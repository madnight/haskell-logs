00:00:56 <ivanm> :o hackagebot is down! how are we meant to know about new software uploads to hackage _now_ then>
00:01:01 <ivanm> s/>/?/
00:01:43 <ivanm> \o/
00:03:38 <trofi> :]
00:03:38 <lambdabot> trofi: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:50:00 <kevinulin> ive been bashing my head on this for a while now, is there a way to tell quickcheck2 to ignore test cases with certain arbitrary values or overwrite th arbitrary definition on a per test basis? I want to have a test that only runs with 8 bit characters
00:51:03 <ivanm> yes, use a -> Property rather than a -> Bool
00:51:52 <ivanm> e.g. : notNullTest as = not (null as) ==> blah as :: [a] -> Property
00:52:12 <ivanm> kevinulin: ^^
00:53:20 <kevinulin> ivanm: thanks i think, i think ill need to do some reading on what it means that a test can return a property and what ==> is, but at least now i have a direction to go
00:53:22 <kevinulin> thanks
00:56:42 <ivanm> kevinulin: see the RWH chapter on QuickCheck
00:56:59 <ivanm> it describes QuickCHeck 1, but the specifications of tests is the same
00:57:12 <ivanm> (main difference between 1 and 2 is that CoArbitrary is in a separate class now)
01:04:01 <kevinulin> oh i see
01:04:33 <kevinulin> prop_t c = ord c <= 128 ==> c /= 'x'
01:04:58 <ivanm> yeah
01:04:59 <kevinulin> someday people are gonna start to run out of arrow shaped things
01:05:06 <ivanm> heh
01:05:16 <ivanm> kevinulin: AFAIK there is no maximum line length...
01:05:26 <lpsmith> the answer,  obviously,  is named arrows
01:05:29 <ivanm> ergo, it is theoretically possible to have infinite ='s in there...
01:07:07 <kevinulin> i hope eventually we get to use multi line ascii art
01:07:15 <kevinulin> as inline functions
01:07:18 <lpsmith> Maybe with some kind of fortress-like graphical presentation of source code so you get something like
01:07:23 <lpsmith>     fin
01:07:27 <lpsmith> A =====> B
01:08:07 <lpsmith> for finite functions from A to B  (I was thinking of B being {0,1},  and the function space being characteristic functions of finite sets)
01:08:58 <lpsmith> epigram uses some kind of multiline ascii art,  I've never used it though
01:09:28 <kevinulin> i just want the orly bird to be an exception handler
01:09:31 <kevinulin> thats all im after in life
01:09:36 <lpsmith> lol
01:10:12 <lpsmith> for a second there I thought you were referring to "To Mock a Mockingbird" and the various bird combinators :-D
01:10:27 <ivanm> @slap kevinulin
01:10:27 * lambdabot clobbers kevinulin with an untyped language
01:26:14 <zeiris> @pl b .&. ((-1) `shiftR` (8-n))
01:26:14 <lambdabot> b .&. (-1 `shiftR` (8 - n))
01:26:27 <zeiris> @pl f b n =  b .&. ((-1) `shiftR` (8-n))
01:26:28 <lambdabot> f = (. ((-1 `shiftR`) . (-) 8)) . (.&.)
01:35:51 <freiksenet> are there anonymous types in haskell?
01:36:33 <aavogt> what is an anonymous type?
01:36:46 <freiksenet> the type that doesn't have a name
01:36:57 <freiksenet> that I can declare once in type signature, for example
01:37:06 <ivanm> not really
01:37:14 <ivanm> what do you want to do?
01:37:18 <freiksenet> bar :: Int -> (Foo | Bar)
01:37:32 <ivanm> bar :: Int -> Either Foo Bar
01:37:32 <opqdonut> bar :: Int -> Either Foo Bar
01:37:35 <aavogt> HList records
01:37:40 <ivanm> @slap aavogt
01:37:40 * lambdabot slaps aavogt
01:38:04 <opqdonut> you can even make an infix alias for either, :|||: or soemthing like that
01:38:04 <freiksenet> thanks :)
01:38:33 <ivanm> freiksenet: after all, does it make sense to have "anonymous" or "throw-away" types?
01:38:46 <ivanm> if it's only defined in one type signature, what is the type of a function that uses it?
01:38:53 <ivanm> @src Either
01:38:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:38:56 <ivanm> bah
01:38:58 <freiksenet> I am having arguments with dynamic typing prononents
01:39:17 <aavogt> @src Dynamic
01:39:17 <lambdabot> Source not found. There are some things that I just don't know.
01:39:35 <freiksenet> they are saying static type system constrains you during development and made example
01:39:42 <ivanm> bull
01:39:46 <freiksenet> (\x -> if x == 1 then 1 else "foo")
01:39:52 <freiksenet> they want this kind of stuff possible
01:39:57 <Jafet> freiksenet, eat some foie gras to annoy them
01:39:59 <ivanm> freiksenet: that doesn't make sense to do
01:40:04 <freiksenet> I agree
01:40:13 <ivanm> Jafet: huh?
01:40:22 <freiksenet> but they seem to say that indeed constrains their freedom
01:40:31 <ivanm> freiksenet: dynamic typing means that anything can happen
01:40:44 <ivanm> and you have to do a lot more casting/checking/etc. to see what you _can_ do with something
01:40:51 <Jafet> Just allow deriving (Obj)
01:41:13 <freiksenet> jafet: ?
01:41:23 <ivanm> Jafet: heh
01:41:52 <freiksenet> ivanm: yeah, I understand that. they are just saying that they don't care during the development and they just want to do whatever they want
01:42:03 <ivanm> freiksenet: then they're stupid
01:42:05 <ivanm> end of argument
01:42:10 <Jafet> ivanm, it's more fashionable nowadays to do it the python way, pretend your code works when you write it and hope it works when you run it
01:42:23 <ivanm> somehow get them to call you a nazi and you win via godwin's law! :p
01:42:31 <ivanm> Jafet: heh
01:42:31 <sykopomp> nazi!
01:42:54 <ivanm> @remember Jafet it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
01:42:54 <lambdabot> I will never forget.
01:43:03 <ivanm> that reminds me... where's the HWN?
01:43:05 <ivanm> preflex: seen jfredett
01:43:05 <preflex>  jfredett was last seen on #haskell-blah 19 days, 17 minutes and 54 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
01:43:13 <Jafet> Also known as "luck typing"
01:43:13 <ivanm> hmmm...
01:43:16 <aavogt> quite the nap
01:43:18 <ivanm> that's a long sleep...
01:43:23 <ivanm> Jafet: heh
01:43:28 <ziman> haha
01:44:25 <aavogt> they want to be free to make mistakes
01:44:40 <aavogt> nobody actually wants to find out that their code is wrong
01:44:45 <opqdonut> they want ad-hoc data structures
01:44:52 <Jafet> OCaml does have proper structural typing (which is what many programmers mean when they say "dynamic typing")
01:44:53 <freiksenet> ivanm: I think their point is that type system is nice on later stages and that you don't want it on early stages.
01:44:55 * ivanm still hasn't decided what to do wrt printing/parsing HTML-like labels in graphviz
01:45:04 <opqdonut> this can be a map of somethings, and I can decide later how to handle those somethings
01:45:09 <kmc> freiksenet, the solution is dependent types ;P
01:45:19 <opqdonut> writign it out as data Something = Foo Int | Bar String | ... just feels bad
01:45:30 <kmc> (\x -> if x == 1 then 1 else "foo") :: forall (x :: Int). if x == 1 then Int else String
01:45:44 <ivanm> freiksenet: whereas many (most?) people here do "type-based programming" where you specify what you want your code to do and then write it
01:45:49 <ivanm> freiksenet: rather than writing your tests first, etc.
01:45:58 <ivanm> basically, how strictly/correctly do you think?
01:46:07 <ivanm> do you plan out what you're going to code, or just write it willy-nilly?
01:46:25 <kmc> it is strange that people want to use the type system as a single global ad-hoc sum type
01:46:51 <ivanm> kmc: heh
01:46:58 <kmc> if your function does one thing for Int and another for String, it should probably be two functions, or one function that takes data WhatToDo = DoThis Int | DoThat String
01:47:00 <freiksenet> I think that's purely subjective. nice that people realize that they do want it at some stages
01:47:54 <freiksenet> thanks, i got reassured about my views.
01:52:42 <kmc> and yes the whole point of static typing is to constrain your freedom
01:56:02 <Jafet> In soviet russia, State safely executes you
01:56:11 <opqdonut> :D
01:56:34 <opqdonut> @remember Jafet In soviet russia, State safely executes you
01:56:34 <lambdabot> I will never forget.
01:56:43 <kmc> wow, a "soviet russia" joke that actually works, like the originals did
01:56:49 <ziman> :D
01:56:49 <kmc> you deserve some kind of Internet medal
02:18:14 <ivanm> preflex: seen waern
02:18:14 <preflex>  waern was last seen on #haskell 5 days, 14 hours, 13 minutes and 41 seconds ago, saying: dankna: off-by-one indexing into a map
02:18:29 <ivanm> anyone here really good with haddock?
02:19:36 <jutaro> ivanm: I just used haddock as a library, so I know some stuff.
02:19:56 <ksf> edwardk, what do you think about making your rope support holes, more element types than Word8 and more indices than Ints?
02:20:04 <ksf> basically, a chunkwise-packed map.
02:20:05 <ivanm> OK, so if I have a constructor and a datatype with the same name, then 'Foo' will link to the datatype
02:20:18 <ivanm> any way of making a link to the constructor with the name of 'Foo' instead?
02:20:28 <ksf> ...well, map based on keys which have a total order.
02:21:22 <jutaro> ivanm: This I don't know. I just looked how to make haddock run.
02:21:31 <ivanm> *nod*
02:21:33 <ivanm> fair enough then
02:21:39 <ivanm> what were you using haddock as a library for?
02:24:36 <jutaro> ivanm: I use it in Leksah.
02:24:52 <ivanm> ahhhh
02:25:00 <ivanm> so you're one of those people that forked haddock?
02:25:38 <jutaro> By the way, I just want to change Leksah. In Leksah when you double click on any word it opens the module browser on the definition, However, when you have more then one definition, it opens  not open a search pane, which give you datatype and constructor as choices. Its not practical to me. So why do you want to change it?
02:26:12 <jutaro> Oh that was mixed up.:-/
02:27:39 <jutaro> ivanM: So I want to say, if you have datatype and constructor with the same name, Leksah now gives you the choice, But it is more convenient to jump to the datatype directly, as the constructor is their as well.
02:27:57 <ziman> ksf, totally ordered and mappable to Int; you probably don't want to index with Double :)
02:28:08 <ivanm> jutaro: well, I don't use leksah... >_>
02:28:15 <ivanm> I care about documentation links! ;-)
02:28:55 <jutaro> ivanm: its your choice. It just reminded me of this.
02:29:50 <ivanm> fair enough
02:30:15 <jutaro> ivanm: But why do you want to change the link from datatype to constructor?
02:30:39 <ivanm> jutaro: because I have quite a few cases of: data FooBar = Foo Foo | Bar Bar
02:30:49 <ivanm> (since I run out of names that make sense...)
02:31:09 <ivanm> so if I want to talk about something specific to the Foo constructor, then atm 'Foo' will link to the datatype definition instead
02:31:24 <jutaro> So Haddock links to the dataype, even if constructors have different names?
02:31:59 <ivanm> no, the constructors from a _different_ datatype have the same name as the name of a datatype
02:33:06 <jutaro> I just was thinking to change it for data Foo = Foo ... in Leksah. So of course this is different.
02:33:49 <jutaro> Have to go now, meet with family
03:21:31 <tomberek> @djinn
03:21:31 <lambdabot> Cannot parse command
03:21:40 <tomberek> @djinn a->a
03:21:40 <lambdabot> f a = a
03:22:07 <tomberek> @djinn [(a,b,c)]->[(b,c)]
03:22:07 <lambdabot> Error: Undefined type []
03:22:32 <tomberek> @djinn (a,b,c)->(b,c)
03:22:32 <lambdabot> f (_, a, b) = (a, b)
03:27:03 <ivanm> wow.... my testsuite failed due to being out of memory... >_>
03:28:15 <DigitalKiwi> ivanm: obviously you just need to get more ram
03:28:24 <DigitalKiwi> then everything will be better
03:28:26 * ivanm has 4GB...
03:28:32 <DigitalKiwi> MOAR RAM
03:28:54 <DigitalKiwi> how much of it are you currently using?
03:29:00 <Ke> 4GB is almost enough, for a cellphone
03:29:01 <DigitalKiwi> or use at idle rather
03:29:47 <ksf> ziman, the main index case I have, beside total ordered, is String. The consideration is that I'd like to have a mostly unified interface for maps with totally ordered keys and non-totally ordered ones, while retaining the possibility to get a whole range out of a totally ordered map, efficiently.
03:30:23 <ivanm> DigitalKiwi: apparently 335 MB
03:30:39 <ivanm> oh, though my OS only accesses 3031 MB of that 4GB
03:30:49 <ksf> e.g. give me files bar through foo out of that directory and give me indices 0 through 1024 of that file have a bit different semantics.
03:30:49 <DigitalKiwi> fail 32
03:31:25 <DigitalKiwi> no PAE kernel for gentoo?
03:31:30 <ksf> ...holes in the directory just being ignored, and holes in the file being either blocked on or filled with 0 or something.
03:32:39 <ziman> i see, so it's not as simple as Ix.
03:34:23 <ksf> ...I think I'm not the first to try to unify directories and files to typed collections, and getting stuck along the way.
03:40:00 <ivanm> DigitalKiwi: I only have the 4GB option enabled
03:40:27 <DigitalKiwi> why does it not see full 4 gig?
03:40:28 <ivanm> (not sure why that doesn't bring in all 4GB, but 64bit OSs don't seem to like this laptop)
03:40:32 <ivanm> *shrug*
03:41:24 <kevinulin> i am trying to figure out why data binary is padding encoded strings with null characters at the beginning, is there a reason for this? and is the behavior predictable?
03:41:25 <arw> shared memory graphics or any reserved areas for textures?
03:41:29 <kevinulin> i mean Data.Binary
03:41:59 <ivanm> arw: shouldn't be any shared memory *shrug*
03:42:56 <arw> ivanm: other than that, there is only the pci address space which eats away some memory, but only in 32bit mode
03:44:46 <ksf> kevinulin, is it utf8-encoding it or something?
03:44:58 <ksf> I suggest looking at the source.
03:45:38 <arw> utf-8 does not contain null bytes except for real end-of-string null bytes for compatibility.
03:45:55 <arw> but utf-16 and -32 can contain null-bytes.
03:45:57 <ksf> little-endian, quite wide length field?
03:46:42 <ksf> I'd be surprised if data.binary uses null-terminated strings
03:46:59 <ksf> ...the whole library generally being LR(0) and stuff
03:47:24 <kevinulin> ill just have another look at the source in the morning
03:47:34 <kevinulin> at this point all the symbols are starting to look as random as perl
03:47:45 <DigitalKiwi> ghc does static linking right?
03:48:38 <aavogt> DigitalKiwi: not libgmp and also not if you choose for ghc-6.12 on linux
03:48:51 <aavogt> but otherwise it statically links stuff
03:49:09 <DigitalKiwi> so on 6,12 you can do shared if you want?
03:49:13 <ksf> kevinulin, it's serializing the length as Int, then utf8 characters.
03:49:30 <aavogt> yes
03:49:34 <DigitalKiwi> ah, k
03:49:35 <ivanm> IIRC glibc is also dynamically linked
03:49:36 <ksf> Int being a damn bad choice
03:50:20 <DigitalKiwi> so ghc compiled programs that use libs only need the libs at compile time \o/
03:50:23 <kevinulin> ksf: thanks, that would explain it, i was just thinking it was just a string of bytes
03:50:28 <ksf> oh wait it's always serializing int to int64, so everything is fine.
04:03:45 <kolmodin> if I want to distribute a package with .hs files precompiled with alex and happy, where do I put these files?
04:03:51 <kolmodin> the .hs files, that is/
04:03:51 <kolmodin> ?
04:05:07 <kolmodin> should I leave them in dist/build/foo/foo-tmp/Path/To/Module ?
04:52:27 <tomberek> i'm checking via ddump and see that a RULE isn't firing.. this is my first try at this, is there a common mistake or step that i might be missing?
04:53:30 <arcatan> tomberek: GHC might inline a function, which prevents a rule for that function from firing
04:54:09 <tomberek> ok, how do i force my rule?
04:54:30 <arcatan> you can prevent inlining with {-# NOINLINE foo #-}
04:56:43 <tomberek> erg, not working
04:58:49 <arcatan> do you run GHC with flags to enable rewrite rules?
04:58:59 <tomberek> -O2 ?
04:59:09 <arcatan> that should work
04:59:27 <tomberek> I see other rules firing, just not mine
05:01:56 <arcatan> well, I don't actually know much about rewrite rules, these are just the mistakes I've stumbled into
05:02:13 <arcatan> but reading the semantics section in GHC's manual was useful for me http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
05:03:26 <ivanm> hmmm.... my test suite is now only taking up about 2G of RAM...
05:03:38 <Zao> DPH?
05:03:44 <ivanm> nope
05:03:57 <aavogt> maybe you should use it then?
05:04:01 <ivanm> *sigh* still going to overflow
05:04:09 <ivanm> aavogt: then how do I test the library?
05:04:53 <Zao> cvs-ghc@ had some amusing reports of DPH testsuites eating memory like no tomorrow.
05:05:02 <Zao> Mostly due to excessive inlining, I believe.
05:06:39 <ivanm> nah, I think my problem is due to excessive recursion
05:07:31 * ivanm tests by replacing the datastructure that has recursion with ()
05:10:36 <ivanm> it's either that or my shrink implementations do too much work
05:12:53 <kynky> is hwn going way of the dodo ?
05:14:05 <ivanm> kynky: methinks jfredett is AFK for a while...
05:14:08 <ivanm> preflex: seen jfredett
05:14:08 <preflex>  jfredett was last seen on #haskell-blah 19 days, 3 hours, 48 minutes and 56 seconds ago, saying: and with that, I bid Adeiu to you, fair Haskellians, I go now to sleep.
05:15:13 <kynky> ivanm, cheers
05:22:14 <kamatsu> it should be possible to automate HWN
05:22:38 <kamatsu> take every ANN topic from haskell-cafe, some of the top-voted haskell reddit submissions, and all remembered quotes from #haskell in the last week
05:23:44 <Jafet> @remember kamatsu it should be possible to automate HWN: take every ANN topic from haskell-cafe, some of the top-voted haskell reddit submissions, and all remembered quotes from #haskell in the last week
05:23:44 <lambdabot> It is forever etched in my memory.
05:23:51 <Jafet> Just in case.
05:25:15 <kamatsu> in case... ?
05:25:37 <ziman> this should be the essence of the hwn script used by the editor
05:28:18 <ziman> at least byorgey mentioned that when looking for a new editor -- that the process was quite automated
05:28:52 <ksf> kolmodin, nope, /dist isn't included when you do cabal src-dist
05:28:55 <kamatsu> well, perhaps it should publish automatically
05:29:08 <ksf> I think the best thing is to copy them over to where the alex and happy files are
05:29:20 <kamatsu> so that if jfredett gets RSI we won't be deprived of it
05:29:26 <ksf> cabal should prefer those over generating them
05:29:48 <ksf> OTOH, all the packages I know of generate them while building
05:30:19 <ksf> alex and happy are after all part of the platform.
05:31:21 <ksf> @tell edwardk what do you think about generalizing your rope to be a map specializing in operations over totally ordered keys?
05:31:21 <lambdabot> Consider it noted.
05:32:38 <tomberek> i can't get a RULE to fire, any ideas? common mistakes?
05:32:56 <ksf> @tell edwardk I ask because read, write and truncate can be generalized to intersect, union and difference
05:32:56 <lambdabot> Consider it noted.
05:32:58 <sioraiocht> tomberek: inlining too early
05:33:17 <tomberek> i've added a {-# NOINLINE
05:33:24 <tomberek> maybe it's in the wrong place?
05:37:15 <kolmodin> ksf: right. although I see people put stuff in their dist/ in their packages, to require fewer deps
05:37:51 <dcoutts> kolmodin: hmm, naughty
05:38:05 <dcoutts> kolmodin: or you mean just alex/happy etc?
05:38:11 <kolmodin> dcoutts: yes
05:38:22 <dcoutts> ok, and cabal should do that automatically
05:38:24 <kolmodin> alex includes files in its dist/
05:38:39 <dcoutts> though probably we should use a different dir, shipped/ or something
05:38:42 <kolmodin> they should be platform independant, so it should be ok?
05:38:57 <dcoutts> right
05:38:57 <kolmodin> right. should it be supported by the tools too, maybe?
05:39:16 <kolmodin> maybe sdist could help with running the platform independant stuff
05:47:08 <kolmodin> dcoutts: it's for haddock, the package always in the centre of circular deps :)
05:47:25 <kolmodin> dcoutts: haddock requires happy, which pulls in mtl. mtl can be built with docs
05:48:01 <kolmodin> dcoutts: so I was thinking of running happy myself and just patch haddock
05:48:23 <kolmodin> dcoutts: but the resulting patch is 25kb, too big for portage... gr... :D
05:48:34 <kolmodin> so I could pack it and put it on the mirrors.
05:48:40 <kolmodin> or... I could bundle mtl with happy
06:12:01 <ski> ivanm : i think it can make sense to have temporary types ..
06:53:44 <aavogt> ski: more so than just Either and tuples?
06:55:24 <aavogt> or like these: http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36 ?
06:57:38 <ksf> kolmodin, I feel your pain. I think we ought to have separate -doc packages
07:00:57 <ksf> ...that is, let foo-doc be a PDEPEND of foo, I think that should work around the circular deps automatically without having to recompile anything or USE=-doc
07:03:17 <EvanR> @src !!
07:03:17 <lambdabot> xs     !! n | n < 0 = undefined
07:03:17 <lambdabot> []     !! _         = undefined
07:03:17 <lambdabot> (x:_)  !! 0         = x
07:03:17 <lambdabot> (_:xs) !! n         = xs !! (n-1)
07:03:27 <EvanR> can i get something like this in ghci
07:04:35 <Jafet> Sure. Make a command that connects to the internet and looks up the source
07:04:35 <ksf> @hoogle (!!)
07:04:36 <lambdabot> Prelude (!!) :: [a] -> Int -> a
07:04:36 <lambdabot> Data.List (!!) :: [a] -> Int -> a
07:04:58 <kolmodin> ksf: I ended up bundling mtl with happy, not too difficult. it's a bit more to maintain though
07:06:05 <EvanR> :list (!!)
07:06:18 <EvanR> cannot list source code for !!: module GHC.List is not interpreter
07:06:20 <EvanR> :\
07:06:46 <Jafet> ghc isn't gentoo
07:06:57 <EvanR> i figured
07:07:05 <EvanR> so where does the bot get these snippets
07:07:18 <Zao> Big text file, I believe.
07:09:06 <EvanR> well thats convenient
07:11:52 <EvanR> it seems that some non IO functions may throw an exception at runtime
07:11:58 <EvanR> like fromJust
07:12:05 <EvanR> for reliability ive avoided using these functions
07:12:21 <EvanR> but im not sure if some functions throw or not. is there a list?
07:12:29 <Jafet> @src fromJust
07:12:29 <lambdabot> fromJust Nothing  = undefined
07:12:29 <lambdabot> fromJust (Just x) = x
07:12:41 <EvanR> > fromJust Nothing
07:12:42 <lambdabot>   * Exception: Maybe.fromJust: Nothing
07:12:57 <Botje> EvanR: types like "[a] -> a" should tip you off
07:13:05 <chrisdone> generally functions like f a -> a are untrustworthy
07:13:12 <Botje> since there no general approach to construct such an a if you only have []
07:13:19 <mauke> :t fix
07:13:20 <lambdabot> forall a. (a -> a) -> a
07:14:02 <chrisdone> ``generally''
07:16:48 <EvanR> ok
07:17:13 <Jafet> > show $ (fix (\n -> 1 + 1/n))::CReal
07:17:14 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
07:17:14 <EvanR> but then theres this
07:17:14 <lambdabot>         against infe...
07:17:20 <EvanR> > [1,2,3] !! -1
07:17:21 <lambdabot>   Precedence parsing error
07:17:21 <lambdabot>      cannot mix `GHC.List.!!' [infixl 9] and prefi...
07:17:25 <EvanR> > [1,2,3] !! (-1)
07:17:26 <lambdabot>   * Exception: Prelude.(!!): negative index
07:17:36 <chrisdone> :t (!!)
07:17:37 <lambdabot> forall a. [a] -> Int -> a
07:17:39 <chrisdone> EvanR: you could assume a list by viewing the Safe package
07:17:43 <EvanR> oh right
07:18:01 <chrisdone> http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html
07:18:22 <EvanR> > head []
07:18:23 <lambdabot>   * Exception: Prelude.head: empty list
07:18:48 <EvanR> not sure if i can avoid this function
07:18:51 <Jafet> @quote ksf RandomRIO
07:18:51 <lambdabot> No quotes match.
07:18:52 <EvanR> just.. .make sure its not empty?
07:18:54 <Jafet> @quote kmc RandomRIO
07:18:54 <lambdabot> No quotes match. Wrong!  You cheating scum!
07:19:07 <chrisdone> headMay :: [a] -> Maybe a
07:19:36 <Jafet> @quote .*randomRIO.*
07:19:36 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
07:19:38 <Botje> EvanR: listToMaybe
07:20:33 <EvanR> :t listToMaybe
07:20:34 <lambdabot> forall a. [a] -> Maybe a
07:20:42 <chrisdone> > do x <- listToMaybe [5]; return (x*5)
07:20:43 <lambdabot>   Just 25
07:20:44 <chrisdone> > do x <- listToMaybe []; return (x*5)
07:20:45 <lambdabot>   Nothing
07:22:02 <EvanR> @src listToMaybe
07:22:03 <lambdabot> listToMaybe []        =  Nothing
07:22:03 <lambdabot> listToMaybe (a:_)     =  Just a
07:23:03 <EvanR> by using maybe in the right places, ive found that the inner code can be made full proof, or am i deluding myself
07:23:08 <EvanR> barring out of memory
07:24:33 <chrisdone> for computations that maybe will return nothing the Maybe monad is perfect
07:25:30 <EvanR> and i had to pay careful attention to cases where something maybe return []
07:26:12 * Botje is torn between finishing paper and project euler
07:26:25 <serhalp> Hello.  How would I go about getting a 2-byte unsigned integer as a [Word8], from an Int64?  e.g. 12 -> [0x00, 0x0C]
07:26:32 <chrisdone> Botje: neither will bring you true love
07:26:53 <EvanR> i did a couple...  f [] = Nothing, f ls = Just ls
07:26:53 <Botje> serhalp: unfoldr + divMod ?
07:27:44 <Botje> chrisdone: time enough for love later: p
07:27:48 <EvanR> does that not make sense, what if it doesnt fit in a 2 byte integer
07:28:14 <chrisdone> EvanR: well, he wants a list of 2-byte integers
07:28:14 <Botje> serhalp: oh, you only want two bytes.
07:28:28 <Zao> serhalp: Mask and shift.
07:28:40 <EvanR> chrisdone: list of Word8...
07:28:49 <EvanR> or is it [[Word8]]
07:28:54 <mauke> no, [Word8]
07:28:54 <EvanR> where each list is 2 long
07:28:59 <EvanR> [(Word8, Word8)]
07:30:48 <serhalp> Zao: that's what I was thinking -- is there no easier way?
07:32:25 <serhalp> We can ignore the case where it doesn't fit.  And we're assuming I just have a single Int64 to convert to a [Word8] of length 2.
07:32:40 <diskie> How it is possible find which packages depends on given package within HackageDB ?
07:32:44 <EvanR> why not a (Word8, Word8)
07:32:55 <serhalp> Because I actually need a ByteString
07:33:04 <Zao> serhalp: You could maybe coerce a Ptr Int64 to a Ptr Word8, and peek in a endian-dependant way.
07:33:12 <mauke> Zao: ew
07:33:18 <Zao> I would go with shifting and masking.
07:33:23 <Zao> Much less slime that way.
07:33:24 <EvanR> serhalp: then its [msb, lsb]
07:33:34 <chrisdone> how do you notate binary in haskell? I always forget this
07:33:37 <EvanR> each of those is a mask shift
07:33:44 <EvanR> or a mask
07:33:48 <Zao> The icky way would require IO, so extra ickyness applies.
07:33:52 <Botje> EvanR: more like second_lsb *ducks*
07:33:57 <EvanR> right
07:34:22 <Zao> chrisdone: As a literal?
07:34:25 <chrisdone> Zao: yeah
07:34:54 <Zao> chrisdone: No such thing built-in.
07:35:01 <Zao> And the hacks to do them tends to be a bit corny.
07:35:02 <EvanR> serhalp: [(foo & 0xff00) >> 8, foo & 0xff]
07:35:06 <EvanR> adjusted for being not C
07:35:07 <Zao> http://www.haskell.org/pipermail/haskell-cafe/2007-October/033726.html
07:35:15 <Zao> .&.
07:35:17 <mauke> and with more fromIntegral
07:35:31 <EvanR> yeah
07:35:41 <Zao> Also, shiftR.
07:35:43 <EvanR> or use divMod
07:35:44 <Zao> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Bits.html
07:39:00 <gwern> Hamming's 'You and your research' is so brilliant
07:39:07 <serhalp> Thanks!  I'll give it a try.
07:39:55 <EvanR> serhalp: so like, you said you wanted to convert something to a [x, y] so.. f something = [x, y], just a matter of writing the expressions for x and y ;)
07:40:04 <chrisdone> gwern: I saw that recommended in Coders at Work. it sounded good. I'll check it out
07:40:08 <gwern> @tell diskie http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
07:40:08 <lambdabot> Consider it noted.
07:40:15 <gwern> chrisdone: I'd read it today
07:42:33 <gwern> chrisdone: http://www.paulgraham.com/hamming.html
07:43:14 <chrisdone> I will read it presently
07:44:29 <gwern> read it anent?
07:44:35 <gwern> er, anon
07:44:40 <EvanR> chrisdone: not sure if there is a binary literal?
07:45:07 * gwern remembers that anent is a preposition meaning 'with regard or relation to; about'; 'anon' is the 'immediately' adjective. darn middle english!
07:45:55 <Botje> is that the english they speak in middle earth?
07:46:16 <gwern> Botje: no. that's the english they spoke 'twixt old and modern english
07:46:45 <gwern> naturlich
07:47:15 <albertlee> say hi to #haskell
07:47:33 <Botje> hello albertlee !
07:49:05 <albertlee> hi.
07:49:55 <QtPlatypus> @src iterate
07:49:55 <lambdabot> iterate f x =  x : iterate f (f x)
07:51:28 <Alpounet> hi there
07:52:05 <EvanR> are lambda abstractions actually useful?
07:52:17 <chrisdone> you mean the syntax? of course
07:52:20 <albertlee> first time here, so , test the famous lambdabot
07:52:34 <Botje> albertlee: go ahead :)
07:52:44 <albertlee> @src head
07:52:44 <lambdabot> head (x:_) = x
07:52:44 <lambdabot> head []    = undefined
07:53:02 <EvanR> chrisdone: well, i seem to often use something like (5 +) or alreadyMadeFunction or moreDescriptiveNameDefinedInWhereOrLet
07:53:03 <albertlee> @help
07:53:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:53:10 <albertlee> @list
07:53:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:53:43 <EvanR> or (functionWhichOperatesOnFunctions alreadyDefinedFunction)
07:53:49 <chrisdone> EvanR: when you are composing a few together it becomes unworkable to define names for everything
07:54:15 <Botje> EvanR: foldl (\a b -> a * 10 + b) 0 nums
07:54:32 <Botje> very clear what that one does :)
07:54:39 <EvanR> yeah good example
07:54:40 <chrisdone> Botje: he means he'd rather write: foldl foo 0 nums where foo a b = a * 10 + b
07:55:02 <EvanR> no, i just havent run into a situation where it would be that small
07:55:24 <Botje> chrisdone: yes, but foldl and friends are often the place where a lambda is just the right mix of syntax / abstraction
07:55:43 <EvanR> cant you write that lambda as a combination of section
07:55:54 <Botje> @pl (\a b -> a * 10 + b)
07:55:54 <lambdabot> (+) . (10 *)
07:55:59 <Botje> you can, but it's a bit hairy :p
07:55:59 <EvanR> :t ((* 10) +)
07:55:59 <albertlee> get a new name need some more work~
07:56:00 <lambdabot> forall a. (Num a, Num (a -> a)) => (a -> a) -> a -> a
07:56:24 <chrisdone> funcThatTakesFunction $ \abc ->
07:56:24 <chrisdone> anotherFunctThatTakesAFunc $ \pie ->
07:56:24 <chrisdone> andSoForth $ \boo -> do
07:56:24 <chrisdone>  return cakes
07:56:31 <Cale> EvanR: Another good example is where you have something like  forM [1..10] $ \x -> do ... stuff involving x ...
07:56:33 <chrisdone> stuff like that is a lot nicer with lambda abstractions
07:57:02 <EvanR> Cale: ok, so $ so you can write a large do expression and not have to close paren, didnt think of that
07:57:24 <chrisdone> EvanR: well consider what I wrote above, how would you write it without lambda abstractions?
07:57:28 <Cale> EvanR: I thought you were asking about lambdas :)
07:57:46 <EvanR> right
07:57:48 <Cale> (note that the lambda is binding the loop variable)
07:58:33 <EvanR> chrisdone: i seem to do that all the time without lambdas
07:58:46 <Cale> It'd be somewhat unwieldy to have to define a separate function and give it a name just to be able to use it in forM -- moreso if there are nested loops.
07:58:56 <EvanR> a $ b $ c $ d where a =...
07:59:24 <EvanR> Cale: right, but in my program so far the function was already defined or easily representable as (f g)
07:59:49 <EvanR> or (f . g)
07:59:51 <Cale> *If* you can obtain a function by partial application of another function, then don't use lambda.
08:00:09 <Cale> But that doesn't always happen.
08:00:13 <EvanR> that too
08:00:43 <EvanR> i think my main problem was that a large lambda was unweildy, but i didnt think of using $
08:01:27 <EvanR> and small lambdas seem to be equivalent to a smaller section expression or a partial or a composition
08:02:46 <Jafet> Slightly offtopic, is there any research on automatically finding code from a specification? Kind of like @djinn, but more general
08:03:49 <albertlee> google, code search?
08:06:18 <albertlee> @pl map (3+)
08:06:19 <lambdabot> map (3 +)
08:13:17 <albertlee> babal
08:13:21 <albertlee> @babel
08:13:22 <lambdabot>   bzzt.
08:13:53 <Botje> @vixen work on paper or finish project euler?
08:13:54 <lambdabot> yes
08:14:00 <Botje> uh. thanks.
08:14:41 <zenso> haha
08:14:43 <zenso> good answer
08:15:15 <zenso> @vixen work on paper xor finish project euler?
08:15:15 <lambdabot> i think you know the answer to that one, silly
08:16:14 <albertlee> i have no paper work.
08:20:13 <dankna> @vixen Finish my SQL parser xor play with ghc-Javscript?
08:20:13 <lambdabot> isn't it obvious?
08:20:15 <dankna> haha
08:20:25 <albertlee> ......
08:20:39 <dankna> what?
08:21:25 <albertlee> @vixen watching movie or read some book?
08:21:25 <lambdabot> let's don't talk about that
08:29:36 <EvanR> is there a way to read a socket with timeout. i could fork a thread to handle the connection, and the rest of the program would be unaffected if the other side decided to send nothing. but the thread would never end
08:30:59 <EvanR> sIsReadable...
08:34:14 <siracusa> EvanR: Why would it never end, you could kill the forked thread after a certain time has elapsed, don't you?
08:34:47 <EvanR> no because nothing is keeping track of all the threads
08:35:09 <EvanR> is easier if the thread handles itself
08:35:14 <albertlee> did the thread know when to exit?
08:35:54 <EvanR> normally it exits after reading the necessary data from the socket, closing the connection, doing an action, and thats it
08:36:25 <EvanR> the reading will block indefinitely if the other side never sends anything, like, a denial of service
08:36:36 <EvanR> which wont be a real denial, it will just build up my threads
08:37:34 <zenso> excuse the ignorance could the thread just timeout and off itself?
08:37:50 <EvanR> that would be good
08:38:08 <EvanR> see original question
08:38:16 <zenso> gotcha
08:38:24 <zenso> the jist of the original question
08:40:13 <EvanR> polling on sIsReadable seems bad
08:41:06 <EvanR> and i guess the answer is 'build up of threads makes no difference'
08:41:16 <EvanR> forkIO is cheap
08:45:04 * hackagebot ghc-syb 0.2.0.0 - Data and Typeable instances for the GHC API.  http://hackage.haskell.org/package/ghc-syb-0.2.0.0 (ThomasSchilling)
08:45:06 * hackagebot ghc-syb-utils 0.2.0.0 - Scrap Your Boilerplate utilities for the GHC API.  http://hackage.haskell.org/package/ghc-syb-utils-0.2.0.0 (ThomasSchilling)
08:47:36 <jlouis> EvanR: System.Timeout
08:48:24 <EvanR> awesome
08:52:17 <aluink> what's a simple way to read in a list of ints from IO...user enteres "54 73 2 100" and i get [54,73,2,100] to work with after
08:52:56 <aluink> getChar and getLine just seem painful...unless i can combine readLine and Read somehow?
08:53:10 <EvanR> well, getLine followed by parsec
08:53:20 <EvanR> if you want to be reliable
08:53:25 <mornfall> map read . words? :)
08:53:28 <aluink> hmmm
08:53:37 <EvanR> i.e. not crap out because the didnt type it exactly right
08:53:47 <monochrom> use parsec or readP
08:53:54 <zachk> a<-getLine; let b=words a;let c=map (\x->read::Int) b
08:53:54 <aluink> i'm not worried about invalid input right now
08:53:57 <monochrom> perhaps readP is easier
08:53:57 <mornfall> But yes, if input validation is a concern...
08:54:07 <mauke> map read . words.
08:54:32 <EvanR> zachk: right. the only problem is the read may throw an exception if its not a number
08:55:16 <aluink> mauke: yeah, i was just thinking of that
08:57:12 <zachk> he said he didnt care about invalid input
08:58:27 <aluink> yeah, i'm judging a programming conest here and they have Java and C++, i'm messing around with Haskell seeing how simpler i can make my solutions
08:58:47 <aluink> the solution is trivial...it's getting the input and generating output that's the difficult part
08:58:53 <aluink> ugh...haskell haskell :D
09:00:32 <EvanR> getting input without regard for reliability should be trivial ;)
09:00:32 <jlouis> aluink: the contest is bad. It should start off: "Here is a BNF for a language X. Write a parser for the language"
09:01:49 <aluink> jlouis: yeah, the contestants are NOT ready for that kind of problem
09:02:12 <aluink> they are either first year programming students or just getting into DataStructures class
09:03:19 <mxc> is there a way to get the fixity of an operator in ghci?
09:03:54 <Icewing> :i (+)
09:04:16 <Icewing> @info (+)
09:04:16 <lambdabot> (+)
09:05:46 <monochrom> aluink: I once wrote http://www.cs.toronto.edu/~trebla/dplpc/ReaderMonad.lhs for this purpose.
09:06:46 <monochrom> But perhaps today readP is better.
09:07:15 <aluink> monochrom: cool!
09:07:24 <Reisen> What's the best way to remove all --user packages and libraries that might've been installed through cabal?
09:07:25 <aluink> you went to Toronto U?
09:07:32 <monochrom> Yes.
09:07:34 <Vanadium> rm -Rf ~/.cabal
09:07:48 <Vanadium> And possibly convince ghc that they left, somehow
09:08:12 <dankna> of course you might want to save your ~/.cabal/config first
09:08:14 <dankna> if you edited it
09:08:30 <Reisen> I did not but, that'll clear my ghc-pkg right? It won't think packages are registered which don't exist?
09:08:40 <dankna> I've done it and it appeared to work
09:08:44 <Reisen> Hang on then
09:08:56 <dankna> you can check with ghc-pkg list
09:09:09 <dankna> in the worst case you should just need to find where the per-user ghc-pkg file is and delete that too
09:09:13 <Alpounet> you can in the worst case 'ghc-pkg unregister' them
09:09:13 <dankna> but I think it's in .cabal
09:09:14 <albertlee> I meet some error when i use cabal install tabular
09:09:37 <albertlee> say, fcntl_read redef blabla error
09:09:42 <aluink> monochrom: cool, i'm from eastern Ontario
09:09:46 <Reisen> Still lists the packages, listing: .ghc/i386-linux-6.12.1/package.conf.d
09:09:48 <aluink> not there now though :(
09:09:53 <Reisen> Can I safely remove that file without anything breaking?
09:10:26 <Reisen> Oh, dir
09:10:38 <mreh> how would you define a binary relationships as a function? I've got to enumerate all the possible ways objects interact, that's a factorial number of interactions if I do the comparisons step-wise recursively
09:12:19 <mreh> is that a correct analysis?
09:13:09 <jmcarthur> wouldn't it be n^2?
09:13:29 <dankna> Reisen: very probably yes
09:13:55 <dankna> but no deposit no return and all that :)
09:15:14 <Reisen> All clean, thanks dankna
09:15:25 <Reisen> Had to ghc-pkg recache, was confused for a while :o
09:15:55 <dankna> ah, good to know
09:15:57 <dankna> welcome
09:18:43 <mreh> jmcarthur, yeah, you're right
09:19:29 <mreh> there are n! comparisons
09:20:06 <mreh> wait, it should be n^n]
09:20:24 <mreh> n^n definitions of interactions counting symmetry
09:22:49 <mreh> I'm talking about two different n's
09:30:59 <byorgey> mreh: I don't understand what you are trying to do.
09:33:23 <ben_m> Greetings! Is there an editor for Haskell that has support for automated unit tests? Something as simple as a key I could press to run the tests would suffice...
09:33:53 <ben_m> I could write it on my own, but I'd rather not :D
09:34:20 <byorgey> ben_m: if any does, it would be leksah
09:34:27 <byorgey> but I don't actually know whether it has that feature
09:34:43 <byorgey> if not, you could add it and submit a patch =)
09:35:02 <ben_m> Leksah probably has no Emacs/VIM keybinds, does it?
09:36:54 <zygoloid> mreh: binary relations are (a, a) -> Bool. so there's 2^(n^2) of them, where n = |a|.
09:38:07 <twink> 2^((n*(n-1)) `div` 2) ?
09:43:14 <zygoloid> twink: for a reflexive, symmetric relation.
09:45:42 --- mode: calvino.freenode.net set +o ChanServ
09:48:37 <Jafet> If I asked a slightly offtopic question about two hours ago and someone answered, could they kindly answer again?
09:48:52 <Zao> No, you can't have a pony.
09:49:10 <Jafet> I don't remember asking for ponies
09:49:50 <Entroacceptor> that's why we do remember it
09:49:57 <Entroacceptor> so you don't have to.
09:50:01 <stevenmarky> [14:04] <Jafet> can i has a pony
09:50:01 <Zao> 17:03 < albertlee> google, code search?
09:50:16 <Zao> No other replies, unless the @pl slightly below was intended for you.
09:51:10 <Jafet> Damn buggy ethernet, turning all my questions into requests for ponies
09:51:31 <Entroacceptor> have a broadcom card? You might have gotten hacked ;)
09:52:34 <Jafet> I take it, then, that no one knows of any work on deriving code from specifications.
09:52:59 <mxc> jafet - you mean like djinn?
09:53:17 <mxc> @djinn Either a b -> a
09:53:25 <Jafet> Yes, like djinn.
09:53:27 <aavogt> -- f cannot be realized
09:54:08 <Jafet> f (Left a) = a; f (Right b) = undefined
09:54:09 <mxc> so i guess if you know of djinn, your knowledge on hte subject is equal to or greater than mine
09:54:32 * hackagebot chp-plus 1.2.0 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.2.0 (NeilBrown)
09:54:37 <Jafet> Well, knowing the name of the field that studies this would be helpful
09:54:40 <aavogt> right, but djinn doesn't do partial functions
09:55:05 <aavogt> Jafet: you've read theorems for free?
09:55:25 <Jafet> Nope!
09:55:49 <Jafet> Did they change back to the old ircd or what
09:57:28 <Jafet> I was thinking of how it could be extended to, say, dependent types
09:57:49 <Jafet> Which is undecidable in general, but might be solvable for many inputs
10:06:39 <edwardk1> preflex: xseen ksf
10:06:40 <preflex>  ksf was last seen on freenode/#haskell 3 hours, 2 minutes and 4 seconds ago, saying: @hoogle (!!)
10:08:30 <edwardk> ksf: i started converting Data.Rope over to supporting the various vector types in Data.Vector, which will address your ropes of things other than Word8's request, but the non-Int indices bit is a bit more difficult.
10:10:05 <ben_m> weechat filter's them out
10:17:41 <sl1011> .
10:17:51 <ben_m> ,
10:18:41 <Philonous> Isn't it a little strange to have a "download haskell" button on the haskell.org main site?
10:19:06 <fax> more than a little strange
10:19:35 <Philonous> Yes, actually, it's rather solly
10:19:36 <monochrom> Not strange at all if you relax natural language semantics.
10:19:38 <Philonous> silly*
10:19:51 <arw> perl.org has one, too :)
10:20:09 <Entroacceptor> don't you know Matrix?
10:20:12 <Philonous> perl.org has a "download haskell" button? How nice of them :)
10:20:18 <monochrom> hahaha
10:20:24 <edwardk> Philonous: if you consider it from an adoption standpoint it would seem a little strange _not_ to have a big bold button on the main haskell.org site ;)
10:20:34 <Entroacceptor> and still the ugly red
10:20:59 <Philonous> edwardk: I'm not concerned about the big button part, but the idea to download a language rather than a compiler.
10:21:02 <edwardk> Philonous: no, but they do have a huge download perl right in their logo ;)
10:21:31 <edwardk> Philonous: 'download the haskell platform' makes a pretty verbose button
10:22:01 * boegel loves the Haskell Platform
10:22:09 <arw> Philonous: i find something like that helpful. while i know there might be several compilers, implementations and library packages, i'm primarily interested in the 'recommended' one, at least as a first-time clueless user.
10:22:12 <boegel> installation went really smooth @ OS X Snow Leopard
10:22:19 <edwardk> Philonous: and to much of the target demographic, the distinction between the language and a particular implementation has not yet been made
10:22:56 <edwardk> boegel: yep
10:23:02 <Philonous> edwark: I see the predicament. Yet it reinforces the idea that ghc=haskell
10:23:28 <jlouis> edwardk: and in addition, to those that knows of the distinction, some people doesn't care
10:24:06 <Philonous> edwardk *
10:24:33 <jlouis> ardwark?
10:24:34 <edwardk> jlouis: Fair enough. i probably damage my credibility in this argument by stating that i've pretty much given in to the ghc = haskell front until someone else implements type families and all the interesting bits ;)
10:24:49 <jlouis> edwardk: me too :)
10:25:23 <jlouis> it did not take long before the first LANGUAGE pragma hit my code either
10:26:59 <edwardk> Philonous: while ghc isn't haskell it is really the first direction you should point users towards that supports a robust user experience. debugging, portability, performance, features. Once they've gained some experience with the language, then expose them to options. But keep in mind for every link you make people click through you lose something like 30% of your potential audience.
10:27:48 <bremner> its all part of the avoiding success at all cost manifesto.
10:28:04 <edwardk> bremner: then clearly we need to load up the page with more links ;)
10:28:37 <bremner> make people take a quiz on category theory before they can click through
10:32:04 <arw> also, nothing compares to ghc performance-wise.
10:38:12 <Philonous> edwardk: Of course we need a big, colorful button that reads "Download!" prominently placed on the haskell home page. I just deemed it silly that it reads "download haskell". But it doesn't matter much
10:38:47 <fax> Philonous: I agree that it's silly -- maybe email the web designer?
10:39:49 <chrisdone> python web site says "download python" and the ruby web site says "download ruby". there are different implementations of both languages, just like ghc -- are those silly?
10:39:52 <edwardk> "Download!" of course begs the question of 'what?' ;)
10:40:33 <fax> edwardk, good point -- itshould say "Download it!"
10:40:39 <edwardk> fax: =)
10:41:34 <sm> I think the platform page and haskell.org page should merge
10:42:09 <sm> I mean, the content of the platform page should be incorporated within haskell.org front page
10:42:13 <edwardk> given two positions, one of which already has a button on the home page, and the other which requires action, I tend to default to the one that lets me sit on my ass and argue on the internet. ;)
10:42:25 <chrisdone> edwardk: in Don't Make Me Think it is claimed that a user will mindlessly click tonnes of links as long as it is straight-forward
10:42:28 <Philonous> edwardk: Please disregard my comment. It wasn't really meant seriously. It's just that I like my bike sheds green.
10:42:49 <edwardk> Philonous: no worries. i'm sitting here waiting for stuff to compile ;)
10:43:09 <stevenmarky> I think the background of the page should flash all the colors of the rainbow and the button should have a picture of a topless girl on it
10:43:34 <edwardk> chrisdone: it depends on how invested you have the user. if they are just taking a cursory glance at something it is a bit different than if you've already got them neck deep in farmville ;)
10:43:39 <Cale> also, sparkling unicorns
10:44:01 <edwardk> stevenmarky: then do the css design and present it to the community. I'm sure they'll love it ;)
10:44:13 <Philonous> stevenmarky: We need bitches on the front page. Golden retrievers, preferably.
10:44:36 <edwardk> stevenmarky: though, in the interest of being tasteful, the girl should only become topless once you hover over, or better yet, click the link
10:44:46 <Cale> Let's steal BONUS' twitter background for the Haskell front page.
10:44:53 <Cale> http://a3.twimg.com/profile_background_images/75161063/81ced870c37efd64bf957aff6cf91437ddb588c3.gif
10:45:08 <edwardk> cale: we're coming up on Apr 1 ;)
10:45:10 <jlouis> Cale: haha
10:46:06 <chrisdone> edwardk: well, it's about achieving a goal. people only get deterred if they don't think they'll achieve the goal without thinking about it. clicking a few *obvious* links is no mental effort or time
10:47:33 <Cale> I think we should force people to think hard from the beginning, to get them warmed up.
10:47:55 <bremner> Cale: hence my proposal for category theory pop-ups
10:47:56 <chrisdone> maybe haskell.org should redirect to project euler
10:47:56 <fax> beginning of what??
10:48:02 <bremner> life
10:48:04 <Cale> Maybe put the GHC and Platform downloads behind some kind of mathematical puzzle.
10:48:04 <edwardk> bremner: hahah
10:48:22 <edwardk> bremner: category theoretic 'Did you know?' or 'Fact of the Day' dialogs?
10:48:33 <fax> Cale, ooh let's use 'Make' as the build system
10:48:34 <Philonous> Cale: Don't you think we are already pretty good at avoiding success?
10:48:52 <Cale> "Determine the homotopy group of this surface: <picture of randomly generated surface>"
10:48:55 <edwardk> Philonous: not lately =/
10:48:58 <ddarius> edwardk: How long is stuff taking to compile?
10:49:07 <Philonous> edwardk: Oh, what happened?
10:49:07 <edwardk> ddarius: its ghc, you tell me ;)
10:49:16 <edwardk> Philonous: that pesky real world haskell book ;)
10:49:55 <Cale> Hehe, "To prove you're human..."
10:49:56 <Cale> just to make it a little more insulting to those who fail ;)
10:50:07 <edwardk> cale: hahahaha
10:50:15 <edwardk> category theory captcha
10:50:21 <SamB_XP_> Cale: shouldn't it be "to prove you're inhuman"?
10:50:26 <edwardk> don't let ddarius write it though, or we'll all fail
10:50:51 <ddarius> So couldn't you represent a polynomial category as a fibration?
10:51:30 <edwardk> my point ;)
10:51:48 <fax> what the heck is a polynomial category? :)
10:52:01 <fax> this is a bit scary http://en.wikipedia.org/wiki/Category:Polynomials
10:52:05 <fax> there's too much on this page
10:53:37 <ddarius> Consider a category C with a terminal object, attach an arrow x : 1 -> A to it (normally notated C[x:A])
10:54:23 <ddarius> It's one way of modeling parameterization.
10:55:03 <clanehin> I do have to ask, having just installed 6.12, what billion dollar rocket ship crashed because of an unused do binding?
10:55:43 <monochrom> My idea of human detection: "prove or disprove this logic formula", with a link "translate to English".
10:57:58 <edwardk> monochrom: if nothing else it might work as a mathematician's version of google goggles.
11:01:42 <chrisdone> I like this ruby -> haskell stuff. use rails but write haskell? I must investergheit
11:06:06 <Spockz> Has anyone else noticed that maps run over list with parListChunk drop down in cpu usage from 100*n to about 100% over time?
11:10:06 * zachk pings
11:10:40 * Spockz pongs
11:10:46 * elly pongs as well
11:11:07 * chrisdone falls
11:11:17 * Spockz extends a rope
11:11:26 * monochrom detects for humans
11:11:42 * elly hides from monochrom!
11:12:56 <chrisdone> so is anyone working on a proper nice home page design for haskell?
11:13:50 <ddarius> chrisdone: You realize the current homepage is a wiki page?
11:14:03 <chrisdone> ddarius: so?
11:14:13 <Entroacceptor> wikis don't have to look ugly
11:14:31 <Spockz> do we have a ruby/rails person here? Those are famous for their designs :)
11:14:32 <SamB_XP_> chrisdone: what mean you by "proper"?
11:14:51 <SamB_XP_> Space: do they specialize in trainwreck designs ?
11:14:54 <SamB_XP_> er. Spockz
11:14:56 <ddarius> Entroacceptor: I agree, but it does dictate some aspects of the appearance.  The current page isn't horrible.
11:15:00 <siracusa> Can users change the CSS of the Haskell wiki?
11:15:03 <chrisdone> SamB_XP_: done by a designer, not a programmer who's pretty good with gimp/photoshop
11:15:21 <Spockz> SamB_XP_: Well they are hefty enough :0
11:15:26 <Entroacceptor> ddarius: no, they don't
11:15:27 <SamB_XP_> we don't really want photoshop or the gimp involved much here, I think
11:16:41 <chrisdone> we could have another poll but for designs, like the logo
11:17:52 <SamB_XP_> preferably hosted somewhere that can handle the traffic ;-)
11:18:16 <fax> http://hackage.haskell.org/platform/icons/button-100.png
11:18:37 <fax> even tohugh it's a wiki I think only one could change that to say 'Haskell platform'
11:18:43 <fax> (whoever has the source files)
11:18:49 <monochrom> Is it better to have an artist pretty good at javascript, or a programmer pretty good at gimp? XD
11:19:17 <chrisdone> monochrom: the former -- at least you can tell him he's doing it wrong
11:19:28 <SamB_XP_> I'd prefer a designer competent with HTML
11:19:34 <ddarius> The former because who needs javascript?
11:19:47 <Entroacceptor> I think the button is okay
11:19:58 <Entroacceptor> it takes you to 'get the platform' anyway
11:20:37 <Entroacceptor> except that site should tell what the platform actually _is_
11:21:08 <Entroacceptor> ok, it does, but a short list, maybe?
11:21:33 <Entroacceptor> and 'batteries included' is lame, that's stolen from python
11:22:23 <ddarius> Entroacceptor: Python stole it from others, so?
11:23:47 <monochrom> Apple stole it from Xerox PARC.
11:25:19 <SamB_XP_> ddarius: ITYM to say the others stole it from Python
11:26:02 <ddarius> SamB_XP_: Others have stolen it from Python but the saying has been around longer than Python has existed.
11:26:08 <monochrom> "I tease your mother"?
11:26:49 <SamB_XP_> ddarius: oh, well, I first heard it about Python
11:26:58 <chrisdone> the haskell home page could have a slide show of pictures from events. impression: awesome and active community
11:27:02 <monochrom> I imagine one day we speak in acronyms exclusively.
11:27:13 <monochrom> IOW, IIODWSIAE
11:28:00 <chrisdone> monochrom: I imagine we'll speak in lower case only, and without commas, so: iow iiodwsiae
11:28:29 <monochrom> uppercase for the transitional period
11:28:30 <SamB_XP_> chrisdone: please no slideshows!
11:28:44 <SamB_XP_> some of us don't have much RAM, you know
11:28:45 <Igloo> Are you guys still on first-order acronyms?
11:28:46 <Igloo> ii
11:28:46 <Cale> The previous uses of "Batteries Included" as well as the idea for the 1987 movie "Batteries Not Included" were stolen from Python by time travellers.
11:29:24 <SamB_XP_> Cale: hmm, I thought the term "batteries not included" was from TOY COMMERCIALS on TV
11:29:58 <monochrom> It was from lawyers.
11:30:29 <monochrom> Everything was stolen from lawyers and legalese.
11:31:41 <shapr> preflex: @seen lambdabot
11:31:41 <preflex>  lambdabot was last seen on #haskell 2 hours, 27 minutes and 25 seconds ago, saying: (+)
11:33:41 <ddarius> fax: How knowledgeable are you about Skolemization?
11:33:56 <monochrom> w00t, skolemization
11:34:28 <fax> ddarius, I guess it's to do with getting rid of Exists by using functions but I couldn't do any of the problems in my book on it
11:34:53 <TomMc> Hi. I've been trying to compile gtk2hs on Snow Leopard+GHC 6.12.1. Anyone here had success doing that? Starting to think it'll be easier to do haskell work in virtual-box haha.
11:35:09 <ddarius> fax: Skolemize the definition of universal arrow some day.
11:35:38 <fax> ill try it once I get to finding out what that is :D
11:35:50 <shapr> I like bone skolems best.
11:36:06 <byorgey> maybe it should just say "CLICK HERE!!1"
11:36:31 <byorgey> in reference to the button on the Haskell page
11:36:33 <ddarius> byorgey: That thought had occurred to me.
11:36:43 <ddarius> "Just click this."
11:36:54 <dcoutts_> TomMc: there's no release of gtk2hs that works with 6.12 yet. It works fine with 6.10. If you're desperate to use 6.12 then you need to build the darcs version of gtk2hs from source.
11:37:35 <byorgey> I just built darcs gtk2hs from source the other day, it's not hard
11:38:15 <monochrom> Hahaha byorgey++
11:39:07 <TomMc> dcolish: Yeah tried that, since an announcement was it'd been patched.  Ultimately fails with unable to load System.Glib.UTFstring.
11:39:18 <chrisdone> research shows "click here" makes people click the link more than not
11:39:31 <SamB_XP_> since when ?
11:39:56 <chrisdone> SamB_XP_: want the link?
11:39:58 <clanehin> actually, better than "download Haskell" might be "interact with a haskell interpreter in your browser"
11:40:09 <clanehin> if the goal is to hook newbies.
11:40:30 <clanehin> unless they just want to run xmonad.
11:41:13 <monochrom> I believe in higher-order logic. Skolemization to me is not erasing ∃; it is moving inner ∃ to outer, i.e., ∀x∃y.B(x,y) = ∃f∀x.B(x,f(x))
11:42:29 <fax> monochrom is that accurate though?
11:42:44 <ddarius> monochrom: Isn't that still a statement of first order logic?
11:42:48 <monochrom> People trapped in first-order logic have to move that ∃f to their meta-logic. And so they slyly believe in higher-order logic too, in their meta-logic.
11:42:57 <fax> hm
11:43:26 <ddarius> monochrom: Everyone believes in higher order logic.  Set theory is just an implementation of higher order logic on first order logic.
11:43:38 <monochrom> On a tangent, I also believe that people believe in excluded middle somewhere in their meta-logic.
11:44:13 <ddarius> There's nothing wrong with using excluded middle in some contexts and not in others.
11:44:44 <ddarius> And anyway, at the propositional level at least, there's no problem with it.
11:45:12 <fax> why would anyone beleive in excluded middle? :P
11:45:26 <monochrom> I agree. But someone here explicitly said "excluded middle is so strange. how can anyone believe in it?"
11:45:44 <ddarius> There are two types of people in the world: those who believe in excluded middle and those who don't
11:45:48 <fax> I don't know how anyone can beloeve in it either
11:45:49 <fax> hehe
11:46:22 <ddarius> I believe in the right logic for the right job.
11:46:34 <monochrom> Clearly, at a meta-enough level, every logic either has excluded middle or doesn't have.
11:47:23 <SamB_XP_> monochrom: only if the meta-enough level has excluded middle, I think?
11:47:59 <monochrom> I believe that each person has a meta-enough level in him/her that has excluded middle.
11:50:49 * SamB_XP_ returns -+-
12:03:59 * ddarius considers making an introduction to category theory that solely uses internal languages.
12:05:01 <fax> yay I think great idea
12:09:05 <krasno1> @type fromMaybe
12:11:43 <edwardk> hrmm can anyone think of a good reason why OptDescr, ArgOrder, and ArgDescr in System.Console.GetOpt are not Functors?
12:12:51 <edwardk> i have a bunch of modules that each define some options, i'd like to be able to roll them all up into a bigger bag of options by injecting them into a larger sum type
12:13:06 <byorgey> edwardk: because no one ever really thought about modifying them once they are created?
12:13:29 <byorgey> oh, you asked for GOOD reasons =)
12:13:38 <edwardk> byorgey: =)
12:13:56 <edwardk> byorgey: it strikes me as reasonable anyways that they should be functors
12:14:18 <ddarius> edwardk: If they can be made into functors at all, then they should be functors.
12:14:20 <byorgey> indeed. it certainly wouldn't hurt anything.
12:14:24 <edwardk> ddarius: yeah
12:14:40 <byorgey> and they can pretty clearly be made into functors.
12:14:50 <edwardk> http://cvs.haskell.org/Hugs/pages/libraries/base/System-Console-GetOpt.html#t%3AArgDescr all occurrences of 'a' are in a strictly positive position
12:15:42 <edwardk> i'll poke the libraries@ mailing list when i get some downtime, and in the meantime i'll just cobble together a workaround for my immediate needs
12:20:02 <edwardk> hrmm, does anyone know if there is a baked in library somewhere for accessing locale info?
12:20:16 <edwardk> i find System.Locale in old-locale but it just provides localized time
12:20:18 <jlouis> edwardk: i18n perhaps on hackage?
12:20:27 <edwardk> jlouis: cool. checking
12:21:20 <jlouis> If it is there, I would presume that package has it
12:21:52 <edwardk> seems kinda minimal right now. just support for reading PO files
12:21:58 <edwardk> and using them for println, etc.
12:23:13 <edwardk> wish i'd spotted this before i wrote my diagnostic code though, i wound up reinventing most of this
12:23:54 <edwardk> (though my implementation would require you to patch the compiler to add a new localization)
12:24:22 <SamB_XP_> ????
12:25:07 <edwardk> SamB_XP_: ???? ?
12:25:44 <SamB_XP_> edwardk: why would it be necessary to patch the compiler ??
12:28:01 <edwardk> samb: i'm using localized error messages in the kata compiler. at compile time i use the c preprocessor to read a Diagnostics.def X-macro file that contains macros that describe each diagnostic message. i expand that out into a data definition for a DiagnosticLocale,  a default DiagnosticLocale for english, a map of diagnostic names to their kinds , and a bunch of kinds with their default error level, and a bunch of 
12:28:07 <edwardk> er that probably got cut off
12:28:34 <edwardk> from the middle:  a default DiagnosticLocale for english, a map of diagnostic names to their kinds , and a bunch of kinds with their default error level, and a bunch of methods that return the appropriate diagnostic message
12:29:23 <Saizan> oh, "compiler" is the application you're writing in haskell where you need this, not the program that compiles it
12:29:34 <edwardk> so you can then install the appropriate locale in the compiler's q monad and the diagnostic subsystem will use it to format messages appropriately. since most diagnostics refer to ranges in the source file this works well so far
12:29:38 <edwardk> yeah
12:30:47 <edwardk> adding a new locale to the compiler requires instantiating a DiagnosticLocale with appropriate message handlers, and of course you can just start from the default english locale and use record selectors to substitute your own messages.
12:31:10 <SamB_XP_> edwardk: so it's not exactly as simple as gettext, say
12:31:17 <edwardk> yeah =)
12:31:33 <edwardk> because you can use arbitrary higher order functions in the formatting, to pluralize, etc. according to your locale
12:32:16 <edwardk> and this way i get a type checker to tell me that you used the arguments
12:32:39 <edwardk> perhaps it is a bit over-engineered
12:34:01 <edwardk> the main compiler monad then supports throwing these diagnostics or just tell'ing them, collates them appropriately and feeds them out to whatever diagnostic handler was specified, which either pretty prints them or serializes them, etc.
12:34:14 <sm> edwardk: re getopts, maybe you can do it with cmdargs ?
12:34:31 <edwardk> sm: possibly. i just like GetOpt ;)
12:34:57 <edwardk> sm: for now i just defined mapFoo for each of the getopt structs that didn't think to implement Functor.
12:35:26 <sm> I do too, but cmdargs made my code simpler and so far doesn't constrain me too much
12:35:49 <edwardk> checking it out
12:35:52 * sm suspects we should push it as the standard way to do args
12:36:23 <benmachine> isn't cmdargs the impure one
12:37:25 <edwardk> cmdArgs needs way better documentation from what I can see. it looks sexy, but i'm having trouble puzzling it out
12:37:36 <sm> I thought the docs were pretty good
12:37:56 * sm followed all links from http://hackage.haskell.org/package/cmdargs
12:38:42 <edwardk> http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm is what i needed =)
12:38:59 <deech> Hi all, posts I make to fa.haskell through Google groups don't show up in the Haskell-Cafe archives (which is probably why I don't get responses). Anyone else have this problem? When I post to beginners@haskell.org everything is fine.
12:39:44 <sm> yes, that should be better linked
12:39:59 <sm> (edward)
12:40:59 <benmachine> cmdargs exports global variables :(
12:42:06 <edwardk> sm: the Maker example there is exactly what i needed. the main executable runs cabal style with several basic commands, which each have their own options (-Werror, etc.)
12:42:27 <sm> great
12:42:41 <benmachine> well I guess that's okay since getArgs is already global, sort of
12:43:05 <deech> Is there a way around this problem? For instance I added a response to this thread: http://www.haskell.org/pipermail/haskell-cafe/2010-March/075250.html which shows up in the Google group but seems to have been ignored by other posters.
12:43:47 <Igloo> Is it actually supposed to be 2-way?
12:43:49 <edwardk> deech: i haven't experienced then problem you are having, but that doesn't mean much
12:43:52 <Cale> deech: Have you tried just posting to the mailing list directly?
12:44:25 <edwardk> (mostly because i haven't tried to do that) ;)
12:45:20 <deech> Cale: No. I just now investigated the issue. So Google groups is unreliable?
12:45:23 <FliPPeh> Hey, the Haskell Platform has been updated!
12:45:32 <FliPPeh> I just noticed.
12:45:35 <Cale> deech: I haven't used it.
12:45:47 <Eelis> FliPPeh: does it run on exotic distro's like ubuntu and suse yet?
12:45:57 <FliPPeh> Eelis: No idea, I'm an Arch Linux user
12:46:16 <FliPPeh> The AUR package is not up to yet, sadly.
12:46:16 <Cale> deech: Mostly I just use the mailing lists via email as usual, and they've always worked for me that way.
12:47:09 <ksf> edwardk, if you want more than .po files, use grammatical framework.
12:47:17 <deech> I see, so I guess I'll use the mailing list. Thanks!
12:48:52 <edwardk> ksf: i kind of like having minimal dependencies and the type safety of my current solution
12:50:16 <ksf> but grammatical framework is functional functionality overkill!
12:50:57 <i_am_neuron> Hi folks, I'm trying to understand the State monad and want to write the stateful 0-based accumulator with two functions addToSum and getSum. This is how far I got: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24475#a24475, but now I'm getting the type inference errors. Any help here?
12:52:37 <fax> i_am_neuron, you use put wrong,
12:52:38 <fax> :t put
12:52:54 <FliPPeh> What's better, installing the haskell platform by cabal, or the native package manager?
12:53:10 <FliPPeh> Because cabal does work, the package manager does not. Not up to date.
12:53:19 <ksf> use you package manager to install cabal-install, then go from there.
12:53:38 <lpsmith> i_am_neuron,  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24475#a24475
12:53:51 <i_am_neuron> fax: Aha, so having r + i as an argument there should be enough, right?
12:54:04 <edwardk> FliPPeh: well, generally if one works and the other doesn't, i prefer the path that does. ;) depends on your definition of 'better' =)
12:54:14 <fax> i_am_neuron, lambdabot isn't telling the type :(
12:55:35 <FliPPeh> edwardk: Well, my definition of "better" is "cleaner". I have experienced, that with non-native packages installation, the system gets too cluttered with stuff the central management has no idea of where they belong, and thus will have to be manually installed sometime later
12:55:57 <i_am_neuron> fax: put :: (MonadState s m) => s -> m () :)
12:56:05 <ddarius> fax: lambdabot isn't here
12:56:18 <FliPPeh> regex-posix-0.94.1 failed during the building phase. The exception was:
12:56:18 <FliPPeh> ExitFailure 1
12:56:19 <i_am_neuron> fax: I tried, and r + i made typechecker happy, thanks!
12:56:23 <FliPPeh> Cabal is off, too
12:56:42 <edwardk> FliPPeh: well, in general your native platform package manager is the right way to go if you use a lot of out of the box apps installed by your platform. in practice i find there aren't enough haskell apps in most linux distros that that is a limiting factor for me
12:57:26 <FliPPeh> edwardk: Not a factor here, Arch Linux AUR basically has 80% of hackage packages, and I think one of the AL-devs is a haskell fan, too
12:57:26 <Saizan> cabal-install defaults to installing in your $HOME/.cabal/ so it shouldn't be so bad anyway
12:57:40 <SamB_XP_> FliPPeh: only one ?
12:57:50 <FliPPeh> I have no numbers ;d
12:57:52 <edwardk> heya saizan
12:58:15 <i_am_neuron> fax: What still bothers me however, is how should I specify that accumulator is 0-based? I have r <- get in the getSum, could it be that there's no state returned by get?
12:58:25 <fax> what does 0 based mean
12:58:37 <Saizan> edwardk: hi
12:58:52 <fax> i_am_neuron, you will have to put 0 into runState
12:59:05 <i_am_neuron> fax: if I'm invoking getSum before I actually invoked addToSum at least once, I expect this to retrun 0
12:59:37 <FliPPeh> Cabal installing regex-posiy fails
12:59:43 <FliPPeh> Text/Regex/Posix.hs:67:7: Could not find module `Text.Regex.Base'
12:59:46 <ddarius> i_am_neuron: When you run the state computation, you will specify the initial state.
12:59:48 <FliPPeh> but base is installed :/
13:00:14 <ddarius> i_am_neuron: One thing to note, the State monad provides you with a -single piece- of "mutable" state.
13:00:29 <Saizan> FliPPeh: regex-base ?
13:00:31 <FliPPeh> Oh well
13:00:34 <lpsmith> i_am_neuron, it'll look like "runState (addToSum 10) 0",  or "runState (addToSum 10 >> addToSum 20) 0"
13:00:39 <FliPPeh> Saizan: I just fixed it, just reinstalling did it
13:01:00 <FliPPeh> But it's breaking everywhere :(
13:01:04 <i_am_neuron> ddarius: I don't really understand where runState is defined.
13:01:09 <FliPPeh> haskell-platform-2010.1.0.0 depends on haskell-src-1.0.1.3 which failed to
13:01:10 <FliPPeh> install.
13:01:28 <ddarius> It's defined in the same module as State.
13:01:56 <i_am_neuron> ddarius: This is what Wikibooks are saying: newtype State state result = State { runState :: state -> (result, state) }. Not sure how could I redefine it to return 0 when no state are accumulated yet
13:02:34 <lpsmith> that runState that appears in the definition is shorthand for   runState (State delta) = delta
13:02:37 <fax> i_am_neuron: it needs to be nonzero like halfway through a computation
13:04:12 <lpsmith> @define addToSum i = do { x <- get; put (x + i) }
13:04:21 <lpsmith> @let addToSum i = do { x <- get; put (x + i) }
13:04:29 <lpsmith> hmm,  lambdabot seems to be down
13:04:48 <lpsmith> Ok,  I'll pretend to be lambdabot.
13:04:54 <i_am_neuron> lpsmith: :)
13:05:02 <lpsmith> >  runState (return ()) 0
13:05:05 <lpsmith> ((),0)
13:05:23 <lpsmith> > runState (addToSum 10) 0
13:05:27 <lpsmith> ((),10)
13:05:51 <i_am_neuron> lpsmith: Yes, this makes perfect sense to me
13:06:11 <lpsmith> > runState (addToSum 10 >> addToSum 6) 0
13:06:17 <lpsmith> ((),16)
13:06:31 <lpsmith> > runState (addToSum 10 >> addToSum 6) 4
13:06:36 <lpsmith> ((),20)
13:06:39 <lpsmith> :)
13:07:16 <i_am_neuron> lpsmith: the thing is that I do understand that State sort of stitches this things together, but I thought that I mustn't define runState. Is that right?
13:07:53 <lpsmith> I'm not sure what you are trying to ask...
13:08:06 <SamB_XP_> i_am_neuron: indeed -- you call it
13:09:09 <i_am_neuron> SamB_XP_: Aha, so this runState is actually the act of reading the accumulator's value, right? The way to take it out of State monad?
13:09:18 <Taejo> in logic, what does one call a sequence of symbols that is not a well-formed formula?
13:09:47 <ddarius> An ill-formed formula?
13:09:49 <lpsmith> runState (addToSum 10 >> addToSum 6) 4
13:09:49 <lpsmith>          ^^^^^^^^^^^^^^^^^^^^^^^^^^^     This part of the expression is :: State Int (),  which is a monad
13:09:52 <SamB_XP_> i_am_neuron: given an initial state value, it runs the computation and tells you the final state value and return value of the computation
13:11:20 <lpsmith> runState (addToSum 10 >> addToSum 6) 4
13:11:20 <lpsmith> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   The overall expression is just a normal value,  which you can use like you would any other.
13:11:47 <lpsmith> In this case,  it evaluates to ((),20),  which has type :: ((),Int)
13:11:48 <i_am_neuron> lpsmith: Yeah, I think I got it now
13:12:48 <GaMer13> Anyone around here who uses gtk2hs?
13:12:57 <i_am_neuron> Thanks a lot folks, looks like I know enough now to finish with this accumulator :)
13:13:16 <companion_cube> lpsmith: i like your explanations :)
13:14:55 <chrisdone> what do you guys think of this? http://i41.tinypic.com/120j6mc.jpg
13:15:02 <GaMer13> When I run "make" with gtk2hs i get the following output (really long one), but it ends with: http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=23246
13:15:04 <[swift]> reading through the DEFUN 2009 tutorial on multicore haskell programming, and had a quick question
13:15:20 <[swift]> the tutorial states not to do this: "f `par` f + e"
13:16:00 <Vanadium> Yes, why?
13:16:06 <[swift]> the problem is that a spark is made to evaluate f, but the main thread continues on to evaluate f + e, ignoring the spark's efforts
13:16:29 <[swift]> i find this behavior surprising. why doesn't lazy evaluation do the right thing here? it's not like there's a 'seq' in there
13:16:54 <Vanadium> It does the right thing there, but it still blocks the until f is evaluated, just as if you did f + e
13:17:30 <lpsmith> companion_cube, thanks!
13:17:35 <Vanadium> The spark sits there. Maybe it gets to run before f+e is evaluated for some reason, in that case f+e will access the f thunk and block until the spark's thread has finished running.
13:17:36 <[swift]> Vanadium: ah, so the problem is just that you gain nothing from the spark because you're not providing something else independent that can be evaluated in parallel with it
13:17:41 <Vanadium> yes
13:17:59 <allbery_b> GaMer13: unfortunately all that paste means is that something failed a lot earlier in the build
13:18:05 <Vanadium> Does the tutorial go on to suggest f `par` e `seq` f + e or something? :)
13:18:21 <[swift]> i see, thanks for the clarification. the wording of the tutorial threw me off
13:18:30 <[swift]> well it just says "Main thread works on 'f' causing spark to fizzle"
13:18:44 <[swift]> i misinterpreted what that meant
13:19:00 <ddarius> [swift]: There is also the possibility that both the main thread and the spark will evaluate f.
13:19:32 <Vanadium> ddarius: I assumed the thunk evaluation will just block on one of the threads then?
13:20:16 <ddarius> Vanadium: Usually, but there is a race condition that can lead to f being evaluated multiple times.  This is harmless though (unless you are doing bad stuff.)
13:21:00 <[swift]> ddarius: that makes sense. avoiding that situation with locks would probably kill performance for essentially no gain
13:21:49 <[swift]> ddarius: it DOES mean things work slightly differently than how i thought, though
13:21:50 <i_am_neuron> Moved further with the accumulator http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24475#a24482 , but it doesn't seem to accumulate. :) I suspect that forever invoking do block over and over and recreates the state instance. Is that right?
13:22:22 <ddarius> Vanadium: I'm not sure if you were leading to this, but seq is no help there.
13:23:15 <FliPPeh> Well
13:23:59 <FliPPeh> Now I had to reinstall my whole haskell stuff, because it got confused with the system's packages and cabal's packages
13:24:02 <FliPPeh> :(
13:24:10 <[swift]> ddarius: ideally one would use pseq to give the main thread something else to do, but even in that situation the same thing could happen, unless i misunderstand. what if evaluating 'f' takes an hour? is there no way to prevent this?
13:24:14 <FliPPeh> At least I've got a clean situation now
13:24:23 <FliPPeh> Is there a way to remove cabal packages soon?
13:25:24 <benmachine> i_am_neuron: think of a State s a value as a function
13:25:26 <ddarius> [swift]: pseq would work.  It would guarantee that f and e get evaluated in parallel.  If f takes an hour, you have to wait at least an hour no matter what.  There's no way around that.
13:25:27 <FliPPeh> In case the AUR catches on, and I can use that to automatically keep my packages up to date :/
13:25:53 <benmachine> i_am_neuron: (and by "think of it as a..." I mean "it actually *is* a...")
13:25:55 <Vanadium> @src pseq
13:26:10 <Saizan> FliPPeh: if you don't install them globally it's easy
13:26:13 <lpsmith> i_am_neuron, it doesn't accumulate because each   "runState (addToSum i) 0" evaluates to i,  they are completely separate computations
13:26:20 <benmachine> i_am_neuron: so addToSum i is a function that you then apply to 0 (this is what runState does)
13:26:24 <lpsmith> you start over with a fresh accumulator each time
13:26:47 <FliPPeh> Saizan: But then if I just "rm" them, dependencies will be broken
13:26:58 <Vanadium> ddarius: I just wanted to use seq to give the main thread something to do until the spark got around to evaluating f
13:26:59 <benmachine> i_am_neuron: each i has nothing to do with the previous or future things called i
13:27:00 <[swift]> ddarius: right, but imagine we have this: f `par` e `pseq` f + e. can't it happen that if e finishes evaluation before the spark finishes evaluating f, the main thread will start evaluating f again, even if the spark is, say, 30 minutes in?
13:27:02 <FliPPeh> Instead of my pacman telling me that it will cause breakage
13:27:08 <Saizan> FliPPeh: you have to rm -fr ~/.ghc, or ghc-pkg unregister --user them
13:27:09 <benmachine> i_am_neuron: this is a long way of saying, yes you're right
13:27:19 <ddarius> Vanadium: E1 `seq` E2 === E2 `seq` E1 `seq` E2
13:27:30 <Saizan> FliPPeh: i.e. you've to tell ghc you're removing the package.
13:27:38 <ddarius> [swift]: No.
13:27:48 <ddarius> [swift]: The gap is small.
13:27:48 <tomberek> hey guys.. i'm trying to get some RULES to fire and I'm tossing NOINLINES everywhere, to no avail, can I be missing something simple?
13:27:50 <Vanadium> Okay, I keep forgetting about pseq
13:28:22 <[swift]> ddarius: just to clarify, is the answer really no, or is it "the odds of that are astronomically low"?
13:28:47 <FliPPeh> Ahaa, thanks Saizan
13:29:02 <i_am_neuron> lpsmith: but I'm using get and put in addToSum and getSum, so those values go into some cells, it just happens that these cells are different each time, right?
13:29:18 <EvanR> question about formatting. if i have an expression which is very long, can i put it on more than one line, or should i make a new let or where equation
13:29:19 <i_am_neuron> So how can I chain addToSum invocations so that they would work on the same cell?
13:29:24 <benmachine> i_am_neuron: they're not really cells
13:29:52 <benmachine> i_am_neuron: get and put just pass things to functions in sneaky ways
13:30:00 <ddarius> [swift]: I'm pretty sure a spark acquires a thunk before it starts evaluating.  It's possible for two threads to both happen to acquire the thunk at the same time, but once one has started evaluating the other will block.  Certainly 30 minutes in it will be acquired.
13:31:06 <[swift]> ddarius: ah, i see. so the only way a problem could occur is if both threads are _just about_ to start evaluating the thunk. thanks for the clarification!
13:31:07 <ddarius> [swift]: Note that this is the same thing as blackholing.
13:31:15 <lpsmith> i_am_neuron, reload the hpaste,  I tried to explain what was going on,  though I accidentally double-posted one modification for some reason
13:31:30 <lpsmith> What you want to do here is use the StateT transformer
13:31:46 <lpsmith> with IO as the argument to StateT
13:32:11 <benmachine> or, just use a function :P
13:32:33 <benmachine> since if you only ever use the state component of State that's equivalent to just composing functions
13:32:42 <lpsmith> benmachine, of course,  that's how I'd write it, but i_am_neuron is trying to understand the state monad
13:32:50 <Alpounet> [swift], there's paper by Simon Marlow about these mechanisms
13:32:50 <lpsmith> :)
13:33:05 <benmachine> well ok, but then it's a bit weird to say he "wants" StateT
13:33:21 <benmachine> besides I think that when not to use State is as important as when to use it
13:33:29 <[swift]> Alpounet: haha, i'm sure. i've got a couple of his papers on my reading list now but i haven't got to them yet.
13:33:58 <EvanR> wait
13:34:03 <EvanR> StateT with IO ?
13:34:08 <lpsmith> point taken,   but your first uses of monads probably aren't going to be very interesting;  but if they help you understand what's going on...
13:34:10 <i_am_neuron> lpsmith: Great, thanks, this is a perfect explaination why it doesn't work :) However, now I don't have a slightliest clue on how to make it work without passing the state around manually
13:34:16 <Alpounet> [swift], may I suggest you to read this one with high priority : http://www.haskell.org/~simonmar/papers/multicore-ghc.pdf :)
13:34:52 <[swift]> Alpounet: "Runtime support for multicore Haskell", right? i'll read it later today if possible =)
13:35:35 * companion_cube has the feeling that haskell is one of the few functional languages which support multicore
13:36:04 <Alpounet> [swift], yeah
13:36:18 <Alpounet> it explains many mechanisms in detail
13:36:22 <benmachine> i_am_neuron: depends on what you think of as "it" in "making it work"... if you want a state computation that prints out a value and then keeps it for the next time, there are a few ways of doing that
13:36:52 <i_am_neuron> benmachine: I'd prefer doing it with State for educational reasons
13:37:16 <benmachine> well, you can't print stuff inside a plain State
13:37:38 <lpsmith> companion_cube, what do you mean by "support"?   There is concurrent ML,  many Scheme dialects support operating system threads and green threads,   functional programming and parallel programming has a long academic research history....
13:37:39 <benmachine> you can use StateT like lpsmith said, or you can use a Writer monad
13:37:48 <benmachine> or various similar ideas
13:38:06 <EvanR> but but... IO has state stuff built in. IORef?
13:38:13 <benmachine> indeed
13:38:31 <benmachine> StateT with IO doesn't really get you anything you didn't already have with just plain IO
13:38:34 <benmachine> but never mind that :P
13:39:19 <kmc> but StateT state and IORef state are implemented in very different ways
13:39:38 <companion_cube> lpsmith: i mean, in the main language branch
13:39:49 <lpsmith> Erlang has great multicore support,  unfortunately it's single-core performance kind of sucks,  and I have issues with focusing on parallization when your scalar performance sucks
13:39:49 <companion_cube> for example, ocaml does not support multicores
13:40:09 <lpsmith> well,  Haskell98 knows nothing about multicore
13:40:11 <drk-sd> (ocaml doesn't support anything)
13:40:30 <companion_cube> drk-sd: evil troll :)
13:40:40 <i_am_neuron> benmachine: OK, printing is not possible because of the IO/State monads clash, right?
13:40:48 <drk-sd> damn, i'm spotted :(
13:40:50 <Cale> whaat?
13:40:51 <kmc> Haskell (GHC's flavor) is one of the few languages that supports multicore evaluation *without* explicit concurrency or threads
13:41:08 <EvanR> i_am_neuron: your State can return a command to print later ;)
13:41:10 <Cale> i_am_neuron: You can liftIO (print foo)
13:41:10 <kmc> but it also has the more conventional threading model for concurrency or cases where you want finer control over work allocation
13:41:24 <Cale> (in StateT over IO)
13:41:43 <Cale> But as was pointed out, it's silly to StateT transform IO normally
13:41:52 <Cale> Because IO already has gobs of stat
13:41:54 <Cale> state*
13:42:06 <EvanR> isnt writer designed for this sort of thing
13:42:27 <kmc> i think a language with good support for concurrency *has* to be functional, because you want to define and launch threads by closing over free variables
13:42:44 <benmachine> writer is underrated imo
13:42:51 <Cale> You could use a writer monad if you want to collect things to print, or you can just produce a string, or list of strings.
13:42:51 <benmachine> you can do some really neat things with it
13:42:56 <kmc> however, that requires only the broad definition of "functional language"
13:43:33 <deech> kmc: Doesn't  Haskell's purity make it more conducive to concurrent programming?
13:44:01 <kmc> deech, over other languages?
13:44:03 <kmc> yes, i think so
13:44:28 <deech> kmc: yup, I meant as opposed to Haskell being a functional language. It could have been imperative and pure.
13:44:36 <kmc> deech, though concurrent (as opposed to parallel) Haskell code usually makes use of mutable state
13:44:41 <Twey> It is imperative and pure.
13:44:50 <kmc> Haskell *is* an imperative language and that's the aspect you use when you do concurrent programming
13:45:06 <kmc> because concurrency is, by definition, about the ordering (or lack thereof) of sequential events in time
13:45:33 <deech> yes, I keep forgetting that detail.
13:45:43 <bremner> well, Oz for example (for all it's warts) has a much simpler model of pure imperitive concurrency based on a single assignment store
13:46:46 <lpsmith> Well,  lots of people have studied parallization of pure functional language streching back to the 70s
13:48:03 <deech> in fact one of the biggest obstacles for me in the road to haskell was that the language makes you write more concurrent code from the get-go.
13:48:08 <lpsmith> One of the problems is choosing a good parallelization strategy;  GHC punts this responsibility to the programmer,  whereas many early efforts focused on automatic parallization strategies
13:48:12 <kmc> it does?
13:48:15 <kmc> deech?
13:48:43 <kmc> "pure" Haskell code does not depend on evaluation order and cannot be said to be concurrent at all
13:48:58 <kmc> it's important to distinguish concurrency from parallelism
13:49:25 <deech> kmc: Yes that is what I meant for example, isolating IO is a step most programmers don't take unless they have to.
13:49:50 <fax> isolating IO is pointless
13:50:14 <fax> just write the best possible program and of course there will not be IO in algorithms that don't do IO
13:51:15 <Cale> fax: It's important to be able to know, without looking at the source code of a program/function/what-have-you whether that thing has effects other than producing its result.
13:52:14 <fax> when you say 'without looking at the source code' that is beacuse someone else looks at the source code for you
13:52:26 <kmc> the typechecker?
13:52:29 <fax> yeah
13:52:52 <[swift]> sounds like an improvement to me!
13:52:54 <EvanR> hes very cheap labor, and fast
13:52:59 <kmc> and always correct
13:53:50 <lpsmith> well, usually anyway.   He's very consistent, at any rate ;-)
13:55:20 <kmc> Haskell provides no way to tell by a function's type whether applying it has side effects
13:55:32 <kmc> however, the answer is almost always "no"
13:56:03 <lpsmith> referring to unsafePerformIO?  Lazy IO?
13:56:21 <lpsmith> kmc ^
13:56:43 <kmc> yes, unsafePerformIO is one of the few ways to make a function whose application causes a side effect
13:56:45 <EvanR> i like the guarantee that the code i write cant *be affected* by some external agent. seems more reassuring that my code doesnt affect others
13:56:46 <Cale> unsafePerformIO obviously doesn't count
13:57:03 <EvanR> s/that/than/
13:57:28 <benmachine> unsafeMakeMyProgramNotReallyHaskellAnymore
13:57:49 <kmc> the dirty secret is that underlying GHC's implementation of the IO monad are a bunch of functions with side effects
13:58:05 <kmc> but they're rarely seen by mortals
13:58:55 <Cale> GHC's implementation of IO is unnecessarily hacky, though it possibly makes for much simpler optimisation.
13:58:56 <arw_> isn't non-monadic code side-effect-free?
13:59:07 <Cale> arw_: yes
13:59:12 <Cale> Well, non-IO code is.
13:59:15 <kmc> arw_, i'm talking abotu whether applying a function has a side effect, specifically
13:59:26 <kmc> and the answer is "no" for all but some very special cases
13:59:33 <kmc> applying the function "putStr" has no side effect
13:59:42 <Cale> Evaluation normally has no effect other than to produce a value.
13:59:42 <kmc> it's a pure function that returns an IO action
14:00:03 <Cale> But there are low-level ways to get around that fact which kmc is talking about.
14:00:11 <Adamant> hardware requires side effects, so I'm not sure why anyone should be surprised the underlying implementation uses them, even sparingly
14:00:16 <Cale> I normally ignore their existence as much as possible.
14:00:37 <kmc> i'm sort of talking about that, i'm more talking about the reverse
14:00:47 <kmc> that ordinary functions which return IO types are not "side effecting functions"
14:00:52 <lpsmith> yes, but there isn't anything particularly interesting that you can do with the result of "putStr something"  without eventually printing something
14:01:06 <kmc> lpsmith, i disagree
14:01:17 <kmc> you can make a list of 10 IO actions and then choose one randomly
14:01:21 <kmc> or attach it as an exception handler
14:01:28 <companion_cube> kmc: about putStr being pure, how does side-effect propagates ?
14:01:37 <lpsmith> well,  potentially printing "something"  ;-)
14:01:39 <kmc> companion_cube, not sure what you mean
14:01:53 <companion_cube> I mean, how and when is the action really done ?
14:02:02 <Cale> companion_cube: Evaluating putStr "Hello" just results in an action which only has an effect if and when it is run
14:02:04 <kmc> the only action that's actually executed is "main"
14:02:13 <companion_cube> ok
14:02:14 <lpsmith> I almost caught myself in time,  I was thinking putting IO monads in a Data.Map,  and maybe getting them back out later
14:02:18 <EvanR> you can take a list of IO actions and run a function which returns all of them >>='ed in a cycle, via a condition, or whatever
14:02:25 <kmc> to run a Haskell program, evaluate "main" to gen an IO action, and then execute that action
14:02:30 <companion_cube> so you can give an action to another thread, to be evaluated in this thread ?
14:02:33 <kmc> to et an IO action*
14:02:34 <Cale> lpsmith: grumble, don't abuse the word "monad"
14:02:35 <kmc> companio1_square, yes
14:02:41 <EvanR> forkIO myAction
14:02:45 <companion_cube> awesome !
14:02:55 <kmc> companion_cube, yes, it's a powerful technique
14:03:06 <kmc> for example GTK likes to have all its library calls come from one OS thread
14:03:07 <companion_cube> thread-pool pattern in 4 lines :D
14:03:12 <kmc> you don't even need that
14:03:21 <kmc> because the GHC RTS already pools Haskell threads onto OS threads for you
14:03:33 <kmc> you can just spawn one thread per task even if you have hundreds of thousands of tasks
14:04:10 <kmc> there is rarely a reason to do explicit thread pooling, explicit select() loops, or other stuff like that
14:04:49 <Cale> select() is stupid anyway. Let the GHC RTS decide to call it for you if needs be. :)
14:04:51 <lpsmith> Cale, point taken
14:04:59 <kmc> so yeah in GTK if you want to make a GTK call from another thread you just wrap it in another function call, which will send that IO action to the special GTK thread over a channel
14:05:24 <Ke> though this kind of abstraction makes strace pretty messy
14:05:30 <kmc> hehe
14:07:21 <tomberek> anyone have experience with STArray?
14:07:42 <lpsmith> sure
14:08:03 <kmc> yeah
14:08:20 <tomberek> lpsmith: i just finished trying vector and want to play with STArray, but i'm getting confused with the interface
14:08:46 <lpsmith> yeah,  it can be a little confusing at first
14:08:50 <kmc> the interface is mostly the overloaded MArray interface from Data.Array.MArray
14:09:23 <EvanR> so many arrays
14:09:30 <tomberek> what's the 'state variable for the ST type'?
14:09:41 <Cale> STRef
14:09:45 <lpsmith> The mysterious "st" STArray st Int Int is probably what you are confused by
14:09:45 <kmc> tomberek, you might want to learn about ST outside of STArray
14:10:14 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Control-Monad-ST.html and http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Data-STRef.html
14:10:26 <lpsmith> it's half magical
14:10:32 <kmc> tomberek, it's a type variable which never gets filled in
14:10:39 <tomberek> lpsmith : exactly.... kmc: yeah, i got those open already
14:10:55 <kmc> the significance of which is to prevent mutable state from escaping the call to runST
14:10:56 <tomberek> kmc:that seems odd
14:11:07 <kmc> it is odd
14:11:08 <lpsmith> it's only purpose is to make sure that references never escape
14:11:11 <kmc> it makes sense once you think about it a lot
14:11:20 <lpsmith> It's basically parametericity type thinking
14:11:25 <kmc> runST :: (forall s. ST s a) -> a
14:11:44 <lpsmith> For example,   I tell you I'm thinking of a function from :: forall a.  (a -> a)
14:11:44 <chrisdone> kmc: is that a rank-2 type?
14:11:47 <kmc> yes
14:12:05 <kmc> suppose i made the call (runST (newSTRef 'x'))
14:12:18 <kmc> newSTRef 'x' :: ST s (STRef s Char)
14:12:23 <lpsmith> by parametericity,  there is only one function with that type,  id
14:12:34 <kmc> so:  (runST (newSTRef 'x')) :: STRef s Char
14:12:43 <benmachine> lpsmith: only one *total* function :P
14:12:46 <kmc> but that allows the surrounding environment to place constraints on "s"
14:12:51 <lpsmith> benmachine, yes :)
14:12:59 <kmc> which is forbidden by the type of runST
14:12:59 <tomberek> kmc: so if all I want to do is declare a data type.. data MyArray a = MyArray (STArray (something) Int a)
14:13:18 <lpsmith> you can throw in _|_ and const _|_ in there too,  if you really want
14:13:23 <kmc> data MyArray s a = MyArray (STArray s Int a)
14:14:35 <tomberek> and that 's' parameter will be there?
14:14:39 <kmc> yes
14:14:47 <kmc> (unrelated, but you might use "newtype" or just a simple synonym)
14:15:19 <tomberek> kmc... roger roger
14:16:39 <tomberek> kmc. and for usage? I can simply use the MArray interface?
14:17:01 <kmc> yeah
14:17:08 <Cale> along with runST and runSTArray
14:17:13 <kmc> newArray, readArray, writeArray
14:17:23 <lpsmith> yes, though sometimes using the MArray interface can be a little cumbersome,  due to multiparameter type classes
14:17:47 <lpsmith> Which is definitely something that should be avoided unless you really need them, in my opinion
14:18:01 <kmc> i like mptc :/
14:18:36 <lpsmith> I need to play with type families more;  but the little I have,  I already often prefer them to MPTC :)
14:18:43 <tomberek> i tend to like them too, but it gets you in trouble sometimes
14:19:16 <kmc> yeah, type families are a better way to expression functions on types than mptc+fundep
14:19:28 <kmc> but sometimes you want a non-functional relation on types
14:20:13 <lpsmith> Well,  I haven't done enough type-level hackery
14:20:47 <lpsmith> But I prefer type families because inference is more likely to work as intended
14:21:50 <tomberek> kmc, can you get me started? for an empty array,  newListArray (0,0) [] :: ???
14:22:10 <tomberek> of say... Ints
14:22:48 <benmachine> do you need to give it a typesig?
14:22:53 <lpsmith> newListArray (0,0) [] :: STArray st Int Int
14:22:55 <lpsmith> usually
14:23:25 <lpsmith> tomberek:  you might find {-#LANGUAGE ScopedTypeVariables #-} rather handy
14:23:46 <tomberek> lpsmith : it's expecting the third parameter to be (a t e)
14:24:01 <benmachine> tomberek: no it isn't
14:24:16 <benmachine> well it might be but I don't think so
14:24:45 <lpsmith> oh,  my bad
14:24:46 <tomberek>  Couldn't match expected type `Int' against inferred type `a t e'
14:24:53 <lpsmith> newListArray (0,0) [] :: ST st (STArray st Int Int)
14:24:57 <tomberek> ah!
14:25:00 <benmachine> oh right
14:25:03 <lpsmith> sorry 'bout that
14:25:04 <benmachine> I'm wrong too if that helps
14:25:26 <tomberek> ok, that works.... i'll play around a bit
14:25:56 <Axman6> right, breakfast time
14:26:10 <Axman6> hmm, wrong channel... but still true!
14:28:06 <dfkjjkfd> 00000000000000000000000000000
14:29:12 <stepcut> what am I supposed to do if I want to use parsec 3 in my project, which depends on network, but network uses parsec 2 ?
14:29:33 <stepcut> should I send an email to haskell-cafe asking everyone to upgrade to parsec 3.1.0 ASAP ?
14:29:42 <lpsmith> stepcut, it should still work
14:29:48 <monochrom> nothing special to do
14:30:02 <stepcut> lpsmith: I am 90% certain cabal install will fail if a project depends on two versions of parsec
14:30:03 <MadHatterDude> Tk binding for haskell-p
14:30:18 <stepcut> lpsmith: because I had similar issues with QC1/QC2
14:30:19 <lpsmith> not lately
14:30:29 <lpsmith> qc1/qc2?
14:30:33 <monochrom> but your project will not depend (directly) on parsec 2. you will not list it. you just list network.
14:30:39 <stepcut> lpsmith: QuickCheck
14:30:55 <tomberek> lpsmith, kmc,, dang, this interface is tedious
14:31:00 <lpsmith> ahh,  yeah that's a little different,  but I don't know why
14:31:04 <stepcut> monochrom: that was true of QC issue I had as well
14:31:13 <kmc> tomberek, yeah
14:31:20 <kmc> tomberek, if you hpaste some code maybe we can help you clean it up
14:31:38 <tomberek> eh, all i did was make an array and then read from it
14:31:59 <stepcut> the warning, "Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure." is an error when using cabal install
14:32:20 <Liskni_si> wouldn't you end up having instances from both versions of that library?
14:32:26 <stepcut> yes
14:33:37 <lpsmith> stepcut, yeah, ignore that warning.  At least in the case of parsec,  it won't cause issues
14:33:50 <lpsmith> (As far as I'm aware)
14:33:52 <stepcut> lpsmith: but it *does* cause issues because cabal install fails
14:34:07 * sm would call that an issue
14:34:08 <stepcut> lpsmith: and there is no way to tell cabal install that 'it is not really an issue' as far as I know
14:34:43 <lpsmith> doesn't cabal install still install it?  I don't recall...
14:34:48 <tomberek> lpsmith, let a= newListArray (0,2) [4,5] :: ST st (STArray st Int Int)   ;then;  get n=do a1<-a;b<-readArray a1 n;return b
14:34:54 <stepcut> qc, parsec, and haxml, all have this issue -- they are used by a lot of different projects which are using different major version numbers of the library :(
14:35:02 <lpsmith> Honestly cabal install fails frequently enough that I haven't teased apart all the issues
14:35:13 <stepcut> lpsmith: no. runhaskell Setup install works ok, but cabal install does not.
14:35:30 <lpsmith> that's what cabal unpack is for :-/
14:35:43 <lpsmith> I'm not saying it's a good state of  affairs
14:35:56 <lpsmith> but... cabal install is nice when it works,  but it's not exactly robust
14:36:09 <stepcut> lpsmith: it's not acceptable for the happstack project. A requirement is that 'cabal install happstack' just works on Win, Linux, and OS X
14:36:11 * hackagebot network-protocol-xmpp 0.2.1 - Client <-> Server communication over XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.2.1 (JohnMillikin)
14:36:30 <EvanR> hmm. is there a built in IO (Maybe a) -> (a -> IO ()) -> IO (), which generates something and does an action on Just something until Nothing?
14:36:36 <Cale> tomberek: So you're defining a to be the action which makes a new array with indices 0,1,2 where index 0 is initialised to 4, and 1 is initialised to 5, and then defining get n to be the function which runs a to create a new actual array a1, and then reads a1 at position n, returning the result.
14:37:01 <Cale> tomberek: (Just checking that this is really what you wanted to do)
14:37:40 <tomberek> Cale: when you put it that way......  i'm just playing around, the interface seems cumbersome
14:37:42 <Cale> Every time you execute the action get 1, say, it'll make a new array and read from it.
14:38:07 <tomberek> Cale: how would I only make it once?
14:38:10 <Cale> Normally you're actually expected to run the newListArray action right away
14:38:24 <Cale> myArray <- newListArray (0,2) [4,5,6]
14:38:33 <Cale> and then use myArray in what follows
14:38:38 <Cale> (it's an actual array then)
14:39:18 <EvanR> heh. f x y = x >>= (maybe (return ()) y)
14:39:50 <EvanR> messed that up
14:40:18 <EvanR> need a (f x y)
14:50:11 <samphippen> what's the algorithmic complexity of sort?
14:50:22 <Mathnerd314> n^2
14:50:29 <benmachine> isn't it something log something
14:50:41 <Cale> The sort in Data.List is O(n log n)
14:50:45 <Cale> worst case
14:51:00 <kmc> yes, it's mergesort
14:51:02 <kmc> but the API docs do not say this
14:51:07 <kmc> so can we consider it part of the contract?
14:51:22 <dons> danderson: yeah, i have the list here. i'm going to type it up on the plane.
14:51:25 * dons is travelling again
14:51:42 <EvanR> @src sort
14:51:57 <Cale> The sort in the Haskell 98 spec is an insertion sort.
14:52:54 <Cale> It's a little bit evil to specify it that way, since if one were overly literal about things, only a sort which made the same comparisons would be truly identical.
14:53:23 <Cale> But it doesn't really matter so much
14:53:59 <Cale> everyone knows that it'll be implemented by a good sort algorithm in a real implementation :P
14:54:30 <EvanR> interesting assumption
14:54:35 <Phyx-> Hi, is there some documentation somewhere of what the lexical tokens in Lexer.x correspond too?
14:55:51 <EvanR> whats the differences between Data.Map.fromList and fromAscList
14:55:59 <EvanR> and corresponding to functions
14:56:32 <Cale> Nothing.
14:56:37 <Cale> Er, oh
14:56:41 <Cale> from
14:56:57 <Cale> Yeah, fromAscList *requires* that the list you pass it be in ascending order
14:57:42 <EvanR> so toAscList puts the list in ascending order
14:57:51 <EvanR> i suppose descending is a matter of reverse
14:57:51 <Cale> Otherwise, it produces an indeterminate result (probably an incoherent Map value which will behave strangely because it'll break the invariants that are expected)
14:58:14 <Cale> toAscList and toList behave the same way in practice
14:58:24 <Cale> Though I suppose that toList's contract is weaker
14:58:58 <EvanR> whats Data.Map.assocs
14:59:08 <Cale> Gives the list of associated pairs
14:59:20 <EvanR> like toList
14:59:24 <Cale> (Just look at the type, there's only one obvious function of that type)
14:59:26 <Cale> yeah
14:59:36 <EvanR> its just that i cant figure out
14:59:45 <EvanR> why all these different functiosn have the same type ;)
14:59:49 <Cale> For some reason, they felt the need to give a lot of names to that function.
14:59:53 <EvanR> i figure they must do different things
14:59:57 <Cale> They're the same function, mostly
15:00:13 <Cale> toList/toAscList/assocs are all the same thing
15:01:54 <EvanR> ah
15:01:58 <EvanR> i thought they were different because
15:02:03 <EvanR> :t fromList
15:02:12 <EvanR> :t fromAsciList
15:02:16 <EvanR> different type classes
15:02:29 <Cale> fromList and fromAscList *are* different
15:02:36 <EvanR> oh right
15:02:44 <MisterN> EvanR: lambdabot seems to be away
15:02:58 <EvanR> sleeping on the job
15:03:19 <Cale> The network is being attacked, it seems.
15:04:13 <Phyx-> http://i40.tinypic.com/1075evp.png <-- any suggestions for a better color scheme?
15:04:15 <MisterN> oh lambdabot is on linode
15:04:37 <MisterN> Phyx-: msvs supports haskell?
15:04:53 <Phyx-> MisterN: i'm currently making an update to Visual Haskell
15:04:56 <Phyx-> last one was 2003
15:04:58 * Zao hugs Phyx- 
15:05:12 <MisterN> Phyx-: maybe a darker orange?
15:05:30 <MisterN> and the red maybe a bit less red
15:05:32 <chrisdone> Phyx-: no red at all
15:05:39 <Zao> Use existing colors as far as you can, and then expose the rest through settings?
15:05:42 <ivanm> wb lambdabot! \o/
15:05:45 <chrisdone> Phyx-: just blues, grays, dark greens
15:05:50 <Cale> Yeah, darker colour for strings, and the red is jarring. Maybe maroon, or just black for the modules/constructors
15:06:16 <Phyx-> Zao: they're all changeable via settings, I'm just working on some defaults
15:06:17 <Eelis> heh, yes, let's all opine on our favorite colors for coding. the pointlessness is baffling :)
15:06:42 <Phyx-> hmm, right, i'll drop the red
15:06:45 <Phyx-> and change the string colors
15:06:49 <Zao> Eelis: It's what you stare at when coding. If it burns through your skull, it's unhealthy.
15:07:28 <Zao> Last I checked, VS had a perfectly fine colour for string literals.
15:07:30 <Zao> Why override it?
15:07:32 <Eelis> Zao: you have one of those fancy industrial-laser-onto-retina projectors already?
15:08:11 <Phyx-> Zao: dunno what It is
15:08:47 <Zao> Phyx-: Which is why I recommended mapping to whatever categories that already exist and that people will have already tuned.
15:09:18 <Zao> It would be Text Editor -> String, I assume.
15:09:46 <Zao> There's identifier, keyword, string, comment, etc.
15:10:34 <Phyx-> yeah, i currently have 13 color classes. colors TH code differently etc. I could map the basic ones to the defaults in VS
15:13:52 <Phyx-> thanks for the input all, changing it now
15:14:13 <Zao> Don't forget to make lots of noise when you have something usable out.
15:14:52 <ivanm> Phyx-: Visual Haskell == Haskell support for VS?
15:14:57 <Phyx-> Just got syntax highlighting done today, gonna work on parse errors tomorow
15:15:01 <Phyx-> ivanm: yes
15:15:42 <Phyx-> ivanm: however i beleive due to licensing changes, It could be distributed for free using the Visual Studio standalone shell. much like the express editions
15:18:22 <hiptobecubic> You know what I love about haskell? Even when you're shown the answer to a problem, it takes several minutes to internalize what the hell is going on.
15:18:54 <fax> lol
15:18:54 <lambdabot> fax: You have 1 new message. '/msg lambdabot @messages' to read it.
15:18:58 <fax> @messages
15:18:58 <lambdabot> roconnor said 17h 35m 1s ago: cool, send her a link to my thesis
15:19:56 <ivanm> fax: can't you read? lambdabot is quite clearly telling you to msg her, not to do that in the channel directly! :p
15:20:05 <sundaymorning> man, that those gunther threads in haskell-cafe are sure getting annoying :-/
15:20:23 <fax> hiptobecubic -- what like folds and stuff or lazy knot tying??
15:20:41 <ivanm> sundaymorning: s/those// s/in haskell-cafe are/is/
15:21:23 <hiptobecubic> fax, well i don't know what 'lazy knot tying' means, but i'm sure it qualifies
15:21:29 <Entroacceptor> ivanm: syntax error
15:21:32 <ivanm> sundaymorning: also, I'd like to point out to you that it is unfortunately _monday_ morning, not sunday ;-)
15:21:32 <sundaymorning> yeah, or that
15:21:40 <ivanm> Entroacceptor: eh, whatever
15:21:46 <ivanm> @google tying the knot
15:21:47 <lambdabot> http://www.1049films.com/
15:21:47 <lambdabot> Title: Tying the Knot - The Movie
15:21:52 <ivanm> that's not it...
15:21:54 <ivanm> @google tying the knot haskell
15:21:56 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
15:21:56 <lambdabot> Title: Tying the Knot - HaskellWiki
15:21:58 <ivanm> hiptobecubic: ^^
15:22:14 <sundaymorning> here it's still sunday night :)
15:22:25 <ivanm> _night_, not _morning_!
15:22:28 <sundaymorning> hehe
15:25:04 <hiptobecubic> ivanm, ...
15:25:36 <hiptobecubic> My haskell is pretty miserable, but this 'tying the knot' nonsense.... jeebus
15:26:19 <kmc> > let ones = 1 : ones in ones
15:26:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:26:27 <kmc> that's a very simple tied-knot
15:26:32 <yaxu> sundaymorning: I'm not subscribed, but just looked up the archive and now feel sad
15:26:49 <ivanm> *sigh* how do I give a name to a CAF (i.e. a method instance) so that my profiles make sense?
15:26:52 <Cale> What are the threads about?
15:26:54 <hiptobecubic> kmc but it's crazy talk
15:27:31 <hiptobecubic> the idea of partial infinity is difficult to accept coming from python
15:27:34 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
15:27:36 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:27:36 <kmc> hiptobecubic, do you know LISP or Scheme?
15:27:39 <Philippa> Cale: they start off as an enquiry about female haskellers and turn into Guenther trolling about low grade sexism
15:27:42 <hiptobecubic> kmc of course not :)
15:27:45 <kmc> hiptobecubic, def ones(): while True: yield 1
15:27:48 <ivanm> Cale: "Are there any X haskell programmers" (where X \in {female,gay,male}
15:27:49 <ivanm> )
15:28:05 <kmc> Cale, i really like that example :)
15:28:09 <kmc> i will steal it i think
15:28:20 <hiptobecubic> kmc but that definition doesn't require any predicting of the future :)
15:28:24 <kmc> i know female, gay, and male Haskell programers
15:28:37 <Cale> kmc: All the same person?
15:28:41 * ivanm knows haskell programmers, and think that that suffices
15:28:48 <ivanm> Cale: heh
15:28:54 <kmc> Cale, possibly
15:29:11 <fax> lol at gay being somehow seperate from 'male' and 'female'
15:29:13 <yaxu> as a friend put it "using a single bit of information to categorise people will lead to serious issues with rounding errors"
15:29:34 <EvanR> hiptobecubic: ones a cycle of commands, and ones a recursive list definition
15:29:51 <hiptobecubic> Cale... so evens is 1 + odds... which is 1 + evens... which we don't know yet
15:29:56 <fax> yaxu very geeky way to put it :D
15:30:06 <Cale> hiptobecubic: We know the first element of evens is 0 though
15:30:21 <hiptobecubic> Cale, so it jumps back and forth?
15:30:23 <Cale> hiptobecubic: So the first element of odds will be 1 + 0
15:30:24 <Cale> yeah
15:30:25 * kmc doesn't see the point of labeling sexual orientation at all, personally
15:30:41 <kmc> hiptobecubic, yeah, lazy lists are more like a control flow structure than a data structure
15:30:48 <Philippa> well, having labels lets you communicate approximations quickly
15:30:48 <ivanm> kmc: I don't see the point in asking about it in -cafe
15:30:50 <kmc> they can be used to set up co-routines
15:30:54 <Saizan> hiptobecubic: no "tying the knot" example actually predicts the future, though some are less obvious than others
15:31:02 <ivanm> as ketil intimated, since you're not likely to get a partner via -cafe, why ask
15:31:06 <kmc> haha
15:31:10 <hiptobecubic> the one on the wiki clearly predicts the future :)
15:32:09 <EvanR> hiptobecubic: try to 'play computer' and reduce the expressions yourself
15:32:18 <kmc> hiptobecubic, you know how each (:) is like a structure with two pointers?
15:32:22 <kmc> that is, in implementation
15:32:30 <hiptobecubic> EvanR, i am  working on that right now
15:32:47 <hiptobecubic> kmc, i did not, but ok, i follow you
15:32:55 <dcoutts_> lpsmith, stepcut: yes, cabal-install's solver cannot construct solutions where there are two versions of a dependent package.
15:32:57 <kmc> hiptobecubic, a pointer to the first element of the list and a pointer to the rest of the list
15:33:03 <hiptobecubic> kmc, yes
15:33:09 <yaxu> mind you I find gender issues & programming very interesting
15:33:17 <kmc> this is the ancient "cons cell", an elegant weapon for a more civilized age
15:33:27 <kmc> anyway
15:33:29 <hiptobecubic> is it like c? such that it's a pointer to the first element and a pointer to the second element?
15:33:40 <kmc> a pointer to the first element and a pointer to the whole rest of the list
15:33:46 <hiptobecubic> kmc ok
15:33:47 <stepcut> dcoutts_: but, how will the haskell community transition from parsec 2 to parsec 3 then ?
15:33:59 <kmc> mind you, these pointers aren't really part of the Haskell spec.  i'm sort of talking about how a notional Haskell implementation would work
15:34:07 <kmc> (and how GHC does work, in large part)
15:34:09 <stepcut> dcoutts_: seems like we have to say, "on april 23, everyone switch to parsec 3!"
15:34:11 <hiptobecubic> ok
15:34:12 <Cale> hiptobecubic: also, the pointers will be pointers to code...
15:34:26 <hiptobecubic> Cale, explosions
15:34:30 <hiptobecubic> what?
15:34:36 <kmc> so in "let ones = 1 : ones" you have a (:) whose second pointer points at itself
15:34:39 <dcoutts_> stepcut: if we had "private" packages then cabal-install would know that it's ok to use different versions in different places. As it is, it has to play it safe.
15:34:45 <yaxu> http://www.papert.org/articles/EpistemologicalPluralism.html # interesting but dated take on the subject of gender and programming
15:34:50 <Philippa> yaxu: I'd be happy to have the discussion if it weren't being led by a trolling arsehole, y'know?
15:34:57 <kmc> a group of "let" bindings basically builds a graph of expressions
15:35:13 <kmc> hmm, i feel there should be some good vacuum examples here
15:35:13 <fax> Philippa I must hav missed whatever it was
15:35:18 <stepcut> dcoutts_: what should I do then? no matter what version of parsec i pick, someone is going to be unhappy?
15:35:21 <Cale> Expressions are represented at runtime as pointers to code which when executed will compute the required value, and update the pointer to point at a smaller piece of code which when executed will return the required value immediately.
15:35:26 <dcoutts_> stepcut: and parsec (unlike many other packages) is just the kind of thing that tends to be used privately rather than exported in the public API
15:35:41 <dcoutts_> stepcut: use the version in the current Haskell Platform.
15:35:43 <hiptobecubic> Cale, oh ok. sure
15:36:02 <fax> Philippa - oh it's something to do with some mailing list I don't read
15:36:08 <dcoutts_> stepcut: that's the best way to manage any transition
15:36:10 <ivanm> stepcut: IIRC, the latest parsec 3 is a drop-in replacement for parsec 2
15:36:40 <Philippa> has it been made a 100% one instead of 99ish% like the compatibility modules in earlier versions were?
15:37:02 <dcoutts_> stepcut: or as ivanm says, it might be possible to have your stuff work with either
15:37:06 <Cale> But it's all much simpler if you just think of the haskell evaluator as replacing expression graphs with other expression graphs as required.
15:38:00 <stepcut> would be nice if the haskell platform page made it easier to figure out which version of parsec that is..
15:38:00 <yaxu> Philippa: yes, I'm not interested in *that* discussion...
15:38:05 <dcoutts_> stepcut: I'd be happy if people made more noise about this problem, it's not a bug/mis-feature in cabal-install, it's a more general problem of versioning packages and APIs
15:38:14 <stepcut> dcoutts_: right.
15:38:20 <dcoutts_> stepcut: there's more info in the HP trac
15:39:14 <stepcut> my code, unfortunately, use the functions in 3.1 that say "you probably don't want to use these functions" like mkPT and runParsecT :p
15:39:53 <dcoutts_> dons: stepcut makes a sensible point, it's not obvious from the current HP front page how to get to info like "what version of x is in HP version y"
15:42:01 <dcoutts_> dons: I guess we're also missing any kind of "what's new" info for new releases. So much to do :-( We should try and automate as much as possible. Can extract some of this from the haskell-platoform.cabal
15:42:50 <siracusa> Isn't Parsec 3 fully compatible to Parsec 2?
15:42:58 <dcoutts_> dons: we should file tickets and ask for volunteers
15:43:09 <ddarius> siracusa: Pretty much, yes.
15:43:13 <dcoutts_> siracusa: mostly, and of course it has extra stuff
15:43:35 <danderson> dcoutts_: make it an SoC project. Automating away the creation of HP would be a worthy project imho.
15:43:45 * stepcut tries to figure out if we can backport his code to parsec 2
15:44:04 <siracusa> So changing to Parsec 3 shouldn't be a big problem
15:45:08 <Entroacceptor> then who upates all the packages?
15:45:49 <dons> dcoutts_: yeah, the what's new/timeline/old stuff page is on my todo
15:45:51 <siracusa> Entroacceptor: All the maintainers :-P
15:45:52 <dons> tickets help!
15:45:52 <stepcut> siracusa: the problem is that I am using parsec 3.1.0 specific features, so my depends is parsec >= 3.1.0, but other libraries have parsec < 3
15:46:14 <stepcut> siracusa: so I need to change my app so that I can use, parsec >= 2 && <4
15:46:25 <stepcut> siracusa: which may be possible.. but maybe not.
15:46:58 <Cale> I wonder why network would depend on parsec...
15:47:32 <stepcut> Cale: Network.URI probably uses it
15:47:41 <wavewave_> can haskell be as fast as C/fortran for numerical programming?
15:47:43 <dcoutts_> stepcut: if you'd like to advertise this problem on the lists that'd be good. I can help explain the problem and my suggested medium-term solution (i.e. private packages)
15:48:19 <Cale> wavewave_: Sure. You can even FFI import C and Fortran code and use it from Haskell code if you want.
15:48:26 <wavewave_> replacing GSL functions  for example.
15:48:57 <wavewave_> I know that we can use FFI, but I would like to see "pure" haskell way.
15:49:12 <stepcut> dcoutts_: ok
15:49:54 <wavewave_> I am aware that recent 'vector' package can be good substitute of Array.
15:50:01 <Cale> wavewave_: yeah
15:50:58 <Cale> Also, my understanding is that it's not quite ready yet, but when the Data Parallel Haskell package being worked on becomes really usable, it will be quite nice for numerical applications.
15:52:14 <tomberek> Cale: i'm still playing STArray.. i think i'm on the wrong track.... i'm storing actions, not arrays
15:52:23 <Cale> tomberek: yeah
15:52:33 <wavewave_> most numerical algorithm use arrays, so now haskell is ready for numerical things with vector?
15:53:31 <wavewave_> Cale: What is the status of DPH by the way?
15:53:45 <Cale> wavewave_: It's not something that I've tried, but you might like to try using hmatrix, which is a wrapper around GSL.
15:53:57 <fax> I think mathematicians make terrible programmers all their variables are some unrelated crap like phi or sigma and all their methods(functions) are called F and slightly-reshaped-F.
15:54:02 <fax> haha ^
15:55:06 <Cale> wavewave_: There was a talk about the status of DPH a while back... I'll see if I can find you a link.
15:55:08 <wavewave_> I once tried hmatrix but it's hard to debug when some error happens in C side.
15:55:24 <dons> wavewave_: vector is great for numeric stuff, yes. that's its primary purpose.
15:55:44 <ddarius> When I built pandoc, it had a dependency on network which used parsec 2.1.0.1.  I just built it anyway.
15:56:08 <ddarius> wavewave: Haskell has had arrays for a very long time.
15:57:08 <wavewave_> ddarius: But isn't the default array in haskell too slow?
15:57:58 <wavewave_> dons: is any project going on for some nontrivial numerical recipes?
15:58:31 <wavewave_> dons: I am interested in Monte Carlo integration and Root finding, minimization.
16:00:47 <wavewave_> If some algorithms are implemented in pure haskell, I wonder whether some very aggressive optimization like CoCoNUT can be helpful for real projects.
16:03:21 <Cale> http://tumblr.justtesting.org/post/188459020/implementing-data-parallel-haskell -- ah, here it is
16:03:46 <roconnor> has anyone used data parallel haskell?  would it be good for image manpulations such as convolutions and other digital filters?
16:04:20 <wavewave_> Cale: Thanks.
16:04:40 <tomberek> Cale: i'm running into monad issues with that STArray... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24488#a24488
16:04:52 <Cale> roconnor: Theoretically :)
16:05:20 <Cale> roconnor: I'm not sure about how ready it is, though, it's supposed to be more usable in 6.12 than in 6.10
16:05:31 <roconnor> hmm
16:05:50 <Cale> tomberek: Why STArray just to represent graphs?
16:05:57 <edwardk> fax: some of us prefer more verbose naming conventions ;)
16:05:58 <Cale> tomberek: Data.Map is so much nicer for that.
16:05:58 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:06:39 <Cale> tomberek: You're still running the actions too late...
16:06:45 <siracusa> Does Hackage try to rebuild a package that it couldn't build at the first attempt?
16:06:51 <edwardk> @tell ksf i have most of a Data.Vector.Rope that addresses the first of your concerns, but I'm hestitant to add alternate indexing methods, the analogy gets stretched a bit thin
16:06:51 <lambdabot> Consider it noted.
16:07:05 <tomberek> Cale: I used the fgl library, but found too much garbage collection slowed me down... i made a Vector version, which had great improvements, now I'm trying Array, but I'm new to the monadic approach
16:07:24 <Cale> tomberek: The ST s thing in the GraphRep type is weird.
16:07:57 <Cale> tomberek: Are you sure you want to use an ST computation which when executed will produce an STArray as your graph representation? It would be more natural just to use an STArray directly.
16:08:03 <fax> what does Charity have to do with category theory?
16:08:07 <dons> wavewave_: i want to port 'numerical recipes' to haskell
16:08:24 <edwardk> fax: the name of the language or the language itself?
16:08:25 <tomberek> Cale: i agree, i just don't know how to get that type-checked and working right
16:08:40 <fax> hm I suppose it is all explained in here http://pll.cpsc.ucalgary.ca/charity1/www/literature.html
16:08:50 <wavewave_> dons: that's great! I look forward to it much.
16:08:53 <luite> tomberek: did you try to increase the heap size or allocation area?
16:09:03 <Cale> tomberek: Let's take a step back for a moment. How large are the graphs that you're manipulating?
16:09:10 <fax> http://www.tom.sfc.keio.ac.jp/~sakai/hiki/?CPL
16:09:15 <fax> this programming language is cool
16:09:23 <fax> there's an haskell implementation
16:09:29 <tomberek> luite: it helps of course,, but changing from the standard PatriciaTree in fgl to Vector cut GC's by 85%
16:09:36 <edwardk> fax: the main thing about Charity is that you can define things in terms of constructors (how you build it) or in terms of destructors (how you take it apart), so it supports a fairly rigorous notion of data and codata.
16:10:04 <tomberek> Cale: for now, small.  I'll be doing lots of updates, very few inserts
16:10:34 <Cale> tomberek: Then why not just use Data.Map or Data.IntMap?
16:10:35 <tomberek> Cale: basically changing nodes, but not the structure, so making it mutable seems to be the right approach
16:10:36 <dons> wavewave_: well if you know   the field, dive in an work with vector. teach others
16:11:01 <Cale> They have a friendly user interface. I can explain better how to use ST though, if you'd like :)
16:11:04 <tomberek> Cale: the fgl package uses IntMap,,, it makes too many copies as I do updates
16:11:08 <wavewave_> dons: Of course, I will if I can :)
16:11:15 <fax> edwardk it is then, initial and terminal algebra (I have no idea what that is but I read it on wadler :/)
16:11:21 <tomberek> Cale: and then I spend too much time in GC
16:11:31 <Cale> tomberek: When you update an IntMap, it just copies O(log n) of the nodes.
16:11:35 <Cale> hmm
16:11:42 <wavewave_> dons: In fact, I was reading your work on Monte Carlo simulation.
16:12:23 <tomberek> Cale: i had a small graph 23 nodes, but for 10000 updates, the GC's slow it down a lot, and uses a lot of heap, even with -H1G
16:12:24 <edwardk> fax: well, you might say that you can deal with productive corecursion over codata or well-founded recursion over data, but the programming style doesn't let you attempt well-founded recursion over codata, since it may not be well-founded!
16:12:56 <fax> hehe
16:12:57 <dons> wavewave_: ah, hope you found it useful
16:13:17 <Cale> Weird.
16:13:23 <wavewave_> dons: of course, it's very useful and insightful!
16:13:38 <Alpounet> **
16:13:41 <Cale> Actually, looking at the Gr type, it looks like it takes a non-obvious approach to representing the graph...
16:13:46 <dons> its a nice cross-over paper between numerical stuff and compiler / language technology
16:13:48 <Alpounet> hmm
16:13:58 <dons> of *course* we want to specialize our simulations :)
16:14:08 <edwardk> Cale: the fgl stuff is pretty bad to use for anything that wants to update the graph.
16:14:14 <dons> heya Alpounet
16:14:39 <wavewave_> dons: I am now wondering whether generation of specialized haskell function directly can beat generating C code.
16:14:43 <Cale> I've never really used fgl
16:14:47 <tomberek> edwardk, Cale: here's what I did with Data.Vector, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24489#a24489
16:14:55 <Alpounet> hey dons
16:15:02 <dons> wavewave_: generating haskell vs generating C?
16:15:03 <Cale> I've always just created my own graph type, something like  Map Vertex (Set Vertex)
16:15:06 <dons> yes, if we use parallel stuff
16:15:12 <tomberek> edwardk: the updates got sped up a lot
16:15:15 <dons> it might be infeasible to generate equivalent C
16:15:21 <edwardk> tomberek: how much of an improvement did you see?
16:15:43 <tomberek> 1/6 the GC's, 1/10 the time
16:15:44 <dons> "Making a vector version of Data.Graph.Inductive.Graph" -- AWESOME!
16:15:53 <edwardk> tomberek: respectable
16:15:53 <dons> tomberek++ brilliant idea
16:15:58 <ivanm> dons: atrocious
16:15:59 <tomberek> dons: it works, i think
16:16:09 <dons> ivanm: but we get to just implement Cormen et al directly
16:16:18 <wavewave_> dons: So I want to know how mature the relevant code bases are.
16:16:28 <dons> we can use vector  to implement all the standard graph algors.
16:16:41 <dons> wavewave_: vector is about 3 y.o
16:16:44 <tomberek> dons: if you have any suggestions, (or corrections, hehe) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24489#a24489
16:16:46 <ivanm> Data.Graph has so many problems with it that have nothing to do with the choice of array type
16:16:51 <ivanm> it has to do with using arrays in the first place
16:16:55 <roconnor> what is vector?
16:16:55 <edwardk> tomberek: hrmm, i should finish up my vector based ropes so you can have a graph you can add to ;)
16:17:00 <wavewave_> dons: I see. :)
16:17:04 <dons> ivanm: right. my big point is to *write a new graph lib* based on vectors
16:17:06 <Alpounet> roconnor:
16:17:07 <Cale> roconnor: an integer array library
16:17:08 <Alpounet> @hackage vector
16:17:09 <lambdabot> http://hackage.haskell.org/package/vector
16:17:11 <edwardk> roconnor: vector is generalized bytestrings
16:17:14 <dons> a standard impl. from the textbooks
16:17:26 <ivanm> dons: which has the same problem: it uses an array-based approach
16:17:28 <dons> toss in some par graph traversal
16:17:32 <edwardk> roconnor: for boxed data, unboxed data, storable data, primitive types, etc.
16:17:56 <edwardk> cale: can hold a lot more than ints ;)
16:17:59 <ivanm> dons: unless vector lets you arbitrary grow/shrink vectors...
16:18:09 <Cale> Indexed only by ints
16:18:14 <dons> ivanm: which it does
16:18:16 <edwardk> ivanm: well, that is why i have ropes of vectors
16:18:18 <ivanm> hmmm...
16:18:20 <ivanm> edwardk: aha
16:18:35 <edwardk> ivanm: vectors can grow or shrink like bytestrings, they slice nicely, but appending them is O(n)
16:18:47 <Cale> I suppose "integer array" was pretty ambiguous though :)
16:18:56 <edwardk> cale: ahh
16:19:10 <tomberek> so....... what should I do with this Vector instance of Graph?
16:19:50 <Cale> tomberek: Maybe contribute it to the fgl package, or cabalise it separately and upload it to hackage?
16:19:57 <ddarius> Can anyone point to a graph library in any language which is pleasant?
16:20:17 <Cale> I've found it pretty pleasant just using Map Vertex (Set Vertex) directly.
16:20:20 <edwardk> tomberek: i'm tempted to build a vector rope one based on it so you can quickly add contexts, etc.
16:20:36 <roconnor> why would I prefer vector over seq?
16:20:39 <roconnor> sequence
16:20:41 <tomberek> Cale: I'm not even sure it's stable or correct... it seems to work with what limited testing i've done
16:21:24 <wavewave_> I hope some time we will have a very nice comparison matrix for all data types available in haskell.
16:21:29 <edwardk> roconnor: Data.Sequence is O(n log n) in storage overhead, it appends more cheaply, but a vector is O(n) size if you know its size and intend mostly on cuting it up, rather than on splicing it together.
16:21:46 <Cale> Hehe, infinite comparison matrix!
16:21:50 <edwardk> roconnor: Vectors also support list fusion
16:21:56 <edwardk> er stream fusion
16:22:10 <wavewave_> complexity/ usability/ caveat/ ...
16:22:24 <danderson> dons: so, the plan now is to reimplement all storage in terms of vectors? :)
16:22:45 <tomberek> Cale, edwardk: basically, I need a haskell-sage to help me out to clean things up and for correctness
16:23:09 <wavewave_> like wikimatrix comparing wikis
16:23:14 <Alpounet> edwardk, c'mon, it's for HNN :-p
16:23:26 <edwardk> roconnor: i'm using fingertrees of vectors to try to get most of the benefits of both. fusion over the individual chunks, O(log(min(n,m)/c)) append, etc.
16:23:38 <edwardk> Alpounet: what is?
16:23:46 <tomberek> graph
16:25:05 <wavewave_> haskell neural network
16:25:08 <wavewave_> ?
16:25:26 <Alpounet> edwardk, the graph instance for vector that tomberek is talking about :-)
16:25:41 <Alpounet> it's actually the core structure of hnn he's rewriting.
16:25:42 <edwardk> Alpounet: ah.
16:25:53 <wavewave_> Alpounet: Haskell Neural Network = HNN?
16:26:13 <tomberek> edwardk: remember the comonad stuff? it's working
16:26:16 <Alpounet> wavewave_, yeah
16:26:17 <wavewave_> Alpounet: this is also very interesting to me.
16:26:25 <edwardk> Alpounet: yeah we've been talking about it via email for a while, just didn't parse HNN has haskell neural network ;)
16:26:28 <Alpounet> wavewave_, would like to join ?
16:26:31 <edwardk> tomberek: congrats =)
16:26:56 <edwardk> i see you didn't have to give in and break away from fgl after all ;)
16:26:59 <tomberek> edwardk: just can't get the RULES to fire
16:27:06 <wavewave_> Alpounet: i am not an expert on neural network right now, but my field is using that technique much.
16:27:11 <wavewave_> :)
16:27:33 <tomberek> edwardk: it seems to be the most developed graph library we have.... I'd like to see if there is interest in fixing it
16:27:37 <Alpounet> wavewave_, well, we have a repo where tomberek is experimenting new implementations, a mailing list and a trac
16:27:47 <Alpounet> see http://trac.haskell.org/HNN/
16:27:53 <edwardk> tomberek: definitely interest here, but too many projects on my plate
16:27:54 <Alpounet> don't hesitate to jump in heh
16:28:10 <edwardk> tomberek: if you know any interested students willing to take it up for the summer of code, i'd happily mentor though
16:28:24 <tomberek> hm... i'm not a student, or near any
16:28:34 * edwardk looks meaningfully at Alpounet
16:28:37 <wavewave_> Alpounet: Thanks!
16:29:26 <edwardk> -- mostly coz Alpounet had expressed interest in the SoC, but didn't have a firm project idea ;)
16:29:38 <Alpounet> edwardk, hey
16:29:42 <Alpounet> that's wrong!
16:29:53 <edwardk> in that you have an idea?
16:29:55 <Alpounet> I've been looking closely at the llvm backend
16:29:58 <edwardk> ah
16:29:59 <edwardk> sorry
16:30:01 <edwardk> you're right
16:30:03 <Alpounet> heh :)
16:30:12 <tomberek> edwardk: actually, i think one of Okasaki's students is lookng for a project, let me write a quick email
16:30:19 <edwardk> good idea
16:30:33 <edwardk> i think it is definitely a project the community could justify with the right student
16:30:41 <Alpounet> my very first idea was to propose to work on HNN... but well...
16:31:37 <Alpounet> but hmm 'fixing' fgl could be nice too.
16:31:43 <edwardk> well, HNN leaves me personally going "meh", but working on dramatically improving the performance of/replacing the graph library that underlies it is a very sexy idea.
16:31:53 <Alpounet> tomberek, what do you find to be missing to fgl ?
16:32:14 <benmachine> $ file Main.hs
16:32:14 <benmachine> Main.hs: ASCII Java program text
16:32:17 * benmachine fumes
16:32:20 <Alpounet> because the idea isn't bad at all :)
16:32:30 <Alpounet> benmachine, uh ?
16:32:53 <tomberek> Alpounet: A good graph package to work off of will pay off for speed, memory usage, and combinators.
16:32:58 <benmachine> Alpounet: never mind :P
16:34:49 <Alpounet> tomberek, do you think it has to be rewritten from scratch ?
16:35:08 <Alpounet> or is it only few Graph instances far ?
16:35:16 <edwardk> i still like the idea that i think copumpkin had a while back of trying to build a graph library using 'StableName's and Data or Traversable that used each of the fields in a constructor as the links in the graph, so you could manipulate graphs made out of general purpose haskell constructors
16:35:19 <tomberek> I'm not wise enough to answer that question.
16:36:26 <tomberek> the sorts of design decisions that would be made in rewriting it from scratch needs to be made by someone who knows a lot more than me.
16:36:29 <wavewave_> btw, how often "GADT" and "type family" are used for actual projects?
16:36:38 <wavewave_> just curiosity.
16:36:40 <ivanm> edwardk: and I'm working on a graph class...
16:36:42 <edwardk> the only real problem with that approach is it didn't support annotating edges directly without expanding the graph to include nodes for each of the edges.
16:36:46 <Saizan> edwardk: that sounds as meta as most prolog goes, which i'm not sure it's a good thing!
16:36:53 <edwardk> Saizan: =)
16:37:37 <edwardk> Saizan: i'm only half serious about it, but it does fit nicely with the stuff andy gill has been doing with lava, etc. lately
16:37:47 <kmc> wavewave_, type families are catching on as an alternative to fundeps on typeclasses
16:37:58 <kmc> you see them in a lot of newer libraries on hackage
16:38:09 <edwardk> wavewave: 90% of my projects probably use them
16:38:29 <ivanm> edwardk: how many projects do you have? ;-)
16:38:42 <kmc> and it's crucial to have either fundeps *or* type families
16:38:43 <wavewave_> I see. so it will probably be included in new haskell standard some time :)
16:38:45 <Cale> at least 10
16:38:51 <kmc> probably
16:39:06 <kmc> a lot of really essential stuff isn't in the standard :/
16:39:15 <edwardk> ivanm: a lot =) i bounce around between projects like a monkey on crack ;)
16:39:22 <wavewave_> but what is a problem of fundep?
16:39:24 <edwardk> Cale: =)
16:39:39 <kmc> wavewave_, well, they're not in the standard either
16:39:55 <kmc> it's an uglier and less direct way to write functions on types
16:39:57 <gwern> 'Plash: the Principle of Least Authority Shell. This shell runs on Linux, figures out from the command line what any particular invocation of an executable should have access to, creates a sandbox with access to only those things, then maps POSIX calls onto the sandboxed things.'
16:40:15 <edwardk> wavewave: fundeps 'infect' any data type that needs them. you wind up with a ton of extra arguments that nobody cares about that only affect internal details of the data type.
16:40:45 <wavewave_> kmc: so do you think anything that can be done with fundep can be done with type family?
16:40:49 <tomberek> edwardk: i've noticed the same
16:40:52 <edwardk> wavewave: type families on the other hand, have trouble because they can't deal with overlapping instances, incoherent instances, etc that MPTCs have had down pat for a long time
16:40:52 <kmc> i'm not sure
16:41:00 <Saizan> it's easier to write isomorphisms or functions with overlapping cases with fundeps though
16:41:14 <Cale> incoherent instances are a bad idea anyway
16:41:25 <edwardk> wavewave: without 'closed type families' you can still do slightly more with fundeps than type families
16:41:46 <Cale> But sometimes it really is nice to have a real relation between your types
16:41:47 <edwardk> cale: i like them for when i want to define some type level shortcut optimizations that don't have to hold, but which are nice to have properties.
16:41:55 <Alpounet> wavewave_, #hnn :)
16:42:18 <wavewave_> closed type family means a restricted "kind"?
16:42:30 <wavewave_> exhaustible type function?
16:42:33 <edwardk> with type families i wind up having to make little prophyactic type wrappers all over the place, can't define oleg's TypeEq, etc.
16:43:19 <edwardk> wavewave: if you knew nobody later could come along and define new instances you could define type family Foo a :: *; type instance Foo Int = True; type instance Foo a = False
16:43:30 <wavewave_> Alpounet: Oh it has a channel. :)
16:43:57 <edwardk> wavewave: but with other people being able to define new instances in other modules, that construct isn't safe
16:44:13 <edwardk> Alpounet: i keep reading that as the haskell news network
16:44:21 <fax> http://www.abelprisen.no/en/prisvinnere/2010/marcus/
16:44:23 <fax> edwardk
16:44:27 <fax> 1+2+3+4+… = -1/12
16:44:51 <fax> xerox
16:45:21 <Alpounet> edwardk, we don't offer that service yet =)
16:45:35 <tomberek> edwardk: now we just need James Earl Jones: "This is H-N-N"
16:58:10 <fax> > let factor n i = if n `mod` i == 0 then i else factor n (i+1) in factor 126619 2
16:58:11 <lambdabot>   127
16:58:18 <fax> > 126619/127
16:58:19 <lambdabot>   997.0
16:58:32 <fax> I did not expect that to actually work :D
16:59:06 <fax> "In the case of 126619 if you manage to find the primes 127 and 997 did the job then you’ve in fact just cracked a modern day internet code"
16:59:17 <Cale> haha
16:59:36 <Cale> Well, typically the primes used are much much larger
16:59:51 <Cale> (though nowhere near the largest primes known)
17:02:46 <Cale> Like, somewhere on the order of 2^128 or larger. 2^1024 and 2^2048 are not uncommon magnitudes.
17:21:37 <fax> > let el (x,y) = x^3-y^2-43*x+16 in map el [(0,0), (3,8), (3,-8), (-5,16), (-5,-16),(11,32),(11,-32)]
17:21:38 <lambdabot>   [16,-150,-150,-150,-150,-150,-150]
17:22:05 <fax> im confused
17:22:09 <fax> this article says: But change the equation to Y2=X3-43X+166 and suddenly there are only seven pairs of numbers that fit: (X,Y)=(0,0), (3,8), (3,-8), (-5,16), (-5,-16),(11,32),(11,-32).
17:24:14 <fax> how Y^2=X^3-43X+166 is solved by (0,0) I have no idea
17:24:32 <fax> > sqrt(166)
17:24:33 <lambdabot>   12.884098726725126
17:24:42 <kpreid> fax: URL?
17:24:48 <fax> kpreid: http://www.abelprisen.no/en/prisvinnere/2010/marcus/
17:24:53 <fax> it's about 3/4 down
17:24:59 <fax> but the article is good anyway
17:25:35 <kpreid> yeah, that looks just plain wrong
17:26:14 <fax> odd
17:26:27 <fax> why someone would get it wrong I dont realy understand
17:26:40 <fax> maybe it's copied off wikipedia
17:29:53 <ddarius>  > let el (x,y) = x^3-y^2-43*x+166 in map el [(0,0), (3,8), (3,-8), (-5,16), (-5,-16),(11,32),(11,-32)]
17:30:00 <ddarius> > let el (x,y) = x^3-y^2-43*x+166 in map el [(0,0), (3,8), (3,-8), (-5,16), (-5,-16),(11,32),(11,-32)]
17:30:01 <lambdabot>   [166,0,0,0,0,0,0]
17:30:29 <fax> "thanks to the proof of Fermat’s Last Theorem" -- wow this uses fermats last theorem as an application!
17:34:20 <ddarius> Incidentally, Riemann's original paper, "On the number of primes less than a given magnitude" is a pretty good read.
17:34:47 * fax bookmarks for later..
18:07:33 <interferon> anyone know of any examples of iphone apps written in haskell?
18:12:19 <tensorpudding> Don't iPhone apps have to be written using Cocoa?
18:13:59 <pchickey> Hi- I'm trying to turn a Double into a GLfloat
18:14:15 <kpreid> tensorpudding: teeeechnically Cocoa isn't a language, it's a framework
18:14:28 <kpreid> you could use an objc bridge, or write glue code in objc
18:14:53 <tensorpudding> You'd still have to port GHC to the iPhone OS somehow.
18:15:22 <[swift]_> interferon: http://ipwnstudios.com/bloodknight/
18:15:45 <[swift]_> interferon: GHC patches those guys are using: http://projects.haskell.org/ghc-iphone/
18:15:49 <kpreid> it doesn't seem implausible that it'd be possible...the system IS pretty much mac os x with just different userland stuff
18:16:05 <[swift]_> interferon: i believe google will turn up more info
18:16:21 <interferon> i saw the GHC patches, but hadn't seen the bloodknight app
18:16:21 <interferon> thanks
18:20:26 <pchickey> I'm trying to use GHC.Float's double2Float to convert a Double to a GLfloat. In Graphics.Rendering.OpenGL.GL.BasicTypes, type GLfloat = Float
18:20:58 <pchickey> However, I get an error "Couldn't match expected type `GLfloat' against inferred type `Float'
18:21:17 <pchickey> I'm new enough to Haskell that I've never encountered this before.
18:23:24 <kpreid> what you describe would seem to contradict itself, superficially
18:24:44 <mightybyte> Anyone here have experience using Hint?
18:24:57 <pchickey> so am I not looking in the right place? I couldn't find a double2GLfloat function, or even a float2GLfloat
18:25:29 <pchickey> unless for some reason HopenGL uses a different naming scheme. but the relevant modules seem to be dry
18:25:52 <kpreid> pchickey: I think there's a more generic conversion...
18:26:27 <interferon> how do haskell's regex functions work, where you can assert a type signature on the return value and get a different function called?
18:26:39 <kpreid> interferon: type classes, just like return
18:27:03 <[swift]_> pchickey: try realToFrac perhaps? the error is strange
18:27:04 <interferon> kpreid: i'm not sure i understand
18:27:15 <interferon> kpreid: can you make a specific type of type an instance of a typeclass?
18:27:31 <interferon> and how do you write a function that pattern-matches on its return value?
18:27:43 <benmachine> pchickey: at some point in the history of haskell's opengl bindings, GLfloat changed from being a synonym for Float to being a new distinct type
18:27:50 <kpreid> interferon: it doesn't match on the return *value*, its implementation depends on the return *type*
18:27:55 <kpreid> @type return
18:27:56 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:27:58 <benmachine> pchickey: so my guess is you are looking at old docs, or something
18:28:02 <kpreid> just like that
18:28:05 <Philonous> "But don't forget: monads don't do anything. They're simply an interface to something that you must already have implemented some other way. So don't believe all that hype about how monads are what allow Haskell to use side effects and I/O."
18:28:51 <benmachine> pchickey: if you want to convert between types like that, try realToFrac
18:28:55 <Philonous> That puts it rather nicely. Maybe that should be put as a disclaimer somewhere appropriately
18:29:03 <pchickey> ok, I was using the docs at cvs.haskell.org/Hugs/pages/libraries/OpenGL/Graphics...
18:29:14 <pchickey> that was just the
18:29:27 <pchickey> I'm feeling Lucky result, is there a better way to look up docs?
18:29:33 <benmachine> yep
18:29:46 <benmachine> erm
18:29:51 <pchickey> and thanks, realToFrac does the necessary conversion
18:31:28 <benmachine> well
18:32:41 <edwardk> swift: they are running out of time on the first quarter of 2010 ;)
18:32:44 <benmachine> http://hackage.haskell.org/package/OpenGL/ this contains some documentation links, but it's a bit of a mess
18:32:45 <deech> Can anyone recommend a good school(s) for distance learning? I am interested in advanced programming courses.
18:33:52 <pchickey> yeah, what that page really needs is a way to grep the package tree, but a better programmer than I would have to scratch their head on that one
18:33:54 <[swift]_> edwardk: haha, indeed.
18:34:27 <[swift]_> edwardk: i wish i knew of an example that has actually SHIPPED; that'd be a bit more compelling
18:36:47 <interferon> is there a Prelude function that returns a list of n elements x?  e.g. repeatMe 4 1  = [1, 1, 1, 1]
18:36:48 <benmachine> pchickey: I eventually found GLfloat in there by basically picking a module at random and finding a function that accepted one as an argument, then clicking on the doc link
18:36:53 <benmachine> oh
18:36:56 <benmachine> he went
18:37:00 <benmachine> @bots
18:37:01 <lambdabot> :)
18:37:05 <benmachine> > replicate 4 1
18:37:06 <lambdabot>   [1,1,1,1]
18:37:10 <kpreid> @type replicate
18:37:11 <lambdabot> forall a. Int -> a -> [a]
18:37:18 <interferon> thanks!
18:38:33 <interferon> i'm having a lot of fun with laziness
18:40:30 <edwardk> swift: i'm waiting to see if they get past the review process mostly
18:40:50 <interferon> infinite streams in particular: months = concat [zip [1..12] $ replicate 12 year | year <- [2007..]]
18:41:58 <[swift]_> edwardk: when it comes to the app store review process, who knows. i think they should be OK if they don't do any JIT'ing, though; after all, Mono/.NET apps have been allowed in
18:43:04 <interferon> edwardk: are you a bloodknight guy?
18:43:06 <edwardk> [swift]: the other issue is the model they used isn't exactly universal, they allocate a finite number of callbacks in the patch, so if you get too many they just stop working.
18:43:34 <kmc> interferon, did your question about (=~) get answered adequately, or would you like a simple code example?
18:43:37 <edwardk> interferon: nah. i've met ryant5000 at Boston Haskell, and talked to a few of the guys working on it though, since they are in the area.
18:43:51 <interferon> kmc: an example might help :)
18:43:52 <[swift]_> edwardk: ahhh, i wasn't aware. that makes me even more unwilling to bother with that patch
18:43:54 <roconnor> interferon: you haven't seen the half of laziness yet :D
18:44:05 <kmc> btw i don't like that design, of overloading one function to do a bunch of things depending on the return type.  but i'm willing to explain how it works :D
18:44:12 <edwardk> [swift]: it is fine as long as you set up all your callbacks at the start of the app.
18:44:25 <kmc> interferon, so the question is how a function can be selected by return type?
18:44:27 <edwardk> [swift] but if you dynamically register/unregister, etc. you'll be screwed in the end
18:44:37 <interferon> kmc: yes, and how i would write such a function
18:44:43 <kmc> interferon, okay, one sec
18:44:46 <interferon> kmc: i don't like it either :)  just curious as it's something i've nver seen before
18:45:03 <kmc> interferon, you've probably seen it in another guise... it's just a use case of typeclasses
18:45:16 <[swift]_> edwardk: ahh, gotcha
18:47:21 <interferon> and how can i make an infinite list of the same object?
18:47:29 <kmc> > repeat 'x'
18:47:30 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:47:36 <interferon> thanks
18:47:50 <kpreid> interferon: of course, if these didn't exist you could write them yourself
18:47:52 <kpreid> @src repeat
18:47:52 <lambdabot> repeat x = xs where xs = x : xs
18:48:23 <applicative> > map (const 4) [1..]
18:48:24 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
18:48:30 <roconnor> > sum [1,2..]
18:48:35 <lambdabot>   mueval-core: Time limit exceeded
18:48:36 <lambdabot>  mueval: ExitFailure 1
18:48:38 <roconnor> :(
18:48:41 <roconnor> -1/12
18:49:01 <pikhq> applicative: That, unlike (repeat 4), generates multiple objects.
18:49:12 <pikhq> (repeat 4) has a single cons cell.
18:49:16 <kmc> that sharing is not usually observable
18:49:17 <idnar> > sum [1,2..] > (4 :: Nat)
18:49:19 <kmc> except by performance
18:49:21 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
18:49:21 <lambdabot>    arising from the literal `4' at <int...
18:49:31 <idnar> > sum [1,2..] > (4 :: Natural)
18:49:32 <lambdabot>   Not in scope: type constructor or class `Natural'
18:50:14 <applicative> @type sum [1..4]
18:50:16 <lambdabot> forall t. (Num t, Enum t) => t
18:50:19 <kmc> interferon, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24492#a24492
18:50:58 <applicative> pikhq, what does it mean, 'multiple objects'
18:51:08 <applicative> @type map (const 4) [1..]
18:51:09 <lambdabot> forall t. (Num t) => [t]
18:51:19 <kmc> different locations in memory
18:51:24 <kmc> but this is usually not observable
18:51:26 <applicative> @type repeat 4
18:51:27 <lambdabot> forall t. (Num t) => [t]
18:51:29 <kmc> except by how much memory your program uses
18:51:32 <ddarius> > (fix . (:)) 'x'
18:51:35 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:51:45 <idnar> hrmph
18:51:52 <kmc> it's not observable because values are immutable and there's no way to get the address in memory in "pure" Haskell
18:52:18 <idnar> > (fromInteger 4) :: Nat
18:52:19 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
18:52:19 <lambdabot>    arising from a use of `GHC.Num.fromI...
18:52:30 <pikhq> applicative: (repeat 4) is a single cons cell which refers to itself. map (const 4) [1..] is a cons cell that points to a thunk that produces a cons cell that points to a thunk that ...
18:52:31 <idnar> > toNat 4
18:52:32 <lambdabot>   Not in scope: `toNat'
18:52:46 <applicative> kmc, but is that true with the finite   map (const 4) [1..5]
18:52:57 <interferon> > take 15 $ concat [zip [1..12] $ replicate 12 year | year <- [2007..]]
18:52:58 <lambdabot>   [(1,2007),(2,2007),(3,2007),(4,2007),(5,2007),(6,2007),(7,2007),(8,2007),(9...
18:52:59 <kmc> applicative, that'll create 5 different "4" values
18:53:03 <interferon> is there a cleaner way of writing that?
18:53:14 <kmc> applicative, at least in GHC to my knowledge
18:53:16 <applicative> i'm getting it now, ok
18:53:19 <interferon> trying to create an infinite stream of month-year pairs
18:53:24 <kmc> probably it's not specified by the standard
18:53:29 <kmc> because it's not an observable part of language semantics
18:53:39 <interferon> ah kmc, thanks for the example
18:53:42 <interferon> makes sense now
18:54:14 <applicative> pikhq. i see now, yes.
18:54:42 <interferon> also, if i create an infinite stream of month-year pairs and index into it more than once, will ghc remember what it previously evaluated?
18:54:43 <ddarius> roconnor: ζ(-1)
18:54:53 <pikhq> interferon: It depends.
18:55:07 <idnar> > sequence [[2007..], [1..12]]
18:55:09 <lambdabot>   [[2007,1],[2007,2],[2007,3],[2007,4],[2007,5],[2007,6],[2007,7],[2007,8],[2...
18:55:15 <idnar> except those aren't tuples
18:55:19 <kmc> hmm, how would i get the address of a value
18:55:22 <kmc> by tricks and hacks
18:55:33 <kmc> can i unsafeCoerce to some unboxed pointer type?
18:55:36 <ddarius> > liftM2 (,) [2007 ..] [1..12]
18:55:37 <lambdabot>   [(2007,1),(2007,2),(2007,3),(2007,4),(2007,5),(2007,6),(2007,7),(2007,8),(2...
18:55:47 <idnar> oh, yes, obviously
18:56:07 <idnar> ddarius++
18:56:17 <interferon> ddarius: thanks, i thought it had to do with "liftM2 (,)"
18:56:18 <kmc> hmm kind error on unsafeCoerce :/
18:56:28 <interferon> btw, why do we need to lift (,) ?  is it getting lifted into List?
18:56:34 <kmc> yes
18:56:37 <kmc> :t liftM2 (,)
18:56:38 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
18:56:48 <idnar> yes, lifted into the list monad (or applicative, if you want to use liftA2 instead)
18:56:50 <kmc> > (,) <$> [2007..] <*> [1..12]
18:56:51 <lambdabot>   [(2007,1),(2007,2),(2007,3),(2007,4),(2007,5),(2007,6),(2007,7),(2007,8),(2...
18:56:57 <ddarius> Alternatively, liftA2
18:57:33 <idnar> > liftA2 (,) (ZipList [2007..]) (ZipList [1..12])
18:57:34 <lambdabot>   No instance for (GHC.Show.Show
18:57:36 <lambdabot>                     (Control.Applicative.Zip...
18:57:51 <idnar> > getZipList $ liftA2 (,) (ZipList [2007..]) (ZipList [1..12])
18:57:52 <lambdabot>   [(2007,1),(2008,2),(2009,3),(2010,4),(2011,5),(2012,6),(2013,7),(2014,8),(2...
18:58:17 <idnar> (not helpful in this case, obviously)
18:58:43 <applicative> kmc beat me to > (,) <$> [2007 ..] <*> [1..12]
18:58:52 <idnar> > liftA2 (,) (Just 5) (Just 10)
18:58:53 <lambdabot>   Just (5,10)
18:58:57 <idnar> > liftA2 (,) Nothing (Just 10)
18:58:58 <lambdabot>   Nothing
18:59:27 <interferon> nice, the <$> .. <*> version is very concise
18:59:42 <kmc> ah, unpackClosure#
19:00:29 <applicative> > (,,,) <$> [2007 ..] <*> [1..12] <*> ['a'..'z'] <*> "hahahah"
19:00:30 <lambdabot>   [(2007,1,'a','h'),(2007,1,'a','a'),(2007,1,'a','h'),(2007,1,'a','a'),(2007,...
19:00:54 <interferon> nice how that version generalizes out to three tuple-elements
19:01:19 <interferon> take 15 $ concat [zip [1..12] $ replicate 12 year | year <- [2007..]]
19:01:32 <interferon> errr, i mean: take 34 $ (,,) <$> [2007..] <*> [1..12] <*> [1..30]
19:01:37 <interferon> nice and beautiful
19:01:56 <applicative> > take 34 $ (,,) <$> [2007..] <*> [1..12] <*> [1..30]
19:01:57 <lambdabot>   [(2007,1,1),(2007,1,2),(2007,1,3),(2007,1,4),(2007,1,5),(2007,1,6),(2007,1,...
19:02:15 <interferon> not really accurate for all months though
19:02:33 <MisterN> or even for most months
19:02:41 <adu> hi
19:02:42 <interferon> :)
19:03:10 <MisterN> interferon: clearly you need arrows for solving this :)
19:03:28 <tensorpudding> what argument-parsing library should i use...
19:03:46 <edwardk> tensorpudding: CmdArgs
19:03:50 <edwardk> i'm a convert as of 4 hours ago
19:04:02 <tensorpudding> I'm looking at that one.
19:04:07 <tensorpudding> But I'm not sure if it does what I want.
19:04:15 <edwardk> what do you want?
19:04:17 <applicative> > take 34 $ (,,) <$> [2007..] <*> [1..12] <*> ["Pay Rent", "Pay Gas Bill"]
19:04:18 <lambdabot>   [(2007,1,"Pay Rent"),(2007,1,"Pay Gas Bill"),(2007,2,"Pay Rent"),(2007,2,"P...
19:04:19 <interferon> next challenge is to make it accurate
19:05:13 <tensorpudding> I want multiple modes of operation
19:05:32 <tensorpudding> Some of them have special flags that are unique to them
19:05:51 <tensorpudding> Imagine like apt-get has install, check, source, etc.
19:06:11 <kmc> cool, i wrote addrOf :: a -> Ptr a
19:06:37 <interferon> unclean, unclean! :)
19:06:43 <kmc> it feels so wrong
19:06:47 <kmc> but... it feels so right
19:07:00 <edwardk> let leapyear n = 0 {- TODO FIX -} ; months n = 30+[1,leapyear-2, 1,0,1,0,1,1,0,1,0,1] in [ (year,month,day) | year <- [2007..], (month,days) <- months year, day = [1..days] -- ?
19:07:02 <interferon> ghc seems to cache in this example: length $ take 4000000 $ days
19:07:15 <applicative> tensorpudding, doesn't cmdargs permit that?
19:07:15 <interferon> the first run takes a while, future runs are instant
19:07:18 <ivanm> edwardk: heh
19:07:20 <MisterN> kmc: do some category theory to get rid of the wrongness
19:07:28 <tensorpudding> applicative: I can't tell, I'm playing with it.
19:07:32 <roconnor> > do y <- [2007..]; m <- [1..12]; d <- [1 ... if m == 2 then if y `mod` 400 = 0 || (y `mod` 4 == 0 && y `mod` 100 != 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30; return (y,m,d)
19:07:33 <lambdabot>   <no location info>: parse error on input `='
19:07:33 <kmc> actually i think i wrote it wrong :/
19:07:34 <interferon> edwardk: oooo....
19:07:48 <roconnor> > do y <- [2007..]; m <- [1..12]; d <- [1 ... if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 != 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30; return (y,m,d)
19:07:49 <lambdabot>   <no location info>: parse error on input `;'
19:07:56 <ivanm> interferon: I wonder why...
19:08:03 <applicative> tensorpudding, it advertises 'modes' like cabal install  cabal unpack
19:08:03 <roconnor> > do y <- [2007..]; m <- [1..12]; d <- [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 != 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30]; return (y,m,d)
19:08:04 <lambdabot>   Not in scope: `!='
19:08:11 <roconnor> > do y <- [2007..]; m <- [1..12]; d <- [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 /= 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30]; return (y,m,d)
19:08:12 <lambdabot>   [(2007,1,1),(2007,1,2),(2007,1,3),(2007,1,4),(2007,1,5),(2007,1,6),(2007,1,...
19:08:13 <tensorpudding> Yes, it advertises them.
19:08:14 <ivanm> roconnor: this isn't C... ;-)
19:08:21 <interferon> ivanm: eh?
19:08:22 <tensorpudding> I'm trying to figure out how that is supposed to work
19:08:22 <edwardk> roconnor++
19:08:23 <kmc> i think i'm taking the addr of the info table
19:08:25 <roconnor> ivanm: *blush*
19:08:28 <ivanm> interferon: ummm, nvm
19:08:42 <interferon> roconnor: you win #haskell
19:09:11 <applicative> tensorpudding, though now that you mentioned it, i was looking for uses of cmdargs that had 'modes' and i'm not sure i found one...
19:09:13 <tensorpudding> but cmdArgs takes [Mode a], which seems to imply that all the modes have to have the same value type?
19:10:23 <applicative> tensorpudding, i found http://sebfisch.github.com/haskell-barchart/
19:11:08 <applicative> i see, you're thinking youll get all flags for all modes
19:11:39 <edwardk> applicative: http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm the last one there Maker uses modes
19:11:54 <tensorpudding> Ah, of course.
19:12:00 <tensorpudding> an enumeration type..
19:12:16 <applicative> barchart uses the modes
19:12:20 <edwardk> and a mode associated with each alternative
19:12:32 <applicative> the help it prints out, has flags for each mode, then 'common flags'
19:12:56 <edwardk> the only thing i can't get out of it that i would like is a localized version of each configuration string read from a .PO file somewhere ;)
19:13:22 <edwardk> to give localized usage, but thats not very high on my priorities now
19:14:14 <MisterN> @undo do y <- [2007..]; m <- [1..12]; d <- [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 /= 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30]; return (y,m,d)
19:14:14 <lambdabot> [2007 ..] >>= \ y -> [1 .. 12] >>= \ m -> [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 /= 0) then 29 else 28 else if m `elem` [1, 3, 5, 7, 8, 10, 12] then 31 else 30] >>
19:14:14 <lambdabot> = \ d -> return (y, m, d)
19:14:24 <MisterN> @pl . undo do y <- [2007..]; m <- [1..12]; d <- [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 /= 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30]; return (y,m,d)
19:14:24 <lambdabot> (line 1, column 1):
19:14:24 <lambdabot> unexpected "."
19:14:24 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
19:14:41 <MisterN> how was the syntax for combining pl and undo again?
19:14:47 <edwardk> applicative: ooh i didn't see the common flags section. i have a bunch of those.
19:17:00 <MisterN> @. pl undo do y <- [2007..]; m <- [1..12]; d <- [1 .. if m == 2 then if y `mod` 400 == 0 || (y `mod` 4 == 0 && y `mod` 100 /= 0) then 29 else 28 else if m `elem` [1,3,5,7,8,10,12] then 31 else 30]; return (y,m,d)
19:17:03 <lambdabot> ([1..12] >>=) . ap (ap . (((>>=) . enumFromTo 1) .) . (`ap` flip (flip if' 31 . (`elem` [1, 3, 5, 7, 8, 10, 12])) 30) . flip (if' . (2 ==)) . flip (flip if' 29 . ap ((||) . (0 ==) . (`mod` 400)) (ap
19:17:03 <lambdabot> ((&&) . (0 ==) . (`mod` 4)) ((0 /=) . (`mod` 100)))) 28) (((return .) .) . (,,)) =<< [2007..]
19:17:50 <MisterN> :t if'
19:17:51 <lambdabot> Not in scope: `if''
19:18:03 <interferon> what is undo?
19:18:05 <edwardk> applicative: hrmm trying to figure out where in http://github.com/sebfisch/haskell-barchart/blob/master/src/barchart.hs it sets up the common options
19:18:10 <interferon> oh, removes do syntax?
19:18:21 <MisterN> interferon: yup
19:18:35 <edwardk> oh neat it is automatic
19:18:36 <MisterN> i think pl and undo make this beast particularly unreadable :)
19:37:19 <applicative> edwardk. i was going to say, it looks like most of it is automatic.
19:37:44 <edwardk> applicative: yeah, trying to figure out how to write the equivalent of 'cabal help'
19:38:10 <jmcarthur> buff14
19:38:15 <jmcarthur> woah that was wrong
19:38:31 <jmcarthur> sorry, supposed to be a weechat command but i apparently can't use a keyboard
19:38:33 <edwardk> applicative: the only other piece that is tedious is i'd like to refactor out some of the mode noise that gets repetitive, i.e. the million+1 configure options
19:38:43 <edwardk> which are shared with upgrade, install, etc.
19:43:32 <edwardk> applicative: looks like i can do some of that by providing the same mode different arguments. i.e. using one constructor for configure, upgrade and install, and sharing most of the configuration
19:48:48 <applicative> edwardk. i think i see.  it seems this would be great if i were churning out a complex executable every few days, but for one off use its as hard to penetrate as rolling one's own
19:49:59 <sbahra> dons, ping?
19:50:13 <sbahra> Isn't it better if the link to the GHC LLVM back-end on http://haskell.org/ linked to http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM instead?
19:52:07 <edwardk> applicative: i'm currently wrestling with the most complicated executable i've played with in a while, so its working out surprisingly well given the number of hoops i'm making it jump through ;)
19:52:57 <applicative> edwark, i see, i think i'm taking it back anyway.   I guess you saw his Maker example is like that, there are common fields
19:52:58 <applicative> data Maker  = Wipe | Test {threads :: Int, extra :: [String]} | Build {threads :: Int, method :: Method, files :: [FilePath]}
19:53:15 <edwardk> applicative: yeah
19:53:39 <edwardk> applicative: what i'm trying to do right now is refactor things so the 40+ common options i have across 3 of my modes aren't copy-paste fodder
19:53:52 <sbahra> Hi edwardk
19:53:58 <edwardk> heya samy
19:54:14 <applicative> so theres a command     maker test --threads=17  etc    maker build --threads=3
19:54:35 <applicative> i see, you dont want to write {threads::Int,...} forty times
19:54:40 <edwardk> yeah
19:54:57 <edwardk> and get all the corresponding configure = mode $ Configure { ... } nonsense exactly the same each time as well
19:56:03 <edwardk> trying to figure out how to 'rename' a mode so it doesn't match the constructor, that way i can make 3 modes off the same constructor and share basically everything
19:56:38 <applicative> something like type synonyms
19:56:38 <applicative> ha
19:57:43 <edwardk> well, one option is to just duplicate the fields, then make something like commonDef :: Mode -> Mode; which does commonDef mode = mode { target = User & enum [ User &= ... ], .. } and say configure = mode $ commonDef $ Configure { ... } where i configure the non-common args there
19:58:06 <edwardk> then i can use that to break up each of my clusters of options and patch them in where appropriate
19:58:18 <edwardk> with only one copy-paste nightmare
19:59:06 <edwardk> the other is i can make one ConfigureUpgradeInstall constructor that i pass its mode as one of its arguments, and construct it separately, but then its harder to tune the option list per mode
19:59:29 <dancor> hm i wonder if a Map-based instead of record-based approach is better
20:00:58 <edwardk> dancor for options?
20:01:10 <edwardk> more expensive access at runtime though
20:01:20 <dancor> so like testOptions = commonOptions `union` testOnlyOptions
20:02:13 <dancor> ya idk
20:02:28 <edwardk> dancor: well, i suppose one could wish for option union and option disjunction or composition of options by nesting other modes, but now its getting silly
20:02:56 <dancor> one coder's silly is another's awesome
20:03:21 <edwardk> er by option union/composition i mean something like taking merging options from a and b when fed (a,b)
20:03:29 <applicative> in haskell there is no code
20:03:43 <edwardk> or data Command = Configure { ... , common :: Common }
20:04:25 <dancor> but code is shorter than program and haskell is all about conciseness
20:05:32 <applicative> there are just definitions
20:05:32 <dancor> i guess i should type "code" and "program" to keep things well-typed
20:06:35 <dancor> is an import statement a definition
20:07:13 <applicative> we import definitions, yes
20:07:26 <dancor> that may be an answer to a question
20:07:33 <applicative> with a view to making new ones
20:07:35 <dancor> but it wasn't an answer to my question :)
20:08:02 <applicative> okay, but is an import statement code?
20:09:32 <dancor> i think it's a "statement" and i consider "statements" to be "code" in the sense of "coders"
20:10:02 <dancor> i think "coding" started as a bit of a misnomer
20:10:15 <dancor> but i'm unwilling to turn my back on it now :)
20:10:20 <applicative> you mean a statement in the sense of an instruction, imperative, command
20:10:24 <applicative> ?
20:10:36 <dancor> ya i guess it's an instruction to the haskell compiler
20:11:08 <applicative> man do i not think of it that way, but i'm not to be trusted, i'm sure.
20:11:50 <dancor> well is it a Dec in TH?
20:11:53 <applicative> when i write    import Data.List    i mean, that the definitions I give will use words on the right hand side, in the sense of Data.List
20:13:07 <millertime> i would like to participate in the google summer of code. and i love haskell.
20:13:21 <applicative> it sometimes happens on #haskell, people will use some expression, but it turns out Jones means the Data.Blah sense and Smith the Control.Blip sense
20:13:32 <applicative> the google summer of definitions
20:13:39 <dancor> lol
20:13:52 <dancor> of top-level declarations
20:14:02 <applicative> it just shows what a menace they are.
20:14:32 <applicative> summer of code, that means they are pushing obscurity, not clarity, definition, lucidity, rigor
20:14:47 <dancor> code is concise!
20:15:06 <dancor> they got 1 out of 5
20:15:09 <applicative> code is secret, occult
20:15:54 <dancor> millertime: have you been here http://hackage.haskell.org/trac/summer-of-code/
20:16:20 <edwardk> hrmm looks like i can't do the 'one shared constructor' thing. i dug through the mode source and it just takes the name, no opportunity for a 'flag' or other attrib override to replace the name
20:16:27 <dancor> i don't know anything but that looks like a good starting point..
20:16:31 <millertime> dancor: i have, not sure what to do there..
20:16:33 <applicative> code must be decoded.   what needs decoded about    ones = 1:ones     square x = x * x    ?
20:17:16 <millertime> hence why im on irc :P
20:17:17 <dancor> * meaning multiply has to be "decoded"
20:17:55 <edwardk> millertime: what are you looking at tackling?
20:18:55 <edwardk> millertime: you're in the right place. i somehow wound up nominating myself as the organizer for this year. ;)
20:19:43 <millertime> that is an excellent question. unfortunately i've been away from my computer most of spring break and haven't had a chance to find something to tackle...
20:20:32 <applicative> edwardk, darcs-benchmark may have a more complex use of cmdargs:  http://code.haskell.org/darcs/darcs-benchmark/main.hs
20:20:57 <edwardk> millertime: well, there was some talk over on #hnn about trying to see about tackling improvements to the graph library. there are a bunch of posts on the reddit.com/r/haskell_proposals that might make good projects
20:21:02 <edwardk> applicative: ooh
20:21:33 <millertime> and i could pick something from there?
20:21:48 <edwardk> millertime: it might make a good starting point to get a feel for what the community is looking for
20:21:49 <millertime> i'm quite novice >.<
20:22:48 <edwardk> the main things to keep in mind are that whatever it is should benefit the community as a whole where possible, by either improving something the community uses, or by enlarging the community to include more people, and that it should be something reasonable for a summer of coding.
20:23:05 <edwardk> it helps if you can sell folks on why you are the right person for the particular job as well
20:23:06 <applicative> edwardk, it's complex but not to the point I think, no declaring mode $ blah...
20:23:58 <edwardk> applicative: yea they get away with barely using cmdargs at all
20:24:18 <edwardk> ah its in that Config module
20:24:53 <[swift]_> i find it remarkable how much shorter my code is getting as i get better with haskell. i can only imagine how terse my code is going to be a month or two from now
20:24:59 <edwardk> http://code.haskell.org/darcs/darcs-benchmark/Config.hs
20:30:07 <applicative> edwardk, i see not much to that.   i also see http://code.haskell.org/~roelvandijk/code/ls-usb/ls-usb.hs  which seems pretty straightforward...more interesting is his use of unicode in the text
20:32:20 <edwardk> i suppose i could use getopt/the environment to check for a --locale, then pass appropriate modes in by hand with the text substitution done.
20:33:03 <edwardk> not worth it for now, but i want to make sure i can juggle it here since i do it everywhere else
20:35:24 <applicative> edwardk, hah, i have proof that you'll be cutting and pasting, see  hssqlppp
20:35:39 <edwardk> i already started ;)
20:35:55 <edwardk> i at least copy and paste the field names, but i use combinators to add the fields to the mode
20:36:21 <dancor> cutting and pasting is wrong, there must be a better way using TH insanity
20:36:26 <edwardk> that way if i'm masochistic i can use TH to fix the ...
20:36:26 <edwardk> yeah
20:36:28 <edwardk> =)
20:36:31 <dancor> heh
20:36:52 <applicative> http://community.haskell.org/~JakeWheat/hssqlppp/pandoc_source/examples/HsSqlSystem.lhs.html
20:37:32 <applicative> 'mode' has 22 matches in module Main ....
20:38:11 <applicative> "cutting and pasting is wrong, there must be a better way using TH insanity"
20:38:11 <edwardk> applicative:     build = addBuildDirOpt $ addPackageOpts $ addTargetOpt $ Build {} -- its not so bad
20:41:28 <SecretofMana> sigh, grabbed ghc-6.10.3 when it's .4 I need
20:41:37 <edwardk> ouch
20:41:53 <edwardk> did you have to build it or did you just install binaries?
20:42:19 <SecretofMana> just install binaries so nothing that won't take too long to correct
20:42:47 <applicative> SecretofMana, what 'platform' are you on.
20:43:03 <SecretofMana> Ubuntu 10.04
20:43:57 <applicative> i see, so you can't install the 'haskell platform' that has 6.10.4 yet, i guess
20:44:26 * SecretofMana shrugs
20:46:48 <applicative> SecretofMana, http://packages.debian.org/sid/haskell-platform
20:47:56 <SecretofMana> Thanks.
20:48:23 <applicative> Oh wait, I see they''re going straight to ghc 6.12.whatever....
20:49:11 <dancor> aavogt: you said: if you're given  'x, you can get x with   $(varE 'x)
20:49:31 <dancor> but, myTHFunc name = return . LitE . StringL . show $ $(varE 'name)
20:49:39 <dancor> doesn't print the _value_
20:52:12 <dancor> the way that this does: myTHFunc xName x = return . LitE . StringL $ show x
20:52:34 <dancor> myTHFunc :: (Show a) => Name -> a -> Q Exp
21:07:05 <uorygl> I wish irssi wouldn't move all my windows to the left every time I close one.
21:07:19 <dancor> opensource!
21:07:35 <dancor> Where It's Always Your Fault
21:07:48 <roconnor> > deriv (\x -> x**x) x
21:07:49 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
21:08:30 <dancor> (1 *)?
21:08:47 <dancor> > deriv 1
21:08:48 <lambdabot>   No instance for (GHC.Num.Num
21:08:48 <lambdabot>                     (Data.Number.Dif.Dif a -> ...
21:08:50 <dancor> > deriv x
21:08:52 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
21:08:52 <lambdabot>                        ...
21:08:59 <dancor> > deriv (\x -> 1)
21:09:00 <lambdabot>   {-3->0;-2->0;-1->0;0->0;1->0;2->0;3->0}
21:09:23 <dancor> > deriv (\x -> 1) 5
21:09:24 <lambdabot>   0
21:10:43 <ivanm> @type deriv
21:10:44 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
21:10:52 <ivanm> what is this mystical Dif type?
21:11:25 <roconnor> ivanm: it is the local ring R[x]/(x^2)
21:11:53 <ivanm> huh?
21:12:20 <roconnor> ivanm: you know how the complex numbers add an element i such that i^2 = -1 ?
21:12:27 <ivanm> yup
21:12:50 <uorygl> Lemme guess, Dif adds an element e such that e^2 = 0.
21:12:53 <roconnor> ivanm: Dif adds an element epsilon such that epsilon^2 = 0
21:13:05 <Pseudonym> I've always seen that called "dual".
21:13:11 <Pseudonym> But "dual" is so overloaded.
21:13:12 <ivanm> hmmm.....
21:13:39 <ivanm> what's the significance of squaring it?
21:13:46 <roconnor> so Dif is analogous to Complex
21:14:00 <Pseudonym> ivanm: Think of Minkowski spacetime.
21:14:09 <roconnor> ivanm: it removes higher order infitesimals leaving only the first order terms
21:14:15 <ivanm> x^2 + y^2 + z^2 + t^2 ?
21:14:19 <Pseudonym> If v^2 > 0, it's spacelike, if v^2 < 0, it's timelike and if v^2 = 0, it's lightlike.
21:14:24 <Pseudonym> No.
21:14:25 <SecretofMana> hm, when trying to ./configure the haskell platform before installation on Ubuntu 10.04 I get "configure: error: The zlib C library is required"
21:14:31 <Pseudonym>  x^2 + y^2 + z^2 - t^2
21:14:42 <ivanm> SecretofMana: so install the zlib C library....
21:14:50 <ivanm> Pseudonym: oh, right
21:15:24 <uorygl> The derivative of f(x)^2 is 0 when f(x) is 0!
21:16:00 <uorygl> Too bad this fails due to a type error:
21:16:04 <uorygl> > fix deriv
21:16:05 <lambdabot>   Occurs check: cannot construct the infinite type:
21:16:05 <lambdabot>    a = Data.Number.Dif.Di...
21:16:23 <Pseudonym> Yeah, the cool part is that analytic functions can be expanded via Taylor's theorem:
21:16:29 <roconnor> uorygl: ya there are other similar data types that will allow that that have all the higher order derivatives
21:16:43 <uorygl> I would imagine.
21:16:45 <Pseudonym> f(x + e) = f(x) + e f'(x) + e^2 R(x)
21:16:58 <Pseudonym> where the remainder, R(x) is irrelevant because e^2 = 0.
21:17:50 <SecretofMana> ahh, I see why I was having difficulties installing zlib, it's zlib1g, not zliblg
21:18:06 <SecretofMana> such a subtle difference between a one and an l
21:18:55 <SecretofMana> oh wait zlibc's the one I want anyways
21:19:58 <uorygl> It's almost as if for all real numbers x and e, f(x + e) were equal to f(x) + e f'(x) + e^2 f''(x)/2 + e^3 f'''(x)/3! + e^4 f''''(x)/4! + . . ., isn't it!
21:20:17 <Pseudonym> Exactly.
21:20:22 <uorygl> Hey, neat, I just discovered the Taylor series.
21:20:45 <Pseudonym> So if e has norm zero, you can ignore all higher terms.
21:21:30 <uorygl> Now to meditate on all this until suddenly the answer to the Riemann hypothesis comes to me.
21:22:02 <Pseudonym> Don't you need a Dirichlet series, rather than a Taylor series, for that?
21:22:15 <SecretofMana> lol, uorygl. Also yay, finally got the zlib I needed
21:23:40 <uorygl> Well, the zeta function is a Dirichlet series.
21:24:15 <luqui> this is the best language channel ever
21:24:37 <luqui> what a line to come in on (uorygl's)
21:25:48 <uorygl> I really should read "On the Number of Primes Less Than a Given Magnitude" some time.
21:25:56 <ddarius> It's a good read.
21:26:50 <Pseudonym> You must be at least *this* smart (arrow pointing to place on IQ bell curve) to understand #haskell.
21:27:48 <uorygl> I wonder whether I know enough math to understand it.
21:27:58 <Pseudonym> You can never know enough maths.
21:28:07 <ddarius> uorygl: Do you know complex analysis?
21:28:08 <uorygl> Yes, but I can know enough math to understand something.
21:28:22 <uorygl> I might know what complex analysis is!
21:28:26 <Pseudonym> I know enough maths that I can look up anything I don't understand, and usually understand _that_.
21:28:43 <ddarius> Pseudonym: Or apply recursively ...
21:28:50 <Pseudonym> Indeed!
21:28:57 <uorygl> If it has anything to do with Dedekind cuts, I know something about it.
21:29:00 <_Ray_> Hi :) I'm in ghci, and I want a list of Ints, but if I type [1,-2,1,1,-1,3,-3,3], it gives me a list of Integers instead, and then complains that my functions don't type well. How can I fix this?
21:29:06 <Pseudonym> I understand very little topology beyond the basics, for example.  But I can understand a topology textbook.
21:29:21 <Pseudonym> :t [1,-2,1,1,-1,3,-3,3]
21:29:22 <lambdabot> forall t. (Num t) => [t]
21:29:33 <uorygl> :t [1,-2,1,1,-1,3,-3,3] :: [Int]
21:29:34 <lambdabot> [Int]
21:29:36 <Pseudonym> The monomorphism restriction turns that into [Integer].
21:29:37 <Pseudonym> Right.
21:29:49 <_Ray_> Oh, I can cast like that? Awesome :)
21:29:52 <Pseudonym> So normally, you put on an explicit type definition, liek that.
21:29:54 <Pseudonym> Also:
21:29:59 <Pseudonym> :t [1::Int,-2,1,1,-1,3,-3,3]
21:30:00 <lambdabot> [Int]
21:30:10 <_Ray_> :o Why's that?
21:30:11 <Pseudonym> Alternatively, there's default(Int).
21:30:16 <_Ray_> Oh, right, it knows everything is of the same type.
21:30:19 <Pseudonym> Well, all elements of a list have to be the same type.
21:30:20 <Pseudonym> Right
21:30:38 <_Ray_> Thank you :)
21:30:58 <Pseudonym> default(Int) has consequences which may be undesirable, but I should mention that it's there.
21:31:22 <uorygl> Well, it's not really a cast.
21:31:27 <Pseudonym> No.
21:31:31 <Pseudonym> :t [id]
21:31:32 <lambdabot> forall a. [a -> a]
21:31:36 <Pseudonym> :t [id :: Int -> Int]
21:31:37 <lambdabot> [Int -> Int]
21:31:42 <Pseudonym> That's not a cast.
21:31:48 <uorygl> [1,-2,1,1,-1,3,-3,3] is polymorphic, meaning that it can have different types depending on what type you declare it to be.
21:32:12 <ddarius> uorygl: Heard of abstract Stone duality?
21:32:13 <uorygl> (In this case, your implementation automatically declared it to be an [Integer] for some reason.)
21:32:23 <Pseudonym> The "some reason" is in the language spec.
21:32:27 <uorygl> True.
21:32:32 <Pseudonym> Top-level defintions must be monomorphic.
21:32:35 <Pseudonym> i.e. not polymorphic
21:32:49 <uorygl> ddarius: nope.
21:32:56 <Pseudonym> It's something that does trip up beginners.
21:33:10 <uorygl> Huh, both the real part and the imaginary part of an analytic complex function must satisfy Laplace's equation?  That is awesome.
21:33:12 <Pseudonym> It's fair to say that the hoardes aren't entirely happy with this behaviour.
21:33:12 <ddarius> Pseudonym: Really the issue is if you've reached "mathematical maturity" i.e. you can understand something given definitions.
21:33:25 <Pseudonym> Yes and no.
21:33:37 <Pseudonym> I usually require a few representative examples as well as the definition.
21:33:45 <ddarius> Pseudonym: I agree that there is more to it than that, but I'd say that's the core.
21:33:59 <ddarius> uorygl: Holomorphic functions are fairly tightly constrained.
21:34:24 <uorygl> Indeed.
21:34:59 <uorygl> Silly definition-of-a-holomorphic-function, requiring a function's derivative to be the same in every direction, thereby ruling out perfectly good functions like the complex conjugate function.
21:35:00 <twink> There's usually a breadth of knowledge concern with mathematical maturity.
21:35:00 <ddarius> uorygl: In fact, the key property of a holomorphic function is that, given its values on any open subset, you can extend to the entire domain.
21:35:31 <uorygl> ddarius: how about on an open segment of the real line?
21:35:32 <ddarius> twink: Also, agreed, though I'm not sure if that's inherent or just a side-effect of acquiring mathematical maturity.
21:35:36 <Pseudonym> Still, discussions here aren't usually at the level of the n-Category Cafe.
21:36:13 <uorygl> Intuitively, it seems like given a function whose domain is the real line, it should have at most a unique holomorphic extension to the complex plane.
21:37:24 <twink> It may not be the whole plane (e.g. the line itself may form a natural boundary and it only extends to the upper half plane.
21:37:26 <uorygl> Heck, any open subset?  I might go so far as to say you can do it for any sufficiently nice curve.
21:38:07 <uorygl> I'd be kind of surprised to see a function defined on its natural boundary.
21:38:11 <DrSyzygy> uorygl: You don't get uniqueness of extensions if you have a small enough definition set.
21:38:21 <ddarius> uorygl: Given a closed curve would be enough.
21:38:44 <uorygl> The real line is a closed curve, if you pretend it's closed.  :P
21:38:52 <turiya> hi
21:39:01 <ddarius> But, a holomorphic functions values on its domain are determined by its values on its boundary.
21:39:05 <uorygl> DrSyzygy: what's an example?
21:39:05 <Pseudonym> Greetings.
21:39:27 <DrSyzygy> Define your complex function to be 0 at the origin.
21:39:27 <turiya> can someone enlighten me on the concept of referential transparency?
21:39:32 <ddarius> uorygl: You can if you shove it into the Riemann sphere, however the only holomorphic functions on the Riemann sphere are the constant functions.
21:39:51 <ezyang> turiya: What do you want to know?
21:39:53 <uorygl> Well, right.  That's barely even a curve, though.
21:40:09 <cads> > let  x! = product [1..x] in map (\x -> x!)  [0..4]
21:40:10 <lambdabot>   <no location info>: parse error on input `='
21:40:16 <Pseudonym> turiya: The Wikipedia page is pretty good.  Did you read that?
21:40:22 <Pseudonym> http://en.wikipedia.org/wiki/Referential_transparency_%28computer_science%29
21:40:32 <cads> > let  x (!) = product [1..x] in map (\x -> x (!))  [0..4]
21:40:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
21:40:37 <turiya> Yes,i did read some stuff
21:40:43 <uorygl> I think you want (x!).
21:40:43 <turiya> but i have a question
21:40:47 <Pseudonym> OK
21:41:00 <cads> > let  (x!) = product [1..x] in map (\x -> x !)  [0..4]
21:41:01 <lambdabot>   <no location info>: Parse error in pattern
21:41:10 <cads> :)
21:41:22 <turiya> putStrLn cannot return any meaningful value.. this is what a tutorial i am reading says
21:41:33 <cads> sigh - I will read the postfix operator extension
21:41:39 <ezyang> :t putStrLn
21:41:40 <lambdabot> String -> IO ()
21:41:45 <ezyang> turiya: Go on.
21:41:52 <turiya> what if putStrLn returns the same string that was given as input
21:41:53 <ddarius> > let (!) x = product [1..x] in (5 !)
21:41:54 <lambdabot>   120
21:42:12 <turiya> it does not violate referential transparency
21:42:23 <ezyang> turiya: Incorrect.
21:42:32 <turiya> and ofcourse it also has to print it to the screen
21:42:46 <cads> > let (!) x = product [1..x] in (! 5)
21:42:46 <turiya> ezyang: why?
21:42:47 <lambdabot>   No instances for (GHC.Enum.Enum (t -> t1), GHC.Num.Num (t -> t1))
21:42:47 <lambdabot>    arisin...
21:42:49 <uorygl> turiya: well, there's nothing preventing putStrLn from returning the same string that was given as input.
21:42:49 <ezyang> Suppose I have x; x -- if I substitute it in I'll get the print behavior twice.
21:43:08 <uorygl> turiya: there's simply no very good reason for it to do so, so we've made it return () instead.
21:43:15 <cads> > let (!) x = product [1..x] in  5 1
21:43:16 <lambdabot>   Ambiguous type variable `t' in the constraint:
21:43:16 <lambdabot>    `GHC.Num.Num t' arising f...
21:43:19 <cads> > let (!) x = product [1..x] in  5 !
21:43:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:43:25 <ezyang> :t (\x -> putStrLn x >> return x)
21:43:26 <lambdabot> String -> IO String
21:43:27 <cads> hmm, it needs to be in the section
21:43:32 <ddarius> cads: Yes.
21:43:43 <uorygl> So can you give a definition set over an open curve such that there are multiple holomorphic extensions?
21:43:51 <turiya> Yes, but the reason is not that we cannot make putStrLn ref. trans
21:43:52 <ezyang> turiya, however, we can't make a function that prints to the screen with type String -> String
21:44:33 <turiya> as far as I understand putStrLn :: String -> IO ()
21:44:33 <cads> > let (!) x = product [1..x]; c n k = (n !) /((k !) * ((n-k) !) ) in  c 10 4
21:44:34 <lambdabot>   210.0
21:44:42 <ddarius> All the extension does is have the translation of (x !) be (!) x rather than (\y -> x ! y)
21:44:42 <ezyang> There's also something deeper lurking around here with >>=
21:44:45 <turiya> is only to flag it as side affecting. is that right?
21:44:56 <kmc> putStrLn returns a meaningful value
21:45:01 <kmc> it returns an IO action
21:45:09 <uorygl> turiya: pretty much, yeah.
21:45:10 <kmc> IO is not a "tag" on function types to indicate side effects
21:45:15 <kmc> IO is a first-class type constructor in its own right
21:45:27 <kmc> putStrLn is a pure side-effect-free function
21:45:37 <kmc> when you give it a string x, it returns a "recipe" for "how to print string x"
21:45:43 <kmc> which has type IO ()
21:45:55 <ivanm> yeah, yeah, only main has a side effect, blah, blah, blah
21:45:59 <turiya> kmc: putStrLn changes the world
21:46:00 <ddarius> turiya: There is nothing special about IO Int versus [Int] which is [] Int.
21:46:09 <uorygl> You can sort of think of it as being a "tag", but IO () is itself a type.
21:46:11 <ddarius> IO is just another type constructor.
21:46:13 <kmc> applying putStrLn does not change the world
21:46:17 <ivanm> turiya: kmc is arguing (I think) that it doesn't actually change the world where you call it
21:46:20 <kmc> execution is not the same thing as evaluation
21:46:33 <ddarius> uorygl: It's not a tag any more than the list type constructor is a "tag."
21:46:47 <uorygl> You can think of that as being a tag.  :P
21:46:49 <kmc> when you evaluate (putStrLn "foo") no side effect occurs.  it returns a recipe for how one *could* perform a side effect in the future
21:47:46 <kmc> Haskell has values that represent side effects.  they just aren't functions.
21:47:56 <kmc> (and you can argue about whether the adjective "side" is applicable)
21:48:11 <turiya> kmc: many tutorials say that it changes the state of the world.. so i was thinking like that
21:48:29 <ezyang> turiya: Once main gets to it, yeah, it does that
21:48:36 <kmc> turiya, if a tutorial claims that applying the function putStrLn causes a string to be printed, it is incorrect
21:48:47 <ezyang> but if I just have a putStrLn hanging out, it doesn't have to do anything
21:48:52 <tensorpudding> damn, it looks like cmdargs doesn't work with maybe's
21:49:05 <kmc> that is why this code has no effect:  let x = putStrLn "hello" in 2+2
21:49:17 <kmc> you create an IO-recipe named x, but you never execute it
21:49:37 <turiya> kmc: ok, so the type IO () is only a token for the programmer to know that the action might change the state of the world when executed
21:49:44 <kmc> "only a token"?
21:49:51 <kmc> is the type [Int] "only a token" to indicate a list of ints?
21:49:59 <kmc> IO is a type-constructor just like [] or Maybe
21:50:02 <turiya> kmc: what other purpose does it serve?
21:50:08 <turiya> kmc: ok
21:50:16 <kmc> the type "IO ()" represents "a recipe for performing IO"
21:50:44 <kmc> the type "IO t" represents "a recipe for performing IO and producing a result of type t"
21:50:50 <uorygl> It's sort of weird to talk about what a value "does" in Haskell, since they don't do anything unless you either evaluate or execute them, and evaluation and execution are separate things.
21:50:59 <kmc> but when there is no meaningful result, we use the type ()
21:51:20 <uorygl> "What does this function do?" "Oh, it just sits there on the hard drive, until the OS loads it into memory and it's executed.  Why?"
21:51:31 <kmc> "action" and "execute" are terms specific to this IO type
21:51:31 <turiya> ok.. what exactly then is changing the state while execution?
21:51:42 <kmc> "apply" and "evaluate" are fundamental to computation
21:51:51 <turiya> if we divide execution and evaluation
21:52:19 <kmc> turiya, to run a Haskell program: evaluate the value named "main" to get an IO action.  then execute it.
21:53:15 <turiya> ok, that is somewhat clear now
21:53:23 <uorygl> A Haskell program is sort of like a some-assembly-required cookbook.  First, you follow one set of instructions to create a cookbook; doing this part takes no ingredients and produces no food.  Then you use the resulting cookbook to cook something.
21:53:41 <ezyang> turiya: It's important to note that the Haskell language doesn't let you "execute" an IO action. 'main' is just implicitly understood to be what you evaluate and then execute.
21:53:55 <kmc> you can glue together IO actions to make compound actions that do several things
21:53:58 <FliPPeh_> @faq Can haskell cure my increasingly showing signs of age?
21:53:58 <lambdabot> The answer is: Yes! Haskell can do that.
21:54:05 <kmc> this is done with operators like (>>) and (>>=), or with the "do" syntax
21:54:19 <turiya> yes, i was reading those..
21:54:29 <kmc> turiya, did you see http://haskell.org/haskellwiki/Introduction_to_IO
21:54:38 <turiya> yes..i just read that
21:54:42 <uorygl> So if you say "main = getLine >>= putStr", the set of instructions is this: "Take the getLine recipe and the putStr recipe and bind them together to get the cookbook's main recipe".
21:54:53 <uorygl> Then you follow the recipe.
21:55:07 <turiya> why is the IO monad called one way?
21:55:16 <kmc> because there is no function of type:  IO a -> a
21:55:19 <kmc> unless you cheat
21:55:39 <ddarius> turiya: It's hard to illustrate the notion of referential transparency in Haskell because essentially all expressions in Haskell are referentially transparent so there's nothing to contrast against.
21:55:41 <kmc> this is a special property of IO, not a property of monads in general
21:55:45 <kmc> in fact, IO is a very atypical monad
21:56:02 <kmc> ddarius, well, you can make toy examples that aren't using Debug.Trace
21:56:12 <uorygl> Implementations of Haskell do actually provide a function of type IO a -> a, but mentioning it makes people get really nervous.
21:56:30 <turiya> what would such a function break?
21:56:40 <ezyang> referential transparency! :-)
21:56:49 <kmc> turiya, your Haskell compiler uses the assumption of referential transparency to allow it to make aggressive optimizations
21:56:52 <turiya> i cant see how
21:57:06 <uorygl> It would result in undefined behavior.
21:57:21 <kmc> turiya, using unsafePerformIO i can make a function of type Int -> Int which returns a different value every time it's called with the same arg
21:57:29 <kmc> that breaks a basic property of Haskell functions
21:57:39 <kmc> the importance of ref. transparency (both to the programmer and to the compiler) is that it allows you to reason about equals for equals
21:57:58 <kmc> if you have a definition "let x = e" then anywhere x appears, you can think about e appearing there instead
21:58:01 <uorygl> Call the function "unwrap".  Then a function might evaluate (unwrap getLine) two times and get two different results, but assume that they're the same, and therefore cause demons to fly out of your nose or something.
21:58:03 <cads> ddarius, that postfix bang operator is not an extension
21:58:15 <turiya> getLine :: IO string
21:58:30 <kmc> getLine :: IO String
21:58:34 <cads> ddarius, is there an intro to extension writing out there?
21:58:46 <turiya> say, f : IO string -> string
21:58:56 <turiya> f :: IO string -> String
21:59:08 <ezyang> cads: Do you mean FFI, or actually extending GHC?
21:59:34 <turiya> i still cant see why that breaks ref.trans
21:59:35 <ddarius> cads: What do you mean by it's not an extension?
21:59:40 <turiya> :(
21:59:43 <cads> ezyang, the latter - extending the grammar it parses, specifically
21:59:47 <kmc> turiya, i'll write you a real example
22:00:00 <Cale> turiya: There are functions of that type, however, they are all constant functions.
22:00:07 <uorygl> turiya: well, do you know what "referential transparency" means?
22:00:11 <turiya> ok
22:00:21 <kmc> :t \_ -> "foo" :: IO String -> String
22:00:22 <lambdabot>     Couldn't match expected type `IO String -> String'
22:00:22 <lambdabot>            against inferred type `[Char]'
22:00:22 <lambdabot>     In the expression: "foo" :: IO String -> String
22:00:23 <cads> ddarius, ah, so it is..
22:00:33 <turiya> uorygl: the same answer for the same arguments
22:00:35 <kmc> :t const "foo" :: IO String -> String
22:00:36 <lambdabot> IO String -> String
22:01:01 <Cale> Actually, there wouldn't be too much that's conceptually wrong with being able to inspect a value of type IO String. It's just that inspecting such a value should not cause it to execute.
22:01:03 <uorygl> turiya: well, then, take the function \x -> x ++ unwrap getLine.
22:01:13 <ddarius> (Actually, it's more of a change than an extension insofar as it changes the meaning (and thus could conceivably break) existing code.)
22:01:19 <uorygl> turiya: if I call it twice with the same arguments, the user may nonetheless enter a different thing each time.
22:01:27 <_Ray_> Is this "pretty"? http://pastebin.com/97bWJtk5 . I do very little .hs, so I wouldn't know :s
22:01:49 <turiya> uorygl: thanks
22:01:51 <ezyang> cads: I guess my best answer is look at SHE ^^
22:01:58 <Cale> Like, you might imagine if Haskell had some way to determine, given a value of type (IO String), whether or not that action was the same action as getLine
22:02:04 <turiya> uorgyl: that was cler
22:02:26 <Cale> So you'd have a function isGetLine :: IO String -> Bool
22:02:35 <Cale> But Haskell doesn't.
22:02:46 <uorygl> :t seq
22:02:47 <lambdabot> forall a t. a -> t -> t
22:02:49 <Cale> In any case, evaluating such a function wouldn't cause any IO to occur
22:03:06 <turiya> thanks all for the help
22:03:19 <turiya> i understood something :)
22:03:20 <uorygl> func = head (filter isPerfect [1,3..]) `seq` getLine
22:03:32 <SecretofMana> hm guys, how do I run GHC as an interactive prompt on Ubuntu? On Windows I just boot up an app but here I can't really figure out how to
22:03:45 <Cale> IO actions are merely descriptions of stuff which might get done at some point, and evaluating them doesn't cause any effects, any more than opening an executable program in a text editor would cause it to run.
22:04:14 <SecretofMana> oh nvm
22:04:14 <ezyang> SecretofMana: ghci in a terminal
22:04:22 <SecretofMana> Thanks
22:04:26 <SecretofMana> =)
22:04:28 <Cale> If you want the IO to happen, you have to execute the action (not just evaluate the expression into a value)
22:04:46 <turiya> kmc, i missed ur example
22:04:50 <kmc> turiya, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24494#a24494
22:05:29 <ddarius> Cale: If you can get "Fibred categories and the Foundations of Naive Category Theory" by Jean Benabou, its an interesting and entertaining read.
22:05:51 <Cale> ddarius: I'll see if I can find it :)
22:06:00 <kmc> turiya, every time you call (f n) it adds n to some hidden state and returns the previous value of the state
22:06:05 <turiya> kmc, thanks.. i still dont understand unsafe operations
22:06:14 <kmc> unsafePerformIO :: IO a -> a
22:06:22 <turiya> ok
22:06:26 <kmc> you asked why IO is called one-way
22:06:30 <kmc> this is the back door to get around that
22:06:36 <kmc> but you have to be careful with it
22:06:42 <kmc> it's best thought of as an alternative to extending the compiler
22:06:44 <Cale> unsafePerformIO takes an IO action of type IO a, and produces a magical value of type a, which if evaluated, causes the IO action to execute
22:07:15 <Cale> This breaks the mental model of strings merely being lists of characters, for example.
22:07:30 <turiya> kmc, what does the $ symbol do?
22:07:31 <Cale> It gives you some magical strings which do IO when you look at them.
22:07:34 <kmc> @src ($)
22:07:34 <lambdabot> f $ x = f x
22:07:41 <kmc> turiya, it's a regular infix operator, with this definition ^^^^
22:07:59 <Cale> The main feature of $ is that it has very low precedence
22:08:06 <kmc> it's ordinary function application
22:08:22 <kmc> you can write:   f $ big complicated expression here
22:08:28 <kmc> instead of:  f (big complicated expression here)
22:08:30 <Cale> So you can use it to avoid writing parens.
22:08:37 <turiya> ok..
22:08:42 <ivanm> unsafePerformIO is only there for FFI, isn't it?
22:08:44 <kmc> but again, it's an ordinary operator.  not special syntax
22:08:55 <Cale> f . g . h $ k x y z  is the same as  (f . g . h) (k x y z)
22:09:08 <ivanm> which is f (g (h k x y z))
22:09:09 <Cale> ivanm: Mainly.
22:09:16 <kmc> ivanm, in the ideal world nobody lives in, yes
22:09:21 <ivanm> kmc: heh
22:09:41 <Cale> Well, it depends, do you consider Data.ByteString's implementation to be FFI?
22:09:54 <ivanm> what other (legitimate) uses does it have apart from FFI and other "bindings" to tools, etc.?
22:10:01 <ivanm> Cale: hmmm...
22:10:12 <Cale> It can be used to extend the language with new datatypes that have low-level implementations in terms of IO
22:10:51 <kmc> also, sometimes you really want to observe evaluation, usually for debugging
22:10:54 <kmc> so we have Debug.Trace
22:10:54 <Cale> Or generally, to make evaluation do new things which evaluation couldn't do before.
22:11:50 <ivanm> I'm having a look at the docs for Data.ByteString, and am trying to work out why it's needed...
22:11:50 <kmc> lazy IO uses something similar
22:12:04 <kmc> ivanm, because it does Foreign-style allocation behind the scenes
22:12:08 <ivanm> is it because of all the "side effects" it does?
22:12:12 <ivanm> kmc: *nod* that's what I figured
22:12:44 <Cale> Of course, the whole point is that there's no way you can tell that ByteString uses unsafePerformIO behind the scenes.
22:12:57 <Cale> If you could tell, it would be considered a bug. :)
22:13:03 <ivanm> *nod*
22:14:26 <ivanm> hang on, they have INLINE pragmas everywhere, and the docs say you should use NOINLINE ///
22:14:49 <kmc> safePerformIO :: forall (x :: IO a). ProofThatActionIsActuallyOK x -> a
22:14:54 <kmc> yet another reason to get dependent types!
22:15:27 <liyang> How do you prove anything about I/O? :-/
22:15:44 <kmc> same way as about anything
22:16:08 <kmc> you probably need a machine model
22:16:18 <ivanm> by talking really really fast with heaps of hand waving actions!
22:16:39 <ddarius> kmc: Yes, to begin with, you'd have to define IO.
22:16:43 <kmc> but e.g. there are verified compilers in Coq that include a reasonably complete model of x86 machine language
22:16:49 <kmc> so this is not unheard of
22:16:49 <ddarius> directly or indirectly
22:18:54 <ddarius> I'm pretty sure any attempt to (formally) prove any non-trivial usage of unsafePerformIO is safe is completely impractical.
22:19:22 <kmc> what counts as "non-trivial"
22:19:47 <ddarius> kmc: Something other than "return expr" probably.
22:20:19 <ddarius> You might be able to get away with IORefs though, but then we have ST.
22:21:47 <kmc> yeah
22:22:05 <kmc> that's well within the scope of things that have been done in formalizing compilers for functional languages
22:22:40 <kmc> i'm thinking about http://adam.chlipala.net/papers/ImpurePOPL10/ which has references and exceptions
22:23:02 <ddarius> Stuff that's completely within the language would be feasible.
22:23:07 <ddarius> But any actual IO would not.
22:23:21 <kmc> stuff that involves ByteString-like hidden allocation would also be feasible
22:23:26 <ivanm> kmc: there's an impure conference?
22:23:29 <kmc> and i think those are the actual use cases of unsafePerformIO
22:23:30 <kmc> ivanm, haha
22:23:33 <ivanm> how does that work? they let real world stuff in?
22:23:35 <ivanm> ;-)
22:23:38 <kmc> when would you use unsafePerformIO on actual IO?
22:23:43 <kmc> that sounds like a recipe for disaster
22:23:57 <ivanm> (as in industry stuff)
22:24:04 <kmc> that's CUFP ;P
22:24:06 <kmc> you could try to prove some things about lazy IO
22:24:15 <ddarius> kmc: You can write unsafeInterleaveIO (closely enough) with unsafePerformIO.
22:24:16 <kmc> but you'd probably run into the problem that lazy IO is actually brokne
22:24:26 <ivanm> well, it isn't a conference but a workshop... >_>
22:24:30 <ddarius> yes
22:24:50 <kmc> it would be nice to have some proofs about STM and its embedding in IO
22:25:29 <kmc> actually... it might be possible to extract from STM actions a model like those used by SPIN
22:25:36 <ivanm> kmc: you mean "SPJ said it's OK" isn't a good enough proof? :o
22:25:47 <ivanm> s/OK/all good/
22:25:52 <ddarius> kmc: unsafePerformIO is added in the FFI spec for FFI things.
22:25:57 <kmc> "I saw Karp in the elevator and he said it was probably NP-complete"
22:26:03 <ivanm> kmc: exactly
22:26:05 <ddarius> ivanm: He's been wrong before.
22:26:11 <kmc> @quote simonSays
22:26:11 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
22:26:23 <ivanm> ddarius: do I need explicit <joke> ... </joke> tags or something?
22:27:25 <ddarius> It's conceivable that he's used it and never gotten it wrong before.
22:35:49 <SamB_XP> ddarius: who what huh ?
22:45:03 <systemfault> Is there a way to do a "maximum" on an array?
22:46:08 <kmc> convert to a list and use "maximum"
22:46:45 <kmc> with best case optimization it will compile to a simple loop
22:47:13 <ddarius> With best case optimization it will compile to the answer
22:47:23 <systemfault> Ok :)
22:55:38 <edwardk> !@#&(!*@&# i just spent an an hour beating on localizing my usage info trying to use text.i18n.po, then found out it uses parsec 3, so i can't use it with everything else =/
22:56:20 <edwardk> time to cut and paste the whole thing in
22:56:57 <mm_freak_> is there a fancy network library like network-fancy that actually builds?
22:57:06 <edwardk> network-fancy?
22:57:28 <edwardk> found it
22:57:34 <edwardk> cute
22:57:43 <mm_freak_> cute, but fails to build
22:58:29 <mm_freak_>     Not in scope: type constructor or class `FD'
23:00:13 <mm_freak_> the 'Network' module is too high level for some stuff and with Network.Socket i can't resolve IPv6 hosts
23:00:42 <mm_freak_> or rather with Network.BSD, on which i would depend
23:06:10 <mm_freak_> seems like there is no alternative =/
23:08:32 <mm_freak_> taruti: hello there, it seems like you're the author of network-fancy…  it seems like a nice library, but unfortunately it fails to build here — see above for the error message
23:09:25 <mm_freak_> i'm using GHC 6.10.4 on x86…  if you need more info, just ask =)
23:10:21 <ddarius> edwardk: Does it actually expose it's usage of parsec 3?  If it doesn't, you should still be able to build with it.
23:30:43 --- mode: calvino.freenode.net set +o ChanServ
23:31:37 <ski> (chrisdone : re "generally functions like f a -> a are untrustworthy", things like `rootLabel :: Tree a -> a' are just fine)
23:32:07 <dolio> Comonads are untrustworthy.
23:34:10 <ski> (they are not)
23:34:27 <ski> @tell aavogt tuple types and `Either' are good (but i'd like "positional variants"), and lightweight record and variants ("polymorphic variants") are also good
23:34:28 <lambdabot> Consider it noted.
23:34:32 <dancor> what would you do with comonads
23:35:19 <ski> @tell aavogt i was however specifically thinking about temporary recursive types (e.g. possibly to be locally introduced with a `data' or `newtype' inside a `let' or `where')
23:35:19 <lambdabot> Consider it noted.
23:35:28 <roconnor> make label trees?
23:35:33 <roconnor> labeled
23:35:42 <mm_freak_> taruti: linux-openvz 2.6.27, gentoo distribution
23:36:03 <mm_freak_> i tried to install through cabal-install
23:37:32 <taruti> I don't have 6.10.4 locally it did work with 6.10.3 previously
23:38:13 <edwardk> dolio?
23:38:58 <edwardk> they work fine as long as you don't have any pesky branches that don't have any 'a's lying around in them
23:40:13 <dolio> edwardk: Someone said f a -> a was untrustworthy. So I just made the inference.
23:40:17 <edwardk> ah
23:40:53 <dolio> It just depends what f is. if f X = X * ..., then it's fine, if it's f X = X + ..., it might not be.
23:42:15 <mm_freak_> taruti: it complains that 'FD' is not defined…  where would you expect to find the 'FD' type?
23:42:19 <taruti> mm_freak_: can you try whether http://hackage.haskell.org/package/network-fancy-0.1.4 works
23:42:20 <edwardk> hrmm, this cmdargs thing is starting to grow on me. i did have to give up a bunch of my previous gcc-like options, but overall, not bad
23:42:41 <taruti> mm_freak_: there is some CPP to detect GHC version there (it is different for GHC 6.10 and GHC 6.12)
23:42:55 <mm_freak_> taruti: interestingly 0.1.4 builds well
23:43:20 <taruti> ok, so it is the difference.
23:43:45 <taruti> I'll look into it later (don't have 6.10 at hand now), for now use 0.1.4
23:43:52 <mm_freak_> taruti: is there anything wrong with 0.1.4, which would make me wait for the next release?
23:44:58 <taruti> mm_freak_: 0.1.4 is fine.
23:45:26 <taruti> mm_freak_: 0.1.5 is just 0.1.4 with a third party 6.12 fix incorporated
23:45:36 <mm_freak_> ok, great
23:45:38 <mm_freak_> thanks a lot
23:46:08 <mm_freak_> then fastirc will be based on network-fancy =)
