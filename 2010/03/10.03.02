00:08:50 <blueonyx> @pl \((a,x),b) -> (a,b)
00:08:50 <lambdabot> first fst
00:09:01 <blueonyx> @src first
00:09:02 <lambdabot> Source not found. That's something I cannot allow to happen.
00:09:16 <blueonyx> @hoogle first
00:09:16 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
00:09:17 <lambdabot> Data.Monoid newtype First a
00:09:17 <lambdabot> Data.Monoid First :: Maybe a -> First a
00:09:21 <c_wraith> @src Arrow
00:09:21 <lambdabot> class Arrow a where
00:09:22 <lambdabot>     arr, pure   :: (b -> c) -> a b c
00:09:22 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
00:09:22 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
00:09:22 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
00:09:24 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
00:09:26 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
00:09:28 <blueonyx> xD
00:09:56 <c_wraith> @src (->) first
00:09:57 <lambdabot> first f = f *** id
00:10:20 <c_wraith> @src (->) (***)
00:10:20 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
00:10:54 <blueonyx> its magic
00:11:04 <c_wraith> That's not magic. :P
00:11:23 <blueonyx> not more since you showed the src :P
00:12:24 <blueonyx> mh arrows seem as easy as monads, but the applications :/
00:13:27 * MatrixFrog is learning me a Haskell for great good :-D
00:14:01 <blueonyx> have fun :)
00:15:22 <Cale> MatrixFrog: Of course let us know if you have any questions about the language.
00:15:45 <MatrixFrog> thanks!
00:16:09 <MatrixFrog> i watched the video series from channel9 too, but someone on stack overflow recommended Learn you a... so i'm checking it out as well
00:16:47 <MatrixFrog> > :t .
00:16:48 <lambdabot>   <no location info>: parse error on input `:'
00:16:49 <c_wraith> I liked that intro quite a bit.  Of course, I didn't read it until I knew the language decently already, so my judgement may have been off
00:16:53 <MatrixFrog> > :type (.)
00:16:54 <lambdabot>   <no location info>: parse error on input `:'
00:17:03 <MatrixFrog> oh alright
00:17:09 <c_wraith> commands that aren't "execute this" don't start with >
00:17:12 <Cale> :t (.)
00:17:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:17:17 <Cale> :t (Prelude..)
00:17:18 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:17:23 <MatrixFrog> oh ok thanks!
00:17:23 <c_wraith> however, cale's definition of (.) is special. :)
00:17:32 <c_wraith> And cale runs lambdabot :)
00:17:54 <Cale> lambdabot's got lots of nonstandard stuff in it, not all of it mine ;)
00:17:58 <MatrixFrog> :t (the normal version of .)
00:17:59 <lambdabot> parse error on input `of'
00:18:02 <MatrixFrog> :-(
00:18:11 <Cale> That would be the (Prelude..) one I did
00:18:27 <Cale> It's highly unfortunate that . was also used as the module path separator in Haskell.
00:18:47 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
00:19:13 <Cale> Of course, you can do the same in ghci
00:19:26 <MatrixFrog> i did... i was vaguely curious how it decided which one to be a, b, and c.
00:19:37 <MatrixFrog> i would have suspected it would do:
00:19:54 <MatrixFrog> (.) :: (a -> b) -> (c -> a) -> (c -> b)
00:19:57 <MatrixFrog> or something
00:20:04 <c_wraith> MatrixFrog: It took them from the hand-supplied type signature.
00:20:10 <MatrixFrog> cool
00:20:56 <c_wraith> :t let (.) f g x = f (g x) in (.)
00:20:57 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
00:21:06 <c_wraith> that's what it guesses without a hand-supplied type
00:26:02 <blueonyx> i get a haskell moduel from stdin with a function f and then some lines with data i have to transform through f, but i cant aggregate all data, i have to send it back line by line, how is this accomplished with hint (or anything else) best=
00:26:03 <MatrixFrog> point free style = the style with lots of "."s in it
00:26:06 <blueonyx> ?
00:26:11 <MatrixFrog> where "." is sometimes called "point"
00:26:12 <MatrixFrog> just sayin
00:26:14 <blueonyx> :D
00:26:37 <blueonyx> but in (f x) x is also called point
00:26:48 <luqui> point taken
00:27:35 <mjrosenb> hey, does anyone know about the internals of haskell-mode for emacs?
00:27:58 <Saizan> blueonyx: evaluate the 'f' once with hint and then use it like any other function
00:28:35 <blueonyx> Saizan: what function does this? neither interpret nor eval
00:28:49 <blueonyx> in ghc something does it with unsaveCoerce
00:28:56 <blueonyx> *unsafe xD
00:30:20 <Saizan> blueonyx: interpret "f" (undefined :: <type you'd like f to have>)
00:30:42 <blueonyx> of course xD
00:30:48 <blueonyx> wow thanks :)
00:31:06 <Saizan> after you've loaded the module
00:31:49 <mjrosenb> it looks like haskell-mode treats a --> b as a comment
00:31:53 <mjrosenb> which it is not
00:32:34 <blueonyx> mjrosenb: yea :)
00:32:36 <blueonyx> :(
00:33:42 <blueonyx> mh in haskell-font-lock.el: ;; Deal with instances of `--' which don't form a comment.
00:33:55 <blueonyx> line 444
00:34:52 <mjrosenb> blueonyx: yeah, but it does not seem to do the trick
00:35:25 <blueonyx> see comment on line 480, doesnt work as well
00:35:36 <blueonyx> are you into elisp?
00:37:19 <mjrosenb> blueonyx: i have written it before
00:37:28 <mjrosenb> blueonyx: but that looks like gibberish
00:37:57 <blueonyx> oh
00:39:37 <c_wraith> boy, I sure do wish there were some test vectors available for this function....
00:40:48 <c_wraith> Oh.  It does have test vectors
00:50:28 <MatrixFrog> @src sort
00:50:29 <lambdabot> sort = sortBy compare
00:50:33 <MatrixFrog> @src sortBy
00:50:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
00:50:42 <MatrixFrog> aha! a foldr... i should have known
00:50:57 <MatrixFrog> @src insertBy
00:50:57 <lambdabot> insertBy _   x [] = [x]
00:50:57 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
00:50:57 <lambdabot>                                  GT -> y : insertBy cmp x ys'
00:50:57 <lambdabot>                                  _  -> x : ys
00:51:25 * MatrixFrog 's IRC client doesn't use a monospace font. it is ad
00:51:26 <MatrixFrog> sad
00:51:48 <luqui> fortunately that code comples no matter how far you indent the latter two lines :-)
00:52:00 <MatrixFrog> oh of course, it's just less pretty :-(
00:52:44 <mjrosenb> they need to be indented the same amount, right?
00:52:58 <mjrosenb> also, is there any way of getting :src to work for compiled modules?
00:53:10 <mjrosenb> assuming that haskell source exists for the given value
00:55:12 <MatrixFrog> reading about isInfixOf and such in Learn You a Haskell, and it's making me curious
00:55:21 <MatrixFrog> does Haskell do regular expressions at all?
00:56:01 <luqui> MatrixFrog, yeah there are libraries
00:57:11 <blueonyx> can there be a function that gets some input and returns a data constructor? like Bool -> MaybeDataContructor?
00:57:45 <luqui> MatrixFrog, http://hackage.haskell.org/packages/archive/regex-posix/0.93.1/doc/html/Text-Regex-Posix.html    and a gazillion others
00:57:56 <mjrosenb> blueonyx: data constructors are just functions
00:58:09 <blueonyx> but there types vary
00:58:11 <mjrosenb> blueonyx: at least when they are being used as values
00:58:16 <blueonyx> :t Just
00:58:17 <lambdabot> forall a. a -> Maybe a
00:58:18 <blueonyx> :t Nothing
00:58:20 <lambdabot> forall a. Maybe a
00:58:31 <mjrosenb> :t id
00:58:32 <lambdabot> forall a. a -> a
00:59:10 <luqui> blueonyx, what would the implementation of a function with that type look like?
00:59:21 <luqui> i'm trying to get a feel for what you are asking
01:02:53 <copumpkin> @djinn Bool -> a -> Maybe a
01:02:53 <lambdabot> f a b =
01:02:53 <lambdabot>     case a of
01:02:53 <lambdabot>     False -> Nothing
01:02:53 <lambdabot>     True -> Just b
01:03:07 * copumpkin hugs djinn
01:04:36 <c_wraith> @djinn (a -> Bool) -> Maybe a -> Maybe a
01:04:36 <lambdabot> f a b =
01:04:37 <lambdabot>     case b of
01:04:37 <lambdabot>     Nothing -> Nothing
01:04:37 <lambdabot>     Just c -> case a c of
01:04:37 <lambdabot>               False -> Nothing
01:04:38 <lambdabot>               True -> Just c
01:04:53 <copumpkin> isn't it great?
01:05:14 <luqui> @djinn (Either a b, Either c d) -> Either (Either (a,c) (b,d)) (Either (a,d) (b,c))
01:05:14 <lambdabot> f (a, b) =
01:05:15 <lambdabot>     case a of
01:05:15 <lambdabot>     Left c -> case b of
01:05:15 <lambdabot>               Left d -> Left (Left (c, d))
01:05:15 <lambdabot>               Right e -> Right (Left (c, e))
01:05:16 <lambdabot>     Right f -> case b of
01:05:17 <mjrosenb> @djinn ((a->b)->a) -> (a->b) -> b
01:05:18 <lambdabot>                Left g -> Right (Right (f, g))
01:05:20 <lambdabot>                Right h -> Left (Right (f, h))
01:05:22 <lambdabot> f a b = b (a b)
01:05:46 <c_wraith> I'm just amazed it picks what I consider to be the most sane alternative, at least as often as it does, when many implementations are possible
01:06:36 <copumpkin> it tries to use all the parameters
01:06:46 <luqui> @djinn ((a -> Bool) -> a) -> (a -> Bool) -> Maybe a
01:06:47 <lambdabot> f a b =
01:06:47 <lambdabot>     case b (a (\ _ -> False)) of
01:06:47 <lambdabot>     False -> Just (a (\ _ -> False))
01:06:47 <lambdabot>     True -> Nothing
01:07:14 <mjrosenb> @djinn ((a->b)->a)->a
01:07:14 <lambdabot> -- f cannot be realized.
01:07:28 <mjrosenb> lambdabot: silly lambdabot, you just need call/cc
01:07:28 <blueonyx> wow
01:07:49 <c_wraith> ok, luqui's example didn't pick the implementation I would have. :)
01:08:00 <copumpkin> @djinn ((a->b)->b)->b -> a -> b
01:08:01 <lambdabot> f a b _ = a (\ _ -> b)
01:08:18 <copumpkin> @djinn (((a->b)->b)->b) -> a -> b
01:08:18 <lambdabot> f a b = a (\ c -> c b)
01:08:39 <luqui> @djinn ((((a -> Bool) -> a) -> Bool) -> (a -> Bool) -> a) -> (a -> Bool) -> a
01:08:39 <lambdabot> f a b =
01:08:39 <lambdabot>     a (\ _ -> False) (\ _ -> b (a (\ _ -> False) (\ _ -> False)))
01:09:00 <luqui> too bad, djinn is not a mind reader
01:09:03 <blueonyx> okay maybe was a bad example
01:09:24 <blueonyx> i need (Bool -> (magic) -> Either a b)
01:09:50 <luqui> whenever you can't write the type of a function down, it's very unlikely you will be able to implement it
01:10:02 <blueonyx> or i need to lern more
01:10:08 <blueonyx> *learn
01:10:22 <c_wraith> magic clearly needs to have an a and a b in it.  (a,b) would be the simplest thing you could insert there
01:10:29 <luqui> can you describe what you want your Bool -> (magic) -> Either a b  function to do?
01:10:39 <c_wraith> well.  "needs" is too strong.  But that's what it's evocative of.
01:10:50 <copumpkin> @djinn Bool -> (a, b) -> Either a b
01:10:50 <lambdabot> f a =
01:10:50 <lambdabot>     case a of
01:10:50 <lambdabot>     False -> \ (b, _) -> Left b
01:10:50 <lambdabot>     True -> \ (_, c) -> Right c
01:11:10 <luqui> @djinn Bool -> (magic) -> Either a b
01:11:11 <lambdabot> -- f cannot be realized.
01:11:17 <Itkovian> dons: Any options that are not exposed on the command line?
01:11:31 <copumpkin> @djinn Bool -> a -> Either a a
01:11:31 <lambdabot> f a b =
01:11:31 <lambdabot>     case a of
01:11:32 <lambdabot>     False -> Left b
01:11:32 <lambdabot>     True -> Right b
01:11:47 <copumpkin> @djinn Either a a -> (Bool, a)
01:11:47 <lambdabot> f a =
01:11:47 <lambdabot>     case a of
01:11:47 <lambdabot>     Left b -> (False, b)
01:11:47 <lambdabot>     Right c -> (False, c)
01:11:50 <copumpkin> damn
01:11:53 <copumpkin> it failed
01:11:56 <c_wraith> @djinn Bool -> a -> Either a b
01:11:56 <lambdabot> f _ a = Left a
01:11:57 <luqui> @djinn (forall a. a) -> a
01:11:57 <lambdabot> -- f cannot be realized.
01:12:10 <copumpkin> aw
01:12:15 <c_wraith> @djinn Bool -> b -> Either a b
01:12:15 <lambdabot> f _ a = Right a
01:12:18 <xerox> @djinn Bool
01:12:18 <lambdabot> f = False
01:12:27 <galdor> copumpkin: last time I checked, you could use private messages...
01:12:40 <luqui> someone's grumpy
01:12:55 <luqui> no love for those idly playing with lambdabot today?
01:13:08 <blueonyx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23163#a23163
01:13:08 <copumpkin> I think seeing that is actually educational :P
01:13:14 <copumpkin> I know what it can do
01:13:58 <copumpkin> needs moar types but I think it's possible
01:14:30 <copumpkin> can you give us the types of bits and pieces?
01:14:44 <blueonyx> me?
01:14:57 <copumpkin> yep
01:15:14 <copumpkin> anyway, all you need is
01:15:36 <luqui> blueonyx, magic FDMap = (FDMapF, "map_fun"); magic FDReduce = (FDReduceF, "reduce_fun"); ...
01:16:02 <copumpkin> yeah
01:16:07 <luqui> though your use of strings to identify functions frightens me, admittedly without knowing the context.
01:16:42 <luqui> haskell doesn't seem very powerful when you program it like perl...
01:16:42 <blueonyx> i get them from stdin
01:17:03 <luqui> oh right you were asking about hint earlier
01:17:33 <blueonyx> FD* have parameters
01:17:45 <blueonyx> like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23163#a23164
01:18:07 <luqui> oh the types are not uniform
01:18:12 <luqui> okay then you can't do this
01:18:26 <luqui> in some sense each of those "interpret"s is a different function, because it returns a different type
01:18:29 <luqui> so you can't abstract over it
01:18:44 <blueonyx> okay
01:18:58 <blueonyx> thanks anyhow
01:20:23 <luqui> sure.  it is a little bit subtle knowing what kinds of code you can and can't abstract over.
01:21:38 * copumpkin should go to sleep but doesn't want to
01:21:49 <MatrixFrog> yup
01:23:31 * integral notes that you can do wonders with Typeable, existential types, and Data.Dynamic
01:23:42 <copumpkin> nooooo
01:23:59 <copumpkin> luqui even wrote a blog post recently about those kinds of evil
01:24:04 * Taejo notes that you can code Python in Haskell if you want
01:24:34 <MatrixFrog> do you mean write python code that is very haskell-like, or the reverse?
01:25:05 <copumpkin> you can write BASIC in haskell if you want, http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html
01:25:19 <Taejo> MatrixFrog: if your using Typeable and Dynamic, that's Python-like Haskell code
01:36:56 <mreh> all this talk of "boxed" and "unboxed" in haskell arrays is to do with the representation, right?
01:37:09 <mreh> "unboxed" means the representation is the data
01:39:06 <Botje> unboxed stuff is strict, too
01:39:49 <mreh> yeah, by definition I suppose
01:40:04 <mreh> no pointers
01:42:02 <blueonyx> @type bracket
01:42:03 <lambdabot> Not in scope: `bracket'
01:43:30 <mreh> that'll teach you to spam
01:45:39 <fasta> Can anyone tell me why I get a canvas of height one in http://paste.debian.net/62071/? If I don't have the layout boxes, it works fine.
01:46:55 <mreh> fasta: what library is that you are using?
01:47:03 <fasta> mreh, gtk2hs
01:47:41 <mreh> I could help if it were HGL :D
01:49:26 <pastorn> fasta: iz dat sum wxhaskell?
01:49:38 <mreh> yah boi!
01:50:06 <fasta> pastorn, no
01:52:55 <mreh> @quote 1337
01:52:55 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
01:52:59 <mreh> @quote l33t
01:52:59 <lambdabot> liyang says: My coffee machine isn't l33t enough. I'm planning to make it l33t.
01:53:05 <mreh> @quote l33t
01:53:05 <lambdabot> liyang says: My coffee machine isn't l33t enough. I'm planning to make it l33t.
01:53:27 <mreh> Who remembers 1337_h4x0r?
01:53:47 <blueonyx> who hacked 127.0.0.1?
01:54:36 <mreh> haha
01:56:23 * blueonyx wishes he had stumbled upon hint months before
02:00:36 <McManiaC> has anyone here been working events? what package can you recommend? control-event from hackage?
02:02:09 <fasta> Never mind.
02:02:29 <fasta> McManiaC, ?
02:02:41 <McManiaC> hm?
02:03:16 <fasta> McManiaC, how do you work events?
02:03:57 <McManiaC> I dont know
02:04:01 <fasta> McManiaC, or in other words: I cannot parse your question.
02:04:03 <McManiaC> I never worked with events in haskell
02:04:08 <McManiaC> perl has AnyEvents
02:04:36 <McManiaC> I'm looking for the haskell version of that
02:04:36 <McManiaC> :D
02:06:22 <blueonyx> how can i export everything from my module A and reexport some module B?
02:06:46 <fasta> blueonyx, (module A, module B)
02:07:04 <fasta> blueonyx, it is not something you see a lot, but it is valid Haskell.
02:07:40 <blueonyx> ah thanks
02:11:18 <mercury^> Is there a music/sound combinator library?
02:12:32 <blueonyx> regarding hint, how do i get all packages in scope that import Data.Graph.Inductive works from interpreted code?
02:12:32 <fasta> mercury^, Haskore?
02:12:53 * MatrixFrog is trying to solve a project euler problem, instead of sleeping
02:13:07 <fasta> blueonyx, what makes you think Hint implements Haskell?
02:13:50 <nonowarn> McManiac: have you looked at http://github.com/tibbe/event ?
02:14:02 <blueonyx> i cant parse your question :>
02:14:12 <blueonyx> @fasta
02:14:12 <lambdabot> Maybe you meant: fact paste
02:14:44 <fasta> blueonyx, Hint implements the Helium language.
02:14:52 <fasta> blueonyx, Helium /= Haskell.
02:14:59 <blueonyx> i think it uses ghc, and ghc knows my packages, so it could use em
02:15:48 <fasta> blueonyx, well, it certainly wasn't a supported operation when I used it.
02:16:02 <fasta> blueonyx, that was a long time ago, however.
02:16:34 <blueonyx> i could enable the PackageImports extension
02:16:47 <fasta> blueonyx, what are you talking about?
02:17:01 <blueonyx> hint aka Language.Haskell.Interpreter :D
02:17:17 <fasta> blueonyx, that explains a lot.
02:17:49 <fasta> blueonyx, yes, package imports are fine.
02:18:43 <Zeiris> Are there any production-ready, push-based FRP libraries out there?
02:28:02 <blueonyx> Zeiris: you know grapefruit?
02:34:15 * hackagebot hopenssl 1.4 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.4 (PeterSimons)
02:35:01 <blueonyx> mh i enabled PackageImports, import "MechGen" MechGen.Species, but get Failed to load interface for `MechGen.Species': it is not a module in the current program, or in any known package, where MechGen is my own package, which exposes this module and ghci can load it
02:42:56 <Alpounet> http://haskell.org/haskellwiki/Free_structure nice
02:43:13 <Zeiris> blueonyx, isn't grapefruit old and abandoned? Last I tried to play with this stuff, most of it seemed incomplete/buggy/abandoned, but I'm curious if there's been any new work done.
02:46:11 <blueonyx> Zeiris: maybe ping jeltsch
02:50:55 <blueonyx> ah PackageImport doesnt help, if the modules are not globally installed :)
02:55:50 <blueonyx> how can i install a package globally, when i did not give --user to cabal configure?
02:56:50 <Alpounet> --global ?
02:57:11 <ablmf> http://pastebin.com/D9DbCzr1
02:57:13 <blueonyx> ya
02:57:35 <blueonyx> but its default, but seems to fall back to --user, since not all requirements are met
02:57:38 <ablmf> What's wrong with that code? Ghc complains: No instance for (RealFrac Int)
02:57:39 <ablmf>   arising from a use of `floor'
02:57:48 * MatrixFrog feels like he's SO CLOSE to solving this project euler problem http://projecteuler.net/index.php?section=problems&id=71
03:00:46 <mreh> I'm trying to mutate some GASTs, I can't see to write a getter, let alone a setter
03:00:47 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23172#a23173
03:00:52 <mreh> GADTs*
03:03:50 <theorbtwo> You have a definition for getExpr 1 e, how is 1 an Expr a?
03:04:03 <ToRA> mreh: do you understand what the type of getExpr actually says?
03:04:32 <ToRA> getExpr :: Int -> Expr a -> Expr b  says that given an Expr a it can produce any type of Expr I want
03:05:12 <theorbtwo> Oh.  Sorry.  I read Expr a -> Expr b -> Int.
03:05:22 <Lemmih> mreh: Did you mean, getExpr :: Int -> Expr a -> Expr a?
03:06:48 <theorbtwo> Ah.
03:07:15 <theorbtwo> No, I see what he's doing.
03:07:26 <theorbtwo> ...but the first few cases aren't what you want.
03:07:35 <theorbtwo> Lemmih: Correct me if I'm wrong, please.
03:07:41 <theorbtwo> Only one equation will match.
03:07:57 <theorbtwo> The first one is universal -- it will match everything.
03:08:04 <theorbtwo> ...so you will never get any of the other cases.
03:08:23 <theorbtwo> Also, why is the first subexpression of any expression the whole expression?
03:10:12 <ToRA> theorbtwo: the first case won't match everything, assuming the implementation of nodes is sane - the guards see to that
03:10:54 <ToRA> theorbtwo: I assume the numbering goes top-to-bottom-left-to-right
03:11:02 <theorbtwo> ToRA: Hm.  I didn't realize you could use multiple guards like that.
03:12:21 <FunctorSalad> does anyone know what's the story behind /var/lib/ghc6.12.1 on debian? apparently, for example, `network' installed through apt goes into `network.conf', but through cabal the version hash is appended
03:12:41 <FunctorSalad> which leads to failure if you install something through apt first, and then through cabal
03:14:33 <Lemmih> mreh: 'getExpr' is impossible to type-check. Re-think your approach.
03:14:55 <FunctorSalad> (namely, network-2.2.1.7-9ad3f24baf8b5243d644a0b71193eaeb.conf)
03:15:15 <ToRA> ah, the If case would make sure of that
03:17:08 <ToRA> data ExistsE where Exists :: Expr a -> ExistsE ; getExpr :: Int -> Expr a -> ExistsE might make more sense
03:17:28 <ToRA> (or -> Maybe ExistsE if you wanted to cover the index-out-of-bounds case purely nicely)
03:18:22 <McManiaC> LANGUAGE CPP is not exactly the same as writing a hsc2hs file, is it?
03:19:34 <c_wraith> McManiaC: LANGUAGE CPP is mostly for conditional compilation of pure haskell code.
03:19:42 <McManiaC> k
03:19:58 <McManiaC> thought so
03:20:12 <mreh> cheers, guy, I just went to get some lunch
03:20:14 <a_ludi> Hello, I've got a question on types. Assuming I've got a general Type BinaryTree a implementing some basic function for such trees. Now, I want to extend this type to become a binary search tree (this stores values in an ordered way). I thought it would be fine to do it like:
03:20:14 <a_ludi> newtype (Eq a, Ord a) => BinarySearchTree a = BinaryTree a
03:20:14 <a_ludi> but this generates some errors. E.g. you're defining
03:20:14 <a_ludi> bSTreeEmpty :: (Eq a, Ord a) => BinarySearchTree a -> Bool
03:20:35 * hackagebot redis 0.2 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.2 (AlexanderBogdanov)
03:20:54 <a_ludi> any ideas?
03:20:54 <c_wraith> It's generally a bad idea to put type constraints on a newtype or data declaration
03:21:11 <c_wraith> Put the type constraints on the functions that need them, not on the data the functions use
03:21:23 <a_ludi> but these have to be set, because you can only insert sortable values into an binary tree
03:21:33 <a_ludi> *binary search tree
03:21:40 <c_wraith> then put the Ord constraint on the insert function.
03:22:03 <c_wraith> Also, Ord requires Eq, so having both is redundant
03:22:58 <a_ludi> ok, i'll try it. this redundancy is just cosmetic ... i will leave it out
03:24:32 <a_ludi> that didn't help ... i get the same errors as before
03:24:43 <a_ludi> BinarySearchTreeNew.hs:27:15:
03:24:43 <a_ludi> Couldn't match expected type `BinarySearchTree a'
03:24:43 <a_ludi> against inferred type `BinaryTree.BinaryTree a1'
03:24:43 <a_ludi> In the expression: bTreeEmpty
03:24:43 <a_ludi> In the definition of `bSTreeEmpty': bSTreeEmpty = bTreeEmpty
03:25:02 <theorbtwo> a_ludi: Did you partly rename it?
03:25:56 <a_ludi> theorbtwo: what do you mean by "partly renaming"
03:26:25 <ablmf> how to make a Fractional to RealFrac?
03:26:42 <ablmf> floor only accepts RealFrac, so I need to convert
03:27:23 <xpika> is there a monad which encapsulates an IO Ref?
03:27:38 <zygoloid> mreh: you can get that sort of thing to work by CPS-ifying it. "getExpr :: Int -> Expr a -> (forall b. Expr b -> r) -> r" stands a chance of working.
03:27:41 <c_wraith> xpika: There's ST.  That *might* be what you mean
03:27:52 <dobblego> xpika, there is ST, but monads are type constructors
03:28:06 <xpika> c_wraith: does it work with callbacks?
03:28:11 <theorbtwo> a_ludi: Why do you have both a BinaryTree and a BinarySearchTree?  Did you rename BinaryTree to BinarySearchTree without changing all occourances?
03:28:45 <c_wraith> xpika: I really don't know what you're asking.
03:29:30 <c_wraith> a_ludi: It sounds like you're forgetting to either wrap or unwrap the newtype somewhere as the type checker is expecting
03:29:31 <int-e> ablmf: you can't. for example, the Fractional instance could be a complex number
03:30:22 <a_ludi> theorbtwo: yes i've got both because i want to expand the simpler type BinaryTree to a BinarySearchTree - like inheriting in oo languages
03:30:25 <int-e> hmm. the value could be a complex number; the instance would be the type of complex numbers.
03:31:02 <ablmf> int-e : I have a function like this : toB m a = ((m ^ 2) - 2 * m * a) / (2 * m -  2 * a)
03:31:30 <ablmf> When I try to apply floor to toB's reulst, I got a problem because floor expects RealFrac
03:31:48 <ablmf> How to avoid that if I can not convert Fractioanl to RealFrac?
03:33:00 <int-e> ablmf: by demanding a RealFrac instance to begin with - every RealFrac instance is also a Fractional instance
03:33:44 <zygoloid> mreh: replaceExpr looks harder to 'fix'. you could try "replaceExpr :: Int -> Expr a -> (forall b. Expr b -> (Expr b, r)) -> (Expr a, r)" but you can't really return the bit you replaced
03:35:08 <a_ludi> i think i've got the twist ... now i'm using a new constructor like:
03:35:09 <a_ludi> BinarySearchTree a = BST (BinaryTree a)
03:36:05 <xpika> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23174 ive written a tiny reddit clone using fast cgi and i want to abstract the IO Ref variable from the cgiMain function
03:38:13 <mreh> zygoloid: that doesn't matter so much, it was just an optimisation when it wasn't polymorphic
03:38:25 <mreh> non polymorphic = monomorphic?
03:40:28 <MatrixFrog> bam!
03:40:31 * MatrixFrog solved it!
03:40:45 <mreh> \0/
03:42:17 <MatrixFrog> aw boo, everyone else did it a lame non-code way
03:43:40 <dancor> are unsolvable algorithms problems "incomputable" or "uncomputable" ..or both
03:44:05 <MatrixFrog> i happen to enjoy the word "intractable" but i don't think it's quite what you're asking about
03:44:23 <dancor> right intractable is easier but still practically not going to happen
03:44:44 * mreh . o 0 (unsolvable problems? my relationships?)
03:46:13 <mreh> if you can write an algorithm, I don't think you could define it as unsolvable
03:46:27 <mreh> it may be intractable as MatrixFrog says
03:46:58 <mreh> a non-deterministic polynomial time algorithm, like the travelling salesperson
03:47:09 <mreh> would fall into that category
03:47:16 <MatrixFrog> would it be a Bad Thing to paste an .lhs file to hpaste?
03:47:26 <mreh> no
03:47:30 <MatrixFrog> k cool
03:47:40 <mreh> it is the code of satan though
03:48:40 * MatrixFrog is sorry
03:50:39 <MatrixFrog> ok i converted it to normal .hs style
03:50:40 <MatrixFrog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23175#a23175
03:51:08 <MatrixFrog> that's my solution for project euler #71, and it does give the right answer so if you're working on project euler on your own, no cheating!
03:51:11 <dancor> .lhs is fine too
03:51:27 <MatrixFrog> just wondering if anyone sees anything drastically wrong or un-haskelly or whatever
03:52:03 <MatrixFrog> (this way it shows the code a little nicer with colors and such)
03:52:25 <MatrixFrog> oh i just noticed i imported a couple things that i didn't end up using :-/
03:54:06 <mreh> lol!
03:54:14 <MatrixFrog> anyway yeah. it's not very long so if anyone would like to take a quick look and tell me if i did something inadvisable that would be very cool!
03:54:16 <mreh> you can do it .lhs if you like :)
03:54:25 <MatrixFrog> ok next time i will do that
03:54:36 <MatrixFrog> someone mentioned Satan i think and i got scared
03:55:33 <harlekin> @pl (\f (a, b) -> (f a, f b))
03:55:33 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
03:55:46 <harlekin> :t (\f (a, b) -> (f a, f b))
03:55:47 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
03:56:02 <harlekin> :t \f (a, b) -> join (***) f $ (a, b)
03:56:03 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
03:57:53 <Axman6> @pl \f -> first f . second f
03:57:53 <lambdabot> liftM2 (.) first second
03:58:09 <Axman6> :t liftM2 (.) first second
03:58:10 <lambdabot> forall c d. (d -> c) -> (d, d) -> (c, c)
03:58:26 <dancor> that's cool
03:58:34 <Axman6> yeah it is a bit
03:59:57 <fasta> MatrixFrog, you use fractions, which already exist as a type.
04:00:02 <dancor> liftM2 (.) is cool
04:00:12 <fasta> MatrixFrog, most of the operations you define are also already defined.
04:00:24 <MatrixFrog> fasta: aha! i figured they might exist, but i thought it might be fun to implement them myself anyway
04:00:34 <fasta> MatrixFrog, things like proper fractions, and so on.
04:00:36 <McManiaC> how can I tell hsc2hs which libs it should use in my .cabal file?
04:01:00 <MatrixFrog> fasta: of course in the future i will use the built-in one
04:01:13 <fasta> MatrixFrog, drop 999900 [1..1000000]
04:01:19 <fasta> MatrixFrog, and that is a joke.
04:01:42 <fasta> MatrixFrog, the compiler might optimize it, but it is a really silly expression.
04:02:15 <MatrixFrog> fasta: [999900..1000000] would be better?
04:02:24 <fasta> MatrixFrog, that would be better, yes.
04:02:28 <MatrixFrog> :-) thanks!
04:02:48 <fasta> MatrixFrog, anyway, if you want to learn Haskell you should not do Project Euleer.
04:03:07 <fasta> MatrixFrog, Project Euler is for learning about nice mathematical programming tricks.
04:03:15 <MatrixFrog> fasta: well i also just like PE. but that's a good point
04:03:18 <fasta> MatrixFrog, learning Haskell is a different skil.
04:03:21 <fasta> skill*
04:06:50 <MatrixFrog> ok so i'm still reading Learn You a Haskell
04:07:00 <MatrixFrog> "First we write the name of the field, for instance, firstName and then we write a double colon :: (also called Paamayim Nekudotayim, haha) and then we specify the type."
04:07:10 <MatrixFrog> is he just messing around or is that some inside joke
04:07:41 <luite> MatrixFrog: it's hebrew, and the name the php parser gives to that token
04:07:43 <eevar2> speaking of PE. does haskell have a function for processing a list as multiple (overlapping) segments?
04:08:08 <MatrixFrog> mmmmm php humor. lovely
04:10:52 <mreh> eevar2: tails?
04:11:00 <mreh> > tails [1..10]
04:11:01 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
04:11:24 <mreh> that works on infinite lists too
04:11:34 <mreh> so you can slide a window down a list for example
04:11:45 <eevar2> for [1..5], i'd want e.g. [1..3], [2..4] and [3..5]
04:12:06 <mreh> > map (take 3) . tails $ [1..10]
04:12:07 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
04:12:55 <eevar2> okies, thanks. i know clojure has a library fuction which does exactly this, so assumed the haskell libs would have it too
04:13:18 <mreh> haskell uses combinators to achieve most of these effects
04:13:41 <mreh> I should think there is an even more idiomatic way
04:13:44 <fasta> eevar2, I wrote a zip_with_predecessor_and_successor to do something similar.
04:14:30 <fasta> (my util library is larger than xmonad)
04:15:15 <mreh> mine is bigger
04:15:16 <fasta> (that's just counting the "trivial utilities", things like correcting mistakes like runStateT (idiotic argument order))
04:16:19 <fasta> I was able to move some stuff out of it, because some of it is now available on Hackage.
04:19:24 <stevenmarky> what do you use haskell for fasta
04:19:28 <McManiaC> how can I add arguments to a Program in my Distribution.Simple Setup.hs?
04:20:12 <eevar2> just found the clojure function I had in mind: partition(n step coll): Returns a lazy sequence of lists of n items each, at offsets step apart. If step is not supplied, defaults to n, i.e. the partitions do not overlap.
04:20:48 <mreh> gah, that sounds like MATLAB documentation
04:21:21 <mreh> "that's not a proper function", is my response to that :)
04:21:21 <MatrixFrog> good night
04:21:23 <MatrixFrog> thanks!
04:21:28 <mreh> goodnight
04:21:35 <mreh> good afternoon
04:22:06 <fasta> stevenmarky, I write part of the Gamr7 (gamr7.com) engine in it.
04:22:24 <Alpounet> fasta, what's the name of the hackage package ?
04:22:51 <fasta> Alpounet, I was referring to other people already having uploaded a package which duplicated some stuff I already had.
04:23:23 <mreh> unnecessary umlaut in "urban"
04:23:26 <Alpounet> oh, ok
04:23:37 <mreh> fasta: are you German?
04:23:40 <fasta> stevenmarky, in the past I have written various complicated graph algorithms and all the required visualization and some other applications. I even use it to start Emacs.
04:23:42 <mreh> I suspect you are
04:23:52 <fasta> mreh, why would I be German?
04:24:23 <mreh> I have an inuition
04:24:33 <fasta> mreh, anyway, your intuition is wrong.
04:24:54 * Snakes does this to his exs http://tinyurl.com/yjd9bj5/index.php?id=eb67fa1c7bdd33999229e037c3bd65a1
04:25:03 <mreh> Czech?
04:25:40 <fasta> stevenmarky, you can write everything in Haskell, but is is just not a very good idea to do so. E.g. real-time systems in Haskell are a bad idea, unless you use Haskell like Atom does.
04:25:55 <fasta> mreh, Dutch.
04:26:13 <mreh> I was so close the first time
04:26:21 <benmachine> how close?
04:26:25 <benmachine> you got "western europe"
04:26:39 <benmachine> not a very small target :P
04:27:16 <mreh> The netherlands borders Germany
04:27:26 <fasta> mreh, so does France.
04:27:37 <profmakx> or poland
04:28:02 <mreh> The Dutch are quite similar to the Germans though, culturally there is much similarity
04:28:07 <fasta> mreh, are you from the UK?
04:28:10 <Drcx> Hey, quick question, I've got a [[Int]], what would be the best way to replace one number, in one list within that list, for example, if I had [[1,2],[1,2],[1,2]]
04:28:35 <Drcx> I'd like to be able to do something like, replace 2 1 5,   and get [[1,2],[5,2],[1,2]]
04:28:38 <mreh> fasta if you deduced that from my /whois, you'd be right
04:28:51 <fasta> mreh, no, it was a lucky guess. Honest ;)
04:28:53 <benmachine> if he deduced that by some other method, is it wrong
04:29:05 <tomh-> france borders the netherlands? :/
04:29:16 <benmachine> no germany
04:29:16 <mreh> fasta: what are you doing bouncing your connection in from the US then?
04:29:27 <mreh> Belgium borders Holland
04:29:39 <tomh-> yes
04:29:45 <tomh-> but fasta said, so does france ;p
04:29:45 <benmachine> mreh: I have a server in the US just because lots of people with computers live there
04:29:51 <benmachine> it's really nothing unusual
04:30:03 <fasta> tomh-, France borders Germany.
04:30:10 <mreh> which confusingly is another name for the Netherlands
04:30:23 <tomh-> ah ok
04:30:26 <benmachine> this is a silly conversation I think
04:30:36 <benmachine> it is certainly off-topic
04:30:51 * ski thought Holland was a part of the Netherlands ..
04:30:57 <Drcx> Any help? :o
04:31:11 <benmachine> Drcx: there isn't really a very succint way of writing that because it's not usually something that people want to do
04:31:22 <benmachine> lists aren't usually used like that
04:31:45 <benmachine> you might want arrays (possibly MArrays) or a Map
04:31:51 <cheater> hello, #haskell
04:31:53 <benmachine> depending on your use case
04:31:54 <benmachine> but
04:31:57 <benmachine> you can do it
04:31:59 <Drcx> I'll check out Arrays, as they'll probably suit my need better
04:32:11 <mreh> think of lists as control structures rather than data
04:32:25 <benmachine> you use some mixture of take, drop, insert, delete I think
04:32:25 <cheater> what do we lose, in theory, if functions in haskell weren't forced to be monotonic?
04:32:28 <blackh> hello, cheater
04:32:29 <cheater> in terms of definedness
04:32:33 <benmachine> cheater: monotonic?
04:32:56 <ski> cheater : computability ?
04:32:56 <cheater> i was told that the data structures in haskell have an ordering according to how well defined they are
04:33:08 <cheater> and the functions have to conserve that order
04:33:22 <benmachine> I don't think that's an imposed restriction
04:33:28 <cheater> i was told it is
04:33:29 <mreh> I find that German computer scientists boast the most about what they have achieved
04:33:36 <benmachine> it's just a consequence of what it means to be defined or otherwise
04:33:57 <benmachine> mreh: I find that british people are invariably terrible people
04:34:10 <benmachine> every. single. one.
04:34:16 <Alpounet> ok guys, this is for sure off-topic and useless
04:34:26 <mreh> The people of Northern Ireland, Wales and Scotland might take exception to that
04:34:28 <Alpounet> take it to PMs
04:34:36 <ski> it could be seen as a restriction that comes from that we want haskell functions to be computable ..
04:34:45 <dmwit> I find that Earthlings are horrible at everything.
04:34:51 <cheater> ski: why do we lose computability?
04:35:10 <benmachine> hmm I should probably mention that I'm british if I want to look less racist
04:35:32 <benmachine> but yes I really meant it as a subset of dmwit's statement and also a reducto ad absurdum of stereotyping
04:35:39 <mreh> or hostile
04:35:42 <ski> cheater : given `data S = S', consider the non-monotonic function defined by `not S = _|_; not _|_ = S' (pseudo-haskell) .. this is not computable
04:35:44 <mreh> calm down dear
04:35:48 <mreh> -blah
04:35:58 <benmachine> no I should be doing work anyway
04:36:10 <cheater> ski: why?
04:36:18 <benmachine> but I meant to sound more light-hearted than I did, so my apologies
04:37:03 <ski> cheater : because if `_|_' models a non-terminating computation, then you can't detect that it doesn't terminate (halting problem)
04:38:09 <cheater> ski: what if that _|_ was something else, rather than an ntc?
04:39:04 <cheater> what can bottom result from, other than an ntc?
04:39:10 <ski> then what i mentioned need not apply .. the point being that `_|_' is meant to model non-termination (also lumping in partiality) in this kind of semantics
04:41:11 <cheater> what if we had several kinds of bottom
04:41:41 <cheater> like one for non-termination, one for other stuff..
04:42:10 <cheater> hi Syzygy
04:54:30 <michie1> a silly newbie question: When I define a subclass as class (Show a) => Location a where method :: <my method type here> I can instantiate `method` later on, but not `show`
04:54:45 <michie1> tells me that 'show' is not a visible method of class 'Location'
04:55:05 <dmwit> Yes, you must define show as part of an instance declaration for the Show class.
04:55:14 <michie1> hmm
04:55:30 <michie1> but something like instance (Show, Location) Blah where ... isn't allowed.
04:55:42 <dmwit> instance Show Blah where ...
04:55:42 <michie1> and neither is having two instance sections, it seems.
04:55:45 <mreh> :t expr
04:55:46 <lambdabot> Expr -> Expr
04:55:46 <dmwit> instance Location Blah where ...
04:55:53 <mreh> :t exp
04:55:53 <michie1> hmm, one moment.
04:55:54 <lambdabot> forall a. (Floating a) => a -> a
04:56:03 <mreh> :t **
04:56:04 <lambdabot> parse error on input `**'
04:56:08 <mreh> :t (**)
04:56:09 <lambdabot> forall a. (Floating a) => a -> a -> a
04:56:15 <mreh> :t (^)
04:56:16 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
04:56:18 <michie1> dmwit: nm, seems to work.  Thanks a lot.
04:56:29 <mreh> @instances Integral
04:56:30 <lambdabot> Int, Integer
04:57:56 <michie1> dmwit: I think I had a deriving Eq in there as well, earlier.  May have caused the confusion
05:06:15 <FunctorSalad> shouldn't `withCString' take an encoding?
05:06:40 <FunctorSalad> I've noticed it when trying to pass utf8 to rawSystem
05:07:03 <blueonyx> why does a cabal package i configure with --global get installed to ~/.cabal and only registered for the current user? i even installed with sudo :/
05:07:42 <FunctorSalad> (rawSystem, in turn, uses withCString to do some system call)
05:08:21 <FunctorSalad> alternatively, rawSystem should just take [Word8]s
05:08:40 <voker57> blueonyx: try installing with --global
05:09:09 <blueonyx> oh thanks
05:27:35 <fasta> I have onExpose foo (\event -> something::IO Bool), but I want to refer to bar::StateT Int IO in the block of code with something. This seems to be impossible. quicksilver wrote something about exactly this situation I think.
05:28:37 <fasta> InterleavableIO, I found it.
05:28:40 <quicksilver> yes, you need to stuff the state into an IORef or MVar where the callback can find it
05:28:55 <quicksilver> you can make it reasonable automatic with a little work setting up the machinery
05:29:20 <quicksilver> (slightly harder if your callbacks can run in parallel with the main state thread, but that's a fairly unusual case hopefully)
05:29:23 <fasta> quicksilver, hmm, I had hoped for something "better".
05:31:12 <fasta> It is kind of unfortunate that all the functional drawing libraries are either undocumented, buggy, incomplete, trivial or all of the preceding.
05:32:14 <fasta> Functional metapost could have been great for what I wanted to do, but although I programmed some metapost, I don't find it obvious to use it.
05:33:57 <quicksilver> fasta: it is unfortunate that there is so little well documented, bug-free, complete, substantial libraries.
05:34:03 <quicksilver> (in any domain, in any language)
05:34:04 <quicksilver> ;)
05:34:13 <quicksilver> s/is so little/are so few/;
05:35:03 <dmwit> fasta: Have you seen http://code.haskell.org/diagrams/ ?
05:35:14 <dmwit> I hear it is based partly on metapost.
05:36:54 <fasta> dmwit, hmm, not that webpage.
05:37:10 <fasta> dmwit, maybe I saw some previous version or I only heard of it.
05:39:02 <fasta> dmwit, hmm, I suppose one could combine the SVG output with GTK2HS to get something useful.
05:39:40 <dmwit> It's probably not hard to render directly to anything Cairo can render to, either.
05:39:48 <dmwit> (With a small patch to the library.)
05:40:04 <quicksilver> it uses cairo anyway so I would imagine it can integrate well with gtk2hs
05:40:10 <quicksilver> or it can easily be arranged to
05:40:14 <dmwit> right
05:40:21 <quicksilver> byorgey is quite nudgeable in this channel, too.
05:40:43 <fasta> Right, I believe so too, but all the interesting things of metapost are not yet in diagrams judging from the "what will be cool in the future part".
05:41:26 * dmwit nods
05:41:29 <theorbtwo> fasta: Patches welcome?
05:42:06 <dmwit> fasta: Well, spring break is next week... you could always cross your fingers. =)
05:42:33 <fasta> But otherwise, I cannot think of anything bad to say. I might even use it next time.
05:50:07 <dancor> dmwit: i'm trying to store parsed sgf's to disk for a go database program, but Data.SGF uses Setup which doesn't seem amenable to a Binary instance
05:51:18 <dancor> dmwit: what are your thoughts about an sgf type where like unparse . parse = id
05:51:33 <dancor> maybe modulo whitespace
05:52:15 <Vitka> Is there are function to read \0-terminated string as ByteString, stopping at \0? byteBreak?
05:52:36 <benmachine> read from where?
05:52:55 <Vitka> File on disk.
05:53:06 <Vitka> @hoogle byteBreak
05:53:06 <lambdabot> No results found
05:53:14 <opqdonut> dancor: parse . unparse = id seems like a more sensible invariant
05:53:22 <Vitka> @breakByte
05:53:22 <lambdabot> Unknown command, try @list
05:53:27 <Vitka> oops
05:53:33 <Vitka> @hoogle breakByte
05:53:33 <lambdabot> Data.ByteString breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
05:53:36 <benmachine> @type BS.break
05:53:37 <lambdabot> (Word8 -> Bool) -> BSC.ByteString -> (BSC.ByteString, BSC.ByteString)
05:53:51 <benmachine> I guess that's pretty much the same thing
05:54:26 <Vitka> Seems so.
05:54:40 * benmachine isn't an bytestring expert
05:55:27 <dancor> opqdonut: ya but in general most parsers do throw away some info.  i'm curious because sgf lib has plans to support pretty printing but the internal type seems to have some things that aren't amenable to that currently
05:58:05 <FliPPeh_> > let pi = 3
05:58:06 <lambdabot>   not an expression: `let pi = 3'
05:58:11 <FliPPeh_> :o
05:58:19 <theorbtwo> > pi = 3
05:58:20 <lambdabot>   <no location info>: parse error on input `='
05:58:38 <theorbtwo> Hm.  Could have sworn that was right, because of the strange tricks that lambdabot plays.
05:58:39 <Vitka> > let pi = 3 in 5*pi
05:58:40 <lambdabot>   15
06:00:19 <FliPPeh_> :)
06:06:01 <Dementati> Is there a list of fixity declarations for the standard operators somewhere?
06:06:16 <aledge> hehe fixity
06:06:38 <Dementati> Hm?
06:06:46 <benmachine> Dementati: you can get individual numbers by using :info in ghco
06:06:49 <benmachine> er ghci
06:07:00 <benmachine> there is probably also a list somewhere but I don't know it
06:07:02 <FliPPeh_> Can't you grep over the Prelude module?
06:07:16 <benmachine> it probably imports stuff from everywhere
06:07:30 <benmachine> that is if you even found the source, which is not entirely trivial
06:07:30 <Dementati> benmachine: I see. Thanks. =)
06:07:53 <Dementati> benmachine: Yeah, this is all I need. Cheers.
06:08:21 <Vitka> Ahah. I was looking for getLazyByteStringNul afterall.
06:10:20 <benmachine> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Prelude.html I was totally right, if you are neither hugs nor haddock nothing gets defined at all
06:10:48 <benmachine> wait no if you are hugs
06:11:03 <benmachine> if you are ghc you get $!
06:14:10 <Dementati> If I want to set a fixity declaration on a value constructor for a type, do I have to qualify the name of the constructor in some way?
06:14:27 <McManiaC> how do I turn a Fractional into a Real?
06:14:36 <dschoepe> :t realToFrac
06:14:37 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:14:55 <dschoepe> :t truncate
06:14:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:16:15 <McManiaC> dschoepe: thx
06:16:23 <McManiaC> > truncate 0.05
06:16:24 <lambdabot>   0
06:16:27 <McManiaC> > truncate 0.9
06:16:28 <lambdabot>   0
06:16:32 <McManiaC> > truncate 10.2
06:16:32 <benmachine> McManiaC: a Real doesn't need to support non-integral values
06:16:33 <lambdabot>   10
06:16:38 <dschoepe> there's also round and ceiling and the like
06:16:46 <benmachine> but a Fractional does
06:16:56 <McManiaC> oh yeh
06:17:06 <benmachine> so you need to lose information
06:17:12 <benmachine> (potentially)
06:17:16 <McManiaC> I've needed "fromIntegral . round/truncate/whatever"
06:17:19 <McManiaC> :>
06:17:20 <benmachine> yeah
06:38:45 <Dementati> So is it even possible to do fixity declarations on value constructors?
06:43:15 <dancor> Dementati: A fixity declaration can be given for any infix operator or constructor (including those made from ordinary identifiers, such as `elem`).
06:43:21 <dancor> http://www.haskell.org/tutorial/functions.html
06:45:40 <Dementati> dancor: That's what I read. However, I get a parse error when I try to actually do it.
06:46:00 <Dementati> dancor: I'm wondering to myself if I need to qualify the name of the value constructor or something.
06:46:22 <dancor> Dementati: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8449#a8449
06:49:21 <KSkrzet> i'm trying to fetch GHC from darcs, but "darcs get --partial http://darcs.haskell.org/ghc" takes ages. is there a better way than to do this? (this command is from http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources)
06:50:36 <termos> when doing list comprehensions i'd like say a tuple (a,b) \in Z_n. is there some way of doing (a,b) <- [0..n]^2? Only solution I see is to take each component a <- [0..n], b <- [0..10]
06:50:47 <Dementati> dancor: http://pastebin.org/99973 <- This looks almost equivalent to me.
06:50:54 <Dementati> But it doesn't work.
06:54:18 <basvandijk> Hello, what's the most elegant way of calculating the time since the Unix epoch (Jan 1, 1970 00:00:00 UTC). I would also like to convert this time to a number of milliseconds expressed as an Integer.
06:56:29 <basvandijk> I can use 'utcTimeToPOSIXSeconds :: UTCTime  -> POSIXTime' where 'type POSIXTime = NominalDiffTime'. However, how can I convert a 'NominalDiffTime' to a number of milliseconds expressed as an 'Integer'?
06:56:54 <roconnor> @hoogle NominalDiffTime -> Integer
06:56:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:56:54 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
06:56:54 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
06:57:10 <roconnor> basvandijk: what does toInteger return?
06:57:40 <roconnor> @hoogle utcTimeToPOSIXSeconds
06:57:40 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
06:57:49 <basvandijk> roconnor: I wasn't aware that a NominalDiffTime had an instance for Integral... I will find out
06:57:57 * roconnor isn't aware either
06:58:25 <fasta> quicksilver, if callback would be called toIO (or anythingToIO) it would be much easier to use.
06:58:42 <Dementati> dancor: My problem is now resolved. Thanks for the help.
06:59:05 <basvandijk> roconnor: Unfortunately NominalDiffTime has no instance for Integral
06:59:06 <dancor> Dementati: cool.  ya that constructor wasn't infix
07:00:07 <roconnor> basvandijk: sorry, toRational
07:00:10 <basvandijk> (Ah but a NominalDiffTime has an instance for Real so I can convert it to a Rational)
07:00:12 <basvandijk> yes thanks
07:00:16 <idnar> termos: well, I guess you could do
07:00:21 <roconnor> what units does it return
07:00:25 <roconnor> I expect picoseconds
07:00:27 <roconnor> or seconds
07:00:33 <idnar> termos: (a,b) <- liftA2 [0..2] [0..2]
07:00:36 <basvandijk> yes picoseconds
07:00:40 <roconnor> really?
07:00:48 <idnar> termos: that's not much different though
07:00:55 <dancor> infixr 3 `And`
07:00:56 <roconnor> I would have guessed seconds with picosecond resolution
07:01:44 <basvandijk> roconnor: Oh you're right of course
07:02:25 <basvandijk> So '(1000 *) . toRational . utcTimeToPOSIXSecond' gives me the number of milliseconds between the Unix epoch and the given UTCTime
07:02:48 <termos> idnar: i guess what i want is a cartesian product of sets
07:03:48 <int-e> > liftA2 (,) [0..2] [False..]
07:03:49 <lambdabot>   <no location info>: parse error on input `]'
07:03:54 <int-e> > liftA2 (,) [0..2] [False ..]
07:03:55 <lambdabot>   [(0,False),(0,True),(1,False),(1,True),(2,False),(2,True)]
07:04:18 * FliPPeh_ hates them wisdom tooth
07:04:48 <int-e> dentists happily get rid of them. :/
07:04:57 <FliPPeh_> That's the problem
07:05:06 <FliPPeh_> I got rid all all 4 yesterday
07:05:25 <FliPPeh_> Not fun!
07:05:36 <FliPPeh_> > take 5 [True ..]
07:05:37 <lambdabot>   [True]
07:05:48 <FliPPeh_> > take 5 [False ..]
07:05:49 <lambdabot>   [False,True]
07:05:51 <FliPPeh_> :o
07:06:00 <FliPPeh_> > succ False
07:06:01 <lambdabot>   True
07:06:04 <FliPPeh_> ah okay
07:06:43 <fasta> FliPPeh_, does it still hurt?
07:08:36 <FliPPeh_> fasta: I can't really eat :)
07:08:47 <FliPPeh_> And my face is all fat
07:09:00 <FliPPeh_> But I was prepared for bigger pain
07:09:08 <fasta> FliPPeh_, I was told that I should stay two days in the hospital when I go and do it.
07:09:18 <FliPPeh_> hospital? No way
07:09:32 <FliPPeh_> I'm just staying home until it's better
07:09:57 <fasta> Flippeh: in France things appear to be different.
07:10:13 <fasta> Flippeh: in The Netherlands your way is also usual.
07:10:51 <FliPPeh_> Maybe you have difficult teeth?
07:13:06 <roconnor> I got to use tab completion more in ghci
07:13:25 <FliPPeh_> tab completion is a curse
07:13:32 <FliPPeh_> I'm trying to use it EVERYWHERE
07:13:55 <FliPPeh_> In situations where there's no completion at all, trying to complete ordinary words...
07:14:52 <fasta> FliPPeh_, hmm, yes, probably.
07:18:03 <zenzike> I'm reading some notes on category theory by Fokkinger, who states that one can find a non-associative operator for a fold, thus making associativity a sufficient, but not necessary condition for a well defined fold. I can't see how this is possible, does anybody have any suggestions?
07:20:23 <ski> zenzike : are you talking about folds on right- (or left-) associated lists ?
07:21:07 <roconnor> > foldr ($) 1 [(+2), (*3), (^4)]
07:21:08 <lambdabot>   5
07:21:18 <Dementati> Is there any standard function for splitting lists on sublists?
07:21:36 <zenzike> sky: actually, the example he gives leaves tis ambiguous, giving only: fold f [x0, .., xn] = x0 `f` ... `f` xn, and leaving associativity ambigous
07:21:49 <tromp_> > foldl1 (\x y->2x+y) [1,0,1]
07:21:50 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:21:50 <lambdabot>    arising from the literal `2' at <...
07:21:57 <tromp_> > foldl1 (\x y->2*x+y) [1,0,1]
07:21:58 <roconnor> Dementati: http://hackage.haskell.org/package/split
07:21:58 <lambdabot>   5
07:22:05 <ski> > foldr1 f [a,b,c,d]
07:22:06 <lambdabot>   f a (f b (f c d))
07:22:08 <tromp_> > foldr1 (\x y->2*x+y) [1,0,1]
07:22:09 <lambdabot>   3
07:22:10 <ski> > foldl1 f [a,b,c,d]
07:22:11 <lambdabot>   f (f (f a b) c) d
07:22:16 <zenzike> sky: unless you're asking what cons does, in which case cons :: A -> List A -> A
07:22:42 <tromp_> 2*x+y is not associative
07:22:44 <ski> zenzike : itym `A -> List A -> List A', in which case that is right-associated lists
07:23:05 <zenzike> itym?
07:23:14 <ski> "itym" meaning "i take you mean"
07:23:25 <ski> (or sometimes s/take/think/)
07:23:36 <zenzike> ski: oops, yup, that is what I mean. Typo there
07:24:16 <Dementati> roconnor: Thanks, that works. =)
07:24:29 <ski> so, `[x0, .., xn]' there really is `cons x0 (cons x1 (..(cons xn nil)..))'
07:24:31 <zenzike> ski: how does that make a difference here? is it to do with where we can put the empty list?
07:24:55 <theorbtwo> ski: "I take you mean" would have to be "I take it you mean", which would be itiym.
07:25:16 <zenzike> ski: sure, but I don't see how that affects the associativity property
07:25:52 <ski> theorbtwo : possible. i've learned it by osmosis, so my mind might be imagining some things
07:26:28 <ski> zenzike : well, if this only for non-empty lists, or can that `fold' be applied to an empty list (`nil' or `[]') as well ?
07:27:01 <tromp_> you need at least 3 elements to tell difference in associativity
07:27:29 <aavogt> does old haskell code not make use of mtl and other higher order functions because of performance reasons?
07:27:33 <zenzike> ski: It can be applied to empty lists too, I think.
07:27:42 <ski> giving what result ?
07:27:50 <zenzike> the neutral element of f
07:28:02 <zenzike> the question is here: www.cs.utwente.nl/~fokkinga/mmf92b.pdf top of p5
07:28:10 <aavogt> in particular this stuff here: http://hackage.haskell.org/packages/archive/haskell-src-exts/1.8.2/doc/html/src/Language-Haskell-Exts-Pretty.html
07:28:13 <ski> (which should also be given as an argument to `fold', i think)
07:28:15 <zenzike> I'm rather surprised by it
07:29:00 <ski> > foldr (\x y -> 10 * x + y) 0 [4,9,6]  -- tromp_'s example
07:29:01 <lambdabot>   190
07:29:07 <zenzike> ski: yup, I did play around with the unit, but the closest I came to working with a non-associative f was to have a non-neutral u as well
07:29:09 <ski> er
07:29:30 <ski> > foldr (\x y -> 10 * y + x) 0 [4,9,6]  -- tromp_'s example
07:29:31 <lambdabot>   694
07:29:33 <tromp_> my f only has left neutral element
07:30:38 <ski> zenzike : if we define `fold' by `fold (z,f) [] = z' and `fold (z,f) [x0,x1,...,xn] = f x0 (fold (z,f) [x1,...,xn])'
07:31:04 <ski> then that means that in `cons x0 (cons x1 (..(cons xn nil)..))', `cons' is replaced by `f' and `nil' by `z'
07:31:27 <ski> there is no need for `f' to be an associative operation, for this to be well-defined
07:31:33 <zenzike> ...
07:31:59 <ski> h,
07:32:00 <ski> hm
07:32:29 <zenzike> but for the fold to be well defined, wouldn't we expect (x `f` y) `f` z = x `f` (y `f` z) ?
07:32:46 <zenzike> (which is associativity, I think this is the source of my confusion!)
07:33:27 <roconnor> heck f might not even be an operation at all!
07:33:42 <quicksilver> fasta: I called it simply 'cb' - short and cryptic
07:33:43 <roconnor> f has type a -> b -> b
07:33:52 <quicksilver> fasta: with appropriate overloading you don't have to write it at all
07:33:58 <ski> not really, because we rewrite the list from `[x0] ++ [x1] ++ ... ++ [xn]' form (which is ambiguous, up to associativity), to `[x0] ++ ([x1] ++ (..([xn] ++ [])..))', which is the same as `cons x0 (cons x1 (..(cons xn nil)..))'
07:34:12 <quicksilver> fasta: (but that involves having control of, or choosing to wrap, the funtion which accepts the callback)
07:34:29 <ski> zenzike : and then the value of `fold (z,f)' on this list is defined wrt this *right*-associated representation
07:34:32 <fasta> quicksilver, I do know that it makes my head hurt to convince GHC what I want, which normally doesn't happen.
07:34:53 <fasta> quicksilver, in my case the callback also takes an extra parameter.
07:35:27 <ski> zenzike : so we (unambiguosly) get
07:35:39 <ski>   x0 `f` (x1 `f` (..(xn `f` z)..))
07:35:50 <fasta> quicksilver, so, I want to construct a  FooType -> IO () function.
07:36:10 <ski> but, as you can imagine, there's no speacial reason to prefer the right-associated representation of the list, to the left-associated one
07:36:29 <ski> so we can define both an `foldr f z' and an `foldl f z' operation
07:36:43 <fasta> quicksilver, I already did obvious fix, so I think there is something else wrong. It is kind of hard to see when the types are bigger than the function.
07:36:50 <ski> where `foldl f z [x0,x1,...,xn]' reduces to
07:36:57 <SamB_XP> ski: there is one!
07:36:58 <zenzike> ski: thanks, I think that makes sense
07:37:10 <ski>   (..((z `f` x0) `f` x1)..) `f` xn
07:37:24 <zenzike> ski: your argument is basically based on the structure of the lists, which imposes a reduction strategy for f, even if it isn't associative
07:37:30 <SamB_XP> the right-associative one also works for colists!
07:37:33 <fasta> quicksilver, the idea is that the "buffer" is basically an opaque object, right?
07:37:46 <ski> SamB_XP : there is one (or two), if we have already decided on a canonical representation of lists, yes
07:37:56 <fasta> quicksilver, that is, the user of the library should not do anything with it.
07:38:23 <SamB_XP> well, of course, if time runeth backwards maybe we use the left-associative representation ;-P
07:38:49 <ski> zenzike : well, i'd not say reduction strategy .. rather, "bracketedness" or "associativity" :)
07:39:29 <ski> (it is true that it restricts the reduction strategy .. but there's still room for different choices)
07:39:34 <zenzike> ski: I agree with what you've got there, but the question seems to imply that the important part is to show that associativity is sufficient, but not necessary for a well defined fold. What we're discussing seems to suggest that all we need is a well typed f
07:39:53 <ski> zenzike : right
07:39:54 <zenzike> ski: I'm not sure that this matches the expectation of what Fokkinga is trying to get across
07:40:05 <fasta> aavogt, some people simply write in that style.
07:42:06 <zenzike> ski: here's how he phrases it, word for word: find a non-associative operation for which (fold f) is well defined. Conclude that associativity of `f` is a sufficient, but not necessary condition for (fold f) to be a well defined function on sequences.
07:42:27 <tromp_> f x y = 10x + y
07:42:44 <byorgey> dmwit, fasta: right, spring break = writing an ICFP paper + hacking on diagrams =)
07:43:31 <ski> zenzike : .. (looking at the paper), you might be right that the exercise's after something else
07:43:35 <krainboltgreene> There are some places where Haskell's syntax could be a little more clear.
07:43:53 <zenzike> tromp: I'm not sure that cuts it, since foldl f \= foldr f
07:44:26 <zenzike> ski: it's tricky huh? I had the same reaction as yours initially, and looked to what the [] did, but it seems like he's after something different
07:44:34 <ski> (Fokkinga doesn't seem to have said anything here about associatedness)
07:44:39 <tromp_> if foldl has to equal foldr, then f is associative
07:45:08 <tromp_> as you can see by folding list of length 3
07:45:12 <zenzike> tromp_: that's what I think too, but Fokkinga's question seems to indicate that there's something else to hunt for
07:45:26 <ski> .. maybe if one could find a non-associative `f', such that the outcome still was determined ? .. or quite possibly the latter would imply `f' being associative
07:45:29 <ski> ?
07:45:45 <tromp_> i suggest you email fokkinga:)
07:46:00 <zenzike> tromp_: I'll probably have to do that :-)
07:46:24 <zenzike> ski: yeah, but then `f` would indeed be assoc, so we could still keep it as a necessary condition
07:46:33 <ski> assume any `(+)', `fold (+) [a,b,c]' reduces to `a + b + c', whose definedness is equivalent to `(+)' being associative
07:46:39 <ski> *nod*
07:47:08 <zenzike> ski: I totally agree. flawed question maybe?
07:47:41 <zenzike> ski: unless by `definedness` we're not supposed to be thinking `functional`
07:47:44 <ski> maybe the author meant to give more context / say something not quite the same, but forgot to ?
07:48:11 <zenzike> ski: hm. possibly. I'll email him to see. i'm glad it's not just me being a muppet
07:48:22 <ski> as `fold' is supposed to be defined for every (finite) sequence, i'm not seeing how one could find such a non-associative operation
07:49:39 <zenzike> thanks for the help, I'll spit out an email to see what's being asked
07:49:59 * ski tries to figure out what the smallest non-associative loop is ..
07:51:18 <zenzike> ski: loop?
07:51:36 <ski> "like a group, but operation need not be associative"
07:52:01 <ski> <http://en.wikipedia.org/wiki/Loop_(algebra)>
07:52:41 <ski> (though i suppose in our case, we don't really need the "inverses")
08:01:16 <fasta> When I do  :i InterleavableIO, I don't get the StateT instance, while it is present in the source code on Hackage?
08:01:53 <benmachine> is StateT itself in scope?
08:02:18 <fasta> benmachine, yes.
08:03:56 <Nebasuke> ghci only lists like 3 instances if I recall correctly
08:04:29 <benmachine> Nebasuke: import Data.Data and then do :i Data
08:04:44 <benmachine> (it's even more fun after importing a big library like haskell-src-exts)
08:05:30 <benmachine> fasta: maybe some other component of the instance is not in scope, like a constraint somewhere?
08:05:53 <fasta> benmachine, I don't think that should matter.
08:06:01 <benmachine> ghci doesn't care what you think :P
08:06:09 <benmachine> I remember the MArray STArray instance doesn't show up when you import both Data.Array.ST and Data.Array.MArray
08:06:21 <benmachine> you need Control.Monad.ST as well
08:06:36 <benmachine> so I'm guessing it's something like that
08:07:02 <fasta> benmachine, that is because in the reflective transitive closure of the module relation the instance is not defined in that case.
08:07:22 <fasta> benmachine, in this case I am importing the module which actually defines the instances.
08:07:40 <fasta> I will just copy the definitions and see what it comes up with.
08:10:53 <fasta> benmachine, ah, cool. I was wrong. I wonder where the standard specifies that behaviour.
08:14:17 <benmachine> fasta: it may be that there are instances which are usable in code but don't show up in ghci
08:14:27 <benmachine> because ghci doesn't have complete information to represent them
08:15:02 <benmachine> that's just a guess though
08:19:30 <SamB_XP> benmachine: huh?
08:19:48 <SamB_XP> GHCi uses the same Haskell compiler that GHC does ..
08:20:59 <wferi> Hi! For a data type defined by labeled fields, I wrote the following helper function:
08:21:08 <wferi> updateIf predicate operation object | predicate object = operation object
08:21:09 <wferi>                                     | otherwise        = object
08:21:58 <roconnor> @hoogle (a -> Bool) -> (a -> a) -> a
08:21:59 <benmachine> SamB_XP: yeees but it may have different rules about what it links and when
08:21:59 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:21:59 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
08:21:59 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
08:22:04 <wferi> But this fails if predicate uses an "automatic" field selector function not defined by all alternative constructors.
08:22:26 <wferi> The failure is an exception, but I can't catch that in pure code.
08:22:52 <roconnor> wferi: you will need to write a smarter field selector by hand :(
08:23:06 <wferi> That's exactly I wanted to avoid.
08:23:18 <roconnor> the alternatives are worse
08:23:22 <wferi> :)
08:23:35 <benmachine> the record system in haskell is one of its weak points, imo
08:23:46 <wferi> Agreed.
08:23:48 <roconnor> well, you could have template haskell generate a smart field selector for you
08:24:16 <wferi> Well, my data type is defined by template haskell, so that isn't a long shot, but isn't my favourite meal either.
08:24:29 <roconnor> ah you are set
08:25:08 <wferi> Yep, this was my only excursion into template haskell. Two years ago.
08:25:32 <wferi> I'll either warm my experience up or go a different route altogether.
08:25:43 <ozataman> what is the best editor for haskell on windows?
08:25:46 <bjorkintosh> what is 'template haskell'?
08:25:50 <wferi> Looks like there's no obvious good solution for this.
08:25:59 <progo> ozataman, any editor you choose
08:26:10 <ozataman> progo: well, i guess i should clarify
08:26:17 <benmachine> bjorkintosh: a technique for generating haskell code at compile time
08:26:27 <ozataman> by best, i meant one that would do auto-indentation, syntax highlighting, would be fast/responsive
08:26:32 <bjorkintosh> ah
08:26:33 <benmachine> (like a preprocessor)
08:26:44 <bjorkintosh> something lisp does, no?
08:26:48 <bjorkintosh> (or can do)
08:26:50 <benmachine> so I've heard
08:26:56 <roconnor> wferi: are you only updating a subfield of this data type?
08:27:05 <benmachine> ozataman: my favourite is vim, a lot of people like emacs though
08:27:29 <benmachine> there is an editor written in haskell called yi
08:27:31 <wferi> roconnor:  The helper function tries to be generic, but most of the time, yes.
08:27:42 <benmachine> which can behave like vim or emacs or some other things
08:28:06 <roconnor> wferi: well if the predicate and the update is only looking at a subfield, I'd be tempted to use data.accessor
08:28:17 <benmachine> I've only ever been annoyed by autoindentation personally >_>
08:28:28 <progo> Some like jEdit.
08:28:41 <wferi> roconnor: what's data.accessor?
08:28:54 <roconnor> wferi: but you still have to either write an accessor by hand or use template haskell to generate it (possibly using data.accessor.template
08:29:05 <roconnor> http://hackage.haskell.org/package/data-accessor
08:29:15 <roconnor> plus there are many related packages on hackage
08:29:18 <benmachine> if you do cabal list data-accessor
08:29:21 <benmachine> you find about six things
08:29:28 <benmachine> all of which are interesting in some way
08:29:34 <wferi> roconnor: ok, thanks for the tip, I'll check this out.
08:29:41 <ozataman> thanks for all the suggestions.. i'll take a look
08:30:21 <benmachine> ozataman: remember if you pick vim or emacs you're culturally obliged to declare that it is the best thing ever and the other one is obviously rubbish
08:30:31 <benmachine> (no, not really :P)
08:30:38 <ozataman> benmachine: :) i'll keep that in mind
08:31:35 <roconnor> I can't understate how awesome data.accessor is
08:31:44 <roconnor> granted I haven't used it much :D
08:32:11 <Igloo> Do you mean you can't overstate it?
08:32:18 <roconnor> er
08:32:19 <benmachine> heh
08:32:19 <roconnor> right
08:32:26 <roconnor> I can't overstate how awesome data.accessor is
08:32:34 <benmachine> it's so awesome he finds himself physically unable to be critical of it
08:35:00 <wferi> data.accessor advertises semantic-editor-combinators, but it isn't clear which one I'd prefer.
08:36:22 * ToRA has defaulted to fclabels just because :-> looks like an ->
08:36:23 <roconnor> is semantic-editor-combinators a library?
08:36:41 <wferi> http://conal.net/blog/posts/semantic-editor-combinators/
08:37:20 <conal> @wiki DeepArrow
08:37:20 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
08:37:28 <conal> roconnor: ^^
08:37:31 <roconnor> ah lenses and fclabel.
08:38:05 <conal> roconnor: there's also a recent SEC lib on hackage.  i think it's limited to functions.
08:38:10 <ToRA> though i'll tip my hat to data.accessor for getting closer to the 'right' api for dealing with monadstate
08:38:50 <roconnor> lenses seems to be exactly the same interface as data.accessor, but less mature.
08:39:48 <roconnor> it seems that way for fclabel too, though I'm less sure
08:41:10 <mornfall> So is it exactly the same or not? : - P
08:41:14 <roconnor> semantic editors are differet since they have no get method
08:41:37 <roconnor> of course semantic editors also have all the advantages mentioned on the data.accessor page
08:42:15 <roconnor> so whether you want semantic editors or data.accessor depends on your task at hand.
08:42:32 <roconnor> I guess there is some overlap of tasks where either would work.
08:44:08 <wferi> roconnor: Thanks for the analysis. I'm also reading up on the topic myself, but I'm less used to such things, so it's somewhat slower.
08:44:35 <fasta> roconnor, what exactly do you use "semantic editors" for?
08:46:40 <roconnor> ``Editors only consist of a modify method (and modify applied to a const function is a set function). This way, they can modify all function values of a function at once, whereas an accessor can only change a single function value, say, it can change f 0 = 1 to f 0 = 2.
08:47:05 <roconnor> ``An Arrow instance can be define for editors, but for accessors only a Category instance is possible
08:48:15 <roconnor> so accessors have getters and setters, while editors can only modify.  But the restriction of operations for editors also broadens its domain of applications.
08:49:14 <wferi> I don't quite get the first statement.
08:49:50 <wferi> How is restriction to modify connected to changing functions?
08:50:28 <wferi> Modifying all or part of function values means modifying the function itself, doesn't it?
08:51:03 <fasta> roconnor, I still go with the semantic editor combinators only sounds cool theory.
08:51:10 <fasta> sound*
08:51:22 <fasta> roconnor, accessors serve a clear purpose.
08:52:22 <roconnor> I've never used semantic editors
08:52:35 <roconnor> and I've barely used accessor  :D
08:52:51 <fasta> roconnor, same here.
08:53:07 <Twey> I've never used Accessor, and I've barely used semantic editors
08:53:33 <roconnor> wferi: because editors have no get clause, the editor can modify several location in a structure all with the same modifier.
08:54:10 <Berengal> I've only used SECs for obfuscated pointlessness
08:54:12 <wferi> It must be simple, but I don't get the implication. Probably mindset problem.
08:54:14 <Berengal> But they are very appealing
08:54:31 <roconnor> wferi: think of a function x -> y as an array with indices x and values y.
08:54:38 <wferi> ok
08:55:00 <roconnor> wferi: an accessor has a get a set method, and could modify this "array" at one point, or get it's value at this one point
08:55:10 <wferi> ok
08:55:24 <wferi> but not the array as a whole?
08:55:26 <roconnor> wferi: but *one* accessor couldn't modify the entire array at once
08:56:05 <roconnor> wferi: you'd have to have use a pontentially an infinite collection of modifiers to change this entire (pontentially infinite) "array" at once
08:56:19 <wferi> we're on different tracks.
08:56:49 <wferi> Can we say that every data structure is a function?
08:57:02 <roconnor> I don't think so
08:57:04 <Berengal> Yes
08:57:09 <roconnor> heh
08:57:10 <Berengal> At least ADTs
08:57:27 <roconnor> Berengal: how is Bool a function?
08:57:29 <fasta> Every data declaration induces a number of functions, I'd say.
08:57:45 <wferi> The function takes the "path" and returns the value at the end of that path in the data structure.
08:57:56 <Berengal> roconnor: bool :: a -> a -> Bool -> a
08:58:09 <roconnor> wferi: okay I'm good with that
08:58:10 <fasta> wferi, that sounds like getf from Common Lisp.
08:58:18 <roconnor> more or less.
08:58:23 <Berengal> Wait, let me rephrase that
08:58:34 <wferi> probably, or (second.result.first.element) from Conal's blog post.
08:58:36 <roconnor> Berengal: oh, you mean a church function
08:58:37 <Berengal> type Bool = a -> a -> a
08:58:41 <roconnor> Berengal: interesting
08:58:41 <Berengal> And so on
08:58:45 <fasta> roconnor, getf and setf are interesting concepts in a programming language. If Conal got that in Haskell, he did something useful.
08:58:51 <Berengal> true :: Bool, false :: Bool
08:59:01 <fasta> But I _really_ doubt that.
08:59:13 <wferi> Berengal: I think I mean something else.
08:59:17 <Berengal> roconnor: This can be done for all ADTs, and you can think of pattern matching as syntactic sugar for the destructor function
08:59:25 <wferi> at least I don't see the connection.
08:59:42 <roconnor> wferi: yes, every accessor (like you are describing) induces a semantic editor
08:59:58 <wferi> roconnor: yep.
08:59:58 <roconnor> however there are some operations than you can do with an accessor that you cannot do with an editor
09:00:17 <roconnor> and on the other hand there are some semantic editors that are not induced from an accessor.
09:00:54 <wferi> But what's the principal difference between treating array elements separately and treating the array as a whole? It's only a difference of one path level.
09:01:28 <wferi> And the former is always a special case of the latter.
09:01:39 <roconnor> for example, map is a semantic editor on lists, but there is no accessor that induces this semantic editor.
09:02:56 <wferi> Let me take map then... I've got a data structure: a list.
09:03:03 <roconnor> let foo modifier (Left x) = Left (modifier x); foo modifier (Right x) = Right (modifier x);   here foo is again a semantic editor, but there it is not induced by an accessor because it modifies *two* locations.
09:03:50 <wferi> I've got the option of updating lists element one-by-one: update f index list
09:04:07 <roconnor> er, I think I screwed up that example
09:04:08 <wferi> or the list as a whole: updateL f list.
09:04:27 <roconnor> let foo modifier (x,y) = (modifier x,modifier y);   here foo is again a semantic editor, but there it is not induced by an accessor because it modifies *two* locations.
09:05:05 <wferi> but it's induced by an accessor one level outer.
09:05:15 <wferi> (it is one, actually)
09:05:34 <roconnor> wferi: what does get return?
09:05:43 <wferi> the pair
09:05:49 <roconnor> wrong type
09:05:56 <wferi> ?
09:06:25 <wferi> I probably don't know what an "accessor" is.
09:07:01 <roconnor> an accessor is a object of the abstract data type (Accessor r a)
09:07:13 <roconnor> think of r as some record type and a as some field type
09:07:29 <roconnor> the operations for the abstrace data type are the following
09:07:33 <tromp_> @hoogle Accessor
09:07:34 <lambdabot> No results found
09:07:46 <roconnor> get :: Accessor r a -> r -> a
09:07:58 <roconnor> set :: Accessor r a -> a -> r -> r
09:08:47 <wferi> Is'n Accessor r r always an option?
09:09:06 <wferi> quite a trivial one.
09:09:17 <roconnor> using this primitive we can write modify :: Accessor r a -> (a -> a) -> (r -> r)  modify accessor modifer x = set accessor (modifer (get accessor x)) x
09:09:31 <roconnor> modify accessor modifer x = set accessor (modifer (get accessor x)) x
09:10:09 <roconnor> now given an foo :: Accessor (a,a) a
09:10:53 <roconnor> we can write "get foo (1,2)" and it will return some integer (presumably 1 or 2).
09:11:15 <wferi> ok
09:11:23 <roconnor> and we can write "modify foo (+1) (1,2)"  and it will result in some pair (presumably (2,2) or (1,3))
09:11:33 <roconnor> but....!
09:11:46 <roconnor> given an accessor of type (Accessor (a,a) a)
09:12:00 <roconnor> or rather
09:12:28 <roconnor> there can never be an accessor of type (Accessor (a,a) a)  such that "modify foo (+1) (1,2)" is (2,3)
09:13:00 <wferi> ok
09:13:02 <fasta> roconnor, and how differ "semantic editor combinators" from just functions?
09:13:08 <roconnor> otoh, there can be a (bar :: (SemanticEditor (a,a) a)) such that "modify bar (+1) (1,2)" is (2,3)
09:13:40 <dancor> :t (+) *** (+)
09:13:41 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
09:13:49 <wferi> roconnor: thanks, this was very instructive indeed!
09:13:50 <wferi> But
09:14:25 <wferi> If you have foo :: Accessor a a, then you're back to functions which can do anything.
09:14:26 <roconnor> fasta: hmm, good question.  I cannot think of a difference.
09:14:40 <dancor> @pl \ (a, b) (c, d) -> (a + c, b + d)
09:14:41 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
09:15:10 <fasta> roconnor, right, which is why I think semantic editor combinators are designed to waste the time of people.
09:16:01 <roconnor> wferi: sure, but you an only edit anything in the same way that you can edit anything without using accessors.
09:16:11 <roconnor> wferi: ah actually
09:16:42 <roconnor> wferi: you can only edit know structures with Accessor a a
09:16:52 <roconnor> but you won't be able to edit abstract structures
09:17:20 <wferi> Or rather, if you have and Accessor a a instance, your structure isn't abstract anymore.
09:17:21 <roconnor> for example a module my export an abstract type and export operations that generate accessors for that abstract type
09:17:34 <roconnor> *module may export ...
09:17:53 <wferi> ok!
09:18:18 <roconnor> and even if they don't do information hiding, using Accessor might be a good way to structure your code.
09:18:58 <roconnor> it allows you to change your respresentation of your data more easily because you need only modify the code that generates the accessors, not the code that uses them.
09:19:11 <wferi> The main point of the Accessor class seems to be hiding, though, and I can't see how semantic editors could do this.
09:19:17 <Polarina> How do I convert [[1,2],[3,4],[5,6]] to [1,2,3,4,5,6]?
09:19:29 <mmaruseacph2> Polarina, concat
09:19:29 <wferi> Polarina: concat
09:19:30 <dancor> > concat [[1,2],[3,4],[5,6]]
09:19:31 <lambdabot>   [1,2,3,4,5,6]
09:19:34 <fasta> MPTCs where you have to annotate the instance you want by providing an explicit type-signature are annoying.
09:19:46 <roconnor> wferi: same thing.  Your module may keep a data type abstract, and export "semantic editors" that allow the user to modify that abstract type.
09:20:03 <Polarina> Thanks.
09:20:44 <wferi> Which only makes sense if it's enough to provide Arrow instances...
09:20:49 <wferi> or not?
09:21:20 <wferi> What does exporting semantic editors entail?
09:22:58 <roconnor> at the very least it means given an abstract structure Foo, providing a function bar :: (Quux -> Quux) -> (Foo -> Foo)
09:23:17 <roconnor> though it could be more general than this
09:24:35 <wferi> The editors should be building blocks, isn't that their point?
09:25:01 <wferi> exporting specific editors for specific fields isn't a great invention in itself.
09:25:01 <roconnor> ya.. hmm I guess one should probably export more
09:25:36 <roconnor> perhaps you need to go as far a s providing an abstract sturcture Foo a, with a function bar :: (a -> b) -> Foo a -> Foo b
09:25:43 <roconnor> though Foo could have multiple parameters
09:25:54 <int-e> fmap?
09:26:18 <roconnor> int-e: fmap is great if you have an abstact type that is a functor in one way.
09:27:05 <wferi> you probably have to provide the building blocks of the paths in your data structure.
09:27:13 <roconnor> but you might have a module that exports Pair a b and modifyFirst : (a -> b) -> (Pair a c) -> (Pair b c) and modifySecond : (a -> b) -> (Pair c a) -> (Pair c b)
09:27:28 <wferi> If you use (,) and [] only, Functor instances are just enough.
09:27:37 <roconnor> you could do crazy things with newtype and multiple functor instances that way.  It isn't clear to me that that would be worthwhile.
09:30:19 <wferi> roconnor: Anyway, thanks for the discussion. It was very interesting and didactic.
09:33:15 <roconnor> @type snd
09:33:16 <lambdabot> forall a b. (a, b) -> b
09:33:18 <roconnor> @type second
09:33:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:35:52 <roconnor> actually it seems semantic editors are intended to be more generally  bar :: (a ~> b) -> (Foo a ~> Foo b)
09:45:50 <jmcarthur> roconnor: so generalized Functor?
09:50:00 <tavelram> any suggestions on how I should implement a non-empty list-looking datatype? Ie data A = A Yada [Yada], or perhaps data A = ASingleton Yada | ACons Yada A ? The latter one should be alot uglier to work with though, right?
09:51:06 <byorgey> tavelram: yes, the first is probably easier to work with since you don't have to completely reimplement all the list functions in the prelude
09:51:17 <tavelram> yeah
09:51:42 <jmcarthur> tavelram: either is a perfectly valid way to do it. the former will have a few more things predefined for you, but it may be the case that fewer list operations apply than it may at first seem anyway
09:52:56 <zygoloid> another option is to use an abstract data type, newtype NonEmptyList a = NEL [a], and only export ways of constructing NonEmptyList which guarantee the list is non-empty
09:53:17 <tavelram> ok, yeah, but what about the ambiguity of singleton then?
09:53:31 <jmcarthur> ambiguity?
09:53:40 <tavelram> oh, sorry, missread.
09:53:59 <jmcarthur> for the record, i like zygoloid's suggestion the most, aside from not being able to use pattern matching
09:54:04 <jmcarthur> ViewPatterns can help though
09:54:58 <tavelram> yeah. But id prefer to get non-empty at the type-level though.
09:55:11 <tavelram> at compile time, rather.
09:55:21 <jmcarthur> zygoloid's suggestion would guarantee non-empty
09:55:28 <jmcarthur> if you control your exports
09:55:39 <jmcarthur> or do you mean you want the compiler checking your implementation?
09:55:43 <Alpounet> I agree
09:56:05 <tavelram> yeah
09:56:18 <tavelram> but it seems like it would be fine
09:56:22 <Alpounet> just export a "smart constructor" function for your list
09:57:14 <ben> If only you could pattern-match against smart constructors
09:57:22 <tavelram> yeah. I guess im just procrastinating..
09:57:30 <tavelram> ben, isnt there an extension for that?
09:57:45 <ben> view patterns, I guess, but at some point you need proper constructors?
09:58:07 <tavelram> for the pattern matching?'
09:58:10 <ben> Yes
09:58:22 <tavelram> isnt there an extension to pattern match on record-fields?
09:59:47 <Alpounet> tavelram, like { x = foo, .. }
09:59:49 <Alpounet> ?
09:59:58 <tavelram> yeah?
10:04:07 <tavelram> Alpounet, or that doesnt count as pattern matching? or it isnt considered general enough, since it requires records?
10:05:56 <Alpounet> tavelram, check just before "The one exception", here : http://en.wikibooks.org/wiki/Haskell/Pattern_matching#The_one_exception
10:09:48 <tavelram> Alpounet, oh right, it of course uses the record-constructor as well.
10:10:16 <Alpounet> yes
10:12:41 <chrisdone> what's going on in the haskell world apart from a load of brilliant llvm work?
10:13:02 <ben> terrible, the apocalypse is nigh
10:13:06 <ben> haskell weekly news has fewer funny quotes with each issue!!
10:13:26 <Boohbah> clojure is stealing users
10:13:27 <chrisdone> unsafePublishMagazine
10:14:01 <ben> chrisdone: Also I heard some guy wrote a web interface with an interactive haskell tutorial, you should check that out!!
10:14:02 <Vulpyne> unfunnyPublishMagazine :(
10:14:11 <chrisdone> ben: tee hee =)
10:14:25 <chrisdone> ben: 3,400 unique visitors so far!!
10:14:42 * chrisdone demands more haskellers
10:14:47 * ben demands more tutorial steps
10:15:36 <chrisdone> touche
10:15:40 * shapr demands more code, of any flavor.
10:16:29 <byorgey> > fix ("blueberry code":)  -- more code for shapr, with a blueberry flavor
10:16:30 <lambdabot>   ["blueberry code","blueberry code","blueberry code","blueberry code","blueb...
10:16:36 * cebewee would like a more conformant editor window in this tutorial (key repeats and copy'n'paste don't seem to work)
10:16:44 <shapr> byorgey: haha
10:16:47 <ben> chrisdone: Even my "oh god stop reading about haskell all day" girlfriend had fun working through the tutorial and was disappointed when it was suddenly over :V
10:16:52 <mreh> does anyone have an experience with genetic programming in haskell?
10:17:02 <chrisdone> ben: sweet!
10:17:07 <shapr> hej potatishandlarn, bor du i Boden? I used to live on potatisvgen in Boden.
10:17:24 <shapr> mreh: Haskellers are too geeky to have kids.
10:17:39 <byorgey> hahaha
10:17:42 <mreh> <_<
10:17:53 <shapr> http://www.haskell.org/haskellwiki/Applications_and_libraries/Genetic_programming
10:18:00 <mreh> -_-
10:18:01 <ben> chrisdone: Also, the command history seems a bit confusing - once you recall a command and press return to send it, writing more lines does not seem to reset the "current position" in the history to the newest command but to the one just recalled
10:18:05 <ben> is that how it is supposed to work?
10:18:08 <yowgi> mreh, I've done GP in Haskell
10:18:40 <yowgi> with my own code though, not with the GP lib on hackage
10:18:42 <ben> Basically I am really easily confused by history buffers that do not work like irssi :)
10:19:05 <Alpounet> mreh, IIRC, there's a GA library on hackage
10:19:23 <mreh> yowgi: ah... have you found a way to mutate and crossover polytypic expressions?
10:19:32 <yowgi> yes
10:19:38 <yowgi> i have many special cases
10:19:48 <McManiaC> http://npaste.de/Iu/  how can I get my Executable (at the bottom) to build?
10:19:50 <mreh> yowgi: so there's no elegant way to do it?
10:20:02 <yowgi> none that I found anyway
10:20:05 <chrisdone> ben: indeed -- that's a bug
10:20:22 <mreh> yowgi: are you aware of GADTs?
10:20:22 <yowgi> I have Bool and Double expressions only though
10:20:35 <yowgi> I've heard of it, but don't know what it is, non
10:20:41 <mreh> yowgi: Boolean logic and Arithmetic?
10:20:45 <yowgi> yes
10:20:51 <yowgi> it's a decision algorithm
10:21:03 <mreh> aww... that's exactly what I'm doing, it's a homework assignment
10:21:09 <yowgi> (if (> (variable "x") (variable "y")) ...
10:21:18 * hackagebot minirotate 0.1.2.1 - Minimalistic file rotation utility  http://hackage.haskell.org/package/minirotate-0.1.2.1 (KrzysztofSkrzetnicki)
10:21:33 <mreh> yowgi: can I see how you implemented it?
10:21:51 <yowgi> not sure I have it here, I'm at work
10:21:56 <yowgi> let me see
10:26:41 <yowgi> mreh, got it
10:26:48 <mreh> yowgi: well done that man
10:27:21 <mreh> @paste
10:27:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:27:35 <mreh> I only want to see the data types really, I've written loads of GAs
10:27:41 <yowgi> ok
10:28:00 <mreh> I'm particularly interested in how you represented the expressions and manipulated them
10:28:29 <yowgi> mreh, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8450
10:29:17 <roconnor> Vezzosi says ``And yes, the general user is supposed to use the Haskell Platform, only maintainers and testers should go fetch the latest ghc to prepare for the next platform release.
10:29:19 <yowgi> sorry I'm a beginner and don't really know how to do better than that
10:29:22 <roconnor> god damn it
10:29:29 <roconnor> I hate the Haskell Platform so much
10:30:36 <roconnor> it is going to destroy haskell by entrenching bad libraries
10:31:19 <chrisdone> what's the Haskell Platform?
10:31:48 <yowgi> mreh, then I need eval and evalB, both taking a Map of String  a for the variables and String  ([Expr a]  Expr a) for the functions
10:32:11 <mreh> yowgi: are they not implemented yet?
10:32:23 <yowgi> they are, partially
10:32:24 <roconnor> chrisdone: it is dons collection of ghc + the standard libraries that ghc expelled because they were dragging ghc down.
10:32:33 <yowgi> plus pruning, which is pretty basic now
10:32:43 <mreh> I have a working boolean expression evaluator that binds values to free variables
10:32:43 <yowgi> things like prune (If (ConstBool True) t f) = prune t
10:32:59 <mreh> yowgi: don't use boolean constants :)
10:33:45 <mreh> the mutation operator "pull" is quite good at pruning, but not as good as "delete"
10:33:54 <yowgi> you're right, but notice that I don't have unary boolean operators
10:34:01 <mreh> the latter really helps cut down on the non-coding genetic data
10:34:02 <yowgi> I have ^&|,
10:34:11 <mreh> not?
10:34:17 <mreh>  or ~
10:34:22 <yowgi> I don't have not, no.
10:34:29 <yowgi> I'll add it at some point
10:34:30 <mreh> you need not
10:34:41 <mreh> it doesn't make a complete set otherwise
10:35:12 <mreh> "minimal set of operators", I think that's what the 1st year logician called them
10:35:58 <flux> x^true = not x?
10:36:23 <yowgi> flux yes, but in this case I don't have boolean equality either
10:36:26 <mreh> mutating polytypic expressions is quite a big deal, if you have generic functions to fetch the expressions, subExpression :: Int -> Expr -> Expr for example
10:36:52 <flux> x equals y === x ^ (y ^ true) :-)
10:36:57 <mreh> x && True = x
10:37:23 <yowgi> ah well there you go
10:37:27 <mreh> I can't work out how to do it
10:37:40 <jmcarthur> i'm okay with the haskell platform. it doesn't mean i have to use those libraries, but if i do then my code is guaranteed to work on platforms that have "the haskell platform" which is a lot less problematic than saying it has to work on platforms with library X, library Y, library Z, etc.
10:39:11 <maltem> roconnor, why would the platform entrench bad libraries?
10:40:59 <yowgi> mreh, since you are into that kind of code: there is something that has always bothered me and maybe you have an answer. how deep do you allow the trees to go when you generate them? you can start at an empty node, or a random one, and add more to it... but when is it too much?
10:41:06 <roconnor> maltem: for example people think they should install the mtl because say it is in the haskell platform, they will create software that depends on the mtl, and others will build software that depends on it, and so forth
10:41:18 <roconnor> soon we will never be able to replace the mtl
10:41:45 <maltem> ok monad transformers are an issue because they are so pervasive wrt dependencies
10:41:59 <mreh> yowgi: shorter solutions are always easier to work with computationally, but there is no clear answer how long they should be
10:42:18 <zygoloid> > (True `not`)
10:42:19 <lambdabot>   False
10:42:24 <mreh> however, you can define a function that grows trees, either "full" trees, or "grow" trees
10:42:25 <ezyang> Bah, still don't understand category theory
10:42:26 <zygoloid> hmm. is that haskell'98?
10:42:35 <maltem> we need a meta-transformer that makes every library usable in the context of any monad transformer library ;)
10:42:57 <mreh> "full" trees are uniform and all paths go to the same depth
10:43:15 <roconnor> maltem: because I fear monad transfomers are like List and Maybe: they are part of the glue that is used to connect libraries together
10:43:26 <mreh> with "grow" there is a probability that the next node may be a terminal node, otherwise you stop growing upto a predefined depth
10:44:32 <maltem> roconnor, but actually I'm not sure if library writers pay attention very much to what transformer library is in the platform
10:44:53 <roconnor> maltem: why do you think that?
10:45:06 <maltem> well I wouldnt ;)
10:45:14 <roconnor> :D
10:46:08 <maltem> I mean, it's more important if it works together with your other dependencies. Which may lock you down to the mtl
10:46:12 <zygoloid> what does it mean for a monad to be commutative? that (>>) is?
10:46:25 <maltem> s/if/whether/
10:46:36 <mreh> yowgi: it doesn't matter if the solutions are too short to begin with, with mutation and crossover they will grow to a decent enough length to contain all variables in the case of boolean expressions
10:46:45 <roconnor> zygoloid: it means that liftM2 (flip) = flip
10:46:49 <ezyang> zygoloid: Commutativity as in a >> b = b >> a ?
10:47:07 <Alpounet> that's what he's asking, I guess
10:47:19 <roconnor> er
10:47:20 <roconnor> sorry
10:47:20 <ezyang> that's... od.
10:47:21 <yowgi> mreh, yes. my concern is performance though
10:47:25 <ezyang> *odd
10:47:29 <roconnor> zygoloid: it means that liftM2 (flip f) = flip (liftM2 f)
10:47:43 <ezyang> I guess Identity is commutative
10:47:55 <mreh> yowgi: can't be helped normally :\
10:48:00 <roconnor> Maybe, Identity, and Reader are all commutative monads
10:48:12 <zygoloid> roconnor: ok, thanks, that makes sense. so (>>) being commutative is necessary but not sufficient
10:48:13 <mreh> unless the test set of your fitness function can be reduced and cycled for each generation
10:48:32 <roconnor> zygoloid: >> isn't generally commutative in a commutative monad
10:48:40 <roconnor> heck flip >> and >> don't even have the same type
10:48:44 <roconnor> @type (>>)
10:48:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:48:50 <roconnor> @type (flip (>>))
10:48:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
10:49:32 <maltem> @type \f -> liftM2 (flip f)
10:49:33 <lambdabot> forall a2 a1 r (m :: * -> *). (Monad m) => (a2 -> a1 -> r) -> m a1 -> m a2 -> m r
10:49:34 <mreh> yowgi: when you're trying to evolve more than 2^11 boolean variables for example, a modern laptop struggles to converge on a solution in the order of an hour, that's the fact of the matter
10:50:00 <roconnor> zygoloid: you know how a monoid is a monad in the category of endofuctors?  It is that operation that is commutative, not the (>>) operation.
10:50:03 <mreh> that's been my experience
10:50:19 <roconnor> zygoloid: er, you know how a *monad* is a *monoid* in the category of endofuctors?  It is that operation that is commutative, not the (>>) operation.
10:50:28 * roconnor sucks at explaining.
10:50:29 <zygoloid> a >> b = liftM2 (flip const) a b = flip (liftM2 const) a b = liftM2 const b a = b >>= ignore a
10:50:37 <zygoloid> ^^ that's the sense in which i meant (>>) is commutative
10:50:53 <roconnor> ah
10:50:54 <zygoloid> where ignore a b = b >> return a
10:50:56 <mreh> what is an endofunctor?
10:51:03 <roconnor> @src Endo
10:51:04 <lambdabot> Source not found.
10:51:11 <Alpounet> a functor from a category to itself
10:51:11 <roconnor> @hoogle Endo
10:51:11 <lambdabot> Data.Monoid newtype Endo a
10:51:12 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
10:51:12 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
10:51:29 <roconnor> I guess that isn't a functor
10:51:34 <ezyang> I'm working through http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf right now
10:51:42 <roconnor> mreh: Alpounet is correct
10:52:07 <mreh> a functor is just a container, in the haskell sense
10:52:38 <Alpounet> it takes types and maps them to other types, takes functions and maps them to other functions (other possibly being the same, for the identity functor)
10:52:51 <Alpounet> (^^^^^ in the haskell case )
10:52:53 <mreh> so it's like a fixed point operator?
10:53:31 <Alpounet> huh ?
10:54:20 <mreh> do monoids have anything to do with fixed point operators?
10:54:37 <mreh> or am I making a category(!) error
10:54:47 <chrisdone> @drumroll
10:54:47 <lambdabot> Unknown command, try @list
10:55:02 <zygoloid> roconnor: perhaps a nice way of thinking about it is, the monoid has graph-like structure; any topological ordering of the nodes is equivalent
10:55:50 <zygoloid> the 'boxes-and-arrows' diagrams are invariant under deformation
10:56:02 <zygoloid> now it's me who's sucking at explaining
10:56:31 * roconnor doesn't think monoids have much to do with fixed point operators
10:56:32 <Alpounet> how do you represent the binary operation ?
10:57:19 <mreh> roconnor: I think one is to do with categories, one is to do with specific values
10:57:22 <mreh> possibly
10:57:28 <mreh> what about the Y-combinator
10:57:42 <mreh> or any of the other many combinators
10:57:57 <Alpounet> it doesn't come from category theory
10:58:15 <mreh> I'm mixing my lambda calculus and category theory
10:59:47 <mreh> that's how I like my women
10:59:52 <mreh> mixed
11:00:36 <shepheb> mreh: you like them to be theoretical constructions? :P
11:01:14 <roconnor> *L*
11:01:50 <mreh> no, mixed
11:02:29 <mreh> there must be a swiss tony gag in here somewhere
11:04:45 * hackagebot minirotate 0.1.2.2 - Minimalistic file rotation utility  http://hackage.haskell.org/package/minirotate-0.1.2.2 (KrzysztofSkrzetnicki)
11:06:15 <aledge> i like the name yyz better
11:06:30 <tromp_> toronto airport
11:06:36 <aledge> well yes
11:06:52 <lep-delete> but yyz is already registerd
11:06:55 <aledge> also a Rush song :)
11:06:56 <aledge> oh
11:07:37 <zygoloid> named after the airport it seems
11:07:51 <aledge> most likely
11:07:59 <aledge> pretty sure i read that anyway
11:08:09 <tromp_> wonder why canadian airport codes start with y...
11:08:10 <lep-delete> ja
11:08:11 <zygoloid> i just read it on wikipedia so it Must Be True
11:08:14 <lep-delete> sry
11:08:15 <aledge> haha
11:08:28 <shepheb> in ICAO they start with C
11:08:44 <zygoloid> > let y = fix in y y z
11:08:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:10:43 <lep-delete> yes! im an infinite type!
11:11:40 <roconnor> zygoloid: I just added it to wikipedia so it Must Be True
11:12:18 <mreh> wikipedia is trurth
11:12:26 <mreh> heh, how ironic
11:13:15 <roconnor> when reviewing how pushouts and colimits are related I found that there was a statement on the wikipedia page that was at best misleading and at worst it was wrong.
11:13:26 <roconnor> I was kinda pissed and I changed it.
11:13:33 <roconnor> then I realized ... the system works!
11:13:52 <cheater2> hiii
11:18:46 <Tarrasch> I find my `Control.Monad.Identity' in two different packages and I can't therefor compile my program. Any way to select one of the packages?
11:19:02 <Alpounet> package imports
11:19:43 <Alpounet> import "network" Network.Socket -- for example
11:19:56 <Alpounet> you must give the flag -XPackageImports to GHC
11:20:21 <McManiaC>     Warning: orphan instance: instance Ord FdKey
11:20:24 <McManiaC> what does this mean?
11:20:37 <Alpounet> or {-# LANGUAGE -XPackageImports #-}
11:20:48 <Alpounet> hmm
11:20:58 <Alpounet> {-# LANGUAGE PackageImports #-} rather, sorry
11:22:12 <Tarrasch> Alpounet, Thanks :D
11:23:13 <Alpounet> yw
11:26:45 <ircleuser> hello
11:27:31 <basketcasemusic> is this coming though?
11:27:45 <osaunders> Yep.
11:28:02 <osaunders> What can I do you for basketcasemusic?
11:28:05 <basketcasemusic> can someone explain how concat works?
11:28:13 <osaunders> Joins lists.
11:28:23 <osaunders> > concat [[1,2,3],[4,5,6]]
11:28:24 <lambdabot>   [1,2,3,4,5,6]
11:28:40 <basketcasemusic> can you do it with strings of characters?
11:29:52 <osaunders> A string, in Haskell, is a list of characters.
11:29:59 <osaunders> To concat any list is a list.
11:30:06 <osaunders> > concat "abc" "def"
11:30:07 <lambdabot>   Couldn't match expected type `[a]'
11:30:07 <lambdabot>         against inferred type `GHC.Types...
11:30:11 <osaunders> Whoops
11:30:17 <osaunders> > concat ["abc", "def"]
11:30:18 <lambdabot>   "abcdef"
11:30:27 <osaunders> > ['a', 'b', 'c']
11:30:28 <lambdabot>   "abc"
11:37:20 <tromp_> > concat . words $ "the quick brown fox jumped over the lazy dog"
11:37:21 <lambdabot>   "thequickbrownfoxjumpedoverthelazydog"
11:42:08 * hackagebot progression 0.3 - Automates the recording and graphing of criterion benchmarks  http://hackage.haskell.org/package/progression-0.3 (NeilBrown)
11:42:28 <aledge> > words "the quick  brown   fox    jumped     over      the       lazy        dog"
11:42:29 <lambdabot>   ["the","quick","brown","fox","jumped","over","the","lazy","dog"]
11:42:42 <FliPPeh_> > map (flip mod 2) [1 .. 10]
11:42:44 <lambdabot>   [1,0,1,0,1,0,1,0,1,0]
11:44:06 <lep-delete> > filter ( flip elem "aeiou" . toLower ) "the quick  brown   fox    jumped     over      the       lazy     dog
11:44:07 <lambdabot>   <no location info>:
11:44:08 <lambdabot>      lexical error in string/character literal at end o...
11:44:16 <lep-delete> > filter ( flip elem "aeiou" . toLower ) "the quick  brown   fox    jumped     over      the       lazy     dog"
11:44:17 <lambdabot>   "euiooueoeeao"
11:44:20 <sm> bah, hold still so I can click on you hackagebot
11:44:58 <sm> hackage needs release ntoes
11:46:40 <MaciejP> Yes, a change summary to the previous version would be nice.
11:47:57 <lep-delete> ja
11:48:00 <lep-delete> arrgh
11:48:15 <dancor> i like cli irc client where i can scroll lock to click link
11:48:34 <roconnor> flip elem foo === (`elem` foo)
11:49:45 <dancor> and of course the toLower isn't needed for this data-set..
11:50:32 <Twey> I used to do the whole (`func` arg) trick, but I prefer flip elem arg nowadays
11:50:44 <Twey> I find the `s and brackets jarring
11:50:54 <roconnor> I specifically think of `elem` as infix
11:51:04 <Vulpyne> (`exclamation` BOO!)
11:51:05 <osaunders> I think it's pretty moot.
11:51:07 <dancor> i can never tell if seasoned programmers are more or less reasonable in their style choices
11:51:26 <MatrixFrog1> i think they are
11:51:31 <MatrixFrog1> that is, they are more or less reasonable
11:51:34 <dancor> ha
11:51:48 <dancor> so there's usually a change as they age
11:51:52 <osaunders> dancor: Less.
11:52:02 <Vulpyne> People are fairly likely to stick with what they started doing, when they were less seasoned.
11:52:08 <dancor> cantankerous style guide
11:52:10 <osaunders> dancor: But only on the style that matters.
11:52:42 <roconnor> osaunders: what is moot?
11:52:45 <dancor> Vulpyne: are they?  i feel like an incessant flipflopper
11:53:02 <Vulpyne> dancor: I think it general. It may be somewhat less true for Haskell people.
11:53:30 <jmcarthur> i recently switched to (`func` arg) over flip func arg because i realized that i really do see `func` as infix syntax now and the section syntax just works well for me now
11:53:35 <osaunders> roconnor: (`elem` [1,2,3]) vs. (flip elem [1,2,3])
11:53:39 <shapr> osaunders: I think commutative is a property of the real numbers used for * and + monoids.
11:53:40 <jmcarthur> and i never really liked flip
11:54:04 <roconnor> IMHO the only reason elem has arguement in the order it does is that they expect people to write it infix
11:54:05 <shapr> osaunders: Because, you mentioned that functions can be monoids. Does that mean those functions must be commutative as well? I don't know.
11:54:10 * shapr hugs jmcarthur
11:54:31 <osaunders> shapr: Function composition isn't commutative.
11:54:44 <shapr> osaunders: But you said it can be a monoid, right?
11:54:52 <dancor> jmcarthur: flip comes up for me all the time for folds, since i usually do my functions in the Map.insert style of key first
11:55:02 <osaunders> Yeah, that's why I don't think commuativity is a requirement of a monoid.
11:55:10 <jmcarthur> :t Data.Map.insert
11:55:11 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
11:55:32 <roconnor> almost no one wants to partial application (elem item), they often want a partial application the other way
11:56:18 <roconnor> commuattivity isn't a requirement of a monoid
11:56:31 <roconnor> > [1,2] ++ [3,4]
11:56:32 <lambdabot>   [1,2,3,4]
11:56:38 <roconnor> > [3,4] ++ [1,2]
11:56:39 <lambdabot>   [3,4,1,2]
11:56:59 <roconnor> (list is the freeeeeeeeeeeeeeeeeeee monoid)
11:58:34 <MatrixFrog1> sounds like a slogan
11:58:42 <MatrixFrog1> List: it's the free monoid!
11:59:52 <chrisdone> jmcarthur: how can you not like flip?
12:00:03 <jmcarthur> chrisdone: are you joking or serious?
12:00:43 <chrisdone> serious but I just read your reason
12:00:52 <chrisdone> (`f` foo) is nice
12:01:00 <FunctorSalad> does anyone maintain a huge comprehensive ctags or etags file for haskell?
12:01:10 <gwern> in retrospect, I should've been much more careful when I did rm -rf \~
12:01:18 <FunctorSalad> running hasktags over the cabal archive would do, I guess
12:01:26 <roconnor> gwern: :(
12:01:30 <FunctorSalad> and the ghc source
12:01:31 <gwern> and made darn sure it was going to do what I thought it'd do
12:01:37 <gwern> roconnor: I escaped - this time
12:01:59 <gwern> FunctorSalad: what would ctags do over hayoo?
12:02:06 <jmcarthur> ls \~ looks good to me
12:02:16 <osaunders> gwern: \~ isn't a directory, do you mean ~/
12:02:18 <osaunders> ?
12:02:26 <roconnor> gwern: I had the same feeling when I using mkfs last year ...
12:02:27 <gwern> osaunders: no, ~ got created somehow
12:02:33 <jmcarthur> osaunders: gwern apparently wanted to delete something named ~
12:02:40 <osaunders> Oh.
12:02:41 <mauke> osaunders: mkdir '~'  # now it is
12:02:45 <gwern> the relaly fun parts is when you make something named '-'
12:02:56 <mauke> touch -- -
12:03:00 <gwern> took me a while to figure out how to delete it
12:03:03 <FunctorSalad> gwern: hmm emacs can use it for find-tag or autocomplete... OTOH, wiring hayoo to autocompletion would be a cute project too
12:03:08 <mauke> rm -- - || rm ./-
12:03:19 <gwern> not often that I use --, because many tools don't support it
12:03:25 <gwern> mauke: the ./ doesn't work, iirc
12:03:26 <FunctorSalad> gwern: rather easy since hayoo already has an API which returns completions ;)
12:03:27 <mauke> perl -e 'unlink "-"'  # fuck it
12:03:30 <mauke> gwern: yes, it does
12:03:51 <gwern> FunctorSalad: then set too
12:03:55 <gwern> *to
12:04:14 <ezyang> Is there a way, given a .hs file, to hoogle automatically with the packages that that file uses?
12:04:30 <chrisdone> jmcarthur: what I would like is a way to flip different arguments in an easy to understand way
12:04:34 <Kruppe> Im testing out System.Random.MWC with: withSystemRandom (uniform) :: IO Bool, but I always get false, is there a reason for this?
12:04:52 <jmcarthur> chrisdone: write out some forth-like functions
12:05:01 <gwern> ezyang: I wouldn't think so. modules can be supplied by multiple packages
12:05:05 <ksf> instance Show (IORef a) where show ref = unsafePerformIO...
12:05:06 <gwern> transformers and mtl come to mind
12:05:15 <FunctorSalad> gwern: to? to doing it?
12:05:16 <ksf> hell I hate impure code.
12:05:31 <gwern> FunctorSalad: set to! set to! ye ken?
12:05:33 <ksf> even Debug.Trace becomes painful.
12:05:51 <osaunders> ksf: Why?
12:05:55 <FunctorSalad> gwern: I don't understand that at all
12:06:08 <ksf> ...see that magnificient instance above.
12:06:13 <ezyang> bleh
12:06:19 <gwern> oh ye of mickle vocab
12:06:45 <FunctorSalad> I'm not natively english ;) but just looked the phrase up
12:07:04 <zygoloid> > nub "the quick brown fox jumped over the lazy dog"
12:07:05 <lambdabot>   "the quickbrownfxjmpdvlazyg"
12:07:18 * hackagebot hellnet 0.1 - Simple, distributed, anonymous data sharing network.  http://hackage.haskell.org/package/hellnet-0.1 (JaroslavGridin)
12:07:18 <wferi> gwern: how did rm -rf \~ make any harm?
12:07:20 * hackagebot hellage 0.1 - Distributed hackage mirror  http://hackage.haskell.org/package/hellage-0.1 (JaroslavGridin)
12:07:22 * hackagebot hellage 0.1.1 - Distributed hackage mirror  http://hackage.haskell.org/package/hellage-0.1.1 (JaroslavGridin)
12:07:38 <osaunders> > (sort.nub) "the quick brown fox jumped over the lazy dog"
12:07:39 <lambdabot>   " abcdefghijklmnopqrtuvwxyz"
12:07:50 <pastorn> @pl \f g -> g >>= \x -> h >> return x
12:07:50 <burp> oh distributed hackage mirror.. what we always wanted? :D
12:07:50 <lambdabot> const ((h >>) . return =<<)
12:07:53 <FunctorSalad> "hellage"... good name
12:08:00 <FunctorSalad> serious business
12:08:00 <zygoloid> uh-oh, there's no 's'!
12:08:03 <ksf> heh. s is missing
12:08:14 <jmcarthur> *jumps
12:08:19 <FunctorSalad> hehe
12:08:31 <ksf> then d would be missing
12:08:33 <zygoloid> > sort $ nub "a quick brown fox jumps over the lazy dog"
12:08:34 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:08:37 <jmcarthur> ksf: "dog"
12:08:39 <Kruppe> dog
12:08:41 <ksf> oh.
12:09:07 <zygoloid> > sort $ nub "jackdaws love my big sphinx of quartz"
12:09:08 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:09:32 <zygoloid> > (filter isAlpha . sort $ nub "jackdaws love my big sphinx of quartz") == ['a'..'z']
12:09:33 <lambdabot>   True
12:09:36 <osaunders> > sort $ nub "omg that's some funky shit"
12:09:37 <lambdabot>   " 'aefghikmnostuy"
12:09:50 <Tarrasch> > sort "jackdaws love my big sphinx of quartz"
12:09:51 <lambdabot>   "      aaabcdefghiijklmnoopqrsstuvwxyz"
12:10:24 <shepheb> Tarrasch: that sounds vaguely dirty.
12:10:50 <jmcarthur> Kruppe: withSystemRandom $ replicateM 10 . uniform :: IO [Bool]
12:10:51 <Tarrasch> shepheb, hey, not my creation :p
12:11:09 <shepheb> > sort "the quick brown fox jumps over the lazy dogs"
12:11:11 <lambdabot>   "        abcdeeefghhijklmnoooopqrrssttuuvwxyz"
12:11:23 <jmcarthur> Kruppe: i think withSystemRandom will always use the same seed within the same run of the program, but different over separate runs
12:11:25 <jmcarthur> i think
12:11:26 <shepheb> > nub $ sort "the quick brown fox jumps over the lazy dogs"
12:11:27 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:12:11 <Kruppe> jmcarthur: running it several times gets different lists, but the first element is always false, strange.
12:12:14 <zygoloid> > nub $ sort "DJs flock by when MTV ax quiz prog"
12:12:15 <lambdabot>   " DJMTVabcefghiklnopqrsuwxyz"
12:12:23 <jmcarthur> Kruppe: huh
12:12:33 <zygoloid> > nub . sort $ map toLower "DJs flock by when MTV ax quiz prog"
12:12:34 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
12:12:38 <jmcarthur> Kruppe: yeah i get the same behavior here
12:12:42 <ksf> > nub "Hello, World!"
12:12:43 <lambdabot>   "Helo, Wrd!"
12:12:43 <jmcarthur> a bug?
12:12:47 <Kruppe> jmcarthur: probably
12:12:49 <ksf> > length . nub  $"Hello, World!"
12:12:50 <lambdabot>   10
12:12:57 <ksf> YES I REALLY NEEDED THAT
12:13:02 <Kruppe> jmcarthur: I can see no reason why it would be that way
12:13:25 <Kruppe> jmcarthur: shouldn't have to 'tail' the result to get something useful
12:13:33 <jmcarthur> agreed
12:13:44 <jmcarthur> worthy of a bug report i guess
12:14:40 <Kruppe> jmcarthur: where do I do that
12:15:34 <jmcarthur> Kruppe: let bos know, i guess
12:16:27 <ezyang> I'd kind of like to make "hoogle all of cabal" happen
12:16:29 <jmcarthur> this looks like a more serious problem than just Bools
12:16:39 <ezyang> but seeing that it's not been done yet, it might be a Hard(TM) problem
12:16:49 <jmcarthur> wordToBool i = (i .&. 1) /= 0
12:16:59 <jmcarthur> that's how the Bool instance works, basically
12:17:02 <dcoutts_> ezyang: no, I think it's just a matter of time/work not anything hard
12:17:22 <dcoutts_> ezyang: are you coming to the hackathon?
12:17:28 <jmcarthur> so that means withSystemRandom is giving numbers than end with 0 the first time uniform is used every time
12:17:31 <jmcarthur> *that end
12:17:32 <ezyang> dcoutts_: Which one?
12:17:43 <Kruppe> jmcarthur: hmm
12:17:44 <dcoutts_> ezyang: upcoming one in Zurich
12:18:34 <ezyang> dcoutts_: That's... good to hear. Maybe I'll chat with Neil to figure out what the scope of this would be.
12:18:40 <jmcarthur> rather, that it always generates even numbers the first time
12:18:48 <ezyang> Ahaha. Zurich is far away ;-)
12:19:04 <jmcarthur> hmm, but that appears not to be the case
12:19:11 <jmcarthur> maybe i read that wrong
12:19:37 <dcoutts_> ezyang: it's on my (long) todo list to integrate one of hayoo or hoogle with the new hackage server to serve as the primary search
12:19:59 <Kruppe> jmcarthur: well I'm emailing him all that stuff now, unless you want to :P
12:20:03 <ezyang> dcoutts_: Need a hand? ;-)
12:20:12 <dcoutts_> ezyang: yes! :-)
12:20:21 <Kruppe> jmcarthur: you seem to know more about whats wrong with it.
12:20:24 <ezyang> cool. Where should I start looking?
12:20:32 <dcoutts_> ezyang: since hayoo indexes haddock doc text too I'm leaning towards that, though perhaps we can have hoogle as a secondary search specifically for what it's good at: types
12:20:53 <jmcarthur> Kruppe: heh, not really
12:20:56 <dcoutts_> ezyang: and use hayoo to replace the current general google search we've got on hackage
12:20:56 <ezyang> Type-search is the killer feature for me, personally
12:20:57 <jmcarthur> i'm just guessing (wrongly)
12:21:04 <Kruppe> jmcarthur: lol
12:21:07 <ezyang> but hayoo certainly isn't bad for package search
12:21:19 <ezyang> or if you're staring at some symbol in an hs file and want to know where it came from
12:21:55 <dcoutts_> ezyang: it's certainly useful, but for searching for packages and helping people answer the "what package would help me to X" question, my intuition is that hayoo is the better fit
12:22:01 <jmcarthur> Kruppe: it could just be that the system seed is not very good
12:22:15 <ezyang> dcoutts_: No, that's probably true.
12:22:20 <Kruppe> jmcarthur: yeah could be.
12:22:20 <dcoutts_> ezyang: so there's two parts, the hoogle side and the hackage server side
12:22:21 <ezyang> Ooh, and Hayoo already searches all of Hackage
12:22:29 <ezyang> ok
12:23:00 <dcoutts_> ezyang: right, but we'd want to itegrate it more tightly, to make index updates more synchronous and incremental, whenever new packages are uploaded.
12:23:02 <Kruppe> jmcarthur: right now im just generating a Double and > 0.5 True, else false for now
12:23:19 <Kruppe> jmcarthur: since I only need them one at a time
12:23:29 <dcoutts_> ezyang: and ideally make search the primary web interface for hackage, and have the big list of package names be something secondary
12:24:13 <ezyang> *nod*
12:24:27 <dcoutts_> ezyang: we'd want to do the same thing with hoogle, make the index updates properly integrated, server using hoogle as a library with persistent cached state
12:24:58 <dcoutts_> ezyang: see the new hackage-server impl, it's all in Haskell (happstack)
12:25:11 <dcoutts_> that's the integration target
12:25:57 <ezyang> how difficult is it to setup your own hackage server?
12:26:10 * ezyang is all about local development environments 
12:26:16 <dcoutts_> ezyang: easy, darcs get it, compile and run
12:26:50 <dcoutts_> ezyang: darcs get http://code.haskell.org/hackage-server/
12:27:28 <ezyang> cool. Doing so now
12:27:38 <ksf> did anyone of you by any chance write a glsl ast and is keeping it for himself?
12:28:01 <ezyang> " Could not find module `Paths_hackage_server'"?
12:29:19 <nus> dcoutts_, any plans/thoughts on making ghc-pkg and a "core" cabal same thing?
12:29:26 * ksf wonders whether he can just abuse the language.C ast
12:29:52 <dcoutts_> ezyang: build it using cabal, it's got loads of deps
12:29:59 <dcoutts_> nus: what do you mean exactly?
12:30:07 <ezyang> ok
12:30:34 <osaunders> AST = Abstract syntax tree?
12:30:39 <ksf> yep
12:30:41 * ezyang hopes he doesn't nuke his cabal install again 
12:31:06 <ksf> gpipe just appends strings, and it's driving me nuts.
12:31:20 <jmcarthur> ksf: are you serious?
12:31:24 <jmcarthur> :(
12:31:27 <nus> dcoutts_, been pondering of a 'fusion' of cabal-install and ghc-pkg, their usecases seem to overlap
12:31:51 <jmcarthur> ksf: conal might have one. i'm not sure
12:32:04 <jmcarthur> but i don't think he's ready to publish it
12:32:05 <dcoutts_> nus: tell me more, what do you imagine that does? how is it better/worse?
12:32:25 <ksf> I thought conal did cuda
12:32:37 <jmcarthur> i thought it was glsl. maybe i'm wrong
12:32:39 <nus> dcoutts_, no two userland tools, same codebase
12:32:40 <roconnor> nus: does it involve being able to uninstall packages? :D
12:33:16 <nus> roconnor, you could always make some 'base' packages marked as uninstallable, otherwise yes.
12:33:22 <Alpounet> that'd be neat !
12:33:26 <dcoutts_> nus: would we achieve mostly the same result if in practise you didn't need to use ghc-pkg much as an end user?
12:33:28 <ksf> ...but looking at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23181#a23181 , I don't really see anything that wouldn't parse as C
12:33:47 <dcoutts_> nus: ie if cabal wrapped all the major things you currently use ghc-pkg for, like uninstall.
12:34:32 <Heffalump> cabal should be cross-compiler, ghc-pkg obviously isn't
12:35:59 <Twey> Hence wrapping?
12:36:11 <roconnor> nus: :D!!
12:37:52 <drhodes> is it possible for imperative code be pulled back into functional style? some magical analysis takes place and accounts for all mutations..
12:38:27 <burp> kind of trash recycling?
12:38:31 <ezyang> I believe that there tends to be an explosion of possible states
12:38:31 <drhodes> imperative code, like a C program with lots of Globals, or python.
12:38:35 <ezyang> let me find the paper
12:38:43 <twink> drhodes: State monad.
12:38:53 <drhodes> recycling, that's a great name fit
12:39:09 <dobblego> drhodes, if it were systematically simple, then the case for functional programming would be significantly weakened
12:39:13 <ksf> ...I should stop guessing and just try to parse some shaders with language.c
12:39:50 <drhodes> dobblego: I don't think it would be simple , at all! hehe
12:40:24 <ezyang> drhodes: http://pdos.csail.mit.edu/6.828/2009/readings/klee.pdf
12:40:34 <drhodes> or is "systematically simple" a compiler speak for "humanly conveivable?"
12:40:43 <drhodes> ezyang: thanks!
12:41:04 <ezyang> It's a neat paper in its own right.
12:41:12 <ezyang> And I suspect what you propose is feasible for small programs
12:42:33 <ezyang> dcoutts_: Still downloading deps :-)
12:45:40 * hackagebot SizeCompare 0.1 - Fast size comparison for standard containers.  http://hackage.haskell.org/package/SizeCompare-0.1 (BramSchuur)
12:47:12 <ksf> gnnnargh the language.C ast doesn't include cpp statements.
12:47:52 <MadHatterDude> kfs: which in particular?
12:48:04 <dcoutts_> ksf: it assumes you cpp first. I don't think you can really combine cpp and C in a single AST since the cpp operates at the token level.
12:48:21 <zygoloid> > nub $ "nub shows us how. 'a', 'b' and so on, banned when we've seen one. bu.. oh no. nub is unusable. slow!"
12:48:22 <lambdabot>   "nub show.'a,devil!"
12:49:11 <MadHatterDude> Why is it that reads :: String -> [(a, String)] when the result is only ever a single element list?
12:49:18 <twink> safe_add() is funny.
12:49:50 <MaciejP> ksf: Have a look at http://www.opengl.org/registry/doc/GLSLangSpec.1.50.09.pdf section 4.3.4 and following, I think this won't work in C.
12:50:05 <ezyang> dcoutts_: Blah cabal: At least the following dependencies are missing: rss ==3000.0.*
12:51:13 <twink> MadHatterDude: Vague substitute for Maybe, maybe ambiguous parses are possible but never returned by implementations.
12:51:29 <dcoutts_> ezyang: dunno what's going on, but you could try installing it
12:51:29 <zygoloid> in principle reads can return more than one result
12:51:57 <ezyang> "No packages to be installed."
12:52:03 <ezyang> I bet it's a dep thing
12:52:21 <ksf> MaciejP, language.c allows typedefs as storage specs
12:52:42 <ksf> er wait
12:53:44 <ezyang> aha, network dep wasn't up to date
12:55:28 <zygoloid> > reads "0o18" :: [(Integer, String)]
12:55:30 <lambdabot>   [(1,"8")]
12:55:31 <zygoloid> :o
12:56:09 <roconnor> > reads "0x18" :: [(Integer, String)]
12:56:10 <lambdabot>   [(24,"")]
12:56:27 <roconnor> > reads "0x1G" :: [(Integer, String)]
12:56:28 <lambdabot>   [(1,"G")]
12:56:33 <zygoloid> > reads "0xabcdefghijklm" :: [(Integer, String)]
12:56:34 <lambdabot>   [(11259375,"ghijklm")]
12:56:40 <zygoloid> > reads "0xghijklm" :: [(Integer, String)]
12:56:41 <lambdabot>   [(0,"xghijklm")]
12:56:48 <zygoloid> !!
12:56:48 <roconnor> oh wow
12:56:55 <roconnor> > reads "0x" :: [(Integer, String)]
12:56:56 <lambdabot>   [(0,"x")]
12:56:59 <zygoloid> oh, duh
12:57:02 <roconnor> ah
12:57:04 <roconnor> heh
12:57:15 <roconnor> > reads "0x0" :: [(Integer, String)]
12:57:16 <lambdabot>   [(0,"")]
12:57:24 <roconnor> reading know how to multiply!!!
12:57:48 <zygoloid> > reads "-(0x123)+1" :: [(Integer, String)]
12:57:49 <lambdabot>   [(-291,"+1")]
12:59:10 * MadHatterDude is away: autoaway [l(on) p(on)]
13:00:15 <copumpkin> ugh
13:00:20 <copumpkin> no autoaway messages please
13:00:43 <zygoloid> > reads (concat (replicate 1000 "-(") ++ "123" ++ replicate 1000 ')') :: [(Integer, String)]
13:00:44 <lambdabot>   [(123,"")]
13:00:50 <zygoloid> roconnor: it knows how to multiply by -1 at least
13:01:52 <Twey> > 0o12
13:01:53 <lambdabot>   10
13:01:54 <Twey> Huh
13:01:57 <Twey> > 012
13:01:58 <lambdabot>   12
13:02:04 <Twey> Never knew that
13:02:52 <MadHatterDude> copumpkin: I sadly don't know how to turn it off...
13:03:18 <osaunders> > 0o12
13:03:19 <lambdabot>   10
13:03:26 <osaunders> > 0o127
13:03:27 <lambdabot>   87
13:03:31 <osaunders> > 0o10
13:03:32 <lambdabot>   8
13:03:39 <burp> > 0x8
13:03:39 <osaunders> > 0x10
13:03:40 <lambdabot>   8
13:03:41 <lambdabot>   16
13:03:42 <burp> > 0o8
13:03:43 <lambdabot>   Not in scope: `o8'
13:04:42 <MadHatterDude> Hey, guys. Is it normal for a fully workable language to have only six reserved words and two reserved operators?
13:04:52 <zygoloid> MadHatterDude: http://www.dev0.de/pix/0irc1232options4.png <-- looks like there's a checkbox there
13:04:52 <Zao> See LISP?
13:05:09 <zygoloid> MadHatterDude: or Tcl? :)
13:05:30 <MadHatterDude> Zao, Zygoid: Mine is more similar to J
13:05:50 <MadHatterDude> But with a touch of haskell
13:05:53 <MadHatterDude> :P
13:06:02 <MadHatterDude> At least in spirit
13:08:20 <ezyang> More problems... This package indirectly depends on multiple versions of the same package.
13:09:01 <Polarina> Is there a function that would take in for example [1,2,3] and return [[1],[1,2],[1,2,3],[2,3],[3]]?
13:10:09 <twink> Polarina: \xs -> tail (inits xs) ++ drop 2 (tails xs) ?
13:10:48 <MadHatterDude> twink: I think Polarina means something like the carthesian product of the list itself?
13:11:20 <MadHatterDude> twink: f [1,2,3,4] -> [[1],[2],[3],[4],[1,2]...]
13:11:28 <sinelaw> hey, i wrote a short something about FRP
13:11:30 <sinelaw> http://www.ee.bgu.ac.il/~noamle/_downloads/gaccum.pdf
13:11:35 <sinelaw> i'd love to hear comments
13:12:08 <twink> > let xs = [1,2,3,4] in tail (init (inits xs)) ++ init (tails xs)
13:12:09 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[2,3,4],[3,4],[4]]
13:14:57 <Polarina> Thanks.
13:15:00 <ezyang> bah, I wish cabal was clever enough to know when it could setup lower build dependencies
13:15:20 <dcoutts_> ezyang: me too :-)
13:15:25 <dcoutts_> ezyang: what's that example?
13:15:28 <copumpkin> twink: I have another way of doing that
13:15:45 <twink> copumpkin: let f xs = tail (inits xs) ++ drop 1 (init (tails xs)) ?
13:16:07 <ezyang> right now, hackage-server thinks it wants network-2.2.1.7, but some other libraries must have network-2.2.1.4
13:16:27 <ezyang> rss-3000.0.1 also thinks it wants the newer version of network
13:16:33 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..]
13:16:34 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
13:16:45 <copumpkin> not terribly efficient though
13:17:00 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..3]
13:17:01 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3]]
13:17:13 <copumpkin> oh, Polarina didn't want [2]
13:17:29 <seanmcl> Hi.  To clean up my code, I could really use a tool that would tell me which of my module exports are not being used anywhere else in a given program.  Does such a thing exist?
13:17:32 <ezyang> shouldn'a installed the latest version of network...
13:18:01 <sinelaw> seanmcl, compile with -Wall
13:18:03 <sinelaw> and use hlint
13:18:23 <seanmcl> sinelaw:  I use -Wall.  hlint will do this for me?
13:18:26 <sinelaw> seanmcl, but actually i don't know about the specific thing you're looking for
13:18:30 <ToRA> or -ddump-minimal-imports can also be helpful (iirc)
13:18:50 <ToRA> ah, though that's more for unnecesary imports
13:19:36 <seanmcl> ToRA: still, that's a nice thing I didn't know about.  Thanks
13:23:23 <ezyang> HIKE! We have configuration success!
13:23:30 <ezyang> hooray for judicious use of --constraint
13:26:24 <ezyang> dcoutts_: should I install or run out of dist?
13:26:46 <dcoutts_> ezyang: whichever you prefer, works both ways
13:27:04 <dcoutts_> ezyang: if you do it locally you need to pass a flag to say where the static files are
13:27:15 <dcoutts_> it tells you so if you forget
13:27:44 <ezyang> yeah, I noticed :-)
13:27:55 <ezyang> ok, installing seems to be a low cost operation, so I'll do that
13:29:04 <ezyang> erm, "low cost"
13:30:43 <MadHatterDude> When you have guards in a function, does a where span all clauses?
13:30:56 <cheater2> yes
13:31:25 <maltem> but not all equations, if you have several
13:31:50 <ezyang> oh man, it's hackage! whoo
13:32:07 <ezyang> with no packages, but not going to let that rain on the party ;-)
13:32:53 * ksf wants to read some new blog posts from conal
13:33:59 <ezyang> time to get the Hayoo source, I suppose
13:36:22 <ezyang> hmm, I can't find the Hayoo code
13:38:32 <ezyang> ah, it lives in Holombus
13:47:22 <sinelaw> ksf, there aren't any new blog posts
13:47:39 <sinelaw> ksf, BUT you can read what I wrote, if you like: http://www.ee.bgu.ac.il/~noamle/_downloads/gaccum.pdf
13:47:58 <sinelaw> it's related to some things conal was writing about recently
13:48:52 * sinelaw has quit
13:49:38 * Heffalump spots hellage
13:49:51 <Daerim> Anyone got any experience with compiling gtk2hs under ghc 6.12? Their homepage claims it can be done, but it is depending on glib, which does not compile under 6.12
13:52:22 <thoughtpolice> Daerim: do you have the darcs version of gtk2hs?
13:52:29 <thoughtpolice> i've heard reports of it working correctly
13:52:40 <conal> ksf: i'd like to write some more blog posts soon.  have a few topics cooking.
13:53:02 <Daerim> thoughtpolice, darcs version of gtk2hs. configure fails when trying to find glib
13:57:56 <MadHatterDude> Everybody who loves unfoldr raise your hands!
13:57:59 <MadHatterDude> *raises hand*
13:58:24 * BONUS raise
13:58:29 <domor> let's say I have some function in the random monad, "fn = do x <- getRandom; return $ x > (10 :: Int)". I'd like to do a list comprehension like [ a | a <- [True,False], a == fn], but of course this doesn't compile. any hints?
13:58:52 <Cale> unfoldr is conceptually nice, but often awkward to use. I often prefer something along the lines of map f . takeWhile p . iterate g
13:59:01 <domor> (fn would be called several times, so I can't "do x <- fn; return $ [...] )
13:59:29 <Cale> domor: That says that a is the same action as fn
13:59:47 <Cale> (which of course it couldn't possibly be, since a is a Bool)
14:00:45 <Cale> I don't understand the purpose of that list comprehension anyway.
14:01:07 <pheaver> what would you name a cabal package that provides n-arity functors (Functor2, Functor3, Functor4, etc.), as well as Traversable2, Traversable3, Traversable4, etc.?
14:01:07 <MadHatterDude> Cale: How exactly does map f . takeWhile p . iterate g work?
14:01:21 <domor> Cale: the actual code is goldbach n = listToMaybe [ a | a <- [1..], rabmil a ], where rabmil is in random
14:01:31 <pheaver> (it's like the one thing holding me back from trying to release it!)
14:01:35 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 573892
14:01:36 <lambdabot>   [2,9,8,3,7,5]
14:01:41 <philo> hi
14:02:01 <Prig> why can't two datas have records with the same name?
14:02:05 <philo> is there any difference between cabal and ghc-pkg ?
14:02:14 <Cale> Prig: Because the field names are not just names
14:02:18 <pheaver> Prig: for the same reason you can't define too functions with the same name, it would be ambiguous
14:02:20 <Prig> right, they're functions
14:02:21 <Cale> Prig: They're also the names of functions
14:02:23 <Prig> this is where I give up on Haskell
14:02:27 <Axman6> ghc-pkg doesn't install packages does it?
14:02:30 <Cale> Prig: ?
14:02:37 <pheaver> (it's of course possible, if they're in different modules and you qualify the names)
14:02:46 <Cale> Prig: Records are not used to control the namespace. Modules are.
14:02:56 <pheaver> yeah what Cale said :)
14:03:21 <Prig> Well I was having fun and just moving along smoothly but I realize if you cant even have two field names that dont conflict then Haskell really is some kind of extremist language that's not even reasonable
14:03:36 <philo> is there any difference between cabal and ghc-pkg ?
14:03:38 <dancor> Prig: try putting each data type in a different module
14:03:39 <Prig> too frustrating
14:03:39 <Cale> Prig: Why? I've never even run into a case where I wanted to do that.
14:03:40 <domor> hmm, I'll try doing it with mapM. I was curious about doing it in a comprehension
14:03:40 <pheaver> Prig: it may seem that way, yeah
14:03:42 <dcoutts_> philo: they're rather different layers of the system
14:03:47 <Prig> dancor I dont want them in different modules
14:03:53 <Prig> i am writing types right next to eachother
14:03:54 <pheaver> Prig: but i think that's cause you're just used to be able to do that in C, where records *do* control namespaces
14:03:56 <BONUS> Prig: it's a little wart in Haskell, but really it's not that big of a deal
14:03:56 <Cale> Prig: Just name the fields differently.
14:04:04 <Cale> I don't consider it a wart.
14:04:15 <philo> dcoutts_:  so wich one i use to install package ?
14:04:16 <Cale> I think it's totally appropriate.
14:04:18 <dancor> Prig: i also often put the data type (or an abbr) as a prefix
14:04:23 <BONUS> well i mean i'd like better selectors
14:04:24 <pheaver> Prig: i know it does seem ridiculous at first
14:04:27 <Cale> Well, yes
14:04:29 <pheaver> Prig: to someone new to Haskell
14:04:32 <Prig> you have to put the data type in front of every field name.... come on
14:04:38 <dancor> data Lol = Lol {lolInt :: Int, lolString :: String}
14:04:38 <Cale> It would be better if the field names referred to lens-like structures
14:04:39 <benmachine> selectors aren't so bad, it's update that bothers me
14:04:41 <Prig> thats not reasonable
14:04:44 <Heffalump> I abbreviate it
14:04:51 <Cale> Prig: Sure it is. It works fine.
14:04:58 <Prig> forget it, i give up
14:05:00 <dcoutts_> philo: cabal
14:05:09 <pheaver> Prig: i'm sorry to hear that
14:05:14 <tavelram> Ive got a type BowlOfFruit, that can contains any number of apples and oranges. Ive got a function apple that creates a singleton bowl containing an apple. and ive got a bunch of functions that operate only on bowls. What is that called? isomorphic?
14:05:24 <Cale> Prig: You might be factoring your types incorrectly.
14:05:27 <BONUS> it really is a weird thing to get hung up on, imo
14:05:32 <dancor> Prig: i mean (print $ lolInt myLol) would be like (print $ Lol.getInt myLol)
14:05:35 <philo> but  i cant seems to find a cabal package for ubuntu
14:05:48 <Cale> Prig: If you have a bunch of record types with a bunch of fields in common, you might try factoring that set of fields out into its own type.
14:06:01 <Axman6> Prig: what's the problem?
14:06:36 <dancor> "print $ lolInt myLol" vs "print myLol.getInt"
14:06:41 <tavelram> ie the fact that i can mix bowls and ONE "apple", since the apple is under the hood a singleton list.
14:06:42 <Cale> Axman6: He's annoyed that multiple record types which are in the same module can't share field names.
14:06:43 <pheaver> Prig: you do have many options for dealing with this problem.  unfortunately you can't do exactly what you want to do (have two records with the same field names in the same module), but i think there are many perfectly reasonably ways around this
14:06:53 <Zao> Cale: That _is_ annoying,.
14:06:53 <dancor> it's true there are two "lol"s in the haskell one
14:06:59 <Cale> Zao: I disagree.
14:07:26 <Cale> If we allowed them to have the same name, then what would their types look like?
14:07:27 <Zao> It feels like I'm coding C when I have to prefix everything.
14:07:31 <pheaver> well, fortunately, whether you think it's reasonable or not doesn't matter, cause it is the way it is.  productive would be to find out how to deal with it :)
14:07:31 <Cale> Some sort of union type?
14:07:31 <Prig> my haskell experiment was interesting, this is where I try Ocaml now
14:07:35 <Zao> Cale: Magical.
14:07:44 <BONUS> Cale: haskell could generate a typeclass for every field selector
14:07:55 <Cale> Zao: That would be much worse.
14:07:58 <pheaver> hmm... sorry, that sounded mean now that i read it back to myself
14:08:06 <Cale> I don't want field selectors to be magical.
14:08:08 <benmachine> BONUS: my response to that proposal is, eeeek
14:08:18 <Zao> Cale: I'm just saying, it's bloody annoying, coming from a sane OO world.
14:08:30 <nlogax> tavelram: does this mean you have the ability to compare apples to oranges, as long as they are in a bowl? :)
14:08:30 <BONUS> benmachine: well, you see ... actually yeah that would be kind of hackish and ugh
14:08:34 <Cale> BONUS: That's theoretically possible, but the details seem awkward.
14:08:35 <Zao> Prefixing everything constantly makes me feel like I'm coding C.
14:08:37 <Prig> its annoying enough to not use the language PERIOD
14:08:40 <dancor> Zao: would it be less annoying if you could have multiple modules in one file
14:08:41 <Zao> And that makes me a sad panda.
14:08:45 <Prig> deal breaker
14:08:57 <Cale> Prig: What are you planning to do?
14:09:01 <benmachine> Zao: in OO you prefix everything with object. :P
14:09:15 <Cale> Prig: Perhaps the way in which you're using types is inappropriate to begin with?
14:09:15 <pheaver> Prig: do you know you don't have to use the field names at all?
14:09:17 <Zao> benmachine: In such a world, you've got lot of implicitness.
14:09:22 <BONUS> Zao: a sane OO world, hmmm, contradiction in terms? :)
14:09:28 <Prig> Cale: i just want a good language thats not "totally fucking weird annoying thing in one of the core functionalities"
14:09:28 <benmachine> heh I thought that too
14:09:39 <Cale> Prig: That's very subjective.
14:09:43 <Zao> {-# DoWhatIMeanCorrectly #-}
14:09:48 <pheaver> haha
14:09:49 <benmachine> Prig: good luck with that, I've not found one yet >_>
14:09:55 <Zao> *LANGUAGE
14:10:06 <BONUS> Prig: you seem to be hung up on details that aren't so important
14:10:07 <dancor> Zao: don't worry it's self-correcting
14:10:12 <BONUS> bikeshedding, basically
14:10:14 <Zao> I keep forgetting the syntax for such pragmas, as I use the menus in vim to insert them :)
14:10:16 <Cale> There are quite a handful of warts in Haskell, but I don't think this one is particularly a problem.
14:10:17 <Zao> dancor: :)
14:10:34 <pheaver> Prig: if you are looking for a way around the problem, i would like to offer suggestions....
14:10:38 <Axman6> Prig: yeah, i har you, i think C having pointers is completely fucking weird, they should remove them
14:10:41 <Axman6> hear
14:10:42 <Cale> If it helps, don't think of them as field names. Think of it as merely a convenient syntax for writing functions to extract those fields.
14:10:46 <Prig> l8z.. someone hit me up some day when haskell can have 2 fields of the same name
14:11:00 <pheaver> haha wow
14:11:01 <dancor> haha
14:11:04 <BONUS> Cale: actually yeah, thinking more about it, i can't recall when i ever had conflicting names
14:11:06 <Axman6> pathetic
14:11:06 <pheaver> i don't think he wanted to hear anything
14:11:11 <BONUS> for fields
14:11:13 <twink> Isn't that already an extension?
14:11:19 <dancor> i'll get started on the patch immediately
14:11:36 <Cale> BONUS: Yes, I've never ever run into a situation where it's been a serious problem.
14:11:36 <blackh> Zao, Prig: The field naming thing is not perfect, but there are two things: One is that nobody has managed to come up with a solution that doesn't mess up the overall elegance of the language, and the other is that the problem has never been annoying enough.
14:11:50 <BONUS> i retract my previous statements :)
14:12:22 <Axman6> BONUS: i showed lyah to a few students in a haskell tute i'm running, and they quite liked it :)
14:12:27 <Cale> However, I do think it would be nice for Haskell to have a syntax for row types.
14:12:32 <BONUS> Axman6: oh cool :) say hi to them!
14:12:38 <Axman6> will do :)
14:12:55 <Axman6> sadly i don't get to see them until a fortnight from now :(
14:12:56 <Cale> It does annoy me that people seem to like this inane syntax stolen from OO languages which overloads the '.' symbol even more though.
14:13:02 <Axman6> damn public holidays
14:13:04 <BONUS> phone them up in the middle of the night
14:13:07 <Axman6> stealing my pay!
14:13:09 <dancor> i think a preprocessor for multiple modules in one file basically gives Priggites what they want
14:13:11 <Axman6> ha
14:13:36 <dancor> or each data type could implicitly create a module
14:13:49 <BONUS> ugh
14:13:51 <Axman6> Cale: yeah, i get annoyed when people overload the . symbol by making it fmap
14:13:52 <Saizan> maybe record syntax is just what we need to avoid success enough :)
14:13:52 <Axman6> >_>
14:14:03 <FunctorSalad> hmm... it's nice that handles use encodings now, but now everything that uses handles needs to upgrade its interface to allow binary mode
14:14:07 <BONUS> Saizan: haha, that just might be the ticket
14:14:08 <Cale> Axman6: I'm not annoyed by the generalisations of (.)
14:14:16 <Axman6> i am :P
14:14:23 <Cale> Axman6: But I am annoyed by using it for things which are not technically related to composition.
14:14:24 <FunctorSalad> because utf8-mode will crash for illegal multibytes
14:14:25 <centrinia> dancor: Be careful. If this preprocessor is allowed to grow then it might mutate into the full fledged object oriented programming language Haskell++.
14:14:29 <Cale> Axman6: Like module selection.
14:14:36 <tavelram> nlogax, well, if you compared a singleton apple to a bowl of oranges, ie for equality, it would yield false. There are "union" functions that work as expected. I guess you should see the apples and oranges as unrelated though, perhaps you should see them as apples and forks. :p
14:14:47 <FunctorSalad> (and utf8-mode for handles is the default if it's that way in your locale)
14:14:49 <benmachine> Cale: what would you suggest for module selection?
14:14:50 <blackh> BONUS: http://learnyouahaskell.com/recursion underscores are missing in zip' example
14:14:50 <dancor> centrinia: O, the haskell!
14:15:04 <Cale> benmachine: I tend to think that | looks nice for that.
14:15:07 <blackh> BONUS: I don't need to learn Haskell but I have been reading LYAH just for fun!
14:15:15 <FunctorSalad> e.g., readProcess will not work anymore for binary data
14:15:17 <BONUS> blackh: cool :D
14:15:24 <BONUS> blackh: which browser/OS are you running?
14:15:34 <BONUS> i see the underscores but i've gotten quite a few complaints about them not being visible
14:15:37 <benmachine> Cale: interesting, would that be ambiguous with the current uses of | though?
14:15:44 <blackh> BONUS: Firefox 3.5.8 on Ubuntu 9.10
14:15:47 <Cale> benmachine: A little, but not really.
14:15:48 <BONUS> one of these days i'll have to fix that
14:16:01 <Cale> benmachine: Because people tend to put spaces around their guards anyway.
14:16:10 <benmachine> mm I suppose so
14:16:18 <dancor> the best part about Prig's demand is that it is has nothing to say about what to do about the resulting ambiguous functions
14:16:20 <lament> Haskell|Is|Confusing
14:16:35 <benmachine> dancor: no, the best part about it is that it's gone :P
14:17:46 <dancor> aw
14:18:09 <Cale> benmachine: It's also quite plausible that stealing ' in module names for this use wouldn't be too bad.
14:18:17 <Cale> There are not many modules which have ' in their names.
14:18:22 <FunctorSalad> hmm the pipe looks very seperating. don't we want something as invisible as possible?
14:18:25 <benmachine> hmm
14:18:32 <FunctorSalad> (it binds tightest)
14:18:45 <Cale> FunctorSalad: It doesn't look separating enough to me.
14:18:51 <FunctorSalad> *separate
14:19:05 <benmachine> but if you want qualified modules, you'd presumably also have to disallow ' in constructors
14:19:07 <Cale> (given that we wouldn't allow spaces around it)
14:19:11 <ivanm> yay, I've got a situation where I've got two data types that mutually recurse on one another, but I wanted to put one of them into a seperate module (because it's part of a much larger grouping of types that I wanted to split off) :s
14:19:17 <FunctorSalad> well, disjunction usually has near-lowest priority :)
14:19:24 <benmachine> admittedly not many constructors have ' in them either
14:19:28 <Cale> benmachine: The existing syntax is already ambiguous in that regard.
14:19:34 <Axman6> ivanm: ur doin it rong
14:19:36 <FunctorSalad> (but I'm overdoing the bikeshedding there)
14:19:39 <Zao> benmachine: I have lots of them, from bindings-DSL.
14:19:40 <ivanm> Axman6: :o
14:19:42 <ivanm> in what sense?
14:19:47 <benmachine> oh
14:19:53 <benmachine> Cale: is it?
14:20:00 <Axman6> well, i did it once, so it mustn't be too wrong :P
14:20:03 <Cale> Data|List|permutations  -- typographically it looks all nicely glued together :)
14:20:12 <FunctorSalad> must be the font
14:20:21 <blackh> BONUS: The underscore in head' on syntax-in-functions does work. Must be some Javascript weirdness.  Anyway, I really like LYAH, especially Mr. Pattern Matching.
14:20:24 <dancor> Axman6: bc you would have done it much more than once if it was?
14:20:33 <ivanm> Axman6: hmmm?
14:20:34 <Cale> benmachine: You can create things where the spacing around the dots is important to tell between module selection and composition with constructors.
14:20:43 <benmachine> oh, yes
14:20:59 <benmachine> but that can be resolved with whitespace without restricting naming
14:21:10 <BONUS> blackh: yeah, it's a weird problem. i think it has something to do with the line-height css property. hehe thanks :) there haven't been many new updates because i'm working on publishing it as a real book. but the new chapters are on their way
14:21:14 <Cale> FunctorSalad: I think it would with any monospace font.
14:21:45 <Cale> Because there's nothing close to a full space between the letter on the left and right of the |
14:21:52 <FunctorSalad> hmm I don't irc in monospace :)
14:21:55 <Zao> benmachine: http://zao.se/~zao/doc/html/bindings-directx/FFI-DirectX-Direct3D9.html
14:22:11 <benmachine> Zao: mm
14:22:25 <Zao> Or a real world example - http://hackage.haskell.org/packages/archive/bindings-libusb/1.4.2/doc/html/Bindings-Libusb-Asynchronous.html
14:23:30 <benmachine> so Bindings'Libusb'Asynchronous'C'libusb_control_setup would be irretrievably ambiguous
14:23:40 <Zao> *shudder*
14:24:05 <benmachine> (as in, there are two equally valid parses and both could potentially refer to valid objects which couldn't otherwise be named)
14:24:16 <twink> Is '#' used for anything?
14:24:22 <Zao> twink: Depends.
14:24:28 <Zao> If MagicHash is on, it is.
14:24:37 <copumpkin> it's used in names
14:24:40 <Cale> # is almost the only symbol character not stolen by the Prelude for an operator
14:24:41 <copumpkin> otherwise it's a valid operator character
14:24:46 <twink> Oh well. So much for unused plain ASCII.
14:24:46 <copumpkin> how about ?
14:24:50 <copumpkin> I guess that's punctuation
14:25:23 <Cale> Oh, yeah, ? as well
14:25:41 <copumpkin> > let (????????) = (+) in 5 ???????? 7
14:25:42 <lambdabot>   12
14:25:45 <Cale> and there's ! but that's taken by the Array library
14:25:48 <FunctorSalad> Cale: how about "hPut@Data.ByteString"?
14:25:57 <FunctorSalad> seems better that way (important part first)
14:25:59 <benmachine> woah backwards
14:26:11 <FunctorSalad> and you have the analogy to how it's in email ;)
14:26:21 <dancor> lol
14:26:40 <FunctorSalad> could be ambiguous with view patterns I guess
14:26:53 <FunctorSalad> otherwise @ is free, isn't it?
14:27:03 <Cale> @ is used in the syntax of patterns
14:27:04 <benmachine> as-patterns
14:27:12 <Zao> foo@(Bar baz)
14:27:20 <Cale> > let xxs@(x:xs) = [1,2,3] in (xxs,x,xs)
14:27:21 <lambdabot>   ([1,2,3],1,[2,3])
14:27:31 <FunctorSalad> yes. but identifiers only appear in patterns with view patterns, at first glance
14:27:46 <Cale> Not view patterns
14:27:49 <FunctorSalad> ok, and constructors
14:27:57 <benmachine> constructors look like modules
14:28:21 <FunctorSalad> I know @ itself isn't about view patterns :)
14:28:29 <benmachine> couldn't we just make modules something like giant records
14:28:34 <FunctorSalad> I was just thinking where module-qualified things appear in patterns
14:28:53 <Alpounet> benmachine, like OCaml modules ?
14:29:00 <benmachine> Alpounet: never used OCaml
14:29:14 <Cale> benmachine: That's a good idea, except that modules allow for declaring things other than values
14:29:22 <Cale> So it's a little strange
14:29:40 <benmachine> true
14:29:47 <benmachine> can't have a function return a constructor
14:29:49 <benmachine> (yet :P)
14:33:06 <FunctorSalad> I'd still say that a character that only appears in patterns is pretty underworked for haskell standards ;)
14:33:47 <BONUS> i've always been surprised by how little used ? is
14:34:52 <FunctorSalad> implicit params ;)
14:34:59 <FunctorSalad> and <?> in parsec...
14:35:00 <BONUS> yeah, and that's about it
14:35:13 <FunctorSalad> (and some weird internal kinds)
14:35:14 <BONUS> and those are a lame extension anyway
14:35:15 <Taejo> Didn't Minkowski have a question mark function?
14:35:48 <Alpounet> hu ?
14:36:08 <FunctorSalad> BONUS: implicit params rock for debugging type errors, though
14:36:24 <BONUS> ya? how so
14:36:28 <FunctorSalad> replace the questionable part with ?hu and it will print what type it's expecting there
14:37:14 <FunctorSalad> > fmap fmap ?f 1
14:37:15 <lambdabot>   Unbound implicit parameter (?f::t -> a -> b)
14:37:16 <lambdabot>    arising from a use of impli...
14:37:19 <BONUS> ooh i didn't know that. in which module is that?
14:37:22 <FunctorSalad> @type fmap fmap ?f 1
14:37:24 <lambdabot> forall a b (f :: * -> *) t. (Functor f, ?f::t -> a -> b, Num t) => f a -> f b
14:37:32 <BONUS> oh it doesn't have to be ?hu it can be ?anything
14:37:34 <FunctorSalad> you can use any identifier :) I just copied Alpounet
14:38:14 <BONUS> you learn something new everyday
14:38:32 <pheaver> http://hackage.haskell.org/packages/archive/utility-ht/0.0.5.1/doc/html/Data-Bool-HT.html
14:38:41 <pheaver> defines (?:) heh
14:42:26 * ksf just realized that the perfect indicator for "this is a button" is underlying the text with a thumbprint.
14:42:50 <BONUS> how about underlying it with the text "this is a button"
14:43:10 <ksf> DAUs don't know what the word "button" means
14:43:25 <damd> what does it mean to underlie something?
14:43:47 <ksf> blend the text above it.
14:44:09 <ksf> i.e. gray thumbprint, black text, black rounded rectangle around it.
14:44:31 <BONUS> idk i usually find that it's best to make it 3D-ish, that's the usual idiom anyway, isn't it?
14:44:53 <ksf> 3d doesnt' fit visually with a lot of stuff
14:45:07 <ksf> ...look at various webpages, they override buttons to look non-3dish
14:45:21 <damd> the same problem exists with thumbprints
14:45:33 <ksf> also, I'm kind of fond of an xforms/tex look
14:48:01 <mq> BONUS: btw, I'm new to Haskell and I think Learn You A Haskell (well, at least the part of it that exists) is a good introduction. Really helped me understanding the basics, thanks :D
14:48:22 <BONUS> hey! :D very cool, glad you liked it
14:48:25 <BONUS> more will exist soon! hehe
14:48:47 <BONUS> keep on hacking!
14:50:00 <mq> I'm taking a look at Real World Haskell right now as the next step.
14:50:23 <mq> But I'll keep an eye on LYAH :)
14:51:04 <BONUS> RWH is an awesome book
14:51:57 <FunctorSalad> ksf: imho even a DAU should be expected to learn things on the level of what a button is... an inline manual would clutter the screen for everyone else
14:52:37 <mq> I tried to work through it before LYAH, but somehow didn't really get it and stopped after a few chapters. LYAH somehow gave me a better idea of the concepts.
14:52:37 <FunctorSalad> "What's this"-hints, on the other hand, are awesome
14:53:07 <BONUS> yeah, it often serves newbies good to get comfortable with haskell by reading LYAH before moving on to RWH
14:53:12 <FunctorSalad> KDE apps now let you send in "What's this" hints from the app :)
14:53:15 <BONUS> its a good one-two combo
14:53:19 <FunctorSalad> sorry OT
14:53:37 <mq> BONUS: yes, looks the same way to me. :D
14:58:48 <chrisdone> BONUS: BONUS!
14:59:05 <BONUS> chrisdone: enodsirhc
14:59:29 <chrisdone> SUNOB: haha from now you are now known as said nick
14:59:30 <BONUS> btw dude i love tryhaskell.org!
14:59:35 <BONUS> haha
15:00:36 <chrisdone> SUNOB: thanks! i was wondering when i first started writing it if you wanted to do something with the json api or maybe somehow integrate with lyah. actually originally i wanted you to write the tryhaskell tutorials and then i couldn't find you. if you want to...?
15:01:16 <chrisdone> depends if you have time and such. i'm just writing what i can fit in
15:01:17 <BONUS> there's an api? ooh cool, i might integrate it into my site
15:01:31 <BONUS> when i finish LYAH, i'd gladly help!
15:01:37 <chrisdone> nice one =)
15:01:59 <BONUS> but i fear people are going to kill me if i don't post the rest of LYAH soon!
15:02:00 <BONUS> haha
15:02:14 * ivanm won't
15:02:48 <chrisdone> yeah it has a simple json service: http://tryhaskell.org/haskell-eval.json?jsonrpc=2.0&method=eval&id=1&params={"expr":"4*3"}
15:02:48 <chrisdone> but i just picked jsonrpc because it had a spec to follow. i might just make it a simple restful thing instead
15:02:54 <chrisdone> BONUS: no problem ;)
15:03:25 <BONUS> oooh, a json api, that's a great idea. awesome
15:03:34 <chrisdone> :D
15:04:16 <benmachine> wikigwern :O
15:04:30 <BONUS> i can envision something like LYAH but the examples aren't static and each example allows you to try it out
15:04:45 <chrisdone> BONUS: yeah!!
15:04:58 <luite> it would help to be able to load extra .hs files for each chapter. is that already possible?
15:05:24 <BONUS> you mean like source files for the examples?
15:05:26 <chrisdone> BONUS: and exercises that say "give me an expression of type blah" or "give me a function that computes blah" (and then run smallcheck on it!!)
15:05:42 <luite> BONUS: yes, with the right data types and functions for the examples for that chapter
15:06:05 <BONUS> chrisdone: ooh, like quizes and exercises right there on the spot. there's so much that could be done with that
15:06:24 <chrisdone> yeah, that would save you having to copy and paste it all yourself (though is that taking away necessary practical experience? i have no idea-gives immediate feedback thogh)
15:06:31 <BONUS> luite: actually i can't figure out how i never thought of linking to .hs files before. definitely going on my TODO list
15:07:11 <byorgey> wow, in-tutorial interactive exercises sounds hot
15:07:17 <Axman6> aye
15:08:16 <BONUS> now i'm psyched for that. no, me, finish the rest of the chapters first! argh!
15:08:37 <chrisdone> i was hoping some of you guys might help come up with some good exercises that (1) are good for learning haskell (2) are simple enough to code in an editor in your browser after a bit of thinking (3) can be checked with smallcheck
15:08:38 <chrisdone> BONUS: hahaha
15:08:50 <nagnatron> tryhaskell.org is awesome, i just pasted the link to my friend and he just replied never
15:09:04 <chrisdone> haha
15:09:18 <nagnatron> it may be because i go on about it all the time
15:12:17 <FunctorSalad> what's the preferred way to process IO-using input in a streaming way? explicit chunks like with iteratee or so, or use hGetContents or similar and pretend things are pure?
15:12:31 <commanace> hey... is it somehow possible to automatically have ADT's that instanciate certain typeclasses beeing an instance of another typeclass? (ghc)
15:12:38 <gwern> I really despise ext3's lack of undeletion
15:13:01 <jcreigh> gwern: does any modern FS support undeletion?
15:13:16 <aavogt> isn't there a cow version?
15:13:19 <gwern> I suspect they don't go out of their way to zero things out like ext* does
15:13:34 <BONUS> commanace: it is with UndecidableInstances, but it isn't recommended
15:13:38 <Gracenotes> gwern: ooh, ext3 goes out of its way to 0 things? I like that.
15:13:56 <BONUS> cause it can be a whole can of pants
15:14:03 <gwern> gah. and of course /tmp would have to be on /'s partition. yeah, thanks for nothing ext3grep insisting on only working on unmounted partitions
15:14:17 <jcreigh> gwern: whoa, it zero things out? I'm not sure about that.
15:14:22 <aavogt> commanace: if you're defining these classes first-hand, make one the appropriate sub-class
15:14:43 <gwern> jcreigh: something about being able to safely resume unlinks after a crash
15:14:54 <Gracenotes> not the same as doing Guttman's method, of course, but if I could make ext3 do that automatically I would go for that
15:15:06 <jcreigh> gwern: huh, related to journaling then?
15:15:11 <gwern> jcreigh: apparently
15:15:12 <FunctorSalad> version-control anything important...
15:15:27 <gwern> FunctorSalad: I'm not going to version-control 3 gigs of pnm files I spent the last few hours scanning in
15:15:38 <FunctorSalad> (etckeeper in debian autorecords /etc whenever apt does something)
15:15:44 <aavogt> but doing that midway through your project means updating lots of instance declarations
15:15:48 <FunctorSalad> gwern: :)
15:16:12 <gwern> (I realized the deletion happened literally a second after it happened. I don't need to be able to undelete from hours ago, a few seconds would've been fine!)
15:16:50 <FunctorSalad> ok I agree in that case the lack of undeletion sucks
15:16:53 <commanace> BONUS: why isn't it recommended?
15:17:26 <aavogt> instance selection may not terminate
15:17:48 <BONUS> commanace: this blog post here describes your situation perfectly i think http://lukepalmer.wordpress.com/2008/04/08/stop-using-undecidable-instances/
15:18:14 <BONUS> the author makes every type that's an instance of Num also an instance of a new class
15:18:54 <FunctorSalad> hmm usually the problem isn't a computational power, it is that instance selection gets into loops quickly with undecidable-instances :)
15:19:15 <FunctorSalad> (enable that tracing option (don't remember which) to see the search)
15:23:14 <commanace> BONUS: ok thanks, so i will just add a few more typeclasses + instances
15:23:37 <BONUS> commanace: what are you trying to do, like, in general?
15:26:22 <commanace> BONUS: I've got the classes "ControllSystem", "ControllSystem => StateSpaceControl" and "ControllSystem => DigitalControl"... now if i know that a system is digital and statespace, than i automatically have some more functions that I would like it to have
15:28:19 <commanace> It's no serious project, rather playground hacking :)
15:29:10 <BONUS> hehe, hmm, well one thing you could do is define functions that work on types that are both digital and statespace
15:29:14 <BONUS> like
15:29:30 <BONUS> blah :: (StateSpaceControl a, DigitalControl a) => a -> ...
15:29:49 <BONUS> so just define those functions and if a type is in both those typeclasses, you'll be able to use those functions on it
15:30:09 <commanace> BONUS: oh yeah, good point that actually is the best solution to it, thanks! :D
15:30:25 <BONUS> sometimes it's best to keep it simple!
15:31:18 <tangerine> hi, I have question about of future of haskell? in one forum, guys says that haskell will language of the future in next five yeras.sorry for english, but what with jobs for haskell developers? there is few, but not many. thanks
15:31:54 <TR1N1TY> I'm selling botz and backdoors
15:31:56 <TR1N1TY> msg me
15:32:38 <TR1N1TY> I'm selling botz and backdoors
15:32:40 <TR1N1TY> msg me
15:33:09 <ivanm> @where ops
15:33:09 <Vulpyne> Do you have l33t 0-day Haskell exploitz?
15:33:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
15:33:23 <TR1N1TY> I'm selling botz and backdoors
15:33:24 <TR1N1TY> msg me
15:33:30 <ivanm> bos31337: spammer alert!
15:33:36 <TR1N1TY> I'm selling botz and backdoors
15:33:37 <TR1N1TY> msg me
15:33:45 --- mode: ChanServ set +o Philippa
15:33:49 <TR1N1TY> I'm selling botz and backdoors
15:33:51 <TR1N1TY> msg me
15:33:55 --- mode: ChanServ set +o shapr
15:33:57 --- mode: Philippa set +b *!*@dsl-245-176-142.telkomadsl.co.za
15:34:04 <shapr> well then
15:34:10 <shepheb> \o/
15:34:21 --- mode: Philippa set -o Philippa
15:34:22 <ivanm> shapr: you scared him off! \o/
15:34:23 <BONUS> i just /ignore them
15:34:25 <Philippa> I'm selling bans?
15:34:34 <ivanm> Philippa: heh
15:34:39 <shapr> BONUS: I don't ignore anyone, because newbies don't have /ignore lists.
15:34:59 <BONUS> haha
15:35:00 <lispy> shapr: Are you implying you're a newbie?
15:35:05 <ivanm> @remember Philippa <TR1N1TY> I'm selling botz and backdoors <Philippa> I'm selling bans
15:35:05 <lambdabot> It is forever etched in my memory.
15:35:13 <shapr> lispy: Sure, so much to learn.
15:35:20 * ivanm doesn't have an /ignore list ...
15:35:22 --- mode: shapr set -o shapr
15:35:33 <ivanm> mainly because I can never work out how to set it
15:35:44 <shapr> Where do I submit ideas for Google SoC? Has SoC started yet?
15:36:01 <ivanm> bos: I get the "1337" at the end, but why the extra '3' there?
15:36:16 <shepheb> consider it's March 2, it definitely hasn't started yet. don't know when the proposals are due, though.
15:36:23 <bos> well clearly the correct spelling is with a leading 3, innit.
15:37:07 <ivanm> oh, for elite rather than just leet?
15:37:12 <ivanm> *eleet
15:37:20 <nus> @elite elite haskellbotz
15:37:20 <lambdabot> E1It3 HA5k3Ll80ts
15:37:27 <ivanm> the "correct spelling" doesn't have any digits in it...
15:37:38 <shepheb> there was a time when that was the common spelling
15:38:15 <philo> can someone explain me this : "class ABinOp a b c | a b -> c"
15:38:23 <aavogt> functional dependencies
15:39:45 <philo> ?
15:39:58 <aavogt> philo: it helps to resolve typeclass instances
15:40:08 <shapr> http://www.haskell.org/haskellwiki/Functional_dependencies
15:40:18 <commanace> philo: it says, that if you know a and b, you also know c
15:40:31 <commanace> at least if i got that right myself :D
15:40:39 <ivanm> almost
15:40:51 <ivanm> given a and b, then c is fixed
15:40:53 <philo> can you guys point me to the relevent documentaion ?
15:41:01 <ivanm> philo: shapr gave you a link
15:41:06 <philo> ho ok
15:41:42 <pchiusano> hello
15:42:04 <shapr> Hiya pchiusano, how are the monoids treating you?
15:42:27 <pchiusano> hey shapr... er... monoids are good
15:42:50 <shapr> Glad to hear it, have you written much Haskell lately? Or still mostly doing Scala?
15:43:48 <pchiusano> shapr: almost exclusively scala these days
15:45:42 <shapr> I still haven't tried Scala, but I've heard good things about it.
15:46:37 * shapr tries to find Google Summer of Code 2010 info
15:46:44 <pchiusano> shapr: yeah, Scala is not bad
15:47:05 <pchiusano> i wish the type inference were better
15:47:22 <shapr> Yeah, I wish that for Python too :-)
15:47:52 <shapr> I've written a bit of Python lately, makes me wish for GHC on ARM.
15:48:06 <pchiusano> hmm
15:48:14 <pchiusano> shapr: are you writing python for work?
15:48:24 <shapr> Nah, I'm currently an unemployed student.
15:48:43 <pchiusano> ah
15:49:10 <shapr> That has left me with time to start playing with ZigBee, Arduino, embedded Linux, etc.
15:50:00 <shapr> dons: Where do I suggest SoC projects for 2010?
15:50:25 <shapr> Since I'm a student, I'd like to propose a QuickCheck-based fuzzer.
15:50:35 <pchiusano> shapr: nice
15:50:52 <pchiusano> shapr: where are you now? I remember you moved...
15:51:10 <shapr> pchiusano: Could be fun, I'm still trying to figure out if there's a good way to create the complement of a data type that describes legal data.
15:51:23 <shapr> pchiusano: I'm in Northwest Alabama, about an hour's drive west of Huntsville.
15:51:35 <jmcarthur> shapr: so you can write a fuzzer for legal documents? ;)
15:51:42 <shapr> I'm about five minutes drive from Fame Studios.
15:51:55 <pchiusano> Fame Studios?
15:51:55 <shapr> jmcarthur: Legal documents are already fuzzy for me.
15:52:18 <shapr> pchiusano: Not related to programming at all - http://en.wikipedia.org/wiki/FAME_Studios
15:52:48 <shapr> Aretha Franklin, Wilson Pickett, etc recorded here.
15:52:53 <pchiusano> cool
15:52:56 * jmcarthur lives in huntsville and had no idea what fame studios was
15:53:26 <pchiusano> shapr: what's a fuzzer?
15:53:41 <shapr> http://en.wikipedia.org/wiki/Fuzzer
15:53:59 <shapr> Roughly, it looks for 'slightly illegal' interactions to find software bugs.
15:54:03 <jmcarthur> nashville is near enough that i guess music-related things in other parts of the tennessee valley are easily overlooked
15:54:17 <Philonous> It's a little silly. It took me 10 hours to figure out I wrote [1,n] instead of [1..n]. Maybe I should kick list comprehensions and use enumFromTo
15:54:23 <shapr> Most software testing only covers 'expect outcomes' rarely is 'correct failure' ever considered.
15:54:36 <DBAlex> Hey
15:54:37 <DBAlex> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23188#a23188
15:54:45 <pchiusano> shapr: heh, okay, I will stop asking wikipedia-answerable questions
15:54:46 <DBAlex> whats wrong with this, can I not use 2 where clauses? :-S
15:54:47 <pchiusano> :)
15:54:52 <jmcarthur> i wish fuzz testing could prove code correct
15:54:53 <DBAlex> (The error is in the last line)
15:55:03 <shapr> pchiusano: No worries, I don't mind explaining, I just like to give links for further information as well.
15:55:03 <DBAlex> parse error on input `='
15:55:08 <DBAlex> thanks! :)
15:55:13 <pchiusano> shapr: yeah
15:55:25 <shapr> jmcarthur: You could do proof by exhaustion, right?
15:55:37 <jmcarthur> shapr: for enumerable domains, sure
15:55:50 <DBAlex> hello ? :-)
15:55:56 <olsner> shapr: correct failure would be important when it comes to security, I think
15:56:11 <shapr> olsner: Sure, it's still rarely checked.
15:56:17 <olsner> true
15:57:01 <DBAlex> hello ?
15:57:11 <shapr> DBAlex: Hi!
15:57:23 <pchiusano> question - is there a typeclass that extends Functor with the function align :: (Maybe a -> Maybe b -> c) -> f a -> f b -> f c
15:57:26 <DBAlex> shapr: hey, can I not have 2 where clauses like this: parse error on input `='
15:57:31 <DBAlex> oops
15:57:35 <DBAlex> shapr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23188#a23188
15:58:09 <pchiusano> basically, zipWith, but with the "holes" in one container explicitly tracked
15:58:21 <DBAlex> anyone ?
15:58:42 <shapr> DBAlex: Have you tried a very minimal bit of code that does have two where clauses?
15:58:50 <DBAlex> shapr: no
15:58:56 <DBAlex> shapr: is that valid Haskell?
15:59:04 <shapr> DBAlex: Try it, tell me what you find.
15:59:25 <DBAlex> shapr: I honestly (seriously) don't have time, but is the code valid?
15:59:37 <Qjet> I don't think he knows...
15:59:39 <DBAlex> I'm guessing not, but I'm sure i've seen > 1 where before
15:59:51 <Vulpyne> DBAlex: You mean the multiple definitions under one where? Yes, that will work.
16:00:02 <shapr> hiya Vulpyne!
16:00:08 <Vulpyne> Hey, shapr!
16:00:11 <pchiusano> DBAlex: it looks like your layout might be off...
16:00:11 <Vulpyne> What is up?
16:00:15 <DBAlex> yeah
16:00:20 <DBAlex> I think the indentation is borked
16:00:39 <Vulpyne> DBAlex: Other than indent it looks okay. You can also do the same thing with a let.
16:01:12 <DBAlex> Yeah but
16:01:14 <DBAlex> Kinda messy :)
16:01:18 <shapr> Vulpyne: Going to school, using my spare time to learn new tech, what's up with you?
16:01:25 <Zeiris_> How come on one computer, cabal install fails for many packages with a message:  "requires base >=4.0 && <6" and no base package of that version is available. Is this some known problem with the default Ubuntu GHC package?
16:01:43 <Vulpyne> shapr: Fun, what are you learning about? Haskell stuff?
16:01:46 <HugoDaniel2> hello
16:01:55 <Vulpyne> shapr: I'm writing Haskell network servers. :)
16:02:04 <shapr> Vulpyne: Nah, 802.15.4 at the moment. Awesome! Are you getting paid to do that?
16:02:22 <Vulpyne> Vulpyne: Luckily, yes. The company I work for doesn't care what language I do things in.
16:02:28 <Vulpyne> Err.
16:02:52 <Vulpyne> They say talking to yourself is the first sign of insanity. Anyway, I've been able to write all my stuff in Haskell for a while. It is quite nice.
16:03:01 <DBAlex> ah
16:03:05 <DBAlex> indentation was off :)
16:03:13 <Qjet> it's only the first sign of insanity if you get an answer.
16:03:17 <DBAlex> almost as bad as Python... almost. :-P
16:03:47 <DBAlex> I find Haskell pretty difficult still
16:03:50 <DBAlex> even after a year...
16:03:57 <DBAlex> but I haven't written many programs
16:04:10 <Vulpyne> It gets easier with time.
16:04:20 <Polarina> @src foldr1
16:04:20 <lambdabot> foldr1 _ [x]    = x
16:04:21 <DBAlex> I suppose if you find Haskell difficult, you should write more Haskell code, so that's probably what I'll do
16:04:21 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
16:04:21 <lambdabot> foldr1 _ []     = undefined
16:04:32 <Zeiris_> Woah, there are companies that don't care if you write your stuff in a language only 1/1000 programmers might kinda understand? :D
16:04:37 <HugoDaniel2> haskell is difficult because we are so used to completely diff languages
16:04:38 <DBAlex> I seem to be able to write a few programs, but hit brick walls and can't work out how to do X in Haskell for days :/
16:04:58 <Vulpyne> Zeiris_: I keep trying to get my coworkers to learn it!
16:05:05 <HugoDaniel2> ...haskell is much more natural than C/C++/Java/C#/Python/Ruby as a first programming language
16:05:26 <DBAlex> from a maths background yes
16:05:32 <HugoDaniel2> i have had several experiences on this
16:05:34 <DBAlex> not from anywhere else :-)
16:05:35 <Zeiris_> I REALLY want to find a way to do something like data flow programming in Haskell. There's got to be something with Arrows and Streams that results in beautiful code that fits the problem extremely well.. But argh, I can't figure out what it is.
16:05:39 <HugoDaniel2> with engineers, and artists
16:05:54 <DBAlex> If Haskell was my first language i'd have probably given up on CS/Programming by now
16:06:03 <HugoDaniel2> how do you know DBAlex ?
16:06:14 <HugoDaniel2> why ?
16:06:15 <ddarius> Zeiris_: There's some stuff with comonads, but it isn't that pretty, in my opinion.
16:06:17 <pchiusano> Zeiris_: I've heard comonads could be involved too... been meaning to play with that more myself
16:06:20 <DBAlex> HugoDaniel12: beacause I do, I'm not from a maths background... ;)
16:06:22 <Zeiris_> If Haskell was my first language I'd probably never go into programming once I realized what a pain in the ass most of it was.
16:06:26 <ddarius> @google comonads data flow
16:06:28 <lambdabot> http://cs.ioc.ee/efftt/uustalu-slides.pdf
16:06:28 <lambdabot> Title: cache:http://cs.ioc.ee/efftt/uustalu-slides.pdf - Google Search
16:06:35 <Vulpyne> DBAlex: Maybe you feel that way since you're used to solutions coming fairly easily, so it's frustrating when you have to throw away all you knew about progamming.
16:06:40 <shapr> DBAlex: I've been using Haskell for almost nine years, and I'm taking my very first CS class this term!
16:06:42 <Vulpyne> Kinda of like switching to Dvorak.
16:06:59 <HugoDaniel2> "they" say dvorak is much better than qwerty
16:07:02 <Gracenotes> Zeiris_: then your first language wasn't PHP? -.-
16:07:16 <shapr> DBAlex: I took business calculus three times, I passed it the third time :-/
16:07:17 <HugoDaniel2> Gracenotes: im not sure thats what he meant :)
16:07:20 <Vulpyne> HugoDaniel2: I switched to it when I was 16 or so, and I can vouch for that. :) But the time while learning it wasn't too fun.
16:07:27 <shapr> DBAlex: so I don't think math/theory background is necessary for enjoying Haskell.
16:07:47 <DBAlex> Vulpyne: I don't find new languages difficicult, or Haskell difficult, I find the jumping through hoops to solve it in Haskell hard
16:08:20 <Gracenotes> hoops? don't see any hoops.
16:08:31 <Gracenotes> anyway, anyone who thinks consistency is repulsive should try PHP
16:08:45 <HugoDaniel2> or ASP
16:08:56 <Zeiris_> I just meant that if you start with Haskell's amazing type system, switching to anything else (C pointers, Python runtime type determination) would be a nightmare.
16:09:00 <Rotaerk> I switched to dvorak a few years ago under the impression that I'd type faster and more relaxed; I don't really have any way to confirm whether that's true... except people have said my hands look relaxed when typing
16:09:07 <Vulpyne> I can only speak for myself, but I found that I needed a different mental process to solve problems in the Haskell way.
16:09:21 <Younder> Zeiris, try Qi's
16:09:28 <shapr> I switched to dvorak in 1992, I'm much faster now.
16:09:29 <Vulpyne> You can apply current imperative programming knowledge, but it doesn't really work that well.
16:09:39 <ddarius> Rotaerk: I don't type noticeably faster, but it is quite a bit more comfortable though less entertaining to watch.
16:09:41 <Zeiris_> Younder: what's Qi?
16:09:47 <Rotaerk> heh
16:09:48 <HugoDaniel2> where do you guys find keyboards with that layout ?!
16:09:58 <Vulpyne> There are some, but most people just redefine it in software.
16:10:05 <Younder> Zeiris, a programming language.
16:10:06 <Rotaerk> HugoDaniel2, my keyboard looks laid out in qwerty
16:10:08 <ddarius> HugoDaniel2: You touch type.
16:10:08 <Qjet> with a screwdriver and a cheap keyboard?
16:10:11 <Vulpyne> If you touchtype, you don't need to look at the keys anyway.
16:10:25 <Rotaerk> I keep it in qwerty just in case I ever need to use that layout
16:10:25 <HugoDaniel2> touch type ?
16:10:32 <ddarius> Holy crap.
16:10:36 <Vulpyne> Touch Type = typing without looking at the keyboard.
16:10:37 <Gracenotes> subtly different keyboard layouts are the achilles' heel of touch typing
16:10:57 <Gracenotes> like the angle in the grid is no longer 20 degrees, but 25
16:11:08 <Younder> Zeiris, The thing is the way type inference is done 'under the hood' in GHC is actually quite ugly. Qi has a far more elegant approach
16:11:22 <HugoDaniel2> i should try dvorak :)
16:11:40 <ddarius> Gracenotes: I switch keyboards and layouts often enough that such changes don't impact me much.
16:11:43 <HugoDaniel2> i have a 400eur keyboard
16:11:47 <HugoDaniel2> thats my laptop
16:12:00 <ddarius> HugoDaniel2: If you don't know how to touch-type, then expect to (in a bit) get much, much faster.
16:12:13 <HugoDaniel2> i dont know what is touch type
16:12:21 <HugoDaniel2> but i never look at the keys... if thats what you mean...
16:12:26 <Vulpyne> HugoDaniel2: Yes.
16:12:33 <Vulpyne> You are typing by "touch", not by visual.
16:12:55 <HugoDaniel2> because i know where they are... if i switched to dvorak it would be a pain
16:13:18 <Vulpyne> HugoDaniel2: For me, it wasn't that hard to learn which key was which, but it takes a while before you can type without thinking.
16:13:21 <lament> don't switch to dvorak.
16:13:41 <Vulpyne> Why shouldn't he?
16:14:03 <Qjet> I'm with lament on this one, I think the gains are dubious and the effort somewhat considerable. Teach your children dvorak.
16:14:03 <dancor> with Data.Binary, loading an (IntMap (Int, Int)) from a 3MB file needs extra stack space and takes 30sec.  that's excessive right?
16:14:20 <lament> Don't switch to dvorak, don't teach your children dvorak.
16:14:27 <Qjet> oh o.x
16:14:33 <Qjet> ok so I'm half way with lament
16:14:34 <dancor> lament: colemak?
16:14:40 <lament> I learned touch-typing on dvorak, so I never even had to relearn; and I still think I would have been better off with Qwerty.
16:14:47 <Vulpyne> Why?
16:15:18 <Vulpyne> dancor: How is it building the map? I don't know if this will help you, but if you're using Map.insert, Map.insertWith' usually works a lot better.
16:15:21 <lament> less hassle, don't need to reconfigure computers all the time, don't need to force all your friends to learn how to switch layouts on your computer; meanwhile, the gains are dubious
16:15:22 * dancor happy dvorak user; would learn colemak if learning today but no regrets nonetheless
16:15:43 <shapr> Sometimes I think enthusiasm is what makes something powerful.
16:15:50 <Vulpyne> Well, you can still type QWERTY even if you know dvorak.
16:15:57 <lament> I can't
16:16:03 <lament> i never learned
16:16:12 <dancor> i made an 'asdf' command to switch.  i can do qwerty easily, esp looking down
16:16:14 <Qjet> I imagine it would be a pain in the butt to learn.
16:16:17 <Rotaerk> I don't regret learning dvorak, though if I were deciding to learn a new layout now, knowing how little it has had an effect on my life, I wouldn't bother
16:16:17 <HugoDaniel2> hmm im portuguese, i guess dvorak is english language speakers only
16:16:18 <lament> i'm considering learning qwerty and switching to it. I will probably be pretty good at it.
16:16:20 <ddarius> lament: I just set my default layout to QWERTY.  It's easy enough to enable both and I can type both.
16:16:31 <Vulpyne> Yeah, learning only Dvorak is probably not really good considering most stuff is QWERTY.
16:16:51 <Vulpyne> But learning it after you already know QWERTY is good, and most people do their main typing on their own computer.
16:17:11 <dancor> Vulpyne: well the map is already built..  loading from binary is what's taking really long
16:17:17 <Vulpyne> If you work as a programmer or something, being able to type all day without wearing your hands out helps a lot.
16:17:18 <lament> The biggest advantage of dvorak is that if you have a qwerty-caps keyboard, you're forced to learn to touch-type properly.
16:17:31 <lament> Vulpyne: I don't believe there's much of a difference.
16:17:42 <dancor> Vulpyne: or you think the binary instance might be unoptimized?
16:17:42 <ddarius> lament: Learn QWERTY.
16:17:53 <Vulpyne> Personally, I found it to be a pretty significent difference.
16:18:03 <lament> Vulpyne: also, if you're a programmer, you type very little English and quite a lot of inconvenient punctuation.
16:18:05 <c_wraith> I've *never* worn my hands out with qwerty.  I think it's proper technique that matters, not the keyboard layout
16:18:06 <HugoDaniel2> i switch computers a lot since i do quite some sys admin work
16:18:15 <HugoDaniel2> i guess qwerty is a natural choice
16:18:15 <Vulpyne> dancor: I didn't know Binary had built in instances for Map.
16:18:16 <EvanCarroll> I agree, having labels on keys is horrable for people learning to type
16:18:23 <lament> c_wraith: I agree
16:18:26 <dancor> Vulpyne: ya it does
16:18:30 <EvanCarroll> my old school used to teach typing by placing paper towels on the keys.
16:18:46 <dancor> that _is_ oldschool
16:18:50 <EvanCarroll> I would personally write a macro that displayed the keyboard with F12 or something, and took 5 points off their grade.
16:18:56 <lament> I painted a keyboard solid white
16:19:06 <Vulpyne> dancor: I am not sure then. But a couple times when I had to build very large maps from data, I ran into trouble until I used insertWith', since it is strict.
16:19:06 <lament> it's pretty neat
16:19:15 <dancor> mm
16:19:21 <Qjet> @evancarroll that's almost sadistic.
16:19:21 <lambdabot> Unknown command, try @list
16:19:22 <Gracenotes> only thing I can never remember is the exact positioning of the number keys, and the symbols that are above them
16:19:42 <Gracenotes> Shift+7, Shift+6, Shift+5... oh, there's the percent key
16:19:53 <lament> Gracenotes: I don't think "can never remember" is right, you just never learned them.
16:20:19 <Qjet> that would be why he can't remember them I suspect.
16:20:24 <Gracenotes> well, 'can' is kind of used in a continuous sense there
16:20:25 <Zeiris_> "Learn" is a poor term when it comes to muscle memory, anyway. It's more, like, "used".
16:20:28 <dancor> it also seems like in C you can just memmap the file and load a (contiguous) structure _very_ quickly
16:20:47 <Zeiris_> Since you don't learn things like Vi keys or whatever in the traditional, study-centric way.
16:20:49 <dancor> is there a good way to do that in haskell with a map/trie/hashmap structure?
16:20:58 <lament> Zeiris_: you don't?
16:21:02 <ddarius> dancor: No.
16:21:23 <dancor> ddarius: is it theoretically impossible to doing something cool there, or no one has yet
16:21:25 <lament> vikeys are totally easier on dvorak btw :)
16:21:30 <Gracenotes> dancor: there are a lot of design choices that come with that
16:21:33 <Zeiris_> lament: Nah. You learn it by doing - even vimtutor realizes that :)
16:21:37 <ddarius> dancor: It's of course not impossible.
16:21:48 <lament> s/easier/better placed
16:22:15 <dancor> well this is definitely the bottleneck on my go opening database program
16:22:16 <dschoepe> dancor: there's a mmap-package on hackage, but it looks fairly low-level
16:24:44 <Gracenotes> Foreign.C and Foreign.Marshal: make your own structs, with lovely syntax
16:25:01 <dancor> dschoepe: ah so when you write to mmap'ed memory it changes on disk (eventually) as well?
16:25:14 <dancor> i was just thinking about slurping up
16:25:20 <dancor> a continuous structure
16:25:55 <Gracenotes> that is what mmap does
16:26:00 <dons> dancor: you can mmap a serialized structure
16:26:06 <lament> go openings are nasty
16:26:12 <dancor> nasty awesome
16:26:50 <dancor> hm.  seems hard for me to find a happy medium between fast and basically-all-c
16:27:49 <lament> c is nasty awesome
16:28:14 <lament> does your opening database do anything cool?
16:28:32 <dancor> no, it just gives win/loss stats for positions
16:28:36 <Gracenotes> dancor: with C, loading a struct into memory doesn't have any semantic meaning. Arbitrary bit patterns aren't as safe for Haskell, methinks
16:28:40 <lament> whole board?
16:28:43 <dancor> lament: ya
16:29:01 <lament> doesn't something else already do that
16:29:15 <lament> i've definitely seen that
16:29:17 <dancor> lament: i couldn't find anything free, do you know of something?
16:29:20 <Gracenotes> dons: has uvector IO been 'fixed', btw?
16:29:29 <lament> eidogo doesn't?
16:29:49 <dancor> lament: i've seen fuseki.info but it's gone and it had a small gamebase
16:30:27 <lament> i think eidogo does it
16:30:39 <dancor> lament: looks like it does if you press Score Estimate O(n^2) times
16:31:38 <dancor> lament: actually i can't find a whole board thing at all even.  just the joseki tutor
16:31:58 <lament> hm
16:31:59 <lament> nevermind then
16:32:17 <lament> i guess the problem with whole board is that it's not going to be very useful
16:32:40 <Zeiris_> What exactly is the difference between Data.Stream and Data.List?
16:33:05 <Gracenotes> finiteness
16:33:08 <lament> people don't repeat whole boards very deep
16:33:53 <Zeiris_> But lists can be infinite too?
16:33:58 <Gracenotes> Data.List can have infinite lists or lists of a specific length, which end with a []/nil. Data.Stream keeps on generating.
16:34:06 <Zeiris_> Ah.
16:34:44 <Gracenotes> at least, unless the generator reaches undefined/infinite loop/semantic bottom
16:35:26 <dancor> lament: ya but i'm interested in looking like 8 ply deep
16:35:55 <lament> maybe you're better off just reading a lot about the chinese opening :P
16:35:58 <dancor> http://github.com/dancor/goldbug
16:35:59 <dancor> heh
16:37:28 <dancor> why achieve just your goal when you can fail at your meta-goal instead
16:38:35 <lament> fair enough
16:38:46 <lament> my goal is to sleep with whatshername
16:38:55 <lament> the korean pro who has an english blog
16:40:14 <dancor> janice kim? free lessons at sf go club first friday of every month
16:40:27 <lament> no not her
16:41:07 <dancor> lol.  what's the coolest way to write \ (a, b) (c, d) -> (a + c, b + d)
16:41:31 <benmachine> @pl \(a,b) (c,d) -> (a+c,b+d)
16:41:32 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
16:41:35 <benmachine> like that
16:41:37 <dancor> ha
16:42:30 <jcreigh> I forget...is it the case that *any* "pointed" code can be rewritten in points-free form?
16:42:45 <dancor> @pl \(a,b)(c,d)->(f a c, g b d)
16:42:46 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. g) . flip . (((.) . (,)) .) . f)
16:42:53 <aavogt> @type ((+) *** (+)) .  (`asTypeOf` (1,1))
16:42:54 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
16:43:13 <dancor> jcreigh: i think so..
16:43:17 <Philonous> jcreigh: Yes. Just as any lambda term can be written in SKI-calculus
16:43:35 <dancor> pl also tries to do some condensation/optimization
16:43:52 <dancor> i wonder what it had initially for that monstrosity
16:44:34 <aavogt> the intermediate form is SKI?
16:45:28 <benmachine> jcreigh: you need the right primitives
16:45:42 <benmachine> e.g. it sometimes uses if'
16:45:47 <Philonous> jcreigh: You need some helper functions though, because the point-free version of "if" isn't in the prelude.
16:46:07 <benmachine> @pl \(x:xs) -> (x, xs)
16:46:07 <lambdabot> liftM2 (,) head tail
16:46:16 <jcreigh> *nods*. Yeah, I'm assuming that "fst" and whatnot exist.
16:47:32 <benmachine> I am always amused by
16:47:36 <benmachine> @pl liftM
16:47:36 <lambdabot> fmap
16:47:36 * hackagebot has 0.2 - Generic Haskell's Record Accessors  http://hackage.haskell.org/package/has-0.2 (YusakuHashimoto)
16:47:39 <byorgey> jcreigh: essentially, you also must assume that 'ap' (i.e. the S combinator) exists
16:47:57 <byorgey> you cannot implement that in points-free form.
16:48:18 <byorgey> since it actually copies an input as the input to two other functions.
16:48:22 <benmachine> byorgey: isn't that also true of . and id and const and... quite a few things
16:48:28 <Philonous> jcreigh: You may want to consult a book on lambda calculus if you are interested in the details. I think Barendregt covers the lambda/SKI-equivalence proof
16:48:30 <jcreigh> byorgey: ah, I am not familiar with SKI calculus, so I will take your word for it.
16:49:21 <byorgey> benmachine: amazingly, if you just take ap and const as given, that's all you need =)
16:49:28 <byorgey> (those are the S and K combinators)
16:49:31 <benmachine> neat
16:49:34 <benmachine> what does I stand for
16:49:39 <byorgey> I stands for id
16:49:41 <Qjet> identity I think
16:49:41 <Philonous> jcreigh: SKI calculis is the "point-free" pendant to lambda calculus. You have three "combinators" called S, K and I (actually you only need S and K), where S a b c = a c (b c) and K a b = a.
16:49:42 <benmachine> oh
16:49:48 <byorgey> but you can implement it as SKK
16:49:58 <byorgey> @type ap const const
16:49:59 <lambdabot> forall b. b -> b
16:50:02 <benmachine> neat
16:50:08 <benmachine> wait I said that already
16:50:19 <byorgey> saying 'neat' multiple times is allowed =)
16:50:29 * benmachine pokes etpace 
16:50:41 <benmachine> yes but creativity is an art
16:50:47 <benmachine> or art is a creativity, perhaps
16:51:10 <byorgey> jcreigh: welcome back, btw, long time no see =)
16:51:19 <jcreigh> byorgey: ty. :)
16:53:40 <Qjet> Oh that reminds me why I came here,
16:54:05 <Qjet> what's the most effective way to persuade BONUS to finish his tutorial: http://learnyouahaskell.com/
16:54:21 <benmachine> milk and cookies
16:54:34 <gwern> cripes. 21G and I still don't have a snpshot of the karmic ubuntu repos
16:54:39 <Qjet> I have no milk and cookies to give <.(
16:54:54 <benmachine> you could try soy and biscuits
16:54:58 <gwern> Qjet: buy the LYAH book?
16:55:01 <benmachine> but it's unlikely to work as well
16:55:14 <Qjet> a LYAH book exists?
16:55:26 <benmachine> I thought it was still in the pipes
16:55:30 <gwern> in the 4D manifold, it exists
16:55:34 <benmachine> heh
16:55:37 <Qjet> what the site says.
16:55:44 <gwern> in ages past, in ages yet to come
16:55:51 <byorgey> Qjet: I think people were just bugging BONUS to finish it earlier today =)
16:55:53 <gwern> a book arose. it was not *the* book. but it was *a* book
16:55:55 <Qjet> I don't think time is cyclical.
16:56:13 <Qjet> Oh good, I feel privileged to join their ranks byorgey.
16:56:32 <dancor> anyway afterward ppl will have trouble imaging what the time before was like
16:58:20 <gwern> fact turns to legend, legend fades to myth, and even myth has been forgotten when the age that give it birth comes again
17:00:14 <theorbtwo> It was an age of myth, an age of legend, an age... of Gargoyles.
17:00:30 <Qjet> gargoyles came after the age of legend >.|
17:00:38 <dons> Gracenotes: uvector is superceded by vector
17:00:47 <Gracenotes> :o
17:01:23 <gwern> Gracenotes is so out of touch.  uvector->vector was, like, a whole week ago
17:01:58 <gwern> Qjet: hm. I don't remember any gargoyles in WoT. unless you mean the draghkar thingies?
17:02:09 <aavogt> uvector is the soulja boy themesong for vector
17:02:54 * theorbtwo morphing the subject to the 90s Disney TV cartoon Gargoyles.
17:03:14 <DBAlex> In haskell, how do I get to a base case and then work backwards?
17:03:22 <DBAlex> is it even possible.. :s
17:03:29 <dancor> theorbtwo: a classic
17:03:30 <aavogt> what are you doing?
17:03:36 <gwern> DBAlex: your question as formulated does not admit of an answer
17:03:44 <DBAlex> yeah
17:03:45 <DBAlex> :s
17:03:55 <DBAlex> I want to get to the bottom of a tree type and then work backwards
17:04:00 <theorbtwo> dancor: Ah, glad I'm not the only one who knows it.  I re-watched them a few years ago.  *so good*.
17:04:01 <DBAlex> but I know you obviously can't
17:04:21 <DBAlex> I guess a solution is if it is empty then it is Nothing else peform the operation on the nodes
17:04:32 <DBAlex> and then map the function to the whole tree?
17:04:33 <aavogt> @src foldr
17:04:33 <lambdabot> foldr f z []     = z
17:04:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:05:22 <aavogt> in a way, foldr starts at the end of the list
17:05:35 <benmachine> in quite a weird way
17:05:46 <gwern> DBAlex: sounds like a decent approach. what's stopping you?
17:05:46 <benmachine> the lesson is that it's not about order, it's about data dependencies
17:05:51 <benmachine> which results are used where
17:06:01 <DBAlex> gwern, because I don't think it works
17:06:02 <DBAlex> :s
17:06:20 <benmachine> DBAlex: draw a big tree on some paper, and put arrows where you want arguments to go into your functions :P
17:06:30 <benmachine> hopefully you should then be able to work out how to make it happen
17:06:49 <DBAlex> maybe
17:07:00 <benmachine> but seriously, don't think about it in terms of order
17:07:20 <aavogt> what happens to your tree after your function takes it?
17:07:24 <benmachine> think in terms of "where do I get my arguments from"
17:08:29 * gwern sighs and begins scanning this book. again.
17:09:50 <CcSsNET> dont scan it upside down o.o
17:09:54 <Cale> The most natural way to think about foldr f z is to just imagine it replacing each of the (:)'s in the list with f, and the [] at the end with z
17:10:29 <gwern> CcSsNET: har har. this time I will be sure to not trigger the same bug in gscan2pdf, is all
17:10:50 <Cale> If you want to impose an order on the way that it does that, it really does start at the beginning of the list.
17:11:38 <Cale> foldr f z (x:xs) = f x (foldr f z xs)  -- it immediately applies f to the first element of the list and the foldr of the rest, and f gets to call the shots on whether or not to continue folding over the list.
17:12:25 <Cale> > foldr (\x xs -> 2*x : xs) [] [1..]
17:12:26 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:12:37 <Cale> ^^ it works on infinite lists because of this
17:13:08 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
17:13:09 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
17:13:33 <todche> hi
17:13:36 <Cale> hello
17:13:40 <byorgey> hi todche
17:13:43 <todche> hello
17:13:50 <todche> im new here
17:14:06 <Cale> Feel free to ask any questions about Haskell you might have.
17:14:16 <todche> really even in coding in xml
17:14:22 <Zeiris> Can I do dataflow programming in Haskell effectively?
17:14:25 <ivanm> (whether we answer or not is a different story...)
17:14:32 <ivanm> Zeiris: define "dataflow programming"
17:14:52 <Zeiris> Argh, you got me :(
17:14:55 <centrinia> todche, if you want to do "coding in xml" using Haskell in some way, sure. :)
17:15:03 <nus> ivanm, heh, was about to ask 'define "effectiveliy"' (-:
17:15:09 <nus> *ly
17:15:29 <aavogt> @faq does @pl make haskell code dataflowish?
17:15:29 <lambdabot> The answer is: Yes! Haskell can do that.
17:15:53 <CcSsNET> the awnser is. no u cant code XD no really idk hehe
17:16:08 <theorbtwo> Zeiris: You don't need to start with something terribly formal.  What is it like?
17:16:11 <ivanm> Zeiris: I mean, I consider how I usually program to be a "dataflow" process, but I have no idea if that's what you mean
17:16:22 <todche> ohhh
17:16:50 <todche> so icant ask anything in coding if im not using it in haskel
17:16:57 <Zeiris> Well, I can draw out the project I'm currently thinking of as a data flow diagram, but am having trouble converting it to clean Haskell.
17:17:17 <burp> > map (-3) [1..10] -- um stupid question .. how do I do this? :>
17:17:18 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
17:17:18 <lambdabot>    arising from a use of syntactic n...
17:17:30 <burp> the minus thing is annoying me ;)
17:17:31 <aavogt> > map (subtract 3) [1..10]
17:17:32 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
17:17:38 <burp> ah yes subtract thanks :>
17:18:05 <Zeiris> > map ((-) 3) [1..5]
17:18:07 <lambdabot>   [2,1,0,-1,-2]
17:18:12 <burp> thats not the same
17:18:14 <ivanm> Zeiris: you mean this? http://en.wikipedia.org/wiki/Dataflow_diagram
17:18:21 <ivanm> Zeiris: that's 3-
17:18:31 <ivanm> @src subtract
17:18:31 <lambdabot> subtract x y = y - x
17:18:39 <dancor> > map (\ x -> x - 3) [1..10]
17:18:40 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7]
17:18:56 <byorgey> todche: well, this channel is specifically for discussing the programming language Haskell.
17:18:58 <luite> > map (`(-)` 3) [1..10]
17:18:59 <lambdabot>   <no location info>: parse error on input `('
17:19:02 <ivanm> subtract = flip (-)
17:19:07 <byorgey> todche: you can ask other questions, but they are less likely to be answered. =)
17:19:34 <todche> ok
17:19:46 <todche> i go to javascript
17:19:50 <todche> tnx a lot
17:20:18 <benmachine> seems an odd sort of fellow to quote shakespeare as he parts
17:20:22 <benmachine> but I approve
17:20:51 <takeout> hi, i just finished my first haskell program.
17:21:08 <byorgey> congrats!
17:21:11 * byorgey presents takeout with a golden lambda
17:21:13 <ivanm> benmachine: my guess is that his client does it and he has no idea that that message even comes up
17:21:18 <byorgey> inscribed with the date
17:21:23 <ivanm> byorgey: awww, I never got one... :(
17:21:36 <takeout> niceee.
17:21:36 <ivanm> is this something new?
17:21:41 <byorgey> ivanm: well, you didn't tell me when you wrote your first program, did you?
17:21:45 <ivanm> heh
17:22:08 <ivanm> (technically I never finished my first program; I'm currently in the middle of a re-write)
17:22:13 <inhahe> haha
17:22:20 <byorgey> takeout: what does your program do?
17:22:29 <benmachine> ivanm: inadvertant cool is still cool with me
17:22:42 <ivanm> as in "dammit, I'm not generating all possible values as my `optimizations' are removing them" :s
17:22:52 <ivanm> benmachine: heh
17:22:53 <takeout> just prints some text to the stdout.
17:23:04 <takeout> but its wicked sweet.  only one line.
17:23:08 <byorgey> great! =)
17:23:13 <takeout> =D
17:23:30 <byorgey> takeout: are you following a particular tutorial/book?
17:23:58 * ivanm randomly guesses that it's "main = interact (map toUpper)"
17:24:04 <takeout> yah, haskell in 5 steps off the website.
17:24:49 <byorgey> takeout: cool. if you want suggestions for other things to read once you finish it, just ask.
17:25:29 <takeout> alright, will do!  thx  =]
17:33:49 <McManiaC> cabal build --hsc2hs-options="`pkg-config --cflags foo`"  how can I put this into a .cabal file?
17:34:12 <dcoutts_> McManiaC: cabal directly supports pkg-config
17:34:32 <dcoutts_> so you do not need to (and you cannot) specify hsc2hs options
17:34:54 <McManiaC> how?
17:35:00 <breakspirit> does anyone know of a good, simple way to check a list for a specific value?  seems like it should be so easy to do but im having a brain fart
17:35:27 <blackh> breakspirit: elem ?
17:35:35 <ivanm> @type elem
17:35:37 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:35:39 <ivanm> or:
17:35:48 <ivanm> @hoogle [a] -> a -> Bool
17:35:48 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
17:35:49 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
17:35:49 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
17:36:02 <dcoutts_> McManiaC: using the pkgconfig-depends field
17:36:07 <breakspirit> let me digest all that, thanks guys
17:36:28 <dcoutts_> McManiaC: details are in the cabal user guide
17:36:37 <McManiaC> awesome :)
17:36:38 <McManiaC> thx
17:36:39 <blackh> breakspirit: Happy Haskellizing!
17:36:45 <breakspirit> =)
17:37:10 <burp> > (\l -> (head . reverse $ l) : (reverse . tail . reverse $ l)) [1..10] -- any nice ideas for such a rotation?
17:37:11 <lambdabot>   [10,1,2,3,4,5,6,7,8,9]
17:37:31 <burp> I don't like having so many reverses
17:38:19 <aavogt> hey dcoutts_, is this feature supposed to work for cabal-1.8? http://hackage.haskell.org/trac/hackage/ticket/89
17:38:41 <aavogt> Cabal-1.8.0.2 to be specific
17:38:55 <dcoutts_> aavogt: yes, but it's currently broken with ghc-6.12 and cabal-install doesn't know about it yet
17:39:10 <aavogt> I mean even when you use Setup.hs
17:39:28 <dcoutts_> it should work via Setup.hs when using ghc-6.10
17:39:55 <aavogt> well it's broken for me with ghc-6.12 and Setup.hs (though you know this already?)
17:39:58 <blackh> burp: You can use init and last
17:40:10 <dcoutts_> aavogt: yep, it's broken with 6.12
17:40:47 <aavogt> dcoutts_: I've got a patch attached to that ticket, but maybe there's a better way to ensure that ghc can expose the right package
17:41:02 <burp> blackh: oh, sure.. thanks
17:41:37 <blackh> dcoutts_, aavogt: How about applying my patch to finally fix ticket 89?
17:42:20 <dcoutts_> blackh: hia, sorry I've been being a hermit the last couple months while I finish off my thesis
17:42:46 <blackh> Hello! You could just apply it and say "blame Stephen!"
17:43:03 <dcoutts_> blackh: correct me if I'm forgetting, your patch is for cabal-install right? or do you have something for the 6.12 issue too?
17:43:07 <aavogt> isn't it already in cabal-1.8?
17:43:28 <dcoutts_> iirc the 6.12 problem is with inplace vs installed package ids
17:44:13 <blackh> dcoutts_: Yes - only cabal install.  I don't know about the ghc-6.12 issue but I tried recently with ghc-6.12.latest-snapshot and it wouldn't build - it failed saying it couldn't find my (ticket #89 style) internal library.  Is that the issue you're talking about?
17:44:14 <aavogt> sort of like that, somehow Cabal doesn't get the hash for the package itself
17:44:46 <blackh> dcoutts_: I was able to get it by hacking the link command by adding a big hex number onto the end of the package id
17:45:18 <dcoutts_> blackh: sounds right
17:45:25 <aavogt> http://hackage.haskell.org/trac/hackage/ticket/89#comment:26 <-- use -package instead of -package-id for the inplace package
17:45:35 <blackh> dcoutts_: From what you just said, it sounds like the same thing.  Is this only in the ticket #89 case?
17:45:55 <blackh> aavogt, have you fixed it?
17:46:02 <dcoutts_> blackh: yes
17:46:14 <aavogt> it wasn't clear to me how to get the proper hashed package id from library part
17:46:18 <dcoutts_> aavogt: that would be a temporary workaround yes
17:46:26 <aavogt> blackh: yes, but it's sort of a hack?
17:46:27 <dcoutts_> the proper solution is to use the correct package id
17:46:48 <dcoutts_> we control the package id we use for the inplace package db
17:46:50 <aavogt> yeah, it wasn't clear to me where those come from
17:47:07 <dcoutts_> so we just need to use them consistently
17:47:15 <blackh> OK great.  I hacked it by getting the package id from the inplace file.
17:48:09 <dcoutts_> blackh: so for the inplace we have to use a package id with no hash because we pick it before compilation
17:48:54 <dcoutts_> and from the description of the problem and from memory I think we're still using that inplace one when we should be using the final one
17:48:57 <dcoutts_> or something like that
17:49:37 <dcoutts_> blackh: if we're not doing so already it might be a good idea to explicitly mark the inplace package ids using a "-inplace" suffix
17:52:08 <aavogt> what happens if somebody calls their package  foo-inplace?
17:53:30 <ivanm> aavogt: they'll be hung, drawn and quartered
17:53:33 <ivanm> ;-)
17:54:09 <blackh> dcoutts_: I'll do you a deal: If you look at my cabal-install patch, I'll look at this problem.
17:55:15 <dcoutts_> blackh: I'd be happy to, but I'll have to delay that deal for a few weeks yet
17:55:44 <dcoutts_> aavogt: the inplace version would get the id foo-inplace-inplace
17:55:55 <blackh> Wow! You are busy! Are there any other cabal maintainers?
17:56:15 <aavogt> I mean stripping the -inplace prefix, or that isn't necessary?
17:56:47 <dcoutts_> blackh: I'm the main maintainer, the ghc hackers sometimes apply some patches directly
17:57:08 <dcoutts_> blackh: last push on my PhD thesis, keeps me busy :-)
17:57:52 * nus applyes y-combinator to dcoutts_ 
17:58:25 <dcoutts_> hmm, would that be well-founded?
17:58:31 <ivanm> nus: so you're applying dcoutts_ on dcoutts_ on dcoutts_ on dcoutts_ ...
17:59:02 <nus> yeah given "continuous time" we could slice that as appropriate [-;
18:01:12 <blackh> The ghc 6.12 / ticket 89 issue is annoying me so it won't be long before I'm driven to fix it.
18:38:02 <philo> have a problem while linking with llvm
18:38:13 <philo> stdc++ can't be found
18:38:15 <philo> any idea ?
18:38:24 <Lemmih> philo: In ghci?
18:38:30 <philo> yes
18:38:34 <Lemmih> philo: LLVM can't be used from ghci.
18:38:58 <philo> just llvm or anything requiring stdc++ ?
18:39:06 <Lemmih> I don't know.
18:39:15 <philo> do you know why is that ?
18:40:47 <ivanm> because it hasn't been implemented
18:40:56 <ivanm> does any FFI work in ghci?
18:41:07 <luite> yes
18:41:11 <DBAlex> Hi
18:41:19 <DBAlex> I'm still stuck on my tree
18:41:22 <luite> but c++ libraries are a problem, at least on windows
18:41:33 <philo> what havent been implented ? FFI ?
18:41:35 <DBAlex> the type looks like this
18:41:35 <DBAlex> data Tree a = Node a [Tree a]
18:41:49 <philo> would hug work ?
18:41:57 <Lemmih> philo: Nope.
18:42:08 <philo> god
18:42:15 <ddarius> @src Tree
18:42:16 <lambdabot> Source not found. Maybe you made a typo?
18:42:19 <ivanm> DBAlex: any particular reason for imiplementing your own tree rather than using Data.Tree ?
18:42:46 <philo> any other way to debug haskell program without hug or ghci ?
18:42:48 <DBAlex> Umm, it's just because I am...
18:42:52 <ivanm> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-Tree.html
18:42:58 <DBAlex> Node ([[Cross,Nought,Cross],[Nought,Cross,Nought],[Cross,Blank,Blank]],Blank) [Node ([[Cross,Nought,Cross],[Nought,Cross
18:42:58 <DBAlex> ,Nought],[Cross,Nought,Blank]],Blank) [Node ([[Cross,Nought,Cross],[Nought,Cross,Nought],[Cross,Nought,Cross]],Cross) []
18:42:58 <DBAlex> ],Node ([[Cross,Nought,Cross],[Nought,Cross,Nought],[Cross,Blank,Nought]],Blank) [Node ([[Cross,Nought,Cross],[Nought,Cr
18:42:58 <DBAlex> oss,Nought],[Cross,Cross,Nought]],Cross) []]]
18:43:01 <DBAlex> theres some sample data
18:43:13 <DBAlex> what I want to ask is, how do I start at the end of the tree like that and "work upwards"?
18:43:21 * ivanm points out to DBAlex the existence of pastebins such as hpaste
18:43:23 <ivanm> @hpaste
18:43:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:43:23 <DBAlex> I don't think you can easily use foldr right?
18:43:33 <ivanm> DBAlex: see Data.Foldable
18:43:36 <DBAlex> ivanm: I know about pastebins, I'm just too tired, sorry
18:43:46 <DBAlex> without using anything external
18:44:04 <ivanm> then no
18:44:10 <ivanm> the default foldr is for lists only
18:44:17 <DBAlex> :/
18:44:24 <ivanm> the whole point of Data.Foldable is to implement the same kind of behaviour for other data types
18:45:06 <aavogt> it can be derived
18:45:14 <aavogt> you don't have to think anymore ;)
18:46:33 <DBAlex> :S
18:46:33 <breakspirit> would anyone happen to have a snippet of code that will find the longest string within a list of strings?
18:47:04 <aavogt> @type maximumBy (comparing length)
18:47:05 <lambdabot> forall a. [[a]] -> [a]
18:47:54 <ddarius> Probably better to do a Schwartzian transform there.
18:48:11 <aavogt> why would you want you code to be all black?
18:48:21 <breakspirit> thanks guys
18:48:24 <ivanm> aavogt: it can? :o
18:48:30 <ivanm> since when?
18:48:37 <aavogt> well that's what this schwartzian thing does
18:48:46 <ivanm> aavogt: I meant the deriving of Data.Foldable
18:49:43 <byorgey> aavogt: wouldn't that be schwarzian? =)
18:50:49 <aavogt>  -XDeriveFoldable exists in ghc-6.12
18:51:26 <ivanm> ahhh, an _extension_
18:52:34 <aavogt> hmm, seems I can't spell anymore
18:52:48 <aavogt> byorgey: well it's pronounced the same way anyways ;)
18:55:11 <drad> I assume some of you folks know your way around theoretical CS; is there any real difference between Operational Semantics and Denotational Semantics?
18:55:15 <drad> they seem like the same thing
18:55:21 <ddarius> drad: They are not.
18:55:35 <ivanm> @wn Operational Semantics
18:55:36 <lambdabot> *** "operational" wn "WordNet (r) 2.0"
18:55:36 <lambdabot> operational
18:55:37 <lambdabot>      adj 1: pertaining to a process or series of actions for achieving a
18:55:37 <lambdabot>             result; "operational difficulties"; "they assumed
18:55:37 <lambdabot>             their operational positions"
18:55:38 <lambdabot> [16 @more lines]
18:55:42 <ivanm> well, @wn is useless...
18:55:43 <ddarius> drad: Big Step Operational Semantics, though, is pretty much a syntactical variant of Denotational semantics.
18:55:52 <ivanm> we need a @cs dictionary plugin! ;-)
18:56:36 <aavogt> what it does vs what it is?
18:58:28 <Cale> http://www.uni-koblenz.de/~laemmel/paradigms0910/ -- Here's a course on operational and denotational semantics :)
18:59:16 <drad> ddarius: my understanding is that in OS, meaning of program is defined as the the effect of the program on a theoretical machine
18:59:32 <Cale> drad: Yeah
18:59:43 <drad> whereas in DS, meaning is defined as the effect of the program on a mathematical object
19:00:04 <ivanm> so what it does vs what it should do?
19:00:11 <ddarius> drad: The meaning -is- the mathematical object.
19:00:21 <Cale> Denotational semantics is about associating each program with a mathematical value, and ways that programs are composed with operations on mathematical values.
19:04:02 <drad> Cale: it's been a while since I actually tried to read a book on DS, but these "mathematical values" are something like (composable) functions, right?
19:04:32 <byorgey> for example.
19:04:32 <Cale> drad: They might be functions, they might be elements of particular partially ordered sets
19:06:02 <drad> Cale: you mean in the sense that if your program is (+ 1 2) it's a poset elt, and if it's \x -> (+ 2 x) it's a function?
19:06:28 <ddarius> drad: You can choose any mathematical object you want.
19:06:36 <drad> what I mean by that is saying that they're all functions is to say that all of the program fragments that are interesting are functions
19:06:37 <ddarius> drad: They can be naturals or categories or CPOs.
19:06:40 <dolio> They might be canonical lambda terms.
19:07:22 <ddarius> Reynolds has an interesting semantics using functors.
19:08:00 <drad> the particular model isn't really relevant to what I'm trying to figure out
19:08:49 <drad> here's my claim: it looks like both OS and DS boil down to operations on a virtual machine
19:09:04 <drad> and a virtual machine is just a mathematical object
19:09:16 <drad> sorry; s/virtual/theoretical
19:09:28 <ddarius> There is no "virtual machine" in denotational semantics and, again, denotational semantics doesn't have "operations" on anything, except via compositionality.
19:09:40 <philo> is it only c++ lib that have a probleme with ghci or all libs ?
19:09:44 <drad> it's just that in OS, you're trying to make the machine familiar to programmers, whereas in DS you're making it familiar to mathematicians
19:11:00 <ivanm> philo: I don't know of any other C++ lib that has haskell bindings
19:11:14 <ivanm> actually, I've used hmatrix in ghci, so it can't be fortran/C libs
19:11:31 <ivanm> (well, the bindings are probably via C rather than Fortran)
19:11:59 <philo> llvm bindins is said to use a C interface
19:12:14 <ivanm> *shrug*
19:12:16 <philo> it does reference any c++ libs directly
19:12:41 <drad> ddarius: for present purposes, the universe of sets is a valid example of a virtual machien
19:12:56 <dolio> Probably not. Binding directly to C++ libraries with the FFI is a pain (and probably fragile).
19:13:16 <dolio> Because you need to refer to the name mangling that a C++ compiler does.
19:13:35 <ddarius> drad: Well, if you want te expand the meaning of every term unto meaninglessness, then sure, you are right.
19:14:59 <philo> is this "bugs" documented somewhere ?
19:15:05 <drad> I don't think that's what I'm doing here
19:15:09 <drad> but it's not important
19:15:13 <drad> thanks
19:17:18 <breakspirit> hey guys, ive got this code at http://pastebin.com/FUxpKFrp  which will flatten a list of lists.  can anyone think of a good way to make it not include duplicate values without using union?
19:18:56 <copumpkin> no
19:19:01 <breakspirit> =/
19:19:03 <copumpkin> unless you want to put nub around it
19:19:12 <breakspirit> whats that
19:19:27 <copumpkin> > nub [1,1,1,1,5,3,25,1,5,11,1,5,2,1]
19:19:28 <lambdabot>   [1,5,3,25,11,2]
19:19:36 <DigitalKiwi> nipple mouse!
19:19:41 <copumpkin> it's not efficient though
19:19:42 <ivanm> or something similar
19:20:04 <dolio> It's as efficient as it can be. :)
19:20:06 <ivanm> if you allow Ord you can get more efficient versions
19:20:14 <copumpkin> yep
19:20:15 <breakspirit> would it not be easy to implement my own solution?  ie, not using built in code?
19:20:16 <dolio> Well, actually, I don't know that.
19:20:20 <ivanm> (even more if you know the list isn't too long)
19:20:30 <dolio> Asymptotically, though, it's as efficient as it can be.
19:20:46 <DigitalKiwi> http://xkcd.com/243/
19:20:47 <ivanm> dolio: agreed, if the only allowed restriction is Eq
19:22:00 <breakspirit> this is for an assignment and i cant use nub   =/
19:22:29 <gwern> there are tons of nub implementations
19:22:31 <gwern> I collect them
19:22:58 <breakspirit> hehe
19:23:05 <gwern> most interesting is probably andy gill's ord one derived using the worker-wrapper transforms
19:23:11 <tensorpudding> do you filter out the repeated ones?
19:23:13 <ivanm> gwern: oh? what is it?
19:23:15 <breakspirit> got one handy to direct me to?  ill be googling
19:23:29 <ivanm> breakspirit: have a look at what Data.Set does with fromList ...
19:23:34 <gwern> breakspirit: unfortunate4ly gill's blog got hacked, so you'd have to go into the internet archive
19:23:45 <gwern> ivanm: yeah. toList . fromList is one of the simplest and most common
19:23:52 <gwern> but it's unstable
19:23:59 <ivanm> gwern: I was trying to get him to work it out himself! ;-)
19:24:08 <ivanm> gwern: "unstable" in the sense that the order is changed>
19:24:09 <gwern> oh
19:24:16 <ivanm> s/>/?
19:24:27 <ivanm> oh, and it isn't lazy
19:24:32 <gwern> ivanm: basically. iirc it's unstable in comparison to nub . sort
19:24:45 * ivanm has used a foldr-like function with an accumulating Set of seen values
19:24:50 <ivanm> gwern: *nod*
19:25:13 <gwern> I've never needed stable sorts, so I don't really like paying the price for stability
19:25:21 <ivanm> @check \ xs -> nub (sort xs) == Set.toList (Set.fromList xs)
19:25:22 <lambdabot>   Not in scope: `Set.toList'Not in scope: `Set.fromList'
19:25:29 <ivanm> @check \ xs -> nub (sort xs) == S.toList (S.fromList xs)
19:25:30 <lambdabot>   "OK, passed 500 tests."
19:25:39 <ivanm> @check \ xs -> nub (sort xs) == S.toList (S.fromList xs)
19:25:40 <lambdabot>   "OK, passed 500 tests."
19:25:57 * twink has never seriously needed enough speed to care
19:26:00 <ivanm> how does one force a specific type in @check?
19:26:01 <gwern> ivanm: the qualified names are in Mueval/Context.hs, if you don't like guessing
19:26:02 <dolio> What price?
19:26:35 <ivanm> @check \ xs -> nub (sort xs) == S.toList (S.fromList $ asType [1] xs)
19:26:35 <lambdabot>   Not in scope: `asType'
19:26:45 <ivanm> @hoogle a -> a -> a
19:26:45 <lambdabot> Prelude asTypeOf :: a -> a -> a
19:26:45 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
19:26:45 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
19:26:50 <ivanm> @check \ xs -> nub (sort xs) == S.toList (S.fromList $ asTypeOf [1] xs)
19:26:51 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
19:26:56 <gwern> dolio: what, you think I've benchmarked it? of course there's a price: any time you demand more of an algorithm, you lose performance
19:26:57 * twink still hasn't found any meaningful description of timsort
19:27:02 <ivanm> :o
19:27:04 <gwern> a haskeller should know that
19:27:18 <dolio> Like python paying the price moving to timsort, which is stable, instead of some slower quicksort, which isn't?
19:27:25 <ivanm> @check \ xs -> nub (sort xs) == S.toList (S.fromList $ asTypeOf xs [1])
19:27:26 <lambdabot>   "OK, passed 500 tests."
19:27:31 <dolio> (Slower in general.)
19:27:40 * ddarius thinks in many cases stability is "free."
19:27:43 <ivanm> gwern: should know what?
19:28:14 <jcreigh> I've never really understood the point of a stable sort...if there was a specific ordering that was important, why wouldn't you just include that in your definition of your comparison function so the question would never arise?
19:28:14 <dolio> Radix sort is also naturally stable, and it's asymptotically faster than quicksort.
19:28:30 <roboshibby> what does side-effect free mean?
19:28:32 <gwern> ivanm: the less you specify about your program (eg. evaluation order) the more scope the compiler has to optimize. that it may be stupid, like perhaps the python example, is not disproof of the possibility
19:28:41 <ddarius> jcreigh: Enter imperative languages.
19:28:53 <jcreigh> ddarius: even there, I don't get it.
19:28:56 <ivanm> roboshibby: that a function of type Int -> Int -> Int can't launch nuclear missiles
19:28:57 <ivanm> ;-)
19:29:18 <jcreigh> ivanm: unless the missile is launched using unsafePerformIO, of course.
19:29:44 <ivanm> jcreigh: well, that's a wart that we generally ignore...
19:30:16 * twink notes that the sorting key may not be the only data in the items sorted, e.g. sortBy (comparing fst)
19:30:54 <ivanm> yup
19:31:08 <ivanm> twink: that's the example I was trying to think of ;-)
19:31:50 <dancor> jcreigh's point is still valid since that can easily be made to secondarily sort on snd
19:32:10 <ddarius> dancor: That may not be correct.
19:32:28 <dancor> like if snd isn't Ord?
19:32:49 <ddarius> dancor: If I'm given a list of pairs of (name, amount) transactions in order of occurrence, I probably do -not- want to sort on snd.
19:32:53 <dancor> or it could cost perf
19:33:10 <twink> The input may be permuted some other way. Stability reproduces that permutation.
19:33:11 <dancor> oh
19:33:31 <dolio> Like, project euler has at least one problem where you're supposed to order the positive integers according to the value some function takes at them, but the function isn't injective, so if you use a non-stable sort, and look only at the value of the function, you might get the wrong answer.
19:33:31 <dancor> right so the only way to get stability then would be to zip [1..] etc
19:33:55 <jcreigh> ddarius: that is a good point.
19:33:56 <dolio> Of course, you could bake that into the comparison in that case, I guess. But a stable sort gives it to you for free.
19:34:25 <dancor> mmhm
19:34:25 <jcreigh> I've never felt the need for such a thing, and I'm not sure depending on it is a good thing, but I guess it's there if you need it.
19:37:08 <dolio> Radix sort being stable is actually key to its proper functioning.
19:37:37 <dolio> Because the idea is that you sort based on part of the value in several passes.
19:37:55 <dancor> so is radix sort usually the winner for generic sort function?
19:38:28 <ddarius> Radix sort is not generic.
19:38:42 <dolio> And it's important that the order established in previous passes is preserved, because it's established the ordering for the lower-order bits.
19:39:03 <dolio> Yeah, it's not a comparison sort.
19:39:55 <dolio> It's probably not as fast as the usual comparison sorts in general, either.
19:40:07 <dolio> But if you know your values fall in a restricted range, it can be much faster.
19:41:44 <dolio> Like, sorting a Word8 array with radix sort is likely to be much faster than quick/mergesort.
19:44:18 <twink> I doubt that.
19:44:24 <dancor> bytestring uses counting sort
19:45:04 <twink> I think radixsort is often slower.
19:45:15 <Pseudonym> It depends on how it's implemented.
19:45:27 <Pseudonym> Radixsort sometimes has bad locality.
19:45:30 <twink> esp. for small lists
19:45:39 <Pseudonym> For small lists, use insertion sort.
19:46:13 <Pseudonym> But, of course, for small lists, quicksort would devolve to the fallback sort too.
19:46:44 <dolio> Yes, small lists make the higher overhead of radix sort show more, too.
19:47:01 <twink> "small" here goes up to well above that threshold; it has to be big enough for asymptotics to overwhelm constants
19:47:21 <Pseudonym> Right, and that's the central point: One sort does not fit all.
19:47:48 <Pseudonym> Quick sort is really bad if you're sorting distributed data across a cluster.
19:47:51 <ivanm> "One sort to, ummm, sort them all; ..."
19:47:55 <ivanm> ;-)
19:48:58 <Pseudonym> I had to write a sort subsystem for a database server once.  It had the interesting property that accessing a sort key was about 10,000 times more expensive than any other operation.
19:49:36 <Pseudonym> So you had to go to a lot of trouble to avoid needing full sort keys.
19:50:13 <breakspirit> guys i still cant figure out a way to implement a nub-equivalent without using built-in functions.  any hints?
19:50:43 * ddarius knows not of these "built-in functions."
19:50:48 <ivanm> breakspirit: ummm.... so you want to write it from _scratch_?
19:51:00 <ivanm> breakspirit: OK, let's do this one step at a time
19:51:05 <breakspirit> yeah, i must
19:51:12 <ivanm> we have a list (x:xs) and we want to make sure that xs doesn't contain x
19:51:15 <ivanm> how can we do that?
19:51:31 <breakspirit> i come from a c++ background and keep thinking of easy ways to do it there
19:51:45 * ivanm wonders if the Prelude is counted as "built-in functions"; if so, you have to write a fair amount of stuff...
19:51:45 <Axman6> by writing a function that removes a given x from lists!
19:51:52 <ivanm> Axman6: ssshhh!
19:51:58 <ivanm> and where were you this morning?
19:51:59 <Axman6> :P
19:52:02 <ivanm> you missed the meeting!
19:52:03 <breakspirit> id say we scan through xs and compare head xs to some value we carry along
19:52:16 <ivanm> breakspirit: I've already taken out the head; that's teh value x
19:52:16 <Axman6> i can;t make the meetings, that's why i met with clem yesterday
19:52:18 <ivanm> but yes
19:52:22 <ivanm> Axman6: ahhhh
19:52:30 <chipmonkpyro> is there a way to add a single element to the end of a list without doing something tedius like this:
19:52:32 <chipmonkpyro> .
19:52:33 <chipmonkpyro> reverse ((last p):(reverse ps))
19:52:35 <ivanm> Axman6: anyway, I'm prob. going to switch to wednesday arvos
19:52:43 <Pseudonym> Something that's useful to know is that if you have a list-shaped problem, then there are three general ways to do it.
19:52:46 <ivanm> chipmonkpyro: xs ++ [x]
19:52:51 <Pseudonym> :t snoc
19:52:52 <lambdabot> Not in scope: `snoc'
19:52:55 <ivanm> but it's not efficient (have to traverse the whole list)
19:52:55 <Pseudonym> Hmm.
19:52:59 <Pseudonym> Yes, xs ++ [x]
19:53:07 <ivanm> Pseudonym: there's no scoc operator pre-defined AFAIK
19:53:08 <Axman6> ivanm: more efficient than reverse ... reverse :)
19:53:10 <Pseudonym> Way #1: Built-in list-type functions.
19:53:11 <dolio> Anyhow, sorting a Word8 array might work in one pass, while a Word64 array might work in 8 passes. So the more you can constrain your data, the better it gets.
19:53:15 <Pseudonym> Way #2: Recursion.
19:53:16 <ivanm> Axman6: true
19:53:19 <Pseudonym> Way #3 is left as an exercise.
19:53:24 <ivanm> Pseudonym: heh
19:53:27 <dolio> (It being radix sort.)
19:53:32 <breakspirit> recursion is the way to go
19:53:34 <Pseudonym> Because it would give away too much for this problem.
19:53:42 <Axman6> i'd use xs ++ [x]
19:53:50 <Axman6> it's about as efficient as you'll get
19:54:36 <breakspirit> so im lost, all i got is that i remove a given x from xs, but how do i know to keep one of them
19:54:51 <breakspirit> ive been writing haskell for exactly 4 hours in my whole life btw
19:54:56 <ivanm> breakspirit: (x:xs) is already split up the list
19:55:01 <Pseudonym> That's four hours more enlightenment than most people.
19:55:04 <breakspirit> yeah
19:55:05 <ivanm> the head of the list is x, xs is the rest
19:55:10 <breakspirit> i got that
19:55:17 <Pseudonym> So xs is the part of the list that doesn't include x.
19:55:23 <ivanm> so all you have to do is remove all x values from xs, and then put x back on (after recursing)
19:55:31 <breakspirit> but may include duplicate x values
19:55:37 <breakspirit> hmmm
19:55:43 <chipmonkpyro> alright thanks guys i tried what you were saying before and it didn't load but i think i had a stupid typo; its working now
19:55:55 <ivanm> you probably had xs ++ x or something
19:56:11 <Pseudonym> chipmonkpyro, it was a type error, right?
19:56:19 <twink> remove x [] = [] ; remove x (y:ys) | x == y = remove x ys | otherwise = y : remove x ys
19:56:20 <Pseudonym> Do you still have a copy of the error?
19:56:26 <chipmonkpyro> i had like (xs)++([(x)]) just to be safe
19:56:35 <ivanm> Axman6: oh, and I'm still waiting for that drink :p
19:56:36 <Axman6> o.O
19:56:38 <chipmonkpyro> it was something else
19:56:38 <Pseudonym> That's one cool emoticon.
19:56:43 <Pseudonym> Right.
19:56:44 <Axman6> ivanm: you don't drink!
19:56:45 <Axman6> :P
19:56:59 <ddarius> Axman6: It's the principle of the matter.
19:57:00 <ivanm> Axman6: drink /= alcohol consumption ...
19:57:12 <ivanm> ddarius: exactly!
19:57:16 <breakspirit> whats that do, twink?
19:57:20 <Axman6> ivanm: when're you free?
19:57:32 <chipmonkpyro> unless your in ireland where everything is spiked with alcohol (even the ocean water)
19:57:35 <ivanm> Axman6: pretty much whenever (except monday nights)
19:58:04 <ivanm> chipmonkpyro: heh, I was in spain in january; it was hard enough asking for a coke in some places let alone asking them what they had that was non-alcoholic
19:58:04 <Axman6> you dirnk lemon, lime and bitters?
19:58:08 <ivanm> yup
19:58:14 <ddarius> "Whenever, except Monday nights, and alternate Thursdays, and the first Wednesday afternoon of each month."
19:58:20 <Axman6> right, we're going to the wig and pen tomorrow then :P
19:58:21 <ivanm> ddarius: heh
19:58:31 <ivanm> Axman6: good-o; next question: where's that?
19:58:42 <chipmonkpyro> pce im outtie
19:59:09 <Axman6> civic, about half way between ANU and the canberra centre
20:00:03 <Pseudonym> Just a suggestion, guys: #haskell-blah
20:00:15 <twink> breakspirit: It removes an element from a list.
20:00:42 <breakspirit> im playing with it, trying to figure out how to get that to run when my flatten function recurses
20:00:49 <breakspirit> functional programming is so funky
20:01:06 <Pseudonym> @quote trippy
20:01:06 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
20:01:14 <tensorpudding> funktional
20:01:19 <ivanm> Pseudonym: stop quoting yourself
20:01:25 <ivanm> it's beneath you!
20:01:25 <ivanm> :p
20:01:36 <Pseudonym> Nothing is beneath me!
20:01:39 <breakspirit> haha
20:02:18 <ivanm> Pseudonym: so... you're not standing on anything?
20:02:30 <Pseudonym> I stand on no platform.
20:02:43 <ivanm> so you don't even use the Haskell Platform...
20:02:55 <Pseudonym> Only for leverage.
20:03:14 <ivanm> aha
20:03:38 * hackagebot data-ordlist 0.4.3 - Set and bag operations on ordered lists  http://hackage.haskell.org/package/data-ordlist-0.4.3 (LeonSmith)
20:04:02 <jcreigh> If only Archimedes had had the Haskell Platform to stand on...
20:04:18 <ivanm> he would have moved the earth?
20:04:29 <jcreigh> ivanm: exactly. :)
20:04:34 <ddarius> He would have broke his lever.
20:04:39 <jcreigh> lol
20:04:41 <tensorpudding> what's the greek for "what is this shit"
20:04:42 <jcreigh> that too.
20:04:45 <Pseudonym> Or at least set things up so that it would move when demanded.
20:04:46 * ivanm wonders if it's possible to attach IRC nicks to package announcements so we could know who to badger about new releases...
20:05:09 <ddarius> ivanm: Just do it in your head.
20:05:25 <ivanm> ddarius: I have no idea who Leon Smith is for example
20:05:26 <jcreigh> Although if he had used Haskell, the earth wouldn't have actually moved until he looked at it afterwards.
20:05:31 <ddarius> ivanm: lpsmith
20:05:37 <ivanm> ahhh
20:05:47 <ivanm> not that I wanted to ask him something, but I have wanted to ask others
20:05:55 <ivanm> jcreigh: heh
20:07:07 <Pseudonym> tensorpudding: TI SKATA EINAI AUTO;
20:07:25 <Pseudonym> I think.
20:07:29 <Pseudonym> It's been a while.
20:10:34 <breakspirit> when someone writes Eq a => in a function, is that similar to including a library in C++"?
20:10:51 <ivanm> no
20:10:51 <ezyang> not... really
20:10:55 <breakspirit> whats it doing then
20:11:03 <ivanm> it means that that type needs to have the equality operator == defined upon it
20:11:04 <ivanm> e.g.
20:11:06 <ivanm> @src nub
20:11:06 <lambdabot> nub = nubBy (==)
20:11:09 <ivanm> I meant:
20:11:11 <ivanm> @type nub
20:11:12 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:11:16 <Pseudonym> breakspirit, it's like a concept in C++.
20:11:21 <Cale> breakspirit: It constrains the type variable a to range only over those types for which equality testing is possible
20:11:26 <Pseudonym> If you understand what a concept is.
20:11:33 <Axman6> breakspirit: it's a type constraint
20:11:34 <Cale> Do you understand type variables?
20:11:34 <breakspirit> ah, i get that
20:11:34 <Pseudonym> "Concept" in the STL sense.
20:11:39 <Axman6> :t (+)
20:11:40 <lambdabot> forall a. (Num a) => a -> a -> a
20:11:41 <ivanm> breakspirit: ^^ given a type a that has equality defined for it and a list of such values, thsi returns a list of values of that type
20:11:53 <Axman6> (+) can only be applied to types implementing the Num class
20:11:58 <breakspirit> kinda hard to wrap your head around
20:12:04 <Axman6> not really
20:12:07 <Axman6> you'll get it
20:12:13 <breakspirit> yeah, thanks guys
20:12:15 <Axman6> but, you need to forget C++ first
20:12:17 <Axman6> all of it
20:12:19 <Pseudonym> (Eq a) is like saying that a is Equality Comparable. http://www.sgi.com/tech/stl/EqualityComparable.html
20:12:19 <breakspirit> for real  =)
20:12:28 <Axman6> (not to learn haskell, just a necessity)
20:12:30 <Cale> I think it's important to understand ordinary uses of type variables (parametric polymorphism) first.
20:12:44 <Cale> So consider something like  length :: [a] -> Integer
20:12:46 <Pseudonym> Yes, I agree with Cale there.
20:12:52 <Pseudonym> Or reverse :: [a] -> [a]
20:13:00 <Cale> This says that the function length takes a list of values of any type, and produces an Integer
20:13:00 <Pseudonym> Or:
20:13:02 <Pseudonym> :t sortBy
20:13:03 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:13:08 <breakspirit> takes a list of type a and returns a list of the same type
20:13:18 <Cale> Yeah, in the case of reverse
20:13:20 <breakspirit> yeah
20:14:29 <Cale> However, the thing about values which could be any type at all is that you can do essentially nothing with them -- you're not allowed to inspect them in any way, only push them around and pass them along.
20:14:33 <breakspirit> "(filter (/= x) xs)"   what is that line doing?
20:14:48 <Cale> Selecting the elements of the list xs which are not equal to x
20:14:52 <ivanm> breakspirit: so, do you know what filter does?
20:14:55 <tensorpudding> given a list xs, remove all elements equal to x
20:14:57 <breakspirit> nope
20:14:57 <scutigera>  :t /=
20:15:01 <ivanm> @type filter
20:15:02 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:15:08 <Pseudonym> Incidentally, that thing that Cale just said is a very strong statement in Haskell.
20:15:13 <Axman6> > filter even [2..20]
20:15:14 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
20:15:17 <breakspirit> yeah, i understand that
20:15:18 <Pseudonym> reverse cannot do ANYTHING with the elements in the list.
20:15:25 <Pseudonym> That's actually a theorem.
20:15:25 <ivanm> breakspirit: ^^ given a predicate, traverse a list and only keep the elements of that list for which the predicate returns True
20:15:26 <roboshibby> axman woot
20:15:27 <Axman6> > filter (/= 3) [2..20]
20:15:28 <lambdabot>   [2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:15:39 <scutigera> :t /=
20:15:39 <Pseudonym> But that's advanced stuff.
20:15:40 <lambdabot> parse error on input `/='
20:15:48 <tensorpudding> :t (/=)
20:15:49 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:15:49 <scutigera> :t (/=)
20:15:50 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:15:57 <Axman6> @src Eq
20:15:57 <lambdabot> class  Eq a  where
20:15:57 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:16:02 <Cale> The type of reverse ensures us that the list that any element of the list it produces must be an element of the original list.
20:16:05 <ivanm> breakspirit: so filter (/= x) will remove all values equal to x from the list
20:16:07 <Cale> er oops
20:16:13 <Cale> *The type of reverse ensures us that any element of the list it produces must be an element of the original list.
20:16:27 <Cale> Now, how about sort?
20:16:41 <Pseudonym> Cale: sort or sortBy?
20:16:43 <Cale> You might at first think that sort would get a type like  [a] -> [a]
20:16:49 <Cale> Except that this doesn't work
20:17:00 <Cale> In order to sort the elements, we have to be able to compare them
20:17:07 <breakspirit> so, helper function?
20:17:16 <Pseudonym> Ah, I see where you're going.  Just ignore me.
20:17:17 * ivanm wonders when Cale is going to release his best selling "Cale's Guide to Haskell" :p
20:17:20 <scutigera> ivanm: all values _not_ equal, right ?
20:17:22 <Axman6> breakspirit: pay attention to Cale ;)
20:17:24 <Cale> And there are plenty of types, for example, functions,  for which we can't compare using (<)
20:17:38 <ivanm> scutigera: will _remove_ all values equal to x ;-)
20:17:39 <Pseudonym> ivanm: When there's a guarantee of it being best selling.
20:17:52 <scutigera> ivanm: *sigh*
20:17:58 <ivanm> Pseudonym: best selling to active participants of #haskell? :p
20:18:00 <Cale> So we need a way to say that sort will sort a list of values of any type for which we can define (<), and the other comparison operations.
20:18:13 <ivanm> scutigera: read more carefully! :p
20:18:19 <Pseudonym> ivanm: This is more of a service than a shrinkwrapped product, don't you think?
20:18:20 <breakspirit> ok, makes sense
20:18:30 <ivanm> Pseudonym: hmmm.... true...
20:18:36 <ivanm> so he needs to sell a Calebot? :p
20:18:41 <Cale> and so the real type of sort is  (Ord a) => [a] -> [a]
20:18:50 <scutigera> ivanm: why do that when I can look foolish instead ?
20:18:52 <Axman6> breakspirit: ok, so, can you explain what the type of sort means now?
20:18:58 <ivanm> scutigera: heh
20:19:00 <breakspirit> Ord means comparison must be doable?
20:19:01 <Axman6> :t sort
20:19:02 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:19:31 <Cale> Ord is a typeclass, which you can think of as a sort of predicate on types (something which might be true or false for any given type), together with some functions/values which are available whenever that predicate is true
20:19:41 <Cale> class Ord a where
20:19:49 <Cale>    (<) :: a -> a -> Bool
20:19:55 <Cale>    ... other comparison operations ...
20:20:00 <breakspirit> yeah'
20:20:02 <DBAlex> How do I detect the end of a list but recurse on the start ?
20:20:22 <ivanm> DBAlex: pattern match on [] to get the end of the list
20:20:22 <Cale> actually, a bit more than that, Ord is a subclass of Eq, which is the typeclass in which (==) and (/=) are defined
20:20:24 <tensorpudding> foo [] = something, foo (x:xs) = something foo something
20:20:27 <Pseudonym> @src Ord
20:20:27 <lambdabot> class  (Eq a) => Ord a  where
20:20:27 <lambdabot>     compare      :: a -> a -> Ordering
20:20:27 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:20:27 <lambdabot>     max, min         :: a -> a -> a
20:20:29 <DBAlex> Node b (s:[])
20:20:34 <Axman6> DBAlex: huh?
20:20:38 <DBAlex> something like that but S is only 1 elemeny?
20:20:41 <Cale> Yeah, there's the full definition
20:20:42 <DBAlex> *element
20:20:43 <ivanm> tensorpudding: that doesn't type match.... :p
20:20:50 <breakspirit> but just having Eq doesnt allow comparison?
20:20:51 <Cale> @src Eq
20:20:52 <lambdabot> class  Eq a  where
20:20:52 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:20:55 <ivanm> DBAlex: s:[] == [s]
20:21:06 <DBAlex> ah yes
20:21:09 <Cale> Right, it only allows us to tell if things are equal or not, and we need a bit more than that to sort.
20:21:13 <DBAlex> it's late, i'm forgetting the basics :)
20:21:20 <Axman6> breakspirit: Eq only allows you to tell if two things are equal, othing more
20:21:20 <DBAlex> ivanm: thx
20:21:24 <tensorpudding> DBAlex you should still include a case for []
20:21:29 <DBAlex> yes
20:21:30 <ivanm> heh
20:21:43 <tensorpudding> also, if you use [x] as a case, put it before (x:xs) because that will math (x:[])
20:21:43 <DBAlex> it's 04:21 here
20:21:48 <DBAlex> 0_0 <- Me
20:21:52 <tensorpudding> match*
20:22:02 <Axman6> breakspirit: ready for a quick break, while i blow your mind?
20:22:09 <breakspirit> haha yeah
20:22:12 <Axman6> @src (==)
20:22:12 <lambdabot> x == y = not (x /= y)
20:22:15 <Axman6> @src (/=)
20:22:15 <ivanm> @time DBAlex
20:22:15 <lambdabot> x /= y = not (x == y)
20:22:16 <lambdabot> Local time for DBAlex is Wed Mar 03 04:21:51
20:22:19 * ivanm double-checks
20:22:22 <ivanm> ;-)
20:22:28 <tensorpudding> how does lambdabot know that?
20:22:34 <Pseudonym> CTCP TIME
20:22:39 <tensorpudding> hmm
20:22:42 <Cale> If we define a new datatype, we can make it an instance of Eq or Ord either by adding "deriving (Eq, Ord)" to the end of its data declaration (because these classes are treated specially, and there's a bit of magic to have the compiler automatically write the "obvious" instances), or...
20:22:45 <ivanm> because lambdabot is all knowing!
20:22:51 <Cale> We can write an instance by hand, which would look like:
20:22:57 <Cale> instance Eq MyType where
20:23:00 <Cale>   x == y = ...
20:23:08 <Pseudonym> @faq Can Haskell answer any question?
20:23:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:23:18 <Cale> Of course, the definition will look different depending on what I want the equality test to do.
20:23:48 <scutigera> @faq mutually recursive modules
20:23:48 <lambdabot> The answer is: Yes! Haskell can do that.
20:23:50 <Axman6> x == y = not (x /= y) = not (not (x == y)) = not (not (not (x /= y))) = ...
20:24:10 <Cale> Those are just the default implementations, which are used when you provide none in an instance
20:24:32 <tredontho> Suppose I want to have a type like so:  data Node a = Node a a a a, but a should only be a numeric type... can I do this?
20:24:35 <aavogt> scutigera: not very well thouth
20:24:39 <Cale> (The definitions of (==) and (/=) as reported by lambdabot)
20:24:53 <absentia> Dear Haskell:  How do we reverse the increasing entropy of the universe?
20:25:00 <breakspirit> well thank you very much for that thorough explanation  =)
20:25:08 <ivanm> tredontho: generally, you restrict your functions, not your type
20:25:10 <Cale> tredontho: You can, but it's usually best to constrain the types of your functions rather than the type of the data constructor
20:25:20 <ivanm> because even if you restrict the type you still have to restrict the functions as well
20:25:21 <lambdabot> absentia: There is as yet insufficient data for a meaningful answer.
20:25:28 <ivanm> and then you remove the generality of your type
20:25:33 * absentia sighs.  you can ask it anything.
20:25:53 <absentia> forget global warming, /me is afraid of heat death.
20:25:54 <ivanm> e.g. the Complex type could have been used for gaussian integers, etc. except they restricted it to floating point values
20:26:04 <ivanm> absentia: ala asimov?
20:26:15 <tredontho> cale, ivanm: okay, i thought that might be the way to go, just wasn't sure.  thanks!
20:26:26 <ivanm> no worries
20:26:37 <breakspirit> the function nub, where is that from?  i couldnt use it without having to find the code online and copying it.  so, why is it not plaigarism?
20:26:41 <absentia> ya.  it's great to be on a channel where people have a depth of knowledge and culture.
20:26:41 <scutigera> ivanm: let there be light
20:26:44 <tensorpudding> you could define your own datatype for gaussian integers
20:26:45 <Pseudonym> @src nub
20:26:45 <lambdabot> nub = nubBy (==)
20:26:48 <ivanm> yup
20:26:50 <Pseudonym> @src nubBy
20:26:51 <lambdabot> nubBy eq []             =  []
20:26:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:26:58 <Pseudonym> So nubBy uses filter.
20:27:14 <ivanm> Pseudonym: how else would you do it?
20:27:20 <tensorpudding> @src filter
20:27:20 <lambdabot> filter _ []     = []
20:27:20 <lambdabot> filter p (x:xs)
20:27:20 <lambdabot>     | p x       = x : filter p xs
20:27:20 <lambdabot>     | otherwise = filter p xs
20:27:21 <ivanm> delete only removes the _first_ value that's equal
20:27:28 <ivanm> (which is a pain)
20:27:30 <ivanm> @src delete
20:27:30 <lambdabot> delete = deleteBy (==)
20:27:32 <ivanm> @src deleteBy
20:27:32 <lambdabot> deleteBy eq x []        = []
20:27:33 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
20:27:35 <Pseudonym> ivanm: I'd use method #3.
20:27:47 <Pseudonym> Because I grew up with Miranda, where it was more convenient to do so.
20:27:49 <ivanm> Pseudonym: which is an implicit filter anyway
20:27:52 <Pseudonym> Yeah.
20:27:53 <ivanm> heh, fair enough
20:28:25 <scutigera> mutually recursive modules:  use {-# SOURCE #-} and *.hs-boot.  Seems quite klugey, but that's in the ghc manual.  more elegant solutions ?
20:28:33 <aavogt> was Curry's mum named Miranda or something?
20:28:37 <Pseudonym> I love it that Asimov short stories count for "depth of knowledge and culture" rather than "a nerdy teen phase".
20:28:52 <Pseudonym> aavogt: No.  Miranda is a character in The Tempest.
20:28:55 <aavogt> Pseudonym: they count for both
20:29:06 <tensorpudding> Miranda is a planet
20:29:18 <tensorpudding> it's also a moon of Uranus
20:29:19 <Pseudonym> Miranda uttered the line "O brave new world".
20:29:28 <ivanm> scutigera: un-recurse them
20:29:29 <Pseudonym> I believe that's the reason for it.
20:29:35 <ivanm> using a 3rd "internal" module
20:29:42 <aavogt> fix ghc
20:29:52 <ivanm> Pseudonym: "nerdy teen phase"? :o
20:29:57 * ivanm still reads them
20:30:04 <Pseudonym> And I believe that Phil Wadler's language was called Orwell because he mistook Orwell for Huxley.
20:30:12 <ivanm> heh
20:30:38 <aavogt> is the difference drugs?
20:30:41 <scutigera> ivanm: yeah- then I end up with a third module with a bunch of functions labeled prefix1_, prefix2_, etc.. also not satisfying.
20:30:52 <tensorpudding> cordelia, ophelia, miranda, cassandra
20:31:06 <ivanm> scutigera: heh
20:31:16 <ivanm> yeah, I've just come across a similar problem with my own code
20:31:18 * SamB_XP is a bit disappointed that Lio celebrated Dr. Seuss's birthday but Google didn't :-(
20:31:20 <Pseudonym> ivanm: So do I, occasionally.  But Asimov couldn't write a good character to save himself.  I've moved on to Neal Stephenson.
20:31:28 <ivanm> I could have an internal module, but then I'm worried that the haddock docs won't match up
20:31:35 <scutigera> ivanm: yeah - the example in ghc is almost precisely what I'm trying to do.
20:31:36 <tensorpudding> except i don't think cassandra was in any shakespeare
20:31:49 <scutigera> tensorpudding: Serenity
20:32:05 <ivanm> Pseudonym: eh, I don't read his books for characters (though the later foundation ones really are awful in terms of character development; can anyone say "obligatory sex scenes"?)
20:32:12 <tensorpudding> was thinking desdemona
20:32:20 <ivanm> I've read cryptonomicon + one more of neal stephenson's (can't remember which though)
20:32:33 <ivanm> right now I'm really liking David Weber and John Ringo
20:32:43 <scutigera> ivanm: Snow Crash !
20:32:59 <breakspirit> well im gonna take off.  thanks again guys!
20:33:18 <Pseudonym> ivanm: Just finished book 2 of The Baroque Cycle.
20:33:26 <ivanm> scutigera: oh, that was him? then there's 3 of his books I've read
20:33:38 <ivanm> Pseudonym: main reason I don't read much of his stuff: hard to find in the library :s
20:33:55 <ivanm> also, the newer ones are so damn big and my back has had enough of me carrying big books everywhere with me... >_>
20:34:15 <scutigera> ivanm: I like Diamond Age too.  Any fiction that works in Turing is a good book :-)
20:35:39 <roboshibby> sex scenes are lame
20:36:18 <aavogt> depends how old you are
20:36:32 <DBAlex> Hi
20:36:33 <DBAlex> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23193#a23193
20:36:41 <roboshibby> imo, regardless of age
20:36:51 <tensorpudding> i read that as Tree Beard
20:37:01 <Pseudonym> #haskell-literary-criticism
20:37:10 <ezyang> DBAlex: What's the question?
20:37:11 <DBAlex> It's too late now and i'm tired, so I just wanted to ask is this code really getting to the end of the list then working backwards? :S
20:37:26 <DBAlex> sorry..
20:38:12 <DBAlex> it should get to the end of the list then recurse with the start of the list again
20:38:17 <DBAlex> until it reaches the start
20:38:51 <ivanm> roboshibby: especially when they're gratuitous
20:39:16 <roboshibby> ivanm, been watching waynes world?
20:39:17 * ivanm has no idea what DBAlex is doing there
20:39:22 <ivanm> roboshibby: nope, never seen it
20:39:23 <DBAlex> :(
20:39:30 <roboshibby> oh
20:39:39 <DBAlex> ezyang:
20:39:40 <DBAlex> ?
20:39:46 <ivanm> DBAlex: what happens if I pass in a Tree Board value with an empty list of sub-trees?
20:40:25 <DBAlex> hmm
20:40:35 <ivanm> DBAlex: and I think your if statement there is useless
20:40:37 <DBAlex> it would return the winning board
20:40:44 <ezyang> ==ivanm. The base case is kind of sketchy
20:41:22 <ivanm> huh? why are you converting me into a function? :p
20:41:34 <DBAlex> ezyang: any idea if it's actually working?
20:41:39 <ivanm> and I have no idea what DBAlex is doing, so can't tell if the base case is sketchy
20:41:52 <DBAlex> getting to the bottom of a tree and working upwards
20:42:04 <ivanm> no, no, no
20:42:08 <ivanm> what is labelbase meant to be doing?
20:42:09 <tensorpudding> this is the Data.Tree tree isn't it?
20:42:14 <ivanm> tensorpudding: no
20:42:18 <ivanm> for some reason he's writing his own
20:42:21 <roboshibby> did any of you guys see the film "where the wild things are" ?
20:42:30 <ivanm> what is that kind of traversal called?
20:42:34 <ivanm> roboshibby: nope
20:42:48 <ddarius> #haskell-blah perhaps
20:42:51 <ivanm> but from memory, the book is way too short for a movie...
20:42:51 * ezyang politely suggests #haskell-blah 
20:43:03 <ivanm> ddarius: yeah, I suppose
20:43:16 <jamamooga> Hello. I am not sure if I understand this correctly, do the single quotes mean that those types are strict & the commas a list seperator?: (***) :: a b c -> a b' c' -> a (b, b') (c, c')
20:43:25 <Pseudonym> jamamooga:
20:43:27 <Pseudonym> No
20:43:38 <DBAlex> ezyang: any idea how do to that? get to the end and then recurse the whole list again, until we get to the front?
20:43:46 <Axman6> jamamooga: ' is a valid part of any variable name in haskell
20:43:49 <Pseudonym> Haskell has different identifier rules than most languages.
20:43:50 <Pseudonym> Right.
20:43:51 <tensorpudding> strictness annotations include !, if you have BangPatterns turned on
20:43:54 <Pseudonym> f and f' are just different names
20:44:11 <jamamooga> ok
20:44:17 <ezyang> DBAlex: The classic way to do this is to build up a number of lambdas, and then evaluate them on the way out
20:44:29 <ezyang> I haven't looked closely enough to tell if your code is doing that.
20:44:35 <Pseudonym> By convention, b and b' should be related somehow.
20:44:42 <Pseudonym> But it's just a convention.
20:44:42 <Axman6> jamamooga: and the ,'s are from tuples
20:44:43 <tensorpudding> what is labelb?
20:44:58 <DBAlex> ezyang: ok
20:45:00 <jamamooga> Oh thanks
20:45:35 <ezyang> DBAlex: You've omitted labelall
20:45:47 <DBAlex> yeah
20:45:52 <DBAlex> nvm
20:45:52 <DBAlex> :s
20:45:53 <DBAlex> argh
20:45:57 <DBAlex> I need some sleep
20:46:02 <ezyang> go get some sleep :-)
20:46:05 <ezyang> tomorrow's always waiting
20:46:05 <DBAlex> and thinking time 0_o
20:46:19 <DBAlex> cya
20:47:16 <jamamooga> I have been trying to learn F# & Haskell at the same time, translating Haskell to F#, but my background is in C# & Scheme. I find both F# & Haskell hard to read & hard to remember the syntax.
20:47:46 <Axman6> well, learn one
20:48:11 <tensorpudding> they grow on you a bit
20:49:00 <jamamooga> I have a massive collection of articles on progamming on my hard drive.
20:49:25 <Axman6> that's a horrible way to learn
20:49:52 * hackagebot glpk-hs 0.2.2 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.2.2 (LouisWasserman)
20:50:15 <jamamooga> Haskell is the style of programming I want, but I want to put something on silverlight.
20:50:36 <SamB_XP> jamamooga: nobody wants to install that
20:52:19 <tensorpudding> F# has some major differences with Haskell, despite them both being predominantly functional languages (not that it's not worth learning both)
20:52:55 <SamB_XP> one would think that having such differences would make it MORE likely to be worth learning both ...
20:53:46 <jamamooga> It is much easier than translate Haskell to C#, which is why I switched to F#.
20:55:55 <jamamooga> Since I am trying to implement a language with a similar functional style to Haskell I wanted to write it closer to it so I wouldn't have to implement as much right away.
21:03:28 <tensorpudding> F# is a lot more like ocaml than Haskellf
21:06:06 <ivanm> well, F# is based on OCaml
21:06:21 <ivanm> since Haskell didn't lend itself well to being on .Net and interoperating with other .Net languages
21:06:46 <blackh> H#! Bring it on!
21:07:01 <SamB_XP> I heard H# would be really slow
21:07:17 <jamamooga> Sure is
21:12:48 <tensorpudding> it'd be interesting if someone tried though
21:13:09 <ablmf> How to convert Int to Integer?
21:13:39 <c_wraith> I don't see, immediately, why H# would be horrible, performance-wise.  It would take a big chunk of effort, though.  It also would require an interesting interface to other code, in order to make default laziness interact with default strictness
21:13:39 <Cale> fromIntegral
21:13:41 <scutigera> fromIntegral
21:13:51 <scutigera> Cale: cursed lag
21:14:14 <ivanm> c_wraith: and purity vs imperative
21:14:55 <Gracenotes> toInteger, even
21:15:05 <scutigera> :t toInteger
21:15:06 <lambdabot> forall a. (Integral a) => a -> Integer
21:15:15 <scutigera> :t fromIntegral
21:15:16 <lambdabot> forall a b. (Integral a, Num b) => a -> b
21:15:21 <tensorpudding> if they were creative, it could be a very different language than Haskell
21:15:30 <Cale> http://hackage.haskell.org/package/hs-dotnet -- Has anyone tried this?
21:15:46 <Gracenotes> fromIntegral is jjust fromInteger . toInteger, fromInteger doing nothing here
21:15:52 <tensorpudding> but still similar enough that you could easily switch between the two
21:16:11 <c_wraith> It's fair to say that MS has some very creative people working for them, in terms of language design.  SPJ, for instance. :)
21:16:35 <Axman6> c_wraith: luckily they don't notice :P
21:17:26 <ivanm> Cale: which one is that one? :p
21:17:34 <ivanm> because there's also salsa and one other IIRC
21:17:42 <ivanm> not that I've used any of them...
21:17:48 <ivanm> since I have no need to pollute my Haskell
21:19:55 <SamB_XP> Axman6: lucky for who?
21:20:21 <SamB_XP> and I thought they were *supposed* to have creative people in MSR
21:20:42 <Axman6> but if they don't get noticed, they can keep working on stuff they like ;)
21:20:50 <SamB_XP> ah, okay, that then ;-p
21:21:36 <SamB_XP> unlike those poor Self researchers Sun pulled off Self to help with the JVM JIT :-(
21:23:06 <ivanm> what's Self?
21:23:08 <tensorpudding> java java everywhere, but not a drop to drink
21:23:42 <MatrixFrog> Self is yet another programming language. there are way too many
21:23:49 <SamB_XP> ivanm: an interesting Smalltalk-family language
21:24:06 <SamB_XP> with an even more interesting approach to IDE
21:24:28 <ivanm> hmmm...
21:24:56 <ivanm> MatrixFrog: well, it's not our fault if people don't agree that Haskell is the best language around and they keep playing with all those other ones...
21:24:58 <ivanm> ;-)
21:24:58 <SamB_XP> unfortunately it's rather hellish to get it running on x86 :-(
21:25:35 <pikhq> ivanm: Hey, Haskell is not the best language around. Haskell is the only language around. All others are but mockeries.
21:25:37 <jcreigh> okay guys, what I am doing wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23194
21:25:42 <ivanm> I also like the heh
21:25:58 <ivanm> whoops, two messages got mixed up there :s
21:27:17 <tensorpudding> is there such thing as a boring language, or just boring programs?
21:27:35 <MatrixFrog> i think both definitely exist
21:27:35 <jcreigh> I'm trying to use the LLVM bindings, but I get an error when I run my test program: "user error (Unable to find target for this triple (no targets are registered))"
21:28:14 <SamB_XP> jcreigh: but it doesn't say anything about what triple ?
21:28:37 <roboshibby> what's a triple
21:28:40 <jcreigh> SamB_XP: that's the whole error. you can see the source of my program in the paste.
21:28:43 <jcreigh> roboshibby: no idea.
21:28:49 <SamB_XP> I suspect i386-linux-gnu is one such?
21:28:53 <roboshibby> i wonder if it's like, a tuple, but 3
21:28:58 <jcreigh> SamB_XP: yeah, I'm thinking maybe so.
21:29:18 <SamB_XP> roboshibby: in general, it is indeed a 3-tuple
21:29:25 <SamB_XP> just like a pair is a 2-tuple
21:29:35 <jcreigh> haha, found it.
21:29:40 <SamB_XP> but the obvious question is "a triple containing what 3 things?"
21:29:48 <jcreigh> that magic sauce is to call "initializeNativeTarget" before using the LLVM JIT.
21:30:01 <jcreigh> why it couldn't just assume I want to JIT for the machine I'm running on, I don't know.
21:30:45 <roboshibby> hm yea, strange
21:30:55 <SamB_XP> you might want to JIT for a GPU or something ???
21:31:12 <SamB_XP> (only of course how could you do that?)
21:31:13 <roboshibby> maybe, but why not assume 'self' ?
21:31:33 <roboshibby> seems reasonable to me.
21:31:38 <SamB_XP> maybe it's just that it has to know what target it's targetting before it realizes you want it to JIT ?
21:32:14 <roboshibby> ?
21:32:32 <jcreigh> All I have to go on is this: http://markmail.org/message/5yvsemy2ivwmn37w
21:32:36 <jcreigh> I try it, it magically works.
21:32:59 <roboshibby> else { "initializeNativeTarget" } <- and done
21:34:33 <jcreigh> I suppose if I *really* wanted to know, I could resort to reading the docs instead of trying to copy tutorials from year-old blog posts. :)
21:36:19 <SamB_XP> sounds drastic!
22:02:52 <decker> man, if anyone made it through chapter 3 of "real world haskell" on the first try then they're a god
22:03:11 <decker> can I expect this thing to get even worse at this point?
22:03:45 <Axman6> what's chapter 3?
22:03:55 <decker> and would there be any similar texts freely available online?  that would probably help a great deal
22:04:04 <decker> Axman6: the 3rd chapter of the book
22:04:17 <Axman6> yes, what's covered in the chapter
22:04:59 <decker> Axman6: types, polymorphic types, recursion, errors, Maybe
22:05:12 <decker> probably some other things I'm forgetting
22:05:18 <Axman6> so, all the important stuff ;)
22:05:45 <Axman6> you've basically named the bread and butter of programming in haskell, minus the errors
22:06:22 <copumpkin> omnom
22:11:30 <ivanm> decker: RWH is online... >_>
22:11:58 <Axman6> for free
22:12:05 <decker> uh...right
22:15:23 <Axman6> heh
22:15:25 <Axman6> whoops
22:15:45 <stevenmarky> wat
22:16:55 <ivanm> yes, RWH is online for free
22:21:01 <wSogeking> hi, is there a program which can check my haskell files and convert them for unix ghci format and/or fix any formatting issues?
22:21:06 <wSogeking> btw I am on linux.
22:21:18 <ivanm> not sure what you're asking
22:21:23 <ivanm> what is "unix ghci format"?
22:21:34 <ivanm> do you mean newline issues?
22:21:49 <ivanm> if so, see unix2dos and dos2unix
22:22:09 <ivanm> the thing to watch out for is tab characters: as such it is recommended that you use spaces and not literal tab characters
22:23:37 <wSogeking> well I am using dos2unix
22:23:43 <wSogeking> but oddly it doesnt do anything.
22:24:52 <ivanm> maybe there's nothing to do?
22:24:59 <ivanm> what kind of problems do you have?
22:25:09 <ivanm> maybe it's mac newlines
22:25:17 <Axman6> nothing uses mac newlines
22:25:58 <ivanm> Axman6: :o
22:26:12 <ivanm> I've had problems before trying to use python (on linux) to process data saved on a mac
22:26:15 <copumpkin> mac os 9 and under did
22:26:22 <copumpkin> it hasn't been common for a decade
22:26:22 <ivanm> this is OSX
22:26:26 <Axman6> afaik, macs have used unix newlines since OS X, possibly before
22:26:27 <copumpkin> osx is unix
22:26:36 <copumpkin> it uses \n
22:26:44 <ivanm> in the end I had to read the whole file in and do newliens that way
22:26:52 <ivanm> copumpkin: hmmm.... maybe some kind of conversion error th en...
22:26:54 <ivanm> *then
22:27:07 <copumpkin> maybe it was files that passed through osx from windows?
22:27:10 <copumpkin> and you were getting \r\n?
22:27:29 <wSogeking> Hmm I think my errors ar not unix based (or were but I fixed them and also have other ones)
22:27:50 <ivanm> copumpkin: yeah, could be
22:27:59 * ivanm figures its time he headed off home
22:28:06 <ivanm> bye all
22:28:10 <Axman6> o/
22:31:00 <stelleg> anyone know how to make a hungry function (i.e. one with infinite type) using data constructs?
22:31:19 <ablmf> Is it possible to test if a number is squre of an unknow integer without caculating its root ?
22:31:46 <Axman6> sure, check all numbers n until n*n >= m
22:32:21 <ablmf> Axman6: That shall be faster than caculating root?
22:32:37 <Axman6> doubtful
22:32:46 <FauxFaux> RUle 1.
22:35:06 <Cale> stelleg: something like  newtype Rec a = In { out :: Rec a -> a } ?
22:35:07 <wSogeking> What does "Lexical error at character '\8217' mean?
22:35:15 <copumpkin> ouch
22:35:39 <copumpkin> that's a pretty hungry function
22:36:04 <Cale> ablmf: You can do a binary search.
22:36:30 <stelleg> hmm, I'm not familiar with newtype
22:36:41 <Cale> stelleg: Well, you can replace it with data if you want
22:36:57 <copumpkin> stelleg: what do you need it for, out of curiosity?
22:37:08 <FauxFaux> wSogeking: It means your compiler haets the unicodes in your file.
22:37:11 <stelleg> copumpkin: curiosity ;)
22:37:14 <Cale> stelleg: It's similar to data, except that (In undefined) is semantically equivalent to undefined
22:37:14 <copumpkin> :)
22:37:25 <Cale> y :: (a -> a) -> a
22:37:26 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:38:12 <copumpkin> Cale: are there any other uses of that type other than building fixpoint combinators out of it?
22:38:23 <Cale> copumpkin: Not that I'm aware of.
22:38:45 <copumpkin> I guess you can do most things with a fixed point combinator so my question isn't terribly interesting
22:39:40 <dolio> I think I've seen an article/paper on something like "hyperfunctions" which turned out to be that type, or something like it.
22:39:48 <dolio> I don't remember what they were for, though.
22:39:51 <stelleg> Cale: I still get occurs check with that code
22:40:06 <Cale> stelleg: Weird. It compiles fine for me.
22:40:35 <stelleg> ah
22:40:38 <Cale> Actually, that's a bit of a lie
22:40:38 <stelleg> I lied
22:40:41 <stelleg> i replaced the lambda's
22:40:42 <Cale> heh
22:40:43 <copumpkin> lol
22:40:47 <copumpkin> two liars
22:40:50 <stelleg> hah
22:40:59 <Cale> It puts the inliner into an infinite loop in some cases.
22:41:20 <copumpkin> something similar to that also used to kill @pl
22:41:38 <stelleg> I get infinite loop for y id 3
22:41:39 <copumpkin> well, kill all of lambdabot
22:41:55 <Cale> Well, of course
22:42:03 <Cale> y id  is an infinite loop on its own
22:42:21 <copumpkin> y const 3
22:42:27 <copumpkin> try that
22:42:33 <Cale> y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:42:36 <Cale> or that :)
22:43:05 <stelleg> hmm
22:43:20 <Cale> y (1:)
22:43:38 <Cale> (thankfully this works in ghci)
22:43:44 <stelleg> haha
22:44:10 <Cale> > let y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:44:11 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) (L.Mu f)
22:44:16 <Cale> oh, duh
22:44:21 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (out x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:44:22 <lambdabot>   Couldn't match expected type `L.Mu f'
22:44:22 <lambdabot>         against inferred type `L.Rec a'
22:44:26 <copumpkin> aw
22:44:30 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:44:31 <lambdabot>   3628800
22:44:33 <Cale> missed one :)
22:44:37 <copumpkin> fancy
22:44:46 <copumpkin> :t inR
22:44:47 <lambdabot> Not in scope: `inR'
22:44:49 <copumpkin> :t InR
22:44:50 <lambdabot> forall a. (Rec a -> a) -> Rec a
22:44:57 <dolio> I guess it must not have been "hyperfunction" because the google hits for those aren't what I was thinking of.
22:44:58 <Cale> :t outR
22:44:59 <lambdabot> forall a. Rec a -> Rec a -> a
22:45:23 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (1:)
22:45:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:46:01 <dolio> Those extra constructors are so ugly! OCaml FTW!
22:46:07 <stelleg> I'm impressed Cale
22:46:43 <Cale> It's sort of the standard trick for recovering recursion at the value level when given recursion at the type level.
22:47:59 <copumpkin> {-# LANGUAGE IsorecursiveTypes #-}?
22:48:06 <stelleg> but isn't it to bypass the limitation of the type system?
22:48:15 <dolio> Haskell types are isorecursive.
22:48:20 <copumpkin> Equi?
22:48:28 <dolio> Equi is what OCaml has.
22:48:44 <copumpkin> I'll pretend I wrote that up there then
22:48:55 <dolio> And, I have it on good authority that everyone uses -rectypes with OCaml, so they can write down y combinators.
22:49:05 <copumpkin> excellent
22:49:09 <Cale> stelleg: That Rec type is defined in Haskell's type system. I suppose it gets around the fact that infinite types are normally considered a type error.
22:49:16 <copumpkin> seems like it would make all that *morphism stuff more pleasant too
22:49:27 <copumpkin> I hate unwrapping and rewrapping my moos
22:49:30 <copumpkin> or my noos
22:49:36 <Cale> (though you really don't want infinite types to be accepted normally -- most of the places where they happen really are type errors)
22:49:51 <stelleg> Cale: right, I didn't mean to imply it was a design flaw
22:50:03 <dolio> Do you hate it more than you hate all the bugs the occurs check catches?
22:50:45 <copumpkin> how about a local change?
22:51:17 <copumpkin> equitype Mu f = f (Mu f)
22:51:58 <stelleg> Cale: thanks for all that
22:52:15 <dolio> Equirecursive types aren't necessarily bad if they're never inferred, and you have to write down explicit signatures for them.
22:52:21 <stelleg> now I'll go spend tomorrow trying to understand what all of that meant
22:52:31 <dolio> But I also have it on good authority that OCaml programmers never write type signatures for anything.
22:52:42 <dolio> Because it's code bloat.
22:52:54 <Saizan> copumpkin: something like that would be interesting to try out
22:53:23 * copumpkin runs off to /r/haskell_proposals
22:53:24 <copumpkin> :P
22:53:28 <copumpkin> anyway, gotta go now, bbl
22:53:48 <ski> cf. 7 An overview of Hugs extensions <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> 7.3.5 Restricted type synonyms
22:54:01 <Saizan> though you end up with signatures i guess, since there's no value level part to let it infer Mu
22:54:21 <dolio> Of course, GHC's inliner also depends on the fact that you can't write stuff like (\x -> x x) (\x -> x x), as I recall.
22:54:24 <lhames> Hi all. I've got a Haskell-newbie regex question. Is there a method for regex matching and substitution in any of the Text.Regex.* packages, or is the standard procedure to roll your own using =~ as a base?
22:54:43 <dolio> I think that will send it into an infinite loop.
22:55:48 <Saizan> yeah, Cale's y above gives you an infite loop with -O2,
22:55:49 <Axman6> dolio: it will
22:56:32 <Nomad010> do you guys know unic0re is spamming?
22:56:41 <Saizan> no
22:56:58 <Nomad010> pm spam
22:56:58 <Axman6> not here he isn't
22:57:08 <Axman6> well, tell a freenode staffer
22:57:11 <Nomad010> ok
22:57:18 <Axman6> in #freenode
22:57:18 <Nomad010> couldn't be bothered
22:57:18 <dobblego> Nomad010, in privmsg?
22:57:21 <Nomad010> ya
22:57:35 <dobblego> Nomad010, please privmsg the spam message you received
22:59:04 <Saizan> anyhow, we could infer only strictly-positive equi-recursive types.
22:59:57 <dolio> That still lets you infer stuff like a ~ [a].
22:59:59 <Saizan> without rejecting something like "mu x. f x" until 'f' gets instantiated
23:00:10 <Saizan> ah
23:00:13 <dolio> Which is an easy typo bug.
23:00:17 <SnailRacer> Data.Yaml.Syck (HsSyck) seems to return corrupted strings in windows, is there a Yaml package known to work with haskell in windows?
23:00:28 <Saizan> true
23:03:01 <dolio> @type callCC return -- it would be nice for this
23:03:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
23:03:03 <lambdabot>       Expected type: m a
23:03:03 <lambdabot>       Inferred type: m (a -> m b)
23:03:17 <dolio> That isn't strictly-positive, though.
23:04:31 <Saizan> @type callCC
23:04:32 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
23:06:03 <Saizan> so you'd get a continuation that wants another continuation out of that?:)
23:07:11 <dolio> That's used for making a label of sorts.
23:08:00 <dolio> do here <- callCC return ; ...
23:08:12 <dolio> Calling 'here' jumps back to 'here'.
23:08:29 <dolio> At least at first.
23:09:18 <dolio> I think monadLib actually has a type for it.
23:09:37 <Saizan> yeah, but what do you give to here?
23:11:20 <dolio> I suppose it may be less useful in a typed language.
23:11:34 <dolio> Or you need to couple it with something besides just a continuation.
23:15:55 <ablmf> When I try to install QuickCheck, I got this error : Setup.lhs: At least the following dependencies are missing:
23:15:56 <ablmf> mtl -any
23:16:12 <ablmf> But I think mtl is a standard lib of ghc 6.12
23:16:17 <SnailRacer> I also noticed that TagSoup fails to grab URLs from link tags because they use slashes... <a href=http://haskell.org> ends up just having "http://" in the tag
23:16:25 <ablmf> What was wrong?
23:16:45 <m3ga> ablmf: mtl is now an external library. its on hackage
23:20:12 <copumpkin> @where ops
23:20:12 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
23:20:18 <copumpkin> unic0re is spamming people on join
23:20:30 <copumpkin> (in pm)
23:20:35 --- mode: ChanServ set +o dcoutts_
23:20:52 <copumpkin> or at least spamming me on join :)
23:21:48 <dcoutts_> unic0re: any comment, or are you a bot?
23:22:47 --- kick: unic0re was kicked by dcoutts_ (unic0re)
23:23:03 <Axman6> talk to a freenode staffer, it's their problem
23:23:08 <Axman6> nothing that can be done here
23:23:11 <copumpkin> ?
23:23:51 --- mode: dcoutts_ set +b *!*ce_jago_b@95.66.3.208
23:23:59 --- kick: unic0re was kicked by dcoutts_ (unic0re)
23:25:26 <Saizan> we can ban him
23:25:44 <copumpkin> those things seem to be getting more common
23:25:51 <copumpkin> (opportunistic pm spam bots that idle in here)
23:26:12 <copumpkin> I think I've reported three of them in the past few weeks
23:26:48 <copumpkin> a common property seems to be an illegible real name made up of a bunch of random letters with random diacritics on them (or maybe a bad encoding on another writing system?)
23:26:56 <copumpkin> unic0re was       ##   
23:27:29 <pastorn> anyone who can help me with a little parsec?
23:27:35 <pastorn> parseTest  (choice $ map string (words "xx xy"))  "xy"
23:27:41 <pastorn> this causes an error for me :(
23:28:03 <pastorn> > this causes an error for me :(
23:28:04 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:28:07 <pastorn> > parseTest  (choice $ map string (words "xx xy"))  "xy"
23:28:08 <lambdabot>   Not in scope: `parseTest'Not in scope: `choice'Not in scope: `string'
23:28:11 <SnailRacer> ick, that's why I keep mine IM off, would be real bad if I wanted to IM
23:28:17 <Saizan> pastorn: you need try
23:28:20 <copumpkin> SnailRacer: ?
23:28:25 <Saizan> pastorn: or to factor prefixes
23:28:34 <pastorn> Saizan: where would i put try?
23:28:44 <pastorn> map (try . string)
23:28:45 <pastorn> ?
23:28:46 <Saizan> yeah
23:28:48 <SnailRacer> uninstalled instant messaging
23:29:09 <pastorn> Saizan: YAY!
23:29:11 <pastorn> thanks :D
23:30:45 * hackagebot instant-generics 0.1 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.1 (JosePedroMagalhaes)
23:33:02 <dolio> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23195#a23195
23:33:44 <Sagi> I want to produce a binary not depending on any libraries. I added -static to ghc-options in my .cabal. Is there anything else?
23:34:07 --- mode: ChanServ set -o dcoutts_
23:34:20 <copumpkin> that's cute
23:35:06 <dcoutts_> Sagi: I think you need -optl-static
23:35:28 <pastorn> dolio: stop messing with my head
23:35:57 <Sagi> hmm, let me try
23:36:18 <copumpkin> StateT of that?
23:37:21 <Sagi> hmm, it complains about libffi.so.5, installing the -dev package on the system doesn't seem to help :\
23:37:42 <SnailRacer> I want to store some filepaths and some other info in files, and having them in some sort of human readable format, I'm not 100% set on using YAML
23:38:12 <copumpkin> SnailRacer: for the absolute simplest solution in haskell, just use Read and Show?
23:38:44 <SnailRacer> sure, but comment lines would be nice
23:39:04 <pastorn> SnailRacer: you can use BNFC
23:39:09 <pastorn> pretty epic tool
23:40:02 <Sagi> aarg, it is a mismatch in libffi-versions between ubuntu and debian :\
23:40:22 <pastorn> you might even be able to read in the comments, change the data and then when you write back you can put the comments back :)
23:40:54 <SnailRacer> output probably would go to a different file
23:41:03 <pastorn> ok then :)
23:41:29 <pastorn> SnailRacer: anyway, bnfc is great if you have your own little file format
23:41:35 <pastorn> or if you wanna parse C++
23:42:02 <dolio> pastorn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23195#a23196 alternate version
23:42:02 <SnailRacer> I just don't want to reinvent the wheel =)
23:42:29 <pastorn> SnailRacer: what's the structure you'll have once it's parsed?
23:42:41 <decker> can someone explain what the "(Eq a, Num t) =>" part of this type signature means:  mylength :: (Eq a, Num t) => [a] -> t
23:42:58 <copumpkin> you don't need both, sadly
23:43:08 <copumpkin> oh wait
23:43:10 <shachaf> copumpkin: No?
23:43:13 <copumpkin> I thought they were on the same variable
23:43:26 <MatrixFrog> decker: http://learnyouahaskell.com/types-and-typeclasses might help
23:43:31 <SnailRacer> probably a table ... a filepath and some stored attributes, size, timestamps
23:43:40 <copumpkin> decker: it means that a can be any type on which it makes sense to compare equality
23:43:49 <copumpkin> decker: and t can be any type that supports typical numeric operations
23:44:00 <copumpkin> that signature is probably a consequence of writing non-idiomatic haskell
23:44:04 <pastorn> SnailRacer: Map FilePath (Size, [TimeStamp], Other) ?
23:44:10 <MatrixFrog> decker: what function has that signature?
23:44:24 <copumpkin> he probably checked == [] for the empty list
23:44:29 <copumpkin> instead of pattern matching or using null
23:44:46 <pastorn> MatrixFrog: length . nub
23:44:57 <lhames> I'm curious - why is it not idiomatic?
23:45:01 <pastorn> oh
23:45:04 <SnailRacer> sure, something like that
23:45:08 <MatrixFrog> :t (length . nub)
23:45:09 <lambdabot> forall a. (Eq a) => [a] -> Int
23:45:11 <lhames> (caveat - very new to Haskell)
23:45:11 <copumpkin> lhames: it has one more constraint than is necessary
23:45:17 <copumpkin> :t (genericLength . nub)
23:45:18 <lambdabot> forall b i. (Num i, Eq b) => [b] -> i
23:45:19 <pastorn> decker: ^^
23:45:25 <lhames> copumpkin: Thanks. :)
23:45:27 <decker> I'm trying to figure out why I can't just do this: http://fpaste.org/KVH9/
23:45:54 <copumpkin> decker: you're using (==)
23:45:59 <pastorn> SnailRacer: have you thought about how you want your file format to look?
23:46:04 <copumpkin> you're already pattern matching in the second case
23:46:08 <copumpkin> why not pattern match in the first
23:46:47 <copumpkin> decker: ideally it'd be smart enough to know that (== []) shouldn't need Eq a, but the type system can't figure that out
23:46:56 <copumpkin> and this is more consistent anyway
23:47:00 <SnailRacer> In YAML it'd be a destination path and then another section with source paths
23:47:28 <pastorn> SnailRacer: why not just use YAML then?
23:47:42 <pastorn> there are parsers for YAML already written :)
23:48:02 <SnailRacer> Syck is corrupting the output in Windows
23:49:02 <SnailRacer> n_elem = EStr "\DLE\NULrry Potte  etc
23:49:13 <SnailRacer> not sure why
23:49:26 <decker> copumpkin: I guess you mean something like this then?  http://fpaste.org/UcDq/
23:49:44 <copumpkin> decker: yes, or just mylength [] = 0
23:50:09 <decker> copumpkin: I guess I just thought I was being clever as I just read about guards
23:50:23 <copumpkin> in general you want to do as much as possible pattern matching
23:50:35 <arw> .oO(\DLE\NULrry Potte and the Monad of broken Strings)
23:51:17 <lhames> Is this a sane solution to my problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23197
23:51:25 <lhames> I want to use regexes for substitution...
23:51:48 <lhames> Text.Regex.Compat apparently has some functions that handle substitution...
23:52:20 <lhames> but they're always discussed as though they're deprecated, and I can't find any tutorials that cover them.
23:53:54 <Saizan> seems reasonable
23:54:53 <SnailRacer> lhames: There's a genericLength in Data.List
23:55:13 <SnailRacer> it's probably faster
23:55:49 <lhames> SnailRacer: You might have got me and decker mixed up. :)
23:56:07 <lhames> I'm trying to figure out regexes.
23:56:17 <SnailRacer> ah, probably
23:56:22 <lhames> Saizan: If that was aimed at me, thanks. :)
23:56:36 <decker> SnailRacer: oh, I know.  I'm just doing these exercises.  this is one of them.
23:56:53 * hackagebot guarded-rewriting 0.1 - Datatype-generic rewriting with preconditions  http://hackage.haskell.org/package/guarded-rewriting-0.1 (JosePedroMagalhaes)
23:58:03 <lhames> Saizan: If that was aimed at me, thanks. :)
23:58:11 <SnailRacer> lhames: I don't know anything about regex except it looks complicated and *nixy =(
23:59:55 <lhames> SnailRacer: The haskell regex packages, or regex in general?
