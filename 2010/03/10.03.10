00:00:15 <Trinitron> sieve (p : xs) takes each element of [2..] in turn, right?
00:01:01 <kian> it looks like it's doing a cartesian product, Trinitron
00:01:32 <dobblego> Trinitron, sieve is a function and it is pattern matching the first element (p) and the remainder of the list (xs)
00:02:33 <kian> dobblego: and for each element p, and each remaining element of the list of number xs, it checks if those elements are divisible by p, correct?
00:03:03 <Saizan> fhein: well, the problem is that in the EIdent case, you evaluate the looked up expression in the current environment
00:03:12 <dobblego> kian, yes, the list comprehension performs a filter
00:03:17 <Saizan> fhein: you've implemented dynamic scoping, basically
00:03:55 <fhein> Saizan: so instead I should return a VInteger (if the ident maps to an int) or a VClosure (if Expression)?
00:04:37 <fhein> Saizan: as you might've guessed I get problems when I have the same variable name in several functions.. like this: http://pastebin.com/zxv7VWqp
00:05:35 <Saizan> fhein: your Environment Map should be Map Ident Value, yeah
00:05:59 <Saizan> fhein: though i'm not sure if you'd ever use the VInteger case
00:06:58 <Saizan> fhein: in my experience i've just used newtype Env = Env (Map Ident (Expression,Env))
00:07:47 <fhein> Saizan: that's about what worked for call-by-value, where the argument expression was evaluated to a value..
00:08:21 <fhein> Saizan: but then I'm not sure how to extend the enclosed environment with arg, as that's a pure expression
00:08:52 <Saizan> fhein: you use VClosure
00:09:44 <fhein> Saizan: so at line 90 it would be something like "eval (Map.insert x (VClosure env arg) env') body" ?
00:09:55 <Saizan> fhein: exactly
00:10:03 <fhein> I'll try that, thanks!
00:10:13 <Saizan> fhein: and then you've to change the EIdent case too
00:12:22 <Saizan> instead of "Just val -> return val" you need "Just val -> case val of VClosure env' expr -> eval env' expr; v -> return v"
00:15:18 <fhein> Saizan: oh, it looks like it actually might be working now.. gotta run the rest of the test suite
00:15:34 <tomberek> Saizan: is there a functor classtype of (f a b -> f c d) -> g a b -> g c d   where g is a collection of f's
00:15:42 <Saizan> fhein: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.268 <- great and relevant paper, btw
00:16:44 <Saizan> tomberek: mh, i don't think so, what are the concrete types here?
00:17:00 <Trinitron> How do you get the last element of a list in Haskell?
00:17:08 <Trinitron> Isn't it the case you can't?
00:17:10 <Saizan> > last [1..6]
00:17:19 <Saizan> @bot
00:17:20 <tomberek> Saizan: still trying different variations for a graph
00:17:29 <tomberek> @djinn [a->b->c]->[a]->[b]
00:17:36 <tomberek> @djinn [a->b->c]->[a]->[b]->[c]
00:17:49 <Trinitron> doesn't last have complexity n?
00:17:54 <Saizan> it seems dead
00:18:07 <Twey> Trinitron: Yes?
00:18:09 <Saizan> Trinitron: however, you can use last, but it won't terminate for infinite lists
00:19:07 <Twey> Trinitron: If you want better complexity, try a Seq
00:19:54 <lambdabot> :)
00:19:54 <lambdabot> Error: Undefined type []
00:19:54 <lambdabot> Error: Undefined type []
00:19:54 <lambdabot>   6
00:19:57 <Saizan> tomberek: that could be "\f a b -> f <*> a <*> b" or "zipWith3 (\f a b -> f a b)"
00:20:25 <Saizan> tomberek: depending if you want cartesian product or parallel application
00:20:30 <dobblego> zipWith3 id
00:20:55 <Saizan> tomberek: you should see the Applicative typeclass then, maybe
00:21:21 <tomberek> Saizan: are you responding to my djinn? that wasn't related
00:21:40 <Saizan> tomberek: yeah
00:22:23 <tomberek> @type (<*>)
00:23:23 <tomberek> kisvoros: on magyar?
00:24:15 <tomberek> mreh: howdy
00:24:27 <mreh> hello tomberek
00:24:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:25:22 <tomberek> mreh: i was going to ask you something.... or rather get your opinion
00:26:15 <mreh> my opinion isn't work a lot
00:26:26 <mreh> worth*
00:26:43 <tomberek> mreh: perhaps.... i made a note to show you, but I forgot why
00:27:12 <mreh> tomberek: didn't you want to look at some haskell code?
00:27:20 <mreh> I can't remember
00:27:45 <tomberek> weren't you talking to me about graphs or comonads?
00:28:30 <mreh> no, not I
00:28:40 <mreh> I don't know anything about comonads
00:29:34 <tomberek> hm.... i forgot then...
00:31:37 <roboshibby> comonads?
00:31:44 <roboshibby> what's that do
00:31:55 <roboshibby> @get-shapr
00:31:55 <lambdabot> shapr!!
00:32:51 <tomberek> roboshibby: they're the dual of monads... but for a more useful explanation, they perform operations in a context
00:33:15 <roboshibby> context, do tell more please tomberek
00:33:53 <mreh> @get-@get-lambdabot
00:33:53 <lambdabot> Unknown command, try @list
00:34:06 <mreh> @get-mreh
00:34:06 <lambdabot> Unknown command, try @list
00:34:36 <tomberek> roboshibby: let's say you have a structure and want to perform a function on the elements of the structure, but that function depends on the surrounding structure (ie: context)
00:36:16 <mreh> @pl (\a b c -> f a c b)
00:36:16 <lambdabot> flip . f
00:36:39 <tomberek> roboshibby: in that case, comonads should be ideal for composition of those types of functions
00:37:00 <roboshibby> how does the comonad 'get at' the surrounding context of the structure?
00:37:18 <roboshibby> the, context structure
00:37:24 <tomberek> you pass entire structure
00:37:47 <roboshibby> does the comonad represent the context structure?
00:38:22 <tomberek> comonad (like monad) as a term stands for both the structure and the operations on it
00:40:11 <roboshibby> i dont think we're communicating
00:40:42 <tomberek> roboshibby: huh?
00:44:12 <roboshibby> tomberek, is context a function in haskell or? what type of entity is it
00:44:14 <roboshibby> im new to haskell
00:44:24 <roboshibby> im familiar with the idea of a context, but im curious about a context in Haskell
00:44:45 <roboshibby> does every structure have a constant called context that points to the surrounding structure? for example
00:44:51 <tomberek> roboshibby: i'm saying context as a general term.
00:45:18 <roboshibby> so how would you set up a comonad which points to the context?
00:45:21 <tomberek> roboshibby: no, but we can define a structure that includes a "pointer" to a particular element in the structure.
00:45:38 <roboshibby> what do you mean?
00:45:41 <roboshibby> tell me more please
00:46:35 <tomberek> roboshibby: with that pointer, a function taking the whole structure can perform an operation on that pointed to element along with information about the rest of the structure
00:47:35 <roboshibby> ok, well insofar as we're able to communicate, this is similar to what i've implemented in my own language
00:48:02 <roboshibby> thanks for clearing up how a comonad could be used
00:48:13 <tomberek> roboshibby: what have you done?
00:48:51 <roboshibby> implemented the concepts of context
00:49:10 <roboshibby> built my own language
00:49:17 <tomberek> can I see?
00:49:28 <roboshibby> and based it on a monad paradigm
00:49:42 <roboshibby> still private/in dev, but soon; end of this summer
00:50:07 <roboshibby> what kinda stuff are you into?
00:50:50 <tomberek> i'm trying to work on neural networks... and thus graphs.. and thus comonads
00:51:00 <roboshibby> and thus context
00:51:08 <roboshibby> nice/difficult
00:51:23 <roboshibby> what i've actually done is modeled how i think
00:51:25 <tomberek> it's hard to get the abstraction right...
00:51:41 <roboshibby> heh, yep =)
00:52:22 <roboshibby> actually getting deep into this project led my research into a lot of philosophical realms
00:52:33 <roboshibby> it's been an interesting journey
00:52:47 <roboshibby> is it a passion for you? or just a job
00:53:05 <tomberek> passion.. my job is unrelated
00:53:14 <roboshibby> very cool
00:54:33 <roboshibby> have anything online?
00:55:05 <tomberek> not much
00:57:22 <roboshibby> is it for profit or for good?
00:57:54 <tomberek> huh?
00:58:33 <roboshibby> like, what's your motivation? personal growth, contribution to science? profit or free?
00:58:46 <ManateeLazyCat> What's mean this GHC 6.12.1 error "internal error: MUT_ARR_PTRS_FROZEN object entered!" ?
00:58:59 <tomberek> personal,, and trying to do something useful at the same time
00:59:12 <roboshibby> cool
01:01:03 <roboshibby> there are so many greedy assholes in tech now that im really drawn to developing open/free contributions
01:01:38 <tomberek> hehe
01:01:53 <roboshibby> imagine if d'vinci or einstein were patenting cunts. "NO! myyy math"
01:02:44 <tomberek> actually, they were...
01:03:10 <roboshibby> what do you mean?
01:03:21 <Dementati> Didn't... Einstein... Work in a... Patent office...?
01:03:36 <roboshibby> yes, but that doesn't mean he misused the system
01:03:38 <roboshibby> that is my point
01:04:08 <fhein> roboshibby: doesn't matter.. Apple will just patent your inventions and sue your pants off
01:04:11 <roboshibby> not that patents are bad, but rather that patents for ideas are bad, which is what software patents are unless they are scoped to specific code implementations of abstract concepts, which is not how many are used.
01:04:21 <roboshibby> fhein, this is why i create free science
01:04:28 <roboshibby> you can't sue if there's no commercial motivation
01:04:43 <tomberek> roboshibby: sounds good
01:04:44 <fhein> ah
01:05:18 <tomberek> roboshibby: but there is less scientific motivation without the commercial part.  I'm a fan of free enterprise.
01:05:19 <Phyx-> fhein: amen to that
01:05:57 <Dementati> roboshibby: There has to be balance, simply. You can gather resources to invest in a project that requires resources, but you shouldn't stock up on resources for the sake of stocking up.
01:06:01 <roboshibby> im also a fan of free enterprise. that doesn't mean you actually get that in practice. you get varying degrees of fascist structures in practice
01:06:15 <dobblego> #haskell-blah please guys
01:06:23 <tomberek> roger roger
01:06:24 <Dementati> dobblego: Good point. Sorry.
01:06:39 <fhein> imho the main problem with software patents are that some (*cough* Apple *cough*) seem to patent both things they obviously haven't invented and really trivial stuff, that even if they released it first, anyone could think up
01:06:43 <roboshibby> dont get me wrong guys, i make $ as well. i just don't try to profit from everything i do. i balance what i earn, with what i produce in terms of greater good
01:07:00 <roboshibby> yes, its horrible
01:07:02 <Dementati> roboshibby: Let's continue this in #haskell-blah ?
01:07:04 <tomberek> move conversation to #haskell-blah
01:07:08 <Dementati> fhein:
01:07:13 <roboshibby> k
01:09:20 <o-_-o> who wrote learn you a haskell ?
01:09:31 <dobblego> BONUS
01:09:54 <o-_-o> BONUS, are you going to make a book out of it ?
01:10:27 <o-_-o> BONUS, I probably will pay through my nose to purchase a print copy :-)
01:10:43 <Dementati> I'd consider that, as well.
01:10:48 <Dementati> It's great stuff.
01:11:29 <o-_-o> BONUS, and you could become rich too in the process, see it is a win-win situation
01:11:51 <Phyx-> rich? from haskell books?
01:11:52 <Phyx-> lol
01:11:58 <Phyx-> don't think it's mainstream enough :|
01:12:35 <p_l> Phyx-: they sell quite well in Edinburgh...
01:12:39 <sinelaw> you can put on a fake PHP cover
01:12:44 <o-_-o> heh
01:12:47 <sinelaw> to get people to buy it
01:13:14 * p_l had seen Java and Haskell book taped together as a set in Edinburgh bookshop
01:13:31 <o-_-o> php version 100.0 (or what php could be, if they threw everything out and started from scratch)
01:14:10 <profmakx> p_l: the good and the ugly. where's the bad?
01:14:49 <o-_-o> put a C++ book in the middle
01:14:59 <p_l> profmakx: Java requirement?
01:15:14 <profmakx> there you got it
01:15:29 <profmakx> Haskell, C++ and Java The good, The bad, and the ugly.
01:15:46 <Trinitron> > primes = sieve [2..]
01:15:47 <Trinitron> sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] divide x y = if x < head y then x else if mod x head y == 0 then divide (x/ head y) y else divide x tail y
01:15:47 <lambdabot>   <no location info>: parse error on input `='
01:15:52 <profmakx> somehow php is missing, but that's so ugly i dont even want to think about it
01:16:13 <Trinitron> does > work across multiple lines?
01:16:22 <Trinitron> like if I chat 3 times quickly?
01:16:30 <Trinitron> I.E lambdabot
01:16:43 <sinelaw> i say tape some oranges to it
01:16:56 <sinelaw> buy 4 oranges get one haskell book free!
01:16:59 <jlouis> > let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] divide x y = if x  < head y then x else if mod x head y == 0 then divide (x/ head y) y else  divide x tail y
01:17:00 <lambdabot>   <no location info>: parse error on input `='
01:17:04 <jlouis> bah
01:17:28 <jlouis> wrapping it in a let can do it, but it can also take some simple defines IIRC
01:17:37 <o-_-o> I ordered RWH, but I think LYAH is better than RWH, sorry :|
01:18:01 <sinelaw> @let jlouis x = x * 3
01:18:02 <lambdabot>  Defined.
01:18:06 <sinelaw> > jlouis 3
01:18:07 <lambdabot>   9
01:18:12 <jlouis> \o/
01:18:24 <sinelaw> @let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] divide x y = if x  < head y then x else if mod x head y == 0 then divide (x/ head y) y else  divide x tail y
01:18:24 <lambdabot>   Parse error: Equals
01:19:13 <sinelaw> what's that = if doing in there
01:19:42 <Trinitron> err you can do that when you define a function
01:19:44 <Trinitron> afaik
01:20:10 <Trinitron> > blah x = if x then x
01:20:11 <jtza8> Currently my faviorite language is Common Lisp. I'm investigating Haskell as an alternative, I'd like to ask a few questions.
01:20:11 <lambdabot>   <no location info>: parse error on input `='
01:20:16 <Trinitron> wait, you can't
01:20:17 <Trinitron> !
01:20:42 <Trinitron> common lisp isn't purely funcitonal, learn haskell
01:20:43 <Trinitron> :D
01:20:54 <Trinitron> functional*
01:20:54 <elly> Haskell isn't purely functional, learn untyped lambda calculus
01:21:04 <mux> according to guido, LISP isn't even functional :-P
01:21:16 <elly> guido thinks a lot of things, mux :P
01:21:26 <mux> oh, and you can't write a fold in a few lines in a functional proramming *giggles*
01:21:31 <mux> that one was real good
01:21:42 <Trinitron> You should never program functionally in python.
01:22:01 <Trinitron> The language isn't optimised for functional computation.
01:22:03 <sinelaw> nor should you program in functionally python
01:22:16 <mux> that's not what was implied at all
01:22:47 <jtza8> Firstly, is OOP practical in a purely functional environment? (or is it a totally different paradigm?)
01:23:08 <Trinitron> OOP is state change, in haskell you can't change a variable once defined
01:23:12 <Trinitron> because that would be a lie
01:23:14 <ketil> Any hints on how to test probabilistic/inaccurate functions?  I've implemented some numerical methods, but lack of accuracy makes them hard to test.
01:23:31 <Trinitron> unless you use monads or something which I don't know yet
01:23:43 <jtza8> Thought so...
01:23:47 <Saizan> jtza8: OOP is badly defined, i don't think its fundamental characteristic needs mutation
01:23:48 <ketil> jtza8, define OOP?
01:24:07 <o-_-o> jtza8, do you need OOP when are doing purely functional programming ?
01:24:09 <jtza8> I mean, OOP in an immutable sense.
01:24:21 <ketil> At my alma mater, object-based was programming with classes, object-oriented was OB with inheritance.
01:24:30 <Saizan> jtza8: traditional FP is quite a different paradigm, since we usually have a closed definition of our datatypes, and are able to write new functions to extend their interface
01:24:40 <Phyx-> p_l: but the publisher gets most of that loot no?
01:24:47 <Saizan> jtza8: while in OOP you tend to do the opposite
01:25:18 <Saizan> jtza8: though you can adopt this second strategy fairly easily in a functional language with an expressive enough type system
01:25:24 <jtza8> Right, but how would I organise code in FP?
01:25:25 <p_l> Phyx-: I'd say that it depends on what publisher and how exactly you publish
01:25:36 <Saizan> jtza8: using modules
01:25:48 <Trinitron> If we were to define a to be 5, a can't redefined to 6, as that doesn't make any mathematical sense.
01:25:53 <Trinitron> be*
01:25:59 <o-_-o> if I have Class (Eq a) => Num a where, then Num a has it's own class constraints and the class constraints of Eq a too ?
01:26:12 <Saizan> jtza8: which only deal with namespaces
01:26:49 <Trinitron> Definitions in mathematics never change.
01:27:01 <Trinitron> sin 1 is always going to be sin 1.
01:27:13 <jtza8> So I would practiacally write my code with sets of actions in mind, rather than objects, I suppose.
01:27:20 <jtza8> ?
01:27:32 <Trinitron> err you would define functions
01:27:35 <Trinitron> and let them do the work
01:27:48 <jtza8> Yes, but...
01:27:56 <Trinitron> but if you reaaaaly need to change state, there are monads
01:27:57 <Saizan> o-_-o: with that "foo :: Num a => a -> Bool; f x = x == x" is accepted, because the compiler can derive that a is Eq too
01:28:02 <Trinitron> but I've never used them
01:28:10 <Trinitron> so don't ask me how to use it
01:28:19 <jtza8> I'm talking about "grouping" code in a practical manner.
01:28:28 <Trinitron> You seem to misunderstand.
01:28:41 <Saizan> Trinitron: he's not talking about mutation
01:28:41 <Trinitron> There is no "code" only function definitions.
01:28:51 <Saizan> we still have source files :)
01:29:05 <Trinitron> not your conventional list of instrcutions
01:29:13 <jtza8> Saizan: Yes, that's it.
01:29:22 <Trinitron> an expression on its own is meaningless
01:29:24 <pookleblinky> jtza8, functional programming is a plus.
01:29:28 <Trinitron> as there are no side effects
01:29:37 <pookleblinky> Immutable assignment forces your functions to work safely.
01:29:52 <o-_-o> jtza8, each person on here interprets your question differently :-)
01:29:53 * hackagebot ghc-mod 0.1.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.1.0 (KazuYamamoto)
01:30:36 <pookleblinky> jtza8, think of the program as a math proof.
01:30:53 <pookleblinky> You're manipulating things with tiny, well-defined functions.
01:31:02 <pookleblinky> Each does one thing, and only that one thing.
01:31:05 <jtza8> I'm just in the habit of having quite a lot of sorce files, with one class in them maximum, per say, but here I would group them by function, rather than by data type, right?
01:31:09 <Trinitron> some would say that functional programming heavily relies on recursion.
01:31:29 <Saizan> jtza8: well, you program using types to guide you in gluing things together, often you'll find a module that defines a datatype and a set of operations that work with it, though you could also find a module that exports functions to work with multiple types together and are grouped just because they contribute to the same goal
01:31:33 <Trinitron> if you know how to do recursion in an imperative language, you shouldn't find haskell hard.
01:31:48 <pookleblinky> jtza8, you're coming over from Erlang?
01:32:01 <jlouis> mmm, Erlang
01:32:08 <jtza8> pookleblinky: no, CL
01:32:30 <Trinitron> I started on Scheme.
01:32:33 <jtza8> I've done some "pure" FP in scheme before.
01:32:37 <pookleblinky> Ah. Because in erlang, the whole goal is to modularize everything.
01:32:39 <Trinitron> My first FP
01:32:54 <Saizan> jtza8: one datatype per module is most common for data structures
01:32:58 <Twey> Trinitron: Only at a low level
01:33:06 <Trinitron> yes
01:33:11 <Trinitron> I should add that
01:33:12 <Trinitron> heh
01:33:13 <Trinitron> basics
01:33:14 <pookleblinky> An erlang "program" ideally consists of many tiny files each contributing tiny modules.
01:33:15 <Trinitron> :F
01:33:16 <Twey> The functionality is usually captured in combinators in Real Code
01:34:12 <jtza8> Saizan: I think I understand what you mean.
01:34:26 <Saizan> jtza8: we also have "type classes" to capture some ubiquitous interfaces, and to provide a sane way to do overloading
01:36:39 <jtza8> My last concern is clarity of code, and ease of documentation. I guess that's probably been thought of a bit in Haskel?
01:36:52 <pookleblinky> jtza8, in many cases the code is the doc.
01:37:06 <pookleblinky> Look at the use of good type signatures.
01:37:51 <jtza8> pookleblinky: Will do.
01:38:05 <pookleblinky> jtza8, have you looked at haddock yet?
01:38:19 <jtza8> Thanks, I'll do that too.
01:38:49 <Saizan> haddock is pretty similar to how you do java (or similar) api docs
01:39:07 <pookleblinky> However, it is in many cases not very useful.
01:39:11 <pozic> Twey: In particular I want to know whether I need to give a column vector or a row-vector as vector in: http://hackage.haskell.org/packages/archive/Vec/0.9.7/doc/html/Data-Vec-LinAlg.html#v%3Acramer%27sRule
01:39:19 <pookleblinky> square :: Int -> Int
01:39:29 <pookleblinky> What do you think square looks like?
01:39:45 <jtza8> An int? :P
01:40:06 <jtza8> ... function
01:40:10 <jtza8> returning an int?
01:40:12 <Saizan> type + name often gives a pretty good idea of what the function does, though types give more information where they are polymorphic
01:40:25 <pookleblinky> Just by knowing the type sig, you can tell pretty well how the function will work, what it will accept, and usually generate it from scratch.
01:40:43 <Saizan> "Int -> Int" is the type of functions that take an int and return an int
01:41:01 <jtza8> Thought so after a while :)
01:41:16 <pookleblinky> Just by knowing that, you've got the equivalent, essentially, of a contract.
01:41:46 <jtza8> How about FFI in Haskell?
01:41:48 <pookleblinky> You know that you shouldn't pass floats to this function, and that it won't play well with a function that takes floats.
01:42:06 <jtza8> pookleblinky: I also take it that the compiler wouldn't allow that.
01:42:16 <pookleblinky> It's not for the compiler.
01:42:24 <pookleblinky> The compiler can usually figure it out.
01:42:33 <pookleblinky> It's mainly for you, two weeks later.
01:42:36 <zygoloid_> but yes, the compiler wouldn't allow passing a float to that function
01:42:42 <jtza8> pookleblinky: Ah
01:43:44 <jtza8> If I'd like to deal with something such as OpenGL (which is quite imperative) would I be able to do so conveniently?
01:44:17 <pookleblinky> Yes, through monads.
01:44:42 <pookleblinky> You need monads because they encapsulate possible side-effecty behaviour, such as IO.
01:44:57 <jtza8> Ok, makes sense.
01:45:16 <znutar> there's nice syntactic sugar for monads too, so it's less painful than you'd think
01:45:27 <pookleblinky> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source/Core.hs
01:45:35 <pookleblinky> Check out the X monad.
01:45:35 <Saizan> another nice thing is that you generally don't have to specify types, the typechecker can infer them for you
01:45:37 <eevar2> jtza8: suggest you google for haskell + opengl, and have a look at some of the open source projects out there
01:45:53 <jtza8> Ok will do
01:45:56 <Saizan> though toplevel definitions often have type annotations for documentation purpouses
01:46:17 <jtza8> How about iteroperability with C
01:46:22 <jtza8> ... ++ code
01:46:33 <jtza8> * C++ code
01:46:34 <Saizan> C is pretty easy through the FFI
01:46:45 <mux> quite frankly I know of no better FFI than haskell's FFI
01:47:01 <Saizan> for C++ the main strategy is to write a C wrapper first?
01:47:06 <pookleblinky> You can, but you'd have to deal with encapsulating C's oddness.
01:47:31 <pookleblinky> You have to basically quarentine the communication to make sure it doesn't introduce any side-effects.
01:47:55 <jtza8> Seems good to me.
01:48:12 <pookleblinky> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
01:48:18 <adu> indeed, FFI++
01:48:23 <pozic> mux: the FFI could be improved by figuring out the return types from the header file.
01:48:45 <mux> pozic: that's hsc2hs's job, and it does it fine, IIRC
01:48:46 <pozic> mux: well, basically all the types.
01:49:11 <adu> Saizan: theoretically, C's FFI is supposed to be like Haskell's (extern "C++") but no one uses it with anything else other than "C" and "C++"
01:49:30 <jtza8> I'm also wondering about binnary distribution. In CL, for example, dumping an image takes at least 20MB.
01:49:34 <pozic> mux: do you have an example of hsc2hs doing that?
01:49:51 <pozic> mux: my understanding is also that c2hs is a more up to date tool.
01:50:02 <mux> pozic: oh, I was thinking of c2hs, actually
01:51:26 <pookleblinky> jtza8, have you got a copy of Real World Haskell?
01:51:49 <jtza8> I've had a very quick look at it so far..
01:52:34 <jtza8> It'd probably be the best book to read for actually using Haskell.
01:53:23 <roboshibby> is haskell like php?
01:53:28 <pookleblinky> http://www.haskell.org/ghc/docs/latest/html/users_guide/modes.html is a good start on compiler flags and modes.
01:53:35 <pookleblinky> roboshibby...
01:53:44 <jtza8> Ok
01:53:49 <roboshibby> hello
01:54:19 <pookleblinky> jtza8, remember that you can compile to either native or bytecode.
01:54:38 <jtza8> pookleblinky: Ok.
01:55:06 <roboshibby> is haskell like php?
01:55:31 <Saizan> roboshibby: that's not a very well defined question, however i'd go with no
01:55:39 <pookleblinky> roboshibby, it is pretty much the opposite of php in every single way.
01:55:45 <Phyx-> and append a "thank got it isn't"
01:56:10 <jtza8> I'm planning on writing indie games in something that isn't C++, I guess that Haskell is way more expressive, and that with GPUs handling all the real calculations, using haskell could actually be very practical.
01:56:24 <pookleblinky> Consider php's problem with scoping.
01:56:50 <jtza8> ... so thanks to all for answering my questions :)
01:57:23 <Saizan> there are even Embedded Domain Specific Languages to write GPU code, iirc
01:57:31 <Saizan> or projects in that area anyway
01:57:37 <pookleblinky> CUDA ftw
01:57:46 <tokmaster> hi
01:57:57 <pookleblinky> Though, tbh, it isn't that useful for general computation.
01:58:20 <pookleblinky> If you're dealing with linear algebra and such, sending it to the gpu is awesome.
01:58:30 <pookleblinky> But for floating point operations...
01:58:46 <pookleblinky> Plus, your gpu, though internally massively parallel, only takes in one thread at a time.
01:59:22 <Saizan> yeah, you've to use it for whole vectors at once
01:59:27 <Saizan> i guess
01:59:34 <pookleblinky> Saizan, a friend and I have been playing around with an idea for a while.
01:59:44 <pookleblinky> A Tesla for under $2,000
02:00:02 <pookleblinky> Using fpga's and a concurrent microkernel to allocate threads.
02:00:47 * jtza8 thinks that the beautiful code that is threads in C++... would create a performance hit in C++ anyway.
02:00:58 <pookleblinky> The idea being that if you're a uni, you probably need massive performance optimizations that'll never be used for any other project.
02:01:31 <pookleblinky> A constellation of fpga's + libraries for hardware implementations of algorithms + a fast kernel
02:01:50 <roboshibby> embedded DSL?
02:02:16 <Saizan> roboshibby: yeah, a DSL that's implemented as combinators in an host language
02:02:18 <pookleblinky> You'd have the ability to hack a cheap, massively parallel supercomputer for your problem.
02:02:25 <roboshibby> pookleblinky: what do you mean "a tesla"?
02:02:25 <jtza8> pookleblinky: How about SLI for concurrency?
02:02:34 <pookleblinky> Sure, if you're serious you'd use BOINC.
02:02:46 <pookleblinky> roboshibby, the Tesla Computer. A very very cool project.
02:03:01 <pookleblinky> http://www.nvidia.com/object/personal_supercomputing.html
02:03:06 <roboshibby> thank you
02:03:24 <Saizan> roboshibby: so it borrows a lot of the features of the host language but it's also specific enough to write very expressive code
02:03:31 <roboshibby> nice
02:03:36 <pookleblinky> Oddly enough, my friend and I came up with our idea about a month before Tesla was announced.
02:03:53 <roboshibby> saizan, couldn't you by that definition call any code embedded dsl? like objc code uses objc features
02:04:01 <roboshibby> tesla looks pretty cool
02:04:05 <pookleblinky> roboshibby, a DSL is a miniature language.
02:04:11 <pookleblinky> That's all.
02:04:33 <pookleblinky> A tiny version of Foo that has lots of syntactic sugar to do bar.
02:05:36 <pookleblinky> Look at Rake, for instance. It's a version of ruby that has lots of syntactic sugar for dealing with builds.
02:05:37 <roboshibby> nice
02:06:28 <pookleblinky> Technically it's ruby, but it is tweaked so that it is autistically focused on doing one task.
02:06:41 <roboshibby> well im gonna crash, nice chatting with you guys
02:08:05 <Saizan> not necessarily syntactic sugar
02:09:04 <Saizan> you could think of Control.Monad.State as a very small EDSL to write stateful computations
02:09:12 <pookleblinky> Saizan, in a broad sense it is. The biggest part of any DSL is building up the abstractions to the right level.
02:10:08 <Saizan> yeah, i just disagree with the term :)
02:36:53 <pozic> Can anyone explain why 'wth' returns the wrong answer? http://paste.debian.net/63479/ It might be that I am using it wrong, but I actually think it is just broken. cabal install Vec and copying the contents should work.
02:39:27 <zygoloid_> pozic: what solution does it give?
02:39:54 <pozic> zygoloid_: Just (1.0):.(1.0):.()
02:40:14 <pookleblinky> http://ideone.com/c8zkkCRw doesn't help, they don't have Data.Vec.Base >(
02:41:09 <pozic> pookleblinky: cabal install Vec, copy paste and ghci file name is just as much work.
02:44:05 <pookleblinky> pozic, a minor misunderstanding. I've begun sending codesnips to ideone for basic debugging. Often, it can instantly identify problems.
02:44:48 <pookleblinky> But if their environment lacks some deps, it kind of becomes useless for instant debugging info.
02:45:53 <Entroacceptor> is there a command to kill all locally installed cabal packages?
02:46:07 <Entroacceptor> or can I just delete .ghc ?
02:46:09 <pozic> pookleblinky: heh, at this point you can still be a bot ;)
02:46:12 <dobblego> rm -rf ~/.cabal
02:46:18 <dcoutts> dobblego: nooo!
02:46:18 <lambdabot> dcoutts: You have 16 new messages. '/msg lambdabot @messages' to read them.
02:46:40 <dcoutts> dobblego: Entroacceptor is right, rm ~/.ghc/$the-ghc-version
02:46:49 <doserj> pozic: I get Nothing here, using that code
02:46:49 <dobblego> ok
02:47:25 <dcoutts> dobblego: if people only rm .cabal they end up with lots of registered packages that have had all their files deleted, which is jolly confusing.
02:47:46 <dobblego> dcoutts, yes sorry
02:48:43 <pookleblinky> pozic, actually, integrating a bot with ideone is a great idea.
02:49:06 <pozic> pookleblinky: no, it is a mediocre, but useful one ;)
02:49:09 <pookleblinky> You'd have to set it up to suck the code out of hpaste or pastebin or such, and send it into ideone
02:49:33 <pozic> pookleblinky: it would require someone with a clue of Haskell to maintain it.
02:49:38 <pookleblinky> Then return specified parts of the output to privmsg.
02:50:03 <pozic> pookleblinky: that could become annoying
02:50:14 <pozic> doserj: which package version?
02:50:14 <pookleblinky> Annoying but cool.
02:51:02 <pozic> doserj: 0.97?
02:51:05 <zygoloid_> pozic: looks like the bug is in gaussElim. it uses (maybe (m,1) (...) (pivot m)). pivot m returns Nothing for the matrix, but gaussElim throws away the result and produces the original matrix.
02:51:07 <pozic> doserj: 0.9.7?
02:51:31 <pozic> doserj: I use 0.9.6, which might explain it.
02:51:40 <doserj> pozic: 0.9.7 here
02:51:50 <zygoloid_> pozic: backSubstitute then assumes all is well and fills in the result with [1,1]
02:52:01 <pozic> zygoloid_: isn't there some well-tested library somewhere? Gaussian elimination is as old as the wheel.
02:52:15 <Sarahzz> http://imgnow.info/DSC-1268218311.jpg do my boobs look small?
02:53:07 <pozic> zygoloid_: why would anyone do that other that out of pure malice?
02:54:10 <pozic> zygoloid_: in 0.9.7 it returns the right answer indeed.
02:54:34 --- mode: ChanServ set +o dobblego
02:54:49 --- mode: dobblego set +b *!*@63.223.127.*
02:54:53 --- mode: dobblego set -o dobblego
02:55:31 <zygoloid_> dobblego: last time it was from ~AnnaBanz@66.90.81.214
02:55:46 <ivanm> OK, that went to a house rental site...
02:56:13 <zygoloid_> what were you expecting? ;)
02:56:19 <dobblego> zygoloid_, yeah it's happened on another network from many 63.223.127 addresses
02:57:29 <ivanm> zygoloid_: well, it was almost obvious that it _wasn't_ porn
02:58:19 <ivanm> (the almost is there just in case someone really did think that purely functional hackers were authorative experts on relative mammary gland sizing)
02:58:54 <zygoloid_> well, this is a big channel. chances are we've got a few MDs here
02:59:17 <Ke> and quite a few mathematicians who know volume integrals
02:59:33 <ivanm> heh
02:59:58 <nlogax> they're too good at spamming: "Our site has been moved to another server that will be able to handle the heavy traffic."
03:09:37 <mreh> > do { x <- [1..] ; y <- [1..] ; return (x, y) }
03:09:38 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
03:09:46 <mreh> > do { x <- [1..3] ; y <- [1..3] ; return (x, y) }
03:09:47 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
03:10:01 <toki78> > 1+1
03:10:02 <lambdabot>   2
03:10:10 <o-_-o> context ? -> http://www.reddit.com/r/haskell/comments/bau8x/haskell_weekly_news_issue_152_march_8_2010/
03:11:26 <ivanm> o-_-o: jfreddet forgot to include a blog post of Paczeiowa's in HWN
03:11:38 <o-_-o> heh
03:12:28 <mreh> > zipWith zip (do { x <- [1..] ; y <- [1..] ; return (x, y) }) ["hello","mother"]
03:12:29 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
03:12:48 <ivanm> preflex: seen malcolmw
03:12:48 <preflex>  malcolmw was last seen on #haskell 4 days, 19 hours, 46 minutes and 13 seconds ago, saying: pozic: on the other hand, if you count a PhD position as "full time Haskell", you could be earning more like Â£16,000 per annum, but it is tax free and you have lots of flexibility
03:12:49 <mreh> oh...
03:13:23 <vegai> Hello. Is there a way to parse text in Data.Text format?
03:13:35 <ivanm> vegai: you mean use parsec or something on it?
03:13:38 <ivanm> don't think so...
03:13:41 <ivanm> preflex: seen bos
03:13:41 <preflex>  bos was last seen on #haskell 14 hours, 19 minutes and 23 seconds ago, saying: hee hee! i just set up a google adwords campaign for RWH
03:13:48 <mreh> damnit
03:13:48 <mreh> I don't want concatMap
03:14:14 <ivanm> maybe by converting it to bytestring and parsing that...
03:14:43 <vegai> Oh, I didn't notice that there were conversion funtions
03:15:30 <vegai> Then again, my needs are simple: ad-hoc parsing of irc messages from the server
03:15:49 <vegai> perhaps I can do with Data.Text.break and others
03:15:58 <mreh> > map [1..3] . (\x -> concatMap [1..3] $ (\y -> (x,y)))
03:15:59 <ivanm> or you could try making your own Text instance of the Parsec parser (or some other parser such as Polyparse
03:15:59 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
03:16:01 <ivanm> )
03:16:14 <mreh> > map [1..3] (\x -> concatMap [1..3] $ (\y -> (x,y)))
03:16:15 <ivanm> vegai: or get it as Bytesring to start with rather than text?
03:16:15 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
03:17:05 <o-_-o> I have a weird question, if I don't even understand applicative, how will ever use it ? Or rather how will I ever know I can use applicative here ?
03:17:30 <ivanm> vegai: *cough* http://hackage.haskell.org/package/irc *cough*
03:17:31 <profmakx> experience
03:17:40 <mreh> :t concatMao
03:17:41 <lambdabot> Not in scope: `concatMao'
03:17:42 <mreh> :t concatMap
03:17:43 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
03:17:54 <mreh> Come in Chairman Mao
03:17:54 <ivanm> o-_-o: most people seem to use applicative for parsing with parsec
03:18:08 <o-_-o> ivanm, ok
03:18:33 <vegai> ivanm: mm, uses Strings.
03:18:37 <mreh> > map (\x -> map (\y -> (x,y)) [1..3]) [1..3]
03:18:38 <lambdabot>   [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
03:18:45 <ivanm> vegai: picky, picky!
03:18:46 <mreh> this offends my eyes, can I improve on it?
03:18:56 <ivanm> someone has already done the work for you and all you can do is whinge!
03:19:04 <vegai> ;)
03:19:11 <ivanm> @pl \ x -> map ((,) x)
03:19:11 <lambdabot> map . (,)
03:19:20 <ivanm> mreh: map (map . (,))
03:19:26 <ivanm> @pl map (\ x -> map ((,) x))
03:19:26 <lambdabot> map (map . (,))
03:19:28 <mreh> that's even worse :)
03:19:34 <ivanm> mreh: in what sense?
03:19:43 <mreh> nah, I like it
03:19:49 <Alpounet> vegai, heh, port it to bytestrings :-p
03:19:51 * ivanm is confused...
03:19:52 <mreh> well if you're not a seasoned haskeller, it looks pretty strange
03:21:14 <vegai> I suppose I should stop worrying about Data.Text, yes
03:21:51 <ivanm> @ask malcolmw how do I do "look-ahead" parsing with polyparse? using reparse to put chars back on the stack?
03:21:51 <lambdabot> Consider it noted.
03:22:48 <mreh_> :t zipWith zip
03:22:49 <lambdabot> forall a b. [[a]] -> [[b]] -> [[(a, b)]]
03:23:30 <Entroacceptor> can someone help me install happstack-tutorial?
03:23:49 <mreh_> :t map . (,)
03:23:50 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
03:24:11 <mreh_> :t map (,)
03:24:12 <lambdabot> forall a b. [a] -> [b -> (a, b)]
03:24:31 <Entroacceptor> it says Crypto wants QuickCheck>=2, but happstack-util requires <2
03:24:45 <mreh_> sounds like dependency hell
03:24:58 <Alpounet> take an older version of Crypto then Entroacceptor
03:25:15 <ivanm> Entroacceptor: which is why testing dependencies should be _optional_
03:25:18 * Alpounet isn't affraid of dependency hells anymore
03:25:53 <mreh_> dependency purgatory
03:25:56 <ivanm> Entroacceptor: where is happstack-tutorial? it doesn't seem to be on hackage...
03:27:04 <ivanm> wtf? crypto 4.2.0 was uploaded _after_ 4.2.1 ?
03:27:10 <Alpounet> haha
03:27:10 <ivanm> and why doesn't 4.2.1 have any docs?
03:27:23 <ivanm> Entroacceptor: get crypto 4.2.0 rather than 4.2.1
03:27:32 <ivanm> seems to be a "newer" version
03:28:13 <Entroacceptor> I got the darcs from http://tutorial.happstack.com/
03:28:21 <ivanm> ahhh
03:28:26 <mreh_> > 3,4
03:28:27 <lambdabot>   <no location info>: parse error on input `,'
03:28:33 <mreh_> > (3,) 4
03:28:34 <lambdabot>   <no location info>: parse error on input `)'
03:28:43 <mreh_> > (,) 3 4
03:28:44 <lambdabot>   (3,4)
03:28:58 <mreh_> (,) is somewhat of an oddity isn't it
03:28:59 <ivanm> oh, it's still the happs tutorial? :/
03:29:05 <ivanm> mreh_: in what way?
03:29:18 <mreh_> it looks like a section, but , isn't infix
03:29:18 <ivanm> (6.12 has an extension that will let you do (3,) and (,4)!)
03:29:43 <ivanm> Entroacceptor: latest version on hackage doesn't have a QC dep
03:30:03 <mreh> is the GHC platform using 6.12 yet?
03:30:16 <Entroacceptor> ivanm: is that tutorial too old?
03:30:28 <ivanm> Entroacceptor: from nov last year
03:30:32 <ivanm> (the hackage version)
03:30:59 <Entroacceptor> ok, installing the other crpyto seemed to have worked
03:31:01 <Entroacceptor> thanks so far
03:31:17 <ivanm> and even the darcs version doesn't seem to have a QC dep... (going from the cabal file at http://tutorial.happstack.com/projectroot )
03:33:51 <Alpounet> ghc-mod looks interesting
03:34:54 <ivanm> I have no idea what it's meant to be though :s
03:35:13 * ivanm _hates_ users who do "base < 10"
03:35:28 <Alpounet> ivanm, ghc-mod ?
03:35:33 <vegai> a bit nasty that ByteString docs have examples such as '''split '\n' "12\n23"'''
03:35:42 <ivanm> Alpounet: yeah
03:36:09 <ivanm> I mean, what's ghc*.el meant to be?
03:36:26 <ivanm> oh, presumably the elisp files that come with ghc-mod
03:36:52 <vegai> '\n' is not a Word8 being the problem
03:37:03 <Alpounet> ivanm, yeah, it refers tp these elisp files
03:37:06 <Alpounet> to*
03:37:16 <pozic> ivanm: hate the tools, not the users.
03:38:31 <ivanm> pozic: what tools?
03:38:36 <ivanm> AFAIK no tool autogenerates that
03:38:52 <pozic> The limitation of not bing able to use a package which uses both version X and X+1 is a limitation that comes from the C world and is not applicable to pure Haskell libraries.
03:39:01 <pozic> being*
03:39:17 <ivanm> pozic: I don't think so...
03:39:29 <ivanm> from what dcoutts has said it's a diamond dependency problem
03:39:54 <ivanm> for things like QC, they need to get better dep control (into ghc IIRC) to know about un-exported symbols, etc.
03:40:15 <pozic> ivanm: and thus a tools problem.
03:40:41 * ivanm is confused
03:41:04 <ivanm> pozic: I'm talking about people who have as deps in their cabal files something like: "base < 10"
03:41:18 <ivanm> that's just stupid because you can't know that it will still build with base-9
03:41:25 <pozic> ivanm: consider the following algorithm: download all required packages. Rename all constructors and or types such that there are no conflicts. Now, you are in a situation where you use the "same package" twice in different packages.
03:41:37 <ivanm> huh?
03:41:44 <pozic> ivanm: this is a perfectly well-defined algorithm and thus a computer can execute it.
03:41:49 <ivanm> I fail to see how your arguments are relevant
03:42:16 <pozic> ivanm: the base < 10 exists because people don't want to update their cabal packages every single time.
03:42:22 <pozic> ivanm: and they are right.
03:42:25 <ivanm> but that's bloody stupid
03:42:36 <pozic> ivanm: no, they simply understand that the tools are stupid.
03:42:44 <ivanm> no, they're just lazy
03:42:53 <theorbtwo> It's an expected side-effect of not having a policy on API compatability.
03:42:57 <ivanm> what's so hard about making simple changes to a .cabal file when a new version of cabal comes out?
03:43:01 <ivanm> theorbtwo: sure there is
03:43:09 <ivanm> it's called the Package Versioning Policy
03:43:12 <ivanm> @where pvp
03:43:12 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
03:43:12 <theorbtwo> You *can* know that it'll still work with 9.  You can't know that it'll still work with 11 until after 11 is released.
03:43:29 <pozic> ivanm: people can name everything what they want. If it is a bad idea, not everyone will cooperate.
03:43:35 <ivanm> the PVP exists for a reason; if there's a major version bump then quite likely the code will not work
03:43:41 <ivanm> pozic: huh?
03:44:26 <ivanm> if a package follows the PVP, then you know that by upgrading to a versioin with the same major version then the code will still compile
03:44:38 <pozic> ivanm: never mind. Just think about the actual problem for some time until you understand how the numbers that users specify is redundant in an information sense.
03:44:39 <ivanm> (sans instance problems like what happened with yi and data-accessor)
03:44:58 <ivanm> pozic: ummmmm, no, I still think you have no idea what your'e talking about
03:45:22 <pozic> ivanm: well, I have no interest in changing what you are thinking about.
03:45:48 <Entroacceptor> now I get bugs with 'container'
03:46:03 <pozic> And it leads to sillyness like Entroacceptor is experiencing.
03:46:28 <ivanm> Entroacceptor: you using 6.12?
03:46:49 <Entroacceptor> yes, 6.12.1
03:46:57 <ivanm> then the version of container got bumped
03:47:01 <theorbtwo> Right, so < 10 presumably means that you want something that has been in API versions 1 through 9?
03:47:10 <ivanm> _because its API had backwards-incompatible changes_
03:47:14 <Entroacceptor> uaarg happstack-0.4.1 depends on containers-0.2.0.1 which failed to install.
03:47:26 <ivanm> theorbtwo: they're claiming that it will work with all versions of base from 1 to 9, yes
03:47:26 <Entroacceptor> but I just installed happstac-0.4.1 without any problems
03:47:39 <ivanm> dons did that with ghc-core once saying base < 5; it failed to build with base-4
03:47:56 <ivanm> Entroacceptor: edit the cabal file; it will most likely work with containers-3
03:48:19 <Entroacceptor> ok...
03:48:36 <Entroacceptor> even though he says it specifically?
03:48:48 <pozic> The problem with cabal is that users can lie.
03:49:38 <pozic> That is basically why people like Haskell in the first place. Unless people use unsafePerformIO, types have some meaning.
03:49:48 <ivanm> pozic: no, the problem with .cabal files + hackage is that when users are safe + conservative it can take too long for them to release point-fixes to loosen version restrictions
03:50:08 <o-_-o> does bonus live in slovenia or washington ?
03:50:14 <ivanm> dcoutts is working on ways to have hackage allow people to edit the cabal file so that this won't be a problem in future
03:50:27 <ivanm> o-_-o: *shrug* no idea
03:50:29 <pozic> ivanm: and it is the wrong solution.
03:50:47 <pozic> ivanm: it takes up people time, while an automated solution exists.
03:50:58 <ivanm> automated build tests comparisons? maybe
03:51:05 <Entroacceptor> I give up.
03:51:07 <ivanm> that requires extra infrastructure which _people have to write_
03:51:22 <Entroacceptor> I won't manually install all the deps
03:51:46 <Entroacceptor> or maybe it's arch's fault to update ghc so eagerly
03:51:49 <pozic> ivanm: yes, and if people don't write that infrastructure it shows those people don't believe Haskell will be around long enough for it to be useful.
03:52:00 <ivanm> bullshit
03:52:05 <ivanm> it means people haven't written it yet
03:52:06 <ivanm> that's all
03:52:16 <ivanm> in case you haven't realised, dcoutts has a _lot_ on his plate
03:52:20 <Alpounet> agreed
03:52:21 <ivanm> Entroacceptor: heh
03:52:28 <mreh> we are his personal secretaries
03:52:34 <pozic> ivanm: where did I say that dcoutts should do it?
03:52:41 <ivanm> pozic: who else should do it?
03:52:59 <ivanm> dcoutts is one of the main people involved with cabal and hackage
03:53:04 <pozic> ivanm: it is not like cabal is a difficult program, or to do the solution described earlier.
03:53:13 <ivanm> pozic: fine then, _you_ go and write it
03:53:28 <pozic> ivanm: sure, I could do so, but I see no reason to do so.
03:53:48 <pozic> ivanm: which is the real reason why it doesn't exist.
03:54:00 <pozic> ivanm: lack of commercial interest.
03:54:14 <Alpounet> lack of interest at all, don't hide behind commercial interests
03:54:36 <pozic> Alpounet: I am sure someone is willing to write it.
03:54:53 <Alpounet> oh come on
03:55:00 <Alpounet> you sure can find a better excuse
03:55:35 <pozic> Alpounet: Put up a bag of money on haskell-cafe and look how fast development happens.
03:55:46 <mreh> hehe
03:56:09 <Phyx-> lol
04:01:00 <Alpounet> pozic, yeah sure, but as long as there isn't any...
04:02:32 <Alpounet> if you want something and that nobody is currently able to take care of it
04:02:45 <Alpounet> do it yourself, or don't complain and claim that you "could do so"
04:03:05 <Entroacceptor> ok, I can't install containers-2
04:03:18 <Alpounet> Entroacceptor, error ?
04:03:23 <Entroacceptor> because Data.Data is hidden
04:03:34 <Entroacceptor> err, in a hidden package 'base
04:03:50 <Entroacceptor> adding build-depends: base didn't hepl
04:05:32 <Entroacceptor> and it is there already, in a Library block
04:05:39 <ivanm> Entroacceptor: edit the cabal file to let it build with containers-0.3
04:07:09 <Entroacceptor> then I have to tell that to every packet in the list...
04:07:30 <Entroacceptor> I want a switch 'ignore versions, I'd rather mess with that instead of packaging issues'
04:08:30 <ivanm> you mean every package? :p
04:08:45 <ivanm> AFAIK most should already support containers-0.3
04:08:47 <Entroacceptor> looks like every dependency
04:09:10 <Entroacceptor> why can't containers-3 say 'I support containers-2, too!'
04:09:44 <ivanm> heh
04:09:46 * hackagebot hsndfile-storablevector 0.4.0 - Haskell bindings for libsndfile (Data.StorableVector interface)  http://hackage.haskell.org/package/hsndfile-storablevector-0.4.0 (StefanKersten)
04:09:51 <ivanm> because it isn't backwards compatible
04:09:54 <ivanm> there were some changes
04:10:05 <ivanm> (can't remember what they were off the top of my head though)
04:10:24 <Entroacceptor> mh, the happstack-darcs could be installed
04:11:55 <Entroacceptor> but the tutorial depends on the helper...
04:13:03 <Entroacceptor> what a mess
04:17:59 <pokoko222> I am working on http://projecteuler.net/index.php?section=problems&id=59 and I need sugestion to improve my list for searching frequent words http://codepad.org/sRscN104 which i would use for the decryption process
04:21:22 <chipmonkpyro> anyone know what might be causing the message "*** Exception: Prelude.head: empty list"
04:22:09 <chipmonkpyro> ive run into it after loading my program, it seems to be caused by one of my predefined lists
04:22:10 <idnar> you're applying the head function to an empty list
04:22:12 <Entroacceptor> wtff does cabal want to re-install happstack-helpers-0.50
04:22:16 <Entroacceptor> i just installed it
04:22:26 <Entroacceptor> ghc-pgk list finds it
04:23:42 <ivanm> Entroacceptor: does ghc-pkg check say anything?
04:23:50 <ivanm> I'm guessing it's because some deps were upgraded or something
04:24:13 <Entroacceptor> nope
04:24:37 <Entroacceptor> or does cabal: cannot configure happstack-helpers-0.50. It requires containers
04:24:43 <Entroacceptor> not mean that it wants to reinstall it?
04:25:50 <chipmonkpyro> idnar: thanks fixed the problem.
04:26:29 <k23z__> is xmonad fast ?
04:26:34 <k23z__> comparable with wmii or dwm at least ?
04:26:39 <Axman6> sure
04:26:53 <k23z__> I tried to install it and lost like many many hours ... without any result, then when it worked it was a bit slow
04:27:30 <Axman6> sounds like you just asked a question about something you already seemed to have an answer to
04:27:35 <pokoko222> anyone has solved euler 59 ? can u tell me please what common words are used? i got big list for checking so far http://codepad.org/sRscN104 not sure if it is good
04:27:40 <pokoko222> http://projecteuler.net/index.php?section=problems&id=59
04:28:05 <pokoko222> so those are most frequent words i might find if i decrypt
04:29:27 <k23z__> Axman6: sounds like I was looking for oppinions from people who ran it
04:29:34 <k23z__> Axman6: I am also interested if it's flexible
04:29:37 <seit> in a haskell source file, is there a way to specify the extensions ghci should use?
04:29:39 <ivanm> k23z__: then ask in #xmonad !
04:29:53 <k23z__> ivanm: yeah .. but what the hell .. I thought I'd ask here as well
04:29:57 <ivanm> seit: ues, {-# LANGUAGE ... #-} at the top of your file
04:30:00 <Entroacceptor> k23z__: yes.
04:30:03 <Axman6> seit: {-# LANGUAGE BangPatterns #-}
04:30:11 <Entroacceptor> faster than wmii, comparable to dwm for me
04:30:12 <seit> ivanm, Axman6: great, thanks
04:31:01 <Axman6> k23z__: if we sounded a little narky, it sounded like a pretty trollish thing to ask, the way it was asked. my experience with Xmonad is that it didn't feel slow to me
04:31:55 <nagnatron> xmonad doesn't feel slow at all for me.
04:32:01 <k23z__> is it customizable ? to what extent
04:32:04 <k23z__> what can you customize ?
04:32:09 <k23z__> can I have different layouts ?
04:32:16 <k23z__> does it support the layouts of dwm ?
04:32:20 <k23z__> how about the layouts of wmii ?
04:32:25 <k23z__> how about the layouts of awesome ?
04:32:27 <Axman6> its extremely customisable
04:32:28 <k23z__> does it support those ?
04:32:36 <kalven> you just have to rewrite the code
04:32:40 <Axman6> it supports anything you can code
04:32:52 <Axman6> there's plenty of layouts others have written
04:33:06 <k23z__> hah .. well wmii supports anything I can code also, the problem is it's scripted in freackin bash which is completely horrible
04:33:16 <Axman6> but all the config for Xmonad is written in haskell, so if you know haskell, then you can do whatever you like
04:33:24 <Axman6> your imagination is the limit
04:33:40 <ben> yeah, for example you can start gnome's window manager inside it
04:34:17 <nagnatron> k23z__: You should check out the archlinux forum for some examples. A lot of people use it.
04:36:09 <k23z__> ben: what's the advantage ?
04:36:17 <ben> Not having to configure xmonad
04:36:26 <k23z__> I thought wmii,dwm,awesome and xmonad are all written in the minimalistic philosophy
04:36:44 <k23z__> if I start gnome window manager all the stuff will be slowed down by the bloated gnome
04:37:02 <k23z__> dwm for example is written in 2000 lines of C code
04:37:15 <pookleblinky> Xmonad is about the same size.
04:37:18 <k23z__> they claim they'll be able to keep it around 2000 LOC ...
04:37:20 <Axman6> i'd hate to see that code
04:37:54 <Axman6> Xmonad's code is very elegant, well thought out, and well structured
04:37:58 <k23z__> Axman6: well ... C will be here for a long loong time ...
04:38:02 <pookleblinky> 0:chaitin~/srcs/xmonad/XMonad% cat * |wc -l
04:38:02 <pookleblinky> 2622
04:38:30 <Axman6> as will Haskell ;)
04:38:35 <Jafet> They didn't say whether they would keep the line length
04:38:38 <Axman6> it's already been around for 20 years
04:39:09 <pookleblinky> Haskell has the prime benefit over C that linelength is about as low as you can go.
04:39:39 <pozic> pookleblinky: Haskell only has a niche in functional algorithms.
04:39:48 <Axman6> not really
04:39:48 <pookleblinky> C can increase sloc through boilerplate and such. But in haskell, an equivalent increase is something that actually adds functionality.
04:39:56 <pozic> pookleblinky: mutable algorithms are generally shorter in C.
04:40:14 <Axman6> my experience is they're about the same length
04:40:40 <pookleblinky> If I add 20 lines to Xmonad, rest assured those lines are actually implementing some functionality that would take 20*x more lines in an imperative language.
04:40:41 <Jafet> Mutable algorithms? Is that like when it overflows its own buffer with shellcode
04:40:55 <Axman6> heh
04:41:07 <Jafet> pookleblinky, for some imperative languages, x < 1.
04:41:15 <pookleblinky> pozic, have you actually browsed xmonad's source?
04:41:22 <pookleblinky> Look at stackSet.hs
04:41:26 <pookleblinky> It is elegant, minimal.
04:41:50 <Axman6> and safe!
04:41:51 <pookleblinky> You cannot, I will bet, duplicate its functionality in anything like its sloc.
04:42:02 <Axman6> you can make guarantees about StackSets
04:42:12 <Jafet> Only requiring a large, ugly, unsafe haskell runtime!
04:42:30 <pookleblinky> And, as Axman6 points out, you cannot duplicate the safety and assurance you get in haskell.
04:42:49 <kalven> but is it important?
04:43:03 <pookleblinky> If stackSet.hs left insecurities and possible sideeffects, it would not compile.
04:43:03 <Axman6> what, safety?
04:43:11 <kalven> yes
04:43:22 <pookleblinky> The very fact that it compiles means it is safer than the equivalent C code.
04:43:27 <Jafet> Are we talking about the same thing when we say "haskell"
04:43:52 <Jafet> unsafeIRCTroll :: (x -> IO ())
04:44:12 <pookleblinky> Ok. Time for a walkthrough.
04:44:13 <pookleblinky> data Workspace i l a = Workspace  { tag :: !i, layout :: l, stack :: Maybe (Stack a) }
04:44:14 <pookleblinky>     deriving (Show, Read, Eq)
04:44:24 <pookleblinky> From StackSet.hs
04:44:36 <pookleblinky> What does this code do? What does it tell you?
04:45:07 <kalven> that strictness annotations are used
04:45:19 <Axman6> pookleblinky: not a lot actually
04:48:13 <pookleblinky> Axman6, it tells you with but a simple ! that a workspace can never contain a thunky tag.
04:48:49 <pookleblinky> That Stack must return a safe value, and can never ever fuxor dependent functions.
04:48:58 * hackagebot hxt 8.5.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-8.5.1 (UweSchmidt)
04:49:26 <pookleblinky> !i ensures you will not get a memory leak, in other words.
04:49:55 <pookleblinky> Do you get the same assurance in C without massive scaffolds?
04:49:58 * hackagebot hxt-binary 0.0.2 - Serialisation and deserialisation of HXT XmlTrees.  http://hackage.haskell.org/package/hxt-binary-0.0.2 (UweSchmidt)
04:50:56 <burp> @pl liftM repeat
04:50:56 <lambdabot> fmap repeat
04:50:58 * hackagebot hxt-cache 0.0.3 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-0.0.3 (UweSchmidt)
04:59:22 <mreh> can I simplify updating repeated information in a Map with an extra layer of indirection, or does that sound more complicated than just putting up with it
05:00:21 <mreh> e.g. (1,3) and (3,1) in an adjacency matrix point to the same information
05:01:20 <mreh> but not necessarily to the same cell, to use graph jargon
05:06:43 <shapr> hiya carolyn
05:06:46 <shapr> How's code?
05:06:49 * shapr boings cheerfully
05:07:20 <shapr> My gitit instance is working nicely! http://www.scannedinavian.com:8080/
05:07:54 <mreh> I need a better abstraction than Man (Int,Int) Float for my adjacency matrix I think
05:08:06 <mreh> s/Man/Map/
05:11:33 <nainaide> In htmlParse :: String  -> String  -> Document  Posn, the ref said The first argument is the name of the file, the second is the string contents of the file. I do not understand why not just one parameter the Filename?
05:14:32 * shapr abstracts mreh with a TYPECLASS!
05:14:54 <Entroacceptor> so again, how can I get cabal to show me why it wants to reinstall a package?
05:16:43 <HandheldPenguin> Am slowly getting used to the haskell...however, I have this error...
05:16:43 <HandheldPenguin> http://haskell.pastebin.com/RMawhXmG
05:17:17 <harlekin> @pl (\s -> press s . release s)
05:17:17 <lambdabot> liftM2 (.) press release
05:17:37 <doserj> nainaide: the filename is just used for error messages, I think
05:19:25 <doserj> HandheldPenguin: you need a base case for the empty string
05:20:40 <HandheldPenguin> oh cool
05:20:41 <HandheldPenguin> Thanks
05:20:42 <HandheldPenguin> doserj
05:21:17 <shapr> God Morgon Alla!
05:21:34 <doserj> HandheldPenguin: also, a pet peeve: never use '== True' :)
05:21:43 <shapr> That's otherwise?
05:22:00 <doserj> it's just redundant
05:22:21 <HandheldPenguin> doserj is it just 'if contains x y' ?
05:22:33 <doserj> yes
05:22:45 <HandheldPenguin> Thanks
05:22:53 <HandheldPenguin> Gotta keep you peev free :)
05:23:52 <doserj> > let isTrue x = x == True in if isTrue True then True else False -- *cough*
05:23:53 <lambdabot>   True
05:27:42 <benmachine> @check (== True) == id
05:27:43 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Bool.Bool -> GHC.Bool.Bool))
05:27:43 <lambdabot>    arisin...
05:27:51 <benmachine> @check liftM2 (==) (== True) id
05:27:52 <lambdabot>   "OK, passed 500 tests."
05:28:09 * benmachine thinks that 500 tests may have been a little excessive, in fact
05:28:25 <int-e> @scheck liftM2 (==) (== True) id
05:28:26 <lambdabot>   "OK, passed 500 tests."
05:28:42 <benmachine> @help scheck
05:28:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:28:46 <benmachine> @help check
05:28:46 <lambdabot> check <expr>
05:28:46 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
05:28:56 <int-e> I thought we had a smallcheck command. hmm
05:30:12 <Szilva> hi, I have something like
05:30:13 <Szilva>  map (\ add @ x -> x+4 ) (map (\ s @ x -> x*x) [4,5,6])
05:30:15 <Szilva> [20,29,40]
05:30:24 <Szilva> but what I actually want is
05:30:44 <Szilva>  map (\ add @ x -> x+[4,5,6] ) (map (\ s @ x -> x*x) [4,5,6])
05:31:08 <Szilva> of course it is not corrent, I just want to find out how to get a result
05:31:08 <poucet> what
05:31:13 <poucet> what's with the add @ x?
05:31:25 <poucet> I mean, syntactically it works, but what's the point?
05:32:26 <Szilva> dunno
05:32:31 <poucet> @pl \l -> (zip (+) l (zip (*) l l))
05:32:31 <lambdabot> zip (+) `ap` join (zip (*))
05:32:36 <Szilva> i am reading someone else's code ;)
05:32:43 <poucet> > \l -> (zip (+) l (zip (*) l l)) $ [4,5,6]
05:32:44 <lambdabot>   Couldn't match expected type `[a]'
05:32:44 <lambdabot>         against inferred type `a1 -> a1 ...
05:33:05 <poucet> > \l -> (zipWith (+) l (zipWith (*) l l)) $ [4,5,6]
05:33:06 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
05:33:36 <Szilva> ok, what i want is to map a list to an other list, ie multiply the list with [4,5,6] each
05:33:56 <poucet> > (\l -> zipWith (+) l (zipWith (*) l l)) $ [4,5,6]
05:33:57 <lambdabot>   [20,30,42]
05:34:07 <poucet> Szilva: zipWith
05:34:12 <poucet> zipWith function list1 list2
05:34:45 <poucet> > zipWith (\x y -> x
05:34:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:34:58 <poucet> > zipWith (\x y -> x + y) [1..5] [6..10]
05:34:59 <lambdabot>   [7,9,11,13,15]
05:35:15 <Szilva> well, not exaclty
05:35:24 <Szilva> i want to get three lists as result
05:35:55 <poucet> oh
05:36:22 <poucet> so like a cartesian products using an operator
05:36:46 <pookleblinky> HandheldPenguin, you can also use pattern matching for conciseness.
05:36:48 <pookleblinky> http://www.haskell.org/tutorial/patterns.html
05:38:05 <HugoDaniel> hi
05:38:40 <Szilva> poucet: i want to calculate map (\x -> x+4 ) (map ( \x -> x*x) [4,5,6])  and map (\x -> x+5 ) .... and map (\x -> x+6 ).. all the three lists in one run
05:38:46 <poucet> yes
05:39:47 <pozic> pookleblinky: I did, but how is that relevant?
05:40:41 <poucet> > map (\f -> map f [1,2,3])  (map (*) [4,5,6])
05:40:42 <lambdabot>   [[4,8,12],[5,10,15],[6,12,18]]
05:40:44 <poucet> not the cleanest solution
05:40:55 <poucet> > map (\f -> map f [1,2,3])  (map (+) [4,5,6])
05:40:56 <lambdabot>   [[5,6,7],[6,7,8],[7,8,9]]
05:41:42 <NEEDMOAR> ls
05:41:55 <Botje> > liftM2 ($) [(+4),(+5),(+6)] [1..5]
05:41:56 <lambdabot>   [5,6,7,8,9,6,7,8,9,10,7,8,9,10,11]
05:41:59 <Botje> aww
05:42:26 <pookleblinky> pozic, I beg pardon? http://haskell.pastebin.com/RMawhXmG does not look canonical.
05:42:50 <pozic> pookleblinky: it would be nice if you would remember what you said.
05:43:12 <Szilva> poucet: ic
05:43:13 <pookleblinky> I agree.
05:43:38 <poucet> Botje: been a while (damn I'm getting rusty), but I thought there was a function that more easily gave a cartesian product
05:44:09 <Botje> yeah
05:44:14 <Botje> but i can't remember which one :)
05:47:04 <Szilva> well, good enough for me right now, thanks
05:47:54 <pozic> pookleblinky: that Haskell code is definitely not good.
05:48:13 <pookleblinky> I was being polite.
05:48:35 <pookleblinky> Now, explain how my comment to HandheldPenguin somehow involved you and pattern matching.
05:57:25 <amuller> hello!
05:57:35 <Botje> hello!
06:12:09 <Jonno_FTW> hello!
06:18:21 <esr> "On Learning Haskell" is up: http://esr.ibiblio.org/?p=1796
06:19:38 <djahandarie> Nice
06:23:42 <esr> I intended it as a sort of pre-tutorial, a couple of crucial clues for people about to read about the language.
06:26:02 <pozic> pookleblinky: "have you actually browsed xmonad's source?" is what you said.
06:27:38 <pokoko222> someone has solved this http://projecteuler.net/index.php?section=problems&id=59? I would use the information of what are the common words there. I try the decrypt with common ones like the, have, you, i get garbage. then i tried more complex words like something, anything, nothing, but i dont get anything for that...
06:29:06 <tensorpudding> i've solved that one
06:30:24 <pokoko222> oh my god u blessed soul come in pm :D
06:31:42 <Jafet> A strange thing about lisp evangelists is that many of them seem to not have heard of Haskell whatsoever, and ML is rarely to be seen
06:32:04 <Jafet> And then they describe "unique" features of lisp that have already been implemented for a long time in these languages
06:32:21 <pokoko222> i agree
06:32:34 <amuller> Hello, I am a newbie and I have a question regarding filtering multiple files using lazy IO and storing  the results lazily with writeFile.
06:32:44 <pozic> Jafet: are those IRL people?
06:32:45 <esr> Jafet: Learn some hoistory.  The LISP implementations typically predate ML and Haskell ones byt *decades*.
06:32:59 <pookleblinky> Odd. I'd have thought that my experience (voraciously playing with lisp, haskell, and ocaml simultaneously) was common
06:33:13 <Jafet> Well, the texts I read are fairly recent.
06:33:17 <pozic> Heh, esr himself.
06:33:44 <pookleblinky> esr, I was just reading your NetHack Guidebook :)
06:33:50 <esr> Yup.  LISP programmer since 1978, Haskell newbie.
06:34:12 <pozic> The IRL Lisp people I talked to simply chose Common Lisp for the availability of tools.
06:34:30 <pozic> Quite a sane business decision.
06:34:39 <Jafet> I don't know any programmers in real life...
06:34:45 <Jafet> So I can't comment on that
06:34:50 <esr> I haven't learned Ocaml yet.  It's on my list.
06:35:13 <pozic> People on the Internet are not interesting unless you know their background, imho.
06:35:22 <pookleblinky> I would have bet money that people who learn haskell have at least toyed with erlang, ocaml, etc. They are all brothers of a linguistic sort.
06:35:32 <pozic> They can say everything. That doesn't mean it has anything to do with reality.
06:35:54 <Ke> I am no brother to anyone who does weak or dynamic typing
06:36:03 <esr> But LISP truly is the granddaddy of FP languages.  When LISP evangelists claim priority, they mat be tiresome but they are usually right.
06:36:14 <Ke> haskell is much more than just functional programmin
06:36:36 <pookleblinky> LISP is objectively the local maximum of language design.
06:36:52 <Ke> "Ok"
06:36:56 <esr> One local maximum, yes.
06:37:01 <pozic> LISP is not used by anyone anymore. Scheme or Common Lisp are.
06:37:12 <pookleblinky> But that doesn't mean its children aren't unique and beautiful snowflakes in their own right.
06:37:18 <Jafet> Don't forget AutoCAD lisp.
06:37:24 <pozic> Well, except for a few weird people that do theoretical computer science.
06:37:27 <Jafet> I think it doesn't have let-bindings.
06:37:34 <pozic> Jafet: they have abandoned that already.
06:37:43 <pozic> Jafet: or at least, they want to do that.
06:37:43 <Jafet> Thank heavens
06:37:51 <pookleblinky> pozic, ever read Chaitin's Algorithmic Information Theory?
06:38:01 <pozic> pookleblinky: that was what I was referring to.
06:38:09 <pookleblinky> Chaitin encoded a LISP into a huge diophantine equation.
06:38:11 <pozic> pookleblinky: weird people that do theoretical computer science
06:38:12 <pookleblinky> And ran it.
06:38:17 <pozic> pookleblinky: yes, I know...
06:38:18 <pookleblinky> Tell me that isn't cool.
06:38:32 <pozic> pookleblinky: it would be if I didn't already know about it.
06:39:15 <pookleblinky> pozic, it is a lisp encoded in fundamental mathematics. iirc, no one has tried that with Java.
06:39:47 <pozic> pookleblinky: everyone knows Java is overcomplicated.
06:39:58 <pookleblinky> If your language is elegant enough to be ported to the ultimate virtual machine, existing in pure platonic ethers, it should tell you something.
06:40:17 <pozic> pookleblinky: now you just sound like Chaitin.
06:40:41 <Philippa> esr: You comment that Haskell pushes static typing to some kind of logical limit - something like Coq or at least Agda is arguably much closer to one?
06:40:44 <pookleblinky> No, properly I should add more exclamation points and sheer enthusiasm.
06:40:45 <poucet> LISP is truly the granddaddy of FP language just like prokaryotes are the granddaddy of humans.
06:41:16 <pozic> In ten years I probably write my stuff in Coq.
06:41:18 <esr> Philippa: It's possible; I'd have to learn them.
06:41:20 <pookleblinky> Chaitin always seems on the verge of shouting and running through the streets screaming esoteric formulae in a giddy tone.
06:41:32 <pozic> Or preferably something simpler, but with the same expressive power.
06:41:49 * esr think Chaitin is prone to unhelpful grandstanding
06:42:15 <Jafet> That depends on which type systems you include in the term "Haskell"
06:42:26 <Jafet> hs98 doesn't push many grand type theory boundaries
06:42:39 <Philippa> esr: you don't actually have to learn them per se; understanding the Curry-Howard isomorphism's good enough
06:43:27 <esr> Philippa: I grasp what it means but don't know how to apply it formally.
06:43:48 <Jafet> @djinn a -> (a -> b) -> b
06:43:49 <lambdabot> f a b = b a
06:43:59 * esr goes to look up Coq
06:44:00 <Philippa> *nod* - both Coq and Agda are/contain much more useful logics than Haskell, essentially
06:44:37 <amuller> Hello! I have a question regarding lazy I/O, can someone help me please?
06:47:08 <pookleblinky> http://coq.inria.fr/cocorico/SquareRootTwo this is quite beautiful.
06:50:08 <pookleblinky> esr, http://coq.inria.fr/cocorico/QuickSort !
06:50:21 <Jafet> Sexy.
06:50:48 <pookleblinky> pozic, it looks like coq makes it near impossible to write incorrect code.
06:50:57 <pozic> pookleblinky: that is the idea.
06:51:19 <Jafet> Unfortunately "correct" does not imply "does what I want".
06:51:34 <pozic> I don't really buy Jafet's argument.
06:51:58 <Jafet> I don't really buy that you can argue with that.
06:51:59 <pozic> A "star programmer" can always write the lemma's, which then have to be proven by the army of programmers.
06:52:19 <esr> Hm. The QuickSort example seems easier to understand.
06:52:21 <pozic> There is really no way to fool the system then.
06:52:28 <Jafet> That reminded me of the term "code monkey"
06:52:48 <Jafet> Literal code monkeys. Humanity can only advance.
06:53:13 <pozic> Jafet: in some sense everyone is a code monkey. How often do you write algorithms that have an undecidable property?
06:57:33 <yakov> hey
06:58:00 <pookleblinky> pozic, I like it, but it seems too much like an ADA for CS for me to see it becoming popular.
06:59:02 <pookleblinky> In how many circumstances is it worth coding in Coq versus Ocaml, a similarly extremely-academic language?
07:00:00 <pookleblinky> I mention ocaml because despite its academic origins and uses, it also happens to be surprisingly high performance.
07:00:35 <yakov> you can't even do io in coq..
07:01:13 <pookleblinky> yakov, that's kind of like saying PM doesn't accept IO.
07:02:25 <pookleblinky> It seems the point of Coq is to create an executable formal system. Very useful for what it aims at.
07:03:18 <yakov> I mean it's quite unfair to blindly compare Coq  vs Ocaml in general
07:03:45 <pookleblinky> Coq is bound to be useful for a subset of problems which require enormous rigor.
07:04:42 <nostrand^^> are there som benchmarks between different versions of GHC? 6.12 seems to be _a lot_ faster than 6.8 =)
07:05:53 <nostrand^^> 20s to 0,2s by only switching to a newer compiler is nice
07:06:40 * esr is reading an Ocaml tutorial
07:07:51 <krey> hello
07:07:58 <krey> can somebody help me with the state monad?
07:08:03 <pookleblinky> yakov, http://code.google.com/p/flyspeck/wiki/FlyspeckFactSheet
07:08:15 <pookleblinky> This kind of stuff seems tailor made for Coq.
07:08:19 <nostrand^^> i'm taking a course in Haskell and O'Caml soon. Nice to get credits for that :D
07:08:54 <pookleblinky> But I would point out that not only can ocaml do this, but it can also be used to write webservers and such.
07:09:07 <shepheb> I'm in class where we're learning about the IO monad right now.
07:09:24 <shepheb> I'm waiting to get to the interesting monads. just done Maybe, State and IO so far. IO is boring.
07:10:12 <nostrand^^> shepheb: =)
07:10:49 <pozic> shepheb: the reverse state monad is a nice academic exercise.
07:11:03 <pozic> shepheb: and I am sure they won't talk about that :)
07:11:05 <shepheb> I already know Haskell well, so it's fairly dull. hence, IRC.
07:11:17 <pozic> shepheb: you could ask the teacher to humuliate him ;)
07:11:32 <shepheb> pozic: haha I mentioned it to the prof after class on Monday and he emailed me about it yesterday, clutching his skull
07:12:18 <pozic> shepheb: I don't consider it a bad thing if they don't know that, though.
07:12:21 <quicksilver> krey: almost certainly, but no one will help you until you can ask your question
07:12:29 <krey> great
07:12:30 <pozic> shepheb: it is worthless knowledge.
07:12:37 <pozic> quicksilver: hah, you couldn't resist.
07:12:57 <pozic> Lazy I/O, lazy I/O, lazy I/O.
07:13:04 <krey> i am trying to construct the state monad from a join and fmap
07:13:28 <krey> and i don't seem to get the same result as the "proper" state monad
07:13:29 <pozic> I am confusing two people. Ignore me.
07:14:12 <quicksilver> krey: what differences do you see?
07:14:20 <quicksilver> krey: and what are your join + fmap?
07:15:37 <yakov> pookleblinky, they use HOL AFAIS
07:16:03 <krey> fmap f xs = (\x -> (\(y,z) -> (f y, z)) (apply xs x))
07:16:27 <krey> where apply is what it should be
07:16:31 <HandheldPenguin> Why is this removing every occurence of the given character...? http://haskell.pastebin.com/QF1rNP0k
07:16:42 <pookleblinky> yakov, Hol-lite, ocaml, and coq are all being used.
07:17:01 <quicksilver> krey: what's your state type?
07:17:11 <krey> ooh, sorry
07:17:20 <krey> states are integers
07:17:31 <quicksilver> no, that's not what I meant
07:17:43 <krey> data = State a = S (Int -> (a, Int))
07:17:52 <krey> apply (S x) = x
07:18:01 <krey> opps
07:18:03 <krey> typo
07:18:11 <quicksilver> ok
07:18:16 <krey> data State a = S (Int -> (a, Int))
07:18:49 <quicksilver> ok, the fmap looks fine :)
07:18:51 <pastorn> how do i export modules?
07:18:58 <quicksilver> what about join?
07:19:18 <pastorn> i.e. i want to avoid having "import Data.Map (Map); import qualified Data.Map as M;" in all my files...
07:19:39 <quicksilver> (well the fmap isn't quite fine; it's missing an 'S' somewhere, but I assume you must have that or it wouldn't compile)
07:19:43 <pastorn> instead i just want to have "import Base" and that should fix everything...
07:19:47 <krey> join xs = S (\a -> (\(b,c) -> (apply b c)) (apply xs a))
07:19:56 <quicksilver> pastorn: you can't export qualifications.
07:20:01 <pastorn> aww
07:20:20 <quicksilver> to export modules you just write 'module Foo' in your export
07:20:37 <pastorn> cool
07:21:09 <pastorn> can i export just the Map constructor?
07:21:28 <quicksilver> yes, you can export anything in scope
07:21:43 <Botje> HandheldPenguin: that function looks fundamentally broken, actually
07:22:21 <quicksilver> krey: join looks right to me
07:22:34 <danderson> is there a way that I can help the GHC RTS to a heap profile (eg. insert a function call somewhere to tell it to take a heap sample *now*) ?
07:22:58 <danderson> my program is so I/O heavy that even with high resolution and running for 8-10 hours, it can only capture about 3 seconds worth of samples
07:23:05 <krey> quicksilver: ok, thank you, maybe I just didn't try hard enough to prove that it was equivalent to the "official" version
07:23:10 <HandheldPenguin> Botje: How so? It seems to remove every occurence fairly successfully :D
07:23:38 <quicksilver> krey: there is only really one mistake you can make, which is accidentally reusing the initial state instead of the middle one
07:23:55 <quicksilver> krey: apart from that, the type checker means there is only really one thing you can write.
07:24:03 <amuller> Hello, I want to lazily read a set of files with "readFile", filter the lazily read strings, and finally write each result into one single file using appendFile. When I do the same filtering using readFile and writeFile (in the way shown in real world haskell chap 7) for one file no leaks ocurr. When I do a mapM_ my memory explodes. What is the best way to lazily operate on a set of input files and store the result in one file?
07:24:20 <quicksilver> krey: that is, you could write (apply b a) instead of (apply b c)
07:24:53 <krey> quicksilver: thanks again, ima get back to prove this on paper
07:25:19 <krey> quicksilver: we don't use computers for haskell, that would be stupid
07:25:22 <krey> :)
07:26:27 <pastorn> quicksilver: exporting modules isn't working :(
07:26:48 <pastorn> i have "module Control.Monad.Reader; module Control.Monad.State;"
07:27:01 <pastorn> ghc spews warnings out its ass
07:27:03 <Botje> HandheldPenguin: it also removes everything that is NOT that character, up to the first occurrence.
07:27:28 <HandheldPenguin> really?
07:27:55 <quicksilver> pastorn: why would you put a semicolon in an export list?
07:28:05 <benmachine> pastorn: warnings?
07:28:17 <quicksilver> pastorn: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/mtl/src/Control-Monad-State-Lazy.html
07:28:25 <Botje> amuller: now i see your question :) can you put your code on hpaste?
07:28:25 <quicksilver> (just as an example of some haskell source with module exports)
07:28:25 <pastorn> quicksilver: i wanted to emphasize line breaks
07:28:38 <amuller> sure!
07:28:46 <quicksilver> then perhaps I should say "why would you forget to put a comma" ;P
07:28:56 <pastorn> Base.hs:18:6:
07:28:57 <pastorn>     Warning: `fmap' is exported by `module Control.Monad.State' and `module Control.Monad.Reader'
07:29:35 <amuller> Hello Botje, I am getting an 500 Internal Server Error from hpaste... any alternative location?
07:29:51 <pastorn> quicksilver: why do you show link me to the lazy state monad?
07:31:52 <amuller> You can also get the file from here: http://tierra-aoi.net/fastaReader.hs
07:35:30 <pookleblinky> amuller, www.ideone.com
07:35:55 <pookleblinky> Not only does it have haskell syntax highlighting, but it can execute haskell code.
07:36:24 <amuller> pookleblinky: thanks, here is the link: http://ideone.com/PpwVr2hk
07:37:30 <pookleblinky> Hm "prog: user error (Pattern match failure in do expression at prog.hs:48:7-33)" seems entirely unrelated to your problem.
07:37:57 * hackagebot disassembler 0.1.0 - Disassembler for X86 & AMD64 machine code  http://hackage.haskell.org/package/disassembler-0.1.0 (DirkKleeblatt)
07:37:59 * hackagebot harpy 0.4.2 - Runtime code generation for x86 machine code  http://hackage.haskell.org/package/harpy-0.4.2 (DirkKleeblatt)
07:38:09 <amuller> pookleblinky yes, I am not even getting the error with ghc 6.10.4
07:39:06 <amuller> In line 55 I am trying to operate on a set of files by using a Map_ and I believe my space leak should be caused here...
07:40:46 <Botje> amuller: you should probably switch to bytestrings
07:41:06 <Botje> every element of a [Char] takes 24 bytes of memory, so if your fasta files are biggish .. :(
07:41:14 <Botje> amuller: you're compiling with optimizations on, right?
07:41:33 <amuller> yes I am using -O2
07:41:37 <pookleblinky> amuller, are you running it with --enable-executable-profiling ?
07:42:01 <amuller> pookleblinky, I have not tried --enable-executable-profiling
07:42:13 <pookleblinky> http://www.haskell.org/haskellwiki/How_to_profile_a_Haskell_program
07:42:39 <amuller> Botje, I have heard that bytestrings are faster. However when I use the same code on one input file and one output file there is no leak.
07:43:23 <amuller> The memory grows quickly and it doesn't stabilize. Swapping comes in and then I have to kill the process. The profiling I tried shows a constant growth of memory.
07:43:55 <amuller> pookleblinky, I tried profiling in the way explained in Real world haskell chapter 25
07:44:26 <amuller> It seems that haskell is keeping all the large strings in memory because mem fills very quickly
07:46:30 <Botje> myeah
07:48:35 <Botje> it could be because you bind the file to a name in genomeExecute
07:48:47 <Fare> Are we Haskelletons?
07:48:54 <Saizan> amuller: the profiler output should tell you what's using the memory
07:49:21 <Saizan> haskellers
07:49:38 <pookleblinky> Fare, could be worse. He could have said Haskeletors
07:50:14 <amuller> Botje what do you suggest to avoid this bind?
07:51:07 <amuller> Saizan, my last profile shows a peak that is caused by ":"
07:51:10 <Botje> actually, no. that's silly :(
07:51:46 <amuller> I am puzzled because the same code only focused on only one file will work fine with a constant amount of memory :(
07:52:47 <Saizan> ?hoogle appendFile
07:52:48 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:52:48 <lambdabot> Data.ByteString appendFile :: FilePath -> ByteString -> IO ()
07:52:48 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:52:50 <Fare> pookleblinky, are we Ha-men ?
07:54:28 <pookleblinky> That would imply some other language users are Thundercats.
07:54:47 <pookleblinky> Who is the Snarf Snarf of Python?
07:55:03 <Saizan> amuller: is the single file you're testing with one of the largest?
07:55:47 <Botje> amuller: laziness is biting you somewhere, but i can't tell where :[
07:55:58 <Fare> laziness will bite you, someday.
07:56:04 <amuller> No, I have to correct myself... Only one file still causes the leak. Nevertheless:
07:56:05 <Fare> but it's in no hurry to.
07:56:07 <amuller> main = do
07:56:07 <amuller>        -- get the arguments
07:56:07 <amuller>        [input, output, windowSize] <- getArgs
07:56:07 <amuller>        -- keep the input stream
07:56:07 <amuller>        inpStr <- readFile input
07:56:07 <amuller>        let wSize = (read windowSize)::Int
07:56:09 <amuller>        writeFile output $ fastaExtractor inpStr wSize
07:56:14 <amuller> this main doesn't have the leak
07:56:59 <amuller> I wonder what the issue might be... Thanks anyway Botje pookleblinky and Saizan
07:58:07 <Polarina> Does anyone have an example on how to properly use System.USB to write and read an interrupt?
07:58:31 <pookleblinky> woah, don't thank me. I am a stumbling fool.
08:00:45 <amuller> sorry Saizan, I didn't see your msg. Yes the only file I am testing is large... around 200MB
08:01:20 * Saizan hopes the issue isn't getDirectoryContents
08:01:50 <jmcarthur> a 200MB file is going to be huge in memory using String
08:02:09 <Saizan> yeah, but he doesn't have a leak with that one
08:02:15 <amuller> ah OK so it could be the directory contents? is there a way of making this operation strict Saizan?
08:02:44 <Saizan> only when he mapM_ on a bunch of them, but he's processing one at a time
08:02:56 <Saizan> amuller: i think getDirectoryContents is strict
08:03:59 <amuller> Saizan: so if it is strict that should not be causing the issue? At the beginning I was reading the strings with readFile, storing them in the list and then I was concating the results but it also gave me issues.
08:04:07 <lispy> Is there an easy way to tell vim that the .hsc file I loaded should be highlight as haskell?
08:04:22 <pookleblinky> amuller, you could use quickcheck to generate a testcase for each component
08:04:53 <Saizan> amuller: if the directory has a very large number of files the result might use a lot of memory. perhaps
08:04:57 <amuller> pookleblinky, so with quickcheck can I get info. on space leaks?
08:05:15 <amuller> Saizan, the dir contains only 23 files... (23 chromosomes :))
08:05:30 <Saizan> ok, so it's not that :)
08:05:48 <pookleblinky> lispy, add a rule extending haskell mode to .hs*
08:05:57 <amuller> in total the files sum up 4GB, the problem is that the memory is exhausted even when processing the first file, Saizan.
08:06:13 <pookleblinky> http://projects.haskell.org/haskellmode-vim/
08:06:34 <Botje> amuller: can you try making the arguments to Window strict?
08:06:35 <Saizan> amuller: ah, but that same first file doesn't cause problems if you use the main you've pasted in channel?
08:06:40 <Botje> on the last line of readFasta
08:06:54 <amuller> to add ! to each window argument?
08:07:03 <Fare> When is the next BostonHaskell meeting?
08:07:12 <amuller> Saizan, yes the main that I pasted is fine.
08:07:18 <lispy> pookleblinky: I guess I'm too new to vim to understand that webpage.  I did find it before asking, but nothing there helped me
08:07:58 <amuller> Botje, I am a newbie really and I don't know how to make this line strict... :) any hint?
08:08:26 <Botje> chr `seq` map (\(i, w) -> i `seq` w `seq` Window w chr i)
08:08:29 <Botje> OR
08:08:38 <Botje> add a ! in front of the types in the Window declaration
08:08:45 <lispy> pookleblinky: in particular, I found this: http://projects.haskell.org/haskellmode-vim/vimfiles/ftplugin/haskell.vim
08:08:56 <Botje> hmm
08:08:58 <Botje> nah
08:09:10 <lispy> pookleblinky: but when I typed the last line: setlocal suffixesadd=hs,lhs,hsc  at the colon prompt in vim, nothing seemed to change
08:09:21 <Botje> chr `seq` map (\(i, w) -> i `seq` length w `seq` Window w chr i)
08:09:30 <Botje> bolmar: use that instead of the map ... in readFasta
08:09:54 <amuller> Botje, I added ! to the types of the window declaration but it is still leaking...
08:10:15 <Botje> oh, bleh.
08:10:22 <Botje> you need to seq some more :(
08:11:06 <amuller> thanks Botje! :) I will continue seq'ing :)
08:11:21 <Botje> amuller: I think the Window elements are retaining references to the file, which means that haskell can't release it
08:12:05 <amuller> ah really? I see... so even when I print the results the window objects remain floating
08:12:16 <amuller> ?
08:12:28 <Botje> once you print, they're evaluated
08:13:02 <Botje> but haskell has to keep the entire file in memory because your different strings still point into it
08:13:12 <Botje> and 4gb * 24 is a lot
08:13:36 <Saizan> 4gb is the sum of all the files
08:14:22 <amuller> ah I see!
08:14:26 <Saizan> also, what you say applies to a single file at a time
08:14:42 <amuller> when I use the main function that I posted before the memory utilization remains constant.
08:15:15 <Botje> because you don't pass by genomeExecute, you just immediately print them
08:15:20 <Saizan> once you start procesing the second file the Window produced with the first file should be garbage already
08:15:22 <Botje> haskell can fuse /that/ nicely
08:15:31 <Botje> hmm, that's true too
08:15:40 <Botje> bah :(
08:15:49 <pookleblinky> amuller, with quickcheck you can test for a specified property, not only formal (does this sort actually consistently sort?) but performance-wise as well.
08:16:12 <BrianHV> I realize that monads are well covered on the web, but I can't find a simple definition anywhere... is a monad just an entity with bind and return operations?
08:16:16 <amuller> ah ok pookleblinky, I will take a look at quickcheck
08:16:50 <amuller> Botje the chr `seq` map (\(i, w) -> i `seq` length w `seq` Window w chr i) also has problems...
08:16:54 <Saizan> BrianHV: it's a type contructor M for which return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b are defined
08:17:03 <Botje> boo :(
08:17:07 <amuller> :(
08:17:21 <Botje> then you'll have to wait for one of the wizards to show up
08:17:24 <pookleblinky> For instance, you could extract getDirectoryContents, then construct both test data and a unit test.
08:17:40 <Saizan> amuller: i'd try each of those 23 files in isolation with the main above
08:17:59 <amuller> to make sure there is no leak right Saizan?
08:18:01 <BrianHV> Saizan: ok.  that sounds simple enough.  I haven't done much haskell yet, but I don't understand what I'm supposed to find difficult about that...
08:18:18 <Saizan> amuller: yeah, to make sure the input data is not relevant
08:18:31 <Saizan> BrianHV: nothing :)
08:18:38 <amuller> Botje, thanks! What are some nicknames of wizards?
08:18:56 <Saizan> BrianHV: maybe the most difficult part is realizing monads are very simple
08:19:11 <amuller> yep, I will play with this Saizan, thanks.
08:19:13 <Saizan> BrianHV: and/or understanding how typeclasses work in general
08:20:05 <Saizan> BrianHV: then some specific monad implementations might be puzzling if you're not used to functional programming, e.g. the State or Cont ones
08:20:27 <BrianHV> Saizan: perhaps so.  I guess I won't worry about it then. :)
08:20:52 <maltem> BrianHV, Saizan forgot to mention the properties that return and (>>=) should fulfill, though
08:21:11 <Saizan> ah, yeah
08:21:39 <Saizan> but they are mostly common sense, especially if you see the do-notation version
08:22:16 <maltem> Let's see, do I still remember them off-hand?
08:22:23 <bjorkintosh>  why do people keep saying haskell's so damned fast when it's taken nearly a whole day to compile batteries?
08:22:26 <maltem> 1.   m >>= return    = m
08:22:27 <Saizan> http://www.haskell.org/haskellwiki/Monad_laws
08:22:36 <maltem> 2.    return x >>= f      = f x
08:23:13 <maltem> 3.   (m >>= f) >>= g     = m >>= (\x -> f x >>= g)
08:23:33 <Saizan> bjorkintosh: maybe an haskell compiler written in another language would be slower :)
08:23:34 * BrianHV needs to work his way over some syntax hurdles
08:23:46 <maltem> Have I got all of them?
08:23:53 <Saizan> bjorkintosh: a whole day is pretty unusual though, how much memory do you have?
08:24:02 <bjorkintosh> 512mb
08:24:31 <jmcarthur> bjorkintosh: (a) that's a low amount of memory for GHC, (b) nobody ever said the compiler was fast, just the generated code ;)
08:24:47 <jmcarthur> or if somebody did say the compiler itself is fast, i disagree
08:25:01 <Saizan> bjorkintosh: if you disable object splitting it should use less memory
08:25:05 <maltem> jmcarthur, now don't tell anyone who generates GHC's code
08:25:32 <Saizan> the most memory intensive part of compiling GHC generated code are the ld calls, because ld sucks
08:26:57 <Botje> hmm
08:27:04 <Botje> could we use gold in its place?
08:27:12 <Fare> the compiler itself is fast!
08:27:27 <Saizan> i did for a while and didn't have any problem
08:28:19 <bjorkintosh> fast? is clearly relative.
08:28:24 <medfly> bjorkintosh, I have the same problems (512mb ram too)
08:28:29 <medfly> it's fast if you don't swap :p
08:28:44 <bjorkintosh> how do i remind it not to swap?
08:28:53 <bjorkintosh> also, how is it that there isn't a batteries package for ubuntu?
08:29:22 <Saizan> ask the debian maintainers :)
08:29:57 <Saizan> maybe there are only the single packages and not a batteries metapackage?
08:36:55 <jmcarthur> ghc tends to be faster the g++ for me, but next to gcc it's kind of slow, and next to ocaml it's insanely slow
08:37:04 <jmcarthur> *faster than g++
08:37:55 <bjorkintosh> jmcarthur, what about the compiled binary from ocaml?
08:37:59 <bjorkintosh> how does it compare to haskell's?
08:38:15 <pozic> bjorkintosh: is is easier to get fast code in OCaml, I think.
08:38:20 <jmcarthur> bjorkintosh: it used to be that ocaml's was faster, but i think ghc has surpassed it
08:38:20 <zygoloid_> jmcarthur: GHC is amazingly fast i think. but i'm used to c++ :D
08:38:38 <jmcarthur> zygoloid_: you should try the ocaml compiler then ;)
08:38:49 <pozic> GHC just has to do more work than other compilers and it is written in Haskell, which makes it slower.
08:39:00 <jmcarthur> pozic: that latter thing is not a reason
08:39:01 <pookleblinky> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=ocaml&lang2=ghc for what it's worth
08:39:12 <djahandarie> jmcarthur, have you tried with different backends?
08:39:18 <bjorkintosh> pozic, so you're saying ghc is slow and won't speed up any time soon.
08:39:34 <pozic> bjorkintosh: Haskell in principle is not slow.
08:39:35 <jmcarthur> djahandarie: ghc?
08:39:56 <quicksilver> it's true that the linker phase is rather slow and that's ld's fault, but the compile phase is also pretty slow with -O2
08:40:01 <bjorkintosh> it's pretty telling if the compiler written in it's own language is that slow, and claims abound about the speed of binaries.
08:40:05 <quicksilver> (try running without -O and compare)
08:40:06 <pozic> bjorkintosh: unless you do interactive editing of large files, GHC is fine.
08:40:12 <jmcarthur> djahandarie: the gcc backend is slower to build than the native code gen for me, but the results depend on the particular program
08:40:27 <pozic> bjorkintosh: that is, something that takes more than 5 seconds to load.
08:40:29 <quicksilver> bjorkintosh: it's not slow because it's written in haskell; it's slow because it does some fundamentally slow things
08:40:31 <bjorkintosh> finding a fortran replacement is going to be harder than i thought.
08:40:44 <djahandarie> jmcarthur, how about the LLVM backend? >:D
08:40:59 <jmcarthur> djahandarie: i haven't tried it yet. i'd like to, but i want to let it mature a bit
08:41:21 <pozic> jmcarthur: GHC still copies lots of stuff which is not needed.
08:41:35 <ezyang> good morning #haskell
08:41:43 <ezyang> My software engineering class is doing FP in Java :-)
08:41:55 <lispy> ezyang: um?  WHat? :)
08:41:57 <arw_> ieh.
08:41:59 <jmcarthur> pozic: you mean the resulting program has oberly redundant code?
08:42:04 <ezyang> lispy: :-P
08:42:04 <pozic> jmcarthur: when a computer gets a different architecture, then it will become a moot issue.
08:42:06 <lispy> ezyang: as in, making an interpreter or?
08:42:07 <jmcarthur> *resulting binary
08:42:13 <pookleblinky> Sounds like a headache waiting to happen, ezyang
08:42:14 <ezyang> Nope. Writing functional code in Java.
08:42:15 <davpla> HI:  I'm running GHC 6.10.4 on Mac OSX 10.6.2.  I want to install the Haskell Platform.  Do I need to uninstall the current GHC first?
08:42:20 <pozic> jmcarthur: no, I mean that GHC in its internal data structures copies a lot.
08:42:39 <pozic> jmcarthur: because GHC itself doesn't optimize all those copies away.
08:43:14 <jmcarthur> pozic: like deep copies?
08:43:24 <pozic> jmcarthur: no, like the following:
08:44:02 <pozic> jmcarthur: data Foo = Foo Int Int Int (repeated N times), and then changing one field takes N time, not O(1).
08:44:14 <gwern> the more I read about issues with inlining and optimizing, the more I wonder whether separate module compilation (as opposed to wholeprogram ocmpilation) is really worthwhile
08:44:30 <jmcarthur> gwern: me too
08:44:39 <pozic> jmcarthur: if it would recognize single threaded code _always_, a C like language would have no place anymore in this world.
08:45:05 <jmcarthur> pozic: ah, yeah that kind of thing is still a flaw in our compilers
08:45:29 <pozic> jmcarthur: on a graphics card, all you have is copies, so it doesn't matter.
08:45:37 <jmcarthur> gwern: i think if we would put some more effort into whole program optimizing compilers then we would come up with effective caching strategies that aren't artifically bounded by modules
08:45:58 <maltem> Btw, is the (relatively) long time that ghci loads due too the linker?
08:46:20 <gwern> jmcarthur: indeed. look at how c++ devs get by
08:46:21 <pozic> maltem: long time? During what?
08:46:23 <jmcarthur> gwern: so we ultimately wouldn't even have to deal with those long build times that whole program optimizers are hated for, i think
08:46:37 <ben> C++ devs get by?
08:46:57 <jmcarthur> i don't think c++ really does it right ;)
08:46:58 <gwern> ben: they get *something* alright
08:47:22 <ben> The C++ developers I know would kill to get our module system
08:47:40 <maltem> pozic, when typing "ghci" and waiting half a second or so for it to come up, on a slow netbook :p
08:47:55 <gwern> my point being that even bizarre terrible systems have been worked around, so a good whole-program compiler?
08:48:10 <ben> Right
08:48:41 <pookleblinky> time ghci gives me:
08:48:43 <pookleblinky> ghci  0.26s user 0.05s system 2% cpu 10.929 total
08:49:04 <pozic> maltem: user0m0.288s hmm, I suppose you are right.
08:49:20 <pozic> maltem: I only start one ghci per day.
08:49:52 <pozic> maltem: actually, that's not true. Also, when I install a new library that I need.
08:50:03 <pozic> Linking is slow, because it is messy on Linux.
08:50:20 <pookleblinky> Good point. If you're using haskell-mode in emacs or vim, you've likely got a ghci instance for the entire time you're hacking
08:50:32 <pozic> If linking would be understood by everyone, it would be faster.
08:50:35 <jmcarthur> gwern: Max Bolingbroke's email makes me feel a little better about this particular situation
08:50:44 * Twey doesn't understand linking
08:50:44 <pozic> By linking I mean the actual code used to link.
08:50:50 <bjorkintosh> pozic, is it broken?
08:51:09 <pozic> I understand how it is supposed to work, but I think it is a miracle how the linker actually gets its job done.
08:51:26 <pozic> If there are no security issues there, I would be very surprised.
08:51:30 <pozic> So, go and exploit.
08:51:31 <bjorkintosh> so the linker is the reason haskell's so slow?
08:51:37 <bjorkintosh> how does ocaml get it right then?
08:51:40 <pozic> bjorkintosh: Haskell is not slow.
08:51:49 <gwern> you're just too fast
08:52:04 <pozic> bjorkintosh: it is just not mega-fast and it is certainly not slow at the language it executes.
08:52:21 <bjorkintosh> no. it seems like given gigabytes of ram and ghz of speed, haskell is ghc is magically fast!
08:52:30 <pozic> bjorkintosh: there is no fundamental reason for Haskell to be slow.
08:52:38 <bjorkintosh> but yet it is.
08:52:47 <bjorkintosh> it's the first time i've had to compile this sort of thing.
08:52:52 <pozic> bjorkintosh: that is an assertion.
08:52:52 <bjorkintosh> *not the first time.
08:53:01 <pozic> bjorkintosh: what exactly is slow?
08:53:04 <maltem> pozic, heh, I keep starting ghci instances here and there. I must truly have strange habits
08:53:57 <pookleblinky> maltem, is it because you're not loading and unloading modules?
08:54:10 <pozic> Anyway, truly fast code comes from an understanding of the architecture in the end and every single line runnning.
08:54:19 <pozic> In Haskell you give up some of that by using GHC.
08:54:29 <bjorkintosh> ah.
08:54:34 <bjorkintosh> is there an alternative?
08:54:43 <pozic> bjorkintosh: write everything in assembly.
08:54:55 <pookleblinky> :load without any args unloads everything but prelude.
08:54:59 <maltem> pookleblinky, more because I don't spend much time on a single Haskell project. E.g. a major use of ghci for me is as a calculator ^^
08:55:04 <pozic> bjorkintosh: Python is slow. Haskell is not.
08:55:16 <gwern> maltem: a major use of #haskell for me is as a calculator ^^
08:55:18 <bjorkintosh> hmm.
08:55:32 <bjorkintosh> i guess i wouldn't be complaining if i weren't using something as brain dead as debian for haskell.
08:55:42 <pookleblinky> maltem, that is why Cthulhu invented GNU Screen
08:55:49 <bjorkintosh> it won't even run ghc interactively.
08:55:50 <pozic> bjorkintosh: so where is this supposedly slow Haskell code?
08:56:03 <pookleblinky> C-a to a conveniently running ghci instance
08:56:05 <bjorkintosh> pozic, as i just explained, i had to compile batteries on my machine.
08:56:14 <pozic> bjorkintosh: what is batteries?
08:56:16 <bjorkintosh> i started yesterday at around 9.
08:56:19 <pookleblinky> Or C-x b ghci RET
08:56:21 <pookleblinky> etc
08:56:21 <bjorkintosh> the haskell platform.
08:56:33 <pozic> bjorkintosh: and why would you want to do that?
08:56:34 <bjorkintosh> and it finished compiling a few minutes ago.
08:56:35 <liyang> pozic: Hand-rolling assembly with today's pipelines/out-of-order-execution/superscalar architectures? Good luck.
08:56:52 <bjorkintosh> pozic, it's the only way to get it running on a debian system. there's no installable package for it.
08:56:53 <maltem> pookleblinky, it's not like I cannot stand the time ghci is loading :)
08:57:16 <pozic> liyang: you would have to read the architecture manual very precisely and probably search for an optimal program.
08:57:31 <pozic> liyang: hand-writing assembly probably doesn't work optimally.
08:57:46 <pozic> (except for the smallest of problems)
08:57:47 <gwern> I don't think it's quite that hard; look at how much asm media programs like ffmpeg use
08:57:59 <gwern> they aren't generating the asm using peephole optimizers or GAs or anything
08:58:01 <maltem> bjorkintosh, isn't that just the Debian guys splitting everything in small sub-packages?
08:58:06 * pookleblinky uses Arch and Gentoo. He no longer knows what it means to install something without constantly being annoyed at compile times
08:58:25 <bjorkintosh> i s'pose it is. but it's utterly ridiculous.
08:58:30 <ezyang> Dynamically lkinked libraries are great from a package manager's perspective
08:58:45 <pozic> gwern: are you sure about that? I know there is a GNU superoptimizer, and I am sure it has some users.
08:58:51 <ezyang> It means you don't have to repush the N packages that depend on some library when it gets security fixed
08:59:21 <pozic> ezyang: a good maintainer could automate that of course.
08:59:44 <gwern> pozic: I've not heard of it. I certainly don't see any homepage for it
08:59:49 <gwern> bad sign that
08:59:55 <ezyang> pozic: I mean, recompiling all of them is still obnoxious
09:00:20 <ezyang> We do builds for a kernel module in a project I work on. Doing the build is an hour-long affair, at least
09:00:23 <revertTS> bjorkintosh: the platform is already supported in Debian http://wiki.debian.org/Haskell/Platform
09:00:45 <quicksilver> gwern: isn't ffmpeg the one whose asm is generated by a chunk of ocaml?
09:01:01 <gwern> quicksilver: thought that was fast fourier transform something
09:01:13 <quicksilver> ah, perhaps you're right.
09:01:20 <pozic> gwern: http://en.wikipedia.org/wiki/Superoptimization
09:01:23 <liyang> fftw
09:01:46 <quicksilver> all these ffprograms look the same to me
09:02:56 <gwern> racist
09:03:07 <mreh> @quote butter
09:03:07 <lambdabot> No quotes match. Do you think like you type?
09:03:09 <mreh> :(
09:03:22 <liyang> http://www.fftw.org/faq/section2.html#languages
09:03:27 <mreh> > printf "%.2f" 0.00001
09:03:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:03:28 <lambdabot>    `Text.Printf.PrintfType ...
09:03:41 <mreh> > printf "%.2f" (0.00001 :: Float)
09:03:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:03:42 <lambdabot>    `GHC.Show.Show a'
09:03:42 <lambdabot>      a...
09:04:10 <mreh> what the
09:04:25 <liyang> printf â¦ :: IO () or printf â¦ :: String
09:04:54 <jmcarthur> :t printf
09:04:55 <lambdabot> forall r. (PrintfType r) => String -> r
09:05:03 <jmcarthur> @instance PrintfType
09:05:03 <lambdabot> Maybe you meant: instances instances-importing
09:05:11 <jmcarthur> @instances PrintfType
09:05:11 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
09:05:13 <liyang> > printf "%.2f" 0.00001 :: String
09:05:14 <lambdabot>   "0.00"
09:05:19 <mreh> oh yeah
09:05:22 <liyang> > printf "%.2f" 0.00001 :: IO ()
09:05:23 <lambdabot>   <IO ()>
09:05:24 <mreh> it's either String or IO ()
09:05:31 <mreh> hahaha
09:06:03 <mreh> so.. how can I format a float so it prints so many significant figures
09:06:24 <jmcarthur> @instances-importing Text.Printf PrintfType
09:06:25 <lambdabot> (a -> r), IO a, [c]
09:06:25 <mreh> > print f "%2f" 10.1 :: String
09:06:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
09:06:26 <lambdabot>                             ...
09:06:32 <mreh> > printf "%2f" 10.1 :: String
09:06:33 <lambdabot>   "10.1"
09:06:43 <jmcarthur> oh cool, (a -> r) instance
09:09:57 <pastorn> jmcarthur: haskel printf is the worst hack...
09:10:05 <pastorn> it's sick :)
09:10:15 <jmcarthur> agreed
09:13:47 <mreh> > printf "%2g" 10.1 :: String
09:13:48 <lambdabot>   "10.1"
09:13:58 <mreh> > printf "%2" 10.1 :: String
09:13:59 <lambdabot>   "* Exception: Printf.printf: formatting string ended prematurely
09:14:14 <mreh> > printf "%2e" 10.1 :: String
09:14:15 <lambdabot>   "1.01e1"
09:14:22 <mreh> > printf "%2e" 10.12 :: String
09:14:23 <lambdabot>   "1.012e1"
09:14:28 <mreh> damnit!
09:14:44 <mreh> > printf "%.1e" 10.12 :: String
09:14:45 <lambdabot>   "1.0e1"
09:14:46 <bjorkintosh> revertTS, is it installable using apt-get ?
09:14:53 <mreh> > printf "%.1e" 100.12 :: String
09:14:53 <lambdabot>   "1.0e2"
09:14:58 <mreh> > printf "%.2e" 100.12 :: String
09:14:59 <lambdabot>   "1.00e2"
09:15:04 <pookleblinky> I wonder. I bet printf syntax is immortal.
09:15:25 <pastorn> > printf "lol" 199 :: String
09:15:26 <lambdabot>   "lol* Exception: Printf.printf: formatting string ended prematurely
09:15:38 <mreh> incorrect
09:16:06 <mreh> > printf "l%dl" (0 :: Int)
09:16:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:16:08 <lambdabot>    `GHC.Show.Show a'
09:16:08 <lambdabot>      a...
09:16:32 <int-e> > printf "l%dl" (0 :: Int) :: String
09:16:33 <lambdabot>   "l0l"
09:16:45 <mreh> genius
09:17:41 <revertTS> bjorkintosh: there's no single haskell-platform metapackage, but you can pull the individual ones in with apt
09:17:45 <mux> Data.Foldable is cool, but in the end many of the functions you get from the type-class are useless if your data structure is search-oriented
09:18:05 <mux> ie lookup, elem, notElem ...
09:18:19 <bjorkintosh> revertTS, that sounds like a pure PITA!
09:18:22 <pastorn> mux: how does Foldable work? I've never looked at it...
09:18:47 <pastorn> mux: could you use Foldable to define sum :: [Int] -> Int?
09:18:56 <mux> :t Data.Foldable.sum
09:18:57 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t, Num a) => t a -> a
09:19:01 <mux> yes you can ;-)
09:19:04 <bjorkintosh> especially when the Platform is supposed to reduce the headache of finding individual packages.
09:19:15 <pastorn> oh, so a typeclass for all foldable structures?
09:19:30 <bjorkintosh> is it intricately hard or something to create a haskell metapackage?
09:19:39 <revertTS> bjorkintosh: it's not much of a headache when all of the packages you need are listed on the wiki; certainly not more than compiling it
09:19:40 <mux> pastorn: you only need to implement foldMap to define a Foldable instance, and foldMap basically applies a function to transform any element in a monoid, and returns the resulting monoid
09:19:45 <pastorn> mux: does Foldable require Functor?
09:19:53 <mux> pastorn: no, that would be bad
09:20:03 <pastorn> howcome?
09:20:11 <mux> the data structure I'm dealing with at the moment isn't a functor, but there clearly is a sane Foldable instance
09:20:23 <pastorn> hehe
09:20:25 <bjorkintosh> yeah but a simple apt-get haskell-Platform would be really nice.
09:20:33 <bjorkintosh> and significantly easier.
09:20:44 <pastorn> bjorkintosh: just download the GHC binary blob :)
09:20:49 <mux> think, for instance, of an AVL tree: fmap'ing an AVL tree means recreating it from scratch more or less
09:20:51 <bjorkintosh> i have.
09:20:55 <mux> since the structure depends on the elements
09:21:05 <bjorkintosh> infact, i've gone through the trouble of installing all that i need to.
09:21:06 <pastorn> mux: right.
09:21:18 <bjorkintosh> but i HATED it. and it's not the good kind of pain.
09:21:24 <pastorn> mux: but who needs AVL trees?!
09:21:28 <mux> unless of course the function f you apply preserves the ordering
09:21:29 <pastorn> they're annoying
09:21:34 <mux> that was only an example :-)
09:21:35 <jmcarthur> the minimal complete definition for Foldable is either foldMap or foldr, but in my opinion the essence of Foldable is really communicated with toList
09:21:59 <mux> toList is the only useful function I can get from Foldable for this tree
09:22:17 <mux> well, and basic folds too (foldl, foldr and friends)
09:23:03 <revertTS> bjorkintosh: sometimes the packages in the repo are newer versions than specified by the platform; there was some talk of keeping multiple versions so we could have a platform metapackage, but I'm not sure where it led
09:23:04 <byorgey> jmcarthur: of course it is, that's because list is the free monoid =)
09:24:01 <byorgey> you can implement foldMap or foldr in terms of toList and vice versa
09:24:10 <mreh> > printf "%2.0f" 10.1 :: String
09:24:11 <lambdabot>   "10"
09:24:14 <mreh> aah
09:24:20 <mreh> > printf "%2.0f" 100.1 :: String
09:24:21 <lambdabot>   "100"
09:24:23 <mux> yeah, I guess foldMap f = mconcat . map f . toList
09:24:25 <mreh> hm
09:24:28 <mux> or something
09:25:12 <zygoloid_> foldr f a = foldr f a . toList
09:25:41 <byorgey> yep, and toList = foldr (:) []
09:27:42 * byorgey hands out lambdaberry smoothies in honor of Northern Hemispherical spring
09:27:50 <jmcarthur> byorgey: exactly :)
09:29:23 <mux> :t \f -> mconcat . map f . Data.Foldable.toList
09:29:24 <lambdabot> forall a a1 (t :: * -> *). (Monoid a, Data.Foldable.Foldable t) => (a1 -> a) -> t a1 -> a
09:29:35 <mux> :t foldMap
09:29:36 <lambdabot> Not in scope: `foldMap'
09:29:41 <mux> :t Data.Foldable.foldMap
09:29:42 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
09:29:57 <mux> yay, my hypothesis was correct
09:30:42 <jmcarthur> conal: see the good news about ghc head in the mailing list?
09:31:12 <mux> I suppose Data.Foldable.sum is written as getSum . foldMap Sum
09:31:19 <mux> I think foldMap is cute
09:31:21 <conal> jmcarthur: not yet.  looking now.
09:31:23 <byorgey> mux: yes, probably
09:31:39 <byorgey> mux: I agree =)
09:31:49 <byorgey> jmcarthur: what good news is this?
09:32:40 * hackagebot yesod 0.0.0.1 - A library for creating RESTful web applications.  http://hackage.haskell.org/package/yesod-0.0.0.1 (MichaelSnoyman)
09:33:44 <jmcarthur> byorgey: it's probably old news, actually, but in HEAD there is a flag to expose all unfoldings of functions in a module in the .hi file, and HEAD also treats inlining differently with the result that scattering INLINES around, when it doesn't help, still won't hurt so much
09:33:56 <conal> jmcarthur: sweet!
09:34:43 <jmcarthur> conal: it's not perfect, but it's better than the situation with 6.10.1
09:34:49 <jmcarthur> err, 6.12.1
09:35:19 <conal> jmcarthur: i may have missed the "not perfect" part.  what did you spot?
09:35:38 <mux> bon
09:36:09 <jmcarthur> conal: just that GHC's inliner still relies on heuristics that i'm not sure how much to trust
09:36:29 <jmcarthur> conal: like, i can't be *sure* something will inline without INLINE, and of course even then i can't be sure
09:36:35 <conal> jmcarthur: ah, yes.  seems to be terribly subtle/fragile business.
09:36:41 <mreh> i get frightened when these guys start talking...
09:36:46 <mreh> what do all these things mean?
09:36:58 <mux> don't try, last time I ended up in the E.R.
09:37:07 <jmcarthur> but always inlining perfectly is an unreasonable expectation i think so this is good
09:37:18 <mreh> Erlang.Room.
09:37:32 <jmcarthur> mreh: who, conal and me?
09:37:40 <mreh> jmcarthur: yes
09:37:46 <maltem> mreh, frightened due to the abundance of word like "subtle", "cannot trust", "fragile", "hurt"?
09:37:53 <conal> jmcarthur: "The reasonable man adapts himself to the world; the unreasonable one persists in trying to adapt the world to himself. Therefore all progress depends on the unreasonable man." - George Bernard Shaw
09:37:58 <mux> mreh: that being said, I've seen conal & jmcarthur talk about much more complicated things
09:38:22 <Fare> conal: same man who advocated gas chambers for the socially unfit and anyone with a capitalist mind?
09:38:35 <mreh> haha
09:38:42 <bjorkintosh> mreh, they're nerds. it doesn't matter :)
09:38:49 <conal> Fare: hi!  i didn't realize you hang out here. :)
09:38:57 <Fare> once in a while, only
09:39:07 <mreh> he and Oscar Wilde used to carry on didn't they!
09:39:14 <mreh> those jokers
09:39:15 <jmcarthur> do big words imply complicated topics?
09:39:27 <bjorkintosh> there's no such thing as a 'big' word.
09:39:30 <bjorkintosh> infrequently used, sure.
09:39:35 <bjorkintosh> but certainly not 'big'.
09:39:40 <mreh> uh oh, the nerds are on to us!
09:39:45 <Fare> At least Oscar didn't argue for mass murder or for putting in prison people judged as marginal by the majority of society, much less gassing them.
09:39:58 <jmcarthur> mreh, mux: at least our complicated conversations are usually about reducing complexity ;)
09:40:13 <bjorkintosh> blackboxing.
09:40:32 <mreh> heh
09:40:34 * lispy 's offtopic sense is tingling...perhaps #haskell-blah is a better place to discuss it :)
09:40:41 <mreh> heh@jmcarthur
09:40:51 <bjorkintosh> lispy in haskell. now THAT's ot.
09:41:06 <mreh> we've reached critical mass
09:41:23 <lispy> bjorkintosh: The nick haskelly was taken? ;)
09:42:21 <maltem> @seen haskelly
09:42:21 <lambdabot> Unknown command, try @list
09:42:23 <bjorkintosh> hah!
09:42:34 <maltem> :(
09:42:42 * hackagebot convertible-text 0.2.0.5 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.2.0.5 (MichaelSnoyman)
09:42:49 <lispy> I think the offtopic thing I notice is actually over.  Sorry for the noise
09:43:28 <mreh> don't even use the words "off-topic" in here
09:43:49 <lispy> > words "off-topic"
09:43:50 <lambdabot>   ["off-topic"]
09:43:53 <mreh> people will start dissecting until the cows come home
09:44:09 <mreh> Q.E.D.
09:44:26 <lispy> mreh: Usually, I just ask off-topic discussions to move to the off-topic channel. :)
09:44:33 <lispy> most people oblige
09:44:55 <mreh> most people can't be bothered :)
09:45:25 <lispy> does Alistair Bayley hang out here?
09:45:31 <bjorkintosh> so how's about haskell with lisp's syntax, lispy ?
09:45:43 <bjorkintosh> wouldn't that just be awesome!
09:45:53 <aavogt> @where liskell
09:45:53 <lambdabot> http://clemens.endorphin.org/liskell
09:45:55 <lispy> bjorkintosh: liskell?  I think it's a dead project but it made it reallyfar
09:45:58 <mreh> no-one is stopping you surely
09:46:00 <harlekin> @pl (\a b -> foo a b)
09:46:01 <lambdabot> foo
09:46:01 <Fare> What about instead a Lisp with Haskell semantics?
09:46:13 <harlekin> @pl (\a b -> bar $ foo a b)
09:46:14 <lambdabot> (bar .) . foo
09:46:17 <bjorkintosh> Fare, scheme? :)
09:46:24 <bjorkintosh> it's closer than any other lisp.
09:46:27 <ezyang> Does Haskell's arrows have anything to do with Category Theory arrows?
09:46:30 <ezyang> *Do
09:46:35 <bjorkintosh> ezyang, yeah.
09:46:39 <bjorkintosh> unfortunately.
09:46:56 <bjorkintosh> it's very math-y, and won't let you prettify your myspace.
09:47:07 <lispy> heh
09:47:14 <pookleblinky> There is Liskell.
09:47:15 <ezyang> Bleh, one of the nice things about Haskell is the dabbling in mathspace
09:47:30 <bjorkintosh> why?
09:47:31 <pookleblinky> But it is, sadly, named Liskell.
09:47:36 <lispy> But, Haskell can be used to prettify your facebook (they use Haskell programs to apply refactorings to their php)
09:47:45 <ezyang> bjorkintosh: You need to get abstractions from somewhere
09:47:55 <ezyang> And mathematicians generate the "purest" abstractions
09:48:01 <bjorkintosh> ezyang, poetry too.
09:48:21 <ezyang> ^^
09:48:27 <bjorkintosh> don't ask me how. i'm not a poet.
09:48:38 <ezyang> Things that are not the same: poet, poset
09:48:50 <ezyang> :-D
09:48:57 <lispy> nice
09:49:21 <Vq> lispy: Haskell can make PHP pretty?
09:49:30 <ezyang> Vq: Yup!
09:49:37 <lispy> ezyang: It's like the Dr. Seus guide to Academia :)
09:49:41 <Vq> @faq Can Haskell make PHP pretty?
09:49:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:49:42 <Fare> PHaskellP
09:49:46 <Vq> wow
09:49:48 <lispy> Vq: I made no such claims :)
09:50:05 <ezyang> I've commented that the preponderance of Haskell programs to manipulate PHP is what happens when you throw really smart engineers at a big PHP codebase
09:50:06 <harlekin> @pl (\f -> not . f)
09:50:06 <lambdabot> (not .)
09:50:26 <Vq> lispy: maybe not, but lambdabot confirmed it :P
09:50:28 <ezyang> lispy: Oooh; I should do "Dr. Seuss: The Category Theory"
09:50:37 <djahandarie> I do PHP at my day job
09:50:42 <Fare> @unpl (not .)
09:50:42 <pookleblinky> ezyang, or, it's a way to let the smart guys work without going insane.
09:50:42 <lambdabot> (\ a d -> not (a d))
09:50:49 <lispy> ezyang: The Cat in The Theory
09:50:53 <djahandarie> It's really annoying that you can't do even simple stuff like partial application
09:50:57 <djahandarie> Which would be so damn useful
09:51:08 <pookleblinky> There is something to be said for putting your smartest devs into coding in-house tools.
09:51:34 <djahandarie> There should be a PHP backend for GHC
09:51:34 <ezyang> pookleblinky: Same difference :-)
09:51:37 <djahandarie> LOL
09:51:50 * djahandarie writes a thesis about it
09:52:16 <tensorpudding> squeezing GHC into PHP? that'd be a tight fit
09:52:53 <ezyang> The problem with mathematicians is they love talking about stuff that isn't computable
09:53:10 <djahandarie> Everything is computable!
09:53:25 <lispy> ezyang: Alternatively, computer scientists are obsessed with constructionist arguments :)
09:53:28 <ezyang> djahandarie: Oh soooo not ture :^)
09:53:33 <djahandarie> As long as you have an oracle
09:53:33 <ezyang> *true
09:53:36 <ezyang> lispy: Hee!
09:54:45 <ezyang> And I assume all of the real Haskell mathematicians have already put the interesting category stuff into category-extras
09:55:27 <gwern> haskell targetting php makes about as much sense as Wasabi
09:55:37 <ezyang> mmmmm wasabi
09:55:38 <gwern> what's the point of targetting a lower-level slower language?
09:55:43 <lispy> Does anyone work on cat-extras besides edward k?
09:56:01 <gwern> I downloaded it once!
09:56:06 <djahandarie> gwern, to make my job easier
09:56:09 <djahandarie> Do my work for me!
09:56:22 <djahandarie> I currently think in Haskell and then compile everything down to PHP in my head
09:56:45 <gwern> as paul graham says, you have to either work in a high level language or become a human compiler for one
09:57:24 <djahandarie> Haha, never heard that quote before
09:57:49 <Saizan> mh, an haskell to php compiler.
09:57:51 <Fare> unless you're reading aloud, you still haven't.
09:58:28 <Fare> Saizan, sounds painful. What about an INTERCAL to brainfuck compiler instead, written in whitespace?
09:58:55 <gwern> brainfuck is easy. malbolge is hard
09:59:00 <Saizan> oh, can't LLVM generate PHP?
09:59:46 <Fare> "first, write a SKI to bf/malbolge compiler in Haskell..."
09:59:47 <djahandarie> No but Zend bytecode can be compiled to LLVM assembly
10:00:07 <pookleblinky> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
10:00:14 <harlekin> @pl (\xs -> id *** ((xs++) .))
10:00:15 <lambdabot> (id ***) . (.) . (++)
10:00:26 <djahandarie> I have stopped trusting @pl entirely
10:00:46 <djahandarie> @pl 1.5 + 2
10:00:46 <lambdabot> 1 . 5 + 2
10:00:49 <Saizan> it's mostly the parser that's poor
10:00:58 <djahandarie> @pl a.b + 3
10:00:58 <lambdabot> a . b + 3
10:01:28 <Saizan> someone could send a patch to convert it to haskell-src-exts
10:01:42 <djahandarie> Hmmm, that'd actually work nicely
10:02:01 <gwern> Saizan: someone could do a lot of things with lambdabot
10:02:25 <Saizan> sure :)
10:02:32 <aavogt> @pl \x -> x + 1.5
10:02:32 <lambdabot> (1 . 5 +)
10:04:45 <medfly> heh
10:04:50 <medfly> @unpl (+5)
10:04:50 <lambdabot> (\ a -> a + 5)
10:09:40 <medfly> > 1 . 5
10:09:41 <lambdabot>   No instance for (GHC.Show.Show (f b))
10:09:41 <lambdabot>    arising from a use of `M4750421896...
10:11:28 <bremner_> forgive a poor c programmer, but what is the best way to get the character '1' from the number 1?
10:11:49 <shapr> show
10:11:52 <sepp2k> head $ show num
10:12:03 <sepp2k> head $ show 1
10:12:06 <bremner_> ugh. really?
10:12:11 <ezyang> sepp2k: head?
10:12:16 <ezyang> > show 1
10:12:17 <lambdabot>   "1"
10:12:20 <bremner_> yeah head
10:12:22 <ezyang> oh, character :-)
10:12:24 <shapr> oh right
10:12:24 <ben> > toEnum (1 + fromEnum '0')
10:12:25 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
10:12:29 <ben> aw
10:12:35 <ben> > toEnum (1 + fromEnum '0') :: Char
10:12:36 <lambdabot>   '1'
10:12:43 <ben> I believe this is the C way
10:12:54 <ezyang> WAYRTTD
10:13:12 <bremner_> convert a list 1,3,5 into "135"
10:13:31 <bremner_> I could use show and ++ I guess
10:13:49 <bremner_> and foldl/foldr to be fancy
10:13:56 <ben> > let list = [1, 3, 5] in concatMap show list
10:13:57 <lambdabot>   "135"
10:14:19 <bremner_> works for me.
10:14:23 <ezyang> has the added benefit of working for 23,24,26 too
10:14:33 <ben> > let list = [1..] in conmap (const "%d")
10:14:34 <lambdabot>   Not in scope: `conmap'
10:14:38 <ben> err, whoops
10:15:15 <ben> > let list = [1..] in concatMap (printf "%d") list
10:15:16 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:15:16 <lambdabot>    `Text.Printf.IsChar b'
10:15:16 <lambdabot>  ...
10:16:16 <lispy> > let list = ([1 ..] :: [Int]) in concatMap (printf "%d") list
10:16:19 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:16:23 <lambdabot>    `GHC.Show.Show b'
10:16:27 <lambdabot>      a...
10:16:30 <lispy> hmm
10:17:28 <lispy> I guess it doesn't know the type of printf
10:17:34 <lispy> :t Text.printf
10:17:39 <lambdabot> Couldn't find qualified module.
10:17:45 <lispy> ?hoogle printf
10:17:47 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
10:17:49 <lambdabot> module Text.Printf
10:17:51 <lambdabot> Text.Printf class PrintfArg a
10:18:13 <companion_cube> let list = ([1 ..] :: [Int]) in concatMap (printf "%d" :: Int -> String) list
10:18:22 <companion_cube> > let list = ([1 ..] :: [Int]) in concatMap (printf "%d" :: Int -> String) list
10:18:23 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
10:19:22 <bremner_> why is printf better than show?
10:19:28 <ben> bremner_: It is not
10:19:36 <medfly> :t show
10:19:37 <lambdabot> forall a. (Show a) => a -> String
10:19:54 <ben> bremner_: I just considered turning [1, 2, 3] into printf "%d%d%d" 1 2 3 but I could not think of how to generalise that
10:20:01 <pikhq> printf just allows you to use a format string.
10:20:10 <Kagami`> :t printf
10:20:11 <lambdabot> forall r. (PrintfType r) => String -> r
10:21:15 <pikhq> Kagami`: printf is minorly brilliant. The PrintfType typeclass has instances for various functions to a PrintfType, and an instance for a String.
10:21:24 <pikhq> In this way, printf is variadic.
10:21:36 <ben> > let f s [] = printf s ; f s (x:xs) = f s xs x in f "%d%d%d" [1, 2, 3]
10:21:36 <lambdabot>   Occurs check: cannot construct the infinite type: r = t -> r
10:21:39 <ben> aw
10:22:15 <pikhq> ben: You need to specify the type signature to force a specific type for printf.
10:22:25 <ben> I assumed the problem was elsewhere
10:22:46 <pikhq> No, that's a problem with printf. It can't be type inferred well.
10:22:50 <Kagami`> pikhq: but it's not safe. template haskell's printf is better
10:23:10 <int-e> ben: you're right - a type signature will not help with your code
10:23:11 <pikhq> Kagami`: Sure it's safe. Well. It's typesafe.
10:23:41 <pikhq> Though it's also deeply subtle, whereas the Template Haskell printf is fairly straightforward.
10:24:31 <aavogt> template haskell is clear?
10:24:47 <Saizan> the TH one is safer because the format string gets checked at compile time
10:24:52 <pikhq> aavogt: Compared to printf, yes.
10:25:04 <Saizan> > printf "%d" "foo" :: String
10:25:05 <lambdabot>   "* Exception: Printf.printf: bad argument
10:25:30 <pikhq> Oh, right. printf inherently must do some runtime type checking.
10:26:09 <pikhq> Because type-safe != statically type-safe.
10:26:26 <ben> Surely we can come up with some relatively straightforward type-safe EDSL
10:26:36 <aavogt> @hackage xformat
10:26:36 <lambdabot> http://hackage.haskell.org/package/xformat
10:26:48 <Saizan> there's no thing as non-static types, heretic!
10:27:01 <Saizan> ben: it's been done multiple times
10:27:09 <pikhq> *cough* Dynamic *cough*
10:27:31 <int-e> I-know-what-I'm-doing-unsafeCoerce# ;)
10:27:43 <int-e> (Dynamic is just too tame.)
10:27:52 <Kagami`> pikhq: but there are no profit from type-safe printf if we can mix up format string accidentally
10:28:00 <tommd> Can the "Chart" package do eps?  I see ps listed but not eps.  Perhaps my postscript-fu is lacking and there is no difference?
10:28:10 <pikhq> Kagami`: Eh.
10:28:19 <pikhq> Clearly, we should make Haskell dependently typed.
10:28:22 <pikhq> >:D
10:28:28 <ben> What does that mean?
10:28:35 <Saizan> oh, Dynamic and friends exist, it just happens to be an open tagged union :P
10:28:51 <Saizan> i.e. you can do tag checking at runtime
10:28:56 <pikhq> ben: Dependent types allow for things like the type of printf being dependent on its first argument.
10:28:59 * ManateeLazyCat ghc eat 1.7GB memory to compile qtHaskell, crazy.... :)
10:29:14 * ManateeLazyCat And don't including VirtualMemory
10:29:53 <aavogt> pikhq: but what if you read in the format string at runtime?
10:29:53 <pikhq> Though I highly doubt that this is relevant, that figure *could* include the paged in portions of an mmapped file.
10:30:13 <pikhq> aavogt: Then you're still getting runtime type checking.
10:30:29 <pikhq> There's not much that can be done about it.
10:31:10 <aavogt> yeah, in that case you can't
10:31:46 <pikhq> Aside from banning I/O.
10:32:00 <stevenmarky> iostreams << > printf
10:32:17 <pikhq> stevenmarky: ... You're mad, right?
10:32:26 <ben> iostreams are extendable, I like them
10:32:30 <stevenmarky> maybe :p
10:32:37 <pikhq> ben: They are also horribly flawed.
10:32:53 <Saizan> fooo x y = "blah" ++ show x ++ "blah blah" ++ y
10:32:56 <pikhq> (... It's mostly the mode-setting thing that's flawed. Though the syntax for them also sucks horribly.)
10:32:59 <lispy> ManateeLazyCat: Was it gnu ld that used the memory or GHC?
10:33:29 <ben> pikhq: Eh, it is still simpler for dumping objects of custom types into strings than C
10:33:50 <pikhq> ben: True.
10:34:03 <pikhq> Extending printf is a pain, and non-portable.
10:34:11 <ManateeLazyCat> lispy: qtHaskell have 640 module need compile, maybe GHC just release memory after compile finish.
10:34:33 <ben> Maybe the mode-setting syntax should have been something like setw(cout, 20) << pi;
10:35:09 <lispy> ManateeLazyCat: oh, I think there is actually a bug about that
10:35:13 <zygoloid> are there any common examples of Foldable Functors which are not Traversable?
10:35:28 <pikhq> ben: The mode-setting syntax shouldn't actually set modes.
10:35:42 <zygoloid> i guess Data.Set isn't really Traversable is it?
10:35:46 <pikhq> Because, among other things, there's no freaking way to *reset* modes.
10:35:47 <lispy> zygoloid: Hmm...Would State qualify?
10:35:51 <ManateeLazyCat> lispy: I don't understand.
10:36:01 <ben> pikhq: In my example, it would return a temporary iostream-with-modified-modes object that would apply the modes to whatever is streamed into it, but not mutate the underlying iostream
10:36:15 <pikhq> ben: That would be entirely acceptable.
10:36:16 <gwern> zygoloid: why not? turn it into a list, traverse, and then back into a set
10:36:28 <lispy> ManateeLazyCat: I think I did see a bug report recently about GHC using too much memory sometimes when compiling many modules
10:36:36 <Saizan> zygoloid: Data.Set is not even Foldable
10:36:37 <ben> For what it is worth, boost's raii mode setting gimmicks make it relatively painless, too, if not really elegant
10:36:46 <zygoloid> gwern: sequence :: Set [a] -> [Set a] can't work without Ord a i think
10:36:47 <ManateeLazyCat> lispy: Infact, i terminated ghc after it compile apart, because it will kill my box if it compile all 640 modules.
10:36:51 <Saizan> zygoloid: ah, sorry, it is Foldable
10:37:05 <zygoloid> Saizan: right, it has a toList, it should be Foldable!
10:37:14 * gwern said that already ---
10:37:26 <Saizan> zygoloid: i was thinking it needed Ord a even for that
10:37:35 <Saizan> gwern: toList is not enough for Traversable
10:37:44 <gwern> :i Traversable
10:37:48 <Saizan> gwern: you need fromList too, which requires Ord
10:37:59 <Saizan> "or some equivalent"
10:38:02 <gwern> Saizan: well, Set has both, no?
10:38:09 <ManateeLazyCat> lispy: GHC will eat 1.7GB after compile 50 modules.... :)
10:38:15 <gwern> hence the old nub = toList . fromList folklore
10:38:16 <aavogt> @type Data.Set.fromList
10:38:17 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
10:38:18 <zygoloid> you don't need a fromList do you?
10:38:38 <Saizan> gwern: Traversable doesn't let you add the Ord constraint
10:38:47 <Kagami`> ManateeLazyCat: use gtk2hs :)
10:38:48 <gwern> zygoloid: well, if you traverse a set and get a list rather than a set, something is missing :)
10:38:48 <profmakx> 7
10:39:00 <ManateeLazyCat> Kagami`: Yep, i use gtk2hs.
10:39:09 <zygoloid> gwern: right, fromList should be sufficient but not necessary
10:39:10 <ManateeLazyCat> Kagami`: Just interested Qt
10:39:13 <Saizan> ?type traverse
10:39:14 <lambdabot> Not in scope: `traverse'
10:39:23 <Saizan> ?type Data.Traversable.traverse
10:39:24 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:39:30 <ManateeLazyCat> Kagami`: I found qt have some many feature that Gtk+ haven't.
10:39:36 <zygoloid> "(,) a" is Traversable iiuc and it has no fromList
10:39:49 <gwern> Saizan: why would Set's fromList need Ord? shouldn't it only need an Eq? 'is element in Set or not?'
10:39:59 <Saizan> ?type Data.Set.fromList
10:40:00 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
10:40:07 <gwern> modulo implementation issues of trees
10:40:09 <Saizan> gwern: even Eq would have the same problem.
10:40:29 <Saizan> gwern: you can't assume any constraint on b
10:40:35 <zygoloid> gwern: with Eq it provably couldn't achieve it's asymptotic runtime guarantees
10:40:43 <gwern> zygoloid: implementation issues
10:40:47 <ManateeLazyCat> Kagami`: Infact, i don't want try Qt/QtHaskell before some gtk2hs problem crazy me, and lucky, i know how to fix that problem now. :)
10:41:11 <Kagami`> ManateeLazyCat: what problem?
10:41:22 <gwern> :t fmap
10:41:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:41:26 <ManateeLazyCat> Kagami`: Are you read gtk2hs-develop list?
10:41:34 <Kagami`> ManateeLazyCat: no
10:41:48 * gwern wonders what the difference between FUnctor & Traversable is
10:41:48 <Saizan> Set is not a Functor either, in fact
10:41:56 <ManateeLazyCat> Kagami`: If you use GtkSocket/GtkPlug in separate processes for multi-process framework, you need carefully.
10:42:13 <djahandarie> Is there a way to use tagsoup with lambdabot's > ?
10:42:14 <ManateeLazyCat> Kagami`: Otherwise, you will got two processes racing.
10:42:17 <Saizan> gwern: the Applicative f => ..
10:42:18 <zygoloid> gwern: Traversable means you can, well, traverse the 'a's in f a
10:42:34 <ManateeLazyCat> Kagami`: Then you will got `BadWindow` or `BadIDChoice` X error.
10:42:39 <gwern> djahandarie: no. why would you think that?
10:42:40 <zygoloid> that is, visit and transform them in some specified order
10:42:47 <Kagami`> ManateeLazyCat: oh, ok.
10:42:48 <Saizan> (a -> f b) -> t a -> f (t b) vs. (a -> b) -> f a -> f b
10:42:59 <djahandarie> gwern, was just wondering
10:43:21 <ManateeLazyCat> Kagami`: Crazy is this error is not always *reduce*, because those two processes create a *race-condition*.
10:43:39 <zygoloid> fmap is kinda the same as traversable except that it doesn't give you a visiting order
10:44:31 <ManateeLazyCat> Kagami`: You can see `demo/embbed/Embbedd.hs` of darcs gtk2hs, i write a simple demo that how to use GtkSocket/GtkPlug.
10:45:05 <Kagami`> ManateeLazyCat: ok, thanks.
10:45:36 <ManateeLazyCat> Kagami`: That demo have problem, but now works fine with initGUI
10:46:01 <zygoloid> hmm. if sequence is weaker than sequenceA, why is it not in a separate typeclass between Foldable and Traversable
10:46:06 <ManateeLazyCat> Kagami`: If you use unsafeInitGUIThreadRTS in it with `-threaded` flag, that demo will failed.
10:46:12 <gwern> zygoloid: too many type classes as it is!
10:46:51 <ManateeLazyCat> Kagami`: GtkSocket/GtkPlug will help you build multi-processes framework like chromium model.
10:47:16 <ManateeLazyCat> Kagami`: Infact, looks Chromium source code, it use same principle.
10:47:28 <ben> ew
10:47:50 <ManateeLazyCat> In linux platform, Chromium use GtkSocket/GtkPlug implement multi-processes model.
10:48:38 <Kagami`> ManateeLazyCat: yep, i heard about chromium model. multithread is pretty complicated thing to work this
10:48:44 <ManateeLazyCat> Kagami`: If you interested how to fix GtkSocket/GtkPlug problem with X error, see gtk2hs-devel list.
10:49:02 <ManateeLazyCat> Kagami`: Infact, not complicated, simple enough,
10:49:09 <zygoloid> it would be nice if you could export 'hiding' instructions: Data.Traversable where (foldr hiding Prelude.foldr, ...)
10:49:11 <ManateeLazyCat> Kagami`: Just you need carefully sometimes.
10:49:17 <Saizan> zygoloid: fmap is the same as traverse with the Identity Applicative, i'd say
10:49:22 <Ke> well chromium is a bit more complex, since it has even seccomc sandboxing
10:49:38 <ben> zygoloid: Caleskell where ((.) hiding Prelude..)
10:49:56 <zygoloid> Saizan: indeed. i think that's what Data.Traversable.fmapDefault is.
10:50:09 <ManateeLazyCat> Ke If use Haskell with WebKit implement same feature browser like chromium, and not C++, i think code will clearer. :)
10:50:13 <Ke> seccomp is kind of sad, while it doesn't allow brk or anonymous mmap for malloc
10:50:39 <zygoloid> has anyone tried to write an HTML5 renderer in haskell yet?
10:50:39 <Ke> ManateeLazyCat: but it will never be as safe imo
10:50:47 * ManateeLazyCat pasted "Result" at http://paste2.org/get/710734
10:50:57 <ManateeLazyCat> Kagami`: If you too lazy, see above.
10:51:15 <ManateeLazyCat> Ke: Why?
10:51:22 <Ke> ManateeLazyCat: no sandboxing
10:51:27 <zygoloid> Ke: if you don't have brk or anon mmap, how do you allocate? mmaping real files?
10:51:30 <gwern> zygoloid: let me rewrite that: 'has anyone tried to invest man-centuries of engineering effort into writing a HTML5 renderer?'
10:51:37 <ManateeLazyCat> Ke: We can build it.
10:51:44 <ManateeLazyCat> Ke: If we want.
10:51:48 <zygoloid> gwern: it might be a good test for the HTML5 spec ;-)
10:51:49 <Ke> ManateeLazyCat: that would be awesome
10:52:18 <Ke> zygoloid: chromium uses unsandboxed thread for malloc
10:52:18 <Kagami`> ManateeLazyCat: maybe. but i'm still remember how i worked with multithread web-crawler. it was on haskell's libcurl and it .. crashed with segmentation fault :)
10:52:20 <ManateeLazyCat> Kagami`: Infact, i want convert from gtk2hs to qtHaskell. Qt have so many API and rich documentation.
10:52:50 <ManateeLazyCat> Kagami`: So build *multi-processes* to protected core don't crash.
10:53:14 <ManateeLazyCat> Kagami`: Multi-Thread not safe, maybe crash.
10:53:16 <Kagami`> ManateeLazyCat: multi-process is rather slow
10:53:39 <gwern> those who trade safety for speed deserve neither
10:53:47 <ManateeLazyCat> Kagami`: Infact, in Linux, process is very light.
10:54:04 <ManateeLazyCat> Kagami`: Of course, multi-process will eat more memory than multi-thread.
10:54:18 <ManateeLazyCat> Kagami`: But for safe and stable, it's worth to do.
10:54:23 <gwern> ManateeLazyCat: one of the charactersitics of unix v windows I understand - the latter has muckle heavier processes
10:54:32 <Ke> ManateeLazyCat: anyways how would you implement seccomped haskell?
10:55:18 <zygoloid> Ke: at the RTS level i guess
10:55:21 <ManateeLazyCat> Ke: Haven't time research how to do, but i believe Haskell can implement it.
10:55:28 <Ke> was it that haskell runs all IO in separate thread?
10:55:49 <ManateeLazyCat> Ke: Now i just want perfect gtk2hs, or try to perfect qtHaskell.
10:56:00 <Ke> =o)
10:56:07 <Kagami`> ManateeLazyCat: btw, what tools for multiprocessing (and do communication beetween them) using in haskell?
10:56:18 <ManateeLazyCat> Kagami`: DBus.
10:56:20 <notabel> Ke: yes, my understanding is that all IO is handled by the IO manager, and that the thread in which an IO action executes is not observable
10:56:25 <ManateeLazyCat> Kagami`: >package dbus-core
10:56:34 <ManateeLazyCat> >package dbus-core
10:56:38 <ManateeLazyCat> :>package dbus-core
10:56:53 <ManateeLazyCat> Kagami`: Search DBus in HaskellWiki.
10:57:06 <Ke> then technically you could seccomp all other threads and audit the IO-handler
10:57:07 <ManateeLazyCat> Kagami`: I have use it, one word: *awesome*.
10:57:17 <Kagami`> ManateeLazyCat: ok, thanks
10:57:35 <ManateeLazyCat> Kagami`: Or "cabal install dbus-core dbus-client"
10:57:47 <Ke> though I include malloc in the IO here
10:58:09 <ManateeLazyCat> Kagami`: DBus-Core is implementation DBus protocol, and DBus-Client have some handy function for fast develop.
10:59:08 <ManateeLazyCat> Kagami`: Infact, i have glib-dbus patch in my harddisk, but some important functions can't support by current FFI, so i switch to use DBus-Core.
11:00:50 <ManateeLazyCat> Kagami`: GtkSocket/GtkPlug for build multi-processes framework, DBus for communication with those process, stm for handle concurrent.
11:01:40 <Kagami`> ManateeLazyCat: and how about manage running processes? System.Process?
11:02:08 <ManateeLazyCat> Kagami`: And carefully, because current X window don't allow two thread access same resource, so you need use `postGUIAsync` function to wrap all Gtk+ function to make all Gtk+ function just execute in MainProcess.
11:02:20 <ManateeLazyCat> Kagami`: DBus.
11:02:50 <Kagami`> ManateeLazyCat: no. if we want to spawn/kill processes
11:03:13 <ManateeLazyCat> Kagami`: spawn use "forkProcess (executeFile ... )"
11:03:36 <ManateeLazyCat> Kagami`: Kill is simple, just "killall process". :)
11:04:29 <ManateeLazyCat> Kagami`: You can use "forkProcess (executeFile "CurrentProgramePath")" to spawn many chlid process to running separate gtk2hs code
11:04:51 <ManateeLazyCat> Kagami`: Then use DBus communications those processes.
11:05:17 <Kagami`> ManateeLazyCat: i see
11:05:19 <ManateeLazyCat> Kagami`: Of course, you need a *RootProcesses* to control when time spawn/kill processes.
11:05:41 <ManateeLazyCat> Kagami`: Infact, i have all source code about those.
11:06:01 <ManateeLazyCat> Kagami`: Have implementation, just test all those submodule to make them works together.
11:06:50 <ManateeLazyCat> Kagami`: After i fix GtkSocket/GtkPlug multi-processes racing problem, now i try to test all those together.
11:08:34 <ManateeLazyCat> Kagami`: And another problem, in `forkProcess`, just use executeFile for spawn child process, don't add any code on it, otherwise forkProcess make you crazy. :)
11:09:15 <ManateeLazyCat> Kagami`: Now gtk2hs just missing Webkit.
11:09:49 <ezyang> I need a final project for my symbolic systems class. Any suggestions?
11:10:01 <ManateeLazyCat> Now have WebKit patch for gtk2hs, just have some part need to complete, hope Axel will finish this job quickly, i really want use Webkit in gtk2hs.
11:10:10 <ManateeLazyCat> Then i can build Webkit browser for fun. :)
11:10:23 <sinelaw> if i have a type: data Blah a b = Blah | Bleh { junk :: a -> b, jonk :: a } , how can i pattern-match on Bleh?
11:10:23 <Kagami`> ManateeLazyCat: libwebkit?
11:10:34 <ManateeLazyCat> Kagami`: Yep.
11:10:43 <Kagami`> ManateeLazyCat: cool :)
11:10:47 <ManateeLazyCat> Kagami`: A Chinese friend  develop it.
11:10:56 <ManateeLazyCat> Kagami`: But that patch not complete.
11:11:07 <ManateeLazyCat> Kagami`: So Axel haven't push it to repo.
11:11:29 <ManateeLazyCat> Kagami`: Some functions need change Webkit library first, then change gtk2hs.
11:12:05 <ManateeLazyCat> Kagami`: Just wait, Axel have working on it, and he is too busy and haven't time reply my mail. :)
11:12:18 <ben> @hoogle unsafePerformIO
11:12:18 <lambdabot> Foreign unsafePerformIO :: IO a -> a
11:12:19 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
11:12:37 <ManateeLazyCat> Kagami`: Which version of your gtk2hs?
11:12:54 <ben> @hoogle evaluate
11:12:54 <lambdabot> Control.Exception evaluate :: a -> IO a
11:12:54 <lambdabot> Control.OldException evaluate :: a -> IO a
11:12:54 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
11:12:57 <sinelaw> any hints about my question?
11:13:13 <sinelaw> @pl  alloca (\x -> alloca (\y -> return (x, y)))
11:13:13 <lambdabot> alloca (alloca . (return .) . (,))
11:14:00 <Kagami`> ManateeLazyCat: currently it not installed. i remove ~/.cabal after ghc upgrade
11:14:34 <ManateeLazyCat> Kagami`: :)
11:14:58 <sinelaw> ManateeLazyCat, you're in China?
11:15:10 <ManateeLazyCat> Kagami`: I recommand you install darcs version, Duncan have fix it to make it work with GHC 6.12.1
11:15:16 <ManateeLazyCat> sinelaw: I'm Chinese. :)
11:15:24 <sinelaw> ManateeLazyCat, yes, but are you there?
11:15:34 <ManateeLazyCat> sinelaw: Yes!
11:17:13 <ManateeLazyCat> Qt4 is awesome!
11:17:26 <edwardk> > alloca (alloca . fmap return . (,)) -- might be more legible
11:17:27 <lambdabot>   Not in scope: `alloca'Not in scope: `alloca'
11:18:07 <sinelaw> sometimes point-less is pointless
11:18:30 <Kagami`> ManateeLazyCat: but it's really problem to compile, since in haskell all modules need to be compiled ( actually, i love binary distros :) )
11:18:48 <Kagami`> all libraries*
11:18:52 <sinelaw> edwardk, but can you help me with my other question?
11:18:55 <edwardk> sinelaw: i agree. i mostly like it when i can turn something into a run of .'s like that
11:19:03 <edwardk> sinelaw: i wasn't here when you asked it. what was it?
11:19:05 <sinelaw> if i have a type: data Blah a b = Blah | Bleh { junk :: a -> b, jonk :: a } , how can i pattern-match on Bleh?
11:19:11 <sinelaw> simple syntax question i'm guessing
11:19:17 <ManateeLazyCat> Kagami`: gtk2hs? Yes, you need compile it.
11:19:23 <edwardk> foo (Bleh a b) = ...
11:19:25 <edwardk> or
11:19:34 <sinelaw> ManateeLazyCat, cool!
11:19:35 <Kagami`> ManateeLazyCat: no, qtHaskell
11:19:35 <edwardk> foo (Bleh { junk = a, jonk = b }) = ...
11:19:43 <sinelaw> edwardk, ok thanks!
11:19:58 <edwardk> the latter is useful if you only need to pattern match on a few of the arguments
11:20:04 <ManateeLazyCat> Kagami`: Yes, painful, ghc eat 1.7GB memory to compile qtHaskell.
11:20:07 <mauke> the parens are redundant
11:20:20 <edwardk> since you can foo Bleh {} if you only care that it is a Bleh
11:20:26 <ManateeLazyCat> Kagami`: And i need compile those split some part.
11:20:27 <c_wraith> ManateeLazyCat: was that ld, in particular?  It seems to be the most memory-hungry part
11:20:37 <sinelaw> edwardk, cool Bleh {} is exactly what i was looking for
11:20:54 <ManateeLazyCat> c_wraith: ld? Detail?
11:20:55 <edwardk> mauke: yeah, which drives me nuts coz it is one of the few violations of the 'juxtaposition binds tighter than most everything else' rule ;)
11:21:20 <c_wraith> ManateeLazyCat: ld is the linker on linux and osx.  It seems to be the part of the compilation process that eats huge amounts of memory
11:21:21 <ManateeLazyCat> c_wraith: I know ld, but i don't understand what you mean.
11:21:46 <ManateeLazyCat> c_wraith: You mean ld eat memory, and not GHC?
11:22:06 <c_wraith> ManateeLazyCat: that's my experience.  It may not be the case in your specific example
11:23:02 <ManateeLazyCat> c_wraith: GHC increase memory when it compile new modules, until kill my box.
11:23:30 <Fare> edwardk, hi! any news from ravi about the next BostonHaskell meeting?
11:23:30 <ManateeLazyCat> c_wraith: So what's information i can provide to you?
11:23:59 <edwardk> fare: ravi seems to have dropped off the face of the earth. copumpkin was trying to contact someone over at mit to see if they could get us a room
11:24:06 <sinelaw> edwardk, b@(Bleh {}) is ok?
11:24:13 <Fare> I hope he's doing well.
11:24:14 <edwardk> sinelaw yeah
11:24:15 * copumpkin stares at ezyang
11:24:16 <zygoloid> edwardk: aren't the parens required now?
11:24:16 <sinelaw> thx
11:24:34 <c_wraith> ManateeLazyCat: nah, I don't know much about it, except there being a split-objs option that makes the linker use less memory
11:24:37 <copumpkin> hi edwardk, Fare :)
11:24:46 <integral> @src rem
11:24:46 <lambdabot> Source not found. You type like i drive.
11:25:05 <edwardk> > let f l@(Left{}) = True in f (Left 1234)
11:25:06 <lambdabot>   True
11:25:16 <edwardk> > let f l@Left{} = True in f (Left 1234)
11:25:17 <lambdabot>   True
11:25:54 <ManateeLazyCat> c_wraith: I doubt have some bug in GHC's compile module, because GHC is so smart. :)
11:27:45 <ManateeLazyCat> Kagami`: For current situation, you can terminate GHC after compile 50 ~ 100 modules, then do again. Of course you can compile all 640 modules once, if you have enough memory.
11:27:50 <ManateeLazyCat> :)
11:28:22 <Fare> copumpkin, co-hi
11:29:35 <edwardk> Fare: did my reply to your interface passing style post make sense?
11:29:51 <edwardk> i wasn't all that awake when i wrote it
11:30:24 <maltem> ManateeLazyCat, which is, arguably, a GHC performance bug
11:30:31 <medfly> indeed
11:31:35 <ManateeLazyCat> maltem: I don't know, i just know GHC will eat too much memory when compile too many modules.
11:31:44 <edwardk> ManateeLazyCat: i'm guessing you're referring to qthaskell?
11:31:58 <ManateeLazyCat> edwardk: Yep,
11:32:03 <ManateeLazyCat> edwardk: I'm interested it.
11:32:08 <maltem> ManateeLazyCat, exactly
11:32:44 <ManateeLazyCat> edwardk: I like Qt4 API, looks awesome.
11:33:02 <edwardk> haven't really looked at it
11:33:28 <maltem> ManateeLazyCat, http://hackage.haskell.org/trac/ghc/ticket/3829 if you like to subscribe or something
11:33:40 <ManateeLazyCat> edwardk: I was thinking, if i switch from gtk2hs to qtHaskell, i can build more cool feature that base on qt4
11:33:52 <sinelaw> is there a situation where existentials are the way to go?
11:34:04 <sinelaw> or is that a sign of trying to do things the wrong way
11:34:06 <edwardk> sinelaw: left kan extensions? =)
11:34:23 <sinelaw> edwardk, i have no idea what your pet is about :P
11:34:49 <edwardk> sinelaw: you can usually work around the need for them by bundling up the operations explicitly a functions rather than as a typeclass.
11:35:03 <ManateeLazyCat> mattam: I love it http://hackage.haskell.org/trac/ghc/ticket/3829. :)
11:35:24 <sinelaw> in my case its just a data type
11:35:24 <ManateeLazyCat> maltem: 1.7GB, he just have 2GB like me. :)
11:35:29 <Fare> edwardk, it was sometimes more suggestive than explicit. Where do you pass the monad around? as a first argument to each and every function?
11:35:36 <edwardk> but i've used them for some pretty tricky things in the past, like taking a zipper of an Applicative GADT, the intermediate types change as I go down the tree, but I know the type of the top and of the leaves.
11:35:58 <edwardk> fare: lemme scrape up a link (at least to an old paste of it)
11:36:14 <edwardk> fare: http://paste.lisp.org/display/86914
11:36:41 <sinelaw> edwardk, i have some structure where each node has some internal state of some type, which i don't care about when i build the structure
11:36:43 <edwardk> each function returns a lambda that expects the dictionary, that lets me use variadic functions
11:36:49 <maltem> ManateeLazyCat, heh, I didn't feel like investing in more RAM merely on this occasion
11:37:03 <sinelaw> i only care about the part of the node's type that determines to which other nodes it can connect
11:37:19 <djahandarie> I have some code that typechecks but blows up when I run it with no visible error
11:37:23 <edwardk> sinelaw: keep in mind, that thunks and functions already carry around such a state. there is an explicit existential implied in closure conversion
11:37:40 <edwardk> er implicit
11:37:40 <sinelaw> edwardk, yes i was thinking about closures too. maybe i can manage with that
11:37:46 <ManateeLazyCat> maltem: I plain buy 2GB memory for GHC. :)
11:37:56 <sinelaw> edwardk, or are existentials just as good?
11:37:58 <sinelaw> explicit ones
11:38:20 <sm> how can I make a null Assertion that always succeeds ? I need it for an either expression
11:38:34 <edwardk> sinelaw: the explicit variety let you bundle up dictionaries without having to manually expand them
11:38:34 <sm> this is HUnit
11:38:54 <sinelaw> edwardk, i don't understand what you mean by that
11:38:55 <ManateeLazyCat> s/plain/plan to
11:39:02 <djahandarie> Is there any way to figure out what in the world is killing the program?
11:39:16 <c_wraith> sm: "return True" ?
11:39:25 <edwardk> sinelaw: consider something like data Showable = forall a. Show a => Showable a
11:39:32 * djahandarie has never had to debug anything that didn't type check
11:39:36 <sinelaw> djahandarie, how does it blow up? eat memory? segfault? do you run it via ghci or not?
11:39:37 <edwardk> sinelaw you can then do something like foo (Showable a) = show a
11:39:43 <edwardk> sinelaw and pass around lists of them right?
11:39:55 <djahandarie> sinelaw, it just stopped execution, and yeah, ghci
11:40:01 <djahandarie> When there is no reason it should stop
11:40:11 <edwardk> the nice thing is if you have several dictionaries of methods you want to use, (not just Show) you can do the same thing by adding more constraints
11:40:15 <sinelaw> djahandarie, ghci is buggy in some cases where you use external libs
11:40:18 <sinelaw> edwardk, hmm
11:40:25 <djahandarie> Alrighty, I'll try compiling
11:40:56 <sinelaw> djahandarie, maybe your program caused a dynmaic library to load, that's a potential hazard in ghci
11:41:18 <djahandarie> sinelaw, wouldn't it give me some sort of error or something?
11:41:37 <edwardk> sinelaw: and its not always sufficient to just replace Showable with a string. you might want to show it with different surround parentheses, etc.
11:41:45 <sinelaw> djahandarie, that would have been nice, but apparently it's buggy
11:41:50 <sm> c_wraith: if that's some clever monad trick, I haven't made it work.. here's my code
11:41:53 <sm> assertParse :: (Either ParseError a) -> Assertion
11:41:54 <sm> assertParse parse = either (assertFailure.show) (...?...) parse
11:42:02 <edwardk> after all, Show has multiple class members: show, showsPrec, showList
11:42:12 <djahandarie> sinelaw, the compiled version didn't work either
11:42:49 <sinelaw> djahandarie, then it's not that :)
11:43:19 <sinelaw> edwardk, if i'm getting it, you're saying that i can use it to essentially switch between "typeclasses" in runtime?
11:43:29 <edwardk> so to convert that explicit existential to the implicit existential, you'd need to do something like data Showable = Showable { _show: String, _showsPrec : Int -> ShowS, .. }
11:43:40 * sm can't quite put his finger on it
11:44:00 <sinelaw> edwardk, that's not far removed from my own code now :)
11:44:02 * zygoloid hands edwardk some spare :s
11:44:16 <edwardk> zygoloid: hah, true.
11:44:39 <edwardk> zygoloid: been spending too much time hacking on a language that only uses one there ;)
11:44:58 <sinelaw> edwardk, you mean: syoloid, so sincere!
11:45:05 <sinelaw> *sygoloid
11:45:20 <zygoloid> don't worry, i had them left over from a c++ project. someone budgeted for more switches and gotos than we used...
11:46:01 <edwardk> zygoloid: fair enough, i'll trade you some parens, I don't code nearly as much scheme these days.
11:46:03 <sm> aha: assertParse parse = either (assertFailure.show) (const (return ())) parse
11:46:10 <ManateeLazyCat> http://doc.trolltech.com/4.6/classes.html
11:46:14 <zygoloid> edwardk: looks like sm needs them more than i do
11:46:32 <mreh> why is this bad: evalRandIO ((head . dropWhile (== 1)) `liftM` (getRandomRs (0, 1)))
11:46:39 <sinelaw> edwardk, is there anything particularly dangerous i should be aware of when doing something like that?
11:46:41 <edwardk> and if i run out I always turn to okasaki's combinators ;)
11:46:44 <sm> that's the most paren-ful haskell expression I think I've written
11:46:56 <edwardk> er can always
11:48:01 <edwardk> sinelaw: the implicit kind? not much, you have no weird 'existential type escape' issues at least then.
11:48:39 <edwardk> assertParse = assertFailure.show `either` const (return ()) -- ?
11:48:40 <sinelaw> i'm not sure i got how you do that implicitly
11:49:24 <sinelaw> the Showable constructor you wrote is hard-wired to use String, Int, etc..
11:49:25 <mreh> why is that causing an infinite loop?
11:49:48 <sinelaw> edwardk, i'm missing something there
11:49:51 <edwardk> sinelaw: the String there is the result of 'show' the Int is the argument to showsPrec.
11:50:44 <sinelaw> edwardk,  ok so an instance of Showable can use any functions it wants
11:50:46 * Twey hands edwardk some spare ;s
11:50:49 <djahandarie> Grrr
11:50:53 <edwardk> sinelaw: convert :: Show a => a -> Showable; convert a = Showable { _show = show a, , _showsPrec = \i -> showsPrec i a }
11:50:54 * djahandarie stabs his code
11:51:10 <Twey> djahandarie: Paste code, not growls.  ;)
11:51:18 <djahandarie> Hah, alrighty
11:51:26 <mreh> I've got some code
11:51:30 <sinelaw> allMIGHTY
11:51:31 <mreh> evalRandIO ((head . dropWhile (== 1)) `liftM` getRandomRs (0, 1))
11:51:50 <Twey> All mighty Haskell-programmers
11:51:58 <zygoloid> > runRand ((head . dropWhile (== 1)) `liftM` getRandomRs (0, 1)) (mkStdGen 42)
11:52:00 <lambdabot>   (0,1720602 2147483398)
11:52:17 <mreh> ?!
11:52:17 <lambdabot> Maybe you meant: . ? @ v
11:52:25 <zygoloid> mreh: probably runRandIO is too strict?
11:52:30 <djahandarie> import Data.List
11:52:30 <djahandarie> import Network
11:52:30 <djahandarie> import System.IO
11:52:33 <mreh> zygoloid: maybe
11:52:33 <djahandarie> Ah jesus
11:52:40 <mreh> djahandarie, @paste
11:52:42 <djahandarie> http://pastebin.com/wff5JWSZ
11:52:43 <mreh> @paste
11:52:43 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:52:46 <djahandarie> Yes, accidently
11:52:48 <mreh> :)
11:53:02 <zygoloid> mreh: i would guess it's trying to use the IO StdGen, extract infinite ints, then write it back again :)
11:53:04 <djahandarie> Good thing irssi cuts me off when I do that
11:53:11 <edwardk> sinelaw: vs. convert :: Show a => a -> Showable; convert = Showable; _show (Showable a) = show a; _showsPrec (Showable a) i = showsPrec i a -- which would be the equvalent code using the explicit existential i mentioned before. modulo whatever symbols I ran out of and was not resupplied with in the meantime
11:53:19 <mreh> zygoloid: the actual code is in MonadRandom
11:53:24 <Baughn> djahandarie: It's supposed to do it before writing anything at all, though
11:53:29 <mreh> i didn't test it in that context
11:53:43 <djahandarie> Anyways, all I did was a change in eval and added the jisho function
11:53:56 <djahandarie> When the were seperate they were working fine
11:53:59 <djahandarie> they*
11:54:16 <djahandarie> So that makes me feel like ReaderT is fudging something up
11:54:25 <djahandarie> I'm pretty lost because it isn't giving me any errors though
11:55:49 <sinelaw> edwardk, ok, but do you mind staring at my code for a few seconds?
11:55:49 <sinelaw> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8528#a8528
11:56:44 <edwardk> sinelaw: what can you do with the Chain and Bind nodes?
11:56:54 <edwardk> sinelaw: other than know there is some kind of processor there
11:56:55 <sinelaw> run them
11:57:14 <zygoloid> mreh: try: let evalRandIO' x = evalRandIO (fmap (fst . runRand x)) in evalRandIO' ((head . dropWhile (== 1)) `liftM` getRandomRs (0, 1)) (mkStdGen 42)
11:57:24 <ManateeLazyCat> bye all. Good night! :)
11:57:38 <sinelaw> edwardk, run the processors in order, surrounded by allocations and deallocations
11:57:54 <sinelaw> it's a DSL
11:57:55 <edwardk> sinelaw: i.e. are you doing this so you can split these apart and run them in parallel or some such?
11:58:09 <sinelaw> sequentially, actually, but yes
11:58:33 <sinelaw> maybe i should have pasted the full module i'm writing
11:58:44 <sinelaw> but my question is specifically how to encode that thing without forall
11:58:56 <zygoloid> @type let evalRandIO' x = evalRandIO (fmap (fst . runRand x) getSplit) in evalRandIO' ((head . dropWhile (== 1)) `liftM` getRandomRs (0, 1))
11:58:57 <lambdabot> forall a. (Num a, Random a) => IO a
11:59:02 <zygoloid> mreh: ^^ that
11:59:40 <edwardk> dumb question, what keeps you from trying to 'releaseNext' using the wrong processor?
11:59:40 <sinelaw> there's a x-> missing in releaseNext but never mind that
11:59:47 <edwardk> hah
12:00:07 <sinelaw> edwardk, the idea is to use the combinators, not to internally run the functions manually
12:00:17 <edwardk> sure
12:00:26 <edwardk> i'm just looking at how it is put together.
12:00:28 <sinelaw> build stuff using the three constructors (or wrappers thereof) and in the end use 'run'
12:00:41 * djahandarie sighs
12:01:15 <edwardk> what are the 'x's representing? are they just tags or is there real data in them?
12:01:25 <sinelaw> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8528#a8529
12:01:29 <sinelaw> updated to show the whole module
12:01:39 <sinelaw> edwardk, x is for 'extra state'
12:01:42 <sinelaw> :P
12:02:55 <sinelaw> edwardk, it actually doesn't compile now, but i can fix that i think. i want to get rid of the existentials, though.
12:03:59 <edwardk> sinelaw: well, part of this is you should be able to get down to one constructor.
12:04:35 <sinelaw> i already had a version that did, but it really made things complicated because i ended up writing a 'shallow dsl' instead of a deep one.
12:04:37 <edwardk> you have an 'initial' encoding of the problem, but there is an equally valid 'final' encoding.
12:05:32 <sinelaw> i got confused with that, because i couldn't properly do the type of the combined chain (for example) without littering the result's type with tuples
12:06:05 <sinelaw> like when combining:  (P a b) `chain` (P b c) i got: P a (b,c)
12:06:16 <sinelaw> while i wanted P a c
12:06:31 <edwardk> it shouldn't have to change, one sec.
12:06:56 <MadHatterDude> @pl (\f g x -> let r = second g $ f x in (fst r ++ fst snd r, snd snd r))
12:06:57 <lambdabot> ((ap ((,) . liftM2 (++) fst (fst snd)) (snd snd) .) .) . flip ((.) . second)
12:07:37 <pokoko222> how would u do this monster in haskell http://projecteuler.net/index.php?section=problems&id=61 ? i need general guidlines to lower search space
12:07:48 <MadHatterDude> Sometimes pointfree is pointless
12:07:58 <edwardk> also, due to the use of existentials, you'll never be able to call 'allocateNext'
12:08:19 <sinelaw> edwardk, yeah i just realized that
12:08:23 <edwardk> you'll always have to perform allocateNext by pattern matching
12:08:34 * sinelaw nods
12:08:39 <cytzol> MadHatterDude: yeah, but it's sometimes fun to see your expressions expand into huge pointfree beasts
12:08:47 <sinelaw> and my implementation of 'chain' is all wrong. it should be recursive
12:08:54 <sinelaw> for Chain and Bind
12:09:12 <sinelaw> that's fixable though
12:10:00 <Botje> pokoko222: err, start by simply gathering all four digit numbers from those 7 categories?
12:10:12 <MadHatterDude> cytzol: Yeah... when you have things like (\list1 list2 -> list1 ++ insert ++ list2) it already becomes messy...
12:10:28 <pokoko222> Botje and then combinatorial explosion
12:10:30 <MadHatterDude> @pl (\x y -> x ++ " " ++ y)
12:10:30 <lambdabot> (. (' ' :)) . (++)
12:10:58 <edwardk> so, your problem right now is that allocateNext and releaseNext can't be called as you've got this. lets see if it can be turned inside out, and perhaps made to use the implicit existential/and or a final encoding.
12:11:00 <copumpkin> pokoko222: not really
12:11:02 <MadHatterDude> @pl (\x y -> x ++ "   " ++ y)
12:11:02 <lambdabot> (. ("   " ++)) . (++)
12:11:15 <Botje> pokoko222: then start eliminating numbers that can't "connect" with others
12:11:17 <MadHatterDude> @pl (\x y z = x ++ y ++ <)
12:11:18 <lambdabot> (line 1, column 9):
12:11:18 <lambdabot> unexpected "="
12:11:18 <lambdabot> expecting pattern or "->"
12:11:26 <MadHatterDude> @pl (\x y z = x ++ y ++ z)
12:11:26 <lambdabot> (line 1, column 9):
12:11:26 <lambdabot> unexpected "="
12:11:26 <lambdabot> expecting pattern or "->"
12:11:29 <edwardk> you need to call allocate, process, then release, right?
12:11:35 <MadHatterDude> @pl (\x y z -> x ++ y ++ z)
12:11:35 <lambdabot> (. (++)) . (.) . (++)
12:11:48 <pokoko222> copumpkin talk to me mortal
12:12:09 <cytzol> MadHatterDude: that function looks fine as it is to me
12:12:28 <sinelaw> edwardk, right.
12:13:07 <MadHatterDude> cytzol: Bad example :-/
12:13:14 <MadHatterDude> :P
12:13:38 <edwardk> k, fiddling with your types a bit. 'b' is the type of the subset of stuff that release needs to care about?, what distinguishes b and x? why is b in the type but x not.
12:13:58 <copumpkin> @let figurate n = scanl1 (+) [1, pred n..]
12:14:02 <lambdabot>  Defined.
12:14:02 <edwardk> why do i care what types you need to release outside of the step in question
12:14:06 <Botje> huh, in the end i solved 61 by manually checking them :P
12:14:18 <Mathnerd314> I want to create a "double map" function of type(a -> b -> c) -> [a] -> [b] -> [c]. What's the shortest way?
12:14:28 <xerox> ?type zipWith
12:14:29 <copumpkin> Mathnerd314: zipWith
12:14:29 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:14:31 <mreh> No instance for (RandomGen System.Random.StdGen)
12:14:36 <Mathnerd314> ah.
12:14:38 <mreh> @instances RandomGen
12:14:38 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
12:14:39 <xerox> actually I guess it is
12:14:47 <mreh> @instances System.Random.RandomGen
12:14:48 <copumpkin> :t liftM2
12:14:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:14:49 <xerox> ?hoogle (a -> b -> c) -> [a] -> [b]Â -> [c]
12:14:49 <lambdabot> Parse error:
12:14:49 <lambdabot>   --count=20 "(a -> b -> c) -> [a] -> [b]Â -> [c]"
12:14:49 <lambdabot>                                          ^
12:15:03 <copumpkin> :t liftM2 `asTypeOf` zipWith
12:15:04 <lambdabot> forall a1 a2 r. (a1 -> a2 -> r) -> [a1] -> [a2] -> [r]
12:15:05 <mreh> @instances-importing System.Random RandomGen
12:15:06 <lambdabot> StdGen
12:15:10 --- mode: xerox set -o xerox
12:15:12 <sinelaw> edwardk, 'a' is the input, 'b' is the output (except it's actually written in a pre-allocated resource)
12:15:18 <mreh> that's strange
12:15:26 <sinelaw> edwardk, and 'x' is a pre-allocated state that the process function needs
12:16:10 <MadHatterDude> is it just me or are arrows INCREDIBLY awesome?
12:16:12 <edwardk> ok, so you have a hardcoded execution model that the allocator creates both structures, and release throws away the 'x'. why does release need the 'b' then?
12:16:20 <sinelaw> edwardk, example, a = (), and b a Ptr Image, and x is Ptr Camera or so
12:16:47 <sinelaw> because i need to release 'b' too
12:17:04 <sinelaw> after the whole chain completes, that is.
12:17:06 <mreh> MadHatterDude: it's just you
12:17:29 <sinelaw> when i chain them, i want a sequence of allocations, sequence of processing, and sequence of releasers
12:17:35 <mreh> does anyone else have dependency hell with Random and MonadRandom?
12:17:48 <sinelaw> hell, probably
12:17:48 <edwardk> not sure i see the point of both b and o then. o strikes me as the place to put your result, then you have a fairly obvious arrow.
12:18:15 <mreh> MonadRandom and Random have their own RandomGen classes
12:18:28 <mreh> that's strange
12:18:33 <sinelaw> edwardk, it comes from my C bindings. i have functions of the type f(blah *input, bleh *output)
12:18:59 <sinelaw> 'o' can't be the output (in many cases) because it needs to be pre-allocated
12:19:04 <edwardk> that was the piece i was missing ;)
12:19:06 <sinelaw> 'b' is the actual output
12:19:16 <mreh> Cale: can you help with MonadRandom? puhleaze!
12:19:31 <edwardk> why don't you want to free b immediately?
12:19:50 <edwardk> once you have your 'o' in hand
12:20:29 <sinelaw> edwardk, example code in C: dst1_ptr = allocate(); dst2_ptr = allocate(); f(src_ptr, dst1_ptr); g(dst1_ptr, dst2_ptr); ... do something with dst2 ... ... releasers ...
12:20:30 <copumpkin> > map figurate [3..8[
12:20:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:20:34 <copumpkin> > map figurate [3..8]
12:20:35 <lambdabot>   [[1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
12:20:47 <sinelaw> edwardk, 'o' in most of my cases so far is simply ()
12:21:00 <sinelaw> and 'm' is IO. the process function returns IO ()
12:21:19 <gwern> @remember DanielFranke Genuine quote from my old logic professor: âHaskell? Oh, must be named for Haskell Curry. Good guy. I dated his daughter.â
12:21:19 <lambdabot> Good to know.
12:21:31 <MadHatterDude> good god I feel stupid.
12:21:36 <edwardk> gwern: hahaha
12:21:40 <sinelaw> :) heh
12:21:42 <gwern> @flesh
12:22:35 <MadHatterDude> "(Just (l, lr), Just (r, rr)) -> let (ll, rl) = length *** length $ (l, r) in if (ll > lr) then l else r" gives me and error in a case expression on the "->"
12:23:14 <sinelaw> edwardk, is my code making more sense now or less?
12:23:29 <Kagami`> gwern: what does '@flesh' command mean?
12:23:30 <edwardk> some more, some less. i feel like it is subtly off of a very clean solution
12:23:40 <edwardk> and i'm trying to figure out how to change the problem to make a cleaner formulation
12:23:41 <sinelaw> edwardk, so do i, but i can't see it
12:23:46 <copumpkin> @let filterMonotonic p = takeWhile p . dropWhile (not . p)
12:23:47 <lambdabot>  Defined.
12:23:54 <mreh> I need to upgrade a core library, shall I fetch my crucifix just in case?
12:24:07 <sinelaw> mreh, garlic too
12:24:10 <benmachine> MadHatterDude: unmatched parenthesis on the previous line?
12:24:16 <copumpkin> > map (filterMonotonic ((==4) . length . show)) . figurate) [3..8]
12:24:17 <lambdabot>   <no location info>: parse error on input `)'
12:24:18 <mreh> I had this problem before with MonadRandom and Random being incompatible
12:24:23 <copumpkin> > map (filterMonotonic ((==4) . length . show) . figurate) [3..8]
12:24:24 <lambdabot>   [[1035,1081,1128,1176,1225,1275,1326,1378,1431,1485,1540,1596,1653,1711,177...
12:24:35 <edwardk> you have a sort of (>>>)-like Chain but a (>>=)-like Bind, each on different parameters.
12:24:41 <twink> copumpkin: scanl1 (+) [1..] ?
12:24:47 <sinelaw> edwardk, i don't mind dropping the Bind
12:24:49 <MadHatterDude> benmachine: Nope, previous line is "(Nothing, Nothing) -> Nothing"
12:24:58 <Taejo> :t (<*)
12:24:59 <copumpkin> > length . sequence . map (filterMonotonic ((==4) . length . show) . figurate) $ [3..8]
12:24:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:25:03 <lambdabot>   mueval-core: Time limit exceeded
12:25:06 <copumpkin> :P
12:25:14 <edwardk> Bind looks like the bind for a parameterized monad
12:25:15 <sinelaw> edwardk, it's not essential at this point. i'm aware of the similarity to Arrow and Monad
12:25:35 <sinelaw> edwardk, but Chain is more important for me now.
12:25:38 <MadHatterDude> benmachine: Separating it with ';' works somehow...
12:25:51 <benmachine> MadHatterDude: sounds like your error is incorrect indentation then
12:25:55 <benmachine> (possibly)
12:27:14 <MadHatterDude> benmachine: Yeah, and even though I'm an expert in indentation (python for a year with little social life) I can't find it
12:27:50 <xerox> copumpkin: what are you calculating?
12:28:05 <benmachine> MadHatterDude: pastebin?
12:28:11 <jmcarthur> :t figurate
12:28:15 <lambdabot> forall a. (Num a, Enum a) => a -> [a]
12:28:15 <copumpkin> xerox: pokoko222's project euler 61, but I've lost interest now
12:28:55 <sinelaw> i found interest!
12:29:00 <Taejo> :t number
12:29:01 <lambdabot> Not in scope: `number'
12:29:02 <sinelaw> who's is is this
12:29:03 <copumpkin> you took it!
12:29:09 <sinelaw> 4%
12:29:14 <sinelaw> pay up
12:29:17 <pokoko222> copumpkin well when i think about it there are not so many numbers so brute force might do the job
12:29:37 <Mathnerd314> > zipWith (+) [1,2,3] [2,3,4]
12:29:38 <lambdabot>   [3,5,7]
12:29:44 <Mathnerd314> > liftM2 (+) [1,2,3] [2,3,4]
12:29:45 <lambdabot>   [3,4,5,4,5,6,5,6,7]
12:29:48 <Mathnerd314> :-(
12:29:53 <copumpkin> pokoko222: see what I've been doing on lambdabot
12:30:01 <copumpkin> Mathnerd314: what? :)
12:30:10 <aavogt> mreh: the problem is you're mixing multiple version of the random package?
12:30:14 <xerox> > liftM2 f [x,y] [z,w] :: [Expr]
12:30:15 <lambdabot>   [f x z,f x w,f y z,f y w]
12:30:19 <CBro2007> hi guys.. I am planning on learning Haskell, how does it compare to LISP?
12:30:20 <michaeldever> hey all, if i want to add some html formatting to a haddock comment, for subscript and italics, how would i do that?
12:30:27 <Mathnerd314> List has the wrong monad
12:30:28 <mreh> aavogt: something like that
12:30:29 <CBro2007> is the syntax easier to understand?
12:30:35 <xerox> > zipWith f [x,y] [z,w] :: [Expr]
12:30:36 <lambdabot>   [f x z,f y w]
12:30:47 <copumpkin> Mathnerd314: which monad do you want?
12:30:49 <sinelaw> CBro2007, syntax much easier
12:30:55 <mreh> aavogt: I'm not really sure, let me paste what it says
12:30:59 <copumpkin> Mathnerd314: I don't even know of any other list monads :)
12:31:02 <CBro2007> sinelaw: anything else?
12:31:03 <Mathnerd314> I dunno... one that acts like zipWith ;-)
12:31:08 <CBro2007> sinelaw: performance?
12:31:10 <copumpkin> that's an applicative, called ZipList
12:31:16 <jmcarthur> Mathnerd314: that doesn't form a monad
12:31:29 <copumpkin> you could get a monad out of it if you had sized lists
12:31:43 <jmcarthur> or infinite lists
12:31:56 <mreh> aavogt: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8530#a8530
12:31:56 <sinelaw> CBro2007, i don't know enough about Lisp to answer
12:32:01 <michaeldever> is html formatting possible in haddock?
12:32:01 <jmcarthur> (result of bind is the diagonal)
12:32:18 <CBro2007> ok any lisp users here?
12:32:19 <pokoko222> copumpkin hmm so u ... ok i am gonna do it in c++ mortal
12:32:21 <byorgey> > liftA2 (+) (ZipList [1,2,3]) (ZipList [2,3,4])
12:32:22 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
12:32:22 <lambdabot>    arising ...
12:32:24 <copumpkin> pokoko222: o.O
12:32:29 <ulfdoz> CBro2007: For performance, you can have a look at the great computer language shootout.
12:32:30 <MadHatterDude> benmachine: My code: http://pastebin.com/nRHt8sgm
12:32:32 <byorgey> > getZipList $ liftA2 (+) (ZipList [1,2,3]) (ZipList [2,3,4])
12:32:33 <lambdabot>   [3,5,7]
12:32:34 <sinelaw> CBro2007, haskell's performance can be pretty good.
12:32:37 <copumpkin> byorgey: really annoying, that lack of a Show
12:32:41 <byorgey> seriously
12:32:48 <sinelaw> CBro2007, but that's not why it appeals to me
12:33:08 <byorgey> anyway, no one should ever use liftMn: use liftAn (or <$>, <*>) instead!
12:33:11 <ulfdoz> CBro2007: But be aware that it is often a crappy criterion. No one cares for performance, if it works reliable, which is just a matter of code and development effort.
12:33:26 <benmachine> MadHatterDude: why are the case branches indented at different levels?
12:33:43 <Taejo> is there a name for foldr (<|>) ?
12:33:44 <jmcarthur> you should use liftM if you already have a Monad constraint and don't want to also introduce an Applicative constraint (due to our incorrect monad heirarchy)
12:33:45 <edwardk> CBro2007: i'm a rather heavy user of both
12:33:52 <sinelaw> @pl foldr (<|>)
12:33:52 <lambdabot> foldr (<|>)
12:33:54 <CBro2007> ulfdoz: for me performance is important
12:33:55 <MadHatterDude> benmachine: Must be tabs. Vim shows them level...
12:34:01 <edwardk> CBro2007: though w.r.t. lisp dialects I'm more of a scheme user.
12:34:08 <CBro2007> ok
12:34:17 <benmachine> MadHatterDude: -fwarn-tabs :P
12:34:19 <edwardk> CBro2007: haskell's performance tends to blow the doors of lisps.
12:34:35 <copumpkin> unless you go for stalin scheme!
12:34:39 <sinelaw> edwardk, any idea how i can simplify this ?
12:34:41 <CBro2007> really?
12:34:42 <edwardk> copumpkin: i did say tends to ;)
12:34:43 <copumpkin> but stalin was evil
12:34:50 <sinelaw> stalin? that's quite a scheme
12:34:50 <edwardk> copumpkin: and stalin doesn't scale =)
12:35:00 <jmcarthur> CBro2007: ghc generates very fast binaries
12:35:00 <copumpkin> yeah :)
12:35:13 <ulfdoz> CBro2007: If you can save 10% execution time it is almost not not noticable.
12:35:19 <CBro2007> whats GHC?
12:35:19 <companion_cube> is scheme supposed to be that fast ?
12:35:29 <jmcarthur> CBro2007: our major compiler
12:35:39 <therp> I miss my :( ):
12:35:41 <sinelaw> jmcarthur is written in Haskel
12:35:41 <edwardk> sinelaw: starting to see how tricky it is to functionalize your Processor type
12:35:45 <CBro2007> yeah but if the thing is like 5-6 times faster then you will notice it
12:35:55 <jmcarthur> sinelaw: you're the first to figure that out
12:35:56 <byorgey> Taejo: hmm, there isn't, apparently.  maybe call it 'oneOf' or something
12:36:06 <CBro2007> its just that we have a research group heavy into Common Lisp
12:36:10 <CBro2007> and think its the best shit
12:36:13 <sinelaw> jmcarthur: undefined
12:36:16 <byorgey> @pl foldr mappend mempty
12:36:16 <lambdabot> foldr mappend mempty
12:36:21 <ulfdoz> CBro2007: You won't a factor of 5 or 6 because you are using the one language or the other.
12:36:23 <CBro2007> they have developed an OO DB in-memory using Lisp
12:36:37 <jmcarthur> sinelaw: * Exception: Prelude.undefined
12:36:53 <edwardk> CBro2007: well, the nice thing about haskell is you can think thoughts that are very difficult to express in common lisp. on the other hand if you want to interoperate with their code, then CL may be the better way for you to go
12:37:01 <CBro2007> so I am wondering what my first language should be to learn the functional paradigm
12:37:04 <sinelaw> jmcarthur, private messaging with lambdabot, eh? naughty boy
12:37:11 <CBro2007> there is a course at uni that teaches it in "ML"
12:37:12 <sinelaw> or was it ghci
12:37:15 <CBro2007> I hear ML is nice too
12:37:17 <therp> CBro2007: lisp is not functional, forget about that myth
12:37:32 <jmcarthur> sinelaw: i used LB. i just forgot the exact output for undefined ;)
12:37:39 <MadHatterDude> CBro2007: try functional style in python...
12:37:51 <jmcarthur> MadHatterDude: or not
12:37:52 <CBro2007> MadHatterDude: are you serious/
12:37:54 <CBro2007> ?
12:37:55 <edwardk> CBro2007: scheme tends to favor functional code far more than other lisps, like say, common lisp
12:37:57 <MadHatterDude> CBro2007: That was what I started with :P
12:38:04 <jmcarthur> ugh
12:38:16 <MadHatterDude> I quickly changed to haskell tho...
12:38:26 <jmcarthur> i'm never used common lisp, but my impression is that it is quite OO
12:38:29 <jmcarthur> *i've
12:38:36 <sinelaw> MadHatterDude, heh i started by implementing a very tiny functional programming language in python
12:38:43 <therp> scheme favors functional code over lisp, like pizza favors fork and knife over a burger.
12:38:45 <sinelaw> then i said: what the hell, there are reall languages for this.
12:38:54 <therp> s/lisp/common lisp/
12:38:59 <sinelaw> therp, <<loop>>
12:39:17 <byorgey> @remember therp scheme favors functional code over lisp, like pizza favors fork and knife over a burger.
12:39:17 <lambdabot> Done.
12:39:18 <therp> sinelaw: with sed that's no loop, but yeah ;)
12:39:26 <jmcarthur> beat me to it
12:39:35 <jmcarthur> but i was going to correct the s/lisp/common lisp/ part
12:39:41 <byorgey> @forget therp scheme favors functional code over lisp, like pizza favors fork and knife over a burger.
12:39:41 <lambdabot> Done.
12:39:51 <byorgey> @remember therp scheme favors functional code over common lisp, like pizza favors fork and knife over a burger.
12:39:51 <lambdabot> Good to know.
12:39:59 <sinelaw> edwardk, i too thought it will be easy at first
12:40:00 <CBro2007> hmm
12:40:12 <sinelaw> edwardk, at every attempt it seems even more complicated
12:40:12 <CBro2007> I wonder how easy/hard it will be to think functionally now
12:40:18 <CBro2007> I am more a "C" person
12:40:20 <CBro2007> :)
12:40:29 <MadHatterDude> Damn, I've got this little regex-like library that's absolutely brilliant, and now I've gone through 5 or 6 tries at generalizing it into something you can build a parser with (read 'Arrow')
12:40:37 <CBro2007> It must be a completely different style of coding yeah?
12:40:38 <jmcarthur> CBro2007: it's tought to adjust at first, but i promise it is very much worth it
12:40:39 <sinelaw> CBro2007, Haskell is guaranteed to change the way you think, for the better
12:40:41 <edwardk> therp: =P i meant that in scheme you have mandatory TCO so you are not at the mercy of arcane loop constructs like other lisps =P
12:40:45 <jmcarthur> *tough to
12:40:54 <therp> CBro2007: try to do project-euler.net in Haskell if you are really eager to learn something.. that's just my .02$ :)
12:40:57 <Mathnerd314> this page needs help: http://www.haskell.org/haskellwiki/Lucid
12:41:07 <CBro2007> Yeah I hear you can do some real tough stuff in a few lines.. using recursion etc... I like that sorta stuff
12:41:15 <ulfdoz> CBro2007: So what's the point about performance for? High level assembler allows you to handcraft the code, until its fast enough.
12:41:27 <edwardk> CBro2007: the best way i found to learn haskell was to forget about efficiency for a few months, and then relearn what it means to be efficient under the new paradigm you are now in.
12:41:34 <CBro2007> ulfdoz: whats with you and performance?
12:41:41 <jmcarthur> CBro2007: at first you learn some basics and it's like "this is kind of neat, but nothing revolutionary," but then you start learning some of the abstractions we build on a regular basis and it starts to click that this really is something different
12:41:48 <CBro2007> ulfdoz: you want something that does the same job and takes 10 times longer?
12:42:05 <CBro2007> jmcarthur: ok sounds good :)
12:42:05 <therp> edwardk: hmm, that's true :). but at the end, scheme is still every different from Haskell in terms of semantics
12:42:06 <jmcarthur> or we could shock and awe you from the get go, but you won't necessarily be able to learn from that
12:42:28 <ulfdoz> CBro2007: The point is, that performance is one of the last things I care about. First it must work reliable, optimisations are far later, when the bugs have been fixed and the concept is proofed.
12:42:35 <edwardk> therp: well, evaluation order is technically unspecified. you could make a call-by-name scheme and it would still be legal r5rs ;)
12:42:41 <MadHatterDude> CBro: Have you had the "Monad" nirvana?
12:42:56 <MadHatterDude> CBro: If not, look forward to it.
12:43:02 <edwardk> therp: but now i'm just being a language lawyer
12:43:17 <CBro2007> MadHatterDude: whats that?
12:43:37 <jmcarthur> CBro2007: "I hear you can do some real tough stuff in a few lines.. using recursion etc..." <-- at first, sure, but then you learn to abstract even the recursion out! :)
12:43:39 <therp> edwardk: hmm.. I don't think so. the denotational semantics give a very clear picture that the evaluation must be done before the function is called.. although one can argue that the denotational semantics are not part of R5RS
12:43:46 <MadHatterDude> CBro: When Monad operations clicks for you and your code becomes littered with them.
12:44:27 <therp> edwardk: hmm but let me double check that. I'm not sure if I recall that correctly.
12:45:15 <CBro2007> ok
12:45:34 <CBro2007> what books do you guys recommend to a beginner?
12:45:47 <CBro2007> is there a good one littered with good examples?
12:45:50 <jacrough> Real World Haskell
12:45:53 <jacrough> is awesome
12:45:53 <edwardk> therp: the part i'm referring to is the will clingerism that is in r5rs page 9, 'note: although the order of evaluation is otherwise unspecified the effects of any concurrent evaluation of the operator and operand expressions is constrained to be consistent with some sequential order of evaluation. The order of evaluation may be chosen differently for each procedure call'
12:45:57 <jmcarthur> @check let mysum [] = 0; mysum (x:xs) = x + mysum xs in \xs -> mysum xs == foldl' (+) 0 xs
12:45:58 <lambdabot>   "OK, passed 500 tests."
12:46:09 <jmcarthur> @check let mysum [] = 0; mysum (x:xs) = x + mysum xs in \xs -> mysum xs == sum xs
12:46:10 <lambdabot>   "OK, passed 500 tests."
12:46:20 <edwardk> therp: that is the stuff that permits plt's lazy scheme, etc.
12:46:45 <edwardk> therp: once you cps the difference vanishes anyways =P
12:47:06 <jmcarthur> @where lyah
12:47:08 <jmcarthur> @where rwh
12:47:22 <mauke> @where lambdabot
12:47:26 <jmcarthur> @botsnack
12:47:30 <jmcarthur> :(
12:47:38 <edwardk> CBro2007: Real World Haskell (an O'Reilly book written by 3 guys who come on here faily regularly to help people out), and a more tongue in cheek introduction called 'Learn You a Haskell'
12:47:38 <lambdabot> http://www.learnyouahaskell.com/
12:47:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:47:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:47:38 <lambdabot> :)
12:47:42 <jmcarthur> oh hey!
12:47:53 <jmcarthur> CBro2007: ^^ :)
12:47:59 <therp> edwardk: to me this passage doesn't tell anything with respect to whether the evaluation of the args are before or after the function is called
12:48:03 <MadHatterDude> CBro: If you need to get a good feel for the syntax, go watch SPJ's talk "A Taste of Haskell"
12:48:06 <CBro2007> is real world haskell free?
12:48:17 <jmcarthur> CBro2007: the online version is. there is also a dead tree version you can buy
12:48:24 <CBro2007> MadHatterDude: oh yeah is that a video tutorial?
12:48:38 <edwardk> therp: quite deliberately so. that is the only remark w.r.t. ordering pretty much in the whole thing.
12:48:59 <CBro2007> it looks very well written
12:49:02 <CBro2007> I like the font
12:49:04 <CBro2007> :)
12:49:09 <jmcarthur> CBro2007: for the absolute beginner i typically recommend learn you a haskell, but if you are fairly good at C-like stuff already then real world haskell might be good for you
12:49:21 <CBro2007> ok cool
12:49:35 <edwardk> CBro2007: there is a print version of it, but there is an online copy of it. if you find it useful, i'm sure the guys who wrote it would appreciate you buying a copy ;)
12:49:50 <jmcarthur> the print version also have some differences from the online version, irrc
12:49:50 <pikhq> I'd say Learn You a Haskell is also good for people just completely unfamiliar with functional programming.
12:49:52 <jmcarthur> *iirc
12:50:00 <nagnatron> I really think LYAH is an amazing tutorial
12:50:01 <CBro2007> its just that I think I am going to be heavily involved in algorithms that involve lots of recursion and working with graphs.. so C gets a bit heavy sometimes... though it can be real fast..
12:50:10 <jlouis> I think that both RWH and LYAH are good for different reasons
12:50:11 <pikhq> Though if you're familiar with non-functional programming you will go through it pretty darn quickly.
12:50:29 * jmcarthur thinks jlouis is right
12:50:38 * pikhq concurreth
12:50:41 <CBro2007> hmm
12:51:04 <CBro2007> so what would you recommend someone who has more a procedural and declarative kinda background?
12:51:15 <jlouis> I learned Haskell from http://www.haskell.org/tutorial/ which isn't that gentle
12:51:31 <sinelaw> jlouis, ah the good old days
12:51:37 <copumpkin> I learned it from this channel
12:51:37 <edwardk> therp: one justification for why that is so loosely specified is that it permits the language of section 4.1.3 to apply to macro systems under, for instance, call-by-macro-expand
12:51:45 <copumpkin> best tutorial ever
12:51:57 <jlouis> sinelaw: but it is clear and fast. When you know a functional language beforehand, it is pretty neat
12:52:04 <MadHatterDude> How can you convert between a list and a maybe in monadic sense?
12:52:15 <copumpkin> in a monadic sense?
12:52:19 <pikhq> MadHatterDude: Uh... No?
12:52:20 <copumpkin> :t liftToMaybe
12:52:21 <CBro2007> I actually do think you guys are way more helpful as a channel than some other channels ...
12:52:21 <lambdabot> Not in scope: `liftToMaybe'
12:52:23 <BrianHV> jmcarthur: I happened to look at this channel when you made that recommendation, and have to thank you for it.  LYAH was going a little slowly for me, but RWH looks good
12:52:23 <CBro2007> :)
12:52:26 <copumpkin> :t listToMaybe
12:52:27 <lambdabot> forall a. [a] -> Maybe a
12:52:31 <copumpkin> tada, natrual transformation!
12:52:41 <jmcarthur> BrianHV: welcome!
12:52:48 <MadHatterDude> copumpkin: Ok...
12:52:51 <pikhq> @src listToMaybe
12:52:52 <lambdabot> listToMaybe []        =  Nothing
12:52:52 <lambdabot> listToMaybe (a:_)     =  Just a
12:52:52 <arw_> CBro2007: if you want to learn only haskell, start with LYAH. if you are also interested in functional programming in general, you might also want to read abelson & sussman
12:52:56 <pikhq> :)
12:53:04 <edwardk> therp: you can always work around all of this noise by using begin which has explicit sequencing in the semantics.
12:53:05 <copumpkin> who needs monads when you have NTs
12:53:07 <MadHatterDude> copumpkin: Thanks
12:53:18 <CBro2007> arw_: is that a wiki book?
12:53:19 <pikhq> Hmm. listToMaybe is as total head.
12:53:22 <MadHatterDude> copumpkin: NTs ?
12:53:23 <pikhq> Erm. Is a.
12:53:31 <copumpkin> MadHatterDude: natural transformations :)
12:53:38 <arw_> CBro2007: http://mitpress.mit.edu/sicp/ no, i don't think so. but every good library should have one.
12:53:57 <CBro2007> ok will check it out
12:53:58 <jmcarthur> pikhq: yup. and so is (take 1)
12:54:09 <MadHatterDude> :t total
12:54:10 <lambdabot> Not in scope: `total'
12:54:13 <CBro2007> MadHatterDude: have you got a link for that talk you mentioned?
12:54:25 <pikhq> jmcarthur: :)
12:54:33 <MadHatterDude> CBro: in a sec...
12:54:47 <pikhq> MadHatterDude: A "total function" is defined for all inputs.
12:54:48 <CBro2007> MadHatterDude: cheers
12:54:53 <CBro2007> thanks arw_
12:54:58 <MadHatterDude> CBro: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/
12:54:59 <therp> edwardk: I'm just starting at http://www.appsolutions.com/SchemeDS/semantic-functions.scm?showraw .. but that's not very helpful to me..
12:55:08 <pikhq> listToMaybe is total. head is not.
12:56:01 <jmcarthur> > head []
12:56:02 <lambdabot>   * Exception: Prelude.head: empty list
12:56:04 <edwardk> therp: i didn't believe it at first either ;)
12:56:05 <jmcarthur> > listToMaybe []
12:56:06 <lambdabot>   Nothing
12:56:45 <edwardk> therp: then i talked to dan friedman and will clinger about the deliberate choice of language. note that chez scheme deliberately uses a different argument evaluation order explicitly because it is allowed by the spec.
12:56:55 <MadHatterDude> Oh god... I see Arrows everywhere!
12:57:12 <CBro2007> thanks MadHatterDude
12:57:12 <edwardk> though it doesn't go so far as to shuffle the evaluation of the operator before the operands
12:57:37 <MadHatterDude> CBro: Glad to help :P
12:58:12 <dmead> hey channel
12:58:15 <dmead> i have a stupid question
12:58:18 <therp> edwardk: so you are arguing (just to verify) that (begin (setf x 0) ((lambda (y) x) (setf x 1)) x) might return 0, because the y argument never gets evaluated?
12:58:27 <edwardk> no
12:58:36 <dmead> i've got a bunch of types flushed out
12:58:40 <edwardk> begin has explicit ordering stated in the semantics of begin right in r5rs
12:58:49 <dmead> and i want to use parsec to parse strings and return those structures
12:58:59 <dmead> is that a good idea? or am i wrong
12:59:15 <byorgey> dmead: sounds like exactly what parsec is for.
12:59:35 <edwardk> 4.2.3 sequencing is very explicit about the order of effects for (begin ...) blocks
12:59:37 <therp> edwardk: right, but the problem with this example is that the application might never needs it argument because the lambda expression totally disregards its argument
12:59:49 <dmead> byorgey,  hmm alright
12:59:53 <edwardk> but virtually nothing else has that guarantee
13:00:08 <dmead> byorgey, but instead of just returning strings you return whatever type you want?
13:00:09 <byorgey> dmead: are you having trouble getting it to work?  or just wondering if this is the right thing to do?
13:00:18 <dmead> i'm getting it to return strings
13:00:23 <dmead> i wondering if it's the right thing to do
13:00:42 <byorgey> dmead: right, if you have something of type  Parser Foo  (or whatever)  it will take in strings and give you back Foos
13:00:49 <dmead> right
13:00:50 <therp> edwardk: its not about begin in this case. Its not important and also does not effect anything as the crucial is the second statement anyway
13:00:59 <therp> and only in the second statement
13:01:03 <dmead> ok cool
13:01:18 <dmead> byorgey, you ran hack phi last year right?
13:01:33 <byorgey> dmead: yup, that's me, I remember you =)
13:01:40 <dmead> ahh right
13:01:48 <dmead> yea i did a haskell intro at philly lambda
13:01:54 <byorgey> dmead: you're doing the masters project on analyzing network traffic or something like that, right?
13:02:00 <edwardk> therp: i'm not entirely sure whatthe implications of the lack of specificity in r5rs are for the possible results of that statement.
13:02:08 <byorgey> or am I confused?
13:02:17 <dmead> i think network traffic was someone else
13:02:19 <CBro2007> MadHatterDude: is this video for beginners too? or does it assume some knowledge?
13:02:22 <byorgey> oh, hmm
13:02:25 <dmead> i'm trying to do break detection in leg x-rays
13:02:32 <dmead> were you at that meeting?
13:02:39 <byorgey> no, I wasn't
13:02:49 <stevenmarky>  sweet.
13:03:01 <dmead> i did a talk for the january meeting
13:03:06 <dmead> which was actually in feburary
13:03:10 <MadHatterDude> CBro: It assumes you are vaguely fammiliar with functional programming, And somewhat familiar with orther (read imperative) programming
13:03:23 <dmead> i wasn't at hack phi
13:03:29 <therp> edwardk: I understood that you argue that call-by-name evaluation is ok, and as y is never named here by the body of the lambda expression the evaluation should never happen, thereby never giving you the side-effect.. that's not legal in R5RS as this evaluation (no evaluation at all) is not a choice from the set of all possible evaluation orders (this set does not contain the "no evaluation at all" option)
13:03:39 <byorgey> dmead: oh!  ok, I am definitely confusing you with someone else, sorry =)
13:04:06 <byorgey> ah, it was a different Dan
13:04:27 <dmead> ah
13:04:33 <byorgey> I guess we have not actually met
13:04:40 <dmead> i suppose so
13:05:00 <byorgey> well, hopefully that will change =)
13:05:07 <dmead> philly lambda started having meetings at upenn last month
13:05:10 <dmead> so probably, yea
13:05:20 <MadHatterDude> Hmm.. How to generalize "newtype Parser a b = Parser (a -> ParseResultMonad (b, [a]))" into an arrow...
13:05:36 <byorgey> yeah, I came to one philly lambda meeting, but haven't been able to come to more recent ones
13:05:50 <Axman6> @src Arrow
13:05:50 <lambdabot> class Arrow a where
13:05:51 <lambdabot>     arr, pure   :: (b -> c) -> a b c
13:05:51 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
13:05:51 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
13:05:51 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
13:05:52 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
13:05:54 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
13:06:20 <edwardk> therp: i agree with the statement that 'no evaluation at all' is not valid there. it has been a long time since this was brought to my attention. the person in question pointed out there was a middle ground, which now that i reflect on it isn't quite call-by-name.
13:06:32 <byorgey> MadHatterDude: what's the [a] for?
13:06:37 <MadHatterDude> Axman6: Arrows are like Monads but awesomer, and they mock me by their very existence...
13:06:57 <Axman6> i know. just make things that match the types needed
13:06:58 <MadHatterDude> byorgey: Why, the rest of the input, of course?
13:07:29 <edwardk> at the time i dismissed all of this nonsense as more of an intellectual curiosity than a practical concern.
13:07:38 <byorgey> hmm... well, you could make it into an Arrow if you ignore the leftover inputs when composing
13:07:41 <byorgey> but that seems strange
13:07:57 <MadHatterDude> byorgey: yeah...
13:08:02 <therp> edwardk: at least all the semantics I have seen evaluate -- although no order defined -- the arguments before dispatching the call to the function..
13:08:14 <therp> edwardk: isn't that the whole purpose this channel? :) I like it
13:08:18 <MadHatterDude> byorgey: I don't think its trivial to generalize Monadic parser into Arrows.
13:08:33 <edwardk> therp: sure, that is the common interpretation, after all ;)
13:09:01 <edwardk> therp: and barzilay's lazy scheme takes other liberties that make it fall outside of r5rs anyways
13:10:59 <therp> edwardk: I'd imagine that lazy scheme is not that easy to master
13:11:15 <edwardk> therp: it is a pain in the ass actually ;)
13:11:19 <CBro2007> MadHatterDude: damn he doesn't show the screens
13:11:39 <edwardk> therp: i was using a lazy scheme-like language as an intermediate language for a while.
13:11:39 <CBro2007> MadHatterDude: he is constantly focussing on the talker in the video :(
13:11:52 <MadHatterDude> CBro: Use the pdf
13:12:12 <MadHatterDude> CBro: Open it in another window and read it while he talks...
13:12:17 <edwardk> was using the tongue in cheek name 'pyramid scheme' for it ;)
13:12:27 <MadHatterDude> CBro: It's available i nthe link I gave you.
13:12:39 <CBro2007> ok
13:12:43 <CBro2007> sucks
13:12:44 <CBro2007> though
13:12:46 <CBro2007> :)
13:14:46 <therp> sorry, I don't get it, pyramid scheme? the only connotation I have is with pyramid games.. (non-native speaker here)
13:15:09 <edwardk> therp: http://en.wikipedia.org/wiki/Pyramid_scheme
13:15:18 <therp> ah! :)
13:15:22 <therp> now I get it.. thanks :)
13:16:04 <edwardk> it eventually started evolving a static type system though, so it stopped feeling like a scheme
13:21:16 <sinelaw> argh, my laptop tried to commit suicide
13:21:31 <sinelaw> and then wasted 10 minutes fdsiking itself
13:21:55 <FauxFaux> If you unplug the mains it'll generally skip the fdisk.
13:22:02 <FauxFaux> That's the only reason laptops have batteries these days.
13:22:31 <sinelaw> it just went to 100% cpu for no reason and stopped responding to any input
13:22:39 <sinelaw> weird, never happened before
13:22:52 <therp> hmm GHC 6.12.2 panics again where GHC 6.12.1 didn't. I should stop using the GHC API and start my own language..
13:24:34 <Heffalump> is 6.12.2 out?
13:25:16 <roboshibby> is haskell named after eddie haskell?
13:25:21 <copumpkin> nope
13:25:25 <copumpkin> it's named after haskell curry
13:25:28 <roboshibby> it should be
13:25:40 <roboshibby> wait, there's a kind of curry i haven't ate yet?
13:25:42 <copumpkin> the logician was a little more influential in our field
13:26:04 <roboshibby> oh well pardon me queen of england
13:26:14 * roboshibby genuflecs
13:26:14 * sinelaw 's existentials are escaping!!
13:26:26 <copumpkin> sinelaw: damn, lock them in!
13:26:40 <sinelaw> copumpkin, and they're less polymorphic than expected
13:27:15 <sinelaw> GADT's to the rescue!
13:27:35 <blackh> roboshibby: "Currying" was named after the popular takeaway food, however
13:29:37 <sinelaw> they should have called it "yechezkel"
13:30:35 <DBAlex> Hey
13:30:41 <DBAlex> what sort of pattern is this:
13:30:43 <DBAlex> *Main> multiples $ multiples $ multiples [6]
13:30:47 <DBAlex> [6,12,18,24]
13:30:49 <DBAlex> can't define it using map ...
13:30:53 <DBAlex> is it a fold?
13:31:05 <copumpkin> DBAlex: huh?
13:31:06 <c_wraith> An unfold or an iterate?
13:31:23 <c_wraith> but really, what does "multiples" do?
13:31:50 <copumpkin> :t appEndo . foldMap Endo . replicate 3
13:31:51 <DBAlex> takes a list and adds a new item with the first element added to the last element
13:31:51 <lambdabot> Not in scope: `foldMap'
13:31:58 <copumpkin> :t appEndo . Data.Foldable.foldMap Endo . replicate 3
13:31:59 <lambdabot> forall a. (a -> a) -> a -> a
13:32:06 <Taejo> :t intercalate
13:32:07 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:32:25 <DBAlex> :t iterate
13:32:26 <lambdabot> forall a. (a -> a) -> a -> [a]
13:33:40 <ivanm> DBAlex: foldr (.) id (replicate 3 multiples) ? :p
13:34:09 <copumpkin> mine is cuter
13:34:16 <ivanm> there, don't need no stinkin' endo garbage!
13:34:33 <DBAlex> maybe i'm overcomplicating it
13:34:35 <ivanm> @type foldr (.) id . replicate 3
13:34:36 <lambdabot> forall b. (b -> b) -> b -> b
13:35:56 <DBAlex> *Main> take 10 (iterate multiples [6])
13:35:56 <DBAlex> [[6],[6,12],[6,12,18],[6,12,18,24],[6,12,18,24,30],[6,12,18,24,30,36],[6,12,18,24,30,36,42],[6,12,18,24,30,36,42,48],[6
13:35:56 <DBAlex> 12,18,24,30,36,42,48,54],[6,12,18,24,30,36,42,48,54,60]]
13:36:00 <DBAlex> well, that works :)
13:36:36 <copumpkin> surely there's a better way of computing multiples though ;)
13:36:51 <aavogt> @check \n -> take 10 (iterate multiples [n]) == take 10 (iterate (n+) n)
13:36:52 <lambdabot>   Not in scope: `multiples'
13:37:28 <ivanm> yeah, you'd want to do it in a single pass with an infinite list, not appending one on the end each time
13:37:54 <DBAlex> *Main> take 10 (iterate (+6) 6)
13:37:54 <DBAlex> [6,12,18,24,30,36,42,48,54,60]
13:37:55 <DBAlex> Lol
13:38:00 <ivanm> @type (\ n -> fix (n+) n)
13:38:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> t
13:38:02 <lambdabot>     Probable cause: `fix' is applied to too many arguments
13:38:02 <lambdabot>     In the expression: fix (n +) n
13:38:04 <DBAlex> I *was* over-complicating it
13:38:11 <DBAlex> it's not perfect, but not bad :)
13:38:19 <ivanm> @type (\ n -> fix (n+))
13:38:20 <lambdabot> forall a. (Num a) => a -> a
13:38:29 <copumpkin> failivanm
13:38:31 <ivanm> no, wait, that won't create a list
13:38:36 <aavogt> > inits (iterate (+6) 6)
13:38:37 <lambdabot>   [[],[6],[6,12],[6,12,18],[6,12,18,24],[6,12,18,24,30],[6,12,18,24,30,36],[6...
13:38:38 <ivanm> duh, iterate
13:38:40 <DBAlex> @take 10 (iterate (+6) 6)
13:38:40 <lambdabot> Maybe you meant: time type
13:38:47 <DBAlex> how do I execute code?
13:38:50 <DBAlex> > take 10 (iterate (+6) 6)
13:38:51 <lambdabot>   [6,12,18,24,30,36,42,48,54,60]
13:38:53 <ivanm> DBAlex: let's golf it!
13:38:59 <DBAlex> woot!
13:39:06 <DBAlex> well, i'm happy with mine
13:39:13 <ivanm> > flip iterate 0 . (+) $ 6
13:39:14 <lambdabot>   [0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,1...
13:39:15 <DBAlex> I'm sure it's wrong in a heck of a lot of ways, but meh :)
13:39:17 <copumpkin> > let multiples n = n : map (n+) (multiples n) in multiples 6
13:39:18 <lambdabot>   [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138...
13:39:21 <ivanm> > tail . flip iterate 0 . (+) $ 6
13:39:22 <lambdabot>   [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138...
13:39:24 <aavogt> > take 10 $ (iterate =<< (+)) 6
13:39:25 <lambdabot>   [6,12,18,24,30,36,42,48,54,60]
13:39:25 <ivanm> \o/
13:39:36 <ivanm> aavogt: oooohhh....
13:39:37 <copumpkin> > fix (\multiples n -> n : map (n+) (multiples n)) 6
13:39:38 <lambdabot>   [6,12,18,24,30,36,42,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138...
13:39:44 <ivanm> isn't that join in there though?
13:39:46 <DBAlex> what's the most efficient way ?
13:39:54 <DBAlex> or do I just let GHC work it's magic...
13:39:55 <DBAlex> :P
13:40:00 <ivanm> DBAlex: *shrug* using iterate is good enough
13:40:04 <DBAlex> ok
13:40:07 <aavogt> > take 10 . ap iterate (+) $ 6
13:40:08 <lambdabot>   Occurs check: cannot construct the infinite type:
13:40:09 <lambdabot>    a = (a -> a) -> a -> a
13:40:16 <copumpkin> iterate is fine unless you want to skip ahead
13:40:37 <aavogt> > take 10 . ap (flip iterate) (+) $ 6
13:40:40 <lambdabot>   [6,12,18,24,30,36,42,48,54,60]
13:40:44 <copumpkin> > iterate (+6) 6 !! 10000
13:40:45 <lambdabot>   60006
13:40:48 <copumpkin> > iterate (+6) 6 !! 1000000
13:40:49 <lambdabot>   * Exception: stack overflow
13:40:54 <ivanm> heh
13:41:01 <ivanm> copumpkin: so it works for OVER 9000!
13:41:02 <aavogt> there are more efficient ways to multiply
13:41:06 <copumpkin> yep :)
13:41:24 <DBAlex> btw I'm writing lcm in haskell
13:41:26 <aavogt> @src (^)
13:41:27 <lambdabot> x ^ 0            =  1
13:41:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:41:27 <lambdabot>   where f _ 0 y = y
13:41:27 <lambdabot>         f x n y = g x n
13:41:27 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:41:28 <telephone> is hpaste.org down forever?
13:41:29 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:41:31 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:41:33 <copumpkin> > lcm 6 13
13:41:35 <lambdabot>   78
13:41:46 <DBAlex> I'm getting paranoid by all these articles I keep reading about questions they ask graduates for jobs...
13:41:53 <aavogt> @let lcd _ _ = 1
13:41:54 <lambdabot>  Defined.
13:41:59 <copumpkin> lol
13:41:59 <CBro2007> MadHatterDude: you still around?
13:42:01 <DBAlex> maybe if I answer them in Haskell they might realise I can program ? :)
13:42:06 <ivanm> aavogt: heh
13:42:11 <copumpkin> ivanm: heh
13:42:15 <ivanm> @slap copumpkin
13:42:15 * lambdabot pokes copumpkin in the eye
13:42:19 <FauxFaux> DBAlex: Explain a time when you demonstrated EXCEPTIONAL LEADERSHIP ABILITIES.
13:42:19 <copumpkin> :(
13:42:33 <DBAlex> FauxFaux: lol
13:42:44 <DBAlex> FauxFaux: When I was born!
13:42:57 <DBAlex> I was calling the shots...
13:42:58 <stevenmarky> lol good answer
13:43:00 <FauxFaux> DBAlex: I know this is a job for programming in basic, but I think it's important for you to be able to REVERSE THIS LINKED LIST IN PLACE.
13:43:43 <MadHatterDude> CBro: Yes?
13:43:44 <DBAlex> FauxFaux: Hehe
13:44:00 <DBAlex> I think the problem is codinghorror etc
13:44:06 <DBAlex> you start telling yourself you can't program...
13:44:14 <DBAlex> it's a slipperly slope ...
13:44:18 <DBAlex> *slippery
13:44:30 <medfly> DBAlex, don't get creeped out. come in confident. maximise your chances by trying a lot of places until you find somewhere that is willing to give you soem experience.
13:44:34 <medfly> that's what I should be doing
13:44:45 <sinelaw> @slap 'em all
13:44:45 * lambdabot throws some pointy lambdas at 'em all
13:44:51 <ivanm> FauxFaux: well, you can't do that in haskell *shrug*
13:44:58 <stevenmarky> heh.
13:45:02 <aavogt> ivanm: you have to here http://www.md.chalmers.se/~rjmh/Combinators/fingers.html
13:45:26 <ivanm> aavogt: "in place" though?
13:45:35 <aavogt> for real
13:45:35 <DBAlex> medfly: yeah, well, I'm still in my 2nd year, but I'm just sort of trying to prepare
13:45:40 <ivanm> oh, it does
13:45:50 <ivanm> aavogt: it's not a real Haskell list though...
13:45:51 <medfly> DBAlex, does that mean you're trying to find a job
13:45:52 <DBAlex> I know, I have ages... well, gotta start sometime
13:45:54 <ivanm> so it doesn't count!
13:45:57 <medfly> isn't 2nd year when students begin to work :p
13:45:58 <telephone> http://pastebin.ca/1832531 <-- how should I solve this?
13:46:10 <ivanm> and it's in evil, evil IO! :o
13:46:13 <DBAlex> medfly: no... but I want to try and get ahead of everyone else :-D
13:46:14 * ivanm heads off to uni
13:46:31 <Cale> telephone: ghc-pkg hide transformers
13:46:46 <Cale> telephone: (at the commandline)
13:47:01 <DBAlex> maybe I can get some experience this summer...
13:47:04 <DBAlex> :D
13:47:13 <DBAlex> anyone here done GSOC?
13:47:32 <telephone> Cale: ok. Is 'transformers' newer than mtl??
13:47:41 <ahf> DBAlex: i was a mentor some years ago.
13:47:47 <ahf> why?
13:47:55 <Cale> Yes, but it's not technologically newer
13:47:58 <DBAlex> ahf: nice...! Is it worth applying? I'm a 2nd year CS student...
13:48:03 <ahf> yes, it is
13:48:05 <krankkatze`> Alpounet: haven't you done gsoc last year?
13:48:06 <danderson> yes, it is
13:48:11 <ahf> i was in first year high school when i was a mentor!
13:48:11 <DBAlex> ahf: am I too late?
13:48:21 <ahf> no, the projects need to sent in their proposals firstly
13:48:23 <ahf> then you can apply
13:48:27 <danderson> (I'm a former GSoC student, mentor, and now random aide on the organization side :)
13:48:33 <DBAlex> ok, when does that happen ahf?
13:48:35 <aavogt> you can help with the proposals, no?
13:48:38 <ahf> tomorrow i think
13:48:40 <Alpounet> krankkatze`, nope
13:48:43 <Cale> (the code is essentially the same, last I checked, it's just split up across a few packages, to solve certain packaging problems)
13:48:44 <krankkatze`> ok sry
13:48:46 <ahf> dunno, danderson probably knows better
13:48:51 <danderson> so
13:48:57 <danderson> if Haskell hasn't applied to GSoC yet
13:49:01 <danderson> it needs to happen soon
13:49:05 <ahf> i think we're fairly busy in exherbo getting everything ready
13:49:13 <DBAlex> cool
13:49:13 <sinelaw> ok, GADT question here. data MyGADT a where Blah :: (a -> x) -> MyGADT a    <--- isn't this a problem?
13:49:20 <danderson> (getting the data on when, I don't have the dates in mind)
13:49:22 <ahf> mmmmm
13:49:23 <DBAlex> can you work on Haskell stuff for GSoC?
13:49:26 <ahf> wonder if irssi should apply
13:49:27 <Cale> sinelaw: why would it be?
13:49:34 <sinelaw> Cale, consider this:
13:49:55 <sinelaw> myFunc (Blah f) = f
13:50:02 <danderson> oh for Pete's sake
13:50:04 <danderson> browser crapping out.
13:50:05 <Cale> That will be a type error
13:50:11 <sinelaw> why?
13:50:18 <Heffalump> because 'x' will "escape"
13:50:19 <Cale> Because the type of f is unknown.
13:50:20 <danderson> Anyway, the deadline for organizations applying to participate in GSoC is at http://socghop.appspot.com/document/show/gsoc_program/google/gsoc2010/faqs#timeline
13:50:27 <sinelaw> Heffalump, exactly.
13:50:27 <Cale> Well, the complete type.
13:50:41 <sinelaw> Cale, so why am i even allowed to build such GADTs?
13:50:52 <levente_meszaros> I don't want to sound like trolling, but seriously how would you implement this function in haskell?
13:50:55 <levente_meszaros> Returns a list containing the results of calling FUNCTION with one argument from LIST, and one from each of MORE-LISTS for each combination of arguments. In other words, returns the product of LIST and MORE-LISTS using FUNCTION.
13:50:57 <danderson> and I'd encourage Haskell projects (or indeed Haskell.org in general as an umbrella org) to apply if it's not already done.
13:51:08 <Cale> sinelaw: Because sometimes it's useful to forget the type of something and only remember, say, the classes it belongs to, or related functions stored alongside it.
13:51:14 <danderson> levente_meszaros: list monad
13:51:18 <levente_meszaros> (map-product 'list '(1 a) '(3 b)) -> ((1 3) (1 B) (A 3) (A B))
13:51:30 <levente_meszaros> and what would be the type of that function?
13:51:32 <sinelaw> levente_meszaros, try #lisp or #scheme
13:51:35 <danderson> or with a list comprehension
13:51:35 <benmachine> levente_meszaros: are there a fixed number of MORE-LISTS
13:51:37 <Cale> sinelaw: Consider something like   data Foo where F :: [a] -> (a -> Integer) -> (a -> String) -> Foo
13:51:38 <copumpkin> sinelaw: or even forget the type of something with no typeclasses attached!
13:51:42 <benmachine> sinelaw: ref. "in haskell"
13:51:48 <levente_meszaros> benmachine, no
13:52:11 <benmachine> hmm
13:52:21 <Cale> sinelaw: Thus, a value of type Foo is a list of values of an unknown type, together with a way to turn any of those values into a String or an Integer
13:52:33 <Cale> Then we could write:
13:52:39 <sinelaw> hmm
13:52:46 <benmachine> levente_meszaros: function <$> list1 <*> list2 <*> list3 -- would probably do the right sort of thing
13:52:54 <Cale> integers (F xs i s) = map i xs
13:53:01 <Cale> integers :: Foo -> [Integer]
13:53:11 <benmachine> that's actually three function calls but it looks pretty so we don't mind
13:53:13 <DBAlex> danderson: ok thanks!
13:53:34 <levente_meszaros> benmachine, hmm I need to look up what's <$> and <*>
13:53:39 <levente_meszaros> where do I do that?
13:53:58 <benmachine> levente_meszaros: do you know what Applicative is?
13:53:58 <sinelaw> hoogle
13:54:20 <levente_meszaros> benmachine, not by its name
13:54:36 <sinelaw> Cale, ok
13:54:38 <benmachine> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html this is where the docs for <$> and <*> live, but they might not be much good unless you already know what they do :P
13:55:00 <mreh> could someone suggest why StdGen is giving me slightly negative floats?
13:55:01 <sinelaw> Cale, thanks. now i have to re-think my module.
13:55:04 <sinelaw> :)
13:55:15 <mreh> the range I'm using is (0, positive-bar)
13:55:31 <danderson> for Applicative, I heartily recommend the Typeclassopaedia article in one of the issues of the Monad Reader
13:55:35 <benmachine> levente_meszaros: basically, function <$> list1 is the same as map function list1; if function is binary then the result will be a list of functions
13:56:08 <benmachine> then listoffunctions <*> list2 will take each function from listoffunctions in turn and apply it to each value in list2, concatenating the result
13:56:24 <benmachine> > (+) <$> [1,2,3,4] <*> [5,6,7,8]
13:56:25 <lambdabot>   [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
13:56:59 * levente_meszaros understanding
13:57:11 <benmachine> that's the very brief explanation of how <$> and <*> works on lists
13:57:15 <tensorpudding> so many prelude functions seem to do nearly what i want, but not, so i end up replicating them almost exactly
13:57:33 <sinelaw> Cale, can i do something like: data Foo a c where F :: (a -> b) -> (b -> c) -> F a c
13:57:35 <benmachine> of course they are part of a typeclass so they work on other things too, in different ways
13:57:37 <telephone> I get ambiguous occurence for a function 'get'. Module A contains 'get'. Module B contains 'get', but this is imported "qualified as".
13:58:00 <mreh> do floats wrap round when they get really really tiny?
13:58:01 <Cale> sinelaw: You could, though in that form, you might as well just use (a -> c)
13:58:01 <danderson> tensorpudding: expand the search to some base libs
13:58:14 <Cale> sinelaw: since the values of type b will never be observable
13:58:15 <danderson> personally I always peruse Control.Applicative and Control.Monad as well
13:58:19 <sinelaw> Cale, and then: f (F toB toC) a = toC . toB $ a
13:58:20 <benmachine> mreh: no
13:58:24 <danderson> it often happens that the function I want lives there
13:58:33 <Cale> sinelaw: yes, that's valid
13:58:34 <mreh> this is just bizzare
13:58:41 <telephone> when typing 'get', I mean A.get, but I get ambiguous occurence.
13:58:57 <sinelaw> Cale, ok. i want something like that but in a monad (e.g. IO)
13:59:03 <tensorpudding> @src break
13:59:03 <lambdabot> break p =  span (not . p)
13:59:17 <edwardk> sinelaw: F :: forall b. (a -> b) -> (b -> c) -> F a c -- but since types have an implicit 'forall', you just write what you wrote. that is the way GADTs make a lot of use of explicit existentials syntactically nicer. you're just giving the type of the constructors
13:59:26 <MadHatterDude> Grr...
13:59:28 <benmachine> telephone: it shouldn't be ambiguous if you have qualified in there, maybe it's conflicting with something else? does GHC tell you the conflict is from B?
13:59:29 <Cale> sinelaw: Ah, there it might be useful
13:59:30 <sinelaw> do ; b <- actionB a ; c <- actionC b ; return c
13:59:34 <sinelaw> Cale, like that
13:59:53 <Cale> data Foo a c where F :: (a -> IO b) -> (b -> IO c) -> Foo a c
14:00:08 <sinelaw> edwardk, yeah i'm beginning to understand
14:00:18 <Cale> It's like a composite function which comes in two parts, so you can do something else in between if you want.
14:00:19 <sinelaw> Cale, yeah
14:00:27 <Cale> I'm not sure what you'd use that for...
14:00:33 <Cale> But it at least is nontrivial :)
14:00:39 <sinelaw> Cale, allocation, processing, deallocation
14:00:53 <Cale> Oh, the standard way to handle that is just to use a function...
14:00:57 <benmachine> sinelaw: except that you can't get the b in the middle
14:01:08 <copumpkin> @ask ezyang if you don't have time to find out about holding a HUG at the usual place, do you know of any other haskellers at MIT who might be interested in organizing it?
14:01:08 <lambdabot> Consider it noted.
14:01:09 <edwardk> cale: he has a bunch of initializers, and processing routines that have some form of intermediate state. he wants to be able to batch up initialization, then processing, then deallocation should he chain them together
14:01:12 <jmcarthur> good grief i wish a function prototype in C could give me the same amount of information that a type signature in haskell can give me
14:01:14 <sinelaw> where composition of Foos means allocating all, processing all, deallocating all
14:01:35 <DBAlex> hmm
14:01:48 <DBAlex> does Haskell have something like Python's In keyword?
14:01:48 <Cale> edwardk: yeah, the CPS-style still works okay for that, particularly if you write a handful of combinators
14:01:57 <edwardk> sure
14:01:59 <benmachine> DBAlex: implemented as functions
14:02:00 <copumpkin> CP style?
14:02:03 <jmcarthur> int foo(struct bar *b, struct baz *c)  is just not as informative as, say,  Bar -> Baz -> Bool
14:02:04 <edwardk> that was where i was stearing him =)
14:02:11 <edwardk> copumpkin: =P
14:02:12 <benmachine> :t (elem, M.elem)
14:02:12 <DBAlex> benmachine: um, ok
14:02:13 <lambdabot> Couldn't find qualified module.
14:02:17 <benmachine> oh
14:02:17 <DBAlex> elem
14:02:17 <copumpkin> :)
14:02:21 <Cale> yeah, CP-style, I suppose it should be
14:02:21 <DBAlex> > :t elem
14:02:22 <lambdabot>   <no location info>: parse error on input `:'
14:02:25 <benmachine> :t elem
14:02:26 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:02:27 <sinelaw> edwardk, am i in the right direction now? :)
14:02:29 <edwardk> we're from the department of redundancy department =P
14:02:31 <MadHatterDude> Cale: Lol, you said "Contrinuation passing style-style"
14:02:38 <benmachine> @type Data.Map.elem
14:02:39 <lambdabot> Not in scope: `Data.Map.elem'
14:02:39 <edwardk> sinelaw: appreciably the same unless that is your only constructor ;)
14:02:41 <benmachine> oh
14:02:45 <DBAlex> ah nice
14:02:48 <telephone> benmachine: I see the problem now. import A, import qualified B as ..., import C. B was exporting get from C, which is not qualified imported.
14:02:50 <Cale> MadHatterDude: I'd already noticed.
14:02:51 <mreh> my ants crawl around so fast they pause for the GC :D
14:02:52 <DBAlex> > elem 'a' ['a','b']
14:02:53 <lambdabot>   True
14:02:56 <DBAlex> :)
14:03:11 <jmcarthur> i mean, i guess the signature could still theoretically be  Ptr Bar -> Ptr Baz -> IO Int, but that's not common haskell code, especially when the function could otherwise be pure
14:03:11 <telephone> thank you all
14:03:18 * DBAlex probably needs to study the standard library (I'm repeating myself, I've said this before)
14:03:41 <DBAlex> I still think the prelude should have some more string ops.. like string trim etc
14:03:53 <DBAlex> *functions
14:03:55 <jmcarthur> trim?
14:03:57 <jmcarthur> does what?
14:04:14 <DBAlex> trims whitespace/tabs/blah from front & end of string
14:04:15 <sinelaw> edwardk, then i'm missing something here :(
14:04:21 <DBAlex> also, ltrim, rtrim
14:04:21 <jmcarthur> you could always look in Data.List or the split package
14:04:28 <benmachine> trimming from the front is easy
14:04:31 <DBAlex> yeah but it should be standard
14:04:31 <jmcarthur> oh, so like perl's chomp?
14:04:33 * Cale hopes that the 5.42 volts on the 5V rail of his powersupply aren't damaging his machine too badly before he can install a new powersupply.
14:04:34 <DBAlex> I don't need these!
14:04:38 <DBAlex> I can define them easily
14:04:38 <dobblego> DBAlex, it shouldn't have that; it should be on Data.Sequence if anything
14:04:42 <DBAlex> I just wish they were standard!
14:04:50 <sinelaw> Cale, use a voltage divider? :)
14:05:00 <DBAlex> hmm, ok
14:05:34 <sinelaw> actually, maybe i'm not.
14:05:49 <sinelaw> nope, i am.
14:05:51 <sinelaw> :(
14:06:25 <Cale> I've also seen the voltage sensor spike to 6.4V intermittently, which was rather disconcerting.
14:07:17 <DBAlex> Cale: what spec is your PC?
14:07:25 <DBAlex> (Just curious..)
14:07:53 <Cale> DBAlex: Just an aging P4 2.4 GHz machine.
14:07:59 <DBAlex> ahh
14:08:04 <edwardk> sinelaw: straw man your earlier paste rewrites to something like: data P m a b o where P :: (a -> m x) -> (a -> x -> m o) -> (x -> b) -> (x -> m ()) -> P m a b o; C :: P a b o' -> P b c o -> P a c o; ... -- by getting tupling up (b,x) and just calling it x with a projection function to regain b.
14:08:12 <DBAlex> With Hyperthreading?
14:08:24 <DBAlex> Never was a fan of the P4, but the hyperthreading seemed cool
14:08:24 <Cale> DBAlex: yes, though I'm not sure if it's turned on.
14:08:37 <DBAlex> ok
14:08:42 <DBAlex> A64 > P4
14:08:43 <edwardk> er by just tupling up
14:08:49 <DBAlex> :P
14:09:01 <sinelaw> edwardk, ok my code already happens to resemble that
14:09:03 <DBAlex> But C2D > A64 > P4...
14:09:07 <sinelaw> so i wasn't far off :)
14:09:13 <DBAlex> and i7 > All
14:09:17 <DBAlex> pretty much :(
14:09:18 <Cale> We recently had a power outage which knocked out my powersupply, and I borrowed one from my dad's old machine, but it seems to be rather unreliable as well.
14:09:20 <edwardk> sinelaw: yeah thats why i was using it as a starting point
14:09:23 <sinelaw> actually those two lines are exactly what i just wrote
14:09:44 <DBAlex> ok
14:10:08 <sinelaw> edwardk, wait no. why (x -> b) and (x -> m())
14:10:10 <edwardk> what i'd shoot for would be an encoding that added fields to P to enable you to define chain more intelligently
14:10:30 <sinelaw> ah ok
14:10:33 <edwardk> sinelaw: because you manually tuple and untuple (x,b) in 3 places
14:10:39 <sinelaw> yeah
14:10:41 <sinelaw> i see
14:10:50 <edwardk> but only really need to do so once
14:11:04 <edwardk> and that is in the one place where you actually just want b
14:11:07 <sinelaw> ok great i'll keep trying :)
14:11:21 <edwardk> so with the above
14:11:37 <edwardk> you should be able to define chain in such a fashion that chain returns a P not a 'C'
14:11:51 <edwardk> and thereby eliminate the need for 'C' as a constructor at all
14:12:16 <sinelaw> i think first i'll try to get it with C as a constructor
14:12:17 <Cale> sinelaw: So, why not use functions of the form  withResource :: (Resource -> IO a) -> IO a
14:12:30 <sinelaw> Cale, i was considering that too right now
14:12:50 <sinelaw> i'm spiraling in to something :)
14:13:11 <sinelaw> thanks for the help
14:13:40 <sinelaw> i have a feeling i'll end with a something that starts with: class Monad where ... :)
14:13:51 <Cale> sinelaw: You can define some ways of combining such functions -- in fact, this is one of the main nice applications of the Cont monad. You can steal a lot of goodies from Control.Monad by wrapping things with the Cont constructor, applying some monadic stuff, and then runCont
14:13:56 <DBAlex> > let in' = elem in 1 `in'` [1,2,3]
14:13:57 <lambdabot>   True
14:13:59 <DBAlex> hehe :)
14:14:17 <Cale> @src Cont
14:14:18 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:14:25 <Cale> ^^ note the similarity
14:14:30 <sinelaw> Cale, sure, i'll look at it, but after i'm done. this way i learn a lot more
14:15:02 <sinelaw> and appreciate things that already exist a lot more too
14:15:35 <edwardk> sinelaw: what i mean was something like: chain (P alloc process project release) (P alloc' process' project' release') = P alloc'' process'' project'' release'' where alloc'' = (,) <$> alloc <*> alloc'; process'' = ..
14:15:37 <Cale> :t Foreign.Marshal.Pointer.alloca
14:15:38 <lambdabot> Couldn't find qualified module.
14:15:46 <Cale> :t Foreign.Marshal.Alloc.alloca
14:15:47 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
14:15:54 <Cale> :t Cont Foreign.Marshal.Alloc.alloca
14:15:55 <lambdabot> forall a b. (Foreign.Storable.Storable a) => Cont (IO b) (GHC.Ptr.Ptr a)
14:16:10 <Cale> :t replicateM 10 (Cont Foreign.Marshal.Alloc.alloca)
14:16:11 <lambdabot> forall a b. (Foreign.Storable.Storable a) => Cont (IO b) [GHC.Ptr.Ptr a]
14:16:15 <sinelaw> Cale, yeah i know about alloca
14:16:46 <Cale> :t runCont (replicateM 10 (Cont Foreign.Marshal.Alloc.alloca)) id
14:16:46 <sinelaw> that's specific though
14:16:47 <lambdabot>     Couldn't match expected type `IO b'
14:16:47 <lambdabot>            against inferred type `[GHC.Ptr.Ptr a]'
14:16:47 <lambdabot>     In the second argument of `runCont', namely `id'
14:16:50 <Cale> er
14:17:01 <MadHatterDude> I'd love some sake right now...
14:17:22 <sinelaw> edwardk, cool i'll refer to that after i'm done trying it in my own primitive way :)
14:17:41 <Cale> right...
14:17:44 <Cale> :t runCont (replicateM 10 (Cont Foreign.Marshal.Alloc.alloca)) return
14:17:45 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO [GHC.Ptr.Ptr a]
14:18:59 <edwardk> sinelaw: unrestricting the shape of (x,b) like I did, by defining its own projection is important to making that actually work
14:19:05 <Cale> :t let nest = (`runCont` return) . sequence . Cont in nest [Foreign.Marshall.Alloc.alloca,Foreign.Marshall.Alloc.allocaForeign.Marshall.Alloc.alloca]
14:19:06 <lambdabot> Couldn't find qualified module.
14:19:12 <Cale> blah
14:19:17 <Cale> :t let nest = (`runCont` return) . sequence . Cont in nest [Foreign.Marshall.Alloc.alloca,Foreign.Marshall.Alloc.alloca,Foreign.Marshall.Alloc.alloca]
14:19:18 <lambdabot> Couldn't find qualified module.
14:19:28 <Cale> ugh, typos :)
14:19:37 <Cale> :t let nest = (`runCont` return) . sequence . Cont in nest [Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca]
14:19:38 <lambdabot>     Couldn't match expected type `[Cont (m [a]) a]'
14:19:38 <lambdabot>            against inferred type `Cont r a1'
14:19:38 <lambdabot>       Expected type: ((a1 -> r) -> r) -> [Cont (m [a]) a]
14:19:54 <Cale> hmm
14:20:10 <Cale> oh, need to map Cont
14:20:14 <Cale> :t let nest = (`runCont` return) . sequence . map Cont in nest [Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca]
14:20:15 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO [GHC.Ptr.Ptr a]
14:20:48 <Cale> There we are, a nice function for taking a list of similarly-typed resource allocators, and nesting them
14:20:52 <sinelaw> edwardk, i can't see why right now, but i want to try to get a working version first, then i'll be back
14:21:12 <metaperl> How come [a] is not accepted by my parameterized type - http://pastie.org/pastes/864065
14:21:28 <Cale> er, is this really the program I wanted to write?
14:21:35 * Cale thinks about it...
14:21:40 <sinelaw> Cale, i don't know :)
14:21:51 <dobblego> metaperl, the type argument 'a' is not defined
14:22:07 <Cale> oh, right, it's not
14:22:16 <Cale> :t let nest = runCont . sequence . map Cont in nest [Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca,Foreign.Marshal.Alloc.alloca]
14:22:17 <lambdabot> forall a b. (Foreign.Storable.Storable a) => ([GHC.Ptr.Ptr a] -> IO b) -> IO b
14:22:18 <edwardk> sinelaw: your earlier statement about getting something of the form (x,(y,b)) instead of what you needed
14:22:24 <Cale> *that's* the program I wanted :)
14:22:45 <DBAlex> lulz ghc ate 2gb
14:22:47 <DBAlex> :(
14:22:54 <dobblego> metaperl, profList is wrong also: ListProfile xs $ length xs
14:22:58 <DBAlex> now my laptop iz slowz0rz
14:23:10 <DBAlex> don't build infinite lists :x
14:23:23 <c_wraith> > head [1..]
14:23:24 <lambdabot>   1
14:23:32 <c_wraith> I can use infinite lists for anything!
14:23:38 <c_wraith> > head [()..]
14:23:39 <lambdabot>   ()
14:23:48 <Cale> > [()..]
14:23:49 <lambdabot>   [()]
14:24:04 <metaperl> dobblego: I'm saying the list can be of any type. That's why I used [a]
14:24:13 <c_wraith> > [(), ()..]
14:24:14 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
14:24:17 <companion_cube> > take 42 [1..]
14:24:18 <c_wraith> ok, there we go
14:24:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:24:29 <dobblego> metaperl, data ListProfile a
14:24:39 <Cale> metaperl: So, you just want to forget the type of the elements of the list, and all the permissions to inspect the elements that would imply?
14:25:22 <Cale> metaperl: If something could be of any type at all, your program is not allowed to inspect it in any way.
14:25:56 <Cale> metaperl: dobblego's answer is probably the one that you're really looking for
14:25:58 <metaperl> yeah, I need a deriving show
14:26:41 <Cale> also worth noting, you seem to be missing some parens around (length xs) in the definition of profList
14:26:47 <gwern> Kagami`: if you don't already know @flesh, maybe you're young enough I oughtn't explain it
14:28:01 <metaperl> ok, it works now. Thanks - http://pastie.org/pastes/864085
14:28:07 <c_wraith> @check \x -> (x :: String) == head . repeat $ x
14:28:08 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:30:09 <sinelaw> @flush
14:30:10 <lambdabot> Not enough privileges
14:30:16 <sinelaw> @quote psychobot
14:30:16 <lambdabot> psychobot says: gisteneralize thready studentirely
14:30:24 * sinelaw agrees
14:31:39 <DBAlex> hmm, whats a good pastebin?
14:31:43 <DBAlex> hpaste is down
14:32:02 <mauke> DBAlex: it's dangerous to go alone; take this: http://mauke.ath.cx/stuff/perl/pastebin
14:32:12 <mauke> run with --help to see a list of pastebins
14:32:28 * ivanm uses wgetpaste
14:32:38 <sinelaw> DBAlex, http://moonpatio.com/
14:32:39 <dmead> hey guys
14:32:43 <sinelaw> yo
14:32:46 <DBAlex> sinelaw: ok
14:32:50 <dpiponi> @free a->a
14:32:50 <lambdabot> Extra stuff at end of line
14:32:52 <dmead> anyone know how to describe optional spaces in parsec?
14:32:56 <fax> @free id :: a -> a
14:32:57 <lambdabot> f . id = id . f
14:33:00 <fax> hi dpiponi
14:33:02 <dmead> i've got char ' ' to eat up spaces
14:33:13 <dpiponi> Hi. Thanks for the correction.
14:33:23 <zygoloid> @free dup :: a -> (a, a)
14:33:23 <lambdabot> $map_Pair f f . dup = dup . f
14:33:24 <dmead> but i dunno how to make it optional, other than an entire block with <|>
14:33:30 <mauke> there's a function for that
14:33:34 <DBAlex> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8531#a8531
14:33:35 <ivanm> dmead: as in a single space or a list of optional ones?
14:33:41 <mauke> it had a weird name... optionMaybe?
14:33:44 * ivanm doesn't actually know since he doesn't use parsec
14:33:50 <dmead> ivanm lets say list of optional ones
14:33:55 <DBAlex> hey, so why isn't this code lazily evaluated to give me the lcm ? (minimum) of the filter ?
14:33:57 <sinelaw> ivanm, what do you use to parse GraphViz?
14:34:00 <ivanm> polyparse
14:34:01 <mauke> dmead: many (char ' ')
14:34:02 <DBAlex> I have to cap iterate
14:34:11 <dmead> mauke, is that valid for no spaces as well?
14:34:13 <dmead> i mean
14:34:15 <mauke> dmead: yes
14:34:20 <dmead> most excellent
14:34:21 <dmead> thanks
14:34:25 <zygoloid> '' isn't a legal char :)
14:34:26 <ivanm> DBAlex: iterate is infinite ;-)
14:34:33 <DBAlex> ivanm: hmm ok
14:34:34 <Alpounet> ivanm, how are you dot parsing stuffs going on by the way ?
14:34:34 <c_wraith> DBAlex: iterate goes forever, by definition.  use take or takeWhile
14:34:35 <sinelaw> ivanm, recent blog posts claim that attoparsec is fast
14:34:44 <DBAlex> ok
14:34:50 <dpiponi> @free econ :: forall t. t -> (t -> Z) -> (forall r. (forall a. a -> (a -> Z) -> r) -> r)
14:34:50 <lambdabot> (forall k u p. h (y u (p . k)) = z (k u) p) => h (econ x (g . f) y) = econ (f x) g z
14:34:55 <ivanm> I presume there's a many1 or something if you need to have at least one element in the list?
14:35:02 <mauke> yes
14:35:22 <ivanm> Alpounet: I think I might know how to avoid edges being parsed as nodes: try to parse an edge separator, and if it can then fail it (for node parsing)
14:35:32 <dmead> yar
14:35:35 <ivanm> sinelaw: yes, but my understanding is that attoparsec is very low level
14:35:52 <sinelaw> i never even looked at it
14:35:57 <sinelaw> so i don't know
14:36:02 <ivanm> yeah, hackage can't build the docs
14:36:22 <sinelaw> ivanm, btw i forgot to ask you
14:36:28 <Alpounet> ivanm, yeah, nice solution
14:36:33 <ivanm> sinelaw: shoot
14:36:56 <sinelaw> ivanm, did you roll back only the multi-graphs-per-process change, or also the other changes?
14:37:08 <Cale> @undefine
14:37:11 <ivanm> just the multi-graphs-per-process change
14:37:13 <Cale> hmm
14:37:16 <fax> dpiponi - I find you are incredible!
14:37:21 <sinelaw> ivanm, great
14:37:22 <ivanm> (as well as the "parse multiple graphs" and "print multiple graphs" functions)
14:37:33 <ivanm> sinelaw: all the manual augmentation stuff is there still
14:37:42 <sinelaw> i was afraid also the augmentation stuff was rolled back
14:37:43 <copumpkin> oh wow, dpiponi is here
14:38:01 <dpiponi> fax - that's scary! :-)
14:38:06 <Alpounet> yeah
14:38:19 <dpiponi> fax - but I'm sure you mean it in a nice way.
14:38:32 <fax> dpiponi, oh I don't mean that what you say has no credibility :P
14:38:53 <fax> dpiponi, but I have enjoyed reading your blog a lot
14:39:03 <copumpkin> most of us do :)
14:39:16 <Alpounet> all of us should
14:39:30 <copumpkin> AND, dpiponi now has a sweet car too
14:39:48 <zygoloid> dpiponi: i enjoyed the video of your talk on commutative monads. thanks!
14:40:02 <dmead> yea i looked at attoparsec
14:40:18 <dmead> parsec is really better looking, unless you've got really simple stuff
14:40:21 <sinelaw> dpiponi, me too :)
14:40:42 <sinelaw> though i'm sorry to say i forgot it all.
14:41:11 <sinelaw> somewhere in the depth of my unconsciousness, new knowledge awaits.
14:41:28 <dpiponi> Glad you enjoyed that talk. Putting it together took a big chunk of my time. Partly my mistake as I used a stupid approach to writing it.
14:41:56 <Alpounet> yeah
14:42:03 <Alpounet> that video is quite enlightening
14:44:53 <fax> forgetful functor
14:45:25 <Raynes> One forgetful motherfunctor.
14:46:00 <MadHatterDude> I've just downloaded Parsec from hackage, how do I Install it (easily)?
14:46:12 <fax> hi pkrumins!
14:46:17 <dpiponi> copumpkin: I love the car. But BMW don't know how to define a user interface for an electronic gadget.
14:46:24 <pkrumins> hi fax!
14:46:26 <pkrumins> copumpkin
14:46:33 <pkrumins> oops, enter by mistake.
14:46:51 <copumpkin> dpiponi: that's sad :/
14:46:55 <dolio> dpiponi: FYI, the post of mine that you duplicated appears to have shown up to me.
14:47:26 <sinelaw> MadHatterDude, use cabal
14:47:28 <fax> pkrumins: (I just 'know' you from reading catonmat :)))
14:47:46 <dpiponi> Oh, I'll delete it. Maybe I refreshed the browser too soon.
14:48:04 <MadHatterDude> sinelaw: There's a setup.hs with it, do I just throw that out the window?
14:48:10 <pkrumins> fax, :D
14:48:25 <sinelaw> MadHatterDude, use cabal :)
14:48:25 <danderson> can I have a haskell shell?
14:48:26 <pkrumins> fax, that's awesome that people recognize me :D
14:48:35 <danderson> I really want to do cabal <$> [clean, configure, build]
14:48:36 <MadHatterDude> sinelaw: Ok
14:48:39 <danderson> and have it work right :)
14:48:47 <sinelaw> MadHatterDude, cabal install parsec
14:48:48 <dpiponi> BTW I didn't know dolio=Dan Doel. Shoulda guessed.
14:49:17 <copumpkin> so many dans in here today
14:49:22 * fax doesn't really understand what's going on with haskell but it seems to be the thing
14:49:26 <jmcarthur> MadHatterDude: you can either do "cabal install parsec" or you can do dependency chasing and run "runhaskell Setup.hs configure && runhaskell Setup.hs build && runhaskell Setup.hs install" for every single dependency plus parsec
14:49:38 <jmcarthur> MadHatterDude: cabal-install is easier :)
14:50:26 <jmcarthur> danderson: you mean mapM_ cabal [clean, configure, build]
14:51:02 <jmcarthur> assuming clean, configure, and build are even defined
14:51:17 <danderson> jmcarthur: I was taking a bit of syntactic liberty, but you get the idea
14:51:24 <dpiponi> Anyway, I just dropped in to test out @free.
14:51:46 <danderson> and I think <$> would be correct, assuming the shell considers a command to return its output (both return codes and outputs)
14:52:11 <danderson> because I do want to see the output of the build :)
14:52:27 <dpiponi> @free construct :: forall t. t -> (t -> Z) -> (forall r. (forall a. a -> (a -> Z) -> (a -> a) -> r) -> r)
14:52:27 <lambdabot> (forall k u p q f1. k . q = f1 . k                    =>                     h (y u (p . k) q) = z (k u) p f1) => h (construct x (g . f) y) = construct (f x) g z
14:52:29 <dobblego> <$> wouldn't work
14:52:44 <zygoloid> @free foo :: (a -> b -> [c]) -> [a] -> [b] -> [c]
14:52:44 <lambdabot> (forall x. $map h . k x = p (f x) . g) => $map h . foo k xs = foo p ($map f xs) . $map g
14:52:52 <danderson> now, if you just consider the output streams to be side-effects of the shell as well as side-effects of the process being run, then yeah
14:53:00 <danderson> dobblego: why not?
14:53:35 * fax is a bit fed up having spend so much time learning programming
14:54:03 <DBAlex> fax: someone's forcing you to?
14:54:03 <copumpkin> fax: yeah, if only knowledge would just seep in automatically!
14:54:21 <jmcarthur> danderson: mapM instead of mapM_ then
14:54:21 <fax> DBAlex, no I chose to
14:54:26 <jmcarthur> danderson: but surely not <$>
14:54:44 <DBAlex> fax: then you can start and stop ... no one's holding a gun to your head ...
14:55:03 <DBAlex> *or
14:55:34 <danderson> jmcarthur: yes, I see why now. I was taking too much license with the types.
14:56:17 <fax> DBAlex, I mean that i already did it
14:56:24 * DBAlex has honestly never got bored of programming... however bug hunting can get tedious
14:57:50 * jmcarthur agrees with DBAlex
14:57:54 <jmcarthur> but that's why i like haskell
14:57:59 <jmcarthur> there isn't so much bug hunting
14:58:12 <DBAlex> yup, Haskell typing sort of prevents bugs
14:58:14 <DBAlex> ish..
14:58:29 <zygoloid> not all bugs, sadly
14:59:00 <jmcarthur> the type system is infortunately not awesome enough to catch all bugs, but from what i've seen of stronger type systems, we don't quite have the knowledge to make them so painless yet
14:59:12 <jmcarthur> haskell hits a sweet spot
14:59:36 <MadHatterDude> Gotta love FP: "First, ensure that all the packages it depends on are installed (by following these instructions recursively)."
14:59:39 <jmcarthur> or perhaps it's just discipline that we lack
14:59:43 <sinelaw> woohoo works
14:59:57 <jmcarthur> haskell is more disciplined than most languages, but perhaps the path to nirvana is yet more restrictions
15:00:03 <jmcarthur> totality, for example
15:00:12 <sinelaw>  perhaps dependent typing
15:00:25 <jmcarthur> i consider dependent typing to be a possible product of those restrictions
15:00:32 <jmcarthur> just like laziness is one of purity
15:00:50 <Cale> I don't consider laziness to be a product of purity
15:00:59 <zygoloid> the opposite, i'd say
15:01:02 <dobblego> other way around
15:01:02 <jmcarthur> laziness is pretty difficult to reason about without purity
15:01:07 <sinelaw> "laziness kept us pure"
15:01:09 <sinelaw> (SPJ)
15:01:18 <fax> has anyone done dependent typed programming
15:01:23 <Cale> Yes, but that's a point for purity being a product of laziness ;)
15:01:25 <zygoloid> disciple takes an interesting tack wth that
15:01:27 <jmcarthur> i just mean that purity was a necessity for laziness
15:01:30 <sinelaw> Cale, i agree
15:01:39 <jmcarthur> fax: i have
15:01:40 <zygoloid> you can be lazy if you want, but if you are, you must be pure
15:01:53 <fax> what did you do?
15:02:05 <jmcarthur> fax: i've used agda and coq
15:02:05 <dobblego> unless you are CAL, in which case, nobody will use you
15:02:10 <jmcarthur> i like them both
15:02:16 <fax> what did you program with them
15:02:18 <jmcarthur> but they aren't as simple to approach as haskell
15:02:30 <jmcarthur> mostly simple things. i lost patience before i got to anything useful
15:02:44 <fax> ok
15:02:46 <jmcarthur> i haven't used coq for anything too general, but i wrote some opengl stuff with agda
15:03:24 <jmcarthur> but in that particular case it was just an IO monad, so nothing very new
15:03:42 <jmcarthur> but it did demonstrate for myself that i didn't really want to try using agda for anything too serious yet
15:03:49 <roboshibby> haskell
15:04:05 <jmcarthur> roboshibby: you're in the right place!
15:04:11 <Cale> @let halfAdd (a,b) = (sum, carry) where sum = xor2 (a,b); carry = and2 (a,b)
15:04:12 <lambdabot>  Defined.
15:04:21 <roboshibby> woot
15:04:35 <Dashkal> Lazy question: What platforms can ghc target?  Specifically, can I target ARM?
15:04:36 <Cale> @let fullAdd (carryIn, (a,b)) = (sum, carryOut) where (sum1, carry1) = halfAdd (a,b); (sum, carry2) = halfAdd (carryIn, sum1); carryOut = xor2 (carry1, carry2)
15:04:37 <lambdabot>  Defined.
15:04:41 <MadHatterDude> hey, guys, Installing things as told to in http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package, but "runhaskell Setup install" says that "module Prelude is not loaded"
15:04:53 <Cale> @let adder = row fullAdd
15:04:54 <lambdabot>  Defined.
15:05:01 <sinelaw> MadHatterDude, did you try simply: cabal install
15:05:02 <fax> I don't have any goal to acheive by programmign so it was a big waste of time to learn
15:05:03 <sinelaw> in that dir?
15:05:10 <DBAlex> we had to use coq at uni
15:05:13 <DBAlex> wasn't really a fan...
15:05:21 <jmcarthur> i do really like it
15:05:21 <DBAlex> we used it as a proof assistant
15:05:27 <MadHatterDude> sinelaw: How do I _get_ cabal?
15:05:29 <DBAlex> I'm sure it's good if you like proofs :D
15:05:35 <sinelaw> MadHatterDude, what platform are you running
15:05:37 * benmachine likes proofs
15:05:38 <ivanm> Dashkal: there's been work on targetting ARM (specifically the iPhone)
15:05:42 <jmcarthur> DBAlex: do you like types?
15:05:46 <ivanm> not sure where it's at however
15:05:51 <Dashkal> Ahh, in progress.  I'm eying teh Nokia n900
15:05:56 <DBAlex> I like programming...
15:05:57 <DBAlex> :)
15:06:01 <MadHatterDude> sinelaw: WinXP32
15:06:01 <Alpounet> jmcarthur, ch-humor ?
15:06:06 <DBAlex> types are interesting
15:06:08 <sinelaw> MadHatterDude, get the haskell platform
15:06:08 <Alpounet> :p
15:06:17 <roboshibby> iphone sux
15:06:19 <Dashkal> Should be a reasonably straight-forward port.  It's just Linux on ARM
15:06:20 <MadHatterDude> sinelaw: Which is?
15:06:24 <sinelaw> MadHatterDude, http://hackage.haskell.org/platform/
15:06:28 <MadHatterDude> sinelaw: ghc?
15:06:28 <Cale> > simulate adder (low, zip [low, high, high, low] [low, high, high, high])
15:06:29 <lambdabot>   ([low,low,high,low],high)
15:06:36 <jmcarthur> DBAlex: so you don't like vegetables, but broccoli is interesting
15:06:38 <jmcarthur> ;)
15:06:39 <Alpounet> MadHatterDude, GHC + cabal + some very important libraries
15:06:40 <Dashkal> But I'm far from able to do it myself, and it might not be so simple as I suspect.
15:06:41 <sinelaw> MadHatterDude, it's everything you need to get started
15:07:05 <MadHatterDude> sinelaw: thanks
15:07:17 <DBAlex> jmcarthur: no, I like programming, but type theory and correctness aren't that interesting to me
15:07:18 <Alpounet> by the way sinelaw, lambdabot has @where platform for that, don't bother typing the whole thing in next time :)
15:07:28 <fax> DBAlex so what do you do
15:07:30 <jmcarthur> DBAlex: but seriously, i think when we are able to easily write compiler-checked proofs of our code very generally then we will be in good shape
15:07:31 <fax> make
15:07:39 <lelf> xb
15:07:40 <Dashkal> You like programming, but correctness isn't interesting? O.o
15:07:43 <sinelaw> Alpounet, copy paset :)
15:07:45 <sinelaw> paste
15:07:45 <jmcarthur> DBAlex: key word being "easily"
15:07:49 <DBAlex> If it works, it works
15:07:53 <fax> :/
15:07:57 <Dashkal> If it isn't correct, it doesn't work..
15:07:58 <DBAlex> I don't need to proove it's "perfect"...
15:08:00 <jmcarthur> DBAlex: if it's inconvenient then neither i nor anybody else would actually use it
15:08:08 <DBAlex> however it's interesting to do say if you want to...
15:08:12 <DBAlex> *to do so
15:08:14 <roboshibby> define "works"
15:08:20 <roboshibby> that's the primary issue
15:08:30 <mrd> whatever the program does, that's correct
15:08:34 <roboshibby> ha
15:08:39 <DBAlex> it does what I want it to do for the set testing cases I have :-)
15:08:43 <fax> The length of a program bears no relation to the length of its correctness proof.
15:08:50 <roboshibby> just like, whatever i say is correct, just not necessarily true? lol
15:08:52 <Dashkal> I define my program to crash horribly under high load!
15:08:54 <mrd> now if i could turn in hw that way
15:09:00 <Twey> Dashkal: Heheh
15:09:49 <Dashkal> My wake-up call in the regard... I had a Java program that ran fine on a single-core machine, but failed on a dual-core.
15:10:07 <jmcarthur> DBAlex: if robustness, security, and correctness are of no concern then why not code in plain assembly?
15:10:11 <Dashkal> Hint: volatile isn't enough to share data...
15:10:30 <fax> so I wonder what I should do
15:10:49 <DBAlex> jmcarthur: True, they must mean something to me
15:10:51 <fax> imagine if you spent 6 years leaning carpentry, then you never bothered to make another carpet again
15:10:55 <fax> what would be the point?
15:11:05 <mrd> carpet?
15:11:06 <DBAlex> I think I'm more of an engineer, I like to make things above all
15:11:14 <jmcarthur> so do it
15:11:21 <jmcarthur> i just like to know that what i made means something
15:11:33 <mrd> carpenters don't make carpets
15:11:34 <jmcarthur> *so do i
15:11:35 <Dashkal> Engineering is precision work
15:11:46 <mrd> or was that your point
15:12:03 <Dashkal> Someone who slaps together a shed that doesn't fall over on the first windstorm "good enough" isn't a structual engineer.
15:12:20 <fax> mrd, sorry that is my perverse sense of humor
15:12:24 <jmcarthur> or a structural engineer, even
15:12:33 * Dashkal cannot spell to save his life
15:12:36 <jmcarthur> ;)
15:13:05 <jmcarthur> i make enough typos and grammar errors to account for 10 normal peoples' typos
15:13:24 <SubStack> I let the computer spell for me
15:13:38 <Dashkal> That reminds me: I want an incremental compilier/editor for haskell.  Just so I get that little red line as I work when I typo.
15:13:56 <DBAlex> someone needs to update visual haskell
15:13:58 <DBAlex> or w/e it's called
15:14:01 <jmcarthur> Dashkal: maybe integrate it in scion or something?
15:14:06 <DBAlex> (The VS studio thingeh for Haskell)
15:14:16 <DBAlex> *visual studio
15:14:17 <Dashkal> Eh, if I was utterly insane I'd implement it for Eclipse.  But I'm not that sick.
15:14:26 <SubStack> eeps
15:14:35 * SubStack should start using yi sometime
15:14:40 <jmcarthur> Dashkal: actually scion does it already i think
15:14:44 <dpiponi> Talking of IDEs, It's be fun to have an interactive code building environment like the way Coq works. I believe someone is working on something like that.
15:14:46 <Dashkal> Say what you will about bloat, the JDT is an excelent environment for Java.  And almost nothing else.
15:14:59 <Dashkal> hmm, I should look at that.  That would save me some serious time when coding.
15:15:07 <Dashkal> So many compile errors are simply typos
15:15:09 <jmcarthur> Dashkal: http://code.google.com/p/scion-lib/
15:15:27 <jmcarthur> i don't know if it's as-you-type, but you could probably rig that up with a couple lines of elisp
15:15:49 <mrd> it exists
15:15:54 <mrd> flymake
15:16:00 <jmcarthur> ah yeah, flymake!
15:16:15 <jmcarthur> oh, scion does do on-the-fly type checking though
15:16:36 <fax> like when you start programming you learn lots of things at a very fast rate
15:16:42 <jmcarthur> i've been meaning to set up scion. never got around to it
15:16:44 <fax> but now, I am at a stage where I do not learn very much
15:17:07 <jmcarthur> fax: i have felt that way too. i feel like i have to actually discover knowledge for myself now instead of having it fed to me
15:17:18 <jmcarthur> and by discover i kind of mean invent
15:17:52 <jmcarthur> not that there isn't plenty for me to learn, still
15:18:02 <jmcarthur> but my interests are more focused now
15:19:04 <metaperl> Could I get som help with my type error on line 27 please - http://pastie.org/pastes/864162
15:19:18 <Dashkal> jmcarthur: ooo, that's pretty
15:19:40 <fax> metaperl, [sep] ++ x ++ preface sep xs ?
15:20:14 <metaperl> Fax - isnt [sep] ++ x the same as sep:x
15:20:18 <Dashkal> Figures that it comes with an emacs front-end that does what I want and not vim...
15:20:23 <metaperl> ah... but the rest
15:20:35 <metaperl> ok the other part must be concat
15:20:50 <jmcarthur> Dashkal: you're a vim user?
15:20:58 <sinelaw> @pl (\x -> do return  x)
15:20:58 <lambdabot> do return
15:21:09 <jmcarthur> Dashkal: well, it's designed to be easy to integrate with stuff. maybe you could make a vim frontend with it?
15:21:14 <sinelaw> @pl (do return  ())
15:21:14 <lambdabot> do return ()
15:21:24 <sinelaw> @type do return ()
15:21:25 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
15:21:29 <sinelaw> @hoogle m ()
15:21:30 <lambdabot> Network.BSD endHostEntry :: IO ()
15:21:30 <lambdabot> Network.BSD endNetworkEntry :: IO ()
15:21:30 <lambdabot> Network.BSD endProtocolEntry :: IO ()
15:21:33 <jmcarthur> i'm more of an emacs person when it comes to coding. i use vim for config files and stuff
15:21:34 <sinelaw> bah
15:21:37 <fax> :t do 3
15:21:38 <lambdabot> forall t. (Num t) => t
15:22:33 <metaperl> I fixed it. Thanks fax - http://pastie.org/pastes/864173
15:22:35 <fax> I watched a talk by _why
15:22:52 <jmcarthur> jack black you mean
15:23:01 <fax> it seems quite inspirational but it is a bit sad too
15:23:32 <jmcarthur> yeah
15:24:17 <ivanm> jmcarthur: ?
15:24:30 <jmcarthur> ivanm: my jack black comment?
15:24:35 <ivanm> yeah
15:24:37 <jmcarthur> ivanm: i just think _why looks like jack black
15:24:47 <sinelaw> who is _why
15:25:10 <jmcarthur> sinelaw: _why the lucky stiff was a prominent excentric in the ruby community
15:25:22 <sinelaw> and...
15:25:29 <ivanm> sinelaw: http://en.wikipedia.org/wiki/Why_the_lucky_stiff
15:25:33 <Dashkal> jmcarthur: It's entirely possible that I could, I simply lack the attention for another project right now :(  Something to seriously think about, though.
15:25:37 <jmcarthur> sinelaw: and he disappeared suddenly and deleted all his stuff from the internet
15:25:49 <ivanm> sinelaw: he did the poignant guide to ruby (which BONUS is basing LYAH off)
15:26:24 <jmcarthur> _why mixed programming and art in a way that i enjoyed immensely
15:26:34 <ivanm> jmcarthur: didn't he disappear because someone outed his real name on some public blog and wouldn't take it down (thus apparently letting everyone know, even though wikipedia, etc. still don't say it) ?
15:26:39 <jmcarthur> everything he did was a piece of art, even mundane code
15:26:48 <jmcarthur> ivanm: that was a misguided rumor
15:27:46 <ivanm> ahhhh
15:27:52 <jmcarthur> ivanm: people who do actually know his identity say that the blog was wrong. maybe they aren't trustworthy, but i'd rather them be right
15:28:00 <ivanm> so no-one knows why he suddenly disappeared?
15:28:07 <jmcarthur> somebody does, but they aren't talking
15:28:21 <ivanm> hmmm.... maybe he realised his life was misguided by dealing with ruby after suddenly discovering haskell? :p
15:28:25 <jmcarthur> i do think that removing his stuff from version control and everything was irresponsible
15:28:29 <ivanm> yeah
15:28:55 <_why> hi
15:29:00 <sinelaw> ok not.
15:29:09 <sinelaw> his nick is registered. :)
15:30:00 <ivanm> @slap sinelaw
15:30:00 <lambdabot> go slap sinelaw yourself
15:30:11 <jmcarthur> @slap lambdabot
15:30:11 * lambdabot submits lambdabot's email address to a dozen spam lists
15:30:16 <ivanm> heh
15:30:28 <sinelaw> @slap slapping
15:30:28 * lambdabot would never hurt slapping!
15:30:39 <jmcarthur> @slap somebody
15:30:39 <lambdabot> I won't; I want to go get some cookies instead.
15:30:53 <Mathnerd314> @slap you
15:30:53 <lambdabot> I won't; I want to go get some cookies instead.
15:31:00 <mreh> @slap lambdabot
15:31:00 * lambdabot decomposes lambdabot into several parts using the Banach-Tarski theorem and reassembles them to get two copies of lambdabot!
15:31:08 <jmcarthur> @slap herself
15:31:08 <lambdabot> stop telling me what to do
15:31:23 <Dashkal> @sudo make me a pizza
15:31:23 <lambdabot> Maybe you meant: do todo undo
15:31:29 <jmcarthur> lol
15:31:29 <Dashkal> awww
15:32:28 <MisterN> @make me a sandwich
15:32:29 <lambdabot> Maybe you meant: map more
15:32:40 <lament> @fap
15:32:40 <lambdabot> Maybe you meant: faq map
15:32:47 <ivanm> @help map
15:32:48 <lambdabot> map. #haskell user map
15:32:48 <fax> yeah but do we have some kindof goal? what's thep point of all this programming/software and so on
15:32:50 <ivanm> @map
15:32:51 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:33:04 <lament> fax: make your life miserable
15:33:06 <ivanm> fax: hmmm?
15:33:16 <lament> that URL is broken
15:33:35 <sinelaw> http://www.haskell.org/haskellwiki/HaskellUserLocations
15:33:37 <Dashkal> fax: Am I missing some context?  You program to solve a problem you aready know about.  Even if that problem is "I don't know how to do X".
15:33:57 <fax> yeah but I don't have any problems
15:34:04 <Dashkal> _envy_
15:34:16 <Dashkal> Also, grats on nirvana
15:34:38 <fax> it's not really what it's cracked up to be
15:35:07 <jmcarthur> fax: i don't consider programming to be problem-solving so much as a zen activity. i do it because it's something to get lost in
15:35:26 * lament resists the obvious Your Mom joke
15:35:28 <Dashkal> I have plenty of problems that software can be of assistance for.  Ranging from "I'm bored" to "I want to log into my computer remotely more securely"
15:35:38 * Dashkal gives in
15:35:39 <Dashkal> That'
15:35:42 <Dashkal> s what she said
15:36:02 <jmcarthur> fax: "Before enlightenment; chop wood, carry water. After enlightenment; chop wood, carry water."
15:36:23 <jmcarthur> a zen proverb of some sort. i'm not sure of its origins
15:37:00 <Dashkal> Welcome to zen: http://www.ozyandmillie.org/d/20060620.html
15:37:55 <jmcarthur> heh
15:38:52 <lament> instead of enlightenment: chop wood, carry water.
15:40:07 <fax> what is the equivalent of chop wood, carry water for computing people (like us)?
15:40:18 <sinelaw> type, compile
15:40:28 <sinelaw> woohoo my lib works
15:40:30 <jmcarthur> i think it's just whatever you do
15:40:33 <micah> if there are duplicate instance declarations of something to do with data.accessor when installing yi, what should I do?
15:40:43 <araujo> With an empty mind you grasp at FP faster too
15:40:43 <Dashkal> chop wood, carry water :P  What is this computer you speak of?
15:40:46 <fax> I can write a program that enumates every possible haskell program and checks if they compile
15:40:55 <fax> the programming for the sake of programming problem is solved
15:41:09 <jmcarthur> the world is not necessarily a problem to be solved
15:41:11 <Dashkal> Oh my was FP a difficult concept.  I'm still fighting the tendancy to write imperatively first.
15:41:35 <araujo> Dashkal, free your mind
15:41:45 <micah> fp is quite natural for me :D now when I write in environments where fp sucks I end up writing a bunch of crappy code and then rewriting imperatively
15:42:01 <companion_cube> free() is kind of imperative, isn't it ?
15:42:13 <Dashkal> I still catch myself having to write the imparative version of a function first, then translating.  I want to cross that line from translating into thinking in FP
15:42:14 <micah> well it modifies state
15:42:19 <jmcarthur> micah: in what environment does fp suck?
15:42:22 <micah> Game maker
15:42:24 <micah> M
15:42:24 <fax> what should I type ?
15:42:33 <micah> and other crippled scripting languages
15:42:39 <araujo> Dashkal, forget all you know, reborn again
15:42:41 <jmcarthur> oh, particular languages
15:42:43 <jmcarthur> yeah...
15:42:49 <araujo> that is what empty mind means
15:42:51 <Dashkal> araujo: I lack that luxury.  In my day job I write PHP
15:42:59 <fax> araujo what is?
15:43:03 <araujo> Dashkal, sorry, wait for next rebirth then
15:43:05 <araujo> hehe
15:43:15 <micah> think about your programs as the data they work on first
15:43:15 <Dashkal> :P
15:43:22 <micah> and then what transformations you need on the data
15:43:28 <Dashkal> What I should really do is learn FRP.
15:43:29 <micah> not as the order of things you want to do
15:43:31 <araujo> fax, what?
15:43:45 <fax> what does empty mind mean?
15:43:54 <araujo> fax, Wu
15:44:00 <Dashkal> It's a much better fit for what I'm doing, but I wasn't able to grasp it last time I looked into it.  Perhaps I'll fare better this time
15:44:25 <lament> honestly zen is pretty crap though
15:44:29 <jmcarthur> Dashkal: even those of us who are pioneering FRP are still trying to learn it
15:44:36 <jmcarthur> lament: why?
15:44:44 <fax> I have knowledge that presumably, some kind of buisness could exploit to increase profits
15:44:49 <lament> jmcarthur: why not?
15:44:56 <fax> but this is not a very appealing thing for me
15:45:25 <fax> programming, haskell, etc
15:45:33 <Dashkal> jmcarthur: That makes me feel al little better :P
15:45:40 <Dashkal> -l
15:45:41 <lament> jmcarthur: there seems to be a huge disparity between zen and zen in the west, and zen in the west is more or less existentialist philosophy not expressed well
15:45:58 <lament> i'm all for expressing things well as opposed to speaking in riddles
15:46:13 <Dashkal> fax: Why are you into technology?
15:46:20 <fax> I'm not really
15:46:30 <Dashkal> Then why do you identify as "computer people"?
15:46:36 <lament> jmcarthur: and zen not in the west is just another cultural/traditional thing without any real outsider value
15:46:50 <araujo> zen is pretty much the only real thing out there that actually makes sense
15:46:51 <araujo> heh
15:46:54 <jmcarthur> lament: not to continue the riddles intentionally, but perhaps the riddles are precisely because we are not sure what it is we are describing
15:46:55 <Dashkal> I'm asking why you choose tyo identify, not challenging it.
15:47:02 <fax> araujo, I don't understand zazen
15:47:16 <lament> jmcarthur: perhaps. I don't believe that to be the case.
15:47:18 <fax> araujo, ..but that is probably my problem :/
15:47:22 <araujo> fax, good , you don't need to understand it
15:47:27 <lament> jmcarthur: or rather, the zen people are not sure, but western philosophy does a much better job.
15:47:38 <araujo> fax, just sit quiet and practice it
15:47:41 <jmcarthur> i don't follow
15:48:04 <jmcarthur> -blah?
15:48:09 <fax> araujo, but how do I know if I am doing it right?
15:48:15 <araujo> western philosophy is still in baby step  along zen
15:48:51 <araujo> just for except a few western people, most of them are baby steps
15:49:22 <araujo> fax, there is no right nor wrong , just sit and be quiet
15:49:27 <fax> araujo, and why sit anyway?
15:49:52 <micah> can anyone help me with my yi installing problem :P
15:49:59 <araujo> fax, you can choose not to , zazen is just one way through zen
15:50:04 <araujo> there are plenty of ways
15:50:45 <DBAlex> problem is, zen can't be taught to western people I guess
15:50:49 <DBAlex> they're too far gone
15:51:23 <araujo> it depends DBAlex , if they already have too much knowledge set on stone, it is hard, yes
15:51:31 <micah> what is the point of zen
15:51:33 <DBAlex> although I'm not really sure what's so great about it anyway
15:51:43 <micah> is the point to not have any point to anything
15:51:56 <DBAlex> from what I've learn't, most of the zazen people would be happy to meditate until death by malnutrition
15:52:03 <araujo> But actually I think that western people open enough, can actually grasp at zen very well, even better than many east people
15:52:06 <DBAlex> doesn't sound to zen to me
15:52:39 <araujo> zen is meditation ... but meditation has no goal
15:52:45 <DBAlex> there is no point of zen
15:52:46 <fax> so why mediate?
15:52:47 <araujo> if you set a goal
15:52:47 <jmcarthur> araujo: what you describe (unlearning) sounds platonic/socratic, which i believe is decidedly western
15:52:50 <DBAlex> it's void
15:52:51 <araujo> then ther ei sno meditation
15:52:54 <DBAlex> not even null... :p
15:53:17 <DBAlex> you meditate for nothing
15:53:20 <fax> this conversation has split into two, one here and one in #haskell-blah
15:53:26 <DBAlex> you gain nothing, you loose nothing
15:53:27 <araujo> jmcarthur, socrates was very zen-like
15:53:34 <fax> DBAlex that has (at least) two interpretations :S
15:54:04 <DBAlex> fax: ?
15:54:26 <micah> so is this a channel of haskell people who can help me or should I go somewhere else
15:54:27 <micah> :P
15:54:30 <DBAlex> people don't get that it's just about having no gain, or no loss, no nothing, it's void, it's zen...
15:54:39 <blackh> micha: Yes, this is the place!
15:54:49 <gwern> zen distinguishes multiple purposes of meditation; the first one, starting with a 'b' (I forget the rest), is for bodily & mental health
15:54:53 <gwern> good enough reason for me
15:55:00 <fax> vispassana ?
15:55:02 <gwern> certainly the science seems to bear it out
15:55:07 <fax> vipassana *
15:55:09 <blackh> micah: This is the right place for newbies
15:55:12 <gwern> fax: not vipassana
15:55:14 <micah> I'm trying to install yi -f cocoa
15:55:18 <gwern> vipassana ain't zen either
15:56:03 <fax> I am very interested in zazen and vipassana partly because Henk Barendregt has written very favorably about it
15:56:32 <fax> (anyone who is into computing theory should know Henk Barendregt)
15:56:33 <micah> but I get an error about conflicting definitions of Category Accessor.T
15:56:46 * gwern likes vipassana on a practical level. it's better than a nap
15:57:06 <blackh> micah: Are you using ghc-6.10.x or ghc-6.12.x?
15:57:17 <micah> 6.12 I think
15:57:25 <micah> might be 10 though; I don't remember
15:57:41 <ivanm> ghc --version
15:57:48 <araujo> DBAlex, zen speaks lot about the void .... and I think most of the hesitation in western philosophy (and people) to accept Zen is this fundamental idea, that is interpreted in the west like "void" of "death", but that is not actually the meaning... it is more like , if you have an empty room , you just get into the room, but you don't say the room is dead , you just say it is empty, even though, there is a "room" and there is a "space" , so, you
15:57:48 <araujo> neither can say there is something there nor there is nothing there
15:57:50 <micah> oh it's 10
15:57:51 <ivanm> micah: is this yi?
15:58:03 * araujo can take it somewhere else if anyone wants
15:58:04 <ivanm> yeah, it is
15:58:07 <micah> yeah yi
15:58:11 <ivanm> micah: downgrade data-accessors
15:58:11 <copumpkin> FUCKING HELL
15:58:17 <micah> how do I do that
15:58:24 <fax> araujo yeah come to #haskell-blah
15:58:24 * micah is not familar much with cabal
15:58:25 <DBAlex> araujo: umm yup
15:58:32 <ivanm> or else manually edit the yi source to remove the instance for Accessors.T
15:58:36 <fax> though it's getting kind of silly in there
15:58:41 <fax> so maybe that's not the best place
15:58:42 <DBAlex> araujo: problem is, people don't understand that no gain or no loss is actually a good thing
15:58:44 <ivanm> micah: you're using cabal?
15:58:52 <micah> yeah
15:58:56 <micah> cabal install yi -f cocoa
15:58:59 <DBAlex> araujo: it means void as in, no change, stateless
15:59:08 <ivanm> cabal install data-accessors-0.2.1 --reinstall
15:59:10 <ivanm> (I think)
15:59:17 <DBAlex> araujo: not, void as in, devoid of anything
15:59:50 <micah> thanks
15:59:55 <micah> let's hope this works :D
16:00:00 <micah> oh it didn't :(
16:00:04 <micah> same conflict
16:00:07 <blackh> ivanm, micah: I'm not sure what version you need, but you might want need to uninstall the newer ones using 'ghc-pkg list' to see what you've got and 'ghc-pkg unregister data-accessors-<version>'
16:00:22 <ivanm> blackh: yeah, about to suggest that
16:01:21 <Alpounet> or you can just hide that version
16:01:48 <ivanm> Alpounet: nope, I dont' think that will do it
16:01:55 <ivanm> hiding just means it won't appear by default in ghci
16:01:59 <ivanm> but cabal can still use it
16:02:02 <Alpounet> hmm no
16:02:08 <ivanm> (or ghc --make)
16:02:17 <Alpounet> yeah with ghc --make indeed
16:02:18 <ivanm> Alpounet: I've hidden packages before that were still used by cabal...
16:02:19 <Alpounet> sorry
16:03:02 <micah> I unreg'd data-accessor-2.1
16:03:02 <sinelaw> @hooge (.)
16:03:02 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
16:03:03 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
16:03:03 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
16:03:08 <micah> 0.2.1*
16:03:14 <micah> but
16:03:22 <micah> data-accessor-0.2.0.2, data-accessor-0.2.1.2
16:03:33 <micah> are still there and it says both are depended on by some things
16:04:17 <ivanm> micah: rebuild those packages that need them
16:04:29 <micah> k
16:05:17 <micah> data-accessor-monads-fd-0.2 data-accessor-template-0.2.1.3 pointedlist-0.3.5
16:05:21 <micah> that's what it'd break
16:05:25 <micah> so just cabal install those again?
16:06:59 <ivanm> with --reinstall
16:12:34 <micah> I did that and same rproblme :(
16:13:10 <ivanm> which versions of data-accessor do you have installed?
16:14:30 <micah> data-accessor-0.2.1.2
16:15:06 <BrianHV> is it possible to cross compile haskell code to ARM such that it could be called from an Android app?
16:16:14 <micah> probably through c or llvm backend although I don't know anythigna bout it
16:16:31 <ivanm> BrianHV: not yet
16:16:47 <ivanm> micah: I said you had to _downgrade_ to 0.2.1!
16:16:51 * hackagebot language-dot 0.0.5 - A library for the analysis and creation of Graphviz DOT files  http://hackage.haskell.org/package/language-dot-0.0.5 (BrianLewis)
16:17:54 <BrianHV> ivanm: is the hangup the cross compilation or the android compatibility?  is there someone working on this?
16:18:34 <ivanm> BrianHV: both ;-)
16:18:46 <ivanm> there are some people working on iPhone compilation; no idea what stage it's at
16:19:18 <ivanm> is Brian Lewis in here?
16:19:49 <BrianHV> cool... thanks
16:23:15 <Alpounet> ivanm, sounds like what you need
16:23:57 <ivanm> nope
16:24:00 <ivanm> mine is better!
16:24:26 <Alpounet> I hope so !
16:24:33 <ivanm> for most parts, it is
16:24:51 <ivanm> Alpounet: I'm just annoyed that Galois paid Brian Lewis to develop this as they needed features I was already including into graphviz _for free_ :@
16:25:03 <jimmyjazz14> is there an 'if' like function in the standard libraries
16:25:26 <ezyang> yes, but depends on what you ean
16:25:27 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
16:25:36 <jimmyjazz14> basically if as a function instead of a syntax
16:25:38 <ezyang> @messages
16:25:39 <lambdabot> copumpkin asked 2h 24m 30s ago: if you don't have time to find out about holding a HUG at the usual place, do you know of any other haskellers at MIT who might be interested in organizing it?
16:25:52 <sinelaw> ivanm, to develop what?
16:25:56 <sinelaw> (just walked in)
16:26:14 <micah> you could easily createone
16:26:20 <micah> not even using the builtin if
16:26:27 <ivanm> sinelaw: language-dot
16:26:28 <jimmyjazz14> I have one I created: if' ch a b = if ch then a else b
16:26:43 <ivanm> it has "better" (in a limited sense of the word) HTML-like labels
16:26:44 <micah> that takes a Bool and returns a function depending on if it's treu or false
16:26:48 <ivanm> which I'm working on atm
16:26:51 <sinelaw> ah
16:26:55 <ezyang> @message copumpkin I don't think I'll have time, but I'll ask around.
16:26:56 <lambdabot> Maybe you meant: messages messages?
16:26:56 <sinelaw> ivanm, i'm on your side :)
16:27:00 <ivanm> AFAICT, that's the only advantage language-dot has over graphviz
16:27:06 <ivanm> sinelaw: \o/
16:27:23 <ezyang> erm
16:27:25 <copumpkin> ezyang: thanks :)
16:27:26 <Alpounet> ivanm, yeah, but now it's done...
16:27:26 <sinelaw> that's it, Galois = Microsoft
16:27:33 <ivanm> heh
16:27:35 <sinelaw> just kidding
16:27:35 <micah> if' True = \x y -> x; if' False = \x y -> y
16:27:51 <copumpkin> ezyang: no pressure, but ravi has disappeared and I'd like to keep the boston HUG alive (but can't really do much from where I am :/)
16:27:58 <micah> wait just turn those lambdas into the normal arguemtns
16:27:59 <micah> :P
16:28:01 * ivanm might email him after the next release to ask if there's any reason why he keeps working on it
16:28:18 <ezyang> oh no >.>
16:30:27 <sinelaw> Alpounet, check it http://github.com/sinelaw/cv-combinators
16:30:45 <ivanm> ezyang: what?
16:30:50 <jimmyjazz14> micah how is that different then my version?
16:31:12 <sinelaw> i'm writing yet another frp framework, i guess
16:31:12 <jimmyjazz14> I mean other then the fact that I actually use the if statement
16:31:14 <sinelaw> :)
16:31:26 <ezyang> ivanm: Re ravi's disappearance
16:32:11 <sinelaw> i made an interface for OpenCV
16:32:23 <sinelaw> now you can do: resize . camera
16:32:27 <sinelaw> to get a resized camera :)
16:33:00 <Alpounet> sinelaw, let me finish my blogpost and I'll check this out :)
16:33:26 <sinelaw> Alpounet, it's a very preliminary draft alpha version, just to be on the safe side :)
16:33:36 <sinelaw> only two primitives (camera and resizer) exist
16:33:58 <sinelaw> but the concept is there.
16:34:06 <Alpounet> okay
16:34:14 <sinelaw> Alpounet, where's your blog, btw?
16:34:15 <ivanm> ezyang: who?
16:34:25 <ezyang> Previous organizer of boston HUG
16:34:34 <ivanm> ahhh
16:34:43 <ivanm> so it doesn't affect me then ;-)
16:35:29 <Alpounet> sinelaw, alpmestan.wordpress.com
16:36:13 <sinelaw> Alpounet, cool, bookmarked :) night!
16:36:50 <sinelaw> btw, opencv has neural networks i think
16:42:22 <mmmulani> hmm, can anyone install download-curl via cabal?
16:42:39 <mmmulani> it's failing to compile on my machine
16:42:55 <Cale> mmmulani: What's the error? Do you have libcurl installed?
16:43:19 <mmmulani> yes, the error actually deals with compiling something from TagSoup.Tag
16:43:36 <ivanm> oh, the latest version of tagsoup requires GHC 6.12 IIRC
16:43:59 <mmmulani> I'm on 6.12.1 :/
16:44:00 * ivanm just came across the problem of not having libcurl-dev (or whatever it's called) when trying to build darcs
16:44:07 <ivanm> mmmulani: hmmm...
16:44:15 <ivanm> can you paste the actual error up somewhere?
16:44:33 <mmmulani> sure in a sec
16:44:38 <djahandarie> Hey folks, could anyone point me in the right direction to understanding kernel density estimation and how it would work with something like Criterion?
16:44:38 <mmmulani> having problems copying in this vm..
16:44:52 <djahandarie> The wikipedia page is a bit too technical for me
16:45:03 <ivanm> djahandarie: a statistics textbook?
16:45:14 <ivanm> is there a simple english version of that wiki page?
16:45:37 <djahandarie> Nope. I could try reading the Japanese one to see if it helps though...
16:45:57 <djahandarie> Practically a direct translation, lol
16:47:01 <ivanm> heh
16:47:20 <ivanm> preflex: seen Axman6
16:47:21 <preflex>  Axman6 was last seen on #haskell 3 hours, 40 minutes and 23 seconds ago, saying: i know. just make things that match the types needed
16:47:48 <Cale> djahandarie: What are you trying to understand about it?
16:49:06 <djahandarie> Cale, its merits, and a basic example really.
16:49:20 <Cale> You know what a probability density function is?
16:49:43 <mmmulani> ivanm: http://pastebin.com/rWcffDhz
16:49:58 <lpsmith> So I'm experimenting with a bit of cabal-install hacking;   cabal-install demands Cabal >= 1.9,  but i can't seem to install the darcs copy of cabal in my user repository
16:50:41 <djahandarie> Cale, no
16:51:33 <Cale> djahandarie: Okay, so the basic idea is that you have some function such that the probability that a given value lies between a and b is the integral from a to b of of that function.
16:51:52 <Cale> minus the spurious extra 'of' :P
16:51:53 <lpsmith> heh, n/m,  I just tried installing it again to get the error message,  and it worked
16:52:04 <lpsmith> leaving me confused, but whatever
16:52:22 <Cale> To put that more geometrically, it's the area underneath the graph that Criterion is plotting.
16:53:04 <ivanm> mmmulani: which version of tagsoup do you have installed (ghc-pkg list tagsoup) ?
16:53:05 <gio123> Cale: ola
16:53:13 <Cale> Of course, we usually don't care about the exact probability that some function takes between, say, 100ns and 200ns to evaluate
16:53:38 <Cale> but the graph gives you, at a glance, a pretty good idea of how the evaluation times are distributed
16:53:43 <ivanm> tsk, tsk; naughty dons didn't use specific versions...
16:54:00 <Cale> djahandarie: Does that make some sense?
16:54:12 <ivanm> mmmulani: I _think_ it's because you have tagsoup-0.8 installed but download-curl only works with tagsoup-0.6
16:54:13 <copumpkin> oh sweet!
16:54:19 <copumpkin> the first GHC patch made it into LLVM
16:54:24 <ivanm> copumpkin: \o/
16:54:24 <mmmulani> ivanm: tagsoup-0.8
16:54:25 <mmmulani> ahhhh
16:55:08 <copumpkin> dons: is John Earle still banned from haskell-cafe? his stuff is pretty inappropriate for cvs-ghc but I feel bad telling him to sod off unless he is actually able to post to haskell-cafe
16:55:09 <ivanm> @tell dons for download-curl, it doesn't seem to work with tagsoup-0.8;  maybe you should either tighten the deps or release an updated version?
16:55:09 <lambdabot> Consider it noted.
16:55:10 <djahandarie> Cale, yes -- so it'd just be the integral of the function (# of samples) -> execution time?
16:55:25 <ivanm> copumpkin: he posted something the other day IIRC...
16:55:45 <Cale> djahandarie: Like, if you integrate that function between 100ns and 200ns, you get the probability that the evaluation time is between 100 and 200ns
16:56:01 <ivanm> "Fast Haskell Parser" and the like
16:56:17 <copumpkin> ivanm: that's to cvs-ghc, unless he also posted to cafe
16:56:24 <ivanm> copumpkin: so I don't think he's banned (but I think he should be)
16:56:26 <Cale> So it's a function from time, to "probability density", which is a measure of how likely the evaluation will take that amount of time
16:56:33 <ivanm> copumpkin: ahhh; Ben just forwarded it to -cafe
16:56:59 <mmmulani> how do you remove packages with cabal?
16:57:14 <ivanm> copumpkin: in that case, last one that I can spot is from december :s
16:57:35 <ivanm> mmmulani: you can't, really; best you can do is "ghc-pkg unregister <foo-version>" and then manually delete the files
16:57:59 <djahandarie> Cale, oh hm, this is getting clearer now
16:58:21 <mmmulani> ivanm: sweet! that seems to have fixed it
16:58:26 <ivanm> no worries
16:58:50 <Cale> This gives you more information than just a simple mean, because if there are some, perhaps rarer, cases where the evaluation takes much longer, they will show up as lumps way off on the high end of things.
16:59:12 <benmachine> mmmulani: you can also temporarily ignore a package with ghc-pkg hide
16:59:35 <ivanm> benmachine: he's wanting to downgrade it
17:00:04 <benmachine> oic
17:00:10 <Cale> Maybe you have a function which 3/4 of the time takes between 100 and 200ms, and then 1/4 of the time, it takes between 4 and 5 seconds, because it has to choose between two methods based on its input.
17:00:11 <benmachine> my point is still true!
17:00:37 <Cale> The graph will show two lumps, one between 100 and 200ms which will have 3 times the area of the lump between 4 and 5 seconds.
17:00:41 <djahandarie> Cale, right I see how it works now.
17:01:24 <benmachine> in fact the 'correct' way to fix that'd probably be cabal install download-curl --constraint='tagsoup<0.8' wouldn't it?
17:02:08 <djahandarie> Cale, is there a semi-intutive/simple way to explain how that is calculated?
17:03:10 <Cale> djahandarie: The basic idea is that it's taking lots of smooth little bumps for each of the samples, and adding those up.
17:03:38 <ivanm> benmachine: not familiar enough with cabal-install to be able to tell ;-)
17:04:11 <benmachine> http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=%28%5Cx+y+z+-%3E+x+%2B+y+%2B+z%29+1+2+3 whee applying whole lambdas at once
17:04:31 <Cale> The shape of each bump would be based on the error in measurement that you expect to have (I think)
17:05:48 <ivanm> benmachine: wheeeee!!! http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=(\+f+-%3E+(\x+-%3E+f+(x+x))+(\+x+-%3E+f+(x+x)))+(%2B)+1
17:06:28 <ivanm> (the input is "(\ f -> (\x -> f (x x)) (\ x -> f (x x))) (+) 1" if the URL doesn't work properly)
17:06:50 <benmachine> ivanm: yes well done :P
17:07:08 <djahandarie> Cale, on the example used on http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/ , what is the significance of those numbers on the y-axis of the kernel estimate density graph?
17:07:20 <ivanm> I notice you cheated and put a time limit in it though :(
17:07:53 <mornfall> ivanm: Cheating, cheating. There's no defeating the halting problem without cheatcodes.
17:08:00 <mornfall> IDDQD!
17:08:09 <benmachine> ivanm: indeed
17:09:02 <Cale> The y axis is less important, since you're mainly interested in proportional area under the graph for different intervals along the x axis, so you could scale the y axis however you want, but the scale it shows is the one which makes the integral from -infinity to infinity of the graph equal to 1.
17:09:17 <ivanm> mornfall: hmmm?
17:09:22 <djahandarie> Okay, makes sense
17:09:55 <djahandarie> I think if I look at the code now I should be able to understand it. Thanks a bunch Cale
17:10:28 <c_wraith> -infinity?  How often do function times go negative?
17:10:40 <Cale> c_wraith: in this case, never
17:10:49 <Cale> So 0 to infinity is equivalent
17:11:03 * c_wraith needs to find some of these functions that make the rest of the program faster
17:11:09 <mornfall> ivanm: There's no telling if it would ever terminate otherwise. Maybe if he can guarantee that any given step terminates and only compute finitely many steps... Dunno.
17:11:15 <Cale> Actually, though, I think it's summing Gaussians
17:11:40 <benmachine> http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=let+foldr+%3D+%5Cf+z+xs+-%3E+case+xs+of%0D%0A+++++%5B%5D+-%3E+z%0D%0A+++++y%3Ays+-%3E+f+y+%28foldr+f+z+ys%29%0D%0A++++%28.%29+%3D+%5Cf+g+x+-%3E+f+%28g+x%29%0D%0A++++map+%3D+%5Cf+-%3E+foldr+%28%28%3A%29+.+f%29+%5B%5D%0D%0A+in+map+%282+%2B%29+%5B3%2C4%2C5%5D%0D%0A this map example only takes 33 steps now
17:11:41 <Cale> So, the kernel density estimate might actually have some positive probability density for negative values
17:11:42 <djahandarie> Cale, I was wondering why the wikipedia page was talking about that
17:11:47 <benmachine> also, m-m-m-monster URL
17:11:50 <mornfall> But I was just mostly trying to be funny.
17:12:00 <ivanm> mornfall: I meant the IDDQD statement!
17:12:10 <mornfall> Oh.
17:12:13 <mornfall> Joke fail. :)
17:12:29 <ivanm> heh
17:12:33 <mornfall> Now are you serious or are you pulling my leg? :)
17:12:34 <ivanm> benmachine: :o
17:12:43 <benmachine> I solved the halting problem by definitely halting everything >_>
17:12:43 <mornfall> Well, IDDQD is the God mode in Doom.
17:13:05 <ivanm> ahhhhh
17:13:06 <benmachine> but I guess that's not quite what turing had in mind
17:13:20 <ivanm> probably not
17:13:33 <mornfall> benmachine: Well, that's a well-known solution. The resulting machine is, of course, not Turing-complete. :)
17:13:41 <Cale> Gaussian distributed kernels are probably an acceptable approximation, but it's possible that there's a better choice to account for the lack of possibility of negative times.
17:13:58 <benmachine> mornfall: drat it
17:14:00 <Cale> I forget what probability distribution would be appropriate
17:14:40 <djahandarie> Cale, epanechnikov possibly (hehe)?
17:14:57 <mornfall> benmachine: Actually, there's a proof somewhere that a machine without halting problem cannot be Turing-complete. (It's probably quite trivial, too.)
17:15:05 <mornfall> +undecidable
17:15:36 <benmachine> yeah that doesn't surprise me at all
17:15:55 <mornfall> Another fun fact is, that halting oracles give a rise to infinite tower of ever-stronger machines.
17:16:20 <benmachine> hurray
17:16:43 <benmachine> because the halting of a machine with a halting oracle is not decidable by that machine, presumably
17:16:49 <mornfall> Indeed.
17:17:04 <benmachine> would you actually want to know whether a machine with a halting oracle halts or not?
17:17:13 <mornfall> Why not? :)
17:17:52 <benmachine> well I mean, a halting oracle will tell you if Goldbach's conjecture is true or false
17:17:58 <benmachine> a halting oracle oracle... what does it do?
17:18:43 <ivanm> it determines if something is a halting oracle or not?
17:20:21 <mornfall> It... answers. :)
17:20:58 <lament> banana scheme!
17:21:01 <lament> @google banana scheme
17:21:02 <lambdabot> No Result Found.
17:21:06 <lament> of course.
17:21:09 <Cale> I think the idea is that if something is interesting to do once, it might be worth trying again ;)
17:21:44 <benmachine> yeah I see the appeal from a completeness perspective
17:21:52 <Cale> (re: the halting oracle discussion)
17:22:31 <mornfall> It's just sexy.
17:22:42 <benmachine> it is!
17:22:52 <benmachine> but something can be sexy and useful or sexy and not-useful
17:22:59 <mornfall> On the other hand, if you have a result that all even numbers are expressible as a sum of O(1) primes, how useful it is to bound it to 2? :)
17:23:00 <benmachine> and both are fine but I wanted to know which one it was :P
17:23:28 <benmachine> do we have that result?
17:23:35 <Cale> Well, considering halting oracles at all is of a limited immediate practicality, since those don't exist.
17:23:50 <mornfall> benmachine: "In 1930, Lev Schnirelmann proved that every even number nÂ â¥Â 4 can be written as the sum of at most 20 primes. This result was subsequently improved by many authors; currently, the best known result is due to Olivier RamarÃ©, who in 1995 showed that every even number n Â â¥Â 4 is in fact the sum of at most six primes."
17:23:54 <benmachine> Cale: well, there is that minor detail I guess
17:24:00 <benmachine> oh
17:24:02 <benmachine> neat
17:24:10 <Cale> (at least, unless the universe has some more tricks up its sleeve and feels like giving us a halting oracle for free)
17:24:15 <benmachine> heh
17:24:31 <benmachine> we find it encoded in the spots of ladybirds, or something
17:24:37 <Cale> There's no way we could ever verify for sure that it really was a halting oracle anyway :)
17:25:06 <benmachine> would it be possible to demonstrate that something was a halting oracle using a halting oracle, I wonder
17:25:30 <mornfall> Cale: Yeah, it could've just been a damn good guesser. :)
17:25:33 <Stalafin> is there a way to make sure that i use a constant, i have predefined somewhere at the beginning of my document? for example, i might name a constant a, but say i make a function foo (a,b,c); i believe this is called shadowing? how can i make sure, this won't happen? is there any sort of conventino
17:25:34 <Stalafin> ?
17:25:39 <mornfall> Cale: Same issue with all sorts of prophets.
17:26:05 <Cale> Stalafin: try not to shadow any variables
17:26:23 <Cale> Stalafin: I think there might be a warning flag
17:26:28 <Stalafin> Cale: that's trying.... so would you say i'd just name all my variables accordingly?
17:26:34 <Stalafin> say, a_const
17:26:46 <Cale> -fwarn-name-shadowing
17:27:24 <DBAlex> benmachine: wow, that rocks
17:27:29 <Cale> Usually I give things names whose length is proportional to the size of their scope, and inversely proportional to their frequency of use.
17:27:33 <DBAlex> benmachine: how long did it take to write?
17:27:46 <Cale> Almost nothing at the top-level deserves a name with only one letter in it.
17:27:49 <DBAlex> benmachine: can I use this too help with proofs ? :)
17:27:53 <DBAlex> *to
17:28:20 <benmachine> DBAlex: all use is at your personal risk, code is highly immature :)
17:28:26 <Stalafin> Cale:  is this a compile flag?
17:28:29 <Cale> yeah
17:28:32 <DBAlex> benmachine: how long have you been working on it?
17:28:39 <benmachine> first git commit was Jan 22, was working on it before that
17:28:42 <DBAlex> benmachine: does it follow the way GHC evaluates ?
17:28:45 <DBAlex> wow
17:28:45 <benmachine> but not continuously since then
17:28:49 <DBAlex> It's very nice :)
17:28:53 <DBAlex> I'm impressed :)
17:28:55 <benmachine> thanks!
17:29:06 <benmachine> it doesn't specifically follow the ways of any compiler
17:29:14 <DBAlex> How long have you been programming Haskell ?
17:29:23 <benmachine> oh I don't even know
17:29:29 <benmachine> not that long
17:29:35 <DBAlex> oh ok
17:29:47 <benmachine> about a year?
17:29:52 <DBAlex> nice
17:29:52 <Cale> Stalafin: It's included by -Wall, but I find -Wall is annoying
17:29:58 <DBAlex> how long have you been programming in general ?
17:30:07 <ivanm> Cale: :o why?
17:30:21 <benmachine> maybe three years, not sure
17:30:22 <gio123> Cale: hi
17:30:24 <Cale> ivanm: It warns about stupid things
17:30:44 * ivanm just wishes there were ways of telling -Wall "I know this is a _____ but I'm doing it that way for a reason"
17:30:52 <ivanm> Cale: what do you consider stupid that it does?
17:31:11 <benmachine> ivanm: depending on context, there may be such ways
17:31:19 <benmachine> e.g. variables beginning with _ are not unused
17:31:19 <ivanm> orphan instances?
17:31:27 <benmachine> oh, no :P
17:31:47 <benmachine> can't you disable individual warnings with -fno- though?
17:31:52 <benmachine> or something
17:31:53 <DBAlex> oh nice
17:32:02 * DBAlex is embarassed
17:32:08 <ivanm> benmachine: yeah, but that's global then
17:32:16 <DBAlex> I've been writing Haskell for about a year, not sure I could write that though :-X
17:32:21 <benmachine> ivanm: well, you can't have everything >_>
17:32:32 <ivanm> I might be able to do it at the top of the file within a {-# ... #-} but it makes the code fuglier :s
17:32:34 <DBAlex> I guess I haven't been programmming all my projects in haskell
17:32:35 <ivanm> benmachine: yeah
17:33:00 <benmachine> DBAlex: if it helps, that year included the holiday before I came to university which must have been about three months long
17:33:31 <DBAlex> ah ok
17:33:37 <DBAlex> which uni are you at ?
17:33:51 <benmachine> cambridge
17:34:00 <DBAlex> nice :-)
17:34:03 <ezyang> benmachine: whoa!
17:34:11 <benmachine> 'tis
17:34:20 <ezyang> We should, uh, meet up next year when I'm in town :-)
17:34:28 <benmachine> ezyang: :o
17:34:42 <benmachine> who are you :P
17:34:56 <benmachine> (but, yes we should)
17:35:09 <ezyang> benmachine: I'll be doing the CME program
17:35:37 * benmachine has not heard of such a thing
17:36:29 <roboshibby> ben machine, all that code looked insane
17:36:37 <benmachine> roboshibby: noted
17:36:45 <roboshibby> what is it?
17:36:51 <benmachine> which?
17:38:54 <roboshibby> map stuff up scroll
17:38:57 <roboshibby> the 33 steps of it
17:39:18 <roboshibby> btw just read your site a lil. i implemented superclass defaults a few months back; was nice
17:39:40 <benmachine> really? did you tell anyone? :P
17:40:06 <benmachine> the 33 steps are the output of a program I'm writing that tries to show you how stuff is evaluated
17:40:34 <roboshibby> no, it's for my own lang im building
17:40:35 <roboshibby> nice
17:40:54 <benmachine> you can see the definitions for foldr and how they are expanded
17:42:06 <roboshibby> good work
17:42:10 <roboshibby> keep it up bmachine
17:42:11 <benmachine> thanks
17:42:22 <benmachine> am doing my best :)
17:48:23 <uDreamer> aa
17:51:26 <jgrimes> does anyone know why haskell-src-exts might be failing trying to parse something that is quasiquoted?
17:52:27 <ivanm> jgrimes: latest version?
17:52:42 <ivanm> simplest answer (assuming your code is correct): because there's a bug in hsx ;-)
17:52:57 <benmachine> looks like a bug
17:53:04 <benmachine> parseExp $ prettyPrint (QuasiQuote "foo" "bar")
17:53:07 <benmachine> fails
17:54:51 <ivanm> jgrimes: are you parsing an entire file?
17:54:56 <ivanm> or trying to parse a single snippet?
17:55:05 <jgrimes> ivanm, the entire file
17:55:18 <jgrimes> ivanm, using parseModule, haskell-src-exts 1.6.1
17:55:22 <jgrimes> so not the latest
17:55:24 <ivanm> there are a few times where ghc is more liberal than haskell-src-exts
17:55:31 <ivanm> jgrimes: email the maintainer and check with him
17:55:38 <jgrimes> ivanm, ok
17:56:50 <ivanm> benmachine: I get parse errors trying to parse single line of code
17:56:57 <ivanm> so it might be that it needs to parse an entire file
17:57:29 <ivanm> or else I was just using it wrong...
17:57:33 <benmachine> ivanm: parseExp and prettyPrint are supposed to round-trip, I think
17:57:33 <ivanm> nvm, seems to be working
17:57:46 <benmachine> although possibly only one way
17:57:46 <ivanm> benmachine: yeah, but I was trying to get it to parse a non-expression
17:57:58 <ivanm> (trying to parse foo = ...; when I dropped the foo = it worked)
17:58:16 <MaciejP> jgrimes: I think you have to use parseExpWithMode and then add TemplateHaskell to theh extensions list.
17:58:26 <ivanm> benmachine: anyway, I've never used quasi-quotation, so I'm not even sure if teh printExp is printing it properly
17:58:36 <ivanm> MaciejP: ooohhh, didn't think about that
17:58:47 <alex404_> Is real time programming feasible in haskell?
17:59:05 <jgrimes> Hmm, I thought it got the extensions from the top of the file you were parsing
17:59:08 <benmachine> alex404_: there's a lot of discussion about it
17:59:13 <jgrimes> I thought a comment somewhere on the haddock said that
17:59:18 <benmachine> some people get upset about the GC
17:59:25 <ivanm> jgrimes: oh, you have LANGUAGE pragmas? then yes, it does
17:59:31 <alex404_> Yah, that seems to be the deal breaker
17:59:47 <alex404_> Or at least, the big issue
17:59:49 <ivanm> IIRC, it's the _unpredictability_ of the GC that is the deal breaker
18:00:01 <alex404_> Hmmm...
18:00:03 <Cale> alex404_: You can do it via an embedded DSL
18:00:05 <benmachine> yeah I wasn't suggesting we should have no GC, that'd be strange
18:00:13 <Cale> alex404_: There are things like atom for hard realtime
18:00:14 <benmachine> oh, there's that too
18:00:24 <alex404_> Cale: Yah, I know about it
18:00:26 <Cale> http://hackage.haskell.org/package/atom
18:00:28 <Cale> ah
18:00:36 <pikhq> Hard-realtime GC is a bit harder.
18:00:47 <benmachine> who'd've thought
18:00:47 <alex404_> Cale: But it compiles a whole new kernel, right?
18:00:54 <Cale> hm?
18:01:00 <alex404_> Or maybe I misunderstood
18:01:03 <Cale> New kernel?
18:01:29 <alex404_> I was under the impression that it compiled down into its own kernel to be used in specific embedded applications
18:01:31 <Cale> No, your Haskell program generates a C program which is hard-realtime.
18:01:58 <Cale> Well, it's like a language which is embedded in Haskell for writing realtime programs.
18:02:50 <alex404_> Cool... and so I could write a GUI in GTK and whatever else, and then have this RT module running beside it?
18:03:57 <alex404_> And have its thread spitting stuff back into the GUI whenver there's free cycles
18:04:52 <qaa> visit new server /server -m irc.saknet.biz.tm:6667 6697-ssl
18:05:03 <qaa> visit new server /server -m irc.saknet.biz.tm:6667 6697-ssl
18:05:03 <qaa> visit new server /server -m irc.saknet.biz.tm:6667 6697-ssl
18:05:05 <alex404_> Oh cool, it claims it doesn't even need RTAI...
18:05:08 --- mode: ChanServ set +o Cale
18:05:18 --- mode: Cale set -o Cale
18:05:57 <Cale> What sort of realtime application are you writing?
18:06:17 <Cale> I'm sure you could use the generated C code and link a Gtk2Hs Haskell program with it.
18:06:42 <alex404_> I'm developing control software for a microscope...
18:06:49 <alex404_> And there's this technique called dynamic clamping...
18:07:11 <alex404_> Where you read voltages from neurons and pipe current back into other neurons...
18:07:18 <alex404_> Based on a simulation your running on your computer...
18:07:27 <alex404_> In effect implementing virtual neurons.
18:07:31 <alex404_> Obviously, the feedback needs to be real time.
18:08:29 <Cale> hmm, it might be suitable
18:08:36 <alex404_> So your basically just solving/simulating a dynamical system
18:09:11 <alex404_> Have you worked with it at all?
18:09:26 <Cale> I haven't, though I've looked at the various blog postings and such about it
18:10:01 <alex404_> Cool, well I'll take a second look.
18:10:05 <Cale> Writing your code in Atom is basically using a rather simple imperative language, but you can use Haskell as a fancy macro language for constructing complicated programs.
18:10:18 <alex404_> Right.
18:10:29 <alex404_> What do you mean by macro language?
18:10:40 <alex404_> (I know I should know this)
18:11:06 <Cale> I mean, when you run your Haskell program, it's going to generate a C program which you'll then compile using an ordinary C compiler.
18:11:32 <Cale> So the Haskell code isn't involved at the real runtime of the generated program, it's only involved in constructing that program in the first place.
18:11:59 <alex404_> I see.
18:12:10 <alex404_> So you still get the fun of functional programming.
18:12:18 <Cale> Some of it anyway
18:12:19 <alex404_> Outside of your imperative stuff, anyway
18:12:23 <Cale> yeah
18:12:43 <alex404_> Cool. I just found a link to some scientific applications too. So it might be just the right thing.
18:12:48 <ivanm> Cale: but you have to know C to be able to know how to generate it
18:12:55 <ivanm> which is a disadvantage... >_>
18:13:08 <ivanm> then again, if you're wanting low-level real-time, you probably know C already...
18:13:16 <alex404_> I know c
18:13:19 <Cale> ivanm: Well, you need to know atom, and sure, a little bit of C.
18:13:35 <alex404_> But why would you need to know it to generate the c?
18:14:11 <Cale> I think it doesn't write the .h files for you
18:14:20 <ivanm> to kind of know how to use atom properly/efficiently
18:15:04 <alex404_> The sounds perfect.
18:15:08 <alex404_> *this
18:16:01 <alex404_> Anyway, thanks for all the tips guys
18:16:02 <Cale> http://blog.sw17ch.com/wordpress/?p=111 -- an example of using atom to blink an LED on an arduino
18:16:19 <Cale> http://leepike.wordpress.com/2009/05/05/an-atomic-fibonacci-server-exploring-the-atom-haskell-dsl/ -- of course, there would have to be a fibonacci example ;)
18:17:49 <ezyang> Cale: IIRC, that is the sum total of the tutorialish literature on atom?
18:18:05 <Cale> I don't know
18:18:16 <Cale> It's the stuff that I was able to find easily
18:18:51 <ivanm> ezyang: maybe ask tom hawkins if he has a proper tutorial?
18:19:11 <Cale> http://cufp.galois.com/2008/schedule.html -- there's a talk slides and video linked from here
18:20:37 <Cale> Though it looks like some things have been renamed in fairly obvious ways since that was written
18:24:03 <jgrimes> ivanm, so I missed part of the docs "Note that the various parse functions in Language.Haskell.Exts.Parser never look at LANGUAGE pragmas"
18:24:23 <jgrimes> but parseFile in Language.Haskell.Exts does :)
18:25:31 <ivanm> jgrimes: heh
18:25:42 <ivanm> I always use parseFile, so didn't know that ;-)
18:36:34 <gwern> @wn ninnyhammer
18:36:35 <lambdabot> No match for "ninnyhammer".
18:36:39 <gwern> @wn ninny
18:36:39 <lambdabot> *** "ninny" wn "WordNet (r) 2.0"
18:36:40 <lambdabot> ninny
18:36:40 <lambdabot>      n : a stupid foolish person [syn: {nincompoop}, {poop}]
18:40:21 <Spaceghost> hello
18:40:26 <Spaceghost> :)
18:40:32 <roconnor> coast to coast
18:40:42 <Spaceghost> the same, lie
18:42:00 <ivanm> roconnor: did you notice that someone dug out your old anti-C++ blog post and was lambasting you on proggit?
18:42:00 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56 -- this talk (about using atom-generated programs to control hydraulics) was rather interesting :)
18:42:10 <roconnor> ivanm: oh crap
18:42:49 <ivanm> basically, it wasn't that C++ is bad, it's that you just can't code C++ and why were you doing such stupid things
18:43:32 <Spaceghost> where can I learn the basics things for learn haskell? for understand the recursives functions, and know how a interpreter work
18:43:33 <roconnor> ivanm: i'm told that there is a -weff-c-something flag that will warn about these sorts of things
18:43:46 <roconnor> @were lyah
18:43:46 <lambdabot> http://www.learnyouahaskell.com/
18:43:50 <roconnor> Spaceghost: ^^
18:43:59 <roconnor> for great good
18:44:37 <roconnor> who is esr?
18:44:40 <ivanm> roconnor: what sort of things?
18:44:44 <Zao> roconnor: That flag tends to do more harm than good.
18:44:50 <Spaceghost> *interpret
18:45:03 <ivanm> roconnor: http://en.wikipedia.org/wiki/Eric_Raymond
18:45:06 <Spaceghost> esr?
18:45:08 <roconnor> ivanm: the 200 things that effective c++ book tell you you need to do to program in c++
18:45:12 <ivanm> ahhh
18:45:12 <SamB_XP> lol
18:48:42 <roconnor> surprisingly esr has summerized haskell fairly well
18:49:04 <esr> Er, why did you exprct me to do a poor job?
18:49:54 <dobblego> esr, it's an exception, not the norm
18:50:11 <roconnor> esr: I think most people who dabble in Haskell miss the point
18:50:22 <esr> I see.
18:51:11 <esr> Well, I had the right backgriund to get it quicjkly.  Old LISPer, ex-mathematician - probably doesn't get much more appropriate than that.
18:51:40 <ivanm> methinks your description of variables has a problem
18:51:48 <ivanm> usually they aren't re-evaluated each time
18:51:50 * SamB_XP wonders where esr got this: "the value of the variable is a promise to re-evaluate the expression on the right side of the assignment whenever the variable is evaluated"
18:52:00 <ivanm> SamB_XP: yeah, that's what I'm talking about
18:52:11 <SamB_XP> oh, yeah, ivanm went and said it while I was copy+pasting that!
18:52:15 <SamB_XP> how sneaky of him!
18:52:33 <ivanm> > "mw" ++ cycle "ah"
18:52:34 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
18:52:43 <SamB_XP> shh!
18:52:46 <dobblego> one of the comments incorrectly states that this is not the case and is guaranteed by Haskell98, then another comment says that comment is incorrect
18:52:52 <SamB_XP> if my dog hears that, she'll expect pettings!
18:52:52 <ivanm> heh
18:52:59 <ivanm> didn't really bother with the comments
18:53:11 <ivanm> SamB_XP: you have a speech synthesizer hooked up to your IRC client?
18:53:12 <Cale> Actually, the language spec doesn't say anything about evaluation.
18:53:12 <roconnor> ivanm: do you have a link to the comments on reddit about my blog post about my terrible c++ skills?
18:53:16 <aavogt> does \bot have vacuum?
18:53:20 * ivanm looks
18:53:24 <dobblego> Cale, that was the correction to the incorrection
18:53:27 <Cale> But in practice, the value of a variable will never be evaluated more than once.
18:53:35 <SamB_XP> Cale: never?
18:53:40 <Cale> (as long as it remains in scope)
18:53:42 <SamB_XP> I heard it sometimes happens with threads!
18:54:04 <copumpkin> aavogt: lunabot did
18:54:15 <aavogt> :(
18:54:16 <c_wraith> it can happen with threads.  Which might be an issue if you're unsafePerformIOing
18:54:16 <SamB_XP> something to do with not wanting to fully serialize the black-holing
18:54:25 <Cale> Oh, there's a *tiny* fraction of time where two threads can start evaluating the same value, but there are protections against this happening very often.
18:54:26 <aavogt> preflex: seen lunabot
18:54:26 <preflex>  lunabot was last seen on #haskell 39 days, 19 hours, 31 minutes and 39 seconds ago, saying:  31
18:54:42 <SamB_XP> c_wraith: that's why unsafePerformIO now has two flavours, one for when that's okay and one for when it isn't
18:55:00 <ivanm> SamB_XP: what's the other flavour then? (as in the name)
18:55:00 <Cale> Statistically, it only happens extremely rarely, even if you try to make it happen.
18:55:01 <c_wraith> SamB_XP: really? cool.  What's the new one called?
18:55:02 <SamB_XP> instead of just one, that might stop halfway through the unsafePerformIO, like we used to have!
18:55:11 <SamB_XP> I can't remember :-(
18:55:25 <SamB_XP> see GHC.*
18:55:41 <ivanm> roconnor: http://www.reddit.com/r/programming/comments/bbifx/programming_in_c_is_not_humanly_possible/
18:55:47 <esr> SamB_XP: If that's the worst error in the summary I'm happy.  I was thinking about how the language behaves in a logical sense, not the implementation and whatever sort of cachjing it has.
18:56:06 <ivanm> esr: that's the only glaringly obvious error I saw
18:56:11 <SamB_XP> esr: didn't finish reading yet
18:56:17 <ivanm> the rest can be put up to interpretation
18:56:25 <SamB_XP> I just started now when someone else said he didn't much like it ;-)
18:56:25 <ivanm> (in terms of you thinking about how it works differently than I do)
18:56:31 <ivanm> SamB_XP: heh
18:59:22 <ivanm> roconnor: no idea why someone suddenly stumbled across such an old blog post of yours...
18:59:33 <roconnor> ivanm: i told shapr about it yesterday
18:59:39 <roconnor> then he twitted it
18:59:43 <ivanm> ahhh
18:59:51 <roconnor> but that's okay
18:59:58 <roconnor> I wrote that 6 years ago
19:00:04 <roconnor> and I was angry
19:00:41 <ivanm> roconnor: well, I got that
19:00:48 <ivanm> obviously the people who cared on reddit didn't
19:00:56 <ivanm> anyway, so it's all shapr's fault?
19:01:24 <tsou> is there a way to use the "case .. of" matching and group some alternatives together?
19:01:30 <tsou> (if that made any sense at all)
19:01:35 <copumpkin> no
19:01:36 <roconnor> ivanm: more like it is the internets fault
19:01:51 <ivanm> heh
19:01:51 <tsou> copumpkin: no there isn't, or no it made no sense?
19:01:55 <roconnor> tsou: not really that I know of.
19:01:58 <copumpkin> no it isn't possible
19:02:10 <tsou> ok thanks
19:02:34 <ivanm> tsou: do you mean somethink like: case x of 1,2 -> ... ?
19:02:40 <copumpkin> it could be done
19:02:41 <ivanm> if so, then you can't do that
19:02:44 <copumpkin> you should submit a proposal
19:02:46 <tsou> ivanm: yes
19:02:57 <ivanm> well, yeah, you can't do that _yet_
19:03:23 <SamB_XP> is it legal to carry a concealed Haskell without a license?
19:03:26 <ivanm> but IMHO anonymous case statements would be preferred over this :p
19:03:41 <ivanm> SamB_XP: there's no law explicitly against it...
19:03:42 <tsou> ivanm: what do you mean?
19:03:47 <ivanm> how are you concealing it pray tell?
19:04:12 <esr> SamB_XP was making a joke about me and pistiols, I think.
19:04:13 <SamB_XP> I, uh, keep it in a holster in my armpit ?
19:04:14 <ivanm> tsou: the ability to do something like getLine >>= case of ...
19:04:26 <ivanm> heh
19:04:44 <roconnor> does std:vector do copy on write?
19:04:57 <ivanm> *shrug* ask in ##c++? :p
19:05:17 <c_wraith> preflex: seen god
19:05:17 <preflex>  god was last seen on ##c++ 158 days, 3 hours, 59 minutes and 51 seconds ago, saying: I don't really know either actually
19:05:18 <SamB_XP> roconnor: well, I hear *some* std::string implementations do and some don't
19:05:36 <SamB_XP> (some of them copy before then)
19:05:50 <roconnor> #c++ says "god no"
19:05:57 <ivanm> anyway...
19:05:59 <SamB_XP> no idea about about how std::vector works
19:06:03 <Spaceghost> the comercial language more similar to haskell is python? or use a interpret and convert haskell in C?
19:06:04 <Spaceghost> :P
19:06:13 <ivanm> @remember SamB_XP is it legal to carry a concealed Haskell without a license?
19:06:14 <roconnor> I don't get the comment that using std::vector wouldn't copy things zillions of times.
19:06:14 <lambdabot> I will never forget.
19:06:30 <ivanm> (since jfredett will get annoyed if we don't provide him with enough quotes :p )
19:06:35 <SamB_XP> oh, wait, I guess it isn't -- you could get sued for copyright violation!
19:06:39 <tsou> ivanm: i can't see the relation :(
19:06:44 <Zao> You couldn't really do CoW for vectors, as you have to let things like taking the address of the first element and indexing as array work.
19:07:08 <Zao> vector is a too thin abstraction for doing efficient CoW.
19:07:14 <ivanm> tsou: the relation is, if they were going to change the syntax of case statements I'd prefer them do anonymous case statements first over grouped alternatives
19:07:26 <SamB_XP> Zao: taking the address, obviously, would have to also trigger the copy, if you took it as a non-const *
19:07:43 <Zao> SamB_XP: Indexing requires a value of the held type, not a proxy.
19:07:54 <tsou> ivanm: aaah ok, now i got you :P
19:07:54 <Zao> So you'd suffer the cost at any element access.
19:08:14 <SamB_XP> Zao: hmm, can't you give a const & ?
19:08:46 <Zao> I'm a bit vague on the semantics, but I believe that it's legal to cast the const away from the reference returned.
19:08:54 <Zao> Insane, but legal.
19:09:06 <SamB_XP> is it legal to WRITE to such a pointer ?
19:09:14 <Zao> I believe so, yes.
19:09:20 <SamB_XP> that's not UB?
19:09:26 <Zao> As long as the value involved is not originally const.
19:09:55 <Zao> So you can say things like  int x; int const& y = x; const_cast<int&>(y) = 3;
19:10:13 <Zao> const is so loose, you cannot really optimize much at all around it.
19:10:36 <tanash> hi
19:10:45 <tanash> what this channel about?
19:10:57 <Zao> Of course, anyone actively exploiting such behaviour should be shot on site.
19:11:06 <Zao> tanash: The most awesome programming language Haskell.
19:11:08 <copumpkin> tanash: how did you find it?
19:11:33 <tanash> i dont know anything about it
19:12:50 <tensorpudding> how did you get here?
19:13:19 <SamB_XP> was it on a toplist or something ?
19:13:19 <ivanm> tanash: http://en.wikipedia.org/wiki/Haskell_(programming_language)
19:13:53 * copumpkin goes back to his translation of the agda ring solver to haskell
19:14:05 <Zao> http://www.parashift.com/c++-faq-lite/const-correctness.html#faq-18.13 by the way.
19:14:45 <copumpkin> eugh
19:14:50 <SamB_XP> Zao: is there an FQA for it ?
19:15:06 <aavogt> @fqa
19:15:07 <lambdabot> Maybe you meant: faq ft
19:15:53 <Zao> SamB_XP: Wouldn't surprise me. I hate those FQAs.
19:16:25 <SamB_XP> Zao: how come ?
19:16:45 <SamB_XP> aavogt: we question lambdabot's answer to @faq ourselves ;-P
19:16:47 <Zao> SamB_XP: Overly trolly.
19:16:51 <SamB_XP> @faq are you gay?
19:16:52 <lambdabot> The answer is: Yes! Haskell can do that.
19:17:02 <Zao> For reference, although I loathe it - http://yosefk.com/c++fqa/const.html#fqa-18.13
19:17:02 <copumpkin> @faq am I gay?
19:17:02 <lambdabot> The answer is: Yes! Haskell can do that.
19:17:16 <SamB_XP> @faq will you marry me?
19:17:16 <lambdabot> The answer is: Yes! Haskell can do that.
19:17:47 <SamB_XP> Zao: my understanding is that C++ is more of a troll than the FQA is ;-P
19:19:52 <ivanm> grrr.... people publishing in obscure journals resulting in not being able to get a copy of their paper online :@
19:21:30 <SamB_XP> ivanm: who ? when ?
19:21:35 <SamB_XP> what about ?
19:23:04 <ivanm> http://www.zentralblatt-math.org/zmath/en/search/?q=an:1045.05060&format=complete
19:25:10 <copumpkin> I like the PDF version of the abstract
19:25:36 <Spaceghost> a pdf of what?
19:25:54 <ivanm> an abstract
19:25:55 <Spaceghost> I need a program for edit a pdf
19:26:01 <ivanm> copumpkin: yeah, the mathml version isn't too bad
19:26:03 <copumpkin> ivanm: it's on springerlink
19:26:09 <ivanm> copumpkin: :o
19:26:18 <Spaceghost> for then use a program to convert in text
19:26:23 <ivanm> then why doesn't zentralblatt link to it? it links to all the other ones on springerlink...
19:26:24 <copumpkin> oh wait
19:26:31 <copumpkin> it isn't the same paper
19:26:34 <ivanm> Spaceghost: there's heaps of pdf -> text programs
19:26:38 <ivanm> for editing pdf, not as many
19:26:49 <ivanm> acrobat, foxit has one IIRC
19:26:57 <ivanm> for *nix, pdfedit has limited capability
19:27:01 <ivanm> copumpkin: heh
19:27:05 <Spaceghost> uhmm
19:27:05 * ivanm might try arxiv
19:27:26 <Spaceghost> acrobat and foxit are free to in her editer version?
19:28:18 <ivanm> nope
19:28:25 <ivanm> Spaceghost: no, you have to pay for them
19:28:30 <ivanm> (foxit might have a trial, can't recall)
19:28:49 <Spaceghost> :/
19:29:32 <Spaceghost> I test using a program called ABBYY or similar, for convert to text
19:29:44 <Spaceghost> but the only, the only problem that I have
19:29:52 <ivanm> Spaceghost: is it a text-based pdf or an image-based one
19:29:56 <Spaceghost> is that the pdf is 90Âº rotate
19:30:09 <ivanm> if it's scanned or something, then you won't be able to do much with ABBYY
19:30:15 <ivanm> oh, wait, that's an OCR
19:30:21 <Spaceghost> yes
19:30:28 <ivanm> Spaceghost: you _might_ be able to do that in some freebie ones
19:30:34 <ivanm> even using something like ghostscript
19:31:27 <Spaceghost> I can't undestand the last
19:32:56 <Spaceghost> well, I am searching the form of I can get a good print of this book, because is probabily a bad scan, but is the only that I have, this book doesn't selled in my country
19:33:22 <Spaceghost> I only can find in a library but in another language
19:34:33 <ivanm> books.google.com ?
19:34:38 <Spaceghost> my teachers put him on the site of my university, I think that maybe isn't have problems of copyrights
19:34:47 <ivanm> ahhh
19:35:50 <Spaceghost> is a book in portuguese, spanish is my native language, so isn't hard to me
19:36:54 <Spaceghost> but, if I will get a fotocopy or a impression (printed?) I think that will be better, that I make with the spanish translate
19:37:21 <ivanm> *shrug*
19:37:36 <Spaceghost> xD
19:37:37 <Spaceghost> sorry
19:38:02 <Spaceghost> this isn't a good channel for talk of this
19:38:05 <Spaceghost> :P
19:39:38 <pookleblinky> Spaceghost, see if there are and biblio chans
19:40:22 <Spaceghost> biblio chans?
19:41:03 <pookleblinky> #books (no ebooks, apparently), ##literature etc
19:41:08 <Spaceghost> ahh
19:41:16 <Spaceghost> channels
19:41:38 <pookleblinky> Ah, nice. There's a #SICP
19:45:42 <Spaceghost> well, probabily in anothers networks
19:45:46 <Spaceghost> pookleblinky, where?
19:46:21 <pookleblinky> Spaceghost, on FreeNode
19:47:27 <Spaceghost> I am at now in this, and only entered valentingolev by curiosity I think
19:47:28 <Spaceghost> xD
19:51:19 <valentingolev> omg
19:51:48 <Spaceghost> xD
19:53:47 <copumpkin> are there any nice parsing libs that sit on Data.Text yet?
19:57:05 <ivanm> copumpkin: nope
19:57:10 <ivanm> someone was asking about that before
19:57:11 <copumpkin> :(
19:57:37 <ivanm> your best bet is to write a custom instance of a pre-existing parsing class, or else to convert it to bytestrings and parse bytestrings
19:58:13 <copumpkin> meh
19:58:21 <copumpkin> bytestrings don't abstract unicode away
20:00:23 <ivanm> true
20:00:37 <ivanm> but it might be possible to get it going with say Polyparse's parsing class
20:01:40 <metaperl> time to get rid of lpSortFunc ( http://pastie.org/pastes/864173 ) and use (comparing listLength)
20:03:49 * ivanm prefers compare  `on` f to comparing f
20:07:01 * hackagebot Bravo 0.1.0 - Static text template generation library  http://hackage.haskell.org/package/Bravo-0.1.0 (MatthiasReisner)
20:18:30 <metaperl> could someone explain how deriving Ord here ( http://pastie.org/864495 ) leads to Haskell being able to know the position of a type it has never seen before
20:19:05 <ivanm> "position"?
20:19:38 <Zao> A type it has never seen?
20:19:45 <ivanm> metaperl: first of all, note that that sortByLength function is very inefficient
20:19:57 <ivanm> @src comparing
20:19:58 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:20:03 <ivanm> @type comparing
20:20:04 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
20:20:37 <ivanm> metaperl: given two values x and y, comparing lengthNat will apply lengthNat to both and then use the derived Ord instance to see which is bigger
20:20:39 <Zao> metaperl: Earlier ctors are considered "before" later ctors.
20:20:40 <ivanm> @src sortBy
20:20:40 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:20:50 <ivanm> sortBy uses that ordering to sort the elements
20:20:57 <ivanm> Zao: "ctors"?
20:21:01 <Zao> If a ctor has fields, they are lexicographically ordered.
20:21:03 <Zao> ivanm: Constructors.
20:21:21 <ivanm> ahhh
20:21:26 <metaperl> yes, earlierctors I can see for Zero versus Succ
20:21:27 <SamB_XP> ivanm: you never heard of ctors_aux or dtors_aux ?
20:21:31 <ivanm> nope
20:21:34 <SamB_XP> or whatever those things are called ?
20:21:39 <metaperl> but what about comparing Succ Zero with Succ (Succ Zero) ?
20:21:53 <SamB_XP> you must not muck around with ELFs enough ...
20:21:56 <ivanm> metaperl: Succ (Succ Zero) has an extra constructor so it's larger
20:22:03 <ivanm> SamB_XP: as in the binary format on linux?
20:22:04 <Zao> metaperl: The outer ctor is the same, so it looks at the first field.
20:22:13 <Zao> Which compares Zero with (Succ Zero).
20:22:34 <metaperl> oh
20:22:38 <copumpkin> Peano naturals succ
20:22:53 <Zao> They do nat!
20:23:04 <SamB_XP> lol
20:23:18 <idnar> haha
20:23:42 <metaperl> yes, I agree it is inefficient ivanm. The cleverest solution was neat - it terminated once either list reached zero elements instead of taking the length of either sequence outright
20:23:59 <copumpkin> Mu Maybe
20:24:06 <copumpkin> :k Mu Maybe
20:24:07 <lambdabot> *
20:24:18 <copumpkin> > In Nothing
20:24:19 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
20:24:19 <lambdabot>    arising from a u...
20:24:29 <ivanm> metaperl: it would be better with a swarczian transform (however you spell it)
20:24:37 <SamB_XP> :t In
20:24:38 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
20:25:02 <djahandarie> Criterion returns something like "std dev: 1.324608 s, lb 1.114684 s, ub 1.510580 s, ci 0.950" for a benchmark. How would you have a lower and upper bound for a standard deviation?
20:25:13 <ivanm> is that (capital i)n or (lowercase L)n ?
20:25:20 <ezyang> djahandarie: The thing about a normal distribution is that it doesn't have a lower or upper bound
20:25:22 <ivanm> my font makes them look the same :s
20:25:35 <SamB_XP> hmm, now I can't tell whether to pronounce it "MU" like "neither yes nor no", or mew, like a cat!
20:25:38 <ivanm> djahandarie: the error in the standard deviation?
20:26:06 <ivanm> cats go more like "meow", not "mew" (which rhymes with "yew" or "you")
20:26:07 <copumpkin> ivanm: an eye
20:26:09 <djahandarie> How would you even calculate that?
20:26:15 <ivanm> copumpkin: for an eye? :p
20:26:16 <ivanm> right
20:26:22 <copumpkin> yep :)
20:26:38 <metaperl> ivanm: actually I disagree about decorate-sort-undecorate ... here is the cleverest solution - http://pastie.org/864495
20:26:42 * ezyang wishes he was better versed in statistics, but hasn't had a really good reason to learn properly 
20:27:00 <SamB_XP> ivanm: and yet you understood how to pronounce the word!
20:27:05 <djahandarie> Maybe those numbers are mean-std and mean+std
20:27:05 <tomberek> Alpounet: yo
20:27:07 * djahandarie goes to check
20:27:15 <metaperl> This is all about the comments on question #6 - http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
20:27:33 <djahandarie> Wait no, definitely not.
20:27:56 <ezyang> djahandarie: Check out the pictures here: http://en.wikipedia.org/wiki/Normal_distribution
20:28:12 * copumpkin only uses abnormal distributions
20:28:13 <ezyang> especially this one: http://en.wikipedia.org/wiki/File:Standard_deviation_diagram.svg
20:28:17 <ivanm> SamB_XP: greek letters and physics... go figure ;-)
20:28:26 <ivanm> copumpkin: yes, but then again you _are_ abnormal
20:28:28 <ezyang> copumpkin: Gaussian would be so proud of you ;-)
20:28:30 <ivanm> so that only makes sense
20:28:32 <copumpkin> yep :)
20:28:57 <SamB_XP> ezyang: the guy was named Gauss
20:29:17 <djahandarie> ezyang, right. So what would be the lower bound in that picture?
20:29:23 <ivanm> metaperl: except you're not using that...
20:29:42 <metaperl> ivanm: my solution is ridiculously ornate... I just posted it to that thread
20:30:09 <ivanm> and whilst compareListsByLength _might_ be more efficient (if you use lazy Natural values using length might suffice, especially with repeated comparisons), the extra code you write is probably not worth it
20:30:23 <ivanm> because if you really have that many long sub-lists to sort, you're probably doing it wrong
20:32:12 <ezyang> SamB_XP: Right. >.>
20:32:50 <ezyang> djahandarie: The point is, there is none. As you go further left/right, the probability of any given sample being that value goes down to absolutely miniscule values, but it's not zero.
20:33:09 <djahandarie> ezyang, exactly, so what in the world is Criterion returning?
20:33:40 <ezyang> I assume that because Criterion is doing a finite number of samples, there really are upper and lower bounds
20:34:18 <djahandarie> Yes, there are upper and lower bounds. There are also upper and lower bounds for the std deb.
20:34:21 <djahandarie> dev*
20:34:37 <djahandarie> Oh you know, I think it bootstraps
20:34:45 <ezyang> Oh, I think I misparsed your question
20:35:06 <djahandarie> So maybe it is taking that into consideration and doing the lb and ub for all the resamples
20:35:18 * djahandarie needs to go read more about bootstrapping
20:35:34 <ezyang> Reading the criterion code might be enlightening here :-)
20:36:10 <djahandarie> Oh yeah, forgot about that. >_>
20:36:36 <ezyang> alternatively finding criterion's author and asking :-).
20:37:03 <djahandarie> I already asked Bryan but he's a busy guy
20:38:30 <djahandarie> Oh yeah, definitely has to do with the bootstrapping
20:40:50 <djahandarie> Yikes lots of formulas going on
20:53:16 <roboshibby> bow chika bow wow
20:54:55 <asdf1> why is haskell so hard to learn?! :D
20:55:26 <roboshibby> you kidding? i taught my dog spanky about monads
20:56:31 <djahandarie> With all the dog analogies it was probably easier for the dog than us
20:57:11 <ivanm> asdf1: it isn't hard to learn
20:57:20 <ivanm> the hard part is forgetting what you _thought_ was programming
20:57:42 <mgsloan> http://esr.ibiblio.org/?p=1796#comment-250815
20:57:49 <mgsloan> would you guys say I'm wrong?
20:58:04 <mgsloan> is it only I that thinks the point of haskell isn't too prove things about code?
20:58:08 <esr> I just read that and replied.
20:58:29 <mgsloan> :) thanks :D
20:58:33 <mgsloan> btw, loved the book
20:58:42 <mgsloan> it's kinda crazy to talk to someone you've mythologized
20:58:45 <esr> Which one?
20:58:54 <mgsloan> cathedral + bazaar
20:58:56 <roconnor> Zao: why does -Weffc++ cause more harm than good?
20:59:00 <esr> Ah.
20:59:11 <roconnor> Zao: granted I have never tried it myself.
20:59:37 <esr> Please don't hold my awesomeness against me.  Uh, wait... :-) :-) :-)
20:59:42 <ezyang> mgsloan: Reasons "most emphasized" are always a wasy thing
20:59:49 <mgsloan> roight roight
21:00:01 <Zao> roconnor: Some of the things it warns about are inefficient to fix, or working around them would produce ugly code.
21:00:07 <mgsloan> still, I don't think the reasons enumerated are the persuasive ones
21:00:12 <Zao> roconnor: I do not use the switch myself, I go mostly on hearsay.
21:00:29 <ezyang> *washy
21:00:36 <roconnor> Zao: I haven't programmed in C++ since learning about this flag
21:00:42 <mgsloan> while I do care about proving things about code, I think the value of that is the ability for YOU to reason about the code
21:01:10 <mgsloan> but anyway, it's good to hear that you have been in active communication with the community, esr.
21:01:21 <ezyang> Because there is no cabal (ahem) that comes together and says, "this is the unified front that the Haskell community should put forward to the world!"
21:01:38 <mgsloan> yeah, of course not
21:01:45 <roconnor> mgsloan: I don't know if the "point" of haskell is to prove things about code, but one of the major things I like about Haskell is that the code is easy to reason about (denotationally speaking).
21:01:46 <mgsloan> noone can claim to be a representative
21:01:58 <roconnor> major, major things
21:02:06 <mgsloan> exactly my feeling, roconnor
21:02:20 <esr> Being a participant-observer anthropologist among the hackers is sort of my specialty...
21:02:21 <roconnor> Actually I think I got into Haskell because it was sort of like Coq.
21:02:30 <roconnor> I don't recall clearly though
21:02:40 <ezyang> And so in my case, I think all of those things are reasons I'd bring up if I was trying to convince someone why they should pay attention to Haskell
21:02:53 <ezyang> esr: Don't you ever get the "oh man it's esr" reality distortion field?
21:03:11 <roconnor> mgsloan: ah, I see we are agreeing then
21:03:20 <esr> Yes.  I try to pass it off wuth a joke or three.
21:04:20 <esr> Like.  "Dammit.  In my *next* life, I plan to become a legend in a tribe full of hot babes!"
21:04:41 <p_l> esr: a noble goal
21:04:56 <Berengal> esr: You plan on becoming Paris Hilton?
21:05:07 <esr> Yiiiii.
21:05:12 <p_l> ROTFL
21:05:58 * esr hides
21:06:03 <mgsloan> roconnor: yup, esr is saying that we tend to mostly just talk about proving things about code :D  and that's ok, we do talk about that an awful lot
21:06:17 <pookleblinky> ezyang, it's probably like that farside comic
21:06:31 <ezyang> pookleblinky: ?
21:06:31 <pookleblinky> Where the zookeeper suddenly has an attack of 24 years of pentup willies.
21:06:36 <Berengal> I'm actually more content /not/ proving things about code. I leave that to the compiler
21:06:49 <mgsloan> right, and that's the wonder of the type system
21:06:51 <pookleblinky> You'll be talking to esr, then suddenly turn into a shouting Beatlemania girl.
21:07:07 <Berengal> One of the larger reasons I like Haskell is because I can make the compiler do half my work for me
21:07:07 <ezyang> pookleblinky: But I like the Beatles...
21:07:10 <esr> esr hides some more
21:07:10 <pookleblinky> I bet he gets that alot. Then has to smack them.
21:07:30 <ksf> yay http://www.reddit.com/r/haskell/comments/bbup5/ghc_calling_convention_committed_into_llvm_head/
21:07:34 <pookleblinky> "hey hey! Hey! stfu. We were talking about multiple assignment."
21:07:42 <mgsloan> aww, poor esr, I wonder what food will fetch him out of hiding
21:07:55 * mgsloan smacks with trout
21:08:00 <mgsloan> that didn't work, hrmmm
21:08:01 <ivanm> quick! we need some haskell in here!
21:08:12 <mgsloan> om nom nom noms
21:08:13 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:08:14 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
21:08:18 <ivanm> *phew*
21:08:24 <esr> There's sort of a normal distribution.  Fanboys at one end, haters at the other, and a big bulge of "do you get the reality distortion field a lot?" in the middle.
21:08:27 <mgsloan> oh god that felt good
21:08:32 <pikhq> ivanm: \x->undefined
21:08:45 <ezyang> esr: I found your comments about category theory obscuring Haskell itneresting. I'm working through a CT textbook right now.
21:08:51 <pookleblinky> Fibbonacci is a terrible benchmark precisely because it's so addictive.
21:08:55 <ivanm> heh
21:09:33 <roconnor> esr: there are two articles that I think you might like: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/  and http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
21:09:46 <esr> roconnor: Looking...
21:09:59 <roconnor> actually that goes for everyone else in #haskell who hasn't already read them.
21:10:31 <ezyang> ooh, the compact space one
21:10:38 <roconnor> ya
21:10:50 <roconnor> it still blow my mind, even today
21:10:56 <roconnor> *blows
21:11:02 <pikhq> esr? Would this happen to have any relation to the well-known ESR?
21:11:21 <enthymene> hunh?
21:11:23 <enthymene> oh
21:11:24 <djahandarie> An identity relation yes
21:11:31 * pikhq looks up. Yes.
21:11:40 * ivanm passes pikhq a chill pill
21:11:45 <pookleblinky> This esr has a goatee, hence is the evil one.
21:11:47 <pikhq> esr: Nice work on the Jargon File, and let there be lambda.
21:12:05 <enthymene> hehe
21:12:22 <esr> I do *not* have a goatee.  I have a moustache.  And I'm only *slightly* evil.
21:13:15 <psykotic> here goes the neighborhood
21:13:15 <enthymene> So this is the real ESR, and not the "Mirror, Mirror" ESR
21:13:22 <mgsloan> the funny thing about my comment is that it completely agrees with the main sentiment of haskell being mathematical peaps -> mathematical peaps
21:13:25 <pookleblinky> Only an evil man would rather admit to a mustache than a goatee.
21:13:32 <mgsloan> furthermore asserting that if you actually want to be seriously programming you should be in with the mathematical peaps
21:13:47 <psykotic> pikhq: by nice work, you mean ruin gls's excellent work with personal bias?
21:13:51 <esr> enthymene: I'm afraid so. Unless you actually *want* an hour in the agonizer booth.
21:14:05 <enthymene> heh.
21:14:15 <pikhq> pookleblinky: No, no, no. An evil man would be proud of his goatee.
21:14:22 <enthymene> I know I am
21:14:24 <copumpkin> psykotic: aw come on :P
21:14:31 <psykotic> :)
21:14:33 <enthymene> on an unrelated note, browse-url-at-point is wonderful
21:14:35 * pikhq is too lazy to trim. Full UNIX beard instead.
21:14:47 * copumpkin has no facial hair :o
21:14:54 * jmcarthur has a full beard that magically looks trimmed
21:14:54 <copumpkin> except for eyebrows, I guess
21:14:58 <ivanm> > nubBy(((>1) .) . gcd) [2..]
21:14:59 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:15:01 * Berengal has a moustache AND a goatee
21:15:06 <copumpkin> ivanm: that's too long
21:15:10 <pookleblinky> I think Knuth might have been the only beardless wizard.
21:15:11 <djahandarie> roconnor, whoa those are some cool posts
21:15:16 * jmcarthur is just too lazy to shave, but is planning to soon
21:15:19 <enthymene> yeah, the beard is something I felt I had to earn, hence my goatee.  But then I always wanted to be a wizard.
21:15:23 <ivanm> copumpkin: trying to steer this conversation back on topic
21:15:39 <ivanm> and less about "omg, esr is _the_ esr"
21:15:46 <Berengal> > nubBy (fmap fmap fmap (==0) mod) [2..]
21:15:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:15:55 <pikhq> ivanm: nubBy(((>1).).gcd)[2..] is the typical rendition of that insanity.
21:16:02 * jmcarthur feels like maybe he's been missing out by not knowing who esr is
21:16:03 * ivanm did a copy-pasta
21:16:08 <djahandarie> > nubBy ( (.) (.) (.) (==0) mod) [2..]
21:16:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:16:11 <psykotic> > filterM (const [False, True]) [1,2,3,4]
21:16:12 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
21:16:13 <djahandarie> Hahahahahahahaha
21:16:15 <djahandarie> hahahahahah
21:16:17 * djahandarie coughs
21:16:23 <enthymene> djahandarie is channeling mark hammil
21:16:34 <enthymene> and mark's not even dead!
21:16:39 <copumpkin> > beardLength "esr"
21:16:41 <lambdabot>   1
21:16:43 <roconnor> > nubBy ( fmap fmap fmap (==0) mod) [2..]
21:16:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:16:48 <copumpkin> > beardLength "jmcarthur"
21:16:49 <lambdabot>   5
21:16:53 <roconnor> sounds kinda dirty
21:16:55 <ezyang> > beardLength
21:16:56 <lambdabot>   * Exception: <local>:4:16-101: Non-exhaustive patterns in case
21:17:02 <ezyang> mermerm?
21:17:12 <mgsloan> jmcarthur: it's only ok if you're acctually John Mccarthy
21:17:44 <esr> That first one has a spooky connection (OK, not so spooky) with some stuff I was reading this morning about constructive analysis. The link is the  modulus of uniform continuity.
21:17:52 <roconnor> djahandarie: Oleg's response to these posts was "Oh, but everyone knows this"
21:18:04 <djahandarie> ... haha
21:18:19 <ezyang> <3 Oleg
21:18:20 <djahandarie> One day...
21:18:23 * djahandarie looks into the future
21:18:27 <enthymene> ugh, speaking of math, I should really be studying some >.>
21:18:39 <copumpkin> > beardLength "rms"
21:18:40 <lambdabot>   Not in scope: `beardLength'
21:18:44 <pikhq> roconnor: Yes, but that's Oleg. He makes type-level computation seem like a sane way of coding when he talks about it.
21:18:46 <copumpkin> asshole
21:18:54 <copumpkin> I bet it was ivanm
21:19:01 <roconnor> esr: constructive analysis was my thesis topic.
21:19:01 * ivanm looks innocent and whistles
21:19:02 <enthymene> > beardlength "zztop"
21:19:03 <lambdabot>   Not in scope: `beardlength'
21:19:21 <esr> OK, I get it.  This works like the constructive reformulation of Robinson's nonstndard analysis.  Wild - before this morning I wouldn't have known enough to notice that.
21:19:42 <pookleblinky> Haskell: it can iterate over Cantor Space, but cannot withstand rms's bushiness
21:19:50 <roconnor> anyhow
21:19:53 <roconnor> past my bedtime
21:19:57 <enthymene> g'night
21:20:03 <pikhq> roconnor: ãä¼ã¿ã
21:20:07 <roconnor> g'night all
21:20:17 <ivanm> cya roconnor
21:24:41 <pookleblinky> http://esr.ibiblio.org/?p=1796#comment-250765 interesting
21:25:23 <esr> pookleblinky: He's one of my regulars.
21:25:56 <pookleblinky> reminds me of http://adambosworth.net/2004/11/18/iscoc04-talk/
21:26:50 <pookleblinky> "There is an unacknowledged war that goes on every day in the world of programming. It is a war between the humans and the computer scientists. It is a war between those who want simple, sloppy, flexible, human ways to write code and those who want clean, crisp, clear, correct ways to write code."
21:28:50 <SamB_XP> hmm
21:28:53 <SamB_XP> I want BOTH
21:28:55 <SamB_XP> at the SAME TIME
21:29:18 <jmcarthur> i want to write the first one and read the second one
21:29:28 <enthymene> seconded
21:29:48 <esr> Yeah.
21:30:12 <esr> And now *I* must sleep. Thanks for the help, all.
21:30:17 <ezyang> gnight sir
21:30:19 <enthymene> oh heck, I just remebered; I linked my linguistic anthropology professor to The Jargon File the other day, mainly as a computer example of communities of practice
21:30:21 <enthymene> g'night ESR
21:30:29 <pikhq> ãä¼ã¿ã
21:30:56 <pookleblinky> Countdown to post-part girlish giggling in...
21:30:56 <esr> enthymene: The OED uses it as a trustted source.  I'm rather proud of that.
21:30:59 <mgsloan> peace
21:31:05 <djahandarie> pikhq, do you have a replace on "good night" or something? ;)
21:31:10 <enthymene> really?  Win.
21:31:23 <ezyang> <3 OED
21:31:27 <ezyang> Very excellent resource.
21:31:44 * enthymene giggles
21:31:49 <enthymene> sorry, obligatory
21:31:55 <pookleblinky> [obligatory "zomg that was esr Himself!"]
21:31:56 <sohum> wait, what?
21:32:09 <sohum> the oed uses the jargon file as a trusted source?
21:32:16 <pookleblinky> Makes sense.
21:32:17 <pikhq> djahandarie: No. I'm just saying ãä¼ã¿ã
21:32:32 <pookleblinky> It is well documented, widely read.
21:32:38 <enthymene> it sucks to recognize kana and not be able to read them.
21:32:58 <pookleblinky> Definitely as notable for usage as some obscure text that first used the word Felch in 1562
21:33:25 <enthymene> speaking of dusty and venerable resources, Opie and Tatem's dictionary of superstitions?
21:33:32 <pikhq> sohum: Makes sense, yeah. It is pretty much the best documentation on a lot of our slang. ... And some that's never been seen by me. XD
21:33:51 <pikhq> enthymene: "Oyasumi". BTW, ä¼ is kanji, not kana.
21:33:53 <pookleblinky> If the OED can list origins in completely unknown Welsh manuscripts, it had better list origins in jargon.txt
21:34:01 <enthymene> I noticed pikhq
21:34:22 <enthymene> I figured what you were saying, but it feels like cheating when you know damn well that you didn't actually read it.
21:34:57 <sohum> heh, that's true... I can't find any citations to show citationship by the oed though
21:35:01 <sohum> ...if that made sense
21:35:23 <enth|amble> dog ownership is an unalloyed joy
21:35:44 <pookleblinky> Oh, it is alloyed alright.
21:36:43 <jmcarthur> honestly i'm kind of annoyed when people drool over idols. i hope i am never idolized
21:37:10 <ivanm> hang on, I thought SPJ was our idol in here...
21:37:19 <ivanm> with oleg coming a close second
21:37:20 <ezyang> <3 spj!
21:37:23 <ezyang> <3 oleg!
21:37:27 <enth|amble> <3 Carl Sagan
21:37:28 * SamB_XP starts selling solid gold figurines of jmcarthur 
21:37:38 <enth|amble> >.>
21:37:44 <SamB_XP> well, spj is hardly ever here, and I don't think oleg is EVER here
21:37:46 <Berengal> No instance for Num (a -> b)
21:37:55 <pikhq> jmcarthur: Drooling is pretty easy.
21:37:59 <SamB_XP> anyway, oleg is our unit of type-system hackz
21:38:03 <ivanm> augustss is sometimes here... close enough?
21:38:06 <ivanm> preflex: seen spj
21:38:06 <preflex>  Sorry, I haven't seen spj
21:38:12 <pikhq> It takes more work to act even vaguely sanely.
21:38:17 <djahandarie> I've never seen oleg here before
21:38:22 <ezyang> @preflex: seen spjones
21:38:22 <lambdabot> Unknown command, try @list
21:38:23 <jmcarthur> Berengal: i wish there was one, but the Num type class constraints don't work :(  you have to make a bad instance
21:38:31 <SamB_XP> preflex: seen SimonPJ
21:38:31 <preflex>  Sorry, I haven't seen SimonPJ
21:38:39 <ezyang> huh
21:38:43 <pikhq> preflex: seen oleg
21:38:43 <preflex>  Sorry, I haven't seen oleg
21:38:57 <tomberek> hehe
21:39:01 <ivanm> Berengal: would one make sense?
21:39:08 <ivanm> a -> a _maybe_
21:39:15 <jmcarthur> ivanm: aside from Eq and Show, it would make sense
21:39:21 <copumpkin> Num b => Num (a -> b)
21:39:26 <jmcarthur> right, that way
21:39:33 <Berengal> I was just commenting on all the <3's above...
21:39:36 <ivanm> jmcarthur: how would you multiply or add them?
21:39:45 <ivanm> or get the absolute value?
21:39:49 <jmcarthur> ivanm: liftA2 (+)  and  liftA2 (*)
21:39:56 <copumpkin> compose it with that
21:39:56 <jmcarthur> ivanm: and fmap abs
21:40:04 <copumpkin> aka (abs .)
21:40:05 <ivanm> hmm...
21:40:05 <copumpkin> :P
21:40:13 <SamB_XP> Berengal: I don't quite get it?
21:40:13 <ivanm> I was thinking more (*) = (.)
21:40:21 <ivanm> @type liftA2 (+)
21:40:22 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
21:40:43 <Berengal> @type let foo = "foo" in (<3 foo)
21:40:44 <lambdabot> forall a. (Num ([Char] -> a), Ord a) => a -> Bool
21:40:50 <ivanm> @type liftA2 (+) read (ord . head)
21:40:51 <lambdabot> String -> Int
21:41:03 <jmcarthur> > let (+.) = liftA2 (+) in (*5) +. (+4) $ 3
21:41:04 <lambdabot>   22
21:41:13 <SamB_XP> > (<3 f)
21:41:14 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:41:14 <lambdabot>    `SimpleReflect.FromExpr a...
21:41:18 <pookleblinky> Idol worship for anyone but Richard Feynman is seldom excusable.
21:41:18 <SamB_XP> > (<3 f) :: Expr
21:41:19 <Berengal> > type let foo = "foo" in (<3 foo) 6
21:41:20 <lambdabot>   The section `GHC.Classes.< 3 SimpleReflect.f' takes one argument,
21:41:20 <lambdabot>  but its ...
21:41:20 <lambdabot>   <no location info>: parse error on input `type'
21:41:37 <Berengal> > let foo = "foo" in (<3 foo) 6
21:41:38 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> a))
21:41:38 <lambdabot>    arising from the l...
21:41:43 <jmcarthur> ivanm: more generally, with the exception of the Eq and Show constraint, you can define Num for any Applicative
21:41:46 <ivanm> > liftA2 (+) read (ord . head) "hi"
21:41:47 <lambdabot>   * Exception: Prelude.read: no parse
21:41:53 <ivanm> > liftA2 (+) read (ord . head) "1"
21:41:55 <lambdabot>   50
21:42:27 <SamB_XP> I can't believe we got a serious discussion from "the type error you get if you try to evaluate (<3 foo)"
21:42:44 <jmcarthur> lol
21:51:02 <revertTS> is the ghc -C option outputting C or C--?
21:51:28 <ivanm> revertTS: well, IIRC C-- is valid C
21:51:32 <copumpkin> nope
21:51:38 <ivanm> note that the C-- that GHC spits out isn't the C-- on the project page
21:51:48 <ivanm> as it's a bit more customised for gcc
21:51:54 <ivanm> copumpkin: is isn't? oh...
21:52:27 <dolio> Has there ever been an actual C-- compiler?
21:52:27 <ivanm> methinks the GHC paragraph here is out of date: http://en.wikipedia.org/wiki/C--
21:52:40 <dolio> GHC's "implementation" certainly doesn't come close.
21:52:41 * jmcarthur installed the LLVM patched GHC today and is eager to play with it
21:52:43 <manjunaths> hello
21:52:50 <ivanm> dolio: apparently: http://www.cminusminus.org/
21:53:04 * ivanm waves idly in manjunaths' general direction
21:53:17 <manjunaths> is there a downloadable version of lyah ? not the pdf the current html things ?
21:53:26 <copumpkin> apparently there are c-- compilers
21:53:41 <copumpkin> but the only links on cminusminus.org are broken
21:53:49 <monochrom> perhaps you can wget the html version of lyah
21:55:01 <SamB_XP> monochrom: Noooo! that's IMPOSSIBLE!
21:55:54 <manjunaths> monochrom, I am scared it will be in bad taste to do that (leeching?)
21:56:04 <monochrom> God, it's my first time coming back to #haskell since more than a week ago, and the first response I get is negativeness. This channel is not encouraging!
21:56:51 <copumpkin> lol
21:56:53 <manjunaths> heh
21:56:55 <enth|amble> hehe
21:56:57 * ivanm provides arbitrary encouragement to monochrom
21:57:10 <copumpkin> monochrom: quick, use the @faq
21:57:13 <enth|amble> SamB_XP: was... powerfully affected by The Emprire Strikes Back
21:57:16 <Berengal> I'm thinking a bit about how you could hack up a goal system by abusing ghci...
21:57:49 <manjunaths> BONUS, ?
21:58:46 <ivanm> Berengal: a goal system?
21:59:10 <Berengal> Say you have a top-level declaration, 'foo = map (*3) undefined', and you want to know the type of the undefined, could you do that for all (or most) declarations with ':t let f x = let foo = map (*3) x in x in f undefined'?
21:59:39 <ivanm> I would just find the type of f
21:59:44 <Berengal> Could you also use that to ask the type of local definitions inside foo? and evaluate expressions in that context?
21:59:45 <ivanm> then you can infer the type of undefined from that
21:59:55 <ivanm> or foo, whatever
21:59:58 <ivanm> Berengal: nope
22:00:08 <Berengal> ivanm: Do you have a counter-example?
22:00:08 <aavogt> use the monomorphism restriction
22:00:37 <Berengal> aavogt: Doesn't that just apply to type classes?
22:00:44 <Berengal> This abuses lambda monomorphism anyway
22:03:25 <Cale> :t undefined `asTypeIn` \undefined -> map (*3) undefined
22:03:26 <lambdabot> forall a. (Num a) => [a]
22:03:55 <Cale> asTypeIn :: a -> (a -> b) -> a
22:03:56 <Cale> a `asTypeIn` f = a where _ = f a
22:03:56 <Cale> infixl 0 `asTypeIn`
22:03:56 <Cale> f `asAppliedTo` x = f `asTypeIn` \f -> f x
22:03:56 <Cale> infixl 0 `asAppliedTo`
22:04:07 <monochrom> neato!
22:04:19 <copumpkin> I wrote that a while ago
22:04:22 <copumpkin> it didn't stick
22:04:48 <bos> OH GOD WHO TOLD ESR ABOUT HASKELL.
22:04:48 <dons> so ... ESR eh?
22:04:48 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:04:54 <dons> jinx
22:04:57 <copumpkin> wow, bos == dons?
22:05:06 <ivanm> heh
22:05:08 <dons> apparently we work all day and read internets at night
22:05:19 <Cale> esr has even been hanging around here a good bit :)
22:05:27 <ivanm> bos, dons: you're lucky you weren't here when everyone was having esr-gasms over him :@
22:05:27 <dons> crikey
22:05:45 <ivanm> dons: oh, no, stop channeling steve irwin! please! I beg of you! :p
22:05:48 * p_l didn't notice it was *that* ESR before using /whois today.
22:06:04 <p_l> but I tend to spend more time in #lisp :)
22:06:10 <manjunaths> yeah I didn't know if I should feel happy or nervous
22:06:13 <dons> i hope he gets some forkIO going on.
22:06:13 <ezyang> g'evening dons!
22:06:22 <dons> heya ezyang
22:06:32 <monochrom> Oh, so I missed ESR then.
22:06:44 <ivanm> bos: several people were asking before: do you know of any parsing libraries that work with text?
22:06:49 <dons> you caught up now, monochrom ?
22:07:08 <dons> attotext eh? parsext?
22:07:44 <bos> sec phone
22:09:25 <ivanm> dons: I noticed that Brian Lewis released a new version of language-dot earlier; is that because he added stuff that galois wanted or just general bug-fixes, etc.?
22:09:57 <ivanm> preflex: seen copumpkin
22:09:57 <preflex>  copumpkin was last seen on #haskell 4 minutes and 59 seconds ago, saying: wow, bos == dons?
22:10:05 <copumpkin> ?
22:10:10 <ivanm> copumpkin: http://hackage.haskell.org/package/convertible-text <-- maybe this is what you want for your parsing?
22:10:24 <bos> dons: i think parsec3 should be fine for now
22:10:26 <ivanm> (I thought you'd gone off...)
22:10:34 <copumpkin> hmm
22:11:10 * ezyang is looking at his analytics logs, and is really surprised the "small C programs in Haskell" post was so popular 
22:11:24 <bos> the trouble with parsec is that you get String values back, and often you want Text instead
22:11:54 <ivanm> ezyang: it _sounded_ interesting
22:12:02 <ezyang> ivanm: Oh no!
22:12:11 <dons> ivanm: probably.
22:12:16 <copumpkin> bos: it'd be nice because it could give you slices of the original text
22:12:53 <ivanm> dons: probably for which possibility? "[
22:12:55 <ivanm> * :p
22:13:38 <bos> copumpkin: really what would suffice is a parser that runs another parser that returns [Char], then returns that result as a Text
22:13:42 <ezyang> ivanm: The way you say it implies that the content didn't live up to people's expectations :-)
22:13:43 <dons> well, i think his galois contract finished up a few months ago, so prob. bug fixes.
22:14:14 <ivanm> ezyang: well, the title made it sound slightly more interesting than it actually was
22:14:18 <ivanm> and there was no code!
22:14:26 <bos> copumpkin: but all the performance problems with parsec arise from the parsers that return [a] for any a
22:14:32 <ezyang> ivanm: Yes there was! I just, uh, linked to it!
22:14:35 <ivanm> (IIRC, there wasn't even "and it's 1/10th of the size of the C code!" boasts)
22:14:41 <ivanm> ezyang: heh
22:14:53 <ivanm> dons: *nod*
22:14:58 <manjunaths> is there an expanded version of typeclassopediia planned ?
22:15:03 <bos> 1/10th the size is so 2008. we go for 2% the size now.
22:15:08 <ezyang> ivanm: I mean, is that really a useful metric?
22:15:13 <ivanm> dons: any idea what I would need to add to my graphviz lib for galois to use that instead?
22:15:17 <ezyang> The Python version of the script was three lines...
22:15:18 <ivanm> or is it too complicated? :p
22:15:34 <ivanm> ezyang: useful? no; great for boasting purposes? yes!
22:15:38 <dons> it was needed for some project i don't work on, so no, couldn't say
22:15:43 <dons> timing issues basically
22:15:44 <ivanm> fair enough
22:15:49 <dons> we launched it before your stuff appeared
22:16:15 <ivanm> and as for the Python version... it's easy to create another lib containing the guts of the code and then just call that lib
22:16:25 <ezyang> ivanm: precisely!
22:16:45 <ezyang> it was literally "import cgi; import static; some wsgi mumble mumble"
22:17:35 <ezyang> I'm kind of curious what people were actually expecting. Boasts about how we increased revenues by 1000%, cut maintenance costs in half, and saved the pope.
22:18:56 * ezyang stops blathering about his blog now 
22:19:07 <dsrogers> Hmm, so I want to do some type level programming in haskell.  I have a type level bool and want to define a type level equality function.
22:19:10 <dons> we did some stuff. it was fun. it worked.
22:19:20 <copumpkin> dsrogers: people typically use a GADT for that
22:19:40 <copumpkin> data (:=) a b where Refl :: a := a
22:20:47 <manjunaths> byorgey, are you planning on an expanded version of typeclassopedia ?
22:20:50 <dolio> That'd be a value-level proof of type-level equality.
22:20:59 <copumpkin> yep
22:21:22 <ezyang> manjunaths: Out of curiosity, what would you like to see in the expanded version?
22:21:34 <copumpkin> oh so he wants something that outputs his type-level bool if two types are equal?
22:21:38 <ezyang> I guess byorgey could categorize all the typeclasses ever
22:21:44 <dolio> If he's talking about type bools, he might mean some kind of TEq a a TTrue constraint or something.
22:21:46 <manjunaths> ezyang, more examples for things like applicative
22:22:00 <dolio> Oleg has something in that regard, which is more difficult than it might initially seem.
22:22:05 <ezyang> manjunaths: There's, uh, plenty of papers on Applicative :-)
22:22:30 <manjunaths> ezyang, papers are really difficult to read
22:22:37 <copumpkin> nope
22:22:37 <ezyang> oh!
22:22:38 <ivanm> ezyang: ummm.... not really possible...
22:22:43 <copumpkin> people need to stop being scared of papers
22:22:44 <manjunaths> ezyang, I need to take ADHD medication to read the abstract
22:22:55 <ezyang> manjunaths: The seminal paper on Applicatives is reallya ccessible
22:22:58 <ezyang> *accessible
22:23:06 <ezyang> byorgey references it
22:23:27 <ezyang> ivanm: Hm?
22:23:34 <ezyang> ==copumpkin
22:23:43 <ezyang> "what people really need to be scared of is math textbooks!"
22:23:55 <ivanm> to categorize all possible typeclasses
22:24:15 <ivanm> ezyang: you are copumpkin? :o
22:24:19 <ivanm> >_>
22:24:21 <ivanm> <_<
22:24:32 <ezyang> ivanm: "There can't be that many, right?"
22:24:43 <ezyang> (==) (==) assent
22:24:55 <ivanm> ahhh
22:25:10 <jmcarthur> man, the llvm backend leads to longer compilation times than i expected
22:25:12 <ivanm> copumpkin: I'm not scared of papers, I'm just finding it boring doing a survey on papers!
22:25:23 <pastorn> jmcarthur: what did you expect?
22:25:27 <ivanm> jmcarthur: longer compilation of LLVM, of GHC or building packages?
22:25:48 <ivanm> and is that because it now builds normal, profile, split-objs, split-objs+profile, LLVM, LLVM+profile?
22:25:55 <dsrogers> thanks copumpkin
22:25:58 <manjunaths> I just received my copy of RWH!!
22:25:59 <copumpkin> jmcarthur: it's calling a dozen programs as far as I know
22:26:01 * manjunaths dances around
22:26:08 <jmcarthur> pastorn: i expected compilation times similar to -fvia-c
22:26:09 <dsrogers> you've given me lots to chew on though...
22:26:11 <copumpkin> dsrogers: what were you looking for? there are other solutions depending on how type-level you want it to be
22:26:28 <jmcarthur> ivanm: ghc takes longer to build programs when you use -fllvm than i expected
22:26:28 <dsrogers> metaprogramming techniques in haskell, generallys
22:26:32 <dsrogers> *generally
22:26:38 <jmcarthur> copumpkin: eek
22:26:41 <ivanm> jmcarthur: yeah, probably because it's building even more things
22:26:57 * manjunaths opens the RWH package
22:27:02 <ivanm> oh, wait, does it build "normal" versions as well?
22:27:07 <ivanm> or _just_ LLVM ones?
22:27:16 <ivanm> and how much longer are we talking about here?
22:27:17 <dsrogers> Is there an HList implementation somewhere that is built with GADT?
22:27:25 <dolio> jmcarthur: Is it slower just on -fllvm? HEAD seemed slower in general to me.
22:27:27 <ivanm> dsrogers: why do you want an HList?
22:27:32 <dolio> Presumably because it's thinking more than 6.12.
22:27:38 <jmcarthur> dolio: maybe it's the inlining stuff and all that
22:27:48 <dolio> Especially if you're using -Odph.
22:27:49 <jmcarthur> i haven't even tried HEAD without the LLVM backend yet
22:28:03 <jmcarthur> that could be the issue
22:28:08 <manjunaths> wow this package is hard to open
22:28:28 <jmcarthur> ivanm: it's only building with LLVM when you build with -fllvm, afaik
22:29:31 <jmcarthur> ivanm: GHC HEAD with LLVM is taking maybe twice as long as GHC 6.12.1 with native code gen, but that's also on code bases using -Odph which, as dolio pointed out, might be yet slower on HEAD than 6.12.1
22:29:32 <aavogt> dsrogers: and what's wrong with the implementation as-is (using multiparameter typeclasses and fundeps)?
22:29:51 <dolio> -Odph definitely does a lot more work.
22:30:10 <jmcarthur> i'm willing to live with it for faster genreated binaries :)
22:30:15 <jmcarthur> *generated
22:30:36 <manjunaths> The RWH print version if very good
22:30:39 <dolio> I've actually had it send my machine into swapping compiling my sorting test program.
22:30:43 <manjunaths> s/if/is
22:30:53 <manjunaths> it contains a lot of things
22:30:56 <jmcarthur> dolio: how much memory do you have?
22:31:06 <dolio> 2 gigabytes.
22:31:24 <jmcarthur> well, i have 4, so maybe i won't hit that problem
22:31:44 <dolio> Well, it's kind of an unusual program, too.
22:32:08 <manjunaths> wait a min, dons is Don Stewart one of the authors of RWH ?
22:32:15 <c_wraith> yep
22:32:22 <manjunaths> nice
22:32:24 <c_wraith> bos is also one of the authors
22:32:35 <ezyang> manjunaths: Yes.
22:32:36 <manjunaths> oh
22:32:39 <dolio> Probably 10 array algorithms, all inlined, some of which have other algorithms inlined into them (like, mergesort has an inlined insertion sort).
22:32:53 <manjunaths> I didn't know that :-)
22:32:59 <manjunaths> I feel privileged
22:33:39 <dobblego> wait until dobblego gets here!
22:33:56 <manjunaths> dobblego, he is also an author ?
22:34:00 <manjunaths> hey!
22:34:08 <dobblego> no, he is just a rockin' dude
22:34:21 <ivanm> dobblego: do you normally speak of yourself in the third person?
22:34:32 <copumpkin> copumpkin does that too
22:34:33 <ivanm> manjunaths: the third author is CosmicRay
22:34:33 <dobblego> only when he is asleep
22:34:45 <ivanm> dobblego: so you're sleep chatting?
22:34:47 <manjunaths> ivanm, ah
22:34:50 <dobblego> no dobblego is
22:35:00 <manjunaths> nice if I have questions I can ask them here
22:35:02 <ivanm> *groan*
22:35:05 <manjunaths> :-)
22:35:17 <manjunaths> hehe
22:35:19 <dsrogers> iivanm: because I can... aavogt: nothing, I just want to compare them.
22:35:20 <dolio> George likes his kung pao spicy.
22:35:58 <ivanm> dsrogers: I can jump off a cliff; doesn't mean I want to or am planning on doing so
22:36:12 <ivanm> dolio: who's George?
22:36:20 <dolio> Costanza.
22:36:40 <ivanm> oh, Seinfeld...
22:37:07 <dsrogers> ivanm: if I could jump off a cliff with no risk to myself, I would do so, simply out of curosity.
22:37:29 <dsrogers> I'm pretty sure knowing how to implement HList poses no risk to me.
22:38:17 <Makoryu> dsrogers: That's not funny. My brother died that way.
22:38:23 <Makoryu> Implementing HList, that is.
22:39:26 <ivanm> Makoryu: heh
22:39:28 <manjunaths> is the print book bigger than the online version ?
22:39:46 <ivanm> manjunaths: I would say the opposite because of all the comments on the online version
22:39:51 <manjunaths> ivanm, ok
22:40:03 <manjunaths> ivanm, most of the comments are just nitpicks
22:40:04 <ivanm> manjunaths: the main differences are editorial, where changes made to the print format weren't easily portable back to the online version
22:40:05 <Makoryu> Very long, tragic story. The gist of it is, his oxen all died of dysentery while he was fording a hot spring.
22:40:20 <manjunaths> ivanm, ok
22:40:25 <ivanm> Makoryu: and... ?
22:40:37 <ivanm> what has that got to do with implementing HList?
22:40:51 <Makoryu> ivanm: Well, he drowned without ever publishing his thesis
22:41:36 <ivanm> ... right...
22:41:52 * manjunaths cries haskell is more interesting that work (putting things into spreadsheets)
22:42:07 <manjunaths> s/that/than
22:42:15 <Makoryu> ivanm: On the bright side, there's now a spring in rural China where you can bathe to become a Haskell programmer
22:42:47 <copumpkin> yeah, but will I turn into a girl if I get bathed in cold water after that?
22:42:58 <enthymene> maybe
22:43:03 <enthymene> be careful which spring you use.
22:43:08 <Makoryu> copumpkin: You'll turn into a monad
22:43:15 <copumpkin> damn
22:43:25 <copumpkin> hot water will turn me back into myself?
22:44:14 <Makoryu> Or will it?
22:44:15 <Cale> Unfortunately, no, hot water will then turn you into a squirrel.
22:44:25 <copumpkin> crap
22:44:31 <copumpkin> is it cyclic at least?
22:44:56 <Makoryu> It's actually cyrillic.
22:44:56 <copumpkin> maybe I'll become a hot girl's pet squirrel at least
22:45:21 <Cale> From there, to get back to being yourself, you'll need to go hot, cold, hot, steam, and then eat an icecube.
22:45:37 <Makoryu> The kicker is that at that point, you'll have no mouth.
22:45:54 <manjunaths> > :type GenParser
22:45:55 <lambdabot>   <no location info>: parse error on input `:'
22:46:08 <Cale> :k GenParser
22:46:09 <lambdabot>     Not in scope: type constructor or class `GenParser'
22:47:03 <manjunaths> ah..ick, one of the problems with haskell is that to read one thing I need to be front loaded with a million things
22:47:08 <manjunaths> grrrrrrrr........
22:47:14 <Cale> hm?
22:47:19 <copumpkin> Cale: I take it you've fallen into one of the springs yourself?
22:47:39 <manjunaths> > :type st
22:47:40 <lambdabot>   <no location info>: parse error on input `:'
22:47:45 <manjunaths> :type st
22:47:50 <Cale> :t st
22:47:51 <lambdabot> Not in scope: `st'
22:48:02 <Cale> What are you looking for?
22:48:11 <Cale> :k ST
22:48:12 <lambdabot> * -> * -> *
22:48:20 <ivanm> @src State
22:48:21 <lambdabot> Source not found. Sorry.
22:48:21 <manjunaths> data GenParser tok st a
22:48:28 <ivanm> @hoogle State
22:48:29 <lambdabot> module Control.Monad.State
22:48:30 <lambdabot> Test.HUnit.Base data State
22:48:30 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
22:48:33 <Cale> st is a variable there
22:48:33 <manjunaths> I've no idea what st is
22:48:40 <manjunaths> oh...ok
22:48:42 <Cale> The state type for the parser
22:48:56 <aavogt> it could be anything
22:49:13 <roboshibby> what functions does control monad state give you?
22:49:18 <ivanm> maybe it's _s_ome _t_hing ? :p
22:49:26 <ivanm> roboshibby: it gives you the State monad
22:49:37 <c_wraith> roboshibby: You really should just look at the documentation for it.
22:49:40 <roboshibby> what can you do with that?
22:49:42 <roboshibby> url?
22:49:43 <ivanm> @hoogle runState
22:49:43 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
22:49:43 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
22:49:43 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
22:49:48 <ivanm> @hackage mtl
22:49:49 <lambdabot> http://hackage.haskell.org/package/mtl
22:49:50 <ivanm> roboshibby: ^^
22:50:03 <dmead> guys
22:50:14 <dmead> what sort of voodoo do i need to get my imports working?
22:50:16 <ivanm> it gives you an "imperative" like environment where you can "mutate" a given variable
22:50:23 <ivanm> dmead: hmmm?
22:50:34 <dmead> ivanm, i've got my own source files
22:50:41 <dmead> and in the same directory, a file importing them
22:50:42 <ivanm> right
22:50:51 <dmead> everything starts with upper case
22:50:56 <ivanm> dmead: is the filename the same as the module?
22:51:00 <dmead> yea
22:51:07 <ivanm> then it should work
22:51:11 <c_wraith> dmead: Is it an issue with paths?
22:51:16 <ivanm> if you don't have hierarchical module names
22:51:32 <dmead> hmm
22:51:46 <ivanm> e.g. module Foo.Bar would be in Foo/Bar.[l]hs
22:51:54 <jmcarthur> dang, for building both normal and profiling versions of my local copy of vector-static, GHC 6.12.1 takes 12.92s user, but GHC HEAD with -fllvm takes 96.92s user!
22:52:20 <jmcarthur> > 96.92/12.92
22:52:21 <lambdabot>   7.5015479876160995
22:53:15 <ivanm> preflex: seen Axman6
22:53:16 <preflex>  Axman6 was last seen on #haskell 9 hours, 46 minutes and 18 seconds ago, saying: i know. just make things that match the types needed
22:53:16 <manjunaths> :t many
22:53:17 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:53:57 <ivanm> jmcarthur: yeah, so is it HEAD or the LLVM patches that make it take so long?
22:54:58 <manjunaths> ok I am off for now, I'll be back later
22:55:17 <roboshibby> llvm, nice
22:55:24 <jmcarthur> ivanm: a bit of both i think
22:55:47 <jmcarthur> ivanm: i'm thinking mostly HEAD. not to worry, most code shouldn't be affected. it's just -Odph and tons of INLINE pragmas doing it i think
22:55:54 <idreamer> ....
22:56:14 <ivanm> jmcarthur: so it's likely that that's going to be improved as well
22:56:28 <ivanm> since the patches can probably do with a bit of a clean up on full integration
23:06:30 <RodentRodent> Hello, complete haskell newbie here. I'm told that these 2 constructs are not always the same, http://pastebin.ca/1833205 . Why?
23:07:17 <kmc> polymorphism
23:07:51 <kmc> > let x :: (Num a) => a; x = 3 in (x :: Int, x :: Float)
23:07:52 <lambdabot>   (3,3.0)
23:08:02 * hackagebot vector-static 0.1.0 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.1.0 (JakeMcArthur)
23:08:17 <kmc> > (\x -> (x :: Int, x :: Float)) 3
23:08:18 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
23:08:18 <lambdabot>         against inferred typ...
23:08:26 <ivanm> jmcarthur: now the ANNOUNCE email? :p
23:09:05 <kmc> a lambda-bound variable always has a monomorphic type, unless you enable certain GHC extensions (and write the signature yourself, usually)
23:09:14 <kmc> > (\(x :: forall a. (Num a) => a) -> (x :: Int, x :: Float)) 3
23:09:15 <lambdabot>   (3,3.0)
23:09:23 <kmc> that uses -XRankNTypes
23:09:58 <RodentRodent> okay
23:10:02 * hackagebot vector-static 0.1.1 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.1.1 (JakeMcArthur)
23:10:25 <ivanm> jmcarthur: what did you do wrong? :p
23:13:54 <jmcarthur> ivanm: needed to update the homepage (taking over maintainance from copumpkin)
23:13:55 <Saizan> :O vector-static
23:15:50 <jmcarthur> Saizan: yeah, this one has your changes too
23:16:17 <ivanm> ahhh
23:16:25 <ivanm> copumpkin: given up on it? ;p
23:16:31 <copumpkin> yes, actually
23:16:58 <copumpkin> trying something very different now
23:17:11 <ivanm> what?
23:17:30 <ivanm> jmcarthur: I like the README :p
23:17:39 <jmcarthur> ivanm: hey, i didn't write it :P
23:17:45 <copumpkin> a dsl-like thingy with a built-in solver to deal with all the ugly proofs you need to do with sizage
23:17:59 <jmcarthur> copumpkin: :o
23:18:16 <ivanm> jmcarthur: and your wiki says to look at copumpkin's, which has nothing...
23:18:59 <copumpkin> I want it to output both haskell and agda, so you can spit out something you can prove things about (along with the proofs it generates) or spit out haskell code
23:19:07 <Saizan> ivanm: that's what github puts there when you fork, iirc
23:19:19 <ivanm> copumpkin: have you looked at isabelle + haskabelle?
23:19:23 <ivanm> Saizan: ahhh
23:19:32 <copumpkin> ivanm: yep, kind of different goal
23:19:48 <copumpkin> I want something a lot more specialized and with almost no end-user effort
23:19:49 <ivanm> *nod* but the whole round-tripping thing is interesting
23:20:03 <ivanm> fair enough
23:20:26 <jmcarthur> ivanm: not anymore ;)
23:20:31 <jmcarthur> now it's just.... blank :P
23:20:40 <ivanm> heh
23:20:54 <copumpkin> main goal is to have nat/fin primitives and automatic solvage (and pretty printing in errors, and literals) for types involving them
23:21:03 <ivanm> what are Nat and Fin meant to be?
23:21:16 <copumpkin> naturals for lengths/sizes of things
23:21:21 <copumpkin> finite sets for indices
23:21:26 <ivanm> ahhh
23:21:41 <ivanm> copumpkin: why not use a pre-existing type?
23:21:45 <ivanm> or even Word?
23:21:46 <copumpkin> ?
23:21:53 <copumpkin> oh that's what it will be behind the scenes
23:22:15 <ivanm> ahhh
23:22:28 <copumpkin> for example, the type Fin 3 contains 0, 1, 2
23:22:36 <copumpkin> which is exactly what you want for indices into arrays and such
23:22:47 <copumpkin> so Vec n a -> Fin n -> a is safe
23:23:00 <copumpkin> I have that in vector-static already, but it's a pain to use
23:23:35 <ivanm> so vector static is a compile-time safety net around vector?
23:23:41 <asdf1> Can anyone please explain to me the different between guard and case..of?
23:23:50 <copumpkin> yeah, using all the unsafe variants of the vector operations
23:23:56 <copumpkin> since we've verified at compile time that their preconditions hold
23:24:05 <copumpkin> (in theory, at least)
23:24:23 <ivanm> @hoogle guard
23:24:23 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
23:24:23 <lambdabot> Language.Haskell.TH data Guard
23:24:23 <lambdabot> Language.Haskell.TH.Syntax data Guard
23:24:36 <ivanm> asdf1: guard is used to optionally do something within a monad
23:24:47 <copumpkin> ivanm: you get something like cons :: a -> Vec n a -> Vec (S n) a
23:24:49 <ivanm> case lets you do different things based upon the value of an expression
23:25:05 <aavogt> @src guard
23:25:05 <lambdabot> guard True  =  return ()
23:25:05 <lambdabot> guard False =  mzero
23:25:07 <ivanm> e.g. pattern-matching functions de-sugar down to case statements
23:25:15 <jmcarthur> and the main reason i'm using it is so i can nest unboxed vectors. we can do that if we can statically verify the inner vectors' lengths
23:25:36 <jmcarthur> well, that's not the *main* reason, but it helps
23:26:13 <jmcarthur> the main reason is because i just have an api in mind for some graphics code that wants statically known vector lengths ;)
23:26:53 <copumpkin> ivanm: but in haskell (and even agda), if you write cons :: a -> Vec n a -> Vec (1 + n) a and cons :: a -> Vec n a -> Vec (n + 1) a, they're considered different, and you need to use a proof of commutativity of addition to convince the compiler you're not insane. Agda has a ring solver module that can figure that out for you (and much more complicated expressions) but it's fairly noisy to use, and I'd mostly like to build something 
23:26:53 <copumpkin> that in with a goal of extracting fast vector programs in haskell from it (so not too much flexibility for proofs and so on)
23:26:58 <jmcarthur> one more upload to spam us with hackagebot coming up
23:27:13 <ivanm> copumpkin: *nod*
23:27:23 <ivanm> so you're dumping vector-static to write a competing library? :p
23:27:48 <copumpkin> not a library
23:27:52 <copumpkin> a language
23:27:59 <copumpkin> but a very simple one
23:28:05 <jmcarthur> a preprocessor?
23:28:08 * hackagebot vector-static 0.1.2 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.1.2 (JakeMcArthur)
23:28:08 <copumpkin> it'll just spit out unsafe haskell
23:28:16 <jmcarthur> or an actual standalone?
23:28:18 <copumpkin> jmcarthur: I'd consider it a bit more complex than a preprocessor, but maybe
23:28:57 * jmcarthur forgot his hackage password. had to grab his .mozilla file from another system just to upload this stuff
23:29:01 <copumpkin> :o
23:29:03 <ivanm> heh
23:29:03 <Saizan> it'd be nice to hook it up as a quasiquoter
23:29:15 <ivanm> jmcarthur: put it into your ~/.cabal/config
23:29:22 <ivanm> then it's just cabal upload foo.tar.gz
23:29:26 <copumpkin> Saizan: hm, yeah :)
23:29:37 <ivanm> (which will probably hang and then return a 505, but it does upload)
23:29:40 <copumpkin> I wasn't planning on following haskell syntax too closely
23:29:42 <jmcarthur> ivanm: but i don't know it. i need to have it reset :P
23:29:47 <ezyang> yawn! sleep time for ezyang
23:29:52 <copumpkin> but have it be of mostly the same flavor though
23:30:00 <Saizan> copumpkin: in a quasiquoter you can use the syntax you like :)
23:30:03 <ivanm> jmcarthur: _once_ you get it reset!
23:30:09 * ivanm heads off
23:30:09 <jmcarthur> heh, yeah, i plan to do that
23:30:16 <copumpkin> Saizan: yeah, I know :) I just wonder how people would feel about having something different in the same source file
23:30:23 <copumpkin> Saizan: maybe no problem at all :)
23:31:25 <Saizan> copumpkin: heh, this is mostly a detail anyway :)
23:31:46 <copumpkin> my thing will probably turn out to be vaporware anyway ;)
23:31:54 <copumpkin> but I've been putting quite a bit of thought into it anyway
23:32:24 <dsrogers> copumpkin: ok, I have a basic handle on GADTs....  What if I want to create a way to infer a "truth' type when two types match, and a "false" type when two types are different.
23:32:43 <copumpkin> dsrogers: ah, that's harder, and is what dolio was talking about earlier
23:32:48 <copumpkin> you could make a multiparameter typeclass
23:32:58 <copumpkin> actually a type family might work
23:33:04 <copumpkin> actually no
23:33:26 <dsrogers> naw, I tried those.  it's tricky
23:33:35 <copumpkin> yeah, the problem is saying false, I guess
23:33:39 <dsrogers> yeah
23:34:10 <aavogt> class EQ a b c | a b -> c
23:34:21 <copumpkin> aavogt: how do you write the false output?
23:34:27 <dsrogers> yeah...
23:34:32 <jmcarthur> data False
23:34:41 <copumpkin> jmcarthur: then what? :P
23:34:45 <dsrogers> instance EQ a a TTrue
23:34:47 <aavogt> data TRUE; data FALSE; instance EQ a a TRUE; instance EQ a b FALSE -- pleasantly overlapping
23:34:50 <jmcarthur> instance Eq a a True
23:34:53 <jmcarthur> instance Eq a b False
23:34:55 <jmcarthur> :P
23:34:57 <copumpkin> aavogt: that kind of overlap isn't allowed
23:34:59 <dsrogers> that doesn't work.
23:35:17 * aavogt tries it
23:35:28 * jmcarthur is glad that doesn't work, honestly
23:35:34 <copumpkin> if it were, you could do the same thing with type families
23:35:37 <copumpkin> and have nicer syntax
23:35:40 <jmcarthur> yeah
23:36:53 <Saizan> type classes tend to allow more things, ime
23:37:47 <copumpkin> well yeah
23:39:59 <aavogt> in which manner does that typeclass not work?
23:40:11 <dsrogers> it's a duplicate instance.
23:41:15 <Saizan> as it is you get an error about functional deps
23:41:19 <Saizan> but you can fix that
23:41:21 <aavogt> dsrogers: this is accepted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23870#a23870
23:41:21 <Saizan> let me paste
23:41:33 <aavogt> err, forgot the fundeps
23:41:58 <aavogt> and that makes it get rejected ...
23:42:13 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23870#a23871
23:43:06 <dsrogers> oh interesting, what is that ~ syntax?
23:43:14 <dsrogers> negation?
23:43:17 <Saizan> it's from TypeFamilies
23:43:21 <Saizan> no, equality
23:43:26 * dsrogers goes and looks up TypeFamilies
23:43:27 <aavogt> should that extension be necessary?
23:43:39 <copumpkin> you rarely need ~ without them
23:43:47 <copumpkin> but obviously there are such cases :)
23:43:57 <Saizan> ~ is the same as Oleg's TypeCast type class
23:44:02 <Saizan> but less hacky :)
23:45:16 * Saizan would keep fundeps + functional-style syntactic sugar + ~
23:45:48 <copumpkin> aavogt's thing works too
23:46:17 <Saizan> though you can't really make associated datatypes with those 3
23:46:17 * ski wonders why `~' was used instead of `=' ..
23:46:28 <copumpkin> they didn't want to overload it?
23:46:48 <Saizan> i like that = is used only for definitional equality
23:47:19 <ski> imo, it would be a use of the same concept in a different context
23:47:57 * ski doesn't really believe there's a difference between "definitional equality" and "equality" :)
23:47:58 <copumpkin> planetbeing: fail
23:48:57 <ski> (otoh, there is of course a difference between a defining formula, and formulae in general)
23:49:08 <planetbeing> copumpkin: my wifi :(
23:49:20 <copumpkin> :)
23:50:55 <Saizan> ski: mostly that only one is truly a binder
23:51:19 <Saizan> ski: though it's a bit blurry because in superclass contexts you can use free type variables
23:51:43 <ski> how do you mean ?
23:52:16 <Saizan> with = you always introduce a new name
23:52:56 <ski> (i meant re "in superclass contexts you can use free type variables")
23:52:57 <Saizan> with ~ you generally don't, but you can, e.g. class (c ~ d) => Foo c where ..
23:53:42 <ski> i'd say `c' and `d' there are introduced by an implicit `forall', there (which in this case isn't allowed to be explicit by the syntax (even in extensions))
23:54:13 <Saizan> yeah, that's what i meant by free
23:54:29 <ski> (i.e. `class forall c d. c ~d => Foo c where ...')
23:54:37 <Saizan> instance forall a b c d. (c ~ FALSE, c ~ d) => EQ a b c <- you can
23:55:00 <copumpkin> you can't have superclass constraints in classes
23:55:02 <copumpkin> (yet)
23:55:10 <copumpkin> I mean equality constraints in superclasses :)
23:55:25 <ski> hm, i must have missed that being allowed in GHC(?) .. is it allowed in class definitions, too ?
23:55:46 <ski> mhm, ok
23:55:56 <Saizan> only in instances
23:55:59 <Saizan> it seems
23:56:24 <Saizan> ScopedTypeVariables is probably the extension
23:56:29 <copumpkin> apparently in classes it would need a change to core
23:56:42 <copumpkin> not sure how
23:56:54 <Saizan> we're talking about the "forall" (i think)
23:56:58 <copumpkin> oh
23:57:15 * ski was talking about the `forall', yes
