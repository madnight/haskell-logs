00:13:10 <copumpkin> @src liftM2
00:13:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:13:19 <copumpkin> @@ @undo @src liftM2
00:13:19 <lambdabot>  ()
00:13:28 <copumpkin> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:13:28 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
00:13:39 <copumpkin> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
00:13:39 <lambdabot> (`fmap` m2) . f =<< m1
00:13:50 <c_wraith> clear as mud
00:13:58 <copumpkin> I'm trying to write it in terms of join
00:14:05 <copumpkin> and didn't feel like figuring it out by hand
00:15:59 <copumpkin> @pl \f m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
00:16:00 <lambdabot> liftM2
00:16:03 <copumpkin> fuck you
00:16:16 <Jafet> @vixen fuck you
00:16:17 <lambdabot> Calm down there and take it easy!
00:20:44 <copumpkin> @pl \f m1 m2 -> join (fmap ((flip fmap m2) . f) m1)
00:20:44 <lambdabot> ((join .) .) . flip . (fmap .) . flip ((.) . flip fmap)
00:20:48 <copumpkin> beautiful
00:21:05 <copumpkin> @pl \m2 f m1 -> join (fmap ((flip fmap m2) . f) m1)
00:21:06 <lambdabot> ((=<<) .) . (.) . flip fmap
00:21:49 <copumpkin> @src ap
00:21:49 <lambdabot> ap = liftM2 id
00:22:05 <copumpkin> @pl \m2 m1 -> join (fmap ((flip fmap m2)) m1)
00:22:05 <lambdabot> (=<<) . flip fmap
00:22:22 <nus> haha
00:22:42 <copumpkin> @pl \m1 m2 -> join (fmap ((flip fmap m2)) m1)
00:22:42 <lambdabot> (join .) . flip (fmap . flip fmap)
00:23:03 <c_wraith> I really need to learn to think in terms of <=<
00:23:15 <copumpkin> @unpl (join .) . flip (fmap . flip fmap)
00:23:16 <lambdabot> (\ j r -> (fmap (\ g -> fmap g r) j) >>= \ k -> k)
00:44:46 <VeXocide> hi, how can I convert a Maybe a to an a?
00:45:05 <elly> by casing on it!
00:45:07 <copumpkin> you don't
00:45:17 <copumpkin> you lift your function into it
00:45:25 <VeXocide> ah, ok
00:45:28 <ezyang> :t maybe
00:45:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:45:34 <copumpkin> > fmap (+1) (Just 5)
00:45:35 <lambdabot>   Just 6
00:45:39 <copumpkin> > fmap (+1) Nothing
00:45:40 <lambdabot>   Nothing
00:45:47 <xerox> > (+1) . Just 5
00:45:49 <lambdabot>   Just 6
00:45:53 <Jafet> @hoogle (Monad m) => (m a) -> a
00:45:53 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
00:45:53 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
00:45:53 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
00:46:15 <copumpkin> @instances Copointed
00:46:15 <lambdabot> Couldn't find class `Copointed'. Try @instances-importing
00:46:29 <VeXocide> yeah, I'm using lookup which returns a Maybe, but I'm certain in this case the value is there
00:46:44 <ezyang> :t fromJust
00:46:45 <lambdabot> forall a. Maybe a -> a
00:46:50 <Hunner> let f a = case; Just x = x; Nothing = 0; f (Just 2)
00:46:52 <ezyang> use with caution!
00:46:57 <Hunner> > let f a = case; Just x = x; Nothing = 0; f (Just 2)
00:46:58 <lambdabot>   <no location info>: parse error on input `;'
00:47:05 <Jafet> @src fromJust
00:47:05 <lambdabot> fromJust Nothing  = undefined
00:47:05 <lambdabot> fromJust (Just x) = x
00:47:26 <Jafet> Yay undefined
00:47:43 <ezyang> "you better be really really really sure"
00:48:00 <idnar> unsafeFromJust
00:48:08 <VeXocide> actually checked it using another function, it's part of a set of exercises
00:48:35 <Jafet> idnar does it justice.
00:49:05 <ezyang> i dunno who thought it wasn't going to be a good idea to add the unsafe
00:53:19 <VeXocide> well, "fromJust (lookup n s)" is a lot clearer than "snd ((head.filter ((== n).fst)) s)" and I'll add the appropriate warning
00:53:36 <copumpkin> :t fromMaybe Nothing
00:53:37 <lambdabot> forall a. Maybe (Maybe a) -> Maybe a
00:53:38 <copumpkin> ;)
00:53:57 <xerox> I guess the idea is to keep the Maybe a return value in subsequent computations!
00:54:10 <Jafet> @quote .*randomRIO.*
00:54:10 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
00:54:21 <copumpkin> @check liftM2 (==) join (fromMaybe Nothing)
00:54:21 <lambdabot>   "OK, passed 500 tests."
00:54:25 <copumpkin> sweet
00:55:54 <ski> @check (liftM2 (==) join (fromMaybe Nothing) :: Maybe (Maybe Bool) -> Bool)
00:55:55 <lambdabot>   "OK, passed 500 tests."
00:56:05 <copumpkin> ski: that was the only option
00:56:13 <ski> @type liftM2 (==) join (fromMaybe Nothing)
00:56:14 <lambdabot> forall a. (Eq a) => Maybe (Maybe a) -> Bool
00:56:21 <copumpkin> oh :)
00:56:26 <ski> `Maybe (Maybe ()) -> Bool' was another option
00:56:27 <copumpkin> I take that back
00:56:44 <copumpkin> either way actually
00:56:45 <ski> (and probably that was what was checked, first)
00:57:14 <ski> (what either way ?)
00:57:19 <copumpkin> it's polymorphic in a
00:57:23 <copumpkin> Nothing, Just Nothing, Just (Just x)
00:57:33 <copumpkin> those are the possible values, and it can't do anything but pass x through
00:57:37 <ski> yes, so presumably defaulting set `a' to `()'
00:57:44 <ski> @check (==)
00:57:45 <lambdabot>   "OK, passed 500 tests."
00:57:48 <copumpkin> yeah, I know
00:57:57 <copumpkin> I'm saying that it's sufficient
00:58:06 <copumpkin> (to test on ())
00:58:16 <ski> ok, yes, since it's parametric polymorphic
00:58:43 <copumpkin> (but that's not what I was thinking of when I first tried it, either way :P)
00:58:45 <ski> (no class constraints)
01:07:04 <systemfault> Hmm, if I wanted enumFromTo 10 1, how would I do that?
01:07:48 <copumpkin> > enumFromThenTo 10 9 1
01:07:48 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
01:07:54 <systemfault> Thanks :)
01:07:56 <copumpkin> > [10,9..1]
01:07:57 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
01:07:58 <copumpkin> :)
01:08:10 <systemfault> I was trying with enumFromStepN :/
01:09:49 <copumpkin> you can do that too I think
01:09:57 <copumpkin> enumFromStepN 10 (-1) 10
01:10:54 <copumpkin> dabblego: what are you dabbling in?
01:11:14 <dabblego> eh?
01:11:21 <systemfault> I was trying to make that collatz sequence Euler Project Fast :P
01:11:32 <ivanm> dabblego: DABBLEgo (emphasis added)
01:11:43 <ivanm> dabblego: also, what's with you always having two nicks present?
01:11:54 <systemfault> -fvia-C and -fllvm are still faster on that one
01:12:04 <dabblego> one is at work
01:13:19 <ivanm> ahhh
01:13:23 <ivanm> where you working at now?
01:14:17 <dabblego> for a gaming company in Brisbane
01:15:47 <slava> dons: ping
01:16:33 <copumpkin> omg it's slava
01:16:35 <ivanm> dabblego: oh? what kind of games?
01:16:40 <ivanm> and what langs do you use there?
01:17:02 <dabblego> online casino, pokies; I use Java :( and sometimes Python
01:17:09 <Jonno_FTW> since when does australia make games?
01:17:31 <Jonno_FTW> you make actual pokie machine games?
01:17:40 <dabblego> yes
01:17:52 <ivanm> dabblego: were you desperate for work or something? :s
01:17:53 <Jonno_FTW> how do you feel ethically about this?
01:18:03 <dabblego> I have no problem with it at all
01:18:07 <ivanm> Jonno_FTW: there's actually a fairly decent (mainly indie level) gaming industry in brisbane
01:18:08 <dabblego> ivanm, yes
01:18:18 <ivanm> but _Java_? really?
01:18:18 <ivanm> :p
01:18:21 <Jonno_FTW> i meant the pokie machines
01:18:42 <dabblego> I'd rather Java than Python; they're all doing it wrong, there is no choice
01:19:05 <dabblego> I have $90K medical bill to pay now, thanks doc
01:19:30 <dabblego> (and still counting)
01:19:51 <Jonno_FTW> too much Java can do that too you
01:19:53 <Jonno_FTW> *to
01:20:17 <dabblego> doctors with equivalent competence of Java programmers can too
01:21:25 <kamatsu> aw, i want TDNR
01:27:02 <ivanm> dabblego: no medical insurance, etc.?
01:28:10 <dabblego> yes, you under-estimate the magnitude of idiocy that I refer to
01:28:12 <systemfault> Any obvious way to make this faster? http://www.ideone.com/FGwTx9aH
01:30:01 <Cale> systemfault: memoise
01:30:07 <Jonno_FTW> systemdefault: you can  use memoization
01:30:31 <systemfault> Hmm, any idea how I would implement that?
01:30:37 <Jonno_FTW> let in
01:30:48 <Jonno_FTW> there's an article on the haskell wiki about it
01:30:48 <Cale> You should also note the existence of even
01:30:50 <Cale> :t even
01:30:51 <lambdabot> forall a. (Integral a) => a -> Bool
01:30:54 <Cale> > even 5
01:30:55 <lambdabot>   False
01:31:09 <systemfault> Cale: Slower.. :/
01:31:13 <Cale> Really?
01:31:23 <systemfault> I'll retry
01:31:35 <Jonno_FTW> you should look for the big optimisation rather than the small one
01:31:36 <Cale> It shouldn't really matter
01:31:48 <systemfault> It's indeed slower :/
01:31:50 <Cale> I would write it using even and `div` 2
01:31:52 <systemfault> Jonno_FTW: Sure :)
01:31:55 <Cale> and then just memoise it
01:32:04 <Jonno_FTW> i assume this is project euler
01:32:09 <systemfault> It is
01:32:14 <Jonno_FTW> which one?
01:32:22 <systemfault> Jonno_FTW: I wanted to get the haskell version close to C (Speed wise)
01:32:23 <systemfault> 14
01:32:33 <Jonno_FTW> so you have the answer
01:32:37 <Jonno_FTW> you just want it faster
01:32:45 <systemfault> Yes :)
01:33:02 <Cale> Are you compiling it with -O2?
01:33:17 <Cale> (silly question, but sometimes not so silly)
01:33:27 <systemfault> By replacing the bitwise operators with even and div... I passed from 0.125s to 0.510s
01:33:29 <Jonno_FTW> mine runs in 3 seconds for that one using the naive method
01:33:32 <systemfault> Huge perf hit
01:33:49 <systemfault> Yeah :) -O2
01:34:34 <dons> slava: pong
01:34:45 <ivanm> hmmmm.... the SoC email says $4.5k; the trac page says $5k
01:34:50 <ivanm> who's telling the truth? >_>
01:34:57 <VeXocide> hi, I just wrote http://codepad.org/V3cdMcr4 as a homework assignment, it run, but could someone please have a look and give me feedback on what can be done differently, better etc. ?
01:35:01 <dons> 5k. but only 4.5k goes to the student
01:35:07 <ivanm> ahhh
01:35:07 <VeXocide> runs *
01:35:08 <dons> 500 goes to Haskell.org
01:35:15 <dons> which pays for the new hackage
01:35:27 <VeXocide> the idea is to evaluate a 'pico' application
01:35:38 <ivanm> VeXocide: what is a pico application?
01:36:18 <VeXocide> ivanm, it's a trivial language the people who created the assignment came up with, there's an example in the paste
01:36:38 <ivanm> VeXocide: soe immediate comments: 1) any particular reason for using List and Maybe rather than Data.List and Data.Maybe? 2) needs more comments, 3) IMHO it looks nicer to have each algebraic constructor on a new line, 4) derive Read and Ord as well, not just Show and Eq
01:38:12 <VeXocide> ivanm, 1) no, why are they better?, 2) you're right, 3) ok, 4) the data and types were actually given, but that makes sense
01:39:43 <ivanm> VeXocide: for 1), it's that the Data.* versions are usually used instead (and have a few more functions than the non-Data versions)
01:40:04 <ivanm> the non-Data versions are holdovers from the pre-hierarchical types extension to the report
01:40:16 <VeXocide> aha, ok
01:40:17 <monadic_kid> VeXcoide: there is a tool that can help suggest haskell code improvements
01:40:33 <VeXocide> monadic_kid, that'd be brilliant
01:40:40 <ivanm> @hackage hlint
01:40:40 <lambdabot> http://hackage.haskell.org/package/hlint
01:41:13 <ivanm> monadic_kid: it suggests how to fix code usage, not layout, etc. though (which most of my points were about)
01:41:33 <monadic_kid> the more the merrier
01:42:08 <monadic_kid> VeXocide: as ivanm said hlint
01:42:14 <VeXocide> this is basically my first practical haskell experience, thus any feedback welcome
01:43:02 <Cale> systemfault: actually, how does your program even work when you're using Ints?
01:43:14 <Cale> systemfault: I seem to recall needing Integer for this.
01:43:32 <monadic_kid> VeXocide: Haskell wiki is an awesome resouce as well but sometimes it's hard to find the bit of info you need
01:43:36 <systemfault> Cale: It would go up to more than 2Billion?
01:43:43 <Cale> systemfault: Oh, are you on a 64 bit machine?
01:43:49 <systemfault> Cale: Yeah
01:43:53 <monadic_kid> VeXocide: I mean it's hard to find it in there even though it is there
01:44:01 <Cale> On my computer, your program takes 33 seconds and dies.
01:44:09 <Cale> (with Prelude.Enum.succ{Int}: tried to take `succ' of maxBound)
01:44:10 <systemfault> Cale: With optimization?
01:44:13 <Cale> yep
01:44:21 <systemfault> Hmm
01:44:40 <systemfault> Cale: Then you must be right, it must work because I'm on 64bit
01:44:47 <ivanm> VeXocide: with your fromJust usage, are you _sure_ that n will be in s?
01:44:51 <Cale> I have a naive memoised version which finishes in 4 seconds
01:45:00 <ivanm> (I've assumed that before and it took a while to debug that that was where my error was)
01:45:10 <systemfault> Cale: Would you mind showing me when you're done?
01:45:36 <ivanm> VeXocide: also, to improve readability, a lot (most?) haskell programmers will line up all the equals signs in a multi-part function
01:46:52 <VeXocide> ivanm, well, it n is not in s, the application is invalid according to the specifiction they've given thus the result can be left undefined
01:47:13 <ivanm> VeXocide: fair enough
01:47:17 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8536#a8536
01:47:21 <ivanm> VeXocide: however, you can make that more obvious:
01:47:36 <Cale> heh, actually, you can kill the Data.Function dependency
01:47:39 <ivanm> fromMaybe (error "The specification states that n should be in s but it isn't.") $ lookup n s
01:47:46 <Cale> and, for that matter, Data.List
01:51:01 <VeXocide> ivanm, hmz, what does the $ operator do, never seen it, and googling it isn't really working
01:51:15 <ivanm> @src ($)
01:51:15 <lambdabot> f $ x = f x
01:51:29 <ivanm> VeXocide: low level application operator
01:51:32 <Cale> VeXocide: The important thing about $ is that it has really low precedence
01:51:33 <ivanm> it avoids using parens
01:51:42 <Cale> "low level" might be misleading
01:51:43 <ivanm> e.g. rather than f (g x), you can do f $ g x
01:51:51 <ivanm> Cale: yeah, I meant low precedence
01:52:01 <VeXocide> aha, k
01:52:09 <ivanm> even better: f (g (h x)) == f . g . h $ x
01:52:15 <ManateeLazyCat> Good news, Axel have push Webkit patch to gtk2hs! Rock.....
01:52:38 <ivanm> huh?
01:52:45 * ivanm has no idea what ManateeLazyCat is talking about
01:52:50 <ivanm> who is Axel? what patch is this?
01:52:56 <Cale> So you can write something like f . g . h $ x, and it means (f . g . h) x, whereas f . g . h x would mean f . g . (h x), because function application normally binds tighter than any infix operator
01:53:46 <VeXocide> thank you all for the feedback, I've added some improvements and 'll add a bunch of comments to the code
01:54:26 <systemfault> Cale: I'm checking :)
01:54:36 <systemfault> Cale: Thank you by the way :)
01:55:26 <Cale> systemfault: It doesn't seem faster than the version which just swaps Int out for Integer in your code.
01:55:34 <Cale> systemfault: But it's pretty anyway :)
01:55:57 <systemfault> It also gives me ideas :)
01:56:22 <Cale> systemfault: I find that most of the Project Euler problems can be solved reasonably well by just writing the naive recursive solution, no matter how inefficient, and then memoising.
01:56:53 <systemfault> Cale: I just wanted to know how close to my C++ version I would get :)
01:57:24 <Jonno_FTW> > [(c,c)|c<-[0..6]]
01:57:25 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6)]
01:57:31 <Jonno_FTW> can i do that in less code?
01:57:55 <Cale> > map (join (,)) [0..6]
01:57:56 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6)]
01:58:00 <Cale> not less...
01:58:09 <Jonno_FTW> have you looked at 282 yet Cale?
01:58:24 <Jonno_FTW> i don't think memoization will work here
01:58:47 <Jonno_FTW> or perhaps it will
01:58:58 <Cale> Jonno_FTW: Nope, I've only looked at the problems which people have asked for help with.
01:59:23 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=282
01:59:58 <Jonno_FTW> is there a general way of implementing memoization?
02:00:00 <Cale> Memoising certainly looks rather important there
02:00:07 <Cale> I use Data.MemoCombinators usually
02:00:39 <QtPlatypus> @pf map (join (,)) [0..6]
02:00:39 <lambdabot> Maybe you meant: bf pl
02:00:46 <QtPlatypus> @pl map (join (,)) [0..6]
02:00:46 <lambdabot> map (join (,)) [0..6]
02:00:52 <systemfault> Cale: With your two in one, i lowered my time to 0.108 :D
02:01:21 <Jonno_FTW> @hackage MemoCombinators
02:01:22 <Jonno_FTW> @commands
02:01:22 <lambdabot> http://hackage.haskell.org/package/MemoCombinators
02:01:22 <lambdabot> Unknown command, try @list
02:02:44 <Jonno_FTW> this looks useful
02:03:10 <ManateeLazyCat> ivanm: Webkit patch push in gtk2hs repository
02:03:17 <ivanm> ahhh
02:03:41 <ManateeLazyCat> ivanm: That's mean we can use Webkit API develop browser use Haskell/gtk2hs.
02:03:42 <ivanm> ManateeLazyCat: by what you said, I thought _actual_ gtk+, and was thus querying why we'd care (also I thought they already had webkit support)
02:04:20 <ManateeLazyCat> ivanm: But you need gtk2hs, make you coding with Haskell style. :)
02:04:55 <ManateeLazyCat> ivanm: I haven't test Webkit patch, but this is screenshot that use uzbl: http://farm5.static.flickr.com/4036/4426992557_2cec005a32_o.png
02:05:45 <ManateeLazyCat> ivanm: Axel is the author of gtk2hs. He's a hero!
02:06:21 <ManateeLazyCat> ivanm: Patch is write by cjack, Axel finish missing signal part.
02:06:30 * ivanm thought dcoutts was gtk2hs' author...
02:07:19 <ManateeLazyCat> ivanm: Axel is original Axel, and dcoutts help we finish problem with GHC or other deep detail.
02:07:35 <ivanm> ahhh
02:07:43 <Cale> Jonno_FTW: Probably the key in that one is working out how to do modular reduction early on. There's a way to express the Ackermann function using Knuth's up-arrow notation, which basically results in towers of exponentiation.
02:07:44 <ivanm> I know dcoutts used to be a maintainer, etc. ...
02:07:59 <ManateeLazyCat> ivanm: Haven't now, Duncan is too busy. :)
02:08:01 <Saizan> ManateeLazyCat: how complete are these WebKit bindings?
02:08:08 <Jonno_FTW> Cale: thanks, I checked out the wikipedia on that
02:08:09 <ivanm> yeah
02:08:29 <Jonno_FTW> i'll get the hang of this library first
02:08:37 <ManateeLazyCat> Saizan: Should complete, infact, few months ago have this patch, just missing some signal part.
02:08:46 <Saizan> nice
02:08:49 <ManateeLazyCat> Saizan: But i think this patch is complete. I haven't test.
02:09:43 <ManateeLazyCat> Saizan: In the first, my chinese friend write this patch, but have some problem with signal, that need patch Webkit and gtk2hs, so just lie on Axel's disk till now.
02:10:02 <ManateeLazyCat> Saizan: Today, he send mail to me, he have push this patch to repository.
02:10:17 <ManateeLazyCat> Saizan: I think it's be complete, otherwise Axel won't push it.
02:10:36 <ManateeLazyCat> Saizan: BTW, Webkit is damn fast.
02:10:53 <ManateeLazyCat> Saizan: Yesterday, i use uzbl integrate with gtk2hs: http://farm5.static.flickr.com/4036/4426992557_2cec005a32_o.png
02:11:22 <ManateeLazyCat> Saizan: Really cool, today i can use Webkit API and don't need any other program. :)
02:12:16 <Saizan> ManateeLazyCat: yeah, i got interested in uzbl, but it'd be much nicer to develop something like that in haskell
02:12:22 <ManateeLazyCat> ivanm: But Duncan still watch gtk2hs, he will patch gtk2hs to make it work on newsest GHC.
02:12:34 <Saizan> integrating it with xmonad, maybe
02:13:00 <ManateeLazyCat> Saizan: Like my screenshot, i embedded uzbl in my window, but have a problem, you lose control and flexibility.
02:13:10 <ivanm> ManateeLazyCat: yeah, but it'd be nice if the 6.12 patch was applied and a release made so that 6.12 users could actually install gtk2hs... :@
02:13:12 <chrisdone> in Bryan O'Sullivan's blog there's a function \n -> fib (10+n-n) -- why the n-n? some GHC optimistaion trick?
02:13:20 <ManateeLazyCat> ivanm: Example, Duncan make gtk2hs work on Ghc 6.12.1
02:13:33 <ivanm> chrisdone: *shrug* makes it a thunk?
02:13:43 <ivanm> if the n wasn't on the RHS, it might be optimised away
02:13:43 <ManateeLazyCat> ivanm: Yep GHC-6.12 can install gtk2hs, i have use it long time.
02:13:50 <ivanm> ManateeLazyCat: an actual release?
02:13:50 <ManateeLazyCat> ivanm: You need darcs version.
02:13:57 <ivanm> no, I want a release
02:14:10 <Saizan> chrisdone: it's to prevent sharing between the multiple runs
02:14:14 <ManateeLazyCat> ivanm: Infact, gtk2hs's darcs version is stable and haven't different between a release version.
02:14:21 <chrisdone> Saizan: ivanm: ah, ok
02:14:29 <ivanm> ManateeLazyCat: I WANT A TARBALL FOR END USERS TO USE
02:14:32 <Saizan> chrisdone: criterion has a nicer interface for that now, iirc
02:14:40 <ManateeLazyCat> ivanm: Release version just remove darcs files and complete corresponding documentation, that's all.
02:14:54 <ivanm> I WANT A TARBALL!!! HOW HARD IS THAT TO UNDERSTAND!!!
02:15:16 <ManateeLazyCat> ivanm: Why not compile it self, you at Windows?
02:15:23 <ivanm> no
02:15:24 * Saizan gives ivanm a tarball
02:15:31 <jlouis> mmmm, tarball
02:15:35 <jlouis> taste bad
02:15:49 <ivanm> I compile stuff myself all the time
02:15:49 <Saizan> it's an acquired taste.
02:15:50 <ManateeLazyCat> ivanm: If you want, i pull from repository, then pack one to you. Okay? :)
02:16:02 <ivanm> but stuff like gtk2hs is too important to tell end users who just want a GUI that they have to get a live version
02:16:08 <jlouis> no darcs! tarball!
02:16:11 <ivanm> ManateeLazyCat: no, I want an official release
02:16:19 <ivanm> to be able to make an updated package for for end users to use
02:16:33 <ivanm> (and then araujo has to get off his lazy behind and update himerge :p )
02:16:36 <jlouis> No git commit id either... tarball! gzipped!
02:16:38 <ManateeLazyCat> ivanm: It's different between release and darcs, because gtk2hs just binding, so it's always stable as Gtk+
02:16:49 <ivanm> *sigh* you don't seem to be getting it
02:16:50 <ManateeLazyCat> ivanm: Well, i always use darcs version.
02:17:08 <ivanm> ManateeLazyCat: but you're a developer without a release that people want to use
02:17:22 <ivanm> I'm thinking about people that want to use software that needs gtk2hs
02:17:27 <ivanm> (e.g. chart for use with criterion)
02:17:34 <ManateeLazyCat> ivanm: Well, Windows package need another people to help.
02:17:59 <ManateeLazyCat> ivanm: I have said this thing to Axel, we will release pack after testing Webkit API.
02:18:01 * ivanm doesn't care about windows...
02:18:27 <ManateeLazyCat> ivanm: We need release those platform at the same time.
02:18:28 <ivanm> it's just ridiculous that a point release wasn't made with that patch to the current "stable" version for people to be able to use
02:18:57 <ManateeLazyCat> ivanm: Okay, i know you mean.
02:19:03 <ivanm> preflex: seen Baughn
02:19:03 <preflex>  Baughn was last seen on ##c++ 14 hours, 45 minutes and 52 seconds ago, saying: blocky: You want efnet#winprog
02:19:31 <Saizan> ivanm: not so ridiculous considering ghc-6.10.4 is still the recommended version for end users
02:19:32 <ManateeLazyCat> ivanm: We will release package after test completely. Just few developers on it. It's need time.
02:19:45 <ivanm> Saizan: true
02:20:11 <ivanm> Saizan: but some people still want to use "bleeding edge"
02:20:21 <jlouis> To be honest, I don't really care about release. I care that the main integration branch can be tracked though
02:20:21 <FliPPeh_> Thank god Arch Linux packs always the newest GHC :)
02:20:24 <ivanm> and AFAIK gtk2hs is the only major library that doesn't support 6.12 yet
02:20:36 <ivanm> (to be more precise: doesn't have a release supporting 6.12)
02:20:37 <FliPPeh_> ivanm: It worked with 6.12 here
02:20:38 <ManateeLazyCat> ivanm: It's support!
02:20:45 <jlouis> releasing is done to please the gods of package distribution
02:20:54 <ManateeLazyCat> ivanm: gtk2hs support 6.12
02:20:58 * Saizan burns some offer to the gods
02:20:58 <ivanm> release a tarball; if windows users really care so much they can build it themselves *shrug*
02:21:06 <ManateeLazyCat> ivanm: Duncan patch that
02:21:07 <ivanm> ManateeLazyCat: a _release_ that supports 6.12
02:21:09 <Saizan> ManateeLazyCat: yeah, he meant an official release
02:21:18 <ivanm> a live repo doesn't count
02:21:30 <ManateeLazyCat> ivanm: Okay. I see.
02:21:45 <Saizan> you can tell that ivanm is a gentoo maintainer :)
02:22:00 <Saizan> j/k
02:22:02 <ivanm> heh
02:22:10 <ivanm> Saizan: s/gentoo/distro/
02:22:21 <ivanm> and I want my pretty graphs from criterion!
02:22:22 <ivanm> :p
02:22:29 <ManateeLazyCat> ivanm: Okay, we will try to release next version, as i said before, we need some time.
02:23:33 <jlouis> ivanm is generally too intelligent to be slammed with the ricer-gentoo badge
02:23:40 * ManateeLazyCat Maybe it's will be eaiser if gtk2hs base on cabal someday.
02:24:03 <ManateeLazyCat> Have guys works on that split gtk2hs to cabal package.
02:24:33 * ManateeLazyCat Pull repository to test Webkit API.
02:24:36 <ivanm> jlouis: exactly!
02:24:53 <ivanm> ManateeLazyCat: AFAIU, the problem is that c2hs doesn't play nicely with cabal
02:25:01 <ivanm> and cabal doesn't support multiple libraries within the one package
02:25:19 <ivanm> jlouis: my main reason for the s/gentoo/distro/ was that this isn't purely a gentoo problem
02:25:25 <ManateeLazyCat> ivanm: First, we try to split gtk2hs with many little packages.
02:25:32 <ivanm> there was a long enough time after 6.10 came out before we had gtk2hs dupporting it
02:25:42 <ivanm> *supporting
02:25:54 <ivanm> and this is _one simple little patch_ that's required to get it to build with 6.12
02:26:14 <ivanm> a lot of libraries just did point releases to provide 6.12 support; why couldn't gtk2hs?
02:27:18 <Saizan> distro maintainers comment out parts of ssh but they don't apply a small patch?:)
02:27:25 <ManateeLazyCat> ivanm: You can ask in gtk2hs list, those need Axel to decide. Even it just package and change name.
02:27:45 <ivanm> Saizan: in gentoo we prefer to leave it to upstream to do stuff
02:27:55 <ivanm> we were considering applying the patch ourselves, but figured we'd wait
02:28:01 <ivanm> in hindsight, maybe we shouldn't have...
02:28:11 <ManateeLazyCat> ivanm: In gentoo, can't compile source code self? Must use from repository?
02:28:15 <ivanm> anyway, 6.12 becomes the recommended version next month if all goes to plan...
02:28:27 <ivanm> ManateeLazyCat: ummm.... most people prefer using releases
02:28:36 <ivanm> I only use a few "live" packages
02:28:57 <ManateeLazyCat> ivanm: Oh, sorry i don't know you use Gentoo, i use Debian system. :)
02:29:01 <ivanm> but I'm sure arch would have similar problem and preferences
02:29:08 <ivanm> ManateeLazyCat: we build _everything_ from source
02:29:10 <ManateeLazyCat> ivanm: Perhaps it's a problem for gentoo.
02:29:25 <ivanm> (well, except for proprietary packages and optionally firefox and openoffice)
02:29:30 <ManateeLazyCat> ivanm: I saw a friend use it, build all system use one *week*.
02:29:32 <ivanm> ManateeLazyCat: no, it's a problem for all distros
02:29:34 <Entroacceptor> I use Arch,and I still prefer release packages
02:29:48 <ivanm> Entroacceptor++ thanks for agreeing with me!
02:30:08 <ManateeLazyCat> ivanm: I never use any release package for Haskell.
02:30:20 <ivanm> O RLY?
02:30:22 <ManateeLazyCat> ivanm: Then i can use newest Haskell code.
02:30:25 <ivanm> so you use HEAD GHC
02:30:29 <ivanm> ?
02:30:37 <ManateeLazyCat> ivanm: I compile GHC self.
02:30:47 <ivanm> so do I; what's your point?
02:30:49 <ManateeLazyCat> ivanm: Then compile gtk2hs, other package use cabal.
02:31:01 <ManateeLazyCat> ivanm: Never use release package.
02:31:04 <ivanm> I use gentoo; I compile everything except openoffice
02:31:23 <ManateeLazyCat> ivanm: Gentoo is too slow to install package.
02:31:26 <Saizan> ManateeLazyCat: a "release package" is usually the source package associated with an official release
02:31:29 <ivanm> and most packages aren't stable enough to use live versions of
02:31:51 <ivanm> ManateeLazyCat: ummm..... you compile everything from live repositories, but then diss a distro which compiles everything from tarballs?
02:32:53 <ManateeLazyCat> Saizan: Infact, gtk2hs haven't stable and unstable, it's stable enough. Well, it's a good thing for end user if we release official package.
02:34:01 <ManateeLazyCat> ivanm: If i need develop something, i will compile it self. If i just use it, i install package from Debian repository.
02:34:07 <jlouis> It is hell to maintain 1337 patches rather than get upstream to integrate them
02:34:27 <Saizan> ManateeLazyCat: a release is often the moment you test the code on multiple platforms, plus you know the api won't change, and in general it just feels more reliable
02:35:00 <ManateeLazyCat> Saizan: I never use Gentoo, just saw my friend use it.
02:35:11 <Saizan> ManateeLazyCat: gentoo doesn't matter here
02:35:37 <Saizan> ManateeLazyCat: i was talking about the maintainers of some library doing a release
02:35:45 <FliPPeh_> :t !String
02:35:46 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
02:35:53 <FliPPeh_> BangPatterns?
02:36:04 <ManateeLazyCat> Saizan: If just for Linux, we just need remove darcs files, and change name to gtk2hs-support-6.12. That's all.
02:36:07 <Saizan> FliPPeh_: are you seeing that in a datatype definition?
02:36:21 <FliPPeh_> Saizan: Xmonad source
02:36:38 <FliPPeh_>  { normalBorderColor  :: !String
02:36:38 <ManateeLazyCat> Saizan: So relase a package for multiple-platform need test.
02:36:40 <Saizan> yeah, but where in the xmonad source?:)
02:36:49 <FliPPeh_> datatype ;>
02:36:57 <Saizan> FliPPeh_: that means the constructor will be strict on that argument
02:37:16 <FliPPeh_> Instantly evaluated?
02:37:18 <ivanm> ManateeLazyCat: the problem with live packages for serious development is that you don't have a stable, working API to use to write your software
02:37:24 <ivanm> and thus end users can't use your software
02:37:46 <ManateeLazyCat> ivanm: I see.
02:38:04 <Saizan> FliPPeh_: no, just that when you force the constructor you'll also force that String
02:38:17 <Saizan> FliPPeh_: but only up to its outermost constructor
02:38:31 <FliPPeh_> okay :o
02:39:27 <Saizan> FliPPeh_: data Foo = Foo { x :: !Bar } is a bit like having an automatic $! inserted wherever you apply the Foo constructor
02:40:08 <Saizan> @src $!
02:40:08 <lambdabot> f $! x = x `seq` f x
02:40:49 <ManateeLazyCat> What's problem with code.haskell.org ? I can't pull patch from it.
02:41:11 <ManateeLazyCat> Hardware problem?
02:41:50 <SubStack> wow, I've just stumbled across a really simple way to do ray tracing
02:42:21 <ivanm> ManateeLazyCat: for example, it would be stupid for someone to use my darcs version of graphviz, since I don't keep it in a particularly stable or useful state
02:42:23 <Jonno_FTW> how come this won't load:
02:42:25 <Jonno_FTW> import qualified Data.MemoCombinators as Memo
02:42:26 <Jonno_FTW> a = Memo.integral $ memo2 a'
02:42:53 <Heffalump> what's the error?
02:43:15 <Jonno_FTW> not in scope on memo2
02:43:22 <Heffalump> Memo.memo2 ?
02:43:25 <ManateeLazyCat> ivanm: I understand. Stable release always good for end-user.
02:43:28 <Jonno_FTW> oh right
02:43:58 <Jonno_FTW> now i get Inferred type is less polymorphic than expected
02:44:11 <Heffalump> @type Data.MemoCombinators.integral
02:44:12 <lambdabot> forall a r. (Integral a) => (a -> r) -> a -> r
02:44:16 <Saizan> paste the whole code
02:44:21 <Heffalump> a' has to take any Integral type
02:44:22 <ivanm> ManateeLazyCat: and even for developers; you shouldn't base your code on live repositories since you can't guarantee it will work with actual releases
02:44:27 <Heffalump> it probably only takes Int or Integer or something
02:44:28 <Saizan> and the whole error
02:44:44 <Saizan> Heffalump: no, the forall is at the outermost level
02:44:47 <Jonno_FTW> @hpaste
02:44:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:44:49 <Heffalump> oh, sorry
02:44:54 <Heffalump> misread
02:45:10 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8538#a8538
02:45:33 <Saizan> Jonno_FTW: and the error?
02:45:39 <Jonno_FTW> silly
02:46:14 <Saizan> @type Data.MemoCombinators.memo2
02:46:15 <lambdabot> forall a b r. Memo.Memo a -> Memo.Memo b -> (a -> b -> r) -> a -> b -> r
02:46:19 <ManateeLazyCat> ivanm: I know. But gtk2hs is just binding..... haven't big problem with relase.
02:46:19 <Jonno_FTW> fixed
02:46:43 <Saizan> ManateeLazyCat, ivanm: you're running in circles :)
02:46:52 <ivanm> ManateeLazyCat: probably because by the sounds of things gtk2hs is slow to change ;-)
02:47:01 <ivanm> Saizan: heh, quite probably
02:47:35 <ManateeLazyCat> ivanm: Yep, we won't add any more if low-level API haven't change.
02:48:20 <ManateeLazyCat> ivanm: What's graphviz ?
02:48:30 <ivanm> www.graphviz.org
02:48:53 <ivanm> it's a set of tools (well, there's a library there as well, but I don't use it directly) to visualise graphs
02:48:58 <ivanm> @hackage graphviz
02:48:58 <lambdabot> http://hackage.haskell.org/package/graphviz
02:49:05 <ivanm> ^^ that's the "bindings" to it I maintain
02:49:43 <Jonno_FTW> any ideas on that error?
02:49:59 <ivanm> what error?
02:50:07 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8538#a8539
02:50:09 <ManateeLazyCat> ivanm: Looks some graphics for design work.
02:50:25 <ivanm> ummm.... no...
02:51:38 <ivanm> Jonno_FTW: replace the $ with . I think
02:51:59 <Jonno_FTW> still get the same with the .
02:52:13 <ivanm> *shrug* add an explicit type signature?
02:52:26 <ivanm> @type Data.MemoCombinators.integral
02:52:27 <lambdabot> forall a r. (Integral a) => (a -> r) -> a -> r
02:52:45 <ivanm> but I think you're using memo2 wrong...
02:52:47 <Saizan> Jonno_FTW: you've to use Memo.memo2 Memo.integral Memo.integral a', i think
02:55:22 <Jonno_FTW> thanks
02:56:05 <chrisdone> hpaste used to tell us when a #haskell paste was made... was it decided that that should be removed or does the latest hpaste just not implement it?
02:56:24 <ivanm> chrisdone: I think it was never implemented in hpaste2
03:16:10 * ManateeLazyCat Downloading eBook in crazy... brb
03:27:09 <Jonno_FTW> if I have a list of numbers, how can I perform a function like this: [a,b,c] -> a^b^c ?
03:27:40 <fax> wow this is a HUGE function!
03:27:47 <Jonno_FTW> precisely
03:27:50 <fax>  foldl1 (^) [a,b,c]
03:27:51 <fax> > foldl1 (^) [a,b,c]
03:27:57 <lambdabot>   mueval: ExitFailure 1
03:27:59 <fax> > foldr1 (^) [a,b,c]
03:28:02 <Jonno_FTW> @src foldl1
03:28:02 <lambdabot> foldl1 f (x:xs) = foldl f x xs
03:28:02 <lambdabot> foldl1 _ []     = undefined
03:28:05 <fax> to big for lambdabot!
03:28:06 <lambdabot>   mueval-core: Time limit exceeded
03:28:12 <Jonno_FTW> oh wow
03:28:22 <Jafet> > (a,b,c)
03:28:23 <lambdabot>   (a,b,c)
03:28:27 <fax> I'm never sure if a^b^c associates left or right
03:28:30 <Jafet> > a^b
03:28:35 <lambdabot>   mueval: ExitFailure 1
03:28:39 <jlouis> > foldl1 (^) [2,3,4]
03:28:44 <fax> > foldl1 (^) [2,3,4]
03:28:44 <fax> 4096
03:28:46 <lambdabot>   mueval: ExitFailure 1
03:28:46 <lambdabot>   4096
03:28:56 <fax> > (2^3)^4
03:28:57 <lambdabot>   4096
03:29:01 <fax> > 2^(3^4)
03:29:02 <lambdabot>   2417851639229258349412352
03:29:05 <jlouis> heh
03:29:14 <copumpkin> > foldl1 (^) [2..4] :: Expr
03:29:15 <lambdabot>   2 * 2 * 2 * (2 * 2 * 2) * (2 * 2 * 2 * (2 * 2 * 2))
03:29:21 <copumpkin> damn :P
03:29:39 <ivanm> copumpkin: what, you thought lambdabot couldn't do it?
03:29:43 <ivanm> or it brackets them wrong?
03:29:48 <jlouis> > foldl1 (^) [a,b,c] :: Expr
03:29:49 <copumpkin> no, I forgot it wasn't a method
03:29:56 <lambdabot>   mueval-core: Time limit exceeded
03:29:56 <lambdabot>  mueval: ExitFailure 1
03:30:10 <copumpkin> so that it's actually going to do something smart
03:30:14 <ivanm> copumpkin: oh, you wanted the whole pseudo-Show instance for a function?
03:30:29 <Twey> Sense makes it does not
03:30:32 <copumpkin> I wanted a parenthesized expression :)
03:30:40 <Twey> You got one :þ
03:30:42 <copumpkin> > foldl1 (+) [2..7] :: Expr
03:30:45 <lambdabot>   2 + 3 + 4 + 5 + 6 + 7
03:30:49 <copumpkin> > foldr1 (+) [2..7] :: Expr
03:30:50 <lambdabot>   2 + (3 + (4 + (5 + (6 + 7))))
03:30:52 <Jonno_FTW> well which one should be correct with exponentitation?
03:32:16 <Saizan> infixr 8 ^
03:32:45 <Saizan> so foldr1
03:37:04 <amuller> Hello, is it possible to have a function stack overflow outside a let definition and inside of a let be OK? (the only difference is a variable that instead of being defined inside the let would have to be passed to the function)
03:37:41 <fax> > 2^(3^4) -- this one is (much!) bigge
03:37:42 <lambdabot>   2417851639229258349412352
03:37:42 <fax> r
03:38:20 <Jonno_FTW> > 3^4
03:38:21 <lambdabot>   81
03:38:31 <Saizan> amuller: can you paste the two versions?
03:38:34 <jlouis> amuller: it might depend on evaluation order and strictness
03:38:34 <amuller> yes!
03:39:02 <amuller> readFasta :: Int -> [Char] -> [Window]
03:39:02 <amuller> readFasta windowSize sequence =
03:39:02 <amuller>     -- get the header
03:39:02 <amuller>     let (header: rest) = lines sequence
03:39:02 <amuller>         chr = parseChromosome header
03:39:03 <amuller>         go _ [] = []
03:39:07 <amuller>         go i (w:ws) = Window w chr i : go (i+1) ws
03:39:09 <amuller>     in go 0 $ slideWindow windowSize $ concat rest
03:39:11 <amuller> This is the one that works
03:39:12 * Jafet stack overflows
03:39:18 <ivanm> amuller: paste them in a paste site, not here ;-)
03:39:33 <amuller> Ah ok!
03:39:35 <amuller> hold on...
03:40:06 <ski> @paste
03:40:06 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:40:20 <Saizan> mh, it's surprising that one works
03:41:01 <Saizan> ghc must have become smarter :)
03:41:04 <amuller> this is the overflow: http://snipt.org/zmV
03:42:04 <Saizan> yeah, the problem is that when you write go outside it gets a more general type and could be used with other arguments, so GHC can't optimize it as much
03:42:06 <amuller> The code that does not overflow: http://snipt.org/zmW
03:42:26 <amuller> I see, Saizan, even if I write the type definition on top of the "go"?
03:42:49 <Saizan> amuller: that could work, otherwise you'd also need to add some strictness annotations
03:43:10 <amuller> I see... Even when I wrote the go inside a where it will also overflow...
03:44:20 <Saizan> with -XBangPatterns you can write go _ !_ [] = ..; go chr !i (w:ws) = ...
03:44:45 <amuller> oh I see...
03:45:12 <Saizan> that will make it strict in the i argument, so it'll get evaluated at each step, rather than building a big unevaluated expression, which will overflow when you force it
03:45:43 <amuller> I see, so the problem might be i, instead of chr right?
03:46:04 <Saizan> the problem is almost surely i
03:47:11 <Saizan> but it's also possible that adding the chr argument makes the life harder for GHC's optimizer
03:47:45 <amuller> OK, so I guess the trick is to play with those patterns when something explodes...
03:48:06 <Saizan> you've to recognize lazy accumulators
03:48:21 <Saizan> especially when you're working with atomic types like Int
03:48:46 <jlouis> My strict-CML experiment looks promising
03:48:58 <amuller> Saizan, so when you start recognizing them, can the programming become much more fluid and less "Mystic". Right now I have to confess that some of the errors that I am encountering are so difficult to find...
03:49:05 <Saizan> atomic is maybe not the right term, i meant types whose values are not composed of multiple parts
03:49:12 <ski> jlouis : Concurrent ML ?
03:49:20 <Saizan> amuller: yeah
03:49:31 <jlouis> ski: in haskell, with dons strict mvar library to send along values
03:49:31 <Saizan> @wiki Stack overflow
03:49:32 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
03:49:51 <Saizan> amuller: reading that page should help ^^^
03:50:05 <ski> jlouis : and is `Event' a monad ?
03:50:14 <amuller> Saizan, thank you so much! :)
03:50:37 <jlouis> ski: I just hacked on the cml package in which Event is not a monad
03:50:40 <Saizan> np
03:50:59 <jlouis> in the haskell sense, I am pretty sure it is a monad though with >>= == wrap
03:51:26 <ski> jlouis : .. i've always wondered whether `Event' actually is a monad, but i've not sufficiently understood the formalism to be able to decide for myself
03:51:31 <Saizan> wrap :: Event a -> (a -> IO b) -> Event b <- almost
03:51:53 <dbelange> Thanks for clearing that up Saizan
03:52:12 <ski> Saizan : yes, but maybe `\ma amb -> wrap ma (sync . amb)' ?
03:52:23 <dbelange> Now is almost a monad, or just a plain old contravariant functor?
03:52:40 <ski> (or maybe it would violate some of the laws .. i'm not sure)
03:52:54 <ski> dbelange : monads must be covariant functors
03:53:51 <jlouis> wrap is the eaiser part of cml though. guard, choose and wrapabort are the fun parts
03:54:01 <Saizan> that wrap would make it a covariant functor from Kleisli IO to Hask, in fact
03:54:32 <Saizan> (if you flip)
03:54:48 <dbelange> ski: What!
03:54:55 <dbelange> Why I never.
03:55:05 * ski never, too.
03:56:05 <Saizan> OTOH, what would return be?
03:56:32 <ski> `\a -> choose [a]' (iirc `choose' correctly) ?
03:56:52 <Saizan> choose :: [Event a] -> Event a
03:57:03 <ski> ok .. then i don't recall
03:57:29 <Saizan> maybe the haskell API is too restrictive
03:58:01 <dbelange> Good point.
03:58:09 <dbelange> Haskell needs more mutation.
03:58:25 <Saizan> i just meant cml's API
03:58:31 <jlouis> what is that MUT in my profiling doing then?
03:59:22 <jlouis> of course we could also put a radioactive source next to Haskell
04:00:28 <Saizan> well, that's in ghc 10, the release for quantum computers
04:01:00 <ivanm> heh
04:01:13 <ivanm> @remember Saizan that's in ghc 10, the release for quantum computers
04:01:13 <lambdabot> I will never forget.
04:01:31 <ivanm> dbelange: go use DDC then or something
04:03:12 <ski> Saizan : hm, there's `alwaysEvt' in the original CML
04:03:32 <ski> surely there must be a corresponding one to that in the Haskell one ?
04:03:35 <cYmen> is there a function like "isWhitespace"?
04:03:42 <ski> @type isWhite
04:03:45 <lambdabot> Not in scope: `isWhite'
04:03:53 <dabblego> @type isSpace
04:03:54 <lambdabot> Char -> Bool
04:03:56 <Jonno_FTW> > isWhitespace ' '
04:03:56 <ski> @index isSpace
04:03:56 <lambdabot> Data.Char
04:03:57 <lambdabot>   Not in scope: `isWhitespace'
04:04:03 <Jonno_FTW> > isWhiteSpace ' '
04:04:04 <lambdabot>   Not in scope: `isWhiteSpace'
04:04:18 <ski> > map isSpace " \b\t\v\f\n\r"
04:04:19 <lambdabot>   [True,False,True,True,True,True,True]
04:04:26 <cYmen> sweet, thanks
04:05:33 <Saizan> ski: it seems like it's missing http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html
04:06:49 <kuribas> > filter isSpace (map chr [1..255])
04:06:50 <lambdabot>   "\t\n\v\f\r \160"
04:07:49 <kuribas> quit
04:07:58 <kuribas> sorry...
04:08:23 <ivanm> what's \v, \f and \160 ?
04:10:21 <xerox> I guess vertical tab, dunno, dunno
04:10:29 <ski> Saizan : see <http://cml.cs.uchicago.edu/pages/cml.html> for `never',`alwaysEvt',&c.
04:10:43 <jlouis> Saizan: never is choose []
04:10:48 <ski> (yes)
04:11:02 <ivanm> ahhh, \f is page break apparently
04:11:07 <ski> vertical tab, form feed, and (?)non-breaking space
04:11:08 <mauke> ivanm: form feed, no-break space
04:11:13 <jlouis> alwaysEvt can also be encoded pretty easily IIRC
04:11:34 <ivanm> mauke: oh, &nbsp; ?
04:11:59 <mauke> yes
04:12:23 <mauke> ivanm: http://mauke.ath.cx/stuff/javascript/unicode.html?q=160
04:12:25 <Saizan> jlouis: how?
04:12:39 <mauke> this page can search unicode by number, name, or literal character
04:13:14 * ski uses form feed to separate "larger pieces" of code, in emacs
04:13:29 <ski> jlouis : how ?
04:13:51 <ivanm> ski: how?
04:14:33 <xerox> how?
04:14:49 <ivanm> now?
04:15:01 <Lycurgus> how
04:15:01 <ski> (ivan : `C-q C-l' inserts a form feed, then `C-x [' and `C-x ]' pages backward and forward)
04:15:20 <Lycurgus> .oO(some kina indian schtick apparently)
04:15:29 <ivanm> Lycurgus: no, you were meant to go "brown"!
04:15:30 <ivanm> ;-)
04:15:38 <Lycurgus> :)
04:15:49 <ivanm> and then someone says "cow"!
04:16:10 <Lycurgus> yeah but I decided to cross the streams. My bad.
04:16:24 <ivanm> preflex: seen Axman6
04:16:24 <preflex>  Axman6 was last seen on #haskell 5 hours, 54 minutes and 45 seconds ago, saying: do you want processes or threads?
04:19:47 <jlouis> ski: my guess is you fork a child that does nothing but send a on some internal channel and then it is a receive on that channel
04:20:41 <jlouis> it isn't clear cut in haskell though, since the forkIO takes ... well... IO
04:21:46 <ski> i see ..
04:22:52 <Saizan> a pretty busy return :)
04:23:02 <Saizan> but it make sense
04:24:17 <jlouis> A lot of CML code relies on garbage collection of processes that were stray
04:24:41 <jlouis> as such, it comprises a nice stress test of the system :P
04:25:10 <jlouis> anyway, off for a bit
04:46:41 <scotd> Is there a common technique for parsing strings without using monads or arrows?
04:47:24 <ski> you could use applicative functors, i think
04:47:24 <cYmen> is there a simple way to create an infinite list of words to test if my "words" function can handle it?
04:47:33 <cYmen> I mean..an infinite string...you know
04:47:45 <ski> (also, there's Happy, which is similar to Yacc)
04:48:46 <Cale> scotd: well, most parsing libraries end up falling into one of the general classes like that, but there's nothing saying that all of them would be. I suppose any sort of parser which doesn't produce a result (recognisers for a language) wouldn't even be a functor, and so would be exempt from that
04:49:10 <ski> > (intercalate " " . cycle) ["can","the","\"words\"","function","handle",":"]
04:49:11 <lambdabot>   "can the \"words\" function handle : can the \"words\" function handle : ca...
04:49:52 <cYmen> ah of course
04:49:56 <ski> > cycle "infinite "
04:49:57 <cYmen> thanks again :)
04:49:57 <lambdabot>   "infinite infinite infinite infinite infinite infinite infinite infinite in...
04:50:29 <ski> > repeat '!'
04:50:30 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
04:50:48 <ski> (maybe your function will screw up if it doesn't find any space at all ?)
04:52:00 <waterlaz> which one is more appropriate? Having long unique names or namespaces?
04:52:44 <Twey> waterlaz: Namespaces
04:53:08 <Twey> Namespaces, if done properly, allow your users to choose appropriate short unique names.
04:53:14 <Cale> waterlaz: My general rule is that the length of names should be proportional to the size of their scope, and inversely proportional to their frequency of use.
04:53:26 <Twey> That's two rules
04:53:30 <Twey> Which conflict :þ
04:53:35 <waterlaz> =)
04:54:00 <Cale> Nah, it's really one rule: (length of name) = k (size of scope) / (frequency of use)
04:54:12 <waterlaz> hm...
04:54:39 <Cale> I think that namespaces are a good way to control things on the large scale, but are totally inappropriate for the small scale.
04:55:34 <Cale> It's nice when modules go out of their way a little to define names that don't step on each other's toes. Sometimes it's unavoidable, of course.
04:55:56 <waterlaz> ok, here is the thing. I'm making bindings to xmms2
04:55:58 <Twey> Cale: But then if you have k = 1, (size of scope)_a = 3, (frequency of use)_a = 3, (length of name)_a = 1; yet if (size of scope)_b = 4, (frequency of use)_b = 4, (length of name)_b also = 1
04:56:29 <Twey> So it's not proportional to the size of scope (because b's size of scope is proportionally greater than a's, yet the length of their names is the same)
04:56:34 <luite> Twey: the relation defines equivalence classes of name lengthiness ;p
04:56:48 <Cale> Twey: The proportionalities are with all other things held constant.
04:56:56 <waterlaz> it has lot's of functions like xmmsc_playlist_list, xmmsc_playlist_shuffle etc..
04:57:00 <Twey> Cale: Aha
04:57:09 <Twey> waterlaz: Yeah, modules are appropriate for that
04:57:24 <Cale> Twey: So something which you use a lot might have a short name even if it has a very large scope
04:57:25 <waterlaz> so I have an option to have a namespace Playlist
04:57:28 <Cale> Like map, for instance.
04:57:36 <Cale> Or (.)
04:57:40 <Twey> waterlaz: Sound.XMMS.Client.Playlist.list, or something like that
04:57:55 <waterlaz> ok, thanks
04:58:14 <Cale> Things with a small scope can have short names even if they're only used once -- the parameters to one-line functions, particularly.
04:58:32 <fax> http://www.sporcle.com/games/moogles/programlanguages this is so hard :|
04:58:48 <Twey> Cale: *nod* I think I understand
05:00:39 <Cale> waterlaz: In that case, I would tend to want to strip all the xmms_'s from the start of the names, and just let the module system do its thing.
05:00:55 <Cale> waterlaz: Especially as 'playlistShuffle' is rare enough on its own.
05:02:14 <waterlaz> so should I leave this playlist prefix?
05:02:36 <cYmen> @src foldl
05:02:36 <lambdabot> foldl f z []     = z
05:02:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:02:37 <Cale> Well, perhaps. I suppose you could shorten it further.
05:02:39 <cYmen> @src foldr
05:02:39 <lambdabot> foldr f z []     = z
05:02:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:02:45 <ski> or make a `XMMS.Playlist' module ..
05:03:02 <scotd> ski: thanks, that was helpful... functors are mind-bending :-)
05:03:33 <waterlaz> btw, Every editor I've seen so far colors things like XMMS.Playlist.shuffle like types and not functions
05:03:34 <ski> scotd : applicative functors ~= monads - `join' / `(>>=)'
05:03:43 <Cale> waterlaz: There's no one right answer of course. You just want to balance the convenience of the short names with the potential for needing to import the module qualified because of conflicting names in other modules.
05:03:43 <waterlaz> damn even leksah
05:04:22 <ski> scotd : in terms of parsers, that means that the parser can't decide what kind of thing to parse later, depending on what actual values it parsed earlier (which monadic parsers can)
05:04:23 <Cale> Haskell is hard to syntax colour properly. You have to actually parse it, and most things go with regex approximations that don't really work in the edge cases.
05:04:40 <luite> hmm, is it already possible to make multiple modules in a single source file? I regularly have name clashes when experimenting with small programs with different data definitions with the same field names
05:04:41 <ski> scotd : iirc, parsers without that ability can be implemented more efficiently
05:05:12 <scotd> ski: so, more generally, there wouldn't be a way to do a Finite State Machine in Haskell without using monads, or something like them? Even if the input is a simple string?
05:05:17 <Twey> I greatly dislike using long names to avoid modules
05:05:22 <twink> Cale: This one would just be tokenizing, which I think is still regex.
05:05:47 <ski> scotd : sure, you can do a simple FSM, by hand, if you prefer
05:05:48 <Cale> One thing about monadic parsers is that it's very hard to make them efficient -- there are even fundamental limitations on how efficient a monadically-expressed parser can be, since >>= takes a function as its right parameter, and functions are opaque values.
05:05:51 <Twey> There's not a whole lot of difference between playlistShuffle and Playlist.shuffle, and the latter gives the user more control over how they want their names to look in their code, thanks to qualified imports
05:06:03 <Cale> So you can't do much to "compile" the parser, you can only "interpret"
05:06:21 <ski> scotd : it's just that using something like a parser combinator library (in terms of applicative functors, or monads, or arrows), is ususally easier
05:06:29 <Cale> Twey: Except for the sad fact that the latter uses a period for something that isn't composition
05:06:50 <Cale> But yeah, it's not so bad.
05:07:26 <waterlaz> this is not hard to tell types and functions apart
05:07:34 <waterlaz> even with regexps
05:07:55 <twink> I guess (UpperCaseName Dot)^* LowerCaseName vs. (UpperCaseName Dot)^* UpperCaseName or something. It should turn out to be regular still.
05:08:02 <Cale> waterlaz: Well, it probably colours the module names the same as it would data constructors, right?
05:08:11 <waterlaz> yes
05:08:18 <Cale> waterlaz: There's a genuine ambiguity in the Haskell syntax there.
05:08:54 <Cale> (one which is resolved by spacing in the case of a conflict -- subtle, but usually does the right thing)
05:09:05 <scotd> ski: how would i deconstruct a string "a b" into "a" and "b"?
05:09:30 <ski> scotd : using a parser, or what ?
05:09:35 <ski> > words "a b"
05:09:36 <lambdabot>   ["a","b"]
05:10:00 <Cale> I suppose you could just always colour the Foo in Foo.bar with module colour, and in Foo . bar with constructor colour.
05:10:15 <Cale> That might work out okay, and force people into good style.
05:10:15 <scotd> ski: so i need to go look at function words :-) brb
05:10:40 <Cale> But it would be confusing for code that was correct but didn't leave spaces around the composition operator
05:10:41 <twink> The ambiguity is that spaces are allowed even with module names?
05:10:52 <cYmen> @src groupBy
05:10:52 <lambdabot> groupBy _  []       =  []
05:10:53 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:10:53 <lambdabot>     where (ys,zs) = span (eq x) xs
05:11:03 <Cale> twink: The ambiguity is that . is both an infix operator and the module path separator
05:11:39 <Cale> twink: So, you can have a module named A which defines a function called f, and a data constructor called A, and have A . f and A.f mean two different things.
05:12:16 <Cale> and the meaning of the latter depends on the presence of the module A in the imports
05:12:37 <Cale> While the former is unambiguously composition
05:12:42 <twink> But when there's no clash, they're both the same?
05:12:46 <Polarina> Are there any GLX bindings out there I do I have to make my own? :P
05:13:09 <Cale> When there's no clash, A.f means whichever of the two things makes sense.
05:13:20 <Cale> (either composition or module selection)
05:13:56 <Cale> It's awkward, but it sort of works. I think that '.' was a poor choice of module path separator, myself.
05:13:59 <twink> So you've got to track module imports to detect clashes, and spaces to resolve the clashes?
05:14:07 <Cale> yeah
05:14:52 <Cale> and it's extremely rare that there's an actual clash
05:15:09 <twink> Vaguely brutal. Some skeletal parsing to extract imported module names might be possible with less than total pain, but still.
05:15:13 <Cale> You would suspect malice if it actually came up.
05:15:56 <Cale> But yeah, for syntax colouring, deciding what to colour the A in A.f is tricky.
05:16:20 <Cale> So most things just end up colouring modules and data constructors the same way.
05:19:21 <twink> How much can it depend on things outside the file? Like A.B.x -- is B a module or a constructor?
05:24:58 <Saizan> in the current haskell if you say Foo.bar Foo is always interpreted as a module
05:24:59 <Cale> twink: It could be either a constructor in A, or a module
05:25:17 <Saizan> as implemented by GHC, at least
05:25:18 <Cale> Saizan: Oh really?
05:25:44 <Saizan> > Just.foo
05:25:45 <lambdabot>   Not in scope: `Just.foo'
05:26:00 <Saizan> > Just.map
05:26:01 <lambdabot>   Not in scope: `Just.map'
05:26:02 <Cale> hmm, interesting
05:26:24 <Cale> I was pretty sure the hierarchical libraries standard said that it was disambiguated by spaces
05:26:45 <Saizan> > [False..] -- this is how you usually bump into this
05:26:46 <lambdabot>   <no location info>: parse error on input `]'
05:27:05 <Cale> Oh, yeah, that's pretty brutal ;)
05:27:46 <Cale> Sorry "Hierarchical Module Namespace Extension"
05:28:51 <Cale> Perhaps I'm mistaken :)
05:29:02 <Cale> In which case, that's considerably simpler than I thought.
05:29:34 <Twey> > Just.map "foo"
05:29:36 <lambdabot>   Not in scope: `Just.map'
05:29:45 <Twey> > Just . map "foo"
05:29:46 <lambdabot>   Couldn't match expected type `a -> b'
05:29:47 <lambdabot>         against inferred type `[GHC.T...
05:29:51 <Twey> Eh?
05:29:53 <Twey> :t (.)
05:29:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:30:12 <Twey> Oh, haha
05:30:29 <Twey> > Just . map succ "foo"
05:30:30 <lambdabot>   [Just 'g',Just 'p',Just 'p']
05:30:35 <Twey> > Just.map succ "foo"
05:30:36 <lambdabot>   Not in scope: `Just.map'
05:30:39 <Twey> Hm
05:31:23 <Twey> We should really just go for significant spacing already
05:33:39 <Cale> Man, if this was *really* a committee language, we'd have gone with "any infix operator is a module path separator if it occurs without surrounding spaces"
05:34:07 <Cale> ;)
05:36:55 <Saizan> that'd make it too easy to win obfuscation contests
05:37:07 <Twey> Cale: Haha
05:37:08 * hackagebot explore 0.0.7.1 - Experimental Plot data Reconstructor  http://hackage.haskell.org/package/explore-0.0.7.1 (CetinSert)
05:38:09 <Jafet> ( ) a b = ...
05:40:05 <Cale> Compromising to the point of idiocy is awesome. I seem to recall that the ATM protocol committee couldn't agree on whether to make the packets 42 or 64 bytes, and so they compromised and went with 53.
05:40:25 <Cale> (which is the average of the two)
05:40:55 <Jafet> Real mean of them
05:41:04 <Polarina> lol
05:41:13 <Cale> So it has nice prime-number-sized packets
05:42:25 <Jafet> If TH had significant whitespace, you could have real DSLs
05:43:18 <Cale> Jafet: You can use quasiquoting and do your own parsing.
05:43:55 <Jafet> I had the impression that still tokenized with haskell rules
05:44:05 <Cale> hmm
05:44:28 <Cale> I confess that I have not once actually used the quasiquoter extension myself
05:47:17 <cYmen>  What does the $ operator do?
05:47:34 <xerox> applies
05:47:35 <Twey> Function application
05:47:49 <Cale> f $ x = f x, but $ has really low precedence
05:48:07 <Cale> So when you write something like f . g . h $ x + y
05:48:16 <Cale> it means the same as (f . g . h) (x + y)
05:48:29 <cYmen> ok, thanks
05:49:02 <Jafet> I want a dollar for every time I have to explain $
05:49:23 <Cale> A common idiom is to chain together a bunch of functions using function composition, and apply the composite function to a value using $
05:50:00 <Cale> You can't mess up the parens which you don't have to write :)
05:51:54 <FliPPeh> HTML is actually fun with Text.Xhtml
05:52:03 <Cale> Yeah
05:52:13 <Cale> No closing tags to write :)
05:52:15 <interferon> if i have two record types that have a filed named "sales" i have to use two different function names for each
05:52:23 <interferon> is there a way around that?  can i overload the name?
05:52:29 <FliPPeh> linkCSS = tag "link" noHtml ! [rel "stylesheet", thetype "text/css", htmlAttr "media" << "screen", href "style.css"]
05:52:35 <FliPPeh> That's just beautiful
05:52:52 <interferon> FliPPeh: what library is that?
05:53:02 <FliPPeh> interferon: Text.Xhtml
05:53:10 <Cale> interferon: You can put them in different modules, or you can prefix the names with something identifiable.
05:53:23 <interferon> i've been prefixing them, but maybe I should look at different modules
05:53:24 <interferon> thanks
05:53:35 <Cale> interferon: The reason that you have to keep them separate is that they're not just field names, but really the names of functions that you're defining to extract the fields.
05:53:48 <Cale> interferon: It wouldn't be well-typed to name them the same thing
05:53:53 <interferon> i see what you mean
05:54:28 <Cale> You can however, make a typeclass, and make each of those datatypes an instance.
05:54:41 <interferon> i was just going to ask if i could do that
05:55:23 <Cale> But there's no particularly automatic way to do it that I'm aware of (though I wouldn't be too surprised if someone had cooked up some Template Haskell to help with it)
05:55:42 <Cale> It's easy enough to write the classes and instances yourself if there are not so many.
05:55:58 <Cale> But you should only really do it if the similarly named fields are really related to one another.
05:56:09 <Cale> I wouldn't do it just for the vanity of sharing the name.
05:56:28 <Cale> If they're at all conceptually different, they ought to have different names anyway.
05:57:17 <interferon> that makes sense
05:57:19 <interferon> thanks
05:57:38 <danblick> There's a remark in RWH that it might be better to use monadLib than the mtl.  Could anyone comment on this?  What's your preferred way to use monad transformers?
05:57:49 <Jafet> I always thought that it should be possible to scope them within the type name, ie. TypeName.ConsName. Is this a bad idea?
05:58:02 <Cale> danblick: My preferred way to use monad transformers is to not make it apparent that I'm doing so.
05:58:28 <Cale> danblick: (that is, not to export anything from the module which would make it obvious that a monad transformer was used in the construction of my monad)
05:58:57 <Cale> danblick: Some people disagree with me on this though :)
05:59:06 <Twey> I approve
05:59:11 <Cale> monadLib is nice, mtl is used almost everywhere though
06:00:24 <danblick> Cale, thanks, that sounds reasonable
06:00:32 <Twey> I don't understand monadLib, but it sounds cool.  ☺
06:00:56 <Cale> Is hackage slow for anyone else, or just me?
06:01:19 <Cale> (could very well just be me, in which case I should reset my router...)
06:02:34 <danblick> (I can get pages from hackage.haskell.org without much latency)
06:02:39 <Cale> okay
06:03:26 <Twey> Cale: It's okay for me.
06:03:52 <Cale> I have a stupid cheap Linksys router which is not compatible with 3rd party firmware and which seems to mysteriously accumulate slowness over time and needs to be restarted.
06:04:00 <Twey> Ych.
06:04:03 <Cale> brb
06:04:04 <Twey> STill?
06:04:09 <Cale> yeah
06:04:12 <Twey> You've had that old thing for years
06:04:15 <Twey> You should replace it already :þ
06:04:59 <Cale> I should probably do something about it, but before that, I should probably do something about not having a real job.
06:08:04 <Cale> One nice thing about monadLib is that it's not split into dozens of modules.
06:08:53 <Cale> another is that it generalises liftIO to inBase
06:09:29 <Cale> and it also defines a bunch of machinery for deriving the instances of various classes of operations
06:11:14 <Twey> What is the name for the ‘class Foo | e -> m where …’ syntax, again?
06:15:33 <Cale> Twey: Functional dependencies
06:15:42 <Twey> Ah, that's it — thanks
06:19:24 <scotd> If I wanted to write a string parser by hand, would a good approach be to write one function per term in the Backus-Naur Form?
06:20:26 <chrisdone> scotd: parsec?
06:21:20 <chrisdone> http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.html#Expressions
06:21:33 <scotd> chrisdone, thanks, but i'm trying to understand how to do it myself without using monads
06:22:39 <scotd> chrisdone, i looked at the definition of 'words' function in the prelude (this approach was recommended by ski in this channel)
06:22:57 <scotd> so generalizing, it looks like i'd need one function per BNF term?
06:23:08 <Saizan> the most natural approach is to do a recursive descent parser i think, + backtracking
06:23:42 <Saizan> a function for every non-terminal symbol in your grammaer
06:27:38 <scotd> Saizan, do you think i could eliminate the backtracking if i used seq?
06:27:43 <FliPPeh> Hmm
06:28:01 <Saizan> scotd: what do you mean?
06:28:14 <scotd> if it was strict evaluation
06:28:24 <FliPPeh> Network.CGI seems to be nice with Text.Xhtml, but how would I generate a bigger webpage than "Enter your name -> hi name" with it?
06:28:28 <scotd> maybe not
06:28:37 <FliPPeh> I can only output the contents once..
06:28:56 <FliPPeh> Not build up the page piece by piece
06:29:03 <Saizan> you need backtracking to support all the grammars, evaluation is orthogonal
06:29:36 <scotd> Saizan, ok thanks... reading about it now...
06:29:39 <Saizan> if you restrict yourself to LL(1) grammars you won't need backtracking
06:30:27 <Saizan> FliPPeh: you build a single html value that describes the whole page?
06:30:51 <FliPPeh> Saizan: But when there's a lot of things changing on the page?
06:31:08 <FliPPeh> I'm used to build them up piece by piece, as you do with PHP for example
06:31:47 <Saizan> you can easily just use functions to split your concerns
06:33:37 <FliPPeh> Saizan: do you know a medium sized example of Haskell CGI?
06:33:44 <FliPPeh> Something to get the idea
06:35:03 <Saizan> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell#File_uploads <- here for example, page is parametrized by the title and the body
06:35:25 <Saizan> it's a trivial example though
06:35:32 <FliPPeh> That's what I'm already doing
06:36:11 <Saizan> you can continue like that
06:36:41 <Saizan> what might change becomes a parameter of the function
06:37:13 <FliPPeh> I think the problem I'm facing is, that all dynamics come from the cgiMain function, and if I need to put dynamics inside a deeply nested element across 20 functions, I'd have to change 20 functions
06:37:26 <Saizan> "functions" actually, you'd split it in more than one
06:38:43 <Saizan> it's usually preferred to use a MVC approach, so that the Html generation is a pure function from the model
06:39:09 <scotd> flippeh, what if you had a page footer on 20 pages? you'd just change the footer function once, right?
06:39:18 <FliPPeh> of course
06:39:33 <Saizan> however it's still simple to fetch the data from IO and pass that as an argument to your rendering function
06:39:52 <FliPPeh> I think I should try a practical example
06:39:59 <Saizan> you can use HOFs to avoid adding parameters to all the intermediate ones
06:40:02 <FliPPeh> To get a feeling for it
06:42:01 <Saizan> http://blog.well-typed.com/2008/05/information-plumbing/ <- might help
06:46:53 <danderson> I'm looking at how to strictly serialize data as efficiently as possible. I know the final serialized length of the message at the start of serialization, so my imperative instinct is to preallocate a byte array that long, then fill it up.
06:47:10 <danderson> how would I do something similar in Haskell, to end up with a strict ByteString at the end of serialization?
06:48:07 <danderson> I was looking at Foreign.Storable, which offers a nice way of filling an allocated byte array with serialized data, but I'm unsure of how (or if it's even possible) to then convert that `Ptr a` into a ByteString
06:49:49 <danderson> oh, well, packCString looks reasonably like what I wanted. Pity it still needs to O(n) copy the storage, but it's better than nothing I suppose.
06:49:56 <Cale> danderson: Seems like premature optimisation to me
06:50:38 <Cale> Just operate on strict ByteStrings, and see if it's too slow at the end.
06:50:47 <danderson> right now it's more an academic consideration of "how would I do it" than anything else
06:50:58 <Polarina> Are there any GLX bindings out there?
06:51:28 <danderson> Cale: also, serializing to a strict bytestring mean using cons, append and other O(n) operations to construct the string
06:51:41 <Ke> btw opengl4 was just released
06:51:43 <danderson> given that the end size is already known, it feels like a huge waste.
06:51:47 <Polarina> Ke, I know.
06:53:03 <Cale> danderson: Well, yeah, you don't want to have to do a lot of consing on strict bytestrings. You could always use lazy bytestrings which have better asymptotic performance for those operations and then convert after
06:53:14 <Cale> (or not at all)
06:53:47 <Cale> There's a low-level interface to strict bytestrings in Data.ByteString.Internal
06:54:23 <danderson> hmm, using lazy bytestrings and then doing a concat . toChunks is something I hadn't considered. Interesting thought.
06:55:20 <danderson> and ByteString.Internal also looks interesting if I end up aiming for as fast and as incomprehensible as possible.
06:55:26 <Saizan> the Builder monoid in the binary package is probably the most efficient way to build a (lazy) bytestring from pieces
06:55:57 <Cale> Ah, yeah, if you're working with binary data, there are nice libraries like cereal
06:56:01 <Cale> (and binary)
06:56:32 <danderson> Saizan: I've been using binary, but not knowing the size of the serialized message beforehand works against efficiency here
06:56:45 <Cale> My understanding is that cereal is the new, faster and nicer version of binary, but I haven't tried it.
06:57:04 <danderson> (more context: I'm blue-skying about how I'd go about implementing a protocol buffers port to haskell, focusing on the most ridiculously fast serialization/deserialization)
06:57:16 <danderson> (yes, I know there is already a protocol buffers port :)
06:57:36 <danderson> looking at cereal, thanks for the reference.
06:58:22 <Cale> Oh, apparently it is limited to finite inputs, but that's probably not a concern for you
06:58:34 <Cale> It's much nicer in handling parse failure though.
06:59:04 <Cale> Since you're working with the other side of things, neither of those is really a concern
07:00:06 <marcot> Sorry, I got connection problems.. please resend any answers to my question.
07:00:07 <lambdabot> marcot: You have 1 new message. '/msg lambdabot @messages' to read it.
07:00:12 <fax> I hate solving problems on paper :(
07:00:39 <Saizan> Builder uses a buffer internally, using a default size of ~32k
07:00:52 <Saizan> it seems you could look at the code for inspiration though
07:01:09 <Cale> marcot: I don't see your question
07:01:30 <Saizan> danderson: ^^^
07:01:59 <Cale> fax: Somehow I prefer it. It's all the tedious little details in a real implementation which I usually have trouble forcing myself to take care of.
07:02:06 <marcot> I remember read something about replacing the semantics of = in haskell, I don't remember if it was in a blog post or in haskell-cafe.
07:02:20 <marcot> Does anyone remember (and has a link) of something like that?
07:02:24 <Cale> marcot: You mean for pattern bindings?
07:02:30 <Twey> = has semantics?
07:02:51 <danderson> Saizan: good point, I'll take a look.
07:02:56 <Cale> marcot: or the more recent thing about the typing rules for let?
07:03:42 <danderson> Saizan: this thinking was actually prompted by the realization that the protocol buffers port actually makes it very hard to use as a Distribution.Simple preprocessor, which kinda negates the point of having all the fancy code generation stuff that it has.
07:03:59 <marcot> Cale: I'm not sure.  It was something that changed the way = works, and it had a sequence of lets, which would make some tricky things like 1 + 1 become 3.
07:04:09 <Cale> Uh...
07:04:15 <danderson> and so I'm idly pondering how I'd go about implementing a protocol buffers encoder/decoder that I'd be happy with, as an exercise.
07:04:15 <marcot> I don't remember it exactly, but I think it was some kind of overload of =
07:04:19 <Cale> You can redefine + so that 1 + 1 = 3
07:04:19 <fax> Cale I cant program stuff either but what I am basically doing is finding the right expression in a graphing calculator and then working backwards to 'solve' the integral...
07:04:29 <Cale> > let 1 + 1 = 3 in 1 + 1
07:04:30 <lambdabot>   3
07:04:46 <marcot> Cale: yes, that's just what I was looking for.
07:04:46 <fax> because I just get it wrong every time
07:05:11 <Cale> fax: ah. In university, we only did enough symbolic integrals by hand to make us hate them, and no more.
07:05:37 <Cale> fax: Which was about 8, one of which I remember was the indefinite integral of sec^5 x
07:05:42 <fax> haha
07:05:52 <marcot> Cale: thanks, and sorry for expressing it in the wrong terms.
07:06:07 <fax> what is bugging me is like.. why have to do this? since the computer can do it...
07:06:12 <Cale> marcot: This is just a local redefinition of + with a pattern match
07:06:30 <fax> it's like weightlifting I guess
07:06:33 <fax> but that is not very fun
07:06:35 <Cale> fax: Well, some of the results which let you compute integrals are more important than the integrals themselves.
07:06:46 <marcot> Cale: I noticed, it's quite simple.
07:06:54 <fax> yeah I only like theorems, I don't want to actually solve any problems myself!
07:06:54 <Cale> fax: But yeah, I agree, it's not really something that humans should spend lots of time on.
07:07:07 <Cale> Computation should be left to computers.
07:10:49 <Saizan> "pointless" exercises might be valuable if they make you build some more intuition
07:11:03 <Saizan> no idea if this is the case
07:11:17 <fax> well the truth is I am rubbish at not making mistakes
07:11:28 <fax> I will forget to carry a one, or I mix up + and - signs
07:11:44 <fax> and it is true that doing these will make me do that less..
07:11:47 <fax> but its not fun :P
07:12:53 <danblick> i wish i had found out about universal algebra in school
07:13:11 <fax> I don't really get universal algebra
07:13:15 <fax> what's it for?
07:13:20 <fax> other than defining homomorphism
07:13:32 <Cale> I wish that my uni had offered a real category theory course. That would have been fun.
07:15:28 <Cale> fax: It's another approach to generalising abstract algebra, which is less general than category theory, and thus has more specific results.
07:15:47 <profmakx> is yi dead?
07:17:22 <Cale> I don't think it could really be considered dead until there's a more complete text editor of its sort written in Haskell.
07:17:55 <Cale> As to whether there's active development, I'm not sure.
07:18:33 <Saizan> the last patch is from Thu Feb 18 09:52:36 CET 2010
07:18:50 <Cale> The bigger Haskell projects seem to undergo periods of dormancy, since there are only so many Haskell programmers to keep them going.
07:19:15 <Cale> Well, that's encouraging. The last upload to Hackage is from Jul 14 2009
07:19:47 <Saizan> maybe they scheduled too many tickets for the next milestone :)
07:21:36 <jeffwheeler> What project is that?
07:21:40 <jeffwheeler> Sounds like Yi . . .
07:21:45 <Cale> jeffwheeler: That's right
07:22:41 <jeffwheeler> Yeah, JPB (maintainer) is pretty busy, so he really doesn't do much on it, and I'm in the same position. I was contributing a decent amount a while back.
07:22:42 <Cale> jeffwheeler: profmakx was asking if Yi was dead
07:22:50 <jeffwheeler> Cale: I really wish it wasn't :(
07:22:55 <jeffwheeler> I love Yi.
07:23:19 <Cale> jeffwheeler: My response was that Yi can't really be considered dead until there's a more complete text editor of its type written in Haskell
07:23:43 <profmakx> well, perhaps i should have asked in a different way
07:23:45 <jeffwheeler> Cale: that makes sense. I don't think Leksah really tries to compete. (It even tries to integrate Yi into the UI.)
07:23:50 <profmakx> as in: Is development on Yi dormant :P
07:24:16 <jeffwheeler> profmakx: no, but I thought about patching something about scrolling while sleeping last night. And then I forgot what it was.
07:24:21 <jeffwheeler> Err, "yes, but"
07:24:59 <cYmen> hm..what are the associativity laws for haskell.... how is something like this filled up with brackets "foldr step id xs z
07:25:19 <Saizan> jeffwheeler: maybe you or JPB could write up a GSOC project idea on the wiki, to harness a student-summer of work :)
07:25:20 <opqdonut> associate to the left
07:25:28 <cYmen> is that (foldr step id xs) z or foldr step (id xs) z or whatever
07:25:39 <opqdonut> so (((foldr step) id) xs) z
07:25:43 <Cale> (((foldr step) id) xs) z
07:25:50 <cYmen> ok
07:25:51 <jeffwheeler> Saizan: ha, that's a great idea; it's an odd angle, me being a college student
07:25:53 <opqdonut> and function application binds the tightest
07:25:58 <opqdonut> so f x ++ y is (f x) ++ y
07:25:59 <jeffwheeler> (although I have a job this summer)
07:26:22 <jeffwheeler> Saizan: I'll post that on the Yi mailing list
07:28:17 <Saizan> jeffwheeler: good, you should consider being a mentor maybe, it takes far less time
07:28:46 <jeffwheeler> Saizan: I'm not really sure I'm knowledgeable enough for that :-/
07:28:49 <cYmen> ok now   where step x g a = g (f a x) is used as step in a foldr ...shouldn't that take only 2 parameters?
07:29:16 <Twey> cYmen: Not if the two-parameter function produces a function
07:29:25 <chrisdone> In general I think we should emphasise getting your code up on Hackage as soon as possible, or at least github or patch-tag. Release early, release often, and all that. There's a bunch of Hackage packages I've used that were bare bones but really helped me with a project and that I have contributed to. Having an incomplete implementation shouldn't stop you sharing it. Perhaps Hackage could be somehow linked to github and patch-tag by
07:29:25 <chrisdone> RSS feeds, e.g. on the What's New page: http://hackage.haskell.org/packages/archive/recent.html
07:29:46 <Twey> ‘step x g a = …’ means ‘step x g = \a -> …’
07:30:23 <cYmen> Twey: uh...what?
07:30:31 <cYmen> that looks like the opposite of currying or something
07:31:04 <Saizan> currying has to do with the fact that those two are denotationally the same
07:31:26 <Saizan> ?type foldr
07:31:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:32:01 <Saizan> cYmen: from another point of view, the 'b' type variable in the type of foldr above can be instantiated to a function type
07:32:20 <chrisdone> @ty \t -> \t1 -> \t2 -> "[Char]"
07:32:21 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> [Char]
07:32:59 <chrisdone> @ty \t t1 t2 -> "[Char]"
07:33:00 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> [Char]
07:33:50 <Stalafin> i need to parse a line, which looks like this: char number number number string; can somebody point me to something that might help me?
07:34:29 <Saizan> > words "a 123 12 123 abc"
07:34:30 <lambdabot>   ["a","123","12","123","abc"]
07:34:57 <Stalafin> oh this is cool, thanks!
07:35:32 <chrisdone> > (id &&& takeWhile isLetter) . dropWhile isSpace . takeWhile isDigit $ "123 sausage"
07:35:33 <lambdabot>   ("123","")
07:35:47 <chrisdone> oops
07:36:01 <Cale> Stalafin: words is probably simple enough in this case. For anything more complex, I would recommend a parsing library such as Parsec or ReadP (they're pretty close to interchangeable with one another in their basic use, so learn any one of them)
07:36:22 <Twey> f (words -> ((head -> c) : (read -> n1) : (read -> n2) : (read -> n3) : str)) = …
07:36:36 <Twey> View patterns ♥
07:36:46 * hackagebot explore 0.0.7.2 - Experimental Plot data Reconstructor  http://hackage.haskell.org/package/explore-0.0.7.2 (CetinSert)
07:37:05 <chrisdone> Twey: are views a standard extension in ghc now?
07:37:29 <Saizan> they are not enabled by default
07:37:38 <Saizan> and they aren't in Haskell2010
07:37:46 <Stalafin> Cale: yeah, it looks great;
07:37:53 <chrisdone> Saizan: what cool stuff is? :p
07:37:54 <Stalafin> Cale: don't think i need more
07:38:12 <Twey> chrisdone: http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
07:39:07 <Saizan> chrisdone: yeah, i wasn't sure what meaning of standard you were using though :)
07:39:50 <Stalafin> Cale: just got a question: say the first few lines should be disregarded, and the prog should start reading from the first line that matches that pattern char num num num string
07:39:58 <Stalafin> Cale: is there a way to do that?
07:40:22 <Twey> Stalafin: map f . drop n . lines
07:40:36 <Twey> Oh, wait — I see
07:41:19 <Cale> Stalafin: That's a little trickier, but it's manageable using reads
07:41:25 <Cale> :t reads
07:41:26 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:41:40 <Cale> It might be preferable to just use ReadP
07:41:41 <chrisdone> Twey: none of that is cool
07:41:48 <Twey> I wish I could do f (words -> ((head -> c) : (read -> n1) : (read -> n2) : (read -> n3) : str)) = Just (…); f _ = Nothing; g = catMaybes . map f . lines
07:41:54 <jeffwheeler> I'm having trouble applying dons' patch "add new LLVM code generator to GHC" patch to the GHC head; it seems to just hang on 75/82 (left it overnight)
07:41:59 <jeffwheeler> I'm following the info here: http://alpmestan.wordpress.com/2010/03/11/getting-ghc-head-and-llvm-working-together/
07:42:04 <Twey> chrisdone: Whatchoo talkin' 'bout, boy?
07:42:05 <Cale> I'll write a ReadP parser to show how you'd do it
07:42:14 <jeffwheeler> Is that patch still necessary, or has it already been put in GHC head or something?
07:42:33 <chrisdone> Twey: I remember when 2010 came out and I was really excited about some -XExtenions being standard Haskell. and then I read stuff like "Hierarchical module names: a small extension to the Haskell 98 syntax to allow module names to contain a dot '.', thus allowing modules to be structured in a hierarchy." ... wow ...
07:43:36 <mreh> how could I get this into whnf succinctly?: "map (\(x, y) -> if x == y then ((x,y),0) else ((x,y),1)) keys"
07:43:50 <McManiaC> how can you turn a char/string into its binary representation? like "en" → 00 02 65 6e (?)
07:43:59 <Twey> I guess I could readMaybe = listToMaybe . fmap fst . reads; f (words -> ((take 1 -> [c]) : (readMaybe -> Just n1) : (readMaybe -> Just n2) : (readMaybe -> Just n3) : str)) = Just (…); f _ = Nothing; g = catMaybes . map f . lines
07:44:12 <mreh> it's mapping a lambda expression to a list, that's going to give me a list of un-evaluated lambda expressions applied to arguments
07:44:16 <Twey> That'd work
07:44:22 <Twey> chrisdone: Ahh, yeah
07:45:45 <Saizan> McManiaC: Data.Char.ord and showHex
07:45:50 <Saizan> ?hoogle showHex
07:45:50 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
07:47:29 <Saizan> unless you wanted a specific encoding rather than unicode codepoints
07:47:49 <Stalafin> Twey: what magic are you doing there? :D
07:47:49 <McManiaC> hmmm how does showHex work?
07:49:06 <Twey> Stalafin: Jus' plain ol' pattern matching, with a little view-pattern deliciousness thrown in
07:50:07 <Twey> McManiaC: showHex = showIntAtBase 16 (['0' .. '9'] ++ ['a' .. 'b'])
07:50:11 <Twey> McManiaC: Not very exciting :þ
07:50:23 <Stalafin> Twey: first, since i am still being confused a lot by dot free notation: map f . drop n . lines - please explain
07:50:24 <Twey> Er, ['a' .. 'f']
07:50:40 <Twey> Stalafin: Dot free notation?  :þ
07:50:43 <Stalafin> Twey: i understand, map takes a function (f) and a list
07:50:47 <Twey> Stalafin: Yep
07:51:09 <Twey> Stalafin: lines breaks it up, then passes it to drop n, which drops the first few elements, then passes it to map f
07:51:34 <Stalafin> Twey: so.... with the dots.... i apply lines to a string, get a list of strings, drop n string, and then map has arguments f and the result of drop n . lines ?
07:51:39 <chrisdone> Twey: haha, a...b
07:51:40 <Stalafin> Twey: i see
07:51:45 <Twey> Stalafin: That was before I realised that you wanted ‘n’ to be determined by the number that actually parsed, though
07:51:58 <Twey> Stalafin: That's right
07:52:00 <Stalafin> Twey: same thing as map f (drop n (lines foo))
07:52:03 <McManiaC> Twey: kay ^^
07:52:06 <Twey> Stalafin: Yes
07:52:11 <Stalafin> kool
07:52:24 <Saizan> > showHex 13 ""
07:52:25 <lambdabot>   "d"
07:52:46 <Twey> Oh, there should be a !! in there, too >.<  Sorry
07:53:00 <Twey> > showIntAtBase 16 (['0' .. '9'] ++ ['a' .. 'b'] !!) 13 ""
07:53:01 <lambdabot>   The operator `GHC.List.!!' [infixl 9] of a section
07:53:01 <lambdabot>      must have lower pre...
07:53:07 <Twey> > showIntAtBase 16 ((['0' .. '9'] ++ ['a' .. 'b']) !!) 13 ""
07:53:08 <lambdabot>   "* Exception: Prelude.(!!): index too large
07:53:13 <Twey> Argh.  xD
07:53:16 <Twey> > showIntAtBase 16 ((['0' .. '9'] ++ ['a' .. 'f']) !!) 13 ""
07:53:17 <lambdabot>   "d"
07:53:20 <Twey> There you go
07:55:45 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8540#a8540
07:55:52 <Cale> Stalafin: ^^
07:56:46 <Cale> Stalafin: note, this ignores any line on which the parse fails
07:56:55 <Stalafin> Cale: this look complicated :p
07:56:57 <Cale> Stalafin: rather than just at the start
07:57:13 <Stalafin> Cale: will dig into that; thank you
07:57:15 <Cale> Stalafin: It's rather nice and flexible once you get the notation
07:57:31 <Stalafin> Cale: yeah, it's the notation still, which i find confusing
07:58:06 <Cale> Stalafin: The idea is that a value of type (ReadP t) represents a parser which might eat some characters, before producing a value of type t
07:58:31 <Cale> and each parser does this nondeterministically (there can be backtracking in cases where the parse is ambiguous)
07:58:37 <int-e> > map intToDigit [0,9,10,13]
07:58:38 <lambdabot>   "09ad"
07:58:52 * hackagebot mtp 0.1.1.1 - Bindings to libmtp  http://hackage.haskell.org/package/mtp-0.1.1.1 (JoachimFasting)
07:59:46 <Stalafin> Cale: wht i do not understand is, that you make define dataLine; but before you give it a type... this part i find very confusing
08:00:01 <Cale> Stalafin: hm?
08:00:11 <Stalafin> Cale: sentence building fail...
08:00:22 <Stalafin> Cale: a type ReadP(.....)
08:00:28 <Stalafin> i have never seen such an expression
08:00:45 <marcot> Why does the Num class requires the Show and Eq classes?
08:00:54 <chrisdone> > showIntAtBase 26 (['a'..'z'] !!) 2170814761 ""
08:00:54 <Cale> That type means that dataLine is a parser which, when run, will (try to) produce a value of type (Char, Integer, Integer, Integer, String)
08:00:55 <lambdabot>   "haskell"
08:00:56 <Twey> Why is moonpatio broken?  ☹
08:01:10 <Cale> Twey: moonpatio is the one which is working for me...
08:01:17 <marcot> Prelude says: "The class Num of numeric types is a subclass of Eq, since all numbers may be compared for equality"
08:01:20 <Cale> hpaste.org is broken
08:01:25 <Twey> I'm getting connectoin failures on moonpatio, Cale
08:01:28 <Cale> hmm
08:01:30 <Twey> Intermittently
08:01:46 <Cale> marcot: That's a stupid wart of Haskell 98
08:01:48 <Twey> hpaste.org connects OK, but has a database error
08:01:52 <marcot> Is there anything besides it?  Something operational?
08:01:57 <Cale> marcot: It's best not to try to understand why
08:02:12 <chrisdone> > showIntAtBase 26 (['a'..'z'] !!) (26^6*7+26^4*18+26^3*10+26^2*4+26*11+11) ""
08:02:13 <Cale> marcot: "Not for any good reason" is probably the best answer
08:02:13 <lambdabot>   "haskell"
08:02:17 <chrisdone> gotta love operator precedence
08:02:34 <marcot> Cale: One thing I thought is that in pattern matching of literal numbers, the pattern is turned into an equality.
08:02:54 <marcot> Like: f 1 = ...  --> f x | fromInteger x == 1 = ...
08:03:10 <Drk-Sd> hi!
08:03:11 <chrisdone> it's actually just pattern matching the constructor '1'
08:03:15 <Drk-Sd> is there any vim user here ?
08:03:24 <marcot> Hence the need of the Eq class.
08:03:30 <chrisdone> nope
08:03:31 <marcot> But Show I can't see no reason.
08:03:42 <chrisdone> you don't need an Eq class to see if Nothing matches Nothing
08:03:51 <chrisdone> it's the same constructor
08:04:00 <Saizan> chrisdone: but for numeric literals it's desugared into an use of ==
08:04:07 <Saizan> there's no 1 constructor
08:04:41 <chrisdone> ok
08:05:11 <Cale> drk-sd: Most people here use vim or emacs. I'm a vim user.
08:05:53 <Cale> marcot: yeah, that's the rationale for Eq, though it's a bad one, since just demanding that the type be in Eq when using that sort of pattern match would make much more sense
08:05:56 <drk-sd> Cale: ok, well i've been using emacs for years but recently i decided i would give vim a shot
08:06:10 <Stalafin> Cale: ah, ok... well, i am not even defining types for my functions yet :D
08:06:20 <marcot> Cale: sure, this would be better.  Is there a proposal to change this in language level?
08:06:40 <drk-sd> and i must say i'm very pleased with it, but there's still one thing that i'm not happy with
08:06:48 <drk-sd> it's the haskell coloration
08:07:08 <Cale> marcot: I think most people think it should be that way, but somewhat foolishly we haven't figured out a good way to make changes to the Prelude that conflict with the standard.
08:07:10 <drk-sd> i mean, when i'm using emacs i've the function names in a color, the args in another one
08:07:17 <drk-sd> with vim, none of them are colored
08:07:23 <drk-sd> is there a way to change that ?
08:07:35 <drk-sd> (a syntax file i could find online, or whatever)
08:07:44 <Cale> marcot: Most of the machinery is in place to do so. Just define a new version of the base package... but for some reason it doesn't happen.
08:08:16 <Cale> drk-sd: :syntax on ?
08:08:42 <marcot> Cale: But usually you don't need Eq a to make a pattern matching, so maybe people don't want to include this exception to types that are Num.
08:08:43 <Cale> drk-sd: Oh, the default syntax doesn't colour them differently, I suppose.
08:08:49 <Cale> drk-sd: I'm not sure.
08:08:59 <drk-sd> Cale: i've syntax on
08:09:07 <marcot> Cale: Yes, it would not be hard to use a newer base..
08:09:26 <drk-sd> but it dœsn't colour them differently yeah, i could show you a screenshot if you didn't understood what i meant
08:09:37 <drk-sd> (my english is very approximative, i'm sorry for that)
08:09:45 <Cale> marcot: people take the Haskell 98 standard too seriously
08:10:04 <Cale> marcot: Strangely enough, we've managed to change the *other* libraries which Haskell 98 defines.
08:10:29 <Cale> It's just the Prelude which has gotten frozen at one of its most embarrassingly awkward points.
08:10:46 <Cale> The Haskell 1.4 Prelude was a lot nicer than the Haskell 98 Prelude.
08:11:03 <marcot> Cale: This is really something that should be worked out.  Should we expect something like this to haskell 2011?
08:11:04 <Cale> Even just reverting to it would be better. (I'm not sure if it fixes that particular problem or not)
08:11:12 <drk-sd> Cale: http://rsz.me/8i
08:11:14 <Cale> Haskell 2011 is the wrong place to make the change, imo
08:11:22 <Cale> The right place to make the change is in GHC first
08:11:35 <Cale> and then, if we decide that we like it, in the standards document
08:11:59 <marcot> Cale: Wouldn't it be easier to just create a new-base package in hackage?
08:12:02 <Cale> The goal being never to standardise things that we haven't extensively tried.
08:12:07 <marcot> So that people could install it and test it?
08:12:19 <marcot> Without the need to change ghc?
08:12:23 <Saizan> you can't really install base as a standalone package
08:12:37 <Cale> Yeah, base is too deeply tied to ghc for that
08:12:54 <Cale> But changing GHC itself to try these things wouldn't be a bad thing, I think.
08:13:01 <Saizan> and the Prelude that comes with the "real" base is somewhat tied to the desugaring of a lot of syntax, though you can use NoImplictPrelude for that
08:13:08 <Cale> At least for changes as uncontroversial as this one.
08:13:14 <twink> I think people disagree on the path to going back to a more generalized prelude or something.
08:13:29 <Cale> There are lots of changes which are controversial
08:13:30 <marcot> Cale: There're things like numeric-prelude
08:13:34 <Cale> and which make things hard to do
08:13:55 <Saizan> this change would probably break most oh hackage though :)
08:14:05 <Saizan> *of
08:14:11 <Cale> numeric-prelude would be an awesome package if it weren't a Henning Thielemann abomination
08:14:30 <FliPPeh_> @pl dp c = paragraph << (show c)
08:14:30 <lambdabot> dp = (paragraph <<) . show
08:15:05 <Cale> I've more than once considered writing a tool to sanitise Henning Thielemann's code.
08:15:13 <twink> NoImplicitPrelude falls down as soon as you make positive integer literals fromNatural instead of fromInteger (or similar sorts of literal coercions). I never figured out the ghc magic to change how literals are desugared or whatever.
08:15:30 <marcot> Cale: what's the problem with it exactly?
08:15:52 <Twey> foo :: C a => T a -> T a
08:15:56 <Cale> marcot: He names all his types T and all his typeclasses C, making the documentation impossible to read, and qualified imports mandatory.
08:16:21 <marcot> Cale: wow, that's impressive.
08:16:25 <Twey> I think he has a couple of T's and T''s
08:16:31 <twink> omfg that's horrendous
08:16:35 <marcot> I'm reading the haddock documentation, it's strange indeed.
08:17:00 <chowder> haskell newb here, how do I install cabal?
08:17:09 <Twey> chowder: With your distribution's package manager, usuall
08:17:10 <Twey> y
08:17:20 <Cale> chowder: What OS?
08:17:27 <chrisdone> chowder: cabal comes with ghc. actually I don't even know anymore. is that part of the "platform"? O_O
08:17:27 <chowder> Ubuntu Linux
08:17:32 <Saizan> even T' and T'' ? that's just evil
08:17:34 <twink> I've moved in the other direction. I use long variable names in type variables, like type Graph vertex = Map vertex (Set vertex)
08:17:35 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.8.0/cabal-install-0.8.0.tar.gz -- on Linux, you're best off downloading this
08:17:44 <Cale> and running the bootstrap.sh from inside it
08:17:49 <Saizan> chrisdone: cabal-install never came with ghc
08:17:53 <fax> why bother calling everything T if you are just going to prime them?
08:17:59 <Saizan> chrisdone: only Cabal the library, and it still does
08:17:59 <chrisdone> Saizan: he didn't say cabal install
08:18:09 <chowder> Cale: I tried looking for cabal with my OS's package manager but its not there
08:18:20 <twink> fax: Maybe he doesn't like the letters R, S, U, or V.
08:18:23 <Cale> chowder: Right, take my advice instead.
08:18:35 <Mathnerd314> > repeat 1
08:18:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:18:48 <Heffalump> chowder: what OS?
08:18:55 <Cale> Heffalump: Ubuntu Linux
08:18:59 <Mathnerd314> how does lambdabot cut off the output?
08:19:10 <jeffwheeler> Mathnerd314: yes
08:19:18 <Cale> chowder: I'm on Ubuntu, and what I do is download the generic linux binary of GHC (6.10.4 for now) from the GHC website
08:19:22 <xerox> she  takes n . show . eval  more or less
08:19:28 <jeffwheeler> Mathnerd314: err, sorry, misread that
08:19:29 <chrisdone> > take 5 . show $ [1..]
08:19:30 <lambdabot>   "[1,2,"
08:19:32 <Cale> chowder: and then get that package for cabal-install and bootstrap it
08:19:50 <chowder> Cale: I installed ghc from the repos
08:20:10 <chowder> since Ubuntu is always a few versions behind would that cause compatibility issues?
08:20:17 <Cale> chowder: I don't use Ubuntu's packages for Haskell stuff, because Ubuntu (or Debian) likes to split the GHC package into a million tiny pieces which need separate installation to work normally.
08:20:29 <Cale> Yeah, and it's perpetually behind.
08:20:47 <Cale> But for now it's not *so* bad in that regard. 6.12 is still too new anyway
08:20:48 <marcot> Cale: that's not true nowadays.
08:20:54 <marcot> Cale: At least in Debian sid.
08:21:01 <orlandu63> dont use ubuntu for develpoment
08:21:05 <Heffalump> the Debian Haskell team has been doing a great job
08:21:05 <Cale> I'm talking about Ubuntu, not Debian.
08:21:19 <Heffalump> orlandu63: why? (I'm just installing it right now :-)
08:21:20 <Cale> With Debian, presumably you could get a reasonable version from testing.
08:21:32 <Twey> Heheh.
08:21:54 <Cale> With Ubuntu, the dev cycles for GHC and Ubuntu are misaligned so that new GHCs come out a few weeks after the Ubuntu freeze
08:21:54 <chowder> $ ghc --version || The Glorious Glasgow Haskell Compilation System, version 6.10.4 <<my version
08:22:11 <Heffalump> chowder: that's exactly the right version to be running now
08:22:23 <marcot> Cale: ghc 6.12.1 is going to be on testing in a few days.
08:22:27 <Cale> chowder: That'll work, except you'll end up installing a half-dozen libghc-foo-dev packages
08:22:46 <Cale> chowder: Which ones are the ones that come with GHC normally and everyone expects you to have are a bit hard to tell
08:22:50 <Heffalump> perhaps if we invoke Laney's name you'll get some advice on how to install cabal-install
08:23:03 <chrisdone> I'm on ubuntu and I just installed ghc from haskell.org and bootstrapped cabal install
08:23:04 <orlandu63> Heffalump: because there is Arch Linux
08:23:32 <chowder> chrisdone: that's what I'm about to do
08:23:33 <Heffalump> orlandu63: well, personally I just install GHC myself and use cabal for everything, but that's less appropriate for newbies.
08:23:37 <kaol> FYI, 6.12.1 migrated to Debian testing 20 minutes ago. Won't hit your mirrors for another half a day.
08:23:47 <Heffalump> kaol++
08:23:49 <Twey> Nice.
08:23:49 <Cale> chowder: If you're going to use the Ubuntu package, then at least you'll need libghc-mtl-dev. I'm not sure about what else.
08:23:55 <ben> $ apt-cache search ghc | grep libghc | wc -l
08:23:55 <ben> 228
08:23:59 <ben> I had no idea it was this bad
08:24:04 <chrisdone> chowder: I tend to install ghc to ~/ rather than global. requiring root to install things presents problems
08:24:05 * Laney peers around
08:24:44 <marcot> ben: Why is this bad?
08:25:05 <ben> That is a lot of packages to get the equivalent of a single package
08:25:16 <Cale> ben: Not all of those come with GHC normally
08:25:19 <kaol> But others did most of the work with migrating the libraries. nomeata++
08:25:26 <Cale> ben: Only a difficult-to-determine subset of them
08:25:33 <ben> Oh, I see.
08:25:39 <ben> Not that it convinces me that this is better :V
08:25:43 <Entroacceptor> ben: do you want a package called 'world'??
08:25:53 <marcot> I think the ones that come with GHC are in the ghc package.
08:25:57 <Entroacceptor> and the user doesn't have to care about how many packages that are
08:25:58 <marcot> kaol: Am I wrong about that?
08:26:11 <Cale> marcot: I'm pretty sure that mtl isn't in the GHC package
08:26:33 <marcot> Cale: it isn't.  I didn't knew it came with GHC usually.
08:26:36 <companion_cube> orlandu63: are you running ghc on archlinux ? I've got problems with packaging of cabal
08:26:37 <Cale> and it comes with ghc (the big package of GHC anyway)
08:27:01 <Heffalump> Laney: was just hoping for advice for chowder on the recommended way of getting cabal-install on ubuntu
08:27:37 <Cale> chowder: Anyway, what happens when you run the bootstrap.sh script?
08:27:39 <Laney> the cabal-install package is only in from Lucid
08:27:39 <idnar> Cale: there's a haskell-platform package, perhaps that's the best one to shoot for
08:27:45 <Cale> chowder: Does it work, or emit an error?
08:27:45 <chowder> Cale: running it now
08:28:04 <Cale> I'm kind of sad about haskell-platform.
08:28:16 <chowder> Cale: its compiling some stuff
08:28:28 <idnar> it pulls in ghc6 + libghc6-mtl-dev + etc.
08:28:47 <marcot> What's the problem of haskell-platform?
08:28:57 <idnar> oh, but maybe that's not in Ubuntu yet
08:29:09 <Cale> Well, I suppose nothing conceptually.
08:29:09 <chowder> I really wanna learn haskell. I'm a CS major and I've become bored with Java lately.
08:30:10 <Cale> I seem to recall that for some stupid reason it included useless junk like the binding to editline, which is one of the most embarrassingly buggy libraries I've ever seen. (The C code's fault, not the binding's.)
08:30:10 <CcSsNET> java is a horrible thing to begin with
08:30:19 <CcSsNET> stay bored with it
08:30:52 <Cale> and I really liked the scale of the distribution of GHC with the extralibs
08:31:18 <Cale> haskell-platform seems to include lots more stuff, not all of which I really want
08:31:25 <marcot> I understand.
08:32:06 <marcot> Changing a little bit the topic.  Do you know if it's possible to make the compiler optimze the code by calculating the code of pure functions that can be reduce at compile time?
08:33:04 <pikhq> Possible? Yes. It's rather hard, thouh. Need heuristics to tell if it would be worth-while, heuristics to tell if it's feasible, etc.
08:33:44 <CcSsNET> chowder, your school pitched java to you real hard eh? hehe
08:34:19 <chowder> yep
08:34:26 <CcSsNET> likewise
08:34:30 <CcSsNET> i droped out learning that crud
08:34:38 <drk-sd> i'm sorry to interrupt you with my « colors » problem, but rly, if someone knew how to have vim color haskell the same way emacs does, it'd be wonderful
08:34:47 <Cale> marcot: It's possible to force the issue in some cases (for some types) by simply wrapping the thing in $( ... ) and turning on TH
08:34:51 <chowder> Later on we move on to C/C++ if we take the UNIX route
08:34:55 <chowder> which is what I'm going to do
08:34:59 <drk-sd> ( http://rsz.me/8i if you wanna compare)
08:35:02 <idnar> Cale: maybe there should be a ghc6-extralibs metapackage, or something like that
08:35:15 <twink> haskeline does seem to be doing better than editline in 6.12.1's ghci repl.
08:35:15 <Cale> idnar: yes
08:35:21 <CcSsNET> chowder they honestly tought java before c or c++? wow. thats pathetic.
08:35:25 <marcot> Cale: But not in a general manner by enabling some optimization with a -f parameter...
08:35:26 <jeffwheeler> I think I may have figured out how to get these instructions to work: http://alpmestan.wordpress.com/2010/03/11/getting-ghc-head-and-llvm-working-together/
08:35:33 <pikhq> chowder: Learn C. You probably don't want to use it for a lot, but I'd say every programmer should know C.
08:35:35 <Cale> idnar: also the ghc6 package ought to just depend on it, probably.
08:35:40 <twink> Not so much better in 6.10.4 though.
08:35:46 <fax> why should anyone know C?
08:35:48 <jeffwheeler> Don't apply the first patch; applying dons' patch is sufficient, and it won't work if the first is applied.
08:35:49 <Cale> idnar: It's extremely rare to want to install GHC without the extralibs set.
08:35:50 <pikhq> Java... Is not important.
08:35:57 <chowder> CcSsNET: every school seems to be doing it, though
08:35:59 <dantheman_> Hey, I'm  having a problem finding the file "ffitarget.h", does anyone know where it should be?
08:36:12 <pikhq> fax: It's the common denominator. Every language interacts with C.
08:36:13 <dantheman_> I'm using the latest haskell platform on windows
08:36:18 <idnar> Cale: if you're installing ghc to use it directly, then you probably do want them; if you're just installing it as a build-dependency, you don't
08:36:19 <CcSsNET> chowder yea, capitalism infiltrates in the weirdest of ways dont it?
08:36:35 <chowder> CcSsNET: Its not that Java is inferior or anything I'm just bored of doing Java every day
08:36:38 <pikhq> Not to mention that it's a rather low-level language, and everyone should *know* such a language.
08:36:39 <dantheman_> I think its included from ffi.h
08:36:48 <pikhq> (they should also know an assembly language.)
08:36:49 <CcSsNET> microsoft force feeds "free copys or pcs" and they throw java from sun as well
08:37:07 <chowder> yea
08:37:17 <dantheman_> anyone?
08:37:28 <chowder> although my uni gives equal time to UNIX
08:37:35 <CcSsNET> thats good ^
08:37:44 <pikhq> My university has a single non-UNIX programming class.
08:37:45 <orlandu63> what's the difference between reverse' (x:xs) = reverse' xs : x
08:37:45 <jeffwheeler> My university, within EE, teaches assembly first and builds up to C.
08:37:49 <orlandu63> oops
08:38:00 <CcSsNET> jeffwheeler what school?
08:38:11 <jeffwheeler> CcSsNET: University of Illinois at Urbana-Champaign
08:38:11 <CcSsNET> sounds ideal :D
08:38:13 <orlandu63> what's the difference between reverse' (x:xs) = reverse' xs ++ [x] and reverse' (x:xs) = reverse' xs : x
08:38:22 <Cale> orlandu63: xs : x doesn't typecheck
08:38:24 <jeffwheeler> CcSsNET: yeah, it makes sense to me
08:38:29 <CcSsNET> yea indeed
08:38:39 <jmcarthur> Axman6: "yeah, you'd think it had only been worked on by one guy for 6 months :P"  oh know, seriously ;)
08:38:54 <CcSsNET> my school did it backwards to me, i hate them for it. first basic, then visual basic, then c++, then java.....
08:39:03 <pikhq> *Ugh*.
08:39:03 <roconnor> > let pair a b = a + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map (text . show . map (uncurry pair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
08:39:05 <jeffwheeler> CcSsNET, oh man
08:39:07 <lambdabot>   [0,2,5,9,14]
08:39:11 <lambdabot>  [1,4,8,13,19]
08:39:11 <CcSsNET> yea horrible simply horrible
08:39:15 <lambdabot>  [3,7,12,18,25]
08:39:23 <pikhq> My school does C++ and assumes you learn other languages.
08:39:24 <jeffwheeler> CcSsNET: I did Java in high-school. Terrible.
08:39:39 <fax> I don't know what is bad about java
08:39:39 <CcSsNET> yea im speaking of highschool actually
08:39:42 <fax> it seems pretty cool to me
08:39:42 <pikhq> (after the introductory classes, you are limited to "school computers have a compiler")
08:39:43 <CcSsNET> lots ^
08:39:47 <jeffwheeler> CcSsNET: ha; AP?
08:39:53 <Cale> orlandu63: (x:xs) means the list whose first element is x, and whose tail is xs. So xs:x would be the list whose first element is xs, and whose tail is x, except that they don't have the right type for that to work.
08:40:02 <jmcarthur> i went through a computer engineering program followed by a cs program. c++, then assembly, then c, then java
08:40:22 <jeffwheeler> CcSsNET: C/C++/ASM make senes to learn. Never understood Java; it seems pretty arbitrary.
08:40:23 <fax> I would rather write java than C++ or C or assembly, just in terms of getting a non-crashy program which computes the right answer
08:40:27 <marcot> Maybe the ghc6 package should recommend these extralibs.
08:40:38 <Cale> marcot: yeah, at least :)
08:40:40 <CcSsNET> java anoys me for many reasons. if anyone doesnt mind a rant ill begin ;)
08:40:42 <roconnor> > let pair a b = ((a+b)^2 + x + 3*b) `div` 2 in  vcat $ map (text . show . map (uncurry pair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
08:40:43 <lambdabot>   [((0 + 0) * (0 + 0) + x + 3 * 0) `div` 2,((1 + 0) * (1 + 0) + x + 3 * 0) `d...
08:40:44 <jmcarthur> jeffwheeler: java is for the career-oriented students
08:40:48 <jmcarthur> :\
08:40:59 <jeffwheeler> jmcarthur: perhaps that's true
08:41:02 <roconnor> > let pair a b = ((a+b)^2 + a + 3*b) `div` 2 in  vcat $ map (text . show . map (uncurry pair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
08:41:03 <lambdabot>   [0,1,3,6,10]
08:41:03 <lambdabot>  [2,4,7,11,16]
08:41:03 <lambdabot>  [5,8,12,17,23]
08:41:03 <lambdabot>  [9,13,18,24,31]
08:41:03 <lambdabot>  [14,19,25,32,...
08:41:08 <Cale> CcSsNET: Essentially everyone here knows why not to like Java ;)
08:41:14 <CcSsNET> hehehe
08:41:16 <orlandu63> Cale: i see. thanks
08:41:19 <CcSsNET> yea ill spare it then
08:41:27 <jmcarthur> i wasn't in it for career purposes though, so i feel like i wasted my time
08:41:47 <jmcarthur> rather, i was initially, but then decided i would have prefered more academic subjects
08:41:47 <jeffwheeler> CcSsNET: yeah, the last two years of high-school CS was mostly Starcraft for me
08:41:59 <CcSsNET> a career needs c and php imo
08:42:03 <CcSsNET> maybe python
08:42:07 <dantheman_> I'm trying to build the example at http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Setting_up_your_build_environment_.28Visual_Studio_Specific.29 in visual studio
08:42:09 <CcSsNET> :P
08:42:11 <fax> PHP is worse than java too
08:42:11 * jeffwheeler cringes at the thought of PHP
08:42:15 <fax> that language has built in problems
08:42:20 <eevar> heh. you're dissing java but like php? ;)
08:42:20 <CcSsNET> haha ^
08:42:23 <dantheman_> But things keep failing with a fatal error C1083: Cannot open include file: 'ffitarget.h': No such file or directory
08:42:24 <orlandu63> Cale: what if i had done this: reverse' (x:xs) = (reverse' xs) : x
08:42:24 <fax> Cale except me
08:42:25 <jmcarthur> oh, i meant to address the career-oriented stuff at CcSsNET, not jeffwheeler. sorry
08:42:30 <fax> I don't know what is bad about java
08:42:34 <fax> but everyone here seems to hate it
08:42:41 <dantheman_> Does anyone here know how to set this up properly?
08:42:45 <jeffwheeler> CcSsNET: your rant, please
08:43:18 <dantheman_> Any help much appreciated
08:43:28 <Cale> fax: Mainly lack of adequate abstraction facilities. This is 2010. If a language doesn't support functions (or procedures) properly, there's just no excuse.
08:43:31 <jmcarthur> dantheman_: i could help you out on a unix :\
08:43:43 <dantheman_> jmcarthur
08:43:45 <fax> Cale: could you say the same about C and C++ and assembly?
08:43:48 <Cale> We've known how to do first class functions and procedures well for a few decades now.
08:43:49 <chowder> IMHO, each language has its purpose.
08:43:52 <Cale> fax: yes
08:43:53 <dantheman_> even that'd be great
08:43:54 <marcot> http://www.haskell.org/ghc/download_ghc_6_12_1.html
08:43:58 <dantheman_> I just need to know where to find it
08:44:01 <jmcarthur> chowder: except for the ones that don't
08:44:01 <marcot> There's no extralibs version in this page.
08:44:02 <fax> Cale, but why do we single out java?
08:44:10 <chowder> also, why learn assembly unless you're doing systems programming?
08:44:11 <Cale> fax: I'm not really singling out Java.
08:44:12 <jmcarthur> dantheman_: where to find unix?
08:44:36 <dantheman_> No, I mean if you can tell me on unix, I can probably figure out where to find it on windows
08:44:36 <jeffwheeler> fax: I find the poor choice of abstractions painful. "Enterprise" describes the abstraction choices painfully well.
08:44:39 <marcot> So I cannot tell what would the ghc6-extralibs meta-package contain.
08:44:41 <fax> Cale yeah but I think people do hate java and not the other languages, even though it is technically superior in most criteria that actually matter
08:44:50 <CcSsNET> its c++ all over again. but pitched from a corprate entity. also when talking about security, for the end user, not the coders, the end user doesnt know whats running and cant controll the processes. its all javaland. instead of userland. so in my opinion its the worst untrustable piece of crud existant. not even mentioning the slowness it "had" yes i give them credit and said had... even though i still claim its slow.
08:44:54 <Cale> But, Java has a particular sort of egregiousness to it, because it tries to be high-level and fails.
08:45:01 <jmcarthur> dantheman_: well, it wouldn't be visual studio stuff, so i'm doubtful
08:45:04 <fax> ah
08:45:11 <monochrom> Hi, where can I find a haskell channel?
08:45:19 <jeffwheeler> monochrom: you're in one?
08:45:29 <CcSsNET> my rant summed up best i could
08:45:37 <jeffwheeler> fax: I think comparing Java to C# highlights the problems in Java.
08:45:38 <dantheman_> There's a libffi.a included in the HaskellPlatform main directory
08:45:40 <monochrom> You think "enterprise" "java" "c++" is in one?
08:45:51 <Cale> It's running on a bloody VM, so it's not like being close to the machine model is really an excuse, like it is for C.
08:45:51 <dantheman_> Should I just put this on my include path, or do I need to do something else?
08:45:58 <chowder> Despite being bored of Java I actually like Java. The same goes for PHP. They have their place. Same thing goes for Perl, which is the weirdest language I've ever used.
08:45:59 <jeffwheeler> monochrom: occasionally :P
08:46:10 <Cale> C++ is a horrible abomination, and I won't defend it over Java.
08:46:16 <jmcarthur> dantheman_: looks more like link path than include path
08:46:16 <monochrom> This is like happening every day reliably, not occasionally.
08:46:33 <jeffwheeler> monochrom: I'm not in here enough to say
08:46:41 <fax> I find java really useful personally, on the other hand I haven't written any programs in forever
08:46:42 <arw> java was successful because it actually was an improvement over c++. but that does not say too much...
08:46:43 <monochrom> People, could you move your other-languages-gossip to #haskell-blah or elsewhere please.
08:46:47 <CcSsNET> cale, even if its horrible. at least the user can control the apps! and send a kill -9 to it!
08:46:49 <dantheman_> or do I need to look for a libffi.lib file somewhere too?
08:47:03 <jmcarthur> g2g
08:47:17 <dantheman_> Sorry, ya I meant my library path
08:47:36 <chowder> brb
08:47:36 <CcSsNET> what java did was trully ment to fix c++ but they would rather make money then do the right thing...
08:47:49 * Saizan wonders if forall ADTs T there's a functor f such that Free f () ~ T, where Free f is the free monad
08:47:52 <roconnor> mathematicians are dumb.  They are like all "oh a polynomial is irreduciable over a field or it isn't" like it is some sort of trivial problem.
08:48:01 <Cale> Java actually did manage to fix some things which C++ messed up badly.
08:48:04 <fax> haha roconnor
08:48:07 <dantheman_> Do you have such a file on linux jmcarthur?
08:48:21 <dantheman_> (i.e. libffi.lib)
08:48:30 <Cale> But they were such embarrassing things in the first place that it's not really a selling point.
08:48:33 <CcSsNET> cale even if they did it doesnt excuse them for what it is.
08:48:33 <twink> roconnor: Where did this come up?
08:49:32 <roconnor> I'm reading "Computable Fields and Galois Theory" by Russell Miller
08:50:29 <CcSsNET> im a fan of c. c++, perl, python, php, lua, even though none are perfect they have there place. i still claim java has no place. no place but capitalistic intent
08:50:47 <roconnor> At least java doesn't make implicit copy constructors
08:50:49 <roconnor> grrr
08:50:54 <CcSsNET> meh
08:51:02 <fax> CcSsNET, how does being badly designed have anything to do with money?
08:51:20 <CcSsNET> there a corprate entity thats why
08:51:23 <CcSsNET> :D
08:51:48 <fax> I don't really see the link
08:51:48 <twink> Sounds rather interesting. Sadly I know little more than the usual bit about all the fields being cyclotomic (for some prime) or the p-th root of some real number after the p-th root of unity has already been adjoined or some such.
08:51:48 <roconnor> monochrom: ah sorry
08:51:57 <monochrom> At least I can go to #haskell-blah to talk about haskell in revenge.
08:51:58 <CcSsNET> fax, i see my link, dont really care if your willing to or not
08:52:01 <twink> s/fields being/extensions being/
08:52:21 <fax> CcSsNET, oh right it's turned into this sort of thing now
08:52:49 <Saizan> monochrom: let's go to #c++
08:52:52 <CcSsNET> ok lets look closer at the company. and there practices.
08:52:56 <CcSsNET> u can start
08:52:56 <twink> roconnor: Is that book enough to write a program to write explicit radical and rational operation expressions for various roots of unity?
08:52:58 <CcSsNET> ill end it
08:53:05 <Saizan> CcSsNET: somewhere else.
08:53:08 <CcSsNET> hehe
08:53:47 <twink> roconnor: (I think the cyclotomic polynomials are solvable, for certain orders e.g. primes if not in general.)
08:53:49 <roconnor> twink: it is a 10 page article in the notices of the AMS
08:54:29 <twink> roconnor: Doesn't sound like it.
08:58:47 <Younder> twing, look up galoise's theorem
08:59:05 <Saizan> is there a technique in combinatorics to go from some tree to the one where the leaves are labelled?
08:59:31 <twink> Younder: I was describing my approximate recollection of it (or something related to it).
09:00:08 <bjrn> Can I get or-patterns in Haskell somehow?
09:01:23 <bjrn> With or-patterns I mean the possibility of grouping patterns together that match to the same value
09:01:47 <drk-sd> hmmm, i did a « :set filetype=lhaskell » while editing a literate haskell file in vim
09:02:04 <drk-sd> does someone know why the haskell is not colored ?
09:02:25 <drk-sd> (i should go on #vim maybe, rather than bothering you with such questions)
09:02:46 <mail> is it possible to clear the screen in ghci?
09:05:03 <Cale> bjrn: Unfortunately not.
09:05:15 <roconnor> Question, is a haskell Klesli category a symmetric monoidal category?
09:05:43 <bjrn> Cale: That's unfortunate. Thanks for the answer though.
09:07:40 <Cale> roconnor: which monoid operation? Categorical product? Sure.
09:07:50 <dantheman_> Ah, figure it out!
09:13:03 <chowder> tried cabal-install and got an error
09:13:05 <chowder> Setup: At least the following dependencies are missing:time ==1.1.*
09:13:28 <roconnor> Cale: what is a categorical product?
09:13:36 <chowder> ran the bootstrap.sh script and it terminated giving me the error above
09:14:54 <byorgey> Saizan: I don't understand the question.
09:15:12 <Cale> roconnor: If X and Y are objects in a category C, then their product (if it exists) is an object X x Y together with so-called projection maps X x Y -> X, and X x Y -> Y, such that for any other object Z and maps Z -> X and Z -> Y, there is a unique arrow Z -> X x Y making the diagram commute.
09:15:55 <roconnor> Cale: kliesli categories have products? (in haskell)
09:17:25 <Cale> hmmm
09:17:56 <Cale> Seems so
09:18:05 <Cale> It's just the usual product
09:18:46 <Cale> and compose the projection maps with return, I suppose.
09:19:02 <roconnor> But I remember learning that it isn't cartesian closed
09:19:04 <Cale> I suppose it's less obvious that it's a product...
09:19:09 <Cale> hmm
09:19:09 <roconnor> I guess it is the closed part that was problematic
09:19:24 <roconnor> ya
09:19:27 <Saizan> byorgey: well, take unlabelled binary trees, T = 1 + 2T, the corresponding tree labelled only on the leaves would be T' a = a + 2T'
09:19:29 <roconnor> not obviously a product
09:19:32 <sepp2k> Is .. forbidden as a function name?
09:19:34 <roconnor> anyhow I have to go now
09:19:38 <roconnor> I'll be back later
09:20:15 <Cale> ah, I know why
09:20:17 <Saizan> byorgey: i was wondering if there was a known generic way to go from one to the other
09:20:21 <Cale> Yeah, there's a problem
09:20:49 <Cale> There will be products in Kleisli categories over commutative monads, I think
09:21:09 <Cale> But the noncommutativity destroys the uniqueness of the map Z -> X x Y in the last step, I believe.
09:21:11 <byorgey> Saizan: just replace every '1' by 'a'?  Or am I not understanding the question?  (also, I assume you mean T^2)
09:21:17 <Cale> er hmm
09:21:26 <Cale> Maybe it's not just that.
09:21:33 <Boxo> @pl \a b -> b a
09:21:34 <lambdabot> flip id
09:21:35 <Saizan> byorgey: oh, yeah T^2
09:22:00 <Cale> Seems you might need an even stronger condition
09:22:59 <Saizan> byorgey: replacing every 1 doesn't really work, e.g. T = (1+1)*T + 1 doesn't become T' a = (a+a)*T + a,
09:23:18 <Boxo> flip :: (a -> b -> c) -> (b -> a -> c), id :: (a -> a), how is "flip id" possible...?
09:23:21 <Saizan> byorgey: T' a = (a+a)*T' a + a, sorry
09:24:14 <byorgey> Saizan: It doesn't?  I guess it depends how you define "leaf"
09:24:22 <Cale> You'd want that fmap fst . f, and fmap snd . f together uniquely determine f, which means that the effects somehow "separate", which is really strong.
09:24:41 <byorgey> Saizan: how *do* you define "leaf"? =)
09:24:42 <Cale> It works for Reader, but I'm not sure it'd work for much else.
09:24:59 <Saizan> byorgey: i guess that's my problem :)
09:25:21 <Desustorm> humm can someone feeling kind help a lowly newbie haskell programmer? :)
09:25:47 <byorgey> Saizan: how about expressing it as a sum of products, and only replacing 'top level' occurrences of 1?
09:25:52 <Cale> Desustorm: Feel free to ask any questions you might have here
09:25:56 <Boxo> I can see how "flip id" works, but why doesn't it cause a type error?
09:26:02 <doserj> Boxo: id::(a->b)->(a->b)
09:26:04 <Cale> Desustorm: Many of the people here are mostly here to help beginners.
09:26:12 <Saizan> byorgey: in a CS course on data structures you'd have external nodes
09:26:15 <Boxo> aha :D
09:26:20 <Desustorm> Cale, okay
09:26:25 <Lycurgus> Cale: rly?
09:26:28 <Saizan> byorgey: i guess that would work
09:26:37 <Cale> Lycurgus: I think so, yes :)
09:26:47 <Cale> Lycurgus: At least, that's what I mostly come here for :)
09:27:02 <krey> hello, can somebofy please help me with parsers?
09:27:06 <Desustorm> Trying to shuffle a sorted deck of cards using Durstenfeld's algorithm
09:27:09 <Saizan> byorgey: assuming there's a mechanical way to normalize to that form
09:27:29 <Desustorm> getting a compiler error
09:27:51 <byorgey> Saizan: of course there is, the wame as there is a way to normalize logical formulae to conjunctive normal form
09:27:54 <byorgey> *same
09:27:54 <Lycurgus> Cale: Acknowledged, and thanks for your good work
09:28:02 <byorgey> just distribute * over +
09:28:04 <krey> i am trying to implement regular expressions
09:28:08 <Cale> Desustorm: This is yet another name for the obvious random shuffling algorithm?
09:28:24 <Desustorm> humm kinda
09:28:24 <Cale> krey: What trouble are you having?
09:28:31 <Desustorm> it's the O(n) one
09:28:37 <byorgey> Saizan: in fact, once you normalize the only 1's left might be only 'top-level'
09:28:49 <byorgey> Saizan: for example, your example would become T = T + T + 1
09:28:50 <Saizan> byorgey: i was thinking the recursive occurrences / fixpoints might mess with it
09:28:52 <Desustorm> get a random number between 0 and remainingdecklength
09:29:02 <krey> i wrote some code, and I'm not sure if it's done correctly
09:29:02 <krey> also
09:29:11 <krey> im trying to parse the regexp strings into trees
09:29:16 <byorgey> Saizan: It might if you have nested fixpoints, I suppose...
09:29:16 <krey> and have no idea how to
09:29:21 <Desustorm> then swap that number in the list of cards with the final card
09:29:28 <byorgey> but if you have only one it should be ok, as long as you don't unfold the recursive occurrences
09:29:41 <Desustorm> lol sorry i'm just talking over krey
09:30:00 <byorgey> Desustorm: it's ok, everyone just talks over everyone else, it's the nature of IRC =)
09:30:07 <Cale> Desustorm: Okay, so you want to use a mutable array for this?
09:30:23 <Desustorm> I don't really know how to do arrays
09:30:40 <Desustorm> I thought about using a list with splitAt
09:30:57 <byorgey> krey: if you want someone to take a look at your code, feel free to paste it in a pastebin somewhere
09:31:00 <Cale> krey: Yeah, I'd start with a datatype like... data Reg a = Zero | One | Sym a | Sum [Reg a] | Prod [Reg a] | Star (Reg a) deriving (Eq, Ord, Show)
09:31:25 <Desustorm> and then concatenating the head of the second list onto the tail and vice versa, then using  nub to remove repeats
09:31:30 <Cale> (you can also add in any extra fancy bits you might want)
09:31:33 <Desustorm> but that's probably not very efficient
09:31:46 <Cale> Desustorm: Yeah, it's essentially impossible to do efficiently with lists
09:32:01 <Desustorm> i kinda just need it to work though ;P
09:32:29 <Cale> Desustorm: You can imitate the same thing, but it'll be slow because swap isn't an efficient thing with lists.
09:32:31 <krey> http://pastebin.com/0sYWFYer
09:32:49 <byorgey> but an inefficient but simpler implementation is often a good place to start.
09:33:00 <byorgey> if it isn't fast enough you can always change it later.
09:33:01 <Cale> Even selecting elements is a bit expensive, but will be nicer.
09:33:06 <Desustorm> Cale, check this code for me will you?
09:33:07 <Desustorm> http://pastebin.com/9nMtH6iH
09:33:25 <Desustorm> the only thing stopping it from working is a compiler error :(
09:33:43 <Desustorm> fyi, pack = [Card rank suit | suit<-[Club .. Spade], rank<-[Ace .. King]]
09:34:22 <danderson> oh pooh, Parsec doesn't define an instance of Applicative for parsers?
09:34:38 <byorgey> krey: wow, a Monad instance for regexps and everything =)
09:34:43 <Heffalump> danderson: trivial to write
09:34:55 <byorgey> krey: so do you have specific questions about that code?
09:35:09 <byorgey> danderson: it does in version 3, IIRC
09:35:30 <danderson> Heffalump: besides the point, I could redefine the universe from nothing, but I'm on a time budget ;)
09:35:31 <byorgey> but yes, instance Applicative ... where pure = return; (<*>) = ap
09:35:36 <krey> yeah, is this how you're supposed to do it?
09:35:43 <krey> im really new to monads and parsing and such
09:35:55 <byorgey> krey: that is not a very specific question ;)
09:36:03 <danderson> byorgey: aha, I'm probably getting Parsec2, that would explain it. Cheers.
09:36:14 <Heffalump> danderson: I did say "trivial", not "possible" :-p
09:36:20 <Desustorm> Cale, apologies for the very ugly code :p
09:36:38 <byorgey> krey: I don't know, it looks quite reasonable at a first glance
09:36:50 <byorgey> krey: does it type-check?
09:36:55 <krey> oh yes
09:36:59 <danderson> Heffalump: yeah, true. I wasn't thinking of reusing the Monad definitions.
09:37:00 <byorgey> well then =)
09:37:05 <krey> so
09:37:11 <krey> if this is fine
09:37:13 <Cale> Desustorm: You're aware that you'll be picking the same "random" number every time this way?
09:37:32 <Desustorm> bah i had a feeling that might be so
09:37:33 <Cale> Desustorm: Well, at least, whenever n is the same
09:37:45 <krey> next thing for me to do is parse the regular expressions into (Regexp a)-s
09:38:07 <Cale> Desustorm: Haskell functions are proper mathematical functions, which means that when you give the same parameters to a function, you'll always get the same result
09:38:19 <krey> i was thinking of using Parser Maybe (Regexp Cb)
09:38:34 <byorgey> krey: ah, one thing I just noticed: all your parser combinators are for things of type 'Parser m String'
09:38:51 <byorgey> krey: you almost certainly want them to be polymorphic in the type of things being parsed, i.e. 'Parser m a'
09:39:11 <byorgey> otherwise you can only parse Strings into... Strings.
09:39:13 <Cale> Desustorm: If a function depends on something, it must be a parameter to the function -- this makes testing easy, but randomness a little more tricky (but not too much more)
09:39:19 <byorgey> which is kind of boring ;)
09:39:22 <Desustorm> Cale, do I need IO if i want a properly random number then?
09:39:28 <krey> oh, yes, donno why i did that :D
09:39:33 <krey> thx
09:39:33 <Cale> Desustorm: Well, for proper randomness, yes.
09:39:40 <Cale> Desustorm: But not for pseudorandomness
09:39:51 <Desustorm> I don't mind pseudorandomness
09:39:52 <Desustorm> :p
09:39:57 <byorgey> krey: what is Cb?
09:40:12 <Cale> Desustorm: The (basic) way we handle pseudorandomness is to define functions that take the state of the RNG as a parameter
09:40:45 <Desustorm> how could I go about doing that then?
09:40:48 <Cale> Desustorm: Whenever you create a "random" value, you'll get a new StdGen, which you shouldn't throw away, as it's to be used to generate the next value.
09:41:07 <krey> Cb is Char->Bool
09:41:19 <Cale> Usually in doing this, it's nice to use let expressions to pattern match the values you get
09:41:31 <byorgey> krey: ah, ok, yes, that sounds perfect then
09:41:39 <Cale> There's actually a fancier way to wrap up some of this noise, but it's good to understand this way first.
09:41:50 <danderson> how do I import Parsec 3 explicitly over Parsec 2?
09:42:03 <danderson> when I'm building with Cabal that's trivial, I just shadow Parsec 2, but from ghci?
09:42:30 <Cale> Desustorm: I'll show a simpler example first... suppose we want to roll two dice, and produce the resulting sum
09:42:37 <Saizan> :set -package parsec-3.x
09:42:51 <Saizan> or ghc-pkg hide parsec-2.x before you start ghci
09:42:59 <krey> so, how do i parse string into trees?
09:43:04 <Cale> Our function will have type StdGen -> (Integer, StdGen)
09:43:04 <Desustorm> Cale, okay
09:43:22 <Saizan> danderson: actually, it'll stick to the latest version available, so you don't have to do anything
09:43:29 <Boxo> @pl \x -> g (f x) x
09:43:29 <lambdabot> g =<< f
09:43:35 <Boxo> @pl \x -> g x (f x)
09:43:35 <lambdabot> ap g f
09:43:52 <danderson> Saizan: actually, I didn't have parsec 3 installed, which explains quite a bit :P
09:43:54 <Cale> So it takes the state of the RNG, and produces the resulting sum, and a new StdGen to be used for further random generation
09:44:00 <Cale> okay
09:44:12 <Desustorm> hmm yeah alright
09:44:32 <Cale> dice g = ...
09:44:48 <Cale> So the first thing we'll do is call randomR with (1,6), the bounds
09:44:50 <Cale> and g
09:44:56 <Desustorm> getStdGen(randomR(1,6))
09:44:57 <Desustorm> ?
09:45:27 <Cale> this'll give us an integer in the range 1 up to 6, and a new StdGen g'
09:45:49 <Cale> dice g = let (x,g') = randomR (1,6) g; ... in ...
09:46:03 <SamB_XP> @hoogle x -> StdGen
09:46:04 <lambdabot> Prelude id :: a -> a
09:46:04 <lambdabot> Data.Function id :: a -> a
09:46:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:46:09 <Desustorm> is g' just another name?
09:46:11 <Cale> yeah
09:46:15 <Desustorm> okay
09:46:19 <SamB_XP> @hoogle StdGen
09:46:20 <lambdabot> System.Random data StdGen
09:46:20 <lambdabot> System.Random getStdGen :: IO StdGen
09:46:20 <lambdabot> System.Random mkStdGen :: Int -> StdGen
09:46:23 <byorgey> krey: well, you write a parser of type Parser Maybe (Regexp Cb) using your parser combinators
09:46:26 <byorgey> krey: for example, you might start out by saying that a regular expression is a sequence of terms, each of which is either an atom or a group/closure
09:46:39 <Cale> okay, and then we want to do the same thing again, but this time with g' as the input
09:46:47 <byorgey> krey: so you would say  parseRegexp = many parseTerm
09:46:58 <Cale> dice g = let (x,g') = randomR (1,6) g; (y,g'') = randomR (1,6) g' in ...
09:47:11 <Desustorm> is there a reason why we needed to use let?
09:47:14 <byorgey> parseTerm = parseAtom `mplus` parseClosure
09:47:16 <byorgey> and so on
09:47:19 <Cale> well, it's convenient to
09:47:27 <Cale> Could also just as well have used 'where'
09:47:34 <Cale> But there's a natural sequence to this thing.
09:47:43 <byorgey> krey: do you know about BNF grammars?
09:47:58 <byorgey> if you do, it would probably help to first write a grammar for regular expressions
09:47:58 <Cale> and 'let' allows us to put the randomR's before the production of the result
09:48:05 <Cale> It just happens to read better that way
09:48:07 <byorgey> then you can translate it directly into a parser implementation
09:48:18 <Desustorm> yeah sure okay
09:48:47 <Cale> okay, so our result will now be (x+y,g'')
09:48:57 <Cale> dice g = let (x,g') = randomR (1,6) g; (y,g'') = randomR (1,6) g' in (x+y,g'')
09:48:58 <monochrom> Haha, to understand regular languages, you must first understand context-free languages.
09:49:34 <Desustorm> is the ; necessary?
09:49:37 <krey> byorgey: ima add polymorphism to my code, brb
09:49:47 <Cale> Only if you're squishing it all onto one line
09:49:47 <Twey> Desustorm: It'd be a newline in a file.
09:49:56 <Desustorm> okies
09:50:01 <byorgey> monochrom: hehe, when you put it that way... ;)
09:50:11 <Desustorm> im doing a test file along with it :)
09:51:00 <byorgey> monochrom: but the *syntax* of regular expressions is not a regular language =)
09:51:23 <Desustorm> okay Cale
09:51:27 <monochrom> yeah
09:51:38 <Desustorm> so new i have the sum of 2 random ints between 1 and 6
09:51:44 <Desustorm> nwo*
09:51:45 <Desustorm> now*
09:51:47 <Twey> byorgey: Is the syntax of the syntax of regular expressions?
09:51:49 <Desustorm> -.-
09:51:49 <Cale> Desustorm: yep
09:52:01 <Cale> Desustorm: okay, so this code obviously has some issues
09:52:12 <Cale> Desustorm: It's easy to get the threading of the state wrong
09:52:13 <Desustorm> hehe many i would assume :0
09:52:22 <Cale> I mean the code that I just wrote
09:52:35 <Desustorm> oh, my bad
09:53:04 <Desustorm> p.s. how would you make a StdGen to call that function?
09:53:14 <Cale> Okay, that you might do from I/O
09:53:15 <byorgey> Twey: parsing the syntax of the syntax of regular expressions requires a time-traveling non-deterministic multi-head Turing machine with a TSP oracle.
09:53:22 <Twey> byorgey: Hahaha.
09:53:39 <Desustorm> mm..
09:53:41 <Cale> at the top level of your program in main, execute newStdGen, and you get a StdGen value which you can then pass along
09:53:52 <Saizan> + a working LHC
09:53:57 <Cale> You can also use mkStdGen with a specific seed to use
09:53:58 <Desustorm> we've been told that shuffle has to be shuffle :: Int->[a]->[a]
09:54:01 <Cale> outside of I/O
09:54:07 <Desustorm> okay
09:54:13 <byorgey> Saizan: well, you can just simulate it on the Turing machine
09:54:17 <Cale> Well, that's pretty impossible, unless you want to use the Int as a seed.
09:54:34 <Desustorm> i think that was the idea
09:54:40 <byorgey> if you don't mind waiting a bit longer
09:54:45 <opqdonut> you could get the nth permutation :)
09:55:01 <Desustorm> he said we could do the O(n^2) or try for O(n) for a bonus
09:55:21 <monochrom> To understand type-0 languages, you must first understand type-0 languages.
09:56:32 <Desustorm> so it's not really doable Cale ?
09:57:08 <Cale> Desustorm: It's certainly awkward if you're not allowed to pass around a StdGen.
09:57:16 <Desustorm> Define a function shuffle of type Int -> [Card] -> [Card] or (preferably) Int -> [a] -> [a] which takes a random number seed and a list of cards (possibly the whole pack)
09:57:23 <Cale> ah, okay
09:57:24 <Desustorm> is what I've been told to do
09:57:43 <Cale> Okay, you can apply mkStdGen to turn the Int into your first StdGen
09:58:01 <Desustorm> I can? >_>
09:58:06 <Cale> :t mkStdGen
09:58:07 <lambdabot> Int -> StdGen
09:58:29 <Desustorm> okay that's handy
09:58:35 <Cale> Unless he wants you to write your own PRNG
09:58:53 <Desustorm> no he did suggest mkStdGen
09:59:02 <Desustorm> but very vaguely
09:59:42 <marcot> Cale: If you want to ping me when there's a extralibs package for ghc 6.12.1, I can create a Debian meta-package for it.
10:00:03 <Cale> marcot: I think the plan is that there won't be one. They're only going with Platform now
10:00:26 <Cale> Desustorm: If you'd like, I can give you a hint about how I'd factor this problem
10:00:36 <Desustorm> that would be nice, Cale
10:00:44 <marcot> Cale: ah, ok.
10:01:16 <krey> byorgey: http://pastebin.com/srFndT1G
10:01:17 <Cale> Desustorm: I would start by writing a function  select :: [a] -> [(a,[a])] which takes a list xs, and produces a list of pairs (x,ys) where x is an element of xs, and ys is all the rest of the elements of that list
10:01:23 <Cale> For example:
10:01:33 <krey> byorgey: is this better?
10:01:40 <Cale> select [1,2,3] = [(1,[2,3]),(2,[1,3]),(3,[1,2])]
10:02:46 <Desustorm> hmm okay
10:03:16 <Cale> This is not such a hard function to write recursively
10:03:31 <Desustorm> you'd be surprised :)
10:03:41 <Cale> and picking a random element from it will give you the first element of your random shuffle, along with the remainder of the elements of the list
10:04:02 <Cale> (so you can continue random shuffling on those)
10:04:38 <Cale> So then you only need a function which picks a random element, which is something you'd expect to be in the libraries, but for some reason the standard libraries are a bit impoverished in this regard.
10:05:20 <Cale> It's possible to speed things up a bit after that by passing around the remaining length of the list, rather than recomputing it over and over
10:06:29 <Desustorm> hmm
10:06:30 <krey> could someone take a look at my parser please: http://pastebin.com/srFndT1G
10:07:06 <Cale> (as you might have to do when naively selecting a random element of a list)
10:07:19 <McManiaC> is there something like printf("%03d",5) for "pure" functions?
10:07:35 <Cale> Actually, there's a way to select a random element of a list without computing its length beforehand as well, if you're clever
10:07:57 <Cale> > printf "%03d" 5
10:07:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:07:58 <lambdabot>    `Text.Printf.PrintfType ...
10:08:01 <Cale> > printf "%03d" 5 :: String
10:08:02 <lambdabot>   "005"
10:08:35 <McManiaC> oi
10:08:37 <McManiaC> okay
10:09:01 <Desustorm> Cale, will that be O(n)?
10:09:46 <Cale> McManiaC: unfortunately, that one is a little hard to do otherwise without writing something particular to do the zero padding
10:10:04 <Desustorm> because I think my approach is sound, it just needs debugging :-(
10:10:23 <Cale> Desustorm: okay, let's look at your code a bit more then
10:10:40 <Desustorm> Cale, need the link again?
10:10:40 <McManiaC> Cale: yeh…
10:10:47 <Cale> Desustorm: nope, I have it
10:10:52 <Desustorm> Okay
10:11:07 <Cale> Desustorm: Big obvious problem:  x ++ tail y ++ y ++ head y -- not all of these things can be lists of the same type
10:11:11 <Cale> :t (++)
10:11:12 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:11:16 <Cale> :t (Prelude.++)
10:11:17 <lambdabot> forall a. [a] -> [a] -> [a]
10:11:34 <Cale> (the bot has some nice generalisations :)
10:11:44 <Desustorm> heh
10:12:09 <Desustorm> why are they not lists of the same type though?
10:12:14 <Cale> In any case, that says (++) takes two parameters of the same type.
10:12:21 <Cale> head y might not be a list at all
10:12:36 <Cale> actually, that's the only real problem
10:12:47 <Cale> also, are you really sure you want nub?
10:12:51 <Desustorm> (apart from the rubbish rng)
10:12:56 <Cale> nub will remove all the equal elements of the list.
10:13:02 <Desustorm> not really, it just seemed convenient
10:13:03 <Cale> > nub "mississippi"
10:13:03 <lambdabot>   "misp"
10:13:14 <Desustorm> yes
10:13:24 <Desustorm> if it's a deck of cards none of them will be the same
10:13:28 <Cale> Well, okay
10:13:36 <FliPPeh_> @pl altColor p = theclass "row" ++ show (p `mod` 2)
10:13:37 <lambdabot> altColor = (theclass "row" ++) . show . (`mod` 2)
10:13:44 <Cale> hmm
10:13:51 <Desustorm> unless i'm being stupidly inefficient
10:13:57 <Desustorm> which is very likely
10:14:25 <FliPPeh_> @pl altColor p = theclass $ "row" ++ show (p `mod` 2)
10:14:26 <lambdabot> altColor = theclass . ("row" ++) . show . (`mod` 2)
10:14:36 <Cale> nub (tail y ++ y) is the same as  tail y ++ [last y], so long as y is a nonempty list
10:15:01 <Cale> The other thing of concern is that head and tail and init and last all die with exceptions on an empty list
10:15:18 <Cale> and there's nothing which really guarantees safely that x and y are nonempty here
10:15:49 <Desustorm> can't i just add a line like (_,[])
10:15:49 <Desustorm> ?
10:15:55 <Desustorm> = whatever
10:16:11 <Cale> yeah
10:16:19 <Cale> you can handle those cases separately if you like
10:16:27 <Desustorm> will that stop the compiler error though?
10:16:31 <Cale> yeah
10:16:39 <Cale> Actually, it'd be a runtime error
10:16:56 <Desustorm> it's an Occurs check that's getting me
10:16:59 <Cale> (and one which is typically hard to debug, so it's best to be really really careful with head and tail)
10:17:10 <Cale> Yeah, that's from using the element as a list thing.
10:17:19 <Desustorm> how do i get around it?
10:17:22 <Cale> [head y]
10:17:27 <Cale> Make a list of length 1
10:17:55 <Desustorm> that didn't seem to make a difference
10:18:05 <Cale> There's probably more than one problem...
10:18:34 <Desustorm> without a doubt :)
10:18:43 <Desustorm> it's the same Occurs theck though
10:18:45 <Desustorm> check*
10:19:07 <felzix> is there a way to grab code from http://community.haskell.org? I tried copying the url directly to no luck.
10:19:14 <Cale> swapr (x,y) = x ++ tail y ++ [head y] -- perhaps this is what you want?
10:19:54 <Cale> actually, if that's the case, don't use head and tail at all
10:19:58 <Cale> Instead, pattern match
10:19:59 <byorgey> felzix: which code are you trying to get?
10:20:02 <Desustorm> no, i'm splitting the [pack] 1 before the random roll
10:20:16 <Desustorm> so i can swap the 2 list elements easily
10:20:24 <Cale> Well, this is equivalent to what you had
10:20:24 <felzix> byorgey: System.Console.CmdArgs
10:20:34 <Cale> Given that the elements are all distinct
10:20:46 <Boxo> @unpl flip . ((flip . (flip .)) .)
10:20:47 <lambdabot> (\ n b c f i -> n c f i b)
10:21:03 <Desustorm> is tail a list?
10:21:07 <Cale> Desustorm: yes
10:21:10 <Desustorm> oh fail
10:21:13 <byorgey> felzix: oh, get it from Hackage
10:21:16 <Desustorm> is it every element except the first?
10:21:17 <byorgey> felzix: http://hackage.haskell.org/package/cmdargs
10:21:19 <osaunders> > tail [1,2,3]
10:21:20 <lambdabot>   [2,3]
10:21:21 <Cale> Desustorm: yeah
10:21:25 <Desustorm> -_-
10:21:27 <byorgey> felzix: there is a tarball link at the bottom of the page
10:21:42 <Desustorm> right then :P
10:21:53 <byorgey> felzix: or, if you have cabal-install, you can just type 'cabal install cmdargs' at a prompt
10:21:58 <felzix> byorgey: ah, aweomse. thanks!
10:22:01 <felzix> awesome*
10:22:07 <Desustorm> hmm that's a bit of a bummer
10:22:16 <Desustorm> would i need to reverse the list twice to get the last element then?
10:22:24 <Cale> The last element is last y
10:22:26 <byorgey> felzix: if you installed the Haskell Platform you should already have cabal-install
10:22:53 <Cale> and everything except the last element is init y
10:23:02 <Desustorm> okay
10:23:07 <Desustorm> thank you :)
10:23:10 <Desustorm> new error :D
10:23:12 <felzix> byorgey: I do, but I want the source code so I can give it layers modes
10:23:16 <Cale> last and init are both expensive, so you should avoid them as much as possible
10:23:18 <felzix> layered*
10:23:27 <Boxo> @unpl  flip . (ap .) . flip (.)
10:23:27 <lambdabot> (\ m b c -> (\ j -> c (m j)) >>= \ r -> b >>= \ q -> return (r q))
10:23:29 <byorgey> felzix: ok, you can do 'cabal unpack cmdargs' to get the source code
10:23:34 <Desustorm> Could not deduce (Eq a) from the context () arising from a use of `nub'
10:23:46 <byorgey> felzix: but even better, it looks like ndm has it in a darcs repository
10:23:50 <Cale> Desustorm: right, because nub requires an equality comparison
10:24:03 <Cale> Desustorm: Whereas the function you're trying to write shouldn't really need one
10:24:16 <byorgey> felzix: so you could install darcs ('cabal install darcs' of course =) and follow the directions for getting the repo at http://community.haskell.org/~ndm/cmdargs/
10:24:18 <Cale> Also, nub alone is O(n^2) in geneal
10:24:20 <Cale> general*
10:24:26 <Desustorm> haha i see
10:24:29 <Desustorm> that's not great
10:24:58 <Cale> You can use map head . group . sort if you don't mind sorting and you have an order comparison, but you don't need it here.
10:25:09 <Cale> (that's O(n log n))
10:25:29 <Desustorm> i have a sorted list already
10:26:00 <byorgey> felzix: that way you could get the most recent development version, and easily submit your changes back to Neil
10:26:07 <mercury^> Then skip the sort part, and the algorithm is O(n).
10:26:19 <Cale> I don't see why you need to do this at all though.
10:26:52 <felzix> byorgey: Awesome, that's the page I was looking for. Thanks you!
10:26:54 <Cale> If you can produce the right list using some combination of concatenation, head, tail, init, last, and nub, then you should be able to do without nub
10:27:08 <Cale> Well, given that all the elements of your original list are distinct
10:27:41 <Cale> Because all the elements you'd be removing with nub are elements you specifically put there yourself.
10:27:54 <byorgey> felzix: great, you're welcome =)
10:27:55 <Cale> and you know what those elements will be beforehand
10:28:16 <Desustorm> ah
10:28:29 <Desustorm> > nub "aabbc"
10:28:30 <lambdabot>   "abc"
10:28:38 <Desustorm> > nub "agabbc"
10:28:39 <lambdabot>   "agbc"
10:28:49 <Desustorm> hmm
10:29:08 <Desustorm> > nub "8456784"
10:29:09 <lambdabot>   "84567"
10:29:18 <Desustorm> curses
10:30:01 <Cale> What are you trying to do?
10:30:14 <MisterN> > nub [1,2,3,1]
10:30:15 <lambdabot>   [1,2,3]
10:30:17 <Cale> Write a function to take the nth element of a list and put it at the end?
10:30:26 <Desustorm> turn 45678 into 85674
10:30:30 <medfly> sort?
10:30:33 <medfly> reverse?
10:30:36 <Desustorm> no, swap
10:30:45 <Cale> swap only the first and last elements?
10:30:47 <Desustorm> yes
10:30:59 <Desustorm> i've split it from the original pack
10:31:00 <jethr0> @seen dons
10:31:00 <lambdabot> Unknown command, try @list
10:31:21 <Cale> Well, then  swap [] = []; swap [x] = [x]; swap xs = [last xs] ++ (tail (init xs)) ++ [head xs]
10:32:58 <Cale> Btw, xs ++ ys takes O(length xs) steps to evaluate fully
10:33:09 <Cale> Just to give you a sense of the performance
10:33:15 * jethr0 is pondering a far more complex solution, but so far is coming up empty ;)
10:33:28 <medfly> not using lists?
10:33:30 <Cale> It's really O(min(k,length xs)) where k is the number of elements you use
10:33:41 <Desustorm> hmm okay
10:34:06 <danderson> which type class defines the conversion performed by fromIntegral ?
10:34:13 <jethr0> using sequence might be faster...
10:34:26 <Cale> danderson: A combination of Num and Integral
10:34:29 <burp> :t fromIntegral
10:34:30 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:34:31 <Cale> :t fromInteger
10:34:32 <danderson> I've defined a Bounded subtype of Int (to constrain it to the range 0..32), but fromIntegral 42 silently converts
10:34:32 <lambdabot> forall a. (Num a) => Integer -> a
10:34:42 <danderson> instead of complaining
10:34:48 <Cale> :t toInteger
10:34:49 <lambdabot> forall a. (Integral a) => a -> Integer
10:34:51 <jethr0> danderson: silently converts to what?
10:34:58 <danderson> to my Bounded type
10:35:09 <danderson> > fromIntegral 42 :: IPv4Prefix
10:35:10 <lambdabot>   Not in scope: type constructor or class `IPv4Prefix'
10:35:21 <danderson> that returns a 42 of type IPv4Prefix
10:35:29 <danderson> when IPv4Prefix is Bounded between 0 and 32
10:35:35 <Cale> danderson: define fromInteger
10:35:43 <Cale> danderson: So that it checks the number
10:35:49 <Desustorm> \o/
10:35:53 <Desustorm> it lives!
10:35:57 <Cale> It can only do so at runtime of course.
10:36:04 <danderson> Cale: ah, got it
10:36:13 <danderson> Cale: runtime detection is better than no detection
10:36:22 <Desustorm> I just need to sort out the rng and I'm golden
10:38:08 <Boxo> @pl \f a b x = f (a x) (b x)
10:38:08 <lambdabot> (line 1, column 10):
10:38:08 <lambdabot> unexpected "="
10:38:08 <lambdabot> expecting pattern or "->"
10:38:13 <Boxo> @pl \f a b x -> f (a x) (b x)
10:38:13 <lambdabot> liftM2
10:38:30 <Desustorm> Cale, thanks a lot man :)
10:38:33 <Twey> Don't you love it when that happens?
10:40:16 <Cale> Desustorm: no problem :)
10:40:24 <pokoko222> i have optional subjects: linear algebra OR algebraic structures but not the two, u gotta choose one, what should i do? they are both kinda fundemental. or for the love of category theory i should go algebraic structures?
10:40:37 <monochrom> linear algebra
10:40:48 <danderson> Cale: actually, now that I think about it, an IP CIDR prefix is not actually a Num.
10:40:56 <osaunders> monochrom: Why?
10:41:01 <danderson> it's just Eq, Bounded, Enum.
10:41:13 <danderson> possibly Ord, I guess
10:41:15 <Cale> danderson: Yeah, it might be best to just define an enumeration
10:41:34 <danderson> yeah, needs to be Ord to determine if a prefix is more specific than another
10:41:47 <NEEDMOAR> pokoko222: I would take algebraic structures, since probably learning linear algebra by your own would be easier.
10:41:54 <danderson> so, Eq, Ord, Bounded, Enum, and toEnum lets me throw Ints into the type
10:41:56 <danderson> -> \o/
10:42:12 <opqdonut> is Ord really applicable?
10:42:16 <opqdonut> feels like a partial order to me
10:42:22 <pokoko222> NEEDMOAR and it would get me closer to CT since it is more abstract, and CT will bring me close to Haskell Master Ninja right?
10:42:38 <danderson> opqdonut: in some sense. /24 > /16, because /24 is more specific
10:42:50 <opqdonut> ah okay, only that part
10:42:55 <monochrom> osaunders: because special first, general later.
10:42:57 <danderson> although I could also make the argument for /16 > /24, because it encompasses more addresses...
10:43:03 <osaunders> pokoko222: I know monoids and monads are algebraic structures.
10:43:16 <opqdonut> monads aren't
10:43:35 <danderson> opqdonut: in what way were you parsing what I was saying?
10:43:37 <osaunders> opqdonut: OK.
10:43:41 <Twey> opqdonut: Why not?
10:43:45 <xerox> I vote for linalg too.
10:43:52 <pokoko222> osaunders yeah CT stuff
10:43:53 <sepp2k> How do I say things like "this function takes a function that takes an a and returns an a for all a"?
10:43:56 <danderson> (just curious, in case it's applicable to other types I'm defining)
10:44:01 <opqdonut> well you need to know more than algebra to grok monads
10:44:19 <NEEDMOAR> pokoko222: in some sense, yes. However, there's a lot of stuff needed to master Haskell that is not related to category theory (or at least directly related), more implementation or type theory stuff...
10:44:25 <Twey> opqdonut: Ah, because they bind functions?
10:44:26 <xerox> sepp2k: (a -> a) -> ...
10:44:40 <fax> I thuoght nobody knew haskell.....
10:44:52 <opqdonut> danderson: i was thinking of addreses with netmasks, 10.1.1.1/24 > 10.1.1.1/16 but 10.1.1.1/16 and 10.2.1.1/24 aren't comparable
10:44:54 <osaunders> fax: Huh?
10:44:58 <NEEDMOAR> pokoko222: however, linear algebra needs (in my opinion) a less degree of abstraction than algebraic structres... That's why I would go for algebraic structures.
10:44:58 <fax> thats what people keep telling me
10:45:07 <pokoko222> NEEDMOAR yes well next will be type theory, i already read a lot on compilers and type systems so...
10:45:19 <opqdonut> Twey: yeah, and the monad laws are about arrows
10:45:23 <pokoko222> NEEDMOAR nice, thank you
10:45:44 <osaunders> fax: If we're going to be literal it is not possible for nobody to know a programming language because the language designer has to know it.
10:46:00 <osaunders> fax: What exactly those people mean when they say nobody is pretty undefined.
10:47:10 <danderson> opqdonut: ah, right. I defined IPv4 (just the address) and IPv4Prefix (just the CIDR netmask)
10:47:22 <sepp2k> xerox: I don't think I explained very well. This would also accept a function of type (Char -> Char). I only want to accept functions that are polymorphic.
10:47:26 <Twey> osaunders: Unless it's designed by committee y
10:47:32 <Twey> s/ y//
10:48:07 <monochrom> for example haskell
10:48:30 <danderson> IPv4 implements pretty much everything under the sun: Bits, Bounded, Enum, Eq, Integral, Num, Ord, Read, Real, Show
10:48:54 <danderson> though I should probably kill a couple of those
10:49:04 <monochrom> but not Monoid :)
10:49:10 <Saizan> Real?
10:49:14 <Saizan> ?src Real
10:49:14 <lambdabot> class  (Num a, Ord a) => Real a  where
10:49:14 <lambdabot>     toRational      ::  a -> Rational
10:49:23 <osaunders> Twey: True but what a pathological situation that would be: where nobody on the committee has a complete understanding of what they're designing; awful.
10:49:33 <Twey> osaunders: *cough* *cough*
10:49:36 <danderson> Saizan: it's a dependency on one of the others, and is trivial to define because the internal representation is Word32
10:49:40 <danderson> which is also a Real
10:50:01 <osaunders> Twey: Maybe that happens more than I realize.
10:50:02 <danderson> s/on one of the others/of one of the others/
10:50:21 <Saizan> mh, i don't think it is
10:50:39 <monochrom> Why is that awful? I find it not awful. I think only control freaks find it awful. But then I also think control freaks are awful.
10:50:57 <Twey> monochrom: Because you end up with C++
10:51:18 <monochrom> haskell is designed by committee too.
10:51:31 <danderson> Saizan: it's a requirement for Integral
10:51:34 <fax> "where nobody has complete understanding of X" -- everything everwhere always
10:51:36 <jcreigh> well, it *was*. Now it's defined by GHC. :)
10:51:49 <Twey> Where every task has three completely incompatible features for solving it, each with their own subtle problems
10:52:03 <danderson> and being able to fromIntegral an IP is rather useful in some cases
10:52:09 <Twey> monochrom: Haskell got lucky, though we still have bits like the exception system to boast of
10:52:36 <Twey> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
10:52:49 <twink> I don't think there are very many languages where functionality has taken a back seat to well-definedness and formal definition.
10:53:31 <twink> I think most things trip over a lot of the same areas Haskell does in getting the bare minimum going, try to get formal whatever around it, and so on.
10:54:39 <znutar> I think most places that try to be well defined and formally defined fall into the trap of not having enough programs being written in it to find out why it's horrible to use in fact.
10:55:12 <osaunders> I know I said "a complete understanding of [x]" but I don't mean that.
10:55:14 <znutar> If you're just writing out the spec a priori you're doing dead reckoning, and never going to get something as nice as with a hardy feedback loop
10:55:33 <osaunders> If it's necessary to have a complete understanding of a programming language to know it then I don't know any.
10:55:37 <danderson> Saizan: actually, never mind. Thinking about it, I prefer to define IPv4 implementing Eq,Ord,Enum,Bounded,Show,Read , and have toWord32 and fromWord32 functions to pick stuff out
10:55:54 <monochrom> Here is why the opposite is true. Design by single person is awful. The single person is too limited, compared to the committee. Limited creative ability, limited critical ability, limited open-mindedness, limited time, limited knowledge.
10:55:57 <twink> I'm not sure if it's Russell & Whitehead -style folly to try to get things totally formally defined or what.
10:55:58 <danderson> making IPs addable and divisible just to get fromIntegral working makes no sense
10:56:19 <osaunders> monochrom: All those things are limited in the committee also.
10:56:27 <osaunders> Just less so.
10:56:50 <twink> I think it can be done but the results have sucked for seemingly non-innate reasons every time people have tried.
10:56:52 <monochrom> OK, so design by single person is more awful than design by committee.
10:57:01 <osaunders> Anyway the problem with committees is that they lack continuity and that's very important in language design.
10:57:13 <osaunders> s/they lack/they can lack/
10:57:34 <monochrom> Here is why the opposite is true. Design by single person lacks continuity. When he/she dies it ends.
10:57:55 <FauxFaux> Most things become irrelevant within a human lifespan.
10:58:08 <osaunders> I fail at words. Continuity isn't what I meant.
10:58:11 <Twey> ReiserFS, I guess
10:58:16 <Twey> Coverage?
10:58:28 <monochrom> And yeah, ReiserFS, you don't even have to wait for death.
10:58:29 <FauxFaux> Consistency.
10:58:31 <osaunders> Unified goals.
10:58:41 <twink> How do you specify side effects of purely functional programs (e.g. IO monad results) for some mini-Haskell or PCF or some such?
10:58:42 <osaunders> Unified vision.
10:59:25 <twink> Actually, it doesn't seem to be limited to languages of any specific strictness etc.
10:59:58 <Twey> twink: I don't understand the question.
11:01:07 <twink> Twey: I guess you're trying to define equivalence between programs, so once you throw IO into the mix, what on earth is the denotation/etc. that gives you any equivalences?
11:01:39 <Twey> Sounds like a variation on the halting problem…
11:02:10 <twink> Like hPutStr h s >> hPutStr h s' is equivalent to (maybe) hPutStr h (s ++ s')
11:02:41 <ddarius> You have to define IO, or provide an axiom set.
11:03:02 <sepp2k> xerox: I found what I was looking for. I was looking for RankNTypes.
11:03:08 <xerox> sepp2k: good :)
11:03:35 <twink> Yeah, I just haven't seen very many precedents for doing either of those things. I think the texts I worked off of glossed over impurities for the most part.
11:05:00 * hackagebot Useful 0.0.5 - Some useful functions and shorthands.  http://hackage.haskell.org/package/Useful-0.0.5 (DanielHolden)
11:05:01 <monochrom> Here is why the opposite is true. Design by single person lacks unified goal/vision. Every single person has more cognitive dissonance then himself/herself is aware of, jeopardizing unified goal/vision, instead demonstrating his/her hypocricy and self-inconsistency in his/her design. A committee has a better chance of pointing out and destroying each member's cognitive dissonance. Example: most designed-by-single-person languag
11:05:01 <monochrom> es allow user-definable alphanumeric function names but not symbolic operator names (hypocricy!), whereas Haskell, desgined by committee, gives you no such bullshit.
11:05:42 <Saizan> if you do it denotationally you end up modelling the part of IO that you cover with a purely functional equivalent
11:06:32 <Twey> monochrom: So does C++ :þ
11:06:58 * ddarius thinks how many people is a second order factor compared to which people...
11:07:10 <ddarius> Saizan: Indeed.
11:07:14 <Twey> Aye
11:07:30 <twink> Saizan: Sounds fine, the details or whatever specific to IO elude me.
11:08:02 <monochrom> Stroustrup was and still is the mastermind behind all the cognitive dissonance. The committee fears him and dares not offend his opinions.
11:08:24 <osaunders> monochrom: Yep.
11:08:39 <monochrom> Which means, this is not an example of design by committee.
11:08:43 <osaunders> Same is true of Larry Wall.
11:08:57 <monochrom> This is an example of the People's Congress of China.
11:09:14 <osaunders> This == Haskell?
11:09:18 <monochrom> The Congress consists of 2000 people and is still not a committee.
11:09:29 <marcot> Cale: you said that to evaluate code at compile time I needed only to enable TH and use $(code) ?
11:09:39 <monochrom> This == Stroustrup's brainchild.
11:09:46 <Cale> marcot: that only works in special cases
11:09:50 <Twey> monochrom: Haha.
11:10:01 <Cale> marcot: but yeah
11:10:10 <Cale> marcot: Specifically it works with numbers
11:10:27 <marcot> Cale: I tried here with numbers, but it seems that it's requiring a TH data type inside the $()
11:11:01 <marcot> it's something in the form length [i | i <- [0 .. 1000], condition i]
11:11:01 <Cale> Perhaps I'm misremembering something
11:11:06 <Twey> , $(3 + 5)
11:11:13 <Saizan> twink: e.g. if you model only IORefs (i.e. ST) you end up with IO = State Heap, it gets messier with concurrency though.
11:11:20 <Twey> Didn't we have a TH-bot?
11:11:31 <medfly> @botsnack
11:11:31 <lambdabot> :)
11:11:38 <medfly> no lunabot.
11:11:51 <ddarius> mmorrow has been missing
11:12:03 <Twey> Hm
11:12:38 <marcuy> anyone who knows how to load properly the haskell emacs mode interpreter?
11:13:54 <dfdfdf> marcuy: do you have haskell-mode installed?
11:14:06 <Cale> marcot: oh, try $(lift . length $ [ ... ])
11:14:33 <Cale> marcot: lift from the Language.Haskell.TH.Syntax module
11:15:05 <marcot> Cale: sure.
11:15:11 <marcuy> dfdfdf, yes, and I already loaded the haskell-ghci.el file but I can get it work  C-c C-b
11:15:12 <marcot> Oh, great!
11:15:28 <marcot> Cale: what are the limitations, when does it not work?
11:15:42 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html#t%3ALift
11:15:49 <Cale> You can see the instances of Lift there
11:16:00 <marcot> Cale: ah, ok.  Thanks a lot.
11:16:09 <Cale> So it's a pretty restricted range of types, pretty much corresponding to the available syntax for literals.
11:16:46 <marcot> Cale: It should be possible to write more instances to Lift.
11:16:55 <Saizan> you can extend it for most first-order data
11:17:04 <dfdfdf> marcuy : what would C-c C-b do?
11:17:07 <sinelaw> anyone tried using the "finally tagless" thing in an implementation?
11:17:23 <marcuy> dfdfdf, Start the interpreter at haskell-mode
11:17:25 <sinelaw> don't know anything 'bout, i'm asking from a user perspective
11:18:28 <dfdfdf> try C-c C-l
11:18:48 <marcot> Cale: do you think it would be useful to do this kind of redution in the whole code, without the user specifying when it's needed?
11:20:53 <Mathnerd314> byorgey: good point
11:21:25 <marcuy> dfdfdf, it says: symbol's function definition is void: inferior-haskell-load-file
11:21:49 <mail> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:21:56 <mail> cool :P
11:22:06 <fax> lol
11:22:08 <Cale> marcot: Well, if there were such a thing as a halting oracle, maybe.
11:22:36 <Saizan> marcuy: have you read the README? maybe you're missing something in your .ghci
11:22:37 <dfdfdf> marcuy: hmm, i have no idea why that would happen. sorry, can't help you
11:22:52 <marcuy> dfdfdf, thanks anyway
11:23:05 <sinelaw> is there any specific advantage to having a single constructor and a shallow dsl rather than a deep-dsl with many constructors?
11:23:45 <marcuy> Saizan, I'm got stuck at this
11:23:48 <sinelaw> the way i see it, for any advanced features a deep dsl is more powerful because it lets you probe the structure that was built
11:24:13 <marcot> Cale: Maybe with a -f option that is not enable by default in any of the -O, and that the user only uses when he's sure the program will stop.
11:24:21 <mail> how can i iterate through a string and return true if each char is a digit
11:24:21 <Saizan> sinelaw: interpreting your deep dsl syntax can have a significant computational overhead
11:24:52 <mreh> :t isChar
11:24:53 <lambdabot> Not in scope: `isChar'
11:25:07 <medfly> @hoogle elem
11:25:08 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:25:08 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
11:25:08 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
11:25:16 <mreh> mail: you don't really iterate in functional languages
11:25:36 <mail> yeah i'm having a hard time getting my head around it
11:25:42 <Saizan> > all isDigit "123"
11:25:43 <lambdabot>   True
11:25:44 <dfdfdf> > all isDigit ['1','2']
11:25:45 <lambdabot>   True
11:25:48 <medfly> crud :/
11:26:02 <sinelaw> Saizan, both for deep and shallow dsl's you need to interpret exactly once
11:26:06 <mreh> :t and
11:26:07 <lambdabot> [Bool] -> Bool
11:26:14 <mreh> :t all
11:26:15 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:26:27 <mreh> let me guess
11:26:28 <mreh> and . map
11:26:34 <mail> i'm thinking i have to use recursion or list comprehension
11:26:39 <sinelaw> Saizan, with shallow ones you use interpretation locally, but you still do the same work. no?
11:26:52 <sinelaw> Saizan, and you can't optimize the structure globally
11:26:59 <mreh> mail: all isDigit
11:27:03 <mreh> :t all isDigit
11:27:04 <sinelaw> like lazy vs. strict
11:27:04 <lambdabot> [Char] -> Bool
11:27:11 <Saizan> sinelaw: you can easily end up doing exponential more work
11:27:20 <sinelaw> Saizan, i don't see how
11:27:30 <Saizan> sinelaw: recursion in the host language
11:27:37 <medfly> > map isDigit "123ab3"
11:27:38 <lambdabot>   [True,True,True,False,False,True]
11:28:10 <mreh> :t one
11:28:11 <lambdabot> Not in scope: `one'
11:28:16 <sinelaw> Saizan, do you have a simple example?
11:28:18 <mreh> what is all's dual?
11:28:28 <medfly> @type all
11:28:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:28:31 <ddarius> any
11:28:33 <byorgey> mreh: any?
11:28:33 <sinelaw> what do you mean by recursion
11:28:37 <mreh> :t any
11:28:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:28:41 <mreh> ah
11:28:45 <mail> what's the best haskell library reference
11:29:01 <sinelaw> mail http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
11:29:08 <sinelaw> ....and hackage
11:29:17 <sinelaw> @where base
11:29:17 <lambdabot> http://darcs.haskell.org/packages/base/
11:29:27 <byorgey> @check \l p -> all p l == (not . any (not . p)) l
11:29:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
11:29:28 <lambdabot>    arising fro...
11:29:34 <byorgey> bah
11:29:47 <medfly> no
11:30:02 <medfly> it's like asking if not . || is the same as &&
11:30:17 <byorgey> hmm?
11:30:22 <medfly> > not . (||) False False
11:30:23 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
11:30:23 <lambdabot>         against inferred typ...
11:30:25 <medfly> err
11:30:29 <medfly> > not . (||) $ False False
11:30:30 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
11:30:30 <lambdabot>         against inferred type ...
11:30:39 <medfly> what the hell
11:30:48 <trofi> :t ($)
11:30:49 <lambdabot> forall a b. (a -> b) -> a -> b
11:30:49 <byorgey> needs moar (.)
11:30:54 <medfly> > not (False || False)
11:30:54 <Saizan> sinelaw: a pathological example: you've a syntax term defined like "foo = Constr foo" when you interpret that you pattern match and reduce an infinite number of Constr, in a shallow settings you interpret before tying the knot of the recursive definition, so you do it only once.
11:30:55 <lambdabot>   True
11:31:04 <byorgey> > not ((.) . (.)) (||) $ False False
11:31:04 <medfly> > False && False
11:31:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
11:31:05 <lambdabot>         against inferred type ...
11:31:05 <lambdabot>   False
11:31:18 <byorgey> > ((.) . (.)) not (||) $ False False
11:31:19 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
11:31:19 <lambdabot>         again...
11:31:23 <Cale> @undefine
11:31:29 <Cale> > False && False
11:31:30 <lambdabot>   False
11:31:37 <byorgey> > ((.) . (.)) not (||) $ False False
11:31:38 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
11:31:39 <lambdabot>         again...
11:31:44 <aavogt> > undefined $ False False
11:31:45 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> a'
11:31:46 <lambdabot>         against inferred ...
11:31:50 <ddarius> You are applying False to False.
11:31:56 <Saizan> sinelaw: now do "foo = Constr2 foo foo" and it gets exponential.
11:31:57 <byorgey> oh, duh.
11:32:12 <byorgey> anyway.
11:32:22 <sinelaw> Saizan, hmm...
11:32:30 <sinelaw> Saizan, but for DSL's that don't allow recursion?
11:32:44 <Saizan> sinelaw: haskell allows recursion
11:32:47 <byorgey> medfly: sorry.  is your question answered?
11:32:57 <medfly> byorgey, what?
11:33:02 <Saizan> sinelaw: haskell is always there as a meta-language at least
11:33:09 <aavogt> @type  (not .) . (||)
11:33:10 <lambdabot> Bool -> Bool -> Bool
11:33:16 <Saizan> sinelaw: so it's easy to write macros that produce exponentially large terms
11:33:27 <byorgey> medfly: about the dual of all.
11:33:36 <medfly> byorgey, I didn't ask that question
11:33:41 <fax> my biggest question right now is how to build an algebra heirerachy and program with it in the large
11:33:55 <Saizan> sinelaw: however, it still might not affect your use case
11:34:01 <byorgey> medfly: oh, right.  but I don't understand what you were saying about (&&) and the negation of (||)
11:34:10 <fax> it might need a meta-language to expand out into the source code files..
11:34:12 <byorgey> clearly those are not the same but I don't see how it relates
11:34:14 <medfly> any is like or, isn't it? and all like and.
11:34:15 <aavogt> @google de morgan
11:34:15 <lambdabot> http://en.wikipedia.org/wiki/De_Morgan's_laws
11:34:16 <lambdabot> Title: De Morgan's laws - Wikipedia, the free encyclopedia
11:34:23 <sinelaw> Saizan, interesting point
11:34:48 <sinelaw> i didn't even consider the possibility of recursion
11:34:53 <medfly> > any [True,False,False]
11:34:54 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
11:34:54 <lambdabot>         against inferred ...
11:34:57 <byorgey> medfly: indeed.
11:34:57 <medfly> err
11:34:58 <sinelaw> ....by the host language
11:35:16 <byorgey> medfly: any p = or . map p; all p = and . map p
11:35:39 <medfly> it seemed like someone was trying to figure out if not . any == all, or something
11:35:40 <medfly> whatever
11:35:58 <aavogt> @type not . any
11:35:59 <lambdabot>     Couldn't match expected type `Bool'
11:36:00 <lambdabot>            against inferred type `[a] -> Bool'
11:36:00 <lambdabot>     Probable cause: `any' is applied to too few arguments
11:36:08 <sinelaw> Saizan, the more general case is : foo = fooFuncOf (Contr foo)
11:36:10 <medfly> what does it matter
11:36:15 <byorgey> medfly: no, I wrote  not . (any (not . p)) == all
11:36:15 <aavogt> it needs more fmap
11:36:21 <byorgey> note the extra not
11:36:29 <medfly> never mind
11:36:33 <byorgey> ok, sorry =)
11:36:34 <sinelaw> for a given fooFuncOf, that may type-check
11:36:36 <medfly> why do you keep talking about it, I said never mind
11:37:13 <sinelaw> whereas foo = Constr foo won't type check unless the dsl supports it
11:39:15 <sinelaw> Saizan, what stops arbitrary DSLs from failing in the case: foo = toFoosType (Constr foo)?
11:39:32 * hackagebot resumable-exceptions 0.0.0.20100313 - A monad transformer for resumable exceptions  http://hackage.haskell.org/package/resumable-exceptions-0.0.0.20100313 (NicolasFrisby)
11:39:43 <aavogt> @hackage cmdargs
11:39:43 <lambdabot> http://hackage.haskell.org/package/cmdargs
11:39:52 * fax thought it was interesting anyway
11:40:17 <sinelaw> resumable exception? cool
11:40:18 <aavogt> ^^ does the impurity of &= matter here?
11:40:37 <byorgey> aavogt: matter for what?
11:40:50 <aavogt> for sanity
11:41:21 <byorgey> hehe, I've used cmdargs successfully before.  It was quite fast to get up and working.
11:41:41 <byorgey> although the non-purity did throw me for a loop for about five minutes until I figured out what was going on.
11:41:50 <twink> What deep vs. shallow DSL's are eludes my google-fu.
11:42:36 <fax> probably just a vauge term that doesn't really matter
11:42:58 <fax> or mabye it's the same as .. shallow embedding vs deep embedding
11:43:16 <byorgey> twink: basically, the combinators of a deep DSL construct an actual AST which is later interpreted.  In a shallow DSL the combinators actually carry out the interpretation themselves.
11:43:42 <byorgey> yes, it's the same as shallow vs. deep embedding I think
11:43:44 <twink> byorgey: I was starting to guess something like that.
11:44:23 <twink> Might be hard to get the types right in a deep DSL's built-up data structure.
11:44:30 <sinelaw> i just heard it here which is why i use those terms
11:44:44 <sinelaw> maybe there's a better term for what i mean
11:45:22 * SamB_XP never heard those terms before
11:45:55 <sinelaw> SamB_XP, do you have a name for the distinction byorgey made?
11:46:05 <sinelaw> i'd rather use more accepted names
11:46:06 <SamB_XP> no
11:46:21 <SamB_XP> I just never heard a name for the distinction before, that I can recall ;-)
11:46:22 <byorgey> I think those terms are pretty standard
11:46:33 <Saizan> sinelaw: well nothing in general, if i understand you correctly, but that's orthogonal, it doesn't affect how much duplicated interpretation occurs
11:47:11 <SamB_XP> Saizan: I don't see how not
11:48:06 <Saizan> sinelaw: anyhow, you often start with a deep edsl and go shallower when you figure out what you're doing
11:48:24 <Saizan> SamB_XP: give me a constructive proof that it does :)
11:48:28 <sinelaw> Saizan, ok, that's what i've done. but beginning to regret that
11:48:42 <sinelaw> Saizan, because i can't optimize my structure now
11:48:45 <sinelaw> once its already built
11:49:21 <sinelaw> Saizan, like knowing that two sub-parts are identical values that were used twice
11:49:32 <SamB_XP> Saizan: feeding the same DSL program to the same interpretation program twice does the work of interpreting twice!
11:49:51 <sinelaw> SamB_XP, the question was from before
11:51:09 <Saizan> sinelaw: yeah, i meant you've to refactor your datatype and combinators
11:51:39 <Saizan> sinelaw: you could do CSE if you can pay that price
11:51:51 <sinelaw> @hoogle (a -> a') -> (a' -> b) -> (a' -> b') -> a -> (b, b')
11:51:52 <lambdabot> No results found
11:51:56 <sinelaw> Saizan, how?
11:52:00 <Saizan> sinelaw: as an alternative, i mean
11:52:05 <sinelaw> how do i compare SEs
11:52:21 <Saizan> SEs?
11:52:38 <sinelaw> i meant CSEs, common sub expressions. they've already been interpreted by the shallow and stuck inside other stuff
11:52:39 <Saizan> how does your expression type look like?
11:52:49 <sinelaw> *shallow combinators
11:52:58 <fax> crumbly subexpression elimination?
11:53:13 <sinelaw> CS's i guess i should have said :)
11:53:14 <c_wraith> cookie subexpression explanation
11:53:25 <sinelaw> c_wraith, subordination eminent
11:53:54 <c_wraith> don't you mean immanent, thus ruining the joke?
11:53:59 <c_wraith> err.  imminent
11:53:59 <Saizan> ah, you want to do CSE in a shallow edsl? to figure out which parts were the same?
11:54:21 <sinelaw> Saizan, yes. i understand "finally tagless" has something to do with this?
11:54:21 <Saizan> change your combinators so that they have a notion of identity.
11:55:16 <Saizan> i.e. some kind of hash-consing, probably
11:55:16 <sinelaw> Saizan, if it was deep, i could just do some graph transformations and get it over with
11:56:16 <Saizan> sinelaw: you can do the same with a shallow one, you just have to change the domain of the interpretation
11:56:27 <sinelaw> Saizan, yeah i was considering that, but didn't think of using hashes. i'm not sure i can, because my datatype holds functions
11:56:52 <sinelaw> Saizan, what do you mean by changing the domain of interpretation?
11:56:59 * sinelaw sounds like Eliza
11:58:34 <Saizan> that if you interpreted your dsl into some type T, you now use e.g. (T,OtherStuff) where OtherStuff is what is needed to do the analysis you were going to do with the deep dsl
11:59:32 <sinelaw> ok
12:01:04 <Saizan> the finally tagless style makes it very easy to do this
12:01:09 <sinelaw> Saizan, however, even if i know that a Common subexpression exists in two parts of the graph, i won't be able to access them because the branches have been flattened by the shallow combinators
12:01:27 <sinelaw> so i won't have much to do with this info, no?
12:01:52 <sepp2k> @pl \h i -> i (h g)
12:01:52 <lambdabot> flip id . ($ g)
12:03:18 <Saizan> sinelaw: you can make the combinator use the previous subexpression instead of the one that it's going to construct, however you might need a notion of binder in your language and make the user explicitly mark the sharing, like we do with "let x = .. in .." in haskell to really get any benefit
12:03:57 <sinelaw> so...ghc doesn't optimize CSEs unless you use let?
12:04:18 <sinelaw> *doesn't do CSE :)
12:05:02 <Saizan> yeah
12:05:28 <sinelaw> :( slightly disappointing
12:05:46 <Saizan> GHC doesn't do it because with lazyness it can be a pessimization
12:06:58 <Saizan> you might not want to do it in your interpreter because you still need to analyze all the term, while with an explicit binder you get a much smaller one
12:07:00 <sinelaw> well, if any one branch that eventually evaluates has the subexpression, it can be shared. if noone does, then it won't be evaluated at all, no?
12:07:36 <Saizan> the problem is that keeping the result in memory can be more expensive than recomputing it later
12:07:46 <sinelaw> ah
12:08:15 <sinelaw> ideally there could be some way to know what is more expensive on a given machine
12:08:28 <sinelaw> maybe its cheaper to send it on the network and evaluate it there
12:08:47 <sinelaw> and the prices change during runtime
12:09:03 <sinelaw> Saizan, anyway thanks for the insights :)
12:09:47 <sinelaw> @hoogle (a -> b) -> (a -> b') -> a -> (b, b')
12:09:48 <lambdabot> No results found
12:09:51 <sinelaw> @pl (a -> b) -> (a -> b') -> a -> (b, b')
12:09:52 <lambdabot> (line 1, column 4):
12:09:52 <lambdabot> unexpected ">"
12:09:52 <lambdabot> expecting variable, "(", operator or ")"
12:10:00 <Saizan> np
12:10:17 <sinelaw> @pl (\f g x -> (f x, g x))
12:10:18 <lambdabot> liftM2 (,)
12:10:49 <yitz> @type (&&&) -- sinelaw
12:10:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:10:51 <ClaudiusMaximus> @hoogle f a b -> f a c -> f a (b,c)
12:10:51 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
12:10:57 * hackagebot direct-sqlite 1.0 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-1.0 (DanKnapp)
12:11:03 <dankna> yay :D
12:11:07 <sinelaw> yitz, yeah i was trying to remember that one
12:11:09 <dankna> hackagebot makes me happy
12:11:12 <Saizan> (too bad they are a bit randomly put together, i should try to organize them)
12:11:28 <sm> yay dankna  :)
12:11:32 <sinelaw> Saizan, if you blog, maybe write about deep vs. shallow dsl's and CSE?
12:11:35 <dankna> :)
12:11:47 <sm> what a coincidence, I just now looked for your nick here to ask you about direct-plugin
12:11:52 <dankna> oh cool
12:12:00 <sm> thanks for it.. what could I do with it exactly ?
12:12:02 <dankna> yeah, I could have written up some documentation, haha
12:12:19 <sm> I read the source but still not quite clear :)
12:12:27 <dankna> well, what it does is look up a given function (or constant) in an installed package
12:12:31 <dankna> and return its value
12:12:36 <dankna> loading the package if necessary
12:12:52 <dankna> it essentially lets you use things without really depending on them in the Cabal sense
12:13:07 <dankna> I use it for my content-management system, which has plugins
12:13:30 <dankna> to install a plugin I first install the package for the plugin through cabal, then inform the CMS that it should look for a package by that name
12:13:39 <Heffalump> oh, it works on the level of packages? that's cool.
12:13:41 <dankna> yeah
12:13:59 <enferex> Just messing with a simple list comprehension
12:14:07 <sinelaw> @type a &&& b . c
12:14:08 <lambdabot>     Couldn't match expected type `a b c' against inferred type `Expr'
12:14:08 <lambdabot>     In the first argument of `(&&&)', namely `a'
12:14:08 <lambdabot>     In the expression: a &&& b . c
12:14:09 <dankna> it would also be possible to work on the level of object files that you find explicitly, but that doesn't seem as useful, really
12:14:10 <sm> I'd like hledger to discover installed plugins and offer them as subcommands - like eg mercurial does. I think this could help ?
12:14:36 <dankna> sm, it probably could help in some fashion, and please feel free to contact me here or at dankna@gmail.com if you discover any features you'd like added or have any questions as you go along
12:14:37 <mail> anybody know why i get this in ghci
12:14:38 <mail> <interactive>:1:0: Not in scope: `digits'
12:14:40 <krey> hi, can someone help me with parsers?
12:14:43 <sm> great, thanks
12:14:48 <sinelaw> yitz, does &&& bind stronger than .? and how can i know for myself?
12:14:49 <dankna> the discovery part of it is not particularly easy at present
12:14:56 <krey> trying to parse strings into trees
12:14:57 <Saizan> @hoogle digits
12:14:57 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
12:14:58 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
12:14:58 <lambdabot> Numeric lexDigits :: ReadS String
12:15:02 <cheater2> hi
12:15:06 <enferex> I want to make a list of Int print each element on a new line:  let iter n = [ putStrLn x | x<-[0 .. n]]
12:15:12 <yitz> @type \a b c -> a &&& b . c
12:15:13 <lambdabot> forall (a :: * -> * -> *) b c a1 c'. (Functor (a b), Arrow a) => a b c -> (a1 -> c') -> a b a1 -> a b (c, c')
12:15:20 <sm> dankna: well I guess I could load and catch exceptions
12:15:22 <dankna> I did think about whether it might be possible to insert an extra field into a package description and chew that field to discover things
12:15:23 <Saizan> enferex: you need sequence_
12:15:36 <dankna> yeah, but loading every single package on the system?  not really viable
12:15:38 <sm> (if I know the plugin names)
12:15:47 <enferex> Saizan: can I not call a routine from a list comprehension?
12:15:47 <yitz> hmm , a is  bit confusing here.
12:15:48 <dankna> if you know the plugin names in advance discovery is already done :)
12:15:49 <twink> enferex: iter n = mapM_ print [0 .. n] ?
12:15:49 <Saizan> sinelaw: you can use :info in ghci
12:16:01 <yitz> @type \f g h -> f &&& g . h
12:16:02 <lambdabot> forall (a :: * -> * -> *) b c a1 c'. (Functor (a b), Arrow a) => a b c -> (a1 -> c') -> a b a1 -> a b (c, c')
12:16:08 <mail> http://pastebin.com/ZeUS9LDY
12:16:13 <mail> I load that in ghci
12:16:18 <yitz> @info (&&&)
12:16:18 <lambdabot> (&&&)
12:16:21 <enferex> twink, Saizan thanks
12:16:37 <Saizan> enferex: no, list comprehensions produce lists, you need an IO action instead
12:16:37 <sinelaw> infixr 3
12:16:40 <sinelaw> says ghci
12:16:42 * sm wonders how *do* you programmatically explore the installed module space
12:16:51 <enferex> Saizan: ah ok
12:16:56 <dankna> oh there is an interface for that
12:17:00 <sm> I can get package names from ghc-pkg, but that's not the same
12:17:01 <sinelaw> so i guess it's stronger than . ?
12:17:03 <dankna> the GHC API provides it
12:17:09 <sm> cool, makes sense
12:17:18 <yitz> sinelaw: right.
12:17:25 <Saizan> enferex: sequence takes a list of actions and produces a single action that performs all of them in order, though
12:17:25 <krey> parsers anyone, please?
12:17:27 <dankna> you can get for each package a list of the modules it exports, for example
12:17:53 <dankna> and a list of all packages from a related part of the interface
12:18:09 <sinelaw> @type sequence
12:18:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:18:10 <dankna> so you can visit the whole module space fairly efficiently, not that I've implemented this so don't quote me :)
12:18:20 <Saizan> sinelaw: infixr 9 .
12:18:33 <sm> hey, based on that load function you are my new ghc api guru :)
12:18:35 <sinelaw> Saizan, yeah
12:18:45 <Saizan> so . is stronger
12:18:47 <dankna> sm hahahahaa I learned the GHC API yesterday for this purpose :)
12:18:55 <twink> mail: I'd try to avoid overlapping patterns with something like digits :: String -> Bool ; digits [] = False ; digits s@(_:_) = all isDigit s but otherwise it looks okay.
12:18:56 <sm> nice
12:18:59 <dankna> thanks
12:19:21 <sinelaw> speaking of arrows
12:19:29 <dankna> I suppose you could do discovery through the module hierarchy - the convention would be that any package that exports something matching Ledger.Plugin.* is a plugin for your thing
12:19:33 <sinelaw> isn't arr a little redundant? couldn't we fmap on arrows instead?
12:19:39 <sinelaw> for any interesting case
12:19:47 <dankna> I would rather do it through package metadata, something like
12:19:51 <mail> i don't think the import command is working in ghci
12:19:57 <mail> do i have to do something special?
12:20:09 <dankna> an extra attribute in the .cabal and the ghc-pkg file, named something like HLedger-Plugin-Interface: 1.0
12:20:15 <dankna> that lets you version it
12:20:32 <dankna> but I'm not sure ghc-pkg supports extra attributes, I need to look into it
12:20:35 <yitz> sinelaw: oops. Yeah, Saizan is right.
12:20:41 <sm> an idea I hadn't considered
12:20:58 <yitz> mail: :m +Modue.Name
12:20:58 <Alpounet> sinelaw, you're making your processors instances of Arrow ?
12:21:01 <Saizan> sinelaw: yeah, "arr f = fmap f id" though initially there were no id
12:21:05 <sinelaw> Alpounet, considering it
12:21:06 <dankna> it's also faster because you only have to visit each package, not each module of each package.  might or might not be significant.
12:21:07 <yitz> mail: :m +Module.Name
12:21:42 <Alpounet> it's a good idea in my opinion
12:21:51 <sinelaw> @hoogle Arrow a => a b c -> a c d -> a c e -> a b (d,e)
12:21:51 <lambdabot> No results found
12:22:06 <sinelaw> @hoogle Arrow a => a b c -> a b (c,c)
12:22:07 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
12:22:07 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlowgraph :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> gr a (b, b)
12:22:11 <sm> on the other hand, I can ask the user to add a line to a config file, like hg does
12:22:19 <yitz> mail: why do you want digits [] = False? It is (vacuously) true that all of the characters of the empty string are characters.
12:22:29 <sinelaw> Alpounet, any specific reason?
12:22:41 * sm files the information for future hacking session
12:22:55 <dankna> sm, yeah, that's essentially what I do in my own thing, except for me it's a row in a database
12:23:04 <mail> an empty string has no digits
12:23:06 <dankna> which is basically punting on the issue of discovery, but hey.
12:23:31 <monochrom> every character in an empty string is a digit.
12:23:38 <yitz> mail: right. so every single one of them is a digit.
12:23:51 <yitz> mail: there is not a single character in there that is not a digit.
12:24:13 <monochrom> @type all
12:24:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:24:21 <yitz> @ all isDigit ""
12:24:32 <yitz> > all isDigit ""
12:24:33 <lambdabot>   True
12:24:37 <monochrom> @type every
12:24:38 <lambdabot> Not in scope: `every'
12:24:52 <dankna> hmmm, so ghc-pkg does not support that feature.
12:25:02 <Alpounet> sinelaw, that matches quite well the Arrow model
12:25:08 <Alpounet> (in my mind at least)
12:25:14 <mjrosenb> @type exists
12:25:15 <lambdabot> Not in scope: `exists'
12:25:17 <mail> ok i guess you are right
12:25:17 <mjrosenb> @type exist
12:25:18 <lambdabot> Not in scope: `exist'
12:25:18 <monochrom> > and []
12:25:19 <lambdabot>   True
12:25:22 <mjrosenb> gah
12:25:31 <mail> ghci still wont run the function digits though
12:25:32 <sinelaw> Alpounet, yeah i guess it does
12:25:33 <mjrosenb> @type any
12:25:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:25:36 <mjrosenb> there we go.
12:25:45 <sinelaw> Alpounet, especially now that i've discovered that i really need &&&
12:25:51 * mjrosenb is too used to the sml names for them.
12:26:07 <sinelaw> for example, for a processor that draws on images (it needs both the drawing data and the image to draw on)
12:26:11 <Saizan> mail: so you've the code above in a file.hs and you start ghci like "ghci file.hs" and digits is not in scope?
12:26:27 <mail> i do :l file.hs
12:26:44 <Saizan> and it doesn't give you any error?
12:26:50 <mail> nop
12:26:59 <Alpounet> sinelaw, absolutely
12:27:07 <mail> only when i try to run digits
12:27:09 <mail> <interactive>:1:0: Not in scope: `digits'
12:27:09 <Saizan> mail: have you saved the file?
12:27:11 <mail> yes
12:27:12 <Alpounet> and actually all the other operations fully make sense
12:27:17 <Alpounet> too
12:27:27 <Alpounet> so yeah I'm pretty sure it's a good idea
12:27:31 <sinelaw> yeah
12:27:38 <Saizan> mail: something doesn't match :)
12:28:00 <sinelaw> not hard to implement either
12:28:03 <monochrom> What file? Can I reproduce it?
12:28:22 <Saizan> http://pastebin.com/ZeUS9LDY <- we have this paste
12:30:29 <copumpkin> Mathnerd314: in Haskell, the actual Functor is the type constructor. So in your case (Cons a) would be a functor. [] is another one and Maybe is yet another
12:30:34 <monochrom> works fine for me. perhaps reboot computer.
12:30:50 <copumpkin> Mathnerd314: fmap is a "witness" to the functorness of the type constructor
12:30:53 <mail> not my computer actually :/
12:31:03 <mail> sshed into my uni servers
12:31:12 <sinelaw> Alpounet, Since my type is already a Category, all i need is *** and &&&
12:31:22 <sinelaw> the rest are expressible with the others
12:31:26 <mail> GHCi, version 6.10.1:
12:32:06 <Saizan> sinelaw: so it's an applicative too?
12:32:18 <Mathnerd314> copumpkin: so how would I write that? I keep getting kind errors.
12:32:18 <sinelaw> yes
12:32:19 <Alpounet> sinelaw, oh yeah right
12:32:33 <Alpounet> your processors offer a nice flexibility sinelaw :)
12:32:34 <mail> http://pastebin.com/NU8KF2SF
12:32:34 <sinelaw> Saizan, it's already an applicative, a functor and a category
12:32:37 <mail> this is what happens
12:32:44 <monochrom> quit ghci, look for files to delete, start ghci, try again.
12:32:55 <copumpkin> Mathnerd314: you actually can't write it as a Functor in Haskell. You only have one definition of fmap for that type
12:33:04 <sinelaw> Alpounet,  :)
12:33:21 <copumpkin> and that's fmap (Cons a b) = Cons a (fmap f b)
12:33:24 <mail> :Q
12:33:50 <Mathnerd314> copumpkin: so what's the proper type?
12:33:53 <copumpkin> Mathnerd314: that Functor is more useful than it may look, but it isn't what you want :)
12:34:08 <sinelaw> @type lift
12:34:09 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:34:17 <sinelaw> @type liftA
12:34:18 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
12:34:24 <copumpkin> Mathnerd314: keep in mind the type of f in fmap... it's an (a -> b), and your two parameters to Cons are not constrained to be of the same type
12:34:28 * hackagebot STMonadTrans 0.2 - A monad transformer version of the ST monad  http://hackage.haskell.org/package/STMonadTrans-0.2 (JosefSvenningsson)
12:34:42 <copumpkin> Mathnerd314: (a -> b) -> Cons c a -> Cons c b
12:34:52 <copumpkin> where (Cons c) is the actual functor
12:35:16 <sinelaw> arr = flip liftA id
12:35:16 <sinelaw> ?
12:35:21 <sinelaw> @type flip liftA id
12:35:22 <mail> arrgh still doesn't work
12:35:22 <lambdabot> forall a b. (a -> b) -> a -> b
12:35:33 <Saizan> sinelaw: i like "f &&& g = (,) <$> f <*> g"
12:35:42 <sinelaw> ooh
12:35:55 <Mathnerd314> copumpkin: so how would that apply to Cons (Maybe a) ([a])?
12:36:06 <sinelaw> Saizan, i wonder if that's efficient than my lower-level implementation
12:36:11 <sinelaw> *more efficient
12:36:14 <sinelaw> *less :)
12:36:19 <Saizan> heh, no idea :)
12:36:30 <sinelaw> checking
12:36:36 <copumpkin> Mathnerd314: you'd get a ([a] -> b) -> Cons (Maybe a) [a] -> Cons (Maybe a) b
12:36:55 <copumpkin> Mathnerd314: nothing in the type constrains the two parameters to Cons to be equal
12:37:20 <copumpkin> if they are, you'd typically make it a single parameter
12:37:34 <Mathnerd314> If I wrote Cons a = Cons (Maybe a) ([a]), then they'd be equal?
12:37:40 <copumpkin> but in that case you'd either get data Cons a = Cons a a (isomorphic to (,))
12:37:42 <copumpkin> yep
12:38:12 <Mathnerd314> So if I want arbitrary functors, how do I add that to the type?
12:38:55 <fax> arb functor?
12:39:00 <copumpkin> well, Functors are a particular kind of structure, and not everything fits naturally into the idea
12:39:00 <copumpkin> what's your end goal here? :)
12:39:17 <sinelaw> Saizan, do you have one for (***) ? :)
12:39:22 <fax> "Cons a = Cons (Maybe a) ([a])" isn't meaningful haskell on its own
12:39:28 <fax> you have to prefix by 'type' or 'data'
12:39:42 <fax> if you use 'type' it will be an error, if you use 'data' then the LHS Cons is a different thing than the RHS Cons
12:39:50 <fax> '=' is kind of a misnomer
12:40:07 <Mathnerd314> yeah. left side is a type then.
12:40:08 <fax> unless you literally meant an equation by it
12:40:35 <sinelaw> @type (&&& id)
12:40:36 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
12:40:56 <Saizan> sinelaw: well, there's f *** g = (arr fst >>> f) &&& (arr snd >>> g)
12:41:44 <copumpkin> ARR MATEY
12:41:46 <sinelaw> ah O.o
12:41:55 <sinelaw> ARR FST
12:42:15 <Mathnerd314> so I can write data Cons a = Cons (Maybe a) (Cons a), data Cons a = Cons (Maybe a) [a], data Cons a = Cons (Maybe a) (Maybe a), etc.
12:42:16 <Saizan> first f = (,) <$> (arr fst >>> f) <*> arr snd
12:42:29 <Mathnerd314> I'm wondering if there's a more general way to do that
12:42:34 <Saizan> arr f = f <$> id, and stop :)
12:42:44 <yitz> @remember Saizan  f***g = (arr fst >>> f) &&& (arr snd >>> g)
12:42:44 <lambdabot> Nice!
12:42:56 * sinelaw thinks Saizan has a secret stash of class shortcut trick
12:43:01 <sinelaw> *tricks
12:43:29 <Saizan> yitz: is it so memorable?:D
12:43:49 <yitz> Saizan: next time people write f***g, I'll know what they mean
12:44:11 <Saizan> aaah, i got it now :)
12:44:21 <sinelaw> hah
12:44:25 <fax> what does 'Curry–Howard correspondence' have to do with dependent types?
12:44:33 <mail> fuck you ghci
12:44:37 <sinelaw> do you have one for s**t?
12:44:50 <Saizan> @src **
12:44:51 <lambdabot> Source not found. You type like i drive.
12:44:52 <sinelaw> s**t = arr fst << &^_ %!%!
12:44:57 <sinelaw> or something.
12:45:16 <bjrn> Failing to build ghc HEAD. rts/LdvProfile.c: In function processHeapClosureForDead: rts/LdvProfile.c:113:0: error: TVAR_WATCH_QUEUE undeclared (first use in this function) etc. Sounds familiar? Tried to ask in #ghc but I "Cannot send to channel" whatever that means.
12:45:19 <sinelaw> i was kidding. *crawls back into hole*
12:45:37 <Saizan> fax: it's just that with dependent types you can actually have interesting theorems in the types, i'd guess
12:45:47 <fax> okay
12:46:01 <sinelaw> Saizan, what's your academic education if at all?
12:46:11 <sinelaw> + years of haskell experience?
12:46:19 <sinelaw> if you don't mind telling
12:46:38 <Saizan> sinelaw: anyhow, i've a module where i've tried to figure out which laws are needed to make an isomorphism between Arrow and (Category + Applicative)
12:46:57 <sinelaw> sounds useful
12:47:01 <sinelaw> such as in my case
12:47:36 <Saizan> sinelaw: i'm a CS undergrad, with ~3 years (i think?) of haskell experience
12:48:22 <sinelaw> your knowledge make it seems like a lot more.
12:48:24 <mjrosenb> bjrn: that most likely means that you are not identified.
12:48:26 <sinelaw> *makes
12:48:57 <bjrn> mjrosenb: Ah, right, thanks.
12:49:18 <Saizan> sinelaw: maybe that's why i'm still an undergrad :D
12:49:22 <companion_cube> what does "CS" mean ?
12:49:29 <medfly> computer science
12:49:35 * companion_cube stupid
12:49:43 <sinelaw> Saizan, what? :)
12:49:47 <medfly> it's just an acronym
12:51:21 <Saizan> sinelaw: i meant that i might have done too much haskell and too little of the rest, so i'm behind the regular schedule for completing my degree
12:51:43 <sinelaw> Saizan, how long have you been on it?
12:51:48 <mreh> Saizan: I don't know many undergrads who would take an interest in haskell
12:51:59 <sinelaw> mreh, this channel has more than a few
12:52:04 <sinelaw> including myself
12:52:14 <fax> mreh you are a postgrad?
12:52:24 <marcot> I'm also an undergrad
12:52:37 <opqdonut> most of the people interested in haskell I know are undergrads
12:52:41 <Saizan> sinelaw: this is my fifth year, and it should take 3
12:52:51 <mreh> fax: yes
12:52:57 <marcot> Saizan: In which country?
12:53:02 <sinelaw> Saizan, i convinced my prof. to let me do something about FRP as a final project for my degree, so for the first time i'm working on both :)
12:53:15 <sinelaw> before that iwas also procrastinating on the degree a lot
12:53:18 <Saizan> sinelaw: ah, nice :)
12:53:44 <sinelaw> which reminds me, i've a report to hand in tomorrow which i didn't start writing :( :_( :__(
12:53:46 <Saizan> marcot: italy
12:53:53 <opqdonut> I did my bachelor's thesis on functional data structures, and I'm doing my master's thesis on functional implementations of space-efficient data structures
12:54:03 <sinelaw> opqdonut, cool
12:54:06 <marcot> Saizan: Here in Brazil the graduation course is 4 yers.
12:54:18 <opqdonut> even though the only functional courses at our uni have been (co-)organized by me :)
12:54:21 <sinelaw> i'm doing EE, so it's 4
12:54:27 <Saizan> marcot: here it's splitted into 3 + 2
12:54:28 <mail> arrrrgh
12:54:39 <sinelaw> ....for undergrad
12:54:41 <opqdonut> 3+2 here too
12:54:43 <mail> god damn my editor wasn't using the correct EOL characters for linux
12:54:49 <mail> so ghci was fucking up
12:54:51 <mreh> my postgrad project involves clouds
12:54:51 <marcot> 2 is the masters degree?
12:54:52 <opqdonut> 3 for bachelor, 2 on top of that for master
12:54:55 <sinelaw> mail you mean linuxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
12:55:10 <Saizan> yeah
12:55:13 <opqdonut> mreh: the wet kind or the computationy kind?
12:55:20 <marcot> Here it's 4 + 2.. =(
12:55:22 <mreh> heh, the wet kind
12:55:28 <marcot> I wish it was 3 too.
12:55:29 <Saizan> hah :)
12:55:41 <opqdonut> i'dve guessed the latter
12:55:43 * hackagebot bsd-sysctl 1.0.6 - Access to the BSD sysctl(3) interface  http://hackage.haskell.org/package/bsd-sysctl-1.0.6 (MaximeHenrion)
12:55:43 <marcot> opqdonut: Where do you live?
12:55:46 <opqdonut> finland
12:55:54 <medfly> here it's not a fixed amount of years
12:55:56 <opqdonut> studying at helsinki university
12:55:58 <medfly> which I think is a lot more reasonable.
12:56:03 <marcot> opqdonut: nice.
12:56:16 <opqdonut> medfly: not fixed here either, but 3+2 is the target
12:56:17 <mreh> I'm using basic image features to extract features from images of cloud cover
12:56:25 <opqdonut> and there are some (mild) sanctions if you lag behind too much
12:56:28 <marcot> sinelaw: EE is Electric Engineering?
12:56:33 <sinelaw> marcot, yes
12:56:35 <opqdonut> (have to fill forms and make a study plan or something)
12:56:49 <marcot> sinelaw: Here it is 5 years, I belive.
12:56:52 <marcot> Or 5 and a half.
12:56:55 <Saizan> here if you lag behind too much you've to start over.
12:57:09 <sinelaw> marcot, 4 is undergrad. do you mean 5 for graduate?
12:57:18 <medfly> my sister is studying and it will be 2+2
12:57:20 <mreh> in the united kingdom you can have a postgraduate degree in 4
12:57:25 <marcot> No, 5 (+1/2) for undergrad.
12:57:29 <sinelaw> marcot, wow.
12:57:38 <marcot> Yes, I'm also impressed.
12:57:43 <opqdonut> marcot: where?
12:57:45 <sinelaw> why so long
12:57:45 <mreh> plus the undergrad
12:57:46 <marcot> Things here are very different.
12:57:49 <marcot> I have no idea.
12:57:52 <marcot> Brazil.
12:57:54 <sinelaw> weird
12:58:06 <sinelaw> here you can get a graduate in EE in 4+2
12:58:06 <marcot> How much of the students get a masters degree?
12:58:10 <medfly> I am studying and just the undergraduate thing (engineering) is 4 years.
12:58:15 <sinelaw> marcot, not too many in my place
12:58:19 <sinelaw> most don't
12:58:29 <marcot> sinelaw: So much of them just stay for the 4 yers?
12:58:29 <medfly> don't a lot of people drop out pretty early and such
12:58:32 <marcot> years
12:58:41 <medfly> especially at EE
12:58:47 <opqdonut> here it used to be that we only had a (5 year) master's degree
12:58:50 <sinelaw> marcot, yes, though many need 4.5 to finish it
12:58:53 <sinelaw> and some 5
12:58:54 <opqdonut> the bachelor is a recent change
12:58:56 <jberryman> what happened to hpaste?
12:59:01 <marcot> ok.. this is strange.
12:59:07 <mreh> @paste
12:59:07 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:59:12 <jberryman> thx
12:59:24 <mreh> the mirror is more reliable
12:59:24 <jberryman> 16:02 [ dleslie         ] [ kisvoros       ] [ preflex        ] [ ziman           ]
12:59:34 <sinelaw> marcot, it's not such an easy program, though i don't have much to compare with
12:59:42 <sinelaw> that's why people end up doing it in 4.5
12:59:44 <Kruppe> can someone explain to me why the memoized_fib on http://www.haskell.org/haskellwiki/Memoization actually works? It seems like it would be making a new list each call of memoized_fib but i guess that's not whats happening?
12:59:55 <sinelaw> marcot, though not me :) unless i flunk something this, my last semester
12:59:57 <marcot> sinelaw: Here people don't usually finish in time too.
13:00:07 <mreh> Kruppe: it uses graph reduction
13:00:19 <sinelaw> i'm substituting quality for speed :)
13:00:31 <marcot> sinelaw: Although you can always finish even earlier if you're really interested in graduating fast.
13:00:42 <sinelaw> yes i could have finished even faster if i wanted
13:00:50 <sinelaw> but that would mean actually studying
13:00:54 <mreh> under such a system each argument is evaluated a maximum of one times
13:01:02 <sinelaw> marcot, which i sort of glossed over in most courses
13:01:04 <Kruppe> mreh: hello mreh, I found a wikibook entry for that, I'll check it out
13:01:22 <mreh> Kruppe: I more or less paraphrasing from that :)
13:01:30 <Kruppe> mreh: oh :P
13:01:50 <sinelaw> we should have a "haskell-loving undergrads" group
13:02:10 <mreh> is anyone making games in haskell?
13:02:13 <mreh> I want in
13:02:13 <marcot> http://www.eletrica.eng.ufmg.br/html/Arquivos/Matriz_Curricular_Eng_Eletrica_20101.pdf (In portuguese)
13:02:24 <marcot> If anyone is interested in the 5 years curriculum.
13:02:46 <Saizan> mreh: luqui does, then there are the iphone guys, ..
13:03:14 <marcot> http://www.dcc.ufmg.br/dcc/images/arquivos/gradebcc2.pdf
13:03:28 <marcot> And the 4 years CS course.
13:03:34 <marcot> Which I do.
13:03:54 <mreh> what's C# like, I think I have a job offer
13:04:15 <sinelaw> mreh, death.
13:04:16 <mreh> Saizan: oh, yes, I've spoken to him
13:04:30 <sinelaw> mreh, i've just started working in it, and after Haskell everything seems like Deat.
13:04:32 <sinelaw> h
13:04:49 <mreh> sinelaw: good-oh I'll stay away from that one then
13:04:54 <sinelaw> mreh, wait
13:05:05 <sinelaw> mreh, actually it's ok, in the realm of non-haskell languages i think
13:05:08 <medfly> marcot, I'm sure we all know portugese, that's why we're so familiar with brazil
13:05:31 <mreh> it's going to be another graduate level job, but soon I'll be a post graduate!
13:05:31 <sinelaw> mreh, unless you can find a job in haskell
13:05:41 * maskd knows portuguese
13:05:44 <mreh> sinelaw: many of those going around? :)
13:05:48 <mreh> I don't think so
13:05:54 <sinelaw> mreh, in portland
13:05:54 <Blasa> mreh: Do they want C# or a .net language?
13:06:26 <marcot> medfly: I don't understand your point.  Did my link bothered you?
13:06:29 <mreh> sinelaw: I don't want to move to Oregon :(
13:06:44 <sinelaw> mreh, if i lived in the US i would seriously consider it
13:07:06 <sepp2k> If I try to do  instance Num (forall a. (a -> a) -> a -> a)  I get an error "Illegal polymorphic or qualified type: forall a. (a -> a) -> a -> a  In the instance declaration for `Num (forall a. (a -> a) -> a -> a)'". What exactly does that error mean? Can I work around it without wrapping the whole thing in a newtype?
13:07:06 <mreh> Blasa: C# as far as I am aware
13:07:20 <twink> mreh: Portland OR is climatic paradise.
13:07:21 <medfly> mreh, it's a job. stop being spoiled and take it regardless. are you that attractive you can just get another one?
13:07:22 <mreh> i think they may have pattern matched on the "haskell" I wrote on ym CV
13:07:32 <fax> sepp2k what if you just don't put 'forall a.'?
13:07:37 <monadic_kid> mreh: C# is a better Java, more like C++.
13:07:47 <mreh> medfly: I live in england
13:08:07 <mreh> or are we talking about C#?
13:08:39 <jberryman> I'm trying to use HGL and not sure how to use Regions. The following example doesn't show anything but a black window: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8543#a8543
13:09:30 <mreh> jberryman, "tesreg" is not in scope
13:09:51 <monadic_kid> is this function possible: findA :: (Foldable f, Applicative f) => (a -> f Bool) -> t a -> f (Maybe a)
13:10:16 <aavogt> @type Data.Foldable.find
13:10:17 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> Bool) -> t a -> Maybe a
13:10:27 <monadic_kid> aavogt: thats not what I want
13:10:40 <monadic_kid> aavogt: predicate returns an applicative
13:11:01 <sinelaw> Saizan, first = (*** id), second = (id ***)
13:11:02 <sinelaw> also
13:11:14 <Saizan> yeah
13:11:35 <sinelaw> Saizan, in my case it's simpler to implement *** that's why
13:12:01 <aavogt> @type find snd . Data.Traversable.traverse (\x -> (,) x <$> ?p x) . Data.Foldable.toList
13:12:02 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(a, a1)'
13:12:02 <lambdabot>     In the first argument of `(<$>)', namely `(,) x'
13:12:02 <lambdabot>     In the expression: (,) x <$> ?p x
13:12:24 <aavogt> @type fmap (find snd) . Data.Traversable.traverse (\x -> (,) x <$> ?p x) . Data.Foldable.toList
13:12:25 <lambdabot> forall (f :: * -> *) a (t :: * -> *). (Applicative f, ?p::a -> f Bool, Data.Foldable.Foldable t) => t a -> f (Maybe (a, Bool))
13:12:29 <jberryman> mreh: sorry, that should be testRegion
13:12:46 <aavogt> but this runs the predicate for all elements of the list
13:13:22 <monadic_kid> what's the "?"?
13:13:28 <sepp2k> fax: Then I can't apply the function to arbitrary types.
13:13:38 <aavogt> monadic_kid: Applicative isn't expressive enough to choose to do side effects based on the result of another action
13:14:02 <jberryman> mreh: fixed now
13:14:06 <aavogt> monadic_kid: it's an implicit parameter which is easier here than writing   \p ->  ... p ...
13:14:06 <monadic_kid> aavogt: i didn't think so, anway what is with the "?"
13:14:17 <mreh> jberryman: does it work?
13:15:45 <monadic_kid> ?p == \p -> p ?
13:15:45 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
13:15:45 <lambdabot> v
13:16:10 <jberryman> mreh: no, I meant I fixed up my paste: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8543#a8543
13:16:15 <Kruppe> mreh: I don't understand why slow_fib won't work with graph reduction, maybe I'm missing something?
13:16:17 <aavogt> > let ?x = (+1) in ?x 2
13:16:18 <lambdabot>   3
13:16:39 <dark> > ?x
13:16:40 <lambdabot>   Unbound implicit parameter (?x::a)
13:16:40 <lambdabot>    arising from a use of implicit parame...
13:17:38 <aavogt> monadic_kid: well you have to bind implicit parameters with a let...
13:18:30 <sepp2k> fax: I want to do this without the newtype: http://codepad.org/pDMNx9zK
13:18:52 <sinelaw> Alpounet, do you think it's worth separating out the Processor module and hackaging it separately?
13:19:21 <aavogt> basically they aren't commonly used, probably part of it is that they appear in the type signature, and there is no easy way to indicate a partial type signature
13:19:59 <mreh> jberryman: do you see the window?
13:20:09 <aavogt> so you're either left with none, or you have the trouble of writing which implicit parameters you use (which defeats the purpose)
13:20:31 <aavogt> also, see the ghc manual for a scary case where they aren't very predictable
13:20:33 <monadic_kid> aavogt: is that haskell98 or extension?
13:21:18 <Alpounet> sinelaw, I think the abstraction inherent to your Processor module is worth packaging separately
13:21:25 <Alpounet> it's quite general purpose on its own I mean
13:21:27 <Alpounet> don't you think so ?
13:22:50 <aavogt> monadic_kid: extension, though it is pretty old and implemented in hugs (and maybe other compilers too)
13:23:24 <monadic_kid> k
13:23:45 <fax> sepp2k, yeah, typeclasses just aren't expressive enough to do this
13:24:21 <sepp2k> ok, thanks
13:26:06 <jberryman> mreh: yes, a black window. There should be a white square in it though. At least I think there should be
13:26:24 <mreh> that's what I think too
13:26:31 <mreh> are you on win32?
13:26:46 <mreh> jberryman ^^
13:27:58 <jberryman> mreh: no, Debian linux
13:33:13 <Blasa> Alpounet or Sinelaw: I'm curious about this Processor module. Any links?
13:33:17 <Mathnerd314> so how do you define a recursive type? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8545
13:33:33 <fax> Mathnerd314: it's not allowed
13:33:59 <Mathnerd314> but data = works...
13:34:23 <fax> type ... = ... can't be recursive
13:34:48 <int-e> yes, or a newtype: newtype ZipList a = ZipList { unZipList :: Cons (Maybe a) (ZipList a) }
13:34:50 * fax is not sure if this a fundamental thing, or just a design choice
13:35:04 <copumpkin> you can't newtype it
13:35:08 <fax> I mean ocaml has -rectypes, haskell could too?
13:35:09 <copumpkin> oh yes you can
13:35:13 <copumpkin> if you refer to Cons
13:36:24 <copumpkin> fax: they're usually a mistake though... I'd like an isotype type synonym that allows it though
13:36:32 <fax> yeah that's pragmatics
13:36:33 <copumpkin> isotype Fix f = f (Fix f)
13:36:41 <xerox> channel, do you happen to know the Date/Time stuff well enough to wrap up a line of code that subtracts 42:00 from timestamps of the form hh:mm:ss ?
13:36:44 <int-e> it probably could. I believe the question is, which is more useful: having recursive types or catching a whole class of programming errors early on.
13:36:56 <copumpkin> int-e: why not try to do both and separate them with a new keyword?
13:37:11 <copumpkin> it might be hard to keep the interaction clean
13:37:19 <ddarius> type is supposed to just be a textual shortcut.  From that perspective, being recursive corresponds to infinite rewriting.
13:37:20 <copumpkin> but it'd be awesome if it could be done
13:37:34 * fax doesn't have a problem with infinite rewriting
13:37:40 <int-e> (and the newtype workaround is clumsy but works, so the need is not that bad - in my opinion)
13:37:53 <ddarius> The compiler does.
13:38:05 <copumpkin> int-e: it could make experimenting with all the *morphisms more pleasant and actually practical
13:38:20 <copumpkin> having to take the In constructor apart all the time makes working with fixed points a real pain
13:38:26 <monochrom> "type" is compile-time textual shortcut, not runtime textual shortcut.
13:39:49 <copumpkin> "it'd be nice if X were defined to be B, not A"
13:39:53 <copumpkin> "X is A."
13:40:11 <Mathnerd314> so create Y that is B
13:40:18 <monochrom> It is cheap cheesy armchair thinking to just say "why not generalize everything, I don't have a problem generalizing everything".
13:40:41 <copumpkin> monochrom: I'm saying keep it separate
13:40:57 <monochrom> Don't worry I don't mean you.
13:40:59 <copumpkin> and that it could be an interesting experiment
13:41:05 <copumpkin> ah
13:41:39 <monochrom> I mean certain naive, overly math-inclined, never-wrote-a-compiler freethinkers.
13:41:42 <ddarius> copumpkin: I was explaining why type is the way it is.
13:41:59 <copumpkin> ddarius: yeah, I understand why it is
13:42:04 <yitz> copumpkin: could you simulate it with TH to try it and play around with it?
13:42:34 <copumpkin> yitz: I'm not sure I could, unless I wrote an automatic newtype wrapper/unwrapper with a haskell parser in a QQ or something
13:43:03 <ddarius> copumpkin: Just comment out the occurs check in GHC.
13:43:15 <copumpkin> would it really be that simple?
13:43:28 <fax> lolol
13:43:29 <copumpkin> if so, I might just try hacking in the extra keyword I mentioned and play with that
13:43:48 <yitz> copumpkin: i'm wondering whether if you do this, you'd end up with m4 as your type system.
13:43:50 <copumpkin> (/me honestly has no clue about the complexity about this stuff, so lol away if it's ridiculous)
13:44:05 <fax> lol
13:44:08 <copumpkin> :)
13:44:11 <fax> editing GHC is impossible
13:44:25 <ddarius> Commenting out the occurs check would change the type system everywhere.
13:44:26 <copumpkin> I've edited parts of it
13:44:29 <copumpkin> but not that part
13:45:11 * ddarius has edited parts of GHC, but those changes are probably gone now.
13:45:20 <pokoko222> I need recomendation on book for matrix algorithms please
13:45:32 <copumpkin> pokoko222: why are you even implementing matrix algorithms?
13:45:42 <copumpkin> no matter what you write, it's been done, and faster
13:46:16 <copumpkin> unless you're talking about re-parenthesizing large matrix multiplication chains :P
13:46:24 <fax> "You are not a unique snowflake"
13:46:26 * copumpkin reminisces about his algorithms cours
13:46:27 <copumpkin> e
13:46:37 <monochrom> You haven't even taken a linear algebra course. Yes this is a polite and justified way to say "go away".
13:46:42 <copumpkin> lol
13:46:57 <pokoko222> i am talking about a student doing "something" for the sake of practice and experience, and that something seems matrix algorithms, while watching MIT courseware
13:47:09 <fax> monochrom, I wouldn't recommend linear algebra to him.. but that's because I'm bitter and spiteful
13:47:25 <pokoko222> monochrom not really, i have done graphics before from application level and read back then on engines and stuff, far from noob
13:47:30 <copumpkin> pokoko222: what are you looking for? things like the sub-cubic multiplication algorithms?
13:48:03 <pokoko222> starting from simple things to anything really, i am checking this now: G. W. Stewart “Matrix Algorithms Volume I: Basic Decompositions"
13:48:13 <copumpkin> well, do you even know what the algorithms are doing?
13:48:19 <copumpkin> if we talk about LU decomposition or SVD
13:48:51 <monochrom> I have done both graphics and matrix algorithms. I tell you their overlap is slim. You need linear algebra. And this is necessary not sufficient.
13:48:54 <pokoko222> i have forgotten but i can get those things quickly, so ... hmm the books seem right, 5 volume set cool
13:49:13 <copumpkin> I loved linear algebra, but didn't take the rote computation version that was offered
13:49:20 <ddarius> pokoko222: Learn Geometric Algebra instead.
13:49:35 <copumpkin> 5 volume set = you get to feel like you have a lot of knowledge in a book, but you'll never read it all unless you're a researcher in that field
13:49:35 * fax hates hates hates 'learn maths by computation/solving problems'
13:49:44 <lowasser> ditto that
13:49:59 * fax comes frm the future where computers exist..
13:50:04 <copumpkin> fax: I agree... well solving problems is fine if it's interesting, but "compute the inverse of this 4x4 matrix and show all steps" is ridiculous
13:50:23 <copumpkin> I took the proofy version of linear algebra and that was a lot more fun
13:50:32 <lowasser> proofy linalg is lovely
13:51:06 <pokoko222> proofy linalg? there were more linear algebras in your college?
13:51:17 <fax> matrices are like such an unimportant part of linear algebra
13:51:20 <pokoko222> i got one next year, and it will be enough :P
13:51:21 <copumpkin> pokoko222: in mine there was an honors and non-honors one
13:51:40 <lowasser> ehehehe, I'm still in college
13:51:48 <copumpkin> and the honors one talked about algebraic structures and vectors as elements of vector fields... the other people got R^n and matrices
13:51:55 <pokoko222> me too first year, ok i am back to reading, tnx guys
13:54:50 <Mathnerd314> anyways, "newtype ZipList a = ZipList { unZipList :: Cons (Maybe a) (ZipList a) a}" seems to generate kind errors
13:55:10 <copumpkin> yep, you passed three parameters to Cons
13:55:36 <Mathnerd314> oh.
13:55:41 <Mathnerd314> yeah, that works.
13:55:45 <copumpkin> if your Cons is just Cons a b, you might as well just use (a, b)
13:55:47 <copumpkin> by the way
13:56:07 <lowasser> indeeds
13:56:23 <lowasser> or, why use a newtype at all, if it's just going to be a tuple type?
13:56:29 <copumpkin> and a newtype around a (,) might as well just be Cons
13:56:30 <copumpkin> yeah
13:56:48 <Mathnerd314> wait, removing the "a" doesn't work
13:57:22 <Mathnerd314> Cons as a type takes 3 parameters, 2 monads and the type they're based on
13:57:29 <copumpkin> oh
13:57:43 <copumpkin> if they're two monads, then the monads are Maybe and ZipList a
13:57:45 <copumpkin> or ZipList actually
13:58:01 <copumpkin> unZipList :: Cons Maybe ZipList a
13:58:05 <aavogt> do you have gaps in your ZipList?
13:58:21 <aavogt> or is it all Justs then an infinite list of Nothings?
13:58:35 <aavogt> if it's the latter case, you can encode it a bit better than that
13:58:48 <Mathnerd314> gaps are usually missing, but I need them to make it a monad
13:59:21 <Mathnerd314> the structure isn't rich enough otherwise
13:59:53 <Mathnerd314> (as per http://www.mail-archive.com/haskell-cafe@haskell.org/msg57217.html)
14:00:21 <copumpkin> omg with Maybes in the ZipList, you have no proof that you'll ever get another element!
14:00:56 <Mathnerd314> I will get another element. The maybe is on the left
14:01:10 <Alpounet> Blasa, see sinelaw's github
14:01:24 <Alpounet> it's part of his cv-combinators project for the moment
14:02:55 <aavogt> @faq can cv-combinators help me write a resume?
14:02:56 <lambdabot> The answer is: Yes! Haskell can do that.
14:03:20 <Blasa> Thanks alpounet
14:03:25 <dons> there appear  to be more libraries for haskell than erlang. i'm glad.
14:03:42 <dons> but it's close. 1908 on hackage, vs 1420 on the erlang trapexit site.
14:03:48 <drk-sd> hmmm
14:04:11 <drk-sd> are you sure trapexit lists all erlang related libs ?
14:04:24 <dons> that's what the erlang.org site says to go to.
14:04:32 <drk-sd> yeah sure, but hum
14:04:39 <drk-sd> (wait)
14:04:39 <dons> unless you know of somewhere else they host stuff?
14:04:43 <dons> it's somewhat hard to find.
14:05:02 <drk-sd> i think there was some site i went a few months ago
14:05:06 <dons> "We crawl the web for you, gathering searchable information on all open source Erlang projects from all the major repositories."
14:05:13 <dons> so its not even central -- they scrape.
14:05:16 <copumpkin> we also have a bunch of libs that aren't hackaged
14:05:20 <dons> http://projects.trapexit.org/web/
14:05:23 <copumpkin> so it's probably a little more on both sides
14:05:27 <dons> copumpkin: indeed. a lot on github.
14:05:43 <dons> 821 repos on github
14:05:49 <copumpkin> and random old bitrotted projects :)
14:05:56 <copumpkin> on personal sites etc.
14:05:58 <drk-sd> dons: http://cean.process-one.net/ there it is
14:06:16 <dons> ah, so that's more like hackage.
14:06:21 <dons> but much smaller so far. makes sense.
14:06:25 <drk-sd> yep
14:06:33 <dons> trapexit is trying to scrape it from all the sites, cean is centralized.
14:06:59 <dons> so i think the conclusions are valid.
14:07:13 <Alpounet> aavogt, sure it can
14:07:20 <Alpounet> now spend 10 hours figuring out how
14:07:26 <Alpounet> then generate a resume with it
14:07:36 <dons> 341 on code.haskell.org
14:07:46 <dons> so let's say, 2x Hackage?
14:08:03 <drk-sd> that's funny dons
14:08:13 <drk-sd> nitrogenproject is listed neither on trapexit, nor on cean
14:08:14 <drk-sd> :D
14:08:29 <dons> you gotta centralize infrastructure if you want the community to work efficiently
14:09:32 <aavogt> dons: is the packaging (if it exists) for trapexit as limited as Cabal in that it forces single projects to upload say, 5 packages when there is logically only one codebase?
14:09:35 <drk-sd> hum, forget what i said
14:09:40 <drk-sd> nitrogen is on trapexit.
14:09:49 <dons> aavogt: i don't think trapexit has a common build system
14:09:56 <drk-sd> (haha, my fork is on the list :-°)
14:10:21 <aavogt> ok, then the hackage number is somewhat inflated
14:11:03 <Alpounet> copumpkin, are you gonna do something with vector-static ?
14:11:09 <copumpkin> Alpounet: nope
14:11:16 <copumpkin> I gave it to jmcarthur
14:11:30 <Alpounet> heh ok
14:11:33 <copumpkin> I think it's fairly hopeless for its original purpose
14:11:43 <copumpkin> GHC isn't the right kind of language, but I'm writing another that is
14:11:43 <Alpounet> well
14:11:53 <Alpounet> technically, it's good
14:12:12 <Alpounet> but the usability is much less easy to offer, from such code
14:12:20 <aavogt> ie. something like hdbc is 5 packages because it's messy to have various configurations for the backends
14:12:29 <Alpounet> (I mean simulating dependent typing)
14:13:22 <aavogt> well, maybe hdbc is a bad example since some of the backends are third-party. haskelldb has it's backends all in one repo however
14:13:23 * fax wonder why people don't use ACTUAL dependent types?
14:13:54 <copumpkin> Alpounet: the problem is proving anything
14:14:00 <copumpkin> I tried writing some basic stuff using it
14:14:06 <copumpkin> and it really isn't usable
14:14:18 <copumpkin> which is why I'm building a (non-E)DSL for the same purpose :)
14:14:25 <Alpounet> oh ?
14:14:30 <Alpounet> is it on github ?
14:15:45 <copumpkin> Alpounet: yep, both Saizan and jmcarthur have forked it
14:15:54 <copumpkin> jmcarthur's version is the most recent one
14:16:27 <Alpounet> ok
14:16:29 <Alpounet> let me take a look
14:17:52 <Mathnerd314> ZipList is working pretty well now... but can I make a "RecursiveZipList" function that takes a list and converts it, and all sublists, to a ZipList?
14:17:58 <Alpounet> copumpkin, oh, I was actually asking whether your non-embedded dsl was on github
14:18:03 <notallama> hey guys. what library should i use to pull things from the interwebs? (specifically, i'm trying to iterate through http://limerickdb.com. i'm just going to use parsec on the html, but i need to get the html first)
14:18:07 <drk-sd> copumpkin: i'm curious, what's vector-static ? do you have a link for a presentation/introduction ?
14:18:25 <copumpkin> Alpounet: oh, not yet, I've only just started designing it :)
14:18:33 <copumpkin> drk-sd: almost no information on it, but it's up on hackage :)
14:18:36 <copumpkin> @hackage vector-static
14:18:37 <lambdabot> http://hackage.haskell.org/package/vector-static
14:18:55 <drk-sd> thx
14:19:01 <Alpounet> ok
14:20:45 <dons> notallama: the download-curl library is reasonable.
14:20:49 <dons> notallama: or tagsoup
14:21:01 <dons> http://hackage.haskell.org/package/download-curl
14:21:06 <dons>  doc  <- openURI "http://haskell.org"
14:21:07 <dons> easy.
14:27:13 <lazni> if I compile a haskell program with ghc 6.10.4 in arch, would it run okay on another machine with freeBSD 7.2?
14:27:23 <sinelaw> Alpounet, there's hmatrix-static
14:27:24 <lazni> assuming 32bit on both systems
14:27:32 <sinelaw> not that i have any idea if you need that sort of thing :)
14:28:07 <sinelaw> Blasa, btw, why are you interested in something like cv-combinators?
14:28:31 <Alpounet> heh ok
14:28:48 <Alpounet> Blasa, he rather seems interested by Processor itself
14:28:59 <sinelaw> ah what for?
14:29:05 <Alpounet> don't know
14:29:21 <Alpounet> sinelaw, I don't need it particularly, but I'm just interested in these vecor/matrix libraries for later purposes ;)
14:29:37 <sinelaw> ok :) any specific ideas?
14:29:57 <dons> lazni: probably not. all the system calls are different
14:30:54 <mail> gold @s1(x:xs) @s2(y:ys)
14:31:00 <mail> is that valid?
14:31:02 <mauke> no
14:31:10 <Blasa> I was interested in the Processor itself. I've had a look. Seems quite nice, to my inexperienced eyes.
14:31:26 <ivanm> lazni: I've taken a binary compiled on gentoo and taken it to a fedora machine; it failed because the version of gmp was different :s
14:31:27 <mauke> specifically, the )@ part looks like a syntax error
14:32:03 <Twey> Yep, it is
14:32:04 <ivanm> mail: "gold s1@(x:xs) s2@(y:ys)" is valid (if you were wanting @-patterns)
14:32:19 <mail> i was
14:32:23 <mail> but ghci is complaining
14:32:23 <sinelaw> Blasa, ok :) i've just added an Arrow instance too. not pushed yet
14:32:54 <ivanm> mail: as in you were typing that into ghci?
14:32:59 <mail> no
14:33:02 <mail> loading from file
14:33:03 <tsou> in LanguageDef of Text.ParserCombinators.Parsec.Token, what should I set opStart to, if the language does not support user-defined operators?
14:34:44 <Blasa> Sinelaw: I'm interested in proving qualities about virtual machines (in Coq, in about a million years when I have had enough time to learn everything I need to do so). So anything around that idea gets my interest.
14:35:32 <sinelaw> Blasa, wow. that seems a lot more interesting than Processor and somewhat unrelated.
14:38:00 <Blasa> Sinelaw: A VM is just a form of Processor, though, as you have defined it.
14:38:23 <sinelaw> Blasa, oh? in what sense
14:38:37 <sinelaw> i mean, everything imperative is a Processor, eventually
14:38:52 <sinelaw> but not neccesarily in a useful way
14:41:23 <Blasa> Sinelaw, well I found in interesting at the moment. Whether it will be useful in the long term I don't know. My desire to do things is far greater than my ability, currently.
14:41:41 <Blasa> *it
14:41:51 <sinelaw> good luck, that's exactly the way to go, if you ask me :)
14:42:15 <sinelaw> there's a saying, "if you you're not going up, you're going down."
14:42:31 <Twey> That sounds like a very American saying
14:42:48 <drk-sd> :D
14:42:58 <lowasser> is anyone super bored and/or would be interested in reading a monad.reader article draft?  (in addition to the n people who are already reading it)
14:43:02 <sinelaw> Twey, it's a Hassidic saying actually
14:43:15 <sinelaw> it's about spiritual level, not money :)
14:43:33 <lowasser> discussing priority queues, etc. in haskell
14:43:41 <Twey> sinelaw: Oh, okay then.  :þ
14:45:02 <mreh> rSwitch, drSwitch :: SF a b -> SF (a, Event (SF a b)) b -- can someone explain this type signature to me? there's no way of specifying the Event source
14:45:10 <mreh> the output is an event source
14:45:30 <mreh> or not
14:47:16 <sinelaw> mreh, SF a b , write as a ~> b
14:47:16 <sinelaw> then
14:47:43 <sinelaw> :: (a ~> b) -> (a, Event (a ~> b)) ~> b
14:47:48 <sinelaw> mreh, ^^^
14:48:11 <sinelaw> so the outputs SF takes a tuple as it's input type
14:48:20 <sinelaw> *output
14:48:37 <mreh> oooh
14:48:41 <mreh> smart
14:48:54 <sinelaw> @type (a ~> b)
14:48:55 <lambdabot> Not in scope: `~>'
14:49:19 <sinelaw> mreh, a ~> b is often used as notation for Arrow r => r a b
14:50:13 <sinelaw> which SF happens to be, but it's not neccesarry to actually be an Arrow instance we can still take advantage of the notation for documentation purposes
14:50:20 <Alpounet> lowasser, I would
14:50:49 <sinelaw> @hoogle (a -> b) -> ((a,a) -> b)
14:50:50 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
14:50:58 <sinelaw> @hoogle (a -> b) -> (a -> (b,b))
14:50:58 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
14:50:58 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
14:50:59 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
14:51:14 <sinelaw> @pl (\a -> (a,a))
14:51:14 <lambdabot> join (,)
14:51:22 <sinelaw> @type join
14:51:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:51:30 <sinelaw> moo.
14:51:38 <sinelaw> @hoogle split
14:51:38 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
14:51:39 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
14:51:39 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
14:51:53 <Alpounet> @type (&&&)
14:51:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:51:58 <mauke> @hackage split
14:51:58 <lambdabot> http://hackage.haskell.org/package/split
14:51:59 <lowasser> @Alpounet give me just a mo'
14:51:59 <lambdabot> Unknown command, try @list
14:52:06 <lowasser> oopsies
14:52:06 <Alpounet> sure
14:52:39 <sinelaw> Alpounet, i want something like join (,) on Arrows. but i can just implement it easily enough.
14:53:09 <Alpounet> @type liftA
14:53:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
14:53:12 <sinelaw> split = (join (,) <$>)
14:53:13 <Alpounet> hmm
14:53:16 <sinelaw> or liftA
14:53:29 <sinelaw> wait no
14:53:29 <Alpounet> yeah should be fine
14:53:36 <Alpounet> actually
14:53:47 <Alpounet> how are you supposed to get the two a's on the right hand side ?
14:54:37 <sinelaw> yes i think that will work.
14:54:51 <sinelaw> @type liftA . join (,)
14:54:52 <lambdabot>     Couldn't match expected type `a -> b'
14:54:52 <lambdabot>            against inferred type `(a1, a1)'
14:54:52 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
14:55:55 <sinelaw> @type (join (,) <$>)
14:55:56 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
14:56:21 <aavogt> @type (id &&& id)
14:56:22 <lambdabot> forall b. b -> (b, b)
14:56:41 <lowasser> /privmsg Alpounet http://docs.google.com/fileview?id=0B2uaUF8ZNTNDNTVlODkyZTktOTk5NC00ZjBkLTk0YmQtMGU0OGMxMjMxMTBi&hl=en
14:56:55 <Alpounet> heh
14:56:58 <lowasser> whoops
14:57:05 <lowasser> ...heh.  ah well.
14:57:23 <lowasser> irc fail
14:57:29 <drk-sd> :D
14:57:54 <lowasser> I mean, not that I *mind* lots of people reading it
14:58:08 <lowasser> since lots of people will eventually anyway
14:58:35 <lowasser> and hopefully lots of people will end up using its goodies!
14:59:01 <sinelaw> @hoogle (Functor f) => f a -> f (a, a)
14:59:01 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
14:59:02 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
14:59:02 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:59:33 <aavogt> > map (flip splitAt "lowasser") [2,3]
14:59:34 <lambdabot>   [("lo","wasser"),("low","asser")]
14:59:54 <lowasser> ...lol?
15:00:21 <aavogt> yeah, I assumed the latter when it's actually the former
15:03:00 <aavogt> I wonder if kind annotations would be helpful on the first page, lowasser
15:03:36 <lowasser> yah, the thought occurred to me, I'm just a bit worried that it would prompt inexperienced readers to run away screaming
15:03:37 <aavogt> which would be more concise than calling q a type constructor
15:03:53 <lowasser> I could probably write it in a friendly way somehow, I just need to think about it
15:04:54 <aavogt> as in put the whole class declaration in a single listing?
15:05:02 <lowasser> hmmm
15:05:15 <lowasser> maybe that would be more readable
15:07:54 <Alpounet> yeah
15:08:07 <Alpounet> generally classes are given in a single listing
15:09:10 <lowasser> amended: http://docs.google.com/fileview?id=0B2uaUF8ZNTNDMjZiYTU1ZDktNzZmMS00OWZhLTk2ZjctYjk4MjFmNGNjYWM4&hl=en
15:13:06 <sinelaw> @hoogle (--<)
15:13:06 <lambdabot> No results found
15:14:10 <alise_> Can you implement ++ with just fold f = foldr f []?
15:14:24 <alise_> With plain foldr it's easy -
15:14:35 <alise_> foldr (\xs ys -> foldr (:) ys xs) [] [x,y]
15:14:44 <aavogt> @src (++)
15:14:45 <lambdabot> []     ++ ys = ys
15:14:45 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:14:45 <lambdabot> -- OR
15:14:45 <lambdabot> xs ++ ys = foldr (:) ys xs
15:14:46 <alise_> Well, not "just".
15:14:51 <sinelaw> f --< g = split f >>> g
15:14:53 <sinelaw> Alpounet, ^^^
15:14:55 <alise_> But without using actually ++
15:14:59 <sinelaw> how about that
15:15:18 <alise_> aavogt: that uses foldr
15:15:22 <alise_> not fold f = foldr f [] :)
15:15:46 <Alpounet> that's nice sinelaw
15:15:50 <aavogt> yes, I'm suggesting a more direct way to write (++) rather than nesting the foldrs
15:16:02 <alise_> aavogt: I did it that way for a reason
15:16:21 <alise_> specifically, I'm helping someone else with a perverse esoteric language; and it only has cons and foldl, but I'm trying to make it work with foldr
15:16:24 <sinelaw> @type ((join (,) <$>) >>>)
15:16:25 <lambdabot> forall a (f :: * -> *) c. (Functor f) => (f (a, a) -> c) -> f a -> c
15:16:35 <alise_> Thanks, anyway.
15:16:38 <sinelaw> err
15:16:52 <sinelaw> @type (\a -> ((join (,) <$> a) >>>)
15:16:53 <lambdabot> parse error (possibly incorrect indentation)
15:17:00 <sinelaw> @type (\a -> (join (,) <$> a) >>>)
15:17:01 <lambdabot> parse error on input `)'
15:17:04 <sinelaw> @type (\a -> (join (,) <$> a) >>>))
15:17:05 <lambdabot> parse error on input `)'
15:17:08 <sinelaw> pm :)
15:17:22 <Alpounet> @type (>>>) (join (,) <$>)
15:17:23 <lambdabot> forall a (f :: * -> *) c. (Functor f) => (f (a, a) -> c) -> f a -> c
15:17:25 <Alpounet> ha
15:17:36 <sinelaw> opposite side
15:17:40 <Alpounet> yeah
15:17:42 <Alpounet> got that :p
15:18:12 <Alpounet> ((join (,) <$>) <<<)
15:18:18 <Alpounet> @type ((join (,) <$>) >>>)
15:18:19 <lambdabot> forall a (f :: * -> *) c. (Functor f) => (f (a, a) -> c) -> f a -> c
15:18:29 <Alpounet> damn
15:18:32 <sinelaw> heh
15:18:32 <Alpounet> @type ((join (,) <$>) <<<)
15:18:33 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> a1 -> f (a, a)
15:18:37 <sinelaw> @type (\a b -> ((join (,) <$>) a) >>> b)
15:18:38 <lambdabot> forall a (cat :: * -> * -> *) a1 c. (Functor (cat a1), Control.Category.Category cat) => cat a1 a -> cat (a, a) c -> cat a1 c
15:18:41 <aavogt> alise_: can you write reverse with foldl, then do a left fold (which is a right fold on the original), and then reverse again if you produced a list?
15:18:55 <Alpounet> sinelaw, isn't the last thing I wrote what you want ?
15:19:11 <aavogt> as in can you flip the arguments to cons?
15:19:18 <Desustorm> hey guys can you help me fix a really odd bug in my code?
15:19:18 <sinelaw> err
15:19:27 <lowasser> desu: hit me
15:19:35 <Desustorm> http://pastebin.com/tQjKghxy
15:19:53 <Desustorm> the random number seed affects the number of elements in my list >.>
15:20:03 <sinelaw> Alpounet, what's that (a1 -> f a)
15:20:08 <lowasser> ow
15:20:14 <alise_> aavogt: Suppose you can?
15:20:23 <lowasser> holdup, let me parse this shuffle implementation
15:20:39 <Desustorm> =)
15:20:57 <lowasser> also, I think terribly inefficient >.<
15:20:57 <lowasser> hmm
15:21:02 <Desustorm> yes
15:21:08 <Desustorm> undoubtedly
15:21:12 <Alpounet> sinelaw, hmm
15:21:13 <Alpounet> good question
15:21:16 <Alpounet> you don't need it
15:22:13 <sinelaw> @let split = (join (,) <$>)
15:22:14 <lambdabot>  Defined.
15:22:19 <sinelaw> @type split
15:22:20 <lambdabot>     Ambiguous occurrence `split'
15:22:20 <lambdabot>     It could refer to either `L.split', defined at <local>:1:0
15:22:20 <lambdabot>                           or `System.Random.split', imported from System.Random
15:22:24 <sinelaw> @type L.split
15:22:25 <lambdabot> forall (f :: * -> *) a. (Functor f) => f a -> f (a, a)
15:22:41 <sinelaw> @type (\f g -> L.split f >>> g)
15:22:43 <lambdabot> forall (cat :: * -> * -> *) a a1 c. (Functor (cat a), Control.Category.Category cat) => cat a a1 -> cat (a1, a1) c -> cat a c
15:22:47 <sinelaw> weird.
15:22:54 <lowasser> Desu: would you mind using a monad?
15:23:06 <Desustorm> if you tell me how x)
15:23:09 <lowasser> it'll help, but it's not strictly necessary
15:23:09 <lowasser> hehehe
15:23:12 <Alpounet> > L.split (Just 4)
15:23:13 <lambdabot>   Just (4,4)
15:23:18 <lowasser> @hackage MonadRandom
15:23:18 <lambdabot> http://hackage.haskell.org/package/MonadRandom
15:23:19 <sinelaw> actually that's ok
15:23:20 <Desustorm> shuffle :: Int->[a]->[a] has to stay the same
15:23:22 <sinelaw> the last one i wrote there
15:23:23 <lowasser> of course
15:23:29 <lowasser> but you'll want the package I just linked to
15:23:30 <sinelaw> so it IS split f >>> g
15:23:35 <dabblego> @src L.split
15:23:35 <lambdabot> Source not found. stty: unknown mode: doofus
15:23:49 <sinelaw> @undef split
15:23:53 <sinelaw> @src split
15:23:53 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:23:56 <sinelaw> @type split
15:23:57 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:24:01 <sinelaw> ok back to normal.
15:24:01 <Desustorm> lowasser, how can i check if my university machine has it?
15:24:11 <Desustorm> ie going on PuTTY and checking
15:24:14 <sinelaw> dabblego, my definition was split = (join (,) <$>)
15:24:16 <lowasser> go to ghci and try :module + Control.Monad.Random
15:24:54 <lowasser> if that doesn't work, let me know if :module + Control.Monad.State works
15:25:02 <dabblego> sinelaw, ok ta
15:25:17 <Desustorm> Prelude> :module + Control.Monad.Random
15:25:17 <Desustorm> Could not find module `Control.Monad.Random':
15:25:17 <Desustorm>   Use -v to see a list of the files searched for.
15:25:17 <Desustorm> Prelude> :module + Control.Monad.State
15:25:17 <Desustorm> Prelude>
15:25:19 <Desustorm> oops :<
15:25:36 <lowasser> wait, did the second one work, or not?
15:25:37 <Desustorm> im guessing that counts as working? [sorry for spam]
15:25:40 <lowasser> okay
15:25:46 <lowasser> we can work with this
15:26:55 <Desustorm> i'm trying to make it so that it chooses a random item to swap with
15:26:57 <aavogt> > let xs ++ ys = let f = foldl (flip (:)) in f (f [] xs) (f [] ys) in "abc " ++ "alise_"
15:26:58 <lambdabot>   "alise_ cba"
15:27:08 <Desustorm> supposed to be O(n) but my programming is terrible
15:27:29 <Axman6> Desustorm: System.Random?
15:27:39 <aavogt> > let xs ++ ys = let f = foldl (flip (:)) in f ys (f [] xs) in "abc " ++ " def"
15:27:40 <lambdabot>   "abc  def"
15:27:44 <Desustorm> i have it working..kinda
15:27:56 <Desustorm> but it has a very strange bug and it's rather inefficient
15:27:57 <alise_> aavogt: why thanketh you!
15:28:04 <alise_> aavogt: but we need foldr.
15:28:07 <alise_> not foldl :)
15:28:44 <alise_> already did it in foldl... I think it may be impossible with \f -> foldr f []
15:29:15 <Desustorm> lowasser, full program is http://pastebin.com/SEWpg78N
15:29:21 <aavogt> alise_: well you can write the real foldr in terms of foldl (for finite lists) though...
15:29:22 <Desustorm> module*
15:29:30 <lowasser> almost done
15:30:05 <monochrom> Desustorm: I wonder what swapr does. In particular, why swapr ([1,2,3], []) = [].
15:30:24 <alise_> aavogt: yes but infinite lists
15:30:30 <aavogt> > let foldr f x xs = foldl (flip f) x (foldl (flip (:) xs)) in (foldr (/) 4 [1,2,3],Prelude.foldr (/) 4 [1,2,3])
15:30:31 <lambdabot>   Couldn't match expected type `b -> a' against inferred type `[a]'
15:30:32 <alise_> besides it's an esoteric language, who needs practicality :)
15:30:34 <sinelaw> Alpounet, btw, --< is invalid syntax
15:30:35 <sinelaw> :)
15:30:38 <sinelaw> changed it to -<
15:30:59 <Desustorm> monochrom, because I am terrible at haskell/tired? :p
15:31:01 <aavogt> alise_: well foldl doesn't work for infinite lists
15:31:10 <sinelaw> ...which is also invalid syntax??
15:31:15 <alise_> which is why we want foldr aavogt :P
15:31:23 <sinelaw> @let split' = (join (,) <$>)
15:31:24 <lowasser> Desu: check it out
15:31:24 <lambdabot>  Defined.
15:31:27 <Alpounet> sinelaw, isn't that used in Arrows ?
15:31:32 <monochrom> I guess that explains why you don't get back all cards after shuffle.
15:31:36 <sinelaw> @hoogle (-<)
15:31:36 <lambdabot> No results found
15:31:46 <Alpounet> hm
15:31:51 <lowasser> I submitted corrections to the first link you sent
15:31:56 <sinelaw> @let f -< g = split' f >>> g
15:31:57 <lambdabot>  Defined.
15:32:00 <aavogt> well unless you do some side effects, foldl isn't going to get you anything on infinite lists
15:32:03 <sinelaw> weird. i have some other problem.
15:32:08 <sinelaw> --< should also be find.
15:32:09 <sinelaw> *fine
15:32:13 <alise_> aavogt: Which is why we're redefining the language /with foldr/
15:32:28 <aavogt> that sounds more useful ;)
15:32:54 <Alpounet> sinelaw, http://en.wikibooks.org/wiki/Haskell/Arrows
15:33:09 <Alpounet> but yeah --< shoud le fine
15:33:12 <Alpounet> ~< ? :D
15:33:33 <alise_> aavogt: which is why we need ++ with foldr
15:33:36 <sinelaw> --< is three chars. like >>>, ***, &&&
15:33:42 <sinelaw> ~~< is also possible.
15:36:22 <Desustorm> lowasser, thanks.. can you explain some of the Monad syntax?
15:37:01 <lowasser> sure
15:37:17 <monochrom> Desustorm: So it seems like you should do: swapr (y,[]) = y; swapr (y,[x]) = y++[x]
15:37:21 <lowasser> essentially, it's just syntactic sugar to keep track of the StdGen
15:37:29 <lowasser> without us actually having to do anything?
15:37:36 <monochrom> swapr is not supposed to lose data
15:37:51 <Cale> Hello again
15:38:15 <Cale> Desustorm: Ah, learning about the monadic approach to keeping track of random number generator state?
15:38:21 <lowasser> indeeds =)
15:38:32 <Desustorm> hey Cale :)
15:38:33 <lowasser> it makes things so much more readable!
15:38:45 <monochrom> I am also wondering why the last card is never shuffled.
15:38:58 <Cale> lowasser: Yeah, I just wanted to make sure that he understood the straightforward way first. :)
15:39:01 <Desustorm> i don't know why that happens either monochrom
15:40:07 <monochrom> Of course I was speaking figuratively. I know why. shuf n (size-1) (split n size (init x))++[last x]  says "don't touch the last card".
15:40:12 <Desustorm> haha
15:40:46 <Desustorm> humm
15:41:19 <monochrom> This is an algorithm contrived to be some complicated that no one sees anything obvious. As opposed to so simple it's obviously correct.
15:41:27 <monochrom> s/some/so/
15:42:05 <Mathnerd314> is there a better name for "magic" in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8545
15:42:13 <Desustorm> hmm
15:42:14 <Peaker> @type (&&&)
15:42:15 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:42:41 <dabblego> Mathnerd314, liftA2
15:42:53 <dabblego> Mathnerd314, liftA2 Cons
15:43:01 <Peaker> @type (--<)
15:43:02 <lambdabot> parse error (possibly incorrect indentation)
15:45:02 <Mathnerd314> liftA2 takes applicatives; mine take functions
15:45:43 <dabblego> functions are applicative
15:45:49 <dabblego> @type liftA2
15:45:50 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:47:14 <tensorpudding> not all functions are applicative functors
15:47:32 <dabblego> forall t. (->) t
15:47:38 <tensorpudding> at least not in the sense meant by Applicative
15:48:00 <lowasser> ...false!
15:48:12 <lowasser> (->) a is a monad
15:48:15 <dabblego> @type liftA2 :: (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
15:48:16 <lambdabot> forall a b c t. (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
15:48:16 <tensorpudding> oh fine, modulo currying
15:48:17 <lowasser> so of course it's applicative
15:48:48 <dabblego> @google SKI combinator calculus
15:48:49 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
15:48:49 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
15:49:01 <dabblego> S :: (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
15:49:43 <Cale> Not all type-level functions are applicative functors
15:50:01 <monochrom> > liftA2 (:) head tail [1,2,3]
15:50:02 <lambdabot>   [1,2,3]
15:50:05 <monochrom> works
15:50:29 <Cale> It's not really correct to say that anything at the value level is really an applicative functor, unless you're going out of your way to represent concepts from category theory in a different way.
15:50:54 <thawk> hi
15:50:57 <Cale> hi
15:51:20 <Mathnerd314> I guess there isn't anything to save me from liftA2 <func> <same func> though?
15:51:28 <dabblego> join liftA2
15:51:42 <Axman6> :t join liftA2
15:51:43 <lambdabot> forall b c. ((b -> c) -> b -> c) -> ((b -> c) -> b) -> (b -> c) -> c
15:52:05 <Axman6> @djinn ((b -> c) -> b -> c) -> ((b -> c) -> b) -> (b -> c) -> c
15:52:05 <lambdabot> f a b c = c (b (\ d -> a (a (\ _ -> c d)) d))
15:53:08 <sepp2k> @pl \x -> f x x
15:53:08 <lambdabot> join f
15:53:22 <thawk> so, as a newbie, anything I should know before I get started
15:53:37 <dabblego> that you should get started and ask questions :)
15:53:45 <Saizan> @where LYAH
15:53:46 <lambdabot> http://www.learnyouahaskell.com/
15:54:01 <thawk> thank you
15:57:53 <Axman6> thawk: we're here to help, so if you have a question, just ask away
15:58:50 <thawk> alright, but I'm still trying to find questions to ask
15:59:08 <Axman6> well, go through LYAH, and see what you find
16:00:37 <monochrom> perhaps you will find haskell very easy and no questions to ask. it happened to me too.
16:01:53 <Axman6> haskell's pretty easy, but a lot of the concepts aren't
16:02:20 * twink tries to decipher a snippet he wrote a while back (May '09?), namely http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8548#a8548
16:02:36 <monochrom> everything is so logical and orderly
16:05:21 <olsner> twink: it can probably be rewritten as a simple zygohistomorphic prepromorphism
16:05:51 <twink> It's a ReaderT on something used by contT, possibly even the continuation itself.
16:06:56 <twink> olsner: Well, if it weren't some sort of deranged exercise in using monad transformers for the sake of learning how to use them, it'd probably be rewritten as a simple direct recursion.
16:09:07 <Peaker> monochrom, what did you read to learn Haskell?
16:18:17 <twink> olsner: Probably the first step in unraveling it is getting rid of the ReaderT, which is probably pure obfuscation.
16:18:27 <tomoj> how do you do testing with interleaved execution/evaluation?
16:19:25 <olsner> twink: do you nest the readers or anything? if not, maybe you can just stick the environment in the where clause
16:20:17 <twink> olsner: I've not looked at it in almost a year. I'm betting it's just cramming one more monad transformer in there.
16:23:01 <pokoko222> cab haskell represent a number with 200 000 digits?
16:23:28 <fax> 10^200000 duh
16:23:34 <CalJohn> @faq can haskell represent a number with 200 000 digits?
16:23:35 <lambdabot> The answer is: Yes! Haskell can do that.
16:23:59 <CalJohn> pokoko222: i believe you have your answer :)
16:24:13 * fax thinks that joke was too subtle
16:24:20 <olsner> > length (show (10^200000))
16:24:21 <lambdabot>   200001
16:24:35 <pokoko222> u guys think this is a joke?
16:24:50 <tensorpudding> what do you mean by "represent"?
16:25:01 <ezyang> no no, fax was joking
16:25:02 <Botje> > 10 ^ (10^5)
16:25:03 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
16:25:09 <jcreigh> pokoko222: yes, Haskell has arbitrary-sized integers.
16:25:15 <tensorpudding> Integer is supposed to be unbounded, but there are the usual limitations
16:25:19 <Botje> pokoko222: haskell has an Integer type which can support as much digits as your ram allows.
16:25:32 <tensorpudding> like computer memory, and information capacity of the universe
16:25:34 <olsner> something like (ackermann 7 7) represents a really large number, depending on what you mean by representation
16:25:49 <pokoko222> guys i am reading on primes, and there are infinite as u know, a research shows results on some number with 200 000 or something digits that is why i asked
16:25:51 <tensorpudding> A(7,7) is not representable in the universe.
16:26:20 <Polarina> How do enable FFI in GHCI so I can mess with it?
16:26:23 <Botje> sure it is: "A(7,7)"
16:26:44 <jcreigh> or just "10" in base-A(7, 7) :P
16:26:55 <pokoko222> forget about "representation" can haskell work with 200 000 digits, can it store the variable, print it, sum it?
16:27:03 <jcreigh> pokoko222: yes
16:27:39 <Peaker> pokoko222, Any Turing-Complete language can do it
16:27:46 <Peaker> pokoko222, Haskell can do it conveniently too
16:27:50 <tensorpudding> it's not uniquely representable in the sense that it is distinguishable from every positive integer less than it
16:27:52 <pokoko222> jcreigh u must break the number first or u can do lets say 56^124347347384374 + 343^2383934738473847
16:28:08 <pokoko222> Peaker ahhh, try doing it in c++
16:28:21 <pokoko222> ^ stands for exponent
16:28:41 <jcreigh> pokoko222: yeah, just use them normally.
16:28:50 <Peaker> pokoko222, no problem, I'd use libgmp
16:29:03 <pokoko222> interesting, tnx
16:29:03 <jcreigh> pokoko222: note that if you try to use exponents that large, it will probably seem as if your computer has hung.
16:29:22 <pokoko222> yeah it will calculate for days, that is obvious
16:29:31 <tensorpudding> representable is not equivalent to speedily computable, unfortunately
16:29:38 <pokoko222> yep
16:29:38 <Peaker> pokoko222, What calculation will take days?
16:29:53 <Peaker> pokoko222, most arithmetic you want to do would be O(N) or (N*logN) (N=number of digits)
16:29:54 <pokoko222> Peaker I meant in general big ones, like the 200 000 digits one
16:30:05 <roconnor> there are some number on the order of A(7,7) that are not representable in the universe
16:30:12 <Peaker> pokoko222, adding 200,000 digit numbers or multiplying them will not take days
16:30:14 <roconnor> "random" numbers
16:30:19 <tensorpudding> there are decently quick multiplication algorithms
16:30:37 <pokoko222> Peaker hmm well i thought packing them in special structures and managing that thing would take time
16:30:53 <sinelaw> Alpounet, wanna test face recognition? :)
16:31:05 <sinelaw> main = runTillKeyPressed (camera 0 --< (second faceDetect) >>> drawRects >>> window 0)
16:31:08 <sinelaw> :D
16:31:16 <Peaker> tensorpudding, Yeah, using FFT multiplication is O(N*logN)
16:31:20 <sm> what is this A(7,7) y'all are referring to ?
16:31:30 <pokoko222> Peaker for example if u pack it in c++ class
16:31:30 <Peaker> sm, Ackermann
16:31:35 <twink> let f n = ackermann n n and then f n for n >= 7 is unrepresentible as desired
16:31:37 <pokoko222> u would end up with some mess
16:31:39 <sm> thanks
16:31:41 <Peaker> pokoko222, why?
16:32:33 <Peaker> who do you talk to about a hackage user again?
16:33:09 <pokoko222> ok Peaker i got your point, it can be done fast, seems i had wrong impressions
16:33:11 <Absolute0> xIs i/quit
16:33:28 <aavogt> preflex: see byorgey
16:33:33 <aavogt> preflex: seen byorgey
16:33:33 <preflex>  byorgey was last seen on #haskell 4 hours, 47 minutes and 11 seconds ago, saying: I think those terms are pretty standard
16:33:45 <Alpounet> sinelaw, sure !
16:33:52 <Alpounet> is it pushed ?
16:34:18 <sinelaw> Alpounet, yip
16:34:18 <tensorpudding> A usually refers to the Ackermann function, which is usually people's go-to function for functions on N which grow outrageously fast and are not primitive recursive
16:34:26 <sinelaw> you need to update both HOpenCV and the other
16:35:06 <Alpounet> ok
16:35:24 <aavogt> @tell byorgey diagrams builds with containers-0.3.0.0
16:35:24 <lambdabot> Consider it noted.
16:35:36 <mux> I've been learning about Huffman coding, here is a basic haskell implementation: http://gist.github.com/331663 -- do you guys like it?
16:40:20 <Botje> it looks nice
16:40:25 <monochrom> Peaker: I read the gentle introduction. The most no-nonsense tutorial ever.
16:40:28 <Botje> althouh
16:40:33 <Botje> although having huffman and
16:40:35 <tensorpudding> The Gentle Introduction to Haskell?
16:40:38 <Botje> huffman' is confusion
16:40:40 <Botje> aargh
16:40:42 <monochrom> Yes.
16:40:44 <Peaker> monochrom, I remember having difficulty going through that one
16:40:44 <Botje> my enter key hate sme
16:40:49 <tensorpudding> That almost made me give up on learning Haskell.
16:41:00 <dolio> mux: What's Data.PriorityQueue.FingerTree from?
16:41:02 <tensorpudding> That was a really hard tutorial for someone who knew little programming.
16:41:20 <Peaker> monochrom, I remember having trouble understanding its intro to monads, and then understanding pretty well when going line by line over the implementation of the state monad from YAHT
16:41:46 <monochrom> Well, I'm a logical, unintuitive, screw-all-analogies person.
16:44:35 <Peaker> monochrom, I generally agree -- but maybe my problem was that I was expecting to understand just by reading (as most languages' material before that) and in that case I actually had to write the types and work them by hand
16:45:06 <Peaker> IOW, it was more difficult than the usual trivial stuff you find in language tutorials (which is mostly about new syntax more than about new concepts)
16:46:00 <monochrom> Right, I spontaneously tried my hands at calculating types and creating extra examples.
16:46:36 <tensorpudding> Introductions without examples usually fail if the reader isn't able to construct their own.
16:46:44 <mux> dolio: from the fingertree package
16:46:54 <dolio> Ah. How is it?
16:47:11 <mux> dolio: well, it seems to work :-P
16:47:13 <mux> Botje: thanks
16:47:19 <monochrom> Even just a few months ago I painstakingly worked out types by hand in order to write and revise http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356
16:48:02 <Peaker> tensorpudding, even with examples it wasn't enough - my brain only really made it sink in when I was forced to compute the example myself
16:48:20 <McManiaC> how can I send binary data through sockets? I guess plain "Network" with System.IO.hPutStrLn etc wont do it? ^^
16:48:37 <Peaker> McManiaC, There's a ByteString network thing I think
16:49:01 <monochrom> Unpaid, volunteered tutorials cannot possibly contain enough examples. "enough examples" is a full-time job.
16:49:03 <sinelaw> Alpounet, ? :)
16:49:30 <monochrom> You pay US$200 for a textbook and then you get enough examples.
16:49:39 <monochrom> It's also 2000 pages thick.
16:49:47 <sinelaw> one professor told us once
16:50:08 <sinelaw> "most problems are unsolvable. do you know why books cost so much? because you're paying someone to find solvable problems."
16:50:30 <Peaker> sinelaw, heh
16:50:54 <xerox> monochrom: convoluted
16:52:07 <monochrom> Personal learning skill makes or breaks your success.
16:53:31 <McManiaC> Peaker: looks cool
16:53:31 <McManiaC> thx
16:53:41 <mux> :t concat . map show
16:53:42 <lambdabot> forall a. (Show a) => [a] -> [Char]
16:54:05 <Alpounet> sinelaw, sorry was a bit busy
16:54:08 <mux> @let foo = concat . map show
16:54:09 <lambdabot>  <local>:4:0:
16:54:09 <Alpounet> currently building it :)
16:54:09 <lambdabot>      Equations for `foo' have different numbers of arguments
16:54:09 <lambdabot>   ...
16:54:14 <sinelaw> Alpounet, you have been forgiven.
16:54:17 <mux> @let foobar = concat . map show
16:54:18 <lambdabot>  Defined.
16:54:20 <Alpounet> oh, THANK YOU!
16:54:22 <mux> :t L.foobar
16:54:23 <lambdabot> forall a. (Show a) => [a] -> [Char]
16:54:27 <sinelaw> Alpounet, joking.
16:54:29 <tensorpudding> i wasn't really thinking "show them examples" but "provide them guidance for creating their own examples"
16:54:35 <Alpounet> sinelaw, I know, I was too
16:54:37 <Alpounet> ;)
16:54:41 <sinelaw> :D
16:54:45 <drk-sd> eh, question
16:54:45 <tensorpudding> Haskell is something that needed to sink in for me.
16:54:52 <Alpounet> but I get again that "cannot find -lHSrts_debug_p" error
16:54:56 <tensorpudding> I learned a lot by trying to implement a bunch of number-theory stuff in it.
16:54:56 <Alpounet> how did we solve it, again ?
16:54:57 <sinelaw> wtf
16:54:58 <mux> ah, it was the MR
16:55:01 <sinelaw> oh
16:55:03 <sinelaw> one sec.
16:55:06 <drk-sd> in a type annotation, what does "!String" means ?
16:55:06 <sinelaw> i'll fix that permanently
16:55:21 <drk-sd> what's the difference with String ?
16:55:37 <mux> drk-sd: in a type annotation? that should be a syntax error
16:55:42 <drk-sd> hmm
16:55:42 <mux> in a type definition it would make sense
16:55:53 <tensorpudding> It looks like a bang pattern.
16:56:19 <drk-sd> mux: well
16:56:26 <drk-sd> its in a :
16:56:33 <tensorpudding> the ! usually means "this should be strict" in function and data definitions
16:56:42 <drk-sd> « data Foo where Bar :: !Lol -> ... »
16:56:57 <drk-sd> tensorpudding: strict in what sens ?
16:57:04 <yitz> > "ouch" :: !String
16:57:04 <lambdabot>   Unexpected strictness annotation: !GHC.Base.String
16:57:24 <sinelaw> Alpounet, pull now
16:57:29 <sinelaw> pull up pull up pull up
16:57:36 * sinelaw crashed
16:57:46 <aavogt> > let f :: !a -> (); f _ = (); f undefined
16:57:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:57:57 <aavogt> > let f :: !a -> (); f _ = (); in f undefined
16:57:58 <Alpounet> hooray
16:57:58 <lambdabot>   Unexpected strictness annotation: !a
16:58:26 <tensorpudding> I actually don't know much about when thunks are evaluated.
16:58:30 <drk-sd> :D
16:58:39 <tensorpudding> I would imagine that any bang patterns in the arguments would require that they be evaluated immediately after the function is called, instead of being thunked.
16:58:46 <Saizan> drk-sd: do you know seq?
16:58:54 <drk-sd> yes
16:58:58 <aavogt> they get evaluated when something needs them
16:59:24 <Saizan> well strict fields get evaluated when you force the constructor
16:59:31 <aavogt> tensorpudding: f :: !a -> ()  is like     f x = x `seq` ()
16:59:54 <Alpounet> it forces the evaluation of your argument, when passed to your function
16:59:59 <Alpounet> well, when entering your function
17:00:00 <Saizan> you can actualli write f :: !a -> () now?
17:00:05 <mux> !String looks like someone failing at strictness
17:00:57 <Alpounet> sinelaw, that's awesome ! :D
17:01:13 <Saizan> drk-sd: defining data Foo where Bar :: !Lol -> Foo, is like having $! inserted everytime you use Bar
17:01:29 <tensorpudding> Strict fields can be funboxed.
17:01:34 <Saizan> drk-sd: e.g. "Bar x" becomes "Bar $! x"
17:01:35 <sinelaw> Alpounet, :)
17:01:35 <mux> so, since when you can have strictness annotations in a type annotation rather than in a type definition or in a function definition?
17:01:53 <sinelaw> Alpounet, this is main:
17:01:55 <Alpounet> sinelaw, but OpenCV doesn't like my face apparently
17:02:00 <sinelaw> main = runTillKeyPressed (camera 0 --< (second faceDetect) >>> drawRects >>> window 0)
17:02:07 <Alpounet> it selects half of it (well-centered though)
17:02:09 <drk-sd> Saizan: ok
17:02:17 <Saizan> @src $1
17:02:17 <lambdabot> Source not found. You untyped fool!
17:02:18 <Saizan> @src $!
17:02:19 <lambdabot> f $! x = x `seq` f x
17:02:21 <Alpounet> that's impressive
17:02:23 <sinelaw> Alpounet, are you facing it directly? maybe too far/close?
17:02:27 <aavogt> Saizan: it doesn't work, but I suppose it would mean exactly the same as putting it in the pattern
17:02:57 <Alpounet> sinelaw, ok when I get less close it's okay
17:02:59 <aavogt> which is probably only useful for pointfree code
17:03:23 <sinelaw> Alpounet,  how's performance? cpu usage? framerate?
17:03:25 <aavogt> though it could be a bit weird since type variables don't have to correspond to specific values
17:05:28 <Alpounet> sinelaw, slower than the last time I tried
17:05:33 <Alpounet> but it performs face detection so ...
17:06:15 <sinelaw> yes
17:06:18 <sinelaw> how much cpu?
17:06:23 <sinelaw> it goes to 100% here
17:06:25 <sinelaw> and very slow
17:09:13 <HugoDaniel> hi
17:09:33 <sinelaw> ho
17:11:25 <Alpounet> sinelaw, wait I'll check that
17:12:23 <Alpounet> sinelaw, around 55-60% CPU
17:12:32 <Alpounet> 0.9-1.0 % memory
17:13:27 <sinelaw> not bad
17:13:33 <sinelaw> but you are running it on a beast
17:14:17 <Alpounet> heh
17:14:42 <Alpounet> I think you (we ?) can look for optimizations a bit later
17:15:13 <Alpounet> since most of the performance relies on the core of hopencv
17:15:20 <Alpounet> maybe misses some strictness here and there ?
17:15:36 <sinelaw> there's only one place i can think of optimizing
17:15:40 <sinelaw> in this specific program
17:15:50 <sinelaw> we'll discuss it on another day :)
17:15:58 <sinelaw> if you have any ideas after looking at code, tell me.
17:16:04 <Alpounet> sure, no problem
17:16:09 <Alpounet> I don't have time for that right now
17:16:17 <Alpounet> but I will check the code soon
17:16:38 <sinelaw> if you want, of course
17:16:41 <McManiaC> www.n-sch.de/net.png cool :>
17:16:57 <Alpounet> I do
17:17:02 <Alpounet> that's insanely interesting
17:21:14 <jberryman> whoah, Debian Squeeze just got ghc 6.12 !
17:21:21 <jberryman> when did that happen?
17:22:19 <bremner_> yesterday, I think
17:23:31 <jberryman> I shouldn't be this excited about a compiler
17:24:14 <sinelaw> is there an easy way to upload to hackage? like a script or something?
17:24:26 <Alpounet> hmm
17:24:34 <Alpounet> cabal upload
17:24:48 <Alpounet> cabal upload --help, sinelaw
17:24:59 <sinelaw> thanks
17:26:44 <Mathnerd314> so, how can I write a function that works recursively on lists?
17:27:01 <tensorpudding> you can pattern match
17:27:16 <tensorpudding> first match on [], then match on (x:xs)
17:27:31 <tensorpudding> the function will then recurse on xs
17:28:39 <Mathnerd314> no, when lists themselves are nested
17:28:46 <Mathnerd314> like [[1,2,3],[2,3]]
17:28:48 <c_wraith> how does that change anything?
17:29:21 <tensorpudding> You can't apply the same function to the whole list as to the lists that make up the other list.
17:29:26 <tensorpudding> err, outer list*
17:29:30 <c_wraith> the function you apply to x will operate on a list.
17:29:34 <tensorpudding> They'll have different types, [[a]] and [a]
17:31:28 * hackagebot cv-combinators 0.1 - Functional Combinators for Computer Vision  http://hackage.haskell.org/package/cv-combinators-0.1 (NoamLewis)
17:31:38 <sinelaw> :)
17:31:40 <Alpounet> yay
17:32:06 <Veinor> INFINITE TYPES
17:32:28 * hackagebot HOpenCV 0.1 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1 (NoamLewis)
17:32:37 <Alpounet> upload fury
17:32:46 <tensorpudding> > fix (:[])
17:32:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:33:04 <tensorpudding> Too bad.
17:33:15 <Desustorm> Occurs check: cannot construct the infinite type: a = [a]
17:33:17 <sinelaw> docs didn't build
17:33:17 <Desustorm> i hate you so much
17:33:18 <Desustorm> :(
17:33:37 <c_wraith> Mathnerd314: recursion on lists is often abstracted out into higher-order functions, by the way.  map and the folds, foldr and foldl, cover most cases of list processing.
17:34:48 <sinelaw> how can i see hackage doc building logs?
17:35:23 <tensorpudding> map and the folds have analogues to other "container" types similar to cons lists
17:35:34 <c_wraith> sinelaw: there's a link on packages that have build failures.
17:36:20 <c_wraith> sinelaw: the link isn't present if there isn't a build failure
17:36:36 <tensorpudding> map generalizes to fmap in Functor, and fold generalizes to the multiple variants available to Foldables
17:36:37 <sinelaw> there isn't a link and there's no docs
17:36:48 <sinelaw> c_wraith, is it possible that it just takes time?
17:36:55 <c_wraith> yes.
17:37:05 <c_wraith> there's a cron job that builds the docs every 6 hours or so for new packages
17:37:24 <sinelaw> ah ok.
17:39:54 <Desustorm> dealout :: Int->Int->[a]->[[a]]->[[a]]
17:39:54 <Desustorm> dealout _ _ [] m = m
17:40:00 <Desustorm> why does that give me an error?
17:40:15 <c_wraith> what's the error?
17:40:28 <Desustorm> Occurs check: cannot construct the infinite type: a = [a]
17:40:51 <c_wraith> That line shouldn't cause that error.
17:41:04 <ben> > let dealout :: Int->Int->[a]->[[a]]->[[a]] ; dealout _ _ [] m = m in m 42 42 "" "foo"
17:41:05 <lambdabot>   Couldn't match expected type `t1
17:41:05 <lambdabot>                                -> t2
17:41:06 <lambdabot>      ...
17:41:21 <Desustorm> ah, silly line numbers then
17:41:34 <c_wraith> yeah, I'd blame it on an adjacent error
17:41:42 <Desustorm> dealout t u v z = dealout t (u+1) (tail v) (z!!(u `mod` t) ++ [head v])
17:41:52 <Desustorm> is probably what's getting me ;P
17:42:32 <Desustorm> haha got it the second i pasted it
17:42:37 <c_wraith> nice. :)
17:43:35 <mail> can i cast an Int to Integer?
17:43:48 <tensorpudding> you can do fromIntegral
17:44:18 <tensorpudding> > fromIntegral (5 :: Int) :: Integer
17:44:19 <lambdabot>   5
17:45:25 <tensorpudding> If the offending function that is returning Int's is length, you could switch to genericLength
17:47:41 * hackagebot data-category 0.0.1 - Restricted categories  http://hackage.haskell.org/package/data-category-0.0.1 (SjoerdVisscher)
17:48:00 <sbahra> heh
17:48:51 <jberryman> is anyone familiar with using Regions in HGL? The following just shows a black window for me, and I'm not sure why: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8543#a8543
18:00:35 <kmc> things is quiet here
18:01:18 <ezyang> HI KMC!
18:01:42 <kmc> hi ezyang
18:02:13 <Alpounet> sinelaw, I'm off for now (3 AM), I'll keep you posted regarding your code
18:02:32 <sinelaw> k :)
18:02:35 <sinelaw> i should alos be off
18:04:21 <twink> jberryman: I think that region is tiny in most resolutions.
18:05:36 <twink> jberryman: It may be hard to spot what you drew. Not sure what else could be going wrong. Someone who knows graphics might be more helpful.
18:06:58 * hackagebot cv-combinators 0.1.1 - Functional Combinators for Computer Vision  http://hackage.haskell.org/package/cv-combinators-0.1.1 (NoamLewis)
18:08:00 * hackagebot HOpenCV 0.1.1 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1.1 (NoamLewis)
18:09:08 <ezyang> Is there any literature on detecting mutation in arbitrarily deeply linked data structures?
18:14:55 <thawk> hey
18:16:47 <pokoko222> any game programmers here?
18:17:13 <thawk> I'm sorta learning
18:18:06 <monochrom> programming is a game. a programmer is a game programmer.
18:18:31 <pokoko222> monochrom enlightening
18:20:16 <thawk> so you need help with anything pokoko
18:20:20 <erikc> pokoko222: i guess me
18:20:20 <jberryman> twink: so the units aren't pixels then... ?
18:21:43 <erikc> though im headed out of game programming
18:21:46 <twink> I thought video games were a lot more about graphic design/art/etc. than programming. Like when the engine gets changed to handle some detail differently, all the ragdoll/whatever meshes have to get updated, and then the texture maps and bump maps and so on atop that.
18:22:43 <twink> (Not that I have any real knowledge.)
18:23:52 <twink> jberryman: I was thinking that if the units were pixels it'd be tiny. Like 5% of the screen or less.
18:24:47 <theorbtwo> Depends on the game, I think.
18:25:26 <FauxFaux> All the rockband clones certainly have a lot of that kind of thing.
18:25:31 <theorbtwo> Modern, big to medium budget action games, certianly, though not so much, I think, for the reason you think.
18:25:59 <theorbtwo> I don't know all that much about it either, really.
18:26:14 <erikc> twink: there are engine programmers who build runtimes for content, tools programmers who build tools for artists and designers (the tools are often simple visual programming languages that offload simple programming to non-programmers)
18:26:16 <jberryman> twink: oh. Nah, I looked pretty closely and just saw black ;)
18:26:17 <twink> Big worlds vs. numerous different characters?
18:26:42 <erikc> and then there'll be 'gameplay programmers' who sort of fill in the gaps where custom mechanics are needed or a bit of programming is too small to justify a tool for a non-programmer to do it
18:26:47 <theorbtwo> ...but I don't think programming changes terribly often need new artwork.
18:27:00 <Mathnerd314> tensorpudding: I want the shortest way to convert nested lists to my data structure, nested ZipLists: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8545#a8547
18:27:15 <Mathnerd314> something like a recursive makeZL function
18:27:59 <theorbtwo> If quests seem repetitive, that's why -- they only built tools for two kinds of quests, and don't have enough gameplay programmers.
18:28:18 <theorbtwo> Well, that, and the text writers aren't doing a good enough job hiding that fact.
18:29:59 <erikc> there's a push towards removing programming from gameplay development because it's the biggest production risk
18:30:15 <twink> Something like Soul Calibur IV might strike a different balance between "big worlds" and "lots of characters."
18:31:02 <thawk> erikc: what?
18:31:22 <erikc> thawk: ?
18:31:37 <theorbtwo> From the point of view of an outsider, it's been popular for a long time to just buy somebody else's engine.
18:31:46 <twink> thawk: The sort of thing I'm going on about where it's mostly graphic art/design/etc.
18:32:28 <twink> thawk: Though I'm not very versed in any of this where erikc is.
18:32:44 <theorbtwo> You can be more sure of getting N textures per hour out of a graphic artist then you can be sure of getting mumble out of a programmer.
18:32:53 <MrBlueSky> Quick halp. Does this look right?
18:32:55 <theorbtwo> How do you even measure the productivity of that?
18:33:02 <MrBlueSky> z :: IO StdGen
18:33:02 <MrBlueSky> z = do
18:33:02 <MrBlueSky>   gen <- newStdGen
18:33:02 <MrBlueSky>   return gen
18:33:14 <MrBlueSky> System.Random is imported.
18:34:01 <theorbtwo> Programming is a creative field in this case, in a way that the more outwardly artistic bits of game making aren't, neccessarly.
18:34:06 <twink> z seems to be identical to newStdGen
18:34:09 <theorbtwo> ...at least if you suck all the soul out of it.
18:34:48 <MrBlueSky> twink: Wouldn't z be identical to gen, not newStdGen?
18:35:56 <erikc> theorbtwo: exactly (regarding N textures per hour), hollywood production style is really popular now, and engineering is the greatest risk to those schedules
18:36:23 <erikc> much easier to license an engine, give tools to designers and say 'this is the palette of things you can have the player do, figure out how to make it fun'
18:36:31 <twink> theorbtwo: I was more impressed by how huge an army it must've taken years to do up the relatively detailed huge worlds, or highly detailed animations and so on for all the characters.
18:36:36 <Desustorm> MrBlueSky, nothing wrong with it, no
18:36:52 <erikc> (it's interesting to note that games that do this rarely hit high notes (or high sales) though), but it is a way to mitigate risk
18:37:00 <Botje> MrBlueSky: z is exactly the same as newStdGen
18:37:28 <twink> MrBlueSky: Try z = newStdGen
18:37:34 <MrBlueSky> ok
18:38:08 <theorbtwo> I was amazed to find that Mass Effect & Mass Effect 2 aren't based on bioware's own engine.
18:38:25 <theorbtwo> They licensed the Unreal engine for them.
18:38:44 <theorbtwo> I don't know about Dragon Age, though.
18:38:46 <idnar> theorbtwo: that didn't amaze me too much
18:38:48 <twink> erikc: I presumed there was some programming effort involved somewhere in all these things, but maybe not.
18:38:59 <idnar> theorbtwo: what amazes me is how often Bioware has developed a COMPLETELY FREAKING BRAND NEW engine for a game
18:39:02 <MrBlueSky> so I see.. I must be misunderstanding something somewhere in the tutorial. Thanks for that tip!
18:39:13 <theorbtwo> idnar: Huh?  They never have, or nearly never.
18:39:24 <Stalafin> i am trying to understand what fmap does; i am not so deep into haskell yet, and i don't get the concept of a functor; can somebody please explain what fmap is doing with an example?
18:39:26 <theorbtwo> Everything's been upgraded versions of the NWN engine for some time.
18:39:30 <idnar> theorbtwo: they developed one for Baldur's Gate / Icewind Dale / etc.
18:39:35 <dumael> twink: the unreal engine has a large amount of scripted components in it.
18:39:37 <theorbtwo> ...and I think that engine is actually older then that.
18:39:38 <idnar> theorbtwo: then they threw that away and wrote a new one for NWN
18:39:51 <theorbtwo> idnar: Are you sure it's not an upgraded one with a newer name?
18:39:53 <idnar> theorbtwo: then they rewrote most of that for Knights of the Old Republic
18:40:22 <Stalafin> idnar: errr.... the engine they used for icewind dale, baldurs gate, planescape torment was a little old for nwn, dont you think? :)
18:40:38 <erikc> theorbtwo: dragon age engine is derived from the neverwinter nights code base
18:40:39 <crash[`]> Hey folks; I need something to replace a 2D array for the sake of search (finding diagonals, etc), and being able to set values - what should I be using to do this efficiently (in terms of programmer time, not performance) ?
18:40:52 <idnar> theorbtwo: and then as far as I know, Jade Empire used a brand new engine too
18:40:59 <theorbtwo> idnar: It didn't.
18:41:08 <theorbtwo> At the very least, it didn't use new file formats.
18:41:15 <theorbtwo> (Slightly modified ones.)
18:42:05 <Stalafin> i know it's interesting being off topic and such...... but i ould really need some help with the whole functor thing (that is, an explanation for fmap)
18:42:05 <mail> putStrLn $
18:42:10 <mail> what does the $ sign do?
18:42:27 <jcreigh> @type ($)
18:42:28 <lambdabot> forall a b. (a -> b) -> a -> b
18:42:29 <Botje> crash[`]: Data.Array is pretty easy to work with
18:42:33 <idnar> theorbtwo: hmm, okay
18:42:36 <monochrom> "putStrLn $ blah blah" is "putStrLn (blah blah)
18:42:40 <crash[`]> It takes the evaluation of everything to the right as its parameter; it's a low precedence operator
18:43:39 <Stalafin> ok, no need to answer it; learn you a haskell did it :) love that thing
18:44:34 <mail> thanks
18:46:15 <QtPlatypus> What is the function for turning strings into the lower case?
18:46:35 <ManateeLazyCat> Hi all, are you use Text instead String always? I heard someone said Text is *much much* efficient than String.
18:47:01 <Desustorm> emacs irc?
18:47:01 <crash[`]> toLower
18:47:03 <crash[`]> from Data.Char
18:47:04 <tensorpudding> > map toLower "FOOBAR"
18:47:05 <lambdabot>   "foobar"
18:47:06 * Desustorm vomits
18:47:13 <c_wraith> ManateeLazyCat: depends on if it's something where that matters.
18:47:15 <QtPlatypus> Thankyou
18:47:19 <crash[`]> ManateeLazyCat: I always use bytestring :P
18:47:48 <c_wraith> ManateeLazyCat: If you're doing text processing, it matters.  If you're just using strings to report the result of a non-text calculation, the use of strings doesn't matter
18:48:06 <QtPlatypus> Desustorm: You ok?
18:48:21 <Desustorm> hehe yes
18:48:28 <crash[`]> desu desu desu
18:48:35 <Desustorm> was upset with the idea of an emacs irc client
18:48:36 <Desustorm> :<
18:48:37 <ManateeLazyCat> c_wraith: I'm doing editor. :)
18:48:39 <monochrom> ByteString.Char8 for massive ascii. Text for massive unicode. Is that right?
18:48:58 <ManateeLazyCat> c_wraith: Looks i need convert to Text.
18:49:08 <ManateeLazyCat> monochrom: Yep, Text for unicode.
18:49:22 <mail> can you give variable to IO functions?
18:49:40 <ManateeLazyCat> mail: IORef
18:49:54 <Zao> @type let x = "omg" in putStrLn x
18:49:55 <lambdabot> IO ()
18:50:40 <Desustorm> > 12 `mod` 12
18:50:41 <lambdabot>   0
18:50:56 <Desustorm> > 13 `mod` 12
18:50:57 <lambdabot>   1
18:51:04 <crash[`]> > "got in one little fight and my mom got scared.."
18:51:05 <lambdabot>   "got in one little fight and my mom got scared.."
18:51:24 <Desustorm> yes
18:51:31 <mail> http://pastebin.com/cSxw2fHv
18:51:32 <Desustorm> also, out of bounds error ;-;
18:51:35 <mail> need to do something like that
18:52:21 <Desustorm> yeah can someone help me with something quite remedial? |_|
18:52:22 <drk-sd> mail: where is your problem with this code ?
18:52:36 <mail>  Couldn't match expected type `IO ()'
18:52:37 <mail>            against inferred type `String -> IO ()'
18:52:41 <Desustorm> er, mail
18:52:51 <Desustorm> do you go to Bristol universiry?
18:52:55 <Desustorm> apdkoap
18:52:58 <Desustorm> university
18:53:02 <mail> yeh
18:53:05 <Desustorm> haha
18:53:09 <Desustorm> me too
18:53:10 <drk-sd> hum, that's weird mail
18:53:21 <Desustorm> lemme get my Mind up
18:53:37 <monochrom> mail: perhaps it depends on how you wrote "score"?
18:53:54 <mail> score is a custom function
18:54:00 <mail> it exists
18:54:03 <Desustorm> you don't have secret
18:54:03 * monochrom doesn't understand why the concept of "reproducible experiment" is so hard
18:54:06 <drk-sd> mail: i wouldn't have used another do after the else
18:54:09 <Desustorm> unless you made it a constant?
18:54:18 <drk-sd> did you try without it ?
18:54:18 <mail> yeah should be x
18:54:19 <Desustorm> no
18:54:22 <Desustorm> it should be x
18:54:22 <Desustorm> :p
18:54:28 <mail> still gives error though
18:54:30 <hasenov> hello, i am trying to import a module from a different directory in ghci, and for some reason the -i option is not working
18:54:42 <monochrom> I can't reproduce your problem. End of story.
18:54:43 <Desustorm> it should be play x at the end
18:54:51 <mail> ahh
18:55:03 <mail> cheers
18:55:05 <Desustorm> mail, are you first year or second?
18:55:09 <mail> first
18:55:14 <mail> doing CSE
18:55:15 <hasenov> if b and c are subdirectories of dir a, and I am in dir c, how would I import a file that resides in dir b?
18:55:19 <Desustorm> what halls? >_>
18:55:25 <mail> Hawthorns
18:55:27 <Desustorm> ah
18:55:29 <Desustorm> Badock here
18:55:39 <mail> CS 1st ?
18:55:41 <drk-sd> mail: you found what your error was ?
18:55:43 <Desustorm> yeah
18:55:43 <Desustorm> :p
18:55:56 <mail> yeh drk-sd
18:56:03 <drk-sd> what was it? :)
18:56:11 <Desustorm> play x on last line
18:56:13 <drk-sd> hasenov: "../b/foo" ?
18:56:19 <drk-sd> Desustorm: nice
18:56:28 <Desustorm> i'm doing the same course as him xD
18:56:40 <drk-sd> (btw « /b/ » :D)
18:56:47 <Desustorm> ~_~
18:56:53 <mail> Desustorm if you call play from main does return break back to the main function?
18:57:08 <Desustorm> umm
18:57:09 <mail> wait haskell return doesn't do that
18:57:12 <Desustorm> no
18:57:12 <mail> fail
18:57:13 <drk-sd> mail: it disn't break
18:57:25 <drk-sd> but well
18:57:27 <monochrom> "return ()" is nop.
18:57:29 <Desustorm> but in this case you can just use return() yes
18:57:36 <drk-sd> it's the last thing your function does
18:57:39 <Desustorm> which you already did
18:57:41 <drk-sd> (return ()) i mean
18:57:54 <drk-sd> so it encapsulate () into an IO() monad
18:57:59 <monochrom> since it does not recurse, it moves on.
18:58:03 <pikhq> Y'know, I have a complaint with return... That function is *horribly* named.
18:58:06 <drk-sd> and it returns it to your main function yes
18:58:26 <Zao> pikhq: I prefer pure, just to annoy people.
18:58:28 <drk-sd> pikhq: i don't think so
18:58:33 <Desustorm> mail, how's revision going :p
18:58:39 <mail> for what?
18:58:45 <Desustorm> tests next week
18:58:53 <pikhq> drk-sd: It looks like an imperative return statement. Obviously it isn't.
18:58:55 <mail> in?
18:59:01 <Desustorm> oh if you're doing CSE then maybe not
18:59:03 <tensorpudding> Return doesn't do any "returning", it just stuffs a bare value into a monad.
18:59:07 <drk-sd> pikhq: yeah, but who cares about imperative ?
18:59:17 <Desustorm> decision 2 and pure maths
18:59:18 <drk-sd> we shouldn't let it influence the language
18:59:29 <idnar> tensorpudding: return yields the action that does nothing and returns the given value
18:59:32 <mail> i do maths with maple
18:59:35 <Desustorm> ah
18:59:42 <Desustorm> fun :p
18:59:50 <mail> decision 2 = discrete maths ?
18:59:53 <Desustorm> yes
18:59:59 <mail> we have a test in that?
19:00:01 <mail> shit
19:00:03 <Desustorm> yeah
19:00:05 <Desustorm> shit indeed
19:00:06 <pikhq> idnar: "Returns a value"? Man. I've kept on saying "results in a value" just because it's less confusing.
19:00:09 <Desustorm> i have been to 3 lectures
19:00:18 <monochrom> This is the lesson you learn from "meaningful" names. You see a meaningful name "return", yeah? Well there are so many meanings to choose from.
19:00:35 <mail> the lectures are so unfortunately place
19:00:39 <idnar> pikhq: I don't think that's any less confusing, but hey
19:00:45 <idnar> pikhq: let's rename return to result then ;)
19:00:46 <mail> placed*
19:00:47 <hasenov> drk-sd: i say "import b.foo" (considering foo is module) in a file in c dir and then use "ghci -i~/a/b" file" and it cant find the dir
19:00:48 <Desustorm> not for CS people
19:00:54 <Desustorm> but they're still terrible
19:01:03 <pikhq> idnar: How's about liftM0 or something. :P
19:01:07 <mail> i have it on thursday at 9 am and it's my only lecture that day ...
19:01:32 <hasenov> same thing with ghc --make actually
19:01:41 <monochrom> I agree 9am is a crime.
19:01:44 <drk-sd> hasenov: i'm sorry, i can't help you, i'm also new to haskell
19:01:48 <idnar> pikhq: it's not liftM0 though
19:01:58 <drk-sd> but i would do import foo if i were you
19:01:59 <Desustorm> ha
19:02:00 <drk-sd> not b.foo
19:02:05 <drk-sd> since your module is called foo
19:02:07 <Desustorm> mail we have 4 from 9am->1pm
19:02:25 <drk-sd> (but i don't know, maybe the path has some influence on the module name, but i don't think so)
19:02:31 <mail> ouch
19:02:38 <pikhq> idnar: How's about we just refer to it as "the non-pathological function of type (Monad m) => a -> m e.a"
19:02:46 <pikhq> ...
19:02:52 <pikhq> "the non-pathological function of type (Monad m) => a -> m a"
19:02:57 <idnar> heh
19:03:07 <Desustorm> don't worry mail
19:03:10 <Desustorm> i don't go to them
19:03:11 <Desustorm> \o/
19:03:12 <pikhq> And then... Let GHC read our minds.
19:03:19 <djahandarie> Is that type composition or something? :P
19:03:49 <monochrom> I was TA for a course at 9am. I dutifully went. No student. Then at 9:30 some student came, but it was "I'm here for the next class at 10". At 9:45 another student came, but the first student said "he's in my same class". What a wonderful day! You think TA:students ratio being 1/1 is the best possible? Well I beat you there, 1/0.
19:03:53 <tensorpudding> return is the function that satisfies the monad laws along with bind
19:04:06 <Desustorm> haha monochrom
19:04:24 <Stalafin> monochrom: TA/student? i had a better thing with my professor
19:04:31 <monochrom> Haha
19:05:09 <Desustorm> any idea why i get an index too large exception here:?
19:05:10 <Desustorm>         dealout :: Int->Int->[a]->[[a]]->[[a]]
19:05:10 <Desustorm>         dealout t u v z = dealout t (u+1) (tail v) [z!!(u `mod` t) ++ [head v]]
19:05:34 <Stalafin> monochrom: beginning of the semester; party the night before until 4am; getting up at 8am (class is as 8:15);i dutifully run off to the class, just to find there is nobody there, except the prof; the next 1 hour 15 minutes i spend nodding
19:05:54 <Desustorm> whole method: http://pastebin.com/zy305Wvg
19:05:56 <monochrom> heh nodding
19:06:05 <Desustorm> s/method/function/
19:06:07 <tensorpudding> Desustorm: I don't see any reason to think that (u `mod` t) is going to be less than or equal to the length of z
19:06:44 <Stalafin> monochrom: i always wondered - what happens if there is nobody in class; is the prof still giving the lecture? kinda like the tree falls in forest - does it give a noise? :D
19:07:16 <idnar> Stalafin: no, because it's lazily evaluated
19:07:30 <Stalafin> good reply :D
19:09:03 <Desustorm> tensorpudding, what do you mean by that?
19:10:00 <Desustorm> i should have mentioned that it is called by dealout ((length c)) 0 b c
19:10:11 <monochrom> The prof may take vengence in deciding to announce exam-related information in that time-slot only. :)
19:10:30 <drk-sd> ok guys, i got a question
19:10:54 <drk-sd> what do ":>", ":\/:" and ":/\:" mean ?
19:11:06 <Desustorm> first one is a happy face
19:11:07 <Desustorm> :p
19:11:17 <monochrom> user-defined things. see the source code.
19:11:18 <Cale> drk-sd: They're data constructors (probably)
19:11:32 <Cale> Unless they're at the type level, in which case they're type constructors
19:11:39 <monochrom> I mean: see the whole source code. context is important.
19:12:09 <Cale> You can tell because they start with : which is the only symbol character which is treated like an uppercase letter with regard to infix operators
19:12:20 <drk-sd> ok
19:13:10 <drk-sd> they're data constructor there then
19:13:21 <drk-sd> but it isn't part of Haskell, is it ?
19:13:34 <monochrom> not in the standard library
19:13:36 <drk-sd> they've been defined in the « program »
19:13:37 <habitue> Hi I have some strings from a third party source formatted like "Error: {0} occurred at time {1}!" What's the best way to do c/python like substitution on these?
19:14:48 <drk-sd> hum, sorry monochrom, i didn't saw your first answer!
19:14:50 <drk-sd> thank you :)
19:15:56 <monochrom> "Error! " ++ x ++ " occurred at time " ++ y ++ "!"
19:16:41 <habitue> well so I'd need to do some splitting up these strings, since I am getting them from somewhere else
19:17:28 <habitue> I'm fetching them dynamically, and they might change from time to time, so I need a flexible way to do substitution I guess
19:17:58 <monochrom> This uses Text.PrettyPrint: show (hsep [ "Error!", text x, "occured at time", text y, "!" ])
19:19:18 <monochrom> hsep will decide at runtime where to break lines
19:19:46 <habitue> They might be built that way, but I'm getting them as complete strings, so they already have the "{0}" etc, I just need to do the substitution
19:20:32 <habitue> it's an api, so I'm getting a big list of format strings, and I have to fill in the data in them
19:21:01 <habitue> but they aren't normal printf style format strings
19:21:14 <monochrom> Text.Printf understand "%s" but not "{0}".
19:21:53 <habitue> is there a good way to do search and replace?
19:24:22 <oklopol> so if i want to see how many seconds something takes, what's the simplest way?
19:24:48 <krasno> Is it pure evil to use parameterized types to get around mutually recursive modules?
19:25:45 <monochrom> No.
19:27:04 <oklopol> i tried getClockTime, but i can only get either seconds or picoseconds out of it (and actually don't know how to get picoseconds to show correctly, the amount shows as a negative number)
19:27:30 <oklopol> i guess i could make anything i want out of picoseconds
19:28:40 <FauxFaux> oklopol: Isn't picoseconds just for relative times?  If so, negaitev doesn't matter.
19:28:56 <Jafet> > time (sum [1..1000000])
19:28:57 <lambdabot>   Not in scope: `time'
19:29:04 <Jafet> Wait, that's lunabot.
19:29:25 <monochrom> lunabot went to the moon
19:29:29 <oklopol> negaitev?
19:29:42 <Jafet> Good for her
19:29:55 <monochrom> negaitev is russian for negative <duck>
19:30:22 <oklopol> oh eh lol
19:30:33 <FauxFaux> Negatiev is English for "Oh, gosh-darn I have far too much lag to actually read what I wrote before hitting enter.".
19:30:53 <oklopol> yeah i tend to assume people don't make mistakes
19:31:48 <FauxFaux> I'd normally bother to correct them but frequently the text doesn't appear before I hit enter.  Only four more days on this connection. \o/
19:32:12 <ozamosi> Total haskell noob here, who's about to jump out a window if I don't figure this out soon. I have defined newtype AppT m a = App (ReaderT Connection (CGIT m) a) (copied from http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskelland), and right now ghc complains that it expected a CGIT IO but got an AppT IO. Is there not a CGIT in there, and how do I get it? When I try to use the different lift functions, it
19:32:12 <ozamosi>  lifts too far, and I just end up with an IO.
19:32:22 <oklopol> i used something like (tdPicosec $ diffClockTimes timeAfterExact timeBeforeExact) `div` 1000000000, but it gives me -91 when the difference is actually about 2 seconds
19:32:33 <oklopol> that should be milliseconds if i'm not mistaken
19:33:14 <monochrom> (What happens if you jump out a window?)
19:33:42 <ozamosi> monochrom: well, I'm lazy, and it's 4 am, so I won't find out until tomorrow.
19:34:28 <mail> x <- take 4 $ randomRs (0,9) gen :: [Int]
19:34:34 <mail> should x be binded to Int
19:34:37 <mail> shouldn't*
19:34:57 <monochrom> What is App? I wondering if you should have App (ReaderT Connection (CGIT m)) a
19:35:22 <oklopol> FauxFaux: what do you mean it "doesn't matter"?
19:35:24 <Cale> habitue: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8555#a8555
19:35:29 <ozamosi> monochrom: App is type App a = AppT IO a
19:35:48 <oklopol> oh wait
19:36:10 <oklopol> does diffClockTimes actually take the args in order before, after? /me tests...
19:36:43 <Cale> habitue: There's something I whipped up using the ReadP parsing library to interpolate for you. You pass it a format string, and a function from, say, numbers to strings to be interpolated, and it produces the best interpolation it can manage.
19:37:33 <oklopol> okay i swapped the args, now it takes between 34 and -206 milliseconds to do the thing.
19:37:36 <Cale> for example...
19:37:41 <Cale> ghci> format "hello {0} world {1}" (["abc", "def"]!!)
19:37:42 <Cale> "hello abc world def"
19:37:49 <oklopol> i think i'm doing something very wrong here
19:39:52 <crash[`]> Can someone give me a hand? I've got code/explanation at http://haskell.pastebin.com/iF9HK52P but the short is, it's not working, and I both would like to know how to fix it and how to write it .. better
19:43:46 <Cale> crash[`]: Maybe something like...  setElement board x y val = [[if x' == x && y' == y then val else val' | (x',val') <- zip [1..] xs] | (y',xs) <- zip [1..] board]
19:44:53 <Cale> Of course, you'll pay a performance penalty there for each element of the board, but lists aren't really the right datastructure for this type of access to begin with
19:45:20 <jmcarthur> Alpounet: yeah i would not say that vector-static is appropriate for algorithms that are remotely complex
19:45:32 <crash[`]> Cale: yeah someone suggested Data.Array, but i was already part way into this so I was curious to figure out how to fix this
19:45:58 <jmcarthur> Alpounet: i'm only going to be using it for some linear algebra type stuff, which won't deal much with changing dimensions, etc.
19:46:22 <crash[`]> Cale: and while that solution seems to work, that's definitely confusing to think about :P
19:46:40 <Cale> > zip [1..] "hello"
19:46:41 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
19:47:08 <Cale> > [ if even k then toUpper x else x | (k,x) <- zip [1..] "hello"]
19:47:09 <lambdabot>   "hElLo"
19:48:04 <mail> guys I just want a list of 4 random numbers between 0 and 9
19:48:05 <crash[`]> Yeah, the idea of the whole thing being one list comprehension was what threw me
19:48:07 <Cale> It's a common idiom to zip a list with a list of indices, so that you can then write your function to depend on the positions of elements in the list.
19:48:09 <mail> how the hell do i do that
19:48:24 <dons> mail: no need to swear. it is easy to find out via hoogle.
19:48:35 <dons> http://www.haskell.org/hoogle/ type in "random"
19:48:41 <Cale> > let gen = mkStdGen 42 in take 4 (randomRs (1,9) gen)
19:48:42 <lambdabot>   [3,4,5,2]
19:48:50 <Cale> er
19:48:52 <Cale> > let gen = mkStdGen 42 in take 4 (randomRs (0,9) gen)
19:48:53 <lambdabot>   [1,1,7,4]
19:48:56 <dons> click on the System.Random package, and look for a function that mentions lists, e.g. randomRs
19:48:59 <Desustorm> mail,
19:49:00 <Desustorm> main =  do
19:49:00 <Desustorm>     num <- randomRIO (1::Int,9999)
19:49:06 <Desustorm> is hax
19:49:07 <Desustorm> :)
19:49:14 <dons> randoms :: RandomGen g => g -> [a]
19:49:41 <crash[`]> dons: totally unrelated, do you do any work on ghc itself?
19:49:53 <QtPlatypus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23955#a23955 <- Am I using a buggy libary or does this generate the wrongly formatted date for everyone?
19:50:45 <Cale> What is Data.DateTime?
19:50:53 <QtPlatypus> I get "Sun, d Mar 2010 03:45:23 UTC" rather then "Sun, 3 Mar 2010...
19:51:42 <Ytinasni> you mean "Sun, 13 Mar...", i hope?
19:51:53 <Desustorm> dons, speaking as a total haskell beginner, it's really difficult to derive stuff from the hackage API when you have next to no knowledge of what's going on
19:51:57 <QtPlatypus> A wrapper around Data.Time.*
19:52:00 <QtPlatypus> Ytinasni: Yes I did
19:52:39 <QtPlatypus> Cale: You can replace it with Data.Time and get the same results.
19:53:32 <Cale> QtPlatypus: Yep
19:53:37 <Cale> What's wrong with the output?
19:53:55 <Cale> "Sun, 14 Mar 2010 03:53:26 UTC"
19:53:57 <Cale> is what I get
19:54:39 <QtPlatypus> Cale: What version of Date.Time do you have?
19:54:55 <Cale> /usr/local/lib/ghc-6.10.4/./package.conf:
19:54:56 <Cale>     time-1.1.4
19:56:19 <oklopol> okay this is a bit of a stupid question i guess, but i want to see how long a computation takes, but i can't just do like "getCPUTime, let smth = ..., getCPUTime" because ... won't actually be evaluated between the getCPUTimes, is there a quick way around this
19:56:45 <Cale> oklopol: You could use Control.Exception.evaluate to force it to evaluate to whnf
19:57:03 <oklopol> but will it evaluate between the getCPUTime calls
19:57:03 <QtPlatypus> Cale: Thanks
19:57:17 <mail> Cale relplace mkStdGen with getStdGen
19:57:20 <Cale> yes, that's what evaluate is for -- sequencing evaluation with other IO actions.
19:57:23 <oklopol> i should somehow make it part of the monad chain
19:57:35 <mail> let gen = getStdGen in take 4 (randomRs (1,9) gen)
19:57:50 <Cale> mail: Type error
19:58:02 <Cale> mail: getStdGen is an IO action, you have to actually run it to get the result
19:58:05 <Desustorm> mail
19:58:20 <oklopol> ah i see, so do i do smth <- Control.Exception.evaluate whatever, or how does it work? guess i could google too
19:58:23 <Cale> mail: That just defines gen to be the same IO action as getStdGen, without running it
19:58:25 <dons> Desustorm: interesting. i wonder what we could do to make it easier
19:58:35 <dons> Desustorm: better training on reading types?
19:59:12 <Cale> mail: So, to run it, you want to use something like  main = do g <- getStdGen; print (take 4 (randomRs (0,9) g))
19:59:21 <Desustorm> any tutorials on it go from easy->crazy hard quickly
19:59:35 <Cale> mail: Though, actually I recommend using newStdGen and ignoring getStdGen
19:59:36 <Desustorm> yeah that could help
19:59:46 <Desustorm> main =  do
19:59:47 <Desustorm>     num <- randomRIO (0::Int,9)
19:59:49 <Cale> (but you use it in the same way as getStdGen)
19:59:49 <Desustorm> would this not work?
19:59:56 <dons> and if you care about performance, switch to mersenne-random-pure64
19:59:56 <Desustorm> x4
20:00:00 <Cale> Desustorm: It would produce one...
20:00:23 <Cale> You could  replicateM 4 (randomRIO (0::Int,9))
20:00:35 <mail> that's what i'm doing Cale
20:00:36 <Cale> Using replicateM from Control.Monad
20:00:42 <mail> but error
20:00:50 <Cale> mail: Which error?
20:00:51 <mail> Couldn't match expected type `t -> [t1] -> IO ()'
20:01:10 <Cale> hm?
20:01:14 <Cale> More context
20:01:52 <mail> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23956#a23956
20:02:09 <Cale> let x = take 4 (...)
20:02:16 <Cale> take 4 (...) is a list, not an IO action
20:02:20 <Cale> So you can't run it
20:02:40 <Cale> Instead, you want to define x to be equal to that list, so you use let
20:02:56 <Cale> v <- x means "run the action x getting the result v"
20:03:08 <Cale> let v = x means "define v to be equal to x"
20:03:20 <mail> woah
20:03:22 <mail> nice
20:04:56 <Cale> If you leave out the take 4 by the way, you get an infinite list of pseudorandom numbers.
20:05:32 <mail> yeah
20:06:15 <Cale> Referential transparency makes it necessary to be a little more careful about randomness
20:06:58 <Cale> If the result of a function depends on something, that thing must be a parameter to the function, and this includes the state of random number generators, as you've probably already noticed :)
20:08:10 <Cale> There are various nice ways that people have worked out to help manage the additional wiring though, including special monads for random number generation.
20:08:37 <Cale> (you often don't want to do it all in the IO monad, since IO code is harder to test and work with)
20:09:47 <mail> wont x have a type IO
20:10:55 <mail> mhhm or not
20:11:34 <Cale> Inside a do-block which involves IO actions, in the line v <- x, we have that x :: IO t for some type t
20:11:38 <Cale> and then v :: t
20:12:10 <Cale> and with let v = x, the v and x could have any type, but they will have the same typ
20:12:11 <Cale> e
20:12:35 <Desustorm> The last statement in a 'do' construct must be an expression
20:12:46 <Desustorm> what does that mean, precisely?
20:13:01 <c_wraith> usually that your indentation is wrong.
20:13:06 <Cale> Desustorm: It means that you're not allowed to write v <- x or  let foo = bar on the end of a do-bloc
20:13:10 <Cale> k
20:13:10 <dons> practically, either the last statement is a return or a call to a monadic thing. usually it means your indentation is wrong.
20:13:11 <mail> possible indentation problems
20:14:01 <Desustorm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23957#a23957
20:14:04 <Cale> The last line of a do-block must be an action, and shouldn't bind the result, because the result of the last line is the result of the whole block, and you couldn't refer to that result if there are no further lines anyway.
20:14:06 * Desustorm prepares to blush
20:14:16 <Desustorm> ehm
20:14:19 <Cale> Desustorm: there's a tab
20:14:20 <Desustorm> what
20:14:22 <Desustorm> lol
20:14:34 <Cale> Desustorm: make sure your editor is configured to convert tabs to spaces automatically
20:14:37 <Desustorm> yeah that only showed up when i published it
20:14:39 <Desustorm> i have
20:14:59 <Desustorm> i think i pasted it :p
20:15:04 <Cale> Yeah, it's often not at all obvious when a stray tab character gets into your file
20:15:34 * hackagebot mongoDB 0.4 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.4 (ScottParish)
20:15:40 <idnar> I have vim configured to display tabs in a very obvious way
20:16:18 <Desustorm> Cale I'm also getting another problem with my other assignment that mail also has ;P
20:16:27 <Cale> hm?
20:16:34 <Desustorm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23958#a23958
20:16:58 <Desustorm> Exception: Prelude.(!!): index too large
20:17:04 <Desustorm> :(
20:17:19 <jinjing> hi, I have a question: when an enumerator is converted to a bytestring or vise versa, all the space benefit provided by the enumerator will be lost, is this true?
20:17:21 <Cale> Yeah, things like this are why we hate (!!)
20:17:33 <Cale> If you use (!!) in the first place, it's like admitting defeat
20:17:37 <Desustorm> haha
20:17:41 <Cale> Usually there's a way to avoid it altogether.
20:17:47 <Desustorm> humm okay
20:18:04 <Desustorm> splitAt?
20:18:09 <Desustorm> bah
20:18:11 <Cale> splitAt is also bad
20:18:19 <Desustorm> yes
20:18:20 <Cale> Anything dealing with indices is bad
20:18:33 <Cale> You want to write operations which act uniformly on entire lists
20:18:51 <Desustorm> hmm
20:18:51 <Cale> Though, splitAt is probably not as bad, for something like this
20:19:01 <Desustorm> well i'm dealing a deck to 3 hands
20:19:03 <Cale> You have a specific number of players to deal to, after all
20:19:04 <Cale> yeah
20:19:44 <Desustorm> is there a neater way to do it than x::Int->[[a]] where y :: Int->[a]
20:19:45 <Desustorm> etc
20:19:54 <Cale> Write a function to split off an appropriate number of appropriately sized chunks, just in the order that they occur in the list, using splitAt
20:20:20 <Cale> This would be like dealing each player all of their cards before going on to the next player
20:20:44 <Cale> You can then transpose that list of lists to deal in the conventional order, if you care about that.
20:21:00 <Desustorm> so
20:21:02 <Cale> (if the deck is shuffled, it doesn't really matter anyway :P)
20:21:25 <Desustorm> i would have [player1] [player2] [player 3] when a = 3?
20:22:02 <Cale> Your result will look like ([[player1], [player2], [player3]], [rest of cards])
20:22:14 <Desustorm> oh i see
20:22:20 <Cale> since probably you want to keep track of the remaining part of the deck
20:22:24 <Desustorm> 4 splitAts then?
20:22:33 <Cale> should only be 3 splitAts
20:22:37 <Desustorm> haha yes
20:22:43 <Desustorm> 4am maths :)
20:25:50 <Desustorm> > splitAt [1..4] 1
20:25:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:25:51 <lambdabot>         against inferred type ...
20:26:01 <Desustorm> > splitAt [1 .. 4] 1
20:26:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:26:02 <lambdabot>         against inferred type ...
20:26:31 <Desustorm> > splitAt [1,2,3,4] 2
20:26:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:26:32 <lambdabot>         against inferred type ...
20:26:38 <Desustorm> whargarbl
20:26:58 <Desustorm> > splitAt 1 [1,2,3,4]
20:26:59 <lambdabot>   ([1],[2,3,4])
20:33:59 <Veinor> what's the recommended method to get GHC onto osx 10.6?
20:34:43 <Desustorm> @type [[a]]
20:34:44 <lambdabot> [[Expr]]
20:36:31 <Desustorm> @type ([[a],[b],[c]],[d])
20:36:32 <lambdabot> ([[Expr]], [Expr])
20:43:48 <Desustorm> Cale, is it possible to make splitAt use [] instead of ()
20:43:49 <Desustorm> ?
20:44:13 <Jafet> Veinor, the official installer?
20:46:05 <dark> is there a reason for the camelCase in haskell hmm culture? (also standard library)
20:46:50 <Zao> Fewer glyphs, less jarring?
20:47:00 * ezyang likes hyphens, but they're reserved 
20:47:32 <Zao> omg'wtf'bbq
20:47:39 <mail> Desustorm is the second Haskell assignment harder than the first?
20:47:42 <Jafet> it'sFromMLIWouldGuess
20:47:45 <ezyang> Zao: Heh
20:47:48 <Desustorm> mail, yes
20:48:07 <Desustorm> lists ftl :(
20:48:41 <mail> found this site very helpful
20:48:42 <mail> http://learnyouahaskell.com/
20:49:00 <mail> made by BONUS I believe
20:50:41 <Desustorm> wtf is wrong with (!!)
20:50:44 <Desustorm> D:
20:51:29 <Spaceghost>  /msg ChanServ TEMPLATE #anime-es
20:51:34 <Spaceghost> sorry!
20:51:54 <Zao> Desustorm: Suboptimal perf.
20:52:19 <Desustorm> no i mean why the hell isn't it working :P
20:52:23 <manjunaths> hello
20:52:43 <manjunaths> hey anyone know how to get to the first help page that comes up on github when you start off ?
20:53:11 <Desustorm> :C
20:54:18 <mmmulani> > do { interact id }
20:54:19 <lambdabot>   <IO ()>
20:55:36 <dbelange> > echo dicks
20:55:37 <lambdabot>   Not in scope: `echo'Not in scope: `dicks'
21:35:54 <kniu> do typeclasses and types have different namespaces?
21:37:02 <sohum> :t interact
21:37:03 <lambdabot> (String -> String) -> IO ()
21:37:48 <manjunaths> I have a data type, which is like data Particle = MkParticle { pos = Vector3 Double, v = Vector3 Double }.
21:38:07 <Jafet> Haskell has namespaces?
21:38:28 <manjunaths> if I create a particle p0 like let p0 = MkParticle {pos = Vector3 1.0 0.0 2.0, v = Vector3 0.0 0.0 0.0 }
21:38:38 <manjunaths> how do I access the pos of p0 ?
21:38:47 <manjunaths> should I write explicit accessor functions ?
21:38:59 <manjunaths> or is there a way to automate it ?
21:39:17 <manjunaths> I am looking for something like p0.pos in C++.
21:39:20 <dons> manjunaths: the field name is the accessor function
21:39:23 <dons> pos p0
21:39:29 <manjunaths> ah...
21:39:31 <dons> :)
21:39:54 <manjunaths> thanks :-)
21:40:02 <manjunaths> I am reading page 55 of your book
21:40:51 <dons> i hope you enjoy it!
21:40:59 <manjunaths> dons it is amazing
21:41:02 <dons> and learn lots of cool things.
21:42:17 <Desustorm> hmm is there a way to split the first set in ([1,2,3,4],[5,6,7,8]) into ([[1],[2]...], [5..8]) ?
21:42:25 <manjunaths> yes, I like it and I showed it to a friend, whom I sold some haskell-crack to, and who is hooked, he liked it too and is considering ordering a copy of his own...
21:43:14 <manjunaths> haskrack
21:44:05 <manjunaths> just like crack, not only the first hit, all the hits are free!
21:44:29 <Desustorm> anyone? :(
21:45:20 <aavogt> Jafet: it does. For example constructors and types can be named the same
21:45:30 <manjunaths> > fst ([1,2,3,4], [5,6,7,8])
21:45:31 <lambdabot>   [1,2,3,4]
21:45:54 <aavogt> but it isn't ambiguous because the context determines what the CapitalizedName is
21:46:02 <manjunaths> > [ [x] | x <- fst ([1,2,3,4], [5,6,7,8])]
21:46:02 <lambdabot>   [[1],[2],[3],[4]]
21:46:30 <manjunaths> > [ [x] | x <- fst ([1,2,3,4], [5,6,7,8])], snd ([1,2,3,4], [5,6,7,8])
21:46:31 <lambdabot>   <no location info>: parse error on input `,'
21:46:34 <manjunaths> er
21:46:43 <Jafet> Well, other than the trivial value/type distinction
21:46:51 <manjunaths> > [[ [x] | x <- fst ([1,2,3,4], [5,6,7,8])], snd ([1,2,3,4], [5,6,7,8])]
21:46:52 <lambdabot>   No instance for (GHC.Num.Num [t])
21:46:52 <lambdabot>    arising from the literal `5' at <inter...
21:47:07 <Desustorm> manjunaths, if it can't be done in a loop i can't use it :P
21:47:19 <aavogt> kniu, Jafet look at the last section here: http://www.haskell.org/onlinereport/intro.html
21:47:27 <manjunaths> Desustorm, loop ? are we talking about haskell ?
21:47:45 <Desustorm> eh yeah kinda
21:47:47 <Desustorm> 6am haskell
21:47:54 <Desustorm> as in
21:48:06 <Desustorm> i have x amount of elements that need to be in that first set
21:48:14 <Desustorm> and split accordingly
21:48:24 <Desustorm> so nothign to do with a loop, i'm being stupid
21:48:26 <Jafet> aavogt, interesting
21:48:28 <Desustorm> nothing*
21:49:08 <manjunaths> > [ [x] | x <- fst ([1,2,3,4], [5,6,7,8])]
21:49:09 <lambdabot>   [[1],[2],[3],[4]]
21:49:14 <manjunaths> what is wrong with this ?
21:49:26 <aavogt> nothing at all
21:49:37 <Desustorm> i need the last set too on the end
21:49:41 <aavogt> except maybe it doesn't do what you want
21:49:44 <Desustorm> well i have cards instead of numbers
21:50:39 <aavogt> > first return ([1,2,3,4],[5,6,7,8])
21:50:40 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
21:50:40 <lambdabot>    arising from a use of `M19044376...
21:50:45 <Desustorm> i need ([[playerOnesHand],[p2],[p3]...[px]], [rest of the cards not dealt])
21:50:47 <aavogt> > first (:[]) ([1,2,3,4],[5,6,7,8])
21:50:48 <lambdabot>   ([[1,2,3,4]],[5,6,7,8])
21:50:58 <manjunaths> > [ [x] | x <- fst ([1,2,3,4], [5,6,7,8]) : snd ([1,2,3,4], [5,6,7,8])]
21:50:58 <aavogt> > first (map (:[])) ([1,2,3,4],[5,6,7,8])
21:50:59 <lambdabot>   No instance for (GHC.Num.Num [t])
21:50:59 <lambdabot>    arising from the literal `5' at <inter...
21:50:59 <lambdabot>   ([[1],[2],[3],[4]],[5,6,7,8])
21:51:18 <manjunaths> > [ [x] | x <- fst ([1,2,3,4], [5,6,7,8]) ++ snd ([1,2,3,4], [5,6,7,8])]
21:51:20 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8]]
21:51:55 <aavogt> @type uncurry (++) -- manjunaths
21:51:56 <lambdabot> forall a. (Monoid a) => (a, a) -> a
21:52:10 <aavogt> @type uncurry (Prelude.++)
21:52:10 <lambdabot> forall a. ([a], [a]) -> [a]
21:52:33 <manjunaths> Desustorm, I think aavogt fixed your problem
21:52:44 <aavogt> (\bot has alternate / generalized definitions of some functions)
21:52:54 <manjunaths> aavogt, yeah
21:53:36 <Desustorm> mm.
21:53:42 <Desustorm> i think i should sleep :p
21:53:48 <aavogt> Desustorm: do you know how to use pattern matching?
21:53:52 <Desustorm> 6am haskelling ftl
21:53:53 <Desustorm> no
21:54:06 <aavogt> there's really no need for functions like   first
21:54:31 <harrison> hey guys. is it a terrible idea to stuff a parse error into the maybe monad with catch and unsafePerformIO? basically, i'm not seeing what catch has to do with io in the first place.
21:55:00 <aavogt> harrison: it belongs in the IO monad because it's non-deterministic
21:55:47 <aavogt> if your code has    error "a" + error "b", it's unspecified which error you will catch
21:56:32 <aavogt> but in any case, that use of unsafePerformIO is one of the more accepted uses
21:56:38 <harrison> so if it only throws one error, it's fine?
21:57:00 <aavogt> harrison: what is throwing the error? Your code?
21:57:26 <evanbd> Somehow I don't equate "it's ok unless something goes wrong" with correct, deterministic behavior :)
21:57:57 <aavogt> well in this case you could implement the exact same behavior without unsafeperformio
21:58:08 <harrison> aavogt: no, if it was my code, i'd just have it use Either in the first place. it's Network.HTTP.getRequest
21:58:08 <aavogt> which is more or less the proof obligation
21:58:26 <aavogt> @hackage spoon
21:58:26 <lambdabot> http://hackage.haskell.org/package/spoon
22:04:29 <dancor> how often do you look up the spelling of runKleisli
22:04:41 <Zao> Never?
22:05:13 <Zao> As I never use it, but I'd misspell it consequently.
22:05:17 <Zao> *consistently
22:19:34 <kniu> Jesus, that's a lotta namespaces.
22:21:09 <Zao> I assume you mean scopes?
22:22:04 <crash[`]> Hey so I'm trying to pretty print a 2-d array (showing it as a square)
22:22:45 <Zao> Sorry, wrong channel.
22:22:53 <byorgey> crash[`]: ok.
22:23:07 <Zao> (my reply, not your question)
22:23:58 <crash[`]> byorgey: lol, sorry I got distracted
22:25:29 <crash[`]> Anyway; I can't think of a more concise way to do it than using a count for the rows, using a filter with the indices function, and using tail recursion to grab/print a line at a time. Anyone know a clever way to do it with a fold/map/etc?
22:25:57 <Zao> Sounds like a job for the pretty libraries.
22:26:13 <byorgey> crash[`]: it can almost certainly be done with some maps.  getting a row at a time by index sounds pretty bad =)
22:26:48 <byorgey> > unlines . map (intercalate " ") $ [[1,2,3], [4,5,6]]
22:26:49 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
22:26:49 <lambdabot>    arising from the literal ...
22:26:57 <crash[`]> exactly the problem. I was thinking maybe unzip + intercalate to add newlines
22:27:05 <byorgey> > unlines . map (intercalate " " . map show) $ [[1,2,3], [4,5,6]]
22:27:06 <lambdabot>   "1 2 3\n4 5 6\n"
22:27:16 <byorgey> unzip?
22:27:19 <crash[`]> nevermind
22:27:22 <crash[`]> well
22:27:32 <byorgey> so obviously what I just typed won't align the columns
22:27:36 <crash[`]> well that's fine
22:27:48 <crash[`]> but i've got something like
22:27:49 <byorgey> but you could also use printf, or write your own function to pad the numbers
22:28:41 <crash[`]> [((1,1), 4), ((1,2), 4), ((2,1), 4), ((2,2), 4)]
22:29:44 <byorgey> oh, you have a list of (location, value) pairs?
22:29:53 <byorgey> where each location is (row,column)?
22:30:07 <crash[`]> > assocs $ listArray ((1,1), (2,2)) (repeat 4)
22:30:08 <lambdabot>   [((1,1),4),((1,2),4),((2,1),4),((2,2),4)]
22:30:19 <byorgey> yep, I see
22:30:50 <byorgey> well, if you know how big the array is, just forget about the indices and split up the list by row first
22:31:09 <crash[`]> i know the size of the array, yes, plus the bounds function will give it to me as a tuple
22:32:24 <crash[`]> so you're just saying use take/drop
22:32:42 <byorgey> something like   chunk numCols . elems $ array
22:32:53 <crash[`]> hm
22:32:54 <byorgey> where chunk is defined in Data.List.Split, in the split package
22:33:00 <byorgey> or you can write your own with take and drop
22:33:18 <crash[`]> never heard of Data.List.Split
22:33:18 <crash[`]> hm
22:33:32 <byorgey> @hackage split
22:33:32 <lambdabot> http://hackage.haskell.org/package/split
22:34:03 <byorgey> that will give you a list of lists, then you can map/intercalate/unlines that however you like
22:35:31 <crash[`]> mhm thanks
22:36:38 <AxleLonghorn> hi, I'm trying out Haskell and I can't find the state monad
22:36:51 <byorgey> AxleLonghorn: it's in Control.Monad.State
22:37:02 <AxleLonghorn> ghc says it can't find that
22:37:09 <byorgey> AxleLonghorn: how did you install ghc?
22:37:26 <AxleLonghorn> arch linux pacman install
22:38:02 <byorgey> ok, I think it's just because that only comes with a few basic packages
22:38:55 <byorgey> AxleLonghorn: are there other ghc-related packages on arch?  I use arch too but I didn't install ghc via pacman
22:39:09 <pookleblinky> Get the mtl library
22:39:11 <pookleblinky> http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-State.html
22:39:35 <pookleblinky> Try not to use yaourt, though. It doesn't play well with haskell.
22:39:47 <byorgey> AxleLonghorn: try installing the haskell-mtl package
22:39:59 <AxleLonghorn> ok
22:40:24 <pookleblinky> extra/haskell-mtl 1.1.0.2-1.1
22:40:25 <byorgey> AxleLonghorn: in general though we usually recommend installing the Haskell Platform which comes with all of this stuff pre-packaged
22:40:45 <byorgey> but I don't know how you feel about installing stuff not through pacman
22:41:14 <AxleLonghorn> related question: I'm looking at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html which doesn't have Control.Monad.State listed, should I have been looking somewhere else?
22:41:34 <AxleLonghorn> byorgey: can you link to the Haskell Platform?
22:41:55 <byorgey> @where platform
22:41:56 <AxleLonghorn> also, thanks to both of you
22:41:56 <lambdabot> http://hackage.haskell.org/platform/
22:42:08 <byorgey> AxleLonghorn: yeah, that only lists the base libraries that come with ghc
22:42:47 <byorgey> AxleLonghorn: searching Hoogle is the way to find it
22:42:51 <byorgey> @where hoogle
22:42:51 <lambdabot> http://haskell.org/hoogle
22:43:09 <byorgey> if you search for State the first hit is a link to the Control.Monad.State docs
22:43:17 * hackagebot hunit-gui 0.1.4 - A GUI testrunner for HUnit  http://hackage.haskell.org/package/hunit-gui-0.1.4 (KimWallmark)
22:43:39 <pookleblinky> http://hackage.haskell.org/package/ghc-mtl
22:43:57 <AxleLonghorn> ok, if I install the platform, should I uninstall the pacman-installed cabal first?
22:44:09 <byorgey> AxleLonghorn: probably safest to uninstall first.
22:44:15 <byorgey> although I don't know if it matters.
22:44:39 <byorgey> pookleblinky: I think that's something else
22:46:58 <pookleblinky> byorgey, yeah, just noticed this is it: http://hackage.haskell.org/package/mtl-1.1.0.2
22:47:32 <AxleLonghorn> will I be ok if I compile platform with ghc6.12.1 instead of 6.10.4 ?
22:47:41 <Ke> no afaik
22:47:47 <Ke> no gtk2hs
22:48:41 <AxleLonghorn> so I shouldn't use the latest version of the compiler? that seems off
22:49:02 <dcoutts> anyone here got ghc-6.12.1 on windows and can check something quickly for me?
22:49:02 <lambdabot> dcoutts: You have 18 new messages. '/msg lambdabot @messages' to read them.
22:49:25 <dcoutts> I'm trying to double check where ar.exe is installed in the ghc tree
22:49:27 <byorgey> Ke: hm? what do you mean?
22:49:59 <Ke> does it compile already
22:50:01 <Ke> ?
22:51:01 <byorgey> oh, does the Platform include gtk2hs?
22:51:09 <dcoutts> byorgey: nope
22:51:10 <Ke> I was under impression that ghc-6.12 was held back due to platform non-compile
22:51:21 <byorgey> AxleLonghorn: the current release of the Platform includes GHC 6.10.4.
22:52:23 <byorgey> oh look, there's a haskell-platform package in the AUR
22:52:27 <byorgey> http://aur.archlinux.org/packages.php?ID=26279
22:52:40 <byorgey> that's probably the way to go then
23:27:19 <ivanm> preflex: seen Axman6
23:27:19 <preflex>  Axman6 was last seen on #haskell 7 hours, 25 minutes and 26 seconds ago, saying: haskell's pretty easy, but a lot of the concepts aren't
23:27:38 * Axman6 still stands by that statement
23:27:42 <ivanm> heh
23:27:52 <ivanm> Axman6: what happened to the email you were going to be sending out last weekend? :p
23:28:14 <Axman6> remind me tomorrow
23:28:24 <ivanm> k
23:52:08 <hatds> :t round
23:52:09 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
23:52:45 <hatds> > round $ (2.5 :: Rational)
23:52:46 <lambdabot>   2
23:52:49 <hatds> > round $ (3.5 :: Rational)
23:52:50 <lambdabot>   4
23:53:04 <hatds> anyone else find the above strange?
23:53:28 <Veinor> it's one way of resolving rounding for x+1/2
23:53:39 <Veinor> that is guaranteed to not be biased in a particular direction
23:53:49 <hatds> namely how... always to the even possibility?
23:55:05 <hatds> so it is documented somewhere that round is always even?
23:55:16 <shachaf> > map round ([0.5..9.5] :: [Rational])
23:55:17 <lambdabot>   [0,2,2,4,4,6,6,8,8,10]
