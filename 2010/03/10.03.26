00:08:43 <kniu> you know what I need?
00:08:54 <dmwit> speed?
00:08:55 <kniu> I need C with first-class functions.
00:09:13 <kniu> or Haskell with pointers.
00:09:24 <dmwit> ?hoogle Ptr
00:09:25 <lambdabot> module Foreign.Ptr
00:09:25 <lambdabot> Foreign.Ptr data Ptr a
00:09:25 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
00:09:33 <kniu> Good lord.
00:11:48 <dmwit> That's the nicest thing anybody's called me all day.
00:29:38 <lpsmith> glguy__:  thanks!  I wanted 2009.2.0.1
01:35:25 <rajeshsr> hi
01:35:44 <rajeshsr> is there any web interface for haskell mailing list?
01:45:23 <silver> rajeshsr, http://www.haskell.org/pipermail/haskell-cafe/
01:45:38 <Araneidae> `cabal install` says: "You should update your code to use the new base version 4.x".
01:45:42 <Araneidae> How do I do this?
01:45:45 <silver> rajeshsr, http://www.haskell.org/mailman/listinfo/
01:47:34 <rajeshsr> silver, thanks!
01:47:59 <rajeshsr> so, forum interface is not there? Isn't it just an archive?
01:49:29 <silver> oh, you want to post something?
01:49:44 <silver> you can use gmail web client :)
01:49:44 <ivanm> rajeshsr: either subscribe or you can post a one-off via gmane
01:50:08 <rajeshsr> yeah! i do subscribe via gmail.
01:50:26 <rajeshsr> just thought, it will be better had it been as forums
01:50:52 <ivanm> mailing list /= forum
01:51:03 <ivanm> mailing list can be accessed from numerous places, etc.
01:51:07 <ivanm> and doesn't need a browser
01:52:54 <rajeshsr> ivanm, i do know that! :)
01:53:10 <ivanm> they why are you suddenly wanting the mailing list to be a forum?
01:53:20 <rajeshsr> but a web interface as a forum which is coupled with the mailing list can be good too!
01:53:37 * ivanm doubts it
01:53:45 <ivanm> and I don't know of any such interface
01:53:57 <rajeshsr> hmm! netbeans has something like that, IIRC
01:53:59 <ivanm> anyway, forums are linear; mailing lists are more like trees
02:02:44 <HandheldPenguin> Is there a function in haskell to find the location of a string in a given [string]]?
02:03:03 <dobblego> @type findIndex
02:03:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
02:03:31 <HandheldPenguin> cool thanks dobblego
02:03:35 <dobblego> np
02:04:24 <ivanm> heh, that reminds me: when tutoring yesterday, a student had written a function of type [[a]] -> [a] for his assignment
02:04:33 <ivanm> he got really annoyed that that function was called "concat"
02:06:50 <zygoloid> ivanm: any particular reason for the annoyance?
02:07:03 <ivanm> zygoloid: the fact that he spent all that time writing it when it was already available
02:07:04 <rajeshsr> concat already exists!
02:07:17 <ivanm> note that they were all provided with printed copies of the tour of the Haskell prelude
02:07:40 <ivanm> zygoloid: then again, he was using stupid names (e.g. a type called "Donkey") *shrug*
02:08:09 <zygoloid> ivanm: well, /clearly/ the natural name for concat is "cheeseBurger"
02:08:32 <ivanm> it is? :o
02:09:35 <Botje> and for filter it's "canHaz" ?
02:09:44 <dobblego> when a person is disappointed by the existence of their own work, I consider their motives for producing that work
02:09:53 <Ferdirand> you should have told him it was called "join"
02:10:06 <ivanm> Ferdirand: except it isn't
02:10:11 <ivanm> join is equivalent to concat for lists
02:10:19 <dobblego> Scala calls it flatten
02:10:39 <ivanm> Ferdirand: we have enough trouble explaining what the "Eq a => " on some functions is for without considering monads, etc.
02:10:40 <ivanm> (yet)
02:11:03 <Ferdirand> ivanm: ye, i was just being silly :)
02:11:07 <ivanm> ahhh
02:11:28 <dobblego> ivanm, what/where are you tutoring?
02:11:35 <ivanm> COMP1100 @ ANU
02:11:36 <ivanm> with Axman6
02:11:41 <ivanm> speaking of him...
02:11:43 <ivanm> preflex: seena X-Scale
02:11:46 <ivanm> grr.
02:11:50 <ivanm> preflex: seena Axman6
02:12:03 * ivanm missed hitting the `a' key before `x' and then tab
02:12:09 <ivanm> preflex: wakey, wakey!
02:12:23 * Botje supplies ivanm with an oversized x key
02:12:35 <ivanm> Botje: it was the _a_ key that was the problem, not x!
02:12:40 <FliPPeh> Mh
02:12:40 <ivanm> mauke: methinks your bot is dead
02:12:46 <FliPPeh> After getting used to screen...
02:12:48 <FliPPeh> It's not that bad.
02:12:50 <Botje> ivanm: huh. it's too early :(
02:14:01 <HandheldPenguin> bah Ambiguous occurence
02:14:22 <HandheldPenguin> Can you do things like import List.findIndex?
02:14:40 <dobblego> import Data.List(findIndex)
02:17:39 <HandheldPenguin> Cheers :)
02:18:52 <zygoloid> HandheldPenguin: you can also say 'import Data.List as List', then later write List.findIndex
02:19:12 <zygoloid> *'import qualified Data.List as List' if you want to avoid the ambiguity
02:37:13 <HandheldPenguin> I've got... foo :: ([a] -> [b]) -> [a] -> [b]
02:37:26 <HandheldPenguin> And it wont let me parse for foo x _ = error "Empty"
02:37:35 <HandheldPenguin> or foo _ y = error "Empty"
02:37:48 <Botje> HandheldPenguin: can you show code?
02:37:57 <Botje> maybe the error is somewhere else
02:37:57 <HandheldPenguin> yeah sure
02:38:34 <HandheldPenguin> http://codepad.org/2UEMUBMf
02:39:08 <HandheldPenguin> I'm trying to make sure that the user doesn't pass empty strings
02:39:08 <Botje> ERROR - Undefined variable "main"
02:39:12 <Botje> oh, duh
02:39:14 <Botje> that's codepad stuff, nevermind
02:39:18 <HandheldPenguin> Yeah lol
02:39:25 <HandheldPenguin> I think it only does C or somethign
02:39:37 <Axman6> ivanm: o/
02:39:49 <Botje> HandheldPenguin: and what error are you getting from your compiler?
02:40:03 <HandheldPenguin> Well that compiles fine
02:40:08 <ivanm> hey Axman6
02:40:17 <ivanm> what's the current registration count?
02:40:18 <HandheldPenguin> it's when i put something like foo x _ = error "error"
02:40:23 <HandheldPenguin> it gives overlapped patterns
02:40:58 <Botje> HandheldPenguin: yes, because both foo x y and foo x _ match the same things.
02:40:59 <int-e> HandheldPenguin: right. because  foo x _  does match exactly the same values as  foo x y
02:41:28 <Botje> HandheldPenguin: you want something like foo x [] = error "don't give me an empty string! ; foo x y = ...
02:41:35 <HandheldPenguin> I want it to throw an error when they don't pass any args for either func
02:41:36 <Botje> s/string/list/ :P
02:41:37 <HandheldPenguin> oh ok
02:41:37 <HandheldPenguin> thanks
02:41:51 <Botje> HandheldPenguin: users /have/ to pass arguments.
02:41:56 <Botje> otherwise they get a type error
02:42:04 <HandheldPenguin> oh ok cool
02:42:49 <HandheldPenguin> Thanks once again :D
02:43:28 <Botje> have fun :)
02:43:47 <HandheldPenguin> Oh I am...my last 2 courseworks and I'm free
02:43:55 <Axman6> ivanm: 18
02:44:20 <Axman6> ivanm: including Chak :P
02:44:45 <ivanm> \o/
02:53:21 <burg> hello. i get this error in huskell: http://codepad.org/gFl6HbcF . how can ifix it?
02:54:17 <Botje> burg: you should make a Show instance for your Nat type
02:54:31 <Botje> easiest way to do that is data Nat = Zero | Succ Nat deriving Show
02:54:41 <dobblego> burg, on the end of your data Nat put this: "deriving Show"
02:56:24 <Anchakor> hi, I don't use haskell but I got a question - does haskell have array data type, or it uses pointers or arrays are not possible or something else?
02:56:39 <dobblego> yes it has an array data type, but not pointers
02:56:54 <dobblego> there is nothing that is not possible
02:57:02 <dobblego> Haskell is turing complete
02:57:03 <Anchakor> ok thanks, this is usual in funcional languages?
02:57:16 <burg> Botje,  how did you know that i had data Nat = Zero | Succ Nat ?
02:57:24 <dobblego> in pure functional languages, yes, there is no need for pointers
02:57:26 <Anchakor> (having datatypes for structured types)
02:57:39 <dobblego> burg, Haskell has a function that allows us to read others' minds
02:57:41 <Axman6> Anchakor: it's the most useful functional programming language imo
02:57:56 <Axman6> Erlang is useful, but limited in its uses
02:58:18 <Botje> burg: it's a common exercise :)
02:58:19 <dobblego> Anchakor, what do you mean by "having datatypes for structured types"?
02:58:24 <Anchakor> does it have asociative array data type (map)?
02:58:27 <Botje> (i gave it to my students two weeks ago)
02:58:30 <dobblego> Anchakor, yes
02:58:32 <Axman6> Anchakor: Haskell has quite a few Array types by the way
02:58:47 <Axman6> @hoogle Map
02:58:47 <lambdabot> module Data.Map
02:58:47 <lambdabot> Data.Map data Map k a
02:58:48 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
02:59:00 <Anchakor> dobblego: something like structs in c - what I mean if the base language defines all the types you can use
02:59:02 <Botje> Anchakor: haskell has almost all data types you'd expect in an imperative language.
02:59:16 <Axman6> Anchakor: you can define any type you like in haskell really
02:59:22 <dobblego> Anchakor, Haskell has very powerful "structs" called "algebraic data types"
02:59:33 <Axman6> binary tree: daya Tree a = Node a (Tree a) (Tree a) | Leaf a
03:00:58 <Anchakor> does it have similar level of type modularity like OOP languages or the base types are fixed (like in C for example)?
03:01:45 <Botje> Anchakor: haskell is nothing like OOP languages.
03:01:56 <Botje> but yes, you can make your own types, as Axman6 just described
03:01:59 <Anchakor> yeah I just wonder about the type system
03:02:00 <dobblego> it does modularity much better than OOP languages, to the extent that it is very different
03:02:13 <Botje> Anchakor: the best way to get a feel for it is just to dive in, really
03:02:25 <Axman6> Anchakor: like I said, haskell has possibly the most powerful system for defining your own types of any language that exists
03:02:34 <Axman6> it's one of the best features of the language
03:02:42 <Anchakor> ok, thanks a lot guys
03:04:01 <jlouis> Anchakor: Haskell has IORef cells which for all purposes work like a pointer. You can't do arithmetic on them though
03:04:07 <Axman6> Anchakor: for example, a linked list can be defined as: data List a = Cons a (List a) | Nil
03:04:23 <Axman6> jlouis: that's what we have Ptrs for :P
03:04:23 <dobblego> IORef is not like a pointer
03:04:34 <ivanm> Axman6: even more than coq, agda, etc.?
03:04:39 <dobblego> there is nothing like a pointer in Haskell
03:04:48 <ivanm> dobblego: thankfully! :D
03:04:49 <Axman6> ivanm: useful languages
03:04:56 <ivanm> heh, nice qualification
03:04:56 <Axman6> dobblego: what's Ptr then?
03:05:04 <dobblego> ivanm, kind of (there is a paper on memoisation)
03:06:02 <dobblego> Axman6, part of the FFI iirc
03:08:28 <Phyx-> dobblego: and the FFI is an addendum to Haskell, so arguably it's a part of it
03:09:51 <dobblego> Phyx-, such a discussion is terribly uninteresting to me :)
03:13:01 <mreh> (head . dropWhile unsafe . zip) `liftM2` (getRandomRs (0, fromIntegral wWidth)) (getRandomRs (0, fromIntegral wHeight)) -- I can't see what I've done wrong here
03:13:23 <mreh> :t liftM2
03:13:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:13:35 <dobblego> mreh, what does GHC say is wrong?
03:13:52 <mreh> Couldn't match expected type `[(Double, Double)]'
03:13:52 <mreh>            against inferred type `[b] -> [(a, b)]'
03:13:52 <mreh>     In the second argument of `(.)', namely `zip'
03:14:47 <dobblego> mreh, what is the type of unsafe?
03:18:12 <zygoloid> @type (head . dropWhile ?unsafe . zip) `liftM2` (getRandomRs (0, fromIntegral ?wWidth)) (getRandomRs (0, fromIntegral ?wHeight))
03:18:13 <lambdabot>     Couldn't match expected type `[a2 -> r]'
03:18:13 <lambdabot>            against inferred type `[b] -> [(a, b)]'
03:18:13 <lambdabot>     In the second argument of `(.)', namely `zip'
03:18:50 <mreh> unsafe is the correct type, (Double,Double) -> Bool
03:18:52 <zygoloid> mreh: you wrote: (...) `liftM2` (...) (...)
03:19:04 <mreh> zygoloid, yes
03:19:22 <zygoloid> did you mean ((...) `liftM2` (...)) (...)?
03:19:29 <mreh> zygoloid: quite likely
03:19:42 <zygoloid> @type liftM2 (head . dropWhile ?unsafe . zip) (getRandomRs (0, fromIntegral ?wWidth)) (getRandomRs (0, fromIntegral ?wHeight))
03:19:43 <lambdabot>     Couldn't match expected type `[a2 -> r]'
03:19:44 <lambdabot>            against inferred type `[b] -> [(a, b)]'
03:19:44 <lambdabot>     In the second argument of `(.)', namely `zip'
03:20:13 <mreh> is there a simpler example we could construct?
03:20:27 <mreh> I've never had to use liftM2 before
03:20:44 <dobblego> nobody has ever had to
03:20:45 <zygoloid> @type liftM2 (\a b -> head . dropWhile ?unsafe $ zip a b) (getRandomRs (0, fromIntegral ?wWidth)) (getRandomRs (0, fromIntegral ?wHeight))
03:20:46 <lambdabot> forall a b a1 (m :: * -> *) a2. (?unsafe::(a, b) -> Bool, Num a, ?wWidth::a1, Integral a1, MonadRandom m, Random a, Num b, ?wHeight::a2, Integral a2, Random b) => m (a, b)
03:20:59 <zygoloid> @pl \a b -> head . dropWhile unsafe $ zip a b
03:20:59 <lambdabot> ((head . dropWhile unsafe) .) . zip
03:21:25 <zygoloid> @type liftM2 ((fmap.fmap) (head . dropWhile ?unsafe) zip) (getRandomRs (0, fromIntegral ?wWidth)) (getRandomRs (0, fromIntegral ?wHeight))
03:21:26 <lambdabot> forall a b a1 (m :: * -> *) a2. (?unsafe::(a, b) -> Bool, Num a, ?wWidth::a1, Integral a1, MonadRandom m, Random a, Num b, ?wHeight::a2, Integral a2, Random b) => m (a, b)
03:23:31 <zygoloid> @type \wWidth wHeight -> (head . dropWhile ?unsafe) <$> (zip <$> getRandomRs (0, fromIntegral wWidth) <*> getRandomRs (0, fromIntegral wHeight))
03:23:32 <lambdabot> forall a b a1 (f :: * -> *) a2. (?unsafe::(a, b) -> Bool, Num a, Integral a1, MonadRandom f, Random a, Applicative f, Num b, Integral a2, Random b) => a1 -> a2 -> f (a, b)
03:25:22 <mreh> wWidth and wHeight are constants
03:26:11 <mreh> :t (head . zip `liftM2` getRandoms) getRandoms
03:26:12 <lambdabot>     Precedence parsing error
03:26:12 <lambdabot>         cannot mix `.' [infixr 9] and `liftM2' [infixl 9] in the same infix expression
03:26:20 <mreh> :t (zip `liftM2` getRandoms) getRandoms
03:26:21 <lambdabot> forall a b (m :: * -> *). (MonadRandom m, Random a, Random b) => m [(a, b)]
03:26:41 <zygoloid> liftM2 is really not ideal for use infix
03:26:43 <mreh> I'll just write it out in full in do notation...
03:26:50 <zygoloid> <$> and <*> are good for that though
03:28:11 <zygoloid> liftM2 f a b = f `liftM` a `ap` b
03:28:21 <zygoloid> with a matching Applicative instance, that's f <$> a <*> b
03:34:33 <ivanm> Axman6: what was that auction site again?
03:34:47 <Axman6> allbids
03:34:51 <ivanm> ta
03:45:19 <FliPPeh> tmux > screen :)
04:06:19 <trofi^w> hia! are here gtk2hs developers around?
04:09:14 <trin_cz> trofi^w: hi! I just came looking for them, too. I was compiling gtk2hs darcs version and was missing EntryBuffer. EntryBuffer was introduced in gtk2.18 .
04:10:45 <trofi^w> aha. i'm using more recent gtk2hs and it's broken too
04:11:30 <trin_cz> trofi^w: there is gtk2.16 on Jaunty :-(
04:13:13 <trofi^w> :[
04:14:24 <trin_cz> trofi^w: do you have ghc6.12.1?
04:15:13 <HugoDaniel> http://trac.haskell.org/SCC/wiki/monad-parallel  this seems very interesting
04:15:47 <trofi^w> trin_cz: yes
04:16:23 <trin_cz> trofi^w: then you need darcs version and http://haskell.org/gtk2hs/archives/2010/01/18/compiling-with-ghc-612/
04:16:59 <trofi^w> yes, i know. we've already backported ghc-6.12 fix to gtk2hs-0.10.1 in gentoo
04:17:32 <trofi^w> upstream got quite a lot new fiatures, which broke build once again
04:19:41 <trin_cz> trofi^w: ah ...
04:20:35 <trofi^w> gtk2hs-0.10.1-* ones: http://code.haskell.org/gentoo/gentoo-haskell/dev-haskell/gtk2hs/files/
04:25:57 <SubStack> @faq Is haskell blub yet?
04:25:57 <lambdabot> The answer is: Yes! Haskell can do that.
04:26:45 <SubStack> that'll be the day....
04:34:57 <Peaker> Anyone here knows graphics-imagecombinators?
04:35:14 <Peaker> I am wondering if I can "crop" images with it, and later compose the cropped images, and I think that might be impossible
04:35:17 <pozic> Peaker: I know that there is little reason to use it.
04:36:05 <Peaker> pozic: really, why?
04:36:06 <pozic> Is there anything that can draw 3d line segments via a kind of plot interface without getting the opengl shotgun?
04:36:25 <pozic> Peaker: because it doesn't do anything advanced.
04:37:09 <Peaker> pozic: that doesn't mean there's little reason to use it :)  Most of the drawing I need is very simple
04:37:34 <Peaker> pozic: For advanced things, I'm thinking of extending it
04:37:35 <Peaker> pozic: what alternative do you recommend?
04:37:46 <Peaker> imperatively using OpenGL Is far uglier than using a functional interface like drawingcombinators..
04:37:51 <pozic> Peaker: ok, well, if it fits your problem, go for it. Every time I think it might be useful I find some reason why it doesn't work.
04:38:14 <Peaker> pozic: I've just hit my first problem -- I think I can't crop
04:39:10 <pozic> Peaker: anyway, in these case it is often the case that you find that the initial assumptions made by the library completely don't work with what you need, so you end up rewriting the whole library.
04:40:49 <Peaker> pozic: what alternative is there?
04:41:37 <pozic> Peaker: roll your own unless you are convinced that drawingcombinators is perfect.
04:42:05 <pozic> There simply are not that much useful Haskell libraries available other than the most basic things (like ByteStrings).
04:43:02 <Peaker> pozic: I found the library situation in Haskell much better than that of Python for a lot of the things I've been doing..
04:44:13 * hackagebot transformers 0.2.0.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.2.0.0 (RossPaterson)
04:44:15 * hackagebot monads-fd 0.1.0.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.1.0.0 (RossPaterson)
04:44:27 <pozic> Peaker: where is the triangulation library for Haskell?
04:44:45 <pozic> Peaker: where is the Boost binding?
04:45:07 <Peaker> pozic: triangulation?
04:45:12 <Peaker> pozic: I don't care about C++ :)
04:45:14 * hackagebot leksah-server 0.8.0.5 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.5 (JuergenNicklischFranken)
04:45:22 <Peaker> or, I care, in a bad way :)
04:45:25 <pozic> Peaker: ?
04:45:41 <pozic> Peaker: what does triangulation have to do with C++?
04:45:53 <Peaker> pozic: The C++ response was about Boost
04:46:21 <Peaker> pozic: I'm not sure what you mean by triangulation? You mean tessalation? It's done in graphics libraries (e.g: FieldTrip)
04:46:50 <pozic> Peaker: Boost has some non-trivial algorithms implemented.
04:47:08 <Peaker> oh, distance-to-a-point.. That sounds trivial
04:47:13 <pozic> Peaker: what specifically does FieldTrip implement and with what complexity?
04:47:28 <Peaker> pozic: I misunderstood you -- FieldTrip does something else
04:47:44 <pozic> Peaker: no, you did understand correctly the first time.
04:47:54 <pozic> Peaker: triangulation can be done in higher dimensions.
04:47:59 <Peaker> pozic: FieldTrip lets you purely functionally define 3d geometries and renders them efficiently
04:48:01 <pozic> Peaker: (on simplices)
04:49:21 <pozic> Peaker: there are a lot of ways to triangulate a surface. I am pretty sure that the most advanced methods are larger in terms of code size than the whole of FieldTrip.
04:49:30 <pozic> Peaker: so FieldTrip must do something trivial..
04:49:39 <Peaker> pozic: I guess it depends on what field you're working in.  In the field of graphics, file handling, process invocation, and various other things I found Haskell no less (sometimes more) apt than Python, which I find more apt than C++/boost and most other languages
04:49:40 <pozic> Peaker: and thus cannot be used for anything but a toy.
04:50:06 <bremner> pozic: you might well be correct, but assertions like that without looking at the code leave a bad taste
04:50:15 * hackagebot monads-tf 0.1.0.0 - Monad classes, using type families  http://hackage.haskell.org/package/monads-tf-0.1.0.0 (RossPaterson)
04:50:16 <pozic> bremner: I did look at the code.
04:50:23 <pozic> bremner: and I saw nothing of interest.
04:50:34 <Peaker> pozic: FieldTrip does some pretty nice things.  A one-liner or few-liner to define: http://www.youtube.com/watch?v=WNB5V9Z7Obc
04:51:18 <bremner> pozic: anyway, if you really care about triangulation, I doubt Boost is the ne plus ultra. CGAL is a more likely place to start.
04:51:19 <pozic> Peaker: a nice demo proving nothing.
04:51:30 <Peaker> pozic: proving you can do really nice things with very little code :)
04:51:36 <pozic> bremner: right, CGAL has basically everything.
04:51:57 <bremner> pozic: not really, CGAL is mostly only good in low dimensions
04:52:16 <pozic> bremner: do you know how Geometry Code obtained the rights to all the code?
04:52:31 <pozic> bremner: AFAIK, it was work by universities.
04:52:44 <Peaker> well, a myriad of incompatible libraries with their own String type in the C++ world is something I'd happily replace with hackage :)
04:52:50 <pozic> Er Geometry Factory
04:52:55 <bremner> I think it is a spin-off from the project. Yeah, EU projects have weird ideas about IP.
04:53:31 <bremner> pozic: definitely all the work is done in Universities (or places like INRIA)
04:53:42 <pozic> bremner: so who owns the spin-off?
04:54:00 <pozic> It seems it is owned by someone who just implemented one module.
04:54:01 <bremner> pozic: roughly speaking, the project
04:54:11 <pozic> bremner: so, all its members share in the profits?
04:54:11 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24388#a24388
04:54:14 <Peaker> the C++ standard library is pretty horribly designed - which leaves library authors either reimplementing it, or building their libraries on a broken base
04:54:21 <ksf> any ideas on how to make that even cooler?
04:54:28 <bremner> pozic: I _think_ so, but I don't know the details.
04:54:47 <ksf> (I should really start linewrapping my haddock
04:54:55 <zygoloid> Peaker: some bits of it are pretty nice ;-) though i'll admit std::basic_string should be taken out and shot
04:54:57 <pozic> bremner: considering that tax money paid it, I don't understand how a company can be created closing it all off.
04:55:02 <ksf> it's a tex thing, where I do each paragraph on one line.
04:55:49 <bremner> pozic: like I say, EU projects are odd. People there are still stuck in the mindset of "free = free for non-commercial use"
04:57:18 <pozic> bremner: isn't there EU regulation for that?
04:57:24 <bremner> pozic: but maybe take this to #haskell-blah or something? it drifted pretty far from Haskell?
04:57:37 <Peaker> zygoloid: Without type-classes and without Hindley Milner types, a language is doomed to be so wrong in so many ways..
04:57:40 <pozic> bremner: OK
04:57:41 <ksf> both the INRIA and Frauenhofer are way pre-EU
04:58:26 <ksf> ...and at least Fraunhofer isn't a government entity, and I don't think they recieve many funds if any.
04:58:51 <pozic> ksf: #haskell-blah
04:59:20 <ksf> ...I'm already there.
05:00:19 <zygoloid> Peaker: well, without those or similar systems, at least, yeah. though iterators are a reasonably nice, composable way of faking up lazy lists, given the straitjacket of c++ ;-)
05:02:17 <pastorn> i'm thinking of applying for a SoC project...
05:02:34 <pastorn> i'm looking through the list now, but i dunno...
05:02:44 <Peaker> pozic: so what keeps you using Haskell if you hate the libraries so much?
05:02:46 <pastorn> what "good" projects aren't taken yet?
05:03:01 <Peaker> I love the libraries, btw, much nicer to use a library with a pure interface than a Python/C++ library
05:03:29 <ivanm> pastorn: what are you interested in?
05:03:31 <Peaker> pastorn: I have a lot of ideas on my TODO list and so little time carry any of them out (most might be too large for SoC)
05:03:57 <pastorn> ivanm: i'd like to build a 3D engine using GPipe
05:04:19 <pastorn> to see if haskell is a good game development language
05:04:40 <pastorn> ivanm: doesn't even have to be GPipe
05:05:13 <pozic> Peaker: the language itself is pretty good.
05:05:29 <pastorn> or maybe write directX bindings for haskell
05:06:08 <ivanm> pastorn: then propose that...
05:06:12 <Peaker> pozic: what languages do you like the libraries of?  C++ I'm guessing?
05:06:20 <ivanm> obligatory "directX bindings? ewwww!"
05:06:29 <pastorn> ivanm: heh, well
05:06:36 <pastorn> that's how most games are written
05:06:45 <pastorn> but still, GL is fine
05:07:30 <pozic> Peaker: I like how C has an ABI and C++ indeed has quite some useful libraries.
05:08:18 <ivanm> pastorn: using directX immediately limits your target haskell audience for testing, etc.
05:08:34 <pastorn> ivanm: true
05:08:43 <burp> and your karma :P
05:09:47 <pastorn> is GPipe a worthy cause?
05:09:59 <pozic> pastorn: DirectX and OpenGL are two different things.
05:10:04 * ivanm has no idea what GPipe is, and thus can't comment
05:10:08 <pozic> pastorn: Direct3D and OpenGL can be compared.
05:10:25 <ivanm> and IIRC, the guy from id had a good blog post about why you should use opengl for games rather than directx
05:10:44 <pastorn> ivanm: John Carmac
05:10:50 <pastorn> (or maybe with a k...)
05:10:58 <ivanm> pastorn: there's already a GPipe library
05:10:59 <Botje> yes, with a k
05:11:07 <pastorn> ivanm: yeah, but it needs work
05:11:07 <ivanm> don't know if it's the same gpipe you're thinking of though...
05:11:11 <ivanm> pastorn: that's the one
05:11:23 <pastorn> and it needs examlpes!
05:11:34 <ivanm> pastorn: possible problem: not of immediately obvious use enough to be worth a GSoC
05:11:36 <pastorn> there's literally no code or guide on how to use the library
05:11:46 <Peaker> so, does anyone know of a good purely functional graphics library? Alternatively, how to extend graphics-drawingcombinators to support cropping? Need some GL knowledge..
05:12:08 * ivanm would consider taking a leave of absence from his PhD to do a GSoC, but he hasn't been doing it for that long and thinks his supervisor might be a tad annoyed...
05:12:10 <ivanm> maybe next year
05:12:23 <pastorn> ivanm: not fair! you have a job
05:12:28 <pastorn> !!
05:12:35 <Botje> still a phd /student/ :P
05:12:37 <ivanm> no I don't!
05:12:43 <Peaker> Should this really enable FTGL anti-aliasing?  polygonSmooth $= Enabled       Using FTGL the fonts look far far worse than using SDL-ttf
05:12:45 <ivanm> I have a _stipend/scholarship_
05:12:58 <pastorn> ivanm: how much do get each month?
05:12:59 <ksf> pastorn, there's lambdacube
05:13:01 <ivanm> if I had a job, I'd be earning at least twice as much as my stipend provides
05:13:11 <ivanm> pastorn: ummm..... about AUD$2k I think
05:13:13 <ksf> and I fear gpipe doesn't work well with multiple textures in a scene.
05:13:32 <ivanm> I get AU$26k a year (at least for this year)
05:13:50 <ivanm> so just over 2k a month
05:13:51 <pastorn> ivanm: i get 8000 SEK each month
05:14:00 <pastorn> and nothing during the summer
05:14:24 <pastorn> ivanm: and once you're done you're gonna make a shitload of money
05:14:25 <ivanm> pastorn: but what is that in terms of living costs?
05:14:33 <ivanm> direct currency comparisons make no sense
05:14:49 <ivanm> pastorn: uhhh.... I'm doing a PhD in CS focusing on graph generation algorithms
05:15:06 <ivanm> I doubt I'll be making a "shitload" (both metric and imperial) of money when I finish
05:15:29 <pastorn> ivanm: having a PhD is worth more than a normal degree
05:15:43 <pastorn> (salary-wise)
05:15:44 <ivanm> yes
05:15:47 <pastorn> there you go
05:15:49 <ivanm> but in terms of employment...
05:15:54 <pastorn> huh?
05:15:55 <ivanm> besides, I want to go the academia route
05:16:02 <Botje> it also makes you less willing to do stupid crap like code PHP for a living :P
05:16:11 <pastorn> Botje: hehe
05:16:21 <ivanm> pastorn: my PhD topic isn't directly translatable to the "real world" AFAIK
05:16:24 * Botje is also a freshly minted phd student
05:16:28 <ivanm> Botje: heh
05:16:40 * Botje also teaches haskell^Wfunctional programming
05:16:43 <ivanm> Botje: so you're still nice and shiny with no finger smudges?
05:16:57 <Botje> correct! pristine condition still in the box!
05:17:01 <SamB_XP> Botje: hmm, don't you mean "provides a convenient excuse for being less willing to [...]" ?
05:17:05 <medfly> the more education you get, the less willing you are to do simple, annoying things
05:18:36 * ivanm tries to wrap his head around his partially-recursive Arbitrary instances
05:19:03 <medfly> see, when you get a lot of education, you complain 8000 sek a month to do stuff you like is little ;)
05:21:00 <ksf> no comments on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24388#a24388 ?
05:22:09 <ksf> what I'd actually need is overloaded data types.
05:22:40 <ksf> so that O_CREAT | O_WRITE can be translated to toSubSet O_CREAT | toSubSet O_WRITE
05:24:22 <ksf> or a sane enum class that can work with more than Ints. It'd be the day haskell went sane.
05:26:27 <Peaker> ksf: if you define a Functor/Applicative instance for BitSet, you could use liftA2 and fmap instead of the "unBitSet" and such :)
05:26:29 <ivanm> eh, that's enough coding for tonight; I'll finish it off tomorrow (hopefully)
05:26:53 <ksf> Peaker++
05:27:46 <Peaker> mappend = liftA2 (.|.)
05:27:54 <ksf> wait but that doesn't help me define the instances
05:28:21 <ksf> I'm way more concerned with usage that the backing code.
05:28:47 <ksf> ...though I've been too lazy to do TH deriving, yet.
05:32:52 <haskoso> Hi!
05:33:01 <haskoso> I'm trying to import other units
05:33:09 <haskoso> but the interpreter gives me error
05:33:31 <haskoso> I'm doing "import Tools"
05:33:49 <haskoso> and I recive     Could not find module `Tools':
05:34:02 <haskoso> Using GHTC under Eclipse GAVAB utility
05:34:29 <pastorn> anyone know how to use the ghci trace thingy?
05:34:43 <pastorn> i just used > :trace main
05:34:59 <Botje> haskoso: where is Tools.hs located?
05:35:05 <pastorn> and now i reached Stopped at <exception thrown>
05:35:07 <pastorn> _exception :: e = _
05:35:09 <pastorn> [<exception thrown>] *Main>
05:35:31 <Botje> pastorn: you can :force e, i think
05:35:38 <Botje> or you can print e, which should force it as well
05:35:50 <Botje> (err, exception)
05:37:15 <haskoso> Botje: in the same folder than the file
05:37:44 <haskoso>  /home/xxx/workspace/practicablp/src/Addition.h and  /home/xxx/workspace/practicablp/src/Tool.h
05:37:49 <haskoso> ups, Tools.hs
05:37:59 <haskoso> they are in the same folder
05:40:17 <Botje> and Tools.hs creates "module Tools where ..." ?
05:40:22 <Botje> *contains
05:40:44 <kalven> is there something in the standard library for dropping the last n items of a list? (that is: take ((length lst) - n) lst)
05:41:15 <Botje> do you know how long the list is?
05:41:21 <kalven> nope
05:41:35 <kalven> I know it'll have more than n items at least
05:41:51 <Botje> then i don't think there is a built-in
05:42:01 <Cale> > let xs = [1..10] in zipWith const xs (drop 4 xs)
05:42:02 <lambdabot>   [1,2,3,4,5,6]
05:42:05 <Botje> why do you need the last n elements of a list?
05:42:18 <Cale> ^^ that's probably the prettiest way
05:42:20 <Botje> wow, right
05:42:22 <Botje> Cale++
05:42:36 <Cale> (at least conceptually)
05:42:38 <Botje> i'm just going to refrain from trying to help people, today is not my day
05:42:49 <kalven> thanks
05:43:28 <Botje> << paper
05:46:01 <Cale> > let xs = [1..10] in zipWith const <*> drop 4 $ xs
05:46:02 <lambdabot>   [1,2,3,4,5,6]
05:48:47 <SubStack> is there a trick to include a big block of data at compile time into the compiled program?
05:49:49 <bremner> SubStack: what kind of data?
05:49:51 <SubStack> if there is such a trick I won't need to worry about setting up a deployment environment in the filesystem
05:50:03 <RichardBarrell> Uh, I guess you could do that by abusing the C FFI enough, but what kind of data?
05:50:17 <SubStack> c++ source code
05:50:38 <SubStack> which sounds really terrible when I type it out
05:51:01 <bremner> SubStack: tricks to avoid deployment systems are usually what ruby-on-rails people are up to, so yeah, it sounds terrible :)
05:51:17 <SubStack> but I'm writing a glsl cpu compatability layer
05:52:06 <SubStack> I *could* use quasiquotes and paste the source files myself
05:52:22 <SubStack> but I was hoping there was something better
05:52:43 <pozic> SubStack: you want to do what?!
05:52:48 <SubStack> I know right?
05:53:24 <SubStack> pozic: a cpu compatability system for glsl shaders
05:54:00 <RichardBarrell> Pasting the sources, quoted, is the simplest option from a build system perspective. There are other things that you can do, but they make your makefiles more complicated.
05:54:28 <SubStack> I'm not concerned about makefile complications
05:54:30 <pozic> SubStack: do you want to execute this C++ source code?
05:54:37 <SubStack> pozic: sometimes
05:54:55 <RichardBarrell> Save yourself some trouble though and do the quoting with a short Haskell program rather than by hand.
05:55:36 <SubStack> that could work
05:56:03 <haskoso> Botje, sorry, I was looking the code
05:56:17 <haskoso> and the webchat does not advise me when new message received
05:56:20 <RichardBarrell> You could even make your makefile all complicated and automate that step too ;)
05:56:34 <haskoso> the module tools in the header only have
05:56:34 <SubStack> hmmmm
05:56:42 <haskoso> module Tools where
05:56:51 <haskoso> and the functions
05:57:28 <Botje> haskoso: then you'll have to fiddle with your compiler options to let GHC look in the correct place, i think.
05:58:25 <haskoso> I am using the "run" tool that comes with IDE
05:58:46 <haskoso> I'm going to try the compiler alone and tell
06:00:16 <Botje> i don't know the IDE you're using, but you should be doing ghc --make instead of just ghc
06:01:13 <haskoso> It's a modification of the Java Eclipse IDE by one of my university departments
06:01:33 <haskoso> So don't worry, it's not so famous
06:01:59 <haskoso> I don't want to put all in a single module
06:02:06 <haskoso> but it looks like it will be the solution
06:18:12 <Peaker> glOrtho is in OpenGL Raw module, it seems, what am I supposed to use instead?
06:18:49 <Zao> Some fancypants vector library, or it?
06:18:54 <Zao> Or gluOrthoNN?
06:20:47 <Peaker> Zao: where is that?
06:20:59 <Zao> No idea.
06:21:05 <Zao> Haskell OpenGL is a mess.
06:21:44 <stevenmarky> offtopic question, Zao do you also frequent #gamedev on afternet
06:21:49 <Zao> stevenmarky: Yes.
06:22:43 <stevenmarky> cool.
06:26:05 <stevenmarky> also offtopic: I discovered a haiku in one of our error messages today (in some 6 year old software) : "A broken teacup, cannot hold the April rain, Memory leaking"
06:27:05 <quicksilver> Peaker: ortho2D?
06:28:10 <HugoDaniel> just do software render
06:28:15 <HugoDaniel> its the way of the future
06:29:59 <pokoko222> good morning mortals
06:30:22 <Peaker> quicksilver: thanks
06:30:28 <stevenmarky> good morning omnipotent one
06:31:56 <Peaker> HugoDaniel: it's the way of the non-lazy
06:32:20 <Peaker> maybe I ought to just give up on my OpenGL/GLUT effort and switch back to SDL
06:32:34 <Peaker> Can anyone confirm whether or not SDL bindings work on OS X?
06:33:51 <HugoDaniel> Peaker: just glfw it
06:34:11 <HugoDaniel> put a screen aligned quad, and use sw render to draw onto it
06:34:15 <HugoDaniel> :)
06:37:28 <Peaker> I still can't get OpenGL to anti-alias my FTGL fonts
06:37:38 <Peaker> the SDL TTF looks much much better than the FTGL
06:38:08 <Zao> Got the wrong min/max-ification filters?
06:38:21 <Peaker> Zao: I'm using luqui's drawing-combinators
06:38:34 <Zao> Beats me then.
06:38:39 <Zao> Silly abstractions :)
06:38:59 <Peaker> Zao: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24389
06:39:04 <Peaker> that's the set-up
06:39:14 <Peaker> it's really nice to be able to compose images functionally :)
06:40:09 <HugoDaniel> yes, fonts suck
06:40:11 <Zao> Those would be filters you set when creating your GL texture (which I assume FTGL uses).
06:40:15 <Zao> Text is hard.
06:40:28 <Peaker> SDL-ttf gets it right -- the fonts look great
06:40:37 <Peaker> (it doesn't use GL)
06:40:51 <Zao> Got a screenshot of the horrible fonts?
06:40:52 <Peaker> Zao: so do you think that setup code is wrong?
06:41:01 <Zao> An image says more than a thousand words when it's about graphics.
06:41:17 <Peaker> making one
06:42:56 <EvanR-work> reading about blocking behavior on this page http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Control-Concurrent.html, im confused about what is considered a 'foreign call' and what is 'merely an i/o action'
06:43:11 <EvanR-work> does socket i/o count as foreign calls
06:45:13 <Peaker> Zao: http://imgur.com/nZujO
06:45:26 <Peaker> took me a while, cause I have no idea how to image manipulate :) Tried GNU paint - which sucked. Gimp was OK
06:45:43 <Peaker> Zao: left one is SDL-ttf, right is FTGL
06:45:53 <Peaker> well, the PNG quality ruined it some
06:45:58 <Peaker> but you can still see the difference
06:46:01 <Zao> PNG is lossless, you know.
06:46:09 <Zao> Unless you pre-mutilate when saving.
06:46:37 <Zao> For starters, is FTGL bitmap or vector based?
06:46:58 <Zao> If the former, check for quality flags to configure subpixel behaviour.
06:47:05 <Peaker> that's funny, imgur recompressed the PNG to a *larger* size with *less* quality
06:47:07 <Zao> If the latter, enable GL antialiasing and All Should Be Well.
06:47:21 <BT4> Hello
06:47:25 <Peaker> Zao: it's the same true-type font, so I suppose it's vector-based?
06:47:37 <Zao> Peaker: You can use FreeType in two ways.
06:47:57 <Zao> Peaker: Either you tell it to rasterise, or you tell it to give you friendly spline outlines.
06:48:29 <Zao> Judging by the docs, FTGL does all of the above, and more.
06:48:35 <Zao> It all depends on how you use it.
06:48:36 <Peaker> Zao: drawingcombinators uses FTGL thus: FTGL.createPolygonFont, FTGL.setFontFaceSize, FTGL.renderFont (getFont font) str FTGL.All
06:48:54 <Peaker> I'll go read FTGL documentation now
06:48:57 <Zao> Are you on a nvidia card?
06:49:03 <Peaker> yeah
06:49:13 <Zao> Set the __GL_FSAA_MODE environment variable.
06:49:28 <Zao> To, uhm...
06:49:42 <Peaker> 1?
06:49:51 <Zao> One of the values gotten from   nvidia-settings --query=fsaa --verbose
06:50:00 <Zao> The values mean different things on different GPUs.
06:50:45 <Peaker> Zao: cool! it did make a difference
06:51:08 <Zao> Then the "smooth" modes you set are not AA, they're just friendly hints I'd reckon.
06:51:23 <Zao> Whine at whoever made whatever package you use maybe?
06:52:20 <Peaker> Zao: this is in drawingcombinators too: GL.hint GL.LineSmooth GL.$= GL.DontCare
06:52:23 <Peaker> does it matter?
06:52:29 <Zao> Probably just affects lines.
06:53:12 <Zao> I believe that requesting an antialiased mode is rather platform dependant, and those states you refer to are legacy thingies that may once have had sane semantics.
06:53:21 <Zao> GL is a mess, and it's been too long since I hacked on it.
06:54:27 <Peaker> Zao: :-(
06:54:31 <Peaker> Zao: Thanks a lot!
06:54:41 <Peaker> Computing is in such a sad state of affairs...
06:55:19 <pokoko222> anyone has done multi agent systems programming in haskell?
06:55:50 <fax> mauke
06:55:53 <Peaker> what is multi-agent systems programming?
06:56:47 <pokoko222> Peaker google it, AI stuff
06:57:29 <luite> bah you need specialized languages for that! apparently the best way to build multi-agent systems is to use huge xml files to describe them, with java code in those xml files
06:58:21 <luite> (at least I had to use such a language in a course about those things, wasn't the best course I have had...)
06:59:35 <medfly> >.<
07:02:47 <pokoko222> luite can u give me link to the course?
07:03:12 <pokoko222> what kind of systems, i am talking about BDI architecture
07:14:45 <fax> ?djinn (b -> a, p -> q) -> (c -> b, q -> r) -> (c -> a, p -> r)
07:14:45 <lambdabot> f (a, b) (c, d) = (\ e -> a (c e), \ f -> d (b f))
07:15:38 <lpsmith> ok,  I installed the windows installer for gtk2hs,  and Haskell Platform 2009.2.0.1,   but how do I use ghc-pkg register to make the gtk2hs packages show up in the global package configuration?
07:16:21 <dcoutts> lpsmith: it does it automatically, are you sure gtk2hs installed ok?
07:16:34 <dcoutts> lpsmith: do you have multiple ghc versions installed?
07:16:40 <lpsmith> not on windows
07:17:09 <lpsmith> And it complained that it couldn't find a working ghc install, even though it found the directory and that ghc install worked
07:17:09 <dcoutts> lpsmith: if it cannot find the right ghc version it should complain during installation
07:18:10 <lpsmith> I mean,  I can cabal install stuff,  and run ghc(i) just fine,  but for some reason the gtk2hs installer complained
07:18:12 <dcoutts> lpsmith: you're sure the error message wasn't saying that it found a version of ghc but not the version it needs?
07:18:44 <dcoutts> lpsmith: unless they've updated it, the version on the gtk2hs download page is built for an earlier ghc version
07:18:46 <lpsmith> well,  I installed 2009.2.0.1 because it came with ghc-6.10.3
07:19:07 <lpsmith> I don't know if it's a windows 7 incompatibility of some sort...
07:22:36 <dcoutts> lpsmith: so it reports that if it cannot find the ghc lib dir
07:23:14 <dcoutts> wait, no, if it cannot find the version properly
07:23:16 <lpsmith> I'm pretty sure it said "could not find a working ghc install" or something close tot that
07:25:12 <dcoutts> lpsmith: yes, reading the logic in the installer, it reports that if it find the ghc install dir but if it cannot determine the version
07:25:20 <dcoutts> by running ghc.exe --numeric-version
07:26:05 <lpsmith> well, when I run ghc.exe --numeric-version,  it returns 6.10.3 just fine
07:26:16 <dcoutts> lpsmith: you might get more detail from running the installer with logginf
07:26:19 <dcoutts> logging
07:26:27 <lpsmith> how do I do that?
07:26:39 <dcoutts> something like /LOG
07:27:58 <dcoutts> lpsmith: yes, /LOG or /LOG="filename"
07:28:20 <dcoutts> if you don't specify it ends up in your TEMP dir
07:32:54 <lpsmith> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24390#a24390
07:34:26 <dcoutts> lpsmith: hmm, I bet it is quoting that's going wrong
07:34:30 <dcoutts> paths with spaces
07:35:10 <dcoutts> lpsmith: it's actually running cmd.exe /C ${pathtoghc} --numeric-version > tmpfile
07:35:12 <lpsmith> dcoutts:  yeah,  I was just thinking about that myself.  I'm already in the process of reinstalling the Haskell Platform to someplace without spaces
07:35:33 <dcoutts> lpsmith: would you mind trying it from the command line
07:35:51 <lpsmith> dcoutts: sure,  how?
07:35:53 <dcoutts> run cmd.exe /C C:\Prog.. (etc) --numeric-version
07:36:03 <lpsmith> oh
07:36:06 <dcoutts> lpsmith: and then do it again with "" around the path name
07:36:25 <dcoutts> i.e. cmd.exe /C "C:\Prog.. (etc)... /bin/ghc.exe" --numeric-version
07:41:11 <lpsmith> dcoutts: yes, the spaces would be the issue,  fixed if you use quotes.   I was pretty sure you were right,  but I confirmed it by trying to run what you wanted
07:41:34 <dcoutts> lpsmith: thanks!
07:42:17 * lpsmith thinks I may have read about not installing the Haskell Platform into a location with spaces in the path... 
07:42:35 <lpsmith> But I don't use Windows frequently enough to remember stuff like that
07:42:54 <Zao> lpsmith: The default path is in Program Files (x86), which leads to great amusement.
07:43:06 <Zao> gtk2hs is one of the packages that goes insane over spaces in GHC paths.
07:44:17 <quicksilver> I bet, secretly, that's the reason Apple chose its system dirs not to have spaces in
07:44:24 <quicksilver> so they could be compatible with badly written unix shell scripts
07:44:30 <Jafet> Three cheers for sh(1)
07:44:58 <quicksilver> "$@" ftw?
07:48:11 <marekw2143> http://pastie.org/888340 - in ghci calling roots 10 20 30 returns (NaN, NaN)
07:49:50 <benmachine> marekw2143: what were you expecting?
07:49:51 <Zao> marekw2143: sqrt is real?
07:49:59 <Zao> > sqrt -1
07:50:00 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:50:00 <lambdabot>    arising from the literal `1' at <...
07:50:18 <Zao> > sqrt (-1)
07:50:19 <lambdabot>   NaN
07:50:20 <benmachine> 20 * 20 = 400, 4 * 10 * 30 = 1200, 400 - 1200 = -800
07:50:26 <benmachine> actually sqrt is polymorphic
07:50:28 <twink> > sqrt (-1) :: Complex Double
07:50:29 <lambdabot>   (-0.0) :+ 1.0
07:50:48 <Zao> benmachine: Bah.
07:50:48 <benmachine> but has probably been defaulted to Double here
07:51:00 <marekw2143> true, thanks
07:51:20 <twink> > let i = sqrt (-1) :: Complex Double in i ** i
07:51:21 <lambdabot>   0.20787957635076193 :+ 0.0
07:51:51 <burp> huh
07:52:00 <fax> o_O
07:52:17 <fax> > e^pi
07:52:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:52:18 <lambdabot>    `GHC.Real.Integral a'
07:52:18 <lambdabot>   ...
07:52:24 <twink> > let i = sqrt (-1) :: Complex Double in i ** i - exp (-pi / 2)
07:52:24 <Taejo> twink: sqrt (-1) is better known as (0 :+ 1) btw
07:52:25 <lambdabot>   0.0 :+ 0.0
07:52:41 <fax> > e^(-pi/2) :: Double
07:52:42 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:52:42 <lambdabot>         against inferred ty...
07:52:47 <fax> > exp(-pi/2) :: Double
07:52:48 <lambdabot>   0.20787957635076193
07:54:26 <burp> hm, (^2) . sqrt $ -1 :: Double .. can ghc optimize this away to -1? :>
07:54:35 <benmachine> no
07:54:54 <benmachine> that would technically be incorrect
07:55:01 <twink> That's a Cauchy principal value. i ** i is really multivalued, where the logarithms of i crop up, like (exp (pi*i/2 + 2*pi*i*k)) ** i == exp (-pi/2 - 2*pi*k) where k is any integer, positive, negative, or 0.
07:55:05 <burp> ah yes, double..
07:55:16 <burp> never mind
07:55:37 <fax> > log (sqrt (-1)) :: Complex Double
07:55:38 <benmachine> with doubles, you can't even optimise x + 0 to x :(
07:55:38 <lambdabot>   0.0 :+ 1.5707963267948966
07:55:50 <fax> @let c c = c :: Complex Double
07:55:51 <lambdabot>  Defined.
07:56:02 <dcoutts> lpsmith: add yourself to the cc list here http://hackage.haskell.org/trac/gtk2hs/ticket/1165
07:56:07 <fax> > c (log i/log i)
07:56:08 <lambdabot>   Ambiguous occurrence `c'
07:56:08 <lambdabot>  It could refer to either `L.c', defined at <local...
07:56:09 <burp> question is if it would harm anything :>
07:57:18 <fax> making undefined values turn into arbitrary defined values should never break a program
07:57:36 <benmachine> but sqrt (-1) is defined
07:57:37 <benmachine> as NaN
07:57:54 <benmachine> making floating-point arithmetic even more special-casey and weird is just ew
07:57:59 <burp> ok, but in general.. (^2) . sqrt
07:58:24 <burp> is there anything that would optimizing this away by any compiler in any language harmful?
07:58:24 <djahandarie> > -0.000000000000000000000000000000000000000001 :: Double
07:58:25 <lambdabot>   -1.0e-42
07:58:33 <djahandarie> Oh yeah
07:58:35 * djahandarie is and idiot
07:58:41 <djahandarie> Was trying to get it to round to -0
07:58:48 <fax> > (-1.0e-42)*(-1.0e-42)
07:58:49 <lambdabot>   1.0e-84
07:59:07 <djahandarie> > -1.9*0
07:59:08 <lambdabot>   -0.0
07:59:14 <djahandarie> \o/
07:59:27 <fax> > -0.0
07:59:28 <lambdabot>   -0.0
07:59:29 <fax> > -0.0 == 0.0
07:59:30 <lambdabot>   True
07:59:33 <djahandarie> > sqrt (-0)
07:59:34 <benmachine> burp: it'll probably almost always work and then trip you up in a tiny corner case and it'll take you forever to work out why
07:59:34 <lambdabot>   -0.0
07:59:35 <fax> > show (-0.0) == show (0.0)
07:59:36 <lambdabot>   False
08:00:11 <fax> @quickcheck \(x :: Double) (y::Double) -> show x == show y
08:00:11 <lambdabot> Unknown command, try @list
08:00:13 <benmachine> burp: it's also an incredibly specific optimisation and if you ask the compiler to look for every function/inverse pair ever it's just going to waste time
08:00:14 <fax> @check \(x :: Double) (y::Double) -> show x == show y
08:00:15 <lambdabot>   Parse error in pattern at "(y::D..." (column 16)
08:00:29 <fax> @check (\x y -> show x == show y) :: Double -> Double -> String
08:00:30 <lambdabot>   Couldn't match expected type `GHC.Types.Double
08:00:40 <fax> @check (\x y -> show (x::Double) == show (y::Double))
08:00:40 <lambdabot>   "Falsifiable, after 1 tests:\n2.0\n2.5\n"
08:00:44 <benmachine> heh
08:00:49 <fax> @check (\x y -> x == y ==> show (x::Double) == show (y::Double))
08:00:49 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:00:50 <lambdabot>                     (Test.QuickCh...
08:01:05 <benmachine> :t (==>)
08:01:06 <lambdabot>     Ambiguous occurrence `==>'
08:01:06 <lambdabot>     It could refer to either `Lava.==>', imported from Lava
08:01:06 <lambdabot>                           or `Test.QuickCheck.==>', imported from Test.QuickCheck
08:01:08 <fax> @check (\x y -> let p ==> q = p || not q in x == y ==> show (x::Double) == show (y::Double))
08:01:09 <lambdabot>   Precedence parsing error
08:01:09 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
08:01:16 <benmachine> what the hell is Lava >:|
08:02:03 <pozic> A hardware description language that nobody uses?
08:02:06 <fax> @check (\x y -> let p ==> q = not p || q in (x == y) ==> (show (x::Double) == show (y::Double)))
08:02:06 <lambdabot>   "OK, passed 500 tests."
08:02:36 <benmachine> @check (\x -> x < 10e9)
08:02:37 <lambdabot>   "OK, passed 500 tests."
08:02:38 <fax> so quick check isn't testing 0.0 vs -0.0
08:02:45 <benmachine> ALL NUMBERS ARE LESS THAN A BILLION.
08:02:51 <fax> @check (\x -> x < 10e5)
08:02:51 <lambdabot>   "OK, passed 500 tests."
08:02:52 <dankna> very amusing.
08:02:53 <fax> hehe
08:02:59 <fax> gee what's the biggest number??
08:03:09 <benmachine> it's probably not consistent
08:03:10 <medfly> @check (\x -> x < 10e4)
08:03:10 <lambdabot>   "OK, passed 500 tests."
08:03:13 <medfly> @check (\x -> x < 10e3)
08:03:14 <lambdabot>   "OK, passed 500 tests."
08:03:16 <medfly> @check (\x -> x < 10e2)
08:03:17 <lambdabot>   "OK, passed 500 tests."
08:03:19 <medfly> ...
08:03:24 <fax> @check (\x -> x < 1000)
08:03:24 <lambdabot>   "OK, passed 500 tests."
08:03:31 <medfly> @check (\x -> x < 10)
08:03:32 <lambdabot>   "Falsifiable, after 33 tests:\n16\n"
08:03:37 <medfly> it's probably around 500
08:03:40 <medfly> @check (\x -> x < 501)
08:03:41 <lambdabot>   "OK, passed 500 tests."
08:03:41 <benmachine> nah
08:03:47 <medfly> @check (\x -> x < 500)
08:03:48 <lambdabot>   "OK, passed 500 tests."
08:03:50 <benmachine> probably around 250, given negative numbers
08:03:50 <fax> "the biggest number is probably around 500"
08:03:51 <medfly> @check (\x -> x < 450)
08:03:52 <lambdabot>   "OK, passed 500 tests."
08:03:54 <medfly> @check (\x -> x < 250)
08:03:55 <lambdabot>   "OK, passed 500 tests."
08:04:00 <medfly> @check (\x -> x < 249)
08:04:01 <lambdabot>   "OK, passed 500 tests."
08:04:03 <medfly> @check (\x -> x < 248)
08:04:04 <lambdabot>   "OK, passed 500 tests."
08:04:07 <medfly> @check (\x -> x < 200)
08:04:08 <lambdabot>   "OK, passed 500 tests."
08:04:11 <benmachine> actually, given doubles, it depends entirely on the distribution
08:04:12 <medfly> @check (\x -> x < 150)
08:04:12 <lambdabot>   "Falsifiable, after 493 tests:\n158\n"
08:04:18 <medfly> @check (\x -> x < 180)
08:04:19 <lambdabot>   "Falsifiable, after 391 tests:\n183\n"
08:04:25 <benmachine> see, inconsistent
08:04:25 <fax> this is great news for finitism
08:04:34 <medfly> it sure is
08:04:52 <medfly> it turns out 10e2 is bigger than the biggest number.
08:05:45 <benmachine> oh hold on, we weren't testing doubles
08:05:49 <benmachine> we were testing Integers
08:05:50 <benmachine> oh well
08:06:06 <mail> oh well
08:06:18 <twink> I wonder if anything out there generates Lava from moderately high-level programming languages.
08:17:53 <HandheldPenguin> Can someone give me some pointers with this? http://codepad.org/mjDkNzj6
08:18:01 <HandheldPenguin> It's just an output problem
08:18:10 <HandheldPenguin> Explained in paste
08:19:03 <pastorn> i want a syntax highlighter for haskell code
08:19:06 <pastorn> CSS
08:19:14 <HandheldPenguin> notepad++
08:19:16 <pastorn> google gives me nothing
08:19:20 <pastorn> HandheldPenguin: CSS
08:19:26 <HandheldPenguin> ?
08:19:35 <pastorn> i want syntax highlighting for this: http://web.student.chalmers.se/~goranssa/Tut2.html
08:19:39 <pastorn> check the source
08:20:12 <benmachine> @hackage highlighting-kate
08:20:12 <lambdabot> http://hackage.haskell.org/package/highlighting-kate
08:20:21 <HandheldPenguin> Oh I get you now
08:20:51 <swiftorific> @hackage hscolour
08:20:52 <lambdabot> http://hackage.haskell.org/package/hscolour
08:21:13 <benmachine> HandheldPenguin: you seem to ignore ys completely?
08:21:17 <swiftorific> hscolour is pretty good. Can output in HTML+CSS or just HTML I think
08:21:42 <HandheldPenguin> benmachine: yeah that's my problem it needs to sort print each multiple out in order
08:21:46 <marekw2143> assume that f is function that takes 3 args: a, b and c, then what does it mean f a (c b) ?
08:21:48 <HandheldPenguin> But can't work out how to do it
08:21:58 <Cale> HandheldPenguin: You're not using ys anywhere in the definition of multiples
08:22:18 <swiftorific> pastorn: I seem to recall a Haskell plugin for http://code.google.com/p/syntaxhighlighter/ too
08:22:33 <benmachine> HandheldPenguin: maybe write a separate function that given two ascending lists merges then
08:22:36 <benmachine> *them
08:22:49 <Cale> Yeah, you're definitely going to want an ordered merge
08:23:12 <HandheldPenguin> ok
08:23:29 <Cale> (why such a function is not available in Data.List, I have no idea)
08:24:11 <dankna> the standard libraries are a little weak in general on list- and string-processing, yeah.
08:24:31 <pastorn> isn't there a predefined CSS file for highlighting haskell?
08:24:45 <swiftorific> CSS doesn't work like that
08:24:53 <dankna> pastorn: well, you can't do it with just CSS, you need annotatations in the HTML as well
08:24:56 <dankna> <spans> or whatever
08:24:56 <swiftorific> Its for formatting HTML tags, not text.
08:25:05 <pastorn> dankna: i have that... look at my source
08:25:11 <pastorn> <3 <3 <3 pandoc <3 <3 <3
08:25:22 <dankna> oh.  well, then I would look at what hscolour uses and see if you can just copy it over.
08:26:08 <dankna> probably will need to rename some span classes, but.
08:27:18 <EvanR-work> ok
08:27:46 <EvanR-work> how do i catch Prelude.read: no parser errors
08:27:55 <pastorn> EvanR-work: you don't
08:27:59 <pastorn> use parsec :p
08:27:59 <EvanR-work> ?
08:28:00 <benmachine> you use reads
08:28:04 <pastorn> or that
08:28:07 <EvanR-work> parsec
08:28:14 <pastorn> EvanR-work: have you ever used parsec?
08:28:16 <benmachine> well parsec doesn't do everything that reads does
08:28:17 <EvanR-work> i just want to convert an string into an integer
08:28:22 <EvanR-work> read "1234"
08:28:24 <EvanR-work> come on
08:28:28 <fax> come on?
08:28:29 <Cale> > read "1234" :: Integer
08:28:30 <lambdabot>   1234
08:28:33 <benmachine> reads is the error-handling way to do it
08:28:35 <Cale> works
08:28:39 <EvanR-work> i know
08:28:45 <EvanR-work> ill look at reads
08:28:51 <Cale> > reads "1234" :: [(Integer, String)]
08:28:52 <lambdabot>   [(1234,"")]
08:28:57 <Cale> > reads "1234apple" :: [(Integer, String)]
08:28:58 <lambdabot>   [(1234,"apple")]
08:29:02 <Cale> > reads "apple" :: [(Integer, String)]
08:29:03 <lambdabot>   []
08:29:03 <pastorn> EvanR-work: s2i s = if all isDigit s then read s :: Integer else error "contains non-digits"
08:29:18 <benmachine> pastorn: error kind of defeats the point there :P
08:29:18 <pastorn> @hoogle isDigit
08:29:19 <lambdabot> Data.Char isDigit :: Char -> Bool
08:29:23 <EvanR-work> i just want it to return Just a if its succeeds and Nothing other wise
08:29:37 <dankna> > case reads "1234" of { ((result,""):_) -> Just result ; _ -> Nothing }
08:29:38 <lambdabot>   Nothing
08:29:44 <pastorn> EvanR-work: s2i s = if all isDigit s then Junh (read s :: Integer) else Nothing
08:29:51 <dankna> > case reads "1234" of { ((result,""):_) -> Just result ; _ -> Nothing } :: Maybe Integer
08:29:51 <lambdabot>   Just 1234
08:29:55 <dankna> > case reads "1234foo" of { ((result,""):_) -> Just result ; _ -> Nothing } :: Maybe Integer
08:29:56 <lambdabot>   Nothing
08:30:03 <benmachine> :t foldr (Just . snd . const) Nothing . reads
08:30:04 <lambdabot>     Couldn't match expected type `b -> b'
08:30:05 <lambdabot>            against inferred type `Maybe a'
08:30:05 <lambdabot>     In the first argument of `(.)', namely `Just'
08:30:10 <dankna> notice that I required it to consume the entire input by pattern-matching the "".  you don't have to do that.
08:30:18 <EvanR-work> benmachine: wow
08:30:26 <int-e> > (read "1234  " :: Integer, (reads :: ReadS Integer) "1234  ")
08:30:27 <lambdabot>   (1234,[(1234,"  ")])
08:30:29 <benmachine> EvanR-work: wow, it didn't work? >_>
08:30:43 <EvanR-work> benmachine: thats awesome
08:31:07 <dankna> @pl case reads "1234" of { ((result,""):_) -> Just result ; _ -> Nothing } :: Maybe Integer
08:31:07 <lambdabot> (line 1, column 22):
08:31:08 <lambdabot> unexpected "{"
08:31:08 <lambdabot> expecting variable, "(", operator or end of input
08:31:10 <benmachine> :t foldr (const . Just . snd) Nothing . reads
08:31:11 <lambdabot>     Ambiguous type variable `a' in the constraint:
08:31:11 <lambdabot>       `Read a' arising from a use of `reads' at <interactive>:1:37-41
08:31:11 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
08:31:21 <misk20> i so much like haskell, but find very difficult to use in daily programming, any tips ?
08:31:22 <dankna> I guess @pl only works on expressions without cases
08:31:25 <benmachine> :t fromInteger . foldr (const . Just . snd) Nothing . reads
08:31:26 <lambdabot>     Couldn't match expected type `Integer'
08:31:26 <lambdabot>            against inferred type `Maybe b'
08:31:26 <lambdabot>     In the first argument of `(.)', namely
08:31:33 <benmachine> bah whatever :P
08:31:43 <benmachine> :t fmap fromInteger . foldr (const . Just . snd) Nothing . reads
08:31:44 <lambdabot>     Couldn't match expected type `Integer'
08:31:44 <lambdabot>            against inferred type `[Char]'
08:31:44 <lambdabot>       Expected type: String -> [(a, Integer)]
08:31:55 <EvanR-work> o_O
08:31:55 <benmachine> oh, duh
08:31:57 <int-e> > let readMaybe a = case [val | (val, s) <- reads a, all isSpace s] of [a] -> Just a; _ -> Nothing in readMaybe "1234  " :: Maybe Integer
08:31:58 <lambdabot>   Just 1234
08:32:00 <benmachine> :t fmap fromInteger . foldr (const . Just . fst) Nothing . reads
08:32:01 <lambdabot> forall a. (Num a) => String -> Maybe a
08:32:08 <benmachine> finally
08:32:16 <dankna> I wondered what that snd was doing there :)
08:32:17 <pastorn> @type (\s -> if all isDigit s then Just (read s :: Integer) else Nothing)
08:32:18 <lambdabot> [Char] -> Maybe Integer
08:32:22 <pastorn> EvanR-work: ^^
08:32:24 <dankna> but I assumed you knew something I didn't, haha
08:32:31 <benmachine> heh
08:32:36 <benmachine> never assume I know anything :x
08:32:39 <dankna> amusement
08:32:56 <EvanR-work> like 100 answers
08:33:00 <EvanR-work> last night i got like none ;)
08:33:03 <benmachine> heh
08:33:05 <dankna> this channel loves a challenge ;)
08:33:07 <benmachine> luck of the draw
08:33:08 <int-e> @quote fugue
08:33:08 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:33:16 <dankna> int-e: that rules
08:33:37 <pastorn> EvanR-work: will you string conain *only* the int? or do you want to take the numbers and keep the remainder of the string?
08:33:53 <int-e> Text.Read defines a readEither locally ... but it isn't exported :-(
08:33:58 <pastorn> EvanR-work: :: String -> (Maybe Int, String) ?
08:34:00 <EvanR-work> pastorn: well, its going to have a new line, and read handles that
08:34:31 <dankna> ask#haskell :: String -> [(String, TypeRep)]
08:34:47 <pastorn> EvanR-work: what are you working on? :)
08:35:10 <EvanR-work> something connects, sends 'a number\n' and closes connection
08:35:15 <EvanR-work> do something with the number
08:36:05 <dankna> what's your end goal?  just to learn, or is there going to be more to it?
08:36:09 <dankna> just curious
08:36:09 <benmachine> read discards trailing whitespace
08:36:13 <pastorn> EvanR-work: hGetLine >>= runNumber . parseNumeber
08:36:17 <benmachine> reads gives it to you to discard
08:36:22 <EvanR-work> pastorn: yeah
08:36:31 <EvanR-work> but i dont want it to crash if they dont send a number
08:36:35 <dankna> > case reads "1234" of { ((result,"\n"):_) -> Just result ; _ -> Nothing } :: Maybe Integer
08:36:36 <lambdabot>   Nothing
08:36:40 <dankna> > case reads "1234\n" of { ((result,"\n"):_) -> Just result ; _ -> Nothing } :: Maybe Integer
08:36:41 <lambdabot>   Just 1234
08:36:55 <dankna> and so we see the advantage of the pattern-matching over the point-free :)
08:37:06 <pastorn> EvanR-work: hGetLine h >>= maybe (return ()) runNumber . str2MbInt
08:37:09 <benmachine> I'd go with (result, s) : _ | all isSpace s -> Just result
08:37:19 <dankna> ah yeah, that's a nicer approach
08:37:26 <EvanR-work> pastorn: runNumber?
08:37:28 <pastorn> EvanR-work: have you seen the function 'when'?
08:37:31 <EvanR-work> is that parsec
08:37:42 <pastorn> EvanR-work: no, that's your function
08:37:43 <dankna> @hoogle runNumber
08:37:43 <lambdabot> No results found
08:37:45 <dankna> oh
08:37:46 <pastorn> handling the number given
08:37:56 <EvanR-work> alright gotta get back to work
08:38:31 <dankna> :t log
08:38:32 <lambdabot> forall a. (Floating a) => a -> a
08:38:48 <EvanR-work> :t isDigit
08:38:49 <lambdabot> Char -> Bool
08:38:54 <EvanR-work> > isDigit '3'
08:38:55 <lambdabot>   True
08:39:06 <dankna> :t lg
08:39:07 <EvanR-work> why dont i have isDigit ...
08:39:07 <lambdabot> forall b. b -> [Char]
08:39:14 <dankna> it's in Data.Char
08:39:22 <EvanR-work> oh
08:39:31 <benmachine> > lg undefined
08:39:32 <lambdabot>   "life's good"
08:39:38 * dankna blinks
08:39:48 <EvanR-work> ?
08:39:52 * benmachine shrugs
08:39:56 <int-e> > read ('"':repeat '1') :: Integer
08:40:01 <lambdabot>  Terminated
08:40:18 <pastorn> EvanR-work: i was doing stuff with maybe and IO recently... i found this to be pretty helpful:
08:40:20 <pastorn> whenJust f mb = maybe (return ()) f mb
08:41:10 <dankna> > log 256 / log 2
08:41:14 <lambdabot>   8.0
08:41:27 <dankna> @let lg n = log n / log 2
08:41:29 <lambdabot>  <local>:11:0:
08:41:29 <lambdabot>      Multiple declarations of `L.lg'
08:41:29 <lambdabot>      Declared at: <local>...
08:41:34 <dankna> bah
08:41:39 <pastorn> > log 2
08:41:40 <lambdabot>   0.6931471805599453
08:41:42 <medfly> > log 5 / log e == log 5
08:41:43 <pastorn> > lg 2
08:41:45 <lambdabot>   False
08:41:47 <pastorn> > lg 2
08:41:47 <lambdabot>   mueval-core: Time limit exceeded
08:41:49 <lambdabot>   "life's good"
08:41:50 <medfly> > log 5 / log 10 == log 5
08:41:51 <lambdabot>   False
08:41:52 <Jonno_FTW> sure you don't want logBase (exp 1) 2?
08:41:58 <pastorn> > lg 2
08:42:00 <lambdabot>   "life's good"
08:42:00 <Cale> @undefine
08:42:02 <pastorn> hehe
08:42:11 <Cale> > logBase 2 8
08:42:12 <lambdabot>   3.0
08:42:30 <dankna> I would want logBase in general, but what I really want to do is define the common-in-mathematics abbreviation lg to be log base 2 :)
08:42:33 <Cale> @let lg = logBase 2
08:42:36 <lambdabot>  Defined.
08:42:40 <dankna> ah
08:42:44 <dankna> well, that works too :)
08:42:50 <misk20> if i define function like "suffix = init . tails" but not "suffix xs= init . tails xs" why ??
08:42:52 <dankna> thanks
08:42:54 <medfly> > log 5 / log 2 == log 5
08:42:55 <lambdabot>   False
08:43:00 <medfly> > log 5 / log (exp 1) == log 5
08:43:01 <lambdabot>   True
08:43:22 <misk20> i mean if i define function like "suffix = init . tails" it works but not "suffix xs= init . tails xs" why ??
08:43:54 <benmachine> > log 5 / log e == log 5
08:43:55 <lambdabot>   False
08:44:06 <Jonno_FTW> > e
08:44:07 <lambdabot>   e
08:44:12 <Jonno_FTW> :|
08:44:12 <medfly> :t e
08:44:14 <dankna> benmachine: it's base 10
08:44:14 <lambdabot> Expr
08:44:26 <Jonno_FTW> @src logBase
08:44:27 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:44:29 <medfly> > log 5 / log (exp 1) == log 5
08:44:30 <lambdabot>   True
08:44:32 <Jonno_FTW> @src log
08:44:32 <lambdabot> Source not found. Maybe you made a typo?
08:44:32 <medfly> > (exp 1)
08:44:33 <lambdabot>   2.718281828459045
08:44:38 <benmachine> dankna: I'm just trying to work out what caused lambdabot to timeout earlier
08:44:41 <dankna> oh
08:44:42 <dankna> okay
08:44:43 <benmachine> around the time something tried that
08:45:04 <dankna> I thought it timed out due to the (now-overwritten) definition of lg
08:45:14 <lispy> benmachine: just about everything :)
08:45:20 <benmachine> heh
08:45:34 <monochrom> misk20: precedences. (init . tails) xs
08:45:46 <benmachine> dankna: yeah, but the type signature of that log should have ignored its argument and just returned a string?
08:45:48 <jao> misk20: function application takes precedence over composition. init. tails xs means init . (tails xs)
08:45:54 <benmachine> but, whatever
08:45:59 <benmachine> I will go with lispy's explanation
08:46:01 <dankna> oh hm
08:46:02 <dankna> point.
08:46:04 <lispy> benmachine: she's on a virtual host with not a lot of ram.  Everytime she uses too much memory she grinds to a halt
08:46:33 <lispy> benmachine: one way to improve her would be to make her use a lot less memory for everything, eliminate space leaks, etc
08:46:39 <misk20> thx, i got it
08:46:54 <lispy> benmachine: but she's more or less unmaintained.  Cale does a lot to keep her running, but I don't think anyone is writing code
08:47:01 <benmachine> another would be to get rid of the show for functions, imo >_>
08:47:02 <Cale> Yeah, lambdabot's code really needs to be reworked.
08:47:22 <dankna> I have a very clean bot in Lisp that I might port over sometime, heh
08:47:40 <dankna> yes, my dirty secret, I was a Lisp user first.  but I'm a total convert, I love static typing now, haha.
08:47:42 <medfly> yeah, lambdabot sucks
08:47:49 <benmachine> @vixen do you suck
08:47:50 <lambdabot> i do occassionally, i guess
08:47:57 <Cale> hehe
08:47:58 <lispy> dankna: I have no idea what you're talking about ;)
08:47:59 <monochrom> ...
08:48:00 <medfly> along with Haskell. it doesn't do well at simple tasks like IRC bots.
08:48:01 <dankna> except for the part where lambdabot is highly useful despite all these flaws :)
08:48:03 <dankna> lispy: haha :)
08:48:12 <Cale> Also, mueval has the annoying property of putting a new file in /tmp on every single evaluation.
08:48:16 <medfly> maybe just stick to Lisp
08:48:19 <Cale> (and not cleaning them up)
08:48:26 <lispy> Cale: heh
08:48:31 <Cale> medfly: trolling is ineffective here, you know that.
08:48:33 <dankna> well, if I stuck to Lisp I couldn't do Haskell evaluation
08:48:42 <medfly> Cale, why is it trolling if its true
08:48:55 <dankna> also I don't think my particular bot is very Lisp-dependant
08:48:59 <dankna> I think it would work fine in Haskell
08:49:10 <monochrom> medfly: why is it trolling implies falsehood
08:49:24 <lispy> Haskell has become the language you use when you need quick development, correctness, and efficiency
08:49:25 <lispy> IMO
08:49:30 <medfly> it implies I'm saying bullshit to upset people. I'm saying true things to upset people
08:49:35 <gwern> Cale: why should mueval cleanup in /tmp?
08:49:40 <dankna> ooh ooh
08:49:41 <dankna> quote:
08:49:43 <gwern>  /tmp cleans itself
08:49:45 <medfly> Cale, YOU should clean up /tmp
08:49:45 <benmachine> gwern: because it's polite
08:49:53 <dankna> "A man came up to me and said / I'd like to change your mind / with wrong ideas that appeal to you / but I am not unkind."
08:49:58 * medfly gives Cale a broom
08:50:05 <dankna> ?
08:50:22 <gwern> dankna: good old they might be giants, eh
08:50:25 <dankna> quite so
08:50:33 <jmcarthur> is /tmp only cleaned on reboot or does a cron job typically do it, too?
08:50:36 <Cale> gwern: because /tmp *doesn't* clean itself, and I'm responsible for it
08:50:39 <dankna> typically only on reboot
08:50:46 <dankna> because cron has no way of knowing what's still in use
08:50:51 <jmcarthur> then i'd set something up to clean /tmp every once in a while
08:50:56 <monochrom> Your trolling skill is limited. It's easy to say true things to upset people too.
08:50:58 <jmcarthur> of the stuff i put there anyway
08:51:03 <dankna> well, that's nontrivial
08:51:14 <medfly> monochrom, it's what I did
08:51:19 <dankna> it's better for clients to clean up after themselves
08:51:29 <dankna> they're the only ones that know the rules about what's no longer needed
08:51:29 <jmcarthur> dankna: that's kind of what i meant
08:51:36 <dankna> hrm, okay
08:51:56 <monochrom> But the highest level is to say undecidable things to upset people.
08:51:58 <gwern> dankna: be kind of hard with mubot. what does the cleanup? the main thread in the main process? one of the watchdog threads or processes?
08:51:58 <dankna> monochrom: even if you disallow politics? :)
08:52:04 <gwern> *mueval
08:52:11 <dankna> gwern: hmm, I take your point
08:52:16 <EvanR-work> pastorn: hah. if all isDigit. fails on empty ;)
08:52:20 <medfly> monochrom, show me
08:52:25 <gwern> the point of mueval is paranoia, after all.
08:52:27 <Cale> I could just create a script which deletes all the files which look like they were created by mueval, but just fixing mueval to clean up after itself would be better.
08:52:37 <jmcarthur> monochrom: Static typing will never beat dynamic typing in the long run!
08:53:18 <Cale> gwern: I don't see how that has anything to do with it... if you create a temporary file, delete it when you're done, it's pretty simple ;)
08:53:19 <Guest91702> silahkan masuk Guest91702 silahkan chit-chat dimari..
08:53:28 <misk20> jao: one thing "init (tails xs)" also does the same thing then why use composition ?, any reason composition is better ?
08:53:28 <dankna> I guess I'd put the cleanup in the watchdog
08:53:29 --- mode: ChanServ set +o monochrom
08:53:32 <medfly> you're talking to yourself
08:53:37 <gwern> Cale: and suppose the expression timesout?
08:53:41 <Guest91702> silahkan masuk fasta silahkan chit-chat dimari..
08:53:45 <Guest91702> hi everybody
08:53:45 <pastorn> EvanR-work: && not (null s)
08:53:47 <Guest91702> silahkan masuk Nshag silahkan chit-chat dimari..
08:53:48 <Cale> gwern: Delete the file after.
08:53:57 <EvanR-work> pastorn: i put safeRead "" = Nothing ;)
08:53:59 <Guest91702> any Haskell guru from Indonesia here ?
08:54:05 <gwern> Cale: if the expression timesout, there's nothing to do the deleting after
08:54:06 <fasta> Please ban for life.
08:54:11 <gwern> because it's been killed
08:54:17 <pastorn> EvanR-work: haha... that's pretty lame :p
08:54:18 <Guest91702> silahkan masuk Serpentin silahkan chit-chat dimari..
08:54:22 --- mode: monochrom set +b #haskell!*@*
08:54:29 <benmachine> eeer
08:54:32 <Serpentin> Hijos de puta
08:54:33 <medfly> fasta, highlighting you unnecessarily should be punishable by death
08:54:34 <monochrom> un/ban #haskell
08:54:43 --- mode: monochrom set -b #haskell!*@*
08:54:46 <fasta> medfly, preferably.
08:54:58 <Cale> gwern: Can't set a trap to delete the file?
08:55:01 <medfly> you CAN troll this channel
08:55:13 <medfly> very effectivelly
08:55:14 <Cale> medfly: Sure, but you'll end up as a lambdabot plugin
08:55:17 <dankna> I don't know how the mueval code is architected, but it's not a hard problem in principle.  if you're doing evaluation in a monad, have a list of files that have been created; wrap the code that creates the file with something that adds to that list; use bracket just outside the timeout to clean up things in the list
08:55:17 <Cale> @keal
08:55:18 <lambdabot> can GMP support KealDigit? I invent KealDigit
08:55:25 <medfly> Cale, I can just highlight 650 people
08:55:28 * benmachine giggles
08:55:28 <jmcarthur> keal?
08:55:37 <medfly> I don't mind having a lambdabot plugin for that
08:55:37 <medfly> easier
08:55:43 <Cale> Keal was one of the more amusing trolls
08:55:48 <medfly> keal isn't a troll
08:55:53 <Cale> medfly: That's not trolling
08:55:59 <medfly> Cale, what is it?
08:56:01 <dankna> see
08:56:07 <dankna> the claim wasn't that we couldn't be trolled
08:56:11 <gwern> dankna: feel free to look at the mueval code. it's pretty straightforward
08:56:13 <fasta> medfly, trolling is like saying how OCaml is better than Haskell.
08:56:17 <dankna> the claim was something much more interesting  - that trolling is ineffective here
08:56:24 <dankna> gwern: I may do that, in my copious free time :)
08:56:32 <Cale> That's more on the side of crapflooding or just being a dick, which will get you a ban pretty quickly :)
08:56:38 <dankna> which I think is true.  because it's quickly recognized and deflected with layers of meta.
08:56:51 <medfly> Cale, so you do ban people. you're too weak to handle their trolling ability
08:56:52 <jmcarthur> haha
08:57:18 <jmcarthur> medfly: i wouldn't consider somebody who gets hit with the banhammer very quickly a good troll
08:57:25 <jmcarthur> more of a spammer
08:57:29 <dankna> I concur with jmc
08:57:32 <Cale> It's not weak to ban people for crapflooding. That's what bans are for.
08:57:32 <medfly> what if he pisses off at least 50 people?
08:57:35 <medfly> it's a win.
08:57:44 <medfly> way better than arguing with 3
08:57:49 <Cale> medfly: It's not a good troll though.
08:57:53 <gwern> dankna: the problem is that the thread doing the evaluating is the same thread that writes the files and is the only one that knows the file names. and that's the thread that has a dozen ways to error out or be killed
08:58:02 <jmcarthur> medfly: highlighting 50 people is not really so anger inducing
08:58:03 <Cale> It's a good way to irritate people, but not a good troll.
08:58:14 <medfly> a good troll by your definition is a guy that manages to piss off 3 people?
08:58:16 <gwern> dankna: so yeah, it could presumably remove the files, but it will 'leak' /tmp files
08:58:16 <mercury^> Good trolls are funny.
08:58:21 <mercury^> Highlighting the whole channel is not.
08:58:25 <medfly> I can piss off at least 50 by highlighting everyone.
08:58:33 <mercury^> It's not about pissing people off.
08:58:35 <dankna> gwern: I get that.  Okay, maybe instead of putting it in the evaluation monad it needs to be a Chan that informs the watchdog thread of the filenames... obviously the watchdog will need to sanitize those.
08:58:36 <Cale> Pissing people off isn't the same thing as trolling
08:58:38 <mercury^> It's about entertaining people.
08:58:46 <medfly> trolling isn't entertaining.
08:58:46 <jmcarthur> medfly: but then you will not get an opportunity to rub it in. you will just be banned
08:59:12 <benmachine> do we care what the definition of trolling is? :P
08:59:13 <jmcarthur> getting banned is a failure to troll properly
08:59:15 <medfly> jmcarthur, well, if I'm already flooding I can come prepared for it with multiple hosts
08:59:17 <gwern> dankna: well, it's not just a watchdog thread. there's a watchdog process too
08:59:23 <dankna> gwern: oooh nifty
08:59:31 <benmachine> do we really care about this trolling conversation at all
08:59:34 <benmachine> I suspect it is a red herring
08:59:37 <dankna> gwern: well, I'd have to look at it
08:59:39 <gwern> dankna: turns out ghc = teh suck when it comes to watchdog threads
08:59:45 <dankna> I see
08:59:57 <Cale> gwern: Maybe just have another thread decide on the name to use
09:00:12 <dankna> well, could implement a fake Chan on top of socketpair()
09:00:15 <gwern> (dankna: a thread in a tight non-allocating loop will never yield control to another thread)
09:00:23 <medfly> anyway, we get the idea, Haskell IRC bots are crappy IRC bots. I think even the Java one is better.
09:00:31 <benmachine> my testing framework thinks this test has failed but is dumping exactly. the. same. output for the test case and the actual result
09:00:32 <dankna> (gwern: not even with forkOS?)
09:00:34 <Cale> medfly: preflex is good
09:00:34 * benmachine sighs
09:00:39 <gwern> dankna: apparently not?
09:00:46 <benmachine> is preflex a haskell?
09:00:46 <dankna> curious.  I'd like to test that.
09:00:49 <benmachine> I thought it was a generic
09:00:56 <gwern> medfly: I think IRC would be a great testcase for FRP
09:01:26 <dankna> I don't totally get the concept of FRP, I admit.  it seems too simple so I don't think I've understood it correctly.
09:01:28 <medfly> #haskell should be ashamed until it fixes lambdabot
09:01:35 <gwern> I mean, it's halfway to interact's IO (String -> String), after all
09:01:42 <Cale> http://mauke.ath.cx/preflex/
09:01:43 <dankna> I don't know about that - lambdabot remains quite practical for the things it's good at
09:02:00 <benmachine> oh right
09:02:01 <benmachine> neat
09:02:03 <gwern> and a good deal of lambdabot
09:02:07 <gwern> has been outsourced
09:02:18 <gwern> mueval, hoogle, brainfuck, djinn, etc
09:02:23 <dankna> awww
09:02:27 <benmachine> lambdabot is a middle-person
09:02:28 <dankna> I tried to make my nick ?
09:02:32 <dankna> but freenode wouldn't let me
09:03:11 <dankna> for the record, if we were having this conversation via Jabber that would have been possible :)
09:03:26 <dankna> (but Jabber Multi-User-Chat clients suck.  that's another free-time project of mine.)
09:04:40 * Cale wants Unicode nicks, but then you'd end up with irritating people that put ZWNJs at the beginning of their nick, etc. etc. :)
09:04:56 <medfly> it's fucking IRC. deal with it
09:05:26 <medfly> you need to have 8 character alphanumeric nicks
09:05:43 <monochrom> ZWNJ = ?
09:05:46 <medfly> + some other things
09:05:47 <Zao> medfly: Preferably in a non-painful configuration.
09:05:51 <Cale> Zero width non-joiner
09:06:41 <monochrom> I see. would be amusing.
09:07:25 <djahandarie> lol quickcheck
09:07:39 --- mode: monochrom set -o monochrom
09:07:41 <djahandarie> I think the way it handles that is by some growing function for random number generator
09:08:10 <djahandarie> So with x more checks it would get C log x harder to fail
09:08:13 <medfly> @check (\x->x < 1000)
09:08:14 <lambdabot>   "OK, passed 500 tests."
09:08:25 <djahandarie> It was a while since I looked at the code though
09:08:43 <medfly> look how crappy Haskell is.
09:08:48 <djahandarie> If you look at the values it is passing, they should be random, but growing on some sort of trend
09:08:52 <djahandarie> medfly, shut up!!
09:09:06 <medfly> see? who said I'm a bad troll?
09:09:07 <benmachine> djahandarie: telling people to shut up doesn't work
09:09:15 * medfly smiles
09:09:19 <djahandarie> benmachine, can I use my fists
09:09:21 --- mode: ChanServ set +o monochrom
09:09:30 <benmachine> djahandarie: punch his name in your IRC window, that will help
09:09:33 --- mode: monochrom set +q medfly!*@*
09:09:56 <djahandarie> haha
09:10:14 <monochrom> I am weak, I can't handle trolls, yada yada. Bite me. Like I care what you think.
09:10:22 * benmachine hugs monochrom 
09:10:25 --- mode: monochrom set -o monochrom
09:10:26 <fasta> monochrom, can you also do that for #haskell-blah?
09:10:30 <fasta> monochrom, :D
09:10:41 <monochrom> I can't. I don't have op there, paradoxically.
09:10:59 <djahandarie> Poor medfly
09:13:04 <gbacon> when I try to build gtk2hs-0.10.1 on Ubuntu karmic, I run configure then make and get a long train of "file .../*.hi is missing (ignoring)" and, for example, "dependency "bytestring-0.9.1.5" doesn't exist (ignoring)"
09:13:21 <Zao> gbacon: ghc version?
09:13:37 <gbacon> Zao: 6.12.1
09:13:49 <Zao> http://haskell.org/gtk2hs/archives/2010/01/18/compiling-with-ghc-612/
09:14:26 <cycloid> Has anyone used quickcheck to test space/time properties of functions?  i.e., "should be linear in size of list", etc.
09:14:32 <gbacon> Zao: thanks! should I bite the bullet and go with a newer ghc?
09:14:34 <dankna> cycloid: oooh nice concept
09:15:12 <cycloid> danka: yah, I like it.  Not much clue on implementation ...
09:15:48 <fasta> cycloid, yes.
09:16:14 <fasta> cycloid, only time, though.
09:16:19 <dankna> cycloid: well I'll tell you one thing, testing it will churn cpu :)
09:16:31 <dankna> cycloid: but it strikes me as intriguing; you should write it up if you do it
09:17:10 <cycloid> fasta: if you know of a pointer to examples I'd love to look at them
09:17:30 <cycloid> dankna: I'll post if I make some progress
09:17:39 <dankna> excellent
09:17:48 <Zao> gbacon: 6.12.1 is the current newest. You can either chicken out to 6.10.4, or apply the patch to gtk2hs sources or fetch gtk2hs head.
09:22:11 <deech> Is there a library in Haskell which sends email?
09:22:48 <benmachine> someone mentioned a library called SMTPClient the other day
09:23:06 <benmachine> cabal list smtpclient
09:23:10 <deech> benmachine: thanks, I'll check it out!
09:23:17 <benmachine> hahaha
09:23:25 <benmachine> there are three that come out of that
09:23:27 <benmachine>     Synopsis: A simple SMTP client
09:23:30 <benmachine>     Synopsis: Simple SMTP Client
09:23:34 <benmachine>     Synopsis: Very simple SMTP Client
09:23:37 <dankna> haha!
09:23:38 <dankna> that rules
09:23:46 <benmachine> um
09:23:56 <benmachine> SMTPClient actually was mentioned here in the context of, not working
09:24:03 <benmachine> so maybe try the others >_>
09:24:04 <deech> oh
09:24:22 <monochrom> hahaha
09:26:06 <deech> There's also HaskellNet, any feedback on that library?
09:27:28 <benmachine> :t unzip
09:27:29 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
09:48:07 <c_wraith> I've got an application that's not running properly on the threaded runtime, but appears to be fine with the non-threaded runtime.
09:48:23 <dankna> what behavior are you seeing?
09:48:39 <c_wraith> depends on the system.  On my local system, it segfaults intermitttently
09:49:04 <c_wraith> In the production system, it halts hard (doesn't even respond to signals) intermittently
09:49:33 <dankna> hrm.
09:49:55 <dankna> it's truly unfortunate that it's so hard (impossible?) to get a stack dump of Haskell
09:50:03 <dankna> such a valuable debugging tool for situations like that
09:50:25 <dankna> are you using the FFI at all?  any other unsafe operations?
09:50:27 <Cale> The stack dump wouldn't be so useful, even if it were in the nicest possible format
09:50:35 <dankna> you mean because of aggressive inlining?
09:50:42 <dankna> I still think it would be useful
09:50:42 <c_wraith> it's using library code that does FFI.
09:50:52 <Cale> The stack that GHC uses just holds on to case expressions that are waiting for their scrutinees to evaluate
09:50:57 <c_wraith> hsdns and hdbc-postgres, at the very least
09:50:58 <dankna> c_wraith: try changing all the "unsafe" imports in the library to "safe"
09:50:59 <fax> hey cale
09:51:02 <Cale> It has nothing to do with function calls
09:51:06 <dankna> c_wraith: there's a performance penalty, but...
09:51:17 <Cale> There is no stack for function calls.
09:51:23 <dankna> Cale: that still sounds useful to me if they could somehow be associated with source lines
09:51:43 <dankna> Cale: fascinating information
09:51:45 <dankna> Cale: are you one of the ghc maintainers?
09:51:49 <Cale> No
09:51:51 <dankna> oh
09:52:03 <fasta> dankna, what can that possibly help?
09:52:04 <c_wraith> It also links to the curl bindings, but isn't actually using them in the setup both I and the production server have.
09:52:20 <dankna> fasta: "safe" imports don't crash if the library calls into Haskell and a GC occurs
09:52:27 <dankna> fasta: while within a call to that function
09:52:42 <dankna> fasta: I've had trouble before with functions calling into Haskell that I didn't think possibly could, and making that change fixed it
09:52:46 <fasta> dankna, are you sure it is not exactly the other way around?
09:52:58 <fasta> dankna, I am not sure, I must admit.
09:53:00 <dankna> fasta: in which regard?
09:53:08 <c_wraith> It's been suggested this may be a signal-handling problem...  The threaded runtime uses signals differently than the non-threaded runtime?
09:53:16 <dankna> c_wraith: hmm.
09:53:17 <fasta> dankna, that safe actually means "this call is safe, just trust me".
09:53:23 <dankna> fasta: yes, I'm sure
09:53:30 <fasta> dankna, ok, then I haven't said anything.
09:53:34 * fasta looks up FFI 
09:53:35 <dankna> fasta: hehe
09:53:48 <dankna> I wouldn't be amazed to learn that I got it backwards, but I'd be at least surprised :)
09:54:03 <dankna> since I have noticed the two possible interpretations before and made an effort to remember which is correct
09:54:55 <fasta> dankna, you are right.
09:55:02 <fasta> Safe actually is safer ;)
09:55:44 <dankna> fasta: good :) I rather thought I was
09:56:21 <fax> Our slogan is: category theory can provide a better and more natural understanding of
09:56:25 <fax> mathematical objects than set theory , so we use it to guide our tour around the world
09:56:28 <fax> of data types.
09:56:40 <dankna> fax: I dislike set theory, haha
09:56:50 <dankna> fax: but I'm not sure category theory is any more epistemologically healthy
09:57:01 <dankna> Cale: so yeah, it's at least worth trying that.  and then if it fixes your problem you can try to narrow down which call and why.
09:57:06 <fax> dankna, in what respect?
09:57:23 <fax> (and do you have some other preference?)
09:57:42 <dankna> fax: well, set theory has severe problems with defining things without any real motivation, in such a way that paradoxes are possible
09:58:15 <dankna> fax: and no, I'm not a mathematician.  but I note coming from a philosophical background that set theory has problems which are very hard for the outsider to sort out, although I'm sure they make sense to set theorists.
09:58:42 <fasta> dankna, are you referring to things like the AoC?
09:58:52 <fax> dankna, okay (and I agree with quite a lot of this) -- but what about your second point?
09:58:57 <dankna> fasta: sorry?
09:59:04 <fasta> dankna, Axiom of Choice.
09:59:08 <dankna> oh, yes, I am
09:59:25 <dankna> fax: I don't /understand/ category theory so I can't be sure it's healthier.  to be honest, I had never thought of it as a potential replacement for set theory until you just said that above.
09:59:40 <dankna> fax: now I'm going to have a lot of thinking and reading to do to try to decide that question :)
10:00:43 <fax> dankna, I'm learning it too!
10:00:48 <dankna> fax: fair enough :)
10:01:52 <ddarius> There was a quite a bit of effort in thinking about category theory as a foundation for mathematics, but I don't think most mathematicians worry about such issues nowadays and most categorists use category theory as a tool and don't care too much about foundations.
10:02:30 <dankna> which is a shame, because foundations are important
10:02:38 <ddarius> Not really.
10:02:41 <dankna> mm
10:03:10 <dankna> well, I disagree but I can't articulate quite why.  my father actually is writing a book on that exact point - why foundations in mathematics are important - but I haven't digested the ideas from it yet :)
10:03:16 <dankna> so I'm a little biased :)
10:04:20 <fax> fundations are cool
10:04:52 <fax> it's a similar perversion to learning all the different sorts of programming languages you can find
10:04:58 <ddarius> The vast majority of mathematics makes little reference or use of e.g. ZFC or whatever.  One way to think of it is most of mathematics is done in a high level language and would work with only minor (and usually unimportant) changes over any reasonable foundational system.
10:04:58 <fasta> In the end there is no foundation.
10:05:20 <djahandarie> Foundations d
10:05:25 <djahandarie> ...fail
10:05:29 <benmachine> there are lots of foundations and you pick whichever one you like
10:05:59 <ddarius> So, using that analogy, worrying about foundations for most mathematics is like worrying about which assembly language your Haskell code is being compiled to.
10:06:21 <fasta> Yes, since most results are "portable".
10:06:27 <ddarius> Exactly.
10:07:12 <dankna> mm.
10:07:39 <dankna> yes, I'm not sure it's that important to research mathematicians, but it's important to, say, teachers of mathematics
10:07:43 <ddarius> I definitely think it is good for some people to think about foundations and for most to have an idea about one or another (but then I think it is good to know assembly), but most mathematics in practice has little use for it.
10:07:46 <dankna> without foundations, how do you motivae what you're teaching?
10:07:56 <benmachine> the difference being that the foundations of mathematics are pretty, whereas assembly isn't :P
10:07:58 <ddarius> I've never seen foundations used as a motivation.
10:08:00 <dankna> (I think it's good to know assembly too)
10:08:13 <dankna> I find assembly pretty as long as you don't try to write anything too big in it :)
10:08:24 * fax just can't write anything in it
10:08:27 <dankna> well, I'm out of my depth, so I'm going to bow out of the conversation now
10:08:28 <benmachine> I don't think foundations are important, but that doesn't mean they're not fun
10:08:47 <benmachine> and most of the reason I do mathematics is because I enjoy it
10:08:51 <benmachine> I guess I'm lucky in that respect
10:08:52 <fax> dankna, in this book Sets for Mathematics (which Cale recommended) they axiomatize the category of sets
10:09:01 <dankna> oh, cool
10:09:04 <fax> dankna, and I think that can serve as a foundation
10:09:08 * dankna nods
10:09:17 <ddarius> fax: Yes, that was one of the approaches.
10:09:28 <ddarius> fax: Look up some work by Lawvere on that.
10:09:59 <fax> well this book is Lawvere and others
10:10:08 <fax> but I think it's just a tiny bit of his works...
10:10:20 <fax> he is very often cited in my other books
10:10:33 <ddarius> Well, yes.  Lawvere is all over category theory with a variety of interesting applications.
10:10:43 <ddarius> fax: Check out his site some time.
10:11:27 <fax> oh okay
10:11:42 <fasta> I think it would be cool to find some algorithms which work for no reason at all.
10:12:38 <benmachine> I recall a study in which someone used a genetic sort of system to devise a thing which distinguished input frequencies, where he had no idea how it worked
10:12:59 <benmachine> that was the vaguest sentence ever
10:13:07 <ddarius> benmachine: Yes, the FPGA thing.
10:13:16 <djahandarie> haha, not vague enough!
10:13:20 <benmachine> :)
10:13:24 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.92.5349&rep=rep1&type=pdf
10:13:40 <fasta> That is just a practical issue.
10:13:44 <ddarius> benmachine: He had some ideas.
10:14:16 <ddarius> But it was definitely exploiting things below the level of abstraction that FPGAs provide.
10:15:04 <fasta> I meant actually something which is completely formal and can be checked for correctness on a case by case basis, but has no inductive argument.
10:15:29 <fax> fasta I don't know what that means
10:15:42 <fax> like and undecidibly correct program ?
10:15:44 <benmachine> fasta: is it certain that such things exist?
10:15:49 <fasta> fax, yes.
10:16:13 <fasta> benmachine, AFAIK, yes.
10:16:33 <fasta> But AFAIK, there are no natural problems which have that property.
10:17:08 <benmachine> I suppose if your input was finite it wouldn't be too hard to imagine an algorithm that just fed your input through a bunch of nonsequitur transformations until all the answers lined up by sheer coincidence
10:18:38 <benmachine> surely for any infinite input it'd be impossible to "find" such algorithms
10:18:50 <ddarius> That's probably related to the fact that, unless you are working on language implementation, undecidability rarely raises its head.
10:19:56 <benmachine> such algorithms might exist, and we might find them, but we would not be able to prove that that is what they were
10:20:06 <ddarius> Indeed.
10:21:29 <benmachine> it would be kind of funny if we found an efficient method of factorising very large numbers into primes that worked in just few enough cases to be useless
10:22:39 <c_wraith> like...  factoring 2^n?
10:22:49 <c_wraith> I can write an algorithm for factoring 2^n into primes really fast.
10:22:55 <benmachine> heh
10:23:03 <benmachine> that's not "just" enough for me
10:23:12 <c_wraith> too few cases where it works?
10:23:14 <benmachine> yes
10:23:25 <benmachine> well
10:23:30 <benmachine> if you look hard enough
10:23:38 <c_wraith> How about numbers of the form 2^n*3^m ?
10:23:44 <benmachine> you're going to eventually push me into saying "it would be kind of funny if something happened that was funny"
10:24:11 <benmachine> can we accept that that at least is true
10:24:24 <c_wraith> depends on how grumpy I feel :)
10:24:31 <benmachine> heh
10:26:57 <fax> boolean <-> if statement
10:27:06 <fax> disjoint union <-> case statement
10:27:14 <fax> natural number <-> primitive recursion, for statement
10:27:27 <fax> function space <-> function call
10:27:35 <lament> apples <-> oranges
10:27:43 <fax> control structures in programming languages come out of the structure of data
10:27:46 <fax> types 
10:28:01 <dankna> this is an interesting observation
10:28:35 <lament> what about GOTO?
10:29:01 <lament> what about while loops?
10:29:20 <fax> I don't think they fit into this
10:29:30 <lament> no, they don't :)
10:29:37 <fax> ??????????
10:30:00 <lament> "some control structures..." is a much weaker and less interesting statement, though
10:30:02 <sbahra> Yet they are control structures.
10:30:09 <dankna> enumerations <-> integers/goto
10:30:14 <dankna> er
10:30:19 <dankna> enumerations <-> labels/goto
10:30:33 <sbahra> dankna, can you elaborate?
10:30:36 <dankna> yeah
10:30:46 <dankna> I'm thinking of the case where your function is a state machine
10:30:57 <dankna> I'm thinking specifically of C
10:31:18 <dankna> I've seen some machine-translated FORTRAN code which puts everything in one function so that it can use gotos, haha
10:31:37 <dankna> and in trying to make this comparison it occurred to me that the labels are an enumeration
10:32:06 <dankna> the set of possible labels being the elements of it
10:32:30 <sbahra> I see. I don't think that's a very useful comparison, shrug.
10:32:33 <dankna> I think the situation you get in modern C code where you use labels/gotos for error handling is different
10:32:41 <dankna> well, okay
10:32:44 <dankna> maybe it isn't :)
10:33:11 <lament> there doesn't need to be any data type involved in gotos
10:33:18 <lament> goto labels don't even need to be first-class anything
10:33:29 <dankna> hm
10:33:33 <lament> it's just parts of your program welded together
10:33:52 <lament> the label is just to make the welding easier, without actually having to bend the code-space :)
10:34:08 <dankna> well, the goal was to try to get some as-yet-unidentifier insight into language design by playing with this family of analogies :)
10:34:13 <dankna> *unidentified
10:34:19 <dankna> unidentifier was Freudian :)
10:36:11 <EvanR-work> is there a way to write a function that returns IO () but consists of an expression that is IO a (not ())
10:36:25 <kmc> EvanR-work, sure
10:36:27 <benmachine> what is the fixity of :
10:36:28 <kmc> :t getChar >> return ()
10:36:29 <lambdabot> IO ()
10:36:34 <EvanR-work> foo >> return ()
10:36:37 <kmc> EvanR-work, though technically that's not even a function
10:36:37 <EvanR-work> can i avoid the return ()
10:36:41 <benmachine> I thought I knew but HSE and ghci give me two answers and neither are what Ithought
10:36:53 <EvanR-work> kmc: well, theres a parameter
10:37:09 <kmc> EvanR-work, well if the type is actually polymorphic (IO a) then it will instantiate to (IO ()) just fine
10:37:22 <EvanR-work> really
10:37:32 <dankna> doItAndIgnoreTheResult interestingParameter = doInterestingStuff interestingParameter >> return ()
10:37:42 <benmachine> okay, can someone :i : for me in ghci
10:37:44 <EvanR-work> so (a -> IO a) can possibly return IO ()
10:37:45 <benmachine> and tell me if it lies to them
10:38:02 <kmc> :t \() -> throwIO Deadlock
10:38:03 <lambdabot> Not in scope: `throwIO'
10:38:03 <lambdabot> Not in scope: data constructor `Deadlock'
10:38:05 <benmachine> (for me it says infixr 5, but it patently isn't; haskell-src-exts says infixl 9, which it also isn't)
10:38:09 <kmc> :t Control.Exception.throwIO
10:38:10 <dankna> EvanR-work: only if it's passed ()
10:38:10 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> IO a
10:38:17 <kmc> :t Control.Exception.throwIO Control.Exception.Deadlock
10:38:18 <lambdabot> forall a. IO a
10:38:22 <EvanR-work> dankna: eh
10:38:22 <dankna> EvanR-work: (a -> IO a) is a different type from IO a :)
10:38:27 <kmc> EvanR-work, a value like that will instantiate to IO ()
10:38:33 <EvanR-work> how about
10:38:34 <kmc> :t \() -> Control.Exception.throwIO Control.Exception.Deadlock
10:38:35 <lambdabot> forall a. () -> IO a
10:38:39 <kmc> :t (\() -> Control.Exception.throwIO Control.Exception.Deadlock) :: () -> IO ()
10:38:40 <lambdabot> () -> IO ()
10:38:47 <EvanR-work> Maybe a -> (a -> IO b) -> IO b
10:39:05 <kmc> EvanR-work, but you rarely find IO actions of type forall a. IO a
10:39:11 <benmachine> oh no I am just doing something wrong
10:39:25 <kmc> they'd generally represent an error or exception of some kind, because you can't actually make good on the promise to provide a value of any type a whatsoever
10:39:28 <EvanR-work> kmc: right, but ...
10:39:50 <dankna> doItAndIgnoreTheResult maybeInterestingParameter = { case maybeInterestingParameter of Nothing -> return () ; Just interestingParameter -> doInterestingStuff interestingParameter >> return () }
10:39:58 <kmc> Maybe a -> (a -> IO b) -> IO (Maybe b) is easy
10:40:11 <kmc> as is that but returning Maybe (IO b) instead
10:40:40 <EvanR-work> ok
10:42:03 <EvanR-work> arg
10:42:09 <EvanR-work> what did you do
10:42:18 <djahandarie> ARG MATEY
10:42:25 <djahandarie> > pirate "test"
10:42:26 <lambdabot>   Not in scope: `pirate'
10:42:29 <djahandarie> :[
10:42:46 <aavogt> dankna: you are serious?
10:42:48 <djahandarie> > yoda "The trick is in the wrists."
10:42:49 <lambdabot>   Not in scope: `yoda'
10:42:50 <djahandarie> Damn
10:42:57 <dankna> aavogt: serious about what?
10:43:06 <dankna> aavogt: I'm sure there's a pointfree way to do it
10:43:16 <aavogt> @type maybe (return ()) void
10:43:17 <lambdabot> Not in scope: `void'
10:43:22 <kmc> :t flip $ maybe (return Nothing)
10:43:23 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => Maybe a1 -> (a1 -> m (Maybe a)) -> m (Maybe a)
10:43:24 <aavogt> @type maybe (return ()) (>> return ())
10:43:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m a) -> m ()
10:43:45 <djahandarie> > unwords . reverse . words $ "The trick is in the wrists."
10:43:46 <lambdabot>   "wrists. the in is trick The"
10:43:50 <dankna> aavogt: ah, the Maybe monad?  I know I should know it, but I don't :(
10:44:01 <dankna> aavogt: I still consider myself a learner with Haskell
10:44:14 <mauke> preflex: seen ivanm
10:44:14 <preflex>  ivanm was last seen on #haskell 5 hours, 17 minutes and 45 seconds ago, saying: eh, that's enough coding for tonight; I'll finish it off tomorrow (hopefully)
10:44:24 <mauke> ivanm: why do you think it's dead?
10:44:25 <kmc> i don't think that uses the maybe monad
10:44:28 <benmachine> dankna: actually, those don't use the maybe monad
10:44:32 <kmc> :t maybe
10:44:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:44:33 <benmachine> they just use the maybe function
10:44:36 * dankna sighs and goes to actually read them :)
10:44:43 <dankna> :t maybe
10:44:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:44:47 <aavogt> are you sure they do?
10:45:06 <benmachine> case expressions on Maybes and calls to maybe are usually interchangeable
10:45:21 <benmachine> and by usually, I mean always
10:45:24 <dankna> haha
10:45:36 <enderx86> hi
10:45:41 <enderx86> i am trying to gauge how active this channel is
10:45:43 <aavogt> depends if you want parentheses instead of builtin syntax
10:45:43 <djahandarie> :t shuffle
10:45:44 <dankna> okay, I see what that does
10:45:44 <benmachine> but sometimes not neatly
10:45:44 <lambdabot> Not in scope: `shuffle'
10:45:50 <benmachine> enderx86: this active <===>
10:45:56 <aavogt> enderx86: there are logs
10:45:57 <enderx86> which is more active, ##C or ##haskell?
10:46:12 <dankna> enderx86: well, I don't think ##haskell exists
10:46:14 <benmachine> #haskell is pretty active
10:46:22 <enderx86> which is more active, ##C or #haskell?
10:46:27 <aavogt> if you analyze logs, you can come up with a quantitative comparison
10:46:31 <enderx86> where are the logs?
10:46:35 <benmachine> more so than other channels for similarly-popular languages I think, because we're nicer
10:46:37 <monochrom> in the topic
10:46:53 <dankna> I agree that our traffic is due largely to our niceness
10:47:04 <djahandarie> Wasn't there something that generated cool graphs off those logs?
10:47:18 <dankna> there was, but it isn't run automatically, it needs to be done by hand.  iirc.
10:47:42 <dankna> and it generated more a list of "possibly amusing statistics" than a serious attempt at data mining.
10:47:54 <aavogt> what does it mean to have graphs like that? It's not as if people name eachother all that frequently
10:47:58 <dankna> not that there's anything wrong with that
10:48:24 <djahandarie> I meant charts, not actual graphs
10:48:30 <aavogt> or would you base that more on the assumption that people who talk at the same time are likely to be having some kind of conversation?
10:48:32 <dankna> well, I think a serious attempt at data mining might try to extract a social network based on who's talking at the same time about similar topics
10:48:38 <dankna> you'd have to extract a topic map first
10:48:58 <benmachine> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+foldr+f+z+%5B%5D+%3D+z%0D%0A++++foldr+f+z+%28x+%3A+xs%29+%3D+f+x+%28foldr+f+z+xs%29%0D%0A++++%5B%5D+%2B%2B+ys+%3D+ys%0D%0A++++%28x+%3A+xs%29+%2B%2B+ys+%3D+x+%3A+%28xs+%2B%2B+ys%29%0D%0A++in+foldr+%28%2B%2B%29+%5B%5D+%5B%5B1%5D%2C+%5B2%5D%2C+%5B3%5D%5D I fixed my bracketing \o/
10:49:00 <kmc> i like that the logs are updated in realtime
10:49:03 <benmachine> please try to break it
10:49:06 <benmachine> *parenthising
10:49:13 <dankna> kmc: I also!
10:49:48 <fax> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+x+%2B+x+in+double+%28double+3%29
10:49:51 <fax> doesn't do sharing ?
10:49:59 <djahandarie> Does anyone know Manlio Perillo
10:50:04 <benmachine> fax: no not yet
10:50:57 <mauke> 2107. (\ x -> x Time limit expired!
10:51:10 <monochrom> hahaha
10:51:16 <djahandarie> Huh?
10:51:30 <benmachine> fax: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+double+x+%3D+let+y+%3D+x+in+y+%2B+y+in+double+%28double+3%29 you can coerce it into sharing but it actually takes longer :P
10:53:54 <benmachine> hmm I should probably close the HTML properly when it does
10:53:56 <benmachine> *dies
10:56:26 <mauke> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%22a%3Cscript%3Ealert%28%27pwnd%27%29%3C%2Fscript%3E%22
10:56:34 <benmachine> mauke: :(
10:56:51 <benmachine> not sure what that will actually get you though
10:57:11 <mauke> it will let me steal cookies from www.srcf.ucam.org
10:57:20 <HugoDaniel> why doesn't let f (sqrt x) = x works ?
10:57:28 <HugoDaniel> but let f (n+1) = n works ?
10:57:35 <benmachine> HugoDaniel: the latter is a special case
10:57:44 <benmachine> mauke: what kind of cookies
10:57:45 <HugoDaniel> is it ? why ?
10:57:50 <mauke> benmachine: all of them
10:57:54 <benmachine> HugoDaniel: because some people thought it would be neat
10:58:18 <HugoDaniel> why ?!
10:58:30 <benmachine> HugoDaniel: it's removed in the next version of haskell :P
10:58:51 <benmachine> mauke: okay, do you know off the top of your head where I can find me an escaper
10:59:05 <mauke> benmachine: what?
10:59:06 <HugoDaniel> let duplicate(x+2) = (duplicate x) + (duplicate 2)
10:59:09 <HugoDaniel> seems usefull
10:59:16 <HugoDaniel> but i would like sqrt as well :D
10:59:24 <kmc> HugoDaniel, read about view patterns
10:59:29 <dankna> benmachine: "&" -> "&amp;", "<" -> "&lt;", ">" -> "&gt;" are the standard three.  note the order dependency.
10:59:43 <mauke> benmachine: what language is stepeval.cgi written in?
10:59:46 <benmachine> HugoDaniel: you can't do a pattern like that without the function having an inverse though
10:59:51 <benmachine> mauke: it's compiled Haskell
11:00:03 <mauke> benmachine: so just escape the output
11:00:10 <mauke> why do you need to "find an escaper"
11:00:11 <benmachine> ref. http://github.com/benmachine/stepeval
11:00:20 <benmachine> mauke: I don't *need* to
11:00:24 <HugoDaniel> benmachine: but sqrt x has an inverse...
11:00:41 <pastorn> HugoDaniel: you could do a deep embedding of maths
11:00:43 <benmachine> but I imagine that it's a sufficiently common task that someone else has already done it
11:00:47 <pastorn> and then it could work :)
11:00:57 <kmc> HugoDaniel, right, so you can write a view pattern for it
11:00:59 <benmachine> HugoDaniel: sqrt doesn't have an inverse when applied to negative numbers
11:00:59 <kmc> HugoDaniel, http://ryle-if-a.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns
11:01:16 <pastorn> HugoDaniel: data Math a = Val a | Add a a | Mul a a | Sqrt a
11:01:22 <kmc> lambdabot doesn't support view patterns for some reason
11:01:33 <pastorn> HugoDaniel: and then have  afunctionon applyMaths :: Math a -> a
11:01:49 <mauke> benmachine: dude, you're parsing query strings by hand, but you want prewritten code for html escaping?
11:02:02 <HugoDaniel> why is this going to be removed ?
11:02:08 <kmc> n+k patterns?
11:02:14 <benmachine> mauke: man, I only asked in case you knew immediately :P
11:02:16 <pastorn> HugoDaniel: it's ugly
11:02:20 <pastorn> or something...
11:02:44 <pastorn> What library should i use to generate HTML?
11:02:50 <HugoDaniel> pastorn: blazeHTML
11:02:52 <HugoDaniel> :)
11:02:55 <kmc> it's a silly special case that confuses people and isn't that useful
11:03:22 <HugoDaniel> so is it going to become an extension ? or is it going to disappear completely ?
11:03:49 <kmc> HugoDaniel, i imagine GHC will support it forever
11:03:54 <lispy> Does readFile add a newline to the end of the input, even if it's not present in the file?
11:03:57 <kmc> because GHC will always support Haskell 98 code
11:04:25 <lispy> Yikes, that seems to be the case
11:04:26 <cebewee> Besides the missing error checking, is the following a sensible implementation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24396#a24397
11:04:52 <kmc> don't know if you can get them in Haskell 2010 mode explicitly
11:05:01 <benmachine> kmc: I'd imagine that some day the a new version will be the default
11:05:02 <lispy> This strikes me as a bug
11:05:24 <kmc> HugoDaniel, http://hackage.haskell.org/trac/haskell-prime/wiki/NoNPlusKPatterns
11:05:42 <pastorn> lispy: read as bytestring and then do that magic casting to String?
11:05:43 <lispy> oh, maybe this file does end in a newline... hmm
11:05:54 <kmc> HugoDaniel, n+k patterns were *already* considered evil in Haskell 98, but they were included for compatibility with previous versions
11:07:04 * lispy updates his code to not care about newlines
11:07:18 <HugoDaniel> i was reading the wikipedia page about haskell
11:07:21 <HugoDaniel> and found them there...
11:07:24 <HugoDaniel> ...and i wondered...
11:07:29 <HugoDaniel> it was about it
11:07:46 <HugoDaniel> if they are evil, then they should definetly be removed from the wikipedia page
11:07:58 <EvanR-work> what, history rewriting?
11:08:07 <EvanR-work> remove satan from wikipedia too?
11:08:14 <HugoDaniel> :P
11:08:34 <HugoDaniel> its just my opinion, i wont argue
11:08:36 <kmc> it is a bit unreasonable to use them in examples then
11:08:51 <EvanR-work> what is unsafe about unsafePerformIO
11:09:02 <mauke> everything
11:09:16 <dankna> what is a non-rigid context?
11:09:22 <dankna> I don't understand this error message :)
11:09:28 <kmc> dankna, hpaste it and we'll help you
11:09:31 <dankna> okay
11:09:35 <kmc> hard to explain what a non-rigid context is
11:09:40 <dankna> fair
11:09:47 <kmc> EvanR-work, it breaks assumptions that GHC might make when optimizing your code
11:10:21 <kmc> and it lets you write other nasty things like unsafe type casts
11:10:30 <EvanR-work> so clearly avoid it. but what are some things you can do with it with reasonble certainty that nothing bad will happen
11:10:35 <kmc> which breaks the type system entirely
11:10:45 <kmc> EvanR-work, using unsafePerformIO is an alternative to modifying the compiler
11:11:04 <kmc> you take on a bunch of obligations to understand stuff "under the hood" which is normally safely abstracted away
11:11:23 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24398#a24398
11:11:50 <kmc> EvanR-work, one common use case is Debug.Trace
11:12:03 <kmc> (which you should just use directly, but it's implemented with uPIO)
11:12:25 <kmc> "trace" prints a message when a particular expression is evaluated
11:12:30 <EvanR-work> trace, ive been looking for some debug method
11:12:32 <kmc> which normally is impossible -- evaluation cannot cause IO to occur
11:12:53 <EvanR-work> nice
11:12:54 <kmc> even evaluating a value of IO type
11:12:58 <dankna> and then there's the use of it to create global MVars with a no-inlining annotation
11:12:59 <kmc> but it's a useful hack :)
11:13:01 <benmachine> I used unsafePerformIO with threadDelay once to fake an expensive computation
11:13:10 <dankna> benmachine: ha :D
11:13:12 <dankna> clever
11:13:15 <pastorn> benmachine: NICE!
11:13:35 <benmachine> which was handy for testing `par` stuff
11:13:46 <dankna> yeah, I'm gonna remember that one if I do go poking in the mueval code
11:14:34 <kmc> benmachine, clever
11:15:12 <dankna> so um
11:15:24 <dankna> the error message, as you can see in the hpaste above, suggests adding a type signature to "something"
11:15:30 <dankna> but as far as I can see everything already has a type defined
11:15:32 <kmc> that's a lot of code
11:15:47 <kmc> and heh, a remarkably useless error message
11:15:49 <dankna> kmc: yes it is, I excerpted it as best I was able.  this is why I didn't want to hpaste if I could avoid it :)
11:16:52 <kmc> dankna, add a type signature for oldColumnDefinitions and newColumnDefinitions
11:16:57 <dankna> trying that
11:17:33 <dankna> oh hey
11:17:37 <dankna> I can't, and that tells me what my problem was
11:17:39 <benmachine> mauke: http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%22a%3Cscript%3Ealert%28%27pwnd%27%29%3C%2Fscript%3E%22 satisfied? :P
11:17:45 <kmc> dankna, what was the problem?
11:17:53 <benmachine> (apart from the fact that it's actually pretty silly to expand the thing out like that)
11:18:01 <dankna> they aren't [ColumnDefinition], they're OneOrMore ColumnDefinition
11:18:02 <benmachine> (hmm, maybe I can fix that to not happen now)
11:18:20 <dankna> which I can't match against because the constructor for OneOrMore is deliberately not exported
11:18:38 <dankna> perhaps this is a job for view patterns?  is it possible to define a view pattern and export it without exporting the constructor?
11:18:48 <benmachine> yeah
11:18:49 <kmc> which constructor?
11:18:51 <dankna> great
11:18:55 <benmachine> well
11:18:58 <dankna> the constructor is MkOneOrMore [a]
11:19:01 <kmc> the typical use case of view patterns is to map an abstract type to a concrete one
11:19:02 <benmachine> you don't define view patterns really
11:19:06 <Zao> Use a guard with whatever functions you have available?
11:20:07 <dankna> Zao: hmm.
11:20:09 <Peaker> EvanR-work: "unsafePerformIO" is OK for actions that are actually pure and have no side effects.. A composition of impure IO actions may result in a pure action (e.g: Save registers, load registers, add registers into result, restore registers = pure addition implemented as a composition of impure things)
11:20:28 <dankna> yeah, I'm reading http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns now
11:20:43 <Zao> dankna: If none of the guards of a pattern match, it falls through to the next pattern.
11:20:48 <mauke> benmachine: 
11:21:09 <benmachine> mauke: thanks for bringing that to my attention btw :)
11:21:13 * benmachine e-hug mauke
11:21:40 <dankna> Zao: good to know.  I'm not exactly seeing what a guard buys me though.
11:22:29 <Zao> dankna: If whatever library you're using exposes a isOneOrMore or some other function to query/manipulate your thingie, it might be useful.
11:22:33 <Zao> I haven't tracked the context.
11:23:40 <dankna> Zao: (it's my own library, btw.  4000 lines - I'm very proud of it.)  the type is already known though...?
11:23:58 <dankna> (yes, I'd be prouder of it if it were shorter, haha)
11:26:25 <EvanR-work> kmc: Debug.Trace doesnt seem to print out anything for IO foo, or expressions which evaluate to a function
11:27:17 <dankna> kmc: actually just having that realization wasn't enough to resolve the issue :(
11:27:26 <dankna> kmc: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24398#a24399 tried your suggestion of adding type signatures
11:27:31 <kmc> EvanR-work, whenever you force evaluation of (trace "foo" x) is when the message will be printed
11:27:53 <EvanR-work> kmc: i get foo, but after that, nothing
11:28:01 <kmc> err, that's all it does
11:28:03 <kmc> it prints "foo"
11:28:10 <EvanR-work> i thought it printed x
11:28:13 <kmc> no
11:28:17 <EvanR-work> oh
11:28:18 <dankna> (trace (show x) x)
11:28:26 <kmc> :t join traceShow
11:28:27 <lambdabot> Not in scope: `traceShow'
11:28:40 <dankna> or that :)
11:28:43 <kmc> :t join Debug.Trace.traceShow
11:28:44 <lambdabot> forall a. (Show a) => a -> a
11:28:54 <kmc> is like a tracing version of "id"
11:29:07 <benmachine> huh, my Debug.Trace doesn't have a traceShow
11:29:17 <benmachine> is it new/old
11:29:21 <benmachine> oh
11:29:27 <benmachine> that is on my 6.8
11:29:37 <benmachine> with you now
11:31:29 <kmc> EvanR-work, tracing a function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24400#a24400
11:32:55 <kmc> tracing an IO action: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24401#a24401
11:34:12 <edwardk> as soon as i get around to adding type level nats i should have a type level fingertree. i don't know whether to be amused or apalled
11:34:42 <kmc> can we just get dependent types already
11:35:03 <edwardk> (right now it doesn't know its size, so you can't split it, but you can read from either end of it as a deque and append
11:36:01 <edwardk> kmc: they don't play nice with type inference
11:36:42 <dankna> mrrrrr
11:37:00 <fax> kmc????
11:38:43 <edwardk> i should probably write the ViewL and ViewR equivalents though
11:39:49 <dankna> I apparently can't even pattern-match tableColumnDefinitionsOrSelect (CreateTable _ _ _ result) = result
11:39:56 <dankna> same error as with the deeper pattern
11:40:03 <c_wraith> how does endOfInput work in attoparsec, given that the parser is always free to ask for additional input?
11:40:03 <dankna> so the OneOrMore issue was a red herring
11:40:06 <edwardk> dankna: what error?
11:40:15 <dankna> edwardk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24398#a24399
11:40:20 <edwardk> c_wraith: if you give it no input in the bytestring it assumes it is done
11:40:44 <fax> wow that's some GADT
11:40:48 <dankna> yes I know
11:40:55 <dankna> it models the entire SQL language
11:40:58 <edwardk> c_wraith: an attoparsec parser that replies to a ByteString.empty with a continuation is in error.
11:41:01 <dankna> as implemented by SQLite3
11:41:05 <kmc> fax????
11:41:13 <fax> there is already dependent types kmc
11:41:30 <djahandarie> Attoparsec is cool
11:41:49 <fax> dankna, what is the reason that this is a GADT rather than an ADT?
11:42:00 <kmc> fax, in Haskell?
11:42:04 <fax> no
11:42:10 <fax> it wouldn't be haskell if it did..
11:42:14 <c_wraith> edwardk: I hadn't considered that case, and that's cool.  But the case I was thinking of doesn't actually apply in attoparsec's model.
11:42:41 <c_wraith> attoparsec isn't nondeterministic.  It'll always try to match the first alternative first.
11:42:41 <kmc> fax, well, GADTs aren't in Haskell either
11:42:44 <dankna> fax: because, well...  you can see the entirety of Types.hs at http://dankna.com/software/darcs/FruitTart/Base/Network/FruitTart/Base/SQL/Types.hs btw ... but I'll try to explain
11:43:00 <c_wraith> That means the behavior of endOfInput is well-defined.
11:43:02 <dankna> fax: some statements can be embedded in other statements, or in expressions; others cannot
11:43:12 <kmc> or hierarchical module names, until like a few months ago
11:43:27 <dankna> fax: I want it to be the case that it's not possible to construct an abstract syntax tree representing invalid SQL at all
11:43:36 <dankna> fax: GADTs allow me to do that
11:43:47 <dankna> fax: if you know how to do it with ADTs I'm all ears
11:43:59 <edwardk> c_wraith: very true
11:44:26 <edwardk> c_wraith: if you want all parses there is always uu-parsinglib
11:44:43 <c_wraith> edwardk: indeed.  I like that lib quite a bit.  But it has a very different intended purpose. :)
11:45:13 <edwardk> i love attoparsec, i just wish i didn't have to reimplement it to suit my purposes.
11:45:36 <edwardk> i wonder if i could get away with just tweaking the driver for it and doing some creative byte counting
11:46:10 <lispy> dankna: Oh!  You're in Corvallis. Do you go to OSU or work with dr. erwig?
11:46:12 <edwardk> (i need the byte offset at which an error occurred)
11:46:18 <dankna> I'm where?!?
11:46:22 <lispy> hmm
11:46:24 <dankna> I'm in New Jersey :)
11:46:28 <lispy> Maybe I misread my whois
11:46:33 <dankna> hehe
11:46:46 <lispy> dankna: ah, I see.  I'm still not used to Pidgin
11:46:50 <djahandarie> I'm in Connecticut!
11:46:56 <djahandarie> Not much Haskell activity here though...
11:47:00 <dankna> lispy: ah I see, yeah, that's the server I'm connected to, which freenode picked randomly for me
11:47:02 <edwardk> dankna: the pattern match you gave should uniquely determine the type. have you tried giving that function a manual type?
11:47:11 <dankna> we should have a greater-NYC Haskel Users Group
11:47:20 <dankna> *Haskell
11:47:25 <djahandarie> I mean, yale is here, but that is it
11:47:29 <edwardk> djahandarie: you should come up to the next boston haskell meeting ;)
11:47:32 <dankna> edwardk: hmm, no, I haven't, one sec
11:48:00 <edwardk> djahandarie: there are a bunch of us up here
11:48:04 <dankna> edwardk: where do I put the type annotation for that?  I am embarrassed to admit that I've never had to do that before with functions defined by lets
11:48:20 <edwardk> let foo :: type signature; foo = ....
11:48:26 <dankna> ah!  excellent
11:48:26 <edwardk> and you can use layout in the let
11:48:32 * dankna nods
11:48:42 <djahandarie> edwardk, hah, I might do that. Do you know when the next one is?
11:49:16 <edwardk> djahandarie: mostly whenever we get around to organizing one. we were going monthly like clockwork all last year, but they lapsed in the last 2-3 months coz the organizer has been busy
11:49:34 <edwardk> i'm trying to see if i can arrange the space at MIT and just restart things
11:50:00 <djahandarie> Cool
11:50:03 <djahandarie> Let me know
11:50:15 <dankna> edwardk: thanks!  it compiles now
11:50:51 <edwardk> we typically hit a wednesday evening, 6:30-9 or so and head down to the local microbrewery until they kick us out. ;)
11:50:57 <cads> I am wondering about functors in haskell, trying to understand 3 aspecs I see about them versus the two aspects I know from basic ct.
11:51:11 <edwardk> cads: shoot
11:51:26 <edwardk> cads: fmap f . fmap g = fmap (f . g), and fmap id = id
11:51:52 <c_wraith> err.  what's the point of "\ x@X{..} -> f x"?  What do you get by specifying the constructor?  strictness?
11:51:53 <edwardk> what is the third?
11:53:17 <cads> In byorgey's typeclassopedia, it shows a functor as a type constructor f that lets us write f a for any type,  and an instance of fmap.
11:53:53 <edwardk> cads: it is also useful to note that haskell 'Functor' instances are a certain 'injective' form of covariant endofunctors on the category of types.
11:54:01 <cads> The latter corresponds to a function which takes a morphism on a type and raises it to morphisms in the target category
11:54:07 <fax> a functor is a pair F_0 : C -> D (category C to category D), and F_1 : (f : A -> B) -> (f : F_0(A) -> F_0(B)) takes arrows to F(arrow)
11:54:36 <fax> in haskell the functor  f :: * -> *  is F_0  and  fmap (instanced on f) is the F_1
11:54:59 <edwardk> you can view 'f' as the mapping on objects, and the fmap :: (a -> b) -> (f a -> f b) as taking a morphism from a to b, to the corresponding morphism between f a and f b.
11:54:59 <cads>  but there is also a function  forall a => a -> f a, which is closer to the part of a morphism which maps objects of a into f a
11:55:13 <edwardk> cads: the objects are types, not the values.
11:55:16 <fax> I guess that * -> * explains what 'endofunctor' means
11:55:43 <jlouis> Nasty long-standing bug fixed in combinatorrent due to CML... wrapped evented execute in their own thread, so myThreadId can't be relied on :P
11:55:48 <cads> edwardk, ah,  that makes sense
11:56:12 <c_wraith> an endofunctor is a functor from a category to itself.  since the category in question is haskell types, everything's an endofunctor.
11:56:41 <c_wraith> haskell doesn't give you a way to leave the category of haskell types. :)
11:56:56 <cads> :)
11:57:05 <edwardk> 'pointed' allows you to use it to bring over values as well. it specifies a 'family of coalgebras' indexed by the types in haskell that is associated with your functor
11:58:48 <edwardk> and that family of f-coalgebras is what provides you the machinery to map the individual values in each of those types over. i.e. given a single value of type 'a' i can give you a list of type [a] because it has a 'return' as a monad. but i can't, for instance construct out of whole cloth using data Const b a = Const b  -- a value of type Const b a given a
11:59:05 <cads> so in this view, lets take the constructor []  and the function map as our functor... then what is the function \a -> [a]?
11:59:09 <edwardk> the latter is a valid functor. i mean just define fmap _ (Const b) = Const b
11:59:13 <edwardk> but it isn't 'pointed'
11:59:18 <cads> I'm wondering if it's somehow just part of the type constructor []
11:59:45 <fax> it's not
11:59:53 <edwardk> that is the action of "point" "pure" or "return" which are all names for that canonical family of value-preserving coalgebras
12:00:04 <edwardk> but it need not exist for every functor.
12:00:23 <edwardk> you map the types in hask to other types in hask, but you can't necessarily project a value in that type into a value in the target type
12:00:28 <edwardk> that is the magic of 'return'
12:00:31 <cads> oh, pure and return, I've heard of those in context of monads
12:00:46 <edwardk> "point" is the same thing just without any other baggage
12:00:47 <Twey> pure is the arrow name for them
12:00:57 <Twey> point is the pointed name 
12:01:04 <edwardk> clas Functor f => Pointed f where point :: a -> f a
12:01:12 <edwardk> was the best name i could come up with at the time
12:01:37 <Twey> Why the Functor constraint?
12:01:56 <edwardk> Twey: think of it as a step on the chain from functor => pointed => applicative => monad => ...
12:02:07 <Twey> That ordering seems odd to me
12:02:12 <Twey> Pointed doesn't require Functor
12:02:20 <cads> Thanks for clearing that up guys
12:02:26 <Twey> Any more than Functor requires Pointed
12:02:44 <edwardk> Twey: first give me a pointed non-functor =)
12:02:54 <edwardk> Twey: they exist
12:03:11 <edwardk> but you have to have constructors with the 'a' in negative position in something other than the constructor used by the point
12:03:39 <Twey> I can't actually think of one, but it doesn't seem like a reason to add a Functor constraint
12:03:52 <edwardk> Twey: i was using it to model pointed functors in a category ;)
12:04:06 <edwardk> i can add every constraint piecemeal, but i don't want to write the function signatures that result.
12:04:19 <cads> Hehe, I'm afraid all those examples sailed cleanly over my head
12:04:22 <edwardk> every place i do that results in a library nobody uses =)
12:04:30 <Twey> Heh.  Wait for class aliases.  
12:04:43 <edwardk> Twey: good luck. i've been waiting for years. i've given up =P
12:04:48 <Twey> Aww
12:04:52 <Twey> I'm sure we'll get them soon
12:05:00 <fax> ;((((((
12:05:03 <edwardk> Twey: any day now. in the meantime i'll go build the taj mahal ;)
12:05:07 <cads> But I'll be reding about pointed and arrow and all those other in the typeclassopedia.. then I'll at least have a framework to be confused in
12:05:07 <Twey> Progress has sped up recently.
12:05:19 <cads> readin*
12:05:31 <fax> edwardk I try to defined category theory in Coq but it goes really badly
12:05:38 <kmc> is there some big theoretical difficulty to having context aliases?
12:05:43 <kmc> or is it just a matter of someone has to write the damn code
12:05:45 <edwardk> fax: i have a haskell prelude and most of category extras in coq
12:05:53 <fax> cool
12:05:56 <fax> online??
12:06:05 <djahandarie> edwardk, that's cool
12:06:06 <edwardk> fax: not at present
12:06:34 <fax> edwardk -- if we just had pattern matching and quotients I think it would be easy in Coq :/
12:06:42 <Twey> Wait, was pure applicative?  I thought it was arrow
12:06:45 <Twey> :t pure
12:06:46 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
12:06:47 <fax> (by pattern matching I mean that UIP axiom)
12:06:50 <edwardk> fax: i pestered mattam until he'd let me use his prelude as a basis but let me switch it from gpl'd to bsd'd code, and i didn't actually change enough of it that i felt i could release it in good conscience without forking his code base
12:07:11 <Twey> Oh, duh
12:07:14 <fax> I have seen mattams haskell prelude
12:07:17 <Twey> Not even the same thing
12:07:17 <edwardk> Twey: both, though, arrow has both 'arr' and 'pure' and in the light of applicative modern arrow usage was switched to 'arr'
12:07:21 <fax> yeah
12:07:22 <Twey> Yeah
12:08:27 <edwardk> http://mattam.org/repos/coq/prelude/
12:08:58 <edwardk> i think he released it a couple of years back to not much fanfare.
12:09:12 <edwardk> but it is a nice way to learn coq, especially his 'Program' construct
12:11:38 <tafryn> Why would I not be able to import FiniteMap in ghci?
12:12:16 <c_wraith> Is that the name from the Edison-API package?
12:13:12 <Saizan> FiniteMap is the one that got substituted with Data.Map at some point in the past, i believe
12:13:49 <c_wraith> Hmm.  Hayoo knows of a FiniteMap in EdisonAPI and in a package called FiniteMap.
12:15:07 <c_wraith> tafryn: I'm pretty sure neither of those are installed by default.  Have you installed whichever mean to be using?
12:15:24 <c_wraith> err, whichever *you* mean to be...
12:15:34 <HugoDaniel> i dont like to repeat myself, but my head is a big mess when i start to think about concurrency and parallelization
12:15:35 <wavewave> what is the fast library for string manipulation?
12:15:44 <wavewave> fastest.
12:15:44 <HugoDaniel> are there any schedulers written in haskell ?
12:15:57 <HugoDaniel> wavewave: bytestring ?
12:16:02 <wavewave> especially stream-like operation.
12:16:05 <edwardk> wavewave: Data.ByteString
12:16:10 <edwardk> or Data.ByteString.Lazy
12:16:15 <wavewave> is bytestring good for stream-like operation?
12:16:19 <edwardk> there is also my Data.Rope but its hardly tested ;)
12:16:26 <edwardk> ByteString.Lazy is
12:16:29 <wavewave> appending continuously.
12:16:42 <edwardk> if you're going to keep growing the string you might want to check out Data.Rope
12:16:45 <dankna> in general, given data AnyStatement = forall l t v . Statement (Statement l t v), is it possible to write fromAnyStatement :: AnyStatement -> Statement l t v?
12:16:46 <edwardk> which is in the 'rope' package
12:17:01 <mauke> misread as Date.Rape :-(
12:17:07 <tafryn> c_wraith: Well, Data.Map appears to be present. There's a FiniteMap.[hi|dyn_hi|p_hi] in my /usr/lib/ghc-6.12.1/ghc-6.12.1 directory, but I guess that directory isn't searched?
12:17:11 <Saizan> or the Builder type in the binary package
12:17:30 <wavewave> Thanks!
12:17:34 <edwardk> it has O(log(min(n,m)/c)) append where c is the chunk size in appending ropes of size n and m
12:17:39 <edwardk> and can append bytestrings in O(1)
12:18:01 <edwardk> wavewave: the current version does utf8 decoding when you read chars from it though
12:18:07 <edwardk> wavewave so make sure that is what you want =)
12:18:18 <edwardk> otherwise you'll need to read off Word8's and convert them to chars.
12:18:26 <edwardk> (uncons, etc are polymorphic in what you're removing)
12:18:29 <wavewave> I will use only ascii files.
12:18:34 <edwardk> (and note that length is in bytes, not chars)
12:18:53 <edwardk> you need to use an annotation to get char length, which isn't in the public repo yet
12:19:13 <edwardk> then you're probably fine
12:19:26 <wavewave> appending bytestrings in O(1) is important for me.
12:19:34 <wavewave> Thanks for great info.
12:20:02 <edwardk> if you see any string functions you need in http://hackage.haskell.org/packages/archive/rope/0.6.1/doc/html/Data-Rope.html but which aren't there lemme know
12:20:12 <edwardk> and i'll see if i can fit it into the polymorphic packing/removal structure
12:20:22 <edwardk> things like 'tail' are ill-defined given the current API.
12:20:22 <djahandarie> Man, asympototic notation really annoys me sometimes
12:20:24 <dankna> lol,
12:20:25 <dankna> <interactive>:1:4:
12:20:25 <dankna>     My brain just exploded.
12:20:25 <dankna>     I can't handle pattern bindings for existential or GADT data constructors.
12:20:25 <dankna>     Instead, use a case-expression, or do-notation, to unpack the constructor.
12:20:25 <dankna>     In the binding group for
12:20:27 <dankna>         (Statement oldDefinition)
12:20:29 <dankna>     In a pattern binding: (Statement oldDefinition) = oldDefinition
12:20:30 <edwardk> djahandarie: ?
12:20:33 <dankna> oops
12:20:35 <dankna> that looks longer in irc
12:20:37 <dankna> I guess I should have only pasted the first line
12:20:49 <djahandarie> edwardk, it lies... a lot
12:21:01 <edwardk> djahandarie: constants here are pretty good ;)
12:21:12 <djahandarie> Hehe not in this case then
12:21:35 <djahandarie> But sometimes an O(n) algorithm can be a lot better than a O(1) algorithm, which people often rarely notice
12:21:50 <edwardk> djahandarie: think a 2-3 tree for which you've grabbed the left most and right most child and raised them to the top, letting the root dangle
12:21:57 <edwardk> djahandarie: so you have O(1) access to the ends
12:22:04 <edwardk> and then store slicable arrays in each leaf
12:22:10 <edwardk> that is the Data.Rope implementation
12:22:36 <edwardk> djahandarie: though i'm seriously eyeballing allowing it to hold things other than bytestrings
12:23:07 <tafryn> Are qualiifed imports not allowed in ghci?
12:23:16 <edwardk> a rope that, for instance held slightly tweaked UArr's would be nice. (they'd need to support slicing)
12:23:22 <tafryn> s/iif/ifi/
12:23:27 <djahandarie> That's pretty cool
12:23:29 <c_wraith> err.  Shouldn't building haskell platform on a clean install of ghc 6.12.1 *not* result in deprecation warning from libs using base 3?
12:24:10 <edwardk> and now tom harper is checking to see if he can add stream fusion to the ropes, so they might wind up becoming efficient, against my better judgement ;)
12:25:07 <Cale> tafryn: Yeah, the 'import' syntax in ghci is not so fancy.
12:25:25 <Cale> tafryn: You can however, import a module which imports things qualified.
12:25:28 <wavewave> any tutorial for rope?
12:25:55 <edwardk> wavewave: not really. you can just import Data.Rope.Unsafe and hack away using the monad instance though. most of it is geared towards my annotations which you don't need
12:25:57 <Cale> er, hmm, I suppose to use the qualified names, you'd have to *load* a module which imports them qualified
12:26:15 <edwardk> import Data.Rope.Unsafe and then you can work in an 'Branded Unsafe Rope' monad
12:27:12 <tafryn> Cale: I see. Thanks.
12:27:16 <edwardk> foo :: Rope a; foo = do pack "Hello"; pack ' '; pack "World"; tell (pack "another way to write"); x <- return 12; let y = "Hello"; pack "Hello"
12:27:36 <edwardk> wavewave: you can use "Branded Unsafe Rope" just like an efficient monad-writer of ropes
12:28:10 <edwardk> wavewave: you can also just use the 'Writer Rope' monad or 'WriterT Rope', or manipulate them like bytestrings from the outside
12:28:55 <edwardk> Rope is just a big block of efficiently sliceable bytes. that is in Data.Rope
12:28:59 <fax> kind of frustrating
12:29:06 <edwardk> the other stuff is probably overkill =)
12:29:07 <wavewave> thx!
12:29:16 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.6.1/doc/html/Data-Rope.html
12:29:19 <djahandarie> edwardk, what were you using that for by the way?
12:29:21 <wavewave> let me try it.
12:30:03 <edwardk> djahandarie: my c preprocessor and macro expander for kata use it to attach position annotations wherever they replace a macro, expand an include, or hit a #line directive to add monoidal position info to the rope
12:30:41 <edwardk> djahandarie: that way given a byte offset into the rope during a later 'dumb' parsing pass, i can tell you exactly what file it came from, the file include stack, what macros were expanded, where the arguments came from, where the hygienically bound variables came from...
12:30:57 <Apocalisp> What do you call a functor f with isEmpty : f a -> Bool ?
12:30:57 <edwardk> djahandarie: just given a branded position into the rope, and an annotated rope with the same brand
12:31:56 <edwardk> Apocalisp: it doesnt have a nice name. you can view the best thing that approximates an empty functor as a limit of the functor that is a value that has type (forall a. f a), which for lists consists only of [] or exotic terms
12:32:13 <Apocalisp> edwardk: Fancy meeting you here. I'm actually working with Generator/Reducer, and I'm finding that I need to know whether the container type is empty.
12:32:23 <edwardk> Apocalisp: so what you'd be looking for are, potentially, functors that you can check to see if something is in the image of the limit of the functor.
12:32:31 <edwardk> Apocalisp: =)
12:32:45 <edwardk> Apocalisp: your monoid can tell you that ;)
12:33:51 <edwardk> newtype Empty = Empty Bool; instance Monoid Empty where mempty = Empty True; mappend (Empty a) (Empty b) = Empty (a && b); instance Reducer a Empty where unit _ = Empty False
12:34:06 <edwardk> then just getEmpty . reduce ;)
12:34:13 <edwardk> not very efficient though
12:34:38 <edwardk> Apocalisp: so in theory every container supports the operation, if not very efficiently
12:34:53 <edwardk> Apocalisp: so i could add it to generator, with the above monoid used as a default implementation
12:35:11 <edwardk> and of course, most generators overriding it
12:35:18 <Apocalisp> That makes sense, but is there a name for something that just has the isEmpty function but isn't necessarily, say, foldable?
12:35:59 <edwardk> nah like i said, its probably the best approximation of having something you can test to see if it is in the image of the limit of the functor. but not everything has a categorical interpretation that makes much sense ;)
12:36:19 <Apocalisp> What's the limit of a functor?
12:36:19 <eevar> hmm... ghc -v states that I have 'ghc v 6.12 [...], stage 2 booted by ghc 6.10.4'. is that optimal?
12:36:39 <edwardk> newtype Limit f = Limit (forall a. f a) -- is a passable approximation of a limit in Hask.
12:37:06 <edwardk> consider the non-exotic inhabitants of Limit Maybe
12:37:21 <edwardk> it only works if you ignore bottoms of course
12:37:48 <EvanR-work> is there no simple split function for lists
12:37:54 <EvanR-work> split '@' email
12:38:17 <edwardk> Apocalisp: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Limit.html
12:38:47 <edwardk> EvanR-work: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
12:38:57 <jlouis> edwardk: I am beginning to wonder... is MacLane a book on programming?
12:39:10 <edwardk> jlouis: i treat it as one ;)
12:39:17 <EvanR-work> meh
12:39:33 <edwardk> jlouis: the last chapter is really about kan extensions, and i find them to be invaluable as a programming reasoning tool
12:40:01 <jlouis> I've yet to study Kan extensions deeply
12:40:06 <edwardk> jlouis: some stuff doesn't cleanly translate, but i blame the limits of our choice of language =)
12:40:29 <edwardk> jlouis: http://comonad.com/reader/2008/kan-extensions/ might serve as a starting point
12:40:39 <jlouis> I am somewhat around the level of Adjoints
12:40:39 <dankna> for the record, it IS possible to do the thing I said
12:40:43 <dankna> you have to use type-classes
12:40:49 <jlouis> oh, i'll read that one!
12:40:57 <edwardk> jlouis the second post connects adjoints and kan extensions ;)
12:41:05 <edwardk> http://comonad.com/reader/2008/kan-extensions-ii/
12:41:46 * edwardk slows down the link-spam ;)
12:42:23 <edwardk> djahandarie: er did my motivation make sense?
12:42:24 <jmcarthur> edwardk: why is attempting stream fusion on ropes against your better judgement?
12:42:52 <edwardk> jmcarthur: mostly tongue in cheek. i think it is a good idea actually. but its tricky to get right.
12:42:57 <jmcarthur> edwardk: and btw, try unboxed vectors, not UArr ;)
12:43:40 <edwardk> jmcarthur: that was what i was looking for thanks =)
12:43:49 <edwardk> hah i even called the module Data.Vector.Rope ;)
12:43:54 <jmcarthur> heh
12:44:13 <edwardk> i think if i abstract the domain of my ropes a bit i can have
12:44:15 <edwardk> Rope ByteString
12:44:23 <edwardk> Rope (Vector Int)
12:44:40 <edwardk> and Rope Buffer
12:44:44 <jmcarthur> awesome
12:44:45 <edwardk> or whatever all just work
12:45:10 <edwardk> but then of course i'm dealing with (Unsafe `Branded` Rope ByteString) a as the monad ;)
12:46:26 <djahandarie> edwardk, yeah, that's pretty interesting
12:47:06 <edwardk> or the (s `Branded` Rope (Vector Int)) (Position s) -- as an annotated rope of integers with a position annotation.
12:47:15 <edwardk> er not that position makes sense on its
12:47:16 <edwardk> er ints
12:47:46 <edwardk> starts to be a bit of a mouthful
12:47:54 <djahandarie> edwardk, I wonder if Yi could use the ropes
12:48:04 <jmcarthur> type synonyms are nice
12:48:14 <djahandarie> I think they are using finger strings atm for their buffer text
12:48:17 <jmcarthur> newtypes are even nicer
12:48:18 <edwardk> djahandarie: probably
12:48:28 <jmcarthur> whis is why i tend to not care about complexity of types
12:48:28 <edwardk> jmcarthur: been trying to avoid MPTCs in here
12:48:40 <jmcarthur> complex constraints, on the other hand, annoy me
12:48:43 <edwardk> jmcarthur: and i'm already fairly polymorphic in allowing different args to be cons'd etc.
12:48:59 <edwardk> any more and they become type annotation heavy
12:49:16 <edwardk> the Data.Rope.Annotated is already fairly crippled by the type annotation requirement
12:49:23 <jmcarthur> :\
12:49:32 <edwardk> which is why i wrote Data.Rope.Unsafe so i wouldn't have to do everything in CPS
12:49:56 <HugoDaniel> bye
12:51:00 <edwardk> now that i have type level fingertrees i should be able to handle some of the type-level brand management stuff better
12:51:25 <edwardk> ( i got bored last night, they were surprisingly easy)
12:51:35 <jmcarthur> edwardk: !!
12:51:38 <edwardk> though my fingertrees don't currently support slicing
12:51:43 <edwardk> (the type level ones that is)
12:51:50 <edwardk> you can cons, snoc and viewl/viewr
12:51:52 <edwardk> and append
12:52:32 <Alpounet> type level fingertree ?
12:52:33 <edwardk> i wasn't willing to bang out the type level nats just to add a type level size annotation for slicing purposes, when my brands don't support it anyways
12:52:36 <Alpounet> uh
12:53:17 <edwardk> Alpounet: I pasted about half of the implementation to myself last night at: comonad.com/Seq.hs -- but that version wasnt complete
12:53:24 <edwardk> i'll probably add them to Data.Rope later ;)
12:53:32 * Philippa just had a thought
12:53:37 * jmcarthur fears
12:53:39 <Alpounet> let me take a look
12:53:52 <edwardk> Philippa: whats that?
12:54:03 <jmcarthur> oh my gosh
12:54:03 <Philippa> is there a page somewhere on the wiki containing a list of common short (1-3 letters?) identifier names coupled with an expansion, optional domain and description?
12:54:06 <jmcarthur> yay type families
12:54:12 <edwardk> jmcarthur: not bad, see?
12:54:21 <jmcarthur> really not
12:54:25 <Alpounet> haha
12:54:26 <jmcarthur> pleasantly surprised
12:54:28 <Philippa> for example, if it's a compiler then t might be a type. Or elsewhere it's more likely to be time...
12:54:42 <Alpounet> that definitely reminds me some of my C++ metaprogramming fun
12:54:52 <edwardk> Philippa: acronym dictionaries tend to go out of date fast though
12:55:00 <Philippa> edwardk: I'm afraid I just jumped in
12:55:04 <edwardk> Alpounet: yeah, i cut my teeth on c metaprogramming ;)
12:55:15 <Alpounet> c ?
12:55:16 <Alpounet> oh
12:55:17 <Alpounet> come on :p
12:55:21 <edwardk> c++ ;)
12:55:35 <edwardk> but i did my fair share of x-macro nastiness in the c days too =)
12:55:38 <Philippa> edwardk: I'm thinking the 3 letter ones shouldn't be TLAs
12:55:42 <jmcarthur> wat, c doesn't do much metaprogramming
12:55:59 <edwardk> jmcarthur: http://en.wikipedia.org/wiki/C_preprocessor#X-Macros
12:56:13 <edwardk> jmcarthur: how do you think you get most of the variadic macros in boost ;)
12:56:13 <Philippa> more stuff like "env", which I suspect appears in a high proportion of interpreters
12:56:24 <edwardk> Philippa: *nods*
12:56:30 <jmcarthur> edwardk: i've done this style of metaprogramming
12:56:31 <thoughtpolice> x-macros are kind of awesome for some things, but in the same vein, the preprocessor is evil
12:56:37 <Philippa> (and would have in FP interpreters two decades ago, too)
12:56:40 <edwardk> jmcarthur: yeah
12:56:40 <thoughtpolice> IMO, anyway
12:56:41 <jmcarthur> edwardk: it's not simple, but i wouldn't say it's that powerful
12:57:01 <edwardk> my original statement was a typo, but then i realized i had done a fair bit of 'meta programming' in that style ;)
12:57:37 <Alpounet> edwardk, I hope most of your code has been generated
12:57:49 <edwardk> Alpounet: the stuff there? nah, all by hand...
12:57:57 <Philippa> admittedly I partly have the idea to assuage my guilt at code where all the variable names are 1-3 chars long and following conventions that sort of make sense but aren't quite documented :-)
12:57:58 <edwardk> well, vi, regexen, and the data.sequence code
12:58:07 <Alpounet> heh ok
12:58:16 <jmcarthur> hmm... it would be cool to have a program that takes a more sane syntax and turns it into type level code using type families
12:58:29 <edwardk> jmcarthur: its called 'prolog' ;)
12:58:36 <MisterN> jmcarthur: i have done some c preprocessor metaprogramming, but it's mostly about applying simple programs in ways that the preprocessor accepts
12:58:37 <Philippa> but also because it's tempting to supply "x: thingy (abstract stuff)"
12:58:50 <djahandarie> Who was it that had a just wrong amount of type classes on one function?
12:58:53 <jmcarthur> edwardk: i mean a preprocessor
12:58:57 <edwardk> djahandarie: dankna
12:59:06 <edwardk> jmcarthur: *nods*
12:59:14 * Philippa wonders how much of that SHE does
12:59:22 <Philippa> it's been a little while since I saw the annouce for it
12:59:25 <jmcarthur> i guess she does quite a bit
12:59:30 <edwardk> i wonder how well the kata macro stuff would work on haskell
12:59:39 <jmcarthur> i've used she for a toy project. i quite enjoyed it
13:00:10 <jmcarthur> damn conor for that name
13:00:13 <edwardk> would have to change quite a few of the lexing rules, so its not worth it right now, but i'll play with it later
13:00:21 <Philippa> anyone else like/dislike the tiny identifier dictionary idea? Should I just go grab a wiki page already?
13:00:35 <edwardk> being able to define custom layout binders, etc. would be handy in haskell
13:00:46 <edwardk> Philippa: just grab a wikipedia page and spam it
13:00:55 <edwardk> Philippa: someone else will come along or not ;)
13:01:02 <Philippa> heh. I was going for the haskell wiki rather than wikipedia
13:01:03 <edwardk> er not wikipedia i meant haskell.org
13:01:04 <edwardk> yeah
13:01:31 <Philippa> not going to be so good at the spamming, but I figure it'd be fun to advertise on -cafe in a bit
13:01:36 <dj_ryan> i have a 194m point datat set in a 14gb file... can i use haskell to reduce it?
13:02:03 <edwardk> Philippa: as i tend to change convention from file to file, i'll likely not be the best contributor ;)
13:02:15 <jmcarthur> dj_ryan: that depends on what "reduce" means
13:02:27 <edwardk> @faq i have a 194m point datat set in a 14gb file... can i use haskell to reduce it?
13:02:27 <lambdabot> The answer is: Yes! Haskell can do that.
13:02:47 <edwardk> what is the operation you want to perform?
13:02:50 <jmcarthur> dj_ryan: if "reduce" is computable in the resources your computer has, sure, haskell can do it :)
13:03:04 <MisterN> @faq can haskell clean my oven?
13:03:04 <lambdabot> The answer is: Yes! Haskell can do that.
13:03:10 <MisterN> yay haskell
13:03:15 <dj_ryan> so i want to so some simple bucketing o the points and keeps some stats
13:03:19 <edwardk> MisterN: you didn't ask if it would... ;)
13:03:40 <MisterN> edwardk: uh it's a programming language i just tell it to :)
13:03:53 <jmcarthur> dj_ryan: bucketing as in partitioning them into equivalence classes?
13:04:08 <EvanR-work> i know ive asked this before, but does a data constructor count as a function, for example can i pass it to map
13:04:14 <EvanR-work> or zipWith
13:04:17 <jmcarthur> EvanR-work: yes
13:04:18 <jmcarthur> :t Just
13:04:20 <lambdabot> forall a. a -> Maybe a
13:04:25 <dj_ryan> jmcarthur: right and keeping info about those classes. the points are integers, so i want to bucket them then know what the max/min/average/etc for a bucket is
13:04:28 <EvanR-work> nice
13:04:45 <edwardk> MisterN:     Couldn't match expected type `[Integer]' against inferred type `IO CleanOven' ;)
13:05:05 <edwardk> EvanR-work: yep!
13:05:08 <jmcarthur> dj_ryan: you can definitely do that in haskell
13:05:10 <MisterN> edwardk: well if haskell can do it, it's just a matter of getting the types to check
13:05:44 <dj_ryan> jmcarthur: will the lazy evaluation go all the way back to the disk io? or will i end up building a 194m item list in memory first?
13:05:51 <edwardk> dj_ryan: feed it into a lazy bytestring, then just fold along the contents reading them as you go, maintaining the 'sufficient statistics' you need to answer those questions
13:06:06 <jmcarthur> dj_ryan: it depends on if you use lazy io
13:06:16 <dj_ryan> jmcarthur: ah ha
13:06:24 <jmcarthur> dj_ryan: lazy io is one of those things which i personally was not used so often, but i have to admit it can be useful
13:06:43 <dj_ryan> when you have a 194m line file...
13:06:52 <edwardk> dj_ryan: there are lazy io operations that work fine with enormous unbounded io (as long as you don't hold onto the beginning of the input!)
13:06:53 <jmcarthur> dj_ryan: for your case, i think lazy io sounds liek a reasonable solution
13:07:14 <edwardk> dj_ryan: to be safe there are always "Iteratees"
13:07:21 <edwardk> which don't hold onto the input
13:07:31 <edwardk> they just hold onto the current chunk until its gone
13:07:35 <edwardk> then grab the next
13:07:42 <jmcarthur> dj_ryan: i would use lazy io to read it in, converting it to a list of ints and accumulating them into an IntMap using insertWith to update statistics as you go
13:08:25 <jmcarthur> dj_ryan: or just a map if the equivalence class is not defined using mere equality
13:09:34 <jmcarthur> i don't know the full purpose of the program though, so make sure to weigh what i say against what you actually want ;)
13:09:35 <dj_ryan> yeah probably a map
13:09:59 <dj_ryan> actually its fairly simple, i am analyzing the sizes of data blocks in files to determine how variant they are
13:10:39 <edwardk_> variant as in variance/standard deviation, skew, kurtosis?
13:11:23 <edwardk_> if its just those, (and maybe a min/max, etc you can use 'sufficient statistics' to supply the answer.
13:11:32 <edwardk_> http://en.wikipedia.org/wiki/Sufficient_statistic
13:12:23 <dj_ryan> im most interested in min/max in a bucket
13:12:50 <edwardk_> i.e. i.e. the count of items read, the sum of the items, the sum of the squares, the sum of the cubes, the sum of the 4th power of the items in your list.. you can answer SD,, kurtosis, etc.
13:12:55 <MisterN> @hoogle reduce
13:12:56 <lambdabot> No results found
13:13:09 <EvanR-work> gah transpose acts weird when give a list with one member
13:13:23 <edwardk_> dj_ryan: read the bucket and foldMap (Min &&& Max) over the bucket ;)
13:13:25 <jmcarthur> :t transpose
13:13:26 <lambdabot> forall a. [[a]] -> [[a]]
13:13:32 <jmcarthur> > transpose [[]]
13:13:33 <lambdabot>   []
13:13:35 <EvanR-work> > transpose [[1,2], [3,4], [5,6]]
13:13:36 <lambdabot>   [[1,3,5],[2,4,6]]
13:13:39 <EvanR-work> > transpose [[1,2], [3,4]]
13:13:40 <lambdabot>   [[1,3],[2,4]]
13:13:43 <EvanR-work> erm
13:13:44 <dancor> @src transpose
13:13:44 <lambdabot> transpose []             = []
13:13:45 <lambdabot> transpose ([]   : xss)   = transpose xss
13:13:45 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:14:01 <edwardk_> > foldMap (Min &&& Max) [1,3,2]
13:14:02 <lambdabot>   Not in scope: `foldMap'Not in scope: data constructor `Min'Not in scope: da...
13:14:19 <EvanR-work> > transpose [[1,2], [3,4], [5,6]]
13:14:19 <edwardk_> > Data.Foldable.foldMap (Data.Monoid.Min &&& Data.Monoid.Max) [1,4,2]
13:14:20 <lambdabot>   [[1,3,5],[2,4,6]]
13:14:20 <lambdabot>   Not in scope: data constructor `Data.Monoid.Min'Not in scope: data construc...
13:14:23 <EvanR-work> > transpose [[1,2], [3,4]]
13:14:24 <lambdabot>   [[1,3],[2,4]]
13:14:25 <dancor> i wonder how much more suited to fast transpose other data structures are
13:14:25 <edwardk_> gah
13:14:26 <EvanR-work> > transpose [[1,2]]
13:14:27 <lambdabot>   [[1],[2]]
13:14:28 <edwardk_> no monoid
13:14:30 <EvanR-work> now thats irght
13:14:43 <EvanR-work> > transpose []
13:14:44 <lambdabot>   []
13:14:53 <EvanR-work> i want [[], []] :( ;)
13:15:11 <jmcarthur> > transpose [[],[]]
13:15:11 <lambdabot>   []
13:15:14 <Philippa> @wiki Tiny Identifier Dictionary
13:15:14 <lambdabot> http://www.haskell.org/haskellwiki/Tiny_Identifier_Dictionary
13:15:15 <jmcarthur> meh
13:15:31 <Philippa> (just created, not got a huge number of entries for now but it'll do)
13:15:41 <EvanR-work> guess i hit the 'zero' here where inverses dont work
13:15:57 <edwardk_> Philippa: f for functor. m for monad or monoid
13:16:04 <edwardk_> n for natural or int
13:16:04 <xerox> > head . transpose $ [[[]],[[]]]
13:16:06 <lambdabot>   [[],[]]
13:16:12 <djahandarie> a for... anything?
13:16:24 <Philippa> a for applicative, perhaps
13:16:36 <edwardk_> Philippa: i use f for applicative still ;)
13:16:37 <djahandarie> It's used for more than applicative though
13:16:39 <MisterN> > transpose [[[]],[[]]]
13:16:40 <lambdabot>   [[[],[]]]
13:16:41 <edwardk_> a b -> ... always looks weird ;)
13:16:46 * jmcarthur uses f for applicative
13:16:46 <fax> b for bananna split c for catamorphism
13:17:02 <MisterN> > transpose . transpose [[[]],[[]]]
13:17:02 <edwardk_> and here is where the rush comes in ;)
13:17:03 <lambdabot>   [[]]
13:17:11 <MisterN> > transpose . transpose . transpose [[[]],[[]]]
13:17:12 <lambdabot>   [[]]
13:17:16 <fax> I h ave a universe inconsistency!
13:17:26 <Philippa> fax: I'd be highly surprised by someone using c as the identifier for a catamorphism. If only because "cat" is still nicely short
13:17:31 <Twey> Daddy, how many nanas in banananananananananananana
13:18:21 <edwardk_> phi tends to be the algebra for a catamorphism, psi the coalgebra for an anamorphism.
13:18:32 <monochrom> also banananananananananananana(infinitely many of them, followed by) nana
13:18:50 <edwardk_> 'go' tends to be the local helper function if there is only one and the code was ever touched by dons ;)
13:19:17 <monochrom> what happens when dons touches it?
13:19:19 <djahandarie> Which is a large portion of the code. :P
13:19:46 <MisterN> monochrom: is the end of an infinite sequence even a defined concept?
13:20:00 <edwardk_> monochrom: foo bar = slightly epensive worker/wrapper setup where go n s = ...
13:20:05 <dancor> it clearly ends in anan!
13:20:09 <monochrom> I don't know. I'm paroding those who think 0.999... is not 1.
13:20:24 <edwardk_> monochrom: has a codata banana
13:20:37 <fax> what about people who thing the infinite sum of rational numbers is still rational?
13:20:43 <dancor> i would say the Nearest Reasonable Concept is lim (n->inf) a_n
13:20:47 <dancor> which here is not defined
13:20:51 <dancor> but is a for haaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..
13:20:57 <edwardk_> > "b" ++ fix ("an" ++)
13:20:58 <lambdabot>   "banananananananananananananananananananananananananananananananananananana...
13:22:20 <monochrom> A codata banana is a magical food which you eat or split a bite and get moar codata banana.
13:22:49 <edwardk_> monochrom: it is the mananana.. of the gods
13:22:58 <monochrom> hahaha
13:23:11 <MisterN> you mean hahaha...
13:23:21 <edwardk_> =)
13:23:37 <monochrom> hanana... montananana...
13:27:14 <monochrom> http://www.amazon.com/Hannah-Montana-Loop-Suzanne-Harper/dp/1423116623  hananana... montananana in the loop
13:31:12 <MisterN> monochrom: now everybody is blind and deaf.
13:31:33 <monochrom> I am a counterexample.
13:33:20 <MisterN> monochrom: a counterexample proves nothing!
13:33:36 <ulfdoz> lol
13:33:39 <monochrom> proves an existential statement.
13:34:04 <jao> monochrom: you're the exception that confirms the rule
13:35:27 <edwardk_> monochrom: we can't tell, we're blind and deaf and you could be using a braille term ;)
13:37:14 <MisterN> also, is monochrom even a person?
13:37:28 <monochrom> define person
13:37:29 <dankna> we need a Turing Tribunal to determine this
13:37:30 <aledge> or just a room with a person inside
13:38:11 <ulfdoz> As a counterexample, it takes no space.
13:41:11 <edwardk_> dankna: dangerous. last time we held a turing tribunal it declared dons was human, even though he is clearly a coding machine that is active 24 hours a day with an automated reddit autoposting subsystem. Now that he has civil rights and employment outside of academia who knows what will happen.
13:41:48 <ulfdoz> Haven't you seen terminator I-IV?
13:42:02 <dankna> edwardk: hahaha, duly noted.
13:42:06 <lispy> ?quote skynet
13:42:07 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
13:42:11 <Philippa> ulfdoz: dons is a non-terminating process!
13:42:19 <jmcarthur> edwardk_: can donsbot adopt children?!
13:42:37 <edwardk_> jmcarthur: see, even his very nickname was a clue ;)
13:42:38 <lispy> Does dons dream of electric sheep?
13:42:40 <aledge> Philippa, prove that dons doesn't terminate
13:42:49 <ulfdoz> Philippa: But that is not an algorithm!
13:43:01 <edwardk_> aledge: the counterexample would make us sad
13:43:14 <aledge> edwardk_, so it's an axiom then?
13:43:42 <edwardk_> aledge: a mesofact
13:44:05 <aledge> hmmmmmmm
13:45:42 <conal> is there a haskell-package with ghc 6.12.1 on macports?  i did "sudo port install haskell-platform" and got ghc 6.10.4.
13:46:40 <dankna> conal: when did you do this?  there's supposed to be, as of a couple days ago
13:46:48 <conal> dankna: a few minutes ago
13:46:51 <dankna> drat
13:46:56 <conal> yeah
13:47:42 <jlouis> updating ports?
13:50:57 <dv-> How do I get whatever runProcess is sending to stdout? I've tried making a temporary handle, but after the process finished the handle is closed
13:56:34 <c_wraith> dv-: use a pipe
13:57:11 <c_wraith> looks like you need to use a different function to do that.
13:57:20 <c_wraith> But System.Process is pretty comprehensive
13:57:55 <c_wraith> dv-: runInteractiveProcess would do what you want.
14:00:38 <c_wraith> dv-: as would any number of other functions in that module, actually
14:01:18 <conal> i guess the new haskell-platform hasn't actually reached macports yet.
14:01:36 <dv-> There are only 4 run* functions :p
14:01:50 <c_wraith> dv-: many of the read* functions would also do what you want
14:02:26 <dv-> I don't see any read*. I'm still on ghc-6.6
14:02:56 <c_wraith> holy crap.  If you can update that a few dozen versions, it'd help a lot
14:03:35 <MisterN> c_wraith: doesn't ghc seem to skip odd versions?
14:03:41 <EvanR-work> combinator to make a boolean function from the AND of two boolean functions that takes the same input
14:03:44 <EvanR-work> quick
14:03:45 <c_wraith> MisterN: they're dev versions
14:03:54 <jmcarthur> EvanR-work: type?
14:03:55 <MisterN> hmm so they exist
14:03:56 <c_wraith> :t ap(&&)
14:03:56 <lambdabot> (Bool -> Bool) -> Bool -> Bool
14:04:10 <kmc> :t liftM2 (&&)
14:04:11 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
14:04:12 <jmcarthur> :t liftA2 (&&)
14:04:13 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
14:04:19 <aavogt> @type msum
14:04:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:04:32 <EvanR-work> (a -> Bool) -> (a -> Bool) -> (a -> Bool)
14:04:42 <aavogt> @type Data.Foldable.foldMap
14:04:43 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
14:04:44 <kmc> EvanR-work, liftA2 or liftM2 will work for that
14:04:47 <jmcarthur> EvanR-work: yeah the liftA2 and liftM2 solutions do it
14:04:47 <chrisdone> is there any argument parsing thing knocking about that's more monadic/applicative like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24402#a24403 GetOpts is a bit restricted and fudgy
14:05:02 <kmc> > liftA2 (&&) odd even 3
14:05:02 <aavogt> @hogle (a -> m b) -> t a -> m b
14:05:03 <lambdabot>   False
14:05:03 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
14:05:03 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
14:05:03 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
14:05:12 <kmc> > liftA2 (&&) odd (> 1) 3
14:05:14 <lambdabot>   True
14:05:21 <aavogt> is there a version of foldMap for MonadPlus?
14:05:56 <chrisdone> :t mconcat . map
14:05:57 <lambdabot>     Couldn't match expected type `[a]'
14:05:58 <lambdabot>            against inferred type `[a1] -> [b]'
14:05:58 <lambdabot>     Probable cause: `map' is applied to too few arguments
14:06:06 <chrisdone> :t \f -> mconcat . map f
14:06:07 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
14:06:11 <jmcarthur> @check \f g x -> liftA2 (&&) f g (x :: Int) == (f x && g x)
14:06:12 <lambdabot>   Overlapping instances for GHC.Show.Show
14:06:12 <lambdabot>                              (GHC.T...
14:06:20 <jmcarthur> o_O
14:06:25 <aavogt> @ty (msum .) . map
14:06:26 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
14:06:37 <chrisdone> always get msum and mconcat mixed up
14:07:51 <EvanR-work> how about a zipWithFilter
14:08:07 <jmcarthur> EvanR-work: type?
14:08:48 <EvanR-work> (a -> b -> Bool) -> (a -> b -> c) -> [a] -> [b] -> [c]
14:08:51 <kmc> :t \f xs ys -> catMaybes $ zipWith f xs ys
14:08:52 <lambdabot> forall a a1 b. (a1 -> b -> Maybe a) -> [a1] -> [b] -> [a]
14:09:23 <EvanR-work> that shouuld work
14:09:49 <jmcarthur> :t \cond f xs ys -> map (uncurry f) . filter (uncurry cond) $ zip xs ys
14:09:50 <lambdabot> forall a b c. (a -> b -> Bool) -> (a -> b -> c) -> [a] -> [b] -> [c]
14:09:59 <jmcarthur> @pl \cond f xs ys -> map (uncurry f) . filter (uncurry cond) $ zip xs ys
14:10:00 <lambdabot> flip flip zip . (((.) . (.)) .) . flip ((.) . map . uncurry) . filter . uncurry
14:10:05 <jmcarthur> lol, there you go
14:10:10 <kmc> :t \f g xs ys -> catMaybes $ zipWith (\x y -> guard (f x y) >> g x y) xs ys
14:10:11 <lambdabot> forall a a1 b. (a1 -> b -> Bool) -> (a1 -> b -> Maybe a) -> [a1] -> [b] -> [a]
14:10:22 <kmc> :t \f g xs ys -> catMaybes $ zipWith (\x y -> guard (f x y) >> return (g x y)) xs ys
14:10:23 <lambdabot> forall a a1 b. (a1 -> b -> Bool) -> (a1 -> b -> a) -> [a1] -> [b] -> [a]
14:10:32 <MisterN> jmcarthur: booby code
14:10:48 <kmc> :t (((.) . (.)) .)
14:10:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f2 (a -> b) -> f2 (f (f1 a) -> f (f1 b))
14:11:09 <kmc> :t let f . g = \x -> f (g x) in (((.) . (.)) .)
14:11:10 <lambdabot> forall t t1 t2 t3 t4. (t4 -> t1 -> t2) -> t4 -> (t -> t3 -> t1) -> t -> t3 -> t2
14:11:13 <jmcarthur> :t \cond f -> (fmap.fmap) (map (uncurry f) . filter (uncurry cond)) zip
14:11:14 <lambdabot> forall c a b. (a -> b -> Bool) -> (a -> b -> c) -> [a] -> [b] -> [c]
14:11:33 <jmcarthur> @pl \cond f -> (fmap.fmap) (map (uncurry f) . filter (uncurry cond)) zip
14:11:34 <lambdabot> flip flip zip . ((fmap . fmap) .) . flip ((.) . map . uncurry) . filter . uncurry
14:11:37 <MisterN> kmc: ah that makes it more readable
14:11:38 <jmcarthur> still not pretty
14:12:13 <Adamant> fax: as long as your goal is to teach mathematicians, that can work, I just think cat theory is even worse to try and teach in most schools for non-mathematicians than set theory.
14:12:43 <fax> ?? nobody teaches set theory in schools
14:12:43 <lambdabot>  nobody teaches set theory in schools
14:12:54 <fax> they don't even tell you what 'exists' means
14:13:10 <Adamant> fax: huh?
14:13:56 <Adamant> there was the whole 'new math' deal in the 60's, and while most of that has gone away, a lot of high schools teach basic set theory
14:16:27 <djahandarie> lol that stupid . = fmap junk
14:16:31 <Philippa> Adamant: that was a US thing, I think
14:17:40 <fax> people are taught to hate "proofs" in school because there's never a chance to say in any detail what it is
14:17:51 <Adamant> Philippa: I think it was mostly US, although my understanding is that it was in part an idea to take the ideas of that French mathematical collective to the masses.
14:18:06 <Philippa> fax: UK education and US education significantly differ
14:18:41 <Adamant> in US K-12, the only proofs you will generally do are geometric, Euclid-style ones.
14:18:44 <ddarius> fax: People are taught to hate proofs because the only rigourous ones they do, in typical American education, are Hilbert style proofs of mostly meaningless geometric facts.
14:19:02 <maltem> Philippa, not exclusively, I've heard of that here in Germany, but most people consider it to have failed / be pointless, afaics
14:19:03 <aledge> true that
14:19:09 <EvanR-work> can i do this
14:19:13 <EvanR-work> f [a,b] = ...
14:19:29 <kmc> EvanR-work, yes
14:19:32 <EvanR-work> awesome
14:19:49 <kmc> EvanR-work, if the argument to f doesn't have exactly two elements, it will fall back to the next equation
14:20:10 <kmc> > let f [a,b] = "two"; f _ = "not two" in map f ["", "a", "abc", "ab"]
14:20:11 <lambdabot>   ["not two","not two","not two","two"]
14:20:15 <applicative> conal:  did someone clarify?  It does seem there was confusion from overlapping announcements...the macports is ghc-6.10 64 bit, the installer is 6.12 32 bit.... again .. that's my understanding.  I took the macports way.
14:21:00 <kmc> > (\[a,b,c] -> ()) "ab"
14:21:01 <lambdabot>   * Exception: <interactive>:1:134-147: Non-exhaustive patterns in lambda
14:21:50 <applicative>  (\[a,b,c] -> ()) "abc"
14:22:00 <applicative> > (\[a,b,c] -> ()) "abc"
14:22:01 <lambdabot>   ()
14:22:11 <conal> applicative: thx.  i learned the hard way.  my project uses gtk2hs + 3d, and i don't know how to get that combo working on os x with 6.12.  sigh.
14:22:29 <EvanR-work> @src reverse
14:22:30 <lambdabot> reverse = foldl (flip (:)) []
14:22:59 <dcoutts> conal: can you remind me what the problem was?
14:23:17 <conal> i'm leaning toward abandoning graphics & uis in haskell.  so fragile.  i might instead just generate gpu code from haskell and do the rest in other languages.
14:23:20 <dcoutts> conal: is it simply that we never got the gtkgl C extension building on OSX?
14:23:40 <conal> dcoutts: do you mean native?
14:23:50 <dcoutts> conal: oh either X11 or native
14:24:00 <applicative> conal: I see yeah.  You would know better but the installer was the first time I could get any graphics going on the mac -- well almost.  The new installer made a hash though, for some reason that isn't its fault so I went macports, which was much better than a year ago....
14:24:20 <conal> dcoutts: i'd like native much better, but apparently there's no native gtk+3d
14:24:53 <conal> dcoutts: and for x11, i don't know how to get gtk2hs & ghc 6.12 on os x.  i thought macports, but i guess not.
14:25:50 <chr1s> conal: hi!
14:26:01 <dcoutts> conal: ok, so the situation is that it worked with gtk-X11 but not the newer native gtk backend, does that sound right?
14:28:29 <applicative> it's pleasing that despite the impediments no one needs to worry that conal will go over to 'MacRuby' on OS X
14:34:39 <wavewave> edwardk: snoc in Data.Rope has O(1) complexity. right?
14:36:33 <ddarius> wavewave: It should be the same complexity as Data.Sequence.Seq snoc
14:37:28 <wavewave> ddarius: Data.Sequence.Seq is strict, isn't it?
14:38:57 <wavewave> snoc defined in ByteString.Lazy is O(n).
14:39:34 <stepcut> is there some obvious/simple/prefered way to implement a function like this in parsec 3, GenParser Char () a -> GenParser String () a
14:39:48 <ddarius> (|>) which is snoc in Data.Sequence is O(1)
14:39:49 <conal> whew.  back after connectivity break.
14:40:05 <fax> hi conal
14:40:12 <stepcut> conal: yay!
14:40:34 <chrisdone> @src Monoid
14:40:34 <lambdabot> class Monoid a where
14:40:34 <lambdabot>     mempty  :: a
14:40:34 <lambdabot>     mappend :: a -> a -> a
14:40:34 <lambdabot>     mconcat :: [a] -> a
14:40:48 <chrisdone> @instances Monoid
14:40:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:40:54 <chrisdone> how come Bool isn't a Monoid?
14:40:59 <wavewave> ddarius: okay. but doesn't strictness cause any problem?
14:41:15 <dcoutts> chrisdone: should it use && or || ?
14:41:16 <wavewave> ddarius: I would like to deal with very large file.
14:41:31 <byorgey> chrisdone: for the same reason Integer isn't an instance of Monoid.
14:41:37 <conal> dcoutts: i had gtk2hs-with-3d working with a ghc 6.10.x from macports.  i don't know a way with 6.12
14:41:44 <byorgey> chrisdone: check out Any and All
14:41:53 <chrisdone> dcoutts: byorgey: ah thought so
14:42:04 <chrisdone> @source All
14:42:04 <lambdabot> All not available
14:42:21 <dcoutts> conal: I expect 6.12 support will appear in macports soonish, we're just getting the HP release with 6.12.2 ready
14:42:34 <byorgey> All = All { getAll :: Bool }
14:42:37 <chrisdone> byorgey: yeah that's cool
14:42:52 <conal> dcoutts: yeah.  sigh.  i guess i upgraded ghc too soon.
14:42:58 <applicative> @src All
14:42:58 <lambdabot> Source not found. Sorry.
14:43:06 <byorgey> hmm, are those the only possible monoids on Bool?
14:43:21 <dcoutts> conal: it ought to be possible to build gtk2hs from source (to use the X11 backend) if you've got gtk and gtkglext installed via macports
14:43:25 <applicative> byorgey, the combinatorial possibilities are restricted....
14:43:41 <ddarius> byorgey: There are trivial ones.
14:43:52 <dcoutts> conal: though you need the latest darcs version of gtk2hs to work with 6.12, again 6.12 support is still maturing.
14:43:53 <byorgey> ddarius: ah, true
14:44:18 <byorgey> _ % _ = False, and suchlike
14:44:23 <dcoutts> conal: you're ahead of widespread 6.12 support, especially being before the HP release
14:44:42 <byorgey> wait, no, that doesn't work, does it.
14:44:48 <applicative> t t  t f f t t t are the possibilities for the operation.  so that's eight possibilities for an operation, but now one has to be an identity.
14:44:58 <conal> dcoutts: there is an hp for 6.12, but not in macports, iiuc.
14:45:01 <chrisdone> byorgey: doesn't it?
14:45:10 <byorgey> can't work for identity
14:45:10 <applicative> no 16 possibilities...argh
14:45:11 <dcoutts> conal: a beta/pre-release yes.
14:45:23 <dancor> stepcut: so wait, does parsec2 GenParser String correspond to Parsec [String]?
14:45:24 <conal> oh, oops!  i thought it was more solid.
14:45:29 <byorgey> suppose you pick False to be mempty, then  False `mappend` z == z  should hold, but what if z is True?
14:45:31 <dancor> in parsec3
14:46:06 <applicative> False is mempty for || as mappend
14:46:08 <chrisdone> byorgey: I thought by your definition % means mappend, so False `mappend` True would be False and identity would be preserved. what's %?
14:46:08 <dcoutts> conal: it's out so people can test, the stable HP release will have ghc-6.12.2 which also isn't released yet.
14:46:12 <applicative> or am I in a muddle
14:46:39 <byorgey> chrisdone: no, if False is mempty then  False `mappend` True would be required to be True.
14:46:47 <stepcut> dancor: sure?
14:46:59 <byorgey> % was just a name I made up for the silly constantly-false binary operation
14:47:01 <chrisdone> byorgey: sorry good point
14:47:03 <conal> dcoutts: thanks.  i'll try to get back to a sane state with 6.10.4
14:47:46 <conal> dcoutts: though ultimately, i'll probably drop gtk2hs, since there's no mac-native support for 3d.
14:47:47 <applicative> True is mempty for && as mappend.   True is like 1 and && like *; False is like 0 and mappend like +   - on the natural reading, the one Boole presupposed.  (Or am I in a muddle again)
14:48:22 <byorgey> applicative: no, you're absolutely right.
14:48:40 <applicative> True with && is like 1 with *    False with || is like 0 with +   There I said it.
14:48:50 <dcoutts> conal: apparently there are patches for gtkglext for native, and they might do a release, but yes it's rather fustrating
14:48:51 <byorgey> I was just idly wondering if there were any others that satisfy all the monoid laws.
14:48:55 <stepcut> dancor: I am trying to parse a [String], but sometimes I want to drill down to the Char level.. When working at the Char level I only want to be looking at the the single current String token of the 'parent' parser. so 'many anyChar' would only parse to the end of the current String, not all the [String]
14:48:59 <wavewave> okay Rope is using FingerTree and Sequence also uses FingerTree
14:49:09 <dancor> stepcut: so you want the resulting parser to grab one String token from the input stream and run the Char-parser on it?
14:49:14 <wavewave> FingerTree is strict or lazy?
14:49:21 <stepcut> dancor: exactly
14:49:23 <conal> dcoutts: oh!  i hadn't heard any progress before.
14:49:42 <dcoutts> conal: as far as I can see, there is actually no really decent cross-platform GUI in any language. QT comes pretty close but it's GPL which is problematic for some users.
14:50:05 <stepcut> dancor: one I issue I see is how to report the 'position' for error messages.
14:50:09 <applicative> take either as the identity and return it for the operation -- use  blah p q = p || q || not p || not q  as the operation
14:50:10 <conal> dcoutts: how about wx?
14:50:13 <dancor> stepcut: right
14:50:15 <byorgey> wavewave: it is strict in the "measure" annotations and lazy in the spine, IIRC.
14:50:38 <byorgey> and the spine-laziness is exactly what makes it efficient.
14:50:53 <dcoutts> conal: wx has variable backends on each platform, it inevitably behaves somewhat different on each
14:50:55 <stepcut> dancor: in this case, character offset relative to, intercalate "/" tokens, would be ideal ;)
14:51:02 <wavewave> hm. quite difficult to understand.
14:51:06 <applicative> let blah p q = p || q || not p || not q in [blah True True, blah True False, Blah False True]
14:51:09 <conal> dcoutts: ah.
14:51:16 <stepcut> dancor: but word.char would be ok as well
14:51:22 <applicative> > let blah p q = p || q || not p || not q in [blah True True, blah True False, Blah False True]
14:51:23 <lambdabot>   Not in scope: data constructor `Blah'
14:51:33 <applicative> > let blah p q = p || q || not p || not q in [blah True True, blah True False, blah False True]
14:51:34 <lambdabot>   [True,True,True]
14:51:40 <byorgey> wavewave: out of curiosity, why do you ask?
14:52:00 <applicative> instance Monoid Bool where mempty = True and mappend = blah
14:52:10 <wavewave> byorgey: just for making a program dealing with huge output string file.
14:52:11 <byorgey> wavewave: it is not as clear-cut as saying that a data structure is lazy or strict, one or the other.
14:52:57 <byorgey> wavewave: are you having trouble, or just wondering whether those data structures will work for you?
14:52:57 <c_wraith> does anyone working on yesod hang out here?
14:53:16 <applicative> I can change blah to make the operation false if they're both false.   But that's disjunction ||  .   I think we have a theorem.  Its && , || or trivial
14:53:18 <wavewave> byorgey: I am just looking for what is the best way.
14:53:48 <wavewave> byorgey: I have used String with ++ operator until now.
14:54:10 <wavewave> byorgey: and hPutStrLn afterwords
14:54:21 <wavewave> byorgey: to save the file.
14:54:22 <byorgey> wavewave: ah. well in that case switching to anthing else will likely be a big improvement =)
14:54:43 <dancor> stepcut: i imagine it's just something like this http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8965#a8965
14:54:52 <wavewave> byorgey: what is the best method in your suggestion? :)
14:55:18 <wavewave> byorgey: in the worst case, the file size can exceed 1GB.
14:55:49 <wavewave> byorgey: For your curiosity, this is a scientific number crunching project.
14:55:51 <king313> Hi!
14:55:57 <kmc> yes a 1 GB String would be a disaster
14:55:59 <kmc> hi king313
14:56:04 <stepcut> dancor: but then the position errors from the Char parser will be relative to the string they are parsing, with out reference to the overall context?
14:56:05 <aavogt> It's amazing how tracking down bugs in ghc's warnings brings up the fact that your code is wrong
14:56:07 <chrisdone> hello there
14:56:13 <wavewave> kmc: that's right :)
14:56:15 <king313> When I try to pass as parameter to a function that accepts a Integer
14:56:22 <king313> the parameter "length list1 - length list2"
14:56:25 <dancor> stepcut: yes, but i think you can/have-to do magic with that
14:56:28 <king313> where list1 and list2 are a integer list
14:56:29 <byorgey> wavewave: hmm, this is not really my area of expertise, but you might want to use ByteStrings
14:56:31 <kmc> king313, length returns Int not Integer
14:56:33 <kmc> :t length
14:56:34 <lambdabot> forall a. [a] -> Int
14:56:41 <kmc> king313, you can convert with fromIntegral
14:56:43 <king313> kmc, how I can cast it to integer?
14:56:43 <kmc> :t fromIntegral
14:56:44 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:56:49 <chrisdone> :t genericLength
14:56:50 <lambdabot> forall b i. (Num i) => [b] -> i
14:56:52 <dancor> stepcut: i think parsec has black-magic to access that kind of state info
14:56:58 <wavewave> byorgey: ByteString append function has O(n) complexity.
14:57:01 <stepcut> dancor: I am looking at how Stream and SourcePos work now
14:57:02 <kmc> or use genericLength from Data.List as chrisdone indicated
14:57:13 <king313> kmc, sorry, I'm really unskilled in Haskell
14:57:27 <king313> I know that I have to learn by myself
14:57:29 <dancor> stepcut: also the naive errors aren't so bad because it's the position of the String in [String], then of the Char in [Char]
14:57:36 <maltem> wavewave, no real need to concat bytestrings before writing them out
14:57:48 <dancor> depending on your application it might already be close to acceptable
14:58:03 <byorgey> wavewave: oh, really? yikes
14:58:16 <king313> but I don't know how to apply the knowledge that you have give to me
14:58:24 <kmc> king313, you can use the function fromIntegral
14:58:24 <wavewave> byorgey: you mean write down to file directly?
14:58:29 <kmc> as if it has type Int -> Integer
14:58:35 <kmc> to do the conversion
14:58:38 <king313> fromIntegral (length list1 - length list2)
14:58:39 <byorgey> wavewave: well, in that case, try using Sequence and see if it works for you
14:58:41 <kmc> it actually has a more general type
14:58:43 <maltem> byorgey, for strict bytestrings, sure: they have to be copied around
14:58:45 <stepcut> dancor: ah, I see. The message might be a tad ugly, but it would have all the information
14:58:50 <applicative> king313, no you can ask here...
14:58:55 <byorgey> maltem: ok, fair enough
14:58:58 <kmc> king313, yes, or:   genericLength list1 - genericLength list2
14:59:10 <kmc> which will compute it as an Integer with no conversion
14:59:17 <pikhq> byorgey: Well, yeah. A bytestring is just a bunch of bytes in a row. ;)
14:59:18 <maltem> byorgey: for lazy ones, not so, because that's essentially [Strict.ByteString]
14:59:24 <stepcut> dancor: on the other hand, it's not the last time I'll use parsec, so I think it is worth figuring out if there is a 'better' way
14:59:25 <applicative> > genericLength "hhahaha" - genericLength "ha"
14:59:26 <lambdabot>   5
14:59:37 <jmcarthur> maltem: it's still linear in the length of the list
14:59:37 <king313> kmc, thanks!
14:59:38 <kmc> > genericLength "foo" :: Natural
14:59:39 <lambdabot>   Not in scope: type constructor or class `Natural'
14:59:41 <kmc> > genericLength "foo" :: Nat
14:59:42 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
14:59:42 <lambdabot>    arising from a use of `Data.List.gen...
14:59:50 <applicative> @type  genericLength "hhahaha" - genericLength "ha"
14:59:51 <lambdabot> forall i. (Num i) => i
14:59:55 <king313> I have no errors now
14:59:59 <kmc> where did our natural numbers go?
15:00:22 <wavewave> byorgey: hmm. so sequence is good for dealing with a large file?
15:00:22 <fax> :t infinity
15:00:23 <lambdabot> Natural
15:00:28 <kmc> :t Natural
15:00:30 <lambdabot> Not in scope: data constructor `Natural'
15:00:31 <kmc> :k Natural
15:00:32 <lambdabot> *
15:00:32 <applicative> > ( genericLength "hhahaha" - genericLength "ha") + (5::Integer)
15:00:33 <lambdabot>   10
15:00:35 <kmc> > 3 :: Natural
15:00:36 <lambdabot>   Not in scope: type constructor or class `Natural'
15:00:41 <fax> > genericLength "hahahaha" `asTypeOf` infinity
15:00:42 <lambdabot>   Not in scope: `infinity'
15:00:45 <byorgey> wavewave: I don't know.  unfortunately I kind of doubt it.
15:00:48 <applicative> @type  ( genericLength "hhahaha" - genericLength "ha") + (5::Integer)
15:00:49 <lambdabot> Integer
15:00:54 <fax> :t infinity
15:00:55 <lambdabot> Natural
15:00:56 <fax> > infinity
15:00:57 <lambdabot>   Not in scope: `infinity'
15:01:02 <byorgey> wavewave: so, why do you need to append stuff to the front and back of the string?
15:01:30 <jmcarthur> maybe try a finger tree or edwardk's in-progress rope library?
15:01:54 <jmcarthur> well, s/a finger tree/Data.Sequence/
15:02:25 <wavewave> mm actually edwardk suggested me the rope two hours ago.
15:02:27 <applicative> king313, they should stop you from saying that fromIntegral "casts" from, say, Int to Integer.  It's a function from one type to another, like length.
15:03:03 <wavewave> jmcarthur: I think rope is using finger tree and Sequence is also using finger tree
15:03:05 <byorgey> wavewave: oh, if edwardk himself suggested rope to you then you should try that =)
15:03:20 <jmcarthur> wavewave: yes
15:03:40 <jmcarthur> wavewave: but i was suggesting slightly higher level abstractions over finger tree
15:03:54 <pikhq> applicative: I've just started thinking of casts as functions from one type to another in C. :P
15:04:07 <wavewave> byorgey: hmm, actually, I am qute a newbie in haskell.
15:04:31 <wavewave> byorgey: I just want to have some stream-like operation in C++.
15:04:33 <applicative> pikhq cool..   But don't we think of a cast as revealing the secret pile of bits....?
15:04:42 <wavewave> or buffer-like.
15:04:44 <king313> applicative, thanks for the correction
15:04:59 <king313> I have so much imperative frame yet
15:05:02 <pikhq> applicative: In C? Not necessarily. It can do... Many different weird things, depending.
15:05:02 <applicative> of course, that may be what the ghc does, but its not our business.
15:05:20 <EvanR-work> a cast isnt a very well behaving function...
15:05:35 <pikhq> (note: I'm saying that's how I've started thinking of *C* casts.)
15:05:53 <byorgey> wavewave: oh, you mean, instead of writing the data out directly to the file you want to put it in an intermediate "buffer" data structure and then write that out to the file?
15:05:54 <pikhq> EvanR-work: C is not a very well-behaving language.
15:06:08 <applicative> pikhq, if figured that too, but I was thinking it was the primitive idea of casting.   From a functional point of view, there's really not much sense in the concept at all.
15:06:10 <wavewave> byorgey: that's right.
15:06:31 <kmc> king313, this doesn't have much to do with "imperative".  and imperative is not in any way the opposite of functional or Haskell
15:06:45 <byorgey> wavewave: that can work well with laziness, because the intermediate data structure can be computed "as needed" to write it to the file
15:06:49 <wavewave> byorgey: for example, i can write two files together later.
15:07:06 <byorgey> wavewave: yep
15:07:18 <EvanR-work> i wish more stuff were automatically lazy, like IO..
15:07:28 <wavewave> byorgey: that's why I am worrying about Data.Sequence.
15:07:30 <chrisdone> haha, I don't
15:07:47 <jmcarthur> EvanR-work: IO is not lazy aside from the lazy IO functions
15:07:48 <byorgey> wavewave: so the intermediate data structure will never actually get that big.  Sequence should be just fine then, I think
15:07:52 <EvanR-work> outside this channel though, i feel a growing dislike of lazy evaluation
15:08:09 <c_wraith> EvanR-work: lazy IO would be really nice, if it wasn't for errors.
15:08:12 <kmc> and the lazy IO functions are considered semantically dubious
15:08:13 <byorgey> wavewave: try it and see what happens, and come back and ask more questions here or on the haskell-beginners mailing list!
15:08:22 <jmcarthur> dubious at best
15:08:31 <wavewave> byorgey: so what you mean by "it's lazy in spine." is that?
15:09:06 <byorgey> wavewave: don't worry about it, it just means that the "spine" or "shape" of the data structure will not even be computed until necessary
15:09:51 <wavewave> byorgey: my knowledge on Data.Sequence is from Real World Haskell by the way.
15:10:03 <byorgey> ok, sounds good
15:10:41 <wavewave> byorgey: and I cannot understand Hinze and Paterson paper cited in Data.Sequence library webpage.
15:10:52 <aavogt> finger trees?
15:11:02 <wavewave> avvogt: yes.
15:11:17 <jmcarthur> just thing of a finger tree as a tree with the ends lifted up for easy access
15:11:19 <jmcarthur> *think
15:11:20 <byorgey> wavewave: ah, the fingertree paper?  That's a classic, but if you're just starting in Haskell it might be a little beyond your reach yet
15:11:37 <jmcarthur> don't worry about much else
15:11:38 <byorgey> wavewave: but you'll get there soon, I find it quite readable
15:11:44 <c_wraith> Then add a zipper to the finger tree. :)
15:11:44 <jmcarthur> yeah i like that paper
15:11:50 <wavewave> byorgey: definitely yes! but i'm interested in it. thx!
15:12:14 <wavewave> byorgey: anyway, let me try to use sequence and come back later with some result.
15:12:21 <byorgey> wavewave: ok, sounds good.  good luck!
15:12:22 <dankna> haha, drat
15:12:30 <wavewave> byorgey: thx!
15:12:31 <stepcut> dancor: thanks!
15:12:35 <dankna> ghc stops me from having cycles in type synonym definitions
15:12:52 <jmcarthur> dankna: yeah you need newtype to do that
15:13:06 <dankna> jmcarthur: yeah - don't want that :)
15:13:13 <jmcarthur> why not?
15:13:16 <dankna> well
15:13:21 <dankna> you know what I'm working on, yes?
15:13:24 <jmcarthur> yes
15:13:37 <dankna> it occurred to me that it would be nice to also have a type synonym for each and every statement type
15:13:43 <dankna> and that I could do this by adding a fourth GADT parameter
15:13:54 <dankna> but I cannot do
15:14:02 <dankna> type Vacuum = Statement L0 NT NS Vacuum
15:14:04 <dankna> I have to do
15:14:07 <dankna> data Vacuum'
15:14:08 <dankna> type Vacuum = Statement L0 NT NS Vacuum'
15:14:19 <dankna> see?
15:14:34 <dankna> I don't think this is a deficiency in Haskell per se... what I want is rather complicated :)
15:14:43 <jmcarthur> or newtype Vacuum = Vacuum (Statement L0 NT NS Vacuum)
15:14:53 <EvanR-work> whoevers idea it was to sleep forever by waiting on an MVar, it didnt work with -threaded in a real setting ;)
15:14:56 <jmcarthur> but i'm not so sure what the benefit of what you want to do is anyway
15:15:00 <applicative> > map ord "We hold these truths to be self-evident, that all men are ..."  -- I think I'll 'cast' the Declaration of Independence as [Int]
15:15:01 <lambdabot>   [87,101,32,104,111,108,100,32,116,104,101,115,101,32,116,114,117,116,104,11...
15:15:02 <EvanR-work> it canceled the program by detected deadlock
15:15:23 <chrisdone> why can't I stop coding. i'm supposed to be eating and watching a movie
15:15:31 <c_wraith> I still say the correct solution is to wait on an mvar that children have access to
15:15:44 <c_wraith> so a child can shut down the program if desired
15:15:54 <dankna> jmcarthur, well, but then I'd be exporting a type constructor...  I just want to export a type name
15:16:06 <MisterN> EvanR-work: so you have to make a "pause" action?
15:16:14 <jmcarthur> dankna: my confusion is why, so suggesting how is probably not what i should be doing
15:16:18 <jmcarthur> ;)
15:16:18 <dankna> the benefit is that it lets me write properly-typed functions which require a specific statement type as a parameter
15:16:25 <applicative> @type cast -- king313 check this out
15:16:26 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:16:32 <jmcarthur> properly-typed means what?
15:16:38 <dankna> for example, I have a utility function that takes two CREATE TABLE statements
15:16:39 <monochrom> "We hold these definitions to be self-referencing, that all functions are fixed points..."
15:16:56 <dankna> @src cast
15:16:57 <lambdabot> Source not found. My pet ferret can type better than you!
15:16:58 <maltem> wavewave, if it helps, http://www.flickr.com/photos/desegnis/2567674094/sizes/l/
15:17:19 * king313 is checking
15:17:32 <dankna> without this fourth GADT parameter there's no way to enforce that they actually are CREATE TABLEs
15:17:47 <dankna> they could just as easily be DROP TABLEs, which would cause this pure function to throw up its hands in despair
15:18:06 <jmcarthur> dankna: i get that, but why do you need synonyms?
15:18:15 <kmc> king313, applicative, "cast" is not at all useful for converting numbers between different types, i'm not sure the point of bringing it up
15:18:39 <dankna> oh, because I'm thinking of this pure function as "client code".  for maintainability's sake I don't want it to be bound tightly to the implementation of the GADT.
15:18:55 <jmcarthur> dankna: a synonym doesn't abstract that away
15:18:57 <dankna> and I certainly don't want to have to explain that implementation to somebody else.  I'm writing it "as if" somebody else wrote it.
15:19:02 <dankna> sure it does?
15:19:11 <jmcarthur> a synonym is completely transparent
15:19:17 <dankna> as long as I change the synonym if I change the GADT
15:19:24 <kmc> there are two distinct concepts of "convince the compiler that these two types are really the same" versus "convert data from this type to that type by knowing what it means"
15:19:37 <dankna> it abstracts it from the programmer's point of view
15:19:44 <kmc> these are really not very related things, but C uses the same syntax for both
15:19:45 <dankna> I know it doesn't really do anything from the compiler's point of view
15:19:50 <kmc> most other languages do not
15:19:54 <jmcarthur> dankna: if you are wanting to hide details then you want an opaque abstraction. synonyms are just sugar
15:19:58 <kmc> even C++ when you're "doing it right"
15:20:07 <kmc> and Haskell has no special syntax for either, we use ordinary functions
15:20:17 <dankna> I'm not convinced I want to hide details in the sense you mean
15:20:25 <ddarius> @check \x y z -> (x == (y == z)) == ((x == y) == z)
15:20:26 <lambdabot>   "OK, passed 500 tests."
15:20:46 <applicative> kmc, king313, sorry, I wasn't thinking 'cast' was of use.  It was just that the existence of it spoke against my claim that it was an unHaskelly concept or word.
15:20:50 <ddarius> @check \x y z -> (x /= (y /= z)) == ((x /= y) /= z)
15:20:50 <lambdabot>   "OK, passed 500 tests."
15:20:54 <dankna> if I made a newtype, I couldn't also have my types ExplainableStatement and TriggerStatement and AnyStatement, right?
15:20:58 <kmc> synonyms don't really hide anything, but they can make it easier to refactor client code and library code independently
15:21:02 <jmcarthur> dankna: if you are simply wanting to mask the gadt then the programmer will have to look at the definition of your type synonyms whenever he runs into a type error
15:21:06 <dankna> what kmc said
15:21:07 <kmc> applicative, ah, i might have missed something
15:21:12 <Philippa> ddarius: any thoughts on or additions to http://www.haskell.org/haskellwiki/Tiny_Identifier_Dictionary ?
15:21:41 <applicative> kmc, I was just saying it sounds wrong to say that things like fromIntegral are used for 'casting'
15:21:44 <dankna> jmcarthur: you're right, of course, but at least his code won't have to break when they change
15:21:45 <kmc> yeah i agree
15:21:53 <kmc> beacuse in particular, these things are never done implicitly
15:22:07 <kmc> part of the reason casts in C are special is because they happen automatically
15:22:20 <jmcarthur> dankna: well, do you understand the reason that ghc doesn't like cyclic synonym definitions?
15:22:28 <dankna> certainly - because they aren't real types
15:22:31 <ddarius> > and [((x == y) == z) == (x == (y == z)) | let b = [True,False], x <- b, y <- b, z <- b]
15:22:31 <lambdabot>   True
15:22:45 <ddarius> > and [((x /= y) /= z) == (x /= (y /= z)) | let b = [True,False], x <- b, y <- b, z <- b]
15:22:46 <lambdabot>   True
15:22:51 <applicative> well, I guess you could say there's implicit casting when the compiler decides what type to put "1+1" into
15:22:53 <dankna> a cycle in a synonym definition would be impossible to ever construct
15:23:03 <jmcarthur> dankna: i'm thinking if you want another gadt parameter it will need to just be a phantom type and that's it
15:23:22 <dankna> *sigh* now I need to look up phantom types :)
15:23:30 <jmcarthur> dankna: you're using phantom types already
15:23:36 <ddarius> byorgey: &&, ||, ==, and /= are all the Boolean monoids.
15:23:40 <dankna> those are those types without constructors?
15:23:51 <jmcarthur> without data constructors, yes
15:23:54 <dankna> yeah
15:23:55 <applicative> kmc: as with
15:23:59 <applicative> > filter ((== 1 + 1) .length) ["ha","hahah"]
15:23:59 <mauke> dankna: types with unused parameters
15:24:00 <lambdabot>   ["ha"]
15:24:03 <monochrom> data Hello a = Whee is a phantom type.
15:24:05 <dankna> mauke: okay
15:24:09 <kmc> dankna, or the related idea of types with type parameters not used in the data
15:24:12 <kmc> yes, that "a"
15:24:28 <jmcarthur> oh i had my terminology misassigned
15:24:30 <kmc> applicative, you mean defaulting?
15:24:44 <jmcarthur> i had it assigned to the empty data declarations often used in those type variables
15:24:50 <kmc> err no, because "length" already constrains it to Int
15:24:51 <monochrom> If you export Hello but not Whee, thus making your user's life harder, then you get the spirit of phantom type.
15:25:01 <ddarius> Philippa: It may make sense to split into identifiers used at the term level and identifiers used at the type level.
15:25:14 <kmc> anyway i'll be back later
15:25:15 <applicative> versus
15:25:16 <applicative> > filter (== 1+1)( [1..100]:: [Integer])
15:25:17 <lambdabot>   [2]
15:25:20 <dankna> kmc: okay, see you around
15:25:29 <applicative> kmc, one of these isn't defaulting.
15:25:58 <ddarius> Philippa: Also, the ' convention might warrant mentioning.
15:25:59 <byorgey> ddarius: what? == and /= are not even associative
15:26:01 <dankna> okay, anyway, so jmcarthur, that sounds like what I just did
15:26:11 --- mode: ChanServ set +o monochrom
15:26:22 <byorgey> > (True == False) == False
15:26:23 <lambdabot>   True
15:26:27 --- mode: monochrom set -q medfly!*@*
15:26:30 <byorgey> > True == (False == False)
15:26:31 <lambdabot>   True
15:26:32 --- mode: monochrom set -o monochrom
15:26:34 <byorgey> err
15:26:45 <applicative> > ( filter (== 1+1)( [1..100]:: [Integer]),  filter ((== 1 + 1) .length) ["ha","hahah"])
15:26:46 <lambdabot>   ([2],["ha"])
15:26:54 <monochrom> boolean == is associative and commutative
15:26:58 <jmcarthur> dankna: i'm just saying that the type synonyms is a different issue
15:27:03 <ddarius> byorgey: See the stuff I fed to lambdabot above.
15:27:18 <jmcarthur> i'd just get the gadt right first to save extra typing in the first place
15:27:27 <byorgey> oh!  hmm, how did I convince myself they weren't?
15:27:41 <dankna> jmcarthur, hmm.  okay.  I take your point.
15:27:44 <applicative> kmc, isn't "1+1" getting 'cast implicitly' somewhere in there?
15:28:01 <monochrom> by typo or misread
15:28:17 <ddarius> > True == True == True
15:28:18 <lambdabot>   Precedence parsing error
15:28:18 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
15:28:30 <dankna> jmcarthur, anyway I just did it using types without data constructors and type synonyms together, and it worked for me
15:29:10 <jmcarthur> @check \a b c -> (((a::Bool)==(b::Bool))==(c::Bool)) == (a==(b==c))
15:29:11 <lambdabot>   "OK, passed 500 tests."
15:29:30 <byorgey> oh! well, /= is the same as the group operation in Z_2, so of course it is commutative
15:29:39 <ddarius> Philippa: k and c for continuation
15:29:46 <ddarius> byorgey: Indeed.
15:30:02 <byorgey> agh, I meant associative.
15:30:06 <lispy> data PessimisticMaybe a = Never; that's a phantom type :)
15:30:08 <byorgey> it is obviously commutative.
15:30:38 <ddarius> byorgey: Selecting either True or False leaves only the question of what (not mempty) `mappend` (not mempty) means, which is either mempty or not mempty.
15:31:06 <byorgey> ddarius: ah, that's an excellent way of looking at it.
15:31:23 <ddarius> Philippa: w for comonad, but that doesn't come up often
15:32:35 <jlouis> ddarius: if you turn it around...
15:34:42 <noss> If I have a list of items and a predicate on them, how do i find sublists separated by items that are false and are N items away from any item that is true?
15:36:07 <ddarius> Philippa: Finally, p for predicate and e for error/exception type
15:39:05 <byorgey> noss: I'd first annotate the list elements with the smallest distance to an element for which the predicate is true; then split up the list according to the annotations
15:39:25 <applicative> noss, is there an element of the type you're making lists of that you're not using?  Then it would be easy to map "aenmioukksliekssssslueee" to "aeiouie....
15:40:39 <byorgey> applicative: no, don't use an "unused" element, ADD an unused element
15:40:42 <byorgey> called Nothing =)
15:40:48 <applicative> yeah, nothing
15:40:56 <applicative> Nothing
15:42:19 <applicative> > map (\x-> if even x then Just x else Nothing) [1,2,3,2,3,1,4,5,6,7,8,8,8,8,8]
15:42:20 <lambdabot>   [Nothing,Just 2,Nothing,Just 2,Nothing,Nothing,Just 4,Nothing,Just 6,Nothin...
15:43:07 <byorgey> but why do that?  now you've lost the elements that didn't satisfy the predicate
15:44:12 <Philippa> ddarius: added your suggestions (aside from ' for now), will probably do the term/type separation tomorrow and possibly conventions separately as well
15:44:14 <applicative> yes of course.  I only have their positions
15:45:03 <chrisdone> > groupBy even [1,2,3,2,3,1,4,5,6,7,8,8,8,8,8]
15:45:03 * Philippa would be interested to see what someone like Conor might add to the list
15:45:04 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
15:45:04 <lambdabot>         against inferred ...
15:45:22 <chrisdone> :t groupBy
15:45:23 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:45:23 <applicative> But I'm not getting closer to the distance problem, of course
15:45:37 <EvanR> applicative: if (f x) then Just x else Nothing, isnt there a better way to write that
15:45:57 <EvanR> something f x
15:45:59 <chrisdone> > groupBy ((==) `on` even) [1,2,3,2,3,1,4,5,6,7,8,8,8,8,8]
15:46:00 <lambdabot>   [[1],[2],[3],[2],[3,1],[4],[5],[6],[7],[8,8,8,8,8]]
15:46:05 <applicative> EvanR, there must be, it's hideous
15:46:12 <ddarius> EvanR: Not really.
15:46:52 <ddarius> Actually... you can write guard (f x) >> return x but that's not much better and somewhat obfuscatory
15:47:18 <chrisdone> actually I think that's really nice but suite yourself
15:47:22 <chrisdone> suit
15:47:44 <applicative> noss, I think I'm not understaning the problem specification
15:48:28 <noss> i took myself a glass of whisky to think about it. i think i need a functional queue.
15:49:52 <applicative> but could you give an illustration of the value of this function for some simple argument?
15:50:09 <chrisdone> then we can use it as a quickcheck property
15:50:17 <applicative> I guess you need a list and an Int for arguments
15:50:50 <noss> okay, but in erlang then? :)   [1,2,3,4,5,6,7,8,9,10,11,12] and the predicate being equal to 3 or 10, and N=1, then i want [[2,3,4], [9,10,11]]
15:51:21 <chrisdone> what's N for?
15:51:21 <EvanR> what a funny function!
15:51:33 <noss> this is for outputting context lines in a unified diff. the predicate is an item that has been deleted or inserted.
15:52:25 <EvanR> compute all groups of 2*N+1, then filter based on (pred midpoint)
15:52:33 <EvanR> ;)
15:53:10 <noss> Sic, I actually need to know starting line number in before and after versions.
15:53:29 <chrisdone> noss: your problem specifications suck
15:53:37 <noss> chrisdone, thanks
15:53:42 <EvanR> lol
15:53:42 <chrisdone> haha
15:55:37 <byorgey> hmm, the funny thing is that we want to pass information about things that satisfy the predicate both forward and backward through the list
15:55:55 <Botje> noss: you can zip3 the list with [1..] and its reverse
15:56:11 <byorgey> you can do this with some clever knot-tying (borrowing results from future computations), but it's too fiddly to be worth doing it that way
15:56:15 <Botje> then you can take content from both ways
15:56:29 <applicative> noss, I see, I misunderstood.   You want the things that pass the test, together with a little covering of losers around them.
15:56:31 <byorgey> I guess this really calls for attribute grammars =)
15:56:40 <Botje> wait, that won't work :(
15:57:01 <noss> applicative, yes. im having much trouble to describe the actual problem, which is part why im having trouble finding a solution
15:57:22 <Botje> basically, you want a function that works like grep -C :]
15:57:48 <applicative> well, it's haskell, the ideology is that once you formulate the problem you'll have the solution. I sense it will work out here.
15:58:01 <noss> Botje, yeah, that would pose a similar problem.  I'm still thinking about using a queue.
15:58:24 <EvanR> map (coveringForWinner list) (map pred list)
15:58:54 <dv-> @pl \p -> filter (not p)
15:58:54 <lambdabot> filter . not
16:01:01 <EvanR> im wondering about performance tools for haskell, how can you tell whats taking a long time?
16:01:34 <jmcarthur> EvanR: ghc has profiling flags and a runtime to support it :)
16:01:54 <EvanR> generates profiling info, then feed to gprof?
16:01:56 <applicative> noss, are the lists you are going to treat long, or just twenty terms long?
16:02:19 <jmcarthur> EvanR: it generates the results itself i think, no gprof
16:02:27 <EvanR> oh
16:02:29 <jmcarthur> EvanR: it also does heap profiling :)
16:03:16 <jmcarthur> the heap profiling does require post processing though
16:03:37 <noss> applicative, lines of textfiles, so 10000 lines is not unresonable.
16:04:50 <applicative> yeah i see why you are thinking in terms of queues.
16:05:06 <applicative> there must be something more beautiful
16:06:43 <jmcarthur> just jumping in, what's the problem statement?
16:07:24 <chrisdone> EvanR: criterion is a nice benchmarking library
16:07:56 <chrisdone> EvanR: different to profiling obviously, but it helps you optimise individual bits of code
16:08:02 <noss> jmcarthur, something similar to grep -C N
16:08:10 <jmcarthur> noss: i read up. are you wanting to get the line and n surrounding lines?
16:08:22 <noss> jmcarthur, yes.
16:08:34 <jmcarthur> noss: maybe you should look into using a zipper?
16:09:14 <jlouis> oh, a zipper would be a nice way to solve that
16:09:40 <chrisdone> guy at zurihac was telling me about zippers
16:09:51 <EvanR> is there a function application operator that works in reverse. x ? f
16:10:00 <EvanR> sort of like >>=
16:10:12 <jlouis> =<< you mean :)
16:10:21 <jmcarthur> jlouis: no, =<< is "normal"
16:10:45 <applicative> flip ($)
16:10:48 <jmcarthur> f =<< x  as opposed to  x >>= f
16:11:04 <EvanR> x (flip ($)) f
16:11:05 <jmcarthur> :t ($)
16:11:06 <lambdabot> forall a b. (a -> b) -> a -> b
16:11:08 <jmcarthur> :t (=<<)
16:11:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:11:11 <jlouis> ah, yes
16:11:31 <chrisdone> :t (>>>) -- nice for composition
16:11:32 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:11:54 <EvanR> x (>>>>) f = f x
16:11:55 <EvanR> :)
16:12:15 <applicative> 3 `flip ($)` even
16:12:26 <EvanR> (>>>>) = flip ($)
16:12:31 <applicative> > 3 `flip ($)` even
16:12:32 <lambdabot>   <no location info>: parse error on input `('
16:13:04 <jmcarthur> applicative: that's invalid
16:13:09 <jmcarthur> :(
16:13:16 <applicative> even $ 3
16:13:25 <applicative> > even $ 3
16:13:26 <lambdabot>   False
16:16:05 <ezyang> Random question: is reddit emk Edward Kmett?
16:16:22 <ezyang> actually, that seems pretty unlikely
16:16:25 <EvanR> so there are cases where the compiler cannot infer the types without help from ::
16:17:04 <c_wraith> yeah.  using several type-system extensions will put you in that situation.  as will using polymorphic recursion
16:17:08 <byorgey> EvanR: I like using >$> for that
16:17:21 <byorgey> x >$> f1 >>> f2 >>> f3  etc.
16:17:40 <fax> I wrote a haskell program that turns logical statements into equivalent polynomials
16:17:49 * jmcarthur doesn't really ever want reverse application except sometimes for point free functions
16:18:00 <jmcarthur> in which case i defined applyTo = flip (%)
16:18:09 <fax> e.g. 2|x & 3|x & x>1 gives exists x1 x2 x3, ((x - 2 x1)^2 + (x - 3 x2)^2)^2 + (2 - x + x3)^2
16:18:25 <EvanR> c_wraith: i seem to be able to trigger it by having a function return [] and take a variable that i later pass (read x) into
16:18:28 <jmcarthur> as in, applyTo x
16:18:55 <c_wraith> EvanR: that sounds like the monomorphism restriction, then.  I tend to forget about it
16:19:02 <EvanR> whats that
16:19:04 * fax is using it to try and find a number which is divisible by 2 3 5 and is greater than 1... it's takinga  LONG time
16:19:14 <byorgey> fax: hehehe
16:19:29 <c_wraith> The MR is an evil piece of history.
16:19:44 <jmcarthur> EvanR: the monomorphism restriction is a nearly pointless restrictrion imposed by haskell 98. use -XNoMonomorphismRestriction to disable
16:20:02 <c_wraith> I guess it's not necessarily what you encountered.  You can also need type signatures on something like "read . show"
16:20:07 <c_wraith> :t read . show
16:20:08 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
16:20:24 <c_wraith> err, backwards
16:20:27 <c_wraith> :t show . read
16:20:28 <lambdabot> String -> String
16:20:31 <jmcarthur> lol
16:20:40 <jmcarthur> there's a case where that would fail though, yes
16:20:48 <fax> I wonder if you can defined negation in this
16:20:52 <fax> like logical not
16:20:54 <EvanR> > id == (show . read)
16:20:55 <lambdabot>   No instance for (GHC.Classes.Eq
16:20:55 <lambdabot>                     (GHC.Base.String -> GHC...
16:21:06 <EvanR> ;)
16:23:12 <EvanR> jmcarthur: compiled with -prof... wheres my report? :)
16:23:26 <jmcarthur> EvanR: run with +RTS -p
16:23:27 <chrisdone> > let k = 2;loeb x = fmap ($ loeb x) x; extract xs f (n,x) = any f [xs!!(n'-k)|n'<-[n..n+k*2],n'-k>=0,n+k<length xs]; xs = [1,3,5,2,7,9,11,13,15] in map snd . filter (extract xs even) . zip [0..] $ xs
16:23:28 <lambdabot>   [3,5,2,7,9]
16:23:29 <chrisdone> hahaha
16:23:51 <chrisdone> possibly the worst haskell code ever pasted into here
16:24:26 <jmcarthur> EvanR: might also want to compile with, say, -auto-all -caf-all
16:24:34 <EvanR> yeah, no output
16:24:38 <jmcarthur> EvanR: so that it collects information from more functions
16:24:38 <EvanR> so far
16:24:42 <jmcarthur> EvanR: it outputs to a file
16:24:45 <EvanR> ah
16:24:55 <c_wraith> > let x = fix x in x
16:24:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
16:25:00 <jmcarthur> EvanR: should have a .prof extension i think
16:25:06 <c_wraith> it's .hp
16:25:13 <chrisdone> noss: I dunno how fast loeb is. would be interested to see .
16:25:15 <jmcarthur> c_wraith: that's heap profiling
16:25:19 <EvanR> nice
16:25:22 <c_wraith> oh, is this a different profile?  oops
16:25:55 <dankna> bah.  Haskeline doesn't support multiple-line input.  I had hoped it might.
16:25:57 <jmcarthur> EvanR: btw, you can also get gc statistics with +RTS -s, iirc, and you don't have to build with profiling to get that
16:26:08 <chrisdone> dankna: what's haskeline?
16:26:10 <aavogt> @type let loeb x = fmap ($ loeb x) x in loeb
16:26:11 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
16:26:30 <aavogt> @type fix
16:26:31 <lambdabot> forall a. (a -> a) -> a
16:26:33 <dankna> Chrisdone: a library similar to GNU readline (famously GPL rather than LGPL) or to Editline, for processing user input at the terminal.
16:26:47 <chrisdone> dankna: oh nice
16:26:50 <dankna> yes
16:27:01 <dankna> it does seem rather nice, although it doesn't do what I want :)
16:27:01 <jmcarthur> EvanR: http://book.realworldhaskell.org/read/profiling-and-optimization.html
16:27:16 <EvanR> so %alloc means what
16:27:25 <EvanR> memory usage
16:27:28 <fax> > let solve n = find (\x->2^n-7==x^2) [1..] in map solve [3,4,5,7,15]
16:27:29 <lambdabot>   [Just 1,Just 3,Just 5,Just 11,Just 181]
16:27:57 <jmcarthur> EvanR: also see http://research.microsoft.com/en-us/projects/threadscope/ for even more profiling goodness (parallelism in this case)
16:33:48 <EvanR> are CAFS evaluated before runtime?
16:34:13 <chrisdone> what's a CAFS?
16:34:24 <Philippa> CAF - Constant Applicative Function
16:34:27 <EvanR> CAFs
16:34:47 <Philippa> for example, nats = [1..]
16:34:57 <EvanR> well, i guess they arent ;)
16:35:05 <chrisdone> ah, cool
16:35:08 <Philippa> nats is a constant, but it's a "function" in that they're code
16:35:27 <chrisdone> sure
16:35:29 <Philippa> EvanR: yeah, that's an illustrative example for the general case :-)
16:35:41 <EvanR> the link just told me that CAFs have a 'one off cost' because its only evaluated once
16:35:46 <EvanR> [1..] would not be like that
16:36:02 <jmcarthur> EvanR: CAFs are not necessarily evaluated at compile time, right
16:37:08 <Philippa> EvanR: [1..] can be like that, but what you get in return is a "CAF leak"
16:37:11 <aavogt> Philippa | CAF - Constant Applicative Function
16:37:14 <aavogt> isn't it form?
16:37:29 <Philippa> aavogt: er, possibly, yeah. Depends on the exact context, I suspect
16:37:33 <ddarius> nat is an application of a function to an argument, thus beta-reducible, and not a value.
16:37:38 <luite> chrisdone: which version of the json libraries did you use to build haskell-jsonrpc? the latest version gives an error when compiling (line 298)
16:37:39 <ddarius> Yes, "Form."
16:38:01 <ddarius> (in a more strict sense of "value")
16:38:09 <Philippa> EvanR: a CAF leak is where a CAF turns into some huge value and you never want most of it ever again but the GC can't collect
16:38:16 <chrisdone> luite: seems a few people get that build error. I'll update whatever version I have and rebuild the library
16:38:22 <EvanR> sucks
16:38:36 <aavogt> well once you know it, just make the CAF a function
16:38:40 <chrisdone> luite: currently using json-0.4.3
16:38:44 * chrisdone checks the latest on hackage
16:38:49 * Philippa heads off for the night
16:38:59 <jmcarthur> the situation isn't too difficult to prevent. i've had it happen once. sucked to figure out but was an easy fix
16:39:10 <luite> json 0.4.3 here too, hjson 1.1.1
16:40:22 <chrisdone> luite: I don't have hjson installed. hmm. is it even in the .cabal file?
16:40:45 <luite> don't know why I got it, it's somewhere in the dependencies I guess
16:40:55 <chrisdone> ah maybe from json
16:42:45 <chrisdone> luite: i'm updating my stuff. can you hpaste the error?
16:43:17 <merehap> @hoogle String -> Handle
16:43:18 <lambdabot> Prelude error :: [Char] -> a
16:43:18 <lambdabot> Debug.Trace trace :: String -> a -> a
16:43:18 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
16:43:31 <merehap> is there a way to create a handle from a string?
16:43:47 <merehap> I'd like to spoof the stdin and stdout of a process
16:44:34 <luite> chrisdone: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24404#a24404
16:44:51 <jmcarthur> merehap: umm, you could write the string out to a file and then open it
16:45:08 <jmcarthur> i dunno about "spoofing" stdin and stdout though
16:45:14 <merehap> I was definitely hoping to avoid that...
16:45:17 <merehap> :t runProcess
16:45:18 <lambdabot> Not in scope: `runProcess'
16:45:38 <merehap> runProcess in System.Process takes three handles as input
16:45:49 <jmcarthur> merehap: maybe you could spawn a cat process and write the string to its stdin and use its stdout as your handle
16:45:57 <merehap> so it provides most of the spoofing means
16:46:13 <jmcarthur> umm
16:46:22 <chrisdone> luite: it's building fine here. I'll check the latest version is up
16:46:24 <jmcarthur> i could just write to the handle you give it
16:46:28 <jmcarthur> *you could
16:46:55 <merehap> but I don't have a way of creating that handle without accessing the file system...
16:47:48 <merehap> in C#, for example, the Stream class fills the same role as the Handle type, but there is a MemoryStream class
16:47:57 <merehap> which is basically the equivalent of what I need
16:48:16 <merehap> I can hack around it, but it'd be nice if there were a non-IO solution
16:48:16 <aavogt> @hoogle String -> Handle -> IO ()
16:48:16 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
16:48:16 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
16:48:16 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
16:48:31 <EvanR> jmcarthur: man. so it seems easy to write a list processing function that wastes a ton of space and time, and a horrendous combinatino of foldl' and seq are needed to make haskell strict ?
16:48:35 <merehap> aavogt: yes, but I can't get that Handle in the first place
16:48:41 <aavogt> @hoogle runProcess
16:48:41 <lambdabot> No results found
16:48:59 <aavogt> you get the handle when you run the other process
16:49:30 <aavogt> @type System.Process.runProcess
16:49:31 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> IO System.Process.Internals.ProcessHandle
16:49:32 <chrisdone> luite: try pulling again. does it build now?
16:49:39 <merehap> for runProcess, the handles are inputs to the process not outputs
16:49:41 <jmcarthur> EvanR: i'm not a big fan of seq. there are alternatives. pattern matching is strict
16:50:01 <merehap> @type System.Process.runInteractiveProcess
16:50:02 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
16:50:05 <jmcarthur> EvanR: but since seq is everywhere anyway i just use it
16:50:17 <jmcarthur> EvanR: and foldl' isn't ugly, IMO, aside from the use of seq
16:50:28 <merehap> this has them as outputs, but GHC detects a loop when running it, for some reason
16:50:53 <aavogt> merehap: can you paste the code that causes <loop>?
16:51:04 <merehap> sure, just a moment
16:51:10 <luite> chrisdone: nope, another error
16:51:16 <chrisdone> luite: what error?
16:51:18 <jmcarthur> EvanR: a polymorphic alternative to seq would be a Seq type class that uses pattern matching, which wouldn't allow using seq on functions, preserving parametricity :)
16:51:31 <EvanR> heh?
16:51:54 <luite> chrisdone: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=24404#a24405
16:53:00 <merehap> runInteractiveProcess ref args Nothing Nothing
16:53:19 <merehap> ref is something like /bin/cat
16:53:40 <merehap> args is whatever, I'm using a list of length 5 for it
16:53:45 <chrisdone> luite: my ghc is 6.10.4. what's yours? 6.12?
16:53:58 <merehap> I specify Nothing for the environment and working directory
16:54:02 <luite> chrisdone: yes, just upgraded
16:54:22 <chrisdone> it seems everyone but me has this error haha
16:54:30 <chrisdone> hard to debug
16:55:19 <chrisdone> luite: it must be that one of the dependancies imports hjson
16:55:50 <luite> this is basically a clean install of ghc 6.12.1 on ubuntu, with cabal-install 0.8.0 and only the depedencies required for haskell-jsonrpc installed
16:55:51 <chrisdone> luite: ahhh
16:55:55 <chrisdone> I bet it's hjpath
16:56:16 <luite> ah that's probably it, I remember installing that
16:56:29 <luite> but would that cause the second error? the first one seems to be gone now
16:57:02 <chrisdone> ahhh. I built it with hjpath1.0, which doesn't have the json dependancy
16:57:10 <chrisdone> now it does at version 2.0. I'll update it and fix the package
16:58:28 <chrisdone> luite: ha, tada, I got the same error.
16:59:40 <danderson> I want to start a group of threads with shared lifetime (if one thread crashes, all threads in the group get killed), similar to one of Erlang's OTP process control functions. Is there a way to improve on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24406#a24406 ?
16:59:44 <jeffwheeler> I'm trying to compile with the new Cabalized Gtk2Hs packages, but I seem to be getting very sporadic linking errors to glib: http://pastie.org/889234
17:00:13 <danderson> oh, and just as I hit enter, I realize that the Broadcast variable is unnecessary.
17:00:14 <jeffwheeler> It /seems/ as if I changed completely unrelated code to bring it back.
17:01:59 <monochrom> danderson: I would do the same.
17:02:28 <chrisdone> luite: still fixing..
17:02:47 <danderson> monochrom: cheers
17:03:12 <merehap> aavogt: ah, nevermind, made a stupid unrelated mistake, thanks
17:03:32 <luite> chrisdone: no problem, take your time :)
17:04:11 <chrisdone> what's that thing that's like hoogle
17:04:13 <chrisdone> but another one
17:05:41 <dmwit> chrisdone: hayoo?
17:05:52 <chrisdone> yeah that's it, thanks
17:07:40 <chrisdone> luite: ok, fixed
17:08:20 <chrisdone> luite: hjpath maintainer decided it would be a good idea to change the constructors of the types by using a different json library. so now that's a new dependancy :p
17:08:24 <chrisdone> luite: I'll push my changes
17:08:31 <cads> Hooray, functors are like baby monads
17:08:41 <monochrom> heh
17:08:43 <fax> o_o is Qiaochu Yuan a #haskeller??
17:08:50 <monochrom> @remember cads Hooray, functors are like baby monads
17:08:50 <lambdabot> I will never forget.
17:08:52 <luite> chrisdone: ah
17:09:19 <chrisdone> luite: ok, give that a go?
17:10:28 <luite> chrisdone: still the CGI.sessionId error
17:10:29 <ddarius> cads: A functor being a monad is a reasonably special property.
17:10:32 <chrisdone> you'll have to cabal clean/configure/build
17:10:48 <chrisdone> luite: which error is that? you pasted only json errors iirc
17:11:16 <luite> chrisdone: I added it to the hpaset
17:11:18 <luite> hpaste
17:11:34 <luite> but it's line 378 now, with the latest revision
17:12:09 <chrisdone> ahh, hm
17:12:34 <luite> using cgi-3001.1.8.1 here, and cgi-utils-0.0
17:12:50 <chrisdone> luite: did you install cgi-utils from github or hackage?
17:13:20 <chrisdone> github one is probably more up to date
17:14:07 <luite> oh, hackage
17:14:55 <chrisdone> I wonder if I can hack cabal to support using github as a repository
17:15:57 <luite> thanks, works now, with the git cgi-utils
17:16:03 <aavogt> for cabal to be able to build versions from the repos linked in cabal files on hackage?
17:16:56 <chrisdone> sweet it already supports adding repos for git
17:17:12 <chrisdone> aavogt: I meant locally but yes that would be sweet too
17:17:21 <chrisdone> luite: excellent. =)
17:17:46 <aavogt> I think those fields are more useful for buildbots...
17:18:19 <aavogt> sometimes the most difficult part is coming up with a sane interface
17:20:01 <chrisdone> if I could do cabal install cgi-utils --dev or something which would follow the development scm repo and download from that, that would suit my taste
17:20:08 <chrisdone> bbl
17:20:23 <aavogt> or a separate  cabal install-dev ...
17:20:51 <aavogt> then the question of following dependencies' repos
17:21:27 <aavogt> I suppose that would possibly involve using cabal's version tags
17:21:36 <aavogt> currently those are quite unused
17:23:37 <chrisdone> aavogt: so, what, it keeps track of versions of packages and uses git/mercurial/whatever's unique version hash key, and looks those up every time you install a package?
17:23:48 <luite> chrisdone: by the way, I see a textbox on the left of my screen on tryhaskell, when I maximize my browser
17:24:15 <chrisdone> luite: what browser is that?
17:24:18 <aavogt> chrisdone: I mean that cabal supports additional stuff added to the versions
17:24:35 <aavogt> like   package-1.0.0-dev
17:24:42 <luite> chrisdone: firefox and chrome
17:24:56 <chrisdone> aavogt: ahh, cool
17:25:12 <aavogt> rather than having the confusion of developers needing to make up new release numbers before stuff is officially released
17:25:19 <aavogt> *long before
17:25:29 <luite> chrisdone: at 2560x1600 resolution (no I don't usually use maximized browsers :) )
17:25:29 <chrisdone> luite: the console implementation uses a hidden textbox, it should be off screen but maybe you have a huge screen. hum
17:26:14 <chrisdone> luite: oh, looks like I typo'd
17:26:20 <chrisdone> typer.css({position:'absolute',top:0,left:'-999px'});
17:26:23 <chrisdone> should be -9999px
17:26:35 <luite> ah I don't have a screen _that_ large, unfortunately :p
17:26:55 <chrisdone> luite: can always dream
17:27:32 <kmc> @hoogle Control.Concurrent.Event
17:27:32 <lambdabot> No results found
17:27:43 <kmc> danderson, where does it come from?
17:28:12 <chrisdone> luite: yeah that fixed it. hehe
17:28:34 <chrisdone> luite: what are you doing with haskell-json if anything? curious
17:29:00 <luite> ok great :) your patched mueval compiled fine too by the way, with ghc 6.12.1
17:29:06 <chrisdone> excellent
17:29:20 <chrisdone> did you just pull that from github?
17:29:38 <kmc> danderson, fwiw, i think you could do it with a regular MVar
17:29:46 <luite> I'm trying to get tryhaskell running on my server first. I wanted to use it for a blog, for examples with haskell code
17:30:14 <luite> not sure if I have enough time to pull it off
17:30:18 <chrisdone> luite: awesome
17:31:29 <luite> I use apache 2.2, so I still need to figure out the fastcgi configuration
17:31:57 <chrisdone> ahhh
17:32:44 <chrisdone> http://passingcuriosity.com/2009/haskell-fastcgi-with-apache/ -- if it helps
17:50:23 <humasect> is there a method to have ghc generate c code without library dependency? for use with iphone software
17:54:34 <jeffwheeler> humasect: I think llvm is more interesting for that, but check out #haskell-iphone and http://haskell.org/haskellwiki/iPhone
18:00:59 <ivanm> wtf? http://www.reddit.com/r/haskell/comments/bitlg/trigonometry_in_haskell_help_me_rhaskell/
18:01:09 <luite> chrisdone: got fastcgi running, but the redirect doesn't work yet (so I just changed the url in the js files)
18:01:33 <luite> only problem is that the only reply from haskell-json.fcgi is 'Terminated' :)
18:01:42 * hackagebot xhtml-combinators 0.2 - Fast and easy to use XHTML combinators.  http://hackage.haskell.org/package/xhtml-combinators-0.2 (AlasdairArmstrong)
18:03:41 <ivanm> oooh, that looks nice...
18:06:07 <ivanm> mauke: I thought preflex was dead yesterday because it wasn't responding to anything
18:06:17 <ivanm> (at the time)
18:06:37 <mauke> yes, because you didn't use a recognized command
18:06:38 <luite> chrisdone: lol:  where path = "/home/chris/.cabal/bin/mueval-core"
18:06:46 <ivanm> I used seen, did I not?
18:06:49 <mauke> nope
18:07:13 <mauke> <ivanm> preflex: seena X-Scale
18:07:15 <mauke> <ivanm> preflex: seena Axman6
18:07:34 <ivanm> aha
18:07:45 <ivanm> aha, I _did_ hit the a key!
18:07:50 <ivanm> I just hit space after it :s
18:08:05 <ivanm> my apologies to you and your bot mauke
18:08:08 <SamB_XP> obviously, he needs support for italian ;-P
18:08:18 <ivanm> yeah! :D
18:08:44 <marko_> Do any of you guys know anything about PPM image manipulation in Haskell?
18:10:57 <ivanm> marko_: don't ask ANU assignment questions here! :p
18:11:07 <ivanm> marko_: what you need to know for the assignment isn't how it's normally done
18:11:18 <marko_> :(
18:11:28 <SamB_XP> marko_: it should be pretty easy!
18:11:40 <SamB_XP> maybe the ppm manpage would be of use?
18:11:53 <ivanm> SamB_XP: all the PPM related stuff is done for them
18:12:00 <ivanm> they're just doing [[(Int, Int, Int)]]
18:12:04 <SamB_XP> oh, hehehe
18:12:13 <marko_> Yeah i find writing the functions easy but mapping them to the row has me stumped...
18:13:28 <ivanm> marko_: https://cs.anu.edu.au/streams/forum.php?MsgID=52030
18:13:34 <SamB_XP> oh rats, djinn can't do list traversals :-(
18:13:55 <ivanm> yeah :(
18:14:54 <marko_> Thanks Ivan
18:15:03 <marko_> helps if i read my own forum first lol
18:15:30 <ivanm> yup
18:17:50 <luite> hmm, I wonder wy haskell-json.fcgi + mueval-core cannot find Graphics.Raphael, while mueval-core from the terminal can
18:21:26 <chrisdone> luite: I had a similar problem with lighttpd where the package had to be installed globally
18:21:46 <chrisdone> dunno if that's the same problem
18:22:02 <mrAlex> greets all
18:22:36 <kmc> hi
18:22:43 <dancor> can TH generate a data Dat = Dat {datA :: Int, datB :: String, ..}  ?
18:22:55 <aaronl_> hi all... i decided to try learning haskell, so i ported a short lisp program to it. i got it to work, but it's 100x slower than the lisp version, and i'm really sure what's going on. i think it might be lazy evaluation gone amuck.
18:23:14 <aaronl_> if anyone has a few minutes to look at it, i posted the haskell version at http://paste.lisp.org/display/96940
18:23:16 <SamB_XP> aaronl_: could be
18:23:42 <kmc> dancor, probably, what do you want more specifically?
18:23:57 <kmc> aaronl_, how are you running it?
18:24:27 <aaronl_> i just annotated the paste with the lisp version in case that's helpful
18:24:34 <aaronl_> kmc: i'm compiling it with ghc
18:24:38 <kmc> Haskell and LISP don't have speeds... which implementations are you using and how?
18:24:42 <dancor> kmc: i'm considering going from an option specification where like "version" in the input becomes data Opts = Opts {optVersion :: Bool, ..}
18:24:44 <kmc> aaronl_, with -O2 ?
18:24:45 <aaronl_> kmc: using -O made it about 3x faster
18:24:49 <kmc> ah
18:24:51 <luite> chrisdone: yeah I installed it for my user only, I think it has to do with the environment variables for the fastcgi progam
18:25:16 <jmcarthur> eek that's a lot of explicit recursion
18:25:21 <SamB_XP> kmc: the code can have speeds, as executed by some person with some implementations ;-P
18:25:25 <aaronl_> ah, could that be the problem?
18:25:25 <jmcarthur> i can barely follow the code
18:25:39 <aaronl_> will it be building a list of function applications instead of just applying the functions?
18:25:46 <jmcarthur> aaronl_: combinators are more fusable, perhaps, but i doubt that's the complete reason
18:26:05 <SamB_XP> maybe it would be easier to see the problem if he used combinators, though ?
18:26:06 <jmcarthur> aaronl_: i only complain about explicit recursion because i can't read it as easily ;)
18:26:17 <SamB_XP> or maybe it would disappear in the process ;-P
18:27:07 <aaronl_> i'd definitely be interested in better ways to express particular parts of it
18:27:22 <aaronl_> i realize it's not clear what the code actually does, which probably doesn't help
18:27:40 <kmc> aaronl_, i doubt it's a big deal but you're doing the comparison twice in "order"
18:27:40 <mrAlex> what is the algorithm you have implemented?
18:28:58 <twink> Looks like pretty printing uses Text.PrettyPrint.HughesPJ
18:29:58 <aaronl_> i forgot to mention that the executable ghc produces takes about 600 mb of ram to run
18:30:04 <aaronl_> maybe that's a clue about what i'm doing wrong
18:31:24 <jmcarthur> aaronl_: yeah that's a sign of a major space leak
18:31:30 <jmcarthur> aaronl_: what does this code do?
18:31:40 <aaronl_> it solves a discrete math problem
18:31:58 <kmc> aaronl_, you can also add type signatures, this might possibly let GHC specialize some of your otherwise polymorphic functions
18:32:03 <kmc> though it doesn't seem to matter much here
18:32:09 <aaronl_> first it generates pythagorean triples
18:32:22 <aaronl_> in the trips/alltrips lines
18:32:41 <jmcarthur> i very much doubt the microoptimizations matter in the face of the space leak
18:32:41 <aaronl_> v is an infinite sequence that contains all the primitive pythagorean triples
18:32:41 <kmc> aaronl_, btw, "g m x = let a = fst x; b = snd x in ..."   ==>   "g m (a, b) = ..."
18:32:51 <aaronl_> kmc: ah, thanks
18:32:54 <kmc> aaronl_, if you still need x,  "g m x@(a, b) = ..."
18:33:33 <aaronl_> anyway, then it does a binary search on the value computed by 'r' in "bsearch"
18:34:01 <twink> [(2*t, t^2-1, t^2+1) | t <- [2..]] ?
18:34:17 <aaronl_> which involves calculating g over a certain range of pythagorean triples
18:34:37 <kmc> aaronl_, i think calcsum fn k = sum $ map fn [1..k]
18:34:47 <aaronl_> kmc: ah, i was just about to ask if there was a better way to do it :)
18:34:56 <aaronl_> let me try that and see if it makes it stop blowing up
18:35:01 <kmc> doesn't seem to :/
18:35:05 <aaronl_> calcsum is the innermost "loop" so i suspect that's where the problem is
18:35:33 <jmcarthur> aaronl_: calcsum f = sum . map f . enumFromTo 0
18:35:48 <jmcarthur> i haven't tried it
18:36:51 <kmc> aaronl_, if you run your program as "./foo +RTS -s" you will get some useful stats
18:36:58 <kmc> like % time spent in GC
18:37:05 <kmc> in this case about 40%
18:37:09 <kmc> which needless to say is a lot
18:38:00 * jmcarthur targets bsearch next
18:38:08 <aaronl_> i actually don't think it's bsearch
18:38:23 <kmc> did you profile?
18:38:34 <aaronl_> i tried once test where i changed the main function to just run sum [ sum [ g 5000 x | x <- y] | y <- take 5000 v ]
18:38:43 <aaronl_> and that also took a very long time
18:40:53 <kmc> in my profile i see it spend about half its time on g (directly), 15% on g's calls to calcsum, and 15% on coprimeq
18:41:43 <kmc> aaronl_, another little style thing, you might write coprimeq as:
18:41:56 <kmc> coprimeq 1 0 = True; coprimeq _ 0 = False; coprimeq a b = coprimeq b (mod a b)
18:42:29 <aaronl_> ah
18:42:53 <jmcarthur> even better
18:43:00 <jmcarthur> coprime a b = gcd a b == 1
18:43:01 <jmcarthur> :)
18:43:47 <kmc> [ g mid x | x <- y]   we'd usually write as   map (g mid) y
18:43:48 <luite> chrisdone: it works here now :)
18:44:19 <luite> chrisdone: I added a line , P.env = env
18:44:37 <luite> where env = Just [("USER","luite"),("HOME","/home/luite")]
18:44:43 <luite> in the muevalStart function
18:44:46 <kmc> anyway none of these suggestions seem to help the performance :/
18:45:26 <dancor> how can i see the Language.Haskell.TH parse tree of (data Opts = Opts {optLol :: Bool})?
18:45:39 <fax> @let coprime a b = gcd a b == 1
18:45:40 <lambdabot>  Defined.
18:45:45 <fax> > filter (coprime 360) [1..]
18:45:47 <lambdabot>   [1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,9...
18:46:04 <twink> aaronl: You're trying to sum up something to do with Pythagorean triples? IIRC they're polynomials so indefinite sums should be symbolically calculable.
18:46:29 <fax> 7 11 13 17 19 23 29 31 37 41 43 47 are primes
18:46:32 <fax> coincidence???
18:46:45 <aaronl_> twink: yeah, actually I know there's a better way to do it now
18:46:48 <dancor> co-incidence
18:46:49 <twink> aaronl: How is your v which has to do with Pythagorean triples defined?
18:46:52 <kmc> 360 has a lot of factors, film at 11
18:46:55 <aaronl_> twink: but this was what i came up with at first
18:47:04 <aaronl_> twink: and it happened to be purely functional
18:47:23 <aaronl_> twink: so i thought it would be something convenient to try porting to haskell
18:47:28 <twink> I can crank out the indefinite sum for you if need be.
18:48:04 <fax> > filter (coprime (2*3*5*7*11)) [1..]
18:48:06 <lambdabot>   [1,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,...
18:48:43 <byorgey> dancor: just  runQ [d| data Opts = Opts {optLol :: Bool} |]  at a ghci prompt
18:48:51 <twink> fax: There's some general way to do wheels for Eratosthenes.
18:48:54 <aaronl_> i have to run now
18:48:59 <aaronl_> thanks for the stylistic suggestions
18:48:59 <dancor> byorgey: ty!
18:49:08 <SamB_XP> what's a wheel?
18:49:16 <aaronl_> if i figure out what's blowing up, i'll report back
18:49:20 <dancor> sounds underengineered
18:49:50 <aaronl_> or maybe i'll try something easier to follow next time i feel the urge to try writing haskell code
18:49:55 <aaronl_> bbl
18:52:18 <SamB_XP> aaronl_: may be a good idea
18:52:20 <twink> SamB_XP: A cyclic sequence of increments to add to things you derive by doing something like let q = product qs ; ts@(t:ts') = filter (coprime q) [1..q-1] in zipWith (-) (ts' ++ [t]) ts
18:52:26 <SamB_XP> or maybe you should write prettier listp ;-P
18:52:49 <twink> SamB_XP: Where qs is the first few primes you're bootstrapping with.
18:53:37 <fax> > let a k = k : filter (coprime k) (a (k+1)) in a 2
18:53:38 <SamB_XP> @index coprime
18:53:38 <lambdabot> bzzt
18:53:39 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:53:44 <SamB_XP> @hoogle coprime
18:53:44 <lambdabot> No results found
18:53:45 <twink> ugh cycle $ zipWith (-) (ts' ++ [t]) ts
18:53:52 <SamB_XP> @src coprime
18:53:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:54:09 <fax> > product $ map (1/) (let a k = k : filter (coprime k) (a (k+1)) in a 2)
18:54:10 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:54:10 <lambdabot>    `GHC.Real.Integral a'
18:54:10 <lambdabot>   ...
18:54:29 <fax> > product . take 1000 $ (map ((1/).fromIntegral) (let a k = k : filter (coprime k) (a (k+1)) in a 2))
18:54:32 <dancor> lbot's source compendium falls far short of its capacity for trashtalk
18:54:33 <lambdabot>   mueval-core: Time limit exceeded
18:54:37 <fax> > product . take 100 $ (map ((1/).fromIntegral) (let a k = k : filter (coprime k) (a (k+1)) in a 2))
18:54:38 <lambdabot>   2.1222722541254398e-220
18:55:15 <humasect> it's pronounced lithp
18:55:27 <fax> > product . take 100 $ (map (subtract 1 . (1/).fromIntegral) (let a k = k : filter (coprime k) (a (k+1)) in a 2))
18:55:28 <lambdabot>   8.874988377532986e-2
18:55:46 <cads> aaronl_, I'm translating your code into more idiomatic haskell code
18:56:02 <fax> > let square x = x*x in product . take 100 $ (map (subtract 1 . (1/) . square . fromIntegral) (let a k = k : filter (coprime k) (a (k+1)) in a 2))
18:56:03 <lambdabot>   0.6080819361170084
18:57:09 <SamB_XP> cads: he supposedly left!
18:57:32 <cads> Is okay, it's good practice, and I like pythagorean triples
18:57:45 <cads> ( I wanna figure out what the heck this thin does!)
18:58:25 <SamB_XP> be sure to paste the answer into all of the project euler problems!
18:58:32 <SamB_XP> it might be one of them ;-P
18:58:47 <idnar> haha
18:59:03 <cads> heh, I did a project euler like this
18:59:56 <cads> it migth be number 86 http://projecteuler.net/index.php?section=problems&id=86
19:00:14 <cads> (oddly enough it has to do with pythagorean triples :)
19:00:35 <byorgey> quite a few project euler questions have to do with pythagoream triples, IIRC.
19:01:00 <twink> Here's a wheel Eratosthenes though not fully generalized: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8986#a8986
19:02:10 <dancor> byorgey: is there a less ghc-specific way to refer to Bool in data definitions, better than using GHC.Bool.Bool?
19:02:22 <dancor> when creating Dec's in TH
19:02:52 <byorgey> dancor: you can do ''Bool
19:02:54 <dancor> oh
19:03:12 <byorgey> which will give you its proper qualified Name
19:03:13 <cads> gosh..  r = sum [ sum [ g mid x | x <- y] | y <- take mid v ],  where  v :: [[(Int,Int)]], and length a = 1 forall  elem a v :)
19:03:36 <cads> oh
19:03:38 <cads> nevermind
19:03:56 <cads> there are some elements that have multiple subelements
19:05:16 <cads> Hah, I think this problem _is_ for euler 86 :D
19:06:01 <cads> I haven't solved it yet, but if I manage to understand this code well enough to rewrite it, I am stealing the solution
19:06:17 <kmc> :)
19:07:20 <adu> solved what?
19:08:00 * ManateeLazyCat pasted "Darcs failed" at http://paste2.org/get/736988
19:08:01 <ManateeLazyCat> What's wrong with code.haskell.org ? I can't `get` code from there. Above is error
19:08:31 <dancor> oh actually for what i was doing i think the answer was    ConT (mkName "Bool")
19:08:33 <ManateeLazyCat> Oh, now can.
19:11:48 <dancor> TH is great
19:11:53 <ManateeLazyCat> Oh, god, i can't `get` code because `GFW`?
19:12:20 <dancor> ManateeLazyCat: where in china are you
19:12:32 <dancor> (i'm just curious)
19:12:59 <ManateeLazyCat> dancor: I found i can't `get` code when i close tool that fighting GFW.
19:13:16 <dancor> it's funny what sites come under GFW
19:14:28 <ManateeLazyCat> dancor: I don't understand, Why GFW need filter code.haskell.org?
19:14:42 <dancor> right, i don't understand either, that's what funny
19:15:10 <byorgey> dancor: better to do  ConT ''Bool
19:15:36 <dancor> ManateeLazyCat: maybe it just whitelist some ports and the range happens not to include the darcs port
19:15:40 <dancor> byorgey: ah
19:16:23 <humasect> haskell.org/ghc needs updatin'
19:16:26 <ManateeLazyCat> dancor: I guess so, maybe GFW filter some port make i can't `get`, but i can use darcs `push` patch.
19:16:53 <ManateeLazyCat> dancor: If i close tool, i can `push` patch, but i can't `get` code.
19:20:08 <leoncame1> ManateeLazyCat: where are you?
19:20:19 <ManateeLazyCat> leoncame1: China
19:20:19 <IoFF> any FAQ is there?
19:21:01 <leoncame1> ManateeLazyCat: Oh. I know, which ISP is there ?
19:21:16 <ManateeLazyCat> 
19:21:35 <leoncame1> ManateeLazyCat: I guess you can use ScholarZhang ?
19:22:06 <ManateeLazyCat> leoncame1: What?
19:22:06 <leoncame1> ManateeLazyCat: Oh, sorry, we can talk it pravitely .
19:23:06 <humasect> cabal update "Bus error" ?
19:23:20 <BMeph> IoFF: FAQ for what? :)
19:23:30 <ManateeLazyCat> "Darcs failed couldn't connect to server port", looks GFW filter some port that make Darcs failed.
19:24:34 <IoFF> BMeph, i have some problem with declaring function/
19:25:15 <humasect> 0x00413782 in base_GHCziStorable_writeWord32OffPtr1_info ()
19:25:29 <humasect> this does not look good , i have just installed
19:26:05 <dark> does anyone here likes bitc? http://www.coyotos.org/pipermail/bitc-dev/2010-March/001809.html it seems that the author is now out of microsoft, and going to develop it further
19:26:29 <dancor> dark: i liked the idea but thought it was dead, good to know
19:26:31 <dark> also, he says microsoft has no interest on bitc
19:26:47 <Hunner> They wouldn't
19:27:07 <humasect> how can i get the logs from here 98 days ago? =) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14401#a14402
19:29:00 <dancor> Hunner why not?  they are already doing midori and singularity so they don't care about going even further and doing a proven-correct OS/
19:29:03 <dancor> ?
19:29:20 <dancor> (wasn't a proven-correct OS one of the big things planned to be done in BitC?)
19:29:54 <dark> i'm very interested on bitc, i want to learn more about verification ^^ there is a professor here at my uni that is working with B method.. i think a student of him is developing an eclipse plugin for it, to bring it to more 'mainstream' programmers.. do someone know more about this kind of stuff / can give me links?
19:30:42 <aaronl_> damnit
19:30:57 <aaronl_> i was hoping no one would guess the problem number
19:31:38 <dark> dancor, it looks like they will use their regular tools
19:31:58 <dark> dancor, they are pushing C# and .NET even in embedded environments o.o
19:32:08 <dancor> dark: idk much, i would just say that agda is another program-verification thing written in haskell
19:32:14 <dancor> with an emacs mode to make it "mainstream"
19:32:36 <dark> emacs is not mainstream :) (not as much as eclipse)
19:32:41 <dancor> dark: ha i know
19:33:08 <dancor> dark: will BitC being on CLR mean i won't be able to use it in linux
19:33:21 <bremner> dancor: mono
19:33:24 <dark> hmmm
19:33:31 <dark> bitC already compiles to C, right?
19:33:40 <dancor> bremner: ah
19:33:53 <dark> and it can compile to machine code directly i think, it just that it's a hard task..
19:34:05 <dark> hmm it's?
19:34:48 <bremner> the fact that the dude sends html mail makes me lose a little faith in bitc :)
19:35:27 <dark> huh? i read here as plain text o.o
19:35:37 <dark> ah. an html attachament .. hmm
19:35:46 <dark> attachment
19:37:16 <dancor> but, if the time he has spent not learning email has gone into BitC..
19:37:21 <IoFF> how to declare function dealing with array?
19:38:03 <dancor> IoFF: hm?  like:   intSum :: [Int] -> Int
19:38:07 <dancor> intSum = sum
19:38:32 <IoFF> yeah
19:39:00 <IoFF> (Int,[Int]) -> Int
19:39:21 <IoFF> what wrong in that?
19:41:53 <dancor> IoFF: nothing.  that is a valid function type.
19:42:20 <dark> dancor, maybe bremner was denouncing his possible preference for windows (thinking about clr.. ok, it's just a technology.. working at microsoft? ok, it's money after all.. but.. sending html e-mail?)
19:42:35 <IoFF> 111.hs:26:0: Invalid type signature
19:42:40 <dancor> ha right
19:42:43 <dancor> three strikes
19:43:29 <dankna> is there a utility or ghci incantation that takes Haskell code and turns it into properly-indented Template Haskell code?
19:43:47 <dankna> I figured out the incantation to get garbled, unindented TH code :)
19:48:32 <dancor> > runQ [| 4 + 5 |]
19:48:33 <lambdabot>   <no location info>: parse error on input `|'
19:49:53 <dankna> yeah, that yields unindented code
19:50:33 <dancor> dankna: runQ basically gives you something pretty p that some TH func f could use (f = return p).  then you can do $(f) and get the original thing back.  you might have to change some things to mkName's.  is that what you want?
19:51:39 <dancor> so far (not very far i admit) i've found that plenty useful in making TH stuff
19:51:50 <dankna> it's basically what I want
19:51:58 <dankna> I've been using it
19:52:16 <dankna> it's just that I can't actually read the ugly result of runQ without spending half an hour reindenting it by hand :)
19:52:22 <dancor> i see
19:52:27 <dankna> I can go ahead and insert it in my code without doing that, I suppose...
19:52:45 <dancor> i think this is the same thing as wanting a general code indenter
19:52:55 <dankna> I think you're right, now that you mention it
19:53:04 <dancor> and i don't know of any :(
19:53:09 <dankna> aw :( fair enough though
19:54:15 <dancor> i think to make it you would want a haskell parser that preserves whitespace ideally
19:54:25 <dancor> or at least comments
19:54:44 <dancor> i guess for this at least you could be fine with one that kills comments even
19:55:36 <dancor> ghc error messages seem to do some pretty-printing/indenting but it's pretty ghastly imho.  but you could try ripping that out and using it
19:56:15 <dankna> yeah, I think you're pretty much right
19:56:17 <dankna> hmmmmmmm
19:56:19 <dankna> interesting thought
19:56:44 <dankna> the other approach
19:56:55 <dankna> would be to take a Haskell parser that ignores whitespace
19:57:04 <dankna> but implements Lisp-style quasiquotation
19:57:13 <dankna> using the built-in quasiquote hooks
19:57:23 <dancor> http://hackage.haskell.org/package/haskell-src-exts
19:57:36 <dancor> ignores whitespace/comments i believe but has prettyprinting
19:57:36 <dankna> sweet!
19:57:50 <dobblego> that's a really awesome library (though I hit a bug the other day)
19:58:57 <dancor> one thing it doesn't parse is e.g. "#!/usr/bin/env runhaskell" iirc, but that's easy enough to do in a wrapper
19:59:04 <dankna> sure
20:07:47 <dobblego> I hit an issue of having a pragma for GHC and another for HLint
20:08:06 <dobblego> I emailed the author and he said he has or will fix it
20:11:12 <dancor> dobblego: what do you think about making it optionally preserve whitespace, laziness should make it nice and not have a perf penalty when you discard whitespace right?
20:12:07 <dobblego> dancor, I haven't used it enough to form an opinion
20:12:38 <dankna> for my use I don't really care about performance anyway
20:17:08 <SamB_XP> dankna: presumably you wants at least a LITTLE bit!
20:18:58 <dankna> well, yes, haha
20:19:04 <dancor> what's the value in making constructors captalized?
20:19:17 <dankna> they stand out
20:19:28 <dancor> i guess what distinguishes them functionally is that you can pattern match
20:19:35 <dankna> hm, yes
20:44:11 <mjrosenb> it looks like the demo/pango directory in newer gtk2hs does not compile out of the box
20:44:17 <mjrosenb> it is using a deprecated interface.
20:54:57 <dancor> if i'm taking some (x :: (forall a. a)) and generating a Q [Dec], can i extract the type of x (as a Name)?
20:55:19 <dancor> to use in my Dec
20:56:03 <babusri> Windows, GHC 6.10.3, haskell platform, vector 0.5: Getting error when running examples from haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial. For binary, I get segmentation fault. With ghci, it says "Loading package vector-0.5 ... linking ... done." and a popup "ghc.exe has encountered a problem and needs to close". hackage says that the package is built on ghc-6.12 but doesn't say 6.12 is required. I think
20:56:04 <babusri>  installing 6.12.1 will solve the problem but was hesitating as the ghc page says "For most users, we recommend installing the Haskell Platform instead of GHC."
20:58:34 <dancor> i guess a general x might not have a type which is a simple Name
21:02:17 <dancor> oh maybe reify can do this
21:09:22 <Parkotron> Is there a way to get the current line/column out of a Parsec parser? There's a SourcePos class which does what I want, but the only way I see to get one is from a ParseError.
21:10:26 <ddarius> @hoogle getPosition
21:10:26 <lambdabot> Text.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
21:10:26 <lambdabot> Text.ParserCombinators.Parsec.Prim getPosition :: Monad m => ParsecT s u m SourcePos
21:11:11 <Parkotron> ddarius: Thanks. Time to do some more reading.
21:15:10 <kamatsu> there is no Random instance for pairs?
21:28:24 <cads> Is there a strict sum function that won't overflow on a large list?
21:28:37 <cads> > sum [1..1000000]
21:28:38 <lambdabot>   * Exception: stack overflow
21:28:59 <cads> > foldl' (+) 0 [1..1000000]
21:29:00 <lambdabot>   500000500000
21:29:06 <cads> > foldl (+) 0 [1..1000000]
21:29:07 <lambdabot>   * Exception: stack overflow
21:29:23 <kamatsu> that's strange
21:29:26 <cads> > sum' (+) 0 [1..1000000]  -- crosses fingers
21:29:27 <lambdabot>   Not in scope: `sum''
21:29:30 <kamatsu> why isn't sum tail optimized?
21:29:34 <cads> it is
21:30:02 <pikhq> Tail call optimisation doesn't do what you think it does in Haskell.
21:30:58 <cads> kamatsu, in this case a growing expression of 1 + 2 + 3 ... is passed each time the next fold is called
21:31:13 <cads> and eventually that blows the stack
21:31:30 <cads> .. or the eventual evaluation does
21:31:34 <cads> I'm not sure on that
21:32:47 <cads> > foldl  (\ a b -> seq a (a+b)) 0 [1..1000000]
21:32:49 <lambdabot>   * Exception: stack overflow
21:33:31 <cads> that didn't work.
21:38:33 <Entroacceptor> > foldr (+) 0 [1..1000000]
21:38:35 <lambdabot>   * Exception: stack overflow
21:42:06 <koninkje> > foldl' (\a b -> seq a (a+b)) 0 [1..1000000]
21:42:08 <lambdabot>   500000500000
21:42:29 <koninkje> cads: you used the lazy left-fold
21:43:00 <koninkje> > foldl' (+) 0 [1..1000000]
21:43:01 <lambdabot>   500000500000
21:43:10 <koninkje> hmm...
21:43:56 <cads> > let sum as = sumAdd as 0 where sumAdd (a:as) b = sumAdd as (a+b); sumAdd [] b = b in sum [1..1000000]
21:43:57 <lambdabot>   * Exception: stack overflow
21:44:06 <cads> > let sum as = sumAdd as 0 where sumAdd (a:as) b = b `seq` sumAdd as (a+b); sumAdd [] b = b in sum [1..1000000]
21:44:08 <lambdabot>   500000500000
21:58:05 <dancor> i'm not understanding this reify "stage error": http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8998#a8998
22:00:27 <dancor> byorgey: ^^ if u get a chance
22:01:00 <dancor> i could see how my idea with forall might be undoable
22:01:04 * hackagebot time-http 0.1 - Parse and format HTTP/1.1 Date and Time string  http://hackage.haskell.org/package/time-http-0.1 (MasatakeDaimon)
22:01:08 <dancor> but i don't understand this error anyway
22:01:42 <dancor> i.e. at which "stage" is d bound, vs at which stage am i using it?
22:08:08 * hackagebot Lucu 0.6 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.6 (MasatakeDaimon)
22:13:36 <kevinulin> good evening, I am looking to do something that is not very functional in haskell and Im not sure where I should start. I want to have a hashtable that I can add and remove key/value pairs from as needed (to create a cache of database connections tied to an identifier)
22:18:12 <kevinulin> i guess I should start with Data.Map?
22:21:11 <danblick> I'm trying to do, "type G = WriterT String Identity", "instance xxx G where ...", and clearly this is not working.  Is there an alternate strategy I can use? (Is it clear enough what I'm trying to do here, or would an example help?)
22:23:33 <dobblego> danblick, you might want to use the newtype keyword instead of the type keyword
22:23:55 <dobblego> newtype G = G (WriterT String Identity)
22:24:31 <koninkje> kevinulin: if you just want to be able to map a set of keys into a set of values, then Data.Map (or Dat.IntMap or Data.Trie) are the best place to start
22:25:02 <koninkje> kevinulin: if you really care about the underlying structure of the map, then the story is different
22:25:03 <kevinulin> is using them just taking the easy way out?
22:25:16 <koninkje> what means "easy way out"?
22:25:17 <kevinulin> im not confident i just dont have a really bad concept
22:25:20 <koninkje> out of what?
22:25:52 <kevinulin> im not sure, ill just have to think on it some more, everytime i try to find a non-obvious way to do something its because the thing I was trying to do was dumb
22:27:44 <kevinulin> maybe i should just use recursion, and have the main function call itself with a new set of connections
22:28:42 <koninkje> If all you need is a mapping from K to V where you can add and remove bindings, then Data.Map should work fine
22:29:30 <kevinulin> if i make a new list of hdbc connections by just appending a new one to an existing list, are all the connections copied by value or reference?
22:30:19 <koninkje> there's no copying at all, the tail of the new list is identical to the old list
22:30:43 <kevinulin> oh i see, since the data isnt mutable it doesnt matter does it? thats clever
22:30:54 <koninkje> :)
22:30:59 <dobblego> kevincla1k, in pure languages, we generally don't append to lists
22:31:10 <dobblego> kevincla1k, specifically, singly linked lists such as []
22:31:21 <danblick> dobblego: here is an example of what I would like to work... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24418#a24418
22:31:24 <Jafet> "o"++"rly"
22:32:24 <dobblego> danblick, just use a newtype or the GHC extension mentioned in the error
22:32:37 <kevinulin> dobblego im afraid you lost me? im thinking about doing mainLoop connections = mainLoop (new ++ connections)
22:32:38 <koninkje> kevinulin: if you have xs++ys then the spine of xs will be cloned but it will contain identical values to the original xs
22:33:20 <koninkje> and the tail of the xs' will be identical to ys
22:34:59 <kevinulin> i guess naming it Loop would be wrong, but you get the idea
22:39:01 <koninkje> Internally a (_:_) cell is just a struct with two pointers. So if I have a function (\xs -> head xs : tail xs) then it will allocate a new (_:_) cell whose value is equal to the old one. But in (pure) functional languages we don't have a way of testing pointer equality so we can't distinguish the identical relation from the equals relation
22:40:05 <koninkje> Thus, people don't tend to talk about copy-by-X since there's generally no copying involved, or if there is then it doesn't matter
22:40:32 <koninkje> (the only time it matters is for optimizing to reduce memory overhead/churn)
22:40:32 <danblick> dobblego: thanks for your help, using GeneralizedNewtypeDeriving with newtype looks good
22:40:42 <kevinulin> ya it doesnt matter in terms of the result of the function, but it sorta matters to the computer that is evalutating the answer
22:40:46 <dobblego> danblick, no worries
22:43:30 <timmaxw> koninkje: do you also write agda? (_:_) looks a lot like mixfix syntax
22:45:25 <Jafet> _:_ is quite Haskell
22:45:56 <timmaxw> Jafet: is "_" legal in operators?
22:46:18 <timmaxw> oh, i see what you mean; the _ is meant to stand for any expression
22:46:26 <timmaxw> nevermind then
22:46:39 <Jafet> > (\(_:_) -> "lol") [0]
22:46:40 <lambdabot>   "lol"
22:47:09 <Jafet> It's an infix data constructor, another abomination of syntax
22:47:14 <koninkje> timmaxw: I'm familiar with agda, but haven't used it for anything yet
22:47:45 <Gracenotes> you can use ((:) _ _) if you're so inclined
22:48:10 <kevinulin> also, you can use even more parens!
22:58:45 <Peaker> dancor: btw, Jonathan Shapiro's EROS had some very interesting properties
22:59:06 <Peaker> Using intrusive resource management is far better than the status quo, imo
22:59:36 <dancor> Peaker: hm?
22:59:53 <Peaker> dancor: Was just scrolling up to your comments about bitC :)
23:00:09 <Peaker> (BitC was the language he started working on when he decided both C and C++ were inappropriate)
23:00:11 <dancor> Peaker: ah cool i'll look at EROS
23:00:21 <dancor> i see
23:00:35 <Peaker> It's just a research OS -- and it had some very nice ideas
23:01:28 <Jafet> Eros is sexy
23:01:47 <dancor> named appropriately
23:01:58 <enthymeme> indeed.
23:03:39 <Peaker> I like the way all OS resources in EROS (except caches, iirc) were allocated by normal user processes.  When you create a process, instead of the OS paying a lot of the bill, you have to hand it all of the allocated kernel pages necessary
23:04:12 <Peaker> You had to give it part of your CPU scheduler slice, the address space tree, the pages used to manage the tables, etc.  So if you fork-bomb, you only DOS against yourself
23:09:11 <koninkje> it's really a shame microkernels haven't taken off
23:11:41 <danblick> i'd love to try out seL4 under xen or kvm
23:11:58 <Peaker> koninkje: I don't really think it matters much if drivers are loaded into one address space or are in user-processes
23:11:59 * koninkje worked with the folks working on BitC and EROS
23:12:15 <Peaker> koninkje: cool!
23:12:36 <koninkje> Well, a lof of what you like about EROS comes from its being a microkernel...
23:12:42 <koninkje> s/lof/lot/
23:13:49 <cads> Hmm
23:15:26 <Peaker> koninkje: why?
23:15:45 <Peaker> koninkje: It's the kernel<->userspace interface that I liked, and the capabilities. I don't think where the drivers run matters
23:17:23 <koninkje> You're talking about "OS resources". In monolithic kernels those all, by definition, come from the kernel. But in microkernel systems they need not. In particular, EROS pushes most "OS resources" into userspace in order to make the kernel as minimal as possible
23:17:33 <koninkje> ...which is whe whole idea of microkernels
23:17:41 <humasect> the internet is the operating system of earth
23:18:07 <koninkje> Yeah, the capabilities are awesome. That's the part I like best about EROS
23:18:09 <dancor> humasect: so i guess you installed google desktop then?
23:19:06 <koninkje> Peaker: that is, I (and most microkernel folks) don't see much of a difference between drivers and any other OS resource
23:19:59 <dancor> i want to a have a list (or something..) of things of different types (like: 4  :: Int, "hi"), then extract their types with TH and do something with them
23:20:06 <dobblego> how do I get FilePath -> IO Handle?
23:20:20 <dancor> i'm having trouble trying to be magical with (forall a.).  should i consider something else?
23:20:22 <kamatsu> dobblego: FilePath is a string, can't you just open the file?
23:20:42 <dobblego> kamatsu, I want the Handle
23:20:44 <dancor> i could possibly tuple them all together and have TH unpack the tuple or some such
23:20:47 <Peaker> @hoogle FilePath -> IO Handle
23:20:47 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
23:20:47 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
23:20:47 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
23:20:53 <dancor> there's also Dynamic
23:20:56 <dobblego> oh System.IO thanks
23:21:25 <kamatsu> dancor: Why do you want this, just incidentally?
23:21:36 <humasect> dancor: no =) it just seems that a compu9ter without networking is not usable today.
23:21:41 <dancor> kamatsu: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=8998#a8998
23:22:08 <dancor> humasect: actually that reminds me i've been meaning to improve my offline haskell docs setup
23:22:38 <Peaker> humasect: IME, it is more usable for programming that way :)
23:22:52 <Peaker> humasect: on my way to work, on the train, I have no internet, and I thus actually program stuff :)
23:23:10 <kamatsu> dancor: doesn't answer why you need to extract each specific type
23:23:14 <humasect> ah, this is true ! here i am sending packets and receiving them when i sat down to code !
23:24:15 <dancor> kamatsu: i'm trying to create with TH a data Opts = Opts {opt1 :: Int, opt2 :: String, ..} where the Int and String there are pulled out of the default values in the optDesc being like 4 :: Int and "hi".
23:25:04 <dancor> kamatsu: that's why there are type annotations in the example in the comment at that link.  (0 :: Int) and (Nothing :: Maybe String).
23:25:08 <cads> I don't usually care about execution speed, but this just broke my heart... the fastest I've gotten some haskell code to run has been ten seconds.. the lisp code it was translated from runs in a tenth of a second
23:25:21 <kamatsu> dancor: Data.Typeable?
23:25:29 <Peaker> cads: maybe you're using String or some super-slow thing?
23:26:30 <cads> Well, let me paste the code and the profiling, as well as the original lisp (which is ooogly)
23:27:32 <cads> The lisp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24419#a24419
23:27:44 <cads> The haskell: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24420#a24420
23:28:26 <dancor> kamatsu: i'm not sure how to do it.  if the api still has optDesc taking a list, that list has to be :: [forall a. (Typeable a) => PolyOpt a]?
23:28:41 <cads> The ugly: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24421#a24421
23:29:16 <cads> Peaker, I was pretty happy with myself and the code till I was told the lisp runs in a 0.1s
23:29:28 <kamatsu> dancor: afaict, you want a heterogenous list
23:29:31 <Peaker> can't you try running it?
23:29:36 <Peaker> cads: to compare on the same machine?
23:29:47 <cads> Peaker, I downloaded lispworks just to try it
23:29:48 <kamatsu> dancor: so, to get existential quantification in haskell, you've gotta make a separate box type
23:29:58 <cads> Peaker, it was blazing..
23:30:06 <cads> ridiculously fast
23:30:20 <kamatsu> dancor: Then your list will be of the box type.
23:30:22 <dobblego> @hoogle Handle -> Handle -> Handle
23:30:22 <lambdabot> Prelude asTypeOf :: a -> a -> a
23:30:22 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
23:30:22 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
23:30:47 <Peaker> cads: 4.6 seconds here
23:31:06 <cads> yup. it's not bad at all
23:31:22 <cads> or are you talking about the lisp version?
23:31:42 <Peaker> cads: no, just ran the Haskell one. did you try to profile it?
23:32:14 <dancor> kamatsu: how do you go from Typeable's TypeRep to TH's Type?
23:32:41 <kamatsu> dancor: I have no experience with TH, I think TH is generally silly.
23:32:55 <kamatsu> dancor: I'm not sure you even need TH for what you're trying to do
23:32:59 <cads> peaker, Ii didn't profile the lisp, here's the haskell profile http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24422#a24422
23:33:16 <dancor> kamatsu: i'm pretty sure i need TH to construct a top-level data at runtime
23:33:43 <kamatsu> dancor: runtime?
23:33:47 <kamatsu> dancor: th?
23:33:49 <dancor> sorry, compiletime
23:34:16 <cads> Peaker, I'm wondering if the lisp code is using a better algorithm :D
23:34:28 <kamatsu> Do you need to do that, though?
23:34:56 <kamatsu> dancor: couldn't you just make your data definition, derive typeable for it?
23:35:09 <dancor> kamatsu: i think i do to achieve my goal of not being redundant in option specifying
23:35:39 <dancor> once you derive typeable on your Opts datatype, you still need to specify defaults and help strings
23:35:40 <kamatsu> dancor: couldn't your commandline parser / config file loader just use the typeable instance of the type to figure it all out?
23:36:04 <kamatsu> dancor: Okay, but this still doesn't seem to be a compelling argument to use TH.
23:36:16 <dancor> not that i can see without retyping the record names in the Opts datatype
23:36:37 <dancor> well, you have failed to dissuade me.  :)
23:37:02 <kamatsu> dancor: ah, you could provide defaults simply by providing a specific value of your Opt type, which derives typable
23:38:02 <dancor> data Opts = Opts {showVersion :: Bool} deriving (Typeable); defOpts = opts {showVersion = False}
23:38:32 <Peaker> cads: are they? I thought you read the lisp one :)
23:38:36 <dancor> i know it's crazy but i'm just not willing to type "showVersion" again :)
23:38:46 <Peaker> cads: Lisp is painful for me to read, I'm not practiced in reading prefix notation
23:38:49 <aavogt> @type join traceShow
23:38:50 <lambdabot> Not in scope: `traceShow'
23:40:19 <Peaker> I keep writing traceId prefix x = trace (prefix ++ show x) x
23:40:21 <zeiris> Has anyone played with Thrift-based RPC in Haskell?
23:40:22 <Peaker> doesn't everybody?
23:40:25 <kamatsu> dancor: fine, you don't have to:
23:40:26 <Peaker> far more useful than "traceE'
23:40:40 <kamatsu> dancor: data Opts = Opts {showVersion :: Bool} deriving (Typeable); defOpts = Opts False
23:40:54 <Peaker> zeiris: A friend of mine has taken a project upon himself to extend thrift to 2-way calls (using auto-generated code for proxies)
23:40:55 <dancor> ya but then you have to change things in two places
23:41:17 <Peaker> zeiris: He has later discovered Thrift kind-of sucks, because it inlines *everything* in generated code, generating megabytes of code for trivial things
23:41:36 <aavogt> dancor: TH is run at compile time
23:41:40 <dancor> i'm going to solve my highly constrained problem here that i believe, in it's highly constrained form, requires TH.  they i'll reevaluate my life.
23:41:43 <dancor> theN
23:41:51 <Peaker> if you ever wonder how a tiny Java app is taking megabytes in JAR files, maybe it's using thrift
23:41:51 <zeiris> Peaker, I'm trying to figure it out now, and am pretty concerned about its naming conventions... I guess I'll watch out for inlining, too o.O
23:42:08 * aavogt reads what the actual problem is
23:42:15 <dancor> aavogt: yes.  i mispoke earlier when i said "runtime" instead of "compiletime"
23:42:59 <cads> peaker, I'm reading it now :)
23:43:11 <dancor> Peaker: lol
23:43:19 <Peaker> cads: message me via lambdabot or memoserv, gotta go :)
23:45:25 <kamatsu> dancor: afaik TH just works on the expression tree, which is not necessarily annotated with all type information from inference
23:45:39 <dancor> kamatsu: right, it might not work because of that
23:45:49 <dancor> but that's not the error i'm getting right now
23:45:53 <aavogt> yeah, stuff gets checked later on
23:46:05 <kamatsu> dancor: my point is that types cannot be inspected by TH
23:46:15 <dancor> kamatsu: i think they can in some cases
23:46:22 <kamatsu> dancor: so you can't generate code based on the type of a value in TH
23:46:40 <aavogt> sure you can
23:46:45 <dancor> http://research.microsoft.com/~simonpj/tmp/notes2.ps
23:46:51 <aavogt> if you're given a Name, you can reify it
23:46:56 <aavogt> that gives you type information
23:47:17 <aavogt> dancor: but you can't use reify on arbitrary expressions
23:47:26 <dancor> "The current implementation simply tells whatever the type checker knows at that moment."
23:47:46 <dancor> i'm not sure if it will work in this case, but i think it's plausible
23:47:49 <dancor> that it would
23:47:54 * liyang was sure TH did two passes of typechecking, once on the original expression and another on the generated result.
23:47:57 <dancor> since the types are directly annotated
23:48:42 <dancor> on the values i look at the types of!
23:48:59 <aavogt> dancor: I'm interested in your problem too
23:49:08 <dancor> cool
23:49:23 <aavogt> I don't believe that you should structure your recursion around an existential type
23:49:31 <dancor> ok
23:49:39 <aavogt> the TH splice should accept a Name
23:49:59 <aavogt> the Name being for a type of a nested record structure
23:53:50 * aavogt had some code that used to typecheck but apparently I got distracted midway through
23:54:44 <dancor> my code used to typecheck, but then i got hylomorphic
23:55:17 <aavogt> incomplete refactoring on my part
23:55:57 <aavogt> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=9005#a9005
