00:00:53 <cads> Is there a form of fold which also passes the remainder of the list to the function?
00:01:36 <cads> This would not actually be a fold:    foldl' :: (a -> b -> [b] -> a) -> a -> [b];      foldl' f a x:xs = foldl f (f a x xs) xs;  foldl' f a [] = a
00:02:10 <cads> s/foldl f (f a x xs)/foldl' f (f a x xs)
00:07:01 <Kostafey> ksf, thanks, it is the solution!
00:07:22 <cads> I wrote a function that would have gone like foldl' (\ a b bs -> max a (sum $ take 5 (b:bs))) 0. Which perhaps would have been more efficient with something like a queue.
00:14:45 <ksf> I bet you can make mapAccumL do that
00:15:45 <ksf> ...for the particular problem, I think you want to separate the sum/take and max passes.
00:16:25 <ksf> map (tail 5) . tails and so on
00:16:38 <ksf> er take 5
00:17:36 <ksf> :t foldl'
00:17:37 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:18:27 <ksf> > foldl' max . map (sum . take 5) . tails $ [1..100]
00:18:29 <lambdabot>   []->
00:18:29 <lambdabot>    [15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115...
00:18:47 <ksf> > foldl' max 0 . map (sum . take 5) . tails $ [1..100]
00:18:48 <lambdabot>   490
00:19:13 <cads> @type tails
00:19:14 <lambdabot> forall a. [a] -> [[a]]
00:19:24 <cads> aha
00:19:27 <ksf> > tails [1..4]
00:19:28 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
00:20:26 <ksf> ...that's the mindbogging elegance of haskell all those people are raving about.
00:22:48 <avenge> Any HDBC users here?
00:23:38 <cads> ksf: folding over the _tails_. rather than the list proper, provides the conceptual trick needed :)
00:24:22 <ksf> yep. I've spend at least a day beating all those Data.List functions into my head.
00:24:47 <cads> I should do the same.
00:25:37 <cads> I've got this cute handbound haskell cheatsheet booklet that I made
00:25:54 <cads> and I should add to that some of the module docs
00:27:27 <ksf> I've always followed the technique of slurping up information and grokking its applicability putting off understanding of /how/ to apply it until I need it
00:28:09 <ksf> ...or how it works, for that matter.
00:29:49 <ksf> It'd be interesting to see whether stream fusion will reduce that to a single loop with five accumulators
00:31:16 <cads> I'll come back to this problem when I learn about queues
00:31:42 <ksf> queues are easy.
00:32:12 <ksf> an (imperative) singly-linked list makes a perfect fifo queue.
00:32:24 <ksf> [] itself makes a perfect LIFO queue.
00:33:05 <ksf> ...the imperative version does, too, and you get the fifo queue by keeping a pointer to the last element.
00:34:23 <ksf> things get more interesting when you get to priority queues, which are usually binary trees optimized for inserting + lookup of the smallest element (which usually is the root of the tree)
00:35:18 <ksf> ..."priority" meaning that the queue order isn't based on insertion order, but some other priority measure, say an int.
00:36:25 <cads> wow, I'd never wondered about what priority queues were.. the theory must be rather involved
00:37:28 <ksf> it's all very well-researched
00:37:33 <opqdonut> now that you mention it, they do have some whacky time complexities
00:37:44 <opqdonut> like the inverse ackermann function for fibonacci queues
00:38:04 <opqdonut> er, fibonacci heap
00:38:05 <o-_-o> which is the fold paper ?
00:38:13 <o-_-o> link ?
00:38:31 <cads> http://www.cs.nott.ac.uk/~gmh/fold.pdf
00:38:40 <cads> that's hutton's paper
00:38:57 <o-_-o> thanks
00:39:12 <opqdonut> err, no, it wasn't the fibonacci heap
00:39:36 <cads> the literal inverse of the ackermann function, huh?
00:39:55 * ksf once used a binary heap to keep track of open nodes in an a-star
00:39:57 <cads> like O(A^-1(n))... oy vei..
00:40:10 <opqdonut> ah, yes, it was the disjoint set structure
00:40:28 <opqdonut> cads: http://en.wikipedia.org/wiki/Ackermann_function#Inverse
00:40:31 <ksf> usually it'd be premature optimisation to start out using them.
00:41:24 <opqdonut> and they have pretty horrible constant factors
00:42:53 <ksf> ...which means "use them if your data is big and on the internets, think twice if it's on your local network, think thrice if it's on your disk, and use something else if it's in ram"
00:44:28 <cads> man, I should be practicing for the SAT instead of playing with project euler :/
00:44:44 <ksf> in general, just use an IntMap unless you know it's your performance bottleneck.
00:44:56 <opqdonut> word
00:44:58 <ksf> log n for lookup and insertion is usually good enough.
00:45:27 <opqdonut> isn't IntMap log_256 or something, too?
00:45:45 <ksf> yeah it's a trie
00:46:00 <ksf> ...you still have log n cache misses, though.
00:46:04 <opqdonut> mmh
00:46:20 <opqdonut> another nice way of structuring stuff is just using functions, and then inserting MemoCombinators
00:46:28 <opqdonut> not always applicable, of course
00:46:58 <ksf> I really like to hide maps behind functions
00:47:13 <Veinor> inverse ackermann is so slow it might as well be O(1) :P
00:47:58 <cads> Is there an analytic extension of the ackermann function?
00:48:15 <Veinor> I highly doubt it.
00:48:46 <Veinor> wikipedia says you can extend A({1,2,3},z) but not A(4,z) (at least, we don't know of any way)
00:50:20 <cads> @hoogle Ord a => [a] -> a
00:50:21 <lambdabot> Prelude maximum :: Ord a => [a] -> a
00:50:21 <lambdabot> Prelude minimum :: Ord a => [a] -> a
00:50:21 <lambdabot> Data.List maximum :: Ord a => [a] -> a
00:50:42 <cads> I love hoogle so goddamn much.
00:50:59 <cads> oh that reminds me to check if it installed correctly
00:51:03 <ksf> > maximum . map (sum . take 5) . tails $ [1..100]
00:51:04 <lambdabot>   490
00:52:03 <cads> maximum . map (product . take 5) . tails $ [1..20]
00:52:08 <cads> > maximum . map (product . take 5) . tails $ [1..20]
00:52:09 <lambdabot>   1860480
00:52:14 <cads> glee!
00:53:51 <Gilly> > sum . take 5 . reverse $ [1..100]
00:53:52 <lambdabot>   490
00:54:32 <cads> so fusion really gives us a way to transform that into a form with 1 accumulator for the max and 4 for the current numbers being tested?
00:54:46 <ksf> dunno
00:54:49 <ksf> look at the core
00:55:18 <cads> @src tails
00:55:18 <lambdabot> tails []         = [[]]
00:55:18 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
00:57:05 <cads> It would amaze me if it did, but I don't think it's beyond the algebraic fortitude of the haskell authors to pull something like that off
00:59:15 <cads> ksf: you mentioned A* and it reminded me of this super mario AI that uses the same algo: http://www.youtube.com/watch?v=DlkMs4ZHHr8
01:00:35 <ksf> http://theory.stanford.edu/~amitp/GameProgramming/
01:00:40 <ksf> gotta hit the hay, though.
01:34:43 <pokoko222> anyone uses Ogre3d?
02:02:10 <cads> @pl (\(a,b,c)->a*b*c)
02:02:10 <lambdabot> (line 1, column 7):
02:02:10 <lambdabot> unexpected ","
02:02:10 <lambdabot> expecting letter or digit, operator or ")"
02:02:10 <lambdabot> ambiguous use of a non associative operator
02:02:37 <cads> I think pl doesn't work with triples
02:03:22 <o-_-o> :t (@)
02:03:23 <lambdabot> parse error on input `@'
02:03:27 <o-_-o> :t @
02:03:28 <lambdabot> parse error on input `@'
02:03:32 <o-_-o> :type @
02:03:38 <o-_-o> > :type @
02:03:39 <lambdabot>   <no location info>: parse error on input `:'
02:03:43 <o-_-o> > :type (@)
02:03:44 <lambdabot>   <no location info>: parse error on input `:'
02:03:47 <o-_-o> ??
02:10:15 <kmc> o-_-o, @ is a reserved operator the same as :: and -> and such
02:10:18 <kmc> because of at-patterns i guess
02:10:30 <kmc> but you can use it as part of an operator
02:10:36 <kmc> :t let _ @@ _ = () in (@@)
02:10:37 <lambdabot> forall t t1. t -> t1 -> ()
02:10:43 <o-_-o> does it have a type ?
02:10:57 <kmc> no
02:11:19 <kmc> just as "::" does not have a type
02:11:20 <o-_-o> I read RWH's explanation of it and I could not understand what it was doing...
02:11:25 <kmc> you mean at-patterns?
02:11:27 <o-_-o> kmc, ah...ok
02:11:31 <o-_-o> as-patters
02:11:35 <o-_-o> as-patterns
02:11:42 <o-_-o> that is what RWH calls it
02:11:47 <kmc> > let all@(first:rest) = [1,2,3] in (all, first, rest)
02:11:48 <lambdabot>   ([1,2,3],1,[2,3])
02:12:09 <kmc> the pattern «v@p» matches the same things as the pattern «p», and binds the same variables as the pattern «p»
02:12:21 <kmc> it additionally binds the variable «v» to the entire value so matched
02:12:47 <kmc> it's not an operator like (+), it's part of the syntax of patterns
02:13:09 <o-_-o> ah...ok
02:13:30 <kmc> > let (first:rest) = [1,2,3] in ((first:rest), first, rest)  -- equivalent, but less efficient as it reconstructs a list cell
02:13:31 <lambdabot>   ([1,2,3],1,[2,3])
02:14:20 <kmc> you'd use an @-pattern to avoid re-constructing a value you already took apart
02:16:34 <o-_-o> ok
02:29:48 <cads> Is there a way to tell a list comprehension to choose the output of its generators according to some 'smallest first' order?
02:30:23 <cads> For example, I'd like to create an infinite list which enumerates the coprime pairs of integers, ordering them according to the size of their sum.
02:31:29 <cads> > [(a,b) | a <- [2..], b <- [2..], gcd a b == 1]
02:31:31 <lambdabot>   [(2,3),(2,5),(2,7),(2,9),(2,11),(2,13),(2,15),(2,17),(2,19),(2,21),(2,23),(...
02:32:25 <psykotic> write a helper function
02:32:49 <Heffalump> cads: do some algebraic reorganisation manually
02:33:16 <Heffalump> [(a,b) | sum <- [2..], a <- [2..sum-2], let b = sum - a, gcd a b == 1]
02:33:37 <psykotic> that works well in that case but i've definitely found it useful in general to factor that kind of thing out
02:33:49 <psykotic> alternatively, you can do something like what oleg did and have a 'fair' backtracking monad that takes care of these things for you
02:35:13 <psykotic> more generally it's useful to take a list of lists and generate the cartesian product in the usual zigzag order that is usually used in the proof that the countable product of countable sets is itself countable
02:35:43 <cads> yeah, that diagonal enumeration is exactly what I'd like to do
02:35:51 <cads> I think I can use what Heffalump suggested
02:36:07 <psykotic> yep
02:36:41 <BONUS> http://blog.sigfpe.com/2009/07/monad-for-combinatorial-search-with.html
02:37:23 <cads> > [(a,b) | height <- [2..], b <- [2..height], let a = height - b,  gcd a b == 1] -- lets see
02:37:24 <lambdabot>   [(1,2),(1,3),(3,2),(2,3),(1,4),(1,5),(5,2),(4,3),(3,4),(2,5),(1,6),(5,3),(3...
02:38:12 <psykotic> here is oleg's older stuff: http://okmij.org/ftp/Computation/monads.html#fair-bt-stream
02:38:54 <cads> ahh, I'm off a bit - fixing it makes it exactly Heffalump
02:39:01 <cads> 's code
02:40:05 <psykotic> btw, oleg's code is essentially just roundrobin thread scheduling
02:40:15 <ketil> Where does "If wishes were horses..." (wren's posting to -cafe) come from?  Or rather, how does it continue?
02:40:40 <ketil> I couldn't help thinking that if I wished wishes were horses, and got my wish, I would get a horse instead...
02:40:46 <BONUS> > concatMap (\x -> zip [1..x] [x,x-1..]) [1..]
02:40:47 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
02:41:00 <BONUS> ketil: i only know about: If wishes were fishes, we'd all cast nets.
02:41:25 <BONUS> which is from Dune
02:41:46 <BONUS> oh wait. http://en.wikipedia.org/wiki/If_wishes_were_horses,_beggars_would_ride
02:42:16 <ketil> If wishes were fishes, we'd put them on dishes... Oh, I've heard that one after all.
02:42:31 * ketil apologizes for not catching the ECC errors in his brain.
02:44:23 <cads> thanks for the help all
02:46:39 <cads> hah, funny about oleg's code - I'm generating pythagorean triples too.
02:51:16 <psykotic> so is sigfpe :)
02:55:42 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
02:55:43 <lambdabot>  Defined.
02:56:33 <Cale> > let pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]} in map (pyth . (+1)) posRationals
02:56:35 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
02:58:50 <psykotic> mr feigenbaum i presume?
03:00:07 <Cale> The chaos theory Feigenbaum?
03:03:57 <cads> > let primPyth = [ (a,b) | h <- [1..], a <- [1..div h 2], let b = h - a, gcd a b == 1, square(a^2+b^2)] where square n = n == (floor . sqrt . fromIntegral $ n) ^ 2 in take 20 primPyth
03:03:58 <lambdabot>   [(3,4),(5,12),(8,15),(7,24),(20,21),(12,35),(9,40),(11,60),(28,45),(16,63),...
03:04:44 <mm_freak_> is anyone here responsible for hackage user accounts?
03:05:11 <ivanm> mm_freak_: Heffalump is IIRC...
03:05:18 * ivanm is quite possibly wrong however
03:05:21 <mm_freak_> i tried to request one through an email to the addess given on the web page, but i got a delivery error back
03:05:26 <mm_freak_> thanks
03:05:34 <mm_freak_> Heffalump: are you responsible for hackage user accounts?
03:06:49 <cads> @src posRationals
03:06:49 <lambdabot> Source not found. You untyped fool!
03:11:47 <mm_freak_> oh, i just saw that my mail got rejected
03:12:17 <jlouis> mm_freak_: I think it is Ross Paterson
03:12:47 <jlouis> mm_freak_: http://hackage.haskell.org/packages/accounts.html yup
03:17:12 <mm_freak_> yeah, indeed, but i wonder why my mail got rejected
03:18:33 <Saizan> you might try asking on cabal-devel@
03:19:23 <mm_freak_> i resent the mailâ€¦  seems like it worked now
03:19:30 <mm_freak_> at least no failure mail yet
03:19:41 <dobblego> what library is typically used for parsing binary format?
03:20:25 <ivanm> if I want to do [[a]] -> Seq a, what would be better? "Seq.fromList . concat" or "foldr ((><) . Seq.fromList) Seq.empty" ?
03:21:56 <ivanm> dobblego: attoparsec is meant to be good for that...
03:22:13 <ivanm> dobblego: otherwise, there's cereal IIRC
03:23:06 <mm_freak_> since version 3 parsec supports ByteStrings, so i wonder whether attoparsec is faster
03:23:28 <ivanm> mm_freak_: didn't you see bos' latest blog post? :p
03:23:34 <mm_freak_> i fell in love with polyparse lately because of its implicit 'try'
03:23:43 <mm_freak_> ivanm: hmm?
03:23:44 <ivanm> IIRC, parsec is slow due to having too much backtracking, etc.
03:23:57 <ivanm> attoparsec is faster than parsec-3!
03:24:11 <ivanm> mm_freak_: oh, the automatic failing?  yeah, that's handy
03:24:22 <mm_freak_> too much?  i don't know how it's solved technically, but you need to allow backtracking explicitly, which is rather annoying
03:24:36 <mm_freak_> in most of my code i'd rather commit explicitly like you do in polyparse
03:24:49 <ivanm> and I just realised the other day that instead of manually having to put back stuff that parsed and failed, I could just manually call fail to get that parse to die
03:24:54 <mm_freak_> also i wonder what happened to arrow-based parsers
03:25:01 <mm_freak_> PArrows isn't maintained for quite some time now
03:25:19 <Saizan> is attoparsec really for binary data? the API seems geared towards textual
03:25:20 <ivanm> mm_freak_: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
03:26:09 <mm_freak_> wow
03:26:31 <mm_freak_> i just wondered, there are five items, but only three bars =)
03:26:44 <ivanm> mm_freak_: look at the beginning...
03:26:48 <ivanm> there _are_ 5 bars
03:26:56 <ivanm> http_parser and attoparsec are just that fast ;-)
03:26:58 <Saizan> ivanm: it's not backtracking that's making parsec-3 slower, it's the generality and the lack of effort spent in optimizating it for GHC
03:27:03 <ivanm> (in comparison)
03:27:07 <Saizan> *optimizing
03:27:15 <ivanm> Saizan: oh? attoparsec is that tied to ghc?
03:27:31 <ivanm> and by "generality" I presume you mean that you can parse different types of data, etc.?
03:28:17 <Saizan> yeah
03:28:31 <Saizan> well, i guess it has those INLINE pragmas etc..
03:28:44 * Saizan looks at the code
03:28:57 <mm_freak_> ivanm: yeah, just seen that
03:29:29 <ivanm> would concat be O(n) (where n is the length of the returned list)?
03:30:00 <Saizan> saizan@astarte:~/attoparsec-0.7.2/Data$ grep -r INLINE * | wc -l
03:30:01 <Saizan> 32
03:30:26 <Saizan> ivanm: yes
03:30:37 <jlouis> A couple of correctly placed INLINEs goes a long way
03:30:55 * ivanm has never worked out how to know where to place INLINEs
03:31:11 <jlouis> unfortunately, my INLINE-placing-fu is not up to par
03:32:37 <mm_freak_> ross just replied
03:32:42 <ivanm> and?
03:32:53 <mm_freak_> got an account now =)
03:33:39 <zygoloid> ivanm: well, not quite. it's more like O(n-k) where k is the length of the last list
03:34:06 <ivanm> zygoloid: well, in many cases n >> k, so O(n) is good enough ;-)
03:34:09 <zygoloid> (and this is assuming we have a reasonable definition for big-O notation in a lazy language...)
03:34:27 <ivanm> true
03:34:29 <Saizan> (we have)
03:34:35 <zygoloid> basically concat is asymptotically free
03:35:10 <zygoloid> because you already have to have an O(n) cost traversing the first n elements of the result in order to see the O(n) cost of producing the first n elements of the result
03:35:17 <Saizan> time-wise you just pay the cost of traversing the result
03:35:59 <Saizan> space-wise you build new cons cells (unless it gets fused)
03:36:26 <zygoloid> space-wise it's free isn't it, unless the caller holds on to the start of the list as they traverse?
03:38:51 <Saizan> mh, it's O(n) garbage, not sure how i'd consider that free
03:39:03 <Saizan> s/how/how much/
03:39:25 <zygoloid> hmm, that's true. to be honest i'm not sure i have the requisite tools to reason about this...
03:39:31 <Saizan> the bottom line is that concat is very cheap, anyhow :)
03:39:46 <Saizan> "concat xs ++ concat ys" instead..
03:40:39 <ivanm> Saizan: "O(n) garbage" ?
03:42:00 <zygoloid> ivanm: as compared to (repeat x) which has O(1) garbage no matter how far you traverse
03:42:40 <ivanm> what are you meaning by "garbage"?
03:43:14 <Saizan> structures that can be garbage collected
03:43:15 <ivanm> is concat O(n) or not?
03:43:38 <quicksilver> it's O(n) where n is the total size of all lists except the last.
03:43:45 <quicksilver> as said some time above
03:43:57 <ivanm> yes, but zygoloid and Saizan then confused me ;-)
03:44:23 <Saizan> i started talking about space usage
03:44:43 <ivanm> OK, so Seq.fromList . concat might be a better rather than a fold . map Seq.fromList
03:45:12 <ivanm> ahhh
03:46:21 <zygoloid> ivanm: sorry!
03:48:08 <Jonno_FTW> @src concat
03:48:08 <lambdabot> concat = foldr (++) []
03:49:07 <Gooffy> hi, folks! i'm trying CHP (communicating haskell processes), but first code snippet from tutorial failed to compile with strange error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23919#a23919 <- here is code and error. chp abd chp-plus installed via cabal-install. what's wrong? thanks :)
03:50:49 <Saizan> Gooffy: you've to use --make
03:52:45 <Gooffy> Saizan: oh, my fault! thanks! :)
03:55:45 <Saizan> np :)
04:15:27 <shapr> Yow!
04:15:51 <zygoloid> @shapr shapr
04:15:51 * lambdabot smacks shapr about with a large trout
04:16:01 <shapr> Hm, something fishy going on here
04:16:14 <jlouis> shapr: yo!
04:21:21 <jlouis> Haskell doesn't like HaskellTorrent running with -threaded... http://paste.pocoo.org/show/188780/
04:22:08 <danderson> does anyone have an example of a package on Hackage which invokes custom commands to generate some .hs files?
04:22:32 <danderson> case in point, I'm already using Cabal's default support for .hsc files, but I need to explain to it how to generate a .hs file from a .proto file as well.
04:27:27 <poucet> danderson: afaik, cabal file only defines the dependencies on packages, I believe the build commands are in Setup.hs
04:28:19 <ivanm> gahhhh!!! I'm trying to define something in ghci; :type works but as soon as I try to do let foo = it complains about ambiguous type variables even if I give it an explicit type signature! :@
04:28:19 <danderson> poucet: well, it also defines the kind of build system used, but yes, you're correct. I should be less vague :)
04:30:00 <danderson> poucet: but I'm simply going to bruteforce it. Getting the "all packages" archive from hackage, and power to grep :P
04:30:03 <shapr> y0 jlouis
04:32:11 <ivanm> y0 shapr
04:37:26 <ivanm> is there a nicer way of saying something like: do { a <- foo; if p a then fail "message" else return a } ?
04:39:08 <jlouis> :t when
04:39:09 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:39:18 <jlouis> ivanm: closest thing I can come up with
04:39:37 <ivanm> yeah, I was thinking of that
04:39:44 <BONUS> isn't guard closer to that?
04:39:44 <ivanm> but then I have to still do a return
04:39:55 <BONUS> when doesn't fail, it just returns () if the condition isn't met
04:39:56 <BONUS> :t guard
04:39:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:40:00 <Makoryu> @pl \foo p m -> foo >>= \a -> if p a then fail m else return a
04:40:00 <lambdabot> (. flip (flip . (ap .) . (. fail) . flip . (if' .)) return) . (.) . (>>=)
04:40:01 <ivanm> BONUS: well, I'm not sure if this particular monad is a monadplus instance actually...
04:40:06 <ivanm> heh
04:40:19 <ivanm> nope, it isn't
04:40:45 <ivanm> malcolmw: have you ever thought about making polyparse have monadplus, applicative, etc. instances?
04:41:06 * ivanm isn't sure if that makes sense or not for Parser, but still...
04:41:36 <ivanm> BONUS: actually, guard doesn't make sense for this because I _want_ to explicitly call fail (since it stops the parsing)
04:41:53 <BONUS> ah
04:42:14 <ivanm> @hoogle when
04:42:15 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
04:42:35 <Saizan> danderson: you've to grep for uses of this http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.8.0.2/Distribution-Simple.html#v%3AhookedPreProcessors , if you didn't know already :)
04:43:18 <poucet> Is there a proper place to discuss 'cabal'?
04:43:23 <danderson> Saizan: ooooh, perfect and shiny, thanks!
04:43:39 <Saizan> poucet: there's #hackage
04:43:45 <poucet> Saizan: ah, that's it =)
04:46:43 <merijn> Blah, haskell has ruined my ability to write C which doesn't crash with stack overflows >.>
04:46:43 * ivanm is tempted to specify -fno-warn-unused-do-bind in ghc-options in the cabal file for graphviz
04:47:08 <ivanm> does ghc care if I pass it an invalid argument (because it was introduced in a later version of ghc)?
04:47:25 <ivanm> merijn: heh
04:47:35 <ivanm> Saizan: there is? :o
04:47:41 <ivanm> that's right, Axman6 started that...
04:53:02 <jlouis> ah, disabling -threaded puts the focus back on where the cost centre is
04:53:27 <merijn> ivanm: I find myself implementing trees with recursive functions in C because it's just so much easier. But obviously that doesn't work well in C if it results in lots of recursion >.>
04:53:56 <Jafet> Most trees have well-defined maximum depth.
04:56:58 <mm_freak_> merijn: recent versions of GCC do TCO
04:57:59 <merijn> mm_freak_: Well, I already rewrote the crashing code to avoid it. Most of it can remain recursive, fortunately
04:58:18 <tallpaul> Hi folks.
04:58:27 <mm_freak_> merijn: but i know what you mean
04:59:11 <mm_freak_> i implemented state monads and built monadic parser combinators on top of one of them in C#
04:59:41 <mercury^> mm_freak_: there has been some form of TCO in gcc for a long time now. Have there been recent improvements?
05:00:05 <tallpaul> How is it possible to combine a ReaderT with a Parsec-monad? If I've written a function parseProgram : Parser Program, how is the type signature for the lifted version? I thoght it was ReaderT Config Parser Program, but this is wrong
05:00:08 <mm_freak_> dunno, i'm not coding in C, i just repeat what i've heard
05:00:56 <merijn> mm_freak_: Nice, I was working on designing my own language in addition to the compiler for class but all attempts so far seem to evolve into either poor haskell or poor scheme designs :p
05:00:57 <SamB_XP> from what I can see, all major compilers do TCO in recent versions
05:01:06 <mm_freak_> tallpaul: that sounds right, though, but that type has kind * -> *
05:01:13 <SamB_XP> at least, MSVC and GCC do
05:01:20 <SamB_XP> I *think* I've seen it from BCC as well
05:02:11 <mm_freak_> merijn: what do you need C for?
05:02:26 <tallpaul> mm_freak: How to fix this? I want to read Config out while parsing? ReaderT Config ???
05:02:48 <SamB_XP> I'm not sure exactly how *often* they do it, or which optimization flags you need to turn on, but seems to happen at least for no-args functions
05:02:49 <merijn> mm_freak_: The compiler framework we're using to class is written in C, so it's either C or invent everything for the class from scratch...
05:03:04 <merijn> s/to/in/
05:03:09 <mm_freak_> tallpaul: myIntegerParser :: ReaderT Config Parser Integer
05:03:29 <mm_freak_> tallpaul: note that depending on your monad transformer library you need to lift in one or another way
05:03:31 <SamB_XP> anyway, try it and see if the compiler you're using does it ?
05:03:55 <SamB_XP> merijn: well, it might not be that hard to recode everything in Haskell ;-P
05:04:23 <merijn> SamB_XP: True, but I'll save that for when my grade doesn't depend on it :p
05:04:38 <mm_freak_> merijn: i agree with SamB_XPâ€¦  using most C libraries is probably much more difficult than rewriting them from scratch in haskell
05:05:01 <SamB_XP> how many lines of code is the whole framework ?
05:05:18 <tallpaul> mm_freak: I'm using ghc Control.Monad.Reader. If I say "ReaderT Config Parser Program" Haskell complains: Type synonym `Parser' should have 1 argument, but has been given 0.
05:05:49 <SamB_XP> @hoogle Reader
05:05:49 <lambdabot> module Control.Monad.Reader
05:05:49 <lambdabot> Control.Monad.Reader newtype Reader r a
05:05:50 <lambdabot> Control.Monad.Reader Reader :: (r -> a) -> Reader r a
05:05:53 <Saizan> tallpaul: you can't partially apply type synonyms
05:05:53 <SamB_XP> @hoogle Parser
05:05:53 <lambdabot> module Language.Haskell.Parser
05:05:54 <lambdabot> Text.Parsec.ByteString type Parser = Parsec ByteString ()
05:05:54 <lambdabot> Text.Parsec.String type Parser = Parsec String ()
05:05:56 <mm_freak_> tallpaul: you're probably using Control.Monad.Reader from the mtl package, which has nothing to do with GHC ;)
05:06:13 <SamB_XP> hmm ...
05:06:23 <SamB_XP> tallpaul: which version of parsec are you using ?
05:06:44 <tallpaul> i think 3.0.0
05:06:44 <SamB_XP> @hoogle Parsec
05:06:45 <lambdabot> module Text.Parsec
05:06:45 <lambdabot> module Text.ParserCombinators.Parsec
05:06:45 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
05:06:46 <Saizan> tallpaul: though you can probably substitute the definition of Parser manually in there
05:06:54 <SamB_XP> @hoogle ParsecT
05:06:55 <lambdabot> Text.Parsec.Prim data ParsecT s u m a
05:06:55 <lambdabot> Text.Parsec.Prim ParsecT :: (State s u -> m (Consumed (m (Reply s u a)))) -> ParsecT s u m a
05:06:55 <lambdabot> Text.Parsec.Prim runParsecT :: ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))
05:07:27 <merijn> SamB_XP: 17k or something in that absurd ballpark
05:07:28 <Saizan> @hoogle Parser
05:07:28 <lambdabot> module Language.Haskell.Parser
05:07:28 <lambdabot> Text.Parsec.ByteString type Parser = Parsec ByteString ()
05:07:29 <lambdabot> Text.Parsec.String type Parser = Parsec String ()
05:07:52 <SamB_XP> merijn: hmm, that doesn't sound all that bad
05:08:40 <SamB_XP> how much of that is to make up for C having no standard datastructure libraries ?
05:09:26 <SamB_XP> Saizan: I'm not quite seeing why the synonym needs an arg
05:09:36 <Honza>  > map (+1) [1..10]
05:09:36 <Honza>  
05:09:37 <merijn> Most of it is actually meta-code to generate datastructure and data integrity checking from an XML AST specification
05:09:38 <SamB_XP> @kind Parser
05:09:39 <lambdabot> Not in scope: type constructor or class `Parser'
05:09:43 <Saizan> SamB_XP: neither do i
05:09:50 <SamB_XP> merijn: oh
05:10:07 <SamB_XP> merijn: why is THAT written in *C* of all things ?
05:10:16 <Zao> SamB_XP: What else? Java?
05:10:35 <malcolmw> ivanm: yes, I nearly converted polyparse to have Applicative and Alternative, but there turns out to be a small technical problem
05:10:38 <merijn> SamB_XP: Masochism by the research group the framework is pilfered from?
05:10:39 <SamB_XP> wouldn't XSLT or Python or Perl or PHP -- or, yes, Java! -- be a better choice ?
05:10:54 <merijn> SamB_XP: There's XSLT in there to
05:11:28 <SamB_XP> not that I like XSLT much, but that's mostly because it has only about half as much syntax as I think it ought to have
05:11:30 <merijn> Doing the XML transformation in C would just be stupid
05:11:56 <SamB_XP> namely, it has XPath, but no real syntax for itself -- just that lame XML stuff
05:12:15 <SamB_XP> it's like if Relax NG didn't have the Compact form
05:18:01 <shapr>  y0 ivanm
05:18:29 <VeXocide> Hi, -this is a homework question, but it already works, I just want to know if there's a neater solution-, we have http://codepad.org/LEGp0tL5 and in exprs we want to find all expressions in a list of stats
05:18:37 <VeXocide> writing out all cases seems like overkill
05:19:11 <Jafet> I wish my homework involved haskell
05:19:40 * Botje is in the position to give homework about haskell
05:19:57 <shapr> Jafet: You could assign yourself Haskell homework
05:20:09 <shapr> or you could do the Botje homework!
05:20:16 <merijn> VeXocide: Where do you study that has haskell homework? (Netherlands I'm assuming from comments...)
05:20:34 <Botje> VeXocide: why did you duplicate exprs for [] and non-empty lists?
05:20:41 <Botje> can't you just say exprs [] = [] ?
05:21:41 <VeXocide> Botje, that's a good point, fixed that
05:22:32 <VeXocide> merijn, Technische Informatica at the TU/e in Eindhoven, we have the course Functional Programming which is given using haskell
05:23:06 <VeXocide> er, Technische Informatica translates to Computer Science
05:23:47 <Botje> VeXocide: also, exprs (s ++ t) === exprs s ++ exprs t , which is a lot clearer imo
05:23:52 <merijn> Nice, I intended to go to the NL-FP day in Eindhoven, but I had to stay up until 6 am to get out formal verification project done so in the end I didn't make it :\
05:25:25 <VeXocide> Botje, you're right, that does look better
05:27:17 <ZtdCk9PF4NrUuHXh> idiomatic way to remove nth entry from a list?
05:27:17 <Botje> VeXocide: also, people generally write exprs :: Stat -> [Expr] and use concatMap to do [Stat] -> [Expr]
05:27:36 <Botje> ZtdCk9PF4NrUuHXh: that way lies pain.
05:27:57 <Botje> ZtdCk9PF4NrUuHXh: let (f,_:r) = splitAt n list in f ++ r
05:27:58 <ZtdCk9PF4NrUuHXh> list is *very* short and I test the length ahead of time
05:28:46 <cads> Is there a function which builds a list from every nth element of a given list?
05:28:54 <cads> Something like the following:
05:28:57 <cads> > let  everyN _ [] = []; everyN (n+1) (x:xs) = x : everyN (n+1) (drop n xs);  in everyN 6 [0..36]
05:28:58 <lambdabot>   [0,6,12,18,24,30,36]
05:29:16 <VeXocide> Botje, could you give an example on how to use concatMap?
05:29:49 <Botje> VeXocide: given exprs wit hthe type Stat -> [Expr], *your* version of exprs would simply be concatMap exprs
05:30:10 <VeXocide> Botje, ah, k
05:31:43 <Botje> cads: you could use map head . Data.List.Split.chunk 6 ?
05:32:43 <cads> I'll check it out Botje
05:33:38 <mm_freak_> > let everyN n = map head . takeWhile (not . null) . iterate (drop n) in everyN 6 [0..36]
05:33:39 <lambdabot>   [0,6,12,18,24,30,36]
05:33:52 <VeXocide> Botje, is there a neater way to turn an Expr x into a [Expr] other than x:[] ?
05:34:14 <VeXocide> ah, [x] works
05:34:16 <Botje> [x]
05:34:44 <mm_freak_> cads: that's how i would write it
05:35:14 <stulli> What is the equivalent to "runWriter" in the list monad?
05:35:33 <mm_freak_> stulli: the list functions
05:35:45 <mm_freak_> and pattern matching
05:36:36 <cads> mm_freak_: hah, I like it!
05:38:00 <ZtdCk9PF4NrUuHXh> >  let (f,_:r) = splitAt 3 [0 .. 10] in f ++ r
05:38:01 <lambdabot>   [0,1,2,4,5,6,7,8,9,10]
05:38:50 <ZtdCk9PF4NrUuHXh> this language reminds me too much of APL sometimes
05:39:27 <stulli> mm_freak_: So there is not only one function (like runWriter) to evaluate(?) the monad but several (the list functions)? In most examples it seems to me like the list monad executes in the IO monad
05:39:59 <Botje> stulli: what?
05:40:12 <mm_freak_> stulli: note that monads don't necessarily denote computations, for which it makes sense to be run
05:40:32 <mm_freak_> in the list monad the computation is the list of results
05:41:00 <mm_freak_> > do x <- [0..3]; y <- [10,20,30]; [y+x, y-x]
05:41:01 <lambdabot>   [10,10,20,20,30,30,11,9,21,19,31,29,12,8,22,18,32,28,13,7,23,17,33,27]
05:41:45 <mm_freak_> this whole do construct is a list, not a computation producing a list
05:42:00 <mm_freak_> so "running" the list would be like using the elements of it
05:42:32 <tsou> What is the proper way to get the correct newline string depending on the system?  ("\n", "\r\n", etc)
05:42:37 <fasta> So, did anyone actually understand stulli's question?
05:43:00 <mm_freak_> fasta: no, but that's likely related to a misunderstanding of monads =)
05:43:29 <mm_freak_> tsou: the "proper" way to use newlines is to use '\n', because the base library translates it to whatever is correct on the current platform
05:43:38 <tsou> mm_freak_: wow, thanks :)
05:43:44 <theorbtwo> tsou: It is always "\n", if you opened the file in text mode correctly.
05:44:28 <Botje> fasta: i guess he was asking about the definition of runList
05:44:33 <Botje> but afaik it's just id :]
05:44:50 <stulli> fasta: I was thinking since Writer and List are both monads, they should share some properties. And i thought having a "execution function" like runWriter would be such a property
05:45:07 <mm_freak_> well, an actual "runList" would be something like foldr =)
05:45:18 <Botje> stulli: nah, the only shared features monads have are >>= and return
05:45:21 <fasta> The only use of the list monad is the list monad transformer as far as I am concerned and even then the use of it is questionable.
05:45:40 <mm_freak_> stulli: there is no runIO either
05:45:56 <mm_freak_> there is unsafePerformIO, but that's not meant to be used, unless you have a very good reason =)
05:46:06 <fasta> stulli, monads share return and bind and that is it.
05:46:16 <cads> Botje: Nice suggestion - map head . chunk n $ list does it perfectly.
05:46:17 <fasta> stulli, the rest is specific.
05:46:18 <mm_freak_> fasta: i use the list monad very often
05:46:31 <mm_freak_> > let subsets = filterM (const [True, False]) in subsets "abc"
05:46:32 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
05:46:42 <fasta> mm_freak_, that would be a very bad use.
05:46:51 <mm_freak_> not for quick-n-dirty code
05:46:54 <mm_freak_> =)
05:46:58 <stulli> I guess the time has come to not just use monads but finally understand them
05:47:18 <mm_freak_> and actually not even for real code, because if you understand the list monad, you understand my definition, too
05:47:29 <theorbtwo> The biggest problem with the list monad is that foo [x] = do ... does something, and often not what you expect.
05:47:37 <fasta> stulli, it are just objects with two methods (actually it is a bit more complicated, but that is mostly irrelevant).
05:47:45 <theorbtwo> Then again, even I haven't had that problem in a long time.
05:47:50 <mm_freak_> theorbtwo: why?  it's just somewhat desugared list comprehension
05:48:17 <fasta> stulli, and then some (probably all) monads have extra methods.
05:48:18 <theorbtwo> Huh.  Maybe that isn't a bad thing in a long time.
05:48:25 <mm_freak_> stulli: you may want to read my monads tutorialâ€¦  it explains the list monad thoroughly =)
05:48:33 <fasta> stulli, there is nothing magical or special about them.
05:48:50 <stulli> mm_freak_: Where do i find it?
05:48:52 <fasta> They are not built-ins or anything like that.
05:49:07 <theorbtwo> Back in the day, when Pugs ruled the earth, I had that problem a lot, where I actually wanted to return a list, and accidentally ended up being in the list monad.  However, possibly...
05:49:08 <mm_freak_> stulli: see the notice
05:49:23 <theorbtwo> a: I wouldn't have had that problem in the first place, had I understood monads even a little, and...
05:49:25 <fasta> theorbtwo, Pugs never ruled the earth.
05:49:50 <theorbtwo> b: It wouldn't have been a problem if I had understood monads even a little.
05:50:04 <theorbtwo> fasta: Call it artistic license, if you like.
05:50:17 <theorbtwo> Or hyperbole, if you prefer.
05:50:35 <mm_freak_> theorbtwo: well, i always add type signatures, so generally i don't run into this problem
05:51:31 <mm_freak_> however, one of my most frequent use cases for the list monad is combinations and permutations
05:51:41 <mm_freak_> > replicateM 3 "01"
05:51:42 <lambdabot>   ["000","001","010","011","100","101","110","111"]
05:52:14 <mm_freak_> > sequence ["bB", "lL", "aA4", "hH"]
05:52:15 <lambdabot>   ["blah","blaH","blAh","blAH","bl4h","bl4H","bLah","bLaH","bLAh","bLAH","bL4...
05:52:38 * hackagebot np-extras 0.2.0.1 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.2.0.1 (BrentYorgey)
05:52:43 <Jafet> Looks easier than jtr
05:53:23 <misk20> I know little bit of haskell and want to learn more, what do you suggest where can i start ?
05:53:31 <Botje> @where lyah
05:53:31 <lambdabot> http://www.learnyouahaskell.com/
05:53:34 <Botje> or
05:53:36 <Botje> @where rwh
05:53:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:53:59 <Botje> or try to do some project euler problems
05:54:10 <misk20> i was more looking for practice i know some theory, like any small project ideas
05:54:14 <Botje> ah
05:54:18 <Botje> project euler is a good idea
05:54:24 <Botje> most of first 50 are oneliners in haskell
05:54:44 <Jafet> They don't teach any haskell
05:54:45 <misk20> what is that actually
05:54:55 <misk20> euler ?
05:55:05 <Jafet> Something Euler would strongly disapprove of.
05:56:19 <misk20> http://projecteuler.net/ ??
05:56:20 <therp> misk20: http://project-euler.net
05:56:27 <therp> or without the dash
05:56:33 <misk20> thnx
05:57:22 <cads> Botje: check out http://projecteuler.net/index.php?section=problems&id=11 - that's no one liner!
05:57:30 <cads> maybe a 4-liner :)
05:57:52 <jlouis> misk20: find something you want solved. Try to solve it.
05:58:14 <jlouis> Repeat until you begin to have proficiency
05:58:45 <Zao> cads: Ignoring the list, mine is 15 lines or so.
05:59:08 <Zao> 15 reasonably readable lines, I might add.
05:59:58 <cads> hehe
06:00:05 <fasta> If you want to solve that problem optimally it is probably more.
06:00:29 <fasta> There are certain optimizations you can do to the most readable program that a compiler probably doesn't do.
06:00:29 <merijn> fasta: Depends on your definition of optimal :p
06:00:44 <fasta> merijn, that which uses the least amount of CPU.
06:00:59 <VeXocide> how can I import a module in a .hs file?
06:01:23 <fasta> VeXocide, import Prelude
06:02:01 <VeXocide> fasta, but I get a picoStart.hs:66:0: parse error on input `import'
06:02:14 <misk20> jlouis : is there any place i can post my code and discuss whether its good or not ??
06:02:26 <Botje> cads: hence, /most/ of them :]
06:02:30 <fasta> VeXocide, show the whole code or solve it yourself.
06:03:09 <cads> I think I will make something to find the largest sum of a list of integers. Then I'll apply it to the list of lists for the horizontal pass, transpose the list for the vertical pass, and pad the list with zeros to line it up for the diagonal passes
06:03:43 <VeXocide> fasta, sorry, http://codepad.org/E1zGL6OG
06:03:43 <jlouis> misk20: indeed. For small code blocks, we have a pastebin. For larger projects, you can host it somewhere on a revision control hosting platform
06:04:07 <fasta> VeXocide, they have to be on the top.
06:04:09 <misk20> ok
06:04:17 <VeXocide> fasta, ah, ok
06:04:28 <fasta> VeXocide, import A;x=1;import B means garbage in Haskell.
06:04:48 <jlouis> hey kamatsu
06:05:14 <VeXocide> fasta, makes sense, so it needs to be before "module" right?
06:05:34 <sinelaw> affirmation of prior presence!
06:05:42 <fasta> VeXocide, read a book. It is pointless to program like you are doing.
06:06:12 <VeXocide> fasta, you have a point there, thanks anyways
06:06:31 <kamatsu> jlouis: hey
06:09:23 <Makoryu> VeXocide: Actually, the import statements have to come after the "module Foo where" part.
06:13:37 <VeXocide> Makoryu, thanks
06:13:56 <Makoryu> But yeah, you should read a book
06:15:57 <Saizan> @where LYAH
06:15:57 <lambdabot> http://www.learnyouahaskell.com/
06:16:24 <fasta> Saizan, did you read LYAH completely?
06:16:42 <Saizan> fasta: no, i don't even know if it cover this
06:17:12 <fasta> Saizan, so why do you recommend it?
06:17:33 <Saizan> hearsay
06:19:12 <mm_freak_> project euler problems are good to learn solving mathematical problems in haskell, but they don't teach application development
06:19:28 <benmachine> they are good to learn all sorts of things
06:19:40 <benmachine> but agreed, not application development
06:20:22 <jlouis> I can only recommend "A Gentle introduction to Haskell" :P
06:20:43 <jlouis> but that is H98 and thus perhaps not fitting these days, IIRC
06:20:50 <Saizan> what's the opposite of recommend?:)
06:21:01 * hackagebot c10k 0.2.0 - C10k server library  http://hackage.haskell.org/package/c10k-0.2.0 (KazuYamamoto)
06:21:02 <Saizan> i need to use that for YAHT
06:21:09 <Jafet> "proscribe", perhaps
06:21:21 <Jafet> And you can "prescribe" lyah
06:21:31 <medfly> for me, project euler problems create small, easy to solve problems that I use to learn a new language when I run out of things to try myself that I can still do :)
06:21:34 <theorbtwo> You might want to try http://codekata.pragprog.com/ , perhaps.
06:21:54 <Zao> Bah, no -threaded runtime for that c10k library.
06:22:02 * hackagebot webserver 0.2.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.2.0 (KazuYamamoto)
06:22:34 <Zao> Interesting that that limitation is not mentioned in the webserver-0.2.0 description.
06:22:39 <Zao> Nice mine for someone to find.
06:23:07 * hackagebot mighttpd 0.2.0 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.2.0 (KazuYamamoto)
06:24:25 <sinelaw> is there any way to know if two values are the same without Eq?
06:24:31 <jlouis> Zao: I've just had fun disabling -threaded on HaskellTorrent. It definitely changed the performance profile
06:24:53 <sinelaw> like knowing that two subexpressions are identical?
06:24:59 <sinelaw> the compiler obviously knows, no?
06:25:13 <Saizan> you mean poiter equality?
06:25:18 <theorbtwo> sinelaw: If you think the compiler knows, you can say "driving (Eq)", and see if you are right.
06:25:18 <Saizan> *pointer
06:25:53 <jlouis> sinelaw: it might know that they are identical, but not always
06:25:55 <sinelaw> example, a -> b -> (a,b), if i have two partially applied functions
06:26:04 <Saizan> jlouis: btw, are you aware that communications with the main thread are significantly more expensive?
06:26:22 <jlouis> Saizan: yup, the main thread is basically parked on a mutex
06:26:27 <Saizan> 'k
06:26:27 <sinelaw> > (const 4) == (const 4)
06:26:28 <lambdabot>   No instance for (GHC.Classes.Eq (b -> t))
06:26:28 <lambdabot>    arising from a use of `GHC.Cla...
06:27:13 <benmachine> sinelaw: allowing the amount of reflection that would be necessary for that would require optimisation-breaking changes, I think
06:27:17 <Saizan> at runtime you don't have the expressions around to compare them
06:27:18 <benmachine> or, so I would guess
06:27:45 <jlouis> Saizan: currently I am slowly adding cost centres around each process. That digs up some interesting things
06:27:47 <sinelaw> so the only way to compare DSL values is to use a deep-dsl?
06:28:03 <benmachine> and would break things like referential transparency, because const 4 would equal const 4 but might not equal (if goldbachConjectureIsTrue then const 4 else const 5)
06:29:07 <Saizan> sinelaw: not necessarily, see Oleg's tagless interpreters, or the hackier StableName
06:29:54 <Saizan> sinelaw: Oleg has an example where he does CSE
06:30:26 <sinelaw> link?
06:32:02 <Saizan> it was a mailing list message, maybe it's linked from here http://okmij.org/ftp/Computation/tagless-typed.html
06:32:20 <Saizan> however this approach is somewhat deeper than others
06:32:30 <sinelaw> deeper in what sense
06:33:40 <Saizan> well, it has binders (e.g. lambdas) in the EDSL, though they are in HOAS style
06:34:20 <sinelaw> i guess i'll need to read some :)
06:34:25 <sinelaw> or use a deep dsl
06:44:56 <cads> Zao: I have come up with a solution, though it's perhaps not very readable
06:45:36 --- mode: ChanServ set +o Saizan
06:48:00 --- mode: Saizan set -b *!*@*.dynamic.sbb.rs
06:49:27 --- mode: Saizan set -o Saizan
06:50:29 * hackagebot multiset-comb 0.2 - Combinatorial algorithms over multisets  http://hackage.haskell.org/package/multiset-comb-0.2 (BrentYorgey)
06:50:55 <cads> Zao: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23923#a23923
06:51:06 <Phyx-> oh noes, i'm late
06:52:02 <Zao> cads: Mine uses an unboxed array and bruteforces over sets of indices.
06:55:22 <cads> I was thinking of an approach like that but was too tired to work out comprehensions for the indices. How did you generate your sets of index tuples?
06:56:28 * ManateeLazyCat Got GHC 6.12.1 error `stg_ap_v_ret` when call `forkProcess`
06:57:16 <ManateeLazyCat> What's `stg_ap_v_ret`?
06:58:04 <Zao> Non-comprehensingly :)
06:59:16 <ManateeLazyCat> And sometimes got `WEAK object entered!` and `MUT_ARR_PTRS_FROZEN object entered`, but now just `stg_ap_v_ret` can redure.
06:59:41 <Apocalisp> CAN_HAZ_ARR_PTRS
07:00:09 <Zao> u = filter (<20) [x..x+3] ; v = filter (<20) [y..y+3] ; v' = filter (>=0) [y,y-1..y-3]   and then zip suitably to get sequences of ix.
07:03:30 <cads> everyone in the forum searched for big numbers by eye
07:03:41 <poucet> @check let rest s = if s == [] then [] else tail s in \l -> rest l == drop 1 l
07:03:42 <lambdabot>   "OK, passed 500 tests."
07:04:50 <Jafet> Does ghc 6.12.1 go with cabal 1.6.0.2?
07:05:27 <poucet> @hoogle split
07:05:27 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
07:05:27 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
07:05:27 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
07:06:38 <Jafet> Hmm, wait
07:07:23 <Jafet> "GHC 6.12.1 only works with Cabal-install 0.8 or later."   The cabal page lists 0.6.4
07:08:33 <Saizan> ghc-6.12+ requires Cabal-1.8+ and cabal-install-0.8+
07:08:44 <Saizan> the latter is on hackage
07:09:20 <Jafet> Thanks
07:10:22 <Saizan> (Cabal-1.8.something comes with ghc, don't reinstall it, especially globally, or you might break your ghc installation)
07:10:44 <Jafet> Seems that the install script didn't install it, though
07:11:35 <Saizan> "Cabal" is the library, you should see it in ghc-pkg list Cabal
07:11:50 <b4taylor> I can't find where user-defined operators are defined :(
07:11:51 <Saizan> the executable "cabal" comes in the cabal-install package
07:12:18 <Saizan> it is a bit confusing, things should change when they get a chance to refactor a bit :)
07:12:46 <Saizan> b4taylor: if you've them in scope in ghci you can use :info
07:12:54 <Jafet> So, I should download cabal-install from hackage myself and install it
07:13:00 <Saizan> yeah
07:13:00 <b4taylor> Saizan: I think I found it in the report.
07:13:27 <b4taylor> Saizan: Oh I meant "what typograhic characters can be composed to form an operator"
07:13:36 <Saizan> oh, i see
07:13:45 <Saizan> then the report is the right place
07:14:11 <b4taylor> Saizan: Yeah I think my final google query was a success.
07:16:51 <jmcarthur> "<Vitka> omfg did I actually gave correct advice to someone?"  -- yup, but the whole thing could have been reduced to find
07:17:01 <jmcarthur> woah i was scrolled up
07:17:02 <jmcarthur> my bad
07:17:14 <jmcarthur> well
07:17:15 <jmcarthur> :t find
07:17:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:17:19 <jmcarthur> :)
07:17:48 <idnar> MonadZero!
07:18:47 <roconnor> http://www.cse.chalmers.se/edu/year/2010/course/afp/lectures/lecture11/Memo.hs.html <-- is this true; eta expanding a definition gives different operational behaviour?
07:19:29 <roconnor> oh
07:19:31 <roconnor> wait
07:19:39 <roconnor> memo uses unsafePerformIO
07:19:44 <roconnor> I guess all bets are off
07:21:04 <ddarius> roconnor: The operational behavior, specifically sharing, is unspecified.
07:22:16 <roconnor> but eta expansion seems so innocent
07:22:23 <benmachine> is it me or is it really annoying to get from a haskellwiki history/edit/talk page back to the original page
07:22:34 <roconnor> benmachine: it's not just you
07:22:44 <ddarius> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/src/Data-MemoCombinators.html
07:22:55 <ManateeLazyCat> I want create new bug, where to attach source code in wiki page?
07:23:01 <Saizan> roconnor: the monomorphism restriction applies only to CAFs for the same reason
07:23:14 <ManateeLazyCat> After "create ticket"?
07:24:03 <Saizan> ManateeLazyCat: if you're talking about trac you can upload an .hs file as an attachment
07:24:41 <roconnor> Saizan: yeah, but everyone knows that the MR is dumb. :)
07:25:24 <Saizan> MR is dumb for being overly obsessive about sharing, but implementations still "guarantee" only that much :)
07:25:56 <ddarius> roconnor: It's the difference between, let x = ... in \y -> ... and \y -> let x = ... in ..., which in a naive compilation would change when/how often x is allocated.
07:26:00 <ManateeLazyCat> Saizan: I just saw "preview" and "create ticket", haven't found any hint to upload attach file.
07:28:29 <ManateeLazyCat> Saizan: I find it after "create ticket".
07:28:33 <Alpounet> byorgey, nice work !
07:28:53 <Saizan> ManateeLazyCat: after you login there's an "Attach File" button just below the Description section
07:29:39 <ManateeLazyCat> Saizan: I have success.
07:29:49 <ManateeLazyCat> http://hackage.haskell.org/trac/ghc/ticket/3918
07:30:46 <ManateeLazyCat> Need gtk2hs, dbus-core, dbus-client to recur this bug.
07:30:56 <ManateeLazyCat> And i believe it's a bug of forkProcess.
07:32:04 <cYmen> I'm reading rwh and am currently in chapter four. Somebody suggests in the comments to rewrite filter using foldl instead of foldr. Could somebody comment on why this is a bad idea please?
07:32:35 <ManateeLazyCat> cYmen: Performance
07:32:52 <fax> cYmen, try both versions on an infinite list and explain what happens
07:33:00 <fax> > filter odd [1..]
07:33:01 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:33:57 <merijn> cYmen: I found a link with some nice diagrams showing the difference between how foldl and how foldr recurses, maybe that helps? http://cale.yi.org/index.php/Fold_Diagrams
07:34:44 <fax> does anyone know ALL of haskell?
07:35:12 <ManateeLazyCat> fax: Just ask. Have many people know ALL. :)
07:36:50 <Makoryu> fax: Define "all." There are plenty of extensions that few people know how to use.
07:37:02 <Makoryu> fax: And there are lots of libraries out there
07:37:09 <ManateeLazyCat> I have install GHC 6.12.1 , and i want install GHC 6.10.4 to test bug, how to make GHC-6.10.4 local?
07:37:13 <Makoryu> But the core language is actually really simple
07:37:36 <Saizan> ManateeLazyCat: pass a --prefix=foo flag to the configure script
07:37:46 <ManateeLazyCat> Saizan: Thanks.
07:40:15 * ManateeLazyCat Test GHC 6.10.4 whether have same bug for forkProcess.
07:40:53 <cYmen> so basically filter can be written using foldl just as well as foldr but when using foldl it uses a list ++ [elem] instead of elem:list and that makes it not work on infinite lists because in the first case the list would have to be done for the ++ to even start, right?
07:41:14 <Saizan> the problem is not there
07:41:20 <korstya> Hello! Does anybody know how to use internet explorer embedded in haskell? I need your help. Please :-)
07:41:28 <ManateeLazyCat> Saizan: Do you know what's mean `stg_ap_v_ret` ?
07:41:42 <ManateeLazyCat> korstya: gtk2hs
07:41:59 <korstya> ManateeLazyCat: thank you very much! :-)
07:42:03 <ManateeLazyCat> korstya: If you mean embedded browser in your GUI program
07:42:12 <Saizan> cYmen: can you write an f and z such that "foldl f z (repeat ())" gives an useful result?
07:42:16 <korstya> ManateeLazyCat: yes I do
07:42:37 <ManateeLazyCat> korstya: You can use GtkSocket/GtkPlug embedded any Gtk+/Qt widget in your GUI program.
07:43:11 <korstya> ManateeLazyCat: thank you! Haskell is Great! :-)
07:43:20 <ManateeLazyCat> korstya: Download darcs version of gtk2hs, and find demo program under subdir `demo/embedded` .
07:44:11 <cYmen> Saizan: I'm not following...
07:44:18 <ManateeLazyCat> korstya: I don't know how to embedded IE widget in it, but now it can embedded firefox widget, and webkits widgets will embedded in it after patched.
07:44:37 <korstya> ManateeLazyCat: i only need any web browser
07:44:41 <korstya> that's all
07:44:54 <ManateeLazyCat> korstya: Yes, gtk2hs can.
07:44:57 <korstya> I don't want to render page by myself
07:44:59 <korstya> :-)
07:45:08 <zygoloid> cYmen: does 'foldl f z (infinite list)' ever get as far as invoking f?
07:45:09 <Saizan> cYmen: the idea is that foldl will never terminate when applied to infinite lists, regarless of what the other arguments are
07:45:18 <cYmen> Shouldn't it be easier to use infinite lists with foldl instead of foldr because we know the left end of the list but not the right end?
07:45:28 <Saizan> @src foldl
07:45:28 <lambdabot> foldl f z []     = z
07:45:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:45:40 <cYmen> ok maybe I have a problem with the definitions here
07:45:41 <ManateeLazyCat> korstya: Me too. I'm not browser expert. :)
07:45:48 <fax> remember haskell is lazy
07:46:14 <merijn> cYmen: It is hard to explain, I recommend you manually execute a foldl by rewriting on a piece of paper or whiteboard, that how I finally "got" it
07:46:17 <Saizan> cYmen: laziness means that you always expand the outermost function application
07:46:33 <fax> so   head (x : <difficult computation>) = x  -- and it doesn't take time
07:46:33 <ManateeLazyCat> korstya: You even can embedded WebKit (same as Chrome) browser in future version of gtk2hs.
07:46:50 <cYmen> so a finite list looks like (1:(2:(3:[]))) how does that work for infinite lists?
07:46:51 <Saizan> cYmen: here the the outermost is always an application of foldl, so it keeps recursing
07:47:04 <ManateeLazyCat> korstya: You can found firefox browser demo under `demo/mozembed`.
07:47:06 <cYmen> Saizan: I get that so it never starts collecting the results back together...makes sense
07:47:08 <fax> 1:(2:(3:(4: ... )))
07:47:10 <korstya> ManateeLazyCat: Wow! Did you embed browser? You know much about it)
07:47:30 <ManateeLazyCat> korstya: I'm a developer of gtk2hs. :)
07:47:30 <cYmen> fax: mkay..and the ... are magic?
07:47:40 <fax> cYmen, yes
07:47:47 <idnar> I wouldn't say they're magic\
07:47:53 <fax> I showed you a 'real' infinite list in haskell earlier on
07:47:54 <korstya> ManateeLazyCat: it is great! what a luck that I've met you :-)
07:47:56 <fax> did you miss it?
07:47:56 <idnar> they just represent the fact that the list doesn't end
07:47:58 <ManateeLazyCat> korstya: Infact, Axel (author) have working on how to make Webkit in gtk2hs.
07:48:09 <idnar> obviously it's impossible to write the whole list out if it's infinite
07:48:15 <cYmen> fax: you mean [1..]?
07:48:18 <fax> yet
07:48:20 <fax> yes*
07:48:33 <ManateeLazyCat> korstya: Webkit have can render Webpage, but have some little bug haven't fix.
07:48:35 <Saizan> foldl f z [1..] = foldl f (f z 1) [2..] = foldl f (f (f z 1) 2) [3..] = foldl f (f (f (f z 1) 2) 3) [4..] = ...
07:48:48 <korstya> ManateeLazyCat: is it completed? I mean Webkit
07:49:00 <ManateeLazyCat> korstya: Almost.
07:49:08 <Saizan> @src foldr
07:49:08 <lambdabot> foldr f z []     = z
07:49:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:49:10 <Alpounet> http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=let+foldr+%3D+\f+z+xs+->+case+xs+of%0D%0A+++++[]+->+z%0D%0A+++++y:ys+->+f+y+(foldr+f+z+ys)%0D%0A++++(.)+%3D+\f+g+x+->+f+(g+x)%0D%0A++++map+%3D+\f+->+foldr+((:)+.+f)+[]%0D%0A+in+map+(2+%2B)+[3,4,5]%0D%0A
07:49:14 <Alpounet> may be of help
07:49:51 <Saizan> with foldr instead the outermost application is of "f", so if f at some point doesn't use its second argument, you don't need to expand the foldr recursion anymore
07:49:59 <ManateeLazyCat> korstya: My friend send Webkit patch to gtk2hs-devel list, but have some API haven't finish, and you need ask Axel about detail. I think he's working on it.
07:50:27 <ManateeLazyCat> korstya: I haven't test that patch, but my friend tell me that patch can work.
07:50:53 <cYmen> alright, I think I got it
07:51:00 <korstya> ManateeLazyCat: the only think I want is a web browser in a tab
07:51:04 <korstya> that's all)
07:51:12 <ManateeLazyCat> korstya: Yes, you can.
07:51:15 <cYmen> I got confused by the fact that infinite lists seem to start "on the left" and real lists "on the right"
07:51:29 <korstya> ManateeLazyCat: guys, your product is great! :-)
07:51:34 <merijn> cYmen: That's not it.
07:51:53 <ManateeLazyCat> korstya: Not me, i just helper developer.
07:51:57 <merijn> cYmen: Look at Saizan's example: "foldl f z [1..] = foldl f (f z 1) [2..] = foldl f (f (f z 1) 2) [3..] = foldl f (f (f (f z 1) 2) 3) [4..] = ..."
07:52:04 <ManateeLazyCat> korstya: You need thank Axel (the author of gtk2hs).
07:52:08 <korstya> ManateeLazyCat: you all :-)
07:52:09 <Saizan> cYmen: the first element you can access is on the left
07:52:22 <korstya> ManateeLazyCat: I will do it with a great pleasure!
07:52:35 <Saizan> cYmen: infinite lists lack a "terminator" though, which is the []
07:52:42 <merijn> cYmen: for foldl to return it needs the first item of the list PLUS the foldl of the rest. You can't compute the foldl of an infinite list
07:53:02 <ManateeLazyCat> korstya:  "gmane.comp.lang.haskell.gtk2hs"  "gmane.comp.lang.haskell.gtk2hs.devel", you can ask question in those two mail-list.
07:53:27 <merijn> cYmen: Hence the foldl can't pass the result of the foldl of the rest of the list to the initial computation
07:53:34 <Heffalump> mm_freak_: no, I'm not responsible for hackage user accounts (belatedly)
07:54:45 <ManateeLazyCat> korstya: I remember some browser team develop browser that just for embedded other program, if you can get NativeWindowId of that browser, you can embbed in gtk2hs program.
07:54:52 <korstya> ManateeLazyCat: ok! you have saved me from using the darkest side - C! really :-)
07:55:20 <cYmen> merijn: but in the definition of foldr it says foldr f z (x:xs) = f x (foldr f z xs) and the second part can never be calculated for infinite lists either
07:55:46 <ManateeLazyCat> korstya: Infact, you can embedded Webkit immediately, if you use C, if you use gtk2hs, you need wait some time.
07:56:10 <merijn> cYmen: Haskell is lazy, it only needs to compute foldr of the rest of the list if the function f looks at its second argument
07:56:15 <korstya> ManateeLazyCat: what time? to load some components you mean?
07:56:23 <ManateeLazyCat> korstya: You even can make mplayer render in your widget gtk2hs, i haven't test it.
07:57:05 <cYmen> merijn: ah..right of course
07:57:06 <ManateeLazyCat> korstya: Current, Webkit patch for gtk2hs is at harddisk of Axel, and about detail, you can ask gtk2hs mail-list.
07:57:07 <merijn> cYmen: Imagine a list of booleans and the function f implementing "or" (i.e. it returns true if it's first argument is true OR its second argument)
07:57:33 <ManateeLazyCat> korstya: Webkit patch haven't push to repository of gtk2hs.
07:57:34 <merijn> cYmen: You wouldn't need to compute the "foldr f z xs" if x was already true :)
07:58:18 <korstya> ManateeLazyCat: so I won't have a browser component or what?
07:58:26 <merijn> cYmen: If you now compare that to the foldl example of Saizan you'll see that that can't be done using foldl
07:58:41 <ManateeLazyCat> korstya: Have firefox.
08:00:09 <korstya> ManateeLazyCat: but what if user have no firefox installed?
08:00:57 <ManateeLazyCat> korstya: AFAIK, you don't need install firefox.
08:01:22 <korstya> ManateeLazyCat: oh! thats what I really need :-)
08:02:13 <ManateeLazyCat> korstya: Mozilla develop a component (or render widget) named MozEmbed, you can use it like a normal widget.
08:02:47 <korstya> ManateeLazyCat: without gtk2hs you mean?
08:03:29 <Saizan> it's still a gtk widget i think
08:03:38 <ManateeLazyCat> korstya: Example "moz <- mozEmbedNew" create a mozEmbed widget, then you just add this widget in program window. then show it. That's all.
08:03:39 <ManateeLazyCat>  
08:03:44 <Saizan> but you don't need a firefox installed
08:04:07 <ManateeLazyCat> korstya: Infact, gtk2hs just provide a Haskell-Interface for low-level C code.
08:05:05 <ManateeLazyCat> korstya: Infact, all gtk2hs code will call low-level C code, just give you Haskell style feeling.
08:05:29 <korstya> ManateeLazyCat: thank you :-) it's great!
08:06:11 <ManateeLazyCat> korstya: Please ask in gtk2hs mail-list if you have any problem about this. :)
08:06:27 <ManateeLazyCat> korstya: Have many people will help you.
08:08:33 <korstya> ManateeLazyCat: you know, haskell community is the best! IMHO :-) C++ for example have much more developers and much fewer libraries
08:09:02 <jmcarthur> c++ has tons of libraries. there just isn't a respository for them all
08:09:03 <Zao> korstya: Surely you're not implying that Haskell is better than C++?
08:09:30 <profmakx> haaa the simplification. "is better than". i love it
08:09:46 <ManateeLazyCat> korstya: And #haskell is hottest,
08:09:56 <korstya> Zao: jmcarthur: it is my opinion, thats all :-)
08:09:59 <korstya> ManateeLazyCat: :-D
08:11:20 <jmcarthur> korstya: i agree that the haskell community is the best
08:11:29 <ManateeLazyCat> korstya: Gtk2hs still need people's help to perfect.
08:11:31 <jmcarthur> never have a seen a more supportive community around a language
08:11:39 <jmcarthur> *have i
08:12:04 <korstya> jmcarthur: that's it! :-) I was a C++ developer
08:12:20 <ManateeLazyCat> jmcarthur: Just looks #haskell, you will know how hot of Haskell. :)
08:12:36 <ManateeLazyCat> korstya: Do you like Qt?
08:12:41 <korstya> ManateeLazyCat: can I be helpful
08:12:50 <korstya> ManateeLazyCat: it is much better than MFC
08:12:57 <Alpounet> heh
08:13:02 <Alpounet> you just can't compare Qt and MFC
08:13:03 <korstya> ManateeLazyCat: and much worse than wx
08:13:05 <mm_freak_> Heffalump: thanks, the problem is already resolved
08:13:05 <ManateeLazyCat> korstya: You can help qtHaskell ( a Haskell for Qt)
08:13:30 <korstya> ManateeLazyCat: I have used MFC much more :-(
08:13:39 <korstya> ManateeLazyCat: but I can still try
08:13:39 <ManateeLazyCat> korstya: Qt worse than wx? Kidding?
08:13:54 <ManateeLazyCat> korstya: I hate MFC.
08:14:01 <korstya> ManateeLazyCat: me too)
08:14:21 <ManateeLazyCat> korstya: I prefer to use Gtk+ or Qt.
08:14:22 <korstya> ManateeLazyCat: I mean it is more pleasant to use
08:14:49 <korstya> ManateeLazyCat: not more functional or smth
08:15:08 <ManateeLazyCat> Haskell will have more people knows if gtk2hs and qtHaskell perfect.
08:15:40 <ManateeLazyCat> And need more program that base on gtk2hs/qtHaskell.
08:16:11 <korstya> ManateeLazyCat: it surely will! :-)
08:16:31 <ezyang> Mmm, the Leather-Loh-Jeuring paper looks interesting
08:17:19 <ManateeLazyCat> korstya: Ask all you question on gtk2hs-list, Axel is kindness man. :)
08:17:59 <nominolo> ezyang: which one?
08:18:04 <korstya> ManateeLazyCat: By the way you are also a kindness man :-)
08:18:27 <Alpounet> ezyang, what is it about ?
08:18:54 <ezyang> http://people.cs.uu.nl/andres/Incrementalization/
08:18:56 <ManateeLazyCat> korstya: I'm a foolish, always bla, bla, bla. :)
08:19:11 <ezyang> it's about "functional incrementalization"
08:19:12 <korstya> ManateeLazyCat: but you helped me a lot!
08:19:21 <ezyang> I haven't read it thoroughly yet
08:19:31 <fax> I think "functional" really means (A -> B) -> X
08:20:00 <fax> a functional is something that takes a function
08:20:31 <manjunaths> http://shootout.alioth.debian.org/u64/performance.php?test=regexdna
08:20:43 <manjunaths> why has haskell failed miserably there ?
08:20:45 <fax> I guess it's sort of warped though
08:20:47 <ManateeLazyCat> korstya: Give your screenshot http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png , this program use gtk2hs.
08:21:44 <eldragon> is haskell's internal related to physical science ? xD
08:22:06 <korstya> ManateeLazyCat: wow! it is good! :-) I like this screenshot:-)
08:22:41 <kako_ste>  http://www.e-castig.com/index.php?r=HzkN PLEASE HELP ME WIN LAPTOP! just click on this! please!
08:22:53 <kako_ste>  http://www.e-castig.com/index.php?r=HzkN PLEASE HELP ME WIN LAPTOP! just click on this! please!
08:23:12 --- mode: ChanServ set +o Saizan
08:23:51 <ManateeLazyCat> korstya: BTW, use gtk2hs, you just need 1/10 code to build same feature of C program.
08:24:36 --- mode: Saizan set -o Saizan
08:25:35 <korstya> ManateeLazyCat: as always in haskell as. and no complicated object, inheritance, hiding, overriding blahblahblah as in cpp :-D And no more "oh where is a free call?" as in c. Or even "WTF this seg. fault means?" :-)
08:26:14 <ManateeLazyCat> korstya: Yep, gtk2hs automatically GC.
08:26:31 <monochrom> Mathematicians feared functions taking function parameters, so they invented the name "functional" as though it were different. which is absurd because what do you call things like callCC :: ((a -> m b) -> m a) -> m a, "functionalal"? "functionlolol"?
08:26:58 <ManateeLazyCat> korstya: You don't worried where to release memory, and many detail in C.
08:27:11 <amaron> korstya: But sometimes you need more time to write one line in haskell than in 10 lines on other languages. :)
08:27:37 <ManateeLazyCat> amaron: Really?
08:28:20 <korstya> ManateeLazyCat: i don't understand programmers who dislike functional languages although they haven't seen it
08:28:33 <monochrom> You need less time to write correct Haskell than correct other languages.
08:28:46 <amaron> ManateeLazyCat: It happened to me, but only when you learn some stuff. I hope it will decrease in time.
08:28:56 <fax> "Mathematicians feared functions taking function parameters" -- and rightly so!
08:29:01 <ben> You need more time to write fast Haskell than fast C :V
08:29:03 <Makoryu> korstya: They lean so heavily on local mutable state that they can't imagine not having access to it.
08:29:22 <Makoryu> ben: But less time to write correct Haskell ;)
08:29:23 <korstya> amaron: when I have just learnt about monads it was hard to write some stuff :)
08:29:43 <ManateeLazyCat> amaron: I think it's beginning when you haven't understand some stuff, but i believe you will wirte code faster and faster in Haskell.
08:29:51 <korstya> Makoryu: that must be fixed at last! :-)
08:29:58 <Makoryu> Oh wait someone already said that
08:30:00 <fax> is this useful for haskell programming? http://en.wikipedia.org/wiki/F-algebra
08:30:05 <Makoryu> >_>
08:30:20 <ManateeLazyCat> korstya: Just them don't understand Haskell yet.
08:30:21 <Makoryu> korstya: Yeah, it would be nice if other languages were as nice as Haskell
08:30:22 <monochrom> F-algebra is useful. "Maybe" is an F-algebra.
08:30:41 <ManateeLazyCat> Can make cabal use speical version of GHC?
08:31:01 <korstya> Makoryu: they write more and more complicated standarts. llok at poor Java or C++
08:31:06 <korstya> *look
08:31:19 <doserj> ManateeLazyCat: --with-compiler=
08:31:19 <roconnor> fax: very
08:31:26 <jlouis> monochrom: how do you see that?
08:32:16 <fax>  I want to know more!!
08:32:34 <fax> why we should know F-algebra?
08:32:42 <monochrom> "Maybe" is the functor. I guess you then throw in fromMaybe to get an algebra.
08:32:52 <ManateeLazyCat> doserj: Sorry, is runhaskell, but i can use some symlink for different version.
08:32:59 <Makoryu> korstya: The tragedy being that they're adding pointless complexity to languages that have a broken, inconsistent design at a lower level
08:33:04 <roconnor> @wiki Zygohistomorphic prepromorphisms
08:33:04 <lambdabot> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
08:33:06 <ManateeLazyCat> doserj: Thanks!
08:33:10 <roconnor> fax: ^^
08:33:18 <Makoryu> korstya: C++ might be the best example of this anywhere ever
08:33:21 <fax> I already know basics such as Zygohistomorphic prepromorphisms
08:33:31 <roconnor> fax: Algebra f is an F-algebra
08:33:33 <fax> Algebra f b??
08:33:44 <jlouis> monochrom: ah thanks, that is probably enough to work it out
08:33:47 <fax> @hackage category-extras
08:33:47 <lambdabot> http://hackage.haskell.org/package/category-extras
08:34:06 <fax> type Algebra  f a = f a -> a
08:34:09 <roconnor> type Algebra f a = f a -> a
08:34:12 <amaron> ManateeLazyCat: I agree with you, but I have much more trouble understanding stuff then usual.
08:34:14 <fax> hehe
08:34:42 <roconnor> well, when f is a functor, as it usually is for the operations on algebra f
08:34:44 <fax> but I find the haskell versions of these things are a bit specific compared to the category theory versions, is that not the case?
08:35:12 <roconnor> as with monad, yes
08:35:36 <ManateeLazyCat> amaron: Sometimes, Haskell make you crazy. :)
08:37:24 <fax> given a field F and an F-algebra A
08:37:29 <fax> ?? fields are not functors
08:37:29 <lambdabot>  fields are not functors
08:37:38 <roconnor> fields are not functors
08:37:48 <fax> is this a new mantra :D
08:38:09 <fax> but I am confused, this seems to have the same definition -- except they are different htings
08:38:27 <int-e> ?? ?
08:38:27 <lambdabot> Plugin `compose' failed with: Unknown command: ""
08:38:35 <korstya> ManateeLazyCat: in gtk2hs maillist it is written that mozembedded is not compilable on windows
08:38:38 <jmcarthur> ?? test
08:38:38 <lambdabot>  test
08:38:47 <roconnor> fax: what are you reading?
08:38:57 <fax> Finite groups representation theory with Coq
08:39:03 <ManateeLazyCat> korstya: You use Windows?
08:39:10 <fax> but I see F-algebra a lot these days
08:39:22 <korstya> ManateeLazyCat: it is a pity but I need to write soft for windows
08:40:06 <ManateeLazyCat> korstya: I haven't Windows for test, but i think it's should be work, but harder.
08:40:25 <korstya> ManateeLazyCat: be sure that my windows is pirated edition :-)
08:40:32 <ystael> fax: that just means A is an algebra over the field F, that is, A is a ring which is also a vector space over F.  (or did you know that already?)
08:40:50 <fax> no I didn't know that ystael
08:40:51 <korstya> http://www.haskell.org/pipermail/libraries/2005-March/003388.html
08:40:55 <ManateeLazyCat> korstya: I never use Windows long time.
08:41:17 <fax> is the category theory F-algebra the same as the representation theory F-algebra?
08:41:24 <fax> I know you can make a vector space over any field,
08:41:32 <fax> maybe /that/ is the functor?
08:41:35 <monochrom> field is rather irrelevant here
08:41:56 <Saizan> can you see a field as a functor?
08:42:13 <Saizan> however it's not like you say G-Algebra if your functor is called G
08:42:15 <ystael> fax: no.  if you're doing algebra (as opposed to haskell or category theory) "R-algebra" generally means an object which carries compatible structures of ring and R-module (if R is a field, R-vector space).  there are functors flying around, but you don't have to refer to them.
08:42:30 <roconnor> ah, right, F-algbra like C*-algebra
08:42:49 <ystael> it's just short for "algebra over the ring R"
08:44:15 <ManateeLazyCat> korstya: Sorry i can't help you on Windows, but you can ask in gtk2hs-list
08:44:31 <roconnor> fax: ya, this meaning of algebra is simply a vector space with multiplication, like the complex number are a vector space over R with multiplication.
08:44:46 <korstya> ManateeLazyCat: I think I should ask it. thanks
08:45:09 <roconnor> algebra is one of those overused words in math
08:45:15 <fax> oh okay
08:46:07 <roconnor> you can probably relate this to the categorical definition by creating a suitable signature for the functor
08:46:31 <fax> F[G] is the set {Sum(g in G) a_g * g | a_g in F}
08:46:35 <fax> is a functor ? :)
08:46:35 <ManateeLazyCat> korstya: Maybe Qt/QtHaskell will be eaiser, but QtHaskell haven't including Webkit API AFAIK.
08:47:36 <fax> perhaps ot
08:47:37 <fax> not
08:47:56 <korstya> ManateeLazyCat: in that c embedding a web browser is much more easier. it is a case when 1 line in Haskell is harder to write than 10 lines in C :-)
08:48:32 <ManateeLazyCat> korstya: If you use C, you won't need gtk2hs anymore
08:48:47 <ystael> fax: F[-] is a functor from the category of groups to the category of algebras over the field F, the "group algebra" functor, since a map h: G -> G' goes to a map H: sum a_g g |-> sum a_g h(g) and that respects the structure of F-algebra
08:49:09 <korstya> ManateeLazyCat: I don't want such a scenario! I have much code written in Haskell :-)
08:49:16 <ManateeLazyCat> korstya: IMO, gtk2hs will give you cleaner logic make you focus on important part.
08:49:32 <fax> oh yeah!
08:49:53 <korstya> ManateeLazyCat: that's it! that's why I want to make it in haskell
08:49:56 <ManateeLazyCat> korstya: But gtk2hs maybe not complete like Gtk+/C API.
08:50:57 <ManateeLazyCat> korstya: But almost important API have update to Gtk+ 2.18
08:51:29 <ManateeLazyCat> korstya: Because just few people work on it.
08:51:31 <korstya> ManateeLazyCat: but that's C!
08:51:48 <profmakx> whens the webkit stuff supposed to be finished?
08:52:01 <korstya> ManateeLazyCat: that's a great pity!
08:52:26 <ManateeLazyCat> profmakx: I don't know, you need ask Axel.
08:52:26 <benmachine> I'm sure I remember reading about applicative parsers that used the lack of context-sensitivity to do optimisations
08:52:29 <ManateeLazyCat> profmakx: I'm on work that test DBus with gtk2hs multi-processes framework.
08:52:32 <benmachine> do such things exist, and if so where can I find me one?
08:52:39 <profmakx> i am SO looking forward to that
08:52:49 <profmakx> finally my desktop will be haskellized
08:53:07 <ManateeLazyCat> profmakx: I recommand all people ask in gtk2hs-list, maybe Axel will faster. :)
08:53:27 <Berengal> benmachine: polyparse's lazy parser is only fully lazy if you use applicatives, if that counts
08:53:38 <profmakx> when tehres code to test/help/whatever i might be willing to invest time
08:53:42 <profmakx> i will see tonight
08:53:51 <ManateeLazyCat> IMO, Webkit is best browser widget for gtk2hs.
08:53:56 <Berengal> benmachine: I've read similar things myself, but that's the closest I can come to an actual library that I know of
08:53:58 <ManateeLazyCat> Simpler and faster.
08:54:39 <ManateeLazyCat> profmakx: If you really test, you can find Webkit patch in gtk2hs-devel, but you need patch it yourself.
08:54:47 <benmachine> Berengal: there seem to be quite a few things in polyparse, what do I import?
08:55:04 <ManateeLazyCat> profmakx: Webkit is patch by cjacker, my Chinese friend.
08:55:24 <Berengal> benmachine: Text.ParserCombinators.Poly.Lazy is one of the lazy parsers
08:55:31 <Saizan> Berengal, benmachine: uu-parsinglib has "online parsing" only for the applicative parts too, afaiu
08:55:50 <profmakx> i want to embed webkit into xmonad as haskell-browsing-whatever
08:55:59 <copumpkin> byorgey: do you know of a paper that makes the link between doing type arithmetic and combinatorial species, such that the diffferentiation of types to get zippers makes sense?
08:56:00 <profmakx> because neither uzbl nor vimprobable really please me
08:56:02 * benmachine pokes around in some haddocks
08:56:03 <Berengal> Saizan: "online parsing" in the stream-parsing sense?
08:56:23 <Berengal> (Which is basically what the lazy parser is doing)
08:56:32 <ManateeLazyCat> profmakx: uzbl provide standalone widget?
08:56:34 <Saizan> i guess so
08:57:07 <copumpkin> byorgey: or even the "solve for [a]" that gives you 1/(1-a) and thus a generating function of 1 + a + a^2 + a^3 ...
08:57:42 <Berengal> ManateeLazyCat: I've seen someone use xembed to put uzbl in emacs
08:57:43 <ManateeLazyCat> profmakx: If uzbl provide widget like MozEmbedded, you can use GtkSocket/GtkPlug embedded in your gui program, and not need Webkit patch for gtk2hs.
08:57:52 * benmachine gives uu-parsinglib a try
08:58:13 <ManateeLazyCat> Berengal: That's easy.
08:58:33 <ManateeLazyCat> Berengal: But problem is Emacs not multi-thread.
08:59:12 <ManateeLazyCat> Berengal: You need kill Emacs if it freeze.
08:59:19 <Berengal> ManateeLazyCat: I think it still runs uzbl as a standalone program, it just renders the window inside emacs
08:59:29 <fax> x = 1 + a * x = 1 + a * (1 + a * ...) = 1 + a + a^2 + a^3 + ...?
08:59:34 * Berengal is no expert in these things
08:59:39 <profmakx> you can always use XEmbed
08:59:55 <ManateeLazyCat> Berengal: Yep i know, use GtkSocket/GtkPlug with multi-processes framework through Xembedded protocol.
08:59:55 <copumpkin> fax: yep
09:00:03 <copumpkin> fax: know of any sources for that?
09:00:11 <fax> what do you mean? I just proved it
09:00:19 <copumpkin> well, I meant going the other way
09:00:22 <fax> getting the closed form 1/(1-a)?
09:00:39 <copumpkin> yeah, and being "allowed" to differentiate types like conor does
09:00:48 <fax> oh I don't know anything about that
09:00:50 <copumpkin> ah
09:01:01 <ManateeLazyCat> Berengal: Because Emacs is single thread, even you use outer process embedded in it, you still need use Emacs control it (send event), you need kill Emacs if Emacs other module make it freeze.
09:01:36 <Berengal> ManateeLazyCat: That's a problem with emacs, not uzbl or xembed though, right?
09:02:07 <ManateeLazyCat> Berengal: Xembedded program need multi-threaded support. Otherwise you just use *single* thread control multi-processes, still in *single-process*.
09:02:14 <ManateeLazyCat> Berengal: Yes.
09:02:27 <ManateeLazyCat> Berengal: Exactly, is problem of elisp.
09:02:40 <fax> calculus of data types.... doesn't make sense
09:02:49 <Saizan> copumpkin: i think it has to do with taylor series
09:03:12 <ManateeLazyCat> Berengal: You need one thread control render, other thread control communications or non-GUI work.
09:03:58 <ManateeLazyCat> Berengal: We can use outer processes running in Emacs, but it's nothing if Emacs is not multi-threaded.
09:05:02 * ManateeLazyCat Emacs will dead.
09:06:17 <copumpkin> Saizan: hm, ok
09:06:44 <ManateeLazyCat> korstya: Other solution, use GtkSocket/GtkPlug embedded uzbl browser.
09:07:05 <Saizan> collapsing "1 + a + a^2 + a^3 + ..." to "1/(1-x)" i mean
09:07:17 <korstya> ManateeLazyCat: does it work under Windows?
09:07:27 <fax> I think that identity is due to Newton, but I am not sure -- maybe someone can correct me
09:08:12 <ManateeLazyCat> korstya: If you can make uzbl running in Windows, i think can work.
09:08:29 <ManateeLazyCat> korstya: Only different is you need two processes running parallel.
09:08:37 <korstya> ManateeLazyCat: thank you. at least I will try
09:09:21 <copumpkin> Saizan: well I meant more along the lines of http://www.reddit.com/r/programming/comments/94iqd/exponentiation_types/c0bev1c
09:09:23 <fax> ah
09:09:37 <fax> newton did (1+x)^n, for rational n, which includes n = -1
09:09:40 <ManateeLazyCat> korstya: One process running uzbl process and GtkPlug, then run GtkSocket in your program, then make GtkPlug plug-in GtkSocket.
09:10:16 <ManateeLazyCat> korstya: Result, you can make uzbl render webpage in your program, even them running in two separate processes.
09:10:23 <korstya> ManateeLazyCat: oh not the pretties solution but it is something :-)
09:12:02 <ManateeLazyCat> korstya: Yes, you lost control of your browser, but it's enough if you just want view. And don't want develop it deeply.
09:12:14 <ManateeLazyCat> korstya: And this give your safe framework like Chrome.
09:12:44 <ManateeLazyCat> korstya: If browser crash, your main program won't crash, because them running in different processes.
09:12:46 <fax> maybe something to do with counting
09:13:02 <korstya> ManateeLazyCat: like Erlang: let it crash :-)
09:13:16 * snorble is building GHC on an eee pc.
09:14:19 <Saizan> copumpkin: ah, the basic idea is that these expressions count the elements in the respective types, i don't know enough combinatorics to understand why the derivative gives you the zipper, but cale explained it here in the past, iirc :)
09:14:22 <ManateeLazyCat> korstya: Infact, no program will avoid uncatch exception, you just need framework avoid sub-module crash all program.
09:14:57 <ManateeLazyCat> korstya: I'm on working how to integrate DBus with GtkSocket/GtkPlug to build multi-processes framework.
09:14:58 <copumpkin> Cale: aaaaagh!
09:15:03 <copumpkin> Saizan: thanks :)
09:15:20 <ManateeLazyCat> korstya: Have successful, just got damn GHC bug today. bad luck.
09:15:21 <korstya> ManateeLazyCat: you mean in gtk2hs?
09:15:28 <korstya> ManateeLazyCat: :-D
09:15:56 <ManateeLazyCat> korstya: Yep, i have write a model that integrate DBus, gtk2hs to build program like Chrome, but more.
09:16:18 <fax> |0|=0, |1|=1, |a+b|=|a|+|b|, |a*b|=|a|*|b| -- |x|=|1+a*x|=1+|a|*|x| ==> |x|-1=|a|*|x| <=> 1-1/|x|=|a| <=> |x| = 1/(1-|a|) ??
09:16:27 <fax> seem to have proved something completely false
09:16:28 <ManateeLazyCat> korstya: If Webkit patch haven't finish, i will try to use uzbl
09:17:44 <korstya> ManateeLazyCat: I believe in you, Neo! :-D
09:17:47 <fax> we know that |x| = 1/(1-|x|), it certainly is not equal to 1/(1-|a|), how can I have proven this?
09:17:53 <fax> derived this*
09:17:54 <ManateeLazyCat> korstya: http://hackage.haskell.org/trac/ghc/ticket/3918 have Main.hs that how to use DBus integrate gtk2hs to build multi-processes program, just will got GHC error sometimes,
09:18:32 <ManateeLazyCat> korstya: Main.hs is smallest model.
09:18:47 <Saizan> fax: i think |x| = 1/(1-|a|) is the right one
09:18:47 <ManateeLazyCat> korstya: If GHC team fix this bug, my model will works well.
09:18:58 <Saizan> fax: though my interpretation might be off
09:19:07 <ManateeLazyCat> korstya: You can running that Main.hs for a test.
09:19:18 <ManateeLazyCat> korstya: Then you will know how it to work.
09:19:32 <ManateeLazyCat> korstya: You need install gtk2hs, dbus-core, dbus-client first.
09:19:37 <korstya> ManateeLazyCat: I have a parse error
09:19:54 <ManateeLazyCat> korstya: What parse?
09:20:02 <korstya> ManateeLazyCat: its my fault :-)
09:20:13 <fax> oh Saizan, thank you
09:20:20 <fax> that is funny, I thought I broke math
09:20:42 <korstya> dbus is not install! ah!
09:20:57 <fax> so we have a homomorphism from (basic) types into the real numbers
09:21:01 <ManateeLazyCat> korstya: cabal install dbus-core dbus-client.
09:21:08 <ManateeLazyCat> korstya: If you at Linux.
09:21:11 <fax> it's just counting the elements
09:21:16 <fax> (totally)
09:21:19 <ManateeLazyCat> korstya: I don't know how to install cabal on Windows.
09:21:43 <copumpkin> fax: yeah
09:21:43 <fax> thinking about differentiating functions doesn't really tell us anything about the structure of types, so this may be a dead end
09:21:59 <korstya> ManateeLazyCat: quite ugly. go to rep, download it and exec runhaskell Setup.hs configure ...
09:22:24 <Saizan> fax: we know that the derivative corresponds to the zipper
09:22:35 <ManateeLazyCat> korstya: I recommand you install haskell-platform on Windows.
09:22:43 <ManateeLazyCat> korstya: Thenk you will save much work.
09:23:29 <fax> Saizan, yeah you can verify that by cases but I think we want to explain why ?
09:23:33 <ManateeLazyCat> korstya: If you can make cabal works, rest is easy.
09:23:49 <Saizan> fax: ah, yeah
09:24:14 <copumpkin> I don't think conor's paper on it actually explains why it works
09:24:21 <Saizan> i think taking the derivative of a generating serie is a wellknown technique in combinatorics
09:24:34 <copumpkin> yeah, you can do it with species apparnetly
09:24:42 <copumpkin> but I'm missing the link between types and species
09:24:52 <korstya> ManateeLazyCat: it is a fatality! dbus is dependent on unix package which is not portable... God damn Windows!
09:24:59 <fax> species are pretty much exactly the same as types...?
09:25:07 <copumpkin> fax: ah, really
09:25:16 * copumpkin is a mathematical newbie so I'm just trying to find out :)
09:25:18 <ManateeLazyCat> korstya: Oh, no.
09:25:27 <korstya> ManateeLazyCat: :-D
09:25:37 <korstya> ManateeLazyCat: today it's not my day
09:25:38 <fax> http://en.wikiversity.org/wiki/Calculus_of_generating_functions
09:25:46 <Saizan> the species i've seen were a generalization of the usual algebraic types
09:25:54 <copumpkin> I've worked a bit on generating functions before
09:26:07 <copumpkin> I guess not in depth enough to see the connection, though
09:26:14 <copumpkin> thanks fax
09:26:38 <fax> this does not settle the question but it's nice anyway
09:26:40 <ManateeLazyCat> korstya: :) Don't lose heart, always have a way for you.
09:26:57 <Saizan> well 1/(1-a) is the generating function for permutations, right?
09:27:09 * ManateeLazyCat Every doy has his day.
09:27:14 <copumpkin> edwardk_: omg you're running GSOC this year?
09:27:20 * ManateeLazyCat Every dog has his day.
09:27:23 <copumpkin> woof
09:28:23 <korstya> ManateeLazyCat: at last I have COM :-)
09:29:01 <ManateeLazyCat> korstya: I'm reading uzbl, maybe i will give you screenshot that how to use gtk2hs running webkit browser in it.
09:29:37 <korstya> ManateeLazyCat: I will be very thankful for that! :-)
09:30:41 * ManateeLazyCat Git uzbl...
09:31:02 <byorgey> hmm, what was the question about species/generating functions/etc.?
09:31:36 <blueonyx> ya, what species you were talking about?
09:32:31 <copumpkin> byorgey: mostly how zippers end up appearing from differentiation of types and why differentiation even makes sense
09:32:42 <copumpkin> and whether you have any sources on the link between species and types
09:34:21 <fax> thing is,
09:34:26 <fax> generating functions just count
09:35:28 <fax> maybe we have to count zippers for a while, to see it
09:36:02 <byorgey> no, differentiating makes sense without resorting to counting, if you think about it combinatorially
09:36:46 <byorgey> If F is a species/type constructor, then F' is the species/type constructor which builds structures with a distinguished element, i.e. a "hole"
09:37:36 <fax> ah
09:37:40 <jmcarthur> gah, you can't use the pure gcc attribute on functions that do anything on the heap even if it's something that would be cosidered pure in haskell :\  i just realized that
09:37:43 <copumpkin> yeah, I've seen that "work", but but don't fully understand why that works
09:37:48 <fax> so the in the series you have ... + a_n*x^n + ...
09:37:49 <byorgey> and if you think about how this operator interacts which each of the other primitive types + type constructors (unit, sum, product, etc.) you can prove to yourself that the same laws hold (up to isomorphism) as you would expect to hold for differentiation
09:37:49 <jmcarthur> due to memory management, etc.
09:37:57 <jmcarthur> *considered
09:38:31 <fax> and punching a hole in it, means you remove one of the elements (a_n*a^(n-1)) but you also have to say which one was removed (*n) so that gives n*a_n*x^(n-1)!
09:38:33 <byorgey> I don't know if I can explain "why" this happens at a deeper level, it still seems pretty magical to me =)
09:38:41 <fax> I think you did explain it byorgey!
09:38:41 <byorgey> fax: yes, exactly =)
09:39:19 <jmcarthur> i was going to see about using pure as much as i possibly could in my C code at work, but i can't find a single function to stick it on :(
09:39:35 <byorgey> fax: what you've done there is the proof for unlabelled, regular species (which is what we usually think about in CS) but it holds for more general combinatorial structures too
09:39:57 <copumpkin> byorgey: any papers on this connection? :) I'd like to add a citation to my class paper on this magical phenomenon
09:40:12 <byorgey> copumpkin: well, I'm writing one at the moment ;)
09:40:14 <copumpkin> ooh
09:40:39 <copumpkin> [As-yet unpublished work by Brent Yorgey, exists y. y >= 2010]
09:40:43 <byorgey> but let's see... I mean, for differentiation there are some papers by Conor McBride you can cite of course
09:40:48 <byorgey> hehe
09:40:48 <copumpkin> I guess I'll settle for conor's papers for now
09:40:49 <copumpkin> yeah
09:41:00 <copumpkin> :)
09:41:06 <byorgey> unfortunately there aren't yet a lot of papers explaining the connection in more detail from a CS point of view
09:41:17 <copumpkin> ah well, I'll live :)
09:41:28 <byorgey> which is a big part of why I'm writing one, explaining my combinatorial species library
09:42:06 <fax> what I am curious about, is what does category theory have to say on this?
09:42:13 <fax> but maybe I would have to learn french first
09:42:19 <byorgey> fax: lots!
09:42:33 <byorgey> hehe, no, there is an English translation of "Combinatorial Species and Tree-Like Structures"
09:42:42 <byorgey> by Bergeron, Labelle, and Leroux
09:42:53 <copumpkin> the derivative of an arbitrary coproduct :P
09:42:56 <copumpkin> or product
09:43:22 <copumpkin> seems unlikely
09:43:44 <byorgey> fax: formally, a species is defined to be a functor from the category of sets with bijections as arrows (these are the labels, and the bijections mean you can relabel things any way you want) to the category of sets (the structures you build out of the labels)
09:44:01 <byorgey> I don't know if that makes sense when I say it in one sentence like that =)
09:44:02 <copumpkin> oh, cool
09:44:16 <fax> no that does make sense (but I have already read your blog about this too)
09:44:27 <byorgey> and if you look at functors into categories other than Set you get interesting things too
09:44:42 <fax> and today I read about faithful/full functors
09:44:54 <byorgey> like if you do sets with a linear ordering relation and the arrows are order-preserving functions
09:45:11 <byorgey> you can talk about orderings among the labels, which is really what we usually have with data structures
09:45:19 <byorgey> built over some ordered type
09:45:25 <fax> the category of posets??
09:45:34 <ezyang> fax: Yup
09:45:38 <byorgey> maybe you could do posets too
09:45:50 <byorgey> I was just talking about *linear* orders
09:45:52 <fax> ahh
09:46:07 <Saizan> total rather than partial :)
09:46:15 <byorgey> indeed =)
09:46:16 <fax> toesets? :)
09:46:20 <byorgey> hahaha
09:46:49 <dons> i feel conflicted that the SQL extensions to list comps are called "Generalised list comprehensions"
09:46:50 <ezyang> Saizan: ah
09:47:27 <copumpkin> dons: I agree
09:47:36 <copumpkin> or rather, I can feel the conflict :P
09:47:40 <fax> you know one thing is buggin me about the generating functions
09:48:00 <copumpkin> dons: they also didn't give us arbitrary joins!
09:48:10 <fax> it seems like they don't have to converge, so we can use the identity 1/(1-x) = ... even when x > 1
09:48:14 <fax> >= 1
09:48:20 <byorgey> fax: that's correct.
09:48:21 <fax> but that's odd..
09:48:50 <byorgey> fax: it can all be justified rigorously... but the basic idea is that since we're just using x as a formal parameter, we don't really care about convergence
09:48:51 <dons> copumpkin: and it's not like we can actually overload them to generate SQL statements
09:48:57 <dons> afaik. which would actually be useful.
09:48:59 <copumpkin> yeah
09:49:07 <copumpkin> LINQ stole from us, now let's steal back :)
09:49:10 <byorgey> and we use things like 1/(1 - x) just as a "shorthand" for 1 + x + x^2 + x^3 + ...
09:49:21 <fax> ah!
09:49:23 <ezyang> dons: They tossed out monadic list comprehensions a while back, didn't they?
09:49:27 <fax> so it's a white lie :)
09:49:36 <byorgey> and you can prove that all the normal power set operations work exactly as expected on these "abbreviations"
09:49:51 <byorgey> basically it just gives us a powerful, compact way to manipulate infinite lists of integers
09:50:03 <fax> what is a power set operation?
09:50:10 <Saizan> another point is that if you look at the expansion 1 + x + x^2 + x^3 + .. you know by looking at the exponent which addend is counting the elements with that many x's
09:50:15 <byorgey> you know, like addition, multiplication, composition...
09:50:15 <dons> ezyang: yep. 12 years ago
09:50:20 <fax> byorgey sounds very haskelly indeede!
09:50:54 <ezyang> dons: Wow. How time flies. :-)
09:51:03 <fax> I don't htink I have ever heard of 'power set operation'
09:51:26 <byorgey> oh, whoops, did I say "power set operation"?  I meant "power series operation" =)
09:51:48 <fax> okay
09:51:50 <byorgey> operations in the ring of formal power series.
09:52:48 <byorgey> so you can prove, e.g., that if f(x) and g(x) are expressions that "expand" to power series then f(x) + g(x) will "expand" to the power series which is the elementwise sum of the expansions of f(x) and g(x)
09:53:00 <fax> *nod*
09:53:04 <byorgey> and you can prove something similar for multiplication, differentiation, etc.
09:53:21 <ezyang> fax: search "squinting at power series" for a paper that talks about this
09:53:29 <fax> okay
09:55:50 <byorgey> heh, that paper looks like it was from before McIlroy discovered Haskell =)
09:56:16 <byorgey> no need to implement all those streams and channels etc. when you have a lazy graph-reducing runtime =)
09:56:44 <ezyang> byorgey: Yup!
09:57:02 <ezyang> Yum yum laziness
09:57:06 <byorgey> ezyang: and I'm not sure I see where that paper talks about using expressions like 1/(1-x) to represent power series?
09:57:28 <ezyang> I don't think he talks about that. Just about the ability to use streams to calculate results of power series "lazily"
09:57:40 <ezyang> There might be a better paper, if so please share :-)
09:58:34 <edwardk_> copumpkin: yeah
09:58:41 <copumpkin> cool :)
09:58:45 <byorgey> oh, ok.  fax was asking about why we can use "non-converging" things like 1/(1-x) to represent power series
09:59:10 <jmcarthur> the new patch editing in darcs 2.4 scratches an itch that i've had for a long time since i switched back to darcs from git
09:59:18 <jmcarthur> *hunk editing
09:59:20 <edwardk_> copumpkin: was the post coherent, i didn't get much of a chance to proofread it before sending it out.
09:59:37 <byorgey> a formal treatment of that might be in generatingfunctionology but I'm not sure
10:00:15 <copumpkin> edwardk: yep, looks fine!
10:00:30 <edwardk> byorgey: generatingfunctionology covers it, but its not very formal ;)
10:00:37 <byorgey> edwardk: ah, ok.
10:00:47 <aavogt> it wasn't immediately clear for me how to use the hunk editing... some experimenting turned out better than trying to understand the description
10:00:51 <edwardk> byorgey: i have a bunch of notes from a classical analysis class somewhere that described why it was okay though
10:01:20 <edwardk> byorgey: i should translate them and put them online some time, i went out of my way to write up the notes for that class like a book
10:01:33 <byorgey> yeah, personally I've been happy just to take it on faith, backed up by never seeing it fail to work =)
10:01:45 <byorgey> edwardk: but I'd love to see your notes if you put them up
10:02:20 <ezyang> generatingfunctionology looks fascinating
10:02:27 <byorgey> ok, I'm off to spend some time with my wife, if there are any more discussions of species and generating functions please ping me =)
10:02:30 <edwardk> byorgey: there is a proof that if your formal power series has a finite radius of convergence then if you went the same path with normal power series, and avoided using all of the extensions it gives, that the actual power series would have the same radius of convergence
10:02:40 <ezyang> if only I wasn't already working through another math textbook
10:03:02 <edwardk> byorgey: it was pretty much the first thing we proved before working with formal power series
10:03:21 <edwardk> ezyang: generatingfunctionology has the benefit of being very very short ;)
10:04:49 <fax> classical analysis?
10:05:02 <fax> I thought thta was just l'hopitals rule
10:06:50 * hackagebot GPipe 1.2.0 - A functional graphics API for programmable GPUs  http://hackage.haskell.org/package/GPipe-1.2.0 (TobiasBexelius)
10:07:49 <edwardk> fax: one of my favorite professors decided to do a course covering a bunch of the stuff that tends to fall between the cracks, because it is harder than real analysis but doesn't need all of the machinery of say, Lesbegue measure, etc. he covered generating functions, stirling's approximation, etc.
10:08:31 <cYmen> I just wrote this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23925#a23925 comments about everything are appreciated but I'm mostly interested in what the scope of those "where" definitions is and if there is a style guide or something that tells me how to indent
10:09:06 <edwardk> basically, just a bunch of stuff that could be proven with the machinery available back in gauss'/euler's time
10:10:45 <edwardk> preflex: xseen dons
10:10:45 <preflex>  dons was last seen on freenode/#haskell 20 minutes and 30 seconds ago, saying: ezyang: yep. 12 years ago
10:12:30 <Saizan> cYmen: the scope is the right hand side associated with that clause of the function
10:12:55 <edwardk> @tell dons can you take a look at the summer-of-code trac? people can't seem to register as new users
10:12:56 <lambdabot> Consider it noted.
10:12:56 <Saizan> cYmen: neg can be written as "fmap negate"
10:13:00 <Saizan> @src Either fmap
10:13:01 <lambdabot> fmap _ (Left x) = Left x
10:13:01 <lambdabot> fmap f (Right y) = Right (f y)
10:17:59 <copumpkin> differentiating types seems to not deal perfectly with laziness (codata in general?) though
10:18:23 <copumpkin> if the derivative of [a] is [a] x [a], we can actually get a list zipper that is infinite in both directions
10:18:47 <copumpkin> but I guess everything works nicely if we keep it finite
10:19:28 <jmcarthur> whenever i see [a] a [a], i think brainfuck
10:19:43 <burp> is there no repeatM or am I missing something?
10:19:49 <fax> burp replicateM
10:19:49 <copumpkin> burp: nope, there isn't one
10:19:56 <fax> oh
10:20:02 <edwardk> copumpkin: yeah, you need to be more careful. what you need is a representation that permits both data and codata, then you can have a derivative of a codata [a] be a data [a] x codata [a]
10:20:04 <jmcarthur> :t repeat
10:20:08 <lambdabot> forall a. a -> [a]
10:20:18 <edwardk> copumpkin: that works perfectly fine when building zippers in coq ;)
10:20:34 <copumpkin> edwardk: ah, that makes sense. how do you justify one being data and the other being codata?
10:20:35 <jmcarthur> oh nice
10:20:37 <fax> edwardk, this has been done ?
10:20:40 <copumpkin> just because it's necessary?
10:20:46 <zygoloid> copumpkin: the derivative of [a] is something like data List' a = Here [a] | After a (List' a). that looks lazy enough to me?
10:21:13 <zygoloid> copumpkin: whereas [a] x [a] is too big a type; the 'earlier' list for a list zipper can never be infinite
10:21:14 <fax> edwardk oh sorry I get what you were saying
10:21:35 <edwardk> copumpkin: the only way you could get codata on the left from an actual list would be to have taken an infinite number of steps in the first place.
10:22:13 <edwardk> copumpkin: any 'path' like portion of the zipper will turn out to be data, if you want to be able to sew it back up and get a structure in finite time.
10:22:46 <copumpkin> edwardk: yeah, from a pragmatic point of view I can see it, but if we consider differentiation on its own, how does one integrate the notion of data and codata into it? we can talk about the derivative of x^3 + x^2 but it seems hard to attach (co)data tags to that
10:22:58 <copumpkin> (where x is a type)
10:23:17 <burp> repeatM x = xs where xs = x:xs and then using sequence on it, why does it not work as "repeatM"?
10:23:18 <edwardk> copumpkin: easy to prove, the zipper of [a] being [a] x [a] -- is an approximation after all. if you go back and derive it step by step using the derivative you'll see the path term that you then induct on to get the list.
10:23:33 <misk20> how can i read int values from file ?
10:23:49 <copumpkin> edwardk: hmm, ok
10:24:06 <zygoloid> Lx = 1 + x.Lx => dL/dx = 1.Lx + x.dL/dx
10:24:14 <zygoloid> copumpkin: ^^ this is where i got my List' from
10:24:19 <fax> copumpkin, all the reasoning we did earlier (using generating series and counting) was on natural numbers (well.. real numbers but mostly natural ones) so yeah that doesn't cover anything infinite -- and totality was assumed too
10:24:30 <edwardk> copumpkin: you get [a] x [a] by being sort of glib about rewriting it.
10:24:32 <copumpkin> fax: yeah, makes sense, I see
10:24:40 <burp> @let repeatM :: (Monad m) => m a -> [m a]; repeatM x = xs where xs = x:xs
10:24:41 <lambdabot>  <local>:3:38:
10:24:41 <lambdabot>      Multiple declarations of `L.repeatM'
10:24:41 <lambdabot>      Declared at: <l...
10:24:47 <copumpkin> edwardk: but it's super cute that way! :P
10:24:50 <burp> @let repeatM2 :: (Monad m) => m a -> [m a]; repeatM x = xs where xs = x:xs
10:24:51 <lambdabot>  <local>:3:0:
10:24:51 <lambdabot>      The type signature for `repeatM2' lacks an accompanying bi...
10:25:02 <Saizan> ?type sequence . repeat
10:25:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:25:08 <burp> oh right
10:25:10 <Saizan> not so useful though
10:25:14 <copumpkin> sadly
10:25:25 <edwardk> copumpkin: i agree, it has the right generating function after all, but those generating functions don't consider infinite cases.
10:25:32 <fax> copumkin, my guess would be that you can probably work infinity into it using nonstandard analysis (maybe!) but partiality will probably kill all the nice algebraic properties
10:25:32 <copumpkin> yeah
10:25:36 <Saizan> there aren't many monads whose >>= is lazy enough to let that terminate
10:25:39 <copumpkin> we need to extend generating functions!
10:25:48 <copumpkin> fax: ah :(
10:26:14 <zygoloid> > (sequence . repeat $ id) 42
10:26:16 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
10:26:32 <edwardk> copumpkin: i do have a multivariate generating function model for codata.
10:26:39 <copumpkin> :o
10:26:51 <zygoloid> > runState (sequence . repeat $ State (\x -> (x,x+1))) 0
10:26:52 <lambdabot>   ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
10:27:02 <fax> wow how does that work?
10:27:08 <fax> the multivariate thing
10:28:43 <edwardk> fax: i have my notes on it at home, but it came down to counting possible productive consumptions of the codata that involve a given number of steps
10:28:59 <fax> hmm
10:29:18 <edwardk> fax: sorry if that is a bit vague, its been a couple of years since i looked at it
10:29:33 <burp> <Saizan> there aren't many monads whose >>= is lazy enough to let that terminate â† seems the MC monad from monte-carlo isn't lazy on  sequence . repeat
10:30:09 <burp> "sequence . repeat $ flipCoin" doesn't terminate.. if I then run replicateM 1000 flipCoin I guess it actually builds the list with 1000 values
10:30:13 <edwardk> fax: you can model 'infinite tree structures' with that as a generating function, but if those tree structures have possible 'nil' nodes, you need to do more. that was were it became multivariate
10:30:13 <burp> instead of just using it lazy
10:30:27 <edwardk> er where
10:35:15 <ManateeLazyCat> korstya: One browser need how many lines ?
10:35:40 <ManateeLazyCat> korstya: Still threre?
10:36:40 <ManateeLazyCat> http://farm5.static.flickr.com/4036/4426992557_2cec005a32_o.png
10:36:58 <ManateeLazyCat> korstya: See above, i use 29 lines gtk2hs code develop a browser.
10:37:04 <ManateeLazyCat> korstya: Base on Webkit.
10:37:56 * ManateeLazyCat pasted "Uzbl-Gtk2hs.hs" at http://paste2.org/get/713834
10:38:15 <ManateeLazyCat> korstya: Above is source code.
10:39:08 <ManateeLazyCat> If you have install uzbl, just compile above code, you will got program like my screenshot.
10:41:24 <joejacobs> hey guys i need some help with random number generation. sorry if it's a bit dumb i'm new to haskell (this morning). this is what i've tried so far but it won't work. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23928#a23928 any ideas what I should be doing?
10:41:28 <Dementati> How would I go about printing an arbitrary precision rational in decimal point form?
10:41:52 <fax> Dementati: divison algorithm
10:42:02 * ManateeLazyCat Damn GHC bug block my step....
10:42:30 <monochrom> use realToFrac to convert rational to CReal, then print
10:42:51 <fax> :t randomIO(0, 9)
10:42:52 <lambdabot>     Couldn't match expected type `(t1, t2) -> t'
10:42:52 <lambdabot>            against inferred type `IO a'
10:42:52 <lambdabot>     In the expression: randomIO (0, 9)
10:44:08 <jlouis> joejacobs: one way is to build an infinite list of random numbers and then use the 'take' function to pick off 4 of those
10:45:13 <not_nathan> Has anyone tried to make an account on the Summer of Code TRAC today?
10:45:46 <joejacobs> jlouis: that's what i attempted but i'm getting an error whenever i try to store it in a list  "Couldn't match expected type `(t1, t2) -> [t]'
10:45:46 <joejacobs>            against inferred type `IO a'"
10:45:56 <edwardk> not_nathan: it seems to be broken. =/
10:46:15 <edwardk> not_nathan: Igloo apparently took a look at fixing the sign up form, but to no avail.
10:46:25 <edwardk> i left a @tell for dons, but haven't seen him yet
10:47:12 <jmcarthur> joejacobs: try doing it without the list comprehension and it might come to you (this is not something you can use a list comprehension for)
10:47:13 <not_nathan> edwardk : That's a shame.
10:47:33 <jlouis> joejacobs: it is because randomIO has side effects, so it returns something of type IO a
10:47:41 <edwardk> not_nathan: yeah. i saw that the registration link had been fixed at least, but apparently, not the form itself
10:48:04 <edwardk> the former was my motivation for actually sending out the big 'go team' email ;)
10:48:14 <edwardk> if you want, i'll happily add you to the People2010 page
10:48:17 <joejacobs> jmcarthur: ok i'll try that. thanks
10:48:31 <not_nathan> edwardk : that would be great!
10:48:50 <joejacobs> jlouis: thanks
10:49:08 <jmcarthur> :t randomIO
10:49:10 <lambdabot> forall a. (Random a) => IO a
10:49:22 <jmcarthur> that another issue. randomIO doesn't take parameters
10:49:31 <jmcarthur> :t randomRIO
10:49:32 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:49:36 <jmcarthur> is what i think you mean
10:50:05 <joejacobs> ok i'll try using that instead
10:50:18 <jlouis> joejacobs: you could use randomRIO and then use the replicateM function from Control.Monad
10:50:30 <jmcarthur> :t replicateM
10:50:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:50:42 <jmcarthur> :t replicateM 4 $ randomRIO (0,9)
10:50:43 <lambdabot> forall a. (Num a, Random a) => IO [a]
10:50:54 <jlouis> the suffix M suggests it works for any monad, of which IO is one
10:51:31 <jlouis> in a certain sense it does the same thing as 'replicate', just running the monad computation as well
10:51:48 <jmcarthur> @src replicateM
10:51:48 <lambdabot> replicateM n x = sequence (replicate n x)
10:51:52 <ksf> :t join
10:51:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:51:56 <jmcarthur> :t sequence
10:51:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:52:03 <jmcarthur> @src sequence
10:52:03 <lambdabot> sequence []     = return []
10:52:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:52:04 <lambdabot> --OR
10:52:04 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:53:49 <joejacobs> ok system overload...i'm gonna try and make sense of all that. i'll come back if I still don't get it. thanks for the help guys!
10:56:31 <Ke> btw while there ~will be llvm support in ghc, will there be cross-compiling support
10:59:37 <pikhq> Ke: "Maybe".
11:00:06 <ksf> there's still questions to be adressed in the build system, and how to deal with those .hsc files
11:00:33 <pshc_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23930#a23931 have I reached Control.Monad par here or is there more golfing I can do? :)
11:00:56 <ksf> the line between host and target isn't well-fledged out atm.
11:01:24 <pikhq> pshc_: Needs more arrows.
11:01:32 <pshc_> Oho.
11:01:34 <copumpkin> pshc_: is that generating all strings accepted by a DFA?
11:01:42 <pshc_> yeep
11:01:45 <copumpkin> nice :)
11:02:21 <copumpkin> pshc_: I'd use a list comp for your liftM2 (,) >> guard
11:02:32 <pshc_> I never write code like this... hell my use of "join" was a guess
11:02:33 <copumpkin> that entire do could be a one-line list comp
11:02:35 <ksf> There's going to be quite some busyness in the near future prototyping all those things llvm enables us to do cheaply.
11:02:49 <pshc_> yeah it was copumpkin
11:03:10 <ksf> "This shouldn't be too surprising, though, as >> isn't the binary operation of some monoid: the algebraic properties of join are very close to those of + and incidentally, join is also the operation true category theorists tend to work with. They also know of bind, but don't use it a lot because, unlike programmers, they don't do any actual productive work. "
11:03:17 <ksf> please don't tell me I got that horribly wrong.
11:03:18 <pshc_> Just fooling around trying to get more comfortable with the List monad :)
11:03:25 <ksf> http://www.haskell.org/haskellwiki/What_a_Monad_is_not
11:03:32 <ksf> (at the bottom)
11:04:10 <copumpkin> ksf: well, bind is related to something called the kleisli category of a monad
11:05:21 <ksf> ...the context is explaining why commutativity for a monad doesn't mean   (Just 2 >> Just 3) == (Just 3 >> Just 2)
11:06:16 <edwardk> ksf: associativity
11:06:31 <edwardk> ksf: and it means (a >=> b) >=> c ~ a >=> (b >=> c)
11:09:02 <cYmen> @src groupBy
11:09:02 <lambdabot> groupBy _  []       =  []
11:09:03 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:09:03 <lambdabot>     where (ys,zs) = span (eq x) xs
11:09:27 <monochrom> I haven't heard of commutativity for a monad.
11:09:37 <scotd> so monads are a result of the fact that every variable can only be assigned once? monads are like a variable with a counter applied to it, so it is unique?
11:09:41 <cYmen> @src span
11:09:42 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:09:51 <scotd> i understand monads are complicated... just looking for the essence
11:10:07 <monochrom> you haven't found the essence
11:10:19 <ManateeLazyCat> scotd: Monad is not complicated :)
11:10:21 <scotd> bummer :-)
11:10:24 <copumpkin> monochrom: there's a talk by dan piponi on that
11:10:35 * |ManateeLazyCat|
11:10:38 <copumpkin> monochrom: http://vimeo.com/6590617
11:10:43 <copumpkin> it's a good talk
11:11:01 * |ManateeLazyCat| It's me in kvirc.
11:11:58 <[swift]> i've noticed a lot of the builtin haskell modules have names like Text.Whatever.Blah. how do i go about organizing my own modules in this manner? do i just name the module in this fashion or do i have to construct a directory hierarchy like Java?
11:12:10 <shapr> Just name it.
11:12:20 <[swift]> gotcha, thanks!
11:12:24 <shapr> I think the directory hierarchy was supported at one point, but I think it got yanked?
11:12:58 <[swift]> it'd be nice to have the directory hierarchy as an option, i have to say
11:12:59 <scotd> ManateeLazyCat, are you a monad?
11:13:06 <sepp2k> @pl \x -> f x && g x
11:13:07 <lambdabot> liftM2 (&&) f g
11:13:14 <BONUS> i usually still put them in a directory hierarchy
11:13:17 <BONUS> it doesn't hurt
11:13:22 <ManateeLazyCat> scotd: No, because i'm not pure.
11:13:27 <shapr> BONUS: So it does still work?
11:13:31 <BONUS> yeah
11:13:40 <BONUS> last time i tried it
11:13:43 <[swift]> BONUS: cool, thanks! i'll try that out
11:13:45 <shapr> Awright then
11:15:05 <scotd> ManateeLazyCat, so they are just so IO doesn't muck up the type system?
11:16:09 <ManateeLazyCat> scotd: You can monad like a box.
11:16:29 <ManateeLazyCat> scotd: In Box, everything is pure.
11:16:59 <ksf> EDWARDK HOW DID YOU MANAGE TO CRASH MY BOX
11:17:25 <ManateeLazyCat> scotd: Moand like box set bound pure-code between dirty-code....
11:17:35 <int-e> ksf:  ... gravity? :-)
11:17:39 <ksf> first it didn't want to boot into graphics bios, then refused to boot into grub, then linux refused to uncompress itself
11:17:44 <scotd> ManateeLazyCat, thanks
11:18:04 <ksf> then I booted an old kernel and fscked the boot partition, now it uncompresses, again.
11:18:11 <ManateeLazyCat> scotd: You can use Monad do many high-level thinking.
11:18:53 <ksf> the _really_ scary thing being that I didn't have the boot partition mounted
11:18:57 <aavogt> shapr: so it works to call the file   Text.Whatever.Blah.hs?
11:19:02 <urv> hi all - how can i make the head of a lazy list strict?
11:19:17 <ManateeLazyCat> scotd: Haskell not mean everything is code, it's try to use Monad set bound between pure code and dirty code, and limit non-pure in very little space.
11:19:25 <aavogt> urv: what about the head of the tail of that list?
11:19:27 <shapr> aavogt: I dunno, try it!
11:19:30 <scotd> ManateeLazyCat, i'm with you now
11:19:32 <ManateeLazyCat> scotd: Then you just need care those non-pure code.
11:20:01 <aavogt> urv: as in what are you trying to accomplish anyways?
11:20:14 <ManateeLazyCat> scotd: If you just have pure code, you can't do anything.
11:20:45 <ManateeLazyCat> not mean everything is pure code.
11:21:09 * ManateeLazyCat Sorry English-Helper is slower than finger....
11:21:16 <urv> aavogt: well i have a problem with memory, when the head of the list is not stricted than it consumes more and more memory
11:21:30 <edwardk> ksf: that is a very good question. must be my 1337 haxx0ring skills
11:21:35 <scotd> ManateeLazyCat, right, allows IO while keeping rest of code pure
11:21:45 <ksf> ...where ManateeLazyCat currently uses "pure" in its haskellish colloquial definition, not the purely mathematical sense
11:21:58 <aavogt> shapr: it doesn't work for me
11:22:30 <ksf> edwardk, care to make the what's a monad not - page more mathematically intimidating?
11:23:05 <copumpkin> ksf: a worthy goal indeed
11:23:10 <shapr> aavogt: What about Text.Whatever.Blah ? How are you calling it?
11:23:27 <ksf> =)
11:23:58 <edwardk> ksf: i don't like beating people up with math, more gently introducing them to things that are just one step beyond their current comprehension to get them to struggle harder
11:24:09 <aavogt> shapr: module Main where { import A.B; main = return () } -- ghc looks for A.B in A/B.hs or A/B.lhs
11:24:22 <scotd> I'm reading "A History of Haskell" and noticed that Clean uses uniqueness types while Haskell uses monads, but both seem to be based on idea of generating a new variable for every IO occurence
11:24:29 <ksf> the idea is to deconstruct all false assumption and scatter enough haha-only-serious jokes throughout the rebuttals so that the reader can piece together a mathematical understanding of monads from them.
11:24:37 <aavogt> it completely misses the file A.B.hs
11:24:37 <monochrom> give an explicit construction of a group of order 255. prove that it is not a monad.
11:24:50 <shapr> aavogt: Nifty
11:24:55 <shapr> aavogt: Now I know :-)
11:25:01 <shapr> I was convinced that worked...
11:25:04 <aavogt> has it ever worked?
11:25:04 <shapr> I dunno
11:25:14 <shapr> I guess not :_)
11:25:26 <aavogt> before hierarchial modules, . was illegal, right?
11:25:31 <Saizan> scotd: are you referring to the World -> (a, World) description of IO?
11:25:48 <ManateeLazyCat> How to leave message through lambdabot? I forgot again.... :)
11:25:56 <Saizan> scotd: in haskell that's either a broken analogy or an implementation hack
11:25:57 <aavogt> @tell ManateeLazyCat like this
11:25:57 <lambdabot> Consider it noted.
11:26:42 <ksf> ...and I'm admittedly completely at a loss on how I should understand lax functors and terminal bicategories in terms of a monad.
11:27:29 <ManateeLazyCat> @tell korstya See http://paste2.org/get/713834 , source code you need to develop Webkit browser with gtk2hs, you need install uzbl first to compile this program, i think this solution can works on Windows. Bye, i need off now. :)
11:27:30 <lambdabot> Consider it noted.
11:27:57 <ManateeLazyCat> aavogt: Thanks.
11:27:57 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
11:28:26 <FliPPeh> How'd I give a type to a lambda function? "`catch` (\e -> return $ error $ "Exception: " ++ (show e))" doesn't like the e in there, and I want to have it return "IO ()"
11:28:47 <ksf> \(e :: SomeException) ->
11:29:07 <ksf> {-# LANGUGAGE ScopedTypeSignatures #-}
11:29:08 <pikhq> FliPPeh: You give a type to its argument if needed and a type to the result value if needed.
11:29:14 <ksf> ...or something of that ilk.
11:29:32 <aavogt> without extensions, you can accomplish the same using:   \(SomeException e) ->
11:29:32 <Saizan> \(SomeException e) ->
11:29:36 <scotd> saizan, here is the quote: "In Haskell, lacking reference cells, you would probably arrange that each function that must generate fresh names accepts an old value of the counter and returns an updated value of the counter. This is straightforward but tedious, and errors are easily introduced by misspelling one of the names used to pass the current count in to or out of a function application. Using a state transformer monad would let you
11:29:36 <scotd> hide all the â€œplumbing.â€ The monad itself would be responsible for passing counter values, so there is no chance to misspell the associated names."
11:29:57 <pikhq> Or just: ((\e -> ...) :: SomeException -> IO ())
11:30:16 <aavogt> scotd: reference cells are not absent, they are just not used much
11:30:35 <aavogt> @docs Data.IORef
11:30:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
11:31:07 <Saizan> scotd: right, monads can be used to abstract away how you pass the counter around, that's the State Counter monad, but it's a very specific instance of them
11:31:17 <monochrom> Oh screw the technicality. Rewrite it as "In Haskell, without using reference cells" if you like.
11:31:25 <Saizan> scotd: you've to look at more examples to grasp the whole story
11:32:04 <deech`> Hi all, I am trying to install the haskelldb-hsql-sqlite3 package and I get an error saying :  "Could not find module `System.Time': it is a member of the hidden package `old-time-1.0.0.2'". Other people seem to have this issue but Googling found no solution. Can anyone help?
11:32:16 <scotd> ok, so i'm confused, because i thought the counter was part of the implementation of monads, but that article is using them as an example, not as an implementation description for all monads
11:32:34 <ManateeLazyCat> scotd: State Transformer give your environment that just need `get` or `set` and don't need write *variable* name.
11:32:39 <scotd> i mean... i was confused, am not now :-)
11:32:39 <Saizan> scotd: it's not part of the implementation of monads.
11:32:46 <Saizan> ah, ok :)
11:32:51 <ManateeLazyCat> scotd: But for beginning, you can read IORef.
11:33:06 <Dementati> monochrom: Thanks, that worked.
11:33:45 <monochrom> neato
11:33:51 <ManateeLazyCat> scotd: IMO, you just think Monad like *Black Box*, think deeply when you have familiar with Haskell.
11:34:08 <ksf> scotd, you shouldn't put plumbing in quotes
11:34:11 <qwr> heh
11:34:13 <ksf> it's a technical term proper
11:34:27 <aavogt> @wn plumbum
11:34:30 <lambdabot> No match for "plumbum".
11:34:48 * qwr thinks you should do just the simplest thing, whatever the language is...
11:34:51 <ksf> in plumbus unum.
11:35:08 <Twey> ksf: Haha
11:35:42 <aavogt> deech`: haskelldb from the darcs repo doesn't have that problem if I recall correctly
11:36:15 <aavogt> but let's say that it wasn't fixed elsewhere: the solution is to add   old-time  to the list of dependencies in the .cabal file
11:36:42 <deech`> aavogt: Ah I'll try that!
11:36:51 <ManateeLazyCat> scotd: First, don't care Monad how to implement, just use it, you will understand when you coding enough time.
11:37:21 <aavogt> if you've already written a bunch of haskelldb code, you may or may not want to use the unreleased version, since it got changed to use a better record system (HList)
11:37:56 <monochrom> If you don't understand monads, there is probably because of too much plumbum in our plumbing.
11:38:00 <sepp2k> Why is :k (->)  "?? -> ? -> *"? Why not "* -> * -> *"? What do ?? and ? mean?
11:38:25 <monochrom> And too much plumbum butchered my English too.
11:39:07 <ksf> isn't plumbum lead?
11:39:10 <ManateeLazyCat> scotd: Have many different Monad in Haskell, beginning, you study eaiser moand, such as "IO Moand" and "Maybe Monad", then study harder Monad, example "State Moand" ... etc.
11:39:22 <copumpkin> ksf: yep
11:39:26 <ksf> I vaguely remember it as Pb on the period table
11:39:32 <int-e> sepp2k: because functions can take unboxed types as arguments, and have unboxed types and unboxed tuples as return values. unboxed values have kind #, unboxed tuples have kind (#). ?? is the union of * and #, and ? is the union of ?? and (#).
11:39:58 <int-e> sepp2k: all that is ghc specific.
11:40:08 <sepp2k> int-e: Thanks.
11:40:15 <monochrom> Oh I just liked to make a pun on monad and plumbing. "lead" is not as catchy as "plumbum".
11:40:39 <aavogt> aww ghci's :{\n\n\n.... :} doesn't play nicely with editing the history
11:40:57 <deech`> Umm... newbie question. If I want to edit the .cabal file from a "cabal fetch"ed package, do I have to replace the existing tar file with a new one?
11:41:06 <monochrom> perhaps Monad is better called Plumbum
11:41:08 <aavogt> ksf: leading is ambiguous though
11:41:18 <Zao> deech`: You can cabal unpack  to get and unpack the sources.
11:41:26 <Zao> deech`: Then you can just issue cabal commands directly in the directory.
11:41:33 <Zao> cabal configure && cabal build && cabal install
11:41:48 <aavogt> you can leave out the configure and build commands
11:42:07 <ksf> ...you have to manually configure before manually building, though.
11:42:31 <aavogt> no, cabal-install does those steps for unpacked packages too
11:42:34 <ManateeLazyCat> If someone have time, help me look this bug: http://hackage.haskell.org/trac/ghc/ticket/3918 Thanks!
11:42:47 <ManateeLazyCat> Bye all, night!
11:42:49 <ksf> deech`, don't forget to bump the version, though.
11:42:51 <deech`> monochrom: Yes, since plumbum implies lead piping and drinking anything piped through it makes you mad.
11:43:16 <ksf> aavogt, I mean you can't "cabal build" before doing "cabal configure". "cabal install" does those two, automatically.
11:43:37 * shapr hugs cabal
11:43:45 * shapr hugs SyntaxNinja for making cabal happen in the first place!
11:43:49 <shapr> SyntaxNinja++
11:44:00 <deech`> Ok will try. brb.
11:44:11 <aavogt> cabal still has much room for improvement though
11:44:15 <jlouis> shapr!
11:44:20 <scotd> later ManateeLazyCat
11:44:21 <shapr> jlouis!
11:44:24 <jlouis> Need combinatorrent patch!
11:44:27 <shapr> oh?
11:44:27 <jlouis> :P
11:44:36 <shapr> You really named it that? :-)
11:44:38 <monochrom> monochrom!
11:44:48 <shapr> techrachrom!
11:44:50 <jlouis> shapr: not yet!
11:44:55 <ksf> torrent combinators? wtf?
11:44:56 <shapr> jlouis: Where do I find it!
11:45:20 <Becquerel> what is the torrent combinator :P
11:45:21 <shapr> ksf: I wanted to call jlouis' bittorrent client written in Haskell combinatorrent.
11:45:41 <Zao> *groan*
11:45:44 * ksf agrees
11:45:45 * shapr grins
11:45:51 <shapr> I also named The Monad.Reader ...
11:45:55 <monochrom> ingenious name
11:46:04 <shapr> I'm infamous for my cheesy punny names.
11:46:10 <ksf> but we need some superficial combinators that don't make real sense to look even more hillarious
11:46:16 <shapr> ksf: Like what?
11:46:34 <monochrom> the "why" combinator
11:47:07 <ksf> well I don't think more than mappend and mempty can be sqeezed out of them sensibly
11:47:08 <ManateeLazyCat> Wow, i use `runCommand` instead `forkProcess`, my problem fix. So cool!
11:47:16 <monochrom> and the ä¸« combinator
11:47:20 <ksf> but that doesn't mean that we can't have a torrent construction monad.
11:47:26 <ManateeLazyCat> I will see the different between `runCommand` and `forkProcess`.
11:47:35 <shapr> monochrom: Oh, I like that one.
11:47:38 <jlouis> shapr: http://github.com/jlouis/haskell-torrent -- I can rename the repo :)
11:48:03 <shapr> My cultural discovery is that cheesy funny names stick in the mind longer than boring names.
11:48:13 <shapr> So, you want me to patch it?
11:48:28 * hackagebot control-monad-exception 0.8.0.4 - Explicitly typed, checked exceptions with stack traces  http://hackage.haskell.org/package/control-monad-exception-0.8.0.4 (PepeIborra)
11:48:32 * shapr decides to hack up a lambdabot plugin...
11:48:35 <jlouis> if you would like to be part of this great famous project with a cheesy name?
11:49:00 <jlouis> I'd be honored to serve the great unicycler in the sky
11:49:03 <shapr> I doubt I'll do more than patch it to change the name :-)
11:49:06 <ksf> ...the other possibility, though, would be to properly support combining actual life torrents, that is, constructing a new one out of two existing ones without having to manually inject the old files into the new torrent if you want to help initial seeding
11:49:08 <ManateeLazyCat> I'm really happy `runCommand` this perfect fix. :) Bye, it's time to continue. ;-)
11:49:28 <shapr> I have enough stuff going on at the moment... My current interest is low power wireless sensor networks.
11:49:33 <shapr> And getting a degree
11:50:16 <jlouis> ksf: that isn't too far-fetched
11:50:37 <shapr> Hiya Hugo
11:50:54 <jlouis> ksf: http://www.bittorrent.org/beps/bep_0030.html this extension goes some of the way
11:51:18 <ksf> I know, I've did it quite a few times. re-checking gigabytes of chunks is quite tedious.
11:51:27 <NEEDMOAR> A semantics for shapr.
11:51:51 <shapr> NEEDMOAR: If you ever figure it out, you're doing better than I am.
11:53:10 <jlouis> semantics for women ...
11:53:17 <jlouis> now there is a challenge
11:53:25 <NEEDMOAR> Shaprly types separate data, represented by list, from shapr, or structure!
11:55:01 <deech`> My HaskellDB wants to install "directory", which depends on the latest base. The "directory" Hackage page seems to indicate that it fails to build on 6.12. How do I upgrade base without upgrading GHC?
11:56:15 <jlouis> deech`: hmm?
11:56:19 <aavogt> you can't do that
11:56:43 <aavogt> ghc seems to come with directory anyways...
11:56:47 <Heffalump> if you have 6.12 you have the latest base
11:57:11 <jlouis> deech`: built-on is superficial
11:57:20 <HugoDaniel> hey shapr
11:57:22 <HugoDaniel> :)
11:57:38 <deech`> jlouis: so I should go ahead and upgrade GHC?
11:58:40 <jlouis> deech`: I have directory-1.0.1.0 installed on ghc 6.12 here
11:59:29 <deech`> jlouis: Ok, an upgrade it is.
12:22:38 <HugoDaniel> im having problems installing leksah
12:22:43 <HugoDaniel> linux problems
12:22:47 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23932#a23932
12:24:40 <doserj> HugoDaniel: you need to install gtk2hs (http://www.haskell.org/gtk2hs/download/)
12:28:46 <Libster> haskell is gay lol
12:29:02 <c_wraith> His wife didn't say that, as far as I know.
12:29:07 <fax> Libster, you have against gay people?
12:29:11 <fax> something ^
12:29:13 <Libster> i love gay people
12:29:40 <pikhq> Yes, Haskell makes me quite gay. Beautiful languages tend to produce such emotions.
12:29:55 <Libster> llol
12:30:11 <Libster> i'm looking for a channel to troll in is this a good one
12:30:15 <medfly> hi Libster, have you come to troll here?
12:30:19 <medfly> yeah, this one is great
12:30:19 <Libster> yep
12:30:21 <medfly> we don't give up on trolls
12:30:22 <Libster> cool
12:30:25 <Libster> nice
12:30:26 <medfly> now what are your problems with Haskell
12:30:38 <Libster> i am just beginning in my trolling so i might need some help
12:30:42 <pikhq> However, we have a tendency to produce trolls that comprehend monads quite well.
12:30:50 <nostrand> gay is the way as we say
12:30:51 <sshc> i'd believe he'd have a lot of troubles with Haskell
12:30:54 <fax> Libster already knows monads
12:30:55 <medfly> I think Libster would understand monads
12:31:04 <Libster> yeh
12:31:07 <medfly> pikhq, he hangs out in #math
12:31:11 <shapr> Libster: So, wanna learn some Haskell for more effective trolling?
12:31:21 <shapr> Libster: I can set you up with some tutorials and introductions and stuff.
12:31:24 <Libster> cool
12:31:26 <pikhq> medfly: Ah. Very well then.
12:32:09 <medfly> Libster, dude, a bunch of Haskellers know about you! creepy!
12:32:18 <Libster> i know :(
12:33:04 <sshc> Libster: this channel has the most unfriendly, stupid people in it.  Good place to get experience to annoy others.
12:33:16 <Libster> yeah that's why i cam ehere
12:33:46 <shapr> We try.
12:34:56 <Null-A> sshc: my experience has been the opposite
12:35:11 <medfly> Null-A, Libster wants to troll
12:35:12 <Libster> lllllllllllllllllolllllllllllllllll
12:35:15 <sshc> Null-A: you're inexperienced.  Bye now!
12:35:26 <Libster> yeah please tech me how to troll
12:35:37 <shapr> See, I'm here to make sure people are nice to each other on #haskell
12:35:51 <fax> Libster why don't you go study some stacks of cohomology sheaves
12:35:51 <shapr> And that they stay on topic, for the most part.
12:35:52 <medfly> Libster, tell us you get monads, they're like burritos. it all makes sense now.
12:36:00 <medfly> that would work
12:36:18 <sshc> Libster: the best way is to find the most sensitive people
12:36:26 <Libster> ok
12:36:30 <sshc> Libster: It is in my experience that the most sensitive person here is Cale.
12:36:36 <Libster> nah i like Cale
12:36:37 <shapr> Hey, you'll have to take your off-topic troll lessons to #haskell-blah
12:36:38 <copumpkin> don't make him cry
12:36:40 <medfly> sshc, he's sensitive?
12:36:48 <Libster> Cale is cool he does math n shit
12:36:51 <medfly> I think Cale is like the least sensitive person ever.
12:36:57 <copumpkin> medfly: !
12:37:08 <copumpkin> medfly: quit learning from the troll
12:37:08 <medfly> yes, I am the most sensitive person here
12:37:11 <copumpkin> :P
12:37:23 <Libster> fax, wanna cyber
12:37:23 <shapr> Has anyone used the Atom lib to write Arduino code?
12:37:37 <shapr> Libster: Hey, that will get you removed from #haskell, be nice.
12:37:43 * fax does not even know what atom or arduino is ..
12:37:43 <Libster> sry
12:37:51 <Null-A> Most of the gui code I've looked at uses monads frequently, is this a necessity for creating guis? Could've you have something more declarative
12:37:54 <medfly> @hoogle Atom
12:37:58 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:37:59 <Libster> hoogle
12:38:02 <lambdabot> Foreign.C.Types data CSigAtomic
12:38:06 <lambdabot> Control.Exception data NestedAtomically
12:38:08 <Null-A> Couldn't*
12:38:15 <medfly> fax, arduino: http://www.arduino.cc/
12:38:20 <Saizan> Null-A: there are libs like Fruit which are more declarative
12:38:24 <shapr> fax: Arduino: http://arduino.cc/ and atom: http://hackage.haskell.org/package/atom
12:38:31 <Null-A> Saizan: k, thx
12:38:43 <Saizan> Null-A: somewhat experimental though
12:38:47 <fax> oh wow
12:39:05 <Saizan> GuiTV also
12:39:20 <Saizan> (or some other combination of upper/lower case)
12:39:45 <roconnor> I've used GuiTV once.  I liked it.
12:39:58 <roconnor> it was great for my really tiny gui
12:40:28 <sshc> Libster: If you really want to annoy other people, only dcoutt0s, don0s, Saiza0n, monochro0m, Iglo0o, and Philipp0a.
12:40:37 <fax> sshc ???
12:40:47 <Libster> ok
12:40:51 <Libster> thnx
12:41:14 <sshc> shrnp!
12:43:30 <shapr> So I hear alpheccar got GHC doing crosscompilation to OMAP/ARM today.
12:43:35 <Libster> hello dcoutts dons Saizan monochrom Igloo Philippa
12:43:41 <Libster> (i am a grate troll)
12:43:46 <shapr> Libster: Would you like to learn Haskell?
12:43:59 <Libster> will it make me rich
12:44:04 <medfly> definitely would
12:44:06 <fax> @protontorpedo
12:44:06 <Libster> ok
12:44:08 <lambdabot> can haskell be used to develop databases?
12:44:23 <Libster> can i make an mmorpg in haskell?
12:44:34 <shapr> Libster: http://book.realworldhaskell.org/read/
12:44:48 <lament> i think Libster should be directed to LYAH
12:44:59 <lament> at least he'll find the pictures amusing
12:45:10 <Saizan> @where LYAH
12:45:13 <HugoDaniel> @faq can i make an mmorpg in haskell?
12:45:14 <lambdabot> http://www.learnyouahaskell.com/
12:45:16 <Saizan> done
12:45:18 <lambdabot> The answer is: Yes! Haskell can do that.
12:45:23 <lament> Libster: check out that site
12:45:27 <Libster> okthnx
12:45:31 <sshc> oknp
12:47:31 <Libster> :)
12:48:23 <edwardk> shapr: oh? (re cross compilation)
12:48:49 <shapr> That's all I know, but I am looking forward to crosscompiling GHC programs onto my N800 and BUG.
12:48:52 * hackagebot pureMD5 1.1.0.0 - MD5 implementations that should become part of a ByteString Crypto package.  http://hackage.haskell.org/package/pureMD5-1.1.0.0 (ThomasDuBuisson)
12:49:10 <Alpounet> preflex: seen dons
12:49:11 <preflex>  dons was last seen on #haskell 2 hours, 58 minutes and 55 seconds ago, saying: ezyang: yep. 12 years ago
12:49:39 <tommd> preflex: seen dcoutts
12:49:39 <preflex>  dcoutts was last seen on #haskell 2 days, 10 hours, 2 minutes and 14 seconds ago, saying: dobblego: if people only rm .cabal they end up with lots of registered packages that have had all their files deleted, which is jolly confusing.
12:50:11 <Libster> hhhhe
12:50:14 <shapr> I wonder if alpheccar's work will be good for the Haskell iphone devs as well?
12:50:41 <shapr> Libster: So which do you prefer? LYAH or RWH?
12:50:42 <tehgeekmeister> is there some function in the prelude/standard libraries that will drop all successive characters at the end of a string that satisfy a predicate?
12:50:57 <Libster> i like OIFOSIDFIDSOFDSHFBSOPOJHJKIOKJHJOIJH
12:50:59 <tehgeekmeister> i'm trying to strip punctuation from the end of words only, never from in the middle
12:51:10 --- mode: ChanServ set +o shapr
12:51:20 <tehgeekmeister> i can write the function obviously, but if i don't have to, i'd rather not
12:51:20 <tehgeekmeister> =P
12:51:28 <tommd> @tell dcoutts: I caved and made pureMD5 use Data.Serialize.Get.getWord32le instead of using unsafePerformIO and the Storable instance of Word32s.  This should fix your Sparc issue and keep the code #ifdef free at the cost of some performance.
12:51:28 <lambdabot> Consider it noted.
12:51:45 <shapr> Libster: Are you familiar with the concept of foreshadowing?
12:51:51 <Libster> no
12:51:53 <Saizan> tehgeekmeister: reverse . dropWhile .. . reverse ?
12:51:57 <Libster> but can i have ops
12:52:10 <tehgeekmeister> Saizan: meh, i didn't want to reverse every single word, but that's probably the best bet.
12:52:27 <tehgeekmeister> Saizan: also, dropwhile, that'll make my life easier for stripping the beginning.  much thanks.
12:52:27 <edwardk> shapr: hrmm. there was a /r/haskell_proposals that was asking about targeting google NaCl as well. main thing is getting it verified. the issue i think there and on the iphone is that the little callback stubs that get build as needed have to be preallocated. so there is still some stuff that the iphone guys did that would be needed for any iphone cross-compilation that wanted to run without a jailbreak
12:52:31 <shapr> Libster: foreshadowing - http://en.wikipedia.org/wiki/Foreshadowing
12:52:43 <Libster> o
12:52:49 <shapr> Libster: That was tactful for... contribute, be quiet, or get kicked.
12:52:59 <lament> i have to admit this is the most successful troll i've seen Libster pull off
12:53:02 <Saizan> tehgeekmeister: well, you can write it more efficiently with a direct recursion, of course
12:53:04 <lament> and i blame the channel for this
12:53:04 <Libster> please don't dick me
12:53:06 <Libster> *kick
12:53:11 --- kick: Libster was kicked by shapr (Kicked by shapr)
12:53:18 <shapr> That none of contributing or being silent.
12:53:24 <mog> smack
12:53:31 <jmcarthur> mog speaks!
12:53:35 <shapr> Libster: That was called a hint!
12:53:40 <Libster> i'
12:53:45 <Libster> am drunk
12:53:49 <mog> my goal is to get kicked by shapr now jmcarthur
12:53:50 <tehgeekmeister> Saizan: right now that'll work.  I'm doing a quick and dirty first version, and i'd just rather have something working.
12:53:57 <shapr> Libster: Once again: contribute,  be silent, or be *banned*
12:54:02 <tehgeekmeister> Saizan: it doesn't need to be optimized really at all.
12:54:07 <shapr> mog: I'm happy to help :-)
12:54:08 <mog> i just have to get shapr drunk with power
12:54:13 <Libster> i am contributing
12:54:29 <fax> Libster you should learn haskell and implemetn group theory in it
12:54:37 <Libster> :)
12:54:40 <Libster> i like grou ptoery
12:54:44 <fax> me too :P
12:54:48 <lament> shapr with ops is cute
12:54:49 <Saizan> tehgeekmeister: it'll be fine then :)
12:54:50 <fax> I learn about group representations
12:55:09 <fax> homomorphism into F-algebra with nxn matrices??
12:55:15 <Libster> G -> GL(V) lol
12:56:11 <tehgeekmeister> Saizan: i have a really bad habit of trying to optimize too early.  I'm just making wordlists for project gutenberg books.  =P
12:56:20 <roconnor> fax: F-algebra?
12:56:36 <fax> roconnor, yeah but it's field raether than functor
12:56:38 <roconnor> :D
12:57:07 <fax> it's used in wiles proof of fermats last theorem too
12:57:26 <fax> that's where I first found representation theory..
12:58:37 <fax> but now I see it everywhere!
13:01:43 <chrisdone> reet
13:03:07 <juhe> Hello people. Is there a GetT transformer for Get monad from binary package? I'd need to execute some IO actions while parsing binary data...
13:03:28 <chrisdone> :hoogle GetT
13:03:33 <chrisdone> @hoogle GetT
13:03:33 <lambdabot> System.Directory getTemporaryDirectory :: IO FilePath
13:03:34 <lambdabot> System.Console.Editline.Readline getTerminalName :: IO String
13:03:34 <lambdabot> Data.Time.LocalTime getTimeZone :: UTCTime -> IO TimeZone
13:04:02 <chrisdone> hoogle isn't authoritative. she thinks she is but I know different :p
13:04:08 <Saizan> i think there's a GetT floating around somewhere
13:05:21 <Saizan> hard to google though :\
13:05:45 <sshc> binary doesn't sanitise input
13:05:58 <chrisdone> Saizan: just put speech marks around it as "gett"
13:06:00 <sshc> it needs to at least be capable of it!
13:06:02 <chrisdone> http://www.google.co.uk/#hl=en&safe=off&q=haskell+%22gett%22&meta=&aq=f&aqi=&aql=&oq=&fp=819eb60ddcc41d13
13:06:36 <tavelram> Is there a nice way to get around the fact that each line in a do must be correctly indented? Putting each line within () works, but is there nicer way?
13:07:01 <benmachine> tavelram: huh?
13:07:11 <benmachine> you can use {} and ; explicitly if you like
13:07:24 <tavelram> but anything besides that?
13:07:54 <SyntaxNinja> heya shapr
13:08:04 <tavelram> perhaps some extension? or perhaps some precedence-hack?
13:08:19 <shapr> SyntaxNinja!!! Hiya!
13:08:27 <Twey> I second â€˜huh?â€™
13:08:33 <SyntaxNinja> shapr: how's life?
13:08:35 <benmachine> tavelram: not clear about what you want exactly
13:09:00 <Twey> You want to make the structure of a do-block clear, without making the structure of a do-block clear?
13:09:07 <shapr> SyntaxNinja: Writing Haskell to generate Arduino code at this instant. Enjoying university, going out with classmates tonight. How's life with you?
13:09:22 <benmachine> tavelram: you might want to pastebin the code that isn't co-operating
13:10:05 <tavelram> benmachine, Ive got a monad where each line is an expression, ie 3+5 > 0, and Id simply like to align them around the inequality,which means that the lines might have different indentation.
13:10:09 <SyntaxNinja> shapr: pretty good.  still in pdx and doing the same stuff. arduino is pretty sweet. where are you going to school?
13:10:38 <shapr> SyntaxNinja: una.edu, Northwest Alabama, ~1 hour west of Huntsville where jmcarthur, mog and some other folk live.
13:11:08 <benmachine> tavelram: align the inequality by spacing on the right/
13:11:09 <benmachine> ?
13:11:17 <benmachine> also, that sounds perverse
13:11:23 <benmachine> :P
13:11:29 <benmachine> but those are all your options
13:11:32 <tavelram> hehe, hold on :p
13:11:40 <SyntaxNinja> shapr: sweet! And your arduino thing is for school or fun?
13:11:46 <benmachine> if you use {} and ; cunningly then you could make it not-ugly I reckon
13:11:58 <tavelram> benmachine, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23933#a23933
13:12:13 <benmachine> or you could invent an identifier to go on the beginning of the line, because only the first nonwhitespace matters
13:12:36 <tavelram> benmachine, what about setting the precedence of > ?
13:12:42 <Twey> No
13:12:49 <benmachine> precedence is irrelevant to indentation
13:12:53 <Heffalump> anyone got a cabal-install 0.8.0 binary for Windows?
13:12:59 <shapr> SyntaxNinja: Mostly for fun, but partially preparation for the makerspace ybit and I are trying to bootstrap.
13:13:01 <twink> Take acting classes.
13:13:24 <tavelram> well, not really, since If i set infix 0 >, it would go beyond >> and thus affect the indentation ;)
13:14:03 <chrisdone> is there a haskell -> plain english explainer knocking about?
13:14:37 <lament> draw a pentagram and summon Cale
13:14:50 <chrisdone> I'm looking for something more scalable
13:15:27 <Twey> We need a lambdacale
13:15:41 <Twey> lambdacale "explain" "arrows"
13:15:44 <felzix> is there an easy way to profile a haskell program or do I need to specify every library I'm using?
13:15:56 <tehgeekmeister> eep, two minutes so far in just generating a wordlist.  i did something that isn't efficient, it looks like.
13:16:10 <aavogt> you'd have to compile everything with profiling
13:16:22 <Twey> Only if you want to profile inside those bits
13:16:26 <hoknamahn> hey guys, did anyone have a problem with installing haddock 2.4.2 on gentoo?
13:16:45 <felzix> I'd be happy if it just automatically found libraries and recompiled them
13:16:53 <chrisdone> lambdacale: @faq can I be a super hero?
13:16:53 <chrisdone> lamdabcale: The answer is: Yes! Haskell can do that. All you need is to understand intermediate category theory and a solid grasp of how pigs are farmed, ...
13:18:15 <benmachine> tavelram: don't think so, do notation is more magic than that
13:19:10 <jlouis> shapr: you have gotten haskell to gen arduino code?
13:19:11 <chrisdone> "a :: a -> a" could be translate to "the variable `a' has the type for all types `a', function from `a' to `a'."
13:19:17 <jlouis> shapr: me somewhat interested in that
13:19:18 <chrisdone> there's a c++ bot that does similar ~
13:19:31 <shapr> jlouis: Have you seen the atom library?
13:20:00 * qwr deduced... id
13:20:02 <jlouis> shapr: yes, but I did not understand what it does
13:20:22 <qwr> (from a -> a)
13:20:24 <jlouis> shapr: is that what I should check out?
13:20:33 <shapr> Yup!
13:21:54 * jlouis makes mental note
13:21:54 <tavelram> benmachine, oh, i just spend way to much time fighting with precedence until i realized that >> had 1, and changing my operator from 1 to 2 made it work, so I jsut assumed that it was clashing with >>...
13:25:33 <tehgeekmeister> how do you pattern match a lazy char bytestring against a char?
13:25:45 <tehgeekmeister> you can't use pack in the pattern match
13:25:59 <tommd> Does anyone here have access to a Sparc machine or other non- little endian architecture?
13:26:26 * twink cries
13:29:34 <bolmar> tommd: sure
13:29:56 <xerox> tehgeekmeister: this works but needs refinement -XPatternGuards and let f s | (97:_) <- unpack s = "foo" in pack [fromIntegral.ord$'a']
13:30:20 <xerox> (err make that ".. in f .."
13:31:04 <deech`> I just tried to upgrade to GHC 6.12 and found that cabal-install doesn't work anymore. I then re-installed 6.10.4 and now all my existing packages give a "Bad interface file: mismatched interface file versions (wanted "6104" got "")". Doing a "cabal install --reinstall" seems to fix the problem but it is there an easier way?
13:31:39 <tehgeekmeister> xerox: i don't understand that, but fortunately, i figured out another way to do what i was trying to anyway.
13:31:45 <xerox> good :)
13:32:16 <tommd> bolmar: If you are willing I'd like independent confirmation that pureMD5-1.1.0.0 works on your non-x86 architecture.  The package is already on hackage (cabal update ; cabal install pureMD5) and a simple md5sum that uses it is here: http://web.cecs.pdx.edu/~dubuisst/md5sum.hs
13:32:54 <copumpkin> can anyone remember where the typesafe red/black trees are?
13:33:03 <copumpkin> it's an okasaki paper, right?
13:33:06 <ezyang> Yes!
13:33:09 <ezyang> Let me look it up
13:33:26 <ezyang> there at least in "Purely Functional Data Structures"
13:33:35 <ezyang> p.24
13:33:39 <shapr> I love that book
13:33:44 <shapr> Sadly, I loaned my out and never got it back
13:33:45 * shapr cries
13:33:53 <copumpkin> ezyang: not in a separate paper?
13:33:54 <tehgeekmeister> is nub really efficient?  or if i'm trying to remove duplicate words from a really long list of them (800k of plaintext), should i use something else?
13:34:02 <copumpkin> tehgeekmeister: not at all
13:34:04 <ezyang> A dichromatic framewrok for Balanced trees
13:34:12 <Alpounet> @src nub
13:34:12 <lambdabot> nub = nubBy (==)
13:34:16 <Alpounet> @src nubBy
13:34:16 <lambdabot> nubBy eq []             =  []
13:34:16 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:34:17 <ezyang> Leo Guibas and Robert Sedgewick, in the IEEE symposium
13:34:54 <tehgeekmeister> copumpkin: so making my own deal that maintains a hash of what's been seen and not is a much better bet, okay
13:34:57 <copumpkin> ezyang: that's the typesafe invairant checking one?
13:35:21 <ezyang> copumpkin: hm, I don't know about typesafe
13:35:33 <copumpkin> there was one that encoded the invariants in types
13:35:36 <copumpkin> but I can't find it now
13:35:40 <copumpkin> well, most of the invariants
13:35:59 <michael|> a/query ezyang
13:36:06 * michael| kicks autocomplete
13:36:17 <ezyang> michael|: merm?
13:36:44 <michael|> ezyang: Wasn't even focusing on you, xmonad grabbed the wrong window focus.
13:36:48 <michael|> Sorry :)
13:42:24 <bolmar> tommd: sorry, seems there's no haskell on there
13:42:36 <tommd> gah.  Understandable.  Thanks anyway.
13:43:12 <mreh> blame xmonad
13:43:28 <mreh> yampa is sooo hard to learn
13:45:09 * hackagebot hosc 0.8 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.8 (RohanDrape)
13:45:11 * hackagebot hsc3 0.8 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.8 (RohanDrape)
13:45:51 <pflanze> I'm looking for a secure web server, and learning Haskell anyway I'm looking for solutions in that language.
13:46:32 <pflanze> I'm looking at the HAppS web site, but it seems not very active, also I can't find the code.
13:47:03 <pflanze> Also on the fora they mention sendfile; I would prefer a pure Haskell solution with no FFI or otherwise unsafe code.
13:47:33 <pflanze> Would you suggest another project?
13:47:37 <ivanm> pflanze: happstack
13:47:42 <ivanm> it's the successor to happs
13:47:50 <pflanze> aha, thanks
13:47:56 <ivanm> and FFI doesn't always imply unsafe ;-)
13:51:14 <gio123> http://pastebin.com/9DX8CDTZ
13:53:07 <eintopf> hi, anyone knows leksah? I would try it, but I get a segmentation error... strace gives no information for me
13:55:36 <HugoDaniel> how do i remove only the last element of a list ?
13:55:53 <HugoDaniel> so that i get the list with all the elements except for the last one
13:55:58 <sepp2k> HugoDaniel: init
13:56:04 <HugoDaniel> yes, thats it :)
13:56:06 <HugoDaniel> thanks
13:56:16 <HugoDaniel> i was not remembering the name, brainlocked
13:56:26 <sepp2k> np
13:59:12 * hackagebot hsc3-dot 0.8 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.8 (RohanDrape)
14:01:13 * hackagebot hsc3-graphs 0.8 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.8 (RohanDrape)
14:01:55 <tommd> > let e = 2.718281828459045
14:01:56 <lambdabot>   not an expression: `let e = 2.718281828459045'
14:02:04 <tommd> > e = 2.718281828459045
14:02:05 <lambdabot>   <no location info>: parse error on input `='
14:02:07 <tommd> grrr
14:02:21 <tommd> I forgot how to set top level values in lambdabot
14:03:15 <medfly> @let e = 2.71
14:03:16 <lambdabot>  Defined.
14:03:24 <medfly> @undefine
14:03:28 <medfly> I think...
14:03:36 <ivanm> > e
14:03:37 <lambdabot>   e
14:03:37 <medfly> but you might want to not use a one letter thing
14:03:39 <medfly> @type e
14:03:40 <lambdabot> Expr
14:03:44 <medfly> @type f
14:03:45 <ivanm> e is already defined ;-)
14:03:45 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:03:46 <medfly> and so forth
14:03:54 <medfly> SimpleReflect apparently uses all one letter things
14:04:06 * ivanm thinks @let should be removed
14:07:42 <aavogt> > exp 1
14:07:43 <lambdabot>   2.718281828459045
14:11:15 * hackagebot hsc3-db 0.8 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.8 (RohanDrape)
14:11:17 * hackagebot hsc3-rec 0.8 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.8 (RohanDrape)
14:14:16 * hackagebot hsc3-lang 0.8 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.8 (RohanDrape)
14:14:30 <roconnor> has LLVM replaced C-- in GHC?
14:14:39 <Alpounet> no
14:15:03 <Heffalump> the LLVM backend is targeted from C--
14:15:36 <roconnor> whoa
14:16:17 * hackagebot hsc3-sf 0.8 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.8 (RohanDrape)
14:17:17 * hackagebot polyseq 0.1.1 - Counter examples to Free Theorems  http://hackage.haskell.org/package/polyseq-0.1.1 (DanielSeidel)
14:17:19 * hackagebot hsc3-sf-hsndfile 0.8 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-hsndfile-0.8 (RohanDrape)
14:17:48 <HugoDaniel> :)
14:17:55 <HugoDaniel> hackagebot rulling the world
14:18:06 <ivanm> someone made a package of _counter examples_? :o
14:18:31 <ivanm> hang on, the LLVM backend works by still generating C-- ?
14:18:45 <ivanm> I thought it converted core directly to LLVM bytecode or something :(
14:18:55 <thoughtpolice> ivanm: it converts C-- into llvm bitcode
14:18:59 <thoughtpolice> and then llvm compiles it
14:19:07 <ivanm> yeah, I get that
14:19:24 <ivanm> but I thought that with LLVM backend C-- was useless :s
14:19:35 <ivanm> I didn't realise that it was still generating C--
14:19:51 <ivanm> (and then just passing it to a different compiler)
14:19:57 <thoughtpolice> i don't see it as useless, in fact, C-- in GHC has been very useful, leaving the gate open for C, native backends and now an LLVM backend
14:20:19 <Heffalump> I guess it would be possible that if and when LLVM becomes the only backend, then the C-- stage might become redundant. But the situation is nowhere near that yet.
14:20:19 <ivanm> thoughtpolice: no, I meant that with LLVM replacing the GCC backend there would be no need for C--
14:20:34 <Heffalump> LLVM isn't replacing the unregisterised GCC backend
14:20:41 <ivanm> Heffalump: as in avoid the intermediary C-- stage?
14:20:47 <ivanm> oh, just the registered one?
14:20:54 <thoughtpolice> no
14:20:55 <Heffalump> yeah
14:21:02 <thoughtpolice> llvm isn't replacing anything really i didn't think?
14:21:28 <thoughtpolice> there have been plans forever to drop -fvia-C, but I didn't think there was any pressure to get rid of the native code generators entirely in favor of LLVM
14:21:55 <thoughtpolice> i just see it as another backend, not really replacing one or the other
14:21:58 <ivanm> native code gen is staying for now
14:22:12 <ivanm> since for non-dph stuff they're still a tad better IIRC
14:22:58 <systemfault> Hi :) Noobie here, I'm having problems with maximumBy, is it possible to make a strict version or anything?
14:23:14 <ivanm> what do you mean by a "strict version"?
14:25:20 <Lemmih> systemfault: Try compiling with -O.
14:26:20 * hackagebot hsc3-unsafe 0.8 - Unsafe Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-unsafe-0.8 (RohanDrape)
14:26:29 <dobblego> what is the Haskell equivalent of this shell script: #!/bin/sh export T=U
14:26:59 <systemfault> Lemmih: Indeed, it worked
14:27:04 <systemfault> Lemmih: Weird.
14:27:14 <Lemmih> dobblego: system "sh thatScript.sh"
14:27:17 <copumpkin> lol
14:27:29 <thoughtpolice> ivanm: llvm only loses in general right now because it doesn't support TABLES_NEXT_TO_CODE, but i still didn't think there were any plans to just drop all of the NCG infrastructure in favor of llvm
14:27:32 <dobblego> Friday Funnies
14:27:33 * ivanm isn't sure if dobblego is being serious or sarcastic
14:27:35 <dobblego> :)
14:27:43 <thoughtpolice> even once TNTC is implemented for it
14:27:45 <dobblego> I am serious; I can find no way to setenv
14:27:47 <ivanm> dobblego: but it's saturday...
14:27:54 <ivanm> @hoogle environment
14:27:54 <lambdabot> module System.Environment
14:27:54 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
14:28:01 <dobblego> not in #haskell TZ
14:28:38 <Saizan> thoughtpolice: so they are going to implement it?
14:28:39 <ivanm> so you actually want to change the overall system environment?
14:28:46 <dobblego> yes
14:28:47 <ivanm> there _might_ be a POSIX solution
14:28:58 <ivanm> but I doubt there's one that'll also work on windows, etc.
14:29:06 <dobblego> yeah, I'm hoping to replace a pair of .sh and .cmd files
14:29:19 <ivanm> dobblego: System.Posix.Env
14:29:28 <ivanm> for *nix
14:29:38 <ivanm> but as for windows... *shrug*
14:29:49 <dobblego> righto ta
14:30:33 <thoughtpolice> Saizan: i believe so. simon proposed a rough equivalent to the evil mangler (but much, much less evil) for the LLVM backend that would basically do a tiny bit of post asm-generation processing, moving the info tables for closures etc next to the code for it
14:30:35 <ivanm> dobblego: you can try the winio package to see if it has anything...
14:30:45 <dobblego> ok
14:31:07 <thoughtpolice> Saizan: but pretty much nothing else, so it's much less evil than the EM (which does shit like tail call optimization at the GNU as level :( )
14:31:26 <ivanm> dobblego: but if you're running it under cygwin then unix apparently works... >_>
14:34:36 <MadHatterDude> Yo guys, Im at a friends com right now. I'm kinda tired and I can't remember what that all-round haskell program package with cabal and stuff is called... Help?
14:34:45 <Saizan> thoughtpolice: ah, in perl too?:)
14:34:50 <Adamant> Haskell Platform?
14:34:55 <medfly> @where platform
14:34:55 <lambdabot> http://hackage.haskell.org/platform/
14:34:58 <medfly> err
14:35:01 <medfly> is that right...
14:35:04 <MadHatterDude> Adamant: THANK YOU!
14:35:20 <d-snp> hi
14:35:25 <Adamant> medfly too :P
14:35:43 <sm> I have an error-raising parser, from which I get an ErrorT String IO a. When I run it with runErrorT, parsec's "'many' is applied to a parser that accepts an empty string." error raises an exception, instead of the Left String I was hoping for. Could someone advise me.. was my hope well-founded ? Does this mean I am failing in some inappropriate way in my parse code ? Or is it required that I catch IO exceptions in this situation ?
14:37:15 <Saizan> it throws an exceptions because that's not merely a parse error
14:37:49 <d-snp> could anyone explain when currying might be useful?
14:37:52 <Saizan> you're violating the precondition on many
14:37:59 <sm> Saizan: I think I get you.. it's a parsec user error
14:38:12 <d-snp> a haskell friend asked me if ruby had currying, so I made him this: http://pastie.org/867009
14:38:21 <d-snp> though I'm not sure what would be a usecase for it..
14:38:24 <Saizan> d-snp: having functions curried by default makes partial application much nicer
14:38:27 <sm> which just got exercised for the first time
14:38:45 <Saizan> sm: yup
14:39:06 * sm doesn't like the thought of runtime errors lurking in his parsers
14:39:40 <monadic_kid> d-snp: it's makes abstractions like monads and FRP nicer, you can use it to write point-free style programming. Promotes composing functions as opposed to writing redudant lamdbas
14:40:02 <sm> ok.. I guess it wasn't lurking, it did break right away when I added some new code. That's not so bad
14:40:14 <sm> thanks Saizan, that helps
14:40:19 <Saizan> np
14:40:25 <d-snp> hmm
14:41:05 <Cale> d-snp: When you have lots of higher order functions, that is, functions which take other functions as parameters, it helps to be able to apply a function conveniently to less than all of its arguments. Currying the functions makes this as easy as possible.
14:41:08 <c_wraith> d-snp: currying is incredibly valuable when doing higer-order programming.  It gives you a concise syntax for describing functions.
14:41:21 <monadic_kid> d-snp: if you have a action using monads then you're probably using currying without realizing it
14:41:55 <d-snp> woah, you guys all use words I don't know, let me google define: for a bit :P
14:42:07 <d-snp> I'm just a simple rubyist ;)
14:42:13 <monadic_kid> d-snp: just ignore me then for now
14:42:14 <Cale> d-snp: A good example is the map function
14:42:29 <Cale> > map toUpper "hello"
14:42:29 <lambdabot>   "HELLO"
14:42:34 <fax> hi cale !
14:42:57 <Cale> map applies a function to each of the elements of a list (or a string, since in Haskell strings are just list of Char values)
14:43:38 <Cale> Now, let's say we had a list of words and we wanted to make all the letters in each uppercase. Well,  map toUpper  is itself a function, the function we want to apply to all those strings
14:43:38 <d-snp> ahh
14:43:52 <Cale> > map (map toUpper) ["hello", "there", "world"]
14:43:53 <lambdabot>   ["HELLO","THERE","WORLD"]
14:44:14 <monadic_kid> :t map
14:44:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:44:16 <ski> > (sortBy (comparing snd) . zip [0..] . words) "My pet ferret can type better than you!"
14:44:17 <lambdabot>   [(0,"My"),(5,"better"),(3,"can"),(2,"ferret"),(1,"pet"),(6,"than"),(4,"type...
14:44:23 <monadic_kid> :t map toUpper
14:44:24 <lambdabot> [Char] -> [Char]
14:44:33 <Cale> We don't have to introduce a lambda or define a new function to be able to get the function we're after
14:45:14 * ski wonders whether "lambda"s are known in Ruby as "block"s
14:45:19 <d-snp> hmm thanks Cale :)
14:45:23 <d-snp> ski: a bit
14:47:04 <monadic_kid> That's the problem with fsharp programmers, they tend use "pipeline" operator (function application) more than composition and taking advantage of currying. They end up writing redundant lambda expressions even though there is 2 function composition operators in F#
14:47:05 <d-snp> a lambda is a block with a reference to it.. I guess
14:47:23 <Drk-Sd> hi!
14:47:28 <Cale> d-snp: There's also something to be said for the conceptual simplicity of it -- all functions really have exactly one parameter.
14:47:31 <Drk-Sd> i've a question
14:47:47 <Cale> (And those who appear to take more are really just producing other functions)
14:47:49 <Drk-Sd> Â« do StringContent s <- Just $ getContent f Â» i'm not sure how <- is working here
14:48:04 <ski> a "lambda" is a (function-valued) expression, described by how arguments map to result
14:48:19 <Drk-Sd> i mean, StringContent doesn't seem to match Â« Just <some string> Â»
14:48:24 <Drk-Sd> so hum...
14:48:28 <ski> the is no need to name it (if that's what you meant by "reference")
14:48:32 <Cale> Drk-Sd: that looks like awkward code in the Maybe monad. You should never have to write that. Use let instead.
14:48:44 <Drk-Sd> :D
14:48:54 <ski> Drk-Sd : which monad is that ?
14:49:06 <ski> (.. meant to be)
14:49:15 <Drk-Sd> ski: good question isn't it ? i dont know
14:49:23 <Cale> It's equivalent to   do let {StringContent s = getContent f }; ...
14:49:32 <ski> Drk-Sd : by `getContent', maybe you meant `getContents' ?
14:49:36 <ski> @type getContents
14:49:37 <Drk-Sd> hum Cale, that's awkward
14:49:37 <lambdabot> IO String
14:49:38 <Cale> (don't need the braces if you lay it out properly)
14:49:51 <Drk-Sd> non ski, getContent is defined earlier in the file
14:50:24 <Drk-Sd> no*
14:50:41 <ski> so, probably you want what Cale suggested, then
14:51:11 <Cale> Drk-Sd: v <- Just x in the Maybe monad will bind v to x
14:51:22 <Drk-Sd> it's a maybe monad yes
14:51:23 <Cale> Drk-Sd: and v <- Nothing will cause the whole computation to be Nothing
14:51:45 <Drk-Sd> well, the return type of the function is Â« Maybe String Â»
14:51:46 <Cale> That is, the value of the whole do-block is nothing if that happens
14:51:51 <Drk-Sd> so i guess its a maybe monad
14:51:55 <Cale> Which function?
14:52:00 <Cale> getContent?
14:52:14 <ski> presumably the function where this is (part of) the body
14:52:18 <Cale> ah, yeah
14:52:20 <Cale> okay
14:52:22 <d-snp> ski: in ruby a block is like a piece of code with arguments, like a method body, or the body of a lambda, you see in the pastie I linked I capture the block passed to the method into a lambda with the ampersand, so I can call it from the lambda I create
14:52:33 <Drk-Sd> ski: you got it :)
14:52:55 <Cale> d-snp: Well, blocks (may) have parameters as well, like lambdas do.
14:52:58 <ski> d-snp : hm, paste is completely blank ..
14:53:12 <Cale> I'm not sure if they're identical to lambda though. I remember some strange scoping issues.
14:53:17 <d-snp> http://pastie.org/867009 <-- this one?
14:53:42 <ski> d-snp : oh, sorry, it's on `pastie.org' .. so the <http://pastie.org/867009.txt> fix works for me
14:53:59 <d-snp> ah, you have javascript disabled or something? :P
14:54:52 <ski> d-snp : well, you could state it like that .. w3m doesn't implement javascript :)
14:55:05 <d-snp> ah you're browsing in textmode :P
14:56:06 <Drk-Sd> well Cale, you were right, it looks like a let, as getContent can return a Â« StringContent string Â» pattern (beyond some other patterns)
14:56:08 <ski> anyway, afaicu `lambda {|*curry_params| ...}' in `curry' there is an expression whose value is a function .. and it is not named
14:56:32 <tsou> Having defined an operator, is there a standard way to say "I expect this operator to be commutative"?
14:56:38 <ski> so what did you mean by "referenced" ?
14:56:40 <tsou> or, any other assertion actually..
14:57:07 <Cale> tsou: You could maybe write a quickcheck test, but there's no way to inform the compiler.
14:57:11 <ski> tsou : well, you could define a QuickCheck property .. and run it with QC
14:57:39 <Drk-Sd> Cale: i've an other question (im really quite new to haskell, though i played with ocaml and erlang for a few years)
14:57:47 <d-snp> ski: it's not named, but it is returned from that method
14:57:50 <ski> (assuming you have decidable equality on the codomain)
14:58:00 <Drk-Sd> if getContent returns another pattern, like say Â« NoContent Â»
14:58:13 <Drk-Sd> what will happen in the function ?
14:58:19 <Alpounet> pattern matching failure
14:58:24 <Alpounet> (runtime error)
14:58:29 <tsou> is QuickCheck "standard" for writing assertions?
14:58:29 <Drk-Sd> clearly the matching doesn't seam exhaustiv
14:58:35 <Alpounet> yeah
14:58:36 <Cale> Drk-Sd: That's right, it's not.
14:58:39 <Drk-Sd> (god, i don't know how to write exhaustive :D)
14:58:40 <ski> d-snp : *nod* (i was just wondering what you meant by "a lambda is a block with a reference to it")
14:58:58 <d-snp> ski: I'm not certain about what the difference exactly is, it's just how it's used in the language, do create a lambda you pass a block into the 'lambda' method
14:59:08 <tsou> I actually don't care about the compiler, I just want to declare it in a standard way, even in a comment it would be ok
14:59:16 <d-snp> a block is always passed into a method as a parameter, it's never on its own
14:59:17 <Cale> d-snp: One thing I find strange is why blocks aren't just first class to begin with.
14:59:31 <Cale> d-snp: As in, why do you need to pass the block to 'lambda' at all?
14:59:42 <d-snp> yeah.. I've no idea..
14:59:42 <ski> Cale : syntactic reasons
14:59:54 <ski> Cale : why do we need to prefix `x |-> x^2' with `\' ?
14:59:57 <d-snp> if you just do a = do ... end, you get a syntax error
15:00:41 <Cale> ski: Mainly because lambdas can have multiple parameters between the \ and ->
15:00:42 <ski> (d-snp : i'm not sure what (or if) we're really arguing atm, though :)
15:00:48 <Drk-Sd> hmm, in fact, im not sure that will fail
15:00:52 <Drk-Sd> look at : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23934#a23934
15:01:05 <d-snp> ski: we're argueing why there is a difference between blocks and lambda's at all in ruby
15:01:11 <Drk-Sd> it seems that if the pattern doesn't match it will return Â« Nothing Â»
15:01:25 <Drk-Sd> at least, i guess it does
15:01:37 <Drk-Sd> (seeing the code of isa i mean)
15:01:38 <Cale> Drk-Sd: Oh, right, pattern match failure in the Maybe monad results in Nothing.
15:01:47 <fax> maybe what I need to do is write a preprocessor that sets everything up nicely
15:01:47 <ski> (Cale : btw, sorry, that `|->' should have been `->' .. i wrote the former on reflex :)
15:01:52 <d-snp> to me it kind of feels like a block is a lightweight lambda, if that makes sense :P
15:01:55 <fax> problem with that is IDE interaction...
15:01:57 <dolio> Blocks are second-class bits of code that Ruby lets you attach to function calls.
15:02:09 <Drk-Sd> Cale: ok :)
15:02:14 <dolio> "lambda" is a function that captures its block into a first-class object.
15:02:39 <ski> dolio : ok, so `lambda' is an actual Ruby function .. that wasn't clear to me
15:02:48 <Cale> Drk-Sd: More generally, there's an awkward method in the Monad class (which really oughtn't be there) called 'fail' that determines how to handle this pattern match failure.
15:02:48 <ski> (it might have been part of special syntax)
15:02:56 <d-snp> 00:08 < d-snp> ski: I'm not certain about what the difference exactly is, it's just how it's used in the  language, do create a lambda you pass a block into the 'lambda' method
15:03:00 <Cale> Drk-Sd: and it can be implemented differently in different monads.
15:03:00 <d-snp> :P
15:03:11 <Drk-Sd> Cale: oh right ! i read something about that a few days ago
15:03:34 <ski> (d-snp : sorry, i missed the end of that, somehow)
15:03:43 <d-snp> the sentence was too long :P
15:03:48 <Drk-Sd> probably in rwh (well, it certainly wasn't in the baastad, so it must have been in rwh)
15:03:55 <d-snp> tl:dnr :P
15:04:01 <Cale> Drk-Sd: It's a bad idea to rely on all monads having a sensible fail, but in this case, it's okay.
15:04:20 <dolio> ski: Yeah. You could probably implement it as "def lambda (&blk) { blk }", because writing &name as a parameter also captures the provided block into a first-class object (named "name").
15:04:31 <Cale> (most monads have a fail which just throws an asynchronous exception)
15:04:58 <Drk-Sd> 'k
15:05:09 <d-snp> dolio: did you see my implementation of curry into ruby, it sort of does that
15:05:57 <ivanm> noooo!!! I've just been bitten by unlines . lines stripping off the last newline! :@
15:06:11 <d-snp> except instead of returning just blk, it wraps it in another lambda that adds the currying parameters to it
15:07:14 <ski> ivanm : that's why i don't like how those behave ..
15:07:23 <ivanm> yeah
15:07:35 <bum> Greetings. I have a two-dimensional list - how do I replace a value of that list and return the new list?
15:07:38 <ivanm> atm I _know_ that there will be a newline on the end so I'm just appending one
15:07:52 <ivanm> bum: what do you mean?
15:08:09 <ivanm> also, 2D lists are a rather poor way of representing matrices if that's what you're doing ;-)
15:08:36 <bum> myFunction [ [1,2,3], [4,5,6] ] == [ [1,2,100], [4,5,6] ]
15:08:55 <jmcarthur> odds are you're doing it wrong if you need to do that
15:09:02 <bum> Yeah I'm pretty sure I am
15:09:30 <fax> myFunction = replace s3 with 100 ?
15:09:30 <dolio> There's also Proc.new { ... }, as I recall.
15:09:36 <jmcarthur> we have array types, maps, sequences, etc. if you need a lot of indexing
15:09:42 <dolio> Which used to have subtle differences from lambda, but I don't know if it still does.
15:09:52 <fax> or myFunction = replace the 3rd column of the 1st row to 100?
15:10:16 <bum> The latter.
15:10:18 <fax> okay
15:10:40 <fax> the first thing to notice is this problem can be divided into two easier problems: This is always a great thing to have when you want to write a program
15:10:41 <bum> I will rething what I do now anyways, but I'm still curious how one would do that.
15:10:43 <ivanm> bum: use an array of some kind
15:11:23 <fax> imagine if we have some kind of function: replace f index list,  which gives you the list back with 'f' applied to the index
15:11:29 <bum> Writing a simple tile based game using SDL and I use this 2-dimensional list to represent the grid
15:11:38 <fax> then you could define myFunction = replace (replace (const 100) 3) 1
15:11:41 <bum> Grid = [[Tile]], basically
15:11:43 <fax> and that's it done already!
15:12:00 <fax> so the problem is reduced to just implementing  replace f index list,  but this is easy to do by recursion
15:12:08 <fax> recursion on 'index'
15:12:13 <bum> fax: yeah, got it :)
15:12:16 <bum> Thanks.
15:12:35 <systemfault> Anyone has compiled ghc with llvm support? :/
15:12:43 <systemfault> (Recently if possible)
15:13:17 * jmcarthur has
15:13:21 <monadic_kid> bum: you might be interested in this: http://github.com/snkkid/LazyFooHaskell
15:13:22 <jmcarthur> a couple days ago
15:13:44 <monadic_kid> bum: lesson29 is simple tile maps example
15:13:47 <fax> bum, but yeah list is probably not very good
15:13:48 <systemfault> jmcarthur: And everything was working as it should? I get executables that segfaults.
15:14:16 <systemfault> jmcarthur: Even with a : main = do putStrLn $ show [1..10]
15:14:19 <jmcarthur> systemfault: heh, i haven't tried to run any executables from it since i last updated it, so i dunno
15:15:02 <jmcarthur> i am not using the machine that it's installed on currently, otherwise iw ould try now
15:15:04 <jmcarthur> *i would
15:15:08 <bum> monadic_kid: Very interesting indeed, thanks a lot.
15:15:39 <monadic_kid> bum: it's a port of LazyFoo: http://www.lazyfoo.net/SDL_tutorials/index.php
15:15:52 <bum> monadic_kid: Yeah I got that
15:16:03 <monadic_kid> I just started lesson 30
15:16:30 <bum> HaskellSDL has no primitives, does it?
15:17:05 <monadic_kid> bum: SDL gfx
15:17:11 <bum> Things like a box with a stroke around it
15:17:17 <monadic_kid> bum: i've never used it thought
15:17:24 <bum> Well it would suffice for what I do :)
15:17:56 <monadic_kid> bum: SDL gfx is library add-on and there is binding for that as well : http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.3/doc/html/Graphics-UI-SDL-Primitives.html
15:17:59 <systemfault> jmcarthur: Well, perhaps that my fault, I didn't patch LLVM because of the mail on LLVM list saying that trunk have the patches merged
15:18:07 <bum> Oh, didn't know about the bindings! :)
15:18:46 <ski> (fax : i called `replace' `(!!<-)' in an old laboration, with nice reading)
15:19:29 <monadic_kid> bum: I've never used it though, if i remember correctly you'll have to build SDL gfx for windows, some linux distrubutions have prebuilt rpms
15:20:09 <monadic_kid> "yum install SDL-gfx" then "cabal install SDL-gfx" should be good to go
15:20:29 <ski> (ivanm : btw, why no `let' in lambdabot ?)
15:21:13 <bum> monadic_kid: Yeah, not using an rpm based distro, but I already got SDL-gfx :)
15:23:57 <carter> hello, is this the right place to ask about getting a working login for the haskell summer of code 2010 site?
15:24:12 <Alpounet> systemfault, you should check my blogpost
15:24:17 <Alpounet> especially the last 2 comments on it
15:24:31 <Alpounet> (hey, you there ? didn't know you were haskelling too heh)
15:25:20 <carter> or is there a different forum i should go to?
15:26:15 <ivanm> ski: hmmm?
15:26:19 <systemfault> Alpounet: :)
15:26:24 <ivanm> oh, why I don't like people using @let ?
15:26:34 <ivanm> because people like copumpkin keep doing stupid things with it
15:26:39 <Alpounet> haha
15:27:22 * ski doesn't specifically remember copumpkin doing that ..
15:27:24 <Zao> > let omg wtf = wtf in omg "bbq"
15:27:25 <lambdabot>   "bbq"
15:27:28 <Zao> @let is an abomination.
15:27:28 <lambdabot>   Parse error: SemiColon
15:28:22 <ski> the `let' command is useful sometimes to explain things, when you prefer making an auxilary definition, rather than cramming everything into one message
15:28:53 <ski> also, it is useful to secretly define strange functions, and confound bystanders with it
15:28:53 <Zao> Bordering on running it through codepad or so.
15:29:07 <Zao> Cale `fmap` LastName.
15:29:26 <ski> (Caleskell is another thing)
15:29:30 <byorgey> carter: this is as good a place as any, but I guess no one who's reading the channel right now knows how to get you a login...
15:29:39 <Zao> I wonder how hard it would be to get a middle name changed to `fmap`.
15:29:42 <Alpounet> is there any formal definition of Caleskell somewhere by the way ?
15:29:44 <ivanm> ski: the latter is what I hate about it
15:29:52 <Zao> "Oh, it has african roots.'
15:29:54 <ivanm> Alpounet: AFAICT it's "everything is a Functor"
15:30:00 <systemfault> Alpounet: I didn't patch LLVM because of that http://www.haskell.org/pipermail/cvs-ghc/2010-March/052909.html
15:30:07 <Zao> Everything is a functor, and so are you.
15:30:10 <systemfault> Alpounet: Perhaps it was a bad idea..
15:30:18 <ski> ivanm : why ?
15:30:18 <Alpounet> systemfault, don't think it's the problem actually
15:30:27 <byorgey> carter: you might also try asking in #haskell-soc
15:30:35 <Alpounet> I rather think it's a *VERY* recent patch in GHC's repo
15:30:36 <carter> byogey: ah, thanks!
15:30:45 <ivanm> ski: because we shouldn't scare newbies away
15:30:59 <ivanm> especially when they're patently fake functions that don't do anything useful
15:31:01 <ski> ivanm : i mean, i can understand disliking the typical `omg' function exemplified by Zao above .. but functions that are interesting ?
15:31:17 <ivanm> ski: interesting, maybe
15:31:32 <ivanm> but when people keep doing those omg functions, it's just stupid and abusing @let
15:31:36 <ski> (such as my recent `covr :: [[a] -> a] -> [a]')
15:31:41 * ivanm is also against Caleskell
15:31:44 <ski> ivanm : agreed
15:31:48 <Libster> lol caleskell
15:31:55 <systemfault> Alpounet: Hmm, what mode did you use in your build.mk? (If you touched it)
15:31:57 <Libster> lololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololo
15:31:57 <Libster> lololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololo
15:31:57 <Libster> lololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololo
15:32:00 <systemfault> ...
15:32:01 <ski> (to the former part, i.e.)
15:32:02 <Libster> lololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololololo
15:32:04 --- mode: ChanServ set +o Cale
15:32:07 <ski> Libster : please stop
15:32:08 --- mode: Cale set +b *!*@pool-173-73-27-43.washdc.fios.verizon.net
15:32:08 --- kick: Libster was kicked by Cale (Libster)
15:32:14 --- mode: Cale set -o Cale
15:32:29 <Alpounet> systemfault, the two ones I list
15:32:32 <Alpounet> let me find them
15:32:55 <Alpounet> systemfault:
15:32:56 <Alpounet> GhcWithLlvmCodeGen = YES
15:32:56 <Alpounet> GhcEnableTablesNextToCode = NO
15:33:00 <Zao> ski: beardLength, nickLeetness, etc?
15:33:11 <systemfault> Alpounet: I did too :)
15:33:11 <ski> Zao : sorry ?
15:33:24 <systemfault> Alpounet: And for the mode, I uncommented "perf"
15:33:26 <Zao> There was great parroting in the past with those computations.
15:33:34 <Alpounet> systemfault, where ?
15:33:46 <HugoDaniel> libster blew himself up
15:33:55 * ski thinks Caleskell is interesting, for the opportunity to think about "what if ?", but thinks it should be optional, and off by default
15:34:05 <ivanm> ski: exactly
15:34:08 <ivanm> it scares away newbies
15:34:11 <Alpounet> systemfault, see http://alpmestan.wordpress.com/2010/03/11/getting-ghc-head-and-llvm-working-together/#comment-73
15:34:31 <Alpounet> ivanm, no reference page for caleskell ?
15:34:35 <Alpounet> no hwiki page ?
15:34:38 <ski> (e.g. there could be a command to turn it on for a specific user .. or turn any alternative bindings-set on)
15:34:38 <Alpounet> that's a shame
15:34:44 <Alpounet> =)
15:34:45 <ivanm> Alpounet: ask Cale, not me ;-)
15:34:50 <Alpounet> heh
15:35:01 <Alpounet> there is a functorial (.) iirc, right ?
15:35:12 <systemfault> Alpounet: (Opps, I'm dumb... didn't check the comments)
15:35:35 <tehgeekmeister> is there a function that takes a predicate and a list and returns a list of lists which are separated by items satisfying that predicate?
15:35:42 <Alpounet> systemfault, by the time I did all these stuffs, everything just worked out of the box
15:35:45 <ski> Zao : not sure i noticed
15:36:06 <Alpounet> so it's probably about reverting some patches from GHC's repo
15:36:15 <d-snp> well thanks for the info guys, next quarter I'll have a functional programming course (with haskell) so I might be back :) cya!
15:36:27 <systemfault> Alpounet: I think I'll do what he suggests
15:36:34 <Alpounet> indeed
15:36:38 <ski> d-snp : ok
15:37:04 <ivanm> tehgeekmeister: takeWhile ?
15:37:17 <ivanm> group ?
15:37:26 <Alpounet> @type (.)
15:37:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:37:34 <Alpounet> yeah, that's caleskell
15:37:35 <ski> @type (Prelude..)
15:37:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:37:37 <systemfault> Alpounet: Hmm, are you familiar with darcs? Is it easy to checkout 6.13.20100228 ?
15:39:02 <Alpounet> systemfault, you should ask on #darcs, I'm not really a darcs expert
15:39:07 <Alpounet> working on it but... takes time
15:39:13 <systemfault> Ok :)
15:45:55 <tehgeekmeister> ivanm: i could turn that into what i want, but takeWhile only returns the first sublist that doesn't satisfy the predicate, not all of them.  group doesn't seem to do what i want, either.
15:52:31 <c_wraith> @hoogle split
15:52:31 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
15:52:32 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
15:52:32 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
15:52:41 <c_wraith> @hoogle splitOn
15:52:42 <lambdabot> No results found
15:54:42 <liyang> @hoogle splitAt
15:54:42 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
15:54:43 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
15:54:43 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
16:02:11 <pchickey> hi, i'm brand new to haskell and am having trouble with cabal
16:02:25 <pchickey> I'm trying to install tfp-0.2
16:02:31 <Saizan> which kind of trouble?
16:03:02 <pchickey> and cabal install tfp repeatedly hangs at [6 of 14 ]  Compiling Types.Data.Num.Decimal.Literals
16:03:26 <pchickey> it loads a handful of packages , the last of which is QuickCheck-1.2.0.0 ... linking ... done.
16:03:44 <pchickey> then it just hangs for at least five minutes, with ghc taking up 98% of a core according to top.
16:04:36 <pchickey> I'm using ghc 6.10.4 on Ubuntu 9.10
16:05:03 <doserj> pchickey: that module is known to cause long compilation times
16:05:36 <doserj> it creates 10000 type definitions using template-haskell, which simply is slow
16:06:06 <pchickey> I'm sorry, my wifi booted me off for a few seconds.
16:06:34 <doserj> pchickey: that module is known to cause long compilation times
16:06:35 <pchickey> ok, so I
16:08:12 * ski sighs
16:12:00 <sm> strange.. ghc compiles a line like "-- #ifdef" fine, but haddock gives a parse error until I remove the #
16:12:55 <Lemmih> sm: Did you tell haddock to use the CPP extension?
16:13:59 <sm> Lemmih: via LANGUAGE CPP pragma, I guess it does not understand those
16:14:22 <MadHatterDude> Hey guys, I'm riggin' up a friends pc for some hacking, how do you edit file associations on Windows 7?
16:14:35 <sm> no, it does. There are uncommented #ifdefs which it handles fine
16:14:53 <sm> I guess it's interpreting these commented lines as a haddock comment, unexpectedly
16:15:00 <sm> \# makes it happy
16:15:41 <sm> or moving the comments out of that list.. funny. Thanks..
16:15:43 <Phyx-> MadHatterDude: not sure what this has to do with Haskell, but, same way you always did, either right click the file and choose open with and change it there. or open rhe regedit and go to HKCR
16:16:19 <MadHatterDude> Phyx: thx... I'm makimng a right click short cut to a compiling script
16:18:28 <Phyx-> MadHatterDude: you should look at this http://msdn.microsoft.com/en-us/library/cc144169(VS.85).aspx would contain everything you need to know
16:19:08 <Phyx-> MadHatterDude: or rather the parent http://msdn.microsoft.com/en-us/library/bb762787(VS.85).aspx
16:23:27 <flazz> i'm installing cabal-install on ghc-6.12.1, it says to install parsec, i do and then it still complains. what can i do to investigate this?
16:29:08 <Cale> flazz: How are you installing it?
16:29:40 <flazz> Cale: downloaded parsec from hackage, then ./Setup ....
16:30:07 <doserj> cabal-install does not depend on parsec
16:31:32 <flazz> ./bootstrap says it does
16:31:36 <doserj> ahh, indirectly, via HTTP
16:32:17 <watermind> CT question, is there any nice symbol/greek letter for strength and double strength?
16:32:45 <watermind> don't really like the one moggi uses
16:34:19 * ski wonders what "double strength" is
16:34:33 <flazz> i probably want cabal-install 0.8 not 0.6?
16:34:46 <doserj> flazz: which version of parsec did you download? you need parsec-2.*
16:35:27 <flazz> i first got 3 then i got 2 and it went farther but it couldnt parse ghc-pkg dump output, i'm trying cabal-install 0.8
16:35:50 <felzix> Is there a way to make the "error" function *not* stop execution?
16:36:11 <doserj> flazz: if you have ghc-6.12, you need cabal-install-0.8, yes. 0.6 will not work
16:36:14 <ski> felzix : you want it to hang, instead ?
16:36:26 <felzix> ski: no, I want to handle the error intelligently
16:36:40 <ski> then don't use `error' ?
16:36:43 <felzix> ski: My problem is that Data.Map.! throws an error.
16:36:47 <ski> or catch the exception in `IO' ?
16:37:03 <felzix> ski: Ah, that sounds like the thing. I'll look up how to do that. Thanks.
16:37:07 <flazz> the cabal binary seems to be part of ghc, what is the difference between cabal-install and cabal?
16:37:40 <ski> @hoogle Map k a -> k -> Maybe a
16:37:41 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
16:37:41 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
16:37:41 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
16:37:57 <ski> felzix : maybe you could use `lookup', instead ?
16:38:12 <doserj> flazz: the Cabal library is part of ghc. the cabal-install binary (which is just 'cabal'), is not
16:38:25 <felzix> ski: Yeah, thanks :)
16:39:06 <flazz> i seem to have an old version of Cabal
16:39:10 <watermind> I still don't quite get how haskell is pure when it has exceptions
16:39:18 <watermind> I understand the handling is done in IO
16:39:31 * ski idly wonders why `lookup' have the arguments in "wrong" order
16:39:39 <watermind> but isn't throwing it a side effect
16:40:01 <mreh> flip Map.lookup
16:40:08 <mreh> it's annoying :)
16:40:22 <ski> watermind : it is only detectable in `IO', so declaratively, it's attributed to the general nondeterminism of `IO'
16:40:23 <doserj> waterlaz: executing IO actions can have side-effects, yes. evaluating expressions (even of type IO) not.
16:40:49 <ski> mreh : *nod* (the `Prelude.lookup' as well)
16:41:41 <watermind> ski: well I guess I do understand that, if we don't use IO works just like bottom
16:41:49 <mreh> How can I minimise the size of a Data.Map? anyone versed in the inner workings?
16:42:01 <theorbtwo> Hm, really?
16:42:03 <mreh> I'm trying to store 2500^2 numbers
16:42:21 <mreh> > 2500^2
16:42:22 <lambdabot>   6250000
16:42:26 <Cale> mreh: Maybe you ought to use a UArray
16:42:27 <theorbtwo> I'd have thought the RealWorld of IO would be a different monad then the much more general-feeling exception behavior.
16:42:38 <sbahra> mreh, that isn't too large.
16:42:42 <pikhq> watermind: The thing is, IO actions are entirely pure. IO actions merely declare the structure of an imperative program. The execution of the described behavior, however, is *not* pure.
16:42:49 <sbahra> mreh, but are you sure you don't want IntMap?
16:43:07 <Cale> What type is the Map currently?
16:43:10 <mreh> I don't know
16:43:17 <mreh> oh Data.Map (Int, Int) Float
16:43:31 <Cale> Oh, then you could very well use a UArray
16:43:37 <mreh> there are two of these actually
16:43:40 <watermind> ski: on the other hand, what is being done for exceptions could be generalized for other kinds of effects and it isn't
16:43:47 <Cale> At least so long as the (Int,Int) pairs are dense
16:43:54 <flazz> doserj: i had cruft all over the place, cleaning it out helped a lot
16:43:55 <mreh> Cale: yes
16:44:03 <mreh> one of them needs to be mutable also
16:44:06 <watermind> ski: for instance a writer monad (write-only store)
16:44:34 <ski> watermind : do you mean for debugging, or for actual use ?
16:44:39 <Cale> mreh: What are you writing?
16:44:56 <watermind> ski: actual use
16:44:57 <mreh> Cale: Ant Colony Optimisation
16:45:06 <Cale> Ah, okay
16:45:11 <watermind> ski: if you don't read you don't have any side effects
16:45:11 <mreh> it's a 50x50 grid, it's faster to memoize the numbers though
16:45:16 <Cale> Is the Map actually getting too large?
16:45:24 <mreh> Cale: it eats all my memory yes
16:45:26 <watermind> ski: the side effect only occurs when you read
16:45:43 <watermind> ski: so the functions that write to the store could be considered pure
16:45:51 <watermind> ski: using a monad is overkill
16:45:52 <ski> watermind : are you talking generally, or specificall about `Writer o', here ?
16:46:18 <mreh> now I have to generify all my code, weeee
16:46:32 <mreh> usually a good thing
16:46:38 <watermind> ski: generally, I'm saying that using a write only store (which we usually do with a writer monad) could be done in a less intrusive way like exceptions
16:47:04 <ski> watermind : i suppose so
16:47:05 <watermind> ski: functions that just write to the store are pure in the same way that functions that throw exceptions are pure
16:47:10 <mreh> I wrote a generic GA, but I don't think it's as generic as the class one that's already on hackage
16:47:17 <ski> (but then i don't really like how exceptions are handled)
16:47:44 <watermind> ski: so the "magic" could happen only once we read from the monad trasformer
16:47:57 <ski> watermind : they are pure if they can't depend on the store ..
16:48:05 <watermind> ski: exactly
16:48:29 <ski> but then we get that the semantics of the part that does *read* becomes dependent on compiler optimizations, &c.
16:48:37 <ski> (i.e. the "nondeterminism of `IO'")
16:48:41 <watermind> ski: yes
16:49:13 <ski> (and if you don't want to tie this into `IO', how would you do it ?)
16:50:29 <watermind> ski: that would have to be a slightly more evolved type system, I think it was Carsten who studied different classes of side effects according to their algebraic properties
16:50:58 <watermind> ski: and you had classes that were much less premissive than IO
16:51:09 <ski> some kind of effect tracking system ?
16:51:35 <ski> (btw, there's no need for personal attributions all the time, when there's not much other conversation atm)
16:51:38 <watermind> no he didn't get into annotated type systems or even type systems at all
16:52:07 <watermind> he just studied them from a categorical point of view
16:52:33 <ski> hm, which paper are you referring to ?
16:52:45 <watermind> let me check
16:53:21 <Cale> mreh: hmm, on my machine, such a Map takes about 450MB
16:53:46 <mreh> Cale: hmm, mine seems to eat lots and lots of memory
16:53:51 <ski> (watermind : btw, you didn't say what "double strength" was ..)
16:54:05 <mreh> how did you calculate the size precisely?
16:54:26 <mreh> also how long did it take to populate, I timed it at 3 minutes
16:54:30 <Cale> mreh: I created a program which constructed a Map (Int,Int) Float of that size and ran it
16:54:38 <Cale> I'll time it again :)
16:54:59 <doserj> mreh: are you forcing the values you put into the map?
16:55:20 <mreh> doserj: ah, maybe not
16:55:29 <Cale> Yeah, an expression which evaluates to a Float is essentially always going to be larger in memory than a Float
16:55:35 <mreh> I was when I tested it
16:56:21 <watermind> ski: Carsten FÃ¼hrmann. Varieties of effects.
16:56:35 <watermind> ski: In Proceedings of the 5th International Conference on Foundations of Software Science and Computation Structures (FOSSACS 2002),
16:56:36 <mreh> > maxBound Int16
16:56:37 <lambdabot>   Not in scope: data constructor `Int16'
16:56:43 <mreh> > maxBound :: Int16
16:56:44 <lambdabot>   32767
16:56:47 <Cale> It took about 42 seconds to populate my map
16:56:54 <watermind> he only has the first 2 pages on his website
16:57:12 <mreh> Cale: did you calculate each element individually?
16:57:18 <Cale> But that includes the time of all the multiplication that I did in calculating the elements
16:57:40 <Cale> (My map consisted of elements (n,m,x) where x = fromIntegral (n*m)
16:57:45 <mreh> yeah, mine does euclidian distance between that point and everything else
16:57:50 <watermind> ski: oh wait, the full paper is there
16:57:51 <Cale> er, ((n,m),x) rather
16:58:08 <watermind> ski: http://www.cs.bath.ac.uk/~cf/eff_hyper.pdf
16:58:16 <ski> Carsten Führmann <http://www.cs.bath.ac.uk/~cf/eff_hyper.pdf> Varieties of effects
16:58:16 <mreh> thanks for the tips
16:58:28 <OscZA> Are problems related to shared state and concurrency easier to handle in functional programming ? I mean if you really need shared state
16:58:29 <ski> (.. yeah, hunted it down)
16:58:46 <Cale> OscZA: Yes, a bit
16:58:57 <Cale> OscZA: Specifically, you should look at STM
16:59:26 <watermind> as for double strength that would be the morphism  ds : T A x T B -> T(A x B)
16:59:27 <OscZA> Cale: Ok. Is that available in Haskell ? I've read about STM in Clojure
16:59:43 <watermind> need a nice symbol for that
16:59:47 <watermind> but I use t for terms
16:59:47 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/
16:59:49 <Cale> yes
16:59:52 <Makoryu> OscZA: Yes, it works great in Haskell
16:59:58 <OscZA> Ok, thanks
17:00:01 <Cale> (It was in Haskell before it was in Clojure :)
17:00:03 <Makoryu> OscZA: For many of the same reasons that it works well in Clojure
17:00:08 <mreh> do the bang patterns and $! only evaluate a redex to whnf?
17:00:14 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf -- this paper specifically
17:00:45 <Cale> Actually, I'd be willing to bet it's actually safer in Haskell than in Clojure, since Clojure doesn't have the nice type system we have.
17:01:13 <mreh> do not feed the types D:
17:01:17 <ski> (watermind : hm, looks related to the basic axiom for "necessary" in modal logics ..)
17:01:17 <pikhq> I'd imagine so. You really can't do anything dangerous in the STM monad.
17:01:25 <liyang> STM is the bane of my life. >_<;;
17:01:29 <c_wraith> unsafeIOToSTM >_>
17:01:38 <pikhq> c_wraith: Should die.
17:01:39 <pikhq> :P
17:01:56 <c_wraith> It's useful for debugging.  But should never exist in production code
17:01:59 <pikhq> That's the "Screw sanity, I want to violate transactionality" button.
17:02:22 <liyang> (STM was in Java before Haskellâ€¦ but they didn't have orElse.)
17:02:30 <OscZA> Do you know .NET Linq classes ? They are supposed to be monadic.. What does it really mean ?
17:02:43 <Cale> OscZA: Not a whole lot.
17:02:57 <Cale> OscZA: Basically it means that they support a particular API.
17:03:10 <Cale> :t return
17:03:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:03:14 <Cale> :t (>>=)
17:03:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:03:15 <OscZA> I've found them really nice as you can nicely chain up commands .. it seems like a simple concept
17:03:19 <OscZA> but powerful
17:04:28 <pikhq> OscZA: Yes. That's why we use monads.
17:04:29 <Cale> In terms of programming, a monad M is a type constructor together with implementations of return :: a -> M a and bind, written (>>=) :: M a -> (a -> M b) -> M b
17:05:13 <Cale> You can think of a value of type M a as a "computation" whose result has type a
17:05:25 <Cale> Though the extent to which it resembles a computation varies.
17:05:47 <Cale> For example, lists form a monad, so M a would just be the type of lists whose elements have type a, in that case
17:06:17 <theorbtwo> @instances IO a
17:06:18 <lambdabot> Couldn't find class `IO a'. Try @instances-importing
17:06:28 <Cale> and in the list monad, return x = [x], that is, it just gives you the list of one element
17:06:29 <liyang> OscZA: A monad is just a monoid in the category of endofunctors. What's the problem?
17:06:41 <theorbtwo> @instances-importing IO a
17:06:42 <lambdabot> Couldn't find class `a'. Try @instances-importing
17:06:42 <watermind> ops got to go
17:06:51 <Cale> and xs >>= f means concat (map f xs)
17:07:07 <Cale> That is, apply the function f to each of the elements of the list xs, and concatenate the results
17:07:23 <theorbtwo> liyang: The problem is that if you know what a monoid and a category of endofunctors were, you probably wouldn
17:07:40 <liyang> theorbtwo: ignore me. I'm trolling.
17:07:50 <theorbtwo> 't be asking what a monad is.
17:07:51 <OscZA> Coming from Java world, I think I have problems to understand how you can have such a flexible thing
17:07:56 <mauke> @quote copumpkin lax
17:07:56 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
17:07:57 <theorbtwo> liyang: Yeah.  Sorry.
17:07:57 <dolio> A monad is a monad in the 2-category of 1-categories. What's the problem?
17:08:22 <medfly> OscZA, by having too many mathematicians
17:08:22 <Cale> dolio: hahaha
17:08:39 <theorbtwo> medfly: I think that's the answer to half of the questions about haskell.
17:08:51 <theorbtwo> medfly: I think that's the answer to half of the questions about haskell!)
17:08:58 <Cale> OscZA: So, using this list monad a bit...
17:09:06 <medfly> although, one can argue that the mathematicians came because Haskell was so general.
17:09:09 <theorbtwo> Huh.  That's a bit odd...
17:09:10 <medfly> and therefore attractive.
17:09:18 <Cale> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
17:09:20 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
17:09:22 <OscZA> Cale: so list is a list .. but what makes it a monad ?
17:09:30 <theorbtwo> ...the answer to the other half is "by not having enough programmers".
17:09:32 <Cale> OscZA: The type constructor for lists is the monad
17:09:37 <mauke> >>= and return
17:09:37 <medfly> haha
17:09:42 <OscZA> Cale: I think I can understand the concept of a list (I hope huh..)
17:09:42 <medfly> don't programmers love general things?
17:09:42 <Cale> OscZA: and the implementations of return and >>= make it into one
17:10:15 <Cale> medfly: You would think so, but it seems to be mostly the programmers who are also computer scientists...
17:10:28 <monochrom> No, programmers don't love general things. Example: they don't love non-plain-text programming languages.
17:10:30 <medfly> what does that mean?
17:10:41 <theorbtwo> medfly: Right up to the point that they get too general to actually say anything.
17:10:50 <dolio> There's a fair amount of anti-intellectualism amongst "programmers" in my experience.
17:11:12 <medfly> yeah, some programmers are like that... preferring fast code over decent code, and such
17:11:12 <aavogt> and a fair amount of anti-programmerism amond mathematicians?
17:11:14 <monochrom> In fact they don't love non-deterministic programming languages either.
17:11:22 <pikhq> dolio: These are the fools who keep around a lack of garbage collection. :P
17:11:28 <aavogt> *among
17:11:59 <theorbtwo> I think you need a good mix of understanding and pragmatisim.
17:12:08 <Cale> OscZA: Anyway, from these return and >>= functions, we can implement lots of other functions which work in an arbitrary monad
17:12:13 <OscZA> Cale: It seems like monads are like wrappers ... like M a ... I probably dont understand the typing system very well
17:12:32 <theorbtwo> OscZA: A monad is often very much a wrapper.
17:12:35 <medfly> OscZA, to my shitty understanding of it, that's a good start on an understanding
17:12:39 <Cale> OscZA: Well, in Java, it would probably look like M<A>
17:12:48 <Cale> Or something...
17:12:53 <theorbtwo> >>= unwraps a value and passes it on; return wraps a value.
17:13:09 <Cale> I learned Java back before it had "generics" and haven't really used it since.
17:13:13 <liyang> OscZA: you can think of monads as wrappers for some general notion of computation. (non-determinism with lists, sequencing with state/IO/STM and so onâ€¦)
17:13:23 <OscZA> So, we have a type is able to "wrap" some arbitrary thing ?
17:13:34 <Cale> So, this M is something like a function at a type level, which takes a type and produces another type
17:13:56 * ddarius would indeed suggest a decent grasp of the basics of Haskell's type system before bothering with monads.
17:13:57 <ski> @type ContT . (>>=)
17:13:58 <lambdabot> forall a (m :: * -> *) r. (Monad m) => m a -> ContT r m a
17:14:03 <theorbtwo> OscZA: Well, IO a is a type that wraps an a inside the IO monad.
17:14:14 <Cale> So, yeah, we can have M Integer, or M Bool
17:14:33 <Cale> and what those types mean will be different based on what M is
17:14:43 <OscZA> Ahh.. I see.. I think
17:14:45 <Cale> When M is the list monad, M Integer is the type of lists of integers
17:15:09 <Cale> When M is a parsing monad, M Integer will be the type of parsers which may eat some of a string, and produce an integer result
17:15:35 <Cale> When M is the IO monad, M Integer will be the type of IO actions which if executed might cause some I/O to occur before producing an Integer result
17:15:51 <pikhq> When M is the identity monad, M Integer is the type of statements that result in an integer.
17:15:59 <theorbtwo> (And [Integer] is really just a specal syntax for ([]) Integer, or somesuch.)
17:16:00 <Cale> Er...
17:16:12 <ski> @kind [] Integer
17:16:13 <lambdabot> *
17:16:17 <mauke> > [1, 2, 3] :: [] Integer
17:16:18 <lambdabot>   [1,2,3]
17:16:32 <Cale> When M is the identity monad, M Integer would just be a type of integers (possibly wrapped)
17:16:48 <pikhq> Erm. Right. That was hard to phrase right. XD
17:16:52 <theorbtwo> When M is the Quzztl monad, M Integer is the type of quztkakkle that results in an integer when you quakkle it.
17:17:04 <Cale> theorbtwo: heh
17:17:15 <Cale> OscZA: So that's a few examples
17:17:40 <Cale> OscZA: STM also uses this... STM t is the type of transactions which have a result of type t
17:17:47 <OscZA> So monad is a bit like java interface that defines that it is always associated with some object (a bit like generics)..  and then there are certain operations defined for it .. and the operations are defined on the monad itself? (>>=) bind thing ?
17:18:05 <theorbtwo> Yes.
17:18:09 <Cale> yeah
17:18:19 <Cale> return and >>= are defined separately for each monad
17:18:22 <mauke> it's a generic interface
17:18:24 <OscZA> the operation itself is left for the particular monad to "implement" ?
17:18:29 <Cale> and then in terms of those, you can write code which works with any monad
17:18:30 <pikhq> Yes.
17:18:38 <mauke> OscZA: return is the constructor
17:18:41 <ski> @type mapM
17:18:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:18:45 <theorbtwo> The "java interface" bit is called a typeclass.  Show and Read are other examples that you might be familar with.
17:18:52 <Cale> return is a bit weird from a Java perspective
17:18:59 <mauke> it's a virtual constructor :-)
17:19:01 <Cale> because it is polymorphic in its result type
17:19:12 <Cale> and not many things in OO are really polymorphic in that way
17:19:13 <OscZA> mauke: that is one thing that always confused me... the return type
17:19:25 <OscZA> but I think I get it now
17:19:27 <mauke> huh?
17:19:33 <theorbtwo> OscZA: Well, for Monad Int, the return type isn't polymorphic.
17:19:50 <monochrom> There is no Monad Int
17:20:08 <liyang> s/Int/Spoon/
17:20:14 <theorbtwo> monochrom: Er, yes, for a hypothetical monad named Monad.
17:20:15 <Cale> theorbtwo: Int isn't even the right kind to be a monad
17:20:18 <Cale> oh
17:20:35 <theorbtwo> Bad choice of nomenclature, possibly.
17:20:36 <Cale> That looked like a class constraint
17:20:36 <monochrom> Name clash.
17:20:49 <Cale> anyway...
17:21:01 <OscZA> Cale: how is that different from a function with signature like Object getResult()
17:21:16 <ski> OscZA : "that" being ?
17:21:18 <Cale> OscZA: Let me show an example unrelated to monads for the time being
17:21:21 <Cale> :t fromInteger
17:21:22 <lambdabot> forall a. (Num a) => Integer -> a
17:21:25 <mauke> OscZA: that's not overloaded
17:21:40 <Cale> fromInteger is a function which takes an Integer as its parameter, and produces a result of any type of number that you want
17:21:49 <Cale> > fromInteger 5 :: Float
17:21:50 <lambdabot>   5.0
17:21:54 <Cale> > fromInteger 5 :: Complex Double
17:21:55 <lambdabot>   5.0 :+ 0.0
17:22:00 <mauke> OscZA: haskell has return-type-based overloading
17:22:02 <Cale> > fromInteger 5 :: Word32
17:22:03 <lambdabot>   5
17:22:11 <ski> > fromInteger 5 :: Rational
17:22:12 <lambdabot>   5 % 1
17:22:13 <Cale> :t fromInteger 5
17:22:14 <lambdabot> forall a. (Num a) => a
17:22:16 <monochrom> "Object f(Object)" is different from "<T> f(<T>)"
17:22:32 <Cale> The Java type system doesn't really have the ability to properly express this
17:22:46 <mauke> did you mean: T f<T>(T)
17:22:51 <monochrom> Yes.
17:23:09 <OscZA> nice..
17:23:12 <Cale> > read "5" :: Integer
17:23:13 <lambdabot>   5
17:23:19 <Cale> > read "[1,2,3]" :: [Integer]
17:23:20 <lambdabot>   [1,2,3]
17:23:35 <Cale> ^^ another good example :)
17:23:36 * ski for some reason thought that should be `<T> T f(T)' ..
17:23:37 <Cale> :t read
17:23:38 <lambdabot> forall a. (Read a) => String -> a
17:23:44 <OscZA> how are those functions actually defined ? I thought you couldnt have overloading like that
17:23:49 <theorbtwo> In particular, the type of <T> f<T>(T) is written a -> a in Haskell.
17:23:55 <Cale> The parser to use is selected based on the type demanded
17:24:04 <Cale> Well, first, there's a class:
17:24:07 <Cale> class Read a where
17:24:14 <Cale>   read :: String -> a
17:24:27 <ski> (theorbtwo : in case you've an implicit `forall a. ' in there, yes)
17:24:35 <Cale> (this usage of the word 'class' is rather different from Java's, closer to 'interface' in Java
17:24:48 <Cale> and then we have instances:
17:24:53 <Cale> instance Read Integer where
17:25:12 <Cale>   read str = ...
17:25:26 <Cale> and the instance actually defines how the string is to be parsed
17:25:53 <OscZA> oh... i see
17:26:00 <stevenmarky> Finie!
17:26:10 <theorbtwo> ski: Er, yes.  The way I wrote it is, IMHO, clearer, unless you happen to be a mathematician.  Also, forall is, IIRC, a language extension.
17:26:19 <Cale> and then at compile time, the types are checked, and which instance to use is resolved
17:26:20 <OscZA> this is really good example as I've had a bit trouble understanding how Haskell classes differ from Java interfaces
17:26:54 <Cale> One way to explain the difference is that in Java, the method implementations always travel along with the data they act on.
17:27:24 <ski> theorbtwo : well, `a -> a' (without implicit quantification) can be used inside a bigger type, like in as in `forall
17:27:28 <Cale> In Haskell with typeclasses, the operations travel separately, and are selected based on the type at compile time, but at the point in the code where the specific type is resolved.
17:27:46 <ski> `forall a b. (b -> a -> a) -> ([b] -> a -> a)'
17:28:22 <monochrom> "T f<T>(T)" is unambiguous Java. "f :: a->a" is unambiguous Haskell 98.
17:28:43 <theorbtwo> ski: Doesn't that mean the same thing, even if you remove everything before (and including) the dot?
17:29:04 <Cale> OscZA: You can use typeclass-polymorphic functions to build new typeclass-polymorphic functions that are not actually part of the class definition as well.
17:29:09 <monochrom> Consequently there is no further "you mean ..." or "if you mean ..." or "if you add ..." or ...
17:29:27 <ski> theorbtwo : there is a difference between talking about a type `a -> a' (within a context of some given `a', possibly quantified somewhere), and talking about the former, but implicitly universalle quantified .. even if H98 doesn't allow you to express the difference clearly syntactically, it is still there
17:29:31 <Cale> OscZA: For example, the Ord typeclass, which defines the various ordering operations, (<), (>=), etc.
17:29:34 <OscZA> Cale: what do you mean by "method implementations always travel along with the data they act on" ?
17:29:45 <Cale> OscZA: Well, that's what objects are
17:29:59 <Cale> OscZA: They're effectively tuples of operations and data
17:30:00 <OscZA> Oh.. right..
17:30:04 <ski> theorbtwo : `forall a b. (b -> a -> a) -> ([b] -> a -> a)' doesn't mean the same thing as `forall b. (b -> forall a. a -> a) -> ([b] -> forall a. a -> a)', no
17:30:57 <Cale> anyway, I was saying about this Ord typeclass...
17:30:59 <Cale> :t (>)
17:31:00 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:31:10 <Cale> The typeclass itself doesn't define sort
17:31:21 <Cale> and yet, looking at the type of sort
17:31:23 <Cale> :t sort
17:31:24 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:31:25 <ski> (monochrom : yes. still "the type .. a -> a .." is not unambiguous)
17:31:35 <theorbtwo> ski: But the later is the same as forall a b c. (b -> a -> a) -> ([b] -> c -> c)
17:31:49 <Cale> It takes a list of any type of value which is an instance of the Ord typeclass, and produces a list of the same type.
17:31:51 <ski> theorbtwo : no
17:31:57 <theorbtwo> Hm.
17:32:14 <Cale> Just writing functions in terms of the operations in Ord will result in more polymorphic operations
17:32:16 <theorbtwo> I'm going to have to take more time to ponder this at some other point.
17:32:38 <theorbtwo> Cale: OTOH, that's not anything that you couldn't do in most languages, I think.
17:32:46 <ski> theorbtwo : in general, `forall a. (..a..) -> ...' is not the same as `(forall a. ..a..) -> ...'
17:32:59 <Cale> theorbtwo: Actually, it's quite rare
17:33:29 <Cale> I'm really distinguishing here between ad-hoc polymorphism and typeclass polymorphism
17:33:46 <Saizan> you can't often defer overloading resolution like that
17:33:53 <ski> (theorbtwo : however, `forall a. (..a..) -> ...' would be (more or less) the same as `(exists a. ..a..) -> ...', if `exists' were allowed)
17:34:16 <Saizan> though you achieve similar modularity by other means
17:34:34 <aavogt> > let a :: b -> (a -> a); a = const id; a' :: b -> (forall a. a -> a); a' = const id  in (\id1 -> (id1 1, id1 'a')) (a' ())
17:34:35 <lambdabot>   Inferred type is less polymorphic than expected
17:34:35 <lambdabot>    Quantified type variable...
17:34:41 <Cale> With ad-hoc polymorphism, you just define a function or value at a bunch of different types and the compiler chooses the implementation based on the type, but there's no way to use ad-hoc polymorphic functions to write new ad-hoc polymorphic functions without writing the same code over and over.
17:34:57 <Cale> and so that's the difference with typeclasses
17:34:57 <OscZA> Cale: What is the difference between ad-hoc polymorphism and typeclass polymorphism?
17:35:20 <SamB_XP> OscZA: the latter is less ad-hoc
17:35:30 <SamB_XP> to steal the title off a paper
17:35:39 <Cale> With typeclasses, using a typeclass-polymorphic function without pinning down the specific type involved will result in a new typeclass-polymorphic function.
17:35:58 <Cale> :t let f x y z = x < y && y < z in f
17:35:59 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
17:36:17 <Cale> Here, this f function gets just one definition, and works for all Ord types
17:36:30 <Cale> @let f x y z = x < y && y < z
17:36:31 <lambdabot>  Defined.
17:36:38 <theorbtwo> Cale: This does not seem novel to me.
17:36:42 <Cale> > f "Apple" "Blueberry" "Cherry"
17:36:43 <lambdabot>   Ambiguous occurrence `f'
17:36:43 <lambdabot>  It could refer to either `L.f', defined at <local...
17:36:46 <Cale> oops
17:36:47 <mauke> @undefine
17:36:51 <Cale> shouldn't have called it f
17:36:56 * ski hands Cale `L.f'
17:36:56 <Cale> @let foo x y z = x < y && y < z
17:36:57 <lambdabot>  Defined.
17:37:02 <Cale> > foo "Apple" "Blueberry" "Cherry"
17:37:04 <lambdabot>   True
17:37:11 <Cale> > foo 1 2 3
17:37:12 <lambdabot>   True
17:37:15 <Cale> > foo 1 3 2
17:37:16 <lambdabot>   False
17:37:24 <theorbtwo> Now, what
17:37:26 <mauke> > foo "a" "b" 'x'
17:37:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:37:27 <lambdabot>         against inferred ty...
17:37:37 <liyang> > foo LT EQ GT
17:37:39 <lambdabot>   True
17:37:39 <theorbtwo> what's slightly impressive is ... yes, what you just showed.
17:37:55 <theorbtwo> It's hard to tell here, but that error happens at *compile* time.
17:38:25 <aavogt> @vixen do you have a compile time?
17:38:26 <lambdabot> I have nothing but time
17:39:24 <theorbtwo> Not only does the type signature of foo state that all three must be of the same type (that implements Ord), but we never actually told ghc what the type was; it figured that out itself.
17:39:35 <Cale> In a dynamically typed language, you can do similar things, but the problem there is typically that you have to have a sufficiently general (<) to begin with
17:40:03 <OscZA> I think many of my problems of understanding monads stems from the fact that really passing a function isnt that ordinary in Java world
17:40:26 <mauke> maybe start with list functions then
17:40:27 <Cale> OscZA: Absolutely, that's probably a major part of the difficulty a lot of people have starting out.
17:40:31 <mauke> define your own map, filter, etc
17:40:32 <OscZA> maybe these Ruby guys find it easier, I've understood its common practice in there
17:40:33 <theorbtwo> Cale: That's not as big a problem as you think it is; the problem is that by it's nature, you cannot detect type mismatches at compile time.
17:41:00 <theorbtwo> OscZA: Yeah, that's because it's a pain in java; you have to pass around an object and call a method on that object instead.
17:41:02 <aavogt> you can dispatch on type in a dynamically typed language?
17:41:10 <OscZA> someone on this channel once mentioned its quite like the Strategy pattern.. now I understand it better
17:41:16 <theorbtwo> aavogt: Yeah, it's quite common.
17:41:22 <aavogt> or is Data.Dynamic more or less all you can get?
17:41:29 <theorbtwo> $object->method is dispatching on type.
17:41:35 <Cale> Yeah, you can dispatch on the dynamic "type" of the value.
17:41:36 <aavogt> theorbtwo: I mean stuff like read
17:41:57 <sepp2k> @pl \x y -> f (g x y)
17:41:57 <lambdabot> (f .) . g
17:42:03 <Cale> Dynamically typed languages are like statically typed languages which only have one type.
17:42:05 <theorbtwo> aavogt: You can't dispatch on *result* type, no, you dispatch on *argument* type.
17:42:12 <Cale> and that type has cases for all the possible values :)
17:42:29 <OscZA> Cale: I think you once (or twice) said about "design patterns" being defects in the language ... Do you have some examples in mind of the common OO design patterns and how it's done in Haskell?
17:43:03 <jmcarthur> those cases basically just don't appear
17:43:26 <OscZA> Cale: that's interesting.. I've been wondering about types on a meta-level and what kind of beasts they really are. Are there any good books on subjects like this ?
17:43:29 <theorbtwo> aavogt: OTOH, Read is a really bad example, because you don't really want to dispatch on return type with read.  You should really dispatch based on what the string looks like.
17:43:30 <aavogt> @docs Control.Exception
17:43:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
17:43:48 <Cale> OscZA: The standard text is "Types and Programming Languages" by Pierce.
17:43:53 <jmcarthur> i haven't really felt like i ever needed to somehow adapt the abstract strategy factory pattern to haskell before
17:44:26 <jmcarthur> (and if i did i would slap myself for designing with design patterns anyway)
17:44:40 <Cale> Yeah, the most common patterns present in Java are sort of specific to Java, or at least languages close enough to Java.
17:44:52 <sepp2k> @pl \x -> f x $ g x
17:44:52 <lambdabot> ap f g
17:44:58 <aavogt> there are patterns in haskell code
17:45:03 <jmcarthur> yes there are
17:45:13 <jmcarthur> they have a different feeling to me
17:45:16 <Saizan> in haskell you'd just take a function that returns values of the desired type
17:45:17 <Cale> There's something to be said about how something similar to Model-View-Controller is enforced by the IO monad.
17:45:55 <Saizan> a nice haskell pattern is "write an interpreter for it!"
17:46:20 <Saizan> possibily fusing it with the AST to get better performance
17:46:40 <sm> nice, reliable regexps: http://code.google.com/p/re2
17:46:54 <jmcarthur> yeah we need to bind to that
17:46:55 <aavogt> also it is sort of a design pattern to write   data A = forall a. C a => A a,      f :: [A] -> ..., when you really mean   f :: [exists a. C a => a] -> ...
17:47:17 <mauke> sm: can they parse (a{9999}){9999} ?
17:47:32 * sm doesn't know
17:47:48 <Saizan> @hackage regex-tdfs
17:47:49 <lambdabot> http://hackage.haskell.org/package/regex-tdfs
17:47:50 <Saizan> @hackage regex-tdfa
17:47:50 <lambdabot> http://hackage.haskell.org/package/regex-tdfa
17:47:51 <ski> aavogt : i'd call it a workaround
17:47:51 <theorbtwo> Interesting; I was just reading about that from a link on perl5-porters.  I'm not sure reliable is the word I'd use.
17:48:11 <ski> (but then, maybe a workaround is the same as a design pattern ?)
17:48:14 <OscZA> What is there in the properties of a design pattern in some arbitrary language that makes it a "defect in the language" ? Are there certain "primitive" design patterns that should be implemented directly in a language ?
17:48:54 <Cale> OscZA: Well, a design pattern is a similarity in code which comes up often, and is recognisable as a pattern by humans.
17:48:56 <Saizan> ski: (that was the idea)
17:49:02 <ski> (aavogt, also s/exists a. C a =>/exists a. C a *>/ with standard explanation ..)
17:49:13 <jmcarthur> OscZA: no, i'd say the problem is that the language itself doesn't have the facilities to create the abstraction as a first class object
17:49:26 <Cale> OscZA: If you see repetition in code, as a good programmer, your gut response should be to remove the repetition.
17:49:53 <Cale> OscZA: Design patterns are repetition that's left over because of various technical reasons.
17:50:02 <theorbtwo> Exactly.  A design pattern exists where you can write English about the repition, but you can't write code about it.
17:50:05 <aavogt> ski: I think you've explained this to me before, but I've since forgotten that distinction
17:50:07 <Zao> Cale: I have to fight that impulse when coding C++.
17:50:11 <Zao> Sometimes it's not worth it.
17:50:21 <mauke> OscZA: http://blog.plover.com/prog/design-patterns.html
17:50:27 <ski> aavogt : "think of the dictionary translation"
17:50:49 <OscZA> good answers
17:50:50 <ski> (i'll (re?)explain, if you don't see it)
17:50:56 <theorbtwo> I see a fair bit of that in my Haskell code, but I'm not convinced that it's becuase Haskell can't factor it out, rather then because I can't.
17:51:35 <medfly> it's not like writing s [] = something and s (x:xs) something else is that much better than foldr
17:51:45 <Cale> theorbtwo: Well, that's a good point too.
17:52:02 <aavogt> ski: what does *> instead of =>  mean?
17:52:27 <Alpounet> @index (*>)
17:52:27 <lambdabot> bzzt
17:52:35 <aavogt> @type (*>)
17:52:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
17:52:39 <aavogt> but it's not that
17:53:03 <Cale> aavogt: It's ski's syntax for pairing the typeclass dictionary with a value
17:53:21 * hackagebot adaptive-tuple 0.1.1 - Self-optimizing tuple types  http://hackage.haskell.org/package/adaptive-tuple-0.1.1 (JohnLato)
17:54:18 <OscZA> So it's a bit like reducing 8/4 to 4/2 ... and how close you get to 1/2 defines how "good" the language is in this sense ? Does Haskell get at 1/2 in your opinion? Is the ultimate language of computation?
17:54:21 <Saizan> *> is a bit weird, since > is really part of the => which is a double-arrow, we don't have a symbol for double-product though, maybe a circled one?:)
17:54:35 <OscZA> it ^^
17:55:02 <mauke> OscZA: no, haskell still sucks
17:55:07 <ski> medfly : well, i'd say the `foldr' is better (at least in more complicated examples) .. but then there's the problem of `foldr' not composing easily with other looping hofs
17:55:43 <ski> Saizan : i'm open to better syntactical suggestions :)
17:55:53 <medfly> @yes
17:55:53 <lambdabot> Maybe you meant: let oeis yow
17:56:14 <aavogt> ski: I see it now. Is it implemented somewhere?
17:56:25 <ski> aavogt : not to my knowledge ;)
17:56:37 <mauke> medfly: http://mauke.ath.cx/stuff/haskell/yes.hs :-)
17:56:49 <ski> (i've just invented the syntax here, to be able to explain the difference)
17:57:01 <OscZA> mauke: What kind of computations are still hard to express even with Haskell ?
17:57:40 <mauke> OscZA: meta-code
17:57:57 <ski> (Saizan : .. but i'd like an assymetric symbol, i think)
17:58:00 <mauke> generating haskell code in haskell (at compile time) is much harder than necessary
17:58:13 <Cale> OscZA: One thing which would be nice to have in Haskell is a proper record system with row polymorphism.
17:58:40 <ski> module functions (aka functors)
17:58:41 <theorbtwo> Hm.  Is deriving special-cased?
17:58:47 <ski> theorbtwo : yes
17:59:05 <theorbtwo> One cannot make a typeclass Foo that supports deriving (Foo)?
17:59:23 <ski> theorbtwo : iirc, there is (or at least was, not sure) support for defining new deriving classes in GHC with generic classes
17:59:46 <medfly> mauke, ??
17:59:47 <ski> also, there's `newtype'-deriving, which works for any classes
17:59:49 <OscZA> mauke: do you mean a bit like the "annotations" in Java ?
18:00:04 <Cale> OscZA: He means like lisp macros
18:00:07 <mauke> OscZA: I don't know what that is, but I mean something like lisp macros
18:00:22 <ski> or like MetaML staged computations
18:00:22 <OscZA> btw, is Haskell a "homoiconic" language? (I learned this term from a Clojure tutorial text)
18:00:41 <ski> (or MetaOCaml, if you prefer)
18:00:47 <ski> OscZA : it is not
18:00:48 <Cale> OscZA: It's not.
18:01:09 <Cale> Haskell has too much syntax to make that practical.
18:01:25 <ski> (although see liskell)
18:02:08 <OscZA> Ok.. so homoiconic languages tend to have a simple syntax I take it ? Interesting property in itself..
18:02:12 * drdr is like ...
18:02:46 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23941#a23941
18:02:52 <dankna> so I'm writing a replacement for plugins
18:02:54 <Cale> OscZA: Well, because the syntax has to also be capable of representing a value in the language.
18:03:01 <dankna> because that's easier than understanding why it doesn't work with 6.12 and how to fix it :(
18:03:08 <dankna> and I only need a tiny portion of its functionality
18:03:37 <dankna> my code, shown in its entirety at that link, works fine for the case where I use the value before exiting out of the Ghc monad
18:03:44 <dankna> but if I try to return that same value, no dice
18:03:51 <dankna> does this have something to do with laziness? :)
18:03:55 <OscZA> Cale: yes.. Do you think its a really important property of a language or a mere bonus that makes some things easier?
18:04:20 <Cale> OscZA: Well, I get by without it most of the time. It's a nice thing to have, and makes macros a lot simpler.
18:04:43 <Cale> It's really nice to be able to extend the language you're using in that language itself.
18:05:15 <OscZA> In practice, for what kind of things would you usually need macros or such in Haskell ?
18:05:23 <ski> OscZA : for meta-code (not necessarily macros), i think it ought to be required .. but i don't think there is a need for data in general to look that similar to code
18:05:52 <ski> OscZA : defining nicer syntax for DSLs with binders
18:05:54 <OscZA> It sounds like a nice and elegant thing to have...
18:06:38 <Cale> Well, you might want, for example, a library for doing prolog-style logic programming in Haskell.
18:07:10 <Cale> (This would be an example of such a DSL with special binding forms)
18:08:03 <Cale> It's nicer to use real variables and patterns than it is to use strings and pattern representations which don't look like the things they're matching.
18:08:07 <OscZA> DSL = domain specific language?
18:08:09 <ski> also, defining your own mini-language (or new syntactic category) .. e.g. as clauses in a looping construct (a la Shivers' one)
18:08:12 <ski> yes
18:08:59 * ski wonders when one would use strings, there ..
18:09:12 <Cale> ski: for the names of variables
18:09:13 <OscZA> Oh yeah, I had some questions about DSLs btw.. I've run into this term often here
18:09:35 <aavogt> Cale: is it just a question of having enough instances of classes like Language.Haskell.TH.Lift but also for patterns?
18:10:12 <Cale> Well, we could use TH to do something like this.
18:10:18 <Cale> (I think...)
18:10:19 <ski> (Cale : i'd go for `exists :: Variable a => (a -> Logic b) -> Logic b' or `free :: Variable a => Logic a' ..)
18:10:33 <OscZA> So is it that when you "solve" some particular problem in Haskell, you tend to create a DSL on the way? Is that some thing you get for free if you manage to solve the problem in functional terms, or you do have put in an extra effort for it ? (generally speaking)
18:10:56 <ski> (or prettifications of using those, from something looking closer to Prolog)
18:11:13 <Cale> OscZA: Well, we do tend to do that
18:12:15 <aavogt> derive is quite impressive
18:12:40 <OscZA> Why is it that when you solve the same problem in say Java, it isn't that likely to create DSL on the way ?
18:13:13 <aavogt> are we distinguishing between embedded domain specific languages and those that are separate?
18:14:31 <theorbtwo> For what it's worth, I think DSLs are something that gets thrown around a lot in a confusing way.  A ruby programmer might call something a DSL when a Java programmer would call it a library.
18:15:00 <theorbtwo> Is parsec a library, or is it a domain-specific language for parsing?  How about yacc?
18:15:29 <theorbtwo> I think yacc is more of a domain-specific language in exactly the same way as it is a worse solution.
18:15:50 <[swift]_> i must be missing something obvious. can anyone tell me how i can get rid of the obvious repetition in this code, given the type situation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23946#a23946
18:16:06 <aavogt> there's happy, if you want something similar in haskell
18:17:19 <OscZA> I'm just looking for some properties in the languages that are making creation of DSLs easier / more difficult... The answers are probably related to why design patterns are used in OO and why Monads are so powerful ..
18:17:23 <ski> [swift]_ : by "duplication", i presume you mean the `map fst $ ' ?
18:17:32 <OscZA> Just interested what the gurus say to this
18:17:39 * hackagebot attoparsec-iteratee 0.1 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.1 (GregoryCollins)
18:17:41 <ski> hm, interesting
18:17:50 <[swift]_> ski: yeah
18:18:01 <theorbtwo> aavogt: I do not.
18:18:08 <aavogt> just checking
18:18:46 <aavogt> theorbtwo: but parser or lexer generators tend to be faster
18:19:43 <ski> [swift]_ : in this case, i don't you can do better (except than to factor out each `map fst $ 's in a new definition, if you're going to call `map fst $ lexRules cfg' in many different places)
18:20:08 <theorbtwo> OTOH, you could make a good argument that that just means the optimizer needs improving for that particular workload, no?
18:20:23 <ski> [swift]_ : it might be that you could factor out the `map fst $ ' out of the appendings, if haskell had first-class existential types .. alas, that is not the case
18:21:19 <liyang> [swift]_: something like, ids cfg = map ($ cfg) [fst . lexRules, fst . synRules, fst . deletionRules]
18:21:37 <[swift]_> ski: haha, well at least i'm not missing anything. it stood out as ugly to me when looking over my code, but i couldn't see how to improve it
18:21:59 <ski> hm, point, the `map' can be factored out (and the `cfg')
18:22:10 <[swift]_> liyang: hmm, interesting, let me try that
18:22:35 * ski thinks the comments must lie there, though ..
18:22:36 <liyang> [swift]_: I'm not convinced the commented-out types in your paste make sense wrt the code below though.
18:23:38 <ski> liyang : hm, but maybe you need `concatMap', then ?
18:23:53 * ski is not sure
18:23:56 <[swift]_> liyang: i might have made a mistake in the code as i haven't actually tried compiling it yet, but it seems like it should work; i have various types of things identified by strings, and i'd like to just get a list of all those identifiers
18:24:33 <liyang> ski: Perhaps. But I'm confused about those comments as you are. :-/
18:24:41 <ski> [swift]_ : your comment claims `lexRules cfg' is not a list, yet you call `map' on it
18:24:59 <[swift]_> oh, that's an error in the comments
18:25:04 <ski> ty
18:25:12 <[swift]_> those should all be lists of 2-tuples, not just 2-tuples
18:25:21 <liyang> In which case you'll want concatMap
18:25:21 * ski suspected so
18:25:24 <[swift]_> sorry about that haha
18:26:06 <liyang> oh wait. No.
18:27:58 <ski> @type let lexRules :: Char -> [(String, String)]; synRules :: Char -> [(String, [Expression])]; deletionRules :: Char -> [(String, String)]; (lexRules,synRules,deletionRules) = undefined in \cfg -> (map fst $ lexRules cfg) ++ (map fst $ synRules cfg) ++ (map fst $ deletionRules cfg)
18:27:59 <lambdabot>     Not in scope: type constructor or class `Expression'
18:27:59 <aavogt> [swift]_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23946#a23947
18:28:11 <ski> @type let lexRules :: Char -> [(String, String)]; synRules :: Char -> [(String, [Bool])]; deletionRules :: Char -> [(String, String)]; (lexRules,synRules,deletionRules) = undefined in \cfg -> (map fst $ lexRules cfg) ++ (map fst $ synRules cfg) ++ (map fst $ deletionRules cfg)
18:28:12 <lambdabot> Char -> [String]
18:28:50 <liyang> Think you're stuck with that. Any factoring out would make it look worse. But you can write map fst (lexRules cfg) ++ map fst (synRules cfg) ++ map fst (deletionRules cfg) which looks better.
18:29:00 <ski> @type let lexRules :: Char -> [(String, String)]; synRules :: Char -> [(String, [Bool])]; deletionRules :: Char -> [(String, String)]; (lexRules,synRules,deletionRules) = undefined in \cfg -> concatMap ($ cfg) [map fst . lexRules,map fst . synRules,map fst . deletionRules]
18:29:01 <lambdabot> Char -> [String]
18:29:05 <[swift]_> aavogt: haha whoa, that's beyond my comprehension at this point =)
18:29:11 <liyang> (function application binds tighter than ++)
18:29:35 <[swift]_> liyang: that does look better; i'll make the change. thanks!
18:29:49 <ski> [swift]_ : so, you can factor out the `cfg', at least
18:30:24 <liyang> ($ is useful, but don't use it absolutely *everywhere*)
18:31:34 <[swift]_> ski: i'm not sure whether it's worth it though
18:31:34 * liyang thinks aavogt is trolling.
18:31:53 <ski> [swift]_ : probably not here ..
18:32:18 <drk-sd> hey, it's me again
18:32:18 * ski points to the "not that you'd really want to do this, but:"
18:32:27 <[swift]_> haha true
18:32:57 <drk-sd> (i'm sure you all are glad i'm here)
18:34:32 <ski> (drk-sd : maybe if you'd tell us of your latest haskell troubles, we'd be ..)
18:34:54 <drk-sd> i was going to, but Alpounet answered me on another chan
18:34:59 <drk-sd> so i didn't want to bother
18:35:02 <ski> oh, i see
18:35:02 <liyang> [swift]_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23946#a23948
18:35:08 <drk-sd> (but i didn't fear to look stupid)
18:35:17 <drk-sd> (see how brave i am :-Â°)
18:35:30 <drk-sd> (but thank you for your attention ski :))
18:35:35 <dankna> hey
18:35:39 <dankna> unsafeCoerce fixed my problem
18:35:43 <ski> liyang : i'd put the `]' on a line of its own
18:35:46 <dankna> now I know what /that's/ for
18:35:54 <ski> dankna : burn, infidel !
18:36:00 <dankna> mwa ha ha!
18:36:14 <dankna> you'll never stop all of us! :D
18:36:39 <liyang> ski: I would too, but I get enough flack for my coding style as it is.
18:36:40 <aavogt> [swift]_: maybe using antiquotes in the TH: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23946#a23949
18:36:45 <dankna> (actually this is a case, dynamic linking, where I'm pretty sure it's actually reasonable)
18:37:43 <aavogt> liyang: how so? It works
18:37:53 <ski> aavogt : slightly better ..
18:38:52 <dufflebunk> Is there a package for basic geometry stuff, like point in polygon tests and intersection of segments?
18:39:10 <liyang> aavogt: let me know when your implementation evolves to the point when it can read email.
18:39:11 <aavogt> liyang: if it was supposed to be confusing, I would have written the AppEs prefix
18:39:16 <dufflebunk> I've looked on hackage, and I think there must be something simple already made, but I can't find it
18:39:38 <ski> (dankna : you're sure no one won't pass a value of wrong type ?)
18:39:54 <aavogt> liyang: of course you can do IO in template-haskell splices ;)
18:39:57 <dankna> (ski: well, as sure as it's possible to be in this context)
18:40:28 <liyang> Hmâ€¦
18:40:51 <aavogt> @hoogle runIO
18:40:51 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
18:40:51 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
18:40:51 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
18:41:17 <Alpounet> damn, I'm understanding Kan extensions. It's freaking me out.
18:41:33 * twink wishes he understood Kan extensions.
18:42:16 <zygoloid> [swift]_: i think i'd use an existential for the function type
18:42:40 <[swift]_> zygoloid: what is an existential?
18:42:51 <ski> zygoloid : only first-class existentials would be wanted here ..
18:43:01 <zygoloid> data Rules = forall a. Rules :: Config -> [(String, a)]
18:43:37 <ski> (don't mix GADT and ADT syntax, please)
18:43:38 <HugoDaniel> everyday i feel im gettin less bad coding haskell
18:43:54 <zygoloid> ski: d'oh, i'm always doing that :)
18:44:07 <HugoDaniel> but i also feel there is still a long way to go till i get good
18:44:42 <zygoloid> ids cfg = (\Rules f -> fst <$> f cfg) =<< [Rules lexRules, Rules synRules, Rules deletionRules]
18:44:51 <zygoloid> ^^ i /think/ something like that should work
18:45:19 <aavogt> @hoole Name -> ExpQ
18:45:20 <lambdabot> Language.Haskell.TH conE :: Name -> ExpQ
18:45:20 <lambdabot> Language.Haskell.TH global :: Name -> ExpQ
18:45:20 <lambdabot> Language.Haskell.TH varE :: Name -> ExpQ
18:45:55 <[swift]_> zygoloid: i've got to read up on this language feature; i wasn't aware you could do this stuff. this is GADTs?
18:45:55 <aavogt> @hoole String -> ExpQ
18:45:56 <lambdabot> Language.Haskell.TH stringE :: String -> ExpQ
18:45:56 <lambdabot> Language.Haskell.TH.Lib stringE :: String -> ExpQ
18:45:56 <lambdabot> Language.Haskell.TH dyn :: String -> Q Exp
18:46:08 <zygoloid> [swift]_: no, but it's related.
18:46:19 <ski> (zygoloid : because, aiui, `lexRules',&c. would normally be invoked to get all the result .. and using `Rules' like above (which would probably work, modulo the syntax error) feels clunky, and if it's only to be used in this place ..
18:46:48 <ski> )
18:47:15 <zygoloid> ski: yeah, it's a bit awkward having to define a throwaway data wrapper, but it might be worth it if there were a few more functions
18:47:27 <ski> [swift]_ : .. but what do i know. if you prefer zygoloid's solution, by all means, go for it
18:47:55 <zygoloid> at least, it seems less overkill than TH :)
18:48:00 <ski> granted
18:48:16 <[swift]_> i don't know that i prefer, i just don't understand it =) i mean, i can understand what it seems to be doing, but i'm just not familiar with forall
18:48:44 <aavogt> fun2 = sequence $(listE (map (\n -> [| fst . $(dyn n) |]) ["a","b","c"]))
18:48:58 <zygoloid> [swift]_: it's basically declaring a wrapper which contains a function of type Config -> [(String, a)] for some (unknown) a
18:49:46 <[swift]_> zygoloid: yeah, from analogy to mathematics i got the intent. where does type type Config come from, though?
18:49:56 <zygoloid> [swift]_: that's your cfg
18:50:09 <zygoloid> or is that a CFG? ;-)
18:50:15 <[swift]_> zygoloid: ahh, OK. it's a CFG, indeed =)
18:50:19 <ski> [swift]_ : `data Rules = forall a. Rules (Config -> [(String, a)])' (or, in GADT syntax `data Rules where Rules :: Config -> [(String, a)]'), `Rules' is an "existentially quantified data type", which can wrap any function of type `Config -> [(String, a)]', where the type `a' is forgotten
18:51:01 <aavogt> unfortunately, writing the methods as strings doesn't save any space because you could just as easily make your existential constructor one letter
18:51:17 <ski> [swift]_ : which means that even though `lexRules' and `synRules' have different types, `Rules lexRules' and `Rules synRules' have the same type, so they can coexist in a list
18:51:37 <[swift]_> ski: that's pretty cool it! it seems a bit overkill for this situation, but i can see it coming in handy in other places
18:51:59 <aavogt> as said before, existentials aren't first-class
18:52:47 <aavogt> so you may only be replacing one style of boilerplate with another
18:52:52 <ski> [swift]_ : then `\(Rules f) -> fst <$> f cfg' would unpack each `Rules' (where the `a' in `Config -> [(String, a)]' in each case is now unknown, it could be any type at all, but that doesn't matter, since we use `fst' to discard that part) and apply it to `cfg', only keeping the first parts
18:53:03 * hackagebot explore 0.0.7.0 - Experimental Plot data Reconstructor  http://hackage.haskell.org/package/explore-0.0.7.0 (CetinSert)
18:53:27 <ski> [swift]_ : existentials are sometimes handy for "OO-like" situations (canonical example being `[Widget]')
18:53:40 <[swift]_> ski: cool, that makes a lot of sense
18:54:27 <[swift]_> what are the practical ramifications of existentials not being first-class? the fact that you have to manually declare Rules instead of just making your function have that type signature?
18:54:32 <ski> (also, reiterating, if haskell had first-class existentials, it might be that the "obvious" refactoring of your code would go through, without any boilerplate ..)
18:55:32 <ski> [swift]_ : yes, it's mostly that you have to define a new named data-type, and explicitly wrap and unwrap the constructor(s) for it
18:56:07 <aavogt> you can't write functions to lift other functions to operate on the values inside the constructor
18:56:40 <ski> "lift" how ?
18:57:05 <[swift]_> i see. still a very cool feature, though. is there any hope that they'd eventually make existentials first-class in haskell?
18:57:55 <ski> maybe with some caveats .. (like sometimes having to explicitly give at least some type signatures)
18:58:11 <dolio> UHC has them.
18:58:28 <ski> (istr there being issues with deciding how many class contexts to return when you return something existentially quantified, from a function)
18:58:29 <dolio> SPJ is on record saying that he thinks they make GHC's type system too complicated, I think.
18:58:53 <aavogt> as in for:    data T where C a => T a,   and you have some functions    f :: X -> Y X, where you have instances of C a for both the argument and result types, GHC won't let you do        liftT g (T a) = (T (g a))
18:59:31 <felzix> I don't think so, oscza
18:59:40 <felzix> oops, sorry, scroll bar got stuck
19:00:05 <ski> (aavogt : not you too ..)
19:01:19 <aavogt> well there's an error in my f, it should be   f :: C a => a -> Y a
19:01:34 <ski> <ski> (don't mix GADT and ADT syntax, please)
19:01:44 <aavogt> hehe
19:01:54 * aavogt forgot the ::
19:02:56 * ski is not sure what `f' has to do with the latter part ..
19:03:08 <aavogt> but you instead have to write over and over,    f' (T a) = (T (f a))
19:03:15 <aavogt> for each f that you would like
19:03:44 <aavogt> ski: f would be a typical argument to liftT
19:04:53 <ski> maybe you want something like `liftT :: (forall a. C a => a -> exists b. C b *> b) -> T -> T' ?
19:05:29 <aavogt> well once you could write liftT you wouldn't need it
19:06:04 <ski> you mean you'd write `T . f . unT', instead ?
19:06:21 <aavogt> except maybe to avoid having to write type signatures
19:07:00 <aavogt> ski: as in the existential types wouldn't have to be wrapped in constructors in that case
19:07:14 <ski> .. ah
19:07:53 * ski would probably do well, getting some sleep
19:08:24 <aavogt> @localtime ski
19:08:25 <lambdabot> Local time for ski is Sat Mar 13 03:55:07 2010
19:08:37 <liyang> Wat.
19:08:49 <aavogt> sounds reasonable
19:08:59 <liyang> That's a peculiar time zone.
19:09:19 <ski> (sorry, my clock is lagging a bit ;)
19:10:00 <bremner_> @localtime lambdabot
19:10:00 <lambdabot> I live on the internet, do you expect me to have a local time?
19:10:52 <habitue> Hi I'm trying to import a library I've compiled to .o/.hi files, how can I get GHC to pick them up? Do I actually need to make a cabal config and register the library etc?
19:29:49 <HugoDaniel> buyy
19:35:05 <aavogt> habitue`: it's easier if you do just install the library, but if there isn't some fancy build procedure, you can just put the .o .hi and .hs files in Long/Module/Name.*, make sure that ghc's search path includes the directory that contains Long when you try to use those modules
19:35:33 <habitue`> ah ok, I was just naming the files Long.Module.Name
19:35:38 <habitue`> thanks
20:25:30 * hackagebot direct-plugins 1.0 - Lightweight replacement for Plugins, specific to GHC  http://hackage.haskell.org/package/direct-plugins-1.0 (DanKnapp)
20:25:39 <dankna> yay :D
20:26:29 <jeffwheeler> I'm trying to understand the fundamentals of how LLVM and such works, but I'm having trouble seeing how the pieces fit together.
20:26:47 <jeffwheeler> My goal is to get GHC to compile to LLVM, then to an ARM binary, linked against SDL.
20:27:22 <jeffwheeler> Right now, I'm not so much worrying about the Haskell bit; I assume I can get LLVM bytecode from the GHC setup people have been discussing, but I don't exactly see how the LLVM targeting works.
20:28:11 <jeffwheeler> From my understanding, the LLVM I'm getting from Ubuntu's repos (2.27, in Lucid) can't compile an ARM object. It seems like it can build ASM assembly, though.
20:28:51 <jeffwheeler> Theoretically, I can compile this ARM ASM through an ARM assembler, like one I could get through Embedian (Embedded Debian), but I'm not sure this is the normal route.
20:30:01 <jeffwheeler> Should it be possible to directly compile something like simpleapp.bc or simpleapp.ll to an ARM object file, while linking it against ARM object files (i.e. not LLVM object files)?
20:30:45 <jeffwheeler> Or maybe I should be talking to #llvm.
20:37:55 <Alpounet> that'd be better I think yeah
20:37:59 <Alpounet> that's rather llvm specific
20:39:25 <jeffwheeler> Alpounet: alright, doing that; thanks
20:39:47 <Alpounet> jeffwheeler, the llvm channel is on irc.oftc.net
20:40:17 <jeffwheeler> Alpounet: yep, thanks
20:40:42 <jeffwheeler> Alpounet: although it became quiet after your arrival :D
20:41:01 <Alpounet> yeah heh
20:41:18 <Alpounet> I don't think I did something wrong though :p
20:41:55 <jeffwheeler> Alpounet: ha, I think you're fine; I had asked my question and received a few brief responses, but not a lot of help
20:42:43 <Alpounet> ok
20:43:30 <shapr> jeffwheeler: Are you using alpheccar's ARM patches from today?
20:44:04 <jeffwheeler> shapr: I don't know anything about them; are they on a llvm mailing list?
20:44:35 <shapr> I don't think so, I thought you'd magically gotten hold of them: http://twitter.com/alpheccar
20:44:47 <jeffwheeler> shapr: sorry, give me one second; someone just came into my room
20:45:20 <shapr> jeffwheeler: s'okay, you now have all the info I have.
20:47:29 <jeffwheeler> shapr: that looks . . . extraordinarily relevant!
20:48:18 <shapr> yay!
20:48:27 <jeffwheeler> shapr: personally, I'm looking to ARM for the Palm Pre, especially now that PDK is out
20:54:23 <Cale> kw317: Manage to stabilise your connection?
20:54:40 <shapr> jeffwheeler: BUG and N800 for me.
21:01:49 <systemfault> Alpounet: Hey
21:02:04 <systemfault> Alpounet: I think I'm going to cry...
21:02:17 <systemfault> Alpounet: I didn't get llvm/ghc to work yet.
21:04:15 <Alpounet> systemfault: hmm
21:04:21 <Alpounet> what error do you get precisely ?
21:04:43 <systemfault> Alpounet: No compilation errors
21:04:57 <systemfault> Alpounet: Any executable produced segfault
21:05:54 <systemfault> Alpounet: I would like to revert to a certain date.. like the guy said in your blog post...
21:06:23 <systemfault> But looks like darcs isn't really obvious/easy to work with...
21:06:27 <systemfault> Reading the manual
21:08:18 <Alpounet> ok
21:08:46 <Alpounet> systemfault: can you run gdb on these executables ?
21:08:53 <Alpounet> it may give you a clue of what's going on there
21:09:06 <systemfault> I deleted the installation :/
21:09:12 <Alpounet> haha ok
21:09:19 <Alpounet> doing it from the beginning now ?
21:09:23 <systemfault> Yep
21:09:39 <systemfault> I did exactly like on your post.
21:10:00 <systemfault> Except for the LLVM patches..
21:10:51 <Alpounet> yeah hmm
21:15:27 <jmcarthur> systemfault: darcs isn't a snapshotting version control system. it works with sets of patches instead. rather than reverting to a particular snapshot, you must obliterate the patches you don't want from the repository
21:16:25 <systemfault> jmcarthur: So, there's no easyway to rollback to patch 20100228191837 ?
21:17:00 <jmcarthur> systemfault: there's no such thing as rolling back *to* a particular patch
21:17:12 <Alpounet> have to revert patches instead
21:17:32 <jmcarthur> systemfault: you could just try 'darcs obliterate' and then hit 'y' until you have removed enough to be happy
21:17:42 <jmcarthur> for a quick solution not requiring much documentation
21:17:49 <systemfault> Ok
21:17:55 <jmcarthur> and then hit 'd' for "Done"
21:18:24 <Alpounet> brb
21:19:00 <jmcarthur> systemfault: darcs is actually the simplest version control system i know of. you just have to forget all your previous knowledge
21:19:15 <systemfault> I'm just a noob, I'm not judging it
21:19:27 <jmcarthur> i'm not assuming you are. i'm just adding commentary :)
21:19:29 <systemfault> I just don't want to learn it "now"
21:19:44 <systemfault> I would like to get my llvm/ghc working :)
21:19:49 <jmcarthur> gotcha
21:20:18 <systemfault> ls
21:20:21 <systemfault> Oops.
21:22:16 <aavogt> systemfault: darcs put --to-match # or something like that
21:22:48 <systemfault> aavogt: I'll check that if obliterate doesn't work :)
21:22:51 <systemfault> Thank you
21:22:53 <aavogt> but that only works if you know some specific patch
21:23:33 <aavogt> which is more or less what you would do with obliterate anyways
21:30:49 <hopfalgebroid> Question on instancing...  I have something this: instance HopfAlgebra [a] where
21:31:34 <hopfalgebroid> but I need to somehow say that 'a' has + and * defined on it
21:32:22 <hopfalgebroid> *something like this
21:32:30 <aavogt> instance (ClassProvidinPlus a, ClassProvidingTimes a) => Class [a]
21:32:56 <aavogt> or maybe use Num
21:33:20 <Alpounet> instance (Num a) => HopfAlgevra [a] where
21:36:21 <hopfalgebroid> okay, thanks!
21:36:49 <Alpounet> (provided you're actually talking about Num's + and *)
21:38:19 <hopfalgebroid> how would I simply declare a list of Int to be a HopfAlgebra?
21:38:32 <Alpounet> just Int ?
21:38:42 <Alpounet> or any type being an instance of Num ?
21:38:43 <hopfalgebroid> oh wait, I would just define the functions in the HopfAlgebra class on [Int] ?
21:39:00 <hopfalgebroid> well, I'm interested in polynomials over the integers for the time being
21:39:15 <Alpounet> you can just use what aavogt and I proposed you
21:39:23 <Alpounet> and then use it over Ints
21:39:35 <Alpounet> if tomorrow you want to use it over Doubles
21:39:38 <Alpounet> you have it for free :)
21:40:35 <dmead> :t concatMap
21:40:36 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
21:40:59 <hopfalgebroid> oh, right, I'm an idiot
21:41:41 <Alpounet> the idiots I know aren't interested on Hopf algebras :-)
21:41:52 <Alpounet> in*
21:41:59 <hopfalgebroid> well, i'm really aiming at Hopf rings, but one step at a time!
21:44:27 <Alpounet> systemfault, I'm going to sleep (almost 7 AM here...) but keep me posted about your issues
21:44:48 <dbelange> Hello
21:45:01 <dbelange> Does anyone know the formula for the covariance of two functors?
21:46:35 <dmead> ?hoogle transpose
21:46:35 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
21:46:35 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
21:46:35 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
21:46:46 <dmead> > transpose [1..3]
21:46:47 <lambdabot>   No instance for (GHC.Enum.Enum [a])
21:46:48 <lambdabot>    arising from the arithmetic sequence...
21:47:02 <dmead> > transpose [[1],[2],[3]]
21:47:03 <lambdabot>   [[1,2,3]]
21:47:25 <twink> So, to divide by 3 with 32-bit integers, multiply by 2863311531
21:47:30 <dmead> > transpose [[1,2,3],[4,5,6],[7,8,9]]
21:47:31 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
21:47:41 <dmead> how did i not know about transpose
21:47:43 <Axman6> twink: what's that in hex?
21:47:51 * dmead 's ADD is getting worse
21:47:58 <Axman6> :t showHex
21:47:59 <lambdabot> forall a. (Integral a) => a -> String -> String
21:48:08 <Axman6> > showHex 2863311531 ""
21:48:09 <lambdabot>   "aaaaaaab"
21:48:16 <twink> (gdb) p/x ((int)2863311531)
21:48:16 <twink> $3 = 0xaaaaaaab
21:48:23 <dmead> ?src showHex
21:48:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:48:41 <dmead> rutabaga is gross
21:53:05 <SamB_XP> dmead: as long as it doesn't cheat!
21:54:59 <twink> > let egcd' uvw@(u, v, w) xyz@(x, y, z) | w == 1 = uvw | otherwise = case abs w `compare` abs z of { GT -> egcd' xyz uvw ; EQ -> uvw ; LT -> let (f, r) = z `divMod` abs w ; sw = signum w in egcd' (x - sw * f * u, y - sw * f * v, z - sw * f * w) uvw } in let (_, x, _) = egcd' (1, 0, 2^32) (0, 1, 3) :: (Integer, Integer, Integer) in "0x" ++ showHex (2^32 + x) ""
21:55:00 <lambdabot>   "0xaaaaaaab"
21:55:14 <dbelange> Does anyone know the formula for the covariance of two functors?
21:57:00 <Alpounet> systemfault, new comment on my blogpost, should solve your problem
21:58:37 <jmcarthur> daaaang
21:59:13 <jmcarthur> i'm building frag with the llvm backend
21:59:24 <jmcarthur> it's taking all my memory and a ton of swap too
21:59:28 <jmcarthur> i might run out of swap
21:59:49 <jmcarthur> and i have 4GB of ram
21:59:55 <applicative> dbelang: do the words "formula for the covariance of two functors" make sense?
21:59:59 <ezyang> Idea! Make Criterion output ASCII graphs!
22:00:08 <jmcarthur> and iirc i have 4 GB of swap, too
22:00:11 <ezyang> (carry on)
22:00:44 <dbelange> applicative: Yes, you can quantify how covariant functors are.
22:00:53 <jmcarthur> yay went to the next module. looks like i escaped the linux process killer this time
22:01:09 <jmcarthur> oh but here comes the linker
22:01:42 <jmcarthur> aw, undefined references :(
22:01:46 <djahandarie> The Adventure of jmcarthur's GHC-LLVM Compilations
22:02:18 <applicative> debelang:  In other cases where we use the word 'covariance', maybe, but with functors between categories?  A functor is either covariant or contravariant. Am I missing something?
22:02:37 <jmcarthur> djahandarie: it has a sad ending
22:02:54 <jmcarthur> it's a tragedy
22:02:56 <djahandarie> Critics write... "Truely tear-jerking"
22:03:20 <jmcarthur> llvm backend fail
22:06:12 <systemfault> Alpounet: What does he means? :(
22:06:19 <applicative> dbelange: http://en.wikipedia.org/wiki/Covariance covers a sense of the word where we could speak of a 'formula for the covariance of two Xs' but it's hard to see how you'd get that out of http://en.wikipedia.org/wiki/Covariance_and_contravariance_of_functors#Covariance_and_contravariance
22:06:53 <dbelange> Yes, I think it's a pretty deep theorem.
22:09:07 <Axman6> jmcarthur: yeah, you'd think it had only been worked on by one guy for 6 months :P
22:09:07 <applicative> dbelange: Okay, I'm baffled, perhaps a mathematics irc is needed.
22:12:02 <dufflebunk> Anyone know of a package on hackage that does simple geomtry stuff like line segment intersection and point in polygon tests?
22:13:03 <ManateeLazyCat> When you want spawn process, which function do you use? forkProcess or runProcess ?
22:13:23 * ManateeLazyCat I found forkProcess will got bug with executeFile.
22:17:34 <ManateeLazyCat> Read the source code of runProcess, i found it call `c_runInteractiveProcess`.
22:19:13 <ManateeLazyCat> http://www.google.com/codesearch/p?hl=en#A3NG3tctuIg/core/libraries/process/System/Process/Internals.hs&q=runGenProcess_&sa=N&cd=2&ct=rc
22:19:24 <ManateeLazyCat> See above link, at 321 line.
22:21:15 <ManateeLazyCat> Because it add MVar for make sure two thread not *race condition*, so use functoin in System.Process is safe to spawn process.
22:21:39 <Axman6> do you want processes or threads?
22:23:12 <ManateeLazyCat> Axman6: I just found forkProcess have problem when spawn process, special use with gtk2hs.
22:23:49 <ManateeLazyCat> http://www.google.com/codesearch/p?hl=en#RNqXcpfyLBQ/~dsg/gdh/gdh.tar.gz%7C9HlF6gei6dM/gdh/i386-unknown-linux/hslibs/posix/PosixProcPrim.lhs&q=forkProcess%20lang:haskell
22:23:57 <ManateeLazyCat> Above have source code forkProcess.
22:24:29 <ManateeLazyCat> Just simple call `fork`, haven't any protected.
22:24:44 <applicative> dufflebunk: maybe http://hackage.haskell.org/package/SG
22:27:29 <ManateeLazyCat> If you don't use MVar (or other way) to protected when you spawn process, two thread will got *race condition*, if those two processes access same resource, will got problem, it's speical in gtk2hs code.
22:28:32 <ManateeLazyCat> So i recommand don't use `forkProcess` in gtk2hs code, that will crash you program, until make you crazy.
22:28:48 <ManateeLazyCat> I will post this to gtk2hs-list later.
22:31:59 * ManateeLazyCat forkProcess crazy me recently.....
22:34:30 <elly> what.
22:35:54 <ManateeLazyCat> elly: Don't use `forkProcess` in gtk2hs, use `runProcess` or `runCommand` instead.
22:36:23 <elly> it crazies you?
22:36:53 <ManateeLazyCat> elly: If use forkProcess in gtk2hs, two processes will got *race condition* then crash your program.
22:37:28 <elly> I think some of the words from those sentences are missing.
22:37:49 <ManateeLazyCat> elly: You can see the source code of forkProcess.
22:37:59 <elly> Sure.
22:38:31 <ManateeLazyCat> elly: In source code of runProcess, it add MVar to make sure two threads won't got *race condition*.
22:39:00 <elly> sorry, I have to ask: is this an elaborate Star Control 2 joke?
22:42:59 <Dementati> I'd like to sum every number in a very large list. How can I avoid stack overflow while doing this?
22:44:19 <applicative> > sum [1..100000]
22:44:20 <lambdabot>   5000050000
22:44:24 <mjrosenb> Dementati: how are you doing it currently
22:44:34 <mjrosenb> >sum [1..1000000]
22:44:36 <applicative> > sum [1..1000000]
22:44:37 <lambdabot>   * Exception: stack overflow
22:44:38 <applicative> hs
22:44:42 <applicative> ha
22:45:12 <applicative> @src sum
22:45:12 <lambdabot> sum = foldl (+) 0
22:45:19 <Cale> > foldl' (+) 0 [1..1000000]
22:45:20 <lambdabot>   500000500000
22:45:24 <mjrosenb> if we made that foldl'
22:45:27 <mjrosenb> yeah...
22:45:27 <applicative> yeah
22:45:31 <Cale> Compiling with optimisations will also fix the problem
22:46:02 * mjrosenb feels that in general optimizations are not a good substitute for good code.
22:46:07 <Dementati> I see. Thanks.
22:46:24 <applicative> Demtanti:  Have you been doing it in the ghci so far, or compiling
22:46:32 <Cale> foldl (+) 0 is good code for sum though, it's just that GHC does a poor job of compiling it unless optimisations are turned on
22:46:35 <Dementati> applicative: ghci
22:47:00 <mjrosenb> actually, is there any way to get ghci to actually optimize your code?
22:47:13 <systemfault> What?
22:47:14 <Cale> If there are .o files, it will load them
22:47:24 <applicative> If you are aiming at compilation, Cale is probably right, in my experience.  The ghc is aware of what to do with sum xs
22:47:44 <Dementati> It doesn't matter if I compile or not.
22:47:58 <systemfault> mjrosenb: ghci -O2 --make file?
22:48:17 <Dementati> I mean, it doesn't matter to my application if I compile the solution or not.
22:48:53 <applicative> > foldl' (+) 0 [1..10000000]
22:48:54 <lambdabot>   50000005000000
22:49:01 <applicative> > foldl' (+) 0 [1..100000000]
22:49:04 <lambdabot>   mueval-core: Time limit exceeded
22:49:08 <applicative> haha
22:50:01 <applicative> the definition with foldl' doesn't work?
22:55:09 <Dementati> I'll get back to you when my program finishes running. =P
22:55:32 <dmead> > putStr " "
22:55:33 <lambdabot>   <IO ()>
22:56:02 <Veinor> why did haskell have to call join join? :(
22:56:41 <Dementati> Yeah, compiling with -O2 worked.
22:56:45 <Dementati> Thanks, people.
22:57:23 <dmead> dudes.
22:57:25 <applicative> Oh cool.  I was just worried about testing in ghci.  The sameless expedient of compiling a module with mySum = foldl' 0 (+)  and then calling it from another module, opened in ghci doesn't help
22:57:33 <dmead> if i have
22:57:45 <dmead> putStr (show x)
22:57:48 <dmead> x is a string
22:57:54 <dmead> it keeps printing quotes :/
22:58:05 <dmead> what the fook :/
22:58:14 <dolio> That's what show does.
22:58:31 <ezyang> dmead: you prolly want putStr x
22:58:32 <dolio> show s = '"' : s ++ "\""
22:58:44 <applicative> Veinor: Haskell calls join join because that's what it is.
22:58:51 <dmead> you can just pass putstr different types?
22:58:58 <dmead> i thought it was just strings xD
22:59:00 <cknapp> Veinor: it's a monadic join.
22:59:01 <dmead> :t putStr
22:59:02 <lambdabot> String -> IO ()
22:59:06 <Dementati> dmead: Wasn't x already a string?
22:59:14 <Veinor> dmead: also, putstr (show x) is just print x
22:59:16 <ezyang> It makes sense in a type sense: m (m a) -> m a
22:59:20 <ezyang> The monads "join together"
22:59:22 <dmead> oh right xD
22:59:25 <Veinor> well yes, I get that
22:59:35 <applicative> Veinor, doesn't concat seem like a good case of joining?
23:00:03 <applicative> :t concat
23:00:04 <lambdabot> forall a. [[a]] -> [a]
23:00:14 <Veinor> applicative: I think of join as taking two arguments though
23:00:21 <Veinor> the strings to be joined and the separator
23:00:54 <applicative> Veinor, I guess its true, I sort of thing of it as `smashDown`
23:01:23 <dmead> ah yea, i'm a retard
23:01:29 <applicative> Veinor, but you'd think concat, short for concatenate would have two arguments too.
23:01:33 <cknapp> I'm of the opinion that it should be called "multiply" :)
23:01:47 <ezyang> cknapp: Why?
23:01:56 <Veinor> I still kind of want to use inject instead of return in my code
23:02:01 <Veinor> just because.
23:02:26 <ezyang> Veinor: Judicious use of Applicative and Functor mean you don't have to say return!
23:02:40 <applicative> Veinor, it's Haskell, all you do is write inject = return and smashDown = join and you can do what you please
23:02:43 <cknapp> It's the multiplication natural transformation for the monad... in a category thoery sense.
23:02:56 <Veinor> applicative: well, you can do that. the question is should you.
23:03:05 <ezyang> cknapp: Hmm, I guess I'm conflating multiplication with cartesian product
23:03:47 <cknapp> I was mostly making a joke; multiply would be a horribly confusing name for it.
23:04:01 <Veinor> it should be called add, because it adds the two monads into one!
23:08:43 <applicative> Veinor, yes, people should be as wild as pleases them.  See the hackage packages by Jinjing Wang,  he's not going to let opinion stop him. http://github.com/nfjinjing -- they all import  his pleasantly cranky mps  http://hackage.haskell.org/package/mps
23:10:33 <ezyang> that is pretty cranky
23:10:58 <nus> :t (>>=)
23:10:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:11:05 <nus> :t (>>= id)
23:11:06 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
23:11:54 <applicative> ezyang: It is of value because it shows that all of these standard 'operators' are just defined expressions, not really part of the language.  Mere custom.
23:12:50 <ezyang> applicative: Agreed. It's one of the things I really appreciate about Haskell.
23:13:13 <copumpkin> applicative: I just proved that ziplists are one of you
23:13:34 <applicative> copumkin: but did you do it with a proof assistant?
23:13:48 <copumpkin> yep
23:13:52 <applicative> copumpkin: or rather: copumpkin
23:14:05 <applicative> I never bought those academic journal arguments.
23:14:12 <copumpkin> :P
23:16:25 <systemfault> Hey.. I'm a noob and I wonder what do you guys think about monad.. From what I've read, they're like the EVIL side of haskell with side-effects...
23:16:30 <applicative> Have you seen the film of VLADIMIR VOEVODSKY (cut and paste for spelling...) railing against reading the proofs in journal articles, he wants them to be written in something that can be checked
23:16:41 <copumpkin> nope :)
23:16:48 <copumpkin> systemfault: nope
23:17:31 <copumpkin> systemfault: they're fun, don't have much to do with side effects (beyond the fact that we use them to express them), and you probably shouldn't be trying to understand them this early in your venture into haskell :)
23:17:45 <systemfault> copumpkin: Ah ok :P
23:18:15 <systemfault> copumpkin: Just trying to learn with RWH and Project Euler :P
23:18:16 <cknapp> systemfault: monads are a way to abstract the idea of "computation" and to hiding plumbing. Very fun, very useful... but it takes a lot to get your head around them.
23:18:30 <systemfault> Ah ok :)
23:19:20 <systemfault> I always had in mind that using them is getting away from the nice functional side of Haskell
23:19:24 <Berengal> Monads are overloadable semicolons
23:19:43 <systemfault> (Hmm.. too noob to understand that analogy)
23:19:45 <Berengal> systemfault: That's only true of one monad, IO
23:19:45 <copumpkin> lol
23:20:28 <cknapp> Berengal: and the state monad.
23:20:43 <aavogt> or monads that contain IO
23:20:44 <systemfault> My version of Euler #14 http://www.ideone.com/7VH0XuLX
23:20:45 <aavogt> or ST
23:20:49 <applicative> copumpkin: http://video.ias.edu/stream&ref=68  it's a little dull.  He seems to be on about it again, there was a lecture at CMU a few weeks ago on the same theme.
23:20:52 <systemfault> That shows my current Haskell level..
23:21:15 <Berengal> The state monad contains an escape hatch, runState, to return you to your functional idyllic world
23:21:17 <Berengal> (So does ST)
23:21:37 <cknapp> systemfault: they can be used for things that are absolutely pure... such as the list monad.
23:21:52 <cknapp> Berengal: fair enough
23:21:58 <applicative> copumpkin:  I think he's been studying Coq though, with a view to implementing his wild idea -- good luck figuring out what his mad idea is.
23:22:03 <systemfault> cknapp: I'll see if RWH has a chapter on that
23:22:07 <systemfault> (Probably..)
23:23:14 <applicative> copumpkin:  It is pleasing though that a so-called Real Mathematician should take up an interest in super-advanced programming languages.
23:23:15 <cknapp> applicative: does he realize that there are valid proof that are not computable?
23:23:21 <copumpkin> applicative: yeah :)
23:23:34 <applicative> haha, I think there is little he doesn't realize
23:23:41 <ezyang> cknapp: Hah
23:23:42 <copumpkin> cknapp: like what?
23:24:00 <cknapp> Anything which uses the axiom of choice, or the law of the excluded middle.
23:24:09 <applicative> He just wants a general formalism for the formulation of mathematical proofs.  If you don't use the formalism, you cant get checked so you can't get published
23:24:19 * ezyang heard the story of how mathematicians proved that hard problems exist, and then failed to find instances of these hard problems 
23:24:20 <cknapp> Oh. Ok.
23:24:22 <dbelange> cknapp: moron
23:24:31 <applicative> The checking of proofs is trivial.
23:24:32 <copumpkin> cknapp: ah, fair enough
23:24:55 <copumpkin> dbelange: norom?
23:24:56 <nus> applicative, wasn't that what Hilbert wanted once upon a time?-)
23:24:59 <cknapp> dbelange: me? or the guy?
23:25:11 <ezyang> I think in this case the hard problems were hard boolean satisfiability problems
23:25:13 <cknapp> nus: Hilbert, and Frege and Russel... yes.
23:25:14 <applicative> nus: emphatically not.
23:25:33 <cknapp> ... I'm still missing exactly what he's arguing for then.
23:25:51 <applicative> nus:  The checking of an existing proof in a formalism is a trivial programming problem, and can be solved instantly, since a huuman being actually constructed the proof
23:25:52 <copumpkin> cknapp: either way, I reject both of those
23:26:04 <applicative> what is hopeless, is a program for finding a proof, of course
23:26:24 <cknapp> Oh. I get it.
23:26:25 <applicative> no confusion could be greater
23:26:40 <cknapp> Yeah; quite different things.
23:26:50 <dbelange> hence "moron"
23:27:04 <cknapp> :) fair enough.
23:27:29 <applicative> To check the proof you go through all the nodes of a tree that some human actually wrote, and see if they fit with trivial rules like Modus Ponens
23:27:47 <dons> why hasn't anyone uploaded the packrat parser to haskell? http://pdos.csail.mit.edu/~baford/packrat/icfp02/
23:27:47 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:28:16 <applicative> Probably he's right that all existing mathematics could be checked in an afternoon, if it'd been written in The One True Formalism
23:28:31 <dmead> lol
23:28:34 <dmead> whats the one true formalism
23:28:46 <nus> applicative, trees? what about some cyclic graphs, with some xrefs to other? :-P (-;
23:29:07 <applicative> dmead: this is the problem, he explains the difficulties with Automath and similar things
23:29:46 <applicative> dmead: he thinks the existing plans go via a reduction to set theory, which is no good for various reasons.
23:30:17 <applicative> dmead, so he proposes a new Coq that realizes his 'homotopy lambda calculus'.
23:32:46 <applicative> copumpkin, dmead:  see his paper on this mysterious lambda calculus: http://lists.seas.upenn.edu/pipermail/types-announce/2006/000291.html  I think there's another one.
23:33:02 <ski> Berengal : it is not true of `IO', either (or if it is, it is true of other monads as well)
23:33:11 <cknapp> Homotopy lambda calculus? As in homotopical models of dependent type theory? Or...?
23:33:15 <applicative> After I win the Fields Medal, I'm going to go into proof assistants too.
23:33:21 <ski> (applicative : which mathematician is this ?)
23:33:37 <systemfault> Just in case... Nobody compiled llvm+ghc very recently?
23:33:52 <applicative> ski: Vladimir Voevodsky
23:34:00 <dons> systemfault: a couple of weeks ago
23:34:36 <applicative> ski:  I
23:34:44 * ski too
23:34:46 <systemfault> dons: I've been trying 4 times already.. the resulting executables segfaults :/
23:35:09 <dmead> applicative, i'll take a look
23:36:06 <applicative> ski: I mentioned his campaign for a universal formalism mathematicians will have to write in so he doesn't have to check their proofs anyore.  He wants to exercise his aesthetic judgment in accepting or rejecting papers,, not worry about missing cases
23:36:09 <Alpounet> systemfault, still doesn't work ?
23:36:32 <systemfault> Alpounet: Nope.. and the last comment doesn't help :(
23:37:06 <ski> (would you know whether `homotopy' refers to topology or loop theory ?)
23:37:08 <Alpounet> I'll askm him details
23:37:09 <applicative> ski: a somewhat unsuccessful lecture is here http://video.ias.edu/stream&ref=68 from a few years ago, but he's at it again.
23:39:59 <ski> (hm, the video doesn't seem to want to load, atm)
23:40:36 <dons> systemfault: did you patch llvm as instructed?
23:40:43 <dons> and applied the ghc patch to ghc head branch?
23:40:51 <dons> and compiled ghc without tables-next-to-code?
23:41:03 <dons> systemfault: if you follow exactly, and only, the instructions provided  on the wiki, it should be fine.
23:41:15 <systemfault> dons: I didn't patch LLVM because I read that the calling convention has been added to LLVM :/
23:41:26 <systemfault> http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20100308/097632.html
23:41:26 <dons> that's not been tested yet.
23:41:29 <systemfault> :(
23:41:30 <dons> so you tried for the first   time.
23:41:30 <systemfault> Ah
23:41:38 <dons> thanks for testing!
23:41:50 <systemfault> So, now I should use the patch then?
23:41:53 <dons> but you'll still have to patch llvm until ghc knows to take advantage of it.
23:41:59 <systemfault> Ah ok :)
23:42:01 <dons> follow the instructions on the ghc wiki
23:42:54 <systemfault> Ok :)
23:43:04 <applicative> ski: hmm, it's quicktime, there's other ways of getting it at http://video.ias.edu/node/68#attachments
23:44:09 <ski> hm, ty
23:49:23 <ski> (argh, some kind of projector problem)
23:49:46 <nus> applicative, wouldn't that mean that you have to check soundess of the formalism in itself?
23:50:18 <applicative> nus:  yeah, I had a sense lisrtening to him , that fights would break out immediately.
23:51:29 <adu> hi ski!
23:51:40 <applicative> dons: the packrat parser material still compiles, with a few adjustments, should I ask him?  All of my attempts at a useful project are failing.
23:51:41 <nus> applicative, so, ultimately, he is in search of some "true and only" axioms?
23:52:00 <ski> ehlo, adu
23:52:13 <applicative> nus: it isn't that pretentious, if there is a contentious axiom, you make it explicit.
23:52:15 <adu> there is only one "true and only" axiom
23:52:29 <nus> yeah, it's called id
23:52:44 <dbelange> intelligent design
23:53:06 <nus> > let bot = bot in bot
23:53:10 <lambdabot>   mueval-core: Time limit exceeded
23:53:16 <applicative> nus: the problem is forming a common language, not common axioms or whatever, but I'm not sure this distinction is as clear in practice as it is in theory.
23:53:20 <ski> @. djinn type id
23:53:21 <lambdabot> f a = a
23:53:27 <ski> proof of id ^!
23:54:58 <adu> nus: no, its called the axiom of choice
23:56:00 <adu> but my favorite is actually the axioms of separation
23:57:10 <nus> adu, sure, where do you localize 'the meaning'? in the interpreter or in what's being interpreted?
