00:01:13 <arcatan> every random project always seems to be a good GSoC project
00:03:42 <dons> SubStack: there's no reason to host the packages anywhere else -- that would break cabal-install
00:03:55 <dons> if you want to host repos, well, patch-tag.com, code.haskell.org, github, bitbucket etc
00:04:30 <SubStack> cabal can't pull from multiple repos like rubygems can?
00:16:36 <edwardk2> substack the machinery is largely there but untested/refined
00:16:48 <SubStack> got it
00:17:03 <SubStack> I might experiment with this some then locally
00:18:46 <SubStack> gah this module has a warning and also has -Werror turned on, annoying
00:26:56 <mxc> anyone using leksah 0.8?
00:28:59 <kamatsu> mxc: i tried it but i don't use it usually
00:29:56 <SubStack> I can't find a way of telling cabal to -w when building this so it will just install the package already
00:29:59 <danderson> dons: mirroring, but the actual installer files are huge and I'm getting no more than 12kb/sec out of them
00:30:08 <mxc> just kind of playing around with it
00:30:20 <mxc> still trying to figure out how to quickly import an existing, cabalized project
00:30:33 <danderson> is there a copy of the packages sitting on a fast non-killed server that I can grab?
01:11:24 * ksf is willing to indefinitely seed haskell platform torrents
01:11:43 * Zao eyes the idle closet machine on a fat pipe.
01:12:06 <ksf> any of the site admins care to set those up, including haskell.org as http seed and/or more http mirrors?
01:14:16 <scotty> hello!
01:14:58 <ksf> ibiblio might be willing to help, there.
01:15:13 <ksf> failing that, there's always the possibility of abusing say sourceforge.
01:15:42 <ksf> ...or just setting up an appstore site.
01:16:01 <scotty> Does anyone know if there is a nice way to iterate over the values of an n-tuple using recursion?
01:16:03 <ksf> er appengine
01:16:09 <ksf> there isn't.
01:16:30 <Zao> Maybe it can be traversed using SYB or something?
01:16:54 <ksf> the closest thing is Data.Vec
01:16:59 <scotty> Is there a good reason for that?  I wonder if I'm violating some notion by wanting to do this.
01:17:21 <ksf> yes
01:17:25 <ksf> erm
01:17:40 <scotty> I basically just want to define the Euclidean norm for vectors in n-space.
01:17:54 <ksf> (a,b) would need a bifunctor to support map, (a,b,c) a trifunctor
01:18:09 <ksf> oh, you want to use an existing vector library.
01:18:16 <scotty> sqrt(x1^2 + x2^2 + ... + xn^2)
01:18:17 <Zao> What'd you mean by "iterate"?
01:18:20 <Zao> Folding or something?
01:18:31 <ksf> scotty, http://hackage.haskell.org/packages/archive/Vec/0.9.6/doc/html/Data-Vec-LinAlg.html#v%3Anorm
01:18:34 <scotty> I'm a pretty beginner Haskell programmer.
01:19:11 <kmc> scotty, tuples aren't really a container in this way
01:19:24 <kmc> you'll be better off using a more specialized vector type like ksf mentions
01:19:52 <kmc> the simpler solution is to represent your vectors by lists
01:20:00 <kmc> what you lose then is the compile-time typechecking that they have matching size
01:20:04 <ksf> scotty, what you want isn't tuples, but fixed-length list.
01:20:06 <scotty> Yeah, this looks interesting.
01:20:12 <scotty> Ew
01:20:16 <scotty> Lists for vectors?
01:20:29 <ksf> as tuples have heterogenous member types, and lists homogenous.
01:20:45 <ksf> ...at least conceptually, yes.
01:20:48 <kmc> you can always define your own data Vec3 a = Vec3 a a a etc.
01:20:58 <ksf> whether they are really lists depends on length.
01:21:05 <scotty> Yeah
01:21:29 <kmc> but there is no simple way to iterate those fields either
01:21:34 <ksf> like those in http://hackage.haskell.org/packages/archive/Vec/0.9.6/doc/html/Data-Vec-Packed.html
01:24:09 <scotty> What is the point of using the Packed Vector?
01:40:57 <ksf> scotty, space usage
01:42:10 <ksf> ...in general, just don't care, you'd be optimizing prematurely.
01:42:39 <kmc> i imagine it matters for speed via caching as well
01:43:06 <ksf> yes
01:43:32 <ksf> ...but a chunk of vector code is very likely to end up in registers
01:43:40 <kmc> seems like the API is designed around typeclasses that will work with either packed or unpacked data
01:43:50 <kmc> so you don't have to decide now, and should just use the simplest one
01:44:53 <ksf> I guess a dph implementation of the api would be nice, too.
01:45:54 <ksf> ...but possible only useful for bigger vectors, and I don't know whether the type-level stuff would scale
01:46:21 <ksf> someone should really, really implement hardware-accellerated type-level naturals.
01:55:50 <ksf> is there a way to supress a Fields not initialised warning on the source level?
01:56:24 <ksf> ...I'm too lazy to pass a gazillion undefineds into it.
02:08:46 <kevinulin> I am a somewhat novice user trying to use quickcheck from the start of a project, but all of the examples I can find are just cases where the quickcheck program itself is tested, what is the typical way to quick check a seperate program? My guess is that I just mix the quickcheck code in with the logic code and have the main function check a parameter passed in at execution, but I have my doubts
02:10:17 <ivanm> kevinulin: not sure I follow what you're saying
02:10:30 <ivanm> what do you mean by "just cases where the quickcheck program itself is tested"?
02:10:34 <ivanm> there is no quickcheck program...
02:10:56 <kevinulin> well let me rephrase, i am confused by the idea myself
02:10:57 <ivanm> kevinulin: better way: have completely separate testing modules and a separate testing executable
02:11:05 <ivanm> @hackage graphviz
02:11:05 <lambdabot> http://hackage.haskell.org/package/graphviz
02:11:10 <ivanm> kevinulin: ^^ have a look how I do it here
02:11:13 <kevinulin> k thanks
02:14:47 <kevinulin> i looked at your example but i think your situation is different as you are building a library then testing it which will allow you to build a seperate test suite
02:15:20 <ivanm> right
02:15:24 <kevinulin> i guess my question is really, if you have a program which uses the 'main' function, what is the correct way to organize your project so that the test suite also has a main to use
02:15:29 <ivanm> but even with an executable, there's no reason why you can't do the same
02:15:40 <ivanm> since IMHO end users should not have to install and build testing components
02:15:53 <ivanm> the other option is to use CPP to selectively enable testing routines at build time
02:16:10 <Twey> kevinulin: You can have multiple entry modules
02:16:29 <Twey> One might import everything and execute the program, and the other might import everything and run tests
02:17:16 <kevinulin> i see
02:18:37 <kevinulin> so really the correct thing to do is to make 3 different modules: program, test, and common?
02:19:40 <Twey> kevinulin: If you like
02:21:14 <kevinulin> thanks ivanm and Twey
02:21:29 <ivanm> no worries
02:21:50 <ivanm> and yeah, that module setup looks about right
02:22:17 <ivanm> even more so if your "program" module is just the main function, possibly with stuff on dealing with command-line argumetns, etc.
02:22:24 <Twey> Aye
02:22:30 <Twey> Which it should be, really
02:23:39 <ivanm> preflex: seen Axman6
02:23:39 <preflex>  Axman6 was last seen on #ghc 5 hours, 42 minutes and 33 seconds ago, saying: * Axman6 had to add the building to Google Maps for it to show up
02:23:52 <ivanm> @tell Axman6 new registration table! email everyone and tell them to fill it in!
02:23:53 <lambdabot> Consider it noted.
02:30:35 <sinelaw> hi ivanm
02:30:43 <ivanm> hey sinelaw
02:30:50 <sinelaw> how's aushac going along? :)
02:31:16 <ivanm> we have about 8 people registered atm IIRC
02:31:44 <sinelaw> it's only a few thousand kilometers away
02:31:53 <dobblego> I am more likely than not, but still cannot promise
02:32:03 <sinelaw> (for me)
02:32:35 <sinelaw> 14,000 kilometers actually
02:32:37 <sinelaw> :(
02:33:52 <ivanm> dobblego: *nod*
02:34:00 <ivanm> dobblego: when do you expect to know by?
02:34:03 <sinelaw> does australia have a big haskell community?
02:34:31 <m3ga> how big is big?
02:34:39 <sinelaw> more than....10
02:34:41 <dobblego> ivanm, I have a pretty serious health problem at the moment, so no idea
02:34:52 <dobblego> Brisbane Functional Programming Group now has over 100 members
02:35:00 <ivanm> oooohhhh...
02:35:01 <dobblego> though we are not just Haskell
02:35:05 <m3ga> about 3/4 of the attendees at fp-syd know haskell. (18-30 most months)
02:35:09 <ivanm> sinelaw: there is no real "haskell community" atm
02:35:24 <ivanm> there are a bunch of fp groups and generic programming groups around though
02:35:24 <sinelaw> ivanm ok, then, people who use haskell regularly
02:35:25 <m3ga> fp-syd has 130 odd on the mailing list
02:35:39 <ivanm> sinelaw: regularly? even less probably :p
02:35:46 <sinelaw> ok never mind :P
02:35:50 <ivanm> a fair number of people _know_ haskell from uni
02:36:08 <ivanm> AFAIK, there's one or two companies that use haskell and a couple of unis
02:36:14 <sinelaw> they don't even teach it here, actually even the _staff_ aren't familiar with it
02:36:23 <ivanm> that's about it in terms of "having a job using haskell"
02:36:42 <sinelaw> well i meant use even at home as a hobby
02:36:45 <dobblego> I use haskell at work whenever I need to do something practical, without having to argue with anyone else about how to do it (i.e. just do it)
02:36:56 <m3ga> i use ocaml in my day job. trying to bring in some haskell as well
02:37:06 <kevinulin> i got you all beat
02:37:10 <sinelaw> dobblego doesn't it need to interact with other stuff?
02:37:11 <kevinulin> i program vbscript in classic asp
02:37:31 <sinelaw> kevinulin, you beat me but only by an inch: c# asp + javascript
02:37:43 <dobblego> sinelaw, if it does it'll usually be Java, in which case, I use Scala
02:38:14 <sinelaw> scala talks nicely to java?
02:38:30 <dobblego> yes, transparently in fact (you can't notice a difference even if you try)
02:39:43 <sinelaw> ooh looks nice (looking at scala-lang website)
02:40:04 <sinelaw> if it could compile to .net CLR too, i'd be in nirvana
02:40:20 <sinelaw> although a better solution would be to replace all this with Haskell
02:40:28 <sinelaw> ;P
02:40:34 <dobblego> there have been efforts to do that, but I don't think they are successful at this moment
02:40:38 <bremner_> sinelaw: there is also JOcaml if you like that kind of thing
02:40:50 <kevinulin> what ever happened to f#
02:40:56 <dobblego> yes, or a Haskell-like language (Scala makes quite a few mistakes out of ignorance imo)
02:41:18 <dobblego> BFPG had a talk on F# last month
02:41:40 <dobblego> F# is not as practical as Scala imo (ignoring JVM/.NET)
02:41:47 <sinelaw> f# looked disappointing when i gave it a very short look
02:42:00 <sinelaw> should I look again?
02:42:03 <dobblego> no
02:42:22 <sinelaw> also, i got used to pureness
02:42:44 <kevinulin> I love monads, infact i love everything about haskell
02:42:52 <dobblego> I recall clearly standing next to Erik Meijer while he berated Don Syme in his usual animated style
02:43:11 <sinelaw> dobblego i don't know any of "them characters", so .... what?
02:43:19 <dobblego> many people will tell you that F# has monads, but it has a degenerate notion of monads (it cannot abstract on the type constructor)
02:43:32 <sinelaw> f# isn't pure so what's the point anyway
02:43:36 <dobblego> sinelaw, Erik Meijer is a Haskell nut as MSR. Don Syme is the inventor of F# at MSR.
02:44:06 <sinelaw> dobblego ah thanks
02:44:29 <dobblego> and Erik is very animated, while Don is very calm and collected
02:44:42 <sinelaw> garbage collected?
02:44:44 * sinelaw ducks
02:47:46 <sinelaw> what i really want is to unify server/client stuff (replace Javascript + C# with Haskell on both sides)
02:50:22 <bremner_> Compile haskell to javascript!
02:52:06 <kmc> i think it's been done
02:52:07 <sinelaw> bremner_ i think some work has been done on it
02:52:13 <kmc> should be easier now with GHC's LLVM backend
02:52:17 <sinelaw> but i don't know if its reliable
02:52:22 <sinelaw> kmc, oh?
02:52:24 <sinelaw> hmm
02:52:47 <sinelaw> i was thinking of writing an EDSL that interprets into javascript and c#
02:52:57 <sinelaw> instead of compiling haskell directly
02:53:23 <kmc> it's a weird path, Haskell to Core to STG to C-- to LLVM to Javascript to some bytecode to (selectively) machine code
02:53:26 <kmc> but these are the times we live in
03:01:31 <bremner_> did the default import search path for ghc change in 6.12? Or did importing from the current directory never work by default?
03:08:11 <ivanm> bremner_: hmmm?
03:08:15 <ivanm> what do you mean?
03:08:35 <ivanm> in module Foo, "import Bar" should look for Bar from the same directory
03:10:34 <bremner_> ah, I must have just been confused about ghci's working directory. Sorry for the noise.
03:11:29 <sinelaw> is anyone else annoyed by the "E X" notation for expectation where everywhere else in math it's f(X)?
03:11:42 <sinelaw> (which is used even when it's really f . X)
03:23:10 <Botje> sinelaw: I always saw E(X)
03:23:27 <sinelaw> Botje for some reason i have two books here that use E X
03:23:34 <sinelaw> it's amazingly annoying and confusing
03:23:41 <Botje> fix them >:)
03:23:46 <sinelaw> esp. when you have E X+Y etc...
03:24:19 <Botje> yeah, can see why
03:24:32 <sinelaw> ugh
03:24:41 <sinelaw> anyway, info. theory is nice :)
03:24:58 <Botje> i don't remember much from my class
03:26:23 <kmc> when does f . X mean f(X)?
03:26:45 <kmc> err when does f(X) mean f . X?
03:28:01 <sinelaw> kmc when X is a random variable
03:28:25 <sinelaw> X : Omega -> R
03:28:49 <sinelaw> so f(X) is a new random variable, but it's bad notation. it should be f . X because it has type :: Omega -> R
03:28:58 <sinelaw> f :: R -> R of course
03:29:10 <kmc> i think it's more like f <$> X
03:29:30 <sinelaw> kmc, why? random variables are _defined_ as functions
03:29:45 <kmc> how so?
03:30:07 <sinelaw> kmc that's how they're defined
03:30:25 <sinelaw> at least in the version of prob. theory that i've studied :)
03:30:31 * kmc reads
03:44:03 <quicksilver> I've always thought of random variables as being an abstract data type
03:44:18 <quicksilver> that implementation you describe (as functions on Omega) is just an implementation, not the definition.
03:44:48 <quicksilver> long time since I studied any probability theory though
03:47:52 <sinelaw> quicksilver that's how they defined them when i recently studied
03:47:57 <sinelaw> it's by definition
03:48:30 <sinelaw> quicksilver what do you mean by being an abstract data type ? that doesn't describe much about them
03:48:54 <sinelaw> quicksilver and what do you mean by "implementation"?
03:48:57 <sinelaw> this is math
03:48:59 <quicksilver> I was using a CS metaphor.
03:49:12 <quicksilver> In math, I would say simply they are an abstraction.
03:49:27 <quicksilver> A random variable is an object X with the following operations...
03:49:47 <sinelaw> aha.
03:50:08 <sinelaw> quicksilver well i'll have to review most of what i know about probability to check if that holds water :)
03:50:13 <sinelaw> unless you can tell me that it works
03:50:30 <sinelaw> without concluding that X :: Omega -> R anyway
03:51:22 <sinelaw> i mean, you have to work with the basic definitions of probability theory - the probability space and its sigma algebra - no?
03:51:25 <quicksilver> to be fair, a quick google only finds sources who define it as a function.
03:51:36 <quicksilver> that's just not my memory of it. My memory could be faulty.
03:51:53 <sinelaw> ok. if you find a different one, tell me. sounds interesting.
04:08:27 <adnan> hello
04:12:04 <sinelaw> hey adnan
04:13:06 <adnan> hello sinelaw
04:30:06 <dobblego> how can I add a hlint ignore pragma to a source file that has GHC pragmas?
04:37:22 <ivanm> dobblego: to HLint.hs or something in the root directory
04:37:36 <ivanm> (I think... didn't know HLint had pragma support)
04:37:45 <dobblego> I just want to add it to the specific source file
04:38:19 <dobblego> but I already have a GHC pragma, so if I add it anyway, hlint fails to parse
04:41:02 <dobblego> it seems odd to not be able to add two types of pragmas
04:41:50 <ivanm> Axman6!
04:42:20 <ivanm> dobblego: so you don't want it for the entire project, just one file?
04:42:31 <dobblego> ivanm, correct
04:42:58 <ivanm> where are you placing this pragma? before or after the GHC pragma?
04:43:06 <dobblego> after
04:43:19 <benmachine> ...try before?
04:43:22 <ivanm> yeah
04:44:06 <dobblego> then hlint fails to parse the GHC pragma
04:44:20 <ivanm> dobblego: methinks it's a problem with haskell-src-exts
04:44:29 <ivanm> not being able to parse both
04:44:38 <ivanm> check with ndm and niklas broberg
04:44:39 <dobblego> yeah prolly
04:45:01 <dobblego> !seen ndm
04:45:08 <benmachine> preflex: seen ndm
04:45:08 <preflex>  ndm was last seen on #haskell 318 days, 1 hour, 26 minutes and 28 seconds ago, saying: plus with current compiler technology, it would be slower
04:45:09 <ivanm> preflex: seen ndm
04:45:09 <preflex>  ndm was last seen on #haskell 318 days, 1 hour, 26 minutes and 28 seconds ago, saying: plus with current compiler technology, it would be slower
04:45:15 <benmachine> 318 days, nice
04:45:17 <ivanm> you're out of luck there ;-)
04:45:34 <ivanm> dobblego: niklas seems to be online in gmail however
04:45:41 <ivanm> so if you send him an email, he should respond prompty
04:45:43 <quicksilver> ndm has been around more recently than that
04:45:44 <ivanm> *promptly
04:45:55 <quicksilver> but under a different nick, which preflex didn't remember for some reason
04:45:57 <dobblego> ok ta
04:46:11 <ivanm> quicksilver: :o
04:46:17 <ivanm> any idea what nick it was?
04:46:36 <quicksilver> I think it was ndmitchell
04:46:43 <quicksilver> I don't know why preflex didn't record it.
04:46:50 <ivanm> was preflex here at the time?
04:46:57 <quicksilver> no idea :)
04:47:20 <ivanm> last my logs have him using it is september...
04:47:30 <ivanm> and he used it a fair amount
04:47:33 <ivanm> preflex: seen ndmitchell
04:47:33 <preflex>  Sorry, I haven't seen ndmitchell
04:47:38 <ivanm> interesting...
04:48:02 * ivanm tests this
04:48:21 <ndmitchell> this is not ndmitchell, just testing to see if preflex remembers this nick...
04:48:33 <ivanm> preflex: seen ndmitchell
04:48:34 <preflex>  ndmitchell was last seen on #haskell 12 seconds ago, saying: this is not ndmitchell, just testing to see if preflex remembers this nick...
04:48:44 <ivanm> OK, preflex mustn't have been alive at the time
04:49:18 <ivanm> maybe it's a registration thing, since I was already registered to services from my normal nick but ndmitchell doesn't seem to be a registered nick...
04:54:15 <danderson> okay, so, I have an almost complete mirror of the haskell platform site, I'm just missing the .dmg
04:54:44 <danderson> does anyone have said .dmg available somewhere with more than 20k/sec bandwidth, so that I can retrieve it faster?
04:56:20 <fasta> I don't understand the fuss. It is not like there are any completely new components in the platform.
04:57:09 <Zao> fasta: A nice solid base you can install as a user without having to know how to install cabal-install properly.
04:58:23 <fasta> Zao, maybe on Windows or Mac it is useful, I suppose.
04:58:53 <Zao> fasta: It's awfully convenient on Linux/BSD/whatever too.
04:59:04 <fasta> On Linux you can bootstrap a whole development environment in a few hundred lines of shell code.
04:59:28 <Zao> Assuming competence.
04:59:30 <danderson> fasta: and indeed, the linux tarball is just a couple of megs
04:59:35 <fasta> Or well, that's what I did.
04:59:52 <danderson> where the OS X installer includes a binary release of GHC, which is huuge.
05:00:15 <fasta> The only problem is that GHC compilation is slow, but in principle you could turn it on in the evening.
05:00:34 <ksf> plan9 is getting more impressive the more I read about it
05:00:44 <fasta> (I am not actually compiling GHC, GHC is way too fragile. )
05:02:22 <fasta> ksf, have you read about the Synthesis kernel?
05:02:58 <fasta> ksf, 10 times the performance of Unix according to the author, but you cannot actually download and run it.
05:03:20 <bremner_> fasta: see inferno
05:04:09 <fasta> I also recently read that with Haskell you don't actually need protected modes in hardware.
05:04:28 <fasta> That is kind of a nice application of Haskell, IMHO.
05:04:41 <ksf> oh sure you do
05:04:47 <SamB_XP> fasta: well, it helps for the OS portion of the code ;-P
05:04:55 <ksf> unless you forbid the whole ffi and unsafeCoerce
05:05:00 <ksf> as well as unsafePerformIO
05:05:02 <bremner_> I think that people who assume the whole OS is haskell are living in a fantasy world anyway
05:05:16 <ksf> ...which'd mean that virtually no code at all would run.
05:05:22 <SamB_XP> bremner_: well, yes
05:05:26 <quicksilver> "10 times the performance of unix" is nonsense-talk anyway
05:05:32 <SamB_XP> clearly the RTS uses a good deal of C-- and C as well
05:05:38 <fasta> quicksilver, he had measurements.
05:05:48 <ksf> of what? against what?
05:05:49 <fasta> quicksilver, that doesn't mean it is true.
05:05:55 <quicksilver> fasta: the measures would be more interesting than the claim
05:06:06 <quicksilver> my point is that 'unix performance' is not a single scalar
05:06:10 <fasta> quicksilver, you are free to read his thesis.
05:06:10 <SamB_XP> ten times the performance of a specific unix at a specific task, at least by his reckoning ;-P
05:06:14 <ksf> e.g. it's quite impossible to have faster syscalls than beOS.
05:06:17 <quicksilver> you can't say "the performance of this machine is 7"
05:06:18 <fasta> quicksilver, SunOS something, IIRC.
05:06:34 <ksf> ...or faster kernel threads, for that matter.
05:06:40 <SamB_XP> ksf: how does beOS do syscalls that is so fast?
05:06:46 <quicksilver> for example, for integer addition there would be no way to be 10x faster
05:07:06 <fasta> quicksilver, it was about system call performance.
05:07:07 <quicksilver> since the OS overhead during simple math is quite small, really. The OS doesn't make much different.
05:07:27 <ksf> SamB_XP, http://www.haiku-os.org/documents/dev/system_calls
05:07:27 <fasta> quicksilver, basically a kind of run-time partial evaluation.
05:08:23 <fasta> It might be possible that it is obsoleted in some Java operating systems, but I don't know about those in detail.
05:09:07 <SamB_XP> lol @ "is_computer_on_fire()"
05:11:29 <fasta> Too bad that the actual qualities of operating systems are irrelevant today and it only matters whether or not there are binary blobs for wifi/graphics/etc.
05:12:57 <ksf> there's of course performance to be had by haskell if it can prove that some code is sufficiently safe, it can run all of that in one address space and do its managed coroutine thing instead of preemption
05:13:44 <ksf> but I don't think the way to an haskell OS should start with a kernel, anyway.
05:13:46 <SamB_XP> of course, there's always the danger the code will forget to be preempted ...
05:14:19 <ksf> I'm assuming that the kernel or some trusted server does the compiling.
05:14:28 * bremner_ is never going back to co-operative multitasking. You can't make me!
05:14:30 <SamB_XP> ksf: I meant because of that GHC bug
05:14:37 <ksf> oh
05:14:53 <ksf> well at least then there's someone to blame.
05:15:24 <ksf> bremner_, it's not co-operative. yields are inserted automatically by the compiler
05:15:35 <ksf> ...which would run as a trusted kernel server or similar.
05:15:50 <ksf> I've just said that.
05:16:01 <ksf> *sigh*
05:16:19 <ksf> anyway, It's actually 9p and factotum that impress me
05:16:35 <SamB_XP> what's factotum again ?
05:16:39 <ksf> that's authentication and tls Done Right
05:16:42 <bremner_> ksf: sigh yourself. welcome to irc latency
05:16:55 <ksf> an authentication server/keystore.
05:17:24 <ksf> every user has one, and they manage all that key exchange and stream encryption stuff.
05:18:13 <ksf> ...you ask your factotum to shake hands with some server's factotum, and then you ask your factotum to encrypt your data and decrypt the data you recieved.
05:18:40 <SamB_XP> ah, nice
05:19:13 <SamB_XP> so it's a cross between ssh, ssh-agent, and TLS...
05:19:36 <ksf> in the plan9 libs, that's as easy as giving an fd and some auth info and getting another fd which is transparently encrypting the stuff.
05:20:20 <ksf> most importantly, you don't have to relink anything should there be once again a bug in ssh.
05:20:34 <ksf> ...well the factotum itself and you have to restart it, but that's it.
05:20:36 <bremner_> shared libraries also work
05:20:54 <ksf> shared libraries share virtual memory
05:21:06 <ksf> ...the paper said that's a bad idea for interface security
05:21:18 <bremner_> I meant as far as not relinking
05:21:25 <ksf> anyway, plan9 has a nice file protocol to do such things.
05:21:45 <SamB_XP> yeah, in plan9 it really is easier *not* to go the shared lib way
05:21:50 <SamB_XP> seriously
05:29:57 <bob31> anyone hosting a torrent of the platform release by now?
05:30:24 <ivanm> bob31: why should they?
05:30:40 <SamB_XP> which release?
05:30:43 <bob31> ivanm: because it's still slow and taking down hackage http perf
05:30:55 * ivanm personally doesn't understand why people smart enough to get and compile the platform tarballs don't just get cabal-install, build that and install what they want
05:30:56 <bob31> SamB_XP: 2010.01.01
05:31:04 <SamB_XP> ivanm: it might be a good idea for the Windows builds at least
05:31:06 <bob31> ivanm: I do
05:31:06 <ivanm> dammit, there's an update?
05:31:12 <ivanm> SamB_XP: except there isn't one yet AFAIK
05:31:14 <bob31> normally I don't bother with the platform
05:31:24 <bob31> it's the first time I wanted to try and see for myself
05:31:28 <SamB_XP> well, okay, both that and the tarball then
05:31:30 <ivanm> nope, no windows one
05:31:35 <bob31> usually I get GHC and cabal-install
05:31:37 <bob31> that's it
05:31:40 <ivanm> I can see the mac one maybe
05:31:45 <Zao> ivanm: Because the server feeds you files at 20 KiB/s.
05:31:46 <ksf> I'm willing to seed
05:31:59 <ivanm> Zao: no, my point was more along the lines of "why is it needed"
05:32:00 <bob31> one of my curiousity
05:32:09 <ksf> if we set up a torrent with hackage as http seed, we can redistribute those 20k
05:32:11 <Zao> ivanm: The need is primarily Windows/Mac.
05:32:16 <bob31> is there 64-bit suppor ton Darwin now?
05:32:20 <ivanm> *phew* don't scare me like that bob31; there isn't an bugfix release yet!
05:32:23 <SamB_XP> anyway, if we put up a getright-style-webseeeded torrent, that'd probably help download speed a lot?
05:32:38 <bob31> ivanm: fix for which defect?
05:32:43 <ivanm> bob31: _any_
05:32:44 <ksf> heck just set up a torrent rss feed and I'm going to seed them all.
05:32:49 <ivanm> bob31: you said 2010.1.0.1
05:32:51 <Zao> ksf: Dito.
05:32:55 <quicksilver> bob31: in macports, apparently there is.
05:33:05 <quicksilver> bob31: (the downloadable dmg is 32-bit though)
05:33:19 <SamB_XP> ksf: well, I just figured that'd be the easiest way to get them seeded in the first place
05:33:19 <bob31> quicksilver: hmm, I would take a look at whether they do _correct_ patches in macports
05:33:29 <ksf> SamB_XP, indeed.
05:33:38 <Axman6> quicksilver: were you interested in my results of building 6.12.1 with the 64bit 6.10.4?
05:33:38 <bob31> actually now that I think about it
05:33:59 <SamB_XP> since we DO already have a working webserver hosting the files, and getright's webseed style is designed for just such a situation
05:34:00 <bob31> maybe I should build a LLVM variant anyway to do ultimate testing :)
05:34:02 <ksf> but then, someone has to have the file to generate the torrent with all the hashes and stuff
05:34:03 <quicksilver> Axman6: well, certainly interesting to hear.
05:34:25 <Axman6> well, it compiled, but when i ran the test suite, it had a hell of a lot of unexpected failures
05:34:34 <SamB_XP> ksf: well, I figure that should be done as part of the release process
05:34:52 <bob31> generally speaking, it should be much better with 20k torrent and then enough peers sharing than what we have now
05:34:59 <QtPlatypus> Is there a function that if you give it a function to an ordering and an unordered list will return an ordered one.  I tried searching for (a -> Ordering) -> [a] -> [a] but got nothing relivent.
05:35:26 <QtPlatypus> (In other words a sort)
05:35:26 <Cale> QtPlatypus: I believe you want sortBy
05:35:28 <Axman6> `:t compare
05:35:31 <Axman6> :t compare
05:35:32 <ksf> so who can edit the platform pages?
05:35:32 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:35:33 <ksf> dons?
05:35:37 <SamB_XP> i.e. make tarball, create torrent with getright-style webseed pointing at public download URL for tarball, then put both up at their public URLs
05:35:39 <Axman6> :t sortBy
05:35:40 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:35:41 <Cale> QtPlatypus: But that's not the right sort of function parameter
05:35:46 <BONUS> > sortBy (comparing snd) [(1,2),(3,1)]
05:35:47 <lambdabot>   [(3,1),(1,2)]
05:35:53 <QtPlatypus> Exclent that is what I want.
05:36:08 <bob31> dons was on his flight back and just posted about 8 separate security checks at Swiss airport
05:36:14 <QtPlatypus> Cale: Ah I see where my search was wrong.
05:36:18 <quicksilver> Axman6: bah :(
05:36:21 <SamB_XP> another option would be to get e.g. an SF.net project for it and upload to their download service, but that'd be a lot more work I think
05:36:23 <bob31> I guess they statically verified he's good to enter the flight and no risk
05:36:41 <SamB_XP> bob31: what, he's type-safe?
05:36:52 <SamB_XP> (does that mean he's infertile?)
05:37:11 <bob31> :)
05:37:12 <bob31> no
05:37:14 <ksf> ibiblio or the like might be willing to host, too.
05:37:26 <ksf> there's also the gentoo mirrors
05:37:57 <ksf> wait, I don't think there's binaries of the platform, there. or windows versions.
05:38:06 <telemachus> Is the newest version of the Haskell platform *only* ok on Snow Leopard (for OSX)?
05:38:20 <telemachus> I've just installed and ghc/ghci appear fine, but cabal gives a dyld error
05:38:27 <bob31> the better question is what kind of ghc is in the DMG?
05:38:42 <Axman6> 32 bit 6.12.1
05:38:46 <quicksilver> 32 bit intel 6.12.1
05:38:49 <bob31> oh
05:38:53 <bob31> let's stop the download then
05:38:58 <Axman6> ?
05:38:59 <bob31> reddit page was confusing
05:39:02 <Axman6> yeah
05:39:09 <telemachus> again, ghc is fine, but cabal not so much
05:39:17 <bob31> I thought amd64 is supported on Darwin
05:39:20 <Cale> telemachus: Maybe just rebuild it?
05:39:25 <telemachus> (or did I just fall into the middle of a different conversation...)
05:39:37 <quicksilver> bob31: but I just set to you 5 minutes ago "in macports apparently there is, but the downloadable dmg is 64 bit"
05:39:40 <telemachus> Cale: fair enough, though isn't that the point of the platform?
05:39:42 <quicksilver> 32 bit!
05:39:42 <SamB_XP> anyway, a getright-style-webseeded torrent would work for ANY swarm size and would avoid forcing the user to pick a mirror ;-)
05:39:44 <quicksilver> damn words, sorry.
05:39:54 <Cale> telemachus: Indeed it is...
05:39:56 <ksf> *ouch*
05:40:07 <Axman6> -_-
05:40:09 <ksf> I've just noted, they released 6.12.1
05:40:18 <ksf> which means that c2hs doesn't work
05:40:20 <Axman6> quite some time ago ksf :P
05:40:21 <telemachus> Cale: also, I don't know if I also therefore need to rebuild all the libraries in the platform package or *just* cabal
05:40:26 <ksf> ...which means that e.g. gtk doesn't work
05:40:26 <bob31> quicksilver: will check, yeah, forgot what you said while thinking differently
05:40:30 <ksf> yes but now as platform
05:40:30 <quicksilver> :)
05:40:37 <SamB_XP> since when does GHC actually work for 64-bit on OS X ?
05:40:42 <bob31> c2hs in 6.12.1 has problems on Darwin or also on Linux?
05:40:49 <Axman6> SamB_XP: it does in macports
05:40:49 <quicksilver> SamB_XP: since rather recently.
05:40:50 <ksf> in general
05:40:51 <Cale> telemachus: But I haven't had much luck installing the platform in the past, not sure about the new version. Usually I just install the generic binary of GHC, and then cabal-install and then cabal-install anything I need from there.
05:40:58 <Axman6> it's a 64 bit app, that compiles 64 bit code
05:41:04 <ksf> 6.12.1 misses, iirc,  CLDouble
05:41:08 <Axman6> but, can't compile a 64 bit 6.12
05:41:24 <SamB_XP> Axman6: oh ?
05:41:35 <SamB_XP> Axman6: what version is it itself ?
05:41:41 <Axman6> 6.10.4
05:41:46 <telemachus> Cale: ok, I will try that - I can uninstall everything below /Library/Frameworks/HaskellPlatform.framework/
05:41:59 <telemachus> Cale: weirdly enough, I *have* had good luck previously with the platform
05:42:03 <Cale> telemachus: Mind you, I'm not on OSX either.
05:42:09 <SamB_XP> why can't that build 6.12 -- is this just 6.12's fault, or ?
05:42:26 <BONUS> how does one go about making a windows installer for the haskell platform?
05:42:35 <bob31> ksf: hmm, I thought .12 is a stable and not dev version. surprised to hear c2hs doesn't work. is it being deprecated?
05:42:40 <Axman6> well, it can build it, but it fails over a thousand tests unexpectedly
05:42:52 <ksf> they should just release 6.12.2.
05:42:57 <Cale> (The last GHC on OSX that I used was 6.2.x)
05:43:00 <ksf> CLDouble is going to be reintroduced
05:43:11 <ksf> ...it's said to be bugged, dunno the details.
05:43:40 <Zao> bob31: 6.12 is a bit ... differently-abled.
05:43:45 <ksf> and while the "official" ffi generator is hsc2hs, that one is just a pain in the ass to use.
05:43:51 <Cale> I'm waiting for 6.12.2 after hearing about various problems with 6.12.1
05:43:52 <Zao> bob31: New text IO semantics, which tends to break a lot of things.
05:44:19 <ksf> I've had no major problems except the c2hs thing
05:44:43 <ksf> the Control.Exception change in 6.10 was much more painful.
05:44:51 <telemachus> Cale: oh? (crap, crap, crap, crap) Such as?
05:44:57 <SamB_XP> what ever happened to CLDouble in the first place?
05:45:42 <SamB_XP> as long as nobody expects it to be MSVC-compatible it should be no big deal ...
05:47:19 <SamB_XP> oh, I guess it would be rather a pain to actually support with -fasm
05:47:27 <SamB_XP> at least potentially
05:48:00 <ksf> http://hackage.haskell.org/trac/ghc/ticket/2793
05:49:12 <SamB_XP> btw, I mention MSVC because it takes "long double = double", and has for some time
05:49:38 <ksf> gnargh
05:49:50 <ksf> ...why did they have to break stuff, then?
05:49:55 <telemachus> Cale: hrm, now the bootstrap.sh script for cabal itself fails
05:49:59 <telemachus> Configuring Cabal-1.6.0.2...
05:50:00 <telemachus> Setup: failed to parse output of 'ghc-pkg dump'
05:50:09 <SamB_XP> ksf: who?
05:50:15 <ksf> the ghc devs
05:50:24 <SamB_XP> what does the "then" refer to?
05:51:09 <ksf> ...if it's broken in general, anyway.
05:51:20 <SamB_XP> well, it's not broken in e.g. GCC
05:51:27 <SamB_XP> I dunno about BCC
05:51:29 <SamB_XP> I could chekc
05:51:32 <SamB_XP> er. check.
05:52:00 <ksf> and c2hs wasn't broken until they decided that breaking existing code is better than having a hack around until they fix it.
05:52:01 <Cale> telemachus: Well, I'm not certain specifically. I've just heard a relatively high amount of noise about compiler panics and such.
05:52:15 <telemachus> Cale: noted
05:52:24 <telemachus> and I now have a broken setup
05:52:26 * telemachus sighs
05:53:34 <ksf> ...long double doesnt' seem to be specced, anyway.
05:53:46 <ksf> it could be 80 bits, 128 bits, or, well, the same as double.
05:53:53 <SamB_XP> ksf: indeed!
05:54:05 <SamB_XP> or anything else >= double in range and precision
05:54:36 <ksf> so removing it was the wrong descision.
05:54:40 <SamB_XP> as long as you can cast from double to long double and back, obtaining the original number, you're good
05:55:12 <SamB_XP> in the SysV ABI for x86, it is specced as 80-bit
05:55:40 <SamB_XP> padded to 12 bytes, I think?
05:55:54 <ksf> I guesstimate it'd be 128 on amd64, then
05:56:03 <SamB_XP> it would be, yes
05:56:06 <ksf> ...with all that x87 hate going on in there.
05:56:17 <quicksilver> I don't think that's true.
05:56:19 <SamB_XP> there's a reason for hat x87 hate
05:56:24 <quicksilver> I think on amd it's 64 bit
05:56:33 <SamB_XP> quicksilver: hmm, also possible :-(
05:56:42 <ksf> x87 is an awesome instruction set
05:56:43 <quicksilver> sse2-4 do not have 128 bit double support
05:56:50 <SamB_XP> oh
05:57:00 <quicksilver> I recall it's planned for some future CPU instruction set extension
05:57:07 <SamB_XP> is the ISA done for it?
05:57:11 <quicksilver> they have '128-bit' maths or even '256-bit' maths
05:57:11 <ksf> you just have to realize that it's stack-based and utterly made for rpn.
05:57:17 <quicksilver> but those are all vectors
05:57:25 <quicksilver> 256-bit maths is 4x64 or 8x32
05:57:30 <quicksilver> never 2x128.
05:57:50 <SamB_XP> sad :-(
05:57:50 <zygoloid> 64bit should be enough for anyone
05:57:55 <zygoloid> ;)
05:58:05 <quicksilver> I'm not aware of any quad precision flaots on commodity hardware.
05:58:33 <SamB_XP> so the x87 is really the best you can get for that ?
05:59:14 <quicksilver> unless perhaps the PPC G5 did it?
05:59:19 <quicksilver> altivec did some strange stuff.
05:59:24 <SamB_XP> are they still at G5?
05:59:26 <quicksilver> but no one uses G5s any more.
05:59:30 <SamB_XP> no G6 yet ?
05:59:36 <quicksilver> AFAIK that line is discontinued
05:59:44 <quicksilver> the only remaining cousin is IBM POWER
05:59:45 <SamB_XP> oh, what line is that then?
05:59:53 <quicksilver> the motorola PPC G4-5 line
06:00:04 <SamB_XP> you mean G doesn't stand for Generation?
06:00:23 <SamB_XP> referring to the generation of PowerPC core design?
06:00:29 <ksf> ultrasparcs can use quad precision
06:01:02 * ksf stares at his ultra-1
06:01:05 <SamB_XP> quicksilver: so, are you saying the Xbox 360 and the PS3 can't handle that ?
06:01:27 <ksf> it's hard to believe that that slow behemoth with 265 colour graphics has wider registers than my amd64.
06:01:32 <quicksilver> x360/ps3 also don't have quad-precision, afaik.
06:01:33 <SamB_XP> I still can't get over the fact that MS used the *big*-endian mode for Xbox 360
06:01:46 <ksf> you don't need quad precision for graphics
06:01:54 <SamB_XP> ksf: true
06:01:56 <ksf> or, rather, you don't want to waste the transistors.
06:02:08 <quicksilver> ksf: ok, ultrasparc makes sense.
06:02:20 <ksf> if you've got a big world, translate it to fit inside your precision.
06:02:30 <SamB_XP> especially when they need more transistors for the 3 SPU cores
06:03:43 <SamB_XP> ksf: do you mean scale, or are you proposing that the map be represented in 64-bit fixed point?
06:06:30 <ksf> no. if you start the game at coordinate (0,0,0) everything around you is positioned properly, but if you do your code wrong and drive say north for maxFloat units, topology is going to look rather strange.
06:07:17 <ksf> ...you have to translate the world coordinates to be always centered on (0,0,0) camera coordinates, that is.
06:07:54 <ksf> i.e. you move the world, not the camera.
06:08:42 <quicksilver> yes, that's the only way floating point make sense (if it does at all)
06:08:45 <ksf> ...bigger worlds usually being represented in some equivalent of fixed-point bignum.
06:08:59 <quicksilver> if you use it without translation you have one special area where you have higher accuracy
06:09:05 <ketil> I got "openFile: invalid argument" when trying to run my program after moving it to a different machine.  The program works on both machines if compiled locally.  Any idea?
06:09:06 <lambdabot> ketil: You have 1 new message. '/msg lambdabot @messages' to read it.
06:09:09 <quicksilver> and as you move further away from the origin you get increasingly inaccurate
06:09:11 <quicksilver> that's just odd.
06:09:30 <quicksilver> arguably this just demonstrates that FP is wrong for this kind of thing
06:09:35 <quicksilver> and you should really use fixed point anyway
06:09:38 <quicksilver> (but graphics cards don't)
06:10:09 <ksf> hardware fixed point arithmetic would be cool
06:10:32 <Cale> hardware interval arithmetic :)
06:11:13 <ksf> also, harware sine functions based on measuring the cpu fan's spin.
06:11:35 <ksf> I guess that's a cool lavalamp-project.
06:11:57 <arcatan> it spins slower -> taking sine takes longer
06:12:36 <arcatan> that's why the fan always speeds u√• when doing something computationally intensive
06:12:39 <Cale> Or an LRC circuit
06:12:43 <ksf> well you need access to the stepper motor control and a camera.
06:13:08 <int-e> quicksilver: FP = functional programming = floating point = fixed point? :-)
06:13:32 <quicksilver> int-e: yeah, annoying isn't it? Join my campaign to split the overloaded letter F!
06:13:53 * Cale wants a field programmable analog array.
06:16:36 <quicksilver> we'll have F, Vau, and Digamma.
06:16:38 <quicksilver> It will be great.
06:19:34 <ketil> Anybody have any idea on why I get "invalid argument"?
06:25:15 <ksf> ketil, different libc versions?
06:25:30 <ksf> ...different kernels?
06:27:19 <ksf> I guess the only way to find out is to dig down to the open call the libraries do, and compare the system's man pages and configure outputs.
06:28:14 * ksf remembers trying to port ghc to beos, ending up with an otherwise functional ghc that thought files were directories and directories files.
06:29:24 <telemachus> Downgraded from 6.12.1, reinstalled cabal-install and all is good
06:30:19 <ketil> ksf: very likely different kernels and libc, yes.  I think this started happening after upgrading to Ubuntu 10.4, which also includes GHC 6.12.
06:30:25 <telemachus> The platform for Mac is a mess at the moment, it seems. Out of curiosity, has anyone else had luck with that package?
06:30:48 <ksf> hmmm does anyone know of a prng that generates all possible 64-bit values before repeating, but has a larger than 64-bit state so it can't be guessed?
06:31:09 <Zao> There's a Mac lab in the room next to me, but I don't dare go in there. I might catch something.
06:31:20 <Zao> In any way, the platform would take 2.5h to download anyway.
06:31:44 <telemachus> Zao: Just keep saying to yourself, it's a Certified UNIX (TM) and clicking your heels
06:31:45 <telemachus> :)
06:31:58 <ksf> are we really incapable of setting up a torrent for the platform?
06:32:05 <telemachus> I've actually gotten fairly comfortable with OSX at this point (work requirement)
06:32:47 <telemachus> I can get all the *nix tools I want via MacPorts (or Fink or Rudix or Homebrew or Stow or compiling), MacVim works well and Chrome now works well on it
06:32:52 * telemachus shrugs
06:33:35 <telemachus> ksf: I was wondering that as well. I'm happy to lend some bandwidth...
06:35:08 <ksf> the first thing we need is someone with the platform to generate a torrent (including hackage http seed), the second thing is having someone with write access to the platform homepage.
06:35:10 <Cale> Somewhat surprisingly, the main complaints I had back when I was using OSX were related to the GUI :P
06:35:31 <ksf> it might be better than windows, but it ain't no xmonad.
06:35:58 <Cale> Well, I don't like tiling WMs either, but the WM sucked and was not replaceable.
06:36:15 <danderson> ksf: I can generate the torrents, given a second.
06:36:23 <danderson> (I have a mirror of the Platform)
06:36:37 <ksf> you can upload them to the wiki or something
06:36:54 <danderson> presumably, we just want a torrent of the .dmg for now?
06:37:05 <telemachus> Cale: you *can* actually run another WM, though it's a huge amount of work for such a trivial thing. (Out of sheer spite, I got Gnome working on an OSX box at one point.) But, yeah, the OS really doesn't want you to mess with the WM
06:37:30 <Cale> telemachus: With metacity?
06:37:38 <Zao> ksf: Not to mention that you need a tracker too.
06:37:39 <telemachus> Cale: Yup.
06:37:43 <Cale> cool :)
06:37:44 <ksf> the ghc snapshot lives at http://www.haskell.org/sitewiki/images/6/68/Ghc-head.torrent , btw
06:37:48 <telemachus> Cale: Via MacPorts
06:37:50 <ksf> Zao, just use opentracker
06:38:08 <danderson> a combination of opentracker and the DHT will do fine
06:38:47 <ksf> url is http://tracker.openbittorrent.com/announce
06:39:17 <ksf> it's as easy as specifying that url when generating the .torrent ; it's a common misconception that trackers need registration or such.
06:39:25 <danderson> yup yup
06:39:29 <danderson> torrents generated
06:39:47 <danderson> just another sec to boot my client with them, and I'll have 100mbps to seed with
06:39:53 <ksf> and don't forget the http seed (just to make sure)
06:40:34 <ksf> ...I'm going to snarf 1MiB/s of those, and reup with 80KiB/s
06:40:34 <danderson> oh, yeah, there's that
06:40:39 <ksf> (damn adsl)
06:42:35 * Zao huggles his properly symmetric pipe.
06:43:52 <danderson> okay, someone try http://natulte.net/~dave/haskell-platform-2010.1.0.0-i386.dmg.torrent
06:44:06 <ksf> but then, I only pay 24.90 euros per month for mine
06:44:07 <danderson> and http://natulte.net/~dave/haskell-platform-2010.1.0.0.tar.gz.torrent
06:44:33 <danderson> both are being seeded, so you should get some decent pull from it
06:44:50 <ksf> there's no webseeds
06:45:09 <danderson> yeah, I figured the galois servers were hurt enough as it is
06:45:21 <danderson> my server runs 24/7, I'm happy to leave the torrents up
06:46:45 <telemachus> seeding now...
06:46:49 <telemachus> thanks danderson
06:47:52 <mm_freak_> a lot of people use cabal's 'Homepage' to link to the online repository
06:48:03 <mm_freak_> isn't it more correct to use 'Package-URL' for this?
06:51:04 <ksf> danderson, mind if I post the torrent to reddit?
06:51:24 <danderson> ksf: just did so, in dons' post
06:51:26 <telemachus> ksf: and hacker news...
06:51:43 <danderson> If someone can do HN, that would be great
06:52:02 <danderson> I also put up the 2009.2 Windows version, just in case: http://natulte.net/~dave/HaskellPlatform-2009.2.0.2-setup.exe.torrent
06:53:50 <ksf> why's the exe so much smaller than the dmg?
06:54:18 <danderson> dunno
06:54:24 * danderson checks that the file is complete
06:54:45 <int-e> dons: strict-concurrency is broken with base-3; it uses Control.OldException in Control.Concurrent.MVar.Strict. (interestingly cabal-install seems to select base-4 most of the time, disregarding the preferred-versions mechanism. I don't know why.)
06:54:49 <danderson> ksf: yeah, the file is complete. No idea why it's so much smaller, but it's exactly the file that hackage is serving
06:55:50 <sm> mm_freak_: sounds like source-repository: would be most correct (requires cabal 1.6)
06:56:03 <danderson> ksf: you doing an update for hacker news?
06:56:40 <ksf> I don't have an account there
06:57:21 <danderson> I just created one, so I'll comment in the platform article in that case.
06:59:42 <danderson> done.
06:59:56 <danderson> now, does anyone have write access to the platform's website?
07:00:02 <danderson> other than dons, who's in a plane atm
07:01:42 <vpetro_> i was wondering what is the proper way to update my haskell platform install. Should I download the new version and overwrite the old? Do i have to remove the older version first? Is there a script that does that updating?
07:02:08 <fasta> vpetro_, on Windows?
07:04:31 <mm_freak_> sm: thanks
07:04:36 <ksf> erm
07:04:47 <ksf> that 1.8MiB tar.gz is a joke, isn't it?
07:04:54 <danderson> nope
07:05:07 <danderson> that's the linux source tarball, which doesn't include the GHC binary build
07:05:21 <danderson> just the source code for the platform libraries
07:05:34 <DigitalKiwi> text compresses a lot
07:05:44 <danderson> that's why it's so light. The GHC binary releases are 60-90MB each.
07:06:52 <ksf> shouldn't we do a torrent for ghc too, then?
07:07:13 <edwardk> ksf: trendy =)
07:07:44 <ksf> and I don't get why the windows torrent won't take up speed
07:07:45 <edwardk> ksf: next you should try to cram it into a twitter feed somehow
07:07:47 <danderson> ksf: good point. I'll pull the linux tarballs and torrentify them.
07:08:31 <danderson> hmm
07:08:36 <edwardk> er that came across a bit more snarky than intended
07:08:41 <danderson> ksf: otoh, the GHC binary releases are being served from another machine
07:08:47 <danderson> I'm pulling them down at 800K/sec
07:09:05 <Cale> edwardk: You could probably twitter the magnet links
07:09:30 <ksf> ...the way to do that is an rss feed.
07:09:53 <sioraiocht> danderson: can you give me the Tunskell link?
07:10:11 <danderson> sioraiocht: sure, http://bitbucket.org/danderson/tunskell
07:10:20 <danderson> you can `hg clone` that URL, or just browse around.
07:10:24 <telemachus> The downloads for GHC from its own homepage (binaries and source) are quite fast
07:10:25 <ksf> most clients can be set up to listen to it, and then regexp it to only get the torrents you want.
07:10:55 <sioraiocht> Cheers danderson, I'll take a look and get familiar
07:11:01 <danderson> sioraiocht: don't look too hard at the BGP modules right now
07:11:05 <sioraiocht> Okay
07:11:10 <danderson> I'm in the middle of rewriting them to suck less and be tested more
07:11:33 <sioraiocht> danderson: I am keen to program with you, but you also know way more ofthe underlying protocols than I do, hopefully ew can synergise =p
07:12:12 <telemachus> danderson: that could be a good motto - Test more; suck less.
07:12:15 <danderson> sioraiocht: no worries, the subset of BGP that I'm implementing is pretty trivial, and once I've finished fixing the decision engine, it'll be trivial to use
07:12:23 <sioraiocht> cool :)
07:12:27 <vpetro> fasta: i am trying to update it on OS X 10.5
07:12:45 <fasta> vpetro, I don't know. Call Steve? ;)
07:12:48 <danderson> decode BGP packet into a BGPPacket type, feed it to the decision engine, run the decision process to generate new routing tables, push updates out
07:12:56 <telemachus> vpetro: My advice is that you do *not* upgrade on OS X 10.5
07:13:01 <vpetro> fasta: Steve is not cool enough to do haskell
07:13:05 <telemachus> I tried and ghc was fine, but cabal was broken
07:13:22 <vpetro> telemachus: i see.
07:13:28 <telemachus> I ended up downgrading to 6.10.4 (and reinstalling cabal)
07:13:51 <telemachus> It may be something at my end, but it seemed like a library error (dyld error for cabal)
07:14:08 <telemachus> I'm wondering if that build is not sufficiently neutral between 10.5.x and 10.6
07:14:47 <danderson> telemachus: in my case, it really is "test more ; suck less"
07:15:01 <vpetro> telemachus: alright. I am on 6.10.4 right now. I'll leave it as it is right now. Thanks.
07:15:26 <danderson> just using quickcheck, I was able to verify that my packet serializers and deserializers are internally consistent with each other (ie. parse . unparse == id)
07:15:31 <telemachus> vpetro: that said, the framework provides an uninstaller at /Library/Frameworks/GHC.framework/Tools/Uninstaller
07:15:37 <mm_freak_> is there a fast Integer -> ByteString function?
07:15:44 <telemachus> if you ever want to uninstall or install a new version cleanly
07:15:45 <danderson> which is nice, given how fiddly it gets decoding bits of the packet
07:15:48 <vpetro> telemachus: cool
07:16:21 <telemachus> is anyone else seeking peers on the torrents?
07:16:34 <telemachus> I had a few for the dmg, but now all is quiet...
07:17:27 <danderson> telemachus: I'm still seeding, but no peers
07:18:33 <telemachus> danderson: fair enough; I'm assuming that at some point people will catch on. Yesterday the dmg was projecting 54 hours for me to download. This morning crack of dawn, it took an hour still. So this should be much better...
07:21:46 <ManateeLazyCat> dcoutts: `withCString` can pick-up CString from String, and CString is base on CChar, and have gtk2hs's argument is "const guint8" band guint8 is CUChar, so have exist `withCUString` that i can pick-up CUString from String? Or i need write it my self?
07:22:18 <HugoDaniel> hi
07:22:34 <HugoDaniel> i want to handle http requests really darn fast! whats the best way to do that in haskell ?
07:23:08 <ManateeLazyCat> HTTP
07:23:16 <ManateeLazyCat> @hackage http
07:23:17 <lambdabot> http://hackage.haskell.org/package/http
07:23:20 <HugoDaniel> hmm
07:23:23 <HugoDaniel> and possible do a little cache
07:23:32 <HugoDaniel> like memoizing certain inputs and whatever else...
07:23:48 <ManateeLazyCat> @seen dcoutts
07:23:49 <lambdabot> Unknown command, try @list
07:24:15 <danderson> telemachus: unfortunately, we missed the initial onslaught. We'll do better next release I guess :)
07:24:53 <telemachus> danderson: no worries, better now than never.
07:25:18 <telemachus> I'm still frustrated that the dmg itself seems partly broken on my machine.
07:25:46 <danderson> oh, there goes a download for the windows version
07:25:55 <telemachus> Has anyone been successful with cabal via the new 6.12.1 platform on OSX 10.5.x?
07:26:08 <telemachus> (I know I've asked this, but I'm looking for more data...)
07:26:41 <ksf> it started after I clicked "update tracker"
07:26:48 * hackagebot data-flags 0.0.2 - A package for working with bit masks and flags in general.  http://hackage.haskell.org/package/data-flags-0.0.2 (MikhailVorozhtsov)
07:26:50 <ksf> strangely enough, restarting the torrent didn't do the trick.
07:27:59 <danderson> telemachus: sorry, not I. I run a linux only shop
07:28:26 * quicksilver wonders if the @hackage command should be removed from LB on the grounds that it just makes people think it does something useful.
07:28:36 <telemachus> danderson: probably the norm for most here
07:31:18 <ManateeLazyCat> Have a way that do `String -> Ptr CUChar`?
07:31:19 <ksf> @faq can the @hackage command be removed?
07:31:19 <lambdabot> The answer is: Yes! Haskell can do that.
07:31:28 <ManateeLazyCat> @hoogle "string -> ptr cuchar"
07:31:29 <lambdabot> Parse error:
07:31:29 <lambdabot>   --count=20 ""string -> ptr cuchar""
07:31:29 <lambdabot>              ^
07:31:39 <ManateeLazyCat> @hoogle string -> ptr cuchar
07:31:40 <lambdabot> Did you mean: String -> Ptr CUChar /count=20
07:31:40 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
07:31:40 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
07:35:21 <jeltsch> ,help
07:35:37 <jeltsch> @help
07:35:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:35:40 <Lemmih> ManateeLazyCat: It has to be: String -> IO CString.
07:35:53 <ManateeLazyCat> Lemmih: Yes.
07:35:58 <Lemmih> ManateeLazyCat: Have a look at Foreign.C.String
07:36:08 <ManateeLazyCat> Lemmih: I need CUString
07:36:18 <ManateeLazyCat> Lemmih: CString base on CChar
07:36:25 <ManateeLazyCat> Lemmih: But i need CUChar.
07:36:40 <jeltsch> @faq Can Haskell bring me a cup of coffee?
07:36:41 <lambdabot> The answer is: Yes! Haskell can do that.
07:36:47 <Lemmih> ManateeLazyCat: Cast the pointer?
07:36:51 <ManateeLazyCat> Lemmih: I'm on the way modify `withCString` to `withCUString`.
07:37:09 <ManateeLazyCat> Lemmih: Oh, i forgot it. I try.
07:37:22 <ManateeLazyCat> Lemmih: I don't need write `withCString`....
07:39:05 <ManateeLazyCat> Lemmih: Thank you so much, i forgot i can use `castPtr` and don't need write function for CUChar.
07:39:12 <ManateeLazyCat> Lemmih: Have fix now. :)
07:40:05 <Lemmih> ManateeLazyCat: Excellent. (:
07:40:46 <ManateeLazyCat> Lemmih: I'm try to write my self `withCUString`, and that looks stupid way. :)
07:47:40 <ksf> I think if 9p is extended by a way to specify mime types and e.g. an ebml dtd for each file, then we'd have a type-safe unix.
07:47:54 <ksf> no more grep on application/elf !
07:48:10 <ksf> or, rather, it could grep the readelf -a output instead.
07:48:33 <zygoloid> implicit conversion? :o
07:48:36 <ksf> or an assembly dump or something.
07:48:48 <ksf> only to strings, for inspection.
07:49:12 <zygoloid> whee, php in the filesystem
07:49:26 <ksf> you know, haskell does static duck typing.
07:49:34 <ksf> we have e.g. 1 :: Num a => a
07:49:46 <ksf> or overloaded strings
07:50:23 <ksf> not having that kind of stuff leads you to the abyss of ocaml's /.
07:50:49 <ksf> oh, and FilePath should be [String]
07:51:13 <ksf> ...and type String = ListLike l => l a
07:51:54 <ksf> there's an obvious trend towards typeclassifying everything.
07:52:46 <Mathnerd314> is there a reason type classes are bad?
07:52:58 <Vanadium> Well, they are addictive
07:53:03 <quicksilver> they make type errors hard to follow, sometimes
07:53:16 <quicksilver> and they make code type check in an unexpected way, when really it should have been an error
07:53:44 <ksf> ...it's a thing that should be adressed in h'
07:54:40 <ksf> and when there's a lot of them, you find yourself turning on UndecidableInstances just to be able to write aliases for groups of them.
07:55:07 <zygoloid> ksf: are you suggesting that you should have /usr/bin/sh :: ELF a => a? :)
07:55:28 <ksf> type families tend to be even worse when it comes to type inference
07:56:16 <ksf> ELF (CapSet -> Terminal ())
07:56:48 <Mathnerd314> not even haskell has a perfect type system :'(
07:56:54 <ksf> actually, elf shoudn't be visible in the standard case, at all.
07:57:03 <ksf> stuff should be compiled on-demand
07:58:12 <ksf> with an OS level core language, user-level compilation servers and a trusted cpu server that interprets+jits the bytecode and actually runs it.
07:58:50 <ksf> you can't have proper network transparency without abstracting away the hardware cpu.
08:00:37 <AqD|Home> hello everyone
08:00:45 <ksf> anyway, in comparison to plan9, my linux isn't a unix but DOS.
08:00:46 <AqD|Home> wow there are 666 ppl in the channel XD
08:01:00 <harlekin> n
08:01:06 <harlekin> Sorry.
08:01:14 <AqD|Home> ksf: oh but does plan9 have subpixeling font rendering? :P
08:02:13 <tsou> I'm trying to create a Makefile as shown in http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/separate-compilation.html.   'make depend' runs smoothly, but 'make' fails: don't know how to make Typed/TypeSystem.hi-boot.  Any clues what I've done wrong?
08:02:19 <koala_man> it has Glenda. all other arguments are irrelevant
08:02:26 <AqD|Home> hmmm dunno
08:02:32 <ksf> freetype is quite portable
08:02:36 <AqD|Home> i just began reading the docs....
08:02:59 <ksf> AqD|Home, start here: http://9p.cat-v.org/
08:03:08 * AqD|Home checks
08:03:12 <ksf> It's at the core of everything.
08:04:34 <AqD|Home> hymm acme looks interesting
08:09:48 <ksf> the nice thing about typing files would be that echo cmd foo > /net/ether0/ctl could actually be statically checked
08:10:11 <ksf> string-basedness is still the main weakness of unix
08:11:20 <AqD|Home> hmmm
08:11:37 <fasta> ksf, they are just bytes, which often happen to be ASCII chars.
08:12:05 <ksf> ...exactly.
08:12:16 <fasta> ksf, if there is any problem with Unix it is that there is no concept of structured data.
08:12:22 <fasta> But that might be what you meant.
08:12:57 <fasta> One application outputting structured data requires another to reparse it again.
08:12:59 <ksf> char * being haskell's [Word8]
08:13:32 <ksf> parsing structured data can be vastly more efficient than parsing semi-structured text
08:13:48 <fasta> ksf, right, so we agree :)
08:13:52 <ksf> ...and it can be implemented Once And For All
08:14:26 <ksf> in fact, we don't even have to unparse and parse it if we're in a pipe.
08:14:30 <AqD|Home> how do you define structured data across all the programs??
08:14:36 <ksf> ebml
08:14:45 <ksf> ...which is xml, just in binary
08:15:03 <ksf> matroska uses it as bottom layer.
08:15:14 <fasta> ksf, and how do you make sure that the binary data can be trusted?
08:15:37 <ksf> by attaching a dtd to the file, as attribute
08:15:44 <AqD|Home> hmm but you can't have unlimited length of something in xml
08:15:56 <arw> or by the file beeing some kind of database, like some IBM systems do.
08:15:58 <fasta> ksf, that won't help against hackers.
08:16:10 <AqD|Home> arw: vsam?
08:16:15 * AqD|Home hate mainframe
08:16:18 <Janni> Hi.
08:16:24 <AqD|Home> hi Janni
08:16:31 <ksf> current ebml implementations support lengths of up to 2^128 bytes, which is extendible for future versions.
08:16:37 <fasta> ksf, what stops a hacker/cracker to just say "hi, I am a binary file of the right format", but in fact is not.
08:16:41 <arw> AqD|Home: something like that, yes. i've only seen it, never used it.
08:16:43 <ksf> I think that's more or less future-safe
08:16:50 <ksf> fasta, the file system?
08:16:56 <AqD|Home> ksf: but if the length is uncertain?
08:17:05 <ksf> then there's variable length.
08:17:11 <AqD|Home> um i see
08:17:12 <ksf> even better, you can chunk your stuff.
08:17:17 <fasta> ksf, but then the file system needs this parsing stuff.
08:17:28 <ksf> yep.
08:17:34 <fasta> ksf, or it needs a valid structure preserving API.
08:18:00 <fasta> Well, it might work, but probably nobody will ever put it on a popular OS.
08:18:07 <ksf> otherwise it's going to give it a mime of octet-stream, which means apps know they must parse themselves.
08:18:36 <ksf> I wouldn't dream of implementing a whole OS
08:19:05 <ksf> ...such stuff can readily be done without leaving my own userspace.
08:22:02 <ksf> re invalid data, error handling needs to be in the api, at least optionally.
08:22:13 <ksf> e.g. streaming a file over the network.
08:22:35 <ksf> there's all kind of real-world errors that lurk in every corner.
08:24:17 <mm_freak_> typed files would be great, although i think that even with them most people would use files of type ByteString
08:24:47 <mm_freak_> typed files would only be useful, if the operating system's core is a haskell runtime system =)
08:24:57 <ksf> well... no.
08:25:26 <ksf> if I have a .jpg and a .png in a directory and some server understands both of them, a program can render them easily:
08:26:02 <arw> typed files in the haskell sense would not work. you always would need to be able to cast those files to ByteString for transmission and backup...
08:26:16 <ksf> mount them somewhere where you can access them, and then copy over foo.png/data to /wm/newwin/pixeldata
08:26:26 <ksf> you can do that on the shell.
08:27:27 * p_l points out that untyped files were considered a great feature when they arrived in Unix
08:28:02 * arw agrees with p_l 
08:28:10 * ksf points out that there's Data.Dynamic
08:28:27 <p_l> and one of the historical bugs was leaving typed files in as quick hacks to get certain functionality
08:28:28 <mm_freak_> ksf: sure, you can have type classes on an OS level =)
08:28:36 <zygoloid> huh. enlightenment. for a long time i've thought that binaries should carry with them in some standard format a description of their command-line argument syntax
08:28:43 <zygoloid> i now realize i actually want them to carry types
08:30:01 <ksf> ...actually, the types still need to be dynamic. data and pixeldata have to agree on e.g. a colorspace.
08:30:07 <ksf> ...just like default instances.
08:30:13 <ksf> er defaulting
08:31:17 <ksf> module Grep where main :: [String] -> [String]
08:31:30 <arw> whats more, the system needs to be able to handle files with a 'void' type. for example if some file has a type the system doesn't and needn't know about.
08:31:46 <ksf> application/octet-stream
08:32:05 <p_l> ksf: that's one awfully limited grep
08:32:26 <mm_freak_> anyway, i'm sure that nothing will change in the near future
08:32:30 <p_l> one that I would consider useless
08:32:57 <mm_freak_> our files will be streams of bytes for some time to come, until someone implements and makes popular a typed filesystem, which would be the first step
08:33:08 <arw> ksf: not quite. usually you want to preserve the type. you just want the system to treat it like it was application/octet-stream
08:33:34 <p_l> mm_freak_: then they will still be streams of bytes with extra streams of bytes trying to claim what the former are ;-)
08:33:38 <ksf> yep. needs an application monad which'd be ReaderT env (WriterT log Identity)
08:33:44 <arw> mm_freak_: there is a typed filesystem. file extensions in dos/windows.
08:33:54 <arw> mm_freak_: and mac os also carries type tags.
08:34:15 <ksf> arw, well if you want to treat it as an octet stream, just don't use it in a way that needs interpretation.
08:34:21 <arw> mm_freak_: and unix files are typed based on some magic bytes in the start of the stream.
08:34:26 <mm_freak_> p_l: correct =)
08:34:34 <ksf> or mount it in a way that gives you said octet-stream
08:34:41 <mm_freak_> arw: that's not really a typed filesystem
08:34:49 <ksf> I wouldn't dare messing with the raw data.
08:35:14 <arw> mm_freak_: well. in the sense of dynamic typing, i would argue it is.
08:35:53 <arw> mm_freak_: if i execute a shell-skript, the operating system will start the right interpreter based on the shebang.
08:36:04 <arw> mm_freak_: or use the right loader for an elf or a.out binary.
08:36:20 <mm_freak_> arw: it is as typed as a C array
08:36:23 <ksf> if you want to rip a cd and encode it as flac, copying the track files from the cd won't do it.
08:36:31 <mm_freak_> i rather thought of something like ADTs
08:36:44 <arw> mm_freak_: correct. but there is still a type that is acted upon in certain situations.
08:36:58 <ksf> you'd have to mount the file with an encoding server, and then copy <track>/flac over.
08:37:07 <mm_freak_> arw: you don't need file extensions for that though
08:37:18 <mm_freak_> the files are not typed, but they are interpreted with a certain type in mind
08:37:30 <mm_freak_> that's not even something special, that's the way things are done usually
08:37:39 <mm_freak_> and it's quite unsatisfactory to people like us
08:37:53 <monoidal> A package requires containers-0.2, which isn't supported on 6.12. But http://hackage.haskell.org/package/species says it was built on 6.12. How to do it?
08:38:07 <monoidal> ("containers-0.3.0.0 was excluded because species-0.2.1 requires containers==0.2.*")
08:38:15 <p_l> arw: DOS doesn't have a typed filesystem, not really
08:38:16 <mm_freak_> when i open i file i'd prefer to get a [MyToken] instead of a BL.ByteString
08:38:29 <ksf> DOS has a typed file interface.
08:38:35 <ksf> it knows of text and binary files.
08:38:35 <arw> p_l: regarding .com and .exe, it has.
08:38:41 <p_l> mm_freak_: then implement VMS' file interface
08:38:51 <ksf> guess what the EOF ASCII character stands for.
08:39:08 <lispy> the start of a file?
08:39:14 <lispy> wait wait, I got this...
08:39:19 <lispy> Vertical spacing?
08:39:28 <ksf> you get 200 bytes to describe your .com file in ascii, the rest is program...
08:39:49 <ksf> or was the entry point 200 hex?
08:40:05 <lispy> > 0x200
08:40:06 <lambdabot>   512
08:40:16 <lispy> I bet it's 512
08:40:22 <arw> i think it was 0x200, because of the memory layout.
08:40:33 <mm_freak_> ksf: 0x100
08:40:39 <ksf> I just don't see why a .tar.gz shouldn't be a directory as well as a file.
08:40:48 <mm_freak_> for a .com file
08:40:49 <arw> .com is just packed directly into an area of memory, whereas the loader for .exe is more complex.
08:40:58 <ksf> if you want the contents, open the directory. if you want to email the file, open the file.
08:41:26 <mm_freak_> arw: .com is the same as .exe, it's just a convention to save single-segment executables in a .com file and multi-segment executables in .exe
08:41:30 <ksf> ...whereas opening a file is of course function composition.
08:42:57 <p_l> mm_freak_: .com is not the same as EXE. *.COM (and iirc DOS *.SYS) is directly loaded into memory then jumped to a certain address of it, with no processing done or anything.
08:43:10 <arw> mm_freak_: .exe has a relocation header, .com does not.
08:43:29 <p_l> mm_freak_: EXE, otoh, is a proper executable container.
08:44:07 <ksf> I wouldn't be surprised if exes start execution at 0x100, then jump to an os routine that reorganizes the heap, though.
08:44:39 <ksf> nothing is to braindamaged to be implemented in DOS
08:45:00 <arw> unix binaries work that way :)
08:45:29 <arw> a binary first starts a linker snippet which does the dynamic linking...
08:46:06 <p_l> ksf: nope
08:46:08 <mm_freak_> p_l, arw: DOS interprets both in the same way
08:46:24 <mm_freak_> if the MZ header is there, it's a segmented executable, otherwise it's a single-segment executable
08:47:21 <p_l> arw: ELF itself doesn't do linking, true. It contains string that should describe path to executable that should get passed the file to execute.
08:47:30 <mm_freak_> ksf: DOS .exe files are loaded according to the memory layout specified in the header, there aren't even security checks
08:47:52 <bastl> Can someone recommend a citation for this: If (A,a) is the initial F-Algebra, then a is an isomorphism? I want to mention it on 2-3 lines, and want to refer to a better/longer discussion on it.
08:48:55 <monoidal> lambek lemma?
08:51:06 <bastl> thanks
08:59:05 <bastl> monoidal: many thanks. The paper answers all the questions the "folklore" leave open. (e.g. in the multirec paper this is mentioned as "folklore")
09:04:50 <ksf> structured data makes any separation of files and directories kinda pointless.
09:05:30 <cocon> in practical terms, what is the difference between "seq a $ return b" and "return $ seq a b"? e.g. in the IO monad
09:06:27 <ksf> ...the difference is defined by the implementation of return.
09:07:24 <cocon> ksf: not sure about the implementation in the IO monad
09:07:51 <cocon> for all other monads you are right in pointing out that this is how to find the answer
09:08:09 <ksf> in ghc, IO is an ST monad
09:08:24 <cocon> what's an ST monad?
09:08:34 <ksf> ...which means it's just a phantom type that's passed around to order stuff.
09:08:38 <jmcarthur> i think in IO those might be essentially the same
09:08:51 <ksf> that's what I wanted to say.
09:09:03 <pikhq> cocon: The ST monad is a monad used for imperative programming.
09:09:11 <ksf> there's no fancy constructing going on in IOs return.
09:09:36 <pikhq> It provides a means to save and restore state, and happens to be implemented by GHC, rather than being pure Haskell.
09:09:54 <Cale> I think it's fairly misleading to think of IO as a special case of ST.
09:09:55 <jmcarthur> hmm, does return in the IO monad evaluate its argument? i guess it doesn't
09:10:05 <Cale> It can't, it's not allowed to.
09:10:06 <ksf> newtype IO a :: {runIO :: RealWorld# -> RealWorld# }
09:10:12 <jmcarthur> then those two things are not the same
09:10:29 <Cale> return v >>= f = f v
09:10:35 <quicksilver> cocon: the difference between seq a $ return b and return $ seq a b is that in the former, 'a' is forced when the action is evaluated.
09:10:47 <Cale> So, in particular, return undefined >>= f = f undefined
09:10:55 <quicksilver> cocon: in the latter a is not forced until the action is executed and the value returned is forced.
09:11:01 <jmcarthur> right. not the same as undefined >>= f
09:12:02 <cocon> > (undefined :: IO Int) `seq` 0
09:12:03 <lambdabot>   * Exception: Prelude.undefined
09:12:11 <cocon> > (undefined >> (undefined :: IO Int)) `seq` 0
09:12:12 <lambdabot>   0
09:12:20 <cocon> ??
09:12:32 <quicksilver> what part of that surprises you?
09:12:49 <quicksilver> that's something like
09:12:56 <quicksilver> > [undefined,undefined] `seq` 0
09:12:57 <lambdabot>   0
09:13:13 <cocon> ahhh
09:13:16 <cocon> :)
09:13:18 <Cale> In any case, *evaluating* IO actions doesn't tend to do much.
09:13:20 <pikhq> cocon: (undefined >> (undefined :: IO Int)) is not undefined. It's more WhateverIOsDataConstructor undefined.
09:13:32 <cocon> thanks
09:13:34 <Cale> Only *executing* them has a real noticeable effect.
09:13:39 <jmcarthur> Cale: thank goodness
09:13:56 <sori> I have a standard GHC installation on Gentoo Linux. Could it be the case that I have to install libraries such as Network using Cabal?
09:14:14 <quicksilver> there are gentoo packages for the common libraries
09:14:16 <ksf> you may
09:14:25 <pikhq> sori: You may wish to use the haskell overlay.
09:14:32 <ksf> I recommend doing emerge cabal-install, and then doing the rest via that.
09:14:33 <sori> I see..
09:14:46 <ksf> it's going to pull HTTP, network and so on.
09:15:07 <sori> There is one mystery for me actually.. ghc-pkg tells me that it has Cabal
09:15:08 <pikhq> HTTP, Network, and so on have ebuilds in the haskell overlay.
09:15:15 <ksf> that's the library.
09:15:17 <pikhq> Yes. Cabal != cabal-install.
09:15:32 <sori> Yes, but if I emerge cabal-install, then it installas another version of Cabal
09:15:33 <monoidal> what is the difference between Cabal and cabal-install?
09:15:35 <sori> Isn't this a bit strange?
09:15:35 <ksf> the executable "cabal" is the gentoo (and hackage) package "cabal-install)
09:15:39 <pikhq> Cabal is a library. cabal-install is a package that installs a program with the filename "cabal".
09:16:05 <sori> Maybe I shouldn't complain to have multiple versions of Cabal :)
09:16:20 <jmcarthur> i do wish that cabal-install didn't have cabal in the name
09:16:33 <ksf> are you using ghc 6.10?
09:16:43 <sori> yes sir
09:16:55 <ksf> some stuff changed with 6.12 so newer cabal-install versions need a newer cabal lib
09:17:02 <jmcarthur> is there a gentoo package for the haskell platform? that'd probably be the way to jump start
09:17:12 <ksf> they should work fine with a 6.10 ghc, though.
09:17:15 <pikhq> jmcarthur: Work in progress.
09:17:25 <jmcarthur> ah
09:17:40 <sori> okay.... thanks for the help!! :)
09:17:47 <quicksilver> it is fair to describe this naming convention over cabal-the-library and cabal-the-executable as "A Mistake" IMO.
09:17:51 <quicksilver> :)
09:17:51 <ksf> ...the way to jump-start in gentoo is emerge cabal-install
09:18:24 <ksf> the platform just pulls a lot of outdated and unnecessary dependencies.
09:18:49 <sori> okay by the way indeed it seems that the cabal system is not entirely well integrated with the portage system
09:19:03 <ksf> you mean those scary error messages?
09:19:06 <quicksilver> sori: is there any language for which that isn't true?
09:19:10 <sori> (but this is something that the gentoo people should solve..)
09:19:13 <quicksilver> or any distribution, in fact
09:19:35 <sori> yeah you're right
09:19:53 <quicksilver> {CPAN/gems/cabal/pypi} isn't properly integrated with {ports/ebuild/dpkg} ....
09:19:55 <jmcarthur> honestly, i'm really just parroting the platform stuff. i've never used it and am not sure how useful it actually is. i usually just get ghc and cabal-install
09:20:11 <jmcarthur> *i'm not sure from personal experience how useful it is, that is
09:20:17 <dankna> actually CPAN is deeply integrated with dpkg
09:20:24 <dankna> but most of the other combinations aren't
09:20:27 <sori> I think the portage system could be somewhat more flexible so that it can kind of "extend" with "sub-packaging-systems" like Cabal :)
09:20:32 <ksf> there's CPAN-portage integration, too.
09:20:39 <quicksilver> well, some people have written solutions for some parts
09:20:40 <jmcarthur> bauerbill on arch supports cpan
09:20:47 <quicksilver> but they're not perfect and not universally used
09:20:54 <jmcarthur> it also has a flag to trust hackage packages in aur
09:20:57 <ksf> sori, those .ebuilds are auto-generated from .cabals
09:21:10 <sori> OH, okay..
09:22:15 <sori> (then I've said too much without knowing the system well sorry :))
09:22:41 <ologNation> Is there a way to use the if statement in the imperative style?
09:22:48 <ksf> yes
09:23:09 <ksf> ...just the indentation is non-optimal in haskell98
09:23:20 <ksf> you have to indent the then and else branches
09:23:38 <ksf> it's been fixed in haskell2010, but so far isn't supported in the compiler.
09:23:45 <quicksilver> s/fixed/idiotically broken/
09:23:53 <abbe> imperative style ?
09:24:03 <pikhq> abbe: Presumably he means do notation.
09:24:10 * jmcarthur wishes we just didn't have if syntax
09:24:16 <pikhq> Which isn't exactly imperative.
09:24:22 * ksf agrees
09:24:25 <pikhq> jmcarthur: Here here.
09:24:26 <abbe> pikhq: yes, that is not imperative either...
09:24:44 <abbe> I think he meant to use 'if' without 'else'...
09:24:46 <mm_freak_> jmcarthur: what would you prefer?  an "if" function?
09:24:57 * quicksilver finds if to be convenient, and the indentation to make sense.
09:25:00 <jmcarthur> mm_freak_: why not?
09:25:15 <quicksilver> I'd be reasonably happy if we had a function instead, although it would need more ()s ;)
09:25:15 <zygoloid> jmcarthur: {-# LANGUAGE CPP #-} \n #define if if' \n #define then then' \n #define else else'
09:25:23 <jmcarthur> mm_freak_: it would at least be nice for the identifier to be available
09:25:28 <jmcarthur> zygoloid: ugh...
09:25:30 <zygoloid> :D
09:25:31 <mm_freak_> jmcarthur: well, i already hate to use 'catch', because it messes up the beautiful layout of my code, because i need to use parentheses most of the time
09:25:33 <ksf> mixfix!
09:25:39 <ksf>  ? :
09:25:48 <mm_freak_> having no if syntax would make the same true for every conditional code
09:25:54 <ksf> ...that's going to be a bugger to parse.
09:26:10 <ologNation> pikhq, I can post some code to explain myself, but I'm not finding a good paste bin.
09:26:11 <quicksilver> mm_freak_: I think, probably, the haskeller's dislike of parens has gone to far
09:26:11 <ologNation> ,paste
09:26:19 <jmcarthur> mm_freak_: this is what let and where are for
09:26:21 <ksf> if you need paranthesis, you don't have enough where-clauses.
09:26:21 <quicksilver> mm_freak_: in moderation they really aren't a big deal :)
09:26:24 <zygoloid> mm_freak_: really? i use guards rather than if/then/else :)
09:26:37 <quicksilver> ah now, you see, that's interesting.
09:26:48 <quicksilver> I think "if" is much nicer than where clauses in general
09:26:51 <ksf> ologNation, hpaste.org
09:27:01 <mm_freak_> quicksilver: yes, but they look ugly in otherwise purely layout-style code
09:27:03 <ksf> ...if it's not down, again.
09:27:03 <jmcarthur> mm_freak_: i also wish i could overload if
09:27:08 <quicksilver> I hate disrupting the flow of my code, forcing the reader to keep looking down at the where clause
09:27:13 <jmcarthur> can't do it when it's syntax
09:27:17 <mm_freak_> zygoloid: sure, but sometimes you need if
09:27:23 <zygoloid> quicksilver: interesting. should i imagine you prefer let over where too?
09:27:27 <mm_freak_> or rather sometimes you would _prefer_ if
09:27:37 <jmcarthur> quicksilver: when i use where i tend to use descriptive names
09:27:42 <ksf> there's no code flow.
09:27:45 <jmcarthur> quicksilver: and when i use let i tend to use short ones
09:27:47 <mm_freak_> jmcarthur: uhm‚Ä¶  dunno what that would be good for
09:27:55 <jmcarthur> mm_freak_: DSLs, for one
09:27:56 <ksf> there's only reading the whole of it and then zenning 20 lines in a chunk.
09:27:59 <zygoloid> mm_freak_: usually when i find i would prefer an 'if', i should factor out the code so i can use a guard.
09:28:08 <quicksilver> zygoloid: it's like writing a mathematical paper. Sometimes the discusseion is better suited by bringing in some definitions up front, sometimes an up-front summary with following definition reads better.
09:28:21 <quicksilver> zygoloid: I choose the version which, subjectively, i find reads best.
09:28:27 <mm_freak_> zygoloid: sometimes you don't want to explicitly name a little lambda function
09:28:37 <quicksilver> zygoloid: (and I tend to have a slight bias towards let over where, yes)
09:29:02 <mm_freak_> anyway, i'd really like syntax for exceptions
09:29:04 <quicksilver> equally, as mm_freak_ intimiates, sometimes it's nice to give something a name, and sometimes it's annoying to be forced to.
09:29:22 <mm_freak_> every language has that after all and it looks nice‚Ä¶  you don't need extra names, etc.
09:29:30 * ksf even does where clauses in where clauses
09:29:48 <ksf> as there's only a limited amount of symbols in [f,g,h]
09:29:50 <jmcarthur> ksf: i usually prefer to make new top level functions before i do that
09:30:09 <jmcarthur> sometimes it sucks due to parameter passing though, but i take that as a sign of needing refactoring
09:30:17 <zygoloid> quicksilver: i personally prefer a uniform coding style with rules and exactly one most-appropriate serialization of any particlar idea. but i understand it's a matter of aesthetics.
09:30:21 <ksf> they're usually not functions that can be given a sensible name
09:30:24 <ksf> so I don't.
09:30:41 <jmcarthur> ksf: i don't do functions in where that don't have sensible names anyway though
09:30:49 <jmcarthur> i would use let if i can't give it a good name
09:30:52 <ologNation> I was thinking something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24287#a24287
09:31:00 <ologNation> hi conal
09:31:18 <ksf> it's often stuff like foo = (fmap.fmap) f . bar where f = ...
09:31:29 <fax> ologNation, I'd take this opportunity to complain about how much I hate 'if/then/else' :D
09:31:33 <conal> ologNation: hi.  what's up?
09:31:41 <quicksilver> ologNation: you want "when"
09:31:42 <ologNation> Just hacking away.
09:31:47 <ologNation> quicksilver, thanks.
09:31:51 <jmcarthur> :t when
09:31:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:32:00 <quicksilver> although beware, 'outh' will only be defined inside the when
09:32:03 <ksf> ologNation, that's a case for when
09:32:08 <ksf> you can't have if without else
09:32:15 <ologNation> conal, I'm working on writing this module "Precat" with David Spivak.
09:32:17 <zygoloid> ologNation: you want a 'do' after the 'then'
09:32:19 <ksf> ...it's a total function.
09:32:24 <ksf> *special form
09:32:38 <ksf> *syntactic atrocity
09:32:49 <conal> "curse of the special"
09:32:54 <zygoloid> (or after the 'when' if you're using one)
09:33:01 <ologNation> zygoloid, nested do?
09:33:11 <ologNation> I got an error: The last statement must be an expression.
09:33:11 <zygoloid> ologNation: right. do only covers the immediate children
09:33:30 <ologNation> Maybe my paste was misleading.
09:33:39 <ologNation> There are more expressions after the if statement.
09:33:48 <zygoloid> if you have an 'if' inside the 'do' you need another 'do' for the 'then' and 'else' branches if you want to use 'do'-notation there
09:33:58 <quicksilver> ologNation: think about the scoping of outh
09:34:08 <quicksilver> ologNation: 'outh' can only possibly make sense in the branch where it was defined
09:34:15 <quicksilver> ologNation: therefore, that must indeed be a nested do block
09:34:21 <quicksilver> the 'outer' do block has no outh.
09:34:53 <mm_freak_> something like this would be awesome:
09:34:55 <mm_freak_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24288#a24288
09:35:12 <mm_freak_> you have to admit, this would be MUCH nicer than anything you can come up with using Control.Exception functions
09:35:18 <fax> mm_freak_, looks like randomly inventing new language constructs
09:35:24 <fax> not sure I'm into that
09:35:29 <fax> why not just make it a function
09:35:32 <quicksilver> mm_freak_: I don't have to admit that, no ;)
09:35:46 <quicksilver> mm_freak_: I prefer the existing way because it is just an instance of an existing language construct
09:35:47 <fax> you could write  \   instead of   catch
09:35:48 <mm_freak_> quicksilver: you don't have to, of course ;)
09:35:49 <mornfall> fax: Well, all these things are functions in haskell. :)
09:36:02 <quicksilver> which means you can generalise it and abstract in any way you normally could
09:36:11 <ologNation> Can someone point me to an example of the when syntax?
09:36:26 <quicksilver> when True (putStrLn "hi")
09:36:27 <mornfall> :t when
09:36:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:36:34 <ologNation> (It's hard to google for programming keywords which are also common english words)
09:36:36 <quicksilver> ologNation: no syntax required. It's a plain function.
09:36:37 <mm_freak_> quicksilver: i'd like something in layout-style
09:36:43 <mm_freak_> functions are bad at that
09:36:55 <aavogt> mm_freak_: quasiquoter?
09:36:55 <lambdabot> aavogt: You have 1 new message. '/msg lambdabot @messages' to read it.
09:37:06 <mornfall> mm_freak_: Well, what you usually do to get layout-ish catch is this:
09:37:10 <mornfall> do bla
09:37:11 <mornfall>    bla
09:37:15 <mornfall>  `catch` ...
09:37:15 <sclv> infix functions make it much nicer
09:37:18 <mm_freak_> yes, and then `catch`
09:37:32 <mm_freak_> but it's not as nice as real layout
09:37:43 <jmcarthur> honestly, i don't like it
09:37:44 <mm_freak_> aavogt: i have no experience with inventing language constructs =)
09:37:48 <quicksilver> I don't think I understand why that isn't as nice as real layout.
09:37:53 <jmcarthur> i prefer expressions, not statements. personal preference i guess
09:37:56 <fax> mornfall, was referring to the ad-hoc language construct
09:38:08 <quicksilver> then again I also don't understand what's wrong with parentheses
09:38:12 * fax doesn't subscribe to "more syntax = more powerful"
09:38:15 <quicksilver> perhaps I"m just not made to understand this objection :)
09:38:29 <mm_freak_> quicksilver: because as soon as you have multiple such things in a 'do' or you want more than one handler and probably also a 'finally', your code gets uglier and uglier
09:38:49 <mm_freak_> fax: i don't either, but in this case i do
09:38:54 <mornfall> mm_freak_: And it more and more reminds you that you shouldn't stuff everything into a single function. Yeah.
09:38:57 <quicksilver> seems to me that's *exactly* the problem parentheses solve?
09:38:58 <mm_freak_> you could still use functions, if you prefer
09:39:09 <quicksilver> parentheses help you nest constructs and still be able to see what you're doing
09:39:20 <quicksilver> after all, that's what C/Java/Perl/etc do (using {} not ())
09:39:26 <fax> problem with haskell is it adds all this crap and you can't write variables called 'type' or functions called 'if'
09:39:32 <mm_freak_> mornfall: in imperative code, you often do this, then do that and yet do that, etc.
09:39:47 <quicksilver> editors help even more (by matching parentheses or colouring them are shading the indentation levels or folding the code)
09:39:49 <mm_freak_> and sometimes that "this" and those "thats" are very small things
09:40:02 <mm_freak_> and often they require separate exception handlers
09:40:10 <mornfall> mm_freak_: Never happens to me. Interestingly. :)
09:40:15 <fax> quicksilver -- yeah, it's insane that there's all these people (bloggers) which seem to be not be able to see {} but () sticks out like a sore thumb for them
09:40:21 <mm_freak_> mornfall: doesn't mean it doesn't happen
09:40:58 <jmcarthur> i honestly use exceptions infrequently enough that i don't even know the API
09:41:00 <mornfall> mm_freak_: Well, it probably happens rarely enough to not warrant a special construct in language, if it can be expressed using functions.
09:41:05 <ologNation> Can someone show me a working example of when?
09:41:24 <jmcarthur> > when True (putStrLn "It was True!")
09:41:25 <lambdabot>   <IO ()>
09:41:28 <mornfall> ologNation: when errors_happened $ putStrLn "WARNING: Errors happened."
09:41:32 <jmcarthur> ologNation: ^^
09:41:36 <gwern> wow. the google team has really screwed up on google gears. for months they've been distributing 64-bit google gears to 32-bit users like me!
09:41:45 <mm_freak_> mornfall: i find myself catching much less errors in haskell, because i don't like the syntax
09:41:45 <Twey> Errr
09:41:53 <Twey> So it‚Ä¶ doesn't work?
09:41:59 <sioraiocht> dcoutts: ping?
09:42:20 <mornfall> mm_freak_: I think if you find yourself in need of catching many things in Haskell, you are doing something wrong.
09:42:32 <mornfall> mm_freak_: Eg. structuring your programs too imperatively.
09:42:33 <jmcarthur> mornfall: i wouldn't quite say that
09:42:43 <fax> there's nothing a-priori wrong with adding new syntax, but there's always the chance that it's just this weird special case of something more fundamental
09:42:48 <mm_freak_> mornfall: not every code you write is wonderfully pragmatic, pure and beautiful
09:42:49 <jmcarthur> mornfall: a lot of IO functions that are necessary for the application throw exceptions
09:43:04 <jmcarthur> mm_freak_: i call that failure
09:43:07 <fax> and in general you can get within O(1) of new language constructs in haskell just by writing functions
09:43:20 <mm_freak_> sometimes you just _have to_ do some related things in sequence, but unrelated enough that you can't (or don't want to) just write one big exception handler
09:43:36 <mornfall> fax: There's a language with O(n) language constructs? : - ))
09:43:43 <mornfall> fax: Like, two constructs per program line or so? :D
09:43:53 <mornfall> (distinct, anyway)
09:43:55 <jmcarthur> mm_freak_: i still don't see the issue with just using where for that
09:43:57 <dankna> "When I am working on a problem, I never think about beaty.  But when I am finished, if it is not beautiful, I know that it is wrong."
09:44:01 <dankna> Richard Buckminster Fuller.
09:44:02 <mm_freak_> mornfall: just as a side note, i think i'm very good at writing proper pragmatic haskell code
09:44:24 <fax> mornfall: sure! and there's even pathological languages which are designed to make normal programming idiots exponentially verbose to implement
09:44:25 <mm_freak_> jmcarthur: it makes your code unnecessarily long and introduces names you don't want
09:44:26 <dankna> If your program isn't beautiful, keep working on it until it is.
09:44:39 <mm_freak_> like:  where action1 = blah; action2 = blubb; ‚Ä¶
09:44:47 <fax> dankna, the spooky thing about that quote is that it's actually true
09:44:49 <mm_freak_> sometimes there are no better names for these things
09:44:52 <dankna> fax: yeah I know :D
09:45:11 <dankna> I really like that one, I try to live by it
09:45:33 <mornfall> mm_freak_: Can you show me more than one example of reallife Haskell code where that is a real problem?
09:45:39 <jmcarthur> mm_freak_: i've never seen a case where i have two related actions, know how to handle their exceptions, and yet can't come up with names for them
09:45:59 <ologNation> mornfall, Okay, but        when True  outh <- openFile "output.tex" WriteMode)
09:46:03 <ologNation> doesn't work.
09:46:11 <ologNation> (Parse error in pattern)
09:46:12 <mornfall> ologNation: Sure, it can't.
09:46:23 <jmcarthur> ologNation: outh <- when True (openFile ...)
09:46:26 <mornfall> ologNation: when True $ do blabla
09:46:37 <mm_freak_> mornfall: it would be pointless to make up examples of this right now
09:46:39 <mornfall> jmcarthur: outh would be () that way... not very useful
09:46:41 <ologNation>        when True  $ outh <- openFile "output.tex" WriteMode
09:46:42 <jmcarthur> oh that wouldn't work
09:46:46 <jmcarthur> ignore me
09:46:54 <pikhq> jmcarthur: Except that when :: (Monad m) => Bool -> m () -> m ()
09:46:54 <jmcarthur> ologNation: yes that's right
09:46:55 <mornfall> ologNation: And of course, outh will only be valid in the scope inside when True $ do.
09:47:02 <ologNation>        when True  $ do outh <- openFile "output.tex" WriteMode
09:47:13 <ologNation> also gives an error.
09:47:27 <ologNation> "last statement in a 'do' construct must be an expression.
09:47:35 <mornfall> ologNation: Right, that's also true.
09:47:42 <mornfall> ologNation: You probably want to do something with outh.
09:47:48 <jmcarthur> ologNation: you aren't done writing the function. just finish it and it'll be okay
09:48:00 <jmcarthur> ologNation: in do notation you can't bind a variable and then stop
09:48:04 <mm_freak_> mornfall, jmcarthur: of course, "gimme an example" or "i've never seen that" is always a very bad way to argue
09:48:13 <jmcarthur> you have to end with a line that doesn't bind a variable
09:48:17 <mornfall> (I have a creeping suspicion that you want outh to stay in scope after when finishes, which you can't, though.)
09:48:41 <jmcarthur> mm_freak_: i'm not asking for examples. i just can't imagine any
09:48:46 <Twey> Another reason to hate the new discarded-result warnings
09:48:48 <quicksilver> ologNation: it's hard for us to help you because your program is not complete.
09:48:51 <jmcarthur> mm_freak_: surely something specifically has bitten you for you to feel this way
09:48:53 <mm_freak_> jmcarthur: mornfall was asking for examples
09:48:54 <aslhk> mm_freak_: criticizing the technique of someone's argument instead of addressing the topic is also always a very bad way to argue, and now you have me doing it too! :P
09:49:03 <mornfall> mm_freak_: Well, if you claim there is a pressing need for a cosntruct X but can't give an example of where it is useful, now *that* is a problem.
09:49:11 <quicksilver> ologNation: the key issues here are 'how will outh be used' and 'where will it be used'
09:49:31 <mm_freak_> mornfall: there is no pressing need
09:49:45 <mm_freak_> it's just that syntax for exceptions would be nice, or at least i'd find it nice
09:49:47 <mornfall> mm_freak_: Well, so what's the point then?
09:49:51 <ologNation> quicksilver, Gotcha.
09:49:53 <quicksilver> ologNation: I could imagine what you actually want is "outh <- if True then Just <$> openFile "output.fix" else Nothing.
09:49:59 <mm_freak_> nicer than exception handling _functions_
09:50:02 <jmcarthur> i would find it annoying. it would be yet more things i can't express in normal syntax
09:50:04 <ologNation> I'll work over it a bit more and if it still doesn't work, I'll post the whole program.
09:50:10 <mm_freak_> and you could have both at the same time
09:50:10 <quicksilver> ologNation: which makes 'outh' always exist, but be either Just <handle> or Nothing
09:50:16 <jmcarthur> mm_freak_: how?
09:50:20 <zygoloid> mm_freak_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24288#a24288 <-- pretty sure this is implementable if you s/try/try $/, s/catch/catch $ \\/, s/finally/finally $/
09:50:20 <mornfall> mm_freak_: Well, even for "nicer", an example *where* it would be nicer may be quite useful.
09:50:31 <quicksilver> ologNation: and then, later on, you would write to it only if it exists.
09:51:12 <zygoloid> mm_freak_: though i'm not sure the exception handling constructs would scope in the way you might expect them to
09:51:36 <mm_freak_> jmcarthur: good question, probably by naming the syntactic constructs differently
09:51:40 <mornfall> ologNation, quicksilver, alternatively outh <- if True then openFile "output.fix" else stdout...
09:52:00 <mm_freak_> i'd be happy to see this as a language extension, which people, who like it, can turn on
09:52:03 <quicksilver> yes, or that.
09:52:04 <jmcarthur> mm_freak_: my issue isn't losing those particular identifiers. it's losing any meaningful identifiers
09:52:10 <mm_freak_> it doesn't have to be part of the language standard
09:52:15 <jmcarthur> i'd be fine with an extension as long as it's not a default
09:52:31 <quicksilver> mm_freak_: (return stdout, and I made the same mistake)
09:52:31 <quicksilver> mornfall: that was for you!
09:52:31 <quicksilver> :)
09:52:32 <jmcarthur> i'd also like an extension that turns off if syntax
09:52:48 <mm_freak_> zygoloid: probably not, because ($) binds very weakly
09:52:50 <mornfall> quicksilver: Obviously. The typechecker in my head barfed.
09:52:54 <quicksilver> my gut tells me that a syntax extension would be annoying.
09:53:02 <quicksilver> because there would be cases where you wanted to abstract a particular pattern
09:53:04 <quicksilver> and you can't
09:53:08 <quicksilver> because it's syntax, not a function.
09:53:20 <quicksilver> however, I can't concoct the example that demonstrates that in action.
09:53:44 <mm_freak_> quicksilver: even if it just makes your code look nicer and more layoutish
09:53:53 <jmcarthur> quicksilver: well, taking if syntax as an example, i can't write a point free if
09:54:09 <mm_freak_> obviously there is no technical reason to implement syntax for exceptions
09:54:21 <mm_freak_> but it would look more layoutish
09:54:30 <jmcarthur> @pl \a -> if cond then something else a
09:54:31 <lambdabot> if' cond something
09:54:58 <mornfall> Actually, the uglier the exception handling code is, the less tempted people get to abuse exceptions. : - ]
09:55:19 <jmcarthur> i disagree with that as a reason to uglify something ;)
09:55:30 <mm_freak_> mornfall: do you consider catching exceptions and doing something "finally" an abuse?
09:55:34 <mornfall> jmcarthur: In an ideal world, there would be no exceptions. :)
09:55:43 <quicksilver> jmcarthur: yes, but the if example isn't very convincing.
09:55:52 <quicksilver> jmcarthur: (pointless isn't a goal in itself)
09:55:55 <mm_freak_> well, actually the lack of syntactic support makes me write a lot of with* style functions =)
09:56:06 <mm_freak_> that's good for some things, bad for others
09:56:18 <jmcarthur> quicksilver: okay, how about this? http://hackage.haskell.org/packages/archive/Boolean/0.0.1/doc/html/Data-Boolean.html#t%3AIfB
09:56:25 <fasta> Dijkstra would not approve of exceptions ;)
09:57:10 <jmcarthur> i suppose ifB is just a name, but it would certainly be nice if it could just be "if"
09:57:24 <quicksilver> keyword pollution is definitely an argument
09:57:28 <quicksilver> but it's not the one I was trying to make :)
09:57:41 <quicksilver> I was trying to make the abstraction failure argument.
09:57:46 <mm_freak_> well, maybe we just need some more layout for function application
09:58:03 <conal> jmcarthur: exactly.  the specialness of "if" has been awkward for many of my DSELs.
09:58:09 <mm_freak_> then we could get rid of 'if' and i wouldn't miss syntax for exceptions
09:58:13 <jmcarthur> quicksilver: well, at first i thought you were trying to argue that you couldn't easily separate a function using special syntax into two parts, which is where my point free example came in
09:58:39 <jmcarthur> conal: ha, i didn't even realize you wrote that package
09:58:45 <aslhk> mm_freak_: my experience with haskell is still quite limited, but I have avoided dealing with certain exception heavy circumstances (database heavy activities primarily) because I do not care for the exception syntax either.
09:58:45 <conal> :)
09:58:53 <ksf> graaagh
09:58:55 <jmcarthur> i've used it a few times
09:59:02 <fax> so Iota n = [1..n]?
09:59:08 <ksf> wth can't the linux devs get mount to work as a user?
09:59:14 <fasta> aslhk, there is no exception syntax.
09:59:20 <aslhk> fasta: yes
09:59:24 <jmcarthur> ksf: works for me...
09:59:26 <mornfall> ksf: man pmount?
09:59:28 <conal> my preference is that if we do keep if-then-else then make it desugar into an application of a specific name.  and then let that name be overloadable or whatever.
09:59:33 <fasta> aslhk, by yes, you mean what?
09:59:40 <ksf> I neither want to mount anything I don't have access to, nor do I want to mount it somewhere I don't have permission to.
09:59:40 <fax> conal I just want rid of if/then/else :/
09:59:46 <aslhk> fasta: you are right--it's not special syntax
09:59:50 <fax> conal (it's on my list of bullet points for haskell' :D)
09:59:54 <fasta> fax, if you really want it, just write a preprocessor.
10:00:06 <jmcarthur> ksf: add "user" as an option in your fstab for the volumes you want to mount
10:00:12 <mm_freak_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24288#a24289
10:00:12 <fasta> fax, use LINES pragmas to keep nice error messages. Next problem.
10:00:15 <mm_freak_> look below
10:00:22 <fax> yeah I think I need a preprocessor for anything thing I'm doing
10:00:22 <ksf> ...I want to mount stuff like files via loop in my home, or 9p shares in my home.
10:00:32 <conal> fax: i'd be perfectly happy to drop if-then-else.  it weakens our story that haskell doesn't need hard-wired "control" constructs.
10:00:35 <fax> haven't thought too hard about it though
10:00:36 <fasta> fax, or implement it as a GHC extension.
10:00:36 <ksf> ...without adding them to fstab
10:00:41 <mm_freak_> a hypothetical syntactic ($$) construct, which is like a chain of ($)
10:00:45 <jmcarthur> ksf: i admit to setting up fstab for that, but maybe you want fuse?
10:00:47 <ksf> because /home mountpoints surely don't belong there.
10:00:54 <mm_freak_> a $$ b; c; d = a b c d
10:01:23 <ksf> fuse is user-mountable, but doesn't work for loop devices and for 9p it's an extra layer.
10:01:35 <ksf> ...I've got 9p support in the kernel, after all.
10:01:38 <fax> I also considered a 'lingustic' syntax for functional programming.. which would allow you to type things like   map f over 1 to 10,  a mixture of categorical and hindly milner typing to remove ambiguity
10:01:46 <mm_freak_> that way one could align an action together with its exception handler nicely
10:02:03 <fax> in this case   if foo then bar elsl baz   makes sense
10:02:04 <mm_freak_> using nothing but the usual 'catch' or 'handle' functions
10:02:13 <ksf> I also don't get why one has to be root to chroot.
10:02:22 <fax> but in the current syntax of haskell if/then/else sticks out like a sore thumb (to me)
10:02:33 <fasta> fax, everyone (?) agrees.
10:02:34 <jmcarthur> mm_freak_: i've also named functions ($$) in quite a few DSLs ;)
10:02:45 <mm_freak_> jmcarthur: that's just an example
10:02:47 <ksf> ...root seems to be a sin bin at least as bad as IO
10:02:49 <fax> fasta - well the implementors don't seem to :P
10:02:51 <mm_freak_> you could name that ($$) differently of course =)
10:02:56 <fasta> fax, have you asked them?
10:02:57 <fax> which is what matters
10:03:02 <quicksilver> mm_freak_: Yes, that might be nice
10:03:07 <fax> fasta, by this I mean they haven't removed it
10:03:11 <jmcarthur> fax: i would back you up
10:03:17 <jmcarthur> fax: i'm sure conal would too
10:03:18 <quicksilver> mm_freak_: (might be another thing which is hard to explain to newbies, but still nice)
10:03:25 <jmcarthur> and the others who have complained here about it
10:03:26 <fax> I haven't asked them at all but I am sure they would not just do it if I asked
10:03:37 <fax> and anyway I don't /really/ care
10:03:38 <mm_freak_> quicksilver: newbies don't even need to understand it at first
10:03:39 <conal> jmcarthur: yep
10:03:44 <fax> I do most of my programming in my head
10:03:45 <fasta> fax, send it to the mailing list. If you write a GHC patch, it will probably be applied.
10:03:45 <jmcarthur> they have better things to do, i'm sure
10:03:52 <jmcarthur> one of us would need to make an extension or something
10:03:55 <mm_freak_> newbies could just use if (p 0) (x 1) (y 2)
10:03:59 <fax> actually writing it out and compiling it (let aloneg RUNNING it) is rare for me
10:04:16 <fasta> fax, what kind of job do you have?
10:04:22 <fax> I don't have a job
10:04:22 <quicksilver> mm_freak_: well, no, because they'd still read code written by other people.
10:04:31 <quicksilver> mm_freak_: still, I wonder if this idea has ever been suggested.
10:04:35 <mm_freak_> quicksilver: indeed
10:05:10 <fax> not sure I could hack for a living -- on the other hand not sure what ELSE I could do
10:05:18 <mm_freak_> quicksilver: i'll post it to the cafe
10:05:23 <quicksilver> mm_freak_: good
10:05:49 <ksf> If you have doubts about your programming capabilities, you are more qualified than the bottom 40% of the programmer population.
10:06:02 <quicksilver> mm_freak_: it gives a nice type-safe, language-level way to define "new layout constructs" too
10:06:18 <fax> ksf, no - I'm the best programmer the worlds ever seen, the reason I don't think I could do it is because I'd get bored
10:06:44 <medfly> fax, uh, you're acting strange lately
10:06:59 <ksf> fax, http://www.grammaticalframework.org/
10:06:59 <jmcarthur> quicksilver: if there was a way to replace do notation with something more general that would be pretty awesome
10:07:11 <fax> ksf, what about it ? (I've met this before, it's way cool)
10:07:36 <ksf> ..."linguistic" syntax.
10:07:56 <ksf> it's a hell of a parser/unparser.
10:08:00 <fax> oh yeah actually implementing it is left for anyone that finds it a fun challendeg
10:08:07 * fax has other fish to fry
10:08:30 <gwern> ksf: I once wanted to write an English syntax highlighting mode using gf
10:08:32 <mm_freak_> quicksilver: yeah
10:08:34 <gwern> but I couldn't understand it at all
10:09:03 <ksf> that standard library AST is a bitch, yes.
10:09:04 <quicksilver> jmcarthur: well, that's what mm_freak_ has just suggested, for the case with fixed numbers of arguments and no <- use.
10:09:22 <conal> jmcarthur: indeed.  do is much wartier to me than if-then-else.  like if-then-else, it's a special case (restricted to a single type class out of many), but the desugaring is hairier.   and worse yet, it's designed to reinforce imperative thinking (eg the choice of "do").
10:09:24 <jmcarthur> yeah, i was speaking of handling it more generally than that
10:09:25 <quicksilver> jmcarthur: the other thing you might ask for is layout notation for mconcat
10:09:33 <quicksilver> so you can use it for monoids
10:09:35 <quicksilver> (again no <-)
10:09:35 * gwern thinks it's bizarre that we have such great language modes in our editors, but the most we have for english is spellcheck
10:09:55 <quicksilver> jmcarthur: is there any other case not covered by monad,monoid,function application?
10:09:57 <fax> conal, why is it a bad thing to have imperative paradigm in haskell?
10:10:19 <aslhk> gwern: as soon as someone sends me that bnf for english, we'll be set! *laugh*
10:10:30 <ksf> I've been advocating introducing syntax-define into haskell for ages, now.
10:10:43 <gwern> aslhk: dammit we ought to have something after 60 years of research into parsing english!
10:11:08 <jmcarthur> fax: i think do notation is appropriate for the IO monad, the ST monad, and maybe a couple others, but not for most monads in general (which are not inherently imperative, despite the many protests which typically arise when i claim this ;) )
10:11:09 <fax> ksf -- what about TH? isn't that basically (an ugly but equally expressive) version?
10:11:26 <ksf> ...with emphasis on the "ugly" part.
10:11:38 <aslhk> gwern: whoah, whoah!  You're moving too fast here.  We've been speaking english for hundreds of years, and we can't even agree how to spell the word 'color'.
10:11:40 <ksf> it also doesn't integrate with the built-in parser.
10:11:46 <gwern> ksf: also, emphasis on the 'basically' since it doesn't work so well
10:11:53 <fax> ksf, I found it ugly on a conceptual level as well though -- probably just me being fussy though
10:11:57 <fax> though
10:12:00 <gwern> th is bleeding edge, emphasis on the bleeding
10:12:20 <ksf> my main gripe with TH is that the staging restrictions ought to be less restrictive
10:12:26 <fax> jmcarthur, I agree with athat but it does't really answer the question
10:12:39 <gwern> ksf: I wish it weren't so restrictive about what could be used inside the th splices
10:12:39 <aavogt> what's the need to integrate with the builtin parser... isn't haskell-src-exts good enough for you?
10:12:51 <ksf> it's a shame to suddenly need ten files just because you do a bit of moderately complex stuff...
10:13:02 <gwern> I wanted to compile-time check xmonad keymaps, but no dice, because of the bloody module stuff
10:13:28 <aavogt> gwern: for xmonad there isn't too much of a difference between runtime and compile-time though...
10:13:38 <ksf> modules should be implemented in TH.
10:13:41 <jmcarthur> fax: well, i was speaking of do notation, not really whether imperative programming has a place in haskell (i think it does, just not in as many places as it is usually applied)
10:13:44 <gwern> aavogt: sure there is.
10:14:03 <gwern> aavogt: some runtime stuff is hard to invoke. what if you bind the same key twice?
10:14:16 <gwern> the use of data.map means no error or warning
10:14:19 <aavogt> gwern: why didn't it work to place all keybindings in a TH splice?
10:14:20 <conal> fax: i'd ask whether before why
10:14:36 <gwern> aavogt: th bug/limitation. look up my lenghty email to xmonad
10:14:52 <aavogt> hmm, quasiquotes are more permissive and you can still call error....
10:15:27 <aavogt> gwern: when did it happen?
10:15:36 <gwern> aavogt: year before last iirc
10:16:50 <aavogt> this one: http://article.gmane.org/gmane.comp.lang.haskell.xmonad/6477/match=template+haskell ?
10:16:56 <quicksilver> fax: a more explicit control of staging might also fix it
10:17:40 <aavogt> mmorrow has also been quite helpful to me for TH
10:18:05 <aavogt> there isn't any description of what you actually did though...
10:18:42 <gwern> aavogt: note the lack of my sig
10:19:15 <aavogt> does this mean the gmane has truncated the message?
10:19:21 <aavogt> gwern: I'm confused
10:20:01 <gwern> aavogt: failmane is fail
10:20:09 <gwern> try gooling the email text to find a full copy
10:22:09 <aavogt> I found it
10:22:27 <aavogt> gwern: the alternative is to write most of the config inside a splice
10:22:37 <gwern> aavogt: a wretched subterfuge
10:22:56 <gwern> aavogt: re-reading that, it occurs to me that it might be possible to put the splice inside xmonad-core
10:23:15 <aavogt> xmonad-core is already compiled
10:24:02 <aavogt> presumably the problem is not that the default config has keys that overlap
10:25:00 <gwern> hm. guess so
10:25:10 <gwern> as I said, th has restrictions that make it not very useful
10:25:35 <quicksilver> well, the splice in xmonad-core just needs to (also) generate a type-level representation of the already bound keys
10:25:42 <gwern> checking for dupes is just another example of compile-time stuff which would be useful but th can't do
10:25:55 <quicksilver> that can be combined with the users config to get dups at compile time
10:27:31 <gwern> quicksilver: how would that work?
10:27:43 <quicksilver> I don't know.
10:27:57 <quicksilver> I was just suggesting there might be a solution even though the two bits are compiled at different times.
10:27:58 <aavogt> gwern: you can get dynamic binding in TH splices
10:30:20 <sori> I am running a simple server program listening to the port 1111, and I start a client program that does     connectTo "localhost" (PortNumber 1111)    , and I get the message "resource busy (Address already in use)". Am I doing something conceptually wrong? (sorry, I'm a beginner in socket programming..)
10:31:19 <Ke> localhost is different to internet afaik
10:32:03 <Ke> hmm, or not
10:32:47 <gwern> sori: I wonder about permissions; port 1111 is a low port, under system/root control
10:33:04 <gwern> sori: but usually when I see a similar error from gitit, it's because another gitit was running
10:33:07 <quicksilver> no it's not.
10:33:13 <quicksilver> 1024 is the highest low port.
10:33:25 <gwern> quicksilver: really? I thought low ports went to 4096
10:33:33 <quicksilver> sori: you will need to explain more. you'd expect to get that error from the server, not the client
10:33:45 * gwern should mention that gitit is a server program
10:33:46 <quicksilver> (and that would be because another instance of the server was still running)
10:33:50 <leimy> I've got a program that acts as a service in haskell, but I want it to be able to use timeouts.
10:34:11 <sori> gwern, if I try another port (like 11111) I get the same error...
10:34:22 <leimy> problem is that System.Timeout seems to cause infinite data growth unless I use timeout -1
10:34:43 <sori> quicksilver, hmm,,, then maybe I wrote my client in the "style of server" probably? -_-;
10:34:49 <gwern> @hpaste
10:34:50 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:35:28 <quicksilver> sori: well it's hard to confuse listenOn and connectTo
10:35:36 <sori> quicksilver, indeed..
10:35:38 <quicksilver> but perhaps you'd like to show us what you are doing.
10:35:54 <sori> I'll try to use pastebin!!
10:36:40 <leimy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8823#a8823  <--
10:36:57 <sori> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8824
10:39:50 * gwern shrugs. sori's code looks fine to me
10:39:58 <sori> Hmm.....
10:40:08 <quicksilver> sori: are you running in ghci?
10:40:12 <sori> Maybe I shouldn't run them both in ghci?..
10:40:14 <sori> Ah, yes
10:40:19 <quicksilver> yes, the old server won't die
10:40:24 <sori> Ahh........
10:40:36 <sori> Stupid of me.. Thanks :)
10:44:33 <gwern> sori: yeah, as a general rule if things don't work in ghci, try again with separate binaries
10:47:12 <aavogt> gwern: this is workable if you push the lambda and M.fromList into the splice: myKeys conf@(XConfig {modMask = m}) = M.fromList $(uniqueTupleListQ [ -- rebind standard actions
10:48:54 <sepp2k> Does haskell have a function that takes a regex and a string and returns a list of all (non-overlapping) occurences of the regex in the string? Doesn't look like it from my attempts going through the docs.
10:50:16 <mm_freak_> sepp2k: there are lots of regex packages on hackage
10:50:21 <aavogt> > "hi hi hi" ~= "/hi/" :: [String]
10:50:22 <lambdabot>   Not in scope: `~='
10:50:30 <aavogt> > "hi hi hi" ~== "/hi/" :: [String]
10:50:31 <lambdabot>   Not in scope: `~=='
10:50:41 <mm_freak_> sepp2k: they even define a perl-style operator
10:50:52 <aavogt> > "hi hi hi" =~ "/hi/" :: [String]
10:50:52 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
10:50:53 <lambdabot>                    ...
10:51:37 <quicksilver> the trick is navigating through the maze of twisty overloads
10:51:44 <quicksilver> I'm not particularly fond of that API
10:51:48 <sepp2k> aavogt: Thanks. Somehow I remembered that foo =~ foo :: [String] returned an array of captures.
10:52:18 <gwern> aavogt: you mean the splice would return a partial function which asks for the XConfig as its arg?
10:52:19 <aavogt> it should, but apparently not here
10:52:30 <aavogt> yes, gwern
10:52:57 <gwern> aavogt: would be cool if you'd code that up and send an example to the ml
10:53:30 <gwern> aavogt: I don't think it'd ever make it into the core though because dons and sjanssen know even if they argue otherwise on reddit that th is not to be trusted or used more than necessary
10:53:40 <quicksilver> > "hi hi hi" =~ "hi" :: [[String]]
10:53:41 <lambdabot>   [["hi"],["hi"],["hi"]]
10:53:46 <quicksilver> sepp2k, aavogt ^^
10:54:11 <Twey> Heh
10:54:40 <Twey> ‚ÄòYou are in a maze of twisty little overloads, all alike.‚Äô
10:55:29 <quicksilver> aavogt: no // in haskell REs ;) but I don't know why [String] isn't working. I think it might be overlapping with a Char instance or something?
10:57:44 <zygoloid> > "foo-bar goo-bat moo-bam" =~ "(.oo)-(ba.)" :: [[String]]
10:57:46 <lambdabot>   [["foo-bar","foo","bar"],["goo-bat","goo","bat"],["moo-bam","moo","bam"]]
10:58:18 <zygoloid> > "foo-bar goo-bat moo-bam" =~ "(.oo)-(ba.)" :: String
10:58:23 <lambdabot>   "foo-bar"
10:58:55 <zygoloid> > "foo-bar goo-bat moo-bam" =~ "(.oo)-(ba.)" :: (String, String, String)
10:58:57 <lambdabot>   ("","foo-bar"," goo-bat moo-bam")
10:59:11 <zygoloid> :o
11:00:22 * quicksilver nods
11:00:30 <quicksilver> Yes, I understand what the [[]] instance does.
11:00:46 <quicksilver> I just don't understand why LB isn't seeing the [] instance, which does also exist in the docs I'm looking at.
11:00:55 <quicksilver> RegexLike a b => RegexContext a b ([] b)
11:01:02 <quicksilver> (as well as RegexLike a b => RegexContext a b ([] ([] b)) )
11:01:35 <macron> hi, does anyone know if the parser in haskell-src-meta features antiquotations?
11:02:00 <gwern> anti?
11:02:22 <aavogt> there isn't a parser in haskell-src-meta
11:02:31 <aavogt> it uses the parser in haskell-src-exts
11:05:28 <deech> Hi all, quick question about Control.Applicative.(*>). Is it exactly the same as Control.Monad.(>>)?
11:05:56 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24290#a24290
11:06:16 <jmcarthur> deech: assuming that the Applicative and Monad instances for the type agree, yes, it's the same
11:06:30 <jmcarthur> deech: that is, assuming (<*>) == ap  and pure == return
11:06:34 <maltem> deech, for types that are both monads and applicatives, it is *supposed* to mean the same
11:06:42 <jmcarthur> maltem: that's not specified :(
11:06:56 <macron> aavogt: hm, ok. So that would mean I can't write something like say "let x = Lit (Int 3) in [hs| (\x -> x) 'exp:x]" and expect x to be antiquoted?
11:06:59 <deech> So how do I know which one to use?
11:07:03 <maltem> jmcarthur, but *I* want it ;)
11:07:28 <jmcarthur> deech: if you want it to have an Applicative constraint, use (*>). if you want it to have a Monad constraint, use (>>)
11:07:45 <maltem> but yeah you're right
11:07:56 <jmcarthur> deech: if Monad was defined to require Applicative then you could just use (*>) without issue, but unfurtunately it's not
11:08:15 <jmcarthur> *unfortunately
11:08:21 <HugoDaniel> ghci segfaulting http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24290#a24290 ftw!
11:08:22 <deech> And if the library author gives me both instances, test that they do the same thing or look at the source?
11:08:43 <jmcarthur> deech: generally i just assume they agree, but i shouldn't
11:10:52 <astrocub> are there any web scraping libraries available?
11:10:53 <deech> Cool, I'll assume they are until my app doesn't behave and then I'll check.
11:10:57 <deech> thanks!
11:11:20 <jmcarthur> deech: ha, i feel like i just gave risky advice
11:11:48 <jmcarthur> astrocub: try tagsoup. it's not as sophisticated by the python library of the same name, but it's handy for what it does
11:11:59 <jmcarthur> *as sophisticated as the ...
11:12:02 <deech> This is normal coding technique for any other language. Haskell has spoiled you!
11:12:02 <gwern> tagsoup has served me well in the past too
11:12:10 <aavogt> macron: you have to write   [$hs| (\x -> x) exp : x |] if that's what you're thinking about
11:12:12 <jmcarthur> deech: perhaps ;)
11:13:46 <macron> aavogt: aha! thanks for the tip. Though I don't understand how the haskell-src-exts parser differentiates exp : x from a type annotation.
11:14:24 <gwern> wouldn't a type annotation be :: ?
11:15:17 <macron> gwern: uh woops, i mean a cons. Mind polluted by ML, sorry.
11:17:11 <pmaes> Am I supposed to have cabal-install after installing the latest Haskell Platform? I'm on a mac and installed using the dmg. I have ghci, ghc and everything else I can think of except the cabal executable.
11:21:24 <Twey> Does ·µπ render double-width for anyone else?
11:21:31 <Botje> no
11:21:33 <lament> yes
11:21:42 <Botje> wait
11:21:52 <lament> i have no idea what it is, though
11:22:02 <lament> i just see three spaces between "does" and "render"
11:22:04 <aavogt> ? is double-width for me
11:22:18 <lament> so it must be triple-width!
11:22:38 <aledge> mine is a tiny box with "1D79" in it
11:22:42 <aledge> or "17D9"
11:24:34 <Twey> It's meant to be an insular ‚Äòg‚Äô
11:25:23 <Twey> My emacs renders it double-width for some reason ‚Äî the character is twice as wide as the glyph, but the right half is blank
11:26:22 * jmcarthur wonders if his unicode is working in weechat...
11:26:43 <jmcarthur> hmm, it is
11:26:58 <jmcarthur> i have no idea what that character is that Twey typed though
11:27:05 <macron> aavogt: seems the "exp:" qualifier isn't even necessary. For instance, the following works: "let x = 4 in [$hs| (\x -> x) x |]".
11:27:50 <Twey> jmcarthur: You probably just don't have the fonts‚Ä¶ it's a fairly rare character
11:28:14 <jmcarthur> Twey: probably. i'm using Menlo
11:28:18 <Entroacceptor> Twey: I can see it, but it's got single width
11:28:25 <Entroacceptor> but wwhat is it?
11:28:52 <Twey> 18:24:12 < Twey> It's meant to be an insular ‚Äòg‚Äô
11:29:04 <Entroacceptor> but what is it?
11:29:13 <Twey> I don't understand the question
11:30:12 <Entroacceptor> I don't understand your glyph. And what does 'insular' mean in this context?
11:30:33 <aavogt> macron: a quasiquoter for haskell seems pretty useless...
11:30:49 <aavogt> you could just write     let x = 4 in (\x -> x) x
11:31:03 <Zao> Twey: Assuming that there's one space on both sides, it renders as wide as a regular narrow latin glyph.
11:31:14 <aavogt> > let x = 4 in (\x -> x) x
11:31:15 <lambdabot>   4
11:31:17 <Zao> In Consolas.
11:31:32 <Twey> Interesting
11:32:25 <Twey> Entroacceptor: ‚ÄòOriginating from an island‚Äô
11:32:30 <Zao> Twey: http://www.acc.umu.se/~zao/insular.png
11:32:42 <Twey> How can you not understand a glyph?  It's a glyph ‚Äî there's not much to understand about it :√æ
11:32:51 <Entroacceptor> which island?
11:33:05 <macron> aavogt: well, i'm generating writing a haskell program that generates a haskell program in a file. I could just generate a TH ast and pretty print that, but I'd like to take advantage of the haskell-src-exts pretty printer. But then writing down haskell-src-exts AST constructors all over the place gets fairly unwieldy, hence the desire for quasiquotation.
11:33:12 <Twey> Entroacceptor: The island of Ireland
11:33:33 <aavogt> then that quasiquoter is not the one you want
11:33:34 <Twey> Zao: *nod* That's how it renders in my terminal, but not in emacs or Chrome
11:33:39 <Twey> (well, Chromium)
11:34:43 <Entroacceptor> Twey: even my emacs renders it properly
11:35:13 <aavogt> since when that one is run, you end up with whatever the AST represents
11:35:22 <mm_freak_> it's interesting to see that haskell libraries for networking aren't labeled "secure"
11:35:46 <mm_freak_> it's a "fast, elegant HTTP library", not a "fast, secure HTTP library"
11:35:55 <Twey> Entroacceptor: Under X?
11:36:00 <Entroacceptor> yes
11:36:06 <Twey> Interesting
11:36:25 <aavogt> macron: basically you need the same quasiquoter except one that applies lift to the Exp that it parses. I'm not sure if there's one that does that in the haskell-src-meta library
11:36:57 <Entroacceptor> the terminal-emacs just shows a box
11:37:09 <jmcarthur> mm_freak_: define the kind of security you mean?
11:37:27 <mm_freak_> it seems like security (in whatever sense) is an explicit feature of packages in other languages, whereas in haskell that feature is regarded as implicit and implied by design
11:37:35 <jmcarthur> ah
11:37:38 <Entroacceptor> hu???
11:37:48 <jmcarthur> i was thinking that, but i wasn't sure if it was the point you were trying to make
11:38:00 <Entroacceptor> my terminal shows just a box, but the irssi-screen-ssh-terminal combo shows a nice curvy thing
11:38:08 <Entroacceptor> I hate computers.
11:38:17 <jmcarthur> mm_freak_: security is especially implied by the word "elegant," at least in my mind
11:38:43 <mm_freak_> yeah, me too
11:38:44 <Twey> Entroacceptor: Hehe
11:38:45 <jmcarthur> mm_freak_: maybe "safety" is a more apppropriate word, though
11:39:01 <jmcarthur> than security, that is
11:40:03 <mm_freak_> whatever you name it, it's just funny that every second C library sells itself as "secure", while i haven't found a single package on hackage, which is "secure"
11:41:08 <idnar> mm_freak_: well, it's kinda implied by the "haskell" bit :P
11:41:21 <Twey> I guess it's something to do with the fact that ‚Äòsecure‚Äô is so much harder to achieve in C.
11:41:21 <idnar> python etc. libraries don't bother with that either
11:41:23 <Entroacceptor> that's a dangerous attitude
11:41:23 <jmcarthur> mm_freak_: in page search on the hackage listing only reveals one result with "secure" in the desciption, and it's about password-pased security schemes
11:41:29 <mm_freak_> idnar: that's my point
11:41:40 <mm_freak_> jmcarthur: exactly
11:42:01 <idnar> Entroacceptor: well, sure, security is a lot more involved than that
11:42:14 <mm_freak_> Twey: or rather that "secure" is something explicit in C‚Ä¶  you have to provide safety, so code is unsafe by default
11:42:26 <Twey> Like I said
11:42:27 <idnar> Entroacceptor: but when people call a C library "secure", what they really mean is "has less than 9000 buffer overflows"
11:42:32 <Twey> Heh
11:43:06 <jmcarthur> one of these days i'd like to give a talk for my coworkers about haskell and its security benefits. we're do 99% C right now
11:43:09 <mm_freak_> idnar: well, it says, "we care about code safety, because we know that we have to in this language" =)
11:43:09 <jmcarthur> *we do
11:43:14 <idnar> Haskell's purity helps a lot, though
11:43:54 <danderson> jmcarthur: that's one of the selling points (well, it's open source, but you get the idea) of the VPN daemon I'm building atm
11:44:06 <jmcarthur> for the things we mostly do, it makes sense to use C, but we are also a security company, so it would be nice for me to make sure people are aware of the benefits of type safety and such
11:44:08 <idnar> if you're writing some Python code, you don't need to worry about buffer overflows or printf formatting exploits or whatever, but you do still need to worry about other ways to trick the program into doing something nasty
11:44:20 <danderson> assuming performance is acceptable, would you rather have software that is critical to network security be in an unsafe language or a safe one?
11:44:23 <jmcarthur> danderson: heh, i was just fussing with openvpn today
11:44:26 <idnar> pure Haskell code simply can't do anything worse than use up all your memory and CPU cycles
11:44:48 <idnar> so unless you wrote your whole program in the IO monad, you only have to worry about 10% of it
11:44:53 <danderson> not to say that the haskell code is automatically perfectly secure (DoS, bug in the runtime, bug in a library that does unsafe IO...)
11:45:29 <danderson> but since I'm the least bright programmer in the stack of brilliant people who built the runtime and libraries, eliminating that whole class of risk from *my* toolbelt is a huge win, imho.
11:45:41 <idnar> and I think in general, Haskell programmers seem to be smarter, so you're less likely to find an SQL library that requires you to use it by doing string interpolation, or something like that
11:45:41 <danderson> also, quickcheck *rules* for testing routing engines.
11:45:52 <idnar> s/smarter/better informed/ perhaps
11:45:53 <jmcarthur> we also are looking into a portland office and it would be awesome to set the deck to do some with work with galois or something
11:45:57 <mm_freak_> jmcarthur: sadly many people think that security comes from low level control
11:46:15 <jmcarthur> mm_freak_: well, in our case we really do need some C-level stuff
11:46:20 <idnar> mm_freak_: certain types of security do
11:46:28 <idnar> mm_freak_: for example, side channels involving the state of CPU or memory
11:46:29 <danderson> jmcarthur: what sort?
11:46:34 <mm_freak_> and to some extent i understand what makes them feel that way, because i used to program in C, too
11:46:36 <jmcarthur> mm_freak_: we do mostly kernel-level programming, on-the-fly decryption of executables in memory, etc.
11:46:50 <mm_freak_> at that time i couldn't even spell "type safety" or "side effect"
11:47:09 <idnar> but I think Haskell is actually remarkably close to the "bare metal" for such a high-level language
11:47:10 <danderson> put another way, how much of the C level code could you lift into haskell, plugging the rest in via FFI?
11:47:48 <danderson> initially for my VPN stuff, I thought I'd have to have some C library to talk to the kernel, to negociate the creation of the virtual network interface
11:47:53 <jmcarthur> danderson: for our flagship products, not much. for some of the research we are doing, perhaps a fair bit
11:48:05 <danderson> turns out that an FFI to ioctl() takes care of that, such that I have no C code outside of the libc
11:48:17 <amuller> hello, how do I efficiently write an INT into a ByteString?
11:48:33 <danderson> and as a result, I'm not futzing around with buffers and stuff that can overrun
11:49:02 <danderson> amuller: you'll have to be more specific. What encoding do you need? How many bits, big or little endian, etc.
11:49:15 <jmcarthur> danderson: i was wanting to write some of the userspace code for my current project in haskell, but i haven't even formally pitched haskell yet and i don't want to do anything to break maintainability without at least having a few nods of encouragement
11:49:15 <danderson> or even, do you want to write the ascii representation of the number into the ByteString?
11:49:27 <gwern> amuller: maybe you should look into the 'binary' package
11:49:43 <amuller> danderson: yeah, I want to print is as an ascii string using ByteString.Lazy.Char8
11:49:49 <sori> May I give one handle (of a socket connection) to multiple IO forks without further ado?
11:50:21 <amuller> danderson, gwen I want to write a very large csv file.
11:50:23 <gwern> amuller: so then use 'pack' and 'show'?
11:50:38 <amuller> gwen: I use pack and show but maybe there is something more efficient?
11:50:44 <gwern> if you want to write string values there's going to be inefficiency
11:51:58 <BONUS> sori: you might run into race conditions and such. personally, i'd pack it up in a MVar
11:52:19 <danderson> you can probably write a more efficient serializer with the cereal library and its Put monad, but: does the (pack . show) show up in a CPU profile?
11:52:28 <amuller> gwen: hmmm too bad :(
11:52:31 <danderson> if it doesn't, there's no point in losing code clarity by optimizing it
11:53:11 <amuller> danderson, I had very bad performance when doing the oposite "read unpack", so I assumed that the same issue occurs in the other direction
11:53:21 <sori> BONUS, I see.. Thanks!! (I was wondering to what extent I should use shared variable mechanisms.. So it seems that handles should also be treated by the mechanism.)
11:53:35 <danderson> amuller: possible, but avoid assuming
11:54:10 <danderson> the compiler is pretty smart, especially when you compose functions like this
11:54:39 <amuller> danderson: OK, I will try it with show, thank you for the advice
11:55:04 <danderson> can (pack . show) 42 trigger stream fusion and get rid of the intermediate list?
11:55:12 <danderson> better haskellers than myself should know.
11:55:41 <amuller> danderson, ohhh, that would be cool. I am a newbie so I don't have any idea about stream fusion :)
11:56:32 <amuller> danderson: One more question, if I have "print c = L.pack $ show c" and c is an enum value. Would this result be cached by the compiler?
11:57:06 <zygoloid> amuller: no.
11:57:07 <macron> aavogt: yes, i see. That shouldn't be a problem, AFAICT. I can just define a new QuasiQuote that just lifts the result of the hs QuasiQuote.
11:57:28 <gwern> danderson: they're pure functions, so I would expect it too
11:57:34 <amuller> zygoloid, OK thanks... is there a way of caching these values?
11:58:14 <zygoloid> amuller: yes, there are lots of ways. can you say anything more about the type of c?
11:58:56 <danderson> gwern: thing is, the last update to ticket 915 still says that you need to explicitly use the stream fusion library to get anything out of it, and that there are problems with getting that optimization into GHC's basic list functions
11:59:03 <zygoloid> if all you know is that it's an instance of Enum, i don't think that's quite enough (due to poorly-behaved Enum instances like Double you can't just key off fromEnum)
11:59:03 <danderson> so I'm not quite sure what to think.
11:59:25 <amuller> zygoloid: it is just an enumeration of the form: data Chromosome = C1          | C2            | C3            | C4           | C5         | C6
11:59:56 <amuller> the deriving is: deriving (Read, Show, Ord, Enum, Eq)
12:05:49 <sori> I'm writing a networking code which forks a thread. But the program terminates after having forked the thread. Could anyone tell me how I may correctly let the program "wait" until the thread dies?
12:08:06 <glguy> sori, you can create a new mvar, have your forked thread put a unit into that mvar when it is done, have your main thread wait for the unit
12:08:33 <BONUS> yeah, was about to say that
12:08:43 <glguy> I was about to say that you would
12:09:30 <sori> glguy,BONUS, hehe, thanks. I haven't learned to work with mvars yet, but I'll try to follow that guideline. :)
12:09:56 <BONUS> so you do m <- newEmptyMVar; forkIO (do  ... forked code here ...; putMVar m ()); takeMVar m
12:10:20 <BONUS> a MVar is like a box that can be empty of full. and if a thread tries to put something into a full box it will block until some other thread has freed the MVar
12:10:32 <BONUS> also if it tries to take something from an empty box it will block until some other thread puts something in it
12:10:45 <BONUS> that's pretty much it for MVars
12:13:03 <sori> BONUS, Alright... thank you very much. I think I got it. I'm trying to code it.. :)
12:14:40 <DekuNut> I'm sure there was a command for lambdabot which let you find functions based on their type, what is it? I can't find it D:
12:15:59 <DekuNut> Never mind, I'm an idiot sorry
12:16:03 <dankna> @hoogle a -> a
12:16:03 <lambdabot> Prelude id :: a -> a
12:16:03 <lambdabot> Data.Function id :: a -> a
12:16:03 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
12:16:08 <dankna> like that
12:16:16 <DekuNut> Yeah, I JUST found it as you typed it
12:16:19 <dankna> hehe okay
12:16:19 <DekuNut> Thank you
12:16:24 <DekuNut> Rofl
12:16:52 <dankna> I'm glad this channel is publically logged - there's so much valuable information here
12:16:55 <dankna> just a random musing
12:19:10 <DekuNut> Nah, moments of realization that I'd forgotten a while later were easy to come back upon searching the logs
12:19:14 <DekuNut> It's really nice
12:19:28 * dankna nods
12:20:06 <ologNation> Well, thanks for your help with my homework machine.
12:20:23 * ologNation is working on making his messy tests nice with HUnit.
12:20:29 <dankna> ologNation: hahaha
12:20:55 <dankna> ologNation, there was some kids' book I read twenty years ago where the genius kids made a homework machine to do their math problems for them
12:21:08 <dankna> the catch?  to make the machine required them to understand calculus.  to do algebra problems.
12:21:21 <dankna> and they didn't realize it was actually harder, because it was more fun.
12:21:23 <fax> you don't have to be a genuis these days to make a homework machine haha
12:21:27 <dankna> haha true ture
12:21:28 <Nafai> dankna: Sounds like an awesome story!
12:21:28 <dankna> *true
12:21:30 <dankna> it was!
12:21:40 <dankna> I don't remember the title of that series, but I remember loving it
12:21:58 * fax remembers doing this in high school
12:22:02 * dankna laughs
12:22:46 <DekuNut> That's brilliant
12:22:56 <DekuNut> If I ever become a teacher, I'm going to set building a homework machine as homework
12:22:59 <dankna> hehehe
12:23:11 <DekuNut> Then they can try going about building a homework machine that builds homework machines
12:23:15 <fax> or just set "solve these ten million problems by friday"
12:23:15 <dankna> smirk
12:23:17 <dankna> that would rock
12:23:25 <dankna> there's that famous story about, who was it, Newton?
12:23:36 <dankna> the teacher assigned some busy-work, sum all the numbers from 1 to 100 or something
12:23:42 <dankna> he derived the formula in his head and came up with the answer that way
12:23:49 <dankna> infuriating the teacher, who had worked it out the long way in advance
12:23:51 <fax> was that Gauss.. orEuler
12:23:51 <gwern> dankna: about adding 1 to 100?
12:23:55 <dankna> yeah, that one
12:23:57 <gwern> it was gauss iirc
12:24:01 <dankna> quite possible
12:24:03 <DekuNut> Oh, going from 100 backwards and 1 forwards, I liked that
12:24:16 <fax> internet says Gauss
12:24:17 <fax> :D
12:24:20 <dankna> internet is handy
12:24:46 <DekuNut> The internet is pretty much the homework machine you described
12:24:50 <dankna> this is true
12:25:04 <dankna> of course the machine has some parts which generate large amounts of friction
12:25:12 <dankna> as when somebody comes in here for help with their Java homework :)
12:25:22 <DekuNut> Rofl
12:25:28 <c_wraith> man, if "build the internet" was a homework assignment, it'd better give some extra credit
12:25:32 <dankna> quite so
12:26:52 <DekuNut> Creator of the internet, a cisco certification
12:26:56 <DekuNut> Er
12:27:09 <DekuNut> No yeah cisco, brain malfunctioned
12:27:27 <DekuNut> I'm becoming more and more forgetful recently D:
12:27:31 <dankna> this happens :/
12:27:44 <medfly> DekuNut, hehe. kind of funny. I have some lame homework that requires a lot of meticulous hand work and I'm thinking of writing code to do it (as an assigvnment, instead)
12:27:45 <medfly> :)
12:28:14 <DekuNut> Rofl, as long as you still get the marks
12:28:30 <DekuNut> I made that mistake
12:28:40 <Twey> medfly: I did that at GCSE
12:28:42 <medfly> it's not marked :)
12:28:46 <Twey> Lost marks for it ‚òπ
12:28:57 <medfly> GCSE?
12:28:57 <DekuNut> Teacher set a project to make a text base adventure game, it was too simple, so I wrote a language, then wrote my game in that language
12:29:05 <DekuNut> My game was short though, as I was too lazy to write the game afterwards
12:29:11 <DekuNut> Everyone received marks but me
12:29:14 <dankna> ahhh
12:29:16 <dankna> that is a shame
12:29:28 <Ke> I remember when I was a kid I thought that professional matematicians just do regular computations with larger numbers
12:29:41 <dankna> Ke: hehehehee, amusing.  Probably a common supposition.
12:29:45 <Ke> "He can multiply 1000 000 with 1000"
12:30:00 <dankna> 10^9.  Does that make me a professional?
12:30:15 * Ke worship worship
12:30:16 <medfly> ke, it's what a lot of people seem to think
12:30:24 <medfly> it's a really strange thing to think
12:30:39 <DekuNut> I can work out the answer to 123456789 + 987654321 instantaneously
12:30:44 <DekuNut> I am a genius as you can see
12:30:54 <gwern> Ke: as a kid I thought the same thing
12:30:58 <dankna> I can't - it takes me a moment to figure out that every single place has a carry and none of the carries interfere with each other
12:31:17 <JuanDaugherty> of what interest are the conceptions of the unlearned masses?
12:31:26 <dankna> great interest - to a sociologist
12:31:33 <gwern> JuanDaugherty: everyone was an analphabetic prole at some point
12:31:43 <dankna> analphabetic - haha
12:31:53 <DekuNut> Some day when mathmatecians take over the world, I'm sure it will have been time well spent
12:32:06 <JuanDaugherty> gwern, perhaps, I was taught to read at a very young age and don't remember it
12:32:07 <DekuNut> mathematicians D:
12:32:24 <gwern> dankna: what is funny about that adjective?
12:32:48 <dankna> gwern: just that I'd never heard it before and it's amusing to think of classifying people in that regard
12:32:55 <gwern> @wn analphabet
12:32:57 <lambdabot> *** "analphabet" wn "WordNet (r) 2.0"
12:32:57 <lambdabot> analphabet
12:32:57 <lambdabot>      n : an illiterate person who does not know the alphabet [syn: {analphabetic}]
12:32:58 <JuanDaugherty> i meant of course in intellectual discourse, not in general
12:33:16 <dankna> Juan: yes, but it amused me to take you literally
12:33:17 <gwern> @wn abcedarian
12:33:18 <lambdabot> No match for "abcedarian".
12:33:20 <gwern> lies
12:33:26 <dankna> @wn sesquidilophile
12:33:26 <lambdabot> No match for "sesquidilophile".
12:33:28 <JuanDaugherty> or more specifically in mathematics, computer science, etc.
12:33:36 <gwern> @wn abecedarian
12:33:37 <lambdabot> *** "abecedarian" wn "WordNet (r) 2.0"
12:33:37 <lambdabot> abecedarian
12:33:37 <lambdabot>      adj : alphabetically arranged (as for beginning readers)
12:33:37 <lambdabot>      n 1: a novice learning the rudiments of some subject
12:33:37 <lambdabot>      2: a 16th century sect of Anabaptists centered in Germany who
12:33:39 <lambdabot>         had an absolute disdain for human knowledge
12:33:40 <dankna> @wn sesqeue
12:33:41 <lambdabot> No match for "sesqeue".
12:33:44 <dankna> @wn sesque
12:33:45 <lambdabot> No match for "sesque".
12:33:47 <dankna> @wn sesque*
12:33:48 <lambdabot> No match for "sesque*".
12:33:50 <dankna> whatever :)
12:34:21 <medfly> humans with a disdain for human knowledge...
12:34:37 <gwern> medfly: it'd be kind of silly to disdain feline knowledge
12:35:13 <dankna> @wn sesquitertian
12:35:13 <lambdabot> No match for "sesquitertian".
12:35:38 <gwern> that doesn't look like a valid spelling at all
12:35:46 <dankna> it's in /usr/share/dict/words
12:35:54 <gwern> 'having ratio 4:3.'
12:35:59 <dankna> unless I mistranscribed it
12:36:08 <dankna> yeah, it wasn't the word I was thinking of anyway
12:36:13 <dankna> though it remains a cool word
12:36:18 <JuanDaugherty> yeah
12:36:24 <dankna> I don't like sesquitertian videogames, I think they're uncreative
12:36:25 <JuanDaugherty> sounds nice whatever it is
12:36:27 <dankna> I prefer widescreen ones
12:36:44 <dankna> I have to drop this word in videogame-related chats now, because that actually is my opinion :D
12:36:58 <dankna> tall narrow ones are also interesting
12:39:50 <wasted> ok I have a question... it should be pretty simple but I'm having a hard time wrapping my head around it
12:40:03 <wasted> how does "let rev list = foldr rcons id list [] where rcons a f b = f(a:b) " reverse a list?
12:40:42 <wasted> i've traced output in various ways, but I'm left scratching my head. I'm not entirely clear on what 3 arguments are even getting passed to foldr
12:40:44 <fax> wasted: it's revappend
12:40:55 <Botje> wasted: expand it manually for [x,y,z]
12:41:10 <fax> revappend [] ys = ys ; revappend (x:xs) = revappend xs (x : ys)
12:41:15 <fax> ^ understand this first
12:41:37 <fax> well I missed out ys on the second case
12:41:48 <gwern> > let rev list = foldr rcons id list [] where rcons a f b = f(a:b) in rev [x,y,z]
12:41:49 <lambdabot>   [z,y,x]
12:42:01 <gwern> drat.
12:42:18 <fax> @pl revappend (x:xs) ys = revappend xs (x : ys)
12:42:18 <lambdabot> revappend = fix ((`ap` tail) . (. head) . (. (:)) . flip . ((.) .))
12:42:29 <fax> @pl revappend x xs ys = revappend xs (x : ys)
12:42:29 <lambdabot> revappend = fix ((. (:)) . flip . ((.) .))
12:42:32 <fax> hm
12:43:03 <gwern> > let rev list = foldr rcons id list [] where rcons a f b = \x -> f(a:x) in rev [x,y,z]
12:43:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = [a] -> t
12:43:12 <wasted> wohhaaa ok guys I'm gonna read through all this... but could anyone let me know simply what operation is getting passed into foldr... I have a hard time seeing how the rcons is being partially applied... or something
12:43:13 <Botje> rcons z id = (\a f b -> f (a:b)) z id = (\b -> id (z:b))
12:43:26 <gwern> bollocks. I know the simple reflect stuff can show the full call chain
12:43:29 <fax> @pl revappend x xs ys zs = zs (x : ys)
12:43:30 <lambdabot> revappend = const . (flip id .) . (:)
12:43:46 <wasted> gwern: I have some traces, sadly I can only show list and value arguments, not functions
12:44:06 <mm_freak_> is B.concat . BL.toChunks really the easiest way to make a ByteString strict?
12:44:10 <fax> wasted, anyway that's how it works
12:44:12 <mm_freak_> it looks quite ugly
12:44:29 <wasted> yeah well sadly I have to explain _how_ its working
12:44:37 <gwern> mm_freak_: sorry
12:44:46 <gwern> wasted: then expand it by hand
12:44:47 <Botje> wasted: foldr f a xs = x1 `f` x2 `f` ... `f` a
12:44:57 <mm_freak_> gwern: huh?  sorry for what?
12:45:05 <gwern> mm_freak_: for you
12:45:10 <Botje> wasted: the last terms (for [x,y,z]) is z `rcons` id
12:45:26 <Botje> wasted: work out what z `rcons` id means, then try y `rcons` z `rcons` id
12:45:44 <Botje> (if you look up, i did the first one already, but try for yourself first)
12:45:48 <fax> wasted to whom?
12:45:58 <wasted> ok Botje... I think that's getting me there!
12:46:14 <wasted> fax, I'm not gonna lie, its a coursework
12:47:00 <wasted> I did a few traces, with what you guys have said I'm sure I can piece it together - I'm really suprised i'm being stumped by such a simple one liner
12:47:36 <c_wraith> ok, mystery time:  What can make a haskell process stop working and ignore SIGTERM?
12:47:44 <fax> wasted, it's not simple
12:47:56 <dankna> c_wraith: an FFI call to the POSIX signal-handling functions? :)
12:48:20 <Botje> wasted: sometimes you have to work things out by hand
12:48:26 <wasted> fax: thanks, I'm left feeling rather dumb. The thing came up in an exam one year! (all the other questions seem painfully easy by comparison)
12:48:44 <Botje> i spent a week chewing on what liftM2 (id) meant
12:48:44 <fax> why are you feeling dumb
12:48:57 <fax> this foldr thing is very difficult
12:49:03 <wasted> fax, well thanks to you guys I'm not feeling so dumb any more
12:49:07 <fax> ok
12:49:30 <wasted> I understand foldr, I think its the partial application of rcons that I have not wrapped my head around
12:49:42 <mm_freak_> gwern: am i complaining too much?
12:49:55 * ologNation is working on getting HUnit to "just work". 
12:49:59 <gwern> mm_freak_: I've enough people complain about it that it's annoying
12:50:03 <wasted> I'm smart enough to port the code from Miranda (what our lecturer makes us use) to haskell and add in traces, but still ain't quite cracked this!
12:50:06 <Botje> wasted: you can express foldr in terms of foldl using a similar trick
12:50:13 <ologNation> is it import Test.HUnit, or import HUnit, as the documentation says....?
12:50:16 * ologNation is thinking about it. 
12:50:24 <Botje> screw traces, use pen & paper :)
12:50:46 <gwern> wasted: Miranda? I thought miranda stopped being maintained in the 80s?
12:50:54 <gwern> where on earth a re you getting miranda from in 2010?
12:50:56 <wasted> Botje: I have a notepad in front of me - Sometimes it's nice to see what the computer does
12:51:02 <wasted> gwern: ask my lecturer.
12:51:40 <wasted> gwern: the reason is mostly because a) he's lazy, b) it has much less syntax/tricks so it's resonable to expect us to know the _whole_ language for exams
12:51:50 <gwern> haskell is lazy too
12:52:02 <wasted> I mean he's a lazy person :)
12:52:15 <wasted> He's been teaching the course since time began
12:54:02 <ologNation> module `Test.HUnit' does not export `TestList'.
12:54:06 <ologNation> Anyone use HUnit?
12:57:17 <MisterN> why can haskell figure out the type of this expression? (print . sum . map read . words)
12:57:29 <MisterN> i mean, it could use any Num a, couldn't it?
12:57:43 <idnar> :t print . sum . map read . words
12:57:44 <lambdabot> String -> IO ()
12:57:49 <zygoloid> MisterN: it uses defaulting
12:57:56 <mm_freak_> MisterN: the type of 'words' already specifies the type
12:57:58 <mm_freak_> :t words
12:57:59 <MisterN> zygoloid: what's that?
12:57:59 <lambdabot> String -> [String]
12:58:09 <MisterN> :t read
12:58:10 <lambdabot> forall a. (Read a) => String -> a
12:58:12 <idnar> mm_freak_: I think he means the type of read
12:58:12 <ickabob> is the standard offline documentation through haddock?
12:58:23 <idnar> :t sum
12:58:23 <lambdabot> forall a. (Num a) => [a] -> a
12:58:25 <zygoloid> MisterN: because there are standard typeclasses involved (Show, Num and Read), it uses a list of 'default' types to try, in order, until it finds one which works
12:58:28 <mm_freak_> idnar: ah, ok
12:58:30 <idnar> :t sum . map read . words
12:58:31 <lambdabot> forall a. (Num a, Read a) => String -> a
12:58:48 <MisterN> zygoloid: oh that's a cool feature
12:59:17 <mm_freak_> MisterN: it's a cool feature and it's necessary, too
12:59:22 <mm_freak_> main = print 3
12:59:29 <MisterN> :t 3
12:59:29 <lambdabot> forall t. (Num t) => t
12:59:33 <zygoloid> MisterN: http://www.haskell.org/onlinereport/decls.html#default-decls
12:59:35 <MisterN> :t 3.0
12:59:35 <lambdabot> forall t. (Fractional t) => t
12:59:47 <mm_freak_> could be any Num, but of course it's difficult to print "any Num" =)
12:59:59 <wasted> thanks Botje, gwern, fax. I figured it out
13:00:33 <Twey> :t sum
13:00:34 <wasted> my problem is that I did not see that "foldr rcons id [1,2,34]" returned a function, which was then applied to []
13:00:35 <lambdabot> forall a. (Num a) => [a] -> a
13:02:10 <Botje> yay
13:02:31 <MisterN> zygoloid: hmm it's possible to change the default list in modules. is it possible in gchi too?
13:02:54 <ologNation> Module `Test.HUnit' does not export `TestList'
13:03:09 * ologNation is reading the docs at http://hunit.sourceforge.net/HUnit-1.0/Guide.html
13:04:12 <Cale> MisterN: I don't think so.
13:04:22 <MisterN> that would have been cool!
13:04:54 <zygoloid> @go "type defaulting in ghci"
13:04:55 <lambdabot> Maybe you meant: google googleit do
13:04:59 <zygoloid> @google "type defaulting in ghci"
13:05:00 <ologNation> got it!
13:05:01 <lambdabot> http://www.mirrorservice.org/sites/www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
13:05:01 <lambdabot> Title: 2.4.ÔøΩInteractive evaluation at the prompt
13:05:05 <zygoloid> MisterN: ^^ see that
13:05:18 <zygoloid> i don't know if you can change the list in ghci
13:05:25 <zygoloid> but the rules are different there anyway
13:07:08 <MisterN> ah, using () as the first default makes sense
13:11:17 <HugoDaniel> hello
13:13:36 <abbe> hi everyone
13:14:19 <abbe> is there any function in haskell which iterates over an array and invokes a function on each element, and continues iteration only if that function returned true ?
13:14:31 <abbe> s/kell/kell library/
13:14:47 <c_wraith> Uh.  What would that even do?
13:14:55 <c_wraith> as in, what would the type signature be?
13:15:01 <c_wraith> :t takeWhile
13:15:02 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:15:04 <mm_freak_> abbe: "array"?
13:15:14 <mm_freak_> you mean Array?  or Vector?  or a list?
13:15:32 <abbe> mm_freak_: [a] -- is array ?
13:15:37 <c_wraith> that's list
13:15:51 <abbe> okay, sorry
13:16:02 <mm_freak_> that's a list and what you want sounds like takeWhile and map or takeWhile and mapM
13:16:08 <c_wraith> > takeWhile (/= '.') "Foo.bar"
13:16:09 <lambdabot>   "Foo"
13:16:24 <mm_freak_> > map (+1) . takeWhile even $ [2,4,8,9,1]
13:16:25 <lambdabot>   [3,5,9]
13:16:26 <abbe> c_wraith: (a -> Bool) -> [a] -> m (), something like this.
13:16:35 <c_wraith> abbe: what would it *do*?
13:16:40 <mm_freak_> > mapM_ print . takeWhile even $ [2,4,8,9,1]
13:16:41 <lambdabot>   <IO ()>
13:16:56 <c_wraith> abbe: that type signature lacks a meaning.
13:17:00 <abbe> c_wraith: it should stop if (a -> Bool) returns True
13:17:11 <c_wraith> ....  *what* should it stop doing?
13:17:35 <abbe> c_wraith: mapM_ works great, but I don't want mapM_ to continue execution even when there is no use.
13:17:46 <abbe> c_wraith: i'm trying to find a pattern in a list
13:17:56 <c_wraith> So...  you mean more like (a -> m Bool) -> [a] -> m ()
13:18:07 <c_wraith> that type signature actually means something.
13:18:21 <c_wraith> err, if you throw a Monad m => in front of it
13:19:28 <abbe> c_wraith: okay
13:19:46 <mm_freak_> abbe: what are you going to do?
13:20:20 <c_wraith> or you may want Monad m => (a -> Bool) -> [m a] -> m ()
13:20:22 <weissi> I want a function the signature (a -> IO (Maybe b)) which should execute a sequence of IO actions and when the first fails (calling 'fail' in the IO monad), my function should return Nothing. If nothing fails I'd like to return some value. How to achieve that?
13:20:46 <c_wraith> weissi: is this homework?
13:20:56 <mm_freak_> weissi: by not abusing 'fail'
13:21:00 <weissi> c_wraith, no
13:21:06 * abbe is trying to write a script to expire mails older than specific period, and for that I need to go through all of the lines of the mail text looking for the 'Date' header...
13:21:14 <c_wraith> you'd generally use catch for this.
13:21:41 <weissi> c_wraith, I did try catch in fact, but I just didn't get it right :-(
13:21:42 <mm_freak_> abbe: doesn't sound like something you need a monad for
13:21:57 <c_wraith> weissi: which catch did you use?
13:22:00 <c_wraith> @hoogle catch
13:22:01 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
13:22:01 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
13:22:01 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
13:22:10 <c_wraith> Control.Exception catch is much better.
13:22:25 <weissi> c_wraith, I tryied Prelude and Control.Exception
13:22:52 <abbe> mm_freak_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24300#a24300
13:23:20 <weissi> c_wraith, the first thing I tried was to search a function with that signature: Monad m => IO a -> m (IO a)
13:23:48 <zygoloid> @type return :: Monad m => IO a -> m (IO a)
13:23:50 <lambdabot> forall a (m :: * -> *). (Monad m) => IO a -> m (IO a)
13:23:51 <c_wraith> Uh.  I don't think that's the signature you mean
13:23:56 <c_wraith> because that's just return
13:24:05 <mm_freak_> weissi: map a 'try' over the list of actions, then use 'sequence', and finally use 'rights'
13:24:46 <mm_freak_> abbe: that code doesn't make sense
13:26:03 <abbe> mm_freak_: its not complete yet, I've just started writing it, i'll iterate over files present in current directory (maildir) and then filter it to get a list of mails which it considers old enough to be deleted
13:26:06 <weissi> mm_freak_, thanks!
13:26:13 <mm_freak_> :t isPrefixOf
13:26:14 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
13:26:32 <mm_freak_> > filter ("Date:" `isPrefixOf`) . lines $ "Blah: x\r\nDate: 3\r\nDate: 4\r\nBlubb: foo"
13:26:33 <lambdabot>   ["Date: 3\r","Date: 4\r"]
13:27:01 <zygoloid> @type let some_stuff_in_io_monad :: IO a; some_stuff_in_io_monad = undefined  in  (do x <- some_stuff_in_io_monad; return (Just x)) `catch` (\_ -> return Nothing)
13:27:02 <lambdabot> forall a. IO (Maybe a)
13:27:10 <zygoloid> ^^ weissi: i think you want something like that
13:27:49 <abbe> mm_freak_: but it'll traverse whole list..
13:28:09 <mm_freak_> bos: i'm using attoparsec to parse a lot of data‚Ä¶  is it better to use 'lines' and then run many 'Parser Line'?  or should i write a 'Parser [Line]' instead?
13:28:21 <mm_freak_> abbe: remember that haskell is lazy
13:28:32 <mm_freak_> > takeWhile (< 10) [5..]
13:28:33 <lambdabot>   [5,6,7,8,9]
13:28:37 <bos> mm_freak_: i'd try each way and compare them if i were you
13:28:41 <mm_freak_> [5..] is an infinite list
13:28:47 <bos> mm_freak_: i don't have an intuition about which will do better
13:29:00 <mm_freak_> bos: ok, thank you
13:29:01 <abbe> mm_freak_: so I'll use takeWhile, and not filter
13:29:06 <bos> mm_freak_: it also depends on how you consume the result
13:29:14 <weissi> zygoloid, yeah, looks good ;-). thanks!
13:29:17 <abbe> c_wraith, mm_freak_: thanks
13:29:36 <bos> mm_freak_: if you have to construct the entire list then return it all, that will be much more expensive than constructing an element at a time from each line
13:30:33 <mm_freak_> bos: not at all‚Ä¶  it's a parser library for a protocol, which converts raw protocol strings to records
13:30:43 <mm_freak_> a text protocol that is
13:31:00 <mm_freak_> currently i'm using the 'lines' approach
13:32:00 <mm_freak_> bos: ah, another question, what is the easiest way to ensure that a parser completes?  i noticed that sometimes i get Partial even when i use (`feed` "")
13:32:53 <mm_freak_> abbe: depends on what you want to do
13:33:06 <mm_freak_> > filter even [2..]
13:33:07 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
13:33:13 <mm_freak_> > takeWhile even [2..]
13:33:14 <lambdabot>   [2]
13:35:42 <mm_freak_> abbe: btw, have a look at the readFile function
13:35:46 <mm_freak_> :t readFile
13:35:47 <lambdabot> FilePath -> IO String
13:36:07 <abbe> oh, okay
13:36:12 <abbe> thanks
13:40:07 <ddelony> Hmmm, are there any plans to set up Bittorent for the Haskell Package? The HTTP download is a bit slow.
13:42:03 <MisterN> ddelony: you could do that, no? :)
13:42:08 <dankna> ddelony: I'll set it up now, one second
13:42:29 <dankna> for the Mac version at least, which is all I've actually downloaded
13:42:48 <ddelony> dankna: Which is perfect, because that's what I want. :-)
13:42:52 <dankna> good :)
13:43:00 <ddelony> I've already got GHC on my Ubuntu netbook.
13:43:07 * dankna nods
13:43:31 <dankna> may take a moment as I have to install a tracker on my server, too, haha
13:46:21 <absentia> I probably missed it.. I just installed the haskell language and platform.. from the mac osx dmg... nothing showed up in Applications -- where do I find what juat got installed?
13:46:34 <ddelony> If you take long enough, I'll probably have it downloaded. But I'll seed anway :-)
13:46:43 <dankna> haha cool cool
13:47:12 <dankna> absentia: it's not a gui program - ghc and ghci and cabal and related commands were installed below /Library/Frameworks with symlinks from /usr/bin/
13:47:22 <absentia> I could mirror the mac dmg.. if that would be helpful for anyone
13:47:30 <absentia> danka: ah! k.. thanks
13:47:53 <dankna> the "right way" is to set up a bittorrent rather than a slew of mirrors.  plus, my home machine has more upload than my server does, if you can believe that, so ...
13:48:42 <absentia> k
13:48:55 <absentia> well, I get > 8MB/sec at my colo...
13:49:00 <absentia> I'll stop the upload then.
13:49:12 <dankna> heh, up to you
13:49:20 <ddelony> I guess they'll have to put a link to the tracker on the Haskell Distribution site.
13:49:29 <absentia> cancelled
13:50:10 <ddelony> absentia: You're more than welcome to seed it on Bittorrent once we get it set up.
13:51:05 <ddelony> This must be my 5th or 6th time trying to wrap my brain around Haskell. I'm working through Learn You A Haskell.
13:51:13 <dankna> haha, best of luck with it
13:51:24 <dankna> it's very rewarding once you get it
13:52:09 <ddelony> I read The Little Schemer, so I'm somewhat comfortable with the concept of functional programming.
13:52:29 <Twey> Haskell is a bit more functional than Scheme.
13:52:39 <Entroacceptor> pun intended ;)
13:52:55 <mauke> also, your ideas about tail recursion may be wrong
13:52:56 <Twey> Heheh.
13:53:03 <dankna> ddelony: looks like you're likely to get it D/Led before I get the tracker set up
13:57:57 <felzix> What's a good editor/IDE for haskell code? I've been using emacs but its auto indentation isn't great.
13:58:09 <Twey> You're using it wrong
13:58:15 <Twey> Do you have haskell-mode?
13:58:26 <felzix> twey: yes, whichever version ubuntu 9.10 provides.
13:58:38 <Twey> Are you using haskell-mode?
13:58:43 <Cale> Haskell-mode likes to indent things sort of strangely sometimes.
13:58:55 <Twey> Note that you can tab through alternative indentations
13:58:56 <felzix> twey: yes
13:59:00 <dankna> I know my haskell-mode isn't the latest and it's been significantly cleaned up, but it needs a total rewrite, heh
13:59:14 <Cale> I always ended up turning off the "smart" indenter.
13:59:29 <Twey> I think Baughn is basically doing that.
13:59:32 <Cale> At least, when I was using emacs.
13:59:40 <felzix> Cale: what do you use now?
13:59:43 <Cale> vim
13:59:55 <Twey> There have certainly been a lot of changes to it of late.
14:01:18 <felzix> ah, I have 2.4-1 and 2.7.0 is out
14:01:21 <dankna> okay, nuts to this, I'm just going to use openbittorrent.com as the tracker.  it looks like Debian only has trackers for m68k...
14:01:28 <felzix> ubuntu's repo is lagging, as usual
14:03:57 <dankna> http://dankna.com/himitsu/haskell-platform-2010.1.0.0-i386.dmg.torrent
14:04:59 <zachk> @src tranpose
14:04:59 <lambdabot> Source not found. :(
14:05:08 <zachk> @src transpose
14:05:08 <lambdabot> transpose []             = []
14:05:08 <lambdabot> transpose ([]   : xss)   = transpose xss
14:05:08 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:05:10 * Twey instinctively attempts to browse dankna's ‚Äòhimitsu‚Äô directory ‚òπ
14:05:14 <dankna> haha
14:05:18 <dankna> it's a secret :D
14:05:24 <dankna> that's what the word means :D
14:05:25 <Twey> Naisyo~
14:05:32 <dankna> hehe
14:05:45 <ddelony> Yay, it's done!
14:05:51 <dankna> congrats!
14:07:40 <dankna> well, anyway, I'll seed it for a while
14:10:40 <ddelony> Now it won't install.
14:10:46 <dankna> what's it saying?
14:10:52 <dankna> perhaps a previous installation is interfering?
14:13:18 <ddelony> It says "run postupgrade script for 001-mtl-1.1.0.2" failed
14:13:49 <dankna> hmm
14:13:57 <gwern> one thing that irks me is that people say debating semantics like its a bad thing
14:14:05 <gwern> semantics = meaning. what *else* would one wish to debate?
14:14:13 <gwern> syntax?
14:14:37 <dankna> quite
14:14:52 <Twey> gwern: A hearty aye to that
14:15:10 <gwern> a good example of the popular debasement of many terms. reminds me that more than half the populace is below 100 IQ
14:15:16 <Twey> Heh
14:15:49 <ddelony> It would probably help to install Xcode. :-p
14:15:50 <Twey> ‚ÄòSo last I heard you liked having sex with pigs.‚Äô ‚Äò*Breeding* pigs.  I *breed* pigs.‚Äô ‚ÄòNow you're arguing semantics with me?!‚Äô
14:16:13 <jlouis> Twey: argue with pigworker about semantics!
14:17:11 <Twey> Heh
14:17:59 <jlouis> Twey: beware, clowns, jokers, and disneyland characters might appear out of the blue when doing so!
14:18:40 <fax> o_O
14:18:58 <jlouis> fax: pigworker is Conor McBrides twitter account name
14:19:30 <jlouis> And he does outright *brilliant* semantics work
14:19:39 <fax> really?
14:19:49 <fax> I only read his type theory stuff
14:23:51 <harlekin> When reading a BMP file and the first two bytes are 4d 42 do I have to convert host byte order to network order or something?
14:24:16 <harlekin> I expected to get 42 4d. Sorry for being a little off topic.
14:25:25 <bremner_> a little? what does that have to do with american politics?
14:25:33 <bremner_> err, with emacs?
14:26:00 <bremner_> ah never mind.
14:26:04 <Twey> Heh
14:26:21 <harlekin> I could pretent I was decoding bitmaps using Haskell. Although I am using Lazarus (Freepascal) and just too afraid to ask there, because I think I won't get an answer.
14:26:29 <dankna> well
14:27:06 <Twey> You should just insert a relevant filter into your Get monad.  ;)
14:27:11 <dankna> http://en.wikipedia.org/wiki/BMP_file_format#BMP_File_Header
14:27:23 <dankna> "All of the integer values are stored in little-endian format"
14:27:38 <harlekin> dankna, oh. Missed that. Thank you ver much.
14:27:47 <dankna> I would use hexdump to inspect a few sample files and convince yourself that 4d 42 is correct
14:28:09 <dankna> you are welcome :)
14:28:12 <arcatan> the actual bytes in the file should be 42 4d
14:28:39 <dankna> you're right, they should
14:28:45 <harlekin> Then imagemagick's convert would be broken. Oo
14:28:51 <cads> Has anyone had any luck with leksah?
14:29:01 <dankna> the spec is quite clear that it's B M, which is 42 4d
14:29:14 <cads> been rather buggy for me here in windows
14:29:24 <dankna> never tried it, cads
14:29:47 <dankna> harlekin: you must be misunderstanding what you're reading of the imagemagick source
14:30:01 <arcatan> harlekin: for me conver produces files with BM (checked with hexdump -C)
14:31:06 <harlekin> arcatan, I should've used -C either. :)
14:34:29 <glguy> as far as I can tell, leksah's cabal file specifies overly broad version numbers on its dependencies. I can't "cabal-install" it on Fedora 12
14:35:01 <sungji> Hi! I'd like to implement a fold function for my data type { for propositional logic formulae:  data Pform a = Var a | Not (Pform a) | And (Pform a) (Pform a) | Or (Pform a) (Pform a) }
14:35:33 <fax> foldPform var not and or = phi where
14:35:33 <Twey> Foldable?
14:35:36 <fax>  phi (Var a) = var a
14:35:42 <fax>  phi (Not p) = not p
14:35:44 <fax>  ...
14:35:44 <sungji> well, unfortunately I kinda don't see how to do that... I ended up with some sort of a map function
14:35:47 <fax> oops
14:35:50 <fax> that was actually wrong
14:35:55 <fax>  phi (Not p) = not (phi p) *
14:36:05 <fax> anyway, yeah -- you can see how this works from here I am sure
14:36:13 <fax>   phi (Or m n) = or (phi m) (phi n)
14:36:40 <sungji> fax, are you defining the datatype?
14:36:46 <fax> sungji, this is how to define the fold
14:36:52 <fax> you have not seen 'where' in haskell yet?
14:37:18 <fax> foldList nil cons = phi where
14:37:20 <fax>  phi [] = nil
14:37:25 <fax>  phi (x:xs) = cons x (phi xs)
14:37:33 <fax> and so on
14:37:33 <sungji> fax, yes, and I ended up with the same idea
14:37:44 <fax> well you have got it right :P
14:37:57 <sungji> fax, but what got me thinking is that
14:38:27 <sungji> foldr f e (x:xs) = f x (f e xs)
14:38:39 <sungji> but here, I don't see how to substitute and/or/not
14:40:23 <Botje> foldr f e (x:xs) = f x (foldr f e xs) -- rather
14:40:34 <Botje> and foldr f e [] = e
14:40:35 <sungji> Botje, errr yes
14:40:46 <Botje> sungji: not how f is only used in the (x:xs) case, and e only in the [] case
14:41:06 <fax> sungji: um didn't what I said above explain it?
14:41:16 <Botje> you need two "processing arguments since the list type has two data constructors
14:41:29 <Botje> fax is telling you you need one argument for every data constructor in your logic type
14:42:20 <sungji> hm... so I'd end up with  ... -> Bool ?
14:42:47 * fax gives up.. I don't seem to be getting through :P
14:43:04 <fax> a lot of times I say something that makes loads of sense to me but nobody else understand it..
14:43:16 <Botje> sungji: that depends on your fold function.
14:43:35 <Botje> 22:35 < fax> foldPform var not and or = phi where
14:43:36 <sungji> I must have overseen something here..
14:43:37 <Botje> 22:35 < fax>  phi (Var a) = var a
14:43:37 <Botje> 22:35 < fax>  phi (Not p) = not p
14:43:45 <Botje> 22:35 < fax>   phi (Or m n) = or (phi m) (phi n)
14:43:49 <Botje> (sorry for the highlights)
14:43:59 <Botje> sungji: stare at those lines for a while
14:44:23 <fax> ^^^^^^^ this is a fundamental technique of haskell programming :P
14:44:28 <Botje> staring?
14:44:30 <fax> yes
14:44:32 <Botje> very much so :)
14:44:35 <fax> until a fuse blows
14:44:46 <Botje> sungji: note how the phi function has a case for Var, a case for Not, and a case for Or
14:45:03 <Botje> sungji: also note how each case uses a different function, which is passed in the argument list of foldPform
14:45:15 <MisterN> @src >>
14:45:15 <lambdabot> m >> k      = m >>= \_ -> k
14:45:21 <Botje> (and the Not p case should be not (phi p)
14:46:37 <sungji> Botje, and phi (Var a) = phi a ? (I'm still starring...)
14:46:57 <Botje> sungji: no, phi (Var a) = var a
14:47:10 <Botje> (note that the function var is passed as an argument)
14:47:26 <Botje> sungji: a trivial use of foldPform would be the identity function:
14:47:51 <sohum> hm. I thought leksah dealt with haskell indentation cleverly? at least as cleverly as haskell-mode?
14:47:52 <Botje> "foldPform Var Not And Or" will transform a logical expression into .. well .. itself
14:49:07 <CodeBlock> I'm very new to haskell, just dabbling with some simple hello world examples, etc... How do I loop forever (C-style while(1) {})
14:49:41 <Botje> CodeBlock: what do you want to do with that?
14:49:41 <fax> CodeBlock: let loop = do print "LOL" ; loop in loop
14:49:55 <fax> @src forever
14:49:55 <lambdabot> Source not found.
14:49:57 <fax> m
14:50:01 <CodeBlock> Botje: stdin input loop
14:50:02 <Botje> an infinite loop in haskell is "undefined"
14:50:04 <Botje> easy huh :]
14:50:11 <sohum> :t forever
14:50:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:50:17 <Botje> CodeBlock: oh. then you probably want the forever combinator, yes.
14:50:18 <BONUS> forever $ do a <- getLine; putStrLn a
14:50:26 <c_wraith> > forever $ return 5
14:50:27 <lambdabot>   No instance for (GHC.Show.Show (m b))
14:50:27 <lambdabot>    arising from a use of `M2674096352...
14:50:40 <c_wraith> > forever $ Just 5
14:50:44 <lambdabot>   mueval-core: Time limit exceeded
14:52:20 <sohum> I'm surprised forever "returns" an m b
14:52:29 <Twey> Why?
14:52:43 <sohum> why is there the additional restriction of being in the monad?
14:52:53 <fax> sohum, I think that it must be a monad
14:52:55 <Twey> Because it's inescapable
14:52:57 <c_wraith> because forever often doesn't mean "forever" >_>
14:52:58 <fax> because imagine like
14:52:59 <Twey> :t (>>)
14:53:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:53:01 <jlouis> sohum: because it is defined for side effects
14:53:05 <fax> :t print "foo" >> undefined
14:53:05 <c_wraith> > forever Nothing
14:53:06 <lambdabot> forall b. IO b
14:53:06 <lambdabot>   Nothing
14:53:15 <c_wraith> forever can return
14:53:17 <fax> this is still to be IO, if it wants to print anything
14:53:30 <sohum> :t forever Nothing
14:53:31 <lambdabot> forall b. Maybe b
14:53:41 <sohum> hmm, I think I see
14:53:42 <fax> > forever Nothing
14:53:43 <lambdabot>   Nothing
14:53:46 <fax> ^ not really forever :P
14:53:51 <CodeBlock> okay, ghc is saying 'forever' isn't in the scope. :/
14:53:55 <fax> > forever [1]
14:53:56 <lambdabot>   * Exception: stack overflow
14:53:58 <c_wraith> > forever $ Left "foo"
14:53:59 <lambdabot>   Left "foo"
14:54:01 <fax> odd...
14:54:03 <sohum> @where forever
14:54:03 <lambdabot> I know nothing about forever.
14:54:03 <jlouis> CodeBlock: Control.Monad is where forever lives
14:54:04 <fax> > forever []
14:54:05 <lambdabot>   []
14:54:20 <sohum> > forever (1:)
14:54:23 <jlouis> and yes, my bad, it works over any Monad
14:54:24 <lambdabot>   mueval-core: Time limit exceeded
14:54:36 <CodeBlock> jlouis: ah, thank you... like I said, I'm very new to haskell, so I appreciate the help
14:54:44 <sohum> :t forever $ Left "foo"
14:54:48 <lambdabot> forall b. Either [Char] b
14:54:52 <sohum> ah
14:54:54 <sohum> haha
14:55:11 <jlouis> CodeBlock: peruse Control.Monad for a couple of other nice combinators for stitching together monadic computation
14:55:40 <sungji> Botje, fax, ALRIGHT. I got it. And I also know where my problem was here, in case you want to know
14:55:46 <Botje> sungji: yay!
14:55:48 <PlotDevice> What's the canon way of checking the installed ghc version?
14:55:59 <Botje> sungji: did your brain explode?
14:56:07 <PlotDevice> ghc itself doesn't seem to have a -v switch equivalent :(
14:56:12 <BONUS> ghc --version
14:56:16 <sohum> PlotDevice: ghc --version
14:56:17 <PlotDevice> oh welp
14:56:23 <PlotDevice> Thanks for that
14:56:56 <sohum> but yea, why is leksah's indentation so unclever?
14:57:26 <c_wraith> :t mzero
14:57:27 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:57:32 <c_wraith> :t forever mzero
14:57:33 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => m b
14:57:50 <c_wraith> > forever mzero :: Maybe Int
14:57:51 <lambdabot>   Nothing
14:58:12 <c_wraith> > forever mzero :: [String]
14:58:13 <lambdabot>   []
14:58:24 <jmcarthur> you know what i like about SPJ's presentation style? he shows so much enthusiasm (obvious) yet he doesn't oversell at all
14:58:39 <sungji> Botje, I'm fairly new to ADT, and I expected to see something similar to lists {cons vs. f } and Trees (binary). I didn't come up with the idea to let the client provide a function for each possible constructor
14:58:49 <c_wraith> anything that implements the MonadPlus laws properly is going to have "forever mzero" equivalent to "mzero"
14:59:02 <Botje> jmcarthur: you even forget they're all in comic sans!
14:59:08 <stevenmarky> lol
14:59:14 <Botje> but yes, his enthousiasm is /very/ infectious
14:59:23 <jmcarthur> Botje: the typophile in me wants to punch him for that
14:59:49 <Botje> :)
15:00:02 <sungji> fax, thanks
15:00:32 <jmcarthur> Botje: i meant for the emphasis to be on the fact that he doesn't oversell even as he exudes energy about the topic
15:00:54 <Botje> agreed
15:01:04 <Botje> i'd watch some more of his stuff if i had some spare time
15:01:06 <sori> Would it by no way be possible to use something like 'where' inside the scope of 'do'?
15:01:07 <fax> SPJ is one cool cat
15:01:19 <jmcarthur> he managed to raise excitement about something without the risk of somebody crashing later
15:01:24 <jmcarthur> *manages
15:01:24 <fax> sori yeah sure
15:01:37 <fax> sori, but it's really that the do is in scope of the where..
15:01:47 <fax> backwards binding etc
15:02:31 <c_wraith> there's a modified form of let for use in do blocks that might be closer to what you want
15:04:50 <dcolish> if a package, such as packedstring, is depricated, how might i find a suitable replacement?
15:05:24 <mrAlex5> Hi people
15:05:32 <sori> fax,c_wraith, yes,, but,, well what I want is actually,          do { ......some_code......; bracket (connectTo "localhost" (PortNumber 11111)) hClose job     where    job = do { ........code using variables in the last do scope...... }; .......other_codes.......}
15:05:35 <gwern> dcolish: read around and find out what people are using now?
15:05:39 <c_wraith> I don't think there's a standard way people indicate what a package was depricated in favor of.
15:05:45 <c_wraith> err, deprecated. >_>
15:05:48 <gwern> dcolish: packedstring is deprecated in favor of bytestring, incidentally
15:05:48 <dcolish> thats a bummer
15:05:52 <dcolish> oh ok cool
15:06:00 <c_wraith> But yes, that one was an easy one. :)
15:06:02 <gwern> c_wraith: well, if the packedstring maintainer had bothered to add the right pragmas
15:06:26 <micah> so I have gotten `parse (match (NumberTok 3)) "" v` to work now
15:06:27 <c_wraith> sori:  you can do that with let inside of the do block.
15:06:29 <micah> in Parsec
15:06:37 <micah> with my own [Token] stream
15:06:39 <micah> thingy
15:06:44 <micah> but I can't string them together with >>
15:06:45 <micah> :(
15:06:48 <micah> how do I do this
15:07:21 <mrAlex_> Anyone has experience running GHCi from MacPorts?    It's segfaulting badly for me :/
15:07:26 <sori> c_wraith, I see, but then I have to make use of >>= instead of making a do-style computation, right?
15:07:26 <ddelony> Haskell Platform made me log out. Had a cup of coffee. Seems to work. GCHi loads and it's the right version.
15:07:33 <c_wraith> sori: not at all.
15:07:35 <dankna> ddelony: excellent!
15:07:39 <systemfault> Win :D
15:07:51 <edwardk> welcome to the platform
15:07:56 <JuanDaugherty> is HP in GA, general release state now?
15:07:57 <fax> o/
15:07:59 <ddelony> Now I can keep learning me a Haskell.
15:08:05 <dcolish> mrAlex_: i just use the haskell platform installer
15:08:10 <jmcarthur> wait, why would the platform make you have to log out?
15:08:18 <systemfault> Hmm, might seem like a weird/funny question but.. What is a good "first small program" to do with Haskell?
15:08:25 <ddelony> Just curious: What's the best Web framework for Haskell?
15:08:29 <dcolish> jmcarthur: so it can set paths i believe
15:08:35 <jmcarthur> systemfault: an interpreter :)
15:08:35 <systemfault> I only did snippets... small functions until now.
15:08:44 <mrAlex_> Platform installer from web site has problems on Snow Leopard
15:08:51 * fax wonders if edwark is secretly edward khil of vocalize fame
15:09:15 <edwardk> nah
15:09:17 <dcolish> mrAlex_: thats news to me, it worked great for me
15:09:42 <fax> its my fav
15:09:45 <sori> c_wraith, uhm... but         do { ...some_code...; let job = do {...jobs...}; bracket (connectTo "localhost" (PortNumber 11111)) hClose job; ...some_code...}            isn't likely to work... could you tell me how otherwise I should use 'let' then..?
15:10:06 <c_wraith> sori:  can you put that on a pastebin properly indented?  It would help a ton
15:10:16 <sori> yes sir
15:10:27 <jmcarthur> systemfault: seriously, i think interpreters are great for beginners learning haskell. it's easy enough in haskell and hard enough in other languages that i can really make somebody feel like they are getting somewhere fast. plus you can actually learn quite a bit by improving it as you learn
15:10:29 <mrAlex_> I believe one has to edit ghc startup script adding -m32 in there
15:10:33 <jmcarthur> *this it can
15:10:38 <jmcarthur> **that is can
15:10:43 * jmcarthur sucks at typing
15:10:45 <dankna> mrAlex: I believe that's wrong, since this is a 64-bit binary
15:10:50 <Botje> jmcarthur: scheme also makes it rather easy
15:10:50 <dcolish> mrAlex_: not anymore
15:11:00 <jmcarthur> Botje: functional languages in general, true
15:11:24 <mrAlex_> Rly? I have that problem just few days ago. Will give it one more try and see if I can reproduce that segfault in it
15:11:34 <dankna> well, the release was just yesterday
15:11:37 <dankna> re-download if you haven't
15:12:10 <dankna> http://dankna.com/himitsu/haskell-platform-2010.1.0.0-i386.dmg.torrent might be faster than the website, heh
15:12:29 <mrAlex_> Oh, good news. Gonna try it now
15:12:50 <jmcarthur> Botje: but haskell is nice for interpreters even compared to scheme simply due to the usual niceties: purity, laziness, static typing
15:13:08 <jmcarthur> laziness helps a bit less in this case i guess, but it just depends on what you're doing
15:13:29 <jmcarthur> laziness helps a lot for brainfuck interpreters at least
15:13:35 <Botje> jmcarthur: absolutely.
15:13:46 <jlouis> Implement a Z-machine interpreter?
15:13:58 <Botje> turing machine is also rather easy to implement in haskell :)
15:14:01 <jlouis> it might be too nasty
15:14:39 <systemfault> jmcarthur: Ok, where to start? (A lisp interpreter? )
15:14:40 <sori> c_wraith, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8831 so this is the goal style I would like to reach...
15:14:41 <micah> can anyone help me with my parsec parser?
15:14:53 <jlouis> micah: pastebot it!
15:14:55 <jmcarthur> systemfault: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:14:57 <micah> I made `parse (match (NumberTok 3)) "" v` work with a list of tokens
15:15:00 <micah> I just need to know how to make
15:15:02 <micah> match be a monad
15:15:07 <edwardk> systemfault:  http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:15:12 <edwardk> ah jmcarthur beat me to it
15:15:14 <jmcarthur> edwardk: too slow!
15:15:15 <micah> I don't need to debug
15:15:16 <systemfault> jmcarthur: I love you
15:15:22 <jmcarthur> systemfault: i love you too
15:15:28 <jmcarthur> ...
15:15:33 <systemfault> jmcarthur: Haha
15:15:36 * fax 's todo list: REWRITE THAT AWFUL TUTORIAL
15:15:57 <jlouis> micah: also, what parsec version are you using? Parsec 2 and 3 are quite different
15:16:01 <systemfault> jmcarthur: Bookmarked, I'll read that tonight :)
15:16:02 <micah> parsec 3
15:16:11 <c_wraith> sori:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8831#a8832
15:16:26 <Botje> micah: what do you mean make "match be a monad" ? if you got that snippet working, what's the problem?
15:16:35 <micah> well I have
15:16:35 <micah> parse (match (NumberTok 3)) "" v
15:16:37 <micah> but when I say
15:16:44 <micah> parse (match (NumberTok 3) >> match (...)) "" v
15:16:45 <micah> or
15:16:50 <micah> expr = match ...
15:16:52 <micah> it doesn't work
15:16:55 <Botje> what's the type of match?
15:16:59 <micah> match is
15:17:07 <micah> made from `token`
15:17:17 <Botje> put it on hpaste please, it's easier to follow along
15:17:20 <micah> ok
15:17:30 <MisterN> @src flip
15:17:30 <lambdabot> flip f x y = f y x
15:17:56 <chrisdone> @pl \f x y -> f y x
15:17:56 <lambdabot> flip
15:18:01 <chrisdone> D:
15:18:01 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
15:18:04 <chrisdone> @messages
15:18:04 <lambdabot> ivanm asked 1h 7m 35s ago: do you still develop kibro? I just notice that your last release was over a year ago and it's still without base-4 support
15:18:35 <micah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24301#a24301
15:18:42 <chrisdone> ivazquez|laptop: oh yeah, I have several packages I need to update. I'll do tomorrow. one day off work left
15:18:42 <sori> c_wraith, that doesn't work to me.. the compiler says for the 'inner do': Empty 'do' construct
15:18:44 <jlouis> micah: guess: make your tokens into a Text.Parsec.Prim.Stream
15:18:56 <jlouis> micah: or figure out if they already are
15:18:59 <micah> yeah I was wondering how to do that
15:19:01 <c_wraith> sori: that means you're not indenting properly, then.  Are you using tabs?
15:19:01 <micah> I don't think that they are
15:19:16 <sori> c_wraith, I'm using strict spacing
15:19:18 <micah> [(SourcePos, Token)] is the thing that lexer returns
15:20:11 <sori> c_wraith, ahh... if I wrap the inner do with accolades, it seems it works..!!?
15:20:21 <c_wraith> sori: well, the compiler doesn't believe you've indented the body of job properly.  It needs to be indented further than the beginning of the word job
15:20:30 <c_wraith> oh, my example lied to you
15:20:31 <c_wraith> sorry
15:21:00 <jlouis> micah: Monad m => Stream [tok] m tok is an instance, so it would suggest that any list are
15:21:08 <jlouis> for an underlying monad m
15:21:10 <micah> yeah that's what I thought too
15:21:18 <micah> I need the monad m though I guess
15:21:37 <micah> I haven't ever made my own monad before
15:21:49 <jlouis> micah: it can be Identity
15:21:53 <micah> ok
15:22:02 <jlouis> micah: look at the definition of runParser
15:22:05 <micah> aight
15:22:11 <c_wraith> sori: basically, the beginning of the first token after the let introduces the let block.  Things that are indented at that level are considered additional declarations in the let block.  In order to have the do block inside the let block, its contents need to be indented further than the word job, in that example.
15:22:38 <jlouis> micah: or rather, its type signature
15:22:46 <sori> c_wraith, ah, I see.. so that's the way compiler deals with indentation...
15:23:02 <sori> c_wraith, thank you very much, now I have got the code work :)
15:24:46 <jlouis> micah: general rule of Haskell type class hell: Try it blindly. If it works, then pray the default classes that fired does the sensible thing. If not, inspect the type class structure :)
15:24:57 <micah> ok
15:25:18 <jlouis> people tend to define all the sensible instances you will hit with basic types
15:25:18 <micah> so how do I use Identity for this
15:26:23 <stevenmarky> how do I make a string lower case
15:26:29 <MisterN> what's the difference between forM and mapM?
15:26:31 <fax> :t map toLower
15:26:32 <lambdabot> [Char] -> [Char]
15:26:33 <chrisdone> :t toLower
15:26:34 <lambdabot> Char -> Char
15:26:38 <MisterN> @src forM
15:26:38 <lambdabot> forM = flip mapM
15:26:40 <stevenmarky> thanks all
15:26:41 <MisterN> ah!
15:26:48 <fax> > toLower " "OGUNFGOUANFGFRRRR"
15:26:49 <lambdabot>   <no location info>:
15:26:49 <lambdabot>      lexical error in string/character literal at end o...
15:26:54 <fax> ;D
15:26:55 <jlouis> given your parser has type p :: Parsec [(pos, tok)] () a for some return type a, you fire: runParser p () "name of parser" toks
15:27:08 <fax> > toLower . "OGUNFGOUANFGFRRRR"
15:27:09 <jlouis> where toks is the set of tokens.
15:27:10 <lambdabot>   "ogunfgouanfgfrrrr"
15:27:18 <jlouis> it returns an Either back to you
15:27:29 <chrisdone> > toLower "D(._.)B"
15:27:30 <jlouis> the () can be changed if you have a user state
15:27:30 <micah> oh I can't just say parse ...? I should say runParser?
15:27:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:27:30 <lambdabot>         against inferred type...
15:27:39 <chrisdone> hahaha ..
15:27:51 <jlouis> micah: you should be able to do that, yes
15:28:51 <jlouis> MisterN: it is just convenience, that is all
15:29:11 <MisterN> jlouis: i wasn't sure
15:29:19 <MisterN> but it certainly is convenient i think
15:29:30 <jlouis> if your mapping action is big, supplying the data to map over first might be beneficial
15:29:53 <jlouis> MisterN: also check Data.Traversable and Data.Foldable for some generalisations
15:30:07 <MisterN> @hoogle Data.Traversable
15:30:07 <lambdabot> module Data.Traversable
15:30:08 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
15:30:19 <MisterN> hoogle doesn't provide a link? :D
15:30:47 <chrisdone> @source Data.Traversable
15:30:47 <lambdabot> Data.Traversable not available
15:30:54 <chrisdone>  v_v
15:30:54 <lowasser> @source class Traversable
15:30:55 <lambdabot> class Traversable not available
15:30:58 <lowasser> @source Traversable
15:30:59 <lambdabot> Traversable not available
15:31:01 <lowasser> wtf!
15:31:24 <lowasser> I mean, not that it's complicated to define
15:31:29 <Botje> @source is independent from @hoogle
15:31:29 <lambdabot> is independent from @hoogle not available
15:31:30 <jlouis> its a module name
15:31:33 <lowasser> (though it's tricky to understand)
15:33:00 <micah> jlouis: all of a sudden, when I put it in a do block, it ceases to work
15:33:29 <micah> although `runParser (match (NumberTok 3) >> match (NumberTok 4)) ...` worked perfectly
15:33:46 <lelf> ?src Traversable
15:33:47 <lambdabot> class (Functor t, Foldable t) => Traversable t where
15:33:47 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
15:33:47 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
15:33:47 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
15:33:47 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
15:34:51 <jlouis> micah: how about return $ runParser...
15:35:08 <jlouis> your parser is completely functional I think
15:35:23 <jlouis> or better: let res = runParser... in the do-block
15:35:33 <micah> jlouis: where do I put the return?
15:35:39 <micah> jlouis: I don't really understand
15:35:57 <jlouis> x <- return $ runParser... or let x = runParser ...
15:36:05 <micah> ok
15:36:29 <jlouis> lifts the computation to the monad. if your monad is Either you can probably do without it
15:37:39 <micah> why must I use return $ runParser? why can't I use match?
15:37:54 <c_wraith> you can
15:38:17 <Cale> What's the question?
15:38:45 <c_wraith> why all the parsec examples use return $ runParser, instead of just pattern-matching the result of runParser
15:38:56 * hackagebot rope 0.3 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.3 (EdwardKmett)
15:39:09 <Cale> They do?
15:39:19 <c_wraith> well, lots of them do
15:39:29 <edwardk> fixed up the fancy annotated ropes, but sadly the annotation actions are no longer comonadic
15:39:34 <Cale> Which return is that?
15:39:55 <c_wraith> amusingly, Either e, in a lot of the examples I've seen
15:40:03 <micah> heh
15:40:07 <Cale> In any case, that return is going to be conceptually unrelated to the parsing
15:40:43 <Cale> Perhaps there's an IO action about
15:41:37 <micah> so how should I be writing my parser exactly? I am a bit confused.
15:41:45 <c_wraith> in nearly every case, "x <- return $ ..." is silly.
15:42:37 <c_wraith> in fact, in every case where the monad laws are obeyed, it's silly.
15:43:00 <Botje> c_wraith: if x is a pattern and the match fails, fail is called instead of a runtime exeption
15:43:04 <aavogt> c_wraith: except when you want fail
15:43:08 <Botje> s/xept/xcept/
15:43:13 <c_wraith> fail isn't a monad law.  >_>
15:43:44 <c_wraith> Though I really did mean a literal x, not a pattern.
15:44:02 <aavogt> x is a pattern though
15:44:07 <aavogt> ;)
15:44:24 <c_wraith> it's not one that can fail to match. :P
15:44:35 <c_wraith> um.  unless a rank-2 type is returned?
15:44:49 <c_wraith> err.  rank 2 value?
15:44:58 <aavogt> how would that make sense?
15:45:02 <c_wraith> I don't know
15:45:04 <micah> so should I be using... Identity monad, or no monads at all, or what?
15:45:12 <c_wraith> I don't think it does make sense
15:45:33 <aavogt> identity monad is useless
15:45:36 <c_wraith> The identity monad is isomorphic to no monad.
15:45:49 <micah> but is it prettier
15:45:53 <aavogt> unless you have a monad transformer with no non-transformer variant
15:46:07 <micah> I think that I do
15:46:11 <fax> http://getabest.com/listgenerator-monad-combinators-download-new-139008.html
15:46:14 <fax> List/Generator Monad Combinators Supported OS
15:46:15 <fax> Win 3.1x, Win95, Win98, WinME, WinNT 3.x, WinNT 4.x, WinXP, Windows2000, Windows2003, Windows Vista Starter, Windows Vista Home Basic, Windows Vista Home Premium, Windows Vista Business, Windows Vista Enterprise, Windows Vista Ultimate, Windows Vista Home Basic x64, Windows Vista Home Premium x64, Windows Vista Business x64, Windows Vista Enterprise x64, Windows Vista Ultimate x64, Unix, Linux, Linux Console, Linux Gnome, Linux GPL, MAC 68k, Mac PPC, Mac OS 9,
15:46:18 <Twey> > fail "foo" :: Identity Int
15:46:19 <lambdabot>   No instance for (GHC.Show.Show
15:46:19 <lambdabot>                     (Control.Monad.Identity....
15:46:22 <fax> ^^^^^ lol
15:46:27 <Twey> > runIdentity (fail "foo" :: Identity Int)
15:46:29 <lambdabot>   * Exception: foo
15:46:34 <Twey> Oh
15:46:43 <fax> Now List/Generator Monad Combinators supporst Win 3.1x
15:46:43 <Twey> fax: Hahaha
15:46:46 <Twey> Wow
15:47:38 <Botje> impressive. There's a Linux Gnome /and/ a Linux GPL?
15:48:16 <Mathnerd314> language: python
15:49:00 * adu <3 python
15:49:19 <Mathnerd314> if you follow the link, you can see it's just someone porting the List monad to python: http://code.activestate.com/recipes/439361/
15:50:27 <stevenmarky> How do I get GHCI to putStrLn a "£"
15:50:52 <Zao> If on 6.10 or earlier, one of the utf8 packages.
15:50:56 <Zao> If on 6.12, putStrLn :)
15:51:50 <stevenmarky> ah. thanks Zao.
15:52:44 <adu> oo 6.12 is out?
15:53:02 <Draconx|Laptop> for several months now.
15:53:07 <adu> :P
15:53:13 <edwardk> hrmm i just realized i didn't actually define a base case for my annotations
15:54:58 <edwardk> "The List monad in Haskell has many uses, including parsing and nondeterministic algorithms. This code implements the Monad combinators "bind", "return" and "fail", and the MonadPlus combinators "plus" and "zero". It works with all iterables, and ret¬†Programming Methods & Algorithms."
15:55:35 <jmcarthur> oddly phrased, at best
15:55:58 <fax> ;D
16:00:09 <gwern> edwardk: 'ret'?
16:00:21 <edwardk> gwern: not my words
16:00:35 <edwardk> guess it got clipped
16:00:45 <gwern> 'ret Programming Methods'
16:01:21 <edwardk> probably some hackish logic to make sure the keywords Programming Methods & Algorithms fit into the field
16:05:06 * hackagebot graphics-drawingcombinators 1.3.0 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.3.0 (LukePalmer)
16:13:55 <mrAlex_> #irssi /help
16:13:59 <mrAlex_> err
16:14:40 <mrAlex_> Hi once more. Thanks for the advise with freshly-released platform
16:17:20 <mrAlex_> I was wondering about one thing -- is there any (reasonably easy) way to build lambdabot?
16:20:13 <edwardk> mrAlex_: i did it once, so I believe it is possible to repeat the process.
16:20:39 <mrAlex_> Sorry, I'm afraid I missed the beginning :/ Never used irssi before
16:20:40 <edwardk> I am not sure the measures taken were by any logical stretch of the imagination reasonable
16:21:09 <edwardk> mrAlex_:  that was my first statement to you
16:21:25 <djahandarie> Yeah building lambdabot is a pain
16:21:28 <djahandarie> I tried it once and gave up. :P
16:21:32 <mrAlex_> I just tried building version from cabal, and it fails on dependency check
16:21:58 <edwardk> you prolly have to manually install a bunch of junk
16:22:01 <mrAlex_> Pity, I just read some very nice advert about GHCi integration :)))
16:22:28 <MisterN> @src mapM_
16:22:28 <lambdabot> mapM_ f as = sequence_ (map f as)
16:22:53 <mrAlex_> cool. It's alive
16:22:56 <djahandarie> I was cursing "Why doesn't my category theory knowledge help me build this!!!"
16:23:01 <edwardk> i think i got just about that far, using some def macros for ghci, then i wound up moving to a new machien and all my progress was lost
16:23:01 <MisterN> @src sequence
16:23:02 <lambdabot> sequence []     = return []
16:23:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:23:02 <lambdabot> --OR
16:23:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:23:07 <fax> I found this great book on category theory
16:23:15 <fax> the intro paragraph is exciting
16:23:42 <djahandarie> The most interesting thesis I've ever read is Scott Aaronson's.
16:23:49 <edwardk> djahandarie: you used the let kan extension when you should have taken the right, and wound up in albuquerque
16:23:54 <edwardk> er left
16:24:05 <djahandarie> Hehe
16:25:18 <mrAlex_> I guess I have one of the most popular newbie question about Haskel :) How do I generate a bunch of (pseudo)random Doubles with a given range?
16:25:33 <mrAlex_> I recall I figured something for Int's yesterday
16:25:44 <MisterN> hmm i suppose you need the IO monad for that
16:25:48 <mrAlex_> But was getting just Infinitie's for Doubles
16:25:58 <ivanm> nope
16:26:03 <c_wraith> :t randomRIOs
16:26:04 <lambdabot> Not in scope: `randomRIOs'
16:26:07 <mrAlex_> @type Random.mkRandom
16:26:08 <lambdabot> Not in scope: `Random.mkRandom'
16:26:09 <ivanm> mrAlex_: get a seed using newStdGen in IO
16:26:11 <c_wraith> :t randomRs
16:26:12 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
16:26:17 <ivanm> then pass it to randoms (or randomRs)
16:26:43 <c_wraith> > mkStdGen 5
16:26:44 <lambdabot>   6 1
16:26:56 <Cale> mrAlex_: If you know how to do it for Ints then the same code with different type signatures ought to work for Doubles
16:26:59 <ivanm> > randomRs (3.5, 25.3) $ mkStdGen 35623
16:27:00 <lambdabot>   [14.548613680700914,22.286365788822614,11.228637793713398,17.21204633773585...
16:27:04 <c_wraith> > randomRs (0.0, 1.0) $ mkStdGen 5
16:27:05 <lambdabot>   [0.3471719303278187,0.14913877324413943,0.28734412691261246,0.6720783415185...
16:27:19 <ivanm> c_wraith: don't need the R version for that
16:27:38 <mrAlex_> Yuck. Works for you :/    I was getting some Infinities yesterday
16:27:48 <Cale> > randoms (mkStdGen 5)
16:27:49 <lambdabot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
16:27:57 <Cale> > randoms (mkStdGen 5) :: [Double]
16:27:58 <lambdabot>   [0.3471719303278187,0.14913877324413943,0.28734412691261246,0.6720783415185...
16:28:33 <mrAlex_> All is easy when you know the recipie ...
16:29:03 <ivanm> mrAlex_: "infinities"?
16:29:11 <ivanm> random[R]s will return an infinite list...
16:29:24 <mrAlex_> no, the values vere Infinity
16:29:44 <c_wraith> > Infinity
16:29:45 <lambdabot>   Not in scope: data constructor `Infinity'
16:29:46 <jmcarthur> > sum $ randoms (mkStdGen 5) :: Float
16:29:47 <mrAlex_> That was middle of the night, so I doubt I can reproduce it once more :)
16:29:51 <lambdabot>   mueval-core: Time limit exceeded
16:29:55 <c_wraith> > 1 / 0
16:29:57 <lambdabot>   Infinity
16:30:03 <mrAlex_> yup, this one
16:30:28 <lispy> Hmm
16:30:30 <mrAlex_> My impression was that somehow large Integers were naively converted to doubles
16:30:36 <jmcarthur> unless there is a bug, i doubt it would just generate Infinity. you would have to have done some arithmetic with it
16:30:43 <lispy> I wonder how it generates doubles from the ints
16:31:06 <lispy> We should be able to find the implementation
16:31:13 <lispy> Maybe in Base?
16:31:16 <jmcarthur> > maximum . take 1000 $ randoms (mkStdGen 5) :: Float
16:31:17 * hackagebot hpage 0.5.6 - A scrapbook for Haskell developers  http://hackage.haskell.org/package/hpage-0.5.6 (FernandoBenavides)
16:31:20 <lambdabot>   0.9998432
16:31:25 <mrAlex_> > :t randoms
16:31:26 <lambdabot>   <no location info>: parse error on input `:'
16:31:37 <jmcarthur> :t randoms
16:31:40 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
16:31:41 <fax> I was thinking of writing a word processor in haskell
16:32:05 <ivanm> fax: why?
16:32:14 <ivanm> we have enough word processors available
16:32:31 <ivanm> is there some fundamentally great thing you think you're going to be able to do that it's worth starting a new one?
16:32:55 <lispy> embedding Haskell in a webbrowser (to compete with javascript) would be a cool project
16:32:58 <ari> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24304#a24304   is there a commonly used name for this function? Hoogle doesn't seem to know of one...
16:33:35 <[swift]> i'd say word processors are far from perfect and could use a lot of work
16:33:55 <ivanm> lispy: except that you'd have to get it available on enough webbrowsers to make it worth using
16:34:12 <ivanm> and aren't javascript runtimes built into the webbrowsers rather than as a plugin, etc.?
16:34:17 <lispy> ivanm: have to start somewhere :)
16:34:24 <ivanm> having a haskell -> javascript converter might make more sense
16:34:31 <lispy> we have that
16:34:33 <c_wraith> ari:  you can build it with uncurry, (,), and liftM2
16:34:51 <lispy> ivanm: YHC has a javascript generating backend
16:34:55 <ivanm> lispy: it's a catch 22 problem: browsers won't include it if there aren't any users, and web developers won't use it if no browser supports it
16:34:57 <c_wraith> :t uncurry (liftM2 (,))
16:34:58 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
16:34:59 <ivanm> lispy: yeah, I know
16:35:19 <ivanm> besides, is haskell really the right lang to use for client-side in-browser stuff?
16:35:32 <ivanm> it's probably a tad too "big"
16:35:42 <stevenmarky> could write it as a C plugin
16:36:05 <mrAlex_> Codegen haskell -> JS?
16:36:11 <ari> c_wraith: Nice... guess it comes naturally enough to Haskellers there hasn't been a need to name it
16:37:49 <edwardk> lispy:  you just need to compile to javascript ;)
16:38:12 <lispy> except, that's *still* javascript
16:38:21 <lispy> and it's slow :)
16:38:29 <edwardk> getting faster every day ;)
16:38:30 <lispy> I want a fast language in my browser
16:38:31 * sm just read about http://pyjs.org .
16:38:39 <cads> haven't they been doing amazing things with javascript compiling?
16:39:07 <Axman6> yeah
16:39:38 <[swift]> iirc JS is actually pretty fast
16:39:54 <Axman6> well, it can be
16:40:10 <Axman6> depends on the implementation
16:40:13 <[swift]> indeed, consider that shorthand for "there are pretty fast implementations available"
16:41:04 <[swift]> javascript kinda gets a bad reputation because so many other components of the browser are slow
16:41:22 <ivanm> after all, no language is fast or slow since it's just a mathematical abstraction, blah, blah, blah
16:41:49 <ivanm> de-facto implementations (as in the language is associated with a specific implementationi), however, _can_ be fast or slow
16:42:10 <stevenmarky> internet exploder implementations
16:42:19 <bnjmn> some languages are more amenable to efficient implementations than others
16:42:53 <[swift]> there was a blog entry posted in this channel about that very topic
16:43:18 <Adamant> pretty fast is strong, but kind of like how C, C++, and Java got much faster after they started throwing a lot of compiler wizards at them, Javascript has improved a bunch and is still improving
16:44:14 <mrAlex_> There was a nice thread recently on LTU about tracing JIT's
16:44:52 <mrAlex_> s
16:44:54 <mrAlex_>  
16:45:02 <[swift]> Adamant: looking at the programming language benchmarks game, JS on V8 seems to beat Java 6 in most cases. i'd say it's justifiable to call it "pretty fast" at that point
16:45:31 <[swift]> Adamant: it's obviously no C/C++, tho
16:45:48 <Nafai> [swift]: Is that because of a better JIT?
16:45:57 <mrAlex_> It all terribly depends on the exact code. In V8 they did a good job optimizing loops and primitives
16:46:08 <[swift]> Nafai: i couldn't say, but that sounds likely
16:46:14 <Adamant> [swift]: I'd have to look more into that, but that's definitely a good sign and if the comparison is that straightforward, then yeah, I'd say "pretty fast"
16:46:16 <mrAlex_> But when it comes to DOM its a different story
16:46:22 * Nafai nods
16:46:27 <Nafai> the DOM just ruins JS :)
16:46:36 <[swift]> yeah, the DOM is the problem
16:47:23 <[swift]> there's currently a lot of research effort being put into improving the situation, tho; i have high hopes
16:47:24 <mrAlex_> Though from the end-user perspective, it's the rest of the browser which defines the speed and responsivness
16:47:43 <mrAlex_> I was never able to use Firefox for more then a day ;)
16:48:06 <Adamant> I can live with it in the current version.
16:48:25 <bnjmn> ff should dump xul for ui
16:48:50 <bnjmn> trade some flexibility for speed
16:49:01 <mrAlex_> In my case it's also a bit of history. I used Konqueror & Safari for years.
16:49:02 <[swift]> bnjmn: they're kind of trapped by the success of their addon architecture, tho, i think
16:49:18 <bnjmn> crippled by success!
16:49:20 <Adamant> [swift]: that might be changing with Jetpack
16:49:39 <Adamant> bnjmn: well you know, that's kind of the whole story of MS's OS stuff
16:49:45 <mrAlex_> And while they might be slower in some raw benchmarks, the responsiveness buys me
16:49:47 <bnjmn> oh yeah
16:49:48 <[swift]> Adamant: yeah, i haven't used jetpack but its more like chrome's extension architecture, right?
16:49:57 <bnjmn> isn't haskell trying to avoid success at all costs?
16:50:08 <ivanm> bnjmn: I like firefox _because_ of all the extensions
16:50:21 <Nafai> [swift]: As I understand it
16:50:25 <ivanm> whilst chrome also has extensions, using xul allows firefox to have way more
16:50:29 <bnjmn> i like firefox too
16:50:36 <Adamant> [swift]: not sure - the basic idea is to use HTML/CSS/JS pretty much only
16:50:38 <mrAlex_> bnjmn: i guess `avoid success` motto is loosing it's power slowly
16:50:44 <Nafai> I vastly prefer Chrome for now
16:50:47 <Adamant> and to change the security model to be easier
16:50:49 <[swift]> Adamant: that's much like chrome
16:50:57 <bnjmn> i use chrome more now too
16:51:06 <Adamant> closer to a object-capability model
16:51:11 <[swift]> chrome's extension architecture is pretty convenient but they need to expose more things through JS
16:51:31 <mrAlex_> wont it bite back on security?
16:52:02 <Adamant> [swift]: that's part of the problem - stuff like NoScript and Adblock for Firefox need much deeper hooks
16:52:32 <mrAlex_> To be fare I never really understoo all that fuzz about plugins -- I hardly used any in all my browsers
16:52:44 <[swift]> Adamant: yup. that, and some more flexibility with custom UIs would be nice
16:53:01 <Adamant> yeah, then I totally understand why you love Safari and such
16:53:12 <Adamant> extensions and plugins make Firefox
16:53:13 <[swift]> mrAlex_: some can really improve your productivity. i really like tree-style tabs for FF, for example.
16:53:14 <Adamant> pretty much
16:53:25 <mrAlex_> I guess the best part of safari is that it runs on mac :)
16:53:36 <Adamant> and Windows, now :P
16:53:41 <mrAlex_> Cheap way to avoid 99% of scam / botnets and the rest
16:53:44 <[swift]> mrAlex_: what doesn't tho, other than IE? =)
16:53:57 <Adamant> mrAlex_: yeah, but sooner or later, that will wear out
16:54:23 <edwardk> hrmm, what is a good example of a type level list library?
16:54:32 <ivanm> a what?
16:54:32 <edwardk> i need one using type families
16:54:34 <mrAlex_> As a wild guess -- Apple will need at least another 15-25% of the market share to become an attractive target
16:54:37 <[swift]> yeah i'm dreading macs achieving sufficient market share that they're no longer secure by virtue of nobody caring to attack them
16:54:41 <edwardk> HList using type families
16:54:48 <Adamant> mrAlex_: probably too wild.
16:55:02 <Adamant> they are already roughly 10% of the US
16:55:10 <ivanm> edwardk: do I dare ask why?
16:55:25 <Adamant> and there has been a mild overall upswing in stuff targetting Mac user
16:55:32 <Adamant> *users
16:55:46 <edwardk> ivanm: fixing up some of the annotated rope code, i have a monoidal annotation, i'd like to have it turn the list of type level brands into an hlist so it really is monoidal.
16:56:00 <mrAlex_> hmm, hadnt heard much yet.
16:56:10 <ivanm> [swift]: macs are more resistent to viruses, etc. as they use a more secure unix-based security model by default
16:56:20 <Adamant> no.
16:56:22 <mrAlex_> It's not really true.
16:56:25 <[swift]> ivanm: eh‚Ä¶ not buyin it
16:56:29 <ivanm> why not?
16:56:38 <ivanm> edwardk: :s
16:56:47 <Adamant> ivanm: because Unix was never that resistant to viruses as claimed
16:56:50 <mrAlex_> In default setup users enter admin group
16:57:02 <ivanm> mrAlex_: in OSX?  :o
16:57:06 <Adamant> and what mrAlex_ just said
16:57:08 <ivanm> Adamant: how weren't they?
16:57:09 <mrAlex_> And admin has write access to HUGE number of places
16:57:11 <mrAlex_> yep
16:57:33 <Adamant> ivanm: most of the initial research on viruses was done on Unix machines
16:57:35 <[swift]> ivanm: hackers at hacking contests have proven pretty effective at finding exploits in OS X, too; that's empirical evidence
16:57:37 <mrAlex_> I drop admin for myself, but it's soo annoying sometimes
16:57:57 <ivanm> [swift]: IIRC, most exploits were through quicktime, etc. and not the OS itself...
16:58:29 <Adamant> ivanm: yeah, but the web browser is the easiest point of entry
16:58:31 <[swift]> ivanm: does it matter?
16:58:49 <ivanm> *shrug*
16:59:02 <[swift]> this is something that annoys me about many people's conventional thinking on security
16:59:17 <mrAlex_> It's enought to look around, and you will quickly realize that most successful exploits target that "warm soft thing" between seat and keyboard. And no OS can fix it
16:59:29 <[swift]> they're trying to protect things that belong to root and admin groups
16:59:47 <ivanm> mrAlex_: right
16:59:49 <Adamant> if everything is in your user account, it doesn't matter.
16:59:50 <[swift]> but the things in a user's home directory, that they will always have write access to, are the things that REALLY need protecting
16:59:52 <Adamant> right.
17:00:00 <Adamant> "root is a state of mind"
17:00:02 <ivanm> mrAlex_: but it's much harder to install dodgy software on linux than windows
17:00:11 <ivanm> even if we assume that both linux and windows versions exist
17:00:24 <Adamant> ivanm: true, but only if you get everything though a package manager
17:00:29 <mrAlex_> Btw, browser isn't as vulnerable nowadays -- they implemented some sandboxing mechanism in 10.6
17:00:32 <ivanm> the ubuntu predilection for prepending sudo everywhere makes that less true than it used to be however
17:00:38 <mrAlex_> Though I have no idea how effective it is
17:00:44 <ivanm> Adamant: third party RPMs, etc.
17:00:53 <ivanm> which I suppose would work, actually
17:00:55 <ivanm> but most people don't
17:01:02 <danderson> you also don't need sudo for much stuff
17:01:11 <ivanm> so that's an extra security model: if you get screwed by a bad package, then so does everyone else! :p
17:01:15 <danderson> a spam zombie daemon can run just fine as any random user
17:01:20 <Adamant> ivanm: right, I mean that most people use a fairly centralized one
17:01:24 <[swift]> i'd say a filesystem like zfs that can maintain all old versions of files, combined with good backups, would provide more security for the things people actually CARE about
17:01:34 <[swift]> its easier to reinstall the OS than to rewrite your thesis
17:02:14 <mrAlex_> For ZFS to provide extra security one has to be using it. Its not much better then doing plain backups
17:02:18 <Adamant> mrAlex_: I wouldn't count on the sandboxing mechanism too much until later versions of OS X
17:02:46 <Adamant> I think you're conflating safety and security.
17:02:49 <[swift]> mrAlex_: well hopefully someone like apple will take the ideas and make them automatic. time machine already does that for backups; it seems a natural fit for something like ZFS, too.
17:02:51 <Adamant> with the ZFS thing.
17:03:07 <mrAlex_> Well, I remember poking around when 10.5 was released. That was pretty funny.
17:03:07 <ivanm> yeah
17:03:29 <felzix> How can one load an image for opengl in haskell?
17:03:41 <[swift]> Adamant: i understand the difference, what i'm trying to express is that there's a disconnect between what users care about and what people are usually securing when they talk about security
17:03:47 <Adamant> ah, alright
17:03:51 <mrAlex_> They implemented their own socket-level firewall, which was (by default) blocking software not signed by apple key
17:04:08 <mrAlex_> And there was signed version of "nc" (netcat) in it
17:04:53 <edwardk> ivanm: found one: http://hackage.haskell.org/packages/archive/tfp/0.2/doc/html/Types-Data-List.html
17:05:17 <mrAlex_> Oh my, midnight here.
17:05:29 <ivanm> edwardk: *shudder*
17:05:39 <edwardk> ivanm: that is nothing =)
17:05:44 <[swift]> that said, traditional security is important too, for society as a whole. people don't want to lose their data, but they also don't want it stolen or their computers used as part of a botnet
17:05:54 <[swift]> but anyhow i'll stop going on about it =)
17:06:46 <Adamant> to relate this to Haskell and make it on-topic, I think some of the stuff Galois and other groups use the language for to develop higher-security software are interesting.
17:06:51 <edwardk> ivanm: it is so much easier with type families. consider http://hackage.haskell.org/packages/archive/type-int/0.4/doc/html/ by way of comparison
17:07:30 <ivanm> edwardk: I question why anyone wrote such a thing
17:07:37 <ivanm> the only reason I can think of is morbid curiosity :s
17:07:46 <edwardk> ivanm: i needed type level integers for dealing with array bounds at the time
17:08:05 <edwardk> and the type level integers i can get out of peano arithmetic bottom out around 20.
17:08:06 <ivanm> hmmm...
17:08:13 <ivanm> since we don't have dependent types yet?
17:08:31 <edwardk> the ones i can build using base 2, 2s' complement, bottom out around 2^20, which is small enough that i can still need arrays bigger than that
17:09:11 <edwardk> so, going to 16s complement hex digits i can deal with just under 80 bits of data before hitting the recursion cap
17:09:12 <ivanm> I wonder whether using okasaki's (or was it oleg's? I forget) trick for type-safe matrix multiplication would work...
17:11:03 <ivanm> http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps (I remembered right the first time, it _was_ okasaki)
17:13:39 * hackagebot pandoc 1.5.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.5.1 (JohnMacFarlane)
17:14:32 <mrAlex_> Good night everybody. See you next time .
17:19:27 <superoptimizer> Having trouble understanding lazy evaluation and/or pattern matching. Wrote two versions of 'take' myself, and one operates as I would expect, the other doesn't.
17:19:50 <superoptimizer> works: gimme n (x:xs) | n > 0 = x : gimme (n-1) xs
17:19:58 <superoptimizer> works:                | otherwise = []
17:20:09 <superoptimizer> broken: gimme n (x:xs) = x : gimme (n-1) xs
17:20:13 <superoptimizer> gimme 0 _ = []
17:20:25 <ivanm> superoptimizer: what happens if n < 0 ?
17:20:36 <ivanm> @src take
17:20:37 <lambdabot> take n _      | n <= 0 =  []
17:20:37 <lambdabot> take _ []              =  []
17:20:37 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:20:54 <ivanm> superoptimizer: and you have no base case in the latter
17:21:03 <superoptimizer> So that's obviously a problem, and one of the reasons I wrote the working version.
17:21:04 <ivanm> what happens for "gimme 5 []" ?
17:21:32 <superoptimizer> ivanm: Won't pattern matching hit when n is down to 0?
17:22:07 <ivanm> superoptimizer: it is perfectly valid to write "take (-5) xs"
17:22:59 <superoptimizer> ivanm: Sure. Ignoring that momentarily, though, I don't understand why the broken version doesn't work for "gimme 5 [1..]"
17:23:22 <ivanm> it should
17:23:37 <superoptimizer> It just keeps printing.
17:23:53 <ivanm> > let gimme n (x:xs) = x : gimme (n-1) xs; gimme 0 _ = [] in gimme 5 [1..]
17:23:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:23:59 <lhames> superoptimizer: It's the order of your patterns.
17:24:06 <lhames> I think.
17:24:06 <ivanm> oh, yeah
17:24:14 <ivanm> superoptimizer: the first one matches the 0 case as well
17:24:17 <ivanm> put the 0 case first
17:24:22 <superoptimizer> lhames: Ah, I see! Thanks.
17:24:25 <ivanm> lhames++
17:24:36 <ivanm> lhames: coming to AusHack?
17:24:50 <lhames> AusHack?
17:24:59 <ivanm> http://www.haskell.org/haskellwiki/AusHac2010
17:25:14 * ivanm noticed that lhames has an australian hostmask
17:27:33 <lhames> Yep - I'm in Oz. Sounds sweet.
17:27:38 <ivanm> \o/
17:27:46 <ivanm> Axman6: we might have another attendee! \o/
17:27:53 <ivanm> lhames: which part of aus are you from?
17:28:13 <lhames> Sydney.
17:28:23 <lhames> I'm a bus ride away from UNSW, so travel should be easy. :)
17:28:24 <ivanm> even better for you then! ;-)
17:28:40 <lhames> I'm a Haskell newb though.
17:29:15 <ivanm> lhames: well, you have a few months to get up to scratch :p
17:29:16 <lhames> I'll hake to see if I can improve my skills a litte before then. :)
17:29:19 <lhames> Yep.
17:29:26 <ivanm> but it won't be that big a deal
17:29:31 <ivanm> where do your hacking interests lie?
17:29:34 <lhames> I've got plenty of LLVM experience though, so at least that won't go over my head.
17:29:54 <lhames> I'm working on register allocation for irregular architectures for my PhD.
17:29:55 <superoptimizer> lhames: What have you done with LLVM?
17:30:14 <lhames> superoptimizer: I wrote the PBQP allocator.
17:30:17 <superoptimizer> lhames: Oh, nice. I work on compilers myself. New to FP and Haskell, though.
17:30:22 <superoptimizer> lhames: Excellent.
17:30:31 <superoptimizer> lhames: I was just going to start looking at that, actually.
17:30:34 <lhames> And interned with the LLVM team last summer trying to improve their liveness work.
17:30:43 <lhames> Ahh cool.
17:30:53 <lhames> It's an interesting idea. Now I'm just trying to make it practical.
17:30:57 <superoptimizer> lhames: I saw that they still just have the linear scan and local allocators.
17:31:06 <lhames> Yep.
17:31:28 <superoptimizer> lhames: Years ago I worked with an intern from Davis who was working 0-1 integer programming to do register allocation and scheduling simultaneously.
17:31:38 <superoptimizer> lhames: Interesting, but incredibly slow. :)
17:32:01 <lhames> superoptimizer: Who was that?
17:32:13 <superoptimizer> lhames: I don't recall his name. Kent Wilken was the advisor.
17:34:05 <lhames> Ahh yeah - I remember Wilken's name on a couple of ILP papers.
17:34:31 <MisterN> @src liftM
17:34:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:34:35 <lhames> PBQP does optimal coloring, but not scheduling, and we try to stick to heuristics to keep the solver time down.
17:34:37 <superoptimizer> How long have you been working with LLVM? I've been aware of the project for a while, but didn't start looking at it until last summer.
17:35:06 <lhames> Someone pointed me to it in 2006, and I started hacking on it in early 2007.
17:35:35 <superoptimizer> I've found the code pretty easy to read and write. Compared with several other compilers I've worked on it's quite a bit nicer in many ways. The tools, esp.
17:35:56 <superoptimizer> I love the graphviz integration, in particular.
17:36:07 <lhames> Yeah that's really handy.
17:36:13 <ivanm> MisterN: liftM is equivalent to fmap for monads
17:36:24 <ivanm> (as in, the Functor instance for monads has fmap = liftM)
17:36:50 <lhames> superoptimizer: Yeah the tools are great.
17:37:05 <superoptimizer> I'm mostly just curious about Haskell, but I do want to learn something about compiling functional languages and take a look at ghc and the hook-up to LLVM.
17:37:16 <MisterN> ivanm: uh i'm reading real world haskell, you know. i'm not that advanced yet :)
17:37:23 <ivanm> heh, fair enough
17:37:32 <zenso> MisterN: me too
17:37:47 <zenso> how far along are you?
17:37:47 <superoptimizer> MisterN: Me too. Page 80 or so. :) Forgetting as much as I'm learning, it seems.
17:37:49 <ivanm> @undo do { x1 <- m1; return (f x1) }
17:37:49 <lambdabot> m1 >>= \ x1 -> return (f x1)
17:37:58 <ivanm> @. pl undo do { x1 <- m1; return (f x1) }
17:37:58 <lambdabot> f `fmap` m1
17:38:02 <ivanm> heh
17:38:18 <ivanm> I was hoping for m1 >>= return . f ;-)
17:39:05 <zenso> superoptimizer: this'll be my second time through the book
17:39:09 <zenso> it's going much better
17:39:11 <MisterN> @pl \f -> do { x1 <- m1; return (f x1) }
17:39:11 <lambdabot> (line 1, column 10):
17:39:11 <lambdabot> unexpected "{"
17:39:11 <lambdabot> expecting variable, "(", operator or end of input
17:39:14 <cads> I remember once hearing about a way to convince the ghc lexer to let you write lambdas using the actual lambda character and a right-arrow.
17:39:27 <cads> > let b = (Œª a ‚Üí a^2) in b 10  -- Like so.
17:39:28 <MisterN> @.pl pl undo \f -> do { x1 <- m1; return (f x1) }
17:39:28 <lambdabot>   Pattern syntax in expression context: Œª a -> a ^ 2
17:39:28 <lambdabot> (line 1, column 9):
17:39:28 <lambdabot> unexpected "\\"
17:39:28 <lambdabot> expecting variable, "(", operator or end of input
17:39:52 <ivanm> cads: yeah, I think there's an extension
17:39:56 <ivanm> UnicodeSyntax or something
17:40:10 <cads> This would require lexing Œª as \, and  ‚Üí as ->.
17:40:11 <MisterN> cads: uh how do you type that character?
17:40:14 <ivanm> MisterN: @pl doesn't understand do notation by the looks of things
17:40:21 <MisterN> ivanm: so it seems
17:40:22 <ivanm> MisterN: copy/paste I believe :p
17:40:33 <ivanm> cads: I'm not sure if the arrow works however
17:40:40 <MisterN> cads: copy-pasting characters really sucks for programming
17:40:50 <zenso> looks like lambda bot converted the arrow and not the lambda
17:41:05 <ivanm> yeah, and then escaped it for some reason
17:41:07 <mm_freak_> chrisdone: the fastirc repository is uploaded now
17:41:10 <cads> I have it set for  \-(tab)
17:41:18 <lhames> ivanm: Any registration fees for AusHack?
17:41:26 <benmachine> arrow is done by -XUnicodeSyntax I think
17:41:33 <cads> and ‚Üí is  ar-(tab)
17:41:41 <benmachine> but Œª is problematic because it's a valid variable name
17:41:43 <mm_freak_> chrisdone: darcs get http://code.haskell.org/fastirc/
17:42:06 <ivanm> lhames: nope
17:42:07 <mm_freak_> but wait until the next release before adding checks
17:42:25 <ivanm> lhames: just have to get your own meals, etc.
17:42:49 <ivanm> cads: any particular reason for using fancy chars however?
17:42:58 <lhames> ivanm: No worries there.
17:42:59 <cads> benmachine, I did find a ghc bug report discussing that the Œª  <->  \  would require to completely ignore lambdas as variable names
17:43:11 <cads> ivanm, just readability
17:43:40 <cads> in leksah the conversion is done automatically
17:43:42 <ivanm> mm_freak_: needs a description ;-)
17:44:12 <ivanm> and the (debian?) machine running c.h.o doesn't like whatever non-ASCII character you use in the surname...
17:44:50 <theorbtwo> OTOH, using fancy chars instead of the nonfancy ones doesn't really help all that much in readability, and creates a lot of difficulty in typability, especially given that the world hasn't really gotten all that good at encodings Just Workign yet.
17:44:54 <mm_freak_> ivanm: it's the first package i've ever uploaded‚Ä¶  note that i even forgot to add my email address =)
17:45:35 <superoptimizer> @src take
17:45:36 <lambdabot> take n _      | n <= 0 =  []
17:45:36 <lambdabot> take _ []              =  []
17:45:36 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:45:40 <cads> theorbtwo, as evidenced by other problems I've been having working in my window/msys/haskell platform environment :)
17:46:13 <ivanm> mm_freak_: heh
17:46:30 <ivanm> mm_freak_: by "uploaded" you mean to a repository rather than hackage I take it?
17:46:39 <cads> theorbtwo, but a good text editor can give you the fancy chars for free, as in leksah where arrows in type annotations are converted automatically
17:46:54 <MisterN> @src maybeIO
17:46:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:46:59 <MisterN> :t maybeIO
17:47:00 <lambdabot> Not in scope: `maybeIO'
17:47:03 <MisterN> hmmm
17:47:04 <mm_freak_> ivanm: no, it's on hackage, too
17:47:14 <MisterN> ooh :D
17:47:35 <theorbtwo> cads: Yeah, or you could just prettify it for display.  Of course, that leads to problems where people think that they have to type it that way.
17:47:38 <ivanm> mm_freak_: quick! upload a bugfix release!
17:47:48 <mm_freak_> ivanm: to fix what?
17:47:49 <superoptimizer> Where does @src look up the source from, and where can I find source for functions on an install on Mac OS X?
17:47:57 <ivanm> mm_freak_: putting in an email address
17:48:03 <theorbtwo> Making the compiler accept that syntax will make it OK to type it that way as far as the compiler is concerned.
17:48:04 <cads> theorbtwo, yeah, that is what leksah essentially does
17:48:12 <ivanm> though hackage likes your surname better than c.h.o does
17:48:15 <MisterN> @pl \act -> handle (\_ -> Nothing) (Just `liftM` act)
17:48:15 <lambdabot> handle (const Nothing) . fmap Just
17:48:22 <MisterN> const?
17:48:32 <mm_freak_> ivanm: i already fixed it locally and i'm adding a lot of stuff tonight‚Ä¶  you can expect the next release in a few hours
17:48:34 <theorbtwo> ...but it doesn't fix the problem of people thinking they *have* to type it that way.
17:48:37 <MisterN> :t fmap
17:48:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:48:39 <ivanm> @src const
17:48:39 <lambdabot> const x _ = x
17:48:42 <ivanm> MisterN: ^^
17:48:48 <ivanm> mm_freak_: fair enough
17:48:51 <zenso> hah
17:48:56 <mm_freak_> ivanm: i hope that in a few hours you can already connect to an IRC server =)
17:48:58 <theorbtwo> A given editor converting \ to a lamda char, and etc, only helps users of that editor.
17:49:08 <MisterN> ivanm: aah const is useful then.
17:49:09 <ivanm> mm_freak_: a bit late now since you've released it, but I would have capitalised IRC if only to make it more obvious what it does
17:49:14 <MisterN> :t const const
17:49:15 <lambdabot> forall a b b1. b1 -> a -> b -> a
17:49:17 <zenso> anyone have any recommendations for xmonad tutorials?
17:49:21 <ivanm> "fastirc" doesn't immediately read as "fast irc" ;-)
17:49:31 <MisterN> :t const . const
17:49:32 <ivanm> zenso: #xmonad :p
17:49:32 <lambdabot> forall b a b1. a -> b -> b1 -> a
17:49:35 <mm_freak_> ivanm: for some reason i prefer lowercase package names =)
17:49:39 <zenso> oops
17:49:44 <theorbtwo> ...and implementing such a thing is fraught with peril, when your editor converts a -> that is supposed to be part of a string, or for some other reason shouldn't be.
17:49:46 <zenso> thanks ivanm
17:49:52 <ivanm> no worries
17:50:01 <mm_freak_> ivanm: i'm still struggling with myself about how to do the event handling‚Ä¶  either callbacks or concurrency
17:50:08 <mm_freak_> i think i'll go with concurrency
17:50:09 <ivanm> theorbtwo: yeah, it's issues like that which is why I stopped using the pretty lambda support in emacs
17:50:23 * ivanm heads off
17:50:36 <theorbtwo> I'm not sure why a lambda char is more readable then a backslash, though...
17:51:11 <mm_freak_> theorbtwo: i don't like the lambda character in actual code
17:51:12 <zenso> agreed thorbtwo
17:51:25 <mm_freak_> because greek letters are identifiers to me
17:51:36 <mm_freak_> i don't see why lambda should be special
17:51:49 <zenso> other than being pedantic, using lambda is unnecessary
17:52:24 <cads> maybe pedantic
17:53:07 <cads> but it's closer to my own written notation, so I like it
17:53:57 <zenso> cads: to each his own
17:54:19 <zenso> just don't be surprised if not everyone jumps all over it ;)
17:54:53 <cads> heh, I'm not drafting a proposal for the next haskell revision or anything :)
17:54:57 <mm_freak_> when i use OverloadedStrings and write "x", is that translated to (pack "x") or to (singleton 'x')?
18:01:49 <ddarius> mm_freak_: It's translated to fromString "x"
18:03:02 <mm_freak_> ddarius: well, my question is whether it gets optimized
18:03:22 <aavogt> so ultimately it depends on what the fromString instance for bytestring is
18:03:31 <ddarius> mm_freak_: I imagine no more or less than pack would be.
18:04:35 <siracusa> Is there a summary of all standard flags that are available in cabal files?
18:05:13 <aavogt> siracusa: you make up flags yourself
18:05:45 <siracusa> aavogt: But then were does base4 and splitBase come from?
18:05:50 <aavogt> or you mean stuff like   built-with: ... , author and so on?
18:06:17 <aavogt> siracusa: you specify    flag foo
18:06:40 <aavogt> either users specify them with --flags="foo base4"
18:06:50 <mm_freak_> hmm, ok
18:07:01 <aavogt> or cabal figures out that it can only build with a certain combination
18:07:13 <aavogt> in which case you don't have to override anything
18:08:09 <siracusa> aavogt: Ok, so everyone using the base4 and splitBase flags is just `coincidence'?
18:08:21 <aavogt> they copy eachother
18:08:33 <aavogt> or you're looking at cabal files written by the same person
18:09:39 <siracusa> I thought of them being standard flags that are added by GHC.
18:10:31 <exordinary> if you want to share your ex's vids --> #chatberry
18:13:19 <tensorpudding> Are Char8 and Word8 bytestrings different things?
18:13:39 <edwardk> tensorpudding: nope
18:13:53 <edwardk> they are the same underlying type, just re-exported
18:13:54 <tensorpudding> So a function which works on one bytestring should work on the other?
18:13:57 <edwardk> yeah
18:14:01 <edwardk> you can load both and mix and match
18:14:10 <tensorpudding> Well, I'm getting a type problem
18:14:13 <edwardk> just qualify them, no conversion needed on the bytestrings
18:14:23 <edwardk> probably because you may have a Lazy bytestring mixed in
18:14:31 <tensorpudding> Oh, darn.
18:14:34 <tensorpudding> That could be it.
18:14:36 <edwardk> Data.ByteString.Lazy and Data.ByteString are different types
18:14:58 <tensorpudding> Right, it seems that the function expects a non-lazy one.
18:15:24 <tensorpudding> err wait, I was using Data.ByteString.Char8
18:15:31 <edwardk> then chunk it up and feed it through piecemeal, or S.concat . L.toChunks
18:15:46 <tensorpudding> and it was expecting a lazy one
18:15:52 <edwardk> well, it is a lot easier to feed a strict buytestring to something that wants a lazy one
18:16:00 <edwardk> L.fromChunks . return
18:16:33 <tensorpudding> Oh, hmm.
18:16:47 <tensorpudding> This is Data.ByteString.Lazy.Internal.ByteString
18:17:38 <tensorpudding> and it doesn't like being called a Data.ByteString.Lazy.Char8.ByteString
18:17:39 <edwardk> data.bytestring.lazy.internal.bytestring is exported by data.bytestring.lazy and data.bytestring.lazy.char8
18:17:54 <tensorpudding> or at least, the qualified imported name of the latter
18:18:04 <tensorpudding> I imported D.B.L.C8 as B
18:18:47 <edwardk> in d.b.l.c8 it gets it from 'import Data.ByteString.Lazy.Internal' -- so that is the same bytestring
18:19:33 <dankna> so
18:19:49 <dankna> is there any clever way to make types with constraints, like nonempty lists and nonnegative doubles,
18:20:04 <dankna> or do I just make list types and double types and then not export the constructors but only functions that do the validation?
18:20:12 <edwardk> sure, well, at least the former, it is a lot harder to define the latter inductively
18:20:26 <tensorpudding> It works when I import it unqualitified.
18:20:31 <tensorpudding> er, unqualified
18:20:36 <dankna> well, yeah, I see how to do the former I guess :)
18:20:41 <fax> dankna -- I don't even do validation
18:20:44 <dankna> just have One and More constructors
18:20:48 <edwardk> that is one way
18:20:51 <dankna> fax - no?
18:21:08 <edwardk> the other is to tag the type with an extra argument that works as an annotation that tells you something about it
18:21:25 <dankna> ah hm
18:21:28 <edwardk> and use the type class machinery to carry around the 'refinement type'
18:21:48 <edwardk> head :: List NonEmpty a -> a
18:22:03 <edwardk> cons :: a -> List c a -> List NonEmpty a
18:22:04 <tensorpudding> Hmm, including a type annotation on the function explicitly using B.ByteString makes it work.
18:22:12 <fax> dankna, you can go quite far with using wild hacks to encode logical invariants but at some point I start to feel like, unless something has a natural structural way to encode it -- doing all this insane stuff is not worth it
18:22:14 <tensorpudding> But it looks like an awful kludge.
18:22:27 <edwardk> then any time you can't prove the type argument = NonEmpty you need to go through a heavier weight check
18:22:39 <dankna> fax - well, what I want is to know a priori that any instance of my super-complicated data structure is inherently valid
18:22:46 <dankna> and I need those two particular types to do that
18:22:52 <edwardk> you can of course, be more anal retentive and deal with lists of length n so that cons'ing increases the length by one, etc.
18:22:57 <dankna> (how complicated is it?  1500 lines, haha)
18:22:58 <fax> dankna, so I tend to just use haskell as a kind fo untyped script language (one that has really really good syntax errors) and for really tricky stuff there's always paper or Coq
18:23:08 <dankna> hmm
18:23:20 <fax> I tend to write a lot partial programs in haskell, which only works if given correct input
18:23:26 <dankna> yeah I see
18:23:29 <dankna> (to both)
18:23:32 <fax> I think everyone does this -- just some people don't really notice it happening :P
18:24:03 <fax> (of course user input, or data from a file, or webserver form input is ALWAYS "correct"...)
18:24:15 <fax> (meaning that it's never safe trust it...)
18:24:15 <dankna> (haha)
18:24:30 <fax> hm that didn't make sense now that I read it back
18:24:44 <dankna> (it made the opposite of sense, but I inverted it mentally and got something that did)
18:25:04 <fax> ok :D
18:25:47 <dankna> anyway, edwardk, hmm, so with your approach I still have to not export the constructor
18:25:59 <dankna> which is fine, as I can just export mkNonEmpty instead
18:26:19 <dankna> but then mkNonEmpty has to check its input and generate an error
18:26:31 <dankna> which will necessarily be an error in pure code, which will be a pain to catch
18:26:35 <dankna> bad style, isn't it?
18:26:53 <ddarius> mkNonEmpty :: a -> [a] -> List NonEmpty a
18:27:05 <dankna> oh, yes, good
18:27:11 <dankna> but I still have that problem for mkNonNegative
18:27:57 <fax> dankna to expand a bit on what I was meaning e.g.   if length xs > 1 then head xs else ...    is fine because there's this (invisible) proof/rumor going around that xs is nonempty
18:28:04 <ddarius> dankna: The point of such mechanisms is not to annihilate errors, but to push them outward and allow large areas of code that are "provably" error-free.
18:28:05 <dankna> rumor, haha
18:28:11 <edwardk> dankna: or you have to use GADTs
18:28:24 <dankna> I'm not at all adverse to GADTs, I'm already using them for another aspect of this
18:28:26 <fax> danka, but this is not new I mean every time we use division this sort of thing happens
18:28:34 <dankna> fax: hrm...
18:28:39 <dankna> ddarius: that's a fascinating point
18:28:45 <ddarius> dankna: The ideal situation would be to do a check on user input immediately upon receipt that verifies that it will work with all the rest of the coed.
18:29:06 <Spaceghost> what is the good of make demostrations in Haskell?
18:29:14 <fax> it's really hard (to the point of just being ridiculous) to put numerical invarients into the type system -- "number theory is hard" and the type system isn't even on your side!
18:29:23 <Spaceghost> I find useful write functions, and maybe derivations?
18:29:29 <dankna> ddarrius: that's what I want - I want the check to occur as the data structure is constructed.  but putting the check in pure code rather than IO makes it happen at some unspecified later time, doesn't it?
18:29:33 <Spaceghost> but write an induction demostrate, for example?
18:29:42 <fax> so what seems to work is proofs on paper and which the programs have forgotten about
18:30:43 <ddarius> dankna: Potentially.  Why does the check need to be in pure code.  You could have a function like: readNonEmptyList :: Read a => IO (NonEmptyList a)
18:30:49 <dankna> hmm
18:31:06 <fax> Spaceghost: if you do program derivation for haskell it is a great idea to put that in the source code (as a comment in some kind of 'literate' style)
18:31:18 <ddarius> For pure code you normally have a function a -> Maybe b
18:31:22 <fax> Spaceghost: and tell me :P because I like to read it
18:31:43 <dankna> but of all my dozens of validity constraints it's the only one that I can't enforce purely
18:31:44 <dankna> oh!
18:31:54 <dankna> Maybe will work fine, hahah
18:32:08 <dankna> that was the simple suggestion I was hoping for
18:32:26 <Spaceghost> you said that because is hard or imposible did this? fax
18:32:59 <dankna> thanks, all
18:33:05 <fax> Spaceghost - /I/ find it very difficult but I know people do this technique to great effect
18:33:58 <fax> it's like origami
18:34:49 * hackagebot graphics-drawingcombinators 1.3.1 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.3.1 (LukePalmer)
18:34:51 * hackagebot rope 0.4 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.4 (EdwardKmett)
18:44:39 <edwardk> ddarius: i wound up having to brand the ropes with a type so i could get the annotations to stay with the appropriate rope, but its looking usable
18:44:40 <edwardk> http://comonad.com/haskell/rope/dist/doc2/html/rope/Data-Rope-Annotated.html
18:44:47 <rookie> Hi, I'm having some trouble with some haskell code. Is this the right place to ask questions?
18:44:56 * hackagebot Bravo 0.1.0.1 - Static text template generation library  http://hackage.haskell.org/package/Bravo-0.1.0.1 (MatthiasReisner)
18:45:01 <dankna> no, you want #java.  (yes, it is.)
18:45:04 <edwardk> rookie: yes
18:45:17 <rookie> @dankna: funny :P
18:45:17 <lambdabot> Unknown command, try @list
18:45:29 <dankna> yeah, sorry, couldn't resist
18:45:59 <rookie> Im having some trouble with whitespace (i think)
18:46:03 <rookie> menu = do putStr "Input File? (Blank for default name)"           filename <- getLine           if filename == ""  	     then                let filename = "default"  	     else putStrLn "You're wrong!" 	  putStr filename
18:46:10 <rookie> damn, how can i copy code?
18:46:11 <edwardk> @hpaste
18:46:12 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:46:15 <edwardk> paste it there
18:46:32 <rookie> @hpaste menu :: IO() menu = do putStr "Input File? (Blank for default name)"           filename <- getLine           if filename == ""  	     then                let filename = "default"  	     else putStrLn "You're wrong!" 	  putStr filename
18:46:32 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:47:30 <rookie> kinda confused...(not used to irc)
18:47:51 <dankna> you have to go to that website and use it :)
18:49:00 <rookie> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8837#a8837
18:49:54 <edwardk> rookie: overall it looks good. be warned ghc treats tabs as 8 spaces exactly, and mixing tabs and spaces will bite you in the ass if you're doing so
18:50:20 <rookie> Im getting an "unexpected keyword else" error
18:50:30 <rookie> could it be mixing spaces and tabs?
18:50:34 <edwardk> yeah
18:50:41 <edwardk> oh
18:50:42 <edwardk> no
18:50:44 <edwardk> you have that 'let
18:51:30 <rookie> whats the issue with the let?
18:51:50 <edwardk> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8837#a8838
18:52:04 <edwardk> let has two uses
18:52:22 <edwardk> do { let foo = bar; x <- baz; ... }
18:52:22 <edwardk> and
18:52:31 <edwardk> let { foo = bar; baz = quux } in ...
18:52:43 <siracusa> But then putStrLn filename'
18:52:45 <edwardk> the let you have was interpreted as the latter because it was not found inside the do block
18:52:54 <edwardk> siracusa: yeah
18:53:39 <rookie> so the "else" was seen as part of "let"?
18:53:42 <EvanR> @src map
18:53:43 <lambdabot> map _ []     = []
18:53:43 <lambdabot> map f (x:xs) = f x : map f xs
18:54:07 <aavogt> well that's not allowed, rookie
18:54:11 <EvanR> > map 37 []
18:54:12 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
18:54:12 <lambdabot>    arising from the literal `37' at ...
18:55:01 <edwardk> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8837#a8840
18:55:04 <edwardk> yeah
18:55:05 <rookie> thanks ppl, i'll look at the code and try to understand it a bit more
18:55:25 <edwardk> the version there restructures the code to move 'everything to do with the filename' into a method named done
18:55:34 <edwardk> then just calls if with either value.
18:56:02 <aavogt> EvanR: that would be [] if you didn't check any types, but that's not the case
18:56:17 <EvanR> hmm.
18:56:20 <rookie> @edwardk thx
18:56:20 <lambdabot> Unknown command, try @list
18:56:29 <EvanR> > map (const 37) []
18:56:30 <lambdabot>   []
18:56:40 <EvanR> @type map
18:56:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:56:43 <rookie> edwardk: thx
18:56:53 <edwardk> rookie: np. good luck!
18:57:10 <EvanR> [] must be value with type [a] where a is any type
18:57:16 <rookie> Still trying to get my mind to this "haskell" not "c" :P
18:57:22 <rookie> *to think
18:58:00 <edwardk> heh after all of that work on my rope annotations, they seem to like me to have to use lots of explicit type annotations
18:58:07 <sbahra> Is this rookie, attilio rookie?
18:58:12 <sbahra> or some other rookie?
18:58:20 <rookie> some other rookie
18:58:23 <sbahra> Ah :)
18:58:27 <rookie> sorry to disapoint
18:58:38 <sbahra> No disappointment. :D
19:02:04 * hackagebot rope 0.5 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.5 (EdwardKmett)
19:04:05 * hackagebot hsignal 0.1.0.1 - Signal processing  http://hackage.haskell.org/package/hsignal-0.1.0.1 (VivianMcPhail)
19:04:35 <edwardk> hackage is busy tonight
19:05:00 <dankna> yep
19:05:42 <Nafai> Yay hackage
19:16:28 <PlotDevice> Is anyone here familiar with Yi? I'm trying to install it through cabal but its dependencies fail with "ghc version >=6.4 is required but it could not be found", while I have 6.10.4. Most other dependencies build fine.
19:24:41 <dankna> I've never used it, I fear
19:28:15 <SamB_XP> PlotDevice: what OS ?
19:28:20 <SamB_XP> and arch?
19:28:50 <siracusa> PlotDevice: Is it really Yi causing this problem or a dependency package?
19:31:55 <PlotDevice> Win32, not Yi itself.
19:32:11 <PlotDevice> For example, regex-base fails with that error.
19:33:00 <SamB_XP> PlotDevice: Win32 is the OS or the package?
19:33:11 <ManateeLazyCat> Fuck, all Google domain filter by China GFW, fuck!
19:33:18 <PlotDevice> Win32 is the os, package is regex-base.
19:33:21 <ManateeLazyCat> Damn GFW!!!
19:33:26 <SamB_XP> ManateeLazyCat: hmm ?
19:33:31 <PlotDevice> Fails with a compiler version "mismatch".
19:34:04 <ManateeLazyCat> SamB_XP: I need use special tool to around GFW, otherwise i can't use my Google!!!
19:34:28 <SamB_XP> oh, GFW == great firewall
19:34:29 <ManateeLazyCat> Damn China Government!!!
19:34:29 <SamB_XP> right
19:34:41 <ManateeLazyCat> I'm so angry
19:35:16 <ManateeLazyCat> SamB_XP: Yesterday, Google exit China, today all Google domain is filter by GFW, you can search anything, even Haskell.
19:35:21 <Fallen_Demon> Ok, confused as hell
19:35:33 <Fallen_Demon> Trying to get back into haskell
19:35:41 <Fallen_Demon> So mucking around with basic functions
19:35:52 <aavogt> PlotDevice: get the yi from it's darcs repo
19:35:54 <Fallen_Demon> How do I type cast from a Fractional Int to and Int?
19:36:19 <aavogt> PlotDevice: when in the repo, run     cabal install --constraint="template-haskell >= 2.4"
19:36:51 <aavogt> but maybe the misbehaving dependencies that need that constraint (data-accessor-template) have since changed
19:37:09 <aavogt> Fallen_Demon: Fractional Int =>   is a constraint that cannot be satisfied
19:37:17 <Fallen_Demon> Dammit >_<
19:37:24 <aavogt> it means you are ex. dividing two IntS with /
19:37:40 <Fallen_Demon> Ok, so what're my options?
19:37:54 <Fallen_Demon> Is there a function I can use to get around it?
19:37:55 <aavogt> when / is for fractional division, maybe you want   `div`   or    fromIntegral x / fromIntegral y
19:38:04 <aavogt> where x and y are Ints
19:38:09 <Fallen_Demon> Ah, Sweet :)
19:38:11 <Fallen_Demon> Thanks
19:38:19 <PlotDevice> It looks like it might be a completely different problem. Regex-base fails to install even when I try to get it alone. What does it mean when a package fails during the configure step?
19:38:42 <Fallen_Demon> aavogt, worked like a charm, thanks mate :)
19:39:10 <aavogt> PlotDevice: which yi are you trying to build?
19:39:44 <PlotDevice> Right now, none. I want to figure out why cabal packages are not installing properly. =/
19:39:54 <aavogt> anyways, paste the whole error somewhere if you're still having trouble
19:40:31 <aavogt> I dunno, I have ghc-6.12.1 and regex-base-0.93.1 installed too
19:41:15 <SamB_XP> PlotDevice: what does ghc-pkg list tell you ?
19:45:41 <Fallen_Demon> Wow, first years this year have nothing to complain about...
19:53:56 * Mathnerd314 nominates #haskell for most quiet channel
19:54:21 <c_wraith> shh.  your nomination is disturbing the tumbleweeds
19:54:38 <SamB_XP> quietest per capita, maybe ;-P
19:55:04 <dankna> quiet per capita, haha
19:55:05 <dankna> perhaps so
19:55:17 <dankna> why ARE there so many people in here who have no intention of saying anything? :)
19:55:33 <SamB_XP> just trying to soak up the "smart"?
19:55:38 <SamB_XP> or maybe they talk when I sleep?
19:55:40 <dankna> haha, that's the only explanation I can find
19:56:25 <dankna> my personal logfile for this channel is 39M and that's only for periods when I'm signed in and only back to 2007 (I have logs from other channels as far back as 1998)
19:56:34 <dankna> so yes, it's pretty talkative in here in absolute terms
19:56:49 <aavogt> @type \a b c d e f g -> f g a b c d e
19:56:51 <lambdabot> forall t t1 t2 t3 t4 t5 t6. t -> t1 -> t2 -> t3 -> t4 -> (t5 -> t -> t1 -> t2 -> t3 -> t4 -> t6) -> t5 -> t6
19:57:20 <dankna> a poem?  haha
19:57:21 <SamB_XP> yes, my logs are starting to show on windirstat too ...
19:57:28 <dankna> amusement
19:57:38 <SamB_XP> ... kinda wish x-chat had log rotation and compression
19:57:42 <dankna> agreed
19:57:43 <dankna> well
19:57:46 <dankna> you could run logrotated on it
19:58:01 <Mathnerd314> couldn't you just read the ones online?
19:58:04 <dankna> and it DOES have a feature to put the date in the filename
19:58:05 <SamB_XP> yeah, yeah, I'm sure that's ported to win32
19:58:10 <SamB_XP> true
19:58:22 <dankna> eh?  of course it is.  via your choice of cygwin or mingw.
19:58:34 * Mathnerd314 <3 mingw
19:58:54 * dankna >3 mingw
19:59:21 <Mathnerd314> keep forgetting my shortcuts...
19:59:23 * dankna 8 mingw, rather
19:59:26 * Mathnerd314 ‚ô° mingw
19:59:30 <SamB_XP> was it tasty ?
19:59:35 <aavogt> > (<3) mingw
19:59:36 <lambdabot>   False
19:59:45 <SamB_XP> lol
19:59:49 <dankna> what encoding is that in, Mathner?  I'm using utf-8 on this end so I couldn't see whatever special character you tried to type
19:59:49 <SamB_XP> > mingw
19:59:51 <lambdabot>   Not in scope: `mingw'
19:59:55 <dankna> yes, it was tasty
20:00:04 <SamB_XP> why do you people DO that?
20:00:09 <Mathnerd314> dankna: no idea...
20:00:15 <aavogt> do what?
20:00:21 <ddelony> I was going to learn me a Haskell some more, but I'm full of Indian food.
20:00:36 <p_l> dankna: UTF-8. Your font just doesn't include the char
20:00:36 <SamB_XP> stick these names in scope and then @unlet before I get a chance to try to see their values!
20:00:39 <pikhq> ddelony: Best time to learn you a Haskell.
20:00:43 <dankna> oh.  well, what char was it?
20:00:45 <pikhq> Curry aids these things greatly.
20:00:59 <dankna> yeah, XChat Aqua is woefully outdated and doesn't support proper font sets :(
20:01:02 <Mathnerd314> u2661
20:01:12 <SamB_XP> dankna: an empty heart
20:01:23 <dankna> ah cool cool :)
20:01:39 <dankna> I see it now, in the character viewer
20:02:03 <dankna> did you know there's a proposal on the table to add about 800 emoticons to Unicode?
20:02:25 <Mathnerd314> they're not there already?
20:02:29 <dankna> apparently there are three major private-use encodings of these in Japan, with the three major cell-service providers there
20:02:43 <dankna> and it's getting to be burdensome that there's no reconciled encoding
20:03:06 <dankna> so there's actually a case that the Unicode Consortium will listen to for encoding these entirely frivolous characters :)
20:03:30 <SamB_XP> dankna: wow
20:03:34 <dankna> yeah
20:03:37 <pikhq> Unicode does not know the meaning of "frivolous".
20:03:50 <SamB_XP> and I thought Japan had already provided us with such a bounty of largely decorative characters!
20:03:51 <dankna> hush!  there are serious scholars who need those Elvish codepoints!
20:03:59 <SamB_XP> you know, from JIS
20:03:59 <dankna> SamB: I know, right?  ahahah
20:04:04 <dankna> yeah, I know those ones
20:04:19 <pikhq> The only reason they denied the addition of Klingon script is because Klingon speakers used ASCII.
20:04:26 <SamB_XP> I actually like that, if it isn't obvious
20:04:30 <ddelony> Typing in examples in programming tutorials helps me the most.
20:04:34 * dankna ? ?
20:04:35 <SamB_XP> pikhq: seriously ?
20:04:38 <pikhq> Literally "If you guys actually used this script, it would be in."
20:04:41 <pikhq> SamB_XP: Yes.
20:04:44 <SamB_XP> okay.
20:04:53 <dankna> pikhq: interesting.  I can see their point.
20:05:02 <aavogt> well is there a shortage of codepoints?
20:05:05 <dankna> yeah, I like having these fun characters too
20:05:07 <pikhq> aavogt: No.
20:05:09 <dankna> it's true that there's no shortage of them
20:05:23 <SamB_XP> what are there, 2^24 of them ?
20:05:24 <dankna> there's very little downside to encoding these things... it doesn't create any sort of obligation on font vendors
20:05:29 <pikhq> The Unicode Consortium will assign characters if there is sufficient use of them to merit having it.
20:05:32 <dankna> no, you can go as high as six bytes
20:05:44 <SamB_XP> dankna: isn't that just UTF-8 ?
20:05:55 <dankna> hrm
20:05:56 <dankna> maybe
20:06:05 <SamB_XP> actually ...
20:06:12 <SamB_XP> > maxBound :: Char
20:06:13 <lambdabot>   '\1114111'
20:06:15 <dankna> right
20:06:19 <dankna> that looks familiar
20:06:28 <SamB_XP> and take out all the UTF-16 surrogates, too
20:06:30 <dankna> @hoogle hex
20:06:30 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
20:06:30 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
20:06:31 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
20:06:41 <dankna> @more
20:06:52 <ddelony> I'm coming from Python. Is Haskell picky about whitespace? Doesn't seem like it so far.
20:07:03 <dankna> not compared to Python, no
20:07:10 <dankna> > showHex (maxBound :: Char)
20:07:11 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
20:07:11 <lambdabot>    arising from a use of...
20:07:17 <SamB_XP> it's whitespace sensitive, but fairly liberal
20:07:17 <dankna> > showHex $ ord (maxBound :: Char)
20:07:18 <lambdabot>   ""->
20:07:19 <lambdabot>    "10ffff"
20:07:19 <lambdabot>  "a"->
20:07:19 <lambdabot>    "10ffffa"
20:07:19 <lambdabot>  "aa"->
20:07:20 <lambdabot> [3 @more lines]
20:07:39 <dankna> huh?  why did that produce so much output?  oh, I meant to take head of it I guess
20:07:59 <dankna> > showHex (ord (maxBound :: Char)) ""
20:07:59 <lambdabot>   "10ffff"
20:08:01 <dankna> yeah
20:08:10 <ddelony> SamB_XP: Thanks.
20:08:32 <dankna> anyway that's somewhat over two and a half bytes
20:08:37 <Veinor> :t showHex
20:08:38 <lambdabot> forall a. (Integral a) => a -> String -> String
20:08:52 <Veinor> ... what's the String for?
20:09:03 <Veinor> ah,
20:09:04 <dankna> read up on the ShowS type
20:09:27 <glguy_> > foldr showHex "" [8..12]
20:09:28 <lambdabot>   "89abc"
20:09:44 <SamB_XP> dankna: the SmallCheck Show instance kicked in, yeah ;-P
20:09:49 <dankna> heh okay
20:11:41 <ddelony> I do think pattern matching is neat. The cleanest way I've seen to implement a multi-way decision.
20:11:58 <dankna> I concur fully
20:12:10 <Mathnerd314> what about overloading?
20:12:11 <monochrom> I'm fully concurrent
20:12:19 * dankna chortles
20:12:25 <Mathnerd314> (or does it look too much like pattern matching)
20:12:26 <dankna> monochrom: well played
20:19:30 <Mathnerd314> say, are there any languages with good support for coroutines?
20:19:31 <superoptimizer> :type add
20:21:49 <tensorpudding> Go claims to have such.
20:22:26 <ddelony> Implemented a Fibonacci function!
20:22:34 <tensorpudding> :type (+) -- superoptimizer ?
20:22:43 <tensorpudding> err, that doesn't work
20:22:49 <tensorpudding> :type (+)
20:22:53 <monochrom> @type (+)
20:22:54 <lambdabot> forall a. (Num a) => a -> a -> a
20:22:57 <monochrom> :t (+)
20:22:58 <lambdabot> forall a. (Num a) => a -> a -> a
20:23:04 <tensorpudding> damn, right
20:23:06 <monochrom> It is rather inconsistent.
20:23:13 <tensorpudding> I got fooled.
20:23:18 <ddelony> Here it is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24306#a24306
20:23:51 <monochrom> It is slow. It is also too special, i.e., type Int.
20:23:54 <superoptimizer> ignore me. i'm just messing around in ghci and accidentally typed that into the wrong window
20:24:16 <monochrom> Very few fibonacci numbers fit in Int.
20:24:28 <tensorpudding> also, it'll go into an infinite loop on negative arguments
20:25:06 <edwardk>  @seen sbahra
20:25:13 <ddelony> monochrom: But not bad for a first try, right?
20:25:14 <tensorpudding> unless the input is a bounded Int or a Word
20:25:29 <ddelony> I just changed the Int to a.
20:25:52 <monochrom> You can have in fact (Integral a, Integral b) => a -> b
20:25:55 <tensorpudding> Actually, the input will default to whatever the type of the output is to be
20:26:03 <superoptimizer> Mathnerd314: on coroutines, see the wikipedia entry: http://en.wikipedia.org/wiki/Coroutine#Programming_languages_supporting_coroutines
20:26:10 <tensorpudding> or, no
20:26:15 <tensorpudding> nevermind
20:26:24 <superoptimizer> I've been thinking about implementing a small experimental language support coroutines myself.
20:27:47 <ddelony> My function is slow on bigger numbers.
20:28:34 <tensorpudding> that function has very poor asymptotic behavior
20:29:42 <tensorpudding> because the number of recursions increases very quickly as n increases
20:30:37 <ddelony> tensorpudding: I see. I've trying to google other Fibonacci algorithms.
20:30:41 <tensorpudding> you can crutch it a bit with memoization, though that won't work when you run out of stack space
20:31:34 <monochrom> need only "memoize" two recent entries.
20:31:45 <ddelony> Or maybe a hardware optimization. ;-)
20:32:50 <tensorpudding> a lookup table could make sense
20:33:09 <ddelony> tensorpudding: Well, I guess I've got an ongoing project.
20:35:01 <tensorpudding> if you didn't need absolute accuracy, you could use the golden ratio function
20:35:24 <tensorpudding> i forget what the formula is called, binet's formula?
20:35:46 <superoptimizer> if you want to see slow, try ackermann's function
20:36:24 <tensorpudding> yeah
20:36:50 <monochrom> Just read http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
20:42:42 <superoptimizer> are n+k patterns commonly used in haskell?
20:42:57 <tensorpudding> Aren't n+k patterns deprecated?
20:43:04 <Mathnerd314> I think they got removed...
20:43:20 <superoptimizer> oh, from 2010?
20:43:24 <monochrom> not commonly used
20:43:32 <tensorpudding> There was a proposal to remove them.
20:44:03 <Mathnerd314> yeah: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
20:52:19 <kmc> er, "goroutines" are not anything like coroutines
20:52:28 <kmc> they are threads.
20:52:54 <kmc> but the word "thread" is associated with "giant pain in the ass" so they had to choose a different name
20:52:58 <kmc> we have the same problem
20:54:17 <kmc> Python supports coroutines directly via "yield", see http://www.python.org/dev/peps/pep-0342/
20:54:52 <dankna> kmc: btw, thank you for your help yesterday on the SQL model.  I took your L0 L1 suggestion and am just now putting the finishing touches on my 1700-line model :)
20:54:52 <kmc> Haskell programs are full of implicit coroutines.  the composition of a lazy list consumer and a lazy list producer is in effect a coroutine
20:54:56 <kmc> cool :)
20:59:03 <monochrom> moar yields: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356
21:00:03 <siracusa> From n+k patterns: `the symbol + is being abused in the syntax. It doesn't really mean +' - What does this mean?
21:01:23 <monochrom> It means syntax does not tell you semantics.
21:02:34 <aavogt> > let f (x+1) = x in f 1
21:02:35 <lambdabot>   0
21:02:58 <aavogt> > let f (1+1) = 1 in f 1
21:02:59 <lambdabot>   <no location info>: Parse error in pattern
21:03:24 <siracusa> Oh I see
21:03:36 <monochrom> You write code ¬´f (n+10) = blahblah¬ª. I call it with ¬´f 94¬ª. What will happen? Subtraction will happen. No addition will happen. + does not cause addition to happen. Syntax does not tell you semantics. Syntax is deliberately malicious.
21:05:26 <aavogt> well it's like writing an equation and then the constant term is moved to the other side
21:06:23 <kmc> view patterns are more explicit and way more general
21:07:33 <aavogt> view patterns are weird with repeated computations
21:09:39 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24309#a24309
21:09:44 <dankna> Is there a way to simplify StatementList?
21:10:00 <dankna> it irks having to export those L0NTNS constructors for StatementListItem and explain them to my users
21:10:42 <dankna> I mean I suppose one workaround is to create a complete suite of list-processing functions that operate on these lists, so that the user will have no need for the StatementListItem constructors...
21:21:47 <superoptimizer> @src foldl
21:21:47 <lambdabot> foldl f z []     = z
21:21:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:26:23 <superoptimizer> Is there a filter-like function that filters values out rather than in?
21:27:46 <bos> > filter isUpper "Why Would You Want That?"
21:27:47 <lambdabot>   "WWYWT"
21:27:53 <bos> > filter (not isUpper) "Why Would You Want That?"
21:27:54 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:27:54 <lambdabot>         against inferred type ...
21:28:00 <bos> > filter (not . isUpper) "Why Would You Want That?"
21:28:02 <lambdabot>   "hy ould ou ant hat?"
21:29:02 <bos> superoptimizer: ^^^
21:29:09 <aavogt> > concatMap (\x -> if isUpper x then [x,x] else [x]) "Would You Be Looking for Something like concatMap?"
21:29:09 <lambdabot>   "WWould YYou BBe LLooking for SSomething like concatMMap?"
21:30:17 <superoptimizer> No. I hadn't seen '.' before, and had to look it up. Thanks. Very new to Haskell. Working my way 10-15 pages at a time through RWH.
21:33:45 <dankna> I pasted this about ten minutes ago but no response.  I hope it's not rude, but I'm going to paste it again... :)
21:33:55 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24309#a24309
21:34:12 <dankna> I would like it if I could construct a list-like type containing the various subtypes of Statement
21:34:34 <dankna> without having to have those "marker" constructors L1NTNS, L0NTNS, L0TNS, L0TS
21:35:22 <dankna> Ideally I want to be able to do StatementList [Select ..., Update ..., Insert ...], where Select, Update, and Insert are all constructors of Statement
21:35:31 <dankna> I understand why I can't as things stand: with GADT they are separate types
21:37:00 <aavogt> dankna: because it's a difficult question?
21:37:04 <dankna> haha
21:37:07 <dankna> that's fair enough
21:37:19 <adu> what?
21:37:29 <aavogt> what do you do with the subtypes of this Statement?
21:37:44 <dankna> for a similar problem yesterday which it ultimately turned out I didn't have to solve after all, somebody mentioned that there were two choices - higher rank types and existential quantification - and that I'd have to think carefully about which to use
21:37:45 <aavogt> you can erase your phantom types before putting stuff in a list
21:37:50 <dankna> hmm
21:38:07 <dankna> well, I pattern-match on them, I serialize them into strings, I parse them out of strings
21:38:16 <dankna> was that what you were asking?
21:38:28 <dankna> I don't need to pattern match on them while they're contained in a list, I'm fine with having to get them out of the list before I can do that
21:39:45 <dankna> I wasn't aware that I was using phantom types.  Is that what those types without constructors are called?
21:41:36 <aavogt>   [(forall l t v. Statement l t v -> r) -> r] is apparently an edwardk thing to do for existentials (I have yet to try it out though)
21:41:45 <dankna> haha, I see.... hmmmm
21:42:42 <aavogt> well you will have issues parsing them out of strings if you don't know what type they have to begin with....
21:43:04 <aavogt> or can your specific constructors in Statement restrict the types?
21:43:20 <dankna> the specific constructors do restrict the types
21:43:28 <dankna> each constructor has only a single type
21:43:43 <dankna> for example, Select is :: blah -> blah -> blah -> Statement L0 T S
21:44:44 <dankna> the purpose is of course to limit where it can occur, with each of the three flags being used to indicate whether it can occur in a different particular type of context
21:44:57 <dankna> and that aspect of it works fine, I can't construct anything invalid :)
21:45:07 <dankna> and can construct everything valid, according to informal tests
21:45:35 <dankna> but there's this one context, StatementList, that actually needs to allow everything, and that's a bit finicky, heh
21:46:23 <aavogt> HLists?
21:46:30 <dankna> looking those up now
21:46:42 <aavogt> they are kind of awkward sometimes
21:47:58 <dankna> I'm skimming the HList package docs.  It looks like overkill, but if I need it I need it.
21:48:24 <dankna> I'm not sure how I would use the forall thing you mentioned above, could you explain that in a little more detail so I can figure out whether it meets my needs?
21:49:09 <dankna> oh, and thanks for your time, by the way :) I should probably have said that first
21:52:28 <aavogt> dankna: what kind of pattern matching do you do on them when they are in the list?
21:52:49 <dankna> as I said, I'm okay with not pattern-matching on them while they're in the list - with having to extract them from the list before I can do that
21:54:33 <dankna> this is because most of the interesting things like automated query building are done on the level of individual statements and smaller, not on the multiple-statement level
22:00:06 <Nafai> Hey jeffwheeler
22:00:50 <jeffwheeler> Hey, Nafai.
22:01:22 <aavogt> dankna: you use that forall to hide the type variables l t v, exposing some common type(s) all together in the 'r'
22:02:16 <aavogt> so say all your Statements support being showed as a string, then r can be a String
22:02:19 <dankna> hrm
22:02:33 <dankna> well, they all support being turned into a sequence of tokens
22:03:28 <aavogt> but that's all you can do with that type then
22:04:11 <dankna> yeah, that's somewhat limiting.  I'd like to be able to go from my list-like type back to individual Statements, somehow...
22:07:58 <kevinulin> I am still a monad novice, can someone tell me what "generateKeyPair :: RandomGen g => g -> Int -> (PublicKey, PrivateKey, g)" means as a type definition, particularly the part "GrandomGen g => g" or at least what the concept is called so I can read about it online?
22:08:28 <aavogt> that's no monad
22:08:47 <kevinulin> well i am a novice to whatever it is about :)
22:08:48 <aavogt> RandomGen is a typeclass
22:09:19 <kevinulin> ok so start with typeclasses, thanks
22:09:37 <aavogt> it means that the type  g   supports a bunch of operations with whatever types given where that class is defined
22:10:04 * edwardk hears his name call out to him.
22:10:34 <edwardk> dankna: you can typically avoid full hlists
22:10:45 <dons> ?yow
22:10:45 <lambdabot> Couldn't find fortune file
22:10:49 <kevinulin> oh i mean i should start with that, just curious what i had to google, googling "=>" is less thank helpful :)
22:11:02 <edwardk> dankna: several lines of type families and you have a usable type level list
22:12:09 <dankna> yeah hmmmm
22:12:13 <dankna> I thin I may have just found a solution
22:12:18 <dankna> using existential quantification
22:12:23 <dankna> I'll hpaste it in a sec and ask about drawbacks :)
22:12:34 <dankna> it seems remarkably simple for the complexity of the question
22:13:02 --- mode: ChanServ set +o Pseudonym
22:13:02 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24309#a24310 possible solution added as annotation
22:13:06 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/", "RIP Robin Milner"]' by Pseudonym
22:13:10 --- mode: ChanServ set -o Pseudonym
22:13:19 * dankna doesn't think Pseudonym is his real name!
22:13:26 <Pseudonym> Damn, I've been caught!
22:13:29 <dankna> hehe
22:13:52 <Pseudonym> I have never heard that joke before and, most crucially, nor have I ever delivered it!
22:14:05 <dankna> For some reason my sarcasm detector just burned out.
22:14:21 <Pseudonym> The good news is, BTW, J. Roger Hindley is still alive.
22:14:25 <dankna> I can't imagine why.
22:14:34 <dankna> Ah - yes, that is good news.  Tragic about Milner of course.
22:16:20 <dankna> see, I'm fine with having the extra constructor Statement in there
22:16:39 <dankna> I just didn't want to have FOUR extra constructors and have to document to the user which types of statements went with which constructors
22:17:15 <dankna> I guess I didn't do a great job of explaining that, but then, that solution didn't occur to me until it did, so I couldn't say "... this solution would be okay"
22:17:30 <Pseudonym> We should all infer a principal type in his honour.
22:17:33 <dankna> anyway I thank everyone for their time, especially aavogt
22:18:07 <dankna> the generator half of my SQL generator-parser is now complete, and only representations of valid SQL can be constructed.  I think that's pretty cool.
22:18:17 <dankna> heh, I have.... no idea what inferring a principal type is, but okay :)
22:18:20 <dankna> just tell me where to sign :)
22:26:15 <edwardk> hrmm. preference question: i have a few types i can play with for branded ropes vs. annotated ropes vs. unsafe ropes
22:26:45 <edwardk> (s `Branded` Rope) a  -- s `BrandedRope` a -- Branded s a -- etc.
22:26:55 <edwardk> similarly
22:27:24 <edwardk> (f `Annotated` Rope) s -- f `AnnotatedRope` s -- Ann s f
22:27:50 <edwardk> i know the penchant in the haskell community for brevity, just not sure it applies well here
22:28:03 <aavogt> braided?
22:28:08 <edwardk> otoh, i don't want to layer types 5 layers deep before you get to anything
22:28:09 <edwardk> branded
22:28:34 <edwardk> as in carrying a type level 'brand' that can be used in unification to keep you from doing bad things
22:29:17 <aavogt> so this data is like Data.Sequence, but more data in each node of the tree?
22:29:18 <edwardk> "Branded" is called "A" in this source: http://comonad.com/haskell/rope/dist/doc/html/rope/Data-Rope-Annotated.html
22:29:48 <edwardk> Data.Rope is a very efficient Data.Sequence Word8 using that machinery, yeah
22:30:10 <edwardk> Data.Rope.Annotated is a lot more
22:31:20 <edwardk> but I want a better name for the constructor than 'A'
22:31:39 <edwardk> data A s a = A !Rope a -- ignoring the 's' that exists purely as a brand
22:31:51 <edwardk> so the first option that leaps to mind is
22:32:05 <edwardk> data Branded s t a = Branded !t a
22:32:24 <edwardk> or data BrandedRope s a = ...
22:32:52 <edwardk> Branded s t is a comonad regardless of the choice of t.
22:34:05 <edwardk> type Ann a f = A a (f a) -- is a wrapper to pass the same type level brand to both the comonad and the contents of the comonad.
22:34:17 <edwardk> think of it like the ST s monad, used for the same reasons
22:34:51 <edwardk> you build up a bunch of inhabitants of your comonad using comonadic actions over a particular underlying rope, and you don't want people to accidentally use the annotations on the wrong comonad.
22:35:38 <edwardk> In A a (f b) where b != a, the annotations are basically useless, but you can fmap them into the comonad, you can 'extract' them out, etc.
22:35:44 <edwardk> the brand is the only source of safety
22:36:25 <edwardk> letting me avoid the 'OI' problem from back when folks first proposed using comonads for general purpose haskell io
22:36:52 <edwardk> er. did that make any sense?
22:37:41 * aavogt is still trying to absorb
22:38:20 <edwardk> well, take IO for instance
22:38:38 <edwardk> nothing keeps you from having an IO action in one thread from generating an action to be run by another
22:39:51 <edwardk> with any functor in haskell you can always dumb that value in any functor you have lying around. fmap (const theThingIWantInThere) (whateverFunctorIwantToScrubOut)
22:39:52 <aavogt> I get the analogy to ST
22:40:16 <BMeph> edwardk: It works for me; I'm glad you're doing something to get comonads out into the hands of hoi polloi. ;)
22:41:06 <edwardk> bmeph: saying the question is saying:  "(f `Annotated` Rope) Unsafe -- or Annotated f Rope Unsafe too offputting when i could use a shorter name?
22:41:32 <edwardk> er the question is, is saying ....
22:42:07 <edwardk> BMeph: i had a more principled version that used comonads extensively in the back end definition for your annotations
22:42:19 <edwardk> unfortunately, i couldn't write myself out of the corner i found myself in
22:42:33 <edwardk> and that version had to do a little more work
22:44:45 <edwardk> cons :: (ReducerA f, Reducer t Rope) => (f `Annotated` Rope) a -> t -> (forall c. (f `Annotated` Rope) (Cons c t a) -> r) -> r -- may be going a bit too far
22:45:01 <edwardk> which is why i'm looking at the 'Unsafe' module for when you know you're mangling your bytestring all over the place
22:45:08 <edwardk> then I can avoid the cps'd code
22:45:23 <edwardk> and cons dumbs down to
22:45:31 <edwardk> cons :: (ReducerA f, Reducer t Rope) => (f `Annotated` Rope) a -> t -> (f `Annotated` Rope) Unsafe
22:46:15 <edwardk> which is closer to the Data.Rope: cons :: (t `Reducer` Rope) => t -> Rope -> Rope
22:48:41 * BMeph ponders ponderously...
22:50:52 <edwardk> type (f `Annotated` t) b = (b `Branded` t) (f b) -- where b `Branded` t is a comonad, so annotated looks kind of like a comonad over that 'f' argument that has kind * -> *, but definitely shouldn't be a functor
23:10:35 <edwardk> i compromised. i went for the (s `Branded` t) a -- but the annotated versions only make sense on ropes, and are more common, so they are 'Ann f a' for an annotated rope with annotation f, brand 'a'
23:19:10 <dancor> why isn't there Ord ProcessHandle
23:19:28 <dancor> i want to track child processes with a Set
23:19:53 <aavogt> @hoogle ProcessHandle
23:19:54 <lambdabot> No results found
23:22:53 <Sgeo> Is it just me, or is haskell.org being slow?
23:23:40 <dancor> Sgeo: same here
23:24:12 <dankna> same here
23:27:15 <dancor> w
23:29:09 <Nafai> I think the platform release must be really popular because any access to haskell.org has been particularly slow the last couple of days
23:29:33 <dankna> there is a torrent of it, incidentally
23:29:44 <dankna> at least, I made one of the Mac version
23:30:06 * glguy_ glares at those that download during the day (PDT)
23:30:07 <pippijn> where is it?
23:30:08 <dankna> http://dankna.com/himitsu/haskell-platform-2010.1.0.0-i386.dmg.torrent
23:30:10 <pippijn> ah
23:30:39 <dankna> and yeah, I wouldn't doubt that it's popular
23:32:08 <pippijn> the torrent is not very fast
23:32:14 <pippijn> I'll be seeding it for a while
23:32:37 <BMeph> Time to bed down for the night: good night! :)
23:33:36 <dankna> indeed it's not very fast, I think it's just me and one other person seeding, so it's definitely good if you seed it too
23:34:30 <dankna> ah here you go.  for some reason it had stopped seeding for me.
23:35:28 <dankna> that half a meg per second connection you're seeing is me :)
23:39:59 <Sgeo> Why does http://hackage.haskell.org/platform/ look new?
23:40:13 <ddarius> Grr, the arrows of a comma category are commutative squares.  Haskell won't come close to hacking it.
23:41:43 <dankna> Sgeo: because it is.  release was yesterday.
23:42:10 <Sgeo> On the Windows page, it says 2009
23:42:20 <Sgeo> :(
23:44:19 <dankna> yeah :( that one isn't ready yet
23:45:21 <Sgeo> :(:(:(
23:45:28 <Sgeo> What's new in the new Platform/
23:45:29 <Sgeo> ?
23:45:37 <dankna> GHC 6.12.1
23:45:59 <dankna> on Mac, it's big news because a) there was not previously a binary distro of that version at all, and b) it's the first to support 64-bit
23:46:08 <dankna> also new versions of all the packages
23:46:19 <Sgeo> And what's new in that? I'm somewhat on shaky ground when it comes to Haskell, and have waay too little practise
23:46:29 <dankna> that's fair
23:46:34 <dankna> well, I don't know - a lot of things
23:46:37 <dankna> a lot of extensions
23:46:39 <dankna> better performance
23:46:44 <dankna> it's a new major release
23:47:01 <dankna> there's probably a changelog on haskell.org somewhere
23:53:55 <pippijn> oooh haskell goes shiny!
23:54:43 <dankna> hehe
