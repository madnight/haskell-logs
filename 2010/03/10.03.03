00:00:15 <lhames> I'm still taking Haskell in, so I don't know good code from bad yet.
00:00:25 <SnailRacer> um, yes??
00:00:30 <lhames> Heh.
00:01:00 <decker> so how about this warning?  I don't really understand it:  http://fpaste.org/qGUz/  because I turned mylength into a Double?  throwing 1.0 and 0.0 in doesn't make the warning go away.
00:02:13 <pastorn> decker: "1" ==> "(1 :: Double)"
00:02:21 <pastorn> and the some for the 0
00:02:28 <pastorn> that might work
00:02:28 <pheaver> no it's not the 0
00:02:35 <pheaver> it's the [1,2,3,4] list that he passed to mylength
00:02:57 <pheaver> mylength ([1,2,3,4] :: [Int]) is one way to get rid of the warning
00:03:25 <pastorn> seems like an awefully weird error
00:03:26 <pheaver> has nothing to do with the return type of mylength, the Double
00:03:27 * hackagebot uri 0.1.2 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.2 (JaroslavGridin)
00:03:32 <pastorn> *warning*
00:03:36 <pheaver> it's just defaulting
00:03:50 <lhames> decker: Your fpaste example works for me.
00:03:52 <lhames> I'm using GHC 6.10.4
00:04:03 <pheaver> lhames: yes it *works*, but it gives a warning (with -Wall that is)
00:04:22 <lhames> pheaver: Ahh. Thanks.
00:04:26 <pheaver> :)
00:05:10 <lhames> Oh dear. I shudder to think what's going to happen when I turn Wall on in my makefile now...
00:05:46 <roboshibby> this is how i program: http://www.youtube.com/watch?v=1uPznTbus3g&feature=related
00:05:52 <lhames> Not as awful as I expected.
00:06:27 <pheaver> lhames: heh :)
00:09:29 * hackagebot hellnet 0.1.1 - Simple, distributed, anonymous data sharing network.  http://hackage.haskell.org/package/hellnet-0.1.1 (JaroslavGridin)
00:14:17 <sinelaw> roboshibby, heh that's pretty amazing
00:14:34 <roboshibby> yea, he does my taxes
00:17:33 <Adamant> Clutch goes surprisingly well with unicycling... probably the work of The Greys.
00:18:50 <roboshibby> is that the name of the band? clutch?
00:19:21 <sinelaw> and where are the monads in all this?
00:19:37 <roboshibby> it's the wheel
00:20:49 * sinelaw goes to read about alloca
00:22:14 <roboshibby> what's alloca?
00:23:03 <Cale> alloca :: Storable  a => (Ptr  a -> IO  b) -> IO  b
00:23:09 <Cale> alloca  f executes the computation f, passing as argument a pointer to a temporarily allocated block of memory sufficient to hold values of type a.
00:23:09 <Cale> The memory is freed when f terminates (either normally or via an exception), so the pointer passed to f must not be used after this.
00:23:27 * copumpkin says something about wanting to prevent escapage of the Ptr via that b
00:24:00 <SnailRacer> YamlReference didn't build =( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23198#a23198
00:25:30 <Cale> copumpkin: That's pretty hard, seeing as Ptr values can be turned into integers.
00:25:44 <sinelaw> so how's this normally used?
00:25:49 <copumpkin> Cale: why is that legit?
00:25:57 <copumpkin> we should be stricted!
00:26:00 <Cale> It's FFI
00:26:01 <copumpkin> *stricter
00:26:18 <copumpkin> pff
00:26:21 <Adamant> roboshibby: yup
00:26:28 <copumpkin> pffi
00:26:46 <Cale> sinelaw: alloca $ \x -> do ... stuff which uses the pointer x ...
00:26:48 <copumpkin> even gcc warns you about treating ints as ptrs and vice versa
00:26:59 <Cale> copumpkin: Well, you have to do it explicitly
00:27:05 <copumpkin> yep
00:27:16 <Cale> ptrToIntPtr
00:28:03 <copumpkin> so IntPtr could also have a universally quantified phantom type attached to it
00:28:08 <sinelaw> does ghc 6.12 support haskell-2010 ? (meaning, no need to specify some of the extensions?)
00:28:15 <Cale> You could also pass the pointer into a C function, and then accidentally have that C function stash it somewhere and do some stuff with it later.
00:28:21 <copumpkin> but I guess it also can get converted
00:28:23 <copumpkin> *sigh*
00:28:35 <copumpkin> screw the outside world
00:28:37 <copumpkin> it's dirty and mean
00:28:46 * copumpkin wraps himself in his padded room of purity
00:29:16 <sinelaw> ultimate escapism
00:32:03 <Saizan> SnailRacer: how are you building it? "cabal install YamlReference" works here
00:33:12 <SnailRacer> yeah, that was what I did... GHC 6.10.1, might be versions or something
00:33:53 <SnailRacer> lot of stuff doesn't work in Windows that works fine in *nix
00:34:13 <Saizan> that applies on C bindings, mostly
00:34:23 <Saizan> however cabal --version ?
00:35:04 <SnailRacer> using version 1.6.0.2 of the Cabal library
00:36:57 <Saizan> i'd "cabal install "cabal-install >= 0.8"" and retry "cabal install YamlReference" after that
00:38:05 <SnailRacer> cabal: There is no available version of cabal-install that satisfies >=0.8
00:39:09 <SnailRacer> I'd have to upgrade GHC first probably, but I'm waiting for HsGTK bindings
00:43:03 <Saizan> i think you just need a "cabal update" to fetch the index
00:46:02 <SnailRacer> ah that worked
00:46:29 <tredontho> is there an efficient way to take every possible pair from a (finite) list?  I have a solution, but it seems like for large lists, it won't perform very well
00:47:15 <c_wraith> It's inherently O(n^2).
00:47:23 <c_wraith> That won't perform well for large lists, no matter what
00:47:41 <tredontho> c_wraith: i should have dialed captain obvious first.  whoops
00:48:04 <c_wraith> Still, you looking for just distinct pairs, or all pairs?
00:48:17 <tredontho> just distinct pairs
00:48:29 <tredontho> so, if (x,y) is in there, i don't need (y,x)
00:48:49 <c_wraith> Oh.  That complicates things slightly
00:49:20 <c_wraith> But what about duplicates...  do you care about seeing a particular (x, y) twice?
00:50:04 <tredontho> i don't need (x,y) twice ever
00:50:23 <Saizan> > let xs = [1..3] in [(x,y) | (x:ys) <- tails xs; y <- ys ]
00:50:24 <lambdabot>   <no location info>: parse error on input `;'
00:50:31 <Saizan> > let xs = [1..3] in [(x,y) | (x:ys) <- tails xs, y <- ys ]
00:50:32 <lambdabot>   [(1,2),(1,3),(2,3)]
00:50:41 <Saizan> > let xs = 1:[1..3] in [(x,y) | (x:ys) <- tails xs, y <- ys ]
00:50:42 <lambdabot>   [(1,1),(1,2),(1,3),(1,2),(1,3),(2,3)]
00:51:23 <tredontho> that's so much easier to read
00:51:33 <c_wraith> doesn't eliminate all duplicates, hough
00:51:34 <tredontho> i got all tricky on myself with a do statement
00:51:35 <c_wraith> *though
00:51:44 <tredontho> well, that's fine
00:51:45 <tredontho> sorry
00:52:04 <c_wraith> :t join $ liftM2 (,)
00:52:05 <SnailRacer> YamlReference-0.9.3 failed while unpacking the package. The exception was: user error (Invalid file name in tar archive: "YamlReference-0.9.3\\tests\\c-flow-sequence.n=4.c=flow-in.::.input")
00:52:05 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
00:52:15 <tredontho> if (x,y) and (x1,y) are in there, and x happens to equal x1, that's fine
00:52:25 <SnailRacer> at least it's a shorter error
01:02:20 <SnailRacer> nub (\(x,y)->if (x<=y)then(x,y)else(y,x)) pairs
01:04:29 <SnailRacer> Well, I'm off.  Thanks Saizan, at least I've got a newer cabal =)
01:10:09 <sinelaw> @pl (\x,y) -> if (x<=y) then (x,y) else (y,x)
01:10:09 <lambdabot> (line 1, column 6):
01:10:09 <lambdabot> unexpected ")"
01:10:09 <lambdabot> expecting letter or digit, operator, ",", pattern or "->"
01:10:10 <sinelaw> @pl (\x,y) -> if (x<=y) then (x,y) else (y,x))
01:10:11 <lambdabot> (line 1, column 6):
01:10:11 <lambdabot> unexpected ")"
01:10:11 <lambdabot> expecting letter or digit, operator, ",", pattern or "->"
01:10:24 <sinelaw> @pl \(x,y) -> if x<=y then (x,y) else (y,x)
01:10:25 <lambdabot> uncurry (ap (ap . ap (ap . (if' .) . (<=)) (,)) (flip (,)))
01:10:29 <sinelaw> puke
01:11:01 <sinelaw> @pl \(x,y) -> min x y
01:11:01 <lambdabot> uncurry min
01:11:35 <sinelaw> @pl \(f,g) x -> (uncurry . f$ x, uncurry. g $ x)
01:11:35 <lambdabot> uncurry ((. (uncurry .)) . liftM2 ((,) . uncurry))
01:11:54 <sinelaw> @pl \x -> (uncurry . f$ x, uncurry. g $ x)
01:11:54 <lambdabot> ap ((,) . uncurry . f) (uncurry . g)
01:12:49 <sinelaw> i give up
01:13:18 <quicksilver> amazon-- # suggesting I buy jdh books
01:14:02 <quicksilver> sinelaw: uncurry min &&& uncurry max, perhaps?
01:14:12 <sinelaw> ah right
01:14:22 <quicksilver> > uncurry min &&& uncurry max $ (5,4)
01:14:23 <lambdabot>   (4,5)
01:14:26 <sinelaw> exactly.
01:14:32 <sinelaw> too bad pl doesn't know about &&&
01:14:43 <quicksilver> not sure how to add &&& in a way which is confluent
01:14:58 <sinelaw> pl is magic for me anyway
01:15:28 <Twey> Sorting pairs?
01:16:00 <Twey> > on (&&&) uncurry min max (5, 4)
01:16:01 <lambdabot>   (4,5)
01:16:15 <sinelaw> @hoogle on
01:16:15 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
01:16:15 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
01:16:15 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
01:16:27 <sinelaw> hoy
01:16:44 <c_wraith> on is another one of those functions @pl doesn't know about
01:17:16 <sinelaw> so many functions, so little time
01:17:28 <Twey> Heh
01:18:18 <sinelaw> how impossible is it for the compiler to optimize it so it doesn't compare the pair twice?
01:20:03 <mreh> here's an interesting question on finger trees: What is their space complexity like? I calculated 2^(log(n) +1)
01:20:23 <mreh> is there an identity to simplify that?
01:20:56 <Twey> sinelaw: Requires special-casing or supercompilation
01:21:34 <c_wraith> Err.  mreh, that doesn't sound right at all.
01:21:46 <c_wraith> oh, yeah it does
01:21:51 <c_wraith> that's O(n)
01:21:54 <c_wraith> give or take
01:22:01 <mreh> c_wraith: how did you come to that?
01:22:16 <sinelaw> 2^(log(n) + 1) = 2n
01:22:31 <sinelaw> if the log is base 2, otherwise multiply by a constant
01:22:32 <mreh> oh, okay, twice as big as an array then
01:22:35 <c_wraith> assuming you use log base 2
01:22:42 <mreh> c_wraith: of coures :)
01:22:59 <Twey> > join ((swap ?? id) . (== GT) . uncurry compare) (5, 4)
01:23:00 <lambdabot>   Not in scope: `swap'Not in scope: `??'
01:23:03 <Twey> Ack
01:23:09 <Twey> @let swap (a, b) = (b, a)
01:23:10 <lambdabot>  Defined.
01:23:16 <Twey> @let (y ?? n) p = if p then y else n
01:23:17 <lambdabot>  Defined.
01:23:18 <c_wraith> mreh: It's a number of nodes proportional to the number of elements, and some extra pointers.
01:23:20 <Twey> > join ((swap ?? id) . (== GT) . uncurry compare) (5, 4)
01:23:21 <lambdabot>   (4,5)
01:23:32 <Twey> sinelaw: That one only compares once
01:23:44 <mreh> c_wraith: uhuh
01:23:47 <c_wraith> mreh: so it's going to be O(n), obviously
01:23:53 <sinelaw> Twey, yeah but less legible
01:23:57 <Twey> A bit
01:24:01 <sinelaw> i'd like the compiler do the implemenation work
01:24:06 <Twey> Yeah
01:24:18 <sinelaw> implementation, even
01:24:21 <Twey> Get excited about supercompilation ☺
01:24:25 <c_wraith> I still wonder why supercompilation isn't present in all compilers.
01:24:33 <mreh> c_wraith, it's not so obvious... there are 2^(h+1) nodes, where h = log_2(n)
01:24:44 <mreh> it's not obvious in my mind at least
01:25:07 <quicksilver> c_wraith: it's n^2 or worse in total program size
01:25:12 <mreh> (those calculations are for regular trees)
01:25:43 <c_wraith> I guess the answer is that supercompilation really requires whole-program compilation, which no big compilers are doing.
01:26:07 <mreh> == partial compilation? heh
01:26:13 <mreh> are we talking optimisations
01:26:15 <sinelaw> VC does
01:26:23 <sinelaw> (microsoft)
01:26:37 <sinelaw> oh wait, i'm not sure.
01:26:38 <c_wraith> Oh, right.  I tend to forget that some people still use windows.
01:26:52 <Twey> heh
01:27:02 <sinelaw> :_(
01:27:18 <sinelaw>   \____
01:28:49 <c_wraith> gah.  converting imperative algorithms to haskell..  I'm almost tempted to use the state monad just to manage this one value that is updated a bunch in one function.  Feels so overkill...
01:30:48 <c_wraith> Huh.  Maybe it's not overkill, for this case.  runState has the right return value.  Hmm.
01:32:08 <c_wraith> Or maybe I should go straight to ST.  This is even a case where it's appropriate
01:32:27 <o-_-o> I have a friend here who is asking why do we need kinds ?
01:32:32 <o-_-o> if we already have types
01:32:41 <o-_-o> how does it help to understand kinds
01:33:05 <c_wraith> well..  If you talk a bit about type constructors...
01:33:08 <quicksilver> the compiler needs them to stop you writing nonsense, o-_-o
01:33:15 <quicksilver> you don't need them yourself, really
01:33:15 <c_wraith> How "Maybe" is different from "Integer"
01:33:27 <o-_-o> quicksilver, ah
01:33:30 <quicksilver> (they're not explicitly mentioned in the haskell 98 standard I don't think)
01:33:42 <c_wraith> And you can't use "Maybe" the same way you can use "Integer", because Maybe is a type constructor, where Integer is a type.
01:33:43 <sinelaw> is it ok for my c functions to store stuff statically between calls by haskell code?
01:33:52 <quicksilver> but the compiler needs to know that "foo :: Maybe -> ()" is nonsense
01:33:53 * hackagebot glpk-hs 0.2.3 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.2.3 (LouisWasserman)
01:33:59 <sinelaw> assuming everything is essentially pure
01:34:01 <quicksilver> and "foo :: Maybe Maybe -> ()" is also nonsense
01:34:14 <quicksilver> but "foo :: Maybe Int -> ()" is not
01:34:17 <c_wraith> And then you can say that kind are way of keeping track of the difference between types and type constructors
01:34:33 <c_wraith> *kinds
01:34:36 <o-_-o> ah...ok
01:34:46 <o-_-o> so does ghc give you kind errors ?
01:34:50 <c_wraith> it does
01:34:51 <o-_-o> like type errors
01:34:56 <o-_-o> ah
01:35:24 <c_wraith> @kind RWST
01:35:25 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
01:35:38 <c_wraith> I'm greatly amused by that. :)
01:36:10 <wSogeking> Hey guys I am writing an essay on java vs haskell, but I have no ideas on what to write (also not knowing much of haskell doesnt help)
01:36:18 <c_wraith> RWST is a type constructor that takes 5 arguments.  The 4th is a type constructor that takes one argument!
01:36:23 <wSogeking> what would you guys say haskell has over java?
01:36:35 <wSogeking> with a focus on writing compilers (but not limited to)
01:37:36 <sinelaw> wSogeking, haskell is pure and functional, which makes it much easier to implement a semantically precise design
01:37:59 <sinelaw> plus, separation of side-effecting from computations
01:38:12 <c_wraith> wSogeking: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html <-- If you haven't read this paper, start there.
01:38:40 <sinelaw> wSogeking, and this http://www.ee.bgu.ac.il/~noamle/intro.html#what-is-functional-programming
01:38:40 <c_wraith> It's not specifically about Haskell, but it does start the ball rolling in the right direction
01:39:06 <sinelaw> wait no. wrong link
01:39:19 <sinelaw> wSogeking, this: http://www.ee.bgu.ac.il/~noamle/intro.html#functional-programming-and-haskell
01:40:06 <sinelaw> but just the first page or two
01:40:30 <sinelaw> i need to edit that into something more general
01:40:55 <c_wraith> ah.  that's your research. :)
01:41:42 <wSogeking> thanks by the way
01:41:58 <sinelaw> c_wraith, i wouldn't call that specific thing research
01:42:05 <wSogeking> links + what sinelaw said really helped
01:42:28 <c_wraith> well, ok.  It's somewhat about your work with FRP.
01:42:53 <sinelaw> yeah :) just trying to be modest here
01:43:02 <sinelaw> it's more of a learning experience
01:43:56 <int-e> @quote eek
01:43:56 <lambdabot> <bfh6558> says: foldr.com reminds me of some horrible lisp nightmear I had a few weeks back
01:45:15 <sinelaw> @quote psychobot
01:45:15 <lambdabot> psychobot says: You speak an infinite computation
01:46:55 <mreh> where does the Haskell finger tree implementation lie?
01:47:34 <c_wraith> Data.Sequence
01:48:01 <mreh> Oh... it's the constructor that's called Seq isn't it...
01:51:27 <sinelaw> @quote objects
01:51:27 <lambdabot> Jafet says: <gwern> closures are a poor man's object <ddarius> objects are a poor man's closure <Berengal> objects are a rich man's structs <Jafet> Poor programmers should start unions
01:55:54 <dolio>  @quote could use a way of systematically remembering quotes involving multiple people.
02:06:38 <sinelaw> @hoogle {-# LANGUAGE ForeignFunctionInterface, EmptyDataDecls #-}
02:06:38 <sinelaw>  
02:06:38 <sinelaw> module GSLWorkSpace (Workspace, createWorkspace) where
02:06:38 <sinelaw>  
02:06:38 <sinelaw> import Foreign.C.Types
02:06:38 <lambdabot> Parse error:
02:06:39 <lambdabot>   --count=20 "{-# LANGUAGE ForeignFunctionInterface, EmptyDataDecls #-}"
02:06:39 <lambdabot>              ^
02:06:41 <sinelaw> import Foreign.Ptr
02:06:43 <sinelaw> import Foreign.ForeignPtr
02:06:45 <sinelaw>  
02:06:47 <sinelaw> data Workspace
02:06:49 <sinelaw> foreign import ccall unsafe "gsl/gsl_integration.h gsl_integration_workspace_alloc"
02:06:51 <sinelaw>     c_ws_alloc :: CSize -> IO (Ptr Workspace)
02:06:53 <sinelaw> foreign import ccall unsafe "gsl/gsl_integration.h &gsl_integration_workspace_free"
02:06:55 <sinelaw>     c_ws_free  :: FunPtr( Ptr Workspace -> IO () )
02:06:57 <sinelaw>  
02:06:59 <sinelaw> createWorkspace :: CSize -> IO (Maybe (ForeignPtr Workspace) )
02:07:01 <sinelaw> createWorkspace size = do
02:07:03 <sinelaw>     ptr <- c_ws_alloc size
02:07:05 <sinelaw>     if ptr /= nullPtr
02:07:07 <sinelaw>         then do
02:07:11 <sinelaw>            foreignPtr <- newForeignPtr c_ws_free ptr
02:07:13 <sinelaw>            return $ Just foreignPtr
02:07:15 <sinelaw>         else
02:07:17 <sinelaw>            return Nothing
02:07:19 <sinelaw> oyyyyy!!
02:07:21 <sinelaw> Sorry.
02:07:23 <sinelaw> I hate emacs.
02:07:25 <sinelaw> @hoogle createForeignPtr :: (a -> IO (Ptr b)) -> (FunPtr (Ptr b -> IO () )) -> a -> IO (Maybe (ForeignPtr b) )
02:07:26 <lambdabot> No results found
02:07:31 <sinelaw> well, duh.
02:16:16 <Alpounet> @hoogle createForeignPtr
02:16:16 <lambdabot> No results found
02:18:13 <sinelaw> Alpounet, it's a function i just wrote. emacs' copy&paste is messy here
02:19:39 <Alpounet> oh ok sinelaw
02:19:54 <Alpounet> sinelaw, by the way, M-x haskell-hoogle, IIRC
02:31:29 <Saizan> (Data.Sequence is implemented as a fingertree, for the general fingertree structure there's a package on hackage)
02:44:50 <blueonyx> is it possible to combine the IO,State and some Error monad?
02:45:32 <blueonyx> any pointers how it would look like?
02:46:24 <quicksilver> StateT s (ErrorT e IO) a
02:46:27 <quicksilver> or the other way around
02:46:40 <quicksilver> depending if you want errors to come with the final state attached or not
02:46:48 <commanace> hey... is (fibs !! n) more efficient than (recursivefib n) ? I mean, is haskell clever enough to maintain and keep one instance of the fibs list and only calculate the needed element on demand, or is the fibs list always recalculated?
02:47:05 <commanace> better: is ghc clever enough
02:47:28 <quicksilver> yes, it does
02:47:36 <quicksilver> named values are kept until they are GCed
02:49:05 <commanace> ok, thanks
02:50:12 <benmachine> is recursivefib the exponential one
02:50:29 <benmachine> err, I mean the two-recursive-calls-each one
02:50:57 <blueonyx> quicksilver: the other way around would be ErrorT e (StateT s IO a)? is there some IOT too? does is make sense?
02:51:05 <benmachine> IOT doesn't make sense
02:51:12 <benmachine> or, isn't really possible
02:53:34 <sinelaw> Alpounet, thanks
02:58:42 <sinelaw> Is there a way to see the hierarchy?
02:58:54 <sinelaw> oops. the entire module hierarchy that hackage supplies
02:59:03 <sinelaw> Data.Something.Bla etc...
02:59:05 <sinelaw> that tree.
03:01:04 <commanace> benmachine: yeah,... just took it as a known example... in my case i have a recursive function which i call quite often - e.g. for plotting, so i actually need every value of the sequence... therefore the sequence approach probably is more appropriate anyway... (?)
03:01:43 <commanace> as compared to map (myrecursivefun) [0..]
03:02:43 <pastorn> for parsec; is this true+
03:02:46 <pastorn> ?
03:03:16 <pastorn> option def (try p) === p <|> return def
03:14:10 <erorrfouroforang> hi
03:14:30 <pastorn> herro
03:15:31 <erorrfouroforang> i have a question about another functional language - sisal - but could not find a channel for it. its also a functional language, so maybe someone can still take a look?
03:16:34 <pastorn> erorrfouroforang: what are you building?
03:16:58 <erorrfouroforang> doing some homework for my programming languages class, im trying to sort a 2 dimensional array
03:17:49 <pastorn> erorrfouroforang: why not just make it one-dimensional and pass your pointers through 'mod x rowLength'?
03:17:50 <erorrfouroforang> there's a concat operator || that i use, but it gives me the error:   ****ERROR Arity of operand for binary operation ||  is greater than 1. Line   69
03:19:05 <pastorn> well, '||' seems to be needing two arguments?
03:19:07 <pastorn> erorrfouroforang:
03:19:11 <pastorn> @hpaste
03:19:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:19:14 <pastorn> paste it there
03:19:39 <erorrfouroforang> here's the line: Main( L ) || Middle || Main( R )
03:19:40 <erorrfouroforang> k
03:21:23 <pastorn> erorrfouroforang: let's use [a] to mean an array of a, and [[a]] an array of arrays of a
03:22:03 <pastorn> [a] || [a] ==> [a] ?
03:22:32 <erorrfouroforang> it would be [a a] i think
03:22:39 <pastorn> wut?
03:22:45 <pastorn> what does that even mean?
03:22:58 <pastorn> [int] would be a list of int
03:23:00 <erorrfouroforang> the two lists concatenated
03:23:10 <pastorn> ah, i was speaking of this on a type level
03:23:19 <erorrfouroforang> you know im talking about sisal, not haskell right?
03:23:40 <pastorn> [1,2,3] || [4,5,6] == [1,2,3,4,5,6] ??
03:23:44 <erorrfouroforang> yeah
03:24:01 <pastorn> erorrfouroforang: i highly doubt that sisal doesn't use types
03:24:39 <erorrfouroforang> sure it has types, including ones you can define yourself, like a two dimensional array
03:24:46 <erorrfouroforang> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8452#a8452
03:25:02 <erorrfouroforang> thats all the code, the problem is at line 69
03:25:30 <pastorn> ehm... what does 'Split' do?
03:25:37 <erorrfouroforang> the call to quicksort from the main function is on line 39
03:25:48 <erorrfouroforang> its defined within quicksort, 54
03:25:59 <pastorn> oh, there
03:26:49 <blueonyx> does http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23201#a23201 make sense? why is it a [Char], i got the (Left "bla") :(
03:27:44 <pastorn> blueonyx: remove "Left ("
03:27:52 <pastorn> from your last line
03:28:17 <Alpounet> it expects an IO String, not an IO (Either [...])
03:29:34 <blueonyx> but there is also a Left case with a different type O.o
03:29:48 <pastorn> blueonyx: hpaste
03:29:59 <blueonyx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23201#a23203
03:30:25 <blueonyx> and IO (Either..) worked before :/
03:30:25 <pastorn> erorrfouroforang: i don't see it... sorry :(
03:30:32 <erorrfouroforang> thanks anyway
03:30:59 <pastorn> blueonyx: the whole function+
03:31:10 <pastorn> it could be good to see the functions type signature...
03:31:37 <erorrfouroforang> i was thinking that when Split has no elements to put into one if it's arrays, that causes the problem and the empty array cannot be concatenated or cannot be returned
03:31:48 <blueonyx> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23201#a23204
03:33:05 <pastorn> erorrfouroforang: concatenating with the empty array should just give the other array
03:33:16 <pastorn> erorrfouroforang: [] || someArr == someArr
03:33:21 <blueonyx> oh it probably is withTempFile
03:34:17 <blueonyx> sry for the noise
03:34:40 <erorrfouroforang> but perhaps split doesn't generate an empty array in the first place when the 'where' condition is never met?
03:35:00 <erorrfouroforang> and returns null or something... donno
03:35:13 <pastorn> blueonyx: withTempFile takes an IO String as last argument?
03:35:56 <Alpounet> @hoogle withTempFile
03:35:56 <lambdabot> No results found
03:36:08 <Alpounet> hm
03:36:26 <blueonyx> pastorn: yep
03:36:42 <pastorn> seems silly
03:36:46 <pastorn> liftM*?
03:37:03 <blueonyx> had it IO a and dont know why i changed it :/
03:38:02 <blueonyx> liftM*? withTempFile creates some file and uses bracket to run the action and remove the file
03:38:22 <pastorn> oh, you use bracket
03:38:26 * pastorn shuts up
04:05:18 <yoaz> someone here?
04:05:46 <yoaz> is someone os connexted
04:05:48 <yoaz> ?
04:15:06 <erorrfouroforang> btw pastorn, i solved the problem.. i was calling the wrong function on line 69 (Main instead of quicksort)
04:15:18 <pastorn> erorrfouroforang: haha
04:15:21 <pastorn> NICE
04:15:23 <erorrfouroforang> crazy how i spent a couple of hours looking at the code and couldnt catch such a stupid mistake
04:15:27 <erorrfouroforang> :(
04:16:02 <erorrfouroforang> anyway, thanks for the help, im going to sleep
04:18:33 <blueonyx> is there any way to catch Prelude.head: empty list? i tried 'try (return $ head []) :: Either SomeException Int' (from Control.Exception) without luck
04:20:48 <Alpounet> @hoogle catch
04:20:48 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
04:20:49 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
04:20:49 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
04:21:17 <blueonyx> @src try
04:21:17 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
04:21:59 <blueonyx> ah lazyness
04:26:10 <pastorn> @type try
04:26:11 <lambdabot> Not in scope: `try'
04:26:17 <pastorn> boooooo!
04:27:08 <Alpounet> @hoogle try -- pastorn
04:27:09 <lambdabot> Parse error:
04:27:09 <lambdabot>   --count=20 "try -- pastorn"
04:27:09 <lambdabot>                  ^
04:27:14 <Alpounet> @hoogle try
04:27:14 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
04:27:14 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
04:27:14 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
04:27:22 <Alpounet> pastorn, ^^^
04:29:20 <Alpounet> a @src-importing command would be nice
04:30:11 <blueonyx> @hoogle evaluate
04:30:11 <lambdabot> Control.Exception evaluate :: a -> IO a
04:30:11 <lambdabot> Control.OldException evaluate :: a -> IO a
04:30:11 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
04:30:22 <blueonyx> @hoogle IO a -> IO a
04:30:22 <lambdabot> Network withSocketsDo :: IO a -> IO a
04:30:22 <lambdabot> Control.Exception block :: IO a -> IO a
04:30:23 <lambdabot> Control.OldException block :: IO a -> IO a
04:31:41 <blueonyx> is there some evaluate for io actions?
04:31:53 <pastorn> blueonyx:
04:31:59 <pastorn> @type unsafePerformIO
04:32:00 <lambdabot> Not in scope: `unsafePerformIO'
04:32:05 <blueonyx> oh
04:32:07 <pastorn> @hoogle unsafePerformIO
04:32:08 <lambdabot> Foreign unsafePerformIO :: IO a -> a
04:32:08 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
04:32:27 <pastorn> blueonyx: but that's nastyness, don't use that unless you're sure of what you're doing
04:32:52 <blueonyx> is calling unsafePerformIO in an IO block safe?
04:33:00 <pastorn> no
04:33:19 <Alpounet> blueonyx, the better would be to force the evaluation of the nested data (the 'a')
04:33:34 <blueonyx> that gets forced by evaluate
04:33:52 <pastorn> blueonyx: use seq or pseq to force evaluation of some expression
04:34:05 <pastorn> pseq does it on another cpu core (iirc)
04:34:19 <pastorn> @hoogle seq
04:34:20 <lambdabot> Prelude seq :: a -> b -> b
04:34:20 <lambdabot> Data.Sequence data Seq a
04:34:20 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
04:35:07 <pastorn> blueonyx: heavySubExpression `pseq` f heavySubExpression
04:35:13 <Alpounet> blueonyx, e.g, if you're reading the content of a file, force the evaluation of either the content, or the length, or such stuffs.
04:35:25 <Alpounet> do not use unsafePerformIO for that !
04:35:39 <pastorn> blueonyx: use unsafePerformIO EVERYWHERE
04:35:42 <pastorn> it's AWESOM
04:35:58 <pastorn> and gets you lots of women!
04:38:02 <blueonyx> no women no cry
04:38:15 <pastorn> hehe
04:38:45 <blueonyx> but my problem is, that i wrap the head [] into a try, but the exception gets caught by another catch :/
04:39:06 <BONUS> why are trying to catch head [] anyway?
04:39:30 * pastorn nods
04:40:24 <BONUS> preflex: seen mmorrow
04:40:24 <preflex>  mmorrow was last seen on #ghc 44 days, 9 hours, 42 minutes and 39 seconds ago, saying: * mmorrow is rtfm'ing
04:41:19 <blueonyx> to provide a better error message and i have to communicate over stdin/out with json encoded messages, where ***Exception: messes everything up
04:41:44 <BONUS> what about: if null xs then ... else ...
04:41:51 <Alpounet> yeah
04:41:53 <Alpounet> or pattern matching
04:41:56 <BONUS> ya
04:41:57 <Alpounet> and returning Nothing
04:42:04 <Alpounet> or Just (theList)
04:42:16 <blueonyx> i get the code which throws the error over stdin and compile it via hint
04:42:21 <Zao> Data.Maybe has some  [a] -> Maybe a, doesn't it?
04:42:30 <BONUS> Zao: Data.Maybe.listToMaybe
04:42:47 <Alpounet> blueonyx, here you go ^^^
04:42:53 <Zao> @src listToMaybe
04:42:53 <lambdabot> listToMaybe []        =  Nothing
04:42:53 <lambdabot> listToMaybe (a:_)     =  Just a
04:43:42 <blueonyx> i dont want a workaround i need to catch it :/
04:44:01 <blueonyx> and i catch it, just in the wrong place
04:48:34 <blueonyx> thanks anyhow, bye
04:59:47 <pastorn> how do i do fuzzy searches?
04:59:56 <pastorn> String -> [String] -> [String]
05:00:44 <pastorn> search "gogle" ["google","yahoo"] == ["google"]
05:02:32 <luite> pastorn: you could use some function to measure the similarity between the strings, perhaps de Levenshtein distance
05:02:36 <luite> the
05:02:45 <eevar2___> @hoogle fuzzy
05:02:46 <lambdabot> No results found
05:04:47 <pastorn> go go translate superheroes! http://en.wikipedia.org/wiki/Levenshtein_distance#Computing_Levenshtein_distance
05:07:04 <pastorn> luite: thanks :)
05:07:35 <adri_> Hi, trying to install cabal using bootstrap.sh I get the following error : Setup: At least the following dependencies are missing:time ==1.1.*
05:08:00 <pastorn> adri_: how did you install ghc?
05:08:03 <pastorn> what OS?
05:08:11 <adri_> pastorn, aptitude install ghc6
05:08:20 <adri_> pastorn, ubuntu 9.10
05:08:40 <pastorn> hmm... i usually install ghc from its binary blob on ubuntu
05:08:45 <pastorn> less headache :)
05:09:27 <pastorn> adri_: that way ghc and its packages are separate from ubuntus :)
05:09:34 <pastorn> (almost)
05:10:54 <silver> wait, I've encountered this... but can't remember the solution
05:11:14 <silver> can you provide full log?
05:11:22 <silver> I know there is something more
05:11:29 <silver> about quickcheck may be
05:12:11 <adri_> silver, are you talking about my cabal issue?
05:12:16 <silver> yea
05:12:34 <adri_> pastorn, ok, I'll try uninstalling ghc6 and installing it myself.
05:13:24 <pastorn> adri_: don't need to uninstall
05:13:58 <adri_> silver, http://pastie.org/851570
05:14:30 <adri_> pastorn, but then i'll have 2 ghcs living on my computer right?
05:14:58 <Alpounet> adri_, install time separaltely
05:15:01 <Alpounet> -l
05:15:30 <pastorn> adri_: actually booting ghc/ghci will just be a soft link to the actual binary
05:15:41 <pastorn> so there's no worry
05:15:47 <pastorn> unless you worry about disk space
05:16:14 <adri_> Alpounet, don't know how to do that...isn't cabal the tool that's supposed to install haskell packages? (sorry I am completely new to the language/ecosystem)
05:16:26 <benmachine> cabal makes it a lot easier
05:16:30 <benmachine> but it's not essential
05:16:38 <silver> awww, that's strange
05:16:56 <benmachine> well
05:17:08 <benmachine> cabal-install is the package for the command line tool cabal
05:17:20 <benmachine> the Cabal library comes with GHC and is what you use to install stuff
05:17:29 <benmachine> cabal-install is an interface to the Cabal library
05:18:07 <Alpounet> adri_, you also can download the tarball of time, uncompress it, and do : runhaskell Setup.lhs configure, runhaskell Setup.lhs build, runhaskell Setup.lhs install (it might me Setup.hs, though, depending on the package)
05:23:17 <adri_> Ok.. I did aptitude install libghc6-time-{dev,doc,prof} and it works. I think I'll keep going through Ubuntu for now, seems like _less_ headache for me :)
05:29:15 <silver> hehe
05:31:56 <pastorn> adri_: hehe... ok
05:32:25 <pastorn> but you can't do CTRL+arrow keys to jump whole words in GHCI with the ubuntu ghc version
05:32:28 * pastorn knows
05:32:39 <sieson> what does the $ mean in haskell? I have seen it in so many places and haven't found any solid description of it anywhere.
05:32:50 <pastorn> @src ($)
05:32:51 <lambdabot> f $ x = f x
05:32:52 <zygoloid> sieson: f $ x = f x.
05:32:55 <pastorn> sieson: ^^
05:33:12 <pastorn> sieson: what it does is that it binds "hard"
05:33:12 <sieson> zygoloid: so why use it?
05:33:13 <zygoloid> sieson: this means that: foo bar baz $ x y z = (foo bar baz) (x y z)
05:33:20 <zygoloid> it's therefore useful for removing parentheses
05:33:21 <Zao> sieson: It is for getting rid of parens.
05:33:28 <pastorn> sieson: you can use it to trick the type system :)
05:33:30 <zygoloid> there's another use of it:
05:33:35 <pastorn> sieson: have you seen (.)?
05:33:45 <pastorn> (as in h = f . g)
05:33:47 <zygoloid> > map ($ 10) [(+1), (*2)]
05:33:47 <sieson> pastorn:: yes
05:33:48 <lambdabot>   [11,20]
05:33:51 <Zao> pastorn: I wouldn't say "trick", as it's all quite sane and legal.
05:33:59 <pastorn> sieson: ok, in ghci:
05:34:02 <pastorn> :t not
05:34:03 <lambdabot> Bool -> Bool
05:34:09 <eevar2___> @hoogle $
05:34:09 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:34:09 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
05:34:09 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
05:34:10 * Zao slaps pastorn around a bit with the monomorphism restriction.
05:34:16 <pastorn> lambdabot: not u
05:34:17 <sieson> ok thanks
05:34:30 <pastorn> :t not . not
05:34:31 <lambdabot> Bool -> Bool
05:34:34 <sieson> when you get stuck in haskell where is the best place to check first?
05:34:37 <pastorn> :t not . not True
05:34:38 <lambdabot>     Couldn't match expected type `f Bool' against inferred type `Bool'
05:34:38 <lambdabot>     In the second argument of `(.)', namely `not True'
05:34:38 <lambdabot>     In the expression: not . not True
05:34:45 <pastorn> :t not . not $ True
05:34:46 <lambdabot> Bool
05:34:52 <pastorn> sieson: ^^^
05:35:54 <int-e> pastorn: you can wield a type signature in defense :)
05:35:55 <ski> sieson : depends .. but here is usually not that bad a general recourse
05:36:21 <pastorn> Zao: YOU are a momomorphism restriction
05:36:45 <sieson> ski: yeah of course IRC is the best, I meant some website.
05:37:16 <ski> (first you should check your source code, and the error messages (if any), then you might consult your local haskell resource, like a book or a TA; failing that, the mailing list or here)
05:37:29 <benmachine> I'd say here then mailing list in that order
05:37:37 <benmachine> usually
05:37:38 <ski> (s/TA/TA or guru/)
05:37:58 <benmachine> oh hey ski I was going to ask you something about CPS transforms
05:38:04 <benmachine> give me a moment to remember what it was
05:38:07 <ski> (benmachine : heh, that last "or" was unordered :)
05:38:12 <quicksilver> here is better for quick answers.
05:38:29 <quicksilver> the mailing list is good for more involved questions, but the risk is if you ask a really good question, no one answers at all.
05:38:41 <sieson> ski: Ok thanks :D
05:38:48 <quicksilver> here you almost always get some kind of answer.
05:39:07 <benmachine> well if it's busy sometimes you can be missed
05:42:02 <benmachine> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23206#a23206 do you remember these? the former doesn't work on infinite lists unless I make the tuple match lazy, but I was surprised to see the latter has the same problem
05:42:25 <benmachine> can it be fixed to do so?
05:45:02 <ski> hm, istr the names "spi" and "wpi" ..
05:45:22 <benmachine> wpi being foldr, basically
05:45:35 <ski> hm, right, this was for expressing `listCase', iirc
05:45:38 <benmachine> yes
05:45:48 <benmachine> and spi being (a -> [a] -> b) -> b -> [a] -> b
05:46:03 <benmachine> (i.e. listCase or destructList or whatever you want to call it)
05:46:37 <benmachine> anyway, spi'' const 0 [1,2,3] gives 1 but spi'' const 0 [1 ..] dies
05:47:51 <Polarina> Can GHC compile for IBM POWER7?
05:54:21 <adri_> Trying to install yi, I get this -- google refuses to help. cabal: Error: some packages failed to install: terminfo-0.3.1.1 failed during the configure step. The exception was: ExitFailure 1
05:55:33 <ski>      spi'' const 0 [1 ..]
05:55:45 <ski>   =  foldr g (\k -> k 0 []) [1 ..] const
05:55:59 <ski>   =  g 1 (foldr g (\k -> k 0 []) [2 ..]) const
05:56:12 <ski>   =  foldr g (\k -> k 0 []) [2 ..] (\_ xs -> const (f 1 xs) (x:xs))
05:56:23 <ski>   =  foldr g (\k -> k 0 []) [2 ..] (\_ xs -> f 1 xs)
05:56:36 <ski>   =  g 2 (foldr g (\k -> k 0 []) [3 ..]) (\_ xs -> f 1 xs)
05:57:00 <ski>   =  foldr g (\k -> k 0 []) [3 ..] (\_ xs -> (\_ xs -> f 1 xs) (f 2 xs) (x:xs))
05:57:18 <ski>   =  foldr g (\k -> k 0 []) [3 ..] (\_ xs -> f 1 xs (x:xs))
05:57:37 <ski>   =  g 3 (foldr g (\k -> k 0 []) [4 ..]) (\_ xs -> f 1 xs (x:xs))
05:57:49 <benmachine> there's no way it should even be evaluating that far in the list
05:58:04 <benmachine> spi' const 0 (1 : undefined) works fine :P
05:58:15 <ski>   =  foldr g (\k -> k 0 []) [4 ..] (\_ xs -> (\_ xs -> f 1 xs (x:xs)) (f 3 xs) (x:xs))
05:58:46 <ski> &c.
05:58:57 <benmachine> yes
05:59:02 <ski> so, it is basically trying to reach the end of the list
05:59:15 <byorgey> adri_: there was probably another error message earlier in the output.  Try just doing  cabal install terminfo-0.3.1.1  and see what happens.
05:59:50 <benmachine> yes
06:00:46 <adri_> byorgey, http://pastie.org/851647
06:01:04 <ski> `foldr' in this case becomes tail-recursive (mutually with `g')
06:01:43 * benmachine tries to work out whether the output of his step evaluator matches what ski found
06:01:47 <ski> if it would ever reach the end, then `\k -> k 0 []' would extract the result
06:02:07 <ski> (benmachine : i made a few typos, i notice now)
06:02:13 <benmachine> oh
06:02:26 <ski> the problem is that it is passing down the result (inside the continuation) don't to the base case
06:02:28 <benmachine> heh, if there'd been a discrepancy I'd've assumed it my fault
06:02:30 <ski> s/don't/down/
06:03:03 <ski> (the first free `x' should be `1', the next should be `2', &c.)
06:03:32 <Alpounet> adri_, you probably have to install libcurses
06:03:36 <benmachine> right
06:03:55 <|m0rph|> hello, i have a question regarding cabal preprocessing, is this the right channel?
06:04:00 <benmachine> my step evaluator doesn't evaluate under lambdas so it just got a giant mess instead
06:04:17 <benmachine> |m0rph|: I think so
06:04:44 <ski> benmachine : hm .. maybe one could make a cbn-CPS version of it ..
06:05:01 <mornfall> |m0rph|: Well, if you are into canned cabals, then probably no. But for the buildsystem, should work. ;)\
06:05:31 <Alpounet> adri_, use your package manager to install ncurses, and you should be fine
06:05:41 <benmachine> ski: well, I don't really know enough about CPS transforms to help, I'm just curious
06:05:47 <|m0rph|> so, what I want to do is to chain two preprocessors: cpp and happy. I've been poking around the Distribution.Simple.PreProcess but can't find how to do that
06:05:56 <ski> @type let spi'' f z xs = foldr g (\k -> k z []) xs const where g x p k = p $ \_ xs -> k (f x xs) (x:xs) in spi''
06:05:56 <benmachine> to see if that ~ could be easily translated
06:05:57 <lambdabot> forall a b. (a -> [a] -> b) -> b -> [a] -> b
06:06:08 <Alpounet> adri_, the -dev version included, since you need the headers
06:06:23 <|m0rph|> i have a file like .cppy and want to run cpp to create the .y file then run happy
06:06:28 <ski> @type foldr `asTypeIn` \foldr -> let spi'' f z xs = foldr g (\k -> k z []) xs const where g x p k = p $ \_ xs -> k (f x xs) (x:xs) in spi''
06:06:29 <lambdabot> forall a b. (a -> ((b -> [a] -> b) -> b) -> (b -> [a] -> b) -> b) -> ((b -> [a] -> b) -> b) -> [a] -> (b -> [a] -> b) -> b
06:06:33 <ski> (that's better)
06:08:56 <ski>   foldr :: (a -> Cont o (o,[a]) -> Cont o (o,[a])) -> Cont o (o,[a]) -> [a] -> Cont o (o,[a])  -- basically
06:09:38 * benmachine tries to work this out
06:10:02 <benmachine> where those tuples are not actual tuples but CPS tuples
06:10:06 * ski wonders how sane that is ..
06:10:10 <ski> yes
06:10:15 <|m0rph|> so can anyone help me ?
06:10:49 <benmachine> |m0rph|: sorry, not my field
06:11:20 <|m0rph|> i hate building issues
06:11:24 <byorgey> |m0rph|: this is the right channel but you have to catch the right person =)
06:11:27 * benmachine reckons quicksilver was wrong on the "some kind of answer" comment unless "dunno" counts as an answer
06:11:46 <|m0rph|> :/
06:11:50 <|m0rph|> thx
06:11:58 * ski wonders if we should migrate this CPS rambling to #haskell-overflow, so as to not overload the more mundane issues ..
06:12:43 <benmachine> ski: do you know any resources which are good in general for learning the benefits of continuations?
06:12:50 <byorgey> |m0rph|: if I were you I would try emailing haskell-cafe@haskell.org
06:13:08 <benmachine> you have to sign up to the list before you can post there, don't you?
06:13:12 <byorgey> well, yes
06:13:41 <ski> benmachine : i'm not sure .. i myself learned about them because they seemed like great fun .. then i guess i've picked up various uses of them on the way
06:13:55 <|m0rph|> byorgey, will try that
06:13:56 <|m0rph|> thanx
06:14:13 <benmachine> ski: hah
06:14:26 <benmachine> I am in favour of that sort of learning
06:14:45 <benmachine> so I should basically just try and work out CPS transforms of stuff and then see if anything neat happens?
06:14:49 <ski> benmachine : .. however, it's hard to enumerate uses - if i see a situation that could benefit of them, then i'll think of the use
06:15:37 <ski> benmachine : it might be nice to understand the basic reason CPS was invented .. and also understand the actual rules of the CPS transformation
06:15:46 <benmachine> might be!
06:15:57 <adri_> Alpounet, thanks it worked. But I've just solved 2 more errors in the process of installing Yi, and am looking at a new one now. That's a total of 6 I think. Is this normal? I did everything in a rather standard way.
06:16:22 <benmachine> well, CPS is more or less the only way of encoding data in lambda calculus, right?
06:16:30 <ski> benmachine : i thought "Abstracting Control" and "Representing Control" was partially good for that, but i'm not sure how much i read about CPS before reading them
06:16:45 <benmachine> or at least, I have "CPS" "lambdas" and "catamorphisms" in the same mental bag
06:16:45 <Alpounet> adri_, yeah, it happens sometimes... It will make you appreciate so much more your freshly installed yi, right after :-p
06:16:45 <ski> benmachine : in a pure lambda calculus, yes
06:17:20 <ski> (you can have a lambda calculus with pairs and left- / right- tagged values, &c.)
06:17:33 <benmachine> I've had a go at implementing peano numerals in pure lambdas before
06:17:34 <adri_> Alpounet, I thought I was good at positive thinking but you... :)
06:18:04 <benmachine> trouble is I'm not sure I got it right because the evaluator is one I wrote myself and more often it was wrong than my lambdas >_>
06:18:12 <Alpounet> heh
06:18:43 * ski wonders why there's `o' in the the "return type" of the continuation actions, above ..
06:20:40 * benmachine saves a copy of the abstracting control paper into his ~/haskell/papers directory
06:20:47 <benmachine> into which things seem to go in but never come out >_>
06:21:05 <ski> (my bookmarks file is mostly the same ..)
06:21:40 <ski> (in the long run, i expect some to escape as Hawking radiation)
06:21:44 <benmachine> heh
06:24:20 * benmachine wonders why he gets compression ratios of about 90% on pdf files
06:24:22 <benmachine> err
06:24:23 <benmachine> or 10%
06:24:30 <benmachine> I'm not sure which way round the numbers go
06:24:43 <benmachine> 1.3 MB -> 1.2 MB
06:25:01 <Jafet> What were you expecting
06:25:35 <benmachine> well, their actual content is mostly text
06:25:38 <benmachine> english text
06:25:47 <benmachine> which is pretty compressible I think?
06:26:33 <Jafet> It's already compressed, and no it doesn't have to be english text
06:26:44 <benmachine> it doesn't have to be?
06:26:52 <benmachine> I am looking at it
06:26:56 <benmachine> it looks like english text to me :P
06:26:57 <opqdonut> embedded fonts...
06:27:54 <Jafet> It could be bitmaps for all you know
06:28:08 <benmachine> it could be all sorts of things
06:28:11 <benmachine> but that would be silly
06:28:16 <Jafet> Although if they're haskell papers it's probably stored as text
06:28:18 <burp> http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Unboxed-Mutable.html ← hm, is there no way to freeze such a mutable vector?
06:28:23 <Jafet> Embedded images, too
06:28:25 <benmachine> they're not haskell papers in this case
06:28:36 <benmachine> they are just text documents I have around
06:28:44 <benmachine> and thought I'd reshuffle
06:28:48 <benmachine> while I was there
06:30:07 <benmachine> but if indeed the format is already compressed I suppose that explains why .ps.gz is common but .pdf.gz is not
06:33:09 <Jafet> ps.gz is terrible and antiquated, I don't know why it's still used -- or why papers are still distributed in postscript for that matter
06:33:32 <Jafet> People aren't printers
06:41:21 <ski> @type let lCase :: forall a b. (a -> [a] -> b) -> b -> [a] -> b; lCase f z xs = foldr g (\k -> k z []) xs const where g :: a -> (forall o. (a -> o -> o) -> o) -> (forall o. (a -> o -> o) -> o); g x p k = k (p (\_ xs -> f x xs)) (p (\_ xs -> x:xs)) in lCase
06:41:22 <lambdabot>     Couldn't match expected type `forall o. (a -> o -> o) -> o'
06:41:22 <lambdabot>            against inferred type `(a -> o -> o) -> o'
06:41:22 <lambdabot>     In the first argument of `foldr', namely `g'
06:41:46 <ski> benmachine : i suspect something similar to that could work, if it would be convinced to type-check ..
06:42:46 <ski> (fsvo "work" .. it would probably recompute the "pairs" each time instead of sharing .. but maybe that doesn't matter in this case)
06:44:57 * ski for some reason always thought papers in PS nicer to read on the screen than ones in PDF
06:55:46 <benmachine> ski: as I understand it, the foldr should produce a (forall o. (a -> o -> o) -> o), but that doesn't match the type of const?
06:55:54 <zygoloid> ski: do you perchance use a nicer ps viewer than your pdf viewer? :)
06:56:10 <ski> zygoloid : .. could be it
06:56:10 * benmachine uses evince for both
06:56:20 * zygoloid uses and loves okular
06:57:13 <zygoloid> ski: what's that terrifying-looking fold supposed to do?
06:57:56 <ski> it is supposed to effect `\cons nil xs0 -> case xs0 of [] -> nil; x:xs -> cons x xs'
06:58:11 <ski> (but without using explicit pattern-matching, instead relying on `foldr')
06:58:24 <zygoloid> right, i see.
07:02:51 <ski> benmachine : hm, you're right, so `a -> o -> o' should have been `o -> [a] -> o' in the type of `g'
07:03:40 <benmachine> okay
07:04:19 <benmachine> still getting an error though - expected type `forall o. (o -> [a1] -> o) -> o' against inferred type `(o -> [a1] -> o) -> o'
07:06:17 <benmachine> hmm, does RankNTypes imply ScopedTypeVariables?
07:07:55 <dolio> I don't think so.
07:09:07 <benjamin_scarlet> benmachine: no
07:10:23 <korstya> hello all. can anyone advise me a package to process https browsing? Network.Browser is cool but it seems to me that it doesn't support ssl. please :-)
07:11:21 <ski> benmachine : .. yes, i should have mentioned the error didn't go away
07:11:44 <ski> i suppose one could try making an explicit datatype
07:11:53 <benmachine> ski: are your TypeVariables supposed to be Scoped
07:12:10 <ski> yes
07:12:13 <benmachine> right
07:12:27 <ski> but GHC doesn't match the way i want, anyway
07:13:07 <ski> one could try replacing `forall o. (o -> [a] -> o) -> o' with `Foo a', which is defined to contain the former
07:13:28 <benmachine> mm
07:13:37 <benmachine> it is probably time that I got on with my real work though
07:13:54 <ski> (basically, GHC refused to instantiate the polymorphic parameters of `foldr' to a polymorhic type .. hm ?!)
07:13:59 <benmachine> heh
07:14:20 <ski> maybe it would allow it with ImpredicativeTypes (or whatever it was called)
07:14:31 <Zao> *shudder*
07:14:43 * benmachine tries :set -XImpredicativeTypes and :r but to no avail
07:14:55 * benmachine decides it is late-lunchtime
07:15:06 <benmachine> thanks for your help
07:15:10 <ski> benmachine : for more fun, define `zipWith' (or `zip') using only `foldr' for list matching
07:15:38 <ski> (e.g. try to define it without using a `listCase' construction defined from `foldr')
07:15:44 <benmachine> korstya: you are correct that Network.Browser doesn't support https, you could try one of the curl packages?
07:16:10 <benmachine> ski: sounds like an adventure :P
07:16:23 <benmachine> hmm
07:17:53 <benmachine> :t uncurry zip
07:17:54 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
07:18:04 * benmachine reckons defining that might be easier
07:20:07 <korstya> benmachine: thank you for advise but are there any ways to do it in haskell not in c?
07:29:32 <osaunders> Is there a version of !! that allows you to specify a default if the index is too large?
07:34:25 <roconnor> @hoogle a -> Int -> [a] -> a
07:34:25 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
07:34:26 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
07:34:26 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
07:35:56 <ski> @type \x xs n -> (xs ++ repeat x) !! n
07:35:57 <lambdabot> forall a. a -> [a] -> Int -> a
07:36:34 <roconnor> ski: genious!
07:36:44 <McManiaC> hmm anyone ever used Bindings.GLib? I get a lot of undefined references
07:36:51 <McManiaC> /home/nils/.cabal/lib/bindings-glib-0.1/ghc-6.12.1/libHSbindings-glib-0.1.a(Threads.o): In function `sjgk_info':
07:36:54 <McManiaC> (.text+0xdf09): undefined reference to `g_private_set'
07:36:56 <McManiaC> etc
07:37:09 <roconnor> ski: though I guess not the fastest implementation :)
07:37:33 <McManiaC> http://npaste.de/JD/
07:37:35 <ski> roconnor : possibly not .. unless it gets deforested
07:59:33 <zygoloid> > let lCase cons nil xs = foldr (\x k c n -> k (\y ys -> c x (y:ys)) (c x [])) (\c n -> n) xs cons nil in lCase (\x xs -> show x ++ ":" ++ show xs) ("[]") [1,2,3,4,5]
07:59:34 <lambdabot>   "1:[2,3,4,5]"
07:59:53 <zygoloid> ski: there you go. sorry for the delay, but i was in a meeting...
08:00:13 <medfly> zygoloid, "I totally did not spend the last 30 minutes coming up with that"
08:00:49 <zygoloid> medfly: it took 4 minutes and worked first time :D
08:01:27 <zygoloid> wish i had spent the last half hour on it, it would have been more interesting than the document review meeting i actually had :)
08:02:23 <ski> zygoloid : yeah, we've already done that :) .. the problem atm was how to get that to work on infinite lists
08:04:10 <ski> (<http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23206> shows the two definitions we did some week(?) ago)
08:09:44 <benmachine> I like how you say "we" as if I was any use to the process whatsoever
08:11:21 <ski> (zygoloid : though, actually, now that i look more closely, i see that your version is not quite the same as the previous CPS one .. still fails at infinite lists, though)
08:12:43 * ski ah:s
08:13:31 <ski> your version basically uses a CPS-variant of `data ListCase a = Cons a [a] | Nil'
08:19:30 <MaciejP> Does any package provide utility functions for traversing and manipulating a haskell-src-exts AST?
08:20:27 <kiris> anyone written a mod_haskell that uses GHC as a backend, compiles the source file and then loads it as a .so for subsequent requests a la ASP .NET?
08:21:45 <SamB_XP> kiris: ASP .NET compiles ASP sources to CLR DLLs and loads 'em up?
08:21:55 <SamB_XP> I suppose that should be unsurprising ;-)
08:22:30 <kiris> SamB_XP: wha'?
08:22:46 <SamB_XP> kiris: wha' wha' ?
08:22:56 <kiris> SamB_XP: what you talking about?
08:23:02 <benmachine> MaciejP: syb? :P
08:23:04 <SamB_XP> you don't understand what I said, or that isn't what you meant by "ala ASP .NET"
08:23:10 <SamB_XP> ?
08:23:50 <kiris> SamB_XP: I believe asp .net compiles asp sources to libraries and loads them up. are you disputing this?
08:23:58 * hackagebot hgom 0.5.1 - An haskell port of the java version of gom  http://hackage.haskell.org/package/hgom-0.5.1 (PaulBrauner)
08:23:58 <SamB_XP> kiris: no!
08:24:13 <kiris> SamB_XP: ok. why did you say it?
08:24:29 <kiris> oh sorry!!
08:24:31 <kiris> hahahaha
08:24:35 <kiris> the question mark wasn't visible on my page
08:25:09 <SamB_XP> asking for clarification that it does indeed do this and/or expressing the fact that I had not known this previously ;-)
08:25:11 <kiris> SamB_XP: yeah thats' what I meant
08:25:59 * hackagebot hgom 0.5.2 - An haskell port of the java version of gom  http://hackage.haskell.org/package/hgom-0.5.2 (PaulBrauner)
08:26:15 <SamB_XP> I'm still not quite sure why CLR code gets stuck into DLLs ...
08:26:38 <MaciejP> benmachine: The doc says `The type of gfoldl is a headache' - and that's true! :-)
08:26:54 <SamB_XP> MaciejP: whoa!
08:27:16 <kiris> I want a web module like typical php that I can just take an html page and add a line that does a bit of dynamic stuff like <? if (preg_match('dave',$_SERVER['HTTP_HOST'])) { ?> ... <? } ?>
08:27:50 <kiris> I used it on tryhaskell and I kept thinking "I hate php the language but this way of writing simple web scripts is so easy"
08:27:51 <SamB_XP> I like it -- docs are rarely so refreshingly <insert adjective here>
08:28:19 <quicksilver> well, that seems completely orthogonal to how it's compiled, kiris :)
08:28:24 <kiris> and I've got used to, in using .net, pages recompiling when you change them and waiting for it to compile
08:28:31 <SamB_XP> are there any free implementations of ASP .NET ?
08:28:44 <quicksilver> whether you can embed haskell in web pages is a different question for hte details of if it makes .so files.
08:29:10 <quicksilver> still I don't think embedding full programming languages in web pages is a particularly good idea - better to use a simple template substitution there with a real language driving it.
08:29:11 <kiris> quicksilver: well, I just mean it gets compiled properly, not interpreted, and can be loaded dynamically on the server
08:29:41 <SamB_XP> quicksilver: you mean like that thing they use in TRAC ?
08:30:00 * hackagebot hgom 0.5.3 - An haskell port of the java version of gom  http://hackage.haskell.org/package/hgom-0.5.3 (PaulBrauner)
08:30:05 <quicksilver> SamB_XP: I mean like, for example, Template Toolkit or StringTemplate
08:30:17 <SamB_XP> excuse me, that's probably not the correct capitalization -- I get confused because there's a guy who hangs/hung out in #zsnes with the nick TRAC
08:30:30 <quicksilver> kiris: I'm not aware fo anything like that that isn't bitrotted.
08:30:40 <quicksilver> Haskell Server Pages was supposed to be a bit like that but I think it's dead.
08:31:26 <SamB_XP> kiris: I don't think that it would be particularly hard to switch anything that does that with interpretation over to using compilation, at this point
08:31:33 <quicksilver> still, have a poke around at : http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming#Web_frameworks
08:31:44 <kiris> quicksilver: yeah, for a proper site I'd setup templates and such. but for the odd tid bit pages that aren't worth the effort it'd be nice to just pop in <% maybe (return ()) putStrLn =<< getInput "age" %> or w/e
08:32:07 <SamB_XP> (can GHCi be persuaded to compile each expression natively yet?)
08:32:20 <benmachine> MaciejP: I don't "get" gfoldl either but I've made some decent use of gmapQ, everywhere etc.
08:32:46 <ski> @type gfoldl
08:32:48 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
08:32:55 <ski> looks fun
08:33:09 <benmachine> 'tis
08:33:23 <benmachine> MaciejP: http://github.com/benmachine/stepeval <-- a thing that uses HSE with syb
08:33:44 <ski> @type flip
08:33:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:34:30 <ski> @type \ia b -> ia <*> pure b
08:34:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
08:35:18 <kiris> is it possible to compile and load haskell code on the fly with ghc, reasonably straight-forwardly?
08:35:44 * SamB_XP likes how MS's .NET is like Java, except all the pieces of the system have their own names
08:36:05 <benmachine> kiris: I reckon any two of {compile haskell, on the fly, straightforward} can be satisfied :P
08:36:08 <SamB_XP> (instead of just being called "Java blah blah")
08:36:23 <benmachine> (on the premise that doing nothing on the fly is fairly straightforward)
08:36:49 <benmachine> kiris: I'm not an expert but I think the GHC API is the thing to look at
08:37:04 <benmachine> err that is to say, GHC has an API
08:37:12 <SamB_XP> doesn't GHCi support native compilation when you do :l ?
08:37:28 <benmachine> ghc supports native compilation when you do ghc
08:37:33 <benmachine> what is your point
08:38:18 <SamB_XP> I guess I figure at this point the GHCi REPL is (practically) using the GHC API?
08:43:24 <roconnor> > foldl f z [a,b,c]
08:43:25 <lambdabot>   f (f (f z a) b) c
08:43:46 <maltem> Not sure if ghci is fully decoupled, isn't the GHC API much newer than the ghci code?
08:46:04 * ksf wants a list of a sum type which statically disallows some combinations.
08:46:23 <ski> .. like ?
08:46:29 <ksf> as a silly example: I want to allow [1,2,+,3] but not [1,+,+,2]
08:47:08 <ksf> the straight-forward thing is to define some mutual recursive ADTs, but I was wondering if there's some mindboggingly elegant and generic solution I'm missing.
08:47:54 <ksf> ...the idea being data Foo = Foo Int (Maybe Bar); data Bar = Bar String (Maybe Foo)
08:48:16 <ksf> ...replace Maybe with something more complex to get more complex stuff.
08:48:57 <ski> one might be able to have some fun with non-regular data types or GADTs ..
08:53:04 <zygoloid> > let lCase cons nil xs = foldr (\x k b c n -> c x (k False (:) [])) (\b c n -> if b then nil else n) xs True cons nil in lCase (\x xs -> show x ++ ":" ++ show xs) ("[]") (repeat 'a')
08:53:08 <lambdabot>   "'a':\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
08:53:16 <ksf> how would gadts help me?
08:53:16 <zygoloid> ski: the type is too restrictive, but...
08:53:26 <ksf> my major worry is extensibility
08:54:29 <ksf> hmm data SkipList a b = Nil | SkipList a (SkipList b a)
08:55:30 <ksf> ...it should be possible to generalise all that with sufficient type magic, but I fear it'd be a bugger to pattern match on.
08:56:13 <kiris> benmachine: SamB_XP: I've used GHC's interpreter api which is what mueval uses. but there's nothing about compilation on there. I'm just musing anyway, it's probably really easy. I'll check it out when I get home. I was thinking of writing a lighttpd module to do it\
08:56:14 <ski> i'm not quite sure how much "all that" includes ..
08:56:26 <andgra> Hi, let's say I have a 'data Tree = Node Tree Tree | Leaf' and I want to replace a subtree of my tree with another tree - while maintaining the rest of the tree... is there any smart way to do this while keeping my 'small' datatype?
08:56:59 <ksf> for starters, supporting different things than ababababab. in general, matching something resembling regexen, like session types.
08:57:12 <zygoloid> > let lCase cons nil xs = snd $ foldr (\x ~(xs, r) -> (x:xs, cons x xs)) ([], nil) xs in lCase (\x xs -> show x ++ ":" ++ show xs) ("[]") [1..]
08:57:13 <lambdabot>   "1:[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:57:17 <zygoloid> ski: there you go.
08:57:26 <ksf> ...in fact, it's the data structure version of session types
08:58:07 <ski> zygoloid : see the first version at aformentioned <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23206> :)
08:58:15 <kiris> andgra: have to reconstruct the whole list naturally
08:58:43 <zygoloid> ski: thought you said you had trouble with infinite lists?
08:58:52 <kiris> andgra: but what do you mean "while keeping my 'small' datatype"?
08:59:06 <ski> andgra : which subtree ?
08:59:09 <zygoloid> ski: a CPS-ified one can't work on infinite lists, because CPSification enforces an evaluation order
08:59:12 <ski> zygoloid : for the CPS version, yes
08:59:27 <ski> zygoloid : i was thinking maybe cbn-CPS could alleviate that ..
08:59:30 <ksf> andgra, you're going to have to rebuild the spine from the root to the point of your change.
08:59:46 <andgra> hmm, yeah, I guess it's inevetible
08:59:48 <ksf> ...that usually comes for free, though, as you have to traverse it, anyway.
08:59:59 <ski> andgra : zippers might be useful, though ..
09:00:06 <ksf> that, or fgl.
09:00:38 <danewbie> hi there
09:01:28 <danewbie> does anyone know if gtk2hs allows to query if a font contains a glyph for a given character?
09:01:33 <andgra> well, that's why I asked - I've read about zippers and didn't wanna get into them :P
09:01:38 <andgra> maybe it's worth it tho
09:01:43 <ksf> freetype allows you to do that.
09:01:53 <danewbie> aha
09:02:15 <danewbie> but is freetype the only backend for pango?
09:02:33 <danewbie> ideally i would like to do it from pango
09:02:51 <danewbie> using something like PangoCoverage
09:03:01 <ksf> I don't even know if it uses freetype direcly. It could be using xft (or whats the name of the X font library)
09:03:52 <danewbie> not sure
09:03:57 <ksf> ...with freetype, you get a special NIL glyph code when you query for the glyph of a unicode point that's not in the font
09:04:16 <danewbie> ok
09:04:50 <danewbie> maybe I could use the haskell bindings for freetype to query, and then do my business in pango
09:04:56 <danewbie> though it's a bit ugly...
09:05:08 <ksf> afaik there's no freetype bindings
09:05:27 <danewbie> just found that
09:05:29 <danewbie> http://www.n-heptane.com/nhlab/repos/haskell-freetype/
09:05:36 <ksf> ...except the ones on my disk that I didn't release yet and am hesitant to release now, as my c2hs is defunct
09:05:39 <danewbie> not sure what it is
09:06:19 <ksf> it's going to suffice for your needs
09:06:28 <danewbie> ok
09:06:33 <danewbie> thanks
09:06:59 <ksf> do withFreeType withNewFace getCharIndex
09:07:21 <danewbie> nice
09:07:51 <GNU\colossus> hi folks
09:08:22 <Itkovian> @pl liftM read getLine >>= \n -> liftM (map (\l -> (\(i:s:[]) -> s !! (read i - 1)) $ words l) . take n . lines) getContents >>= \cs -> putStrLn $ Data.List.intersperse '\n' cs
09:08:22 <lambdabot> (line 1, column 55):
09:08:22 <lambdabot> unexpected "["
09:08:22 <lambdabot> expecting "()", natural, identifier, "_" or "("
09:09:20 <zygoloid> @type foldr (\x k r -> let ~(xs, _) = k (,) in r (x:xs) (?cons x xs)) (\r -> r [] ?nil) ?xs (\xs y -> y)
09:09:22 <lambdabot>     Occurs check: cannot construct the infinite type: b = ([a], b)
09:09:22 <lambdabot>       Expected type: [a] -> b -> b
09:09:22 <lambdabot>       Inferred type: [a] -> b -> ([a], b)
09:09:35 <ksf> danewbie, according to http://freetype.org/freetype2/docs/reference/ft2-base_interface.html#FT_Get_Char_Index  0 is the nil value you're looking for
09:09:39 <zygoloid> ^^ i /think/ that would work if fold could cope with the polymorphism of k and r
09:09:49 <GNU\colossus> I don't understand why this lambda function has the type Hugs tells me it has, can anyone please try to explain that to me?:
09:09:52 <GNU\colossus> Hugs> :t (\x y z -> x(z))
09:09:55 <GNU\colossus> \x y z -> x z :: (a -> b) -> c -> a -> b
09:10:25 <Itkovian> GNU\colossus: assign a type t_i to each variable
09:10:31 <zygoloid> GNU\colossus: well, it takes three values, x y and z, of types tx, ty and tz
09:10:32 <Itkovian> and then try to unify those types
09:10:53 <Itkovian> the type of x is something that taklea a type tz and returns something that is the typew of the entire expression
09:11:14 <Itkovian> the type of y is irrelevant
09:11:45 <Itkovian> so, if tz == a and type(expr) == a then x :: b -> a
09:12:22 <Itkovian> @pl liftM read getLine >>= \n -> liftM (map (\l -> (\(i:s) -> (head s) !! (read i - 1)) $ words l) . take n . lines) getContents >>= \cs -> putStrLn $ Data.List.intersperse '\n' cs
09:12:22 <lambdabot> putStrLn . Data.List.intersperse '\n' =<< flip fmap getContents . (map (ap (flip ((!!) . head) . subtract 1 . read . head) tail . words) .) . (. lines) . take =<< fmap read getLine
09:12:25 <Itkovian> yes
09:12:27 <Itkovian> thx!
09:12:51 <NEEDMOAR> Itkovian: your lines frigthen me.
09:12:56 <jmcarthur> we should change or fork quickcheck to use one of these faster number generators and see if it gives us a reasonable speedup. i haven't profiled to see if that's a common bottleneck, but of course that would be a preliminary step before actually writing any more code
09:13:19 <Itkovian> NEEDMOAR: Basically I'm trying to get a program on 1 line :-)
09:13:19 <shapr> jmcarthur: Are you seeing slowdowns?
09:13:36 <Itkovian> said program can be found here (I wrote it): http://www.vlaamseprogrammeerwedstrijd.be/voorbeeld_opgave/oplossing_Haskell.hs
09:13:42 <jmcarthur> shapr: no. the thought just occurred to me that it would be a reasonable thing to look for in profiling
09:13:44 <danewbie> ok, thanks, ksf
09:13:58 <Itkovian> GNU\colossus: You with us, so far?
09:13:59 <jmcarthur> shapr: have you ever compared the speed of smallcheck to that of quickcheck?
09:14:07 <danewbie> i'll try with that
09:14:14 <jmcarthur> shapr: smallcheck generates test cases a *lot* faster most of the time
09:14:29 <Itkovian> NEEDMOAR: given that the ruby people had two lines in their solution
09:14:30 <shapr> Doesn't Smallcheck start from [1..] ?
09:14:34 <zygoloid> Itkovian: liftM read getLine = read <$> getLine. (\(i:s) -> (head s) !! (read i - 1)) = (\(i:s:_) -> s !! (read i - 1))
09:14:36 <jmcarthur> shapr: and i suspect it may have to do with the lack of random num gen
09:14:41 <Itkovian> erm. 4 lines
09:15:10 <jmcarthur> shapr: yeah smallcheck essentially does a bounded enumeration
09:15:18 <GNU\colossus> Itkovian: not really, no :(
09:15:20 <Itkovian> zygoloid: right. I did not think to ignore the tail of the words output
09:15:24 <zygoloid> \cs -> putStrLn $ intersperse '\n' cs = mapM_ putStrLn
09:15:30 <GNU\colossus> I'm still trying to grok your explanations
09:15:48 <Itkovian> GNU\colossus: OK, so let's start easy
09:16:02 * GNU\colossus is all ears
09:16:16 <Itkovian> you have a number of types: the type of the expression, which is the type of the 'function' value and the type of each argument.
09:16:38 <jmcarthur> shapr: i guess the speedup may also have to do with the fact that the test data itself is smaller
09:16:42 <zygoloid> GNU\colossus: ok. so x must be a function because the result is 'x z'. and its argument type (call it 'a') must be the type of 'z'. its result type is the result type of the lambda
09:17:01 <Itkovian> GNU\colossus: so, let's say that \x y z -> x (z) :: te and that x :: tx, y :: ty, and z :: tz
09:17:36 <zygoloid> so x :: a -> b, z :: a, (\x y z -> x z) :: (a -> b) -> ? -> a -> b. and that ? can be anything, so let's call it 'c'.
09:17:42 <Itkovian> Now, the type of y is irrelevant, so it stays ty or anything else you might want to call it, say 'c, as y does not appear in the RHS of the expression, i.e.m, in the function body
09:17:57 <Itkovian> Then, you see that x is a function that is applied to z
09:18:09 <Itkovian> so tx must be something tiog the form t1 -> t2
09:18:10 <GNU\colossus> yeah, I think it's all coming together now for me… :)
09:18:19 <GNU\colossus> thanks very much you guys!
09:18:39 <Itkovian> And as x (z) is the completer body, the type of this fiunction application must be the type of the complete expression, i.e., te so t2 = te
09:18:58 <Itkovian> and then you rename that to the first letters of the alphabet
09:21:49 <Itkovian> zygoloid: hmm, that type of that last part does not check out ...
09:21:56 <Itkovian> read <$> getLine >>= \n -> (map (\l -> (\(i:s:_) -> s !! (read i - 1)) $ words l) . take n . lines) <$> getContents >>= mapM_ putStrLn
09:22:00 <zygoloid> @type mapM_ putStrLn . map (:[]) =<< (\n -> (map ((\(i:s:_) -> s !! (read i - 1)) . words) . take n . lines) <$> getContents) =<< read <$> getLine
09:22:01 <lambdabot> IO ()
09:22:09 <zygoloid> Itkovian: no, thoguth cs was [String] not [Char] :o
09:22:52 <Itkovian> well, we could map show to it :-)
09:22:58 <Itkovian> of map (\c -> [c])
09:23:04 <Itkovian> s/of/or/
09:24:42 <zygoloid> @type (\(n:cs) -> mapM_ putStrLn . map ((\(i:s:_) -> [s !! (read i - 1)]) . words) $ take (read n) cs) =<< lines <$> getContents
09:24:44 <lambdabot> IO ()
09:24:49 <zygoloid> getting better...
09:25:02 <Itkovian> this should do it yeah
09:25:33 <zygoloid> must there always be exactly two words on the second and subsequent lines?
09:25:44 <Itkovian> no, but there are
09:25:59 <Itkovian> the first word is the index of the char, the secodn the word to look in
09:25:59 <zygoloid> so it has to deal with there being more than two words? or not?
09:26:04 <Itkovian> it does not
09:26:11 <zygoloid> @type (\(n:cs) -> mapM_ putStrLn . map ((\[i,s] -> [s !! (read i - 1)]) . words) $ take (read n) cs) =<< lines <$> getContents
09:26:12 <lambdabot> IO ()
09:26:19 <zygoloid> ^^ a little tweak then.
09:26:34 <Itkovian> hmm, I'd have to parse that
09:27:13 <Itkovian> right, cool.
09:27:36 <zygoloid> @type (\(n:cs) -> mapM_ (putStrLn . (\[i,s] -> [s !! (read i - 1)]) . words) $ take (read n) cs) =<< lines <$> getContents
09:27:37 <lambdabot> IO ()
09:28:38 <Itkovian> let's see if that still works
09:29:08 <Itkovian> it does :-)
09:29:11 <Itkovian> you gotta love types
09:29:32 <zygoloid> not sure how much more you can squeeze out of it
09:29:46 <Itkovian> well, it's more readable than my initial oneliner
09:29:47 <zygoloid>  @pl doesn't really help much.
09:29:55 <Itkovian> right
09:30:12 <zygoloid> i don't like the \(n:cs) really, it reads in the wrong order
09:30:37 * zygoloid ponders a reverse-lambda syntax: (foo <- (n:cs)/)
09:30:39 <Itkovian> if you put the lines <$> getContents >>= up front, it's ok, I guess
09:30:42 <zygoloid> yeah
09:31:55 <Itkovian> Ah well, the original shows best how we expect the teams to do IO, I think.
09:32:53 <zygoloid> @pl lines <$> getContents >>= (\((read -> n):cs) -> mapM_ (putStrLn . (\[read -> i,s] -> [s!!(i-1)]) . words) $ take n cs)
09:32:54 <lambdabot> (line 1, column 36):
09:32:54 <lambdabot> unexpected "-"
09:32:54 <lambdabot> expecting operator or ")"
09:35:06 <Itkovian> I mean the original that is not a single line
10:02:48 <Arnar> I'm looking for a function..
10:02:58 <opqdonut> none here, boss
10:02:58 <Arnar> :hoogle (a -> [b]) -> a -> [b]
10:03:09 <Arnar> no sorry
10:03:14 <opqdonut> :t id :: (a -> [b]) -> a -> [b]
10:03:15 <lambdabot> forall a b. (a -> [b]) -> a -> [b]
10:03:19 <opqdonut> there?-)
10:03:26 <Arnar> @hoogle (a -> [a]) -> a -> [a]
10:03:27 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
10:03:27 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
10:03:27 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
10:03:41 <opqdonut> what should it do?
10:03:45 <Arnar> it's sort of like iterate.. but a monadic version
10:03:57 <Arnar> for example
10:04:01 <Arnar> lets call it iter
10:04:17 <Arnar> iter (\x -> [x+1]) 0 = [1,2,3,4,...]
10:04:44 <benmachine> @hoogle iterateM
10:04:44 <lambdabot> No results found
10:04:44 <Arnar> i'm happy with a list only version, but I think it can be defined for any monadplus
10:04:47 <benmachine> hmm
10:04:48 <bos> yummy attoparsec performance goodness: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
10:04:56 <ksf> :t scanl
10:04:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:05:01 <zygoloid> @type \f -> fix (>>= f)
10:05:02 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
10:05:17 <ksf> :t unfoldr
10:05:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:05:20 <Arnar> hmm
10:05:36 <ksf> > unfoldr (\x -> Just (x+1)) 0
10:05:37 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
10:05:50 <Arnar> my last attemt was  iter f x0 = f x0 >>= iter f
10:05:52 <ksf> > unfoldr (\x -> Just (x, x+1)) 0
10:05:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
10:06:33 <Arnar> why the pair?
10:06:58 <ksf> the first x gets past in in the next iteration
10:07:01 <ksf> er no.
10:07:19 <ksf> the first is returned as list element, the second one gets passed on.
10:07:19 <zygoloid> Arnar: what should this function do?
10:07:38 <zygoloid> Arnar: isnt' it just concat . iterate?
10:07:40 <Arnar> zygoloid: it should iterate a nondeterministic function
10:07:44 <Arnar> :t concat . iterate
10:07:45 <lambdabot>     Couldn't match expected type `[[a]]'
10:07:45 <lambdabot>            against inferred type `a1 -> [a1]'
10:07:45 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
10:08:06 <benmachine> :t \f - concat . iterate f
10:08:06 <Arnar> :t \f -> concat . (iterate f)
10:08:07 <lambdabot> parse error on input `-'
10:08:07 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a]
10:08:12 <benmachine> whoops
10:08:23 <Arnar> I have a function a -> [a]
10:08:28 <benmachine> hmm
10:08:31 <Arnar> and i want to iterate it..
10:08:34 <Arnar> starting with a value of type a
10:08:47 <Arnar> (a -> [a]) -> a -> [a]
10:09:19 <benmachine> if your function is (\x -> [x, x + 1])
10:09:26 <ksf> :t concat . unfoldr
10:09:27 <lambdabot>     Couldn't match expected type `[[a]]'
10:09:27 <lambdabot>            against inferred type `b -> [a1]'
10:09:27 <lambdabot>     Probable cause: `unfoldr' is applied to too few arguments
10:09:27 <benmachine> then how would that behave exactly
10:09:29 <Arnar> iter f x = do { y <- f x ; [y]++(iter f y) }
10:09:35 <ksf> :t concat . unfoldr f
10:09:36 <lambdabot> forall a b. (Show b, SimpleReflect.FromExpr (Maybe ([a], b))) => b -> [a]
10:09:50 <ksf> > concat . unfoldr f
10:09:52 <lambdabot>   No instance for (SimpleReflect.FromExpr
10:09:52 <lambdabot>                     (Data.Maybe.May...
10:09:57 <Arnar> :t \f x -> do { y <- f x ; [y]++(iter f y) }
10:09:58 <lambdabot> Not in scope: `iter'
10:10:20 <benmachine> :t fix \iter f x -> do { y <- f x; y : iter f y }
10:10:20 <Arnar> let iter f x = do { y <- f x ; [y]++(iter f y) } in iter (\x -> [x,x+1]) 0
10:10:21 <lambdabot> parse error on input `\'
10:10:27 <benmachine> :t fix $ \iter f x -> do { y <- f x; y : iter f y }
10:10:28 <lambdabot> forall b. (b -> [b]) -> b -> [b]
10:10:36 <Arnar> aha
10:11:02 <benmachine> :t let iter f x = f x >>= \y -> y : iter f y in iter
10:11:03 <lambdabot> forall a. (a -> [a]) -> a -> [a]
10:11:17 <ksf> @pl let iter f x = f x >>= \y -> y : iter f y in iter
10:11:17 <lambdabot> fix (liftM2 flip ((>>=) .) . (ap (:) .))
10:11:27 <benmachine> let iter f x = f x >>= \y -> y : iter f y in iter (\x -> [x, x + 1]) 1
10:11:31 <benmachine> > let iter f x = f x >>= \y -> y : iter f y in iter (\x -> [x, x + 1]) 1
10:11:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:11:33 <Arnar>  > let iter f x = f x >>= \y -> y : iter f y in iter (x -> [x,x+1]) 0
10:11:35 <benmachine> heh
10:11:38 <benmachine> whoops.
10:11:51 <benmachine> > let iter f x = f x >>= \y -> y : iter f y in iter (\x -> [x + 1, undefined]) 1
10:11:52 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:11:54 <benmachine> hmm
10:11:58 <benmachine> not quite what you wanted!
10:12:02 <Arnar> hmm.. nope :)
10:12:13 <benmachine> so I assume anyway
10:12:16 <Arnar> :t \f x -> do { y <- f x ; y:(iter f y) }
10:12:17 <lambdabot> Not in scope: `iter'
10:12:25 <benmachine> what *do* you want? there are several possible functions with this type
10:12:34 <Arnar> :t let iter f x = do { y <- f x ; y:(iter f y) } in iter
10:12:35 <lambdabot> forall b. (b -> [b]) -> b -> [b]
10:12:49 <Arnar> > let iter f x = do { y <- f x ; y:(iter f y) } in iter (\x -> [x,x+1]) 0
10:12:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:12:52 <Arnar> grr
10:12:59 <Arnar> ok..
10:13:00 <Arnar> from this:
10:13:05 <Arnar> > let iter f x = do { y <- f x ; y:(iter f y) } in iter (\x -> [x+1]) 0
10:13:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:13:10 <Arnar> I wanted that :)
10:13:14 <Arnar> aaah
10:13:18 <Arnar> this *is* what I want
10:13:21 <Arnar> it's just depth first..
10:13:24 <benmachine> heh
10:13:26 <benmachine> yes
10:13:28 <Arnar> hence the 0,0,0,0...
10:13:30 <benmachine> indeed
10:13:46 <benmachine> testing on functions that always return a non-empty list may be deceptive
10:13:47 <Arnar> > let iter f x = do { y <- f x ; y:(iter f y) } in iter (\x -> if x < 10 then [x+1] else []) 0
10:13:48 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:14:02 <Arnar> > let iter f x = do { y <- f x ; y:(iter f y) } in iter (\x -> if x < 10 then [x+1, (-x)] else []) 0
10:14:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,-9,...
10:14:09 <benmachine> hah, neat
10:14:16 <Arnar> excellent :D
10:14:18 <Arnar> thanks!
10:14:19 <Arnar> btw..
10:14:27 <Arnar> what I actually want to use it for is:
10:14:29 <benmachine> @undo do { y <- f x ; y:(iter f y) }
10:14:29 <lambdabot> f x >>= \ y -> y : (iter f y)
10:14:44 <ski> > let iter f x = do {return x} `mplus` do { y <- iter f x; f y } in iter (\x -> [2*x,2*x+1]) 1 :: [Integer]
10:14:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:14:47 <Arnar> bishopWalk = iter (go (Up + Right))
10:15:03 <Arnar> ski: there we go..
10:15:24 * ski hasn't really been listening much, so is not sure whether that's what you're after or not ..
10:15:33 <zygoloid> > let iterateM f x = let v = f x in v `mplus` (v >>= iterateM f) in iterateM (\x -> [x+1]) 0
10:15:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:15:47 <Arnar> ski: looks like it..
10:15:50 <zygoloid> @type let iterateM f x = let v = f x in v `mplus` (v >>= iterateM f) in iterateM
10:15:51 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> a -> m a
10:15:56 <pikhq> @@ pl undo do y <- f x; y : (iter f y)
10:15:56 <lambdabot>  pl undo do y <- f x; y : (iter f y)
10:16:02 <pikhq> Curses.
10:16:05 <pikhq> @@ @pl undo do y <- f x; y : (iter f y)
10:16:05 <lambdabot>  (line 1, column 17):
10:16:05 <lambdabot> unexpected ";"
10:16:05 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
10:16:08 <pikhq> @@ @pl @undo do y <- f x; y : (iter f y)
10:16:08 <lambdabot>  ap (:) (iter f) =<< f x
10:16:10 <ski> zygoloid : now try with `\x -> [2*x,2*x+1]' ?
10:16:23 <zygoloid> > let iterateM f x = let v = f x in v `mplus` (v >>= iterateM f) in iterateM (\x -> [2*x, 2*x+1]) 0
10:16:24 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
10:16:40 <Arnar> whoops
10:16:44 <ski> sorry, you need to start with `1', too
10:16:48 <zygoloid> > let iterateM f x = let v = f x in v `mplus` (v >>= iterateM f) in iterateM (\x -> [2*x, 2*x+1]) 1
10:16:49 <lambdabot>   [2,3,4,5,8,9,16,17,32,33,64,65,128,129,256,257,512,513,1024,1025,2048,2049,...
10:17:07 <zygoloid> well, it's depth-first. is that ok? :)
10:17:09 <pikhq> @@ @pl @undo \f x -> do y <- f x; y : (iter f y)
10:17:09 <lambdabot>  liftM2 flip ((>>=) .) (ap (:) . iter)
10:17:14 <zygoloid> > let iterateM f x = let v = f x in v `mplus` (v >>- iterateM f) in iterateM (\x -> [2*x, 2*x+1]) 1
10:17:15 <lambdabot>   [2,3,4,6,5,7,8,12,10,14,9,13,11,15,16,24,20,28,18,26,22,30,17,25,21,29,19,2...
10:17:19 <Arnar> yes.. depth first is ok
10:17:28 <Arnar> I won't be using it on infinite lists
10:17:31 <zygoloid> LogicT to the rescue
10:17:45 <ski> zygoloid : well, we just need to wait \omega elements, then we should start getting elements from the other branches, too ;)
10:17:55 <Arnar> :)
10:18:30 <ski> Arnar : if you want breadth-first, though, the above trick will probably work as well
10:18:43 <Arnar> ski: which one?
10:18:55 <ski> the one i fed to lambdabot
10:19:09 <Arnar> > let iter f x = do {return x} `mplus` do { y <- iter f x; f y } in iter (\x -> [2*x,2*x+1]) 1 ::
10:19:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:19:12 <Arnar>              [Integer]
10:19:22 <Arnar> > let iter f x = do {return x} `mplus` do { y <- iter f x; f y } in iter (\x -> [2*x,2*x+1]) 1 :: [Integer]
10:19:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:19:25 <Arnar> this one..
10:19:56 <ski> `\x -> [2*x,2*x+1]' maps each node element to the list of elements in the roots of the children
10:20:11 <ski> and `1' is the element in the global root
10:20:56 <Arnar> :t (>>-)
10:20:57 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
10:21:08 <Arnar> wait.. are you kidding me?
10:21:22 <Arnar> if I have [x] and want to get MonadLogic m => m x
10:21:28 <Arnar> I just change >>= to >>- ?
10:21:36 * ezyang is learning about posets! 
10:21:45 <ezyang> Arnar: No.
10:21:47 <ski> (hm, btw, iirc, that trick had problems with finite lists .. haven't figured out a nice way to fix that)
10:22:18 <ezyang> Arnar: (msum . map return) [1,2,3]
10:22:19 <Arnar> ok
10:22:36 <ezyang> I believe this works for infinite lists too
10:22:38 <Arnar> ezyang: pardon?
10:22:47 <ski> @type foldr (mplus . return) mzero
10:22:48 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
10:22:57 <zygoloid> > let iterateM f x = let go v = v `mplus` go (v >>= f) in go (return x) in iterateM (\x -> [2*x, 2*x+1]) 1
10:22:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:23:01 <ezyang> And MonadLogic implements MonadPlus
10:23:35 <ezyang> >>- has a different function in the logic monad; it's a "fair conjunction"
10:24:00 <ski> > let iterateM f x = let go v = v `mplus` go (v >>= f) in go (return x) in iterateM (\x -> guard (x < 10) >> [2*x, 2*x+1]) 1
10:24:04 <lambdabot>   mueval-core: Time limit exceeded
10:26:00 <ezyang> The arrows... they're everywhere!
10:26:05 <ezyang> unfortunately, they rarely are computable >.>
10:27:34 <zygoloid> > let iterateM f x = let go v = v `mplus` go (v >>= f) in go (return x) in iterateM (\x -> [2*x, 2*x+1]) 0
10:27:36 <lambdabot>   [0,0,1,0,1,2,3,0,1,2,3,4,5,6,7,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,...
10:37:21 <chrisdone> reet
10:38:37 <Alpounet> bos, very interesting post
10:39:41 <MaciejP> benmachine: Yay, it took me 2 hours to understand how your applyMatches function works but finally I got it.
10:39:55 <benmachine> MaciejP: that's still considerably shorter than it took me to write it >_>
10:40:11 <benmachine> slash rewrite it
10:40:15 <benmachine> slash rewrite it again
10:40:20 <benmachine> got it wrong like three times
10:41:04 <benmachine> so if it's hard to understand that just means you're normal :P
10:41:08 <benmachine> (relatively speaking, that is)
10:42:08 <MaciejP> extT was the key for me
10:42:32 <benmachine> mkT = (id `extT`)
10:42:50 <benmachine> (in case that helps, which it might not)
10:43:30 <MaciejP> Yeah, I didn't understand how to write a function for gmapT that can handle *all* types of Data a
10:44:00 <benmachine> one of my Things To Do some day is write a syb tutorial I think
10:44:11 <benmachine> because it took a while for me to "get it"
10:44:30 <benmachine> mostly playing around with cast and gmapT in ghci
10:45:31 <Arnar> thanks all for the iter help
10:45:50 <Arnar> ski: the one you posted looked promising.. but fails if the lists are finite
10:46:12 <Arnar> in the end I used just this (depth-first) one:
10:46:19 <Arnar> iter f x = f x >>= \y -> y:(iter f y)
10:49:47 <aavogt> benmachine, MaciejP: I'm doing something similar with haskell-src-exts and syb, but I'm not directly using gmap. Am I missing out on stuff?
10:49:57 <benmachine> not necessarily
10:50:02 <aavogt> or gfoldl
10:50:08 <benmachine> I'm not using gfolfl
10:50:09 <benmachine> it's scary
10:50:32 <benmachine> I used to use everywhere and everywhere' but for my purposes they proved slightly inadequate
10:50:36 <mauke> grofl
10:50:36 <benmachine> for complicated reasons
10:50:45 <benmachine> gfluffle
10:50:48 <aavogt> well with haskell-src-exts, sometimes you have to go up a level to delete stuff...
10:51:00 <aavogt> benmachine: that's the sort of limitation you have with everywhere?
10:51:17 <benmachine> no, the problem that I had was that
10:51:33 <benmachine> the transformation I was applying was replacing Vars with Exps
10:51:37 <benmachine> according to matching rules
10:52:03 <benmachine> but in certain circumstances, I wanted to not-replace because I was entering e.g. a lambda that shadowed an outer binding
10:52:32 <benmachine> I used to use everywhereBut but I think it didn't work on mutually recursive binds, or something
10:52:36 <benmachine> I don't recall the details
10:52:44 <aavogt> interesting
10:53:02 <benmachine> (everywhereBut would have to do it one bind at a time, and that could potentially go wrong)
10:54:11 <ksf> ...if in doubt, split one pass in two.
10:54:23 <ksf> especially if said pass involves mutating
10:54:51 <aavogt> twice as slow... but that doesn't seem to be a problem yet
10:55:10 <ksf> you can always fuse them later, if possible.
10:55:31 <ksf> map f . map g = map (f.g) just doesn't hold for many things more complicated than maps
10:55:56 <FliPPeh_1> What is Text.Xhtml doing to my HTML?
10:56:12 <ben> Adding an X, presumably
10:56:12 <FliPPeh_1> "<body\n  ><h1\n    >Hello world</h1\n    ></body\n  ></html\n>"
10:56:25 <ben> Avoiding significant whitespace you did not specify
10:56:29 <FliPPeh_1> Jamming newlines in there like it owns the place1
10:56:30 <FliPPeh_1> !!
10:56:37 <benmachine> heh
10:56:39 <benmachine> basically
10:56:49 <benmachine> whitespace inside tags can be ignored according to the spec
10:56:49 <benmachine> always
10:56:59 <benmachine> whitespace outside tags is sometimes significant, sometimes not
10:57:09 <benmachine> so it's easier to never have any outside the tags
10:57:10 <FliPPeh_1> i understand
10:57:13 <sinelaw> someone please kick peanut_bu
10:57:15 <benmachine> (except when you explicitly want it)
10:57:17 <sinelaw> sending me ads
10:57:21 <FliPPeh_1> But why does it in the first place?
10:57:23 <sinelaw> kick/ban
10:57:33 <ksf> to make the output readable?
10:57:39 <c_wraith> You can tell it to add no whitespace at all
10:57:45 <c_wraith> Which is what I chose to do
10:57:49 <FliPPeh_1> Ah nice
10:57:52 <FliPPeh_1> How?
10:57:59 <c_wraith> It's a different function
10:58:05 <c_wraith> I don't remember the name of it
10:58:15 <c_wraith> But it converts to a string without adding whitespace
10:58:29 <FliPPeh_1> I'll have a look at it, thanks :)
10:58:30 <sinelaw> dons, kick/ban peanut_bu
10:58:40 <sinelaw> or shapr
10:58:49 <sinelaw> or whoever.
10:58:50 <ksf> sinelaw, if in doubt, there's staffers
10:59:02 --- mode: ChanServ set +o mauke
10:59:02 --- kick: peanut_bu was kicked by mauke (peanut_bu)
10:59:02 --- mode: mauke set +b *!*@95.66.37.243
10:59:06 <sinelaw> thank you.
10:59:08 <ksf> I don't think our chanops can kick someone from the server.
10:59:13 <benmachine> yeah
10:59:30 <sinelaw> @faq can haskell kick someone from the server?
10:59:30 <lambdabot> The answer is: Yes! Haskell can do that.
10:59:34 <benmachine> heh
11:01:02 --- mode: mauke set -o mauke
11:01:57 <chrisdone> FliPPeh_1: the default show instance for Html is renderHtml, you might prefer showHtml or prettyHtml
11:02:04 <chrisdone> http://hackage.haskell.org/packages/archive/xhtml/3000.0.1/doc/html/Text-XHtml-Strict.html#v%3AshowHtml
11:02:26 <chrisdone> instance Show Html where
11:02:27 <chrisdone>       showsPrec _ html = showString (renderHtmlFragment html)
11:07:15 <Arnar> hmm
11:07:22 <Arnar> I have a monad which is essentially  St.StateT (State g) [] a
11:07:33 <Arnar> automatically newtypederiving Monad
11:07:36 <sinelaw> ok so I have this idea: I need to process things using an imperative library that takes a pre-allocated pointer for the output data
11:07:40 <roconnor> @quote maiden
11:07:40 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
11:07:52 <Arnar> and I do (inside do block) x <- bla   where bla :: [b]
11:07:54 <sinelaw> but it's basically a pure function: Ptr a -> Ptr a
11:08:07 <Arnar> then I was expecting x :: b -- am I way off here?
11:08:29 <sinelaw> how can i wrap that purely?
11:08:49 <sinelaw> not using alloca, because i really want the memory to be pre-allocated and reused (it's a pretty huge chunk)
11:09:30 <ksf> ForeignPtr?
11:09:39 <ksf> plus a bit of unsafePerformIO
11:09:55 <ksf> keep in mind that it's utterly non-threadsafe
11:10:14 <sinelaw> that's the problem
11:10:27 <jmcarthur> @unmtl StateT (State g) [] a
11:10:28 <lambdabot> err: `State g' is not applied to enough arguments, giving `/\A. g -> (A, g)'
11:10:31 <ksf> then take a TVar before doing anything
11:10:36 <sinelaw> and ForeignPtr means I will have to use it inside a withForeignPtr, and all that within a IO monad
11:10:38 <jmcarthur> Arnar: i don't understand your tranformer stack
11:11:05 <ksf> don't be afraid of unsafePerformIO when dealing with the ffi
11:11:14 <zygoloid> Arnar: yes, you're off. but not way off. if you want to use stuff from the inner monad you need to use 'lift'
11:11:33 <jmcarthur> x <- lift bla
11:11:35 <Arnar> zygoloid: doh'
11:11:47 <ksf> ...you have to use IO anyway, to use peek/poke
11:11:53 <sinelaw> ksf, so i'll need to unsafePerformIO stuff that uses an external TVar?
11:11:56 <Arnar> jmcarthur: my stack is StateT on top of the list/nondet monad
11:11:58 <zygoloid> @type (do x <- lift [1,2,3]; return x) :: StateT g [] Int
11:11:59 <lambdabot> forall g. StateT g [] Int
11:12:06 <sinelaw> i can't see how i get the memory to be reused between calls
11:12:07 <ksf> sinelaw, yep.
11:12:10 <zygoloid> Arnar: i assume that's the monad stack you meant
11:12:16 <Arnar> zygoloid: yes.. indeed
11:12:19 <Arnar> sorry for the brainfart
11:12:36 <jmcarthur> Arnar: i was just confused about your State g part of that since it's the wrong kind, but it now occurs to me that maybe you have redefined State in your scope to something else, so nevermind
11:12:39 <ksf> ...take the tvar before serializing the haskell data to the pre-allocated memory
11:12:50 <sinelaw> hmm
11:12:55 <Arnar> jmcarthur: ah.. State g is an associated type
11:12:58 <ksf> but I don't think not doing alloca will gain you performance
11:13:17 <Arnar> should have removed it from the paste
11:13:35 <Arnar> i.e. it is not Control.Monad.State.State
11:13:40 <zygoloid> @hoogle Foreign.Marshal.with
11:13:40 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
11:13:40 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
11:13:41 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
11:13:43 <sinelaw> ksf, i'm avoiding alloca because of my assumption that it limits the scope in which you can share the allocated memory
11:13:50 <sinelaw> not because of performance
11:14:36 <sinelaw> another problem is that Haskell gets a pointer to an opaque struct
11:14:40 <ksf> ...I don't think sharing memory will gain you performance, either.
11:15:07 <zygoloid> sinelaw: with undefined $ \p -> do foreignThing p; peek p
11:15:08 <sinelaw> ksf, why? re-allocating buffers at each function call won't be slow?
11:15:23 <ksf> haskell allocates all the time
11:15:28 <zygoloid> assuming foreignThing :: Ptr p -> IO a
11:15:36 <ksf> it's not like in C, where a malloc is expensive
11:15:46 <sinelaw> ksf, exactly, but it's the C that does the allocations here
11:15:52 <ksf> oh
11:16:08 <sinelaw> maybe i can avoid that too
11:16:13 <ksf> figure out the adress of whoever did that.
11:16:56 <sinelaw> OpenCV
11:17:14 <stevenmarky> no, I'm shy
11:17:55 <ksf> stevenmarky, you're saying that quite assertively.
11:24:57 <Arnar> zygoloid: sorry for re-reraising the issue, but in the above bla is actually :: (MonadState g s) s [a]
11:25:03 <Arnar> so I need something more than lift
11:33:23 <regalia> RWH calls for Text.Regex.Posix
11:33:33 <regalia> and I can't find it in ghci =\
11:34:05 <twink> Why is malloc() expensive in C?
11:34:51 <pikhq> twink: Memory allocation is expensive in general.
11:35:26 <zakwilson> I'm experimenting with TokyoCabinet.TDB as documented here: http://tom-lpsd.github.com/tokyocabinet-haskell/Database-TokyoCabinet-TDB.html - the example code given there fails to compile with a parse error at line 24, column 27 with a parse error on input "->"
11:35:50 <twink> pikhq: Why more so in C than e.g. Haskell?
11:37:09 <aavogt> twink: you mean for haskell code that does allocations behind your back, or explicit calls using stuff from Foreign.*
11:37:48 <roconnor> @type real2frac
11:37:49 <lambdabot> Not in scope: `real2frac'
11:37:54 <twink> aavogt: Whatever ksf and sinelaw were going on about.
11:37:55 <roconnor> @type realToFrac
11:37:56 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:37:58 <MaciejP> regalia: Is that what you're looking for: http://hackage.haskell.org/packages/archive/regex-posix/0.93.1/doc/html/Text-Regex-Posix.html ?
11:38:48 <regalia> MaciejP: Yes, I just use cabal to install the package?
11:39:09 <MaciejP> Yes, cabal install regex-posix
11:39:26 <regalia> MaciejP: Thanks :)
11:39:28 <aavogt> twink: well my understanding is that malloc() allocates from the OS, while   let x = f something,  does some allocation of memory that the RTS may already have grabbed from the OS
11:39:57 <mauke> aavogt: your understanding is flawed
11:40:07 <aavogt> could you correct me?
11:40:18 <mauke> my understanding is that having a garbage collector can simplify the allocator a lot
11:41:09 <mauke> malloc needs to track free chunks of memory to semi-efficiently locate a suitable block when you ask for one
11:41:32 <mauke> AFAIK the GHC RTS just increments a pointer
11:45:25 <twink> No, malloc() has some 2-layer thing where there's memory freed by callers not yet returned to the kernel etc.
11:45:51 <twink> Not sure how much is due to fragmentation vs. policy.
11:46:21 <Ytinasni> aavogt: having a GC makes the alloc routine smaller, at the cost of time spent in doing GC. This tends to be faster (overall) than malloc/free because of cache effects.
11:46:52 <twink> There's some amortization that goes on that makes allocation ops shorter but there's some trickiness about overall speed.
11:50:50 <sinelaw> what's the difference between TVars and MVars?
11:51:22 <mauke> TVars are like IORefs
11:51:27 <mauke> MVars are different
11:52:00 <sinelaw> oh they are different, that's the difference!
11:52:09 <twink> I think if you average over the lifetime of a program GC usually wins, but you get into trouble with things like standing servers' worst-case response times.
11:52:23 <mauke> sinelaw: MVars are either full or empty
11:52:37 <mauke> sinelaw: writing to a full MVar and reading from an empty MVar blocks
11:52:48 <shapr>  /wi Guest99035
11:52:56 <shapr> oops
11:55:18 <sinelaw> so MVars are like a little semaphore-locked var?
11:55:55 <sinelaw> s/like a little/a little like/
11:57:13 <twink> How's a TVar differ?
12:00:01 <ksf> newtype TMVar a = TVar (Maybe a)
12:00:16 <ksf> ...they're just threadsafe IORefs
12:00:39 <ksf> MVars write-block on Just and read-block on Nothing
12:00:40 <Twey> Well, STM'd IORefs
12:01:01 <Twey> Bit more than thread-safe in the usual definition
12:01:04 <twink> TVars are never empty, then?
12:01:09 <ksf> nope
12:02:11 <ksf> if you want to grok them, just look at how TMVars are implemented in terms of them
12:03:41 <ksf> ...the trick with TVars, though, is that if you retry (the STM function) after reading one, you won't read it again until it changed.
12:04:19 <ksf> ...or rather, any TVar you read changes.
12:05:01 <sinelaw> i'll watch some videos on STM
12:05:17 <ksf> there's a nice one with spj in his red pullover on oscon
12:05:35 <sinelaw> yeah i'm downloading that now
12:08:28 <benmachine> @hoogle Language.C
12:08:28 <lambdabot> Language.Haskell.TH data Callconv
12:08:29 <lambdabot> Language.Haskell.TH.Syntax data Callconv
12:08:29 <lambdabot> Language.Haskell.TH CaseE :: Exp -> [Match] -> Exp
12:08:31 <benmachine> hmm
12:14:51 <roconnor> ugh!
12:15:19 <FunctorSalad> I'm a bit confused... if you are chaining functions which transform some kinds of streams together, is a continuation-using scheme like for example in the `generator' package more efficient than the more straightforward [a] -> [b]?
12:15:38 <FunctorSalad> or monadic lists if the streams involve IO
12:16:03 <roconnor> I just realized I fell into the troll of "Oh, the data.time library is horrible, see there is no nice way to write this code!" and then I go and tell them the nicer way of writing it.
12:16:26 <roconnor> what is the techincal term for that type of trolling/asking a question?
12:16:42 <FunctorSalad> I thought there was only constant overhead with plain lists, too (as long as the transformers only eat one or a few elements of the input at a time)
12:17:42 <ksf> sclv is a troll?
12:17:44 <quicksilver> roconnor: it's not trolling, because the intention really is to elicit an answer
12:17:54 <roconnor> ah true
12:18:01 <quicksilver> (in trolling the intention is to cause heat / light / provokation)
12:18:14 <roconnor> but is there a techincal term for this form of question asking?
12:18:19 <stevenmarky> yeah
12:18:33 <quicksilver> it closely related to the old adage that the fastest way to get an answer from a usenet group is to post a wrong statement
12:18:34 <stevenmarky> socratic method I think
12:18:45 <FunctorSalad> it doesn't even look like a question
12:18:51 <FunctorSalad> (the quoted part)
12:19:04 <quicksilver> any, sclv is clearly on the side of the angels ;)
12:19:08 <quicksilver> s/any/anyhow/
12:19:56 <FunctorSalad> stevenmarky: AIUI, socratic is if you go along with someone else's opinion (which you intend to show to be absurd)
12:20:42 <ksf> I'd call it ranting
12:21:53 <quicksilver> I thought socratic was demonstrating an argument by using two fictional identities who assume extreme views enabling the truth to come out
12:21:55 <stevenmarky> But I think the common opinion was that the time library is horrible
12:22:10 <quicksilver> it's not as horrible as most people think, but it's badly documented.
12:22:32 <quicksilver> in particular, some of its important functionality is hidden inside instances
12:22:39 <quicksilver> (it's not great, all the same)
12:22:41 <FunctorSalad> IMO the issue is that it makes easy things complicated. Otherwise it's fine
12:22:43 <mauke> I think none of you know what the socratic method is
12:22:44 <ksf> socratic is to make your opponent express every consequence of his initial fallacy, leading him to contradiction.
12:22:51 <FunctorSalad> and names like nominalDiffTime
12:22:57 <FunctorSalad> or diffNominalTime...
12:23:01 <FunctorSalad> (?)
12:23:47 <FunctorSalad> mauke: so enlighten us?
12:24:07 <danlei> socratic means also to make the other one remember what he already knows (ideas), also called maieutics
12:24:11 <ksf> he doesnt' need to, I'm right.
12:24:46 <danlei> and, yes it often ends in apeiron
12:24:46 <FunctorSalad> danlei: yes, that's what I meant by "going along" :)
12:24:52 <danlei> :)
12:25:29 <danlei> hm, not apreiron, what was it called?
12:25:31 <FunctorSalad> (maybe the leapsecond stuff should be in an ".Advanced" module or package)
12:25:34 <danlei> aporie in german
12:25:35 <roconnor> FunctorSalad: I maintain that Data.Time only makes complicated things complicated
12:26:09 <FunctorSalad> roconnor: if you know what the functions are called, easy things are easy, granted
12:26:22 <ksf> wikipedia says aporia
12:26:36 <danlei> yes
12:26:53 <ksf> eris is a master of that one.
12:27:16 <FunctorSalad> (and, as quicksilver mentioned, know that you're supposed to use fromIntegral/realToFrac)
12:28:25 <roconnor> yes, there is certainly a documentation issue with Data.Time
12:28:51 <roconnor> Perhaps I feel a kindred with Data.Time because my Data.Colour library is almost as "complicated".
12:29:03 <FunctorSalad> :)
12:29:26 <ksf> we should all just switch to the discordian calendar, it's way less confusing than the gregorian one.
12:29:44 <jmcarthur> wait a sec. DiffTime is an instance of Num? ew
12:29:44 <Arnar> when a monad transformer stack is on top of the list monad.. you have to lift, lift, lift all the time
12:29:48 <FunctorSalad> with Data.Colour, I always wondered how can you hope to get color calibrations right in the first place if you don't have data for your monitor
12:30:10 <stepcut> any idea why the 'binary' package is hidden by default (at least in 6.13)
12:30:12 * jmcarthur wonders what 4 seconds * 5 seconds is in seconds
12:30:13 <Arnar> is there an implementation of the list (nondeterminism) monad which has an associated type class?
12:30:14 <FunctorSalad> (there's sRGB mode but that limits the gamut)
12:30:14 <ksf> ...linux supported it for ages, now, why is haskell lacking behind?
12:30:17 <roconnor> FunctorSalad: you just use sRGB and forget about the issues
12:30:44 <stepcut> jmcarthur: 20 seconds squared
12:30:48 <FunctorSalad> (and I don't think my laptop display has an sRGB setting)
12:30:59 <jmcarthur> stepcut: "in seconds"
12:31:06 <stepcut> (20 seconds) seconds ?
12:31:24 <jmcarthur> stepcut: (*) :: DiffTime -> DiffTime -> DiffTime
12:31:33 <FunctorSalad> Arnar: ListT package?
12:31:45 <stepcut> perhaps difftime is unitless ?
12:32:01 <FunctorSalad> Arnar: err, "List" package, "ListT" is the module
12:32:02 <jmcarthur> stepcut: it's specified that conversion functions treat numbers as seconds
12:32:17 <stepcut> jmcarthur: sounds like trouble
12:32:18 * sm__ likes Data.Time
12:32:32 * Twey likes Acme.Now
12:32:39 <Arnar> FunctorSalad: it doesn't have a MonadList class
12:32:49 <jmcarthur> stepcut: exactly :(
12:32:49 <FunctorSalad> NominalDiffTime and UTCTime should be an affine space / vector space pair
12:32:58 <FunctorSalad> with pretty operators...
12:32:59 <jmcarthur> definitely
12:33:17 * jmcarthur is the one that proposed that
12:33:24 <FunctorSalad> Arnar: Data.List.Class?
12:33:29 <FunctorSalad> (in the List package)
12:33:37 <roconnor> FunctorSalad: leap seconds mess that up
12:34:17 * jmcarthur would rather keep gregorian things separated from the rest
12:34:48 <FunctorSalad> roconnor: hmm I thought these two were the ones which ignored the leap seconds
12:34:56 <Arnar> @info Data.List.Class
12:34:56 <lambdabot> Data.List.Class
12:35:15 <Arnar> FunctorSalad: sorry.. what package?
12:35:25 <roconnor> FunctorSalad: well, nominalDiffTime has no leap seconds and UTCDoes
12:35:40 <FunctorSalad> class (MonadPlus l, Monad (ItemM l)) => List l where
12:35:40 <FunctorSalad>   runList :: l a -> ItemM l (ListItem l a)
12:35:40 <FunctorSalad>   joinL :: ItemM l (l a) -> l a
12:35:40 <FunctorSalad>         -- Defined in Data.List.Class
12:35:44 <FunctorSalad> Arnar: `List'
12:36:02 <FunctorSalad> ItemM is associated with that class, :info doesn't tell
12:36:16 <FunctorSalad> where ... type ItemM l :: *
12:36:48 <roconnor> FunctorSalad: Actually, I think it is impossible to take the absolute time difference of two UTCTime in the Data.Time library
12:37:01 <roconnor> (mostly because it would need a table of leap seconds)
12:37:03 <Arnar> this is proving challenging for my google fu   "did you mean iteM?" :)
12:37:05 <FunctorSalad> where ... type ItemM l :: * -> *
12:37:07 <FunctorSalad> (correction)
12:37:19 <FunctorSalad> (ItemM is the monad in which the list is monadic)
12:37:38 <FunctorSalad> Arnar: use quotes ("ItemM")
12:37:53 <Arnar> found it! :)
12:37:54 <Arnar> thanks
12:37:55 <FunctorSalad> they mostly turn off google's fuzzyness
12:38:08 <Arnar> the one I found is in the generator package
12:38:19 <Arnar> http://hackage.haskell.org/packages/archive/generator/0.5.1/doc/html/Data-List-Class.html
12:38:35 <FunctorSalad> Arnar: ah. I think I have the git version installed
12:39:02 <FunctorSalad> was split up, apparently
12:39:03 <Arnar> thanks a bunch
12:39:16 <FunctorSalad> np
12:39:17 <Arnar> this is beautiful..
12:39:59 <FunctorSalad> actually my questions some screens up was about it :)
12:40:03 <FunctorSalad> *question
12:40:15 <FunctorSalad> why GeneratorT is more efficient for streaming than just using the ListT
12:40:24 <roconnor> ah in Data.Time.Clock.TAI there is utcToTAITime :: LeapSecondTable -> UTCTime -> AbsoluteTime
12:40:38 <roconnor> AbsoluteTime and Diff time form an affine space / vector space pair.
12:40:39 <FunctorSalad> (assuming that it is)
12:40:50 <Arnar> aha
12:41:38 <roconnor> heh newtype AbsoluteTime = MkAbsoluteTime {unAbsoluteTime :: DiffTime} deriving (Eq,Ord)
12:42:03 <FunctorSalad> roconnor: wait... if UTCTime ignores leap seconds, what is the problem at all?
12:42:29 <FunctorSalad> "<roconnor> FunctorSalad: well, nominalDiffTime has no leap seconds and UTCDoes" <-- guess that is where I thought different
12:42:57 <roconnor> the problem is that adding a nominal hour to UTCTime may add 60, 61, or 59 seconds of real time depending on if there was an intervening leap second or not.
12:43:32 <roconnor> or in other words the time from 1:00 to 2:00 UTC may contain 60, 61 or 59 seconds
12:43:35 <FunctorSalad> roconnor: apparently you're right, it says that an UTCTime day can have a leap second
12:44:17 <jmcarthur> me would rather do mathy things with non-UTC times and then convert to UTC
12:44:28 <roconnor> really the whole problem is with the astronomers.  I'm totally in favour of elimiting leap seconds and replacing them with leap hours every 60,000 years.
12:44:37 <jmcarthur> no sense in complicating the API to work directly with gregorian
12:44:43 <roconnor> (though I seem to recall there was a counter agrument to this)
12:45:20 <roconnor> jmcarthur: converting Absolute time to UTC requires a lookup table that is published on a periodic basis.
12:45:21 <jmcarthur> */me would rather
12:45:26 <jmcarthur> and unusual typo to correct
12:45:43 <jmcarthur> roconnor: yes, but we are in no worse a situation than now, are we?
12:45:55 <roconnor> thus it is impossible to do consistently with dates more than 6 months into the future.
12:45:58 <FunctorSalad> jmcarthur: the AbsoluteTime roconnor mentioned is for clean math?
12:46:00 <nus> roconnor, well, laziness taken to extreme, replace it with leap eon at the end of time?-)
12:46:07 <FunctorSalad> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock-TAI.html
12:46:20 <roconnor> nus: getting up for work at midnight would suck.
12:46:30 <jmcarthur> roconnor: but i can't add more than 6 months to a UTC time either then, so what's the big fuss about?
12:46:43 <roconnor> jmcarthur: you can work with nominal time and UTC.
12:46:51 <jmcarthur> roconnor: at least if i am working with absolute time then i can at worst delay formatting to UTC until i have an up to date table
12:47:14 <jmcarthur> how does nominal+UTC handle it?
12:47:35 <roconnor> perhaps,  though you may find that your schedules business appoints shift by one second every once in a while.
12:48:21 <jmcarthur> i still think having a dual system is fine
12:48:26 <roconnor> jmcarthur: a nominalDiffTime doesn't represent a specific amount of real time.
12:48:33 <jmcarthur> yeah i gather than now
12:48:36 <jmcarthur> *that
12:48:56 <jmcarthur> i just don't like absolute time being second class
12:49:01 <roconnor> but I'm sure it works great for business software
12:49:29 <chrisdone> with the `load` function can I properly compile a source file (as opposed to interpret) and then load it and use a function from it as a library?
12:49:35 <chrisdone> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-6.12.1/GHC.html#6
12:50:24 <FunctorSalad> hmm? "This function implements the core of GHC's --make mode. It preprocesses, compiles and loads the specified modules"
12:50:56 <FunctorSalad> (but does ghci's :load do compilation?)
12:51:18 <chrisdone> I don't know whether loading means I can actually execute the code, or means ghc just has it in memory now and you can inspect it syntactically
12:51:25 <chrisdone> yeah
12:51:37 <sinelaw> that STM video is pretty neat
12:51:41 <sinelaw> to say the least
12:51:52 <FunctorSalad> chrisdone: maybe you still need to import the module
12:51:54 <regalia> Is it possible to get vi style command line editing in ghci?
12:51:57 <FunctorSalad> (don't know)
12:52:06 <roconnor> Prelude Data.Time> UTCTime (fromGregorian 2010 03 03) 86400
12:52:08 <roconnor> 2010-03-03 23:59:60 UTC
12:52:10 <roconnor> Prelude Data.Time> addUTCTime (-1) $ UTCTime (fromGregorian 2010 03 03) 86400
12:52:11 <roconnor> 2010-03-03 23:59:59 UTC
12:52:12 <roconnor> Prelude Data.Time> addUTCTime 1 $ addUTCTime (-1) $ UTCTime (fromGregorian 2010 03 03) 86400
12:52:14 <roconnor> 2010-03-04 00:00:00 UTC
12:52:25 <roconnor> so adding and subtracing 1 second from UTCTime doesn't return the same value.
12:52:39 <roconnor> thus isn't an affine space / vector space pair
12:52:58 <FunctorSalad> I see
12:53:09 <chrisdone> dons: do you know?
12:53:43 <roconnor> Prelude Data.Time> addUTCTime (0) $ UTCTime (fromGregorian 2010 03 03) 86400
12:53:44 <jmcarthur> i still wish we had absolute time as an affine space / vector space pair
12:53:45 <roconnor> 2010-03-04 00:00:00 UTC
12:53:47 <roconnor> heh
12:54:16 <roconnor> well "normal" UTCtime and nominalDiffTIme from an affine space / vector space pair
12:54:38 <ksf> there's no 23:59:60
12:54:46 <roconnor> It's just that "normal" UTCtime can't express all instances of time (and may specify non existant instances of time)
12:54:53 <roconnor> ksf: there is during leap seconds
12:55:14 <ksf> but aren't those on new year?
12:55:32 <roconnor> It can be in summer too IIRC
12:55:35 <FunctorSalad> so much talk about leap seconds... we'll look stupid if we go extinct before it makes any difference
12:55:37 <roconnor> I forget the exact rules
12:55:53 <roconnor> FunctorSalad: what do you mean by makes a difference?
12:56:23 <FunctorSalad> roconnor: I mean the time-of-day/daylight-shift accumulating enough to be noticeable
12:56:24 <opqdonut> well, amount to over 5 minutes for instance
12:56:45 <roconnor> we'll probably get to 5 minutes before going extinct
12:56:51 <roconnor> we are already up to 34 seconds
12:56:59 <ksf> there's more jitter introduced by timezones not respecting sun time.
12:57:16 <roconnor> in about 50 years of having leap seconds
12:57:28 <roconnor> ksf: yes, leap seconds are stupid
12:58:47 <ksf> ...they should rather re-align new year to the winter solstice. heck it's not even on christmas, anymore.
13:00:06 <roconnor> last time they did that people got really pissed off
13:00:28 <Rayne> i wonder how i can use function composition to be able to write "foo . bar x" instead of "foo ( bar x)". according to the papers the following definition is used: (.) :: (b -> c) -> (a -> b) -> a -> c - how do i implement it or is it allready?
13:00:43 <mauke> Rayne: foo . bar x is wrong
13:00:49 <Cale> Seconds are kind of the strange part of the metric system to begin with.
13:00:50 <mauke> did you mean (foo . bar) x?
13:01:03 <Rayne> mauke, my fault
13:01:14 <mauke> @index (.)
13:01:15 <lambdabot> Prelude
13:01:35 <Cale> Rayne: foo . bar x means that bar x is the function to be composed with foo
13:01:42 <roconnor> ksf: http://www.baronage.co.uk/bpgif-01/mont1752.gif
13:01:49 <Cale> It's not outright wrong...
13:01:58 <Rayne> i tried as example "(round  . round) 2" which i hoped would call round(round 2)
13:02:06 <Cale> It would.
13:02:13 <Cale> Except that doesn't make sense
13:02:15 <medfly> > (succ . succ) 3
13:02:18 <lambdabot>   5
13:02:18 <Rayne> but it should work
13:02:21 <roconnor> intrestingly the Sunday through Saturday 7 day cycle of names has gone unbroken throughout known history.
13:02:24 <Cale> :t round
13:02:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
13:02:30 <mauke> Rayne: no, it shouldn't
13:02:38 <Cale> ^^ there is no type which is both RealFrac and Integral
13:02:47 <Cale> So round won't compose with itself.
13:02:47 <Rayne> hm  my fault again
13:02:55 <medfly> roconnor, I believe there used to be cultures that didn't use it
13:03:01 <medfly> roconnor, it's just a very inconvenient change.
13:03:14 <FunctorSalad> @ty round . round
13:03:15 <lambdabot>     Ambiguous type variable `a' in the constraints:
13:03:15 <lambdabot>       `Integral a' arising from a use of `round' at <interactive>:1:8-12
13:03:15 <lambdabot>       `RealFrac a' arising from a use of `round' at <interactive>:1:0-4
13:03:22 <Rayne> thanks for your example medfly
13:03:26 <medfly> roconnor, there are some places that have recently changed the day at which there is a day off, too
13:03:32 <osaunders> http://news.ycombinator.com/item?id=1164391
13:03:32 <roconnor> ah crap, apparently the "give us our 11 days back" riots is a myth.
13:03:43 <medfly> 11 days?
13:03:57 <FunctorSalad> (but curiously, due to uniqueness issues, not existence (@Cale))
13:04:04 <roconnor> medfly: http://www.baronage.co.uk/bpgif-01/mont1752.gif
13:04:10 <FunctorSalad> (doesn't try to compute the intersection)
13:04:25 <Cale> Oh, yes, that's another problem.
13:04:42 <roconnor> ``It has been reported in some history books that a number of the public rioted after the calendar change, requesting that their "eleven days" be returned. However, this is very likely a myth, being based on only two primary sources: The World, a satirical journal of Lord Chesterfield and a painting by William Hogarth.[3]
13:05:09 <Cale> The intermediate type in between the two rounds is underdetermined
13:05:31 <FunctorSalad> @let rr x = round (round x `asTypeOf` x)
13:05:33 <lambdabot>  Defined.
13:05:34 <FunctorSalad> ;)
13:05:37 <Cale> (It can't be defaulted to Integer or Double because neither of those satisfy the constraints)
13:05:42 <chrisdone> dons: n/m, figured it out
13:05:50 <medfly> let me look it up, though
13:07:57 <roconnor> ``There were, however, legitimate concerns about tax payments under the new calendar.
13:08:14 <twink> 1752 gets bad once you throw Russia and Eastern Europe into the mix.
13:08:20 <roconnor> oh god, time is sooooooo messy
13:08:29 <sori> Could someone introduce me some other language, an extension to Haskell or any theoretic investigation for specifying the intended equational laws of a class (e.g. monadic axioms of Monad, functoriality of Functor) within the programming language (e.g. Haskell)?
13:08:52 <roconnor> sori: coq and agda2
13:09:02 <twink> It gets a bit worse when you start dealing with truly ancient calendars (e.g. Western Roman Empire, Byzantines, etc.).
13:09:04 <FunctorSalad> roconnor: the map is messy, the territory sad ;)
13:09:15 <sori> roconnor, Ah, I'll look at them, thanks:)
13:09:15 <roconnor> and epigram2 whenever it exists.
13:09:50 <medfly> roconnor, A 10-day week was used in France for 12 years from late 1793 to 1805; furthermore, the Paris Commune adopted the Revolutionary Calendar for 18 days in 1871.
13:09:57 <medfly> roconnor, or do you mean that the names weren't changed
13:10:11 <roconnor> medfly: I just mean the names
13:10:30 <McManiaC> is there a way to suppress "Defined but not used" warnings for certain files?
13:16:59 <nus> regalia, which version of ghc are you using?
13:17:17 <regalia> 6.12.1
13:17:36 <nus> regalia, http://trac.haskell.org/haskeline/wiki/KeyBindings
13:17:56 <regalia> nus, awesome, thank you :)
13:18:23 <nus> regalia, np
13:19:50 <McManiaC> is there a list about GHCs pragmas?
13:21:21 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
13:21:44 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id352860 -- also handy, flag reference
13:22:04 <osaunders> GHCi is a bit slow have there been any projects to make a fast Haskell interpreter?
13:23:28 <nus> osaunders, how fast do you need it to be?
13:23:36 <Cale> osaunders: If you want things to run faster in GHCi, you can compile the code beforehand.
13:23:57 <Cale> If there's a .o/.hi for the given module which is up to date, it will load that instead.
13:24:04 <osaunders> nus: As fast as the slowest scripting language Ruby, say?
13:24:27 <jmcarthur> Io is slower than Ruby
13:24:31 <osaunders> Cale: I guess I want a lightweight interpreter so I don't need the massive GHC.
13:25:01 <osaunders> Right now I don't feel like Haskell is a reasonable language for scripting.
13:25:28 <opqdonut> have you tried hugs? it might be faster...
13:25:40 <osaunders> jmcarthur: I don't believe many use Io for serious work.
13:25:46 <Cale> osaunders: What counts as scripting, and why is compilation not an option?
13:25:55 <jmcarthur> osaunders: no, you're right
13:26:22 <ksf> it counts as scripting if you can chmod +x your source
13:26:24 <dons> osaunders: use the compiler
13:26:30 <dons> if you care about performance
13:26:33 <ksf> #!/usr/bin/runhaskell
13:26:52 <dons> no one uses ghci for anything performance sensitive -- that's what the optimizing compiler is for
13:27:12 <ksf> a jitting haskell vm would be nice
13:27:22 <opqdonut> ksf: why?
13:27:26 <dons> yeah, why?
13:27:42 <opqdonut> haskell isn't dynamic enough to benefit from jitting
13:27:45 <osaunders> Cale: Compilation is slow, creates temporary files, and requires a hefty compiler.
13:27:46 <opqdonut> maybe type class dispatch
13:27:51 <ksf> because it can measure code during run-time and optimize for the common cases.
13:27:51 <dons> all the pain of an interpreter, while not exploiting the benefits of full static type erasure
13:28:14 <dons> osaunders: the interpreter is the same size though
13:28:29 <dons> ghc -O2 is where all the smarts are
13:28:35 <osaunders> dons: Does it have to be though?
13:28:42 <dons> if you want it to be fast
13:28:47 <jmcarthur> i think jit could be nice for partial evaluation, but i would want control over it
13:28:47 <dons> it still needs the optimizations
13:28:54 <ksf> ...it can inline more agressively if stuff is called with the same lambdas, every time.
13:29:06 <opqdonut> (btw if you want a small and fast scripting language, go for lua)
13:29:23 <opqdonut> (it even has first-class functions)
13:29:34 <mauke> "even"?
13:29:39 <mauke> what doesn't?
13:29:49 <nus> well, some still use Forth.
13:29:54 <osaunders> opqdonut: You know what, OK. I am going to check out Lua. People keep mentioning it.
13:30:02 <ksf> "even" as in "it's the best way to get first-class functions if you're coding in C"
13:30:15 <erikc> opqdonut: Factor is lovely
13:30:16 <osaunders> ATM I have this serious problem in that Haskell is the only PL I can stand to program in.
13:30:23 <ybit> oi shapr :-)
13:30:39 <jmcarthur> osaunders: why is compilation not an option?
13:30:42 <ksf> it's basically just a C library with a parser and syntax thrown in so it can pretend to be a complete language.
13:30:58 <ybit> we both live in florence and use haskell, how about that?
13:31:05 <opqdonut> ksf: well what isn't?
13:31:11 <jmcarthur> ybit: oh you're in florence too!
13:31:14 * jmcarthur is in huntsville
13:31:15 <ybit> <- uses xmonad as well, what about yourself?
13:31:17 <ybit> yep
13:31:23 <opqdonut> i think lua gives a pretty good bang for buck
13:31:24 <osaunders> jmcarthur: My reasons aren't that great but a compiler has to create files and compilation tends to be slow.
13:31:29 <ybit> http://yit.ath.cx is my home server, about 400GB of content, enjoy
13:31:51 <Cale> osaunders: But you only have to compile things once. If you're just testing things, it usually isn't so important that they're fast.
13:32:13 <ybit> jmcarthur: did we meet this summer at makers local?
13:32:23 <ybit> i was the crazy guy rambling about diy h+
13:32:33 <osaunders> Cale: runhaskell has a noticeable lag before execution begins. That's not good.
13:32:43 <Cale> It might be interesting to have a flag for ghc -e and ghci which told it to compile the modules to native code when loading them.
13:32:51 <jmcarthur> ybit: i am a member of makers local, but i don't recall anybody rambling about diy h+
13:33:02 <Cale> osaunders: Well, it compiles to bytecode.
13:33:04 <Rayne> what is wrong with "let foo x | x `mod` 2 = True | True = False"?
13:33:10 <ybit> oh, there was some meeting that where i spoke about it
13:33:13 <osaunders> Cale: Maybe I'll be happy with Lua or Factor.
13:33:14 <ybit> -that
13:33:17 <copumpkin> it should compile to BITcode!
13:33:20 <mauke> Rayne: x `mod` 2 is not a Bool
13:33:25 <Rayne> oh
13:33:28 <ybit> anywho, nice to know there's yet another haskell guy in the area :)
13:33:30 <jmcarthur> ybit: i am not one of the extremely involved members
13:33:40 <Cale> Rayne: You probably want  even x  or  odd x
13:33:55 <jmcarthur> even though i am one of the earliest involved in the group
13:34:10 <Rayne> Cale, good idea 
13:34:15 <Rayne> thanks mauke
13:34:19 <nus> Cale, yep, nobody needs the bytecode interpreter, anyway (-: Compile-to-native on load, that's the way.
13:34:24 <Rayne> i forgot everthing about haskell, fail
13:34:47 <ksf> bytecode is way more portable
13:34:50 <erikc> i seem to rememebr someone saying some initial Haskell impl was built on Common Lisp and you could incrementally develop and it'd typecheck along the way
13:34:53 <Cale> Rayne: Also note that  otherwise = True  is defined in the Prelude.
13:35:04 <Cale> (It tends to read a little nicer when used in guards :)
13:35:06 <ksf> ...well, at least in the hugs case.
13:35:07 <erikc> that's actually the system i wish i had for haskell
13:35:23 <nus> ksandstr, yeah, in theory. In practice it's IA32/x64 anyway in ~99%
13:35:26 <Rayne> Cale, i like True more or is it not recommended to use in these cases?
13:35:36 <jmcarthur> ybit: it's in dire need of moderation, but here's a relevant link for you http://groups.google.com/group/alabamahaskell
13:35:48 <Cale> Rayne: Well, it's more idiomatic to use otherwise for the last guard, but obviously True is equivalent.
13:36:06 <jmcarthur> shapr: you need to get rid of the spam on the alabamahaskell list
13:36:24 <nus> ksandstr, oops that was mean for ksf.
13:36:32 * nus mutters
13:41:21 <nus> erikc, http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/syntax/haskell/0.html
13:42:10 <nus> erikc, also http://www.mail-archive.com/haskell@haskell.org/msg01149.html
13:49:12 <erikc> nus: o cool, thanks, im curious to take a peek at this
13:59:04 --- mode: ChanServ set +o mauke
13:59:04 --- mode: mauke set -b *!*@95.66.37.243
14:01:04 --- mode: mauke set -o mauke
14:02:08 <chrisdone> haven't seen vincenz forever
14:04:52 <dons> he'll be at the hackathon
14:11:29 <chrisdone> Feb 15: Registration is now closed.
14:11:31 <chrisdone> god damnit!
14:11:54 <Cale> Registration for what?
14:12:02 <Cale> oh, the hackathon?
14:12:14 <chrisdone> when's the next haskell get together?
14:14:22 <dons> march 20 or so
14:16:34 <chrisdone> I meant after that seeing as zurihack registrations are closed, hehe
14:16:39 <chrisdone> I'll just look through the conferences list
14:18:07 <nostrand> i have a list o of list that i want to convert to matrix(IOArray), what's the easiest way?
14:18:39 <dons> use hmatrix instead, perhaps?
14:19:26 <dons> fromLists :: Element t => [[t]] -> Matrix t
14:19:38 <dons> http://hackage.haskell.org/package/hmatrix
14:19:57 <dons> (not sure what you're doing with the IOArray, but you can also write a loop calling fromList (fromList ...)
14:20:02 <nostrand> o thanks =). I would like to just use std libs, but that looks tempting =)
14:20:19 <nostrand> yeah, thought so, but that's not as sexy
14:20:36 <benmachine> if you're sure all the sublists are the right size, concat them and use listArray?
14:21:05 <dons> there's lots of good stuff on hackage, depending on what operations you need, hmatrix might be useful
14:21:21 <nostrand> i just need indexing
14:21:39 <nostrand> benmachine: but can i get a double-indexed array from that?
14:22:08 <dons> oh, just indexing? so an array indexed by pairs
14:22:15 <dons> you could use vector for that actually
14:22:16 <benmachine> nostrand: yeah, index by pairs
14:22:17 <nostrand> yep
14:22:19 <dons> probably the easiest.
14:22:24 <nostrand> GHC 6.8 =/
14:22:33 * twink is tied to hmatrix; no ghc-6.12.* until hmatrix on gentoo works with it.
14:22:53 <dons> nostrand: omg. need  to ugprade :)
14:23:03 <benmachine> :t newListArray
14:23:05 <lambdabot> Not in scope: `newListArray'
14:23:10 <nostrand> dons: Debian Testing ^^
14:23:22 <ivanm> :o
14:23:34 <ivanm> I thought debian had the platform (or at least most of it) :s
14:23:35 <benmachine> newListArray ((1, 1), (m, n)) [elements]
14:23:39 <benmachine> is how I'd do it
14:23:57 <nostrand> benmachine: :D
14:26:44 <benmachine> (yes I index matrices from 1 what of it)
14:26:55 <nostrand> benmachine: of course =)
14:28:00 <nostrand> benmachine: it worked perfectly :D
14:28:04 <DrTeggy> G'evening all.
14:29:04 <benmachine> nostrand: note that if your list elements are off a bit it will go very strange
14:29:13 <seanmcl> I'm very happy with Cabal.  However I've had the following problem a number of times.  I'll grab a library from Hackage (e.g. Edison) which uses, say, Quickcheck 1.2, but I'm already using Quickcheck 2.1 in my code.  Then I get a warning from Cabal.   First, is this a problem?   Cabal claims it often leads to compilation failures.  2) If so, how do you guys deal with it?
14:29:16 <nostrand> benmachine: :D
14:29:32 <cheater2> hey guys
14:29:40 <benmachine> (like, if you have one too few in the first row it won't just error, it'll fill from the next row and everything will be off by one)
14:29:56 <cheater2> what's a good link to give a pointy hair manager so that he can understand why haskell is great for the web?
14:30:15 <DrTeggy> lhs2TeX 1.15 fails to `cabal install' for me (using cabal-install 0.9.0, GHC 6.12.1).  Has anybody else seen this?
14:30:48 <ivanm> what's with bos' blog being down?
14:30:59 <ivanm> DrTeggy: maybe paste the error output somewhere?
14:31:12 <ivanm> DrTeggy: or else ask kosmikus directly (assuming he's online atm)
14:33:33 <dons> cheater2: "makes programmers more productive, allows projects to grow larger,
14:33:33 <dons> allows maintenance teams to pick up the code with less skills xfer, faster
14:33:34 <dons> time to market and faster and more reliable changes to existing systems"
14:33:44 <DrTeggy> ivanm, good idea
14:33:47 <DrTeggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23216
14:34:04 <dons>  + scalable. better concurrency. faster than dynamic langs.
14:34:33 <Alpounet> cheater, also, point him to
14:34:37 <Alpounet> @where industry
14:34:37 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
14:35:51 <ivanm> dobblego: what are you up to in Singapore?
14:36:12 <ivanm> awww.... I can't look at the API of bos' updated attoparsec because bytestring-lexing fails to build because it can't find a file it needs :(
14:36:28 <dobblego> ivanm, surgery
14:36:35 <ivanm> dobblego: more :o
14:36:39 <ivanm> I thought you were done with all that
14:36:47 <dobblego> so did I
14:37:07 <ivanm> DrTeggy: I don't think it works with Cabal 1.9
14:37:25 <ivanm> maybe you should use stable (as in with an official release) GHC + Cabal + Cabal-install ;-)
14:37:37 <dobblego> I've had to leave the country full of idiots, hence SNG
14:37:37 <ivanm> dobblego: so what kind of surgery are you getting done know?
14:37:43 <ivanm> yeah, figured that
14:37:47 <dobblego> decompression of deep peroneal nerve
14:37:51 <DrTeggy> ivanml: looking at the error message suggests exactly this, yes.
14:38:39 <Athas> Man, record updating is so verbose.
14:38:51 <Athas> It looks so... boilerplate.
14:39:13 <ivanm> Athas: there are various libraries that can help, such as fclabels
14:40:01 <ivanm> dons: why is it that hackage doesn't like your bytestring-lexing? http://hackage.haskell.org/packages/archive/bytestring-lexing/0.2.1/logs/failure/ghc-6.12
14:40:44 <ivanm> dobblego: so how long are you likely to be there?
14:41:49 <dobblego> surgery Friday, fly home Sunday
14:43:18 <dons> ivanm: old version of alex
14:43:25 <ivanm> dons: ahhh
14:43:35 <ivanm> so it's the hackage maintainers fault?
14:43:37 <dons> yep
14:45:15 <cheater2> dons: is there some sort of neat presentation that puts this in picture-language?
14:45:23 <cheater2> dons: the spiky hair manager never reads text
14:46:18 <dons> a general presentation on haskell for web dev?
14:46:26 <cheater2> yes
14:46:35 <dons> ask on haskell-cafe@ . i'm sure people have written such talks
14:47:02 <cheater2> dons: this sort of thing is not only handy... it's required :S
14:49:26 <McManiaC> could someone install bindings-glib and test this: http://npaste.de/JM/ for me?
14:49:33 <McManiaC> Loading package bindings-glib-0.1 ... linking ... <interactive>: /home/nils/.cabal/lib/bindings-glib-0.1/ghc-6.12.1/HSbindings-glib-0.1.o: unknown symbol `g_thread_init'
14:49:37 <McManiaC> ghc: unable to load package `bindings-glib-0.1'
14:49:42 <McManiaC> I dont even get to the undefined =(
14:49:59 <cheater2> dons: you know, as a sort of general overkill weapon that will shut down anyone who thinks haskell can't do it
14:50:47 <cheater2> dons: but also as a good resource to point non-technical people to when they say 'haskell? what's that?'
14:52:39 <dons> haskell.org is the main site
14:52:46 <dons> and has some motivating text
14:54:41 <Alpounet> @where advocacy
14:54:41 <lambdabot> I know nothing about advocacy.
14:54:44 <Alpounet> hmm
14:55:04 <Alpounet> http://www.haskell.org/haskellwiki/Advocacy -- cheater2
14:55:30 <mike31> serpentine.com down?
14:55:45 <medfly> www.downforeveryoneorjustme.com
14:55:54 <medfly> "give a man a fish..." :)
14:55:58 <mike31> I always forget that site's name
14:56:21 <ivanm> mike31: yeah, it seems to be down :(
14:56:22 <cheater2> Alpounet: ok this is completely useless
14:56:39 <cheater2> Alpounet: non-technical people will not be able to understand any of the links there
14:56:52 <mike31> ivanm: thanks.
14:56:59 <ivanm> no worries
14:57:06 <ivanm> (I was asking about it before :p )
14:57:13 <medfly> tell them that it's the next big thing?
14:57:14 <medfly> o.O
14:57:18 <cheater2> the first paragraph in "introduction" says: "WOW! I basically wrote this without testing just thinking about my program in terms of transformations between types."
14:57:35 <cheater2> the 'why haskell matters' is very obviously geared towards technical people
14:57:38 <Alpounet> oh, non-technical people only documents
14:57:41 <cheater2> yep
14:58:38 <jmcarthur> usually the arguments for any technology directed to non-technical people are roughly the same
14:59:01 <cheater2> yeah, but they need to be substantiated with proof.
14:59:05 <Alpounet> cheater2, these are the only "advocacy" documents I know of, but you really should follow dons' advice about starting a discussion on haskell-cafe@. This may lead to writing a haskellwiki page for these people about why Haskell is a good choice for real world use.
14:59:10 <regulate> there's very little that non-technical people can understand about haskell
14:59:15 <jmcarthur> hard to prove techy things to nontechy people :(
14:59:35 <Alpounet> jmcarthur, indeed but as far as I have seen, that's how industry works, right ?
14:59:52 <cheater2> regulate: they can very well understand how haskell fits together with other things. you don't need to be technical to understand some general uses of a language.
14:59:56 <jmcarthur> Alpounet: and that's a big reason why industry is stuck in the stone ages
15:00:08 <Alpounet> hehe yeah absolutely
15:00:17 <cheater2> any spiky hair manager can understand 'linux+apache+mysql+php'
15:00:25 <cheater2> and similar with any other languages
15:00:33 <regulate> cheater2: you can't even explain what makes haskell distinguished to a non-techie
15:00:52 <cheater2> what matters is the managemental differences
15:01:03 <regulate> does it matter?
15:01:09 <dons> there ahve been discussions on the 'elevator pitch' for haskell
15:01:11 <Alpounet> cheater2, "no need to pay for a testing team" ? :-p
15:01:12 <dons> you can google those
15:01:20 <dons> RWH has text too
15:01:28 * copumpkin only has an escalator pitch
15:01:32 <dons> http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
15:02:11 <cheater2> dons: this is not answering the right questions
15:02:24 <cheater2> dons: it answers questions that coders ask, not ones that managers ask
15:02:32 <decker> hi.  I know this doesn't make sense as I have it, as the x's in mymean could be Integral or Fractional, but could someone give me a hint on how to handle both?  http://fpaste.org/DZpI/
15:02:37 <ivanm> copumpkin: I'm sorry, but that's just not good enough
15:02:40 <regulate> yeah, and it says haskell is fun. you can't tell that to your managers
15:02:42 <jmcarthur> cheater2: http://www.mail-archive.com/haskell-cafe@haskell.org/msg29619.html
15:02:49 <ivanm> you need to take into account the different kinds of motion involved, etc.
15:03:01 <copumpkin> damn, I'll have to stop using mu x. 1 + (a, x): http://www.patentstorm.us/patents/7028023.html
15:03:06 <copumpkin> or whatever the notation is for that
15:03:09 <cheater2> managers ask: how will this improve the quality of my product, the process of bringing that product to market, and the time in which it happens?
15:03:10 <ivanm> as such, porting an escalator pitch to an elevator pitch will probably take more work than writing an elevator pitch from scratch
15:03:12 <ivanm> :p
15:03:23 <cheater2> how will it lower the cost in the short and log term?
15:03:33 <cheater2> those are the questions that need answering
15:03:42 <dons> http://nickmudge.info/?post=51
15:04:14 <dons> by reducing line count (== productivity) and increasing assurance (== less maintainance, fewer defects)
15:04:37 <cheater2> jmcarthur: still too technical (but the first 2/3 were ok). And 5-10x too short.
15:05:04 <Alpounet> cheater2, again, your best bet would be to post on haskell-cafe@
15:05:08 <dons> this is the thread, http://haskell.org/pipermail/haskell-cafe/2007-September/031402.html
15:05:09 <copumpkin> :0
15:05:23 <dons> check that thread, then see if you can combine it with points from e.g. RWH and the haskell.org (technical) pitch.
15:05:39 <dons> the pitch from David Pollack is a good one.
15:06:04 <cheater2> where is it?
15:06:25 <dons> i linked  to the thread above.
15:06:26 <cheater2> found it
15:06:41 <dons> try to read them, and balance the different views. then you'll have a few key points to convey
15:06:58 <dons> then back it up with evidence, http://haskell.org/haskellwiki/Haskell_in_industry
15:07:06 <dons> industrial support coalition lowers risk further.
15:07:19 <copumpkin> if I were rich, I'd want to start a haskell company!
15:07:19 <dons> many different user experience reports, key players in some industries, etc.
15:07:50 <dons> cheater2: and nothing beats reimplementing/writing something for work faster/shorter/safer/sooner
15:08:02 <Alpounet> copumpkin, with French rap all around the place ? :-p
15:08:15 <dons> hehe
15:08:30 <jmcarthur> together we are rich
15:08:33 <copumpkin> Alpounet: certainement :P
15:08:38 <Alpounet> haha
15:09:01 <ivanm> Alpounet: why french rap?
15:09:09 <copumpkin> because he thinks I'm a weirdo
15:09:26 <Alpounet> ivanm, ask copumpkin ! I don't get it myself
15:09:36 <ivanm> Alpounet: you suggested it though
15:09:39 <nagnatron> dons: Hi, I saw your post on reddit/haskell_proposals here: http://tinyurl.com/y8eezy5. Could you expound a bit so I can look into it?
15:10:00 <cheater2> looking, thanks
15:10:01 <dons> nagnatron: a replacement for our curl package
15:10:07 <dons> which is bug prone
15:10:10 <cheater2> dons, but there should be a nice pitch on haskell.org
15:10:14 <cheater2> with pictures and stuff
15:10:16 <dons> cheater2: yes!!
15:10:20 <cheater2> for the technically-impaired
15:10:25 <dons> if you get the notes together, i can polish them a bit for you.
15:10:28 <copumpkin> ivanm: because I like listening to it
15:10:36 <dons> i've linked to the best resources i can think of.
15:10:37 <ivanm> oh...
15:10:40 <ivanm> >_>
15:10:43 <dons> and then let's put it on the wiki for others to use
15:10:44 <ivanm> <_<
15:10:45 <jmcarthur> i think i am witnessing the official death of "avoid success at all costs"
15:10:50 <cheater2> dons: i'm not a person good with writing pitches.
15:10:50 <copumpkin> damn
15:10:55 <dons> jmcarthur: get jobs at all costs!!
15:11:05 <dons> cheater2: can you pull together notes from the links i gave you?
15:11:09 <copumpkin> we need a benevolent dictator
15:11:12 <copumpkin> I propose dons
15:11:19 <jmcarthur> dons: as long as the cost is lower than the rewards reaped from said jobs
15:11:23 <cheater2> dons: that's the plan
15:11:27 <dons> no no. no dictatorship. it's a do-ocracy
15:11:31 <copumpkin> eww
15:11:32 <chrisdone> simon peyton-dons
15:11:33 <cheater2> (but i'll do that tomorrow rather than today)
15:11:36 <copumpkin> but all real languages have dictators
15:11:54 <dons> nagnatron: http://hackage.haskell.org/package/curl
15:12:01 <dons> so replace that with something *reliable* in haskell.
15:12:05 <cheater2> i'm off to sleep
15:12:05 <copumpkin> alright, gonna go home now
15:12:10 <cheater2> cya later don
15:12:16 <dons> did you get what you need?
15:12:22 <nagnatron> dons: Thanks, I will look at it
15:12:29 <cheater2> dons: nope! but i'll come back tomorrow :)
15:12:36 <dons> hehe
15:12:39 <dons> well, it's a start
15:12:42 <chrisdone> dons: I'm registered for zurihac, woo!
15:13:27 <dons> cool
15:14:24 <dancor> i want to make an ffi lib to a mutable C hashmap so that i have faster serialization to/from disk than i seem to be able to get with a trie structure.  is this a good idea, and has this been done?
15:14:41 <decker> is there something like "x == [Int]" or "x == [Double]" I could use as a guard?
15:14:42 <ivanm> dancor: see dons' judy library
15:14:45 <ivanm> might do what you want
15:14:46 <dons> dancor: the judy lib
15:14:55 <dons> decker: doesn't make sense in haskell
15:15:04 <ivanm> decker: sounds like you want a typeclass...
15:15:04 <dons> decker: since those assertions are checked at compile time
15:15:12 <dancor> dons: judy arrays are rapidly serializable?
15:15:13 <dons> x :: [Double] ?
15:15:23 <dons> dancor: unknown.
15:15:26 <dons> i think so
15:15:26 <dancor> i thought they were crazy tries
15:15:29 <dons> they are
15:15:47 <dons> can you just serialize e.g. a vector?
15:15:53 <dancor> don't tries typically have a bunch of separate parts in memory so won't have rapid serialization?
15:16:05 <dons> check the judy api
15:16:09 <jmcarthur> dons: speaking of judy, is there any reason its all in IO instead of ST?
15:16:14 <dons> jmcarthur: laziness
15:16:19 <dons> (not the haskell kind :)
15:16:26 <jmcarthur> ah, a trait of a true haskeller
15:16:26 <decker> dons: that works great.  thanks.
15:16:30 <dons> i should get into the habit of doing all my effects in ST.
15:16:35 <decker> dons: or at least it compiles now...
15:16:41 <jmcarthur> yeah, i've been pushing myself to do that lately
15:16:50 <dancor> maybe vector is the correct route.  i don't expect judy arrays will work for me.
15:16:58 <dons> i think the api supports read/write
15:17:02 <dons> that's pretty efficient
15:18:11 <decker> oops, no it doesn't.  so this is no good apparently:  mymean x::[Double] = ....
15:18:13 <Cale> http://cale.yi.org/share/2010-Winter-Olympics.png :)
15:18:31 <dons> decker: parens
15:18:34 <Alpounet> decker, parens
15:18:36 <ivanm> Cale: [gold, silver, bronze] ?
15:18:38 <dons> mymean :: [Double] -> Double
15:18:40 <dons> mymean x = ...
15:18:47 <dons> decker: i'm guessing you're not writing type decls?
15:18:47 <Cale> yeah
15:18:53 <damd> Cale: what do those connections mean?
15:19:02 <damd> poset = partially ordered set?
15:19:08 <Alpounet> yeah
15:19:59 <ivanm> so is Canada related to Norway because they have more golds? or what?
15:20:07 <damd> yeah, that's what i'm wondering
15:20:14 <ivanm> i.e. is it just a >= gold relation?
15:20:17 <Cale> This is the Hasse diagram for the partial order where [G,S,B] beats [g,s,b] if G >= g, G + S >= g + s, and G + S + B >= g + s + b
15:20:20 <ivanm> or a total number of medals
15:20:25 <decker> if I go with "mymean (x::[Double]) = blah", then I get the error " Illegal signature in pattern: [Double]"
15:20:27 <ivanm> Cale: ahhh
15:20:46 <ivanm> Cale: I think arrows would help make the ordering more obvious (than just height)
15:20:47 <dons> decker: can you just write a regular type declaration for mymean?
15:20:53 <ivanm> what did you use for that? dot?
15:20:56 <Alpounet> Cale, generated with Haskell ?
15:20:57 <decker> dons: my type signature is already this: mymean :: (Num x) => [x] -> Double
15:20:58 <dons> rather than using e.g. lexically scoped types
15:21:03 <Saizan> decker: you can't have different branches in mymean based on the type.
15:21:09 <dons> but you're saying that it actually has to be Double, decker
15:21:19 <Cale> That's another way to say that country X dominates country Y if and only if country Y's medals can be turned into country X's medals by a series of medal upgrades and medal additions.
15:21:28 <dons> so change it to [Double] -> Double , or else add an appropriate fromIntegral to cast things to Double
15:21:37 <Cale> Alpounet: There's a little bit of Haskell code I used to determine the order and Hasse diagram.
15:21:39 <dons> it seems like you shouldn't need to constrain x to Double
15:21:43 <decker> dons: well I want it to be either way, Fractional or Integral.
15:21:50 <ivanm> decker: unless you define a new typeclass, you can't really do that since there's no generic (Num a) => a -> Double function
15:21:55 <Cale> I drew the diagram by hand in inkscape.
15:22:07 <ivanm> dons: I think he does for the division
15:22:10 <dons> decker: i bet you're missing a fromIntegral there
15:22:21 <dons> ivanm: only on the accumulator. it won't affect  the intput list type
15:22:42 <Saizan> a fromIntegral would make it work only on Integral and not Fractional
15:22:47 <Cale> (I fixed up some of the edges after posting it)
15:22:49 <ivanm> dons: right, but how do you code your accumulator to know whether to use it or not?
15:22:55 <ivanm> Cale: cheater! :p
15:22:56 <dons> Saizan: good point
15:22:58 <luite> argh hasse diagrams! (i've been drawing a lot of them in the last week and need to finish thisaper...)
15:23:04 <luite> paper
15:23:05 <dons> you want a function Num a => a -> Double
15:23:08 <decker> dons: here's what I have at the moment: http://fpaste.org/G1w9/
15:23:10 <ivanm> dons: that was what I was getting at
15:23:25 <ivanm> Cale: what's the point of automatic graph layout tools/algorithms if you do it better by hand? :p
15:23:50 <Cale> ivanm: Good question :)
15:23:52 <decker> ivanm: sounds like I need to look in to making a new typeclass then.  thanks.
15:24:17 <ivanm> decker: either that, or have a generic mean function to which you provide how to do the division, etc.
15:24:22 <Alpounet> decker, or use Either
15:24:29 <Cale> ivanm: To be fair, I did a lot of what one of those algorithms would do using Haskell code.
15:24:38 * ivanm has done that to even provide how to do the accumulation, etc. to be able to perform mean of vectors
15:24:47 <ivanm> Cale: oh? how?
15:25:04 <Cale> ivanm: In particular, I peeled off the set of maximal elements in the relation repeatedly to generate the rows.
15:25:07 <decker> Alpounet: ok, I'll look into that too.  thanks.
15:25:30 <ivanm> Cale: but you still had to do the positioning + edges by hand, did you not?
15:25:35 <Cale> and I determined the edges in my Hasse diagram by using some list comprehensions
15:25:39 <Cale> yeah
15:25:46 <Cale> I did the actual positioning by hand.
15:25:56 <Alpounet> decker, but still I find it weird that you have to deal with both Fractional and Integral types
15:26:04 <Alpounet> within the same function.
15:26:24 <Alpounet> isn't there just one that better suits your needs ?
15:26:58 <decker> Alpounet: I certainly don't have to.  in fact this problem probably only wanted me to do so for integrals.  but I figured mymean would be a lot better if it did both is all.
15:27:34 <ivanm> decker: better off having a mymeanInt function that does the integral case
15:27:50 <dons> ah, it is like the enumFromTo problem
15:27:52 <ivanm> and just have: mymeanInt = mymean . map fromIntegral
15:27:59 <ivanm> dons: oh? how?
15:28:02 <dons> where   you are forced to have an Integral and a Fractional version
15:28:07 <dons> you can't write a generic one
15:28:11 <ivanm> ahhh
15:28:23 <dons> you have to write two slightly different ones
15:28:29 <ivanm> @hoogle Double -> Float
15:28:29 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
15:28:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:28:30 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:33:32 <reynard> hello, I'm new to haskell, can someone show how to maintain a state without assignement?
15:33:44 <mauke> reynard: easy, use function parameters
15:33:59 <ivanm> reynard: generally in Haskell we don't maintain state
15:34:10 <jmcarthur> @unmtl a -> State s b
15:34:10 <lambdabot> a -> State s b
15:34:12 <ivanm> there is the State monad that lets you do so however
15:34:14 <jmcarthur> grr
15:34:20 <ivanm> jmcarthur: heh
15:34:22 <jmcarthur> a -> s -> (s, b)
15:34:37 <jmcarthur> actually i think State swaps the result
15:34:41 <jmcarthur> :t runState
15:34:42 <lambdabot> forall s a. State s a -> s -> (a, s)
15:35:36 <mapreduce> reynard: Most state is just temporary storage (or should be), which in Haskell you'd often write recursively instead.
15:35:42 <Cale> Oops, I missed an edge. Updated :)
15:35:55 <jmcarthur> reynard: typically if you need something like state in pure code you just make a new version of the value based on the old and just "forget" the older one
15:35:58 <mapreduce> reynard: E.g., consider the imperative vs. functional implementations of factorial.
15:36:20 <jmcarthur> reynard: we also have dirty imperative things like the IO monad or, less dirty, the ST monad
15:36:38 <reynard> thanks.
15:36:58 * jmcarthur actually likes ST now
15:37:04 <jmcarthur> i used to be kind of repulsed by it
15:37:27 <Cale> I guess one of the reasons you'd want an automatic layout is that it doesn't miss out edges by accident ;)
15:38:44 <jmcarthur> "2010 Winter Olympics Poset" -- I love it!
15:39:34 <ivanm> Cale: yup
15:39:35 <jmcarthur> kind of easy to miss the significance of the connections in the face of the vertical positioning, though
15:39:44 <ivanm> jmcarthur: yeah
16:02:15 <damd> fuck design patterns
16:02:36 <danderson> there's probably a pattern for that and all
16:03:25 <damd> microsoft's latest hot topic is MVVM... that's right - the model-view-viewmodel design pattern
16:03:44 <Alpounet> isn't that rather an architecture pattern ?
16:04:01 <damd> whatever you want to call the MV* patterns, this is one of those
16:04:08 <Alpounet> haha
16:04:11 <Alpounet> yeah
16:04:30 <pantsman> MVFDP
16:04:33 <dobblego> medicine has crackpottery; why should we be exempt?
16:04:38 <m0nkfish> i enjoy design patterns
16:05:00 <dobblego> some patients enjoy homeopathy
16:05:02 <damd> josh smith, famous WPF blogger, seriously calls for the MMVVVM pattern... model-modelview-view-viewmodel.
16:05:19 <m0nkfish> whats wrong with MVC
16:05:24 <Alpounet> dobblego, remarkably excellent answer
16:05:27 <danderson> it's models and views all the way down
16:05:48 <damd> m0nkfish: MVVM sort of came up while microsoft were working on WPF.  MVVM apparently felt rather natural when working with WPF...
16:05:54 <mapreduce> The V in MVC is rarely sufficiently distinct from the C to classify as a separate letter.
16:05:59 <danderson> then just throw in a little Corba
16:06:01 <damd> mapreduce: i agree
16:06:05 <danderson> and it's so enterprisey you can taste it
16:06:10 <m0nkfish> then you're doing it wrong
16:06:38 <damd> m0nkfish: WPF has some really cool features though
16:06:42 <pantsman> the next stage is to only allow design pattern abbreviations that are also valid roman numerals
16:06:50 <damd> you don't *need* to use MVVM for WPF, but most people would say that it's The Right Thing
16:07:32 <damd> actually, what's cool in WPF is the reactive programming-ish parts
16:07:37 <mapreduce> And when the view starts modifying the model you get near-Heisenbugs, as part of the design.  Can't FRP just take over all this?
16:09:38 <damd> mapreduce: WPF uses some variant of FRP, it's pretty cool
16:09:58 <damd> <Border Height="{Binding SomethingElse}" ... />
16:10:08 <conal> damd: windows platform foundation?
16:10:19 <damd> conal: s/platform/presentation/
16:10:26 <conal> damd: ah.
16:10:26 * ddarius doesn't know why every data flow framework is called "FRP."
16:10:33 <mm_freak> let x = 2^100000000000000 in x == x  -- this compares the actual number…  can't that comparison be optimized away?
16:10:52 <conal> damd: that's because folks moved from the MS frp project into WPF
16:10:54 <mapreduce> damd: Can you do reasonable programmingy stuff there like <Border Height="{Something Else}*2" ... /> ?
16:11:19 <conal> damd: they adapted an architecture described in one of my papers on sprite-based display of frp
16:11:31 <Cale> mm_freak: well, for Integer perhaps
16:11:36 <damd> mapreduce: no, not like that, but you can use a custom "converter", as {Binding Something, Converter=MyConverter} iirc
16:11:42 <Cale> mm_freak: But not for, say, Float
16:11:44 <damd> conal: that's cool!
16:12:06 <conal> damd: yeah.  though at the time i had very mixed feelings.  i hated seeing the semantic elegance gutted.
16:12:11 <Cale> mm_freak: For Float, I suppose you could optimise it to not . isNaN
16:12:15 <mapreduce> damd: Thanks.
16:12:16 <mm_freak> Cale: yes, i'm talking mainly about Integer, but out of interest, why can't you do that for Float?
16:12:21 <Cale> mm_freak: But that still involves computing the value.
16:12:25 <Cale> > let x = 0/0 in x == x
16:12:26 <lambdabot>   False
16:12:33 <mm_freak> ah
16:12:48 <Cale> IEEE floating point is weird about comparisons.
16:12:49 <conal> Cale: do you know how that equality fails?
16:12:55 <mm_freak> indeed
16:12:56 <Cale> conal: x is NaN
16:13:08 <conal> Cale: yeah.  and NaN is unequal to itself?
16:13:11 <Cale> yeah
16:13:14 <Cale> For some reason
16:13:17 <ddarius> conal: Yes, by definition.
16:13:19 <conal> maybe because there are a lot of them.
16:13:24 <damd> that's the case in javascript as well
16:13:26 <conal> funky
16:13:35 <Cale> Yeah, it prevents accidental detection of convergence, I suppose.
16:13:35 <roconnor> IEEE says NAN is not equal to NAN
16:13:46 <conal> i wonder how to clean up IEEE FP semantics.
16:14:04 <roconnor> == on floats is a perfectly good PER
16:14:04 <conal> sounds like NaN isn't really a value, but rather stands for many values.
16:14:36 <Cale> I think IEEE floating point is one of those things which is very well thought out for its purpose, but looks ugly because the niche where it fits doesn't really have any very beautiful solutions in it.
16:14:47 <Cale> But that might not be true.
16:15:03 <conal> is NaN a hack to avoid partiality?
16:15:07 <Cale> Yeah, it's more of a signal for divergence.
16:15:08 <roconnor> yes
16:15:38 <roconnor> float's are automatical an instance of Maybe (well-defined floats)
16:15:45 <conal> a well thought out hack.
16:15:55 <Cale> Floating point arithmetic satisfies almost no nice properties. About the only thing that you can say about the addition and multiplication is that they're commutative (not associative), and have identities.
16:15:57 <roconnor> without having all the goodness of actually being Maybe (well-defined floats)
16:16:25 <jlouis> Cale: indeed!
16:17:24 <conal> roconnor: i've been wondering lately: might we someday leave floating point behind and work with exact reals, doing enough program analysis to get efficiency?
16:17:55 <Cale> That's something I've been wondering about too. Whether there's a sufficiently efficient version of exact real arithmetic with enough operations to be useful.
16:17:56 <roconnor> some people are working on that.
16:18:07 <jlouis> Do people really need exactness? That is the deeper question
16:18:14 <conal> roconnor: sometimes doing even less work than float or double.  when less precision suffices.
16:18:33 <Cale> jlouis: Well, it would be nice to have a sort of abstract exactness, up to the point where you demand some finite precision.
16:18:36 <conal> basically think of numeric computation lazily
16:18:37 <roconnor> it is almost impossible to be faster than hardware supported floating point
16:18:45 <roconnor> Cale: what operations are ERA missing?
16:18:47 <jlouis> Cale: ah, yes. conal hit that
16:19:06 <conal> roconnor: yeah.  almost impossible assuming the hardware stays the same.
16:19:21 <conal> roconnor: though maybe with some fpga like arch.
16:19:26 <roconnor> true
16:19:35 <roconnor> though I hear graph reduction machines are passe
16:20:03 <conal> roconnor: i'm thinkin floating point is almost always either overly precise or harmfully imprecise
16:20:17 <jlouis> I've been somewhat loosely pondering on FRP for haskell-torrent btw
16:20:27 <conal> roconnor: reduceron sounds pretty promising.
16:21:24 <roconnor> Rumour has it that the floating point pros truncate their doubles to floats before proceeding
16:21:29 <conal> functional programming itself was passe a few years ago.
16:21:34 <Cale> roconnor: Well, I don't know too much about it to be honest. For certain sets of primitive operations, I imagine that you don't get the full set of computable reals.
16:21:51 <Cale> But maybe that would be a good thing efficiency-wise.
16:21:56 <Cale> I'm not sure.
16:21:57 <roconnor> Cale: heh, fair, though with floats you don't even get the full set of rationals :P
16:22:18 <conal> the float thing is such a weird semantic compromise in the context of pure denotative/functional programming.
16:22:53 <conal> as is Int, come to think of it.
16:23:56 <conal> copumpkin: howdy!
16:24:56 <roconnor> sadly we don't have ideal machines to run ideal programs on
16:25:32 <copumpkin> conal: hallo!
16:25:40 <copumpkin> we have coideal machines
16:33:23 <roconnor> wheee.  let D be the solution of D = 1 + D + D + D * D + [D -> D] ...
16:33:42 <roconnor> rather the least solution
16:33:50 <copumpkin> o.O
16:34:11 <roconnor> Scott is our hero
16:36:25 <ivanm> roconnor: do I dare ask what that is meant to be?
16:36:39 <ivanm> especially the [D -> D]
16:36:46 <Axman6> ivanm!
16:36:47 <ivanm> and who is Scott pray tell
16:36:50 <ivanm> Axman6!
16:37:04 <roconnor> [A -> B] are continuous functions from A to B
16:37:27 <roconnor> http://en.wikipedia.org/wiki/Dana_Scott
16:37:31 <ivanm> oh, so D is meant to be a set or something?
16:37:54 <roconnor> D is a algebraic, dountably based, bounded complete, dcpo
16:38:00 <roconnor> *countably
16:38:02 <ivanm> Axman6: ready to roll?
16:38:38 * ivanm gives up and goes back to pretending to look for graph generation related papers
16:39:13 <roconnor> If you don't know what an algebraic, dountably based, bounded complete, dcpo is then you aren't allowed to program in Haskell :P
16:39:15 <copumpkin> data D = ConA | ConB D | ConC D | ConD D D | ConE [D -> D] | ...
16:39:19 <roconnor> *countably
16:39:23 <ivanm> @slap roconnor
16:39:23 <lambdabot> I won't; I want to go get some cookies instead.
16:39:26 <ivanm> grr...
16:39:43 <ivanm> roconnor: having a lot of trouble telling the difference between c and d, aren't you...
16:39:44 <roconnor> copumpkin: you can just use ConE (D -> D)
16:39:52 <copumpkin> what's ConE?
16:39:57 <copumpkin> oh
16:40:07 <Axman6> ivanm: sort of, Sarah's gonna join us, and then we can go.
16:40:10 <copumpkin> I just wrote that :)
16:40:19 <ivanm> fair enough
16:40:27 <ivanm> you still coming up here?
16:40:28 <copumpkin> roconnor: because it already contains lists in the existing constructors?
16:40:32 <ddarius> "who is Scott"  Kids these days!
16:40:33 <ivanm> copumpkin: heh
16:40:35 <Axman6> i'm actually sitting about 5 meters below you atm
16:40:36 <copumpkin> as in, you can build a list out of what's already there
16:40:40 <ivanm> Axman6: heh
16:40:42 <copumpkin> ivanm: heh
16:40:58 <ivanm> copumpkin: you're heh'ing my heh to you?
16:41:01 <ivanm> :/
16:41:03 <copumpkin> yeah
16:41:10 <Axman6> heh
16:41:23 <roconnor> oh, the notation is the book is [D -> D] so you don't get confused with the non-cotinuous function from D to D.
16:41:38 <copumpkin> :o
16:41:43 <copumpkin> lame
16:41:47 <roconnor> ya
16:41:52 <copumpkin> NO OVERLOADING IN #HASKELL KTHX
16:41:56 <roconnor> everyone knows *all* functions are continuous
16:41:58 <copumpkin> WE R EXPLICIT
16:42:01 <ddarius> roconnor: Indeed.
16:42:02 <ivanm> copumpkin: yeah, write a type class instead!
16:42:18 <ivanm> roconnor: O RLY?
16:42:25 * Axman6 wishes copumpkin  would overload his R with an A and an E
16:42:35 <copumpkin> WE AE EXPLICIT?
16:42:51 <Axman6> yes
16:42:56 <copumpkin> KTHX
16:46:08 <roconnor> operational semantics are lame
16:48:50 <jlouis> roconnor: don't spill that knowledge on the twelf guys :P
16:51:03 <Axman6> rarg, bos' blog won't load :(
16:51:41 <ivanm> Axman6: yeah, I know :s
16:51:47 <ivanm> google cache has it though
16:52:26 <Cale> Not even all the functions relevant to computer scientists are continuous.
16:52:37 <ivanm> and (apparently because the version of alex is out of date) hackage can't even build the docs so I can see what the API for attoparsec is :s
16:53:21 <ivanm> Axman6: maybe you can provide some more relevant OSX advice on the COMP1100 forum
16:53:26 <ivanm> all I can do is "here's a link" :s
16:54:28 <aavogt> aww, too bad the TH AST doesn't include view patterns
16:55:06 <aavogt> otherwise quasi quotes would be a bit more useful
16:55:16 <Axman6> ivanm: will do
16:56:03 <ivanm> Axman6: also, any idea why some threads have bold titles there?
16:58:48 <Cale> And not all functions definable in Haskell are continuous maps between CPOs (because some are non-strict)
16:59:06 <Axman6> i have a feeling it's people sticking <b>'s in there, but i don't know
16:59:41 <scottbnel> Anyone willing to offer me some help?  I am new to Haskell and I am having trouble getting over the lack subtyping.
16:59:55 <copumpkin> don't give up!
16:59:55 <scottbnel> I have a concrete example that I am having trouble with in particular.
16:59:57 <Axman6> what do you need subtyping for?
17:00:37 <scottbnel> I don't need it...I don't even think Haskell supports it.
17:00:45 <ivanm> Axman6: ahhh
17:00:50 <Cale> scottbnel: That's right, Haskell doesn't support subtyping.
17:00:54 <scottbnel> I don't know how to change my OO view to a functional approach
17:01:01 <ivanm> what is subtyping?
17:01:05 <Cale> scottbnel: However, there's an extension which lets you have existential types.
17:01:35 <scottbnel> I'm sure what I am trying to do can be done without that
17:01:46 <Cale> scottbnel: You can think of an existential type as being a wrapper which "forgets" the original type of some piece of data, and only remembers that it supported a particular bunch of operations.
17:02:20 <Cale> Alternately, you can just store tuples of the operations you want the data to support -- pre-applied to the data in question.
17:03:24 <Cale> This technique is more useful when there are more cases of data than there are operations you need to support.
17:03:36 <Cale> For example, the various types of enemies in a videogame.
17:04:04 <ddarius> ivanm: If A is a subtype of B, written A <: B, then you can use A where a B is expected.
17:04:07 <Cale> There might be hundreds of types of enemies, and defining each fundamental operation by pattern matching on every one of them would be extremely tedious.
17:04:24 <ivanm> ddarius: oh, when one object extends another?
17:04:50 <Cale> You want to make it easy to extend the set of enemies by defining what the basic operations (draw, hit, timestep etc.) do to just that new enemy.
17:04:56 <ddarius> ivanm: I didn't say anything about objects.
17:05:02 <Cale> (without having to modify existing code)
17:05:03 <Axman6> ivanm: come down to the front entrance
17:05:07 <ivanm> ddarius: well, in relation to OO
17:05:11 <ivanm> Axman6: OK, coming down now.
17:05:16 <Cale> So you *define* an enemy to *be* that set of operations.
17:05:16 <Axman6> o/
17:05:22 <ivanm> Axman6: oh, which one is the front entrance?
17:05:23 <Cale> Make sense?
17:05:25 <ivanm> CSIRO?
17:05:32 <scottbnel> Right...makes sense.
17:05:34 <Axman6> no, the one facing the rest of ANU
17:05:35 <ivanm> (with the museum thingy)
17:05:44 <ivanm> Axman6: right
17:06:02 <Cale> This is the core idea of OO, without all the nonsense about subtyping and inheritance.
17:06:02 <roconnor> are we talking about that ICFP adventure game?
17:06:37 <scottbnel> Okay...this is a type class in Haskell, right?
17:06:39 <roconnor> ivanm: switch goggles
17:07:00 <ivanm> roboshibby: I was asking about what scottbnel wanted
17:07:12 <ivanm> s/roboshibby/roconnor/
17:07:26 <roconnor> ah
17:07:29 <roconnor> sorry
17:07:29 <Cale> scottbnel: Well, you could collect the operations into a typeclass, that's one way. But I was suggesting just a plain record type
17:08:51 <scottbnel> Okay
17:08:52 <Cale> scottbnel: I have half an example here: http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
17:09:47 <Cale> scottbnel: The interesting thing is that you can define functions that construct your records of operations, and just use their parameters as the 'private data' from an OO perspective.
17:10:06 <Cale> and the operations themselves are what's public
17:10:29 <Cale> data GameObject = GameObject { updateObject :: GameState -> [Key] -> [GameObject],
17:10:29 <Cale>                                renderGameObject :: IO (),
17:10:29 <Cale>                                hitTest :: Point -> Bool }
17:10:33 <Cale> circle radius (ax,ay) (vx,vy) (x,y) = GameObject { .. }
17:10:33 <Cale>   where updateObject gs ks = [circle radius (ax,ay) (vx+ax,vy+ay) (x+vx,y+vy)]
17:10:33 <Cale>         renderGameObject = drawCircle (x,y) radius
17:10:34 <Cale>         hitTest (x',y') = distance (x,y) (x',y') <= radius
17:10:52 <Cale> (a rather simple example of an accelerating circle)
17:11:43 <Cale> So that gives you something rather close to OO, whenever OO is particularly appropriate.
17:12:04 <idnar> Cale: there are some OO languages that embrace an approach like that, too (re: encapsulation / private data)
17:12:28 <idnar> I quite like it
17:13:09 <ddarius> E and Self and JavaScript behave, more or less, like that.
17:13:10 <scottbnel> Okay...I get it.
17:13:18 <jimmyjazz14> how does one override the default (from Prelude) instance of Show for a String
17:13:29 <ddarius> jimmyjazz14: You don't.
17:13:30 <Cale> jimmyjazz14: Just don't use it.
17:13:54 * twink thought something about OO but is unsure what at this point.
17:13:59 <Cale> You could create a newtype around String
17:14:05 <Cale> and write a different instance of Show for it
17:14:29 <Cale> newtype Foo = Foo String
17:14:34 <Cale> instance Show Foo where
17:14:46 <jimmyjazz14> Cale: ah yeah that makes more sense
17:14:51 <Cale>   show (Foo s) = ... something other than what the default instance of Show gives you ..
17:15:29 <Cale> jimmyjazz14: But normally, it's not necessary. What do you want the instance of Show to do?
17:15:47 <Cale> Normally you'd just write a String -> String function that does that.
17:15:49 <jimmyjazz14> Cale: all I really need is for it to not add quote to the string
17:15:54 <Cale> Then don't apply show
17:16:14 <ddarius> Cale: The issue is in things like show myMapOfStrings
17:16:18 <jimmyjazz14> Cale: well the function is a general purpose "print" like function
17:16:38 <jimmyjazz14> I just don't want to print the string with quotes around them
17:17:19 <Cale> Note that if you don't quote the strings, there will be potential for ambiguity in the displayed output (since the strings can contain things like commas and quotes and so on)
17:18:36 <roconnor> compare putStr foo with print foo
17:18:55 <jimmyjazz14> Cale: yeah I kinda understand why the quotes are there, but my print function is for general debugging
17:19:08 <jimmyjazz14> I was just hoping to give it a slightly better interface
17:20:30 <scottbnel> (Thanks for the help before, the discussion gave me a little epiphany!)
17:32:17 <jimmyjazz14> I feel like this should be possible http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23217#a23217
17:37:14 <byorgey> jimmyjazz14: that is possible if you enable the OverlappingInstances flag.
17:37:15 <luite> isn't it possible, with UndecidableInstances?
17:37:32 <byorgey> I don't think you need Undecidable, just Overlapping
17:37:50 <luite> the first one needs undecidable
17:37:55 <copumpkin> yeah
17:38:09 <byorgey> hmm?
17:38:47 <jimmyjazz14> byorgey: oh nice, that did work, usally ghc tells me about those sorts of things
17:39:23 <byorgey> I guess you also need FlexibleInstances and TypeSynonymInstances but you probably already knew about those
17:39:39 <jimmyjazz14> byorgey: yeah I was only missing OverlappingInstances
17:40:52 <FunctorSalad> you won't be able to show something which is only known to be showable, though
17:41:00 <FunctorSalad> that's IncoherentInstances
17:41:23 <FunctorSalad> since it can't know the most specific match at compile time
17:41:27 <decker> so if I need a type signature like this: "ispalindrome :: (Eq x) => [x] -> Bool", for things to work, that means I can't use any types that don't have Eq associated with them?  so if I don't add a deriving(Eq) when I define a type it wont work with my function?
17:41:53 <copumpkin> you can write one yourself
17:41:55 <decker> ha, that make any sense?
17:42:02 <copumpkin> it doesn't have to be deriving (Eq)
17:42:03 <copumpkin> but most things do
17:42:46 <FunctorSalad> jimmyjazz14: if you want to make the type-case dynamic, you could use typeable
17:42:50 <gwern> man. either this is a lousy batch of DVDs or I'm seriously doing something wrong - this is the 4th dvd today where the files to the end are empty or incomplete
17:43:03 <FunctorSalad> case cast x of Just str -> str; Nothing -> show x
17:43:29 <decker> copumpkin: well I'm doing ((head x) == (last x)) in my function.  so that means I need the Eq x in the type signature?
17:43:37 <copumpkin> decker: yep
17:43:42 <decker> k, thanks
17:43:46 <copumpkin> (that's not efficient by the way)
17:44:06 <decker> copumpkin: what would be more efficient?
17:44:15 <copumpkin> x == reverse x, maybe
17:44:33 <jimmyjazz14> FunctorSalad: what do you mean?
17:44:43 <FunctorSalad> jimmyjazz14: which part?
17:44:59 <decker> copumpkin: yeah, ha, that's way simpler.
17:45:00 <jimmyjazz14> do you have an example of how that would work/
17:45:21 <FunctorSalad> jimmyjazz14: the cast?
17:46:03 <BMeph> decker: Just remember that passing [] to your function will do a credible C imitation... ;)
17:46:20 <FunctorSalad> hehe
17:47:05 <decker> BMeph: over my head I guess
17:48:23 <FunctorSalad> BMeph: peek (nullPtr :: Ptr Int) is better
17:57:14 * BMeph appreciates FunctorSalad's adept summoning of "segmentation fault (core dumped)."
18:10:07 <FunctorSalad> any thoughts on iteratee vs. scc? they seem to be sort-of overlapping
18:10:10 <FunctorSalad> (the packages)
18:11:49 <FunctorSalad> (but "seem" is the keyword - I haven't quite grasped these yet)
18:12:20 <gwern> 5 bad DVDs. christ
18:12:32 <gwern> FunctorSalad: the whole iteratee area is a fluid mess
18:12:44 * hackagebot Lucu 0.5 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.5 (MasatakeDaimon)
18:14:06 <FunctorSalad> gwern: seems cleaner than lazy IO, though :)
18:14:18 <FunctorSalad> the chunked reading is explicit
18:14:50 <FunctorSalad> (but you are spared from actually allocating and filling the buffers yourself)
18:19:28 <FunctorSalad> one thing I don't get about iteratee is this function: http://hackage.haskell.org/packages/archive/iteratee/0.3.4/doc/html/src/Data-Iteratee-Base.html#throwErr
18:19:54 <FunctorSalad> sending the thing into an infinite loop seems like a bad way to signal fatal errors
18:20:08 <FunctorSalad> (isn't that error-field only meant for non-fatal errors?)
18:22:14 <MaciejP> Why are the Data.Iteratee.Codecs docs missing?
18:23:22 <MaciejP> IO.Windows too
18:24:00 <FunctorSalad> built with these flags off?
18:25:12 <MaciejP> Ah, `if flag(includeCodecs)'
18:49:13 <ski> Arnar : .. yes, as i recalled after awhile :/
18:50:22 <avenge> Anyone here have experience building ghc?  Am experiencing the following issue:
18:50:22 <avenge> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23219#a23219
18:51:56 <twink> gentoo builds ghc every time
18:52:20 <avenge> Am on gentoo.  Trying to build unmodified ghc-6.10.4 with gentoo's ghc 6.10.4, and it doesn't work.
18:52:29 <ivanm> where is 6.9 coming from?
18:52:37 <ivanm> avenge: which arch?
18:52:56 <ivanm> USE flags, etc.
18:53:02 <ivanm> and maybe #gentoo-haskell ...
18:53:05 <avenge> No idea.  It's very strange the 6.9.  Running x86_64.
18:53:57 <avenge> To be clear, the emerge runs fine (USE="bash-completion doc -binary -ghcbootstrap").
18:54:04 <avenge> But I can't build the stock ghc, which is what I want to do.
18:56:02 <ivanm> ahhh
18:56:10 <ivanm> avenge: any particular reason for wanting to build stock GHC?
18:56:19 <ivanm> compare the flags we apply in the ebuild to what you're doing
18:56:23 <ivanm> we also do some sed work IIRC
18:56:38 <avenge> Yes, because I want to change the source so that cabal always, always installs source code.
18:56:53 <avenge> Can't stand lack of documentation/source code.
18:57:32 <dcoutts_> avenge: a mode to install original or pre-processed sources would be welcome
18:58:33 <avenge> Basically --hyperlink-sources needs to be the default.  (Or mandatory.)
18:58:44 <avenge> But I'm having a hard time navigating the source code without first installing it.
18:58:48 <avenge> Chicken and egg problem.
18:58:49 <dcoutts_> avenge: oh, but you can do that already
18:59:02 <avenge> How?
18:59:06 <ivanm> avenge: you mean the hscolour stuff linked to from haddock docs?
18:59:12 <mudge> anybody here familiar with fannkuch?
18:59:13 <ivanm> USE=hscolour (using the overlay ebuilds)
18:59:20 <mudge> http://code.google.com/p/vala-benchmarks/wiki/fannkuch
18:59:25 <avenge> Ah... So I should install layman and such?
18:59:44 <dcoutts_> oh, hmm, actually sorry I'm wrong, you can set building docs as a default but we've not sorted out the ability to specify various other details about docs
19:00:03 <avenge> Docs are not very useful without source I find.
19:00:22 <avenge> Most Haskell docs are at most 90%.  But the source is 100% of what you need to understand libs.
19:00:52 <mudge> what does n! mean in math?
19:00:58 <avenge> I am totally puzzled about the ghc-pkg-6.9.  Where could that possibly be coming from on my system?
19:01:10 <aavogt> @google factorial
19:01:11 <lambdabot> http://en.wikipedia.org/wiki/Factorial
19:01:11 <lambdabot> Title: Factorial - Wikipedia, the free encyclopedia
19:01:12 <dcoutts_> avenge: it's not that we don't want to do it, it's just a matter of deciding how to specify on the command line and in the config file the other details that you can currently specify when running the "cabal haddock" command.
19:01:18 <avenge> n! means 1 * 2 * 3 ... * n (factorial)
19:01:40 <avenge> Sorry, we is gentoo, or we is ghc/cabal?
19:01:47 <mudge> avenge: oh, thank you
19:01:47 <dcoutts_> avenge: ghc/cabal
19:01:57 <dcoutts_> avenge: there's an open ticket on it if you've got any helpful suggestions
19:02:21 <ivanm> avenge: otherwise, you can get the downloaded tarballs from your distfiles folder
19:02:25 <avenge> Yes, I've been following the ticket, but it's at the point where I can't take it any more.  I have to fix this somehow.
19:02:28 <ivanm> but I'm not sure I understand what you're wanting to do
19:03:00 <avenge> Well, there are two issues.  One is I want to be able to build ghc.  So it's weird that I can't do it.
19:03:24 <avenge> The more important issue is that I want to fix ghc, cabal, and cabal-install so that wherever there's documentation, there's also source.
19:04:02 <mudge> i'm trying to understand this: http://code.google.com/p/vala-benchmarks/wiki/fannkuch
19:04:36 <ivanm> avenge: any particular reason for using cabal-install rather than ebuild packages?
19:04:51 <dcoutts_> avenge: I'm happy to accept patches, but the user is in control, we cannot force people to install stuff they do not want.
19:05:20 <avenge> Yes, I install lots of stuff from hackage that is not available through gentoo.  I also install my own software to test before releasing to hackage.
19:05:41 <ivanm> avenge: you could always ask us for new ebuilds
19:05:45 <ivanm> or submit them yourself
19:05:57 <avenge> Also, I would like to use Haskell in a class, and so want to be able to tell students to install stuff with cabal and just have it work regardless of OS.
19:06:10 <ivanm> anyway, I don't see how this is a ghc problem, but it's more a cabal-install problem
19:06:36 <dcoutts_> avenge: but I'm happy to make it possible for people to configure so that they always get docs linked to sources
19:06:42 <avenge> cabal-install is very closely tied to the cabal libraries which are part of ghc.
19:06:52 <avenge> ghc docs don't hyperlink source, making it hard for me to figure out what is going on.
19:07:07 <avenge> dcoutts_:  You would make me so happy by doing this, you have no idea!
19:07:50 <avenge> How can I make this happen?  Should I switch to layman and use the haskell overlay?
19:09:35 <dcoutts_> avenge: see http://hackage.haskell.org/trac/hackage/ticket/517
19:10:13 <avenge> Yeah, I'm David.  I'm the one pleading for the fix.
19:10:54 <avenge> If I develop a patch for cabal-install, you can integrate it?
19:11:20 <dcoutts_> avenge: what I've not seen yet is a design for the command line & config file
19:11:25 <dcoutts_> what the UI should be
19:11:47 <dcoutts_> I expect the implementation is straightforward once we know what the UI is
19:12:03 <avenge> For starters, we could have an identical UI, but make --hyperlink-source the default.
19:12:41 <dcoutts_> identical to what?
19:12:58 <mudge> i'm trying to understand funnkuch,  and I understand it up to this point: "Do this for all n! permutations, and record the maximum number of flips needed for any permutation. "
19:12:59 <ivanm> avenge: anyway, try to make sure you've got all the sed edits and configs that we have in the ebuild
19:13:07 <mudge> here: http://code.google.com/p/vala-benchmarks/wiki/fannkuch
19:13:12 <mudge> anybody have any ideas?
19:13:13 <avenge> To cabal install.
19:13:41 <ivanm> no, to ghc
19:13:49 <avenge> ivanm: So you needed to do these to get ghc to build?  I was hoping to build a non-customized ghc on gentoo, that I could then build on other OSes as well.
19:13:53 <dcoutts_> avenge: I'm not happy with globally changing the default, but I'm quite happy with users changing the default in their config file
19:14:12 <ivanm> avenge: AFAIK most of them are just tricks to get them to build on gentoo rather than any specific customisations
19:15:30 <dcoutts_> avenge: in any case we have no mechanism yet to change that default, we can consider what the best defaults are once we have any mechanism to implement it
19:15:32 <avenge> Okay, so that have a "hscolour: true" option in ~/.cabal/config.
19:16:11 <avenge> That got garbled.  I meant how about an hscolour option for the config file?
19:16:36 <avenge> Probably you either want all your docs with sources, or all without, so the fact that cabal install doesn't take a specific command-line option doesn't seem like a big deal.
19:17:13 <avenge> It's certainly better than the status quo, which doesn't ever allow sources for automatically installed packages
19:17:38 <dcoutts_> avenge: so like it says in the ticket, I'd really like a comprehensive way to specify all these doc options, rather than ad-hoc adding one more and one more top level flags
19:17:57 <avenge> I think the perfect may be the enemy of the good here.
19:18:28 <dcoutts_> avenge: my concern is that we end up having almost all the same options, with slightly different names, in a way that is hard to explain or maintain
19:18:48 <dcoutts_> and too many top level options so nobody can remember what they are or what they mean
19:18:52 <avenge> But should we really live without source code until the day we can figure this out?
19:20:14 <dcoutts_> avenge: so your minimal suggestion is that enable-documentation => hyperlink-sources
19:20:19 <avenge> How many options are we talking about?  Why can't the config file just have options for all the individual pieces, and "cabal install whatever-package" can just use the options from the config file for each individual stage (configure, build, haddock, install)
19:20:25 <dcoutts_> without providing any mechanism to turn it on/off
19:20:53 <avenge> That would be my minimal suggestion.  If we don't allow configurability, then I think it should include sources.
19:20:59 <aavogt> on iff hscolour can be found?
19:21:08 <dcoutts_> that makes things harder
19:21:33 <avenge> Then I guess fail gracefully, don't abort?
19:21:34 <dcoutts_> the usual policy is if you ask for a feature then you need the tools
19:22:00 <aavogt> I dunno, look at what you did with doc index updating
19:22:20 <aavogt> though that isn't really related to your point
19:22:22 <dcoutts_> what aspect do you mean?
19:23:36 <avenge> Oh, random question about doc index updating.  This is a really cool feature, but is there any way to do it automatically if you don't cabal install a package?  For instance, after I delete a package, it would be nice if there were a simple command to rebuild the index.
19:24:17 <aavogt> in that the interface is simpler if it tries to --hyperlink-source, and the only reason to disable them is if they mess up the rest of the build or documentation
19:24:41 <aavogt> avenge: that's already done
19:24:43 <dcoutts_> avenge: good point, there's nothing yet, but file a ticket and suggest a design from the user's pov
19:25:01 <dons> dcoutts_: hey you. did you see my schedule for the HP release?
19:25:24 <dcoutts_> dons: no, I've been being a hermit, not checking email while I finish off my thesis
19:25:30 <dons> wise.
19:25:32 * dcoutts_ isn't really here
19:25:34 <dons> will you be at zurihca?
19:25:36 <dons> hac.
19:25:55 <dcoutts_> dons: yep, and if I work hard I'll have handed in, or be about to do so
19:26:08 <dons> excellent news.
19:26:18 <dons> release scheduled during zurihac. so all is in hand.
19:26:24 <dcoutts_> ah great
19:26:35 <dons> see you in a few weeks
19:26:35 <dcoutts_> dons: do we expect a 6.12.2 soon?
19:26:43 <dons> not till after, afaik
19:26:46 <dcoutts_> ok
19:26:58 <dons> igloo is aware of the timetable
19:27:05 <avenge> dcoutts_: For doc indexing, I guess my suggestion would just be to have a "cabal index [--user | --global]" that does whatever cabal install does in its final stage.
19:27:08 <dcoutts_> dons: so it's basically just the updated module versions then, not much new right?
19:27:19 <dons> yep
19:27:27 <dons> no additions via vote or so on.
19:27:29 <dcoutts_> dons: well, of course QC2, modern regex
19:27:33 <dons> right.
19:27:36 <dons> but parsec 2.
19:27:39 <dcoutts_> yes
19:29:49 <dcoutts_> dons: I'm looking forward to the Zurich hackathon, I've not written any code in months, just latex and induction proofs
19:30:21 <dcoutts_> but on the plus side, stream fusion really is true! :-)
19:30:30 <dcoutts_> even for abstract types like arrays
19:30:57 <adu> arrays are very concrete
19:31:24 <dcoutts_> (at least, there's a theorem which says what you've got to prove about your ADT for stream fusion to work)
19:31:51 <ddarius> dcoutts: : When do you expect to finish your thesis?
19:32:07 <dcoutts_> ddarius: a few weeks
19:32:10 <avenge> dcoutts_:  Okay, here is my proposal for a more comprehensive UI redesign:
19:32:10 <avenge> First, break "cabal install package" into a bunch of component operations, like cabal fetch, etc., but the index is not.  Then pass all command line options from cabal install to all the sub-operations that accept that particular command.  Finally, allow the configuration file to set these options.
19:32:20 <ddarius> dcoutts_: Cool.
19:32:39 <dons> dcoutts_: i'm looking forward to reading the work.
19:33:28 <dcoutts_> dons: oh yes, I'll send you a copy before I submit, mistakes and all
19:33:52 <dcoutts_> I'll also publish a bytestring tech report
19:33:56 * ddarius changes two characters, adds three characters, and deletes two characters from Parsec's source.
19:34:15 <ddarius> s/three/four
19:34:49 <dcoutts_> avenge: so originally we did think of "cabal install" as being equivalent to fetch; configure; build; etc.
19:35:08 <dcoutts_> avenge: and each command has its own set of flags which make sense in that context
19:35:32 <avenge> So the only thing we would need to ensure is that if two different commands use the same flag, it has the same meaning.
19:36:00 <dcoutts_> avenge: but then we wanted a "do everything" command which became install, but that of course then needs all the flags that configure takes, and as we see now, most of the flags that all the other commands take
19:36:31 <avenge> dcoutts_:  Are there flags that have different meanings for different subcommands?
19:36:41 <dcoutts_> avenge: yes, "css" for example
19:36:50 <dcoutts_> between hscolour and haddock
19:37:39 <dcoutts_> avenge: at the top level you'd want --haddock-css and --hscolour-css I suppose
19:37:45 <avenge> dcoutts_:  Arguably you should be able to use the same style sheet for both, but could we have a haddock-css and --hscolour-hss option?  With --css affecting both?
19:38:01 <MaciejP> Is there a special reason why cabal doesn't have a uninstall command?
19:38:29 <dcoutts_> MaciejP: nobody has implemented it
19:38:40 <ivanm> ddarius: and now it's ready to take over the world? ;-)
19:38:48 <ddarius> ivanm: Perhaps.
19:39:29 <dcoutts_> avenge: in this particular example I doubt it's worth having anything to unify the two, they're rarely used options, but more generally I take your point that it could be problematic
19:39:59 <avenge> MaciejP:  I use this in my makefiles for uninstall:
19:40:00 <avenge> uninstall: dist/setup-config
19:40:00 <avenge>         ./Setup unregister --user
19:40:00 <avenge>         rm -rf $(HOME)/.cabal/lib/$(PKG)-[0-9]*
19:40:03 <avenge>         rm -rf $(HOME)/.cabal/share/doc/$(PKG)-[0-9]*
19:40:06 <avenge>  
19:40:10 <dcoutts_> avenge: the alternative approach would be to say that subcommand-specific flags should be usable at the top level but with a prefix or escape of some sort.
19:40:11 <avenge> MaciejP:  Only issue is rebuilding index, which is more of a pain.
19:40:54 <MaciejP> avange: Unfortunatly won't help on windows :-(
19:40:55 <avenge> dcoutts_:  Why not say going forward that if you re-use an option for a different command, it should have the same meaning as its previous use?
19:41:07 <avenge> dcoutts_:  Is the issue that you control cabal-install but not cabal lib?
19:41:21 <dcoutts_> avenge: no, I'm maintainer of both
19:42:35 <dcoutts_> avenge: I'm not in principle averse to reorganising the command line if it makes it clearer to users. We can have backwards compat by having flag aliases etc that are not advertised.
19:42:47 <avenge> Generally speaking, I think there's a usability benefit to not re-using options for different purposes.  I don't like searching for an option in a man page and finding the wrong explanation.  At the extreme you get things like git, where .. and ... essentially mean the opposite depending on whether you are supplying them in an argument to "git log" or "git diff", which is very confusing.
19:44:29 <altmattr> how does one get ghci to load (and keep in scope) all the modules in a particular project?  I am sick of typeing :l m.m.f m.m.f2 ..... :m + m.m.f .....
19:45:09 <Cale> altmattr: You can write a custom .ghci file with those commands and put it in the directory where the project is
19:45:37 <avenge> altmattr: Also, once loaded ":reload" should do it.
19:45:52 <Cale> You could also create a module which imports everything you might want from your project.
19:45:54 <altmattr> cheers
19:46:00 <avenge> altmattr:  As a cheap trick, you can also create a module that includes and re-exports all the modules you are using, and just always run ghci on that.
19:46:41 <altmattr> I have for a long time used a little shell command (called haski) that starts ghci with the compiler extensions I need, but a .ghci file is a much smarter idea
19:48:27 <avenge> Also, if you have {-# LANGUAGE ... #-} pragmas, you often don't need to specify the options to ghci.
19:50:33 <Cale> Yeah, normally it's best to use LANGUAGE pragmas and keep the source self-documenting with regard to how it needs to be built.
19:51:11 <avenge> Actually, this is another issue with cabal...
19:51:35 <avenge> If you include LANGUAGE pragmas, it's easy to forget to list an extension you require in your .cabal file, I think.
19:51:55 <dcoutts_> avenge: yep, there's an open ticket on that too :-(
19:53:08 <avenge> Does ghc have an option to ignore LANGUAGE pragrmas?
19:53:19 <avenge> That would be a quick and dirty solution.
19:53:52 <avenge> Force people to list the right things in the cabal file, but allow LANGUAGE pragmas so that ghci works better when debugging.
19:53:59 <adu> avenge: that would amount to be a language extension, which would probably require a language pragma to turn language pragmas off
19:54:09 <avenge> ha.
19:54:34 <avenge> But actually, it's a language non-extension.  The LANGUAGE pragmas are the language extension.
19:54:36 <dcoutts_> avenge: the approach I was thinking of was to have cabal notice the language pragmas and tell you when you've forgotten to list them
19:54:45 <avenge> Now that's even better.
19:54:46 <adu> {-# LANGUAGE IDontWantAnyLanguagePragmas #-}
19:55:16 <dcoutts_> avenge: but it also means fixing another long-standing problem with cabal's support for language extensions which is that the meaning of "extensions" in the cabal file is confused
19:55:16 * hackagebot uuid 1.2.1 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.1 (AntoineLatter)
19:55:55 <dcoutts_> avenge: it currently means both of "this package uses these extensions" and "apply these extensions when compiling the code in this package"
19:56:14 <dcoutts_> but we really need to be able to say the first without the second
19:56:51 <dcoutts_> but we also do not want to break all the packages that rely on the current behaviour
19:57:04 <avenge> Why would you want to list extensions you don't need?
19:57:41 <avenge> Or is the deal that you want more fine-grained control, so your package might have one feature that requires some crazy extension, and that a bunch of other stuff that is Haskell98.
19:58:13 <dcoutts_> avenge: right, if you list an extension then it gets applied to all modules
19:58:36 <dcoutts_> where as with the language pragma you control it per-module
19:59:07 <avenge> Makes sense.  So the extensions should not be compiler flags--they should just be an auto-generated union of all LANGUAGE pragmas in all files.
20:00:18 <dcoutts_> avenge: the tricky thing is how to make that transition for 1000's of packages
20:00:36 <dcoutts_> and sometimes people just want convenience and not per-module control
20:03:39 <avenge> Anyway, found where the 6.9 is coming from.  This is in the ghc-6.10.4 distribution in utils/ghc-pkg/ghc-pkg.cabal:
20:03:39 <avenge> -- XXX Version number
20:03:39 <avenge> Version: 6.9
20:03:39 <avenge>  
20:03:59 <avenge> Doesn't explain my compile error, though.
20:08:47 <avenge> Weird.  ghc-6.10.4/utils/ghc-pkg definitely uses the symbol "package" all over the place.  Which module was this symbol supposed to be imported from?
20:11:44 <dcoutts_> avenge: probably from the Cabal library, the field in the InstalledPackageInfo record
20:13:26 * hackagebot parsec 3.1.0 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.0 (DerekElkins)
20:13:29 <avenge> Yeah... Strangely I'm not getting it.  Explicitly tried to import it, and get:Main.hs:20:42:
20:13:29 <avenge>     Module
20:13:29 <avenge>     `Distribution.InstalledPackageInfo'
20:13:32 <avenge>     does not export
20:13:32 <avenge>     `package'
20:13:35 <avenge> gmake: *** [with-bootstrapping-compiler] Error 1
20:13:38 <avenge>  
20:14:09 <dons> parsec 3.1.0 !
20:14:19 <avenge> Indeed, it is not exported.
20:14:31 <dons> ddarius: what's new ?
20:14:32 <avenge> So ghc-6.10.4 is broken?  How could this code compile for anyone?
20:15:13 <aavogt> different versions of Cabal?
20:15:24 <ddarius> dons: Antoine's CPS code is applied so it should run as fast as Parsec 2 and notFollowedBy is generalized.
20:15:32 <ddarius> dons: I'll have an announcement on the lists momentarily.
20:15:32 <avenge> But I'm working from the ghc distribution, so it was all bundled together.
20:15:52 <dcoutts_> avenge: the name is changed in later versions of Cabal
20:16:13 <dcoutts_> avenge: you're looking at ghc-6.10 which uses Cabal-1.6, but you're probably looking at the current Cabal source
20:16:33 <dons> ddarius: cool. any benchmarks? (like bos' thing today?)
20:16:48 <dons> the CPS patch was in bos' post, wasn't it?
20:17:04 <dcoutts_> ddarius: are you the new maintainer then?
20:17:49 <dcoutts_> ddarius: what I think the public want to know about parsec 3 is if it is actually as good as parsec 2 in the various important ways
20:18:22 <dcoutts_> at the moment people are not convinced to move over, since it's essentially a totally new package
20:19:04 <ivanm> dons: yeah, he used it in one of the benchmarks
20:19:21 <ddarius> dcoutts_: Other than performance, Parsec 3 was (modulo one nasty omission) always as good as Parsec 2 and almost a drop-in replacement.  The only significant issue I'm aware of was performance which should be resolved with this release.
20:19:27 <twink> Is this a CPS patch for ghc or something else?
20:19:32 <ddarius> dcoutts: Also, I've always been the maintainer for Parsec 3.
20:19:35 * ivanm is quite happy to keep using polyparse for graphviz and sees no real big reason to move
20:19:46 <ivanm> twink: for parsec 3
20:20:04 <dons> i think a set of benchmarks is what is needed.
20:20:51 <dcoutts_> right, correctness and performance
20:21:00 <ivanm> dons: I thought there were some when Antoine did the original patch...
20:21:32 <ivanm> dons: otherwise, can't you find some way of benchmarking parsec using Vector on LLVM? :p
20:21:34 <avenge> Yes, the bootstrap process seems to be picking up my installed libraries, rather than the ones that came with ghc.  Even running ghc-pkg hide Cabal-1.8.0.2 doesn't seem to work.  Weirdl.
20:21:59 <dcoutts_> ddarius: in the next few months, if you're convinced that it is an improvement and there are no remaining regressions then I suggest proposing it for the following major release of the HP
20:22:04 <ivanm> ddarius: out of curiosity, with parsec-3 is there any real advantage to using it over parsec-2 for just String parsing>
20:22:05 <ivanm> ?
20:22:28 <dcoutts_> ddarius: ie for a major HP release in ~6months time
20:22:32 <Cale> It's like, one more than parsec-2
20:22:34 <ivanm> avenge: yeah, you usually don't bootstrap _downwards_ ...
20:22:39 <ivanm> Cale: heh
20:22:41 <ddarius> ivanm: Not really.
20:22:50 <ddarius> ivanm: Actually, that's not the issue so much
20:22:50 <ivanm> ddarius: *nod* so mainly the bytestring stuff?
20:23:01 <ddarius> ivanm: It's mainly the monad -transformer- stuff.
20:23:05 <ivanm> ahhh
20:23:18 <ddarius> ivanm: The main reason to use Parsec 3 is if you want a parser monad transformer.
20:23:27 <ivanm> ddarius: I was asking because someone was telling me I was doing it wrong doing String parsing when I should be doing Bytestring parsing
20:24:19 <ddarius> ivanm: Depending on what you are doing, they are probably right, however, I'm not sure that there is a big difference between the two, as far as actual parsing goes, in Parsec 3.
20:24:28 <ivanm> *nod*
20:25:04 <avenge> Weird, even adding "Build-Depends: ... Cabal < 1.7" doesn't work.  I really don't understand the ghc-pkg system.
20:25:09 <ddarius> ivanm: However, Parsec is (and was never), in my opinion, not intended for mass quantities of data, particularly mass quantities of data with a simple format.
20:25:19 * twink thought he'd heard something about CPS something which maybe had something to do with monad transformers or something.
20:25:37 <twink> Or maybe monad builtins for ghc.
20:25:51 <ddarius> ivanm: There are better options, such as bos' attoparsec or binary/cereal, for ripping bunches of things from a (byte)string.
20:27:02 <ddarius> ivanm: The main benefits of Parsec is that it is reasonably nice to use, can handle fairly complex languages without inordinate effort, and has nice error messages.
20:27:46 <michael|> Any hint as to why map (*) [0..] (from LYAH) does not work? It says 'no instance for (Show (a -> a)) arising from a use of `print' at .."
20:28:00 <dons> > map (*) [0..]
20:28:01 <lambdabot>   [{-3->0;-2->0;-1->0;0->0;1->0;2->0;3->0},{-3->-3;-2->-2;-1->-1;0->0;1->1;2-...
20:28:07 <ddarius> :t map (*) [0..]
20:28:08 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
20:28:10 <dons> what's the type of (*)
20:28:13 <Cale> michael|: It works, it's just that you get a list of functions
20:28:25 <Cale> michael|: Which isn't something that you can easily print
20:28:25 <dons> (cool show instance,btw)
20:28:38 <michael|> Ah, duh. That makes sense.
20:28:42 <michael|> Thank you all.
20:29:39 <idnar> dons: I think that's from SmallCheck
20:31:35 <dons> looks like it
20:35:54 <mudge> does anyone understand the instructions of how to implement Fannkuch as given on the Haskell website: http://www.haskell.org/haskellwiki/Shootout/Fannkuch  ?
20:41:13 <ivanm> ddarius: well, I'm parsing Dot code
20:41:21 <ivanm> (and I'm actually using polyparse for it... >_> )
20:41:55 <ivanm> I just know that someone told me I should be parsing Bytestrings when reading from file rather than Strings (for both performance and to ensure encoding is preserved properly)
20:42:14 <copumpkin> does the built-in negate syntax use Num's negate?
20:42:21 <copumpkin> does NoImplicitPrelude change that?
20:42:28 <SamB_XP> copumpkin: should do!
20:42:43 <ivanm> copumpkin: I think it's built in, but I could be wrong
20:42:49 <ivanm> you could always try it and see... >_>
20:44:55 <MaciejP> mudge: I do I think :-)
20:45:04 <Gracenotes> as they say, you'll learn much more from trying than if.. ever.. you had never, from if you had tried.. than asking, never tried?
20:45:15 <SamB_XP> lol
20:45:27 <SamB_XP> Gracenotes: where the heck do they say *that*?
20:45:55 <aavogt> yeah, it isn't terribly coherent
20:46:21 <Gracenotes> Has anyone really been far even as decided to use even go want to do look more like?
20:46:38 <Gracenotes> yeah. it comes from javabot actually, "Try it and see. You learn much more by experimentation than by asking without having even tried."
20:48:08 <mudge> MacieJP: can you explain it to me?
20:48:45 <mudge> MacieJP: I am lost after the instruction: "Count the number of flips, here 5."
20:48:50 <mudge> after that I am lost
20:48:59 <dobblego> Gracenotes, that came from me actually :(
20:49:46 <MaciejP> mudge: `Repeat this until the first element is a 1' <- so every step is a flip.
20:50:54 <mudge> MacieJP: I understand the first part,  about how to get 1 as the first element,  i don't understand it after that
20:50:59 <mudge> MacieJP: then what?
20:51:53 <MaciejP> Then you do the complete algorithm for all permutations of n
20:53:01 <Gracenotes> dobblego: a fine quote
20:53:02 <mudge> MacieJP: so do you then run the same algorithm again,  but starting with a different arrangement?
20:53:15 <MaciejP> Yes
20:53:23 <Gracenotes> dobblego: although if javabot is a hammer, every newb looks like a nail
20:54:10 <mudge> MacieJP: okay,  so you again try to get 1 to be the first element,  but starting with a different permutation,     and then do it again starting with a different permutation,   until you have done all the permutations?
20:54:15 <MaciejP> mudge: but I'm not sure how to get the `correct order' of all permutations
20:55:03 <MaciejP> mudge: Exactly
20:55:03 <mudge> MacieJP: is that correct?  what i said above?
20:55:09 <mudge> MacieJP: oh okay, cool
20:56:41 <MaciejP> mudge: Do you get the order of the permutations? I don't
20:57:55 <copumpkin> bos' site is still down
20:58:00 <Axman6> :(
20:58:05 * Axman6 wants to read it!
20:58:25 <ddarius> Axman6: Read it through Planet Haskell.
20:58:38 <Axman6> hmm, i could do that
20:59:27 <mudge> MacieJP: I am checking it out
21:01:42 <mudge> MacieJP: where are you getting order of the permutations?
21:03:02 <MaciejP> Er, I mean I don't understand what is the correct order as listed in the example N=7
21:04:25 <mudge> MacieJP: you are right,  that does seem to be the correct order,  i'm trying to find out why too
21:06:33 <mudge> anybody know why the Fannkuch permutation order is correct here: http://www.haskell.org/haskellwiki/Shootout/Fannkuch
21:23:43 <ozataman> hey all
21:23:52 <ozataman> is there a way to make hGetContents strict?
21:24:47 <Axman6> traverse the result?
21:25:41 <bobtheterminator> So I'm trying to use cabal to install stuff, and whenever I do, it claims that "The exception was: CreateDirectory: permission denied (access is denied)."
21:25:46 <bobtheterminator> why does this happen?
21:25:48 <dons> ozataman: use the strict package?
21:25:59 <dons> ozataman: or strict io based on bytestrings?
21:26:04 <SamB_XP> bobtheterminator: did you use sudo ?
21:26:10 <bobtheterminator> im in windows
21:26:13 <bobtheterminator> sudo isn't legit
21:26:24 <bobtheterminator> is there an equivalent for windows?
21:26:37 <SamB_XP> er, uh, did you run it as admin ?
21:26:44 <bobtheterminator> im pretty sure
21:27:21 <bobtheterminator> wait, i'll try again
21:28:02 <ozataman> dons: thanks, I think the strict bytestrings will do
21:28:13 <bobtheterminator> oh, wow, ok thanks SamB_XP
21:31:02 <scutigera> sum of lengths : foldr (\a b -> b + (length a)) 0 l; how would this be written more compactly ?
21:31:27 <temoto> @pl foldr (\a b -> b + (length a)) 0 l
21:31:27 <lambdabot> foldr ((+) . length) 0 l
21:31:31 <Axman6> sum . map length
21:32:18 <scutigera> thanks.  now I can ponder on partial app some more :-)
21:32:31 <scutigera> :t ((+) . length)
21:32:32 <lambdabot> forall a. [a] -> Int -> Int
21:33:16 <scutigera> Axman6: I _always_ forget there's a `sum`
21:33:24 <Axman6> tut tut tut
21:33:37 <Axman6> also, i think that would be more efficient as a left fold
21:33:51 <Axman6> (which sum already is)
21:34:03 <scutigera> hmmm... I thought I read the opposite, use foldr's or foldl' (?)
21:34:05 <Axman6> :t foldl' ((+) . length) 0
21:34:06 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
21:34:06 <lambdabot>     In the second argument of `(.)', namely `length'
21:34:06 <lambdabot>     In the first argument of `foldl'', namely `((+) . length)'
21:34:34 <Axman6> :t foldl' (\x acc -> acc + length x) 0
21:34:35 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
21:34:35 <lambdabot>     In the expression: acc + length x
21:34:35 <lambdabot>     In the first argument of `foldl'', namely
21:34:40 <Axman6> :t foldl' (\acc x -> acc + length x) 0
21:34:41 <lambdabot> forall a. [[a]] -> Int
21:34:53 <Axman6> > foldl' (\acc x -> acc + length x) 0 cake
21:34:54 <lambdabot>   1393
21:34:59 <scutigera> what's @pl ?
21:35:07 <Axman6> scutigera: there's also length . concat
21:35:55 <scutigera> Axman6: would that append all the lists, i.e. be dreadfully slower than either of the soln's ?
21:36:12 <scutigera> @pl foldr
21:36:12 <lambdabot> foldr
21:36:17 <Axman6> i'm not sure if it would fuse nicely or not, i'd hope it would... dons?
21:36:29 <Axman6> @pl \a b c -> a + b + c
21:36:29 <lambdabot> ((+) .) . (+)
21:36:49 <scutigera> eww
21:36:53 <Axman6> yup
21:36:59 <Axman6> pl = pointless
21:37:11 <Axman6> (a pun on the name pointfree)
21:37:24 <scutigera> right, another one of those things I've been meaning to look up :-)
21:37:33 <scutigera> pointfree that is
21:37:40 <Axman6> pointfree means leaving out the names of variables
21:38:01 <Axman6> like, add1 xs = map (+1) xs === add1 = map (+1)
21:38:15 <Axman6> and it leads to horrible, unreadable code
21:38:17 <aavogt> looks pretty pointless, hence the pun
21:38:21 <Axman6> so... don't use it
21:38:30 <scutigera> don't use pointfree ?
21:38:36 <SamB_XP> except where it's just too much work to naem your vars
21:38:41 <Axman6> that's my advice, others are addicted to it
21:38:45 <SamB_XP> and/or it actually IS clearer
21:38:52 <Axman6> scutigera: aye
21:38:55 <Axman6> uh, SamB_XP
21:38:57 * aavogt needs more fix
21:39:06 <scutigera> I like clear and verbose-ish
21:39:07 <SamB_XP> preferably AND
21:39:14 <Axman6> scutigera: me too
21:39:26 <Axman6> i like writing maintainable code
21:39:38 <SamB_XP> well, some of us only have 1280x1024 screens ;-P
21:39:44 <aavogt> that is where we disagree
21:39:51 <scutigera> I only have 640kb
21:40:05 <SamB_XP> scutigera: that's just your terminal, silly
21:40:13 <aavogt> no you don't. I'm sure ghc wouldn't run with that
21:40:17 <scutigera> aavogt: you don't like writing maintainable code ?
21:40:44 <aavogt> apparently not if we look at code I've written
21:40:46 <scutigera> oh, I'm sorry I mean 1900x1200 ;-)
21:41:23 <scutigera> two 80 col emacs windows is the bomb, or whatever it is you youngsters say these days.
21:42:11 <aavogt> it's terminally ill
21:42:18 <SamB_XP> how do you fit 1900x1200 into 640k ?
21:42:27 <scutigera> one bit at a time
21:42:49 <scutigera> > 1900 * 1200
21:42:50 <SamB_XP> oh, so that's only with the hercules or smtn?
21:42:50 <lambdabot>   2280000
21:42:53 <scutigera> > 640* 1024
21:42:54 <lambdabot>   655360
21:43:00 <aavogt> > showHex (1900x1200) ""
21:43:01 <lambdabot>   Not in scope: `x1200'
21:43:10 <scutigera> oh - that's why my screen updates are so slow...
21:43:12 <aavogt> > showHex (1900*1200) ""
21:43:13 <SamB_XP> >  640* 1024 * 8
21:43:13 <lambdabot>   "22ca40"
21:43:14 <lambdabot>   5242880
21:43:19 <Axman6> > 1900*1080
21:43:20 <lambdabot>   2052000
21:43:30 <SamB_XP> hmm, you could maybe get *4* colors
21:44:14 <scutigera> hmmph, when I was young and atari ruled the world, high quality monochrome was just fine.
21:45:07 <SamB_XP> of course, on a PC only two of those 4 colors'd be tolerable anyways ...
21:46:20 <scutigera> speaking of 640k, has ghc been ported to any low-end hardware ?
21:53:39 <Gracenotes> > read "1e4" :: Int
21:53:40 <lambdabot>   10000
21:54:03 <bmh> Hey guys, I apologize but I've been out of the loop for a while. What's the deal with Prelude being deprecated?
21:54:03 <lambdabot> bmh: You have 1 new message. '/msg lambdabot @messages' to read it.
21:55:00 <Gracenotes> GHC calculates the value frac^exponent during the lexing phase, so hence http://hackage.haskell.org/trac/ghc/ticket/3897
21:55:32 <Axman6> > read "1e0" :: Int
21:55:33 <lambdabot>   1
21:55:38 <Axman6> > read "1e1" :: Int
21:55:39 <lambdabot>   10
21:55:48 <Axman6> > read "1.5e1" :: Int
21:55:49 <lambdabot>   * Exception: Prelude.read: no parse
21:55:50 <SamB_XP> > 1e0 :: Int
21:55:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:55:51 <lambdabot>    arising from the lit...
21:55:55 <Axman6> > read "15e1" :: Int
21:55:56 <lambdabot>   150
21:56:09 <SamB_XP> Gracenotes: so, by GHC you mean GHC.Foo
21:56:30 <Gracenotes> the calculation happens in GHC.Text.Read
21:56:42 <Gracenotes> er, no, Text.Read.Lex
21:57:38 <Gracenotes> line 346 in my version. Not sure how to make 1e1000000000 auto-go to infinity for Doubles, since lexing is meant to be nice, clean-cut, generic.
22:07:14 <tensorpudding> is it possible to import modules conditionally?
22:08:31 <kfish> tensorpudding, yes, if you use {-# LANGUAGE CPP #-}
22:08:35 <tensorpudding> i.e. something like C's #ifdef (thought ideally less hacky)
22:08:52 <tensorpudding> meh
22:10:21 <kfish> well, anyway it is possible to use cpp, and you can specify it through cabal (eg. configure with flags, then import conditionally)
22:11:13 <tensorpudding> cabal would be a pretty big overkill
22:11:27 <tensorpudding> i'm trying to make my xmonad.hs portable to various platforms
22:11:53 <tensorpudding> without having to include all the packages and stuff on each one, if they don't use them
22:12:03 <tensorpudding> i'm pretty sure it's not going to work though...
22:12:43 <kfish> ah :)
22:28:30 <dons> http://hackage.haskell.org/trac/ghc/ticket/3910 is interesting
22:28:57 <Surrador> Semen, the technical name for the fluid of male sexual emission which occurs
22:28:57 <Surrador> at ejaculation, has a generally salty or sweet taste, depending on what the
22:28:57 <Surrador> person responsible has consumed since his last ejaculation, said Dr. Ben
22:28:57 <Surrador> Rodriguez-Silverstein. "It's entirely possible that these foods make semen
22:28:57 <Surrador> taste disgusting," he said. "But unfortunately, most of them are necessary for
22:28:57 <Surrador> survival.
22:29:23 <Surrador> Semen, the technical name for the fluid of male sexual emission which occurs
22:29:23 <Surrador> at ejaculation, has a generally salty or sweet taste, depending on what the
22:29:24 <Surrador> person responsible has consumed since his last ejaculation, said Dr. Ben
22:29:24 <Surrador> Rodriguez-Silverstein. "It's entirely possible that these foods make semen
22:29:24 <Surrador> taste disgusting," he said. "But unfortunately, most of them are necessary for
22:29:24 <Surrador> survival.
22:29:42 --- mode: ChanServ set +o dons
22:29:43 <Surrador> Contacted via phone, Robert Liebovitz, lead counsel for the Association of
22:29:44 --- mode: dons set +b *!*Surrador@*.160.235.225.cable.dyn.cableonline.com.mx
22:29:44 --- kick: Surrador was kicked by dons (Surrador)
22:29:45 --- mode: ChanServ set -o dons
22:30:18 <alex404> So... #INCLUDE is deprecated wrt the FFI... what do I use instead for loading a c header file?
22:32:33 <dons> you can still use hsc2hs to import symbols, or include: foo.h in .cabal files
22:35:01 <alex404> But if I want to reference a locally written c function, how do I do that?
22:35:33 <alex404> Presumably haskell needs to read it out of the header?
22:38:43 <Gracenotes> so, anyone like pineapple?
22:42:23 <dons> alex404: are you building with cabal?
22:42:38 <dons> just add the c-source and include to the .cabal file
22:42:43 <dons> and it will pass the files and paths to ghc
22:43:49 <alex404> Cool, thanks.
22:56:37 <Jonno_FTW> how do i make my IRC bot reply to version requests?
22:57:14 <Jonno_FTW> "VERSION :ircbot v1.0" doesn't work
22:59:02 <dons> not enough info to answer this. do you have a haskell question?
22:59:11 <Jonno_FTW> in my haskell bot
22:59:18 <Jonno_FTW> i was following the tutorial on the wiki
22:59:45 <Jonno_FTW> i got
23:00:21 <Jonno_FTW> it checks if the message it received is a version request
23:00:23 <Jonno_FTW> which works
23:00:34 <Jonno_FTW> but then it can't respond properly
23:00:54 <Jonno_FTW> write "VERSION :IRCbot
23:00:57 <Jonno_FTW> is what I got
23:01:00 <avenge> Using Haskell is like a constant battle for access to source code.
23:01:00 <avenge> What am I doing wrong here:
23:01:00 <avenge> cabal configure --user
23:01:07 <avenge> cabal haddock --hyperlink source
23:01:14 <avenge> (so far so good, now I have access to source code)
23:01:16 <avenge> cabal install
23:01:25 <avenge> (now it wipes my links to source code before installing)
23:01:39 <dcoutts_> avenge: this is the problem of install meaning "do everything"
23:01:56 <dcoutts_> since that includes configureing and building and docs
23:01:57 <avenge> But I thought this used to work?  Do I run something other than install?
23:02:24 <dcoutts_> the "install only" action consists of copy and register
23:02:47 <dcoutts_> there's also an undocumented --only flag (I think that's what it's called)
23:02:52 <avenge> Sorry, so what do I type?
23:02:59 <avenge> Oh... undocumented.  I see.
23:03:06 <dcoutts_> cabal copy; cabal register
23:03:42 <avenge> cabal copy, that's it!  That's what I must have been doing before.
23:04:14 <dcoutts_> avenge: to add to the confusion, if you go via runghc Setup, then the install action there is just install, not a "do everything" command
23:04:19 * hackagebot gloss 1.0.0.0 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.0.0.0 (BenLippmeier)
23:04:31 <avenge> Oh... That's why it used to work!
23:04:45 <avenge> Right.  My own makefiles all just use ./Setup.
23:06:57 <dcoutts_> avenge: if you have any suggestion about how to clean up this mess... :-)
23:07:50 <avenge> Well, I would advocate a two-step proces.  First, just add some kind of simple not terribly general action that at least allows source code.
23:08:22 <avenge> Then, come up with a more general framework, which will be eaiser because everyone's productivity will be so much higher given access to source code :-)
23:09:01 <dcoutts_> I mean the problem that install is overloaded, that people want it to mean do everything and also do the install bit having configured first
23:09:20 * hackagebot gloss-examples 1.0.0.0 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.0.0.0 (BenLippmeier)
23:09:48 <dcoutts_> in general, for an arbitrary Setup.hs, we cannot tell if a package should be reconfigured/rebuilt
23:09:50 <avenge> dcoutts_:  Then maybe consider *two* commands:  cabal and hackage.
23:09:56 <avenge> cabal only deals with current working directory.
23:10:06 <avenge> hackage fetches remote packages, and does builds automatically.
23:10:20 <dcoutts_> avenge: though people also want to install the package in the CWD
23:10:29 <avenge> hackage install vs. cabal install
23:10:54 <dcoutts_> mm
23:11:10 <avenge> But they are two different commands, really.  When I want to install what's in the current directory, I say "make install".  When I want to fetch it, I say "emerge blah".
23:11:34 <avenge> I have no problem with two commands for two different things.
23:13:15 <avenge> Or maybe it's cabal install vs. cabal get.  There are some functions (like uninstall) that you want to do in both contexts.
23:14:00 <dcoutts_> in future I hope to have cabal support more targets than just CWD and named package from hackage
23:14:09 <dcoutts_> also local dirs, tarballs, remote tarballs
23:15:43 <avenge> I see.  So thinking out loud, there are sort of three families of functionality you want to support:  1) Just building stuff, like make, 2) managing the repository of installed packages, documentation, ghc-pkg kind of stuff, and 3) is an interface to databases of available software, of which hackage is one, but presumably some day there will be more.
23:18:20 <dcoutts_> avenge: yes, it's quite broad
23:19:17 <avenge> Does this really need to be all one command?
23:19:42 <avenge> In particular, it seems like #1 could really be handled by ./Setup, while #2 and #3 could be handled by cabal.
23:19:51 <dcoutts_> it is of course subdivided into subcommands
23:20:09 <avenge> Is there still a role for ./Setup in your view?
23:20:22 <dcoutts_> avenge: not as a human interface
23:20:37 <avenge> Why not?
23:20:55 <dcoutts_> it's a convenient interface for distro build scripts and to allow multiple implementations of build system
23:21:28 <avenge> But what's wrong with having users invoke ./Setup?  Or just shipping a Makefile that invokes ./Setup?
23:21:38 <dcoutts_> avenge: we found that having the entry point for humans be a program rather than compiling/running a script is rather better
23:21:49 <avenge> What about running Make?
23:21:54 <avenge> I mean make?
23:22:00 <dcoutts_> what do you mean?
23:22:51 <dcoutts_> avenge: one of the first things we wrote was a "cabal-setup" that basically wrapped the runghc Setup interface but handled compiling the Setup.hs with an appropriate version of the Cabal lib
23:22:52 <avenge> I mean when I'm working on my packages, I just have a Makefile that invokes ./setup.  That's something that could easily be autogenerated.  And it's pretty consistent across languages.
23:23:48 <dcoutts_> avenge: there's no problem in having a wrapper to make the Cabal command line API fit into the ./configure; make  stlye API that some packaging systems prefer.
23:24:21 <dcoutts_> it's already modelled on that style of interface
23:24:40 <avenge> Maybe what I'm stuck on is that it seems weird that two very different commands have the same name.
23:25:07 <dcoutts_> I'm not sure they're so different, install this package vs install that package
23:25:11 <avenge> It's fairly common to have package management tools, like apt-get, emerge, or for languages cpan, gem, etc.
23:25:31 <avenge> But I use a different command when what I want to do is build/run what's in the current working directory.
23:25:53 <dcoutts_> for example when you want to install a local package it can go install all the deps too
23:26:09 <dcoutts_> avenge: is that by design or by accident?
23:26:23 <avenge> I'm not sure.
23:26:25 <Cale> What two commands have the same name?
23:26:31 <dcoutts_> avenge: me neither
23:27:03 <avenge> "cabal install".  I'm saying that "cabal install" with no other argument is like "make install", while "cabal install package" is like "emerge package" or "apt-get install package".
23:27:18 <dcoutts_> avenge: I think it's probably possible to have a comprehensible system designed in either way
23:27:23 <Cale> Oh, I rather like that.
23:27:31 <dcoutts_> Cale: which?
23:27:52 <Cale> The fact that you can use cabal install with no additional arguments to install whatever package is in the directory you're in.
23:28:14 <dcoutts_> avenge: but since there's a lot of functionality then obviously we do need to pay attention to the organisation so that it remains understandable by users
23:28:20 <avenge> Cale:  And how would you feel if they were different commands.  Say:  "hackage install foo" vs. "cabal install".
23:28:49 <Cale> That seems less natural to me. Why should there be a separate command when the only difference is where the package's code is located at the moment?
23:29:16 <avenge> One thing that may be tripping me up is that I'm very used to "make install" meaning something particular, and really, the cabal equivalent is "cabal copy".
23:29:38 <dcoutts_> avenge: as far as I can see, the main problem we have is the slight clash on the meaning of "install" in those two scenarios, otherwise they complement ok
23:29:50 <avenge> So this was frustrating me even just now when I forgot that I'd been typing ./Setup install before, and so was confused why cabal install was wiping my source code.
23:29:50 <mae_tae_> hello people....
23:29:56 <tensorpudding> in freebsd's package system, pkg_add foo.tgz installs the local package foo.tgz, whereass doing pkg_add -r foo installs the newest version of foo available in the package repository you use
23:29:57 <dcoutts_> avenge: and I think if we can solve that one then the current design works ok
23:29:59 <mae_tae_> can i ask an opinion here
23:30:13 <mae_tae_> just a sort of logic
23:30:18 <tensorpudding> it uses the same command for that
23:31:03 <avenge> tensorpudding:  Right, that's fine.  But what about the command that today we call "cabal copy; cabal register"?
23:31:04 <Cale> mae_tae_: Sure
23:31:10 <dcoutts_> avenge: one solution might be to remove install from Setup.hs, keep just copy and register
23:31:34 <avenge> Why is register implemented in two places?
23:31:41 <dcoutts_> avenge: hmm?
23:32:02 <avenge> Unless cabal register is defined purely as invoking runghc ./Setup register.
23:32:16 <avenge> Having cabal install and ./Setup install do different things is definitely problematic.
23:32:26 <Cale> One thing which I often do is to delve into the packages already downloaded in ~/.cabal/packages and unpack and edit one before typing cabal install to reinstall it.
23:32:39 <Cale> I never use ./Setup directly.
23:32:40 <dcoutts_> Cale: you know that you can "cabal unpack"
23:33:11 <dcoutts_> Cale: so no need to go poking about in ~/.cabal/packages
23:33:28 <Cale> Okay, if that would be better. It works well enough regardless :)
23:33:33 <avenge> What is the minimum set of commands required for ./Setup?
23:33:47 <dcoutts_> avenge: it's specified in the Cabal spec
23:33:54 <mae_tae> i thank you cale, this is regarding to credit a subject in college as like a transferee, this is scenario to credit example subject "intro to plane and spherical trigometry", now to credit it from his description, it should contain those significant words for it, it should plane, spherical & trigometry, if im going to program, how will i design the rule?
23:34:33 <Cale> What?
23:34:52 <dcoutts_> avenge: for an absolute minimum, from the pov of a packaging system, I'd say: configure, build, copy (optional temp prefix), register (produce a reg file, not actually register)
23:34:55 <avenge> Where is the spec?
23:35:08 <dcoutts_> avenge: on the website, the spec is a little old now
23:35:10 <Cale> mae_tae: I don't think I understand your question.
23:35:25 <avenge> haskell.org/cabal?
23:35:54 <mae_tae> ok, hehehe, do you know the process of subject course advising?
23:36:40 <avenge> dcoutts_: So cabal register and ./Setup register are different commands?
23:37:03 <avenge> I guess one possible principle might be that cabal and ./Setup should have entirely disjoint commands.
23:37:21 <mae_tae> example you are a transferee from other school, before you can be accepted you still undergo subject evaluation right? hehehe, im trying to make a program but i cannot establish the logic, hehehe
23:37:27 <avenge> Or... all ./Setup commands are also cabal commands, but all cabal does in that case is run ./Setup with the arguments.
23:37:31 <dcoutts_> avenge: no, they're exactly the same
23:37:50 <dcoutts_> avenge: cabal wraps most commands and extends a few more
23:37:59 <avenge> So you are saying cabal register does not actually call ghc-pkg?
23:38:17 <avenge> if ./Setup register is the same as cabal register?
23:38:49 <dcoutts_> avenge: if you've got a custom Setup.hs then cabal calls Setup register which calls ghc-pkg
23:39:12 <avenge> Sorry, I thought you set ./Setup register doesn't actually register?
23:39:33 <dcoutts_> avenge: oh, sorry, I meant hypothetical minimal command line api
23:39:52 <dcoutts_> avenge: that would be the minimum needed by a package manager, not that that's what we've got right now
23:40:08 <avenge> Okay.  So what you do think of the principle that if ./Setup xxx is one of the required commands, then cabal xxx does nothing more than invoke ./Setup xxx?
23:41:04 <dcoutts_> avenge: the way I see it, for Cabal 2.x we should explicitly make the Setup.hs a machine interface and design it with the needs of package managers (like cabal or distros or IDEs) rather than humans
23:41:27 <dcoutts_> avenge: the cabal program is supposed to be the human command line interface
23:41:51 <dcoutts_> so I'm not so concerned about 1:1 relationship between commands, that's just how it's grown up
23:41:51 <avenge> I'm fine with that, but I still think that if cabal and ./Setup support a command with the same name, they should do the same thing.
23:42:32 <avenge> I'm just trying to narrow the design space.  If we start from that principle, then we can discuss what are the responsibilities of cabal vs. ./Setup.
23:43:09 <avenge> Right now, it's ambiguous, because, for instance, cabal install and ./Setup install have overlapping but not identical functions.
23:45:37 <dcoutts_> avenge: I agree its not ideal as is, but if we're talking about design then the sensible design I think is for Setup.hs not to be a primary human interface any more
23:46:11 <dcoutts_> reduce functionality and convenience of Setup.hs
23:46:37 <dcoutts_> and make it more easily wrapped/used by package managers
23:46:58 <dcoutts_> which means having it do less and have the package managers in control
23:47:26 <dcoutts_> eg there's no need for a "runghc Setup.hs install" at all
23:50:45 <avenge> So how about if the different functions of cabal are: fetch, unpack, configure*, build*, haddock*, copy*, register, index, uninstall*, clean*, wipe.
23:50:57 <avenge> The ones marked * are just passed straight through to ./Setup.
23:51:26 <avenge> "cabal install x" is equivalent to fetch, unpack, configure, build, haddock*, copy, register, index, wipe.
23:51:37 <dcoutts_> avenge: not uninstall, uninstall is the job of a package manager not a package build system.
23:51:58 <avenge> Ah, so ghc-pkg should uninstall packages?
23:52:09 <theorbtwo> It shouldn't really be possible for a buggy package to be uninstallable.
23:52:12 <dcoutts_> no, a package manager, like cabal, or portage
23:52:34 <dcoutts_> avenge: ghc-pkg just manages a database of registered packages, not installed files etc
23:53:14 <avenge> Oh, I see what you mean.  But if copy is done by ./Setup (which it probably should be), then there has to be a way of specifying auxiliary files.
23:53:15 <theorbtwo> dcoutts_: You mean that the haskellish packaging tools should create an OS-level package, and you use the OS-level tools to (un)install it?
23:53:35 <theorbtwo> That's a good thing to aim for, for a large number of people, but it doesn't work for everybody.
23:53:50 <dcoutts_> theorbtwo: that's one approach, I meant just making cabal track installed files properly
23:54:10 <avenge> So should copy just be the job of cabal, then?
23:54:20 <theorbtwo> Win32 people don't really have an OS-level package manager, and people who don't have root or want to maintain a local set of packages can't use the OS-level package manager.
23:54:38 <dcoutts_> avenge: the package knows which files need to be installed, the package manager should be responsible for installing them and cleaning things again
23:55:00 <avenge> Okay.  So maybe a ./Setup mkreg that makes a registration file?
23:55:04 <dcoutts_> avenge: so a package manager would copy into an empty image directory, make an index and then install, keeping the index.
23:55:52 <dcoutts_> avenge: it's the traditional split between "make install DESTDIR=$image" and a package manager
23:56:26 <avenge> Sure, that sounds reasonable.
23:56:45 <avenge> So now an issue is that there are two kinds of install we want.
23:56:51 <theorbtwo> I'd make the package create a file with current-location -> installed_location mappings, and then the package manager can read that file.
23:57:02 <theorbtwo> Means you end up copying around the same file fewer times.
23:57:11 <dcoutts_> theorbtwo: some files get created at install time
23:57:30 <dcoutts_> theorbtwo: but yes, there's the opportunity for optimisation if you know the build system will be nice.
23:57:32 <theorbtwo> dcoutts_: Yeah, you give the package the chance to create it progmatically.
23:57:42 <dcoutts_> theorbtwo: if you trust it :-)
23:57:49 <avenge> #1 is just build, haddock, copy, register, index (the command to rebuild doc index).  #2 is fetch, unpack, configure, build, haddock*, copy, register, index, wipe.
23:58:04 <avenge> (These are the two kinds of install we want.  #1 for current directory, #2 for remote.)
23:58:43 <theorbtwo> dcoutts_: No, I mean create the dynamic file to be installed and stick it in the list of files to install.
23:59:00 <dcoutts_> avenge: oh, but those two are complementary, the problem is with #1  build, haddock, copy, register and #2 (assume already configured and built) copy, register
23:59:43 <theorbtwo> If you want, the old method can be mapped to the new by simply creating the directory as always, and the creating a list of things to be installed by running find across it.
23:59:50 <theorbtwo> (Or, y'know, portable equivelent.)
