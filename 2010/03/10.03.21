00:21:45 <ivanm> anyone here know much about html encoding/escaping?
00:22:29 <edwardk> what about it?
00:22:57 <edwardk> and html or url?
00:23:14 <ivanm> atm html
00:23:18 <ivanm> given a Char, how do you know if it needs to be escaped (e.g. &#fd; or whatever) ?
00:23:40 <ivanm> I'm looking on the net, but I can't find if there's any specific allowable character range before something needs to be escaped to the unicode code point
00:23:47 <ddarius> edwardk: The answer to this is very likely "no," but have you ever read an old book "Formal Categories: Adjointness for 2-categories"+
00:23:48 <ddarius> ?
00:23:58 <edwardk> so you mean the & -> &amp, < -> &lt; > -> &gt; and  -- everything else is a nicety ;)
00:24:11 <ivanm> so nothing else needs to be escaped? just those ones?
00:24:17 <edwardk> ddarius: fraid not
00:24:33 <edwardk> ivanm: assuming your charset allows the character to be represented, you're fine
00:24:38 <ivanm> *nod*
00:25:16 <ivanm> edwardk: the thing is, I'm not technically doing HTML; this is Graphviz's "HTML-like" labels and the documentation is rather unspecific wrt escaping
00:25:34 <ivanm> it says you have to escape &<>" (but in some cases you don't have to escape ")
00:25:44 <edwardk> ivanm: so if you have the appropriate <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> or the correct http header to say the same, then you can use other characters with impunity
00:25:45 <ivanm> looking at the C code, it seems to do a couple of other escapes though :s
00:25:55 <ivanm> edwardk: not real HTML ;-)
00:26:02 <edwardk> " you need to encode inside of strings
00:26:05 <edwardk> to &quot;
00:26:15 <edwardk> ah
00:26:38 <ddarius> edwardk: What made me interested in it was this, also very old, mailing list post: http://article.gmane.org/gmane.comp.science.types/297
00:26:53 <ivanm> no mention of escaping here: http://graphviz.org/doc/info/shapes.html#html
00:27:22 <ivanm> and here, it says "In addition, the content must be legal XML, so that the special XML escape sequences for ", &, <, and > may be necessary ... " : http://graphviz.org/doc/info/lang.html
00:27:28 <edwardk> ddarius: hrmm
00:27:32 <ivanm> oh, duh, I need to do XML escaping, not HTML escaping
00:27:36 <ivanm> yay for differences! :s
00:28:28 <ivanm> so for XML, I just need to do "&'<> (and optionally space), and de-escaping is for those + converting &#...; values using chr, right?
00:28:46 <edwardk> ddarius: well, he starts off with a bit of a dickish rant, but has something interesting to say that i can't quite decode ;)
00:29:23 <ddarius> edwardk: What he says is not terribly interesting to me, but rather his side comments with interesting references to the aforementioned book.
00:29:46 <edwardk> the 'by coincidence' bit?
00:30:20 <ddarius> Yes.
00:30:53 <edwardk> of course, reading that makes me want to reply on the newsgroup. but of course at 21 years later that may well qualify as the longest gap between a post and a reply in newsgroup history ;)
00:31:21 <edwardk> yeah, i took that to actually be the meat of his message as well
00:34:05 <edwardk> in other news, the buffer stuff from the other day seems to be coming together, treating a Rope as a context comonad over its annotations, and then defining a bunch of comonadic actions for slicing, which is responsible for updating the annotations
00:35:04 <edwardk> but since they are in the context comonad you can see the rope to get at any of the characters you need to figure out how eliminating characters from the buffer affects your annotations
00:35:05 <mornfall> ivanm: Sup?
00:36:24 <ddarius> edwardk: How would things change if you used the reader monad instead of the context comonad?
00:37:15 <edwardk> so 'Rope a' is basically just: (FingerTree ByteString, a) -- and then i define things like class Elidable a where splitAt :: Int -> Rope a -> (a,a), etc.
00:37:23 <edwardk> well, i'd have to expose the guts of the rope that way
00:37:30 <edwardk> the comonad lets me have better abstraction
00:37:38 <edwardk> taking the type apart:
00:37:39 <edwardk> you get
00:38:10 <ddarius> edwardk: Ah, so it's not obvious its the context comonad from the outsied.
00:38:50 <edwardk> splitAt :: Int -> Rope a -> (a,a), Rope a ~ (FingerTree ByteString, a), which through the adjunction you can see splitAt :: Int -> a -> FingerTree ByteString -> (a,a)
00:39:18 <edwardk> as it is, i can govern the fact that the splitAt, etc. methods only have access to the rope methods to manipulate it, and i don't have to double up the public interface
00:40:03 <edwardk> yeah
00:40:32 <edwardk> right now a Rope is a context comonad/writer monad, you can use it as a writer monad to build up a fingertree by writing ropes into it
00:40:50 <edwardk> instance MonadWriter (Rope ()) Rope where ...
00:41:23 <edwardk> which lets you log messages into the fingertree, and even pass/listen them
00:42:17 <edwardk> i needed the context or reader in order to make it so you can split ropes that have more than one annotation
00:44:21 <edwardk> the model is this way i can turn around and run a pass over the buffer that takes care of, say, line pragmas and injects newlines into a separate fingertree that knows how to give standard compiler-style line and column info by just splitting that fingertree and taking the sum over the front half
00:45:39 <edwardk> on the other hand, parsing those line pragmas 'eats text' out of the fingertree, leaving less for subsequent passes to consider, so i need to elide the text for the pragma from the bytestrings i have, and update the bytes that the other annotations expect to see references to.
00:47:03 <edwardk> but then later someone might come along with another pass that collapses other parts of the rope into annotations, say, macro expansion, or ifdef evaluation, or what have you, but in order to update the position info i need the text of the buffer in the place thats being snipped to avoid having to make the pos fingertree hold onto everything.
00:47:34 <edwardk> so when the pos fingertree is asked to elide text it can summarize it into the position monoid
00:47:48 <edwardk> if that is at all coherent
00:48:22 <ddarius> edwardk: How is a rope with two attributes represented?  Rope (Attr1, Attr2) ?
00:48:26 <edwardk> the main goal is for code to be able to just provide me with a dumb byte based index into the trimmed down rope
00:48:31 <edwardk> effectively.
00:49:31 <edwardk> if they are both Elidable, then the composite rope can be split
00:49:52 <edwardk> i like this version for me, but it seems likely less palatable to the general public than my previous version =)
00:50:58 <ddarius> So basically what the Rope type does is separate the base string from the annotations whereas before one was "mixed in." (?)
00:51:08 <edwardk> it looks like i'll get one hell of a nice c preprocessor pass out of it ;) just giving passing around references to the rope and byte indexes, and reversing out line and column info, and knowledge about which includes were involved in the chain, what macros were expanded to get you the text you're indexing in
00:51:12 <edwardk> yeah
00:51:19 <edwardk> originally i had one annotation, the number of extra bytes
00:51:23 <edwardk> now i don't even bother with that
00:51:49 <edwardk> i just add 'negative column' values to the position monoid for each of the extra tail bytes
00:51:52 <edwardk> =)
00:52:21 <edwardk> i lose the super fast parsing i had before which could avoid even bothering with utf8 decoding over large runs of the file
00:52:26 <edwardk> but i gain a nice abstraction
00:53:12 <edwardk> {-# pragmas #-} , #errors, comments, #line directives, trigraphs, etc. can be made to vanish in orthogonal passes.
00:54:38 <edwardk> i'm trying to figure out how i can use this as part of my hygienic macro expander as well by defining a suitable annotation format to track hygiene and provenance on symbols
00:54:48 <ddarius> Presumably Ropes themselves are instances of Elidable.
00:54:52 <edwardk> yeah
00:55:15 <edwardk> thats how i define the generic elide definition.
00:55:22 <edwardk> er
00:55:43 <edwardk> elide :: Elidable a => Int -> Int -> Rope a -> a -- cuts out a few bytes from the center of the rope
00:55:51 <edwardk> but it is implemented in terms of splitAt by default
00:56:06 <edwardk> elide f l ra = fst (extract rlmr) `mappend` drop l (snd <$> rlmr) where rlmr = splitAt f (duplicate ra)
00:57:36 <lpsmith> ok,  so I'm messing around with Takusen,  and trying to use a prepared insert statement with postgres.
00:57:49 <lpsmith> And Takusen barfs on the second insert;  the first seems to work though
00:58:11 <lpsmith> or rather,  Takusen throws an exception after the first (successful) statement
00:58:31 <edwardk> and most of the annotations don't even bother using the rope, so they are easy: i.e. instance Elidable (Map Int v) where splitAt k a = (l, M.mapKeysMonotonic (subtract k) $ maybe id (M.insert k) r) where (l,m,r) = M.splitLookup k (extract a)
00:58:47 <edwardk> just rip the map in half, and update the keys on the right hand side.
00:58:54 <edwardk> though, to be honest, that is a terrible instance ;)
00:59:09 <edwardk> because it takes time linear in the size of the map to elide anything
00:59:20 <edwardk> so you should be using a fingertree based map anyways
01:02:13 <edwardk> in the case that the annotations are nicely monoidal you can of course build the annotation in parallel, which should provide a few nice combinators
01:03:04 <edwardk> the main thing i like is i can dumb down a lot of the little passes i was doing before in kata.
01:03:47 <edwardk> i.e. if i want to find all of the c preprocessing directives in a file i can look for occurences of every # in the file and then filter out from there.
01:03:57 <edwardk> with the former search being done in parallel
01:04:10 <edwardk> so i don't need a whole big monoidal parser
01:04:18 <edwardk> jsut fast parallel search
01:06:21 <lpsmith> edwardk, working on a text editor, or something else?
01:06:41 <edwardk> lpsmith: language parser actually
01:07:07 <edwardk> lpsmith: but i want very expressive diagnostic error messages
01:07:13 <lpsmith> ahh
01:07:28 <edwardk> so it is very useful for me to be able to refer to anywhere in the file, using very small keys and restore exactly the text that was given to me
01:08:43 <edwardk> and i want to be able to say things like at error blah blah blah in a macro defined at file:12: instantiated with arguments ... included from file2:31, included from ...
01:09:15 <edwardk> and i have a very nice position monoid that handles gcc style include directives to deal with the include-stack,etc.
01:09:33 <edwardk> i just want to extend it to support my macros, and needed a better framework to actually use it from
01:09:46 * hackagebot gitit 0.7.3.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.2 (JohnMacFarlane)
01:11:24 <SubStack> wow, I just had a really zen pointfree moment
01:11:35 <edwardk> SubStack: ?
01:11:53 <SubStack> I now understand the magic of (f .) . g
01:12:04 <ivanm> mornfall: just checking: with hashed-storage, the new release has that fix for ppc64, etc. right?
01:12:13 <ivanm> (the darcs repo appears to have it anyway)
01:12:29 <SubStack> and how it scales up even to ((((f .) .) .) .) . g
01:12:29 <edwardk> SubStack: ah
01:12:46 <dolio> "Particular functions may be most naturally defined by recursion, but what is the benefit of defining the type of such functions by recursion?"
01:12:54 <dolio> Because it's the most natural way to define the type?
01:13:14 <edwardk> dolio: reading the dickish rant from earlier?
01:13:45 <dolio> Yeah.
01:13:46 <ddarius> edwardk: I can email you a djvu copy of that book if you are interested in reading the referenced parts.
01:13:54 <dolio> How could that answer have no occurred to him?
01:13:55 <SubStack> most natural means less having to think about the implementation
01:14:29 <edwardk> ddarius: sure. i'll have to take it offline coz i don't want to get too distracted from my current obsession ;)
01:15:05 <edwardk> gah
01:15:55 <SubStack> if only we could just figure out the types and let the computer figure out the implementation!
01:16:11 <edwardk> i give up on the useless little abstraction i was adding.  class Packable a where singleton :: (a `Reducer` m) => a -> Rope m; pack :: (a `Reducer` m) => [a] -> Rope m; unpack :: ...
01:16:13 <SubStack> whatever the name of that plugin is...
01:17:08 <edwardk> but unfortunately, while before i'd added the 'm' argument i was able to make a nice instance Packable a => Packable [a] definition, which let me pack strings into my ropes, or just ask to take a string off the front -- getting whatever it wanted to give me,
01:17:29 <edwardk> the (a `Reducer` m) requirement gets in the way of my doing so here
01:17:48 <edwardk> because in the Packable [a] context, all i have is an ([a] `Reducer` m)
01:18:13 <edwardk> so i can't feed it to the singleton method of the other, etc.
01:18:14 <edwardk> hrmm
01:18:24 <edwardk> i wonder if i could make a newtype wrapper that could do it
01:20:10 <edwardk> SubStack: @djinn does it =)
01:20:16 <SubStack> ah thanks
01:20:22 <edwardk> @djinn a -> (a -> r) -> r
01:20:23 <lambdabot> f a b = b a
01:21:08 <edwardk> @djinn-env
01:21:09 <lambdabot> data () = ()
01:21:09 <lambdabot> data Either a b = Left a | Right b
01:21:09 <lambdabot> data Maybe a = Nothing | Just a
01:21:09 <lambdabot> data Bool = False | True
01:21:09 <lambdabot> data Void
01:21:11 <lambdabot> type Not x = x -> Void
01:21:13 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
01:21:15 <lambdabot> class Eq a where (==) :: a -> a -> Bool
01:21:42 <edwardk> @djinn-add data Cont r a = Cont ((a -> r) -> r)
01:22:13 <edwardk> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
01:22:13 <lambdabot> f a b =
01:22:13 <lambdabot>     case a of
01:22:14 <lambdabot>     Cont c -> Cont (\ d ->
01:22:14 <lambdabot>                     c (\ e ->
01:22:14 <lambdabot>                        case b e of
01:22:15 <lambdabot>                        Cont f -> f d))
01:22:23 <SubStack> I just wrote drawStringCircle = ((((((((consCmd .) . ) .) .) .) .) .) .) . DrawStringCircle
01:22:26 <SubStack> something is wrong with me
01:22:34 <edwardk> yes, something clearly is ;)
01:24:23 <edwardk> fmap (fmap (fmap (fmap (fmap (fmap (fmap (fmap consCmd))))))) <$> DrawStringCircle ?
01:24:33 <ddarius> Anything using Monad with djinn isn't going to actually work well.
01:27:36 <SubStack> hooray for using the state monad to create a poor man's DSL
01:27:49 <ivanm> heh
01:28:44 <SubStack> because modification of images with IO () return types feels so wrong
01:28:45 <SubStack> http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html#v%3AantiAliased
01:29:09 <SubStack> er, ignore the #v%3AantiAliased
01:49:03 <ivanm> blackdog: connection problems?
02:01:32 <ivanm> why doesn't this work?
02:01:39 <ivanm> > read "32" :: [(Int, String)]
02:01:40 <lambdabot>   * Exception: Prelude.read: no parse
02:01:50 <ivanm> shouldn't that return [(32, "")] ?
02:01:56 <Taejo> ivanm: you want reads
02:02:01 <ivanm> oh?
02:02:06 <Taejo> :t read
02:02:08 <lambdabot> forall a. (Read a) => String -> a
02:02:08 <Taejo> :t reads
02:02:09 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:02:11 * ivanm facepalms
02:02:17 <ivanm> duh
02:04:32 <ivanm> that's what I get for not copy-pasting properly :s
02:07:51 <SubStack> yay http://github.com/substack/haskell-gd/blob/master/examples/circle.hs
02:09:17 <mornfall> ivanm: Yes, it does.
02:09:24 <ivanm> good-o
02:14:02 * hackagebot data-category 0.1.0 - Restricted categories  http://hackage.haskell.org/package/data-category-0.1.0 (SjoerdVisscher)
02:14:58 <ivanm> whatever you do, when parsing don't have something like "many $ many foo"; it results in the parser sitting there spitting out infinite empty lists :s
02:29:57 <temoto> Hello. How to compare my type with some other type? http://codepad.org/OAN1V588
02:31:06 <chr1s> temoto: that's not possible
02:31:11 <madf> preflex, seen cale
02:31:12 <preflex>  cale was last seen on #haskell 13 hours, 30 minutes and 38 seconds ago, saying: I'm not sure how they deal with it, or much in the way of results in shougi AI.
02:31:15 <chr1s> You can look at the type of (==)
02:31:24 <nomeata> Hmpf. No instance for (Binary Text). Stuff like this kindof sucks.
02:31:35 <temoto> @type (==)
02:31:36 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:32:09 <chr1s> temoto: so both arguments have to be of the same type.
02:32:09 <temoto> chr1s, so this means both types have to be the same?
02:32:14 <nomeata> hmm, actually, not too bad in my case as I want to control the encoding.
02:32:40 <temoto> chr1s, thank you.
02:33:41 <Cale> temoto: Types are all checked at compile time. If it's necessary that two things should be the same type, then it'll already have been enforced before the program ever gets a chance to run.
02:44:29 <ksf> how can I run a get-parser over a lazy bytestring?
02:44:37 <ksf> I've got those parsers and just want to use them
02:44:44 <ksf> ...over the network
02:49:50 <jlouis> ksf: a Parsec one?
02:53:02 <ksf> a data.binary.get one
03:16:03 <jlouis> ksf: isn't that using lazy bytestrings?
03:16:18 <jlouis> ksf: v0.5.0.2 says that it is
03:20:46 <ksf> it is
03:20:55 <ksf> I was looking at the wrong version
03:21:13 <ksf> now if I wasn't scared of lazy IO
03:26:13 <systemfault> Anyone familiar with parallel haskell?
03:26:35 <systemfault> I can't seem to make the RTS understand that I need to use 2 CPU
03:27:06 <systemfault> foo +RTS -N2   is what I see on a lot of website but.. doesn't work for me (Invalid option)
03:29:43 <Zao> systemfault: Did you build your application -threaded ?
03:29:58 <Zao> The RTS doesn't grok -N otherwise, as there's no MP going on.
03:30:41 <mreh> there is a problem with parallel haskell in some linux kernel versions I seem to remember
03:30:41 <systemfault> Zao: I'll recheck to be sure
03:30:48 <systemfault> I'm on OSX
03:31:15 <mreh> I don't know about OSX
03:31:22 <systemfault> Ah ok :)
03:31:26 <systemfault> Works now
03:31:29 <mreh> it could be that your annotations are not working
03:31:34 <mreh> :)
03:31:45 <mreh> did you compile with -threaded?
03:32:07 <systemfault> That was the problem.. I did but i didn't pass -fforce-recomp
03:32:57 <Zao> systemfault: The non-threaded runtime could probably use more helpful diagnostics.
03:33:02 <Zao> Might break things though.
03:33:34 <mreh> I've never used -fforce-recomp
03:33:47 <mreh> is it the equiv of rm *.o *.hi and recompiling?
03:35:03 <Zao> Something along those lines.
03:35:10 <systemfault> mreh: Yeah..
03:35:44 <mreh> I use cabal :)
03:35:53 <mreh> no more tangles
03:37:24 <systemfault> @src maximum
03:37:24 <lambdabot> maximum [] = undefined
03:37:24 <lambdabot> maximum xs = foldl1 max xs
03:37:30 <ksf> gnargh attoparsec-iteratee folds over the stream, it doesn't map.
03:39:31 <ksf> convStream is basically the most important feature of iteratees, and I don't want to go without it.
03:39:36 <mreh> banter in the house of commons this week
03:40:25 * hackagebot salvia-protocol 1.0.0 - Protocol suite for the Salvia webserver, including functionality for URI, HTTP, Cookie and MIME.  http://hackage.haskell.org/package/salvia-protocol-1.0.0 (SebastiaanVisser)
03:41:04 <jlouis> mreh: -fforce-recomp circumvents the "uptodate" check on a compile
03:41:25 * hackagebot bidispec 0.1 - Specification of generators and parsers  http://hackage.haskell.org/package/bidispec-0.1 (DavidLeuschner)
03:42:26 * hackagebot httpspec 0.1 - Specification of HTTP request/response generators and parsers  http://hackage.haskell.org/package/httpspec-0.1 (DavidLeuschner)
03:48:27 * hackagebot ghc-core 0.5.3 - Display GHC's core and assembly output in a pager  http://hackage.haskell.org/package/ghc-core-0.5.3 (DonaldStewart)
03:56:27 * ksf is going to name his parsing combinators yoctoparsec and write the fastest 9p parser ever.
03:57:51 * Phyx- doesn't support there are any c# experts here?
03:58:22 <Zao> I hear they all hide in ##csharp
03:58:22 <Fallen_Demon> Axman6, hey, what's with the Hackfest thing at UNSW?
03:58:36 <Phyx-> Zao: #c is so quiet it's kinda scary
03:59:56 <Zao> Try our -blah?
04:01:58 <Phyx-> Zao: i'll wait and see if anyone in c# wakes up
04:02:57 <chrisdone> for benchmarking purposes, does this look like a good way to force evaluation of a list value?
04:02:57 <chrisdone> forceEval :: [a] -> ()
04:02:58 <chrisdone> forceEval xs = go xs where
04:02:58 <chrisdone>     go (x:xs') = go (x `seq` xs')
04:03:00 <chrisdone>     go []     = ()
04:07:06 <chrisdone> (actually, it's a list of Char, should point that out)
04:07:33 <zeiris> Char is unicode, right/
04:08:09 <opqdonut> yeah
04:08:28 <opqdonut> > fromEnum (maxBound :: Char)
04:08:29 <lambdabot>   1114111
04:09:53 <zeiris> :t fromEnum
04:09:54 <lambdabot> forall a. (Enum a) => a -> Int
04:09:56 <chrisdone> n/m
04:10:37 * hackagebot rmonad 0.5 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.5 (GaneshSittampalam)
04:12:24 <Fallen_Demon> I used to have a haskell bot somewhere
04:12:28 <Fallen_Demon> I called it herpesBot
04:14:39 * hackagebot salvia-protocol 1.0.1 - Salvia webserver protocol suite supporting URI, HTTP, Cookie and MIME.  http://hackage.haskell.org/package/salvia-protocol-1.0.1 (SebastiaanVisser)
04:25:32 <Cale> chrisdone: Why not  forceEval xs = foldl' (flip seq) () xs
04:25:51 <Cale> chrisdone: Or even just  forceEval xs = foldr seq () xs
04:27:03 <Cale> Though, the foldl' variant is probably a bit better for the purpose.
04:27:18 <Cale> (at least, without optimisations being on)
04:29:22 <Cale> In fact, in ghci, both foldr and foldl' do a better job than forceEval (though it's probably just because the foldr/foldl' functions are already compiled, while I just defined forceEval on the ghci prompt and so it would be bytecode interpreted)
04:43:56 * hackagebot DPM 0.2.0 - Darcs Patch Manager  http://hackage.haskell.org/package/DPM-0.2.0 (StefanWehr)
04:55:59 * hackagebot jpeg 0.0.1 - A library for decoding JPEG files written in pure Haskell  http://hackage.haskell.org/package/jpeg-0.0.1 (AtzeDijkstra)
05:01:08 <zeiris> Is there a way to programmatically manipulate a Record structure? Like iterate through the names or something?
05:01:48 <ivanm> don't think so (if I understand what you're wanting)
05:01:55 <ivanm> maybe with TH *shrug*
05:02:00 <ivanm> the types would be a problem
05:02:09 <jlouis> put the record names in a list, apply each element from the list to the record
05:02:21 <zeiris> And if I have a map, everything innit has to be the same type... So I'd need to use Dynamic or something to store multiple types.
05:02:29 <jlouis> wrap it with some post-processing functions
05:03:09 <ivanm> jlouis: only works if all the records are of the same type
05:03:16 <Ferdirand> if you have different types, what will you be able to do with it inside the iteration ?
05:03:26 <ivanm> zeiris: yeah, use a forall if you absolutely have mixed types
05:03:39 <ivanm> but as Ferdirand says, you won't be able to do much if they're different types
05:04:03 <jlouis> ivanm: depends in [f . getA, g . getB, h . getC] it doesn't have to be
05:04:23 <ivanm> hmmm.... maybe
05:04:24 <zeiris> I guess that's what I get for starting a project in Python then switching to Haskell :D
05:04:27 <jlouis> of course the result has to be of the same type
05:04:35 <ivanm> it sounds like a bad thing to do in general though
05:04:38 <jlouis> but if the result is IO ()...
05:05:01 <ivanm> zeiris: you should never try to code like you do in language Foo in language Bar (where Foo /= Bar)
05:05:13 <ivanm> even if the languages are similar (e.g. SML and OCaml) they tend to have their own quirks
05:05:18 <ivanm> even stylistically
05:05:29 <ivanm> jlouis: still the same type, is it not? ;-)
05:05:42 <jlouis> ivanm: true!
05:06:03 <zeiris> But I want to :(
05:06:15 <ivanm> zeiris: trust me, you don't
05:06:22 * ivanm force-feeds zeiris the haskell kool aid
05:06:31 * ivanm isn't even sure why he's using that stupid phrase
05:06:33 <jlouis> ivanm: but I figured that when one of them does launchNukesAndDestroyEarth it doesn't really matter
05:07:30 <ivanm> heh
05:07:39 <arcatan> *unsafeLaunchNukesAndDestroyEarth
05:07:44 <jlouis> zeiris: to me, traversing the member fields of a Python class is equally non-idiomatic
05:08:04 <jlouis> arcatan: o.O - there is a safe variant?
05:08:26 <zeiris> Yeah, the thing I'm trying to approximate is a dictionary storing a bunch of different types. Map would be ideal, but using a Dynamic wrapper complicates the syntax when comparing stuff.
05:09:23 <jlouis> zeiris: oh, that is intended behaviour to make sure you don't miss some nasty conversion
05:10:07 <jlouis> you have to type a bit more to make sure you won't generally get a nasty exception at runtime
05:10:12 <ivanm> arcatan: something I've always wanted to do: get one of those USB missile launchers, write Haskell bindings and then actually define an unsafeLaunchMissiles function! \o/
05:10:35 <zeiris> Yeah, I can see reason in it. But I have a vision of the code I want to write in the end, and throwing in toDyn would make it unbeautiful :(
05:11:12 <ivanm> then don't write it that way
05:11:48 <jlouis> zeiris: what are you storing as values? Perhaps there is a better representation which avoids the problem completely
05:12:41 <zeiris> I'm going from a bitstream, to some data structure full of (key,value) pairs where keys can be whatever (as long as they're readable when appearing in code) and values are mostly integers with one or two strings.
05:12:57 <zeiris> I guess the final, final representation is all strings for values.
05:14:07 <ivanm> sounds like you're doing it wrong...
05:14:13 <ivanm> I mean, you could be parsing a Map there...
05:14:15 <ivanm> but still
05:14:38 * ivanm -> replicateUntil timeToWakeUp 'z'
05:14:45 <zeiris> Well, going from bitstream to final representation, involves occasionally looking at the values you get in between.
05:15:00 <zeiris> So a map, or even better some form of record, seems ideal.
05:16:25 <jlouis> I would just do: data R = RInt Integer | RStr String; parse :: ByteString -> [(Key, R)]; and then use M.fromList
05:16:58 <jlouis> eventually roll your own M.fromList if you need to look up earlier keys
05:18:07 <Axman6> thunder93#burgling
05:18:07 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
05:18:30 <Axman6> urgh
05:19:16 <ivanm> Axman6: oh, you are here
05:22:05 * hackagebot epic 0.1.5 - Compiler for a supercombinator language  http://hackage.haskell.org/package/epic-0.1.5 (EdwinBrady)
05:22:08 * hackagebot ivor 0.1.12 - Theorem proving library based on dependent type theory  http://hackage.haskell.org/package/ivor-0.1.12 (EdwinBrady)
05:23:06 * hackagebot idris 0.1.5 - Dependently Typed Functional Programming Language  http://hackage.haskell.org/package/idris-0.1.5 (EdwinBrady)
05:25:25 <CBro2007> Hi guys
05:25:59 <CBro2007> I had spoken to you guys about wanting to learn Haskell ... I got no functional programming background and done lots of C,C++, Java and Perl
05:26:17 <CBro2007> so was wondering if there were online courses to teach functional programming?
05:26:27 <CBro2007> or can it be a self-learning process?
05:26:51 <Axman6> preflex: seen tyrshand
05:26:52 <preflex>  Sorry, I haven't seen tyrshand
05:27:05 <CBro2007> I mean do I need to first understand the theory of functional programming before I even start to learn Haskell.. or while learning Haskell I can learn fp?
05:27:24 <jlouis> CBro2007: do both at the same time i'd say
05:27:34 <narens> does anyone know how to use Data.Vector.Unboxed.Mutable? I want to create a vector of type IOVector Int, but ghci complains
05:28:29 <jlouis> CBro2007: http://haskell.org/haskellwiki/Tutorials has the list of places to start
05:28:30 <narens> this is the link to the package http://hackage.haskell.org/packages/archive/vector/0.5/doc/html/Data-Vector-Unboxed-Mutable.html
05:28:43 <Axman6> @where lyah
05:28:43 <lambdabot> http://www.learnyouahaskell.com/
05:28:46 <Axman6> CBro2007: ^^^^^^^^^^^^^^^^^^
05:29:05 <BONUS> interesting tidbit: i actually added a new section yesterday :)
05:29:11 <jlouis> CBro2007: usually, we recommend Real World Haskell and LYaH to beginners. Which one you like depends a bit on your earlier experience I guess
05:29:19 <BONUS> gonna put up monoids in the next couple of days and then monads in the coming week or two
05:30:02 <CBro2007> ok
05:30:23 <CBro2007> but the theory... is that covered in Real World Haskell and LYAH?
05:30:54 <CBro2007> or would you recommend a general book for the theory of FP to supplement these books?
05:30:57 <jlouis> CBro2007: yes
05:31:04 <jlouis> to the first
05:31:10 <CBro2007> ok
05:31:30 <jlouis> the ideas are much easier to learn if you can try them out
05:31:32 <CBro2007> its just that I think next semester after my break at uni we will have a FP course but I think they use ML in it
05:31:38 <Axman6> start learning the language, then learning what FP is all about imo
05:32:17 <CBro2007> hmm just want it so that when I get a bit comfy with Haskell programming I will then be able to see similarities and also do ML
05:32:34 <CBro2007> are there similarities between Haskell and ML?
05:32:38 <Axman6> you won't want to use ML once you've learnt haskell ;)
05:33:03 <CBro2007> hahah yeah sure thing
05:33:16 <CBro2007> ask the ML guys and they will give me the reverse opinion
05:33:35 <Axman6> except all the ML guys who learnt haskell, and didn't go back
05:34:04 <jlouis> narens: let a = new 70 :: IO (MVector (PrimState IO) Int)
05:34:55 <CBro2007> I always wondered that if you got some really massive tree structure and you were using recursion... how Haskell would handle tree traversals etc
05:35:07 <CBro2007> would I be able to optimize things there?
05:35:59 <jlouis> CBro2007: in a tree lookup, the recursion is usually compiled into a loop
05:36:21 <CBro2007> compiled into a loop?
05:36:31 <jlouis> tail call optimization
05:36:37 <CBro2007> hmm ok
05:37:06 <jlouis> recursion isn't necessarily slow
05:37:10 <CBro2007> so the call stack won't run out of memory
05:37:19 <CBro2007> no I don't believe it is either
05:37:40 <CBro2007> and what about parallel programming with Haskell... is there a concept of threads or MPI?
05:37:44 <narens> jlouis: thanks!
05:38:02 <zeiris> The ability to work with "infinite" data structures due to lazy evaluation is cool, too.
05:38:05 <CBro2007> I am doing a parallel computing course but in C/C++ and its pretty cool shit
05:38:25 <Axman6> CBro2007: Haskell is one of _the_ best languages for parallel programming. it's one of it's big features
05:38:44 <jlouis> CBro2007: MPI: Not so much, but Parallel on the box with more cores is utterly superior to any other language I've tried yet
05:38:46 <Axman6> mainly because of the purity haskell enforces
05:38:48 <CBro2007> so my understanding from reading Wikipedia is that in functional programming you are defining the problem really not explaining how to get the solution
05:39:00 <Axman6> yes
05:39:03 <CBro2007> ok
05:39:25 <CBro2007> so this part I was not so sure about
05:39:29 <Axman6> there's no shared state, so it's extremely easy to parallelise basically anything
05:39:44 <CBro2007> I mean I understand how you can use recursion and in a few lines do some cool shit
05:39:54 <RayNbow> Axman6: to efficiently parallellize is difficult though
05:39:56 <Axman6> you get far more guaranters about things in haskell than you ever will in an imperative language
05:40:06 <Axman6> RayNbow: in any language, yes ;)
05:40:11 <CBro2007> but say you wanted to do something low-level with the solution ... would you be able to do that?
05:40:27 <RayNbow> Axman6: that's right, but it should be mentioned anyway :)
05:40:31 <CBro2007> like do some crazy traversal ... not any of the normal ones
05:40:40 <CBro2007> :) sorry cannot think of a good example
05:40:45 <CBro2007> but just wondering
05:41:14 <jlouis> CBro2007: If you want really fast Haskell, you have to know a bit about how the compiler work. But that is true for any language out there
05:41:26 <Axman6> CBro2007: it's possible to create a a multi million node tree, and then traverse it, whle using a very small constant space (thanks to laziness)
05:41:31 <CBro2007> yeah true
05:41:35 <CBro2007> GHC yeah?
05:41:36 <Axman6> basically, you won't ever create the three at all
05:41:39 <CBro2007> is that the compiler?
05:41:44 <Axman6> yes
05:41:47 <jlouis> CBro2007: One of them. There are several
05:41:54 <CBro2007> hmm cool
05:42:04 <jlouis> GHC utterly dominates thouh
05:42:06 <Cale> Not just a multi million node tree too, you can construct an infinite tree :)
05:42:29 <SubStack> best to post this in here before r/haskell tears me to shreds: http://substack.net/posts/b2b34c/Haskell-GD-Bindings-and-the-State-Monad
05:42:34 <Axman6> ghc is probably one of the most advanced compilers there exists these days
05:42:37 <CBro2007> but if you wanted to write your own traversal or some new algo that you are trying to implement... I wonder how to go about it in haskell
05:42:42 <jlouis> Not just an infinite tree, you can construct an infinite tree in constant space :))
05:42:58 <Axman6> CBro2007: haskell is made for defining algorithms
05:43:18 <Axman6> @src (^)
05:43:18 <lambdabot> x ^ 0            =  1
05:43:18 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:43:18 <lambdabot>   where f _ 0 y = y
05:43:18 <lambdabot>         f x n y = g x n
05:43:18 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:43:19 <SubStack> Axman6: of course, it's written in haskell!
05:43:20 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:43:21 <CBro2007> like I mean if you have just a single liner like ... "traverse depth-first tree t)
05:43:22 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:43:23 <SubStack> how could it not be advanced?
05:43:36 <CBro2007> ok
05:44:11 <CBro2007> ok would you say that Haskell is basically like putting your question in a MATHEMATICAL construct?
05:44:17 <CBro2007> almost looks like that with the lambdabot
05:44:32 <Axman6> somewhat, yes, it's strongly based on lambda calculus
05:44:44 <Cale> CBro2007: You can certainly think of it like that. Haskell functions are actual mathematical functions.
05:44:56 <CBro2007> ok gotcha
05:45:21 <jlouis> And the result tends to be small concise programs that are easy to maintain
05:45:32 <CBro2007> so basically any idea you get you can pretty much lay it out in lambda calculus and you got a working haskell program... in some sense I suppose
05:45:34 <Cale> CBro2007: In that the only effect of applying a function to some parameters is to produce a result, and the result produced only depends on the value of the parameters.
05:45:38 <Axman6> x = y means that x is exactly equal to y, and you can replace any occurance of y with x, and x with y
05:45:50 <fax> CBro2007: no I don't think so
05:46:06 <Axman6> @where lyah
05:46:06 <lambdabot> http://www.learnyouahaskell.com/
05:46:11 <Axman6> CBro2007: go forth and learn!
05:46:17 <jlouis> nono!
05:46:20 <jlouis> not forth!
05:46:21 <Axman6> ask questions when you've got some material to ask them about ;)
05:46:28 <Axman6> go forward!
05:46:29 <CBro2007> ok sure thing
05:46:31 <Axman6> no haskell!
05:46:35 <Axman6> uh, go(
05:46:36 <Axman6> u7
05:46:38 <Axman6> ~345gtkerjkhcdv
05:46:40 <Axman6> -_-
05:46:48 <jlouis> not Go either
05:46:52 <CBro2007> I will have to learn haskell over summer
05:46:56 <Axman6> start now
05:47:01 <SubStack> yes, do it now
05:47:03 <SubStack> it takes forever
05:47:05 <zeiris> It takes a while to sink in.
05:47:07 <CBro2007> just at uni we got no haskell people .... its either ML lovers or LISP lovers
05:47:09 <jlouis> and you have lambdacats on your keyboard Axman6
05:47:25 <zeiris> And in the meantime, you'll benefit from getting a new, data-structure centric perspective on programming.
05:47:29 <CBro2007> and LISP looks kinda shitty to me with all those braces and stuff... haskell code somehow looks cleaner to me
05:47:30 <CBro2007> :)
05:47:41 <chrisdone> CBro2007: http://tryhaskell.org/
05:48:08 <zeiris> Do they sell LISP-friendly keyboards where f and j are ( and )?
05:48:20 <jlouis> The looks of lisp is deceptive
05:48:23 <chrisdone> zeiris: there are free editors that let you do that
05:48:45 <kpreid> I just edited my keyboard layout to swap [] and (). useful for other stuff too
05:48:49 <Axman6> CBro2007: once you learn haskell, you'll realise what those ML and lisp guys are missing ;)
05:48:57 <kpreid> *most* programming languages have more () than [].
05:49:11 <Axman6> they don't even have a super awesome type system that's (almost) turing complete!
05:49:11 <kpreid> heh, except haskell code working with lists :)
05:49:12 <chrisdone> kpreid: indeed, it's a good idea to swap them
05:49:13 <CBro2007> Axman6: yeah I actually want to implement some of their stuff better using Haskell...
05:49:31 <kpreid> I also swap \ with | and : with ;
05:49:38 <jlouis> Axman6: C++ templates ARE turing complete... :)
05:49:44 <chrisdone> kpreid: good idea
05:49:44 <Axman6> CBro2007: shouldn't be too hard
05:49:52 <Axman6> jlouis: is C++? :P
05:49:59 <lpsmith> lisp's syntax has it's advantages
05:50:01 <jlouis> Axman6: I dunno, really
05:50:10 <CBro2007> I rewrote this algo someone wrote in Lisp in C... and they didn't think it was funny ... coz their shit took like 6 mins to execute and C did it in 2.5 seconds or something max!
05:50:13 <Axman6> anyway, sleep time. night all
05:50:24 <lpsmith> For one,  homoiconicity is nice,  that's something Haskell doesn't do very well
05:50:42 <Axman6> CBro2007: just so you know, haskell can be damn fast, up there with C (in some cases faster too)
05:50:49 <jlouis> CBro2007: then they did not know much Lisp :)
05:50:57 <chrisdone> JaffaCake: hi there =)
05:51:21 <CBro2007> jlouis: nah actually they are pretty good LISP coders... they been doing it for like 10 yrs or so...
05:51:23 <moshisushi> chrisdone: you're highlighting the wrong clone :)
05:51:35 <CBro2007> so I am quite sure they did their best to optimize it etc
05:51:49 <chrisdone> moshisushi: are you at zurihac?
05:52:06 <moshisushi> chrisdone: i really don't even know what that is
05:52:12 <moshisushi> so no, i'm probably not there
05:52:37 <jlouis> CBro2007: something is clearly wrong there. 10-15 seconds perhaps, but 6 minutes suggest something is going utterly wrong
05:53:33 <CBro2007> jlouis: you are right... they were actually using a different algorithm or should I say their interpretation of it
05:53:54 <lpsmith> also,  i find hypenated-identifiers much easier on the eyes than ugly_underscores or camelCase
05:54:15 <CBro2007> jlouis: which I didn't agree to and thought they had over complicated it ... so I redid it in C in a different way... so yeah it could very well be that they are doing too much work that they didn't need to in the first place
05:54:41 <chrisdone> lpsmith: me too. easier to type, too
05:55:32 <CBro2007> thanks guys... will read up this summer... look forward to learning Haskell.. hopefully I can learn it and not think procedurally all the time
05:55:33 <CBro2007> :)
05:56:45 <jlouis> CBro2007: or rather, know when it is not beneficial to enforce an imperative style on something which can be explained more succinctly with another
05:57:34 <CBro2007> jlouis: is there things that can be done better in C maybe than in Haskell? would you come across things that would be an overkill to write in haskell?
05:58:16 <danderson> is there a dependency graph somewhere of all of hackage?
05:58:31 <danderson> (as in a drawing that I can stare at, not a graph for Cabal's use)
05:58:49 <mreh> I think someone did that, but it's a huge image
05:58:52 <jlouis> danderson: there might be a graphviz producer
05:59:02 <mreh> it's on haskell.org
05:59:13 <mreh> @google visualising haskell
05:59:15 <lambdabot> http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/
05:59:15 <lambdabot> Title: Visualising the Haskell Universe Â« Control.Monad.Writer
05:59:18 <jlouis> CBro2007: most languages have problems at which they shine
05:59:30 <jlouis> have areas*
05:59:34 <danderson> cheers
06:00:11 <CBro2007> jlouis: I can imagine that maybe a problem is much harder to describe but it has a very simple solution... that might be easier to do procedurally maybe?
06:00:29 <CBro2007> jlouis: I think I should look into lamba calculus too.. to get an idea
06:01:16 <jlouis> CBro2007: lambda calculus can wait. It is the fp equivalent of a turing machine
06:02:11 <fax> lambda calculus is the most important thing in computing :P
06:02:30 <CBro2007> ok
06:10:18 <mreh> they're the same thing, probably
06:11:01 <mreh> why is the main contributor to AI articles on wikipedia the keyboardist in Counting Crows
06:14:37 <mreh> wouldn't someone more academic take up the position, not that there aren't good amateurs out there
06:16:12 <zeiris> Gah, I can't get it how I want it. I'm trying to represent it as a monad, and while that nicely solves the problem of checking previous values, tweaking them a little, or looking ahead... Doing name<-peek$ every time I want to use the variable later is ugly, and results in a lot of extra code for the flags.
06:16:31 <zeiris> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24209
06:17:20 <fax> zeiris, I blame if/then/else
06:17:47 <fax> if we  bool  instead of (a FUNCTION.. what a novel idea) then changing to  boolM  would be a 1 letter change and it would let you not have to write (<-)
06:18:20 <zeiris> I could go back to the idea of storing the thing as a tree of data = Chunk a | If conditionFunc chunka chunkb, but then dealing with loops/data lookahead/data tweaking would complicate things.
06:19:24 <zeiris> Although I suppose data = Chunk | If condition chunk chunk | loopwhile condition chunk | tweak function | done isn't TOO bad.
06:19:58 <zeiris> And yeah, being able to do ifM would be niice.
06:21:40 <ski> zeiris : your latter `if' is missing a `then' and an `else'
06:22:10 <fax> zeiris, I tend to go with bool because if brings bad memories
06:22:22 <zeiris> Oh yeah. That's when I realized I'd have to do flagname <- peek$Flagname for most flags and gave up :E
06:22:30 <ski> zeiris : typically `if foo then bar... else return ()' would be written `when foo $ do bar...' instead
06:22:43 <Remy__> I'm having some trouble using the Parsec parser
06:22:56 <Remy__> sometimes it reports with an error "unexpected... " but it does not show "expecting..."
06:23:21 <Remy__> I have tried to include a "<?>" after every use of "<|>" but still I have cases where parsing fails without an expected
06:24:20 <Remy__> hm
06:24:41 <Remy__> can someone help me with the parsec problem?
06:24:44 <ski> zeiris : hm, what does `peek' do ?
06:25:26 <zeiris> Look up a Key in a Map stored in a StateT within Unpacker
06:26:00 <zeiris> (And pull it out of the Dynamic, erroring if it's not an integer. I guess I need to have peekStr and peekInt.)
06:26:51 <ski> what is its type ?
06:27:10 <ski> (you appear to apply it to `Unpacker'-actions ..)
06:27:44 <zeiris> Oh. hm. Actually the type is :: Unpacker Key. It looks up the last value unpacked.
06:28:09 <ski> that can't be the type of `peek', since it obviously is a function
06:28:11 <zeiris> Err, Unpacker ()? I'm confused.
06:29:24 <ski> (but now i note `(%)' monadically return a value of the `k' key type (maybe it returns the same key it was passed ? (why ?)))
06:30:12 <ski> also, the `where' there looks malplaced
06:30:49 <zeiris> Type signatures are horribly wrong :E
06:31:27 <ski> which of `%' and `<<' binds tighter ?
06:32:02 <zeiris> Equal, left to right.
06:32:35 <ski> so `<<' binds tighter in `Packet%8 << [0x9c,0x9d]' then ..
06:32:58 <zeiris> Does left to right not mean what I thought it means? :o
06:33:00 <ski> (or, hm, the other way around .. /me forgets what "left to right" means here)
06:33:09 <zeiris> Phew, had me worried there.
06:33:49 <ski> `a + b * c' is `a + (b * c)' .. i was thinking of that as "left to right" .. maybe you would say the opposite
06:34:31 <zeiris> Well, with equal binding priority, a + b + c is 'left to right'. I thought.
06:34:35 <ski> (.. "left to right" because the left operator is the outermost, in the AST)
06:35:00 <ski> well, `+' is left-associative, so `a + b + c' is `(a + b) + c'
06:35:25 <ski> (.. so i would say "right to left" about that)
06:35:37 * ski wonders whether we are sufficiently confused, yet
06:35:54 <zeiris> I... Don't know. I'm gonna go look for coffee.
06:36:35 <ski> zeiris : anyway .. maybe you could find some answers to my questions above about your actual code
06:37:39 <ski> i.e. what are the intended type signatures of `(%)',`(<<)',`peek'
06:37:40 <ski> ?
06:38:45 <ski> also, if `(%)' stores a "chunk" under a key in the state, can't you use the key to retrieve it later (like in the `if'), instead of immediately also putting the "chunk" in a variable
06:38:49 <ski> ?
06:38:58 <ski> (`packet <- peek $ ...', &c.)
06:41:29 <zeiris> Revised << type signature at the bottom: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24209#a24218
06:42:01 <zeiris> I'd like to do that, yes, but the if condition must be pure. So I have to retrieve it at some point, because the state is in the Unpacker monad.
06:42:20 <zeiris> I'm not sure if I'm going at all this slightly, or horribly wrong.
06:43:20 <fax> not wrong at all
06:44:42 <zeiris> What I'd like is a parser for a long bit-packed structure that: 1. can do sanity range-checks on some values 2. gives detailed information on failure position. Preferably, it should also 3: allow me to occasionally restrict the ranges of certain keys 4: tell me the next place the values can possibly occur if a failure occurs, or do a partial parse and return both a parser and the remaining bitstream in case of failure...
06:45:56 <zeiris> Oh yes, the parser must also: be able to use previously parsed values to guide future parsing. And occasionally look ahead in the bitstream. Which is why the monad is so, so tantalizingly close, while also providing the potential for almost C-like speed.
06:47:44 <ski> you could define `ifM :: Monad m => m Bool -> m a -> m a -> m a' ..
06:48:54 <zeiris> I'd also need andM, or to lift && into it... Perhaps the beauty of a DSEL is asymptotic, and I've just reached the point of diminishing returns :(
06:49:18 <zeiris> At least I've got the beautiful Keyname%ChunkSize << ValidRange thing going :D
06:49:58 * ski really should try to (finish and) implement his reflective syntax some time
06:52:22 <ski> (i think this would be a situation where it would be handy to use. something like
06:53:29 <ski>    when ([> ([< retrieve Packet) == 0x9d && ([< retrieve action) == AutoUnequip) $ do
06:53:37 <ski>      OwnerAction % 8
06:53:43 <ski>      OwnerAction % 8
06:53:44 <ski> )
06:54:16 <ski> (er, `                        OwnerID     % 32
06:54:22 <ski> ' in the latter case)
06:57:29 <MisterN> hmm real world haskell starts a bit slow but it seems to be quite good so far
06:57:35 <ski> hm .. `maybe' is often useful to partially apply as `maybe no yes'; maybe `ifM' should have the boolean action as last argument too, then
06:58:02 <ski> but then it looks a bit ugly when you don't partially apply (since the branches can be relatively big)
06:59:28 <ski> maybe the solution is to use a flipped application operator, like `boolAction >$ ifM (...) (...)'
07:01:38 <jinjing> anyone have experience with domain registration?
07:03:02 <jinjing> in particular how to deal one, if they suddenly raise the price from $25 to $160?
07:03:34 <jinjing> sorry off topic
07:03:38 <zeiris> After you registered it?
07:03:42 <sm> hi jinjing. You mean $25 for year 1, then raised for year 2 ?
07:03:43 <jinjing> yeah
07:03:50 <jinjing> no after I register it
07:03:56 <jinjing> 7 days after that, I got email
07:04:01 <jinjing> saying I should pay 160
07:04:13 <sundaymorning> this is odd, for some reason haskell.org has been unreachable from where I am :-/
07:04:34 <sm> jinjing: are they trying to shut you down already ? :-/
07:04:37 <jinjing> I'm really a noob here, i'm kinda of stuck
07:05:02 <jinjing> sm: this is the email http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24220#a24220
07:05:11 <sm> that is unusual behaviour of registrars, at least in the US
07:05:51 <jinjing> well, the domain I register is for a wiki to help more people by pass the great firewall
07:06:00 <sm> yes, i saw your gitit list posts
07:06:00 <jinjing> now I don't know what to do
07:06:31 <sm> from the message it sounds like you could wait, then try again with another registrar. But there's a chance you could lose the domain
07:06:32 <jinjing> i mean I don't need the name, I could always go for another name, but this is weird
07:06:41 * sm doesn't know
07:07:31 <jinjing> sm: thanks
07:07:45 <BBanny> hey im a haskell newbie. Can anyone help me ?
07:08:08 <Zao> BBanny: Depends on if you ask well-founded questions or not.
07:09:28 <JuanDaugherty> BBanny, this a pretty friendly channel so go ahead and ask.
07:09:34 <JuanDaugherty> *this is
07:09:47 <BBanny> well, i have been worknig on an assignment to create a deck of cards, shuffle and deal it. Iv got some code written down already, which works, my only problems are shuffling and dealing
07:10:10 <ski> @paste
07:10:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:10:27 <sm> jinjing: good luck.. I assume you watch the other similar projects to see what works/doesn't work
07:10:28 <mauke> @where shuffle
07:10:29 <lambdabot> I know nothing about shuffle.
07:11:29 <BBanny> sorry, really stupid, but how do i use the paste thing ? to past emy code into ?
07:11:45 <mauke> yes
07:12:11 <Astro> :t Data.ByteString.Lazy.pack <$> (OpenSSL.Digest.ByteString.Lazy.digest OpenSSL.Digest.SHA1)
07:12:12 <lambdabot> Couldn't find qualified module.
07:12:16 <ski> enter the URL in your browser of choice, paste the relevant code you want help on, possibly fill in your nick and a title, and press the paste button
07:12:26 <Astro> :t Data.ByteString.Lazy.pack `Control.Monad.liftM` (OpenSSL.Digest.ByteString.Lazy.digest OpenSSL.Digest.SHA1)
07:12:27 <lambdabot> Couldn't find qualified module.
07:12:47 <mauke> @where+ shuffle http://okmij.org/ftp/Haskell/perfect-shuffle.txt
07:12:48 <lambdabot> Done.
07:13:02 <BBanny> what is the URL for the paste site ?
07:13:17 <ski> Astro : possibly `OpenSSL' is not installed at lambdabot ?
07:13:22 <ski> @paste
07:13:22 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
07:13:25 <ski> BBanny : ^
07:13:30 <BBanny> thankyou
07:14:14 <mreh> what on earth is "<<loop>>"
07:14:15 <BBanny> and thankyou for the presfect sort algorithm. I had found that before and tried worknig on it, but i am required to write using different types, and coudlnt modify the algoritms to fi t with my specifications
07:14:18 <ski> (BBanny : sorry, you first need to follow the "new" link)
07:14:23 <mauke> mreh: an infinite loop
07:14:53 <mreh> mauke: how does it detect that?
07:15:01 <ski> mauke : the run-time system managed to solve the halting problem for you in this case
07:15:05 <mauke> black magic
07:15:13 <mreh> graphs?
07:15:33 <Astro> ski: hrm, obvious :)
07:15:33 <mauke> mreh: while it evaluates a thunk, it replaces the code pointer with that exception
07:15:34 <BBanny> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8784#a8784
07:15:38 <mreh> I am using unsafePerformIO, I am messing with powers that I don't understand
07:15:48 <mreh> well, Debug.Trace.trace
07:15:50 <mauke> mreh: so if it has to evaluate the same value inside itself, it will die
07:16:01 <BBanny> i decided to use a slower less efficient shuffle method since i coudlnt do the more complicated one...
07:16:14 <BBanny> but it is unfinised sicne i coudlnt get a random gen to work
07:17:44 <BBanny> also my style isnt very good, i use a lot of unecessary brackets i think, but thats just so i can see the coede mroe clearly,..used to writing in differnt languages
07:18:27 <mauke> [Card r s]!!n makes no sense
07:18:47 <BBanny> it is also suggested that i use Int -> [a] -> [a] to be more flexible
07:18:54 <mauke> what is the Int for?
07:19:02 <BBanny> int is a random number seed
07:19:08 <mauke> I see
07:19:09 <ski> BBanny : hm, were you here the other day with (a previous version) of this code ?
07:19:26 <mauke> BBanny: do you know what [Card r s] means?
07:19:42 <BBanny> i wasnt no...but my friend gave me this link, who was presuemable here with a similar problem
07:19:45 <ski> BBanny : btw, in `display' you don't need the brackets around the calls to `show'
07:19:45 <BBanny> on the same assignment
07:19:55 <ski> ok
07:20:43 <BBanny> [Card r s] was jsut an alteration i made today, it probly is wrong, but it got rid of some errors. I changed my code from [a] to [Card r s], since [Card] didnt work
07:20:52 <BBanny> said there werent enough arguments
07:21:01 <mauke> BBanny: do you know what [Card r s] means?
07:21:07 <mreh> could you see an obvious reason why this might cause a loop?: route (gi,oos) sfs = trace (show . map fst . IL.assocs $ oos) (IL.mapWithKey routeAux $ sfs)
07:21:34 <ski> BBanny : it might be helpful if you, at least temporary change `data Card = Card Rank Suit
07:21:44 <ski> ' into `data Card = MkCard Rank Suit'
07:21:44 <BBanny> how do you mean ? its a list of cards, conprised of a rank a suit ?
07:22:08 <mauke> BBanny: no, it's a list of one element, which is a Card with a rank and a suit
07:22:16 <mauke> BBanny: the critical part being "one element"
07:22:24 <ski> that way you hopefully will have lesser problems confusing the type constructor `Card' from the data constructor (was `Card', but renamed to) `MkCard'
07:22:26 <Luke> ezyang: you around?
07:23:06 <BBanny> ah ok thankyou i see
07:23:34 <BBanny> the input to shuffle  will be tested on the output from 'pack'
07:24:43 <ski> BBanny : will you try ?
07:25:19 <BBanny> try changing to MkCard ?
07:25:37 <ski> yes
07:25:50 <BBanny> i ahve done,..but i have also changed to the prefered version from my specification. Here is how it should ideally look
07:25:57 <BBanny> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8785#a8785
07:26:05 <BBanny> ...this is in terms of the arguments passed to each function
07:26:19 <ski> (since when you said "I changed my code from [a] to [Card r s], since [Card] didnt work", that suggests you were confusing the *data* constructor `Card' with the *type* constructor `Card' (which were named the same))
07:26:39 <mauke> BBanny: [a] is still a single-element list
07:26:53 <mauke> well, depends
07:27:01 <BBanny> how do i talk @ certian people ?
07:27:03 <ski> BBanny : next time, annotate the existing paste with updates, by clicking on "modify" (or "add revision")
07:27:08 <mauke> BBanny: by using their name?
07:27:30 <ski> BBanny : just write their name like "ski : ah, i see"
07:27:30 <BBanny> and yes i was confusing the type and contrsuctor.
07:27:36 <BBanny> oh ok :)
07:27:50 <BBanny> thnaks
07:27:55 <mauke> BBanny: or the first letters of their name and hit <Tab>
07:28:10 <mauke> mau<Tab> -> mauke
07:28:12 <ski> (it is also easy to confuse the singleton list *expression*/*pattern* `[a]' with the list type `[a]')
07:29:19 <BBanny> ski: ah i see. I was also getting a lot of non exhaustive patterns when compiling the code as it stands now, and running shuffle or extract
07:29:42 <mauke> yes, because shuffle/extract are only defined for empty or one-element lists
07:30:54 <BBanny> how would i define a multi element list in this way?
07:31:20 <mauke> shuffle n x = ...  -- x is some list here
07:31:41 <mauke> shuffle n (x : xs) = ...  -- x is the first element, xs is the remaining list
07:31:47 <mauke> or something like that
07:31:53 <BBanny> a:rest ?
07:32:53 <BBanny> that is what i have been suing in previous assignments, to create loops etc
07:36:28 <ski> yes, match on `[]' in one equation, and on `a:rest' in another
07:36:51 <ski> (whether you call it `rest' or `as' doesn't matter to the implementation, only to the human reader)
07:37:11 <MisterN> it must be x and xs!
07:37:54 <BBanny> ski: jsut done that, and uploaded a revion. but get lots of errors about not being able to match inferred types.
07:38:14 <BBanny> These are probly obvious simple errors to fix, but not having much expereince in haskell, i jsut look at them and have no idea where to start fixing
07:38:21 <mauke> BBanny: you added [ ]
07:38:22 <mauke> why?
07:38:41 <BBanny> at the start on the line ?
07:38:44 <BBanny> of*
07:38:51 <BBanny> in my extract ?
07:38:59 <mauke> [a:rest]
07:39:19 <BBanny> oh, do i not need them?
07:39:41 <ski> MisterN : as i said, it matters only to the human reader. (or are you claiming to be non-human ?)
07:39:44 <mauke> <mauke> shuffle n (x : xs) = ...  -- x is the first element, xs is the remaining list
07:39:48 <mauke> I feel ignored
07:39:49 <opqdonut> [a:rest] is a pattern that matches a one-element list
07:39:55 <opqdonut> with the one element being a list
07:40:01 <opqdonut> of which the first element is bound to a
07:40:06 * Phyx- <3 #haskell
07:40:08 <fax> hi mauke
07:40:22 <MisterN> ski: i was trying to be unhelpful. can't resist that urge sometimes :P
07:40:31 <Phyx-> #haskell = helps you solve problems, #c = talk about microsoft and/or pokemon
07:40:42 <BBanny> mauke: sorry im not ignoring you :)
07:40:46 <mreh> newtype derives an entirely new type correct?
07:40:54 <mreh> not just a synonym
07:41:10 <opqdonut> yes
07:41:15 <mreh> interesting
07:41:20 <mreh> useful too
07:41:24 <opqdonut> indeed.
07:43:23 <BBanny> thanks for your help on shuffle, i think i am well equipped to continue working on it later today
07:43:36 <BBanny> but could i please ask some advice on the deal module i have to write
07:46:24 <BBanny> deal 3 [1,2,3,4,5,6,7] would return [[1,4,7][2,5][3,6]]...which incorporated into my code should take the pack of cards and deal them into a number of hands
07:46:46 <sm> Feuerbach: Commands/Chart.hs has bitrotted in some strange way.. I can't find a version of Chart it builds with
07:47:26 <sm> ack, ignore me
07:47:39 <sm> ask the question in a public place ! never fails!
07:48:03 <mauke> > splitAt 2 [1,2,3,4,5,6,7]
07:48:04 <lambdabot>   ([1,2],[3,4,5,6,7])
07:48:52 <mauke> :t unfoldr
07:48:53 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:49:08 <mreh> has anyone ever had trouble with trace causing a <<loop>> before?
07:49:20 <mauke> > takeWhile (not . null) $ unfoldr (Just . splitAt 3) [1 .. 7]
07:49:21 <lambdabot>   [[1,2,3],[4,5,6],[7]]
07:49:35 <morts> BBanny: would that be the flop and individual hands?
07:49:44 <mauke> > transpose . takeWhile (not . null) . unfoldr (Just . splitAt 3) $ [1 .. 7]
07:49:45 <lambdabot>   [[1,4,7],[2,5],[3,6]]
07:50:11 <BBanny> morts: that was jsut an example using a list of 7. My assignment will take a whole deck of 52 cards, and deal them into 'n' hands until all cards aRE DEALT
07:50:18 <idnar> ooh, a real use of unfoldr
07:50:36 <ski> mauke : .. i just wrote the same code (modulo brackets instead of `$')
07:50:58 <ski> well, actually, not quite the same
07:51:00 <mauke> > transpose . unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 3 xs) $ [1 .. 7]
07:51:01 <ski> > (transpose . unfoldr (liftM2 (>>) (guard . not . null) (Just . splitAt 3))) [1,2,3,4,5,6,7]
07:51:01 <lambdabot>   [[1,4,7],[2,5],[3,6]]
07:51:02 <lambdabot>   [[1,4,7],[2,5],[3,6]]
07:51:51 <mauke> heh, nice
07:51:55 <BBanny> hmmmm intersting,.although none of those functions i have met before haha
07:52:24 <mauke> is there a way to involve a ReaderT or something?
07:52:31 <idnar> hahaha
07:52:51 <ski> why `ReaderT' rather than `StateT' ?
07:52:56 <sm> what's a good way to get a package which provides just an executable to appear in ghc-pkg list ?
07:53:06 <mauke> hmm
07:53:37 <mauke> ski: because liftM2 (>>) is Reader
07:53:41 <Zao> ski: No need for modification?
07:53:45 <sm> or for that matter, in cabal list --installed ?
07:54:28 <fax> what color is a functor?
07:54:34 <dino-> unfoldr!
07:54:39 <dino-> > (\sep -> takeWhile (not . null) . Data.List.unfoldr (Just . span (/= sep) . dropWhile (== sep))) '|' "foo|bar|baz"
07:54:39 <BBanny> would that work for my deal code then ?
07:54:40 <BBanny> transpose . unfoldr (liftM2 (>>) (guard . not . null) (Just . splitAt n))) [a:rest]
07:54:40 <lambdabot>   ["foo","bar","baz"]
07:54:52 <mauke> BBanny: you're still using [a:rest]
07:54:57 <BBanny> oh yeah
07:54:59 <mauke> which is still a single-element list
07:55:01 <BBanny> without the [ ] :p[
07:55:17 <BBanny> transpose . takeWhile (not . null) . unfoldr (Just . splitAt n) $ a:rest
07:55:20 <mauke> BBanny: if you don't use a and rest separately, why split them up in the first place?
07:55:40 <sm> answer: add an empty "library" directive to the .cabal
07:55:51 * hackagebot hashed-storage 0.4.9 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.4.9 (PetrRockai)
07:55:52 <BBanny> ooooooh, sorry i understand now...the problem with [a] was that it was a sinhgle element list,..i could ahve jsut put 'a'
07:55:58 <BBanny> sorry, really overlooked that
07:56:11 <dcoutts_> sm: I'm not sure that qualifies as a good solution
07:56:33 <sm> hi dcoutts_ .. is it a bug I'm seeing ?
07:56:42 <dcoutts_> sm: no, binaries are never registered
07:56:59 <ski> @type iterateSR
07:56:59 <ski> @type iterateSMR
07:57:00 <lambdabot> forall sr a. State sr a -> Reader sr [a]
07:57:01 <lambdabot> forall sr a. StateT sr Maybe a -> Reader sr [a]
07:57:12 <sm> I'd expect cabal list --installed to list packages I've installed though
07:57:20 <ski> fax : the same as an object ?
07:57:28 <dcoutts_> sm: eg. you can't expect a distro package to register the Haskell binaries specially
07:58:01 <fax> ski, why? :S
07:58:06 <fax> I thought bojects and functors are different
07:58:33 <ski> > transpose (iterateSMR (StateT (liftM2 (>>) (guard . not . null) (Just . splitAt 3))) `runReader` [1,2,3,4,5,6,7])
07:58:34 <lambdabot>   [[1,4,7],[2,5],[3,6]]
07:58:37 <fax> hm althoug A being the same color as FA makes sense
07:58:55 <dcoutts_> sm: question is, is it better to be inconsistent between progs installed via cabal and via your native ditro, or is it better to be inconsistent between libs and progs.
07:59:15 <ski> fax : well, points in an object, and morphisms are on the same level, in one sense; and objects and functors on the next level, in the same sense
08:00:10 <sm> I expect you've thought this through, but I don't quite follow the above.. would you agree the list --installed thing is  surprising and needs something to be done ?
08:00:27 <ski> (fax : semantically, you can think of points as morphisms from some stage of definition object, such as `1'; likewise you can think of objects as functors from the stage of definition category, such as `1' -- though syntactically, there's a difference in each case, though)
08:01:00 <dcoutts_> sm: it reports progs as [ Unknown ], which is accurate
08:01:06 <BBanny> i have added the code suggested above int o my code and added a revision
08:01:07 <BBanny> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8785#a8790
08:01:17 <benmachine> I reckon it'd be nice to track binaries separately
08:01:20 <sm> cabal list --installed does not list my executable-providing package at all
08:01:22 <BBanny> do i need to import anything to use transpose etc
08:01:33 <mauke> @index transpose
08:01:33 <lambdabot> Data.List
08:01:35 <dcoutts_> sm: oh yes, --installed
08:01:48 <dcoutts_> sm: if you did cabal list prog then it will report it as unknown
08:02:01 <BBanny> import Data.List ? that all
08:02:42 <sm> in fact cabal list hledger shows the 0.7 version, which did contain a lib. This is pretty confusing for users, I expect
08:03:02 <BBanny> what imports do i need to liftM2, and guard ?
08:03:07 <mauke> @index liftM2
08:03:08 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:03:13 <mauke> @index guard
08:03:13 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:03:16 <sm> I think cabal list should list packages on hackage whether or not they provide libraries
08:03:26 <dcoutts_> sm: it does
08:03:30 <BBanny> mauke: thnaks, but i have never come across the @index thing befofe,. what is that ?
08:03:33 <sm> no, it doesn't
08:03:39 <BBanny> before*
08:03:41 <mauke> BBanny: a lambdabot command
08:03:59 <sm> ok, I'm sorry. I must be wrong
08:04:00 <dcoutts_> sm: it does if you don't use --installed
08:04:07 <BBanny> :S feel stupid, but i dont know what that is
08:04:29 <sm> I haven't pushed this to hackage, so of course. I'll play with this some more
08:05:07 <sm> thanks dcoutts
08:05:35 <lambdabot> BBanny: I'm right here
08:05:48 <ski> @type Reader . unfoldr . runStateT
08:05:49 <lambdabot> forall r a. StateT r Maybe a -> Reader r [a]
08:06:21 <sm> dcoutts_: but wait. I cabal installed from the local source dir. SHouldn't cabal list --installed list that, regardless of whether it's on hackage ?
08:07:01 <dcoutts_> sm: only libraries are registered with ghc-pkg
08:07:09 <dcoutts_> sm: we do not know if programs are installed or not
08:07:17 <BBanny> haha ok im easily confuseeddd. What exactly do i have to type and where do i have to type the imports?
08:07:46 <sm> dcoutts_: you are also saying, we do not know what was cabal installed
08:07:55 <dcoutts_> sm: yes
08:08:33 <sm> ok. It's confusing. :)
08:08:44 <dcoutts_> sm: we know what libraries are registered (either manually, via cabal or via your native distro package manager)
08:10:02 <shapr> Good morning #haskell!
08:10:06 <sm> thanks for the help dcoutts, afk a little
08:10:14 <ski> good afternoon, shapr !
08:10:20 <shapr> hej ski!
08:10:41 <shapr> What sort of fun stuff are you working on?
08:11:23 * ski is currently trying to ponder Escardo's strange search of infinite types
08:11:43 <ski> s/of/inside/
08:15:56 <byorgey> good morning shapr!
08:16:13 <shapr> gooood morning byorgey! How's philly?
08:16:26 <shapr> ski: What's that?
08:16:27 <byorgey> beautiful and sunny!
08:16:52 <byorgey> shapr: want to come to Hac phi 2 in May?
08:17:41 <shapr> byorgey: I'd love to, but I'm hoping to take more classes.
08:17:57 <shapr> I'd like to take several classes this summer.
08:18:08 <ski> shapr : <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/> <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
08:18:34 <byorgey> shapr: gotcha.
08:19:29 <BBanny> ok thnask for your help everyone :) got to go now
08:19:30 <BBanny> bye
08:19:57 <Luke> byorgey: i've had your typeclassopedia on my kindle to read for some time and haven't gotten around to it =) how long did that take you to write?
08:19:57 <ski> shapr : e.g., one can use that to check whether a function `Stream a -> Bool' (where `data Stream a = Cons a (Stream a)') is a constant function or not, as well as making a (terminating) `Eq' instance for that type
08:19:59 <shapr> I'm having a blast doing the college thing, I even introduced a php programmer to Haskell last night.
08:20:28 <shapr> ski: Sounds crazy.
08:20:52 <ski> indeed
08:29:57 <ski> shapr : there's also "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> linking to the paper "Synthetic topology of data types and classical spaces" by Martín Escardó, which is related
08:33:07 <choffstein> Okay, stupid beginner question time!  In my main function, I am calling a function 'f' that returns an RVar Double (where RVar is a Random Variable Monad from random-fu).  I want to print the underlying double.  What I tried was f >>= print, but since main is expecting an IO return type, I am getting an "Couldn't match expected type `IO a' against inferred type `RVar Double'" error.  Any thoughts?
08:33:32 <Kagami`> liftIO ?
08:33:45 <benmachine> what you need to do depends on the RVar monad
08:34:04 <benmachine> probably an RVar Double doesn't represent exactly one double
08:34:15 <ski> either you need to "run" the `RVar' monad somehow .. or you need to `liftIO' your `IO'-action into the monad (if possible)
08:35:00 <benmachine> seems RVar isn't MonadIO, so liftIO won't work
08:35:05 <ski> (s/`RVar' monad/`RVar' monad action/)
08:35:08 <benmachine> you need to use runRVar
08:35:21 <benmachine> seems you need a RandomSource
08:36:28 <choffstein> Herm...
08:36:39 <choffstein> I think I am doing something very wrong
08:36:56 <byorgey> Luke: I probably worked on it on and off for about a month or so, but probably 60% of it was written in one massive all-day writing session a few days before the deadline ;)
08:40:33 <Luke> byorgey: haha nice =) I can't wait to read it
08:42:18 <byorgey> Luke: I'm actually planning to put out a second edition soon (within the next couple months)
08:42:42 <byorgey> which you may or may not want to wait for (maybe not, since there's always the possibility I won't actually get around to it =)
08:43:17 <Luke> byorgey: haha I'll just read it ASAP. Right now I've been studying for the series 7 (stock broker version of the bar exam) so I haven't had time for free-reading
08:43:40 <byorgey> Luke: I see, good luck with that!
08:43:46 <Luke> thanks thanks.
08:43:53 <Luke> you were saynig something about another hacphi in may?
08:43:59 <Luke> that'd be awesome!
08:44:09 <byorgey> yep, either the weekend of the 15th or the 22nd
08:44:35 <byorgey> would you actually come again?  or you're just saying it would be awesome in general?
08:44:43 <Luke> i would definitely come again
08:44:50 <byorgey> sweet!
08:44:50 <Luke> reece too probably
08:44:57 <Luke> perhaps a few more guys from my company as well
08:45:16 <Luke> those weeks both work for me btw
08:45:22 <byorgey> that would be fantastic.  do you have a strong preference for one or the other... ok =)
08:45:29 <Luke> both are OK =)
08:46:29 <choffstein> How would I go about printing an intermediate value?  I am getting an 'out of bounds' error indexing on a matrix class and I want to check the values I am indexing...
08:46:37 <Luke> afk
08:46:49 <mauke> Debug.Trace
08:47:43 <choffstein> thanks
08:49:10 <Luke> ezyang: PM me when you come online
08:50:52 <Luke> byorgey: let me know if you need help organizing anything for hacphi 2 btw.
08:51:03 <Luke> or if you just need someone to do bitch work =)
08:53:26 <mreh> they do haskell in philly?
08:56:14 * hackagebot salvia 1.0.0 - Modular web application framework.  http://hackage.haskell.org/package/salvia-1.0.0 (SebastiaanVisser)
08:56:38 <byorgey> Luke: ok, thanks =)
08:56:49 <byorgey> mreh: heck yes
08:58:14 * hackagebot salvia-sessions 1.0.0 - Session support for the Salvia webserver.  http://hackage.haskell.org/package/salvia-sessions-1.0.0 (SebastiaanVisser)
08:58:16 * hackagebot salvia-extras 1.0.0 - Collection of non-fundamental handlers for the Salvia web server.  http://hackage.haskell.org/package/salvia-extras-1.0.0 (SebastiaanVisser)
08:58:18 * hackagebot salvia-websocket 1.0.0 - Websocket implementation for the Salvia Webserver.  http://hackage.haskell.org/package/salvia-websocket-1.0.0 (SebastiaanVisser)
09:00:02 <benmachine> highlighting-kate is silly
09:02:16 * hackagebot salvia-demo 1.0.0 - Demo Salvia servers.  http://hackage.haskell.org/package/salvia-demo-1.0.0 (SebastiaanVisser)
09:14:04 * gwern thinks today is a good day to mess with gmailfs
09:14:24 <gwern> benmachine: and what's silly about highlighting-kate? I dno't see any other haskell package offering >50 syntax highlighting modes...
09:24:42 <maurer_> If I have a function of n arguments, and a list of n arguments, is there an easy way to apply the function with each element in the list as an argument?
09:25:33 <roconnor> maurer_: no easy way
09:25:40 <maurer_> roconnor: OK, thanks.
09:25:40 <byorgey> maurer_: not really, although for each n you can make an appropriate adapter function
09:25:56 <byorgey> e.g.  apply3 :: (a -> a -> a -> b) -> [a] -> b
09:26:01 <roconnor> it is unusal to have a lis t with exactly n elements
09:26:34 <maurer_> Yeah. I was trying to take a shortcut by applying the constructor for a type directly to the output of a select query to build some local data structures.
09:26:51 <maurer_> Looks like I'm going to need a middling convert function. Thanks.
09:30:38 <pippijn> can I tell cabal to look in other places for its sources?
09:30:45 <pippijn> so I can scatter them around?
09:30:58 <pippijn> I have some sources in . and some in ../hsbindings
09:30:59 <Darkone> GHCi is useful :D
09:31:13 <Darkone> I mean, outside of testing things: Like a calculator.
09:31:38 <pippijn> I use ghci as a calculator quite often ;)
09:32:15 <Darkone> Yea. Was thinking of trying something, and it worked perfectly after an initial hiccup :P
09:32:38 <Darkone> zipWith (^) [2,2..] [1..32]
09:33:11 <Darkone> At first, I didn't have the ,2, and forgot that it would increment it without it.
09:33:15 <roconnor> ``Let us then make the even more idealised assumption that we can also store real numbers with unlimited precision
09:33:21 <roconnor> that's pretty darn idealized
09:33:24 <siracusa> maurer_: Have a look at Data.Dynamic, maybe dynApply is what you what.
09:33:29 <Darkone> I imagine there's ways to make that simpler, right?
09:33:40 <Darkone> Like using $^ instead of (^)
09:34:06 <Darkone> I think.
09:34:40 <Darkone> Nope xD
09:34:45 <roconnor> ``we will not have direct access to the entire decimal expansion of {\pi}.
09:34:47 <maurer_> siracusa: That might be it, but I've already written the silly conversion function. I'll look at that next time I need something like this.
09:34:49 <roconnor> oh, that's not so bad then
09:38:51 <roconnor> Data.Dynamic is never the solution.
09:39:59 <elly> Data.Dynamic can help you instantiate Greenspun's Tenth Rule!
09:40:01 <dcoutts_> pippijn: the assumption is that packages are self-contained so source dirs outside of the source tree are not generally supported, though it might work locally. you certainly cannot distribute such packages.
09:40:23 <roconnor> elly: who is Greenspun and what is his tenth rule?
09:40:23 <pippijn> dcoutts_: it's being built as part of a larger C project
09:40:51 <elly> roconnor: http://en.wikipedia.org/wiki/Greenspun's_Tenth_Rule
09:41:15 <Darkone> Ooh, map (2 ^) [1..32] is simpler. Yaaay learning :P
09:41:31 <choffstein> does anyone know what may be causing a program that ghci has no problem interpretting, but ghc can't compile due to linking errors?
09:43:00 <dcoutts_> pippijn: if you've got other Haskell code in ../blah, then perhaps that indicates it should be a separate Haskell lib
09:43:15 <pippijn> no
09:43:16 <dcoutts_> pippijn: rather than using hs-source-dirs: ../blah
09:43:31 <pippijn> dcoutts_: it's in ../blah because I am doing an out-of-tree build
09:43:37 <pippijn> and that generates some hs sources
09:43:48 <pippijn> in addition to the hs sources in $srcdir/hsbindings
09:43:56 <pippijn> where $srcdir happens to be ..
09:44:05 <pippijn> could be anything, though
09:44:07 <pippijn> including .
09:44:26 <roconnor> elly: :)
09:44:32 <dcoutts_> pippijn: I don't see how an out of tree build is relevant
09:44:47 <roconnor> elly: Data U = Foo (U -> U) is better though.
09:44:51 <dcoutts_> pippijn: you can put the intermediate .o files (the dist/ tree) anywhere
09:44:51 <roconnor> actually
09:45:04 <pippijn> dcoutts_: yes, but I *generate* hs sources
09:45:10 <dcoutts_> pippijn: that's fine
09:45:11 <pippijn> dcoutts_: and those generated sources end up in $builddir
09:45:22 <pippijn> which may be different from $srcdir
09:45:36 <dcoutts_> pippijn: cabal generates files too and puts them in the dist/build dir
09:45:50 <dcoutts_> pippijn: so that we never write to the original source tree
09:45:55 <pippijn> exactly
09:45:59 <roconnor> Data Lisp a = Atom a | Cons (Lisp a) (Lisp a) | Function (Lisp a -> Lisp a)
09:46:25 <pippijn> but those generated hs files are generated before I even call cabal
09:46:28 <roconnor> so data.dynamic still loses
09:46:37 <elly> roconnor: the Function type is superfluous, given a sufficiently cool eval :P
09:46:54 <dcoutts_> pippijn: and they get generated to a location outside of the source tree?
09:47:05 <pippijn> yes
09:47:14 <dcoutts_> pippijn: so that's not very conventional
09:47:25 <pippijn> so that I never write to the original source tree
09:47:54 <dcoutts_> pippijn: as I say, it's probably best to put them in the same place as Cabal puts generated files
09:48:09 <pippijn> ah
09:48:14 <pippijn> yes
09:48:28 * dcoutts_ back in a bit
09:48:55 <pippijn> dcoutts_: I do that
09:49:05 <pippijn> but the original source tree is elsewhere
09:49:16 <pippijn> so I have to reference that
09:56:59 <ski> elly : "sufficiently cool" ?
09:57:38 <elly> ski: yes, fsvo cool
09:58:17 <ski> maybe you could elaborate on what you had in mind ?
10:03:07 <otulp> Does anyone know how I should go about fully evaluating a vector (all elements)? I have tried writing an instance of NFData a => NFData (Vector a), in order to to use deepseq, but seem to have failed miserably.
10:04:17 <roconnor> elly: I think it is necessary.
10:04:56 <temoto> Does it makes sense to say that '+' is not associative in all algebras?
10:05:17 <roconnor> temoto: depends on what you mean by algebra
10:05:50 <temoto> roconnor, like set of operations defined on types. Is that algebra?
10:05:57 <roconnor> yes
10:06:12 <roconnor> though often it is restricted to one type.
10:06:33 <roconnor> temoto: in that case your statment is correct
10:06:38 <temoto> So does it make sense to say that '+' is only associative in numeric and string algebras, but not, i.e. in list algebra?
10:06:42 <roconnor> I mean, in the case you said
10:07:03 <roconnor> temoto: what is a list algebra?
10:07:17 <temoto> roconnor, well, ++ for one operation :)
10:07:24 <roconnor> ++ is associative
10:08:05 <ski> `+' is associatives in algebras which have as an axiom that the `+' should be associative (or other axioms implying that)
10:08:05 <temoto> oh indeed
10:08:34 <temoto> roconnor, well stack algebra shouldn't be associative
10:08:50 <ski> what is a stack algebra ?
10:08:50 <temoto> + i mean
10:09:00 <temoto> algebra on stacks
10:09:07 <ski> .. which is ?
10:09:27 <temoto> where stack is a FIFO uh.. data structure
10:09:46 <ski> how many carriers ? what operations ? which laws ?
10:10:49 <temoto> ski, you must be kidding. carriers and laws.. i just said 'algebra' with sense for the first time in my life.
10:11:44 <elly> roconnor: disagree; functions are themselves lists: (lambda (x) (+ x 1)) is itself (cons lambda (cons (cons x null) (cons (cons + (cons x (cons 1 null))) null)), modulo parens matching
10:11:48 <temoto> Okay, nevertheless, the main thing is clear.
10:11:51 <temoto> elly!
10:11:57 <elly> temoto?
10:12:02 <elly> do I know you?
10:12:27 <roconnor> elly: ah okay
10:12:43 <temoto> elly was you teaching students to write a buffer for keyboard year and half ago?
10:12:59 <ski> temoto : you said "like set of operations defined on types. Is that algebra?", so i assumed you had at least some familiarity with some algebras, like monoids, groups, rings, fields, vector spaces, (directed multi-)graphs
10:13:11 <elly> temoto: ...yes, I am a teaching assistant for our OS class, and I was a year and a half ago, and they did have to write a keyboard driver
10:13:19 <elly> why do you ask? I am now intensely curious
10:13:20 <temoto> ski, no, just numbers. :)
10:13:56 <temoto> elly, well you was helping me with haskell noob questions back then. And i haven't seen you on this channel for all this time.
10:14:06 <ski> elly : code which evaluates to functions can be represented as lists, yes
10:14:11 <elly> temoto: o_O woah
10:14:42 <elly> ski: right, which means the Function constructor is unnecessary
10:14:47 <elly> agh, I need food, ->
10:15:22 <ski> elly : but what if you want to represent the result values of evaluation in the *same* datatype .. don't you need it then ?
10:16:26 <temoto> roconnor, ski thanks for sorting this algebra thing out.
10:16:30 <pippijn> [  2 of 651]
10:16:33 <pippijn> \o/
10:17:03 <ski> elly : (hm, i suppose you could do it like a small-step operational semantics; i.e. say `(cons nil nil)' evaluates to `(cons nil nil)' rather than `(nil . nil)')
10:17:13 <dankna> pippijn: what on Earth are you compiling?
10:17:29 <pippijn> haskell bindings for a C++ library ;)
10:17:33 <dankna> ahhhh haha
10:19:35 <maltem> I'm notoriously too blind for this type error, anyone? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24223
10:20:33 <Utkarsh> hi everyone. I'm new to haskell. Could anyone suggest improvements to this? http://pastebin.com/G8Z4qDYj (sum of all fibonacci numbers below 4 million)
10:21:17 <aavogt> maltem: but what's the error?
10:21:41 <maltem> aavogt, forgot to paste that, but nvm I found a fix now
10:22:04 <maltem> a type sig for sendInfo did it, god knows why
10:22:41 <temoto> Utkarsh, hello. You are calculating fib x twice in your list comprehension.
10:23:17 <maltem> Utkarsh, looks good to me. It obviously does the right thing ;)
10:23:29 <maltem> Of course, the algorithm you chose is awfully slow
10:23:42 <temoto> But is perfectly readable.
10:23:44 <Utkarsh> well yeah, it's taking very long to reach fib 50
10:24:22 <monochrom> use a better algorithm
10:24:43 <maltem> ah ok we should fix what temoto said: you can have let's within a list comprehension
10:25:59 <aavogt> > fix ((1:) . scanl (+) 1) !! 49
10:26:00 <lambdabot>   12586269025
10:26:13 <temoto> Utkarsh, you could try    fibs = map fib [1..50]   and   e2 = sum $ filter (\n -> n < 4*1000*1000) fibs
10:26:41 <temoto> Utkarsh, this doesn't make overall algorithm better, but at least you're calculating fib x once.
10:27:17 <temoto> oh that's   filter (<4000000) fibs    even
10:27:21 <monochrom> > let {f 0 = (0,1); f n = (y,x+y) where (x,y)=f(n-1)} in f 50
10:27:23 <lambdabot>   (12586269025,20365011074)
10:29:14 <temoto> Utkarsh, as you can see, efficient algorithms are no longer as readable as yours :)
10:29:54 <monochrom> This is only because I omit the readable derivation from readable specification to efficient algorithm.
10:30:09 <Utkarsh> temoto: I read this kind of thing for calculating factorials I think :)
10:30:20 <pippijn> dankna: I think compiling the hs bindings takes longer than building the c++ lib itself ;(
10:30:34 <monochrom> For example a short comment "f n = (fib n, fib (n+1))" makes a world of difference.
10:31:37 <bremner_> doesn't every course in FP in the universe use that definition as an example?
10:31:37 <dankna> pippijn: I wouldn't be at all surprised
10:31:41 <monochrom> Therefore I disbelieve in readable code. I believe in readable derivation.
10:32:33 <pippijn> dankna: C++ already takes long
10:33:04 <pippijn> each hs file is about 200 lines
10:33:12 * dankna nods
10:33:16 <dankna> well, it's the linking that's slow
10:33:17 <pippijn> foreign import + real wrapper
10:33:37 <pippijn> g++ is also not that fast at compiling
10:34:40 <pippijn> 3.2MB of haskell sources for the bindings
10:34:56 <pippijn> 70KLOC
10:35:01 <dankna> that's ginormous
10:35:02 <pippijn> luckily all generated
10:35:09 <dankna> it must be a very wordy binding
10:35:16 <pippijn> it has many many types
10:35:20 * dankna nods
10:35:25 <pippijn> each has several methods
10:36:22 <sm> will the latest version of the HP overwrite my installed ghc 6.10 setup on mac ?
10:37:02 <sm> I'm asking about both the installer version and/or the ports version
10:37:05 <dankna> sm:
10:37:16 <dankna> the installer version is what I have familiarity with; I haven't tried the ports version (which is newer)
10:37:24 <sm> hey there dankna
10:37:30 <dankna> the installer installs two .framework directories into /Library/Frameworks/
10:37:31 <dankna> heya sm :)
10:37:39 <dankna> GHC.Framework and (I think) HaskellPlatform.framework
10:38:15 <dankna> I don't know where the ports version installs.  I don't know why they elected to not do an installer version for this release, but I could hazard a guess based on having seen their source that it's because nobody remembered or documented how to make it :)
10:38:26 <pippijn> noooo!
10:38:27 <pippijn> oh
10:38:33 <pippijn> right, CLDouble is gone
10:38:52 <sm> I should clarify - my current setup is the previous mac HP, installer version. That one said it would overwrite the previous mac-installer-HP
10:38:55 <dankna> the installer also creates symlinks in /usr/bin/ to the binaries in the frameworks
10:39:03 <sm> I'll the give port a try
10:39:17 <dankna> I would think, however, that since .frameworks are versioned and they bumped to GHC 6.12
10:39:19 <sm> woah.. too early for drinkin
10:39:25 <dankna> whereas the previous release was 6.10
10:39:34 <dankna> that it wouldn't overwrite
10:39:50 <dankna> if you're worried that it will, you can just back up those two .frameworks beforehand by making copies of them in the Finder
10:40:25 <dankna> sm: how goes HLedger? :)  I did a new release of direct-plugins that is safer - it grovels the .hi files to make sure the value it's loading is a Dynamic
10:41:12 <sm> dankna: I saw, thanks! hledger going fine, I am working on splitting up the package. Or deciding whether to, and when
10:41:19 <dankna> welcome!
10:41:21 <dankna> cool cool
10:41:32 <sm> after the existing stuff is better packaged, I'll look again at how to support new plugins
10:41:39 <dankna> makes sense to me
10:41:57 <sm> I have identified a couple of different kinds of plugin, and different implementation approaches
10:42:03 <dankna> oh?  sounds interesting?
10:42:20 <dankna> I guess you mean plugins that provide commands versus plugins that provide functions, or whatever
10:43:06 <sm> exactly, that sort of thing.. new cli commands, new web ui features/themes, new import export formats etc.
10:43:11 <dankna> gotcha
10:43:33 <sm> they have different needs from the implementation, eg for new cli commands execing an executable is fine
10:43:55 <sm> linking the app at startup is still problematic, I'd like to avoid it
10:44:01 <sm> but all to be revisited
10:44:10 * dankna nods
10:44:33 <dankna> what exactly is the issue with the linking at startup?  is it slow?
10:44:44 <dankna> one thing you could do that would avoid the need for that
10:44:46 <dankna> would be something like
10:45:05 <ologNation> Is there a good channel for basic unix questions, like about how to use a makefile?
10:45:08 <dankna> have each plugin export something with the same interface, exactly as if you were going to link at startup
10:45:10 <Zao> ologNation: ##workingset
10:45:16 <pippijn> 22 minutes for the first attempt (after which it failed)
10:45:21 <ologNation> Zao,  Thank you.
10:45:22 <pippijn> and it was at about 50%
10:45:25 <dankna> pippijn: ouch
10:45:38 <ologNation> Also, does anyone know the name of the channel for more theoretical strains of haskell
10:45:39 <pippijn> dankna: no problem, I could resume it after fixing the error
10:45:45 <dankna> pippijn: ah good
10:46:00 <dankna> then have a module in your main executable that imports them all and exports a list of them
10:46:08 <zachk> ologNation: #haskell-in-depth
10:46:12 <pippijn> yes, I have that
10:46:25 <pippijn> it's called Cxx.Parser.Classes
10:46:29 <sm> yes it's slow - even a second is too much for a command-line tool that's supposed to be near-instant - and/or memory hungry - will chew up a bunch of ram and maybe cause swapping on a memory-limited vps where you're running hledger web
10:46:37 <dankna> pippijn: oh - was talking to sm hehe
10:46:41 <pippijn> oh okay
10:46:45 <ologNation> zachk, Thanks
10:46:54 <zachk> ologNation: your welcome :-D
10:46:55 <dankna> sm: then you only have to change it in two places to add or remove plugins, that module and the .cabal file
10:47:14 <dankna> sm: this would get you the benefits of static linking.  also the drawbacks of course :)
10:47:44 <dankna> sm: I take your point.  another approach would be to make the cli tool client/server as well, but since I take it the purpose of the cli tool is to be a fallback when the server isn't working, that might be a bad idea
10:47:44 <sm> dankna: that sounds good but I don't quite follow, are you saying it avoids the need for linking ?
10:48:06 <dankna> sm: well, it would be a way to have everything statically linked but still organized "as if" they were plugins
10:48:16 <dankna> sm: you wouldn't need direct-plugins or hs-plugins at all to do things that way
10:48:29 <dankna> sm: so the linking happens at compile-time instead of run-time
10:48:43 <sm> ah right.. that's in fact what I'm going with for the moment - gathering at least the "official" plugins into one kitchen-sink package (hledger)
10:48:47 <dankna> right, gotcha
10:49:01 <dankna> you can make them separate packages if you want, that doesn't really affect how this strategy would work
10:49:21 <dankna> my web framework FruitTart and its plugins are each separate Cabal packages
10:49:32 <dankna> but that's orthogonal to the question of when they're linked
10:49:42 <sm> ok, good. I plan to start with hledger-lib, hledger-cli and hledger packages, and I'll follow a strategy like you say and perhaps split out more packages later
10:49:47 <dankna> that's cool
10:50:11 <sm> I'm trying no to do it unless there's something driving it though. There's a cost! complexity etc.
10:50:21 <dankna> indeed there is
10:50:44 <dankna> people need to remember that code is "primarily for humans to read and only secondarily for computers to execute" (who said that?  well, whatever)
10:50:59 <nanashi> =)
10:51:03 <zachk> knuth?
10:51:19 <dankna> no, I don't think so...
10:52:03 <dankna> google not turning anything up, must have the wording wrong
10:55:16 <pippijn> [651 of 651]
10:56:07 <pippijn> 15:51.82 total
10:56:11 <pippijn> 16 + 22 minutes
10:56:19 <dankna> well, congrats
11:03:56 <Utkarsh> thanks temoto, monochrom and maltem. Finally got it :)
11:07:02 <cebewee_> hm, how can i get ghci to honour the -i flag?
11:07:33 <benmachine> cebewee: what do you want it to do
11:08:26 <Utkarsh> what's wrong in this? http://pastebin.com/kNjQML52
11:08:30 <Utkarsh> I'm getting ' Couldn't match expected type `[a]' against inferred type `Bool''
11:08:46 <cebewee> benmachine: I want to do 'ghci -i./src' and then 'import Data.Term' where Data.Term is in ./src
11:09:23 <benmachine> if you do ghci -isrc and import Data.Term it will look for src/Data/Term.hs I think
11:09:48 <cebewee> benmachine: does not work.
11:09:56 <benmachine> Utkarsh: first of all, palin x*y is the same as (palin x)*y
11:10:08 <cebewee> benmachine: what does however is 'ghci -isrc dummy.hs' where dummy.hs does 'import Data.Term'
11:10:18 <benmachine> Utkarsh: you need to use brackets, because function application has highest priority
11:10:43 <benmachine> cebewee: okay, do ghci -isrc and then do :l Data.Term
11:10:59 <cebewee> benmachine: ah, thanks!
11:11:02 <Utkarsh> benmachine:thanks for that. Error seems to be caused by something else I think ?
11:11:13 <benmachine> cebewee: I think import is for compiled modules
11:11:52 <benmachine> Utkarsh: a lot of problems like this can be made clearer by giving explicit type signatures to your functions
11:12:02 <benmachine> Utkarsh: what type does palin have?
11:12:16 <Utkarsh> boolean?
11:12:30 <Utkarsh> oh no. it takes numbers
11:14:08 <benmachine> right
11:15:00 <benmachine> the way you've used it in the list comprehension requires it to have a type palin :: (Num n) => n -> Bool (assuming you've added parentheses as appropriate)
11:16:13 <benmachine> but the way you've defined it, you've called reverse on the parameter, so the parameter has to be type [a]
11:16:16 <benmachine> :t reverse
11:16:17 <lambdabot> forall a. [a] -> [a]
11:16:44 <benmachine> so the definition's type has to be (Eq a) => [a] -> Bool
11:17:11 <benmachine> there's no way those types can be reconciled there is a Num instance for lists, which there isn't
11:17:16 <benmachine> hence, error
11:21:24 <Twey> :t all . (==)
11:21:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:26:39 <mreh> @src (->) fmap
11:26:39 <lambdabot> fmap = (.)
11:27:00 <aavogt> :k (->)
11:27:01 <lambdabot> ?? -> ? -> *
11:27:51 <mreh> @src (-> a) fmap
11:27:51 <lambdabot> Source not found. My pet ferret can type better than you!
11:34:53 <dankna> so Happy is throwing an error in pure code inside my parseError method
11:34:56 <dankna> how can I catch it?
11:35:07 <dankna> I already tried unsafePerformIO (do catch ...)
11:35:16 <dankna> er, it's not a method, but ykwim
11:36:56 <Cale> errors thrown from the middle of pure code can be tricky to catch
11:37:18 <Cale> Typically, you want to use Control.Exception.evaluate along with catch
11:37:21 <dankna> hmmm
11:37:23 <dankna> okay
11:37:33 <Cale> in order to try to ensure that the evaluation happens at the right time
11:37:39 <dankna> right
11:42:54 <mreh> :t arccos
11:42:55 <lambdabot> Not in scope: `arccos'
11:42:59 <dankna> that worked, thank you
11:43:15 <Twey> :t acos
11:43:16 <lambdabot> forall a. (Floating a) => a -> a
11:43:19 <mreh> thx
11:53:56 <mreh> what's the most common way to do polygon intersections with concave and even complex polygons
11:54:42 <mreh> concave is pretty easy if you segment the polygon into convex ones
11:54:51 <mreh> naively or otherwise
11:55:01 <dankna> mreh: funnily enough, I'm working on that for my real job stuff right now
11:55:15 <mreh> dankna: exciting
11:55:22 <mreh> making a haskell library :D
11:55:24 <mreh> ?
11:55:31 <dankna> no, it's Objective C actually
11:55:57 <dankna> anyway, the first step is finding all the line-line, line-vertex, and vertex-vertex intersections
11:56:16 <dankna> and subdividing both polygons such that the only remaining intersections are vertex-vertex
11:56:44 <fax> I'd probably triangulate
11:56:56 <dankna> then you classify each vertex as inside or outside the other polygon, and use that information to efficiently classify each line segment as inside, outside, or shared
11:56:56 <mreh> I'm confused as to what a line-vertex intersection is
11:57:09 <dankna> that's when the line segment passes directly through a vertex
11:57:25 <ddarius> mreh: Consider the triforce.
11:57:32 <mreh> what about when a polygon is inside another?
11:57:34 <dankna> ddarius: those words need to be spoken more
11:57:47 <dankna> mreh: then the subdivision step is trivial
11:58:21 <dankna> once you have everything classified, you simply construct a new polygon as a subset of the line segments and vertices of the two old ones - which subset depends on which set operation you're performing
11:58:29 <dankna> for intersection you include all the ones that are "inside" or "boundary"
11:59:00 <dankna> this is the broad outline of an algorithm.  I unfortunately can't give you a citation for details, because the paper I'm working from is for the 3D case.
11:59:04 <mreh> dankna: do you have a document explaining these?
11:59:13 <dankna> but I can give you /that/ citation, one moment
12:00:17 <pippijn> the hs bindings are 415MB
12:00:26 <dankna> pippijn, wow....
12:01:08 <pippijn> ghc -package doesn't link in the extra-libraries
12:01:22 <pippijn> stripped, the hs bindings are...
12:01:24 * pippijn strips
12:01:31 <pippijn> 159M
12:01:32 <dankna> "Constructive Solid Geometry for Polyhedral Objects", David H. Laidlaw and John F. Hughes, some ACM publication or other
12:01:37 <dankna> I got it from the ACM Digital Library
12:01:43 <lostman> which latex package should I use to make diagrams for category theory?
12:02:12 <dankna> (on a related note, I really need to start getting organized about citations... use BibDesk or something...)
12:02:31 <mreh> Biblatex is good
12:02:38 <Cale> lostman: xy-pic or TikZ, depending on what sort of diagrams.
12:02:39 <dankna> oh?  will look into that
12:03:29 <lostman> Cale: simple commutativity diagrams; I want to write something about catamorphisms, anamorphisms, etc.
12:04:04 <lostman> on a related note, how can I get good banana brackets? (| |) looks a bit rubbish
12:04:33 <dankna> lostman, I supose you could use Unicode.... :)
12:05:02 <Cale> lostman: Probably xy-pic is fine then. You might even get away with using Paul Taylor's "diagrams" package
12:05:03 <dankna> ? and ? used as brackets would amuse me highly
12:05:37 <Cale> lostman: I think put a \! or two between the ( and the | to squish them together
12:05:40 <dankna> oh look!  there's even unicode symbols for
12:05:44 <Cale> (and then make the thing into a macro)
12:05:47 <dankna> ? and ?
12:05:58 <Cale> dankna: utf8-fail
12:06:06 <lostman> Cale: yeah, was thinking about something like that
12:06:13 <dankna> Cale: my xchat is definitely sending utf8; your font may not have the symbols
12:06:18 <voker57> ? Â¿
12:06:25 <Cale> No, those were definitely question marks.
12:06:29 <dankna> oh
12:06:31 <dankna> well drat
12:06:34 <lostman> dankna: unicode sounds good too, just how to find the codes for the symbols I'm looking for...
12:07:06 <dankna> well, let me look up the codepoints for you
12:07:07 <mreh> dankna: how do they do this all efficiently
12:07:12 <dankna> since I'm on a Mac I can type them no problem
12:07:24 <dankna> mreh: they explain their data structures in the paper
12:07:54 <ologNation> I'm always curious about what browsers good programmers use.
12:07:57 <ologNation> Does anyone here use vim?
12:08:12 <dankna> U+2985 and U+2986 are LEFT and RIGHT WHITE PARENTHESIS
12:08:19 <ologNation> Does anyone code haskell in an IDE?
12:08:19 <mreh> ologNation, I don't think it depends on how good the programmer is
12:08:26 <ologNation> mreh, Yeah?
12:08:48 <Cale> ologNation: What browsers? I use vim as my text editor. Firefox is my browser.
12:09:34 <mreh> dankna, do they cache the decompositions of models?
12:09:48 <mreh> I use gedit :)
12:10:22 <dankna> sorry, what do you mean by decompositions?
12:11:02 <dankna> I use Emacs, but I hate it.  I got used to vi (Elvis) for five years before switching and I still prefer that philosophy.
12:11:19 <dankna> But Emacs has too many killer features.  So as Emacs fans like to point out to me, this is actually a backhanded compliment to it.
12:11:26 <ologNation> dankna, why's you switch?
12:11:37 <silver> why do you care about browsers?
12:11:42 <dankna> Haha, actually I switched because my boyfriend at the time talked me into it.
12:12:03 <mreh> dankna: the complex/concave polygons need decomposing into convex ones
12:12:09 <ologNation> So it seems like it really is a toss up between Emacs and vim.
12:12:11 <mreh> dankna, are you a female?
12:12:17 <dankna> mreh: I am a male!
12:12:26 <ologNation> Like East and West coast Gangsta rap.
12:12:43 <ologNation> mreh, we're here.  we're queer.  Get used to it.
12:12:44 <dankna> mreh: no, the algorithm works on concave polys as well, I believe
12:12:59 <mreh> it's a false dichotomy, choose whatever you want
12:13:08 <dankna> at least I've been using it on them and haven't found a case where it doesn't
12:13:17 <mreh> I was almost suprised that we had a female haskeller
12:13:20 <dankna> hahaha
12:13:35 <dankna> my gender identity is actually somewhere in the middle if you really want to know, so you still could be :)
12:13:41 <ologNation> Yeah.  So it looks like things got really stable for programmers a few decades back and things were settled on these two awesome editors with two different philosophies.
12:13:56 <dankna> but I agree that it's a false dichotomy
12:14:06 <dankna> sexual preference is very much not black and white
12:14:11 <ologNation> gender or editors?
12:14:16 <dankna> er, both!
12:14:17 <mreh> haha
12:14:25 <ologNation> It's true!
12:14:26 <fax> gender vs editors is a false dichotomoy...
12:14:26 <ologNation> I want both!
12:14:31 <dankna> fax: hahaha
12:14:41 <ologNation> I love emacs and I feel like I'm finally getting the hang of it.
12:14:47 <ologNation> But I want to learn fim.
12:14:51 <ologNation> s/fim/vim/
12:15:00 <ologNation> It's intimidating.
12:15:05 <ologNation> It's like programming left-handed.
12:15:17 <silver> I use both hands :X
12:15:29 <dankna> I type with my right foot
12:15:34 <joga> that's because the right hand is used to alleviate drooling over the fabulousness of vim
12:15:34 <mreh> what cool features do you use the most often in vim and emacs?
12:15:36 <dankna> and I kick with my left hand
12:16:01 <ologNation> mreh, I love "recording kbd macros" in emacs.
12:16:01 <joga> I can type with my foot since I have a pedal there :)
12:16:10 <dankna> yeah, keyboard macros I use constantly
12:16:11 <ologNation> C-x ( to begin recoriding.
12:16:13 <dankna> joga: haha awesome
12:16:20 <Twey> I approve
12:16:23 <ologNation> s/C/M/
12:16:29 <ologNation> M-x ) to stop recording.
12:16:30 <mreh> ologNation, what do they do?
12:16:34 <dankna> it should be noted that vi also has them, but I don't believe it has a "record" mode, you have to type them as a command
12:16:36 <ologNation> Then C-x e to replay.
12:16:47 <ologNation> dankna, Interesting...
12:16:50 <ologNation> But of course it does.
12:16:53 <medfly> dankna, sexual identity is a dichotomy thing, IMO. there's "willing to publicly look like gender X" and "not willing to" :)
12:16:59 <joga> dankna: vim at least has recording
12:17:05 <dankna> medfly: that's fair :)
12:17:15 <yitz> ologNation: C-x-( works for me
12:17:18 <dankna> joga: oh, yeah, I suppose so
12:17:19 <ologNation> mreh, if you use emacs, you should try it.  I use it all the time.
12:17:32 <dankna> joga: I was an Elvis user, as I said, so I dunno how that works
12:17:33 <ologNation> yitz, You're right.
12:17:34 <rajeshsr> well you can move to recording in vim by "q"
12:17:35 <ologNation> It's C-x.
12:17:35 * medfly does not understand what "programming left handed" means.
12:17:36 <joga> dankna: simply press q, then select which register you want to record to, then start doing stuff
12:17:41 <mreh> ologNation, I have a little experience of vim, that's all
12:17:42 <dankna> joga: nice!
12:17:44 <joga> the recording can be edited too
12:17:49 <mreh> medfly: on a netbook
12:17:55 <ologNation> mreh, What do you typicall use?
12:18:02 <dankna> yeah, in Emacs the recording can be edited but it's really difficult to do so I never do
12:18:02 <medfly> okay, then that sucks
12:18:08 <mreh> ologNation, gedit
12:18:08 <joga> (oh, and q in command mode stops recording)
12:18:17 <medfly> "oh shit, I clicked enter." ... "oh shit, I clicked enter." ... "oh shit, I clicked enter."
12:18:38 <rajeshsr> well, editing recording sucks! We can re-record it after all! :)
12:18:49 <dankna> that's my usual workaround, haha
12:19:02 <ologNation> dankna, Yeah. The funny thing is I want to add variables in there somehow sometimes.
12:19:04 <joga> rajeshsr: yeah, but if it's a really long one it's a bothersome task when you make some dumb mistake ;)
12:19:14 <dankna> olog - Emacs has variables in recording
12:19:24 <ologNation> dankna, how do you do it?
12:19:27 <dankna> though I never use them because I can't remember how :(
12:19:31 <Twey> medfly: What about âwilling to publicly look like any gender, but not bothered enough to put in the required effort to look like either?â
12:19:31 <ologNation> oops!
12:19:38 <rajeshsr> joga, hmm! i never did like that. I always break into simple tasks!
12:19:45 <ologNation> Twey, That's called "guy".
12:19:45 <dankna> androgynes are so cute~
12:19:50 <Twey> ologNation: ;)
12:20:00 <Twey> dankna: Yeah :-D
12:20:09 * ologNation needs a haircut. 
12:20:12 <yitz> most of the time, when a task is complicated enough to need a kbd macro that is more than a few keystrokes, i just load the file in ghci and work there.
12:20:21 <rajeshsr> BTW, has anyone here used both vim and emacs?
12:20:27 <joga> I use both
12:20:33 <rajeshsr> i mean equally, without a bias! :)
12:20:43 <joga> nah I just use emacs for slime
12:20:48 <dankna> rajeshshr - yes.  I used vi for five years and even wrote half of my own, before switching to Emacs which I've used for about ten years now
12:20:49 <Twey> rajeshsr: I used vim for several years before I switched
12:20:49 <joga> vim for everything else
12:20:56 <ologNation> yitz, what do you mean?
12:20:59 <Twey> Same as dankna, but halve the timespans ;)
12:21:02 <rajeshsr> Twey, that is interesting! Why?!
12:21:03 <dankna> hehe
12:21:08 <ologNation> you load the elisp in ghci?
12:21:29 <rajeshsr> dankna, like to share your experience?
12:21:29 <yitz> ologNation: no the text file
12:21:45 <dankna> rajeshsr - well I'm happy to answer questions, sure
12:21:51 <yitz> ologNation: then do stuff to it in ghci, then write it back out
12:21:57 <Twey> rajeshsr: vim was the first Real Editor I encountered, but people were making such a fuss about emacs that I decided I should at least give it a fair go, and I really never looked back.
12:22:15 <Twey> (there were a few longing backward glances before I discovered ergoemacs, though)
12:22:21 <dankna> (haha)
12:22:53 <rajeshsr> Twey, So any "comparative" comments on them?
12:23:10 <rajeshsr> both are good, after all they are editors?! :)
12:23:31 <dankna> they're both good.  I find key chords difficult to remember.
12:23:31 <Twey> rajeshsr: Wellâ¦ they're both better than anything else I've tried, but as far as I can see, emacs beats vim hands-down
12:23:41 <dankna> I prefer sequences of multiple keys rather than chords.
12:23:42 <ologNation> yitz,  I wanna see a youtube.
12:23:45 <ologNation> That sounds cool.
12:23:56 <dankna> (chords being like control-meta-swedish-campground-Q)
12:24:01 <Twey> I guess I might want a vi if I had a limited system (little disk space, memory, or slow processor)
12:24:09 <yitz> i once worked as a student under a professor who used teco. watching how fast her fingers moved was frightening.
12:24:14 <Twey> I prefer chords
12:24:14 <dankna> wow teco
12:24:19 <ologNation> yitz, So you, like, map functions over it and stuff?
12:24:26 <yitz> ologNation: right
12:24:45 <dankna> do you really?  my memory has nothing to tag them with, so I know commands "with my elbows" (there are nerve clusters there) or not at all
12:24:46 <ologNation> yitz, I wanna see an example.
12:24:50 <yitz> ologNation: bind variables to intermediate results, repeat.
12:25:00 <dankna> so I can execute commands and think back "wait what did I just type" and have no idea
12:25:01 <rajeshsr> Twey, hmm! interesting! i have used only vim, and used it really well! May be i will learn about e-macs, for what you exactly said, because of the fuss about it! :)
12:25:05 <yitz> ologNation: hmm, i don't have a recording
12:25:15 <Twey> In vi it feels like half the time I spend is spent switching modes
12:25:34 <Twey> dankna: Haha, yes â I'm the same
12:25:38 <dankna> yeah the mode-switch needs to be a key nearer the home row
12:25:41 <dankna> Twey: haha interesting
12:25:50 <yitz> Twey: someone should sell special vi keyboards with extra-strong ESC key
12:25:53 <joga> I have escape under my right thumb
12:25:56 <dankna> I always typed control-left-bracket because it was faster than reaching for escape
12:25:58 <rothwell> 'lo... any way to get haddock to output html that can be embedded in other documents?
12:26:05 <dankna> rothwell: it has an API, heh
12:26:11 <rothwell> dankna: does it?
12:26:14 <dankna> yes
12:26:14 <rothwell> i wasn't aware...
12:26:17 <rothwell> heh, thanks
12:26:19 <dankna> sure
12:26:20 <rothwell> i'll look into it
12:26:38 <Twey> dankna: ergoemacs is good for that â it basically arranges the most common movement/editing commands into two WASD-style keypads, one under each hand
12:26:48 <dankna> twey - ah that's nifty
12:27:06 <yitz> Twey: but for vi
12:27:08 <yitz> ?
12:27:25 <Twey> yitz: Sorry?  What about it?
12:27:42 <yitz> Twey: the name makes it sound optimized for emacs, not vi
12:27:47 <Twey> I don't think an ergoemacs equivalent exists for vi, though I'm sure you could do some remapping
12:28:03 <ologNation> yitz, I wanna see it.
12:28:21 <ologNation> I think that the reason this is such a stimulating conversation is that programming is an experience.
12:28:29 <ologNation> People who love programming care about what it feels like.
12:28:33 <dankna> certainly
12:28:35 <ologNation> So editors are really important.
12:28:52 <Twey> It probably wouldn't work as well, though, because there are more movement keys (whereas emacs prefers keys with modifiers, so you can have a few [seven, in ergoemacs] core movement keys and modify them)
12:28:56 <Twey> ologNation: Yeah
12:28:58 * ddarius uses vim and Visual Studio, but doesn't care too much about the editor.
12:29:11 <ologNation> ddarius, That's interesting.
12:29:20 * pippijn uses vim and visual studio and does care about the editor
12:29:22 <joga> ddarius: do you put them to good use?
12:30:34 <erikc> i bet he inserts characters with them
12:30:41 <Twey> Surely not
12:30:47 <zeiris> Is there an unsafePerformMonad equivalent to non-IO things?
12:30:59 <Twey> zeiris: Not such a generic one, no
12:31:12 <zeiris> I've got "name <- peek Name" lines cluttering up mah code. I want them varmints gone.
12:31:13 <Twey> zeiris: The ability to âperformâ things is not part of the monad typeclass
12:31:32 <Twey> Various monads have different escape functions
12:32:03 <Twey> (but that's not really related to their being monads: they just happen to both be monads, and have functions that âextractâ the internal type)
12:32:04 <yitz> ologNation: hmm. do you have an example of something you do where you need a big kbd macro?
12:33:00 <Twey> yitz: E.G. removing one layer of primes from every name defined in a big where clause?  âº
12:33:11 <fax> prime numbers?
12:34:06 <yitz> Twey: yeah. just "defined", or also where they're used?
12:34:35 <yitz> fax: change varName''' to varName'' etc.
12:34:38 <Twey> Just defined, really â where they're used too is getting into regex territory, I think :Ã¾
12:34:46 <ologNation> yitz, A big one?
12:34:50 <yitz> Twey: ew regex
12:34:50 <ologNation> Twey, Good one.
12:34:59 <Twey> But that's my most common use-case for keyboard macros
12:35:10 <Twey> Performing a repetitive change to a whole bunch of lines
12:35:19 <dankna> yes, same here
12:35:43 <ologNation> yitz, Maybe removing every prime-numbered line.
12:35:55 <yitz> ologNation: :)
12:36:03 <dankna> recently I've used them for, say, converting back and forth between quoted strings embedded in Haskell code containing SQL and actual standalone SQL
12:36:21 <dankna> adding and removing ++ " and stuff like that
12:36:56 <ologNation> Sometimes I imagine that a good editor should be like a rubics cube.
12:37:04 <ologNation> There is no sense of linear order in the text.
12:37:16 <ologNation> Just these fifty buttons
12:37:32 <yitz> Twey: I would use kbd macros - or just doing it in ghci - for things that are *more* complicated than what would be convenient to do using query-replace-regex
12:37:38 <ologNation> and this sliding object, folding through symmetries in response to my finger-flickings.
12:37:38 <dankna> also for when I have, say, something in a format like "key|value" and I need to convert many lines like that to lines in a format like "function key = subroutine key value"
12:37:57 <Twey> yitz: They're really different use-cases
12:38:02 <dankna> smart search/replace doesn't work as nicely because it's more work to design a regexp to match the parts of the line than it is to just navigate to them in record mode
12:38:15 <Twey> I don't understand âjust doing it in GHCiâ
12:38:30 <Twey> How would you do something like that in GHCi more easily than with a keyboard macro?
12:39:43 <ologNation> Would anyone be able to build a website at which the interior letters of each word permuted randomly when you clicked on it?
12:39:55 <yitz> Twey: well, it depends what. ghci is a more powerful environment, but it often takes more keystrokes to do something. that can be offset by removing the need to enter an entire big macro many times until you finally get it right.
12:40:24 <yitz> (and - undo undo undo...)
12:40:25 <Twey> yitz: Still not with you here â how is it a âmore powerful environmentâ?
12:40:29 <ologNation> I could do it by generating a massive web of html files linking each other, but I wouldn't know how to make the clicking call a (say) haskell prgram which edited the html file and replaced it.
12:40:37 <ologNation> I would like to build such a website though.
12:40:47 <ddarius> Twey: You have a Turing-complete language, how is it -not- a more powerful environment?
12:40:51 <dankna> you want to do that with Javascript
12:40:55 <Twey> ologNation: I have no idea what you're talking about, but I'm interested to see it âº
12:41:00 <dankna> sounds trippy
12:41:12 <yitz> Twey: well, i don't like to do elisp programming at the M-: prompt, although that's also an option
12:41:13 <Twey> ddarius: But the language can't be used for editing your source-code
12:41:15 <ologNation> dankna, Twey,  It's really trippy.
12:41:22 <ologNation> It's not totally my idea.
12:41:22 <ddarius> Twey: Sure it can.
12:41:28 <Twey> Well, I suppose you can represent it all as strings
12:41:32 <ddarius> Twey: source <- readFile "foo.hs"
12:41:35 <Twey> But that's kind of inconvenient
12:41:44 <ddarius> Twey: That's what a text editor is doing.
12:41:50 <ologNation> Some linguists noticed that people can read text almost as well if the interior letters are all permuted.
12:42:10 <Twey> No, it's providing an interactive interface â the strings are all behind the scenes
12:42:10 <yitz> Twey: why inconventient?
12:42:14 <medfly> that's in English though, no?
12:42:23 <ologNation> medfly, yeah.
12:42:32 <Twey> That âstudyâ is less than universally accepted
12:42:33 <yitz> *inconvenient
12:42:42 <ologNation> dankna, Maybe javascript, yeah.
12:42:49 <Twey> yitz: Well, you have to worry about quotation marks, for a start
12:42:59 <medfly> ologNation, hehe, I just thought yuo were trying to say it's valid in Java too.
12:43:01 <Twey> And you don't get to see what you're editing as you're editing it
12:43:13 <yitz> Twey: in practice not a problem usually
12:43:18 <Twey> And in Haskell, you can't really update stuff as you go and then save it
12:43:34 <fax> @tell dolio He also claimed to have invented a new decimal number notation that leads to proofs/disproofs of the Prime number theorem, Poincare Conjecture, Goldbach Conjecture, Fermat's Last Theorem, and the Riemann Hypothesis, and which will render current methods of mathematics  obsolete
12:43:35 <lambdabot> Consider it noted.
12:43:35 <Twey> I suppose you could shadow it a bunch of times
12:43:52 <yitz> Twey: but you *do* get to see what you're editing as you craft your functions
12:43:53 <medfly> :)
12:43:56 <medfly> fax, crackpot?
12:44:02 <ddarius> Clearly.
12:44:05 <yitz> Twey: and the text that is in them
12:44:39 <Twey> yitz: Let me try this again
12:44:43 <yitz> Twey: and edit them using readline keys, similar to simple emacs keys
12:44:44 <fax> This theorem is important in two aspects. One, it changes all of
12:44:44 <fax> current math
12:44:44 <fax> for it destroys much of what was considered to be math but as it turns
12:44:44 <fax> out
12:44:45 <fax> was just fiddling idealism such as Cantor transfinites
12:44:47 <Twey> yitz: How does your edit cycle go?
12:45:01 <Twey> yitz: You open GHCi, readFile a file, thenâ¦?
12:46:27 <yitz> Twey: readfile. let a=stuff. look at result, press up arrow, try again, get something good. let b=other stuff. let myFunc x y=stuff. etc. ... let z=stuff that gives the final result. when it works - writeFile z
12:47:24 <yitz> Twey: usually :m +Data.List, maybe some others, also
12:48:44 <Twey> yitz: So how would you do something like navigate to the first instance of a particular name, delete it, and replace it with something else?
12:48:46 <yitz> fax: forget it, Fermat already done.
12:49:05 <fax> yitz: This theorem solves the Riemann Hypothesis,  Goldbach Conjecture, Perfect Numbers, Fermat's Last Theorem, and
12:49:09 <fax> almost
12:49:11 <fax> all other unsolved problems.
12:49:12 * pippijn is compiling his haskell bindings again :\
12:49:33 <Twey> Since you can't, e.g., use inline search or just navigate to it with movement keys?
12:49:46 <yitz> Twey: oh, it's almost always fmap lines $ readFile, and often fmap (map words.lines) $ readFile
12:49:49 <ddarius> fax: I can do that too.  Prove false = true.  QED.
12:51:39 <dankna> FLT isn't unsolved
12:51:43 <dankna> it was solved in the 90s
12:52:12 <dankna> oh, yitz said that
12:52:19 * hackagebot monad-parallel 0.5 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.5 (MarioBlazevic)
12:52:59 <yitz> Twey: s.t. like let (h,b:t)=break(==["name"].take 1)a;b'="otherName":drop 1 b -- or whatever
12:53:21 <Twey> yitz: So you'd do, what, elemIndex True (map (elem "someName")) yourStuff, then let b = a !! thatIndex, then let c = elemIndex "someName" b, break it, do your transformation, and concatenate it all together?
12:53:26 <Twey> Blimey.
12:53:38 <yitz> Twey: thought you'd like it :)
12:54:11 <ddarius> Doesn't using words destroy your formatting?
12:54:19 <ologNation> I want to write a story with a bunch of files edited in text mode
12:54:19 * hackagebot monad-coroutine 0.5 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.5 (MarioBlazevic)
12:54:21 * hackagebot scc 0.5 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.5 (MarioBlazevic)
12:54:30 <Twey> And you consider this more powerful than hitting inline search, entering someName, hitting kill word, typing something else, and hitting save?  :Ã¾
12:54:32 <CcSsNET> not at all!
12:54:35 <CcSsNET> oops
12:54:49 <ologNation> Then woven together (by haskell, of course) into one big text file in proper latex a
12:54:57 <ologNation> and then print a big pdf of the story
12:55:22 <ologNation> and also a pdf listing verbatim all of the contents of the project directory including the latex source and the haskell scripts that did the weaving.
12:55:59 <Twey> And fail to see how it could be considered inconvenient by comparison?  :Ã¾
12:56:03 <yitz> Twey: no. it's more powerful than typing in a huge kbd macro, that when it doesn't work you have to enter from scratch several times and hit undo 20 or 30 times.
12:56:21 <yitz> Twey: it's not more powerful than simple editing. of course not.
12:56:51 <yitz> Twey: (but it does work for that too, and just like emacs and vi, once you get the hang of it it's pretty fast)
12:58:22 <Twey> But it'sâ¦ 48 keystrokes plus identifiers, instead of three plus identifiers
12:58:26 <yitz> Twey: also, if your kbd macro really needs all kinds of conditionals, and/or a whole bunch of complex regexes - forget it, it will take all day in the editor, just do it in two minutes in ghci
12:59:03 <Twey> And you're more likely to make a mistake, too, since you can't see what you're doing while you're doing it
12:59:15 <yitz> Twey: repeat i'm not talking about choosing this method for things that you can do in 3 keystrokes in an editor.
12:59:30 <Twey> 19:56:28 < yitz> Twey: (but it does work for that too, and just like emacs and vi, once you get the hang of it it's pretty fast)
12:59:33 <yitz> Twey: in some ways you can see *better* what you are doing
13:00:04 <Twey> I make it about sixteen times slowerâ¦ that doesn't count as âpretty fastâ :Ã¾
13:00:10 <Twey> Heck, I could do it in MS Notepad faster than that
13:00:27 <yitz> Twey: i meant that if you moved over to ghci to do something complex, and then you just want to, say, change a word, it's not so bad, you don't have to go back and forth, you can change it in ghci, too. takes a few seconds longer, that's all.
13:00:34 <Twey> How so?  You can't see what you're doing it all â you have to visualise it in your mind
13:00:42 <Twey> s/it all/at all/
13:01:58 <Twey> Unless you stop to print the result of your expression after adding each new step
13:02:16 <yitz> Twey: you can *see* the macro you are typing. you can see the exact results of the macro, cleanly isolated from the rest of the file. you can easily look at whatever snippet of the file you want, after any combination of partial application of your macro work
13:03:02 <yitz> Twey: you can filter the file with any predicate and look at any selected snippet
13:03:52 <Twey> No you can't â not while you're typing it
13:04:04 <Twey> You have to form it first, then apply it to something and look at the result
13:04:34 <yitz> Twey: the unit of work is one ghci command, not one keystroke. that's more natural for heavy macro work
13:05:14 <ologNation> I begin with a concrete task.
13:05:19 <ologNation> Then I think of a way to automate it.
13:05:21 <ologNation> It goes well.
13:05:30 <ologNation> And I begin to automate the process of automation.
13:05:31 <ologNation> And so on.
13:05:33 <ologNation> Until I end
13:05:38 <ologNation> in staring at the screen,
13:05:47 <ologNation> thinking about something deep.
13:05:48 <yitz> Twey: as you are typing a complex regex, the crazy highlighting and "incomplete" and other stuff that flashes on and off with each keystroke is not helpful at all, for example.
13:06:24 <Twey> yitz: I don't think emacs does any of thatâ¦
13:06:28 <yitz> sure it does
13:06:43 <Twey> Certainly not with replace-regexp
13:06:56 <yitz> well my emacs does
13:07:12 <chrisdone> are you using regexp-builder?
13:07:18 <yitz> no
13:07:41 <Twey> Stock emacs 23.1 doesn't
13:08:13 <chrisdone> are you guys talking about yasnippet?
13:08:34 <Twey> No
13:08:47 <yitz> Twey: furthermore, i find forcing myself to think of complex editing task through the lens of regexes a bit unpleasant compared to expressing what i am doing using haskell combinators
13:08:57 <Twey> At least, I was â I have no idea what yitz has installed in his editor
13:09:03 <Twey> â¦ wasn't**
13:09:11 <yitz> Twey: stock aquamacs
13:10:18 <Twey> I kind of agree WRT regexen vs. combinators
13:10:27 <Twey> But the regex approach tends to be more concise, too
13:10:42 <Twey> I'd mostly prefer the combinators if it weren't a one-off task
13:10:42 <yitz> Twey: yeah. you could do it in perl REPL, too
13:13:48 <yitz> Twey: with this editor stuff, claims about one tool and/or approach being inherently faster than the other is usually moot. any reasonable editor and methodology, in the hands of a skilled practitioner, is extremely fast. so you do what you are most comfortable with.
13:14:09 <yitz> i guess watching my advisor firing away in teco taught me that
13:15:27 <twink> yitz: The line editor guys are scary.
13:15:35 <yitz> hehe
13:15:42 <Twey> Well, that's basically what yitz is doing.
13:16:12 <yitz> Twey: yeah but i cheat - emacs is open all along in the window right next to it :)
13:16:51 <Twey> Heh
13:21:10 <ologNation>  Youtube might be a good way to share some of these ideas.
13:25:10 <yitz> ologNation: you're right. i should get more fluent at recording screen videos.
13:26:16 <ologNation> yitz, It would be cool.
13:26:24 <ologNation> We could also think of it as a sort of community project.
13:26:33 <ologNation> There's this huge question of style.
13:26:44 <ologNation> It's hard to emphasize what an important part of programming it is.
13:26:46 <yitz> ologNation: it's a very personal thing
13:27:04 <ologNation> I see people spend years and decades of their life seeking this way of programming,
13:27:18 <ologNation> but they never learn to enjoy the feeling of editing text.
13:27:30 <ologNation> yitz, Indeed.
13:28:26 <mreh> I think more than I type, the point is moot
13:29:43 <ologNation> mreh, Thinking is important.
13:29:48 <ologNation> I forget to think sometimes.
13:30:33 <ologNation> I like both.  Thinking. Typeing.
13:30:56 <ologNation> If I liked knitting instead of typeing, maybe I would think the same thoughts, but have sweaters instead of programs.
13:31:51 <ahihi> eah
13:31:56 <ahihi> oops sorry
13:35:55 <ologNation> I have to "hClose" a bunch of files.
13:36:20 <ologNation> Instead of having 10 which all say hClose, is there a way to map hClose over a list of handles?
13:36:41 <Twey> Of course
13:36:53 <Twey> mapM_ hClose [handle1, handle2, handle3, handle4 â¦]
13:38:39 <bonobo2> hej all
13:38:50 <bonobo2> how do I set a breakpoint in GHCi?
13:38:53 <xerox> :help
13:39:38 <Phyx-> :b
13:40:43 <bonobo2> *Main Happstack.Data.IxSet> :bre getOrd
13:40:44 <bonobo2> No breakpoints found at that location.
13:40:53 <bonobo2> what does this mean?
13:45:47 <mreh> > acos 1.5
13:45:48 <lambdabot>   NaN
13:45:52 <mreh> excellent
13:46:19 <companion_cube> > atan 1.5
13:46:21 <mreh> not that that ever occurs when doing dot products
13:46:21 <lambdabot>   0.982793723247329
13:46:27 <tensorpudding> @type NaN
13:46:28 <lambdabot> Not in scope: data constructor `NaN'
13:46:39 <mreh> > atan 10000000000000000000000000
13:46:40 <lambdabot>   1.5707963267948966
13:46:41 <tensorpudding> @type (acos 1.5)
13:46:42 <lambdabot> forall t. (Floating t) => t
13:46:44 <companion_cube> > acos . cos $ 42
13:46:46 <lambdabot>   1.9822971502571054
13:46:52 <tensorpudding> NaN does appear to be a Floating
13:47:17 <mreh> NaN is IEEE 754
13:47:37 <mreh> anyway, acos 1.5 doesn't make sense
13:47:55 <mreh> shouldn't that be an error?
13:47:56 <fax> > acos 1.5 :: Complex Double
13:47:57 <lambdabot>   0.0 :+ 0.962423650119207
13:48:00 <mreh> ooh
13:49:09 <tensorpudding> Hmm.
13:49:13 <tensorpudding> That's smart.
13:49:19 <tensorpudding> @type acos
13:49:20 <lambdabot> forall a. (Floating a) => a -> a
13:49:46 <mreh> Complex Double presumably is a type of floating point number
13:49:58 <tensorpudding> Yes.
13:50:10 <tensorpudding> It's a different type though.
13:50:14 <mreh> but I suspect there is magic going on there
13:51:13 <mreh> > cos pi
13:51:15 <lambdabot>   -1.0
13:51:27 <mreh> riiight
13:51:34 <mreh> oh, that is right
13:52:02 <mreh> I'm trying to detect obtuse angles
13:52:07 <mreh> this isn't going to work
13:52:46 <mreh> projecting -1 onto another vector is too abstract for me to imagine
13:53:15 <mreh> well I can kind of imagine it
13:53:32 <tensorpudding> What do you mean by projecting -1?
13:54:11 <mreh> the dot product is the magnitude of the projection of one vector onto another
13:54:37 <tensorpudding> Yeah, that is way of looking at the dot product.
13:55:13 <mreh> anyway, I have bigger problems, I'm trying to decompose a concave polygon... how can I tell if the first angle is an obtuse interior angle and not a acute exterior one?
13:55:16 <fax> -1 just means backwards
13:55:28 <mreh> by going only clockwise/anti-clockwise?
13:55:33 <opqdonut> yeah
13:55:39 <opqdonut> that's one solution
13:55:54 <mreh> do we have a library for this?
13:56:59 <mreh> damn... how can I tell if I'm going clockwise or anti-clockwise?
13:57:57 <fax> does it matter?
13:58:01 <mreh> I might just specify it as a constraint, it's a bloody game of asteroids not a 2D graphics engine
13:58:02 <fax> just go right around once
13:58:11 <fax> if you have negative area that means you went backwards
13:58:24 <mreh> fax: how do you define a negative area?
13:58:35 <mreh> I'm confused
13:58:41 <fax> don't be
13:59:00 <fax> suppose a clockwise triangle has area 1, then it's counterclockwise version would have area -1
13:59:20 <mreh> fax: what equation are you using?
13:59:25 <fax> none
13:59:36 <fax> you can use this to find the orientatin of a polygon
13:59:40 <mreh> I need the proof to believe you
13:59:44 <ddarius> mreh: Look into geometric algebra.
13:59:52 <znutar> mreh: pretend the 2d is 3d and the cross product will give you the area of a triangle with 2 sides equal to the vectors, with the sign of the Z component being the winding and the magnitude of the z component being the area
13:59:58 <fax> proof of what ?
14:00:06 * ddarius vomits on the cross product.
14:00:32 <Botje> heh heh. cross product ftw
14:00:34 <ddarius> pretend the 2d is 2d and the outer product will give you the area of the triangle
14:00:42 <mreh> this is homogeneous co-ordinates isn't it
14:00:59 <mreh> yeah, I'll just use 2 dimensions :)
14:01:04 <znutar> nah, not homogeneous at all, just an outer product
14:02:00 <mreh> presumable I have to take the determinant of the outer-product
14:02:07 <fax> :S
14:02:10 <fax> why make it so complicated
14:02:34 <mreh> because the definition of the outer-product is a matrix
14:03:04 * ddarius isn't talking about that outer product.
14:03:12 * ddarius is talking about the wedge product.
14:03:16 <mreh> oh
14:04:50 <mreh> they didn't teach me these things in university
14:05:05 <ddarius> Of course not.
14:05:24 <fax> hehe
14:06:22 <sinelaw> hi
14:07:13 <mreh> hello
14:07:51 <mreh> I wasn't taught these things because I went to a terrible university, I had to teach myself linear algebra in 4 weeks, that was fun
14:08:01 <sinelaw> ooh gilbert strang
14:08:32 <ddarius> mreh: You weren't taught these things because they aren't commonly taught at all.
14:09:00 <mreh> hmm, the wedge vector is defined in terms of itself
14:09:07 <mreh> and the basis vectors
14:09:42 <fax> where did you get the idea to study linear algebra?
14:09:44 * hackagebot gitit 0.7.2.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.2.1 (JohnMacFarlane)
14:09:58 <mreh> fax: necessity
14:10:11 <mreh> it's examined material on my course this year, Machine Learning
14:10:18 <fax> oh
14:10:23 <mreh> about 50% of it involves some linear algebra
14:10:25 <fax> so are you doing a computing course?
14:10:41 <mreh> I obtained my Bachelors in CS last year
14:11:28 <pickles> fax: most math type stuff is done in computers using linear alg, so it's handy to know ;)
14:11:44 <ddarius> mreh: Read these two papers: http://www.science.uva.nl/~leo/clifford/dorst-mann-I.pdf and http://www.science.uva.nl/~leo/clifford/dorst-mann-II.pdf
14:25:54 <superoptimizer> New to haskell. Reading Real World Haskell. Having a problem with one of the exercises. I don't think they've given enough information to complete it.
14:26:16 <Twey> Which exercise is that?
14:27:04 <superoptimizer> Exercise 1 on page 60. They present a recursive parametric type List and ask you to write a converter from that to the built-in parametric list type
14:28:15 <Twey> Sorry, I only have the Web version â which chapter is that?
14:28:15 <pastorn> superoptimizer: can you find it here? http://book.realworldhaskell.org/read/
14:29:10 <Twey> Oh, I see â Chapter 3, under âRecursive Typesâ
14:29:27 * ivanm vaguely recalls that exercise, and doesn't think you need any extra info
14:29:41 <ivanm> it's a direct fold application by replacing one constructor by another
14:29:51 * mauke wonders why people refer to book contents by page
14:29:54 <Twey> Let's seeâ¦ you've got pattern-matching and functions, and recursionâ¦ I think you have everything you need
14:30:09 <Twey> mauke: Ease of lookup?
14:30:23 <ivanm> mauke: you mean you _don't_ own a copy of RWH? :o
14:30:24 <ivanm> ;-)
14:30:25 <mauke> Twey: but depends on the exact book version
14:30:40 <ivanm> there's only one print version of RWH...
14:30:54 <mauke> this isn't about RWH
14:30:57 <Twey> mauke: That's true, but it's easy to search in the immediate vicinity if you have a different version.
14:31:15 <mauke> Twey: yeah, so you only have to search ~20 pages
14:31:16 <mauke> what
14:31:17 <Twey> There isn't always an alternative
14:31:41 <Twey> Well, that's how much you'd have to search anyway if they specified it by chapter
14:31:48 <Twey> Or possibly more, depending on the book
14:32:00 <pickles> someone should do statistics on that
14:32:01 <superoptimizer>  I see. Didn't know about that site, thanks. I think the confusion I had is that they hadn't given an example of a function that took a parametric type, but from one of the solutions on that site it's clear what's expected.
14:34:54 <Twey> superoptimizer: They did
14:35:08 <Twey> There's an example of a function that takes a List just a little way back up the chapter
14:35:25 <Twey> Under âExhaustive patterns and wild cardsâ
14:35:43 <Twey> Oh, and one without special syntax a little bit further up
14:36:42 <brentbeer> just jumped in so you may already be talking about this: as a beginner is there a "guide" of sorts thats good to start with (besides learnyouahaskell )
14:36:56 <Twey> brentbeer: Define âbeginnerâ
14:37:06 <Twey> Programming experience?  Mathematical experience?
14:37:11 <Cale> brentbeer: Perhaps "Real World Haskell"?
14:37:16 <Cale> @where rwh
14:37:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:37:22 <brentbeer> cale: thats what i was thinking
14:37:24 <Cale> brentbeer: There's also yaht
14:37:27 <Cale> @where yaht
14:37:27 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
14:37:31 <Cale> @where wikibook
14:37:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:37:37 <Cale> and the wikibook :)
14:37:47 <superoptimizer> Hmm, I must be blind. I see the ones that use the built-in list type, but not the parameterized user defined type. I seem to have gotten something working, though.
14:38:07 <brentbeer> twey: experience with ruby for about a year (not too intense) and OOP experience for about 3 years, sr in college
14:38:18 <Twey> superoptimizer: Read âFurther adventuresâ
14:38:23 <Twey> brentbeer: RWH should be fine for you
14:38:35 <brentbeer> thanks
14:39:40 <superoptimizer> 30 years of programming experience certainly didn't prepare me for this :)
14:39:56 <superoptimizer> Probably a detriment more than anything.
14:40:55 <Cale> superoptimizer: Yeah, to some extent, it's best to pretend that you don't know anything and that you're learning your first language.
14:41:10 <brentbeer> 30 years of OOP or something, i could see that hurting
14:41:24 <brentbeer> with 3 years i already have to look at simple things multiple times
14:41:29 <Cale> superoptimizer: Eventually, once you relearn to express things, all the knowledge about algorithms and such will become useful again.
14:42:11 <twink> It didn't seem like that big a deal to me.
14:42:43 <twink> I had only been programming 5 years at the time.
14:43:41 <superoptimizer> 30 years of imperitive procedural languages, 20 years of assembly language and C++, 3 years of data-parallel programming in HLSL & CUDA, and 17 years writing compilers for all the above.
14:43:51 <Twey> I'm intimidated.
14:44:27 <superoptimizer> First functional programming (other than being forced to write an expression optimizer in LISP in college). Very different, but I suppose I'll catch on.
14:44:39 <nanashi> or it may be more difficult.
14:45:53 <Twey> After compiler-writing?  You're kidding me.  :Ã¾
14:45:58 <superoptimizer> Different things are difficult to different people. I recall when I took C at a community college when I was in high school, there was a guy in the class who wrote everything in mainframe assembly language. He dropped out half way through the class because he just didn't get these "high level" concepts and syntax.
14:46:10 <Twey> Heheh.
14:46:38 <Darkone> Uhhmm
14:46:50 <fax> yeah I'm like that
14:46:56 <fax> except relace high and lov
14:46:57 <Darkone> I've lined up both of my pipes for the 2 guards at the same level of indentation
14:47:19 <Darkone> The one on the line of the function passes, but the second is giving a parse error when I try to load it into GHCi
14:47:59 <pickles> i would agree w/ some of the sentiments expressed already, haskell was the toughest language i've learned since C/C++ (which were my first "real" languages)
14:48:05 <pickles> though so so so worth the pain
14:48:13 <Darkone> asInt' (x:xs) tab |      next line is   tab tab |
14:48:14 <Twey> Darkone: GHCi doesn't accept multi-line input
14:48:28 <Twey> Darkone: In this case, you can just put them both on the same line
14:48:31 <Cale> Darkone: Do *not* put tab characters in your source files
14:48:36 <Darkone> Ahhh
14:48:44 <Twey> Darkone: Sometimes you have to use semicolons and braces.
14:48:51 <Cale> Darkone: make sure your editor is converting all tabs to spaces
14:48:51 <ddarius> Twey: Newer GHCi's have :{ and :}
14:49:01 <Twey> ddarius: Really?  Huh.  Didn't know that.
14:49:18 <Twey> Hm
14:49:24 <Twey> Prelude> do :{
14:49:30 <Twey> <interactive>:1:0: Empty 'do' construct
14:49:41 <ddarius> :{ multiline stuff :}
14:49:42 <Twey> What am I supposed to do (ha, ha) there?
14:49:57 <Cale> Darkone: If you're using vim, you can add  set expandtab  and  set smarttab  to your .vimrc
14:49:59 <Twey> Oh, put the :{ first?
14:50:42 <Twey> Hm
14:50:57 <benmachine> you need :{ on its own line I think
14:51:22 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24228#a24228
14:51:33 <Twey> Does it need explicit semicolons, too?
14:52:03 <Twey> (yay, hpaste is up)
14:52:10 <Cale> looks like it
14:52:20 <Twey> Doesn't that defeat the point a little?  :Ã¾
14:52:28 <benmachine> no
14:52:30 <benmachine> well
14:52:32 <benmachine> a little
14:52:42 <Darkone> Huh.. I must have screwed this up. Even when I had the guards- ddooooooooohhhhh
14:52:47 * Darkone facepalms
14:52:57 <Darkone> Guessing asInt' is already defined in prelude?
14:53:09 <Twey> No
14:53:13 <benmachine> but having to do whole things on one line before was much worse than having to put a few semicolons in
14:53:16 <Darkone> Huh
14:53:28 <Alpounet> hi there
14:53:29 <Darkone> I changed it to asInt_fold, and now it's fine.
14:53:36 <Twey> I don't believe there are any primed functions in the Prelude
14:53:41 <Darkone> It was apparently trying to pass the guard to asInt'??
14:53:46 <ddarius> Twey: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html It's discussed in section 2.4.2 there.
14:54:40 <Darkone> Uhhm
14:54:56 <Darkone> What's ord in again?  Data.Types?
14:55:07 <Twey> Data.Char
14:55:19 <benmachine> @where hayoo
14:55:19 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:55:23 <benmachine> comes in handy ^
14:55:26 <Twey> Unless you mean Ord, in which case the type is in the Prelude but there's some useful stuff in Data.Ord
14:55:28 <Darkone> Yea, just found it.
14:55:44 <Darkone> Yea, was looking for ord :P
14:56:06 <Twey> I wasn't sure why you'd be looking for ord in something called âData.Typesâ :Ã¾
14:56:22 <Twey> Also:
14:56:25 <Twey> @index ord
14:56:26 <lambdabot> Data.Char
14:56:39 <Darkone> Was thinking of something else :P
14:56:48 <Twey> Haha, okay
14:57:08 <aavogt> hmm, some versions of quickcheck have instances for Arbitrary Rational?
14:58:37 <danderson> </zurihac>
14:58:40 <danderson> good times.
15:00:18 <chrisdone> danderson: yes! did we meet? I need a function :: RealName -> IRCName
15:00:49 <chrisdone> danderson: nevermind! I just read the #zurihac channel -- I know you
15:01:40 <danderson> chrisdone: that function is called /whois nick, for certain correctly configured IRC clients :)
15:01:54 <ddarius> danderson: The inverse is.
15:02:18 <chrisdone> haha, outsmartassed! ;p
15:02:23 <danderson> oh, yes. Well, handwave handwave
15:02:34 <danderson> just /whois everyone and build a bijection mapping
15:02:48 <danderson> and kickban people who violate the bijection assumption
15:02:58 <chrisdone> haha!
15:03:19 <chrisdone> ahh, great Zurihac pictures :)
15:03:49 <sinelaw> chrisdonehey
15:03:53 <sinelaw> chrisdone hey rather
15:04:24 <chrisdone> sinelaw: hey there :)
15:05:24 <mreh> does anyone know of a convex hull calculator already on hackage?
15:05:59 <Alpounet> so, how was zurihac ?
15:07:04 <chrisdone> Alpounet: talkative, productive, expensive, popular, too short
15:07:20 <danderson> yeah, what chrisdone said
15:07:43 <danderson> also more chaotic than I expected, in that I did nothing that I was planning to, but picked up loads more TODOs
15:08:10 <benmachine> heehee
15:08:12 <sinelaw> sounds like fun!
15:08:23 <chrisdone> me too
15:09:12 <dufflebunk> mreh: Not in Hackage, but this might be what you're looking for: http://www.dinkla.net/fp/cglib.html
15:09:50 <Alpounet> chrisdone, danderson, heh ok, nice still. I have also seen a lot of uploads to hackage !
15:10:13 <danderson> Alpounet: there was a T-shirt involved, that's why :)
15:10:29 <mreh> dufflebunk,  cheers
15:11:28 <chrisdone> I gained experience using git, specifically in a team, which was handy. now I'm going around my projects doing commits and other people's, just so I can practice more
15:11:51 <Alpounet> danderson, ohhh, makes sense indeed :p
15:12:08 <superoptimizer> git is awesome.
15:12:08 <Alpounet> chrisdone, tryhaskell ?
15:13:26 <Darkone> Uhhh
15:13:28 <chrisdone> Alpounet: I didn't touch it at zurihac, was working on benchmarks for blazehtml. but I spoke to a lot of people about it and got some feedback/ideas. did you manage to write some quizz system with it? it was you who wanted to do that,  right?
15:13:58 <Alpounet> nope, wasn't me
15:14:06 <Alpounet> are you actually trying to make me put that on my todo list ?
15:14:08 <Alpounet> :p
15:14:22 <chrisdone> er, um, yes. yes, I am :)
15:14:23 <Darkone> I must be understanding this wrong. foldl is left associative, right? (((0 + 1) + 2) + 3)?
15:14:47 <chrisdone> @src foldl
15:14:47 <lambdabot> foldl f z []     = z
15:14:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:14:55 <Twey> > foldl subtract 0 [1, 2, 3]
15:14:56 <lambdabot>   2
15:15:16 <Twey> > ((0 `subtract` 1) `subtract` 2) `subtract` 3
15:15:16 <ddarius> (((1 + 2) + 3) + 0)
15:15:17 <lambdabot>   2
15:15:28 <ddarius> I'm wrong.
15:15:33 <Twey> > foldl subtract a [b, c, d]
15:15:34 <lambdabot>   d - (c - (b - a))
15:15:36 <chrisdone> > foldl f x [y,z]
15:15:37 <lambdabot>   f (f x y) z
15:15:41 <Darkone> Wait, I think I get it.  -1 * asInt_fold2 xs   is -1 * (...), right?
15:15:48 <ddarius> Twey: Subtract flips.
15:15:58 <Twey> ddarius: That's why I used `subtract`
15:16:11 <ddarius> > foldl (+) a [b,c,d]
15:16:12 <lambdabot>   a + b + c + d
15:16:17 <Twey> Useful :Ã¾
15:16:27 <Twey> Oh!
15:16:30 <Twey> I see what you mean.
15:16:39 <Twey> > foldl (-) 0 [1, 2, 3]
15:16:40 <lambdabot>   -6
15:16:45 <Darkone> For some reason I was thinking it would be (((-1 * 1) + 2) + 3). Gahhh I'm doing badly when it comes to thinking clearly today
15:16:50 <Twey> > foldl (-) a [b, c, d]
15:16:51 <lambdabot>   a - b - c - d
15:16:54 <Twey> Bah :Ã¾
15:17:51 <djahandarie> haha
15:17:53 <dons> hey guys, feedback on the new haskell platform site?
15:17:54 <dons>  http://hackage.haskell.org/platform/new/
15:18:02 <Darkone> negate foldl (+) 0 "12345"
15:18:09 <chrisdone> Darkone: a nice way is to understand pure haskell functions that are confusing to you is to take a simple expression like `foldl f x [a,b,c]` and then write out the substitutions line by line
15:18:43 <sinelaw> dons nice design
15:18:55 <danderson> dons: maybe periods at the end of the mini-sentences under the headings on the right
15:18:59 <Darkone> Would be negate (((((0 + 1)+2)+3)+4)+5) ?
15:19:09 <danderson> not sure which is correct, but my brain falls off the end of the sentences without them
15:19:09 <sinelaw> yes I agree with danderson
15:19:11 * hackagebot arbtt 0.5 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.5 (JoachimBreitner)
15:19:22 <dons> mmm
15:19:24 <dons> yes.
15:19:26 <djahandarie> dons, maybe lighten the blue a little so there is better contrast for the text
15:19:31 <sinelaw> dons also maybe slightly brighter background?
15:19:34 <Darkone> I think I got it right now :V
15:19:52 <dons> yeah, that's a good point
15:20:12 <djahandarie> dons, also, what is with that mac logo?
15:20:46 <dons> that's the open source logo -- not affiliated with apple.
15:20:59 <djahandarie> Interesting, I've never seen it before.
15:21:04 <danderson> djahandarie: it looks strange, but check out mozilla.org - they use the same one to represent OS X
15:21:11 <dons> e.g http://www.mozilla.com/en-US/firefox/all.html
15:21:30 <chrisdone> dons: very web 2.0 and clean, simple and straight-forward. I like it! the sub-pages don't look anything like the main page but that's not a big concern, eh?
15:21:51 <dons> yeah, they're just 'generic' hp pages.
15:22:04 <djahandarie> Although a standard logo across the pages might be helpful
15:22:11 <dons> i might be able to make them a bit more uniform
15:22:18 <danderson> dons: maybe make the "Get the Haskell Platform" font ever so slightly smaller
15:22:18 <djahandarie> So people know they haven't completely left the site
15:22:35 <danderson> here, it renders with barely a pixel or two of padding between the text and the edge of the light box
15:22:48 <dons> mmm
15:22:55 <Twey> dons: You could have the main bar at the top, then some content underneath it
15:23:24 <djahandarie> It seems to just use whatever you have set as sans-serif
15:23:26 <Twey> dons: I'd like a bit more definition on the bottom corners of the âGetâ box
15:23:40 <djahandarie> Maybe a default font would be better for consistent rendering
15:23:45 <Twey> dons: Having it fade out like that screws up my 3D perspective
15:24:30 <danderson> dons: if you have the original scalable image for the background, I can twiddle it if you want a variation on color/form
15:24:54 <djahandarie> Also, this is a personal preference, but I like helvetica/arial for headers and verdana for body text
15:25:35 <Twey> djahandarie: http://www.xs4all.nl/~sbpoley/webmatters/verdana.html
15:26:22 <dons> yeah, i got some comments about bad rendering on windows, but i think it was a mistake to move that.
15:26:29 <dons> danderson: i'll work on that tomorrow
15:26:54 <djahandarie> Twey, I like verdana for small text because of the large x-height
15:27:14 <djahandarie> Also that page makes me feel like I shouldn't be taking any typography tips from that person...
15:27:29 <Twey> I know, I know, it's a crappy page, but it makes a valid point
15:27:36 <cads> dons, could the scope of the site include some "getting started" documents, haskell news, and a link to TryHaskell?
15:28:24 <Twey> It's not just a large x-height, it's generally huge
15:28:44 <dons> cads, yes. under the 'Learn more' once I'm done.
15:29:17 <djahandarie> Twey, sure, but the reason I use it is for a large x-height, proportionally -- it makes for easier reading at small font sizes
15:29:24 <dons> btw, there's a snow leopard binary installer there
15:30:52 <chrisdone> dons: is haskell moving away from this colour theme? http://haskellwebnews.files.wordpress.com/2009/12/haskell-logo-variation.png it is my personal favourite colour theme and logo but whatever becomes the "official" haskell theme, I will use that in any haskelly web projects
15:31:13 <Twey> djahandarie: There are fonts with large x-heights that don't have crazily huge point-sizes, like Lucida Bright
15:31:36 <Twey> chrisdone: Green and purple?  :Ã¾
15:31:47 <dons> that's the 2000s
15:31:56 <dons> the old logo
15:32:03 <Twey> It's okay on a logo, with a bunch of gloss, butâ¦ I wouldn't use it for a whole site.  Too much like a migraine.  :Ã¾
15:32:11 <dons> i like cabal's theme more, file:///home/dons/hp/haskell-platform/download-website/new/mac.html
15:32:14 <dons> grr.
15:32:17 <danderson> read: it's totally 20th century, you can't be seen on web 3.0 with it.
15:32:19 <Twey> dons: Useful :Ã¾
15:32:35 <dons> http://hackage.haskell.org/platform/new/mac.html
15:33:04 <chrisdone> well, maybe my sentence was ambiguous. I meant whatever you guys choose, I will use your choice for my projects. it seems the colour theme is changing all the time and I'm waiting for it to stick
15:33:29 <dons> yeah. it's changing since we have zero design people..
15:33:32 <chrisdone> dons: I like that one a lot too
15:33:37 <dons> we need an ubuntu like color makeover :)
15:33:56 <dons> purple is the 'old' haskell. haskell 2010 is all about pink.
15:34:04 <dons> we have the science to show it
15:34:12 <Twey> Haha
15:34:21 <Twey> Purple is a bit retro
15:34:25 <Twey> In general
15:34:26 <dons> 70s
15:34:32 <c_wraith> neon orange?
15:34:40 <dons> isn't lime green back ?
15:35:31 <pokoko222> anyone has see some MIT math courses? i need opinions, i am not satisfied with the calculus ones... professors explain shit
15:35:32 <chrisdone> good designers can make any colour look great, but yeah
15:35:55 <sinelaw> pokoko222 linear algebra with gilbert strang was good.
15:36:27 <pokoko222> yep i liked that one too
15:36:31 <Twey> chrisdone: It can look great, but it's always going to look retro.  :Ã¾
15:36:31 <pokoko222> but calculus sucks bad
15:37:04 <Alpounet> <sinelaw> pokoko222 linear algebra with gilbert strang was good. <<< that's one of the MIT open course ware video right ?
15:37:56 <chrisdone> Twey: what I mean is that good designers are the people who change what is fashionable by making things look great. but what do I know :)
15:38:29 <Twey> Retro can be fashionable ;)
15:38:53 <pokoko222> Alpounet yeah, i am disapointed by the calculus ones i just wanna get opinions from others, it might be just me...
15:39:02 <fax> what
15:39:05 <fax> calculus is great
15:39:15 <fax> you can learn it from a book
15:39:26 <fax> don't need to stinking classes
15:39:27 <chrisdone> Twey: if you insist
15:39:53 <pokoko222> fax yeah i kinda learned more from book then the course, the guy does not explain good acording to me
15:40:16 <cads> I agree with that
15:40:22 <fax> that's the way I would recommend
15:40:32 <fax> you can go at your own pace
15:40:34 <cads> but it' also good to have a professor to talk to and give alternate perspectives, imo
15:40:53 <fax> if you learn calculus in class it probably takes too long in easy bits and skips over difficult things you'd be better thinking about harder
15:41:05 <cads> hmm, that sentence was wrong.. I meant to say that a professor can give you an alternate perspective on the material
15:43:23 <ivanm> dons: was the platform finalised, or not yet?
15:44:19 <danderson> ivanm: not quite yet afaik. Empirically, I'm running the version that's on the site and ghc 6.12 right now, and it's quite happy
15:44:34 <danderson> so it's working, but ISTR it's not final.
15:44:36 <cads> Hey, I was wondering if there is any other language that uses hindley milner type systems which has found more acceptance in industry than haskell. Perhpaps SML? Or is haskell the best choice to master nowadays?
15:44:52 <ivanm> OCaml? F#? *shrug*
15:45:00 <ivanm> hard to tell what has more industry acceptance
15:45:01 <dons> it's beta
15:45:07 <ivanm> (without taking jdh30's word for it :p )
15:45:14 <dons> cads, SML is a dead research project.
15:45:18 <ivanm> so when are we likely to have a proper release?
15:45:24 <fax> cads, ocaml
15:45:28 <danderson> dons: by google standards that would make it 5 years old and battle-hardened. That's why I wasn't sure how to take the qualifier.
15:45:35 <dons> ocaml's dead too.
15:45:37 <dons> danderson: :D
15:45:54 <dons> 5 days vs 5 years. shrug :)
15:46:09 <danderson> "eeeh, it's the same thing, live on the edge!"
15:46:15 <cads> I don't know why I'm afraid to see what F# looks like.
15:46:17 <dons> cads, i think the 'more acceptable for industry' either implies MS supported (e.g. F#), or haskell.
15:46:17 <ivanm> oh, jdh30 only pushes F# now? :p
15:46:23 <danderson> speaking of which, how about I back up those hackathon photos
15:46:26 <dons> ivanm: yeah.
15:46:32 <ivanm> well, it could be argued that Haskell is in part MS supported...
15:46:42 <dons> it is. for more than a decade.
15:46:56 <superoptimizer> is F# much like haskell?
15:46:57 <dons> they also fund DPH.
15:47:06 <dons> superoptimizer: similar, but not that close.
15:47:13 <dons> though some of the libraries are close
15:47:15 <ivanm> oh? didn't knowk that
15:47:17 <ivanm> *know
15:47:17 <dons> they borrow library ideas.
15:47:22 <ivanm> "borrow
15:47:26 <ivanm> " ?
15:47:31 <ivanm> you mean steal, don't you? ;-)
15:47:37 <ivanm> (since I doubt they'll ever return them...)
15:47:42 <pikhq> superoptimizer: F# is more of an ML that works with .Net than anything else.
15:47:47 <superoptimizer> I was thinking about learning that at some point. I work on a Mac at home, though, so I wouldn't be able to do much with it at home.
15:47:54 <superoptimizer> pikhq: Oh, I see.
15:47:57 <danderson> it's hard to steal that which multiplies when taken
15:48:32 <ivanm> pikhq: I thought F# _was_ an ML
15:48:32 <dons> yeah
15:48:57 <cads> "variant of ml, largely compatible with ocaml implementation"
15:49:33 <Alpounet> they just dropped some ocaml features
15:49:52 <nanashi> it IS ocaml
15:50:00 <Alpounet> and added a .NET compliance layer
15:50:02 <nanashi> i mean the tuareg source code base
15:50:09 <cads> so ocaml lives on .net :)
15:50:11 <nanashi> yeah what Alpounet said =)
15:50:17 <nanashi> but it was tuareg (ocaml) source
15:50:41 <tensorpudding> There is a project to get ocaml on the jvm too.
15:51:03 <tensorpudding> No haskell love though.
15:51:08 * nanashi remembers watching some beta of F# compile . it was mostly ocaml source tree
15:51:11 <cads> hm, I wonder whether the TIOBE index reflects at all accurately the volume of actual development work done in the respective languages
15:51:13 <Alpounet> there is a *separate* project to have a parallel-friendly implementation of OCaml =)
15:51:52 <Alpounet> (and by separate I mean really separate, i.e not INRIA-supported)
15:53:12 <cads> oh, tiobe is a search engine based metric http://www.tiobe.com/index.php/content/paperinfo/tpci/tpci_definition.htm
15:53:18 <COOKIE13> Hello
15:53:27 <m3ga> Alpounet: separate parallel ocaml project?
15:53:29 <zeiris> Cabal fails with many hackage packages for me, citing a dependency of base ==4. :( However, the only base-4.0 package depends on things that don't exist, and base-4.1 and above... Require base 3? Or something? halp
15:53:46 <theorbtwo> tiobe is also horribly inaccurate, and should only be used as a joke.
15:53:50 <COOKIE13> I'm going through the Write Yourself a Scheme in 48 Hours tutorial
15:53:58 <chrisdone> COOKIE13: excellent
15:54:00 <COOKIE13> and trying to unit test my code as I go along
15:54:03 <theorbtwo> It simply measures the number of google hits for "foo programming" for various foo.
15:54:09 <COOKIE13> with HUnit
15:54:19 <COOKIE13> except that I can't seem to write this function well:
15:54:27 <COOKIE13> assertParses :: String -> Parser a -> a -> String -> Assertion
15:54:28 <cads> theorbtwo, that makes me feel better
15:54:34 <Alpounet> m3ga, see JOCaml
15:55:05 <m3ga> ah yeah, jocaml. tried that. prefer the DPH approach :-)
15:55:15 <COOKIE13> somehow, the Either baffles me useless
15:55:16 <theorbtwo> It turned out that very few perl programmers used that phrase, so we got low tiobe numbers.  Somebody or another decided to fix that; they stuck the phrase in the footer of a template for all pages on their site, and we gained several places on tiobe.
15:55:27 <Alpounet> m3ga, how comes I'm not surprised :)
15:55:33 <kmc> COOKIE13, any reason you chose HUnit over QuickCheck?
15:55:48 <COOKIE13> a few
15:56:04 <COOKIE13> learning one new concept at a time - haskell is enough to wrap my brain about
15:56:27 <chrisdone> COOKIE13: the Either type returned by Parsec?
15:56:37 <COOKIE13> without needing to grasp how to find nontrivial invariants for my parser that would give good coverage
15:56:44 <COOKIE13> the same
15:57:26 <chrisdone> COOKIE13: so which part confuses you? you can do a case analysis on it to inspect whether it is a `Left error` or `Right success` value
15:57:29 <COOKIE13> I will learn to use QuickCheck one day - although I still cannot imagine using it to test parsers, of all things
15:57:45 <COOKIE13> the part where I do that and my tests never fail
15:57:48 <cads> theorbtwo, that's dreadfully lazy statistics methodology, it seems like
15:57:50 <chrisdone> COOKIE13: actually parsers are one of the best use cases for QuickCheck
15:57:56 <Darkone> Wow.
15:58:00 <theorbtwo> cads: Indeed, it is.
15:58:03 <ivanm> since most parsers are pure
15:58:06 <Darkone> It's alot easier to debug when you're paying attention.
15:58:11 * ivanm points out the test cases he has for graphviz
15:58:27 <danderson> can QC actually be used for impure code?
15:58:27 <cads> ivanm, graphvis test cases?
15:58:36 <danderson> eg. to test properties on network servers
15:58:51 <Darkone> I forgot that when autoamtically constructing a list that goes down, you have to define the first step. [10,9..1] works, but [10..1] is null :X
15:58:55 <cads> ivanm, heh, hook a brother up!
15:58:55 <ivanm> cads: yes, test cases for my printing/parsing of Dot code in the graphviz library
15:58:58 <ivanm> @hackage graphviz
15:58:59 <lambdabot> http://hackage.haskell.org/package/graphviz
15:58:59 <danderson> (I have plenty of pure code to quickcheck as well, but there's more than the usual dose of IO code in such a server)
15:58:59 * theorbtwo hugs the test anything protocol.
15:59:07 <superoptimizer> Darkone: noticed that the other day. ugh
15:59:08 <ivanm> cads: I have two brothers; AFAIK you're neither of them
15:59:24 <ivanm> danderson: don't think so...
15:59:30 <Darkone> I was tearing my hair out over why   myconcat (>5) [10..1] kept returning [] xD
15:59:31 <ivanm> since it has to eventually return True
15:59:33 <Darkone> superoptimizer, I know D:
15:59:37 <ivanm> s/True/a Bool/
15:59:42 <danderson> yeah
15:59:49 <m3ga> Alpounet: i thought you may have been talking about the flying frog effort (which is in its very early days and I suspect will go nowhere)
15:59:51 <chrisdone> COOKIE13: you'll have to describe your problem in more detail. feel free to paste your code on http://hpaste.org to display hard to talk about code
15:59:56 <COOKIE13> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24229#a24230
15:59:57 <danderson> I wonder what sort of testing I should be applying to network code
16:00:10 <theorbtwo> QC is a lovely idea, TAP isn't really saving the same problem -- but TAP does solve a very useful problem.
16:00:19 <Alpounet> m3ga, I have been contributing it actually
16:00:21 <danderson> I guess just spin up a couple of copies of the code talking to each other, and after a while stop the world and sanity check
16:00:25 <Alpounet> in its very very early stages
16:00:55 <COOKIE13> I'd love to hear about how to TDD my parser with QC
16:00:56 <COOKIE13> but first
16:01:01 <Alpounet> and then dons told me via twitter my time would be better spent working on Haskell/GHC stuffs
16:01:03 <COOKIE13> I'd prefer to get my code working
16:01:08 <m3ga> how do you find working with him? he seems to annoy most people who he deals with.
16:01:13 <chrisdone> so at zurihac I brought up whether quickcheck should be in a separate test module or whether quickcheck properties should be coupled with the functions they are specified for. what do you guys think?
16:01:56 <ivanm> theorbtwo: what's TAP?
16:01:58 <kmc> danderson, you can model your protocol, sniff interactions and test them against the model
16:02:15 <m3ga> Alpounet: how do you find working with him? he seems to annoy most people who he deals with.
16:02:28 <theorbtwo> ivanm: It's a specification for the interface between tests and a test harness that runs the tests, and collects the results.
16:02:40 <ivanm> in Haskell?
16:02:50 <COOKIE13> in ascii
16:02:59 <COOKIE13> originally from the perl world
16:03:03 <ivanm> aha
16:03:14 <theorbtwo> It's nicely language agnostic, which means that you can have a common harness running tests from various components in different languages.
16:03:20 <danderson> kmc: there isn't much protocol, and what little of it there is can be tested more directly by quickchecking the internal state machine
16:03:22 <chrisdone> COOKIE13: so it looks like your assertPassess function is OK from here. are you sure that your parser is correct?
16:03:43 <danderson> actually, the state machine for the protocol is pure and can be quickchecked, as can the binary parsers/serializers for the protocol
16:03:46 <COOKIE13> I am sure my parser is wrong
16:03:51 <danderson> it's more the integration level tests that bother me
16:03:54 <COOKIE13> I crippled it to try and make the tests fail
16:03:57 <COOKIE13> they still passed
16:04:02 <danderson> ie. making sure that everything is wired together
16:04:14 <theorbtwo> Run test, output "ok 1 testname\n" or "not ok 1 testname\n".  Simple to implement in pretty well any language.
16:04:20 <zeiris> Can I define binary numbers via \b0101011 or something?
16:04:40 <theorbtwo> (I'm simplifying for ease of discussion, but only very slightly.)
16:05:03 <Alpounet> m3ga, he's trolling most of the time
16:05:13 <ivanm> zeiris: I think I once found something on how to define binary numbers...
16:05:16 <ivanm> but can't recall how :s
16:05:19 <COOKIE13> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24229#a24231
16:05:20 <Alpounet> but he explained me some stuffs
16:05:21 <Alpounet> etc
16:05:29 <COOKIE13> I put the whole code there, to simplify discussion
16:05:34 <Alpounet> not the best "opensource coworker" I had, but he is really fine
16:05:39 <m3ga> Alpounet: yeah hes trolling. but its pointless and stupid
16:05:44 <Alpounet> yeah
16:05:54 <Alpounet> it's different when working on a project with him
16:05:58 <Alpounet> but well...
16:06:03 <m3ga> i would hope so
16:06:04 <chrisdone> COOKIE13: ok let me look at it
16:06:11 <Alpounet> Now I don't regret of getting interested in GHC
16:06:13 <COOKIE13> thanks a lot
16:06:15 <Alpounet> -of
16:06:54 <m3ga> yeah, i start with ocaml in 2004 and i;m slowly transitioning to haskell
16:07:13 <Alpounet> m3ga, didn't you have a blog or whatever ?
16:07:20 <Alpounet> your nickname sounds 'familiar'
16:07:43 <m3ga> yeah, still do :-) http://www.mega-nerd.com/erikd/Blog/
16:08:25 <m3ga> my main toy project atm is the DDC compiler
16:08:28 <danderson> speaking of blogs: suggestions for blog software that can colorize (or at least not mess up htmlized) haskell code?
16:08:28 <Alpounet> ahhh
16:08:33 <Alpounet> yeah
16:08:44 <chrisdone> COOKIE13: ok, so the test is perfectly fine. I've tested this. but your parser isn't signalling an error, which indicates that it's not strict or not broken enough
16:08:51 <chrisdone> COOKIE13: try replacing parseAtomâb
16:08:51 <Alpounet> m3ga, I have seen you "transitioning" from debian ocaml to debian haskell actually =)
16:09:03 <chrisdone> COOKIE13: sorry, I'm not used to typing on a mac
16:09:26 <chrisdone> COOKIE13: try replacing parseAtom with (fail "this parse failed") -- which is Parsec's way of signalling a parse error explicitly
16:09:41 <m3ga> i'm really pleased with the way the debian haskell packagining has improved over the last year or so. tremendous progress
16:09:48 <Alpounet> heh
16:09:55 * Alpounet switched to arch during that time
16:10:06 <m3ga> you be back :-)
16:10:34 <COOKIE13> this worked to get a failure
16:10:36 <chrisdone> COOKIE13: you should get something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24229#a24232
16:10:59 <danderson> dons: btw, http://bitbucket.org/danderson/tunskell/ is the codebase for tunskell, if one day you feel bored with coding and want to do code reviews
16:11:09 <COOKIE13> but it still does not explain why Haskell decides that things match when they don't
16:11:22 <m3ga> for me debian (or ubuntu) is the only sane solution. i have production code that gets built in a couple of different build bots. having the compilers and libs as binary packages is the only thing that makes sense.
16:11:42 <COOKIE13> I mean, my asserts get an "expected" parameter
16:11:51 <COOKIE13> they should fail even if the parser isn't strict
16:12:22 <chrisdone> COOKIE13: what do you mean? your unit test code is spot on, it's the parser that's too lenient, it gobbles anything
16:12:44 <chrisdone> let me re-read it
16:12:56 <COOKIE13> how about the number parser? that one is cripled to always return 0
16:13:12 <chrisdone> ok let me look
16:13:14 <COOKIE13> why do tests involving it succeed?
16:14:00 <Alpounet> m3ga, I actually like quite much both debian and arch... But I just prefer arch for a desktop usage.
16:15:21 <m3ga> i need the uniformity. i use ubuntu at work and a mix of debian/ubuntu at home. its all very similar.
16:15:31 <dons> danderson: i got it :) already passed the url onto bos.
16:16:02 <dons> danderson: btw, i was thinking of this http://hackage.haskell.org/package/Scurry
16:16:05 <chrisdone> COOKIE13: I've never used hunit -- are you supposed to give TestCase an action which runs many tests? it seems like you should use TestList for that?
16:16:21 <COOKIE13> it uses an IO monad
16:16:26 <chrisdone> mhm
16:16:33 <COOKIE13> and you're allowed to give it a few asserts
16:16:41 <COOKIE13> so I figured mapM should be fine
16:16:53 <danderson> dons: bos will cry at how bad the code is, seriously :)
16:17:27 <danderson> he already owes me a code review explaining why my patch to attoparsec sucks, when he has the time.
16:18:17 <danderson> dons: scurry looks cool. Fortunatel, it seems that we completely accidentally implemented almost completely non-overlapping features
16:18:26 <shapr> chrisdone: Yes, TestList
16:18:35 <dons> :)
16:18:38 <danderson> I
16:18:47 <dons> scurry was before attoparsec days too
16:19:09 <danderson> I'll certainly be stealing the STUN code (especially since I happen to know of an open stun resolver sitting on the internet at a highly available location, so yay free NAT traversal)
16:19:36 <Darkone> Can you view a function in GHCi? Like, a command that takes a function and prints the source?
16:19:46 <Darkone> Or do you have to look it up?
16:19:48 * shapr hugs dons 
16:20:14 <danderson> dons: it does look like we converged on the rest of the technology though, other than parsec vs. attoparsec
16:20:21 <kmc> Darkone, no
16:20:34 <ivanm> dons: with the hackathon, why where there so few releases? last hackathon you could barely turn around for all the ANNOUNCE messages on the mailing list (of course, half of them were for you announcing yet another judy release... :p )
16:20:41 <danderson> ooh, it also has win32 tun/tap code. Excellent.
16:21:07 <kmc> Darkone, lambdabot has @src, but that's just a lookup in a fixed database
16:21:27 <Darkone> Yea, it's a builtin. 'groupBy'
16:21:28 <chrisdone> COOKIE13: okay so assertNumberMatches uses assertParses, which in turn just checks that it parses. at no point does it test for equality. I believe this is why all the tests you're trying that you expect to fail are succeeding. because it's not actually checking that (1,"1"), for example, are parsing to be the same
16:21:35 <kmc> Darkone, hoogle will find that for you in the standard library docs
16:21:38 <kmc> which have source links
16:21:44 <COOKIE13> but it does!
16:21:49 <chrisdone> COOKIE13: where?
16:21:55 <COOKIE13> with the pattern matching of "Right expected"!
16:21:58 <COOKIE13> or is it?
16:22:15 <chrisdone> COOKIE13: no, that binds a new variable called `expected`. it doesn't test for equality
16:22:20 <dons> ivanm: mostly people just upload to hackage now
16:22:26 <chrisdone> COOKIE13: maybe that is where the confusion lies
16:22:39 <ivanm> dons: without announcements? :(
16:22:42 <COOKIE13> definitely is
16:22:46 <chrisdone> COOKIE13: try something more like Right result | result == expected -> return ()
16:22:53 <COOKIE13> thanks
16:22:58 <dons> ivanm: right. check the hackage logs -- heaps of stuff today and yesterday
16:23:01 <chrisdone> COOKIE13: (or a more appropriate variable name, hehe)
16:23:13 <ivanm> yeah, I'm already looking
16:23:30 <COOKIE13> (fail "this parse failed")
16:23:34 <COOKIE13> woops
16:23:41 <ivanm> hmmm, the hackage logs don't list that many...
16:23:52 <COOKIE13> "Could not deduce (Eq a) from the context"
16:24:12 <COOKIE13> where a is LispValue
16:24:17 <ivanm> then add it!
16:24:22 <COOKIE13> how do I define an Eq behavior?
16:24:34 <chrisdone> COOKIE13: mhm, that's because your functions just refer to an `a' type -- there's no constraint that the `a' type be an instance of Eq, so you add that on the type signature
16:24:35 <zeiris> @pl f c = (b.&.c)==c
16:24:36 <lambdabot> f = (==) =<< (b .&.)
16:24:37 <Twey> deriving (Eq)
16:24:44 <chrisdone> assertParses :: Eq a => String -> Parser a -> a -> String -> Assertion
16:24:58 <COOKIE13> but LispValue isn't an Eq instance
16:25:03 <zeiris> :t =<<
16:25:04 <lambdabot> parse error on input `=<<'
16:25:28 <chrisdone> COOKIE13: but you will want to test for equality on them, right?
16:25:28 <jmcarthur> :t (=<<)
16:25:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:25:40 <chrisdone> COOKIE13: for these tests?
16:26:37 <COOKIE13> <COOKIE13> how do I define an Eq behavior?
16:26:54 <fax> instance Eq Ghoul where
16:26:58 <fax>  _ == _ = False
16:27:14 <ivanm> fax: no pair of ghouls are alike? ;-)
16:27:15 <chrisdone> COOKIE13: for your code you can just put `deriving Eq` on the line below your data declaration
16:29:41 <chrisdone> COOKIE13: did you sort it out?
16:30:29 <ivanm> whilst you're at it, derive everything you can that makes sense
16:30:41 <ivanm> e.g. "deriving (Eq, Ord, Show, Read)", etc.
16:30:51 <ivanm> s/e.g./i.e./
16:30:52 <COOKIE13> thanks a lot
16:30:54 <COOKIE13> it works
16:30:58 <COOKIE13> now, sleep
16:30:59 <COOKIE13> gn
16:31:01 <COOKIE13> thanks again
16:31:42 <superoptimizer> I haven't been paying attention - is the Haskell patch going to make it into LLVM 2.7?
16:31:56 <superoptimizer> And has the associated code for ghc been submitted yet?
16:32:25 <ivanm> superoptimizer: I think it has (for both)
16:32:32 <ivanm> but IIRC the GHC patch hasn't been applied yet
16:33:07 <superoptimizer> I know the LLVM patch went in, but after the 2.7 deadline, with the hopes that it would get pulled into 2.7 anyway, but I'm not sure if that happened.
16:33:32 <pikhq> I thought they'd gotten it pulled into 2.7.
16:33:45 <ivanm> superoptimizer: http://pls.posterous.com/status-update-on-the-llvm-backend-for-ghc
16:33:45 <c_wraith> http://pls.posterous.com/status-update-on-the-llvm-backend-for-ghc
16:33:48 <ivanm> TacticalGrace says it's in
16:34:51 <superoptimizer> Excellent. I've been working with LLVM for a while and am hoping to study ghc and LLVM to improve my understanding of Haskell
16:34:52 <ivanm> and david terei is going to be doing an internship at MSR in cambridge to tidy up the GHC patch
16:35:13 <chrisdone> ivanm: wow great!!
16:35:17 <ivanm> superoptimizer: I don't think by looking at the generated LLVM code that you'll understand haskell any better ;-)
16:35:27 <ivanm> since it would have been mangled quite a bit by the time it got there
16:35:45 <ivanm> chrisdone: yeah, that's why he can't come to AusHack :(
16:36:04 <superoptimizer> ivanm: In a sense I think I will. I'm very interested in how Haskell is compiled into machine code.
16:36:33 <superoptimizer> It might not help with basic understanding of Haskell, but perhaps in 6 months once I understand enough I'll get a deeper understanding of how things actually work.
16:36:35 <pikhq> superoptimizer: It is done so in such a way that you cannot recognise the code when it's done.
16:36:38 <ivanm> superoptimizer: first GHC converts it to core, then it converts it to C, then uses the C bindings to LLVM
16:36:49 <ivanm> and there's heaps of mangling done in between as well
16:37:12 <pikhq> ivanm: There is no C involved.
16:37:19 <superoptimizer> Okay, then perhaps the LLVM part isn't that interesting, although I'm familiar with LLVM so I was hoping that knowledge would be leveraged in some way.
16:37:30 <ivanm> pikhq: you sure?  pretty sure someone told me that it went via C
16:37:40 <ivanm> but they're working on binding to LLVM directly to avoid C
16:37:42 <pikhq> GHC converts it to Core, does optimisations, converts it to STG, does optimisations, converts it to C--, does optimisations, converts it to LLVM, then does optimisations.
16:37:42 <Alpounet> ivanm, Cmm
16:37:48 <ivanm> oh, right
16:37:50 <pikhq> The above is the LLVM compilation path.
16:37:54 <ivanm> C--, C, same diff!
16:38:02 <superoptimizer> What are Core and STG? and C--?
16:38:03 <pikhq> Erm. Sorry, there are no optimisations between C-- and LLVM.
16:38:17 <ivanm> superoptimizer: Core is a sub-FP language that GHC uses for optimisation purposes
16:38:27 <ivanm> STG is the State something Graph? *shrug*
16:38:30 <ivanm> @where STG
16:38:30 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
16:38:33 <Alpounet> superoptimizer, you better focus on Haskell rather than the intermediate languages GHC uses heh
16:38:35 <ivanm> superoptimizer: ^^
16:38:37 <pikhq> superoptimizer: Core is *essentially* a desugared Haskell.
16:38:51 <ivanm> Core is only of interest for profiling, etc.
16:38:58 <pikhq> STG is a graph reduction machine.
16:39:19 <pikhq> And C-- is a C-like language meant to be used as a code generation target.
16:39:26 <superoptimizer> I see.
16:39:53 <ddarius> STG = Spineless Tagless G-machine.
16:41:44 <systemfault> When should I use case expressions instead of regular pattern matching?
16:41:58 <mwc> systemfault: when you need an expression and not a declaration ;)
16:42:54 <ivanm> systemfault: when you're case-ing on the result of a function or something
16:42:58 <ivanm> or within a do-block
16:43:04 <kmc> systemfault, case *is* the simplest form of regular pattern matching
16:43:12 <kmc> systemfault, the others (e.g. multiple function equations) desugar via case
16:43:30 <ivanm> I've also used case where I wanted a common where clause rather than defining a separate function (but I didn't case on the whole value, just one part of it)
16:43:46 <ivanm> kmc: you mean desugar _to_ case?
16:43:56 <kmc> yeah
16:43:57 <systemfault> Ah ok :)
16:44:33 <kmc> since the others are sugar, i think it's just a question of what's most readable
16:44:36 <systemfault> I had in mind that case is to pattern matching what   ?: is to a normal  "if" in C-ish languages
16:45:09 * ddarius almost never uses case, let, or lambda.
16:45:38 <ivanm> I only use let in do-blocks
16:45:41 <kmc> case is *also* the primitive for forcing evaluation
16:45:47 <ivanm> lambda very rarely; I prefer point-free notation
16:45:54 <ivanm> but sometims the lambda form is cleaner
16:45:55 <ddarius> kmc: Not in Haskell itself.
16:45:59 <ivanm> kmc: :o
16:45:59 <kmc> yeah
16:46:03 <ivanm> oh, in Core?
16:46:06 <kmc> it is in Core and STG
16:46:11 <kmc> the situation is more complicated in Haskell
16:46:27 <systemfault> kmc: I'm too noob to understand strictness/laziness correctly :(
16:46:35 <kmc> systemfault, don't worry about it then
16:46:54 <kmc> the nice thing about non-strict evaluation is that any term which evaluates properly with strict evaluation will also evaluate non-strictly
16:47:10 <systemfault> kmc: I understand that I must make my recurse functions tail-recursive to avoid killing the stack..
16:47:16 <systemfault> That's about it
16:47:22 <kmc> systemfault, that's the case in a strict language
16:47:22 <systemfault> *recursive
16:47:34 <kmc> with lazy evaluation the meaning of "tail recursive" is more complicated
16:48:06 <ivanm> Haskell doesn't really have TCO
16:48:09 <ivanm> since it doesn't need it
16:48:14 <ivanm> yay for laziness!
16:48:38 <mreh> does anyone have an ideas of how to implement the ray casting algorithm
16:49:01 <ddarius> ivanm: Yes it does (where "it" is all implementations) and yes it does need it.
16:49:08 <mreh> easy enough to do the line intersection
16:49:10 <ivanm> :o
16:49:18 <ivanm> ddarius: I'm pretty sure I've read that it doesn't have TCO...
16:49:20 <kmc> say h = (g . f), i.e functions f and g composed.  in a strict language (h x) will evaluate (f x) entirely, then apply g to that, and so you care that f be tail recursive so it can finish without blowing the stack
16:49:21 <ivanm> @google haskell tco
16:49:22 <lambdabot> No Result Found.
16:49:23 <mreh> but not a segment that is infinitely long at one end
16:49:41 <kmc> with non-strict semantics, (g . f) is a sort of pipeline or co-routine between the two functions, which trade off control back and forth
16:49:51 <ddarius> ivanm: The standard does not specify that TCO will be performed, but all implementations do it and all sane implementations will need to do it.
16:49:53 <kmc> and so you care that f be "productive" in the sense of feeding data to g which can be used and discarded
16:50:07 <ivanm> ddarius: hmmm...
16:50:55 <kmc> so e.g. «ones = 1 : ones» is clearly not tail-recursive (indeed, it's not a function).  but «ones !! 100000» will not blow the stack, because each «1:» is "eaten" by (!!) before more are produced
16:51:05 <kmc> > let ones = 1 : ones in ones !! 1000000
16:51:06 <lambdabot>   1
16:52:04 <ddarius> kmc: That's not a matter of stack.  The stack would come into the definitiono of (!!).  Further, ones could take arbitrarily large amounts of memory (though not stack) if it doesn't get shared.
16:52:12 * ivanm just came across http://flyingfrogblog.blogspot.com/2009/04/another-serious-bug-in-ghc.html
16:52:15 <kmc> true
16:52:22 <kmc> but sharing is guaranteed, isn't it?
16:52:26 <kmc> @src (!!)
16:52:27 <lambdabot> xs     !! n | n < 0 = undefined
16:52:27 <lambdabot> []     !! _         = undefined
16:52:27 <lambdabot> (x:_)  !! 0         = x
16:52:27 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:52:30 <ivanm> funny, for "one of the only industrial users of haskell", I've never heard of nazooka before...
16:52:38 <ddarius> kmc: No.  The standard says absolutely nothing about sharing one way or the other.
16:53:55 <mreh> kmc: nice reply from dons
16:54:07 <ddarius> The standard is almost completely silent on operational issues.
16:54:15 <kmc> so you can't portably write efficient Haskell programs?
16:54:28 <mreh> ivanm, not kmc
16:54:33 <ddarius> kmc: Correct.  And data-memocombinators relies on behavior that isn't guaranteed.
16:54:37 <kmc> :(
16:54:40 <ivanm> yeah
16:56:14 <ddarius> Since TCO isn't guaranteed.  Almost no non-trivial programs have guaranteed good stack space usage.
16:56:51 <ddarius> E.g. there is no definition of length that is guaranteed not to take O(n) space.
16:57:11 <Darkone> ivanm, heh, I love the replies.
16:57:11 <twink> A subtle FFI bug in ghc destroyed darcs? When was this?
16:59:29 <dons> ivanm: don't feed the troll
16:59:34 <ivanm> ddarius: this is what I was thinking of: http://www.haskell.org/haskellwiki/Tail_recursion
16:59:41 <ivanm> dons: which troll?
16:59:58 <ivanm> I found that whilst looking for haskell and tail recursion and just found it humerous
17:00:17 <gwern> hm. the darcs thing was probably the 6.8 performance issue
17:00:20 <dons> scary that you find stuff like that. via google?
17:01:52 <Darkone> I love how the guys he 'quotes' basically say that they're going to use haskell because of the nice, helpful, and prompt community ;)
17:02:06 <ddarius> ivanm: The usual syntactic criterion for tail calls is not as definitive for performance as it is in strict languages, but it's still important.  Just look at the definition of (!!) above.  It is tail recursive and relies on TCO to not take up stack.
17:02:17 <ivanm> ddarius: *nod*
17:02:25 <ivanm> dons: yup
17:02:37 <dankna> this really is a nice community
17:02:52 <dankna> I don't think I've ever once failed to get help when I had a real problem
17:03:15 <Darkone> I know. Everyone puts up with my silly questions, and explains it all :D
17:03:22 <dons> ok, it's live now: http://hackage.haskell.org/platform/
17:03:29 <gwern> dons: you should've pointed out all the stuff on hackage using via reverse deps the ffi without a problem
17:03:57 <dankna> dons: oh - are you the maintainer of Haskell Platform?
17:04:06 <dons> dankna: yeah
17:04:13 <dons> btw, ghc  6.12 + snow leopard + 64 bit
17:04:15 <dankna> ah, I didn't realize
17:04:17 <dons> ready. in binary form.
17:04:20 <dankna> sweeeeeet
17:04:25 <dankna> I may have to switch to that then
17:04:37 <dankna> although not today because I only just got everything set up the way I like it with 32-bit, haha
17:04:50 <dons> gwern: note the 'Problems?' link goes to the wiki. that's where all our FAQ and troubleshooting can go
17:04:58 <dons> gwern: since it was such a success for xmonad
17:05:07 <gwern> dons: the xmonad faq you mean?
17:05:07 <dons> but maybe you can help there too :)
17:05:18 <dons> yes, in general, haskell wiki for collecting project notes
17:05:23 <systemfault> dons: Where?
17:05:33 <systemfault> dons: Your link doesn't have it..
17:05:34 <dons> http://hackage.haskell.org/platform/
17:05:39 <gwern> '{-# LANGUAGE PackageImports #-}
17:05:39 <gwern> import "mtl" Control.Monad.Trans
17:05:42 <gwern> zomgwtf
17:05:43 <ivanm> dons: \o/
17:05:46 <dankna> btw, a suggestion.  I'm impressed by the binary installer.  so impressed that I tried to build it once and couldn't find directions anywhere.  you may have already remedied that, dunno.
17:05:47 <gwern> since when did we have that?
17:05:52 <ivanm> gwern: used by GHC for naughty internal stuff
17:05:59 <luite> dons: ooh great, looks nice too. any idea when the windows installer will be ready?
17:05:59 <dankna> gwern: hey, I didn't know that.  neat.
17:06:06 <dons> later this week.
17:06:11 <dons> its still on the 6.10.4 installer.
17:06:16 <dons> refold is the guy
17:06:17 <gwern> ivanm: no kidding. it breaks the package abstraction all hollow
17:06:17 <ivanm> dons: who did the website?
17:06:19 <dons> but haven't heard from him.
17:06:29 <dons> ivanm: chr1s and me
17:06:38 <dons> with help from googlers
17:06:42 <ivanm> very nice
17:06:47 <gwern> googlers?
17:06:48 <systemfault> dons: F.... nice! No more hack
17:07:03 <ivanm> dons: may I suggest a link to the source tarball on the front as well for people who want it from other OSs?
17:07:06 <ivanm> (BSD, etc.)
17:07:24 <luite> I hope the gtk2hs guys will now release a windows installer that works with 6.12...
17:07:56 <ivanm> luite: that is apparently why they haven't done a new 6.12 compatible release
17:08:06 <dons> ivanm: mmm
17:08:11 <ivanm> no-one has stepped forward to make and test a windows version yet :s
17:08:26 <luite> ivanm: I've tried to build it, but didn't succeed
17:08:45 <ivanm> dons: e.g. similar to what AMSN does: http://www.amsn-project.net/download.php
17:09:14 <dons> good idea
17:09:21 * dons updates todos
17:10:15 <dons> can someone make me a 'Try Haskell' javascript widget/button for people to put on their site?
17:10:21 <dons> that points to the platform?
17:10:28 <ivanm> dons: so packagers should fire away now?
17:10:44 <ivanm> heh, I thought you meant a "Try Haskell" widget to link to tryhaskell.org ... ;-)
17:11:14 <systemfault> dons:
17:11:17 <systemfault> Err sorry
17:11:39 <dons> ivanm, yep. fire up the distros.
17:11:49 <dons> there'll be a follow-up with 6.12.2
17:11:50 <siracusa> dons: Is there no summary what version of each package is included, as in the last version of the platform?
17:11:58 <dons> siracusa: click 'Learn more'
17:12:05 <dons> that will be a full overview once i'm done
17:12:23 * ivanm will do it tonight if kolmodin and trofi don't do it first
17:12:31 <siracusa> dons: and then?
17:12:47 <dons> siracusa: well, it will be better :) currently it's just a listing of the contents
17:13:03 <siracusa> dons: Ah ok
17:14:13 <ivanm> dons: is HP still just GHC + extralibs + cabal-install ?
17:14:21 <ivanm> or have you started getting other packages in there as well?
17:14:28 <ivanm> dons: and why is editline still there?
17:14:44 <ivanm> IMHO inclusion of editline should no longer be needed since GHC uses haseline
17:14:47 <ivanm> *haskeline
17:14:55 <Darkone> dons, has the windows one still 6.10.4, or is it 6.12.x, and just named the same as the last one?
17:15:04 <Darkone> s/has/is
17:15:35 <ivanm> Darkone: windows installer hasn't been updated yet
17:15:40 <Darkone> Kk
17:15:46 <Darkone> Thanks, ivanm.
17:15:59 <dons> ivanm: oh, its not there.
17:16:03 <dons> the contents is out of date.
17:16:20 <ivanm> dons: oh, and you might want to fix up the description under "Languages": haskell-src provides Haskell98 language parsing and pretty printing, not "new" Haskell ;-)
17:16:23 <ivanm> \o/
17:16:43 <dons> yeah, don't look at contents.html yet. its my last task
17:16:57 <dons> try out the mac installer and let us know
17:17:11 <dons> anyone interested in making widgets/buttons?
17:18:03 <ivanm> dons: is the .cabal file available anywhere (to simplify package generation)?
17:18:45 <dons> yeah, in the code.haskell.org/haskell-platform repo
17:18:53 <ivanm> *nod*
17:18:54 <dons> developer stuff is still on the trac as always
17:19:02 <ivanm> there's a trac? :o
17:21:14 <Landmine> So I have a quick questions, that could use a clever answer.
17:21:24 <Landmine> Any takers?
17:21:38 <ivanm> don't ask to ask ;-)
17:21:43 <Landmine> lol
17:21:45 <Landmine> Alright
17:21:55 <systemfault> When you just upgraded ghc, I guess you need to upgrade cabal packages, right? Is there an easy command for that?
17:22:03 <fax> Landmine what is ti??
17:22:50 <dons> systemfault: not yet.
17:22:54 <dankna> systemfault - no particularly easy way.
17:22:56 <dons> you have to manually cabal install each one.
17:22:57 <systemfault> Ah ok
17:22:59 <dons> well, the list
17:23:02 <Landmine> Basically, I program mostly in Visual Studio, but other IDE's and I'm trying to come up with the best way, an a minimal way, to work on projects and have them be accessible from any of my 3 work locations
17:23:14 <dons> and you can extract the old list with: ghc-pkg list --simple
17:23:20 <dons> then use that to pass to cabal-install afterwards
17:23:25 <dons> though versions will change
17:23:28 <dons> so you have to ignore those
17:23:32 <dankna> Landmine: you need distributed version control of some sort.  the one I recommend is darcs.
17:23:42 <systemfault> dons: Ah ok :) Thanks
17:23:43 <ivanm> systemfault: nope
17:23:52 <ivanm> which is why you should use distro packages where possible!
17:23:52 <dankna> http://google.com/search?q=darcs+features&btnI=z
17:23:58 <ivanm> *cough* haskell-updater *cough*
17:24:00 <systemfault> ivanm: I'm on osx
17:24:06 <Landmine> I'm thinking DropBox with could be a good answer
17:24:15 <Landmine> Darcs, really? I've never heard of it
17:24:23 <ivanm> systemfault: gentoo-prefix? :p
17:24:27 <ivanm> @where darcs
17:24:27 <lambdabot> http://darcs.net/
17:24:30 <ivanm> @where camp
17:24:30 <lambdabot> http://projects.haskell.org/camp/
17:24:36 <dankna> the thing with a dropbox is that you'll be forever overwriting your changes and losing stuff
17:24:40 <ivanm> Landmine: ^^ have a look at the video on the camp website
17:24:42 <dankna> or forgetting to obtain the latest version
17:24:46 <ivanm> (camp is the future successor to darcs)
17:25:14 <Landmine> Looking at the camp site now
17:25:34 <dankna> incidentally, does anybody have a good explanation of what functionality exactly darcs gets that git doesn't, by virtue of the fact that darcs patches can commute and git ones can't?
17:25:59 <dankna> oh, haha, http://wiki.darcs.net/DifferencesFromOtherDVCS
17:26:03 <ivanm> dankna: there's a vs page on the darcs site
17:26:03 <dankna> never mind :D
17:26:04 <Landmine> Interesting
17:26:05 <ivanm> yeah, that one
17:26:13 <Landmine> Let me toss this into the mix as well.
17:26:15 <ivanm> dankna: IIRC, the summary is easier/better cherrypicking
17:26:54 <dankna> hmm yes, I see
17:27:10 <Landmine> I have a dedicated web server with more than enough space to hold all of my projects, should I store them in the cloud? Right now, I'm using SVN for my important projects, but it would be nice to not have to do extra steps to have my projects added to a "shared folder" basically.
17:27:23 <ivanm> @where patch-tag
17:27:23 <lambdabot> I know nothing about patch-tag.
17:27:28 <ivanm> @google patch-tag
17:27:29 <lambdabot> http://patch-tag.com/
17:27:29 <lambdabot> Title: Darcs Hosting: Patch-Tag.com
17:27:43 <ivanm> Landmine: ^^ darcs equivalent of github; currently only public repos atm however
17:29:07 <Landmine> Why would I move from svn and my tortoisesvn to darcs?
17:29:58 <dankna> well, there's a couple major differences - really the darcs site already tells you about them, but,
17:30:22 <dankna> svn is version-of-file based; darcs is change-based
17:31:01 <dons> Landmine: darcs is a lot simpler to use.
17:31:36 <Landmine> I like simple :)
17:31:39 <dons> shapr: whaddya think? http://hackage.haskell.org/platform/
17:33:15 <Landmine> It looks like Darcs is all command line?
17:33:53 <ivanm> yes
17:33:58 <dankna> that is true.  I have a 30%-finished Mac OS X GUI to it that I'm implementing in my copious free time.
17:34:03 <ivanm> well, some editors have support for it
17:34:10 <ivanm> dankna: sarcasm intended?
17:34:16 <dankna> yes.
17:34:25 <dankna> I have no free time, because I'm self-employed.
17:34:33 <dankna> irony intended, too :)
17:34:36 <Landmine> I'm self-employed as well
17:34:50 <Landmine> For the time being, it will be interesting to see how the politics play out tonight
17:35:01 <dankna> ugh, don't get me started on it, but yeah
17:35:15 <Landmine> Sorry to bring up a bad subject
17:35:26 <dankna> shrug
17:35:46 <ivanm> huh?
17:35:49 <dankna> we're all adults, we can talk politics if we want, but I suspect it might be wise to take it elsewhere.  anyway I don't particularly want to at this moment :)
17:36:03 <ivanm> the elections in SA and Tasmania were on Saturday, not tonight...
17:36:03 <Landmine> So Dankna, what do you use? Darcs or SVN? Sorry if you've said, I've been trying to get an idea of who is who
17:36:04 <ivanm> :p
17:36:12 <dankna> Landmine: I'm a huge Darcs fan
17:36:22 <ivanm> Landmine: most people here use either Darcs with a growing minority of git
17:36:29 <dankna> I didn't specify why it would be wise to take it elsewhere, haha
17:36:32 <ivanm> darcs is written in haskell, so we have a vested interest in using it :p
17:36:41 <dankna> the large quantity of non-USAians is a big reason though
17:36:57 <Landmine> haha interesting
17:37:31 <Landmine> Well thank you all for your time, I've got to drive to my girl friends and jump on my laptop, and hopefully I'll be back in here to chat more about this.
17:37:40 <Landmine> Thanks again and have a good rest of your weekend.
17:37:42 <dankna> okay, sure thing
17:38:00 <dankna> someday I really do have to finish Cocoa Darcs
17:38:03 <dankna> it would be so handy
17:38:05 <jmcarthur> ivanm: patch tag has private repos
17:38:24 <jmcarthur> ivanm: they just haven't monetized it yet
17:38:29 <ivanm> jmcarthur: they do? last time I visited the site they said they were working on it still
17:38:43 <jmcarthur> ivanm: i have a few private repos on there
17:38:47 <choffstein> Hey all, I have a quick question.  I need to perform an iteration ~1,000,000x.  My first thought, of course, is recursion.  The issue is that in each iteration, I have to update a table -- so when I do recursion, I end up absolutely SLAMMING the stack.  Is there a better way to do this?
17:38:56 <ivanm> jmcarthur: hmmm...
17:39:01 * ivanm has an account, but has never used it
17:39:15 <ivanm> choffstein: use some forcing
17:39:16 <necroforest> choffstein, tail recursion?
17:39:24 <choffstein> forcing?
17:39:25 <ivanm> best way is to have a ! in whatever data type you're passing around
17:39:35 <ivanm> or use seq, etc.
17:39:39 <danderson> choffstein: force Haskell to evaluate what you're passing around
17:39:44 <dankna> wow do I feel lame, I was about to suggest mapM_ (\_ -> ...) [1..10000000]
17:39:45 <necroforest> oh i see... the table's immutable, so you're making copies
17:40:01 <danderson> otherwise it'll lazily construct a giant chain of stuff and evaluate right at the end when it needs to
17:40:11 <choffstein> necroforest: right.  And since I am doing recursion, the garbage collector doesn't seem to be marking the old data as unused
17:40:25 <jmcarthur> choffstein: that's not the problem
17:40:35 <choffstein> Well, then I am an idiot.
17:40:37 <jmcarthur> choffstein: the problem is that you are building a chain of thunks and not evaluating until the end
17:41:08 <danderson> choffstein: you seem to think that on each pass through the function, haskell is actually updating the table
17:41:22 <dankna> IOArrays are relevant to this too
17:41:37 <danderson> but it's not. It's storing a thunk that remembers how to construct the new table with the old one, so that it can evaluate it later, when it needs it
17:41:49 <dankna> I think the strictness answer is probably the fastest easiest solution
17:41:56 <danderson> then, through the next iteration, that thunk becomes part of a larger thunk
17:41:58 <danderson> and so on and so forth
17:42:02 <Darkone> Hey, I can help explain this
17:42:03 <dankna> but making it an IOArray might also work, depending on what he's doing
17:42:30 <danderson> only when the result is actually needed (eg. you print it, or otherwise force its evaluation) does haskell actually collapse all the thunks into a real value
17:42:37 <choffstein> danderson: ahhh, interesting.
17:42:44 <choffstein> so how do I force it to evaluate?
17:42:50 <danderson> that's the bread and butter of what "haskell is a lazy language" means
17:43:03 <Darkone> Like he said, it's storing a thunk: The reason this get's so big, is it might store, say, (((5 + 5) + 5) + 5) +5 instead of (20) + 5
17:43:25 <danderson> choffstein: depends on your code, but the simplest forcing primitive is the seq function
17:43:28 <choffstein> danderson: this is my first experience with a lazy language, so I am probably writing very inefficient code
17:43:28 <danderson> :t seq
17:43:29 <lambdabot> forall a t. a -> t -> t
17:43:41 <Darkone> Yea, but you have to be careful with seq, as I'm seeing here.
17:43:54 <Darkone> Uhh
17:43:57 <danderson> seq takes 2 values, forces evaluation of the first, and returns the second
17:44:00 <Darkone> Let me try and get the link
17:44:33 <Darkone> Here, danderson, choffstein, this might be useful
17:44:33 <Darkone> http://book.realworldhaskell.org/read/functional-programming.html#fp.seq
17:44:37 <ivanm> danderson: I beg to differ; simplest method could be to put a ! in the data type being used
17:44:44 <danderson> so, for example, if you have your variable foo which contains your table, foo `seq` foo will return foo, forcibly evaluated
17:45:02 <ivanm> if the value being accumulated is part of a larger data type
17:45:11 <siracusa> choffstein: Was it you asking a question to a GHC/GHCi linking problem some hours ago?
17:45:15 <ivanm> danderson: up to whnf, anyway ;-)
17:45:18 <danderson> ivanm: that is true, it does however depend on what the code looks like (ie. whether the type can be twiddled easily)
17:45:29 <Darkone> Explains strict evaluation vs lazy, how to use seq, and in what cases seq won't work.
17:45:41 <choffstein> siracusa: yeah, but I figured it out.  turns out my osx build of gnu mp library wasn't i386, it was x64
17:45:47 <danderson> ivanm: yeah, I wasn't going to get into whnf and all that, strict vs. lazy is a decent first approximation ;)
17:45:47 <Darkone> Apparently, seq likes to get finicky if you're not careful :X
17:46:33 <siracusa> choffstein: ok, I had similar problems using mysql libraries.
17:47:47 <dankna> choffstein: upgrade to the latest Haskell-Platform.  it just came out, like, today.  and it supports 64-bit.
17:48:04 <[swift]> the new haskell platform is out? sweet
17:48:13 <dankna> yeah, dons announced it here like half an hour ago :)
17:48:16 <danderson> it's still beta, no?
17:48:36 <choffstein> ah, fantastic.  thanks
17:48:38 <rubendv> what is the status on generating 64 bit code on Snow Leopard?
17:48:39 <danderson> if you're not afraid: http://hackage.haskell.org/platform/new/
17:48:58 <dankna> <dankna> <dons> btw, ghc  6.12 + snow leopard + 64 bit
17:48:58 <dankna>  <dankna>  <dons> ready. in binary form.
17:49:02 <danderson> (you shouldn't be afraid, despite the beta label, it looks rather happy, I've been running it for a couple of days)
17:49:16 <dankna> I believe the beta label is gone now?
17:49:18 <[swift]> i can't wait for the mac ports people to package it
17:49:25 <shapr> dons: It's purty! I want to try it!
17:49:31 <dankna> and that it is in macports now as well?
17:49:34 <rubendv> [swift]: im installing it from there right now
17:49:38 <dankna> at least the site certainly claims it is
17:49:40 <[swift]> really?
17:49:44 <rubendv> sudo port selfupdate
17:49:54 <[swift]> damn, trying now
17:49:58 <choffstein> is there a haskell profiler?
17:50:07 <dankna> @google ghc profile
17:50:08 <ivanm> choffstein: inbuilt into GHC
17:50:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
17:50:08 <lambdabot> Title: Chapterï¿½5.ï¿½Profiling
17:50:17 <danderson> dankna: don't think so. The beta label is gone from the site, but because it's being finalized
17:50:24 <[swift]> strange as the macports website still shows ghc 6.10 as being the newest
17:50:25 <danderson> I could be wrong though.
17:50:46 <ivanm> [swift]: it's just come out...
17:50:51 <danderson> dankna: in any case, it's not terribly important, it's not beta in the sense of highly likely to explode.
17:50:58 <ivanm> do you expect macports to have the new installer instantly? :p
17:51:04 <choffstein> Oh Haskell, I will figure you out!
17:51:06 <[swift]> ivanm: no, but somebody just said they did =)
17:51:25 <[swift]> might be that the website is out of date tho
17:51:38 <ivanm> danderson: and in the sense that the libraries aren't completely stable for all time (like the big monolithic C libraries)
17:52:24 <danderson> choffstein: the path to enlightenment is long (I should know, I'm still on it, not that far), but the previous pilgrims have opened nice little pubs along the way, so it's a pleasant trip
17:52:26 <ivanm> [swift]: 2009.2.0.2 just made it into macports
17:52:52 <dankna> danderson: agreed that it doesn't really matter whether it's beta or what, but I think it's the real deal
17:52:56 <ivanm> danderson: heh
17:53:00 <[swift]> ivanm: meaning the old version, i assume, unless the naming is really bizarre. ah well
17:53:01 <danderson> ivanm: right. But for mac, where you have either a dmg or a macports install, either way it should be painless to upgrade to final if it does happen to change
17:53:14 <ivanm> [swift]: yup
17:53:35 <ivanm> danderson: do you mind if I @remember an edited version of that (removing the "I should know" bit?
17:53:40 <choffstein> Looks like 'seq' did the trick.  Thanks for that guys
17:53:43 <ivanm> or do you prefer the whole thing being @remembered
17:53:44 <ivanm> ?
17:53:54 <danderson> ivanm: be my guest
17:54:11 <[swift]> if others on a mac know.. i've actually just been running the ghc 6.12 dmg, not the full platform. do i need to uninstall it before i install the platform?
17:54:26 <ivanm> @remember danderson the path to [Haskell] enlightenment is long, but the previous pilgrims have opened nice little pubs along the way, so it's a pleasant trip
17:54:26 <lambdabot> It is stored.
17:54:28 <ivanm> voila!
17:54:39 <ivanm> [swift]: most probably
17:54:45 <ivanm> since IIRC the mac installer includes GHC
17:54:49 <dankna> swift: the platform installer will detect its presence and, I think, refuse to install
17:54:59 <dankna> the relevant files are in /Library/Frameworks/GHC.framework
17:55:11 <dankna> and some symlinks in /usr/bin/ but those it's probably safe to leave alone
17:55:18 <olsner> last time I tried (that was the previous version), the haskell platform thing actually had two separate installers in the .dmg you download
17:55:52 <[swift]> cool, sounds good. will try it out shortly
17:55:58 <olsner> one that looked like it was exactly the GHC installer they distribute, and one that installs the platform stuff
17:59:55 <superoptimizer> what is meant by "the platform" in this case?
18:00:22 <superoptimizer> I think I used MacPorts to install, and I seem to be at 6.10.4 of ghci
18:01:14 <m3ga> superoptimizer: The 'haskell platform' is a ghc compiler and a set if libs (at a particular version) which is considered a good base system for haskell development
18:02:09 <kmc> @where platform
18:02:10 <lambdabot> http://hackage.haskell.org/platform/
18:02:20 <m3ga> or better yet : http://hackage.haskell.org/platform/contents.html
18:02:35 <m3ga> which renders weird for me
18:02:37 <ivanm> usually described as a "batteries included" set of libraries for GHC
18:02:45 <ivanm> it's basically GHC + the old extralibs + cabal-install
18:03:31 <choffstein> Would someone be willing to check out a haskell program I wrote an help explain to me why it is so slow?  I would really appreciate it.
18:03:46 <fax> choffstein I'll try but I am rubbish at that
18:04:56 <m3ga> choffstein: for code that is slow, profiling is a good course of action. see http://book.realworldhaskell.org/read/profiling-and-optimization.html
18:05:02 <danderson> choffstein: I can try, but I'm better at writing bad code than at improving it.
18:05:18 <choffstein> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24233
18:05:26 <choffstein> Yeah, I am pretty bad.
18:06:00 <m3ga> choffstein: i'm a relative newbie, but using that profiling chapter i was able to find the perf bottleneck in a 50k line haskell program.
18:06:06 <choffstein> If you need more comments, I can go through and more thoroughly comment it.
18:06:13 <choffstein> Okay, I will check the chapter out
18:06:32 <danderson> RWH in general is a great reference
18:06:42 <m3ga> once i found the bottleneck it was pretty easy to figure out that the problem function was O(n^3) or worse.
18:07:35 <choffstein> Not build for 'prof'.  Damnit.
18:08:17 <m3ga> choffstein: are you running under ghci or compiling?
18:08:23 <choffstein> compiling
18:08:40 <choffstein> figured it out
18:08:46 <m3ga> the chapter explains what compiler flags you need for profiling
18:08:48 <choffstein> thought it was talking about my ghc, not my program
18:11:49 <zeiris> What is base ==4 and why does it not let me install stuff from Hackage, despite having the latest cabal version :(
18:12:38 <ivanm> base 4 comes with ghc >= 6.10.1
18:12:40 <choffstein> looks like I might need to rebuild a lot of libraries for profiling...
18:12:47 <ivanm> it has nothing to do with Cabal nor cabal-install
18:12:52 <ivanm> whichever one you meant
18:14:18 <choffstein> is there a way to tell cabal to install the profiling libraries for a package?
18:14:31 <ivanm> choffstein: do you mean Cabal or cabal-install?
18:14:32 <Alpounet> choffstein, --enable-profiling IIRC
18:14:44 <ivanm> if the latter, set it in your ~/.cabal/config
18:14:46 <Alpounet> but you can modify it in your ~/.cabal/config
18:15:01 <Alpounet> so that it will apply for all the libraries you install
18:16:02 <choffstein> Man you guys are helpful
18:16:30 <tensorpudding> cabal install -p on the command line
18:17:11 <tensorpudding> if you just want it for an individual package installed via cabal-install
18:18:01 <ivanm> choffstein: note: the command line application "cabal" comes with cabal-install and not Cabal
18:18:19 <ivanm> thus, when you're referring to the tool you should specify cabal-install and not just say cabal
18:18:49 <choffstein> okay, thanks
18:19:28 <dons> Cale: i made a crappy 'download haskell' button. see on the right here, http://donsbot.wordpress.com/ do you want to make a better one?! :D
18:20:23 <choffstein> Is there any way for me to rebuild all my haskell libraries with profiling ability?
18:20:47 <ivanm> dons: needs some roundedness ;-)
18:21:25 <ivanm> dons: btw, what wordpress theme do you use?
18:22:08 <nar0122> can anyone help me with undertanding execution times for various adt operations using an array based implementation and a pointer based implementation
18:25:09 <choffstein> installing haskell 2010.  be right back
18:27:35 <lpjhjdh> I know there are a few arch folks out there, anyone have a solution for getting ghc built against the new gmp in testing?
18:28:13 <zeiris> What are my odds of being accepted to work on Haskell for GSoC, if I haven't uploaded anything to Haskell (yet) and my expertise so far consists of (probably) understanding monads and (probably) being able to write reasonably large functioning applications?
18:28:25 <zeiris> s/to Haskell/to Hackage
18:29:42 <dankna> speaking as an outsider, I'd say it depends on your proposal
18:29:55 <dankna> how well written it is, how clear a need it fills, whether it shows expertise
18:30:22 <danderson> having submitted something (not necessarily a package, a patch to an existing library is also an option) would be a plus
18:30:37 <danderson> simply because it gives people reviewing some code to look at
18:31:40 <zeiris> Has the idea of a Haskell IDE died out, or is there still a need for one?
18:32:16 <bremner_> zeiris: leksah?
18:32:25 <zeiris> Yes :3
18:32:42 <bremner_> last release 5 days ago?
18:32:47 <Alpounet> lpjhjdh, #arch-haskell
18:32:49 <zeiris> Woah.
18:33:03 <Alpounet> (haven't encountered that issue yet, btw)
18:33:46 <lpjhjdh> Alpounet: thanks
18:36:56 <MrBlueSky> Is "data Person = Person String" the same as "type Person = String" ??
18:38:01 <dankna> no, there's a couple subtle but important differences
18:38:21 <dankna> with type Person = String, you can use any string as a person, no questions asked
18:38:31 <kmc> i disagree that it's subtle ;)
18:38:34 <kmc> they are totally different
18:38:36 <dankna> with data Person = Person String, you have to be like Person "foo"
18:38:38 <dankna> well
18:38:41 <dankna> yes, haha
18:38:51 <kmc> "type" is a synonym, it's just like a macro expansion wherever "Person" appears in a type
18:38:58 <dankna> I started out thinking I was going to talk about the implications for typechecking, which are a little subtle
18:39:11 <dankna> but then I explained the constructor versus no constructor thing instead, which is totally glaring
18:39:25 <ivanm> kmc: hmmm, never thought of it as a macro expansion
18:39:28 <MrBlueSky> ok yeah I don't know how I overlooked that. Thanks!
18:39:30 <ivanm> just as syntactic sugar
18:39:32 <kmc> "data" creates a new type which the typechecker will not treat as equal to the underlying type
18:39:43 <ivanm> data vs newtype is more subtle
18:39:47 <kmc> ivanm, *shrug* you can make type synonyms with type parameters and those act a little like macros
18:39:53 <ivanm> yeah
18:40:03 <ivanm> and IIRC the only thing that matters code wise there is how undefined is treated
18:40:08 <ivanm> (for data vs newtype)
18:40:14 <kmc> yeah
18:40:23 <ivanm> runtime, newtype > data
18:40:27 <kmc> newtype is like a more efficient form of data, that you can only use in some cases
18:40:36 <kmc> if you ignore the different treatment of undefined values
18:41:09 <ivanm> newtype can be considered a type safe version of type that also lets you define new instances
18:41:23 <kmc> though it's worth pointing out that «newtype Foo = (Int, String)» is no more efficient than «data Foo = Foo Int String», and noisier and less readable
18:41:51 <ivanm> kmc: actually, that doesn't work (your newtype example) :p
18:41:54 <ivanm> but agreed
18:42:07 <ivanm> newtype should only be for singleton values, not pairs, etc.
18:42:16 <ivanm> use adaptive pairs if you want efficiency on that front
18:42:40 <kmc> why doesn't it work?
18:42:50 <ivanm> no constructor!
18:42:51 <kmc> oh durr
18:42:53 <kmc> yeah sorry
18:42:56 <ivanm> :D
18:43:54 <pikhq> It's like the difference between "typedef foo bar" and "typedef struct {foo f;} bar", in C terms. (type vs. data)
18:53:32 <ivanm> @. elite protontorpedo
18:53:33 <lambdabot> Can u BUi1d t|-|In9s phaz+ in |-|ASx31|?
18:53:40 <kmc> @. elite nixon
18:53:41 <lambdabot> i D0n'T \/\/4nt +O 5eE 7Hiz0rz coun+ry t0 90 T|-|A+ \/\/ay. u KnoW wHa+ |-|Appen3D +o The gr3Ekz. ho/\/\O$3xuA|I7Y de$7R0YEd +H3/\/\. $urE, 4Riz+OT|3 W4$ a HO/\/\O, We 4Ll KNoW t|-|A+, s0 W45 SoCR4+
18:53:41 <lambdabot> 3z.
18:54:07 <ivanm> what is 7Hiz0rz meant to be?
18:54:33 <kmc> this -> thizorz -> 7Hiz0rz
18:54:38 <ivanm> aha
18:55:45 <winxordie> kmc: nice typing.
18:55:54 <superoptimizer> Wow, macports install of haskell-platform is taking forever. MacBook Pro is hot...I want to write an expression optimizer and now I'm just waiting... :(
18:57:13 <ivanm> an "expression optimizer"?
18:57:16 <Nereid_> @die
18:57:17 <lambdabot> unexpected end of input: expecting number
18:57:20 <Nereid_> eh
18:57:23 <Nereid_> @die 20
18:57:23 <lambdabot> 20 => 20
18:57:28 <Nereid_> ehhhh
18:57:31 <Nereid_> what's that supposed to do
18:57:33 <ivanm> @die 137
18:57:33 <lambdabot> 137 => 137
18:57:44 <ivanm> d&d dice rolling IIRC
18:57:45 <ivanm> @help die
18:57:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:57:52 <Nereid_> it doesn't seem to be rolling very well then
18:57:53 <ivanm> @help dice
18:57:53 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
18:57:59 <ivanm> there we are
18:58:03 <ivanm> @dice 1d6
18:58:04 <lambdabot> 1d6 => 5
18:58:12 <Nereid_> ahh
18:58:14 <ivanm> one number from a 6 sided dice
18:58:19 <kmc> @dice 2d2 + 7
18:58:19 <lambdabot> 2d2 + 7 => 10
18:58:34 <dankna> @dice 1d0
18:58:34 <lambdabot> 1d0 => 1
18:58:39 <dankna> @dice 100d0
18:58:39 <lambdabot> 100d0 => 48
18:58:49 <dankna> @dice 1d99999999999999999999999999999999999999
18:58:49 <lambdabot> 1d9999999999999999999999999... => 86282976490649095534162317803914519763
18:58:50 <ivanm> dankna: stop being mean!
18:58:51 <superoptimizer> ivanm: Yes. e.g. take an expression represented by a tree and optimize it, e.g. to fold constant expressions, eliminate things like 'a-a', distribute things like a*(b-c) so that a*(b-c)-a*b is optimized to -(a*c)
18:59:02 <dankna> ivanm: hehe it's still cool
18:59:18 <ivanm> superoptimizer: hmm.... I wonder how feasible that would be and how well it would scale
18:59:27 <superoptimizer> It's a small project to improve my haskell skills.
18:59:34 <ivanm> if it does end up working, it might be something to get into hlint...
18:59:36 <dankna> superoptimizer: if you think Haskell-Platform is a big install, try MacTeX.  1.2G download...
18:59:42 <superoptimizer> ivanm: I would think that it's feasible. I did the same in LISP 20 years ago :)
18:59:50 <ivanm> heh, fair enough
18:59:55 <ivanm> but is it just numeric stuff?
19:00:06 <dankna> @dice -1
19:00:06 <lambdabot> unexpected "-": expecting number
19:00:08 <ivanm> or are you proposing to do list fusion optimisations, etc. on the code level?
19:00:14 <ivanm> @slap dankna
19:00:14 * lambdabot throws some pointy lambdas at dankna
19:00:20 * dankna chuckles
19:00:22 <superoptimizer> literals and variables
19:00:26 <superoptimizer> g2g
19:00:42 <dankna> sorry, I'll leave lambdabot alone
19:00:57 <dankna> heh, it's a programmer instinct though - when you see a new toy, try to break it
19:01:17 <dankna> some years ago I brought my shiny new bot which I had written in Lisp to show it off to a friend
19:01:26 <dankna> who immediately asked it to roll one million dice and display the list of results
19:01:32 <dankna> he expected the bot to crash somehow
19:01:51 <dankna> instead its built-in protection against flooding caused it to start displaying the results JUST SLOWLY ENOUGH that the server wouldn't kick it for abuse
19:02:04 <dankna> I had to kill it by hand
19:02:15 <theorbtwo> Ouch.  That's really the worst thing it could possibly have done, from the point of view of anybody else in the channel.
19:02:18 <dankna> we had a good laugh about it and agreed that he deserved it, hahaaha
19:02:20 <dankna> yes, it is
19:03:09 <dankna> I had simply never considered protecting against that type of abuse
19:03:11 <zoheb> I have written a lot of code which uses a certain list that I have defined list = ["some",words", ......] , now I want this listed read in from a file instead of being defined in the program
19:03:37 <zoheb> The issue is that I have used this list all over the place and deep inside nested fn calls
19:03:46 <fax> zoheb, we need a module system :|
19:03:56 <dankna> @hackage direct-plugins
19:03:56 <lambdabot> http://hackage.haskell.org/package/direct-plugins
19:03:57 <fax> one thing you might be able to do is,
19:04:03 <theorbtwo> dankna: So why didn't it simply flood and get caught by the server's antiflood things?
19:04:05 <zoheb> How can I avoid rewriting the whole program to deal with the IO monad, is there any way to do this cleanly
19:04:27 <zoheb> whats a module system?
19:04:35 <fax> it woudl solve this problem..
19:04:38 <dankna> theorbtwo: because it had a built-in timer that knew what the server's antiflood heuristic was and defeated it, to prevent denial-of-service exploits that would make the bot get itself kicked
19:04:41 <zoheb> How will that solve the issue
19:04:49 <fax> I'mtrying to think of a way that haskell actually supports though
19:04:51 <zeiris> zoheb, unsafePerformIO :D:D:D
19:05:06 <fax> zeiris, some peopel actually think that...
19:05:06 <zoheb> I saw that coming :-/
19:05:08 <dankna> fax: cf. my own library direct-plugins, which is exactly what I think you're talking about
19:05:20 <ivanm> fax: we _have_ a module system...
19:05:26 <zeiris> Could also wrap it in a Reader monad, especially if there's some state or failure or other monadic-y things being passed around.
19:05:34 <dankna> (or dons's Plugins, which my package is intended as a replacement for)
19:05:36 <ivanm> zoheb: you read the data in in one place, and then pass it around
19:05:42 <zoheb> Yes
19:05:53 <ivanm> no, as in that's how you do it
19:06:05 <zoheb> Now I will have to turn every fn in my code into an IO monad
19:06:12 <ivanm> either explicitly, or else a Reader/State monad as zeiris suggested
19:06:15 <dankna> not IO - reader/state
19:06:26 <ivanm> or just pass the value explicitly
19:06:30 * theorbtwo shrugs.  I'd normally prefer getting DOSed then causing one.
19:06:30 <dankna> but yes, you'll have to make pervasive changes
19:06:40 <ivanm> of course, if you're going that far down then methinks you're doing it wrong...
19:06:51 <zoheb> Is there any standard way of dealing with this issue?
19:06:59 <dankna> theorbtwo: I agree.  It was the wrong call.  What it actually should have done was what it did BUT with an additional protection that prevents any one command from causing too much output.
19:07:03 <ivanm> yes; don't do it in the first place! :p
19:07:05 <fax> zoheb, suppose your file is,   f = .. ; g = ...
19:07:07 <ivanm> or use Reader/State
19:07:12 <fax> then you can indent this whole file by one space
19:07:14 <theorbtwo> dankna: Yeah, that's the better solution.
19:07:15 <fax> and put at the start
19:07:16 <dankna> theorbtwo: but you asked what my reasoning for the behavior was, and that was what it was
19:07:25 <fax> let fg list = (f',g') where
19:07:29 <fax> oops
19:07:29 <theorbtwo> (And, notably, what lambdabot does.)
19:07:31 <fax> fg list = (f',g') where
19:07:36 <zeiris> fax, I kinda do think that. In the end, as you're learning, getting results is more important than spending hours figuring out how to kludge your code into shape. Fix the problem now, sort out how to deal with it later - it worked well for me since I ended up learning a lot more that way. (Disclaimer: I do not in any way encourage this in a team environment.)
19:07:43 <dankna> right
19:07:44 <fax> fg list = (f,g) where ** third time lucky!!
19:07:51 <fax> then in the OTHER file you can go
19:07:57 <theorbtwo> (Though somewhat oddly for a haskel program, it seems to compute the entire output, then truncate it.)
19:08:03 <fax> (f,g) = fg ["some","words"]
19:08:13 <dankna> I'd like to know what you meant by a module system, fax, and why you think we don't have it :)
19:08:36 <theorbtwo> dankna: Think firefox addons, or chrome extensions.
19:08:44 <fax> dankna, well see what I suggested here -- abstracting out the 'list' variable by making it a parameter
19:08:48 <ivanm> zeiris: I've tried that approach in the past...
19:08:56 <zoheb> @fax I dont quite get it
19:08:56 <lambdabot> The answer is: Yes! Haskell can do that.
19:08:59 <theorbtwo> Load all the .so files in a directory, at runtime, and let them modify the behavior of the base program.
19:09:00 <ivanm> however it ended up being easier to get in and do large scale changes ASAP
19:09:07 <fax> danka, the idea of 'module system' is just exactly that... except that it handles the (f,g) = fg stuff and the indenting all automatically
19:09:16 <ivanm> otherwise, you end up having more code that uses your kludges and you thus have to rewrite _more_ of it down the track
19:09:21 <fax> look at e.g. http://caml.inria.fr/pub/docs/manual-ocaml/manual004.html
19:09:41 <fax> afaict there's no reason we couldn't add this to haskell.. just nobody did it yet
19:09:46 <zeiris> It worked beautifully, because when I ran into that very problem I was in no way ready for monad transformers. So I just delayed them, by throwing in an unsafePerformIO... then a few days later realized I could solve that problem + a bunch of others via a transformer stack :D
19:10:13 <zeiris> I think it's a really important technique to flatten the learning cliff a little, and make Haskell a more viable choice than <insert favourite language of choice> for beginners.
19:10:30 <dankna> I'm not quite understanding how this differs from Haskell modules, except that Haskell modules have 1:1 with source files and this apparently doesn't?
19:10:37 <dankna> is that the major difference?
19:10:47 <Alpounet> no
19:10:53 <Alpounet> ML modules can be parametrized
19:11:07 <dankna> hm
19:11:07 <Alpounet> (=> module functors)
19:11:08 <ivanm> fax: it would involve a major change IIRC
19:11:26 <adu> hi all
19:11:29 <zoheb> fax are u describing someting that haskell supports as of now?
19:11:32 <ivanm> fax: and a lot of arguments about the best way of doing it syntactically ;-)
19:11:35 <ivanm> zoheb: no
19:11:40 <dankna> hmmm
19:11:44 <dankna> this is interesting
19:11:46 <zoheb> the fg list = (f,g) where *** part
19:11:52 <zoheb> ok
19:12:05 <fax> zoheb - that is valid haskell ... it's a way to approximate the modular way I'd do it in ocaml
19:12:23 <fax> an other (hacky) approach to approximate it is to use typeclasses
19:12:32 <fax> but I think the method with typeclasses is a bit harder to understan
19:13:02 <Alpounet> dankna, ML-like modules are powerful, really. That with polymorphic variants are two particular OCaml features I quite like
19:13:16 <dankna> they sound pretty interesting, I'm glad to hear about them
19:13:58 <fax> you'd do something like   class List module where list :: module -> [String];   class List module => FG module where f :: ... ; g : ....;     instance List module => FG module where f = ... ; g = ...
19:14:06 <zoheb> fax, so basically u r suggesting that I put my entire program in a where clause, so I can refer to the reader monad like a regular function
19:14:29 <fax> then in the OTHER file you could make various list intances for different 'modules' (which are just arbitrary types used as names)
19:14:36 <ivanm> zoheb: not at all
19:14:39 <fax> zoheb no, no moads
19:14:43 <fax> no monads*
19:14:48 <zoheb> ok
19:14:56 <ivanm> fax: we _were_ suggesting a Reader/State monad above ;-)
19:15:11 <fax> zoheb ill make an example
19:15:25 <ivanm> zoheb: you have to pass around your data either explicitly (foo data = bar $ baz data) or imiplicitly using a Reader/State monad
19:15:36 <ivanm> where State allows you to "edit" the data if you have to
19:15:55 <zoheb> I know the reader monad part
19:16:11 <zoheb> but dont all my functions turn into a reader monad
19:16:12 <fax> I don't know what you mean about reader monad, btw.. nothing I said has anything to do with monads
19:16:39 <zoheb> I was referring to what ivanm was stating sorry about that
19:17:36 <ivanm> zoheb: so all your functions look like: foo :: Reader (); foo = do data <- ask; doStuffWith data
19:17:53 <ivanm> and then you use runReader to pass the data in and execute all of them
19:19:33 <zoheb> ivanm, I have already written most of the program, I will have to butcher every fn I wrote and rewrite it in monadic style
19:19:49 <ivanm> zoheb: well, yes; as I said that was one option
19:20:33 <ivanm> zoheb: you have two problems with your design: 1) you didn't think hard enough about what you were going to do (in that you are now wanting to read data infrom file); 2) you have too many functions using that data directly
19:20:48 <ivanm> zoheb: the easier way of doing it is to pass that data around as a variable
19:20:52 <fax> zoheb, http://pastie.org/880426
19:20:57 <fax> there is two methods..
19:21:01 <Darkone> sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]     Can someone explain why the function application on [1..] is necessary?
19:21:28 <Darkone> I don't understand what teh error that generates when you don't use it means.
19:21:56 <fax> Darkone: in general...   f . g . h $ x   is   f (g (h x)),   but   f . g . h x  is a function, so  (f . g . h x) y  = f (g ((h x) y)) -- which makes no sense in the case you wrote
19:21:56 <zoheb> fax, wow! thanks for writing that up, I am looking at it now
19:22:02 <kmc> Darkone, it would parse as sum . takeWhile (<10000) . filter odd . (map (^2) [1..])
19:22:07 <kmc> that's a type error
19:22:13 <kmc> as (map (^2) [1..]) is not a function
19:22:17 <kmc> so it can't be the right argument to (.)
19:22:19 <ivanm> Darkone: because you have to map a function on _something_?
19:22:28 <ivanm> oh, you mean why you need the $ ?
19:22:40 <Darkone> Yes, still reading answers
19:22:56 <kmc> Darkone, with the $ it parses as (sum . takeWhile (<10000) . filter odd . map (^2)) $ [1..]
19:22:56 <ido> which is better, haskell or a car that runs on water and poops strawberries?
19:23:03 <ivanm> fax: *shudder* your class example is IMHO horrible :s
19:23:13 <dankna> haskell
19:23:13 <ivanm> I don't even understand what it's trying to do
19:23:14 <Darkone> Ahhhh, I see.
19:23:27 <ivanm> @slap ido
19:23:27 * lambdabot pushes ido from his chair
19:23:38 <dankna> the car would solve a short-term problem.  haskell solves a long-term problem.
19:23:42 <Darkone> The $ matches to a closing parenthesis, that starts earlier.
19:23:50 <dankna> @slap dankna
19:23:51 <lambdabot> *SMACK*, *SLAM*, take that dankna!
19:23:53 <dankna> @slap dankna
19:23:53 * lambdabot activates her slap-o-matic...
19:24:14 <Darkone> It turns everything before it into a partial function, and feeds it the list. Is my interpretation correct?
19:24:23 <applicative> Darkone, the $ is like a knife in the middle of the sentence, everything to the left is function, everything to the right is argument -- to put it crudely
19:24:32 <ivanm> dankna: I take it you're a masochist?
19:24:37 <ivanm> and into self torture?
19:24:39 <nanashi> =)
19:24:49 <nanashi> applicative
19:24:50 <dankna> nah, it just didn't seem right to indulge my curiosity about how many phrases she had on someone else :)
19:24:51 <ivanm> Darkone: not really
19:24:57 <Darkone> Yea. Low... precedence? operator.
19:25:09 <kmc> yeah, it has the lowest precedence
19:25:14 <ivanm> Darkone: the $ is there basically to stop the chain of functions and actually feed it a value
19:25:16 <applicative> it's only use is its precedence
19:25:22 <kmc> that's not true
19:25:24 <ivanm> @src ($)
19:25:25 <lambdabot> f $ x = f x
19:25:25 <kmc> it's also useful as a section
19:25:32 <kmc> > map ($ 3) [pred, succ, (+ 7)]
19:25:33 <lambdabot>   [2,4,10]
19:25:38 <ivanm> kmc: damn, you beat me to it!
19:25:39 <applicative> well, okay
19:25:50 <applicative> how do i get slapped?
19:26:04 <fax> zoheb the second one is kind of crazy but the first one shoudl make sense :)
19:26:09 <kmc> i have an idea for a Haskell blog post
19:26:12 <applicative> @slap applicative
19:26:12 <lambdabot> why on earth would I slap applicative?
19:26:13 <kmc> but i'm lazy and don't have a blog
19:26:17 <kmc> so one of y'all should write it
19:26:33 <Darkone> Thankyou all :P
19:27:10 <syntaxglitch> flip ($) is useful sometimes, too
19:27:38 <Darkone> Makes sense what was happening now.
19:27:38 <zoheb> fax, ok I get the 2nd one
19:27:52 <zoheb> the 1st one sorry
19:27:52 <fax> oh I meant the 3rd one
19:27:55 <fax> heheh
19:28:08 <Gracenotes> make
19:28:09 * hackagebot gitit 0.7.3.3 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.3 (JohnMacFarlane)
19:28:16 <Gracenotes> grr, wrong terminal
19:28:27 <Gracenotes> unless you guys will make my project for me
19:28:34 <Darkone> That means you can write it as oddSquareSum = sum . takeWhile (<10000) . filter odd $ map (^2)  [1..] also, as the last half would be a value (expression?) that the left function can accept
19:28:56 <Darkone> Although I imagine they work alot differently.
19:29:12 <kmc> Darkone, indeed
19:29:23 <kmc> in fact you can write sum $ takeWhile (<10000) $ filter ...
19:29:26 <kmc> but it's considered worse style
19:29:40 <kmc> because the chain of compositions is a useful expression in of itself
19:29:52 <kmc> you might refactor your code to cut out the application and give the function itself a name
19:29:55 <applicative> it's ugly since the $ is ugly
19:29:59 <kmc> but if you use ($) throughout then you are committed to applying it here and now
19:30:06 <Darkone> The later makes the partial function up to the $, then passes it an infinite list of all whole numbers squared.
19:30:10 <zoheb> thanx @fax
19:30:15 <zoheb> that makes sense
19:30:23 <Darkone> Also, yea, looks ugly with too many $'s
19:30:31 <fax> kk :)
19:30:33 <Darkone> Something about . looks so pretty :P
19:30:49 <kmc> also re: usage of "expression" and "value", both would be reasonable here.  expressions are part of the syntax of programs; values are what the pieces of programs evaluate to at runtime
19:30:58 <Darkone> Like calling a member of a class in another language, it just looks so clean and tidy.
19:31:20 <applicative> sum . takeWhile (<10000) . filter odd . map (^2)  is something by itself, you can apply it to something;  sum $ takeWhile (<10000) $ filter odd $ map (^2)  is a type violation
19:31:32 <applicative> @type sum $ takeWhile (<10000) $ filter odd $ map (^2)
19:31:33 <lambdabot>     Couldn't match expected type `[a]'
19:31:33 <lambdabot>            against inferred type `[a1] -> [a1]'
19:31:33 <lambdabot>     In the second argument of `($)', namely `map (^ 2)'
19:31:47 <applicative> @type sum . takeWhile (<10000) . filter odd . map (^2)
19:31:48 <lambdabot> forall a. (Integral a) => [a] -> a
19:32:13 <kmc> (.) is an associative operator, ($) is not
19:32:13 <Darkone> kmc : yea, I'm terrible at terminology, so whatever I use is oftena  stab in the dark :P
19:32:30 <kmc> and when you write a big chain of something without parens, it's always better to use an associative operator
19:32:41 <kmc> and (.) is like everyone's favorite associative operator
19:32:46 <fax> associative is NICE
19:33:26 <applicative> Darkone, have you tried hlint?  I found its really good straightening out precedence and so on.
19:33:27 <Darkone> kmc, and it looks clean... as well as kind of neat, in the "cool" sense of the word. I can't put my finger on why.
19:33:57 <kmc> because it's a simple thing that's complicated in most languages
19:34:15 <Darkone> applicative, I just didn't understand how it was working well enough. I wasn't thinking it was trying to make map (^2) [1..] a function. Now it makes perfect sense :P
19:34:45 <Darkone> The recursion stuff isn't too hard, nor is the construction of fold, after I ironed out the kinks in here :C
19:34:46 <applicative> Darkone, hlint always notices if you have, say, k x =  f $ g $ h $ x and suggests  k = f . g. h
19:35:04 <Darkone> kmc, agreed. PArtial Application is amazing.
19:35:08 <applicative> or if you have k x = f ( g ( h x )))
19:36:15 <kmc> Darkone, I take the more pessimistic view.  it's not amazing at all; it's amazing how badly wrong most languages handle this stuff
19:37:05 <glguy> Did GHC on Snow Leopard get 64-bit support or are my reddit eyes deceiving me...
19:37:34 <absentia> what?
19:37:36 <absentia> yes?! where? whe?
19:37:45 * absentia goes back tp coding on for the iPad.
19:38:20 <fax> absentia??
19:38:25 * DigitalKiwi wants an iMat
19:38:34 <ivanm> glguy: it does
19:38:56 * ivanm wants a Nokia N900
19:39:42 <absentia> what?
19:39:59 <fax> how can you write code for iPad?
19:40:02 <ivanm> you actually get sucked in to the iPad hype? :o
19:40:18 * Darkone wants an i7 980X, one or two 5970s, some nice monitors, and the micronuclear power plant required to power the whole setup.
19:40:39 * dankna wants lots of money
19:40:40 <Darkone> Too much poweR? Yes.
19:40:50 <absentia> SDK 3.2?
19:41:09 <Darkone> 6 copies of Dwarf Fortress on 6 screens? :D
19:41:19 <ivanm> dankna: sure, take the _easy_ approach...
19:41:35 <tensorpudding> One copy of dwarf fortress is too many.
19:41:39 <DigitalKiwi> http://i.imgur.com/3JmjP.jpg Lol
19:41:42 <dankna> ivanm: hehe, fair enough
19:41:49 <ivanm> fax: my understanding is that anyone can start to write code that targets the iPad; whether you'll be allowed to sell it immediately upon launch is a different story
19:42:22 <Darkone> tensorpudding, maybe... but I'm pretty sure an i7 980X could handle 6 with enough RAM
19:42:43 <fax> absentia?
19:42:49 <absentia> my proggie will be free.
19:42:51 <absentia> what?
19:42:56 <Darkone> DF is still single threaded, so one per core. Pretty much the fastest stock per-core processor there is.
19:42:57 <fax> how?
19:43:11 <absentia> all devs have access to the iPhone OS 3.2 beta.
19:43:34 <fax> ahhh so it's a pay $200 to write software for your computer deal?
19:43:34 <Darkone> DigitalKiwi, iFloor, iBlock, iCity...
19:43:48 <absentia> $99, but ya.
19:44:05 <fax> if it weren't for that I would have bought one :(
19:44:09 <tensorpudding> A computer the size of a chalkboard would be kind sweet to see.
19:44:18 <fax> because then I could read (digital) boks in bed
19:44:20 <Darkone> fax, makes me wonder WHY emotic is charging for the SDKs for their epoc :/
19:44:32 <Darkone> tensorpudding, microsoft Touch Wall? :P
19:44:37 <absentia> ya, I want to do that w well
19:44:44 <fax> Darkone, what's emotic? im not up on these technology things at all
19:45:11 <dankna> tensorpudding: exists, sort of.  A company called SmartBoard has a combination of a touch screen and a projector.
19:45:28 <Darkone> fax, company making an advanced neural interface, like OCZ's NIA, but able to handle emotions, facial expressions, complex thought patterns
19:45:36 <fax> ohh wow
19:45:41 <tensorpudding> I've seen something like that, but that's still a projector.
19:45:48 <Entroacceptor> which are impressively expensive
19:45:50 <Darkone> Pretty cool. Currently the thought pattern stuff is a bit slow.
19:46:13 <dankna> pudding: sure, but it's more or less the same from the user's perspective.
19:46:21 <Entroacceptor> and the software sucks big time (talking about smartboard)
19:46:30 <dankna> yeah, I hate the smartboard software actually
19:46:45 <dankna> but you don't have to use their "write on the screen" thing, you can just use it as if it were a mouse.
19:47:05 <dankna> this still leaves the question of what it's actually good for...
19:47:09 <Darkone> tensorpudding, dankna, like I said, microsoft has something, I think it's called the Touch wall, that is basically a giant touchscreen. Uses cameras instead of that touch-sensitive layer though
19:47:20 <dankna> Darkone - oh, that's interesting too then
19:47:21 <Darkone> So it's way cheaper. Works a bit like project natal
19:47:35 <Darkone> There's a demo of bill gates showing on off
19:47:53 <Darkone> And what he thinks the near future of information presentation will be :P
19:48:17 <tensorpudding> Microsoft does a lot of fancy stuff like that, but when was the last time that it actually ended up being represented at all in a finished product?
19:48:46 <luite> the surface is somewhat finished...
19:48:49 <Darkone> tensorpudding, they seem to be pushing hard for this. PArtially because it's cheap enough to work
19:49:05 <Darkone> At least compared to a 60" touchscreen o.o
19:49:14 <tensorpudding> Are they going to actually make a version of the surface you can buy?
19:49:27 <Darkone> And I imagine they'll make smaller systems for smaller monitors, if they carry through with this.
19:50:05 <fax> I hope there's an open source version of iPad :P
19:50:08 <fax> I'll buy it
19:50:30 <tensorpudding> It's not the tech stuff that is important, it's the interface
19:50:35 <Darkone> Though not as complex or powerful, there's a.. uh... open source library- for webcams that tracks markers.
19:50:41 <tensorpudding> the iPhone sure showed that
19:51:12 <Entroacceptor> fax: what for? how would you use it?
19:51:17 <luite> tensorpudding: they do intend to make a smaller/cheaper one, but I think it's still meant to be something that you buy through one of the partners, who will customize it for you, or something
19:51:23 <fax> Entroacceptor: read books and IRC while in bed :D
19:51:35 <ivanm> fax: so an ebook reader?
19:51:42 <DigitalKiwi> tablet PC?
19:51:53 <DigitalKiwi> heaven forbid a laptop ;p
19:52:05 <Entroacceptor> fax I'm ircing from bed right now
19:52:12 <tensorpudding> You'll be able to read ebooks on an iPad won't you?
19:52:13 <fax> hehe I got to go..
19:52:17 <tensorpudding> Pretty sure I saw that.
19:52:26 <Luke> you can
19:52:28 <fax> tensorpudding yeah but I hate the idea that computers into into vending machines for entertainment
19:52:32 <Darkone> Pfft, laptops are outdated. Everyone uses neural interfaced HUD's projected onto their retinas now!
19:52:36 <fax> rather than.. you know.. computers, what let you write programs...
19:52:36 <Luke> you can read an ebook on anyting - just like a PDF
19:52:37 <Entroacceptor> and I think my 20EUR used smartphone stillhas a better keyboard
19:52:52 <Luke> i almost exclusively read on the kindle now
19:52:56 <fax> so I don't want to buy anyd iPad or iPhone to support that idea
19:52:59 <tensorpudding> Writing programs isn't necessarily what computers are supposed to be built for.
19:53:07 <luite> Luke: do you have a regular kindle or dx?
19:53:12 <Luke> regular
19:53:18 <fax> but.. honestly I know that it's too late and we're all gonna be feeding through a straw in yeah 2020
19:53:19 <Luke> you can put PDFs on it now
19:53:26 <luite> oh, don't you read papers or textbooks?
19:53:32 <Darkone> tensorpudding, but running them is :P
19:53:38 <Darkone> Well, to an extent.
19:53:39 <luite> 6" seems rather small for those
19:53:39 <Luke> not anymore - i put papers and textbooks on the kindle
19:53:44 <absentia> I got a kindle 2 for xmas, I gave it away to someone.
19:53:46 <Luke> you know that green defacto algorithms book?
19:53:52 <absentia> was useless for viewing pdfs.
19:53:55 <luite> clrs?
19:53:56 <Luke> that translated into the kindle format really nicely
19:53:58 <absentia> painful.  web browsing.. painful.
19:54:11 <Darkone> Blah. My only thoughts on the iPad: It costs more than my gaming computer :(
19:54:14 <luite> Luke: does it reflow those documents?
19:54:16 <Luke> i heard they are revamping the kindle web browser
19:54:29 <absentia> tltl
19:54:38 <Luke> luite: yes but the better the PDF converting, the better it is... the amazon format is far superior to PDF
19:54:42 <Luke> but sometimes the PDF doesn't translate well
19:54:46 <Luke> then I just leave it in PDF format
19:55:01 <luite> and scanned textbooks?
19:55:07 <Luke> yeah the CLRS PDF converted awesome into the amazon format
19:55:17 <Luke> scanned into what format? pdf?
19:55:26 <Darkone> My computer is like 445$, + cheapy cheapy monitor, + mouse and keyboard and speakers.. so yea, the iPad costs more than it o.o
19:55:45 <Luke> the key to the kindle is the epaper... its awesome!
19:55:57 <Luke> and since it uses almost no power, it has like a month of battery life
19:55:58 <luite> Luke: the 'less official' channels seem to have djvu mostly
19:56:05 <Entroacceptor> my speakers were 400EUR alone...
19:56:09 <Luke> djvu?
19:56:24 <Darkone> Entroacceptor, ouch o.x
19:56:43 <Luke> orilley gave me the mobi version of my paper books for free as well!
19:56:55 <Luke> having them both is the best but honestly, I rarely crack the paper versions anymore
19:56:57 <Entroacceptor> darkone but they are for my stereo, so it's ok :)
19:56:59 <Darkone> I built mine pretty damn budgeted. AMD + ATI + ASRock + Hec PSU
19:57:05 <Luke> the kindle is more convenient than you can imagine
19:57:08 <luite> yes, it's an image compression format, stores the image in two layers, one black/white layer for text (jbig-like compression), and a color layer for images (jpeg-like)
19:57:29 <Darkone> AMD motherboards are fantastic o.o
19:57:29 <Luke> its kinda like you don't know how much better haskell is until you try it =) everyone just thinks all turing complete languages are the same
19:57:44 <Luke> luite: oh yeah I don't know anything about that
19:57:59 <ivanm> Luke: they do? how?
19:58:08 <ivanm> IIRC you had to pay for the ebook version of RWH
19:58:10 <luite> most textbooks don't seem to be available electronically, unfortunately
19:58:20 <Luke> ivanm: i just told them I already owned the books i had
19:58:25 <ivanm> :o
19:58:38 <Luke> my friend did the same thing and had like 40 oriely books so he paid 5 dollars for the lot!
19:58:42 <ivanm> luite: I don't want the situation, however, where textbooks are only available in some proprietary ebook format
19:58:48 <superoptimizer> I find reading technical books on the kindle difficult. It's too slow flipping pages. If you have to look back at diagrams, tables, etc., it's frustrating.
19:58:49 <Darkone> 50$  my mATX motherboard has: AM3 support, 140w cpu support, 4 slots and up to 16 gigs of RAM, PCI-e 2.0 *16 slot, 6 usb, 6 SATA, nice old IDE, uhh
19:59:05 <Luke> luite: have you heard of bitme?
19:59:08 <luite> oh that's nice... unfortunately I don't have many o'reilly books :)
19:59:08 <Darkone> All sorts of goodies. For 50 freaking dollars o.o
19:59:18 <luite> Luke: hmm, no, can't say that I have
19:59:31 <Luke> bitme is the biggest "less official" e-learning site =)
19:59:34 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! maxbound
19:59:36 <Darkone> Anyways, night everyone :P Thanks for the help.
19:59:36 <lambdabot>   Not in scope: `maxbound'
19:59:38 <Luke> they have tons of pdfs and mobi format
19:59:38 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! maxBound
19:59:43 <lambdabot>   mueval-core: Time limit exceeded
19:59:46 <ivanm> bah
19:59:51 <Luke> hah
19:59:59 <luite> Luke: perhaps continue in -blah?
20:00:19 <Luke> sure good call
20:02:36 <Axman6> ivanm: o/
20:02:45 <ivanm> Axman6: \o
20:02:58 <cads> If I'd like to output a formatted table of data consisting of columns of numbers and text, what should I use? Right now I have a program that outputs a very long comma seperated list (thousands of entries), and it does it onto a single line: http://github.com/cads/fbspider/blob/master/output
20:03:29 <Axman6> i got your email
20:03:35 <ivanm> right
20:03:49 <cads> I was thinking of interspersing newline charachters, but what would be nicer would be something for formatting the output into a tab seperated table, I think
20:04:43 <DigitalKiwi> ivanm: http://omploader.org/vM3BjZg
20:05:05 <ivanm> DigitalKiwi: heh
20:05:10 <ivanm> but that's not why I say "bah"
20:05:36 <aavogt> hmm, is porting code to use quickcheck 2 supposed to be this frustrating?
20:05:43 <ivanm> aavogt: from QC1?
20:05:48 <aavogt> yes
20:05:48 <ivanm> *shrug* I've only ever used QC2
20:05:51 <DigitalKiwi> ivanm: bah
20:05:54 <DigitalKiwi> ;D
20:05:54 <cads> I'd also us it eventually for printing out matlab style columns of data from experiments and such
20:06:00 <ivanm> DigitalKiwi: heh
20:06:18 <ivanm> aavogt: all you have to do is define an arbitrary instance
20:06:38 <ivanm> s/instance/implementation/
20:06:48 <ivanm> if you're using large data types though, a shrink implementation is probably a good idea though
20:06:51 <aavogt> ivanm: well the package (ChasingBottoms) is easy enough to build with qc2, but getting the tests included in that package to run with qc2 is another matter
20:07:09 <aavogt> the way to run tests seems to have changed
20:07:20 * ivanm goes to check what he did
20:07:59 <ivanm> aavogt: http://code.haskell.org/graphviz/Data/GraphViz/Testing.hs
20:08:07 <aavogt> there's all this redundant code for running the tests
20:08:27 <ivanm> just do quickCheck prop
20:14:07 <Luke> did anyone see that paper about implementing ML channels in haskell in like 150 LOC?
20:29:03 <ivanm> Axman6: anyway, you OK with that plan?
20:38:28 <Axman6> ivanm: i shall read it again and let you know
20:38:35 <ivanm> k
20:39:13 <Axman6> all sounds good to me
20:39:30 <ivanm> good-o
20:39:35 <ivanm> preflex: seen SubStack
20:39:35 <preflex>  SubStack was last seen on #haskell-blah 6 hours, 59 minutes and 7 seconds ago, saying: considering how we interact with gravity in most circumstances
20:40:01 <ivanm> @tell SubStack your state-based GD module doesn't seem very referentially transparent to me... ST _might_ be a better choice than State for things like this
20:40:02 <lambdabot> Consider it noted.
20:44:20 <ivanm> wtf? about half an hour ago I responded to adamtheturtle on -cafe; now he's just gone and asked the exact same question...
20:44:22 <ivanm> _again_
20:45:23 <Pseudonym> I'm guessing he didn't understand the answer.
20:46:24 <superoptimizer> Beyond http://haskell.org/haskellwiki/Data_Parallel_Haskell and the Nepal paper, are there other places I should look to learn about DPH? I'm very interested in this, and esp. if it's up-to-date WRT LLVM code generation - e.g. is it possible to generate SSE SIMD code for DPH?
20:46:41 <ivanm> I _think_ so
20:46:45 <ivanm> preflex: seen TacticalGrace
20:46:49 <preflex>  TacticalGrace was last seen on #haskell 21 hours, 21 minutes and 3 seconds ago, saying: I will check whether we can get it for those days
20:46:52 <ivanm> superoptimizer: TacticalGrace is the head of the DPH project
20:47:16 <superoptimizer> Okay.
20:47:24 <ivanm> Pseudonym: well, I've made the answer more obvious this time
20:47:33 <TacticalGrace> superoptimizer: in principle it should be possible to use SSE from DPH
20:47:33 * ivanm hates lazy people that expect to be spoon fed
20:47:39 <TacticalGrace> but we cirrently don't do that
20:48:25 <ivanm> TacticalGrace: benl23 got back to me and said he's booked the room; I'll be emailing out the "official" date announcement tonight
20:48:27 <TacticalGrace> (simply because out current focus is on multicore parallelism for irregular dataparallel programs)
20:48:41 <TacticalGrace> ivanm: great!
20:49:21 <superoptimizer> TacticalGrace: I see. Vector codegen in LLVM isn't completely robust at this point. Last LLVM developer meeting I collected a laundry list of issues, and I don't think most/many have been fixed at this point.
20:50:05 <superoptimizer> TacticalGrace: Most basic things should work, and I was hoping that they would through DPH as well. I'm mostly interested in some prototyping.
20:53:22 <TacticalGrace> superoptimizer: one reason for our interest in a GHC LLVM backend (this was done by one of our students) is that it might give use access to SSE SIMD
20:54:06 <TacticalGrace> but we haven't really done anything about it yet (the LLVM backend isn't even in GHC yet after all)
20:54:12 <TacticalGrace> bbl
20:58:30 * hackagebot gitit 0.7.3.4 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.4 (JohnMacFarlane)
21:00:33 <ddarius> TacticalGrace: What's with the new nick by the way?
21:16:40 * hackagebot rope 0.1 - Tools for manipulating annotated ropes of bytestrings  http://hackage.haskell.org/package/rope-0.1 (EdwardKmett)
21:17:07 * edwardk looks up bleary eyed and triumphant. now i just need to write all the code that uses it ;)
21:18:01 <ivanm> edwardk: "ropes"?
21:18:25 <edwardk> ivanm: annotate fingertrees of utf8 encoded text basically
21:18:28 <edwardk> er annotated
21:18:45 <edwardk> or are you suggesting a better package name>
21:18:49 <ivanm> as in for sequence type stuff?
21:19:00 <ivanm> no, trying to work out wtf it does ;-)
21:19:12 <ivanm> * I mean as in a fingertree-style sequence
21:19:18 <edwardk> ah
21:19:42 * hackagebot xhtml-combinators 0.1 - Fast and easy to use XHTML combinators.  http://hackage.haskell.org/package/xhtml-combinators-0.1 (AlasdairArmstrong)
21:19:43 <edwardk> hrmm, a Rope (), works a bit like an efficient Seq Char, so you could look at it that way
21:20:13 <edwardk> the gist is this, a Rope is a fingertree of bytestrings, with an extra 'annotation' of type a.
21:20:26 <jeffwheeler> @pl interestingKey k = (k == "SID") || (k == "Error")
21:20:27 <lambdabot> interestingKey = liftM2 (||) ("SID" ==) ("Error" ==)
21:20:30 <edwardk> Annotations know how to trim themselves when you edit the rope
21:20:41 <ivanm> right
21:20:44 <edwardk> they have access to the current rope as context via a context comonad
21:20:46 <ivanm> what are the annotations for?
21:20:57 <ivanm> and the wikipedia page seems to assume that String = Array Char
21:21:40 <edwardk> lets take for instance that you start with a simple rope of text, you run it through a c preprocessor (which could be done inside of this framework, but just for sake of discussion, is done externally)
21:21:44 <edwardk> now you have text with #line pragmas
21:22:23 <ivanm> as in you filter all segments that don't start with #line ?
21:22:27 <edwardk> you might build an annotation out of a map of byte #'s to 'interesting position changes', and collapse the bytestring over the #line pragmas
21:22:44 <edwardk> so that the line pragmas are now gone from the bytestring, but are captured in the annotation
21:23:04 <ivanm> hmmm...
21:23:05 <edwardk> so you can now come back over the bytestring with a dumb parser that isn't aware of all the vagaries of the c preprocessor
21:23:23 <ivanm> so it's basically metadata of the string?
21:23:24 <edwardk> and when you hit errors, you can just take the offset, and look it up through the position tree
21:23:35 <ivanm> and is the annotation on the overall fingertree or per-element?
21:23:39 <edwardk> and get back a line and column, and the include path, etc.
21:24:14 <edwardk> the annotations are attached along side of the tree, so instead of fingertree (bytestring * annotation) it is fingertree bytestring * annotation
21:24:26 <edwardk> that lets you not pay for any annotation you aren't using
21:24:40 <edwardk> because a rope is a functor, and you can just strip off the annotations you don't care about
21:24:51 <ivanm> right
21:25:17 <ivanm> so when you combine ropes you also need something to combine annotations with
21:25:26 <dibblego> when I System.Process.createProcess "bash" I cannot see stdout, how can I fix this?
21:25:36 <edwardk> yep, annotations should be monoidal
21:25:54 <edwardk> there is some extra machinery required of them
21:26:00 <edwardk> but that is the first requirement
21:26:11 <ivanm> dibblego: maybe use runInteractiveProcess?
21:26:33 <dibblego> ivanm, I need to pass env vars
21:26:40 <ivanm> and by "I cannot see stdout", do you mean the stdout of the process you're runing can't be seen within the calling program or by the user?
21:26:50 <ivanm> edwardk: *nod*
21:27:02 <dibblego> I mean, when I type, I cannot see what I am typing
21:27:04 <ivanm> sounds intriguing; I don't think I"m likely to have any use for them, but it sounds intriguing
21:27:13 <ivanm> dibblego: ahhh
21:27:20 <m3ga> other than vi/vim/emacs what editors are people using on linux systems? must be open source.
21:27:23 <ivanm> you probably need to echo out the stuff you're reading in again
21:27:30 <edwardk> runInteractiveProcess allows you to pass an optional environment, no?
21:27:43 <ivanm> m3ga: kate, gedit, nano, scite
21:27:53 <ivanm> there's also kdevelop and eclipse as IDEs
21:28:08 <dibblego> edwardk, so it does
21:28:12 <aavogt> could it help to set different buffering?
21:28:22 <ivanm> aavogt: could be that
21:28:40 <dibblego> runInteractiveProcess returns me to the ghci prompt
21:28:58 <m3ga> installing kate pulls in libxine, gedit is horrible and nano is so 1982. are you actually *using* any of these? :-)
21:29:36 <edwardk> ivanm: i'm basically using it so i can run dumb passes that don't need robust error handling internally, and externalize the error locations in fancy ways, so given a byte location in the macro expanded stream i can tell you it came from a macro in file xyz line 10, included from file bar line 102, expanded with args from ... and provide you with little syntax snippets
21:29:38 <ivanm> dibblego: what are you actually trying to do?
21:29:48 <ivanm> it sounds like you want the Prompt monad or something
21:29:59 <ivanm> edwardk: *nod*
21:30:01 <dibblego> ivanm, I want a terminal with environment variables set, for both windows and not-windows
21:30:03 <edwardk> dibblego: well, ghci is an interactive process ;)
21:30:26 <dibblego> edwardk, I tried ghc -e as well, it just returned
21:30:32 <ivanm> you're writing your own terminal?
21:30:48 <dibblego> no, I'm setting env vars instead of using x.sh and x.cmd to do it
21:32:02 <ivanm> dibblego: oh, you're writing a program to set variables and then exit
21:32:08 <ivanm> with those variables remaining afterwards?
21:32:12 <dolio> edwardk: Does this mean your parsing-library-to-end-all-parsing-libraries is going to be out soon?
21:32:13 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
21:32:14 <dibblego> yes
21:32:23 <ivanm> AFAIK, most things like that that set variables are typically just for that program/session
21:32:23 <dibblego> ivanm, is it possible?
21:32:27 <edwardk> dolio: well, this is sort of a tangent =)
21:32:35 <edwardk> but it is making writing swathes of kata much easier =)
21:32:38 <ivanm> e.g.: FOO="bar" echo $FOO
21:32:40 <dolio> Ah.
21:32:45 <ivanm> after you run that, FOO is unset again
21:32:53 <ddarius> Swathes you've already written?
21:32:58 <ivanm> dibblego: so no, I don't think so
21:33:01 <dibblego> ivanm, this is a very nasty set up
21:33:04 <dibblego> ok
21:33:09 <dolio> I guess you need to come up with an unused name before you can release anyway.
21:33:18 <dolio> How about: parsimmon?
21:33:25 <edwardk> nah, this is letting me finally get that macro system i've been kicking around ideas for for a long time
21:33:27 <lpjhjdh> cabal obviously has stuck some stuff in .cabal, can I tell it to remove those or should I just nuke'em by hand?
21:33:28 <ivanm> dibblego: e.g. if you have a bash script and you have "export FOO=bar", it's valid throughout the script; yet even when you run it it isn't set
21:33:35 <ivanm> you have to source the script to have the variables persist
21:33:43 <ivanm> lpjhjdh: huh?
21:33:45 <dibblego> ivanm, right, except on windows
21:33:54 <ivanm> dibblego: don't know about windows, however
21:34:08 <ivanm> dibblego: hang on, lemme check something
21:34:27 <edwardk> only annoying thing about hackage is it doesn't update the docs very frequently =)
21:34:30 <lpjhjdh> ivanm: err, cabal-install
21:34:39 <lpjhjdh> the thing that gives me the cabal executable
21:34:46 <ivanm> lpjhjdh: I understood that much, I'm just not sure what you're asking
21:34:54 <ivanm> what are you wanting to remove?
21:35:18 <lpjhjdh> there was some stuff installed into ~/.cabal and I was wondering if I can tell cabal (the executable) to get rid of it based on some package name
21:35:20 <deech> Hi all, is there some way to pattern match string argument like : someFunction "hello" = doSomething
21:35:27 <lpjhjdh> I have no regrets just blasting it with rm
21:36:10 <kmc> deech, yes, precisely that
21:36:19 <ivanm> dibblego: I wonder if finishing with system or something would work...
21:36:20 <kmc> > let f "foo" = 3; f _ = 4 in (f "foo", f "bar")
21:36:22 <lambdabot>   (3,4)
21:36:31 <ivanm> lpjhjdh: cabal-install can't uninstall stuff yet
21:36:36 <dibblego> ivanm, I may have a hack
21:36:50 <lpjhjdh> ivanm: ok, thanks, I probably should have phrased it that way to begin with :)
21:36:56 <kmc> deech, "foo" is sugar for ['f', 'o', 'o'] which is sugar for ('f' : 'o' : 'o' : []) which is an ordinary pattern made of (infix) constructor applications
21:37:00 <ivanm> lpjhjdh: you should first unregister those packages from ghc-pkg (ghc-pkg unregister foo-version)
21:37:05 <ivanm> but you probably want to keep ~/.cabal/config
21:37:11 <ivanm> dibblego: oooohhh
21:37:12 <deech> oh wait, I meant something like : someFunction "hello":restOfString = doSomething
21:37:31 <aavogt> @type stripPrefix
21:37:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
21:37:32 <kmc> for that you'd have to write 'h':'e':'l':'l':'o':rest = foo
21:37:42 <aavogt> no, use view patterns:
21:37:56 <kmc> yeah, there are better ways
21:38:06 <aavogt> > case "hellothere" of (stripPrefix "hello" -> Just rest) -> rest
21:38:07 <lambdabot>   Illegal view pattern:  (stripPrefix "hello" -> Just rest)
21:38:07 <lambdabot>  Use -XViewPatter...
21:38:12 <aavogt> :(
21:38:12 <deech> kmc: ok, I already had that, I was looking for a more convenient way.
21:38:20 <ivanm> aavogt: :o
21:38:51 <aavogt> here the view patterns don't make it cleaner, but sometimes they help quite a bit
21:38:56 <deech> aavogt: I thought view patterns went into the function arguments not the body.
21:39:12 <kmc> view patterns are just another kind of pattern
21:39:13 <aavogt> deech: they go wherever you may put patterns
21:39:26 <deech> aavogt: oh, cool.
21:39:29 <aavogt> of course they are kind of crippled in lambdas
21:39:34 <TacticalGrace> ddarius: consolidating nicks...it's my twitter handle
21:39:40 <TacticalGrace> :)
21:39:46 <edwardk> heh
21:39:51 <ivanm> TacticalGrace: couldn't you get ChilliX as your twitter handle?
21:39:54 * hackagebot texmath 0.2.0.1 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.2.0.1 (JohnMacFarlane)
21:39:54 <kmc> > case "hellothere" of xs | (("hello", ys) <- splitAt 5 xs)  -> ys
21:39:55 <lambdabot>   <no location info>: parse error on input `<-'
21:40:01 <kmc> hmm pattern guard?
21:40:04 <ivanm> TacticalGrace: note that your user page on the haskell wiki still says ChilliX
21:40:39 <TacticalGrace> ivanm: that's the other thing, ChilliX was always only a compromise, because Chilli was already taken on freenode
21:40:46 <TacticalGrace> ivanm: ohm ok
21:40:56 <edwardk> i had fun with view patterns and CPP macros the other day, generating things like (# I# -> a, I# -> b #) = measure c -- i didn't expect the view patterns to work in such a bizarre setting but they hummed right along
21:41:58 <dibblego> ivanm, I don't; I thought I could execute a specific shell command and pass env vars
21:41:59 <TacticalGrace> ivanm: fixed the wiki page
21:42:00 <ivanm> why Chilli anyway?
21:42:23 <ivanm> dibblego: yeah, probably not unfortunately
21:42:23 <TacticalGrace> that's the nick I used forever
21:42:28 <ivanm> TacticalGrace: *nod*
21:42:34 <TacticalGrace> since I've been on irc
21:42:37 <ivanm> so where/how did you come up with this new one?
21:43:30 <TacticalGrace> ivanm: it's from a novel
21:43:42 <edwardk> kmc: remove the outermost parens
21:43:43 <TacticalGrace> Excession by Iain M. Banks
21:43:50 <aavogt> edwardk: that's what it expands to?
21:44:49 <aavogt> yet another case where modern ghc extensions let you write so many arrows:   (f -> x) | Y z <- x -> z
21:44:53 <edwardk> aavogt: yeah. http://comonad.com/haskell/buffer/include/measure.h
21:45:18 <kmc> > case "hellothere" of xs | ("hello", ys) <- splitAt 5 xs -> ys
21:45:19 <lambdabot>   "there"
21:45:25 <kmc> meh it would be more readable with the parens allowed
21:45:41 <aavogt> it's easy to get the count for splitAt wrong though
21:45:55 <dibblego> ivanm, I take it back, I think my workaround can work
21:46:04 <ivanm> \o/
21:46:04 <kmc> yeah
21:46:06 <ivanm> what are you doing?
21:46:10 <aavogt> hence the addition of stripPrefix
21:46:10 <ivanm> TacticalGrace: ahhh
21:46:36 <aavogt> which would be unnecessary if we had variations on zip that gave you the leftovers
21:47:25 <ivanm> aavogt: I sometimes want that...
21:47:50 <aavogt> something like    zipRest :: [a] -> [b] -> ([(a,b)],Maybe (Either [a] [b]))
21:47:53 <ivanm> zipWith' :: (a -> b -> c) -> [a] -> [b] -> ([c], Either [a] [b])
21:47:56 <aavogt> hmm, that's unweildy
21:48:01 <edwardk> case splitAt 5 "hellothere" of "hello" -> ... would also work and would require less pain ;)
21:48:08 <ivanm> actually, that won't work; need to return Nothing or something if they're of equal length...
21:48:23 <aavogt> @wn unweildy
21:48:24 <lambdabot> No match for "unweildy".
21:48:28 <aavogt> @wn unwieldy
21:48:29 <lambdabot> *** "unwieldy" wn "WordNet (r) 2.0"
21:48:29 <lambdabot> unwieldy
21:48:29 <lambdabot>      adj 1: difficult to use or handle or manage because of size or
21:48:29 <lambdabot>             weight or shape; "we set about towing the unwieldy
21:48:29 <lambdabot>             structure into the shelter"; "almost dropped the
21:48:31 <lambdabot> [5 @more lines]
21:48:47 <ddarius> "i before e except after c"
21:48:51 <ivanm> aavogt: EitherEmpty a b = | Neither | HasLeft a | HasRight b ?
21:48:52 <ivanm> ;-)
21:49:00 <Fallen_Demon> ivanm, haskell hackfest thingy
21:49:05 <ivanm> Fallen_Demon: shoot
21:49:23 <Fallen_Demon> Any haskell in particular that it'd be good to learn beforehand?
21:49:29 <Fallen_Demon> I haven't used it since 2600
21:49:30 <aavogt> ddarius: there are enough exceptions that it almost isn't worth bothering
21:49:35 <aavogt> me neither oO
21:49:50 <ivanm> Fallen_Demon: you haven't used it since the future? :p
21:50:01 <Fallen_Demon> :P
21:50:16 <Fallen_Demon> I assumed ANU = Know about Clem's courses, sorry
21:50:23 <ivanm> oh...
21:50:32 <ivanm> Fallen_Demon: I just started my PhD here; I'm from Brisbane ;-)
21:50:32 <Fallen_Demon> I haven't used it for a while
21:50:38 <Fallen_Demon> Oh, OK XD
21:50:44 <ivanm> what kind of software you wanting to hack on?
21:50:58 * ivanm wonders where demons fall down to...
21:51:02 <dolio> Or when sounding like 'a' as in neighbor and weigh.
21:51:05 <Fallen_Demon> I would like to have a browse through the LLVM thing
21:51:18 <ivanm> dolio: and there's yet another exception IIRC
21:51:27 <dolio> Are there more than those two?
21:51:29 <ivanm> Fallen_Demon: hmmm.... I can't help you there then because I haven't looked
21:51:32 <ivanm> maybe ask TacticalGrace
21:51:37 <Fallen_Demon> Hrmm, ok
21:52:00 <Fallen_Demon> Well, I'll get back into and drag out my bot again xD
21:52:00 <Fallen_Demon> into it*
21:52:06 <ivanm> dolio: e.g. "unless you're being weird"
21:52:12 <ivanm> http://en.wikipedia.org/wiki/I_before_e_except_after_c
21:52:46 <ivanm> Fallen_Demon: did you read RWH when it came out?
21:52:46 <dolio> I guess there's also Peirce, but that's a name.
21:52:53 <Fallen_Demon> RWH?
21:52:57 <Fallen_Demon> Probably not :P
21:53:20 <Fallen_Demon> I've been away from Haskell for a long time
21:53:28 <ivanm> @where RWH
21:53:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:53:34 <ivanm> there's a free version on the website
21:53:42 <ivanm> (as in HTML)
21:53:43 <Fallen_Demon> Cool :) Thanks
21:53:49 <ivanm> or there's the actual book (dead tree + ebook)
21:53:58 <dolio> ivanm: I like to use the rule: "just know how to spell things."
21:54:05 <dibblego> ivanm, I don't suppose you know if I can ask the system if I am on windows?
21:54:07 <ivanm> dolio: heh
21:54:13 <ivanm> dibblego: not really :s
21:54:21 <dibblego> ok ta
21:54:26 <ivanm> dibblego: surely one of the system functions lets you get OS info though
21:54:43 <Blaine_> what does "Ambiguous type variable `t' in the constraints:" mean?
21:55:05 <dibblego> it means you should explicitly specify the type due to the monomorphism restriction
21:55:08 <ivanm> dibblego: System.Info.os
21:55:11 <ivanm> @hoogle os
21:55:12 <lambdabot> System.Info os :: String
21:55:12 <lambdabot> Prelude acos :: Floating a => a -> a
21:55:12 <lambdabot> Prelude acosh :: Floating a => a -> a
21:55:12 <dibblego> ivanm, ta
21:55:19 <ivanm> > System.Info.os
21:55:21 <lambdabot>   Not in scope: `System.Info.os'
21:55:23 <ivanm> bah
21:55:49 <aavogt> so now to argue over whether that one violates referential transparency?
21:56:13 <ivanm> aavogt: arguably, yes
21:56:20 <dibblego> Of course not. They are different Haskell versions!
21:56:21 <ivanm> but it's built in at compile time (of GHC)
21:56:28 <ivanm> dibblego: heh
21:56:53 <Traveler2> Hello
21:57:00 <kmc> hi
21:57:01 <ivanm> Fallen_Demon: and we're going to make it 16-18 July
21:57:09 * ivanm waves idly in Traveler2's general direction
21:57:20 <aavogt> hacking in oz?
21:57:45 <ivanm> yup
21:58:00 <Fallen_Demon> Awesome ^_^
21:58:02 <Traveler2> I'm doing an introductory computing course in Haskell, I need a bit of help
21:58:03 <ivanm> Traveler2: don't even think about asking any questions about Clem's assignment...
21:58:17 <ivanm> why not ask your tutor, go to a drop in session or use the forums?
21:58:22 <Fallen_Demon> Lol
21:58:24 <kmc> hehe
21:58:25 * ivanm laughs evilly at his power
21:58:28 <aavogt> because ivanm is your tutor?
21:58:39 <kmc> o snap
21:58:41 <ivanm> aavogt: doubt it; he's logged in from uni atm
21:58:41 <Fallen_Demon> I'm out in the CS lobby if you need some help, Traveler2
21:58:53 <ivanm> and my tutorial is on wednesday arvos
21:58:53 <kmc> Traveler2, we'll answer your questions anyway ;)
21:59:12 <Traveler2> I'm not going to ask for help explicitly, I just want some hints on how to do things
21:59:21 <aavogt> we'll be sure to give convoluted answers
21:59:34 <Fallen_Demon> Hang on, I'll check the thing.... I need to get back into it :)
21:59:37 <ivanm> shoot
22:00:49 <cads> What does the !(_) type constructor do? example: labels :: !(IntMap a)
22:00:50 <Fallen_Demon> Errgh, what idiot hasn't packaged GHC for opensuse?
22:01:00 <aavogt> cads: strictness
22:01:00 <ivanm> cads: forces it
22:01:05 <ivanm> well, to whnf
22:01:11 <sjanssen> Fallen_Demon: I guess every idiot?
22:01:12 <ddarius> It's not a type constructor.
22:01:27 <kmc> i don't think it's valid in a signature like that
22:01:32 <ivanm> cads: it's equivalent to { labels = a `seq` a }
22:01:45 <kmc> err isn't (a `seq` a) equivalent to a?
22:01:46 <ivanm> kmc: looks like a record definition
22:01:49 <kmc> oh
22:01:52 <aavogt> ivanm: really?
22:01:57 <aavogt> I disagree
22:01:59 <ivanm> aavogt: pretty sure it is
22:02:03 <cads> Yeah, it's record syntax: data Graph a = Graph { labels :: !(IntMap a) , childrens :: !(IntMap [Int]) } deriving (Show,Read)
22:02:05 <ddarius> x `seq` x === x
22:02:09 <ivanm> it's not to WHNF ...
22:02:12 <kmc> «data Foo = Bar !Int» has the property that, if a Foo is reduced to whnf, the Bar inside is also reduced to whnf
22:02:30 <ivanm> cads: *sigh* you're not creating yet another graph datatype are you?
22:02:37 <ivanm> s/WHNF/RNF/
22:02:38 <aavogt> ivanm: is's more like      a `seq` x { labels = a }
22:02:38 <ddarius> cads: That means the two fields are Graph are strict.
22:02:49 <ivanm> aavogt: hmmm.... yeah, I suppose
22:02:51 <kmc> cads, yes, that says that if you've evaluated a (Graph a) far enough to see the data constructor Graph, then you're guaranteed that the labels and childrens fields inside are also evaluated to weak head normal form
22:02:54 <ivanm> you get what I mean anyway ;-)
22:03:10 <ivanm> Traveler2: well, go on, ask!
22:03:11 <aavogt> well seq is tricky
22:03:45 <aavogt> it's not every day you get to introduce fictitious data dependencies
22:03:52 <ivanm> heh
22:04:03 <cads> ivanm, I was actually wondering if there was somthing more canonical I could replace this graph type with, but I think it would require overhauling the whole program, so not a project for tonight
22:04:13 <ivanm> fair enough
22:04:18 <cads> this is still someone else's code besides mine :)
22:04:25 <ivanm> aha
22:08:22 <aavogt> other people's code tends to be scary
22:08:39 <cads> So this seems to be a definition of a graph where each node is labeled indexed by an integer and is associated to a label by the label map which maps the integers to the labels. The childrens map must map a node's index to a list of the indices of other nodes.
22:09:00 <cads> remove that first "labeled"
22:09:22 <aavogt> but mine is the same if I come back to it a couple months later
22:11:58 <cads> Hmm, I left out that each element  index -> indices of the children map must correspond to edges between the node corresponding to index and the nodes corresponding to the indices in the list.
22:12:11 <cads> aavogt, you're right, this is terrifying
22:12:46 <cads> this graph is being operated upon in the state monad, I believe
22:14:07 <cads> (the haskell cheatsheet doesn't cover this  >:P
22:14:21 <aavogt> whose cheatsheet?
22:14:39 <aavogt> the state monad shouldn't be too bad...
22:14:45 <cads> Justin Bailey
22:15:05 <cads> http://blog.codeslower.com/static/CheatSheet.pdf
22:15:20 <aavogt> I've seen that one before
22:16:20 <cads> it seems like the most popular one
22:16:25 <cads> hmm, I haven't even checked out others
22:16:42 <Veinor> Just "in Bailey"
22:16:59 <cads> oh brother :)
22:17:18 <cads> Veinor, you're done
22:17:33 <Veinor> :D
22:19:37 <aavogt> cads: convince haddock to make some docs for your code, then click the links until you've read all the relevant library documentation
22:20:30 <dankna> Copyright Justin Bailey?  That rules!
22:21:09 * aavogt wonders how that works for the suggestions people gave him
22:21:23 <cads> aavogt, would it be difficult to make it compile docs for all of the imported functions relevant to this program?
22:21:34 <aavogt> I don't know
22:22:16 <aavogt> if you build the whole project with cabal and have --enable-docs (or somesuch), then you get most links done correctly
22:22:44 <aavogt> but if the depending libraries aren't built with documentation it's almost easier to just remove them first
22:23:09 <cads> aavogt, I think people giving suggestions to an author freely then it's no problem for him to compile their suggestions in his own words and copyright it, but it would be interesting to know for sure
22:24:13 <cads> Wow I need sleep, my english is degrading terribly.
22:24:15 <aavogt> yeah, I'm ok with the handling of my couple suggestions
22:24:29 <aavogt> no, fix your code!
22:24:56 <cads> hah, 'adam voght' - you're attributed
22:25:15 <cads> in the contributors section
22:26:49 <Veinor> I should get a haskell wiki account.
22:27:09 <ivanm> preflex: seen kowey
22:27:09 <preflex>  kowey was last seen on #haskell 12 days, 17 hours, 33 minutes and 56 seconds ago, saying: hmm, the GHC manual seems to give an idea - http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/other-type-extensions.html
22:27:19 <aavogt> well they are only useful if you want to write something
22:27:37 <Veinor> yes, but if I get one, then when I decide to write somehting I don't have that barrier in my way :D
22:27:53 <ivanm> @tell kowey I'm hoping to have a release of graphviz with record label support out by easter (I'm actually spending most of my time getting the HTML label support working :s)
22:27:53 <lambdabot> Consider it noted.
22:28:34 <Fallen_Demon> Is lambdabot's source available?
22:29:16 <aavogt> @help
22:29:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:29:18 <aavogt> @version
22:29:19 <lambdabot> lambdabot 4.2.2.1
22:29:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:29:27 <Fallen_Demon> Awesome, thanks :)
22:29:39 <Blaine_> can someone tell me why this code explodes and how to fix it? http://gist.github.com/339818
22:29:49 <ivanm> Fallen_Demon: so, did Traveler2 end up going to find you and ask you stuff in person?
22:29:56 <Fallen_Demon> Nope
22:29:58 <Fallen_Demon> XD
22:30:07 <Fallen_Demon> Or if he did, he didn't try very hard
22:30:09 <ivanm> hmmm, didn't ask here either
22:30:23 <ivanm> *shrug* obviously didn't want an answer :p
22:30:53 <Fallen_Demon> lol
22:30:55 <aavogt> @type ceiling . sqrt . fromIntegral
22:30:56 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
22:31:02 <Fallen_Demon> Pride is a fickle beast
22:31:12 <aavogt> ^^ Blaine_ use this instead for you integer sqrt
22:31:48 <Blaine_> ceiling . sqrt . fromIntegral n?
22:31:52 <ivanm> no
22:32:00 <ivanm> ceiling . sqrt . fromIntegral $ n
22:32:04 * Blaine_ knows nothing about function composition x.x
22:32:32 <ivanm> Blaine_: " if x `mod` n == 0 then True else False " can be simplified
22:32:48 <pippijn> ghc links with -lutil
22:32:53 <pippijn> is that something haskell related?
22:33:01 <pippijn> I have a libutil myself and linking to that breaks things
22:33:03 <ivanm> as can your guard in isPrime
22:33:11 <ivanm> pippijn: never heard of it
22:33:12 <Blaine_> how so?
22:33:13 <pippijn> hm
22:33:16 <ivanm> so I don't think it's a C lib
22:33:28 <ivanm> Blaine_: think about the types involved
22:33:42 <ivanm> if _Bool_ then _Bool_ else _Bool_
22:34:27 <ivanm> Blaine_: I also have the sneaking suspicion that your code will say that 16 is prime
22:35:01 <pippijn> I don't know why it's even linking against it :(
22:35:29 <pippijn> I don't have it listed in my cabal file
22:35:49 <pippijn> it's used exactly once in my makefiles
22:35:59 <pippijn> and that's when linking another binary
22:36:18 <ivanm> pippijn: I thought you meant that when building ghc it was linking against util ...
22:36:21 <cads> Ahahahahah, I understand the code now. Hehe, saizan will be pissed at my mangling of his code, but as far as I'm concerned it's MINE NOW, huhuhu
22:36:42 <pippijn> no
22:36:50 <pippijn> ghc links my program against libutil
22:36:56 <ivanm> *shrug*
22:37:13 <pippijn> ghc -v doesn't hint
22:37:19 <pippijn> except
22:37:21 <ivanm>  l/lib/libutil.so ?
22:37:34 <pippijn> it's there along with -lrt and -ldl
22:37:45 <pippijn> oh
22:37:47 <pippijn> look at that
22:37:52 <pippijn> there is a /usr/lib/libutil.so
22:38:12 <Blaine_> the odd thing is... it works if I do something like... if divisibleByAny 101, [3, 5..(ceiling (sqrt 101))] == True then False else True
22:38:13 * pippijn renames his libutil to libutility
22:38:21 <Blaine_> well, odd to me
22:38:27 <Blaine_> I don't know the reasoning behind it
22:39:06 <ivanm> Blaine_: huh?
22:39:17 <ivanm> @type 101
22:39:18 * hackagebot texmath 0.2.0.2 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.2.0.2 (JohnMacFarlane)
22:39:19 <lambdabot> forall t. (Num t) => t
22:39:21 <kmc> think about what "== True" does
22:39:23 <ivanm> ^^ it's a valid Double as well
22:39:27 <kmc> > (== True)
22:39:29 <lambdabot>   {True->True;False->False}
22:41:02 * Blaine_ sulks his way back to learnyouahaskell.com
22:42:19 * hackagebot texmath 0.2.0.3 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.2.0.3 (JohnMacFarlane)
22:42:32 <Fallen_Demon> -_-
22:42:45 <Fallen_Demon> Raging so hard at openSUSE right now >_<
22:42:57 <Fallen_Demon> No GHC packages, I need to bootstrap the whole platform
22:44:35 <cads> Fallen_Demon, strength!
22:45:00 <Fallen_Demon> cads, SPEED! AGILITY!
22:45:05 <Fallen_Demon> They aren't me :P
22:45:11 <Fallen_Demon> I'm a pasty computer geek
22:45:25 <cads> man, I was ENDOWING you with strength, SHAZAM
22:45:59 <ivanm> Fallen_Demon: http://download.opensuse.org/repositories/devel:/languages:/haskell/ ?
22:46:08 <ivanm> and http://en.opensuse.org/Packaging/Haskell
22:46:21 <cads> yum
22:46:22 <Fallen_Demon> Oh damn -_-
22:46:35 <Fallen_Demon> I looked it up with zypper search
22:46:42 <Fallen_Demon> Couldn't find ghc anywhere :(
22:46:47 <cads> not that building it would have hurt ya
22:47:06 <aavogt> it tends to be painful though
22:47:15 <Fallen_Demon> Nah, I've almost got it downloaded now :P
22:47:20 <pippijn> so it does hurt!
22:47:23 <Fallen_Demon> It'll give me something to do tonight
22:47:32 * pippijn is building a C++ compiler
22:47:40 <Fallen_Demon> g++?
22:47:43 <pippijn> no
22:47:58 <pippijn> edg
22:48:13 <Fallen_Demon> I should do more C++
22:48:18 <Fallen_Demon> I avoid it generally
22:48:20 <ivanm> remember the karma! refer to it as C\+\+ ! :p
22:48:27 <Fallen_Demon> XD
22:48:36 <pippijn> g\+\+
22:48:56 <ivanm> @karma g
22:48:56 <lambdabot> g has a karma of 206
22:49:00 <ivanm> tsk, tsk
22:49:09 <pippijn> @karma c
22:49:09 <lambdabot> c has a karma of 1
22:49:10 <pippijn> :D
22:49:22 <pippijn> people don't speak about it a lot here, do they?
22:49:32 <pippijn> or maybe they also speak about c-- a lot
22:50:08 <edwardk> ivanm: iirc the karma doesn't change unless it is the first thing on the line.
22:50:19 <ivanm> you sure about that?
22:50:24 <ivanm> @karma lambdabot
22:50:25 <lambdabot> lambdabot has a karma of -4
22:50:30 <pippijn> @karma c
22:50:30 <lambdabot> c has a karma of 1
22:50:33 <pippijn> c--
22:50:34 <pippijn> @karma c
22:50:34 <lambdabot> c has a karma of 1
22:50:39 <ivanm> let's see if this raises the karma of lambdabot++
22:50:40 <pippijn> C is locked :(
22:50:42 <ivanm> @karma lambdabot
22:50:43 <lambdabot> lambdabot has a karma of -3
22:50:46 <edwardk> i also think 'c' was locked yeah
22:50:50 <ivanm> edwardk: methinks you're wrong
22:51:46 <edwardk> ivanm: i may very well be. i just recall a bunch of folks sitting on channel here trying things with lambdabot and that being the case at the time. *shrug* lots of things that lambdabot used to do are broken down and busted these days ;)
22:52:01 <Fallen_Demon> 1 minute until I have the GHC source >:D
22:52:16 <pippijn> 1 hour until my compiler is done
22:52:23 * ivanm figures it's time he called it today
22:52:30 <ivanm> and tomorrow I should really make sure I dont' use IRC... :s
22:52:44 <pippijn> oh, an addict?
22:52:51 <ivanm> to procrastination, yes
22:53:02 <edwardk> ivanm: likewise =)
22:53:37 <ivanm> anyway, bye all
22:53:45 <aavogt> :(
22:53:48 <aavogt> bye ivanm
22:53:53 <ivanm> aavogt: don't you want me to go? :p
22:54:28 * ivanm notices that adamtheturtle hasn't responded back to -cafe since he mentioned the `H' word...
22:54:49 <aavogt> ivanm: well I guess it's your loss
22:55:05 <ivanm> aavogt: between staying at uni and going home?
22:55:09 * ivanm picks home
22:55:22 <ivanm> for starters, there's a steak that's awaiting to be cooked...
22:55:38 <ivanm> that reminds me, where has copumpkin gone off to? I dont' recall him being online this weekend...
22:55:44 <ivanm> preflex: xseen copumpkin
22:55:45 <preflex>  copumpkin was last seen on freenode/#haskell 2 days, 7 hours, 37 minutes and 6 seconds ago, saying: that seems like an odd type for an "is" function
22:55:52 <ddarius> edwardk: If you look at that Formal Category Theory book, beware a typo in an otherwise nice definition of fibration that says a functor is a right adjoint right inverse but should be a left adjoint right inverse.
22:56:16 * ivanm really goes this time
22:56:27 <jeffwheeler> @pl \s -> (readStringAttr "id" s >>= parseLabel)
22:56:27 <lambdabot> (parseLabel =<<) . readStringAttr "id"
23:02:46 <jeffwheeler> I feel like I'm repeating myself a lot in this code snippet, with 'case' statements matching one type constructor, and if it doesn't match, simply going with a Nothing value: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24235#a24235
23:02:55 <jeffwheeler> Is there a better way to test for a constructor like that?
23:04:09 <kmc> do { JSString s <- readJSField field obj; return $ fromJSString s }
23:04:18 <kmc> you're in the Maybe monad; pattern-match failure will result in Nothing
23:04:38 <jeffwheeler> kmc: oh, hmm; for some reason I was thinking a pattern-match failure would result in an error
23:04:43 <jeffwheeler> Let me play with that
23:04:43 <kmc> let me check
23:04:46 <kmc> > do { (x:xs) <- Just []; return x }
23:04:47 <lambdabot>   Nothing
23:05:01 <jeffwheeler> Oh, that's awesome. I don't know why I was thinking that.
23:05:03 <jeffwheeler> Thanks!
23:05:08 <kmc> pattern match failure in "do" is handled via "fail"
23:05:16 <jeffwheeler> I see, that makes a lot of sense.
23:05:17 <kmc> which is a member of the Monad typeclass (somewhat unfortunately but eh)
23:05:20 <edwardk> ddarius: good to know
23:05:30 <jeffwheeler> that simplifies my code a lot :)
23:05:33 <kmc> also in readJSField you can just pattern match it in the function definition
23:05:47 <jeffwheeler> kmc: oh, yep; good catch
23:06:05 <jeffwheeler> (I'm really excited for this code. I love Google Reader, and I didn't realize how easy this was.)
23:07:55 <edwardk> jeffwheeler: why not write a combinator that does that for you?
23:08:05 <jeffwheeler> edwardk: does what for me?
23:08:36 <edwardk> What is the type you keep pattern matching on?
23:09:04 <jeffwheeler> edwardk: JSValue, from the 'json' package
23:09:10 <jeffwheeler> http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html
23:10:00 <edwardk> ah, i was looking at the repeated Ok t -> ...; _ -> Nothing blocks
23:10:43 <jeffwheeler> edwardk: well, that's pretty much the same problem, and resolved in the same way, but a different type
23:11:24 <edwardk> resultToMaybe :: (a -> b) -> Result a -> Maybe b; resultToMaybe f (OK a) = Just a; resultToMaybe  _ _ = Nothing
23:11:58 <edwardk> tags sid = resultToMaybe readTags <$> apiCall "tag/list?output=json" sid
23:12:33 <jeffwheeler> @type <$>
23:12:34 <lambdabot> parse error on input `<$>'
23:12:40 <jeffwheeler> :t <$>
23:12:41 <lambdabot> parse error on input `<$>'
23:12:44 <kmc> :t (<$>)
23:12:46 <edwardk> (<$>) = fmap
23:12:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:13:11 <kmc> edwardk, you're not using f
23:13:21 <edwardk> oh oops, Just (f a) =)
23:13:36 <jeffwheeler> edwardk: that's really quite beautiful
23:13:38 <kmc> :t maybe
23:13:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:13:54 <kmc> jeffwheeler, i'd define something analogous to "maybe" for Result
23:13:56 <edwardk> you can do the same thing with the JSArray call
23:14:02 <kmc> then resultToMaybe = result Nothing Just
23:14:19 <kmc> or perhaps resultToMaybe f = f <$> result Nothing Just
23:15:10 <jeffwheeler> Where "result" accepts the default value (Nothing) and a function that is applied to its input, in this case the type constructor "Just"?
23:15:27 <kmc> @src maybe
23:15:27 <lambdabot> maybe n _ Nothing  = n
23:15:28 <lambdabot> maybe _ f (Just x) = f x
23:15:41 <jeffwheeler> Yeah, I see the analogy.
23:15:45 <kmc> result _ f (OK x) = f x;  result n _ _ = n
23:16:11 <kmc> yeah, it takes a default and a function to apply in the case of OK
23:16:23 <edwardk> now, if you really wantto be evil you could just use 'return' and 'fail' ;)
23:17:20 <edwardk> ok :: Monad m => Result a -> m a; ok (OK a) = return a; ok _ = fail "Bad result, bad!, Bad result!"
23:17:42 <kmc> heh
23:17:56 <jeffwheeler> Woah, edwardk.
23:18:05 <kmc> or use MonadPlus if you want to be less evil
23:18:16 <edwardk> yeah
23:18:24 <edwardk> on that note i'm going to bed
23:18:27 <edwardk> later
23:18:35 * hackagebot pandoc 1.5.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.5.0.1 (JohnMacFarlane)
23:18:36 <jeffwheeler> Thanks for the help, edward . . . ah, too slow
23:19:01 <jeffwheeler> Well, thanks for your help, too, kmc. :)
23:19:35 * hackagebot gitit 0.7.3.5 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.5 (JohnMacFarlane)
23:19:37 <kmc> :)
23:27:11 <mxc> i propose this for dons ' get haskell button request:  http://dl.dropbox.com/u/3468290/gethaskell.png
23:28:11 <pippijn> hm
23:28:16 <Veinor> mxc++
23:28:58 <mxc> ty
23:29:17 * Hunner was wondering where the "Solaris" button is, but guesses "Linux" is synonymous with "Source" for the most part
23:29:21 <Pseudonym> I don't mean to single out Felipe here, but I want to vent, briefly.
23:29:34 <luite> mxc: you still need to paste a lambda or the >>= logo somewhere
23:29:53 <Pseudonym> On bubble sort: "I don't know how much difference in time there would be, but you should use lists in C and/or mutable arrays in Haskell, otherwise you are comparing apples to oranges.  Comparision of algorithms should use the same data structures, unless you're asking for a comparision of "idiomatic" implementations."
23:30:01 <mxc> true, this is for the "small button"
23:30:11 <Pseudonym> Surely that's the ONLY reason to implement bubble sort (apart from "it's on the exam").
23:30:26 <Pseudonym> If you care about time, don't use bubble sort.
23:31:43 <Pseudonym> Let me put that in convenient all-caps form: THERE IS NO REASON WHY YOU SHOULD EVER HAVE TO IMPLEMENT BUBBLE SORT.
23:31:49 <Pseudonym> OK, I'm done.
23:33:00 <Hunner> Or if you want your values shifted by no more than one position in the list :>
23:33:11 <Hunner> Partial application of bubble sort
23:33:19 * Pseudonym laughs
23:33:38 <Pseudonym> Seriously, people need to know bubble sort so they don't accidentally re-invent it when they're actually trying to implement insertion sort.
23:37:16 <Pseudonym> And I guess it generalises to the heap method of generating initial runs for merge sort.
23:39:15 <cads> > map (printf "%d\n") [1..10]
23:39:17 <lambdabot>   Ambiguous type variable `b' in the constraints:
23:39:17 <lambdabot>    `Text.Printf.PrintfType ...
23:39:31 <cads> any way to make that work?
23:39:55 <langtree> > map (\d -> printf "%d\n" d) [1..10]
23:39:56 <lambdabot>   Ambiguous type variable `b' in the constraints:
23:39:56 <lambdabot>    `Text.Printf.PrintfType ...
23:40:10 <langtree> > map (\d -> printf "%d\n" d) [1..10] :: [IO ()]
23:40:11 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
23:40:18 <langtree> > map (printf "%d\n") [1..10] :: [IO ()]
23:40:19 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
23:40:26 <langtree> Like that :)
23:40:27 <Pseudonym> > map (\d -> printf "%d\n" d >> return ()) [1..10]
23:40:28 <lambdabot>   No instance for (Text.Printf.PrintfType (m a))
23:40:28 <lambdabot>    arising from a use of `Te...
23:40:37 <Pseudonym> Oh, hang on.
23:40:40 <Pseudonym> Sorry.
23:41:19 <kmc> > map (printf "%d\n" :: Integer -> String) [1..10]
23:41:20 <lambdabot>   ["1\n","2\n","3\n","4\n","5\n","6\n","7\n","8\n","9\n","10\n"]
23:41:30 <kmc> > mapM_ (printf "%d\n" :: Integer -> IO ()) [1..10]
23:41:31 <lambdabot>   <IO ()>
23:41:37 <cads> oh nice
23:42:17 <langtree> > concatMap (printf "%d\n" :: Integer -> String) [1..10]
23:42:18 <lambdabot>   "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"
23:42:19 <kmc> cads, what did you want it to do?
23:42:36 <langtree> > concatMap (printf "%d\n") [1..10] :: String
23:42:37 <lambdabot>   "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"
23:42:54 <cads> I'd like to output a column of formatted info
23:42:58 <Veinor> printf's magic return type is kind of... special
23:43:00 <Veinor> :t printf
23:43:01 <lambdabot> forall r. (PrintfType r) => String -> r
23:43:14 <kmc> cads, so you want the IO () one?
23:43:41 <cads> Yes
23:43:49 <kmc> then you'll probably want to use mapM_
23:44:23 <langtree> > mapM_ (printf "%d\n") [1..10]
23:44:24 <lambdabot>   No instance for (Text.Printf.PrintfType (m b))
23:44:24 <lambdabot>    arising from a use of `Te...
23:44:48 <kmc> it's Haskell's equivalent to a "for" loop, but it's an ordinary function
23:45:17 <kmc> because working in a good imperative languages gives you that power :)
23:45:39 <pippijn> make -j3  5754.38s user 623.19s system 168% cpu 1:03:15.70 total
23:45:40 <kmc> mapM is the version that returns a list of the results (but is slower if you don't care about results and are throwing them out anyway)
23:45:43 <cads> :t map (printf "%d" :: Int -> IO())
23:45:44 <lambdabot> [Int] -> [IO ()]
23:45:44 <pippijn> :D
23:47:07 <cads> :t map (printf "%d" :: Int -> IO()) [1,2]
23:47:08 <lambdabot> [IO ()]
23:47:23 <cads> so it returns a list of io actions?
23:47:35 <cads> evaluates to*?
23:47:42 <kmc> yeah that expression does
23:47:46 <kmc> :t sequence
23:47:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:48:04 <kmc> mapM f = sequence . map f
23:48:31 <kmc> :t sequence_
23:48:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:48:47 <cads> > sequence_ $ map (printf "%d" :: Int -> IO()) [1,2]
23:48:48 <lambdabot>   <IO ()>
23:49:06 <cads> holy moly it worked in my ghci
23:49:26 <cads> > sequence $ map (printf "%d" :: Int -> IO()) [1,2]
23:49:27 <lambdabot>   <IO [()]>
23:49:45 <cads> that was giving me Exception: Prelude.undefined
23:49:45 * hackagebot c10k 0.3.0 - C10k server library  http://hackage.haskell.org/package/c10k-0.3.0 (KazuYamamoto)
23:50:34 <kmc> lambdabot can evaluate IO actions but will not execute them
23:51:11 <cads> so she can't tell that the former works out while the latter is an exception
23:51:18 <cads> thanks kmc
23:51:42 <Veinor> she hates being anthropomorphized!
23:52:11 <cads> it's true that modern women prefer to be objectified
23:53:20 <kmc> unfortunately the standard Text.Printf pushes some typechecking to runtime
23:53:30 <kmc> > printf "%d" 'x'
23:53:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:53:32 <lambdabot>    `GHC.Show.Show a'
23:53:32 <lambdabot>      a...
23:53:35 <kmc> > printf "%d" 'x' :: String
23:53:37 <lambdabot>   "120"
23:53:43 <kmc> > printf "%d" "foo" :: String
23:53:44 <lambdabot>   "* Exception: Printf.printf: bad argument
23:54:47 * hackagebot webserver 0.3.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.3.0 (KazuYamamoto)
23:55:35 <cads> well, basically what I'd like to do would  be to print out a stream of Ints aligned to the left in 3 columns of 75 charachters each
23:56:07 <cads> I think I can do that with a little finagling with the printf function
23:56:11 <o-_-o> hello
23:56:19 <cads> the types will be ints for sure
23:56:26 <o-_-o> http://alexpogosyan.com/color-theme-creator/ <- it would've been nice if this were haskell code :-)
23:57:47 * hackagebot mighttpd 0.3.0 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.3.0 (KazuYamamoto)
23:57:57 <cads> kmc, you wouldn't know a canned routine for formatting large tables of numbers would you?
23:58:16 <mxc> any idea why the osx haskell platform installer requires a logout?
23:59:01 <cads> my reasoning is that it's bound to exist somewhere, but in the time it may take for me to find it, I could complete a useful excercise in writing a text formatting routine
