00:00:23 <Cale> Things like accumulating parameters which aren't evaluated until the very end.
00:00:53 <Cale> Stack overflow doesn't mean what you might expect from strict languages.
00:01:11 <kamatsu> let me first try shrinking the size of the data to see if it is an infinite recursion or just a blowout of memory
00:01:20 <Cale> The stack essentially holds on to all the case expressions which are waiting for their scrutinee to be evaluated enough to pattern match.
00:01:25 <SamB_XP> almost exactly the opposite, actually
00:02:28 <kamatsu> okay, shrinking the size removes the overflow, so i have some buildup of data somewhere
00:03:13 <SamB_XP> too bad vacuum can't help :-(
00:03:26 <Cale> kamatsu: What does the code look like?
00:03:55 <kamatsu> a cellular automata simulation with a state monad
00:05:46 <Saizan> maybe you've to add strictness to how you access/modify the state
00:07:40 <kamatsu> ah, changing to Control.Monad.State.Strict solved that problem
00:07:50 <Cale> kamatsu: Are you displaying the full content of the simulation on every step?
00:07:57 <kamatsu> Cale: yes
00:08:01 <Cale> hmm, okay
00:08:15 <kamatsu> Cale: but my display code seems to be not working, i was just fixing up this overflow first
00:08:45 <Cale> Does it happen just within a single iteration of your automaton?
00:08:53 <Cale> (the overflow)
00:09:15 <kamatsu> Cale: yes
00:18:14 <Saizan> the day GHC can figure out that a bunch of insert on a Map should be done eagerly it'd be a great day :)
00:20:35 <edwardk> saizan: it more or less does now, thanks to the ! annotations ;)
00:21:23 <Saizan> :P
00:22:03 <Saizan> that's more like being told
00:22:26 <edwardk> well, it at least takes instructions well =)
00:22:32 <edwardk> bbiab
00:24:01 <Saizan> however i'm not so clear on how you'd introduce a data dependency between your state and the tuple
00:24:47 <Saizan> without thinking about doing it, i mean
00:25:01 <Saizan> so that just switching to .Strict like kamatsu did helps
00:26:05 <Amagineer> Is there a Instantant Messenger client of some form written in Haskell yet?
00:26:14 <kamatsu> hm, that's odd
00:26:30 <kamatsu> now my simulation runs once, it draws once, the sim runs again, and then the draw never terminates
00:28:23 <Amagineer> exit
00:28:25 <Amagineer> Hmm
00:31:12 <kamatsu> Ah, that's even stranger
00:31:21 <kamatsu> it seems like my array has become infinite or something
00:31:48 <kamatsu> accessing elements inside an array causes the program to freeze
00:31:56 <kamatsu> A.assocs and printing it cause it to freeze
00:31:59 <kamatsu> rather
00:32:05 <kamatsu> let me try just printing out the first one or something
00:32:45 <kamatsu> even wierder, accessing just one element causes freeze
00:33:28 <kamatsu> if my state was lazy, that would be possible because an infinite computation could be in the array and is evaluated when i try to print or display it
00:33:29 <copumpkin> you sure you don't have an infinite knot?
00:33:35 <kamatsu> but with strict that's odd
00:33:40 <copumpkin> hm, can I see?
00:33:57 <kamatsu> it's a fairly large amount of code that's difficult to break up into chunks
00:34:01 <copumpkin> ah
00:34:07 <Saizan> kamatsu: State.Strict is not strict in the state.
00:34:10 <copumpkin> well, the fact that your state is strict doesn't mean that the entire array is evaluated
00:34:18 <kamatsu> ah
00:34:21 <Saizan> kamatsu: only in the tuple holding the state.
00:34:28 <kamatsu> i see
00:34:58 <Saizan> kamatsu: and anyhow, if you e.g. apply seq to an array, you are only strict in its spine, not the elements
00:35:25 <kamatsu> right
00:35:57 <Saizan> tried compiling with -O2 ? it might report a <<loop>>
00:36:03 <Saizan> at runtime
00:36:13 <kamatsu> ah
00:36:14 <kamatsu> i'll try now
00:36:30 <kamatsu> yeah, it did
00:36:50 <kamatsu> doesn't give any useful information aside from that tho
00:37:37 <copumpkin> can you show us the code where you create the array?
00:38:18 <kamatsu> > initialScreen = A.listArray ((0,0),(32,64)) (repeat (Cell water 0.0))
00:38:19 <lambdabot>   <no location info>: parse error on input `='
00:38:25 <kamatsu> oops, sorry lambdabot
00:38:42 <copumpkin> hm, and what's water?
00:38:42 <Saizan> maybe the problem is repeat?
00:38:50 <Saizan> ah, no, sorry
00:39:07 <kamatsu> copumpkin: water is an Element type that is basically just a pair of a bool and a word32
00:39:16 <copumpkin> ah, and it doesn't refer to initialScreen?
00:39:23 <kamatsu> copumpkin: no
00:39:27 <copumpkin> hmm
00:39:46 <Saizan> and just diplaying that freezes?
00:40:08 <kamatsu> no, first time, i run sim, i display it, it works
00:40:14 <kamatsu> i run sim again, i display it, it freezes
00:40:23 <Saizan> ah, ok
00:40:42 <Saizan> how are you running these simulations?
00:40:49 <kamatsu> Saizan: what do you mean?
00:41:07 <Saizan> well, what's the code that chains them?
00:41:42 <kamatsu> in a StateT IO ()
00:41:52 <kamatsu> *StateT SimState IO ()
00:41:59 <kamatsu> just update SimState, draw, rinse and repeat
00:42:57 <Saizan> so no opportunity for a self-referencing let definition that should instead be shadowing?
00:43:47 <kamatsu> not that i can see
00:43:51 <kamatsu> ah, i just discovered something else
00:44:07 <kamatsu> if i remove all mass from the simulation, it simulates fine
00:44:14 <kamatsu> and draws (nothing) fine
00:44:28 <kamatsu> as soon as I add mass to the simulation, it simulates once and then drawing freezes
00:44:55 <kamatsu> so the loop is somewhere in the simulation for flow
00:47:39 <helino> hello everyone, I would like to get some profiling information about my haskell program which uses STM, especially things such as the number of abort, commits etc. Does anyone have any suggestion on tools to use?
00:47:59 <dons> i'm not sure   there is any tool for tracking STM aborts or retries.
00:48:05 <dons> the closest thing would be ThreadScope
00:48:10 <dons> which may have that informatoin.
00:48:25 <dons> http://research.microsoft.com/en-us/projects/threadscope/
00:48:45 <dons> ghc's new logging features (which threadscope uses) may emit that info
00:48:52 <dons> otherwise, you can write your own tracing code
00:49:00 <dons> use Debug.Trace to emit messages
00:49:06 <helino> dons: ok
00:49:30 <dons> if you're inclined, you might even want to patch the ghc rts to emit stm logs into the format threadscope can use (if it doesn't)
00:49:35 <dons> that'd be a fairly easy project, i think
00:50:14 <helino> I've read the paper "Profiling Transactional Memory applications on an atomic block basis: A haskell case study" by Tim Harris et al, in which they mention the function ReadTStats
00:50:22 <helino> dons: ok, thanks!
00:51:33 <helino> however, I've search all over for the "ReadTStats" function, and I can't seem to find it anywhere except in Tims papers :(
00:51:52 <kamatsu> argh, i found the loop
00:52:11 <dons> mmm.
00:52:18 <dons> helino: ask JaffaCake
00:53:51 <helino> dons: thanks for your help!
01:00:32 <helino> dons: Can I use Debug.Trace to write a message when the function "atomically" aborts or commit, or do I have to trace things in the RTS?
01:02:18 <c_wraith> helino: Debug.Trace doesn't work inside of STM
01:03:43 <helino> that's what I thought...if I would like to add some code to RTS to get this information, where should I start looking?
01:04:05 <c_wraith> You can get the info you want.
01:04:11 <c_wraith> Let me find the function
01:04:18 <helino> c_wraith: wow thanks
01:05:01 <copumpkin> helino: modifying the RTS seems a little heavy-handed
01:05:35 <c_wraith> You can use unsafeIOToSTM to print from inside of STM
01:05:49 <copumpkin> or to increase an IORef
01:05:55 <copumpkin> which seemed to be what he wanted, more or less
01:06:19 <c_wraith> and you can use a combination of orElse and retry to detect when a transaction is aborted
01:09:04 <helino> thanks! I understand how I would be able to detect when a transaction is aborted, but how would i know when it commited?
01:09:45 <c_wraith> Just use >>
01:09:55 <c_wraith> Err, actually, that wouldn't work.
01:10:09 <c_wraith> Well, there'll be exactly one commit per call to atomically
01:10:18 <c_wraith> You can figure it out from there. :)
01:11:51 <helino> c_wraith: you mean that if the transaction didn't abort, then it commited?
01:12:01 <c_wraith> yes
01:13:16 <helino> ok, once again, thanks for taking your time!
01:14:13 <helino> i really appreciate it
01:14:32 <c_wraith> You're welcome. :)
01:30:22 <paulvisschers> What's the easiest way to convert from String to ByteString?
01:31:23 <Saizan> Data.ByteString.Char8.pack
01:31:23 <tensorpudding> @hoogle String -> ByteString
01:31:23 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:31:24 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:31:24 <lambdabot> Prelude read :: Read a => String -> a
01:31:33 <Phyx-> omg... I've been doing to much functional programming lately. I've been staring at the call "process list base" for a while wondering why the C# compiler was complaining
01:32:54 <paulvisschers> thanks guys
01:37:31 <helino> JaffaCake: hi, do you know where I can find the function "ReadTStats" which is mentioned in some papers by Tim Harris on getting profiling information about STM transactions?
01:48:01 <ivanm> @. elite protontorpedo
01:48:01 <lambdabot> wH47 iz0rz zO go0D abOu+ cOntiNUa+iONS/
01:50:07 <ivanm> preflex: seen bos
01:50:08 <preflex>  bos was last seen on #haskell 1 day, 4 hours, 23 minutes and 30 seconds ago, saying: ivanm: we're talking about a lot of work here, you understand, right?
02:09:28 <voidprayer> http://blog.sigfpe.com/2009/12/where-do-monads-come-from.html
02:09:41 <voidprayer> Excuse me, can anyone tell how to understand this?
02:09:55 <Heffalump> they come from the great categorical god in the sky
02:10:51 <Heffalump> what don't you understand?
02:11:38 <voidprayer> helino: First, what does "in the sky" mean in the English?
02:11:42 <voidprayer> -_-|||
02:12:18 <voidprayer> Heffalump: First, what does "in the sky" mean in the English?
02:12:31 <Heffalump> the sky is the big blue thing (when it's not cloudy) above the ground
02:12:38 <Heffalump> so it just means "up there"
02:12:52 <voidprayer> Heffalump: Back to the topic, "flag set". What flag?
02:13:05 <Heffalump> a flag is just a boolean value in this context
02:13:34 <voidprayer> I see, and later,  abc=bc?
02:15:07 <voidprayer> Heffalump: "Here are some more rules that you can check for yourself:" abc=bc?  later 2 are easy to understand, but abc? what is abc?
02:15:25 <Heffalump> hmm. I'm not entirely sure.
02:15:44 <Heffalump> he doesn't seem to define the associativity of multiplication
02:15:54 <voidprayer> Heffalump: yes, that's what i cannot get.
02:16:10 <Heffalump> I think the point is something to do with making one choice then another is equivalent to just making the second choice.
02:16:57 <voidprayer> the only redefinition about multiplication is making a choice. but "a" seems a result of something. "a" set? then check "b", and "b" set then return c?
02:17:16 <voidprayer> in no way it cannot be the same as checking "b" set and return "c"
02:18:07 <Heffalump> that's my confusion too
02:18:12 <Heffalump> so sorry, can't help
02:18:40 <Heffalump> I'd suggest leaving a comment to ask
02:19:18 <voidprayer> Heffalump: thank you very much.
02:20:02 <Saizan> it says that "a" and "b" are both either 0 or 1
02:20:26 <Saizan> while c can be any expression
02:20:31 <Heffalump> but it leaves cases uncovered
02:20:41 <Saizan> like?
02:20:45 <voidprayer> Saizan: yes, but i still cannot get why abc=bc. if a =0 and b = 1?
02:20:59 <Heffalump> well, if a is 0, what if the answer is actually 1?
02:21:11 <Saizan> voidprayer: because c can only see the value as left by b
02:21:44 <Heffalump> oh, there's no test
02:21:58 <Saizan> 0 and 1 both correspond to setting the flag to that value
02:22:05 <Heffalump> they're both writing to the same flag
02:22:07 <Heffalump> yeah
02:22:22 <Saizan> "testing" the flag is done with +
02:22:44 <voidprayer> Saizan: I see. flag set can be flag=0 or flag=1, while flag undefined = flag unset?
02:23:02 <Heffalump> no, flag set is flag = 1
02:23:17 * voidprayer is worn out...
02:23:30 <Heffalump> I think testing the flag without flag:=0 or flag:=1 first is undefined
02:23:48 <Saizan> 1 sets the flag, 0 resets it, if you want to use that terminalogi
02:23:56 <Saizan> *temrinology
02:24:02 <Saizan> ..whatever.
02:24:26 <voidprayer> then it means, set flag =a  and then set flag=b and then return c? so set flag =a does not make sense since it is immediately replaced by "b"?
02:24:42 <Saizan> however i guess you assume there's some initial value for the flag when the expression is evaluated
02:25:12 <Heffalump> voidprayer: right
02:25:22 <Heffalump> well, it makes sense, it's just irrelevant
02:25:24 <voidprayer> Heffalump & Saizan: thank you.
02:25:37 <Saizan> except it doesn't mean to return c, it means the rest of the expression is c
02:25:50 <Saizan> c might be composed of other multiplications and additions
02:26:07 <Saizan> and variable.
02:26:43 <voidprayer> Saizan: oh yes. i should've thought that.
02:35:08 <Twey> Is it possible to use Data.Text instead of String for Happstack output?
02:35:18 <Twey> If so, how should one go about doing it?
02:39:05 <Saizan> well, the Response type uses bytestring for the body, iirc
02:39:38 <Saizan> and there's a typeclass to provide canonical ways to convert your type into a Response
02:40:44 <Twey> Hmm, better still: there's a ToMessage typeclass that only needs to provide a way of converting the type into a lazy bytestring, it seems
02:40:53 <Twey> But I'm not sure
02:41:02 <Saizan> yeah, it should be that one
02:41:11 <Twey> The info for the class has ‘...’s around the toMessage function
02:41:26 <Twey> Does that mean that it requires more methods that haven't been mentioned?
02:41:39 <Saizan> did you do :i ToMessage or :i toMessage?
02:42:02 <Twey> :i ToMessage
02:42:08 <Twey> Oh wait
02:42:11 <Twey> No I didn't
02:42:15 <Twey> I'm stupid.  Sorry.  :þ
02:42:36 <Twey> Yeah, it also requires ToContentType and ToResponse
02:42:48 <Saizan> some of the methods have a default, iirc still
02:43:03 <Twey> Seems odd that such a thing doesn't exist already
02:43:30 <Saizan> well, the text package is pretty new
02:43:46 <Twey> Not *that* new
02:44:12 <Saizan> and there's always the "do i depend on everything just to provide instances?" problem
02:44:19 <Twey> http://groups.google.com/group/happs/browse_thread/thread/13d1f3da00ce412f# — that was a month ago
02:44:22 <Twey> Yeah… :-\
02:44:38 <Twey> We really should have more flexible support for instances
02:50:16 <kamatsu> hey, currently I'm using SDL to draw my automata, but the drawing is slow
02:50:35 <kamatsu> i am drawing each pixel of the screen individually so this isn't entirely unexpected
02:51:09 <kamatsu> perhaps i should use openGL?
02:51:20 <kamatsu> if so, how can I use openGL to draw lots and lots of single pixels
03:00:40 <voker57> kamatsu: draw on an separate surface, then blit it
03:03:20 <kamatsu> voker57: in SDL? I'll try it
03:03:53 <Alpounet> yeah
03:03:57 <Alpounet> use the double buffering mode
03:04:21 <Alpounet> you draw stuffs on the non-displayed buffer, and then switch the buffers
03:04:33 <kamatsu> Right, that would reduce flickering
03:04:52 <kamatsu> but it wouldn't increase the speed
03:08:37 <kamatsu> as i expected, double-buffering doesn't  change this at all
03:09:36 <voker57> you'd better ask in #sdl probably
03:10:01 <kamatsu> hm, ok
03:15:18 <kamatsu> ah, turning off the simulation makes the drawing go fast
03:15:32 <kamatsu> my drawing just appeared slow because the simulation is happening lazily
03:16:33 <olsner> hmm, maybe you want the simulation to happen non-lazily then? like put the simulation results directly in an (unboxed) array, then convert the array to pixels
03:17:14 <kamatsu> well, the simulation operates on a standard Data.Array at the moment
03:17:31 <kamatsu> so, would unboxing it cause the simulation to happen strictly?
03:18:02 <olsner> also, if you're using setpixel or something like that, I think you rather want to get a pointer to the pixel buffer and write directly (which SDL does have, although I have no idea how the haskell interface looks)
03:18:48 <kamatsu> olsner: it's possible to get the raw buffer in Haskell's SDL, I think.
03:20:14 <kamatsu> but the main bottleneck appears to be my simulation
03:20:15 <olsner> yes, unboxed arrays don't store thunks/boxes but rather just raw ints, so when storing anything in there it has to be fully evaluated to figure out which value to store
03:20:38 <kamatsu> well, s/Data.Array/Data.Array.Unboxed/g didn't change anything
03:21:18 <kamatsu> oh, i may see why, hold on
03:23:37 <kamatsu> hm
03:23:40 <kamatsu> nope, didn't help
03:27:50 <kamatsu> ah, i fixed the speed issues, i thinki
03:45:44 <pastorn> is Control.Arrow in the standard libraries?
03:50:03 <Alpounet> pastorn, yeah, pastorn is in 'base', which is shipped with GHC
03:50:19 <pastorn> cool
03:50:57 <pastorn> aww... these type signatures are annoying... i'll just write first :: (a -> b) -> (a,c) -> (b,c), and second
03:51:03 <pastorn> myself
03:51:31 <Twey> What type signatures?
03:51:39 <Twey> :t first
03:51:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:51:44 <pastorn> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Arrow.html
03:51:49 <pastorn> Twey: that
03:51:54 <Twey> Why is that annoying?
03:52:03 <pastorn> because i don't know how to read them
03:52:08 <Twey> Your case is just a = (->)
03:52:11 <ivanm> Twey: hey, I use first and second all the time and I have trouble reading them
03:52:43 <ivanm> have to remember that the function is the arror
03:52:47 <ivanm> *arrow
03:52:48 <Twey> (Arrow (~>)) => (a ~> b) -> (b, d) ~> (c, d)
03:52:57 <Twey> I find a bit nicer to read
03:53:20 <pastorn> oh, that looks kinda nick
03:53:22 <pastorn> *nice
03:53:46 <pastorn> but since there's only one place in my program for this, i'll just write first and second myself and then let that be that
03:53:52 <moshisushi> pastorn: haha bra nick :)
03:53:57 <Alpounet> arrows just abstract -> away
03:53:57 <Twey> But why, when you can just import them?
03:54:05 <Alpounet> -> is a particular case of arrows
03:54:11 <Twey> Right
03:54:24 <Alpounet> you can use Control.Arrow straight in your code
03:54:27 <kamatsu> ah, bah
03:54:28 <Twey> You already have the functions you need — they're interchangeable with the ones you want
03:54:30 <pastorn> maybe later when i'm working with more massive pair structures i might look at the Arrow lib
03:54:31 <Alpounet> even for ->
03:54:34 <kamatsu> I give up on implementing falling sand game in Haskell for now
03:54:34 <pastorn> moshisushi: klart ;)
03:54:46 <Twey> > first (* 2) (3, 4)
03:54:47 <lambdabot>   (6,4)
03:55:03 <Alpounet> pastorn, why do you want to rewrite them ?
03:55:07 <Alpounet> they'll just work (TM)
03:55:12 <pastorn> Alpounet: learning experience
03:55:17 <Twey> It'll take its type from the first argument, so you don't even need to worry about specifying a type signature to narrow them down
03:55:34 <pastorn> if it's a basic data manipulation library i want to know that i can write it myself
03:55:35 <Twey> Either you want to learn, or you want to make something
03:55:45 <Twey> If you want to learn, learn to use arrows, then use Control.Arrow
03:55:54 <pastorn> so that i can see myself why everything is in the library
03:56:01 <Twey> If you want to make something, pretend arrows are just functions, then use Control.Arrow ;)
03:56:39 <pastorn> like with Parsec... i didn't use that until AFTER i've read "Monadic Parsing in haskell" and copied the code from there to write my own shitty little monadic parser (that didn't really work)
03:57:32 <pastorn> so i'll just write the basic arrow functions and copy their names for now
03:57:46 <Twey> There's no point writing first f (a, b) = (f a, b); second f (a, b) = (a, f b) when they're already available
03:57:54 <Twey> You're not going to learn anything from that
03:57:58 <pastorn> then later on i should just be able to comment out my own functions and import
03:58:00 <pastorn> and it'll work
03:58:11 <Twey> But what's the point?
03:58:25 <pastorn> Twey: &&&, ***, >>> etc. etc.
03:58:33 <Twey> pastorn: Right
03:58:42 <Twey> They're all ridiculously trivial to implement for functions
03:58:43 <pastorn> Twey: you don't know how little i know :p
03:58:59 <Twey> (f &&& g) a = (f a, g a)
03:59:11 <Twey> (f *** g) (a, b) = (f a, g b)
03:59:18 <Twey> (>>>) = flip (.)
03:59:25 <pastorn> Twey: stop that
03:59:31 <dobblego> pastorn, what is Monadic Parsing in Haskell?
03:59:41 <pastorn> dobblego: an awesome paper
03:59:44 <pastorn> you should read it
03:59:48 <dobblego> ok
03:59:59 <Twey> pastorn: And these are probably all exactly the definitions used for the Arrow instance of (->)
04:00:01 <pastorn> dobblego: have you written a parser in haskell for anything yet?
04:00:06 <dobblego> pastorn, yes
04:00:12 <ivanm> what? there's a monad paper that dobblego hasn't read? :o
04:00:15 <Twey> (or close enough)
04:00:18 <ivanm> especially one about parsing? :o
04:00:35 <dobblego> I've read it
04:00:39 <pastorn> hehe
04:03:00 <ivanm> *phew*
04:05:25 <ivanm> preflex: seen kowey
04:05:26 <preflex>  kowey was last seen on #haskell 27 days, 19 hours, 36 minutes and 9 seconds ago, saying: is sam hughes (keeper of the YAHT) around?
04:11:25 <benmachine> if you want to understand everything before you use it, that's not a bad philosophy except you're never going to understand everything
04:12:31 <benmachine> there are more people out there making stuff faster than you can consume it
04:12:33 <arw_> well. people who really want to do that will starve...
04:13:03 <zachk> to whoever benmachine just said that: i enjoy using haskell and I understand the IO monad, the Maybe ne monad and the List monad, and I love it more then any other language
04:13:46 <benmachine> :t let first' f = first f `const` f undefined in first'
04:13:47 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
04:14:52 <benmachine> you don't need to know how that is implemented to see that there's only one possible thing it can do
04:25:30 <maxmud> hello
04:25:33 <chrisdone> hi
04:28:39 <dv-> Hi. How do I tell cabal that I have ghc? I just installed cabal and cabal-install and it's telling me that I need ghc -any
04:30:54 <Saizan> dv-: it's asking about the ghc package
04:31:11 <Saizan> i.e. the library
04:31:28 <Saizan> which is shipped with ghc, but maybe it got broken?
04:31:44 <Saizan> dv-: try "ghc-pkg check"
04:34:10 <dv-> Saizan, hm, it says that ghc is broken because a specific version of cabal isn't installed
04:36:05 <Saizan> dv-: what does ghc-pkg list Cabal says?
04:37:08 <dv-> Saizan, /var/lib/ghc-6.12.1/package.conf.d \n Cabal-1.8.0.2
04:38:41 <Saizan> ok, so you've installed a Cabal-1.8.0.2 globally, overwriting the one shipped with ghc
04:39:01 <dv-> the shipped cabal was broken
04:39:05 <Saizan> upsetting the dependent packages :)
04:39:09 <Saizan> how?
04:39:41 <tensorpudding> are there any caveats to upgrading to ghc 6.12.x?
04:39:49 <Heffalump> no released platform yet
04:40:03 <Heffalump> so you're on your own getting all the pieces installed
04:40:10 <tensorpudding> assuming that i don't use the platform explicitly
04:40:12 <Heffalump> in theory cabal install should just work fine, and it has for me
04:40:44 <dv-> Saizan, ehm, something not understanding the output of ghc-pkg i think
04:41:04 <dv-> something about*
04:41:39 <Saizan> the Cabal shipped with ghc surely was able to understand it
04:41:49 <Saizan> maybe you're talking about cabal-install?
04:42:00 <Saizan> anyhow, you've to reinstall your ghc
04:42:16 <Saizan> you can keep your cabal-install though
04:42:50 <dv-> should i get a development snapshot while i'm at it?
04:43:05 <Saizan> ehm, why?
04:47:15 <dv-> Saizan, alright, reinstalling ghc worked. thanks
04:53:51 <vakosel> hi i would like to try haskell for gui programming . which you think is the most -up to now- easiest toolkit to use?
04:54:31 <vakosel> i have used win32, wx and gtk in the past.. but i dont have any problem with qt either
04:54:50 <ivanm> for haskell, the two big ones are gtk2hs and wxhaskell
04:55:04 <ivanm> gtk2hs is usually recommended, however it isn't cabalised and wx is
04:55:12 <ivanm> and wx might be a bit more cross-platform
04:55:21 <ivanm> (mac users really hate gtk2hs)
04:55:35 <moshisushi> ivanm: mac users hate gtk
04:55:43 <vakosel> my paltform is win32 and ubuntu to tell you the truth
04:55:52 <vakosel> so i am not a mac guy
04:55:52 <ivanm> moshisushi: no, as in I'm pretty sure gtk2hs doesn't build properly IIUC
04:56:09 <vakosel> wxhaskell uses xrc?
04:56:17 <ivanm> it uses wxwidgets
04:56:31 * ivanm has no idea what xrc is
04:56:37 <tensorpudding> xrc is a windows one
04:56:52 <vakosel> i mean support
04:56:54 <ivanm> IIRC, the current gtk2hs installer doesn't really like the haskell platform's default installation path on windows however
04:56:55 <vakosel> xrc
04:57:01 <ivanm> vakosel: it uses wxwidgets
04:57:06 <ivanm> it's just a haskell wrapper library
04:57:12 <vakosel> i understand that
04:57:20 <ivanm> if wxwidgets supports xrc, then presumably wxhaskell supports it
04:57:42 <vakosel> not always
04:58:09 <vakosel> so i should go for wxhaskell
04:58:10 <ivanm> *shrug*
04:58:14 <ivanm> if you want to
04:58:24 * ivanm doesn't use windows and for the most part doesn't care about it
04:59:06 <vakosel> i simply meant xml design
04:59:13 <vakosel> for gui
04:59:29 <vakosel> i am new to haskell but i really like it
05:02:31 <ivanm> xml design?
05:02:32 <ivanm> *shrug*
05:02:43 <ivanm> the only thing I know about that is that gtk2hs supports using glade...
05:03:27 <Jonno_FTW> what is the best way to get from IO Integer to Integer?
05:03:52 <pastorn> Jonno_FTW: unsafePerformIO ;)
05:04:40 <ivanm> Jonno_FTW: don't
05:04:48 <ivanm> you use your pure functions within the IO monad
05:04:49 <dobblego> Jonno_FTW, the best way is to not do that
05:04:52 <vakosel> ivanm: thanks i just saw that .. glade is a good option
05:04:53 <pastorn> noooooooooooo
05:04:55 <malosh> jonno_FTW : best way = use the do notation ?
05:04:57 <pastorn> lambdacats is down
05:05:04 <Jonno_FTW> hmmm
05:05:12 <ivanm> using liftM/fmap, getting the "value out" in a do block or using >>=
05:05:15 <malosh> what are you trying to do ?
05:05:23 <ivanm> pastorn: well, shillelagh hasn't been in here for _years_
05:05:26 <pastorn> Jonno_FTW: how do you get your IO Integer?
05:05:34 <Jonno_FTW> measure a ping time with getCPUTime
05:05:43 <ivanm> Jonno_FTW: and what do you want to do with it?
05:05:50 <malosh> then don't you think this _is_ a side effect ?
05:06:11 <Jonno_FTW> so that my IRC  bot can measure ping times
05:06:23 <ivanm> well, your IRC bot presumably operates within IO anyway
05:06:42 <Jonno_FTW> it does
05:06:55 <malosh> Maybe you are trying to get this as a toplevel value, i.e. not inside another function ?
05:06:55 <pastorn> Jonno_FTW: pingTime <- ping "someComputer"
05:06:55 <Jonno_FTW> but the thunk for what it sends is not
05:07:13 <pastorn> Jonno_FTW: with that pingTime :: Integer, when you use it again within that function
05:07:38 <Jonno_FTW> hmm
05:07:48 <Jonno_FTW> the way i will work it is
05:07:53 <pastorn> Jonno_FTW: have you used getLine?
05:07:57 <malosh> Jonno_FTW : then you can call it from an IO function, passing the Integer and not the IO Integer. Use 'do's
05:07:58 <Jonno_FTW> i tell the bot to ping someone
05:08:17 <Jonno_FTW> the bot then pings them using the cputime
05:08:27 <pastorn> Jonno_FTW: i'll make you a small paste explaining how this works...
05:08:33 <Jonno_FTW> thanks
05:08:34 <pastorn> @hpaste
05:08:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:08:51 <malosh> Does someone understand how lazy IO works in System.IO.getContents ?
05:09:08 <Twey> malosh: Badly
05:09:17 <malosh> In GHC 6.12 the documentation for GHC.Handle.Internals has vanished
05:09:52 <Jonno_FTW> what's so bad about using unsafePerformIO?
05:10:07 <malosh> I would say that there is an API for using Handle__
05:10:12 <malosh> but I cannot find it
05:10:35 <pastorn> Jonno_FTW: you can break stuff...
05:10:37 <malosh> jonno_FTW : nothing, but you lose the guarantee that side effects change the type
05:10:46 <malosh> which one of the best features in haskell
05:10:54 <Jonno_FTW> all i want is the cputime
05:11:13 <Twey> More than that — the compiler and various functions assume that pure functions won't have side-effects
05:11:20 <Twey> If that's not true, you could break stuff.
05:11:42 <malosh> this is a side effect. Try to understand how parallelism using 'par' works, you should agree that unsafePerformIO is not always cool
05:11:47 <Twey> Jonno_FTW: Why does that require you to use unsafePerformIO?
05:12:00 <Jonno_FTW> because i'm not good at IO
05:12:26 <Twey> Jonno_FTW: How can you not be good at IO?  :þ
05:12:45 <Jonno_FTW> because it's a monad
05:12:48 <malosh> Jonno_FTW : use do
05:13:15 <dobblego> Jonno_FTW, are you good at list?
05:13:20 <Jonno_FTW> yes
05:13:25 <Jonno_FTW> it's a monad too
05:13:28 <dobblego> oh that's funny, because it's a monad
05:13:31 <malosh> monads are cool. That's how you really want to sequence things in any other language, but only haskell allows you to do it.
05:13:42 <pastorn> Jonno_FTW: i hope this clears things up a bit: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8502#a8502
05:13:55 <Jafet> *cough Icon cough*
05:13:59 <dobblego> many languages allow it, not just haskell
05:14:26 <Jonno_FTW> these include?
05:14:37 <dobblego> Java, C#
05:14:37 <Jonno_FTW> and without the aid of libraries?
05:15:05 <pastorn> Jonno_FTW: is other languages you could write
05:15:19 <pastorn> int pingTime = ping("someComputer");
05:15:24 <pastorn> but also
05:15:28 <pastorn> int x = 3+4;
05:15:44 <pastorn> you don't make a difference of what kind of computation you are doing
05:15:59 <progo> hey guys, would you recommend or say if the "Basic category theory..." by Benjamin Pierce (must be familiar around here, no?) describes the monads well?
05:16:01 <Jafet> Both are the same kinds of computation
05:16:25 <Jafet> Haskell provides them too, in ST.
05:16:27 <progo> I'd like to learn about some background philosophy of functional languages.
05:16:32 <pastorn> Jonno_FTW: a way that i have had help with is considering what's "inside" the language
05:16:59 * hackagebot Bookshelf 0.1.5 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.1.5 (EmilAxelsson)
05:16:59 <pastorn> stuff that's "inside" haskell is stuff that doesn't need to reach outside of the programs memory to find stuff out
05:17:12 <Jonno_FTW> ok
05:17:34 <malosh> progo : then this is for you : http://blog.sigfpe.com/
05:17:38 <pastorn> Jonno_FTW: i.e. 'readFile' needs to communicate with the operating system to get it's result; thus it goes 'outside' of the language
05:17:44 <Jafet> pastorn, getRandomInt
05:17:48 <Jonno_FTW> yep
05:17:57 <malosh> progo : or the haskell wikibook has a nice introduction to categories
05:18:05 <Jafet> getPseudorandomInt, rather
05:18:12 <progo> malosh, I see :)
05:18:15 <Cale> @where awodey
05:18:15 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
05:18:22 <pastorn> Jafet: don't be an ass, he's trying to learn
05:18:25 <Cale> ^^ my favourite intro to categories book
05:18:50 <Jafet> "Hi, my name is Jafet and I am an ass"
05:18:57 <progo> Thanks :)
05:19:02 <pastorn> Jonno_FTW: so things like 'ping' most definetly needs to go outside of the language, thus it gives you something of type "IO Integer"
05:19:11 <Jonno_FTW> ok
05:19:16 <Jonno_FTW> well
05:19:22 <Jonno_FTW> all it does is read a string really
05:19:38 <pastorn> Jonno_FTW: what reads a string? ping?
05:19:56 <Jonno_FTW> ok
05:20:06 <pastorn> or my example code?
05:20:16 <Jonno_FTW> uhhh
05:20:37 <Jonno_FTW> the bot works by reading the stuff sent to it from the server
05:20:54 <Jonno_FTW> and when you ping it sends a user the message ping with a number
05:21:04 <pastorn> yes... are you using the guide on the haskell wiki?
05:21:05 <Jonno_FTW> the user will respond with ping and your original number
05:21:08 <Jonno_FTW> yes
05:21:21 <Jonno_FTW> s/ping/pong/
05:21:22 <pastorn> oh, the IRC ping
05:21:27 <Jonno_FTW> yes
05:21:31 <pastorn> i thought you were talking the network ping
05:21:35 <Jonno_FTW> no
05:21:37 <pastorn> haha
05:21:47 <Jonno_FTW> i mentioned my irc bot earlier
05:21:55 <pastorn> Jonno_FTW: are you using the Network.IRC package?
05:22:01 <Jonno_FTW> no
05:22:05 <pastorn> it's in the package callade 'irc' on hackage
05:22:07 <pastorn> you should
05:22:09 <pastorn> it's awesome
05:22:12 <Jonno_FTW> i'm totally doing all the hard work
05:22:35 <pastorn> dispatch msg = case translateReply (msg_command msg) of
05:22:37 <pastorn>     "PING"          -> write $ msg { msg_command = "PONG" }
05:22:44 <pastorn> that's all my code for PING replying :)
05:23:03 <Jonno_FTW> but will it give ping time?
05:23:09 <Jonno_FTW> latency?
05:23:13 <pastorn> you don't get a time with PING
05:23:17 <pastorn> you only get a message
05:23:19 <Jonno_FTW> sure you do
05:23:25 <pastorn> no you don't
05:23:30 <progo> btw, Pierce's "Types and Programming Languages" should be good?
05:23:47 <pastorn> well, you MIGHT get a time in the servers message, but don't count on it
05:23:51 <Jonno_FTW> :Jonno_FTW!~Jonno@sodium.poisonate PRIVMSG HerpBOT :☺PING 1267881789037☺
05:24:09 <Cale> progo: yeah, it's the standard introductory text for type theory
05:24:11 <Jonno_FTW> that's what chatzilla sent to my bot
05:24:14 <pastorn> Jonno_FTW: that's the first message, but after that you're not guaranteed to get it
05:24:35 <Jonno_FTW> according to the rfc, the user should return with PONG and the same number
05:24:42 <pastorn> yup
05:24:55 <Jonno_FTW> from which the client can find the difference between received time and current and get the latency
05:25:01 <pastorn> Jonno_FTW: i'll paste  my dispatch function so you can see how i do it
05:25:02 <olsner> ah, that reminds me, I should pick TaPL up again, it was just starting to get interesting
05:25:10 <progo> HaskellWiki could use a little more complete Books section to describe how good certain books are
05:27:50 <pastorn> Jonno_FTW: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8503#a8503
05:27:57 <pastorn> that's my handler function
05:28:36 <Jonno_FTW> ok
05:28:38 <pastorn> decode in listen is imported from Network.IRC... makes everything a lot easier
05:29:32 <Jonno_FTW> is yours based off the tutorial version?
05:29:49 <pastorn> Jonno_FTW: i started with the tutorial, then stuff went overboard
05:30:22 <pastorn> i don't like printf, so i just use the standard functions
05:30:50 <pastorn> my MIRRK monad is StateT BotState (ReaderT Env IO) a
05:36:07 <Jonno_FTW> back
05:37:15 <Jonno_FTW> i think I need to study the RFC
05:37:27 <pastorn> Jonno_FTW: nah... not really
05:37:34 <pastorn> just do 'cabal install irc'
05:37:45 <pastorn> it fixes everything for you
05:37:49 <Jonno_FTW> but that would be cheeeeeeeeeaaaaaaaaating
05:37:54 <pastorn> no, it wouldn't
05:38:01 <Jafet> There isn't any rfc for irc, really
05:38:09 <Jonno_FTW> http://www.irchelp.org/irchelp/rfc/ctcpspec.html
05:38:14 <pastorn> yes there is
05:38:17 <pastorn> 1459
05:38:22 <Jonno_FTW> http://www.irchelp.org/irchelp/rfc/index.html
05:38:22 <pastorn> and there's a newer one too
05:38:39 <pastorn> 2*something*
05:39:02 <pastorn> Jonno_FTW: you COULD mess with writing message parsers forever and ever
05:39:08 <Jafet> None of those are IRC as it is used.
05:39:13 <Jonno_FTW> that's what I am doing
05:39:20 <pastorn> OR you could focus on writing cool features for your bot
05:39:42 <Jonno_FTW> hmmm
05:39:45 <Jonno_FTW> but then
05:39:48 <pastorn> then what?
05:39:58 <Jonno_FTW> I would have to mess around with new Data types
05:40:04 <Jonno_FTW> which I am not good at
05:40:05 <pastorn> it's ONE datatype
05:40:10 <Jonno_FTW> egads
05:40:21 <pastorn> data Message = Message {msg_prefix :: Maybe Prefix, msg_command :: Command, msg_params :: [Parameter]}
05:40:41 <pastorn> the Prefix is either a server or a nick
05:41:09 <pastorn> and the params are for a message to a channel ["#someChan", "whatever the messag was"]
05:41:44 <Jonno_FTW> i might look into this
05:41:51 <Jonno_FTW> do a complete rewrite
05:41:58 <pastorn> Jonno_FTW: do eeeeet!
05:42:33 <Jonno_FTW> @hpaste
05:42:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:43:08 <Jonno_FTW> here's what it looks like at the moment
05:43:09 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8504#a8504
05:43:16 <Jonno_FTW> if you're interested
05:43:40 <pastorn> eval is NASTY
05:43:44 <Jonno_FTW> yep
05:43:55 <Jonno_FTW> my other problem is
05:43:56 <pastorn> Jonno_FTW: you should read "monadic parsing in haskell"
05:44:01 <pastorn> it's pretty awesome :)
05:44:03 <Jonno_FTW> ok
05:44:11 <nomeata> Hi. Is http://code.haskell.org/haskell-platform/haskell-platform.cabal already close to what will be released as platform 2010.2.0.0?
05:44:25 <pastorn> takes a few hours, but once you've done that you'll be ready to use parsec :)
05:44:39 <pastorn> (and actually know wtf is going on)
05:44:48 <Jonno_FTW> ok
05:45:07 <Jonno_FTW> the other thing is
05:45:28 <Jonno_FTW> how can I parse brackets?
05:45:37 <pastorn> in parsec
05:45:45 <McManiaC> does anyone have encoding issues with Network.Curl? I cant get it to work with utf8 :S
05:45:50 <Jonno_FTW> in my bot it's at line 138 where i tried
05:45:56 <pastorn> between (char '{') (char '}')
05:46:12 <Jonno_FTW> hmm
05:46:31 <Jonno_FTW> @src between
05:46:32 <lambdabot> Source not found. stty: unknown mode: doofus
05:46:39 <Jonno_FTW> >:3
05:46:49 <pastorn> heh
05:47:06 <pastorn> Jonno_FTW: i have 300 lines of parsec code for my bot
05:47:11 <pastorn> but then it can do some nifty stuff
05:47:12 <Jonno_FTW> wow
05:47:35 <pastorn> then i ALSO use the IRC library, so i don't bother with parsing any of the IRC protocol
05:47:36 <Jonno_FTW> all i wanted it do was similar to words
05:47:43 <McManiaC> *Commands.Curl> curlGetString "http://npaste.de/snowman" [CurlEncoding "utf-8"] >>= putStrLn . snd
05:47:46 <McManiaC> *Commands.Curl> curlGet "http://npaste.de/snowman" []
05:47:46 <McManiaC> ☃
05:47:47 <McManiaC> O.o
05:47:50 <McManiaC> â
05:47:50 <Jonno_FTW> where anything between matching brackets would be a word
05:48:13 <pastorn> Jonno_FTW: do you want to grab commands that are between brackets?
05:48:21 <Jonno_FTW> sort of
05:48:29 <pastorn> Jonno_FTW: how do you trigger your bot?
05:48:37 <pastorn> i use ".someCommand someArg"
05:48:46 <Jonno_FTW> !command <args>
05:48:50 <pastorn> ok
05:48:58 <Jonno_FTW> i wanted
05:49:27 <Jonno_FTW> words2 "1 2 (3 4" -> ["1","2","(3 4)"]
05:49:55 <pastorn> Jonno_FTW: you most definetly should use parsec for that
05:50:06 <Jonno_FTW> i thought it would be simple
05:50:20 <Jonno_FTW> using indexes and things
05:50:22 <pastorn> well... it might...
05:50:23 <mauke> Jonno_FTW: what about "1 (2 (3 4))"?
05:50:33 <Jonno_FTW> in context
05:50:39 <Jonno_FTW> it is applied recursively
05:51:16 <pastorn> Jonno_FTW: eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf
05:51:24 <pastorn> read that
05:51:30 <Jonno_FTW> also, my bot had URL fixing
05:51:37 <Jonno_FTW> it's niftiest feature of them all
05:51:44 <pastorn> and copy what you read and write yourself a simple parser for a subset of your commands
05:52:02 <mauke> Jonno_FTW: what does it do?
05:52:32 <mauke> also, is that your real password in the paste?
05:52:42 <Jonno_FTW> if you send a message to the channel which looks like a url, but isn't proper, it fixes it
05:52:46 <Jonno_FTW> and sends a fixed url
05:53:40 <Jonno_FTW> isUrl x =  if length x < 4 then False else ("." `isInfixOf` init (tail x)) && not(isPunctuation $ last x) && not (".." `isInfixOf` x) && not ("..." `isInfixOf` x)
05:54:06 <pastorn> Jonno_FTW: oh my god that is nasty
05:54:08 <Jonno_FTW>   |  (any isUrl $ words x) && (("PRIVMSG "++chan) `isInfixOf` s) && not ("http://" `isInfixOf`  x) && not("files/" `isPrefixOf` x)= privmsg  ( ("http://"++) (head $ filter isUrl $ words x))
05:54:09 <mauke> 'if length x < 4 then False else' better written as 'length x >= 4 &&'
05:54:13 <pastorn> NASTY
05:54:15 <pastorn> STOP IT
05:54:16 <Jonno_FTW> yep
05:54:24 <pastorn> Jonno_FTW: read the paper! NOW!
05:54:28 <pastorn> i command you!
05:54:33 <Jonno_FTW> yes sir
05:54:43 <pastorn> THE POWER OF CHRIST COMPELLS YOU!
05:55:10 <Jonno_FTW> MONADS BE PRAISED!
05:55:17 <mauke> kinda redundant computation there, any isUrl (words x) ... head (filter isUrl (words x))
05:55:39 <Jonno_FTW> it works
05:55:57 <mauke> PRIVMSG ... `isInfixOf`? what the
05:55:58 <Jonno_FTW> i had people testing it
05:57:30 <Jonno_FTW> i guess that last bit is redundant
05:57:47 <pastorn> Jonno_FTW: there's #bottest @ EFnet... they'll try your bot out :)
05:58:04 <pastorn> (tried to crash mine with python injection thingys)
05:58:06 <Jonno_FTW> i'm testing it on #perwl on rizon
05:58:27 <mauke> so if I said "6.8.2 PRIVMSG #perwl"
05:58:44 <Jonno_FTW> yes that would be fixed
05:58:45 <mauke> it would reply http://"6.8.2
05:59:14 <pastorn> hello mauke :)
05:59:23 <Jonno_FTW> the above was to prevent it from replying to server messages
05:59:56 <Jonno_FTW> but I guess I don't need it, as long as it only checks the things users say
06:03:40 <malosh> How to seek on a semi-closed handle ?
06:04:22 <mauke> you don't, it's closed
06:05:11 <malosh> You mean I have to reopen it ?
06:05:20 <mauke> how about you don't close it in the first place
06:05:42 <malosh> btw, it's closed but you can read it. Why am I not able to seek ?
06:05:57 <mauke> if it's closed, you can't read from it
06:06:22 <malosh> if it is semi-closed, the hGetContents in System.IO can read from it
06:06:29 <mauke> no, it can't
06:07:01 <McManiaC> pastorn: how does that bottest work? :D
06:07:05 <malosh> for instance if I do withFile "file" ReadMode $ \f->hGetContents f then what does it do ?
06:07:16 <pastorn> McManiaC: it's just a channel for testing stuff
06:07:23 <mauke> that's evil and you should use readFile instead
06:07:43 <McManiaC> hmkay
06:07:47 <pastorn> McManiaC: nothing special... just that the guys there try out your features (if they're awake) when you announce them :)
06:07:47 <malosh> suppose I don't (I'm writing a library)
06:07:51 <mauke> malosh: hGetContents takes an open handle, reads its contents into a string, and closes it
06:08:05 <mauke> malosh: except it uses evil lazy io
06:08:23 <malosh> ah ok, but that's precisely what I'm trying to do !
06:08:25 <mauke> so the handle isn't really closed but is bound to the returned string
06:08:43 <mauke> but that's an implementation detail; as far as other functions are concerned, that handle is dead
06:08:44 <malosh> and it is not seekable ?
06:08:53 <mauke> dude, it doesn't make sense to seek on a closed handle
06:09:08 <malosh> hmm, right !
06:09:10 <malosh> thanks
06:09:22 <mauke> if you want to seek, you shouldn't use hGetContents
06:15:54 <Keegz> New maemo video http://420stars.info/watch?v=AksDp2
06:17:05 <xerox> spam
06:17:23 --- mode: xerox set +b *!*@203-219-249-173.static.tpgi.com.au
06:17:37 --- mode: xerox set -o xerox
06:24:47 <McManiaC> there arent any encoding informations inside a CString, are there?
06:25:15 <olsner> no, it's just a pointer to some bytes
06:25:20 <xerox> ?hoogle CString
06:25:21 <lambdabot> Foreign.C.String type CString = Ptr CChar
06:25:21 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
06:25:21 <lambdabot> Foreign.C.String newCString :: String -> IO CString
06:25:36 <McManiaC> *Commands.Curl> c <- newCString "❤"
06:25:36 <McManiaC> *Commands.Curl> peekCString c >>= putStrLn
06:25:36 <McManiaC> d
06:25:37 <McManiaC> :S
06:26:23 <olsner> you probably want a newCString variant that takes an encoding to use, or one that uses utf8
06:27:12 <olsner> could maybe use encodeString/decodeString from utf8-string
06:27:40 <McManiaC> well that lib returns a CString tho :S
06:44:07 <Jonno_FTW> sleep time
06:44:20 <Jonno_FTW> all these monadic parsers can wait till morning
06:57:32 <danderson> I'm having trouble running System.Cmd.rawSystem:
06:57:33 <danderson> rawSystem "echo" ["bleh"]
06:57:33 <danderson> Loading package unix-2.3.2.0 ... linking ... <interactive>: /home/dave/software/install/lib/process-1.0.1.2/ghc-6.10.4/HSprocess-1.0.1.2.o: unknown symbol `sysErrorBelch'
06:58:02 <danderson> googling doesn't show any particular known issue on this
06:58:07 <danderson> so, um... Help?
06:59:15 <danderson> never mind, it's just ghci that's borking.
07:11:59 <Twey> Is there any way to indicate to Text.XML.HXT.Arrow.Pickle that the order of the children in a particular element doesn't matter?
07:17:35 <appamatto> Is it a good idea to upgrade to the latest GHC?
07:18:18 <appamatto> 6.10.4 requires cabal 1.6.0.3 while Agda seems to want > 1.8.0.2
07:18:24 <voker57> depends
07:18:44 <voker57> if you won't miss gtk and some other stuff...
07:20:10 <Alpounet> gtk builds fine on 6.12.1 now
07:29:55 <Twey> Hm, formlets don't work with HTML?  ☹
07:33:22 <osaunders> :t (<=<)
07:33:23 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
07:33:34 <osaunders> :t (>=>)
07:33:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:35:30 <Zao> @type (>>=)
07:35:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:35:58 <Zao> Ah. The centre-= ones take a parameter, neat.
07:36:47 <byorgey> Zao: (<=<) and (>=>) are like composition but for things that look like  (a -> m b)  instead of for normal (a -> b) functions
07:40:53 <voidprayer> Excuse me, what is the I # of "len []     a# = I# a#" in the source of GHC.List's length?
07:40:57 <voidprayer> I#
07:41:18 <Zao> Magic.
07:41:19 <mauke> @src Int
07:41:19 <lambdabot> data Int = I# Int#
07:41:40 <voidprayer> mauke: You mean this?
07:41:49 <mauke> what?
07:41:54 <voidprayer> I#
07:42:28 <Heffalump> it's the constructor that goes from the unboxed value to the boxed value
07:42:52 <voidprayer> Heffalump: I see. Thank you and you helps again. Thanks again.
07:43:03 <voidprayer> s/helps/help me/
07:43:27 <Heffalump> you're welcome :-)
07:44:02 <doserj> can someone kick [Yankee] for pm-spamming, please?
07:44:13 --- mode: ChanServ set +o Heffalump
07:44:26 --- mode: ChanServ set +o mauke
07:44:26 --- kick: [Yankee] was kicked by mauke ([Yankee])
07:44:26 --- mode: mauke set +b *!*@95.66.13.22
07:44:35 <lep-delete> @type lift
07:44:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:44:39 <Jafet> (How does that help pm-spamming?)
07:44:42 --- mode: Heffalump set -o Heffalump
07:44:48 <medfly> I think it breaks his very dumb script
07:44:53 <mauke> does no longer see joins in #haskell
07:44:53 <Heffalump> Jafet: well, they can't then continue to trawl the channel for more nicks to spam
07:45:25 <doserj> thanks, mauke
07:46:26 --- mode: mauke set -o mauke
07:46:59 <dv-> How would I go about solving this: Cabal-1.8.0.2-f1b96fbe00cb2101ed495d60417d9464 is shadowed by package Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a
07:49:02 <Polarina> Why isn't this code snippet compiling properly? http://codepad.org/6T9ouDrn
07:49:25 <Heffalump> dv-: what context do you get the error in?
07:49:50 <mauke> Polarina: because you can't sqrt an Integer
07:50:08 <Polarina> mauke, erm?
07:50:16 <tensorpudding> you can't use the prelude function sqrt on an Integer
07:50:22 <Jafet> :t sqrt
07:50:23 <lambdabot> forall a. (Floating a) => a -> a
07:50:23 <dv-> Heffalump, I'm trying to build Leksah
07:50:38 <Polarina> But what is this RealFrac, Floating, Integral?
07:50:44 <centrinia> :t fromIntegral
07:50:45 <lambdabot> forall a b. (Integral a, Num b) => a -> b
07:50:51 <mauke> Polarina: typeclasses
07:50:59 <Polarina> Yes, but why are they popping up?
07:51:09 <mauke> Polarina: because your code is wrong
07:51:13 <Polarina> ...
07:51:30 <mauke> what do you mean by "popping up"?
07:51:46 <Polarina> Changing [1..100] to [1.0..100.0] doesn't help it. :(
07:51:49 <Jafet> That's what she said
07:52:09 <dv-> Heffalump, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23279#a23279
07:52:17 <mauke> Polarina: what do you think is the type of pythagorize?
07:52:20 <tensorpudding> @type [1.0..10.0]
07:52:21 <lambdabot> forall t. (Fractional t, Enum t) => [t]
07:52:32 <centrinia> :t (floor . sqrt . fromIntegral $ a^2 + b^2)
07:52:33 <Polarina> mauke, I don't know.
07:52:33 <lambdabot> forall b. (Integral b) => b
07:52:35 <Twey> :t (^)
07:52:36 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:52:45 <centrinia> :t (\a b -> floor . sqrt . fromIntegral $ a^2 + b^2)
07:52:46 <lambdabot> forall b a. (Integral b, Integral a) => a -> a -> b
07:52:48 <Twey> :t sqrt
07:52:50 <lambdabot> forall a. (Floating a) => a -> a
07:52:53 <mauke> Polarina: well, find out what you want, then
07:52:55 <centrinia> > (\a b -> floor . sqrt . fromIntegral $ a^2 + b^2) 4 5
07:52:56 <lambdabot>   6
07:53:00 <Twey> ^ results in an Integral, but you need a Floating for sqrt.
07:53:07 <Twey> :t (**)
07:53:08 <Polarina> mauke, I am sorry, but I honestly do not know.
07:53:08 <lambdabot> forall a. (Floating a) => a -> a -> a
07:53:12 <Twey> Try this one
07:53:17 <Polarina> Twey, thanks.
07:53:33 <mauke> Polarina: if you don't know what you want to do, why are you trying to write code?
07:53:36 <Heffalump> dv-: hmm. No clue. Does -v help?
07:53:44 <Polarina> mauke, I want that to work.
07:53:49 <mauke> define "work"
07:53:53 <Polarina> Work!
07:53:53 <Twey> > let pyth a b = sqrt (a ** 2 + b ** 2) in pyth 3 4
07:53:54 <lambdabot>   5.0
07:54:30 <centrinia> > (\a b -> floor . sqrt . fromIntegral $ a^2 + b^2) (3 :: Int) 4
07:54:31 <lambdabot>   5
07:54:41 <xerox> > magnitude (3 :+ 4)
07:54:42 <lambdabot>   5.0
07:55:01 <Twey> That'd do it too ☺
07:55:07 <tensorpudding> there is a magnitude function?
07:55:13 <centrinia> :t magnitude
07:55:14 <tensorpudding> is that in Data.Complex?
07:55:14 <lambdabot> forall a. (RealFloat a) => Complex a -> a
07:55:17 <Polarina> centrinia, thanks.
07:55:18 <Twey> @index magnitude
07:55:18 <lambdabot> Data.Complex
07:55:34 <tensorpudding> damn, i used to write my own function for that
07:55:37 <dv-> Heffalump, No idea what's going on. "This package indirectly depends on multiple versions of the same" What does that even mean?
07:55:41 <tensorpudding> i must've missed it
07:55:56 <Polarina> @type (:+)
07:55:57 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:56:08 <tensorpudding> (:+) constructs a complex number
07:56:18 <Polarina> o.O
07:56:19 <Twey> Polarina: pyth a b = magnitude (a :+ b)
07:56:27 <centrinia> Why does (:+) have typeclass restrictions?
07:56:43 <Twey> pyth = fmap magnitude . (:+)
07:56:51 <tensorpudding> well, without it, you couldn't represent abs correctly
07:57:28 <tensorpudding> since sqrt(a^2+b^2) is not always an integer for a,b integers
07:57:41 <centrinia> Ah.
07:57:56 <tensorpudding> only when a and b are legs of a pythagorean right triangle
08:01:56 <Polarina> How can I floor a RealFloat?
08:02:30 <tensorpudding> @type floor
08:02:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:02:46 <Polarina> It's whining somehow about an ambiguous type.
08:02:56 <tensorpudding> is there any types that are instances of RealFloat but not RealFrac?
08:04:01 <Jafet> @src RealFloat
08:04:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:04:50 <MaciejP> Polarina: What's the code?
08:05:52 <Polarina> MaciejP, pythagorize a b = floor . magnitude $ (a :+ b)
08:07:13 <tensorpudding> it can return any instance of Integral
08:07:46 <Polarina> tensorpudding, yes, but when I use that function, it complains about an ambiguous type:  problem = [sum [a, b, pythagorize a b] | a <- [1..100], b <- [1..100]]
08:08:02 <tensorpudding> so you'll have to specify a type signature, or it will have to default it
08:08:15 <Polarina> Where do I specify the type signature?
08:08:30 <doserj> Polarina: that code says that a, b, and pythagorize a b have the same type, which is not possible
08:08:48 <tensorpudding> you can specify type signatures anywhere in the program, on its own line, but most people put it on the line above the function definition
08:09:02 <tensorpudding> ah hmm, right
08:09:16 <tensorpudding> a,b must be instances of RealFrac
08:09:17 <Polarina> doserj, how do I make them the same type then?
08:09:21 <doserj> Polarina: you need to use fromIntegral somewhere
08:09:29 <Polarina> @type fromIntegral
08:09:30 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:09:43 <tensorpudding> you should do fromIntegral $ pythagorize a b
08:09:49 <Polarina> Thanks.
08:10:07 <lep-delete> @src ($)
08:10:07 <lambdabot> f $ x = f x
08:10:15 <Polarina> Cool, thanks.
08:11:34 <lep-delete> @src (.)
08:11:35 <lambdabot> (f . g) x = f (g x)
08:11:54 <tensorpudding> hmm
08:11:56 <tensorpudding> @type (.)
08:11:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:12:05 <tensorpudding> caleskell is still there
08:15:49 <MaciejP> > succ . [1,2,3]
08:15:50 <lambdabot>   [2,3,4]
08:15:55 <MaciejP> Interesting
08:16:12 <Zao> This is the Cale-period operator, right?
08:16:26 <tensorpudding> heh, is that what we're calling it?
08:16:37 <tensorpudding> cale redefined (.) to mean fmap
08:16:41 <MaciejP> Oh, it's not the standard definition?
08:16:47 <Zao> @type fmap
08:16:47 <tensorpudding> well
08:16:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:16:50 <tensorpudding> there is a good reason
08:17:11 <tensorpudding> because you can define an instance of Functor for ((->) a) which has fmap = (.)
08:17:20 <Zao> The regular (.) is like fmap on the identity monad or something?
08:19:45 <Twey> Zao: On the function functor
08:20:05 <Twey> Functors have fmap, monads have join
08:20:11 <Twey> (or bind)
08:20:17 <tensorpudding> the functor is a functor on hom-sets from a particular object
08:20:28 <Zao> In my world, if you have   t a,   t is a monad until proven otherwise :P
08:20:37 <Zao> Which I know is horribly wrong, but it's never wrong to rub people the wrong way.
08:20:42 <Twey> Heh
08:20:51 <tensorpudding> or rather, it returns a function in the hom-set
08:21:14 <Twey> tensorpudding: Gesundheit :þ
08:22:25 <mauke> <newbie> what's a monad?  <Zao> what isn't?
08:22:31 <Twey> Zao: The perhaps-more-general definition of fmap is that it lifts a unary function to operate a functor
08:22:54 <tensorpudding> is that a quote?
08:23:05 <Twey> Zao: The ‘value’ ‘inside’ the function functor is the result of the function when applied to something
08:23:43 <Twey> Zao: If you look at fmap as applying another function to that future value, it's trivial to see that it's just composition
08:25:17 <tensorpudding> you lift a function into the "functions which start at a" space by prepending it with a function starting at a
08:25:27 <tensorpudding> a space"
08:25:40 <tensorpudding> or a" space
08:25:45 <nomeata> Hi. Ghc uses too much memory when building something like highlighting-kate on some arches, especially profiling libraries. Are there any easy trickts to reduce memory consumption?
08:25:55 <Twey> tensorpudding: Your corrections confuse me :þ
08:25:59 <tensorpudding> sorry
08:26:15 <tensorpudding> "functions which start at type a" space
08:26:38 <tensorpudding> (it's annoying that haskell uses lower-case letters for type variables)
08:28:54 <opqdonut> just call it (a->) ?
08:30:40 <osaunders> tensorpudding: Why is that annoying?
08:31:08 <tensorpudding> because they are hard to intersperse in writing like what i did
08:31:12 <Twey> tensorpudding: Try quotation marks :þ
08:31:25 <Twey> ‘Functions that start at “a”’
08:31:30 <mauke> just use greek letters
08:31:36 <osaunders> Oh you could say t1, t2, etc.
08:31:37 <mauke> id :: α -> α
08:31:41 <Twey> Heh
08:31:46 <Zao> Functions that start at ?a.
08:32:00 <Zao> Although that's lambdabotese for "unknown variable", so that'd be dumb.
08:32:19 <mauke> it's ghcese for implicit parameters
08:32:46 <osaunders> Zao: I don't agree.
08:32:50 <tensorpudding> it's slightly harder to write greek letters
08:33:17 <Zao> tensorpudding: Where by slightly is "very".
08:33:21 <Zao> +much
08:33:22 <Twey> :t ?a
08:33:23 <lambdabot> forall t. (?a::t) => t
08:33:25 <Twey> > ?a
08:33:26 <lambdabot>   Unbound implicit parameter (?a::a)
08:33:26 <lambdabot>    arising from a use of implicit parame...
08:33:29 <tensorpudding> well
08:33:31 <tensorpudding> on emacs
08:33:37 <tensorpudding> you can switch input mode to greek
08:33:58 <tensorpudding> α β γ δ ε  etc.
08:34:11 <mauke> make S⃒S⃒S⃒ fast
08:34:16 <Zao> Emacs can go gently caress it self.
08:34:28 <tensorpudding> what are those characters between?
08:34:34 <Zao> See. I'm so disturbed by your statement, I start separating composite words.
08:35:02 <tensorpudding> there are plenty of other things that support alternate input modes
08:35:11 <tensorpudding> scim, for instance
08:35:18 <tensorpudding> (off-topic)
08:35:22 <mauke> U+0053 (53): LATIN CAPITAL LETTER S [S]; U+20D2 (e2 83 92): COMBINING LONG VERTICAL LINE OVERLAY [⃒]
08:40:58 <commanace> hey... I'm trying to tinker a bit with haskell and control systems and that way try to learn both :D not sure yet whether that's a good strategy ;-) the point is, i thought that a control system looks like something monadic, but i don't know enough about it to say for sure...
08:41:07 <commanace> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23280#a23280
08:41:28 <commanace> that's the code (probably won't even compile right now :) )
08:42:00 <commanace> looking at the thing at line 85
08:45:33 <commanace> i would expect that concatinating control systems is something like binding monads... you could for example bind a (LTI Int) to an (LTI Double) which would correspond to a digital to analog converter
08:47:09 <commanace> but on the other hand i think that the identity for example does not make much sense... gosh i like this abstraction but for a beginner that can be a bit confusing :)
08:47:56 * hackagebot nonlinear-optimization 0.3.1 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.1 (FelipeLessa)
09:04:59 <danderson> how do I manually fire a parse error from a Parsec parser?
09:05:27 <danderson> I'm trying to write a parser which should parse a number in a certain range, and fail if the parsed number is outside that range
09:05:39 <danderson> (where number = read <$> many digit)
09:05:42 <mauke> you could use fail
09:05:48 <pikhq> Um. I'm not certain, but I *think* fail would do it.
09:06:11 <danderson> ah, of course, the monadic bastard child
09:06:13 <danderson> let's see...
09:06:32 <ehamberg> is (randoms g :: [Double]) guaranteed to only return numbers 0 ≤ n ≤ 1? (it seems to do that in ghc 6.12.)
09:08:13 <MadHatterDude> Yo guys
09:08:32 <danderson> hmm, fail works, but the error is rather awful
09:09:01 <MadHatterDude> @pl (\x -> (map tail $ fst x, snd x))
09:09:01 <lambdabot> first (map tail)
09:09:44 <danderson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23282#a23282
09:14:14 <chrisdone> I've not yet discovered why I ought to find `fail' worth using
09:15:06 <pastorn> chrisdone: have you written a typechecker?
09:15:16 <pastorn> or a parser?
09:15:27 <chrisdone> no
09:15:33 <pastorn> ok then ;)
09:15:57 <chrisdone> I have, but I was curious to see if your answer would be one of those kinds if I said no, and it was. shame on you
09:16:24 <chrisdone> explain yourself!
09:16:29 <pastorn> what? for giving the obvious answers?
09:17:03 <pastorn> i don't know any other monads where fail makes much sense...
09:17:14 <pastorn> maybe it does in Cont... who knows...
09:17:34 <Saizan> not really
09:17:51 <Saizan> unless you are in Cont String
09:18:30 <pastorn> Saizan: is that a parser?
09:21:26 <chrisdone> I used it once and realised I didn't want to just return a string, and probably will never use it over a more general solution
09:22:21 <nomeata> Hmm, when building a bunch of modules in one ghc 6.12.1 run (e.g. from cabal), memory consumptions is steadily increasing. Is there a memory leak somewhere?
09:25:15 <Philippa> danderson: pzero
09:25:31 <Philippa> or pzero <?> "error message"
09:26:06 <Philippa> you're probably stuck with the awful message though
09:26:21 <MadHatterDude> :t (<?>)
09:26:22 <lambdabot> Not in scope: `<?>'
09:26:45 <Philippa> MadHatterDude: we're talking Parsec
09:26:58 <MadHatterDude> Philippa: Ah
09:27:28 <MadHatterDude> I'm making a semi-functional language, is it worth using for that?
09:27:47 <Philippa> it's a good approach for programming language parsing, yeah
09:28:01 <NEEDMOAR> What's the difference between Text.Parsec and Text.ParserCombinators.Parsec?
09:28:16 <Philippa> one's the new parsec 3 modules, the other's parsec 2
09:28:24 <pastorn> NEEDMOAR:
09:28:29 <MadHatterDude> Is it faster for a relatively small grammar than a custom implementation?
09:28:32 <pastorn> are you jonno?
09:28:50 <NEEDMOAR> Philippa: and why do they mantain both?
09:28:58 <NEEDMOAR> pastorn: no, I'm afraid I am not.
09:29:12 <pastorn> NEEDMOAR: nice nick :)
09:29:23 <Philippa> MadHatterDude: depends on your custom implementation
09:30:00 <Philippa> NEEDMOAR: because until recently parsec 3's performance for things parsec 2 could do wasn't on a par with parsec 2
09:30:25 <MadHatterDude> Philippa: Ok. I think I can get away with about 7 pattern matching cases and relatively simple code for each
09:30:36 <NEEDMOAR> Philippa: oh, thanks.
09:30:40 <NEEDMOAR> pastorn: thank you sir.
09:31:01 <Philippa> MadHatterDude: parsec'll definitely scale better if you're ever going to extend it
09:31:53 <MadHatterDude> Phillippa: Ok. I probably won't though, I've already thought up the syntax.
09:32:21 <Philippa> fair enough if it's an esolang, I guess
09:32:51 <MadHatterDude> Philippa: It's an APL-inspired, so in a way.
09:33:02 <MadHatterDude> Philippa: :P
09:34:07 <NEEDMOAR> Philippa: which one is parsec 3, and how would I know which one was it if I didn't ask you?
09:35:51 <MaciejP> NEEDMOAR: Text.Parsec.* is Parsec 3. These modules were not included in Parsec 2
09:36:02 <MadHatterDude> I was thinking of making every linux command line util in haskell. Yay or Nay?
09:36:28 <Twey> Nay
09:36:28 <Heffalump> are you going to make them run as fast?
09:36:33 <Twey> Strings are the past
09:36:57 <Twey> Do something PowerShellish, but with strong typing!
09:39:03 <NEEDMOAR> MaciejP: but shouldn't that be documented somewhere in Parsec's package or something?
09:39:39 <MaciejP> Hhm, I thought it is
09:40:56 <MaciejP> NEEDMOAR: Text.ParserCombinators.Parsec says `Parsec compatibility module'
09:41:51 <benmachine> Twey: do you mean Strings or strings
09:42:02 <benmachine> actually even if you answer that I still don't know what you're talking about
09:42:29 <Twey> benmachine: Linux tools use strings as the Universal Data Format
09:42:43 <Twey> Which works, but is hideous
09:42:46 <benmachine> oic
09:42:50 <Twey> And requires Much Duplication of Process
09:42:54 <NEEDMOAR> MaciejP: oh, I see. It'd be nice if they could explain it a bit more in the documentation.
09:43:10 <Twey> PowerShell is a Microsoft innovation (I know right) that uses .NET objects instead of strings in the shell
09:43:10 <benmachine> so you are suggesting a more general I/O interface, essentially?
09:43:11 <SamB_XP> Twey: at least they don't parse their own commandlines into strings!
09:43:20 <Twey> SamB_XP: Some of them do :þ
09:43:40 <SamB_XP> Twey: I mean, *nix programs get their commandlines pre-split into args
09:43:52 <SamB_XP> not so Windows programs!
09:44:15 <Twey> benmachine: I was thinking that a shell with proper typing, pattern-matching, &c. would be nice, if done properly
09:44:20 <SamB_XP> it's probably one Windows' worst warts
09:44:26 <Twey> SamB_XP: Really?  But Windows programs have argv, don't they?
09:44:58 <benmachine> Twey: basically make ghci, but a bit more convenient? :P
09:45:03 <SamB_XP> Twey: that's parsed by libc
09:45:10 <Twey> SamB_XP: Oh, ew
09:45:11 <SamB_XP> and they have a lot of libcs to choose from!
09:45:11 <Twey> benmachine: Nah
09:45:27 <Twey> benmachine: GHCi is made for running Haskell code, not interacting with the OS
09:45:44 <SamB_XP> WinMain doesn't even receive argv as a parameter
09:45:52 <benmachine> all right but I mean you could have things like ls :: IO String
09:45:55 <Twey> An interactive development environment and an OS shell are similar, but have different goals
09:45:58 <benmachine> as silly as that might be
09:46:12 <benmachine> or, ls :: IO [FilePath] I guess
09:46:16 <Twey> benmachine: But you don't want it to be IO String — that's my point.  That's the current ls.
09:46:20 <Twey> Yeah
09:46:22 <Twey> IO [FilePath] is the one
09:46:24 <SamB_XP> that's probably the single worst vestige of DOS that lives on
09:46:28 <Twey> SamB_XP: Urrgh
09:46:50 <benmachine> except it would have some weird polymorphic type that let it take variadic arguments :P
09:46:59 <benmachine> or maybe it wouldn't
09:47:07 <zoLevDotCom>  ;)
09:47:20 <benmachine> maybe arguments would be just like, compositions
09:47:24 <benmachine> or operators of some other kind
09:47:49 <SamB_XP> ls :: LsOptions opt => opt -> [FilePath] -> IO [FilePath]
09:48:08 <SamB_XP> (I figure opt is some kind of extensible record or something ;-P)
09:48:52 <SamB_XP> oh, except actually you'd want some stat results and stuff too sometimes ?
09:49:06 <benmachine> mm
09:49:19 <benmachine> say what you like about strings, they're pretty versatile
09:50:35 <chrisdone> it would be awesome is pipeable commandlines were well typed and polymorphic!
09:51:58 <chrisdone> vgrabj >>= (convert :: JPEG -> IO PNG)
09:51:58 <increpare> hey guys - has anyone had trouble installing the OSX version of 6.12.1? (with the binary installer) - I'm getting that the 'install' button is disabled in the installer, but I don't know why.
09:52:17 <Zao> What binary installer?
09:52:39 <increpare> Zao: GHC-6.12.1-i386.pkg , frome http://www.haskell.org/ghc/download_ghc_6_12_1.html#macosxintel
09:53:32 <increpare> it could be that I have OSX 10.6, but I'm not sure, so I thought I'd ask if anyone else has found this...
09:54:05 <Zao> If it's executable, any diagnostic output in a terminal maybe?
09:54:22 <Zao> I don't have any remote desktop access to a mac now, just ssh.
09:54:39 <increpare> Zao: ah ok.  There's no output that I can see from it in the system console.
09:55:15 <Zao> Seems to be 10.4 anyway, my systems.
09:55:28 <increpare> Zao: also it's not a standalone executable, it's a .pkg thing run by the osx installer program
09:55:33 <increpare> Zao: ah ok
09:56:21 <increpare> Any suggestions as to who I should talk to this about?  (I can just rebuild from the source myself)
09:58:03 <Zao> haskell-cafe maybe?
09:58:17 <Zao> increpare: Did you check the GHC trac for existing bugs?
09:58:41 <increpare> Zao: I haven't yet.  I'll see if my system config is screwed up first, then search through trac, then send an email : )
09:58:42 <increpare> cheers
10:08:10 <pokoko222> hello mortals, what math u as computer scientists use the most?
10:08:22 <pokoko222> calculus? or no calculus, just discrete?
10:09:14 <alp> algebra
10:09:24 <ulfdoz> defined by the problem.
10:10:50 <copumpkin> pokoko222: I use higher categories and operads the most
10:10:55 <copumpkin> especially for everyday programming
10:11:37 <pokoko222> copumpkin for what kind of problems?
10:11:45 <copumpkin> all of them
10:15:25 <increpare> copumpkin: :)
10:15:40 <thoughtpolice> i use almost no math, but then again i wouldn't consider myself a computer scientist
10:15:47 <thoughtpolice> does that mean my haskell license gets revoked?
10:15:51 <copumpkin> aie!
10:15:53 <copumpkin> I forgot again
10:15:55 * Twey doesn't use maths
10:15:57 <copumpkin> thoughtpolice: will do it right now!
10:16:01 <Twey> Heh, thoughtpolice beat me to it
10:16:08 <thoughtpolice> i heard you had to write at LEAST 3 papers on category theory before you can code haskell :(
10:16:14 * copumpkin only uses maff
10:16:30 <increpare> I'm not a computer scientist, alas, but I've tend towards graph/topology-related things of late.
10:16:52 <copumpkin> thoughtpolice: your licenses is hereby revoked. Leave and don't come back until you can explain coends to me.
10:16:59 <thoughtpolice> :(
10:18:03 <increpare> copumpkin: you been doing any fun stuff recently?
10:18:12 <copumpkin> loads of work and sulking, mostly
10:18:15 <copumpkin> so no :)
10:18:24 <increpare> increpare: hmm ok
10:19:05 <increpare> trying to get back on my haskell horse again - I have a chunk of profiling work I have to do but it doesn't appeal to me tooo much, so I've been putting it off...
10:19:27 <thoughtpolice> copumpkin: this makes me sad because now i'm stuck with c++/java at work. :(
10:19:35 * thoughtpolice considers becoming an ocamler...
10:19:56 <increpare> thoughtpolice: that would make c++/java more bearable?
10:20:26 <thoughtpolice> increpare: but if i don't have my haskell license, i can't stop writing c++/java at work to write haskell recreationally :P
10:20:43 <thoughtpolice> which happens a lot sometimes :p
10:21:10 <increpare> sometimes it happens a lot?
10:21:14 <Heffalump> who says you have an ocalm licence?
10:21:18 <Heffalump> s/ocalm/ocaml/
10:21:42 <copumpkin> thoughtpolice: I haz account 4 u
10:22:06 <thoughtpolice> Heffalump: :( does it require writing papers?
10:22:13 <thoughtpolice> copumpkin: awesum
10:22:19 <copumpkin> I PM'd details
10:22:27 <copumpkin> it's 10.5
10:23:19 <pokoko222> Anyone has done GRE test in computer science?
10:23:35 <copumpkin> not me
10:24:49 <thoughtpolice> copumpkin: thanks, 10.5 may/may not be easier to do things on :/ i have a SL system here at least so I can check as much as possible
10:25:11 <copumpkin> yeah, not sure whether it'll be easier or not
10:27:50 <pokoko222> copumpkin check it and let me know if u can solve those questions, at least 50 % of them http://www.ets.org/gre/subject/about/content/computer_science/index.html
10:28:08 <copumpkin> why?
10:28:50 <copumpkin> some of these questions are ridiculous
10:29:36 <macron> hi, does anyone know what happened to the plan to move ghc development from darcs to git?
10:31:10 <thoughtpolice> macron: i believe they held it off because darcs become 'good enough' pretty quickly
10:31:13 <increpare> Zao: ah, it works now, I reinstalled xcode : )
10:31:22 <thoughtpolice> and the process to switching to git was going to be insane, not gonna lie
10:31:25 <copumpkin> except that you still can't darcs get the repo
10:31:43 <thoughtpolice> having multiple versions of the boot libs in 2 different version control systems = insanity.
10:32:10 <macron> thoughtpolice: hm ok, but getting patches via darcs is still extremely slow. :-/
10:32:11 <Heffalump> copumpkin: what do you mean? I've been able to darcs get the ghc repo no problem.
10:32:20 <Heffalump> or do you mean the whole darcs-all script thing?
10:32:33 <thoughtpolice> er, well, not multiple versions, but different boot libs scattered across both git and darcs would have been crazy, because lots of changes and GHC can cause subsequent touches in boot libraries
10:32:35 <copumpkin> pokoko222: so far I feel pretty confident about all the questions I've encountered, but a lot of them are really dumb questions
10:32:59 <copumpkin> Heffalump: last time I tried the instrucitons were to fetch a tarball of a recent snapshot and then darcs(-all) pull -a from that snapshot
10:33:04 <copumpkin> because there were simply too many patches to grab
10:33:11 <pokoko222> copumpkin dumb? in what way?
10:33:20 <pokoko222> are u drunk now? :D
10:33:24 <thoughtpolice> copumpkin: when GHC switches to darcs2 format, hopefully that should go away entirely
10:33:25 <copumpkin> no
10:33:49 <copumpkin> pokoko222: question 1, for example
10:34:03 <copumpkin> even question 2 bothers me
10:34:03 <pokoko222> copumpkin nah ignore the first ones look further
10:34:16 <copumpkin> yes, I did a random sampling
10:34:17 <thoughtpolice> copumpkin: there is also a darcs2 mirror of the GHC repo somewhere but i can't remember where
10:34:26 <copumpkin> I'm just saying a lot of the questions are quite dumb
10:34:34 <thoughtpolice> copumpkin: apparently it was impressively fast and getting all of ghc took only a minute or so :)
10:34:41 <thoughtpolice> (no tarball)
10:34:51 <copumpkin> I know that floyd-warshall is theta(n^3) but I don't think that's fundamental CS knowledge
10:35:00 <copumpkin> especially when they don't define what n is
10:35:11 <Saizan> thoughtpolice: what's holding the switch to darcs2? and couldn't it switch to hashed at least?
10:35:30 <Heffalump> I think they are now switching to hashed.
10:35:31 <copumpkin> oh I guess they do define it
10:35:37 <copumpkin> but it's still silly in my opinion
10:35:46 <thoughtpolice> Saizan: not sure, as igloo or someone :/
10:36:02 <Heffalump> copumpkin: I've ignored those instructions and just done a get and it does work. There's a mirror someone runs that tends to perform better than the main GHC repo.
10:36:03 <increpare> looking through the gre thing now - looking up things I don't know might help patch a few holes in my cs knowledge : )
10:36:04 <thoughtpolice> it would be nice to switch because darcs 2 is pretty stable and fast these days
10:36:14 <copumpkin> Heffalump: interesting
10:36:21 <pokoko222> copumpkin wow then you are a computer science ninja
10:36:37 <copumpkin> pokoko222: I mean, I'd hope I know most of these questions
10:36:41 <Heffalump> darcs2 patches have better conflict behaviour than darcs1 patches, but aren't otherwise a significant performance improvement
10:36:45 <copumpkin> since it's supposed to test what you get in a CS degree
10:37:28 <pokoko222> u know, i think it is dumb asking about algorithms time, how am i suposed to remember what all sorting algorithms do in terms of time
10:37:51 <copumpkin> I think it's dumb too, but that's a fairly well known one
10:39:15 <pokoko222> i did the mergesort, quicksort, insert sort stuff before and i have forgotten their time now, so what that makes me less computer scientist
10:39:25 <Saizan> well, if you know how an algorithm works it shouldn't be much of a stretch to connect it with a time complexity
10:39:45 <vakosel> has anybody build gtk2hs in a win32 with msys and gtk+ installed?
10:39:56 <vakosel> mean win32 os
10:40:10 <Saizan> (there are some algorithms for which the calculation is fairly complex though)
10:40:12 <pokoko222> Saizan am i support to remember after a year insert sort vs quick sort vs bublle sort?
10:40:17 <pikhq> pokoko222: Actually, intuition helps a lot.
10:40:26 <Saizan> pokoko222: how they work? i think so
10:41:03 <pikhq> You should be able to think about bubble sort and see that it's ridiculously slow compared to anything else. Not necessarily see "Oh, it's O(n^2)."
10:41:09 <copumpkin> your intuition might not help with a disjoint set datastructure :) or a fibonacci heapp
10:41:11 <copumpkin> -p
10:41:24 <dullard> does monad rhyme with gonad?
10:41:39 <copumpkin> dullard: sure
10:41:50 <dullard> good
10:42:07 <pokoko222> i am first year cs, and i did sorting algorithms on my own before but i keep forgetting them from time to time and i always use reference when need them now and then
10:42:10 <pikhq> copumpkin: Sure. That's when you get out the complexity analysis.
10:42:18 <dons> or "mon" as in "ton"
10:42:28 <pokoko222> i guess they will put sorting algorithms on exams in second year, ah, that will make me remember them
10:42:33 <shepheb> is there an official pronunciation? I've heard "m-aww-nad" and "m-owe-nad", not sure which if either is correct.
10:42:38 * copumpkin actually has no clue how to get to the inverse ackermann in disjoint sets
10:42:55 <Saizan> see "the catsters" videos on youtube
10:42:55 <pikhq> pokoko222: Eh, don't worry too much about it. In "reality", you *will* be using reference documentation all the time.
10:42:56 <c_wraith> copumpkin: union-by-rank and path compression
10:43:21 <copumpkin> c_wraith: yeah, I know how the datastructure works, but I don't know how the analysis leads to inverse ackermann... never looked at the derivation
10:43:27 <pikhq> You'll probably get useful algorithms down just by using them enough, not by a concerted effort to memorise them.
10:43:58 <Saizan> knowing algorithms helps in writing new ones too, though
10:44:07 <c_wraith> copumpkin: ah.  I looked at it, but it washed right over me.  I *do* remember how union-by-rank alone gives O(n lg n)
10:44:13 <copumpkin> ah :)
10:44:15 <pikhq> Saizan: Yes. But you're not going to memorise algorithms.
10:44:21 <pikhq> You're going to *grok* them.
10:44:26 --- mode: ChanServ set +o mauke
10:44:26 --- mode: mauke set -b *!*@95.66.13.22
10:44:32 * copumpkin groks pikhq 
10:44:44 <Saizan> depends on what you mean :)
10:44:52 <theorbtwo> Moan-ad.
10:45:17 <c_wraith> theorbtwo: now you're making it sound kinky
10:45:31 <pikhq> "Memorisation" as in "could easily write down the algorithm on a piece of paper." "Grok" as in "comprehend what the algorithm does, how it does it, and why".
10:45:32 <Saizan> you'll need to memorise the idea behind them, and the tradeoffs they make
10:45:33 <theorbtwo> c_wraith: Or just annoying...
10:45:48 <Saizan> pikhq: the latter seems to imply the former to me
10:45:57 <pokoko222> how about just memorize how to search on wikipedia?
10:46:05 <theorbtwo> OTOH, if you understand bubble sort, you should be able to write it.
10:46:25 <Saizan> pokoko222: that doesn't help you to write better code
10:46:26 --- mode: mauke set -o mauke
10:46:28 <copumpkin> pokoko222: memorizing tends not to be a good idea
10:46:30 <c_wraith> I don't understand bubble sort.  I think it's the most oblique sorting algorithm ever.  I think there are lots better options. :)
10:46:41 <pikhq> Saizan: Yes, but you're not going to actually try to memorise the algorithm. You're going to understand the design of it.
10:46:46 <copumpkin> well, it might be if your goal is to demonstrate knowledge for a week after memorizing
10:46:48 <pikhq> And from there, using it is pretty easy.
10:46:50 <c_wraith> I think nearly *every* sort algorithm is simpler than bubble sort
10:47:15 <pikhq> Even if you have to occasionally pull up a psuedocode of the algorithm for a tricky bit that you forgot.
10:47:16 <pokoko222> i think even Obama knew about bubble sort
10:47:35 <pokoko222> on an interview... wierd
10:47:44 <Saizan> i wonder, was bubble sort invented to be a bad example, or what?
10:47:46 <copumpkin> you should know bogo and bozosort
10:47:48 <pikhq> Bubble sort is the *naive* sorting algorithm. ... In imperative programming environments.
10:47:55 <FunctorSalad> hmm the hackagebot on twitter is useful but it drowns out everything else ;)
10:47:58 <twink> I usually use selection sort as a simpler naive sorting algorithm than bubblesort.
10:48:09 <pikhq> Saizan: Naive programmers in imperative languages will use it.
10:48:09 <copumpkin> http://en.wikipedia.org/wiki/Bogosort
10:48:14 <c_wraith> selection and insertion are both much simpler naive algorithms than bubble sort
10:48:19 <twink> Bubblesort is substantially more complex than selection sort.
10:48:35 <copumpkin> how is bubblesort complex?
10:48:42 * sm wonders what FunctorSalad is talking about
10:48:47 <pikhq> I'd say selection and insertion sort are slightly less *obvious*. Though much simpler.
10:48:53 <twink> copumpkin: In terms of proof of correctness.
10:48:54 <FunctorSalad> sm: http://twitter.com/Hackage
10:48:55 <c_wraith> copumpkin: the reason why it works is significantly less obvious.
10:48:59 <copumpkin> twink: ah, yes
10:49:28 <twink> copumpkin: When you want an easy answer to "Why does this work?" selection sort conquers all IMHO.
10:49:34 <copumpkin> true :)
10:49:51 <sm> ha!
10:49:51 <copumpkin> I think dolio proved insertion sort
10:49:55 <pokoko222> if u ask me u can spend a hole life time just on sorting algorithms
10:49:59 <sm> hackage sends out more tentacles
10:50:05 <pikhq> pokoko222: It is possible.
10:50:09 <pikhq> Though a bad choice.
10:51:29 <TempestAdept> hello overybody.. I'm solving a haskellgolf problem. I need  to multiply 2 matrices, 1st is given  by rows, 2nd by columns
10:51:38 <TempestAdept> this code works:  main=readLn>>=print.uncurry(flip(map.flip(map.(foldl1(+).).zipWith(*))))
10:51:40 <twink> Insertion sort is more complicated though it's not far out by any means.
10:51:52 <TempestAdept> but I need to shorten it
10:52:02 <burp> ew this is horrible
10:52:11 <copumpkin> why not sum instead of foldl1(+) ?
10:52:21 <copumpkin> you should be able to get away with fewer flips
10:52:38 <TempestAdept> oh.. i'm stupid..
10:52:59 <TempestAdept> but i couldnt get rid of those flips..
10:53:47 <theorbtwo> For what it's worth, I used to code bubble sort all the freaking time.  Of course, this was in the age of 5.25 inch floppies, and gwbasic.
10:53:52 <twink> TempestAdept: A lot of this depends on the formats of the matrices.
10:54:11 <theorbtwo> It's a very simple sort, that is very easy to get right.
10:54:33 <Twey> I've always preferred quicksort
10:54:35 <TempestAdept> they are given as lists of lists, first by rows, second by columns
10:54:37 <twink> theorbtwo: Yeah, it's sort of a bikeshedding affair because even some of the less naive sorts (even non-quadratic!) are still plausibly in the realm of "easy."
10:54:44 <Twey> It just Makes More Sense than bubble-sort
10:54:46 <copumpkin> TempestAdept: what can you use? foldMap would merge two of those
10:55:10 <copumpkin> ah actually no
10:55:13 <TempestAdept> well, this is haskellgolf.. code needs to be as short as it's possible
10:55:32 <Saizan> pokoko222: well, the point is not really that they are sorting algorithms, (even if sorting is a relatively common need), but that they are examples of different algorithms for the same problem, which should teach something about algorithm design, so maybe you just have to pick a different case study
10:55:40 <twink> Twey: A lot of it depends on if you're sorting lists or arrays, and if there's imperativeness or otherwise what language.
10:56:33 <theorbtwo> It also depends on how much you value speed of execution vs a host of other factors; certianty that you have coded it correctly, space of execution, time it takes to code it.
10:57:04 <twink> Twey: One thing I used to like to do when presented with the data incrementally was heapsort, where I'd incrementally maintain the heap and then only at the end do any sorting.
10:57:50 <Twey> twink: That's true
10:58:05 <theorbtwo> Oh, and if you have a whole bunch of data and need to sort all of it, or if you are getting one item at a time, and need something sorted after each one.
10:58:41 <theorbtwo> In the second case, insertation sort is a clear win -- even in a straight battle of execution time, over algorithms that have a better naive assesement of O().
10:58:52 <copumpkin> columnsort!
10:59:20 <theorbtwo> Quicksort, for example, has pathalogical behavior in the case where the list starts almost sorted.  IIRC.
10:59:21 <twink> Twey: For instance, I wrote a "heapsort" mini-util where only some bounded number of outputs was ever going to happen, and then maintain a heap in reverse order, insert into it until it overflowed, then at each step dequeue and enqueue, and then at the end do the wrap-up phase of heapsort and so on.
10:59:52 <twink> Twey: Essentially in order to do cmd | sort | tail
11:00:39 <theorbtwo> Oh, another factor -- some algorithms will keep the relative order of items that compare equal in the input.  Others won't.
11:00:57 <theorbtwo> Algorithm choice is almost never as simple as "pick the one with the smallest O()".
11:00:59 <Saizan> "stability"
11:01:22 <theorbtwo> Saizan: Yes, that's the proper term.  I was explaining it on purpose.
11:01:25 <pikhq> I'm still fond of bucket sort.
11:01:44 <theorbtwo> In fact, the idea that every algorithm has a single O() is a fallacy.
11:01:48 <pikhq> It's my prefered sorting algorithm for hand-sorting.
11:03:00 <copumpkin> every O() is a set of them
11:06:05 <Saizan> every statement about performance should be formalized as a theorem in your language, so you can check all the preconditions and limitations :)
11:06:36 <imc> hello!
11:06:55 <imc> I'm trying to use Graphics.GD library but got stuck :/
11:07:13 <Saizan> how?
11:07:15 <imc> i would like to 1. create a new image (newImage size)
11:07:42 <imc> then 2. set all its pixels (setPixel point color image)
11:07:48 <theorbtwo> Saizan: It'd be an interesting test library that you could tell to test that your function takes O(n) time with a crossover point of less then m.
11:07:56 <imc> data about points/pixels are in a structure of mine
11:08:13 <imc> the problem: newImage  :: Size  -> IO  Image
11:08:29 <imc> setPixel  :: Point  -> Color  -> Image  -> IO  ()
11:08:32 <Saizan> theorbtwo: ah, not check in that sense
11:09:06 <imc> i create an image, i get an IO Image, then i must feed setPixel but dunno how to "get rid" of the IO thing (sorry, i'm still quite noob)
11:09:27 <Saizan> imc: do image <- newImage size; setPixel point color image;
11:09:35 <imc> I imagine it's an IO Image because it's memmapped from hd
11:09:44 <Saizan> imc: and IO Image and an Image are fairly different things.
11:10:11 <Saizan> imc: and IO Image is a computation that when executed will give you an Image as result
11:10:19 <imc> Saizan: yeah... i used newImage size >>= setPixel pt col
11:10:27 <roconnor> the "average" O notation depends on the distribution of inputs
11:10:34 <theorbtwo> Oh, you mean decorate every operation with a performance penalty, and try to compute the performance of everything from it's constituant parts?  Sounds... nasty.
11:10:39 <imc> isn't the same as do notation?
11:10:54 <Saizan> theorbtwo: i mean that you'd have to prove it
11:11:03 <Saizan> imc: yes, it's the same
11:11:05 <TempestAdept> imc: do notation is desugared to (>>=) and d the like
11:11:40 <imc> oh my
11:11:43 <imc> eheh
11:11:58 <imc> i changed my functions signatures to use IO Image... should change them back :P
11:12:03 <theorbtwo> Sounds even worse... the computer proving it for me would be OK, having to prove it myself ... kill me now.
11:13:32 <Fruladox> noob question : I installed packages via Cabal, but I can't manage to load them in ghci
11:14:25 <Saizan> Fruladox: you can't :load a module from an installed package
11:14:33 <Saizan> Fruladox: you can import it though
11:14:44 <Fruladox> for example, I try ... :l Math  ... and I get an error stating that the module does not exist
11:14:50 <imc> :m + Module.Name
11:15:05 <Fruladox> couldn't find module Math
11:15:24 <Fruladox> :m, :l, import, none will find the module Math
11:15:47 <Saizan> what does "ghc-pkg find-module Math" say?
11:15:51 <Fruladox> is there a way to print a list of installed modules?
11:15:54 <Saizan> from the shell
11:16:56 <Fruladox> it prints : C:/Program files/Haskell Platform/2009.2.0.2\package.conf
11:17:25 <Saizan> only that? it means you don't have a module Math then
11:17:51 <Saizan> which package have you installed that you think should have it?
11:17:54 <Zao> Fruladox: What package is this, if it's a hackage one?
11:18:52 <Fruladox> mm... statistics
11:18:59 <Fruladox> ... is one of them
11:19:22 <Saizan> statistics has Statistics.Math
11:19:39 <Saizan> so "import Statistics.Math" will work
11:19:52 <pokoko222> are there any books where people talk about computer science professions? I mean, I have no idea what i would like to do, AI seems cool especially the Prolog reasoning stuff so far to me... but i have no idea what to start to specialize in and pay more attention to
11:19:55 <Fruladox> it worked!
11:21:08 <byorgey> pokoko222: I'm not aware of any such books.
11:21:16 <byorgey> pokoko222: just pay attention to things that seem interesting to you, and keep looking for references to further reading and so on
11:21:35 <Fruladox> I must import the whole name... ok.. thanks Saizan!
11:22:10 <Saizan> np :)
11:22:23 <FunctorSalad> Ghci> take 10000 `fmap` readProcess "cat" ["/dev/urandom"] ""
11:22:23 <FunctorSalad> <interactive>: fd:10: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
11:22:49 <FunctorSalad> I think this should either return binary data or have customizable encoding
11:23:38 <benmachine> 6.12? possibly the package needs updating
11:23:59 <FunctorSalad> AIUI, before 6.12, it used to work in spite of ignoring the encoding issue because the encoding it used to use didn't have illegal bytes
11:24:16 <Saizan> well the rest of the module allows you to set binary or change the encoding
11:24:16 <benmachine> @. pl undo \a -> do { x <- a; hSetBinaryMode x True; return x }
11:24:16 <lambdabot> (ap ((>>) . flip hSetBinaryMode True) return =<<)
11:24:22 <benmachine> @. pl undo \a -> do { x <- a; hSetBinaryMode x True; return x; }
11:24:23 <lambdabot> (ap ((>>) . flip hSetBinaryMode True) return =<<)
11:24:23 <FunctorSalad> benmachine: readProcess is built into ghc I think
11:24:33 <benmachine> oh I suppose that makes sense
11:24:38 <benmachine> try hSetBinaryMode
11:24:38 <FunctorSalad> Saizan: yeah, but apparently readProcess doesn't have hooks
11:24:57 <FunctorSalad> you'd have to createProcess requesting a handle, and then hSetBinaryMode, right
11:25:10 <FunctorSalad> (hooks to modify the handle, I mean)
11:27:09 <Polarina> Is there something similar to `isInfixOf` but tells me where it is an infix of?
11:27:17 <Saizan> yeah, we should probably split a function that takes the result of a call to createProcess and does the reading, out of readProcess
11:27:38 <FunctorSalad> but maybe an impure errors is a bit drastic as a response to illegal multibytes -- for handles in general
11:27:46 <FunctorSalad> *"are a bit"
11:28:01 <Saizan> ?type findIndex
11:28:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
11:28:16 <byorgey> @hoogle Eq a => [a] -> [a] -> Maybe Int
11:28:16 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:28:16 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
11:28:16 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
11:28:33 <byorgey> hm, it exists for ByteStrings but not lists
11:28:43 <Saizan> ?type \a -> msum . findIndex (a `isPrefixOf`) . tails
11:28:44 <lambdabot>     Couldn't match expected type `[m a]'
11:28:44 <lambdabot>            against inferred type `Maybe Int'
11:28:44 <lambdabot>     In the first argument of `(.)', namely `findIndex (a `isPrefixOf`)'
11:28:45 <FunctorSalad> @type findIndices
11:28:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
11:28:54 <Polarina> I have something like  "def" `isInfixOf` "abcdefghijklm"
11:28:57 <Saizan> ?type \a -> msum . map (findIndex (a `isPrefixOf`)) . tails
11:28:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> Maybe Int
11:29:32 <byorgey> that won't give you the right indices anyway
11:29:42 <Saizan> oh, duh.
11:30:22 <benmachine> @type \a -> length . takeWhile (not . (a `isPrefixOf`) . tails
11:30:23 <lambdabot> parse error (possibly incorrect indentation)
11:30:31 <benmachine> @type \a -> length . takeWhile (not . (a `isPrefixOf`)) . tails
11:30:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
11:30:38 <freiksenet> Hello! Is there a built in function for, hm, I think that would be all possible permutations for two lists, so list of all possible pairs of values in two lists. so listpermutations [1,2,3,4], [1,2,3,4] would be [(1,1), (1,2) ..]
11:30:38 <FunctorSalad> ("Char" has lots of unused space already anyway right? Why not have a "read error" pseudo-Char instead of `error'ing out?)
11:30:45 <Zao> FunctorSalad: Yes.
11:30:47 <benmachine> hmm, returns length of the list if it doesn't find it though
11:30:49 <Zao> Err, freiksenet: yes.
11:30:58 <copumpkin> preflex: seen edwardk
11:30:58 <preflex>  edwardk was last seen on #haskell 11 hours, 8 minutes and 26 seconds ago, saying: bbiab
11:30:59 <byorgey> freiksenet: sure, easiest way is to use a list comprehension
11:31:11 <Zao> > [(x,y) | x <- [1..4], y <- "omg"]
11:31:12 <byorgey> > [(x,y) | x <- [1,2,3,4], y <- [7,8,9]]
11:31:13 <lambdabot>   [(1,'o'),(1,'m'),(1,'g'),(2,'o'),(2,'m'),(2,'g'),(3,'o'),(3,'m'),(3,'g'),(4...
11:31:13 <lambdabot>   [(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9),(4,7),(4,8),(4,9)]
11:31:26 <freiksenet> byorgey: uh, good idea, never though of this. :)) lisp background shows itself
11:31:30 <freiksenet> thansk
11:31:32 <Zao> There's probably a cute non-comprehension way too.
11:31:36 <benmachine> > (,) <$> [1,2,3] <*> [4,5,6]
11:31:37 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:31:42 <Zao> ^
11:31:43 <byorgey> yep =)
11:31:51 <benmachine> probably several ways
11:32:04 <byorgey> > liftM2 (,) [1,2,3] [4,5,6]
11:32:05 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:32:12 <byorgey> same thing, really
11:32:13 <benmachine> is there a zipWithM
11:32:26 <FunctorSalad> > ord maxBound
11:32:27 <lambdabot>   1114111
11:32:29 <byorgey> @hoogle zipWithM
11:32:29 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:32:30 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
11:32:30 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
11:32:30 <freiksenet> :) uuh.
11:32:39 <freiksenet> thanks, I'll take a look
11:32:47 <FunctorSalad> > log (ord maxBound :: Double) / log 2
11:32:48 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
11:32:48 <lambdabot>         against inferred ty...
11:32:49 <Zao> (,) requires TupleSections, right?
11:32:49 <benmachine> hmm maybe that is not what I meant
11:32:55 <byorgey> Zao: no
11:32:56 <copumpkin> Zao: not on its own
11:32:57 <FunctorSalad> > log (fromIntegral (ord maxBound) :: Double) / log 2
11:32:58 <lambdabot>   20.087461546321563
11:33:03 <copumpkin> > (,5) 4
11:33:04 <lambdabot>   <no location info>: parse error on input `5'
11:33:04 <byorgey> Zao: TupleSections gives you (,3) or (3,)
11:33:13 <FunctorSalad> omg it wastes more than 11 bytes :o
11:33:14 <copumpkin> you can also use it for bigger tuples
11:33:15 <benmachine> and (,3,)
11:33:15 <FunctorSalad> ;)
11:33:21 <benmachine> and (,,4,5,,,,7,8)
11:33:25 <byorgey> Zao: but (,) has always been the name for the two-tuple constructor
11:33:33 <FunctorSalad> > sizeOf 'a'
11:33:34 <lambdabot>   Not in scope: `sizeOf'
11:34:02 <FunctorSalad> (returns 4 on my box)
11:34:19 <FunctorSalad> so there's plenty of room for errors in Char :)
11:34:20 <benmachine> > bitSize (ord maxBound)
11:34:21 <lambdabot>   64
11:34:34 <benmachine> wait, what
11:34:48 <benmachine> oh
11:34:54 <FunctorSalad> benmachine: hmm that just tells you the size of the default Integral type
11:34:57 <FunctorSalad> @ty ord
11:34:57 <benmachine> bitSize doesn't do what I think it does
11:34:58 <lambdabot> Char -> Int
11:35:01 <FunctorSalad> err, of Int
11:35:24 <mornfall> :t bitSize
11:35:25 <theorbtwo> :t bitSize
11:35:25 <lambdabot> forall a. (Bits a) => a -> Int
11:35:26 <lambdabot> forall a. (Bits a) => a -> Int
11:35:40 <theorbtwo> :t bitSize (42 :: Char)
11:35:41 <lambdabot>     No instance for (Bits Char)
11:35:42 <lambdabot>       arising from a use of `bitSize' at <interactive>:1:0-19
11:35:42 <lambdabot>     Possible fix: add an instance declaration for (Bits Char)
11:35:52 <theorbtwo> ...or not.
11:36:05 <benmachine> 42 :: Char doesn't make sense anyway :P
11:36:08 <TempestAdept> :i Bits
11:36:21 <FunctorSalad> though sizeOf 'a' just tells me the size of the marshalling format, I think
11:36:26 <FunctorSalad> not the internal
11:36:29 <benmachine> @instances Bits
11:36:30 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
11:36:31 <mornfall> FunctorSalad: Indeed.
11:36:31 * theorbtwo slaps his forehead.  This isn't ##C!
11:36:31 <FunctorSalad> but I thought that's 32 bit too
11:36:38 <benmachine> @instances-importing Data.Bits Bits
11:36:39 <lambdabot> Int, Integer
11:37:50 <mornfall> FunctorSalad: Me too. UTF-32 or something.
11:38:27 <byorgey> theorbtwo: hehe
11:38:47 <twink> chr 42?
11:39:00 <FunctorSalad> . o O (it makes sense that `Char` is not an instance of Bits if a Char is supposed to represent a character abstractly)
11:39:05 <Twey> > sizeOf 'a'
11:39:06 <lambdabot>   Not in scope: `sizeOf'
11:39:12 <Twey> Aw,
11:39:19 <theorbtwo> Anyway, if Char is supposed to hold any unicode character, it should be at least 24 bits wide.
11:39:34 <mornfall> theorbtwo: Right, and it doesn't make sense to be unaligned.
11:39:48 <mornfall> theorbtwo: Especially since in String you waste a pointer per character anyway.
11:40:11 <theorbtwo> Yes, which always seems horrible to me, but that's life.
11:40:22 <FunctorSalad> ByteString to the rescue...
11:40:31 <mornfall> theorbtwo: It doesn't matter in most contexts. And where it does, there's ByteString.
11:40:43 <FunctorSalad> but anyway, my point was just that Chars could hold error data, not that they should be more packed ;)
11:40:47 <Twey> theorbtwo: 26
11:40:52 <mornfall> (Which is oftentimes more efficient than char * in C, anyway...)
11:41:10 <Zao> Twelve bytes per code unit in a string is nice.
11:41:10 <FunctorSalad> then programs wouldn't suddenly fatal-error on hGetChar in 6.12
11:41:48 <theorbtwo> Huh.  Actually, 20.
11:42:01 <theorbtwo> > (log 0x10FFFF)/(log 2)
11:42:02 <lambdabot>   20.087461546321563
11:42:14 <theorbtwo> Well, 21, I suppose.  Should ceil, not round.
11:42:46 <Twey> 21, sorry
11:42:47 <Twey> Yes
11:43:00 <Twey> Nice calculation method.  I don't understand it.  :þ
11:43:10 <Twey> > length $ showIntAtBase 2 ("01" !!) 0x10ffff ""
11:43:12 <lambdabot>   21
11:44:24 <theorbtwo> The maximum unicode character number is 0x10FFFF.  In order to hold that, you need the log base 2 of 0x10FFFF.  Log base 2 of N == log base 10 of N divided by the log base 10 of 2.
11:44:40 <theorbtwo> (And I don't know how to do logs in haskell, but guessed that the log function with one argument would work.)
11:44:54 <FunctorSalad> Twey: log x / log y = log_{base y} x
11:45:26 <theorbtwo> Come to think of it, there's an off-by-one error there, since there are 0x11000 distinct values -- 0 counts.  It doesn't matter, it's 21 either way.)
11:45:32 <Zao> "code point"
11:47:03 <imc> hm
11:47:31 <imc> saveJpegFile does not create a file
11:47:35 <imc> :(
11:47:52 <Twey> theorbtwo: Ah, right.  That's it.  :þ  Thanks.
11:47:59 <Twey> FunctorSalad: I knew *that* much at least.  :þ
11:48:26 <FunctorSalad> Twey: sorry misunderstood the issue then
11:48:41 <FunctorSalad> where he got the maximum codepoint from?
11:49:02 <imc> uh.. actually it does
11:49:06 <Zao> Unicode standard?
11:49:14 <imc> but not when i manipulate it.. investigate further
11:49:15 <Zao> There are 17 planes.
11:49:18 <codolio> > text [maxBound]
11:49:19 <lambdabot>   􏿿
11:49:23 <copumpkin> > ord maxBound
11:49:24 <lambdabot>   1114111
11:50:01 <theorbtwo> Er... I know these things off the top of my head, but yeah, unicode spec... somewhere.
11:51:10 <FunctorSalad> > maxBound :: Char
11:51:11 <lambdabot>   '\1114111'
11:51:23 <Zao> http://unicode.org/glossary/#plane
11:51:28 <FunctorSalad> > return maxBound :: String
11:51:29 <lambdabot>   "\1114111"
11:51:33 <Zao> Also in the standard proper, of course.
11:51:34 <FunctorSalad> hmm
11:51:58 <FunctorSalad> Zao: were you replying to me? I was just asking Twey what his question was ;)
11:52:19 <theorbtwo> Hm.  "\nnnnn" is decimal, and unbounded without delimiters?
11:52:25 <theorbtwo> That's very unusual.
11:52:35 <theorbtwo> > "\x{10FFFF}"
11:52:35 <FunctorSalad> > '\12345'
11:52:36 <lambdabot>   <no location info>:
11:52:36 <lambdabot>      lexical error in string/character literal at chara...
11:52:36 <Zao> FunctorSalad: I haven't followed the conversation much, just folding in information where it seems suitable.
11:52:37 <lambdabot>   '\12345'
11:52:44 <FunctorSalad> Zao: :)
11:52:50 <theorbtwo> Oh well.
11:53:13 <FunctorSalad> "\11111111111111111"
11:53:14 <FunctorSalad> > "\11111111111111111"
11:53:15 <lambdabot>   <no location info>:
11:53:16 <lambdabot>      lexical error in string/character literal at chara...
11:53:29 <FunctorSalad> hmm odd, yes
11:58:11 <imc> :28
11:58:15 <imc> ups :/
11:58:17 <imc> irssi is not vim
11:58:39 <MrBlueSky> quick question. What is "=<<"?
11:58:55 <imc> >>= but on the other side (guess) ?
11:59:30 <MrBlueSky> oh, that would make sense
11:59:38 <tensorpudding> it is (>>=) flipped
11:59:59 <MrBlueSky> ok thanks (:
12:00:04 <imc> eheh
12:00:16 <imc> flipped smiley
12:02:15 <McManiaC> how do you kill a process in ghci that doesnt react to ^c ?
12:03:47 <aavogt> ^z, then kill %
12:04:08 <aavogt> maybe kill -9
12:04:20 <Polarina> Is there some function that does prime factorization?
12:04:30 <aavogt> @hackage primes
12:04:31 <lambdabot> http://hackage.haskell.org/package/primes
12:04:56 <Polarina> factorization...
12:05:13 <McManiaC> aavogt: ah cool, that process gets its own job
12:05:17 <aavogt> well when you have primes, it's easier to factorize into them
12:05:56 <Polarina> Something that comes with standard haskell?
12:06:20 <Cale> Polarina: No, but you can write one in just a few lines.
12:06:34 <Cale> Depending on how you'd like to do it.
12:06:40 <Cale> and how fast you need it to be
12:06:40 <Polarina> Cale, I already have one, I was just looking for a way to shorten my code. :)
12:07:10 <twink> Genuine sieves of Eratosthenes with wheels etc. aren't even that involved. I think most of the speedups out there are inlining all the priority queue code.
12:09:56 <Cale> There's an infinite prime sieve by Bird (iirc), which is rather efficient and doesn't involve anything fancier than lists, but it's not quite a oneliner. It's in Melissa O'Neill's paper.
12:11:28 <Cale> @let (x:xs) `minus` (y:ys)  | x < y = x : (xs `minus` (y:ys)  | x == y = xs `minus` ys  | x > y = (x:xs) `minus` ys
12:11:28 <lambdabot>   Parse error: Equals
12:11:41 <Cale> @let (x:xs) `minus` (y:ys)  | x < y = x : (xs `minus` (y:ys))  | x == y = xs `minus` ys  | x > y = (x:xs) `minus` ys
12:11:43 <lambdabot>  Defined.
12:13:09 <Cale> @let unionB = foldr merge [] where merge (x:xs) ys = x : merge' xs ys; merge' (x:xs) (y:ys)  | x < y = x : merge' xs (y:ys)  | x == y = x : merge' xs ys  | x > y = y : merge' (x:xs) ys
12:13:11 <lambdabot>  Defined.
12:14:16 <Cale> > let primes = 2 : ([3..] `minus` composites) where composites = union [map (*p) [p..] | p <- primes] in primes
12:14:17 <lambdabot>   Couldn't match expected type `[t]'
12:14:18 <lambdabot>         against inferred type `[[a]] -> ...
12:14:24 <Cale> > let primes = 2 : ([3..] `minus` composites) where composites = unionB [map (*p) [p..] | p <- primes] in primes
12:14:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:15:09 <Cale> The definition of that merge/unionB is really quite sneaky.
12:17:20 <Cale> But it's not as good as Melissa's version using a priority queue and a wheel.
12:30:36 <Fruladox> noob question again : I installed the package midi
12:30:42 <Fruladox> I want to import it
12:30:59 <Fruladox> must I import every single name?
12:31:19 <Alpounet> check the documentation to see which modules contain the functions you need, etc
12:31:29 <Alpounet> and import these modules
12:31:41 <Fruladox> what is a module?
12:31:48 <Fruladox> is Sound.Midi a module?
12:31:54 <Alpounet> yeah, for example
12:32:03 <Fruladox> why can't I import Sound.Midi
12:32:05 <Fruladox> ?
12:32:10 <Alpounet> you can
12:32:25 <Fruladox> how?
12:32:32 <Alpounet> ho
12:32:33 <Alpounet> actually
12:32:42 <Cale> import Sound.Midi
12:32:43 <Alpounet> Sound.Midi is only compound of submodules
12:32:46 <Cale> oh
12:32:46 <Alpounet> http://hackage.haskell.org/package/midi
12:32:51 <Fruladox> it works not
12:32:57 <Alpounet> see the documentation
12:33:03 <Alpounet> below the general informations
12:33:05 <Cale> Yeah, there is no Sound.Midi
12:33:17 <Cale> Or Sound.MIDI
12:33:34 <Cale> There's only  Sound.MIDI.File, Sound.MIDI.General, etc.
12:33:54 <Fruladox> Sound.Midi.File does not work
12:34:00 <Cale> MIDI, not Midi
12:34:21 <Fruladox> it sucks balls
12:34:26 <Fruladox> thanks
12:34:28 <Cale> http://hackage.haskell.org/package/midi -- in the tree of modules here, the blue links should be importable.
12:35:02 <Cale> Oh, it's a Henning Thielemann monstrosity too. :(
12:35:19 <Alpounet> Cale, uh ?
12:35:32 <Cale> He names all his types T
12:35:55 <Cale> It's obnoxious, because he writes so much good code and then sabotages it.
12:36:30 <Alpounet> has anybody ever told him ?
12:36:44 <Cale> Probably. He seems rather opinionated himself.
12:37:02 <Cale> I don't know where he got this style from, but it makes the Haddock unreadable.
12:37:11 <Alpounet> I guess so, yeah
12:37:15 <Zao> Seems to be depending on a tonne of 0.0.1-grade libraries.
12:40:38 <Cale> He also names all his typeclasses C
12:42:09 * danderson does a happy dance
12:42:21 <danderson> just sent my first patch for a haskell library :)
12:42:58 <michie1> congratulations
12:43:11 * michie1 is still trying to figure out the syntax
12:43:14 <dons> thanks danderson !
12:44:12 <michie1> is there a Haskell newbies channel, by the way?
12:44:18 <lament> this one
12:44:28 <michie1> that's what I feared :)
12:44:29 <danderson> michie1: I never said I understand all the syntax, even less the semantics :)
12:44:51 <danderson> my patch was very pragmatic, just adds instances of Bounded and Enum to IP addresses and IP address ranges
12:44:53 <aavogt> hey dons, bytestring-csv is pretty inaccurate regarding commas within quoted fields. I have a replacement using attoparsec that isn't too much slower...
12:45:00 <danderson> so that you can enumerate subnets and the like
12:45:20 <aavogt> though maybe operating on lazy bytestrings is the reason
12:45:31 <osaunders> michie1: If you ask newbie questions people will respond nicely here.
12:46:18 <sinelaw> michie1, not understanding the zygomorphic monadic transforms on the left kan extensions fully can also be considered newbish here, unfortunately
12:46:19 <lambdabot> sinelaw: You have 1 new message. '/msg lambdabot @messages' to read it.
12:46:43 <sinelaw> michie1, but more seriously, ask away :) i'm one too.
12:47:06 <sinelaw> hey Alpounet
12:47:19 <Alpounet> hey :)
12:47:34 <aavogt> @where hpaste
12:47:35 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
12:47:35 <osaunders> sinelaw: Really? Sheeh. I must be an ultra n00b then.
12:47:56 <sinelaw> osaunders, i'm not even born by that standard :P
12:47:56 <osaunders> *sheesh?
12:48:09 <osaunders> hehhe
12:48:13 <osaunders> Undead?
12:48:20 <sinelaw> mmmmmmmnm
12:48:24 <sinelaw> mama
12:48:46 <sinelaw> Alpounet, so what are you making?
12:49:33 <aavogt> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23284#a23284
12:50:17 <dons> aavogt: atto-p version of bytestring-csv?
12:50:35 <dons> good work!
12:50:55 <dons> 2.65 -> 2.77 is great.
12:51:13 <dons> 3.9 for quote matching. great. maybe compare against the regular String csv package...
12:51:26 <bos> moin
12:51:27 <Alpounet> sinelaw, couldn't find time to work on it today, finally, but I will. It's about broadcasting a cam stream
12:51:38 <dons> hyea bos.
12:51:42 <bos> dons: submitting anything to ICFP / haskell symposium / CUFP this year?
12:51:59 <dons> likely for the HW, yeah.
12:52:14 <dons> on panel for CUFP, so looking for speakers.
12:52:45 <bos> ah
12:52:50 <sinelaw> Alpounet, oh nice. i thought of a possible optimization for that if you're broadcasting a person speaking
12:52:53 <dons> want to turn the adaptive containers stuff into a paper.
12:53:10 <sinelaw> Alpounet, using opencv to do face detection and then sending only the area in the image with the face
12:53:33 <Alpounet> sinelaw, could be nice if written efficiently
12:54:00 <dons> bos: when's the SF hackathon?
12:54:16 <bos> dons: need to finalise a date, prob. first weekend in may.
12:54:38 <dons> k.
12:54:42 <dons> i'll come down.
12:54:50 <Alpounet> sinelaw, but I have seen you modified a name ... ?
12:54:55 <Alpounet> cvCaptureFrame iirc
12:55:47 <bos> sweet.
12:56:07 <aavogt> dons: I'm not so sure about my NFData instances though: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23284#a23285
12:57:32 <olsner> you probably want to use rnf again for the lazy-bytestring instance, since L.unpack gives a list
12:58:03 <olsner> or use the function that gives the list of bytestrings instead, to avoid having to convert it to a list of chars/word8
12:58:27 <dons> aavogt: wtf? 64 instance NFData L.ByteString where
12:58:28 <dons> 65     rnf xs = L.unpack xs `seq` ()
12:58:39 <dons> aavogt: so you want  to force the lazy bytestring?
12:58:51 <dons> changing the representation will kill performance :)
12:59:05 <aavogt> well otherwise the parser doesn't necessarily run...
12:59:06 <dons> just ask for the length
12:59:17 <aavogt> ok, I'll try again
12:59:21 <dons> rnf xs = length xs `seq` ()
12:59:45 <dons> i should add a rule "unpack x = trace "Don't use unpack" (unpack xS0
13:00:04 <dons> the strict bytestring instance is correct.
13:00:20 <dons> that's just for benchmarking, right?
13:00:34 <dons> oh, L.pack $ S.unpack bs
13:00:38 <dons> looks sus'.
13:00:42 <dons> you want to convert?
13:00:48 <dons> L.singleton bs
13:01:04 <dons> hmm. no. L.fromChunks [bs]
13:01:32 <aavogt> well that's run outside of the benchmarking
13:02:26 <aavogt> ok, forcing the lazy bytestring only to L.length atto2: 2.566253 ms, alex:  2.639328 ms
13:02:55 <dons> sweet
13:03:08 <dons> i'll happyily accept patches to replace the impl of bytestring-csv
13:03:21 <luite> does anyone here have haskell code for gibbs sampling or other markov chain monte carlo methods?
13:03:24 <aavogt> looks like an insignificant difference considering the standard deviations
13:03:31 <dons> great work
13:03:40 <dons> luite: prob. some monte carlo stuff on hakcage
13:05:50 <sinelaw> Alpounet, what?
13:05:54 <sinelaw> which name
13:06:00 <luite> there is a monte-carlo monad, perhaps I could build on that, but I couldn't find anything for markov chain methods
13:06:22 <Alpounet> sinelaw, cvQueryFrame
13:06:26 <burp> http://hackage.haskell.org/package/markov-chain
13:06:32 <burp> isn't that good?
13:06:38 <Alpounet> oh no
13:06:42 <Alpounet> createCameraCapture
13:06:51 <burp> um seems in very early development, sorry
13:07:42 <luite> burp: probably not very useful for sampling, usually the state space is too large to fit in memory
13:08:07 <luite> (which is usually why you'd use sampling in the first place)
13:10:16 <luite> burp: it's often used to sample from complex distributions, for example combinatorial objects where you can't count them effectively, or statistical physics (the Ising model is a well-known example)
13:10:45 <burp> I used the monte-carlo package for some metroplis monte-carlo simulation
13:10:50 <luite> ah
13:10:51 <sinelaw> Alpounet, oh yeah. my bad. i added a ForeignPtr interface for that
13:11:01 <sinelaw> but accidentally re-named the regular function
13:11:18 <luite> metropolis algorithm is more general than gibbs sampling
13:11:26 <Alpounet> sinelaw, what's the new name ?
13:11:28 <sinelaw> Alpounet, the idea is to use: createCameraCaptureF :: Integral a => a -> IO (Maybe (ForeignPtr CvCapture))
13:11:43 <sinelaw> instead of the regular "low-level" interface
13:11:46 <Alpounet> ok
13:11:55 <luite> burp: what are your experiences with it? is it fast?
13:12:02 <sinelaw> Alpounet, see the test, function main'
13:12:15 <burp> hm can't say.. I have no direct comparison
13:12:53 <burp> but it's nice to use ;)
13:12:53 <luite> I've built something earlier, but the random number generation was a huge bottleneck
13:13:23 <luite> vector-random could help there, probably
13:13:52 <burp> monte-carlo seems to use gsl-random, so it's probably fast
13:14:54 <burp> hm, well mersenne twister is itself not the fastest.. but it's probably faster than using some native haskell generator
13:15:34 <Alpounet> sinelaw, thanks
13:16:57 <luite> mersenne twister is probably fast enough
13:16:57 <sinelaw> no :)
13:17:39 <sinelaw> ....problem :D
13:19:14 <luite> burp: monte-carlo seems to do a lot of unsafePerformIO to avoid copying the RNG state, so it might be fast :)
13:19:30 <Cale> It bothers me that the other random generators don't implement the RandomGen interface.
13:20:09 <harlekin> @pl (\ev -> f ev g)
13:20:09 <lambdabot> flip f g
13:20:43 <chrisdone> I'm sanitising inputs for try haskell's evaluation of top-level declrs
13:20:44 <chrisdone> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23286#a23286
13:20:52 <chrisdone> are any of these that I've allowed actually dangerous?
13:21:41 <chrisdone> it's supposed to just allow func/value definitions, type sigs and typedefs. but I recall certain types can crash ghc but I'm not sure to what effect
13:22:23 <Cale> Shouldn't be... except if Typeable is in scope, you might not want to allow instances of that. I'm not sure if you could really do damage with it... but I wouldn't want to find out.
13:22:50 <chrisdone> righto, I won't import Typeable (it's not imported right now anyway)
13:22:58 <Cale> You can write what is effectively unsafeCoerce using bad instance(s) of Typeable.
13:23:03 <chrisdone> sure
13:23:06 * aavogt wonders if http://hackage.haskell.org/trac/ghc/ticket/1496 could make anything interesting happen
13:23:17 <badkins> I'm trying to build cgi-3001.1.7.2, when I run "runhaskell Setup build", I receive an error: Network/CGI/Monad.hs:30:39:
13:23:17 <badkins>     Module `Control.Exception' does not export `SomeException'
13:23:22 <badkins> any ideas?
13:23:53 <aavogt> badkins: you should have base >= 4, or ghc-6.10 or newer
13:23:54 <chrisdone> badkins: that sounds like your ghc/prelude version is old, I think? what version is your ghc?
13:24:07 <badkins> I'll check...
13:24:18 <badkins> 6.8.3
13:24:20 <aavogt> or the package mis-specified dependencies
13:24:38 <badkins> aavogt: thanks, I'll upgrade ghc and try again
13:24:52 <Cale> chrisdone:   newtype Rec a = In { out :: Rec a -> a }; y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x))); main = print $ y (\f n -> if n == 0 then 1 else n * f (n-1)) 10
13:25:11 <aavogt> well it's a packaging bug such that it failed at that point
13:25:21 <Cale> chrisdone: Compiling that (not interpreting it with the bytecode interpreter) may result in an infinite loop in the inliner.
13:26:08 <aavogt> though ghc-6.8 may be old enough that it isn't worth supporting anymore
13:26:23 <Cale> But if you have a normal sort of timeout for compilation, that shouldn't be a problem.
13:26:58 <Alpounet> sinelaw, how can I get back to normal image display, instead of border detection mode ?
13:27:07 <chrisdone> Cale: I'm just using Haskell.Language.Interpreter. I'll test that out
13:27:28 <Cale> chrisdone: It should be fine unless you go out of your way to compile things then.
13:27:57 <chrisdone> excellent =)
13:28:21 <chrisdone> technically, I suppose, I could allow imports with a whitelist
13:29:12 <aavogt> unless there are conflicting names in those modules, there should be no reason not to have them in scope all the time
13:29:19 * hackagebot highlighting-kate 0.2.6.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.6.1 (JohnMacFarlane)
13:29:54 <chrisdone> aavogt: good point
13:30:13 <chrisdone> aavogt: I was more thinking for teaching how to import modules
13:30:37 <chrisdone> thanks chaps I'll see what I can cook up
13:31:08 <aavogt> this looks like stuff ghci should do by default (rather than having some hacks in .ghci)
13:35:00 <badkins> I think I remember why I have an older ghc:
13:35:03 <badkins> "On Mac OS X 10.5, ghc 6.10.4 requires Xcode 3.1 but you have Xcode 3.0."
13:35:04 <badkins> argh :(
13:40:05 <pokoko222> haskellers read sci fi?
13:40:15 <theorbtwo> pokoko222: This surprises you?
13:40:28 <pokoko222> no i ask for book recomendations
13:41:10 <theorbtwo> Well, recently, Star Trek: Deep Space Nine: The Neverending Sacrifice simply blew me away.
13:42:02 * Cale just finished Ender's Game and Ender in Exile, both of which were excellent.
13:42:42 <jao> pokoko222: philip k dick, neal stephenson, greory benford, greg egan
13:42:46 <Cale> If you haven't read the Dune series (the ones by Frank, not the mediocre fanfiction by his son), then I would recommend that.
13:43:10 <pokoko222> i have done Dunes and i wondered why people love it so much
13:43:45 <pokoko222> thanks for the other both will order them now
13:44:50 * theorbtwo has been avoiding buying Ender in Exile because of some extremely bigited things Orson Scott Card said around the time of it's publishing.
13:45:27 * jao found ender in exile pretty bad
13:46:34 * twink doesn't read scifi
13:47:41 <theorbtwo> I've loved most of the ender serieses.
13:48:51 <theorbtwo> (I count two seperate series.)
13:49:54 <b0fh_ua> Hi there. I want to define module Storage and module Storage.Maildir. Storage should declare some basic functions, working with Mail type, and Storage.Maildir should "implement" them. How should I do that?
13:50:32 <Cale> b0fh_ua: So, you're defining a general typeclass?
13:50:41 <Cale> b0fh_ua: I'm not sure what you're after
13:51:03 <ivanm> b0fh_ua: have Storage.Maildir import Storage ?
13:51:07 <b0fh_ua> well, ll what I want - just define some sort of "interface"
13:51:12 <Cale> b0fh_ua: Do you just want Storage to re-export the functions from Storage.Maildir?
13:51:13 <chrisdone> Cale: I don't think I can achieve ghci-like binding because the haskell interpreter library doesn't seem to support it. I could accumulatively put bindings in a file, but I'd have to handle conflicts. I guess this is why ghci doesn't let you define new types, because it's a pain and confusing. I might just go full on DrScheme and just allow bindings in a textarea
13:51:17 <b0fh_ua> and then provide some implementations
13:51:20 <ivanm> or else actually define them in an internal module with Storage just re-exporting them all
13:51:41 <b0fh_ua> ivanm: well, I'm on designing stage now :)
13:52:00 <Cale> chrisdone: Yeah, I sort of wish that we had a DrScheme-like environment for Haskell.
13:52:15 <b0fh_ua> so I just trying to get some idea of how to declare some abstract functions and then provide implementations for them
13:52:41 <ivanm> "abstract functions"?  this isn't Java! :p
13:52:50 <b0fh_ua> ivanm: I know :)
13:53:12 <Cale> b0fh_ua: Maybe just write the typesignatures for now, and write  foo = error "foo: stub"  or some such
13:53:18 <b0fh_ua> I just trying to learn how should I do something like I would do in java
13:53:19 <Cale> Is that the sort of thing you mean?
13:53:39 <ivanm> the only real way of having abstract function definitions in haskell is a type class
13:53:44 <Cale> Basically, you don't do anything the way that you'd do it in Java ;)
13:53:46 <b0fh_ua> Cale: not really, I want to declare Storage and provide Storage.Maildir and Storge.Mailbox for example
13:53:52 <ivanm> but if you're only going to have one implementation, there's no point in defining such a class
13:54:00 <ivanm> oh, in that case a typeclass would work
13:54:12 <Cale> b0fh_ua: Do you know about typeclasses?
13:54:20 <b0fh_ua> so I can use functions as declared in Storage, but depending of what I will import - they will work either with maildirs of mailboxes
13:54:47 <b0fh_ua> Cale: yup
13:54:51 <Cale> For that you would just have multiple modules which export the same functions and values.
13:55:30 <Cale> Typeclasses are if you want polymorphism over the potential implementations.
13:55:38 <b0fh_ua> Cale: okay, so I define type Email and provide class Storage in Storage.hs, and then provide instances in Storage/Maildir.hs and Storage/Mailbox.hs ?
13:56:15 <Cale> You *could* do that, sure.
13:56:25 <Cale> I'm not sure what the typeclass will be for in this instance though.
13:56:30 <b0fh_ua> okay, is it *correct* way?
13:56:41 <Cale> Are you sure that you don't just want to write a couple of functions for parsing and writing those filetypes?
13:56:54 <Cale> They don't even have to be named the same thing.
13:57:48 <b0fh_ua> Cale: in general I want to maintain single set of functions for working with mailbox and maildir
13:57:59 <b0fh_ua> of course I could create several different functions
13:58:16 <Cale> What set of functions?
13:58:21 <Cale> What are their type signatures?
13:58:23 <b0fh_ua> but my background in java interfaces and implementations beats my head about this approach :)
13:59:17 <Cale> I'm just not sure I can see a case where such polymorphism will be useful.
13:59:30 <Botje> b0fh_ua: refactoring is a _LOT_ easier in haskell than in java. do it as you go. also, hi!
13:59:34 <esr> Hello, I'm looking for a Haskell tutorial that I was reading but seem to have lost th link to.  A distinguishing feature is that it has per-paragraph links where you can leave comments on the text.  Does that uniquely identify it?
13:59:40 <b0fh_ua> Cale: I still not sure about signatures, but if think about Email type, I would say that I have to : listEmails :: Storage -> [Email], addEmail :: Storage -> Email -> Storage, removeEmail :: Storage -> Email -> Storage
13:59:44 <Botje> @where rwh
13:59:44 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:59:46 <Botje> esr: ^^
13:59:56 <systemfault> Botje: How can it be?
14:00:17 <Botje> systemfault: referential transparency.
14:00:24 <b0fh_ua> and construct Storage of course
14:00:28 <systemfault> Botje: I mean.. haskell doesn't have as much refactoring tools even thought the language itself helps
14:00:29 <esr> Botje: Thanks, that's exactly it.
14:00:57 <b0fh_ua> so with simply replacing imported modules I would be able to change just background of storage for my emails
14:01:26 <Cale> No IO involved in those?
14:01:26 <Botje> b0fh_ua: write (and test) it with one type of storage first. generalize afterwards
14:01:38 <Botje> systemfault: it's just .. easier :)
14:01:43 <b0fh_ua> Let's assume the signatures will be : openStorage :: String -> Storage, listEmails :: Storage -> [Email], addEmail :: Storage -> Email -> Storage, removeEmail :: Storage -> Email -> Storage
14:02:08 <Botje> often it's just a case of changing function pipelines
14:02:13 <esr> I'm an old LISP-head now trying to wrap same around Haskell.  The functional POV is easy and the syntax no big deal, but the homogenous-list restriction is kind of annoying.
14:02:14 <b0fh_ua> Cale: good point, IO should be definitely there
14:02:42 <Cale> esr: It's surprisingly not a problem in practice.
14:02:51 <Botje> esr: the trivial workaround increases safety. so yay :)
14:02:59 <Cale> esr: If you want a tree datastructure, you define a different datatype, typically.
14:03:59 <b0fh_ua> Botje: okay, that's may be useful, but ... I want to write things in top-down approach :)
14:04:03 <mrd> esr: Ultimately you have to deal with a "heterogeneous" list by checking type tags in lisp.  In haskell that's enforced through datatype declarations and pattern matching.
14:04:13 <b0fh_ua> define some interfaces and provide some implementations :)
14:04:19 <Cale> esr: If you just want a list of values which are related by a common interface of functions, typically you can instead decide on what it is that those values have in common, and preapply the values to the interface of common functions.
14:04:23 <Botje> b0fh_ua: that's not a top down approach
14:04:29 <Botje> that's a java approach.
14:04:31 <Cale> (which you might define as a record type)
14:04:34 <mpiechotka> Hello. After upgrading parsec 3.0.1 -> 3.1.0. Cabal complains 'package network-2.2.1.7 is broken due to missing package parsec-3.0.1'. network rebuilds ok but it does not remove the warning. Any ideas?
14:04:36 <Botje> write things as simple as you can first
14:04:42 <Botje> and only generalize once you get it working
14:04:55 <Cale> *Or* if there are just a few cases, you can define a new datatype with those cases.
14:05:01 <b0fh_ua> Botje: oh damn
14:05:25 <esr> Thatt's not my issue.  I run a project called GPSD, I'm thinking about writing a Haskell client binding for my JSON-emitting service daemon, and handling the nartural type jetorenaity in a JSON object looks like it's going to be a PIA.  Even with the JSON library.  Oh well, I'll cope.
14:05:35 <Botje> b0fh_ua: i have written two compilers in haskell and haven't needed to define my own typeclass :)
14:05:37 <esr> s/PIA/PITA/
14:05:41 <esr> :-)
14:05:56 <Botje> esr: you've read the JSON part of RWH, then?
14:06:04 <esr> s/jetorenaity/heterogeneity/
14:06:06 <mrd> esr: It shouldn't be a problem.  There's a natural recursive datatype declaration that goes with that kind of thing.
14:06:23 <esr> I hate my typos...and yesI have read the JSON stuff.
14:06:30 <Cale> esr: There are some JSON libraries on Hackage... they tend to solve the problem by enumerating the possible types representable in JSON in a single algebraic datatype.
14:06:41 <esr> Yeah, I got that.
14:07:33 <esr> So far I think the single thing that messes with my head most delightfully is recursive type definitions.  Wow.
14:07:36 <Cale> You usually don't want *complete* heterogeneity, since if you have no idea what type something will be, there are essentially no operations you could safely perform on it.
14:09:14 <Botje> esr: it's no different from struct linkedlist { int value; struct linkedlist * next; } in C :)
14:09:25 <mpiechotka> Oh. Forget. I forgot about system libraries ;)
14:10:02 <Cale> http://cale.yi.org/index.php/A_look_at_OO_from_Haskell -- here's something I wrote about the other approach to solving this sort of problem
14:10:31 <Cale> (basically, work out what operations all your values have in common, and define your values to *be* those operations)
14:10:52 <theorbtwo> Hm.  gpsd uses json these days?  Maybe it's time for a second look at it.
14:11:16 <gwern> :info Data
14:11:53 <dons> aavogt: time to write bytestring-json
14:11:59 <dons> port  the parsec json parser over
14:13:01 <Cale> esr: You can use the parameters to functions as what would be the 'private' fields in an OO setting, and the result of those functions will be a record consisting of the 'public' interface to the data.
14:13:15 <esr> theorbtwo: Yeah, I resedesigned the request-response protocol, it's JSON application now.  The practical patoff is that it handles AIS (marine Automatic Identification System transponders) now.
14:15:40 <esr> I'm having an easier time entering the language than most would (I think) because I'm already OK with thinking in a pure-functional mode.  But there are still barriers.  I just got it about monads a couple hours ago; that took work.
14:20:22 <MadHatterDude> @hoogle first
14:20:23 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
14:20:23 <lambdabot> Data.Monoid newtype First a
14:20:23 <lambdabot> Data.Monoid First :: Maybe a -> First a
14:20:53 <Cale> esr: Yeah, I think of monads as just a particular style of combinator library which it's useful to generalise over, since we can then write some functions (all those in Control.Monad for example) which work in all those combinator libraries which fit that shape.
14:21:23 <Cale> Same goes for Applicative, Arrow, Comonad, etc.
14:21:29 <MadHatterDude> @pl \f (x, y) -> (f x, y)
14:21:29 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
14:21:47 <esr> There's some connection with closures that I don't completely understand yet.  But I will.
14:21:50 <MadHatterDude> @pl \f (x, y) -> (x,f y)
14:21:51 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
14:22:22 <MadHatterDude> @hoogle ap
14:22:22 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:22:22 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
14:22:22 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
14:23:00 <Cale> MadHatterDude: \f (x,y) -> (x, f y)  is just fmap, if you have the instance imported
14:23:17 <MadHatterDude> Cale: Ok
14:23:25 <Cale> (also, second from the Arrow library :)
14:23:43 <Botje> i'd recognize it as second a lot faster :P
14:24:07 <Botje> @pl \f x -> (x, f x)
14:24:07 <lambdabot> ap (,)
14:24:11 <Botje> that's another nice one
14:24:11 <esr> Doesn't hurt that I was a mathematician once.  Haskell was *so obviously* designed by logicians.  Dang.  I'm having fun...hadn't really thought about category theory for a couple decades before this.
14:24:58 <copumpkin> it's a pretty awesome language (and gateway into fascinating areas of math and logic)
14:25:33 <MadHatterDude> I think I'll write an anecdote about Functors/Applicatives/Monads/Comonads featuring slaughterhouse equipment...
14:26:16 <esr> theorbtwo: Of course if I write this GPSD binding the main object is going to look like a lazy-evaluated list of time-position-velocity reports.
14:26:37 <theorbtwo> Sounds fairly nice.
14:27:21 <theorbtwo> OTOH, it also seems like it'd be easy to get laggy that way.
14:27:27 <twink> I'm a big fan of it.
14:28:39 <twink> Monad transformer stacks are really big.
14:30:10 <dons> esr: well, comp sci people with a bent for theory designed it.
14:30:24 <dons> a mix of theory guys, and compiler guys that like listening to theory guys
14:30:41 <zygoloid> esr: the downside of such an interface is that you typically can't say 'is there information for this time yet?' without possibly blocking
14:30:54 * esr is in the second category, he guesses
14:30:57 <Cale> I've actually come to not like monad transformers all that much. They have their place, but I feel like they're way overused. Often a traditional direct style would work out better.
14:31:17 <ddarius> esr: Are you aware of the Curry-Howard correspondence?
14:31:28 <esr> ddarius: No.  Do tell.
14:31:35 <copumpkin> oh that's the best part!
14:31:51 <dobblego> C-H is quite awesome
14:31:51 <zygoloid> aka the propositions-as-types principle
14:32:29 <esr> Ah, equating each type with is set of semantic constraint equations?
14:32:46 <copumpkin> a type is a logical statement
14:32:50 <CBro2007> Hi All, I have a background in programming languages like C/C++, Java and some scripting using Perl. I wanted to learn a functional programming language for AI applications and I am wondering how Haskell works out for AI? How does it compare to Common LISP for example?
14:32:51 <ddarius> esr: The summary is types correspond to propositions, programs correspond to proofs, and program rewrites correspond to proof transformations in a pretty strong way.
14:32:51 <copumpkin> a function of that type is a proof of it
14:33:13 <esr> ddarius: This seems intuitively pretty clear, actually.
14:33:22 <ddarius> esr: Basically proof theory and programming are the same thing.
14:33:29 <CBro2007> the thing is that at my university the prof is a LISP fan. But I am wondering if Haskell offers me with newer features that make the language free of "side effects"?
14:33:36 <ddarius> esr: There are a lot of good resources online about this.
14:33:43 <Cale> Basically, the heart of the connection is that in logic, if you want to prove that A -> B, you can start by assuming A, and constructing a proof of B, and in lambda calculus, if you want to construct a value of type A -> B, you write a lambda with a formal parameter x of type A, and you write a term with type B as the body of the lambda.
14:33:58 <esr> Cale: Yes.
14:34:08 <copumpkin> agda's a nice way to get a good feel for it, while still staying in a haskell-like language
14:34:10 <esr> Not hard to see where that's going.
14:34:14 <CBro2007> can someone help convince me to learn Haskell?
14:34:16 <CBro2007> :)
14:34:28 <copumpkin> CBro2007: it's fucking awesome
14:34:34 <Botje> CBro2007: you can never know too many languages.
14:34:39 <CBro2007> copumpkin: ok that does it then
14:34:39 <copumpkin> CBro2007: if you don't learn it I'll track you down and break your legs
14:34:43 <CBro2007> :)
14:34:49 <mpiechotka> How to force a package to use parsec 3.1 even if it has < 3? I tried to edit by hand (like hsemail, SMTPClient, hslogger & happstack-util) but when I tried to install happstack-data it states it needs happstack-util using parsec <3 as 'cannot configure happstack-util-0.4.1. It requires parsec <3' (as on hackage it requires). Any help?
14:34:54 <Cale> And in logic, if you have a proof of (A -> B) and a proof of A, then you can put them together to get a proof of B. In lambda calculus, if you have a term f of type A -> B, and a term x of type A, then you have f x of type B.
14:34:56 <esr> ILike a statically-typed Lisp with extra added awesome :-)
14:35:00 <CBro2007> copumpkin: you might be surprised who you mess with mate :)
14:35:07 <theorbtwo> CBro2007: What's your current language of choice?
14:35:30 <Cale> So, typed lambda calculus and its various extensions can be viewed as proof systems for various implicational logics.
14:35:31 <CBro2007> theorbtwo: well at the moment I love C .. but really it depends on what the task is
14:35:31 * esr is a Python fan
14:35:36 <theorbtwo> Pretty much no matter what it is, you will either find one that suits you better, or you will come back to your current language of choice with new ideas of how to make it better.
14:35:51 <CBro2007> when I want something quick and dirty then I prefer Perl
14:35:53 <Cale> In fact, this is how the lambda calculus got started.
14:36:04 <byorgey> mpiechotka: I don't think it's really possible, besides downloading a tarball of the package in question and editing its .cabal file
14:36:19 <mpiechotka> byorgey: That's what I tried
14:36:29 <mpiechotka> byorgey: It seems to not be so easy
14:36:33 <Cale> It was originally intended as a proof system, but the untyped lambda calculus has the (unfortunate?) property of giving rise to an inconsistent logic.
14:36:35 * theorbtwo is mostly a perl guy, and does a little C when he needs something low-level.
14:36:40 <CBro2007> theorbtwo: but I understand traversing trees and graphs etc can be quite painful to implement in C
14:36:56 <byorgey> mpiechotka: and you installed happstack-util from the downloaded, edited tarball?
14:36:58 <esr> Oh yes.  Quite painful.
14:37:03 <mpiechotka> byorgey: Yes
14:37:13 <esr> The language doesn't support them naturally at all.
14:37:13 <zetter> waddup
14:37:16 <byorgey> hmm, that ought to work, I don't know
14:37:20 <CBro2007> yeah I want to understand functional programming.. so I will be doing a course in it soon.. but I think they use "ML" there!
14:37:40 <Botje> ml is nice
14:37:41 <CBro2007> just tossing up between Haskell and Common Lisp
14:37:49 <Zao> CBro2007: It could be worse than ML :)
14:37:51 <CBro2007> is lisp worth reading?
14:38:02 <Zao> ML is like a strict Haskell with permuted syntax.
14:38:05 <CBro2007> Zao: what could be worse than ML?
14:38:14 <Zao> CBro2007: Lisp. *hides*
14:38:14 <theorbtwo> C doesn't do a good job at letting you have a layer that handles items without thinking about the type of each one.
14:38:24 <mpiechotka> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23288#a23288
14:38:29 <theorbtwo> Perl doesn't do a good job of keeping you from making errors.
14:38:30 <CBro2007> yeah true
14:38:32 <gwern> theorbtwo: but the POWER!
14:38:40 <theorbtwo> Haskell is, in that way, a nice middle ground.
14:38:44 <gwern> think of the power of being able to pierce abstractions!
14:38:47 <CBro2007> with C you really need to know the types and what sorts of memory you setting up etc
14:38:56 <damd> haskell is silly, c++ is so much faster
14:38:58 <esr> CBro2007: My opinion as a Haskell newbie is that you'd be well advised to do some experimenting with pure-functional programming in LISP, then come bacvk to Haskall.  Pure LISP is a bit more accessible, good prep for this language.
14:39:07 <CBro2007> is haskell slow?
14:39:17 <Cale> I found Common Lisp to be surprisingly painful to program in using a functional style though. Scheme is far nicer.
14:39:21 <Cale> CBro2007: no.
14:39:28 <theorbtwo> Execution speed is almost always overrated.
14:39:31 <esr> Cale: Agreed about Scheme.
14:39:33 <Zao> Properly written Haskell is blazing fast.
14:39:37 <ben> At the rate of Haskell's performance has been improving, we will beat C within a few years
14:39:42 * ddarius would definitely recommend Scheme over Common Lisp in most scenarios.
14:39:43 <aavogt> only implementations can be slow... there are slow haskell interpreters
14:39:47 <byorgey> mpiechotka: it looks like it is trying very hard to select parsec-2.1.0.1
14:39:50 <Cale> CBro2007: Not to mention that Haskell is a language and not a language implementation, so Haskell itself isn't slow or fast.
14:39:54 <mpiechotka> byorgey: If I add parsec >= 3.1 to happstack-data: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23289#a23289
14:39:55 <Zao> ben: Haskell women will produce children in eight months reliably soon.
14:40:02 <esr> :-)
14:40:05 <CBro2007> I am not too keen on learning emacs first and then learning common lisp... looks crazy to me
14:40:10 <Cale> But GHC is an implementation of Haskell with reasonably good performance.
14:40:13 <CBro2007> so I am wondering if ML and Haskell are the way to go
14:40:15 <CBro2007> ?
14:40:27 <theorbtwo> CBro2007: You don't need to learn emacs to learn common lisp.
14:40:33 <gwern> ben: I think you mean, 'at this rate, soon dons will be able to beat C in a few years, and the rest of us python' :)
14:40:34 <byorgey> mpiechotka: try giving the command-line option --constraint='parsec >3.0'
14:40:46 <CBro2007> theorbtwo: yeah but all LISPERS love that shit
14:40:53 <medfly> CBro2007, isn't it supposed to be not so bad to learn a language similar to what you know (lisp dialect to another lisp dialect) ?
14:40:54 <CBro2007> and refuse to code in any other editor :)
14:40:55 <esr> It's true.
14:41:01 <theorbtwo> Emacs' built-in langauge is a lisp, but there are plenty of others available.  Better ones.  (While it is a lisp, it's not a common lisp.)
14:41:01 <Cale> CBro2007: Obviously I'm biased, but I think that Haskell is a great place to dive in. :)
14:41:03 <medfly> CBro2007, oh... learn how to use emacs?
14:41:22 <CBro2007> so would haskell be a good first functional language?
14:41:23 <mpiechotka> byorgey: The same as in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23289#a23289
14:41:27 <Cale> CBro2007: I think so, yes.
14:41:28 * ddarius has programmed in Common Lisp and Scheme and has never used emacs.
14:41:35 <increpare> mm anyone know where Data.Array.Diff has gone to?
14:41:42 <theorbtwo> CBro2007: You might want to play around a bit with perl's functional features as well.
14:41:47 <medfly> @hoogle DiffArray
14:41:48 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
14:41:48 <lambdabot> Data.Array.Diff data IOToDiffArray a i e
14:41:48 <lambdabot> Data.Array.Diff newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
14:41:54 <theorbtwo> If you aren't comfortable with code references, you should possibly start there.
14:41:58 <byorgey> mpiechotka: what command did you run to generate that output?
14:41:59 <gwern> esr: you know, if you aren't careful using that nick, the real esr will get mad and get his guns
14:41:59 <esr> Learning Emacs is a good idea for other reasons.  Obligatrory statement of bias: I wrote somer significant pieces of rthe Emacs LISP libs.
14:42:01 <McManiaC> 23:38         esr Cale: Agreed about Scheme.
14:42:08 * theorbtwo chuckles.
14:42:13 <Cale> CBro2007: If you have the imperative mindset ingrained in you already, you might find it challenging to unlearn everything all at once, but it'll be fun.
14:42:16 <mauke> gwern: wait, that's not the real esr?
14:42:25 <McManiaC> I only learned haskell because we got teached scheme at our university :)
14:42:30 <medfly> mauke, are you the real mauke?
14:42:35 <mauke> medfly: yes!
14:42:35 <medfly> now we have to check everyone!
14:42:36 <CBro2007> Cale: Yeah I know .. but thats why I want this new programming paradigm
14:42:38 * esr wasn't unreal last time he checked
14:42:43 <gwern> mauke: if it isn't, I've given him good advice; if it is, then I may've made him laugh. either way...
14:42:45 <zygoloid> CBro2007:  Haskell is probably more of a drastic change than ML is, due to pervasive laziness
14:42:53 <Cale> CBro2007: Haskell is probably the purest choice of functional language that you could choose while still being practical for everyday programming.
14:43:12 <ben> esr: maybe it suffices to consider yourself complex
14:43:13 <CBro2007> yeah in the end how many companies program in LISP?
14:43:15 <increpare> medfly: mmm...alas that is little help to me :/
14:43:24 <increpare> (did make me chuckle though)
14:43:25 <medfly> increpare, yes, sorry
14:43:25 <Cale> The other choices will make it easier to get away with styles that are closer to imperative.
14:43:32 <mpiechotka> byorgey: cabal install --dry-run --constraint='parsec >=3.0' --verbose in /tmp/happstack-data-0.4.1 but cabal install --dry-run --constraint='parsec >=3.0' --verbose happstack-data have the same problems
14:43:32 <byorgey> CBro2007: plus, lisp doesn't have such a friendly IRC channel to help you while you are learning =)
14:43:40 <McManiaC> 23:39        Cale CBro2007: Not to mention that Haskell is a language and not a language implementation, so Haskell itself isn't slow or fast.
14:43:46 <gwern> mauke: and I don't think anything I've read by esr was anywhere near haskell territory; the closest I ever saw him got was common/emacs lisp, so my suspicion isn't totally baseless
14:43:52 <theorbtwo> I'm not sure saying that it's "purest choice of functional language that you could choose while still being practical for everyday programming" is all that great.
14:43:58 <McManiaC> Cale: you could take the speed to express something in that language… therefor haskell would be super fast :>
14:44:01 <gwern> McManiaC: lies! who seriously uses haskell which isn't GHC Haskell?
14:44:02 <esr> gwern: One of the guns is about a foot behind my left shoulder :-)
14:44:12 <theorbtwo> "It's the most deadly form of poision you can take and still wake up"
14:44:15 <medfly> CBro2007, I actually heard of this one company that did program in lisp but kept it a secret because it was their ADVANTAGE! over other companies
14:44:17 <Cale> theorbtwo: I just mean that there are things like Agda and Epigram.
14:44:18 <gwern> esr: ah. so it's too late for you then. oh well
14:44:18 <CBro2007> so whats a good place to start learning haskell?
14:44:24 <medfly> CBro2007, you know paul graham? so it was in one of his articles
14:44:27 <CBro2007> A good book or resource you recmmend?
14:44:32 <byorgey> @where lyah
14:44:32 <lambdabot> http://www.learnyouahaskell.com/
14:44:33 <increpare> medfly: I'm told Data.Array.Diff has been removed in 6.12.1, but I can't find where to at all - doesn't seem to be in the array package
14:44:35 <byorgey> CBro2007: ^^^
14:44:36 <Twey> @where rwh
14:44:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:44:37 <gwern> medfly: you mean paul graham's company which he sold and which then got rewritten in java/whatever :)
14:44:39 <Cale> theorbtwo: But they're not exactly things you'd use to program general applications -- at least, not yet.
14:44:44 <medfly> gwern, the horror
14:44:48 <esr> Yes, that was Paul Graham.  He's a good guy.
14:44:48 <gwern> medfly: or reddit, which then got rewritten in python
14:44:48 <Twey> ↑
14:45:06 <CBro2007> are there any good books you guys recommend?
14:45:13 <CBro2007> I am bit of a book guy :)
14:45:15 <Cale> McManiaC: Yeah, I suppose you could :)
14:45:16 <medfly> gwern, I don't know, but it got me thinking about how using a strange language like that can be an advantage, not a disadvantage :)
14:45:20 * gwern would make fun of commercial lisp more, but it's not like our list of commercial users isn't a bit dubious
14:45:23 <Zao> CBro2007: The two common ones.
14:45:23 <xerox> Twey: somebody turned your code around 90 degrees!
14:45:27 <esr> I've been reading Real World Haskell.  It's working for me.
14:45:31 <Zao> CBro2007: RealWorldHaskell and LearnYouAHaskell.
14:45:35 <Zao> Both available on the internets.
14:45:37 <CBro2007> is there like a definitive guide?
14:45:40 <gwern> CBro2007: you know, LYAH is coming soon to a bookstore near you. so that should cure your prejudice
14:45:44 <CBro2007> ok will check em out
14:45:49 <byorgey> CBro2007: you can get Real World Haskell in dead tree form as well.
14:45:54 <ben> gwern: Will it have the illustrations?
14:45:59 <McManiaC> dead tree form lol
14:46:00 <mpiechotka> medfly: It is disadvantage. Now I hate programming... in any language that is not Haskell ;)
14:46:07 <gwern> ben: of course not. illustrations, in books? perish the thought
14:46:10 <increpare> Cale: have you been doing any fun stuff with haskell recently?
14:46:16 <nostrand> LYAH is to short =(
14:46:19 <McManiaC> mpiechotka: I only see "unsafePerformIO" everywhere ;D
14:46:30 <Cale> increpare: Nothing too magnificent.
14:46:30 <byorgey> nostrand: BONUS has promised to continue it soon...
14:46:32 <increpare> mpiechotka: don't be a hater, be a lover : )
14:46:34 <gwern> they call it a GUI, not a 'Book UI', clearly proving the lack of graphics in the book interface
14:46:37 <CBro2007> There was some talk of not being able to implemet things like "backtracking" as easily in Haskell as in Prolog
14:46:39 <CBro2007> is that true?
14:46:42 <mpiechotka> McManiaC: And Maybe Any ;)
14:46:43 <increpare> Cale: any minor delectations?
14:46:45 * theorbtwo has dead-tree of Real World Haskell.
14:46:48 <Twey> xerox: Hmm?
14:46:48 <byorgey> CBro2007: no.
14:46:57 <CBro2007> byorgey: so its as easy?
14:46:57 <xerox> Twey: your arrow was upards :o
14:47:00 <xerox> *upwards
14:47:05 <McManiaC> real world haskell is a nice book, but it has *many* really *weird* examples which you'll have to skip - otherwise you'll think everything you can do with haskell is weird stuff :>
14:47:05 <Twey> Haha
14:47:07 <Cale> increpare: I've been vaguely dreaming about learning something about electrical engineering while writing a circuit simulator.
14:47:11 <gwern> CBro2007: well, I wouldn't call it *as* easy, but the difference is not major
14:47:17 <Cale> increpare: But I have nothing to show for that :)
14:47:18 <CBro2007> ok
14:47:18 <Twey> Pointing to the link I just effected.
14:47:23 <medfly> Cale, it's my fault?
14:47:23 <increpare> Cale: have you seen the papers modelling electronics using cohomology?
14:47:27 <nostrand> byorgey: :D
14:47:32 <theorbtwo> There's a couple of exercises you shouldn't be too worred about solving well.
14:47:38 <Cale> increpare: I haven't, but it sounds interesting :)
14:47:39 <CBro2007> I am wondering how haskell performs
14:47:42 <xerox> increpare: that sounds very much like a simplifying step indeed.
14:47:50 <CBro2007> would it scale if you had a lot of stuff to do?
14:47:51 <increpare> Cale: i'll see if i can find a link to it...
14:47:52 <Cale> CBro2007: GHC-compiled Haskell can perform really well.
14:47:54 <mpiechotka> increpare: Since now the 'other' is Java I have hard time. So many operations are 1. verbose 2. unsafe 3. unreadable
14:47:54 <theorbtwo> I'm fairly certian it's simply impossible to solve one of them well, given the Haskell it has taught you so far.
14:47:56 <byorgey> CBro2007: I mean, Haskell does not have backtracking search built in like Prolog does.  but if you want to do that sort of thing it's pretty easy to code yourself, and there are even libraries people have released for doing that
14:48:14 <CBro2007> Cale: In Haskell can you do parallel programming?
14:48:20 <Cale> CBro2007: absolutely
14:48:22 <byorgey> heck yes
14:48:23 <mpiechotka> increpare: consider data Something = A | B | C ;)
14:48:23 <gwern> CBro2007: have you looked at the Shootout haskell entries? that's our standard example for 'can haskell be fast'.
14:48:24 <CBro2007> ah cool
14:48:28 <medfly> CBro2007, it's what Haskell is really good for
14:48:29 <mauke> @protontorpedo
14:48:29 <lambdabot> how is smalltalk different from haskell?
14:48:29 <McManiaC> @can haskell do parallel programming?
14:48:29 <Cale> CBro2007: It's one of the major advantages.
14:48:29 <lambdabot> Maybe you meant: faq map run wn
14:48:36 <gwern> CBro2007: single machine parallelism is something of a haskell specialty
14:48:36 <increpare> mpiechotka: consider it considered
14:48:42 <McManiaC> !can foo
14:48:52 <CBro2007> ok coz some people also recommended looking into ERLANG
14:48:53 <medfly> @faq can Haskell do something?
14:48:53 <esr> CBro2007: I'm something of a compiler jock.  Haskell is alleged to compile to very fast code.  The degree of static typing is such that I find these allegations credible.
14:48:53 <lambdabot> The answer is: Yes! Haskell can do that.
14:48:53 <McManiaC> whats the command? :S
14:48:56 <CBro2007> for parallelism
14:48:56 <McManiaC> faq
14:48:57 <McManiaC> :D
14:49:10 <medfly> CBro2007, Haskell is pretty good.
14:49:13 <theorbtwo> Yes, though you should be careful about that; some of the terminology around parallelisim gets used differently by haskellers and everyone else.
14:49:20 <CBro2007> esr: ok thanks
14:49:30 <mauke> CBro2007: are you sure you're not gavino?
14:49:36 <gwern> CBro2007: erlang > haskell if you want to spread over multiple machines
14:49:39 <theorbtwo> For example, haskellers tend to differenciate parallel programming and concurrent programming.
14:49:40 <CBro2007> so on a Mac I just need to download "GHC-haskell" and off I go?
14:49:41 <jlouis> CBro2007: Erlang is bad for parallel computation and good for concurrency. Haskell is pretty good at both
14:49:46 <ddarius> mauke: He's not.
14:49:52 <medfly> @google haskell platform
14:49:53 <lambdabot> http://hackage.haskell.org/platform/
14:49:53 <lambdabot> Title: Haskell Platform Download (Beta)
14:49:53 <byorgey> CBro2007: download the Haskell Platform
14:49:56 <CBro2007> mauke: who is gavino?
14:50:00 <medfly> I think that's that... but not sure
14:50:06 <ddarius> @where hp
14:50:06 <lambdabot> I know nothing about hp.
14:50:11 <ddarius> @where platform
14:50:11 <lambdabot> http://hackage.haskell.org/platform/
14:50:14 <ddarius> Good
14:50:39 <gwern> @where+ hp http://hackage.haskell.org/platform/
14:50:40 <lambdabot> It is stored.
14:50:45 <gwern> @flish
14:50:48 <theorbtwo> To my mind, the typing is the most interesting thing about haskell.
14:51:02 <theorbtwo> You get lots of typing (of values) with very little typing (on your keyboard).
14:51:12 <CBro2007> I want something lightweight that performs well really... will look into Haskell some more
14:51:26 <CBro2007> the ML syntax I breifly looked at ... it looked pretty neat
14:51:26 <theorbtwo> What do you mean by "lightweight"?
14:51:51 <McManiaC> ghc is about 600MB
14:51:54 <McManiaC> so its not lightweight
14:51:56 <McManiaC> :>
14:51:59 <CBro2007> not something clunky like a Java JVM shit
14:52:06 <esr> Yeah, I first aspproached the language as sort of the minimal mutation of LISP given that you want it to have static typing.  (Ignoring details like syntax.)  That approach seems to be working so far.
14:52:11 <CBro2007> that is bloated with all sorts of crap and chews on memory
14:52:12 <zygoloid> McManiaC: it fits on a 10 gram USB stick
14:52:13 <Cale> GHC compiles Haskell to native code.
14:52:13 <CBro2007> :)
14:52:19 <Cale> But there's also a bytecode interpreter
14:52:31 <Cale> (which it uses when you load things in GHCi or use runhaskell)
14:52:33 <ddarius> esr: It's easy to write really slow code in Haskell.  With some experience or some care, it's not hard to write reasonably fast code.  It takes a bit more effort to write very fast code, but more and more libraries and tools are becoming available that make that easier.
14:52:33 <McManiaC> zygoloid: hehe
14:52:34 <CBro2007> I think I prefer the compiled version then
14:52:39 <theorbtwo> Even worse, haskell executables tend to be quite large, and haskell uses huge amounts of RAM for things you wouldn't expect it to.
14:52:52 <aavogt> you can get memory leaks in any language
14:52:54 <McManiaC> zygoloid: lol it took my a while to get that one :S
14:52:56 <theorbtwo> However, RAM and disk are cheap, and it does compile down to machine code.
14:52:57 <Cale> CBro2007: Generally you'll use both in any one project. GHCi for debugging and testing, compile for performance.
14:53:13 <gwern> esr: mm. with that perspective you could as well just look at ml rather than haskell
14:53:13 <Twey> But now we have static linking.
14:53:13 <CBro2007> hmm
14:53:14 <luite> CBro2007: making haskell programs fast can be challenging in some cases... it requires quite a different set of skills from optimizing imperative programs. but the advantage is that you can often write a correct (but slow) version quickly, and work from that to optimize its performance
14:53:30 <Twey> Er, dynamic linking.
14:53:38 <gwern> esr: laziness and more type madness are the major distinguishing features between mls and haskells, imo
14:53:46 <esr> gwern: Yes.
14:53:50 <theorbtwo> Twey: IIRC, only of the runtime, not of actual client libraries.
14:53:55 <McManiaC> yeh… its easy to get binaries with > 20 mb
14:53:57 <CBro2007> ok so it seems like its quite easy to write a real shit slow program for beginners
14:54:09 <CBro2007> and only with experience I can tune it to run super fast?
14:54:15 <nostrand> CBro2007: it is in all languages
14:54:16 <theorbtwo> gwern: OTOH, lazyness is the second most interesting thing about haskell.
14:54:18 <Twey> theorbtwo: No, of libraries too, I'm fairly sure.
14:54:24 <Botje> CBro2007: learn haskell and see for yourself.
14:54:49 <CBro2007> ok wit this book .. does it give you good pointers on what things to avoid?
14:55:05 <CBro2007> I mean there must be some common pitfalls where programmers fuck up :)
14:55:12 <Botje> i've solved over 100 of the project euler problems in haskell with a runtime less than a minute and i'm not a pro
14:55:24 <esr> CBro2007: Seriously, it is already clear to me that Haskell is ome of the language worth learning for how it changes your thinking about programming, even if you never use it much.
14:55:33 <medfly> Botje, very persistent
14:55:35 <nostrand> Botje: it's almost cheating to use Haskell there :D
14:55:36 <theorbtwo> CBro2007: There's a few things that will grind you to a skreeching halt.  Avoiding those is pretty easy, unless it turns out that somebody else did them for you.
14:55:53 <Botje> CBro2007: the pitfall most people fall into is not learning haskell.
14:55:57 <theorbtwo> Most of the time, bad haskell code will be faster then bad C code, I think.
14:56:13 <CBro2007> well there is no such thing as bad C code
14:56:17 <CBro2007> coz then you are fucked
14:56:18 <CBro2007> :)
14:56:19 <esr> !!!!
14:56:20 <McManiaC> lol
14:56:23 <McManiaC> righto
14:56:26 <CBro2007> it probably won't even run
14:56:36 <theorbtwo> ...because lazyness means that the results of computations that you don't use are never actually computed.
14:56:39 <medfly> esr, I agree. Haskell is the first language I became proficient at, and it seemed to have gotten me pretty far ahead in programming, unusually so.
14:56:40 <Cale> CBro2007: The main thing about getting Haskell code to perform well is that you have to remember that Haskell's evaluation model is probably so different from anything you're used to that it's like learning to program all over again.
14:56:42 <mpiechotka> CBro2007: Only if you're lucky
14:56:48 <McManiaC> CBro2007: well, in that case: bad haskell code wont even *compile*
14:56:49 <zygoloid> CBro2007: haskell code which is wrong in a similar way probably won't even compile
14:56:59 <increpare> Cale: ah here it is, chapter 3 of http://www.math.tamu.edu/~rojas/bott6.ps.gz
14:57:00 <theorbtwo> medfly: Er, that's not really related to what he's saying.
14:57:03 <Cale> CBro2007: So it takes quite a while to develop a sense of what will be efficient.
14:57:10 <medfly> no I mean... it has gotten me to learn a lot of things.
14:57:12 <medfly> IT IS RELATED!
14:57:17 <theorbtwo> medfly: What he's saying is that Haskell is a good second language.
14:57:19 <CBro2007> yeah so I am hoping that this good book will help me start by writing some good code
14:57:51 <Cale> CBro2007: The main thing as a beginner is to learn when *not* to use lists.
14:57:58 <CBro2007> Cale: yeah I get that... but it shouldn't be that you are writing something real simple and you follow the best guidelines and its still running like crap and you have these memory problems
14:58:01 <esr> theorbtwo: Actually medfly is right I intended a slightly more general claim.
14:58:12 <medfly> woo hoo!
14:58:15 <zygoloid> Cale: you mean, like, don't use lists of Char for strings? ;-)
14:58:17 <CBro2007> like last assignment we used Python
14:58:17 <medfly> I don't get to feel like a loser
14:58:17 <theorbtwo> Hm.  Fair enough.
14:58:19 <Cale> CBro2007: You can think of lists as being like loops that have been frozen in time.
14:58:22 <increpare> Cale: I remember coming across a clearer article, but I also remember that it was impossible to track down
14:58:23 <SamB_XP> 2nd, 3rd, 19th ... but not 5th!
14:58:37 <Cale> CBro2007: In any case where you're iterating over things in linear order, it makes sense to use lists.
14:58:44 <Cale> For random access though, lists are awful.
14:58:47 <olsner> lists are awesome when you get them deforested
14:58:48 <CBro2007> and we used "lists" ... and it was shit slow... then we used "sets" and that was super fast..
14:59:00 <Cale> If you want a set or a finite map, you should use Data.Set or Data.Map
14:59:09 <CBro2007> apparently in Python if you deleted elements from a list it would make a local copy of the entire list
14:59:11 <CBro2007> or some shit
14:59:36 <Cale> In Haskell, you'll only end up "copying" the portion of the list up to the element you removed
14:59:38 <theorbtwo> Hm.  Possibly it's my perlish background showing, but that seems really wierd.
14:59:39 <McManiaC> Cale: otoh- I think if you really want to get into that high performance haskell coding stuff, with all those pragmas, strict notations etc, you'll need a quite good understanding of imperative languages… functional programming cannot teach you that :)
14:59:40 <ddarius> CBro2007: Python calls arrays "lists".
14:59:40 <medfly> python has some strange performance things...
14:59:46 <ddarius> It's pretty aggravating.
14:59:59 <CBro2007> Cale: so if you were say implementing something like a binary search or a quicksort algo.. what data structure would you use?
15:00:00 <Cale> McManiaC: I don't know about that.
15:00:19 <Cale> McManiaC: It seems to me that one can learn imperative programming quite nicely within the setting of Haskell. :)
15:00:22 <increpare> Cale: actually, just remembered I had a copy upstairs...journal of differential geometry 1972 - 193-210, "On the mathematical foundations of electrical circuit theory", by Smale.  Anyway, enough about that.
15:00:25 <theorbtwo> ddarius: All nomenclatures that aren't universal are annoying to somebody.
15:00:39 <CBro2007> yeah thats why I hope Haskell doesn't have these "undocumented" features too where you just got to learn from practise what works and what doesnt etc
15:00:39 <Cale> CBro2007: For binary search, I'd use a tree.
15:00:40 <McManiaC> Cale: indeed :)
15:00:41 <increpare> theorbtwo: so are all nomenclatures that are ;)
15:00:53 <SamB_XP> CBro2007: binary search I'd use a Binary Search Tree ...
15:01:00 <ddarius> theorbtwo: Particularly so when it is only one language that feels like being different.
15:01:00 <SamB_XP> (like Data.Map)
15:01:16 <CBro2007> ok so there is already a tree data structure I can use?
15:01:23 <theorbtwo> ddarius: Ah, but it isn't.  You just don't know enough languages.
15:01:27 <gwern> CBro2007: tons
15:01:30 <Cale> CBro2007: Quicksort can be implemented on lists, but it's not the best sorting algorithm in the world on lists (or in general for that matter)
15:01:32 <CBro2007> nice!
15:01:36 <gwern> the real question is which tree?
15:01:43 <gwern> or roll your own? easy enough
15:01:46 <Cale> CBro2007: To sort lists, a mergesort works a whole lot better.
15:01:50 <SamB_XP> yeah, MOST of our datastructures are trees ;-P
15:01:53 <ddarius> theorbtwo: I know it isn't, but it is definitely in the minority and young enough to know better.
15:01:57 <Cale> and has more predictable performance to boot
15:02:01 <CBro2007> yeah I just came up with an example :)
15:02:24 <theorbtwo> In perl, arrays and lists are essensially the same thing -- the different is syntatic, not related to in-memory representation... and both are based on C arrays, not linked lists.
15:02:31 <CBro2007> also is there a code repository you guys download modules from?
15:02:36 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) -- binary tree implementation
15:02:38 <medfly> @where cabal
15:02:38 <lambdabot> http://www.haskell.org/cabal
15:02:44 <Cale> CBro2007: hackage
15:02:48 <CBro2007> ok
15:02:50 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
15:03:04 <McManiaC> hackage is pretty awesome
15:03:05 <Cale> CBro2007: you install packages from there using the cabal-install program
15:03:26 <SamB_XP> it's not exactly CPAN, but it beats CTAN ;-P
15:03:27 <Cale> cabal install <packagename>  will download, compile, and install the library or program from Hackage.
15:03:27 <CBro2007> I was actually going to do more C stuff for data structures like all kinds of trees, graphs etc
15:03:37 <CBro2007> but maybe its simpler to do that in haskell
15:03:41 <McManiaC> oh - and one thing i *love* about haskell are its developers… usually you'll get a response within a few hours/days when you email one with a problem :>
15:03:58 <CBro2007> ok
15:04:01 <McManiaC> (from hackage libraries)
15:04:04 <CBro2007> always a good thing
15:04:05 <theorbtwo> In C, an array is an actual type, and a list is a whole class of abstract types, more or less.
15:04:13 <Cale> CBro2007: Yeah, feel free to ask questions here, or if you're having trouble getting a response with something involved, the mailing list is also a rather handy resource.
15:04:18 <McManiaC> not sure about base devs… but theres not much wrong with the base anyway :)
15:04:26 <Zao> Or those insane Chalmers haskellites.
15:04:27 <CBro2007> ok thanks Cale
15:04:29 <chrisdone> man I bloody love making a big change with haskell code and it compiling first time
15:04:37 <ddarius> theorbtwo: C just doesn't have lists.  They can, of course, be implemented as libraries.
15:04:37 <theorbtwo> Using either of the terms to mean a specific representation is silly.  You should know better, and say "linked list" if that is what you mean.
15:04:39 <McManiaC> chrisdone: hehe
15:04:39 <gwern> haskell devs are so needy; the responses I got sometimes when asking about cabalizing & uploading code were pitiful
15:04:42 <Cale> CBro2007: We try not to tell beginners to RTFM.
15:04:56 <CBro2007> RTFM?
15:05:03 <theorbtwo> ddarius: I know.
15:05:05 <SamB_XP> chrisdone: not as much as *I* love making a big change and it working the first time I get it to typecheck again ;-P
15:05:05 <mauke> ddarius: oh yeah? how about parameter lists? :-)
15:05:11 <Zao> gwern: Uploading something to hackage means showing the world, for real.
15:05:12 <chrisdone> BCoppens: read the flowery manual
15:05:13 <Zao> gwern: That's scary.
15:05:17 <increpare> I have resolution.  Diffarray has been moved to its own package which isn't on hackage yet.  http://hackage.haskell.org/trac/ghc/ticket/3370
15:05:18 <Cale> (read the fucking manual -- it's a common response in some programming and technical channels)
15:05:28 <gwern> Zao: speaking of which... how your xtris coming along
15:05:33 <Zao> SamB_XP: Of course, it may take a week to get it to typecheck :P
15:05:38 <chrisdone> CBro2007: whoops, I meant you: read the flowery manual
15:05:42 <CBro2007> yeah I have heard that one...its annoying when people think they are top shit
15:05:47 <McManiaC> Cale: we prefer "RTRWH" or "RTLYAH" :>
15:05:48 <CBro2007> yeah I got it
15:05:50 <SamB_XP> yeah, we don't deserve "fine" WRT most of our manuals, yet. unfortunately :-(
15:05:54 <Zao> gwern: Fixed it so it compiles on 6.10.4, had some exception snafus.
15:05:58 <CBro2007> or LITFM
15:06:04 <medfly> CBro2007, this channel tries to be helpful even when you're trolling
15:06:06 <Cale> Just asking is often a lot more effective than looking through the documentation.
15:06:11 <nostrand> RTFM is still better response than you'll get on #debian ;)
15:06:15 <medfly> CBro2007, some pretty fucked up shit there
15:06:23 <luite> medfly: yeah I guess that must be really annoying to trolls :p
15:06:24 <gwern> Zao: so one could expect an upload soon?
15:06:26 <Zao> gwern: I need to clean up the code though, I want to think I've learnt a fair bit of Haskell in the year that has passed.
15:06:28 <medfly> luite, hell yes
15:06:30 <McManiaC> CBro2007: oh and theres hoogle! an awesome search engine for haskell functions
15:06:30 <Zao> gwern: Unlikely.
15:06:38 <Zao> gwern: It's year-old uncommented scary-code.
15:06:48 <gwern> Zao: you're letting the perfect be the enemy of the good, I see
15:06:49 <CBro2007> yeah I can imagine its annoying to ask... but just to get a suggestion or an opinion is what a chat is meant for really
15:06:53 <gwern> release early, release often!
15:06:55 <SamB_XP> nostrand: what, they instapermaban you when you so much as /join or something ?
15:07:03 <CBro2007> hoogle eh?
15:07:06 <CBro2007> nice name! :)
15:07:08 <CBro2007> hahhaha
15:07:12 <nostrand> SamB_XP: something like that :p
15:07:14 <gwern> @hoogle (a,b) -> b
15:07:14 <lambdabot> Prelude snd :: (a, b) -> b
15:07:15 <lambdabot> Data.Tuple snd :: (a, b) -> b
15:07:15 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
15:07:17 <gwern> eureka!
15:07:18 <Zao> CBro2007: There's also Hayoo.
15:07:21 <Cale> Feeding trolls is an effective response as long as you ensure that the stuff you're feeding them with is incidentally probably useful information to others even if the troll is not really listening.
15:07:25 <McManiaC> CBro2007: if youre looking for a function that modifies a list for example you can just think of the type of that function (without knowing its name), enter it into that search engine and hoogle will tell you what functions would satisfy that type :)
15:07:44 <CBro2007> ah nice
15:07:53 <SamB_XP> Cale: it also saves you time trying to figure out if people are trolling or not ;-P
15:07:58 <CBro2007> I really must start from the basics and muck around with the language
15:08:08 <CBro2007> thanks guys
15:08:22 <CBro2007> am off now .. but thanks for the help
15:08:29 <Cale> Right. More than once, I've run into people who I suspected were trolling, but it really just turned out that they didn't know how to ask questions very well, and were genuinely interested.
15:08:30 <McManiaC> good luck :)
15:08:43 <CBro2007> thanks!
15:08:54 <gwern> Cale: well, esr wrote 'how to ask questions the smart way' for a reason!
15:08:58 <SamB_XP> and maybe even a troll might forget what they came here for
15:09:01 <MadHatterDude> Arrows look really cool...
15:09:02 <medfly> stop quoting him
15:09:07 <medfly> it's creepy
15:09:13 <SamB_XP> is that really esr?
15:09:16 <Cale> medfly: who?
15:09:17 <medfly> it apparently is
15:09:20 <medfly> Cale, esr
15:09:21 <medfly> ...
15:09:24 <esr> Heh.
15:09:25 <Cale> medfly: huh?
15:09:31 <Cale> I'm quoting esr now?
15:09:35 <medfly> esr, you'd have to prove it with naked pics
15:09:40 <Cale> haha
15:09:41 <medfly> there! I said it!
15:09:41 <esr> I get this a lot when I show up on IRC.
15:09:47 <theorbtwo> Of esr?  Please, no.
15:09:51 <mauke> esr: what, request for pix?
15:09:52 <esr> Heh.
15:09:54 <McManiaC> hehe
15:10:07 <esr> Ni, people not believing it's me.
15:10:08 <CBro2007> esr: did you say you were into compilers earlier on?
15:10:08 <theorbtwo> He's either esr, or he's a fairly good fake.
15:10:16 <esr> CBro2007: Yes.
15:10:18 <SamB_XP> esr: it's just that people often show up on irc with the names of famous people
15:10:29 <gwern> esr: of course you do. even now it's still too famous a name. you should see what happens when jwales shows up in #wikipedia
15:10:31 <SamB_XP> often as a joke
15:10:34 <CBro2007> esr: have you used Haskell to implement a compiler or sections of it?
15:10:41 <tinflu>  /nick Beyonce
15:10:42 <theorbtwo> Does it matter of it's the real esr?  Would you say something different if he was rse?
15:10:44 <gwern> not that jwales has been there in a year or two
15:10:44 <tinflu> oops :D
15:10:52 <esr> CBro2007: No, not yet.
15:10:55 <medfly> theorbtwo, of course. we would all be like "fuck you, rtfm"
15:10:58 <CBro2007> ok just wondering
15:11:14 <SamB_XP> theorbtwo: just curiousity :P
15:11:21 <CBro2007> when I was doing the compiler classes the guys who worked on a compiler building project used ML to do it
15:11:22 <olsner> "not yet" :)
15:11:33 <CBro2007> said it was much simpler than trying to do the same in C or C++
15:11:41 <esr> And I don't worry about authenticating myself because my absurd famousness is usually irrelevant to the reason I'm on-channel.
15:11:47 <nostrand> CBro2007: yep, shure is
15:12:03 <medfly> so we're not getting any naked pics?
15:12:05 <Botje> CBro2007: i've written two compilers in haskell now. it's heaven compared to other languages
15:12:10 <chrisdone> http://kiboki.net/haskell/doc/html/haskell-json/haskell-json.fcgi/Network-CGI-Session.html
15:12:11 <CBro2007> maybe Haskell might be pretty neat with regular expressions, syntax trees etc
15:12:14 <esr> medfly: No, sorry :-)
15:12:15 <gwern> theorbtwo: well, if it was the real esr, we could ask questions. for example, I've always wondered whether he sold his valinux (or whatever ipo it was) stock before the dotcom bubble, but there'd be no point in asking that of an imposter
15:12:17 <chrisdone> worth putting on hackage? I use this all the time
15:12:18 <medfly> :)
15:12:25 <CBro2007> Botje: ah cool
15:12:27 <SamB_XP> medfly: we don't even know what he looks like naked anyways, so how would that authenticate him?
15:12:34 <SamB_XP> that only works for proving you're FEMALE
15:12:44 <medfly> SamB_XP, because if it looked like him and he's naked, then it's probably him
15:12:48 <esr> gwern: No, I didn't sell out in time.  Was worth $42 mil on paper at one point, sigh.
15:12:57 <gwern> SamB_XP: we could see whether the carpet matches the awning, if you follow
15:13:03 <esr> HA!
15:13:04 <Zao> Odd. Tracerouting CBro2007 ends up loop routing.
15:13:33 <Axman6> CBro2007: regular expressions are a bad idea in a compiler
15:13:34 <gwern> esr: ouch! I had always assumed you saw the bubble and had sold most of it
15:14:04 <esr> gwern: Alas, no.  I was busy changing the world.  Didn't pay enough attebtion to the money.
15:14:11 <SamB_XP> medfly: you realize that would only really work once
15:14:14 <chrisdone> esr: I was just thinking today about how you wrote Lisp is a language worth learning for the mind expanding experience. what then of Haskell? haha
15:14:19 <medfly> SamB_XP, yeah...
15:14:20 <McManiaC> who is esr anyway? :O
15:14:21 <SamB_XP> especially in a channel of this size
15:14:25 <SamB_XP> McManiaC: lol
15:14:27 <medfly> McManiaC, he's an INTERNET CELEBRITY!
15:14:30 <gwern> McManiaC: see wikipedia [[esr]]
15:14:33 <esr> chrisdone: Same is true of Haskell, IMO
15:14:41 <SamB_XP> @all-dict esr
15:14:42 <lambdabot> *** "ESR" wn "WordNet (r) 2.0"
15:14:42 <lambdabot> ESR
15:14:42 <lambdabot>      n 1: the rate at which red blood cells settle out in a tube of
15:14:42 <lambdabot>           blood under standardized conditions; a high rate usually
15:14:42 <lambdabot>           indicates the presence of inflammation [syn: {erythrocyte
15:14:44 <lambdabot> [14 @more lines]
15:14:46 <esr> medfly: Oh, shut up :-)
15:14:50 <SamB_XP> @jargon esr
15:14:50 <lambdabot> No match for "esr".
15:14:54 <SamB_XP> oh, good
15:14:56 <medfly> ooh...
15:14:58 <SamB_XP> @devils esr
15:14:58 <lambdabot> No match for "esr".
15:15:10 <CBro2007> sorry what were those haskell books again?
15:15:13 <gwern> SamB_XP: give it a break. I didn't say dictionary or jargon file
15:15:16 <medfly> @where lyah
15:15:16 <lambdabot> http://www.learnyouahaskell.com/
15:15:18 <medfly> @where rwh
15:15:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:15:23 <medfly> CBro2007, those?
15:15:27 <CBro2007> yeah those
15:15:28 <CBro2007> thanks
15:15:36 <chrisdone> CBro2007: have you tried haskell yet?
15:15:37 <CBro2007> I found realworld Haskell online
15:15:39 * SamB_XP kinda wishes the devil's dictionary had an entry on him -- it would probably be quite amusing
15:15:44 <CBro2007> chrisdone: nah not at all
15:15:48 <CBro2007> I want to now :)
15:15:53 <chrisdone> CBro2007: http://tryhaskell.org !
15:16:02 <McManiaC> eric raymond?
15:16:04 <NEEDMOAR> esr: I LOVE YOU MAN.
15:16:14 <esr> LOL
15:16:15 <SamB_XP> @devils accountant
15:16:16 <lambdabot> No match for "accountant".
15:16:24 <McManiaC> hehe
15:16:26 <SamB_XP> @devils banker
15:16:27 <lambdabot> No match for "banker".
15:16:31 <medfly> @help devils
15:16:32 <lambdabot> I perform dictionary lookups via the following 13 commands:
15:16:32 <lambdabot> all-dicts ... Query all databases on dict.org
15:16:32 <lambdabot> devils ...... The Devil's Dictionary
15:16:32 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
15:16:32 <lambdabot> elements .... Elements database
15:16:34 <lambdabot> [9 @more lines]
15:16:40 <SamB_XP> @devils lawyer
15:16:40 <lambdabot> *** "LAWYER" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
15:16:41 <lambdabot> LAWYER, n.  One skilled in circumvention of the law.
15:16:41 <lambdabot>  
15:16:47 <CBro2007> chrisdone: thats a pretty neat one
15:16:52 <CBro2007> can you test code on there?
15:16:58 * esr thinks he has become distracting from cjhannel business and should probably go away now
15:17:11 <chrisdone> CBro2007: you can evaluate expressions
15:17:13 <gwern> hm. why did lambdabot print an empty line? maybe a reverse dropWhile whitespace reverse
15:17:20 <SamB_XP> esr: eh, it's always like this ;-P
15:17:23 <CBro2007> chrisdone: ok pretty handy site ... thanks
15:17:30 <medfly> esr, this channel is a bit less strict about that, too.
15:17:31 <chrisdone> CBro2007: I am currently working on writing several line functions, types, etc
15:17:36 <olsner> esr: channel business varies, it appears you are currently the business :P
15:17:37 <medfly> esr, you are considered a reasonable topic
15:17:40 <medfly> esr, being CS-related
15:17:42 <SamB_XP> except sometimes in the middle of the night
15:17:43 <esr> But you guys were pretty funny about it.  Thanks for the help.
15:17:44 <CBro2007> chrisdone: is that your site?
15:17:46 <gwern> CBro2007: no need for another website to test haskell, when we have lambdabot
15:17:46 <theorbtwo> Yow.  Sorry to hear that, esr.  I made quite a lot on VA.
15:17:49 <chrisdone> CBro2007: yep
15:17:54 <gwern> > take 20 [1..]
15:17:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
15:18:08 <theorbtwo> (I sold it as soon as I could.)
15:18:17 <gwern> :) flipper
15:18:18 <SamB_XP> there is codepad!
15:18:20 <CBro2007> how do you use lambdabot?
15:18:26 <medfly> @help
15:18:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:18:36 <medfly> @hackage lambdabot
15:18:36 <lambdabot> http://hackage.haskell.org/package/lambdabot
15:18:56 <esr> theorbtwo: I couldn't.  There was a six-month lockout for directors, so my window before the bust was really short.  Might not have been more than a month.
15:19:14 <zygoloid> > fix((0:).(1:).ap(zipWith(+))tail)
15:19:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:19:22 <gwern> @quote aztec
15:19:22 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:19:27 <zygoloid> fibs have been summoned. normal #haskell service is resumed.
15:19:37 <chrisdone> gwern: haha
15:19:57 <chrisdone> BONUS: hi there =)
15:19:59 <theorbtwo> esr: *nod*  I didn't realize you were a director.  Thanks for giving stock to everybody in the linux authors file, if you were in on that.
15:20:10 <esr> theorbtwo: I was.
15:20:15 <chrisdone> BONUS: wrote any more of your book? :p
15:20:15 <gwern> theorbtwo: eh?
15:20:17 * olsner imagines those ` are supposed to be prounced as glottal stops
15:21:31 <ddarius> olsner: I think the plosives already provide a suitably staccato pronunciation.
15:22:10 <esr> theorbtwo: I also saved the company, though I didn't realize I was doing that at the time.  I was the person who talked the rest of the Board into choosing Andover as our first acquisition target.
15:22:31 <gwern> andover?
15:22:38 <esr> Slshdot.
15:22:43 * mauke suggests #haskell-blah
15:22:53 <esr> The money from that kept VA afloat.
15:22:56 <theorbtwo> gwern: VA Linux gave the ability to buy stock, pre-IPO, at very low prices, to everyone listed in the authors file of the linux kernel.  I was in there at the time, for a very minor patch.
15:23:32 <gwern> theorbtwo: oh wow. I'm amazed they did that - it must've diluted equity a fair bit if a minor patch got you enough to flip
15:23:45 <olsner> ddarius: well, three plosives in a row - that's a hat trick
15:23:59 * hackagebot treemap-html-tools 0.2 - Treemap related commands for producing foldable TreeMap HTML.  http://hackage.haskell.org/package/treemap-html-tools-0.2 (RadoslavDorcik)
15:24:17 <olsner> (had to look that up, but p, t and glottal stop were all categorized as plosives)
15:24:40 * esr enjoys descriptive phonology, too
15:25:03 <theorbtwo> gwern: Everybody in the file.  (Possibly everybody with a US address.)  Getting in the file was a matter of getting a patch accepted that put you in it.
15:28:03 <SamB_XP> I once changed a one token of code from a 0 to constant that was #defined to be zero, and added a comment ...
15:28:32 <olsner> and the name of the constant was ... "ONE"? :P
15:28:36 <mauke> /* SamB was here */
15:29:00 <SamB_XP> olsner: it was probably VM86_FOO_BAR or something like that
15:30:22 <SamB_XP> the reason I did it was because I was trying to rewrite the manpage for vm86(), and had incorrectly concluded that because the kernel did not actually use this preprocessor define, the syscall never returned that value ;-)
15:30:50 <SamB_XP> the point of the comment was to point out that the #define had a value of 0
15:34:46 <SamB_XP> hmm, explorer.exe seems to have forgotten that it's supposed to redraw the desktop once in a while ...
15:35:04 <Polarina> @src even
15:35:04 <lambdabot> even n = n `rem` 2 == 0
15:35:27 <_jef> Looking for hand-holding guidance cleaning up my Haskell/xmonad installation on Ubuntu Jaunty.  I know very little of Haskell.
15:35:52 <esr> Ah, I have something more fun than naked pictures to offer y'all.  My Pandora Radio station: http://www.pandora.com/#/stations/share/191074140164909905
15:36:38 <luite> "We are deeply, deeply sorry to say that due to licensing constraints, we can no longer allow access to Pandora for listeners located outside of the U.S." :(
15:37:16 <esr> Alas.
15:37:44 <luite> guess I'll have to make do with naked pictures then
15:38:20 <esr> Actrually, that's my secondary one, all tribal-ambient.  I've  got the URL for the prog-metal/fusion-jazz station around here somewhere...
15:39:25 <mauke> first result for google image search "esr porn": http://tinyurl.com/6gg3f
15:39:26 <Azstal> that one would interest me except I'm not in the USA. At least we get spotify in the UK :)
15:39:53 <olsner> oooh, nice keyboard
15:40:35 <esr> That's the picture People Magazine took of me backk in '96.
15:41:32 <_jef> Help available here?  I tried to update a perfectly xmonad 0.8 on Ubuntu Jaunty, and it's getting messier as I go...
15:41:49 <_jef> *perfectly fine
15:42:03 * hackagebot cgi-utils 0.0 - Simple modular utilities for CGI/FastCGI (sessions, etc.)  http://hackage.haskell.org/package/cgi-utils-0.0 (ChrisDone)
15:42:49 <SamB_XP> _jef: this is likely a reasonable place to ask your question, whatever it may be, but another place to try is of course #xmonad
15:43:02 <chrisdone> esr: and I bet you still have that quality keyboard
15:43:11 * chrisdone typing on a model m right now. mmm
15:43:51 <esr> chrisdone: Damn straight I do.  Model M buckling springs...can't beat 'em.
15:44:10 <_jef> AsmB_XP: Thanks, but I think the problem is in the area of installing the "haskell-platform".
15:44:36 <_jef> AsmB_XP: as per
15:44:37 <p_l> esr: now, if someone made a *quite* model M....
15:45:03 <_jef> AsmB_XP:
15:45:06 <esr> p_l: Why would I want a quiet one?  I *like* that sound.
15:45:12 <_jef> AsmB_XP:
15:45:22 <esr> Your mileage may vary, of course.
15:45:27 <_jef> AsmB_XP: as per
15:46:04 * SamB_XP would like a keyboard with a mute butan
15:46:06 <p_l> esr: Not for me, but for environment around me. I like people not hearing in the whole house when I'm using keyboard, as I tend to use it very late in the night (or early in the morning)
15:46:06 <esr> Now I really have to go.  Barbeque, gaming, and Futurama with some friends await me.
15:46:24 <gwern> sayonara. hope you enjoyed your time here
15:46:29 <chrisdone> see thee later
15:46:31 <gwern> we thank you for flying Haskell Airlines
15:46:37 <esr> I'lDid.  I'll be back, probably.
15:46:44 <chrisdone> gwern: are you coming to zurihac?
15:46:52 <zygoloid> *sob* he's my hero
15:46:54 <gwern> chrisdone: not being in europe, no
15:47:00 <chrisdone> gwern: D:
15:47:11 <gwern> -_-
15:47:20 <gwern> what would I do there anyhoo
15:47:27 <gwern> I'm not really working on anything right now
15:47:53 <chrisdone> gwern: the idea is to improve on haskell libs in general
15:48:12 <_jef> SamB_XP:  I installed haskell-package successfully and upgraded to ghc 6.10.4, but then I trusted apt-get autoremove and I think I lost something critical.
15:48:13 <chrisdone>  make something new/faster/help out/meet haskellers
15:48:16 * SamB_XP is tempted to @remember zygoloid's sob thing
15:48:52 <_jef> SamB_XP:  I followed the instructions for haskell-package found at http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html,
15:48:55 <SamB_XP> _jef: did you rebuild your Xmonad config?
15:49:09 <zygoloid> SamB_XP: just so you can @quote it if he returns? ;-)
15:49:20 <SamB_XP> zygoloid: er, I dunno!
15:49:25 <SamB_XP> we could get it in HWN or something
15:49:50 <_jef> SamB_XP:  and they worked fine earlier.  Now failing at make, complaining of needing mtl >= 1.0 but it appears to already exist.
15:49:52 <zygoloid> hooray, then i could be famous!
15:50:18 <SamB_XP> _jef: and you've only got the one ghc installed ?
15:50:33 <chrisdone> any english haskellers knocking about?
15:51:01 * zygoloid raises his hand
15:51:08 <chrisdone> zygoloid: wherebouts?
15:51:14 <_jef> SamB_XP:  which ghc reports just the one.
15:51:25 <zygoloid> hold on... what do you mean by 'knocking about'? ;-) i'm in cambridge
15:51:35 * chrisdone zooms in on zygloid with Google Maps like in Men In Black
15:51:51 <SamB_XP> what does ghc-pkg tell you about mtl?
15:52:16 <chrisdone> zygoloid: you going to zurihac?
15:52:30 <zygoloid> sadly not
15:54:16 <_jef> SamB_XP:  ghc-pkg list mtl  >>  /home/jef/.ghc/i386-linux-6.10.4/package.conf:  mtl-1.1.0.2
15:54:40 <chrisdone> zygoloid: D:
15:55:06 <SamB_XP> _jef: and Xmonad's build process catches user packages?
15:55:26 <SamB_XP> or just system-wide ones?
15:55:29 <chrisdone> *** MadHatterDude (~54ee7387@gateway/web/freenode/x-hujweqeqcmceepwz) has quit: Quit: dishes need washing
15:55:30 <chrisdone> I like how he has to quit IRC lest he turn to type on his keyboard with wet bubbly hands :p
15:56:29 <_jef> SamB_XP:  No, I knew I had problems when I made a small edit to mt xmonad.hs and it starting reporting missing dependencies.
15:56:30 <olsner> maybe his keybord is not waterproof
15:56:52 <olsner> (mine has drainage ports, so no problem there :P)
15:56:58 <chrisdone> olsner: clever
15:58:41 <_jef> SamB_XP:  I don't know much at all about Haskell but I love xmonad.  I don't know what questions to ask at this point.
15:58:45 <SamB_XP> _jef: well, take a look a the makefile and see if it's passing GHC any flags that would prevent it from finding packages locally in your homedir
15:59:22 <_jef> SamB_XP:  Okay, I'' try...
16:10:29 <_jef> SamB_XP:  How about removing the mtl package so it might reinstall it and be happy?  Is their a cabal command to properly remove mtl?
16:10:56 <_jef> *is there
16:10:59 <SamB_XP> _jef: I think you need to use ghc-pkg for that
16:11:18 <_jef> SamB_XP:  Tnx, I'll look...
16:14:49 <ClaudiusMaximus> :t pure
16:14:50 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:15:08 <ClaudiusMaximus> is there something like Applicative but without pure?
16:16:24 <ddarius> No.
16:17:00 <aavogt> what kind of laws would ap have if you didn't have pure?
16:17:42 <gwern> chrisdone: to improve haskell libraries in generla, give me push access to base and containers!
16:29:14 <dons> gwern: i'm not sure you hold the concerns of the entire community in mind though :)
16:29:38 <gwern> lies! who else would I have in mind? my employer?
16:29:40 * gwern snickers
16:31:39 <krey> hello
16:32:11 <krey> can anybody help me with cyclic structures?
16:34:05 <zygoloid> aavogt: (.) <$> u <*> v <*> w == u <*> (v <*> w)
16:34:36 <Axman6> krey: what's your question?
16:35:05 <krey> iterate f x = xs   where xs = x : map f xs
16:35:07 <_jef> SamB_XP:  Just want to say thanks. ghc-pkg unregister mtl, then able to ./configure and make haskell-platform (at least further...)
16:35:40 <Cale> krey: What do you need?
16:35:47 <krey> according to my book, this is a cyclic expression
16:35:55 <Axman6> it is
16:35:57 <Cale> krey: yeah, xs is used in the definition of xs
16:35:57 <krey> and can be reduced more efficiently
16:35:58 <Axman6> xs = ... xs
16:36:15 <krey> than iterate f x = x : map f (iterate f x)
16:36:23 <Cale> Constants will never be recomputed as long as they remain in scope.
16:36:26 <krey> and I can't seem to understand why
16:36:48 <Cale> Okay
16:37:01 <Cale> The best way to see this is by doing some stepwise evaluation.
16:37:24 <Axman6> > let itr f x = x : map f (itr f x) in itr f x
16:37:25 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
16:37:30 <Cale> let's use  iterate succ 0  as an example, and try evaluating, say, the first two elements of each
16:37:47 <Cale> (I think the issue ought to appear by the second element, anyway
16:37:49 <zygoloid> krey: because xs = iterate f x
16:37:49 <Cale> )
16:38:14 <Cale> So, with the second one, we have:
16:38:18 <Cale> iterate succ 0
16:38:29 <ddarius> :t fix ((x:) . map f)
16:38:29 <Cale> -> 0 : map succ (iterate succ 0)
16:38:30 <lambdabot> [Expr]
16:38:33 <ddarius> > fix ((x:) . map f)
16:38:34 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
16:38:41 <Cale> -> 0 : map succ (0 : map succ (iterate succ 0))
16:38:58 <Cale> -> 0 : succ 0 : map succ (map succ (iterate succ 0)))
16:39:29 <Cale> and then we can evaluate the succ 0, (we'll pretend we're printing the list, so we want to evaluate each of the elements)
16:39:42 <Cale> -> 0 : 1 : map succ (map succ (iterate succ 0))
16:39:56 <Cale> -> 0 : 1 : map succ (map succ (0 : map succ (iterate succ 0)))
16:40:10 <Cale> -> 0 : 1 : map succ (succ 0 : map succ (map succ (iterate succ 0)))
16:40:11 <zygoloid> krey: you have "iterate f x = xs where xs = x : map f (iterate f x)". you know that "iterate f x = xs", so "xs = x : map f xs".
16:40:28 <Cale> -> 0 : 1 : succ (succ 0) : map succ (map succ (map succ (iterate succ 0)))
16:40:45 <Cale> So now we have to evaluate succ (succ 0)
16:40:53 <Cale> and not just succ 1
16:40:58 <chrisdone> I feel so safe with haskell
16:41:06 <Cale> So we're starting over from the beginning each time, essentially.
16:41:17 <Cale> Make sense?
16:41:26 <Cale> Let's try using the other definition now
16:41:27 <krey> loading...
16:41:40 <zygoloid> chrisdone: Haskell won't cheat on you, won't lie to you and won't dry out your skin like other languages can
16:41:48 <Cale> Well, I'll give you some time to look over that list of reductions and check it
16:41:56 <krey> k
16:42:02 <chrisdone> zygoloid: I believe it
16:42:45 <Cale> I'm leaving things in a sugary form, rather than explicitly blasting out the case expressions for the maps.
16:43:03 <Cale> So we evaluate the outermost function that's ready to pattern match.
16:44:37 <Cale> Oh, and to add insult to injury, not only do we end up evaluating things like succ (succ (succ ... (succ 0) ...))
16:45:10 <Cale> We also have a nested series of applications of map which gets longer and longer
16:45:14 <krey> yes
16:45:25 <krey> i understand the reduction
16:45:54 <Cale> and so eventually, we can expect that there will be a stack overflow, when the stack of things waiting to pattern match gets too large
16:46:10 <krey> well
16:46:16 <krey> oh
16:46:18 <krey> yes
16:46:24 <Axman6> > let itr f x = x : map f (itr f x) in itr f x !! 10000
16:46:27 <lambdabot>   mueval-core: Time limit exceeded
16:46:30 <Axman6> > let itr f x = x : map f (itr f x) in itr f x !! 100
16:46:31 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
16:46:35 <Axman6> > let itr f x = x : map f (itr f x) in itr f x !! 1000
16:46:36 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
16:46:38 <Cale> (at least, in GHC's implementation, without optimisations turned on)
16:46:39 <Axman6> > let itr f x = x : map f (itr f x) in itr f x !! 5000
16:46:41 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
16:47:00 <Cale> Okay, so now we'll take  iterate f x = let xs = x : map f xs in xs
16:47:16 <Cale> iterate succ 0
16:47:27 <Cale> -> let xs = 0 : map succ xs in xs
16:48:02 <chrisdone> zygoloid: haskell is (1) never gonna give you up, (2) never gonna let you down
16:48:26 <blackdog> chrisdone: GC bug?
16:48:30 <Cale> hmm, this graph reduction is a little hard to show in plain expression form
16:48:39 <krey> i tried doing this
16:48:51 <pikhq> Cale: Could try showing the actual graph.
16:48:54 <Cale> Maybe I should draw this
16:48:55 <krey> and got a result equivalent to the previous one
16:49:07 <krey> i have a drawing in my book
16:49:11 <Cale> krey: It's equivalent, but more efficient.
16:49:12 <krey> and it makes nooo sense
16:50:20 <zygoloid> where's mmorrow's vacuum -> dot graph jobber?
16:51:15 * gwern agrees with benjamin russell to scan _Metamagical Themas_ in exchange for him buying me a Gene Wolfe book
16:51:22 <gwern> I do like my Gene Wolfe
16:52:11 <Cale> zygoloid: I don't think vacuum will help here
16:52:39 <zygoloid> Cale: iterate succ 0 :: [Natural] ?
16:55:51 <zygoloid> when will the next version of the platform ship?
16:56:26 <Cale> zygoloid: [Integer], I was assuming
16:56:39 <zygoloid> yeah, that wouldn't be helpful :)
16:58:13 <olsner> Q: when ...? A: [Integer]
17:00:03 <krey> soo
17:00:17 <krey> how can I understand this?
17:00:31 <krey> is there something trivial I'm forgetting about?
17:00:41 <zygoloid> olsner: yeah, that wouldn't be helpful :)
17:01:12 <Cale> http://cale.yi.org/share/iterateSucc0.png
17:01:45 <Cale> It's not really trivial, but quite subtle
17:02:31 <Cale> Curves join the bottom of each function to the top of its arguments in that picture
17:02:46 <Cale> It's important to understand that expressions at runtime are not just trees, but graphs.
17:03:08 <chrisdone> haha, it makes me laugh how easily I can just move Haskell code about that I wrote a year ago and have it work perfectly as expected
17:03:20 * chrisdone works with c# all day and forgets how fun programming can be
17:05:24 <Cale> krey: But the important thing to notice is that the 2-element in the list starts its life there as succ 1, as its expression shares structure with the previous element, and we already evaluated that
17:05:31 <blackdog> chrisdone: one of the guys I know from ruby meetups keeps trying to convince me that using C# is almost like functional programming (or at least, it's not a horrible experience doing it that way)
17:06:59 <krey> --getting paper, start drawing
17:07:00 <Cale> krey: and as the list gets evaluated, this succ * : (map succ *) doodad will walk its way down, and so long as we evaluate the elements of the list as we go, we never build up large succ (succ (... (succ 0) ...)) things, or nested sequences of map
17:07:09 <osaunders> blackdog: Did you tell him you're a Haskell programmer?
17:07:29 <osaunders> (Assuming you are).
17:07:40 <Axman6> "The gold standard of functional programming"
17:07:52 <Axman6> languages*
17:08:09 <osaunders> "The ne plus ultra of purely functional programming"
17:08:15 <osaunders> "The paragon of purity"
17:08:32 <chrisdone> "puts the funk in function"
17:08:33 <osaunders> "The language that eats curry for breakfast"
17:08:50 <danderson> "The language that curries breakfast for eating"
17:09:09 <osaunders> danderson: Better.
17:09:11 <Axman6> and eats it!
17:09:15 <osaunders> Yes!
17:10:38 <krey> --it appears i am out of paper, understanding graphs delayed until paper found
17:12:00 <blackdog> osaunders: that's why he's trying to convince me:) i keep giving talks at the ruby group telling them how good static typing is
17:12:35 <Alpounet> blackdog, I have been trying to convince a rubyist too heh...
17:12:50 <blackdog> Alpounet: i have a gateway drug if you need it...
17:13:03 <osaunders> I used to be a Rubyist.
17:13:17 <chrisdone> it amuses me how matt always talks about how great haskell is
17:13:35 <Axman6> matt?
17:13:36 <chrisdone> he likes purity, he likes static types with inference, he likes stm
17:13:40 <ddarius> blackdog: C# is possibly the nicest "mainstream" language out currently.
17:13:41 <chrisdone> matz
17:13:48 <Axman6> ah
17:13:49 <Alpounet> blackdog, haha
17:13:49 <Cale> krey: I used inkscape to draw my graphs there. It's a little nice to be able to copy/paste, though not ideal.
17:13:58 <chrisdone> "but, you know, I just gotta write my own language that's cutesy and not challenging"
17:14:21 <Axman6> and painfully slow
17:15:06 <blackdog> chrisdone: some ace marketing on that bad boy, though.
17:16:22 <chrisdone> my favourite part is:
17:16:23 <chrisdone>       end
17:16:23 <chrisdone>     end
17:16:23 <chrisdone>   end
17:16:26 <chrisdone> end
17:16:40 <Axman6> not:
17:16:45 <Axman6>         }
17:16:47 <Axman6>       }
17:16:49 <Axman6>     }
17:16:51 <Axman6>   }
17:16:53 <gwern> chrisdone: reminds me of the old )))))) jokes
17:16:54 <Axman6> ?
17:17:21 <blackdog> chrisdone: yeah, it does awful things to your linecount. HAML is interesting that way, though - meaningful indentation etc.
17:17:33 <chrisdone> gwern: it's funny because people complain about lisp's )))) but not about end end end
17:17:48 <blackdog> at least you can write )))) on one line
17:17:58 <zygoloid> the old "I have found the source code to <something huge>, and it turns out it's written in lisp. As proof here's the last line: )))))))))))))))))))))))))))))))))))))))))"
17:18:01 <zygoloid> ?
17:18:43 <benmachine> chrisdone: I think it's not the difference between two types of delimiter but just a general impression that lisp uses more of them
17:19:13 <codolio> Typically, it does.
17:19:47 * benmachine is suddenly tempted to /nick cobenmachine
17:20:12 <Cale> http://cale.yi.org/share/iterateSucc0.png -- added the definition of iterate in the same vein
17:20:51 <Cale> Actually, it might be better to represent application explicitly, because my definition of map doesn't quite show all the sharing
17:21:11 <Cale> (those two f's on the right are really the same f)
17:21:19 <chrisdone> benmachine: well, I see a lot of jokes about "))))))))" as if it's a meaningless syntactic novelty
17:22:14 <chrisdone> http://github.com/rails/rails/blob/master/activerecord/lib/active_record/aggregations.rb#L253
17:23:02 <dolio> I remember seeing some critique of scheme on a java website a year or two back where they laid out their parens as if they were Java brackets.
17:23:05 <dolio> It was pretty amusing.
17:23:09 <gwern> I wonder what would've happened if lisp had early on gotten a tab-based syntax
17:23:47 <Cale> Or if they'd stuck to the plan of using M-expressions
17:23:51 <chrisdone> I think parens are easier to edit
17:24:03 <Cale> Well, we know what that looks like, it looks like mathematica.
17:24:30 <chrisdone> I spend lots more time fudgin haskell code layout than I did lisp (of which I did barely any)
17:25:06 <dolio> That's because lisp looks terrible no matter how much fudging you do. :)
17:25:17 <gwern> @quote oatmeal
17:25:17 <lambdabot> No quotes match. Where did you learn to type?
17:26:03 * osaunders agrees with dolio
17:26:19 <theorbtwo> The problem with lisp isn't that it uses a bad way of forming bracketing constructs, but that all of it's bracketing constructs look the same.
17:26:20 <chrisdone> well, I thought that about Haskell code when I first started using it
17:26:22 <osaunders> You get used to it though.
17:26:41 <osaunders> I think there's an actual physical change in your brain that happens after a while to make that shit easier to read.
17:26:51 <theorbtwo> dolio: I find that's far more true of haskell then lisp, and I don't much care for either.
17:27:04 <chrisdone> I had to get used to Haskell's messy operators and awkward layout and hand editing, and stop missing Lisp's elegant consistency and simple paredit editing
17:27:47 <Lycurgus> wasn't one of the original goals supposed to be that it would read like mathematics?
17:28:08 <Axman6> of haskell?
17:28:12 <Lycurgus> y
17:29:18 <osaunders> Is "where" and "let" from lambda calc?
17:29:26 <chrisdone> no
17:29:30 <dolio> where is from ISWIM.
17:29:31 <chrisdone> just general maths
17:29:37 <alex404> chrisdone: Do you really find it that bad? I've got a haskell package for vim, and I find it pretty hands free.
17:29:42 <theorbtwo> It's more that reading like formal mathematics is a goal of both haskell and mathematica.
17:29:46 <alex404> chrisdone: re indentation
17:30:29 <theorbtwo> That said, I don't find haskell's function syntax very mathematical, and it's largely functions.  Hell, it says so right in the name of the paradigm.
17:30:53 <Axman6> not mathematical? o.O
17:31:22 <chrisdone> alex404: well, let's say a line doesn't fit on my screen, so I move it to the next line. I have to tell it where it should be positioned by hitting tab. if I remove a parent node of the syntactic tree, I have to think about what to reindent it to. in lisp I just hit tab, the parentheses tell the editor where it should go
17:31:56 <theorbtwo> Axman6: I'm used to mutliargument functions being written with commas, and with parens around the argument list, normally.
17:32:19 <Axman6> that's just an uncurried function :)
17:32:21 <theorbtwo> This may well be because I approach mathmatics from a programming background, rather then vice-versa.
17:32:35 <alex404> chrisdone: Fair enough. I guess I just enjoy the language enough otherwise that I suck up having to wrestle with that from time to time.
17:33:19 <alex404> chrisdone: Seems like a lesser of evils approach to me, I Guess.
17:33:27 <chrisdone> alex404: so do I. I've got used to it now. but I'm just saying Lisp is easier to edit
17:34:32 <chrisdone> alex404: and I can't standThisNotation and yet I love this-notation =)
17:34:47 <theorbtwo> The thing is, the lack of parens as argument seperators leads to a proliferation of parens elsewhere, or strange things to get rid of them.
17:34:47 <alex404> alex404: Hands down agree with you there.
17:34:57 <chrisdone> alex404: you're insane!
17:35:11 <chrisdone> :p
17:35:14 <theorbtwo> chrisdone: dashes and prime marks as part of varaible names give me the heebiegeebies a little.
17:35:16 <alex404> ;)
17:35:31 <theorbtwo> camelCase or underscore_seperated are both OK with me.
17:35:31 <alex404> chrisdone: I find camel back hideous but effecetive
17:36:31 <chrisdone> I just don't like typing it. get tired of typing shift
17:36:38 <alex404> I guess the parens vs whitespace thing comes down a lot to editability vs readability
17:37:01 <alex404> And in the long run, readability is worth the effort
17:37:23 <blackdog> i still wish haskell style wasn't to use camelcase. it does awful things to acronyms
17:37:25 <chrisdone> I've spent more than a year with each language and they are both readable to me
17:37:47 <theorbtwo> Ah, yes.  XMLHttpRequest, anybody?
17:37:57 <blackdog> urgh. same in objective C
17:38:00 <alex404> Heh.
17:38:05 <chrisdone> xml-http-request
17:38:06 <blackdog> ASIHTTPRequest no thank you sir
17:38:09 <chrisdone> lisp wins again
17:38:32 <theorbtwo> Most languages, really, or at least most old-school languages.
17:38:35 <blackdog> has anyone here had a serious look at QI?
17:38:48 <ddarius> XmlHttpRequest
17:38:54 <chrisdone> I haven't tried it. it's on my list
17:38:56 <blackdog> I'd actually be pretty keen on a language with s-exp syntax and haskell semantics
17:39:01 <ddarius> This is the same style C# uses.
17:39:04 <blackdog> keep meaning to try liskell
17:39:22 <theorbtwo> I'm actually rather surprised that C started a convention of case-sensitive identifiers, because at the time machines that only had uppercase weren't uncommon.
17:39:27 <ddarius> blackdog: I imagine the identifier rules are the same for Liskell.
17:39:53 <theorbtwo> ddarius: The big problem with XMLHttpRequest is that javascript has case-sensitive identifiers, and it's standardized with the "wrong" caps.
17:39:57 <ddarius> @google XmlHttpRequest
17:39:58 <lambdabot> http://en.wikipedia.org/wiki/XMLHttpRequest
17:39:58 <lambdabot> Title: XMLHttpRequest - Wikipedia, the free encyclopedia
17:39:59 <chrisdone> blackdog: Qi doesn't have haskell semantics. I tried Liskell and it was OK, but it's suffering from bitrot IIRC
17:40:28 <ddarius> theorbtwo: Why do I care what Java does?
17:40:33 <ddarius> er JavaScript
17:40:34 * hackagebot highlighting-kate 0.2.6.2 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.6.2 (JohnMacFarlane)
17:40:47 <theorbtwo> ddarius: Because I'm attempting to illustrate a problem?
17:40:53 <mmmulani> is cabal working on 10.6?
17:41:42 <blackdog> chrisdone: no, but it's doing something interesting with types, which seems a bit unusual in the lisp world
17:41:56 <chrisdone> sure
17:42:21 <chrisdone> one nice thing about it is that it's a thin layer ontop of Common Lisp, and it can talk to CL
17:42:29 <ddarius> Find some unicode character that looks like a hyphen but is (somehow) in the alphanumeric category.
17:42:42 <Axman6> mmmulani: 10.6 of wgat?
17:42:46 <Axman6> what*
17:42:53 <mmmulani> Mac OS X
17:42:57 <Axman6> yes
17:43:00 <theorbtwo> The japanese character for one probably works.
17:43:20 <mmmulani> hmm, I'm getting an error with libgmp
17:43:38 <mmmulani> http://pastebin.com/HQcHPdAu
17:43:38 <ddarius> > let x一y = 3 in True
17:43:39 <lambdabot>   True
17:43:44 <Axman6> got gmp installed?
17:43:48 <mmmulani> yup
17:43:49 <ddarius> > let x一y = x in True
17:43:50 <lambdabot>   True
17:44:16 <ddarius> > let x一y = (x,y) in x一y
17:44:17 <lambdabot>   (x,y)
17:44:23 <ddarius> theorbtwo: Works.
17:44:30 <chrisdone> > let xml一http一request = "yay" in xml一http一request
17:44:31 <lambdabot>   "yay"
17:46:35 <chrisdone> blackdog: Zhivago in #lisp has used Qi for some project(s). if you hang out there
17:48:14 <blackdog> now you just need to map a key in and you're golden, especially if you like confusing people:)
17:54:57 <twink> I'm trying to remember if that's the same guy who got sbcl booting on the bare metal.
18:20:59 <Axman6> > 2^128
18:21:00 <lambdabot>   340282366920938463463374607431768211456
18:21:25 <copumpkin> enough values for you?
18:28:56 <Axman6> enough IP's, yes
18:30:35 <Axman6> > logBase 10 (2^128)
18:30:36 <lambdabot>   38.531839444989586
18:33:09 <Axman6> > let f n = n / (logBase 10 n) in f (2^128)
18:33:10 <lambdabot>   8.831199647417467e36
18:33:20 <Axman6> > let f n = n / (logBase 10 n) in f (2^128) :: CReal
18:33:21 <lambdabot>   8831199647417464989640704080462315226.4015409164000999983046425736914730024...
18:35:04 <copumpkin> what is that telling you?
18:37:12 <Axman6> nothing
18:51:20 <pastorn> shit
18:51:35 <pastorn> working with first, second, curry and uncurry is like...
18:51:42 <pastorn> being i kung-fu master
18:52:01 <pastorn> you're doing crazy shit, and no mortal has a shot at seing what's going on
18:53:52 <copumpkin> lol
18:54:20 <pastorn> especially when doing it points free
18:55:26 <twink> I've got more @pl than Steve Jobs.
19:16:22 <badkins> I've been building ghc via macports on OSX 10.5.8 for quite a while. It seems to be spawning about 200 processes per second which seems odd to me.
19:17:30 <badkins> Anyone else experienced something like that?
19:17:52 <copumpkin> ugh, macports ghc ftl
19:18:03 <badkins> apparently
19:18:18 <copumpkin> why not http://www.haskell.org/ghc/download_ghc_6_12_1.html#macosxintel ?
19:18:24 <copumpkin> it takes forever to build anyway
19:18:37 <copumpkin> I wonder how many megawatts of electricity macports + gentoo have wasted
19:18:45 <copumpkin> megawatt hours
19:18:47 <badkins> the time wasn't too much of a concern until I noticed the process ids spinning up so rapidly.
19:19:27 <badkins> copumpkin: regarding your question, no particular reason
19:19:35 <badkins> although 6.12 seems a bit bleeding edge
19:19:54 <copumpkin> @where platform
19:19:54 <lambdabot> http://hackage.haskell.org/platform/
19:19:57 <badkins> but it's not like this is for "production" - just learning
19:19:58 <dolio> ddarius:  With regard to the parametricity stuff I mentioned yesterday, I think I have sort of an example where standard dependent typing practice and a Haskell encoding can have meaningfully different properties: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23293
19:20:06 <copumpkin> grab that then
19:20:14 <badkins> I plan on installing the platform, but I need ghc first I thought
19:20:23 <copumpkin> the platform comes with ghc
19:20:46 <badkins> so it's a precompiled binary?
19:20:53 <copumpkin> yep
19:20:58 <badkins> rats
19:21:08 <copumpkin> why?
19:21:19 <badkins> because it appears I've been wasting my time building ghc
19:21:23 <copumpkin> :)
19:22:00 <badkins> copumpkin: well, thanks for the advice, I'll give the platform a shot
19:22:08 <copumpkin> cool
19:22:27 <copumpkin> dolio: I don't understand what natural and unnatural are showing
19:23:03 <dolio> copumpkin: natural is a natural transformation, unnatural is not.
19:23:10 <copumpkin> oh
19:23:11 <dolio> In agda, they have the same type.
19:23:17 <copumpkin> yeah
19:23:33 <dolio> In Haskell, natural can be given a type whose naturality is guaranteed by parametricity.
19:23:40 <copumpkin> yeah, hmm
19:24:52 <dolio> And presumably, in something like an erasure pure type system, you could have agda-like code that still has typed distinctions between natural an unnatural.
19:25:19 <dolio> Because that's what EPTSes are all about, essentially.
19:25:49 <dolio> One thing they do is allow you to erase stuff, but the erasure corresponds to parametricity, I think.
19:25:57 <copumpkin> hmm
19:26:00 <adu> WTF is unnatural?
19:26:38 <krey> Cale: took me a while, but http://omploader.org/vM3I5cw
19:27:12 <copumpkin> I don't even understand how it typechecks
19:27:26 <pastorn> @djinn ([a],[b]) -> [(a,b)]
19:27:27 <lambdabot> Error: Undefined type []
19:27:49 <copumpkin> :t uncurry zip
19:27:50 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
19:27:58 <pastorn> that simple?
19:28:02 <pastorn> damn...
19:28:12 <copumpkin> :)
19:29:13 <aavogt> @type Data.Traversable.toList
19:29:14 <lambdabot> Not in scope: `Data.Traversable.toList'
19:29:21 <aavogt> @type Data.Foldable.toList
19:29:22 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
19:29:31 <sfuentes> anyone know how i can go about downloading a binary file through http with haskell?
19:29:49 <krey> reduction trees anyone?
19:29:54 <sfuentes> is there a module that supports this
19:29:54 <aavogt> sfuentes: did you try using Network?
19:30:25 <copumpkin> dolio: El (list a) => List (El a), so how do you get a Nat out of pattern matching on an element in there?
19:30:29 <aavogt> it can get you a handle whose contents you can get in a binary mode
19:31:02 <sfuentes> aavogt: i didn't find anything using http in the haskell platform release
19:31:04 <dolio> We're talking about unnatural in agda?
19:31:08 <copumpkin> dolio: yep
19:31:19 <copumpkin> build is Nat -> Tree Nat
19:31:35 <sfuentes> perhaps i need to find an extra module somewhere. still new to this haskell language
19:31:36 <dolio> copumpkin: I matched against a in that case. a = nat.
19:31:43 <copumpkin> oh!
19:31:44 <copumpkin> duh
19:31:49 <dolio> So El (list nat) = List (El nat) = List Nat.
19:31:51 <aavogt> sfuentes: no, the haskell platform includes network
19:31:54 <copumpkin> yeah, makes sense
19:31:58 <dolio> And same for tree.
19:32:19 <copumpkin> yeah, I was reading that as haskell and saw the lowercase and thought it was a bound variable
19:32:22 <copumpkin> not a constructor
19:32:42 <copumpkin> makes sense now
19:33:10 <aavogt> sfuentes: basically look here: http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/Network.html#v%3AconnectTo and also in System.IO where operations on Handle are defined
19:33:19 <copumpkin> you still get parametricity if you aren't fooling around in a "custom universe", don't you?
19:33:21 <copumpkin> (in agda)
19:35:02 <sfuentes> aavogt: yes network is in the platform, but nothing http specific
19:35:12 <dolio> Yeah, I think so. Since there's no type case.
19:35:30 <copumpkin> so you're effectively reifying types to data constructors and getting typecase that way
19:35:40 <copumpkin> it's pretty neat that you can do it in haskell too
19:36:11 <dolio> That was the point of my constructing the example. To show how you might want parametricity that you couldn't get using the standard dependent type way.
19:36:21 <krey> can anyone help me with reduction trees?
19:36:34 <copumpkin> I see, sorry for being slow :)
19:36:36 <aavogt> @hackage curl -- sfuentes
19:36:36 <lambdabot> http://hackage.haskell.org/package/curl -- sfuentes
19:36:51 <alex404> How do you carry an ini/conf style file along with a cabal package?
19:36:58 <dolio> Because if you only look at Set and stuff like that, it still seems like parametricity holds.
19:37:39 <SamB_XP> Arg, I'm beginning to hate exception 0xC0000005 !
19:37:48 <copumpkin> sure sounds like haskell
19:38:13 <SamB_XP> notepad++ crashed again
19:38:39 <SamB_XP> that's the Windows equivalent of Signal 11 on linux or DJGPP...
19:38:42 <aavogt> notepad++--
19:38:54 <SamB_XP> @karma notepad++
19:38:54 <lambdabot> notepad++ has a karma of -1
19:38:59 <SamB_XP> w00t
19:39:14 <aavogt> @karma --
19:39:15 <lambdabot> -- has a karma of -58
19:39:21 <copumpkin> wow, haven't seen "djgpp" in a looong time
19:40:13 <copumpkin> erikc: good point
19:40:19 <copumpkin> ;)
19:40:58 <pikhq> DJGPP is still around, though.
19:41:10 <pikhq> Quite a nice port of GCC.
19:41:36 <copumpkin> yep, I just remember it from my first attempts at fooling around on a computer
19:41:51 <pikhq> Huh. It was last updated in *2002*.
19:42:03 <SamB_XP> pikhq: so ?
19:42:07 <pikhq> Well, not surprising. There's really not much to do with it any more.
19:42:26 <SamB_XP> the main thing they might do would be to update the software to newer versions
19:42:27 <pikhq> Other than having an older version of GCC, it's kinda... Complete.
19:42:34 <SamB_XP> but that probably wouldn't be so helpful anyway
19:42:40 <pikhq> Oh, wait, that's not an issue.
19:42:50 <copumpkin> "Please note that my legal first name really is "DJ". It is not correct to insert a space between the D and the J, or to put periods after them as if they were initials, or to make either of them lower case. They are not initials, and I have no middle name. Honest."
19:43:47 <pikhq> http://en.wikipedia.org/wiki/File:GCC_DJGPP_Windows.png This seems to suggest modern GCC works just fine on it.
19:44:43 <pikhq> (presumably it's just a supported target of GCC?)
19:47:21 <SamB_XP> pikhq: er, I would have guessed it just meant that the latest GCC still built okay on it
19:47:58 <SamB_XP> personally, I would like a less segfaulty package manager than pakke is ...
19:48:22 <SamB_XP> ... also more capable of fetching packages on, say, Linux systems
19:48:34 <SamB_XP> (running DOSEMU)
19:49:51 <pikhq> SamB_XP: GCC still needs to support the target.
19:50:00 <SamB_XP> well, yeah
19:50:12 <SamB_XP> but that doesn't take much
19:50:20 <pikhq> Admittedly, there's not much work to *supporting* i386-djgpp.
19:50:43 <pikhq> crt1.o, not breaking calling convention, and... Yeah.
19:50:44 <SamB_XP> GDB still wants to support it, too, but it's a bit of work to check :-(
19:51:20 <SamB_XP> I think I tried to get it to build but ran into some kind of trouble related to 8.3 ...
19:52:20 <SamB_XP> ... it might have been something wierd like it won't build on DJGPP if you extract to LFN ...
19:54:22 <SamB_XP> oh, wait, no
19:54:25 <SamB_XP> it wasn't that
19:54:52 <SamB_XP> something just seemed to get stuck somewhere in the process of running make :-(
19:55:03 <jcreigh> whoa, does DJGPP still exist?
19:55:10 <SamB_XP> jcreigh: why would it not?
19:55:22 <jcreigh> I mean, is it still being regularly updated?
19:55:25 <SamB_XP> would DJ's website just disappear?
19:55:30 <SamB_XP> jcreigh: there's not much point1
19:55:35 <SamB_XP> s/1/!/
19:55:40 <SamB_XP> DOS doesn't change much
19:55:55 <jcreigh> true
19:55:59 <jcreigh> I suppose there's still FreeDOS
19:57:33 <SamB_XP> they don't generally do things that DJGPP would need to do anything *about*
19:58:04 <jcreigh> yeah
19:58:13 <jcreigh> I was just surprised to see the name, that's all.
19:58:15 <jcreigh> blast from the past.
19:58:32 <jcreigh> man, I wish I had a proper compiled when I was learning to program, instead of just QBASIC.
20:02:25 <ezyang> Am I a bad person if I use unsafePerformIO to do print statements for debugging?
20:03:04 <MaciejP> Can you create custom compile errors?
20:04:14 <Cale> ezyang: You could just use Debug.Trace
20:05:00 <ezyang> ooh, clever
20:05:26 <ezyang> although essentially the same thing :-)
20:05:51 <Cale> ezyang: I find it a bit rare to need to use it, but it can be handy if you want to get real parameters to your function.
20:06:29 <ezyang> Well, that's the thing; I sort of feel like FP and pure code should give us different, better debugging techniques
20:06:38 <ezyang> I just haven't figured them out :^)
20:06:38 <Cale> (Usually, I'll get some parameters on which the function is behaving strangely, and then switch to just plain GHCi.)
20:07:27 <Cale> The nice thing about referential transparency is that the parameters to a function completely determine its result, so things will work the same way in isolation as they do when you put the program together.
20:08:08 * ezyang nods 
20:08:38 <pikhq> ezyang: The real way to debug is, of course, to draw out the graph and perform the reduction yourself.
20:08:44 <pikhq> ... Or be named Simon.
20:08:52 <ezyang> As long as I can find the misbehaving function, the debugging process isn't that bad
20:08:57 <aavogt> the ghci debugger seems to be quite unloved
20:09:13 <ezyang> Scheme has, unfortunately, left a bad taste in my mouth with regards to errors coming from no where you can easily tell
20:09:26 <leoncame1>  M
20:09:27 <leoncame1> M<
20:09:51 <jcreigh> ezyang: really? I never got into scheme much, but I can't think of any feature of Scheme that would make it worse than any other language. What did you run into in particular?
20:10:37 <ezyang> jcreigh: mit-scheme in particular, doesn't print backtraces if you do something stupid like (car '())
20:11:31 <pikhq> Backtraces are highly overrated. ... Oh, wait. Strict evaluation. *Never mind*.
20:12:36 <ezyang> Well, it doesn't even give you the code that threw the error!
20:12:59 <pikhq> *Vomit*.
20:13:12 <ezyang> "The object (), passed as the first argument to cdr, is not the correct type."
20:13:24 <ezyang> Great, now go guess which piece of code performed the cdr
20:13:38 <ezyang> before you can even start thinking about where the true error is
20:13:49 <leoncame1> <<
20:13:50 <leoncame1> \
20:14:06 <ezyang> Haskell... sort of has this problem with error "", but there are lots of workarounds :-)
20:14:08 <copumpkin> how many cdrs in your code?
20:14:11 <Cale> of course, we have the same problem with head and tail in Haskell, but people tend to stay away from those
20:14:14 <ezyang> "a lot"
20:14:22 <copumpkin> ah, that's "a lot"
20:14:23 <Cale> (for that very reason)
20:14:25 <aavogt> well you get that in haskell with stuff with all those partial functions in haskell
20:14:34 <copumpkin> but we don't use them
20:14:38 <copumpkin> cause we're cooler than that
20:14:40 <ezyang> precisement
20:14:53 * ezyang does happy dance because his blog made it on Planet Haskell 
20:15:03 <ezyang> unfortunately I haven't blogged about anything Haskelly in a week...
20:15:07 <jcreigh> "my other car is a cdr"
20:15:37 <aavogt> but how is it ok that failed pattern matches can give line numbers while those partial functions do not?
20:16:16 <ezyang> I think some people preprocess their code to give them line numbers?
20:16:25 <Cale> aavogt: Well, it's annoying, but this is why we tend to prefer writing total functions where possible.
20:16:35 <aavogt> would it actually be a performance hit if the compiler added an additional line number to functions that can call error?
20:18:11 <copumpkin> I doubt it
20:18:54 <aavogt> hmm, alex used in bytestring-csv seems to be asymptotically faster than the attoparsec code here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23284#a23285
20:19:18 <pikhq> aavogt: Few bytes of overhead in the object code?
20:19:46 <aavogt> with the filesize presented there, they are about the same, but for say a 7M csv file, they are 10x slower
20:20:15 <copumpkin> aavogt: weird, maybe tell bos?
20:20:39 <aavogt> with Atto2 doing a bit less work than the alex version
20:21:13 <alex404> Does anyone know how to get cabal to drop a .conf file into etc with an installation?
20:21:55 <aavogt> note that I've since changed the NFData instance for the lazy bytestring
20:24:46 <Saizan> aavogt: so it's no longer rnf xs = L.unpack xs `seq` () ?
20:25:07 <aavogt> Saizan: yeah, now it's L.length xs `seq` ()
20:26:25 <aavogt> but the code generated by alex is pretty fancy: it probably gets turned into one straight loop
20:26:42 <aavogt> and also the difference between strict and lazy bytestrings...
20:35:37 <Saizan> i wonder what happens if you use L.fromChunks . return instead of L.pack . S.unpack
20:40:08 <ddarius> What line number are you expecting a partial function to give?
20:40:50 <SamB_XP> ddarius: the line number(s) where I forgot to put the missing pattern(s)
20:40:53 <SamB_XP> duh!
20:52:33 <codemac> What do people use to browse haskell code?
20:52:43 <codemac> Similar to a cscope for haskell?
20:53:05 <ezyang> codemac: Haddock docs come with docs
20:53:12 <ezyang> *code
20:53:20 <ezyang> But they don't tend to be cross-linked
20:53:26 <ezyang> Hayoo and Hoogle may also be of interest
20:54:20 <codemac> No no, I mean, I want to jump around the code between references to different function etc.  I don't want to click around in haddock
20:54:35 <codemac> but I'll check out hayoo and hoogle
20:55:06 <ezyang> yeah, those are ~about what you're looking for
20:55:22 <ezyang> they're not perfect, but it'll get better when Hayoo starts updating its index more regularly
20:56:45 <codemac> hm ok
20:57:02 <codemac> I'm trying to learn and figure out how yi is written
20:57:17 <codemac> and hopping around code is a pain in the ass.
20:57:40 <codemac> All these tools are for standard libraries, not local code
20:57:43 <codemac> that's the difference I guess
20:57:50 <codemac> but these are great for other reasons lol
20:57:55 <Saizan> you can run cabal haddock --hyperlink-source
20:58:04 <Saizan> and hasktags
20:58:45 <codemac> ooh, hasktags
20:59:37 <Saizan> not 100% accurate, but it works
20:59:50 <codemac> yea, tags is a step up.
21:02:39 <kniu> @hoogle amap
21:02:40 <lambdabot> Data.Array.IArray amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
21:04:47 <ddarius> You could also check out Leksah.
21:11:01 <Jonno_FTW> what can I do about this error:
21:11:03 <Jonno_FTW> cabal: Missing dependency on a foreign library:
21:11:05 <Jonno_FTW> * Missing header file: fcgiapp.h
21:11:06 <Jonno_FTW> * Missing C library: fcgi
21:11:17 <Jonno_FTW> in trying to install fastcgi
21:11:21 <aksionov> Jonno_FTW: install fastcgi libs
21:11:50 <Jonno_FTW> no such package
21:11:58 <Jonno_FTW> oh
21:12:05 <aksionov> Jonno_FTW: the real fcgi package, not the haskell one..
21:12:12 <Jonno_FTW> yep
21:12:53 <aksionov> Jonno_FTW: if use arch gnu/linux, its provided by 'fcgi' package
21:13:02 <Jonno_FTW> i'm on windows
21:13:11 <Jonno_FTW> i got it from the fcgi website
21:17:15 <aksionov> okay
21:37:34 <_nickel> Functor f => [(a -> b)] -> f a -> f b   <-- does anyone know the name for this I can't find it using Hoogle and I'm not sure where else to look
21:37:37 <Jonno_FTW> this is getting stupid
21:38:01 <_nickel> although, looking at it
21:38:11 <tensorpudding> how would it work?
21:38:12 <_nickel> it doesn't make much sense
21:38:20 <Jonno_FTW> i compiled fcgi and used: cabal install fastcgi --extra-lib-dirs="C:\fcgi-2.4\include\" --extra-include-dirs="C:\fcgi-2.4.0\include"
21:38:21 <SamB_XP> _nickel: I was thinking the same
21:38:24 <scheibo> @hoogle fmap
21:38:24 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
21:38:24 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
21:38:24 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
21:38:26 <SamB_XP> what did you want one for ?
21:38:27 <Jonno_FTW> and it still won't work
21:38:43 <tensorpudding> @type fmap . head
21:38:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> f a -> f b
21:39:53 <_nickel> tensorpudding: that works but I was hoping it would apply a list of functions to the contents of the functor (terminology?)
21:40:02 <tensorpudding> so
21:40:15 <tensorpudding> something like [a -> b] -> f a -> [f b]
21:40:17 <tensorpudding> ?
21:41:47 <_nickel> tensorpudding: hmm I was in the process of responding with [ a -> a ] -> f a -> f a but then it need not be a functor I guess
21:41:58 <tensorpudding> hmm
21:42:10 <tensorpudding> so you want to apply each of the (a -> a) in turn?
21:42:15 <_nickel> tensorpudding: exactly :D
21:42:32 <_nickel> tensorpudding: do I need a different typeclass?
21:42:36 <tensorpudding> @type fmap (foldr (.) id)
21:42:37 <lambdabot> forall b (f :: * -> *). (Functor f) => f [b -> b] -> f (b -> b)
21:42:44 <tensorpudding> err
21:43:00 <tensorpudding> @type fmap . foldr (.) id
21:43:01 <lambdabot> forall a (f :: * -> *). (Functor f) => [a -> a] -> f a -> f a
21:43:08 <_nickel> tensorpudding: thar she blows!
21:43:30 <_nickel> tensorpudding: I thought something like that would be included with Functor but I couldn't find it
21:43:49 <Saizan> _nickel: it's orthogonal
21:43:53 <tensorpudding> also
21:43:59 <Saizan> ?type foldr (.) id
21:44:00 <lambdabot> forall b. [b -> b] -> b -> b
21:44:44 <Saizan> you make an (a -> a) by chaining the functions in your [a -> a], and then you use Functor's method to apply it inside your f a
21:45:28 <tensorpudding> there are other ways to do it
21:45:37 <dark> ?type (1, "a")
21:45:38 <lambdabot> forall t. (Num t) => (t, [Char])
21:45:41 <tensorpudding> you could make the whole thing a fold
21:45:51 <_nickel> Saizan: what do you mean by orthogonal in this context ? so I can learn
21:46:35 <tensorpudding> @type foldr fmap id
21:46:36 <lambdabot> forall b. [b -> b] -> b -> b
21:46:41 <tensorpudding> err, wait
21:46:54 <tensorpudding> @type foldr fmap
21:46:55 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
21:47:05 <tensorpudding> same thing, arguments flipped
21:47:24 <_nickel> tensorpudding: very nice
21:47:26 <dark> why does haskell uses forall x. <expr with x>, instead of ml's 'x? (a reason in special?), this seems to add complexity
21:47:38 <Saizan> _nickel: that the idea of chaining functions in a list is not limited nor requires the idea of Functor
21:48:20 <_nickel> Saizan: yes! thats what i mean by " but then it need not be a functor I guess", thank you for clarifying though
21:48:22 <Saizan> dark: with higher-rank types the position of the forall matters
21:49:26 <Saizan> in fact, forall is not used in haskell98, where you can't have them
21:49:45 <Saizan> but lambdabot has the extensions turned on
21:50:34 <Saizan> tensorpudding: the difference there is that you do O(n) traversals of the functor
21:50:43 <Cale> dark: You can omit the explicit quantifier, and type variables will automatically be forall-bound at the top level of each signature just like in ML, but sometimes it's useful if you want to move the bindings inward for higher-rank polymorphism and other extensions
21:51:00 <Cale> dark: For example, suppose you want to write a function that requires a polymorphic function as its parameter.
21:51:10 <Cale> :t runST
21:51:11 <lambdabot> forall a. (forall s. ST s a) -> a
21:51:29 <Cale> The parameter to runST is required to be completely polymorphic in the type s
21:52:04 <Cale> and since it is bound earlier, the type a, whatever it is, cannot involve s in any way.
21:53:09 <Cale> This is a trick used to ensure that any one STRef can't be used across multiple calls to runST, which would break referential transparency. Instead, they must be used within the computation that created them.
21:57:34 <dark> ST?
21:58:03 <dark> hmm so the type system of haskell is strictly more powerful than ocaml's?
21:58:24 <dark> for some reason i was thinking they were equivalent
21:58:48 <Niccus> well, is ocaml's type system turing-complete?
21:58:56 <dark> lol
21:59:14 <Saizan> well, in haskell you can omit the forall quantifier if it's at the start of the type
21:59:15 <dark> but isn't this a bad thing?
21:59:20 <Saizan> so maybe it's the same in ocaml?
21:59:24 <blackdog> dark: http://www.cse.unsw.edu.au/~chak/papers/WC08.html
21:59:36 <Saizan> and you just didn't see it used?
22:00:17 <Saizan> the comparison between modules and typeclasses is almost at a different level :)
22:01:26 <Saizan> dark: haskell type system becomes turing complete only by turning on UndecidableInstances, unsurprising.
22:02:00 <dark> but this will means that the compiler may not terminate?
22:02:28 <tensorpudding> hmm, i just noticed that haskell platform's website references batteries also
22:03:34 <Saizan> dark: in principle yes, in practice there's a stack limit
22:04:27 <tensorpudding> that can't be a coincidence
22:04:53 <Saizan> well, not really stack, but a recursion limit for the typeclass resolution mechanism
22:05:00 <Saizan> (since we're talking about GHC anyway)
22:06:43 <tensorpudding> but does ocaml's batteries included predate the haskell platform?
22:06:48 <tensorpudding> or vice-versa
22:06:58 <Saizan> yes, batteries came first
22:07:57 <SamB_XP> hmm, I think Python came with batteries before that ...
22:08:12 <Saizan> yeah, i think too
22:08:25 <tensorpudding> python comes with batteries too?
22:08:50 <tensorpudding> hmm, it's a popular phrase
22:08:53 <Saizan> it comes with a fairly comprehensive library, and i think they coined the term at some point
22:09:08 <Saizan> or well, started using it with this meaning
22:09:58 <Saizan> dark: what's the type of e.g. map in ocaml?
22:10:49 <tensorpudding> ('a -> 'b) -> 'a list -> 'b list = <fun>
22:11:56 <Saizan> i see
22:12:54 <tensorpudding> it's exactly the same as Haskell, modulo syntactic diffences
22:12:59 <Saizan> so ocaml has the forall quantifier too, though it seems it's not allowed everywhere: type r = { f : 'a . 'a -> 'a }
22:13:15 <Saizan> http://devmusings.legiasoft.com/blog/2008/05/23/higher-rank_polymorphism_in_ocaml <- from here
22:14:50 <tensorpudding> hmm
22:15:11 <tensorpudding> so that is a rank2 type?
22:16:19 <Saizan> well, forall a. a -> a by itself isn't
22:16:47 <tensorpudding> a bit mungy that they allow quantification in records but not elsewhere
22:16:49 <Cale> dark: Well, the forall syntax is defined by an extension to the language anyway (or a bunch of extensions really)
22:16:59 <Cale> dark: Haskell-as-standardised doesn't have it
22:17:29 <ezyang> "GHC is totally it's own language by now"
22:17:40 <copumpkin> -'
22:17:53 <Saizan> tensorpudding: a fold for that record would require an higher-rank type though
22:18:01 <ezyang> copumpkin: :-P
22:18:44 <Saizan> foldR :: ((forall a. a -> a) -> b) -> R -> b
22:19:50 <copumpkin> hmm
22:36:16 <ElMexicano>  It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  Wha
22:36:16 <ElMexicano>  t have the niggers in New Orleans done? If you are sick of this, join Chimpout Forum!  http://www.chimpout.com/forum  We welcome all races except for NIGGGGGGGERS!  We are not white supremacists, just negro inferiorists! http://www.chimpout.com/forum
22:36:57 <pikhq> ElMexicano: It was unintelligent in #esoteric, it remains unintelligent here.
22:37:18 <pikhq> Your uninformed and fallacious opinions have no place here.
22:40:24 <copumpkin> @where ops
22:40:24 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
22:40:38 * copumpkin still wishes this channel were +s
22:42:10 <tensorpudding> what's +s?
22:42:32 <ElMexicano>  It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  Wha
22:42:32 <ElMexicano>  t have the niggers in New Orleans done? If you are sick of this, join Chimpout Forum!  http://www.chimpout.com/forum  We welcome all races except for NIGGGGGGGERS!  We are not white supremacists, just negro inferiorists! http://www.chimpout.com/forum
22:42:36 <copumpkin> secret, doesn't show up in channel lists
22:42:46 <copumpkin> wow, I should apply for ops :)
22:42:59 <copumpkin> tensorpudding: these dudes clearly run a /list and sort by users
22:43:03 <copumpkin> and go to the top few and spam
22:43:04 <pikhq> ElMexicano: It continues to be unintelligent, uninformed, and banal.
22:43:09 <copumpkin> there's no reason for us to show up in /list
22:43:13 <pikhq> copumpkin: No, he was in #esoteric.
22:43:15 <pikhq> Which is... Tiny.
22:43:25 <copumpkin> well, they can also follow people around from /whois
22:43:28 <copumpkin> which +s covers too
22:43:30 <pikhq> Mmm.
22:43:53 <copumpkin> I can't believe none of those ops is around
22:44:15 <pikhq> ... And #japanese now.
22:44:28 --- mode: ChanServ set +o glguy
22:44:29 <tensorpudding> they're busy people
22:44:34 --- mode: glguy set +b *!*~ElMexica@201.160.235.225.cable.dyn.cableonline.com.*
22:44:37 --- mode: ChanServ set +o allbery_b
22:44:59 <copumpkin> :)
22:45:33 --- mode: glguy set +b *!*@201.160.235.225.cable.dyn.cableonline.com
22:45:49 --- kick: ElMexicano was kicked by allbery_b (ElMexicano)
22:46:02 --- mode: allbery_b set -o allbery_b
22:46:27 --- mode: glguy set -b *!*~ElMexica@201.160.235.225.cable.dyn.cableonline.com.*
22:46:35 --- mode: glguy set -o glguy
22:47:49 <allbery_b> not to mention that his kn owledge of history is about general-American-like in quality
22:48:38 <pikhq> Alas, so it is.
22:49:21 <Adamant> America is probably leading the trend, but the West is getting stupid about history in general
22:49:40 <pikhq> America most definitely more-so than other nations.
22:50:08 <Adamant> pikhq: arguable, I've seen some Brits with a shocking lack of knowledge about their own history
22:50:09 <pikhq> Here's American history in a nutshell: There were Indians. Whitey came. Fuck yeah, we're AMERICA!
22:50:29 <copumpkin> "Oh and by the way, STAY THE FUCK OUT IMMIGRANTS, IT'S OURS"
22:50:41 <Niccus> that's less exclusively american
22:50:50 <copumpkin> yeah, but more ironic in this particular case
22:50:57 <pikhq> We don't have a *lot* of history, and we don't care that much about foreign history... So we end up knowing hardly anything about history.
22:51:08 <Niccus> man you know poe's law is in effect; how do i tell if you're ironic D:
22:51:16 <copumpkin> I mean
22:51:21 <copumpkin> ironic for people to be saying that
22:51:25 <Adamant> um, what color is the sky on the history class on your planet
22:51:27 <copumpkin> when their grandparents were also immigrants
22:51:29 <pikhq> (well. There's a lot of interesting things in American history. However, there's only a few hundred years of written records.)
22:52:45 <Niccus> adamant: judging from the photos, gray
22:53:01 <allbery_b> American history in the little, insular, 100% white, 90+% Catholic town I grew up in was jaundiced, to say the least
22:53:05 <Adamant> I read US history books written in the 70's that spent about 1/4th of the time talking about various things that happens with the Indians, including basic records of What Actually Happened and not idealized history
22:53:28 <Adamant> and these were aimed at elementary school students
22:53:45 <twink> Adamant: Yep, it's been dumbed down a lot.
22:53:57 <pikhq> Adamant: I was in the 90s. We bloody well ignored most of that.
22:54:07 <Adamant> and my state is not exactly renowned for either it's educational quality or it's liberal attitudes
22:54:10 <twink> Adamant: You ought to see the "New Math" textbooks from the 60's.
22:54:28 <pikhq> "Uh, there was the trail of tears. And... Yeah. That's *all that ever happened to Indians*."
22:54:30 <Adamant> pikhq: I finished high school in the 90's
22:54:31 <Niccus> depending on the state it might be more or less detailed
22:54:43 <Adamant> let me say I don't agree with your assertion
22:54:50 <tensorpudding> (this should go to #haskell-blah)
22:54:54 <Adamant> yes
22:54:55 <Niccus> but in all states it's usually getting less detailed overall, depending on how overpopulated the schools are
22:54:57 <allbery_b> I'm sure there were places that did better, but as a 4th grader I kinda knew something was up when my third grade basic introduction the fall of Constantinople had been presented as a clash of very different cultures, but in the 4th grade the few mentions of it were "Europe vs eeevil savages"
22:55:23 <Adamant> I will take it to teh blah
22:55:44 * allbery_b will just drop it, because he'll just get (more) depressed
22:57:03 <twink> allbery_b: Which is rather odd given that the Byzantines had almost nothing to do with Europe after the Western Roman Empire dropped off, and were even located in modern-day Turkey.
22:57:17 <allbery_b> indeed
22:57:21 <tensorpudding> greece too
22:57:42 <Adamant> ok, is this happening on blah or here, I just want to know where to be off-topic :P
23:00:52 <arw_> twink: not quite. the byzantines had a huge influence on eastern european culture. the russian empire even saw itself as a successor...
23:01:23 <Adamant> and there was the whole "reconquer the Western Roman Empire" attempt
23:01:43 <copumpkin> #haskell-blah? :)
23:03:20 <ivanm> preflex: seen bos
23:03:21 <preflex>  bos was last seen on #haskell 10 hours, 7 minutes and 33 seconds ago, saying: sweet.
23:04:19 <ivanm> @ask bos what's with the constraints on text?  in particular, why do you provide two different paths that base=4 can take (rather than using the same deps for all GHCs)?
23:04:19 <lambdabot> Consider it noted.
23:20:29 <pastorn> @pl \x -> (x,x)
23:20:29 <lambdabot> join (,)
23:20:42 <pastorn> @type join (,)
23:20:43 <lambdabot> forall a. a -> (a, a)
23:37:06 * hackagebot unix-handle 0.0.0 - POSIX operations on Handles  http://hackage.haskell.org/package/unix-handle-0.0.0 (AndersKaseorg)
23:39:08 <Jafet> Version... zero?
23:39:29 <Niccus> You have to start somewhere
23:39:38 <arw_> as long as you don't divide by it...
23:39:49 <Niccus> preferably in a way that would justify future versions being infinitely better
23:43:05 <ezyang> yay, Anders uploaded his package finally
23:59:47 <rajeshsr> The idea of >>= in monads seems interesting. But why isn't it not making things non-lazy? It makes actions sequential, which could be interpreted to mean we lose laziness.
