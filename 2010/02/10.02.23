00:14:45 <copumpkin> WE NEED MORE NOISE IN HERE
00:14:53 <copumpkin> SOMEONE ASK A QUESTION
00:16:21 <m3ga> anybody want to join a really cool project?
00:16:24 <nlogax> how is lambda formed
00:16:27 <m3ga> written in haskell?
00:16:36 <mornfall> Anyone know if Sven Ove Aas appears here?
00:16:38 <copumpkin> you need to do way instain curry
00:16:52 <copumpkin> mornfall: yes, am trying to remember the nick
00:16:54 <mornfall> Svein*
00:17:44 <asdf2> is "instance Eq a => Eq (Set a) where" is a long version of "instance Eq (Set a) where " declaration?
00:18:00 <copumpkin> mornfall: Baughn
00:18:12 <mornfall> copumpkin: Thanks. :)
00:18:29 <copumpkin> asdf2: they're different
00:18:42 <allbery_b> asdf2: no; the former asserts that it is true only when a is itself Eq, the latter asserts it's always true
00:19:00 <nlogax> copumpkin: i have a question! how can i sneak some haskell into my daily work?
00:19:09 <asdf2> oh, i see :) thanks.
00:19:11 <nlogax> is the cocoa frontend for yi in a usable state?
00:19:24 <mornfall> Baughn: (when you are around), what is the preferred haskell-mode indentation module? Documentation seems to suggest -indentation, but that seems to be broken-ish, compared to -indent. I'm asking because I need to pick a default in the Debian package and I'm not quite decided.
00:19:25 <copumpkin> nlogax: turn out the lights and hope nobody notices
00:19:33 <nlogax> :D
00:20:23 * ketil wonders if Haskell would be nice for implementing video codecs.
00:21:06 <ketil> They seem to be complex and error prone (at least mplayer seems to crash a lot), but similar in many ways to compilers, and map well to the functional paradigm.
00:21:22 <ketil> (not that I ever looked inside the box, of course...)
00:22:06 <allbery_b> I haven't had mplayer crash much (when I can build it and it runs at all) but I suspect much of the problem is in windows-only DLLs
00:23:19 <allbery_b> mplayer provides just enough emulation to allow most of those to work, but it'snowhere near complete so pretty much any win32 call fron such a codec will cause a crash
00:25:21 <ketil> allbery_b, that's quite possibly the cause, yes.  Perhaps if one sticks to native codecs, things are safer.
00:30:15 <theorbtwo> Also note that codecs are, at least in some cases, very performance-sensitive.
00:30:28 <theorbtwo> A codec that can't decode fast enough on your system is useless to you.
00:31:35 * hackagebot upload: lrucache 0.2.0.1 - a simple, pure LRU cache (CarlHowells)
00:32:01 <theorbtwo> What's the right way to make a FilePath from a string?  http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/System-IO.html#t%3AFilePath seems to say that it's simply FilePath string, but, after import System.FilePath, I still get dumpfile.hs:10:18: Not in scope: data constructor `FilePath'
00:32:14 <theorbtwo> (Or import System.FilePath.Posix.)
00:32:26 <Zao> @src FilePath
00:32:39 <Zao> Isn't it just a type FilePath = String
00:32:44 <Zao> That is, an synonym?
00:33:06 <dobblego> yes, a synonym
00:39:06 <ketil> theorbtwo, decoding is performance sensitive, but encoding isn't so much, I think.  At least, some people would be willing to trade CPU for smaller size or better quality.
00:39:39 <theorbtwo> Zao, dobblego, aha, that makes sense.
00:40:20 <theorbtwo> ketil: Good point.
00:46:08 <p_l> ketil: encoding can be very performance-sensitive, it's just difference between time constraints you have. I recall a point in time where Theora was actually quite useful codec, implemented in FPGA for digital CCTV - it required fast, good quality & small size compression of 1024x1024 video
00:47:19 <visof> hello
00:47:25 <visof> how can i uninstall ghc ?
00:49:36 <Baughn> mornfall: Well.. I use -indentation. I'll admit it isn't quite as mature all the time, but it annoys me less, overall.
00:50:10 <mornfall> Really hard call, then. :|
00:51:02 <Baughn> mornfall: The correct solution is to fix whatever annoys you about it. ;)
00:52:10 <mornfall> Baughn: Possibly. :)
00:52:45 <mornfall> One bug report I got is that after f :: bla, hitting tab moves you forward instead of filling in f...
00:53:09 <Baughn> That's not a bug, that's a missing feature.
00:53:14 <Baughn> Though it would be nice if it did that..
00:54:19 <mornfall> I tend to agree. There's also something about getting extra whitespace after hitting <RET> but I am not yet sure if that depends on the indentation mode.
00:55:08 <mornfall> And some issues with filling.
00:56:17 <tensorpudding> visof: that depends on how you installed it probably
00:56:47 <mornfall> Baughn: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=570243 http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=568510 http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=570236 http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=570317 are the reports I got after uploading 2.7.
00:57:11 <visof> tensorpudding from the source
00:57:36 <visof> tensorpudding cd ../ghc* && make uninstall
00:57:43 <visof> tensorpudding doesn't work
00:57:58 <tensorpudding> you could probably remove all of the files it created by hand
00:58:04 <tensorpudding> that is what i did anyway
01:04:45 <mornfall> Baughn: If it's going to help, I can try to partition them into indent-mode-specific and the rest, but that'll have to wait a bit.
01:16:09 <krankkatze> hi, sorry for being such a beginner, but I tried writing a fusion sort in haskell, which I started learning last night
01:16:22 <Baughn> mornfall: In my opinion,haskell-indentation has less surprising behaviour, but haskell-indent is still there specifically so you can select it
01:16:41 <krankkatze> so I'd like advices to make the hole thing look better
01:16:42 <krankkatze> http://paste.pocoo.org/show/9CWf8bRGpJpkLUz6Rhr6/
01:16:43 <Baughn> mornfall: Really, you shouldn't load any of them; picking one is supposed to be up to the user.
01:16:45 <krankkatze> +w
01:17:34 <mornfall> Baughn: Well, in Debian people expect things to work out of the box. :) You shouldn't need to manually configure it to get reasonably behaviour. And automatic indentation is something I'd definitely expect to work out of the box.
01:18:06 <Axman6> krankkatze: usually, the then and else are treated as two sub parts of the if, not <if .. then ..> and <else ..>
01:18:43 <Axman6> and you're not using any pattern matching at all, which i would
01:18:56 <krankkatze> I haven't learned the syntax of it yet
01:18:56 <Baughn> mornfall: Perhaps it would be possible to make it selectable in customize?
01:19:06 <krankkatze> but I'll look for that, thanks
01:19:26 <mornfall> Baughn: Well, overriding the mode in ~/.emacs doesn't seem to be an issue.
01:20:47 <krankkatze> and the haskell-mode indents "if ..\nthen ..\nelse .." with the same indentation for the three lines
01:21:01 <krankkatze> is this normal?
01:21:32 <Baughn> mornfall: Emacs will "happily" load multiple indentation modes at the same time. Doesn't mean it's a good idea.
01:21:55 <Baughn> mornfall: You'd have to take care to disable the default one.. it's just not very nice.
01:23:00 <mornfall> Hm.
01:23:14 <mornfall> Tis' a mess.
01:24:03 <Baughn> mornfall: None of the indentation modes really work like I want them to, no. Picking one means picking the least annoying one. :/
01:24:24 <Baughn> So I fully intend to write a better one, but there's no time for that this sprin
01:24:27 <Baughn> g
01:24:48 <mornfall> Time's always an issue. :\
01:26:37 <Axman6> krankkatze: would you like to see how i would do it?
01:30:05 <mreh> I need an arbitary number of expression operators (n-ary) represented by a tree structure
01:30:23 <mreh> are binary trees enough to encode that?
01:30:25 <krankkatze> yes Axman6 :D
01:31:37 <mreh> and, if I use a generic tree structure, how can I guarantee that each operator has the requisite number of arguments
01:32:02 <mreh> I'd like to use existing tree algorithms rather than re-inventing them for my own purposes
01:32:56 <mreh> right now I've got: Expr = And Int Expr Expr | Or Int Expr Expr | Not Int Expr | etc...
01:33:33 <mreh> the Integers are the size of the subtree for optimising the traversal
01:34:22 <fasta> Is there a way to ask for the call site of the current function in some relatively easy way in the code using GHC?
01:35:13 <Axman6> krankkatze: http://pastebin.com/ez2Evs9Z the foo functions are yours, the foo' are my versions
01:37:14 <visof> hello
01:39:56 <mreh> good morning
01:40:09 <Daerim> morning
01:40:53 <Axman6> krankkatze: what do you think?
01:43:28 <fasta> Axman6, if you are optimizing for code-reuse and readability, you can do better (with the same complexity, of course)
01:43:52 <Axman6> Alpounet: well, that was just an initial translation to using pattern matching
01:43:58 <Axman6> uh, fasta, not Alpounet
01:44:23 <fasta> Axman6, but it is trivial code anyway. Fine by me :)
01:45:14 <krankkatze> well Axman6
01:45:16 <fasta> I would probably write it in terms of dropEven and dropOdd and combine those.
01:45:27 <krankkatze> I can't actually read your code :D
01:45:36 <Axman6> that would probably be more lazy, yes
01:45:41 <krankkatze> (a:b:as) ?
01:45:43 <Axman6> krankkatze: time for yoiu to learn you some haskell ;)
01:45:50 <Axman6> > 1:2:[]
01:46:00 <Axman6> argh! no lambdabot!
01:46:03 <fasta> krankkatze, basically, you are also using !! in a horrible way.
01:46:34 <Axman6> anyway, x:y:[] is the same as [x,y]
01:46:35 <fasta> krankkatze, the !! is translated in my brain to "look here, someone has too much CPU power".
01:46:39 <Axman6> @sec []
01:46:44 <Axman6> argh!
01:47:01 <Axman6> fasta: "too much C" here ;)
01:47:02 <krankkatze> hm
01:47:19 <fasta> Axman6, if it would be C, it would use !.
01:47:51 <fasta> !! and [] the index operator have nothing to do with eachother, other than indexing.
01:48:17 <krankkatze> so how should I access the first and second values of the list?
01:48:39 <Axman6> by patterh matching
01:48:47 <krankkatze> ok
01:48:49 <fasta> krankkatze, That is what the pattern match does. It binds 'a' to the first element and 'b' to its second element.
01:48:51 <Axman6> pattern*
01:49:02 <fasta> krankkatze, but the best way is to decompose the problem.
01:49:09 <Axman6> and as is the rest of the list
01:49:20 <Alpounet> 'morning, guys
01:49:38 <fasta> krankkatze, you basically want to drop all the even indexed elements and all the odd index elements and combine those.
01:49:54 <fasta> krankkatze, if you approach the problem like that the code becomes trivially correct.
01:50:09 <Axman6> (and easily provably so too)
01:50:16 <Axman6> proof++!
01:50:36 <fasta> Proof in a language without a proof system++
01:50:39 <krankkatze> Ok Axman6 I understand your whole code now
01:50:48 <Axman6> you sure?
01:50:51 * copumpkin proves the unprovable
01:51:06 <krankkatze> well
01:51:16 <krankkatze> I understand the idea behind it
01:52:36 <fasta> krankkatze, what is your programming background?
01:53:02 <krankkatze> well
01:53:08 <krankkatze> I can actually write C and Python :D
01:53:25 <Axman6> time to forget those ;)
01:53:31 <krankkatze> and I have read introductions to Ocaml and Erlang
01:54:51 <mreh> you poor thing
01:55:15 <mreh> all your sins will be forgiven
01:55:21 <mreh> come my child
01:56:16 <fasta> I don't see how people can think functional programming is hard. Figuring out how your whole heap of pointers looks like can be counted as hard.
01:56:19 <mreh> with pattern matching I can write the specification for multiplexers!
01:56:53 <krankkatze> well fasta I actually like using functional language way more than inperative ones
01:57:06 <mreh> you'll be happy here then
01:57:13 <Axman6> you don't write very functional code ;)
01:57:32 <krankkatze> but I had be using python for, like, 2 years before I heard about functional programming
01:57:35 <Alpounet> fasta, I think it's more about getting used to the functional way of thinking about a program
01:57:39 <fasta> Functional programming is just programming on a reduced machine essentially. Some problems can be expressed efficiently on them, some cannot.
01:57:56 <krankkatze> so when I have to write something that is hard for me, I actually do it with python
01:58:05 <mreh> fasta: functional programming moves away from the notion of a machine
01:58:15 <krankkatze> hum Axman6 I haven't learned the haskell pattern matching syntax
01:58:17 <krankkatze> yet
01:58:19 <mreh> it's much more abstract
01:58:27 <krankkatze> that's why my code was pretty strange, I guess
01:58:39 <fasta> mreh, you can say that, but I still have to wait log n time more if I don't use mutable code.
01:58:55 <fasta> mreh, which translated to a factor of 20.
01:58:55 <mreh> fasta: for doing what?
01:59:13 <mreh> you can write functional code with arrays
01:59:37 <fasta> mreh, what do you mean by "array"? There are a gazillion types which people call arrays.
01:59:44 <mreh> a binary search can be written recursively for example
02:00:00 <mreh> fasta: an array has O(1) access
02:00:06 <Axman6> krankkatze: well get to it, it's one of the more important and useful parts of haskell
02:00:09 <mreh> that's what characterises an array in the wild
02:00:18 <fasta> mreh, please assume I am not stupid.
02:00:32 <mreh> fasta: you're asking the questions
02:00:34 <fasta> mreh, my arrays have O(1) r/w access.
02:01:13 <fasta> mreh, I have not looked at the vector package for a long time yet, but when I did this the only available "array" were the DiffArrays.
02:01:19 <fasta> arrays*
02:01:31 <Alpounet> there are other ones now
02:01:31 <fasta> mreh, and everyone knows DiffArrays are slow.
02:01:55 <mreh> fasta: you don't have to use arrays, mutable data isn't ever a requirement
02:02:04 <fasta> mreh, yes, it is.
02:02:21 <augur> who here has read (any of) Handbook of Formal Languages?
02:02:27 <fasta> mreh, it follows from certain requirements.
02:02:35 <mreh> fasta: give me an example
02:03:00 <fasta> mreh, the bipartite matching algorithm by Cole-Ost-Schirra.
02:03:29 <Axman6> sounds like you need to be using the vector package3
02:03:31 <Axman6> =3
02:03:33 <mreh> can't you pick something I would be familiar with?
02:03:56 <visof> hi
02:04:00 <fasta> mreh, a simulator of a RAM.
02:04:18 <mreh> fasta: why do you *need* to simulate RAM in haskell?
02:04:30 <visof> i had that when i'm trying to install network http://pastie.org/838311 , what should i do ?
02:04:39 <mreh> the quicksort in haskell isn't really *the* quicksort algorithm it still does the same thing
02:04:56 <fasta> mreh, you are using ridiculous logic.
02:05:27 <mreh> fasta: you need to stop thinking in terms of the von neumann architecture
02:06:04 <fasta> mreh, I'd love to think in terms of a 3D-cube architecture or anything which has real locality of space associated with it.
02:06:19 <fasta> mreh, but such ideas are worthless, since such machines do not actually _exist_!
02:06:19 <mreh> if you want to simulate RAM in haskell as part of a simulation you an use the state monad
02:06:41 <Axman6> if you're emulating RAM, there's no reason the actual implementation needs to be the same as actual RAM would be
02:06:54 <mreh> this isn't a sensible conversation
02:07:00 <fasta> mreh, you are clearly missing the point.
02:07:21 <fasta> Axman6, and where did I claim that?
02:07:42 <mreh> fasta: you want mutable Arrays in haskell, I'm telling you that you don't even need them
02:07:44 <Axman6> i never said you sis, but it was somewhat iomplied ;)
02:08:20 <fasta> I am merely saying that indexing in a polynomial bounded indexes takes at least time ln (ln n).
02:08:22 <Axman6> did*
02:08:49 <mreh> fasta: finger trees?
02:09:11 <mreh> they're amortized time constant
02:09:11 <fasta> mreh, no, but it merely shows you don't know everything there is to know about this subject. Neither do I, probably.
02:09:22 <fasta> mreh, you are full of it.
02:09:25 <mreh> I'm sure I dont
02:10:07 <mreh> what do you mean precisely by "polynomial bounded indexes"
02:11:15 <fasta> mreh, it means that just as an array has [1..n] indices, a polynomial bounded indices are bounded by a polynomial.
02:11:24 <fasta> -a
02:12:19 <mreh> an array of n items has O(n) space complexity
02:12:26 <visof> isn't there anyone can help me ?
02:12:35 <fasta> mreh, grass is green. What is your point?
02:12:39 <dobblego> there was a thesis published recently about the need for arrays against the performance but I can't remember who wrote it
02:12:53 <dobblego> visof, wossup?
02:13:03 <mreh> fasta: I still don't understand what you mean
02:13:10 <fasta> mreh, not my fault.
02:13:12 <mreh> dobblego, pastie ^
02:13:19 <visof> dobblego i had that when i'm trying to install network http://pastie.org/838311 , what should i do ?
02:13:21 <mreh> fasta: I'm sure you can help me understand
02:13:27 <fasta> mreh, anyway, go and implement something non-trivial and you will understand.
02:13:36 <CalJohn> fasta: it is your fault.  you're being needless obtuse and aggressive, and aren't even trying to communicate your meaning any more
02:14:12 <fasta> CalJohn, I find it annoying that random people tell me Their Truth without any basis.
02:14:12 <mreh> I only want to understand what you mean
02:14:19 <mreh> @where ops
02:14:25 <mauke> mreh: yes?
02:14:50 <mreh> fasta's kicking up a fuss, can we try and sort this out
02:14:56 <mreh> I don't know what he's talking abou
02:14:56 <mauke> wtf
02:15:07 <mauke> solve your own problems
02:15:18 <mreh> heh, okay, sorry to bother
02:15:43 <Stephan202> The problem just solved itself ;)
02:15:48 <mreh> oh yes
02:16:00 <mreh> man...
02:17:50 * mux_ wonders if #haskell reached critical mass somehow
02:18:03 <mreh> the equivalent of storming out of the conversation
02:18:28 <mreh> yeah, there does seem to be too many arguments
02:18:31 <mreh> often revolving around me
02:20:03 <mreh> > replicateM 3 [True, False]
02:20:11 <mreh> @botsnack
02:21:46 <mreh> no bots?!
02:22:57 <Alpounet> no bots.
02:24:05 <mreh> time I stopped using them as my private interpreter then
02:27:39 <mreh> I don't understand replicateM on the list monad, in my mind it would just give me a list of []'s n long
02:28:16 <mreh> if you concatMap (\x -> return []) to [1,2,3] you get [[],[],[]]
02:28:47 <mreh> n! long
02:29:19 <mreh> can't think this morning
02:32:13 <BONUS> mreh: do you understand sequence?
02:32:15 <BONUS> on lists
02:32:49 <mreh> BONUS well w.r.t the defintion of replicateM, clearly not
02:32:56 <mreh> oh, I think I get it now
02:33:14 <BONUS> replicateM is just replicate and then sequence
02:33:52 <mreh> the concatenation happens in sequence
02:35:19 <BONUS> replicateM 3 [1,2,3] makes [[1,2,3],[1,2,3],[1,2,3]] and then it sequences that. so in essence it makes a list where every inner list is [x,y,z] and x is drawn from [1,2,3], as is y and z
02:35:53 <BONUS> if it were replicateM 4 [1,2,3] then you'd have a list where every inner list is [x,y,z,w] and each letter there is also drawn from [1,2,3]
02:37:32 <mreh> this isn't the most general case though, if I wanted words of length n from an alphabet of m you need to do something else
02:39:09 <BONUS> ah i didnt know you were looking for that i just thought you were asking about replicateM
02:39:29 <mreh> BONUS: my mind tends to look for generalisations of everything
02:39:47 <mreh> it's a bad habit and a time waster
02:39:59 <mreh> from a business perspective
02:40:45 <BONUS> but it does give you words of length n from an alphabet of m
02:40:53 <BONUS> > replicateM 3 "ab"
02:40:59 <BONUS> ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
02:41:21 <mreh> need to think about this some more
02:41:26 <mreh> i'll do it later
02:41:36 <mreh> thanks
02:41:39 <m3ga> :t div
02:41:51 <mreh> no bots
02:43:23 <m3ga> whats the normal precedence of an infix div?
02:44:27 <mreh> m3ga: got ghci?
02:44:46 <mreh> the command is :info anyway :)
02:44:46 <m3ga> yes
02:44:57 <mreh> infixl 7 div
02:45:26 <m3ga> cool, got it in  ghci  as well. thanks
02:46:29 <mreh> does GP and GAs strike you as remarkably un-Darwinian
02:49:15 <ehamberg> mreh: of course. darwin was all about *natural* selection. :)
02:50:01 <mreh> meh, they're both pretty unedifying
02:50:46 <dancor> i don't get it
02:51:55 <dancor> because the selective pressures don't change over time?
02:52:20 <dancor> because typically only narrow parameters are changing instead of the entire program?
02:55:17 <mreh> dancor: Darwinian evolution supposed to be ateological, but with a GA you have an objective function
02:55:52 <mreh> I think of it as a stochastic search, one doomed to fail
02:56:29 <mreh> they have their best mathematicians trying to work out what the "building block hypothesis" actually means
02:56:50 <dancor> mreh: what does ateological mean
02:57:14 <mreh> dancor: ateleological, sorry
02:57:27 <mreh> without a bauplan
02:57:39 <mreh> no intentionality implied
02:59:45 <zygoloid> the 'real' genetic algorithm which created, say, humans was run on a massively parallel system for millions of years. and it created less source code than is involved in 'Notepad'.
03:07:36 <gal_bolle> what does "missing field in record construction" mean, as a run-time error?
03:08:17 <jlouis> gal_bolle: you are trying to construct a record, but when you did, you forgot to supply all fields
03:08:50 <Beelsebob> in runtime IIRC it means you actually tried to read that field too
03:09:05 <Beelsebob> there's a compile time warning that warns you no matter what though
03:09:21 <gal_bolle> ok, i must have missed the compile time warning
03:09:42 <gal_bolle> i was indeed using X {foo = bar} instead of x {foo = bar}
03:09:46 <gal_bolle> thanks
03:12:50 <RayNbow> preflex: seen copumpkin
03:12:51 <preflex>  copumpkin was last seen on #haskell 1 hour, 21 minutes and 59 seconds ago, saying: * copumpkin proves the unprovable
03:13:16 <Alpounet> yay, a bot !
03:13:16 <copumpkin> RayNbow: yo
03:14:12 <RayNbow> copumpkin: g'morning :)
03:14:19 <copumpkin> I'm still awake :(
03:14:30 <copumpkin> terrible morning, if anything :P
03:14:35 * RayNbow just woke up a few minutes ago :p
03:14:53 <RayNbow> (it's actually just past noon here)
03:15:45 <RayNbow> copumpkin, what did you mean with raising them to a power?
03:16:28 <copumpkin> RayNbow: multiply the adjacency matrix by itself
03:21:11 <RayNbow> copumpkin: hmm, how are (i,j) in the result matrix plotted if (i,j) > 1?
03:21:45 <copumpkin> they mean the number of ways you cross an edge
03:22:07 <copumpkin> you don't have to take them into account
03:22:41 <copumpkin> anyway, gonna go to sleep now
03:22:49 <RayNbow> ok, good night
03:23:08 <copumpkin> good luck
03:28:06 <ehamberg> oh, no. hpaste.org is down.
03:29:07 <Raynes> The world just imploded.
03:31:15 <ehamberg> i'm trying to learn how to use monad transformers. could anyone take a look at http://haskell.pastebin.com/tAsq4u6f ? (21 lines) does it look sane? (besides the game being stupid. :)
03:31:49 <aleator> Hi! I need to compile a shared library and end up with "relocation R_X86_64_32S against `stg_upd_frame_info' can not be used when making a shared object; recompile with -fPIC
03:31:53 <aleator> How to proceed?
03:31:57 <ehamberg> took a lot of guesswork to find the correct function type, though :|
03:32:37 <Alpounet> -fopt-c -fPIC, something like that, IIRC
03:33:37 <aleator> I already compile my code with -fPIC
03:34:21 <aleator> I would need base compiled with -fPIC?
03:37:21 <jlouis> ehamberg: I usually pull the transformer type to its own type declaration
03:37:34 <jlouis> otherwise, you'll go mad writing it all the time
03:39:41 <jlouis> ehamberg: also check out GeneralizedNewtypeDeriving
03:41:43 * hackagebot upload: kangaroo 0.4.0 - Binary parsing with random access. (StephenTetley)
03:43:47 <xpika> does anyone know how to pass gcc flags through cabal?
03:48:23 <ehamberg> jlouis: will do. thanks.
03:54:19 <jlouis> ehamberg: it might be able to simplify all your lifts
04:13:00 <mreh> is there a typeclass to obtain the arity of a constructor
04:13:13 <mauke> it is likely
04:13:28 <mreh> I'll make my own
04:13:33 <mreh> it's only toy code
04:14:00 <idnar> oh, data constructor
04:14:34 <mreh> it is truth
04:14:59 <mreh> class Terminal... sounds ominous
04:15:40 <mauke> > toConstr (Just ())
04:15:46 <mauke> BOOOTS
04:15:53 <mreh> heh
04:16:24 <mreh> you can't shout "bots" in a way fit for battle star galactica
04:16:48 <mauke> preflex: seen lambdabot
04:16:49 <preflex>  lambdabot was last seen on #haskell 11 hours, 49 minutes and 34 seconds ago, saying: forall a b. (a -> b -> b) -> b -> [a] -> [b]
04:16:52 <mauke> preflex: seen Cale
04:16:53 <preflex>  Cale was last seen on #haskell 12 hours, 46 minutes and 1 second ago, saying: f (Book isbn title authors) = ...
04:17:56 * benmachine thought mauke was shouting BOOTS and kind of wondered why
04:17:58 <mreh> it's going to be runtime magic whatever it is
04:18:19 <benmachine> mreh: I remember copumpkin making an Arity class but I think it depended on overlapping instances
04:18:26 <benmachine> or something similar
04:18:36 <mreh> BOOTS!!! why are you not selling homeopathic medicines anymore?!
04:18:49 <mreh> benmachine: overlapping how?
04:18:56 <mreh> I am unfamiliar with that
04:19:08 <mreh> compound types?
04:19:09 <benmachine> as in, -XOverlappingInstances
04:19:12 <ehamberg> jlouis: right. i guessed there was a better way. :)
04:19:17 <benmachine> also, because homeopathy is a lie
04:19:38 <Cale> Oh, lambdabot is wedged?
04:19:43 <mreh> syntactically, that makes no sense
04:19:56 <mreh> are you lambdabot's Daddy, Cale?
04:20:16 <benmachine> @vixen welcome back
04:20:20 <benmachine> ooor not
04:20:22 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
04:20:31 <benmachine> that's cool with me
04:20:36 <mreh> she lives!
04:20:49 <mreh> > toConstr (Just ())
04:20:56 <lambdabot>   Just
04:21:02 <benmachine> mreh: overlapping instances are like when you have instance Foo a and instance Foo Char and you expect that to work in some way
04:21:12 <benmachine> generally they are pretty scary
04:21:23 <mreh> benmachine: oh... that's just polymorphism
04:21:27 <benmachine> no
04:21:37 <benmachine> instances in general are polymorphism
04:21:41 <quicksilver> mreh: on the contrary, it is precisely the opposite of everything that is good about polymorphism
04:21:46 <quicksilver> mreh: it is DEATH and FIRE and PAIN
04:21:50 * benmachine giggles
04:21:55 <mreh> oh noes
04:22:04 <benmachine> the point is simultaneously having an "a" and "Char" instance for Foo
04:22:09 <mreh> ask a simple question in #haskell and you get a complicate answer
04:22:19 <benmachine> means that calling foo's methods on a Char has multiple possible resolutions
04:22:26 <mreh> benmachine: oh
04:22:28 <mreh> I see
04:22:31 <benmachine> which quicksilver is not a fan of
04:22:34 <quicksilver> technicaly my comment was a rant, not an answer ;)
04:22:50 <mreh> my original question was, how can I get the arity of a constructor
04:22:54 <benmachine> yes
04:23:15 <mreh> have I gotten an answer, I lost the plot a bit
04:23:21 <benmachine> and I said I remembered someone doing a thing which told you the arity of a function, using overlapping instances
04:23:23 <quicksilver> constructors aren't really first class entities in haskell
04:23:36 <quicksilver> you can surely get constructor arity out of SYB or one of those things though?
04:23:37 <Beelsebob> benmachine: unless of course you define what the resolution is – like for example, the most specified instance
04:23:42 <benmachine> and then I also said that overlapping instances are generally unpleasant
04:23:58 <Beelsebob> but that can get fun to define ofc
04:24:01 <quicksilver> Beelsebob: but that breaks composability.
04:24:09 <Beelsebob> quicksilver: indeed it does
04:24:10 <quicksilver> which is a pretty big thing to give up.
04:24:17 <Beelsebob> uhhuh
04:24:17 <mreh> you can pass constructors to a HOF
04:24:48 <benmachine> > gmapT cast (Just 4)
04:24:50 <lambdabot>   Couldn't match expected type `b1'
04:24:50 <lambdabot>         against inferred type `Data.Maybe...
04:24:54 * benmachine doesn't really remember this stuff
04:25:04 <benmachine> wait there is listify
04:25:09 <Alpounet> @type gmapT
04:25:10 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
04:25:16 <quicksilver> mreh: no you can't.
04:25:21 <mreh> Data, sounds like "Object"
04:25:22 <benmachine> no listify is a bad idea
04:25:27 <quicksilver> mreh: (what you're passing is the function part of the constructor)
04:25:36 <mreh> quicksilver: oh?
04:25:41 <quicksilver> mreh: that's what I mean by them not being first class
04:25:54 <quicksilver> when you pass "Just" to a HOF, you're only passing the function (a -> Maybe a)
04:25:59 <mreh> you just said constructors are functions
04:26:04 <mreh> yes
04:26:05 <quicksilver> you're not passing the whole 'constructorness' of it
04:26:12 <mreh> oh
04:26:18 <quicksilver> in particular you can't pattern match with the thing you get
04:26:24 <quicksilver> pattern matching is the key property of constructors
04:26:30 <quicksilver> (or at least, the part of them which isn't functions)
04:26:40 <quicksilver> the de-construction half.
04:27:37 <mreh> I'm going to code this GP in record time, no time to learn new things
04:27:43 <benmachine> > gmapQ (const ()) (Just 3)
04:27:44 <lambdabot>   [()]
04:27:48 <benmachine> > gmapQ (const ()) Nothing
04:27:50 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:27:50 <lambdabot>    `Data.Data.Data a'
04:27:50 <lambdabot>      a...
04:27:53 <benmachine> erk
04:27:59 <benmachine> > gmapQ (const ()) (Nothing :: Maybe Bool)
04:28:00 <lambdabot>   []
04:28:13 <benmachine> > gmapQ (const ()) (4, 4, 4)
04:28:15 <lambdabot>   [(),(),()]
04:28:32 <benmachine> possibly there is an easier way, my knowledge of syb is a bit sparse
04:28:35 <mreh> I can just pattern match with the constructors, I don't plan on adding any more to the type class, so that's alright
04:28:50 <mreh> thankyou for wasting your time for me
04:29:00 <benmachine> > gmapQ (const ()) [a, b, c, d, e, f, g] -- only get the constructors for the :
04:29:01 <lambdabot>   [(),()]
04:29:03 <mreh> thank me for wasting you time
04:29:05 <benmachine> err arity
04:30:56 <benmachine> :t gfoldl -- how does this work
04:30:57 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
04:31:04 <benmachine> I am confused by the c
04:32:45 <mreh> I have to grow a tree recursively.. that's hard
04:32:47 <Axman6> well, c could be Maybe, [], Either a
04:33:17 <mreh> maybe I could be lazy about it
04:33:39 <benmachine> you can make a c with the second argument
04:33:47 <benmachine> and you can sort of apply a function inside a c with the first
04:34:26 <benmachine> so you could use the second argument to put a function in a c, and then use the first to apply it to something...
04:34:29 <benmachine> then what?
04:34:39 * benmachine shrugs
04:34:53 <benmachine> one of these days I'm going to have to poke around inside Data to see what is going on
04:35:26 <mreh> on an evening out with the wife
04:35:26 <Axman6> hmm, i wonder howhard it would be to implement an IPv4 processing library in haskell
04:35:51 <Axman6> seems like a great job for things like Cereal
04:35:54 <Alpounet> benmachine, I don't get the 'a' of the type sig
04:36:05 <Alpounet> I think I get the rest, like you, though
04:36:14 <benmachine> you think I get the rest?
04:36:20 <benmachine> I didn't intend to give that impression
04:36:22 <Alpounet> approximately
04:36:30 <Alpounet> but anyway
04:36:36 <Alpounet> what's the point of that a there ?
04:36:46 <Alpounet> oh
04:37:32 <Alpounet> I have one possible interpretation but then the first arg is useless
04:37:40 <Alpounet> I guess this isn't a good one, then.
04:37:59 <benmachine> heh
04:38:05 <benmachine> it's a mystery!
04:38:23 * Axman6 thinks looking at this might make it easier:
04:38:26 * Axman6 thinks looking at this might make it easier:
04:38:30 <Axman6> oops
04:38:30 <Alpounet> @hoogle gfoldl
04:38:30 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
04:38:31 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
04:38:33 <Axman6> (Data a) => ((Data d) => c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
04:38:41 <Axman6> fine then
04:39:13 <benmachine> :t foldl
04:39:15 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:40:02 <Alpounet> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Data-Data.html#gfoldl
04:40:31 <Alpounet>   -- The type of 'gfoldl' is a headache, but operationally it is a simple
04:40:31 <Alpounet>   -- generalisation of a list fold.
04:40:32 <Alpounet> haha
04:45:01 <benmachine> > gfoldl (const (+1)) (const 1) (Just ())
04:45:02 <lambdabot>   Could not deduce (GHC.Num.Num (c g1)) from the context ()
04:45:02 <lambdabot>    arising from t...
04:45:08 <benmachine> hrrrm
04:45:17 * benmachine breaks
04:45:21 <Cale> hmm, hoogle reports incorrect types
04:45:37 <Cale> @hoogle runST
04:45:37 <lambdabot> Control.Monad.ST runST :: ST s a -> a
04:45:38 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
04:45:38 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
04:45:57 <Cale> heh, who needs higher rank polymorphism anyway? ;)
04:46:06 <Alpounet> haha
04:46:30 <idnar> heh
04:47:57 <jlouis> Axman6: cereal is an excellent idea for an IPv4 parser
04:48:40 <Axman6> the only thing that would be better is something that allows you specify how many bits you want to read, instead of how many bytes
04:53:42 <sizur_> Hi guys.  I have a question about ghc parallel gc.  Does it have the shortcoming described in the paper -- all processes freeze during gcing?
04:56:46 <Cale> sizur: yes, it's still stop-the-world, but it makes use of parallelism
04:56:58 <Axman6> and he's gone -_-
04:57:12 <Cale> There's a different sizur still here though
04:57:20 <Axman6> ah
05:00:35 <Alpounet> <Cale> sizur: yes, it's still stop-the-world, but it makes use of parallelism
05:04:08 <mreh> I might kill GP
05:04:14 <mreh> I hate it
05:04:39 <mreh> how am I supposed to get a working multiplexer from random boolean functions
05:09:19 <int-e> by luck
05:09:41 <Janni> GP=?
05:09:48 <int-e> genetic programming, I guess
05:52:05 <Daerim> Are the PolyFunViz and associated project all dead?
06:06:01 <ketil> Anybody using CmdArgs?  isQuiet seems to always return True?
06:08:21 <ketil> Never mind: isQuiet = return True
06:09:31 <ketil> mlesniak, hi!
06:09:39 <mlesniak> Is there a way to pass my own command line parameters to criterion?
06:29:02 <jontore> Hi. I'm having some problems with reading from file and pure values. I don't think I have gotten a hold on it yet. This is the code I'm having trouble with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22905#a22906. Seems like it is how I use input that is the problem but I can figure out how it should be done. Thanks
06:34:20 <Cale> jontore: Your indentation there is messed up
06:34:44 <Cale> jontore: Also, compileFile's type is clearly not  String -> String
06:35:16 <Cale> jontore: Because such a type means that no I/O could possibly be done, whereas you're reading a file.
06:36:45 <jontore> Cale: ok, so the input should be IO String ?
06:36:52 * ksf is confused. what does log^2 n mean? It's a type error to me, but I see it in a lot of papers...
06:37:04 <Cale> jontore: The result of compileFile should be an IO action of type IO String
06:37:17 <cebewee> ksf: log log n?
06:37:22 <Cale> jontore: Here's how I/O works in Haskell. Functions, and in general, the evaluation of expressions, are not allowed to have any I/O effects.
06:37:34 <ksf> no that's different, they're all using that, too.
06:37:45 <Daerim> ksf, log(n)^2?
06:38:17 <ksf> can't be, he's also using (log log n)^(2+epsilon)
06:38:19 <Cale> jontore: Instead, we encode those effects as values of type (IO t). You can think of a value of type IO t as being a program which if you were to execute it, it may do some I/O, and it would produce a value of type t.
06:39:09 <Cale> jontore: On the other hand, just evaluating that value does nothing visible -- similar to how opening the source code to a program in a text editor won't cause it to run.
06:39:45 <jontore> Cale, right. Thats why Haskell uses return and <- when going between them or ?
06:39:46 <ksf> ...well, or it's (log n)^2 and utterly unclear syntax.
06:40:01 <Cale> jontore: Well, I'll explain return and do-notation in a moment
06:40:32 <Cale> but what we do is to build up values of type (IO t) describing what we want the program to do overall, and eventually one of these values is 'main', which is evaluated (turning the expression into a value) and then executed
06:40:50 <NeoMojo> ksf: could it mean log to the base of 2?
06:41:06 <ksf> it's log base 2 all over the place
06:41:18 <Cale> It's important to understand the difference between evaluation (turning expressions into values), and execution (taking (IO t) values and carrying out the effects they describe)
06:41:23 <NeoMojo> because normally log is meant to mean log to yhe base 10
06:41:32 <ksf> ...in fact, he uses lg, not log. I'd use ld, logarithmus dualis.
06:41:47 <ksf> ...but not in computer science.
06:41:50 <Cale> If that's clear, then we just need to understand some ways in which to combine IO values to get the programs we're after.
06:42:27 <Cale> return :: a -> IO a, gives us a way to construct the IO action which "does nothing" but produces a particular value as its result.
06:42:51 <Cale> This is mainly useful at the end of a chain of actions in deciding what value the overall action should produce.
06:43:11 <Cale> (Note that return's type is actually more general, but I don't want to talk about monads)
06:44:09 <pozic> NeoMojo: in mathematics log usually means the natural log.
06:44:22 <NeoMojo> I thought ln normally means natural log
06:44:26 <pozic> NeoMojo: every field has its own conventions.
06:44:35 <pozic> NeoMojo: ln only means natural log.
06:44:40 <Cale> NeoMojo: That too, but most mathematicians don't like the notation 'ln' at all.
06:44:50 <NeoMojo> oh!
06:45:02 <pozic> NeoMojo: in computer science nobody cares about log or ln or whatever.
06:45:10 <NeoMojo> ??
06:45:11 * ksf really, really, likes ld, but nobody uses it.
06:45:29 <pozic> NeoMojo: since they are all the same unless you actually care about their precise values and not their asymptotic behaviour.
06:45:38 <NeoMojo> ah! of course
06:45:40 <jontore> Cale, thank you. That helped clearing up a couple of issues for me.
06:46:00 <Cale> jontore: So, next we need to have some ways to glue smaller IO actions together into larger ones
06:46:20 <pozic> IMHO, it is bad style not to ever define which logs you are meaning if it matters for the results.
06:46:21 <Cale> jontore: This is what do-notation is for.
06:47:14 <Cale> Inside of a do-block, the notation:
06:47:16 <Cale> v <- x
06:47:26 <ray> well if you don't specify a base for your log, what else could make sense as the default :)
06:47:29 <Cale> means to run the action x, and name the result of running that action v
06:47:36 <pozic> ray: there is no default.
06:47:36 <Cale> If x :: IO t, then v :: t
06:47:54 <ray> sure there is, e
06:47:55 <pozic> ray: if you come from outside the field at least there is not.
06:47:56 <Cale> and if you leave the "v <-" out, it just means to run the action x
06:48:05 <ksf> the default is definitely 2.
06:48:13 <Cale> The only log which anyone should care about is the natural one.
06:48:21 <ksf> as two is the natural size for divide+conquer.
06:48:37 <Cale> I don't think that it makes much sense to define logs of any other bases. They're just scalar multiples of the natural one anyway.
06:48:48 <ksf> ...in one dimension, that is.
06:48:54 <Cale> I usually prefer to write log x / log 2 in the case that I really want the log to base 2
06:48:55 <pozic> Cale: Euler would be so pleased.
06:48:58 <ray> yeah
06:49:29 <tromp> just write log_2 to be explicit
06:49:32 <Cale> But in CS, it often doesn't matter anyway, since most of the cases where logarithms show up are in asymptotic settings anyway.
06:49:47 <Cale> (and the base doesn't matter)
06:50:15 <ksf> still, you have to know the base to figure out min(k log log n, log n)
06:50:47 <ksf> ...because, you may not know it, there's people who are interested in actual running times, not only asymptotics.
06:51:58 <Cale> Yeah, if you're interested in the constants, then you do need to preserve the base, but I usually find it more convenient to just use natural logarithms and explicit division.
06:52:23 <Cale> (makes it easier to remember how the operations go)
06:52:26 <pozic> Everyone is interested in constants. Since if they were not, everything would be trivial.
06:52:50 <Cale> pozic: Inside of big-O notation, they don't tend to matter.
06:53:24 <pozic> Cale: what is practical or usual is of no interest.
06:54:34 <Cale> Usually I find that people care about the asymptotic performance together with actual benchmarks of implementations, rather than exact operation counts.
06:54:51 <pozic> Right, but the constants are still there, implicitly.
06:55:16 <pozic> If people don't care about constants, CS is trivialized.
06:55:29 <Cale> I'm not sure I understand what you mean.
06:55:40 <pozic> Universal algorithms solving everything optimally already exist.
06:56:06 <pozic> So, given a new problem, you simply apply the universal algorithm and you are done.
06:56:31 <pozic> You can answer that to your algorithms assignments at university if they don't say anything about constants.
06:56:33 <ksf> ...especially with new data structures, there's usually a high cost in constant factors and/or space usage for a meagre asymptotic gain
06:56:54 <pozic> You will get a perfect score, because you are right.
06:57:02 <pozic> That the instructor didn't mean that, is his problem.
06:57:38 <Cale> pozic: So there's an algorithm which turns a problem description into an asymptotically optimal solution to that problem?
06:57:56 <pozic> (and since most instructors are ignorant of areas other than their own very narrow area of research, it works)
06:58:00 <pozic> Cale: yes
06:58:05 <Cale> How does it work?
07:01:48 <pozic> Cale: basically it proves properties about all algorithms and it allocates time in a smart way while doing so s.t. that you only have an additive constant.
07:01:57 <Cale> I don't know how I'd avoid needing to solve the halting problem.
07:02:08 * hackagebot upload: hjson 1.1.1 - JSON parsing library (JaroslavGridin)
07:02:21 <pozic> Cale: it are only all the provable algorithms.
07:03:33 <pozic> Cale: but since everything which humans publish about is provable, that is hardly a limitation.
07:04:26 <Cale> So you're saying, enumerate all proofs of termination, and find among them a proof of termination for an algorithm which you can additionally prove solves your problem?
07:04:55 <pozic> Cale: yes, there is a complicated way to allocate time, but the time to find the algorithm is essentially a constant.
07:05:26 <Cale> Surely not constant in the length of the problem description.
07:05:58 <Cale> Oh, I see what you mean.
07:06:23 <Cale> Treating this universal algorithm as part of a solution to another problem.
07:06:26 <pozic> Cale: the problem description is the abstract formal description like "sort N numbers".
07:06:39 <pozic> Cale: right
07:08:35 <Cale> I'm still not sure how you go about showing that you've found an asymptotically optimal solution -- or even that one exists in general.
07:09:07 <Cale> Are there no problems such that there's an infinite sequence of asymptotically improving solutions with no optimum?
07:09:25 <Cale> (I was pretty sure there were...)
07:09:30 <pozic> Cale: yes, there are such problems.
07:09:41 <Cale> Then how could this universal algorithm terminate at all?
07:09:55 <Cale> Since there is no solution.
07:10:01 <pozic> Cale: but I do not understand the speedup theorem myself, since the paper is badly damaged and I cannot see all the symbols.
07:10:33 <Cale> I feel that something fishy is going on :)
07:10:41 <pozic> Cale: http://www.hutter1.net/ai/pfastprg.htm
07:11:01 <pozic> Cale: M avoids Blum's speed-up theorem by ignoring programs without correctness proof.
07:11:24 <pozic> Cale: the speedup-theorem depends on unprovable algorithms :)
07:11:31 <pozic> Cale: how convenient, isn't it?
07:12:32 <pozic> Cale: anyway, he demonstrates in a very real sense that theoretical computer science assuming infinite resources is essentially dead.
07:13:36 <pozic> Cale: when you finish it, tell me what you think about it. I read it a long time ago.
07:13:46 <Cale> It seems like there ought to be some functions f such that there exists a sequence of programs P_n for computing f and functions g_n such that P_n has time complexity O(g_n), and such that g_n > g_(n+1) for all n.
07:14:04 <Cale> But for which there is no asymptotically optimal solution.
07:15:11 <Cale> Er, better way to put it, for any program P computing f, there is another program Q computing f such that the asymptotic performance of Q is better than that of P.
07:15:35 <Cale> Maybe that's impossible, but I don't see why it should be the case.
07:17:28 <int-e> you can combine all those algorithms into a single one, with various thresholds for switching from one to another. and in fact that universal algorithm will do that in a grossly inefficient (in terms of constant factors involved) way.
07:17:36 <int-e> I guess you allocate time like this, assign 1/2^k of the time to running the k-th program, 1/2^k of the time to attempting to prove the k-th program correct. pick the first result of a program that was proven correct. So ultimately the fastest algorithm will win, dominating all the other ones.
07:17:56 <pozic> int-e: right, but that's what is described in his paper.
07:18:00 <Cale> ah, okay
07:18:14 <pozic> The details are kind of boring, but creative.
07:18:25 <Cale> But you need an effective way to construct the sequence of improving programs in that case.
07:18:40 <Cale> hmm
07:18:49 <Cale> I suppose you have one, yeah.
07:19:07 <pozic> Cale: you can download the paper. What's there to wonder?
07:19:47 <pozic> int-e: do you understand Blum's Speedup theorems?
07:20:19 <pozic> Someone should publish a newly type-set version of his results.
07:23:11 <int-e> pozic: no, but now I'm curious about them
07:26:49 <pozic> The speedup theorems are also only interesting when you have infinite resources.
07:27:15 <pozic> Which makes them operate in a kind of fantasy land. (at least that's what I understood from them)
07:27:49 <pozic> If you have just a simple finite computer (like the one on your desktop), you cannot store algorithms of infinite (ever growing) complexity.
07:28:49 <pozic> And whether or not there exist natural problems which have speedup theorems is still an open question, IIRC.
07:29:00 <Cale> Hmm, so this provides a sort of "cocompleteness" of the space of programs computing a specific function with respect to asymptotic complexity order.
07:29:15 <pozic> Cale: if you define cocompletness, sure ;)
07:29:16 <Cale> I like that.
07:30:24 <ev4378538475843> ests
07:31:04 <pozic> Bot net time!
07:33:09 <Cale> I suppose we only want chain cocompleteness (co-chain completeness?)). If P -> Q means that P is a program which asymptotially takes less time than Q, then for any co-chain ... -> P_n -> P_(n-1) -> ... -> P_0 of programs, we can find a colimit Q such that Q -> P_n for every n.
07:36:50 <Cale> er by "less" I really mean "less than or asymptoticallly equivalent to"
07:37:53 * Cale just has to turn everything into category theory ;)
07:46:44 <Cale> pozic: It's interesting though, that while this algorithm will be asymptotically optimal, the algorithm doesn't actually extract any explicit asymptotic bound.
07:47:36 <Cale> So there's still room to care about what the asymptotic bound *is* for a given function, even if we know that we can construct a program which is optimal.
07:48:30 <zygoloid> Cale: suppose there were such a chain of programs with better and better asymptotic bounds. if you used P_n for problems of size n, wouldn't that give you the limit you want?
07:49:16 * zygoloid is not quite sure whether that works, but it seems plausible
07:50:19 <zygoloid> (of course, that assumes you can compute the size of the problem quick enough...)
07:51:29 <zygoloid> are we assuming that the sequence P_i is computable?
07:58:00 <Cale> zygoloid: Yeah, that works.
07:59:53 <Cale> zygoloid: I suppose there's actually more to this, in that this algorithm actually sifts through the set of all programs which compute the function, and doesn't bother attenpting to compute explicitly how they're related asymptotically, but instead just runs them all in parallel with different frequencies.
08:00:39 <Cale> and regardless of how this is done, you end up with something asymptotically optimal
08:05:00 <FliPPeh> Why can you use foreign C functions without being in IO?
08:05:25 <FliPPeh> I'm not sure how I can expect C functions to be free of side effects ;x
08:05:25 <mauke> because some of them are pure
08:07:44 <Zao> FliPPeh: It's something you should know when importing them.
08:07:48 <Vulpyne> Consider a function like C atoi, it will always give the same result given the same input.
08:08:38 <FliPPeh> So I could in therory have impure functions in pure code, breaking a core concept of haskell?
08:08:51 <Vulpyne> Haskell already lets you do that. :)
08:08:53 <jaspervdj> FliPPeh: you can always unsafePerformIO anyway
08:08:54 <nbowler> FliPPeh: Haskell has unsafePerformIO, too.
08:09:03 <Zao> FliPPeh: If you say "yeah, it's indempotent" and it's not, it's your fault.
08:09:10 <Zao> (sic=
08:09:30 <FliPPeh> Hm!
08:10:01 <Cale> Well, it's a property sort of like idempotence you're after, but I'm not sure that's really the correct word to use.
08:10:03 <Zao> Vulpyne: Technically the input is the pointer you feed it :)
08:10:11 <Cale> Idempotent usually means that f . f = f
08:10:35 <Zao> Cale: Wikipedia says that in this usage, it means "same result on several invocations".
08:10:57 <Zao> And as we all know, wikipedia is the ultimate authority on life and everything.
08:11:10 <nbowler> Zao: it's probably referring to several invocations in the f(f(f(f(x)))) sense.
08:11:16 <Zao> What terms _hasn't_ non-mathemagicians corrupted.
08:11:16 <MissPiggy> they are using idempotent to mean that if f(x) = y and f(x) = y' then y = y'?
08:11:18 <Zao> nbowler: No.
08:11:28 <MissPiggy> you should edit that
08:11:34 <ray> would you rather trust cale or wikipedia
08:11:50 <Zao> http://en.wikipedia.org/wiki/Idempotence#In_computing
08:11:50 <badsheepy> the thing i like about wikipedia, is its definitions are self fulfilling properties.. even if its wrong, enough people will read them for its meaning to change to the wrong one :o
08:11:56 <Cale> In the case of a sequential program, I suppose you could say that it's idempotence with respect to >> that we're interested in
08:11:59 <Cale> x >> x = x
08:11:59 <Zao> I know it from both meanings.
08:12:28 <Vulpyne> Zao: Delayed touche. :)
08:13:05 <ray> well in math f(x) always being the same is already implicit
08:13:17 <ray> if f's a function
08:13:28 <mauke> see also attribute((const)) and attribute((pure)) in gcc
08:14:29 <Cale> Hmm, if something is idempotent with respect to >> is that really all we need to say that it's safe to unsafePerformIO it?
08:15:26 <nbowler> Cale: as in x >> x = x ?
08:15:37 <Cale> nbowler: yeah
08:15:42 <jaspervdj> Cale: I can't think of any counterexample
08:15:43 <nbowler> Cale: That doesn't guarantee that x >> y >> x = x.
08:15:55 <Cale> nbowler: indeed.
08:16:40 <nbowler> so y might screw things up in ways that cause unsafePerformIO x to break horribly.
08:16:43 <Cale> Aha, so something which reads a mutable variable, for instance, would be a bad candidate for unsafePerformIO, even though it's sequentially idempotent.
08:16:44 <ray> id >> unsafeNuclearMissile >> id
08:17:05 <Cale> So, that's not really enough.
08:17:27 <Cale> You really want full referential transparency, not just idempotence.
08:18:49 <jaspervdj> anyone care to give an example where x >> x = x and x >> y >> x /= x?
08:18:49 <Cale> Which I suppose we can express as exists v. x = return v (semantically)
08:18:59 <mauke> jaspervdj: strlen
08:19:17 <Cale> jaspervdj: x = readIORef r, v = writeIORef r 0
08:19:31 <Cale> er, "y =" rather
08:20:03 <jaspervdj> Cale: ah, but in x >> x, the IORef could be modified by another thread, right?
08:20:24 <Cale> jaspervdj: Even taking nondeterminism into account, the set of possible results is the same.
08:20:31 <nbowler> jaspervdj: consider a thread-local variant of readIOref instead.
08:20:49 <Cale> (because the other thread might modify the variable before or after the read in any case)
08:21:24 <jaspervdj> nbowler: I see
08:22:20 <Cale> Reading the same IORef twice in a row is semantically equivalent to reading it once, even if there are mutations going on in other threads.
08:23:33 <idnar> so (y >> x) would meet the revised criteria?
08:23:58 <Cale> You really want that  x = return v  for some v.
08:24:13 <Cale> (I think)
08:24:17 <idnar> I guess it wouldn't
08:26:07 <Cale> Hmm, if x >> y = y is that enough in IO to guarantee that x = return v for some v?
08:26:16 <Cale> (that is, for all y)
08:26:27 <Cale> I suppose not.
08:26:43 <Cale> Because x might produce a different value every time, but have no output effect
08:27:06 <nbowler> isn't mutation fun?
08:28:15 <Cale> How about if there exists v such that for all f, x >>= f = f v, does that ensure x = return v in IO?
08:28:41 <Cale> That seems like maybe enough.
08:30:30 <nbowler> Cale: it should be enough because you require it to work when f = return.
08:32:05 <nbowler> x >>= return = return v (premise), x >>= return = x (monad law), therefore, exists v such that x = return v.
08:35:34 <pozic> OMG, they are even sending spam in Debian bug reports now.
08:35:47 <nbowler> who's "they"?
08:36:01 <pozic> nbowler: If I knew they would obviously have already been nuked from orbit already.
08:36:15 <zygoloid> it is, after all, the only way to be sure
08:36:30 <nbowler> unsafeLaunchMissilesAtThem
08:37:13 <pozic> Actually, I could write a program to do that, but by the time the program is done, I am already dead and the person who sent it will be so too.
08:37:43 <pozic> Unless immortality gets mainstream soon, naturally.
08:38:53 * hackagebot upload: haskelldb-hdbc 0.13 - HaskellDB support for HDBC. You will also need one  or more back-end specific packages. (JustinBailey)
08:39:41 <zygoloid> Cale, nbowler: (newIORef 42 >> return v) >>= f = f v, forall f.
08:39:53 * hackagebot upload: haskelldb-hdbc-odbc 0.13 - HaskellDB support for the HDBC ODBC driver. (JustinBailey)
08:40:16 <zygoloid> i suppose you could argue that (newIORef 42 >> return v) == return v, though...
08:40:55 * hackagebot upload: haskelldb-hdbc-postgresql 0.13 - HaskellDB support for the HDBC PostgreSQL driver. (JustinBailey)
08:40:57 * hackagebot upload: haskelldb-hdbc-sqlite3 0.13 - HaskellDB support for the HDBC SQLite driver. (JustinBailey)
08:40:59 * hackagebot upload: haskelldb 0.13 - SQL unwrapper for Haskell. (JustinBailey)
08:41:11 <Twey> What is HaskellDB?
08:41:56 <pozic> Twey: a DSL for relational algebra mapping to SQL, AFAIK.
08:42:34 <Twey> Ah, I see
08:44:18 <sbahra> ^c0_SendiRIan^ is a spam bot.
08:44:36 <Twey> ‘DSL’ confuses me.  When exactly does something become a DSL?  HXT claims to be a DSL, but it's just a bunch of arrows.
08:44:49 --- mode: ChanServ set +o mauke
08:44:49 --- kick: ^c0_SendiRIan^ was kicked by mauke (/msg me if you're not a spam bot)
08:44:53 <sbahra> " ^c0_SendiRIan^:  Visit us at network chat and get bots + hosting special and free,   /server [...]"
08:45:01 --- kick: ^c0_SendiRIan^ was kicked by mauke (no autorejoin)
08:45:02 --- mode: mauke set +b *!*@95.66.8.206
08:45:16 <Saizan> there's no exactly
08:46:57 <pozic> Twey: DSL is a buzzword.
08:47:01 --- mode: mauke set -o mauke
08:47:06 <pozic> Twey: you are free to delete it from your brain.
08:47:13 <Twey> Heh.  Noted.
08:47:23 <Twey> ‘a for relational…’
08:47:28 <mauke> > reverse "DSL"
08:47:29 <lambdabot>   "LSD"
08:47:38 <Twey> LSD is not a buzzword.
08:47:54 <pozic> LSD has been developed by the CIA.
08:47:55 <Twey> Except in a punny sense.
08:48:02 <FliPPeh> > reverse "lol"
08:48:03 <lambdabot>   "lol"
08:48:12 <pozic> (yes, now I am just stating facts.)
08:48:33 <pozic> Some people claim they can think more clearly with drugs.
08:48:52 <pozic> Does anyone of you do that?
08:48:53 <badsheepy> not the same people who claim lsd was developed by the cia though :p
08:48:57 <FliPPeh> Depending on WHAT you think about, it might be true.
08:49:20 <FliPPeh> If you're thinking about pink elephants, LSD might help thinking more clearly
08:49:32 <pozic> They did some research in the USA and a percentage higher than 10% used it, IIRC.
08:49:41 <pozic> (not LSD, but some kind of drug)
08:49:55 <badsheepy> 'some kind of drug' would be virtually everyone
08:50:47 <mauke> the real question is why it's not called LAD in the USA
08:50:54 <McManiaC> Linking hirc ...
08:50:54 <McManiaC> <command line>: unknown package: HDBC-2.2.2
08:50:56 <McManiaC> hmmm wtf
08:51:01 <pozic> badsheepy: mental performance enhancing drug.
08:51:06 <badsheepy> caffine
08:51:12 <badsheepy> virtually ever.. etc
08:51:21 <pozic> badsheepy: ok, without counting that.
08:51:28 <jlouis> caffeine and ethanol
08:51:31 <pozic> badsheepy: actual pills.
08:51:35 <NeoMojo> nicotine
08:51:43 <Philonous1> mauke "LySergic" ?
08:51:43 <McManiaC> why does he want to link against hdbc-2.2.2 when i have 2.2.3?
08:51:56 <pozic> NeoMojo: since when is that performance enhancing?
08:52:16 <NeoMojo> nicotine is an upper
08:52:22 <pozic> http://www.webmd.com/brain/news/20080409/poll-scientists-use-brain-boosting-drugs
08:52:25 <pozic> There we go.
08:52:42 <pozic> The most popular drug was Ritalin, used by 62% of responders. Provigil was the drug of choice for 44% of those polled -- suggesting that many of the users take more than one drug. Beta-blockers, such as Inderal, accounted for 15% of the drug use.
08:52:51 <Cale> Wow, this captcha actually had the empty string as its solution, though it was confusing because they drew seme random squiggles over it.
08:52:53 <Cale> some*
08:53:32 <doserj> most captchas look to me like the empty string with some random squiggles over it
08:53:39 <NeoMojo> Stimulants can enhance permformance
08:53:54 <Twey> Cale: Was it a ReCAPTCHA?
08:54:18 <Cale> no
08:54:40 <Twey> Interesting
08:54:41 <Cale> It was the 'delete this message' captcha on a mailinator message.
08:55:01 <pozic> It will be a fun day when the botnet people figure out how the universal algorithms work.
08:55:18 <pozic> Self-modifying algorithms impossible to remove.
08:55:24 <pozic> And always improving.
08:55:42 <pozic> I wonder what the "security specialists" will say about that.
08:56:04 <pozic> Probably along the lines of "WTF?".
08:56:56 * ezyang sighs 
08:57:01 <ezyang> Writing fast Haskell code is hard.
08:57:31 <ezyang> not impossible, but hard.
08:58:57 <pozic> ezyang: the key to writing fast Haskell is by not writing slow Haskell.
08:59:02 * hackagebot upload: HDBC-postgresql 2.2.3.1 - PostgreSQL driver for HDBC (JohnGoerzen)
08:59:18 <ezyang> pozic: Not necessarily...
08:59:41 <Philonous1> It's enough to not execute the slow parts
08:59:45 <zygoloid> the key to writing fast haskell is the llvm bindings ;-)
08:59:58 <ezyang> possibly. needs more work there :-)
09:00:05 <pozic> zygoloid: bindings or the compiler?
09:00:07 <ezyang> I look at stuff like the Java HotSpot VM and despair
09:00:32 <zygoloid> pozic: the bindings. though the compiler backend is showing some serious promise
09:00:33 <ezyang> because they've put so many man years into making it so that everyman can write fast code w/o thinking particularly hard
09:01:17 <zygoloid> pozic: ... because the bindings let you write down directly what you want the machine to do, and how :)
09:01:18 <pozic> zygoloid: are there examples of actually doing that?
09:01:26 <Berengal> ezyang: I bet they're kicking themselves for allowing nulls in there
09:01:41 <Berengal> And not separating evaluation from execution
09:01:43 <ezyang> Berengal: Indeed :-)
09:01:56 <ezyang> but once it's warmed up, the JVM is frickin' fast
09:02:16 <Berengal> It is. Comparable to C in some cases
09:02:27 <zygoloid> pozic: yeah, it was on planet a while back. it sounded like you can implement "compileUsingLLVM :: (forall a. Num a => a -> a) -> Double -> Double"
09:02:39 <ezyang> zygoloid: Ha! That's great.
09:02:40 <pozic> zygoloid: oh, right, Lennart did that.
09:03:03 <Philonous1> I wonder if it is desirable to strive for a totally functional programming style
09:03:12 <ezyang> On the bright side, a team I'm on recently rewrote a C executable in Haskell. It only resulted in a +4ns increase in runtime
09:03:16 <MissPiggy> Philonous1: I don't think so
09:03:20 <pozic> Philonous1: it is a lot easier to debug.
09:04:01 <pozic> ezyang: 4ns? Uhm, you cannot even measure that.
09:04:15 <pozic> ezyang: unless you have some special hardware.
09:04:27 <Philonous1> pozic: Maybe it is in a tight loop?
09:04:30 <ezyang> I think the person who did the benchmark did it in aggregate
09:04:49 <ezyang> oh, +4ms, not ns
09:04:52 <ezyang> :o)
09:05:02 <pozic> :)
09:05:04 <Berengal> I find it interesting that when your Haskell program is too slow there's a decent chance you've not been programming at a high enough level of abstraction
09:05:17 <ezyang> Berengal: Really?
09:05:39 <pozic> The only reason my Haskell programs become slow is that it spends a lot of time in GC.
09:05:41 <ezyang> I mean, that could mean you're not using the best abstraction to make the most efficient algorithm feasible
09:05:47 <ezyang> ==pozic
09:05:54 <zygoloid> ezyang: +4ms out of how much? ;-)
09:05:58 <ezyang> 5ms
09:06:08 <ezyang> We have... special needs.
09:06:15 <Berengal> ezyang: Indeed. Not always, obviously, but often enough that it's one of the things I try when I feel a need to optimize
09:06:23 <zygoloid> ezyang: you doing stock market arbitrage or something? :)
09:06:31 <ezyang> Nope. Cat'ing static files
09:06:36 <ezyang> :-D
09:06:42 <Philonous1> MissPiggy: Why not? Symbolic data introduces interpretation, meaning and representation get seperated
09:07:26 <MissPiggy> does that have anything to do with total?
09:08:29 <zygoloid> MissPiggy: i think Philonous1 meant 'totally' as in 'entirely' not as in 'never bottoms out' :)
09:09:00 <MissPiggy> ohhh......
09:09:16 <ezyang> say I have let foo = ... in the IO monad. I want to force the computation of foo so that I can do some timing later on in the program; how could I do this?
09:09:19 <Philonous1> MissPiggy: Oh, I think "totally function" is a fixed term, I didn't mean total programs but totally functional ones
09:09:38 <Berengal> ezyang: foo `seq` return ()
09:09:48 <ezyang> won't return () get optimized away?
09:09:54 <zygoloid> ezyang: evaluate foo
09:09:55 <Berengal> Not in my experience
09:09:58 <zygoloid> @type evaluate
09:10:00 <lambdabot> Not in scope: `evaluate'
09:10:04 <zygoloid> @hoogle evaluate
09:10:04 <lambdabot> Control.Exception evaluate :: a -> IO a
09:10:04 <lambdabot> Control.OldException evaluate :: a -> IO a
09:10:04 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
09:10:11 <Berengal> Oh, yeah, evaluate. I always forget about that one
09:10:17 <ezyang> oh cool, evaluate is it
09:10:36 <Saizan> i'd use foo `seq` return () over evaluate
09:10:51 <ezyang> Saizan: Why?
09:11:23 <Saizan> simply because they didn't find a way to express the semantics of evaluate using only haskell concepts :)
09:11:57 <ezyang> am I allowed a free pass because this is making sure my benchmark isn't bogus :-)
09:12:43 <Saizan> i'd be very surprised if you get any difference between "return $! foo" and "evaluate foo"
09:13:03 <jerome`> > toRational (read "0.1" :: Double)
09:13:05 <lambdabot>   3602879701896397 % 36028797018963968
09:13:11 <jerome`> :(
09:13:16 <Saizan> and if you ignore the result you can use foo `seq` return () too
09:13:42 <zygoloid> @src evaluate
09:13:42 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
09:13:48 <malosh> Hi. Imagine I have an algorithm that needs much memory, but the data structure can be easily broken at some points, serialized in a file, then read again later when I need the final result. From the moral point of view, this is not _unsafe_ IO. Is there an elegant type trick like in the ST monad to allow this ?
09:14:18 <ezyang> i,i "unsafePerformIO"
09:14:24 <zygoloid> i guess the difference is, forcing 'evaluate a' doesn't force a, whereas forcing any of the others does
09:14:30 <pozic> malosh: you have to implement your own ST like monad.
09:14:39 <malosh> ezyang : come on ! would you call that an "elegant type trick" ?
09:14:53 <ezyang> "i,i = I have no point, I just like sayin'"
09:15:05 <malosh> ah ok ;-)
09:15:25 * ezyang is attempting to export memes 
09:15:44 <jerome`> how can the string "0.1" be made into 1 % 10, without rounding?
09:15:46 <pozic> malosh: or you can just use the virtual memory system.
09:15:48 <malosh> pozic : don't you think it can even be done in ST ?
09:15:55 <pozic> malosh: impossible.
09:16:04 <malosh> no, I want to choose when to swap
09:16:12 <nbowler> jerome`: read :: String -> Rational
09:16:24 <zygoloid> nbowler: that expects "a % b"
09:16:24 <pozic> malosh: you can return an ST computation that constructs IO actions.
09:16:25 <Saizan> > read "0.1" :: Rational
09:16:26 <lambdabot>   * Exception: Prelude.read: no parse
09:16:29 <jerome`> > read "0.1" :: Rational
09:16:30 <lambdabot>   * Exception: Prelude.read: no parse
09:16:32 <zygoloid> > read "2 % 5" :: Rational
09:16:33 <nbowler> zygoloid: oh.
09:16:33 <lambdabot>   2 % 5
09:16:40 <quicksilver> > 0.1 :: Rational
09:16:41 <lambdabot>   1 % 10
09:16:49 <ezyang> odd
09:16:51 <malosh> I mean, in ST with unsafePerformIO internally but the forall s. ST s to guarantee that it's still cool ?
09:17:02 <zygoloid> > toRational (read "0.1" :: CReal)
09:17:04 <lambdabot>   * Exception: CReal.toRational
09:17:04 <pozic> malosh: right.
09:17:05 <zygoloid> :(
09:17:35 <Berengal> malosh: You can use unsafeIOtoST to preserve most of the semantics of IO, but make it runable in pure code
09:17:47 <malosh> ok, thanks
09:17:56 <pozic> Berengal: except that that function has no semantics.
09:17:59 <nbowler> jerome`: parse it by hand, I guess :/
09:18:03 <Berengal> It's still going to be unsafe though
09:18:14 <Berengal> pozic: Shh. The compiler doesn't know that
09:18:20 <Saizan> malosh: find what would make your scheme break ref. trasparency, then find a way to prevent that statically, then find a way to encode it in the type system :)
09:18:25 <jerome`> nbowler: my hand!?
09:18:55 <nbowler> jerome`: I mean "write your own function to parse it".
09:18:59 <pozic> malosh: you would probably want to encode that you cannot read and write to the same file at the same time.
09:19:32 <malosh> if I just get a filename that does not exist yet, in a safe place like /tmp, and the file name is not known outside the code segment that does it, does it break the referential transparency ?
09:19:44 <pozic> malosh: but things like that are probably a waste of time unless you are either a researcher wishing to prove a useless point, or work at a ridiculously big company.
09:20:14 <pozic> malosh: another process could come by and kill your semantics.
09:20:14 <malosh> guess what ? I'm in the first case ;-)
09:21:30 <pozic> I am not sure whether the OS you use has a notion of a process owned file.
09:21:37 <gwern> hm. ediff in emacs is pretty cool
09:21:55 <nbowler> It's weird that the read instance for Rational doesn't support the same syntax as the language proper.
09:21:59 <pozic> gwern: kdiff3 > ediff, no?
09:22:01 <malosh> pozic : I'm even sure it does not !
09:22:18 <pozic> malosh: well, then there are certainly no guarantees.
09:22:49 <pozic> malosh: I am however quite sure it is possible on all major OS's.
09:22:57 <pozic> I never did it, though.
09:23:19 <malosh> or maybe it could be possible to talk directly with swap space.
09:23:25 <malosh> Thanks for all this, bye !
09:25:00 <ezyang> LOL!
09:25:12 <ezyang> I just realized why Rich's code seems so much faster
09:25:17 <ezyang> he's doing HALF the sample size
09:25:22 <gwern> pozic: is kdiff3 in my emacs?
09:25:44 <gwern> doing less work. the best way to optimize!
09:25:47 <ezyang> oh man, I would feel so validated if this was actually the case
09:26:22 <ezyang> if the peanut gallery would like to play along: http://groups.google.com/group/clojure/browse_thread/thread/776943086de213f9
09:27:05 <gwern> why are you trying to write a fast haskell map in clojure?
09:27:38 <ezyang> no other way around
09:27:50 <ezyang> Apparently clojure's map is really fast, and I'm trying to get an implementation in Haskell
09:28:00 <ezyang> but I've been failing at getting good performance
09:29:27 <ezyang> I sent mail to haskell-cafe two nights ago, no one's bit yet :-)
09:29:58 <osaunders> ezyang: Map as in data structure?
09:30:06 <ezyang> hash map, yup
09:30:12 <osaunders> Ah.
09:30:14 <ezyang> the "holy grail" of purely functional programming
09:30:22 <osaunders> Why's that?
09:30:47 <ezyang> traditional hash tables, which are the bread and butter of imperative code, are strictly destructive
09:32:58 <Berengal> ezyang: Neat. I thought about doing this, but I'm even lazier than Haskell
09:32:58 <ezyang> Ooh, transient data structures are neat. http://clojure.org/transients Is this like the ST monad?
09:33:05 <zygoloid> ezyang: you're implementing a hash map in haskell? are you aware of the performance issues with arrays in ghc?
09:33:14 <ezyang> zygoloid: I thought they fixed those?
09:33:21 <ezyang> But that might explain why it's so frickin' slow!
09:33:24 <Berengal> zygoloid: Only mutable boxed arrays
09:33:26 <zygoloid> ezyang: if you're using 6.13, i think so
09:33:37 <ezyang> :-) definitely not.
09:34:12 <osaunders> What performance issues are these?
09:34:54 <Berengal> osaunders: The GC has to rescan the entire array even when only one internal object is dirty
09:35:02 --- mode: ChanServ set +o mauke
09:35:02 --- mode: mauke set -b *!*@95.66.8.206
09:35:38 <zygoloid> in 6.13 they started using a card-marking system for (something like) 1K blocks of the array, i think
09:35:42 <ezyang> maybe my "convert everything to tuples using TH" idea isn't so crazy anymore...
09:36:06 <osaunders> Sounds crazy to me :-)
09:36:08 <Berengal> osaunders: Even worse, it has to treat the array as it were of the same generation as the youngest object in it
09:36:41 <Berengal> osaunders: So when you're doing lots of mutations, it has to rescan the entire array on every minor GC
09:36:55 <osaunders> Berengal: I don't really understand what you're saying. :-( but that isn't really surprising given I know nothing about how GHC works at all.
09:36:59 <quicksilver> you can mitigate against this by using multiple small arrays
09:37:02 --- mode: mauke set -o mauke
09:37:11 <ezyang> ok, doesn't sound like my problem
09:37:12 <quicksilver> (only a useful optimisation if "most" of them won't change "most" of the time)
09:37:17 <ezyang> 2-32 sized arrays are not large
09:37:24 <quicksilver> easy to check: use +RTS -sstderr
09:37:30 <ezyang> and they should contain boxed values
09:37:32 <quicksilver> if GC is more than 30% of your time, this is probably youre problem
09:37:37 <quicksilver> s/youre/your/
09:37:40 <ezyang> quicksilver: Well... it is...
09:37:42 <Berengal> quicksilver: At that point you might just as well use regular immutable arrays
09:37:59 <ezyang> but I am using immutable arrays
09:38:07 <Berengal> Then your problem is elsewhere
09:38:16 <ezyang> GC time is 64.7%
09:38:31 <Berengal> ezyang: Profiling time!
09:38:38 * Berengal does a little profiling dance
09:38:40 <ezyang> with a 1G heap, it's much better (only 17.4%)
09:38:47 <ezyang> but the overall performance still sucks
09:38:49 * zygoloid ponders a hashtable using Data.Seq for the table
09:39:17 <Cale> Wait, what? You seem to be using Data.Vector and mutation...
09:39:29 <ezyang> Cale: Really?
09:39:39 <Cale> http://github.com/ezyang/hamt/blob/master/HAMT.hs
09:39:43 <Cale> isn't this it?
09:39:51 <ezyang> (the only thing vaguely mutation-ish should be update, which I thought had copy with a change semantics...)
09:39:57 <ezyang> that's it
09:41:24 <Cale> brb, resetting connection
09:44:09 <Cale> er, okay, sorry about that, it may very well copy
09:44:28 <ezyang> ah, ok
09:44:33 <Cale> unsafeUpdate doesn't sound like an immutable update to me
09:45:06 <Cale> But maybe they just decided that it was unsafe for some other reason?
09:45:16 <zygoloid> Cale: i think unsafe here means no bounds checking
09:45:25 <ezyang> ==zygoloid
09:48:29 <Polarina> Is it somehow possible to catch out-of-memory errors?
09:50:16 <Cale> Polarina: I don't think GHC currently generates HeapOverflow exceptions.
09:50:30 <Cale> But if it did, that's probably what you'd want to catch.
09:52:41 <ezyang> ok, running off to class
09:52:50 * ksf deskbangs
09:52:51 <ezyang> cyall
09:53:15 <ezyang> ksf: Don't deskbang! It's bad for your brain cells
09:53:30 <ksf> ...the proper way to keep track of two monoids on a search set is of course a kd-tree.
09:53:44 <ksf> oh, it's fun.
09:54:13 <ksf> I once did it in the office, and had five people staring at me.
09:54:45 <ksf> ...you just take your forhead and move it down quickly, while making a knocking your knuckles against the table where people can't see it.
09:55:09 <Cale> ksf: If M and N are monoids, then so is their Cartesian product, taking the operation to be elementwise.
09:55:10 <Berengal> There's no point in deskbanging if it's not for real
09:55:42 <ksf> ...but I want to search for them separately, so I can't combine them.
09:55:55 <Cale> ah, I see what you mean
09:56:07 <Twey> ksf: I did it in class once.  People started avoiding me.
09:56:08 <ksf> consider for example a structure that saves strings by both lexicographical order and length.
09:56:10 <Twey> No knuckles, though.
09:57:29 <Cale> So you're indexing the tree with the minimum/maximum string in each subtree, and the minimum/maximum length of a string in that subtree.
09:58:27 <Cale> hmm...
10:00:19 <zygoloid> sounds like a job for a fingertree?
10:00:25 <Cale> Well, yeah
10:00:38 <ksf> ...and, in fact, I think that cache-splay trees are closely related to a kd-tree keeping track of last-recently accessed in one of its dimensions
10:00:40 <Cale> I'm assuming that you're using something like a fingertree, or just a monoidally-indexed tree
10:01:31 <ksf> ...you can't just combine those two monoids. it's like adding apples and bananas.
10:04:31 <ksf> mhh if I store those points in the kd-tree at _relative_ coordinates to their bounding box, I can move all of them together in O(1)
10:05:05 <chrisdone> reet
10:08:48 <Cale> ksf: Of course you can combine those two monoids, seeing as you can combine any two monoids.
10:09:06 <ddarius> @instances Monoid
10:09:06 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:14:13 <Cale> I suppose the problem is that you still have an underlying sequence there, and it's hard to arrange so that splitting in either direction is logarithmic.
10:18:46 <Cale> Er, do you get that with a kd-tree anyway?
10:19:47 <ksf> dunno. I'm brainstorming
10:20:48 <jontore> ls
10:23:24 <noggle> noob trying to understand folds here
10:23:30 <MissPiggy> hi
10:23:33 <Cale> noggle: sure
10:24:21 <sori> would be there some standard alias for       `flip (.)`        ?
10:24:27 <Cale> noggle: I like to understand folds, and particularly foldr, as replacing the structure of the list (or other datastructure) with arbitrary other functions, in a systematic way.
10:24:29 <Cale> sori: no
10:24:31 <gwern> folds are easy. they're just catamorphisms over intial algebras
10:24:41 <sori> Cale: thanks :'(
10:24:48 <MissPiggy> what's an initial algebra
10:25:03 * ksf thinks the best way to understand them is to stare at their source and compare it with explicit recursion, and do the transformations by hand
10:25:14 <noggle> so when I do foldLen = foldr (\_ x -> x + 1) 0, this works on foldLen [someList] because foldLen is merely bound as a synonym to foldr (\_ x -> x + 1) 0, hence the argument to foldLen is actually an argument to foldr
10:25:22 <Cale> noggle: So, every list is either the empty list [], or it is a nonempty list constructed by applying (:) to a first element, and another list
10:25:47 <Cale> noggle: All functions secretly have only one parameter
10:26:07 <Cale> noggle: Functions which appear to have more than one parameter are really functions that produce other functions as their result.
10:26:13 <noggle> ahh so: foldr (+) 1 [1,2,3] = (+) 1 ((+) 2 ((+) 3))
10:26:21 <noggle> wait
10:26:28 <noggle> ahh so: foldr (+) 1 [1,2,3] = (+) 1 ((+) 2 1 ((+) 3 1))
10:26:31 <MissPiggy> yes
10:26:32 <doserj> sori: Control.Arrow.>>> is a generalization of flip (.)
10:26:33 <noggle> jesus
10:26:38 <noggle> or fsm
10:26:38 <Cale> foldr (+) 1 [1,2,3] = (+) 1 ((+) 2 ((+) 3 1))
10:26:40 <xerox> no
10:26:55 <Cale> > foldr (:) [] [1..3]
10:26:56 <lambdabot>   [1,2,3]
10:27:16 <sori> doserj, ah, I'll look at it. thanks:)
10:27:20 <Cale> foldr f z is the function which replaces each (:) in a list with f, and the [] at the end with z
10:27:28 <jmcarthur> > foldr (+) z [a, b, c, d]
10:27:29 <lambdabot>   a + (b + (c + (d + z)))
10:27:31 <Cale> So since [1,2,3] is equal to:
10:27:38 <Cale> 1 : 2 : 3 : []
10:27:41 <jmcarthur> > foldl (+) z [a, b, c, d]
10:27:43 <lambdabot>   z + a + b + c + d
10:27:45 <noggle> I see
10:27:51 <Cale> foldr (+) 1 [1,2,3] is equal to
10:27:53 <noggle> I see!
10:27:55 <noggle> cool!
10:27:59 <Cale> 1 + (2 + (3 + []))
10:28:27 <noggle> thanks Cale!
10:28:27 <Cale> foldl does something related, but more complicated
10:28:31 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
10:28:57 <chrisdone> Cale: did you make this logo? http://tryhaskell.org/
10:29:02 <Cale> chrisdone: no
10:29:02 <heatsink> Is there a tool to get the graph of static references among functions in a module?  It would help me refactor my code.
10:29:06 <chrisdone> who did ;_;
10:29:47 <chrisdone> gwern: did you see try haskell? ^_^
10:29:55 <noggle> wow
10:29:59 <Berengal> chrisdone: That specific logo, or the haskell logo in general?
10:30:04 <Berengal> chrisdone: Nice work by the way :)
10:30:07 <chrisdone> Berengal: the specific one with colours
10:30:26 <noggle> so this means that foldr can replace all of these x : f xs, x + f xs pattern
10:30:29 <noggle> coolio
10:31:00 <chrisdone> Berengal: :D
10:31:19 <Cale> noggle: We can also write folds analogous to foldr for other data types
10:31:48 <Cale> noggle: for example, if we have the binary tree datatype   data Tree a = Tip | Branch a (Tree a) (Tree a)
10:32:19 <Cale> We would write a function which takes replacement functions for Tip and Branch, and replaces the structure throughout a tree:
10:32:41 <Cale> foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
10:32:49 <doserj> heatsink: SourceGraph?
10:33:13 <noggle> ooo
10:33:15 <Cale> and we could use that to write all sorts of useful functions on binary trees then
10:33:17 <noggle> that is shiny
10:33:31 <Cale> size = foldTree 0 (\x l r -> 1 + l + r)
10:33:34 <noggle> this language has all kinds of shiny things
10:33:35 <heatsink> doserj: Cool!
10:33:39 <roconnor> what is a free many-sorted anarchic algebra?
10:34:36 <heatsink> The opposite of an oppressed many-sorted dictatorial algebra
10:34:55 <heatsink> Math names are weird sometimes
10:35:13 <roconnor> I could believe lawlessness has something to do with it
10:36:13 <doserj> I guess anarchic means that it's not even associative?
10:36:54 <FliPPeh> If a code crashes and nobody is around to hear, does it make a sound?
10:37:27 <roconnor> oh, it appears to be just a fancy name for term algebra
10:40:12 <enthymene> A question: can you have more than one class definition per file/module?
10:40:16 <roconnor> though I'm not sure what a free means for a free many-sorted term algebra
10:40:24 <roconnor> emias: yes
10:40:28 <roconnor> enthymene: yes
10:40:29 <enthymene> hehe
10:40:31 <enthymene> okay
10:41:16 <enthymene> followup (stupid sanity check) question: you can choose to export a given class from a module or not
10:41:26 <roconnor> no
10:41:35 <enthymene> hmm
10:41:42 <roconnor> this is one of the terrible things about Haskell
10:41:47 <enthymene> *nod nod* okay
10:41:58 <enthymene> I was hoping you could do cool things like (say) anonymous classes, et cetera
10:42:03 <roconnor> number 1 problem on my list of problems with Haskell
10:42:06 <MissPiggy> did you mean instance?
10:42:13 <enthymene> no, class
10:42:22 <MissPiggy> because for class you just put  module Foo where (Class(..)) ...?
10:42:24 <MissPiggy> or you don't
10:42:30 <Sternmull> isnt record name collision much uglier?
10:42:32 <roconnor> is that the case?
10:42:37 <roconnor> oops
10:42:43 <enthymene> like, if I had two classes in a module M, C1 and C2, that were similar enough that I could define them in terms of a class C'
10:42:55 <enthymene> and thus not repeat myself, but not clutter the namespace with C'
10:43:15 <gwern> chrisdone: no
10:43:19 <enthymene> the alternative being anonymous classes, which would probably not be accessible outside their immediate scope anyway
10:43:21 <roconnor> enthymene: MissPiggy appears to be right
10:43:24 <enthymene> woo!
10:43:28 <roconnor> sorry
10:43:29 <MissPiggy> enthymene yeah but the problem with that is you can't instantiate C1 without instantiating C'
10:43:35 <roconnor> only instances are automatically exported
10:43:43 <roconnor> ah right
10:43:50 <enthymene> hrm
10:43:55 <enthymene> I guess that's true.
10:43:55 <roconnor> I remember this now.  It can be used to create "closed" types
10:44:07 <roconnor> by making a class depend on a class that isn't exported
10:44:12 <gwern> so anyway; I'm collecting 'nub' implementations. I have prelude, toList . fromList, the map head . group one, inserting into a Set linearly, and andy gill's work-wrapper Set version
10:44:16 <gwern> am I missing anyone?
10:44:18 <roconnor> er to create "closed" classes
10:44:36 <enthymene> yeah, roconnor, MissPiggy seems to be saying that (brain still expanding to store new data :P)
10:44:53 <Polarina> Configuring Cabal-1.6.0.2...   Setup.hs: failed to parse output of 'ghc-pkg dump'
10:44:56 <Polarina> What to do?
10:44:56 <enthymene> but then again I'd be loath to create closed types unless I really had to </hippie>
10:45:36 <roconnor> MissPiggy++
10:45:39 <enthymene> Haskell's classes are sooo much easier to get one's head around than O'Caml's parameterized types
10:46:50 <opqdonut> yay, a judiciously placed seq saves the day!
10:47:44 <heatsink> Polarina: Do you know if the problem is in the package index, or in Cabal's parser?  You can probably test by running 'ghc-pkg dump' and see if it prints the package index or an error message
10:47:59 <Polarina> heatsink, running 'ghc-pkg dump' works fine manually.
10:48:18 <Polarina> heatsink, I just downloaded cabal and I am trying to configure it for compilation.
10:48:25 <enthymene> hrm, okay
10:48:45 <dcoutts_> Polarina: you're probably using cabal version 0.6.2 but with ghc-6.12. You need to upgrade the cabal program (which is provided by the package cabal-install)
10:48:46 <enthymene> so I have a data Expr = Const Float | Var String | ... deriving Show
10:48:53 <trust1024> hi all, why can help me with visualbasic?
10:49:02 <Polarina> dcoutts_, I downloaded the latest version of cabal.
10:49:13 <enthymene> can I "instance Show a => Show Expr where show = printExpr" (where printExpr pretty-prints alegbraic expressions?
10:49:21 <MissPiggy> enthymene: no
10:49:25 <dcoutts_> Polarina: you can check with cabal --version
10:49:26 <enthymene> :/ durn
10:49:29 <trust1024> hi all, why can help me with visualbasic?
10:49:38 <copumpkin> no
10:49:40 <enthymene> MissPiggy: why not?
10:49:44 <MissPiggy> enthymene because what is a?
10:49:45 <Polarina> dcoutts_, cabal: command not found
10:49:54 <enthymene> aaaah
10:49:55 <enthymene> okay
10:50:08 <MissPiggy> enthymene anyway you already defined Show
10:50:15 <MissPiggy> no point doing it twice
10:50:23 <dcoutts_> Polarina: oh, are you using runghc Setup.hs then?
10:50:28 <Polarina> dcoutts_, yes.
10:50:47 <dcoutts_> Polarina: and using ghc-6.12?
10:51:04 <Polarina> dcoutts_, yes.
10:51:25 <dcoutts_> Polarina: that's pretty odd then since ghc-6.12 comes with the Cabal-1.8 library already
10:51:40 <dcoutts_> and Cabal-1.6 does not even compile with ghc-6.12
10:51:55 <dcoutts_> Polarina: are you sure that you don't have ghc-6.10 installed too? perhaps runghc is using 6.10
10:52:22 <Polarina> dcoutts_, I have never installed ghc 6.10 -- yes I am certain.
10:52:34 <Polarina> I compiled 6.12 myself.
10:52:48 <enthymene> yeah MissPiggy
10:52:57 <enthymene> was fixing that in the another workspace
10:53:00 <dcoutts_> Polarina: ohh, I see what you're trying to do. You're trying to install Cabal-1.6 for ghc-6.12
10:53:00 <enthymene> er, another workspace
10:53:01 <Berengal> Polarina: How did you compile 6.12 without having 6.10 installed?
10:53:09 <Polarina> Berengal, 6.8
10:53:12 <Berengal> Ah
10:53:23 <enthymene> since I already know that (Sum (Const 1) (Prod (Const 2) (Const 3))) looks the way it does
10:53:25 <Polarina> But I uninstalled that.
10:53:42 <enthymene> I'd rather have it show as "(1.0 + 2.0*3.0)"
10:54:19 <dcoutts_> Polarina: is that right, that you're attempting to compile/install Cabal-1.6 ?
10:54:24 <Polarina> dcoutts_, yes.
10:54:30 <Berengal> enthymene: It's just a style issue, but normally the Show class is used for uglyprinting that can be parsed back in again with the Read instance (if any).
10:54:31 <dcoutts_> Polarina: ok, don't do that :-)
10:54:39 <dcoutts_> Polarina: ghc-6.12 already comes with Cabal-1.8
10:54:45 <Polarina> dcoutts_, o.O
10:54:46 <dcoutts_> and 1.6 will not work with ghc-6.12
10:54:58 <Polarina> dcoutts_, why don't I see it on the official webpage.
10:55:06 <Polarina> dcoutts_, And how do I install cabal-1.8 then?
10:55:27 <dcoutts_> Polarina: it's already installed, it comes with ghc-6.12
10:55:31 <dcoutts_> you don't need to do anything
10:55:39 <Polarina> dcoutts_, it's not installed.
10:55:50 <dcoutts_> ghc-pkg list Cabal
10:56:02 <dcoutts_> Polarina: did you accidentally uninstall it?
10:56:04 <Polarina> /usr/local/lib/ghc-6.12.1/package.conf.d   Cabal-1.8.0.2
10:56:07 <Polarina> dcoutts_, I did not.
10:56:09 <dcoutts_> ok, there it is
10:56:13 <Polarina> I only installed ghc.
10:56:34 <dcoutts_> so it is installed
10:56:42 <Polarina> Then how come I don't see it?
10:56:47 <enthymene> Berengal: aaah, hadn't thought of that
10:56:51 <enthymene> well, it's a cool experiment anyway
10:57:06 <Igloo> Polarina: Are you looking for Cabal the Haskell library, or cabal the executable program?
10:57:13 <dcoutts_> Polarina: are you talking about the command line program 'cabal' ?
10:57:15 <Polarina> Igloo, Cabal to install stuff.
10:57:21 <Polarina> dcoutts_, I don't know.
10:57:22 <enthymene> and I'm working on converting ghci into a poor-smart-person's alternative to Mathematica in the long run.
10:57:28 <Polarina> Just something to install nice things from hackage.
10:57:38 <Igloo> dcoutts_: Wasn't there a plan to rename one or the other? What happened to that?
10:57:40 <dcoutts_> Polarina: the library is already installed, the 'cabal' program is separate, in the package cabal-install
10:57:48 <enthymene> sort of Hoctave, or Oskell, or HaskMat.
10:57:49 <Polarina> dcoutts_, where do I get that?
10:58:04 <dcoutts_> Polarina: it's on hackage
10:58:07 <doserj> http://hackage.haskell.org/package/cabal-install
10:58:11 <Polarina> dcoutts_, 0.6.2?
10:58:18 <dcoutts_> you need 0.8.x
10:58:25 <Polarina> Stupid webpage. :(
10:58:43 <dcoutts_> since you're using ghc-6.12
10:59:00 <dcoutts_> Igloo: it'll happen when we get the opportunity to reorganise the libs
10:59:20 <Berengal> dcoutts_: Does cabal-install build on a clean ghc install now, without bootstrap.sh?
10:59:45 <dcoutts_> Berengal: the bootstrap gets the deps that do not come with ghc
10:59:58 <Polarina> dcoutts_, it asks for dependencies.
11:00:06 <dcoutts_> Berengal: so if you've got those deps installed already then you don't need the bootstrap.sh
11:00:28 <Igloo> Berengal: Building on a clean GHC install is exactly what bootstrap.sh is for
11:00:41 <dcoutts_> Polarina: btw, all this business is the reason that the ghc download page still recommends the Haskell Platform rather than the 6.12 dev release
11:00:48 <Berengal> Polarina: http://www.haskell.org/cabal/release/cabal-install-0.8.0/cabal-install-0.8.0.tar.gz
11:01:30 <Polarina> Berengal, thanks.
11:01:38 <Polarina> dcoutts_, why not just make it easy?
11:01:55 <Berengal> /someone/'s forgotten to update their webpage
11:02:00 <dcoutts_> Polarina: that's exactly what the Haskell Platform does
11:02:13 <Polarina> And bootstrap.sh installed cabal into my home directory. :(
11:02:44 <dcoutts_> Polarina: but we also need to be able to make developer/early-adopter releases of the compiler so that package maintainers can fix things up before end-user Haskell Platform releases
11:02:45 <Polarina> How do I get it in /usr/local?
11:03:12 <doserj> mv cabal /usr/local/bin/
11:03:16 <Polarina> o.O
11:03:22 <dcoutts_> or there's a flag to bootstrap
11:03:22 <doserj> *cough*
11:03:24 <Polarina> Can't I just make bootstrap install it there somehow?
11:03:54 <dcoutts_> Polarina: yes, though there's no real need, the default for cabal-install is also to do per-user installs
11:04:30 <Polarina> dcoutts_, I just bootstraped and Setup.hs still asks for dependencies.
11:05:25 <Berengal> Don't you have the cabal program now though?
11:05:39 <dcoutts_> Polarina: if the bootstrap was successful then you're done, you've got the cabal program installed.
11:05:47 <Polarina> At the wrong location...
11:05:50 * hackagebot upload: powerpc 0.0.0 - Tools for PowerPC programs. (TomHawkins)
11:05:51 <Berengal> mv
11:06:07 <Polarina> I wish to install it properly.
11:06:17 <dcoutts_> the reason the Setup.hs complains is because by default Setup.hs does global installs, but the bootstrap has done per-user installs of the dependent libs
11:06:28 <Polarina> Oh, that's not good.
11:06:39 <Polarina> I'll just install those packages manually then.
11:06:49 <dcoutts_> there's a flag for the bootstrap to do a global install
11:06:56 <Polarina> dcoutts_, what flag?
11:07:05 <Saizan> ./bootstrap.sh --help
11:07:12 <dobie_gillis> Polarina: what distro are you using? some have a cabal-install package, though it may be too old for use with ghc6.12
11:07:26 <Polarina> dobblego, Ubuntu 9.10.
11:07:57 <Polarina> http://codepad.org/DDkOW3IS
11:08:03 <dobie_gillis> Polarina: have you tried 'aptitude search cabal'?
11:08:17 <Polarina> dobie_gillis, that's outdated.
11:08:24 <dcoutts_> Polarina: as ./bootstrap.sh --help says, the flag is --global
11:09:09 <Polarina> dcoutts_, http://codepad.org/DDkOW3IS
11:09:15 <Berengal> Polarina: The first few lines of the bootstrap.sh script tells you everything you need to know about how to use it
11:10:48 <dcoutts_> Polarina: mm, yep that's a bug. The script finds the local per-user installed libs but of course for a global install those are not available.
11:10:56 <Polarina> dcoutts_, :(
11:11:02 <Polarina> dcoutts_, how do I uninstall the local ones?
11:11:08 <dcoutts_> Polarina: workaround: ghc-pkg unregister the per-user ones. Sounds like you didn't want them anyway.
11:11:11 <Berengal> Polarina: ghc-pkg unregister the packages, and remove them from ~/.ghc
11:11:23 <Polarina> unregister how?
11:11:24 <heatsink> I think it's ~/.cabal
11:11:35 <heatsink> ghc-pkg unregister zlib --user
11:11:40 <Berengal> Maybe the actual libs are in ~/.cabal...
11:12:11 <dcoutts_> Berengal: the actual files are in ~/.cabal but the important thing is the ghc-pkg registration info
11:12:28 <Berengal> Indeed
11:12:59 <Berengal> Except gtk2hs, which installs itself in ~/.ghc (as I just found out, but it doesn't use cabal anyway)
11:13:18 <dcoutts_> Berengal: wtf?
11:13:22 <dcoutts_> that's not good
11:13:42 <Berengal> Meh, it's probably my fault
11:13:45 <heatsink> Polarina: The unregister command will make ghc-pkg and cabal ignore the packages.  Then, you can delete the library from ~/.cabal/lib/libraryname
11:13:56 <Berengal> I messed around with the prefixes before installing it
11:13:56 <heatsink> s/ignore/forget
11:14:22 <Polarina> heatsink, seems to work now.
11:17:13 <opqdonut> are tuples any faster than a custom two-field datatype?
11:17:37 <heatsink> opqdonut: I would expect the opposite.
11:17:40 <opqdonut> my program is spending lots of time dissecting and reassembling a simple two-field datatype :/
11:18:07 <opqdonut> and I don't want to lose generality by manually specialising it to two accumulator variables
11:18:46 <Polarina> How do I make cabal install things globally?
11:19:00 <Heffalump> opqdonut: does making it strict help?
11:19:05 <opqdonut> Heffalump: it already is
11:19:11 <opqdonut> unpacked also
11:19:11 <heatsink> opqdonut: Is the worker-wrapper transformation not happening?
11:19:14 <Heffalump> how about making the code that passes it around strict in the datatype?
11:19:15 <heatsink> Polarina: --global
11:19:16 <dcoutts_> Polarina: --global, and you can set that as a default in the ~/.cabal/config file. You can also set a sudo command.
11:19:22 <Heffalump> also, how about making it *not* unpacked?
11:19:41 <opqdonut> it's two Ints
11:21:29 <opqdonut> also, not being able to specialize over module boundaries is a bore
11:24:15 <noggle> this language is like having programming super powers
11:24:22 <noggle> there are so many cool features
11:24:37 <enthymene> hehe
11:24:38 <noggle> I wish I would have learned this before java or python
11:24:52 <enthymene> have you ever programmed something bottom-up noggle?
11:25:55 <zygoloid> @remember noggle this language is like having programming super powers
11:25:55 <lambdabot> It is stored.
11:26:00 <noggle> enthymene: I am working on something right now that is bottom up
11:26:12 <enthymene> :3 it's fun ain't it
11:26:17 <noggle> it is a ridiculously large system in php
11:26:23 <noggle> and I am seeing this code
11:26:25 <enthymene> I made the majority of an artillery game in Scheme in about an hour that way
11:26:26 <noggle> and these constructs
11:26:33 <enthymene> it was was a crazy experience.
11:26:49 <enthymene> oh man,PHP
11:26:59 <enthymene> I have to learn that for my job, once they stop making me write PL/SQL for them.
11:27:18 <ksf> ...there's another implementation strategy than bottom-up?
11:27:23 <noggle> and I am seeing ways and methods that will A: Cut my dev time by >50% when I actually grasp this language B: Allow me to have fun.
11:27:35 <noggle> designing systems in php is not fun for me
11:27:41 <enthymene> ksf: yes, doing it wrong and then doing it over
11:27:45 <enthymene> a.k.a. waterfall
11:28:05 <ksf> oh, I'm doing that, too, just bottom-up
11:28:09 <Berengal> waterfall is a project methodology, not a programming strategy
11:28:10 <enthymene> hahahahaha
11:28:15 <sbahra> PHP isn't a good choice for large systems, in my opinion. You don't really have constructs to reap all benefits of good system structure.
11:28:21 <enthymene> Berengal: I'm being flippant, of course
11:28:46 <noggle> this whole pattern matching on types business
11:28:47 <ksf> imposition of structure escalates disorder
11:28:49 <noggle> awesome
11:29:10 <ksf> ...which is the reason why all those design-pattern guys are plain nuts.
11:29:46 <enthymene> eh, design pattenrs have proved useful to me when I'm forced to use an OO language.
11:29:53 <Berengal> ksf: Design patterns are good to know and all around us. You're probably thinking of "design patterns" though, in which case I wholeheartedly agree
11:30:11 <enthymene> not hugely useful, but then I didn't study them deeply
11:30:16 <ksf> enthymene, there you've got it. forcing stuff into OO is the first level of escalation
11:30:43 <enthymene> eh, I view Object definitions as just another means of abstraction.  I don't like it, but I can't really denigrate it beyond that.
11:30:49 <Cascade_> New programming forum! http://www.hackersrus.info JOIN!
11:31:09 <ksf> ...that object system for haskell that's been recently posted to reddit is nice, though.
11:31:15 <aledge> >>= id !
11:31:17 <ksf> really nice, to be precise.
11:31:55 <sbahra> ksf, imposition of structure escalates disorder? Why do you think this?
11:32:21 <ksf> it's the law of preservation of chaos
11:32:28 <enthymene> ah, ksf is a discordian
11:32:41 <sbahra> ksf, at least in systems structure this imposition has had good results at least for NetBSD, FreeBSD and Solaris (let's say, compared to Linux).
11:32:57 <enthymene> I think we need to ask ksf to define structure first.
11:33:10 <sbahra> Good point.
11:33:22 <ksf> order = structure = both illusions.
11:33:38 <enthymene> now, as per my own loose definition of structure, I think structure in programming should be recognized, not imposed.
11:33:48 <sbahra> ksf, huh? That is not a definition. :-P
11:33:57 <enthymene> but then I'm a haskell/lisp type so I'm prejudiced
11:34:20 <enthymene> and disregard the irony of me referring to myself as a "lisp type"
11:34:36 <ksf> sbahra, you can insert that, and disorder = illusion into the law and get "imposition of one illusion escalates its counterillusion"
11:35:53 <gwern> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8110#a8110 <-- what am I doing wrong here with the C bits?
11:35:55 <ksf> the very thing that you _think_ makes a program easier to manage (design patterns) makes it _harder_ to manage because of all that cruft you have to change as soon as you realize that no abstraction is eternal.
11:35:58 <enthymene> well, I thought he was discordian.  Now.. I am dissapoint...
11:36:32 <sbahra> ksf, of course, the key is to make clear your design and performance goals.
11:37:01 <ksf> form follows function
11:37:08 <enthymene> oh yay, slogans.
11:37:20 <tomoj> enthymene: why disappointed?
11:37:22 <ksf> bauhaus coding
11:37:31 <enthymene> tomoj: not dissappointed, "dissapoint"
11:37:58 <Cascade_> New programming forum http://www.hackersrus.info/index.php JOIN!
11:38:04 <enthymene> http://knowyourmeme.com/memes/son-i-am-disappoint tomoj
11:38:05 --- mode: ChanServ set +o Heffalump
11:38:07 <sbahra> Cascade_, fuck off.
11:38:17 <tomoj> I guess I meant, what made you think he wasn't a discordian?
11:38:19 <sbahra> Cascade_, please don't spam us.
11:38:21 <enthymene> nothing says "fuck off" like mode +b
11:38:36 <enthymene> tomoj: he started relying on fixed definitions
11:38:39 <enthymene> dead giveaway
11:38:44 --- kick: Cascade_ was kicked by Heffalump (no spam please)
11:39:13 <ksf> enthymene, definitions like "and, or, a, the"?
11:39:17 <enthymene> yeah
11:39:20 <enthymene> exactly those
11:39:23 <ksf> or "yeah"?
11:39:25 <enthymene> glad to see you recognize your problems
11:39:34 <enthymene> no, yeah is suitably vague
11:39:52 <sbahra> I don't understand ksf's point, in all honesty. I don't see an alternative to structure (there is always structure). There is always structure imposed. Some structures have useful properties for certain problems.
11:40:03 <ksf> so by your definition being discordian is about expressing oneself in a fuzzy way?
11:40:13 <enthymene> well we've still yet to define structure in the sense of programming
11:40:16 <ksf> I always assumed those were properties of teabag-swingers.
11:40:25 <enthymene> oh, I swing teabags too
11:40:31 <enthymene> sometimes I do it in a rigidly defined way
11:40:35 <gwern> nobody familair with the C FFI?
11:40:35 <sbahra> "<ksf> the very thing that you _think_ makes a program easier to manage (design patterns) makes it _harder_ to manage because of all that cruft you have to change as soon as you realize that no abstraction is eternal."
11:40:52 <enthymene> yeah, he was conflating design patterns with structure in general there
11:41:14 <enthymene> I'd agree with him on that point though, I think
11:41:18 <ezyang> gwern, sorry missed your paste
11:41:19 <gbacon> what's the name of scanl's cousin that does the scan without accumulation?
11:41:24 <gwern> ezyang: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8110#a8110
11:41:31 <sbahra> Why do you assume people who use design patterns assume abstraction is eternal to begin with? Structure is, I think, among other things...a limited abstraction (by definition).
11:41:34 <enthymene> map, gbacon?
11:41:48 <gbacon> e.g., git the list of differences between successive ints a list of
11:41:56 <enthymene> oh
11:41:56 <gbacon> e.g., git the list of differences between successive ints in a list
11:41:56 <enthymene> umm
11:42:00 <enthymene> that sounds like you need to zip
11:42:01 <enthymene> and then map
11:42:02 <gwern> hm. '`which ghc` --make -lfpstring -L./ -I./ archive-disk.hs' doesn't work either
11:42:03 <Polarina> dcoutts_, what do I change in ~/.cabal/config to make installs only global?
11:42:04 <sbahra> enthymene, yes, of course there are trade-offs. Sometimes you can also make unnecessary trade-offs if you don't employ the correct design patterns.
11:42:08 <ksf> the hodgepodge isn't as yin-yang. yin-yang doesn't include chaotic reversal of polarities.
11:42:08 <Heffalump> \xs -> zipWith (-) xs (tail xs)
11:42:14 <gbacon> ok, zip and tail
11:42:16 <sbahra> heh, ksf
11:42:16 <enthymene> 'zactly
11:42:26 <ezyang> gwern: When I was doing this, I had to make a .so file, and then link that in
11:42:31 <heatsink> gwern: add the C file to ghc's command line
11:42:35 <ezyang> I couldn't get it to work with just .o
11:42:36 <dcoutts_> Polarina: it's the one called user-install
11:42:51 <gbacon> > let l = [10, 15, 27, 33] in map (uncurry (-)) (zip l (tail l))
11:42:52 <Polarina> dcoutts_, no such thing.
11:42:52 <gwern> heatsink: hm. that gets me a bunch of errors, but that's still progress
11:42:53 <lambdabot>   [-5,-12,-6]
11:43:07 <gbacon> > let l = [10, 15, 27, 33] in map (uncurry $ flip (-)) (zip l (tail l))
11:43:08 <lambdabot>   [5,12,6]
11:43:19 * monochrom misreads "C FFI" as "how to call C code from C code" - hey, that's easy, just add "extern int the_outside_func(char *a, int b);"... :)
11:43:40 <ezyang> no no, that's "how to call asm code from C code"
11:43:41 <heatsink> gwern: What does it do?
11:43:47 <gwern> ah, got it! trim the stuff I wasnt using and remove the -lfpstring call
11:43:51 <gbacon> ?pl \l -> map (uncurry $ flip (-)) (zip l (tail l))
11:43:51 <lambdabot> map (uncurry subtract) . ap zip tail
11:43:54 <Polarina> dcoutts_, what do I add?
11:44:01 <dcoutts_> Polarina: perhaps you've got an old version of the ~/.cabal/config from a previous installation? if so, just rm it and let it be re-created by e.g. cabal update
11:44:05 <ezyang> cool. For my benefit, mind pasting the final command? :-)
11:44:05 <gwern> heatsink: oh, it's a bit of C that looks for \0 in a file
11:44:13 <copumpkin> gbacon: I think it can be easier than that
11:44:16 <gwern> heatsink: which indicates whether it is binary or textual
11:44:19 <copumpkin> :t \l -> map (uncurry $ flip (-)) (zip l (tail l))
11:44:20 <lambdabot> forall a. (Num a) => [a] -> [a]
11:44:31 <Polarina> dcoutts_, it's still not there.
11:44:37 <copumpkin> > ap (zipWith (flip subtract))
11:44:38 <lambdabot>   []->
11:44:38 <lambdabot>    []
11:44:38 <lambdabot>  [-2]->
11:44:38 <lambdabot>    []
11:44:38 <lambdabot>  [-2,-1]->
11:44:40 <lambdabot> [5 @more lines]
11:44:43 <copumpkin> :t ap (zipWith (flip subtract))
11:44:45 <lambdabot> forall b. (Num b) => ([b] -> [b]) -> [b] -> [b]
11:44:48 <copumpkin> whoops
11:44:53 <copumpkin> something like that, anyway
11:45:06 <dcoutts_> Polarina: can you paste it somewhere please?
11:45:06 <heatsink> gwern: I was actually asking what the compile errors were.  You solved it though.
11:45:31 <Polarina> dcoutts_, http://codepad.org/MWQWnzno
11:45:45 * ezyang is still using ghci -lffi -lthecthing Module 
11:45:50 <dcoutts_> Polarina: oh, it is there
11:46:02 <Polarina> dcoutts_, no, it's not.
11:46:08 <dcoutts_> just uncomment it and change it from True to False
11:46:14 <Polarina> Ok.
11:46:26 <dcoutts_> Polarina: see it? line 29 "-- user-install: True"
11:47:34 <Polarina> dcoutts_, I see it.
11:48:00 <Polarina> Cool, it works.
11:50:54 <RayNbow> copumpkin, already awake? :p
11:51:02 * RayNbow looks at the time
11:51:02 <copumpkin> yeah :(
11:51:11 <gbacon> :t ap (zipWith subtract) tail
11:51:11 <RayNbow> you didn't get much sleep then
11:51:12 <lambdabot> forall a. (Num a) => [a] -> [a]
11:52:17 <gbacon> > ap (zipWith subtract) tail [4, 8, 15, 16, 23, 42]
11:52:19 <lambdabot>   [4,7,1,7,19]
11:52:19 <RayNbow> btw copumpkin, raising an adjacency matrix to the 2nd power results in a rather dense matrix
11:52:20 <copumpkin> gbacon: yeah, that's what I meant :)
11:52:35 <gbacon> @karma+ copumpkin
11:52:35 <lambdabot> copumpkin's karma raised to 6.
11:52:41 <copumpkin> RayNbow: do you understand the "graphical" interpretation of the power?
11:53:11 <RayNbow> copumpkin: yes, A^k(i,j) = #paths from i to j with length <= k
11:53:27 <copumpkin> ok :)
11:53:49 <RayNbow> so if A^2 is rather dense, that means you can reach most nodes within 2 hops
11:53:53 <copumpkin> yeah
11:54:08 <RayNbow> it also means your hard disk is getting filled rather quickly :p
11:54:11 <copumpkin> lol
11:54:23 <copumpkin> what's the matrix from?
11:54:49 <RayNbow> I crawled a few BitTorrent swarms last September
11:54:56 <copumpkin> ah
11:55:34 <RayNbow> I believe the ones I posted on Twitter are from some Transformers 2 torrent :p
11:55:47 <balor> I'm getting a linker symbol issue when cabal installing hashed-storage.  Any idea how to solve it? http://www.fpaste.org/9UAW/
11:55:48 * RayNbow just picked the top 10 largest swarms on TPB to crawl
11:56:00 <copumpkin> RayNbow: draw the graph!
11:56:55 <dcoutts_> balor: check if you've got more than one instance of the old-time lib registered
11:57:27 <RayNbow> copumpkin: you mean the actual graph with links between peers?
11:57:42 <bla123> i set library-profiling to true in my cabal config and i cannot cabal-install tagsoup - ghc tells me that the profiling library for network may be missing. does the haskell platform not contain profiling libraries?
11:57:48 <copumpkin> RayNbow: yep
11:58:01 <copumpkin> sfdp from graphviz could probably handle that graph without too much pain
11:58:01 <gwern> huh. so that's why unsafeperformio.com is down: gill says it was hacked
11:58:02 <RayNbow> I tried that already... too many nodes :p
11:58:05 <gwern> good reason
11:58:22 <RayNbow> that is, visually too many nodes
11:58:25 <copumpkin> ah
11:58:32 <RayNbow> I did make a graph of an Ubuntu swarm
11:58:45 <Twey> gwern: Too unsafe ;)
11:58:51 <RayNbow> copumpkin: http://www.tribler.org/trac/attachment/wiki/DistributedTracker/graph-ubuntu-swarm.eps
12:00:00 <copumpkin> RayNbow: I think you'd get a much nicer graph out of it with sfdp
12:00:20 <copumpkin> RayNbow: that's what I used for the twitter graphs I was posting yesterday
12:00:22 <RayNbow> hmm, I think that graph was created with sfdp...
12:00:23 <dcoutts_> bla123: depends on the point release and whether you used the generic source installer
12:00:30 <RayNbow> or perhaps it was fdp...
12:00:50 <copumpkin> it doesn't look like the sfdp output I'm used to, but maybe :) I haven't played with fdp much
12:01:51 <bla123> _dcoutts: it's the binary 2.0.2 - if it does not contain profiling libraries, will future versions contain them?
12:05:13 <c_wraith> bla123: you just need to install it with profiling turned on
12:06:09 <bla123> the strange thing is, i can compile several other libraries with profiling turned on ... does that mean that only some profiling libraries are missing from the haskell platform?
12:06:31 <enthymene> man, I'm on some sort of alt.religion kick this week
12:06:42 <c_wraith> bla123: cabal install --reinstall -p binary-2.0.2
12:07:00 <enthymene> editor wars on dorksnet, SubGenius trolling on otherworlders, and accusing people of sham-discordianism here :p
12:07:03 <mreh> enthymene: is that emacs?
12:07:14 <enthymene> mreh: yeah, Church of Emacs
12:07:23 <enthymene> I'm IRCing from inside emacs right now.
12:08:16 <bla123> c_wraith: thx, but i already tried that. network won't build for some reason (linking problems, i guess), so i'd rather use the version from the platform and turn profiling off
12:08:50 <balor> Why might package "base" be hidden on my machine? "Could not find module `Control.Exception.Base': it is a member of the hidden package `base'"
12:09:22 <aavogt> different versions of base?
12:09:23 <ksf> ...base can be hidden by another version of base
12:09:27 <ksf> use -v to find out
12:09:51 <balor> ah
12:09:55 <bla123> balor: pkg-cfg list
12:10:24 <c_wraith> balor: you're using cabal and don't list base in the dependencies?
12:10:28 <bla123> balor: you can use expose and hide to swap the packages
12:10:34 <RayNbow> copumpkin, sfdp seems to produce denser graphs
12:10:40 <copumpkin> ah
12:11:03 <balor> c_wraith: I'm trying to compile the latest directory, and it's failing because of a hidden base.
12:11:39 <bla123> balor: sry, ghc-pkg
12:11:40 <RayNbow> copumpkin: http://tmp.shinnonoir.nl/sfdp-test.eps
12:12:02 <Ziphilt> is BONUS here now?
12:12:23 <mietek> Any Mac OS X/homebrew users?  http://github.com/mxcl/homebrew/issues/#issue/815
12:12:56 <copumpkin> RayNbow: cute!
12:13:09 <balor> bla123: thanks.  I've only got one version of base installed "base-4.1.0.0"
12:13:25 <RayNbow> copumpkin: yeah, but in this case I prefer the output of fdp :p
12:13:35 <bla123> balor: if it has parenthesis around it, it's hidden
12:13:40 <copumpkin> RayNbow: I found that changing the opacity of the edges makes things clearer. I'd make smaller colored dots for nodes with no border, set edges to be 0x22 alpha
12:14:15 <bla123> balor: you can use "ghc-pkg expose" to unhide packages
12:14:28 <copumpkin> be careful not to expose in public
12:14:30 <balor> bla123: It's not reported as being hidden
12:14:35 <copumpkin> you can get a fine for that
12:15:09 <balor> bla123: There _are_ two versions though....3.0.3.1 and 4.1.0
12:15:33 <bla123> balor: maybe directory depends on the older, hidden version?
12:15:37 <RayNbow> copumpkin: how small is small? I currently use height/width=0.1
12:15:45 <copumpkin> RayNbow: hm, not sure :)
12:17:18 <bla123> balor: with my installation, none of the base packages is hidden. i guess it's the same with yours. i'm afraid i can't help you in that case
12:17:39 <balor> bla123: Thanks.
12:22:49 <sizur> Cale & Alpounet: thanks guys for earlier (GC)
12:25:09 <litherum> Hello, all!
12:25:15 <Botje> hi litherum!
12:35:09 <iFire> if I'm calling to haskell from c and I run multiple processes how much overhead is the RTS
12:36:10 <sizur> ZipList feels like a hack
12:38:33 <ray> i assume you're referring to newtype wrapping to get alternate instances?
12:41:54 <sizur> ray: yep, exactly
12:42:32 <ray> yeah, it does give one a strange feeling of sorts
12:43:22 <maurer_> Say I have a ByteString, how do I do something similar to "read" on it.
12:45:05 <ray> read . unpack?
12:57:09 <shApr> I want to create a fuzzer in Haskell. How can I automatically generate 'slightly wrong' values from a datatype that only allows correct values?
12:57:33 <zachk> shapr whats a fuzzer?
12:57:48 * hackagebot upload: HJScript 0.4.9 - HJScript is a Haskell EDSL for writing JavaScript programs. (NiklasBroberg)
12:57:55 <shApr> zachk: http://en.wikipedia.org/wiki/Fuzzer
12:58:43 <shApr> Let's say I wanted to generate a BitTorrent fuzzer. I could check for client that accept incorrect input by bencoding things slightly incorrectly.
12:58:44 * copumpkin giggles at HJ
12:59:11 <shApr> oh wait...
12:59:17 <c_wraith> shApr: quickcheck might actually be good for that.
12:59:20 <shApr> Yes!
12:59:51 <shApr> So, I want to create Arbitrary instances that generate slightly false input, or add a new method to the Arbitrary class.
12:59:54 <shApr> hmm
13:00:48 <c_wraith> I ended recently creating a new data type that represented a transaction sequence for my data structure, and using quickcheck for that.
13:01:08 <shApr> Basically, I want something like shrink, sort of.
13:01:18 <c_wraith> Easier to do that creating an arbitrary instance that represented valid states of the structure I was testing
13:01:27 <c_wraith> But yes..  Shrink on a list is interesting
13:01:59 <shApr> If your datatype only allows representation of valid states, that makes it harder.
13:02:12 <shApr> Is there a way to create the complement to a datastructure? Does that even make any sense?
13:03:39 <c_wraith> "this structure contains everything that's not in that structure"?
13:04:09 <shApr> Right
13:04:28 <tommd> With gtk2hs, how do you force a window to float?  I notice none of the demos work well with xmonad.
13:04:35 <c_wraith> within the same structural constraints?
13:05:02 <QtPlatypus> shApr: Only within a in limited domain of discorse
13:05:02 <c_wraith> like, you're talking about something that's essentially a string, so you mean "all invalid strings"?
13:05:07 <dcoutts_> tommd: generally with X you cannot "force" top level windows to do anything, you can only politely ask the window manager
13:05:29 <shApr> c_wraith: yeah, and something like shrink to create strings that are only 'slightly' invalid.
13:05:35 <shApr> I'm not sure if this is a silly idea or not.
13:06:03 <tommd> dcoutts_: Good to see you online.  Thanks - I'm looking through the haddock docs for just such a function.
13:06:26 <dcoutts_> tommd: gtk+ provides a bunch of "politely ask the WM" functions for the GtkWindow class, gtk2hs should bind most of them
13:06:35 <dcoutts_> tommd: btw, I'm not really here :-)
13:06:43 * dcoutts_ is finishing his thesis
13:06:47 <shApr> yay thesis!
13:06:59 <shApr> dcoutts_: Partial eval goodness in the near future then?
13:07:01 <c_wraith> shapr: how about: create a random valid string, then just modify it slightly, and reject things that somehow remain valid?  You could even use arbitrary's shrink instance to help you generate modifications of it, though the monotonicity may not interest you
13:07:13 <luite> dcoutts_: what is your thesis about?
13:07:17 <shApr> c_wraith: I like it!
13:07:22 <dcoutts_> luite: stream fusion
13:07:38 <luite> a nice :)
13:07:44 <dcoutts_> shApr: no, I dumped that topic years ago :-(
13:07:48 <shApr> aww
13:09:05 <shApr> c_wraith: And yet, it has to be valid enough to do something useful, hm.
13:11:16 <MaciejP> > not$even 1
13:11:18 <lambdabot>   True
13:11:33 <copumpkin> > not$even 7
13:11:35 <lambdabot>   True
13:11:39 <copumpkin> damn
13:11:42 <MaciejP> Hhm, my GHCi gives me Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ
13:11:52 <copumpkin> MaciejP: I think your function is broken
13:12:17 <MaciejP> broken?
13:12:25 <copumpkin> it says that 7 is not$even
13:12:29 <copumpkin> when it clearly is
13:12:55 <copumpkin> furthermore,
13:12:58 <copumpkin> > not$even 2
13:12:59 <lambdabot>   False
13:13:05 <copumpkin> > 2 == 7
13:13:06 <lambdabot>   False
13:13:09 <copumpkin> clearly wrong
13:14:05 <MaciejP> Sorry, I don't get it
13:14:28 <stevenmarky> :.<
13:15:17 <stevenmarky> notseven
13:15:21 <MaciejP> My problem is my GHCi supposes not$even to be a template I think.
13:16:09 <MaciejP> whereas not $ even works
13:16:44 <gwern> (the google gears svn repo is enormous!)
13:20:17 <gwern> so far svn has checked out 263M
13:20:20 <gwern> what
13:23:01 <Itkovian> Is it possible that haxr is not able to correctly parse a XML-RPC response consisting of an array of structs? An array of 'values' seems to work out fine. Anybody any XP with this?
13:23:08 <regalia> It's finally clicking guys! :D
13:24:23 <MaciejP> I thought th splices are allways surrounded by parentheses
13:24:28 <noggle> regalia: I know the feeling
13:24:38 <noggle> I cannot implement filter with foldr
13:24:46 <noggle> but I can tell you how foldr works :)
13:24:47 <noggle> haha
13:24:51 <regalia> :)
13:25:10 <regalia> I've been that far but I don't remember any of it because it never really clicked
13:25:12 <Cale> noggle: Well, foldr gets to replace the function (:) which adds an element to the beginning of a list
13:25:12 <Twey> noggle: Really?  o.@
13:25:17 <regalia> but now everything is falling into place :)
13:25:35 <noggle> Twey: yeah
13:25:45 <Cale> noggle: So you want to replace (:) with the function that tests to see if the element satisfies the predicate before adding it
13:25:58 <noggle> hmm
13:26:05 <Twey> filter p = foldr (\x rs -> if p x then (x : rs) else rs) []
13:26:47 <Twey> Cale: I've never really got that explanation
13:26:54 <Twey> What happens to the second parameter, the rest of the list?
13:27:21 <Saizan> the same thing?
13:27:38 <Saizan> rs is already the tail of the list where you've replaced (:) and []
13:27:46 <Cale> Twey: foldr f z replaces each (:) in the list with f, and the [] at the end with z
13:27:50 <regalia> Yeah, i can put both of your guys explanations together and can completely understand it
13:27:51 <Twey> Ohh, I see
13:28:01 <Twey> Yes, okay; that makes sense ☺
13:28:12 <Cale> > foldr (:) [4,5,6] [1,2,3]
13:28:13 <lambdabot>   [1,2,3,4,5,6]
13:28:25 <mreh> @src (++)
13:28:26 <lambdabot> []     ++ ys = ys
13:28:26 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:28:26 <lambdabot> -- OR
13:28:26 <lambdabot> xs ++ ys = foldr (:) ys xs
13:29:15 <Cale> > let map f = foldr ((:) . f) [] in map (*2) [1..10]
13:29:17 <ben> > foldl (flip (:)) [4, 5, 6] [1, 2, 3]
13:29:17 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
13:29:18 <lambdabot>   [3,2,1,4,5,6]
13:29:18 <ben> whoops
13:29:46 <Polarina> :t map
13:29:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:29:52 <Polarina> What is this "forall"?
13:30:04 <Cale> It just means that the type works for all types a and b
13:30:05 <mreh> the universal quantifier
13:30:14 <mreh> if that makes things clearer for you
13:30:19 <Polarina> Why mention it?
13:30:21 <enthymene> as opposed to :t quicksort >.>
13:30:24 <aavogt> it's usually implicit
13:30:30 <Cale> Because it sometimes matters where it is positioned.
13:30:41 <ben> Polarina: Like this, it is equivalent to not mentioning it. The extension is for putting it elsewhere, where it matters.
13:30:51 <MissPiggy> Cale how come you help so many people with haskell?
13:30:52 <Polarina> When would it matter?
13:30:52 <mreh> is that a "Rank 1" universal quantifier?
13:30:58 <ben> Polarina: existentials :I
13:31:02 <Cale> MissPiggy: Because I enjoy it?
13:31:14 <Polarina> Weird stuff.
13:31:16 <aavogt> also used with ScopedTypeVariables
13:31:17 <luite> ben: with ScopedTypeVariables there is still a difference between forall and no forall,
13:31:26 <Polarina> What's the difference?
13:31:31 <Polarina> And what is ScopedTypeVariables?
13:31:36 <ben> Presumably it introduces a scope for the type variable?
13:31:38 <mreh> MissPiggy: what a bizzare question to ask
13:31:38 <MissPiggy> Cale but you probably taught about two thoursand semesters of computing courses by this point!
13:31:49 <ben> I only ever use scopedtypevariables so I can say \(e :: SomeException) -> ...
13:31:59 <Twey> filter p = (flip foldr [] .) . flip (??) id (:) . ap
13:32:11 <mreh> I've seen universal quantifiers called "Rank 2" in the past
13:32:13 <Saizan> > let f :: (forall a. Show a => a -> String) -> String; f g = g 'a' ++ g () in f show
13:32:14 <lambdabot>   "'a'()"
13:32:16 <Twey> filter = (flip foldr [] .) . flip (??) id (:) . ap
13:32:29 <Saizan> > let f :: Show a => (a -> String) -> String; f g = g 'a' ++ g () in f show
13:32:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:32:30 <lambdabot>         against inferred type...
13:32:31 <mreh> rank 1 presumably means it's on the outsidest expression
13:32:59 <Saizan> Polarina: essentially, it's useful when you want to abstract over polymorphic values, like in my 'f' above
13:33:01 <MissPiggy> why is it a bizarre question
13:33:01 <ben> @src foldl
13:33:02 <lambdabot> foldl f z []     = z
13:33:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:33:03 <Cale> Anyone who feels that they need to send me money can PayPal cgibbard at gmail dot com :)
13:33:13 <luite> hehe
13:33:22 <ben> Why does the (ghc) prelude definition of foldl use a local function instead of this definition?
13:33:34 <regalia> take' :: (Num i, Ord i) => i -> [a]
13:33:37 <regalia> eekkk
13:33:38 <ben> @src foldr
13:33:39 <lambdabot> foldr f z []     = z
13:33:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:33:42 <MissPiggy> mreh are a new here ?
13:33:49 <MissPiggy> or newish
13:33:49 <regalia> take' :: (Num i, Ord i) => i -> [a] -> [a]
13:34:01 <Cale> ben: To work around the fact that GHC's optimiser is missing a certain optimisation.
13:34:05 <mreh> MissPiggy: I've been here around a year
13:34:25 <MissPiggy> mreh right, and don't you find it impressive too?
13:34:35 <mreh> it's just a very strange thing to ask, as if doing it weren't reason enough
13:34:47 <mreh> it's kind of insulting :)
13:34:57 <ben> Cale: So, uh, I guess the idea is that passing the same argument to a function over and over is less desirable than binding a free variable in an outer scope?
13:35:01 <ben> If I worded that correctly, anyay
13:35:02 <MissPiggy> really?? I am sorry
13:35:02 <mreh> I mean that in the nicest possible way of course
13:35:07 <Cale> ben: yeah
13:35:14 <MissPiggy> why is that insulting
13:35:23 <ben> I think it was the other way around in lua. I have been doing it wrong here all the time :((
13:35:50 <mreh> MissPiggy, it sounds as if you think he's crazy, or has an ulterior motive
13:36:14 <MissPiggy> that's a bit annoying, how apparently I said a whole bunch of things which hadn't even crossed mmy mind and I didn't want to imply at all
13:36:41 <Cale> I wasn't insulted :)
13:37:18 <mreh> well that's all happy and good then!
13:38:10 <Cale> It's a bit economically irrational of me to continue providing free tutoring when I should probably be asking for money. I am my own worst competition ;)
13:38:53 <Cale> But it's fun.
13:39:17 <kw317> I've got a problem with cablal: cabal: failed to parse output of 'ghc-pkg dump'
13:39:26 <kw317> anyone familiar with this issue/
13:39:30 <kw317> ?
13:39:31 <Saizan> kw317: you need a newer cabal-install
13:39:37 <monochrom> If you set the goal of free tutoring, at least it is more economical to write it once and for all on a web page, like I do.
13:39:40 <MissPiggy> yeah it's fun sometimes (for me) but often when I try and advise people they are like "no I want to do it $silly_way" or find some reason to re-interpret what I say as an insult
13:39:53 <Cale> kw317: Yeah, you're using the wrong version of cabal-install for your version of GHC
13:39:54 <dcoutts_> kw317: you're using cabal-install-0.6.2 with ghc-6.12, you need version 0.8 with 6.12
13:40:32 <kw317> ok, I'll upgrade it, thanks!
13:40:39 <monochrom> Oh I have to list my contributions to haskell wiki, too.
13:41:12 <Saizan> if you still have the old ghc around you can e.g. cabal install -w ghc-6.10.4 "cabal-install >= 0.8"
13:41:27 * mreh secretly wants to smash MissPiggy's confidence into the ground
13:41:32 <mreh> just kidding!
13:41:36 <Berengal> kw317: http://www.haskell.org/cabal/release/cabal-install-0.8.0/cabal-install-0.8.0.tar.gz <- latest version, since it's annoyingly not linked to on the download page
13:42:32 <Berengal> monochrom: But then lots of people'll read it and not go "thanks, mind blown $ETC"
13:42:52 <kw317> Berengal: thanks
13:43:00 <Berengal> monochrom: See above ;)
13:43:46 <monochrom> My reward is more profound. I see strangers here recommending my pages.
13:44:17 <mreh> monochrom: which are yours?
13:44:21 <Berengal> Ah true
13:44:29 <Berengal> I tend to just recommend #haskell...
13:44:31 <monochrom> There were two or three times someone asked about fix, and before I could give my URL, other people already gave my URL.
13:47:09 <Saizan> btw, my browser seems to have problems opening http://www.vex.net/~trebla/haskell/index.xhtml , is it just me?
13:47:23 <xerox> yes
13:47:41 <enthymene> is it supposed to look like google buzz?
13:48:10 <monochrom> IE8 does not know the media type application/xml+xhtml
13:48:24 <enthymene> wow.  They should have that looked at
13:48:34 <enthymene> oh hell
13:48:52 <gwern> the gears repo is 1.4GB in total!
13:48:55 <gwern> wow
13:48:59 <enthymene> yahoo
13:49:01 <gwern> good thing bandwidth is cheap for google
13:49:11 <Berengal> o_O
13:49:17 <enthymene> welp
13:49:39 <enthymene> time to switch classes
13:49:49 <enthymene> er, I mean, go to work
13:49:57 <gwern> 1.4gb is what you get when you bundle in all your deps...
13:50:06 * enthymene quit hi ho! hi ho! It's off to work I go!
13:50:56 <monochrom> In some far future I will write a comprehensive stylesheet covering all of xhtml so IE8 can display it.
13:52:58 <edon> i have these two functions: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22917#a22917 . For big inputs i'm getting a stack overflow. I know that 'coefs' isn't causing one. Which one of the other functions is more likely to cause one and what would you advice to use instead?
13:54:43 <Botje> @src minimum
13:54:43 <lambdabot> minimum [] = undefined
13:54:43 <lambdabot> minimum xs = foldl1 min xs
13:54:51 <Botje> edon: minimum could be a cause.
13:55:01 <Botje> is coefs a big list?
13:55:32 <edon> yes
13:56:39 <Botje> foldl1' might solve it, then
13:57:12 <Botje> @pl cost ks cs = sum $ zipWith (*) ks cs
13:57:12 <lambdabot> cost = (sum .) . zipWith (*)
13:58:18 <Botje> @src sum
13:58:18 <lambdabot> sum = foldl (+) 0
13:58:21 <Botje> doh
13:58:39 <Botje> sum should also be implemented with foldl' :/
13:59:08 <edon> thank you
13:59:27 <copumpkin> or foldr
14:00:43 <Twey> Botje: It is
14:00:48 <Twey> \b lies :þ
14:01:01 <gwern> I'm so glad I turned my monitor on its side - now I can read full pages at >100%
14:01:08 <Twey> It's strict really (or as strict as (+) for the type used, anyway)
14:01:09 <gwern> very good for papers
14:01:27 <regalia> gwern: I did it for about five minutes, not a fan
14:01:35 <Botje> Twey: ah
14:01:38 <Botje> lambdabot: boo!
14:01:39 <regalia> regalia: but I have dualies now :)
14:02:05 <gwern> regalia: why ever so?
14:02:47 <regalia> gwern: I suppose I didn't really give it a chance
14:02:48 <mreh> "I've got a 28" plasma in my office, when you get a document up on that baby you are seriously looking at that document"
14:02:56 <regalia> gwern: It was just, awkward to me...
14:03:52 <mreh> no fans of peep-show in here then?
14:04:59 <gwern> regalia: well, that's pretty vague. my only beef so far is that many web pages expect my monitor to be wider
14:09:42 <edon> Botje: tried both with foldl', it still causes a stack overflow. any other ideas?
14:10:00 <regalia> gwern: That might have been what I ran into immediately. This was some time ago
14:10:10 <Berengal> edon: compile it with -O2
14:11:02 <Berengal> Otherwise, start looking at some other functions
14:11:10 <edon> Berengal: thanks, that works
14:11:40 <roconnor> Reynolds thereom is almost reason enough by itself to drop excluded middle from your reasoning. :D
14:12:29 <oconnore_> There is only room for one of us here...
14:12:36 * oconnore_ quick draws!
14:13:02 <roconnor> :)
14:13:18 <byorgey> roconnor: which theorem is that?
14:13:18 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
14:14:09 <roconnor> byorgey: the one that says there is no non-trivial interpretaion of the polymorphic lambda calculus as sets that interprets A -> B as the set function space.
14:14:31 <roconnor> Andrew Pitts says you can interpret it in other topos though.
14:15:57 <jvoorhis> dons: thanks for posting your slides, wish i could've been there today
14:19:44 <ezyang> Meh, no libghc6-cairo-prof package
14:24:25 <thoughtpolice> so, is there any documentation for cabal 1.8 yet?
14:24:27 <gwern> where did all the old repos on darcs.haskell.org go?
14:25:26 <thoughtpolice> apparently the IHG funded some big changes but I cannot figure out how to use them (notably: make cabal not recompile source twice when you have a package that has a library and an executable based on the library)
14:25:27 <Berengal> gwern: Was that the server that was shut down?
14:25:45 <gwern> that's monk IIRC; d.h.o is still there, just a lot of repos gone
14:25:52 <dcoutts_> thoughtpolice: http://haskell.org/cabal/release/cabal-1.8.0.2/doc/users-guide/
14:26:04 <Berengal> Ah, then dunno
14:26:24 <dcoutts_> thoughtpolice: note that that feature is currently broken with ghc-6.12 (we discovered a bit late)
14:26:42 <dcoutts_> thoughtpolice: it's just a matter of specifying that the exe build-depends on the lib
14:27:08 <thoughtpolice> dcoutts_: k, thanks
14:27:21 <dcoutts_> thoughtpolice: though you also have to make sure the source dirs are right, since local sources take precedence over modules from packages
14:29:25 <gwern> hm. yhc's repo was on d.h.o too
14:33:09 <ben_m> Good evening
14:33:21 <ben_m> Convert to proper greeting depending on your timezone
14:33:50 <copumpkin> too late, I'm already offended
14:33:52 <MaciejP> Is there a Haskell template library capable to specify conditional replacements?
14:33:57 <dcoutts_> gwern: ask Igloo for old repos that needs moving elsewhere
14:34:18 <ben_m> I can't find any documentation on what the three values for the Tall layout mean... ("Tall x y z")
14:34:25 <ben_m> Help! :D
14:34:33 <Twey> What are their types?
14:34:41 <ben_m> int ratio ratio
14:34:53 <Twey> Hmm, two ratios?
14:34:57 <RayNbow> http://xmonad.org/xmonad-docs/xmonad/XMonad-Layout.html#t%3ATall
14:35:09 <Twey> Ah, there you go
14:35:17 <ben_m> hmm
14:35:22 <ben_m> I did not find that before
14:35:27 <ben_m> odd.
14:35:30 <ben_m> Thanks! :)
14:35:46 <RayNbow> ben_m: it was the first hit @ Google
14:35:53 <RayNbow> (I searched for "Tall xmonad")
14:36:10 <enthymene> umm
14:36:16 * enthymene checks his xmonad.hs
14:36:42 <enthymene> nmaster delta ratio
14:36:49 <enthymene> nmaster is the number of windows in the master pane
14:36:50 <ben_m> The documentation I found just said the types are int! ratio! ratio!
14:36:52 <ben_m> Nothing else
14:37:04 <enthymene> ratio is the share of the screen the master pane gets
14:37:14 <enthymene> and delta is how much you change by when you use mod h and mod l
14:37:34 <enthymene> so (Tall 1 1/2 3/100) means one window in the master pane
14:37:44 <enthymene> 1/2 of the screen to the master pane by default
14:37:45 <ben_m> yeah I get that :)
14:37:48 <ivanm> ben_m: of course, there's #xmonad available for your asking pleasure... ;-)
14:37:53 * RayNbow notices that the documentation is a bit off...
14:38:08 <ben_m> ivanm: Well, I did try to find it in the documentation first! :D
14:38:11 <enthymene> there are many xmonad.hs's out there with instructive comments
14:38:31 <benmachine> enthymene: you might need to bracket those fractions
14:38:36 <enthymene> ah yeah
14:38:44 <enthymene> sorry, my xmonad.hs defines them in a where clause
14:38:47 <benmachine> heh
14:38:53 <enthymene> ick
14:38:56 <aavogt> note that the record field labels show up when you enter into ghci  :info Constructor
14:38:56 <enthymene> I just called it a where clause
14:39:01 <enthymene> too much PL/SQL for me
14:39:26 <enthymene> heh
14:39:39 <enthymene> fun, just made polynomials an instance of Num :3
14:39:51 <benmachine> I call them where clauses
14:40:00 <benmachine> 'sgood a name as any other
14:40:02 <enthymene> signum has no meaning for a polynomial, right?  Not unless it's been evaluated, and then it's a Num.
14:40:17 <benmachine> you can possibly come up with one
14:40:25 <benmachine> but it'd be fairly contrived
14:40:26 <enthymene> yeah, I couldn't think of one
14:40:32 <enthymene> I just set it to (\ x -> 0)
14:40:43 <benmachine> I set mine to error "urk"
14:40:46 <monochrom> There is a "norm" for polynomials in abstract algebra.
14:40:52 <enthymene> oh, yeah
14:40:56 <enthymene> I should do that
14:41:10 <enthymene> although norm has a slightly different meaning right?
14:41:23 <copumpkin> it's not signum, but you could probably pull it out of it
14:41:29 <monochrom> Oh wait, norm is for abs, I don't know what should signum do. :)
14:41:37 <enthymene> okay
14:41:52 <benmachine> :t abs
14:41:53 <enthymene> so yeah, abs set to 'map abs'
14:41:54 <lambdabot> forall a. (Num a) => a -> a
14:41:57 <copumpkin> anyway, abs is terrible too
14:41:59 <benmachine> hmm
14:42:23 <benmachine> I think signum would follow from abs
14:42:27 <enthymene> what is it nowadays with all my podcasts having intermissions
14:42:30 <benmachine> in that abs n * signum n should equal n
14:42:37 * twink ponders super-high-precision software floating point.
14:42:41 <benmachine> :t signum
14:42:42 <lambdabot> forall a. (Num a) => a -> a
14:42:45 <copumpkin> benmachine: not if abs is a norm
14:43:02 <copumpkin> > abs (1 :+ 5) * signum (1 :+ 5)
14:43:03 <benmachine> copumpkin: abs has got to produce the same type as it's given, though
14:43:03 <lambdabot>   1.0 :+ 5.0
14:43:07 <benmachine> heh
14:43:09 <copumpkin> oh, I guess then
14:43:10 * benmachine wins
14:43:20 <copumpkin> fucked up though :P
14:43:30 <benmachine> > signum (1 :+ 1)
14:43:32 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
14:43:36 <benmachine> interesting
14:43:46 <copumpkin> I guess that isn't too bad
14:43:55 <copumpkin> I thought it was the abs that was giving me the complex
14:44:13 <ivanm> copumpkin: no, sqrt (-1) tends to do that...
14:44:15 <ivanm> ;)
14:45:11 <twink> It could make algebraic number fields like Q(i) awkward. |1+i| = 2^(1/2) which is not in Q(i).
14:45:33 <Twey> Wait what
14:45:38 <enthymene> yes please explain
14:45:40 * enthymene sits
14:45:55 <Twey> How does signum (1 :+ 1) become 0.7071067811865475 :+ 0.7071067811865475?
14:46:12 <copumpkin> http://snapplr.com/zc20
14:46:14 <twink> (1 :+ 1)/abs (1 :+ 1)
14:46:15 <enthymene> oh, I thought you were talking to twink
14:46:18 <benmachine> Twey: it extends the concept of signum on reals
14:46:26 <twink> = (1 :+ 1) / sqrt 2
14:46:29 <benmachine> in that it is a number in the same "direction" of size one
14:46:30 <benmachine> but
14:46:39 <benmachine> the name signum is stupid in that context
14:46:40 <benmachine> but
14:46:40 <Twey> But as I understand it, signum returns 1, 0, or -1
14:46:41 <benmachine> whatever.
14:46:56 <benmachine> signum returns x / abs x
14:46:57 <benmachine> I think
14:47:00 <copumpkin> Twey: only on the reals, and I guess x / |x| probably has a special case for 0
14:47:00 <arw> Twey: strictly speaking there is no signum for complex numbers.
14:47:01 <Twey> Not 0.7071067811865475
14:47:07 <Twey> Hum
14:47:14 <enthymene> hrm
14:47:18 <twink> Twey: Well, to do something that makes some sort of sense for complex numbers, they chose that (and it is called csgn or some such elsewhere).
14:47:24 <arw> Twey: and the "complex extension" is not what most people would choose
14:47:26 <enthymene> having signum return a polynomail divided by it's absolute value hmmm
14:47:31 <Twey> I see… weird
14:47:35 <enthymene> even a polynomial
14:47:35 <benmachine> having useful properties is more useful than making logical sense :P
14:47:47 <copumpkin> enthymene: where absolute value isn't map abs :P
14:47:49 <Twey> > abs (1 :+ 1)
14:47:50 <lambdabot>   1.4142135623730951 :+ 0.0
14:47:59 <Twey> … what?
14:48:09 <benmachine> that is expected?
14:48:11 <copumpkin> didn't you get the memo? the length of a complex number is itself complex
14:48:15 <benmachine> heh
14:48:15 <MissPiggy> > sqrt (1^2 + 1^2)
14:48:16 <lambdabot>   1.4142135623730951
14:48:21 <Twey> Oh
14:48:23 <benmachine> well, it *is*, technically
14:48:28 <Twey> Weird
14:48:32 <Twey> Okay then
14:48:35 <copumpkin> the length of a complex number is a quaternion
14:48:38 <copumpkin> in my opinion
14:48:40 <monochrom> Of course a non-negative real number is a complex number.
14:48:55 <copumpkin> actually, it's sedenion
14:49:14 <DBAlex> Hey, why does this not work as "main" function: > main = mapM_ showBoard $ gametree $ genb [[Nought,Nought,Nought],[Nought,Nought,Nought],[Nought,Nought,Nought]] (It's type correct, and showBoard has return type IO() )... I wanted to compile to test some gametree code :-)
14:49:16 <arw> doesn't that depend on the metric chosen?
14:49:35 <QtPlatypus> monochrom: Why are negative real numbers not complex?
14:49:40 <DBAlex> thanks!
14:49:53 <arw> QtPlatypus: because the result of abs() is always positive.
14:49:54 <monochrom> the length of a complex number is an element of the set of all sets in my opinion.
14:50:09 <QtPlatypus> arw: Ah
14:50:24 <MissPiggy> lol
14:50:30 <lament> i remember a #math flamewar about something like this
14:50:32 <DBAlex> Hello ?
14:50:32 <arw> QtPlatypus: so i guess the sentence is not completely correct...
14:50:37 <monochrom> Who said negative real numbers are not complex? I certainly didn't, I don't know why I'm asked.
14:50:53 <lament> i.e. whether complexes are a superset of the reals, or there's an injection from one to the other
14:51:08 * DBAlex cries in the corner while the intelligent people talk about set theory..
14:51:11 <monochrom> So, if I say "monochrom is male", do you suddenly ask me "why is dons not male?"?
14:51:35 <lament> DBAlex: ...what's the error?
14:51:44 <DBAlex> lament: no error, just nothing is printed
14:51:45 <DBAlex> :/
14:51:49 <QtPlatypus> monochrom: Point taken. Though it was a needless qualification.
14:52:08 <ivanm> monochrom: why, are you likely to say such a thing?
14:52:09 <ivanm> ;)
14:52:18 <copumpkin> he was referring to the output of norm in particular
14:52:25 <DBAlex> Oh wait
14:52:27 <DBAlex> Hahahahahaha
14:52:36 <DBAlex> I'm completely stupid, don't worry :)
14:52:39 <DBAlex> :p
14:52:39 <lament> DBAlex: you have a bug somewhere :) Just load your module in ghci
14:52:44 <monochrom> I was agreeing with "didn't you get the memo? the length of a complex number is itself complex"
14:52:53 <DBAlex> no, I got Nought and Blank mixed up
14:53:05 <DBAlex> :p
14:53:05 <lament> DBAlex: you don't need a main function, just load in ghci, run stuff right there, and :reload when you change the file
14:53:15 <DBAlex> lament: does it compile each time?
14:53:25 <monochrom> And I am not sure that more than half of the traffic here are not "needless".
14:53:33 <DBAlex> I want to run this with optimization hopefully
14:53:36 <DBAlex> just to see if it works
14:53:39 <DBAlex> (quicker)
14:54:07 <lament> if tictactoe is slow, you're doing it wrong
14:54:36 <lament> bruteforcing tictactoe should be instant
14:54:42 <ivanm> unless you intended to write a slow one...
14:54:45 <DBAlex> oh
14:54:46 <DBAlex> it works :)
14:54:53 * ivanm plays devils advocate
14:54:54 <DBAlex> I'll just leave that running for a while...
14:55:22 <lament> there're less than 362880 tictactoe games...
14:55:37 <benmachine> less than?
14:55:42 <DBAlex> well the human plays first here
14:55:47 <lament> even less than 45360 i guess
14:55:56 <DBAlex> 40320
14:55:57 <monochrom> Perhaps your tictactoe seems slow just because the computer is playing Strip Thermonuclear War in the background.
14:55:58 <DBAlex> Hmm
14:55:58 <DBAlex> :)
14:56:06 * benmachine giggles
14:56:07 <DBAlex> 40320 shouldn't take too long right ? :P
14:56:11 <twink> How are there so few tic-tac-toe games?
14:56:12 <lament> it should be instant
14:56:14 <DBAlex> Oh, it's done!
14:56:37 <DBAlex> 8 factorial.. right?
14:56:39 <lament> twink: ignoring symmetries, it's 9 factorial to fill the whole board.
14:56:49 <lament> twink: and the game actually games before then.
14:56:53 <lament> *actually ends
14:57:00 <lament> and there's an 8-fold symmetry
14:57:09 <twink> Okay, I see, sort of.
14:57:14 <DBAlex> yeah but you cheat and let the human go first because you want to use bruteforce and not right an alpha-beta prune function!
14:57:17 <benmachine> > product [1 .. 7] * 9
14:57:18 <lambdabot>   45360
14:57:19 <DBAlex> :p
14:57:22 <DBAlex> *write
14:57:46 <benmachine> but any configuration with more than five of one thing is invalid
14:57:53 <copumpkin> > product [1..9] / 8
14:57:54 <lambdabot>   45360.0
14:57:58 <DBAlex> I'm filtering the invalid moves..
14:58:05 <twink> How is there 8-fold symmetry?
14:58:24 <ksf> horizontal, vertical, 2xdiagonal, 4 rotations
14:58:25 <benmachine> twink: because the board can be rotated four ways and flipped two ways
14:58:32 <DBAlex> Shhh
14:58:38 <DBAlex> I'm supposed to work this out myself
14:58:38 <DBAlex> ;)
14:58:41 <DBAlex> ...
14:59:05 <twink> I have my doubts that those translate to a factor of 8 reduction in the game database.
14:59:08 <monochrom> Because D8 has eight elements <duck>
14:59:24 <benmachine> twink: every single game position has seven other positions that are basically identical
14:59:43 * benmachine hugs monochrom
14:59:48 <benmachine> I miss group theory :(
14:59:50 <DBAlex> benmachine: can this be applied to chess too then?
14:59:56 <lament> twink: you're right, actually taking advantage of this requires some extra coding, but not much
14:59:59 <DBAlex> or is that a completely stupid thought...
15:00:07 <DBAlex> (the symmetry ?)
15:00:14 <benmachine> DBAlex: uhm
15:00:15 <ksf> chess is irregular
15:00:22 <DBAlex> :/
15:00:25 <DBAlex> true
15:00:27 <ksf> both queens and both kings face each other
15:00:33 <pastorn> how do i do event based programs in haskell?
15:00:38 <benmachine> you can flip the board on its axis if it helps you
15:00:39 <twink> I'm still at a bit of a loss to see how the factor-of-8 reduction is carried out.
15:00:43 <benmachine> but I can't imagine that it would
15:01:05 <twink> I can see factors of 4.
15:01:12 <DBAlex> hah
15:01:20 <DBAlex> I like how ghc tells me when I don't need to compile...
15:01:21 <DBAlex> :)
15:01:23 <ksf> it'd help you with go, but go is a bitch to write an ai for
15:01:32 <DBAlex> "you already compiled, keep up!"
15:01:37 <dschoepe> pastorn: there's "Functional Reactive Programming"
15:01:42 <lament> twink: at the start of the game, play only in the top half of the board.
15:01:46 <pastorn> dschoepe: not what i'm looking for
15:01:53 <pastorn> dschoepe: this is for an IRC bot
15:01:57 <benmachine> there are only three starting moves really
15:01:57 <lament> twink: if the human actually plays in the bottom half, pretend he played in the top half and remember that the board is flipped.
15:02:01 <dschoepe> ah, okay
15:02:45 <ksf> in that sense, they're only three start positions if I'm not mistaken
15:02:48 <lament> twink: (this is not on the first move - more like second and/or third)
15:03:01 <twink> And then the next move is always the lower left corner or lower center square.
15:03:58 <benmachine> pastorn: I might have a different idea from you of what "event based" is, but I think threads and MVars are pretty good
15:04:08 <benmachine> at least, that's how I did my IRC bot
15:04:31 <ezyang> I wish the criterion documentation code examples were up to date...
15:05:05 <DBAlex> :hoogle
15:05:13 <DBAlex> aww
15:05:19 <benmachine> @hoogle unsafe
15:05:19 <lambdabot> Language.Haskell.TH unsafe :: Safety
15:05:19 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
15:05:19 <lambdabot> module Data.ByteString.Unsafe
15:06:16 * hackagebot upload: formlets-hsp 2.2.3 - HSP support for Formlets (JeremyShaw)
15:09:42 <pastorn> benmachine: so what did you have in your different threads?
15:10:49 <benmachine> pastorn: I think I had three, one which waited for keyboard input, one which waited for data from the server, and one which wrote anything that got put in its MVar to the socket
15:11:07 <benmachine> hmm
15:11:19 <benmachine> I can't remember if I had a separate one for drawing the UI (it was ncurses)
15:11:50 <pastorn> is there some function "sleepOnHandle :: Handle -> IO a -> IO a"?
15:11:59 <benmachine> what would it do
15:12:14 <pastorn> when there's stuff on the handle it would run the function
15:12:29 <benmachine> would the function read data from the handle?
15:12:34 <pastorn> yes
15:12:37 <ksf> pastorn, google "github tibbe event"
15:12:47 <benmachine> then the functino you want is pretty much just hGetLine? :P
15:12:50 <ksf> that's a nice epoll interface
15:12:51 <monochrom> there are threadWaitRead and threadWaitWrite in Control.Concurrent, for Fd rather than Handle
15:12:53 <benmachine> which sleeps until data is available
15:12:56 <benmachine> and then gets it
15:12:58 <pastorn> forever $ do
15:12:59 <pastorn>         s <- hGetLine h
15:13:06 <pastorn> ^^ not the greatest design
15:13:14 <benmachine> what's the problem?
15:13:21 <pastorn> (forever p = p >> forever p)
15:13:29 <jmcarthur> untilM isEOF    -- (for stdin)
15:13:34 <jmcarthur> i had to define untilM myself though
15:13:35 <benmachine> you have to then do something with the data
15:13:45 <benmachine> or, not if you don't want to
15:13:57 <benmachine> I have
15:14:07 <jmcarthur> benmachine: the problem is EOF
15:14:11 <benmachine> forever $ hGetLine socket >>= putMVar mvar
15:14:19 <benmachine> jmcarthur: pfft, exception handling
15:14:23 <benmachine> is fine for that
15:14:27 <c_wraith> doesn't hGetLine fail to actually do IO, if you don't somehow use its result?
15:14:38 <benmachine> c_wraith: hGetLine is not lazy
15:14:42 <ksf> no that's readContents
15:14:48 <benmachine> getContents/readFile
15:14:48 <c_wraith> ah, ok.
15:14:56 <Twey> Can't forever be expressed in terms of fix?
15:15:08 <pastorn> Twey: don't be annoying
15:15:09 <ddarius> Twey: Of course it can.
15:15:09 <Twey> Oh, I guess no
15:15:10 <Twey> t
15:15:11 <c_wraith> sure.
15:15:13 <benmachine> @pl forever x = x >> forever x
15:15:13 <lambdabot> forever = fix (ap (>>))
15:15:20 <Twey> Oh
15:15:22 <Twey> Okay then :þ
15:15:23 <pastorn> goddammit
15:15:31 <pastorn> benmachine: i didn't want to see that
15:15:38 <Twey> pastorn: Why?  It's so pretty :þ
15:15:46 <pastorn> Twey: be quiet, you
15:15:47 <benmachine> all recursive functions can be expressed in terms of fix
15:15:56 <ddarius> That's a crappy definition.
15:16:04 <benmachine> well
15:16:10 <MaciejP> @type fix
15:16:11 <lambdabot> forall a. (a -> a) -> a
15:16:12 <ddarius> forever = fix . (>>)
15:16:16 <pikhq> Well... Yeah, of course. That *is* what fix does.
15:16:39 <ddarius> :t fix (ap (>>))
15:16:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:16:42 <ddarius> :t fix . (>>)
15:16:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:16:44 <benmachine> all non-recursive functions can be expression in terms of fix . const
15:16:51 <pastorn> STOP THIS
15:16:59 <jmcarthur> pastorn: calm down
15:17:01 <benmachine> expression?
15:17:02 <benmachine> expressed
15:17:43 <c_wraith> is there a pointless case extension floating around?
15:18:03 <benmachine> no
15:18:10 <ksf> cases introduce points, so, no.
15:18:32 <benmachine> I think the idea of "case of" -> "\x -> case x of" has been suggested
15:18:36 <benmachine> but not implemented (yet)
15:18:59 <benmachine> (lots of things have been suggested though, most of them are never going to happen and that is probably for the best)
15:19:15 <monochrom> Time flies like an arrow. Haskell programs like a fix.
15:19:27 <ksf> not being able to write that made me love where definitions
15:19:45 <ksf> ...my code is always scattered with f, g and go.
15:19:49 <benmachine> heh
15:20:24 <Berengal> ksf: And loop, and x' and i' and n' and ...
15:20:30 <jmcarthur> benmachine: being able to write a case expression without newline or semicolons doesn't make it point free, anyway
15:20:45 <benmachine> jmcarthur: buh?
15:20:56 <ksf> I actually shadow bindings. foo <- bar; case foo of Just foo -> ...
15:20:58 <jmcarthur> that's not what point free is
15:21:01 <c_wraith> jmcarthur: it's about not naming the value you're examining
15:21:05 <benmachine> the thing I posited had nothing to do with newlines or semicolons
15:21:11 <jmcarthur> c_wraith: right
15:21:26 <c_wraith> that's what the suggestion he mentioned is about
15:21:32 <c_wraith> It just doesn't name a temporary value
15:21:34 <jmcarthur> benmachine: but a case expression is for pattern matching
15:21:34 <Berengal> I only shadow in strictly sequential code
15:21:42 <Twey> jmcarthur: For example, ‘case of Nothing -> 3; Just x -> x’
15:21:48 <jmcarthur> the only point free "case" is a fold
15:21:49 <benmachine> I shadow the hell out of everything all the time
15:21:56 <jmcarthur> Twey: but that's not point free
15:21:58 <benmachine> it is a bad habit possibly
15:22:03 <Twey> To mean \y -> case y of Nothing -> 3; Just x -> x’
15:22:13 <Twey> jmcarthur: It's one point less
15:22:17 <jmcarthur> maybe 3 id  -- is point free
15:22:26 <Berengal> Yeah, this is what destructors are for
15:22:33 <ksf> :t maybe
15:22:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:22:39 <ksf> that's a very, very useful function.
15:22:44 <Twey> That it is
15:22:55 <ddarius> ksf: Just like foldr...
15:22:59 <Berengal> You don't write the patterns, you only write what should be done when it matches. The destructor takes care of the pattern matching for you
15:23:07 <jmcarthur> folds are point free case expressions
15:23:10 <twink> -Wshadow or something?
15:23:12 <ksf> that'd be \y -> maybe 3 id y
15:23:27 <MissPiggy> = maybe 3 id
15:23:27 <benmachine> it's free with -Wall
15:23:30 <MissPiggy> eta reduced
15:23:31 <Twey> ksf: main = runServer . maybe 8080 id . ((>>= (fmap fst . listToMaybe . reads)) . listToMaybe) =<< getArgs
15:23:33 <Twey> <3
15:23:39 <jmcarthur> maybe 3 id == fromMaybe 3
15:23:42 <DBAlex> C:\Documents and Settings\Alex\Desktop\G52AFP>testing
15:23:42 <DBAlex> Brute force: 40320
15:23:43 * benmachine has 23 shadowing warnings in a 300-line source file
15:23:44 <DBAlex> yay :D
15:24:00 <Berengal> jmcarthur: Are folds really the basic destructors though?
15:24:02 <c_wraith> It would be easy enough to finish making case pointless.  just say that pattern matches can be treated the same way as functions.
15:24:06 <twink> -Wall does some other things that aren't great.
15:24:15 <benmachine> like unused do binds
15:24:18 <benmachine> eeew.
15:24:21 <DBAlex> now to optimize...
15:24:31 <jmcarthur> Berengal: there are many ways to define what is more "basic" than anything else
15:24:57 <c_wraith> "case of Nothing -> 3 ; Just -> id" would get translated to "\x -> case x of Nothing -> 3; Just y = id y"
15:25:18 <c_wraith> err, s/=/->/
15:25:23 <Berengal> jmcarthur: Indeed, but I'm having some problem in this case. Take lists; is foldr the "fundamental" destructor, or is "foo :: [a] -> b -> (a -> [a] -> b) -> b"?
15:25:41 <Berengal> Wait, the list should go on the end
15:25:43 <Twey> c_wraith: I'm glad I'm not the only one who always does that
15:25:51 <Berengal> b -> (a -> [a] -> b) -> [a] -> b
15:26:08 <c_wraith> Twey: the compiler is considering getting a mallet to hit me with every time I do that.  It told me so in a vision
15:26:17 <Twey> c_wraith: Heheh
15:26:20 <jinjing> sorry for double question, does template haskell require GHCi? is there a way around this?
15:26:29 <Twey> jinjing: No, N/A
15:26:39 <Berengal> I wish they would've used = in case expressions as well, and let -> be a regular identifier
15:26:48 <ivanm> Twey: it does need something _like_ GHCi
15:26:48 <ksf> jinjing, yes, and no.
15:26:48 <Twey> Berengal: And lambdas?
15:26:52 <ivanm> since it does interpreting
15:26:53 <Berengal> Twey: = or .
15:26:53 <jmcarthur> Berengal: i guess you are right. your destructor is not recursive
15:26:59 <ksf> jinjing, it needs the bytecode interpreter
15:27:01 <ivanm> (and has bitten us before in Gentoo)
15:27:01 <jinjing> Thanks Twey ksf
15:27:07 <Twey> ivanm: I thought it could just use ghcasalibrary.
15:27:09 <jmcarthur> the recursion in a fold is extra baggage
15:27:11 <Berengal> jmcarthur: Indeed, but the list definition /is/
15:27:11 <ivanm> ksf: just bytecode?
15:27:24 <ivanm> Twey: could be
15:27:29 <ksf> jinjing, there's a program that can do it without the interpreter, though.
15:27:30 <ivanm> it does some interpreting though
15:27:37 <jmcarthur> Berengal: like i said, there are more than one way to look at it
15:27:38 <ivanm> ksf: ZeroTH?
15:27:39 <jinjing> ksf: I'm trying to get TH to work on the ghc-iphone port
15:27:41 <jmcarthur> *there is
15:27:44 <ksf> yep that's the one.
15:27:48 <benmachine> you could define foldr in terms of Berengal's version, but not vice versa?
15:27:49 <jinjing> ksf: what is it?
15:27:56 <ksf> it's a preprocessor
15:28:09 <ksf> instead of running in ghc, you generate .hs files out of .hs files
15:28:10 <ddarius> benmachine: You can define vice versa.
15:28:11 <Berengal> jmcarthur: Indeed, and like I said, I'm having trouble deciding on what's Right in this case
15:28:13 <jmcarthur> :t foldr
15:28:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:28:28 <ddarius> benmachine: This is actually a theorem of F-algebras.
15:28:31 <jmcarthur> @djinn (b -> (a -> [a] -> b) -> [a] -> b) -> ((a -> b -> b) -> b -> [a] -> b)
15:28:31 <lambdabot> Error: Undefined type []
15:28:33 <ksf> it's definitely a viable way to get stuff running fast
15:28:35 <jmcarthur> bah
15:28:39 <ddarius> benmachine: Lambek's Lemma
15:28:46 <ivanm> ksf: and for most uses of TH that I've seen, I wished devs used it
15:28:53 <jinjing> ksf: could i be point to somewhere?
15:29:01 <ivanm> rather than making users call TH for "static" metaprogramming
15:29:09 <ivanm> jinjing: it's on hackage
15:29:19 <jinjing> oh, zeroTH?
15:29:24 <Berengal> I think I'd better sleep on it, then read some algebra tomorrow...
15:29:44 <ivanm> jinjing: yup
15:29:59 <jinjing> thanks ivanm
15:30:04 <ivanm> no worries
15:30:42 <benmachine> djinn doesn't allow recursive types :(
15:30:55 <jmcarthur> yeah
15:30:56 <MissPiggy> can anyone prove that recursive types would make it undecidible
15:31:27 <MissPiggy> I think you would need to use nested types in the demonstration but maybe it's possible without?
15:31:35 <pikhq> MissPiggy: Probably halting problem.
15:31:44 <MissPiggy> pikhq what
15:32:03 <ivanm> yeah, IIRC that's why
15:32:03 <pikhq> MissPiggy: What, the halting problem?
15:32:41 <michaeldever> hey all, im having a problem with indentation, its probably something small, could someone take a look and let me know where im going wrong?? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22923#a22924
15:34:09 <ivanm> michaeldever: as a first guess (without looking at the code): are you using literal tabs?
15:34:28 <benmachine> michaeldever: missing else
15:34:28 <ivanm> michaeldever: found the problem: no else
15:34:37 <benmachine> every if needs an else
15:34:39 <ivanm> line 12 if statement
15:34:42 <michaeldever> ah, ok
15:34:49 <ivanm> if ... then ... else ... is an _expression_
15:34:54 <benmachine> when ghc says parse error (possibly incorrect indentation)
15:34:55 <ivanm> not a control construct like in other languages
15:35:10 <benmachine> it can also mean unbalanced parentheses, missing parts of expressions
15:35:24 <benmachine> anything that makes the parser confused about where it is and what it's doing
15:35:38 * benmachine isn't really sure why it says (possibly incorrect indentation)
15:35:48 <michaeldever> ah right, ok, thanks folks :)
15:36:45 <benmachine> michaeldever: also, fewer parentheses!
15:37:12 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22923#a22928
15:37:27 <benmachine> also
15:37:42 <benmachine> if blah then True else x == blah || x
15:38:16 <ivanm> heh
15:38:46 <ivanm> so that returns False iff blah == x == False
15:38:55 <ivanm> right?
15:38:55 <Berengal> Let destructList :: b -> (a -> [a] -> b) -> [a] -> b. Can you define foldr without general recursion?
15:38:57 <benmachine> yup
15:39:11 <Berengal> Can you do this for any ADT?
15:39:11 <benmachine> Berengal: general recursion?
15:39:21 <ivanm> so you could just replace it with blah || x
15:39:23 <Berengal> benmachine: Yes, not primitive
15:39:38 <Berengal> Or structural
15:39:38 <Cale> Berengal: A common restriction of recursion is to only allow folds over algebraic datatypes
15:39:39 <michaeldever> thanks folks, got it fixed!
15:39:47 <ivanm> opdolio: is your "op" the same as copumpkin's "co"?
15:39:49 <benmachine> wait, so primitive recursion is allowed?
15:40:05 <copumpkin> ivanm: for a while he was codolio but then decided op was cooler, I guess :(
15:40:07 * benmachine decides he is probably not qualified to answer this question
15:40:08 <Cale> primitive recursion is a special case of structural recursion, isn't it?
15:40:11 <ivanm> heh
15:40:15 <Berengal> Cale: Indeed
15:40:46 <benmachine> foldr f z = destructList z (foldr f z) ?
15:40:57 <benmachine> err
15:40:58 <benmachine> no
15:41:03 <benmachine> that is wrong
15:41:11 <jmcarthur> @pl foldr f z = destructList z (foldr f z)
15:41:11 <lambdabot> foldr = fix (ap destructList .)
15:41:14 <jmcarthur> fix ^^
15:41:35 <Ziphilt> searching for BONUS...
15:41:54 <ivanm> preflex: seen BONUS
15:41:54 <preflex>  BONUS was last seen on #haskell 13 hours and 55 seconds ago, saying: ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
15:41:57 <benmachine> @let destructList z f [] = z; destructList z f (x:xs) = f x xs
15:41:59 <lambdabot>  Defined.
15:42:03 <benmachine> @type destructList
15:42:05 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
15:42:08 <Berengal> What I'm thinking is that if you take folds as primitives then your language would be less powerful than if you had to write folds as recursions over non-recursive destructors, then folds are a more fundamental destructor than their non-recursive cousins
15:42:15 <monochrom> Hrm, BONUS has become a computer
15:42:37 <ivanm> monochrom: nah, he's just probably got an instance of lambdabot running his chats for him
15:42:41 <jlouis> monochrom: if you lurk long enough in #haskell, that might happen
15:42:42 <benmachine> :t let foldr f z = destructList z (foldr f) in foldr
15:42:43 <lambdabot> forall t t1. t -> t1 -> [t1] -> t1
15:42:50 <ivanm> if it doesn't look like code, then it just uses vixen to simulate conversation
15:42:50 * benmachine blinks
15:43:03 <monochrom> Of course, it has happened to me already. :)
15:43:13 <copumpkin> benmachine: THAR BE NO CONNEXION
15:43:20 <ivanm> @vixen does BONUS use a version of you?
15:43:21 <lambdabot> what about me?
15:43:31 <copumpkin> benmachine: U HAZ NO LINKD UR f 2 UR LIST
15:43:42 <ivanm> monochrom: so you're claiming to be a computer now?
15:43:50 <benmachine> I think I possibly need sleep
15:44:03 <Berengal> @type let foldr z f = destructList z (\e l -> f e (foldr z l)) in foldr
15:44:04 <lambdabot>     Couldn't match expected type `t1 -> t11 -> t'
15:44:04 <lambdabot>            against inferred type `[t1]'
15:44:04 <lambdabot>     In the expression: f e (foldr z l)
15:44:14 <monochrom> I have intelligence. I can perform computer functions.
15:44:21 <monochrom> @dict
15:44:21 <lambdabot> Supported dictionary-lookup commands:
15:44:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
15:44:21 <lambdabot> Use "dict-help [cmd...]" for more.
15:44:26 <Ziphilt> if bonus isn't here, does anybody know about learnyouahaskell?
15:44:34 <monochrom> @web1913 intelligence
15:44:35 <lambdabot> *** "Intelligence" web1913 "Webster's Revised Unabridged Dictionary (1913)"
15:44:35 <lambdabot> Intelligence \In*tel"li*gence\, n. [F. intelligence, L.
15:44:35 <lambdabot>    intelligentia, intellegentia. See {Intelligent}.]
15:44:36 <lambdabot>    1. The act or state of knowing; the exercise of the
15:44:36 <lambdabot>       understanding.
15:44:37 <lambdabot> [35 @more lines]
15:44:41 <copumpkin> Ziphilt: what about it?
15:44:49 <Berengal> Ziphilt: Yep, we know it
15:44:52 <monochrom> It's about #4 or #5.
15:45:10 <Ziphilt> i was just interested to know when it started, and how progress is going on completing it
15:45:26 <monochrom> Oh, wait, there was no computer of that sort in 1913, nevermind. It's a more recent webster.
15:45:50 <Berengal> monochrom: Are you thinking of the human computers?
15:46:03 <Berengal> Because I'm pretty sure they existed in 1913...
15:46:09 <ivanm> monochrom: what's the significance of 1913?
15:46:23 <ivanm> (as in, why does lambdabot use that)
15:46:26 <ivanm> @wn intelligence
15:46:31 <lambdabot> *** "intelligence" wn "WordNet (r) 2.0"
15:46:35 <lambdabot> intelligence
15:46:36 <benmachine> augh
15:46:37 <benmachine> 23:46:03 <lambdabot> Plugin `more' failed with: thread killed
15:46:39 <lambdabot>      n 1: the ability to comprehend; to understand and profit from
15:46:43 <lambdabot> Plugin `dict' failed with: thread killed
15:46:50 <Berengal> Haha
15:46:52 <ivanm> ?
15:47:03 <benmachine> might've been me trying to get through that intelligence definition
15:47:13 <Berengal> Ziphilt: Last I heard he was still working on it, with a dead-tree book in the works
15:47:14 <benmachine> I did about five @mores
15:47:35 <monochrom> I don't know why lambdabot uses 1913
15:47:36 <Ziphilt> Berengal, "dead-tree"?
15:47:40 <Berengal> Ziphilt: paper
15:47:51 <Ziphilt> i should have known
15:48:03 <Twey> monochrom: Copyright expired
15:48:09 <Ziphilt> as opposed to the normal kind, the ones that reside on computers
15:48:15 <Twey> (I guess)
15:48:18 <Berengal> Ziphilt: Indeed :)
15:48:25 <ivanm> Twey: ahhh, fair enough
15:50:29 <Berengal> @type let foldr z f = destructList z (\e l -> f e (foldr z f l)) in foldr
15:50:31 <lambdabot> forall t t1. t -> (t1 -> t -> t) -> [t1] -> t
15:50:39 <benmachine> hurray
15:51:17 <copumpkin> @pl foldr z f = destructList z (\e l -> f e (foldr z f l))
15:51:18 <lambdabot> foldr = fix (liftM2 (.) destructList . (liftM2 flip ((.) .) .))
15:51:27 <benmachine> destructList is pretty much just a case-expression on lists
15:51:31 <Berengal> fix, so automatically disqualified
15:51:40 <Berengal> It is
15:51:43 <Berengal> But so's foldr
15:51:53 <benmachine> but with foldr you don't get the tail of the list
15:51:56 <benmachine> you get the folded tail
15:52:10 <benmachine> so you can't do destructList in terms of foldr, right?
15:52:17 <Berengal> You can
15:52:35 <benmachine> how?
15:53:47 <Berengal> I don't know yet
15:56:46 <ezyang> I wrote this code in Python and immediately felt ashamed that I hadn't written it in Haskell. "print sum(float(x) for x in sys.stdin.readlines())"
15:56:56 <ezyang> I golfed the Haskell downto "main = sum . map read . lines <$> getContents"
15:57:13 <pikhq> Not quite.
15:57:30 <roconnor> do all dcpos have a bottom?
15:57:56 <roconnor> Hmm, I guess the c in cpo says there is a bottom?
15:57:58 <copumpkin> ezyang: use interact
15:58:06 <Saizan> roconnor: and a top
15:58:08 <copumpkin> ezyang: presumably you want to print it out again
15:58:15 <roconnor> or is it (dc) po ?
15:58:18 <ezyang> cool
15:58:20 <ezyang> yup
15:58:52 <MissPiggy> complete-partial-order
15:59:04 <MissPiggy> it means that every sequence has a supremum
15:59:35 <ezyang> runghc seems to print out the val of main
15:59:40 <roconnor> Saizan: I'm confused.  This says that SET is a full subcategory of DCPO
16:00:16 <roconnor> oh
16:00:27 <roconnor> maybe a set is mapped to the DCPO with that set plus top and bottom
16:00:59 <Saizan> i think i'm wrong.
16:01:22 <Cale> Isn't the discrete order directed-complete?
16:01:36 <roconnor> Cale: does it have a bottom?
16:01:54 <Cale> no
16:01:57 <roconnor> ah
16:01:58 <roconnor> good
16:02:32 <roconnor> so a CPO has bottoms
16:02:55 <Saizan> and a DCPO doesn't have to?
16:03:20 <Cale> Yeah, I think that's right.
16:03:38 * Saizan was confusing cpo with complete lattice
16:03:50 <Cale> Though CPO seems like a bit of a misleading term to me.
16:03:58 <roconnor> isn't a cpo a complete lattice?
16:04:01 <roconnor> oh
16:04:03 <roconnor> c is continous?
16:04:03 <Berengal> @type let tail = fst . foldr (\e (s,s') -> (s',e:s')) ([],[]); head = foldr const (error "head"); destructList z f l = foldr (const (const (f (head l) (tail l)))) z l in destructList
16:04:04 <lambdabot> forall a a1. a -> (a1 -> [a1] -> a) -> [a1] -> a
16:04:07 <Cale> complete
16:04:08 <Berengal> \o/
16:04:14 <roconnor> ack
16:04:14 <Saizan> CPO = complete partial order
16:04:17 <roconnor> ok
16:04:25 <roconnor> but if it is complete it has all sups and infs, right?
16:04:37 <roconnor> so it is a lattice? and a complete lattice at that?
16:04:48 <Cale> Wikipedia says that a complete partial order is just a directed-complete partial order with a bottom element, but that seems very suspicious to me.
16:05:02 <roconnor> Cale: that is what this paper says too
16:05:32 <Cale> Well, it's fine as a definition, it just doesn't agree with how I'd expect "complete partial order" to be defined given the name.
16:05:50 <roconnor> and it is also what DOmains and Lambda-Calculi says
16:05:51 <Berengal> So it looks like you need general recursion to define foldr in terms of destructList, but not the other way around
16:06:00 <Saizan> complete lattice is the one with all sups and infs, which doesn't seem to correspond to cpo
16:06:11 <Berengal> I'm cheating by using _|_, but there's probably a clever way of avoiding that
16:06:12 <roconnor> right
16:06:34 <monochrom> all directed subsets have sups. you can call that a kind of "directed-complete"
16:07:06 <roconnor> so is the {_|_} both the initial and final object in CPO?
16:07:09 <Cale> yeah, directed-complete makes sense.
16:07:49 <gwern> and replies to my 13 or 14 emails about missing repos begin coming in
16:07:56 <gwern> goodness that took a while to do!
16:08:06 <Cale> roconnor: No, just the initial
16:08:08 <roconnor> system F is the same thing as the polymorphic lambda calculus?
16:08:16 <monochrom> As for "with bottom", people fight and lose bloody over those things anyway, e.g., "is 0 among the natural numbers".
16:08:18 <Cale> roconnor: There might not be a terminal object
16:08:22 <roconnor> Cale: why isn't it final?
16:08:25 <monochrom> s/bloody/blood/
16:08:35 <Cale> roconnor: Because there are no arrows going into it at all.
16:08:41 <Cale> Except the identity
16:09:03 <roconnor> isn't there an arrow from any CPO that maps everything to bottom?
16:09:05 <Cale> Oh, sorry, I misread you
16:10:15 <Cale> I was thinking that you were talking about a given CPO as a category, and asking if bottom was both initial and terminal, but that's obviously not what you mean.
16:10:41 <roconnor> oh
16:10:42 <roconnor> ya
16:10:50 <roconnor> I'm talking about the cataegory of CPOs
16:10:58 <roconnor> and continuous functions
16:11:04 <Cale> Yeah, seems to work then.
16:12:10 <Saizan> const undefined
16:12:11 <roconnor> is there an interpretation of system F in the category of CPOs?
16:13:15 <Cale> I don't know, but you can generalise CPOs to chain-complete categories, and the basic results on least fixed points still work.
16:13:29 * twink looks at IEEE754 and suspects writing 64*N -bit floating point for arbitrary N could be difficult.
16:13:43 <Saizan> though System F doesn't have general recursion
16:13:53 <Cale> I really ought to look at the definition of System F more carefully sometime
16:14:04 <Saizan> so the domains don't have bottoms?
16:15:11 <roconnor> Saizan: I'm studying Renyold's theorem which says that system F doesn't have Set theoretic semanatics.
16:15:42 <roconnor> Saizan: and a more general version says that DCPOs don't either because it has Set as a subcategory
16:15:58 <roconnor> which seems to mean that bottoms are important
16:16:32 <Cale> ah, right, it doesn't a priori include a fixpoint operator
16:16:56 <Cale> We could smash one in of course :)
16:17:50 <Cale> er, hmm
16:18:32 <noggle> what is this Maybe business?
16:18:38 <roconnor> and continuity is also important becuase PPOS (posets with a bottom and monotonic functions) also cannot interpret system F
16:18:51 <Zao> noggle: Horribly nice type.
16:18:54 <noggle> like, Just [a] might be an empty list
16:19:01 <noggle> or what?
16:19:04 <Zao> Nah, [a] may be an empty list.
16:19:14 <Cale> Waaait, we have type level lambda
16:19:20 <Zao> Maybe t  is either an Just val or a Nothing
16:19:26 <Zao> @src Maybe
16:19:26 <lambdabot> data Maybe a = Nothing | Just a
16:19:29 <noggle> aha!
16:19:29 <Zao> Like that.
16:19:30 <noggle> I see
16:19:51 <Cale> Can't we use type-level lambda to define recursion at the type level and then use that to recover recursion at the value level in System F?
16:19:59 <Zao> Other languages call it an Optional or Nullable.
16:20:02 <noggle> so Maybe [a] might be an empty list or just [a]
16:20:11 <noggle> as demonstrated
16:20:16 <noggle> that is cool
16:20:18 <Zao> Maybe [a] is either a list or no list.
16:20:18 <noggle> somewhat wtf
16:20:26 <noggle> cool
16:20:28 <noggle> that is cool
16:20:29 <Zao> It implies nothing about the list itself, it may be anything a list may be.
16:20:36 <noggle> okay
16:20:46 <noggle> polymorphism
16:20:48 <Zao> > [Just 9001, Nothing, Nothing, Just 3]
16:20:49 <lambdabot>   [Just 9001,Nothing,Nothing,Just 3]
16:21:32 <Zao> > catMaybes [Just 9001, Nothing, Nothing, Just 3]
16:21:34 <lambdabot>   [9001,3]
16:21:42 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Maybe.html
16:21:43 <Draconx|Laptop> Cale, certainly not general recursion, as System F is strongly normalizing.
16:21:49 <roconnor> Cale: system F is strongly normalizing
16:21:52 <noggle> that is some cool stuff
16:21:58 <Cale> Oh, hmm
16:22:21 <Cale> What goes wrong with doing what I just suggested then?
16:22:47 <roconnor> I don't understand how you want to use type-level lambda to define recursion
16:22:54 <Cale> Are types kinded in System F?
16:23:04 <roconnor> no
16:23:10 <roconnor> they are in System F_omega
16:23:32 <Zao> noggle: Much of Haskell is.
16:23:38 <Cale> Then the type language for System F is essentially untyped lambda calculus, plus some primitives?
16:23:48 <Saizan> aren't they still kinded, except that you can only have type variables of kind * ?
16:24:04 <noggle> that maybe business is cool
16:24:07 <Cale> See, this is what I really wanted to know ;)
16:24:13 <noggle> I think I am going to create hangman in haskell
16:24:14 <roconnor> Saizan: sure you can say that.  But that is normally what we mean by unkinded.
16:24:19 <noggle> that is a good first project
16:24:37 <roconnor> the type language for system F is just type variables and arrows AFAIK
16:24:44 <Draconx|Laptop> and foralls.
16:24:46 <roconnor> er
16:24:52 <roconnor> right, there are foralls too
16:24:55 <Cale> roconnor: It also has type-lambda
16:25:03 <Saizan> i understood unkinded to be a parallel of untyped for the term level
16:25:07 <roconnor> the expressions have type lambdas
16:25:16 <roconnor> but not the types.  The types have foralls
16:25:17 <roconnor> so ya
16:25:24 <roconnor> types have type variables foralls and arrows
16:25:46 <Cale> Oh, I see what you mean.
16:26:15 <Cale> It has value-level type lambda just for specialising polymorphism.
16:26:20 <Saizan> i thought you could define Pair = \a b -> forall r. (a -> b -> r) -> r, though maybe i'm wrong
16:26:26 <Cale> But not type level type lambda :)
16:26:35 <twink> I forget if F_\omega or F_\omega^\leq are strongly normalizing or basically any of their other properties.
16:27:24 <Saizan> however, even with type level type lambdas you can't get to define the Rec type, afaiu
16:27:32 <sori> Is there a way to define in Haskell the nowhere-defined function a->b ?
16:27:43 * twink looks at the paper and notes recursive types are some sort of big deal.
16:27:54 <Zao> sori: Depends on what you want it to do, but you could write one.
16:27:58 <Saizan> sori: only as a non-terminating function
16:28:00 <Zao> coerce, cast, whatnot.
16:28:06 <Cale> Saizan: You can if there's no kind system keeping you sane ;)
16:28:23 <Cale> Saizan: because you can just use the Y combinator at the type level then
16:28:24 <sori> Ok...
16:28:29 <twink> (ftp://progftp.vub.ac.be/tech_report/1994/vub-tinf-tr-94-01.pdf)
16:28:42 <Saizan> ah, maybe you were thinking of unsafeCoerce?
16:28:47 <roconnor> Saizan: pair A B a b = /\C.\f:A -> B -> C. f a b and then pair :: forall a b, a -> b -> (forall c. (a -> b -> c) -> c)
16:29:06 <roconnor> PAIR A B := forall C. (A -> B -> C) -> C
16:29:19 <Cale> sori: const undefined
16:29:23 <roconnor> thus pair : forall A B, A -> B -> (PAIR A B)
16:29:36 <sori> Zao,Saizan,Cale: thanks.. i'll try...
16:29:37 <Cale> :t const undefined
16:29:38 <lambdabot> forall a b. b -> a
16:29:45 <Cale> :t undefined :: a -> b
16:29:47 <lambdabot> forall a b. a -> b
16:29:49 <Saizan> roconnor: yeah, but PAIR is not a term there
16:29:56 <Cale> ^^ similar but not identical, because of seq
16:30:03 <Cale> > undefined `seq` 0
16:30:04 <lambdabot>   * Exception: Prelude.undefined
16:30:08 <Saizan> so i guess i was wrong
16:30:10 <Cale> > (undefined :: a -> b) `seq` 0
16:30:11 <lambdabot>   * Exception: Prelude.undefined
16:30:14 <Cale> > (const undefined :: a -> b) `seq` 0
16:30:16 <lambdabot>   0
16:31:20 <sori> so, actually, what I want to do is, write a function    f :: (a->b) -> c   for which I can pattern match on the nowhere-defined function a->b
16:31:36 <sori> I don't know whether this is possible ...
16:31:48 <roconnor> that is not possible.
16:32:00 <Saizan> you want something like an absurd pattern?
16:32:03 <roconnor> you cannot pattern match on functions
16:32:09 <sori> roconnor, I see..
16:32:50 <sori> well, I'm doing a homework.. have to write foldr in the form  foldr = fix f where f = ...
16:33:05 <copumpkin> that's mechanical
16:33:11 <copumpkin> @src foldr
16:33:11 <lambdabot> foldr f z []     = z
16:33:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:33:21 <roconnor> sori: if you could you could probably violate continuity which would destroy the existance of fixpoints, so no more recursion theorem and the universe implodes
16:33:35 <Cale> fix (\foldr f z xs -> ...)
16:33:42 <ivanm> roconnor: depends on how clever f is I suppose...
16:33:46 <sori> Cale, yes I'm trying that
16:33:54 <copumpkin> sori: just write the same thing :)
16:33:56 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
16:33:57 <lambdabot>   3628800
16:34:03 <copumpkin> sori: (with a case statement to do the pattern matching)
16:34:16 <ivanm> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
16:34:16 <ivanm>   3628800
16:34:17 <lambdabot>   3628800
16:34:19 <ivanm> grrr...
16:34:25 <ivanm> this client fails at copy/paste
16:34:29 <ivanm> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) (-1)
16:34:32 <lambdabot>   * Exception: stack overflow
16:34:34 <ivanm> ;)
16:34:57 <Cale> sori: Basically, fix (\f args -> ... f ...) is the same as let f args = ... f ... in f
16:35:30 <ivanm> and it's up to you to define the base case
16:35:36 <Saizan> ?google you could have invented fix too
16:35:37 <lambdabot> No Result Found.
16:35:39 <roconnor> sori: that is a realy good homework question
16:35:45 <Cale> Well, you can use case for pattern matching
16:35:53 <ivanm> true
16:36:01 <sori> and using case, I can match on the empty function..?
16:36:09 <tromp> stand on 2 wheels
16:36:12 <Cale> sori: You don't need to pattern match on a function
16:36:17 <tromp> wrong window:(
16:36:18 <ivanm> isn't function-level pattern matching just syntactic sugar for case statements anyway?
16:36:19 <Cale> sori: You only need to pattern match on the list
16:36:28 <noggle> see you guys later :) thanks for the assistance everyone
16:36:32 <ivanm> sori: what is an empty function? :p
16:36:49 <sori> ivanm, I mean the nowhere-defined partial function..
16:36:56 <Cale> fix (\foldr f z vs -> case vs of [] -> ...; (x:xs) -> ...)
16:37:21 <Cale> sori: I don't understand why you'd need to pattern match on that.
16:37:24 <sori> Cale, I'm trying to understand you!!
16:37:28 * ivanm still doesn't follow what sori is talking about
16:37:29 <Cale> sori: (and you can't anyway)
16:37:57 <Cale> sori: The only pattern you can use for a function is a single variable (or a wildcard)
16:38:09 <sori> Ok..
16:38:19 <Cale> sori: And it's impossible to know (halting problem) if a given function is the everywhere undefined function.
16:38:34 <sori> that's right yes..
16:38:40 <Cale> I think you may be confused about the description of fix
16:38:56 <sori> probably I am..
16:39:36 <Cale> You might be thinking of the description of fix f as the limit of the sequence {undefined, f undefined, f (f undefined), ...}
16:40:33 <sori> Cale, I should try to follow your code above, I think, but what I tried is
16:40:44 <Cale> But f is never actually applied to undefined by fix
16:40:55 <Cale> fix f = x where x = f x
16:41:04 <sori> Ahh, okay, I didn't see that..
16:41:04 <Cale> Or:
16:41:09 <Cale> fix f = f (fix f)
16:41:29 <Cale> (though the latter is not quite as efficient in general)
16:41:40 <Cale> and remember that expressions are evaluated outermost-first
16:41:57 <MaciejP> @where HStringTemplate tutorial
16:41:57 <lambdabot> I know nothing about hstringtemplate.
16:41:58 <Cale> So when you go to evaluate f (fix f), you *don't* immediately expand fix f
16:42:26 <sori> Cale, Ahh,, okay.. i'm beginning to see the problem better..
16:42:56 <ivanm> @google hstringtemplate tutorial
16:42:58 <lambdabot> http://www.haskell.org/haskellwiki/HStringTemplate
16:42:58 <lambdabot> Title: HStringTemplate - HaskellWiki
16:43:03 <ivanm> heh
16:43:45 <Cale> Instead, you expand the definition of f, and plug the expression "fix f" in for the parameter (actually, there's sharing if the parameter occurs more than once in the body, so it will only compute it once)
16:43:54 <MaciejP> ivanm: Yes, but there are lots of totds in it
16:44:14 <MaciejP> ivanm: todos
16:44:29 * Cale never understood why someone would want to use that library.
16:44:51 <sori> hm..
16:45:06 <Cale> HStringTemplate looks like a really complicated way to do something which is conceptually very simple.
16:45:27 <ivanm> Cale: that's what I thought when I first saw it
16:45:32 <ivanm> (haven't really looked at it since)
16:45:58 <ivanm> Cale: AFAICT, it came about from a Java convert that didn't want to think about the Haskellian way of doing things and wanted to write Java in Haskell :s
16:46:16 <MaciejP> Cale: What's a better alternative?
16:46:27 <Cale> MaciejP: concat and show? :P
16:47:14 <ivanm> printf?
16:47:16 <ivanm> pretty?
16:47:37 <Cale> Yeah, for really complicated things there are nice prettyprinting libraries.
16:47:44 <MaciejP> No, I want a seperation of code and layout
16:47:50 <Cale> I like wl-pprint
16:48:05 <ivanm> MaciejP: what do you mean?
16:48:13 <DBAlex> lolz
16:48:13 <Cale> Why not just use more code to define the layout?
16:48:24 <DBAlex> HASKELLIAN?
16:48:28 <DBAlex> is that even a wurd?
16:48:29 <MaciejP> ivanm: Writing a website in Haskell
16:48:39 <ivanm> uhhh, HStringTemplate is even worse than I thought
16:48:46 <Cale> After all, it seems like HStringTemplate contains half an implementation of a programming language anyway
16:48:59 <ivanm> MaciejP: why not use one of the various web-page libraries/frameworks on hackage already?
16:49:01 <theorbtwo> There are very good HTML editors around -- both software and people.
16:49:16 <MaciejP> ivanm: I do :-)
16:49:19 <theorbtwo> It makes a lot of sense to use them when what you want to do is write HTML, not code.
16:49:25 <Cale> If you need runtime loading of code, then use something like hint to load a Haskell module defining the appropriate string/HTML
16:49:38 <MaciejP> ivanm: Happstack makes use of HStringTemplates
16:49:40 <Cale> There are libraries which generate valid HTML
16:49:49 <QtPlatypus> Cale: It seems to be the fate of templating systems to evolove into badly conceeved langauges.
16:50:06 <Cale> http://hackage.haskell.org/package/xhtml
16:50:26 <Cale> It's silly, what you really want are operations in a real programming language for manipulating strings.
16:50:28 <theorbtwo> It does, but the alternative is to take your programming language, and use it as a badly conceeved templating system.
16:50:36 <ivanm> Cale: any libraries you recommend I look at to replace Pandoc in SourceGraph to produce better web page reports?
16:50:45 <DBAlex> omg emacs tetris is addictive... mmm
16:50:45 <ivanm> (rather than trying to hack around pandoc)
16:51:14 <Cale> ivanm: I haven't actually done a whole lot of that, but if you know what HTML you'd like to produce, you can just use the xhtml library I just linked to.
16:52:09 <Cale> Web pages aren't really strings, they're trees. Templating systems operating at the level of strings are obviously the wrong thing.
16:52:16 <ivanm> Cale: I haven't done much web stuff :p
16:52:37 <Twey> Cale: I approve
16:52:40 <Cale> You want *functions* which produce trees of HTML :)
16:52:54 <Twey> Though I do not approve of using xhtml to generate HTML
16:53:19 <regalia> flip f = \x y -> f y x
16:53:23 <Twey> What are you going to do, search-and-replace "/>" to ">"?  And that only works for XHTML1 and (X)HTML5, anyway
16:53:26 <regalia> can someone explain that one to me =\
16:53:34 <Twey> regalia: flip f x y = f y x
16:53:36 <Twey> Better?
16:53:42 <regalia> Twey: I understand that
16:53:49 <Twey> The other is the same thing
16:53:51 <theorbtwo> Cale: I disagree with that premise.
16:53:54 <regalia> Twey: but why :)
16:53:59 <Twey> Just with the second two arguments moved into a lambda
16:54:04 <Cale> regalia: It takes a function of two parameters, and produces the function of two parameters, but with the parameters in reverse order.
16:54:10 <ivanm> Twey: why not?
16:54:14 <regalia> Yes yes, I know what the function does
16:54:15 <MaciejP> Cale: The point is, as a programmer you actually don't care what the produces HTML looks like. This is what the web designers should take care of.
16:54:18 <ivanm> (use xhtml to generate HTML)
16:54:22 <regalia> But I want to know why those two are equivelent
16:54:38 <regalia> equivilant*
16:54:39 <mrshoe> regalia: the \x y -> bit is the syntax for creating a lambda
16:54:45 <regalia> yup
16:54:54 <Cale> There's nothing wrong, in my opinion, with forcing people to use a better language to express the HTML.
16:54:55 <regalia> so \x takes one arg, y correct?
16:55:00 <theorbtwo> Normally, you should make programming that looks like programming, and is easy for programmers.  You want HTML that looks like HTML, and is easy for designers.
16:55:07 <hello> oh my god a proramming room that works!
16:55:08 <Twey> ivanm: Only XHTML1 <=> HTML4 and XHTML5 <=> HTML5 are compatible like that, and even then they're not necessarily
16:55:19 <mrshoe> nope, \x y creates a lambda that takes two args: x and y
16:55:44 <Cale> I'd rather force people to use something which ensures that the generated HTML is valid by construction.
16:55:49 <regalia> mrshoe: Ahhhh!
16:55:51 <monochrom> (\x y -> z) is (\x -> \y -> z)
16:55:55 <regalia> Got it :)
16:55:57 <Guest99072> wow
16:56:02 <Twey> ‘\x y -> body’ is a lambda of two arguments, x and y, that, when they are supplied, evaluates to ‘body’
16:56:26 <regalia> Awesome, I get it now, thanks guys :)
16:56:32 <Twey> ivanm: And for HTML4 you have to parse out the bits of XHTML1 that are not compatible after generation
16:56:38 <Guest99072> i apologize for interrupting but if anyone has a moment id like to ask a question i am unsure of the room rules so please forgive me
16:56:42 <Twey> ivanm: Like self-closing tags
16:56:46 <Cale> And won't run into problems whereby interpolated strings can be injected and mess things up.
16:56:53 <theorbtwo> Guest99072: On IRC in general, don't ask to ask.  Just ask.
16:56:59 <QtPlatypus> Guest99072: Just ask
16:57:01 <Guest99072> ah
16:57:04 <Guest99072> thanks guys
16:57:04 <Twey> Guest99072: Standard Marquis of Stallman rules apply
16:57:15 <Guest99072> well im andy sorry about the nick
16:57:40 <Twey> Guest99072: http://catb.org/~esr/faqs/smart-questions.html
16:57:41 <theorbtwo> Guest99072: Type /msg nickserv help if you want to sort out the nick, or just /nick foo, where foo is something that isn't already taken.
16:57:46 <Guest99072> i am taking java and man it is proving tough partially because its online and partially because of the instructor
16:57:48 <Twey> Oh, Raymond.  Pardon me.
16:57:52 <theorbtwo> (Apparently, "hello" is already.)
16:57:54 <Cale> Guest99072: (In general, nobody can tell if they can answer your question without knowing what the question is :)
16:58:06 <Cale> Guest99072: This room is about Haskell programming, rather than Java programming.
16:58:11 <regalia> #java
16:58:21 <Twey> You'll need to register first.
16:58:30 <Guest99072> oh im sorry it is pretty simple stuff i could imagine though
16:58:34 <Twey> /msg nickserv help register
16:58:35 <ivanm> it's ##java, not #java IIRC
16:58:41 <Twey> Yeah, but it redirects
16:58:43 <ivanm> and they are unbelievably unhelpful and rude
16:58:44 <ivanm> oh
16:58:45 <Guest99072> ahh i googled my mistake
16:58:53 <QtPlatypus> (BTW what does ## mean?)
16:59:01 <Twey> QtPlatypus: Unofficial channel
16:59:01 <Cale> QtPlatypus: It means unofficial
16:59:14 <Twey> QtPlatypus: #java would have to be run by Sun, for example
16:59:23 <Twey> (or approved by Sun)
16:59:26 <Twey> (Oracle?)
16:59:26 <Guest99072> ah is see
16:59:27 <dobie_gillis> or Oracle, now :/
16:59:29 <ivanm> and #C would have to be run by AT&T? :p
16:59:32 <Twey> Yeah :þ
16:59:33 <monochrom> Java DOM and SAX prove to be tough because I'm so used to Haskell HXT.
16:59:50 <Twey> #math is run by god… or so some of them think of themselves ;)
16:59:54 <Guest99072> well its this new project  given to me
16:59:54 <monochrom> And yeah, down with string escaping by hand.
17:00:33 <theorbtwo> Cale: I don't think the way you are suggesting is the right path here... and I think you can solve the interpolation problem with typesystems... but that doesn't imply that you should try to make your designers learn Haskell.
17:00:34 <Guest99072> i have to make a car rental program that can assign a customern name make and rating key
17:00:35 * Cale used to be more watchful over #math, but got tired of coping with certain "helpful" people.
17:01:13 <Cale> theorbtwo: They don't have to learn all of Haskell, just a particular subset of it necessary for defining pages :)
17:01:14 <Guest99072> anybody think they would know anything about this in java?
17:01:18 <monochrom> What is ""helpful" people"?
17:01:33 <Twey> Guest99072: I'm sure that they would, although that's terribly basic stuff
17:01:40 <Twey> Guest99072: You might have more luck reading a good tutorial
17:01:42 <nagnatron> Guest99072: Is this your homework?
17:01:47 <Guest99072> well yeah
17:01:54 <Guest99072> i am actually just stuck
17:01:55 <monochrom> (Should I write "&quot;helpful&quot; people"? :) )
17:01:57 <m3ga> so, where's the "Javascript for people who are smart enough to code in haskell" tutorial, because all the Noddy's guide tutorials give me the shits.
17:02:04 <Twey> Guest99072: http://java.sun.com/docs/books/tutorial/java/index.html for example
17:02:15 <theorbtwo> m3ga: Try Javscript: The Good Parts.
17:02:29 <mrshoe> Guest99072: you could ask in #clojure so at least your instructor could run the resulting code ;-)
17:02:46 <m3ga> thanks theorbtwo
17:03:17 <Guest99072> well i just cant understand why i keep turning up a null
17:03:18 <Cale> monochrom: People who are knowledgeable, but often respond with answers that are obviously inappropriate to the knowledge level of the person asking the question, and/or will be mean to beginners but helpful when responding to advanced questions.
17:03:26 <Guest99072> i have set the instance fields in the tester
17:03:34 <Twey> Guest99072: Paste it somewhere — http://paste.lisp.org/ for example
17:04:40 <Cale> monochrom: People who are just trolling are easy to deal with -- you just kick them. But when someone is helpful a good portion of the time, and contributes, but also contributes to an unfriendly atmosphere, it's really annoying.
17:04:59 <nagnatron> m3ga: The author of that book(i forget the name) held some lectures at yahoo i think. There are videos online.
17:05:36 <theorbtwo> Cale: I can certianly understand that, though personal experince with ##C makes me wish you'd stayed.
17:05:45 <theorbtwo> You seem more reasonable then half the people there.
17:05:51 <QtPlatypus> Cale: That person isn't in #math anymore.
17:06:12 <Cale> QtPlatypus: I'm not talking about any one person
17:06:27 <Guest99072> pasting
17:07:59 <MissPiggy> sometimes in here I tell people things but someone says "That guy is a newbiew don't dare tell him about the secret of the <difficult concept>"
17:08:02 <QtPlatypus> Doen't paste into the channel use a pastbin
17:08:24 <ivanm> and don't show us Java code; must of us are Java refugees! :p
17:08:28 <MissPiggy> and it's like but why? this is so simple compared to having fragmented knowledge as if you are in high school math
17:08:29 <tensorpudding> is it bad to say things that are correct but possibly confusing?
17:08:44 <Cale> MissPiggy: Mostly that applies to unsafe* functions, which shouldn't really be used by anyone whose first name isn't Simon.
17:09:11 <monochrom> or the Don
17:09:24 <Guest99072> http://paste.lisp.org/+21PA.
17:09:27 <ivanm> he's a mafia crime lord now? :p
17:09:28 <Guest99072> thats the class
17:09:47 <ivanm> so.... Java code pasted into a lisp pastebin and given to a Haskell IRC channel?
17:09:51 * Cale weeps for the indentation.
17:09:52 <monochrom> I watched too much Godfather because I bought a box set at a low price. :)
17:09:54 <MissPiggy> im trying to do algeba in Coq (so I can follow along with my haskell code)
17:09:57 <nagnatron> triple combo
17:09:59 <ivanm> monochrom: heh
17:10:16 <MissPiggy> I can't figure out a design that works though
17:10:23 <monochrom> "Don Stewart wants your service for the family! err community!"
17:10:34 <pikhq> I'd also like to note that noobs really shouldn't see the word "monad" until well after they grok do notation. :P
17:10:40 <Cale> Just because Java isn't indentation-sensitive doesn't mean that you shouldn't be careful about how much you indent each line...
17:11:02 <Cale> pikhq: Well, there are many ways to do it.
17:11:16 <theorbtwo> I'm not sure.
17:11:16 <Guest99072> well the paste actually did that
17:11:18 <monochrom> Cale: I have a theory why some programs are absurdly indented. Their authors know pico only.
17:11:21 <MissPiggy> I can basically mirror the typeclass structure exactly
17:11:21 <pikhq> (category theorists exempted)
17:11:25 <Guest99072> its not like that in the compiler
17:11:26 <Cale> pikhq: But I agree that introducing people to specific monads first makes sense.
17:11:28 <MissPiggy> that seems to be the best way so far
17:12:06 <Cale> Oh, I see, it's because you're mixing tabs and spaces.
17:12:08 <pikhq> Cale: Most certainly. Just abstracting what you've already been *doing* is much easier than going from an abstraction to specific details, after all.
17:12:38 <pikhq> Guest99072: What's with the newlines at the end?
17:12:58 <monochrom> I have seen 4th-year vocation-track compsci students using pico for all their coding assignments. Yes, students who have had coding assignments for 3+ years.
17:13:23 <pikhq> monochrom: o.o
17:13:25 <Guest99072> well this is my 4th one and first ever programming class
17:13:33 <tensorpudding> people still use pico?
17:13:35 <Guest99072> I added the tester class
17:13:46 <ivanm> I've used nano for quick and dirty edits...
17:13:48 <ivanm> that's about it
17:13:53 <pikhq> tensorpudding: Actually, they use the Pico-alike entitled nano.
17:13:59 <tensorpudding> i thought so
17:14:04 <pikhq> And I use it for quick edits for no particular reason.
17:14:05 <tensorpudding> i haven't seen pico in a while
17:14:12 <tensorpudding> i hate pico though
17:14:15 <sori> Cale, now I got it. Unfolding the definition helped. Thanks!!:)
17:14:23 <Cale> sori: No problem :)
17:14:28 <pikhq> (maybe a full emacs just puts me in a different mindset or something?)
17:14:38 <tensorpudding> for some reason it's the default editor on a few linux distributions
17:14:41 <aavogt> pikhq: hmm, then teach assembly before high level languages?
17:14:48 <monochrom> unfolding definitions always helps. rule #0 in Gries & Schneider's discrete math book.
17:15:37 <Cale> Guest99072: I'm guessing that in the constructor CarRental, you don't just want to define three local strings which are equal to the parameters of the constructor and which are immediately discarded.
17:15:46 <mrshoe> gotta love java.. the first code they teach you to write is 100% boilerplate that shouldn't need to be written
17:15:46 <pikhq> aavogt: Though technically high-level languages are abstractions on assembly, in practice assembly is a de-abstraction of high-level languages. :P
17:15:48 <copumpkin> tensorpudding: probably don't want to get into emacs/vim wars
17:16:02 <Guest99072> well i thought it was pointless!
17:16:07 <Guest99072> but i wasnt sure
17:16:12 <tensorpudding> it's not that big of a deal so long as you have a vi on the system
17:16:13 <twink> What's the interpolation problem?
17:16:16 <Guest99072> i have been typing this tryin to understand the reason behind it
17:16:27 <Draconx|Laptop> hm, how do I teach Cabal about 'extra-tmp-files' that should _not_ be deleted by './Setup.lhs clean -s'?
17:16:44 <pikhq> tensorpudding: Well, nano's pretty much the sane default. Noobs won't be *too* afraid of it, and anyone who knows better can change it.
17:16:54 <Cale> twink: context?
17:16:56 <tensorpudding> but the gentoo installer only has nano, and you're expected to write your own config files
17:17:09 <ivanm> pikhq: which is exactly why gentoo uses it as the default editor (despite people's whining that it should be a variant of vi)
17:17:11 <pikhq> The Gentoo installer is *exceptionally* barebones.
17:17:17 <pikhq> ivanm: Quite.
17:17:18 <monochrom> twink: Example: f x = "<em>" + x "</em>", and then you use f "0 < 1".
17:17:27 <tensorpudding> would it kill them to put in vi?
17:17:32 <ivanm> plus it has low number of dependencies
17:17:43 <ivanm> tensorpudding: Gentoo is all about customisability
17:17:47 <pikhq> ivanm: Though for *Gentoo* it's more that nano is the least offensive editor.
17:17:48 <monochrom> Sometimes also f "</em>"
17:17:49 <ivanm> you can install vi if you want
17:17:51 <twink> Cale: theorbtwo saying he thought you could solve the interpolation problem with typesystems.
17:17:52 <tensorpudding> so they toss in a worthless editor?
17:17:54 <ivanm> pikhq: yeah
17:17:55 <Draconx|Laptop> tensorpudding, gentoo comes with a vim clone: busybox vi
17:18:01 <Cale> twink: Oh
17:18:10 <tensorpudding> Draconx|Laptop: are you sure?
17:18:17 <Guest99072> so Cale what do you propose I do because just testing customer name it comes u null
17:18:24 <Draconx|Laptop> tensorpudding, quite certain.
17:18:24 <pikhq> tensorpudding: Just emerge vim once you're in the chroot, et voila.
17:18:25 <Cale> twink: Well, you can help make it easier not to mess up.
17:18:26 <tensorpudding> i couldn't find any editor at /usr/bin/vi
17:18:37 <Draconx|Laptop> tensorpudding, that's because you run busybox vi by typing.... busybox vi
17:18:39 <tensorpudding> (this conversation should move elsewhere)
17:18:47 <Guest99072> i have done this same code with double instead of string and it works
17:19:04 * twink isn't wild about vim, and goes with nvi instead. Sometimes, ex or ed if terminal emulation is going wrong.
17:19:18 <monochrom> twink: Perhaps the most comical example is http://xkcd.com/327/
17:19:25 <Cale> twink: Basically the problem occurs where you have strings which are being inserted into the middle of strings which are not really strings but represent something with a particular structure that ought to be maintained.
17:19:36 <Guest99072> holy cow
17:19:41 <Guest99072> you are neo!
17:19:42 <Guest99072> hah
17:19:42 <theorbtwo> twink, Cale: In essence, you make HTML and generic string different types, and you define ++ on the various combinations to do it right.
17:19:59 <twink> Cale: Sounds difficult without dependent types.
17:20:36 <Guest99072> so can you do that with if else?
17:20:41 <theorbtwo> Actually, it's mostly just difficult without metaprograming and generics.
17:20:50 <Cale> The right way to solve it is not to do interpolation at all, but to use a type which properly represents the structure of the data, together with a function which properly flattens the structure into a string at the end.
17:21:14 <Cale> (and which handles the issues of quoting at that point)
17:21:35 <Guest99072> well i kinda have the instructors instructions too
17:21:47 <twink> Cale: Sounds like what I'd recommend.
17:21:57 <theorbtwo> Cale: You'll get something that isn't terribly usable, involves lots of hand-coding, or hacks around a lack of dynamic coding, and is overly closely tied to HTML.
17:22:01 <Cale> Guest99072: (this bit about interpolation is a different discussion, by the way)
17:22:27 <Guest99072> ah
17:22:46 <Cale> I think you usually end up with something that's much more usable than HTML is directly.
17:22:53 <Cale> Given that HTML has such garbage syntax.
17:23:21 <theorbtwo> It's a syntax that people who have any business writing HTML already know, though.
17:23:52 <Cale> HTML and XML are a couple rare examples of languages where writing the code for their abstract syntax trees is actually easier than writing the parsed string.
17:23:53 <twink> Not tough to beat HTML by hammering together a data structure of HTML syntax trees and then using Read/Show.
17:24:07 <monochrom> I use HXT and has no injection problem. I write like mkelem "p" [mkattr "script" "f(a&&b)"] [txt "1<0"]. This creates <p script="f(a &amp;&amp; b)">1&lt;0</p>>
17:24:16 <Cale> monochrom: exactly.
17:25:17 <Cale> monochrom: heh, though it probably shouldn't quote inside attributes like that
17:25:23 <monochrom> Similarly you should do this to SQL, where millions of dollars are at stake. I mean, with XML, the worst you get is parser error. With SQL, you lose data, leak data, get compromised.
17:25:24 <Guest99072> well thanks guys i think i need nothing short of a miracle to get through this one the way my class runs
17:26:04 <Cale> Guest99072: If your question was about Haskell, it'd probably get more attention. You're in a channel mostly full of people who despise Java.
17:26:33 <theorbtwo> monochrom: Depends on the XML in question.
17:26:36 <Cale> If you're writing for the JVM, at least use Clojure or Scala or something. :)
17:27:00 <monochrom> Cale: The absolute minimum to quote inside attribute values is still & and < , because sometimes you want to say <p x="&#3948;">
17:27:02 <theorbtwo> I've heard tell of stacking bugs that can cause severe money loss by poorly-formed XML.
17:27:07 <enthymene> yeah was about to suggest Clojure
17:27:12 <pastorn> i have a monad stack that are three monads deep, but i can't make any instance of MonadTrans with GeneralizedNewtypeDeriving :(
17:27:18 <theorbtwo> monochrom: No, it's & and " or '.
17:27:30 <monochrom> Hrm!
17:27:50 <Cale> monochrom: Does the JavaScript code there actually work with the character entities expanded like that?
17:27:55 <pastorn> newtype MIRKK a = MIRKK { unMIRKK :: StateT Varz (ReaderT Handlez IO) a }
17:27:57 <pastorn>     deriving ( Monad, MonadState Varz, MonadReader Handlez, MonadIO)
17:28:15 <pastorn> ^^ i want to remove MonadIO and make it to MIRKK m a with MonadTrans derived
17:28:20 <theorbtwo> Cale: Yes; the browser unescapes the attributes before handing it to the javascript interpreter.
17:28:29 <Cale> theorbtwo: ah, good
17:28:40 * twink just looked at Guest99072's paste.lisp.org entry and is doubting there is enough content to comment upon.
17:28:47 <theorbtwo> (For a script attribute, not for a script tag; the script tag is magical in HTML, but, IIRC, not xhtml.)
17:29:07 <Cale> In any case, it's something which the library ought to know ;)
17:29:17 <monochrom> OK, http://www.w3.org/TR/2008/REC-xml-20081126/#sec-common-syn and scroll down a bit for AttValue says: need to escape < & ' if inside ".
17:29:26 <Cale> I certainly don't want to remember how everything is supposed to be quoted.
17:30:02 <theorbtwo> The toolkit you use should certianly protect you from that.
17:30:16 <theorbtwo> However, it should do so without having to *stop actually using HTML*.
17:30:33 <Cale> Well, depends on what you mean by "use"
17:30:35 <monochrom> I just found out last night that IE 8 does not unescape &apos; in attribute values.
17:30:58 <Cale> I think it's appropriate to generate HTML. I just don't think you should write strings of actual HTML code by hand.
17:31:47 <theorbtwo> Cale: It depends on what you mean by "by hand".
17:33:03 <Cale> Any process whereby the generated code could possibly fail to be valid.
17:33:37 <theorbtwo> Cale: Yeah.  I'm a lot less concerned by that then you are.
17:33:51 <Cale> You might not generate the page you were after, but there's no excuse for producing invalid HTML.
17:34:07 <theorbtwo> I'm all for making it *difficult* to create invalid code, especially as a result of user input.
17:34:08 <Cale> Because you can let a library take care of it for you.
17:34:40 <monochrom> pastorn: You want newtype MIRKK m a = MIRKK { unMIRKK :: StateT Varz (ReaderT Handlez m) a } deriving lots-of-things?
17:34:42 <Cale> and any invalid HTML code then becomes the library maintainer's problem
17:34:43 <theorbtwo> For one thing, generating invalid HTML can often be quite useful.
17:35:00 <Cale> oh?
17:35:23 <theorbtwo> For one thing, it allows the library to be useful when generating things that simply aren't supposed to be HTML.
17:35:42 <theorbtwo> (Such as xhtml with embedded svg, plain old svg, rss...)
17:35:47 <theorbtwo> ...text, even.
17:35:47 <Cale> If you're generating something else, you should use another library.
17:36:11 <Cale> One which enforces the invariants on whatever language it is that you're generating.
17:36:13 <HugoDaniel> those llvm results seem fantastic!
17:36:30 <monochrom> For every use, you can delineate clearly what is valid and what is invalid, then restrict to valid only.
17:36:57 <nus> which results, dons playing with vector?
17:37:02 <theorbtwo> No, you really can't.  See plain text.
17:37:16 <theorbtwo> Moreover, such a thing *simply isn't terribly useful*, in most cases.
17:37:23 <monochrom> As long as your target language is not all of Σ*, there is always an "invalid".
17:37:24 <HugoDaniel> nus: yes those
17:37:25 <HugoDaniel> :)
17:37:33 <Cale> HugoDaniel: Which results? The paper describing the LLVM backend announced mostly pretty mediocre results (but which were quite reasonable given the simplicity of the backend)
17:37:39 <HugoDaniel> i always like dons opinion! he is clearly biased :D
17:38:19 <Cale> theorbtwo: Plain text is mostly handled well with strings and concatenation -- but even there you have encoding issues which should be handled at the library level.
17:38:48 <theorbtwo> Cale: I agree... which is why I suggest using a library that solves them, without making life overly difficult for yourself.
17:38:52 <Cale> I don't want to have to be concerned with how to generate valid strings of bytes for UTF-8
17:38:53 <HugoDaniel> im also a haskell zealot, but i can't argue that well
17:39:08 <theorbtwo> Cale: Quite so.
17:39:43 <Cale> theorbtwo: So, I use a library which does this (in GHC 6.12, it will be the standard IO library :)
17:40:01 <theorbtwo> It didn't do so before 6.12?  That's depressing.
17:40:05 <Cale> theorbtwo: I also wouldn't attempt to generate C code as strings.
17:40:08 <theorbtwo> Doing so is a no-brainer.
17:40:22 <theorbtwo> Cale: I might.  It depends on my application.
17:40:30 <theorbtwo> Clearly, people do all the time.
17:40:50 <Cale> theorbtwo: The String type has always allowed for Char values which represent each unicode code point, but until 6.12, the IO actions didn't do any text encoding apart from line endings.
17:40:54 <theorbtwo> ...it's called typing C into an editor.
17:41:31 <theorbtwo> There are times when you want to generate HTML, or CSS, or what-have-you, on a high level.
17:41:31 <Cale> theorbtwo: Okay, yes, I guess I don't think of C as a language which people write by hand anymore ;)
17:41:34 <monochrom> We are working on abolishing that, too.
17:41:50 <theorbtwo> Most of the time you don't.  You want to fill in a few blanks.
17:42:05 <Cale> C is a target language ;)
17:42:12 <theorbtwo> Working on the right level of abstraction makes things a lot simpler.
17:42:37 <theorbtwo> When I'm generating HTML code, I want to do it by writing the HTML code first, then adding the generation in, most of the time.
17:42:42 <theorbtwo> ...even if only mentally.
17:43:06 <Cale> I don't like the syntax of HTML, and would prefer to write something in a higher level library.
17:43:13 <Cale> Even if I'm writing a static page.
17:43:24 <theorbtwo> Cale: Then you really have no business writing HTML.
17:43:26 <Cale> HTML has no mechanism for abstraction.
17:43:43 <Cale> Which automatically makes it a terrible language.
17:43:44 <theorbtwo> HTML *is* a mechanism for abstraction.
17:43:57 <nus> eh?
17:44:22 <Cale> If you have repetitive structures in your HTML code, you can't do anything about it except to write a program in another, different language, which will produce them.
17:44:32 <theorbtwo> Correct.
17:45:02 <Cale> That's what I mean by "no mechanism for abstraction"
17:45:05 <theorbtwo> (Well, not technically.  You can define an entity, but that covers only completely repetitive structures.)
17:45:23 <theorbtwo> Cale: That makes it a bad programming language, which is unsurprising... it's not a programming language at all.
17:46:07 <theorbtwo> It's a page description language.  (The line moves around on how much it's supposed to describe semantics and how much it's supposed to describe layout.  That's a topic for another debate.)
17:46:45 <cYmen> I was wondering if it's possible to do serious image processing in haskell.
17:47:00 <theorbtwo> That doesn't imply that you can write a program to produce decent HTML without having an understanding of it's strengths and weaknesses, it's soul as a language.
17:47:08 <cYmen> I came across some example when googling but basically they didn't really code normal haskell anymore to make it reasonably fast.
17:47:08 <Cale> cYmen: What is "serious"?
17:47:25 <theorbtwo> cYmen: Sure.  Image processing is mostly just numeric processing.
17:47:32 <cYmen> Cale: Like realtime filtering of a videostream from a webcam.
17:47:52 <Cale> Hmm...
17:48:06 <cYmen> I'm asking because in C++ people usually make a big mess with pointers to get it fast and I couldn't find any example code in haskell..
17:48:26 <Cale> I've never seen anyone do anything with video in Haskell, but conceptually it should be possible.
17:49:00 <Cale> You could even do the low-level tricks and write/use a library which abstracts them away.
17:49:13 <Cale> http://hackage.haskell.org/package/atom
17:49:16 <nus> cYmen, raw or compressed video?
17:49:25 <MaciejP> Cale: Not serious: http://professor-fish.blogspot.com/2009/12/major-breakthrough-in-image-processing.html :-D
17:50:05 <SubStack> I've done video processing in python, so it's definitely possible
17:50:10 <pikhq> cYmen: The typical Haskell solution to that sort of thing is "Do what needs to be exceptionally fast in very low-level Haskell or in C, and write everything else in idiomatic Haskell."
17:50:31 <SubStack> polling the crappy web cam I had was by far the slowest part
17:50:54 * copumpkin wonders what cYmen's first haskell package on hackage would be called
17:51:38 <cYmen> monkeybusiness
17:51:44 <cYmen> or some lame acronym...
17:54:00 <copumpkin> I was referring to the fact that many haskell packages have H at the beginning of their names ;)
17:54:48 <cYmen> ah...a new version of a joke I have heard _a lot_ ;)
17:55:02 <djahandarie> HHHHHHHHHHHHHHHHH... I got caught in infinite recursion when naming my package!
17:55:22 <zygoloid> djahandarie: is that package a haskell wrapper around... itself?
17:55:45 <theorbtwo> It looks like he's got it all wrapped up.
17:55:49 <copumpkin> djahandarie: TMI, keep information on your package to yourself
17:55:53 * theorbtwo puts on sunglasses.
17:55:58 <theorbtwo> Yeaaaaaah!
17:57:47 <zygoloid> newtype FixHType = FixHType { runFixH :: IO FixHType }; foreign import "runFixH" importedRun :: FixHType -> IO FixHType; foreign export runFixH;
17:58:08 <djahandarie> lol
18:02:20 <Hunner> So when I get something like "Couldn't match expected type [foo] against inferred type IO [foo]" how am I supposed to think of this?
18:02:39 <ivanm> Hunner: you're trying to treat an IO value as a normal value
18:02:41 <ivanm> which you can't
18:03:17 <Hunner> Yeah... so what do people do normally with this?
18:03:51 <ivanm> you put your function into the IO monad, rather than trying to pass the IO value to a function
18:07:07 <tehgeekmeister> how do you represent a negative numeric literal in haskell?
18:07:19 <tehgeekmeister> i know - isn't it, but that means you also can't multiply by -1
18:07:35 <ivanm> > (-1)
18:07:36 <lambdabot>   -1
18:07:52 <ivanm> > -(2*(-3))
18:07:53 <lambdabot>   6
18:08:23 <tehgeekmeister> right, need the ()
18:08:24 <tehgeekmeister> forgot
18:08:26 <tehgeekmeister> thanks!
18:08:29 <theorbtwo> tehgeekmeister: To put it shortly -- the obvious way.  You can't use the prefix - directly after another piece of puncuation, though, IIRC.
18:08:29 <zygoloid> tehgeekmeister: there are no negative numeric literals in haskell. only nonnegative literals and unary negation
18:08:41 <theorbtwo> Hm.  Am I wrong here?
18:08:42 <theorbtwo> > -1
18:08:43 <lambdabot>   -1
18:08:51 <theorbtwo> > -2 * -3
18:08:52 <lambdabot>   Precedence parsing error
18:08:52 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
18:08:59 <theorbtwo> OK, apparently I am.
18:09:04 <ivanm> zygoloid: interesting way of putting it
18:12:56 <zygoloid> incidentally, this means 'fromInteger' on Bounded types where minBound == -maxBound - 1 must 'work' even when given toInteger maxBound + 1.
18:13:05 <zygoloid> > fromInteger 2147483648 :: Int32
18:13:06 <lambdabot>   -2147483648
18:14:35 <asodifj> DCC SEND C://////////////////////////////////////
18:15:05 <zygoloid> @where ops
18:15:05 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
18:16:04 --- mode: ChanServ set +o monochrom
18:16:08 --- mode: monochrom set +b *!*@user-0c99d03.cable.mindspring.com
18:16:08 --- kick: asodifj was kicked by monochrom (asodifj)
18:18:27 <nus> > (+1)(maxBound::Int)
18:18:28 <lambdabot>   -9223372036854775808
18:18:36 <ivanm> > minBound :: Int
18:18:38 <lambdabot>   -9223372036854775808
18:18:52 <ivanm> > pred minBound :: Int
18:18:53 <lambdabot>   * Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
18:19:05 <ivanm> > succ maxBound :: Int
18:19:06 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
18:19:25 <ivanm> bugger; I normally use succ/pred for +1/-1
18:19:33 <ivanm> > subtract 1 minBound :: Int
18:19:35 <lambdabot>   9223372036854775807
18:20:05 <djahandarie> ivanm, that behavior might actually be nicer
18:20:12 <djahandarie> > pred maxBound :: Int
18:20:13 <lambdabot>   9223372036854775806
18:20:14 <ivanm> djahandarie: what, crashing?
18:20:28 <copumpkin> @let zomg x = (x :: Int) + 9223372036854775807
18:20:30 <lambdabot>  Defined.
18:20:33 <copumpkin> > zomg 5
18:20:34 <lambdabot>   -9223372036854775804
18:20:38 <djahandarie> ivanm, an exception. It is better than silently wrapping at least
18:21:02 <theorbtwo> The great problem of purity: Almost nothing cannot error.
18:21:03 <ivanm> @slap copumpkin
18:21:04 * lambdabot moulds copumpkin into a delicous cookie, and places it in her oven
18:21:45 <copumpkin> theorbtwo: why not: not almost nothing cannot not error?
18:21:56 <copumpkin> are we classical in here, anyway?
18:22:16 <tensorpudding> the law of the excluded muddle
18:22:42 <theorbtwo> Fine.  "There is almost nothing you can do without risk of an error occouring".
18:23:00 <tensorpudding> "if p or (not p) is false, that's pretty confusing, so we'll exclude it"
18:23:27 <copumpkin> :)
18:27:02 <aavogt> @src groupBy
18:27:02 <lambdabot> groupBy _  []       =  []
18:27:02 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
18:27:02 <lambdabot>     where (ys,zs) = span (eq x) xs
18:30:06 --- mode: monochrom set -b *!*@user-0c99d03.cable.mindspring.com
18:30:10 --- mode: monochrom set -o monochrom
18:47:36 <copumpkin> how are existentials related to (a -> r) -> r? is an (a -> r) -> r basically a proof of exists a ?
18:50:18 <ivanm> huh?
18:51:35 <monochrom> Yeah I essentially disagree that they are related.
18:52:44 <copumpkin> http://twitter.com/luqui/status/9516175098
18:53:00 <monochrom> twit?!
18:53:24 <copumpkin> forall r. (forall a. (a -> n, a) -> r) -> r
18:53:33 <ivanm> copumpkin: doesn't look like what you wrote
18:54:11 <copumpkin> well, mine is more general :P
18:54:17 <copumpkin> but yeah, I misremembered
18:54:30 <monochrom> Oh, t is more general yet.
18:56:06 <monochrom> Usually you have data MyExistential = forall a. MyCtor (a->Blah) a
18:56:39 <Saizan> "forall r. (Something -> r) -> r" is a general scheme for the church encoding of Something
18:56:52 <copumpkin> yeah, that's the simple way of doing an existential
18:56:59 <monochrom> the function a->Blah is a getter method for your existential type.
18:57:03 <copumpkin> and I know how it works with dependent pairs
18:57:11 <Saizan> e.g. (a,b) becomes forall r. ((a,b) -> r) -> r ~ forall r. (a -> b -> r) -> r
18:57:26 <monochrom> So (a->n, a) plays the role of MyCtor (a->Blah) a
18:58:25 <Saizan> now, an existential is sort of a pair fo a type and a value of that type, exists s. s becomes forall r. ((exists s. s) -> r) -> r ~ forall r. (forall s. s -> r) -> r
19:02:20 <ivanm> preflex: seen Axman6
19:02:20 <preflex>  Axman6 was last seen on #haskell-blah 4 hours, 47 minutes and 2 seconds ago, saying: you Jon?
19:02:48 <ivanm> @tell Axman6 just heard that the printing system is down all across ANU atm, and so printing is apparently _free_ (if you needed anything printed)
19:02:48 <lambdabot> Consider it noted.
19:06:01 <monochrom> Anyway, don't believe everything you see in twits.
19:06:44 * ivanm points out the monty python sketch "upper class twit of the year"
19:08:54 <copumpkin> monochrom: but it's luke palmer!
19:09:07 <copumpkin> he's never wrong
19:15:38 <Saizan> oh, a nice way to say this is that given "data Exists f = forall a. Exists (f a)"  then  "Exists f ~ forall r. (forall a. f a -> r) -> r"
19:18:20 <Saizan> uh, we have -Odph ?
19:18:41 <copumpkin> yep
19:28:34 <b4taylor> Anyone do networking with Haskell?
19:28:38 <Kruppe> Im looking for a fast random number generator. System.Random is just not cutting it. Is there a good general purpose one out there?
19:28:40 <b4taylor> I am having trouble with: client msg -> server, server print msg, server msg -> client, client print msg.
19:29:53 <b4taylor> But I can do: client -> server, or server -> client, after connections.
19:30:06 <b4taylor> But not, client -> server, then respond server -> client.
19:30:25 <dolio> Kruppe: There's a mersenne package on hackage. Also, one written by bos that's even faster, but I don't know what package it's in.
19:30:40 <dolio> Might be in the statistics package? Or criterion?
19:31:09 <Kruppe> dolio: thanks! I'll take a look
19:31:12 <ivanm> dolio: it got split off from statistics
19:31:27 <dolio> mwc-random?
19:31:29 <ivanm> Kruppe: look at the deps for statistics, one of them will be the random generator package
19:31:34 <ivanm> dolio: yeah, that'd be it
19:31:37 <b4taylor> Oh I wonder if I'm sending a newline.
19:31:40 <b4taylor> I'm prolly not.
19:31:54 <ivanm> it's generally recomended over the two mersenne ones nowadays as it's more haskelly than mersenne (which is more imperative)
19:32:11 <monochrom> You can also add a lot of hFlush's.
19:32:14 <b4taylor> Oh no I totally am...
19:32:28 <dolio> Well, the pure mersenne one is relatively haskelly, as I recall.
19:32:32 <b4taylor> monochrom: I've tried that too.
19:32:36 <dolio> But it's slower.
19:33:24 <ivanm> dolio: still not that great
19:33:27 <ivanm> it does some hacks
19:33:29 <c_wraith> one of these days, I'm going to get around to writing some really slow PRNGs...  That implement the FIPS 800-90 standard for cryptographically secure PRNGs
19:33:31 <Kruppe> ivanm: mwc-random is the package it looks like
19:33:40 <ivanm> the algorithm doesn't lend itself that well to pure code
19:33:44 <b4taylor> Oh I added another hflush and my server doesn't catch a sigpipe now when I kill the other.
19:34:00 <dolio> Oh, it does? I thought it was similar to System.Random. Does it do black magic behind the scenes?
19:35:24 <ivanm> dolio: I forget; ask dons about it
19:35:48 <dolio> Well, I could just look myself. I don't really care that much, though. :)
19:36:23 <dolio> bos' is reportedly faster than even the impure mersenne one.
19:36:58 <b4taylor> monochrom: Oh man, it's all my fault.
19:37:12 <ivanm> dolio: in some cases
19:37:21 <ivanm> in others it's faster
19:37:24 <b4taylor> monochrom: Completely glazed over the fact that I was calling hGetContents instead of hGetLine. I'm a total failure :p
19:38:37 * ivanm is tempted to @remember the second half of b4taylor's comment...
19:39:21 <dolio> Well, as soon as the anti-lazy-IO zealots @remember the first half, we'll have the whole thing.
19:39:29 <b4taylor> ivanm: Pfff what I do remember is that lambdabot forgets eventually!
19:39:46 <ivanm> b4taylor: not as much nowadays...
19:39:57 <ivanm> and jfreddet just greps logs for the HWN anyway :p
19:40:07 <tensorpudding> @vixen do you ever forget?
19:40:07 <lambdabot> i never forget ;)
19:40:13 <ivanm> heh
19:40:18 <tensorpudding> hmm
19:40:24 * ivanm wants a partially strict hGetContents
19:40:28 <tensorpudding> @vixen do you ever dance with the devil in the pale moonlight?
19:40:29 <lambdabot> maybe. do you?
19:40:34 <monochrom> says the computer who can't even decide its own termination.
19:40:35 <ivanm> grab as much as you can that there is, but don't close the Handle!
19:40:55 <tensorpudding> oh, that's good
19:42:00 <ezyang> Lack of profiling libraries for Criterion is making me /very/ sad
19:42:08 <ezyang> maybe I'll build cairo from scratch...
19:44:20 <ezyang> or am I asking for a world of pain?
19:44:58 <Saizan> if you built it once
19:44:59 <tensorpudding> i just built cairo from source yesterday, actually, it's not too bad
19:45:07 <tensorpudding> you need to install pixman first
19:45:44 <ezyang> Saizan: ?
19:46:01 <ezyang> tensorpudding: Cool! Did building profiling libraries work too?
19:46:07 <tensorpudding> i didn't bother
19:46:14 <ezyang> hmmm
19:46:31 <ezyang> so, here's what I'm really trying to do
19:46:37 <tensorpudding> you'll probably need some dev libraries
19:46:42 <ezyang> I just changed a bunch of ad hoc timing code to use criterion
19:46:55 <ezyang> but criterion requires chart which requires cairo, so I can't compile it with profiling
19:47:01 <tensorpudding> ah
19:47:10 <ezyang> like, I'm not even using chart...
19:47:16 <ezyang> maybe I should just make another script for profiling
19:47:19 <tensorpudding> you can't compile Chart with profiling?
19:47:28 <ezyang> nope
19:47:33 <tensorpudding> hmm
19:47:43 <tensorpudding> that's kinda lame
19:47:45 <Hunner> Does a return in main always evaluate it's arguments?
19:47:51 <ezyang> Hunner: no
19:48:04 <Hunner> How can I tell it to evaluate?
19:48:22 <mauke> :t evaluate
19:48:22 <ezyang> Hunner: WAYRTTD?
19:48:23 <lambdabot> Not in scope: `evaluate'
19:48:39 <ezyang> if it's benchmarking, criterion may be of interest
19:49:02 <ivanm> ezyang: ummm..... compile gtk2hs with profiling enabled?
19:49:08 <ezyang> >.>
19:49:14 <ezyang> actually, wtf
19:49:15 <ivanm> then re-compile chart with profiling enabled...
19:49:25 <ezyang> I definitely want to make a separate binary for profiling
19:49:28 <ezyang> w/o criterion
19:49:40 <Saizan> that's what i thought.
19:49:44 <Hunner> ezyang: sql call and show the result. afaik it's doing nothing
19:49:54 <Saizan> anyway you can also cabal install criterion -p -f-chart
19:50:05 <ivanm> what's the -p for? profiling?
19:50:08 <enthymene> holy shit.  Google patented MapReduce?
19:50:13 <Saizan> yes
19:50:22 <ivanm> IIRC, to make sure no one that is evil does so
19:50:22 <enthymene> Fuck them
19:50:29 <enthymene> yeah fuck them
19:50:43 <ivanm> they're apparently not going to stop anyone from using MapReduce however
19:50:49 <Saizan> Hunner: use print on the results?
19:50:55 <enthymene> until they trade places with MS
19:51:24 <enthymene> at which point I'm not willing to trust them not to pull an SCO and try to extort from everyone.
19:51:37 <ezyang> yeah, just print 'em
19:51:41 <ezyang> that'll force it
19:51:55 <Saizan> Hunner: the sql call should get performed regardless of what is evaluated anyway, if it's part of the main action
19:52:56 <ezyang> CHEATERS! The clojure people are CHEATERS!
19:53:06 <ezyang> They're using mutation to initialize their functional data structure! AH!
19:53:22 <Hunner> Saizan: thanks. I think mixing print up with show was my brain problem
19:53:51 <SamB_XP_> ezyang: next, you'll say runSTArray is cheating!
19:53:55 <b4taylor> ezyang: Agreed. But consider the language...
19:54:00 <ezyang> SamB_XP_: It totally is! :-P
19:54:09 <ezyang> So, now I have to make IntMap cheat too :-D
19:54:17 <dolio> So, does anyone here compile GHC HEAD?
19:54:28 <copumpkin> I haven't done it in a while
19:54:29 <copumpkin> in 6.11
19:54:38 <dolio> Not 6.13, though?
19:54:43 <copumpkin> nope, why?
19:54:53 <tensorpudding> the LLVM is in the head isn't it?
19:55:07 <dolio> I've been trying to get a darcs checkout, but part of it sends my computer into swap death every time.
19:55:11 <pikhq> Don't think it's been merged yet.
19:55:14 <dolio> Some ghc-tarballs repository.
19:55:22 <copumpkin> dolio: oh, I thought they'd decided to kill that
19:55:29 <copumpkin> and not store tarballs in the head
19:55:38 <tensorpudding> dons posted about it earlier this week, don't remember
19:55:39 <dolio> It only gets 1/5 patches before it takes up over a gig of memory.
19:55:43 <copumpkin> dolio: oh, you're doing a darcs checkout? that's bad
19:56:07 <copumpkin> dolio: they have a tarball of a recent snapshot that you're supposed to unpack, then pull more recent changes on that
19:56:18 <dolio> Oh. Okay.
19:56:18 <copumpkin> the number of patches is too large for a checkout
19:56:34 <dolio> I have the ghc repository checked out.
19:56:36 <tensorpudding> hmm, it's available as a patch
19:56:47 <dolio> It's just when you're supposed to do "./darcs-all get".
19:56:47 <copumpkin> darcs really needs a good answer to having O(n) time checkouts where n is the number of patches
19:56:51 <copumpkin> oh
19:56:53 <copumpkin> hmm
19:56:55 <copumpkin> not sure then
19:57:03 <dolio> It's the patches in ghc-tarball that are giant, apparently.
19:57:20 <copumpkin> I can try doing a checkout in a bit
19:57:25 * ezyang is a blasphemer and uses git, not darcs 
19:57:28 <copumpkin> have a deadline in an hour but after that I'll try
19:57:33 <copumpkin> ezyang: same here, but I don't mind using darcs either
19:57:41 <sjanssen> there's such a thing as 'darcs checkout'?
19:57:41 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
19:57:46 <ivanm> darcs get == darcs checkout?
19:58:01 <ivanm> sjanssen: yeah, I'm trying to work out what they mean as well :s
19:58:02 <tensorpudding> i used darcs before i used git
19:58:07 <b4taylor> darcs failed:  No such command 'checkout'
19:58:14 <ivanm> heh
19:58:27 <tensorpudding> darcs get is what you want
19:58:35 <b4taylor> I haven't used darcs in forever. I was semi watching the google SOC project though.
19:58:50 <dolio> The llvm stuff is intriguing, but mostly I want to work on vector-algorithms without having to guess whether my code is slow due to the compiler getting confused.
19:59:17 <copumpkin> does DPH have a mutable branch by the way?
19:59:23 <tensorpudding> i switched to git because of github and because it seemed faster and nicer at the time
19:59:31 <b4taylor> dolio: Algorithms that use vectors, or are you doing your own vector thing? Because there was a fast vector library released recently I believe.
19:59:51 <dolio> b4taylor: It's algorithms for those vectors.
20:00:01 <b4taylor> dolio: Most excellent
20:00:04 <dolio> Ported from an older package for a different vector library.
20:00:45 <ivanm> from uvector to vector?
20:01:03 <dolio> Yes.
20:01:24 <ivanm> oh, you're the maintainer of uvector-algorithms?
20:01:33 <dolio> I am.
20:02:14 <ddarius> copumpkin: Probably not as that would significantly complicated a problem that is already research.
20:02:55 <copumpkin> ddarius: I mostly mean as a stream source and something that can be frozen into regular parallel arrays, rather than something which would benefit from the implicit parallelization
20:03:01 <dolio> As a bonus, with vector, there's actual incentive to implement timsort.
20:03:09 <copumpkin> dolio: what's that?
20:03:35 <dolio> Since one of its selling points is that it does fancy stuff that causes overhead in an effort to not do as many comparisons in a lot of cases.
20:03:45 * ddarius proposes dansort.
20:04:06 <dolio> Which is more compelling when you're not just comparing Ints and stuff.
20:04:17 <ivanm> dolio: as in it caches some results?
20:04:17 <SamB_XP_> timbotsort?
20:06:43 <Saizan> dolio: it took a while but my darcs-all completed darcs get --partial http://darcs.haskell.org/ghc-tarballs , using less than 300mb of ram
20:07:04 <dolio> ivanm: No, more like it chunks the array according to non-increasing/decreasing segments, and when merging, it tries to identify whether entire blocks of elements can be transferred at once (using something more like binary search).
20:07:21 <copumpkin> I don't even see why you should have to fetch mingw
20:07:22 <ivanm> hmmm...
20:07:27 <copumpkin> which is the largest thing in ghc-tarballs
20:07:33 <b4taylor> http://en.wikipedia.org/wiki/Timsort
20:07:40 <b4taylor> It explaims timsort quite well.
20:07:55 * twink cowers in fear.
20:08:25 <ivanm> b4taylor: not really
20:08:33 <ivanm> I already read through that and still have no idea how it actually works
20:08:34 <dolio> ivanm: Of course, that takes care of a lot of special cases automatically, as well.
20:08:40 <ivanm> as in, what's the actual algorithm?
20:08:45 <ivanm> dolio: *nod*
20:08:47 <dolio> Sorting an already sorted or reverse-sorted array is O(n).
20:08:48 <b4taylor> ivanm: Oh well read his paper then :p
20:08:49 <copumpkin> I wonder if we'll ever be able to shut jdh up about haskell performance
20:09:08 <roconnor> Do flat CPOs form a ccc?
20:09:26 <copumpkin> ask djinn to prove it
20:09:26 <b4taylor> ivanm: And by paper I mean ... txt file :(
20:09:28 <copumpkin> if it fails, it's not true
20:09:37 <mauke> <insert C3PO joke here>
20:09:40 <roconnor> copumpkin: who is jdh?
20:09:46 <copumpkin> roconnor: harrop
20:09:59 <roconnor> as in harrop formulae?
20:10:02 <copumpkin> lol
20:10:03 <ivanm> copumpkin: you can, but the police for soem reason don't like the various approaches available...
20:10:08 <ivanm> mauke: heh
20:10:10 <tensorpudding> @quote harrop
20:10:10 <lambdabot> Heffalump says: he's [Jon Harrop] not exactly a Haskell beginner, more like a Haskell fuckwit
20:10:11 <copumpkin> roconnor: the ocaml/f# tropp
20:10:17 <roconnor> oh
20:10:19 <copumpkin> @quote harrop
20:10:19 <tensorpudding> @quote jdh
20:10:19 <lambdabot> dolio says: [regarding a paypal spam message on #haskell] Take that, Harrop! Does OCaml have illegal cracking utilities?
20:10:19 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
20:10:20 <roconnor> the flying frog
20:10:25 <copumpkin> and by tropp I mean troll
20:10:34 <tensorpudding> a trollop?
20:10:35 <ivanm> @quote jdh30
20:10:35 <lambdabot> jdh30 says: parallel Haskell would seem to have immediate practical applications
20:10:43 <tensorpudding> @quote jdh30
20:10:43 <lambdabot> jdh30 says: parallel Haskell would seem to have immediate practical applications
20:10:46 <ivanm> wow, something intelligent...
20:10:48 <tensorpudding> @quote jdh30
20:10:48 <lambdabot> jdh30 says: parallel Haskell would seem to have immediate practical applications
20:10:50 <tensorpudding> oh
20:10:50 <roconnor> so not Ronald HArrop
20:10:56 <dolio> @quote most.profitable
20:10:56 <lambdabot> JonHarrop says: I am the author of the world's most profitable book on functional programming.
20:10:59 <roconnor> http://en.wikipedia.org/wiki/Harrop_formula
20:11:01 <ivanm> copumpkin: anyway, why bring himi up again?
20:11:06 <roconnor> :D
20:11:11 <roconnor> most profitable
20:11:15 <roconnor> is that true?
20:11:17 <ivanm> roconnor: wrong harrop
20:11:20 <copumpkin> ivanm: cause we're talking about fast algorithms in haskell
20:11:29 <ivanm> roconnor: well, who else writes FP books to actually make money?
20:11:40 <tensorpudding> the "most profitable" book on functional programming isn't in the best-selling list of functional programming books on amazon
20:11:41 <twink> How did the claim that theoreticians are unconcerned about constant factors acquire any credence?
20:11:41 <ivanm> IIRC, dons, bos and CosmicRay don't make much off RWH
20:11:55 <copumpkin> being self-published helps a lot
20:12:03 <SamB_XP_> ivanm: they forgot to include the counterfeighting example ?
20:12:06 <ivanm> twink: context?
20:12:07 * copumpkin is playing with http://alchemy.cs.washington.edu/
20:12:15 <ivanm> SamB_XP_: hmmm?
20:13:09 <monochrom> All attacks on theorists and theories gain automatic credence because people hate theories because theories are taught poorly at school.
20:13:14 <ddarius> roconnor: Function domains aren't flat, so no.
20:13:19 <ivanm> what I've found annoying recently is all the libraries/applications posted onto the haskell reddit recently.... which only exist on github
20:13:29 <ivanm> really, if it's not on hackage then what's the point?
20:13:55 <ivanm> monochrom: like how there's arguments that all science is now perceived as being less than credible because of the attacks on climate science?
20:13:56 <b4taylor> ivanm: Agreed. And even the ones that are on hackage are poorly maintained anyways.
20:14:03 <ivanm> b4taylor: a lot of them, yes
20:14:11 <ivanm> damn fly-by-nighter software writers...
20:15:34 <roconnor> ddarius: they can't be made flat somehow?
20:15:59 <b4taylor> I kind of wish Hackage would get a little cleanup. I don't like seeing User-interface, and User Interfaces as two categories.
20:16:00 <roconnor> by making A_ -> B_ := (A -> B)_ somehow
20:16:21 <monochrom> ivanm: Oh it goes much older than that. Ever heard of "in theory, theory is the same as practice; in practice blah blah"? People accept it automatically; they don't even stop to think: why is "theory" in singular?
20:16:36 <roconnor> let' see, it has to be adjoin to pairing
20:16:49 <ivanm> monochrom: nope, don't think I've heard that phrase before
20:17:06 <ivanm> b4taylor: blame the people that upload those packages
20:17:07 <SamB_XP_> monochrom: well, haven't you ever heard of newtonian physics ?
20:17:20 <ivanm> since you specify which categories you want your package to be in in the .cabal file
20:17:25 <b4taylor> Oh snap VTY has a widget library now.
20:18:16 <ddarius> ivanm: There's no way to expect such global coordination especially as there is no direction at this point.
20:18:29 <ivanm> true
20:18:58 <ddarius> ivanm: However, it wouldn't be hard for a list to be made that will collapse multiple categories to make the Hackage display list cleaner.
20:19:12 <ddarius> ivanm: I.e. do it transparently at the server-side.
20:19:37 <SamB_XP_> could we not have cabal tell you when that happens, too?
20:19:51 <ddarius> SamB_XP_: Why would Cabal be involved?
20:19:54 <ivanm> Cabal is just a library...
20:20:08 <SamB_XP_> er, when you do the "cabal put" or whatever ?
20:20:10 <ivanm> as it stands, cabal-install upload ends up with 500 errors anyway
20:20:18 <SamB_XP_> oh
20:20:19 <ivanm> (even though the package does indeed upload)
20:20:27 <ivanm> SamB_XP_: it's too late then though...
20:20:29 <ezyang> Man, all of the job postings on haskell.org are so old!
20:20:32 <ivanm> maybe as part of "cabal check" ?
20:20:36 <SamB_XP_> or that
20:20:46 <ddarius> ezyang: The wiki is not the best place to look.
20:20:50 <dolio> Which people should it yell at? "User Interface" or "User-Interface"?
20:20:51 <ivanm> ezyang: and they _still_ haven't hired anyone yet! :p
20:21:02 <ivanm> dolio: the one with the least number of (reputable) packages?
20:21:08 <ivanm> or the newer category
20:21:16 <SamB_XP_> the one that's less cosmetically pleasing ?
20:21:19 <SamB_XP_> all of them ?
20:21:26 <ivanm> thing is, hackage also serves as an archive... so both will stay :(
20:21:29 <ezyang> ddarius: Heh, ok.
20:21:34 <monochrom> If you want a noun phrase, it's "user interface".
20:21:44 <ezyang> ddarius: Better suggestions?
20:21:47 * ddarius is suggesting a manually made list '["User Interface", "User-Interface"] -> "User Interface"' and for that to be used to group packages for display on Hackage.
20:22:01 <ddarius> ezyang: The mailing list is where job announcements are made.
20:22:22 <ezyang> Yeah, the problem is that I'm looking for an internship, not a job ^^
20:22:43 <dolio> Well, whatever your solution is, you have to be able to programatically decide it for arbitrary cases, not just "User-Interface".
20:23:15 <dolio> Unless you just want a big black list someone stores on hackage.
20:23:18 <ezyang> "review all incoming packages!"
20:23:55 <ddarius> dolio: I'm not suggesting a black list because that wouldn't allow for new categories at all.
20:24:12 <ddarius> Er, I guess a white list wouldn't.
20:24:24 <ddarius> A black list would be difficult as it wouldn't handle typos and such.
20:24:25 <dolio> ddarius: I'm not talking about your solution. I'm talking about the solution where we have cabal/hackage automatically complain at people.
20:24:43 <ddarius> dolio: My solution could be made into that via a white list type mechanism.
20:25:37 <ivanm> dolio: I would say that "cabal check" should complain "You've specified Category Foo which doesn't exist yet; are you sure you want to use it?"
20:26:04 <dolio> Well, all it takes is one person saying "yes" and the floodgates are open. :)
20:26:17 <ivanm> possibly use some edit distance thingy to recommend other categories...
20:26:25 <ivanm> dolio: well, we do want to allow new categories...
20:26:38 <ddarius> ivanm: My solution would allow migration to a more standard set and it would be no problem to have Hackage rewrite the category section of old .cabal files.
20:26:55 <ddarius> (Once more solid categories were decided upon.)
20:27:29 <ivanm> ddarius: and if a new category is thought of down the track?
20:28:06 <ddarius> ivanm: At that point, your idea can be used to avoid future divergences of the kind that currently exist, but in general the list would need to be maintained.
20:28:30 <ddarius> Categories don't proliferate -that- much as to be that big of a problem to maintain.
20:33:38 <ddarius> My idea is more of a stop-gap measure to fix the current issues and allow incremental solidification, after which some other mechanism would be used to maintain cleanliness.
20:36:52 * twink is still going over timsort.
20:37:28 <enferex> I have a if/else statement and a recursion afterwards.  I want the if/else to be evaluated and then the recursion to be called after that conditional
20:37:30 <ddarius> The basic idea seems pretty straightforward and sounds like an untuned implementation could be made from it.
20:38:00 <ddarius> enferex: Is this in a do-block?
20:38:01 <ezyang> enferex: What is the if/else statement doing?
20:38:08 <ezyang> is it side-effectful?
20:38:09 <enferex> foo x = if x==1 then x + 1 else x + 2
20:38:40 <enferex> I want foo to re-evaluate x after that condition
20:38:42 <ivanm> recursion_bit . if_then_else_bit
20:38:50 <mauke> enferex: huh?
20:40:42 <tensorpudding> foo x = if x == 1 then foo (x+1) else foo (x+2)
20:40:43 <tensorpudding> ?
20:41:22 <ddarius> tensorpudding: In that case you can do as ivanm suggested and just write: foo x = foo (if x == 1 then x + 1 else x + 2) which more clearly illustrates the infinite loopishness of it.
20:41:24 <tensorpudding> that function is obviously not going to return anything but bottom, no matter what its called on
20:41:38 <ivanm> ddarius: and which never ends!
20:41:51 <ivanm> foo 0 = 0; foo x = foo ( ... )
20:42:12 <ivanm> that at least will end if you start with a negative even number ...
20:42:44 <ivanm> better way:
20:43:05 <ivanm> foo 1 = 2; foo x = foo $ x + 2
20:43:06 <ddarius> enferex: An if expression is an expression with a value.  If you don't directly use that value, then there is no point in having the expression.  Furthermore, no variables are changed so "re-evaluating" doesn't make any sense.
20:43:11 <tensorpudding> i don't think this function is what enferex wanted
20:44:01 <enferex> Ok
20:44:32 <enferex> I was trying to count the occurances of each item in a list, and return an array of counts
20:44:47 <enferex> all Int
20:45:27 <enferex> occurances :: (Int, [Int]) -> [Int]
20:45:42 <ivanm> huh? that type sig doesn't match what you said
20:45:50 <ivanm> what's the first Int for?
20:45:58 <enferex> ivanm: The number to count
20:46:00 <tensorpudding> enferex: an array isn't a list, by the way
20:46:00 <mauke> what's the list of counts for?
20:46:18 <ivanm> enferex: then you only need a number of counts...
20:46:29 <enferex> Ok so let me restate,
20:46:31 <enferex> im learning
20:46:35 <ivanm> occurances x ys = filter ((==) x)
20:46:38 <ivanm> occurances x ys = filter ((==) x) xs
20:46:47 <ivanm> ^^ is that what you want?
20:47:03 <mauke> needs more length
20:47:11 <ivanm> > let occurances x ys = filter ((==) x) ys in occurances 3 [1,5,3,3,6,3,7,8,3,3]
20:47:12 <lambdabot>   [3,3,3,3,3]
20:47:16 <ivanm> enferex: ^^
20:47:17 <tensorpudding> i was thinking you had a list of [Int], and you want to return a list of [(Int,Int)] where (a,b) in the result says that the number a appeared b times in the list
20:47:20 <mauke> also more 'e'
20:47:24 <enferex> I want to take a list of Ints, and then return a list of occurances that each element has
20:47:33 <enferex> Really trivial
20:47:36 <ivanm> then you want:
20:47:42 <tensorpudding> maybe a Map
20:47:56 <ivanm> map (\xs -> (head xs, length xs)) . group . sort
20:48:00 <ivanm> @type map (\xs -> (head xs, length xs)) . group . sort
20:48:01 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
20:48:10 <ivanm> enferex: ^^
20:48:14 <tensorpudding> you can consume the list, and if the number appears in the Map, you increment the value it references, and otherwise you add it to the map with value 1
20:48:19 <mauke> occurrence occurrence occurrence
20:48:31 <ivanm> tensorpudding: nah, group . sort is easier ;)
20:48:36 <Saizan> > M.toList . M.fromListWith (+) . flip zip [1,1..] $ [1,5,3,3,6,3,7,8,3,3]
20:48:38 <lambdabot>   [(1,1),(3,5),(5,1),(6,1),(7,1),(8,1)]
20:48:47 <tensorpudding> ivanm: is it faster?
20:49:00 <ddarius> Also occurrence isn't usually a concrete thing, so having a list of them doesn't make a whole lot of sense.
20:49:00 <ivanm> tensorpudding: he's new; we want something easier to understand!
20:49:12 <ivanm> @pl \ xs -> (head xs, length xs)
20:49:13 <tensorpudding> ivanm: programmers don't understand hashtables?
20:49:13 <lambdabot> liftM2 (,) head length
20:49:19 <ivanm> tensorpudding: it's not a hashtable...
20:49:23 <ivanm> and who says he's a programmer?
20:49:32 <ddarius> ivanm: I do.
20:49:34 <tensorpudding> Map isn't a hashtable?
20:49:36 <copumpkin> nope
20:49:42 <ivanm> > map (liftM2 (,) head length) . group . sort $ [1,5,3,3,6,3,7,8,3,3]
20:49:43 <lambdabot>   [(1,1),(3,5),(5,1),(6,1),(7,1),(8,1)]
20:49:44 <Saizan> it's a binary search tree
20:49:50 <tensorpudding> maybe i have a screwed definition of a hashtable
20:50:03 <copumpkin> a hashtable tends to be based on an array and a hash function
20:50:07 <enferex> Would you all recommend the Real World Haskell by O'Reilley
20:50:10 <copumpkin> Ord would serve it no good
20:50:15 <enferex> I wanted to do this on my own so I could learn
20:50:16 <Saizan> maybe you're using it as synonym of dictionary
20:50:18 <ddarius> tensorpudding: Uh, I'd have to say you do if you are uncertain about this at all in this context.
20:50:19 <tensorpudding> Map is a dictionary
20:50:19 <ivanm> enferex: if you've programmed before, then yes
20:50:26 <tensorpudding> i was thinking dictionary, not hashtable
20:50:28 <enferex> ivanm: Im an imperative guy :-)
20:50:28 <Axman6> enferex: i'd recommend LYAH first
20:50:28 <lambdabot> Axman6: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:50:31 <Axman6> @where lyah
20:50:32 <lambdabot> http://www.learnyouahaskell.com/
20:50:42 <ivanm> enferex: then yes, RWH would suit you
20:50:46 <copumpkin> yeah, other languages get quite lax about calling any dictionary a hashtable
20:50:48 <ivanm> greetings Axman6
20:50:50 <enferex> Axman6: Yea, Ive browsed LYAH
20:50:57 <enferex> so im loosly familiar with the language
20:51:02 <Axman6> well, time to get RWH then :)
20:51:02 * ivanm notices that Axman6 still hasn't come around N329...
20:51:18 <Axman6> ivanm: didn't know which room it was until you told me :P
20:51:22 <enferex> Axman6: Okie!  I browsed RWH when I was at B&N.  It made sense
20:51:24 <ivanm> heh, fair enough
20:51:43 <Axman6> will you be in tomorrow?
20:51:45 <ddarius> ivanm: You can tell from what enferex originally asked that he had some programming experience in an impure, a likely imperative language.
20:51:50 <enferex> thanks again all
20:52:01 <ivanm> enferex: RWH is a decent Haskell tutorial if you know how to program (in any decent language)
20:52:18 <ddarius> ivanm: What if you only know indecent languages?
20:52:21 <tensorpudding> is the term association list common in haskell?
20:52:26 <ddarius> Is there an indecent tutorial?
20:52:26 <enferex> ivanm: Im new to functional, but have done years of other
20:52:35 <ivanm> ddarius: knowing LOGO might not be sufficient ;)
20:52:36 <enferex> Im a procedural guy
20:52:40 <ddarius> tensorpudding: It would be understood, but they don't come up that much.
20:52:41 <Axman6> tensorpudding: i've seen it used, but not that common
20:52:45 <ivanm> tensorpudding: yes; [(a,b)]
20:52:46 <ddarius> :t lookup
20:52:46 <tensorpudding> in the sense that it is used in lisp
20:52:47 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
20:52:48 <Axman6> enferex: not for long!
20:52:53 <tensorpudding> for [(a,b)]
20:52:54 <enferex> Axman6: heheh
20:52:54 <tensorpudding> yeah
20:53:03 <enferex> Thanks for not flaming me
20:53:08 <tensorpudding> i'm just wondering if haskell users call [(a,b)] an association list
20:53:12 <enferex> I might actually come back with a more reputable question!
20:53:14 <ivanm> Axman6: I'll be in from around 10 tomorrow (have to take the car up to belconnen to get a service first)
20:53:21 <ivanm> tensorpudding: RWH does...
20:53:22 <ivanm> so yes!
20:53:24 <ddarius> tensorpudding: They do if it is intended to be used that way.
20:53:36 <ddarius> tensorpudding: But Haskellers don't usually use association lists.
20:53:43 <ivanm> that's what Maps are for
20:53:45 <enferex> anyone happen to be from Melbourne?
20:53:46 <tensorpudding> yes
20:53:50 <copumpkin> I'm not even sure why we have a function encouraging its use in the prelude
20:53:52 <tensorpudding> going back to the subject of Map
20:54:05 <ivanm> I've only ever used an association list when I only have up to say 5 elements of the list
20:54:16 <tensorpudding> i would use a Map there instead of an alist, if it were a big list
20:54:16 <ivanm> enferex: there are some people IIRC, but no-one online atm that I know of
20:54:21 <Axman6> ivanm: well i finish at 11 tomorrow, so i could drop in before going with my girlfriend as she gets her wisdom teeth out
20:54:23 <enferex> gotcha
20:54:29 <ivanm> Axman6: fair enough
20:54:34 <enferex> thanks again
20:55:05 <tensorpudding> hmm
20:55:12 <tensorpudding> so dictionaries are not hashtables
20:55:22 <Axman6> no
20:55:24 <ddarius> tensorpudding: They can be.
20:55:37 <Axman6> hashtables are dictionaries
20:55:39 <ddarius> tensorpudding: But a hash table is a particular, concrete data structure.  A dictionary is just an interface.
20:56:02 <ezyang> Dictionaries are kind of magical, in many implementations
20:56:10 * ezyang looks at Python 
20:56:15 <copumpkin> is there any meaningful distinction between a map and a dictionary?
20:56:17 <Axman6> heh
20:56:18 <ivanm> Axman6: well, hashtables can be implemented as dictionaries...
20:56:21 <ddarius> copumpkin: No.
20:56:22 <copumpkin> I use them interchangeably
20:56:24 <copumpkin> ok
20:56:32 <tensorpudding> i used to think the terms were interchangeable because some languages used dictionaries, like python, and others used hashtables
20:56:42 <ivanm> copumpkin: well, a map helps you find where you want to go, whereas a dictionary is used to look up the meaning of words...
20:56:43 <ivanm> ;-)
20:56:46 <tensorpudding> like some language that i now forget
20:56:48 <copumpkin> :P
20:56:54 <copumpkin> ruby calls them Hash
20:56:56 <copumpkin> sadly
20:57:06 <tensorpudding> hmm, that is right
20:57:08 <ddarius> tensorpudding: Did you mean "use the terms" ?
20:57:10 <ezyang> I mean, in some ways, it's good to know what the underlying implementation is
20:57:17 <ezyang> so you can plan the performance characteristics again
20:57:23 <ddarius> tensorpudding: Otherwise your statement is like saying that some languages use numbers and others use integers.
20:57:57 <ivanm> ddarius: some languages only have one numeric data type? :o
20:57:57 <tensorpudding> if python calls its structure a dictionary, but is a hashtable, does that mean that it is a dictionary or a hashtable?
20:57:58 <ivanm> :p
20:58:15 <copumpkin> a dictionary isn't a concrete structure
20:58:15 <tensorpudding> if you say hashtable, it's not proper python because it isn't called that
20:58:17 <ddarius> ezyang: The asymptotic performance characteristics should be part of the interface in my opinion, so you should not need to know the underlying implementation (to a first order)
20:59:10 <ddarius> tensorpudding: Again your question is like saying, "if python calls its numbers numbers but they are integers does that mean it is a number or an integer?"
20:59:27 <ezyang> ddarius: Maybe.
20:59:35 <copumpkin> Either
20:59:41 <ezyang> But I think lots of data-structures look the same.
20:59:45 <tensorpudding> ddarius: you're saying that it is wrong to call something by the name the language gives it, if it is not actually how it works
20:59:48 <Axman6> IO
20:59:58 <ezyang> It was mentioned on this chan a while back, but I'd love to see a datastructure/algorithm encyclopedia
21:00:05 <copumpkin> damn, my kind is the odd one out
21:00:19 <Axman6> disgraceful
21:00:26 <ddarius> ezyang: The documentation for Data.Map has the asymptotic complexities of each operation.
21:00:38 <copumpkin> ezyang: I started constructing one on the computer science freebase base, with strcture
21:00:42 <tensorpudding> in any case, i'm confused now what we're even arguing about
21:00:51 <ezyang> ddarius: That's great :-)
21:00:51 <copumpkin> ezyang: a while back, not sure if anyone continued it
21:01:05 <ezyang> copumpkin: I sort of want something... more indexable, perhaps?
21:01:21 <scutigera> tensorpudding: can you look up the meaning of map in a dictionary or can you find a dictionary by using a map.
21:01:26 <copumpkin> ezyang: well the point of freebase is that it's structural, you represent relations
21:01:31 <ezyang> ohh!
21:01:32 <ddarius> @google Dictionary of Algorithms and Data Structures
21:01:33 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:01:37 <ddarius> @google Dictionary of Algorithms and Data Structures
21:01:38 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
21:01:40 <ezyang> fail!
21:01:52 <ddarius> http://www.itl.nist.gov/div897/sqg/dads/
21:02:03 <tensorpudding> scutigera: by my fay, i cannot reason
21:02:14 <copumpkin> ezyang: unfortunately their system isn't quite flexible enough to express the kind of knowledge I want to put into it
21:02:29 <copumpkin> ezyang: http://www.freebase.com/view/en/red-black_tree/-/base/computerscience
21:02:59 <copumpkin> it's mostly empty still :(
21:03:01 <ezyang> mmm, pretty
21:03:17 <copumpkin> http://www.freebase.com/view/base/computerscience/views/data_structure
21:03:23 <copumpkin> ah well
21:03:49 <scutigera> tensorpudding: ?
21:04:05 <tensorpudding> quote from hamlet, sorry
21:04:26 <scutigera> tensorpudding: don't apologize for quoting the bard ! :-)
21:04:39 <tensorpudding> rosencrantz and guildenstern were arguing about shadows shadows and beggars, and hamlet was getting lost
21:04:58 <tensorpudding> it seemed appropriate
21:05:13 <scutigera> tensorpudding: well maybe I'll take a break from Topoi and take in an act.
21:06:09 <ddarius> scutigera: If you cannot reason, perhaps you need more toposes.
21:06:15 <tensorpudding> a hashtable by any other name would have the same algorithmic complexity
21:06:45 <tensorpudding> hooray algorithmic shakespeare snowclone
21:06:46 <ddarius> "Optimizing hash array mapped tries" ...
21:06:53 <ezyang> ddarius: Hee
21:07:10 <ezyang> My current theory is that Clojure is mutating their trie under the hood, which is why it seems so much faster
21:08:08 <Saizan> ezyang: can you use it in a persistent way?
21:08:08 <copumpkin> @let s p=r[](fix(0:))0[]where r c m i o=let a(&)=g$w&z:e;j=1+i;h=r c m;g=h j;z:x=o;w:e=x;k:l=c;d=drop(1+z);t=take z;in case(p++"!")!!i of;'p'->show z++g x;'P'->chr(mod z 128):g x;d|isDigit d->g$ord d-48:o;'+'->a(+);'-'->a(-);'*'->a(*);'/'->a div;':'->g$signum(w-z):e;'g'->h(z+j)x;'?'->h(i+case w of 0->z;_->1)e;'c'->r(j:c)m z x;'$'->r l m k o;'<'->g$m!!z:x;'>'->r c(t m++w:d m)j e;'^'->g$x!!z:x;'v'->g$x!!z:t x++d x;'d'->g x;'!'->"";' '
21:08:08 <lambdabot>   Parse error: VRightCurly
21:08:08 <copumpkin> o;_->error$show(p!!i)
21:08:12 <ezyang> Yup
21:08:15 * ivanm decides to call it a day and head off home, despite having no internet there...
21:08:17 <copumpkin> hm
21:08:21 <ddarius> IntMap is pretty fast.
21:08:24 <ezyang> So when I force it to update using the pure interface, it's on par with Haskell
21:08:25 <FauxFaux> IceDane: Nooooooooooo!
21:08:26 <twink> Multidimensional indexing? R trees?
21:08:29 <ivanm> copumpkin: do I dare ask wtf that was meant to be?
21:08:31 <ezyang> ddarius: It's true :-)
21:08:44 <copumpkin> ivanm: a virtual machine in haskell, apparently: http://kpreid.livejournal.com/23060.html
21:08:44 <ezyang> I have several experiments I want to conduct
21:08:45 <ddarius> ivanm: Hack VM
21:09:00 <copumpkin> twink: I wrote the beginnings of an r-tree the other day on fingertrees
21:09:03 <ivanm> which lambdabot doesn't want to accept?
21:09:10 <copumpkin> ivanm: sadly
21:09:23 <ivanm> and as obfuscated as kpreid could make it
21:09:24 <ivanm> ?
21:09:33 <ddarius> It looks cut off.
21:09:38 <copumpkin> oh
21:09:41 <ddarius> It ends with ;' '
21:09:52 <copumpkin> it was supposedly designed to fit into an IRC line
21:10:20 <scutigera> yep , it got cut-off at the o;_ etc...
21:10:39 <copumpkin> boo
21:11:14 <ivanm> so it's still not short enough...
21:11:26 <Saizan> the most obfuscated part is the perl to obsfuscate it
21:11:35 <ivanm> Saizan: heh
21:12:22 <ivanm> anyway, bye all
21:12:27 <ezyang> bye!
21:12:38 <ivanm> you don't have to sound so happy about it ezyang...
21:12:41 <ivanm> ;)
21:12:41 * twink checks it out
21:13:50 <scutigera> let a(&) ? what's '&' do.
21:14:00 <ddarius> scutigera: It's a binding like any other.
21:14:44 <Saizan> > let a(&) = 1 & 2 in a (+)
21:14:45 <lambdabot>   3
21:14:57 <Saizan> > let a (&) = 1 & 2 in a (+)
21:14:58 <lambdabot>   3
21:15:15 <tensorpudding> wow
21:15:26 <copumpkin> twink: it's remarkably easy to write a multidimensional "region tree" with finger trees. An r-tree is just a few steps away at that point
21:15:46 <tensorpudding> > let a `fun` = 1 `fun` 2 in a (+)
21:15:47 <ddarius> just five strokes of the backspace button
21:15:47 <lambdabot>   <no location info>: parse error on input `='
21:15:58 <tensorpudding> oh
21:16:00 <tensorpudding> wait
21:16:12 <copumpkin> no `` in the pattern
21:16:13 <tensorpudding> no, it make sense
21:16:31 <scutigera> no it doesn't , is & being bound, & can't be a variable name..
21:16:41 <tensorpudding> (&) is a valid pattern, which is confusing
21:16:49 <ddarius> scutigera: (&) is being bound and it can be a variable name.
21:17:01 <Saizan> a is bound as a function with a formal parameter (&)
21:17:04 <scutigera> I just tried let & = 1 and it don't work
21:17:17 <Saizan> > let (&) = 1 in (&)
21:17:18 <lambdabot>   1
21:17:18 <ddarius> scutigera: It's still an operator.
21:17:24 <copumpkin> @src on
21:17:24 <lambdabot> (*) `on` f = \x y -> f x * f y
21:17:26 <tensorpudding> > let f (>>=) = 5 + 5 >>= 3 in f (*)
21:17:27 <lambdabot>   20
21:17:41 <scutigera> hod ! right, () denotes operator...
21:18:07 <Saizan> > let a (f) = f 1 2 in a (+)
21:18:08 <lambdabot>   3
21:18:24 <tensorpudding> > let a f = f 1 2 in a (+)
21:18:26 <lambdabot>   3
21:19:08 <Saizan> it's more like (..) gives you the function associated with the operator
21:19:12 <hotaru2k3> > let a (*) = 1 * 2 in a (+)
21:19:14 <lambdabot>   3
21:19:24 <tensorpudding> that's pretty sweet though
21:19:34 <scutigera> > Saizan: ok, thanks.
21:19:35 <lambdabot>   <no location info>: parse error on input `,'
21:19:50 <ddarius> > let n + 1 + k + 4 = (n, k) in 10 + 7
21:19:51 <lambdabot>   <no location info>: Parse error in pattern
21:20:21 <copumpkin> need moar mixfix
21:20:34 <tensorpudding> instance Functor f where fmap (*) = (+)
21:21:04 <tensorpudding> err, that won't work, needs more bifunctor
21:33:34 --- mode: Heffalump set -o Heffalump
21:35:13 <kquick2> Question re pattern match for existential GADT.  Given: data Elem where MkElem :: String -> a -> Elem;  I'd like to create a function with pattern match:  isBoolE :: Elem -> Bool; isBoolE (MkElem _ True) = True; isBoolE (MkElem _ _) = False
21:35:51 <Heffalump> you can't do that
21:36:08 <Heffalump> you need to use different constructors on the GADT for the Bool and non Bool cases
21:36:11 <ddarius> Anyway, the second pattern matches (MkElem _ False)
21:36:36 <copumpkin> kquick2: once you throw away the information on a's type, you can't get it back
21:36:37 <Saizan> MkElem :: Typeable a => String -> a -> Elem ?
21:36:47 <copumpkin> ugh :)
21:37:19 <mauke> @let a === b = Just a == cast b
21:37:21 <lambdabot>  Defined.
21:37:37 <Saizan> ?type (===)
21:37:37 <copumpkin> :t (===)
21:37:38 <lambdabot> forall a a1. (Typeable a1, Typeable a, Eq a) => a -> a1 -> Bool
21:37:39 <lambdabot> forall a a1. (Typeable a1, Typeable a, Eq a) => a -> a1 -> Bool
21:37:43 <copumpkin> :P
21:38:01 <Saizan> > "" === False
21:38:02 <lambdabot>   False
21:38:06 <Saizan> weird
21:38:08 <ddarius> ugh
21:38:11 <tensorpudding> > 5 === "5"
21:38:13 <lambdabot>   False
21:38:14 <copumpkin> > "" = []
21:38:15 <lambdabot>   <no location info>: parse error on input `='
21:38:23 <copumpkin> > "" == []
21:38:24 <kquick2> I thought a's type was existentially known to the compiler for pattern matching.
21:38:24 <lambdabot>   True
21:38:38 <copumpkin> kquick2: nope
21:38:41 <tensorpudding> > [] === ""
21:38:42 <lambdabot>   False
21:38:53 <copumpkin> mmm
21:39:07 <tensorpudding> > cast "" :: Maybe [Int]
21:39:09 <lambdabot>   Nothing
21:39:17 <ddarius> kquick2: a's type can be dependent on run-time information.  The compiler has no idea what it is and couldn't use the information even it id.
21:39:20 <tensorpudding> ahmm
21:39:22 <ddarius> s/id/did/
21:39:57 <mauke> > 42 === 42
21:39:58 <lambdabot>   True
21:40:21 <tensorpudding> > 42 === "the answer to life, the universe, and everything"
21:40:23 <lambdabot>   False
21:40:41 <kquick2> Hmm... I should clarify: I thought existentially known based on the context in which isBoolE was called (i.e. where it got it's Elem).  Sounds like that's not extended in that way.
21:41:09 <kquick2> Thanks.  More thinking ahead.
21:41:13 <pikhq> > let 42 == "The answer to Life, the Universe, and Everything" = True in 42 == "The answer to Life, the Universe, and Everything"
21:41:15 <lambdabot>   True
21:41:57 <tensorpudding> @djinn a -> a
21:41:58 <lambdabot> f a = a
21:42:46 <tensorpudding> hmm
21:43:20 <tensorpudding> there is always a unique function from a -> (), is () the terminal object of Hask?
21:43:58 <copumpkin> ignoring the usual baddies
21:44:00 <ddarius> tensorpudding: There is more than one element of a -> () for any particular a.  However, idealizing somewhat, yes, () would be the terminal object.
21:44:01 <tensorpudding> rather, "a"
21:44:46 <tensorpudding> is it because of _|_?
21:44:55 <tensorpudding> that there is more than one element of a -> ()
21:45:12 <ddarius> tensorpudding: Well, without bottom there wouldn't be (under a typical semantics).
21:45:17 <domor``> \query lambdabot
21:45:24 <domor``> @nick domor
21:45:24 <lambdabot> Maybe you meant: dice dict
21:45:34 <bos> preflex: seen dons
21:45:34 <preflex>  dons was last seen on #ghc 3 hours, 7 minutes and 27 seconds ago, saying: jinjing: no way around it -- it requires ghci
21:45:37 <domor``> wow, I haven't slept enough lately.
21:46:30 <tensorpudding> hmm
21:46:32 <tensorpudding> @dice
21:46:32 <lambdabot> unexpected end of input: expecting number
21:46:36 <tensorpudding> @dice 50
21:46:36 <lambdabot> 50 => 50
21:46:48 <tensorpudding> never heard that command before
21:46:50 <Saizan> @dice 2d6
21:46:51 <lambdabot> 2d6 => 8
21:47:00 <domor> @dice 2d6
21:47:00 <lambdabot> 2d6 => 4
21:47:04 <tensorpudding> @dice 1000d1
21:47:04 <lambdabot> 1000d1 => 1000
21:47:06 <copumpkin> @dice 15d19
21:47:07 <lambdabot> 15d19 => 150
21:47:16 <tensorpudding> @dice 1000d0
21:47:16 <lambdabot> 1000d0 => -26965397022934738615939577861835371004269...
21:47:20 <tensorpudding> oho
21:47:41 <tensorpudding> is that a critical fail
21:48:06 <ddarius> Um, what value are you expecting to come from 1000 rolls of a 0-sided die?
21:48:15 <tensorpudding> 0?
21:48:35 <copumpkin> > toRational (1/0)
21:48:36 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
21:48:58 <copumpkin> > toRational (-1/0)
21:48:59 <lambdabot>   (-1797693134862315907729305190789024733617976978942306572734300811577326758...
21:49:16 <domor> ddarius: an error would be better than a nonsensical result, I assume
21:49:19 <copumpkin> > toRational (0/0)
21:49:21 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
21:49:23 <copumpkin> aha
21:49:42 <tensorpudding> > 5 % 0
21:49:43 <lambdabot>   * Exception: Ratio.%: zero denominator
21:49:55 <tensorpudding> Data.Ratio takes exception to this shit
21:51:59 <kquick2> OK, back to existential types (specifically http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types).  The paradox I'm struggling with is that the contents of the Showbox are unknown except that they satisfy Show, yet it's legal to call show on them.  How does the compiler know which show function to invoke if it has lost the Showbox a type?
21:53:58 <Saizan> one has been chosen when the constructor got applied
21:55:17 <kquick2> So the show function for each a gets "bound" to the show function for each SB instance when that instance is created?
21:55:43 <ddarius> kquick2: Consider how you'd make a similar existential type without using type classes.
21:56:49 <kquick2> ddarius: meaning?
21:57:26 <ddarius> kquick2: I meant exactly what I said.  Think about it.
21:58:21 <twink> Where are those Word256 types etc.
21:59:02 <kquick2> Without type classes I couldn't declare any methods, therefore SB would be utterly opaque and useful only as a placeholder in my Heterolist.  Is this what you mean?
21:59:06 <ddarius> @hoogle Word256
21:59:06 <lambdabot> No results found
21:59:27 <copumpkin> http://hackage.haskell.org/packages/archive/Crypto/latest/doc/html/Data-LargeWord.html
21:59:40 <copumpkin> I thought there was a separate package for them though
22:00:01 <ddarius> kquick2: No.  How would you get a similar result without using type classes.  You are mixing the notion of existential types and type classes and that's making your understanding of existential types more difficult.
22:00:24 <copumpkin> that representation seems unnecessarily slow
22:00:33 <copumpkin> it's nesting them, with no strictness and no unboxing
22:01:23 <sjanssen> copumpkin: yeah, you'd want to get rid of LargeKey if you really want goesfast
22:01:47 <twink> Still looking.
22:01:55 <sjanssen> actually, I'd look into making LargeKey a data family
22:05:20 <kquick2> That's where I'm lost (my original question: it was GADT based but I think it was really an existential type question).  I want to do something with the SB elements of the Heterolist.  How can I do anything with what's "in" an SB constructor without pattern matching if the explicit type is lost when bound by the constructor?
22:05:59 <kquick2> I can't: doX :: SB a -> Bool; doX (SB (b::Int)) = True
22:06:43 <kquick2> Sorry, doX :: ShowBox -> Bool; doX (SB (b::Int)) = True
22:08:02 <dolio> Did you know that any time you have 'C a => t' you can turn it into 'C a -> t', where C a is a datatype holding the functions that would be in the class?
22:08:04 <sjanssen> bah, who tabstops at 3 characters?
22:08:24 <twink> I'm a little lost.
22:11:36 <dolio> Man, finally building HEAD.
22:11:54 <dolio> Downloading the snapshot tarball was a good tip.
22:12:02 <bos> dolio: funnily, that's exactly what we do in the event library.
22:13:37 <twink> There's a needle in the haystack affair going on with LargeKey
22:14:08 <dolio> Of course, you need to apply a little ingenuity to make that work for existentials.
22:14:19 <ddarius> dolio: You do?
22:14:50 <tomberek> howdy all
22:14:59 <dolio> exists a. C a => T[a] doesn't become 'exists a. C a -> T[a]'.
22:15:33 <dolio> Assuming one keeps the => notation for exists-bound variables.
22:15:55 <ddarius> Perhaps one shouldn't...
22:15:59 <dolio> I suppose it's straight forward if you're using GADT syntax.
22:19:14 <dolio> Figuring out in 'data Foo = forall a. C a => Con (T[x])' how the C a permutes past the Con presumably isn't obvious, either, unless you already know how existentials interact with classes.
22:20:01 <dolio> That should be a T[a], clearly.
22:21:11 <twink> I may have lost it.
22:21:54 <copumpkin> twink: ?
22:26:28 <twink> Sorry, I mean I may have lost the thread.
22:27:37 <dolio> Just buy some more at Jo-Ann Fabrics.
22:28:22 <twink> No, having to do with LargeWord and LargeKey
22:29:02 <dons> bos: pong
22:30:49 <bos> dons: do you know of any decent http load generators that speak http 1.1 correctly?
22:31:21 <dons> mmm, you mean like ab or httperf?
22:31:46 <bos> i'm clocking upwards of 12,000 requests per second on my laptop with http 1.1 keepalive, but httperf has the world's worst command line interface, and i can't get it to perform well over the network.
22:32:06 <ulfdoz> canoo webtest and some forking.
22:32:25 <bos> this is with a small tweak to my server code that was previously handling 7000 requests per second when it was forcing connection: close
22:32:30 <ulfdoz> dunno, whether it meets your needs, but you can even simulate full user stories with it.
22:32:38 <dons> that's all i've used. so i've no other recommendations
22:33:00 <bos> ulfdoz: not really, sorry.
22:33:09 <bos> ulfdoz: thanks though.
22:33:11 <bos> dons: sod.
22:34:52 <ulfdoz> bos: With a bit of scripting you can probably use wget, too.
22:35:19 <bos> ulfdoz: not really, i want a very fast and lightweight client.
22:39:52 <ulfdoz> bos: Air gets thin there. httperf is the only one I find, that is really specialised in performance measuring
22:41:47 <ski> dolio : imo, one should normally use something like `exists a. C a *> T [a]', `exists a. C a => T [a]' meaning something else
22:42:19 <dolio> Well, I'm on board for the first one. What would the second one mean?
22:43:08 <ski> (iow, `exists a. C a *> T [a]' would be translated to `exists a. (CDict a,T [a])'; while `exists a. C a => T [a]' would be translated to `exists a. CDict a -> T [a]')
22:43:33 <ulfdoz> bos: but another question: How do you get 12k requests/sec out of a single box? I could need something similar for another protocol. My current shot is, to have only a few threads issuing the requests and processing the replies in another one, but I'm far away from 12k. Also it is not that parallel as I'd expect it in practice.
22:43:36 <dolio> Oh. The second one probably wouldn't be very useful.
22:43:52 <ski> in this case, the latter is probably not very useful .. but i think there could possibly be cases where it would be useful
22:44:09 <dolio> Except if you have incoherent instances.
22:44:28 <ski> (and in any case, it's good to be able to express the distinction between `=>' and `*>', imo)
22:44:30 <dolio> (Which, GHC automatically does for existentials, but...)
22:44:47 <ski> it does what automatically for existentials ?
22:45:06 <dolio> It has incoherent instances even when IncoherentInstances isn't enabled.
22:45:29 <ski> example ?
22:46:11 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16988
22:48:11 <Saizan> eww
22:48:24 <dolio> http://www.haskell.org//pipermail/glasgow-haskell-users/2010-February/018366.html
22:48:27 <dolio> Also there.
22:49:25 <ski> if you remove the `case' in `bar', what happens ?
22:49:30 <ski> do you get an error ?
22:49:49 <dolio> Remove it how?
22:50:02 <ski>   bar :: a -> String
22:50:07 <ski>   bar x = foo x
22:50:12 <copumpkin> that requires incoherent instances
22:50:17 <copumpkin> I think?
22:50:20 <dolio> Yes, that is an error unless incoherent instances are enabled.
22:50:28 <ski> ok, i see what you mean
22:50:45 <roboshibby> incoherent instances?
22:52:24 <dolio> SPJ explains the motivation in that thread, although I'm not sure I buy it.
22:53:44 <Saizan> he basically gives a reason against OverlappingInstances in that post
22:55:10 <Saizan> and i guess he meant to add an instance Show [Char] where .. ?
22:55:24 <roboshibby> dang, i dont know haskell syntax yet. i'd like to know what's meant by:
22:55:26 <roboshibby> class C a where
22:55:26 <roboshibby>     foo :: a -> String
22:55:27 <roboshibby>   instance C a where
22:55:27 <roboshibby>     foo _ = "universal"
22:55:27 <roboshibby>   instance C Int where
22:55:28 <roboshibby>     foo _ = "Int"
22:55:28 <roboshibby>   bar :: a -> String
22:55:28 <roboshibby>   bar x = foo x
22:56:21 <copumpkin> you could have just linked to his paste :P
22:56:44 <copumpkin> he's showing some odd behavior of certain obscure haskell extensions that many haskellers don't know
22:56:59 <copumpkin> I don't think that if you don't understand the syntax you'd get very much out of it
22:57:02 <dolio> Nor use. :)
22:57:07 <roboshibby> damn
22:57:18 <roboshibby> can you walk me through what's being done there? i want to learn haskell
22:57:32 <copumpkin> I don't think it's a good starting point :)
22:57:48 <roboshibby> ok, lol
22:57:54 <roboshibby> how about, hello world?
22:58:06 <copumpkin> > "hello, world!"
22:58:08 <lambdabot>   "hello, world!"
22:58:17 <dolio> main = putStrLn "Hello world."
22:58:33 <dmwit> > expr . fun $ "Hello, quoteless world!"
22:58:34 <lambdabot>   Hello, quoteless world!
22:58:35 <copumpkin> needs more enthusiasm!
22:58:45 * dmwit feels devilish
22:58:45 <copumpkin> main = putStrLn "Hello, world!"
22:58:59 <copumpkin> > text "Allo"
22:59:01 <lambdabot>   Allo
22:59:01 <dolio> > text "Hello world" -- come on
22:59:03 <lambdabot>   Hello world
22:59:08 <ddarius> dolio: Moral of the story, down with overlapping instances.
22:59:10 <dmwit> copumpkin: Thank you! How come so many people forget the comma??
22:59:19 <dmwit> dolio: I always forget the name of it. =P
22:59:34 <copumpkin> :)
22:59:37 <ddarius> dmwit: But you remember expr . fun?
22:59:42 <dmwit> yep
22:59:51 <dmwit> crazy little world innit
23:00:13 <dolio> ddarius: Yeah, well, I'm not terribly enamored with overlapping instances myself.
23:00:53 <Saizan> OverlappingInstances are not bad when your methods are in Prop
23:01:48 <ddarius> "OverlappingInstances are not bad when your methods don't matter."
23:03:03 <mauke> roboshibby: you've been here for at least two months asking questions, and now you want to start learning haskell?
23:03:19 <copumpkin> wow, that long?
23:03:26 <copumpkin> I remember him storming off a couple of days ago
23:04:19 <mauke> the nick appears in dec 2009, which is when I started logging
23:04:32 <copumpkin> wow
23:08:13 <roboshibby> yea, im a wild man
23:09:34 <copumpkin> so are you actually interested in learning seriously or do you just like to poke at us occasionally?
23:10:20 <copumpkin> we're more than happy to put some effort into explaining things to people, but it's frustrating if they forget it all the next day
23:10:23 <roboshibby> definitely interested. i dont have enough free time for it now, but i'm aching to
23:10:38 <copumpkin> we have a few recurring people who've been coming here for years pretending to want to learn
23:10:45 <copumpkin> but really just making snide remarks about the language
23:10:45 <roboshibby> copumpkin, oh i've really just been having general conversation, not asking too much about haskell
23:10:47 <copumpkin> ok :)
23:11:00 <mauke> except when you asked about Control.Monad and >>=
23:11:22 <roboshibby> i guess, since i dont have the time *yet* but plan to 'soon', im just having conversation to get to know some of you guys
23:11:31 <roboshibby> yea
23:11:33 <roboshibby> except then
23:13:16 <copumpkin> :)
23:19:19 <roboshibby> haskell seems like the best language of the class of 'functional mathy' languages
23:42:21 <ski> dolio : hm, do you know if this over strange issue with overlapping instances was discussed too ?
23:42:35 <ski> namely one that crops up in things similar to
23:42:39 <ski> @type \p -> let _ = fst p in elem p
23:42:40 <lambdabot> forall a b. (Eq a, Eq b) => (a, b) -> [(a, b)] -> Bool
23:43:06 <ski> here the context is `(Eq a,Eq b)', rather than `Eq (a,b)'
23:43:08 <roboshibby> Mirc is spamming
23:44:13 <ski> but if there were an overlapping instance `Eq (Int,Int)' *known* at the point the above was defined, then it would get a context of `Eq (a,b)' instead
23:45:30 <ski> so the same code will get different context (with possibly differing behaviour), depending on whether an overlapping instance is known at the point where the code appears
23:45:55 <ski> (and this happens with two copies of that same code in two places in the same program)
23:46:51 <ski> (s/happens/still happens/)
23:50:26 <Saizan> there's a ticket about something very similar to that
23:50:49 <roboshibby> fraggle rock!
23:51:00 <roboshibby> man i haven't watched that in at least 20 yars
23:51:02 <roboshibby> years*
23:52:12 <ski> Saizan : which ?
