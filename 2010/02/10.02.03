01:06:06 <solrize> divmod should be quadratic, not cubic, if done the obvious way
01:06:15 <solrize> expmod is cubic and montgomery helps with that
01:06:25 <solrize> mreh what are you trying to do?
01:06:29 <solrize> how big are these numbers?
01:06:42 <solrize> haskell uses GMP which uses fancy algorithms (FFT based) when the numbers are very large
01:07:14 <c_wraith> sometimes.  GHC on  OSX doesn't use GMP unless it's installed
01:07:20 <solrize> hmm
01:07:29 <solrize> well install it :)
01:08:15 <c_wraith> also, it's an optional dependency in 6.12.  You can choose to link against a pure haskell implementation instead, on any platform
01:08:41 <solrize> ic
01:20:02 <moshisushi> hello!
01:20:20 <moshisushi> ghc-pkg says parsec-3.0.0 is installed
01:20:24 <moshisushi> byt import Parsec fails
01:20:43 <moshisushi> "Could not find module Parsec"
01:20:50 <moshisushi> when running ghci
01:20:52 <moshisushi> any ideas?
01:21:03 <moshisushi> i'm using latest stable ghc
01:21:37 * Cyneox re
01:22:02 <moshisushi> nevermind.. had to import Text.ParserCombinators.Parsec instead of just Parsec
01:23:22 <medfly> :-)
01:28:33 <Daerim> Good morning haskellers
01:29:13 <Daerim> Anyone know of a Fortran tutorial for haskell programmers?
01:30:39 <Ke> there is no similarity at all between the 2
01:31:25 <Ke> just write matlab code and you are pretty close
01:31:28 <Daerim> Ke, that was what I was afraid of
01:32:08 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17014#a17014  why does this panic the compiler ?
01:35:23 <fasta> solrize, because of the :
01:35:44 <fasta> solrize, so, you failed and the compiler doesn't give a nice error message, because the compiler devs were lazy.
01:35:49 <fasta> solrize, it's a known issue.
01:37:03 <solrize> fasta, oh oops, i got confused, i thought the : was needed.  i even looked at another program that compiled, and didn't notice the difference.  thx
01:53:42 <ksf> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/GHC-IO-Device.html#v%3Aread
01:53:49 <ksf> "This function should only block if there is no data available. If there is not enough data available, then the function should just return the available data."
01:53:54 <ksf> is that standard C behaviour?
01:54:05 <ksf> and what does "should" mean?
01:54:49 <ibid>  there is no "read" in standard C
01:55:02 <ibid> but that does look like the usual Unix behavior
01:55:23 <ksf> posix == c, for all I care
01:55:49 <ibid> as long as you are content to be nagged about it :)
01:57:07 * hackagebot upload: haskell-src-exts 1.8.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
01:58:38 <fasta> ksf, probably some exception.
01:59:43 <Ke> there is fread in standard C and that's pretty close
02:01:49 <quicksilver> but fread doesnt' specify blocking behaviour.
02:02:09 <ibid> although unbuffered mode does come close
02:02:28 <ibid> but certainly fread doesn't guarantee the semantics quoted above
02:03:08 <ibid> (though, as fread is, in Unix, likely to be implemented using read + libc buffering, it is likely it will follow it)
02:03:19 <fasta> Documentation with words like "should" should (haha) be vanquished.
02:03:34 <ibid> or "should" should be defined
02:04:15 <ibid> the IETF meaning of SHOULD is probably the clearest specification, but not always what is meant
02:04:21 <fasta> How hard is it to simply specify the exact contract for everything?
02:04:46 <ibid> fasta: hard
02:05:15 <ibid> (though i expect you didn't really mean "exact" there:)
02:05:24 <ksf> ...it's all moot anyway, I can't mix FDs with Fds
02:06:25 <ibid> (often people write "should" when they mean "must" but are timid)
02:07:03 <ibid> (or think that it isn't enforceable anyway)
02:07:37 <ksf> ...ok, what do I use to read an Fd unbuffered?
02:08:41 * ksf should actually look at System.Posix.IO before asking
02:09:07 <Bacta> Welcome to BactaBot
02:09:13 <quicksilver> ksf: if you hSetBuffering appropriately, then haskell Handles are unbuffered.
02:09:13 <Bacta> A Chatbot written in Haskell
02:09:18 <mm_freak> why do you use the low level interface anyway?
02:09:19 <Bacta> To troll #freenode press #1
02:09:50 <quicksilver> ksf: are you really asking about buffering, or about blocking?
02:09:53 <ksf> wtf fdRead returns a string
02:10:00 <ksf> er yes blocking
02:10:00 <quicksilver> your first question seemed to be able blocking.
02:10:36 <quicksilver> the simplest solution in haskell is normally to use a thread for the reading.
02:10:37 <mm_freak> ksf: i don't know if you have specific reasons to do it that way, but to read nonblockingly you read blockingly in haskell
02:10:41 <mm_freak> in a concurrent thread
02:11:03 <ksf> I'm using tibbe's epoll stuff
02:11:07 <medfly> Bacta, #1!
02:11:49 <ibid> wtf, a chat bot inside irc?
02:11:57 <mm_freak> what's wrong with concurrency?
02:12:23 <ksf> well...
02:12:38 <ksf> that'd be spawning threads in the callback
02:13:00 <ksf> I guess it should be safe because I won't get another callback before everything is read
02:13:06 <mm_freak> not necessarily
02:13:17 <mm_freak> you can spawn the thread beforehand and communicate with it using an MVar
02:16:05 <ksf> if alice sends me 1k of data and waits for an answer, and bob is using a 2k input buffer and blocking, they aren't going to talk much.
02:16:32 <ksf> ...no matter how many threads bob uses
02:16:46 <mm_freak> hSetBuffering h NoBuffering
02:17:01 <ksf> I've got an fd, not a handle
02:17:25 <mm_freak> convert it to a Handle
02:18:03 <ksf> I'd have to do that everytime epoll calls me
02:18:47 <jmv> Hi      what should I import to make data definition like in    data Bool = False | True
02:18:52 <HugoDaniel> hello
02:18:55 <HugoDaniel> i need help please!
02:18:58 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17016#a17016
02:19:04 <HugoDaniel> the thing on line 193 (in blue)
02:19:16 <HugoDaniel> takes about 4GB of RAM to run
02:19:19 <HugoDaniel> and takes AGESSSS
02:19:22 <benmachine> jmv: no imports necessary
02:19:52 <mm_freak> ksf: well, do you have specific reasons to use epoll?  concurrency is the way to handle this in haskell
02:20:18 <HugoDaniel> the [Detalhe] is about 7000 in length
02:20:31 <HugoDaniel> its not that many...
02:20:33 <HugoDaniel> why is this ?
02:20:42 <jmv> benmachine, ok, but then how to make it available in ghci ?
02:20:55 <benmachine> jmv: you can't do that in ghci
02:21:05 <benmachine> you have to do it in a file
02:21:09 <benmachine> and then load that file into ghci
02:21:11 <mm_freak> HugoDaniel: i don't see your imports, but it could be because you're packing a long string into a strict ByteString
02:21:12 <ksf> mm_freak, the reason is http://github.com/tibbe/event
02:21:14 <jmv> ok
02:21:25 <Alpounet>  What do you guys advise to use for timing haskell programs ?
02:21:33 <HugoDaniel>   7 import qualified Data.ByteString.Char8 as BS
02:21:34 <benmachine> this process is a little less painful if you know about the ghci commands :e and :r
02:21:36 <HugoDaniel> maybe this ?
02:21:44 <benmachine> which edit a loaded source file and reload it, respectively
02:21:52 <mm_freak> ksf: the RTS provides this stuff, too
02:21:54 <Saizan> Alpounet: criterion?
02:21:58 <Alpounet> oh yeah right
02:22:01 <ksf> mm_freak, the rts uses select
02:22:01 <Alpounet> thanks
02:22:02 <ksf> http://hackage.haskell.org/trac/ghc/ticket/635
02:22:17 <mm_freak> ksf: what's wrong with select?
02:22:22 <ksf> it's slow
02:22:51 <gmux2> it doesn't scale, rather
02:22:52 <HugoDaniel> anyway, i compiled it with -O3, and it ran fast (taking only 2GB of RAM)
02:23:09 <ksf> ...which is the same if you're writing a web server.
02:23:24 <mm_freak> well, i'd rather wait for the RTS to use epoll instead
02:23:26 <Saizan> HugoDaniel: why do you pack your String into a ByteString just to write it out?
02:23:28 <ksf> -O3 is the same as -O2
02:23:31 <Saizan> HugoDaniel: use a lazy one at least.
02:23:45 <mm_freak> using an event library seems to me like going back to C++
02:23:58 <HugoDaniel> Saizan, isn't it faster ?
02:24:20 <jmv> just a beginner's thought: Haskell is rather mathematical, and mostly about functions, but it droped the essential of math functions syntax: the parenthesis!
02:24:51 <mm_freak> also note that i use concurrency heavilyâ€¦  i haven't noticed any performance problems with the RTS so far
02:25:12 <ksf> jmv, that's because we don't multiply stuff as often as apply functions
02:25:17 <xerox> jmv - it's because the most important construct should use the lightest syntax: in this case function application, and the syntax is just juxaposition
02:25:22 --- mode: xerox set -o xerox
02:25:23 <Saizan> HugoDaniel: it'd be faster if you were working with Bytestring from the start, packing like that has to force the whole list, allocating a chunk of memory large enough, copying every char from the list into this chunk of memory, copy the contents of this chunk in pieces to the OS
02:25:30 <Saizan> HugoDaniel: it doesn't look fast to me!
02:25:57 <jmv> xerox, that makes sense
02:26:00 <rmui86> can you program games with haskell?
02:26:06 <ksf> HugoDaniel, probably just using non-bytestring putStrLn would make it faster
02:26:09 <gmux2> @faq can you program games with haskell?
02:26:09 <lambdabot> The answer is: Yes! Haskell can do that.
02:26:15 <Saizan> HugoDaniel: using a lazy bytestring you wouldn't force the whole input list at once, at least
02:26:35 <Saizan> HugoDaniel: but i still don't think it's a win over just using System.IO.writeFile directly
02:26:59 <jmv> thanks ksf too
02:28:24 <mm_freak> Saizan: it may be a win, because writeFile is much faster for ByteStrings
02:28:30 <jutaro> HugoDaniel: The list concatenation with ++ in show gives quadratic behavior. Use ShowS
02:28:39 <mm_freak> i think BS.pack is more efficient than whatever writeFile does to make a byte array
02:29:09 <Saizan> mm_freak: with lazy bytestrings, you mean?
02:29:15 <mm_freak> yeah
02:29:27 <HugoDaniel> jutaro: why dont i know of these things ? :P
02:29:49 <Saizan> mm_freak: we'd have to measure!
02:29:51 <mm_freak> jutaro: what do you mean?
02:29:59 <mm_freak> (++) is not strict
02:30:37 <Saizan> mm_freak: if you repeadetly use ++ in a left associative fashion, you get quadratic time
02:31:05 <mm_freak> the way he uses it it should make no difference
02:31:37 <mm_freak> you shouldn't use it to make a string in an append-style, which you're going to use in its entirety
02:31:39 <jutaro> mm_freak: ++ Copies the whole list to append at the end. If you repeat this a lot of times it eats your cycles. Strict or not, it does it at some point.
02:31:44 <Saizan> depends on what he is actually showing
02:31:55 <mm_freak> but using it to make a string, which you intend to consume sequentially should be fine
02:32:04 <ksf> mm_freak, the actual fun starts when it's coming to load-balancing the fds across cores
02:32:34 <Saizan> mm_freak: (a ++ b) ++ c == a ++ (b ++ c), but the first traverses 'a' twice
02:33:03 <ksf> ...which is a thing I don't want to do in the rts, because the rts doesn't scale to the cloud
02:33:06 <HugoDaniel> interesting.. :D
02:33:08 <mm_freak> sure
02:33:15 <mm_freak> but HugoDaniel uses only a single (++) anyway =)
02:33:43 <jutaro> HugoDaniel: http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#UsingShowS
02:34:02 <Saizan> mm_freak: look at the Show instances
02:34:06 <mm_freak> ksf: i would, because i expect it to be fixed some time instead of forcing me to use an event library
02:34:43 <mm_freak> oh, i see
02:35:09 <ksf> I seriously doubt that the rts will ever do the exact right thing in that case
02:35:34 <mm_freak> ksf: if it doesn't, i'll live with it
02:35:43 * Saizan strongly disagrees with 16
02:35:52 <ksf> but then you won't be able to serve a billion concurrent users
02:36:03 <mm_freak> really, i don't expect my software to be run on terabit links anyway
02:36:22 <mm_freak> i don't want to give up the concurrency constructs the RTS provides
02:36:26 <Alpounet>  ?
02:36:28 <Saizan> why are you two discussing about what each one wants to do?
02:36:29 <ksf> me neither, but there's enough web servers that don't to make me want to write one that can.
02:36:30 <Alpounet> 16  ?
02:36:43 <Saizan> Alpounet: i was referring to the link :)
02:36:57 <Alpounet> haha ok
02:37:23 <mm_freak> ksf: feel freeâ€¦  i'll be glad to use it, when it's finished =)
02:38:25 <mm_freak> i don't like apache a lot, but i have yet to find some time and delight to learn happstack
02:38:50 <ksf> apache is a pile of legacy patches
02:39:30 <mm_freak> yes and its haskell support is around zero
02:39:36 <mm_freak> more to the negative side
02:40:07 <ksf> it's got a lot of features, and is obviously bloated, otherwise people wouldn't be using lighthttpd
02:40:56 <ksf> ...and fastcgi is necessarily slow because you have to copy the data
02:40:56 <mm_freak> i'm used to apache and it gives me the performance i need, until i finally become strict and learn happstack =)
02:41:26 <mm_freak> then i can get rid of it entirely
02:49:54 <cizra> data Num = D Digit | Num :> Digit
02:50:09 <cizra> :> appears to mean "followed by" here.
02:50:28 <cizra> Is this standard Haskell? I've seen it working in hugs for certain.
02:50:36 <cizra> How to read/understand/grok :>?
02:51:05 <Saizan> ":>" is just the name of the contructor there
02:51:28 * cizra ponders
02:51:31 <Saizan> Num is isomorphic to non-empty lists of Digit
02:51:35 <mm_freak> cizra: data Num = D Digit | (:>) Num Digit
02:51:52 <cizra> mm_freak: -- yeah, that's helpful (=
02:51:56 <HugoDaniel> Saizan: are you going to the hackaton in zurich ?
02:52:20 <Saizan> HugoDaniel: not sure yet
02:52:28 <mm_freak> cizra: but it's not standard AFAIK
02:52:30 <pokoko222> NLP is done with Haskell?
02:52:34 <pokoko222> anyone has experience?
02:53:13 <cizra> mm_freak: Is :> something my teacher just came up with? It rather seems to be some kind of Hugs-provided operator.
02:53:26 <cizra> pokoko222: yes, I think
02:53:33 <Saizan> pokoko222: http://www.cs.chalmers.se/~aarne/GF/ is implemented in haskell, i think
02:54:03 <Saizan> cizra: that "data Num = D Digit | Num :> Digit" is what is defining :>
02:54:07 <mm_freak> cizra: it's just a constructor nameâ€¦  there is an extension allowing symbolic constructors, as long as they start with a colon
02:54:20 <Saizan> you don't need any extension for them.
02:54:40 <mm_freak> what is it that you need an extension for?  type operators?
02:54:43 <cizra> aha!
02:54:44 <Saizan> yeah
02:54:46 <mm_freak> ah, ok
02:55:28 <mm_freak> however, cizra, you could just as well write it as:  data Num = D Digit | Append Num Digit
02:55:44 <mm_freak> and you wouldn't want to call it Num =)
02:57:06 <cizra> Yes, I already search-replaced it to Numb
02:57:14 <cizra> OK, thanks. You guys are very helpful.
02:57:17 <cizra> (gals?)
02:57:41 <mm_freak> uhm, how about Number?
02:58:29 <ksf> or Num `Append` Digit
02:58:45 <ksf> (:>) Num Digit should work, too
03:02:24 * hackagebot upload: hashed-storage 0.4.6 - Hashed file storage support code. (PetrRockai)
03:31:50 <temoto> @src map
03:31:51 <lambdabot> map _ []     = []
03:31:51 <lambdabot> map f (x:xs) = f x : map f xs
03:34:05 <drk-sd`> @djinn ? a -> a
03:34:05 <lambdabot> Cannot parse command
03:34:09 <drk-sd`> :(
03:35:04 <drk-sd`> temoto: can you show me how to use djinn please ?
03:35:13 <drk-sd`> (im not at home, i dont have my logs)
03:37:03 <drk-sd`> @djinn f ? a -> a
03:37:03 <lambdabot> Cannot parse command
03:37:07 <drk-sd`> @djinn f ? a -> a;
03:37:07 <lambdabot> Cannot parse command
03:37:13 <drk-sd`> meuh :(
03:37:46 <zygoloid> what do you expect the ? to do? :)
03:37:48 <drk-sd`> @djinn a -> a
03:37:49 <lambdabot> f a = a
03:37:57 <zygoloid> @djinn f :: a -> a
03:37:58 <lambdabot> Cannot parse command
03:38:00 <zygoloid> :(
03:38:05 <drk-sd`> @djinn a -> [a]
03:38:06 <lambdabot> Error: Undefined type []
03:38:13 <temoto> @djinn a -> a
03:38:13 <lambdabot> f a = a
03:38:38 <temoto> drk-sd`, afaik djinn doesn't know about lists.
03:38:53 <drk-sd`> @djinn int -> int -> char
03:38:53 <lambdabot> -- f cannot be realized.
03:39:02 <temoto> @djinn Int -> Char
03:39:03 <lambdabot> Error: Undefined type Int
03:39:08 <temoto> @djinn Integer -> Char
03:39:08 <lambdabot> Error: Undefined type Integer
03:39:21 <temoto> Doesn't know about pretty much of things. :)
03:39:31 <drk-sd`> taht's sad :(
03:39:43 <drk-sd`> that*
03:40:03 <drk-sd`> @djinn int -> a
03:40:04 <lambdabot> -- f cannot be realized.
03:40:05 <temoto> drk-sd`, you can use clever guys around as a better replacement for @djinn.
03:40:14 <drk-sd`> yeah sure :D
03:40:28 <drk-sd`> but well, i wanted to try it a bit
03:40:54 <drk-sd`> i'm in school right know and kinda bored so :-'
03:41:13 <drk-sd`> (i should be doing C# :x )
03:42:41 <drk-sd`> @djinn (a -> b -> c) -> ((a,b) -> c)
03:42:41 <lambdabot> f a (b, c) = a b c
03:43:40 <drk-sd`> is that right ?
03:43:58 <drk-sd`> doesnt seem
03:45:57 <mm_freak> yes, it's righ
03:46:11 <drk-sd`> there are to much parenthesis apparently
03:46:18 <mm_freak> (a -> b -> c) -> ((a, b) -> c) = (a -> b -> c) -> (a, b) -> c
03:46:21 <medfly> :t (f a (b,c) = a b c)
03:46:21 <lambdabot> parse error on input `='
03:46:25 <drk-sd`> or aint there?
03:46:33 <drk-sd`> ah
03:46:34 <drk-sd`> ok
03:46:38 <mm_freak> you've written curry2
03:46:44 <mm_freak> :t curry2
03:46:45 <lambdabot> Not in scope: `curry2'
03:46:51 <drk-sd`> oh, yeah ok
03:46:51 <medfly> @hoogle curry2
03:46:51 <lambdabot> No results found
03:46:54 <mm_freak> :t curry
03:46:55 <drk-sd`> i get it now
03:46:55 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:47:03 <mm_freak> uncurry
03:47:04 <ivanm> sure it's not curry3?
03:47:05 <mm_freak> not curry
03:47:09 <medfly> @hoogle uncurry
03:47:09 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
03:47:09 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
03:47:25 <mm_freak> it's uncurry, sorry
03:47:45 <mm_freak> you're making a bad function out of a good one =)
03:48:26 <medfly> hurrah
03:57:02 <ksf> where do the standard libraries hide setbuf(3)?
04:02:03 <b0fh_ua> Hi there! Can somebody please explain, how can I specify types explicitly in the code: http://pastebin.com/d20d23b54 ? the function definition is http://hackage.haskell.org/packages/archive/curl/1.3.5/doc/html/Network-Curl.html#v%3AcurlGetResponse_
04:03:02 <guest> I have a question
04:03:24 <ksf> :t (*) :: Int -> Int -> Int
04:03:25 <guest> How do I accept user input?
04:03:25 <lambdabot> Int -> Int -> Int
04:03:26 <ksf> like that
04:03:48 <ivanm> guest: in what sense?
04:03:52 <ivanm> there's the interact function
04:04:15 <ksf> guest, http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
04:04:19 <ivanm> you can do it manually
04:04:29 <ivanm> or there's the Prompt monad IIRC
04:04:34 <guest> I want to accept a string of input from the user whilst allowing delete/backspace to work and to prohibit arrow key navigation
04:04:49 <guest> from 1st principles
04:05:04 <Axman6> try getLine
04:05:04 <ivanm> "from 1st principles"? what's that mean?
04:05:08 <ksf> you don't want to do it from 1st principles
04:05:09 <guest> I want the up arrow to recall a history of typed commands (but this is optional)
04:05:11 * ivanm wildly guesses homework problem... >_>
04:05:12 <ksf> ...but use haskelline
04:05:21 <ivanm> yeah, or an explicit ncurses binding
04:05:31 <Axman6> guest: ha, there's nothing first principals about that ;)
04:05:42 <Axman6> use haskeline
04:05:51 <ivanm> b0fh_ua: I _think_ it's how you use the C.curlGetResponse_ function
04:05:58 <ivanm> so you need something before it in your main function
04:06:00 <guest> getLine puts funny characters when I press delete on my iMac
04:06:03 <ksf> http://hackage.haskell.org/package/haskeline
04:06:06 <ivanm> even if it's using typeOf
04:06:15 <ivanm> *asTypeOf
04:06:19 <ivanm> > 1 `asTypeOf` 2.3
04:06:20 <lambdabot>   1.0
04:06:29 <ivanm> guest: which version of ghc?
04:06:48 <ksf> with haskeline, you even get command line history and completition
04:07:04 <ivanm> b0fh_ua: are you using C.curlGetResponse_ just for a side effect?
04:07:04 <guest> 6.10.4
04:07:17 <ivanm> hmmm.... there shouldn't be anything funny there AFAIK...
04:08:21 <guest> I could do this easily on my Commodore 64...why is it so hard to do in Haskell? It seems almost so trivial its embarrassing!
04:09:16 <ksf> guest, the other possibility is to disable input echoing in your terminal, and outputting the input yourself.
04:09:32 <ksf> or maybe just enable line buffering
04:09:42 <ksf> terminals are, in general, extremely nasty.
04:10:09 <ksf> guest, as I said, just use haskeline
04:10:18 <ivanm> depends on how you define "easy" and "hard" and what you expect to do with the input
04:10:29 <b0fh_ua> ivanm: I am using it to get the content from specific URL
04:10:35 <ksf> ...and it's a unix thing, not something specific to haskell
04:10:36 <ivanm> also, I've never heard of a programming language called "Commodore 64" :p
04:10:44 <ivanm> b0fh_ua: well, you won't get it that way AFAIK
04:10:50 <guest> It's for a text adventure, like Zork
04:11:08 <b0fh_ua> I think I can safely use String for now, but I'd like to understand how to use curlGetResponse_ :)
04:11:12 <ivanm> b0fh_ua: oh, wait, I misread your code
04:11:16 <b0fh_ua> ivanm: okay, please explain :)
04:11:28 <Axman6> blackdog: you around?
04:12:08 <ivanm> b0fh_ua: OK, so I _think_ you want it to return (CurlResponse_ [(String, String)] String)
04:12:33 <ivanm> so you want to use a respBody in there
04:12:38 <ivanm> oh, wait, you are
04:12:57 <ivanm> b0fh_ua: aha! try replacing it "parseBody $ respBody resp" with "parseBody (respBody resp)"
04:13:29 <ivanm> you want it to be part of the RHS of the >>=, but due to its associativity it makes the >>= part of the LHS of the $
04:13:35 * ivanm has fallen into that trap before
04:13:57 <ivanm> b0fh_ua: also, atm you can just say parseBody = print
04:14:16 * ivanm annotates the paste
04:15:03 <ivanm> b0fh_ua: have a look at http://pastebin.com/d6e7f922e
04:15:07 <ivanm> that should work I think
04:15:08 <b0fh_ua> oh yeah
04:15:18 <ivanm> it's a bit simpler as well
04:18:07 <b0fh_ua> anyway it still wants me to define type for headers
04:21:22 <ivanm> b0fh_ua: OK, so what you can do is to split out the "parseBody . respBody" bit into a separate function and give it a type
04:21:48 <ivanm> type CurlResponse -> IO ()
04:21:57 <ivanm> that should do the trick
04:25:51 <b0fh_ua> looks ugly :(
04:25:56 <ksf> groaaaaaaaaaaaaaaaaaaan
04:26:10 <ksf> which clown did think of the name setCooked?
04:28:18 <ivanm> b0fh_ua: *shrug*
04:29:01 <ivanm> there might be another way, but I can't think of one off the top of my head that doesn't require either giving an explicit signature, defining a new function or somehow having a value of type CurlResponse handy to use as a comparison
04:29:45 <koala_man> ksf: it's probably ancient. even posix uses it
04:32:14 <b0fh_ua> ivanm: with the helper function it works fine
04:32:20 <b0fh_ua> but that's ugly :)
04:32:29 <snhmib> ksf: it's the opposite of raw :P
04:33:10 <ksf> boiled. fried.
04:33:39 <ksf> I'd understand the choice if there was a setRaw, too, and both wouldn't take bools.
04:55:41 <temoto> @src open
04:55:41 <lambdabot> Source not found. Maybe you made a typo?
04:55:50 <ivanm> @hoogle open
04:55:50 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
04:55:50 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
04:55:50 <lambdabot> Network.Browser OpenConnection :: BrowserEventType ty
05:02:01 <ksf> why is it so hard to decide whether to copy or to reference data?
05:02:23 <endojelly> it's easy if it's immutable ;)
05:03:35 <ksf> not really. if I copy stuff out of my array, I might copy needlessly, if I reference the data, I might retain unescessary data
05:28:34 <b0fh_ua> what is the best way to parse XML in Haskell?
05:28:42 <b0fh_ua> beter event-based
05:28:49 <ivanm> haxml, hxt, etc.
05:29:14 <b0fh_ua> hxml I guess
05:32:01 <b0fh_ua> igel: well, I need to extract some data from certain tags, what would you suggest?
05:33:03 <ivanm> do you mean me rather than igel? :p
05:33:17 <igel> ;(
05:33:19 <ivanm> if so, I have no idea... never done any xml stuff (well, not with Haskell)
05:34:17 <kamatsu> i suggest looking at haddock documentation ;)
05:39:13 <ivanm> kamatsu: docu-what? :p
05:39:13 <kamatsu> ah, well, I actually tend to write massive intricate amounts of documentation
05:39:13 <kamatsu> my current work with operational transforms is all literate and jam-packed with info
05:39:17 <kamatsu> look forward to it
05:39:31 <kamatsu> *massive amounts of intricate documentation
05:39:58 <ivanm> *shudder*
05:40:02 <kamatsu> shudder?
05:40:20 <kamatsu> Writing code like you write a paper, it's a great way to force yourself to explain your assumptions
05:40:23 <kamatsu> and question them
05:40:26 <ivanm> just invisaging what kind of tangled mess you're calling "massive amounts of intricate documentation" :s
05:40:37 <kamatsu> haha, it's all structured LaTeX
05:40:40 <kamatsu> very easy to read
05:41:20 <kamatsu> I do it more for my own benefit, because It's sort of like explaining your code to someone else
05:41:58 <kamatsu> but the end product is quite useful, and easier to get to grips with than code with ordinary comments
05:42:20 <kamatsu> OTs are somewhat complicated
05:44:10 <kamatsu> (hell, i even incorporate diagrams into my lhs tex output)
05:52:11 <ksf> I think the fastest way is to use haxml and generate data types for your xml, then use some generics library
05:52:34 <ksf> ...well, at least if you did it before.
06:13:49 <Jonno_FTW> is it true, that in the life of every haskell programmer, that they must create some kind of tutorial on monads?
06:13:59 <medfly> yes
06:14:04 <medfly> it's a rite of passage
06:14:19 <Jonno_FTW> to become a great sage
06:14:22 <medfly> hehe
06:14:30 * Saizan never did
06:14:36 * Jonno_FTW gasps
06:15:32 <Saizan> i'm still in time though, i hope
06:19:05 <Axman6> medfly: well, it's obvious why :P
06:20:40 <benmachine> I kind of came up with something that I thought would be helpful but then it smelled too familiar so I thought I'd better not
06:28:06 <Alpounet> is there any trick to find what is the assembly code corresponding to some function in our haskell code, when looking at the output of ghc -S ?
06:29:37 <int-e> ghc-core manages to do that, doesn't it?
06:31:37 <Alpounet> oh
06:31:40 <Alpounet> I forgot about it
06:31:46 <Alpounet> let's take a look
06:33:16 <Axman6> Alpounet: you can search for the name of the function in the ASM output, and you should be able to find the ASM
06:33:31 <Alpounet> Axman6, that's what I did
06:33:34 <Alpounet> but doesn't seem to work
06:33:39 <int-e> hmm, apparently not :/
06:33:40 <Alpounet> well, the name isn't there
06:35:35 <int-e> hmm, does the name contain z? or _ or '?
06:36:37 <int-e> (those are encoded, z -> zz, _ -> zu, ' -> zq)
06:38:13 <rmihael> hi everybody. that's my first time here, so don't take hard on me :) I want to ask, is there standard forward composition function in haskell? Something defined like f |> g = g.f ?
06:38:45 <Twey> >>> from Control.Arrow does that
06:38:45 <int-e> > (*2) >>> (+1) $ 5
06:38:46 <lambdabot>   11
06:38:56 <Vanadium> @type (>>>)
06:38:57 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:39:06 <Twey> It's a bit more general than just function composition
06:39:11 <Twey> But that's its effect on functions
06:39:23 <Vanadium> @hoogle (a -> b) -> (b -> c) -> a -> c
06:39:24 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:39:24 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
06:39:24 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:39:42 <Alpounet> int-e, hmm I find nothing close to the name of my function
06:39:45 <Vanadium> err.
06:39:57 <int-e> Alpounet: is the function exported from the module?
06:40:00 <Alpounet> I expected something like "zMyFunctionName""
06:40:16 <quicksilver> your function probably got optimised away
06:40:20 <int-e> Alpounet: otherwise it might have gotten inlined everywhere ... and disappeared
06:40:24 <Alpounet> yep
06:40:24 <quicksilver> compile without optimisation, perhaps.
06:40:35 <Alpounet> quicksilver, I've just compiled with ghc -S foo.hs
06:40:56 <quicksilver> no idea.
06:41:02 <quicksilver> maybe some optimisations are always on ;)
06:41:13 <ksf> inlining, definitely.
06:41:22 <Alpounet> heh
06:41:24 <ksf> just export the function and you're going to be fine.
06:41:31 <Alpounet> ok thanks
06:42:04 <ksf> and you might want to cabal install ghc-core
06:42:08 <Alpounet> oh indeed, I have it now
06:42:16 <Alpounet> yeah it'll be much handie
06:42:17 <Alpounet> +r
06:45:04 <rmihael> wow. that's more then I was expecting :) thank you all!
06:54:12 <Jonno_FTW> is anyone here good with the Text.XHtml library?
07:01:48 <Jonno_FTW> well?
07:02:53 <MissPiggy> no
07:02:58 <MissPiggy> I don't even know about it
07:03:13 <Jonno_FTW> well I'm totally stuck about how its types work
07:03:26 <Jonno_FTW> and how to add to add attributes
07:04:10 <MissPiggy> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/html/Text-Html.html this one?
07:04:35 <Jonno_FTW> this one
07:04:37 <Jonno_FTW> http://hackage.haskell.org/packages/archive/xhtml/3000.2.0.1/doc/html/Text-XHtml-Strict.html#v%3Astyle
07:10:59 <Vanadium> whoops i accidentally installed happstack-server
07:11:06 <Vanadium> I was under the impression it was broken for 6.12
07:11:46 <Jonno_FTW> i got this far, but it doesn't compile at all
07:11:48 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17034#a17034
07:12:27 <Jonno_FTW> i get lots of type errors
07:13:17 <quicksilver> Jonno_FTW: (a) what errors, (b) what is "thediv" ?
07:13:51 <MissPiggy> thediv is a weird name from this library
07:13:54 <Jonno_FTW>  Couldn't match expected type `Html -> b'
07:13:56 <Jonno_FTW>         against inferred type `Html'
07:13:56 <quicksilver> (c) your code says Text.Html but the docs you pasted were Text.XHtml
07:14:08 <Jonno_FTW> i changed it to see if it would work
07:14:14 <Jonno_FTW> it didn't
07:14:25 <Jonno_FTW> the other error i get is
07:14:44 <quicksilver> oh it's called 'thediv' because 'div' is alread defined
07:14:47 <quicksilver> > div 5 2
07:14:47 <Jonno_FTW> Couldn't match expected type `Html'
07:14:48 <lambdabot>   2
07:14:49 <Jonno_FTW>        against inferred type `Html -> Html'
07:14:50 <Jonno_FTW> In the expression: thediv ! [theclass x]
07:14:52 <Jonno_FTW> In the definition of `dC': dC x = thediv ! [theclass x]
07:14:58 <Jonno_FTW> as in a <div> </div>
07:15:16 <quicksilver> 'thediv' is a function it requires a parameter
07:15:20 <quicksilver> the parameter is the contents, I think.
07:15:45 <theorbtwo> :t Text.XHtml.thediv
07:15:46 <lambdabot> Couldn't find qualified module.
07:16:00 <theorbtwo> :t Text.Html.thediv
07:16:01 <lambdabot> Couldn't find qualified module.
07:16:05 <theorbtwo> ...or not.
07:16:19 <quicksilver> so, for example, (thediv noHTML) is an empty div
07:16:32 <Jonno_FTW> ok
07:16:57 <quicksilver> (thediv (stringToHtml "words go here")) is a div with one sentence in it
07:17:26 <quicksilver> (thediv (stringToHtml "words go here")) ! theclass "bar" is a div with one sentence in it and a class, I think
07:17:27 <Jonno_FTW> i just want blank divs at the moment
07:17:30 <quicksilver> see if that's enough to get you going ;)
07:17:32 <Jonno_FTW> with classes and id's
07:27:49 <Jonno_FTW> ok
07:28:06 <Jonno_FTW> i got the functions sorted out to produce divs with id's and classes
07:28:37 <Jonno_FTW> dI x = (thediv noHtml) ! [identifier x]
07:28:51 <Jonno_FTW> but I get a type error when I try and use it
07:28:52 <Jonno_FTW> as in
07:28:59 <Jonno_FTW> pTop = (dC "header") << (dI "title")
07:30:51 <paulvisschers> mapLift :: (Monad m, MonadTrans f) => (m a -> m b) -> f m a -> f m b
07:30:59 <paulvisschers> Could this be a useful function?
07:31:18 <benmachine> isn't that just fmap?
07:31:18 <MissPiggy> could be
07:31:20 <benmachine> more or less
07:31:28 <benmachine> oh wait
07:31:32 <benmachine> no
07:31:41 <benmachine> because f m a = (f m) a
07:32:15 <paulvisschers> yeah not the same
07:32:33 <Absolute0> How can I express bitsOn using high-order functions? http://pastie.org/807637
07:32:55 <Absolute0> I tried using iterate but the output is not the input...
07:33:17 <int-e> Jonno_FTW: why <<? +++ instead should work.
07:33:20 <Absolute0> there needs to be an intermediate function between the next call to iterate
07:33:25 <Jonno_FTW> but I want nesting
07:33:53 <int-e> Jonno_FTW: oh.
07:34:08 <Jonno_FTW> <div id="1"><div id="2"></div></div>
07:34:57 <Absolute0> @src iterate
07:34:57 <lambdabot> iterate f x =  x : iterate f (f x)
07:34:58 <Jonno_FTW> any ideas?
07:35:03 <Absolute0> @where iterate
07:35:03 <lambdabot> I know nothing about iterate.
07:35:06 <int-e> Jonno_FTW: what is the type of dC?
07:35:12 <Jonno_FTW> String -> Html
07:35:42 <MissPiggy> hehe
07:35:45 <MissPiggy> lambdabot is confused
07:35:52 <int-e> Jonno_FTW: ok, then << is definitely the wrong type. Or dC should have type String -> Html -> Html
07:36:16 <int-e> Jonno_FTW: with the second argument giving the "inner" Html.
07:36:18 <benmachine> Absolute0: you could try unfoldr
07:36:25 <benmachine> :t Data.List.unfoldr
07:36:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:36:27 <Jonno_FTW> yep
07:37:16 <paulvisschers> The nice thing about mapLift is that you can use it to define for example MonadReader's local
07:37:27 <paulvisschers> local f = mapLift (local f)
07:37:33 <Absolute0> no unfoldl? :)
07:37:51 <benmachine> Absolute0: how would that even work :P
07:38:01 <benmachine> unless it'd just be reverse . unfoldr
07:38:03 <Absolute0> benmachine: why is the output a Maybe?
07:38:21 <int-e> Nothing encodes the end of the list
07:38:26 <benmachine> @src unfoldr
07:38:26 <lambdabot> unfoldr f b  = case f b of
07:38:27 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
07:38:27 <lambdabot>    Nothing        -> []
07:38:27 <Absolute0> i see
07:39:05 <Absolute0> let me play with unfoldr
07:39:48 <benmachine> > unfoldr (\x -> guard (x < 20) *> Just (x * 2)) 3
07:39:49 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
07:39:51 <benmachine> bah
07:39:56 <benmachine> > unfoldr (\x -> guard (x < 20) *> Just (x, x * 2)) 3
07:39:58 <lambdabot>   [3,6,12]
07:40:26 <Absolute0> :t guard
07:40:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:40:46 <Absolute0> guard is just filter on one item?
07:40:53 <benmachine> > guard False :: Maybe a
07:40:54 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
07:40:54 <lambdabot>    `a' is a rig...
07:40:56 <benmachine> fff
07:40:59 <benmachine> > guard False :: Maybe ()
07:41:00 <lambdabot>   Nothing
07:41:20 <ksf> guard is monadic
07:41:23 <ksf> :t guard
07:41:24 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:41:25 <benmachine> it's just a way of getting a Nothing when you need one
07:41:26 <Absolute0> I have to get back into the coding mindset, haven't code for over a month
07:41:29 <Absolute0> got very lazy..
07:41:30 <Absolute0> :(
07:41:51 <Absolute0> > guard (<0) Just 5
07:41:52 <lambdabot>   The section `GHC.Classes.< 0' takes one argument,
07:41:52 <lambdabot>  but its type `GHC.Bool.B...
07:41:58 <ksf> it's exactly like filter for Monad []
07:42:03 <Absolute0> > guard (<0) (Just 5)
07:42:04 <lambdabot>   The section `GHC.Classes.< 0' takes one argument,
07:42:04 <lambdabot>  but its type `GHC.Bool.B...
07:42:06 <benmachine> > guard (<0) >> Just 5
07:42:07 <lambdabot>   The section `GHC.Classes.< 0' takes one argument,
07:42:07 <lambdabot>  but its type `GHC.Bool.B...
07:42:11 <benmachine> bah
07:42:14 * benmachine silly
07:42:18 <benmachine> > guard (3<0) >> Just 5
07:42:20 <lambdabot>   Nothing
07:42:22 <int-e> guard . (<0) =<< Just 5
07:42:23 <benmachine> :P
07:42:31 <Absolute0> > guard (<0) [(Just 5), (Just (-5))]
07:42:32 <lambdabot>   The section `GHC.Classes.< 0' takes one argument,
07:42:32 <lambdabot>  but its type `GHC.Bool.B...
07:42:36 <benmachine> it is not filter!
07:42:41 <int-e> > guard . (<0) =<< Just 5
07:42:42 <lambdabot>   Nothing
07:42:49 <Absolute0> :t guard
07:42:50 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:42:59 <Absolute0> f*in kinds
07:43:02 <benmachine> it is either mzero or return ()
07:43:05 <ksf> it's not, but you use it in the same way if you do monadic lists
07:43:39 <int-e> > [0 | odd 1]
07:43:40 <lambdabot>   [0]
07:43:42 <temoto> guard to filter is like fmap to map?
07:43:46 <benmachine> no
07:43:50 <int-e> > guard (odd 1) >> return 0
07:43:51 <lambdabot>   No instance for (GHC.Show.Show (m t))
07:43:51 <lambdabot>    arising from a use of `M3854873960...
07:43:56 <ksf> fmap is the same as map and .
07:43:59 <int-e> > guard (odd 1) >> return 0 :: [Int]
07:44:00 <lambdabot>   [0]
07:44:17 <benmachine> guard takes a single boolean argument and uses it to generate a value
07:44:36 <benmachine> either a mzero or a return ()
07:44:37 <temoto> ksf, map is same as . ?
07:44:52 <ksf> :t (.)
07:44:53 <benmachine> the idea being that guard False >> a == mzero, and guard True >> a = a
07:44:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:44:55 <ksf> :t fmap
07:44:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:44:57 <int-e> filter f xs = xs >>= \x -> guard (f x) >> return x
07:44:58 <ksf> :t map
07:44:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:45:05 <ksf> ...uh, well, cale wasn't througout.
07:45:30 <ksf> ...but put in Functor [] and you get map's signature
07:45:34 <int-e> @pl filter f xs = xs >>= \x -> guard (f x) >> return x
07:45:34 <lambdabot> filter = (=<<) . (`ap` return) . (((>>) . guard) .)
07:45:57 <int-e> pointless use of monads :)
07:46:21 <Twey> Ow :Ã¾
07:46:25 <ksf> temoto, the easy way to understand is that both take a function a -> b and convert a parametrized type from a to b. that is, apply the function inside of the type.
07:46:30 <temoto> > (.) (==0) [0..2]
07:46:31 <lambdabot>   [True,False,False]
07:46:39 <temoto> FKME
07:46:46 <temoto> O_O
07:46:46 <ksf> > toUpper . "amazing, ain't it?"
07:46:48 <lambdabot>   "AMAZING, AIN'T IT?"
07:46:54 <MissPiggy> jij
07:46:57 <Jonno_FTW> calm down
07:47:07 <MissPiggy> > toUpper . "I am calm"
07:47:08 <lambdabot>   "I AM CALM"
07:47:10 <int-e> @type (.)
07:47:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:15 <medfly> it's fmap
07:47:18 * int-e blames Cale
07:47:25 <medfly> > map toUpper "I am calm"
07:47:26 <lambdabot>   "I AM CALM"
07:47:34 <Jonno_FTW> > toLower . "THIS WILL SUPPRESS MY RAGE AND NO ON WILL NOTICE"
07:47:35 <medfly> > toUpper `fmap` "I am calm"
07:47:35 <lambdabot>   "this will suppress my rage and no on will notice"
07:47:36 <lambdabot>   "I AM CALM"
07:47:49 <temoto> This is incredible.
07:48:18 <temoto> Why do we have 2 exactly identical fmaps?
07:48:36 <temoto> wait no
07:48:39 <ksf> . and map are specialized as not to confuse noobs
07:48:42 <temoto> :t (<$>)
07:48:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:48:46 <temoto> 3
07:48:46 <benmachine> :t (=<<) . (return .)
07:48:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b) -> m a -> m b
07:48:53 <benmachine> pfft close enough
07:49:01 <Absolute0> > takeWhile (>0) $ unfoldr (\x -> let lg2 = log2 x in Just (lg2, x-lg2)) (0xFFFF)
07:49:01 <int-e> @type (Control.Category..)
07:49:02 <lambdabot>   Not in scope: `log2'
07:49:03 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
07:49:24 <temoto> ksf, how . is specialized when it has exactly same signature?
07:49:28 <Absolute0> let log2 x = truncate $ logBase 2 $ fromIntegral i in takeWhile (>0) $ unfoldr (\x -> let lg2 = log2 x in Just (lg2, x-lg2)) (0xFFFF)
07:49:32 <Absolute0> > let log2 x = truncate $ logBase 2 $ fromIntegral i in takeWhile (>0) $ unfoldr (\x -> let lg2 = log2 x in Just (lg2, x-lg2)) (0xFFFF)
07:49:33 <lambdabot>   * Exception: not a number
07:49:39 <benmachine> log 0'd
07:49:41 <Absolute0> benmachine: anyways that doesnt work
07:49:50 <Absolute0> i get weird output
07:50:09 <Absolute0> 100 15's followed by 100 14's and so on
07:50:33 <Absolute0> the output should be [4,3,2,1]
07:51:47 <Absolute0> I'll just stick with the recursive version i have right now
07:52:11 <ksf> :t Prelude.(.)
07:52:12 <lambdabot> Not in scope: data constructor `Prelude'
07:52:16 <ksf> :t Prelude..
07:52:17 <lambdabot> parse error on input `Prelude..'
07:52:22 <ksf> arrrrgh
07:52:30 <MissPiggy> aaaaaaaghh!!!!
07:52:42 <MissPiggy> :t (Prelude...)
07:52:42 <lambdabot> Not in scope: `Prelude...'
07:52:55 <benmachine> :t (Prelude..)
07:52:56 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:53:06 <int-e> useless fact ... (.) (.) (.) (.) (.) (.) == (.) (.) (.) (.) (.) (.) (.) (.) (.) (.) ... (please don't look at me like that!)
07:54:35 <temoto> @src (.)
07:54:35 <lambdabot> (f . g) x = f (g x)
07:54:42 <benmachine> Absolute0: for me the version you pasted doesn't work
07:54:52 <temoto> Is this a fmap for ->?
07:54:57 <benmachine> (it didn't even compile initially)
07:55:03 <benmachine> temoto: yeah fmap for -> is (.)
07:55:13 <int-e> temoto: yep
07:55:15 <benmachine> > fmap (+1) (*2) $ 3
07:55:15 <ksf> Functor ((->)a), yes
07:55:16 <lambdabot>   7
07:55:22 <temoto> the world is turning inside out...
07:55:46 <benmachine> :t fmap
07:55:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:55:51 <benmachine> replace f with (t ->)
07:55:56 <benmachine> and it makes perfect sense
07:56:10 <temoto> benmachine, yeah that's how i came to it
07:56:33 <temoto> boy is there at least something special in haskell?
07:56:45 <benmachine> special?
07:56:45 <temoto> not defined in terms of fmap?
07:56:48 <benmachine> hah
07:57:01 <ksf> it's categories, all the way down.
07:57:13 <temoto> Until you reach turtles?
07:57:19 <int-e> > (=<<) (=<<) (=<<) (-) x
07:57:20 <lambdabot>   x - x - x
07:57:53 <lispy> int-e: cute
07:58:17 <temoto> :t (=<<) (=<<) (-) x
07:58:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
07:58:18 <lambdabot>       Expected type: m a
07:58:18 <lambdabot>       Inferred type: a
07:58:44 <benmachine> > ((=<<) =<<) =<< (-) $ x
07:58:46 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
07:58:53 <temoto> int-e, why it doesn't try to evaluate it?
07:58:54 * benmachine melts
07:59:07 <MissPiggy> > (x + 1)^2
07:59:08 <lambdabot>   (x + 1) * (x + 1)
07:59:14 <int-e> @type x
07:59:15 <lambdabot> Expr
07:59:26 <medfly> hahahaha
07:59:28 <int-e> temoto: that Expr type has a special Num instance
07:59:30 <MissPiggy> > x + 1 == 1 + x
07:59:31 <lambdabot>   False
07:59:36 <temoto> hm didn't know it work with expressions
07:59:44 <temoto> @type a
07:59:45 <lambdabot> Expr
07:59:46 <benmachine> Expr is very basic
07:59:52 <benmachine> doesn't really do anything numerical
07:59:59 <benmachine> just remembers what you did to it :P
08:00:13 <benmachine> which allows clever things like
08:00:23 <benmachine> > foldr (+) z [a, b, c]
08:00:24 <lambdabot>   a + (b + (c + z))
08:00:27 <temoto> Like int-e did.
08:00:41 <benmachine> mm
08:00:43 <temoto> Very nice.
08:01:29 <temoto> Another amazing day on #haskell.
08:01:33 <temoto> Thank you all.
08:03:23 <Absolute0> benmachine: sorry I was careless in illustrating what I wanted, here's the working version: http://codepad.org/m5RAMwig
08:03:51 <roconnor> MissPiggy: heh, eq for Expr should have an associative, commutative solver in it :D
08:03:56 <Absolute0> That's probably why unfoldr failed as well. :)
08:04:03 <benmachine> probably
08:04:09 <benmachine> roconnor: totally
08:04:38 <benmachine> roconnor: I tried to write something that simplified expressions in a group (as in algebra) once
08:04:45 <benmachine> but it was terribly crude
08:05:00 <benmachine> just tried every possibly association and looked for one that was arbitrarily less complicated
08:05:18 <benmachine> er, by which I mean less complicated as measured by an arbitrary scale
08:05:54 <MissPiggy> suppose it was a total order, and you always found a minimum: What is the proble?
08:06:26 <benmachine> I took ages doing it?
08:07:33 <Absolute0> > (takeWhile (>=0) $ unfoldr (\x -> let lg = truncate $ logBase 2 $ fromIntegral x in Just (lg, x - (2^lg))) 0xf)
08:07:34 <lambdabot>   [3,2,1,0]
08:07:37 <Absolute0> woot!
08:07:38 <Absolute0> :)
08:07:49 <benmachine> congrats :P
08:07:50 <Absolute0> how do I put the takeWhile inside the unfoldr?
08:08:03 <Absolute0> using the guard function..
08:08:03 <temoto> Please check if this is a proper instance of Functor for (.):
08:08:12 <temoto> instance Functor (t ->) of
08:08:25 <benmachine> s/of/where/
08:08:34 <temoto> fmap :: (a -> b) -> (t -> a) -> (t -> b)
08:08:52 <Absolute0> I doubt the unfoldr version is more effecient than the recursive one..
08:09:21 <Absolute0> seems like a lot of overhead
08:09:26 <roconnor> Absolute0: why are you using floating point numbers?
08:09:28 <benmachine> > unfoldr (\x -> let lg = truncate . logBase2 $ fromIntegral x in (lg, x - (2^lg) <$ guard (lg >= 0)) 0xf
08:09:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:09:33 <benmachine> fff
08:09:42 <Absolute0> roconnor: logBase requires it :(
08:09:55 <roconnor> :^)
08:09:56 <benmachine> > unfoldr (\x -> let lg = truncate . logBase2 $ fromIntegral x in (lg, x - 2^lg) <$ guard (lg >= 0)) 0xf
08:09:57 <lambdabot>   Not in scope: `logBase2'
08:10:03 <benmachine> fffffff
08:10:07 <benmachine> > unfoldr (\x -> let lg = truncate . logBase 2 $ fromIntegral x in (lg, x - 2^lg) <$ guard (lg >= 0)) 0xf
08:10:08 <Absolute0> logBase 2
08:10:09 <lambdabot>   [3,2,1,0]
08:10:13 <benmachine> right
08:10:37 <benmachine> Absolute0: roconnor has a point, though, it might be faster for small numbers just to iterate through the powers of two
08:10:56 <Absolute0> Well I am working with Word64's
08:11:00 <temoto> benmachine, besides 'where', is type correct?
08:11:07 <roconnor> using floating point numbers for an intereger problem is just wrong.
08:11:22 <roconnor> actually, using floating point numbers is always just wrong :D
08:11:24 <benmachine> temoto: (t ->) isn't valid Haskell (although imo it should be)
08:11:27 <zygoloid> erg0t: no, you can't write operator sections for types
08:11:31 <Absolute0> roconnor: there's isn't a Int version of logBase
08:11:34 <benmachine> you want ((->) t), otherwise it's fine
08:11:35 <zygoloid> s/erg0t/temoto/
08:12:14 <benmachine> Absolute0: the trouble is that floating-point is liable to introduce inaccuracy
08:12:22 <zygoloid> i guess the reason (t ->) isn't valid is because, if it were, people would expect (-> t) to be too
08:12:24 <temoto> Thanks. And implementation would be   fmap f g = f g  ? Intuition tells me i should swap arguments on either side of equal sign.
08:12:35 <Absolute0> should I make a lookup table for log2 from 2^0-2^64?
08:12:38 <benmachine> and equally liable to be just plain slow, at least compared to integer operations
08:12:48 <zygoloid> fmap f g = f . g, or fmap f g x = f (g x)
08:12:52 <Absolute0> benmachine: well thats why I truncate..
08:12:59 <pokoko222> how could u embed prolog in haskell?
08:13:07 <roconnor> @type (<$)
08:13:08 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:13:13 <temoto> zygoloid, but type says it takes 2 arguments.
08:13:23 <zygoloid> temoto: not for this instance :)
08:13:31 <benmachine> Absolute0: you could make a list of the first 64 powers of 2 and length . takewhile (<=) or something
08:13:48 <temoto> zygoloid, for this.  fmap :: (a -> b) -> (t -> a) -> (t -> b)
08:13:53 <Absolute0> benmachine: can you rewrite you previous example without using logBase ?
08:13:56 <benmachine> Absolute0: or, just iterate through the powers of two and do .&. tests in the first case
08:14:00 <benmachine> *first place
08:14:09 <zygoloid> temoto: that's the same as fmap :: (a -> b) -> (t -> a) -> t -> b.
08:14:19 <Absolute0> truncate.logBase seems more effecient
08:14:28 <Absolute0> I doubt they use a lookup table for logBase
08:14:37 <Absolute0> its probably some formula
08:14:41 <temoto> zygoloid, i see, thanks.
08:14:43 <Absolute0>  /2 :)
08:15:05 <benmachine> "some formula", indeed :P
08:15:27 <benmachine> well, you can do what you like
08:15:34 <roconnor> > (\x -> sequence (map testbit [0..bitsize x - 1]) x) 0xf
08:15:35 <lambdabot>   Not in scope: `testbit'Not in scope: `bitsize'
08:15:39 <roconnor> > (\x -> sequence (map testBit [0..bitsize x - 1]) x) 0xf
08:15:40 <lambdabot>   Not in scope: `bitsize'
08:15:44 <Absolute0> I'd like to do the most effecient If i can
08:15:46 <roconnor> > (\x -> sequence (map testBit [0..bitSize x - 1]) x) 0xf
08:15:47 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
08:16:00 <Absolute0> in this case, resorting to floats seems appropriate, for me at least
08:16:12 <roconnor> > (\x -> sequence (map (flip testBit) [0..bitSize x - 1]) x) 0xf
08:16:13 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:16:13 <lambdabot>    `Data.Bits.Bits a'
08:16:13 <lambdabot>      a...
08:16:31 <benmachine> well, integer calculations may surprise you in speed
08:16:32 <benmachine> may do.
08:16:34 <roconnor> > (\x -> map (testBit x) [0..bitSize x - 1]) 0xf
08:16:34 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:16:35 <lambdabot>    `Data.Bits.Bits a'
08:16:35 <lambdabot>      a...
08:16:42 <roconnor> > (\x -> map (testBit x) [0..bitSize x - 1]) (0xf::Word)
08:16:43 <lambdabot>   [True,True,True,True,False,False,False,False,False,False,False,False,False,...
08:16:47 <Absolute0> testing 64 bits compared to only those that are required...
08:17:00 <pokoko222> I read a book that claims Haskell is better then Prolog for NLP, how cool is that? I love Haskell even more
08:17:04 <benmachine> mm, but if say half the bits are set you're doing a similar amount of work
08:17:16 <Absolute0> I guess so.
08:17:17 <Absolute0> :)
08:17:30 <benmachine> if only one bit is set you're doing less with log
08:17:36 <benmachine> but
08:17:40 <benmachine> I am arguing this way too much
08:17:44 * osfameron writes a book that claims Perl is better than Haskell for NLP, even cooler! ;-P
08:17:46 <benmachine> you can do whatever you think is best :P
08:17:47 * osfameron runs away
08:18:02 * benmachine unsafePerformMurder osfameron
08:18:12 <temoto> pokoko222, all claims are uncool.
08:18:16 <Absolute0> benmachine: for my use case I will have only a couple of bits set at any time.
08:18:29 <Absolute0> only 1 most of the time
08:18:57 <pokoko222> temoto u dont think so?
08:18:58 <roconnor> Absolute0: you are aware of Data.Bits right?
08:19:07 <pokoko222> osfameron? prolog is better?
08:19:10 <benmachine> roconnor: he kind of imported it
08:19:16 <temoto> pokoko222, no, i *do* think that all claims are uncool.
08:19:33 <benmachine> temoto: that is quite a claim :P
08:19:41 <fasta> pokoko222, it is the algorithm or more interestingly procedure that matters.
08:19:42 <benmachine> (maybe that was the joke and I am ruining it)
08:19:45 <Absolute0> roconnor: yes, using testBit would require a loop of 64 iterations
08:19:45 <benmachine> (if so oops sorry)
08:19:49 <pokoko222> temoto arhh..nevermind
08:20:06 <fasta> pokoko222, and having lots of data, of course.
08:20:13 <osfameron> pokoko222: I have no idea tbh.  Is Prolog inherently better for logic programming for example, or does it just have mature, optimized libraries?
08:20:14 <roconnor> Absolute0: you could do faster with a binary search. :D
08:20:21 <dmwit> Ah, yes, programming languages: the ultimate in "us vs. them" arguments.
08:20:32 <temoto> pokoko222, proofs are cool. If they prove that haskell is better for something than something, that would be cool.
08:20:35 <int-e> > unfoldr (\n -> guard (n > 0) >> let b = n .&. (-n) in return (b, n-b)) 45054
08:20:36 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,8192,32768]
08:20:42 <Absolute0> roconnor: indeed :)
08:20:58 <roconnor> Absolute0: using shift plus a zero test
08:21:02 <benmachine> int-e: *gasp* sneaky
08:21:11 <Absolute0> > unfoldr (\n -> guard (n > 0) >> let b = n  .&. (-n) in return (b, n-b)) 0xf
08:21:12 <lambdabot>   [1,2,4,8]
08:21:16 <pokoko222> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17037#a17037 temoto here, educate yourself
08:21:20 <Absolute0> :)
08:21:51 <Absolute0> int-e: go work for google
08:21:52 <Absolute0> :)
08:21:52 <roconnor> :D
08:22:56 <Absolute0> 0xf (.&.) (-0xf)
08:22:59 <Absolute0> > 0xf (.&.) (-0xf)
08:23:00 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:23:00 <lambdabot>    `Data.Bits.Bits a'
08:23:00 <lambdabot>      a...
08:23:15 <Absolute0> > (0xf::Word64) (.&.) (-0xf::Word64)
08:23:16 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
08:23:16 <lambdabot>         against inferred type ...
08:23:17 <int-e> > 0xf .&. (-0xf)
08:23:18 <lambdabot>   Ambiguous type variable `t' in the constraint:
08:23:18 <lambdabot>    `Data.Bits.Bits t'
08:23:18 <lambdabot>      a...
08:23:30 <int-e> > 0xf .&. (-0xf) :: Int
08:23:31 <lambdabot>   1
08:24:14 <fasta> Does foo f xs ys = [(x,y)| x<- xs, y <- ys, y <= yy] have a name and a constant factor more efficient implementation somewhere ?
08:24:15 <Absolute0> > 1 .&. (-1)::Word64)
08:24:16 <lambdabot>   <no location info>: parse error on input `)'
08:24:18 <Absolute0> > 1 .&. (-1)::Word64
08:24:19 <fasta> ys*
08:24:19 <lambdabot>   1
08:24:29 <temoto> pokoko222, i was just picking on the word 'cool'. And i know there exists a NLP library in haskell for a few years.
08:24:29 <Absolute0> > 1 .&. (-1)::Int
08:24:30 <lambdabot>   1
08:24:40 <fasta> You can assume that xs and ys are sorted already.
08:24:40 <Absolute0> > 3 .&. (-3)::Int
08:24:41 <int-e> > drop 100 $ unfoldr (\n -> guard (n > 0) >> let b = n .&. (-n) in return (b, n-b)) (-1)
08:24:41 <lambdabot>   1
08:24:42 <lambdabot>   []
08:24:59 <roconnor> fasta: y <= x ?
08:25:08 <fasta> roconnor, er, yes.
08:25:10 <pokoko222> temoto it is not about libraries u ... it is about the paradigm, functional is more clear then the logic crap
08:25:23 <pokoko222> and you keep logic and sanity
08:25:25 <temoto> pokoko222, no doubt here.
08:25:27 <fasta> roconnor, and also f (x,y), instead of (x,y)
08:25:27 <int-e> > drop 100 $ unfoldr (\n -> guard (n /= 0) >> let b = n .&. (-n) in return (b, n-b)) (-1 :: Integer) -- whoops.
08:25:28 <lambdabot>   [1267650600228229401496703205376,2535301200456458802993406410752,5070602400...
08:25:46 <roconnor> fasta: this isn't not merge
08:25:51 <roconnor> no
08:25:52 <roconnor> ok
08:25:59 <int-e> one of the worse ways of generating an infinite list of the powers of 2 :)
08:26:19 <fasta> > iterate (*2) 1
08:26:20 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:26:30 <Twey> > drop 100 $ iterate (* 2) 1
08:26:31 <lambdabot>   [1267650600228229401496703205376,2535301200456458802993406410752,5070602400...
08:27:13 <fasta> > (iterate (*2) 1) !! 20
08:27:14 <lambdabot>   1048576
08:27:30 <Absolute0> what does drop do?
08:27:46 <int-e> > drop 5 [1..10]
08:27:47 <lambdabot>   [6,7,8,9,10]
08:27:51 <benmachine> applies tail that many times
08:27:53 <Twey> Drops a certain number of elements
08:27:53 <benmachine> sort of
08:27:58 <Twey> From the start of a list
08:28:00 <int-e> That dropped the first 5 elements of the list.
08:28:02 <roconnor> @src drop
08:28:02 <lambdabot> drop n xs     | n <= 0 =  xs
08:28:02 <lambdabot> drop _ []              =  []
08:28:02 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
08:28:04 <Absolute0> dropWhile...
08:28:05 <Twey> > drop 2 $ [10 .. 1]
08:28:06 <lambdabot>   []
08:28:08 <fasta> > drop 0 []
08:28:09 <lambdabot>   []
08:28:10 <Twey> > drop 2 $ [10, 9 .. 1]
08:28:11 <lambdabot>   [8,7,6,5,4,3,2,1]
08:28:12 <fasta> > drop 1 []
08:28:13 <lambdabot>   []
08:28:15 <Twey> Always throws me, that one
08:28:16 <roconnor> > tail []
08:28:16 <lambdabot>   * Exception: Prelude.tail: empty list
08:28:25 <Twey> â€˜drop 1â€™ is useful as a safe tail.
08:28:28 <Absolute0> I ran drop 100 [0..10000] and only noticed no change at the end of the output.
08:28:29 <fasta> So, the tail conjecture is false ;)
08:28:37 <Twey> Absolute0: That's because your input was too big.  :Ã¾
08:28:43 <Absolute0> right..
08:28:44 <Absolute0> :)
08:28:44 <benmachine> fasta: that's where the "sort of" comes in
08:29:04 <Absolute0> Twey: what character is that tongue?
08:29:08 <roconnor> listToMaybe is a safe head
08:29:20 <Absolute0> japanese p? :)
08:29:40 <Twey> Japanese â€˜pâ€™?  The Japanese don't even have separate consonants
08:29:44 <Twey> It's a lower-case thorn
08:29:52 <Absolute0> I was joking.
08:29:58 <Twey> Aha
08:30:06 <Absolute0> alt+?
08:30:13 <int-e> U+00FE
08:30:19 <Twey> Compose t h
08:30:25 <Absolute0> compose?
08:30:28 <Absolute0> what os?
08:30:40 <Twey> Anything with X11
08:30:53 <benmachine> Ã¾
08:30:53 <Absolute0> what key is that?
08:30:53 <benmachine> oic
08:30:57 <Absolute0> windows?
08:31:05 <Absolute0> i mean meta?
08:31:05 <Twey> I have it bound to caps lock
08:31:12 <benmachine> I have it right-super
08:31:15 <int-e> > text "\xFE"
08:31:16 <lambdabot>   Ã¾
08:31:18 <benmachine> for some reason
08:31:24 <benmachine> I can't remember how I set it though
08:31:34 <int-e> (wow, that worked :) )
08:31:44 <benmachine> why is compose stuff in weird places :(
08:32:00 <Absolute0> well super-L is bounded to my xmonad meta key so I can't use it.
08:32:01 <Absolute0> :(
08:32:22 <benmachine> use super-R?
08:32:23 <Twey> Option "compose:rwin", benmachine?
08:32:23 <Absolute0> \xFE
08:32:32 <Absolute0> benmachine: don't have one, laptop
08:32:38 <benmachine> Twey: I found a Multi_key in my xmodmap
08:32:43 <benmachine> is that anything to do with it?
08:32:46 <Twey> Ah, that'd do it
08:32:47 <Twey> Yeah
08:32:49 <benmachine> right
08:32:58 <Absolute0> let me rebind..
08:33:10 <benmachine> Absolute0: I have a laptop and I have one :P
08:33:21 <Absolute0> benmachine: aren't you special...
08:33:25 <benmachine> yes.
08:33:34 <Absolute0> I need to get a new laptop, mine is over 5 years old
08:33:45 <benmachine> I think mine is coming up to its second birthday
08:33:50 <Absolute0> r key is broken, slow as hell, battery is falling out :)
08:33:58 * Twey is considering trading his in for a netbook
08:34:03 <Absolute0> embarrasing
08:34:12 <Absolute0> are macbooks any good?
08:34:17 <Absolute0> they seem to expensive
08:34:22 <Twey> They're pretty nice
08:34:23 <fasta> Twey, are you getting the one with the accompanying magnifying glass?
08:34:24 <Absolute0> and mac os is limiting
08:34:31 <benmachine> I got mine on discount
08:34:32 <Twey> fasta: Haha, such a one exists?
08:34:37 <tromp> mine is 9 yrs old, still works great
08:34:40 <benmachine> and I haven't booted OS X in forever :P
08:34:43 <Twey> I was considering the 1000H
08:34:46 <fasta> Twey, things like this one are called jokes. ;D
08:34:51 <Twey> Oh
08:34:57 <Twey> I'm sorry
08:34:59 <Absolute0> how are the new thinkpads like?
08:35:05 <Twey> I think my humanity-emulation module failed
08:35:56 * Becquerel files a report on Twey Bugzilla
08:37:08 <Absolute0> rebinding the windows key didn't help
08:37:36 <Absolute0> Twey you code haskell on a macbook?
08:38:35 <Absolute0> I started an nzb session and firefox at the apple store, and it took 20 seconds to load...
08:38:47 <Absolute0> left the store right away :)
08:38:52 <tromp> I wish the thinkpad X100e had an atom cpu, and an SSD option...
08:39:18 <fasta> Absolute0, nzb session?
08:39:23 <Absolute0> sabnzbd
08:41:21 <Twey> Absolute0: No, I don't
08:41:31 <Twey> One of my friends has one
08:41:50 <Absolute0> I think you pay $500 extra just for the Apple sticker.
08:42:07 <Absolute0> more like $1000 extra actually.
08:42:13 <burp> o0
08:42:19 <burp> maybe even 10k$
08:42:22 <Twey> The hardware is nice quality, though
08:42:31 <Absolute0> nicer than thinkpad?
08:42:33 <benmachine> I like the magnetic power supply
08:42:37 <Twey> Pretty screens, and the keyboards are really nice
08:42:41 <Twey> Yeah, that's clever too
08:42:45 <benmachine> I tend to drop stuff a lot
08:42:50 <Twey> *nod*
08:42:51 <benmachine> probably saved me a few times :P
08:43:01 <burp>  
08:43:03 <Twey> Hehe
08:43:09 <Absolute0> but the OS is crap
08:43:14 <Absolute0> and installing linux is a pain
08:43:18 <benmachine> but the OS is replacable
08:43:24 <burp> it's not really crap
08:43:25 <Twey> Absolute0: It's not that bad, and it's pretty easy
08:43:34 <Twey> Beats Windows *shrug*
08:43:35 <benmachine> hmm I haven't tried installing linux recently
08:43:43 <Twey> Linux installers are really friendly nowadays
08:43:53 <Twey> The ones that intend to be, anyway
08:43:55 <Absolute0> Twey: linux is made for windows pc's..
08:43:58 <temoto> Absolute0, Linux OS is not crap. It's the userland built on top that sucks.
08:44:00 <benmachine> Twey: mm, but when I got this laptop a few of them didn't work
08:44:01 <Twey> Absolute0: No it isn't
08:44:16 <Absolute0> the mac versions are awkard
08:44:21 <Absolute0> and need more configurations
08:44:25 <ksf> temoto, how is xmonad and zsh crap?
08:44:28 <benmachine> I think I ended up installing archlinux from virtualbox or some such
08:44:30 <burp> erm..
08:44:31 <Twey> There's no such thing as a â€˜Mac versionâ€™
08:44:38 <Absolute0> temoto: Mac OS not linux
08:44:38 <burp> you think there is special mac hardware?
08:44:38 <Twey> Linux is Linux
08:44:56 <Twey> There is some special Mac hardware, but I think everything handles it nowadays
08:45:06 <burp> not talking of ppc ages
08:45:09 <Twey> It's not like it's a completely different system, just a few different keys on the keyboard
08:45:09 <MissPiggy> "Hopefully, you are aware that OS X is Unix with a windowing system and design that is far superior to any Linux distro."
08:45:10 <Absolute0> Twey: maybe not nowadays, there used to be a powerpc debian iso..
08:45:20 <MissPiggy> http://discussions.apple.com/thread.jspa?threadID=1667139 lol
08:45:21 <Twey> Absolute0: Macs don't even use PPC any more
08:45:33 <burp> and ppc doesn't mean mac necessarily
08:45:36 <temoto> ksf, i'm not saying for all software. xmonad has no friendly configurator, btw.
08:45:37 <Twey> Yeah
08:45:49 <Absolute0> MissPiggy: i think its Munix
08:45:49 <ksf> it does.
08:45:52 <ksf> it's all haskell
08:45:56 <ksf> very friendly.
08:46:02 <Twey> +1
08:46:10 <benmachine> heh
08:46:12 <temoto> ksf, no i mean human friendly, not programmer friendly.
08:46:13 <Absolute0> MissPiggy: os x is superior to xmonad?
08:46:23 <ksf> and programmers aren't humans?
08:46:25 <Twey> temoto: If you're a human, you wouldn't be using it.  Obviously.
08:46:36 <Twey> Sheesh.  These kids and their crazy logic.
08:47:06 <temoto> I mean general computer user, okay?
08:47:26 <ksf> mh does bluetile come with a nice configurator?
08:47:36 <Absolute0> the iPad is another rip off, just a bigger i touch
08:47:52 * benmachine uses general computers
08:47:58 <Absolute0> can't install regular apps on it
08:48:07 <ksf> ...anyway, the worst part of the linux desktop is all that gnome/kde menu bloat
08:48:10 <Absolute0> they have to be special ipad/iphone apps
08:48:17 <Twey> The iPad can get stuffed until I can run multiple apps at once
08:48:20 <Absolute0> ksf: don't use gnome/kde
08:48:25 <ksf> I don't.
08:48:39 <temoto> ksf, that was exactly my point about userland crap.
08:48:42 <ksf> well I _do_ use konsole
08:48:50 <Absolute0> shame on you!
08:48:57 <temoto> and not only menu
08:49:00 <Absolute0> gnome-terminal is better
08:49:05 <Absolute0> but urxvt is even better
08:49:08 <Absolute0> :-P
08:49:12 <Absolute0> "better"
08:49:13 <Twey> ksf: No, apparently BlueTile does not come with a nice configurator
08:49:21 <Twey> urxvt hurts
08:49:31 <Twey> I'd rather not limit myself to XIM, thank you
08:50:03 <Absolute0> hurts?
08:50:11 <ksf> er yes. I just realized that we don't have a proper gui kit yet, and gluing gtk or qt onto xmonad would be herecy.
08:50:18 <Twey> Heh.
08:50:20 <leimy_> What's the name of the Haskell group that wants to help get support for commercial entities interested in using it?
08:50:28 <Twey> leimy_: CUFP
08:50:29 <leimy_> oh
08:50:35 <leimy_> Industrial Haskell ...?
08:50:35 <Twey> Commercial Users of Functional Programming
08:50:37 <Twey> That one?
08:50:39 <Twey> Oh
08:50:42 <leimy_> Oh that's a different one
08:50:42 <ksf> true theme support might be cool though.
08:50:42 <leimy_> :-)
08:50:44 <dmead> oy
08:50:48 <Twey> Heh
08:50:52 <Absolute0> how successful is CUFP?
08:50:52 <benmachine> Twey: I googled XIM and I got "We are a band from Norfolk featuring melodeon, hurdy gurdy, bagpipes, flute and bass."
08:50:55 <Twey> http://industry.haskell.org/
08:50:59 <ksf> that is, don't just change colours, but specify IO actuions that paint stuff.
08:51:02 <Twey> benmachine: Hahaha
08:51:04 <Twey> Nice
08:51:08 <benmachine> I wouldn't want to be stuck with them either?
08:51:09 <Vanadium> Hm, IO auctions.
08:51:11 <leimy_> Well I'm in a new company, and I think they're considering contracting out the engineers.  I had suggested that some of us might be interested in doing that kind of work, but the money had to be right :-)
08:51:25 <ksf> hey u and i are right next to each other
08:51:37 * benmachine snuggles up next to ksf 
08:52:23 <Vanadium> ksf: Just makes me imagine a load-balancing mechanism where processes post IO actions and then auction them off between nodes that bid the spare resources to run them
08:53:39 <ksf> Vanadium, you just made me think of an excuse to hook up my ultra.
08:55:17 <ksf> I also know a guy who has three C64. clustering those might be fun.
08:58:24 <leimy_> Hmmm well we might not be able to join the IHG just yet, but I think I can convince some people to perhaps later get us involved
08:58:31 <leimy_> we're very "start-uppy" at the moment.
08:58:53 <leimy_> We might be hiring soon though.
08:59:04 <leimy_> in the Seattle area and in San Diego, CA
08:59:52 <Saizan> leimy_: were you thinking of Well Typed ?
09:00:12 <Absolute0> leimy_: what sort of projects do you work on?
09:00:18 <leimy_> Saizan: Not really, I was thinking of the industrial haskell group :-)
09:00:25 <ksf> conal, re your IO post, did you already stumble across http://patch-tag.com/r/np/safe-lazy-io/snapshot/current/content/pretty/README ?
09:00:37 <ksf> it's functor, not monad based.
09:00:53 <pokoko222> anyone has read syntactic structures from chomsky?
09:00:54 <leimy_> Absolute0: We build datacenter stuff.  We have a container product, and we have managed rack hardware.
09:01:04 <leimy_> There's a good bit of Erlang involved at the moment
09:01:06 <conal> ksf: what IO post?
09:01:16 <leimy_> and in one container configuration there's a Haskell driver as well.
09:01:23 <ksf> http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/
09:01:36 <leimy_> It's a lot easier to deal with the concurrency in these languages :-)
09:01:40 <Twey> Is this the one about functional programming using enzymes?
09:01:47 * trofi^w wonders if dons has read ask for sqlite bump
09:01:48 <conal> ksf: ah, thx.  no i haven't seen safe-lazy-io.  will check it out.
09:03:14 <conal> ksf: does it have precise & tractable denotation?
09:04:38 <ksf> if by precise & tractable you mean way easier than monadic lazy IO, definitely.
09:05:48 <leimy_> Oh and we're not using stuff like Scala because the systems are relatively small, so Haskell and Erlang work out to good enough of a memory footprint in most cases vs big JVM projects.
09:06:01 <ksf> that is, the real world doesn't nuke all the effort as easily because resources are managed sanely.
09:06:11 <Twey> Good article, conal.  Typo â€˜simleâ€™, FYI.
09:06:25 <conal> Twey: thx & thx.
09:06:35 <Twey> I think Watts has â€˜beliefâ€™ and â€˜faithâ€™ backwardsâ€¦
09:07:02 <Twey> The modern definition of â€˜faithâ€™ is absolute trust in a particular idea, without evidence, to the exclusion of all else
09:07:39 <ksf> or even consiously disregarding contrary evidence.
09:07:57 <jmcarthur> that's the "pop" definition of faith, i think
09:08:15 <paulvisschers> @djinn (m a -> m b) -> m [a] -> m [b]
09:08:15 <lambdabot> Error: Undefined type []
09:08:18 <conal> Twey: yes, i also notice that conditional def being more popular than the unconditional def that watts uses.  i prefer watts's.
09:08:24 <paulvisschers> @djinn :: (m a -> m b) -> m [a] -> m [b]
09:08:24 <lambdabot> Invalid command
09:08:25 <Twey> ksf: Hence â€˜to the exclusionâ€¦â€™
09:08:50 <paulvisschers> @djinn :: (m a -> m b) -> m (Either e a) -> m (Either e b)
09:08:50 <Twey> conal: I agree
09:08:50 <lambdabot> Invalid command
09:08:51 <conal> ksf: no, i don't mean just easier than monadic IO.  i mean (a) a precise denotational/math model, and (b) a tractable one.
09:08:56 <paulvisschers> @djinn (m a -> m b) -> m (Either e a) -> m (Either e b)
09:08:57 <lambdabot> -- f cannot be realized.
09:09:26 <paulvisschers> @djinn (Monad m) => (m a -> m b) -> m (Either e a) -> m (Either e b)
09:09:26 <lambdabot> -- f cannot be realized.
09:09:44 <Saizan> paulvisschers: djinn doesn't handle monads anyhow
09:10:11 <paulvisschers> Saizan: ok, gues I'll figure it out myself
09:10:48 <ksf> conal, I'd dare to say yes, If I had any qualification to judge it.
09:13:03 <Vanadium> Installing library in .cabal/lib/happstack-server-0.4.1/ghc-6.12.1; Registering happstack-server-0.4.1...; then Could not find module `Happstack.Server' in ghci
09:13:06 <Vanadium> What is going wrong :<
09:13:27 <conal> ksf: i guess to find out, we'd start by formulating a precise model, then check that it's adequate, and then evaluate its simplicity.
09:14:49 <Saizan> Vanadium: did you restart ghci?
09:15:03 <Vanadium> yes
09:15:07 <Vanadium> I only started it afterwards, anyway
09:15:46 <MissPiggy> hi conals
09:16:15 <Saizan> Vanadium: what does "ghc-pkg find-module Happstack.Server" says?
09:16:34 <conal> MissPiggy: hi
09:17:36 <Vanadium> Saizan: .ghc/x86_64-linux-6.12.1/package.conf.d lists happstack-server-0.4.1, but it also complains about broken packages, which seem to be haskell-src-exts missing cpphs as its dependency
09:18:31 <Saizan> Vanadium: ah, run ghc-pkg check, maybe happstack-server is involved in the breakage
09:18:36 <b0fh_ua> Hi there! Can somebody please advice, how to install HXT with cabal? I am getting the error: http://pastebin.com/d57c09a14 . Looks like I have to upgrade something - but what exactly and how?
09:18:53 <Vanadium> ghc-pkg check only referes to haskell-src-exts-1.6.1 and cpphs-1.9-cfa8ec53fc2f4ba31ee6e7eda9c1e2e6
09:19:22 <Vanadium> I installed the latter and now ghc-pkg check is silent
09:20:17 <Saizan> Vanadium: are you sure your ghci matches your ghc/ghc-pkg ? i.e. that you are not confusing two ghc installations ?
09:20:23 <MissPiggy> conal I couldn't write my program even though I worked really hard trying all different things for weekr
09:20:25 <MissPiggy> weeks
09:20:40 <Saizan> b0fh_ua: you either have to upgrade your GHC or pick an older version of base
09:20:52 <Vanadium> They all seem to give the same version number and are all from /usr/bin
09:21:35 <Saizan> Vanadium: and you're running ghci and ghc-pkg with the same user?
09:21:39 <b0fh_ua> Saizan: unfortunately there's no new version of GHC available in FreeBSD ports for now. How can I get older version of base?
09:21:45 <Vanadium> Yes
09:21:55 <Vanadium> Same user as I cabal-installed with
09:22:18 <Saizan> b0fh_ua: older version of HXT i meant
09:22:57 <Saizan> b0fh_ua: cabal install hxt-8.3.2
09:23:57 <Saizan> Vanadium: weird, you aren't running ghci from inside happstack-server's source tree right? can you paste the complete error?
09:24:12 <jho> I'm new to Haskell and I'm trying to create a program that steps through files A and B. A contains everything that's in B, plus some random junk inbetween those lines. I want to collect and print the differing lines. I've got this far, and I can't figure out what's wrong: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17038#a17038
09:24:25 <b0fh_ua> Saizan: let me try that
09:24:56 <b0fh_ua> Saizan: seems to start doing something :)
09:24:57 <kmc_> jho: first of all, it's a serious code smell to be using length, head, and tail together
09:25:03 <ksf> jho, diff?
09:25:06 <kmc_> head especially is just bad in most cases
09:25:10 <kmc_> what you probably should do is pattern matching
09:25:24 <ksf> and don't use length if you want to use null
09:25:24 <kmc_> getDiff [] [] tmp = ...;  getDiff (x:xs) (y:ys) tmp = ...
09:25:30 <conal> MissPiggy: Drag :(
09:25:33 <kmc_> don't use length at all; use pattern matching
09:25:38 <Vanadium> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17039#a17039
09:25:57 <kmc_> jho: anyway, your error is using map putStrLn
09:26:02 <kmc_> you should probably use mapM_ putStrLn
09:26:07 <conal> MissPiggy: Perhaps Polya's advice would help: "If you can't solve a problem, then there's an easier problem you can solve: find it."
09:26:15 <kmc_> what you've produced with "map" is a list of IO actions, rather than a single IO action
09:26:22 <kmc_> that's what the type error is telling you
09:26:28 <jho> Okay, thanks :)
09:26:42 <ksf> conal, if there's a problem you can't solve, search a harder one you can solve.
09:26:50 <kmc_> Applying the function "putStrLn" does not do any IO.  It returns a "recipe" which can be used to do IO later
09:27:04 <kmc_> And so a list of such recipes is not useful (here) until you glue them together into a single recipe
09:27:11 <Saizan> Vanadium: oh, last thing that comes to mind, ghc-pkg field happstack-server library-dirs will give you a path, you should check that there's a Happstack/Server.hi in it
09:27:28 <ksf> piecing together solutions doesn't necessarily yield the best answer
09:27:41 <Vanadium> There is :(
09:28:07 <jmcarthur> ksf: why not?
09:28:36 <ksf> because you fail to notice that your problem is just a specialisation of something generic
09:28:39 <conal> ksf: you think Polya is recommending piecing together solutions in that quote?
09:28:59 <ksf> conal, that, or simplifying
09:29:31 <jmcarthur> ksf: maybe i missed the context. lemme scroll up past all these stupid netsplit things...
09:29:54 <ksf> jmcarthur, nope, conals polya quote is the context
09:30:02 <jmcarthur> no, must have been said while i was split
09:30:04 <MissPiggy> I tried to find subproblems and solve them but I could not
09:30:05 <jmcarthur> oh
09:30:27 <b0fh_ua> Saizan: http://pastebin.com/d149a4e19 - for some reason it doesn't build, may be you could advice?
09:30:47 <jmcarthur> ksf: i either disagree with your interpretation of the quote or with your disagreement with the quote :P
09:31:03 <kmc_> jho: you also have type errors, mixing String and [String]
09:31:21 <conal> MissPiggy: could not which -- find or solve?
09:31:25 <ksf> I only disagree with that quote if it's considered to be the whole truth
09:31:31 <MissPiggy> solve
09:31:41 <MissPiggy> I could not even write any of the simpler bits
09:31:52 <Vanadium> Saizan: Trying to import it in a source file and compiling that with ghc -v indicates that happstack-server "is unsuable due to missing or recursive dependencies"
09:31:57 <kmc_> jho: getDiff (tail a) b [tmp, (head a)]
09:31:57 <Vanadium> I suppose I will try installing them manually
09:32:12 <Saizan> b0fh_ua: it seems you need --constraint="tagsoup == 0.6"
09:32:13 <kmc_> [tmp, (head a)] is invalid because tmp :: [String] and (head a) :: String
09:32:22 <jho> kmc_: Yeah, I just figured that out myself :)
09:32:26 <jho> Thanks anyways
09:33:38 <Vanadium> Except I already have those. Hm.
09:33:43 <conal> MissPiggy: Try iterating Polya's advice.
09:33:52 <b0fh_ua> Saizan: okay, trying that
09:34:42 <b0fh_ua> Saizan: that worked )
09:34:44 <jmcarthur> conal: the challenge of Polya's advice is that it introduces a new problem of how to sufficiently decompose the problem, which may not actually be any simpler
09:34:45 <b0fh_ua> thanks a lot
09:34:52 <Saizan> np
09:35:25 <jmcarthur> conal: generally i agree with the advice, but for some people it is as difficult as the original problem
09:35:58 <MissPiggy> I don't know what my problem is
09:36:01 <conal> jmcarthur: sure.  and i'm not so sure polya's advice is restricted to decomposing the problem.
09:36:20 <zygoloid> jho: completely untested, but here's a refactoring of your code with the bugs hopefully fixed: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17038#a17040
09:36:30 <jmcarthur> finding simpler problems reminds me again of the quote: "I did not have time to write you a short letter, so I wrote you a long one."
09:36:44 <MissPiggy> who wrote that
09:36:52 <MissPiggy> grothendeick?
09:36:53 <jmcarthur> MissPiggy: nobody knows for sure
09:37:01 <MissPiggy> or lagrange
09:37:01 <zygoloid> Blaise Pascal, i heard :)
09:37:03 <jho> zygoloid: Thanks :)
09:37:03 <kmc_> jho, zygoloid: heh, i did something similar: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17038#a17041
09:37:41 <conal> jmcarthur: sometimes i simplify so as to improve my own familiarity with the neighborhood of my original problem.  warm-up.
09:37:42 <jmcarthur> MissPiggy: many believe it was blaise pascal, apparently
09:37:43 <kmc_> jho: note that my version adds the element 'a' onto the *front* of the tmp list, and then reverses it in one go
09:37:56 <kmc_> this should be more efficient than sticking the element onto the end each time
09:38:00 <zygoloid> whereas mine builds the list on the fly
09:38:38 <jmcarthur> conal: i'm kind of playing devil's advocate here.
09:38:41 <Saizan> zygoloid++
09:38:49 <ksf> conal, jmcarthur, http://video.google.de/videoplay?docid=1607386732227802988    25:00 onward
09:38:52 <conal> jmcarthur: and yeah -- decomposition takes insight.
09:39:03 <Saizan> for being lazier :)
09:39:09 <kmc_> i kept the tail-recursive form -- but tail recursion does not really mean the same thing under a lazy evaluation strategy
09:39:15 <jho> Am I correct in assuming that bb@(b:bs) means that the whole list can be used as bb, and b and bs are the head and tail of that?
09:39:19 <kmc_> yes
09:39:22 <dolio> I know I once managed to prove something I needed (but couldn't figure out) in Agda by instead writing down a more general theorem, and proving that. I don't remember why the more general version was easier to prove, though.
09:39:22 <jho> Cool
09:39:33 <kmc_> zygoloid's "non tail-recursive" version is probably more space efficient than mine
09:39:41 <kmc_> whereas the opposite would be the case in a strict-evaluation language
09:39:42 <Saizan> dolio: that's common for me
09:39:44 <zygoloid> Saizan: what about the other people in the channel who didn't offer a solution at all? :)
09:39:48 <jmcarthur> dolio: i find that general things are almost always easier to prove
09:39:57 <jmcarthur> it removes variables
09:40:00 <dolio> But in that case, I guess the more general problem would by definition be an easier problem?
09:40:07 <Saizan> yeah, there are less things to try :)
09:40:25 <MissPiggy> there's two kinds of more-general for proofs
09:40:25 <MissPiggy> (at least0
09:40:40 <jmcarthur> it's like how djinn has an easier time with fully polymorphic functions
09:40:42 <Saizan> "more general" usually means that you've a stronger result, no?
09:40:45 <kmc_> jho: the syntax there is an "at pattern".  the pattern x@p matches anything matched by the pattern p, binding the same things that p does, and additionally binds x to the entire value so matched
09:40:48 <conal> jmcarthur: might be devil's advocate for something polya wasn't saying here.
09:41:32 <jmcarthur> conal: perhaps you, ksf, and i all walked away with something different. do you happen do know the context which that quote was placed in? i do not
09:41:36 <jmcarthur> *happen to know
09:41:51 <MissPiggy> anyway, it is utterly disappointing and completly bizarre that I could not even succed in simple programming tasks after spending so many years learning all these things
09:41:55 <conal> jmcarthur: no, i don't.
09:41:59 <Saizan> i guess it depends on how the quantifiers/-> nest
09:42:02 <zygoloid> , let foo x@(drop 5 -> y) = (x, y) in f "hello world"
09:42:06 <conal> MissPiggy: i bet it is :(
09:42:19 <zygoloid> preflex: seen lunabot
09:42:19 <preflex>  lunabot was last seen on #haskell 4 days, 10 hours, 19 minutes and 32 seconds ago, saying:  31
09:42:25 <jmcarthur> MissPiggy: what is your definition of simple?
09:42:47 <MissPiggy> I don't tend to have definitions for words
09:42:54 <MissPiggy> I know what it means though
09:43:00 <jmcarthur> perhaps it is not as simple as you are making yourself believe
09:43:35 <ksf> try my advice for code design: think of a way to solve it, throw it away, think of another, and then a third one. then decide which one gets too esoteric, and take the previous one.
09:43:44 <MissPiggy> You might say that I have spent years deluding myself to the point where I think everything is trivial, even though I do have the skill to actually produce anything
09:44:06 <MissPiggy> do not***
09:44:20 <ksf> MissPiggy, http://xkcd.com/224/
09:45:06 <quicksilver> MissPiggy: if you have succeeded in convincing yourself you could probably convince other people. Therefore the magic 8-ball recommends you take a career as a life coach.
09:45:41 <ksf> now there we got an excelent definition of "faith"
09:46:37 <Vanadium> If I understand this right, hslogger depends on base 3.*, stuff depends on hslogger, therefore I cannot use stuff.
09:46:40 <Vanadium> Oh well.
09:46:46 <burp> lol
09:46:58 <Saizan> Vanadium: that shouldn't be the case
09:47:40 <Saizan> Vanadium: under recent ghc's base-3 is just re-exporting things from base-4, so they should be usable in the same project
09:47:56 <conal> ksf: :)  i love that xkcd
09:48:24 <Saizan> Vanadium: unless you've done something like compiling your own base-3, but i'm not even sure if that's possible
09:48:34 <Vanadium> I should not have done that
09:48:41 <Vanadium> It says hiding package base-3.0.3.2 to avoid conflict with later version base-4.2.0.0
09:49:02 <Saizan> what's saying that?
09:49:25 <Vanadium> ghc -v trying to compile something that involves import Happstack.Server
09:49:26 <Vanadium> Let me paste
09:49:34 <Saizan> can you paste ghc-pkg list too?
09:50:01 <Saizan> ah, maybe you need to clean the .hi files in your tree
09:50:37 <Vanadium> Do you mean my .cabal tree?
09:50:48 <Saizan> no
09:50:55 <Vanadium> I do not have a foo.hi here
09:51:01 <Saizan> ah, ok
09:52:13 <Vanadium> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17042#a17042
09:52:28 <MissPiggy> I don't think of any simpler problem I can approach instead
09:52:37 <MissPiggy> it's not clear at all what I should do
09:54:35 <Saizan> Vanadium: ah, you've network-2.2.1.7 in both the global and user db, that's known to cause problems
09:57:02 <Saizan> i wonder why ghc-pkg check doesn't catch that
09:59:47 <Vanadium> Saizan: That was apparently pulled in by cabal install when I try to install happstack things
10:04:55 <Saizan> Vanadium: i'd try unregistering the user one and see what breaks, anyway
10:05:07 <Vanadium> Apparently everything that wants network
10:05:21 <Vanadium> unregistering network would break the following packages: happstack-server-0.4.1 sendfile-0.6.1 hspread-0.3.3 happstack-data-0.4.1 happstack-util-0.4.1 HAppS-Util-0.9.3 hslogger-1.0.7 SMTPClient-1.0.1 HTTP-4000.0.9
10:05:45 <MissPiggy> theres' TWO poet bots in #poetry
10:06:03 <Saizan> that message is not guaranteed to be accurate :) however you can backup ~/.ghc and try
10:06:15 <Vanadium> I tried and now ghc-pkg lists those as missing dependencies
10:07:53 <Saizan> Vanadium: i'd try to see if cabal install --dry-run -v happstack-server wants to install a new network, and why
10:08:07 <Vanadium> In order, the following would be installed:
10:08:08 <Vanadium> network-2.2.1.7 (reinstall) changes: parsec-3.0.1 -> 2.1.0.1
10:09:50 <Saizan> cabal install --dry-run -v happstack-server --constraint="parsec == 3.0.1" ?
10:10:03 <mmmulani> how can I add Eq to a user defined class?
10:10:17 <Saizan> mmmulani: you mean an user defined type?
10:10:27 <mmmulani> Saizan: yeah, sorry
10:10:46 <Vanadium> cabal: cannot configure happstack-server-0.4.1. It requires parsec <3
10:10:49 <Vanadium> Oh.
10:11:07 <Saizan> mmmulani: data YourType = ... deriving Eq
10:11:24 <Saizan> mmmulani: that's the easiest way, you get structural equality
10:11:41 <mmmulani> ouuuu, thanks
10:11:54 <Saizan> mmmulani: otherwise you can do "instance Eq YourType where x == y = ..."
10:13:41 <Saizan> Vanadium: if the network in the userdb used parsec2 you might want to restore the old .ghc and nuke the global one
10:14:23 <sinelaw> hey all
10:26:01 <mreh> is there somekind of array based map?
10:26:29 <mreh> or, are there map combinators?
10:26:47 <Vanadium> Saizan: That about did it, thanks. The global network was my distribution's, I kind of assumed it was ghc shipping it for some reason
10:31:48 <mreh> I'm just going to learn how to use the Array interface
10:33:20 <Saizan> Vanadium: np, unfortunately it took so long to find the problem..
10:40:33 <HaskellLove> anyone has implemented a knowledge base in haskell?
10:40:58 <aavogt> what is a knowledge base?
10:41:18 <aavogt> is such a thing different from a wiki?
10:41:46 <HaskellLove> knowledge base like in AI literature
10:41:50 <sm> yes: http://www.catamorphism.net/fpb/haskref.cgi
10:42:03 <yrlnry> dogomorphism
10:43:04 <HaskellLove> wow sm thanks amazing site
10:43:17 <sm> yes, it's great
10:43:21 <zygoloid> meerkatamorphism?
10:43:32 <HaskellLove> aavogt to get back to your wiki comparison, kinda makes sense
10:43:49 <HaskellLove> you querry a knowledge base, it must be consistent, hmmm what else...
10:44:05 <HaskellLove> u update it or delete items from it and still needs to stay consistent
10:44:18 <HaskellLove> and last thing it has ti infer things
10:44:22 <HaskellLove> i guess wiki cant do that
10:44:54 <aavogt> infer things in what sense? just searching?
10:45:22 <aavogt> or it has   A => B,  B => C somewhere else, and it should tell you  A => C?
10:46:01 <aavogt> maybe categories of pages sort work like that...
10:47:17 <HaskellLove> sm actually... where are the papers?
10:47:27 <sm> clicky ?
10:47:35 <sm> I know I read some there
10:48:00 <sm> entries have a paper and or info link
10:48:09 <HaskellLove> aavogt yes, in that sense, transitivity and stuff
10:48:36 <kuribas> My code only compiles when don't write a type signature on optimal_break: http://paste.lisp.org/display/94308  Does anyone understand why?
10:48:53 <HaskellLove> there are links to sites like this http://www.cs.nott.ac.uk/~nhn/TFP2006/ but i see no papers yet
10:48:55 <kuribas> ghci gives me a strange signature that doesn't even work!
10:49:06 <yrlnry> what does it give you?
10:49:12 <yrlnry> snd what are you trying to write?
10:49:41 <HaskellLove> sm lot of links are empty
10:49:45 <mauke> are best_break and last_break even valid?
10:50:00 <sm> sounds like a bug
10:50:03 <kuribas> mauke: Why wouldn't they be?
10:50:05 <mauke> how is it going to deduce the other type parameters?
10:50:19 <HaskellLove> aavogt i guess i can implement predicate logic and have the inference engine?
10:50:38 <HaskellLove> sm not bug, just links to sympsiums and stuff rather then pdfs
10:50:43 <kuribas> mauke: I'll show you the whole file...
10:51:10 <sm> HaskellLove: I would think the "paper" link, if it exists, should lead to the paper
10:51:41 <zygoloid> kuribas: it's not possible to give a type signature for optimal_break
10:51:47 <kuribas> http://paste.lisp.org/display/94308#1
10:51:56 <HaskellLove> sm i opened at least 20 that have no papers, just links to symposiums
10:52:03 <kuribas> zygoloid: then why does it compile?
10:52:06 <kmc_> maybe a fundep is wanted here?
10:52:14 <zygoloid> kuribas: because the compiler internally /can/ give one
10:52:19 <sm> right.. look for the ones with (paper) underneath
10:52:38 <kuribas> zygoloid: I didn't know that was possible...
10:52:40 <zygoloid> kuribas: the problem is evident if you reduce it to 'optimal_break = last_break'. what's the type of it now?
10:52:44 <sm> maybe filter by type will help
10:53:46 <aavogt> kuribas: this compiles: http://paste.lisp.org/display/94308#2
10:53:49 <kuribas> zygoloid: I would think 'BreakPoint p a bk => bk'
10:53:55 <zygoloid> kuribas: "optimal_break :: forall param a bk. (BreakPoint param a bk) => bk" is wrong, because it doesn't allow GHC ot deduce that 'param' and 'a' in that declaration are the same as in last_break.
10:54:31 <HaskellLove> sm and there are links to "books" basically links to buy yourself one http://web2.comlab.ox.ac.uk/oucl/publications/books/algebra/
10:54:51 <aavogt> though you could add enough annotations with -XScopedTypeVariables such that you can implement optimal_break exactly the same without restricting the class
10:54:52 <zygoloid> that is, you're giving last_break an instance for (BreakPoint p a bk), and it wants an instance for (BreakPoint p1 a1 bk). it doesn't know that p~p1 and a~a1
10:55:30 <zygoloid> right, ScopedTypeVariables allows you to give a type signature, but the typeclass would still be morally dubious ;)
10:55:59 <aavogt> that's true
10:56:59 <kuribas> I couldn't make this work in standard haskell?
10:59:54 <mmmulani> when using System.IO.interact, how can I check if I have reached the end of the input?
11:00:26 <Vanadium> see whether your code is being executed
11:00:28 <Vanadium> if not, end of input
11:00:33 <ksf> you get the end of the list
11:01:12 <nolrai_FG> @ty maybe
11:01:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:03:26 <mmmulani> ksf: as in an equality test with [] would work?
11:03:29 <aavogt> kuribas: technically you aren't using standard haskell by using multiparameter typeclasses
11:03:48 <kuribas> aavogt: I know, I would rather get rid of them!
11:04:18 <zygoloid> mmmulani: you should use 'null' or pattern matching rather than (==[]).
11:04:28 <aavogt> then use data instead of class... sometimes it's ok to be closed and have to manually pass the record around
11:06:24 <aavogt> @hoogle (Foldable f, Monoid m) => f m -> m
11:06:25 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
11:06:25 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
11:06:25 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
11:06:57 <aavogt> heh, I missed that one
11:16:05 <ksf> mmmulani, sure
11:16:59 <ksf> but you can of course also do things like interact (\foo -> foo ++ "bar")
11:17:36 <ksf> (++, after all, incidentally checks for the end of a list before appending the second one...)
11:18:42 <mreh> > 20^2
11:18:43 <lambdabot>   400
11:19:10 <nolrai_FG> Okay I need to applie a function that takes each key value pair in a Map and produces a new key value pair, whats the best way to do that?
11:19:56 <nolrai_FG> > putString "bob"
11:19:57 <lambdabot>   Not in scope: `putString'
11:20:07 <nolrai_FG> > putStrLn "bob"
11:20:08 <lambdabot>   <IO ()>
11:21:14 <paper_cc> @ty fromAssocs
11:21:15 <lambdabot> Not in scope: `fromAssocs'
11:21:36 <zygoloid> @hoogle mapKeys
11:21:36 <lambdabot> Data.Map mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
11:21:36 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
11:21:36 <lambdabot> Data.Map mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
11:22:32 <aconbere> I'm working with Lazy ByteString for the first time and I've come across some behavior I don't understand
11:22:46 <aconbere> when I use BL.hGetContents handle
11:23:07 <aconbere> obviously it's constructed a lazy data structure around that handle
11:23:24 <aconbere> and Char8's should be pulled from the handle on demand
11:23:55 <aconbere> but say for debuging purposes I'd like to remove all the contents
11:24:04 <jmcarthur> "remove"?
11:24:11 <aconbere> uh.. read
11:24:13 <aconbere> sorry
11:24:20 <jmcarthur> k
11:24:28 <aconbere> so I figure something like
11:24:54 <aconbere> putStr (show $ BL.hGetContents handle)
11:24:56 <aconbere> should work
11:25:08 <aconbere> but instead my program hangs waiting for more content
11:25:24 <jmcarthur> this handle is just a file, or what?
11:25:30 <aconbere> heh, it's a socket
11:25:39 <aconbere> I'm playing around with some of the simple web servers in haskell
11:25:42 <aconbere> (learning project)
11:25:45 <Twey> Then it will get content until the connection is closed
11:26:02 <aconbere> Twey: shouldn't it get content until it reaches the EOF?
11:26:07 <aconbere> and then close the connection
11:26:12 <jmcarthur> whether you see any output until the connection is closed might also depend on the buffering mode of stdout
11:26:25 <aconbere> "Once EOF is encountered, the Handle is closed."
11:26:34 <aconbere> jmcarthur: yeah I thought of that
11:26:38 <aconbere> oh!
11:26:40 <aconbere> stdout
11:26:52 <aconbere> I turned off buffering for the socket
11:26:59 <jmcarthur> try for both
11:27:00 <mauke> aconbere: the handle sees EOF when the other side closes the connection
11:27:01 <aconbere> but maybe I should turn off buffering for stdout too
11:27:10 <kmc_> lazy IO :(
11:27:14 <aconbere> :)
11:27:16 <jmcarthur> yeah...
11:27:17 <aconbere> wheeee
11:27:20 <kmc_> lazy IO is questionable
11:27:22 <jmcarthur> i'm ignoring the lazy IO thing
11:27:33 <Twey> aconbere: The EOF is when the connection closes
11:27:37 <jmcarthur> lazy IO is usually *bad* for sockets
11:27:45 <Twey> s/ for sockets//
11:27:48 <jmcarthur> since there are so many possible errors
11:27:52 <aconbere> I'm only doing it because of premature optimizations :)
11:27:52 <jmcarthur> well, especially for sockets
11:28:05 <kmc_> how's that
11:28:07 <aconbere> I figure it would be interesting to look at how that handles large bodies in http messages
11:28:08 <jmcarthur> aconbere: it's not really an optimization, either
11:28:19 <Twey> Read the presentation and learn Iteratee
11:28:26 <kmc_> the issue here is not efficiency
11:28:34 <kmc_> but rather that lazy IO has questionable semantics and is easy to screw up badly
11:28:42 <Twey> It's faster, it's neater, it's nicer, it's more powerful, and Oleg specifically uses HTTP requests as his motivating case
11:29:28 <jmcarthur> iteratees is also hard to pick up :(
11:29:35 <kmc_> what's so bad about regular old IO
11:29:46 <aconbere> Twey: http://okmij.org/ftp/Streams.html
11:29:52 <aconbere> ?
11:30:03 <Twey> aconbere: Yes
11:30:19 <jmcarthur> aconbere: are you doing a client or server?
11:30:23 <aconbere> jmcarthur: server
11:30:54 <Twey> jmcarthur: Not that hard
11:31:14 <jmcarthur> is this for learning purposes, or do you not like any of the existing http server libraries?
11:31:22 <aconbere> jmcarthur: mostly learning
11:32:09 <Twey> kmc_: Long-winded, imperative, doesn't compose, requires exceptions
11:32:33 <aconbere> wow
11:32:37 <aconbere> I just segfaulted irssi
11:32:39 <kmc_> "imperative" is a dirty word now?
11:32:43 <aconbere> :P
11:32:50 <Twey> Non-uniform representations of things (though that's better since .12)
11:33:13 <Twey> kmc_: Yep :Ã¾
11:33:30 <kmc_> i'd rather perform an imperative task in an imperative way than pretend it's somehow related to beta-reduction when that is an obvious lie
11:33:30 <aconbere> jmcarthur: it's given me a great chance to learn about bytestrings and sockets, and parellelism
11:33:35 <Twey> Imperative code is clumsy and doesn't compose nicely
11:33:45 <kmc_> Twey: but you already covered that with your other adjectives
11:33:52 <kmc_> anyway, you can write composable imperative code
11:34:06 <kmc_> people aren't used to it, because mainstream imperative languages also have pitiful abstraction facilities
11:34:07 <Twey> But it'll still be clumsy
11:34:12 <kmc_> but Haskell is an imperative language with good abstraction
11:34:32 <jmcarthur> we can't really cast out imperative code until we have a good alternative
11:34:43 <Twey> jmcarthur: And in this case, we do
11:34:43 <kmc_> anyway, something like iteratees is probably the right solution here
11:35:04 <jmcarthur> Twey: we have an alternative, and it's also efficient, but it's definitely not simple
11:35:15 <kmc_> but lazy IO is far worse than writing imperative code for an imperative task
11:35:27 <Twey> jmcarthur: It is rather simple
11:35:31 <jmcarthur> so if simplicity is a criterion for "good" then we dont' have it yet
11:35:33 <Twey> kmc_: Agreed
11:35:47 <Twey> jmcarthur: It's at least simple to *use*, if not simple to *understand*
11:36:00 <leimy_> Twey: iteratee is simple to use?
11:36:01 <Twey> jmcarthur: Much like the current I/O facilities, actually
11:36:04 <kmc_> with lazy IO you can pretend that files are immutable data strictures
11:36:07 <kmc_> but this makes no sense on sockets
11:36:09 <Twey> leimy_: Sure
11:36:12 <leimy_> I've not really messed with it
11:36:20 <leimy_> I was thinking about rewriting a big chunk of code that way though.
11:36:36 <jmcarthur> Twey: understanding it is rooted in understanding its imperative implementation
11:36:39 <Twey> leimy_: The sample in Oleg's talk ended up being about the same size as the lazy-IO equivalent
11:36:53 <Twey> jmcarthur: It doesn't have an imperative implementation (necessarily)
11:36:57 <leimy_> right but I have to get an idea as to how the pieces relate :-)
11:37:29 <jmcarthur> Twey: it doesn't even abstract its implementation away. that's why it's not simple
11:37:56 <Twey> jmcarthur: I don't think I agree with that
11:38:13 <Saizan> jmcarthur: [] doesn't abstract its implementation away either
11:38:32 <Twey> Oleg likes to teach ground-up, but I'm pretty sure that it's possible to use iteratees without understanding their inner workings
11:38:32 <leimy_> I guess I could/should spend some time with Iteratee
11:38:45 <jmcarthur> Saizan: in the case of [], it's implementation is simple and even matches with the desired semantics
11:39:18 <Saizan> jmcarthur: the semantics here is "(chunked) stream consumer" so it might match too
11:39:37 <nolrai_FG> @ty mapM
11:39:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:41:52 <leimy_> should the iteratee package really ship with codecs for things?
11:42:11 <jmcarthur> probably shouldn't
11:42:42 <leimy_> I mean, I like examples :-)
11:42:45 <leimy_> but put em in the docs
11:42:56 <Saizan> however i think i prefer an interface like Coroutine in the scc package, i'm not sure if it is as efficient though
11:44:14 <jmcarthur> i guess i see iteratee as a sort of fold over IO, not really some sort of replacement for it
11:44:34 <jmcarthur> folds don't really abstract away from their implementations, just over the recursion
11:44:38 <mreh> Array isn't O(1) is it?
11:44:39 <Twey> jmcarthur: Well, it's not just over IO
11:44:48 <Twey> mreh: For lookup, sure
11:44:57 <jmcarthur> so i don't see it as a "solution" to IO "problem"
11:45:04 <Twey> jmcarthur: It doesn't replace the IO monad or anything
11:45:07 <jmcarthur> Twey: sure. it's just recursion
11:45:14 <Twey> But it does replace the monadic interface we use so often
11:45:31 <jmcarthur> without really making the imperativeness of IO irrelevant, though
11:45:44 <mreh> Twey, I'm doing lookup in a 2D array, it gets slower for larger n.... must be something else, need to profile
11:46:09 <Twey> jmcarthur: It does make the imperativeness of IO irrelevant
11:46:23 <Twey> Unless you're designing a new stream source
11:46:41 <Saizan> an iteratee can still do any sort of IO while consuming the stream, no?
11:47:09 <Twey> Sure, but that IO can itself be phrased in terms of iteratees, applicatives, or something else non-imperative
11:47:11 <jmcarthur> i haven't really found a good way to use iteratee to make my outputs less imperative
11:47:32 <jmcarthur> i still have to perform actions
11:47:44 <jmcarthur> in a monadic way
11:47:52 <jmcarthur> or at least in an imperative way
11:47:54 <Saizan> what do you mean by "less imperatie outputs"?
11:48:19 <jmcarthur> Saizan: the responses generated by a program using iteratee are still action-driven
11:48:39 <kmc_> err, i'm not sure Applicative is really "non-imperative".  for IO it just gets you a subset of the IO monad actions
11:48:53 <kmc_> each one is directly a sequence of things to do in order
11:49:07 <jmcarthur> you can set up an output stream for a web server, sure, but what about all the *other* things the program does?
11:49:56 <jmcarthur> i don't really see iteratee making opengl any nicer, for example
11:50:54 <jmcarthur> iteratee is a great alternative to lazy IO or IO that would otherwise replace lazy IO, but it doesn't really make IO less imperative
11:51:03 <kmc_> yeah, what makes OpenGL nicer is a highly domain-specific and fancy mapping
11:51:03 <jmcarthur> generally, i mean
11:51:09 <Veinor> I think Haskell is getting to me. I'm taking a (mandatory) intro to CS course, and when they gave me an assignment 'make a vector class and write the add method', my first thought was 'write a lift function that applies its first argument element-wise to the two vectors, then let add(v1,v2) = lift(operator.add, v1, v2)'
11:51:10 <kmc_> something like FRP
11:51:21 <kmc_> yup, map
11:51:36 <Saizan> Veinor: hehe :)
11:51:40 <Botje> Veinor: what are you doing in an intro to CS course? :)
11:51:42 <zygoloid> Veinor: sounds good to me.
11:51:43 <Twey> Veinor: Well, obviously
11:51:48 <Veinor> it can't be tested out of, unfortunately.
11:51:49 <kmc_> yeah, that's just map
11:52:11 <kmc_> i hope you don't plan to become a professional software developer
11:52:30 <jmcarthur> why not?
11:52:31 <mauke> map? looks more like zipWith
11:52:53 <Twey> map = zipWith1
11:52:55 <kmc_> because you will be forced to use languages much worse than Haskell
11:53:02 <b0fh_ua> Hello! Can somebody please teach me of how to parse [Char] with XML inside with HXT, and extract some data from XML tags and attributes of that tags into a list of String objects?
11:53:06 <Veinor> kmc_: :P
11:53:13 <jmcarthur> kmc_: worse is subjective
11:53:15 <kmc_> i'm not kidding at all
11:53:40 <jmcarthur> kmc_: i'm happier writing kernel modules in C than i probably would be in Haskell
11:53:49 <kmc_> yeah yeah right language right job etc
11:53:49 <Veinor> that's cause you're weird.
11:53:53 <kmc_> we've all been over it
11:54:02 <aavogt> preflex: seen ivanm
11:54:03 <preflex>  ivanm was last seen on #xmonad 6 hours, 6 minutes and 4 seconds ago, saying: * ivanm -> land of nod
11:54:10 <kmc_> i'm talking about writing regular applications software, data munging and the like
11:54:19 <kmc_> you will spend a few weeks on a problem, knowing the whole time how you'd write it in Haskell in three hours
11:54:23 <kmc_> over and over
11:54:26 <Veinor> also, I've found that writing Haskell has made me slightly worse at Python because I keep expecting the compiler to catch stupid shit like typo'd variable names or stuff not being in scope at the right time.
11:54:26 <jmcarthur> but that's not the only kind of software job there is
11:54:42 <jmcarthur> Veinor: yeah, same here for C
11:54:48 <kmc_> jmcarthur: indeed, in fact there are software jobs in Haskell as well
11:55:05 <jmcarthur> kmc_: indeed. they just must be found and nabbed
11:55:38 <kmc_> anyway, i don't believe ignorance is bliss, so i think you should learn Haskell anyway
11:57:10 <MissPiggy> I beleive ignorance is bliss
11:57:20 <MissPiggy> not about programming though
11:57:29 <MissPiggy> all the programming languages are essentially the same
11:57:30 <kmc_> well, the Bible says it is
11:57:38 <MissPiggy> then the bible is right
11:57:47 <jmcarthur> programming languages are not all the same
11:58:07 <zygoloid> you could write a haskell interpreter in most languages, then write your program in a string constant :)
11:58:07 <MissPiggy> I never meta language I didn't like
11:58:59 <pikhq> zygoloid: I prefer writing an SK interpreter. :P
11:59:07 <pikhq> Much more confusing.
12:17:33 <Cale> Writing an SK interpreter is slightly easier than writing a lambda interpreter too :)
12:25:19 <olsner> I wrote my SK interpreter by first writing a lambda interpreter then translating SK to lambda
12:25:40 <sm> is there an easy way to list all installed ghc or cabal packages with nothing depending on them ?
12:25:53 <sm> I'd like to do some cleanup
12:32:53 <leimy_> So how does one use iteratee in the simplest case with say the Identity monad?
12:33:05 <leimy_> I want to try something like "run stream2list"
12:33:14 <leimy_> but I'm not really sure what the hell I'm doing.
12:33:15 <srush> what's the right way to parse integers with parsec
12:33:16 <nopsled_XYZ> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17047
12:33:30 <nopsled_XYZ> whats going on? operator precedence at work?
12:34:02 <srush> I've been using the language lexer, but I'd rather not have to
12:34:21 <MissPiggy> stream2list :: (StreamChunk s el, Monad m) => IterateeG s el m [el]
12:34:21 <monochrom> srush: read <$> many1 digit
12:34:25 <ezyang> srush: I think this is one of the unfortunate oversights of Parsec
12:34:33 <kmc_> nopsled_XYZ: you have (Just 2 (>>=))
12:34:39 <ezyang> monochrom: That's why ended up doing. I'm not happy with it :-(
12:34:44 <srush> monochrom: what about doubles?
12:34:50 <MissPiggy> StreamChunk s el has an instance for String (because [Char])
12:34:50 <endojelly> nopsled_XYZ, it's not an infix operator anymore when you put it in parantheses
12:34:53 <kmc_> applying Just to two arguments
12:35:00 <kmc_> the first is 2 and the second is (>>=)
12:35:40 <kmc_> but (Just 2) has type (Maybe a) for some a, which is not a function type.  so it's not prepared to accept a second argument
12:35:51 <MissPiggy> IterateeG [] Char Identity String
12:35:53 <monochrom> double is more involved. you have to write it yourself or use the language lexer.
12:36:04 <srush> gross
12:36:11 <srush> can't I just use the Read instance somehow?
12:36:14 <leimy_> MissPiggy: that's what I would expect
12:36:16 <leimy_> hmmm
12:36:40 <leimy_> ah
12:36:44 <leimy_> I had bad parens :-)
12:36:54 <leimy_> and no show instance of that result it seems
12:37:16 <MissPiggy> no show instance for function types
12:37:30 <MissPiggy> you need to  runIter stream2list <streamG>
12:37:48 <monochrom> No, Parsec doesn't have API to swallow a reads-like function. (ReadP does.)
12:37:58 <kmc_> it's not hard to write, is it?
12:38:01 <kmc_> pity it's not standard :/
12:38:02 <ezyang> "or so you think"
12:38:10 <ezyang> There's one in XMonad, iirc
12:38:17 <leimy_> > run ( stream2list :: IterateeG [] Char IO String)
12:38:18 <lambdabot>   Not in scope: `run'Not in scope: type constructor or class `IterateeG'Not i...
12:38:22 <leimy_> DOH!
12:38:23 <ezyang> in fact one of you folks showed it to me
12:38:23 <leimy_> :-)
12:38:25 <leimy_> but that works
12:38:26 <monochrom> "nothing to look here" ?
12:38:34 <kmc_> > fix error
12:38:35 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:38:55 <nopsled_XYZ> endojelly, kmc_ : thanks :-)
12:39:17 <Polarina> Is there a function in Prelude that takes in a list and returns another list with only X elements of the original list.
12:39:18 <Polarina> ?
12:39:36 <endojelly> Polarina, take
12:39:38 <endojelly> :t take
12:39:39 <lambdabot> forall a. Int -> [a] -> [a]
12:39:40 <Polarina> Thanks.
12:39:44 <monochrom> Polarina: drop
12:39:47 <monochrom> :t drop
12:39:48 <lambdabot> forall a. Int -> [a] -> [a]
12:39:49 <endojelly> > take 3 [1..]
12:39:50 <lambdabot>   [1,2,3]
12:40:10 <Cale> drop is the opposite :)
12:40:23 <endojelly> monochrom, that's rather returning n-x elements of the original list %)
12:40:33 <monochrom> Yeah combine with length.
12:42:09 <monochrom> > (\s -> drop (length s - 4) s) [1,1,1,1,1,1,1,1,1,1]
12:42:10 <lambdabot>   [1,1,1,1]
12:42:12 <monochrom> works
12:43:24 <Cale> Just not if the list is infinite ;)
12:43:24 <MissPiggy> http://simple.wikipedia.org/wiki/Main_Page
12:43:27 <MissPiggy> we should make a simple.haskell
12:43:35 <MissPiggy> there would be no difficult words
12:43:42 <Cale> hehe
12:44:25 <Twey> Haha
12:44:55 <Twey> Haskell is a very clever programming language.  It can do all sorts of things, like write messages to people.
12:44:55 <MissPiggy> [change] Common tasks for a computer scientist:
12:44:59 <MissPiggy> [change] Asking a question
12:45:00 <MissPiggy> Why do we need so much time and effort maintaining existing programs?
12:45:08 <MissPiggy> guys I think I might be a computer scientist
12:45:13 <Twey> Hehe
12:45:15 <shambler> :)
12:45:48 * monochrom builds fol.wikipedia.org : written in first-order logic only.
12:46:06 * Cale wonders why there's only a Simple English Wikipedia, and not simplified versions of the other languages.
12:46:40 <monochrom> Because only Americans need it.
12:46:44 * Twey chuckles.
12:46:47 <Cale> haha
12:46:49 <burp> haha
12:46:53 <Cale> http://simple.wikipedia.org/wiki/Iwasawa_theory
12:46:53 * MissPiggy is enjoying it
12:47:20 <shambler> that's simple for sure
12:47:45 <Twey> Oh, yeah.  Every Tom, Dick, and Harry knows what p-adic integers are.  ;)
12:47:58 <MissPiggy> are p-adic difficult?
12:48:00 <Cale> and Pontryagin duality
12:48:10 <Cale> p-adic integers are not so bad :)
12:48:44 <Cale> Though, there's no simple English wikipedia page for them :P
12:48:46 <Twey> I'm sure they're not, but I'm pretty sure that people who can't understand a word like â€˜proposedâ€™ won't even know what integers are
12:49:22 <MissPiggy> # Artificial intelligence (making computers look intelligent)
12:49:23 <Cale> Well, I think the idea of Simple English wikipedia is that it's for people who are learning English.
12:49:27 * MissPiggy snickers
12:49:38 <Twey> MissPiggy: smart**
12:49:42 <gwern> simple wikipedia is an abomination
12:50:02 <Cale> So they might have lots of domain specific knowledge, but not much English vocabulary.
12:50:03 <gwern> it's worse than the 9/11 wiki because it still exists
12:50:13 <shambler> http://en.wikipedia.org/wiki/P-adic_L-function
12:50:14 <Twey> Cale: I suppose
12:50:17 <Cale> I think it's a good idea in theory.
12:50:20 <Twey> gwern: 9/11 wiki?
12:50:23 <shambler> they'll simplify it later
12:50:26 <Cale> I'm not sure how well it works in practice.
12:50:28 <gwern> Twey: what it says on the tin
12:50:31 <shambler> oh
12:50:33 <shambler> wrong link
12:50:39 <shambler> http://en.wikipedia.org/wiki/Iwasawa_theory
12:50:47 <Polarina> The only proper way to learn English is to read the normal wikipedia and look up every other word.
12:50:53 <Twey> gwern: 911.wikipedia.org, or something?
12:50:57 <Twey> Polarina: *nod*
12:51:09 <Twey> s/English/a language/
12:51:14 <MissPiggy> In computer science, a program specification is a list of requirements written for a computer program. The program specification is written before a computer scientist makes the program. Then, after the computer scientist makes the program, she must check that the program agrees with the requirements in the specification.
12:51:17 <MissPiggy> ^ that seems wrong
12:51:33 <Cale> MissPiggy: Why?
12:51:38 <gwern> Twey: well, we no longer have the 9/11 wiki which was the point
12:51:42 <Polarina> Cale, "she"
12:51:44 <shambler> cientist makes the program, _she_ must check
12:51:44 <Twey> Computer scientists don't write programs.  That's for engineers.  :Ã¾
12:51:45 <MissPiggy> I don't believe in the ordering
12:51:46 <shambler> omf
12:51:47 <shambler> wat
12:51:54 <Cale> MissPiggy: Is that from the simple English wikipedia?
12:51:58 <MissPiggy> yes
12:52:08 <Twey> That's quite common in English
12:52:25 <Twey> â€˜Heâ€™ used to be a generic pronoun, so in response some people decided to use â€˜sheâ€™ instead
12:52:32 <gwern> Twey: some people flip coins
12:52:33 <monochrom> I do that all the time. Specification before program, and checked.
12:52:43 <gwern> imo, the best guideline is to use your own gender
12:52:47 <MissPiggy> hmm
12:52:55 <Twey> Or just use gender-neutral â€˜theyâ€™
12:52:58 <Twey> Or â€˜he/sheâ€™
12:53:07 <gwern> since english forces you to add information, at least make it convey something other than sheer entropy
12:53:13 <Twey> If you're one of those crazy people who hates Shakespeare
12:53:17 <Twey> Ha
12:53:27 <gwern> this is one  reason I dislike french
12:53:28 <Twey> We could use that as an entropy sourceâ€¦
12:53:32 <leimy_> > run $ fileDriverHandle (stream2list :: IterateeG [] Char (IterateeG [] Char IO) String) "/etc/passwd"
12:53:33 <lambdabot>   Not in scope: `run'Not in scope: `fileDriverHandle'Not in scope: type const...
12:53:34 <leimy_> Yuck?
12:53:36 <shambler> he's dead, why hate him?
12:53:37 <Twey> MissPiggy: The ordering seems reasonable to me, though.
12:53:41 <gwern> it has something like a megabyte of entropy to memorize because of its gender
12:53:45 <Twey> leimy_: Yuck
12:53:59 <Cale> I like gender-neutral 'they'.
12:54:07 * gwern smiles at leimy_. did you really think that'd work?
12:54:13 <Twey> Everyone likes gender-neutral â€˜theyâ€™, except very strange people
12:54:13 <leimy_> not here :-)
12:54:23 <gwern> Cale: but that conveys as little as randomizing your (s)hes
12:54:31 <Cale> The plurality is a plurality of possibilities rather than a plurality of people.
12:54:32 <leimy_> the file path was a random choice
12:54:37 <monochrom> I use "he/she/it/they" because I don't want to discriminate against other genders, dogs, and bacteria cultures.
12:54:53 <Twey> Wellâ€¦ I'd prefer it to not be the same as the third-person plural, but it's better than nothing
12:54:56 <Twey> monochrom: Haha
12:55:10 <gwern> leimy_: random eh. like the number 4
12:55:36 <leimy_> gwern: Well I was thinking yuck in terms of syntax...
12:55:53 <MissPiggy> what's wrong with type annoationa
12:55:56 <MissPiggy> lol
12:56:01 <MissPiggy> when I see
12:56:02 <MissPiggy> f :: X
12:56:04 <MissPiggy> f = ...
12:56:08 <MissPiggy> that's okay?
12:56:21 <MissPiggy> but f (x :: T) y
12:56:57 <Cale> MissPiggy: You need an extension to support the latter syntax.
12:57:24 <Cale> Type annotations weren't part of the syntax of patterns in Haskell 98
12:57:41 * hackagebot upload: monad-stlike-io 0.2.1 - ST-like monad capturing variables to regions and supporting IO. (TaruKarttunen)
12:58:05 <Cale> {-# LANGUAGE PatternSignatures #-}
12:58:31 <Twey> Cale: Might have been a callâ€¦
12:58:41 * hackagebot upload: monad-stlike-stm 0.1.1 - ST-like monad capturing variables to regions and supporting STM. (TaruKarttunen)
12:59:00 <Cale> oh, I suppose so
12:59:07 <Cale> But it would have been okay in that case.
12:59:47 <leimy_> Hmmm I think an "expect" like language could be written for iteratee pretty easily the more I look at it.
12:59:58 <MissPiggy> "expect"??
13:00:21 <leimy_> http://expect.nist.gov/
13:00:22 <kmc_> it's a unix command
13:00:24 <Cale> MissPiggy: A tool for scripting interactions with interactive programs.
13:00:50 <leimy_> right
13:01:00 <leimy_> you basically write what you expect to see, and how to respond
13:01:03 <leimy_> with alternatives
13:01:12 <leimy_> I've got one now in Haskell
13:01:14 <leimy_> in  monad
13:01:18 <leimy_> er in a monad
13:01:24 <leimy_> but it's messy as all hell
13:01:29 <kmc_> isn't it great how every UNIX tool has its own ad-hoc domain specific language
13:01:39 <leimy_> so I wrote it a second time... and iteratee looks like it'd be a better way to go for safer IO on the handle
13:02:01 <MissPiggy> hows it different than tcl
13:02:10 <leimy_> It's usually built into Tcl
13:02:19 <leimy_> there was expect for Perl too
13:02:23 <leimy_> probably still is
13:02:28 <MissPiggy> ah
13:02:39 <leimy_> I used to use expect to login to the university modem pool when I was in college
13:02:46 <leimy_> to establish a PPP connection.
13:04:10 <mux> cimer
13:04:14 <mux> woops, sorry
13:12:45 <b0fh_ua> Guys, how do I get rid of the lambda in  [1,2,3] >>= \x -> [succ x] ?
13:13:07 <Twey> map succ [1, 2, 3]
13:13:38 <Peaker> @pl [1,2,3]>>=\x->[succ x]
13:13:38 <lambdabot> succ `fmap` [1, 2, 3]
13:13:39 <Twey> Or, if you must use the monad instance, [1, 2, 3] >>= return . succ, A.K.A. liftM succ [1, 2, 3]
13:13:42 <b0fh_ua> Twey: sure, but I'd like to understand how to do such kind of tricks in >>=
13:14:05 <Twey> â€¦ A.K.A. fmap succ [1, 2, 3], A.K.A. map succ [1, 2, 3]
13:14:25 <b0fh_ua> Twey: got you, thanks
13:14:25 <Peaker> b0fh_ua: [succ x] is just    ((:[]) . succ) x     and in the list monad, (:[]) is just return.. so far with me?
13:14:52 <b0fh_ua> Peaker: yup, that's clear. I should think about this prior asking
13:14:58 <Cale> If the function on the right hand side of >>= is written as a composite, I find that flipping it over and using =<< is nicer.
13:15:07 <Twey> I guess so
13:15:20 <b0fh_ua> not so fast, I just learning things :)
13:15:25 <MissPiggy> b0fh_ua, why do you want rid of lambda?
13:15:29 <Cale> So it would become  return . succ =<< [1,2,3]
13:15:33 <Twey> â€˜>>= monadFunction .â€™ is something of an idiom for me
13:15:53 <Cale> Though you should always replace return . f =<< x with fmap f x
13:16:33 <b0fh_ua> btw may be somebody could suggest some VERY simple library to parse XML and extract some content from it? I found hxt very complicated - I don't understand much of it
13:16:39 <Cale> (or liftM, if you're concerned about the extra Functor constraint)
13:16:47 * hackagebot upload: BerkeleyDB 0.8 - Berkeley DB binding (StephenBlackheath)
13:16:49 <MissPiggy> :(
13:17:02 <Peaker> MissPiggy: Lambdas are evil :)
13:17:09 <b0fh_ua> so much things to learn
13:17:15 <MissPiggy> oh right I better stop using lamba
13:17:25 <Twey> Lambast those lambdas!
13:17:35 <Peaker> MissPiggy: joking aside, I think its nicer to denote structure using combinators than using lexical scope references
13:17:39 <Peaker> I find it more declarative
13:17:51 <MissPiggy> b0fh_ua that wasn't a rhetorical question that was just some veiled way to say that you're wrong it was an actual question
13:17:52 <cosinelaw> though sometimes it's more readable to have named variables
13:18:11 <Alpounet> Peaker, wholeheartedly agreed
13:18:11 <Twey> I concur
13:18:52 <Peaker> cosinelaw: Well, the points-free style gets rid of the intermediate names which were good documentation anchors, I guess..  Maybe a non-textual editor could have both a declarative structure and documenting the data that flows within
13:18:55 * b0fh_ua is reading about STG
13:19:13 <MissPiggy> b0fh_ua, and?
13:19:20 <Peaker> For now, one can use comments (lesser than names, but maybe good enough)
13:20:16 <Polarina> @src return
13:20:16 <lambdabot> Source not found. My mind is going. I can feel it.
13:20:37 <Peaker> @src [] return
13:20:38 <lambdabot> return x    = [x]
13:21:35 <MissPiggy> b0fh_ua, k just ignore me.
13:23:49 * hackagebot upload: BerkeleyDBXML 0.7 - Berkeley DB XML binding (StephenBlackheath)
13:27:41 <kniu> yo, is there such a thing as "explicit" inference?
13:27:49 <kmc_> what would that mean?
13:28:16 <kmc_> Polarina: return is defined separately in each instance of the typeclass named "Monad"
13:29:20 <kniu> that would mean something like
13:29:45 <gwern> anyone know whether cabal ever got the make functionality from the summer of code library?
13:29:57 <gwern> b0fh_ua: anyone suggest tagsoup to you?
13:30:30 <kniu> (\(x : forall t . t) . t)
13:30:45 <kmc_> well, that's a type signature on a pattern
13:30:50 <kmc_> (except in haskell we use :: instead of :)
13:31:10 <c_wraith> accidental smileys! maximal confusion!
13:31:12 <kmc_> > (\(x :: forall a. a) -> ()) undefined
13:31:13 <lambdabot>   ()
13:31:16 <kmc_> > (\(x :: forall a. a) -> ()) 7
13:31:17 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
13:31:18 <lambdabot>    arising from the li...
13:31:18 <Philonous> No smileys in haskell
13:31:19 <MissPiggy> kniu, I think what you are getting at is maybe church vs curry
13:31:24 <kmc_> > (\(x :: forall a. a) -> ()) 'x'
13:31:25 <lambdabot>   Couldn't match expected type `a'
13:31:25 <lambdabot>         against inferred type `GHC.Types.C...
13:31:44 <kmc_> kniu: btw, that creates a function with a rank-2 type
13:31:55 <kmc_> :t \(x :: forall a. a) -> ()
13:31:56 <lambdabot> (forall a. a) -> ()
13:31:59 <c_wraith> there are definitely smiles in haskell
13:32:01 <MissPiggy> "sometimes called intrinsic vs. extrinsic"
13:32:04 <kniu> hm.
13:32:05 <c_wraith> > (:[])
13:32:07 <lambdabot>   {()->[()]}
13:33:17 <idnar> (# #)
13:33:21 <nopsled_XYZ> doSomething :: Monad m => a -> m b
13:33:25 <kmc_> > (# #)
13:33:26 <lambdabot>   No instance for (GHC.Show.Show (t -> (# t #)))
13:33:26 <lambdabot>    arising from a use of `M1...
13:33:28 <kmc_> > (# 2, 3 #)
13:33:29 <lambdabot>   Illegal binding of unboxed tuple e_123 :: (# t_a368, t_a36a #)
13:33:50 <kmc_> > case (# 2, 3 #) of (# a,b #) -> a
13:33:51 <lambdabot>   2
13:34:05 <idnar> > (# 2#, 3# #)
13:34:06 <c_wraith> let (^.^) = (*) in 4 ^.^ 5
13:34:06 <lambdabot>   Illegal binding of unboxed tuple
13:34:06 <lambdabot>      e_123 :: (# GHC.Prim.Int#, GHC.Prim.I...
13:34:18 <tavelram> c_wraith, dont you agree that (:[]) is the coolest smiley ever? :)
13:34:21 <nopsled_XYZ> could someone bind a definition for doSomething ?
13:34:28 <Vanadium> > let (# a, b #) = (# 2#, 3# #) in a
13:34:29 <lambdabot>   Couldn't match kind `#' against `*'
13:34:33 <Vanadium> Huh.
13:34:36 <MissPiggy> doSomething = undefined
13:34:41 <Vanadium> let is lazy so it has to be boxed things?
13:34:51 <kmc_> something like that
13:35:15 <kmc_> on STG machine, let creates a closure, and unboxed tuples don't have a closure representation
13:35:19 <kmc_> > let x = 2# in ()
13:35:20 <lambdabot>   ()
13:35:23 <kmc_> hmm, odd
13:35:27 <kmc_> :t let x = 2# in x
13:35:28 <lambdabot> GHC.Prim.Int#
13:35:55 <nopsled_XYZ>  doSomething ::  a -> Just b  can do that, but i want to now a example when using a the generic Monad class.
13:36:16 <kmc_> err, (Just b) is not a type
13:36:27 <idnar> @type let (# a, b #) = (# 2#, 3# #) in a
13:36:28 <lambdabot> GHC.Prim.Int#
13:36:34 <MissPiggy> nopsled_XYZ, mzero
13:36:35 <nopsled_XYZ> ok: doSomething :: a -> Maybe b
13:36:46 <idnar> I think the problem is the kind of a and b there
13:36:50 <MissPiggy> > mzero :: Maybe Integer
13:36:51 <lambdabot>   Nothing
13:36:56 <idnar> or maybe not, I dunno
13:36:57 <MissPiggy> > mzero :: Maybe [Integer]
13:36:58 <lambdabot>   Nothing
13:37:05 <MissPiggy> > mzero :: [Maybe [Integer]]
13:37:06 <lambdabot>   []
13:37:27 <doserj> @type const (return undefined)
13:37:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => b -> m a
13:38:44 <gwern> @seen Saizan
13:38:44 <lambdabot> Unknown command, try @list
13:38:50 <gwern> preflex: seen Saizan
13:38:50 <preflex>  Saizan was last seen on #haskell-blah 1 hour, 29 minutes and 36 seconds ago, saying: massive leverage doesn't crush you down if you lose?
13:39:05 <nopsled_XYZ> :t mzero
13:39:06 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:39:09 <nopsled_XYZ> oops
13:40:21 <harlekin> @pl (\s -> forever $ forkIO . handle =<< accept s)
13:40:21 <lambdabot> forever . (forkIO . handle =<<) . accept
13:40:24 <gwern> has anyone ever used 'hbuild'?
13:40:43 <bolmar> @type >>
13:40:44 <lambdabot> parse error on input `>>'
13:41:31 * monochrom is quite impressed with how many years is 2^31 minutes. :)
13:42:42 <gwern> preflex: seen nominolo_
13:42:43 <preflex>  nominolo_ was last seen on #ghc 4 hours, 26 minutes and 46 seconds ago, saying: topi`: correct
13:42:45 <gwern> preflex: seen nominolo
13:42:45 <preflex>  nominolo was last seen on #ghc 1 day, 10 hours, 37 minutes and 15 seconds ago, saying: dreixel: you'll need the devel branch though
13:43:09 <mauke> preflex: calc 2^31 / 60 / 24 / 365.26
13:43:09 <preflex>  4082.867242207986
13:43:20 <gwern> nominolo_: around?
13:44:08 <nominolo_> gwern: what up?
13:44:19 <gwern>  nominolo do you remember what actually came out of your 2008 ghc api SoC? I'm trying to figure out whether to classify it as a success or failure
13:44:38 <gwern> I'm looking at the trac page but it doesn't seem to list anything you actually did
13:45:08 <nominolo_> gwern: ah, well, SimonM classified is as a success.  It was mostly minor things though
13:45:09 <Peaker> mauke: why do you need just minute-accuracy, and why store it in a signed integer?
13:45:25 <mauke> Peaker: I don't
13:45:25 <gwern> nominolo_: classified it in a google submission?
13:45:30 <nominolo_> yes
13:45:42 <gwern> nominolo_: oh. I assume if he didn't you wouldn't've gotten paid
13:45:49 <nominolo_> right
13:45:53 <gwern> nominolo_: but minor things... hm. maybe I should mark that a failure
13:46:02 <nominolo_> for what purpose?
13:46:10 <gwern> nominolo_: my history of SoCs
13:46:23 <gwern> http://community.haskell.org/~gwern/wiki/Haskell%20Summer%20of%20Code.page
13:46:46 <gwern> I would use you as another bullet for my contention 'SoCs need to be very specific'
13:47:40 <gwern> I mean, even if all your minor things got in, SoCs oughn't be for minor things
13:47:52 * monochrom chuckles at the memoryless nature of most IRC participants :)
13:48:03 <gwern> I willn't mark it a success given how rare and valuable SoCs can be
13:48:24 <mauke> monochrom: s/memory/state/
13:48:30 <mauke> it's all about purity!
13:49:04 <nominolo_> gwern: true,  I am still only making slow progress into improving the API.
13:49:37 <nominolo_> gwern: The main problem is figuring out where to go and each tiny step there can be quite difficult.
13:50:41 <nominolo_> gwern: I introduced the Ghc monad and fixed some small bugs, but I didn't introduce fundamentally new features to the Ghc API
13:51:19 <Peaker> is the GHC monad an effect-ful one, or just a bunch of ReaderT's/etc?
13:51:43 <nominolo_> Peaker: it's ReaderT (IORef Session) IO a
13:51:50 <nominolo_> not pretty
13:51:57 <nominolo_> GHC itself is very impure
13:52:08 <Peaker> why? :(
13:52:10 <monochrom> worst of both worlds :)
13:52:22 <nominolo_> The IORef is to avoid space leaks
13:52:31 <Peaker> why not strict StateT?
13:53:04 <nominolo_> not sure.  The Simon's opted for IORefs
13:53:19 <sinelaw> shouldn't GHC be the ultimate ultimateness in Haskell code, the pristine example of how such code should look in a real application?
13:53:19 <Cale> Peaker: Mutable references make for an easy efficient implementation of unification, though probably using Data.Map wouldn't be too much less efficient.
13:53:36 <kmc_> the real world is messy
13:53:46 <nominolo_> sinelaw: it was started 16 years ago.  lots of things has changed since then.
13:54:00 <sinelaw> time to rewrite?
13:54:03 <kmc_> it's more important that GHC be an actually good compiler than that it have pretty code
13:54:13 <kmc_> there are other people working on Haskell compilers
13:54:18 <nominolo_> Cale: well, ST would be possible if IO weren't so useful for debug output
13:54:24 <kmc_> you too can write a Haskell compiler
13:54:38 <sinelaw> kmc_, my first haskell program was a patch for ghc
13:54:46 <nominolo_> sinelaw: it's only 200K SLOC of very delicate code ...
13:54:47 <sinelaw> that was it for me
13:55:12 <moshisushi> hello anyone here using the functional graph library (FGL) ?
13:55:17 <sinelaw> Nomad010, i was half joking
13:55:20 <sinelaw> moshisushi, yes indeed
13:55:28 <moshisushi> i'm trying to figure out how to write recursive functions over a graph
13:55:30 <sinelaw> albeit i use it very little
13:55:31 <mornfall> Is there a way to stop a profiled program midway and having it dump the profile as well? ^C seems to prevent the final profile dump :(
13:55:38 <moshisushi> how to work out the pattern matching, taht is
13:55:39 <sinelaw> moshisushi, meet ivanm
13:55:40 <Peaker> Cale: I don't understand -- unification as in type unification?
13:55:40 <nominolo_> sinelaw: I do have a few ideas how to get to a more pure interface.
13:55:55 <moshisushi> ivanm: hello best graph lib expert!
13:55:55 <Peaker> Cale: what's the difference between ReaderT (IORef s) IO   and a strict StateT s IO
13:56:02 <sinelaw> heh
13:56:41 <Botje> Peaker: can you store _|_ in an ioref?
13:56:56 <Peaker> Botje: I think so
13:57:03 <nominolo_> Botje: yes
13:57:26 <Botje> then wouldn't that be a difference? :)
13:57:27 <Peaker> I don't see the IORef using "seq" and it has no other way to force the value inside it (since its polymorphic)
13:57:30 <Saizan> strict StateT is not strict in the state
13:57:48 <gwern> does hp2any work?
13:57:51 <Saizan> is only strict in the tuple
13:57:52 <gwern> *be useful
13:57:55 <Botje> oh.
13:58:17 <Peaker> Saizan: Like the ReaderT (IORef s), isn't it?
13:58:39 <Saizan> Peaker: there's no tuple there :)
13:58:40 <mornfall> Strict in which tuple?
13:58:50 <Peaker> Saizan: I mean, in either case the state itself is not strict
13:58:52 <Saizan> ?src State
13:58:53 <lambdabot> Source not found. My brain just exploded
13:58:56 <moshisushi> sinelaw: well maybe you can help anyway, t'll show you what i'm trying to do
13:58:59 <Saizan> ?type State
13:59:01 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:59:07 <Saizan> mornfall: that tuple ^^^
13:59:14 <Saizan> Peaker: yeah
13:59:17 <kmc_> @unmtl state s a
13:59:17 <lambdabot> state s a
13:59:21 <kmc_> @unmtl State s a
13:59:22 <lambdabot> s -> (a, s)
13:59:24 <Peaker> Saizan: so what reason is there for the IORef hack?
13:59:38 <aavogt> but doesn't bind force the tuple with the strict StateT?
13:59:47 <Cale> Peaker: Yeah, type unification. The traditional way to implement it is just to have each type variable be an IORef.
14:00:19 <Saizan> Peaker: mh, a type like that is easier to use with functions that expect a callback in the IO monad
14:00:28 <Peaker> Cale: yuck :)
14:00:34 <Cale> Peaker: and as you acquire equations on the types, you fill in the IORefs with that information.
14:00:42 <Saizan> Peaker: but you can do that with StateT too, by using a temporary IORef
14:01:02 <Peaker> GHC should be a flagship of good practices, ideally.. it's got the most famous experts working on it
14:01:05 <nominolo_> No, IORefs for unification are separate
14:01:23 <nominolo_> they are only used in the type checker, so that's a separate issue
14:01:30 <Cale> I don't know what you're referring to regarding ReaderT/StateT
14:01:53 <nominolo_> The main GHC monad passes around a mutable Session
14:01:53 <Saizan> UHC (or should i say EHC?) use a Data.IntMap heap instead of IORefs, if the papers tell the truth
14:01:54 <Cale> I thought that's what we were talking about.
14:01:58 <Cale> ah
14:02:39 <nominolo_> The Session state maintains various symbol tables and other information loaded from interface files.
14:02:40 <Peaker> how many LOCs is GHC?
14:02:47 <moshisushi> sinelaw: so i have this graph of type Gr Char Char
14:02:47 <nominolo_> 200K SLOC
14:03:11 <moshisushi> constructed by a few Context Char Char's and the & operator
14:03:16 <Peaker> nominolo_: that's huge.. do you think it could be much smaller if made more composable/denotational?
14:03:19 <nominolo_> It's not *that* big.  But it's lot of code that only one of the Simon understands.
14:03:30 <nominolo_> Peaker: the type checker alone is 100K
14:04:11 <Peaker> nominolo_: Weird! There are DT checkers in <100 lines, supposedly
14:04:48 <moshisushi> sinelaw: now, i want to iterate over the graph recursively, pretty much like you do with lists and pattern matching.. do you know how to accomplish this?
14:04:51 <nominolo_> The type checker works on the full Haskell syntax tree to have better error messages.
14:04:55 <MissPiggy> Dependent types are simple
14:04:55 <Saizan> DT?
14:05:00 <MissPiggy> I've said this before
14:05:10 <kmc_> MissPiggy: me too, nobody believes us :/
14:05:21 <Peaker> simpler than non-dependent types?
14:05:23 <kmc_> yes
14:05:25 <kmc_> fewer things
14:05:26 <MissPiggy> hi grahamhutton!
14:05:37 <jmcarthur> dependent types are trivial compared to many type systems
14:05:42 <MissPiggy> simpler than Fw or whateer
14:05:50 <MissPiggy> and ML
14:05:52 <kmc_> one form of abstraction is simpler than two
14:05:52 <Cale> Dependent types are simple to implement, but I bet things get more complicated if you want to have a meaningful amount of type inference, and decent interaction with other type system extensions.
14:05:55 <grahamhutton> hello!
14:06:10 <Cale> as well as good error messages
14:06:13 <jmcarthur> Cale: more complicated with almost *any* amount of type inference :\
14:06:15 <Peaker> if you can do code inference, screw type inference :)
14:06:15 <nominolo_> Peaker: ok, I've been wrong.  It's only 20K
14:06:25 <pumpkin> you get really really basic type inference
14:06:31 <Saizan> Peaker: same thing really
14:06:43 <Cale> Peaker: I disagree. Sometimes I just want to write the code and have the types inferred and checked.
14:06:45 <MissPiggy> with dependent types, term inference IS type ineference
14:06:47 <dolio> Why are dependent types simpler than Fw? Fw can be done with exactly the same machinery, but one fewer rule.
14:07:04 <MissPiggy> dolio, um I got the name wrong
14:07:05 <Cale> Peaker: There are a lot of programs, especially small programs, where you don't want to write the types.
14:07:07 <Peaker> Saizan: how come?
14:07:10 <MissPiggy> I was thinking of the one GHC uses
14:07:26 <Peaker> Cale: if the types are rich enough, can't you just write only the types, and let the code stem from that?
14:07:40 <MissPiggy> System FC
14:07:43 <MissPiggy> that's what I meant to say
14:07:44 <dolio> Ah.
14:07:53 <MissPiggy> and things like Definition of Standard ML
14:07:55 <MissPiggy> that's a BOOK
14:08:04 <MissPiggy> not a A5 page
14:08:08 <luqui> MissPiggy, unless you consider context.  I would say type inference is "term -> its type", and term inference is "type -> a term that has that type"
14:08:09 <lambdabot> luqui: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:08:14 <luqui> which are pretty different
14:08:18 <Cale> Peaker: Consider things like small unix shell-script tools, mostly of type String -> String. Often refining the type such that it becomes a specification is harder than just writing the string function you're after directly.
14:08:27 <kmc_> that's just inferring two directions of the (:) relation
14:08:33 <kmc_> which in DT is a relation between two terms
14:08:44 <kmc_> a "type" is just a term that happens to have type Set or whatever you call it
14:08:46 <MissPiggy> luqui, I mean the cases where you have    f _ _ x  and the underscores are inferred (that can be read off the type of x)
14:09:09 <luqui> ah okay those are kinda the same thing
14:09:13 <Cale> Peaker: moreover a lot of those things are good one-liners, and you don't want to screw up that part of the design space by forcing people to write type signatures which double the size of the program text.
14:09:13 <Saizan> Peaker: in DT you've terms in types, so you've the same exact structure on both sides, and so you use the same machinery to infer both values and types, the surrounding contraints just have to be tight enough for the type checker to derive a solution for you
14:09:33 <luqui> kmc_, inferring those two directions involves fairly different machinery
14:09:37 <Saizan> Peaker: this already works in agda, for example
14:09:46 <gwern> anyone use EclipseFP?
14:09:59 <Cale> Scaling down is just as important as scaling up, in my opinion.
14:10:17 <nominolo_> Ok, it's only 100K SLOC:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17056#a17056
14:10:25 <nominolo_> I may have confused it with LOC
14:10:30 <nominolo_> There are lots of commens
14:10:33 <nominolo_> *commets
14:10:36 <sinelaw> heh
14:10:39 <sinelaw> asteroids
14:10:50 <jmcarthur> dragons?
14:11:00 <Botje> shouldn't there be 400 lines of perl in there? :D
14:11:29 <nominolo_> Wasn't nhc designed to fit 10K lines, but the goal was achieved by leaving out all type signatures and using tuples everywhere?
14:11:55 <kmc_> :(
14:12:00 <gwern> tuples?
14:12:08 <nominolo_> yeah, no records
14:12:32 <nominolo_> The RTS is 45K SLOC, but a lot is conditionally compiled
14:12:48 <luqui> nominolo_, that doesn't make it simpler
14:13:01 <luqui> it's not like not compiling them always makes them not count
14:13:02 <nominolo_> luqui: certainly not
14:13:08 <MissPiggy> oh
14:13:25 <MissPiggy> but stuff like type inference and pattern match elaboration isn't really type checking
14:13:49 <MissPiggy> it's different in haskell, where type inference IS type checking
14:13:54 <MissPiggy> (roughly)
14:14:37 <nominolo_> MissPiggy: GHC's typechecker also rewrites the input to an explicitly typed variant of haskell
14:14:56 <MissPiggy> yeah but e.g. I wrote an implementation that doesn't do that
14:15:00 <luqui> with other crap.  if only it were so simple
14:15:13 <ddarius> Botje: Quite a bit more than 400 lines.
14:16:12 <Saizan> Peaker: though, to be fair, you probably meant something much more involved like what djinn or tactics in Coq do
14:16:13 <ddarius> Botje: There are 2061 wc -l lines in the ghc-asm perl file distributed with the compiler.
14:16:36 <nominolo_> Hm, I wonder how 110K of Haskell would be if it were C++
14:16:49 <nominolo_> 1M, maybe?
14:16:53 <Polarina> nominolo_, millions of lines!
14:16:59 <Botje> nominolo_: and they'd be PROUD of it!
14:17:02 <ddarius> nominolo_: Possibly depending on the application.
14:17:10 <nominolo_> ddarius: well, a compiler
14:17:26 <nominolo_> also, I'm leaving out the standard libs
14:18:23 <MissPiggy> oh and data types are fun
14:18:50 <MissPiggy> adding them in can be quite a tricky thing
14:19:24 <MissPiggy> (it could also be relatively simple of you have a different strategy)
14:19:31 <nominolo_> MissPiggy: does intensional/extensional equality play a role in type checking?
14:19:34 <kmc_> well, Boost.Optional is about 1000 lines
14:19:47 <nominolo_> kmc_: is that Maybe ?
14:19:50 <kmc_> and it implements Maybe, call that 10 lines (including Show instances, etc.)
14:19:56 <kmc_> so call it 100x bloat ;)
14:20:03 <nominolo_> kmc_: what about Data.Maybe?
14:20:11 <kmc_> don't know how much of it corresponds
14:20:13 <Botje> ghc-asm is _REALLY_ crufty perl code
14:20:15 <nominolo_> i.e, isJust, isNothing, catMaybes
14:20:20 <Botje> would it be worth the effort of cleaning it up?
14:20:32 <kmc_> there is of course no clean way to express the Maybe monad in C++
14:20:39 <nominolo_> Botje: no, it won't be needed for the native code gen
14:20:56 <kmc_> a lot of the complexity in the boost code is conditional compilation for 100 different broken C++ compilers
14:21:06 <MissPiggy> nominolo_: what do you mean?
14:21:14 * hackagebot upload: Vec-Boolean 1.0.2 - Provides Boolean instances for the Vec package (TobiasBexelius)
14:21:37 <Botje> okay :)
14:21:46 <MissPiggy> nominolo_: I think of 3 sorts now intensional, extensional and observational
14:21:49 <Cale> The Evil mangler is perl code, but given what it does, perl is not a terrible choice of language there. It's a fundamentally messy thing to begin with, and it's only needed for compiling via C anyway.
14:22:01 <nominolo_> MissPiggy: Ok, more generally, I believe there are various design decisions to be made in a DT language.  Certainly some of those affect the type checker.
14:22:14 * hackagebot upload: Vec-Transform 1.0.3 - Extends the Vec package with some 4x4 transform matrices (TobiasBexelius)
14:22:39 <MissPiggy> nominolo_: well in the case of extensional equality, type checking is undecidible -- so they have some kind of search programs that try very hard
14:22:46 <sm> building gtk2hs from source on osx 10.5, make says unknown package: glib-0.10.1. I have glib1 1.2.10 and glib2 2.22.2 ports installed. What is it looking for ?
14:23:06 * Cale wonders if benmachine has made any progress on the stepwise evaluator. :)
14:23:30 <Botje> sm: you might need to set PKGCONFIG_PATH to /usr/local/lib/pkgconfig or somesuch
14:23:36 <idnar> kmc_: why can't Maybe be a template class?
14:24:11 <nominolo_> MissPiggy: I see.  BTW, Conor is that you?
14:24:22 <MissPiggy> no I just read all his papers 10x :P
14:24:41 <nominolo_> ah, I didn't think Conor was on IRC
14:25:42 <sm> I gave  PKGCONFIG_PATH=/opt/local/lib/pkgconfig to configure and make, but no difference. configure seems to be seeing glib
14:26:06 * sm gives port install gtk2hs another try
14:26:40 <nominolo_> sm: I think you need to give it more paths
14:26:43 <ziman> how would you calculate indices of an nâœ•n matrix in zig-zag order? All i'm able to think of is an ugly stateful unfoldr and "filter validRange . diagAllNaturals"
14:27:24 <holmak> what kind of zigzag?
14:27:34 <damd> /\/\/\/
14:27:55 <holmak> so, up a column, down a column, ...?
14:28:09 <ziman> well, it should begin with [(0,0),(0,1),(1,0),(2,0),(1,1),(0,2),...
14:28:15 <MissPiggy> ziman: turn the matrix into a function (Integer,Integer)->element
14:28:17 <ziman> diagonal zigzag
14:28:20 <cads> a guy I've met is using "higher order perl" to do functional style programming. He's written an implementation for manipulating permutations. He's basically programming group theory code in PERL http://search.cpan.org/~wsdookadr/CM-Permutation-0.08/
14:28:26 <MissPiggy> then you just need to enumerate the indices
14:28:40 <luqui> ziman, look at Control.Monad.Omega's documentation
14:28:51 <luqui> the upper bound it gives should be exactly the number you want
14:28:51 <roconnor> ziman: dovetailing is easier  cPair a b = a + ((a + b)*(a + b - 1) `div` 2)
14:29:15 <cads> I'm debating whether it's my place to suggest that he might have an easier time doing group theory in a more strongly functional language than perl
14:29:20 <luqui> ziman, oh right, that's the one.  it's not a zigzag.
14:29:45 <luqui> whether you are on a zig or a zag should be (a + b) `mod` 2
14:29:57 <roconnor> > let cPair a b = a + ((a + b)*(a + b - 1) `div` 2) in map (uncurry cPair) (sequence http://en.wikipedia.org/wiki/Special:Search?go=Go&search=0..3],[0..3)
14:29:58 <lambdabot>   <no location info>: parse error on input `='
14:30:02 <MissPiggy> cads let him
14:30:15 <roconnor> bah Konversation
14:30:17 <luqui> roconnor, lol you just blew my mind
14:30:20 <roconnor> > let cPair a b = a + ((a + b)*(a + b - 1) `div` 2) in map (uncurry cPair) (sequence [ [0..3],[0..3] ])
14:30:20 <lambdabot>   Couldn't match expected type `(a, a)' against inferred type `[t]'
14:30:53 <roconnor> > let cPair a b = a + ((a + b)*(a + b - 1) `div` 2) in map (uncurry cPair) ([(x,y) | x <- [0..3], y <- [0..3] ])
14:30:54 <lambdabot>   [0,0,1,3,1,2,4,7,3,5,8,12,6,9,13,18]
14:31:06 <roconnor> oops
14:31:11 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in map (uncurry cPair) ([(x,y) | x <- [0..3], y <- [0..3] ])
14:31:12 <lambdabot>   [0,1,3,6,2,4,7,11,5,8,12,17,9,13,18,24]
14:31:41 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in map (uncurry cPair) ([(x,y) | x <- [0..4], y <- [0..4] ])
14:31:42 <lambdabot>   [0,1,3,6,10,2,4,7,11,16,5,8,12,17,23,9,13,18,24,31,14,19,25,32,40]
14:31:54 <dolio> > let f (Left p) = Just (p, if snd p == 0 then Right (1 + fst p, 0) else Left (1 + fst p, snd p - 1)) ; f (Right p) = Just (p, if fst p == 0 then Left (0, 1 + snd p) else Right (fst p - 1, 1 + snd p)) in unfoldr f (Right (0,0))
14:31:55 <lambdabot>   [(0,0),(0,1),(1,0),(2,0),(1,1),(0,2),(0,3),(1,2),(2,1),(3,0),(4,0),(3,1),(2...
14:32:29 <cads> MissPiggy, I've been invited to learn galois theory and as far as mathematics goes he seems rather knowledgeable. Though I look forwards to discussions with him about topics group theory/algebra/galois theory, I'm surely not looking forwards to code example presented in perl!
14:32:40 <ziman> yeah, that's roughly what I came up with -- but I need to restrict the indices on a nâœ•n matrix
14:32:42 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in  map (map (uncurry cPair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
14:32:43 <lambdabot>   [[0,2,5,9,14],[1,4,8,13,19],[3,7,12,18,25],[6,11,17,24,32],[10,16,23,31,40]]
14:32:55 <MissPiggy> you can learn perl
14:32:59 <MissPiggy> it's not hard
14:33:21 <MissPiggy> anyway isn't the output of the programs the only thing that matters
14:33:34 <MissPiggy> whatever algorithms you use are surely theorems from a book?
14:33:46 <cads> hmm.. I guess I certainly can learn perl.. I hadn't thought of that
14:33:55 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in  map (show . map (uncurry cPair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
14:33:56 <lambdabot>   ["[0,2,5,9,14]","[1,4,8,13,19]","[3,7,12,18,25]","[6,11,17,24,32]","[10,16,...
14:34:12 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in  map (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
14:34:13 <lambdabot>   [[0,2,5,9,14],[1,4,8,13,19],[3,7,12,18,25],[6,11,17,24,32],[10,16,23,31,40]]
14:34:15 * cads 'duh's
14:35:18 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..4]] | y <- [0..4] ])
14:35:19 <lambdabot>   [0,2,5,9,14]
14:35:19 <lambdabot>  [1,4,8,13,19]
14:35:19 <lambdabot>  [3,7,12,18,25]
14:35:19 <lambdabot>  [6,11,17,24,32]
14:35:19 <lambdabot>  [10,16,23,31,...
14:35:33 <roconnor> > let cPair a b = a + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..3]] | y <- [0..3] ])
14:35:34 <lambdabot>   [0,2,5,9]
14:35:34 <lambdabot>  [1,4,8,13]
14:35:34 <lambdabot>  [3,7,12,18]
14:35:34 <lambdabot>  [6,11,17,24]
14:35:39 <ziman> wow
14:35:40 <roconnor> :O
14:35:58 <roconnor> lambdabot doesn't return a leading space on all lines!!
14:36:04 <roconnor> time for some recursive bot action!!
14:36:18 <mauke> look closer
14:36:18 <kmc_> idnar: i didn't say Maybe couldn't be a class template
14:36:21 <ziman> she just returns two on the first one :)
14:36:25 <roconnor> damn it
14:36:41 <cads> roco, tsk tsk
14:36:47 <Alpounet> @type quickCheck
14:36:48 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
14:36:52 <Alpounet> @type (==>)
14:36:52 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
14:36:58 <cads> we must treat lambdabot as a lady.
14:37:54 <roconnor> > let cPair a b = b + ((a + b)*(a + b + 1) `div` 2) in  vcat $ map (text . show . map (uncurry cPair)) ([[(x,y) | x <- [0..3]] | y <- [0..3] ])
14:37:55 <lambdabot>   [0,1,3,6]
14:37:55 <lambdabot>  [2,4,7,11]
14:37:55 <lambdabot>  [5,8,12,17]
14:37:55 <lambdabot>  [9,13,18,24]
14:38:01 <roconnor> I think I like that better
14:38:07 <Peaker> Saizan: ah, interesting (sorry for late response)
14:38:30 <roconnor> I'm suprised that text . show doesn't have a name
14:38:38 <Peaker> Saizan, Cale: I guess richer types / programs will thrive on more interactive editors that partially infer as you work
14:38:51 <aavogt> @remember > test lambdabot
14:38:52 <lambdabot> I will remember.
14:39:01 <mauke> @quote >
14:39:01 <lambdabot> > says: test lambdabot
14:39:26 <mauke> @crash
14:39:26 <lambdabot> Unknown command, try @list
14:39:29 <aavogt> @forget > test lambdabot
14:39:29 <lambdabot> Done.
14:39:35 <mreh> @remember frankie relax
14:39:35 <lambdabot> I will never forget.
14:39:48 <roconnor> @quote preflex:
14:39:48 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
14:40:18 <ezyang> @quote sussman
14:40:19 <lambdabot> JamesIry says: 1970 - Guy Steele and Gerald Sussman create Scheme. Their work leads to a series of "Lambda the Ultimate" papers culminating in "Lambda the Ultimate Kitchen Utensil."
14:40:37 <roconnor> @quote maiden
14:40:37 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
14:40:39 <kmc_> @quote recursion.and
14:40:40 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
14:41:04 <ziman> well, to clarify more, i have an 8x8 array and i want to serialize it zig-zag diagonally (yes, JPEG). I thought "myData = map (array!) (indices 8)" would be the best way because then I can do "array bounds $ zip (indices 8) myData". But I'm stuck on the definition of indices, where I cannot think of anything elegant.
14:41:23 <roconnor> gah, JPEG
14:42:07 <c_wraith> :t (%)
14:42:08 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
14:42:33 <lpjhjdh> could someone explain why I need (f,g) instead of g?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17058#a17058
14:43:14 <aavogt> @type option
14:43:15 <lambdabot> Not in scope: `option'
14:43:27 <aavogt> @type fmap
14:43:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:43:31 <lpjhjdh> If I just have f <- stuff then it seems to make it not polymorhpic
14:43:32 <Saizan> lpjhjdh: real and int have different types
14:43:51 <lpjhjdh> but id and negate are polymorphic
14:43:56 <ziman> but Control.Monad.Omega seems to do what I need so I'm going to dive in the source :)
14:44:12 <Saizan> lpjhjdh: you need a type signature to get that polymorphism
14:44:16 <lpjhjdh> something I'm missing about how the type-system works everything out?
14:44:36 <c_wraith> the monomorphism restriction, probably
14:44:43 <Saizan> no, no MR here
14:44:51 <Saizan> it's just how hindley-milner worksÃ¹
14:45:06 <lpjhjdh> f <- option id (char '-' >> return negate) :: (Stream s m Char, Num a) => ParsecT s u m (a -> a)
14:45:16 <Twey> Worksa sunkÃ¹!
14:45:20 <Saizan> when you use something that's polymoprhic in an expression it gets instantiated
14:45:23 <lpjhjdh> still seems to fail with expected integer
14:45:26 <lpjhjdh> ah
14:45:35 <Saizan> and gets regeneralized again when binded in a let
14:45:35 <lpjhjdh> thanks
14:45:52 <DrTeggy> binded? bound?
14:45:53 <Saizan> toplevel definitions included
14:46:03 <Saizan> yeah, sorry, bound :)
14:47:18 <Saizan> lpjhjdh: lambda bound variables are monomorphic by default, so you'd have to annotate that too
14:48:02 <Saizan> "f <- .." counts as a lambda
14:48:13 <lpjhjdh> right, many thanks
14:48:19 <lpjhjdh> I was deeply disturbed at first
14:50:29 <Saizan> ?type (return id `mplus` return negate :: Maybe (forall a. Num a => a -> a)) >>= \f -> return (f 1, f 1.0)
14:50:30 <lambdabot> forall t t1. (Num t, Fractional t1) => Maybe (t, t1)
14:50:33 <DrTeggy> lpjhjdh: Haskell leaves me deeply disturbed almost every day. :-)
14:50:51 <Saizan> it seems you don't need to for the lambda actually
14:51:06 <Saizan> but you've to move the forall inside the result type.
14:51:06 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs (no context)
14:51:07 <kmc_> mm infected mushroom
14:51:23 <kmc_> eek mauke
14:51:54 <pumpkin> mmm infected mushroom
14:52:06 <absentia> centipede?
14:52:15 <Botje> i was thinking that as well ..
14:52:15 <Saizan> lpjhjdh: seen above? ^^^
14:52:19 <Botje> do they have new cd's out?
14:52:31 <kmc_> Legend of the Black Shawarma
14:52:34 <kmc_> is the most recent one
14:52:36 <kmc_> pretty good too
14:52:46 <pumpkin> I don't have that one
14:52:49 <Twey> mauke: Yay segfault?
14:52:49 <lpjhjdh> Saizan: awesome, I'll have to tinker with these ideas a bit, thanks for the help
14:52:54 <pumpkin> anyone into shpongle?
14:52:59 <kmc_> they're p. good too
14:53:13 <mauke> Twey: needs x86/linux
14:53:16 <ezyang> pretty popular pick on MixApp
14:53:27 <Twey> mauke: x86_64 â˜¹  What's it meant to do?
14:53:32 <jlouis> kmc_: Legend of the black shawarma is good :)
14:53:35 <mauke> hello world
14:53:42 <pumpkin> so many psytrancers in here
14:54:10 <Twey> mauke: And why?
14:54:12 <kmc_> at my school there was a strong overlap between people interested in haskell and people interested in psychedelic drugs
14:54:14 <Botje> so they have!
14:54:16 <kmc_> and so, it's not surprising
14:54:30 <Botje> kmc_++ # updated pointer to infected mushroom
14:54:33 <pumpkin> kmc_: you mean there was more than one person interested in haskell?? or are you just telling us about your interest in drugs?
14:54:39 <mauke> Twey: because I can
14:54:47 <kmc_> order of 10 people
14:54:49 <Twey> mauke: But *how*?  :Ã¾
14:54:49 <theorbtwo> Haskell is often described as a mind-altering experince.
14:54:53 <pumpkin> wow
14:54:58 <pumpkin> impressive
14:54:59 <kmc_> every experience is mind-altering, by definition
14:55:13 <jlouis> kmc_: I also listen to Meshuggah, Opeth, Symphony X, ... go figure :)
14:55:19 <mauke> it is a mystery
14:55:21 <pumpkin> kmc_: how about the experience of being at absolute 0?
14:55:27 <kmc_> sure
14:55:40 <pumpkin> :o
14:55:49 <kmc_> if you experience something, it has altered your mind
14:55:58 <Twey> It's true
14:55:59 <pumpkin> kmc_: but at absolute 0, nothing moves/changes
14:56:10 <kmc_> then you can't experience it
14:56:14 <lpjhjdh> Saizan: is there a way to achieve that without ImpredicativeTypes?
14:56:28 <pumpkin> lpjhjdh: make a custom type with a universal in it
14:56:43 <lpjhjdh> thanks
14:56:45 <pumpkin> is generally the way to avoid impredicative types
14:57:09 <pumpkin> I don't actually know the context of your question though :)
14:57:25 <pumpkin> mmm, rigoletto is over, time for some mushroom
14:57:27 <Saizan> yeah, that's the standard solution
14:57:41 <lpjhjdh> pumpkin: a solution none the less :)
14:57:55 * Saizan wonders how you do this with only a predicative hierarchy of universes
14:58:03 <ezyang> wait, whoa, compumpkin lost the co-?
14:58:09 <ezyang> *copumpkin
14:58:14 <lament> mushroom > rigoletto
14:58:34 <copumpkin> ezyang: nope
14:58:43 <pumpkin> lament: depends on my mood, for me :)
14:58:58 <pumpkin> classical mushroom time
14:59:24 <lpjhjdh> is first class polymorphism just really difficult or something?
14:59:31 * ezyang is now confused! 
14:59:37 <ezyang> Both pumpkins go to dartmouth too...
14:59:46 <pumpkin> lpjhjdh: apparently impredicative polymorphism is really ugly in the typechecker right now
14:59:49 <pumpkin> rank-n is fine
14:59:55 <pumpkin> ezyang: zomg
15:00:28 <pumpkin> lpjhjdh: I don't think it's inherently ugly but it was holding things back so they're taking it out for now until they can find a better solution I think
15:02:15 * Botje just bought the CD
15:02:57 <pumpkin> :)
15:03:42 <Saizan> lpjhjdh: it's quite difficult to do type inference for it
15:03:56 <kmc_> first class polymorphism (e.g. System F) is fine if you aren't doing inference
15:04:02 <kmc_> in fact you might as well do dependent types then
15:04:05 <pumpkin> well, they already aren't doing inference of higher polymorphism
15:04:11 <pumpkin> rank-N and so on aren't inferred
15:04:18 <kmc_> i thought rank-2 was
15:04:32 * pumpkin thought it was possible but we aren't doing it
15:04:48 <Saizan> pumpkin: no inference for lambdas, still you get inference for function applications
15:04:49 <pumpkin> I've never seen an inferred higher-order polymorphic type
15:04:55 <pumpkin> ah
15:05:12 <kmc_> :t runST
15:05:13 <lambdabot> forall a. (forall s. ST s a) -> a
15:05:14 <Saizan> with impredicative types it's hard to get even that
15:05:14 <kmc_> :t \x -> runST x
15:05:15 <lambdabot>     Inferred type is less polymorphic than expected
15:05:15 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
15:05:15 <lambdabot>         x :: ST s a (bound at <interactive>:1:1)
15:05:19 <kmc_> aha
15:05:25 <kmc_> eta expansion fail :/
15:05:26 <pumpkin> :)
15:05:33 <c_wraith> :t runST ?x
15:05:34 <lambdabot>     Could not deduce (?x::ST s1 a) from the context ()
15:05:34 <lambdabot>       arising from a use of implicit parameter `?x'
15:05:34 <lambdabot>                    at <interactive>:1:6-7
15:05:38 <pumpkin> :t (runST .)
15:05:39 <lambdabot> forall a (f :: * -> *). (Functor f) => f (forall s. ST s a) -> f a
15:05:41 <kmc_> :t \(x :: forall s. ST s a) -> runST x
15:05:43 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
15:05:43 <lambdabot>       unless the pattern has a rigid type context
15:05:43 <lambdabot>     In the pattern: x :: forall s. ST s a
15:05:45 <pumpkin> :t (. runST)
15:05:47 <lambdabot> forall a b. (a -> b) -> (forall s. ST s a) -> b
15:05:49 <kmc_> bleh?
15:06:14 <kmc_> :t let f x = runST x in f
15:06:15 <lambdabot>     Inferred type is less polymorphic than expected
15:06:15 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
15:06:15 <lambdabot>         x :: ST s a (bound at <interactive>:1:6)
15:06:18 <Saizan> like the whole runST $ foo vs. runST foo problem.
15:06:21 <pumpkin> yeah
15:06:24 <kmc_> :t let f :: (forall s. ST s a) -> a; f x = runST x in f
15:06:25 <lambdabot> forall a. (forall s. ST s a) -> a
15:06:28 <pumpkin> $ actually works okay most of the time
15:06:35 <pumpkin> (.) doesn't, but I was unable to get it to misbehave
15:07:06 <kmc_> :t let f :: (forall a. a) -> (); f _ = () in f ?x
15:07:07 <lambdabot>     Could not deduce (?x::a) from the context ()
15:07:07 <lambdabot>       arising from a use of implicit parameter `?x'
15:07:07 <lambdabot>                    at <interactive>:1:44-45
15:07:14 <c_wraith> :t let x = return "foo" in print . runST $ x
15:07:16 <lambdabot>     Cannot match a monotype with `forall s. ST s a'
15:07:16 <lambdabot>     When matching `forall s. ST s a'
15:07:16 <lambdabot>               and `forall s. ST s a'
15:07:24 <kmc_> implicit params cannot have polymorphic type?
15:07:30 <c_wraith> pumpkin, was that the error you were looking for?
15:09:10 <Saizan> mh, HM is like having defaulting for polymorphism
15:10:06 <pumpkin> c_wraith: there's some nasty behavior doing seemingly innocent things with (.) and higher-rank polymorphic functions, but I couldn't remember the details
15:10:08 <Saizan> "this variable could have lots of types, let's default to the less polymorphic one"
15:10:30 <pumpkin> :t runST . return
15:10:31 <lambdabot>     Couldn't match expected type `forall s. ST s a'
15:10:31 <lambdabot>            against inferred type `m a1'
15:10:31 <lambdabot>       Expected type: a1 -> forall s. ST s a
15:10:44 <pumpkin> :t \x -> runST (return x)
15:10:45 <lambdabot> forall a. a -> a
15:11:05 <pumpkin> :t \x -> runST $ return x
15:11:06 <lambdabot> forall a. a -> a
15:11:44 <Saizan> i guess they never implemented the system described in the last FPH paper
15:15:15 <merehap> @pl \f (x,y) -> (f x, f y)
15:15:15 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:15:27 <Alpounet> huh ?
15:15:35 <merehap> wow, that makes me sad
15:15:53 <dolio> join (***)
15:15:54 <merehap> is there seriously no library function to do that?
15:15:58 <merehap> ah
15:16:11 <merehap> thanks dolio
15:16:14 <Twey> > join (***) succ (3, 4)
15:16:15 <lambdabot>   (4,5)
15:16:43 <pikhq> I'm pretty sure @pl is just not aware of the arrow functions.
15:16:44 <merehap> why doesn't pl know about join?
15:16:54 <merehap> clearly it would have given better advice...
15:16:56 <Twey> I think it does
15:17:00 <pikhq> @pl f x x
15:17:00 <lambdabot> f x x
15:17:05 <Twey> @pl \x -> f x x
15:17:05 <lambdabot> join f
15:17:09 <pikhq> Erm.
15:17:20 <pikhq> merehap: It's (***) it doesn't know about.
15:17:32 <pumpkin> :t \x -> x x
15:17:32 <dolio> @pl \(x, y) -> (f x, g y)
15:17:33 <lambdabot> f *** g
15:17:33 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:17:33 <lambdabot>     Probable cause: `x' is applied to too many arguments
15:17:33 <lambdabot>     In the expression: x x
15:17:35 <pikhq> @src (***)
15:17:36 <merehap> ah, got it, thanks y'all
15:17:36 <lambdabot> f *** g = first f >>> second g
15:17:46 <pumpkin> :t \(x :: forall x. x -> x) -> x x
15:17:47 <lambdabot> forall x. (forall x1. x1 -> x1) -> x -> x
15:26:00 <brad_larsen> template haskell question:  in ghc, Haskell pattern quasiquotes are not implemented.
15:26:21 <brad_larsen> :t [p| _ |]
15:26:21 <lambdabot> parse error on input `]'
15:26:33 <brad_larsen> (ahh, lambdabot doesn't do template haskell?)
15:26:53 <brad_larsen> are they not implemented because it is really tricky in ghc, or because there hasn't been demand?
15:26:55 <brad_larsen> anyone know?
15:27:13 <lpjhjdh> I thought 6.12 added quasi-quoters
15:27:24 <lpjhjdh> ooh, nm, misread your question
15:27:24 <kmc_> lunabot does TH
15:27:27 <kmc_> but is not alive
15:27:33 <kmc_> lunabot is all TH-based
15:27:48 <brad_larsen> lpjhjdh: yeah, I'm playing around with quasiquoters now  :-)
15:28:27 <brad_larsen> working on embedded DSL stuff, source-to-source transformations
15:28:52 <brad_larsen> quasiquoters would be really handy for doing different codegen passes
15:29:05 <kmc_> ah, you mean a pattern quote
15:29:17 <kmc_> in GHC's terminology a "quasiquote" is a quote of a language other than Haskell
15:29:17 <brad_larsen> and I think I'll eventually end up providing quasiquoters for the EDSL, because Haskell doesn't let me overload its syntax as much as I'd like
15:29:22 <kmc_> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#th-quasiquotation
15:29:27 <kmc_> those are implemented, for patterns and expressions
15:29:31 <brad_larsen> kmc_: yes, a pattern quote
15:30:09 <kmc_> and there are modules on hackage to quasiquote Haskell source, parse it with haskell-src-exts, and then convert that AST into a TH AST
15:30:12 <brad_larsen> kmc_: i'm looking for the Template Haskell [p| ... |] quotation
15:30:19 <kmc_> yes, GHC does not have that afaikx
15:30:24 <brad_larsen> which is in the TH paper, but not supported
15:30:35 <kmc_> http://hackage.haskell.org/package/haskell-src-meta has some goodies
15:30:39 <kmc_> HsHere is neat
15:33:13 <kmc_> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
15:34:31 <brad_larsen> kmc_: ahhh, I see, Language.Haskell.Meta.QQ.Hs
15:34:38 <brad_larsen> seems to work...?
15:34:40 <brad_larsen> playing with it now
15:34:49 <kmc_> QQ is convenient for writing source-to-source transformations on an object language which is not necessarily anything like Haskell
15:37:23 <ivanm> jfredett: my apologies for the lack of noise recently, but I'm busy getting ready to move, etc.
15:37:23 <ivanm> ;-)
15:41:45 <brad_larsen> kmc_: yes, such as generating C code (which is one thing I am interested in doing)
15:47:35 <brad_larsen> are there quasiquoters anywhere for the languace-c package on hackage?
15:55:37 <gwern> hm. I wonder if there are any guidelines on 'how to write English so the recipient - who may be Japanese with English as a second language - can understand it?'
15:56:06 <Twey> Avoid phrasal verbs :Ã¾
15:56:33 <gwern> Twey: which would be?
15:56:44 <Twey> Things like â€˜to put up withâ€™
15:56:48 <Twey> â€˜To take outâ€™
15:56:56 <Dashkal> Would someone be willing to give me a quick sanity check on a monad definition I just wrote? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17059#a17059
15:57:06 <Twey> Good advice for writing accessible English in general, actually
15:57:10 <Dashkal> RWH didn't do it this way, but this seems like it should work.
15:57:25 <gwern> Twey: hm. 'I am interested in whether Mr. Sakurai said the following quote. But I have not found the quote on the Production I.G. website.' doesn't obviously use one to my eyes
15:57:33 <gwern> but I'm not sure what a phrasal verb is still
15:58:24 <Twey> Yeah, looks accessible to me
15:58:28 <gwern> oh well. I've written it as simply as I can
15:58:33 <gwern> (fire and forget)
15:59:17 <gwern> oh shoot
15:59:28 <gwern> in retrospect I should've seen whether it survives a roundtrip through google translate
15:59:33 <Twey> Yes, that's the idea of â€˜fire and forgetâ€™ :Ã¾
15:59:42 <Twey> I don't think that would be a particularly useful statistic
16:00:20 <gwern> Twey: no, it is useful, since it tells me, without any japanese understanding, whether my recipient can, at the limit, run it through a machine translator to understand it
16:01:28 <Twey> gwern: But if something gets horrendously mistranslated by the translator, you don't know if it was in the en->ja phase or the ja->en phase
16:01:46 <gwern> Twey: it is a necessary but not sufficient condition
16:02:10 <doserj> Dashkal: looks ok. You can also use -XGeneralizedNewtypeDeriving and just derive the Monad instance
16:02:13 <brad_larsen> Dashkal:  I'd just `deriving (Monad)' Game
16:02:33 <Dashkal> yeah, suppose I should get over my fear of -X...
16:03:14 <Twey> gwern: If it's in the ja->en phase, then you have nothing to worry about anyway
16:03:53 <Twey> But frankly, I wouldn't worry about it too muchâ€¦ it's the reader's job to discern what you meant, assuming you used correct language, and there are plenty of people in Japan to whom the recipient could show it should they have trouble deciphering it
16:05:55 <gwern> Twey: when asking favors online, the slightest thing can cause them to discard your email
16:06:36 <Twey> Hmm, I don't think I would discard it for using language beyond my ken
16:06:43 <Twey> Very poor grammar, maybe
16:06:46 <gwern> I get no answers to many of my cold emails, even when I know for sure it's active and was read
16:07:50 <Twey> Dashkal: Don't think of it as -Xâ€¦ think of it as {-# LANGUAGE #-}â€¦ ;)
16:09:15 <Dashkal> Twey: Same deal.  I hesitate about moving beyond the base language simply because I don't yet understand the implications very well.
16:09:27 <Dashkal> Simply a matter of reading the docs on those specific pragmas
16:11:02 <Twey> I think the best way to learn what they're for is to come to need them on your own.
16:11:06 <Twey> Like many things.
16:11:40 <Dashkal> The other thing is if it's just a convience, I don't want to use it until I understand the hard way.  With that implementation for monad I just linked, I finally got it.
16:13:48 * ddarius does some short experiments with a third bridge.
16:15:01 <mornfall> Hm. What does WHNF mean for a list?
16:15:08 <gwern> I feel utterly dispirited now in trying to borrow yi's unicodifying for gitit
16:15:26 <mornfall> Is that (:) x y for x y possibly being thunks?
16:15:32 <ddarius> mornfall: Or [], yes.
16:15:55 <Raynes> @src reverse
16:15:55 <lambdabot> reverse = foldl (flip (:)) []
16:16:04 <Cale> mornfall: Yeah, either [] or (:) x y, where x and y are arbitrary expressions
16:16:12 <ddarius> In general, WHNF means C E1 E2 ... En for constructor C and arbitrary expressions Ei.
16:16:17 <Cale> Or a lambda
16:16:36 <Twey> Are lambdas and thunks distinct?
16:16:44 <ddarius> Yes.
16:16:44 <mornfall> If I force the spine of a filtered list, is that enough to GC the filtered-out bits?
16:16:48 <Cale> thunks are an implementation mechanism for expressions
16:16:48 <Twey> 'kay
16:16:58 <ddarius> mornfall: Probably.
16:17:30 <luqui> nontrivial thunks are always applications
16:17:35 <Cale> An expression is in weak head normal form if it is either an unapplied lambda, or it is a data constructor (possibly applied to any expressions)
16:17:44 <luqui> or cases i guess.  i don't believe in those.
16:17:57 <Cale> Or, I suppose, if it is a let/in, whose in-part is in WHNF.
16:18:14 <Cale> case expressions are not in WHNF.
16:18:17 <mornfall> Well, the lambda is allowed in WHNF and not in HNF, IIUIC.
16:18:47 <Cale> A lambda is in HNF if and only if its body is in HNF.
16:18:55 <mornfall> Aye.
16:18:58 <luqui> for HNF you need to evaluate under lambda.  I.e. the leftmost application must have a bound variable on the left
16:19:03 <mornfall> For WHNF, a lambda with anything in it is OK.
16:19:16 <mornfall> Okey.
16:20:08 <mornfall> And NF is everything forced down and through, right? I.e. no unevaluated applications at all...
16:20:26 <Cale> Yeah.
16:20:50 <mornfall> So what'd be the right way to implement NFData instance? I tried rnf f@(Foo x y) = rnf x `seq` rnf y `seq` f `seq` () to no avail...
16:21:19 <Cale> The seq f there is redundant.
16:21:29 <mornfall> Well, it probably does *something* but not what I'd expect it to do.
16:21:35 <mornfall> Or maybe there's a catch I don't see.
16:21:41 <Cale> You already have to evaluate f into WHNF in order to pattern match.
16:21:50 <mornfall> Right.
16:22:04 <Cale> That looks fine to me. What's wrong with it?
16:23:10 <mornfall> Well, if I say "modify `using` rnf" I leak ... if I put "`using` rnf" at the right places inside modify, I don't leak. And that puzzles me to no end.
16:23:50 <Cale> Have you looked at the definition of using?
16:24:04 <mornfall> I would assume that the outside `using` clause would subsume anything that could be 'inside' the expression.
16:24:11 <mornfall> No, not really.
16:24:17 <Cale> using x s = s x
16:24:43 <Twey> using = flip id?
16:24:48 <mornfall> That must be different using.
16:24:55 <mornfall> This comes from Control.Parallel.Strategies.
16:25:06 <mornfall> a -> Strategy a -> a
16:25:08 <Cale> I'm talking about the one from C.P.Strategies
16:25:25 <Cale> type Strategy a = a -> ()
16:25:48 <Cale> Or  a -> Done  where Done is yet again a type synonym for ()
16:25:56 <mornfall> Hm.
16:26:08 <Cale> hmm
16:26:12 <mornfall> How does the 'a' end up in the result then?
16:26:23 <Cale> Maybe it was  s x `seq` x
16:26:23 <mornfall> I'd say using x s = s x `seq` x
16:26:25 <Cale> yeah
16:26:43 <mornfall> Which *should* do what I want. I think, at least.
16:27:01 <Cale> So, when you write something like  modify foo `using` rnf, it just rnf's the "modify foo".
16:27:15 <Cale> Which in the State monad doesn't do a whole lot, since the inside of a State computation is just a lambda
16:27:38 <mornfall> Well, this ain't a State's modify.
16:27:39 <Cale> (and even though it claims to reduce to normal form, the best you can really do is weak normal form)
16:27:42 <Cale> Oh, okay
16:27:51 <Cale> What sort of modify is it then?
16:27:52 <mornfall> Although State.Strict is involved.
16:28:22 <mornfall> Cale: Well, the thing is I have a data structure and something that changes that data structure in a pure way. Now under normal circumstances, references to the old version linger.
16:28:43 <mornfall> Cale: And when I want to get rid of those references, because I am continuously changing the structure, I need to somehow force evaluation.
16:28:50 <Vanadium> Am I the only one who is constantly confused between Monoid and MonadPlus?
16:29:00 <Cale> Vanadium: Well, they're closely related.
16:29:03 <mornfall> And I haven't found a way other than making the operation strict.
16:29:20 <Cale> Vanadium: MonadPlus is for a specific sort of monoid which interacts nicely with the monad structure.
16:29:33 <mornfall> Say there's a big list that I repeatedly filter, eg.
16:30:57 <Cale> You generally need strictness wherever your computation is turning data with a large number of separately-evaluable parts into data with a small number of separately-evaluable parts.
16:31:25 <Cale> Repeatedly filtering a list is a bit of a hard one to call.
16:31:27 <ddarius> Vanadium: Yes.  They aren't even the same kind.  (One is a type class, the other is a constructor class.)
16:31:38 <Cale> Strictness might help, but it might also hurt you.
16:31:49 <Cale> It depends on how many elements get removed.
16:33:06 <Cale> Oh, looking at Control.Parallel.Strategies, it looks like they've adjusted some of the definitions
16:33:34 <Vanadium> kind?
16:33:40 <ddarius> :k Maybe
16:33:41 <lambdabot> * -> *
16:33:41 <ddarius> :k Int
16:33:42 <lambdabot> *
16:33:44 <Vanadium> :k Monoid
16:33:45 <lambdabot> Class `Monoid' used as a type
16:33:58 <Cale> :t mappend
16:33:59 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:34:03 <Cale> :t mplus
16:34:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:34:09 <ddarius> It's not completely appropriate to say a class has a kind, but you can say it classifies certain kinds.
16:34:22 <ddarius> (Though if we had kind polymorphism, some classes could classify infinite kinds.)
16:34:43 <Cale> The typeclass dictionary type constructor has a kind.
16:35:03 <ddarius> class Cat (hom :: forall k. k -> k -> *) where ...
16:39:17 <dolio> You don't want that. hom Maybe Either isn't going to be right.
16:39:35 <dolio> Or, hom Maybe [], since those are actually the same k.
16:39:57 <ddarius> What's wrong with that?  (Note, I have actual applications for Category having that kind.)
16:40:20 <Alpounet> @index MonadPlus
16:40:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:40:48 <dolio> Because those are unlikely to be objects in the same category as Integer and Char.
16:41:06 <Vanadium> So is MonadPlus m basically the same as wrapping MaybeT around m?
16:41:24 <Cale> Vanadium: er, no?
16:41:37 <dolio> And having hom be forall k. means every category is going to admit objects of all kinds.
16:41:50 <dolio> Which is even worse than it is currently.
16:42:16 <Cale> Vanadium: Though, MaybeT has a general instance of MonadPlus (albeit one which ought to be MonadOr)
16:42:20 <Twey> Vanadium: No, you write your own mzero/mplus methods.  They don't have to be Maybe's.  That's the point of the typeclass.
16:42:23 <ddarius> dolio: They are objects in the functor category Hask -> Hask.
16:42:31 <Alpounet> is mplus over Maybe a actually useful ?
16:42:37 <Cale> Alpounet: Sure.
16:42:39 <Twey> Sure
16:42:51 <Cale> Alpounet: It's great for combining configuration options.
16:43:02 <Alpounet> Cale, would you mind giving an example ?
16:43:06 <Twey> Or writing â€˜filterâ€™ :Ã¾
16:43:08 <ddarius> dolio: I guess it is really the class, Category, that would have the polymorphic kind.
16:43:10 <dolio> ddarius: Yeah, but I think what you want is a kind parameter to the class, not for hom to be polymorphic in kinds.
16:43:14 <ddarius> I'm not sure how to notate.
16:43:20 <ddarius> +it.
16:43:31 <ddarius> That was my intent.
16:43:35 <mornfall> Ok, it seems that length foo `seq` foo works to eliminate references that have been filtered out of foo.
16:43:43 <mornfall> Now the question becomes, what of M.Map?
16:43:47 <mornfall> I mean, Data.Map.
16:44:05 <Cale> Alpounet: Well, suppose you have a program which supports default, system-wide, and user level configuration options.
16:44:12 <ddarius> dolio: So the example you should have given is: I don't want hom Int Int and hom Maybe [] for the same hom.
16:44:22 <Twey> filter = fmap rights . flip ap id . fmap (zipWith $ Right ?? Left) . fmap
16:44:24 <Twey> Muhaha
16:44:26 <dolio> Yeah, true.
16:44:29 <Cale> Alpounet: You might define a datatype with a bunch of fields, each of type Maybe t for some t.
16:44:39 <Alpounet> yeah
16:44:55 <Cale> Alpounet: The config file parser might leave some of the fields Nothing, if the options aren't set by the parsed configuration.
16:45:14 <Alpounet> indeed, yes
16:45:24 <Cale> You could then define a Monoid instance, which makes use of the Maybe mplus, to combine sets of config operations, layering one on top of the other.
16:45:33 <Cale> (in a first-setter-wins sort of way)
16:45:42 <Twey> Last- would be more useful
16:45:51 <Cale> Well, it's basically the same thing.
16:45:56 <Twey> Ah, yeah
16:46:18 <Alpounet> hmm okay I see now
16:46:19 <Cale> In the end, you'd write something like  userConfig `mappend` systemConfig `mappend` defaultConfig
16:46:28 <Vanadium> Hmm, thanks.
16:46:33 <Cale> and that mappend would make use of the mplus for Maybe
16:46:43 <Twey> :t mappend
16:46:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:46:44 <Alpounet> thank you Cale !
16:46:46 <Twey> :t mplus
16:46:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:46:51 <Twey> Ah, yeah
16:47:00 <Cale> The mappend for Maybe is also useful, and does something completely different
16:47:12 <Twey> Annoying that they're both prefixed m-
16:47:20 <dolio> ddarius: While you're at it, you might want kinds like * x *, and possibly some others.
16:47:45 <ddarius> dolio: Actually, I do.  You can find me in the #haskell logs saying that I want kind polymorphism and kind products.
16:48:14 <Cale> instance Monoid a => Monoid (Maybe a) where
16:48:14 <Cale>   mempty = Nothing
16:48:14 <Cale>   Nothing `mappend` m = m
16:48:14 <Cale>   m `mappend` Nothing = m
16:48:14 <Cale>   Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)
16:51:59 <temoto> Cale, today i learned that (.) = fmap :) guys were mentioning you about this for some reason.
16:52:30 <lament> temoto: for some definition of "="
16:53:35 <temoto> lament, for equal signature and usage.
16:56:04 <mietek> Linking QuickCheck swaps my 256MB slice to all hell.
16:56:20 * ddarius use to be able to not compile Hat.
16:56:26 * ddarius doesn't know if he can now.
16:59:10 <temoto> mietek, we usually build stuff at our local machine in the office with the same arch as nodes and then distribute binary packages.
17:01:41 <mietek> temoto: unfortunately, I don't have the pleasure of having another AMD64
17:02:02 <mietek> I guess I'm going to have to resize-compile-resize once again.
17:02:27 <temoto> mietek, i'm on amd64 right now. Have ghc 6.10.4.
17:06:43 * hotaru2k3 needs to stop buying ARM machines and get an amd64
17:07:14 <ddarius> Years of guitar (and also bass and banjo) have made playing a fretless instrument less difficult.
17:08:31 <temoto> ddarius, by fretless do you mean amd64? :)
17:10:08 <Axman6> hotaru2k3: i'll take them off your hands if you like :o
17:10:56 <Twey> I don't knowâ€¦ amd64 has made me fret plenty of times
17:14:02 <hotaru2k3> Axman6: i didn't say i wanted to get rid of any... there's a reason i keep buying them :Ã¾
17:14:20 <Axman6> but... i want one :(
17:28:33 <mietek> temoto: thanks for the offer, but I can't do it right now; it's too late here. :)  Cheers.
17:41:31 * hotaru2k3 googles to determine if any progress has been made on ghc on ARM... and decides that was a bad idea
17:43:50 <drdr> it wa a terribly retarted idea
17:43:58 <drdr> there isnt a arm good enough for haskell
17:44:21 <noknok> Hi there! Can anybody recommend a good XML tool for Haskell? hxt looks promising and has a good documentation, but I can't get it installed. HaXML is installed now (easy with cabal), but I can't find an introduction.
17:44:30 <hotaru2k3> oh well... at least i have hugs
17:44:33 * Zao is trying to make an "arm and a leg" joke, but fails.
17:45:01 * drdr is trying to use arm on leg...
17:45:09 * drdr fails
17:45:11 <Zao> Try on Oleg instead.
17:45:11 <BMeph> hotaru2k3: HOld out until the Touch Book comes out... :)
17:45:21 <gwern> noknok: how heavy duty are your needs?
17:47:00 <noknok> I am prepared to do a thorough study. I am thinking of writing some tool for MathML.
17:48:40 <hotaru2k3> BMeph: dammit
17:52:39 <hotaru2k3> i need an amd64 machine, not another ARM
17:59:38 <temoto> Zao, who is Oleg?
18:00:02 <philed> @let witness = (\x k -> k x) :: Show a => a -> (forall b. Show b => b -> r) -> r
18:00:03 <lambdabot>   Parse error: DoubleArrow
18:00:05 <mgsloan> even better is "what's an oleg?"
18:02:22 <Zao> temoto: Oleg is a legendary Haskellite which can bend spoons and the type system with his mind.
18:02:48 <Zao> http://okmij.org/ftp/Haskell/
18:03:19 <temoto> Zao, the one who done this new strict lazy IO?
18:03:46 <Kostafey> Can you help me with one small question? Is it pissible to learn the index of the list's element in function, called by map?
18:04:17 <Zao> Kostafey: You can map over   zip [0..] xs
18:04:24 <Zao> Or just replace the map with zipWith.
18:04:41 <Zao> > zip [0..] "hello"
18:04:42 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
18:05:05 <temoto> Kostafey, technically, there is no index in linked list. You can create a loop list, how would you reason about index then?
18:05:35 <Zao> temoto: The distance from an arbitrary point.
18:05:41 <Kostafey> so, then use map for new list [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]?
18:06:46 <Zao> > zipWith (\a b -> replicate a b) [0..] "hello"
18:06:47 <lambdabot>   ["","e","ll","lll","oooo"]
18:06:50 <temoto> Zao, i mean maybe the task is not about indexes at all.
18:07:37 <Zao> Kostafey: There's many solutions; I've enumerated two.
18:07:40 <Kostafey> temoto: the index number nedeed for the read the same element's index from other list/
18:07:59 <Zao> Do note that indexing lists is costly.
18:08:01 <temoto> Kostafey, see, you need arrays anyway.
18:08:18 <temoto> Kostafey, or, zip those lists in first place.
18:08:28 <Zao> If you want to traverse them simultaneously and process elements pairwise, a zip is all you need.
18:08:33 <Kostafey> Zao: zapWidth?
18:08:38 <Zao> It depends on what operation you want to perform.
18:08:56 <Zao> Which brings us to the question: What is it you're trying to do?
18:09:19 <Kostafey> THANKS EVERYONE!!!
18:09:27 <temoto> ( i used to hate this part on #python ) :)
18:10:46 <Kostafey> I need zap for this two list before the call map - it's solution.
18:12:19 <Zao> Note that it's "zip", as in the zipper you have on clothes.
18:12:40 <Zao> @src zip
18:12:40 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
18:12:40 <lambdabot> zip _      _      = []
18:13:41 <temoto> I wonder why zip is not defined in terms of zipWith.
18:15:33 <Kostafey> It's awesome answer speed, I'm surprised, as I'm newble in channel!
18:15:36 <Zao> temoto: The Report defines zip = zipWith (,)
18:16:17 <temoto> Zao, lambdabot has wrong definition then?
18:16:24 <Zao> temoto: "wrong" is not the right word.
18:16:27 <Zao> They're semantically equivalent.
18:16:59 <Zao> And likely a decent optimization opportunity.
18:17:17 <Zao> I wouldn't be surprised if there's a tonne of fusion, inlining and other deep magic around too.
18:17:24 <temoto> Previous statement should make them equal to optimizations. :)
18:17:49 <temoto> Kostafey, yes, this is a pretty active channel in 24/7.
18:19:05 <Zao> temoto: In honor of #python - "lol"
18:22:02 <temoto> Zao, sorry, "in honor of #python"?
18:23:07 <Zao> temoto: It's a bannable offense (at least when I was around) to say "lol" in #python.
18:23:19 * pumpkin joins #python to find out
18:24:21 <Zao> I wonder if I should take some time to hack up some kind of parser instead of this wild regexing.
18:24:51 <Zao> I'm trying to parse C, heh.
18:25:41 <temoto> Zao, i know, but i don't get what is that lol related to.
18:25:43 <c_wraith> Zao: http://hackage.haskell.org/package/language-c-0.3.1.1
18:25:51 <hotaru2k3> zao: use an existing parser
18:27:31 <Zao> That's out, as it seems to require an unix environment to build.
18:27:51 <Zao> I do not wish to impose that as a dependency just for building a library.
18:28:15 <gwern> it uses happy and alex
18:28:18 <gwern> surely those work
18:28:35 <Zao> directory seems to require a configure script.
18:28:39 <gwern> oh
18:28:50 <gwern> well if you can't use  core libs like directory...
18:28:53 <Zao> Which it seems to want to rebuild even though there's a directory of the same version in my ghc-pkg list.
18:29:19 <gwern> you could probably remove the Language.C.System modules
18:29:24 <gwern> I bet those are the ones using directory
18:29:57 <Zao> What disturbs me is that there's a perfectly fine directory-1.0.1.0 in the global list of ghc-pkg, but cabal still tries to build directory-1.0.1.0
18:30:16 <Zao> And failing, I might add.
18:30:47 <gwern> I don't understand why it does that so much, but I'm sure dcoutts had a good reason for making it do that
18:31:07 <Zao> It'd be fine, except that it doesn't manage to configure properly.
18:32:10 <Zao> Oh well, I doubt that it would be able to parse this code properly anyway, as there's non-GNU extensions in it.
18:33:24 <sshc> are package and executable names with hyphens in them valid?
18:38:54 <temoto> sshc, sure haskell doesn't care how you name your executable. 'language-c' sounds like a packagge with hyphen in name.
18:39:32 <sshc> temoto: I don't think it will be, actually, because how will I import Cabal.Packge-Name.Etc?
18:40:30 <Zao> A dash in a package name tends to map roughly to a . in a module hierarchy.
18:40:37 <Zao> My bindings-directx has Bindings.DirectX.*
18:41:44 <temoto> I think that's because Bindings.DirectX makes sense as a name in namespace Bindings, like System.IO etc
18:42:25 <temoto> Loopy-loops, obviously shouldn't be Loopy.Loops.
18:43:46 <temoto> sshc, yes, hyphens in module names are prohibited.
18:43:54 <temoto> too bad
18:47:27 <Astro> hm, how do I find the equivalent for: f (a -> b) -> a -> b ?
18:47:34 <Astro> I'm quite new to Applicatives
18:48:09 <Axman6> looks a lot like f a -> a to me, which isn't generally possible i believe
18:48:39 <Astro> aw
18:48:46 <temoto> looks like unlift . id :)
18:48:52 <Astro> I meant f (a -> b) -> a -> f b
18:49:02 <temoto> :t >>=
18:49:03 <lambdabot> parse error on input `>>='
18:49:07 <temoto> :t (>>=)
18:49:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:49:16 <Astro> :t (=<<)
18:49:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:49:22 <temoto> yeah
18:49:33 <Zao> All you need is a generalized unsafePerformIO for arbitrary monads :P
18:49:44 <Zao> Err, arbitrary F.
18:50:17 <temoto> unsafePerformFunctor?
18:50:48 <Astro> currently my code looks like ... <*> (pure $ ...)
18:51:03 <Axman6> foo f a = f <*> pure a
18:51:22 <Axman6> :t let foo f a = f <*> pure a in foo
18:51:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
18:51:29 <Axman6> hoorah!
18:51:41 <temoto> Astro, which is fine, no?
18:51:46 <Astro> absolutely
18:51:53 <Astro> I just didn't want to invent my own function for that
18:52:11 <Axman6> @pl foo f a = f <*> pure a
18:52:11 <lambdabot> foo = (. pure) . (<*>)
18:52:22 <temoto> @djinn forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
18:52:23 <lambdabot> Cannot parse command
18:53:46 <Astro> ok, I'm committing <*> (pure $ ...) and will wait what upstream says :)
18:54:46 <temoto> Probably this doesn't worth so much attention as long as it works as expected and easily understood (it is).
18:55:27 <sshc> Zao: so a hyphen in a package name *is* valid?
18:55:50 <sshc> I should probably use an underscore
18:55:55 <sshc> or nothing at all
18:56:34 <Axman6> _--
18:56:39 <Axman6> @karma _
18:56:40 <lambdabot> _ has a karma of -1
18:56:44 <Axman6> damn right
18:56:54 <ski> @type flip
18:56:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:57:03 <Axman6> >_<
18:57:13 <temoto> wow
18:57:24 <ski>   flip f a = fmap ($ a) f
18:57:36 <ski> (that's Caleskell)
18:57:45 <Zao> sshc: Judging by the hackage index, very much so.
18:57:48 <Axman6> and god how i wish he would remove it
18:58:16 <temoto> Remove what?
18:58:21 <Axman6> caleskell
18:58:23 <Axman6> all of it
18:58:26 <sshc> @C--
18:58:27 <lambdabot> Unknown command, try @list
18:58:30 <sshc> C--
18:58:35 <sshc> @karma C--
18:58:35 <lambdabot> C-- has a karma of 3
18:58:35 <temoto> Remove from where?
18:58:51 <Axman6> removing it will annoy _noone), keeping it there pisses off quite a few people. the man refuses to see reason
18:59:18 <ski> Astro : so, you don't need `Applicative', just `Functor' : `\f a -> fmap ($ a) f'
18:59:23 <temoto> Keeping it where?
18:59:28 <Axman6> in lambdabot
18:59:32 <temoto> oh
18:59:52 <temoto> You want it to print other type?
19:00:07 * ski assumes removing it will annoy Cale :)
19:00:47 <dolio> Cale's the only one who could remove it anyway, presumably.
19:00:48 <Axman6> the type of flip is supposed to be (a -> b -> c) -> b -> a -> c, that's how the report defines it, and having it consistent makes life a hell of a lot easier for people who are having problems. keeping it as it is just makes the types even harder to decipher for people who are trying to learn
19:00:56 <Axman6> dolio: yes
19:00:59 <Axman6> and he refuses to
19:01:16 <tensorpudding> @type flip
19:01:17 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:01:24 <tensorpudding> hmm
19:01:40 <tensorpudding> that's not flip
19:01:56 <dolio> It's a generalization of flip, technically.
19:01:58 <tensorpudding> @type (<*>)
19:01:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:02:05 <tensorpudding> not quite <*>
19:02:08 <Axman6> @src flip
19:02:08 <lambdabot> flip f x y = f y x
19:02:21 <Axman6> see, the type doesn't even match the source >_<
19:02:29 <temoto> it matches :)
19:02:48 <Astro> ski: thanks for the hint
19:02:50 <temoto> The source is done as flip for instance of Functor ((->)t)
19:03:04 <temoto> same as for (.) = fmap and friends
19:03:06 <tensorpudding> well, it's the same with (.)
19:03:09 <Axman6> it's as the report defines it, as it should be
19:03:45 <temoto> I like Cale's version, but staying consistent with standard is important too.
19:04:19 <Axman6> i don't have a problem with cale's version, and i like it too. but this is not the place for it
19:04:49 <Axman6> this is a place of learning, and it's making the already steep learning curve even steeper
19:05:02 <ski> having a `Caleskell' module in lambdabot, or a way to say which variant you want, would be ok, imo
19:05:02 <temoto> More interesting is why it works...
19:05:19 <temoto> > (*2) . [1,2]
19:05:20 <lambdabot>   [2,4]
19:05:22 <Axman6> yes, i'd have no problem with using C.flip
19:05:25 <temoto> Why it works?
19:05:30 <tensorpudding> i don't think it's too bad that it isn't the correct one
19:05:35 <Axman6> fmap (*2) [1,2]
19:05:47 <temoto> (.) is not defined as fmap
19:05:52 <Axman6> yes it is
19:05:58 <temoto> @src (.)
19:05:58 <lambdabot> (f . g) x = f (g x)
19:06:02 <Axman6> :t (.)
19:06:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:06:04 <temoto> see, it's not
19:06:09 <Axman6> yes, is, look
19:06:11 <tensorpudding> it's not defined using fmap
19:06:15 <Axman6> it is*
19:06:32 <doserj>  @src doesn't show the real source
19:06:37 <temoto> That's caleskell type.
19:06:43 <Axman6> tensorpudding: @src and the actual caleskell versions don't correspond at all
19:06:44 <tensorpudding> but yeah, that type is wrong
19:08:13 <tensorpudding> @type map
19:08:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:08:21 <tensorpudding> map hasn't turned into fmap yet
19:08:54 <Astro> what is caleskell?
19:09:12 <Axman6> what cale thinks haskell should be
19:09:18 <Axman6> and enforces on everyone else
19:09:22 <tensorpudding> it's a pun term that is describing the modifications that Cale put into lambdabot's haskell definitions
19:09:34 <Axman6> without them asking for it, and to the detriment of those trying to learn haskell in here
19:09:35 <temoto> How to lift f into Maybe or list?
19:09:55 <dolio> Come on.
19:10:30 <c_wraith> temoto: fmap
19:10:40 <Dashkal> Having trouble finding a function.  What IO action do I need to retrieve the current system time?  Pref in microseconds or better; this is for periodic invocation of another action.
19:11:06 <doserj> @hoogle currentTime
19:11:06 <idnar> temoto: uhm, fmap?
19:11:06 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
19:11:06 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
19:11:22 <Dashkal> ooo, danke
19:11:34 <tensorpudding> caleskell does show how useful fmap is though
19:11:39 <Dashkal> figures, a moment after I ask that I suddenly see System.Time as well...
19:11:45 <Axman6> sure, but it gets in the way
19:11:53 <tensorpudding> though it's more of a "that's pretty neat" rather than a "that's really enlightening"
19:11:53 <temoto> I want  (a -> b) -> F (a -> b)
19:12:12 <tensorpudding> sounds like return
19:12:12 <temoto> not sure that's fmap.
19:12:13 <doserj> pure, or return
19:12:24 <Axman6> there's no general a -> f a function for functor
19:12:38 <tensorpudding> you need to have applicative or monad
19:12:59 <idnar> or Pointed
19:13:28 <tensorpudding> are there any useful pointeds that aren't applicatives?
19:14:02 <temoto> How to write expression for lambdabot which would pure into Maybe or list?
19:14:20 <Axman6> pure x...
19:14:25 <Axman6> :t pure
19:14:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
19:14:28 <doserj> tensorpudding: Data.Map? depending on what you want pure to do
19:14:39 <tensorpudding> hmm
19:14:45 <temoto> Axman6, yeah, but that's not specifying Maybe or list.
19:14:47 <tensorpudding> i haven't seen any real pointeds yet
19:15:02 <Axman6> tensorpudding: add types then
19:15:07 <Axman6> uh, temoto
19:15:25 <tensorpudding> > return 5 :: [Int]
19:15:25 <lambdabot>   [5]
19:15:33 <temoto> oh thanks
19:15:36 <tensorpudding> > return 5 :: Maybe Int
19:15:37 <lambdabot>   Just 5
19:15:50 <temoto> :t flip
19:15:51 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:16:09 <tensorpudding> but specifying the type of monad doesn't seem that wise to me
19:16:39 <tensorpudding> err, specifying which monad*
19:16:41 <Zao> > return 5 :: Either String Int
19:16:42 <lambdabot>   Right 5
19:16:49 <sshc> class Default a where
19:16:49 <sshc> def :: a
19:16:56 <ski> > return (+) `ap` [10,20] `ap` [3,4,5]
19:16:57 <lambdabot>   [13,14,15,23,24,25]
19:16:59 <sshc> how do I use def?
19:17:09 <sshc> if I use def, how will GHC know which instance I want?
19:17:20 <tensorpudding> > pure 5 :: (Bool,Int)
19:17:21 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
19:17:22 <lambdabot>    arising from a use of...
19:17:24 <tensorpudding> hmm
19:17:33 <Zao> sshc: By type context?
19:17:36 <ski> sshc : `not def', or `def == length xs', or ...
19:18:14 <ski> > pure 5 :: (Any,Int)
19:18:15 <lambdabot>   (Any {getAny = False},5)
19:18:25 <tensorpudding> (,) s is a functor but not an applicative, that makes sense
19:18:49 <ski>   instance Monoid o => Applicative ((,) o)
19:19:48 <ski> (sshc : aka "just use it")
19:20:11 <sshc> ski: if there is no context, and I have classs Foo where a :: Bool, how do I tell ghci which instance of a to use?
19:20:17 <tensorpudding> hmm
19:20:36 <tensorpudding> so i imagine that it returns pure s =  (mempty, s)
19:20:49 <tensorpudding> or is it mzero
19:20:53 <tensorpudding> i never remember monoids
19:20:58 <c_wraith> @src monoid
19:20:58 <lambdabot> Source not found. Where did you learn to type?
19:21:02 <c_wraith> @src Monoid
19:21:02 <lambdabot> class Monoid a where
19:21:03 <lambdabot>     mempty  :: a
19:21:03 <lambdabot>     mappend :: a -> a -> a
19:21:03 <lambdabot>     mconcat :: [a] -> a
19:21:13 <c_wraith> looks like you were right the first time
19:21:26 <tensorpudding> mzero must be monadplus
19:21:30 <c_wraith> yep
19:21:48 <hotaru2k3> > return 5 :: a -> Int
19:21:49 <lambdabot>   {()->5}
19:28:57 <sshc> ski: if there is no context, and I have classs Foo where a :: Bool, how do I tell ghci which instance of a to use?
19:29:14 <sshc> a :: False could obviously be ambiguous
19:29:37 <sshc> s/False/Bool/
19:34:51 * hackagebot upload: network-fancy 0.1.5 - Networking support with a cleaner API (TaruKarttunen)
19:35:58 <ddarius> sshc: That's not a legal class definition in Haskell 98 I believe.
19:36:02 <c_wraith> sshc: that's pretty much always true.  Even if there *is* context.
19:36:22 <c_wraith> and it's not valid haskell 98, since the type signature doesn't mention the concrete type
20:00:20 <shapr> taruti: http://github.com/taruti/network-fancy is 404
20:00:40 <shapr> oh, github is offline, never mind!
20:01:08 <temoto> I just realized that python map is an n-ary zipWith.
20:01:18 <tomoj> github will supposedly be back in a bit
20:01:22 <tomoj> servers are "coming up"
20:02:20 <shapr> tomoj: Are you tomayko?
20:02:51 <shapr> Oh, I see.. no.
20:04:57 <tomoj> nope
20:08:28 <idnar> temoto: it's not quite zipWith
20:09:19 <idnar> temoto: if the sequences aren't the same length, the shorter ones are padded with None
20:09:21 <Zao> It pads with None to equalize sequence lengths, doesn't it?
20:09:44 <idnar> itertools.imap truncates, though, like zipWith
20:10:47 <idnar> oh, and map(None, ...) is just zipN
20:11:02 <idnar> except with the None padding behaviour, again
20:11:03 <temoto> idnar, you right, i thought map truncates too.
20:11:10 <temoto> zipN?
20:11:14 <idnar> er, actually, I guess zipN is just zip()
20:11:18 <temoto> :t zipN
20:11:19 <lambdabot> Not in scope: `zipN'
20:11:19 <idnar> temoto: zip, zip2, zip3, etc.
20:11:23 <temoto> ah
20:11:44 <idnar> the map(None, ...) behaviour is kinda obscure, but it's useful when you want zip, except with the padding
20:15:01 <copumpkin> we can write a safe zipN too
20:20:33 <temoto> I don't think that padding with Nones is "safe"
20:21:02 <temoto> it depends on particular task anyway
20:21:05 <copumpkin> I meant the emphasis to be on safe
20:21:51 <mreh> getSwaps :: RandomGen g => Integer -> Rand g [Integer]
20:21:52 <mreh> getSwaps n = mapM (\n -> getRandomR (0, n)) [(n-1),(n-2)..1]
20:22:10 <mreh> I would have thought this to be a lazy function, would you concur?
20:23:59 <temoto> copumpkin, did you mean it to eat arbitrary number of arguments then?
20:24:22 <copumpkin> temoto: I mean it's basically a safe sized matrix transpose with an n-ary function
20:24:52 <temoto> copumpkin, i don't know what 'safe sized matrix transpose' mean :(
20:24:58 <mreh> > mapM (\n -> getRandomR (0, n)) [(n-1),(n-2)..1]
20:24:59 <lambdabot>   No instance for (System.Random.Random SimpleReflect.Expr)
20:24:59 <lambdabot>    arising from a...
20:25:12 <copumpkin> type-level naturals, parametrize your matrix by them, transpose it
20:25:20 <copumpkin> and then map the function to the resulting vectors
20:26:07 <temoto> mreh, your comprehension has 'n' literals
20:26:36 <temoto> they're unbound
20:27:07 <idnar> @type transpose
20:27:08 <lambdabot> forall a. [[a]] -> [[a]]
20:27:40 <idnar> > transpose [[1,2,3],[4,5,6],[7,8,9]]
20:27:41 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
20:28:29 <roconnor> @check \x -> transpose (transpose x) == x
20:28:30 <lambdabot>   "Falsifiable, after 2 tests:\n[[()],[(),(),()],[]]\n"
20:29:00 <idnar> > transpose [[()],[(),(),()],[]]
20:29:01 <lambdabot>   [[(),()],[()],[()]]
20:29:20 <idnar> whaat?
20:29:29 <idnar> oh, I see
20:29:38 <idnar> > transpose [[(),()],[()],[()]]
20:29:39 <lambdabot>   [[(),(),()],[()]]
20:29:43 <roconnor> not rectangular
20:30:09 <roconnor> or does that matter?
20:30:27 <idnar> well, I'm not sure what the specification of transpose is, but I see what it's doing
20:30:41 <roconnor> > transpose (transpose http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[2,3)
20:30:42 <lambdabot>   <no location info>: parse error on input `='
20:30:46 <roconnor> damn it Konversation
20:30:49 <copumpkin> lol
20:30:51 <roconnor> > transpose (transpose [ [1],[2,3] ])
20:30:52 <lambdabot>   [[1,3],[2]]
20:30:59 <copumpkin> dÃ©jÃ  vu there
20:31:04 <idnar> the behaviour may just be undefined in the non-rectangular case
20:31:29 * copumpkin searches for "damn it Konversation" in history
20:33:44 <roconnor> I said it earlier today
20:37:23 <copumpkin> yep
20:39:57 <scutigera> shouldn't be just undefined, it really should be an error
20:44:27 <ddarius> @src transpose
20:44:27 <lambdabot> transpose []             = []
20:44:27 <lambdabot> transpose ([]   : xss)   = transpose xss
20:44:27 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:44:58 <copumpkin> transpose :: Mat m n a -> Mat n m a
20:45:02 <ddarius> > transpose [[1],repeat 2]
20:45:02 <lambdabot>   [[1,2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],...
20:45:42 <ddarius> > transpose [[],repeat 2]
20:45:43 <lambdabot>   [[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2],[2...
20:47:58 <mreh> can I do profiling with GHCi?
20:48:26 <quizme> what's so great about closures ?
20:49:03 <Makoryu> mreh: Dunno! It strikes me as possible
20:49:19 <Makoryu> Since GHCi is basically GHC with different command line options
20:49:35 <copumpkin> quizme: not much
20:49:51 <copumpkin> quizme: haskell people don't make a big deal about them :P
20:49:53 <Makoryu> quizme: When you say "closure" do you mean "lambda expression/anonymous function?"
20:49:54 <holmak> GHCi says it "interprets" haskell code when you load it, though
20:50:02 <scutigera> quizme: closures are like oxygen. all you need are closures
20:50:03 <Makoryu> holmak: It's lying.
20:50:04 <holmak> It might not have representative performance
20:50:13 <holmak> aha! good to know
20:50:35 <quizme> makoryu yah, anonymous function that keeps the variables in the scope in which the closure was created.
20:50:41 <Makoryu> I mean, yeah, it doesn't optimize stuff, but it's not interpreting Haskell code the same way that, say, irb is interpreting Ruby code
20:50:56 <copumpkin> quizme: we don't really have "variables"
20:50:59 <jon_of_arc> Still, the lack of optimization is a problem
20:51:08 <kmc> GHCi compiles to bytecode and interprets that
20:51:09 <Makoryu> quizme: Okay. The reason I ask is that you can have closures without anonymous functions, and anonymous functions without closures.
20:51:18 <kmc> this has a number of differences vs. ghc native code
20:51:24 <quizme> sorry, maybe it's not the right channel to ask this question
20:51:33 <Makoryu> quizme: And people on the internet like to talk about them as if they're the same thing...
20:51:34 <Makoryu> Anyway
20:51:36 <jon_of_arc> Remember the first rule of profiling, crank the optimizations up (to whatever you're re releasing at) before you profile.
20:51:47 <jon_of_arc> Well, maybe not first, but near the front.
20:52:07 <Makoryu> quizme: So, Haskell exploits the properties of closures in ways that most Haskell programmers never even think about
20:52:19 <Makoryu> They just sort of accept this behavior subconsciously
20:52:23 <quizme> i have used closures in ruby as anonymous functions, but haven't used the "capturing local scope" part of it.
20:52:34 <scutigera> quizme:
20:52:39 <ddarius> GHci can also load compiled code.
20:52:46 <kmc> quizme, if you don't capture scope, then your "first class functions" are just a selection over a predefined set of behaviors
20:52:50 <Makoryu> It also provides a whole bunch of ways to write anonymous functions (eg. currying) that don't involve an actual lambda expression
20:52:50 <kmc> as function pointers in C are
20:53:09 <kmc> closure over free variables allows you to create new behaviors on the fly
20:53:14 <kmc> for example
20:53:18 <kmc> > map (2 +) [1,2,3]
20:53:19 <lambdabot>   [3,4,5]
20:53:37 <kmc> the value (2 +) would be represented (in GHC haskell) by a closure
20:53:44 <kmc> (as is nearly every other value, but it's less obvious why)
20:53:58 <mreh> "ghc --make SwapsTest.hs" why does it have to be called Main.hs?
20:53:59 <Makoryu> quizme: x = 12; (1..50).each { |i| x -= 1 if stuff.contains i }
20:54:18 <Makoryu> quizme: ^ There's a use of the scope properties of closures in Ruby.
20:54:21 <Makoryu> See it?
20:54:23 <kmc> mreh, because the IO-executor needs to run the action named Main.main
20:54:31 <kmc> and a module's name must match its file's name
20:54:33 <kmc> mreh, but you can override that on the cmd line
20:54:44 <quizme> hmm
20:54:51 <mreh> kmc: how?
20:54:59 <kmc> mreh, by reading the manpage
20:55:03 <mreh> aawww
20:55:09 <kmc> -main-is i think
20:55:17 <kmc> quizme, anyway, there are plenty of documents explaining why functional programming is useful
20:55:36 <kmc> for example i like SICP
20:55:53 <kmc> one thing you can use closures for is implementing objects
20:55:55 <medfly> SICP speaks of why functional programming is useful?
20:56:04 <kmc> medfly, it demonstrates it at least
20:56:12 <ddarius> @where whyfp
20:56:12 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
20:56:25 <quizme> i'm not doubting functional programming
20:56:40 <quizme> i'm trying to see what the big deal about closures is.
20:57:13 <Makoryu> quizme: Closure over local variables is one of those things that you only really miss when you don't have it.
20:57:16 <kmc> a "closure" is a way of representing first-class functions in memory
20:57:28 <kmc> are you asking what the big deal about first-class functions is?
20:57:34 <kmc> or are you asking why closures are a good way to implement them?
20:57:39 <Makoryu> quizme: Since you have it in Ruby, you don't miss it, and you probably don't even notice it
20:57:45 <quizme> i'm just talking about the word "closure"
20:57:45 <Makoryu> It just comes naturally to you
20:58:20 <quizme> in particular the aspect of capturing some local scope in which the closure was created
20:58:22 <mreh> 0_o http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17062#a17062
20:58:30 <Makoryu> quizme: Yes, that's what I'm talking about.
20:58:38 <kmc> quizme, then you are asking about first-class functions
20:58:43 <quizme> kmc: ok
20:58:45 <kmc> it doesn't matter that they happen to be represented in memory by a vector of a code pointer + slots for each free variable
20:59:01 <lpsmith> quizme, you can use closures to implement finite state machines using the formal definition directly
20:59:09 <Makoryu> kmc: If he's asking about the scope thing, he clearly does mean "closures"....
20:59:16 <kmc> he means closure the verb, perhaps
20:59:24 <Makoryu> That's "close"
20:59:24 <holmak> mreh: That is very exciting!
20:59:27 <ddarius> "closure" isn't a verb
20:59:28 <Makoryu> :p
20:59:34 <kmc> anyway, i think the question here might be "why is capturing local scope important for using functions effectively"
20:59:37 <mreh> holmak: what does it mean?
20:59:38 <quizme> lpsmith: is that the "killer app" for closures ?
20:59:43 <scutigera> lpsmith: that  works _really- well.
20:59:52 <Makoryu> quizme: What's the killer app for mutable variables?
20:59:54 <quizme> kmc: yeah maybe that's my question
20:59:55 <holmak> mreh: It means you win a fabulous linker adventure.
21:00:00 <Makoryu> quizme: What's the killer app for string literals?
21:00:00 <kmc> quizme, no, they are incredibly general.  what's the killer app for for loops?
21:00:12 <mreh> holmak: but I don't want one :(
21:00:12 <lpsmith> @let incList delta xs = map (+delta) xs
21:00:13 <quizme> lol
21:00:14 <lambdabot>  Defined.
21:00:21 <Makoryu> quizme: You see where this is going? :p
21:00:22 <lpsmith> > incList 5 [1,2,3,4,5]
21:00:23 <lambdabot>   [6,7,8,9,10]
21:00:30 <mreh> can I trade it in for the washer and dryer?
21:00:34 <ddarius> for loops are an application of HOFs (and tail calls)
21:00:41 <lpsmith> That uses a closures;   you create a closures to keep track of the delta
21:00:42 <kmc> quizme, the reason local scope matters is that without it, your functions come from a finite set fixed at compile time
21:00:42 <holmak> mreh: Are you sure you defined a main?
21:00:46 <Makoryu> ddarius: A very specific application of them, sure, I guess
21:01:03 <kmc> you can't really claim that functions are a powerful datatype if you have to enumerate at compile time all the functions you will ever create
21:01:12 <mreh> holmak: check the revision
21:01:19 <quizme> kmc ok... that's pretty good
21:01:37 <kmc> we could never claim that C has "first-class strings" if every string were a string literal
21:01:42 <lpsmith> quizme, I dunno if it's the "killer app",  there are a lot of ways to implement state machines,  and there are a lot of applications of closures
21:02:09 <lpsmith> You can't write things in the continuation passing style,  really, without closures
21:02:11 <kmc> but that's exactly how functions pointers work in C -- pointers into read-only memory
21:02:19 <jon_of_arc> Sure you can
21:02:23 <jon_of_arc> It's just hideously painful
21:02:32 <kmc> that's why so many callback frameworks have the user specify a void* value that gets passed in
21:02:52 <Zao> Callbacks that do not provide context data should be kicked on the shins.
21:03:02 <kmc> the struct you pass there is a closure, which you have to create yourself
21:03:27 <Zao> Of course, you can always generate your own thunks, but that's highly machine specific.
21:03:49 <kmc> similarly all the C++ libraries which are templated to work on any type T which has operator()
21:04:17 <kmc> the common "design pattern" is to write a struct, give it a constructor which saves some arguments into member vars, and an operator() which uses those members together with its args
21:04:21 <Zao> Boost.Bind is like sliced bread, but good.
21:04:24 <kmc> that is a hilariously long-winded way of defining a closure
21:04:35 <quizme> at every one of my job interviews, they ask "what's so great about closures?"
21:04:56 <quizme> I should tell them "what's so great about loops?"
21:05:01 <kmc> loops suck
21:05:09 <holmak> mreh: the internet says that if you have previously compiled, GHC might not recompile even if flags change, leading to problems
21:05:10 <kmc> i mean it's useful to have them in a standard library or something
21:05:27 <holmak> mreh: try cleaning your previous install? did you change your flags?
21:05:30 <kmc> no reason to elevate them to Language Feature
21:05:43 <mreh> holmak: cleaning the installed library?
21:06:13 <holmak> mreh: no, just delete .hi files and stuff
21:06:15 <mreh> holmak: i've done a rm *.o *.hi
21:06:24 <mreh> that was my first reaction
21:06:47 <mreh> I shouldn't have to know how compilers work and don't work :(
21:07:07 <holmak> mreh: ha, i agree. I feel like I've had this problem before...
21:07:19 <holmak> mreh: Did you try renaming your module to Main?
21:07:30 <holmak> mreh: If not permanently, then just to see what happens
21:07:43 <mreh> holmak: I'm serious considering it, I just want to profile the thing
21:09:53 <mreh> mapM (\n -> (getRandomR (0, n)) -- I have my suspicions about this line you see
21:10:17 <holmak> mreh: The internet also suggests that specific libraries can cause that to happen
21:10:18 <mreh> I've just had such a simple idea..
21:11:22 <holmak> you could also make a *new* Main.hs that calls your other code and runs tests for profiling
21:14:18 * hackagebot upload: bytestring-show 0.3.3 - Efficient conversion of values into readable byte strings. (DanDoel)
21:14:49 <quizme> kmc: [1,2,3].map{|x| 2+x}  <--- is the 1, 2, and 3 considered to be "in the scope in which it was called?" or are those just arguments to the function?
21:15:07 <kmc> i don't know ruby
21:15:19 <copumpkin> quizme: they don't have a name
21:15:24 <kmc> map is a function of two arguments
21:15:26 <Makoryu> quizme: They're literals, not variables
21:15:27 <kmc> one is the list [1,2,3]
21:15:32 <Makoryu> Literals have no scope!
21:15:32 <kmc> one is the function \x -> 2+x
21:15:35 <kmc> (Haskell notation)
21:16:49 <sepp2k> quizme: 1,2,3 are the arguments to the function.
21:17:04 <ddarius> The list [1,2,3] is one of the arguments to map.
21:17:30 <sepp2k> However if you replace 2+x with y+x and previously define y, then y is "in the scope in which it was called"
21:17:34 <quizme> Makoryu i think they're talking about   x=2; [1,2,3].map{|y| x+y}, here x is the local scope.
21:17:35 <kmc> the point of closures is that we can say: \y -> map (\x -> y+x) [1,2,3]
21:17:36 <kmc> yes
21:17:53 <kmc> within «\x -> y+x», y is a free variable
21:18:06 <kmc> it's very easy to describe the free variables of a lambda term
21:18:18 <ddarius> quizme: Scope is an extent of code (either an extent of an (sub)expression or the extent of a block of statements).
21:18:50 <kmc> every term in the lambda calculus is a variable, a lambda abstraction, or an application
21:19:31 <ddarius> quizme: Lambda, \ in Haskell notation, opens a scope.  More obviously, let, in Haskell opens a scope.  In the expression: let x = 3 in x + 2, x is in scope in the expression x + 2.  It doesn't make sense to say a variable is a scope.
21:20:06 <kmc> the free variables of «v» are {v}.  the free variables of «\x -> e» are the free variables of e, except x.  the free variables of «a b» are the union of the free variables of «a» and «b»
21:21:22 <quizme> ddarius: ok thanks for the clarification.
21:22:07 <quizme> lots of people in the channel
21:22:18 <copumpkin> omnom
21:22:32 <quizme> you would think the whole world was programming in haskell
21:22:41 <kmc> lotta lurkers
21:22:48 <copumpkin> quizme: you'd think, eh :)
21:22:50 <Dashkal> >.>
21:22:57 <copumpkin> or would at least appreciate it
21:23:02 <mreh> why do they lurk?
21:23:10 <Makoryu> quizme: We could almost fill a 747, I'm told
21:23:13 <copumpkin> mreh: I've tried to explain it but maybe someone else has a better explanation
21:23:15 <mreh> misanthropy?
21:23:22 <quizme> makoryu hehe i bet you could
21:23:32 <mreh> shall we just go over and talk to them?
21:23:47 <Dashkal> Meh, after all the purity while learning haskell... I'm not so fond of working in IO.
21:23:51 <Makoryu> mreh: They're busy reading monad tutorials
21:23:55 <Makoryu> ï¼ˆã€€Â°â€¿â€¿Â°ï¼‰
21:24:06 <dmwit> Dashkal: this, too, shall pass
21:24:22 <dmwit> Dashkal: both a comfort and a warning
21:24:35 <Dashkal> It reminds me of java :P  So I made pains to isolate IO out of most of the app.  It'll show in the main loop and in socket code.  That's it.
21:24:43 <medfly> haha
21:24:52 <medfly> #haskell is the entire Haskell world
21:25:05 <Dashkal> s/made/took/
21:25:34 <copumpkin> medfly: not quite :)
21:25:39 <Makoryu> Some spoilers, medfly: There are many more Haskell programmers than the ones in this channel! And the rest are all smart enough not to spend too much time goofing around on IRC....
21:25:58 <Dashkal> ... not idle on IRC?  What madness!
21:26:00 <medfly> not smart enough to avoid Haskell ;)
21:26:56 <kmc> Dashkal, the upside is that you can use all that pure functional programming when writing imperative code
21:27:12 <medfly> I do that.
21:27:36 <Dashkal> Sadly, this particular module isn't really pure.  Fortunately the rest of the app can be.  Mutable city down here.
21:28:00 <kmc> indeed the typical imperative Haskell function is a bunch of pure functions that compute IO actions
21:28:10 <Dashkal> It is in the technical sense, of course, but effectively puts foo is just an assignment.
21:28:17 <Dashkal> erm, put foo
21:29:44 <quizme> closures can be used to create scopes. like the "let" statement in Clojure.
21:30:47 <scutigera> Makoryu: busy not understanding monad tutorials
21:30:54 <Makoryu> AHA
21:30:59 <scutigera> at least in my case..
21:31:07 <kmc> why don't they understand, a monad is like a burrito
21:31:16 <Makoryu> scutigera: 'Sokay, most of them are nonsense
21:31:34 <Makoryu> The real difficulty is in understanding higher-order parametric polymorphism
21:32:10 <kmc> people without functional programming experience go looking for the magic in the wrong place
21:32:15 <Makoryu> Once you've got that down, Monad is just like any other typeclass
21:32:28 <kmc> "monad" has a crazy name and "function" doesn't
21:32:30 <Dashkal> <-- seriously overcomplicated monads while learning them
21:32:41 <scutigera> problem is that monads like IO "trap" things but Monads like maybe don't. ??
21:32:43 <Makoryu> Dashkal: Everyone does. The name sounds SO EXOTIC
21:32:53 <medfly> does it?
21:32:58 <medfly> lambda calculus sounds bad too...
21:33:06 <Makoryu> scutigera: That's only because you have access to the data constructors for Maybe
21:33:09 <medfly> GREEK! I CAN'T TAKE IT!!!!!!
21:33:12 <Dashkal> It doesn't have a meaning in lay-english.  hence exotic
21:33:17 <kmc> some monads for which you lack the constructors still have a "run" function
21:33:35 <kmc> IO is a weird atypical monad
21:33:51 <Makoryu> scutigera: There's no generic way to extract stuff from a monad, so the "trappiness" depends entirely on whichever type you're working with
21:33:51 <medfly> I don't even know what "closure" means. that sounds rather exotic to me.
21:33:56 <Dashkal> lambda calculus is something on my todo list.  I'm pretty sure I can handle it now.
21:33:59 * medfly is ignorant of terminology
21:34:17 <kmc> lambda calculus is like a tiny tiny subset of Haskell
21:34:21 <scutigera> oh, by the way, read operational monad tutorial in last monad.reader - great stuff.
21:34:23 <Makoryu> medfly: At least it's obviously an English word reused in an unfamiliar context
21:34:34 <medfly> Makoryu, I've never seen it used. :(
21:34:40 <medfly> besides to mean some CS concept.
21:34:48 <medfly> I have however seen monad being used outside Haskell, which is friendlier. :)
21:34:51 <solrize> medfly, you should probably read SICP
21:35:00 <kmc> it seems backwards to learn Haskell or Scheme as preparation for learning the lambda calculus
21:35:01 <medfly> solrize, I'm just slow :(
21:35:14 <kmc> however, it might be good motivation for why you should care about the lambda calculus
21:35:28 <Makoryu> medfly: I usually hear it used with respect to some ongoing emotional ordeal
21:35:30 <medfly> I would do it. everything mathematical makes more sense when I am familiar with it from programming.
21:35:31 <scutigera> Makoryu: access to the data constructor.  why can't I have access to the IO data ctor.  get, gets a char, can't I have a char ctor ?
21:35:31 <Dashkal> heh, it would be backwords, but I wanted to learn pure functional programming and my interest in the lambda calculus came due to how many times it came up while studying.
21:35:43 <medfly> I recall being in high school and getting this "induction" thing.
21:36:20 <copumpkin> induction ftw!
21:36:21 <medfly> I make a mockery of mathematics.
21:36:23 * hackagebot upload: HsSVN 0.4.2 - (Part of) Subversion binding for Haskell (MasatakeDaimon)
21:36:26 <Dashkal> induction is a concept I still struggle with, despite the fact that I use it on a regular basis
21:36:37 <copumpkin> Dashkal: really?
21:36:55 <Makoryu> scutigera: Look at it this way. The theoretical semantics of the IO monad mean that any faithful implementation of the IO type would have a different constructor for every possible world state you might be working with.
21:36:56 <Dashkal> Dunno why.  For some reason I glaze over when trying to understand the definition.
21:36:59 <copumpkin> there's a handy haskell function for induction!
21:37:06 <copumpkin> ;)
21:37:22 <medfly> Dashkal, I can't really get mathematics too. that's why I prefer being introduced to everything through programming.
21:37:25 <Makoryu> scutigera: So, for example, you would have different constructors representing the entire world before and after you fired some missiles
21:37:34 <medfly> Dashkal, I may be weaker at it than you are, though.
21:37:38 <copumpkin> Dashkal: induction :: forall p n. Nat n => n -> p Z -> (forall x. Nat x => p x -> p (S x)) -> p n
21:37:46 <medfly> I haven't even looked at the definition of induction
21:37:48 <copumpkin> stolen from ryan ingram :)
21:37:55 <scutigera> Makoryu: how about before and after I brewed beer :-)
21:38:04 <Makoryu> scutigera: That too! :p
21:38:04 <Dashkal> I'm pretty good with math, but I have "holes".
21:38:18 <Dashkal> I can do calculus in my sleep, but matrix math eludes me
21:38:20 <Makoryu> scutigera: Anyway... obviously, Haskell does not (yet) grant time travel powers to your computer
21:38:30 <Makoryu> So the IO type is restricted to reflect this
21:38:31 <copumpkin> try to figure out that type signature in haskell :)
21:38:39 <copumpkin> it's pretty nice
21:39:14 * Dashkal tries to read
21:39:36 <scutigera> Makoryu: I haven't heard that spin on it yet.  I shall ponder.
21:39:49 * Dashkal fails
21:39:52 <temoto> copumpkin, Z and S are unbound.
21:40:06 <copumpkin> data S = S
21:40:06 <dmwit> data Z
21:40:10 <dmwit> data S a
21:40:12 <copumpkin> or rather data S x = S x
21:40:19 <Dashkal> oh!
21:40:21 <temoto> ah it's Zero and Succ?
21:40:23 <copumpkin> yep
21:40:38 <copumpkin> I guess S could be a newtype
21:40:45 <copumpkin> doesn't really matter though
21:40:48 <Dashkal> ok, I can read that
21:40:52 <Dashkal> *blinks*
21:40:55 <Makoryu> scutigera: ^ Probably 'cause I made it up on the spot just now Â¯\O_o/Â¯
21:40:58 <Dashkal> that's bloddy simple...
21:40:59 <copumpkin> Dashkal: that's induction!
21:41:14 <copumpkin> Dashkal: can you see how you'd write the function itself?
21:41:19 <temoto> Dashkal, could you to explain what you read?
21:42:04 <Dashkal> I'm going to play in a ghci / vim session for a sec to be sure I have it right.
21:42:09 <scutigera> Makoryu: actually I'm not buying it.  if I'm reading characters, why can't I read them into a list, and when I'm done return a pure list ?  cons is now my ctor
21:42:19 <copumpkin> Dashkal: better get the supporting things too, although you need not understand them
21:42:31 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
21:42:51 <Dashkal> I've done Z and S before a few times, though in Scala rather than haskell.  Good excercise.
21:43:44 <dmwit> scutigera: The answer to that depends on where you're reading from.
21:44:12 <dmwit> scutigera: If you're reading from stdin, then the answer is you can't return a pure list because that would throw away the state change (namely, that you read those characters and they're gone).
21:44:15 <Makoryu> scutigera: Because that would return the list and discard the universe
21:44:33 <dmwit> scutigera: If you're reading from a file, then the answer is you can't return a pure list because the action may actually return different values depending on when it's run!
21:45:00 <scutigera> oh right, I took the char out of the universe, is that the idea ?
21:45:06 <dmwit> yep
21:45:25 <temoto> scutigera, and every nanosecond the universe is different.
21:46:52 <temoto> Which doesn't allow you to abstract out a subset of universe and work with it in a pure manner.
21:47:10 <scutigera> so how about one of those sneaky random number generators that returns a pure list ?
21:47:31 <scutigera> seems like an rng is the epitome of IO
21:47:43 <Dashkal> ok, this article is harder to read that than type
21:47:50 <Dashkal> we're using extensions I haven't heard of
21:47:58 <Makoryu> scutigera: Well... You can always cheat using the unsafePerformIO function, which does exactly what you're asking for <_<
21:48:04 <copumpkin> Dashkal: I just meant it as a source for supporting code for that induction function
21:48:26 <temoto> scutigera, there are math algorithms to compute pseudorandom numbers from seed values. Those are pure functions.
21:48:45 <scutigera> right, but "trapping" with IO is useful in that allows a discipline to seperate pure from not quite so pure.
21:49:16 <scutigera> temoto: oh yeah , good point !
21:49:43 <scutigera> temoto: but my rng hardware based on thermal noise would be IO.
21:50:01 <temoto> scutigera, yes, and there are randomIO functions.
21:50:46 <scutigera> temoto: yes I've seen both, but as was pointed out you can sprinkle unsafe and dispense with the IOness, right ?
21:51:07 <temoto> scutigera, yes, that's what unsafePerformIO is about.
21:51:19 <temoto> :t unsafePerformIO
21:51:19 <lambdabot> Not in scope: `unsafePerformIO'
21:51:24 <scutigera> temoto: ok, also something I had wondered about.
21:51:28 <temoto> IO a -> a
21:52:08 <Makoryu> @hoogle unsafePerformIO
21:52:09 <lambdabot> Foreign unsafePerformIO :: IO a -> a
21:52:09 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
21:52:10 <temoto> a hole in trapping separation. for those rare cases where you really need it quick
21:53:11 <temoto> But, since it becomes a pure value,   a + a where a = unsafePerformIO randomIO   in fact sums 2 identical numbers.
21:55:15 <scutigera> ?? because the compiler uses the same value, right ? it says, you're pure, so I must get the same result.
21:55:15 <lambdabot> Plugin `compose' failed with: Unknown command: ""
21:56:33 <scutigera> and doesn't eval the second a
21:57:20 <temoto> scutigera, kind of. It's not reasoning like "i must get the same result so i will not evaluate you twice", that would be a memoization, a cache. value of `a` *will* be discarded and really forgot after the whole a+a expression evaluated. So in another a+a it will evaluate `a` again.
21:57:41 <Dashkal> took me a sec to read it again once I got it compiling.  Given a natural number n, the result of applying the operation to Zero, and the way to convert the result of the operation on x to the result of the operation on x+1, you have the operation on n
21:57:49 <Dashkal> now to try to implement
21:59:19 <temoto> scutigera, it's reasoning like "as soon as i have the value of `a` so i can use it in all places where `a` is met"
21:59:55 <temoto> scutigera, but it boils down to the same: no need to evaluate it twice, yes.
22:00:18 <Ali7> hii
22:00:23 <scutigera> temoto: makes sense, thanks.
22:00:48 <Ali7> so who will help
22:01:40 <Dashkal> bleh, I have a solution I think is correct, but fails to typecheck (the type of induction is too strict for the method I used)
22:03:27 <temoto> scutigera, And trapping and separation you mentioned, happily, apply not only to IO, but also to state changes. There is a State monad which captures some mutable state inside a pure (non-IO) function. And it is a valuable separation again. And sometimes you hate it and want to do dirty things without separation.
22:05:43 <scutigera> temoto: state would be pure though because I am changing in predictable and reproducible manner
22:06:51 <Ali7> Who the fuck will help?
22:07:14 <sshc> Ali7: I will not.
22:07:16 <temoto> scutigera, yes :)
22:07:26 <sshc> Ali7: bye now!
22:07:53 <temoto> Ali7, it's a general advice on all IRC channels: don't ask to ask, just ask.
22:08:30 <scutigera> temoto: thanks for your help.
22:08:49 <Astro> that's called metaquestions
22:11:20 <sshc> yes thanks for your help everybody all I wanted!
22:11:23 * sshc -!- [~sshc@unaffiliated/sshc] has left #haskell []
22:11:29 <Dashkal> copumpkin: Ok, I got it, I'm just stumbling on unfamiliar type concepts.
22:11:49 <Dashkal> Looking down on that article, my implementation is trying to do the same thing
22:12:18 <Dashkal> I have no idea what ~ means in a type sig.
22:12:32 <holmak> irrefutable pattern
22:12:33 <Zao> Dashkal: In patterns, it means irrefutable.
22:12:58 <Dashkal> Ok, I've seen that term before, but I haven't yet grasped it
22:13:00 <copumpkin> Hello there! Do you think you would be so kind to allow me to ask a question about the etiquette in this channel? if so, I was wondering if it would be too much bother for me to ask a question about Haskell. If it is not too vexing, I should very much like to know what a Monad is. Thank you.
22:14:18 <ivanm> Dashkal: in a type sig?
22:14:34 <ivanm> @slap copumpkin
22:14:34 * lambdabot puts on her slapping gloves, and slaps copumpkin
22:14:36 <Dashkal> ex: caseNat :: forall r. n -> (n ~ Z => r) -> (forall p. (n ~ S p, Nat p) => p -> r) -> r
22:15:07 <copumpkin> Dashkal: type equality
22:15:14 <ivanm> yup
22:15:28 <ivanm> it's saying that Z is the same type as n
22:15:30 <copumpkin> n ~ Z => r basically says, "in a context where n is Z, r"
22:15:47 <copumpkin> ivanm: it's a clever hack to close the typeclass :P
22:15:50 <copumpkin> I mean Dashkal
22:15:59 <ivanm> copumpkin: heh
22:16:05 <Dashkal> *nods* Ok, I think I follow
22:16:20 <Dashkal> That said, if I forget peano numbers in the type system, I can implement it using Natural :p
22:16:37 <Dashkal> (assuming there isn't a type quirk I'm not seeing)
22:16:39 <ivanm> Dashkal: do I dare ask why you'd _want_ to implement peano numbers in the type system?
22:16:57 <Dashkal> ivanm: Learning how to define mathimatical induction
22:17:25 <copumpkin> Dashkal: the point of doing it that way is that haskell can verify the proof for you (with a bit of certainty, but not 100%)
22:17:47 <Cale> Ali7: Everyone who can help will help, but nobody can know whether or not they can help until they know what the problem is. :)
22:17:59 <ivanm> Dashkal: do it by hand using pen and paper?
22:18:02 <Dashkal> ok, skipping that, I'm still trying to establish how to work with the first parameter.
22:18:12 <copumpkin> Dashkal: of the induction function?
22:18:27 <Cale> ivanm: Naturals at the type level are useful for various things.
22:18:29 <Dashkal> ivanm: The original seed to this conversation was my admission that I'm unable to grasp the normal definition of induction.  Trying it this way
22:18:36 <ivanm> aha
22:18:51 <Cale> Dashkal: Which definition is the normal one?
22:18:57 <Dashkal> copumpkin: Yes.  I need to differentiate Z from S n
22:19:34 <Dashkal> Cale: Perhaps a poor choice of words.  I didn't grasp it back in high school, nor in later attempts.  This is despite the fact that I use it.  Annoying brain fart.
22:19:45 <Cale> Oh, okay.
22:19:50 <ivanm> the way I've always done it: for some P(n), forall n >= a: 1) Prove the base case n = a; 2) Assume true for n = k, some k; 3) Prove true for n = k + 1
22:20:10 <ivanm> Dashkal: so you know how to do it, just not how/why it works?
22:20:22 <Dashkal> *nods* that's about the definition I see all the time, but it doesn't "click" or "sink in".  I'll forget it in a few seconds.
22:20:35 <Cale> So, the usual induction on naturals is that if you can show that a property is true for a natural number n given that it is true for all naturals less than n, then it must be true for all n.
22:20:37 <copumpkin> that's what the type definition I wrote above says too :)
22:20:42 <ivanm> Dashkal: think of it as building a tower
22:20:46 <Ali7> So who can help?
22:20:47 <copumpkin> not the all naturals one
22:20:48 <ivanm> you know how to build the first floor, the foundations
22:20:56 <ivanm> now, if you have one floor, do you know how to build another floor?
22:21:03 <Dashkal> copumpkin: It does say the same thing, but in language I can retain better.
22:21:08 <Cale> Ali7: Nobody can help until they know what you need help with.
22:21:09 <copumpkin> Ali7: are you being intentionally thick?
22:21:12 <ivanm> Ali7: what's the question?
22:21:25 <Ali7> I need help with Prototypes
22:21:32 <Cale> Ali7: Prototypes?
22:21:36 <Ali7> I have a function.. already i just need prototyes for it
22:21:36 <Ali7> yes
22:21:55 <Ali7> Prototypes*
22:21:57 <Cale> Let's see your code?
22:22:03 <monochrom> perhaps as in "C function prototype"
22:22:06 <Ali7> Copy Paste here?
22:22:09 <ivanm> Ali7: Cale's "Prototypes?" question was (I think) more a request for clarification
22:22:11 <Cale> @where hpaste
22:22:11 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
22:22:12 <Ali7> Yes C function
22:22:14 <ivanm> what do you mean by "prototypes"?
22:22:17 <Dashkal> ahh, I'm getting nowhere without some sort of function on the Nat class.  Seems I'm going to need to either grasp or cheat and copy-paste that caseNat trick used there.
22:22:18 <Cale> Oh, in C?
22:22:21 <ivanm> monochrom: what's that mean?
22:22:26 <monochrom> type sig
22:22:27 <Ali7> Yes C
22:22:29 <Cale> Ali7: You're in the wrong channel, probably.
22:22:35 <Ali7> Gah!
22:22:40 <Cale> Ali7: This channel is for questions about the programming language Haskell.
22:22:40 <Ali7> How ? Which 1 should i go to?
22:22:41 <ivanm> Ali7: see ##C
22:22:52 <Ali7> Ok C is programming language :S
22:23:00 <ivanm> why does C call its function type signatures "Prototypes"?
22:23:09 <Ali7> I have no idea..
22:23:16 <Ali7> My stupid instructor wants us..
22:23:16 <monochrom> because "type sig" was not coined yet.
22:23:28 <ivanm> aha
22:23:39 <Ali7> So which channel i should go to?
22:23:43 <ivanm> Ali7: ##C
22:23:47 <monochrom> well, "type" was already coined but "sig" wasn't.
22:23:48 <ivanm> (like I already told you)
22:23:49 <Ali7> ok thanks
22:23:57 <Cale> Dashkal: Would you like me to prove that induction works, based on the assumption that every nonempty set of naturals has a least member?
22:23:57 <Makoryu> Ali7: http://dis.4chan.org/prog/ <- Go here for GREAT ASSISTANCE
22:24:02 <Cale> Makoryu: hehe
22:24:03 <ivanm> Makoryu: heh
22:24:11 <ivanm> Makoryu: stop being evil to the seeming newbie
22:24:16 <Makoryu> :3
22:24:53 <ivanm> now that he's gone... for those yanks here, a "community college" is the really low level tertiary education that are for people that are too dumb to get into "real" universities?
22:25:03 <ivanm> if so, that explains it (since his IP was from a community college)
22:25:06 <Dashkal> Cale: I'm not at all sure a proof will work for me.  Pure mathical language sometimes escapes me.
22:25:21 <Makoryu> ivanm: Yep
22:25:24 <monochrom> for people too dumb to read "##C"
22:25:24 <Dashkal> ivanm: Or just not rich enough.  "real" universities are prohibatively expensive
22:25:32 <Cale> Dashkal: Well, it might help to understand the reasoning behind it anyway.
22:25:33 <ivanm> Cale: try using impure (i.e. put some phyisics into it or something) mathematical language for Dashkal ;-)
22:25:38 <Cale> hehe
22:25:42 <Dashkal> lol
22:25:48 <Dashkal> I almost have this
22:25:49 <ivanm> Dashkal: I thought that was what "state colleges" were for...
22:25:59 <Dashkal> Just slowly decoding the type of caseNat
22:26:13 <Makoryu> ivanm: State colleges are a step above community colleges, and yet they're still more or less as you say
22:26:19 <Dashkal> Oh probably.  I'm canadian.  Student loans are somewhat sane here.
22:26:24 <ivanm> oh? I thought some state colleges were meant to be quite good
22:26:38 <Dashkal> From what I hear, that varies dramatically state to state
22:26:44 <Cale> Dashkal: I think the formal versions of induction are probably trickier to understand than the ones written in English, anyhow.
22:26:46 <Makoryu> ivanm: Maybe I'm acquainted with all the wrong state colleges :p
22:27:09 <ivanm> we have "HECS", which means you have to pay the government back 1/3 of the cost of your undergraduate education once you start working (it gets deducted from your pay once you start earning enough)
22:27:11 <ivanm> Makoryu: heh
22:27:15 <Cale> Dashkal: The idea is that induction gives us a tool to show that certain properties are true of every natural number.
22:27:16 <ivanm> Dashkal: fair enough
22:28:27 <Dashkal> *click* Finally managed to read that damn signature
22:28:33 <Dashkal> ok, now I can implement
22:28:53 <Cale> If you think about it a bit, that is fairly profound. Actually checking that the property is true for every natural number would ordinarily take an infinite amount of work.
22:29:37 <monochrom> Dashkal: I'm the opposite of Cale. I think formal versions are clearer. So here is my shot: (P0 and (forall k. Pk implies P(k+1))) implies (forall n. Pn).  Note that (forall k. Pk implies P(k+1)) is not ((forall k. Pk) implies (forall k. P(k+1))), therefore one of the confusions saying "it looks circular" does not stand.
22:30:21 <Cale> The idea is this: if a property that is purported to hold for all natural numbers is to fail, there must be a *least* natural number where it fails.
22:30:28 <pikhq> ivanm: A "community college" is the low-level tertiary education for people too dumb to get into "real" universities *or* for people who want to save money when doing some of the more mundane courses.
22:31:01 <ivanm> hmmm....
22:31:05 <Cale> If, assuming that it is true for all the natural numbers less than n, we can show that it must be true for n, then it would be a contradiction for there to be a least number where the property doesn't hold.
22:31:13 * ivanm just writes it up as yet another way where the USA is f**ked up
22:31:16 <pikhq> (they're quite significantly cheaper...)
22:31:51 <Cale> (because we could use the fact that it must then hold for all the smaller numbers to show that it also holds for that one)
22:31:53 <pikhq> ivanm: Yes, tertiary education funding is quite f**ked up here. Wonderful if you can afford it, terrible if you can't.
22:34:29 <Cale> Well, I suppose we should look at the precise version of induction that you're trying to convince yourself about :)
22:35:21 <Dashkal> It compiles!
22:35:35 <Dashkal> Just took a small pile of pragmas at the top
22:35:50 <monochrom> Cale: It's as suggested by copumpkin: forall p n. Nat n => n -> p Z -> (forall x. Nat x => p x -> p (S x)) -> p n
22:36:13 <Dashkal> Ok, now that I have it compiling, I think I can read this enough to actually define it
22:36:26 <Cale> Oh, that has a strange parameter order.
22:36:43 <monochrom> Yeah, I would prefer n to be next to p n too.
22:36:54 <Cale> yeah
22:37:07 <copumpkin> yeah, it is odd :)
22:37:41 <Cale> If p is true of Z, and, given that p is true of x, we can show that p is true of the successor of x, then for any n, we can show that p is true of n.
22:37:48 <monochrom> The two orders are isomorphic.
22:38:40 <Dashkal> Prove that p Z is true.  Then prove that given a p x, that p (S x) is true.
22:39:00 <Cale> actually, why does n have to be a parameter at all?
22:39:00 <copumpkin> yep
22:39:04 <Cale> I might like:  p Z -> (forall x. Nat x => p x -> p (S x)) -> (forall n. Nat n => p n)
22:39:30 <copumpkin> Cale: for caseNat, in ryan's case
22:41:58 <Dashkal> Now I can definitely understand why this is not circular.  The part where I choke when actually trying to use induction intentionally is p x implies p (x + 1).  sec, gonna try to work this out quickly for a simple case.
22:42:25 <monochrom> Ha, I knew it.
22:42:39 <copumpkin> ?
22:42:52 <Cale> Have you done many proofs of simple properties by induction?
22:42:58 <Dashkal> Not since high school
22:43:04 <monochrom> <monochrom> ... Note that (forall k. Pk implies P(k+1)) is not ((forall k. Pk) implies (forall k. P(k+1))), therefore one of the confusions saying "it looks circular" does not stand.
22:43:10 <copumpkin> ah :)
22:43:20 <Dashkal> To be specific, I'm somewhat grasping the concept, just failing in application.
22:43:36 <copumpkin> Dashkal: do you see how the definition of that function works by the way?
22:43:41 <Cale> What would you like to prove?
22:43:49 <copumpkin> like, how one would write a function with that type
22:43:56 <Cale> (Perhaps pick something and we'll try an example :)
22:44:25 <monochrom> This is why quantifiers must be made explicit whether you use evolved languages or intelligent-designed languages.
22:44:27 <copumpkin> oh no, the merged closing paren
22:44:39 <copumpkin> omg monochrom is a proponent of ID
22:44:55 <Dashkal> I think I'm good.  Now that I'm more or less up to speed, the examples given on wikipedia are actually making sense!
22:45:04 <monochrom> Of course intelligent-designed languages trump evolved languages for math purposes.
22:45:10 <pikhq> copumpkin: Just intelligently designed languages.
22:45:24 <pikhq> Like Haskell, and unlike C++.
22:45:53 <Dashkal> oh of course, just work backwords from p (x + 1) to p (x)
22:46:15 <Cale> Probably the simplest thing I can think of is: given the recursive definition of addition that 0 + m = m, and (Sn) + m = S(n+m), show that for all n we have that n + 0 = n.
22:46:25 <monochrom> and just hope that you hit p Z soon.
22:47:03 <Dashkal> not having to manually hit p Z is kinda the whole point, isn't it?
22:47:09 <ski> sshc : if you have `class Foo where a :: Bool', then there can only be at most one instance of `a', so there is no problem
22:47:20 <monochrom> Yeah let the computer do it.
22:47:48 <monochrom> Or in math, let the axioms say it's done, or let set theory do it.
22:48:11 <Cale> Firstly, we have that 0 + 0 = 0, so the property is valid when n = 0.
22:48:20 <Cale> Then, supposing that k + 0 = k, we'd like to show that Sk + 0 = Sk.
22:48:28 <Cale> By the second equation in the definition of addition, we have that Sk + 0 = S(k+0),
22:48:39 <Cale> and k + 0 = k by assumption, so putting these together gives Sk + 0 = S(k+0) = Sk.
22:48:56 <Cale> and so by induction, the property is valid for all n.
22:49:15 <ski> (are we proving naturals form a monoid ?)
22:49:23 <Cale> ski: Just the right identity.
22:49:43 <monochrom> You first need induction to prove that recursive definitions are sound.
22:49:43 * hackagebot upload: HsHyperEstraier 0.3.2 - HyperEstraier binding for Haskell (MasatakeDaimon)
22:50:28 <The_third_man> crisse d'ostie, c'est l'heure de bouger
22:51:52 <The_third_man> MER IL ET FOU
22:53:13 <Dashkal> Alrighty.  The other half just returned home.  Thanks all very much for the help.  I think it'll actually stick this time
22:57:09 <ski> Omega-inconsistent theory <http://en.wikipedia.org/wiki/%CE%A9-inconsistent_theory>
22:57:13 <ski> (apropos "if a property that is purported to hold for all natural numbers is to fail, there must be a *least* natural number where it fails.")
22:58:28 <ski> sshc : maybe you meant to say `class Foo a where foo :: Bool', instead ?
22:59:11 <ski> sshc : in that case, the operation `foo' would be ambiguous (there's no way to deduce which `a' to use from a use of `foo'), so that's disallowed
23:12:39 <ski> (sshc : each class operation must mention enough of the class parameters to determine all of the class parameters uniquely)
23:13:16 * ski wonders whether omega-consistency has anything to do with the existence property
23:39:16 <solrize> ski, yes, if a theory is omega-consistent then the theorem (exists x) Px implies that there is actually such an x.
23:39:47 <solrize> for some x in 1,2,3....
23:40:14 <solrize> if it's omega-inconsistent there could be a nonstandard x but no actual numeral x
23:40:17 <monochrom> ... , 0
23:41:06 <solrize> monochrom is skeptical ;)
23:41:23 <monochrom> No, I'm adding 0 to your list.
23:41:24 <solrize> the WP article is pretty good
23:41:28 <solrize> heh
23:51:52 <m3ga> with quickcheck, is there a way to limit the size of the randomly generated QC data structure?
23:53:30 <m3ga> i have 'data BackGraph k  = BackGraph (Map k [k]))' and QC is creating insanely huge BackGraphs
23:55:18 <ski> solrize : but omega-consistency seems to refer only to natural numbers (or presumably also things encodable in them)
23:56:03 <ski> m3ga : there's a size environment in the `Gen' monad, iirc
23:56:12 <ski> @hoogle sized
23:56:12 <lambdabot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
23:57:52 <ski> .. ah
23:57:55 <ski> @type Test.QuickCheck.rezize
23:57:56 <lambdabot> Not in scope: `Test.QuickCheck.rezize'
23:57:57 <ski> @type Test.QuickCheck.resize
23:57:58 <lambdabot> forall a. Int -> Gen a -> Gen a
23:59:41 <m3ga> thanks ski
