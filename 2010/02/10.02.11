00:00:14 <Berengal> With function composition, you can replace just about any subexpression with a bound name, but with dollars you usually need to move things around a bit
00:01:29 <Berengal> i.e. you can't just cut the expression, paste it into a where and insert its name without modifying some of the surrounding tokens some
00:01:58 <FliPPeh_> Alright
00:02:33 <FliPPeh_> I've developed the habit to replace a function like "func (foo (bar quux))" with "func $ foo $ bar quux"
00:02:47 <FliPPeh_> Although that'd be what composition was made for :/
00:03:37 <FliPPeh_> Time to kick that habit
00:03:53 <opqdonut> yeah, many advocate "func . foo . bar $ quux"
00:04:29 <FliPPeh_> It also makes it clearer to separate functions from arguments
00:04:43 <FliPPeh_> At least the main target argument here
00:04:46 <FliPPeh_> quux
00:16:30 * hackagebot upload: dow 0.1.0 - Dungeons of Wor (GergelyPatai)
00:35:31 <FliPPeh_> Mhh
00:35:39 <FliPPeh_> Maybe and Either are Monads, too, right?
00:35:47 <copumpkin> Either a is a Monad
00:35:51 <copumpkin> Maybe is
00:35:55 <FliPPeh_> So
00:36:11 <FliPPeh_> Why can I extract values out of them using case, pattern matching and so on?
00:36:16 <FliPPeh_> I thought that's impossible for monads
00:36:19 <FliPPeh_> As IO shows
00:36:23 <copumpkin> Monads say what you can do, not what you can't do
00:36:28 <copumpkin> if you can do more, then that's fine
00:36:38 <copumpkin> Identity is a monad and you can pull stuff out of it just fine
00:36:48 <FliPPeh_> hmm
00:36:50 <FliPPeh_> okay...
00:37:12 <Cale> IO is an unusual example of a monad.
00:41:05 <o-_-o> how do I declare something as a type ?
00:41:13 <o-_-o> I want to say that 1 is of type Word32
00:41:23 <o-_-o> something like let a = 1 :: Word32
00:41:27 <opqdonut> that works
00:41:29 <Cale> o-_-o: That's right.
00:41:32 <Cale> Or:
00:41:33 <danderson> yup.
00:41:36 <opqdonut> or let a :: Word32; a = 1
00:41:37 <Cale> a :: Word32
00:41:40 <Cale> a = 1
00:41:56 <o-_-o> ah...cool :-)
00:48:03 <pozic> Why doesn't the debugger show all the breakpoints, but only approximately all?
00:49:17 <FliPPeh_> Hmm
00:49:19 <pozic> I am dividing by zero somewhere, but there is no way to tell the debugger to give me the exact expression containing the division.
00:50:09 <FliPPeh_> I have a monad that, when run like "withMPD currentSong", will either return "Left error" or "Right Song { ... }"
00:50:35 <FliPPeh_> But when I run a function instead of "currentSong" I cannot see wheter it will be Left or Right until withMPD has completed
00:50:54 <FliPPeh_> How could I modify it so I can run single functions and grab each result instead a total of all runs?
00:51:30 <FliPPeh_> Short: I can only see wheter it was successful from outside
00:52:10 <FliPPeh_> If I want all results, I'd have to run multiple "withMPD" with other functions, but the problem is that withMPD opens a new connection
00:52:19 <FliPPeh_> So lots of reconnecting for some queries
00:53:42 <FliPPeh_> I think this is something I carried over from the old LibMPD
00:53:56 <FliPPeh_> I just have no idea how to change that...
00:55:58 <mpiechotka> Hello. What's the name of extension where I can name types? I.e. something :: forall a. ...; something = .... (someExpr :: a) -- this is the same a as in signature
00:57:41 <olsner> mpiechotka: I think you're looking for ScopedTypeVariables
00:58:23 <mpiechotka> olsner: Thanks. I always forgot its name
00:59:04 <xerox> pozic  maybe with loch?
01:14:36 <pozic> xerox: with loch I have to put in asserts through the whole program.
01:16:39 <pozic> Does anyone know the Vec library and in particular how to multiply a vector with a scalar?
01:22:08 <kalven> @src uncurry
01:22:08 <lambdabot> uncurry f p = f (fst p) (snd p)
01:22:45 <idnar> @src init
01:22:45 <lambdabot> init [x]    = []
01:22:45 <lambdabot> init (x:xs) = x : init xs
01:22:45 <lambdabot> init []     = undefined
01:22:49 <kalven> is there an uncurry3?
01:23:10 <idnar> @type uncurry
01:23:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
01:23:13 <quicksilver> @hoggle uncurry3
01:23:14 <lambdabot> No results found
01:23:19 <idnar> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
01:23:19 <lambdabot> No results found
01:23:29 <felzix> how can I do "mv" as in linux with haskell code?
01:23:32 <quicksilver> no, although there is zip3 and zipwith3
01:23:51 <quicksilver> bit inconsistent really
01:23:56 <quicksilver> felzix: something in System.Directory
01:24:07 <xerox> pozic it's automatic, it's not like you have to put them manually and keep them forever
01:24:08 <idnar> @type let uncurry3 f ~(a,b,c) = f a b c in uncurry3
01:24:09 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
01:24:19 <felzix> quicksilver: awesome, thanks :)
01:26:33 <kalven> idnar: what does the ~ mean?
01:27:53 <idnar> kalven: irrefutable pattern match
01:28:35 <kalven> ok
01:28:55 <idnar> > let uncurry f ~(a,b); foo a b = 5 in uncurry foo (1,2)
01:28:56 <lambdabot>   <no location info>: parse error on input `;'
01:29:05 <idnar> > let uncurry f ~(a,b) = f a b; foo a b = 5 in uncurry foo (1,2)
01:29:06 <lambdabot>   5
01:29:13 <idnar> > let uncurry f ~(a,b) = f a b; foo a b = 5 in uncurry foo undefined
01:29:14 <lambdabot>   5
01:29:18 <idnar> > let uncurry f (a,b) = f a b; foo a b = 5 in uncurry foo undefined
01:29:19 <lambdabot>   * Exception: Prelude.undefined
01:29:31 <idnar> > let uncurry f p = f (fst a) (snd b); foo a b = 5 in uncurry foo undefined
01:29:32 <lambdabot>   Couldn't match expected type `(a, b)'
01:29:32 <lambdabot>         against inferred type `Simple...
01:29:36 <idnar> oops
01:29:42 <idnar> > let uncurry f p = f (fst p) (snd p); foo a b = 5 in uncurry foo undefined
01:29:42 <lambdabot>   5
01:30:32 <quicksilver> the point being that if 'foo' ignores both its arguments anyway you might want it to work even if the whole tuple is undefined
01:30:44 <quicksilver> more practically, it makes certain kinds of recursive construction work.
01:33:15 <idnar> I guess "lazy pattern match" would be a better name
01:34:04 <quicksilver> that is also a common name for them
01:34:47 <dolio> @remember JonHarrop I am the author of the world's most profitable book on functional programming.
01:34:48 <lambdabot> Nice!
01:35:47 <dobblego> haha
01:35:54 <tensorpudding> which book is that?
01:36:21 <dolio> Either his OCaml or F# book, I guess.
01:37:18 <quicksilver> it is unlikely that he knows that to be a fact
01:37:26 <dolio> The guy he was arguing with guessed "Functional Programming for Dummies".
01:37:38 <kalven> idnar: thanks for the help
01:37:42 <quicksilver> "Functional Programming by a Dummy" surely?
01:37:57 <idnar> functionally dumb programming?
01:38:05 <dolio> Well, not knowing things for facts hasn't stopped him before.
01:38:07 <tensorpudding> what does it mean for the book to be the most profitable?
01:38:14 <dolio> @quote foremost.expert
01:38:14 <lambdabot> No quotes match. My brain just exploded
01:38:21 <badsheepy> perhaps he just found it very rewarding to write
01:38:23 <badsheepy> :o
01:38:37 <tensorpudding> the one that makes the author the most royalties, the publisher the most money, or the people who read it the most money?
01:38:47 <dolio> @quote top.expert
01:38:47 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
01:39:39 <quicksilver> tensorpudding: the beneficiaries (publisher, author, other rights holders) the most money
01:39:46 <quicksilver> at least, that's the natural meaning of the term to me.
01:39:58 <tensorpudding> to me as well
01:40:02 <quicksilver> but such things are typically kept secret.
01:40:07 <tensorpudding> but he might have a funny definition of profitable
01:40:37 <pozic> If he is the most popular on Amazon, you at least have an indication if he sells there.
01:40:41 <merehap> has anyone managed to get sha to build with ghc 12.1?
01:40:58 <tensorpudding> i figured the books that sell the best are the most profitable
01:41:01 <dolio> He'll probably top the profitability mark with his latest book, which he's apparently planning to sell for 1000 pounds each.
01:41:09 <merehap> apparently the linear allocator "is out of slots"
01:41:24 <tensorpudding> 1000 UKP?!?!
01:41:29 <eevar2> his prices are certainly out of whack
01:41:38 <dolio> That's what someone quoted earlier.
01:41:54 <tensorpudding> is he that arrogant that he thinks what he wrote is worth that much?
01:42:02 <pozic> They are more like 100 euro or something like that
01:42:08 <pozic> They are market prices.
01:42:27 <dolio> http://www.reddit.com/r/programming/comments/az6td/how_to_become_rich_as_a_programmer_even_if_nobody/c0k69ak
01:42:27 <pozic> That is, he has a scarce product, so he can ask whatever he wants.
01:42:45 <pozic> How many book son OCaml are there?
01:42:56 <pozic> Especially written by people who have written applications.
01:43:13 <tensorpudding> there is a book by some french ocamlers
01:43:13 <pozic> I never read his book, though.
01:43:24 <dolio> There's Practical OCaml (I think that's right), but that was reportedly terrible.
01:44:14 <quicksilver> http://www.amazon.co.uk/gp/bestsellers/books/14159961/ref=pd_zg_hrsr_b_1_5_last
01:44:14 <tensorpudding> there's Developing Applications with OCaml
01:44:18 <tensorpudding> that's the one i mentioned
01:44:27 <quicksilver> contains many books which have higher sales ranks than his, as far as I can see
01:44:30 <idnar> pozic: that only works if there's demand for the product
01:44:37 <quicksilver> but those are current ranks not historical totals
01:45:00 <tensorpudding> according to the cover, it's by O'Reilley from France
01:45:17 <pozic> idnar: there is non-zero demand for his books.
01:46:16 <pozic> idnar: the most interesting books I read are certainly by people who do not agree with the common opinion.
01:46:30 <idnar> pozic: non-zero isn't infinite
01:46:39 <pozic> idnar: sometimes you get crackpots, sometimes you get a glimp of brilliance.
01:46:47 <idnar> pozic: heh, the only books I read are fiction
01:47:52 <dobblego> Harrop doesn't disagree; he's just a liar
01:48:37 <tensorpudding> there's a lot of copies of deitel's java book in there
01:48:55 <pozic> His books are quite expensive, though. He should become a professor and force his students to use his book.
01:49:22 <pozic> I'd love to know how the economics of professors and students using their books work.
01:49:31 <quicksilver> he's a professional troll and he's very good at it
01:49:50 <quicksilver> as is evidenced by the fact that this normally intelligent IRC channel has wasted half an hour debating his faiings
01:49:56 <quicksilver> every time we do that, he wins :)
01:50:16 <pozic> quicksilver: because it is hard to distinguish between fact and fiction for every bit Harrop outputs?
01:50:28 <idnar> quicksilver: only if we buy one of his books :P
01:50:32 <eevar2> I come across his books when i first started looking into fp. might have even bought something, if it wasn't for the outrageous prices
01:50:34 <tensorpudding> does amazon have any books by harrop?
01:50:37 <tensorpudding> i don't see any
01:50:40 <idnar> unless he has some way of making money off IRC activity ;)
01:50:44 <quicksilver> idnar: no, if *someone* buys one of his books.
01:50:48 <dolio> They have his F# book.
01:50:51 <idnar> quicksilver: well, yeah, that
01:51:00 <quicksilver> idnar: but having this kind of discussion we just raise his profile, make more people aware of him and his books etc
01:51:09 <quicksilver> that's exactly why he does it.
01:51:20 <quicksilver> (and his consultancy services too)
01:51:49 <tensorpudding> hmm, spelled his name wrong, that's why
01:52:44 <idnar> quicksilver: fair enough
01:53:00 <idnar> quicksilver: I don't really understand why people find him interesting
01:54:07 <dolio> He's fun to quote.
01:54:40 <tensorpudding> he seems to dislike haskell a lot
01:54:40 <pozic> What was his PhD thesis about?
01:54:45 <mreh> why don't we pillory him?
01:55:15 <dolio> Because it'd probably be illegal?
01:55:23 <dobblego> he's never written a single line of haskell
01:55:54 <pozic> "Structural properties of amorphous materials"
01:56:05 <mreh> The pillory illegal? Next you'll we can't Birch people any more
01:58:27 <mreh> what is an amorphous material?
01:58:39 <mreh> isn't that a contradiction in terms?
02:00:27 <pozic> mreh: more like a paradox, I suppose.
02:03:04 <mreh> I once had a guy called Jim Arlow teaching me UML, he insisted it was amazing
02:03:31 <dolio> That'd be a better story if it were Arlo Guthrie teaching you UML.
02:03:43 <mreh> I begged to differ. However he exploded when I criticised the fact that I had a minus next to a method that did addition.
02:03:55 <lpsmith> heh,  I've never did take a really serious look at UML
02:03:57 <mreh> Well, I exploded UML, he got angry.
02:04:14 <lpsmith> I glanced at a few UML things a few times,  once upon a long time ago
02:04:19 <mreh> @google Arlo Guthrie
02:04:19 <lambdabot> http://www.arlo.net/
02:04:20 <lambdabot> Title: ArloNet
02:04:59 <mreh> "F# for scientists"! What an amazingly fatuous title
02:05:16 <lpsmith> So what's the benefit of UML,  really?
02:05:23 <lpsmith> To make IBM money?
02:05:29 <mreh> uhhh... yeah, money
02:05:43 <mreh> it's like people like to feel like their doing formal methods
02:05:54 <mreh> but they can't... because they're like... stupid
02:06:06 <mreh> something like that
02:06:41 <lpsmith> heh,   yeah,  I was much more interested in the Z notation,  but a lack of readily available,  easy to use software meant I didn't go very far
02:07:45 <mreh> what were you reading? David what's his face?
02:08:14 <mreh> Monograph in computer science...? I have the book at home, formal methods for imperative programming never really tickled me.
02:08:36 <mreh> The things about proving invariants is very nice, but I do that in my head all the time.
02:09:07 <pozic> mreh: formal methods exist because humans are error-prone.
02:09:15 <mreh> Obviously I've never written a specification for a large and complex software system, these are just my personal interests.
02:09:39 <dolio> Types are nice, but I can just remember them in my head.
02:10:43 <mreh> are you mocking me?
02:11:02 <dolio> I'm saying the argument is similar.
02:12:15 <dolio> That doesn't mean that UML is a good way to specify and prove invariants, but "I can eyeball it" isn't necessarily a good argument against it.
02:12:53 <lpsmith> I don't recall;  but I was getting throughly addicted to FP at the time,  so that also helped supress my interest in Z
02:13:14 <dolio> Oh, are we talking about Z? I disconnected a little there.
02:13:57 <mreh> well, you can reason about your programs so much more easily if you are programming in the functional style
02:14:23 <mreh> Proving invariants in Java isn't necessary these days because of "Unit testing" apparently
02:14:38 <lpsmith> lol,  yeah,  we were talking about Z.   I don't entirely disagree with either your argument or mreh's :-)
02:15:28 <pheaver> looking for any information on defining your own local hackage server.  can someone point me in the right direction?
02:15:53 <lpsmith> the code that runs hackage is available on code.haskell.org
02:15:58 <pheaver> ah
02:15:59 <lpsmith> I don't know much about it though
02:16:11 <mreh> pheaver: can't you share you code with the rest of us? :(
02:16:18 <pheaver> oh here we go: http://code.haskell.org/hackage-server/
02:16:36 <lpsmith> You also don't need to run the full hackage server to run a local hackage repository
02:16:47 <pheaver> got it
02:16:48 <lpsmith> never played around with either
02:16:52 <dolio> I'm biased against Z simply because I'm not too wild about set theory, and especially not ZF.
02:17:09 <lpsmith> Set theory is what I know
02:17:31 <lpsmith> I don't love it;  I just know it better than other formalisms,  thanks to training
02:17:44 <tensorpudding> what's wrong with set theory?
02:17:58 <mreh> Russell's Paradox?
02:17:59 <lpsmith> (I wouldn't say I hate set theory either)
02:18:20 <mreh> typed set theory solves that though doesn't it?
02:18:45 <tensorpudding> russell's paradox is only valid in naive set theory
02:19:14 <tensorpudding> it's not in any of the later models like ZFC, NBG or NF
02:19:46 <lpsmith> mreh:  running a local repository that you have more precise control over can eliminate a lot of headaches;  sometimes cabal-install isn't very good at picking a compatible selection of packages,  and a new GHC release or new package uploads mean that things that used to be a few keystrokes away are now broke
02:20:38 <pheaver> oh.  yeah, i'm just doing it for proprietary code in our company or whatever
02:20:57 <mreh> lpsmith: isn't that why you define the package contraints in the cabal file?
02:21:25 <pheaver> mreh: yeah but that's the developer of the package that defines those, what he's talking about is the user
02:21:38 <lpsmith> well,  people don't always get the constraints right,  and I've seen cabal-install do some *strange* things with seemingly sensible constraints
02:21:53 <pheaver> yeah what he said :p
02:21:55 <mreh> hmm, sounds evil
02:22:03 <pheaver> ?
02:22:05 <dolio> Well, as far as ZF goes, I'm not wild about the fact that it accepts things like "1 \in 2" as well-formed formulas.
02:22:07 <mreh> black magic :)
02:22:12 <pheaver> oh
02:22:28 <dolio> I've seen set theories that rule those sorts of things out, though. I like those better.
02:23:14 <quicksilver> dolio: or you can just layer a theory on top of it
02:23:27 <quicksilver> dolio: one which has more 'type-like' properties
02:23:32 <mreh> like a cake!
02:23:45 <lpsmith> dolio, I agree;  but mathematicans don't tend to dwell on such formulae :)
02:24:21 <lpsmith> Actually,  mathematicans don't tend to dwell on the particulars of set theory,  for that matter
02:24:22 <dolio> You can. But if I were to study a set theory, it'd be a nice set theory, not an ugly set theory that I can ignore the ugliness of in practice.
02:24:56 <tensorpudding> most mathematicians don't really care about foundations
02:25:15 <tensorpudding> it's not terribly exciting
02:27:19 <quicksilver> "most mathematicians" don't really care about riemann surfaces, either
02:27:25 <quicksilver> or lebesgue integration
02:27:30 <quicksilver> or any other, single, topic ;)
02:27:36 <quicksilver> as such foundations is no different.
02:27:40 <lpsmith> So Grothendieck is still alive.
02:27:45 <FliPPeh_> I feel bad for having 90% of my code in the IO monad :(
02:27:51 <quicksilver> you should
02:28:03 <quicksilver> make 90% of it pure and just have 10% wrapper code in the IO monad
02:28:07 <FliPPeh_> But it's a heavily IO oriented programm
02:28:10 <FliPPeh_> Socket
02:28:29 <FliPPeh_> Basically, IO is just a part of the result of my other monad
02:28:42 <FliPPeh_> So I'm in the IO monad about 10% and 80% in my MPD monad
02:29:13 <FliPPeh_> "data MPD a = MPD { runMPD :: MpdConn -> IO (Response a) }"
02:29:15 <FliPPeh_> Does that count?
02:29:25 <tensorpudding> grothendieck must be pretty old now
02:29:53 <lpsmith> yeah,  he was born in the early 20s
02:30:27 <dolio> Wikipedia says he's almost 82.
02:30:43 <tensorpudding> ah
02:31:35 <FliPPeh_> @hpaste
02:31:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:32:45 <lpsmith> So after being disappeared for 20 years,  not wanting any contact with the outside world,  he's finally broke his silence to say that he doesn't want any of his books republished
02:33:45 <FliPPeh_> quicksilver: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7106#a7106 is this too much IO/Monading?
02:33:58 <FliPPeh_> Just glance at the function types, not too much too read ;x
02:34:51 <FliPPeh_> I have no idea how that could be done any other way
02:35:06 <lpsmith> well, sometimes you gotta do what you gotta do
02:35:33 <dolio> We're not mad, just disappointed.
02:36:09 <idnar> heh
02:38:23 <mreh> IO Monad aint so bad
02:39:38 <mreh> it depends on what you use it for I suppose
02:39:44 <FliPPeh_> I know haskell should be as little IO code as needed and as much pure as possible
02:39:53 <FliPPeh_> But most of what I write ends like this
02:40:05 <FliPPeh_> Probably because I chose projects like IRC bots and networking
02:40:19 <mreh> it's still pure code
02:40:41 <lpsmith> well,  I suppose you keep doing what you do,  and keep looking for better ways of expression :)
02:40:48 <mreh> is it still pure code?
02:40:59 <mreh> no, it has side effects
02:41:06 <lpsmith> I wouldn't say so
02:41:11 <lpsmith> it has real-world side effects
02:41:47 <mreh> well sometimes it's really useful to use IO monad if you can't be bothered to put it in another monad :)
02:41:53 <pozic> It is a silly discussion. There is no definition of what "pure" is.
02:42:15 <pozic> This discussion has happened before and will happen again.
02:42:27 <mreh> that is just your opinion
02:42:33 <lpsmith> but the IO monad is like a condom that prevents the real world from infecting Haskell and making extraordinarily hard to use.
02:42:34 <pozic> mreh: no, that is a fact.
02:42:40 <tensorpudding> haskell has ten or so discussions that are always going on
02:42:48 <pozic> mreh: there is no definition, so, there is nothing to prove.
02:42:58 <lpsmith> There are definitions of purity
02:43:12 <pozic> mreh: it all comes down to "I feel it is this way vs I feel it is that way".
02:43:18 <tensorpudding> "how should we teach monads" and "what is a purely functional language"
02:44:17 <pozic> lpsmith: ok, so what is a pure program? Please, cite references.
02:44:23 <mreh> I have bioinformatics in 15 minutes and I can't remember any of the 20 amino acids!
02:44:59 <pozic> Only 20 are used in the human body. More exist.
02:45:17 <mreh> "pure program" sounds like begging the question
02:45:23 <FliPPeh_> What have I started?
02:45:40 <pozic> FliPPeh_: nothing. People have been doing that for eons.
02:45:42 <mreh> FliPPeh_: it's like the Australian outback
02:45:49 <mreh> one tiny flame
02:45:58 <FliPPeh_> ;D
02:46:27 <mreh> you have pure expressions and impure expressions in Haskell
02:47:32 <mreh> the pure ones are consistent in their habits
02:48:01 <mreh> that's the "functional" part of functional programming
02:48:23 <mreh> a mathematical definition of "functional"
02:48:58 <dolio> There's a mathematical definition of "functional"?
02:49:09 <mreh> well, a function
02:49:54 <quicksilver> FliPPeh_: looks fine. It's a program about doing IO after all.
02:50:33 <quicksilver> there *are* ways to remove the IO but I'm not going to make a case they are better in this case.
02:50:45 <lpsmith> pozic:  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.27.7800   <-- one possible answer
02:51:20 <quicksilver> you can write in an abstract request/response monad which is not necessarily IO, and then you have the ability to 'run' that monad in a pure way over a trace of example requests (useful for testing) as well as running 'over IO' for real sockets
02:51:31 <quicksilver> but that's substantial abstraction cost.
02:51:40 <quicksilver> being able to test purely is handy for tracking down some kinds of bugs though.
02:51:56 <Twey> Hm… when I install HXT with cabal-install hxt, everything seems to work, no errors, modules appear under ~/.cabal/lib, cabal says it's registered them
02:52:06 <Twey> But I can't import them in GHCi
02:52:12 * hackagebot upload: uuagc 0.9.14 - Attribute Grammar System of Universiteit Utrecht (ArieMiddelkoop)
02:54:22 <quicksilver> Twey: have you restarted ghci?
02:54:34 <Twey> quicksilver: Yes
02:55:41 <quicksilver> do you have multiple ghc versions?
02:55:47 <Twey> quicksilver: No
02:55:54 <Twey> (just 6.12.1)
02:56:14 <Twey> (which is the directory under which hxt installed in ~/.cabal)
02:57:08 <quicksilver> does hxt show up in ghc-pkg list?
02:57:19 <quicksilver> what error does ghci give?
02:57:29 <Twey> quicksilver: Yes
02:57:34 <Twey> It says that the module can't be found
02:57:49 <Twey>     Could not find module `Text.XML.HXT.Arrow':
02:57:49 <Twey>       it is not a module in the current program, or in any known package.
02:59:29 <quicksilver> what is the output of ghc-pkg find-module Text.XML.HXT.Arrow ?
03:00:48 <quicksilver> (the next thing to check is ghc-pkg describe hxt and see if the 'exposed-modules' line contains Text.XML.HXT.Arrow)
03:01:19 <Twey> Ooh
03:01:33 <Twey> It found it, but I got a ‘WARNING: there are broken packages’
03:01:58 <Twey> Oh
03:02:22 <Twey> But ghc-pkg check doesn't list hxt among the broken packages (dependency problem with deepseq)
03:03:52 <Twey> ghc-pkg describe hxt does indeed list all the modules I'd expect
03:08:17 <merehap> how can I use 'runhaskell Setup.hs build' with an additional ghc option? (-fregs-graph)
03:08:52 <merehap> I was hoping --PROG-option= would work, but no luck
03:15:11 <quicksilver> Twey: OK. I'm stuck now. You could try #hackage.
03:15:55 <Twey> Hm :-\
03:20:12 <merehap> has anyone managed to install the SHA package with ghc 12.1? I keepd triggering a bug in the linear allocator
03:20:20 <merehap> keep*
03:21:11 <harlekin> Is the original paper about Template Haskell good to learn Template Haskell or does the information there not apply to ghc's current implementation?
03:23:33 <FliPPeh_> Wow, when I started haskell I wondered how people could mangle their functions in all possible ways to combine them to a point free style
03:23:36 <FliPPeh_> Now I'm doing it myself.
03:23:57 <FliPPeh_> sendCommand cmd = getConn >>= (liftIO . flip hPutStrLn cmd . mpdHandle)
03:41:38 <moshisushi> is it possible to performance test parsec-based code with a profiler?
03:41:49 <moshisushi> do i need to compile parsec in some special way?
03:42:25 <tomh-> probably the same way as if you want to profile normal haskell apps
03:53:46 <isr> Hello. I've got a really dumb question (just starting to learn haskell). Mind if I ask here?
03:54:03 <FauxFaux> OUT WITH IT
03:54:03 <endojelly> isr, not at all, just ask
03:54:29 <zygoloid> isr: if anything we'd prefer questions about haskell to questions about questions about haskell :)
03:55:51 <isr> Ok. I've got a function which takes in one of my own types
03:55:57 <tensorpudding> i meta-love meta-questions
03:55:59 <isr> This type has a number of Int fields
03:56:26 <isr> the function takes 2 of the field, divides them, and returns the result
03:56:45 <isr> First, let me just post the version which does work
03:57:01 <zygoloid> @quote 8-ball
03:57:02 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
03:57:38 <theorbtwo> isr: The question is how to make it more readable?
03:58:09 * zygoloid predicts the 'version which does work' has an accompanying 'version which does not work' :)
03:58:42 <isr> sorry, just a sec
03:58:57 <zygoloid> isr: http://hpaste.org is a good haskell pastebin
04:00:44 <isr> -- type synonyms
04:00:44 <isr> type Name = String
04:00:44 <isr> type Matches = Int
04:00:44 <isr> type Runs = Int
04:00:44 <isr> type Innings = Int
04:00:45 <isr> type Wickets = Int
04:00:45 <isr> type Catches = Int
04:00:49 <isr> -- a polymorphic type
04:00:51 <isr> data Cricketer = Batter Name Matches Runs Innings
04:00:53 <isr> 	| Bowler Name Matches Wickets Runs
04:00:55 <isr> 	| Keeper Name Matches Catches
04:00:57 <isr> 	deriving (Eq, Show)
04:01:00 <isr> careerAve :: (Fractional a) => Cricketer -> a
04:01:01 <isr> careerAve (Batter _ _ runs innings) = (fromIntegral runs) / (fromIntegral innings)
04:01:03 <isr> careerAve _ = 0
04:01:05 <isr> -- lets populate some variables
04:01:07 <isr> p1 = Batter "Javed Miandad" 100 9000 170
04:01:09 <isr> p2 = Bowler "Imran Khan" 90 380 8000
04:01:11 <isr> p3 = Batter "Inzi" 110 9500 200
04:01:13 <isr> p4 = Keeper "Imitaz" 30 100
04:01:15 <isr> (sorry for the flooding)
04:01:16 * Lemmih frowns at isr.
04:01:19 <isr> question is this
04:01:23 <theorbtwo> isr: Do *not* paste like that into *any* IRC channel.
04:01:30 <isr> sorry guys
04:01:39 <isr> I'll pastebin it next time
04:01:44 <isr> apologies
04:01:49 <theorbtwo> That's why zygoloid linked to hpaste.org.
04:02:21 <quicksilver> isr: but, anyhow, what's the problem/question ?
04:02:42 <isr> ok, the function careerAve
04:02:46 <isr> as it stands, it works
04:03:43 <isr> But, why can't I have a type signature of    careerAve :: (Num a) => Cricketer -> a
04:03:54 <zygoloid> @type (/)
04:03:55 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:04:04 <isr> Does the (/) function not return a Num ?
04:04:29 <zygoloid> it returns a subclass of Num which defines (/) :)
04:04:43 <isr> Fractional is a subclass of Num
04:05:04 <isr> so shouldn't (Num a) work (for careerAve) ?
04:05:15 <isr> confused
04:05:15 <zygoloid> right. but for instance, Int is an instance of Num but is not an instance of Fractional. if it returned Num a => a, then callers could demand an Int result, which it can't create
04:05:28 <idnar> isr: you've got the relationship the wrong way around
04:05:54 <idnar> isr: the fact that it's a subclass means that if there is an instance Fractional a, there is an instance Num a; but the reverse does not apply
04:06:14 <idnar> for example, there is no Fractional instance for Integer
04:06:22 <idnar> > (5 :: Integer) / 6
04:06:23 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
04:06:23 <lambdabot>    aris...
04:06:30 <zygoloid> isr: if a function demands an instance of Num, you can give it an instance of Fractional (because every Fractional is a Num) but if it produces a Fractional, you can't pretend it produces every sort of Num.
04:07:08 <quicksilver> isr: yes, it returns *A* Num
04:07:26 <quicksilver> isr: but the signature Num a => Cricketer -> a says it returns *ALL* possible Nums
04:07:30 <quicksilver> that's the difference.
04:07:38 <isr> ah, I just looked at :t (+), and I see the diff between that and :t (/)
04:07:38 <quicksilver> whatever it returns will definitely be a Num, that's true.
04:07:49 <quicksilver> but it can't return all possible nums.
04:07:55 <isr> (+) returns any kind of Num, but (/) doesn't. Is that it?
04:08:04 <isr> I see ...
04:08:11 <zygoloid> isr: when there's a free variable in a type (like the 'a' in careerAve), the /caller/ gets to choose the value of 'a', not the function.
04:08:13 <quicksilver> yes. (+) works on Ints, for example, while (/) doesn't.
04:08:40 <isr> ok, so let me ask this then
04:08:46 * zygoloid adds an 'in haskell'98' clause to his previous comment
04:09:01 <isr> I have a function, which divides 2 numbers, and returns the result
04:09:30 <isr> The inputs are Ints, but I want to return either an Int (if there is no remainder), or a float (if there is)
04:09:35 <isr> In other words:
04:09:43 <Sgeo_> What types of Nums are there that aren't Fractional nums?
04:09:56 <Sgeo_> That was a stupid question, n/m
04:10:07 <quicksilver> isr: you can't do that.
04:10:11 <isr> ah
04:10:18 <quicksilver> isr: functions can't choose their return type based on their parameters.
04:10:25 <quicksilver> and really, you wouldn't want that in this case anyway.
04:10:34 <zygoloid> isr: remember, the /caller/ gets to choose the type 'a' in your careerAve :: Fractional a => Thing -> a
04:10:48 <zygoloid> careerAve doesn't get the choice, it gets told what 'a' will be
04:11:03 <isr> I see
04:11:30 <theorbtwo> I tend to think of it returning something which is all Fractional at once, and later things paring that down.
04:11:35 <isr> man, I've been scratching my head over this one
04:11:38 <theorbtwo> It works out to the same thing, though... I think.
04:12:14 * Trafalgard boggles
04:12:17 <isr> ok, so to take a step back
04:12:24 <isr> I have 2 Ints
04:12:26 <zygoloid> @type let divide a b | a `mod` b == 0 = Left (a `div` b) | otherwise = Right (fromIntegral a / fromIntegral b) in divide :: Int -> Int -> Either Int Float  -- what you asked for :)
04:12:27 <lambdabot> Int -> Int -> Either Int Float
04:12:48 <Trafalgard> if I run this without tracing it, it runs some distance through several functions, prints a bunch of debug code, and then gets locked in an infinite loop without printing <<loop>>
04:13:04 <zygoloid> theorbtwo: your characterization is more accurate in the presence of existentials
04:13:19 <isr> Holy ......
04:13:19 <Trafalgard> if I try to trace it in GHCI, it throws an exception before getting anywhere near that point
04:13:20 <Trafalgard> wtf
04:13:38 <theorbtwo> isr: Is there any reason *not* to always return a Fractional here?
04:14:15 <Trafalgard> ... I don't think doesFileExist should be throwing exceptions when a file doesn't exist?
04:14:39 <isr> theorbtwo: its just a contrived example :)
04:15:07 <isr> zygoloid: thanks. I'll have to digest that one slowly ....
04:15:27 <theorbtwo> Yeah, when asking for something that the language or etc just doesn't do, you really need a non-contrived example.
04:15:33 <isr> theorbtwo: I guess this clarified that I've been thinking about this incorrectly
04:15:38 <tensorpudding> Either allows you to return a result of two different possible values
04:15:42 <isr> theorbtwo: :)
04:15:58 <tensorpudding> err, two different possible types
04:16:00 <theorbtwo> The end is usually that there's a better way to accomplish what you set out to do, but in a contrived example, that solution isn't available.
04:16:35 <zygoloid> Trafalgard: according to the source it's "doesFileExist name = (...) `catch` (const (return False) :: IOException -> IO Bool)
04:16:42 <isr> thanks guys (and apologies for the silly copy/paste flood, wasn't thinking)
04:16:45 <zygoloid> so it looks like it shouldn't be throwing any IOExceptions
04:16:55 <isr> another thing
04:17:56 <theorbtwo> tensorpudding: The thing is, Either doesn't, exactly.  It allows you to return one type, which has a bit of data in it of one type or the other.
04:18:00 <isr> see in careerAve, where for any other pattern match, it just returns '0'. Can I return 'False' instead? In other words, can I have 2 different types of return values, depending on which pattern 'clause' is matched within the function?
04:18:14 <theorbtwo> Either Int Float is just a pain to deal with.
04:18:21 <tensorpudding> theorbtwo: yes, it needs to have the information on which type it is to be useful
04:18:32 <tensorpudding> you have to pattern match on the Either to actually use it
04:18:44 <zygoloid> isr: not exactly. but the Maybe type constructor is great for cases where you may or may not have a result.
04:19:02 <Trafalgard> Could there be any way that catch could be getting disabled during tracing?
04:19:10 <Trafalgard> or during a stack overflow or the like?
04:19:19 <Trafalgard> because I saw it happening last night during stack overflows as well
04:19:37 <Trafalgard> of course, I was tracing through them, so hey
04:19:45 <zygoloid> isr: for instance:  careerAve (Batter _ _ runs innings) = Just (runs % innings); careerAve _ = Nothing
04:20:14 <zygoloid> there, careerAve :: Cricketer -> Ratio Int
04:20:29 <zygoloid> sorry, Cricketer -> Maybe (Ratio Int)
04:20:47 <zygoloid> @quote initial
04:20:47 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
04:21:07 <isr> I see, The Maybe type really holds 2 different classtypes
04:21:36 <tensorpudding> it holds a value of some type, or "nothing"
04:21:41 <zygoloid> "data Maybe a = Nothing | Just a"
04:22:02 <isr> Is Nothing a classtype?
04:22:07 <tensorpudding> classtype?
04:22:15 <tensorpudding> Nothing is a data constructor
04:22:16 <zygoloid> Nothing is a value, like 42.
04:22:18 <tensorpudding> @type Nothing
04:22:19 <lambdabot> forall a. Maybe a
04:22:21 <Trafalgard> _exception :: e = GHC.Exception.SomeException (GHC.Exception.:DException _
04:22:23 <Trafalgard>                                                              (GHC.Show.:DShow ..
04:22:29 <Trafalgard> .) ....)
04:22:49 <isr> sorry, typeclass
04:22:53 <isr> doh!
04:23:02 <Saizan> Nothing is not a typeclass either
04:23:04 <tensorpudding> there aren't any typeclasses involved with NOthing
04:23:23 <tensorpudding> you can think of Nothing as akin to []
04:23:34 <tensorpudding> [] is a list of any kind you want
04:23:42 <Saizan> Nothing lives at the value level, it one way you can use to construct a value of type Maybe a
04:24:03 <Saizan> s/it/it's/
04:24:04 <tensorpudding> but there's nothing really "contained" in it
04:24:23 <Trafalgard> using :force says that it's an GHC.IOBase.IOError Nothing GHC.IOBase.NoSuchThing and then annoyingly lists individual characters instead of a string, but what it says is "does File Exist" "No such file or directory" Nothing
04:24:24 <ablmf1> When I try to build a package timeit, I got this error message : Setup.hs: ar is required but it could not be found.
04:24:28 <ablmf1> What is "ar" ?
04:24:31 <Saizan> typeclasses are predicates over types
04:25:12 <zygoloid> Trafalgard: it's possible (i guess) that this is an issue with base-3 versus base-4 incompatibility
04:25:14 <Trafalgard> (it is a string, it's just going ['d', 'o', 'e', 'etc'
04:25:25 <isr> Ok, onwards with the tutorials then (to make more sense of it all). Will definately be back with (even) more dumb questions (err, pastebin next time!!) - you chaps have been very helpful. Thanks
04:25:30 <Trafalgard> )
04:25:39 <Saizan> ablmf1: ar is an utility to create archives, it's used to make .a files out of multiple .o ones
04:25:44 <zygoloid> Trafalgard: (in particular, perhaps the `catch` it's doing isn't correct with extensible exceptions?)
04:26:12 <zygoloid> isr: good luck.
04:26:29 <isr> thanks :)
04:27:15 <Saizan> Trafalgard: if you're in the ghci and set -fbreak-on-exceptions then you first break on an exception and if you make it continue the catch will kick in
04:27:18 <theorbtwo> Has anybody else, by the way, had a problem with Real World Haskell having really obnixious homework problems?  Does it get better after the first couple chapters?
04:27:21 <FliPPeh_> Suppose I have a list of tuples, i. e. [("id", "3"), ("something", "anything"), ("id", "4") ...], and every "id" key introduces a new block until the next "id" key appears, HOW would I process it to get something like [Stuff { id = "3", something = "anything" }, ...] ?
04:27:26 <Saizan> Trafalgard: in the ghci debugger i meant
04:27:34 <Trafalgard> There's a way to continue? :P
04:27:39 <FliPPeh_> But I don't know how many elements there are inbetween the ID keys
04:27:45 <FliPPeh_> That could vary :/
04:27:48 <Saizan> Trafalgard: :step is one way
04:28:04 <Trafalgard> okay
04:28:11 <Saizan> Trafalgard: :continue too
04:28:14 <Trafalgard> Stopped at exception thrown!
04:28:14 <Saizan> Trafalgard: see :help
04:28:18 <Trafalgard> heh.
04:28:22 * Trafalgard tries :continue instead
04:28:28 <Trafalgard> Hey, there we go.
04:28:47 <Trafalgard> Exception again. This is probably going to happen repeatedly.
04:28:53 <Trafalgard> This is not going to be fun.
04:29:17 <Trafalgard> Is there any way to, um, DISABLE this except for when I hit ctrl-c?
04:29:37 <Trafalgard> Or to make it not break inside catch statements?
04:30:52 <Saizan> > groupBy (\_ (a,b) -> a /= "id") [("id", "3"), ("something", "anything"), ("id", "4"), ("foo","bar")]
04:30:53 <lambdabot>   [[("id","3"),("something","anything")],[("id","4"),("foo","bar")]]
04:30:58 <Trafalgard> Also, I don't suppose this might be fixed in a newer GHC version (I'm using 6.10.3 still, haven't upgraded yet since the last time I checked the only recommended version of GHC available was 6.10.4)
04:31:13 <Saizan> Trafalgard: check the docs
04:31:27 * Saizan never used the ghci debugger much
04:31:37 <Trafalgard> The docs have not been terribly helpful
04:31:46 <Saizan> i suspected so :)
04:32:20 <Trafalgard> they don't even mention command-line arguments to GHCI
04:32:37 <Trafalgard> either that or I managed to miss them despite looking through it three times for them
04:33:00 <Saizan> why are you using the debugger, btw?
04:33:00 <Trafalgard> GHCI said to see the user guide or whatnot for additional command-line arguments or something
04:33:03 <Trafalgard> but there weren't any there
04:33:19 <Trafalgard> in order to break in the middle of the infinite loop to find out where it is
04:33:43 <Trafalgard> but I can't get there if it keeps stopping everywhere else
04:34:26 <Saizan> Trafalgard: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html <- this seems to explain how to use every command in detail
04:34:26 <Trafalgard> It isn't draining more and more RAM once it goes into the infinite loop or whatever it's doing
04:34:38 <Trafalgard> it just freezes
04:35:06 <Trafalgard> I had another one yesterday that I already figured out that was, and that stack overflowed and was much easier to track down as a result
04:35:20 <Trafalgard> since GHCI generated an exception for it
04:35:37 <Saizan> Trafalgard: "-fbreak-on-error, which works similarly but stops only on uncaught exceptions"
04:35:44 <Saizan> from http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
04:35:44 <Trafalgard> aha
04:36:12 <FliPPeh_> No ideas?
04:36:14 <Trafalgard> I have four or five of those docs pages bookmarked and looked through them, but hadn't found that yet
04:36:25 <Trafalgard> thanks
04:36:30 <Saizan> FliPPeh_: seen my groupBy above?
04:36:45 <Saizan> > groupBy (\_ (a,b) -> a /= "id") [("id", "3"), ("something", "anything"), ("id", "4"), ("foo","bar")]
04:36:46 <lambdabot>   [[("id","3"),("something","anything")],[("id","4"),("foo","bar")]]
04:37:00 <Trafalgard> I was looking at some completely different docs, too
04:37:08 <Trafalgard> the man file, probably
04:37:20 <Trafalgard> except it had indentation, so probably not quite
04:37:25 <Trafalgard> but it was not very useful
04:37:56 <FliPPeh_> Saizan: didn't notice, I'll tkae a look
04:38:16 <Trafalgard> I had found pages which mentioned a bunch of +RTS commands though
04:39:12 <Saizan> FliPPeh_: then i'd write a function [(String.String)] -> Stuff manually and map it
04:39:35 <Trafalgard> huh
04:39:38 <Saizan> or maybe i'd make Stuff = Map String String and just use fromList
04:39:40 <Trafalgard> "Not stopped at a breakpoint"
04:39:47 <Trafalgard> :/
04:40:01 <Trafalgard> I guess ctrl+c doesn't count as an error!
04:42:03 <FliPPeh_> Saizan: Works great, thanks!
04:42:04 <FliPPeh_> :)
04:50:40 <Saizan> FliPPeh_: np :=
04:50:43 <Saizan> )
04:51:09 <Saizan> FliPPeh_: it's a bit hacky since it exploits an implementation detail of groupBy
04:55:31 <FliPPeh_> Saizan: But it works GREAT, I didn't even have to add any special treatment, I can just group the whole list and map my already written "makeSong" function over it, which turns that list into a beautiful list of MpdSong records
04:56:03 <zygoloid> FliPPeh_: it works great until you move to a different compiler or a different version of base :)
04:56:35 <FliPPeh_> What's the exploit here?
04:56:38 <FliPPeh_> Just wondering
04:56:49 <FliPPeh_> groupBy seems to be defined for things like this
04:57:00 <zygoloid> it's assuming that the LHS of the relation passed to groupBy is the first element of the group
04:57:31 <zygoloid> iirc groupBy requires the relation you give it to be an equivalence relation
04:57:32 <FliPPeh_> What'd be the correct behaviour?
04:59:18 <zygoloid> the behaviour of a correct programmer would be to give groupBy an equivalence relation :)
04:59:32 <FliPPeh_> Well, by the time it starts to fail on me, I should be able to fix that :)
05:00:13 <Jonno_FTW> how can i have an empty string?
05:00:55 <FliPPeh_> Jonno_FTW: ""
05:00:58 <FliPPeh_> []
05:01:03 <FliPPeh_> Any of them
05:01:18 <Jonno_FTW> i get this error:     lexical error in string/character literal at character '\''
05:01:26 <FliPPeh_> > null ""
05:01:27 <lambdabot>   True
05:01:36 <FliPPeh_> Why a ' ?
05:01:59 <Jonno_FTW> i have this
05:02:02 <Jonno_FTW> f n | n == 1 = ''
05:02:04 <Jonno_FTW>     | n `rem` 3 == 0 ='D'
05:02:12 <FliPPeh_> You mean an empty character
05:02:15 <Jonno_FTW> yep
05:02:18 <FliPPeh_> Erm
05:02:19 <zygoloid> FliPPeh_: using Data.List.Split, you could write: split . keepDelimsL . whenElt (("id"==) . fst)
05:02:21 <FliPPeh_> Good question indeed
05:02:27 <FliPPeh_> You COULD do "Maybe Char"
05:02:37 <FliPPeh_> Or have a character you treat as empty
05:02:41 <FliPPeh_> Like '\0'
05:05:10 <Saizan> Jonno_FTW: strings and characters are different types
05:05:19 <Saizan> String vs. Char
05:05:19 <Jonno_FTW> ij
05:05:30 <Jonno_FTW> yep
05:05:42 <Saizan> in case you meant to really return strings from your function
05:06:02 <FliPPeh_> I'd simply declare \0 to be my "char is empty" value
05:06:04 <Jonno_FTW> the function a char
05:06:08 <FliPPeh_> If not Maybe Char
05:07:30 <Jonno_FTW> i think i'll let it slide
05:08:07 <Jonno_FTW> and not worry about it
05:09:13 <FliPPeh_> It's not like this is awesomly complicated to do :x
05:09:32 <FliPPeh_>  f n | n == 1 = Nothing
05:09:43 <FliPPeh_>  n `rem` 3 == 0 =Just 'D'
05:10:20 <Jonno_FTW> the resultant string will only have an extra 'U' at the end
05:10:27 <Jonno_FTW>     | n `rem` 3 == 1 ='U'
05:10:29 <Jonno_FTW>     | n `rem` 3 == 2 ='d
05:34:40 <mreh> specifying dependencies is frightening
05:35:06 <mreh> like when you have complex dependency realtionships
05:39:24 <FliPPeh_> mreh: Beware of cyclic dependencies!
05:39:54 <FliPPeh_> I once ended up in an endless loop of dependencies and it took me 10 minutes to figure out what's wrong :D
05:40:19 <Jonno_FTW> how does that even work?
05:40:35 <FliPPeh_> Package one depends on package two, package two depends on package one
05:40:48 <Jonno_FTW> wow
05:40:54 <FliPPeh_> If you have a package manager that's looking ahead before installing, this can happen
05:41:10 <FliPPeh_> In this case it was my system's package manager :)
05:41:16 <Jonno_FTW> apt?
05:41:19 <FliPPeh_> Pacman
05:41:37 <FliPPeh_> Arch Linux
05:41:54 <Jonno_FTW> I use Debian
05:42:26 <FliPPeh_> :)
05:42:57 <mreh> cyclic dependencies... that's impossible
05:43:06 <FliPPeh_> Tell pacman about it
05:43:15 <FliPPeh_> It was a package in the user repos
05:43:29 <FliPPeh_> There was also a package depending on itself
05:43:41 <zygoloid> the same version of itself, i hope?
05:43:44 <FliPPeh_> I wonder who lets those in
05:43:45 <Jonno_FTW> is this the result of bad documentation?
05:43:47 <burp> lol
05:43:57 <burp> an earlier version ;)
05:44:10 <FliPPeh_> Probably not a newer version
05:44:26 <FliPPeh_> That's like me asking my future me.
05:45:58 <Saizan> that would be great
05:46:30 <FliPPeh_> Sadly, everything insanly awesome is impossible.
05:47:30 <Jonno_FTW> couldn't a circular dependency be resolved by just compiling package A and then B
05:47:39 <Jonno_FTW> seeing as they rely on each other
05:47:54 <FliPPeh_> It could, but pacman didn't think about installing any one of them before the other was installed :)
05:48:01 <dschoepe> FliPPeh_: that comes close: http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
05:54:25 <FliPPeh_> dschoepe: that hurts
06:09:52 <fasta> Does anyone know of a correct implementation of a ray-ray intersection test, which also returns two rays facing each other as an intersection?
06:11:08 <ddarius> fasta: Usually those types of tests (implicitly) return the point of intersection (if any).  There would be infinitely many in that case.
06:12:28 * RayNbow wonders if Higher-kinded C# would look like this: http://dpaste.com/157415/
06:12:30 <fasta> ddarius, I am interested in the point of intersection which lies closest to the origin of both rays.
06:12:41 <fasta> ddarius, I suppose I will just have to write it myself.
06:12:58 <fasta> Really annoying that basic geometry is not available in libraries.
06:14:57 <ddarius> fasta: What you are asking for isn't something that is commonly wanted.  I doubt you'd find such a function in many geometry libraries.
06:16:28 <ddarius> I would just write a normal ray-ray intersection test (which is easy) and special-case the collinear case.
06:16:32 <FliPPeh_> My MPD library is really looking good
06:16:53 <FliPPeh_> Within 2 days I relearned everything I have forgotten about Haskell, and even new things
06:17:06 <fasta> ddarius, yes, that's what I am already doing.
06:17:10 * FliPPeh_ is looking forward to becoming the best Haskeller ever
06:19:43 <RayNbow> bah... my first attempt at a higher-kinded C# syntax has limitations...
06:21:28 <mm_freak> RayNbow: are you trying to add higher-kindedness to C#?
06:21:47 <RayNbow> mm_freak: only trying to figure out how it would look like
06:21:53 <mm_freak> i don't think it requires any extra syntax…  it just requires the compiler to allow it
06:22:28 <RayNbow> or well, I'm trying to figure out how IFunctor would look like in a higher-kinded C#
06:22:28 <mm_freak> in fact, if you try to compile such code, the compiler specifically says:  the generic can't itself be genereic
06:23:19 <RayNbow> http://dpaste.com/157415/ <-- my first attempt is a bit limiting in certain cases
06:23:49 <fasta> RayNbow, nobody cares about C#.
06:24:14 <FliPPeh_> I actually hate it :X
06:24:27 <FliPPeh_> Even with Mono it's MS only.
06:25:04 <RayNbow> fasta: but I do... I could use it to demonstrate how weak its type system is ;)
06:26:15 <Jonno_FTW> what's wrong with C#?
06:26:26 <FliPPeh_> It'S a copy of Java
06:26:27 <RayNbow> FliPPeh_: the specs are freely available though
06:26:31 <RayNbow> FliPPeh_: no it isn't
06:26:35 <FliPPeh_> Oh come on
06:26:49 <FliPPeh_> The early versions were a 95% copy of java
06:26:52 <FliPPeh_> They have only added stuff
06:26:57 <Saizan> ok, this is way off topic.
06:27:05 * Axman6 agrees
06:27:09 <Jonno_FTW> is it an improvement though?
06:27:11 * FliPPeh_ agrees, too
06:27:26 <FliPPeh> Damn underscores
06:27:55 <ben> Surely C# is more like Haskell than Java is
06:32:41 <FliPPeh> @src id
06:32:42 <lambdabot> id x = x
06:32:46 <FliPPeh> :o)
06:32:48 <Zao> C# is like Java, but good instead.
06:33:27 <ben> Is it possible to define id in points-free?
06:33:31 <FliPPeh> And mostly unusable under Linux because most linux people hate C# and don't want mono
06:33:41 <FliPPeh> ben, that'd be "id ="
06:33:43 <FliPPeh> So no
06:34:11 <medfly> @pl id x = x
06:34:11 <lambdabot> id = id
06:34:15 <medfly> funky.
06:34:18 <ben> I saw that coming :V
06:34:27 <ben> @type unsafePerformIO . return
06:34:28 <lambdabot> Not in scope: `unsafePerformIO'
06:34:30 <FliPPeh> What does @pl do?
06:34:31 <Saizan> that doesn't actually work, of course
06:34:33 <FliPPeh> @help pl
06:34:33 <lambdabot> pointless <expr>. Play with pointfree code.
06:34:37 <FliPPeh> Ahh
06:34:39 <ben> @type fromJust . Just
06:34:40 <lambdabot> forall a. a -> a
06:34:40 <RayNbow> FliPPeh: well yes, early versions of C# didn't differ much from Java... but it has grown a lot and made different design choices
06:34:57 <Saizan> ?type ap return return
06:34:57 <ben> Such as uppercasing method names. Madness!
06:34:58 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:34:58 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
06:34:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:35:02 <RayNbow> (for example, Java has use-site co/contravariance... C# now has def-site co/contravariance)
06:35:31 <Saizan> ?type return `asTypeOf` const
06:35:32 <lambdabot> forall a b. a -> b -> a
06:35:45 <Saizan> ?type ap return return `asTypeOf` id
06:35:46 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:35:46 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
06:35:46 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:35:55 <Saizan> ?type ap return
06:35:56 <lambdabot> forall b a. (b -> a) -> b -> b
06:36:01 <FliPPeh> Meh, I'll never be a fan of C#. Even the license it is provided with is nonsense.. Microsoft Community Promise...
06:36:03 <Saizan> heh
06:36:06 <FliPPeh> Revokable at any time
06:36:12 <Saizan> ?type ap return Just
06:36:13 <lambdabot> forall b. b -> b
06:36:43 <FliPPeh> @pl hello world = putStrLn world
06:36:44 <lambdabot> hello = putStrLn
06:37:00 <FliPPeh> @pl  compress (x,y) = (show x) ++ ":" ++ (show y)
06:37:00 <lambdabot> compress = uncurry ((. ((':' :) . show)) . (++) . show)
06:37:05 <FliPPeh> What!
06:37:31 <FliPPeh> > let cp = ((. ((':' :) . show)) . (++) . show) in cp (1,4)
06:37:32 <lambdabot>   {()->"(1,4):()"}
06:37:44 <FliPPeh> lambdabot isn't perfect :(
06:38:00 <FliPPeh> > let cp = uncurry ((. ((':' :) . show)) . (++) . show) in cp (1,4)
06:38:01 <lambdabot>   "1:4"
06:38:02 <FliPPeh> Oh
06:38:07 <FliPPeh> Let me revoke my last statement
06:38:35 <byorgey> @vixen are you perfect?
06:38:36 <lambdabot> yes, i am
06:38:36 <mreh> what could my project be using that depends on haskell-src?
06:39:10 <FliPPeh> @pl getResponse cmd = sendCommand cmd >> readBlock >>= (either fail return . parseResponse)
06:39:10 <lambdabot> getResponse = (either fail return . parseResponse =<<) . (>> readBlock) . sendCommand
06:39:22 <mreh> oh, haskore
06:39:26 <mreh> strange
06:39:44 <FliPPeh> Little bugger just flipped my statements around
06:40:01 <medfly> it also made it pointless
06:40:07 <FliPPeh> Yes
06:40:18 <FliPPeh> It's impressive actually
06:41:09 <FliPPeh> @pl withMPDx host port m = do h <- safeConnect host prt; maybe errorFail run h
06:41:09 <lambdabot> (line 1, column 52):
06:41:09 <lambdabot> unexpected ";"
06:41:09 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
06:41:10 <mreh> pointless, never gets old
06:41:24 <byorgey> how about  sendCommand >=> const readBlock >=> (either fail return . parseResponse)
06:41:25 <FliPPeh> Doesn't like do
06:41:46 <FliPPeh> How about this...
06:42:02 <FliPPeh> @pl safeConnect host port = catch (liftM Just $ connectTo host port)  (const $ return Nothing)
06:42:03 <lambdabot> safeConnect = flip flip (const (return Nothing)) . ((catch . fmap Just) .) . connectTo
06:42:19 <FliPPeh> flipflip :)
06:42:20 <byorgey> ugh
06:42:23 <FliPPeh> :t flip flip
06:42:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:42:56 <byorgey> :t flip
06:42:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:43:03 <byorgey> what!
06:43:06 <FliPPeh> Some liines should be left unpointfree'd
06:43:11 <FliPPeh> Just for readability
06:43:36 <byorgey> oh, I see, it's been generalized a la (.)
06:43:39 <Axman6> FliPPeh: s/some/most
06:43:55 <FliPPeh> Axman6: Many can still be read just fine
06:44:35 <FliPPeh> makeSongs      = map makeSong . groupBy (\_ (a,b) -> a /= "file")
06:44:41 <FliPPeh> Like this on
06:44:42 <FliPPeh> e
06:44:44 <Axman6> if there more than one of {flip, const, ap}, then you're doing it wrong
06:44:48 <Axman6> ^^^ Axman's law
06:45:29 <FliPPeh> So I'm doing it right :)
06:45:31 <FliPPeh> :t const
06:45:32 <lambdabot> forall a b. a -> b -> a
06:45:37 <FliPPeh> What does that even do?
06:45:48 <FliPPeh> > const "A" "B"
06:45:49 <lambdabot>   "A"
06:45:54 <Axman6> > const True FFalse
06:45:55 <lambdabot>   Not in scope: data constructor `FFalse'
06:45:57 <Axman6> > const True False
06:45:58 <lambdabot>   True
06:46:03 <FliPPeh> And why does it do?
06:46:15 <FliPPeh> That's just an id with a useless parameter ;x
06:46:18 <Axman6> it's useful for making things pointfree
06:46:54 <Axman6> > zipWith const "Take the first ten characters" [1..10]
06:46:55 <lambdabot>   "Take the f"
06:47:22 <Axman6> > zipWith const "Take the first ten characters" "Make the first this length"
06:47:23 <lambdabot>   "Take the first ten charact"
06:47:28 <byorgey> FliPPeh: it's useful for making constant functions, which is useful for constructing arguments to higher-order functions
06:47:52 <FliPPeh> Mhh :/
06:48:09 <FliPPeh> I don't really see how I could apply it
06:48:14 <Saizan> > let xs = "Take the first ten characters" in zipWith const xs (drop 10 xs) -- initN
06:48:15 <lambdabot>   "Take the first ten "
06:48:58 <Saizan> FliPPeh: ever written "\_ -> ..."? if not then you didn't need const yet
06:49:03 <ddarius> ap and const (in an untyped language) are Turing complete.
06:49:16 <ddarius> Better, ever write: do foo; bar
06:49:52 <ketil> Given discussion at http://lwn.net/Articles/372384/#Comments - do we set fadvise with FADV_SEQUENTIAL  for readFile?  This only allows sequential access, right?
06:51:38 <ddarius> :t curry fst
06:51:39 <lambdabot> forall a b. a -> b -> a
06:53:05 <mux> ketil: fadvise() sounds like something Linux-specific; there is madvise() and posix_madvise() though, and MADV_SEQUENTIAL - but it's only a hint for the VM, it doesn't prevent non-sequential access
06:54:35 <FliPPeh> @src (*)
06:54:35 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:55:27 <tcleval> is there a haskell to java or maybe haskell to some VM compiler?
06:55:40 <FliPPeh> Wow
06:55:52 <FliPPeh> Converting a purely functional language to Java?
06:56:13 <Zao> FliPPeh: Just implement a STG machine on the JVM and off you go.
06:57:07 <Zao> Also, http://wiki.brianweb.net/LambdaVM/LambdaVM
07:00:14 <FliPPeh> > (++) <$> Just "Hello " <$> Just "World"
07:00:15 <lambdabot>   Couldn't match expected type `a -> a1'
07:00:15 <lambdabot>         against inferred type `Data....
07:00:29 <FliPPeh> > (++) <$> Just "Hello " <*> Just "World"
07:00:30 <lambdabot>   Just "Hello World"
07:01:59 <Jonno_FTW> is there a way to clear the memory ghc is using?
07:03:16 <silver__> kill ghc?
07:05:11 <Jonno_FTW> i spose
07:07:20 <Jonno_FTW> also
07:07:39 <Jonno_FTW> what is the best way to go about building up a list of precalculated values
07:07:53 <Jonno_FTW> such that later calculations can use the precalculated ones to speed up
07:08:10 <Jonno_FTW> since the next sequences are already calculateed
07:08:20 <tcleval> it looks like a table to me
07:08:35 <nuba> http://www.haskell.org/haskellwiki/Memoization
07:09:06 <nuba> Jonno_FTW: ^
07:09:11 <Jonno_FTW> thanks
07:09:17 <tcleval> that is cool
07:14:43 <Jonno_FTW> what is =~= ?
07:15:04 <FliPPeh> :t (=~=)
07:15:06 <lambdabot> Not in scope: `=~='
07:15:17 <Jonno_FTW> it's in that memoization article
07:17:05 <FliPPeh> > getZipList $ (,) <$> ZipList [1..] <*> ZipList "Now this is interesting"
07:17:06 <lambdabot>   [(1,'N'),(2,'o'),(3,'w'),(4,' '),(5,'t'),(6,'h'),(7,'i'),(8,'s'),(9,' '),(1...
07:17:18 <FliPPeh> > getZipList $ (,) <$> ZipList [1..] <*> ZipList ["Now this is interesting"]
07:17:19 <lambdabot>   [(1,"Now this is interesting")]
07:17:30 <FliPPeh> > getZipList $ (,) <$> ZipList [1..] <*> ZipList ["Now", "this", "is", "interesting"]
07:17:31 <lambdabot>   [(1,"Now"),(2,"this"),(3,"is"),(4,"interesting")]
07:17:34 <FliPPeh> :)
07:17:46 <ludflu> Hi Haskellers. I'm looking at using zippers to modify a rose tree. All the examples I can find are just for binary trees. Could anyone point me in the right direction?
07:18:59 <fasta> ludflu, there is already a package on Hackage which does that.
07:19:30 <fasta> ludflu, the xml package is also based on it.
07:19:47 <ludflu> fasta: that's great news. thanks
07:19:51 <fasta> Outside of that, I have never needed zippers, although I implemented them twice.
07:20:21 <ludflu> fasta: you never needed them because you didn't need to modify trees?
07:20:23 <fasta> (figured out that the complexity analysis required mutable structures)
07:20:32 <ludflu> oh I see
07:20:41 <fasta> Zippers are very simple structures.
07:20:56 <fasta> It's just that it sounds complicated.
07:21:22 <fasta> IMHO, they are hyped structures.
07:22:39 <ludflu> ya, I'm a little new to the  pure functional approach - and I'm just trying to find the best way to modify a tree.
07:23:39 <fasta> ludflu, what is the problem you are solving?
07:24:05 <fasta> ludflu, only for really advanced algorithms you have to implement your own data structures.
07:24:34 <ludflu> modifying a particular node is straightforward. modifying the whole tree is harder. I'm looking at a game tree for possible moves in Go.
07:25:03 <ludflu> yes I'd rather not implement my own data structures I'm thinking I should use Data.Tree
07:25:08 <fasta> ludflu, there are packages which abstract over that already and are specially designed to handle these kinds of games.
07:25:29 <fasta> ludflu, a solver in Haskell will not be very fast unless you have a few thousand cores ;)
07:25:54 <ludflu> ya, I'm not trying to solve - monte carlo is where I want to go
07:26:09 <fasta> ludflu, Data.Tree builds actual cells in memory.
07:26:11 <ludflu> you think Data.Tree is a good place to start?
07:26:37 <fasta> ludflu, the various monads which work for games don't do that.
07:26:53 <fasta> ludflu, I recommend you to look into these special game strategy monad transformers.
07:26:53 <Jonno_FTW> a few thousand cores can be found in a couple of GPU's
07:27:17 <fasta> Jonno_FTW, those are not real cores.
07:27:26 <fasta> Jonno_FTW, but might work for this problem.
07:28:12 <ludflu> fasta, which game strategy monad transformers? I was thinking I would need to write my own. I'd be thrilled to use a standard implementation though
07:30:16 <fasta> ludflu,  http://hackage.haskell.org/packages/archive/parallel-tree-search/0.4.1/doc/html/Control-Parallel-TreeSearch.html might help
07:30:45 <fasta> ludflu, I am not an expert in that area, but I am fairly sure there is stuff to do that.
07:31:01 <fasta> ludflu, LogicT can also help.
07:31:04 <ludflu> that looks promising. thanks!
07:37:17 <Jonno_FTW> i still can't figure out how to memoize my function
07:40:40 <Jonno_FTW> ;__;
07:42:11 <bitstream0101> Typeclass/fundeps errors: anyone willing to help me out? I'm not even entirely sure if what I'm attempting to do can work. (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19634#a19634)
07:42:17 <osfameron> Jonno_FTW: there is stuff about it on the haskell wiki.  I didn't get my head round it tbh, but I think one approach is rewriting your function as a lazy list/map
07:43:19 <bitstream0101> I think I understand the message (could have different t's for the drefData function and the dref function in the typeclass) -- but I don't know how to resolve it, or if it can be resolved.
07:44:47 <Jonno_FTW> a n | n == 1         =[n]    | n `rem` 3 == 0 =n: (a $ n`div`3)    | n `rem` 3 == 1 =n: (a $ (4*n +2)`div`3)    | n `rem` 3 == 2 =n: (a $ (2*n -1)`div`3)
07:44:54 <Jonno_FTW> is my function
07:45:33 <Zao> I hear paste sites are awesome ;)
07:46:38 <cp2> desu: i love your vhost
07:47:57 <desu> lol
07:48:03 <cp2> :<
07:48:38 <desu> >:
07:48:47 * hackagebot upload: Vec 0.9.7 - Fixed-length lists and low-dimensional linear algebra. (ScottDillard)
07:49:33 <fasta> How is that hackagebot line implemented? Where does it get its data?
07:49:46 <ben> At a guess, hackage
07:50:03 <fasta> ben: does it poll all day long?
07:50:06 <sm> it's a rss2irc bot, watching hackage's new package feed
07:50:11 <sm> yes it does
07:50:26 <ben> I wonder when polling became socially acceptable again
07:50:30 <ben> must have been the whole web 2.0 thing
07:50:37 <sm> it was rss, I think
07:50:48 <sm> it took over
07:51:06 <sm> it scaled much better than push. That's what I read anyway
07:51:47 <osaunders> Can you put class constraints on type synonyms?
07:53:14 <sm> fasta: maybe some day the hackage server will grow an irc head. But for now, syndication and polling ...
07:53:33 <Saizan> osaunders: depends, what do you mean exactl?
07:54:22 <bitstream0101> Anyone care to peek at my typeclass/fundep woes? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19634#a19634
07:54:38 <osaunders> Saizan: type NumOpFn = (Num n) => n -> n -> n
07:55:33 <quicksilver> I don't think you can.
07:55:39 <quicksilver> I certainly would suggest you shouldn't.
07:55:47 <osaunders> quicksilver: Why?
07:55:49 <quicksilver> contexts aren't part of the type, except when they are
07:55:59 <quicksilver> contexts aren't properly first class.
07:56:35 <quicksilver> if haskell permitted that, then (Int -> NumOpFn) would be an illegal type
07:56:40 <quicksilver> which would be odd.
07:56:47 <Saizan> NumOpFn -> Foo /= forall Num n => (n -> n -> n) -> Foo
07:56:55 <quicksilver> (illegal in haskell 98, that is)
07:57:01 <quicksilver> only I got it backwards.
07:57:06 <quicksilver> Saizan's example is what I meant :)
07:57:38 <osaunders> Hm, OK.
07:57:41 <Saizan> s/forall/forall n./ -- to be accurate
07:58:25 <Saizan> NumOpFn -> Foo = (forall n. Num n => n -> n -> n) -> Foo -- if you know what it means and that's what you want, then ok
07:59:26 <osaunders> Saizan: I probably don't know what it means.
07:59:37 <osaunders> DW though, I'll settle with type NumOpFn n = n -> n -> n
08:00:32 <Laney> @djinn ((a -> b) -> b) -> a
08:00:32 <lambdabot> -- f cannot be realized.
08:08:29 <osaunders> > (+) == (+)
08:08:29 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a -> a))
08:08:30 <lambdabot>    arising from a use of `GH...
08:08:32 <osaunders> :-(
08:08:55 <osaunders> How can I convert operators to strings?
08:09:11 <osaunders> I want to write opAsStr (+) == "+"
08:10:45 <voker57> no metaprogramming for you
08:11:00 <Saizan> no function equality sir
08:11:15 <osaunders> :-(
08:11:49 <roconnor> > x + y
08:11:51 <lambdabot>   x + y
08:12:07 <osaunders> Lambdabot did it.
08:12:09 <Saizan> yeah, you can make your own Num instance
08:12:33 <mreh> why does cabal insist that it wants haskell98-1.0.1.0
08:12:45 <roconnor> > show $ x + y
08:12:46 <lambdabot>   "x + y"
08:12:51 <mreh> none of my dependencies need it excplicitly
08:12:54 <Saizan> mreh: try again with --dry-run -v
08:13:00 <osaunders> > show $ (+)
08:13:00 <Saizan> mreh: it'll tell you
08:13:01 <lambdabot>   "-3->\n  {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}\n-2->\n  {-3->-5;-2-...
08:13:11 <osaunders> > show (+)
08:13:12 <lambdabot>   "-3->\n  {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}\n-2->\n  {-3->-5;-2-...
08:13:27 <mreh> Saizan: this is a "cabal configure"
08:13:33 <osaunders> > (+)
08:13:34 <lambdabot>   -3->
08:13:34 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
08:13:34 <lambdabot>  -2->
08:13:34 <lambdabot>    {-3->-5;-2->...
08:13:39 <mreh> i'll just read the documentation
08:13:41 <roconnor> > show ((+) :: Expr -> Expr -> Expr)
08:13:42 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
08:13:42 <lambdabot>    arising from...
08:13:52 <Saizan> mreh: -v should give more information anyhow
08:14:38 <mreh> Saizan: it does :) thanks
08:15:20 <mreh> Actual cabal output:
08:15:21 <mreh> dependencies conflict: haskore-0.1 requires random ==1.0.0.2 however
08:15:21 <mreh> random-1.0.0.2 was excluded because haskore-0.1 requires random ==1.0.0.1
08:15:23 <zygoloid> > show ((+) :: Int -> Int -> Int)
08:15:23 <lambdabot>   "-3->\n  {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}\n-2->\n  {-3->-5;-2-...
08:15:26 <mreh> riiiiiight....
08:15:39 <leimy> :t (+1)
08:15:40 <lambdabot> forall a. (Num a) => a -> a
08:15:56 <leimy> > show (*)
08:15:57 <Saizan> mreh: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
08:15:57 <lambdabot>   "-3->\n  {-3->9;-2->6;-1->3;0->0;1->-3;2->-6;3->-9}\n-2->\n  {-3->6;-2->4;-...
08:16:08 <roconnor> hackage is about to implode
08:16:26 <roconnor> too successful
08:16:57 <roconnor> not enough cutting edge design.
08:17:27 <mreh> mind you fingers on those
08:18:52 <roconnor> ``The solution we've been discussing for the next major ghc release is to track package ABIs and possibly even to allow slotting packages in their ABI.
08:19:00 <roconnor> I don't know what this means, but it sounds great
08:19:33 <roconnor> cutting edge even
08:20:27 <fasta> roconnor, it only sounds like another can of worms to me. If their bug count is at zero they should add new features and not before that.
08:20:51 <fasta> roconnor, unfortunately, I am the only person in the world who seems to value a good implementation.
08:21:29 <roconnor> fasta: I think properly handling modules and interfaces is more important
08:21:53 <roconnor> I'd rather they halt development of everything else and fix this issue.
08:21:53 <fasta> roconnor, modules already work. You just have to recompile everything.
08:21:54 <Saizan> the package ABI thing is already implemented on the ghc side, and it's useful for shared libs
08:22:34 <fasta> roconnor, and I know that is annoying, but if people always postpone fixing bugs and keep introducing new features you end up with a mess.
08:22:44 <osaunders> Veins are like trees under your skin.
08:22:50 <Saizan> though there's still some problem with having two ABIs for the same version
08:23:07 <fasta> If you keep the invariant that the bug count in your system is zero, fixing new bugs as they arrive is not a lot of work.
08:24:22 <Saizan> fasta: fixing a bug might mean work around something that would disappear by introducing a feature
08:24:23 <Vitka> http://adblockplus.org/en/subscriptions
08:24:36 <roconnor> fasta: bug reports /= bugs
08:24:53 <roconnor> fasta: and without a spec you cannot even tell if a bug report corresponds to a bug or not.
08:25:16 <Vitka> whoops
08:25:18 <Vitka> Sorry.
08:25:37 <fasta> roconnor, no, but you are not suggesting that GHC has zero bugs currently.
08:26:34 <mreh> so how do I upgrade my core packages safely?
08:26:43 <mreh> upgrade the whole GHC installation?
08:26:47 <roconnor> fasta: I'm saying that without a spec, the conspect of GHC have bugs or not is not well-defined.
08:26:59 <roconnor> concept
08:27:02 <Saizan> mreh: i'd never use "cabal upgrade"
08:27:03 <fasta> roconnor, that is a theoretical argument.
08:27:19 <fasta> roconnor, yes, Haskell has no formal semantics.
08:27:20 <mreh> Saizan: cabal install seems to do the trick
08:27:31 <fasta> roconnor, but at the same time we can program in it.
08:27:46 <fasta> roconnor, so, clearly most people have an idea of what is Haskell.
08:27:49 <mreh> but that only install to the user db, which shadows the  global one and breaks everything
08:28:09 <roconnor> fasta: no, clearly people mostly have an idea what is Haskell
08:28:30 <roconnor> but bugs are often in areas where people might disagree about what Haskell is
08:28:32 <Saizan> mreh: try to avoid rebuilding the same version of the same package
08:28:42 <fasta> roconnor, example?
08:28:51 <Saizan> mreh: if you build a newer version that's fine.
08:29:01 <mreh> Saizan: I want to upgrade Random-1.0.0.1 to .2
08:29:05 <roconnor> or even more likely in areas where people might disagree about what *GHC* is.
08:29:26 <Saizan> mreh: how does your ghc-pkg list look like?
08:29:33 <roconnor> let me think
08:30:04 <fasta> roconnor, take for example the zero-allocation bug resulting in not switching to another thread.
08:30:17 <mreh> Saizan: lots broken packages now I've remove Random 1.0.0.2
08:30:33 <fasta> roconnor, everyone agrees that the current behaviour is wrong.
08:30:50 <Saizan> mreh: can you paste it?
08:31:24 <mreh> Saizan: I shall forthwith
08:32:06 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19671#a19671
08:32:48 <mreh> I see, haskell98-1.0.1.0 was compiled with random-1.0.0.2
08:32:59 <roconnor> fasta: sure, then that is in a part of the area of what people mostly understand.
08:33:18 <mreh> Saizan: ^^
08:33:28 <Saizan> mreh: start with ghc-pkg --user unregister haskell98-1.0.1.0
08:35:47 <mreh> Saizan: okay
08:35:50 <roconnor> fasta: can we search for bugs that were marked "not-a-bug"
08:36:31 <roconnor> fasta: those are likely to contain examples outside of what people mostly understand about GHC
08:37:49 <mreh> Saizan: it looks different now
08:38:13 <Saizan> mreh: then you can install random-1.0.0.2, and then i'd cabal unpack haskell98, edit the .cabal file to bump the version, cabal install it (so it'd be built against random-1.0.0.2) and only then cabal install haskore, this only if you've a specific reason to upgrade to random-1.0.0.2
08:38:47 <Saizan> mreh: i guess the global haskell98 is not broken anymore, right?
08:39:49 <fasta> roconnor, I was not really making a social argument.
08:40:15 <roconnor> fasta: well, you aren't making a formal argument either.
08:40:22 <roconnor> so I don't know what type are argument you are left with
08:40:41 <roconnor> actually
08:40:51 <roconnor> <fasta> roconnor, so, clearly most people have an idea of what is Haskell.
08:40:52 <absentia> http://macnugget.org/photos/cars/feature
08:40:54 <absentia> not a bug
08:40:57 <fasta> roconnor, I simply meant that the amount of bugs which are classified as bugs by GHC developers is not zero.
08:40:57 <mreh> I might get away with just using random-1.0.0.1
08:41:00 <roconnor> sounds social to me
08:41:20 <roconnor> fasta: ah okay
08:41:39 <fasta> roconnor, and the most people referred to GHC developers and the kind of people that report valid bugs.
08:42:05 <fasta> roconnor, I also have reported some bugs which were basically debatable, but they were outside of Haskell98.
08:42:49 <roconnor> fasta: how many H98 bugs are there that GHC developers acknowledge?  It is really non-zero?
08:43:10 <fasta> roconnor, probably less than 5.
08:44:01 <roconnor> fasta: if they fix those 5 bugs, then can they solve the problem of package dependencies in the presence of upgrades?
08:44:39 <fasta> roconnor, that would be my preferred way of how things worked, yes. They can work in parallel of course, but these issues should not be ignored.
08:45:04 <roconnor> I'd be interest to see a list of such bugs
08:45:12 <fasta> roconnor, of course, I am not paying for the development, so I have nothing to say :P
08:45:17 <roconnor> sure sure
08:45:33 <roconnor> none of this discussion will really affect how GHC devleopment takes place
08:46:03 <roconnor> I just prefer not to disagree with, what appear to be, rational people such as yourself.
08:47:05 <fasta> roconnor, from the top of my head there is the allocation bug, no mutual recursive modules and FFI support being incomplete (which has been documented now).
08:47:37 <roconnor> hmm, I'd like the no mutual recursive modules to be fixed too
08:47:42 <fasta> roconnor, oh, and some quadratic behaviour in some cases, which I have never investigated in depth.
08:47:54 <roconnor> I have some extreme ideas about how to fix that
08:48:22 <roconnor> which imply seprating the idea of user modules from compilation modules (units of compilation).
08:49:01 <roconnor> and having the compiler make its own fine grained dependency graph of functions.
08:49:23 <roconnor> not that I research compilers or in anyway am quaified to think about this topic :D
08:49:41 * djahandarie doesn't research anything
08:50:14 <Saizan> recompilation checking would get more accurate though probably more expensive, if it follows that graph
08:51:04 <roconnor> I vaugely recall being told that IBM had a C (C++ ?) compiler that did essentially this.
08:51:09 <Saizan> (i'd like something like that for Agda, to reduce typechecking time without having to manually split the code between multiple files)
08:51:40 <MissPiggy> like a agda core which has all the type inference already done?
08:51:41 <roconnor> Saizan: That'd be nice
08:51:51 * roconnor heads out for lunch
08:53:44 <Saizan> MissPiggy: no, something that can typecheck parts of a module without doing the rest if it's not used
08:53:59 <MissPiggy> oh
08:54:28 <Saizan> and memoize those parts when you go retypechecking the rest after you've changed it
08:55:43 <Saizan> so, in the context of a single module while you're in a edit-typecheck cycle where you only edit the last definition, it wouldn't retypecheck all the above ones too
08:55:46 <Saizan> like it does now
08:55:49 <MissPiggy> hmm yea I wonder why it doesn't do that already, it's not even like one file is an SCC
08:56:00 <Saizan> yeah
09:00:24 <moshisushi> MissPiggy: hello there
09:00:36 <moshisushi> i got the parser to work nicely at the end :)
09:00:51 <MissPiggy> good!
09:00:54 <MissPiggy> how did you do it?
09:01:16 <osxx> Please rate video http://www.youtube.com/watch?v=LOUGWeN2amY
09:01:29 <moshisushi> the process was kind of: remove all crap, add a binary "" operator in a list between the list of + * ? ops and the list of the bar op
09:02:22 <moshisushi> MissPiggy: i can't think of a more succinct definition of that bloody grammar :)
09:03:57 <moshisushi> MissPiggy: so basically i have the rule that a term is an expr, an expr is an atom or (term), and an atom is a char in the alphabet or a .
09:04:28 <MissPiggy> that sounds fine
09:08:48 <moshisushi> MissPiggy: Yeah, no obvious bugs, so it obviously has no bugs, right?
09:09:49 <MissPiggy> hehehe
09:12:08 <Arnar> grr.. how can I get emacs haskell mode not to cd to ~/.cabal when I C-c C-l ?
09:12:25 <Arnar> I've created both a dummy X.cabal file and an empty .cabal dir in my working directory
09:13:09 <Arnar> I mean it tells ghci to cd
09:13:29 <Arnar> something about going up the directory hierarchy looking for a .cabal file.. so everything is loaded from the pkg root
09:13:36 <Arnar> but now I'm not in a package.. just a dir with two .hs files
09:14:06 <quicksilver> Arnar: I believe the newer haskell mode fixes this.
09:14:32 <quicksilver> alternative, customize the variable inferior-haskell-find-project-root
09:14:37 <quicksilver> which is what I did.
09:15:47 <Arnar> quicksilver: ah.. thanks
09:16:01 <Arnar> I'm a vimer.. so I'm not the slickest when it comes to emacs
09:16:12 <Arnar> but editing haskell in it is just so nice :)
09:16:39 <Arnar> I'm curious to try the newer mode though.. are there any known downsides to it?
09:17:16 <quicksilver> don't recall any.
09:17:31 <quicksilver> you can nudge Baughn he's maintainig it now, that's an advantage
09:17:58 <Arnar> ah.. good to know
09:18:18 <tcleval> can I use PVM together with ghc? is there a library for PVM?
09:18:42 <Baughn> Arnar: Well, the various insert functions don't work..
09:18:53 <Baughn> Arnar: But it's bundled with the older modes too, so it's easy enough to switch
09:22:28 <Arnar> Baughn: insert functions?   sorry about the noobism here
09:23:00 <Arnar> in any case sounds like something I don't use (I use it mainly for the indentation and interaction with ghci)
09:23:31 <Baughn> Arnar: The tab-cycle inserts some appropriate code at some points. Like, inserting "foo " under "foo 2" when you tab-complete.. umh
09:23:38 <Baughn> Arnar: Well, sounds like you won't miss it
09:24:01 <Arnar> ah.. ok
09:24:02 <Arnar> well
09:24:06 <Arnar> I might actually
09:24:23 <Arnar> anyways.. I'll try it and bother you if there is an actual problem :)
09:24:29 <Arnar> as opposed to a hypothetical one
09:28:24 <Arnar> what about this scion thing?
09:28:34 <Arnar> is it generally useful?
09:28:50 * Baughn would answer, but he is quite biased
09:28:53 <gwern> scions are very useful for carrying on the family name
09:28:58 <gwern> so long as they be male
09:29:24 <Arnar> harhar
09:29:26 <Arnar> :)
09:29:40 <Arnar> Baughn: please answer.. your disclaimer is noted :)
09:29:57 <gwern> females with their dowries are just a waste. drown'em like kittens!
09:30:22 <gwern> </feudalism>
09:30:43 <Baughn> Arnar: It attempts to be a haskell IDE backend, that can be used by multiple IDEs.
09:31:04 <Baughn> Arnar: Splendid idea, really. I intend to take full advantage. However, there are no mature IDEs.
09:31:28 <Arnar> I mean specifically in emacs
09:31:33 <Arnar> just reading the readme actually sounsd good
09:31:37 <Arnar> e.g. the comletion
09:31:43 <Arnar> completion*
09:31:54 <Baughn> I haven't really looked closely at any others than haskell-mode yet, sorry. *shrug*
09:32:13 <Arnar> no worries
09:32:23 <Arnar> I would like to see one feature from the agda-mode ..
09:32:23 <Baughn> Last time I tried to use the emacs scion mode, I failed to make it work
09:32:29 <Arnar> which is parameter expansion
09:32:38 <Arnar> I write fun x y = ...
09:32:41 <Arnar> where x is a data type
09:32:51 <gwern> hm. waht's the point of default implementations in a typeclass, like /= in Eq being defined in terms of ==? if /= can be completely definde with ==, why not just split it out as a separate function with an Eq constraint in its type sig?
09:33:00 <Arnar> put cursor on it, press a key combo and it makes one defn of fun for each constructor
09:34:01 <Baughn> Arnar: WOuld be nifty, yeah
09:34:32 <Baughn> Arnar: But if it acts recursively, it could quickly get out of hand.. ah well, you might just not invoke it in that case.
09:34:44 <Arnar> it only expands one level
09:34:58 <Arnar> if you want to recurse you have to ask for it
09:37:50 <doserj> gwern: sometimes == is easy to define for a type, sometimes /=. having both as class methods gives you the choice
09:38:04 <gwern> doserj: hm. example?
09:40:58 <lispy> gwern: Having both means that either one is acceptable to define.  With the way you suggested you are biased towards defining ==
09:41:41 <lispy> gwern: I don't really know a good example of a type where /= is significantly easier to define than ==
09:41:47 <doserj> gwern: also, I guess sometimes /= can be more efficiently implemented for certain cases than via (not .) . (==)
09:43:13 <doserj> gwern: maybe for Ord the difference is more apparent than for Eq
09:48:28 * hackagebot upload: haskore 0.1.0.2 - The Haskore Computer Music System (HenningThielemann)
09:57:28 <paolino> anyone on osx can tell if System.Directory.getCurrentDirectory is working ?
10:00:26 <Arnar> > "Testing some notification Arnar"
10:00:27 <lambdabot>   "Testing some notification Arnar"
10:18:45 <roconnor> what does it mean in category theory for two functors to be isomorphic?
10:20:38 <MissPiggy> I don't know but I got myself a category theory book today
10:20:51 <MissPiggy> it sounds cool it's got sketches in it
10:21:12 <shambler> which one?
10:21:14 <Saizan> i'd guess that there are two natural transformations that are inverses
10:21:16 <shambler> book I mean
10:22:00 <MissPiggy> shambler http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
10:22:16 <shambler> thank you
10:27:50 <doserj> functors are objects in the functor category, with morphisms the natural transformations, so what Saizan said is a natural definition
10:28:29 <roconnor> Saizan: so all isomorphic functions are naturally isomorphic by definition?
10:28:33 <roconnor> *functors
10:30:51 <Saizan> Two functors F and G are called naturally isomorphic or simply isomorphic if there exists a natural isomorphism from F to G. <- according to Wikipedia
10:31:02 <roconnor> :)
10:31:12 <roconnor> thanks
10:31:15 <doserj> typically, one uses a notion of natural equivalence instead, though., which is a it weaker
10:31:29 <roconnor> oh?
10:31:43 <doserj> natural equivalence is what Saizan quoted
10:32:25 <roconnor> huh?
10:32:31 <Saizan> uhm, is there a diffrence between having two NT that are inverses and having an NT that produces isomorphims?
10:32:51 <Saizan> which is the definition WP uses for "natural isomorphism"
10:32:57 <roconnor> ugh
10:33:06 <roconnor> I think they are the same
10:33:24 <doserj> I thought they were different
10:33:25 <sioraiocht> Saizan: shouldn't be
10:34:11 <roconnor> isn't composing two NT the same thing as composing each arrow generated by the NT?
10:34:27 <sioraiocht> roconnor: should be
10:34:56 <roconnor> thus composing two NT is the identity if and only if computing each arrow generated by the NTs results in the idenity
10:35:16 <roconnor> twhus two NT's are isomorphic if and only if all the genarated ...
10:35:18 <roconnor> ah
10:35:53 <roconnor> I guess you could have two NT's that produce arrows which are half of "an" isomorphism
10:36:01 <roconnor> but not half of each other's isomorphism
10:36:21 <roconnor> what is WP's definition again?
10:36:49 <roconnor> cause it sounds like a dumb/wrong definition
10:37:10 <IceDane> Would I have to use monads if I want to catch an exception(from prelude.read) ?
10:37:19 <roconnor> actually
10:37:21 <roconnor> maybe it is fin
10:37:30 <roconnor> if you have an NT whose arrows are all isomorphisms
10:38:13 <roconnor> then there is a NT goint back generated by taking all the other half of each isomorphism
10:38:51 <roconnor> and the compositoin of those two NT's will be the identity
10:40:00 <doserj> I may have confused it with isomorphism vs natural equivalence for categories...
10:40:38 <IceDane> Alright - can anyone direct me to anything that explains the usage of exceptions? If there are many types of them for different functions - I need info on the ones that handle exceptions thrown by prelude.read
10:40:54 <zygoloid> IceDane: don't. use reads instead.
10:41:02 <lispy> :t reads
10:41:04 <lambdabot> forall a. (Read a) => String -> [(a, String)]
10:41:05 <roconnor> zygoloid++
10:41:23 <IceDane> How would it make stuff easier?
10:41:32 <roconnor> reads doesn't throw exceptions
10:41:33 <lispy> > reads "hi" :: [(Int, String)]
10:41:34 <lambdabot>   []
10:41:38 <IceDane> Ah, sweet.
10:41:47 <roconnor> @src read
10:41:47 <lambdabot> read s = either error id (readEither s)
10:41:56 <roconnor> whoa
10:41:59 <roconnor> there is a readEither?
10:42:04 <roconnor> @type readEither
10:42:05 <lispy> :t readEither
10:42:05 <lambdabot> Not in scope: `readEither'
10:42:05 <lambdabot> Not in scope: `readEither'
10:42:08 <roconnor> :^)
10:42:09 <lispy> ?hoogle readEither
10:42:10 <lambdabot> No results found
10:42:14 <lispy> weird
10:42:20 <roconnor> but not be exported?
10:42:20 <lispy> Is that src entry bogus?
10:42:52 <zygoloid> lispy: i think that's how it's specced i the report
10:44:13 <roconnor> readEither s = case [ x | (x,"") <- readPrec_to_S read' minPrec s ] of [x] -> Right x [] -> Left "Prelude.read: no parse" _ -> Left "Prelude.read: ambiguous parse" where read' = do x <- readPrec lift P.skipSpaces return x
10:44:32 <roconnor> wow
10:44:38 <roconnor> crazy
10:45:16 <roconnor> @type readPrec_to_S
10:45:17 <lambdabot> Not in scope: `readPrec_to_S'
10:45:28 <MissPiggy> :t readP_to_S
10:45:29 <lambdabot> Not in scope: `readP_to_S'
10:49:10 <tibbe> I need a function that applied a list of function [a -> a] to some value 'a'
10:49:18 <tibbe> feels like a fold with $ or something?
10:49:25 <kmc_> map ($ x)
10:49:26 <MissPiggy> ?
10:49:28 <MissPiggy> what answer
10:49:33 <kmc_> or do you want to compose them?
10:49:33 <tibbe> :t map ($x)
10:49:34 <lambdabot> forall b. [Expr -> b] -> [b]
10:49:35 <kmc_> :t foldr (.) id
10:49:36 <lambdabot> forall b. [b -> b] -> b -> b
10:49:40 <tibbe> kmc_: compose
10:49:41 <MissPiggy> what is the full type f the function???
10:49:47 <tibbe> kmc_: and I want strict evaluation
10:49:53 <kmc_> of what?
10:50:10 <tibbe> IterateFunc :: [a -> a] -> a -> a
10:50:22 <kmc_> yes, that's foldr (.) id
10:50:29 <kmc_> what sort of strictness do you want to add?
10:50:44 <tibbe> kmc_: the value a should be whnf between each function call
10:51:28 <tibbe> :t Data.List.foldl' (.) id
10:51:30 <lambdabot> forall a. [a -> a] -> a -> a
10:51:30 <kmc_> :t let f .! g = \x -> x `seq` f (g x) in foldr (.!) id
10:51:31 <lambdabot> forall a. [a -> a] -> a -> a
10:51:39 <roconnor> > sequence [succ, pred] 0
10:51:40 <lambdabot>   [1,-1]
10:51:48 <tibbe> kmc_: how about a strict left fold?
10:51:48 <roconnor> tibbe: sequence solves all problems
10:51:58 <tibbe> roconnor: efficiently? :)
10:52:11 <kmc_> :t foldr (.) id . map (\f x -> x `seq` f x)
10:52:12 <lambdabot> forall b. [b -> b] -> b -> b
10:52:15 <tibbe> roconnor: I need as good performance as if I handrolled the function
10:52:16 <roconnor> tibbe: oh wait, did you want to compose the functions
10:52:21 <kmc_> @pl (\f x -> x `seq` f x)
10:52:21 <lambdabot> ap seq
10:52:35 <roconnor> ah
10:52:39 <kmc_> :t (seq <*>)
10:52:40 <roconnor> sorry, I misunderstood
10:52:40 <lambdabot> forall a a1. (a -> a1) -> a -> a1
10:52:45 <tibbe> roconnor: yes, but I'm going to apply them right away so I don't want the intermediate closure
10:52:52 <kmc_> :t foldr (.) id . map (seq <*>)
10:52:53 <lambdabot> forall a. [a -> a] -> a -> a
10:52:57 <roconnor> @type flip (foldr ($))
10:52:58 <lambdabot> forall b. [b -> b] -> b -> b
10:53:01 <roconnor> I ususually use this
10:53:05 <doserj> @type let (f .! g) x = let gx = g x in gx `seq` f gx in (.!)
10:53:06 <lambdabot> forall a b t. (a -> b) -> (t -> a) -> t -> b
10:53:23 <roconnor> I don't know how efficent it is, but it is probably at least as efficent as your fold (.) stuff
10:53:48 <tibbe> @type foldr ($)
10:53:50 <lambdabot> forall b. b -> [b -> b] -> b
10:53:54 <Saizan> ?type foldl
10:53:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:53:58 <tibbe> @type foldl ($)
10:53:59 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> b
10:53:59 <lambdabot>     Probable cause: `$' is applied to too many arguments
10:53:59 <lambdabot>     In the first argument of `foldl', namely `($)'
10:54:06 <Saizan> ?type foldl' (flip ($))
10:54:07 <lambdabot> forall b. b -> [b -> b] -> b
10:54:14 <Saizan> ?type flip (foldl' (flip ($)))
10:54:15 <lambdabot> forall b. [b -> b] -> b -> b
10:54:25 <Saizan> looks like that's what you want.
10:54:28 <tibbe> Saizan: that looks like what I want
10:54:39 <roconnor> > foldr ($) 2 [(*2) (+2)]
10:54:40 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
10:54:41 <lambdabot>    arising from the literal `2' at <...
10:54:47 <roconnor> > foldr ($) 2 [(*2), (+2)]
10:54:48 <lambdabot>   8
10:54:57 <roconnor> > foldl (flip ($)) 2 [(*2), (+2)]
10:54:58 <lambdabot>   6
10:55:13 <tibbe> roconnor: that's it :)
10:55:44 <tibbe> thanks all
10:55:52 <roconnor> which way do you want to compose :D
10:56:09 <tibbe> roconnor: the way you did, apply first function in the list first (or innermost)
10:56:10 <roconnor> the foldl composes the backwards, for some definition of backwards
10:56:18 <kmc_> @djinn (a -> b) -> [a] -> [b]
10:56:18 <lambdabot> Error: Undefined type []
10:56:34 <kmc_> @djinn-let data List a = Nil | Cons a (List a)
10:56:34 <lambdabot> Maybe you meant: djinn-del djinn-ver
10:56:58 <roconnor> tibbe: ah, welll foldl' will probably be quite efficent then.
10:57:09 <MissPiggy> if you add recursive data to djinn then it is undecidible
10:57:17 <tibbe> roconnor: yup
10:57:58 <MissPiggy> thinking about some horrifically complicated encoding of posts problem in a nested recursion
10:58:11 <Twey> quicksilver: Figured it out, or at least worked around it — needed to use --preference="base >= 4" and also reïnstall GHC and all the related packages.
10:58:18 <MissPiggy> withot nested recursion, hm? it is still decidible?
10:58:38 <roconnor> tibbe: won't work on infinite lists though :D
10:58:52 <tibbe> roconnor: right, in my case that's not needed
10:59:00 <roconnor> > foldr ($) undefined (repeat (const 0))
10:59:00 <lambdabot>   0
10:59:02 <Twey> On a related note, Text.XML.HXT.Arrow.parseHtmlDocument :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> IOStateArrow s XMLTree XMLTree, eww.
10:59:36 <c_wraith> Um.  Clearly, those bools should be packaged up into an option structure
10:59:40 <Twey> Yeah.
11:00:04 <roconnor> Clearly, those bools should be packeded up into a bitfield of some Word type. :P
11:00:06 <zygoloid> wow, that's ... an interesting and courageous approach
11:00:26 <Twey> zygoloid: And that's… an interestingly euphemistic phrasing
11:00:43 <roconnor> Text.XML.HXT.Arrow.parseHtmlDocument :: Word6 -> IOStateArrow s XMLTree XMLTree
11:01:07 <Twey> Text.XML.HXT.Arrow.parseHtmlDocument :: Set Flag -> IOStateArrow s XMLTree XMLTree
11:01:40 <zygoloid> data ParseHtmlDocumentFlags = NoneOfThem | JustTheFirstOne | JustTheSecondOne | TheFirstTwo | JustTheThirdOne | TheFirstOneAndTheThirdOne | TheSecondOneAndTheThirdOne | TheFirstThree | ...
11:01:51 <MissPiggy> haha
11:02:51 <aavogt> well how else could you prohibit specific flag combinations statically?
11:03:06 <gwern> aavogt: a tree of adts?
11:03:15 <zygoloid> the first six flags are actually just the HTML version in binary (we're only up to HTML 5 so far but you've got to plan ahead)
11:03:29 <gwern> data Top = Options A B | Option C D or something
11:04:02 <aavogt> hmm
11:04:05 <zygoloid> | Optio E F | Opti G H | ... ? :)
11:04:31 <kmc_> Foo::Foo(Bar& x, Baz* y, bool b1 = true, bool b2 = true, bool b3 = true, bool b4 = true, bool b5 = false, bool b6 = true, bool b7 = false, bool b8 = false, bool b9 = false, bool b10 = false, bool b11 = true, bool b12 = false, bool b13 = false, bool b14 = false, bool b15 = false, bool b16 = false);
11:04:47 <kmc_> that's the prototype of the ctor of a C++ class i've had to work with
11:05:01 <kmc_> names have been alpha-renamed to protect the guilty
11:05:36 <zygoloid> kmc_: i hope at least the bools all have the same meaning in some sense?
11:05:50 <gwern> I never understand. why do we protect the guilty? does that mean we ought to punish the innocent?
11:06:01 <zygoloid> hold on, they can't, they all have different defaults. oh my god.
11:06:15 <MissPiggy> I want to do some haskell programming
11:06:15 <MissPiggy> or maybe I should read my book
11:06:29 <kmc_> they enable and disable various behaviors of the class
11:06:34 <kmc_> also, some of the combinations are illegal
11:06:41 <gwern> MissPiggy: here's a good starter. rewrite all the basic unix utilities in haskell
11:06:49 <zygoloid> we have something like: Foo(Maybe<string> a = Nothing, Maybe<string> b = Nothing, Maybe<string> c = Nothing, ... <lots more> ...) in our code (C++ again)
11:06:52 <mm_freak> i'm gonna throw up
11:07:12 <gwern> MissPiggy: it'll take you basic IO, and about separating concerns, and each utilitiy is small enough to be a learning experience but large enough that it's not frustrating
11:07:20 <kmc_> is Maybe boost::optional, or a homegrown equivalent?
11:07:27 <kmc_> @quote boost
11:07:28 <lambdabot> kmc_ says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
11:07:31 <zygoloid> but that's just used as a shorthand to build a container of strings and do stuff with it, so it's not /too/ bad
11:07:49 <Kruppe> does filter use any structural sharing?
11:08:03 <gwern> @src filter
11:08:03 <lambdabot> filter _ []     = []
11:08:04 <lambdabot> filter p (x:xs)
11:08:06 <lambdabot>     | p x       = x : filter p xs
11:08:08 <lambdabot>     | otherwise = filter p xs
11:08:22 <kmc_> Kruppe: the cons cells of the list will be rebuilt.  the elements are all shared
11:08:28 <zygoloid> Kruppe: no. even if the whole list matches the filter you get a new spine.
11:08:58 <Kruppe> zygoloid: ah
11:09:05 <kmc_> it only matters in that case though
11:09:11 <kmc_> if all but the last element matched, you would still need a completely new spine
11:09:31 <kmc_> but you can make fancier sequential data structures where this is not the case
11:09:37 <Kruppe> kmc_: if its immutable couldnt you share the tail in that case?
11:09:51 <kmc_> hmm, you're right
11:10:01 <kmc_> you can share the portion of the list after the last non-matching element
11:10:34 <Kruppe> kmc_: if it can figure our where that point is
11:10:38 <zygoloid> but you can't share the tail of the list without introducing a space leak
11:10:38 <Kruppe> out*
11:10:48 <Kruppe> zygoloid: oh?
11:11:06 <lpsmith> moonpatio,  it's down!  :-(
11:11:21 <zygoloid> consider "filter (!=0) [1..]"
11:11:22 <lpsmith> Isn't moonpatio mmorrow's server?
11:11:59 <lpsmith> preflex,  seen mmorrow
11:12:00 <preflex>  mmorrow was last seen on #ghc 24 days, 16 hours, 14 minutes and 14 seconds ago, saying: * mmorrow is rtfm'ing
11:12:08 <zygoloid> the space leak comes from holding onto the original list in case you can reuse its tail
11:12:22 <lpsmith> :-/
11:12:32 <zygoloid> but actually it's worse than that since if you try to reuse the list, "head (filter (!=0) [1..])" can't terminate :-o
11:13:09 <Kruppe> zygoloid: why not
11:13:57 <zygoloid> cleaner explanation: filter (!=0) (1:undefined) must be (1:undefined). so filter cannot look at the tail of the list in advance
11:14:19 <zygoloid> (it must produce the first cons before looking at the tail of the list, so the first cons cannot be shared)
11:14:36 <Muad_Dibber> Is there an introduction tutorial or something to QC 2?
11:14:37 <Kruppe> zygoloid: ahhhhhhh I see
11:17:59 <aavogt> Muad_Dibber: it isn't that much different from QC 1, which has a bunch of publications
11:18:15 <aavogt> though maybe you can find something on QC 2
11:20:15 <dbro> newbie question: what's a good way to record from a microphone in Haskell? I want to work with the raw samples. Is there a library for setting up the sampling rate, #channels, etc?
11:20:41 <aavogt> @type strength
11:20:41 <Twey> Hm… is there some term like ‘idempotent’ for a function that is its own inverse, like ROT13
11:20:42 <lambdabot> Not in scope: `strength'
11:20:56 <aavogt> nilpotent
11:21:25 <roconnor> ROT13 isn't idempotent
11:21:30 <roconnor> oh
11:21:31 <roconnor> sorry
11:21:34 <roconnor> hm
11:21:42 <ben> unitary?
11:21:52 <mauke> self-inverse
11:21:53 <ben> Wait, no. Whoops.
11:22:00 * roconnor tries to remember
11:22:39 <MissPiggy> involutive
11:22:44 <doserj> http://en.wikipedia.org/wiki/Involution_(mathematics)
11:22:49 <roconnor> yes
11:22:59 <ben> That sounds like the function is going to throw up for some reason
11:23:47 <aavogt> @hoogle m (a -> b) -> a -> m b
11:23:47 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:23:47 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
11:23:47 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:23:52 <aavogt> @type flip
11:23:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:24:15 <roconnor> caleskell!!!
11:24:24 <mm_freak> i always wondered
11:24:24 <aavogt> I actually need that function :)
11:24:24 <MissPiggy> lol
11:24:32 <mm_freak> if there's a cousin, is there also a usin?
11:24:33 <MissPiggy> we're not meant to say that word
11:24:42 <roconnor> @src flip
11:24:42 <lambdabot> flip f x y = f y x
11:24:45 <roconnor> :/
11:24:50 <doserj> it should have a standard name, but that name shouldn't be flip
11:24:55 <mm_freak> btw, i'm starting to come up with caleskell, too =)
11:25:13 <burp> @type flip f a = fmap ($ a) f
11:25:14 <lambdabot> parse error on input `='
11:25:21 <burp> um, sure
11:25:31 <mm_freak> > let mySubsequences = filterM (const [True, False]) in mySubsequences "abc"
11:25:32 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
11:25:41 <Twey> MissPiggy: Ah, thanks
11:26:01 <dbro> where's QuickCheck moved to ?? darcs.haskell.org/QuickCheck doesn't work now
11:28:12 <coppro> What windowing libraries exist for Haskell?
11:29:57 <erikc> windowing?
11:30:08 <kmc_> GUI libraries?
11:30:14 <FliPPeh> ncurses?
11:30:19 <FliPPeh> @hoogle ncurses
11:30:19 <lambdabot> No results found
11:30:22 <FliPPeh> :(
11:30:31 <FliPPeh> I want a curses binding for haskell
11:30:32 <coppro> yeah, GUI
11:30:40 <doserj> dbro: http://www.haskell.org/pipermail/haskell/2010-January/021861.html
11:30:57 <kmc_> coppro: Gtk2Hs is popular
11:31:30 <kmc_> there's a wxWidgets binding too
11:31:58 <monochrom> @type callCC
11:31:59 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:32:01 <kmc_> there are direct bindings to X and Win32
11:32:15 <kmc_> there are some high-level declarative GUI APIs too
11:32:21 <kmc_> best would be to check out the package list on hackage
11:32:41 <doserj> there are also qt bindings
11:33:17 <dbro> doserj: thanks
11:36:32 * MissPiggy doesn't understand if you can acutally read haskell-cafe through nabble
11:38:19 <doserj> MissPiggy: I don't. but googling is faster than searching locally :)
11:39:38 <tARrAScH> Hello! I'm trying to create a Gen (MyMonad), and I would like the monad to consist of several several binds, as if it's a several lines of do syntax. I already have/know which functions to use as >>='s 2:nd parameter, though I can't grasp the whole of this generator, especially how I'm going to keep track of all the variables (By variables I mean the left arguement of >>=). Is there any good...
11:39:40 <tARrAScH> ...examples of this I can view or any general hints?
11:41:05 <mm_freak> tARrAScH: you mean you have a computation, which contains multiple binds
11:41:24 <mm_freak> > do x <- Just 3; y <- Just 4; return (x+y)
11:41:25 <lambdabot>   Just 7
11:41:30 <mm_freak> or equivalently:
11:41:40 <mm_freak> > Just 3 >>= \x -> Just 4 >>= \y -> return (x+y)
11:41:41 <lambdabot>   Just 7
11:41:57 <tARrAScH> mm_freak: I'm trying to create a Generator, the quickCheck arbitrary function
11:42:39 <aavogt> :k Gen
11:42:40 <lambdabot> * -> *
11:42:54 <aavogt> :k Maybe
11:42:55 <lambdabot> * -> *
11:43:04 <aavogt> :k Gen Maybe
11:43:05 <lambdabot>     `Maybe' is not applied to enough type arguments
11:43:05 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
11:43:24 <aavogt> you're asking to fit (* -> *) into (*), which doesn't work
11:43:35 <tARrAScH> however I won't be coding the Monad-variable, I want to generate it and I just can't see in front of me how the amount of lamdas could be counted.
11:43:54 <aavogt> @type sequence
11:43:54 <lpsmith> hpaste is down too;  same 500 error: cannot access database!
11:43:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:44:15 <tARrAScH> aavogt: I think you didn't give me a prper explenation :-/
11:44:24 <aavogt> @type foldr
11:44:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:44:47 <aavogt> @type foldr (=<<) . return
11:44:48 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
11:45:17 <tARrAScH> aavogt: I can guarantee you that you can create Gen [Int], cause I've done that at least :)
11:45:32 <kmc_> [Int] has kind *
11:45:40 <kmc_> it's a type, you can have values of type [Int]
11:45:41 <Arnar> can anyone help me to tell ghc what I mean when I write: instance (MonadTrans t, MonadIO m) => MonadIO (MyCustomMonadT (t m))  ?
11:45:46 <doserj> tARrAScH: you want to declare an "instance Arbitrary SomeDataType"?
11:45:51 <kmc_> similarly you can have values of type (Maybe Int)
11:45:52 <aavogt> tARrAScH: well how is each of these randomly generated computations supposed to be connected?
11:45:57 <kmc_> but no values of type Maybe
11:46:10 <tARrAScH> Ok, I'm just gonna ask it.  What is * ? Any type?
11:46:15 <kmc_> no
11:46:18 <kmc_> it's a "kind"
11:46:22 <Arnar> I can write it for a specific t, like StateT  (the impl is just lift . lift )
11:46:24 <aavogt> types for types
11:46:25 <kmc_> kinds classify types in the same way that types classify terms
11:46:25 <Heffalump> it's the kind representing any type
11:46:40 <Sgeo> IO a is of kind *,
11:46:47 <kmc_> of kind * -> *
11:46:48 <Sgeo> IO is of kind * -> *
11:46:49 <kmc_> sorry
11:46:50 <kmc_> yes
11:46:51 <tARrAScH> Yea ok I'm restricting myself to special variable type: Ints
11:46:53 <kmc_> what you said
11:47:04 <Sgeo> Since IO takes a type (*) and turns it into a type (*)
11:47:15 <Sgeo> :k IO
11:47:16 <lambdabot> * -> *
11:47:18 <Sgeo> :k IO a
11:47:19 <lambdabot> Not in scope: type variable `a'
11:47:26 <Sgeo> :k IO ()
11:47:27 <kmc_> :k Int
11:47:27 <lambdabot> *
11:47:28 <lambdabot> *
11:47:29 <kmc_> :k Maybe
11:47:30 <lambdabot> * -> *
11:47:31 <kmc_> :k Maybe Int
11:47:32 <lambdabot> *
11:47:37 <tARrAScH> You guys are right, It wouldn't be possible for  Gen M but I want for Gen (M Int))
11:47:44 <kmc_> okay
11:48:03 <kmc_> Arnar: what sort of error do you get?
11:48:14 <Arnar> kmc: kind error .. incidentally :)
11:48:15 <kmc_> perhaps upload your code and error msg to codepad.org
11:48:17 <kmc_> hehe
11:48:23 <Arnar> yes.. hang on
11:49:33 <aavogt> tARrAScH: well what do you catch by generating arbitrary sequences of >> and >>= with appropriate values or functions in between?
11:50:10 <tARrAScH> aavogt: You mean as what kind of bugs I can catch with such Generator?
11:50:15 <mm_freak> :k ReaderT
11:50:16 <lambdabot> * -> (* -> *) -> * -> *
11:51:47 <aavogt> tARrAScH: yeah, as opposed to generating Ints, and then passing them to computations that use your monad for some effects, and then verifying that those effects do what you suppose they should
11:52:13 <Arnar> kmc_: http://codepad.org/cxLRt0AT
11:53:02 <kmc_> Arnar: shouldn't MT.MonadTrans have an argument?
11:53:08 <kmc_> did you mean (MT.MonadTrans t)
11:53:09 <aavogt> what I mean is that there isn't much benefit in randomly generating  sequences of  >>=  and  >>, because there's not too much you can say about them if you don't know how they were put together
11:53:28 <Arnar> yes..
11:53:34 <Arnar> that doesn't help though :)
11:53:40 <Arnar> just got lost in the pasting somehow
11:53:53 <tARrAScH> aavogt: Well, I can draw conclusions if I know what argumetns I pass to >>=/>>
11:54:27 <kmc_> :k ErrorT
11:54:28 <lambdabot> * -> (* -> *) -> * -> *
11:54:43 <temoto> > let alleq xs = all (\x -> x == (head xs)) (tail xs) in alleq [1, 1, 1]
11:54:44 <lambdabot>   True
11:54:49 <temoto> How to write it better?
11:54:57 <kmc_> eek don't use head
11:55:09 <MissPiggy> call it allEqual instead
11:55:11 <Arnar> kmc_: not thought that I'm using my own ErrorT
11:55:13 <kmc_> > let alleq (x:xs) = all (== x) xs in alleq [1,1,1]
11:55:14 <lambdabot>   True
11:55:14 <Arnar> but it has the same kind
11:55:26 <kmc_> temoto: ^^^^
11:55:44 <kmc_> :t GHC.Exts.the
11:55:45 <lambdabot> forall a. (Eq a) => [a] -> a
11:55:52 <tARrAScH> aavogt: Though question really, but there are only two operations on my monad except for >>=/return and I don't know I if I really tested my Monad completely unless I use all operations combined
11:56:11 <Veinor> what does the do?
11:56:30 <temoto> kmc_, parens! That's why i couldn't write it with x:xs pattern. Thank you.
11:56:36 <kmc_> temoto: :)
11:56:49 <kmc_> you always need parens around a constructor pattern
11:56:53 <aavogt> @type fmap (foldr (\a (b,t) -> (a,a==b && t)) True) . mapM (>> get)
11:56:54 <kmc_> in this context at least
11:56:54 <lambdabot>     Couldn't match expected type `(a, Bool)'
11:56:54 <lambdabot>            against inferred type `Bool'
11:56:54 <lambdabot>     In the second argument of `foldr', namely `True'
11:57:26 <aavogt> @type fmap (all (uncurry (==)) . (zip `ap` tail)) . mapM (>> get)
11:57:27 <lambdabot> forall a (f :: * -> *) a1. (Eq a, Functor f, MonadState a f) => [f a1] -> f Bool
11:57:36 <aavogt> @type fmap (all (uncurry (==)) . (zip `ap` tail)) . mapM (>> ask)
11:57:36 <sinelaw> off-topic: hi!
11:57:37 <lambdabot> forall a (f :: * -> *) a1. (Eq a, Functor f, MonadReader a f) => [f a1] -> f Bool
11:57:47 <Veinor> aavogt: now you're just being silly
11:57:56 <aavogt> @type liftM (all (uncurry (==)) . (zip `ap` tail)) . mapM (>> ask)
11:57:57 <lambdabot> forall a (m :: * -> *) a1. (Eq a, MonadReader a m) => [m a1] -> m Bool
11:58:21 <kmc_> Arnar: this one passes my typechecker (using MTL classes only): instance (MT.MonadTrans t, MT.MonadIO m, Monad (t m), Error e) => MT.MonadIO (ErrorT e (t m))
11:58:28 <aavogt> Veinor: well this is a kind of test I could expect tARrAScH might be trying to do
11:58:50 <Arnar> kmc_: hang on let me check (i used my own ErrorT to get rid of the Error restriction)
11:59:48 <Arnar> kmc_: yes.. that's basically what I had arrived at..
12:00:02 <Arnar> but for some stupid reason it want's to derive Monad (t IO)
12:00:04 <Arnar> gr
12:00:12 <sinelaw> off-topic: hi!
12:00:19 <Veinor> > GHC.Exts.the
12:00:20 <lambdabot>   Not in scope: `GHC.Exts.the'
12:00:29 <aavogt> hi sinelaw
12:00:29 <Veinor> ?
12:01:04 <Arnar> kmc_: hang on.. now I got something to typecheck..
12:01:09 <Arnar> kmc_: let's see if it does the right thing
12:01:26 <aledge> goddamit, I took my computer to the shop to be fixed
12:01:41 <aledge> at the same time I had an epiphany about how to fix some code i was working on
12:01:49 <aledge> so I can't try it out until next weeksih probably :(
12:01:57 <Arnar> kmc_: YES :D
12:01:59 <Arnar> thanks!
12:02:19 <Arnar> I ended up with   instance (MT.MonadTrans t, MT.MonadIO (t m)) => MT.MonadIO (ErrorT e (t m))
12:02:30 <Arnar> and changed the impl to   MT.lift . MT.liftIO
12:02:54 <kmc_> cool
12:03:49 <Arnar> kmc_: bah.. *facepalm*
12:04:02 <IceDane> Nei, annar íslendingur?
12:04:05 <Arnar> it was actually sufficient to have only instance (MT.MonadIO m) => MT.MonadIO (ErrorT e m)
12:04:17 <kmc_> ah
12:04:20 <Arnar> IceDane: j.. your nick indicates danish though :)
12:04:21 <kmc_> makes sense
12:04:37 <IceDane> Arnar: I'm a bit of both
12:05:00 <Arnar> kmc_: I realized it when I started writing the comment explaining the purpose of this :)
12:05:04 <Arnar> but thanks..
12:06:46 <Arnar> IceDane: i'm in .se myself actually
12:06:47 <burp> hm, has anyone recently build h4sh? the dependencies don't seem to build anymore (hs-plugins)
12:07:01 <IceDane> Arnar: I saw on the whois. Living in iceland makes no sense these days
12:07:01 <tARrAScH> aavogt: Hmm, to sum up what I have now, I can very easily create the precise arguments to the binds, my only problem is like this: When I code in a do notation the scoping of the lamda x parameter is visible, but how can I see it when I'm generating an arbitrary MyMonad Int?
12:07:19 <tARrAScH> aavogt: please say If I'm bothering you with questions ...
12:07:47 <Arnar> @instances MonadState
12:07:47 <kmc_> IceDane: why not?
12:07:47 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
12:08:21 <arkleseizure> @pl \ x -> (Just x, x)
12:08:21 <lambdabot> (,) =<< Just
12:08:27 <arkleseizure> that's what I thought
12:08:41 <Arnar> kmc_: our currency is in the crapper
12:09:21 <arkleseizure> @pl \ f x _ -> g (f x)
12:09:21 <lambdabot> ((const . g) .)
12:09:53 <kmc_> Arnar: yeah, it's weird to have an independent currency for a country of only 300,000 people that's heavily dependent on trade with the Eurozone
12:09:55 <Arnar> kmc_: being a phd student in .se gives me the same buying power when I travel to Iceland as a full time systems designer with 5 years seniority
12:10:03 <sinelaw> has anyone success compiling sdl on windows?
12:10:04 <kmc_> still, i like it because there are fish on the coins :)
12:11:04 <Arnar> kmc_: hehe yes.. and a troll :D
12:11:13 <kmc_> which one has the troll?
12:11:44 <medfly> Arnar, it's like moving to a third world country!
12:11:47 <medfly> Arnar, except it's not
12:12:12 <aavogt> tARrAScH: are all the parameters the same type?
12:12:43 <Arnar> medfly: precisely
12:12:50 <kmc_> on the other hand, all the geothermal power you can eat
12:12:53 <medfly> MAGICAL
12:13:01 <aavogt> if they are, then you might more easily have the same result by generating:  [[Int] -> m [Int]]
12:13:07 <tARrAScH> aavogt: well when I'm not using >> then yes, they are Int in facts
12:13:33 <kmc_> why don't they run a big fuckoff power cable to scotland by way of the faroe islands
12:13:34 <aavogt> but at this point your test case is getting more complicated than you original implementation :)
12:13:46 <nomeata> Hi. Has anyone succeeded in building hugs packages with Cabal-1.8? I get hlibrary.setup: --inplace is not supported with Hugs
12:13:52 <kmc_> or huge microwave power transmission towers
12:14:16 <nomeata> But ./Distribution/Simple/Build.hs seems to hardcode that
12:15:18 <tARrAScH> aavogt: wait a second what did you mean by parameters?
12:16:33 <IceDane> kmc_: Someone may have said this between the point where you said and now, but I'll say it anyway: The econonmy in iceland is in the shitter. I thought this was known everywhere? It's nice to vacation there now.
12:17:09 <kmc_> yeah i know
12:17:27 <tARrAScH> my Monad instance is basically like: f1; f1; a <- f2; f1; b <- f2; return a*b; The problem I have is that I lose track of 'a' and 'b' when I'm generating the Monad
12:17:34 <kmc_> but the massive supply of cheap electricity hasn't gone away
12:17:38 <kmc_> surely it could be monetized
12:17:42 <IceDane> Perhaps
12:18:17 <kmc_> i guess nobody has the spare capital for wonder-of-the-modern-world-scale engineering projects anymore :/
12:18:37 <Arnar> kmc_: exporting electricity is the problem
12:18:50 <kmc_> how about pumping CNG tankers with compressed air instead
12:18:51 <Arnar> currently it's done by folding it in aluminum :)
12:18:54 <aavogt> perhaps other projects like Al smelting make more sense
12:18:55 <kmc_> yeah
12:19:28 <Cale> tARrAScH: sorry, what? You're programmatically generating monad instances?
12:19:53 <tARrAScH> Cale: I try to ...
12:19:57 <Cale> Why?
12:20:08 <tARrAScH> Cale: Testing my code
12:20:33 <tARrAScH> Cale: or actually it's an assignment at uni
12:20:35 <aavogt> do you know of free theorems?
12:20:38 <Cale> I don't see why you'd need to generate monad instances to test code.
12:20:45 <Arnar> kmc_: my code is so beautiful now that I could cry..
12:21:04 <Cale> So you're using Template Haskell?
12:21:15 <aledge> Arnar, it is funny, I believe a friend of mine is moving from here (US) to Iceland to work
12:21:16 <tARrAScH> Cale: well It's Monad Int
12:21:28 <Cale> Int isn't the right kind to be a monad.
12:21:28 <tARrAScH> Cale: actually MyMonad Int
12:21:31 <Cale> oh
12:21:34 <Cale> Er...
12:21:37 <newsham> ?seen conal
12:21:37 <lambdabot> Unknown command, try @list
12:21:39 <IceDane> aledge: Really? What is his function?
12:21:48 <Cale> So, you're not generating monad instances, you have just one monad?
12:21:59 <Arnar> aledge: will he get paid US salary?
12:22:06 <aledge> IceDane, I think he's going to work for EveOnline, and I don't know the details
12:22:08 <Cale> and you're generating values in that monad?
12:22:13 <aledge> err
12:22:14 <aledge> Arnar
12:22:17 <aledge> no wait
12:22:18 <aledge> hahaha
12:22:23 <aledge> Arnar, don't know
12:22:29 <Arnar> aledge: ccp (eve online producer) offers some people contracts in USD or EUR
12:22:40 <IceDane> I hope to god he's getting paid in EUR
12:22:51 <IceDane> Otherwise he might as well get paid in monopoly money
12:22:57 <Arnar> since their revenue is mostly in foreign currency..
12:23:08 <aledge> IceDane, USD would be ok I suppose?
12:23:10 <Arnar> can he convince them to use haskell (just so that we stay on topic):)
12:23:10 <tARrAScH> Cale: Yea, the type MyMonad (Int), I want to make some binds  yes.
12:23:18 <kmc_> would you rather take your pay in Icelandic ISK or Eve ISK? ;)
12:23:21 <IceDane> aledge: Yeah, of course.
12:23:26 <aledge> IceDane, :_)
12:23:32 <Arnar> kmc_: haha.. unfortunately
12:23:36 <Arnar> eve isk :)
12:23:47 <aledge> kmc_, tbh, knowing this guy, he just *might* take Eve ISK
12:23:48 <IceDane> Not the same amounts, though, heh.
12:24:11 <Cale> tARrAScH: So you want to generate values of type MyMonad Int, that's fine.
12:24:34 <Cale> tARrAScH: Depending on what monad it is, that may or may not be terribly useful...
12:24:47 <tARrAScH> Cale: Hmm, Do you have any resources that've done this (prefarbly on easy Monads). Or any general hints?
12:24:58 <Cale> (actually the fact that it's a monad is less important than what type it really is)
12:25:19 <Cale> How is MyMonad defined?
12:26:01 <Cale> and what sort of function are you trying to test?
12:26:20 <tARrAScH> Cale: Yea, I think I examplified my "scooping" problem above where I couldn't see 'a' and 'b'
12:26:28 <tARrAScH> Cale: Well, how it's defined, lets see...
12:26:42 <Cale> I don't really understand the scoping thing.
12:27:06 <Cale> Scope should have nothing to do with it, unless you're generating source code for these things, rather than values directly.
12:27:52 <tARrAScH> well keep in mind that I'm not savvy (yet :)). Let me demonstrate
12:29:10 <tARrAScH> do f1; f1; a <- f2; f1; b <- f2; return a*b; Let's say that would compile, but how would I be able to do that if I'm generating the monad, would I be able too see the values returned by f2 after their execution?
12:29:49 <tARrAScH> Cale: maybe I'm just lacking basic monad knowledge...
12:30:00 <Cale> You're not generating a monad.
12:30:07 <Cale> You're generating a value in the monad.
12:30:20 <tARrAScH> Sorry. I meant that :)
12:30:34 <Cale> "A monad" refers to a type constructor, together with definitions for return and >>=
12:30:39 <aavogt> well what do you compare that value to?
12:30:40 <tARrAScH> And Of course it wouldn't make sense to say generating a monad...
12:30:46 <aavogt> what are you looking to "check"?
12:31:11 <Cale> tARrAScH: What is your specific monad?
12:31:27 <tARrAScH> @paste
12:31:27 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:31:43 <tARrAScH> darn internal error
12:32:30 <tARrAScH> newtype Replay q r a =  R { unR :: Trace r -> IO (Either (Maybe q, Trace r) a) }
12:33:26 <Cale> @where hpaste
12:33:26 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
12:33:31 <Cale> use the first link
12:33:42 <Cale> er, oh, that's out too
12:33:46 <tARrAScH> lol
12:33:51 <Cale> Weird.
12:36:01 <tARrAScH> Anyway, I doubt there's much information I can get here if you don't know of about any similiar succesful tries. Or know of any general hints...
12:40:49 <tARrAScH> THank you guys, but I think I better sleep on the problem :)
12:47:26 <nomeata> Is it possible that ghc6-6.12 compiles a lot faster than 6.10? It feels like it.
12:47:54 <medfly> VOOOOSH
12:48:08 <kmc_> which ghc did you compile ghc 6.12 with? and which ghc did you compile ghc 6.10 with?
12:48:29 <paolino1> I'm having problem installing ghc 6.12. I have ubuntu 9.10 for i386 on virtual box. Configure runs ok. make install just error at the beginning
12:49:19 <sshc> how do I configure a cabal package to link with an RTS hook written in C?
12:49:34 <mrsolo> i wonder when haskell platform will jump to 6.12...
12:49:50 <int-e> paolino1: well, what is the error?
12:50:05 <int-e> @where paste
12:50:06 <lambdabot> http://hpaste.org/new
12:50:22 <sshc> how do I configure a cabal package to link with an RTS hook written in C?
12:52:15 <paolino1> int-e . It disappeared somehow , after untarring a second time .... unbelievable, sorry
12:52:59 <int-e> sshc: I'd expect that if you add the c file to a C-sources: line, it'll be linked with your program
12:56:03 <paolino1> int-e , strangely, errors were written in italian , nevermind, it will happen again to someone else
12:57:18 <sshc> int-e: thanks!
12:57:42 <Twey> Fear the T_PAAMAYIM_NEKUDOTAYIM.
12:58:14 <medfly> hehehe
12:58:57 <pflanze> I'm looking for documentation on how the do notation works (translation rules, or precise description of what's happening).
12:59:50 <Heffalump> translation rules are in the language report
13:00:19 <pflanze> thanks
13:01:41 <Cale> pflanze: Roughly, it looks like:
13:01:46 <Cale> do { x } = x -- base case
13:02:01 <Cale> do { x; <stmts> } = x >> do { <stmts }
13:02:03 <Cale> oops
13:02:04 <Cale> do { x; <stmts> } = x >> do { <stmts> }
13:02:12 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
13:02:50 <Cale> do { let { <decls> }; <stmts> } = let { <decls> } in do { <stmts> }
13:04:13 <Berengal> Cale: Roughly? Looks like "exactly" to me
13:04:19 <Gracenotes> it's nice and elegant, when you look at it like that
13:04:43 <Cale> Berengal: I'm leaving out the handling of pattern match failure.
13:04:50 <Berengal> Ah, true
13:05:18 <Berengal> Those are somewhat more complicated, and involves types...
13:05:25 <c_wraith> too bad the spec didn't take that step
13:05:45 <pflanze> When http://www.haskell.org/all_about_monads/html/class.html#donotation says "advantage of membership in the Monad class is the Haskell support for "do" notation", what do they mean with that membership requirement
13:06:12 <Cale> pflanze: That there's an instance of the typeclass Monad for the given type constructor.
13:06:25 <Cale> class Monad m where
13:06:25 <_Jedai_> pflanze: if your type is an instance of the typeclass Monad, you can use the do-notation with it
13:06:29 <pflanze> Why would the translator care about the type membership? According to the above rules there is no testing of the types involved.
13:06:52 <_Jedai_> Well you're right, but (>>) and (>>=) are defined on Monad
13:06:56 <Cale> pflanze: >>= and >> have types
13:07:12 <pflanze> Sure, but that's what's the result of the translation, not the input.
13:07:25 <Saizan> yeah, the translation is purely syntactical
13:07:27 <pflanze> So it's just the docs being misleading?
13:07:35 <_Jedai_> if you want to use the translator with arbitrary (>>), you'll have to hide the Monad typeclass (or there will be conflicts)
13:07:43 <c_wraith> well, things that aren't monads don't type-check after translation
13:07:43 <kmc_> > do { 5 }
13:07:44 <lambdabot>   5
13:08:09 <_Jedai_> kmc_: trivial case excepted
13:08:16 <Twey> > do { let { x = 5 }; x }
13:08:17 <lambdabot>   5
13:08:21 <Heffalump> pflanze: those operators are part of the Prelude and are defined to have type Monad m =>
13:08:30 <pflanze> I see; the important thing is that the resulting >> and >>= will need to match your types and hence have an instance matching your types.
13:08:38 <Twey> Trivial *cases* ;)
13:08:38 <Cale> pflanze: right.
13:08:39 <pflanze> It's that what is meant.
13:08:46 <kmc_> if you use -XNoImplicitPrelude you can define your own (>>) and (>>=) with whatever type you like
13:08:55 <Heffalump> and the translation is defined to pick up the ones from the Prelude no matter what is in scope, unless you use the GHC extension -XNoImplicitPrelude as kmc said
13:09:07 <pflanze> Ok, thanks!
13:09:28 <kmc_> > do { x <- 3; return x+2 }
13:09:29 <lambdabot>   No instance for (GHC.Num.Num (m b))
13:09:29 <lambdabot>    arising from the literal `3' at <int...
13:09:38 <sinelaw_> anyone successeeded installing sdl-image and sdl-tiff for windows?
13:09:44 <sinelaw_> succeeded :)
13:09:45 <Cale> pflanze: I'd also like to point out that do-notation isn't the real advantage of defining something as a monad. It's really that you get all the stuff in Control.Monad and other libraries which is polymorphic over the type of monad it works in.
13:10:07 <Gracenotes> > do { x <- return 3; return (x+2) }
13:10:08 <lambdabot>   No instance for (GHC.Show.Show (m b))
13:10:09 <lambdabot>    arising from a use of `M1621833176...
13:10:12 <kmc_> >
13:10:17 <kmc_> > do { x <- (); return () }
13:10:18 <lambdabot>   Couldn't match expected type `()' against inferred type `m a'
13:10:29 <kmc_> in my ghci that gives an error referencing "a stmt of a 'do' expression"
13:10:35 <kmc_> rather than parameters to (>>=)
13:10:48 <kmc_> so it does typecheck the sugar, or remember it anyway, probably to give better error messages
13:10:59 <mauke> precisely
13:11:04 <Gracenotes> it tends to be good at preserving the original code
13:11:10 <kmc_> the report should only require that if the desugaring is type correct then the sugar is accepted
13:11:10 <Cale> It probably depends on what extensions you have turned on too.
13:11:15 <IceDane> http://icedane.pastebin.com/d6e7671d3 I'm trying to modify this RPN calculator so that it returns a Maybe Float, and I have a feeling that the problem would lend itself well to using monads. Could someone give me a hint as to how I could implement it? (Hpaste is broken, btw)
13:11:15 <Gracenotes> as opposed to, say, template errors in C++, cough
13:11:56 <kmc_> fwiw i prefer codepad over pastebin
13:12:13 <MissPiggy> IceDane why not just define a new Num instance for  Num a => Num (Maybe a)
13:12:20 <kmc_> uh
13:12:25 <kmc_> that's a pretty dramatic change
13:12:26 <MissPiggy> then you have  Nothing + _ = _ + Nothing = Nothing
13:12:27 <Gracenotes> IceDane: in which situations would you want it to be Nothing?
13:12:32 <Cale> Hehe, "ln". Everyone knows that "log" is the one true notation for the natural logarithm ;)
13:12:37 <MissPiggy> and _ / Just 0 = Nothing
13:12:56 <IceDane> Gracenotes: Every time it would fail to parse something. I would probably use reads to detect parsing failure
13:13:06 <mauke> preflex: calc ln 10
13:13:06 <preflex>  2.302585092994046
13:13:14 <kmc_> IceDane: you might want to use Applicative rather than Monad
13:13:17 <MissPiggy> MissPiggy, you could actually define Num (m a) for something like MonadPlus m and Num a
13:13:20 <MissPiggy> err
13:13:26 <MissPiggy> IceDane should have been
13:13:26 <Zao> I love uu-parsinglib.
13:13:29 <Gracenotes> well, you could use foldM instead of foldl as a starting hint for types
13:13:32 <Gracenotes> @type foldM
13:13:33 <IceDane> So every time a nothing is in the sequence at all, the whole thing should be nothing. <- this is the reason I thought this would be easy to solve with monads or something.
13:13:33 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:13:46 <IceDane> hmm.
13:13:48 <Gracenotes> that would make the function: (a -> b -> Just a) -> a -> [b] -> Just a
13:13:59 <Cale> Gracenotes: You're confusing types and values.
13:14:20 <mauke> preflex: calc 10 ln 2 +
13:14:21 <preflex>  4.302585092994046
13:14:24 <Gracenotes> Cale: in what sense? designing it based on a reasonable type it should have
13:14:45 <MissPiggy> hi conal
13:14:46 <Cale> Gracenotes: foldM would specialise to  (a -> b -> Maybe a) -> a -> [b] -> Maybe a
13:14:49 <mauke> Gracenotes: Just is not a type
13:14:55 <Cale> (Just doesn't mean anything at the type level)
13:15:00 <Gracenotes> er, mental typo
13:15:03 <MissPiggy> Gracenotes knows that :P
13:15:16 <Gracenotes> not the first time I've confused which one's the type and which one's the constructor, not the last :)
13:16:07 <MissPiggy> oh scared him away
13:16:15 <IceDane> I'm still here.
13:16:25 <Gracenotes> the Maybe-is-named-wrong crowd might not be too far off
13:16:38 <MissPiggy> yeah it should be called Option
13:16:42 <mauke> LessThanTwo
13:17:28 <kmc_> Vec {2} a
13:17:51 <aavogt> data Just a = Nothing | Maybe a
13:17:59 <kmc_> that makes less sense
13:18:16 <kmc_> data Maybe a = Definitely a | SurelyNot
13:18:17 <aavogt> it's legal and works too if you hide Nothing
13:18:30 <IceDane> Gracenotes: I just @src'd folM, and the little knowledge of monads that I have was thinking that I needed something similar. foldM basically chains everything together, and if I'm using the Maybe monad it will result in Nothing if one item in the sequence is nothing?
13:18:46 <Gracenotes> exactly
13:18:49 <MissPiggy> what about my suggestion
13:18:56 <IceDane> MissPiggy: I didn't understand it
13:19:01 <IceDane> so I'm pretending to have missed it
13:19:04 <MissPiggy> and
13:19:04 <pikhq> IceDane: Yes, that's how Maybe works.
13:19:05 <MissPiggy> okay
13:19:11 <kmc_> there's a section in that Agda tutorial where they show how to rename Maybe as you import it to have ML syntax
13:19:22 <MissPiggy> a lot ofpeople do that it's pretty irritating, I should stop trying to acutally help people
13:20:50 <Gracenotes> MissPiggy: I read it :D to me, it looks like you're saying the input types should also be Maybes, which doesn't seem like the case... an effectful folding like foldM could be the proper solution
13:21:09 <IceDane> MissPiggy: I'm sorry, I'm confused enough as it is with trying to learn to use monads that I don't need to be focusing on other solutions, even if there are any.
13:24:07 <Gracenotes> I'm trying to look for a generalization of foldM in Data.Foldable, but all there is is foldlM, which requires Monad and Foldable, collapsing to the exact same thing with lists
13:30:37 <conal> MissPiggy: hi
13:31:11 <MissPiggy> hey
13:34:32 * jmcarthur just realized that since the Computation monad is actually the same as Free Identity then it should probably also benefit from a CPS definition
13:35:08 <kmc_> which monad is that?
13:35:23 <jmcarthur> kmc_: data Computation a = Now a | Delay (Computation a)
13:35:52 <jmcarthur> and in my own version i also add a Never constructor for speed
13:36:01 <jmcarthur> since sometimes i just want fix Delay
13:36:50 <jmcarthur> i'm thinking about writing a package for it
13:37:15 <jmcarthur> i'm finding it to be very useful. thanks MissPiggy for reminding me of its existence
13:38:47 <aep> any idea what i need to link to for "__stginit_basezm3zi0zi3zi2_ForeignziC_"  ?
13:39:15 <Cale> aep: You need --make
13:39:44 <Cale> Er, that's actually pretty odd.
13:39:49 <aep> ah right.  thanks
13:40:01 <Cale> Because that symbol is in the base package.
13:40:11 <Cale> Maybe you're using the wrong version of base somehow?
13:40:20 <aep> dunno.  i want to use System.Fuse
13:40:22 <jmcarthur> kmc_: the main use of it for is that i can write amb in terms of it:  amb :: Computation a -> Computation a -> Computation a
13:40:30 <jmcarthur> *of it for me
13:40:33 <aep> but i had to get it from cabal, since it appears to be missing in ghc
13:40:47 <aep> and the cabal package seems to be not the same as in ghc
13:42:04 <jmcarthur> i'm not really sure i like all the terminology surrounding Computation, including the name, but i love the idea
13:42:16 <IceDane>  http://icedane.pastebin.com/d3092ca24 <- Any takers? I'm not sure I understand what the error is.. foldingFunction takes string and returns a Maybe Float
13:43:26 <monochrom> (is it just me or is pastebin.com highlighting less readable than the plain text box? :) )
13:43:35 <jmcarthur> i agree
13:43:54 <Twey> Yeah, definitely
13:43:58 <Twey> Yellow on white?  Ych
13:44:12 <IceDane> Yeah, it's pretty bad
13:44:15 <IceDane> No idea what they're doing
13:44:17 <Twey> And the underline… while I understand it's to show it's a link…
13:44:17 <IceDane> but hpaste is down.
13:44:24 <Twey> IceDane: moonpatio.com
13:44:35 <IceDane> Twey: I did google for a haskell pastebin, didn't find that one
13:44:35 <Twey> Oh
13:44:35 <IceDane> thanks
13:44:36 <sinelaw_> anyone lucky enought to succesfully build sdl-ttf an sdl-image on windows?
13:44:39 <Twey> Damn, that one's dead too
13:44:40 <sinelaw_> i'm losing my mind here
13:44:41 <monochrom> (I think 60% of the problem is using, like, #fefefe foreground on #ffffff background. :) )
13:44:43 <IceDane> oh =(
13:44:44 <Twey> paste.lisp.org
13:44:51 <luqui> IceDane, foldingFunction does not return a Maybe Float
13:44:58 <jmcarthur> hpaste.org ?
13:45:04 <jmcarthur> oh dang
13:45:04 <monochrom> @where hpaste
13:45:05 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:45:07 <luqui> IceDane, it returns a [Maybe Float]
13:45:07 <monochrom> two choices
13:45:10 <jmcarthur> hpaste dead
13:45:19 <jmcarthur> both dead!
13:45:22 <jmcarthur> :(
13:45:31 <monochrom> onoes
13:45:32 <jmcarthur> codepad.org
13:45:41 <jmcarthur> tries to run your code! :)
13:46:23 <luqui> IceDane, I don't understand your code fully, but from your naming ("stack"), are you expecting the return value of foldingFunction to be the new stack?
13:46:51 <IceDane> luqui: I believe that's how it worked when I used foldl, yes
13:46:59 <jmcarthur> a simple one that my wife did the logo for http://www.pasteit4me.com/
13:47:22 <luqui> IceDane, since foldingFunction returns a List, the monad that foldM is using is the list; a.k.a. nondeterminism monad
13:47:46 <luqui> IceDane, I am not sure you want foldM
13:48:10 <luqui> or maybe you do... but it should look more like...
13:48:45 <IceDane> luqui: This is basically a 'test case' for an RPN calculator. If it fails to parse at some point, it should return Nothing down the whole line.
13:48:55 <IceDane> And as I understand, that's what foldM will do for me with they maybe monad
13:49:22 <luqui> IceDane, but you were in the list monad.  if you want Maybe, foldingFunction has to return a Maybe something...
13:49:29 <luqui> whereas now it returns a List something...
13:50:06 <luqui> something more like: http://icedane.pastebin.com/m4117928e
13:50:28 <luqui> though i think that's wrong, it was just the minimal modification to get the idea across
13:51:11 * RayNbow just received a long chained-retweet with conal and luqui in it...
13:51:12 <IceDane> Hmm. So I can't 'build a stack' like I can with foldl? To put into perspective, I'm trying to basically modify this calculator to return Nothing if it ever hits an element that it can't parse. http://icedane.pastebin.com/d6e7671d3
13:51:29 <RayNbow> Small World Effect :p
13:51:41 <c_wraith> IceDane: You really probably want to be using lots of liftM* functions
13:51:48 <kmc_> or <$> and <*>
13:51:55 <gwern> http://www.reddit.com/r/haskell/comments/7ydun/share_your_haskell_experience/c07qwvt
13:51:59 <luqui> IceDane, sure you can.  return Just (whatever) when you succeed, and Nothing when you fail.
13:52:02 <gwern> looks like I'll win that one
13:52:06 <luqui> from foldingFunction
13:52:15 <gwern> I haven't heard anything about maybet being included in the ghc pckages
13:52:18 <IceDane> Hmm..
13:52:40 <c_wraith> Or, for that matter, liftA* functions :)
13:52:56 <MissPiggy> what's happening in the twitter machine?
13:53:12 <c_wraith> :t liftA2 (+) (Just 5) (Nothing)
13:53:13 <lambdabot> forall a. (Num a) => Maybe a
13:53:17 <c_wraith> > liftA2 (+) (Just 5) (Nothing)
13:53:17 <gwern> nor is maybet in the haskell platform
13:53:18 <lambdabot>   Nothing
13:53:18 <gwern> phew!
13:53:26 <c_wraith> > liftA2 (+) (Just 5) (Just 8)
13:53:27 <lambdabot>   Just 13
13:53:27 <luqui> IceDane, if foldingFunction returned Nothing, the foldM terminates with Nothing.  If foldingFunction returned a (Just something), the (something) will be passed to the next iteration of foldingFunction
13:53:44 <IceDane> luqui: luqui Oh, of course!
13:53:51 <IceDane> That makes sense.
13:54:02 <luqui> :-)
13:55:38 * c_wraith realized yesterday how often <* can convert 3 lines of code into one line
13:56:07 <MissPiggy> c_wraith, another notation for it could be (| ... |) from She
13:59:58 <DBAlex> hey
14:00:22 <sinelaw_> arrrg, fclabels + windows = fail
14:00:26 <DBAlex> why isn't something as simple as this in the Prelude or Data.List (yes I know pastebin.com sucks, but hpaste is broken): http://pastebin.com/m3177bb2f
14:00:33 <kmc_> DBAlex: i like codepad
14:00:35 <DBAlex> also, can anyone write that as a one-liner?
14:00:40 <kmc_> DBAlex: i've wondered that
14:00:51 <DBAlex> I couldn't find it on Hoogle
14:00:53 <MissPiggy> hahah chunk
14:01:03 <DBAlex> What's so funny?
14:01:18 <MissPiggy> this comes up periodically, for years on end
14:01:29 <DBAlex> Well it probably should be in the prelude then
14:01:31 <DBAlex> or Data.List
14:01:36 <DBAlex> as well as a string split too
14:02:17 <aep> i have a lib (System.Fuse) which expects a bunch of callbacks. none of these callbacks allows for any user data. Now i can add some parameter thanks to currying, but how can i preserve state between the called functions? :/
14:02:21 <DBAlex> Is it possible to define chunk as a one liner?
14:02:26 * DBAlex pokes kmc_ 
14:02:27 <Berengal> @type let if' b t f = if b then t else f in \n -> unfoldr (if' <$> null <*> pure Nothing <*> Just . splitAt n)
14:02:29 <lambdabot> forall a. Int -> [a] -> [[a]]
14:02:31 <MissPiggy> yeah but why would you want to?
14:02:41 <MissPiggy> @wiki chunk
14:02:41 <lambdabot> http://www.haskell.org/haskellwiki/chunk
14:02:42 <DBAlex> Because I don't want to add an extra 3 lines
14:02:45 <DBAlex> i'd rather have a where
14:03:06 <MissPiggy> http://www.haskell.org/haskellwiki/Data.List.Split
14:03:55 <MissPiggy> DBAlex that's a weird thought.. 3 lines is bad but 1 line is okay
14:04:03 <DBAlex> http://www.haskell.org/haskellwiki/HaskellWiki:New_accounts < Which is the most active email here?
14:04:22 <Berengal> MissPiggy: I too find top-level utility functions to clutter my modules
14:04:27 <DBAlex> MissPiggy: it is when your program is supposed to be small
14:04:39 <MissPiggy> still not getting it, it's probably me not you
14:04:39 <sinelaw_> how can i access an sub-record without fclabels?
14:04:40 <DBAlex> and I still have about 20-30 lines to write for minimax and what not
14:04:55 <mm_freak> > let chunk n = takeWhile (null.not) . map (take n) . iterate (drop n) in chunk 3 [1..]
14:04:56 <lambdabot>   Couldn't match expected type `[a]'
14:04:56 <lambdabot>         against inferred type `GHC.Bool....
14:04:56 <Berengal> @where SEC
14:04:56 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
14:05:01 <Berengal> sinelaw_: ↑
14:05:04 <sinelaw_> can I do this? bla{field={subfield={...}}}
14:05:34 <mm_freak> > let chunk n = takeWhile (not.null) . map (take n) . iterate (drop n) in chunk 3 [1..]
14:05:35 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
14:05:44 <jmcarthur> DBAlex: heh are you also doing the google ai challenge
14:05:45 <jmcarthur> ?
14:06:05 <DBAlex> jmcarthur: no, this is uni coursework, I probably shouldn't tell you that though ;-)
14:06:10 <Berengal> sinelaw_: foo{field=bar{subfield=}} should work
14:06:11 <Dodek> hey, i need an  asynchronous i/o on sockets
14:06:14 <DBAlex> since i'm buggered if I ask for any help now ;)
14:06:20 <Berengal> Dodek: forkIO :)
14:06:22 <mm_freak> Dodek: use concurrency
14:06:25 <Dodek> the Network interface seems to be fully synchronous
14:06:36 <jmcarthur> DBAlex: we don't have a problem with helping with homework here, generally
14:06:41 <sinelaw_> Berengal what's the 'bar'  there?
14:06:47 <DBAlex> jmcarthur: I didn't ask specific questions anyway
14:06:48 <jmcarthur> DBAlex: it's best to be up front about it though ;)
14:06:48 <Dodek> concurrency? that's what i wanted to avoid
14:07:00 <sinelaw_> Berengal and will that modify only the subfield?
14:07:03 <mm_freak> Dodek: why do you want to avoid it?  note that it has nothing to do with OS threads
14:07:05 <DBAlex> jmcarthur: true
14:07:06 <Berengal> sinelaw_: another value. You want pattern-matching?
14:07:18 <jmcarthur> DBAlex: many of us just answer questions. if it prevent you from learning it properly then you shouldn't have asked
14:07:35 <mm_freak> Dodek: concurrency is haskell's way of expressing (among other things) access to multiple file handles/sockets simultaneously
14:07:38 <DBAlex> I only ask questions when i'm totally stuck
14:07:39 <sinelaw_> hmm
14:07:52 <DBAlex> which usually means I thought about it all day and I'm still getting no where
14:07:53 <jmcarthur> DBAlex: yeah that's how i used to do it too
14:07:53 <Berengal> sinelaw_: Ah, you want modification? Then my version should work
14:08:00 <jmcarthur> although i unfortunately never had haskell at uni :(
14:08:02 <Berengal> sinelaw_: But I'd write modificators
14:08:06 <DBAlex> which usually means i'm missing a really simple answer because I don't know the prelude properly...
14:08:09 <sinelaw_> i give up
14:08:13 <kmc_> Dodek: thread in GHC-Haskell are cheap and simple
14:08:18 <Dodek> mm_freak: from my experience, using concurrency with i/o creates more problems than solves
14:08:31 <jmcarthur> DBAlex: are you reasonably good at reading type signatures?
14:08:31 <kmc_> Dodek: you have experience with this in Haskell?
14:08:38 <mm_freak> Dodek: but that's probably not haskell experience =)
14:08:38 <Dodek> no, in other languages
14:08:40 <sinelaw_> Berengal for modification i need bar to be equal to (field foo) no?
14:08:42 <DBAlex> jmcarthur: whats the google AI challenge anyway?
14:08:45 <kmc_> right, we do things differently
14:08:50 <kmc_> you've probably noticed that in other areas ;)
14:08:53 <DBAlex> jmcarthur: you're going to recommend hoogle right?
14:08:53 <Berengal> Dodek: In Haskell the experience should be different. At least for something as simple as this
14:08:54 <jmcarthur> DBAlex: http://csclub.uwaterloo.ca/contest/index.php
14:08:57 <DBAlex> kmc_: :-P
14:09:02 <DBAlex> oops
14:09:03 <kmc_> Dodek: note that the GHC runtime implements multiple Haskell threads blocking on IO as a single call to select or epoll
14:09:07 <jmcarthur> DBAlex: a lot of the entries are using minimax in their AIs
14:09:14 <mm_freak> Dodek: haskell threads are, as kmc_ noted, lightweight…  what appears to you as many threads is technically just a select() call
14:09:15 <jmcarthur> DBAlex: that's why i thought you were participating
14:09:20 <gwern> anyone know whether cabal-install allows specifying shared libraries in ~/.cabal/config?
14:09:20 <DBAlex> ok
14:09:30 <Dodek> oh, is it
14:09:30 <gwern> cabal-install seems to just have --enable-shared
14:09:37 <Dodek> now it's getting interesing
14:09:47 <jmcarthur> DBAlex: no i wasn't going to recommend hoogle. i was just wondering how good you might be at just skimming things like Prelude and Data.List for type signatures that look useful
14:09:47 <Berengal> sinelaw_: use -XRecordWildcards, or RecordPuns or something... anyway, do "where Foo{..} = foo" to open foo, then you can use "foo{bar=bar{subfield=5}}"
14:09:55 <kmc_> Dodek: RWH has some good examples of network programming, concurrency, etc.
14:09:56 <mm_freak> Dodek: it gets more interesting, because you can switch on multithreaded behaviour as you wish =)
14:09:57 <kmc_> @where rwh
14:09:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:10:03 <jmcarthur> DBAlex: because that's how i usually find things, personally
14:10:08 <DBAlex> jmcarthur: Yeah I do that, hoogle is best for that :)
14:10:11 <DBAlex> yeah :-)
14:10:13 <jmcarthur> DBAlex: hoogle and hayoo don't seem to be very accurate, to me
14:10:16 <mm_freak> Dodek: so all your concurrent programs are parallelizable with no overhead in code
14:10:35 <mm_freak> and the runtime does thread distribution for you…  you have to care about nothing =)
14:10:45 <kmc_> eh that's an overstatement
14:10:48 <DBAlex> I do like haskell, can get tedious at times though, guessing I shy away from writing my own programs in it, which is a bad thing
14:11:04 <Dodek> ok, so i'll look into it
14:11:09 <Dodek> thanks
14:11:11 <mm_freak> kmc_: compared to other languages, it's an understatement =)
14:11:20 <Berengal> Dodek: By default the haskell compiler uses a single-threaded runtime and a preemptive scheduler. The SMP runtime works the same, except there's multiple worker-threads
14:11:20 <kmc_> but yes, generally the idea is to spawn perhaps hundreds of thousands of Haskell threads and choose (via command line arg) how many OS threads to map them onto
14:11:25 <DBAlex> I only use it for uni work at the moment... but not in every module, but it's used quite a bit, e.g. for the compilers module
14:11:26 <kmc_> eh, GHC does
14:11:27 <jmcarthur> DBAlex: it becomes less and less tedious the more abstractions you learn. that's why it rocks :)
14:11:33 <sinelaw_> Berengal ok
14:11:36 <sinelaw_> thanks
14:11:38 <Chaze> can i look up all functions by a signature in ghci?
14:11:50 <kmc_> other compilers are free to do other things... the Concurrent Haskell spec does not preclude one OS thread per Haskell thread, iirc
14:12:04 <mm_freak> it's great how the GHC RTS easily handles 100000 concurrent threads on my system, each communicating with each other
14:12:05 <DBAlex> jmcarthur: yeah... I keep thinking "there most be a higher-order function way of doing this" but sometimes there just isn't
14:12:05 <jmcarthur> DBAlex: there is, of course, a point before which haskell is more tedious than most languages for some things, which i think puts a lot of people off
14:12:19 <DBAlex> e.g. chunk
14:12:26 <jmcarthur> DBAlex: usually there is anyway, but it's named something insanely abstract and is hard to find
14:12:31 <DBAlex> yep
14:12:35 <jmcarthur> what type does chunk have?
14:12:35 <DBAlex> or it's less clear
14:12:45 <DBAlex> umm it's just something I wrote
14:12:48 <mm_freak> DBAlex: well, if there isn't, most such boilerplate functions are very easy to write
14:12:50 <Berengal> Dodek: To read asynchronously, use something like "do {result <- newEmptyMVar; forkIO (readBlocking >>= putMVar result); <code that somewhere calls takeMVar result, which is blocking as long as it's empty>}
14:12:54 <DBAlex> but Int -> [a] -> [[a]]
14:12:59 <aep> how would you modify a reference to a list from multiple threads?
14:13:02 <DBAlex> mm_freak: true
14:13:05 <Zao> aep: Carefully?
14:13:06 <jmcarthur> DBAlex: oh, split the list into chunks of given size?
14:13:10 <mm_freak> DBAlex: btw, if there isn't, then it can be an indicator that you're using the wrong data type anyway =)
14:13:11 <aep> heh
14:13:11 <DBAlex> yes
14:13:27 <mm_freak> DBAlex: i posted an easy one-liner for your chunk function above
14:13:27 <DBAlex> jmcarthur: yup!
14:13:34 <DBAlex> mm_freak: thanks!
14:13:44 <mm_freak> > let chunk n = takeWhile (not.null) . map (take n) . iterate (drop n) in chunk 3 [1..10]
14:13:45 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
14:13:51 <kmc_> aep: you'd use a threadsafe reference type like MVar or TVar
14:13:58 <DBAlex> I think i'll stick with mine for now
14:13:59 <kmc_> IORefs give you no threading guarantees
14:14:12 <aep> kmc_: thanks, going to look that up
14:14:12 <jmcarthur> mm_freak: you just did just about exactly what i was going to do
14:14:13 <DBAlex> but cheers!
14:14:21 <Berengal> kmc_: atomicallyModifyIORef is atomic, isn't it?
14:14:26 <kmc_> i hope so
14:14:30 <kmc_> that's a good point
14:14:34 <mm_freak> jmcarthur: i needed that function a few times, so i can type it almost blindly =)
14:14:44 <Berengal> @type atomicallyModifyIORef
14:14:45 <kmc_> aep: RWH has good coverage of this stuff
14:14:45 <lambdabot> Not in scope: `atomicallyModifyIORef'
14:14:54 <burp> why takeWhile (not.null) ?
14:14:54 <aep> i was just wondering, all of these require copying the entire list each time
14:15:04 <burp> > map (take n) . iterate (drop n) $ [1..10]
14:15:05 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:15:05 <lambdabot>         against inferred type ...
14:15:07 <kmc_> as does http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
14:15:11 <mm_freak> DBAlex: generally if you have a function of type a -> [a], that's often an 'iterate' pattern
14:15:14 <burp> oops
14:15:18 <jmcarthur> burp: without that you would end up with a bunch of [[], [], [], []] at the end
14:15:19 <burp> > map (take 3) . iterate (drop 3) $ [1..10]
14:15:20 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
14:15:23 <burp> oh true
14:15:28 <kmc_> (also covers parallelism, which is something very different from concurrency)
14:15:29 <mm_freak> most list splitting/reformatting functions can be expressed easily with 'iterate'
14:15:35 <DBAlex> mm_freak: ok, see i'd never seen iterate before
14:15:39 <DBAlex> so, thanks
14:15:40 <kmc_> aep: if that's a problem, you probably should be using a different structure than a list
14:15:42 <jmcarthur> :t iterate
14:15:43 <lambdabot> forall a. (a -> a) -> a -> [a]
14:15:43 <DBAlex> I'll have a play around
14:15:45 <mm_freak> you're welcome =)
14:15:53 <aep> kmc_: such as?  its a file system
14:15:53 <Berengal> aep: When modifying only the reference, no. Lists are immutable, so multiple threads accessing it at the same time isn't a problem
14:15:54 <kmc_> like for example Data.Sequence
14:16:04 <jmcarthur> DBAlex: iterate is basically like fix, but it lets you see every application
14:16:09 <kmc_> all values are immutable
14:16:11 <mm_freak> burp: iterate never stops
14:16:26 <kmc_> sort of by definition
14:16:29 <mm_freak> > iterate (\x -> x^2 + 1) 1
14:16:30 <lambdabot>   [1,2,5,26,677,458330,210066388901,44127887745906175987802,19472704769152964...
14:16:34 <burp> but for [1..] it's no problem
14:16:40 <kmc_> aep: what properties does your data structure need?
14:16:40 <aep> kmc_: that would still require me to swap it each time i change it
14:16:46 <kmc_> sure
14:16:48 <burp> if the list is infinite ;)
14:16:51 <kmc_> what else do you want?
14:16:57 <aep> kmc_: well i need concurrent access from multiple threads
14:17:05 <aep> thats pretty much it. its a proof of concept anyway
14:17:15 <aep> fast traversal would be cool
14:17:21 <kmc_> i mean what does the structure have to store, an how?
14:17:27 <Chaze> I *think* I've seen someone in this channel look up functions just by providing a signature. I could be wrong though..
14:17:30 <DBAlex> basically, i'm having a lot of functions to write that need to access the value each time as a whole, not each element, so I guess iterate is what I need
14:17:32 <kmc_> linear sequence? with random lookup? insertion? traversal?
14:17:41 <sinelaw_> Berengal I eneded up solving the problem (build failure on windows) by moving my fclabel-using-stuff to a new package that requires the minimum stuff, not SDLor anything problematic
14:17:51 <mm_freak> Chaze: yes, some simple functions can be derived from their type
14:17:52 <aep> kmc_: tuples of  ("key",[stuff])
14:17:53 <jmcarthur> DBAlex: not sure what you mean
14:17:59 <sinelaw_> ugly. why does ghc dynamically-load EVERYTHING the package needs to do the fclabel stuff on a single module?
14:18:00 <Berengal> sinelaw_: That, too, is a decent solution :)
14:18:04 <Chaze> mm_freak: how would i do that in ghci?
14:18:06 <aep> kmc_: yes linear. but it doesnt matter really
14:18:06 <MissPiggy> @hoogle chaze -> chaze
14:18:06 <lambdabot> Prelude id :: a -> a
14:18:07 <lambdabot> Data.Function id :: a -> a
14:18:07 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
14:18:07 <mm_freak> @djinn Either e a -> Maybe a
14:18:07 <lambdabot> f a =
14:18:07 <lambdabot>     case a of
14:18:09 <lambdabot>     Left _ -> Nothing
14:18:09 <kmc_> aep: you're sure you don't want a Map rather than a list of tuples?
14:18:10 <lambdabot>     Right b -> Just b
14:18:11 <DBAlex> actually nvm
14:18:15 <kmc_> you called the first element a "key"
14:18:18 <aep> kmc_: good point
14:18:20 <kmc_> and so i suspect you want to look up by key?
14:18:23 <mm_freak> Chaze: GHCi can't do that
14:18:25 <aep> yeah
14:18:26 <Berengal> sinelaw_: Because it would otherwise segfault when running the native code?
14:18:29 <Chaze> @hoggle a -> (a,a)
14:18:29 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
14:18:29 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
14:18:29 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
14:18:33 <mm_freak> you need to install djinn
14:18:36 <mm_freak> oh
14:18:44 <mm_freak> you mean look up, not derive =)
14:18:45 <kmc_> an MVar that holds a Map should be pretty efficient generally.  when you insert into a Map, it will share most of its structure with the old map
14:18:49 <aep> kmc_: still doesnt solve the problem that it is imutable :D
14:18:55 <aep> really? cool
14:18:58 <kmc_> of course
14:19:01 <Berengal> aep: MVar is mutable
14:19:06 <aep> didnt realize that, i assumed swapping would be extremlöy expensive
14:19:08 <Chaze> mm_freak: interesting, so it's just lambdabot that's so awesome :)
14:19:17 <Berengal> aep: The reference is just a pointer
14:19:25 <Chaze> but meh, is there no (\x-> (x,x)) ?
14:19:32 <mm_freak> Chaze: i thought you mean to _derive_ functions from type signatures, not look up library functions =)
14:19:34 <c_wraith> :t (,)
14:19:35 <lambdabot> forall a b. a -> b -> (a, b)
14:19:40 <mauke> :t join (,)
14:19:41 <mm_freak> hmm
14:19:41 <lambdabot> forall a. a -> (a, a)
14:19:48 <Chaze> mm_freak: I simply want to look them up
14:19:58 <aep> thanks guys, going to try implement it with MVar Map
14:20:00 <mm_freak> there is no \x -> (x,x) predefined
14:20:05 <kmc_> aep: the beauty of a language with immutable values is that you don't have to do much copying
14:20:16 <xerox> > (,) x
14:20:17 <lambdabot>   {()->(x,())}
14:20:18 <Chaze> c_wraith: the "reverse" of :t, so to speak
14:20:23 <xerox> > join (,) x
14:20:24 <lambdabot>   (x,x)
14:20:24 <mm_freak> aep: out of interest, what do you need an MVar Map for?
14:20:25 <aep> kmc_: is it sort of implicit copied?
14:20:27 <jmcarthur> aep: immutability is actually more efficient for a lot of things than mutation! it means that if i have a data structure, make some change to it, but also need the original, it will only do the minimum of work needed to make the change but i get to keep both around for free
14:20:28 <kmc_> and trees (such as the one implementing Map) are nice for this, because you can copy nodes as needed, rather than copying the whole tree at once when you have a single "write"
14:20:36 <Berengal> aep: No, it's shared
14:20:42 <mm_freak> Chaze: the reverse of :t is @djinn
14:20:45 <aep> err implicit shared, yeah
14:20:51 <mm_freak> but that's derivation, not looking up in libraries
14:20:52 <aep> cool
14:21:01 <Berengal> aep: For example, if you have a list 'xs' and you do '1:xs' it doesn't have to copy the entire contents of 'xs'
14:21:10 <aep> mm_freak: i am implementing a fuse fs. need a backing store for the actual files in memory
14:21:19 <jmcarthur> aep: you could think of it as copy on write
14:21:19 <Chaze> @djinn a -> a
14:21:20 <lambdabot> f a = a
14:21:28 <aep> jmcarthur: yeah, cool
14:21:33 * aep likes
14:21:33 <mm_freak> aep: that sounds like a StateT Map to me =)
14:21:33 <c_wraith> @. pj djinn a -> a
14:21:33 <lambdabot> Plugin `compose' failed with: Unknown command: "pj"
14:21:39 <jmcarthur> aep: and since there is not mutation, there aren't really any writes, so there isn't really any "copying"
14:21:39 <c_wraith> @. pl djinn a -> a
14:21:39 <lambdabot> f = id
14:21:41 <mm_freak> aep: and an MVar to talk to the manager thread
14:21:42 <jmcarthur> ;)
14:21:42 <Berengal> aep: And when you modify a map which is implemented as a tree, it only needs to reallocate the root node and the path to the modified value
14:21:45 <aep> mm_freak: from multiple threads
14:21:53 <aep> mm_freak: huh
14:21:55 <Chaze> c_wraith: yeah, weird syntax
14:22:00 <Chaze> is this bot documented?
14:22:04 <mm_freak> aep: one thread to manage the tree
14:22:10 <mm_freak> multiple threads can talk to that thread
14:22:12 <jmcarthur> @commands
14:22:12 <lambdabot> Unknown command, try @list
14:22:14 <jmcarthur> @list
14:22:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:22:15 <Berengal> aep: By the way, if you're not doing synchronization on the reference, a TVar might be better suited
14:22:27 <aep> Berengal: thanks
14:22:33 <kmc_> yes, message channels are also cheap and easy
14:22:38 <aep> mm_freak: but that requires a lot more complex code
14:22:39 <Chaze> jmcarthur: thanks. rather minimalistic ;)
14:22:50 <mm_freak> aep: does it?
14:22:56 <mm_freak> aep: it centralizes tree management
14:23:01 <aep> hmm good point actually
14:23:11 <jmcarthur> Chaze: it would take too much space to print them all out here
14:23:13 <mm_freak> which gives you both safety and also cleaner code
14:23:23 <sinelaw_> wooho, compiles
14:23:29 <Berengal> Indeed, I sometimes write multithreaded code not because I have to but because it's easier to write that way
14:23:39 <mm_freak> aep: i'm having this usage pattern all the time, so i can show you example code, if you wish =)
14:23:45 <kmc_> aep: for better performance, consider a TVar (Map FileName (TVar Contents))
14:23:47 <Chaze> so there's really no equivalent of "djinn" in ghci?
14:23:54 <kmc_> where Contents is whatever type you choose to represent your file contents
14:24:01 <aep> what would you use for message passing in that case? it needs to be all blocking and the central instance has to have a fair locking mechanism
14:24:03 <kmc_> this way threads modifying different files stay out of each other's way
14:24:07 <c_wraith> does GoA still work?
14:24:16 <mm_freak> aep: http://codepad.org/qRHwLu10
14:24:21 <kmc_> aep: Chan ?
14:24:23 <aep> kmc_: nice idea thanks
14:24:30 <kmc_> aep: but i'd have to think further about that
14:24:31 <mm_freak> i'm prefer MVar over Chan
14:24:47 <kmc_> if you care about performance, the choice between STM and regular MVar / Chan will depend on the level of contention you expcet
14:24:55 <jmcarthur> for even better performance use a trie map instead of Data.Map (a red black tree)
14:25:00 <c_wraith> I used Chan () recently.  >_>
14:25:05 <jmcarthur> yeah i much prefer MVar to Chan
14:25:10 <Berengal> kmc_: Can't Chan also deadlock, or was that bug fixed?
14:25:10 <kmc_> GHC's implementation of STM is optimistic and so it should perform better than the implicitly-locked MVar for uncontended case
14:25:15 <kmc_> Berengal: i don't know about that bug
14:25:35 <mm_freak> kmc_: unless you really need queuing (instead of locking), Chan is better
14:25:35 <mm_freak> if you don't have specific need for it, don't use it
14:25:41 <DBAlex> mm_freak: Is it ok If I post that solution to chunk along with mine on the HaskellWiki (http://www.haskell.org/haskellwiki/Chunk) once I get an account? I'm going to credit yours of course
14:25:49 <kmc_> in a heavily contended case, STM threads can step on each other and cause lots of rollbacks, whereas locking would order them smoothly
14:25:55 <hzap> c_wraith: what's that for?
14:26:06 <jmcarthur> there are arguments that TChan can perform better than Chan, btw
14:26:29 <mm_freak> kmc_: frankly i've never found a need for STM
14:26:30 <jmcarthur> since all the exception handling can be held off to the end of a transaction instead of doing it for every single read and write
14:26:34 <Berengal> kmc_: There's also the message-passing, where locking is implicit in that there's only one thread to run your code, and it reads from an ordered Chan
14:26:44 <c_wraith> hzap: setting a maximum number of open connections.  read from the chan before accepting a connection.  Then fork, and write to the chan when you close the connection
14:27:07 <jmcarthur> i've found that if i stick to code as pure as possible i rarely need concurrency any fancier than an MVar
14:27:09 <Berengal> mm_freak: I use mostly STM, and I find that the more you use it the more uses you find for it
14:27:10 <kmc_> mm_freak: it's not about need, it's about making correct concurrent code easier to write and more composable
14:27:17 <jmcarthur> well, not fancy IO concurrency anyway
14:27:23 <jmcarthur> pure forms of concurrency are more common for me
14:27:26 <hzap> c_wraith: can't you use QSem?
14:27:40 <DBAlex> mm_freak: ?
14:27:50 <mm_freak> Berengal: i tried to, but almost always i've found that using more threads solved my problem in a cleaner way =)
14:28:02 <c_wraith> hzap: looks like I can.  Why does that have such an oblique name?
14:28:16 <mm_freak> DBAlex: i don't think there is a need for an extra wiki page for that function =)
14:28:28 <DBAlex> mm_freak: sounds like a lot of people ask here
14:28:32 <mm_freak> DBAlex: you could see if there is a collection of list functions somewhere and add yours to it
14:28:38 <hzap> c_wraith: I guess it's haskell culture to use super short names :D
14:28:41 <jmcarthur> STM is cool, and I've always thought so, but I've never been able to apply it without finding a better way that doesn't use STM.
14:28:43 <DBAlex> if they google'd it and found that page... might help somewhat?
14:29:02 <mm_freak> jmcarthur: that's my point
14:29:15 <mm_freak> STM is a great idea, but i just find a use case for it
14:29:23 <mm_freak> just like arrows
14:29:28 <Berengal> mm_freak: Indeed, message passing often seems like the better choice for concurrent communication
14:29:30 <mm_freak> they sound great, but i just don't use them =)
14:29:38 <hzap> c_wraith: I wonder why it's not just called Semaphore, too
14:29:45 <kmc_> it's not as immediately clear what arrows are good for
14:29:57 <jmcarthur> I've found that in Haskell i don't find myself sharing so much data among many threads as I might in other languages. I can't even think of a good reason besides maybe that I've been trained to better avoid such situations now.
14:30:01 <kmc_> it's clear that lock-based concurrency is a disaster for composability
14:30:02 <MissPiggy> no? :/
14:30:09 <kmc_> and i think anyone who's worked on a big multithreaded system would agree
14:30:12 <c_wraith> hzap: that looks like an appropriate thing for me to change, though, so I shall
14:30:14 <mm_freak> kmc_: after looking at them a lot of times i found that arrows are only good for expressing tuple-handling functions
14:30:32 <mm_freak> seems like there aren't many arrow instances anyway
14:30:46 <jmcarthur> i find more general kinds of arrows a lot more than Control.Arrow
14:30:49 <Berengal> jmcarthur: Perhaps using more threads has something to do with it? There's a lower threshold for spawning of new fire-and-forget threads
14:31:01 <kmc_> there are a lot of categories that aren't Arrows
14:31:24 <mm_freak> jmcarthur: that's because in other languages you use shared data for communication actually…  that shared data is almost always mutable
14:31:27 <jmcarthur> Berengal: perhaps you misinterpreted me. i *don't* use shared data so much
14:31:45 <jmcarthur> or maybe i am misinterpreting you...
14:31:46 <mm_freak> likely that's what the haskell runtime does under the hood as well
14:32:13 <Berengal> jmcarthur: If by shared data you mean references, then I meant that yes, those are reduced. The threads carry the data with it when you spawn it
14:32:16 <c_wraith> jmcarthur: you never find a case where you want to allow multiple network connections to manipulate state in a way that should be visible to all clients?
14:32:30 <Berengal> And since you spawn more in more places you have more data available at the spawn points
14:33:26 <MissPiggy> @keal
14:33:26 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
14:33:27 <MissPiggy> @keal
14:33:27 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
14:33:44 <MissPiggy> @keal
14:33:44 <lambdabot> nsa try kill me numerous times
14:33:46 <MissPiggy> @keal
14:33:46 <lambdabot> i need math friendly compiler to compile for jvm or flash
14:33:46 <Berengal> @faq can haskell pipe the raw irrational megaequation into an analog device
14:33:46 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:48 <MissPiggy> @keal
14:33:48 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
14:34:12 <olsner> MissPiggy: before doing that all night, you might want to start a private chat with lambdabot :P
14:34:22 <jmcarthur> c_wraith: when i do i usually just have what is essentially a single MVar for all the shared state
14:34:36 <MissPiggy> @keal
14:34:36 <lambdabot> with KealDigit quantum crackproof encryption possible
14:34:37 <MissPiggy> @keal
14:34:37 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
14:34:40 <MissPiggy> @keal
14:34:40 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
14:34:51 <mm_freak> c_wraith: i use database threads for that
14:35:02 <mm_freak> like in the code i linked to earlier
14:35:02 <aep> inside an IO Int , how do i call a maybe function so that if it rweturns Nothing, the function imidiatly returns -1  ?
14:35:16 <c_wraith> jmcarthur: So you're not interested in finer-grain control?
14:35:28 <mm_freak> aep: using MaybeT
14:35:37 * aep hoogles
14:35:45 <mm_freak> go to hackage
14:35:50 <mm_freak> find the 'maybet' package
14:35:50 <Berengal> aep: do {...; case maybeFunc foo of Nothing -> return (-1); True -> do ; ... }
14:36:05 <mm_freak> Berengal: as i understand it, he wants a shortcut out of the computation
14:36:07 <aep> Berengal: ah case. thanks
14:36:23 <aep> yeah, i guess the "proper" way is to use some sort of shortcut
14:36:33 <mm_freak> so case works only at the end of the function
14:36:34 <Cale> aep: using case would have been my first answer
14:36:38 <Berengal> mm_freak: MaybeT won't give you that. You need EitherT, which currently has sucky instances
14:36:44 <Cale> case works anywhere.
14:36:47 <kmc_> ContT :D
14:36:48 <aep> i'll go for case, as i understand that :D
14:36:52 <mm_freak> Berengal: why doesn't MaybeT help?
14:36:59 <Berengal> mm_freak: MaybeT won't let you return anything
14:37:03 <jmcarthur> c_wraith: i certainly am. i just haven't needed it
14:37:10 <kmc_> it's important to note (and you quite likely already realize) that "return" does not cause any kind of early-exit
14:37:25 <kmc_> hmm, maybe ContT is not such a crazy suggestion
14:37:31 <mm_freak> Berengal: it lets you return Nothing, so the outer scope which calls runMaybeT can translate it to -1
14:37:39 <Berengal> kmc_: The case version is basically a poor-man's CPS
14:37:41 <Cale> It's not *that* crazy, but it's a little crazy.
14:37:47 <mm_freak> ContT is a good choice, too, but MaybeT is about the most natural solution
14:37:53 <Berengal> mm_freak: True, but it's a one-trick pony
14:38:08 <mm_freak> Berengal: what's a one-trick pony? =)
14:38:15 <Berengal> mm_freak: Only works once
14:38:31 <mm_freak> huh?
14:38:32 <Berengal> mm_freak: You can't decide to return -2 somewhere else
14:38:46 <Cale> aep: btw, you should be certain that you don't really want to produce a Maybe Int as the result of your action.
14:38:50 <aep> in "case maybeFunct of Just -> "  can i destruct the just?
14:38:55 <mm_freak> he wants a shortcut, if an inside Maybe computation results in Nothing
14:39:04 <aep> Cale: yes. it contains data i want to use
14:39:05 <Cale> aep: You need to use Just n -> ...
14:39:09 <mm_freak> that's precisely what the monadic interface to Maybe is good for
14:39:11 <aep> ah that easy, cool
14:39:20 <Cale> aep: Using -1 as a failure value is bad style.
14:39:33 <Cale> Unless -1 is actually really meaningful as a number.
14:39:34 <Berengal> mm_freak: But only if there's only one way to fail
14:39:39 <aep> that was just an example.
14:39:47 <mm_freak> yeah
14:39:50 <mm_freak> otherwise you need Either
14:39:58 <mm_freak> (or something more fancy)
14:40:00 <Berengal> aep: There's also "maybe"
14:40:00 <aep> the actual code is  Either Errno FileStat
14:40:12 <mm_freak> aep: Either a is a monad =)
14:40:32 <Berengal> aep: I'd probably make it IO (Maybe Int) and call it with fmap (maybe (-1) id)
14:40:32 <aep> well   IO (Either Errno FileState) :P
14:40:37 <mm_freak> but it looks like you have an IO computation and i don't know an EitherT implementation
14:40:50 <DBAlex> mm_freak: http://www.haskell.org/haskellwiki/Data.List.Split#Simple_split_at_known_length < I've put it here
14:40:54 <hzap> there's no ErrorT?
14:40:59 <DBAlex> hope that at least helps someone one day... :)
14:41:01 <Berengal> aep: Oh, if you're using that you might want to use ErrorT Errno FileState
14:41:14 <aep> the outer function is   IO (Either Errno FileStat)  and from that i invoke a  Maybe FileStat
14:41:17 <Berengal> ErrorT Errno IO FileState*
14:41:27 <aep> ummm
14:41:35 <Berengal> @unmtl ErrorT a IO b
14:41:36 <lambdabot> IO (Either a b)
14:41:42 <mm_freak> DBAlex: have a look at splitEvery on the same page
14:41:52 <mm_freak> you're reinventing the wheel =)
14:41:57 <aep> i think i'll go for case before my head explodes again
14:42:03 <Berengal> Hehe
14:42:09 <Berengal> @quote transformers
14:42:10 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
14:42:10 <lambdabot> entire human race would have to be rewritten!
14:42:13 <mm_freak> note that almost all list functions you ever write have already been written by someone else ;)
14:42:25 <DBAlex> yeah looks crazy 0_o
14:42:28 <arkleseizure> @pl \ x y -> (Just x, y)
14:42:28 <lambdabot> (,) . Just
14:42:36 <arkleseizure> lolol dammit
14:42:37 <DBAlex> At least it looks simple :)
14:42:39 <mm_freak> aep: my computation would be of type:  MaybeT IO Int
14:42:39 <mm_freak> =)
14:42:42 <Berengal> DBAlex: Learning Haskell is mostly about writing lots of functions, then later discover that they're all in the Prelude
14:42:51 <IceDane> Berengal: so true
14:42:52 <IceDane> lol
14:42:55 <DBAlex> yeah
14:42:56 <mm_freak> (or some other error monad transformer)
14:43:49 <arkleseizure> @pl \ x _ -> (c, x)
14:43:49 <lambdabot> const . (,) c
14:43:53 <mm_freak> DBAlex: honestly i don't know why splitEvery's definition is so complicated
14:43:59 <mm_freak> i'd go with the iterate version
14:44:10 <mm_freak> explicit recursion should only be used if necessary
14:44:33 <DBAlex> yeah of course
14:44:33 <jmcarthur> it ideally should never be necessary unless you are writing a generic fold for some data structure ;)
14:44:41 <dibblego> @remember mm_freak explicit recursion should only be used if necessary
14:44:41 <lambdabot> It is forever etched in my memory.
14:44:44 <DBAlex> explicit recursion is easier for beginnners
14:44:45 <FliPPeh> Can Haskell do something like C can with fork()?
14:44:52 <Berengal> Explicit recursion is almost harder to read that ContT PointLess...
14:44:56 <DBAlex> but your's is a nicer def
14:44:59 <DBAlex> hence the two :)
14:45:00 <FliPPeh> Writing daemons in Haskell would sure be fun
14:45:00 <mm_freak> DBAlex: explicit recursion is ok for beginners =)
14:45:09 <DBAlex> yeah
14:45:10 <mm_freak> DBAlex: and as you go, you'll slowly move away from it
14:45:22 <jmcarthur> FliPPeh: maybe in one of the poxis modules?
14:45:22 <DBAlex> I have moved away from it, just some times I can't think of a nicer way
14:45:29 <DBAlex> but know I've found iterate.. :)
14:45:39 <arkleseizure> FliPPeh: forkIO?
14:45:42 <jmcarthur> FliPPeh: http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/System-Posix-Process.html#v%3AforkProcess
14:45:46 <FliPPeh> Whoo
14:46:00 <jmcarthur> arkleseizure: FliPPeh was talking about forking a new process, i think
14:46:00 <mm_freak> FliPPeh: generally you don't want to fork() in haskell =)
14:46:00 <Berengal> (Does windows have fork()?)
14:46:09 <mm_freak> Berengal: no, but you can approximate it
14:46:10 <jmcarthur> mm_freak: why not?
14:46:27 <kmc_> yes, we'd rather write daemons with multiple threads in a single process
14:46:33 <FliPPeh> "forkProcess  comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent. Another example is the I/O manager thread: since the I/O manager isn't running in the child, attempting to do any Handle-based I/O will deadlock."
14:46:38 <FliPPeh> That's why
14:46:41 <jmcarthur> woah
14:46:43 <mm_freak> jmcarthur: what would that be good for?  haskell has support for threading
14:46:56 <jmcarthur> mm_freak: the point is to put yourself in the background
14:46:57 <mm_freak> the only use case i could think of is switching to daemon mode
14:47:01 <arkleseizure> @pl ( g . (\ f x _ -> f x))
14:47:01 <lambdabot> g . (const .)
14:47:02 <jmcarthur> right
14:47:06 <mm_freak> but i prefer the shell to do that =)
14:47:10 <jmcarthur> do we have a handy way to daemonize?
14:47:14 <mm_freak> or start-stop-whatever
14:47:21 <FliPPeh> But a daemon is about exiting the parent and keep the child running in background!
14:48:05 <arkleseizure> FlipPeh: what are you trying to do with it?
14:48:14 <FliPPeh> Just for information, arkleseizure
14:48:17 <mm_freak> FliPPeh: a lot of server programs come with self-daemonizing, but that's actually just convenience functionality
14:48:20 <arkleseizure> if you just need vanilla concurrency or parallelism there are much more Haskellish, pretty ways
14:48:36 <jmcarthur> you don't want to run mydaemon & just to find that it exits when you close the shell you ran it in
14:48:45 <mm_freak> FliPPeh: in general it's better to do that from the outside, using the shell, using svscan or using start-stop-daemon
14:48:59 <mm_freak> jmcarthur: good point
14:49:18 <jmcarthur> screen would work, but that's a hack
14:49:25 <mm_freak> indeed, there is no useful way to daemonize in haskell
14:49:33 <Berengal> nohup
14:49:35 <Berengal> or disown
14:49:38 <FliPPeh> Note for Haskell 2012 :)
14:49:50 <mm_freak> however, i still think it's not absolutely necessary
14:49:52 <FliPPeh> Can't wait longer, the world is gonna end.
14:50:04 * Berengal also thinks Haskell has done well in demonizing mutable state
14:50:11 <kmc_> :)
14:50:14 <DBAlex> Hmm
14:50:18 <kmc_> too well...
14:50:19 <mm_freak> you should use stuff like start-stop-daemon
14:50:25 <DBAlex> That multicore lecture looks interesting
14:50:26 <mm_freak> if you need monitoring, use svscan
14:50:29 <kmc_> now there is this myth that "haskell can't do state"
14:50:36 <DBAlex> Does RWH have multi-core examples?
14:50:46 <kmc_> it has multithreaded examples
14:50:57 <kmc_> whether they run on multiple cores is just a question of what command line arguments you pass to your program
14:51:04 <kmc_> to whit, +RTS -Nn
14:51:04 <DBAlex> ok
14:51:06 <DBAlex> nice
14:51:07 <kmc_> will use n cores
14:51:09 <jmcarthur> haskell is one of the few languages that actually allows you to control state explicitly
14:51:09 <kmc_> (n OS threads that is)
14:51:10 <mm_freak> DBAlex: OS multithreading is something implicit in haskell
14:51:18 <Berengal> kmc_: It can't, but neither can anything else: State is an illusion brought to us by our alien robot overlords! Fight the powah! Take the red pill!
14:51:24 <DBAlex> Apparently someone has RWH on permanent loan at the library
14:51:31 <DBAlex> Never seems to be available -_-
14:51:35 <mm_freak> DBAlex: you use parallelism constructs or concurrency, then your code will magically become multithreaded
14:51:37 <kmc_> the universe is a single unchanging configuration in four-dimensional minkowski space
14:52:20 <mm_freak> DBAlex: well, buy it =)
14:52:23 <ddarius> Yay Minkowski space!
14:52:27 <DBAlex> mm_freak: I could
14:52:38 <DBAlex> mm_freak: probkem is it's allways 20 quid on amazon
14:52:47 <Berengal> One nice thing about the Haskell threading model is that there's not neccessarily any correlation between the threads in the code and the threads in the running process
14:52:48 <DBAlex> maybe I should just stop being so cheap... :-P
14:52:53 <mm_freak> hehe
14:52:58 <Berengal> @where RWH
14:52:58 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:52:59 <kmc_> DBAlex: it's free online
14:53:03 <DBAlex> yeah
14:53:08 <DBAlex> I even PDF'ed that copy
14:53:13 <kmc_> do you have an employer or school with a printer? ;)
14:53:16 <DBAlex> I just like physical books
14:53:25 <DBAlex> hehe good plan...
14:53:32 <mm_freak> kmc_: i prefer real books =)
14:53:41 <DBAlex> I have a lot of print credits... plus theres a duplex printer that only charges per page
14:53:48 <DBAlex> if I had 2 pages per side...
14:53:57 <kmc_> i don't, for computer stuff.  you want to be playing with GHCi while you read RWH
14:53:58 <DBAlex> Hmm
14:54:11 <DBAlex> Maybe i'll be staying late at the lab this week... :p
14:54:12 <kmc_> balancing a book and laptop is harder
14:54:15 <kmc_> plus books aren't searchable
14:54:20 <Philonous> kmc_: Even than, having a dead tree copy saves screen space
14:54:25 <tensorpudding> can you have a case statement in a do block?
14:54:31 <kmc_> i can change workspaces in milliseconds...
14:54:34 <kmc_> tensorpudding: yes
14:54:41 <kmc_> "case" is not a statement, it's an expression
14:54:49 <mm_freak> kmc_: yes, but somehow books have this strange appeal
14:54:51 <kmc_> and all three forms of "do"-statement contain an expression
14:55:04 <jmcarthur> books have better resolution
14:55:04 <Berengal> tensorpudding: case statements are expressions like everything else. Just watch out for the indentation, as with all indentation-aware expression sytaxes
14:55:18 <gwern> hm
14:55:19 <tensorpudding> i'm not sure why this code is failing
14:55:19 <jmcarthur> and, not being backlit, are much easier on the eyes
14:55:20 <kmc_> > do { x <- [1,2,3]; return (case x of { 1 -> 4; _ -> x }) }
14:55:22 <lambdabot>   [4,2,3]
14:55:24 <mm_freak> it's more about aesthetics that about practicality for me
14:55:26 <gwern> regex-base fails with dynamic linking
14:55:27 <gwern> '/usr/bin/ld: cannot find -lHSmtl-1.1.0.2-ghc6.12.1
14:55:28 <DBAlex> brb, beer
14:55:33 <kmc_> sad
14:55:34 <tensorpudding> oh wait, suddenly it works
14:55:35 <kmc_> beer++
14:55:38 <kmc_> @karma beer
14:55:38 <lambdabot> beer has a karma of 12
14:55:40 <kmc_> preflex: karma beer
14:55:40 <preflex>  beer: 23
14:55:42 <tensorpudding> must have been indentation problems
14:55:59 <gwern> @ask dcoutts do you know why regex-base on 6.12 would fail when --enable-share, saying '/usr/bin/ld: cannot find -lHSmtl-1.1.0.2-ghc6.12.1
14:55:59 <lambdabot> Consider it noted.
14:56:06 <kmc_> tensorpudding: you aren't using tabs are you? ;)
14:56:25 <gwern> @ask dcoutts also, why does the cabal-install bootstrap not install profiling of those basic libraries? 'twere tedious to --reinstall upon error
14:56:25 <lambdabot> Consider it noted.
14:56:31 <tensorpudding> i use tabs as spaces
14:56:45 <Berengal> Haha
14:57:10 <kmc_> then every space is 8 spaces so problem solved ;)
14:57:14 <gwern> spaces are my anti-tab
14:57:35 <tensorpudding> as in, the tab key produces spaces instead of tabs
14:57:39 <Berengal> backspace is my anti-tab...
14:57:41 <tensorpudding> and emacs handles indentation pretty well
14:57:52 <Berengal> cotab
14:58:04 <aep> is a case alternative another monad? "return $ Left foo" works fine outside the case, but inside it complains that the types dont match (comparing what the outer function retuerns and what is after return$)
14:58:30 <Berengal> aep: Nope, case is just a normal expression. You must be doing something else wrong
14:58:33 <gwern> hm. dynamic linking contaminates everything that wants it? apparently you can't build dynamically any library which was built staticaly
14:58:42 <aep> hmm probably indention again :/
14:58:48 <gwern> dammit I hate that in profiling I am no happier about it with dynamic linking
14:59:00 <p_l> gwern: explain?
14:59:01 <aep> it completely ignores the return. i tried all sorts of parantheses
14:59:07 <DBAlex> kmc_: what's wrong with beer? :P
14:59:18 <kmc_> sad was about regex-base not beer
14:59:21 <Berengal> gwern: rm -rf ~/.cabal/lib
14:59:23 <kmc_> i then said beer++
14:59:25 <DBAlex> ah right
14:59:27 <DBAlex> :P
14:59:39 <gwern> p_l: I had to build regex-base stiatically since --enable-share crasjes on ld; but now regex-posix crashes when built with --enable-sare
14:59:56 <DBAlex> preflex: karma beer
14:59:56 <preflex>  beer: 24
15:00:03 <DBAlex> preflex: karma haskell
15:00:03 <preflex>  haskell: 25
15:00:10 <Berengal> gwern: Wait, does regex-base have TH, and do you build documentation?
15:00:13 <DBAlex> preflex: karma karma
15:00:13 <preflex>  karma: 10
15:00:14 <gwern> Berengal: why would that help? if regex-base fails it fails
15:00:17 <Pete1> Hello when writing instance Monad MyMonad where .... with MyMonad a I want to make so a is showable. Can I write something like (Show a) => to make so. I don't know where to put it.
15:00:20 <DBAlex> preflex: karma whore
15:00:20 <preflex>  whore has no karma
15:00:26 <DBAlex> hehe
15:00:29 <Berengal> gwern: I misunderstood the problem
15:00:30 <gwern> Berengal: I have documentation: True, in my .cabal/config
15:00:34 <gwern> yes
15:00:44 <gwern> dunno about regex-base and th; I would be surprised if it did
15:00:48 <mm_freak> Pete1: i'm not sure if i understand your question, but yes
15:00:55 <mm_freak> instance Show a => Show (MyMonad a) where …
15:01:01 <Berengal> gwern: Try building it without documentation, see if that works
15:01:10 <DBAlex> preflex: karma karma karma karma chameleon
15:01:10 <preflex>  karma karma karma chameleon has no karma
15:01:19 <DBAlex> :(
15:01:28 <p_l> gwern: well, you could in theory link a static library into a dynamic one (which probably isn't done by default)
15:01:29 <Berengal> gwern: Are you aware of the haddock-rebuilding-objects-causes-new-TH-names-and-link-failure bug?
15:01:37 <gwern> Berengal: erm. what?
15:02:02 <IceDane> foldl is (a -> b -> a) -> a -> [b] -> a. foldM is (a -> b -> m a) -> a -> [b] -> m a.. So, if i'm using foldl like this: foldl foldingFunction [] someList, then a is a list and b is someList, yes? If I want to modify it to use foldM, its foldingFunction returns m a, should it then return m list ? I hope this makes sense, heh.
15:02:08 <IceDane> As opposed to [m a]
15:02:24 <Berengal> gwern: Haddock rebuilds the objects, reruns TH, and causes new random names to be generated, which causes objects linking to the haddocked TH objects to fail in their linking because the interfaces don't match
15:02:34 <gwern> setting to to false doesn't seem to help
15:02:41 <Berengal> gwern: Although it shouldn't build statically either then
15:02:52 <Berengal> (Except it did for me once, then segfaulted...)
15:02:53 <aep> any idea what i'm doing wrong in the case here? http://codepad.org/NMJ3Q8LJ
15:02:56 <gwern> right after a warning on module 4, Text.Regex.Base.Impl, it errors the same way
15:03:09 <aep> err, wrong paste
15:03:12 <Berengal> Then it's a different bug
15:03:25 <aep> there it is http://codepad.org/MqUNo6rS
15:03:30 <mm_freak> IceDane: foldM expects the result of the folding function itself be wrapped
15:03:43 <Cale> IceDane: yes
15:03:58 <mm_freak> > foldM (\x y -> [x+y, x-y]) 0 [1..4]
15:03:59 <lambdabot>   [10,2,4,-4,6,-2,0,-8,8,0,2,-6,4,-4,-2,-10]
15:04:21 <Berengal> aep: What type does ipcfsFindNode have?
15:04:26 <mm_freak> since the list monad is non-determinism it computes all possible paths, of whic there are 16 in this case
15:04:35 <IceDane> mm_freak: Yes, I get that, I think
15:04:44 <aep> Berengal: ipcfsFindNode :: String -> IpcfsNode -> IO (Either Errno IpcfsNode)
15:04:58 <Pete1> ﻿mm_freak: The thing is I get some errors and it says Possible fix: add(Show a, Read a) to the context of the type signature '>>='
15:05:01 <IceDane> Cale: So this means that foldingFunction, if a starts out as an [], should be m [a], 'basically' ?
15:05:05 <Berengal> aep: There's your problem. Left is an Either constructor, not an IO constructor :)
15:05:10 <IceDane> I know my explanation might be strange
15:05:21 <Berengal> aep: So you can't use it to match an IO value
15:05:25 <aep> Berengal: thats why i wrap it in return
15:05:42 <aep> err
15:05:43 <Berengal> aep: No you don't. You can't wrap patterns
15:05:45 <aep> aah!
15:05:47 <Berengal> aep: I'm talking about the other left
15:05:57 <aep> thanks
15:06:31 <Berengal> x <- fooThatReturnsIO; case x of <stuff>
15:06:43 <aep> yeah
15:06:48 <aep> works :)
15:07:00 <mm_freak> > foldM (return . (+)) 0 [1..10]
15:07:01 <lambdabot>   {-3->-30;-2->-20;-1->-10;0->0;1->10;2->20;3->30}
15:07:06 <mm_freak> uhm
15:07:18 <mm_freak> > foldM (\x y -> [x+y]) 0 [1..10]
15:07:19 <lambdabot>   [55]
15:07:36 <mm_freak> > foldM (\x y -> [x+y, x*y]) 0 [1..10]
15:07:37 <lambdabot>   [55,450,334,3240,243,2330,2026,20160,174,1640,1405,13950,1195,11850,10594,1...
15:08:05 <mm_freak> > foldM (\x y -> Just (x+y)) 0 [1..10]
15:08:06 <lambdabot>   Just 55
15:08:11 <mrshoe> is there a simple rule of thumb for knowing when tail call otimization will be used and when it won't?
15:08:12 <mm_freak> > foldM (\x y -> Nothing) 0 [1..10]
15:08:13 <lambdabot>   Nothing
15:08:27 <Berengal> > foldM (\x y -> [x+y, x*y]) x [a,b,c,d]
15:08:28 <lambdabot>   [x + a + b + c + d,(x + a + b + c) * d,(x + a + b) * c + d,(x + a + b) * c ...
15:08:34 <Chaze> everytime I write a few lines of haskell I think "This must have a name and is probably built-in" :)
15:08:34 <Chaze> so what about this thing i called "combinations"? http://pastie.org/821025
15:08:54 <copumpkin> > replicateM 2 "01"
15:08:55 <lambdabot>   ["00","01","10","11"]
15:09:02 <mm_freak> Chaze: that's because you're forgetting that _you_ are the programmer ;)
15:09:07 <Twey> > sequence "01"
15:09:07 <lambdabot>   Couldn't match expected type `m a'
15:09:08 <lambdabot>         against inferred type `GHC.Types...
15:09:16 <Twey> Oh
15:09:20 <mm_freak> > sequence ["ab", "cd"]
15:09:21 <lambdabot>   ["ac","ad","bc","bd"]
15:09:25 <Twey> Yeah
15:09:31 <Chaze> Cheers, guys ;)
15:09:35 <copumpkin> > sequence (replicate 2 "01")
15:09:36 <lambdabot>   ["00","01","10","11"]
15:09:37 <Twey> replicateM = (sequence .) . replicate
15:09:38 <Twey> Of course
15:09:50 <mm_freak> > filterM (const [True, False]) "123"
15:09:51 <lambdabot>   ["123","12","13","1","23","2","3",""]
15:10:46 <mm_freak> Chaze: really i know that feeling…  haskell makes it almost too easy…  so easy that you always think there is some easier way
15:10:53 <Berengal> Has anybody ever used filterM for anything but powerset?
15:10:59 <kmc_> prolly
15:11:27 <mm_freak> Berengal: i remember using it sometimes in IO
15:11:30 <mm_freak> just like foldM
15:11:40 <Berengal> I can see that
15:11:56 <IceDane> mm_freak: http://codepad.org/cb1ieeg9 If you take a look at this, this is essentially what i'm trying to modify to use monads. As you can see, when reads can't parse, it return Nothing. I want to use foldM to return nothing for 'the whole list' if one of those can't be parsed. It's to be used in an RPN calculator.
15:11:57 <Chaze> Berengal: hah, that's what it's all about? I kept my distance from monad stuff I don't understand yet, but I can surely use a powerset :p
15:12:42 <Berengal> Chaze: filterM (const [True, False]) is the powerset function, but filterM is more general than that
15:12:51 <mm_freak> IceDane: doesn't look like it needs a monad
15:13:17 <kmc_> e.g. to filter a list of files according to their stat() results
15:13:29 <mm_freak> yeah
15:13:30 <c_wraith> if I have a program that (transitively) depends on incompatible versions of quickcheck, is there any way to tell the package to install anyway?
15:13:42 <FliPPeh> :t timesDo
15:13:43 <lambdabot> Not in scope: `timesDo'
15:13:47 <mm_freak> i used stuff like:  files <- filterM doesFileExist dirEntries
15:13:56 <c_wraith> I'm not going to be using an quickcheck code in either of the dependencies
15:13:58 <c_wraith> *any
15:13:59 <mm_freak> FliPPeh: you mean replicateM?
15:14:04 <mm_freak> :t replicateM
15:14:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:14:18 <FliPPeh> mm_freak: Yup ;D
15:14:21 <Berengal> c_wraith: I'm not sure if that's possible without some black voodoo
15:14:23 <FliPPeh> Missed the definition
15:14:25 <IceDane> mm_freak: The thing is, if Nothing gets put in the list once, it will be passed to my evaluation function(that evalulates the RPN expression) and that would require checking at every turn to see if it was Nothing
15:14:28 <mm_freak> FliPPeh: replicateM_, if you don't need the results =)
15:14:30 <IceDane> Am I right in thinking that?
15:14:38 <FliPPeh> Currently playing with forkIO and STM
15:14:40 <mm_freak> IceDane: catMaybes
15:14:44 <FliPPeh> I still don't get the concept of STM
15:14:55 <mm_freak> :t catMaybes
15:14:56 <lambdabot> forall a. [Maybe a] -> [a]
15:14:59 <FliPPeh> Is it like a mutable "variable" or like a message channel?
15:15:01 <Berengal> c_wraith: You might be able to link the libraries separately, or reinstall one of them with the other version as a dependency
15:15:21 <mm_freak> FliPPeh: whatever you need
15:15:25 <c_wraith> Berengal: I can't even figure out why cabal thinks quickcheck is a dependency of one of them.
15:15:26 <FliPPeh> Or like a socket?
15:15:30 <mm_freak> FliPPeh: have you played with concurrency already?
15:15:36 <FliPPeh> Not in Haskell
15:15:41 <FliPPeh> But Threads in other languages
15:15:45 <mm_freak> then do that first, before trying out STM =)
15:15:52 <kmc_> FliPPeh: STM is a mechanism for working with variables, channels, and other stuff
15:15:56 <Berengal> c_wraith: Shouldn't that be in its cabal file?
15:15:58 <kmc_> in such a way that you don't need explicit locks
15:16:04 <FliPPeh> But threads without any communication to the outside world are rather.. useless :(
15:16:11 <mm_freak> basically STM adds transactions and waiting for multiple events in the same thread
15:16:12 <kmc_> you just say "atomically $ do { ... stuff ... }", and that stuff will happen atomically
15:16:19 <c_wraith> Berengal: I changed the cabal file to never mention quickcheck, and cabal refused to stop thinking that package depended on it
15:16:23 <kmc_> FliPPeh: RWH has a great intro both to STM and to concurrency in Haskell in general
15:16:25 <FliPPeh> What does "atomically" mean anyways?
15:16:29 <FliPPeh> I see it popping up a lot
15:16:31 <kmc_> FliPPeh: all-or-nothing
15:16:32 <FliPPeh> :x
15:16:33 <IceDane> mm_freak: Wow, thanks. That seems to be something I could use
15:16:35 <FliPPeh> Ah nice
15:16:40 <kmc_> another thread can't see the steps "in progress"
15:16:47 <kmc_> and they can't go partway then fail
15:17:01 <FliPPeh> So if it happens, it happens at once
15:17:01 <mm_freak> FliPPeh: read "atomically" as "run this STM computation" =)
15:17:06 <FliPPeh> And if it fails, nothing has been changed?
15:17:19 <Berengal> c_wraith: copy the source, rewrite the cabal, change the name... locating the source of that dependency is most likely the easiest way
15:17:28 <kmc_> STM is a good example of why monads are a powerful abstraction for imperative programming, and not merely a way of re-adding side effects to functions
15:17:35 <kmc_> FliPPeh: yeah
15:17:36 <mm_freak> FliPPeh: to "fail" means not to happen
15:17:44 <mm_freak> in the context of STM
15:17:48 <FliPPeh> :)
15:17:55 <FliPPeh> I should read RWH more often
15:17:59 <FliPPeh> But it's so fast moving...
15:17:59 <Berengal> FliPPeh: STM doesn't fail, but it might diverge
15:18:02 <ozataman> Hey all, what's the best library to parse json data?
15:18:28 <Berengal> That is, "atomically" only returns when it's successful
15:18:45 <Berengal> (But it might be "successful" with an empty result, if you want it to)
15:18:49 <kmc_> but you can also do choice in STM, meaning "try this one, but if it fails try something else"
15:18:52 <kmc_> try this once*
15:18:57 <c_wraith> `orElse` return ()
15:19:03 <mm_freak> rather like:  try whatever happens first
15:19:07 <MissPiggy> is STM slow
15:19:11 <FliPPeh> Looks like I should have a glance soon :)
15:19:19 <FliPPeh> When I'm back from my vacation
15:19:22 <kmc_> FliPPeh: another great intro is http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf
15:19:26 <FliPPeh> Some ski fun.
15:19:33 <mm_freak> MissPiggy: it's slower than the non-transactional concurrency stuff, but fast enough for almost any purpose
15:19:33 <Berengal> MissPiggy: I think it's slower than MVars in general, and can be really slow with lots of contention going on
15:19:43 <kmc_> a short paper (book chapter actually), designed for people with no Haskell knowledge (so you're well ahead of the curve)
15:20:12 <kmc_> the key advantage of STM over locking is that STM is more composable
15:20:32 <c_wraith> Is there any way to get cabal (or ghc-pkg) to dump a dependency list for an installed package?
15:20:38 <kmc_> there's a straightforward way to glue two atomic STM actions together to make one atomic STM action
15:20:41 <copumpkin> preflex: seen mmorrow
15:20:41 <preflex>  mmorrow was last seen on #ghc 24 days, 20 hours, 22 minutes and 56 seconds ago, saying: * mmorrow is rtfm'ing
15:20:44 <kmc_> which is simply (>>) (or the "do" sugar, etc)
15:20:46 <copumpkin> damn! where'd he go!
15:20:55 <Berengal> It doesn't support locking natively, but that's easy to emulate (with either flags or TMVars)
15:20:56 <xerox> the fm is very long
15:21:02 <mm_freak> kmc_: that's the big problem i have with STM
15:21:14 <mm_freak> i don't find use cases for it, because i don't find any locks in my code =)
15:21:21 <kmc_> heh
15:21:23 <kmc_> that's good then
15:21:37 <kmc_> it probably says something about the kind of software you write as well as how you design it
15:21:44 <Ziphilt> hello everyone
15:21:50 <kmc_> certainly a lot of things that would use locks and multithreading in C++ don't even have explicit threads in Haskell
15:21:55 <Berengal> Ziphilt: Hello :)
15:21:56 <kmc_> hi Ziphilt
15:22:00 <mm_freak> yeah
15:22:04 <kmc_> welcome to the world of tomorrow
15:22:06 <Ziphilt> i am greatly interested in learning Haskell
15:22:18 <Ziphilt> i am unsure of where to learn from
15:22:21 <kmc_> @where LYAH
15:22:22 <lambdabot> http://www.learnyouahaskell.com/
15:22:22 <kyagrd> Ziphilt: Buy "Programming in Haskell"
15:22:22 <kmc_> @where RWH
15:22:23 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:22:26 <mm_freak> laziness helps a lot here
15:22:27 <Ziphilt> i have read most of Learn you a Haskell
15:22:28 <FliPPeh> LYAH is great
15:22:37 <FliPPeh> RWH is just too fast for me :(
15:22:41 <Ziphilt> and have tried to start RWH
15:22:43 <Berengal> @quote #haskell
15:22:43 <lambdabot> Botje says: "Welcome to #haskell, we ♣ imperative programmers"
15:22:48 <kmc_> hehe
15:22:57 <mm_freak> Ziphilt: if you don't mind a quite dry introduction, you can learn from YAHT, too
15:23:00 <Berengal> Not quite the quote I was hoping for, but good enough
15:23:10 <kmc_> @quote mutant
15:23:10 <lambdabot> kmc_ says: agda is super mutant haskell
15:23:14 <kmc_> heh me either
15:23:27 <Berengal> @quote degree.granting
15:23:27 <lambdabot> sioraiocht says: maybe we should make #haskell a degree granting institution
15:23:41 <mm_freak> there is TMNT and AGDA
15:23:50 <mm_freak> but i don't know what AGDA means =)
15:24:11 <Ziphilt> also, i was thinking maybe i should learn pure lisp first
15:24:23 <mm_freak> btw, i found that i can implement most use cases of dependent types in haskell
15:24:27 <Ziphilt> i have been finding books on Scheme
15:24:37 <Ziphilt> what are your thoughts on that?
15:24:38 <mm_freak> Ziphilt: i'd prefer haskell
15:24:44 <Berengal> Ziphilt: Haskell and Lisp are pretty different. It doesn't matter much which order you learn them in
15:24:58 <mm_freak> there is a lazy scheme (part of PLT scheme), but it's not anywhere near haskell
15:25:09 <kmc_> yes, they're very different
15:25:27 <kmc_> you will need to be comfortable with first-class functions to use either language effectively
15:25:36 <kmc_> but it's only a beginner concept in both
15:25:43 <kmc_> and they diverge quite strongly on most more advanced ideas
15:25:48 <mm_freak> my personal opinion (after evaluating scheme, clisp, erlang and (a tiny fraction of) ocaml), i think that haskell is the best choice
15:25:50 <p_l> there are also lazy libraries for CL etc. I personally recommend learning both (and I think I'd recommend CL over Scheme)
15:26:00 <mm_freak> and in fact i wouldn't even start learning the others, before i learned haskell
15:26:03 <Saizan> lisp tutorials will teach you how to use parentheses though :)
15:26:17 <Alpounet> and most importantly how to indent them.
15:26:18 <Berengal> Saizan: s/use/abuse/
15:26:22 <kmc_> @where sicp
15:26:22 <lambdabot> http://mitpress.mit.edu/sicp/
15:26:38 <Ziphilt> yes, i have looked at SICP
15:26:45 <mm_freak> p_l: personally i found scheme better than clisp
15:26:48 <kmc_> i recommend Scheme over Lisp
15:26:52 <kmc_> it's just cleaner and simpler
15:26:54 <Ziphilt> apparently HtDP is better?
15:27:04 <mm_freak> clisp is not that functional
15:27:05 <kmc_> SICP is a classic
15:27:07 <kyagrd> Ziphilt: HTDP is for programming beginners
15:27:25 <kyagrd> SICP is also for programming beginners but much more hardcore :)
15:27:29 <Ziphilt> yes, SICP has the "crazy difficult" stiff
15:27:32 <Ziphilt> *stuff
15:27:35 <Ziphilt> whoops
15:27:39 <Ziphilt> >_>
15:28:03 <Ziphilt> should i bother reading HTDP first?
15:28:34 <medfly> I plan to read both
15:28:35 <Saizan> does SICP cover delimited continuations?
15:28:37 <medfly> when I stop procrastinating
15:28:53 <aep> is there a function to split a string by a specified delimiter?
15:28:54 <Berengal> I recommend writing Game of Life, then take a look at Project Euler, implement an IRC bot, write a Scheme compiler and as a final rite, write a monad tutorial. Intersperse with tutorials and books as needed, and keep a window to #haskell open
15:28:57 <medfly> I have a lot of plans for then
15:29:03 <mm_freak> Ziphilt: really, if you want to learn haskell and lisp, learn haskell first
15:29:12 <Ziphilt> okay
15:29:13 <Saizan> aep: in the split package
15:29:14 <mm_freak> knowing lisp you will have a harder time stepping into haskell
15:29:26 <aep> Saizan: thanks
15:29:26 <mm_freak> but knowing haskell, it should be easy to step ("back") to lisp
15:29:28 <Ziphilt> why is that?
15:29:47 <kyagrd> Ziphilt: cause lisp doesn't have static types
15:29:48 <kmc_> uh, i don't agree
15:29:53 <mm_freak> Ziphilt: you may want to read this:  http://www.newartisans.com/2009/03/hello-haskell-goodbye-lisp.html
15:29:58 <kyagrd> and currying is not default either
15:30:00 <Zao> Or even better, after learning Haskell, not caring about Lisp at all.
15:30:03 <Ziphilt> Berengal, are you talking to me?
15:30:22 <Berengal> Ziphilt: Yes, but also to a general audience.
15:30:43 <Berengal> Everyone were shouting out their recommendations, so I thought I'd join the choire :)
15:30:44 <Ziphilt> i agree with that schedule of projects
15:30:46 <mm_freak> Zao: it's ok to learn lisp, because it's _the_ DSL language family
15:30:51 <mm_freak> particularly clisp
15:31:08 * Berengal learns the most from doing, not reading
15:31:11 <pflanze> Is there an operator to check for ranges? Like  10 < x < 100.
15:31:11 <FliPPeh> :t newEmptyMVar
15:31:12 <lambdabot> Not in scope: `newEmptyMVar'
15:31:15 <p_l> mm_freak: First of all, I didn't recommend CL for being functional - it's definitely multiparadigm, and less fragmented than Scheme.
15:31:18 <kmc_> writing effective LISP will require you to learn things you don't learn in Haskell
15:31:28 <kmc_> precisely because it doesn't have static types or algebraic data
15:31:36 <Berengal> pflanze: No, but you can write one
15:31:38 <Alpounet> pflanze, I often define something like :
15:31:47 <p_l> kmc_: and macros :)
15:32:10 <Ziphilt> lisp is the one with macros, correct?
15:32:11 <Alpounet> > let between x (a, b) = a < x && x < b in 10 `between` (1, 340)
15:32:12 <lambdabot>   True
15:32:17 <mm_freak> pflanze: 10 < x && x < 100
15:32:21 <Berengal> writing macros in Haskell will require you to learn things you don't learn in Lisp, because haskell doesn't have a homoiconic representation
15:32:25 <kmc_> Ziphilt: LISP and Scheme both have macros and encourage their use pervasively
15:32:38 <kyagrd> template haskell dose some things but not as flexible as macros in lisp
15:32:45 <Cale> I actually found Common Lisp to be really really annoying to try to program in, in a functional style.
15:32:51 <kmc_> Berengal: i don't entirely agree.  the fundamental sort of data in Haskell is the algebraic data type, so it's sort of homoiconic
15:32:57 <kmc_> Ziphilt: LISP and Scheme macros are rather different
15:33:00 <mm_freak> p_l: i don't know what you mean by "fragmented"
15:33:07 <Berengal> Cale: I know, right? Whoever thought separate namespaces was a good idea...
15:33:16 <Cale> yeah, it's a mess
15:33:21 <kmc_> Ziphilt: Many other languages, including Haskell, also have macros, but most of them encourage other forms of abstraction and use them as a "last resort"
15:33:23 <Cale> Scheme is a heck of a lot better for that reason.
15:33:25 <mm_freak> unlike CL, scheme is a simple, fully defined language, while CL is somewhat made of macros
15:33:58 <Cale> You can use functions as values without needing to use funny quotes and call apply explicitly, etc.
15:34:01 <Ziphilt> i am hearing a lot that says that either CL or Scheme is better
15:34:11 <mm_freak> Cale: a number of people say that CL is mainly imperative
15:34:27 <kmc_> Ziphilt: learn them both!
15:34:28 <mm_freak> in general you use loop instead of a list map in CL
15:34:30 <Cale> CL is probably fine if you don't care to write your programs in a functional style.
15:34:32 <Ziphilt> may as well
15:34:35 <p_l> mm_freak: There's RxS, but I got lost few times in differences between implementations (thank god for SRFI). CL got ANSI CL. And it's working in the style you write it (though imperative might be easier for beginner)
15:35:11 <Berengal> CL has good support for functional programming compared to imperative programs (even python and javascript, which have decent support), but still pales in comparison to real functional languages
15:35:13 <p_l> mm_freak: Since advanced user of CL can just turn it into language he wants, really. At what point you rename it, I don't know
15:35:26 <Berengal> s/programs/languages/
15:36:03 <mm_freak> p_l: of course, CL is a great language, if you love DSLs
15:36:29 <p_l> well, CL is kinda "compromise" between different implementations. Haskell got fresh start allowing a language greatly suited for FP.
15:36:31 <Berengal> mm_freak: LISP without DSLs would be like assembly without macros...
15:36:36 <Ziphilt> so now that i plan to learn both CL and Scheme after Haskell, is there a recommended order to learn /those/?
15:36:42 <p_l> mm_freak: the question is, when do you call it DSL or not
15:36:52 <Cale> Ziphilt: I'd say start with scheme.
15:36:55 <Berengal> Ziphilt: Practical Common Lisp is decent enough, and SICP
15:37:02 <mm_freak> Berengal: CL goes beyond that, i think
15:37:21 <mm_freak> p_l: well, you're making a general purpose out of lots of DSLs
15:37:25 <mm_freak> +language
15:37:26 * p_l for long time tried to start with Scheme due to the "cleaner design", ended up reading PCL and giving up on Scheme
15:37:27 <Cale> SICP and HTDP both use Scheme, and they're good places to learn programming in general.
15:37:35 <mm_freak> Ziphilt: i'd say start with haskell =)
15:37:53 <mm_freak> really, haskell is very diffierent from lisp languages
15:37:55 <Ziphilt> yes, we established that mm_freak :)
15:37:57 <Cale> p_l: How can you stand the irritating namespace split for functions?
15:38:04 <p_l> Also, I consider CLOS awesome, even if its imperative :P
15:38:05 <winxordie> Learn Scheme in fixnum days is pretty good if you're looking for a Scheme tutorial.
15:38:12 <p_l> Cale: I barely notice it, frankly speaking
15:38:24 <mm_freak> Ziphilt: sorry =P
15:38:37 <Berengal> Some people claim to like it because they can have a variable called "list"... Why, I wonder... why?
15:38:59 <Cale> I spent practically the entire time I spent programming in CL banging my head against it, and the fact that the list library seemed to be missing a lot of basic things.
15:39:01 <p_l> Cale: I got more problems with knowing when the code I'm writing is executed :)
15:39:40 <Berengal> Once you know Haskell and CL, Scheme is pretty easy to pick up
15:39:51 <Ziphilt> okay, so what do you all think of ML/Caml/OCaml?
15:39:55 <Berengal> I don't know about how Haskell + Scheme -> CL
15:39:59 <mm_freak> Cale: that's because you wouldn't do things with list processing functions, but rather with loops
15:40:38 <Berengal> Ziphilt: We're friends.
15:40:38 <mm_freak> IMO scheme, CL and haskell are three different worlds
15:40:39 <p_l> Cale: unfortunately, SERIES didn't make it into ANSI (though it was at some point there, I think)
15:40:53 <winxordie> Alice ML had some cool features that I kinda miss. I never tried the xCaml series out.
15:41:04 <mm_freak> winxordie: like what?
15:41:29 <mm_freak> Berengal: once you learned haskell and scheme, CL is going to annoy you
15:41:39 <mm_freak> likely
15:41:50 <winxordie> Berengal: futures and pickling. maybe I haven't seen them in haskell yet.
15:41:54 <Ziphilt> i have read that OCaml can compile to code that can sometimes surpass C in speed, while remaining a functional language
15:41:58 <Ziphilt> that interested me
15:42:15 <Berengal> mm_freak: CL annoyed me a bit, coming from Haskell, but macros were fun
15:42:18 <MissPiggy> unfortunately?
15:42:22 <MissPiggy> who cares
15:42:26 <winxordie> Ziphilt: So ATS and Gambit-C make the same claim
15:42:31 <MissPiggy> there's a decent working lib you can USE
15:42:36 <winxordie> *I meant mm_freak not Berengal, my bad. :)
15:43:12 <Ziphilt> winxordie, do you imply that they are incorrect in that claim?
15:43:38 <p_l> so do some CL implementations - with benchmarks etc. I find it's more about the code you write, not the language
15:43:52 <Twey> 23:37:41 < Cale> p_l: How can you stand the irritating namespace split for functions?
15:44:07 <mm_freak> winxordie: could you give my pointers?  i don't know what futures and pickling are
15:44:09 <Twey> If it were up to me, and at all feasible, I'd allocate a separate namespace for every type
15:44:12 <mm_freak> my → me
15:44:23 <winxordie> Ziphilt: It's not the case. I only claim that 'beating C' in speed is not really the most important part. Code expression is a bit more important than pure run speed
15:44:26 <medfly> wow, Cale was annoyed by something
15:44:34 <Twey> Hehe, I know!
15:44:37 <Berengal> Twey: Why? So you could name everything x?
15:44:37 <aep> is there something that runs a computation on each member of a list which can return "fail completely"  "try the next one"  and "found it, return this value"  ?
15:45:04 <mm_freak> medfly: Cale is a haskell programmer
15:45:11 <Berengal> aep: foldr
15:45:14 <mm_freak> naturally he's annoyed by a lot of things ;)
15:45:14 <Twey> Berengal: Yes.  :þ
15:45:24 <Ziphilt> winxordie, i agree that the code readability and expression power is more important than pure speed
15:45:34 <mm_freak> aep: foldM
15:45:41 <Berengal> Twey: That's horrible!
15:45:43 <medfly> the key sentence here is
15:45:46 <medfly> DEPENDS FOR WHAT PURPOSE
15:45:46 <Berengal> Twey: I'd call them y.
15:46:00 <winxordie> mm_freak: futures as Alice ML implemented them were a series of Computation objects implementing concurrency via a promise system and a laziness system.
15:46:06 <aep> hm k. thanks
15:46:12 <Twey> Berengal: *snrk*
15:46:27 <mm_freak> Ziphilt: the thing is that OCaml libraries generally receive more manual optimization than C libraries
15:46:29 <winxordie> mm_freak: http://www.ps.uni-saarland.de/alice/ there we go.
15:46:41 <Ziphilt> i see
15:46:52 <mm_freak> this is not surprising, because in C implementing what you want is already hard enough =)
15:46:56 <Veinor> Is there an actual difference between partial application and currying?
15:46:59 <Ziphilt> well, is OCaml a good and fun lang to program in?
15:47:03 <mm_freak> OCaml is much more convenient than C
15:47:15 <mm_freak> so you can spend your time on important stuff =)
15:47:20 <Twey> Moving rocks around is more convenient than C
15:47:32 * p_l would take C over C++ any day
15:47:39 <Dark_Shikari> any sane person would
15:47:50 <mm_freak> winxordie: an MVar sounds like what alice calls a "future" =)
15:48:20 <aep> i cant see how i would short circuit out of a foldr
15:48:35 <winxordie> mm_freak: I haven't played around with the haskell concurrency stuff yet, still learning. :P
15:48:51 <Saizan> > foldr const [1..]
15:48:51 <mm_freak> winxordie: do result <- newEmptyMVar; forkIO (threadDelay 1000000 >> putMVar result 10); takeMVar result >>= print
15:48:57 <lambdabot>  Terminated
15:48:57 <mm_freak> prints '10' after a second
15:49:07 <Saizan> what?
15:49:14 <Saizan> > foldr const [1..]
15:49:18 <Ziphilt> i thought it was safe to assume that any functional language would be more convenient than C, usually by a large margin
15:49:19 <lambdabot>   mueval: ExitFailure 1
15:49:28 <Ziphilt> but is OCaml /good/?
15:49:28 <Saizan> ag,
15:49:33 <Saizan> > foldr const undefined [1..]
15:49:34 <lambdabot>   1
15:49:45 <FliPPeh_> :t Map.empty
15:49:47 <lambdabot> Couldn't find qualified module.
15:49:51 <FliPPeh_> :t empty
15:49:52 <mm_freak> p_l: i'd pick C++ over C
15:49:52 <lambdabot>     Ambiguous occurrence `empty'
15:49:53 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
15:49:53 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
15:49:58 <Saizan> aep: you simply not use the second argument to the step function at some point
15:50:02 <winxordie> mm_freak: Is that by cycle, nanoseconds, or what?
15:50:02 <Dark_Shikari> mm_freak: well, as I said, sane people
15:50:03 <medfly> mm_freak, maybe you need treatment.
15:50:26 <mm_freak> winxordie: nanoseconds
15:50:31 <burp> @karma c++
15:50:31 <lambdabot> c++ has a karma of -4
15:50:35 <burp> @karma c
15:50:35 <lambdabot> c has a karma of 1
15:50:36 <medfly> hehe
15:50:38 <Veinor> aep: consider that failing and returning a value are basically the same things
15:50:39 <Dark_Shikari> @karma haskell
15:50:39 <lambdabot> haskell has a karma of 58
15:50:42 <Veinor> c++--
15:50:45 <medfly> we cheated
15:50:46 <Dark_Shikari> @karma apl
15:50:46 <lambdabot> apl has a karma of 1
15:50:48 <winxordie> lol, what's this karma?
15:50:51 <Dark_Shikari> @karma java
15:50:52 <lambdabot> java has a karma of -5
15:50:54 <medfly> it's very easy to make it change easily
15:50:56 <FliPPeh_> @karme haskell
15:50:56 <lambdabot> haskell has a karma of 58
15:50:57 <Ziphilt> yes, what is karma?
15:50:58 <medfly> even without flooding :)
15:51:05 <Veinor> observe
15:51:06 <medfly> haskell--
15:51:06 <Dark_Shikari> @karma forth
15:51:07 <lambdabot> forth has a karma of 0
15:51:08 <mm_freak> c++ has useful abstractions
15:51:08 <medfly> @karma haskell
15:51:08 <lambdabot> haskell has a karma of 57
15:51:13 <mm_freak> c has only functions and loops
15:51:16 <Veinor> @karma c++
15:51:16 <lambdabot> c++ has a karma of -5
15:51:19 <winxordie> @karma ml
15:51:19 <lambdabot> ml has a karma of 0
15:51:23 <Dark_Shikari> @karma brainfuck
15:51:24 <lambdabot> brainfuck has a karma of 0
15:51:27 <winxordie> @karma scheme
15:51:27 <lambdabot> scheme has a karma of 0
15:51:30 <Ziphilt> lol brainfuck
15:51:31 <mm_freak> @karma unlambda
15:51:31 <Dark_Shikari> @karma lisp
15:51:31 <lambdabot> unlambda has a karma of 0
15:51:31 <lambdabot> lisp has a karma of -2
15:51:36 <mm_freak> unlambda++
15:51:36 <Dark_Shikari> @karma arc
15:51:37 <lambdabot> arc has a karma of 0
15:51:39 <mauke> mm_freak: functions are fine abstractions
15:51:40 <Saizan> can we stop abusing the bot?
15:51:45 <winxordie> lol
15:51:45 <medfly> it's not for languages only guys
15:51:50 <medfly> @karma Twey
15:51:50 <lambdabot> Twey has a karma of 5
15:51:56 <Dark_Shikari> @karma australia
15:51:56 <lambdabot> australia has a karma of 0
15:52:00 <kmc_> @karma weed
15:52:00 <lambdabot> weed has a karma of 290
15:52:01 <mauke> preflex: karmatop
15:52:03 <Dark_Shikari> @karma stallman
15:52:03 <lambdabot> stallman has a karma of 0
15:52:05 <FliPPeh_> :/:/:/:/
15:52:07 <mm_freak> mauke: yes, but C provides no abstractions to group related functions together
15:52:08 <preflex>  c: 64049; g: 3456; ##c: 2793; c/c: 1651; vc: 1381; bacek: 1232; #c: 1071; notepad: 1028; coke: 1011; pmichaud: 1003
15:52:09 <DBAlex> @karma whore
15:52:12 <FliPPeh_> This is madness
15:52:13 <Dark_Shikari> mm_freak: yes it does.
15:52:13 <lambdabot> whore has a karma of 0
15:52:16 <Ziphilt> yes, please stop abusing the bot
15:52:17 <Dark_Shikari> I can think of many
15:52:18 <kmc_> @karma police
15:52:21 <lambdabot> police has a karma of 0
15:52:22 --- mode: ChanServ set +o Saizan
15:52:22 <mauke> mm_freak: it does, actually; but no one uses them
15:52:23 <mm_freak> also C does not provide any generic programming constructs
15:52:24 <DBAlex> preflex: karma whore
15:52:25 <preflex>  whore has no karma
15:52:25 <Dark_Shikari> function names, structs of function pointers
15:52:29 <Dark_Shikari> mm_freak: yes it does
15:52:29 <DBAlex> preflex: karma whore
15:52:29 <preflex>  whore has no karma
15:52:32 <DBAlex> preflex: karma whore
15:52:32 <preflex>  whore has no karma
15:52:38 <DBAlex> :-P
15:52:46 <mauke> DBAlex: spam somewhere else
15:53:01 <DBAlex> just a joke, sorry :(
15:53:06 <DBAlex> like: "man woman"
15:53:06 <mm_freak> Dark_Shikari: you can also implement a haskell DSL in C and write your code in haskell
15:53:10 <mm_freak> that's not really using C
15:53:19 <mauke> DBAlex: ... four times in a row?
15:53:21 <Dark_Shikari> using function pointers isn't using C?
15:53:25 --- mode: Saizan set -o Saizan
15:53:29 <DBAlex> mauke: hehe, ok...
15:53:34 <Ziphilt> what is DSL in this context?
15:53:41 <DBAlex> Damn Small Linux!
15:53:45 <Dark_Shikari> obviously
15:53:50 <benmachine> domain-specific language
15:54:01 <mm_freak> Dark_Shikari, mauke: you're suffering from the blub paradox, it seems
15:54:06 <Ziphilt> DBAlex, that's what i thought :)
15:54:16 <mauke> mm_freak: more like the opposite
15:54:21 <DBAlex> Heh
15:54:25 <mm_freak> "C can do that"
15:54:26 <mauke> mm_freak: I thought C++ was cool until I understood it
15:54:29 <Dark_Shikari> mm_freak: but I know about higher level languages than C
15:54:30 <Dark_Shikari> and use them
15:54:36 <Dark_Shikari> the point is, C++ is _NOT_ a good higher level language
15:54:37 <DBAlex> strange how acroynms are hard-wired into my brain
15:54:48 <DBAlex> can't help being a geek I guess
15:54:53 <Dark_Shikari> it hardly does anything better than C and mostly does worse
15:55:02 <Ziphilt> i recently installed DSL to my flash drive
15:55:06 <Dark_Shikari> studies show that projects in C++ are more costly and take more time to develop than projects in C
15:55:10 <Ziphilt> it's difficult to get used to
15:55:16 <mm_freak> but C++ gives you useful abstractions, too
15:55:21 <DBAlex> I quite like C
15:55:28 <DBAlex> I prefer C to C++ anyways
15:55:29 <Dark_Shikari> the abstractions are not well designed
15:55:31 <mauke> mm_freak: I doubt that, from personal experience
15:55:38 <DBAlex> can't say why though, I just like simplicity
15:55:40 <mm_freak> it gives you classes, it gives you exceptions and templates (although template syntax is extremely ugly)
15:55:46 <Dark_Shikari> exceptions are marginally useful
15:55:50 <Dark_Shikari> templates are a good idea, but often abused
15:55:57 <Dark_Shikari> and 99% of cases where templates are used can be done just as easily in C
15:56:03 <Dark_Shikari> all C applications I work on use templates
15:56:03 <mauke> mm_freak: writing exception safe code is extremely hard
15:56:04 <DBAlex> the laziest programmers must use Haskell, less typing more thinking
15:56:13 <mm_freak> Dark_Shikari: if you think in C, yes
15:56:13 <Ziphilt> someone please alert me when the discussion drifts away from C/C++ ;)
15:56:15 <mm_freak> you can do it in C
15:56:19 <Pete1> Is it possible to get to cases run the same code? like : case x of (Case1) && (Case2) -> f x insted of writing f x two times?
15:56:24 <Dark_Shikari> mm_freak: it's just that C++ doesn't offer better ways to do anything
15:56:26 <mauke> Pete1: no
15:56:36 <Dark_Shikari> C++ is like Java done badly, and Java is Java done badly
15:56:37 <Pete1> ﻿mauke: :(
15:56:37 <medfly> mauke, thinking is hard work
15:56:47 <mauke> medfly: C++ is pointlessly complex
15:56:51 <Dark_Shikari> and yeah, that
15:56:52 <ClaudiusMaximus> > let f i = last . takeWhile (<i) in f 4 [1,3,5,7]
15:56:53 <lambdabot>   3
15:56:55 <mm_freak> Pete1: not directly, but:  let f = … in case x -> f; y -> f
15:56:57 <medfly> mauke, when was I arguing for C++
15:56:58 <DBAlex> Nothing wrong with java... I just wish it wasn't tied to the JVM
15:56:59 <Dark_Shikari> basically, if you want a high level language, there's haskell
15:57:00 <benmachine> Pete1: if f x is complicated, put it in a where clause?
15:57:03 <DBAlex> compilers exist but they suck
15:57:05 <Dark_Shikari> and python, etc
15:57:05 <benmachine> you can attach wheres to case
15:57:09 <Dark_Shikari> C++ isn't good at anything
15:57:23 <mauke> medfly: nowhere, why?
15:57:31 <Drk-Sd> Pete1: in OCaml you could, you'd just have to write match x with (Case 1) | (Case 2) -> f x
15:57:34 <Drk-Sd> :)
15:57:34 <mm_freak> Dark_Shikari: C fails at handling the most basic things
15:57:37 <Drk-Sd> :-°
15:57:38 <mm_freak> like a list of objects
15:57:41 <benmachine> my friend in games programming tells me C++ is ubiquitous in that industry
15:57:45 <kmc_> yup
15:57:49 <everythingsucks> nope
15:57:54 <Dark_Shikari> mm_freak: works fine here
15:57:58 <medfly> "I wrote a game in Haskell"
15:57:58 <mauke> mm_freak: C++ fails at the most basic things, like forwarding function args
15:58:10 <DBAlex> mm_freak: why, because people can't write linked list code?
15:58:11 <medfly> mauke, what does that mean
15:58:21 <everythingsucks> benmachine: they use haskell predominately in the games industry
15:58:21 <Twey> yup
15:58:26 <Dark_Shikari> mm_freak: http://portal.acm.org/citation.cfm?id=621567
15:58:28 <kmc_> C++ is used by people who need extreme speed, and (many more) people who know they need XTREEM SPEED!@!! but can't be arsed to profile anything
15:58:30 <DBAlex> I still don't get why there isn't a standard library linked list in C
15:58:32 <mauke> medfly: write a function f that calls another function g with the same arguments
15:58:34 <mm_freak> it's just that linked list code is much easier to write in C++ using a class
15:58:38 <arw> Dark_Shikari: C++ is good at producing error messages. a friend of mine once told me, he dreamt about C++ template errors at night. I told him i didn't believe that, a night isn't long enough for a complete output to scroll by.
15:58:42 <Dark_Shikari> arw: lol
15:58:43 <kmc_> ahahaha
15:58:48 <DBAlex> seems strange... now theres 21728127812 different versions out there
15:58:54 <Dark_Shikari> arw: I would argue that the error messages and compile time alone are reasons enough to not use C++
15:58:55 <mauke> mm_freak: show me
15:58:55 <medfly> mauke, for an arbitrary number of arguments?
15:59:02 <everythingsucks> kmc_: fallacy people use C++ when they are in need of a ambigous grammar
15:59:04 <mauke> medfly: if possible, yes
15:59:08 <everythingsucks> And lots of pain
15:59:14 <mauke> medfly: how general can you make it?
15:59:14 <tromp> so just like   f = g    ?
15:59:16 <mm_freak> mauke: why?  look at the STL
15:59:25 <Dark_Shikari> oh god the STL
15:59:29 <Dark_Shikari> it's almost as bad as boost
15:59:31 <burp> hm, true c++ compilation is slow
15:59:33 <mm_freak> you can do the same with a linked list of pointers in C
15:59:38 <mm_freak> but then, where is the type safety?
15:59:38 <mauke> mm_freak: how is that easier?
15:59:40 <medfly> mauke, strange
15:59:43 <burp> it's always amazing how slow
15:59:46 <DBAlex> wow, I never saw #haskell so busy :)
15:59:55 <mm_freak> mauke: how is it harder?
15:59:57 <medfly> DBAlex, everyone loves to complain about C++
15:59:58 <DBAlex> I guess C and C++ are "hot topics"... ;-P
16:00:04 <medfly> hell yes
16:00:08 <everythingsucks> I often hear people talk about C/C++ that is a sin. C++ is to C what lung cancer is to lung
16:00:10 <DBAlex> (Up with the partridge!)
16:00:13 <Dark_Shikari> mm_freak: the type safety is in haskell
16:00:15 <Dark_Shikari> that's where it is
16:00:16 <kmc_> everythingsucks: yes!
16:00:22 <Dark_Shikari> and for everyone who thinks C++ is a good idea
16:00:22 <medfly> DBAlex, this channel is 50% Haskell, CS and mathematics, and 50% complaining about other languages
16:00:23 <Dark_Shikari> read http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=00876288
16:00:30 <mauke> mm_freak: added complexity. "STL" requires namespaces, templates, inheritance, exceptions, member functions, ...
16:00:37 <mm_freak> Dark_Shikari: but C++ is safer than C at that
16:00:38 <Dark_Shikari> C++ and Java are both slower than C _and_ have higher development times
16:00:39 * IceDane is selling haskell to a C/C++ programmer
16:00:40 <benmachine> I think we actually keep the complaining fairly decently low
16:00:40 <IceDane> He's buying it
16:00:45 <benmachine> given how awful everything is
16:00:52 <Veinor> you can do it, IceDane!
16:00:52 <mm_freak> mauke: so?  that's what C++ is for
16:00:55 <DBAlex> medfly: complaining about other languages is pointless!
16:00:58 <Saizan> yeah, can we move the 50% about other languages to their channels? or to #haskell-blah?
16:00:58 <mauke> mm_freak: C++ broke arrays. how is that safer than C?
16:01:05 <Dark_Shikari> IceDane: I'm a C programmer, and I like haskell
16:01:06 <Saizan> or rather, move it.
16:01:07 <arw> mm_freak: c++ is also lots more painful at that. all the const/non-const madness and stuff.
16:01:08 <mm_freak> "broke"?
16:01:11 <IceDane> Dark_Shikari: So am I =)
16:01:14 <Dark_Shikari> arw: oh god const
16:01:16 <Dark_Shikari> oh god
16:01:18 <mauke> mm_freak: #haskell-blah?
16:01:18 <medfly> Dark_Shikari, and we're supposed to be subscribed to that?
16:01:21 <Dark_Shikari> the C++ treatment of const is a disaster
16:01:24 <everythingsucks> C was broken but C++ just took that crap and took a massive shit on top of that again
16:01:24 <aep> can i match a list with only one element?
16:01:26 <Veinor> in haskell, everything is const! :D
16:01:27 <Dark_Shikari> medfly: oh, I guess that's true.  I'll reupload it
16:01:27 <mauke> aep: yes
16:01:28 <medfly> I'm a PHP programmer, and I know Haskell
16:01:30 <mm_freak> mauke: i'm not there
16:01:41 <aep> ok, how do i match a list with only one element?
16:01:42 <mauke> mm_freak: ... you can go there
16:01:44 <Veinor> aep: (x:[])
16:01:45 <Dark_Shikari> I'm at a university so I'm spoiled with IEEE subscriptions
16:01:46 <medfly> it's like somewhere in the universe I have created a black hole or something
16:01:47 <mauke> aep: [x]
16:01:49 <aep> Veinor: cool thanks
16:01:49 <medfly> this makes no sense
16:01:53 <Veinor> or [x], yeah
16:01:53 <mm_freak> mauke: what do i find there?
16:02:08 <Dark_Shikari> http://mirror05.x264.nl/Dark/comparison_languages.pdf
16:02:11 <Dark_Shikari> there's your pdf
16:02:13 <mauke> ok, forget it
16:02:21 <mm_freak> i really agree that C++ is not a good language
16:02:25 <monochrom> Oh God, C++ again?
16:02:26 <burp> he wanted to continue the c++ discussion there
16:02:27 <burp> to offload it
16:02:30 <burp> I think ;)
16:02:36 <Dark_Shikari> october 2000 comparison of speed, memory, code size, and development time of 7 languages
16:02:39 <mm_freak> burp: i know, but i want to end it anyway =)
16:02:43 <Dark_Shikari> Java is worse than C++, C++ is worse than C
16:02:43 <DBAlex> C++ RAWKS WUT R U GUYS TLKIN ABT?
16:02:46 <everythingsucks> c++ is a pile of shit
16:02:48 <Dark_Shikari> and all the scripting languages are awesome
16:02:49 <burp> it's interesting to read :>
16:02:53 <Dark_Shikari> (for everything but efficiency of course)
16:02:59 <burp> I like to read about pro/contra c/c++
16:03:00 <Dark_Shikari> tcl, rexx, python, perl
16:03:03 <kmc_> sigh "scripting language"
16:03:09 <kmc_> that term is only good for starting arguments
16:03:16 <mm_freak> however i think C++ is better than C in that at least it provides abstractions that C lacks
16:03:18 <Dark_Shikari> kmc_: ok, they're all interpreted
16:03:21 <mm_freak> you're still free not to use them
16:03:23 <kmc_> gaaah
16:03:24 <kmc_> that's worse
16:03:28 <mauke> Dark_Shikari: you fail it, hard
16:03:29 <everythingsucks> mm_freak: wroong
16:03:31 <Dark_Shikari> and thus slower
16:03:32 <kmc_> no such thing as an "interpreted language"
16:03:32 <DBAlex> all programming languages suck, we should go back to assembly
16:03:37 <Dark_Shikari> kmc_: in practice, they are
16:03:37 <DBAlex> ;-P
16:03:39 <Dark_Shikari> which is why they are slower
16:03:41 <Dark_Shikari> =p
16:03:47 <mauke> Dark_Shikari: languages have no speed
16:03:53 <Dark_Shikari> yes, but this is an article about practice
16:03:54 <kmc_> Dark_Shikari: if you go to #python and complain of speed problems, the first thing they tell you is to use psyco, which is a Python compiler
16:03:59 <DBAlex> but assembly sux, we need a computer with physical switches..
16:04:02 <Dark_Shikari> kmc_: they deprecated that ages ago
16:04:06 <everythingsucks> mm_freak: I suppose it is in place to say why you are wrong. C++ does not prove abstractions. It is just a lot of crap.
16:04:06 <medfly> Dark_Shikari, it sounds biased. those kind of things tend to be.
16:04:08 <kmc_> yes but they still tell people to use it
16:04:09 <Dark_Shikari> and it was never very good
16:04:14 <kmc_> agreed
16:04:19 <Dark_Shikari> now, we do have IronPython
16:04:25 <burp> and it's only available for x86 afaik
16:04:25 <offender_> feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces
16:04:25 <Dark_Shikari> and Unladen Swallow etc
16:04:27 <offender_> feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces
16:04:29 <kmc_> great
16:04:29 <offender_> feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces feces
16:04:29 <medfly> @where ops
16:04:30 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:04:30 --- mode: ChanServ set +o mauke
16:04:30 <kmc_> @where ops
16:04:31 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
16:04:31 <Dark_Shikari> lol
16:04:38 <mauke> medfly, kmc_: gee.
16:04:42 * MissPiggy recommends not using @where ops
16:04:46 <medfly> I can't /kick :(
16:04:51 <tromp> offender_: use cycle for that
16:04:52 <mm_freak> everythingsucks: neither does C…  both languages have a non-academic origin
16:04:53 <medfly> I HAVE TO RESPOND ASAP
16:05:02 <DBAlex> btw, why is there no IronHaskell?
16:05:07 <Dark_Shikari> DBAlex: because we have GHC
16:05:11 <Dark_Shikari> it's already compiled
16:05:11 <DBAlex> yeah but...
16:05:12 <medfly> Dark_Shikari, some people are really comfortable with some languages, and that's it
16:05:14 <everythingsucks> mm_freak: that is debatable
16:05:19 <medfly> Dark_Shikari, and they find those the most readable and useful
16:05:26 <Dark_Shikari> medfly: the article is about statistics
16:05:27 <Dark_Shikari> from actual projects
16:05:29 <medfly> things like memory and speed are things you can argue about
16:05:30 <Dark_Shikari> not individuals
16:05:30 <mm_freak> everythingsucks: yes, and the only thing i see is that C++ has features, which C lacks
16:05:34 <cjs> IronHaskell?
16:05:43 <Dark_Shikari> medfly: keep reading the article, they count lines of code and dev time
16:05:47 <mauke> I feel left out
16:05:53 <medfly> still biased :P
16:05:53 <allbery_b> mmm?
16:05:55 <mauke> discussion of C and C++ is now off-topic
16:06:03 <Dark_Shikari> python was the fastest interpreted language, interestingly enough
16:06:04 <everythingsucks> good riddance
16:06:05 <medfly> #flamewar ? :D
16:06:26 -ChanServ(ChanServ@services.)- xerox added *!*@*.bb.dnainternet.fi to the AKICK list.
16:06:26 <everythingsucks> mauke really gets around
16:06:30 --- mode: mauke set -o mauke
16:06:32 <everythingsucks> now he's op here as well
16:07:20 <aep> hm "Could not find module `Data.List.Split'"
16:07:26 <mm_freak> back to haskell, our favorite language =)
16:07:28 <DBAlex> In general is Haskell compilde with GHC faster than C in GCC?
16:07:28 <jvoorhis> Dark_Shikari: Lua wasn't in the running?
16:07:29 <aep> any other split function available?
16:07:38 <DBAlex> (I'm talking code doing exactly the same thing)
16:07:44 <mauke> aep: why don't you just install Data.List.Split?
16:07:44 <DBAlex> (Obviously :P)
16:07:49 <Saizan> aep: did you install the split package?
16:07:59 <DBAlex> *compiled
16:08:04 <mm_freak> DBAlex: sometimes, but usually haskell code is going to be slower
16:08:12 <Saizan> DBAlex: for some unconclusive benchmarks see the shootout
16:08:19 <Dark_Shikari> jvoorhis: this was 2000
16:08:20 <aep> with cabal? not sure how since "cabal: "Data.List.Split" is not valid syntax for a package name or package
16:08:22 <mm_freak> number crunching code at least
16:08:22 <DBAlex> Saizan: ok
16:08:23 <Dark_Shikari> did lua even exist in 2000?
16:08:23 <everythingsucks> it's a bit funny, but last time I checked the C-- parser is in ocaml
16:08:31 <DBAlex> mm_freak: yeh
16:08:31 <Saizan> aep: cabal install split
16:08:36 <aep> oh. thanks
16:08:42 <DBAlex> Guess C has pointers, and nothing compares for speed
16:08:43 <everythingsucks> is this just the parser or the compiler as well?
16:08:47 <everythingsucks> or what
16:08:55 <DBAlex> or GCC just has a lot of talented people working on it
16:09:02 <mm_freak> haskell code can be much faster for stuff like networking or processing files
16:09:02 <Saizan> the C-- implementation in GHC is pure haskell
16:09:05 <arw> DBAlex: fortran has no pointers and is faster than c.
16:09:08 <mauke> DBAlex: I can write C in Haskell
16:09:13 <jvoorhis> Dark_Shikari: creaed in 1993, but i don't think it had its register-based vm in 2000
16:09:20 <mm_freak> but that's related to the fact that C people don't write concurrent code
16:09:37 <DBAlex> mauke: good for you
16:09:45 <DBAlex> arw: hmm...?
16:09:49 <Dark_Shikari> mm_freak: since when?
16:10:05 <Dark_Shikari> arw: the only reason fortran is faster than C is aliasing rules
16:10:07 <mauke> if you want to use malloc or pointer arithmetic in Haskell, it's there
16:10:09 <Dark_Shikari> otherwise, it's basically equivalent
16:10:15 <Saizan> DBAlex: the amount of work in GCC is very much larger than  the one spent in GHC, at this point
16:10:18 <mm_freak> Dark_Shikari: do you fork concurrent threads in C?
16:10:22 <DBAlex> Seems like theirs too many variables to compare the two
16:10:25 <Dark_Shikari> mm_freak: pthread_create, yes
16:10:25 <DBAlex> same for all languages
16:10:34 <mm_freak> Dark_Shikari: that doesn't scale well
16:10:35 <Dark_Shikari> specifically
16:10:36 <Dark_Shikari> <pengvado> gcc fails to optimize it because gcc has always sucked at arrays
16:10:36 <Dark_Shikari> <pengvado> that's *the* benefit of fortran
16:10:39 <arw> Dark_Shikari: yes. but the reason aliasing is difficult is because c has pointers.
16:10:50 <DBAlex> Saizan: Yup
16:10:58 <Dark_Shikari> mm_freak: it scales well enough for the situations it was designed for
16:11:01 <p_l> also, good FORTRAN compilers and libraries have a *lot* of work done on them, so basically it's a case of experience and polish giving superior quality of generated code :D
16:11:10 <DBAlex> someone said GHC is the "worlds most optimizing compiler"... not sure if that's correct
16:11:19 <Dark_Shikari> DBAlex: doubtful.  it's still completely retarded.  all compilers are.
16:11:24 <mm_freak> Dark_Shikari: haskell concurrency goes well beyond that…  you can use threading everywhere
16:11:25 <Dark_Shikari> some might be less retarded than others
16:11:33 <MissPiggy> Dark_Shikari that is a ridiculous thing to say
16:11:37 <DBAlex> Yeah
16:11:39 <DBAlex> sorry
16:11:40 <MissPiggy> there is not even a grain of truth
16:11:40 <mauke> most compilers write better asm than I do
16:11:44 <DBAlex> All compilers are not retarded!
16:11:45 <Dark_Shikari> then you fail at writing asm
16:11:48 <gwern> DBAlex: I understand icc beats gcc in most cases
16:11:48 <Dark_Shikari> DBAlex: name one that isn't
16:11:53 <Dark_Shikari> and I will name something retarded it did
16:11:59 <DBAlex> GHC, GCC, vbcc
16:12:03 <Dark_Shikari> GCC is incredibly stupid
16:12:06 <DBAlex> LOL
16:12:13 <Dark_Shikari> http://hardwarebug.org/
16:12:15 <Dark_Shikari> read everything here
16:12:16 <Saizan> debating C compilers is off topic.
16:12:20 <DBAlex> Shall we just turn this argument into a pissing contest?
16:12:21 <Dark_Shikari> it generates 100 instructions for a 64-bit bswap
16:12:22 <Dark_Shikari> instead of 2
16:12:32 <p_l> gwern: only on Intel's cpu
16:12:39 <Dark_Shikari> the point is, you cannot blindly trust all compilers
16:12:42 <Dark_Shikari> they are not magic pixie dust
16:12:46 <Dark_Shikari> they are not smart
16:12:50 <Dark_Shikari> they're just fallible programs that serve a useful purpose.
16:13:20 <mm_freak> the smartest compiler i know is GHC
16:13:22 <p_l> and unfortunately, you can't base their quality on age
16:13:23 <Saizan> they still have plenty of optimizations that let you write high-level code and get decent performance
16:13:27 <Saizan> see GHC
16:13:31 <Dark_Shikari> GHC is quite good, yes
16:13:34 <tensorpudding> clang has become self-hosting
16:13:40 <Dark_Shikari> it's still retarded in many ways, but in many of the same ways as any compiler
16:13:45 <Dark_Shikari> i.e. things which are inherently Hard for compilers
16:13:46 <medfly> OH SHIT, WE SHOULD ALL WRITE ASM THEN
16:13:51 <DBAlex> LOL
16:13:58 <shapr> ?
16:13:58 <kmc_> GHC *is* magic pixie dust
16:13:59 <tensorpudding> wait, we're not talking about c compilers anymore
16:14:00 <Dark_Shikari> the mere fact that it can compile haskell efficiently is an accomplishment
16:14:03 <mauke> http://www.linux-kongress.org/2009/slides/compiler_survey_felix_von_leitner.pdf
16:14:18 <mm_freak> Dark_Shikari: well, GHC is amazing…  i notice new optimizations all the time
16:14:19 <DBAlex> I'm waiting for Dark_Shikari's super-awesome-beats-everything-optimizing-compiler
16:14:25 <Dark_Shikari> medfly: actually, by aqnd large, people use SIMD asm for core DSP functions and similar
16:14:30 <mm_freak> > last [1..2^100]
16:14:34 <lambdabot>   mueval-core: Time limit exceeded
16:14:54 <Dark_Shikari> I have plenty of functions that are 10, 15, 20 times faster in asm than in C
16:14:59 <Dark_Shikari> one goes as high as 40, though that's using altivec
16:15:01 <tensorpudding> wonder if clang can replace gcc...
16:15:06 <Dark_Shikari> of course, no compiler in the world does SIMD well
16:15:09 <Dark_Shikari> so that's hardly fair anyways.
16:15:13 <medfly> I'm having a strong feeling of dejavu
16:15:18 <medfly> I've had this argument before
16:15:23 <medfly> with someone
16:15:28 <medfly> ;)
16:15:33 <Dark_Shikari> it's not really an argument
16:15:36 <mm_freak> well, use asm where appropriate
16:15:41 <Dark_Shikari> exactly
16:15:45 <DBAlex> you can use asm in C so...
16:15:47 <mm_freak> but i'd say it's appropriate in very few places
16:15:50 <medfly> he argued that speed is SUPERIMPORTANT!!! which is why things should use it way more often.
16:15:51 <DBAlex> I don't see your problem
16:15:53 <Dark_Shikari> you use it for core DSP functions
16:15:57 <Dark_Shikari> and that's it
16:16:01 <Dark_Shikari> because it's a balance between effort and speed
16:16:05 <Dark_Shikari> (and maintainability)
16:16:09 <shapr> Dark_Shikari: I don't think that's a Haskell discussion.
16:16:13 <DBAlex> Write your ASM in C then use in haskell using ffi?
16:16:14 <Dark_Shikari> shapr: indeed.
16:16:19 <medfly> lol
16:16:23 * shapr checks the channel name
16:16:27 <shapr> Dark_Shikari: I think this is #haskell
16:16:30 <Dark_Shikari> then again, it hasn't been #haskell for 30 minutes
16:16:33 <Dark_Shikari> ;)
16:16:36 <kmc_> #arguments-about-programming-languages
16:16:42 <shapr> Dark_Shikari: I think this is now #haskell
16:16:49 <medfly> I suggested #flamewar which may exist
16:16:59 <gwern> Dark_Shikari: if you stopped working on video players like mplayer or whatever, we wouldn't have all this offtopic stuff!
16:17:27 <MissPiggy> hiya shapr
16:17:31 * gwern sends Dark_Shikari TAPL. that'll quiet you for the next few years; or at least your arguments will be on topic
16:17:31 <shapr> hiya MissPiggy
16:17:35 <DBAlex> #flamewar should just have an insult bot
16:17:42 <MissPiggy> hows it going
16:17:50 <shapr> Life is exciting, how are you?
16:18:08 <MissPiggy> it's been a pretty bad day but nothing that happened today will happen again
16:18:19 <shapr> I guess that's a good thing.
16:18:22 <medfly> who died?
16:18:46 <kmc_> anyone else getting disconnected repeatedly?
16:18:47 <Dark_Shikari> gwern: the relevance was that people writing any language (even haskell) tend to assume the compiler is magic
16:18:51 <Dark_Shikari> and never investigate the produced code
16:18:53 <gwern> it is
16:18:53 <Zao> kmc_: Just you.
16:18:55 <medfly> kmc_, I used to. it was strange.
16:18:56 <Dark_Shikari> often they could write the code better
16:18:58 <shapr> Dark_Shikari: The Coconut compiler (written in Haskell) handles SIMD on the Cell quite effectively.
16:18:59 <Dark_Shikari> and get better results.
16:19:05 <gwern> I could never compile haskell into asm, much less understand and improve on it
16:19:10 <Zao> kmc_: seanl once, but that's probably unrelated.
16:19:13 <Dark_Shikari> gwern: you can't use ghc?
16:19:15 <Dark_Shikari> ;)
16:19:19 <Dark_Shikari> it compiles haskell into asm
16:19:24 <mm_freak> Dark_Shikari: i found that the compiler optimizes better than i do in many places
16:19:27 <gwern> Dark_Shikari: well, that's not me compiling - that's ghc
16:19:31 <Saizan> Dark_Shikari: nah, we even have ghc-core that prints the intermediate language and the resulting ASM for that
16:19:37 <shapr> Dark_Shikari: From what I've seen on #haskell, there's lots of looking at the core output, and seeing how it can be improved.
16:19:53 <Dark_Shikari> shapr: quite often though, if you look at the core output, you can find that if you wrote _your haskelll_ better
16:19:56 <Dark_Shikari> you'd get better results
16:20:04 <shapr> Yup, that too.
16:20:13 <Dark_Shikari> that's the most important reason to be able to read the asm
16:20:26 <DBAlex> Dark_Shikari: people don't assume it's magic, they just think that the people writing the compiler are probably way more intelligent than themselves, plus most people write slow asm anyway
16:20:30 <shapr> That's not always true though.
16:20:55 <shapr> A good endpoint for programming languages would be hardware independence.
16:20:56 <DBAlex> I wouldn't want to debug GHC asm anyway, would be horrible
16:20:57 <FliPPeh_> " | Threw Exception" -> Error: "Class `Exception' used as a type"
16:20:59 <FliPPeh_> :(
16:20:59 <Ziphilt> i am back
16:21:06 <shapr> hiya Ziphilt
16:21:06 <Ziphilt> so i wanted to ask about Perl
16:21:13 <Dark_Shikari> #perl ?
16:21:22 <Ziphilt> yes, i know
16:21:34 <shapr> Ziphilt: Have you been to the Boston Haskell User's Group?
16:21:35 <Ziphilt> but i wanted your perspective on it
16:21:38 <everythingsucks> Saizan: link to that c-- implementation
16:21:44 <Cale> Dark_Shikari: I think the ultimate approach to programming things like small embedded systems is to use a high level language (such as Haskell) together with a library for generating low level code systematically. It's effectively like using an assembler, but you get a lot of advantages that an assembler doesn't have, such as using a real programming language as your "macro" system, and being able to do various sorts o
16:21:44 <Cale> f analysis and simulation.
16:21:46 <Saizan> FliPPeh_: do you have a question with that smile?:)
16:21:54 <Ziphilt> shapr, no i have not
16:22:00 <Ziphilt> that sounds interesting
16:22:02 <shapr> Ziphilt: It's really cool, you should check it out!
16:22:07 <FliPPeh_> Saizan: Yup, I'm currently following Real World Haskell, concurrent programming
16:22:12 <FliPPeh_> That's part of the example code
16:22:20 <FliPPeh_> Just, it doesn't compile
16:22:29 <Saizan> everythingsucks: see GHC's sources, probably not a full implementation, just what's needed by GHC
16:22:39 <Cale> http://hackage.haskell.org/package/atom -- here's an example of such a library for hard-realtime in Haskell.
16:22:45 <shapr> Ziphilt: From what I've seen, Perl leverages prior experience with unix shell tools.
16:22:46 <FliPPeh_> Complaining about the Exception consructor used as a type in my ADT
16:22:50 <DBAlex> Cale: I can't undestand why Java wasn't designed so that it can compile cross platform binaries, then just have the libraries available on each OS
16:22:51 <Saizan> FliPPeh_: import Control.OldException instead of Control.Exception
16:23:08 <Ziphilt> yes, clearly
16:23:23 <DBAlex> Then you just select which binaries you want
16:23:29 <shapr> Personally, I don't have much more of an opinion on Perl.
16:23:35 <FliPPeh_> Saizan: Thanks :) What could I do to make it work with the newer exceptions?
16:23:35 <Cale> DBAlex: Well, Java is a language, and there are implementations of Java which compile to native code rather than the JVM, as I understand it.
16:23:45 <Ziphilt> i read that there was some project to make a combination language of features from Haskell and Perl
16:23:49 <DBAlex> Cale: but can you use Swing etc?
16:23:53 <Ziphilt> i thought that was quite cool
16:24:03 <DBAlex> I mean, you should just have the libraries on each target OS, and then compile for each...
16:24:10 <Cale> DBAlex: That I'm not so sure about. It's been years since I've done anything with Java.
16:24:11 <IceDane> If I have a Maybe [a], and I want my function to return Nothing on 'failure' and Just (head [a]) on success, what would be the proper way to do this monadically?
16:24:12 <DBAlex> most of the Java compilers i've tried suck tbh
16:24:25 <Saizan> FliPPeh_: i'd have to see the code, possibly you could use "SomeException", which is the type at the top of the hierarchy of exceptions
16:24:31 <DBAlex> I don't dislike java the language
16:24:38 <DBAlex> better than C++ imho (but that's offtopic!)
16:24:58 <mauke> IceDane: "monadically"?
16:25:06 <IceDane> mauke: I don't know, heh
16:25:08 <Cale> Better than C++, but still not likeable for me :)
16:25:10 <Saizan> Ziphilt: maybe it's something related to parrot and the haskell implementation of perl6?
16:25:15 <IceDane> I figured there was some functionality that facilitated it
16:25:29 <Ziphilt> Saizan, yes, pugs
16:25:39 <Saizan> IceDane: fmap head
16:25:43 <Cale> I can't really stand to use a language that doesn't properly support functions in this day and age.
16:26:01 <Cale> We've known how to implement functions for about 30 years now. It's inexcusable.
16:26:29 <Saizan> IceDane: fmap head v == do x <- v; return (head x)
16:26:29 <DBAlex> Cale: which language is that?
16:26:44 <Cale> DBAlex: Well, I'm referring to Java in this case.
16:26:57 <DBAlex> Cale: last time I checked it has functions . . .
16:26:58 <lament> Cale: what's so good about functions?
16:27:04 <luqui> Ziphilt, that was an april fool's jokle
16:27:06 <IceDane> Saizan: That's beautiful, thanks.
16:27:14 <mauke> DBAlex: really? I thought it only had a limited form of methods
16:27:21 <Ziphilt> luqui, are you serious?
16:27:46 <Ziphilt> i read that it was, but then i read what made it seem like it was for reals
16:27:52 <Ziphilt> <_>
16:28:09 <Saizan> pugs was serious, but mixing perl and haskell was a joke :)
16:28:15 <DBAlex> mauke: http://en.wikipedia.org/wiki/Function_%28computer_science%29 , In computer science, a subroutine or subprogram  (also called procedure, method, function, or routine)  ?
16:28:32 <Ziphilt> damn
16:28:49 <lament> Cale: functions work well in math, but it's not a guarantee that they're necessarily the most suitable abstraction for programming
16:29:13 <DBAlex> Why does that page have VB6 examples :-/
16:29:25 <luqui> Ziphilt, http://www.dcs.gla.ac.uk/~partain/haskerl/partain-1.html
16:29:51 <Cale_> <Cale> DBAlex: But not first class functions.
16:29:53 <Cale_> <Cale> (which is what I mean by "properly support")
16:29:58 <Ziphilt> luqui, i did see that
16:30:00 <DBAlex> ok
16:30:12 <Ziphilt> then i read a bit about pugs and i thought it turned out to be real
16:30:38 <mauke> pugs is just an interpreter written in haskell
16:30:59 <Ziphilt> sure, but i didn't read it much
16:30:59 <luqui> and haskell has had a not-insignificant impact on the design of perl 6
16:31:16 <Ziphilt> yeah, luqui, that's what i was talking about
16:31:21 <Cale> Or, perhaps I should say "first class procedures" -- as even that would be acceptable :)
16:31:23 <luqui> in the "haskell has these features, perl should too" sense, missing the haskell big picture
16:31:37 <lament> is "not-insignificant" greater or lesser than "significant"?
16:31:38 <Ziphilt> that perl6 would be somewhat more like haskell
16:31:41 <Cale> (procedures having effects, whereas functions don't)
16:31:42 <luqui> haskell's features are properties you can use to reason about your code, not cababilities that your code can do
16:31:48 <DBAlex> Cale: C/C++ doesn't have first class functions either
16:31:52 <Cale> DBAlex: right.
16:31:53 <luqui> the two are at odds with each other :-)
16:32:13 <Cale> DBAlex: I don't program in those very much either :)
16:32:13 <luqui> lament, same as double negation in intuitionistic logic
16:32:28 <lament> *head explodes*
16:32:29 <burp> one can use function pointers :>
16:32:33 <DBAlex> Cale: lambda's are nice, but not generally essential for me
16:32:41 <Cale> function pointers aren't really the same thing
16:32:46 <DBAlex> They're nice in Haskell however :)
16:33:06 <luqui> they are pretty essential in haskell :-P
16:33:20 <luqui> not lambda expressions themselves, but first class functions, of course
16:33:25 <DBAlex> yeah
16:34:01 <Cale> Yeah, I could possibly do without lambda if I had to, but first class functions with *some* syntax is essential. :)
16:34:13 <lament> java doesn't have function pointers?
16:34:48 <Saizan> lament: you've to wrap them in an object/class
16:35:03 <lament> ouch
16:35:04 <arw> lament: you can only use "runnable"
16:35:09 <lament> so it's worse than C?
16:35:15 <lament> that's pretty terrible
16:35:38 <everythingsucks> C-- looks interesting
16:35:51 <Ziphilt> what is this C-- now?
16:36:22 <arw> C-- has a terrible name.
16:36:27 <Saizan> C-- is a lower level C used as an intermediate language in GHC
16:36:34 <arw> googling for that is really not easy.
16:36:51 <Cale> It's similar to trying to cope without parameters to procedures. You end up with lots of patterns that you can't abstract over, and it's terribly frustrating given that the solution is so simple.
16:37:22 <mauke> oh man, I'd love to see Cale trying to code in ploki
16:37:50 <Cale> Of course you can do it, by managing your own stack, say. But you shouldn't have to.
16:37:56 <arw> lament: my java guy next door tells me one could use reflection to get something like function objects which could be used like function pointers...
16:38:04 <Itkovian> Given that a value is returned as IO a, where the actual stuffing of objects into a is dependent on what a is defined to be by type inference from the rest of the application, i.e., the return value of the function returning the IO a that was received, how can I see what a should be?
16:38:06 <Cale> Similarly, you can program your own closures and implement first class functions in Java, but it's painful.
16:38:14 <luqui> arw, google for "c minus minus"
16:38:25 <mauke> Itkovian: you can't
16:38:31 <arw> luqui: thx
16:38:33 <Itkovian> Argh.
16:38:34 <lament> arw: sounds worse than c then :)
16:38:38 <DBAlex> arw: That's why you don't google for it: http://en.wikipedia.org/wiki/C--
16:38:42 <DBAlex> :P
16:38:46 <Itkovian> Any way to work around other than guessing?
16:38:51 <Cale> Itkovian: ... I'm not sure I understand your question.
16:38:52 <mauke> Itkovian: what are you trying to do?
16:39:16 <Itkovian> I receive an XMLRPC structure, which my Python lib seems to interpret as a list/array of dictionaries.
16:39:19 <Ziphilt> okay, thanks for the explanation
16:39:31 <Ziphilt> what do you all think about Google's new lang Go?
16:39:37 <Ziphilt> i haven't read much about it
16:39:41 <Cale> Ziphilt: boring.
16:39:44 <Itkovian> But stating that I want a [(String, MValue)] does not yield the desired result
16:39:48 <Ziphilt> but my friend is being a zealot at me
16:40:06 <Cale> Ziphilt: It's terribly unambitious.
16:40:48 <Itkovian> Cale: Well, HaXR receives the XMLRPC result and tries to convert it into the desired type by reluying on the type inference system and the fact that you can only use types that can be instances (or derived thereof) of an XmlRpcType class
16:41:05 <Cale> Itkovian: okay.
16:41:07 <Ziphilt> as far as i know, it is supposed to be something like a replacement for C
16:41:07 <Itkovian> And I want to grok what the XMLRPC function returns as the API is not clear
16:41:40 <Itkovian> so I get an IO a, and depending on the actual value of a that is returned by the wrapper, HaXR forces the type to match
16:41:50 <mauke> Itkovian: oh, there's a class involved
16:41:55 <Itkovian> But I've no clue what the type should be
16:42:07 <Itkovian> and what I think it should be does not work
16:42:18 <Saizan> Itkovian: i think you can use Value
16:42:27 <Saizan> Itkovian: to at least be able to show it
16:42:47 <Cale> Itkovian: I'm pretty sure you don't just get an (IO a), but probably something like XmlRpcType a => IO a, no?
16:42:58 <Saizan> Itkovian: fromValue for the Value instance should never fail, i'm guessing
16:43:00 <Itkovian> Well, yeah
16:43:06 <Cale> Itkovian: That's very different.
16:43:10 <Itkovian> OK
16:43:23 <Cale> Itkovian: It means that you can apply toValue or getType from the XmlRpcType class.
16:43:41 <Cale> Or fromValue
16:43:51 <sm> yay, a new haskell game. And frp based
16:43:53 <Cale> (to create a value of that type)
16:44:01 <Cale> sm: Which one? dow?
16:44:11 <sm> Cale: yup, dow
16:44:20 * sm fires it up
16:44:28 <bookhacker> hey can someone help me with a beginner question: http://pastebin.com/m2202a060
16:44:29 <Cale> It is old school :)
16:44:31 <Ziphilt> well, i think i have gotten all the useful information i can out of this channel for now, while i don't know haskell very well
16:44:55 <Cale> Ziphilt: Don't be afraid to ask any questions you might have about Haskell :)
16:44:57 <sm> I'm ok with that!
16:45:03 <Ziphilt> so i thank you all, and i'll just lurk until i have a question
16:45:10 <sm> unfortunately it won't take focus, that's not old school
16:45:18 <Cale> bookhacker: b = (a -> t)
16:45:30 <Ziphilt> Cale, thanks :)
16:45:34 <mauke> bookhacker: foldr :: (a -> b -> b) -> b -> [a] -> b where b = (a -> t)
16:45:57 <Cale> bookhacker: step :: a -> (a -> t) -> (a -> t) = a -> b -> b, so the type matches
16:46:31 <Itkovian> bookhacker: a type can be anything
16:46:49 <Itkovian> bookhacker: so it can also represent a function with one or more arguments
16:46:56 <bookhacker> so a -> (a->t) -> a -> t is the same as a -> (a->t) -> (a->t)?
16:47:03 <Cale> A type variable, rather, can be anything :)
16:47:10 <Cale> bookhacker: yeah
16:47:13 <Itkovian> well, yeah
16:47:14 <Cale> -> associates to the right
16:47:27 <Cale> So  A -> B -> C -> D  means  A -> (B -> (C -> D))
16:47:43 <Cale> and to go along with this, function application associates to the left
16:47:45 <Cale> So that
16:47:47 <Cale> f x y z
16:47:49 <Cale> means
16:47:55 <Cale> ((f x) y) z
16:47:59 <bookhacker> and a b c d means a (b (c d)) right
16:48:04 <Cale> the other way :)
16:48:20 <temoto> > a b c d
16:48:21 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
16:48:21 <lambdabot>                           ...
16:48:44 <luqui> > a b
16:48:45 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
16:48:45 <lambdabot>         against infe...
16:48:49 <temoto> Note where '...' is located.
16:48:49 <Cale> > f x y z
16:48:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:48:50 <lambdabot>    `GHC.Show.Show a'
16:48:50 <lambdabot>      a...
16:49:08 <Cale> ah well.
16:49:09 <Philonous> @type ?a ?b ?c ?d
16:49:10 <lambdabot> forall t t1 t2 t3. (?d::t2, ?c::t1, ?b::t, ?a::t -> t1 -> t2 -> t3) => t3
16:49:11 <temoto> See, function application is left-associative for this reason.
16:49:26 <temoto> Because '...' is in the middle of the error message.
16:49:30 <Cale> heh
16:49:31 <aep> can i any idea how i can convert Foreign.C.Types.CSize to Int ?
16:49:32 <Itkovian> bookhacker: function application associates to the left, so a b c d == ((a b) c) d)
16:49:47 <Itkovian> bookhacker: for types it's the other way around
16:50:07 <Cale> Yeah, because we write function application backwards (sort of) :)
16:50:10 <mauke> aep: fromIntegral
16:50:16 <temoto> @djinn Foreign.C.Types.CSize -> Int
16:50:17 <lambdabot> Error: Undefined type Foreign.C.Types.CSize
16:50:18 <Cale> It's all Newton's fault.
16:50:28 <aep> thanks mauke
16:50:41 <Cale> We write f(x) in mathematics, and f x in Haskell rather than (x)f or x f
16:50:46 <temoto> Io uses "proper" order, afaik.
16:51:09 <temoto> Io> "Hello world!" print
16:51:23 <Itkovian> Hmm, so I have the (XmlRpcType a) => IO a as in response <- remote ... , how do I get its type. Sigh.
16:51:40 <DBAlex> Ziphilt: Go is something I wanted to write for a while, but I'm not sure theres much point really, so I didn't bother...
16:51:51 <DBAlex> if you want a cross between C and Python, just use Python
16:51:53 <theorbtwo> Cale: Are you sure that isn't older then Newton?
16:51:59 <Cale> Right, so if you have a value of type (XmlRpcType a) => a, you can apply toValue to it
16:52:10 <Cale> theorbtwo: I'm pretty sure he's responsible for it.
16:52:19 <Cale> theorbtwo: I could be mistaken.
16:52:30 <DBAlex> if you're worried about speed use IronPython, CPython, Psyco... etc
16:52:35 <DBAlex> or Pyrex
16:52:37 <theorbtwo> Thanks.
16:52:40 <temoto> Somebody should take the blame. Newton is dead so he wouldn't complain.
16:52:41 <Ziphilt> DBAlex, yeah, Python is probably better
16:53:05 <Ziphilt> i can't say much about it as i have basically no experience with it
16:53:08 <DBAlex> *Cython even
16:53:20 <Cale> Itkovian: So you get a value of type Value, and then you can use case to pattern match on which of the finite selection of types it is.
16:53:34 <Cale> http://hackage.haskell.org/packages/archive/haxr/3000.5/doc/html/Network-XmlRpc-Internals.html#t%3AValue
16:53:58 <DBAlex> Ziphilt: I haven't bothered to look closely, but from what i've seen you may as well use Python
16:54:12 <Itkovian> grr Ambiguous type variable `a' in the constraint:
16:54:26 <bookhacker> does the state monad perform better for dynamic programming algorithms than Data.Array.Diff?
16:54:30 <Cale> Itkovian: oh!
16:54:42 <Cale> Itkovian: Value is itself an instance of XmlRpcType
16:54:46 * theorbtwo woders who to blame for (f x y z) more then for f(x, y, z)
16:54:50 <Cale> Itkovian: So you don't even have to apply toValue
16:54:59 <Cale> Itkovian: Just use the thing as a Value
16:55:23 <Cale> theorbtwo: Maybe Church.
16:55:40 <burp> f
16:55:53 <Itkovian> But it is not a Value yet.
16:56:05 <Cale> Itkovian: It's anything with that typeclass
16:56:12 <Cale> Itkovian: Including perhaps Value
16:56:28 <Saizan> yes, Value is an instance of that typeclass
16:56:35 <Itkovian> Then why do I need to add a type constraint, and where do I add that constraint?
16:56:37 <Saizan> it's what i was suggesting earlier! :P
16:56:47 <Cale> Itkovian: You actually don't.
16:56:52 <Cale> Itkovian: Just pattern match on it.
16:57:00 <Cale> Itkovian: and the thing will get a constrained type
16:57:04 <DBAlex> Ziphilt: C# is nicer than Go
16:57:10 <DBAlex> plus with Mono your not tied to .Net
16:57:16 <Saizan> Itkovian: to your action that's XmlRpc a => IO a, add a type annotation like IO Value
16:57:57 <Cale> The first thing I do when I'm faced with a new language is to ask how the 'map' function looks.
16:58:00 <Itkovian> Saizan: right. D'oh!
16:58:06 <Ziphilt> DBAlex, are you commending C# or insulting Go?
16:58:22 <Itkovian> shit. Error parsing method response: in <methodResponse>, failed to parse any of the possible choices)
16:58:27 <DBAlex> Ziphilt: commending C#
16:58:31 <lament> Cale: The first thing I do when i'm faced with a new language is to ask how multiple inheritance looks.
16:58:31 <luqui> Ziphilt, can't a simple comparative not be interpreted as a value judgement :-)
16:58:32 <ddarius> C# is pretty nice.
16:58:33 <Cale> Go doesn't have a powerful enough type system for 'map' to typecheck.
16:58:40 <Itkovian> Might HaXR be missing some type?
16:58:44 <mrsolo> mono is still alive? ..wow...
16:58:46 <DBAlex> C# 4.0 is sweet
16:58:55 <DBAlex> not sure what version their at now
16:58:59 <ddarius> However, my impression is that Mono isn't (yet) a serious replacement for MS's environment w.r.t. .NET.
16:59:35 <mauke> Cale: what about perl? it has 'map', but it's not a function :-)
16:59:37 <IceDane> Is there any easy way to parse stuff like "[1..3]" ?
16:59:41 <Ziphilt> i take immediate offense to C# because it is proprietary
16:59:51 <Ziphilt> what computing platforms are you all using?
16:59:59 <IceDane> I'm trying to expand a textual representation of a list like that, "[1..5]" to the list itself.
17:00:03 <Itkovian> Might this be the culprit? -- FIXME: struct elements may have different types (Internals.hs)
17:00:08 <theorbtwo> mauke: Er, depends on your definition of "function".
17:00:32 <dibblego> ddarius, do you write high-level C#? and do you endure protests as a result?
17:00:34 <blackh> Ziphilt: I agree with you, but if a language is popular and there's an O/S implementation then I consider it acceptable.  I'm on Ubuntu amd64.
17:00:39 <Cale> mauke: Well, I'm talking more about asking how the implementation of it would look.
17:00:40 <Itkovian> as well as -- FIXME: array elements may have different types
17:00:41 <c_wraith> newtype QSem = QSem (MVar (Int, [MVar ()])) -- hrm.  interesting
17:01:03 <mauke> ok
17:01:26 <Cale> Go has a builtin foreach, but that doesn't count :P
17:01:29 <Ziphilt> blackh: I am on Fedora x86_64 (synonymous with amd64, in case you didn't know)
17:01:42 <Ziphilt> (i hope you know)
17:01:50 <Cale> The concern is more to do with how to write higher-order functions.
17:01:59 <DBAlex> I'm on XP still, I suck
17:02:03 <Cale> map is just a simple example
17:02:05 <mauke> sub map { my ($f, @xs) = @_; my @ys; push @ys, $f->($_) for @xs; @ys }
17:02:12 <DBAlex> I don't like C# any less/more because I run Windows however
17:02:21 <blackh> Ziphilt: True. Apparently C# is a good language according to people I would believe, but not as good as Haskell, obviously. :)
17:02:27 <Cale> Yeah, perl can cope because it's dynamically typed.
17:02:31 <mauke> hmm
17:02:51 <mauke> this function accidentally mimics the real map in two weird ways :-)
17:02:53 <lament> DBAlex: you will like it less if you switch OSes and use Mono.
17:03:16 <theorbtwo> Cale: It also has easily accessable (if, perhaps, not precisely first-class) function pointers.
17:03:21 <DBAlex> lament: Hmm
17:03:34 <theorbtwo> BTW, sub map (&@) if you want the nice syntax.
17:04:07 <mauke> argh. three ways!
17:04:15 <mauke> my $f = shift; and it's four
17:04:19 <DBAlex> C# is definitely on my "learn properly for a couple of years" list
17:04:33 <DBAlex> along with another functional language, not sure which (scheme, or lisp maybe)
17:05:21 <DBAlex> any reccomendations? or is there no point if I know Haskell?
17:05:45 <IceDane> Is there any way to parse "[x...y]" from text to a list?
17:05:51 <IceDane> Easy way, that is?
17:06:03 <aep> aarg.  my Chan deadlocked D:
17:06:05 <c_wraith> read?
17:06:05 <DBAlex> IceDane: what are you writing?
17:06:12 <DBAlex> a Haskell compiler? :-P
17:06:15 <IceDane> c_wraith: It didn't work, heh
17:06:19 <blackh> DBAlex: Disciple.  Actually it's more of a work in progress than a language, but it's quite interesting.
17:06:22 <theorbtwo> DBAlex: I don't know terribly much about any of the above, but I'd go with c#, I think.  Something that is unashamedly a pratical language.
17:06:28 <c_wraith> > read "[1,2,3]" :: [Int]
17:06:29 <IceDane> DBAlex: Haha, no. I'm expanding the ircbot from the wiki
17:06:29 <lambdabot>   [1,2,3]
17:06:33 <IceDane> with my modified rpn calculator
17:06:36 <Itkovian> I give up for today.
17:06:40 <Itkovian> Night.
17:06:42 <IceDane> > read "[1..5]" :: [Int]
17:06:43 <lambdabot>   * Exception: Prelude.read: no parse
17:06:50 <c_wraith> oh, you mean that syntax in particular
17:06:54 <IceDane> Yes :P
17:07:02 <Cale> Itkovian: When you come back, put your code on a pastebin so that people can look at it :)
17:07:03 <c_wraith> I don't know of anything offhand, short of a haskell parser :)
17:07:05 <DBAlex> Anyone tried agda?
17:07:09 <DBAlex> someone told me it was good...
17:07:25 <Cale> DBAlex: Agda contains elements of the future
17:07:26 <DBAlex> theorbtwo: fair enough
17:07:41 <IceDane> c_wraith: if I could isolate the x y in [x..y], it would be easy, but isolating them isn't so much an easy task.. Not as far as I can see, anyway
17:07:42 <Cale> DBAlex: It would be a good choice.
17:07:58 <lament> I like C#, but i don't use it for any "pet projects" because i don't really trust Mono.
17:08:04 <DBAlex> blackh: ok, cool
17:08:19 <Cale> IceDane: Well, it sounds like you want to write a proper parser at this point.
17:08:22 <ddarius> dibblego: I write a good variety of C#.  I've written rather low-level C#, much more or less typical (industry programmer) level C#, and some really crazy C#.
17:08:32 <IceDane> Cale: Perhaps. Should I dive head first into parsec then?
17:08:37 <DBAlex> really should learn scheme though... or just read SICP
17:08:41 <dibblego> ddarius, don't you get protests for your crazy C#?
17:08:42 <Cale> IceDane: You could
17:09:03 <Cale> DBAlex: Or at least just watch the SICP lectures :)
17:09:06 <IceDane> Cale: or are you talking about writing your own from scratch?
17:09:23 <Cale> IceDane: Nah, I'd recommend using some parser combinator library
17:09:37 <ddarius> dibblego: I don't think I've used too much of my really crazy C# for actual projects.  I've definitely had people appreciate my somewhat higher-level and definitely FP-inspired C#.
17:09:37 <Cale> Either Parsec or ReadP or something like that :)
17:10:02 <ddarius> dibblego: I'll probably work on a cut-down thing sort of like Bling, but without the graphics emphasis soon.
17:10:02 <blackh> DBAlex: Disciple is like Haskell with a more sophisticated (= complex) type system that can handle mutability and IO.  Basically it shifts IO and State from an abstraction into the type system.  Possibilities with regard to safe parallelization of code that does mutable state.
17:10:09 <Itkovian> Cale: http://pastebin.com/m5de713ba
17:10:19 <DBAlex> Cale: cool! I'm not sure if it was SICP but i've seen some of the MIT scheme lectures on youtube, very interesting
17:10:21 <ddarius> dibblego: I do tend to make significant use of higher-order functions in C#.
17:10:37 <DBAlex> I'm glad lectures aren't that sparse here...
17:10:38 <dibblego> ddarius, so do I, but I attract protest when I do
17:11:05 <gwern> @tell dcoutts seems that forcing an install of mtl fixes the -base issue, as much as it scares me to reinstall core libs like that
17:11:05 <lambdabot> Consider it noted.
17:11:31 <mauke> execScanner $ do lit "["; grab digits; lit "..."; grab digits; lit "]" :: String -> Maybe [String]
17:12:04 <DBAlex> blackh: sounds interesting
17:12:14 <DBAlex> I have a few days reading anyhow :-)
17:12:45 <blackh> DBAlex: It's at a pretty early stage.  Some stuff missing and some bugs, but you can compile small programs in it.
17:13:02 <DBAlex> blackh: are you a developer on the project?
17:13:10 <aep> does haskells MVar etc realize it needs to use locking even when the thread wasnt started by haskell but by  C code which just called the haskell function ?
17:13:21 <Cale> ghci> readP_to_S (do char '['; x <- readS_to_P reads; string ".."; y <- readS_to_P reads; char ']'; return (x, y)) "[72..102]" :: [((Integer, Integer), String)]
17:13:21 <Cale> [((72,102),"")]
17:13:45 <blackh> DBAlex: No, but I thought it sounded very interesting and started implementing a hash table, and found a compiler bug in the process.
17:13:53 <DBAlex> cool!
17:13:55 <Cale> IceDane: ^^ there's what it might look like in ReadP
17:14:32 <Cale> IceDane: Of course, you'd probably want to make a proper definition rather than smashing the parser in-place into your code ;)
17:14:38 <gwern> and regex-posix requires me to specify --extra-lib-dirs=/usr/lib/
17:14:39 <gwern> fun
17:14:40 <Saizan> aep: i think so, if you link with the threaded runtime
17:14:48 <blackh> DBAlex: Cale just said Agda has elements of the future - I'm trying to evaluate whether Disciple has.  I think it has.
17:14:54 <aep> it deadlocks :(
17:15:14 <IceDane> Cale: Wow, that was simpler than I thought
17:15:20 <IceDane> Thanks, I'll take a look at readP
17:15:23 <gwern> wait no that doesn't work at all
17:15:33 <DBAlex> Well Adga looks like a theorum proving language :-/
17:15:42 <Cale> IceDane: It's similar to Parsec, but simpler.
17:15:44 <DBAlex> I just did a whole module on proofs... not for me
17:15:46 <gwern> dammit darcs
17:15:51 <Cale> IceDane: It doesn't have support for things like ByteStrings
17:16:06 <ddarius> DBAlex: The old Agda was.  Almost any dependently typed language is going to have that to some extent.
17:16:15 <IceDane> Cale: It doesn't matter. If it gets the job done, that's fine
17:16:30 <gwern> or maybe cabal is at fault here
17:16:44 <DBAlex> ddarius: I guess, it's just not a personal interest of mine
17:16:49 <Cale> DBAlex: Programming and proving theorems are secretly the same thing.
17:16:54 <DBAlex> although some of the modules I take have elements of it included
17:17:09 <Cale> DBAlex: Types are statements, programs are proofs :)
17:17:43 <Figs> I'm having a very hard time getting the SDL bindings to install. Could anyone give me a hand with that, please?
17:18:03 <Cale> Hmm, lots of people interested in installing the SDL bindings lately...
17:18:07 <Figs> I'm in the middle of trying to debug linker errors about missing SDL_main
17:18:46 <Saizan> Figs: which OS?
17:18:58 <Figs> Vista with Msys
17:19:05 <sm> what is this ghc panic: http://gist.github.com/302181 ? Is it a different issue from http://hackage.haskell.org/trac/ghc/ticket/3590 ?
17:19:22 <ozataman> can hxt process json?
17:19:46 <Cale> ozataman: Does json look like XML?
17:19:58 <DBAlex> i can haz json
17:20:09 <ozataman> Cale: nope, but concept is very similar and a lot of the arrow-style combinatorial functionality would be the same
17:20:20 <ozataman> Cale: would be great to have
17:20:38 <Cale> ozataman: I don't think it can, anyway. There are however, libraries for parsing and manipulating json.
17:20:39 <ozataman> Cale: after working with hxt, extracting info from large json dumps is hell using the json library
17:20:56 <`Zerax`> Get to it then ;)
17:21:02 <gwern> only *you* can improve libraries
17:21:19 <aep> can i get the current thread id from somewhere for debugging?
17:21:33 <gwern> @hoogle IO Int
17:21:33 <lambdabot> Did you mean: :: IO Int /count=20
17:21:33 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
17:21:33 <lambdabot> Data.IntSet intersection :: IntSet -> IntSet -> IntSet
17:21:43 <gwern> huh
17:22:21 <m-i-l-a-n> http://conal.net/blog/posts/semantic-editor-combinators/
17:22:41 <Figs> http://pastebin.com/m7802ca4 This is what I have in my console at the moment
17:22:42 <m-i-l-a-n> sorry accident paste :/
17:22:48 <Saizan> sm: it looks different
17:23:38 <Saizan> sm: ghc throws a panic in any unexpected situation, so they can originate from different parts of the code
17:23:46 <Cale> m-i-l-a-n: Oddly on-topic for an accidental paste though. :)
17:24:09 <Saizan> aep: there's myThreadId
17:24:15 <Cale> m-i-l-a-n: They might be just the sort of thing that ozataman would want.
17:24:16 <sm> thanks Saizan .. I found my original report (boy, trac makes that hard!)
17:24:20 <aep> Saizan: thanks
17:24:43 <ozataman> Cale: :) i'm looking at it now
17:25:06 <sm> http://hackage.haskell.org/trac/ghc/ticket/3862 . Seems like I've triggered a 6.10.4 bug .. now how do I avoid it for one more release
17:25:06 <gwern> ghc 6.12 spits out a *lot* more warnings
17:25:15 <gwern> I have noticed
17:26:15 <Twey> That's mostly just because people haven't adapted their code to it yet
17:26:36 <Twey> Also because it produces silly warnings like for discarding the result of a computation *grumble* *grumble*
17:27:59 <`Zerax`> Is that not a good thing?
17:29:28 <ozataman> Cale: wow yeah this is oddly on topic :)
17:29:35 <ozataman> m-i-l-a-n: thanks!
17:30:01 <Cale> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:31:00 <Cale> ozataman: you might also look at that :)
17:31:52 <shapr> Can I embed haskell code into a standard tex document? Or is it easier to go full out lhs?
17:32:17 <Cale> shapr: Well, the difference is mostly just the file extension.
17:32:37 <Cale> Or are you talking about using Plain TeX?
17:32:45 <shapr> I'm using LaTeX at the moment.
17:32:54 <Cale> LaTeX goes better with the \begin{code} ... \end{code} convention :)
17:33:16 <ozataman> Cale: Thanks - I think this is almost an intro to generics
17:33:19 <Cale> lhs2TeX is convenient for making things look pretty
17:33:28 <ozataman> Cale: which, I have read about but haven't had the chance to use yet
17:33:55 <Cale> ozataman: hmm, there might be some sort of relationship there, yeah
17:36:46 <aep> is there any way to debug a deadlock? somehow find out where exactly it is stuckl
17:37:21 <blackh> aep: What sort of deadlock?
17:37:33 <sm> yay, removing the cabal-installed parsec makes it work
17:38:29 <aep> blackh: i wish i knew. i'm using Posix.Fuse and it just stops working with two concurent processes accesing it
17:38:33 <DBAlex> btw, why haven't we been using functional languages for so long?
17:38:39 <aep> both sides just do nothing then
17:38:52 <DBAlex> can't understand why people didn't start using them full-time ....
17:39:03 <DBAlex> not as some specialist language or w/e
17:40:07 * hackagebot upload: hs-gchart 0.3 - Haskell wrapper for the Google Chart API (DeepakJois)
17:40:39 <blackh> aep: What you could do is compile it with 1. profiling support (-prof -auto-all), 2. run it with the -xc option, e.g. ./myprogram +RTS -xc, 3. hack your program somehow to send exceptions to all the threads you can find.  When the exceptions are caught, you should get a stack trace.
17:41:04 <DBAlex> guess it's hard to teach programming as it is, using a functional language is probably harder
17:41:06 <`Zerax`> Ooh, new gchart
17:41:12 <blackh> aep: Use Control.Concurrent.throwTo to send the exception.  You'll need to hack your code so you can do this.
17:41:23 <DBAlex> although a guy I knew got taught scheme as his first language at uni...
17:41:25 <aep> thanks
17:41:31 <aep> blackh: its in none of my functions unfortunately
17:41:40 <aep> i bet its fuse...
17:41:51 <blackh> aep: I was thinking of using the fuse library - shame it has bugs!
17:42:38 <aep> i dont know if it does :/
17:44:25 <Veinor> @djinn (a -> b -> b) -> a -> b
17:44:25 <lambdabot> -- f cannot be realized.
17:45:47 <copumpkin> @djinn (a -> a -> b) -> a -> b
17:45:47 <lambdabot> f a b = a b b
17:46:17 <Figs> So... does anyone have any idea what I'm doing wrong?
17:46:52 <BMeph> "It". ;)
17:48:54 <aep> how do i install prof libs from cabal?
17:49:58 <shrughes> :t (fix .)
17:49:59 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
17:49:59 <aep> ah there
17:50:00 <aavogt> aep: there's a setting in  ~/.cabal/config
17:50:05 <sm> aep: cabal install pkg -p [--reinstall]
17:50:10 * hackagebot upload: hledger 0.8 - A command-line (or curses or web-based) double-entry accounting tool. (SimonMichael)
17:52:17 <blackh> aep: It's a bit of a nuisance doing profiling libraries if you have lots of dependencies, but making it always compile them by editing ~/.cabal/config solves the problem pretty well.
17:53:56 <aep> hm how do i find all threads? :D
17:54:03 <sm> some libs are hard to build with -p though (eg happstack)
17:54:10 <aep> isnt there something like gdb for haskell? :(
17:55:59 <aep> gdb itself doesnt show anything but ???
17:56:09 <sm> ghci has a debugger. It's not much like gdb
17:57:54 <sshc> aep: try read the debugger section of GHC's user manual
17:57:59 <aep> aye
17:59:06 <Figs> Could someone run me through how the setup script works? I think if I change the libraries that it links, I may be able to get this to compile, but I have no idea where it's defined in this build system.
18:00:55 <blackh> Figs: It's all in the .cabal file
18:02:17 <aep> actually, this is odd.  myThreadId says 8  when the deadlock occures, but gdb only shows 6 threads
18:02:29 <sshc> Figs: the best way to understand is to read cabal's documentation
18:02:46 <aep> does haskell start some non system threads and increases thread id on its own?
18:02:53 <kmc> er, ghc?
18:03:18 <kmc> GHC threads have no direct relation to OS-level threads, which is probably what gdb reports
18:03:32 <kmc> @hoogle myThreadId
18:03:32 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
18:03:40 <aep> i see
18:03:46 <aep> can i find the os thread id?
18:03:55 <kmc> you can call any C function, so probably
18:04:06 <aep> good point
18:04:07 <copumpkin> make sure you do forkOS
18:04:07 <kmc> it's likely to change from moment to moment along a Haskell thread
18:04:10 <copumpkin> or it might change a lot
18:04:26 <aep> copumpkin: i have no influence on creation of threads
18:04:33 <kmc> using forkOS rather than forkIO ensures that all FFI calls from that hs thread will execute in the same OS thread
18:04:35 <copumpkin> hm, ok
18:04:43 <copumpkin> yeah
18:05:08 <kmc> it does not necessarily spawn a new OS thread, nor does it force the "pure Haskell" (i.e. evaluation of expressions) part of the thread to happen in any particular place
18:05:11 <kmc> thus the name is somewhat misleading
18:05:28 <copumpkin> well, it's all that really matters
18:05:45 <copumpkin> the only reason you'd want forkOS is to ensure FFI stuff happens on a single thread
18:06:07 <kmc> hmm you can also use runInBoundThread
18:06:44 * dolio has Java GUI coding flashbacks.
18:08:05 <kmc> one strategy for interfacing with a single-threaded FFI library is to send your FFI actions over a Chan to a dedicated forkOS'ed FFI worker thread
18:08:11 <kmc> Gtk2Hs does this iirc
18:08:21 <kmc> it's a cool use of first-class actions
18:09:26 <dolio> JFC programming was full of "runThisInAnotherThreadForMe(x)" stuff.
18:09:48 <c_wraith> well.
18:09:56 <kmc> what is 'x' then?
18:10:03 <c_wraith> My company's haskell web server is now officially handling ~20 requests/second
18:10:09 <kmc> nice!
18:10:21 <dolio> Whatever you want to be run in another thread, because all GUI stuff has to happen in one thread.
18:10:28 <kmc> that might beat rails ;P
18:10:32 <c_wraith> Most of them are identical, and we're caching the response to that query. :)
18:10:33 <pikhq> kmc: An object with a single method, of course.
18:10:48 <pikhq> Hooray, exceptionally verbose lambda.
18:10:58 <kmc> i guess you can in fact build those anonymously in Java
18:11:01 <kmc> but it is pretty verbose
18:11:38 * kmc thinks fondly of Alonzo Church's Object With A Single Method Calculus
18:11:39 <c_wraith> kmc: in fact, we just moved a particular high-traffic API call to haskell from rails.  :)
18:11:45 <kmc> ha
18:12:04 <Figs> Woohoo, finally got it to compile
18:12:44 <Figs> seems that it really didn't like -lmingw32
18:14:07 <monochrom> rail is so 19th century anyway
18:14:13 <dolio> kmc: http://java.sun.com/products/jfc/tsc/articles/threads/threads1.html
18:14:32 <dolio> kmc: Look for "invokeLater".
18:16:04 <monochrom> I almost forgot that Swing is best used as single-threaded too.
18:16:13 <sm> first time installing ghc-6.10.4 package on ubuntu! Three cheers for package maintainers!!
18:17:00 <Figs> Now I get about a dozen errors like this:
18:17:01 <Figs> main.o:fake:(.text+0x193): undefined reference to `SDLzm0zi5zi9_GraphicsziUIziSDLziEvents_waitEvent_closure'
18:17:19 <c_wraith> sm: in my experience, they somehow mucked up haskeline.
18:17:24 <Lemmih> Figs: Using --make?
18:17:27 <sm> ack
18:17:33 <Figs> ?
18:17:50 <c_wraith> sm: try out ghci, and see if the keybindings you expect work for you.  if so, yay!
18:17:52 <kmc> ghc --make foo.hs
18:18:13 <sm> control p.. no
18:18:16 <Figs> Ah, thanks.
18:19:56 <Figs> Holy crap, it works! Woohoo.
18:20:35 <ozataman> It would be great if docs for haskell libraries could show some examples for each method
18:20:42 <ozataman> it would help tremendously
18:20:56 <sm> +1
18:20:57 <aep> ok Chan definatly deadlocked here.  shouldnt i use that on system threads?
18:21:18 <aep> both reader and writer sit on the same mutex doing nothing
18:21:47 <shapr> Yeah, I wish for that also.
18:22:13 <ozataman> For example: http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html#2
18:22:34 <ozataman> Great library I'm sure - but I'm having trouble doing something as simple as loading a large json string and extracting a value from it
18:25:01 <blackh> ozataman: I had a look at this library one time.  It does require you to understand how all the typeclass stuff works - then it's simple.
18:26:06 <blackh> ozataman: I agree about examples - all my libraries have examples (e.g. hexpat)
18:27:22 <ozataman> blackh: Thank you for that - I personally always appreciate when I see a library well documented.
18:28:03 <Cale> ozataman: What does the json that you're trying to read look like?
18:28:07 <blackh> Well, maybe I can encourage the use of nice XML instead of evil JSON. :)
18:28:35 <ozataman> blackh: I would much rather work with xml - I'm working on a one-time thing that needs to parse a large json string
18:28:49 <Cale> XML is at least as evil as JSON. Stupid glorified tree syntaxes with horribly complicated parsing :P
18:28:57 <ozataman> Cale: what do you mean? it has some confidential info inside, so I can't really paste it publicly...
18:29:04 <Cale> ozataman: Oh, okay
18:29:20 <ozataman> Cale: I really like hxt though, so I never have to deal with xml itself
18:29:30 <ozataman> blackh: I'll try hexpat next time too!
18:29:31 <blackh> Cale: That's why I wrote hexpat!
18:29:46 <Cale> ozataman: Well, HXT is overcomplicated because XML is too.
18:29:50 <pikhq> Cale: XML is significantly more evil than JSON. JSON at least is *able to be handled by humans*.
18:30:07 <ozataman> pikhq: Yeah, I think json is easier to work with manually
18:30:20 <blackh> Take a look at hexpat before you say that using XML in Haskell is complicated.
18:30:28 <ozataman> pikhq: but it seems pretty inconvenient to manipulate/extract in Haskell
18:30:40 <pikhq> ozataman: Yeah...
18:30:49 <pikhq> JSON is pretty darned Javascript-centric.
18:32:01 <DBAlex> anyways
18:32:03 <DBAlex> better sleep
18:32:07 <DBAlex> cya :)
18:32:17 <pikhq> Gxis.
18:32:39 <DBAlex> Gxis?
18:32:55 <Cale> blackh: It's way more complicated than just using a normal algebraic datatype with Read and Show instances
18:33:10 <Cale> (or if you want to get fancy, a simple parser and prettyprinter)
18:34:15 <Sgeo> DBAlex, it's .. darn
18:34:41 <Sgeo> "Gxis" is Esperanto. I think it roughly means "Bye"
18:35:14 <Sgeo> Gx (written G^ except with the carrot over the g) is pronounced "j"
18:35:28 <p_l> btw, haskell-related entry into talk about Haskell/Lisp: “ drewc looks at his code using CLOS, FORMAT, lexical scope, continations and monads.... and seens simula, fortran, scheme and haskell-spunning”
18:35:29 <blackh> Cale: This is true. I use hexpat + hexpat-pickle. Erik Hesselink has developed a (I think) TH-based XML pickling system which is less work to use than mine.
18:35:52 <blackh> pikhq: Saluton!
18:36:27 <Cale> As a file format, XML is more complicated to describe than S-expressions, and doesn't really buy you much advantage over them.
18:36:50 <Cale> and it has awkward duplication of functionality (attributes are stupid)
18:36:59 <pikhq> blackh: こんにちは！
18:37:03 <dankna> namespaces are important - that's the main advantage over s-expressions
18:37:15 <pikhq> :P
18:40:17 <p_l> dankna: Then I give you a simple scheme of (namespace:symbol ...) ;-)
18:40:59 <aep> can i get a list of threads somehow?
18:41:05 <copumpkin> p_l: zomg genius
18:41:11 <dankna> no, you really want namespaces to have URIs...
18:41:14 <Cale> "Let's fix the problems with HTML by generalising it to try to deal with arbitrary data while keeping all the mistakes we made. Also, let's make it much more complicated."
18:41:15 <blackh> aep: I don't think so
18:41:26 <copumpkin> dankna: juz cuz
18:41:28 <p_l> copumpkin: ya rly ;-)
18:41:40 <dankna> well, I've had this debate so many times that I'm not trying very hard, haha
18:42:14 <dankna> I'm just trying to make my perspective on it available for those who are interested, I don't really want to convince anyone, it's not worth it
18:42:16 <Veinor> blah. I'm trying to come up with a good example of currying
18:42:40 <Cale> Yeah, because URIs are generally really long and hard to remember, and we like identifiers which are long and hard to remember.
18:42:52 <dankna> I agree that the specifics of public and private identifiers, and entities and such, are all poor design features
18:42:57 <dankna> my ideal XML would not have those
18:43:40 <dankna> well, the thing with URIs is that anyone can allocate their own identifiers and be sure they aren't conflicting with anybody else's
18:43:45 <kmc> aep, you can wrap forkIO to keep the list
18:43:56 <dankna> the way it works in XML is that you say the full name once at the top of the file and give it an abbreviated name at that point
18:44:13 <Cale> Because there's a huge problem with conflicting identifiers in completely separate pieces of data ;)
18:44:18 <aep> kmc: i dont create them
18:44:26 <dankna> but that's the whole point - you can piggyback your data on someone else's
18:44:34 <dankna> look at what Inkscape does to extend SVG, for example
18:44:50 <dankna> or look at the Dublin Core namespace, which is useful in a wide variety of contexts
18:45:48 <dankna> Inkscape-generated SVGs have information which is just for Inkscape's benefit, yet they are still valid SVGs.  it's similar to Amiga's IFF file format, which is still in use today as well, except it's not a binary format.
18:46:03 <dankna> its advantages are similar, I mean
18:46:09 <dankna> its structure is certainly not
18:47:30 <Cale> I don't think I've once cared how Inkscape stores its files. As long as it can export the format I want, why should I care that its files are SVG compatible?
18:47:41 <dankna> well, that's the counterargument
18:48:01 <dankna> with which I actually agree - in my diagram editor I'm using a private format with SVG as an import/export format
18:48:18 <dankna> but I'm presenting the case as best I can because XML doesn't get a lot of love in the functional-programming community :)
18:49:41 <sm> releases always take 4 times as long as you estimate
18:49:46 <dankna> so true
18:50:53 <Cale> I suppose the argument is that if Inkscape were to just smash a bunch of new identifiers into SVG's namespace, then later on, SVG got new extensions using the same identifiers, there would be a conflict. But if all the new identifiers started with 'inkscape' that seems pretty unlikely.
18:51:12 <dankna> well, that's true.
18:51:37 <Cale> At least, unlikely enough that engineering a complicated solution to it seems like a waste of effort.
18:53:07 <dankna> you're probably right, haha
18:53:40 <Cale> Heh, at least it's probably still better than using GUIDs for everything.
18:53:48 <dankna> there's that
19:02:25 <aep> is an MVar locked after  readMVar?
19:03:17 <kmc> if by "locked" you mean "empty", then no
19:03:18 <Cale> aep: readMVar v = do x <- takeMVar v; putMVar v x; return x
19:04:17 <aep> umm
19:04:38 <aep> i'm trying to debug a deadlock.  might be the MVar, not sure
19:04:48 <Cale> There *is* a race condition possible there, where another thread can possibly fill the MVar in between the take and put
19:05:42 <Cale> If you need more safety, using STM and TMVars is probably a good way to go.
19:05:45 <aep> "x <- readMVar ;  doSomethingWIth x;"   is the mvar still locked in the second expression?
19:05:53 <Cale> What does "locked" mean?
19:06:08 <aep> doesnt it use a mutex?
19:06:12 <Cale> Mutex?
19:06:18 <aep> umm
19:06:23 <Cale> An MVar is either empty or full.
19:06:34 <aep> well it uses some locking mechanism
19:06:38 <Cale> Taking from an empty MVar will wait until it is full
19:06:53 <aep> yes, but readMVar shouldnt make it empty, should it?
19:06:56 <Cale> putting to a full MVar will wait until it is empty
19:07:02 <Cale> It shouldn't
19:07:18 <Cale> readMVar will make it empty very briefly though
19:07:39 <aep> well the deadlock is reproducable 100% of the time
19:07:39 <Cale> It takes the MVar, then puts the value right back, and then returns the value that it saw.
19:07:52 <Cale> If another thread is trying to write the MVar, it might win.
19:08:04 <aep> there is no write happening at all
19:08:15 <aep> just a single readMVar
19:08:23 <aep> which will never finish
19:08:53 <Cale> If you readMVar an MVar, and the MVar is empty, your thread goes to sleep until the MVar is filled.
19:08:59 <aep> i'd use SHM, but it doesnt work inside IO :/
19:09:03 <aep> its not empty afaik
19:09:06 <aep> well it shouldnt
19:09:07 <rostayob> could someone tell me what am I doing wrong here: http://pastebin.com/m4b2f8953 ?
19:09:07 <Cale> STM works in IO
19:09:42 <Cale> You compose STM transactions in the STM monad, and then apply the function atomically :: STM a -> IO a
19:09:49 <Cale> to execute a transaction atomically
19:09:57 <aep> hm
19:10:09 <aep> but i cant use IO within STM
19:10:27 <Cale> rostayob: what is getInput?
19:10:28 <aep> well i might not need to.
19:10:35 <Cale> aep: You should never need to.
19:10:36 <aep> let me read up on that. thanks
19:10:57 <Cale> aep: You can always return an IO action from an STM transaction, to be executed after it is finished, of course.
19:11:24 <aep> hm
19:11:25 <rostayob> Cale: is in the CGI package
19:11:45 <Cale> aep: But generally you want to keep STM transactions short and not do too much stuff inside them.
19:12:13 <rostayob> Cale: if I get just one input is fine, but if I get two it says "no arising istance for (MonadGCI IO)"
19:13:50 <Cale> rostayob: you're using runCGI somewhere later, right?
19:14:00 <rostayob> no wait I got the problem, i was mixing simple monad and cgi monad
19:14:06 <rostayob> the code I posted actually works
19:14:10 <Cale> yeah
19:14:13 <Cale> It looks fine to me
19:14:40 <Cale> If you want to run an IO action from inside the CGI monad, you can use liftIO
19:14:52 <Cale> (which will turn the IO action into a CGI action)
19:15:23 <rostayob> ok thanks
19:15:38 <aep> blackh: i did what you suggested (throw to all threads) but i cant make sense out of the output
19:16:24 <aep> i get tons of these: <Main.ipcfs_fuseRead,MAIN.SYSTEM>  but no trace
19:16:36 <rostayob> Cale: thanks for the tip
19:19:21 <aep> any idea how i can get a stack trace where a thread is currently stuck?
19:19:44 <Cale> "What's a stack trace?" :)
19:20:05 <pikhq> What is this stack of which you speak?
19:20:11 <pikhq> I know only thunks.
19:20:17 <aep> you're kidding, right?
19:20:39 <Cale> Well, there is a stack involved in evaluating Haskell expressions in GHC, but it's not used for what the stack is normally used for.
19:20:40 <pikhq> aep: A stack trace, if you could get it, would not help you much.
19:20:48 <sm> aep: while they're thinking about it, you can start by putting trace statements to narrow it down
19:20:55 <aep> hm
19:20:57 <pikhq> The function responsible could very well already be well off the stack.
19:21:10 <aep> sm: inside the functions? nope. it doesnt deadlock in any of mine
19:21:13 <Cale> (It's essentially used to hold on to case expressions which are waiting to pattern match)
19:21:30 <aep> i have a putStrLn in every single of my functions
19:21:35 <sm> at least narrow down to the lib function
19:21:48 <aep> heh, that would be fuseMain
19:22:04 <aep> which does ALOT of magic in the background inclduing starting zillions of threads
19:22:29 <aep> i know the last call on one of the threads was readChan
19:22:49 <aep> i just can't possible imagine any case where readChan would not return
19:23:27 <aep> and actually i'm guessing here, since my putStrLn calls do not show up before i throw exceptions everywhere
19:23:40 <aep> basicly nothing works before i unstick that single thread
19:23:42 <sm> you could build fuse from source and mess with it (cabal unpack HFuse in your source dir)
19:23:53 <sm> a bit primitive, I know
19:23:56 <Cale> I wonder if GHC could attach a name to each case expression, and put that information into the stack, so that you could at least get a list of the case expressions waiting to pattern match when you got a stack overflow.
19:24:06 <aep> does haskell  really have no debugger?  quite crazy
19:24:15 <sm> it has a debugger, it's documented
19:24:23 <Cale> aep: GHCi contains a debugger, but I haven't really used it much
19:24:39 <aep> it doesnt let me start the app with parameters oO
19:24:45 <sm> sure it does
19:25:09 <aep> hm couldnt find that
19:25:14 <sm> :main arg1 arg2 or something
19:25:20 <Cale>    :set args <arg> ...         set the arguments returned by System.getArgs
19:25:21 <aep> nope
19:25:27 <aep> ah!  thanks Cale
19:25:37 <Cale> (in the :?  output in ghci)
19:25:49 <aep> yeah, sorry :/
19:25:56 <Cale> nah, it's okay :)
19:26:16 <Cale> Another handy trick is to separate out your main
19:26:36 <Cale> So that it immediately does getArgs first thing and then calls a secondary main which takes the result
19:26:59 <Cale> and that way you can just call the secondary main with the appropriate args.
19:27:20 <augur> Cale!
19:27:31 <sm> aep: I suppose it's not using cpu, but if it is you could get a profile
19:27:37 <sm> and see where it's at
19:28:10 <aep> sm: nope.  8 threads on pthread mutex
19:28:13 * sm would get fuse src and fill it with traces
19:28:32 <aep> i know its a deadlock already, but i need to know which haskell function resulted in that
19:28:52 <aep> if "fill with traces" means putStrLn, that doesnt help
19:29:05 <aep> the output doesnt appear while the thread is stuck
19:29:10 <c_wraith> aep: don't you wish you had threadscope?
19:29:18 <aep> whats that? :D
19:29:30 <sm> I mean Debug.Trace (trace), not putStrLn.. don't those appear ?
19:29:33 <c_wraith> a tool for visual analysis of the state of your haskell threads...  for ghc 6.12
19:29:34 <blackh> aep: That means the exception is occurring inside Main.ipcfs_fuseRead
19:29:46 <blackh> (belated reply)
19:30:15 <aep> blackh: i guess thats all detail i will ever get?
19:30:47 <blackh> aep: Well, that tells you where it's happening.  You can get more detail if you add {-# SCC  ... #-} annotations to your code
19:30:55 <blackh> aep: It could be happening in C code
19:31:21 <aep> well that function is where readChan is
19:31:28 <aep> i guess that dies after all :(
19:31:48 <blackh> aep: Don't worry about the stuff everyone is saying about how there's no such thing as a stack trace.  This is true, but the stuff you get when you use +RTS -xc is an approximation to a stack trace
19:32:25 <blackh> aep: The -xc output will only contain the names of top-level functions, and only of functions in modules compiled with -auto-all
19:32:28 <aep> ghci dies with an internal error...  *sigh*
19:33:00 <blackh> aep: You could re-compile some of your dependencies with -prof -auto-all (not sure what cabal's -p option passes to ghc)
19:33:01 <aep> how do you guys debug stuff? :D
19:33:21 <Cale> aep: By breaking it down into smaller pieces which are easily understood.
19:33:22 <aep> yeah i did recompile all deps with -p
19:33:33 <blackh> aep: I don't use ghci's debugger.  Haskell's debugability is not as good as other languages, but then you don't need it as much either.
19:34:04 <aep> Cale: try that with a magic library function which randomly starts hundrets of threads in the background :D
19:34:24 <blackh> there are various projects to improve it
19:34:40 <Cale> If it gets to the point where you feel that your only option is to single step through the execution of your program watching everything that's going on, then something seriously wrong has happened in the design.
19:34:53 <c_wraith> oh, hell.  Contention in a QSem leads to unnecessary wait.
19:35:00 <aep> is there any possible bad thing i might have done to deadlock CHan ?
19:35:28 <aep> all i do is readChan on one thread and writeChan on the other. both calls never return
19:35:43 <blackh> aep: That shouldn't happen
19:35:51 <o^_^o> hey guys
19:35:54 <sm> blackh: I used +RTS -xc the other day. It gave me three different traces, none of which turned out to be where the problem was :/
19:35:57 <Cale> aep: Do you ever isEmptyChan?
19:36:04 <aep> no
19:36:15 <c_wraith> err.  I should rephrase that.  appending to the list of waiting processes is O(number of waiting processes).  boo!
19:36:22 <Cale> (because it can block, irritatingly)
19:36:36 <blackh> sm: Actually now that you mention it, I think I've had -xc not tell me where the problem was, but in a lot of cases it worked.
19:36:41 <o^_^o> <non haskell question> Do you guys know any online courses which teaches computer algorithms ?</non haskell question>
19:36:42 <monochrom> Create two Chan's b,c. One thread read from b then write to c. One thread read from c then write to b. They will wait forever.
19:37:06 <aep> well that is obvious
19:37:11 <c_wraith> monochrom, external deadlocks aren't the fault of Chan
19:37:19 <monochrom> Create one Chan b. A thread read from b then write to b. It will wait forever.
19:37:29 <sm> o^_^o: check eg MIT's free courses
19:37:47 <monochrom> Anyway, unit testing > debugging.
19:37:47 <aep> monochrom: err. really?
19:38:01 <ddarius> o^_^o: There's video for a course on algorithms by Leiserson.
19:38:11 <o^_^o> sm: I did, I am looking for anything other than the MIT one.
19:38:16 <monochrom> If there is a magic lib doing funny things and screws you, don't use that lib.
19:38:18 <ddarius> o^_^o: That's the MIT one.
19:38:42 <sm> monochrom: there's something to be said for that
19:39:05 <blackh> monochrom: No! Debug it and send the maintainer a patch!
19:39:08 <o^_^o> ddarius, yes
19:39:28 <aep> yeah i think i'll just give up. i am unable to debug this at all
19:39:55 <Cale> aep: You could put the code somewhere that we could see it
19:40:06 <aep> sure.
19:40:14 <blackh> aep: I might look at it some time - I want to do something with fuse
19:40:15 <monochrom> blackh: If the lib is unit-testable rather than an inpenetrable monolith.
19:40:35 <kmc> hmm, i'm implementing a pi calculus interpreter, and i seem to want a datatype like (Mu Chan)
19:40:38 <kmc> this seems absurd
19:40:52 <kmc> @hoogle Mu
19:40:52 <lambdabot> Text.Html multiple :: HtmlAttr
19:40:52 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
19:40:52 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
19:41:18 <aep> Cale: the relavant line is 113 and 129. those two never return.  http://codepad.org/d1YOx0w8
19:41:23 <ddarius> kmc: What's absurd about that?
19:41:27 <o^_^o> hmmm...from the time I started learning haskell all my bookmarks for the past 4 months has been only haskell related :-)
19:41:47 <kmc> it's chans all the way down
19:42:55 <blackh> aep: How do you know that they're on different threads?
19:43:05 <ddarius> kmc: You can add other types if you want to handle other types as well, but I don't think you -need- them in theory.
19:43:21 <ddarius> kmc: The pi-calculus thing I did a long time ago was an embedding into (Concurrent) Haskell.
19:43:44 <aep> blackh: i print the threadID, but there is no guarantee those are OS threads of course
19:43:48 <o^_^o> any other online courses other than MIT ?
19:43:54 <kmc> ddarius, yeah, i was thinking to do that next
19:44:01 <ddarius> o^_^o: Probably tons.
19:44:24 <o^_^o> ddarius, how come I keep running into pay walls :-(
19:44:29 <o^_^o> maybe my google foo is weak
19:44:39 <Cale> aep: Hmm... is it really desirable to write sequences of individual Word8's to the Chan like that? Chans are quite capable of more complicated message types.
19:45:12 <ddarius> o^_^o: Look up lecture notes.
19:45:12 <aep> Cale: its all i get from fuse, so yes
19:45:23 <Cale> okay
19:45:24 <ddarius> o^_^o: Or just sign up for a course somewhere.
19:45:32 <blackh> aep: One thing you need to watch with FFI code is thread starvation.  Sometimes the C code gobbles up all your worker threads.  I've had this.
19:45:46 <o^_^o> ddarius, thanks
19:46:02 <blackh> aep: Whenever you use a "safe" FFI function, it makes that worker thread unavailable while you're in C land, which can be a problem if the C code blocks.
19:46:30 <sm> aep:  isn't "the duplicate channel begins empty, but data written to either channel from then on will be available from both" an issue here ?
19:47:15 <aep> sm: i just added that dup for debugging. deadlocks without too. also write is invoked after read
19:47:37 <aep> if write is invoked first,  write returns fine and read deadlocks without any other thread running at all
19:48:10 <Cale> aep: Is there a good reason that you duplicate a channel just before reading it?
19:48:17 <Cale> c <- dupChan chan
19:48:20 <Cale> readChan c
19:48:20 <aep> sm just asked that. no.
19:48:28 <aep> thats just debugging
19:48:41 <Cale> It will always block until something writes to chan, since the new channel begins empty.
19:49:00 <Cale> So even if there was already an item waiting on chan, that item won't show up in c
19:49:02 <aep> removing it doesnt solve the problem
19:49:05 <Cale> okay
19:49:15 <sm> there might be more than one problem
19:49:21 <sm> just sayin
19:49:25 <aep> nothing ever shows up btw, even when writing to the chan from the same thread right before read
19:49:36 <aep> it'll still die
19:49:52 <blackh> aep: An easy thing to try would be to add "forkOS $ forever $ threadSleep 10000000" at the beginning of your program - in case your problem is thread starvation
19:49:58 <sm> as a sanity test, this similar code works: http://joyful.com/repos/rss2irc/rss2irc.hs
19:50:20 <aep> blackh: let me try.  what is supposed to happen?
19:50:51 <blackh> aep: What that does is make a new OS thread but give it no Haskell work to do.  Then GHC always has somewhere to run its green threads.
19:51:01 <kmc> uh
19:51:09 <Cale> Are you certain that you really need forkOS rather than forkIO?
19:51:12 <kmc> i don't think forkOS creates a thread which can do Haskell work
19:51:14 <Cale> (at all)
19:51:36 <Cale> hmm, maybe for fuse
19:51:42 <blackh> kmc: I think I am right.
19:51:46 <blackh> aep: Are you compiling with -threaded ?
19:51:48 <kmc> it creates a thread which will do FFI calls on behalf of some green thread
19:51:50 <aep> blackh: yes
19:51:53 <kmc> i don't think that thread can participate in MUT
19:52:12 <Saizan> i don't think it necessarily creates a new OS thread at all
19:52:26 <Cale> It creates a bound Haskell thread.
19:52:33 <blackh> kmc: It would be easy enough to devise an experiment to test it.  You can easily starve an OS thread by making an FFI call to 'usleep'
19:53:32 <kmc> Saizan, yes, if it can satisfy the guarantees another way
19:54:55 <blackh> kmc: A "safe" FFI call, I am talking about.  So - I think forkOS creates a thread that can participate in MUT.  We should test tis.
19:55:53 <blackh> I'm doing it...
19:59:34 <aep> maybe a chan is just crazy
20:00:03 <aep> if i stick 4 bytes in and let 6 threads read from it, exactly the first and the last get stuck
20:00:06 <aep> always
20:00:13 <aep> while i would expect the last 2 to wait
20:01:13 <Cale> aep: It will be random.
20:01:30 <aep> nope.  reproduceable exactly the same behaviour
20:01:33 <blackh> kmc: As much as I hate to admit it, you were right.
20:01:39 <blackh> Results of my testing:
20:01:41 <Cale> aep: That's just luck :)
20:01:54 <aep> i tried 10 times :D
20:02:01 <monochrom> There is no "first" and "last" anyway.
20:02:03 <blackh> 1. An unsafe FFI call that blocks can block MUT
20:02:20 <Cale> aep: The threads that you start aren't ordered in any meaningful way.
20:02:21 <blackh> 2. Even if you add "forkOS $ forever $ threadDelay 10000000" at the start, it still blocks MUT
20:02:27 <aep> and it repeats the pattern.   once the chan is empty again, the first read will get stuck, then the second will work
20:02:32 <blackh> 3. Making the FFI call safe fixes it
20:02:43 <aep> Cale: they are, i invoke them externaly
20:02:51 <blackh> aep: Check any FFI calls in fuse that might block and make sure they're 'safe'
20:03:18 <aep> err, there is only one api call to fuse and that does block, yes
20:03:22 <aep> thats fuseMain
20:03:25 <blackh> 3. Making the FFI call safe fixes it, even if you have not done any forkOS
20:03:40 <blackh> aep: Is it declared safe or unsafe?
20:03:50 <aep> umm
20:03:53 <aep> let me grab the source
20:03:57 <Cale> All the foreign imports in the HFuse source appear to be marked "threadsafe"
20:04:40 <sm> taruti would know
20:06:10 <aep> yeah, all "threadsafe"
20:06:40 <blackh> In my experiment, threadsafe behaves the same as safe. So I don't think that's it.
20:07:15 <blackh> So I believe that only an unsafe call can block the runtime system
20:07:30 <aep> well, there are callbacks...
20:07:38 <aep> the C code calls haskell functions
20:07:52 <aep> from random undefined threads
20:08:02 <blackh> That should be OK.  The FFI documentation says that the call has to be safe, but we know that it is.
20:08:10 <blackh> (the call that goes out to C)
20:09:44 <aep> i still think i missuse Chan. its seems to act completely predictable broken
20:10:52 <aep> write(works);write(works); read(dead);read(works);read(works);read(dead);
20:11:06 <aep> and then write(dead);
20:11:13 <aep> but the next write works again
20:11:17 <aep> its crazy
20:11:29 <blackh> aep: write(dead) is suspicious because Chans are queues - writes shouldn't block
20:11:58 <aep> maybe it didnt die there then. i really have no clue since i dont have any hints where exactly it is stuck
20:12:14 <aep> a step by step debugger would help i guess
20:12:31 <blackh> aep: put a putStrLn both before and after every read and write
20:12:39 <aep> those never print
20:13:16 <sm> trace!
20:13:18 <kmc> blackh, i wouldn't have been sure, except that it came up a few days ago and i ran the test ;)
20:13:27 <monochrom> do { c<-newChan; writeChan c (); readChan c; putStrLn "done" }   you mean even something simple like this dies?
20:13:35 <aep> sm: i wish there was any
20:14:11 <aep> monochrom: yes.
20:14:30 <aep> only on one of the fuse stareted threads though
20:14:58 <aep> actually, let me try creating the chan in the same thread as well
20:14:59 <sm> aep: how come you can't put trace calls in fuse ? That's a poor man's step-by-step debugger imho
20:15:35 <aep> sm: i dunno where actually. HFuse seems to be a tiny wrapper around fuse itself
20:17:10 <sm> ok then I guess it would have to be printf statements in the c lib.. or some kind of gdb invocation..
20:17:29 <sm> don't you wish you had python's pdb.set_trace()
20:19:04 <aep> ummm
20:19:10 <aep> it works all fine now
20:19:17 <aep> .. the hell?
20:20:06 <monochrom> you modified, saved, recompiled.
20:20:23 <aep> yeah
20:21:21 <monochrom> Blame it on NFS not synchronizing :)
20:22:02 <aep> apparantly you cannot read from a chan before writing to it at all?
20:22:27 <monochrom> Can. The reader will wait for a writer.
20:22:50 <aep> well in my case they both wait for each other
20:23:17 <monochrom> "obviously"
20:23:17 <Cale> Writing to a Chan should never block
20:23:46 <monochrom> Oh, writer waits? No, writer does not wait.
20:26:07 <sm> odd that the chan haddock doesn't mention blocking at all
20:26:39 <Cale> Especially odd that it doesn't mention that isEmptyChan can block when it's totally not obvious that it should.
20:27:02 <kmc> how can it block?
20:27:19 <aep> is there something similar to chan?
20:27:25 <Cale> I believe it was if there was a reader blocking on an empty chan and you call isEmptyChan, it will block
20:28:13 <blackh> Anyone who reads the same chan on two threads deserves that.
20:28:37 <Cale> ghci> c <- newChan :: IO (Chan ())
20:28:37 <Cale> ghci> forkIO (readChan c)
20:28:37 <Cale> ThreadId 298
20:28:37 <Cale> ghci> isEmptyChan c
20:28:40 <Cale> <blocked> :)
20:29:41 <sm> there's STM's TChan
20:29:49 <Cale> Yeah, TChan is saner.
20:30:37 <aep> k, thanks
20:31:04 <sm> doesn't mention blocking either. And brings in another monad
20:31:33 <Cale> Yeah, because it doesn't block.
20:31:41 <monochrom> moar monads
20:31:43 <sm> aha
20:31:43 <Cale> STM transactions happen atomically
20:32:19 <Cale> and the obvious behaviour would just retry if the TChan was empty on a read
20:32:41 <Cale> (so only in that sense it "blocks")
20:32:48 <sjanssen> TChan is nice but can't give the same fairness guarantees as Chan
20:37:45 <o^_^o> I've to get on some VPN, so logging off for now
20:55:46 <aep> blackh, Cale: -o direct_io  fixed it
20:56:59 <kmc> i'm really enjoying imperative programming in haskell
20:57:26 <absentia> ya, I really enjoyed it the 6th time I read it too!
20:57:31 <kmc> oh that's a paper / book?
20:57:57 <monochrom> I watched it 7 times in cinemas.
20:58:22 <kmc> heh, i was just talking about the act
20:58:42 <aep> you perv
20:58:43 <monochrom> The cinema pirated it.
20:58:47 <blackh> aep: Thanks for that
20:58:57 <aep> blackh: its crazy though
20:59:06 <aep> this shouldnt have any effect on threading
20:59:27 <aep> oh well, ping me when you have inisghts into it :D
20:59:37 <aep> for now i'm happy
22:05:57 <mreh> :t (>>>)
22:05:58 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:06:27 <mreh> :t :Arrow (>>>)
22:06:28 <lambdabot> parse error on input `:'
22:06:33 <mreh> what's the syntax?
22:06:43 <mreh> :t Arrow: (>>>)
22:06:44 <lambdabot> Not in scope: data constructor `Arrow'
22:07:33 <mreh> anyway, the cats just get replaces by (Arrow a)
22:07:47 <mreh> :t arr
22:07:48 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
22:08:50 <mreh> gah! there's tea in my trackpad!
22:10:54 <SubStack> blarg haskell regexps are too verbose
22:11:05 * SubStack makes a note to hack on this
22:11:21 <SubStack> in particular substitutions
22:11:40 * Hunner is drawing a blank. How would I return a given array with one element changed? like "f arr x val = change (arr !! x) val" where arr is [a] and I want to return [a]?
22:12:55 <Hunner> s/array/list/g :P
22:13:52 <SubStack> > \str i c -> (take (i-1) str) ++ c : drop i str $ "lamdda" 4 'b'
22:13:53 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
22:14:22 <SubStack> stupid parens
22:14:27 <SubStack> > (\str i c -> (take (i-1) str) ++ c : drop i str) "lamdda" 4 'b'
22:14:28 <lambdabot>   "lambda"
22:14:59 <SubStack> ^ Hunner
22:15:45 * Hunner was thinking something recursive with head and tail. Thanks
22:16:16 <SubStack> probably there's a nicer way to write that too
22:16:25 <SubStack> should get you started anyways though
22:16:28 <Hunner> You're is more concise that I was thinking, but yes, it's a bit ugly :P
22:16:55 <ddarius> See splitAt.
22:17:03 <SubStack> oh right that
22:17:10 <ddarius> However, updating an element of a list is not a very sensible thing to do...
22:17:19 <SubStack> it's true
22:17:28 <SubStack> there are better data structures for that sort of thing
22:17:46 <SubStack> like maps or Array-ish types
22:18:00 <Hunner> ddarius: I have a 2D map represented as a list of lists and I want to 'modify' an x,y in it
22:18:10 <pikhq> There's also more efficient functions for that.
22:18:35 * Hunner is open to suggestions
22:19:09 <ddarius> Hunner: Think in "whole map" operations.
22:20:06 <pikhq> Hunner: Much easier to make a change to an entire list than it is to a specific element.
22:20:12 * Hunner is still thinking 'masking bits' like in C >_<
22:22:24 <mtnviewmark> I'm looking for information about linking against external libraries
22:22:30 <mtnviewmark> when building a package
22:22:35 <bos> you have come to the right place, o supplicant.
22:22:36 <SubStack> hmmm hTensor looks nifty for multidimensional arrays
22:23:09 <Hunner> @hoogle hTensor
22:23:09 <lambdabot> No results found
22:23:14 <mtnviewmark> so, a package I'm building adds the following    -lmygcc
22:23:21 <mtnviewmark> which is a lib that is provided by MySQL
22:23:31 <SubStack> hoogle is annoyingly incomplete
22:23:32 <mtnviewmark> But it is a static lib, not dynamic
22:23:45 <bos> really?
22:23:49 <mtnviewmark> everything builds ---- but if I load that package into ghci
22:23:49 <bos> eek.
22:23:59 <mtnviewmark> then ghci looks for the dynamic version of that lib
22:24:36 <bos> yeah, the staticness of the library may be the problem.
22:24:59 <mtnviewmark> so -- is that a general issue --- if I have a package that needs to link against a lib from some non-haskell system - and that lib is static only --- do things get bork'd
22:25:04 <bos> can you build executables that work?
22:25:10 <mtnviewmark> didn't try
22:25:16 <bos> give it a quick whirl.
22:25:23 <bos> most libraries on OS X are built as dylibs.
22:25:37 <mtnviewmark> well - will try tomorrow (as my set up for that is on my work machine)
22:25:39 <bos> static libraries are an unusual beast there.
22:25:41 <bos> ah.
22:25:46 <mtnviewmark> well, mysql distributes that one as statkc
22:26:27 <mtnviewmark> I see about 20 or so in /usr/lib, acutally
22:26:37 <mtnviewmark> odbc among them!
22:27:48 <mtnviewmark> so - does ghc stash the libraries needed for linking somewhere in the .o file, and reextract them out again when building an executable
22:27:59 <mtnviewmark> or does it expect you repeat the full needed list when buliding?
22:28:17 <mtnviewmark> and is ghci then just using htat list and trying to dynamic link 'em?
22:28:57 <pikhq> mtnviewmark: Pretty sure module dependencies are in .hi files.
22:29:19 <mtnviewmark> these are dependencies on external, non Haskell libraries I'm referring to
22:29:33 <mtnviewmark> would those be in the .hi files?
22:30:06 <mtnviewmark> aha! And now I see why HDBC-mysql used to work, and now breaks
22:30:12 <mtnviewmark> !!!
22:30:22 <bos> dependencies on libraries are, i believe, in the .cabal file
22:30:37 <mtnviewmark> it uses mysql_config --libs to determine the list of libraries to use (it has a custome Setup.hs file)
22:30:45 <bos> i don't know where they're stored otherwise, perhaps in the package description
22:30:56 <mtnviewmark> and "mysql_config --libs" on older mysql doesn't list that static-only lib
22:30:58 <bos> but i don't believe that .hi or .o files know about them
22:31:33 <mtnviewmark> they where is ghci getting the notion to try to dynamically load that lib? since surely the static lib doesn't ahven't stubs that load it dynamically
22:32:21 <mtnviewmark> s/they/then/
22:33:42 <mtnviewmark> ah well - the workaround is to put a wrapper around mysql_config that doesn't list that library ... but it doesn't leave me feeling like I understand how it weaves together
22:38:30 <dons> sounds like time to shut down uvector, if roman thinks if vector is ready  to go live.
22:38:44 <bos> yay convergence!
22:38:53 <dons> i guess it filled the gap for the last couple of years, waiting for vector to be done. and vector has the better namespace
22:39:11 <bos> it was a very worthwhile thing to have around for a long time.
22:39:14 <dons> he's done many months of work on it in those two years too -- so i think it is worthwhile.
22:39:33 <dons> e.g. i didn't know we didn't need the strict tuples. need to pick his brain about that.
22:41:33 <bos> dons: thanks for keeping the uvector flame alive~
22:42:32 <dons> i'm happy that vector is ready!
22:42:44 <dons> so now we need to start taking it for a test run.
22:42:46 <bos> me too!
22:43:17 <dons> it'll be interesting to see if we can get rl engaged in maintainance, that might be a bit more difficult, due to his research focus.
22:43:54 <dons> but sounds like max got some patches in, so good sign.
22:44:02 <mtnviewmark> bos - saw your Hackathon note - count me n
22:44:04 <mtnviewmark> me in
22:44:08 <bos> mtnviewmark: cool!
22:44:18 <dons> there's a pdx hackathon planned for april
22:44:24 * dons reads email
22:44:34 <bos> dons: thinking of an SF one at the beginning of may
22:44:49 <bos> i'd move the date if i thought any PDXers might visit (hint, hint)
22:45:17 * bos offers tempting visions of san francisco coffee, beer, and vegan food
22:46:53 <mtnviewmark> I'm looking at the image of Hac5...... Dang, we need more women coding Haskell
22:46:56 <dons> we could prob. get quite a few done there.
22:47:02 <dons> down.
22:47:06 <dons> hackers, that is.
22:47:13 <dons> any gender.
22:47:32 <dons> bos: we'll see if tom and creighton are willing to head down. if so, i'm in for SF.
22:47:50 <dons> i might come down anyway :)
22:48:48 <bos> dons: cool!
22:49:01 <bos> dons: you want to pass the word around among PDXers, then?
22:49:10 <bos> dons: and let them know we can be flexible on dates
22:49:19 <dons> yep. CC'd the organizers.
22:49:23 <bos> thanks!
22:49:29 <dons> also we're in #pdxfunc
22:49:34 <bos> cool
22:49:37 <dons> well, some of them.
22:49:49 <dons> mostly PSU and Galois folks.
22:50:03 <dons> yay for grad students
22:50:16 <bos> ah, cheap slave labour.
22:50:27 <mtnviewmark> I wonder - in conjunction with a Hackathon - perhaps we could run a "teach you a Haskell" night at some place like Hat Factory or Hacker Dojo
22:50:28 <bos> holy cow!
22:50:49 <bos> now that i finally have the internals of my attoparsec rewrite somewhat sane, it's ... nice and fast.
22:51:00 <dons> oh good
22:51:13 <bos> 70x faster than the previous version.
22:51:33 <dons> hehe. yes, i remember you were concerned about the old version.
22:51:42 <dons> might be fun to post some comparative stuff wrt. parsec 3.
22:51:54 <dons> do we have a Data.Text-based parser ?
22:52:16 <dolio> I guess I'd better get to work on vector-algorithms.
22:52:28 <altmattr> http://pastie.org/821394
22:52:55 <altmattr> applyToInner can't be written with SYB becuase you can't use mkT on (a -> b), only (a -> a).
22:53:10 <altmattr> is there another generics library that will allow this?
22:53:14 <altmattr> or a way to do it in SYB?
22:53:44 <bos> dons: not yet.
22:53:54 <bos> dons: porting parsec3 to use it should be easy.
22:54:05 <bos> dons: and i might do an attoparsec port after this is out of the way.
22:54:16 <bos> mtnviewmark: i think that would be a good idea
22:54:33 <bos> mtnviewmark: tibbe was telling me that 73 people are coming to the zurich hac!
22:54:36 <bos> dons: ^^
22:54:40 <mtnviewmark> wow!
22:54:44 <mtnviewmark> that's quite a bit
22:54:48 <bos> mtnviewmark: a bunch of newcomers
22:54:59 <dreixel> altmattr: mkQ ?
22:55:14 <altmattr> that accumulates doesn't it?
22:55:20 <altmattr> I still need to translate
22:55:21 <dreixel> no...
22:55:37 <dreixel> you probably also want everything instead of everywhere
22:55:57 <dons> crikey.
22:56:01 <dolio> bos: You know where the vector HEAD is?
22:56:04 <dons> 73 at google zurich. i hope we all fit.
22:56:18 <mtnviewmark> It would be fun, I think, to take your class slides from this Fall and rework and see how far you could take a group if you assumed they all had computers with them -- and you had a team of Haskeller's roving among them
22:56:27 <bos> dons: are you going to zurich?
22:56:27 <dons>   http://www.cse.unsw.edu.au/~rl/code/darcs/vector
22:56:30 <dons> yeah
22:56:31 <dreixel> oh, wait, I'm seeing your code now
22:56:36 <bos> dons: nice
22:56:41 <mtnviewmark> kind of like "community service" --
22:56:44 <dreixel> applyToInner :: (a -> b) -> Lit a -> Lit b
22:56:44 <dons> i love the euro hackathons. been going for 3 years now
22:56:46 <bos> dolio: rl posted the URL somewhere in the thread
22:56:48 <dreixel> what you want is basically fmap.
22:56:56 <altmattr> dreixel: thankyou, is that the only difference between the two?
22:57:09 <altmattr> dreixel: I still find SYB confusing :(
22:57:10 <dreixel> altmattr: are you using GHC 6.12? You can just use deriving Functor
22:57:15 <dons> dolio: we need a public repo though. i think rl would be happy with that (the dph ones are in ghc head for example)
22:57:18 <altmattr> dreixel: but it is so damn great
22:57:43 <bos> it used to be on darcs.h.o, but the url isn't there any more
22:57:43 <altmattr> dreixel: nope, 6.10
22:57:50 <bos> rl said he was getting a c.h.o account
22:57:58 <dons> i have careful scripts in uvector for testing that   the fusion rules fire. i hope i can port those.
22:58:07 <bos> yay, continuation based attoparsec is faster than plain parsec. finally.
22:58:10 <dolio> dons: I just need the HEAD to make sure I'm porting to the proper API. 0.4.2 on hackage doesn't appear to contain the uvector-like unboxed arrays, for instance.
22:58:10 <dreixel> altmattr: for this, at least. If you are doing other traversals then you might want to use SYB. Basically, if you are doing things of the form Lit a -> b, then you should use everything and mkQ, if you are doing things of the form Lit a -> Lit a then you use everywhere and mkT.
22:58:20 <dons> dolio:  http://www.cse.unsw.edu.au/~rl/code/darcs/vector
22:58:29 <dons> 0.5 coming out soon, apparently.
22:58:50 <altmattr> dreixel: I *am* doing Lit a-> Lit a
22:58:56 <dons> time to start writing native haskell numerics stuff, i guess :)
22:59:06 <dreixel> altmattr: no, it's Lit a -> Lit *b*
22:59:08 <altmattr> dreixel: and everwhere and mkT won't work
22:59:37 <altmattr> sorry, did you mean Lit a -> *Lit* b uses mkQ?
23:00:26 <dreixel> altmattr: no, that you can do simply by using the fmap method of the Functor class: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html#v:fmap
23:01:13 <altmattr> OK, so back to the original question.  SYB cannot help me write (a -> b) -> Lit a -> Lit b, or can it?
23:03:22 <dreixel> altmattr: in general I don't think that can be done easily, no.
23:04:35 <altmattr> dreixel: so I should just derive Functor instead - which seems nice and easy
23:04:55 <altmattr> what other derives snuck in without me noticing? (obviously you can't know that)!
23:05:02 <dreixel> altmattr: yes, but you need 6.12 to derive Functor.
23:05:10 <dreixel> altmattr: also Traversable, I think.
23:05:20 <altmattr> I need to make the instance by hand on 6.10?
23:05:29 <dreixel> altmattr: yes.
23:06:07 <altmattr> strange that the other SYB stuff would get in with that big gap - and that it would be filled so much later
23:06:28 <dreixel> altmattr: see section 1.5.2 in http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-1.html and http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/deriving.html#deriving-typeable
23:08:00 <altmattr> does anyone know why gmap is contrained to (a -> a) while fmap is free of the same constraint?
23:09:20 <dreixel> altmattr: which gmap?
23:09:51 <altmattr> well, I mean, SYB can't do it (isn't gmap the generic map of SYB)
23:11:12 <dreixel> altmattr: ah, ok. Well, I'm afraid that's not very easy to explain, it has to do with the generic view of SYB not really knowing about type parameters...
23:11:47 <altmattr> dreixel: nuff said :)
23:12:19 <altmattr> dreixel: so is Functor a 'better' approach? Or more constrained in other ways? etc?
23:12:30 <altmattr> to generics in general I mean
23:13:03 <dreixel> altmattr: for what you are trying to do here, Functor is what you want. But that's just it: Functor will not help you in doing, for instance, Lit a -> Lit a transformations, or Lit a -> Int, say
23:13:32 <altmattr> dreixel: right.  Thanks for the lesson, I am one step closer to understanding this stuff :)
23:14:46 <dreixel> altmattr: I suggest http://www.cs.uu.nl/research/techreps/UU-CS-2008-025.html for reading about generics in Haskell in general and SYB in particular, if you want. It also has exercises and solutions (disclaimer: I'm one of the authors)
23:34:29 <mreh> when has an author ever pushed his own material on anyone?
23:51:53 <dreixel> well I obviously think my material is the best for understanding this stuff :p
23:52:13 <mreh> would "this = this" be considered an infinite type?
23:52:20 <dreixel> now seriously, on the wiki page (which I also wrote, actually) http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB you can find links to other documentation sources, namely the original papers
23:52:22 <mreh> if this is a binding
23:55:53 <kmc> :t let this = this in this
23:55:54 <lambdabot> forall t. t
23:56:12 <kmc> the type is finite
23:56:30 <kmc> with "x = x" the only constraint the type inference sees is "x has the same type as x"
23:56:34 <kmc> which is trivially true
23:56:44 <kmc> so it infers the maximally general type for x
23:56:53 <kmc> here is an infinite type
23:56:56 <kmc> :t let x = [x] in x
23:56:57 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
23:56:57 <lambdabot>       Expected type: t
23:56:57 <lambdabot>       Inferred type: [t]
23:57:39 <kmc> as you can see, it infers that x has some type t, subject to the constraint that t = [t]
23:58:26 <kmc> in Haskell's type inference (though not in all systems), such constraints will cause an error during type checking
23:59:18 <kmc> :t In [] :: (Mu [])
23:59:19 <lambdabot> Mu []
23:59:22 <ski> (and this is by design)
