00:07:16 <coppro> @pl (\x -> y x >>= z)
00:07:17 <lambdabot> (z =<<) . y
00:08:29 <coppro> @pl \x -> if f x then y else z
00:08:30 <lambdabot> flip (flip if' y . f) z
00:08:58 <olsner> @pl \x y z -> if f x then y else z
00:08:58 <lambdabot> if' . f
00:09:11 <coppro> which module is if' in ?
00:09:23 <olsner> just in lambdabot, probably
00:13:20 <coppro> @pl \z -> x y z
00:13:21 <lambdabot> x y
00:13:30 <coppro> @pl \f z -> f x y z
00:13:30 <lambdabot> flip ($ x) y
00:28:07 <kniu> :t foldr (+)
00:28:08 <lambdabot> forall a. (Num a) => a -> [a] -> a
01:14:13 <pozic> How can I refer to a Haskell symbol named foo in CPP output where the name of the CPP symbol is also foo?
01:31:09 <Itkovian> Trying to figure out this haxr thingie.
01:32:33 <fasta> What is the status of Leksah? Does it have any users?
01:36:47 <quicksilver> fasta: I don't recall hearing any chat about using it here. Which is not quite the same as "no" but it certainly implies "not many"
01:37:18 <fasta> quicksilver, I just fixed the build and now I find out there is another darcs repository...
01:37:30 <fasta> quicksilver, really, people should learn to manage their projects.
01:37:33 <quicksilver> indeed.
01:37:38 <quicksilver> I think there is probably a mailing list.
01:37:49 <Baughn> gtk2hs still doesn't have an official 6.12 release, so..
01:37:56 <fasta> quicksilver, yes, there is, but I shouldn't have to talk to anyone to get the source.
01:38:05 * Baughn was planning to test leksah a while ago but ran into that, and lacks the motivation to use patches
01:38:11 <fasta> Baughn, I am using 6.10.4
01:38:51 <Baughn> fasta: But you can't say (((foo -> bar) -> baz) -> taz) in 6.10 without getting lots of warnings! ;_;
01:38:57 * Baughn ponders
01:39:16 <quicksilver> view pattern rather than polymorphic type, presumably?
01:39:20 <Baughn> Mm
01:39:33 <Baughn> > (\((+) -> a) -> (a 1, a 2)) 3
01:39:35 <lambdabot>   Illegal view pattern:  ((+) -> a)
01:39:35 <lambdabot>  Use -XViewPatterns to enable view patterns
01:39:37 <fasta> Leksah runs, but I don't see any of my modules listed.
01:39:39 <Baughn> Aww
01:39:53 <fasta> I gave it the path to the root dir of all the sources.
01:40:22 <Itkovian> Anybody any clue where the haxr examples can be found? The URLs at http://www.haskell.org/haxr/ point to nowhere.
01:43:17 <fasta> Hmm, in fact the author was not wrong. The wiki is.
01:43:23 <xerox> > (do { a <- (+); return (a 1, a 2) }) 3 -- Baughn
01:43:24 <lambdabot>   (4,5)
01:43:25 <xerox> :D
01:45:27 <Baughn> xerox: Not really the same thing at all. -_-
01:45:31 <xerox> :(
01:45:53 <Baughn> xerox: http://www.theculture.org/rich/sharpblue/archives/000089.html <-- As punishment, read and understand this.
01:46:39 <osaunders> Where is config.log for cabal typically kept if it's not in ~/.cabal/logs ?
01:46:44 <xerox> pretty pictures!
01:47:03 <Baughn> ..well, at least he didn't go "Shiny!".
01:47:34 * xerox puts Baughn outside his light cone
01:47:41 <osaunders> First comment "My God! What gorgeous diagrams! Sorry... what was the point you were trying to explain again?"
01:48:15 <sinelaw> link?
01:48:37 <osaunders> Look upward
01:48:46 <sinelaw> osaunders, i just entered
01:48:51 <fasta> Successfully sent patch bundle to: info@leksah.org.
01:48:57 <quicksilver> fasta++
01:49:05 <osaunders> http://www.theculture.org/rich/sharpblue/archives/000089.html#comment-121
01:50:10 <sinelaw> not bad, but that comment made me expect something nicer :)
01:50:24 <sinelaw> fasta, how's leksah nowadays?
01:50:47 <Itkovian> Baughn: Nice blog, thx for pointing out.
01:51:22 <fasta> sinelaw, if version control systems worked instantly, it builds and I think it is the best IDE thus far (excluding things which are not IDEs, like Emacs, etc.).
01:51:48 <sinelaw> what's your patch about?
01:51:51 <fasta> sinelaw, just throwing an existing project onto it, doesn't seem to work, though.
01:52:03 <fasta> sinelaw, trivial, uninteresting stuff to make it build.
01:52:13 <sinelaw> ah ok. so it won't build out of the darcs box?
01:52:23 <fasta> sinelaw, not here.
01:52:32 <sinelaw> i'lll try now
01:52:41 <fasta> sinelaw, that won't work.
01:52:51 <fasta> sinelaw, since, I cannot commit to the main repository.
01:54:33 <osaunders> There's a syntax error in conftest.c in readline when I try to cabal install it :-(
01:56:07 <fasta> osaunders, which OS?
01:56:16 <osaunders> Darwin.
01:58:34 <Itkovian> Seems like haxr now lives at http://code.haskell.org/haxr/
01:59:21 <Itkovian> anybody care to update the hackage DB entry and the wiki at http://www.haskell.org/haskellwiki/Applications_and_libraries/Web_programming#XML-RPC_and_CORBA?
01:59:28 <fasta> I think something like the architecture of SLIME is a much better way to go forward. Monolithic IDEs are simply abandoned after the initial developer moves on. If a tool does something useful, it won't get abandoned.
01:59:43 <sinelaw> SLIME?
01:59:47 <fasta> Currently, Leksah does nothing useful as far as I am concerned.
01:59:52 <Itkovian> Hmm, seems I do have a wiki account :-)
01:59:56 <quicksilver> fasta: possibly nominolo's scion is a better architecture?
02:00:07 <fasta> The debugging interface looked interesting, but it didn't actually work.
02:00:10 <Baughn> sinelaw: Agreed. That's where I'm taking haskell-mode, long term.
02:00:15 <Baughn> Er, fasta
02:00:18 <quicksilver> but until you have a critical mass of interested developers
02:00:24 <fasta> quicksilver, AFAIK, scion stole SLIME's architecture.
02:00:27 <quicksilver> stuff is at risk of abandonment
02:00:34 <quicksilver> fasta: good. I'll take that as "yes" :)
02:00:57 <Baughn> With a SLIME-like architecture, you'd have most of the code shared between multiple IDEs, so it doesn't matter which one becomes popular
02:00:59 <fasta> quicksilver, and by "stole" I meant "copied intelligently".
02:01:03 <fasta> haha
02:01:42 <sinelaw> fasta, so it's the best IDE but does nothing useful?
02:02:28 <fasta> sinelaw, yep. I am not known to be impressed by any of the IDEs put forward over the years.
02:02:35 <Baughn> Mm. The state of the art in haskell IDEs is unimpressive.
02:02:44 <Baughn> I wouldn't even call haskell-mode an IDE
02:05:23 <bastl> fasta: can you give some reference to "SLIME"?
02:05:30 <fasta> An IDE has smart parsing algorithms, its own type-inference engine, an integrated debugger, uses inotify to track changed files, integrates with already existing build systems and has the magic "jump to definition" and doesn't need configuration to be usable.
02:05:35 <Baughn> bastl: http://common-lisp.net/project/slime/ <-- This?
02:05:49 <Baughn> Whatever /else/ you can say about common lisp, SLIME is the bees' knees.
02:06:13 <fasta> We should simply ban everyone from saying "they have written an IDE for Haskell" unless it has those properties.
02:06:41 <fasta> It radiates the idea that Haskell developers don't know what quality is.
02:07:12 <Baughn> More that we don't have many people really motivated to make one
02:07:12 <fasta> Kind of like I normally would not trust what PHP developers would claim to be a good thing.
02:07:22 <Baughn> ..also, until recently we've been missing the required low-level tools.
02:07:40 * Baughn could hug whoever it was wrote vacuum
02:08:12 <fasta> I would like to have something like vacuum integrated with a debugger too.
02:08:28 <fasta> That is, that you can step through your computation and see all the values.
02:09:04 <Baughn> That would require being able to tell when a thunk is unevaluated, and preferably inspect its pointers too..
02:09:15 <Baughn> Not undoable at all, but something I'd need help from a simon to do
02:09:38 <Baughn> (Or I could just experiment. That would be fun.)
02:09:57 <fasta> Baughn, there are already libraries to do that.
02:10:14 <Baughn> Really? Neat. Hm.. name?
02:10:25 <fasta> Something like isEvaluated.
02:10:38 <fasta> I am pretty sure that if you Hayoo for evaluate you will find it.
02:10:46 <Baughn> fasta: Er.. I wrote that
02:11:07 <fasta> Baughn, right, so, what is the problem?
02:11:11 <Baughn> fasta: I'm not sure how good it is, but besides that, it does not inspect pointers.
02:11:26 <Baughn> The problem isn't telling that (2 + 3) is a thunk
02:11:39 <Baughn> It's telling that (+3) contains a 3
02:12:09 <fasta> Baughn, if you open a feature request, people at least know that you are interested in some specific primitive.
02:12:49 <Baughn> fasta: I'll do that eventually. First I've got about two years' worth of /other/ things to write. :P
02:13:15 <fasta> Baughn, yes, life is too short.
02:13:27 <Baughn> fasta: Wouldn't bet on that one.
02:13:41 <fasta> Baughn, eternal life?
02:13:49 <Baughn> fasta: Wouldn't bet on that one either.
02:13:53 <Baughn> But a couple trillion years..
02:13:53 <fasta> Baughn, ?
02:14:22 <Baughn> Physics seems to forbid infinite computation, unfortunately. :/
02:15:03 <Cale> Someone should make a Haskell expansion pack for the C64 using the Reduceron. :)
02:15:12 <fasta> Baughn, well, very not finite life needs faster computers, but is probably doable.
02:16:06 <Baughn> fasta: Should be rather easy with nanocomputers, even with simple rod-logic designs. I'm not really worried about that; I /am/ worried about blowing ourselves up, or consciousness not being transferable like that. Though I have no reason to believe the latter.
02:16:56 <fasta> Baughn, I don't really belief in transferring consciousness.
02:17:05 <fasta> believe*
02:17:50 <Baughn> fasta: Everything I've read, from quantum mechanics on up, suggests that it's possible. There should be limits, but I have no idea how to discover them.
02:18:13 <koala_man> fasta: that it's possible or that it should be done?
02:18:35 <Baughn> (The quantum mechanics connection is just the "no particle identities" thing, meaning only the patterns actually exist)
02:20:59 <bastl> I'm playing around with vacuum: Can I get it to write strings more user friendly (a list of chars constructed from (:) is unreadable .. )
02:21:46 <Baughn> bastl: ..by editing the source.
02:22:08 <Baughn> bastl: String is special-cased in show; you'd have to special-case it in vacuum too
02:22:36 <Baughn> (Well, actually it's lists that are special-cased, but I'm not aware of any other list types that show with special syntax)
02:22:37 <bastl> ah i dont want to hack around in such cool libraries ...
02:22:51 <Baughn> Then offer to buy me a pizza, and I'll do it for you. :P
02:22:57 <bastl> hehe
02:27:26 <osaunders> How does one notify package maintainers of build problems?
02:34:14 <fasta> koala_man, if it can be done, then of course it should be done.
02:40:31 <Alpounet> osaunders, I'd suggest the good old method : email (in case there isn't a mailing list or bug reporting system dedicated to that project)
02:41:36 <quicksilver> email doesn't work, nobody ever replies.
02:41:53 <quicksilver> the best way to get a response is always to post an inflammatory insulting remark to a public forum
02:42:09 <quicksilver> (seriously I don't recommend that but it's sad how often it's true)
02:42:31 <osaunders> http://hackage.haskell.org/trac/hackage/ticket/631
02:44:31 <osaunders> Alpounet: What email?
02:45:08 <Alpounet> quicksilver, it worked for me once
02:45:15 <dobblego> is it usual to declare a default type-class instance?
02:49:01 <aavogt> dobblego: default methods, or an overlapping instance?
02:49:20 <dobblego> default as in using the default keyword
02:50:27 <aavogt> I've never seen the default keyword used
02:50:42 <osaunders> God I'm so hungry I could eat a horse.
02:51:47 <hariju> what about cows?
02:51:57 <osaunders> http://1.bp.blogspot.com/_faHfrrBaPqM/Sj7_dN6IIWI/AAAAAAAASMc/O2yNJk1N1qE/s400/horse.jpg
02:52:06 <osaunders> Cows are good too.
02:52:09 <osaunders> As are pigs.
02:52:21 <HugoDaniel> and forests (if you are vegetarian)
02:53:00 <koala_man> dobblego:
02:53:16 <dobblego> yo
02:53:19 <tensorpudding> mmm trees
02:53:26 <hariju> :)
02:54:41 <RayNbow> hmm...
02:54:44 <RayNbow> :t fix
02:54:45 <lambdabot> forall a. (a -> a) -> a
02:54:56 <RayNbow> @let loeb x = fmap (\a -> a (loeb x)) x
02:54:57 <lambdabot>  Defined.
02:55:02 <RayNbow> :t loeb
02:55:03 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
02:55:46 <RayNbow> > let {f 0 ex = 1; f e ex = e * ex (e-1)} in loeb f
02:55:48 <lambdabot>   * Exception: stack overflow
02:55:56 <RayNbow> > let {f 0 ex = 1; f e ex = e * ex (e-1)} in loeb f 5
02:55:57 <Guest40752> hello guys I have a java problem and I know this is a haskell channel but you guys were so nice when I was learning haskell so maybe you can help me out this time also :)
02:55:58 <lambdabot>   120
02:57:16 <RayNbow> > let {f 0 ex = 1; f e ex = e * ex (e-1)} in fix (flip f) 5
02:57:17 <lambdabot>   120
02:57:19 <Baughn> Guest40752: #java.
02:59:33 <Guest40752> Baughn i cant get in because you have to get invited
02:59:34 <Guest40752> :(
02:59:53 <Baughn> Guest40752: No, just registered.
03:00:00 <Baughn> Guest40752: /msg nickserv help register
03:00:09 <RayNbow> hmm, so loeb = fix . flip for the Reader monad
03:00:19 <Guest40752> Baughn oki thx
03:00:59 <osaunders> Ah, yes, we are nice here, aren't we.
03:01:08 <brutalcyrre> :)
03:01:09 <brutalcyrre> yes
03:01:14 <osaunders> Grouphug?
03:01:22 <Baughn> @yarr
03:01:23 <lambdabot> I'd like to drop me anchor in her lagoon
03:01:38 <osaunders> lol
03:07:42 <int-e> Beware of hugging lambdas because they are pointy and get tangled up in your hair.
03:08:22 <Saizan> but they are so sweet
03:09:39 <Baughn> http://brage.info/~svein/haskell.png <-- Cute, too!
03:10:33 <int-e> secretly?
03:11:11 <Baughn> Well, she always manages to get the work done before you check. Even if it's just before..
03:11:15 <medfly> this makes humans look like lambdas
03:11:20 <int-e> (the picture says: "secretly, very lazy")
03:13:24 <pozic> Is there any way to reason about the complexity of CReal?
03:14:47 <pozic> That is, if you start with finite precision and you do any sequence of aritmetic operations on them, will you end up with computable predicates?
03:15:18 <pozic> Hmm, that's trivially false, I guess.
03:15:33 <pozic> Just compute one square root and game over.
03:15:43 <pozic> Two actually.
03:16:04 <pozic> Is there a way to say that you want to use CReals, but not using more than X bits of precision?
03:17:43 <pozic> That is, a kind of finite precision monad?
03:18:29 <burp> CReal is dynamic precision
03:18:46 <pozic> burp: you don't understand.
03:18:51 <burp> seems
03:19:05 <pozic> burp: If I write down sqrt 2 == sqrt 2, I have an infinite computation.
03:19:19 <burp> oh that
03:19:32 <theorbtwo> Sounds more like you want to implement some Ring that does arithmetic operations with precision rules.
03:19:33 <burp> hm, but such things are also not good with finite precision
03:19:38 <pozic> burp: but I will just use the almostEquals operations then that I will define myself.
03:19:45 <burp> ok
03:20:43 <pozic> Actually, every number should be tagged by whether or not it is a finite number.
03:21:10 <pozic> And that should be done by some monad.
03:21:16 <Cale> a finite number?
03:21:27 <Cale> Working with hyperreals or just floating point?
03:21:38 <Baughn> pozic: Why a monad?
03:21:47 <theorbtwo> I think you mean "terminating number".
03:21:58 <ziman> is it computable? (whether it's finite)
03:22:20 <Axman6> pozic: Double has finite precision...
03:24:01 <burp> http://hackage.haskell.org/package/AERN-Real maybe something like this?
03:28:00 <burp> pozic: you can compare the showCReal results for limited precision ;-)
03:29:06 <burp> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Fixed.html
03:29:18 <burp> Data.Number.Fixed is also in the same package as CReal
03:30:19 <burp> > sqrt 2 :: Fixed Prec50
03:30:20 <lambdabot>   Ambiguous occurrence `Fixed'
03:30:21 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
03:30:34 <burp> > sqrt 2 :: Data.Number.Fixed Prec50
03:30:35 <lambdabot>   Not in scope: type constructor or class `Data.Number.Fixed'
03:31:30 <Baughn> ..we really, really need type-level literals, so everyone can stop reinventing them
03:32:01 * Baughn wonders if anyone has written a proposal yet
03:32:28 <burp> sqrt 2 :: Fixed (PrecPlus20 (PrecPlus20 Prec50)) -- ha
03:32:42 <Baughn> Horrifying. ;_;
03:33:16 <theorbtwo> Type-level literals as in Fixed 5.0?
03:35:43 <Baughn> theorbtwo: 5.0 would be the literal. Or 5.
03:36:02 <theorbtwo> Baughn: Yes, got that.  I'm just somewhat surprised that it doesn't Just Work.
03:38:37 <Baughn> theorbtwo: It would be a fair bit of work for GHC, and I get the feeling they want to combine it with dependent types somehow
03:38:42 <Baughn> *for the GHC developers
03:39:04 <Baughn> So, no good implementations coming because they're waiting for a perfect one
03:39:17 <Baughn> (..probably accept a patch, though)
03:39:41 <theorbtwo> Yey, the perfect is the enemy of the good.
03:44:39 <aleator> Hi. I have Ptr Double. How do I make it into Ptr CDouble?
03:44:56 <Baughn> aleator: Why do you have a Ptr Double? Where did you get it from?
03:45:48 <aleator> Well, I Math.FFT processes stuff in CArray i Double, and I'm trying to interface this with my c code using c2hs.
03:47:40 <Baughn> aleator: Inconvenient. I want to say castPtr, but there's a good chance that's horrifically wrong..
03:48:09 <Baughn> aleator: You could always peek the pointer then convert it, but that sounds slow. Hm.
03:48:43 <aleator> Well, it is few million elements so doing anything to each one is going to suck badly
03:49:25 <Baughn> aleator: A better way would be to fix Math.FFT so it's parametrized on the type, so you can use CDouble there as well
03:49:51 <quicksilver> fortunately Double and CDouble are the same so castPtr should be fine
03:49:54 <quicksilver> it's a bit clumsy though.
03:50:02 <quicksilver> Baughn: that would destroy the performance, probably.
03:50:08 <Baughn> Perhaps
03:50:15 <aleator> Well. FFT has rather complex typeclass for this stuff, so that is quite hard
03:50:17 <Baughn> ..castPtr wouldn't be /safe/
03:50:34 <quicksilver> and since the raison d'etre  of Math.FFT is performance I can understand why they don't
03:50:37 <Baughn> Even if Double = CDouble on your /current/ machine, there's no guarantee that it'll stay that way
03:50:52 <Baughn> Oh well. I'd probably use castPtr too.
03:50:55 <MarcWeber> Do you just know a package using a custom preprocessor? I'd like to lookup how to use one in Setup.hs
03:51:37 <aleator> Hmm. Seems that I can do ffi import by hand that equates cdouble and double. Now I wonder if c2hs could do that also.
03:51:59 <quicksilver> Baughn: on the current GHC version there is
03:52:18 <quicksilver> Baughn: all FFI-supporting versions of GHC to date make Double == CDouble on all architectures on which they work.
03:52:23 <ksf> package network-2.2.1.7-0252ed952116094104881798b5b14649 is shadowed by package network-2.2.1.7-690829b65e7e551d04f68dfcbdfbfb54
03:52:23 <ksf> package vacuum-opengl-0.0.3-17486e4f8f2a662a6f2deb3985d74d1d is unusable due to missing or recursive dependencies:
03:52:23 <ksf>   network-2.2.1.7-0252ed952116094104881798b5b14649
03:52:27 <quicksilver> I can't predict the future though.
03:52:38 <Baughn> quicksilver: But what if I want to run the program on my kerosene-powered sausage heater?
03:52:41 <ksf> one is a global, purposedly non-dyn one, and the other, local one just got build for vacuum-opengl
03:52:54 <ksf> how do I best fix that?
03:55:56 <Baughn> ksf: Unregister network, reinstall it and all packages depending on it..
03:56:04 <Baughn> ksf: At least it /warns/ you about these things nowadays. :P
03:56:21 * Baughn tries not to install multiple copies of any library without very good reason
03:56:27 <ksf> it wants to update network because there's a new parsec version in town
03:56:32 <ksf> ...which I don't care about.
03:57:26 <ksf> cabal install --reinstall vacuum-opengl "--constraint=parsec == 2.1.0.0"
04:00:37 <ksf> ...now if vacuum wouldn't choke on my recursive definitions
04:03:57 <pozic> How do you do debug ST monad code? Ideally, I would just like to step through it as if it was C code.
04:04:19 <Baughn> Prints.
04:04:43 <Zao> Traces?
04:04:48 <Baughn> Same thing
04:04:54 <Zao> @type print
04:04:55 <lambdabot> forall a. (Show a) => a -> IO ()
04:05:01 <Baughn> unsafeIOToST . print
04:05:07 <Baughn> @type unsafeIOToST . print
04:05:08 <lambdabot> Not in scope: `unsafeIOToST'
04:05:33 <Zao> Baughn: Good point. I shield my eyes when I see the prefix 'unsafe' in the docs, to avoid temptation.
04:05:55 <Baughn> Zao: I've fallen for the temptation, and gone to the other side. I now think of haskell evaluation in terms of thunk reduction.
04:06:09 <Baughn> pozic: Oh, and keep in mind that the default ST monad is /lazy/
04:06:33 <Baughn> ..IO actions are still executed in-order, mind you
04:06:40 <Baughn> It's an odd sort of laziness
04:06:48 <tensorpudding> too much unsafePerformIO can make you go blind
04:07:15 <Baughn> But if you go even further than that, you end up getting a new sense of thgis.
04:07:43 <pozic> Baughn: This library provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads.
04:07:53 <pozic> Baughn: why do the docs say that they are strict then?
04:08:15 <Baughn> pozic: Because I am confusing it with Control.Monad.State
04:08:38 <interferon> is there a function that will map a function across a list, with each function application happening in a separate thread?
04:08:44 <pozic> I don't see why fixST is exported either.
04:08:53 <pozic> mfix already does that.
04:09:20 <int-e> @index parMap
04:09:20 <lambdabot> Control.Parallel.Strategies
04:09:31 <int-e> @type Control.Parallel.Strategies.parMap
04:09:33 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
04:09:42 <interferon> thanks!
04:11:08 <zygoloid> > runST $ mfix (\a -> newSTRef (0:1:zipWith (+) a (tail a)) >>= readSTRef)
04:11:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:11:35 <Cale> interferon: That's not exactly in a separate thread. What happens is that it adds the evaluation of each of the elements to a work queue, and Haskell evaluators on separate OS threads will try to take work from that queue.
04:11:44 <int-e> interferon: Note that this is not exactly what you asked for - parMap will create sparks rather than threads. The RTS will evaluate sparks in its worker threads. I would guess that that's what you want.
04:12:43 <interferon> i think that's actually what i should've been asking for :)
04:14:08 <interferon> thanks
04:14:12 <pozic> Did the debugger improve in 6.12?
04:15:32 <ksf> I didn't think I'd ever say anything good about inkscape, but it obviously loads .svg blazingly fast.
04:15:44 <Cale> inkscape is awesome
04:16:45 <ksf> ...well ok stuff deterioates as soon as i zoom in
04:17:04 <fasta> Does Inkscape does anything complicated?
04:17:13 <fasta> do*
04:17:59 <fasta> I never saw its most interesting feature (sharing a drawing in real-time) work.
04:17:59 <zygoloid> have they fixed all the stability issues which sodipodi used to suffer from yet?
04:18:13 <Cale> Inkscape is most of everything that I ever cared about from Adobe Illustrator, minus a bunch of technical features which might be useful for people doing actual publishing, but plus other cool features for artwork.
04:18:22 <ksf> it's still got stability issues
04:18:50 <ksf> ...and I need to stop vacuum traversing into my maps, not just for performance, but to make any sense of my graph.
04:19:10 <MarcWeber> inkscape is hard to script. You have to work on svg/ xml directly. There is no addRect interface or such
04:19:35 <MarcWeber> dcoutts:
04:19:59 <zygoloid> i've also found it hard to get it to produce the SVG file i want; it seems to add loads of unnecessary gradients (or possibly fail to remove ones which are now unused)
04:20:06 <MarcWeber> http://dpaste.com/156389/ Can you have a quick glance at my custom preprocessor? Maybe you see within 20sec what's wrong. If not I'll digg into sourc
04:20:41 <Cale> I've never actually thought to look at the text of one of the files that Inkscape produces.
04:20:59 <Cale> As far as I'm concerned it's for producing images :P
04:21:28 <zygoloid> Cale: when you're taking those images and feeding them into a flaky python SVG -> GL renderer, it matters ;-)
04:21:49 <Cale> http://qdb.us/294682 -- ahaha
04:22:05 <MarcWeber> Cale: If you write a plugin operating on an "inkscape image" inkscape calls a pipe feeding and expecting svg files
04:22:17 <ksf> I'd like a 3d vacuum interface that allows you to collapse and expand nodes
04:22:49 <MarcWeber> But the interface of inkscape is well designed (keyboard shortcuts etc)
04:24:32 * ksf slates that 3d vacuum interface as a task for the next one who asks how to write a game in haskell
04:25:19 <int-e> hehe. "find the nefarious thunk"
04:25:20 <Cale> Make a fun game which is based on graph reduction of functional programs.
04:26:06 <ksf> seriously, vacuum right now is unusable for bigger stuff
04:26:38 <Cale> Melodious Thunk would be a great name for a piece of music software in Haskell.
04:33:42 <tensorpudding> that's a great name
04:33:44 <Peaker> > 0 == (0.1 ** 1000 :: CReal)
04:33:45 <lambdabot>   True
04:33:49 <Peaker> Why is that?
04:33:57 <tensorpudding> someone needs to get started on it
04:34:26 <Cale> Peaker: The Eq instance is obviously fake
04:34:47 <Peaker> Cale: the show instance also seems to corroborate
04:34:50 <Cale> Peaker: Equality testing for computable reals isn't computable, so you get an arbitrary approximation.
04:34:51 <Peaker> > 0.1 ** 1000 :: CReal
04:34:52 <lambdabot>   0.0
04:35:12 <Peaker> > (0.1 ** 1000 :: CReal) ** (1/1000)
04:35:16 <lambdabot>   mueval-core: Time limit exceeded
04:36:44 <Peaker> > (0.1 ** 41 :: CReal) == 0
04:36:45 <lambdabot>   False
04:37:27 <Peaker> > (0.1 ** 42 :: CReal) == 0
04:37:28 <lambdabot>   True
04:37:32 <Peaker> > (0.1 ** 42 :: CReal) ** (1/42)
04:37:34 <lambdabot>   0.1
04:37:44 <Peaker> here's the proof
04:38:05 <Peaker> @src CReal
04:38:06 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:38:25 <FliPPeh> > 1 :: CReal
04:38:26 <lambdabot>   1.0
04:39:02 <FliPPeh> > 1/42
04:39:02 <lambdabot>   2.3809523809523808e-2
04:39:19 <FliPPeh> > (0.1 ** 42 :: CReal)
04:39:20 <lambdabot>   0.0
04:39:27 <FliPPeh> > (0.1 ** 42 :: CReal) ** 2.38
04:39:29 <lambdabot>   0.0
04:48:22 <Itkovian> Given that Network.XmlRpc.Client.remote returns an IO a with a being anything, is there a way to construct a single datatype, say Xtype = Xtype1 String | Xtype2 (String, Double) such that Xtype can be made an instance of XmlRpcType, which requires a fromValue :: XmlRpcType -> a. Bus as I've no clue what a will be, I've no idea how to write that fromValue function. It should distinguish between the potential return values, but they're all XmlRpcTy
04:48:22 <Itkovian> values. I've no clue how to begin here.
04:49:42 <Itkovian> The point being is that I'd like to have a service :: IO XType function that performs the actual XMLRPC call and can be used from any of the other functions f1, ... fn that are defined by the specific XMLRPC service, in case those found at http://mollom.com/api/mollom-basics
04:50:59 <Itkovian> Or am I looking at this problem the wrong way? HaXr is pretty good at putting stuff in the structure you;d like if you define that structure to be an XmlRpcType instance.
04:51:34 <cizra> > [[a1, a2, a3, b1, b2, b3] | a1 <- [1..9], a2 <- filter (/= a1) [1..9], a3 <- filter (\x -> x /= a1 && x /= a2) [1..9], b1 <- filter (\x -> x /= a1 && x /= a2 && x /= a3) [1..9], b2 <- filter (\x -> x /= a1 && x /= a2 && x /= a3 && x /= b1) [1..9], b3 <- filter (\x -> x /= a1 && x /= a2 && x /= a3, x /= b1, x /= b2) [1..9]]
04:51:35 <lambdabot>   Couldn't match expected type `t -> GHC.Bool.Bool'
04:51:35 <lambdabot>         against inferred ...
04:51:53 <Twey> cizra: Nice :Ã¾
04:51:54 <cizra> lambdabot: um.. what?
04:52:00 <cizra> Twey: Can you comment?
04:52:43 <Twey> You expect me to parse *that*?  When I've only just gotten up?  :Ã¾
04:53:22 <Botje> cizra: i'd write that using a helper fucking choose :: [a] -> [(a,[a])]
04:53:23 <Zao> List no comprehension.
04:53:36 <Botje> *helper function
04:53:37 <Botje> (wow)
04:53:39 <Twey> Haha
04:53:40 <Twey> Nice
04:53:47 <Zao> Botje: Freudian Programming.
04:53:57 <Twey> cizra: I get an â€˜x out of scopeâ€™ because of your use of commas at the end there
04:53:59 <Botje> is that the one where you pair program with your mother?
04:54:01 <Twey> Did you mean &&?
04:54:10 <Zao> Have you've been taking markov lections from psychobot? :)
04:54:37 <cizra> > filter (\x -> length (nub x) == length x) [[a1, a2, a3, b1, b2, b3] | a1 <- [1..9], a2 <- [1..9], a3 <- [1..9], b1 <- [1..9], b2 <- [1..9], b3 <- [1..9]]
04:54:38 <lambdabot>   [[1,2,3,4,5,6],[1,2,3,4,5,7],[1,2,3,4,5,8],[1,2,3,4,5,9],[1,2,3,4,6,5],[1,2...
04:54:41 <cizra> aha!
04:54:45 <cizra> That should be equivalent.
04:55:16 <cizra> Wait, what
04:55:17 <byorgey> equivalent but less efficient.
04:55:21 <cizra> Aren't commas necessary?
04:55:39 <byorgey> you had x /= a2 && x /= a3, x /= b1 ... etc
04:55:42 <byorgey> at the end
04:55:50 <cizra> augh
04:55:50 <cizra> yes
04:55:57 <cizra> I see my mistake
04:56:12 <cizra> > [[a1, a2, a3, b1, b2, b3] | a1 <- [1..9], a2 <- filter (/= a1) [1..9], a3 <- filter (\x -> x /= a1 && x /= a2) [1..9], b1 <- filter (\x -> x /= a1 && x /= a2 && x /= a3) [1..9], b2 <- filter (\x -> x /= a1 && x /= a2 && x /= a3 && x /= b1) [1..9], b3 <- filter (\x -> x /= a1 && x /= a2 && x /= a3 && x /= b1 && x /= b2) [1..9]]
04:56:13 <lambdabot>   [[1,2,3,4,5,6],[1,2,3,4,5,7],[1,2,3,4,5,8],[1,2,3,4,5,9],[1,2,3,4,6,5],[1,2...
04:56:21 <byorgey> also, why not  x `notElem` [a1, a2, a3, b1, b2]
04:56:22 <byorgey>  and so on
04:56:47 <byorgey> b3 <- filter (`notElem` [a1, a2, a3, b1, b2])
04:57:15 <cizra> Would be fine as well
04:59:06 * cizra is trying to write a magic square solver showcasing the relative awesomity of Haskell over C.
05:02:33 <ksf> {-# LANGUAGE PackageImports, ForeignFunctionInterface, MultiParamTypeClasses, FlexibleContexts, DeriveDataTypeable, EmptyDataDecls, FlexibleInstances, FunctionalDependencies, ScopedTypeVariables, ExistentialQuantification, NoMonomorphismRestriction, GADTs, KindSignatures, TypeFamilies, TupleSections, Rank2Types, GeneralizedNewtypeDeriving #-}
05:02:37 <ksf> I think I need to clean up a bit
05:02:40 <cizra> [[2,7,6,9,5,1,4,3,8],[2,9,4,7,5,3,6,1,8],[4,3,8,9,5,1,2,7,6],[4,9,2,3,5,7,8,1,6],[6,1,8,7,5,3,2,9,4],[6,7,2,1,5,9,8,3,4],[8,1,6,3,5,7,4,9,2],[8,3,4,1,5,9,6,7,2]]
05:02:56 <cizra> -- final answer. I haven't tested these, but they should be all possible solutions to the magic square.
05:04:16 <byorgey> what do you mean, "possible" solutions?
05:04:43 <ksf> cizra, you've got duplicates
05:04:51 <ksf> well, rotations or mirros, that is.
05:05:29 <byorgey> I think those are all rotations and mirror images of the same single solution
05:05:55 <ksf> yep
05:17:59 <osaunders> You can't define instances for type synonyms?
05:18:17 <FliPPeh> You can
05:18:27 <FliPPeh> But you've got to add GHC extensions
05:18:37 <osaunders> Why, is it a bad idea?
05:18:50 <FliPPeh> I think it's even standard in Haskell 2010
05:18:54 <FliPPeh> But I might be wrong
05:19:06 <FliPPeh> It's not bad as far as I know, just a too strict standard of HS98
05:19:15 <FliPPeh> But don't quote me on it!
05:20:59 <osaunders> Ok, I'm going with -XTypeSynonymInstances
05:21:26 <FliPPeh> Yep, that's what I mean
05:21:34 <FliPPeh> You can also add it on top of the file you need it in
05:22:22 <FliPPeh> {-# LANGUAGE TypeSynonymInstances #-}
05:23:19 * hackagebot upload: authenticate 0.4.0.1 - Authentication methods for Haskell web applications. (MichaelSnoyman)
05:24:06 <osaunders> Oooh.
05:24:07 <osaunders> Nice.
05:27:20 * hackagebot upload: convertible-text 0.2.0.4 - Typeclasses and instances for converting between types (MichaelSnoyman)
05:28:20 * hackagebot upload: data-object-json 0.0.0.1 - Serialize JSON data to/from Haskell using the data-object library. (MichaelSnoyman)
05:31:13 <kpreid> Trinity` is a spammer
05:35:48 <medfly> where is he spamming?
05:36:35 <kpreid> sent me a message on join
05:37:12 <opqdonut>  /Act
05:37:14 <opqdonut> oops
05:38:02 <medfly> well that's not very good.
05:45:35 <smiler> @src zip
05:45:36 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:45:36 <lambdabot> zip _      _      = []
05:48:29 <bastl> Is someone aware of a lightweight html-parser with Haskell-Datatypes for the Html-syntax ? There are many XML-like things, HaXML, tagsoup etc. but they dont fit.
06:05:07 <osaunders> Hm, not sure how I should solve this problem reasonably: http://codepad.org/897cENrR
06:06:22 <Lemmih> osaunders: weaponName, gameChrName.
06:06:51 <osaunders> That could get tiresome.
06:08:40 <Peaker> @hoogle fclabels
06:08:41 <lambdabot> No results found
06:08:44 <Peaker> @package fclabels
06:08:44 <lambdabot> http://hackage.haskell.org/package/fclabels
06:09:10 <dankna> class Named a where name a :: a -> String
06:09:56 <Peaker> osaunders: well, type inference is nicer than name inference :)
06:10:19 <osaunders> What's name inference?
06:10:58 <Peaker> osaunders: The thing C/C++/Java do when they choose a different name based on the type of thing you're looking in, e.g in C++:   Type a;  a.name   actually looks up:   a.Type::name
06:11:11 <Peaker> osaunders: but it kinda destroys any possibility of unambiguous/useful type inference
06:11:32 <Peaker> If you don't know the type of "a" there, you get different types/semantics based on whatever "name" is chosen
06:11:48 <Peaker> I like name resolution being able to complete unambiguously before doing any type inference - that way type inference is simple and complete
06:12:42 <osaunders> Peaker: Would it be easier if I didn't use record syntax at all do you think?
06:12:49 <Peaker> osaunders: in your example, if you have:  f = name -- what would type inference decide for the type of f?
06:12:59 <osaunders> hm
06:13:29 <osaunders> I can imagine GameChr growing to have a lot of different things within it.
06:13:44 <Peaker> osaunders: a "gc" prefix is a reasonable trade-off IMO
06:13:57 <Peaker> gcName gcHP gcWeapon
06:14:07 <osaunders> Yeah.
06:14:18 <osaunders> I'm not used to having to do such things.
06:14:22 <osaunders> Seems annoying
06:14:27 <Peaker> yes, it is slightly annoying
06:14:59 <Peaker> if we had smart code editors, rather than text editors, then they could do type inference as we edit... Then, when you already know the type of "a" is GameChr you wouldn't need to disambiguate it
06:15:13 <dankna> interesting feature
06:15:25 <Peaker> osaunders: btw, http://hackage.haskell.org/package/fclabels is probably a cool way to access your records
06:15:26 <dankna> how would the code editor know anything the compiler doesn't, though?
06:15:38 <osaunders> Peaker: Yeah I saw that.
06:15:38 <Peaker> dankna: it wouldn't -- but currently the editor doesn't even know things the compiler does
06:15:43 <dankna> hm, that's fair
06:16:06 <Peaker> dankna: and the compiler isn't interactive like the editor so it can't help you with the knowledge it does have as much
06:16:11 <dankna> right, indeed
06:16:31 <dankna> making a real code editor is one of my pet ideas that I want to do someday, so I'm interested in this topic
06:16:45 <dankna> to me, structure editing (cf. paredit for Lisp, for example) would be a big part of it
06:16:49 <osaunders> Peaker: Is having data types with lots of records bad practice in FP?
06:17:12 <Peaker> dankna: Yeah, it's the main project I'd like to work on, and also incorporates revision control within it (instead of a silly "undo buffer") that can gain a LOT from working at the abstract syntax level rather than the textual level
06:17:23 <dankna> yeah, indeed
06:17:38 <Peaker> osaunders: Not as far as I'm aware -- it can hurt composeability/generality a bit (but not if you have convertors to/from standard product types)
06:18:25 <Peaker> dankna: but non-textual editor + revision control + UI toolkit (because existing GUI toolkits are horrible) is a big project, and I'm waiting until I can work on it full-time... :(
06:18:33 <dankna> same.
06:18:40 <Peaker> dankna: I started work on the UI toolkit, and made a bit of progress
06:18:43 <Peaker> @package lui
06:18:43 <lambdabot> http://hackage.haskell.org/package/lui
06:18:46 <osaunders> Peaker: That sounds like a pretty awesome projet.
06:18:48 <osaunders> *project
06:18:48 <dankna> well, I would probably go entirely Cocoa for my UI toolkit.
06:18:53 <Peaker> osaunders: :-)
06:18:56 <dankna> hmmm, okay
06:19:20 <dankna> I'll look at lui in more detail when I have the chance to use it for something
06:19:47 <dankna> in general I feel that it's the wrong approach to be implementing your own widgets on top of SDL, at least for applications - for games it's fine, even expected
06:19:56 <Peaker> dankna: See how most code editors use their own widget, or a text editing widget that is highly customized.. The existing toolkits, including Cocoa offer lots of "form" widgets that I find pretty useless for a code editor
06:20:04 <dankna> platform-native widgets have very rich behaviors
06:20:09 <jontore> Hi. Does anyone know if there a library in ghc that has something like hugs IOExts trace() ?
06:20:13 <dankna> oh I agree that you want the actual text field to be custom
06:20:16 <Peaker> dankna: Well, which native widgets could a code editor use?
06:20:24 <dankna> but if you want there to be any buttons or anything, even in the preferences box, ...
06:20:27 <osaunders> Am I correct in thinking Haskell on it's own doesn't do very much. It's common for people to use lots of libraries to argument the programming experience as well as the things that libraries are used for in imperative languages?
06:20:40 <Peaker> dankna: I an not sure I'd want a "preferences box"
06:20:43 <dankna> hmmm
06:20:50 <dankna> something like Emacs's customize-mode, then?
06:20:58 <Peaker> dankna: Yeah, though better look&feel :)
06:21:01 <dankna> well, I can see a case for that
06:21:30 <Peaker> osaunders: it seems to me that Haskell defers much more of the core functionality to libraries than most other languages
06:21:41 <Peaker> osaunders: but Smalltalk is also similar in this regard
06:21:42 <dankna> compare Perl in that regard, though
06:22:03 <osaunders> OK. Good.
06:22:24 <Peaker> osaunders: There are other (even more) minimalist languages than Haskell (e.g: Lambda calculus)
06:22:38 <dankna> (eg Brainfuck :D)
06:23:10 <Cale> Haskell isn't so minimalist, but it somehow manages to retain some of the feel of a small language.
06:23:26 <bastl> how do i force ghci to choose a specific version of a package ?
06:23:33 <dankna> anyway, yeah, some sort of structure editor is a project that excites me.  I'm glad I'm not the only one.
06:23:34 <Cale> It's actually quite a lot of work to implement Haskell though.
06:23:55 <Peaker> Cale: Haskell's value system (ignoring the type system) is pretty small..
06:24:25 <Peaker> Cale: even if you throw performance out the door? :)
06:24:56 <Cale> Well, there's pattern matching and algebraic types, and well, you can't really forget to implement the type system because typeclasses are so important.
06:25:37 <Cale> You can do quite a bit with lambda calculus + let + case
06:25:48 <Cale> But there's a lot more than that to Haskell...
06:27:43 <Sgeo_> Would writing a BF interpreter be a good excercise?
06:28:02 <dankna> it might be, depending on your goals :)
06:29:01 <bastl> hmm. Now i loaded a specific version of the pkg, but another pkg is not found: :show packages shows the pkg, autocompletion offers the modules contained in it, but when I try to add them using :m, it says module is not loaded :-/
06:30:24 <bastl> the latter package (tagsoup-parsec) depends on an old version of tagsoup.
06:30:45 <kamatsu> ah, so, i have to shelve my OT project until someone (or I) writes a decent source code editor with event hooks for the browser
06:30:47 * Sgeo_ has never written a BF interpreter before in any language
06:31:39 <Saizan> bastl: you can :set -package $pkg-$ver
06:32:04 <bastl> ah. that sounds interesting
06:32:18 <osaunders>  Sgeo_ BF == Befunge?
06:32:26 <Saizan> also, you need to restart ghci after installing a package to make it available
06:32:39 <Sgeo_> BF == Brainf***
06:33:19 <osaunders> Sgeo_: Ah, OK.
06:35:31 <bastl> strange, I load both packages with exact version, auto-completion shows the modules, but I cannot add the module to the "module path"
06:36:37 <bastl> but I can use it with fully qualified names
06:37:08 <osaunders> Sgeo_: If you've never written a BF interpreter, how did you manage to get into #haskell then?
06:37:16 <bastl> :-)
06:37:28 <osaunders> I had to complete an initialization test.
06:37:53 <osaunders> Cale asked me a bunch of questions to make sure I'd written a BF interpreter before I was allowed in,
06:38:15 <osaunders> Wasn't it like that for you, Sgeo_?
06:38:27 <Sgeo_> lol
06:39:33 <osaunders> xD
06:42:06 <medfly> I have never written anything in brainfuck, or a brainfuck interpreter.
06:43:41 * Sgeo_ once wrote a um.. thingy that was supposed to let BF and other such languages interact with more than just stdin/stdout
06:43:53 <Sgeo_> Major project, abandoned it after everyone else lost interest
06:43:59 <tromp> i wrote one in 117 bytes
06:49:33 <fasta> tromp, you should teach me how to convince someone to pay me to do that. :)
06:52:15 <tromp> oh, you just get a job in academia:)
06:52:35 <tromp> but it's also fun to do in your spare time:)
06:53:08 <Hee> I need some javascript help, anyone can help?
06:54:30 <fasta> tromp, there is not an abundance of jobs related to program search/algorithmic information theory available.
06:54:34 <RayNbow> Hee: you do know that this channel is actually about Haskell?
06:54:47 <Botje> shrug
06:54:55 <Botje> people just go to the biggest channels and ask for help
06:55:10 <Hee> lol I just figured that out. I just randomly chose a chanel. Thanks though
06:55:29 <Hee> reddit is awesome
06:55:30 <burp> lol
06:57:02 * RayNbow wonders if anyone has ever written [[a] -> a] -> [a] in C#...
06:57:31 <RayNbow> tying the knot in strict languages is tricky :p
06:58:11 <ziman> is it loeb?
06:58:43 <RayNbow> ziman: yeah
07:01:18 * Sgeo_ is learning about C#
07:01:26 <Sgeo_> I like of like it more than I thought I would
07:06:07 <Sgeo_> Haskell's interfering with my ability to focus on a C# project
07:06:15 <Sgeo_> Because I'd rather be learning more and more about Haskell
07:07:29 <Sgeo_> Bye all
07:09:17 <pozic> If you print 0 with 50 digits of precisiom, you actually get 0.00000000000000000.. instead of 0, which is annoying.
07:09:54 <RayNbow> > showCReal 50 0
07:09:55 <lambdabot>   "0.0"
07:11:24 <pozic> RayNbow: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Fixed.html
07:12:17 <RayNbow> ah
07:13:53 <Twey> > showCReal 0 0
07:13:54 <lambdabot>   "0"
07:13:57 <Twey> > showCReal 0 123
07:13:58 <lambdabot>   "123"
07:14:02 <Twey> > showCReal 0 123.6
07:14:03 <lambdabot>   "124"
07:14:10 <Twey> Hmm, interesting.
07:16:02 <JohnDoe365> is there documentation somewhere about lamdabot? seems realy powerful
07:16:35 <JohnDoe365> Or is there somewhere another online option for lambdabot to prevent spaming the room?
07:16:50 <roconnor> > deriv (\x -> x**x) x
07:16:51 <lambdabot>   (1 * recip x * x + log x * 1) * exp (log x * x)
07:16:53 <Saizan> JohnDoe365: you can query it
07:16:54 <ziman> just query her
07:16:57 <theorbtwo> JohnDoe365: Have you tried /msg?
07:16:59 <RayNbow> @hoogle deriv
07:17:00 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
07:17:15 <RayNbow> :t deriv
07:17:16 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
07:17:29 <ziman> and the doc:
07:17:33 <ziman> @help
07:17:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:17:41 <JohnDoe365> ahhh! that's an idea .. almost forgot about that commands with all the gui tools nowadays!
07:17:43 <benmachine> @list is actually a bit useless
07:17:43 <lambdabot> No module "is actually a bit useless" loaded
07:17:47 <benmachine> >_>
07:17:53 <benmachine> @list list
07:17:53 <lambdabot> system provides: echo list listchans listmodules listservers uptime
07:18:01 <Zao> For IntSet, is there any performance difference between toList/fromList and toAscList/fromDistinctAscList?
07:18:03 <ziman> @list
07:18:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:18:14 <benmachine> I think that list is not up-to-date
07:18:20 <roconnor> Zao: yes
07:18:44 <JohnDoe365> theorbtwo, benmachine, ziman: cool, thanks!
07:18:47 <benmachine> I imagine toList and toAscList are the same
07:19:03 <benmachine> only with the latter, it is guaranteed to be ascending
07:19:12 <benmachine> whereas the former could conceivably change that
07:19:17 <benmachine> in a future release
07:21:20 <gwern> heheh. the gods don't give but they take away
07:21:47 <gwern> my request for a transcript of a roundtable has been finally answered - with a video, and audio in French & Japanese
07:23:35 <Zao> Heh.
07:24:07 <chrissbx> Now you only have to learn French and Japanese.
07:24:28 <mux> being french, I highly suggest you to learn japanese
07:24:48 <mux> unless the japanese subtitles are ideograms
07:25:24 <gwern> mux: I believe it's japanese speakers being translated into french
07:25:32 <gwern> no text at any point
07:25:49 <mux> hah
07:26:09 <gwern> chrissbx: the funny thing is, I do know enough french to get by - but only with text. 'I suck at spoken language, and besides, when am I ever going to run into french audio? I'm no traveller'
07:27:38 <chrissbx> Maybe someone will take the time to write an english translation; not me today.
07:28:31 <gwern> chrissbx: I'll probably give it a try myself and then punt it to a guy interested in the same material who seems to know french better than I
07:32:16 <osaunders> Is this defined anywhere in GHC std libs?
07:32:18 <osaunders> idxRange :: [a] -> (Int, Int)
07:32:18 <osaunders> idxRange xs = (0, length xs - 1)
07:33:29 <roconnor> @hoogle [a] -> (Int, Int)
07:33:29 <lambdabot> Prelude floatRange :: RealFloat a => a -> (Int, Int)
07:33:30 <lambdabot> System.Random genRange :: RandomGen g => g -> (Int, Int)
07:33:30 <lambdabot> Data.Time.Calendar.OrdinalDate mondayStartWeek :: Day -> (Int, Int)
07:38:14 <chrissbx> I'm using gnu emacs (with whatever haskell mode it comes); is there a way to open the file containing a definition of an identifier?
07:38:36 <quicksilver> chrissbx: there is hasktags but it has various limitations.
07:38:52 <chrissbx> Also, for example Text.ParserCombinators.ReadP is a module, I'd like to get a module signature back, is this possible interactively?
07:39:12 <bolmar> :t zipWith
07:39:13 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:39:26 <bolmar> @src zipWith
07:39:26 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:39:26 <chrissbx> If I just enter that name it'll say it can't find the Text.ParserCombinators module.
07:39:26 <lambdabot> zipWith _ _      _      = []
07:39:50 <quicksilver> chrissbx: modules don't have signatures.
07:40:09 <quicksilver> you can do :browse Text.ParserCombinators.ReadP
07:40:28 <chrissbx> aha, that's what I've been looking for, thanks
07:40:47 <det> How can I print a list of strings ?
07:41:39 <chrissbx> det, I guess you'll have to be more specific
07:41:48 <dankna> putStrLn $ show $ intercalate "\n" ["abc", "def"]
07:41:50 <dankna> or something like that
07:41:54 <dankna> wait, no
07:41:58 <dankna> take out the show
07:42:05 <det> Thanks
07:42:15 <bfh6558> when defining a module, what does it mean to necessarily export the functions you've defined inside?  if its not included in the module name (....) where: ie inside the parentheses does it mean its like private? and not a callable function?
07:42:18 <dankna> may have gotten the args to intercalate backwards as well
07:43:07 <dankna> bfh: yes, quite so.
07:43:16 <quicksilver> bfh6558: yes, can't be called by other modules.
07:43:46 <benmachine> @src unlines
07:43:46 <lambdabot> unlines = concatMap (++ "\n")
07:43:48 <dankna> as a special case, if you leave out the list entirely, everything is exported; but that's rarely what you want, really
07:44:00 <bfh6558> hmm
07:44:18 <bfh6558> I've defined a module, imported it to ghci and was able to call a function not exported explicitly
07:44:22 <bfh6558> is this a special case?
07:44:34 <dankna> ghci acts like it's inside the module, I think
07:44:35 <theorbtwo> Hm.  Things that are not exported cannot be used, even when fully qualified?
07:44:43 <bfh6558> ahhh
07:45:01 <bfh6558> the whole computing model is quite strange to me
07:45:17 <quicksilver> theorbtwo: right. Full qualification is not actually part of the language.
07:45:18 <dankna> fair enough.  it does take getting used to.
07:45:18 <bfh6558> i've not been able to even get caba-install working :) ha guess i need practice
07:45:31 <quicksilver> theorbtwo: it's a hack that ghci imports everything under its fully qualified name.
07:45:32 <roconnor> I think ghci will only do that for intepreted modules and not compiled modules
07:45:34 <det> @type intercalate
07:45:34 <roconnor> not sure
07:45:35 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:45:42 <quicksilver> (and ghci lazily imports *all* modules)
07:45:57 <roconnor> quicksilver: oh
07:46:05 <quicksilver> roconnor: no, ghci will do it for compiled stuff too.
07:46:10 <roconnor> interesting
07:46:19 <dbro> I'm struggling with a simple quickcheck list-of-random-numbers generator. Is this the right place to ask for suggestions?
07:46:36 <quicksilver> theorbtwo: it is as if ghci has the init file "import qualified Foo.Bar.Baz as Foo.Bar.Baz" for every module on your system.
07:47:08 <dankna> bfh: to simplify things for yourself, you probably want to install Haskell Platform.  it includes cabal-install.
07:47:16 <quicksilver> bfh6558: and yes, to answer your other question, when ghci loads a module like that you are inside it.
07:47:39 <quicksilver> the purpose is to help you debug/test/develop the module after all
07:47:53 <bfh6558> thank you all
07:47:56 <dankna> sure
07:49:16 <dbro> has anyone here successfully used quickcheck2's vector ?
07:49:21 <dankna> not I
08:02:29 <fasta> There was a talk about a domain specific language for compass and ruler constructions. Are the slides anywhere?
08:03:10 <dankna> ooh, I'd be interested in that too - it relates to my current real project :)
08:03:32 <dankna> do you know who gave the talk or anything?
08:04:27 <fasta> dankna, what is your current real project?
08:04:46 <fasta> dankna, I think some Dutch guy did so.
08:05:02 <dankna> A diagram editor for the Mac with certain features that I'd rather not talk about in a channel as full of professionals as this one, until it's more complete. )
08:05:03 <dankna> :)
08:05:21 <Zao> Aaw, I had my notepad out and all.
08:05:26 <fasta> dankna, heh.
08:05:30 <dankna> haha
08:06:00 <dankna> but I think I have a good niche there.  There's not much competition, except OmniGraffle.  That's stiff competition, but yeah, I think I have an angle on it.  Pun intended.
08:06:13 <dankna> thanks for asking :)
08:07:16 <fasta> dankna, I think there is a market for the implementation of non-trivial geometrical algorithms.
08:07:42 <dankna> fasta, I think you're right, but I'm curious to hear your take on how and why
08:07:57 <fasta> dankna, what are you doing differently (when compared to OmniGraffle)?
08:08:38 * roconnor quickly goes to scoop dankna!
08:08:40 <fasta> dankna, because it seems that quality implementations simply do not exist.
08:09:04 <dankna> I've got more powerful drawing features, but more importantly I have the feature I'm not sure I want to talk about
08:09:11 <dankna> well, okay, I will ^^''
08:09:22 <dankna> constraint-satisfaction drawing tools
08:09:29 <dankna> like "keep these objects distributed"
08:09:36 <dankna> "keep these things aligned"
08:09:49 <fasta> dankna, what kind of constraints? Linear constraints are already implemented in some tools.
08:09:50 <theorbtwo> Yey!
08:09:56 <dankna> that feature is still in the planning stage, but I've got good ideas for how to GUIfy it
08:10:08 * theorbtwo has always wanted that sort of drawing program.
08:10:09 <dankna> yeah, I've seen some of those tools.
08:10:27 <dankna> if you know of any really good, usable ones, I'd love to see them, so I know what I'm up against
08:10:35 <fasta> I have no idea whether OmniGraffle does that, though.
08:10:53 <dankna> it doesn't do anything remotely like that
08:11:01 <bfh6558> anyone have the vim haskell_doc plugin working properly for them?
08:11:08 <fasta> OmniGraffle has a high "looks like a designer worked on it"-aura.
08:11:13 <dankna> yeah
08:11:19 <dankna> which is nice, really, since designers are their market...
08:11:22 <fasta> But I never actually used it.
08:11:33 <dankna> I've used it enough to know what I would do differently :)
08:11:48 <quicksilver> I thought omnigraffle had some constraints
08:11:54 <quicksilver> but I've only used it for about 12 seconds
08:11:58 <dankna> I don't believe it does.
08:12:08 <dankna> It has "magnets" for attaching lines to things, but those are unidirectional
08:12:09 <quicksilver> mostly I've just absorbed the fanatical cultishness of its fans
08:12:15 <dankna> it's not real constraint programming
08:12:23 <quicksilver> dankna: that is probably what they were talking about, though.
08:12:27 <dankna> yeah, okay
08:12:33 <fasta> quicksilver, right. Their marketing is great.
08:12:38 <dankna> I have a plan for how I'll do those better, though
08:13:31 <dankna> I also have a bunch of planned features for doing UML better, because a little market research (mostly consisting of checking the prices of different google keywords to find out how many people want those things, heh) tells me that UML is a big market
08:13:35 <dankna> not full UML
08:13:36 <dankna> just a subset
08:13:52 <fasta> I think if I was the OmniGraffle CEO I would contact some blog authors and offer to make some diagrams for free and put my best designer on it on the condition that it appears that the blog authors made the diagrams themselves.
08:13:59 <dankna> because there's no point in doing full UML unless I really think claiming to support *everything* will get me customers
08:14:04 <dankna> hrm
08:14:07 <fasta> That might be what they already have done.
08:14:10 <dankna> that would be a little dishonest, I think
08:14:20 <fasta> dankna, going to war is dishonest too.
08:14:32 * dankna blinks!
08:14:34 <fasta> dankna, companies, er strike, governments, do that all the time.
08:14:51 <dankna> I've heard it called many things, but not dishonest.  but this isn't #politics :)
08:14:58 <dankna> so I'll just leave it at that
08:15:29 <lispy> dankna, fasta: sounds like a  good topic for #haskell-blah if you do want to continue it :)
08:15:40 <dankna> haha, nah, I'd rather brag about my vaporware :D
08:15:46 <dbro> dankna - you may also be interested in looking at google trends for those query strings
08:15:53 <dankna> dbro: good suggestion, I should
08:15:56 <quicksilver> fasta: there
08:16:13 <theorbtwo> I think the best way to compete with omnigraffle is not to -- make a program that is aimed at non-graphics-designers who want to make decent-looking graphics, rather then at graphics designers who want to make great ones.
08:16:20 * quicksilver tries to remember where that sentence was going.
08:16:28 <dbro> you need both price and volume to size the market
08:16:35 <quicksilver> fasta: there isn't much competition in the precise niche/market than omni* targets
08:16:47 <quicksilver> fasta: very few people make the kind of software that makes people go 'Ooh' like that
08:16:52 <dankna> Orb: well, I think you have a point.  I definitely feel tension between the two audiences...
08:17:02 <quicksilver> (a particular group of people, sure, but there are enough of them to base a product on )
08:17:20 <dankna> I have one feature already, curved text, which Omni doesn't, and it gets "ooh"s from my testers.  so I think it was worth the effort to put in even though it strikes me as pretty useless :)
08:17:28 <quicksilver> dankna: ooh
08:17:30 <dankna> hehe
08:17:41 <Twey> Is this going to be limited to OS X?
08:17:43 <dankna> yes.
08:17:47 <Twey> Aw :(
08:17:48 <theorbtwo> Oh.
08:17:55 <ClaudiusMaximus> fasta: were you looking for this, perhaps? http://www.michaelbeeson.com/research/talks/KobeGeometrySlides.pdf
08:17:57 <dankna> I can't imagine doing something like this cross-platform and making it truly polished.
08:18:08 <quicksilver> theorbtwo: I just write tex macros for that kind of thing :P
08:18:24 <quicksilver> xymatrix has a sufficiently good constrain solver hidden inside it for most purposes.
08:18:24 <Twey> Yeah, TikZ it is, I guessâ€¦
08:18:25 <fasta> ClaudiusMaximus, I don't think so. It was presented on some Dutch Haskell user meeting.
08:18:27 <theorbtwo> quicksilver: I mostly write SVG, but SVG leaves a fair bit to be desired.
08:18:33 <quicksilver> but I'm not the right target market.
08:18:46 <theorbtwo> These days, I write perl scripts that write svg.
08:18:55 <dankna> xymatrix, hrm.  that's a tex package?  I'll have to look into it.
08:19:10 <theorbtwo> (Reminds me, I should release that, or at least put it on git and write a blog entry or something...)
08:19:15 <lispy> xymatrix is cool
08:19:27 <fasta> dankna, Metapost basically does linear constraint-solving.
08:19:30 <lispy> dankna: takes a bit to learn the power of it, but you can make really cool diagrams
08:19:45 <dankna> gotcha, neat
08:19:59 <fasta> dankna, its user-interface kind of suxors, but with polish it could be a useful program.
08:20:05 <dankna> I have a collection of diagrams that were made with other tools to be use-cases for my own
08:20:13 <dankna> I should find some made with that
08:20:25 <dankna> fasta: I'm not sure I'd call source code a user interface :)
08:20:32 <quicksilver> it is, though.
08:20:35 <dankna> hrm
08:20:35 <fasta> dankna, a user interface in which you can program your graphics on one side of the screen and see the result on the right.
08:20:40 <dankna> yeah, I suppose it is
08:20:49 <quicksilver> it might not be the best one
08:20:50 <fasta> dankna, and where the two can be edited.
08:20:52 <quicksilver> but it's a very powerful one.
08:21:03 <quicksilver> fasta: yes, metapost is cooler than xymatrix
08:21:10 <dankna> lispy: do you have any particularly nice examples for my clip file?
08:21:11 <quicksilver> but xymatrix had more prebuilt pieces that were useful to me
08:21:23 <quicksilver> although I did have to add some pstricks tricks to it.
08:21:31 <lispy> dankna: you want the .tex and corresponding output?
08:21:31 <fasta> dankna, that is, being able to move points in the visualization which changes the source code, etc.
08:21:38 <dankna> lispy: yes please!
08:21:43 <lispy> dankna: at the moment, I don't have access to the .tex of it
08:21:46 <dankna> fasta: that would rock, but I fear it's out of scope for my project
08:21:48 <fasta> dankna, that would be a useful tool for computer scientists at least ;)
08:21:49 <lispy> dankna: I just have the pdf
08:21:51 <dankna> okay.  I'll settle for just the output :)
08:21:57 <lispy> okay
08:22:16 <dankna> maybe in version two.  right now I already have a tight schedule, and I feel I'll get a wider audience with every major feature GUIfied
08:22:32 <theorbtwo> If you haven't, you might want to find mark-jason dominous' linograph project.
08:22:34 <dankna> it's certainly something to chew on
08:22:37 <fasta> ClaudiusMaximus, ah, that does look interesting. Maybe the Dutch guys simply presented that.
08:22:38 <dankna> I haven't, I'll look into it
08:23:08 <theorbtwo> It's not quite what you are doing -- for one thing, it's very much not gui -- but is close enough to potentially be inspiring.
08:23:15 <fasta> ClaudiusMaximus, er no, not a line of Haskell. So, I guess not.
08:23:25 <Vasily[w]> hi ^_^
08:23:33 <lispy> dankna: The full pdf is here: http://ir.library.oregonstate.edu/jspui/bitstream/1957/11180/1/thesis.pdf  If you flip to chapter 3, you will see some funky lines over the commutations.   That's all xymatrix
08:23:34 <fasta> dankna, does your project even have a scope?
08:23:43 <quicksilver> guis are hard. let's go shopping.
08:23:48 <Vasily[w]> i'm trying to stude haskell
08:23:50 <fasta> quicksilver, right.
08:23:52 <Vasily[w]> and get some problem
08:23:59 <Vasily[w]> http://pastebin.com/d53c29a05
08:24:06 <quicksilver> it's extremely difficult to make a GUI which is both (a) extremely powerful and (b) remotely usable
08:24:09 <Vasily[w]> how can i say, that x==p?
08:24:18 <dankna> fasta: yes, I have looked at my major competitors and done feature triage on what to include, what to exclude, what's version two
08:24:37 <dankna> this is hopefully going to pay my bills for a while; I have to take it pretty seriously
08:24:43 <lispy> dankna: page 36 has nice examples too
08:24:52 <dankna> quicksilver: I agree.  which is why it's a niche I can live in :)
08:24:57 <dankna> looking, lispy!
08:24:59 <fasta> dankna, that's a good start.
08:25:12 <dankna> if you have suggestions for further process, I'm all ears
08:25:14 <quicksilver> Vasily[w]: x and p are both free type variables
08:25:24 <quicksilver> Vasily[w]: they can certainly be instantiated to the same type
08:25:25 <fasta> quicksilver, the best UI is an AI with a bigger brain than yourself ;)
08:25:51 <quicksilver> Vasily[w]: what ctually is the problem?
08:25:59 <Vasily[w]>     Couldn't match expected type `p' against inferred type `x'
08:25:59 <Vasily[w]>  
08:26:24 <dankna> lispy: hmm okay, I see the stuff you're pointing out.  thanks.
08:26:38 <dankna> I don't feel a strong need for the source code to this, I can see what the data model must be.
08:26:40 <dbro> noobie question: how can I pop a value out of a Maybe construct, ie, how can I remove the "Just" in "Just 3" for instance
08:26:44 <mightybyte> Is there an idiom for parsec parsers separated by a fixed string?  ('many anyChar `sepBy` string "xyz"' doesn't do the trick since 'many anyChar' also matches 'string "xyz"')
08:26:47 <Twey> How do MetaPost and TikZ compare, quicksilver, fasta?
08:27:03 <fasta> Twey, TikZ is not in my database.
08:27:07 <Twey> Huh.
08:27:10 <dankna> dbro: there are two methods.  the preferred one is to pattern match against it, in a case statement or a do <- thing.
08:27:18 <dbro> ok
08:27:20 <mightybyte> ...or does a parser like that require me to left-factor the grammar?
08:27:28 <dankna> dbro: the other one is to call fromJust, but this is bad because it may throw an error, even in otherwise-pure code.
08:27:35 <Twey> Looking at the user's manual for MetaPost, they look quite similar (\draw (20, 20) -- (0, 0) &c.)
08:27:35 <dbro> ok thanks
08:27:59 <lispy> dankna: http://en.wikibooks.org/wiki/LaTeX/Creating_Graphics#XY-pic
08:28:07 <dankna> lispy: ah, excellent
08:28:09 <quicksilver> mightybyte: do you really want to parse "xyxyzxy" as "xy" xyz "xy" ?
08:28:37 <quicksilver> mightybyte: i.e. you have strings which are prefixes of your separator?
08:28:41 <Twey> Oh, but it has loops and stuffâ€¦
08:29:08 <fasta> Twey, what is TikZ? A program, a language a collection of examples?
08:29:14 <Vasily[w]> quicksilver: http://pastebin.com/d233aaaab
08:29:23 <mightybyte> quicksilver: I don't know my data spec in detail, so I'm assuming that I may get strings that are prefixes of the separator.
08:29:24 <dankna> I'm glad I decided to talk about this, the feedback has been useful.
08:29:39 <Twey> fasta: It's a sort ofâ€¦ embeddable drawing language for LaTeX
08:29:49 <fasta> dankna, Turing-Complete?
08:29:55 <quicksilver> mightybyte: no, I don't think there is a parsec idiom for that.
08:30:00 <fasta> Twey, Turing-Complete?
08:30:03 <quicksilver> mightybyte: it's going to be nasty.
08:30:05 <dankna> not a design goal to be Turing-Complete for its own sake, but if it winds up being, I won't complain
08:30:09 <Twey> fasta: I don't know
08:30:18 <mightybyte> quicksilver: So yes, your example is what I want.  (The equivalent of split just using multiple characters)
08:30:21 <mightybyte> quicksilver: :(
08:30:23 <osaunders> Is there a median function?
08:30:24 <Twey> I don't think so, but I might be wrong â€” many of its advanced features still confuse me
08:30:26 <quicksilver> Twey: I don't think TikZ existed back when I did this stuff. It certainly never crossed my radar.
08:30:31 <quicksilver> Twey: it looks interesting.
08:31:17 <mightybyte> quicksilver: It seems to me that it shouldn't be too hard to do something like that.  It's just successive string searches for the separator string.
08:31:24 <quicksilver> Vasily[w]: the signature for presign says that it is polymorphic in the return type.
08:31:32 <Twey> Wait, I recognise that hostâ€¦ MissPiggy is vixey?
08:31:35 <quicksilver> mightybyte: it's not hard. It's just not a very good match for parsec.
08:31:46 <quicksilver> mightybyte: it is probably simpler to do it by hand.
08:31:53 * Twey slow
08:32:07 <quicksilver> Vasily[w]: your instance of it isn't. Presumably pmul is not polymorphic in its return type.
08:32:19 <mightybyte> quicksilver: Ok, I'll look at that.  Having to used parsec before, I thought this might be a good place to start.
08:32:26 <Vasily[w]> quicksilver: yes, it returns first passed type
08:32:28 <mightybyte> s/to used/not used/
08:32:53 <MissPiggy> ?vixey
08:32:53 <lambdabot> what type of music do you like?
08:33:02 <quicksilver> Vasily[w]: well I don't know what you're trying to do, but you can't write that instance that way.
08:33:19 <quicksilver> Vasily[w]: maybe that's not the signature for presign you really want.
08:34:24 <Vasily[w]> quicksilver: I want to have some abstraction for hecc library. I want have container DPa, that contains some type, with that hecc can work (ECP), and parse it from input data
08:36:35 <osaunders> Is there a terser way of writing this? http://codepad.org/MtKAI8lI I'm only changing one value the rest just stay the same. What bothers me is that this function will have to be adjusted if I were to add to GameChr.
08:37:10 <dankna> if you were using record syntax, there would be
08:37:23 <MissPiggy> hakell
08:37:23 <dankna> that's imo the best reason to use record syntax
08:37:34 <osaunders> dankna: How would it look?
08:38:23 <dankna> character `hitBy` attack = character { life = life character - atkDmg attack }
08:38:26 <dankna> I believe
08:38:52 <dankna> what that's doing is constructing a new object which is the same as the given one in all fields except the specified one
08:39:04 <dankna> which is what you want
08:39:11 <osaunders> Ah!
08:39:12 <lispy> only specify what you want to change, yeah
08:39:14 <osaunders> Awesome.
08:39:30 <osaunders> Thnxyou dankna
08:39:32 <lispy> "life character" fetches the current value
08:39:39 <dankna> I'd also encourage yo not to use abbreviations; it gets frustrating trying to remember which words you abbreviated and to what.  but then, going that route leads to 30-character variable names, which may not be to your taste :)
08:39:40 <lispy> and life = ..., sets a new one
08:39:55 <dankna> *you
08:40:12 <quicksilver> Vasily[w]: I'm sorry. Your problem requires too much domain specific knowledge for me to give you a good answer. Perhaps someone else will have more time.
08:40:22 <quicksilver> dankna: or at least use them *very* consistently.
08:40:29 <dankna> quicksilver: yeah, exactly
08:40:39 <fasta> If you use a good editor, then the length of variable names should not be a problem.
08:40:48 <dankna> things in libraries that have been approved by major standards organizations fall into the category of "I don't like it, but I can accept it" :)
08:40:59 <lispy> > let { foo Just {} = True; foo Nothing = False } in foo (Just 1) -- interesting "abuse" of record syntax
08:41:00 <lambdabot>   True
08:41:14 * hackagebot upload: type 0.2.0 - Dynamic casting library with support for arbitrary rank type kinds. (TopiKarvonen)
08:41:30 <dankna> well, it's still a problem in that it makes you have to wrap your lines more often, but that just encourages a style where no one line tries to do very much, which I like anyway and view as a nice synergy
08:41:58 <quicksilver> in the extreme, it reduces the amonut of information in one 'screen' or 'page'
08:42:06 <quicksilver> no matter what line width or font size you choose.
08:42:08 <dankna> that's true, of course
08:42:13 <quicksilver> so, in the extreme, it's not a good thing
08:42:21 <MissPiggy> so whats up
08:42:21 <quicksilver> however, that doesn't mean only use one character names :)
08:42:44 <dankna> well, I agree that there is a balance point, but not quite for that reason
08:42:54 <dankna> I'm not sure it does reduce the information, it's just *different* information
08:43:08 <dankna> because the longer name has more informational content than the shorter one, too
08:43:42 <quicksilver> dankna: it might. Depends how much duplication on one screenful. Certainly the information content may differ.
08:43:46 <dankna> that's true.
08:44:31 <quicksilver> there is also a balance point involving how intimately acquantainted with the code (and, in particular, the meanins of names) you expect the reader of this file to be.
08:44:41 <dankna> if you have to use ten variables in one function that all have a common prefix, you should find a way to refactor so they don't need that prefix
08:44:42 <quicksilver> but I think we're just agreeing noisily and at length.
08:44:43 <dankna> that is very true
08:44:52 <dankna> yes.  well, it's nice to meet with some agreement :)
08:44:59 <quicksilver> dankna: No. It's not.
08:45:05 <dankna> most people don't seriously consider names that long
08:45:07 * dankna laughs
08:45:07 <quicksilver> ;-P
08:45:46 <quicksilver> well in a language like haskell which makes it easy to define combinators, you might wonder if you have something missing if your algebra of names has too much structure.
08:45:56 <dankna> yes, indeed
08:46:00 <quicksilver> if you have { fooBar, fooBaz, fooBam, fooZor }
08:46:10 <Kostafey> Hi! How can I make subtraction of 2 lists,
08:46:10 <Kostafey> wich are elements of other list?
08:46:10 <Kostafey>  
08:46:10 <Kostafey> Here is an idea (but it isn't work):
08:46:14 <Kostafey>  
08:46:16 <Kostafey> subtraction :: Int -> Int -> [[Double]] -> [Double]
08:46:20 <Kostafey> subtraction i' i'' matrixX = [x-y | x <- (matrixX !! i'), y <- (matrixX !! i'')]
08:46:22 <Kostafey>  
08:46:25 <quicksilver> then you might wonder "is there some operator ## and some values foo, bar, baz, bam, zor, such that fooBam is foo ## bam
08:46:28 <quicksilver> etc.
08:46:42 <quicksilver> Kostafey: please don't do that.
08:46:44 <dankna> Kostafey: please use hpaste rather than pasting code here
08:46:49 <quicksilver> Kostafey: (paste 8 liines all at once)
08:46:59 <dankna> yeah, exactly so
08:47:06 <Kostafey> ok, sorry
08:47:08 <FliPPeh> :)
08:47:13 <dankna> and it definitely leads to better code to think about those questions as you work
08:47:15 <FliPPeh> At least you've got attention now
08:47:31 <dankna> you also need to clarify your question.  I'm not sure what you mean by subtracting the lists.
08:47:45 <quicksilver> he appears to mean subtracting two rows of a matrix
08:47:48 <dankna> hmm
08:47:50 <quicksilver> (leading to a vector)
08:47:50 <dankna> oh, yes, I see
08:48:20 <quicksilver> Kostafey: list comprehension go through lists 'independently'
08:48:39 <quicksilver> Kostafey: so that is traversing (matrixX !! i') and (matrixX !! i'') separately in every possible combination
08:48:46 <quicksilver> Kostafey: so you got an answer much longer than you expected, right?
08:48:51 <FliPPeh> Haskell is depressing me #4. Today: Haskell has such a clear syntax, and can look so good, but once you need to get sh** done and need to use monads, monad transformers and stuff like that, the code tends to become unreadable :(
08:49:00 <quicksilver> you wanted to traverse the two lists in parallel, instead.
08:49:19 <aavogt> you don't need monad transformers
08:49:36 <pikhq> FliPPeh: You very rarely need monad transformers.
08:49:42 <FliPPeh> Mhh
08:49:43 <kmc> FliPPeh, when writing imperative code, for it to be readable you must invest effort into writing abstractions for the particular problem you're solving
08:49:50 <kmc> just like writing functional code
08:50:09 <lament> you don't need monad transformers?
08:50:13 <FliPPeh> When I look at other people sources, I never see the things I love about haskell, I see a lot of monad spamming I don't understand at all :(
08:50:15 <quicksilver> I know what FliPPeh is referring to and it is occasionally a frustration but it's a very non-specfic complain. In specific cases there are always ways to make the code readable again.
08:50:22 <pikhq> If your code is ugly, write some functions or expressions that make it more beautiful.
08:50:26 <fasta> aavogt, is that in the same sense that two need just one primitive to compute?
08:50:27 <quicksilver> quite,
08:50:42 <kmc> i guess people are used to imperative languages with poor abstraction so they don't see the abstractions
08:51:07 <pikhq> lament: Not in *general*. In specific cases, yes, they're useful.
08:51:40 <fasta> If you want a computation doing stuff which exists in two monads, the easiest way to implement that is to use monad transformers.
08:51:41 <pikhq> A gigantic stack of them, though, probably means you're doing something wrong.
08:51:54 <aavogt> fasta: in the sense that you can either hide the fact you use transformers (by using a newtype, and generalized newtype deriving), or often a predefined monad is sufficient like RWS
08:51:56 <kmc> FliPPeh, if you don't understand the monadic code other people write, then maybe it's a sign you should learn more rather than a sign that their code is ugly
08:51:56 <fasta> pikhq, or something which is inherently complicated.
08:52:10 <kmc> i find the stuff in Control.Monad and Control.Applicative helps in writing readable monadic code
08:52:11 <pikhq> fasta: Or something which is inherently *very* complicated, yes.
08:52:18 <aavogt> my code is inherently ugly
08:52:20 <FliPPeh> kmc: You're right, but I didn't say it's ugly :)
08:52:32 <FliPPeh> kmc: I just say it's hard to understand and becomes crowded
08:52:40 <aavogt> use more whitespace
08:52:46 <fasta> If you don't want to explicitly lift stuff in your monad, then you get huge types.
08:52:56 <fasta> That is types, that fill about half of your screen.
08:53:11 <dankna> solution: don't do that then :)
08:53:14 <FliPPeh> Also, why doesn't me hilighting work.
08:53:21 <FliPPeh> Anyone here using IRSSI and got nick hilights?
08:53:31 <pikhq> FliPPeh: Yuh.
08:53:38 <pikhq> It's called "the default settings". ;)
08:53:47 <FliPPeh> Doesn't do it for me :/
08:53:50 <quicksilver> no
08:53:58 <FliPPeh> I see your name in blue, pikhq
08:53:59 <quicksilver> the default setting only highlights when you are addressed
08:54:04 <FliPPeh> But I want the whole line to be red
08:54:04 <quicksilver> FliPPeh: like that
08:54:11 <quicksilver> oh, that's something else.
08:54:16 <FliPPeh> I added such a statement to /hilight
08:54:18 <FliPPeh> But meh
08:54:24 <pikhq> Oh, that's something else. Beats me.
08:54:35 <pikhq> And probably overlaps with IRC color.
08:54:36 <Kostafey> But what is it "hpaste"?
08:54:45 <quicksilver> Kostafey: a website which you can paste code at
08:54:45 <FliPPeh> Kostafey: A place where you can paste long codes
08:54:48 <pikhq> (granted, most channels ban that...)
08:54:51 <FliPPeh> Damn you quicksilver
08:54:52 <quicksilver> Kostafey: but, did you get my answer?
08:54:53 <FliPPeh> You're really quick.
08:55:01 <quicksilver> Kostafey: I gave a fairly detailed partial answer to your question
08:55:07 <quicksilver> and waited for response before I carried on
08:56:40 <quicksilver> FliPPeh: 28 years of typing on qwerty keyboards have rendered me a malcoordinated half-touch typist but the words come out fairly fast.
08:56:52 <quicksilver> not always the words I wanted, unfortunately.
08:57:02 <Kostafey> Ha-ha, ok but I don't understand the answer
08:57:17 <FliPPeh> QWERTZ > QWERTY
08:57:30 <FliPPeh> :):):)
08:57:31 <quicksilver> > [ a + b | a <- [1,2,3], b <- [10,50,100] ]
08:57:32 <lambdabot>   [11,51,101,12,52,102,13,53,103]
08:57:38 <c15c8ra1n> Colemak, anyone? :)
08:57:42 <quicksilver> Kostafey: do you understand what's happening there?
08:57:52 <int-e> [{}] hurt on qwertz
08:57:58 <quicksilver> Kostafey: if you have two lists in a list comprehension it does every permutation.
08:58:13 <quicksilver> (in this case 3 * 3 == 9 elements)
08:59:42 <Kostafey> ok, but what if we use (someMatrix !! 1) instead of [1,2,3]?
08:59:55 <quicksilver> Kostafey: doesn't matter.
09:00:07 <quicksilver> the point is, list comprehension goes independently over the two possibilities
09:00:21 <quicksilver> it uses {every element from first list } and {every element from second list} in every combination
09:00:29 <quicksilver> that's not what you wanted, if I understodd you correctly
09:00:30 <Kostafey> But it is a wrong type: Int -> Int -> [[Double]] -> [Double]
09:00:35 <quicksilver> you wanted to pair up the lists.
09:00:47 <quicksilver> The type is fine, I think.
09:00:54 <quicksilver> Or at least, the type is fine for what I thought you were doing.
09:01:13 <dankna> but then, the type was the major clue to what you were doing, so :)
09:01:20 <quicksilver> My teaching approach isn't really working.
09:01:24 <FliPPeh> [18:00:19] Highlights:
09:01:24 <FliPPeh> [18:00:19]    1 $N  -color %r -actcolor %r -line
09:01:27 <FliPPeh> Mhh
09:01:31 <quicksilver> the solution to the problem I *thought* you were having is zipWith
09:01:48 <quicksilver> something like zipWith (-) (matrixX !! i') (matrixX !! i'')
09:01:57 <quicksilver> if that's not what you meant, then I don't know what you meant.
09:03:27 <Kostafey> I'll look what is is zipWith mean... :)
09:03:39 <quicksilver> it means go along two lists doing 'corresponding' pairs
09:03:42 <quicksilver> instead of every possible pair
09:03:52 <quicksilver> > zipWith (-) [10,20,30] [1,2,3]
09:03:53 <lambdabot>   [9,18,27]
09:06:40 <Kostafey> It seems it is that I need... A minute..
09:08:39 <Kostafey> Strange type: (Num [a], Num a) => Int -> Int -> [[a]] -> [a]
09:09:19 <doserj> you probably did sth wrong, like adding lists
09:09:32 <quicksilver> yes, something has made it think you need lists to be numbers
09:09:43 <quicksilver> e.g. using a number as a list or using a list as a number
09:09:49 <quicksilver> :t (1 + [1,2,3])
09:09:50 <lambdabot> forall t. (Num [t], Num t) => [t]
09:09:53 <quicksilver> like that.
09:11:16 <pikhq> Hooray, well-typed but ultimately meaningless functions.
09:11:29 <quicksilver> yes, the price we pay for numeric overloading
09:11:32 <pikhq> (unless someone decides to define naturals using [()] ?)
09:11:36 <quicksilver> I'm not always sure its's a price worth paying.
09:12:02 <quicksilver> there are some other ways to make [a] a Num instance, too. Pointwise addition (like vectors in R^n) for example.
09:12:14 <quicksilver> more sophisticated things like power series, too
09:12:34 <Kostafey> subtraction i' i'' matrixX = zipWith (-) (matrixX !! i'-1) (matrixX !! i''-1)
09:12:48 <Kostafey> :t subtraction
09:12:49 <lambdabot> Not in scope: `subtraction'
09:13:24 <dankna> the type you actually want is (Num a) => Int -> Int -> [[a]] -> a
09:13:32 <quicksilver> Kostafey: (i'-1)
09:13:38 <dankna> so give it that type signature and then try to compile it and if it doesn't match it will tell you what the actual type is
09:13:49 <quicksilver> Kostafey: probably (-) has higher precedence than (!!)
09:13:56 <quicksilver> although I wouldn't know that for sure without checking.
09:17:33 <IceDane> I think I'm about to understand monads! I can't go into more detail, but I just feel as if stuff is 'clicking'
09:17:37 <IceDane> Perhaps it's the beer I've had
09:17:53 * dankna chortles
09:17:54 <dankna> I see
09:17:54 <ehamberg> make sure not to sober up.
09:18:12 <jmcarthur> a lot of people in the google ai competition seem to be impressed by some of the things haskellers are talking about. i think we might win a few converts from it :D
09:18:35 <IceDane> ehamberg: I'm working on it
09:18:57 <pumpkin> jmcarthur: like what?
09:19:26 <jmcarthur> pumpkin: just some of the usual haskell abstractions we have that imperative languages tend to lack
09:19:32 <pumpkin> ah
09:19:40 <aavogt> jmcarthur: you're not using ST?
09:19:47 <jmcarthur> aavogt: you are?
09:19:47 <pikhq> IceDane: So, you grok that >>= and return have meaning. :)
09:19:57 <aavogt> I've been experimenting
09:20:08 <jmcarthur> no, i rely on free undo way too much
09:20:44 <pumpkin> the number of haskell entries seems to be going down
09:20:51 <pumpkin> we had 20 yesterday and are at 12 today it seems
09:20:52 <dankna> Haskellers have real work to do :D
09:21:06 <jmcarthur> pumpkin: a lot of starter packs have been removed from the ladder now
09:21:10 <pumpkin> ah ok
09:21:34 <jmcarthur> pumpkin: and a couple people have uploaded bots that timeout and get suspended (myself included), so they disappear too
09:21:46 <pumpkin> hah ok
09:21:49 <jmcarthur> i'm in the middle of a bit of a rewrite right now
09:21:57 <jmcarthur> my suspended one was the one using unamb
09:22:13 <jmcarthur> that turned out to just be too hard on the RTS
09:22:16 <pumpkin> I see
09:22:22 <pumpkin> gotta run
09:22:35 <dankna> it would be interesting to put a human player in the ladder to see how he does
09:22:43 <dankna> but I suppose that's both against the rules and not possible
09:22:54 <MissPiggy> he would have to play a thousand games?
09:23:04 <dankna> well, hrm.
09:23:37 <jmcarthur> dankna: honestly i think a human player would do about average
09:24:09 <dankna> yeah, it's not a very deep game
09:24:26 <jmcarthur> well, it's easier for people than for ai, generally
09:24:29 <gwern> don't say that until someone proves the optimal strategy :)
09:24:29 <MissPiggy> I think he'd fall asleep
09:24:34 <dankna> haha
09:24:35 <dankna> point.
09:24:39 <jmcarthur> but when in tight quarters the ai is basically going to always win, i think
09:24:44 <jmcarthur> people have slow reflexes
09:24:48 <dankna> not all people :)
09:24:55 <MissPiggy> after 1000 games I think the human wins
09:24:57 <gwern> imo, I suspect the top ai would win. a human just can't wallhug efficiently for 1000 games
09:25:05 <dankna> that may be true
09:25:11 <jmcarthur> gwern: the optimal strategy is basically minimax. the difficulty is that it's exponential
09:25:13 <dankna> what about a hybrid
09:25:26 <dankna> that gives the player wallhugging tools
09:25:28 <MissPiggy> cool idea!!!
09:25:31 <dankna> thanks :)
09:25:47 <MissPiggy> augmented intelligence
09:25:48 <savanni> Hey, all.  I have a problem that may be gtk2hs related, or it may be related to some nuance in how the repl works.
09:25:51 <dankna> yes, indeed
09:25:56 <gwern> jmcarthur: but that's not very informative, that's like saying the optimal strategy is the moves from the set of all possible moves that wins - it is true but uninformative
09:26:01 <MissPiggy> so it's still technically AI....
09:26:09 <savanni> In short, it is a tiny little program (an example) that puts an icon in the status field.
09:26:11 <dankna> gwern: chortle.  yeah.
09:26:57 <jmcarthur> gwern: yeah i know it's uninteresting, but i'm not sure there is a better way to "solve" the game
09:27:01 <pikhq> gwern: So... The optimal strategy is the solution of the game.
09:27:02 <savanni> I have no problems if I execute the individual commands for displaying the icon in the repl, or if I take the whole program, compile it, and run the executable.  But if I run my main function from the repl, the icon disappears after about half a second, even though the main loop is still running.
09:27:05 <jmcarthur> maybe some speedups
09:27:12 <jmcarthur> but probably still exponential
09:27:26 <savanni> Does anyone have any idea what might cause this behaviour?
09:27:42 <gwern> jmcarthur: well, I've already bent your ear about what I consider the optimal strategy - which is not expressed in such tautological terms :)
09:27:52 <jmcarthur> heh
09:29:46 <Kostafey> Please, don't throw sth heavy to me, but is smt like javadoc for java exists for haskell?
09:29:53 <gwern> haddock
09:30:28 <MissPiggy> :(
09:30:32 <pikhq> There's also Literate Haskell.
09:30:35 <pikhq> And TeX.
09:30:38 * MissPiggy drops a piano on Kostafey
09:30:41 <pikhq> Delicious, delicious TeX.
09:31:03 <gwern> tex and lhs are not isomorphic to javadoc
09:31:11 <MissPiggy> pikhq and TeX up a tree, L-a-T-e-X-i-n-g...
09:31:24 <pikhq> gwern: Somewhat similar in purpose, though.
09:31:37 <dankna> that's six syllables and then eight syllables
09:31:51 <dankna> depending on how you pronounce pikhq, I guess
09:31:59 <pikhq> MissPiggy: That's \tex to you.
09:32:09 <pikhq> :P
09:43:17 <c_wraith> :t uncurry (flip ?f)
09:43:18 <lambdabot> forall b a c. (?f::b -> a -> c) => (a, b) -> c
09:43:43 <c_wraith> :t uncurry . flip
09:43:44 <lambdabot> forall a b c. (b -> a -> c) -> (a, b) -> c
09:44:06 <paulvisschers> Am I the only one who is very annoyed by the mtl vs transformers and monads-fd packages
09:44:16 <c_wraith> no.  it's a pox
09:44:48 <MissPiggy> I heard there was a new idea that could replace transformers
09:45:16 <aledge> balderdash
09:45:23 <paulvisschers> every time I have problems with this, missing instances of classes because dependencies are different
09:46:30 <monochrom> Pick the package you like and expose it. Hide the alternative packages.
09:46:42 <c_wraith> monochrom, that doesn't really solve anything.
09:47:03 <c_wraith> because if you're using packages from hackage, you end up depending on both
09:48:51 <paulvisschers> c_wraith: indeed, very annoying
09:51:22 <ddarius> preflex: seen newsham
09:51:22 <preflex>  newsham was last seen on #haskell-blah 16 hours, 21 minutes and 56 seconds ago, saying: banner A
09:55:59 <handonson> is there a traditional version (that is, not the round-to-even one) of round function in Haskell?
09:56:33 <Twey> Er, what?
09:56:41 <Twey> > round 5.5
09:56:42 <lambdabot>   6
09:56:43 <Twey> > round 5.0
09:56:44 <lambdabot>   5
09:56:45 <Twey> > round 5.3
09:56:46 <lambdabot>   5
09:56:51 <Twey> > round 5.7
09:56:52 <lambdabot>   6
09:56:56 <Twey> What did you expect it to do?
09:56:58 <c_wraith> > floor 5.6
09:56:59 <lambdabot>   5
09:57:08 <c_wraith> > ceil 2.2
09:57:09 <lambdabot>   Not in scope: `ceil'
09:57:14 <aavogt> > round 6.5
09:57:15 <c_wraith> > ceiling 2.2
09:57:15 <lambdabot>   6
09:57:15 <Twey> You want floor?  floor isn't â€˜traditional roundâ€™.  Neither is ceiling.
09:57:16 <lambdabot>   3
09:57:22 <Twey> round is.
09:57:41 <handonson> Tway, the Haskell round is 'round-to-even'
09:57:49 <handonson> > round 5.5
09:57:50 <lambdabot>   6
09:57:52 <handonson> > round 6.5
09:57:53 <lambdabot>   6
09:58:01 <handonson> see?
09:58:02 <c_wraith> err, ok, that is a bug.
09:58:13 <MissPiggy> bankers rounding
09:58:14 <handonson> no, that is intended. that is called 'round-to-even'
09:58:19 <handonson> yes, the bankers rounding
09:58:23 <Twey> Huh.
09:58:27 <MissPiggy> > round 7.5
09:58:28 <lambdabot>   8
09:58:30 <MissPiggy> > round 8.5
09:58:31 <lambdabot>   8
09:58:38 <Twey> Well never did I hear of that one before.
09:58:47 <MissPiggy> if you ALWAYS round up, the average is BIGGER
09:58:54 <MissPiggy> if you bankers rounding then the average is 0
09:58:58 <MissPiggy> wel
09:59:02 <MissPiggy> 0 distance
09:59:17 <MissPiggy>  so rounding this way is better*
09:59:28 <MissPiggy> (* terms and conditions may apply)
09:59:31 <handonson> MissPiggy is right, and and i am very happy that bankers rounding is the default rounding of Haskell, but for a specific purpose, i currently need a traditional version of rounding
09:59:36 <dankna> roundTheExpectedWay foo = floor (foo + 0.5)
09:59:57 <dankna> there's probably a nice pointfree way to write that
10:00:16 <handonson> dankna, thanks. i couldn't think of that
10:00:20 <dankna> sure thing
10:00:26 <c_wraith> floor . (+ .5)
10:00:34 <c_wraith> not really any better
10:03:55 <sinelaw> @pl \x -> floor (x+0.5)
10:03:55 <lambdabot> floor . (0 . 5 +)
10:04:15 <sinelaw> same
10:04:17 <MissPiggy> yuck
10:04:20 <jmcarthur> weird
10:04:23 <c_wraith> that's not even valid
10:04:33 <c_wraith> it apparently treated 0 and 5 as functions
10:04:37 <sinelaw> the spaces shouldn't be there
10:04:38 <sinelaw> yeah
10:04:42 <sinelaw> @pl \x -> floor (x+b)
10:04:43 <lambdabot> floor . (b +)
10:04:45 <jmcarthur> :t floor . (0 . 5 +)
10:04:46 <lambdabot> forall b a b1 (f :: * -> *). (RealFrac (f b1), Integral b, Num (a -> b1), Num (f a), Functor f) => f b1 -> b
10:04:51 <jmcarthur> it's valid ;)
10:04:52 <MissPiggy> this is why reimplementing everything is STUPID
10:04:59 <Twey> Haha
10:05:10 <sinelaw> wtf is that
10:05:15 <c_wraith> caleskell
10:05:16 <MissPiggy> these tools need rewritten.
10:05:20 <Twey> No, just failskell
10:05:21 <jmcarthur> functions could be instances of num
10:05:44 <jmcarthur> oh yeah, and caleskell
10:06:03 <lispy> import Caleskell hiding (Prelude)
10:06:36 <zygoloid> @type floor Prelude.. (0 Prelude.. 5 +)
10:06:38 <lambdabot> forall b b1 c a. (RealFrac (a -> c), Integral b, Num (b1 -> c), Num (a -> b1)) => (a -> c) -> b
10:07:41 <MissPiggy> I want someone to read my whole haskell program and tell me how to make it better
10:07:44 <MissPiggy> :(
10:08:04 <Twey> I want someone to write all my Haskell programs for me
10:08:08 <Twey> :Ã¾
10:08:37 <handonson> MissPiggy, send it to the mailing list, maybe someone has too much free time
10:08:59 <MissPiggy> it's 256 lines ^..^
10:09:08 <MissPiggy> 5 files
10:09:36 <dschoepe> using hlint is at least a start
10:10:27 <MissPiggy> oh is that like lisp critic
10:10:55 <sinelaw> MissPiggy, yeah hlint is a good start.
10:11:07 <sinelaw> cabal install hlint
10:11:14 <MissPiggy> lol I love cabal install
10:11:25 <MissPiggy> installing it is such a hassle but it's great once it works
10:11:29 <aavogt> maybe disregard the suggestions for making stuff pointfree though
10:11:40 <MissPiggy> I don't really need suggestions from an AI
10:11:42 <sinelaw> you don't have to accept all its remarks
10:11:57 <sinelaw> but it usually finds some trivial things to improve
10:12:05 <MissPiggy> the problem of my code is much more about the bigger picture
10:12:13 <aavogt> it finds functions you never knew about
10:12:30 <MissPiggy> also is this okay?
10:12:31 <MissPiggy> type i :--> k = M.Map i k
10:12:37 <MissPiggy> I just did that so I use less brackets :|
10:14:30 <badsheepy> are you sure its not cause you want big nosed smileys throughout your code :o
10:14:36 <MissPiggy> that too :D
10:14:41 <badsheepy> :D
10:14:51 <FliPPeh> Mhhh
10:16:07 <MissPiggy> my program is like this:  some typeclasses for zero one (+)(-)(*)(/), and then I implement numbers (natural, integer, rational, complex) then polynomial normal forms and then there's a REPL that just parses your input and squishes it through the normal form and prints it out
10:16:27 <blobl> could we say fmap is object iteration throught a list of "function-like" objects?
10:16:44 <lament> @quote fmap
10:16:45 <lambdabot> ddarius says: fmap: Because getting functions to the values is half the battle.
10:16:58 <Twey> blobl: Functions and functors aren't all that related
10:18:35 <blobl> ya. i see it like this. i got two functions that will be applied to a string. one parses bbcode and another one converts nl to br. php. i have two objects that do this according an interface and i iterate through an array of that sort of objects
10:18:41 <aavogt> blobl: it's not restricted to lists
10:18:50 <aavogt> or sequences even
10:19:35 <blobl> .. and applying the funciton each time.
10:19:47 <Twey> A functor is a type that â€˜containsâ€™ (or presents an interface that pretends to contain) some value
10:20:09 <Twey> fmap is the function used to apply a transformation to the value â€˜insideâ€™ the functor
10:20:23 <aavogt> > ((*2) `fmap` (+2)) 0
10:20:24 <lambdabot>   4
10:20:29 <luqui> are there any random number generators which are good at being split?
10:20:30 <aavogt> > ((*2) `fmap` (+3)) 0
10:20:31 <lambdabot>   6
10:21:03 <Twey> The value â€˜insideâ€™ functions, as used by the functor instance for functions, is the value that will result after the function has been applied to some argument
10:21:34 <Twey> Obviously it's not *actually* inside the function, as we don't even know what it's going to be yet, but you can pretend it is
10:21:36 <aavogt> luqui: the default one in System.Random? Or you're looking for something better?
10:21:36 <sinelaw> @quote psychobot
10:21:36 <lambdabot> psychobot says: let's eat grandma vs let's eat grandma aka interfacing with a guard
10:22:00 <luqui> aavogt, i have heard that splitting is a bad idea for that one. but i don't really know the details.
10:24:42 <c_wraith> @hoogle sequence
10:24:42 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:24:43 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:24:43 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:25:06 <c_wraith> @instances Traversable
10:25:06 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
10:25:24 <luqui> @instances Data.Traversable.Traversable
10:25:25 <lambdabot> Maybe, []
10:26:53 <ddarius> data K a = K; instance Functor K where fmap _ K = K
10:26:57 <quicksilver> luqui: I think the System.Random one is 'OK' for splitting it's just not a very good PRNG.
10:27:03 <quicksilver> luqui: (small state)
10:27:21 <quicksilver> luqui: Mersenne is a much better PRNG but nobody has a good way of splitting it.
10:27:22 <c_wraith> there are issues with it and split
10:27:51 <c_wraith> in particular, if split is called on a StdGen before it's used after initialization, you end up with two StdGens in a bad state
10:27:53 <quicksilver> I'm not sure there is very much anyone knows about splittable rngs.
10:27:58 <quicksilver> which is a shame.
10:28:18 <quicksilver> c_wraith: yes; IMO that's because the initialiszation is broken, not split.
10:28:26 <blobl> uhm.. ya so lets say my functor is the objects, that contains (presenting my interface) some data and by interface definition contains a function to alter them. basically iterating through a list of that kind of objects isn't it much like mapping a function (the one inside the objects that could be simply outside) inside the functor?
10:28:31 <luqui> how are we supposed to do infinite random computations then?  get on it, researchers!
10:28:50 <quicksilver> c_wraith: the intialization mpas into a very small subset of the state space, or something.
10:29:06 <roconnor> Mersenne does infinite random computations, so long as they are all linearlly sequenced
10:29:34 <quicksilver> right.
10:29:41 <quicksilver> it's tree-branching randomness which appears to be hard.
10:29:43 <blobl> erm dont know :D
10:29:43 <luqui> yeah, not linearly sequenced is what i meant.
10:29:57 <blobl> i will eat pizza
10:30:52 <roconnor> luqui: technically you can dovetail the Mersenne sequence
10:31:12 <roconnor> luqui: er, well actually there are an uncountable number of paths in an infinite binary tree
10:31:42 <luqui> that's not an issue since we never see the leaves of such a tree
10:32:06 <dankna> hmm, is that true?
10:32:18 <dankna> it's not obvious to me
10:32:28 <luqui> which?
10:32:30 <zygoloid> dankna: you can encode infinite binary sequences in such a tree
10:32:34 <dankna> the number being uncountable
10:32:44 <zygoloid> *all* infinite binary sequences
10:32:49 <luqui> yeah it's infinite sequence of 0s and 1s.  use cantor diagonal.
10:33:00 <dankna> zygoloid: okay, yeah, got it
10:33:13 <zygoloid> or bijection with [0,1)
10:33:22 <zygoloid> hmm. [0,1]
10:33:27 <roconnor> dankna: don't be fooled, uncountable infinity is stupid and evil!
10:33:35 <dankna> roconnor: it seems like a valid concept
10:33:35 <zygoloid> surjection at least :)
10:34:05 <luqui> my intuition tells me there are a countable number of branches in an infinite binary tree
10:34:08 <roconnor> dankna: see http://knol.google.com/k/john-gabriel/are-real-numbers-uncountable/nz742dpkhqbi/10#
10:34:14 <luqui> because you could just enumerate them breadth-first
10:34:15 <roconnor> john explains it all!!
10:34:17 <roconnor> :D
10:34:21 <roconnor> j/k
10:34:29 <zygoloid> luqui: yeah. countable nodes, uncountable paths.
10:34:46 <zygoloid> (surprise!)
10:34:52 <luqui> that's weird.
10:35:57 <trzkril> luqui: most enumerations leave out all infinite paths, all of them leave out uncountably many infinite paths.
10:36:02 <dankna> roconnor: skimming that page I don't find myself having a lot of sympathy for it.  I take it that's the point.
10:36:17 <roconnor> dankna: sorry, it is a popular crank page
10:36:19 <dankna> haha, okay
10:36:33 <zygoloid> roconnor: you realise every time you post that link he gets more pagerank from the #haskell logs ;-)
10:36:45 <dankna> set theory may have its epistemological and practical problems, but that's not the argument being made there
10:36:46 <roconnor> :)
10:36:47 <zygoloid> (knol pages get a large pagerank boost anyway...)
10:36:54 <roconnor> popular =/= authorative
10:36:55 <luqui> zygoloid, well it's funny.  he should be getting pagerank.
10:37:22 <luqui> trzkril, i was talking about enumerating the branch nodes, not the paths.
10:37:24 <roconnor> actually, the page is a little usefull because he sort of spell out luqui's intuition on why it should be countable
10:37:25 <dankna> I wonder how much google juice the #haskell logs have to give out
10:37:25 <kmc_> roconnor: you don't understand, this is web 2.0.  popular things are correct by definition
10:37:49 <roconnor> then you get to figureout why it is wrong
10:37:57 <zygoloid> luqui: he's /recruiting followers/. before you know it he'll be predicting the end of the universe and there'll be ritual suicides... and darwin wins again i guess :)
10:38:13 <luqui> oh my :-)
10:38:22 <trzkril> luqui: ah, sorry, must have misread something
10:39:51 <sshc> > getLine
10:39:52 <lambdabot>   <IO [Char]>
10:39:59 <MissPiggy> oh my god the cantor stuff still??
10:40:17 <sshc> how does lambdabot define "IO a" as an instance of Show?
10:40:29 <medfly> @hackage lambdabot
10:40:30 <lambdabot> http://hackage.haskell.org/package/lambdabot
10:40:40 <burp> maybe it doesn't
10:40:40 <luqui> @hoogle Typeable a => a -> String
10:40:41 <roconnor> MissPiggy: it is a bit surprising that there are uncountable paths through a countable tree.
10:40:41 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
10:40:41 <lambdabot> Prelude show :: Show a => a -> String
10:40:41 <lambdabot> Text.Show show :: Show a => a -> String
10:41:09 <c_wraith> :t gshow
10:41:10 <lambdabot> forall a. (Data a) => a -> String
10:41:15 <MissPiggy> countable tree aka  O = N -> O  ?
10:41:15 <aavogt> instance Show (IO a) where showsPrec _ _ = "<IO a>"...
10:41:19 <MissPiggy> oops
10:41:25 <roconnor> luqui: what is even more surprising that 2^(2^N) is countable.
10:41:26 <MissPiggy> O = (N -> O) -> O  ?
10:41:39 <roconnor> luqui: for a suitable definition of (2^)
10:41:53 <MissPiggy> if countable trees are ordinals I'm not surprised they're uncountable
10:41:53 <luqui> roconnor, oh i was going to say "WHAAAAAAAT" until you said "suitable"
10:42:00 <kmc_> > gshow ()
10:42:01 <lambdabot>   "(())"
10:42:57 <kmc_> sshc: i think the instance would look something like:  instance (Typeable a) => Show (IO a) where { show = show . typeOf }
10:43:02 <kmc_> > show $ typeOf getChar
10:43:04 <lambdabot>   "IO Char"
10:43:05 <xerox> roconnor does that definition have anything to do with the standard definition?
10:43:06 <luqui> roconnor, is that under the "all functions are continuous" assumption or something?
10:43:29 <roconnor> luqui: ya, (2^X) meaning continuous functions X -> Bool
10:43:46 <roconnor> which is a fair assumption in Haskell
10:43:50 <luqui> true
10:43:58 <MissPiggy> what is the definition of countable tree?
10:44:12 <luqui> roconnor, oh of course.  that's where eskardo's enumeration comes from.
10:44:14 <MissPiggy> it sounds isomorphic to constructive ordinals up to epsilon
10:44:27 <luqui> *escardo
10:44:39 <FliPPeh> lala
10:44:43 <luqui> MissPiggy, we were talking about an infinite binary tree
10:44:55 <MissPiggy> well I was talking about the set of them all
10:44:56 <luqui> whose branches are countable but whose paths/leaves are not
10:45:39 <reitblatt> help please: "ghc-pkg version >=0 is required, but could not be found"
10:45:48 <reitblatt> ghc-pkg is in my path, what else does it want?
10:45:49 <dankna> !
10:47:59 <Saizan> reitblatt: how does your $PATH look?
10:48:27 <reitblatt> well, that's sort of a weird question
10:48:48 <reitblatt> I'm trying to get this up and running on a company system
10:48:55 <reitblatt> so the paths are all funky (and out of my control)
10:49:08 <Saizan> MissPiggy: Tree a = (Bool -> Maybe (a,Tree a)) -- something like this should fit
10:49:41 <Saizan> reitblatt: ghc seems to not interpret a literal ~ in the $PATH for example
10:50:28 <reitblatt> well, the path to the GHC binaries is absolute, so that's not it
10:50:50 <Saizan> what's reporting that error?
10:51:21 <reitblatt> when I try to run setup.hs for a hackage package (parsec)
10:51:55 <Saizan> you can override with --with-ghc=absolute/path/to/ghc-pkg
10:53:40 <sshc> is there a library I can use for more precise floating point numbers?
10:53:41 <reitblatt> Saizan: thanks, that worked
10:54:04 <kmc_> sshc: how precise?
10:54:07 <reitblatt> now it's kvetching about mtl being missing
10:54:13 <kmc_> sshc: there's a library for rational numbers, and another for exact real numbers with a higher-order representation
10:54:17 <kmc_> neither is floating-point
10:54:33 <reitblatt> which isn't showing up in ghc-pkg list, so I guess that's legit
10:54:34 <reitblatt> thanks
10:55:17 <sshc> kmc_: arbitrarily precise
10:55:51 <sshc> kmc_: probably the latter, but what are those libraries?
10:56:59 <sshc> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Arbitrary_precision looks like it's worth reading
10:57:23 <kmc_> sshc: http://hackage.haskell.org/package/HERA
10:58:37 <kmc_> sshc: that's afaik a sort of replacement for the ERA library that provides CReal
10:58:40 <kmc_> > pi :: CReal
10:58:41 <lambdabot>   3.1415926535897932384626433832795028841972
10:58:56 <sshc> kmc_: would the former be Data.Ratio?
10:58:59 <kmc_> yeah
10:59:19 <burp> and there is the numbers package
10:59:54 <kmc_> sshc: the problem with a higher order representation is that working with (a + b) is always slower than working with a or b
11:00:03 <kmc_> the numbers don't reduce to normal forms
11:01:36 <kmc_> why bother anyway, almost every real number cannot be represented in Haskell
11:02:10 <Kostafey> What is a way to print list? I've paint this: http://paste.org/pastebin/view/15331
11:02:21 <medfly> o.O
11:02:24 <c_wraith> > show [1, 2, 3]
11:02:25 <quicksilver> 'real' numbesr are a red herring
11:02:26 <lambdabot>   "[1,2,3]"
11:02:26 <roconnor> there is also a library for Fixed point computations
11:02:33 <quicksilver> sshc just wants high precision arithmetic.
11:02:42 <medfly> Kostafey, too much IO?
11:02:43 <quicksilver> he's not actually asking for computable reals
11:02:45 <kmc_> Kostafey: it typechecks... you have a problem with it?
11:02:56 <quicksilver> just a higher precision
11:03:03 <kmc_> Kostafey: agreeing with others, i'd just use the Show instance for lists
11:03:09 <burp> numbers package for arbitrary but not dynamic precision
11:03:13 <roconnor> kmc_: Oh yeah, name one real number that cannot be represented in Haskell!
11:03:18 <kmc_> in fact "print" will do it
11:03:21 <kmc_> > print [1,2,3]
11:03:22 <lambdabot>   <IO ()>
11:03:58 <theorbtwo> roconnor: take the smallest number that can be represented in haskell.  Halve it.
11:04:07 <kmc_> that doesn't work for these exact real things
11:04:26 <benmachine> if Integers were really genuinely unbounded then your representible set is dense
11:04:27 <kmc_> http://en.wikipedia.org/wiki/Chaitin%27s_constant
11:04:44 <roconnor> theorbtwo: the real numbers cannot be well-ordered so there is not necessarily a smallest element of a set of real numbers.
11:05:13 <quicksilver> luqui: http://barista.cse.ohio-state.edu/wiki/index.php/UTS
11:05:30 <kmc_> Kostafey: in addition to the above suggestions, there's a common pattern in your code that you should learn to identify.  the case for [] is return (), and the case for (x:xs) does something with x and then recurses on xs
11:05:36 <sshc> I'm probably missing something obvious, but after I loaded the module Data.Number.Real, ghci complains "No instance for (Floating CReal)" when I try$ pi :: CReal
11:05:36 <quicksilver> @tell luqui http://barista.cse.ohio-state.edu/wiki/index.php/UTS claim to have a splittable rng based on SHA1
11:05:37 <lambdabot> Consider it noted.
11:05:40 <kmc_> that pattern is abstracted by mapM
11:05:43 <roconnor> kmc_: damn it
11:06:00 <kmc_> if you don't care about getting a list of the results of your actions, you can use mapM_
11:06:10 <theorbtwo> roconnor: There are a pair of real numbers a & b such that a is not equal to, greater then, or less then b?
11:06:26 <sshc> looking at the package, CReal doesn't seem to be what I want
11:06:27 <benmachine> theorbtwo: no, that's subtly different
11:06:33 <benmachine> reals are totally ordered
11:06:37 <Cale> The real numbers can be well ordered, but the well ordering isn't computable.
11:06:42 <kmc_> theorbtwo: what's the smallest element of (0, 1]
11:06:50 <benmachine> but well-ordering is where you can choose the smallest element in a set
11:06:53 <kmc_> it has a greatest lower bound but that bound is not in the set
11:06:55 <FliPPeh> > let tup = [(111, "The"), (222, "Game")] in map (\(_, w) -> w) tup
11:06:56 <lambdabot>   ["The","Game"]
11:06:57 <roconnor> sshc: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Fixed.html
11:07:15 <benmachine> Cale: how does that work?
11:07:46 <theorbtwo> kmc_: Hm.  If we were talking about real numbers, and not about numbers that the computer can represent, I'd agree with you.
11:08:15 <theorbtwo> The smallest element of (0,1] that is representable is exactly the number I just mentioned.
11:08:31 <kmc_> theorbtwo: there is no smallest element of (0,1] representable by CReal
11:08:41 <kmc_> for any x in that interval, you can represent x/2 as a CReal
11:08:43 <theorbtwo> kmc_: Really?  In finite memory?
11:08:46 <FliPPeh> > (0,1]
11:08:46 <kmc_> yes
11:08:47 <lambdabot>   <no location info>: parse error on input `]'
11:08:50 <benmachine> in finite memory
11:08:50 <kmc_> well
11:08:52 <kmc_> sort of
11:08:53 <benmachine> not in bounded memory :P
11:08:54 <Cale> benmachine: There's a theorem from set theory which says that every set can be well ordered. It uses (and is equivalent to) the axiom of choice.
11:09:00 <Kostafey> show list comes with error *** Type           : [Char] *** Does not match : IO a
11:09:11 <Kostafey> print list works fine
11:09:12 <theorbtwo> benmachine: My computer does not have unbouned memory.  Does yours?
11:09:16 <benmachine> Cale: oh, but the ordering might not be the same ordering as the conventional?
11:09:25 <Cale> benmachine: Of course.
11:09:25 <roconnor> benmachine: be aware that the axiom of choice is a ridiculous axiom.
11:09:35 <Cale> It's not ridiculous at all.
11:09:40 <Cale> It's quite intuitive.
11:09:49 <benmachine> I assumed roconnor meant exactly that
11:09:50 <kmc_> theorbtwo: this is a pedantic argument and it's a boring reason why not all reals are representable in Haskell.  there are more interesting reasons
11:09:55 <benmachine> it was so intuitive as to be ridiculous
11:10:13 <Kostafey> kmc_: Am I used this pattern wrong?
11:10:18 <kmc_> besides, i think the property "representable in Haskell" should not depend on whether my computer happens to have 2 GB of RAM or 4 GB of RAM
11:10:21 <Cale> Only countably many of the reals are representable in Haskell, of course.
11:10:23 <roconnor> Cale: no, naive set theory is intuative.  The AC as applied to infinite sets is ridiculous
11:10:52 <kmc_> Kostafey: I don't understand your question.  Your code is correct -- I'm pointing out that it can be written in a shorter and clearer way using an existing library function
11:10:55 <benmachine> do infinitely long Haskell programs count? :P
11:11:13 <theorbtwo> kmc_: It would be nice, but it's simply not the case.
11:11:26 <benmachine> theorbtwo: haskell is a language, not an implementation
11:11:31 <roconnor> theorbtwo: surely it is the case
11:11:31 <kmc_> Kostafey: you'd write:   putList = mapM_ (\x -> show x ++ ", ")
11:11:38 <benmachine> there exist valid haskell programs that no computer is capable of running
11:11:51 <Cale> roconnor: I don't see why.
11:12:17 <dankna> benmachine: main = main ?
11:12:20 <benmachine> theorbtwo: hence, the limits on representation of numbers are not placed by haskell
11:12:20 <sshc> > fix (+2)
11:12:24 <lambdabot>   mueval-core: Time limit exceeded
11:12:25 <benmachine> dankna: that's easy to run :P
11:12:29 <dankna> heh, I suppose it is
11:12:37 <sshc> lambdabot was capable of running that program!
11:12:38 <FliPPeh> What would I do to introduce a new numerical type that can not be used arithemetically?
11:12:49 <kmc_> FliPPeh: what is a "numerical type"?
11:12:53 <FliPPeh> data MyNum = MyNum Int?
11:12:56 <roconnor> I don't recall anything in the H98 standard that limits the size of haskell programs
11:12:58 <FliPPeh> kmc_: A number
11:13:08 <kmc_> what makes a datatype a number?
11:13:10 <FliPPeh> kmc_: But one you cannot (+) or (/)
11:13:21 <roconnor> Cale: because in general there is no predicate that picks out a unique element.
11:13:26 <kmc_> i mean, how is it different from just any old data type
11:13:30 <sshc> FliPPeh: make it an instance of Num
11:13:37 <Cale> roconnor: Why should I need one?
11:13:41 <luite> that's interesting, usually people want things that are clearly not numbers to support + and / :)
11:13:41 <Kostafey> kmc_: thank you
11:13:42 <roconnor> and sets are/were supposed to represent predicates
11:13:52 <FliPPeh> sshc: NAh, I DON'T want it to be able to be calculated
11:13:53 <kmc_> you can't give something a fromIntegral instance (hence numerical literals) without defining (+)
11:14:00 <benmachine> I thought they were supposed to represent, you know, sets
11:14:12 <FliPPeh> kmc_: For example, A telephone number
11:14:23 <FliPPeh> kmc_: You don't want to do calculations with a telephone number
11:14:29 <theorbtwo> A telephone number isn't really a number, it's just a bunch of digits.
11:14:32 <kmc_> right
11:14:55 <roconnor> benmachine: what is a set?  the orginal definition was a collections of elements satifying a predicate.
11:14:59 <Cale> roconnor: Actually, there is such a predicate.
11:14:59 <kmc_> if i interpret your question as "What would I do to introduce a new type that can not be used arithemetically?"
11:15:14 <kmc_> then the answer is to use "data" and don't define an instance of Num
11:15:28 <FliPPeh> Hmm
11:15:30 <benmachine> or newtype?
11:15:30 <roconnor> benmachine: now there is no defintion of set.
11:15:35 <kmc_> or newtype
11:15:36 <sshc> or newtype.
11:15:37 <roconnor> it is just whatever.
11:15:50 <benmachine> roconnor: mm, fair enough
11:15:53 <Cale> roconnor: That definition doesn't work.
11:15:54 <FliPPeh> So basically what I first thought of?
11:15:58 <roconnor> whatever satifies the axioms of ZF or whatever
11:15:59 <FliPPeh> data MyNum = MyNum Int
11:16:00 <benmachine> yes
11:16:07 <kmc_> FliPPeh: in that case you can use newtype
11:16:12 <roconnor> there is no unique (upto isomorphism) model of set theory.
11:16:19 <sshc> newtype YourNum = Int
11:16:24 <benmachine> no
11:16:31 <benmachine> newtype HisNum = HisNum Integer
11:16:32 <sshc> i meannewtype YourNum = YourNum Int
11:16:33 <FliPPeh> Alrighty!
11:16:34 <FliPPeh> Thanks!
11:16:52 <roconnor> Cale: yes, of course we know that Russells showed the naive definition of set is inconsistent
11:17:03 <Cale> Right.
11:17:15 <benmachine> or newtype TheirNum = HerNum { getNumOutOfTheThing :: Integer }
11:17:21 <Cale> Frege's idea of sets doesn't really work out very well.
11:17:35 <theorbtwo> I'd define it in terms of newtype MyNum = MyNum [PhoneDigit] | MyNumPlus [PhoneDigit], I think
11:17:37 <roconnor> now it the definition of set has been replaced by some monstrosity.
11:17:43 <Cale> It's not so bad.
11:17:44 <roconnor> some non-definition
11:17:55 <kmc_> that can't be a newtype
11:17:55 <theorbtwo> (Where MyNumPlus is meant to represent phone numbers beginning with a plus.)
11:17:57 <Cale> How is it not a definition?
11:18:10 <theorbtwo> kmc_: Er, right.  s/newtype/data/.
11:18:15 <Cale> It's similar to all the other definitions of mathematical object.
11:18:15 <kmc_> i would just normalize every number to start with +
11:18:28 <Cale> Like the definition of a group or a ring.
11:18:38 <FliPPeh> I love #haskell. Once I ask something, everyone's reasoning about it :)
11:18:54 <theorbtwo> kmc_: I think it makes sense to talk about a number without the context neccessary to normalize it.
11:19:00 <kmc_> maybe
11:19:09 <kmc_> but in that case you should treat + as another uninterpreted digit
11:19:22 <kmc_> it's ugly to have a [PhoneDigit] field in both ctors
11:19:43 <theorbtwo> kmc_: Not really; a plus in the middle of a phone number isn't syntaticly valid.
11:19:45 <kmc_> maybe data Phone = Phone Prefix [Digit]; data Prefix = Plus | NoPrefix
11:19:58 <theorbtwo> kmc_: Possibly.
11:20:08 <roconnor> Cale: but the original idea of set was to something like unique model for the foundations of mathematics, like Nat is the foundation of artihmetic.  Of course they didn't use those words at the time since they wouldn't even have the knowledge to expression the ideas
11:20:25 <Cale> That's a silly idea anyway.
11:20:34 <Cale> There shouldn't be a unique model.
11:20:36 <roconnor> Cale: if you want to study something general, you should study topos or whatever.
11:20:40 <kmc_> Of course Prefix is isomorphic to Bool but I'd rather use a new type anyway
11:21:06 <roconnor> Cale: zfc has way to much cruft
11:21:26 <roconnor> Cale: ZF is far too specific and fails to be unique
11:21:29 <kmc_> is it foundations day in #haskell or something
11:21:53 <kmc_> type theory > set theory
11:23:05 <Cale> roconnor: Of course there are lots of systems to choose from, but ZFC is the one you use if you want to talk to others, simply because most people use it.
11:23:12 <kmc_> just like Java
11:23:15 <Cale> Also, the results of ZFC seem somehow natural to me.
11:23:50 <Cale> Specifically I think that without choice, you seem to miss out on a lot of functions and sets which seem like they ought to exist.
11:23:57 <roconnor> But if people used, say topos theory, we would see the more general application of their theorems.
11:24:20 <Cale> Taking the negation of choice gives infinite sets too much structure.
11:24:55 <Cale> They're supposed to be like shapeless bags of points, but when you negate ZFC, all of a sudden there are incomparable cardinalities and things like that.
11:25:03 <roconnor> (puts on a classical hat) of course on one takes the negation of choice.  They pick a contradictary axiom like determinancy.
11:25:11 * roconnor takes off the classical hat
11:25:21 * FliPPeh puts on a wizard robe and hat
11:25:25 <kmc_> hahaha
11:26:12 <Cale> Determinacy is fun, but it's probably too high an expense just to make measures behave nice.
11:26:15 <kmc_> anyone want to talk about "Finally Tagless, Partially Evaluated"?
11:26:47 <theorbtwo> Sounds like lisp with less parens...
11:27:12 <roconnor> Cale: I think you missed my point: if you want to study something general, you should study topos or whatever.
11:28:30 <Cale> roconnor: Sure, nothing's stopping you from doing that, but first order foundations of categories are arguably even hairier than ZFC.
11:28:57 <sshc> > pi :: Fixed 4
11:28:58 <lambdabot>   Ambiguous occurrence `Fixed'
11:28:59 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
11:29:15 <sshc> I wonder what "..." is
11:29:24 <sshc> > pi :: Data.Fixed.Fixed 4
11:29:26 <lambdabot>   Only unit numeric type pattern is valid
11:29:45 <theorbtwo> @hoogle Fixed
11:29:45 <lambdabot> module Data.Fixed
11:29:45 <lambdabot> Data.Fixed data Fixed a
11:29:45 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
11:29:59 <roconnor> > pi :: Data.Fixed.Fixed E4
11:30:00 <lambdabot>   Not in scope: type constructor or class `E4'
11:30:28 <doserj> Fixed is not Floating
11:33:34 <Cale> roconnor: Oh, and besides, even if you're going to define Set as a particular sort of topos, nothing's stopping choice from working its way back in :)
11:35:16 <sshc> @hoogle CReal
11:35:17 <lambdabot> No results found
11:37:18 <Cale> (just require every epic arrow in the topos to split)
11:38:30 <handonson> is there a patch with which i can use Home, End and Delete button in GHCi for GNU/Linux?
11:38:55 <kmc_> you probably need to configure readline or haskeline (depending on your GHCi version)
11:38:56 <handonson> For now, when I press Home/End/Delete/etc. in GHCi, it produces some weird characters
11:39:11 <medfly> ?
11:39:27 <medfly> isn't that your terminal?
11:39:27 <handonson> is there a GUI version of GHCi?
11:39:28 <Cale> handonson: Which version of GHC are you using?
11:39:32 <kmc_> for the former i think you need to edit ~/.inputrc .  that's not a Haskell or GHC-specific thing
11:39:34 <medfly> my home/end and such keys work
11:39:59 <handonson> err... my Python interactive interpreter works fine, but GHCi has this trouble
11:40:12 <Cale> handonson: ghc --version
11:40:22 <handonson> Cale: 6.10.4
11:40:30 <Cale> okay, on Linux?
11:40:34 <handonson> Yup.
11:40:39 <roconnor> Cale: actually I'm not all that familiar with topos, but I understand there are several different subtle choices for choice functions, rather than an all or nothing choice principle that ZF forces upon you.
11:40:54 <roconnor> s/choice functions/choice principles/
11:41:05 <Cale> handonson: Huh, that's what I'm using, and it just seems to work.
11:41:22 <Cale> handonson: I'm using gnome-terminal.
11:41:29 <roconnor> > pi :: Data.Fixed.Fixed E3
11:41:30 <handonson> Cale, me too!
11:41:30 <lambdabot>   Not in scope: type constructor or class `E3'
11:41:33 <medfly> o.O
11:41:42 <roconnor> > pi :: Data.Fixed.Fixed Data.Fixed.E3
11:41:42 <medfly> handonson, I think you can configure what it outputs
11:41:43 <lambdabot>   Not in scope: type constructor or class `Data.Fixed.E3'
11:42:32 <Cale> Perhaps by configuring haskeline, you can fix things...
11:42:52 <handonson> how can i configure that?
11:43:12 <doserj> > pi :: Data.Fixed.Fixed E6
11:43:13 <lambdabot>   No instance for (GHC.Float.Floating
11:43:14 <lambdabot>                     (Data.Fixed.Fixed D...
11:43:25 <medfly> nvm, you can't configure the home/end stuff
11:43:28 <Cale> handonson: one moment while I find the documentation...
11:43:29 <medfly> so better use another method
11:44:32 <handonson> i use Home/End a lot when I'm talking to an interactive interpreter
11:44:35 <Cale> handonson: run:  ghc -e getLine   and then press Home and then enter, and see if it says "\ESCOH"
11:44:52 <handonson> Cale, it does
11:45:02 <Cale> End should give "\ESCOF"
11:45:46 <handonson> err.. okay..
11:45:53 <handonson> can i fix this?
11:46:06 <Cale> Just looking for what you might do...
11:46:10 <Cale> http://trac.haskell.org/haskeline/wiki/KeyBindings
11:46:16 <Cale> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
11:46:27 <roconnor> doserj: no floating instance! :'(
11:46:35 <doserj> told you
11:49:14 <Cale> bind: home ctrl-a
11:49:14 <Cale> bind: end ctrl-e
11:49:14 <Cale> keyseq: "\ESCOH" home
11:49:14 <Cale> keyseq: "\ESCOF" end
11:49:25 <Cale> maybe try those lines in your ~/.haskeline
11:50:39 <Cale> handonson: any luck with that?
11:52:23 <handonson> Cale, it works like a charm now. thanks a lot.
11:52:56 <Cale> great :)
11:58:40 <handonson> what is the proper value i should give to the sin/cos/tan functions? radian? degree?
11:59:05 <ray> radians
11:59:21 <Lemmih> > sin (pi/2)
11:59:22 <lambdabot>   1.0
12:00:11 <handonson> thanks.
12:00:46 <handonson> Lemmih: are you Lemmih the maintainer of SDL package?
12:01:37 <Lemmih> handonson: Yeah.
12:02:05 <handonson> I really wanted to thank you!
12:02:37 <Lemmih> You're welcome. (:
12:04:34 <fxr> @seen gcollins
12:04:34 <lambdabot> Unknown command, try @list
12:05:03 <handonson> Lemmih: just one question i wanted to ask. is there a way i can get/set a specific pixel of Surface? this is done by pointer+y*width+x in C, get_at/set_at in Pygame, but I couldn't find the ones in Haskell SDL
12:09:14 <Lemmih> handonson: It can be done with the SDL-gfx package. See http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.3/doc/html/Graphics-UI-SDL-Primitives.html
12:09:37 <Lemmih> (It sorely lacks documentation, though)
12:09:49 <ksf> when I'm writing data (:>) a i j b = a :> b  and  instance IxFunctor ((:>) a)  because Functor ((->) a) gets on my nerve, should I ask you whether there's already something usable in category-extras or rather run like hell?
12:09:55 <gwern> pugs has become enormous! my repo is >300MB
12:10:53 <MissPiggy> by the way why does it take four parameters
12:11:02 <ksf> actually, that should be (:>) a a b b
12:11:06 <MissPiggy> what is that??
12:11:09 <ksf> because it's an indexed functor
12:11:14 <ksf> which don't really exist
12:11:14 <MissPiggy> what's IxFunctor
12:11:15 <MissPiggy> :(
12:11:20 <Egbert9e9> yep, you have the whole alphabet
12:11:42 <ksf> but indexed applicatives and monads exist, and it's absolute insanity to use a non-Ix functor as base for those.
12:11:51 <MissPiggy> hmmmmmmmmmmmmmmm
12:11:54 <MissPiggy> okay
12:12:01 <MissPiggy> so it doesn't have any use?
12:12:07 <MissPiggy> it's just there to complete the pattern
12:12:11 <ksf> yep
12:12:12 <handonson> Lemmih, thanks again!
12:12:35 <ksf> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html
12:12:43 <ksf> ...the type of imap says it all.
12:13:13 <ksf> uh. doh. imap, of course, doesn't take my :> a a b b
12:14:22 <ksf> seriously. -> not being a type class is a mistake.
12:15:06 <pikhq> ksf: *cough* Arrow.
12:16:22 <kmc_> err, category
12:18:46 <tavelram> > 1.045^5
12:18:47 <lambdabot>   1.2461819376531245
12:19:40 <ksf> that's it. first you fix me with categories, and before I know it I'm hooked up on zygohistomorphic prepromorphisms
12:23:34 <roconnor> http://www.b-list.org/weblog/2009/jun/26/fun-little-bug/#c118678
12:24:49 <dolio> "A" Yoneda lemma?
12:27:44 <roconnor> dolio: the Yoneda construction defines a lemma that is unique upto isomorphism.
12:28:25 <roconnor> so there is no "the" Yoneda lemma, just many isomorphic lemmas that are all Yoneda
12:28:28 <roconnor> :P
12:30:37 <dolio> So, some guy in the compsci reddit cross posted something he wrote about how finitism solves all completeness/consistency/Goedel issues.
12:30:56 <dolio> But, I was wondering, does it?
12:31:38 <roconnor> dolio: it might.  I've never seen a formal system for finitism, though I'm intrested
12:31:51 <roconnor> @quote universe
12:31:51 <lambdabot> elly says: I leave for five minutes and godel numbering of endofunctors is invokved as a potential proof that the universe is simulated. Thanks, #haskell :P
12:31:56 <roconnor> @quote universe
12:31:56 <lambdabot> dave_m says: < Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so
12:31:56 <lambdabot> long as nobody else has found a larger one yet) < Cale> what about faster ways to produce larger numbers? < Bobstopper> not after the heat death you can't :P < dave_m> don't you tell me what I can't
12:31:56 <lambdabot> do after the heat death of the universe
12:31:57 <dolio> I mean, the argument goes that you can "just check every possibility" for each theorem.
12:32:03 <IceDane> http://www.globalhermit.com/travelogue/boston/guinness-strength.jpg Guiness is good for you. Gives you understanding of monads (true story)
12:32:05 <roconnor> @quote margin
12:32:06 <lambdabot> No quotes match. :(
12:32:16 <roconnor> @quote inconsistency
12:32:17 <lambdabot> No quotes match. It can only be attributed to human error.
12:32:23 <roconnor> aww
12:32:47 <dolio> But how do you know that you *can* check every possibility? Especially if we're postulating that there's some largest natural number.
12:32:50 <roconnor> dolio: what argument goes  you can "just check every possibility" for each theorem.
12:34:25 <MissPiggy> largest natural number? O_o
12:34:55 <dolio> Yeah, maybe the guy was actually talking about ultrafinitism. I'm not exactly clear on the distinction.
12:35:06 <aledge> MissPiggy, scientists believe it to be around 4,000,000,000
12:35:47 <doserj> ultrafinitism means there is a largest natural number. Finitism typically only means that the natural numbers do not form a set
12:35:58 <MissPiggy> ultrafinitism means there is a largest natural number??
12:36:01 <MissPiggy> that's news to me
12:36:55 <roconnor> doserj: oh, I was thinking you meant ultrafinitism
12:37:20 <roconnor> doserj: actually, presumally all these things are a restriction of classical reasoning, meaning you can prove less
12:37:31 <roconnor> so I don't see how proving less helps with godel's argument
12:37:35 <MissPiggy> I have a different understanding of ultrafinitism
12:37:37 <roconnor> @quote ultrafinitism
12:37:37 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
12:37:40 * ksf wants a type level flip
12:38:00 <kmc_> you can write it now
12:38:08 <ksf> I did.
12:38:18 <ksf> but I can't apply it to my data type
12:38:21 <roconnor> MissPiggy: I also don't believe ultrafinitism would imply there is a largest natural number.
12:38:27 <ksf> oh wait
12:38:41 <roconnor> MissPiggy: since I would except ultrafinitism to be compatible with constructive (hence classical) reasoning.
12:38:57 <doserj> MissPiggy: well, you probably cannot proof in ultrafinitism that there is a largest natural number
12:39:19 <MissPiggy> doserj, yes
12:39:20 <b0fh_ua> Hello! Can somebody please explain what does this statement mean: newtype State s a = State { runState :: (s -> (a,s)) } ? I understand it as "State is a high-order type with property runState, which is a function taking type s and returning tuple (a,s)". Am I correct?
12:39:45 * roconnor looks up fintism
12:40:03 <sshc> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11 <- that was quite an interesting read!
12:40:06 <monochrom> Yes.
12:40:11 * roconnor likes Kronecker
12:40:15 <b0fh_ua> or I would say "declares function runState" ?
12:40:17 <MissPiggy> my favorite ultrafinitists are Zeilberger and Edward Nelson
12:40:17 <dolio> Anyhow, it seems to me that an ultrafinitist system (like the guy was proposing) would have difficulty talking about itself enough to show that it you can "just check every possibility" for each theorem. So are you then left with just hand-waving that bit, or proving it in some system that isn't ultrafinitist?
12:40:27 <MissPiggy> I learned everything I know about ultrafinitism from these two
12:40:31 <ksf> well, it works.
12:40:33 <ksf> kinda.
12:40:36 * hackagebot upload: url 2.1.2 - A library for working with URLs. (IavorDiatchki)
12:40:43 <ksf> Illegal type synonym family application in instance
12:40:51 <roconnor> dolio: oh, he is claiming that you wouldn't be able to prove godel's result, rather than being able to refute it.
12:40:59 <mauke> b0fh_ua: I don't understand the "high-order type" part, but the rest looks ok
12:41:16 <koala_man> b0fh_ua: it's record syntax, and it automatically creates a function runState :: State s a -> (s -> (a,s)) to get the runState property from a State
12:41:23 <roconnor> MissPiggy: anyone have a formal system?
12:41:24 <monochrom> #define higher-order type type
12:41:28 <MissPiggy> no
12:41:30 <roconnor> :(
12:41:31 <MissPiggy> it's philosophy
12:41:37 <roconnor> MissPiggy: it makes it hard to argue
12:41:55 <MissPiggy> roconnor oh I don't think so, you just can't use the laser guns (mathematical logic)
12:41:58 <b0fh_ua> mauke: I've read that high-order type is polymorphic type
12:41:58 <roconnor> MissPiggy: constructivism is (apparently) a philosophy and it has a system.
12:42:22 <roconnor> well, it is at least close to having a system. :D
12:42:25 <MissPiggy> roconnor well yes but maybe aliens have a different formal system but they may ALSO do constructive math (and I sure hope so)
12:42:26 <b0fh_ua> koala_man: so whats the difference between data and newtype?
12:42:45 <Ke> I hope you know that C can often be parallelized automatically or with minimal effort
12:42:50 <MissPiggy> so they are linked but they are maybe not soul mates
12:43:00 <roconnor> MissPiggy: but I have no idea what is or is not a valid argument in ultrafinitism
12:43:08 <sbahra> Ke, oh?
12:43:18 <MissPiggy> roconnor, I don't think anyone does -- that's why it's such an interesting topic
12:43:25 <dolio> roconnor: I don't know. Presumably you could (conceivably) show that ultrafinitism is complete and consistent in a framework strong enough to talk about ultrafinitism, but is ultrafinitism strong enough to do that work itself?
12:43:28 <roconnor> that's one way to look at it :D
12:43:30 <MissPiggy> there's no instruction manual :)
12:43:55 <MissPiggy> but edward nelsons arguments about exponentiation not being total are very convincing/confusing
12:43:56 <Ke> sbahra: graphite or openmp
12:44:46 <roconnor> MissPiggy: I haven't read anything by Nelson yet I don't think
12:44:57 <ksf> in the end, every system bogs down to the axiom "if you deny this, you're spoiling all the fun"
12:45:10 <Saizan> b0fh_ua: the difference is that newtype is more restricted, but in return it doesn't add runtime overhead
12:45:21 <Saizan> b0fh_ua: the constructor acts as if it wasn't there
12:45:43 <ziman> b0fh_ua, runtime representation and a little semantics; if beginning, you can ignore the difference. You can look it up later... Furthermore, data can declare more constructors, newtype is more like `type' with a tag.
12:45:52 <ksf> roconnor, constructivism in philosophy means something different than in mathematics
12:45:53 <roconnor> ksf: I'm hoping a logic based on ultrafinitism will prevent stack overflows and other such errors when deductions are interpreted as programs.
12:46:01 <roconnor> ksf: oh
12:46:08 <roconnor> ksf: I didn't know that
12:46:18 <ksf> for the record, i'm a radical constructivist
12:46:24 <roconnor> ksf: that souns very important
12:46:26 <MissPiggy> hehe
12:46:28 <Saizan> b0fh_ua: so it's helpful when you want two types to differ only in the mind of the typechecker
12:46:31 <MissPiggy> what's a radical constructivist?
12:46:32 <MissPiggy> :p
12:46:32 <augur> RADICAL CONSTRUCTIVIST? :|
12:46:51 * MissPiggy is not a linear logician
12:46:54 <ksf> ...which means that I'm dead set on asserting that every percieved thing is a construction
12:46:56 <augur> sir, infinities are REAL
12:47:00 <b0fh_ua> okay, thats fair, thanks
12:47:14 <augur> perceived thing? construction? hows that work.
12:47:18 <MissPiggy> augur, sir, do you not feel that you are building castles in the sky?
12:47:19 <roconnor> ksf: are we talking about philosophy or math here?
12:47:30 <monochrom> I am talking about haskell here.
12:47:42 <dolio> roconnor: And if it can't do that work itself, why am I just accepting some other framework to be correct enough to show that ultrafinitism is right since the point of throwing out the other systems was "they're all bad because of these big numbers"?
12:48:05 <augur> MissPiggy: certainly not!
12:48:30 <ksf> roconnor, http://en.wikipedia.org/wiki/Constructivist_epistemology
12:48:36 <roconnor> http://en.wikipedia.org/wiki/Constructivist_epistemology  <-- is this philosophical constructivism?
12:48:36 <ziman> a radical constructivist, constructing water from H+ and OH- :)
12:48:38 <roconnor> ah
12:48:40 <roconnor> :D
12:48:56 <ksf> "That is, the process of constructing knowledge regulates itself, and since knowledge is a construct rather than a compilation of empirical data, it is impossible to know the extent to which knowledge reflects an ontological reality. "
12:49:04 <augur> ziman, can we do it the cool way, with giant rockets?
12:49:06 <monochrom> @faq can haskell build http://www.amazon.com/dp/B00005JKYG/ ?
12:49:06 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:41 <ksf> ...which of course means that radical constructivism says that it can't claim that it's true.
12:49:58 <augur> ksf: i disagree with that last part. i definitely agree that knowledge is a construct, but I believe that popper and others (deutsch, for instance) have argued quite clearly that we can distinguish when some things are more objectively true
12:50:14 <augur> unless we decided to lapse into disbelieving our own senses.
12:50:20 <ksf> having an ordering doesn't mean that you can touch the bounds.
12:50:40 <augur> true enough.
12:51:00 <augur> but reflecting objective reality doesn't require that we touch it.
12:51:05 * roconnor is reminded of his problems with large countable ordinals and consistency strength.
12:51:14 <ksf> but then you're reflecting constructs
12:51:21 <ksf> ...you're always reflecting constructs
12:51:37 <dolio> roconnor: Yes, exactly like that.
12:51:38 <augur> no, you're not
12:51:50 <dankna> Knowledge is contextual; the context in which it holds true is part of the thing that you know.  Thus knowledge if valid *always* reflects an ontological reality.
12:52:04 <augur> not being exactly like the objective world is not the same as not reflecting it
12:52:12 <ksf> these may or may not be isomorphic to reality, which decides whether or not you're nuts or daydreaming.
12:52:15 <augur> it just means you're not exactly like it, only partially
12:52:28 <augur> isomorphism isnt the point here
12:52:37 <augur> you can be non-isomorphic but be closer to isomorphism that something else
12:52:57 <ksf> your knowledge is a map of reality, if both are isomorphic, you can safely ignore the difference.
12:53:04 <MissPiggy> "How to escape the clutches of Godelian incompleteness and be a consistent and complete" -- oh great and next up how to make -1*-1 = -1?
12:53:09 <ksf> point is, you can't tell whether they are truly iso or not
12:53:15 <augur> the set Z\{0} is closer to isomorphism to Z than the set {0} is
12:53:17 <augur> but neither is Z.
12:53:17 <roconnor> dolio: I find it confusing and disquieting
12:53:33 <roconnor> MissPiggy: link?
12:53:35 <ksf> ...which satisfies the approach metholodically as an extremely useful working hypothesis.
12:53:40 <augur> well no, you can never know if its truly isomorphic, but so what?
12:53:47 <augur> so you dont have infinite knowledge, big deal.
12:53:51 <MissPiggy> http://www.reddit.com/r/PhilosophyofScience/comments/azoww/how_to_escape_the_clutches_of_godelian/
12:54:05 * mauke ponders whether -1*-1 = -1 means all numbers are 1
12:54:06 <augur> science isnt about infinite knowledge, its about good knowledge.
12:54:20 <monochrom> I hate reddit. Every little rambling on reddit becomes an extended session of off-topic-ness here. I want pure haskell here, or failing that, absence of traffic. None of the "no haskell talk => let's off-topic" bullshit.
12:55:00 <ksf> so it's about maximizing local isomorphisms. or those that one can exploit best atm
12:55:10 <augur> mauke, since -1*-1 /= 1, you would have to define your system to make sense of that. and in such a system you wouldnt be likely to ACTUALLY have numbers
12:55:33 <mauke> augur: how do you know -1*-1 /= 1?
12:55:35 <augur> ksf, its about maximizing global isomorphism, by way of better explanations.
12:55:56 <augur> mauke: because it equals 1 by definition. :P
12:56:03 <mauke> huh?
12:56:06 <ksf> global?
12:56:13 <ksf> ask maxwell about that
12:56:41 <augur> ksf, as far as our knowledge is concerned, anyway. we dont just want to make this one little area of our knowledge better while screwing up the rest
12:56:45 <MissPiggy> monochrom I don't think reddit has anything to do with what people are talking about here
12:56:59 <roconnor> MissPiggy: I probably shouldn't bother reading the comments should I?
12:57:06 <ksf> it bitrots all by itself
12:57:11 <monochrom> <dolio> So, some guy in the compsci reddit cross posted something he wrote about how finitism solves all completeness/consistency/Goedel issues.
12:57:13 <MissPiggy> roconnor I haven't even read this I just thought the title was ridiculous
12:57:28 <augur> mauke: math is a formal system (unless you're one of the other philosophers-of-math people who disagrees), thus -1 is what it is defined to be.
12:57:30 <dolio> roconnor: You should read mine on self-verifying theories. It's only 1 line, though.
12:57:32 <MissPiggy> oh turns out I linked to the exact thing dolio was talking about :D
12:57:35 <MissPiggy> by coincidence
12:57:39 <roconnor> dolio: ya, I read it :)
12:57:45 <FliPPeh> :t newIORef
12:57:46 <lambdabot> Not in scope: `newIORef'
12:57:50 <mauke> augur: so?
12:58:10 <FliPPeh> @hoogle newIORef
12:58:10 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
12:58:18 <FliPPeh> :t IORef
12:58:19 <lambdabot> Not in scope: data constructor `IORef'
12:58:21 <heatsink> I don't understand why GHC gives me an error for [| data Foo a = ... deriving(Typeable1) |], but accepts a standalone [| deriving instance Typeable1 Foo |]  for the same data declaration.  Shouldn't those mean the same thing?
12:58:24 <FliPPeh> @hoogle IORef
12:58:25 <lambdabot> module Data.IORef
12:58:25 <lambdabot> Data.IORef data IORef a
12:58:25 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:58:26 <ksf> -1 isn't Int -> Int -> Int, it's Int -> Bool.
12:58:32 <FliPPeh> Bah
12:58:34 <FliPPeh> What's IORef?
12:58:50 <augur> mauke, so it means that -1*-1 in normal math necessarily equals 1 because it is _defined_ to be 1.
12:58:50 <dolio> heatsink: What about [d| data Foo ... |]
12:59:01 <monochrom> I no longer mind that you people are memoryless single-cellular bacteria having no scroll buffer and behaving context-free. But do not assume that I am like you.
12:59:01 <ksf> FliPPeh, references in the IO monad
12:59:04 <mauke> augur: I don't think it's defined to be 1
12:59:05 <heatsink> FliPPeh: a mutable reference to an object.  You can read the value in it, and write a new value into it.
12:59:05 <mightybyte> Does parsec have a function to "unconsume" part of the input?
12:59:14 <ksf> you make one, then put stuff in it and get stuff out of it and such.
12:59:17 <FliPPeh> Thanks ksf and heatsink :)
12:59:23 <kmc_> it's not a mutable reference
12:59:28 <kmc_> it's an immutable reference to a mutable cell
12:59:29 <MissPiggy> that's not very nice monocrhom
12:59:31 <ksf> also have a look at STRef, MVar and TVar
12:59:36 <heatsink> dolio: The [| |] are just quotes, I'm not using TH.
12:59:39 <augur> well, multiplication over negatives is defined in such and such a way that -1*-1 is 1, let me put it that way.
12:59:44 <dolio> Oh.
12:59:46 <reitblatt> mightybyte: you can use try for arbitrary look ahead, but I don't think you can "roll back"
12:59:47 <MissPiggy> and I don't know why are you picking on me about it
12:59:56 <augur> you can go around and find formal definitions and so for if you like.
13:00:11 <mightybyte> reitblatt: Yeah, I know about lookahead, but I was looking for a way to go back.
13:00:24 <dolio> heatsink: Do you have the standalone deriving extension enabled (whatever it's called)?
13:00:29 <monochrom> I didn't pick on you. I won't pick on you.
13:00:30 <ksf> try _is_ backtracking
13:00:31 <mightybyte> ...something like the inverse of try.
13:00:31 <mauke> augur: I turn -1*-1* = -1 into -1 = -1/-1 = 1, thereby proving that 1 = -1
13:00:55 <mightybyte> ...backtrack when you DO match, instead of when you fail to match.
13:00:55 <dolio> -XStandaloneDeriving
13:00:56 <reitblatt> mightybyte: what do you want it for, and why doesn't "try" work?
13:01:04 <augur> in the formal system you have just created, sure. your system is not the normal set of numbers, but thats ok.
13:01:11 <reitblatt> mightybyte: notFollowedBy?
13:01:15 <heatsink> dolio: Yes.  Standalone deriving works; an attached deriving clause produces an error.
13:01:18 <mightybyte> reitblatt: Hang on for a paste
13:01:26 <augur> im sure that mathematicians have already investigated the object you just defined, mauke.
13:02:15 <dolio> Oh, geeze. I read that backwards. the error is on the first one.
13:02:18 <ksf> mightybyte, try (lookaheadParser <* fail) <|> continuationParser
13:02:37 <heatsink> Oh, I get it now.
13:02:49 <mauke> augur: yeah, I think it's either {0, 1} or {0}
13:02:50 <heatsink> I'm supposed to say deriving(Typeable), and GHC will actually derive Typeable1
13:03:04 <heatsink> but if I say deriving(Typeable1), I get an error.
13:03:13 <MissPiggy> II don't know whta the big deal is anyway
13:03:16 <dolio> Yeah, that makes some sense.
13:03:30 <mightybyte> reitblatt: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=18971#a18971
13:03:33 <MissPiggy> I hadn't read that, it waasn't that I forgot it
13:03:39 <mightybyte> reitblatt: That doesn't do what I expect.
13:03:51 <MissPiggy> but it's just absurd to call people single celled
13:03:54 <heatsink> Well, that's not what I expected, but I can work with that.
13:04:06 <MissPiggy> the only way that can be interpreted is an insult
13:04:14 <mightybyte> reitblatt: I've tried putting "try" in every place I can think of, to no avail.
13:04:24 <augur> mauke: i have no idea. having -1 i think complicates things because youve got some notion of negativity. but i think that there are infinitely many ways of having a formal system in which -1*-1 = -1 holds, given arbitrarily complex definitions of *
13:04:55 <mauke> -1 is the number that gives 0 when added to 1
13:05:20 <augur> for instance, here's one: the object (Z, *) where * is defined thusly: a * b = -1 if a and b == -1, otherwise the result of normal multiplication
13:05:24 <Zao> mauke: cosucc? :)
13:05:35 <Zao> Well, co-one :)
13:05:48 <augur> its probably not a group, mauke, but its definitely an object with -1 * -1 = -1
13:05:56 <mauke> it's also useless
13:06:00 <augur> true!
13:06:10 <mauke> you're treating * as a random identifier, not as multiplication
13:06:17 <augur> but it fits the definition.
13:06:23 <MissPiggy> well I guess you have run out of insulting things to say
13:06:37 <reitblatt> mightybyte: you want to parse anyChar* until you see a (odd number of) "-=-"?
13:08:17 <mightybyte> reitblatt: It's a simple CSV-like format, except that my separator is the string "-=-" and prefixes of the separator are valid in the things being separated.
13:09:01 <MissPiggy> yes I don't feel that remark had any value or positive effect
13:09:01 <reitblatt> mightybyte: I'm confused as to why you have the "sep `sepBy` sep" in there
13:09:15 <reitblatt> mightybyte: why not just (try sep)?
13:09:33 <FliPPeh> Okay, they've done it
13:09:40 <FliPPeh> I'm writing my OWN MPD library
13:09:46 <FliPPeh> As the existing one is broken
13:09:59 <FliPPeh> A Haskell rookie ist tampering with monads, this will be fun
13:10:00 <mightybyte> reitblatt: function application has higher precedence than `sepBy`
13:10:09 <mightybyte> record = manyTill anyChar sep `sepBy` sep
13:10:13 <mightybyte> is the same as...
13:10:23 <reitblatt> ahh, I was assuming that you made a typo there
13:10:24 <mightybyte> record = (manyTill anyChar sep) `sepBy` sep
13:11:18 <mightybyte> Aha, lookAhead does what I want.
13:11:33 <kmc_> Eh, monads are not that special.  Don't believe the hype.
13:11:43 <handonson> Lemmih, Graphics.UI.SDL.Primitives seems to be capable of only writing. How can I read a pixel from a Surface?
13:11:58 <FliPPeh> kmc_: I know, but for a "beginner" like me, they are
13:12:02 <FliPPeh> I know how they work in theory
13:12:05 <FliPPeh> Easy, yep
13:12:10 <FliPPeh> But I have to learn to apply it!
13:12:43 <kmc_> i think the goals of "learn what monads are in the abstract" and "get shit done in IO" are fairly orthogonal
13:12:56 <mightybyte> record = (manyTill anyChar (lookAhead sep <|> (eof >> return [])) `sepBy` sep
13:13:01 <FliPPeh> IO is too easy
13:13:02 <medfly> if you want to get shit done don't use Haskell, right?
13:13:05 <kmc_> as long as you stick to one monad, you don't need to know that they have this common structure
13:13:06 <mightybyte> reitblatt: That seems to work.
13:13:17 <FliPPeh> I'm writing my own monad
13:13:22 <kmc_> ah, that's fun then :)
13:13:23 <medfly> FliPPeh, of course. everything is. why does this channel even exist? we should all discuss other things
13:13:40 <FliPPeh> Holding some read only state, but I don't want to use Control.Monad.Reader
13:13:44 <FliPPeh> I need to learn ;D
13:14:25 <reitblatt> mightybyte: cool
13:14:35 <mauke> FliPPeh: Reader is just functions
13:14:42 <roconnor> FliPPeh: I prefer to view a reader monad as an applicative functor
13:14:52 <medfly> what does writing your own monad mean? taking a functor and making something it work with join and return?
13:14:54 <reitblatt> mightybyte: didn't know about lookAhead, it wasn't in the old parsec doc I have
13:15:14 <roconnor> FliPPeh: the monad operation don't add anything in this case.
13:15:24 <roconnor> :)
13:15:52 <FliPPeh> Well, they add to my brain I hope - so far I never really had anything to do with monads, besides StateT and IO
13:15:55 <FliPPeh> :)
13:16:35 <MissPiggy> #haskell can be pretty mean sometimes
13:16:42 <medfly> MissPiggy, yeah well fuck you
13:16:47 <MissPiggy> haha
13:16:55 <ElfArmy> It's the internet, what do you expect.
13:16:59 <FliPPeh> "return a = MPD (\_ -> return (Right a))"
13:17:08 <FliPPeh> Wouldn't this equal to "MPD (MPD (Right a))" ?
13:17:10 <MissPiggy> medfly cheered me up anyway
13:17:15 <medfly> :-)
13:17:17 <FliPPeh> Or what about that return in the return?
13:18:29 <mauke> FliPPeh: it's probably a different return
13:21:09 <FliPPeh> :t either
13:21:10 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:21:17 <FliPPeh> @src either
13:21:18 <lambdabot> either f _ (Left x)     =  f x
13:21:18 <lambdabot> either _ g (Right y)    =  g y
13:21:54 <heatsink> FliPPeh: yo dawg I heard you like monads, so we put a return in your return, so you can compute while you compute
13:22:04 <FliPPeh> Oh god no
13:22:06 * FliPPeh hides
13:22:17 <mauke> fmap fmap fmap
13:24:19 <lispy> ?type either either either
13:24:20 <lambdabot> forall b a c. Either (a -> c) (a -> c) -> (b -> c) -> Either a b -> c
13:25:37 <heatsink> FliPPeh: It's a monad extended with additional functionality.  The extended monad's return uses the base monad's return.
13:25:43 <MadHatterDude> Hey guys!
13:25:53 <FliPPeh> > let s = Left "lost" in either (\x -> "You " ++ x ++ " the game") (\e -> "What?") s
13:25:54 <lambdabot>   "You lost the game"
13:26:03 <FliPPeh> > let s = Right "Eh?" in either (\x -> "You " ++ x ++ " the game") (\e -> "What?") s
13:26:04 <lambdabot>   "What?"
13:26:06 <FliPPeh> Okay I got it
13:26:34 <MadHatterDude> I got a type error i hope somebody could help with.
13:26:45 <lispy> MadHatterDude: sure
13:26:47 <kmc_> MadHatterDude: sure, upload your code and error to hpaste
13:26:49 <kmc_> @where paste
13:26:49 <lambdabot> http://hpaste.org/new
13:28:18 <MadHatterDude> no, wait, nvm.
13:28:24 <aavogt> :(
13:28:57 <ElfArmy> How anti-climatic.
13:29:14 <lispy> I had a type error, but I eated it
13:29:22 <lispy> nom nom nom
13:32:48 <MadHatterDude> Is there a function to iterate through a list of elements using a comparing function with an argument and pick out the first list element that compares true to the argument?
13:33:02 <FliPPeh> head $ filter ?
13:33:12 <kmc_> > head $ dropWhile (/= 5) [1..]
13:33:13 <lambdabot>   5
13:33:20 <FliPPeh> > head . filter (/= "Hello") ["Hello", "World"]
13:33:20 <lambdabot>   "W"
13:33:25 <mauke> :t find
13:33:25 <MadHatterDude> FliPPeh, kmc: thx
13:33:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:33:27 <FliPPeh> Whoops.
13:33:32 <kmc_> this will throw an exception if no value matches of course
13:33:37 <FliPPeh> Yep
13:33:43 <FliPPeh> Better get a safeHead function
13:33:51 <kmc_> it's called listToMaybe
13:33:53 <mauke> > find even [1, 3, 5, 2, 5]
13:33:54 <lambdabot>   Just 2
13:33:58 <mauke> IT'S CALLED FIND
13:34:00 <kmc_> :t find
13:34:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:34:03 <kmc_> is that standard?
13:34:07 <monochrom> Won't throw an exception if the list is infinite.
13:34:11 <mauke> kmc_: GUESS WHAT I JUST DID TWO LINES ABOVE
13:34:17 <Kostafey> Is there some docs for using different encodings in haskell?
13:34:21 <MadHatterDude> What module is find in? List?
13:34:23 <FliPPeh> > let safeHead a = if null a then Nothing else Just a in safeHead "Hi"
13:34:23 <kmc_> jesus it's angry time
13:34:24 <lambdabot>   Just "Hi"
13:34:27 <FliPPeh> > let safeHead a = if null a then Nothing else Just a in safeHead []
13:34:28 <lambdabot>   Nothing
13:34:30 <mauke> @index find
13:34:31 <lambdabot> Data.List
13:34:39 <MadHatterDude> mauke: Take your voice down, I hear you allright!
13:34:44 <kmc_> > listToMaybe "Hi"
13:34:45 <lambdabot>   Just 'H'
13:34:46 <kmc_> > listToMaybe ""
13:34:47 <FliPPeh> > let safeHead a = if null a then Nothing else Just $ head a in safeHead []
13:34:47 <lambdabot>   Nothing
13:34:47 <lambdabot>   Nothing
13:34:52 <FliPPeh> > let safeHead a = if null a then Nothing else Just $ head a in safeHead [1,4,5]
13:34:53 <lambdabot>   Just 1
13:35:16 <dschoepe> > let safeHead = listToMaybe in safeHead []
13:35:17 <lambdabot>   Nothing
13:35:32 <FliPPeh> > listToMaybe "..."
13:35:33 <lambdabot>   Just '.'
13:35:38 <FliPPeh> :t listToMaybe
13:35:39 <lambdabot> forall a. [a] -> Maybe a
13:35:44 <FliPPeh> :/
13:35:51 <FliPPeh> @src listToMaybe
13:35:51 <lambdabot> listToMaybe []        =  Nothing
13:35:51 <lambdabot> listToMaybe (a:_)     =  Just a
13:36:00 <FliPPeh> heh!
13:36:30 <heatsink> Kostafey: Strings are stored in Unicode.  There are codec libraries for converting to and from Unicode.
13:36:38 <aavogt> @type getFirst . Data.Foldable.foldMap (First . Just) mempty
13:36:39 <lambdabot>     No instance for (Functor First)
13:36:39 <lambdabot>       arising from a use of `.' at <interactive>:1:0-53
13:36:39 <lambdabot>     Possible fix: add an instance declaration for (Functor First)
13:36:52 <heatsink> Kostafey: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:codec
13:37:10 <aavogt> @type getFirst . Data.Foldable.foldMap (First . Just)
13:37:11 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Maybe a
13:37:46 <aavogt> @let toMaybe = getFirst . Data.Foldable.foldMap (First . Just)
13:37:47 <lambdabot>  Defined.
13:37:56 <aavogt> > toMaybe $ Just 1
13:37:57 <lambdabot>   Just 1
13:38:04 <aavogt> > toMaybe "hai"
13:38:05 <lambdabot>   Just 'h'
13:38:18 <Kostafey> heatsink: Thank you
13:39:11 <MadHatterDude> @hoogle listToMaybe
13:39:11 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
13:39:19 <aavogt> @type Data.Foldable.foldr (:) []
13:39:20 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> [a]
13:39:30 <aavogt> @type toList
13:39:31 <lambdabot> Not in scope: `toList'
13:39:35 <heatsink> GHC appears to print in UTF-8, which means you'll need to encode a Unicode string as UTF-8 to display it.  I don't know if that's system-dependent or what.
13:39:37 <aavogt> @type Data.Foldable.toList
13:39:38 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
13:42:45 <FliPPeh> :t open
13:42:46 <lambdabot> Not in scope: `open'
13:42:53 <FliPPeh> :t openFile
13:42:54 <lambdabot> Not in scope: `openFile'
13:43:00 <FliPPeh> :t fileOpen
13:43:01 <lambdabot> Not in scope: `fileOpen'
13:43:07 <FliPPeh> Don't upset me
13:43:19 <Dashkal> In the module declaration, one can export a Data type and all related constructors/extractors with SomeTime (..)  Is there a way to export just the extractors short of listing each one individually?
13:43:39 <aavogt> :t System.IO.open
13:43:40 <lambdabot> Not in scope: `System.IO.open'
13:43:55 <mauke> why so fail?
13:43:57 <heatsink> @type System.IO.readFile
13:43:58 <lambdabot> FilePath -> IO String
13:44:23 <FliPPeh> :t Sytem.IO.fileOpen
13:44:24 <lambdabot> Couldn't find qualified module.
13:44:28 <FliPPeh> :t System.IO.fileOpen
13:44:29 <lambdabot> Not in scope: `System.IO.fileOpen'
13:44:34 <MadHatterDude> is there a withoutPrefix function?
13:44:46 <aavogt> there's a not function
13:44:47 <FliPPeh> :t System.IO.openFile
13:44:48 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
13:51:02 <yokto> is there a reason that label-names (eg. data Test = T { name :: ...}) are in the top level namespace and can there for can be used in only one type?
13:51:27 <FliPPeh> Anyone using Vim for Haskell?
13:51:34 <dolio> Records are just sugar on top of ordinary algebraic datatypes.
13:51:35 <jmcarthur> yokto: it's because they form functions
13:51:48 <jmcarthur> name :: Test -> ...
13:51:52 <FliPPeh> And does that one know how to automatically highlight words that start with a capital?
13:51:57 <FliPPeh> I want to highlight types!
13:52:25 <yokto> ok i didn't think of that thx
13:53:31 <kmc_> however yokto see http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
13:54:34 * MadHatterDude is away: autoaway [l(on) p(on)]
13:55:14 <FliPPeh> @hpaste
13:55:14 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:57:44 <aavogt> FliPPeh: constructors are also capitalized...
13:58:07 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6900#a6900
13:58:13 <FliPPeh> aavogt: I know
13:58:20 <aavogt> I suppose you could get fancy and look for a  ::  to the left...
13:58:34 <FliPPeh> URL: Could someone give me a hint how to actually run my runMPD now? I'd need it to read stuff
13:58:37 <FliPPeh> ... or wait
13:58:43 <FliPPeh> I might just be stupid right now
13:58:54 <aavogt> apply your runMPD function
14:00:28 <FliPPeh> Yes yes
14:00:33 <FliPPeh> But I'm struggling HOW
14:00:46 <FliPPeh> Basically, I'm rewriting the old MPD library because it doesn't work anymore
14:00:58 <FliPPeh> I grepped all those files for runMPD, but I don't see it getting applied
14:01:03 <roconnor> what is MPD?
14:01:10 <FliPPeh> Music Player Daemon
14:01:12 <MissPiggy> multiple parameter disorder
14:01:15 <roconnor> heh
14:01:26 <FliPPeh> A daemon that plays music and can be controlled over network
14:01:28 <roconnor> I swore it was something about probability distributions
14:01:38 <roconnor> I was a little off base
14:03:33 <yokto> kms: thx
14:03:40 <Adamant> roconnor: we're going to need a explicit namespace for acronyms sooner or later
14:03:54 <gwern> I'm more than a little impressed at how much better than gzip 7zip compresses
14:04:16 <gwern> (at least 50% on quasi-text)
14:04:28 <Adamant> especially in technical fields that overlap and share acronyms, you spend more time trying to figure out what acronym the person is using that it would take for them to type it all out.
14:04:46 <Adamant> *than it
14:05:10 <Adamant> gwern: what are the numbers on it vs. the bzip family?
14:05:23 <gwern> Adamant: bzip isn't that great
14:05:29 <gwern> 7z is still better
14:05:44 <Adamant> I thought bzip was a significant improvement over gzip
14:05:52 <gwern> I saved ~200mb offf 800mb gzipped by using 7z; (this was a tar of my mail archives)
14:05:58 <Adamant> but I definitely don't spend a lot of time benchmarking this stuff.
14:06:14 <gwern> Adamant: it's an improvement but not much of one. that's why it isn't used too often
14:06:28 <sshc> how do I configure ghci to record its history?
14:08:00 <IceDane> http://www.haskell.org/all_about_monads/html/exercises.html Could someone give me any hints on how I would solve the last exercise? I'm a bit lost..
14:08:14 <IceDane> Not sure what I have to do to make it general/polymorphic
14:08:58 <IceDane> Oh, never mind, there's the "See the solution" link. Didn't notice it
14:10:30 <b0fh_ua> Hello there! I am trying to learn State monad. I've created sample application which parses XML into custom objects using TagSoup. The app code is located at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18983#a18983. The question is - how do I use evalState with buildIssue, and is it possible to get the state within evalState computation and terminate execution once CurrentState contains empty list as 'tags' property?
14:11:05 <b0fh_ua> or I am totally wrong with the way of implementing such parsing with State as I did
14:14:58 <Athas> Does anyone know of a Haskell library for generating/creating LaTeX?
14:15:13 <Athas> Embedding string fragments in my program seems wrong.
14:15:37 <MissPiggy> Athas, I looked around and that's what everyone's doing -- I'm not keen on it either and I need to generate some LaTeX soon
14:15:46 <Botje> b0fh_ua: evalState buildIssue $ CurrentState tags [] Nothing
14:16:40 <Botje> issues newState looks suspect, though.
14:16:51 <kmc_> there are prettyprinting combinator libraries at least
14:17:01 <kmc_> you will still embed strings but gluing them together looks nicer, and so will the output
14:17:03 <Botje> b0fh_ua: i think the last line of buildIssue should be a call to buildIssue
14:17:15 <funde> I just read "Worse is Better" by RGabriel. Wouldn't it be clearer is the essay was titled: "Release Early, Release Often"? It seems less misleading than the original title.
14:17:47 <pantsman> I think that's just meant to grab your attention using an obvious contradiction
14:18:13 <Botje> b0fh_ua: buildIssue = do (...) <- get; if null cTags then return cIssues else case cTags of ...
14:18:13 <funde> I see. Makes sense. Thanks.
14:18:56 <b0fh_ua> Botje: 1 sec
14:19:14 <pantsman> the thing with "release early, release often" is you can explain it ad infinitum to your boss and he/she will still nod and pretend to understand and say "right, well I just need this one extra feature in before the next release"
14:19:21 <FliPPeh> I am really impressed. I have NO IDEA what the hell I am doing, but it just works. When it compiles, it just works.
14:19:30 <FliPPeh> New haskell slogan.
14:19:31 <FliPPeh> It just works.
14:19:39 <IceDane> FliPPeh: If it compiles, chances are it works
14:19:40 <kmc_> well, once you make the compiler happy
14:19:41 * MissPiggy has found this haskell slogan not to hold for me
14:19:49 * MissPiggy finds if it compiles it probably doesn't work
14:20:00 <aavogt> depends what your types are
14:20:08 <Botje> MissPiggy: that's why we're making new GHC's stricter :)
14:20:10 <tromp> we cannot yet say: it just compiles
14:20:17 <FliPPeh> Can someone explain this "readLines = MPD f
14:20:21 <FliPPeh> to me?
14:20:28 <FliPPeh> Basically
14:20:30 <kmc_> right, it's a good thing that the compiler is picky
14:20:35 <FliPPeh> f gets passed another parameter
14:20:37 <Twey> MissPiggy: That's because you're doing crazy things with types
14:20:39 <Botje> FliPPeh: what are the types of MPD and f?
14:20:39 <FliPPeh> From the MPD constructor
14:20:41 <FliPPeh> But why?
14:20:42 <MissPiggy> no im  not
14:20:46 <tensorpudding> @hoogle MPD
14:20:47 <lambdabot> Language.Haskell.TH forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
14:20:47 <lambdabot> Language.Haskell.TH.Lib forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
14:20:47 <Twey> Heh
14:20:50 <IceDane> I may not have found a new haskell slogan, but I revised guinness' old slogan "Guinness is good for you. Gives you strength" to "Guinness is good for you. Gives you understanding of monads", after drinking a few pints of guinness, and then attempt to understand monads.. It worked.
14:20:52 <tensorpudding> hmm
14:20:55 <aavogt> why not?
14:20:58 <FliPPeh>  data MPD a = MPD { runMPD :: MPDConn -> IO (Response a) }
14:20:59 <FliPPeh> where f c = return (Left "Hi")
14:21:05 <FliPPeh> Botje:
14:21:05 <MissPiggy> the last thing what went wrong was + binding tighter than *
14:21:07 <b0fh_ua> Botje: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18985#a18985
14:21:08 <Twey> IceDane: Hahaha
14:21:18 <Botje> FliPPeh: can you make a paste on hpaste? it's easier to read and follow IRC along.
14:21:21 <FliPPeh> f will get the "MPDConn" part
14:21:26 <FliPPeh> Alright, hold on
14:21:28 <FliPPeh> @hpaste
14:21:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:21:29 <b0fh_ua> this one seems to compile, but resulting list of issues is empty
14:21:38 <b0fh_ua> probably I missed something there
14:21:38 <IceDane> Twey: I'm not even kidding. My mates wanted to visit a pub after school. I tagged along
14:21:51 <kuribas> Is there a standard function to strip spaces from a string?
14:21:52 <tensorpudding> @type readLines
14:21:53 <lambdabot> Not in scope: `readLines'
14:21:57 <MissPiggy> lol IceDane
14:22:05 <FliPPeh> Botje:
14:22:08 <IceDane> Now to educate the general public of the esoteric nature of monads so that they understand that understanding them is no simple feat, so they want to buy guinness because it makes such feats possible.
14:22:16 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6904#a6904
14:22:18 <Botje> b0fh_ua: that only runs through buildIssue once. is that what you wanted?
14:22:30 <b0fh_ua> Botje: nope..
14:22:49 <Botje> b0fh_ua: if you want more runs, you have to call buildIssue somewhere in buildIssue.
14:22:50 <Twey> IceDane: I wonder if I could get a grant for Guinness from my government as an educational aid.
14:23:08 <IceDane> Hahaha.. I just remembered.. kmc once recommended heavy drinking to me to get out of the imperative mindset. Hahaha, it actually worked!
14:23:09 <Botje> FliPPeh: aha. have you checked the type of MPD ?
14:23:10 <b0fh_ua> really
14:23:19 <FliPPeh> Yep
14:23:26 <FliPPeh> A function :/
14:23:39 <tensorpudding> MPD is a data constructor isn't it?
14:23:39 <FliPPeh> record with a function*
14:23:42 <IceDane> Twey: That would certainly be the most awesome educational aid, ever.
14:23:44 <Botje> FliPPeh: that's not the type
14:23:44 <FliPPeh> Indeed
14:23:46 <FliPPeh> Oh damn
14:23:48 <IceDane> Anywho, I'm going to bed. Have a good one
14:23:51 <FliPPeh> It's a constructor
14:23:52 <FliPPeh> Stupid me
14:23:58 <FliPPeh> That explains all
14:24:00 <b0fh_ua> Botje: nice
14:24:04 <Botje> the type of MPD is (MPDConn -> IO (Response a)) -> MPD a
14:24:12 <tensorpudding> MPD :: (MPDConn -> IO (Response a)) -> MPD a
14:24:30 <Botje> f expects an MPDConn and generates an IO action (which is probably executed somewhere)
14:24:53 <MadHatterDude> Yes! Infix to RPN parser!
14:24:58 <tensorpudding> MPD is a record keeping track of how to generate an IO response from an MPDConn
14:25:12 <tensorpudding> is a way that you can think about it
14:25:12 <FliPPeh> Okay, now what's confusing me about this
14:25:20 <FliPPeh> How does f get the "MPDConn" part?
14:25:30 <FliPPeh> Some magic happening?
14:25:35 <tensorpudding> just like how State is a functio that when evaluated on a state, returns a (state, return) pair
14:26:12 <tensorpudding> presumably f knows the constructor for MPDConn types, and generates an appropriate one
14:26:48 <kuribas> > let stripspaces = reverse . dropWhile isSpace . reverse . dropWhile isSpace in "  Strip that! "
14:26:49 <lambdabot>   "  Strip that! "
14:26:52 <tensorpudding> then MPD says "given this MPDConn, here's an IO action that does a response"
14:27:03 <FliPPeh> "readLines = MPD (\c -> return (Right "Hi"))" would be equal to that previous line?
14:27:07 <Zao> kuribas: Actually applying the function is for the weak.
14:27:24 <tensorpudding> FliPPeh: Response = Either?
14:27:27 <Botje> b0fh_ua: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18985#a18987 # untested, but might be what you want
14:27:27 <FliPPeh> Yep
14:27:31 <FliPPeh> Either String a
14:27:38 <tensorpudding> well, it would be
14:27:46 <b0fh_ua> Botje: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18988#a18988
14:27:49 <b0fh_ua> that's it
14:27:53 <tensorpudding> but essentially that is the "ignore the MPDConn, return "Hi" response"
14:28:03 <FliPPeh> Alright
14:28:46 <tensorpudding> but presumably, the IO (Response a) part will be doing some real IO
14:28:56 <b0fh_ua> Botje: your solutions seems to be cleaner
14:29:16 <kuribas> > isSpace ' '
14:29:17 <lambdabot>   True
14:29:40 <Botje> b0fh_ua: yours is pretty good as well
14:30:24 <kuribas> Zao: haha, I forgot it :)
14:31:19 <Axman6> > map isSpace " \t\n"
14:31:21 <lambdabot>   [True,True,True]
14:31:33 <tensorpudding> ohnoes
14:31:41 <Axman6> > filter isSpace ['\0'..]
14:31:41 <tensorpudding> \n is a space
14:31:42 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
14:32:32 <Axman6> > text $ filter isSpace ['\0'..]
14:32:33 <lambdabot>   Â áš€á Žâ€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€
14:32:35 <Axman6> >_>
14:33:54 <b0fh_ua> Botje: I have to think more about it
14:34:06 <heatsink> Axman6: I SEE NOTHING
14:34:07 <b0fh_ua> this is my first attempt to write down something using monads
14:34:41 <Botje> i was just going to suggest adding a writerT *evil grin*
14:36:52 <SubStack> I should write a y-combinator using textures for glsl
14:37:10 * hackagebot upload: hlibev 0.2.1 - FFI interface to libev (AycanIrican)
14:37:17 <SubStack> since most graphics cards suck and don't support recursion
14:37:42 <SubStack> could probably do this with quasiquotes somehow in my glut simulations typeclass
14:37:56 * SubStack thinks out loud
14:38:18 <MissPiggy> SubStack, is it a joke :(
14:38:41 <SubStack> a joke?
14:38:43 <SubStack> negatory
14:38:58 <SubStack> http://github.com/substack/haskell-opengl-simulations/
14:40:07 <Botje> b0fh_ua: one thing you could try is to make tags a parameter of buildIssues
14:40:20 <Botje> because it changes every time anyway
14:40:33 <Botje> but you can do that tomorrow.
14:40:44 <Botje> pat yourself on the back, you did well
14:40:59 <SubStack> the best thing short of writing a proper dsl would be to manipulate the glsl's parse tree and then dump it back to text again
14:42:10 <jmcarthur> woah weechat
14:42:50 <jmcarthur> i think it's time to restart my client. weird stuff is happening
14:43:45 <Alpounet> @hoogle JustS
14:43:45 <lambdabot> No results found
14:43:49 <Alpounet> @index JustS
14:43:49 <lambdabot> bzzt
14:43:50 <Alpounet> mhm
14:44:55 <jmcarthur> Alpounet: planning to do an entry in google ai challenge?
14:45:06 <b0fh_ua> Botje: thanks
14:45:21 <b0fh_ua> hopefully I will understand this code at morning :)
14:47:03 <Botje> :)
14:47:07 <Botje> i'm still here tomorrow ;
14:52:10 <luqui> is it possible to have a cabal repo that is more local than user?  e.g. i want to use one that is only for a particular project.
14:52:10 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
14:52:26 <Saizan> luqui: yeah
14:52:39 <Saizan> luqui: --package-db=somefile
14:53:15 <luqui> neat.   doesn't it need to store more than just a db though?  or is somefile actually a directory?
14:54:10 <Saizan> well, you can use --prefix to control where the actual .hi .a files get stored
14:54:24 <Saizan> the db were just a file until 6.12
14:54:59 <luqui> ah yeah --prefix is what i was wondering about.  cool, thnx
14:55:15 <Saizan> on 6.12 even that is a directory, but it contains only the InstalledPackageInfo
14:58:15 <FliPPeh> :t flip
14:58:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:58:50 <FliPPeh> flip (/) 0 5
14:58:52 <FliPPeh> > flip (/) 0 5
14:58:53 <lambdabot>   Infinity
14:58:58 <FliPPeh> > (/) 0 5
14:58:59 <lambdabot>   0.0
14:59:08 <FliPPeh> > (/) 2 5
14:59:08 <lambdabot>   0.4
14:59:12 <FliPPeh> > flip (/) 2 5
14:59:13 <lambdabot>   2.5
14:59:14 <FliPPeh> Aha
14:59:15 <FliPPeh> :)
14:59:22 <FliPPeh> nifty
14:59:22 <burp> you like to flip, eh? :P
14:59:36 <FliPPeh> Seems so!
14:59:37 <FliPPeh> :D
14:59:48 <damd> flipmode, flipmode is the greatest
14:59:49 <shepheb> burp: ouch.
15:01:53 <luqui> > flip [(/2), (/3), (/4)] 1
15:01:54 <lambdabot>   [0.5,0.3333333333333333,0.25]
15:03:41 <burp> huh
15:03:52 <burp> oh, caleskell flip
15:04:12 <Twey> :t flip
15:04:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:04:18 <Twey> Heh
15:04:22 <MissPiggy> :t flip
15:04:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:04:24 <MissPiggy> woops
15:04:33 <Twey> :t Prelude.flip
15:04:34 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:04:40 <Twey> I see
15:04:52 <Twey> He generalised the first (a ->) to a functor f a
15:05:06 <harlekin> OpenGL Question: Can anyone tell me why the top of the cube (red face) is overlapped by the left quad? Image: http://img717.imageshack.us/img717/5207/ogl.png Paste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18994#a18994
15:06:56 <Botje> random guess: drawing order?
15:07:23 <DekuNut> I've been trying to think of a nice way to work out whether a winning outcome is on my tic-tac-toe board (which is: [[Naught,Naught,Naught]])
15:07:29 <dankna> did you remember to turn on the depth buffer prior to creating your graphics context?
15:07:30 <lispy> harlekin: have you gone through the Haskell version of the ne-he opengl tutorials?
15:07:36 <DekuNut> The simple solution, I can just do a check for verticals, then horizontals, then diagonals
15:07:41 <lispy> ?hackage nehe
15:07:42 <lambdabot> http://hackage.haskell.org/package/nehe
15:07:51 <MissPiggy> DekuNut: that's probably the best one too
15:07:52 <DekuNut> But trying to figure out a way to simply find any winning combination in one procedure
15:08:10 <lispy> harlekin: er, the real link is here http://hackage.haskell.org/package/nehe-tuts
15:08:16 <dankna> also it doesn't look like you're even clearing the depth buffer
15:08:22 <DekuNut> MissPiggy, perhaps, but just thought it'd be interesting to try another way, thought someone might have some ideas because I can't think of anything, not for the lack of trying
15:08:26 <dankna> change clear [ColorBuffer] to clear [ColorBuffer, DepthBuffer]
15:08:45 <MissPiggy> DekuNut, hmm
15:08:55 <MissPiggy> DekuNut, oh I know a different way to do it
15:09:01 <DekuNut> :o
15:09:21 <dankna> but you also have to turn it on.  if you're using GLUT I don't know exactly what call does that.
15:09:40 <MissPiggy> DekuNut, you can do some clever trick with arithmetic (multiply the different board cells by values and sum them all), if the number fits some criteria then there's a win
15:09:52 <MissPiggy> DekuNut, I'll let you fill in the details :P
15:09:55 <DekuNut> MissPiggy, well, I figured if I labeled each field with a digit, like
15:10:03 <DekuNut> 1,2,3 | 4,5,6 | 7,8,9
15:10:27 <DekuNut> Found out all the possible outcome values, then finding some criteria that only those outcomes fit into
15:10:35 <DekuNut> Which sounds like what you suggested but it seems
15:10:37 <DekuNut> Overly complicated
15:10:56 <MissPiggy> DekuNut, it probably ends up one like of code in the end, but /getting there/ yeah it's very complicated
15:11:23 <DekuNut> Alright, I'll give it a go
15:11:36 <harlekin> lispy, thank you. I'll take a look at it. (:
15:11:41 <DekuNut> Thanks MissPiggy
15:12:13 <lispy> harlekin: cool.  I hope you find it useful.  I translated those from the official nehe opengl tutorials back when I was learning opengl.
15:12:22 <lispy> Been years now though
15:12:34 <lispy> I no longer remember much opengl
15:13:19 <SubStack> I never even learned opengl properly in c
15:13:23 <SubStack> jumped right into haskell
15:13:37 <SubStack> since it's sooooo much prettier
15:14:40 <SubStack> harlekin: you could use my simulation class if you're feeling super lazy :D
15:14:44 <burp> I wonder what the source of flip is
15:14:58 <FliPPeh> How can I implement liftIO in my own Monad?
15:15:01 <burp> (the functor flip)
15:15:15 <harlekin> SubStack, what simulation class? Could you provide a link?
15:15:33 <SubStack> http://github.com/substack/haskell-opengl-simulations/
15:16:01 <dbro> noobie question: I believe haskell source code is often much shorter than equivalent C code. But how do the sizes of the compiled binary programs compare (typically) ?
15:16:09 <SubStack> the interface is undergoing lots of flux however
15:16:58 <Botje> dbro: up until now, horrible. because haskell binaries include all of the runtime system and all of the linked libraries.
15:17:13 <dbro> is something about to change?
15:17:15 <Botje> but new releases of GHC are getting smarter at splitting binaries and removing unused functions
15:17:30 <SubStack> 6.12 has -dynamic too
15:17:38 <SubStack> or at least, a better one?
15:18:07 <dbro> Does JHC produce smaller (?lazier?) binary files?
15:18:49 <aavogt> why are you so concerned about implementation details, dbro?
15:19:17 <dbro> I want to try running haskell code on a limited platform (a wifi router running OpenWRT linux)
15:19:29 <Saizan> 6.12 supports dynamic linking of haskell dependencies
15:19:58 <dbro> multi-megabyte binaries won't fit
15:20:05 <FliPPeh> :t liftIO
15:20:06 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
15:20:17 <FliPPeh> Aha
15:20:22 <shepheb> dbro: isn't compiling for the (probably ARM?) processor more of a concern anyway?
15:20:45 <dbro> JHC can help there- it's can compile to C
15:20:51 <kmc_> so can GHC
15:20:55 <dbro> oh ok
15:20:59 <kmc_> iirc there is an unregisterized build for ARM
15:21:06 <shepheb> except that GHC's C is usually far less portable.
15:21:13 <shepheb> jhc has no garbage collection, though.
15:21:14 <kmc_> that is GHC's slow-but-portable C mode can run on ARM with few tweaks
15:21:20 <kmc_> JHC is a toy compiler
15:21:52 <kmc_> if you want to run Haskell code in a small footprint, the solution might actually be an interpreter like Hugs
15:21:55 <kmc_> it's not a common requirement
15:22:05 <Saizan> or nhc
15:22:25 <dbro> thanks for the pointers, I will check those out
15:22:28 <kmc_> which is now yhc?
15:22:40 <Saizan> no, they are separate
15:23:05 <FliPPeh> @hoogle MonadIO
15:23:05 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
15:23:07 <kmc_> well nhc is a compiler
15:23:31 <kmc_> yhc has a bytecode and a small interpreter for that, written in C
15:23:34 <kmc_> might be a good choice
15:24:09 <Saizan> nhc was designed for embedded systems though, iirc
15:24:13 <Adamant> shepheb: it could also be MIPS.
15:24:16 <kmc_> i guess nhc has bytecodes too, though.  i'm not really clear on that
15:30:02 <notallama> how do you pronounce (->) ? or ((->) e) ?
15:30:14 <damd> you don't
15:30:23 <damd> that's the beauty of haskell... no speaking required!
15:30:26 <aavogt> 'to'
15:30:44 <aavogt> type of functions from e to ....
15:31:01 <damd> how do you pronounce |?
15:31:08 <damd> as in data A = A | B | C
15:31:09 <medfly> hmm...
15:31:09 <notallama> and a related question, how do you google them?
15:31:16 <medfly> maybe "or"?
15:31:17 * syntaxglitch generally says "|"
15:31:21 <medfly> hehe
15:31:33 <Twey> I say â€˜orâ€™
15:31:37 <aavogt>  `|' means many different things
15:31:42 <damd> how do you pronounce <-?
15:31:44 <aavogt> the context does matter
15:31:47 <Twey> â€˜fromâ€™
15:31:53 <notallama> i say 'pipe' or 'or', depending on context
15:31:58 <medfly> I have to be honest
15:32:03 <medfly> I don't pronounce my code, what the hell?
15:32:06 <syntaxglitch> damd, like "->", but I look the other direction when saying it
15:32:12 <damd> how do you pronounce *>?
15:32:12 <Twey> Haha
15:32:12 <heatsink> It's obviously pronounced as an alveolar click.
15:32:14 <Twey> >.> arrow
15:32:16 <Twey> <.< arrow
15:32:33 <aavogt> how do you pronounce (.)
15:32:36 <EvanR-work> i implemented zip and unzip in javascript
15:32:38 <damd> aavogt: concatenate
15:32:39 <dolio> medfly: What do you do when you need to read code to someone over the telephone?
15:32:40 <medfly> why do you need to pronounce code?
15:32:43 <EvanR-work> and have been using to for like 2 months
15:32:44 <damd> uh, what
15:32:44 <damd> no
15:32:46 <medfly> dolio, I ask for his e-mail
15:32:48 <damd> compose isn't it?
15:32:49 <EvanR-work> and i just realized its the same algorithm
15:32:50 <Itkovian> Any elegant solution to using data T = T { f :: Int } and data U = U { f :: Int }, where f cannot have another name as it needs to be filled in automagically? -XDisambiguateRecordFields does not doe the trick; if I understood well, this allows overloading from stuff coming from different modules, so that might be a last resort, if I cannot find something more elegant
15:33:05 <aavogt> @quote "(.)"
15:33:05 <lambdabot> Korollary says: I don't subscribe to smalltalk's "+" is a message you send to a number object argument
15:33:06 <Twey> EvanR-work: Hahaha
15:33:10 <EvanR-work> and i wrote the algorithm exactly the same way, and they are right next to each other
15:33:14 <EvanR-work> and i didnt notice
15:33:28 <ElfArmy> With sufficiently advanced programmers, no words are necessary to convey its meaning :D
15:33:56 <SubStack> (.) looks like a dot to me
15:33:57 <medfly> but I guess not pronouncing code is like a side effect of not being a native English speaker
15:34:07 <medfly> "one boob" :))))
15:34:21 <SubStack> but "compose" seems better than "concatenate"
15:34:22 <aavogt> but I guess not pronouncing code is like a side effect of being mute
15:34:33 <notallama> i call (.) 'comp'
15:34:41 <Twey> function unzip(lst) { return zip.apply(this, lst); }
15:34:48 <damd> double-u double-u double-u compose ...
15:34:49 <EvanR-work> Twey: heh ;)
15:34:51 <aavogt> "neht"
15:35:00 <zakwilson> I'm looking for a data structure. It's some sort of map. The keys are variable length lists of variable length strings, and the values are integers. I expect to have a few hundred to tens of thousands of entries. Fast lookups are critical. Fast inserts would be nice, but not critical. Is a hashtable what I want?
15:35:13 <heatsink> zakwilson: A trie?
15:35:26 <syntaxglitch> Sounds like a job for supertrie
15:35:34 <shepheb> I often pronounce '.' and ' ' as juxtaposition. f . g . h $ x comes out as "eff gee aitch dollar eks."
15:35:47 <medfly> o.O
15:35:56 <augustss> zakwilson: have you tried Data.Map?
15:36:02 <shepheb> but that's only in my head; so I know what I mean.
15:36:10 <medfly> this is a way for us to say that you should all find other ways to discuss code
15:36:13 <shepheb> if I were dictating, I'd probably say "dot"
15:36:17 <SubStack> I have yet to find myself in a position where I am dictating haskell aloud
15:36:33 <medfly> oh... professors...
15:36:37 * medfly realises that they exist
15:36:39 <medfly> alright
15:36:41 <zakwilson> heatsink: perhaps.
15:36:41 <syntaxglitch> could be worse--imagine dictating APL out loud
15:36:53 <shepheb> those symbols all have well-known names
15:36:54 <notallama> or perl :p
15:36:54 <aavogt> they get to write the code though
15:37:20 <Twey> Or C
15:37:27 <shepheb> unless you're a classmate of mine, who said "delta calculus" several times while asking a question.
15:37:28 <medfly> C isn't too bad
15:37:32 <heatsink> zakwilson: Do the lists frequently have common prefixes, and is it possible for lookup to fail?
15:37:38 <shepheb> my professor appeared to die a little inside
15:37:42 <EvanR-work> after using haskell, i cant stand c :(
15:37:48 <zakwilson> augustss: I did in some old code that was lost. I'm hoping for better performance, but I may go back to that.
15:37:51 <Twey> â€˜if open-paren x greater-than four close-paren open-brace x equals five semicolon close-braceâ€™
15:37:52 <medfly> shepheb, what did he mean when saying delta calculus?
15:37:57 <SubStack> EvanR-work: same
15:37:58 <medfly> shepheb, oh... lambda?
15:37:59 <zakwilson> heatsink: Yes and yes.
15:37:59 <shepheb> medfly: lambda calculus
15:38:05 <shepheb> we'd been talking about it for two lectures
15:38:11 <medfly> well, can't blame a guy for not knowing Greek outside of Greece.
15:38:19 <augustss> zakwilson: Don't optimize prematurely.  Use Data.Map, then profile.
15:38:20 <shepheb> the symbol is right there on the slide he's asking a question about.
15:38:32 <medfly> shepheb, he probably didn't know it's called lambda
15:38:39 <notallama> EvanR-work: i still enjoy c somehow. there's just something about 'bits is bits' that makes me feel warm and fuzzy inside
15:38:41 <shepheb> we'd been tlaking about it for nearly two class hours.
15:38:59 <augustss> Knowing the greek alphabet is part of scientific literacy :)
15:39:02 <medfly> notallama, take your hands off the electrical circuitt
15:39:03 <SubStack> bits are great until you need to do something with them
15:39:19 <zakwilson> augustss: The root of all evil, I know. I suppose I'll write the new code with Data.Map and see how it goes.
15:39:32 <medfly> (this was a poor attempt at a joke)
15:39:32 <MyCatVerbs> notallama: Data.Bits has Word8, Word16, Word32 and Word64. :)
15:40:11 <MyCatVerbs> Er, brainfart. Data.Word has those. Data.Bits has all the bitwise arithmetic operators.
15:40:39 <notallama> MyCatVerbs: but you can't just say "oh yeah, this chunk of memory right here is actually a struct", can you?
15:40:44 <syntaxglitch> zakwilson, Data.Map is a sorted tree, lookup is O(log n) in collection size I think; that's probably fast enough for most purposes
15:41:28 <MyCatVerbs> notallama: There's the C API.
15:41:47 <augustss> syntaxglitch: well, depending on the application it might be the constant factor you want to be smaller rather than the big-O
15:41:57 <dolio> The problem is that doing lots of [String] comparisons on lookup isn't a great strategy. The question is whether it matters.
15:42:23 <MyCatVerbs> notallama: so, no, not without a smallish code generator (or some manual legwork), beyond the fact that you can allocate memory yourself.
15:43:39 <MyCatVerbs> notallama: but to be fair, it's really inadvisable to cast pointers to and from different structs and types in C in an undisciplined way because it violates the Hell out of the strict aliasing rules.
15:44:08 <heatsink> Always cast to char* first!
15:44:08 <kmc_> you should do all your unsafe pointer casts in Haskell ;)
15:44:38 <roderick2> Testing
15:44:40 * syntaxglitch points to the infamous fast inverse square root algorithm as an example of unsafe bit hacking put to good use
15:44:43 <pikhq> MyCatVerbs: Well, there is some casting that is entirely legitimate.
15:45:03 <pikhq> struct foo {int bar;};struct bar {int bar; int baz;};
15:45:04 <MyCatVerbs> syntaxglitch: that's grand, but it should've used a union for the type pun instead of a pointer cast. :)
15:45:23 <pikhq> foo and bar pointers are perfectly valid to cast between.
15:45:49 <MyCatVerbs> notallama: which leads to either having to turn off a very useful optimisation flag (sad song, small violin) or incorrect microcode being generated (saddest song, smallest violin.)
15:45:52 <syntaxglitch> MyCatVerbs, either way you're telling type safety to take a hike
15:46:18 <kmc_> microcode?
15:46:38 <MyCatVerbs> kmc_: object code. Machine code. Pick any name you like.
15:47:06 <kmc_> microcode usually refers to something else
15:47:10 <MyCatVerbs> syntaxglitch: Surprisingly, no. Modern C says that you get undefined behaviour if you have pointers of different types aliasing one another.
15:47:51 <MyCatVerbs> kmc_: oh, but that's at least two rungs down the abstraction ladder. ;) Apologies, regardless.
15:48:00 <syntaxglitch> MyCatVerbs, hunh. Fair enough, I've not done much more than fairly trivial programming in C.
15:48:35 <MyCatVerbs> syntaxglitch: The behaviour that you get by type-punning through a union is implementation-defined instead. ^^
15:49:33 <MyCatVerbs> pikhq: I have to wonder whether that wasn't just grandfathered in to support the BSD sockets API. ;)
15:51:26 <notallama> i dunno. there's just something satisfying about dumping the contents of a file somewhere, and casting the whole thing as a struct of some kind.
15:51:42 <MyCatVerbs> notallama: Please don't do that. D:
15:52:27 <shepheb> Binary instance win?
15:52:27 <notallama> the look on your face is part of the reason it's so fun :p
15:52:29 <Polarina> notallama, :)
15:52:36 <MyCatVerbs> For starters, it's going to end in tears as soon as you get hit in the face by struct padding varying from one machine to another.
15:52:41 <kmc_> in the real world it is quite often useful to write non-portable C code
15:52:49 <kmc_> and usually acceptable as long as you don't pretend it is portable
15:52:58 <kmc_> gcc provides padding attributes for this reason
15:52:59 * syntaxglitch grumbles about a bunch of OpenGL-based stuff in hackage being broken.
15:53:15 <Polarina> syntaxglitch, do you have OpenGL 3.2?
15:53:26 <Polarina> syntaxglitch, the latest bindings there is for that version.
15:53:28 * SubStack grumbles about a bunch of opengl-based stuff on hacking being ioref-based
15:53:31 <MyCatVerbs> kmc_: I hope for your sake that you never run into a Debian maintainer in a dark alley with a sharp knife.
15:53:42 <DBAlex> hey
15:53:44 <DBAlex> Hey, how can I do this in Haskell, say I have a list like [[1,2,3],[4,5,6],[7,8,9]], I need to get the 1st elem from the 1st sublist, 2nd from the 2nd, 3rd from the 3rd etc... I don't have to use n+k patterns right?
15:53:46 <SubStack> iorefs are so wrong
15:53:54 <kmc_> MyCatVerbs: yeah, i am thinking more of in-house apps with very specific requirements
15:54:00 <syntaxglitch> Polarina, no, it's that the opengl package changed some interface stuff at some point and (last I checked) a lot of packages using it were broken
15:54:15 <DBAlex> This should be really easy, i'm sure i'm missing something easy :-/
15:54:24 <DBAlex> *simple
15:54:44 <heatsink> > zipWith (!!) [0..] [[1,2,3], [4,5,6], [7,8,9]]
15:54:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:54:45 <lambdabot>         against inferred type ...
15:54:57 <DBAlex> so for the above list it would return [1,5,9]
15:55:00 <kmc_> > zipWith (flip (!!)) [0..] [[1,2,3], [4,5,6], [7,8,9]]
15:55:02 <lambdabot>   [1,5,9]
15:55:05 <Polarina> > foldl (head:) [] [[1,2,3],[4,5,6],[7,8,9]]
15:55:06 <lambdabot>   Couldn't match expected type `b -> [[a] -> a]'
15:55:06 <lambdabot>         against inferred typ...
15:55:18 <kmc_> i don't understand all this hate for IORefs
15:55:27 <DBAlex> kmc_: thanks :)
15:55:31 <kmc_> OpenGL is an imperative API and the Haskell binding does not claim to change that
15:55:32 <SubStack> add any concurrency at all and they break
15:55:35 <DBAlex> kmc_: flip?
15:55:39 <kmc_> :t flip
15:55:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:55:44 <kmc_> err, that flip is crazy
15:55:46 <DBAlex> ouch
15:55:47 <DBAlex> :(
15:55:49 * SubStack has been bitten by some horrible bugs with iorefs
15:55:52 <DBAlex> in english?
15:55:53 <kmc_> flip f x y = f y x
15:55:59 <DBAlex> ah
15:56:00 <kmc_> flip :: (a -> b -> c) -> b -> a -> c
15:56:02 <haole> hello there... i'm starting to read Learn Yourself a Haskell For Good and i was wondering if Haskell has memory management similar to C programs, because i was looking at some haskell projects bugzillas and there were some bugs about memory leaks...
15:56:06 <syntaxglitch> OpenGL gives a whole new meaning to "imperative"
15:56:08 <DBAlex> kmc_: thanks!
15:56:22 <shepheb> hm, it's been a while since Caleskell blew my mind. I'm going to have to ponder that flip type.
15:56:32 <DBAlex> haole: depends on the compiler I guess
15:56:40 <kmc_> haole: memory in Haskell is automatically managed, usually by garbage collection
15:56:47 <SubStack> haole: you should only need to care about that if you're using the ffi
15:56:52 <heatsink> shepheb: f = (->) a
15:56:54 <kmc_> so a memory leak would correspond to keeping some references to stuff around when you shouldn't
15:57:05 <kmc_> most likely they don't mean a leak in the sense of failing to free() in C
15:57:09 <haole> that's nice... i was looking at the bugzilla of yi editor and got curious
15:57:21 <kmc_> most likely they mean using more memory than is desired, probably due to laziness
15:57:32 <kmc_> storing a big unevaluated expression in memory, instead of a small result value
15:57:32 <SubStack> memory is cheap
15:57:34 <shepheb> heatsink: well, to be the same as regular flip, yes. but is the generalization actually useful?
15:57:51 <pikhq> SubStack: But it has cost.
15:57:58 <syntaxglitch> SubStack, until it gets paged to disk
15:58:07 <heatsink> oh.  I don't know.
15:58:11 <syntaxglitch> There is no amount of money that can buy your latency back at that point
15:58:15 <blackh> SubStack, or until you're developing on an embedded system
15:58:15 <kmc_> err, RAM is slow compared to cache
15:58:18 <kmc_> and cache is very expensive
15:58:27 <SubStack> meh
15:58:44 <kmc_> i mean usually this sort of thing is considered premature optimization
15:59:08 <Polarina> > map head [[1,2,3],[4,5,6],[7,8,9]]
15:59:09 <lambdabot>   [1,4,7]
15:59:12 <shepheb> > flip (Just show) 3
15:59:13 <lambdabot>   Just "3"
15:59:18 <shepheb> >flip (Just show) Nothing
15:59:21 <Polarina> DBAlex, there you go. :)
15:59:28 <shepheb> > flip (Just show) Nothing
15:59:29 <lambdabot>   Just "Nothing"
15:59:45 <shepheb> > flip Nothing 1
15:59:46 <lambdabot>   Nothing
15:59:56 <DBAlex> Polarina: thanks :)
15:59:56 <syntaxglitch> I think I need to take a break from answering Haskell questions on StackOverflow
16:00:02 <luqui> :t flip Nothing
16:00:02 <lambdabot> forall a b. a -> Maybe b
16:00:03 <syntaxglitch> It's becoming an unhealthy habit
16:00:07 <Polarina> DBAlex, you're welcome.
16:00:12 <shepheb> > flip [(+1),(*2)] 4
16:00:13 <lambdabot>   [5,8]
16:00:59 <DBAlex> heh
16:01:14 <heatsink> It would be useful to have a TH library for making and traversing large record types where all fields have the same type.
16:01:26 <DBAlex> > flip [(+1),(*2)] 4
16:01:27 <lambdabot>   [5,8]
16:01:31 <DBAlex> isn't too helpful :P
16:01:36 <DBAlex> :S
16:01:44 <DBAlex> I guess it's needed here though
16:01:46 <shepheb> DBAlex: just playing with the Caleskell version of flip.
16:01:53 <DBAlex> shepheb: ok
16:02:00 <DBAlex> wonder why it gave such a wierd typedef
16:02:12 <DBAlex> can't you just have lamdbabot linked to ghci or something?
16:02:12 <shepheb> well, it's a straightforward generalization of real flip
16:02:14 <augustss> :t flip flip
16:02:14 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
16:02:22 <doserj> @type \x -> fmap ($x)
16:02:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
16:02:30 <augustss> :t flip
16:02:30 <doserj> it's a flipped version of tha
16:02:31 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:02:31 <SubStack> hmmm I can abuse catch and PatternMatchFail to make a sweet interface for callbacks
16:02:37 <shepheb> doserj: so I see.
16:02:42 <augustss> ugh
16:02:51 <DBAlex> ok
16:03:04 <augustss> :t flip flip flip
16:03:05 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
16:03:18 <shepheb> sort of the dual of fmap. I've got a data structure full of functions and one value to which to apply them.
16:03:19 <DBAlex> Just hope no newbies ask about flip, right? ;)
16:03:29 <shepheb> :t Prelude.flip
16:03:30 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:03:40 <shepheb> DBAlex: we can still access the original
16:03:47 <DBAlex> shepheb: nice
16:04:16 <DBAlex> :m + System.Random
16:04:21 <DBAlex> > :m + System.Random
16:04:22 <lambdabot>   <no location info>: parse error on input `:'
16:04:29 <DBAlex> It's not ghci :)
16:04:48 <shepheb> DBAlex: I think lambdabot actually predates ghci.
16:04:59 <augustss> Just as well, ghci sucks.
16:05:04 <shepheb> it actually uses the GHC API with a lot of extensions and some libraries replaced.
16:05:24 <DBAlex> ok
16:06:24 <shepheb> lambdabot also might rank high on a list of cruftiest Haskell code in existence.
16:09:00 * byorgey makes lambda-peanut curry with green pepper and roasted squash
16:10:02 * heatsink has to stop coding and get dinner now...
16:10:02 <Sgeo_> Caleskell?
16:10:26 <shepheb> Sgeo_: colloquial name for lambdabot's idiosyncratic standard library
16:10:32 <shepheb> :t map
16:10:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:10:36 <heatsink> I think roasted squash would fall apart in a curry though
16:10:39 <shepheb> oh, that one is back to normal
16:10:43 <augustss> Haskell with the bizarre Prelude Cale has made
16:10:45 <shepheb> :t flip
16:10:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:10:48 <shepheb> :t Prelude.flip
16:10:49 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:11:01 <luqui> I think flip follows from strength: http://en.wikipedia.org/wiki/Strong_monad
16:11:02 <augustss> :t (.)
16:11:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:11:15 <Sgeo_> Wait, you can specify kinds?
16:11:26 <shepheb> Sgeo_: with some extension or other
16:11:27 <luqui> @let strength = fmap . (,)
16:11:28 <lambdabot>  Defined.
16:11:31 <luqui> :t strength
16:11:32 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
16:11:33 <augustss> Sgeo_: by turning on an extension
16:11:38 <Sgeo_> :t (,)
16:11:39 <lambdabot> forall a b. a -> b -> (a, b)
16:11:53 <augustss> :t fmap
16:11:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:12:01 <luqui> :t \f x -> fmap (uncurry (flip ($))) (strength x f)
16:12:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
16:12:03 <augustss> :t ).)
16:12:04 <lambdabot> parse error on input `)'
16:12:07 <augustss> :t (.)
16:12:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:12:19 <augustss> :t (.) . (,)
16:12:19 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
16:12:24 <Sgeo_> ..wait, what's with the weird (.) type?
16:12:31 <Sgeo_> Is that Caleskell at work?
16:12:34 <augustss> Caleskell
16:12:36 <byorgey> yep =)
16:12:38 <burp> yes
16:12:50 <burp> its fmap
16:13:00 <Sgeo_> WHY?
16:13:01 <shepheb> Sgeo_: Prelude.(.) is just fmap restricted to (->) a, of course :P
16:13:08 <Sgeo_> Ah
16:13:19 <tensorpudding> just the same as map is fmap restricted to [] a
16:13:24 <shepheb> Sgeo_: quite aside from practical purposes, seeing these generalized expressions is a source of enlightenment for newbies.
16:13:25 <Sgeo_> ...don't quite understand functors in relation to (->) a though
16:13:29 <shepheb> it certainly was for me.
16:13:43 <SubStack> Your search - haskell "inverted subclassing" - did not match any documents.
16:13:54 <SubStack> looks like I'll be the first!
16:14:26 <shepheb> Sgeo_: instance Functor ((->) a) where fmap = (.)
16:14:35 <shepheb> which doesn't help, I imagine.
16:14:42 <SubStack> unless what I am thinking of (that perl's Moose has) is called something else in haskell
16:14:56 <tensorpudding> that doesn't work if you define (.) in terms of fmap though
16:15:02 <shepheb> tensorpudding: well, no
16:15:06 <shepheb> turtles all the way down.
16:15:28 <tensorpudding> :t (++)
16:15:29 <shepheb> it does if you appeal to the Prelude though
16:15:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:15:34 <ddarius> data Void a; instance Functor Void where fmap = fmap
16:15:35 <tensorpudding> aha
16:15:36 <SubStack> shepheb: indeed! c/,,\
16:15:37 <tensorpudding> more caleskell
16:16:06 <tensorpudding> :t mappend
16:16:07 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:16:16 <byorgey> Sgeo_: well, it makes a nice exercise.  substitute (a ->) in place of f everywhere and see what you get.
16:16:24 <tensorpudding> defining (++) = mappend too
16:16:25 <shepheb> of all the Caleskell changes, that one is the most should-be-the-real-one I think.
16:16:35 <tensorpudding> i hate mappend though
16:16:38 <tensorpudding> too long
16:16:43 <shepheb> that's exactly my point
16:16:50 <byorgey> tensorpudding: right, which is why ++ is much better =)
16:16:55 <MissPiggy> > "foo"`mplus`"bar"
16:16:56 <shepheb> we should be spelling `mappend` as ++
16:16:56 <lambdabot>   "foobar"
16:17:02 <MissPiggy> why mappend not mplus?
16:17:04 <SubStack> > fix ("c/,,\\ "++) -- turtles all the way down
16:17:05 <lambdabot>   "c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,\\ c/,,...
16:17:07 <MissPiggy> @src mappend
16:17:07 <lambdabot> Source not found.
16:17:10 <MissPiggy> :t mappend
16:17:11 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:17:15 * Sgeo_ is tpp tired to think right now, though
16:17:16 <MissPiggy> ahh I see
16:17:19 <shepheb> MissPiggy: mplus is MonadPlus in the [] monad
16:17:40 <tensorpudding> Instance Monoid ([] a) where mempty = [], mappend = (++)
16:17:54 <byorgey> > Product 2 ++ Product 3
16:17:55 <lambdabot>   Product {getProduct = 6}
16:18:36 <shepheb> :t Min
16:18:37 <lambdabot> Not in scope: data constructor `Min'
16:18:38 <tensorpudding> hmm, is there a Monoid definition for Integer...
16:18:41 <shepheb> :t Minimum
16:18:42 <lambdabot> Not in scope: data constructor `Minimum'
16:18:50 <byorgey> tensorpudding: yes, two: Sum and Product
16:18:51 <shepheb> tensorpudding: probably not. too many sensible ones.
16:18:57 <byorgey> but they are newtypes
16:19:16 <shepheb> curse you, imprecise semantics. byorgey and I are both right, depending what you meant.
16:19:20 <tensorpudding> where mempty = 1 and mappend = (*), or mempty = 0 and mappend = (+)
16:19:28 <byorgey> hehe
16:19:57 <byorgey> tensorpudding: there is no  instance Monoid Integer.  there are two instances  Monoid Product  and  Monoid Sum, where Product and Sum are newtype wrappers around Integer.
16:20:01 <shepheb> tensorpudding: Maximum/Minimum, if we had +/- infinity
16:20:11 <tensorpudding> hmm
16:20:19 <shepheb> if you know you're working with positive numbers, mempty = 0, mappend = max
16:20:26 <byorgey> > mconcat . map Sum $ [1..5]
16:20:27 <tensorpudding> it would make sense to have them wrapped with newtypes so that you could have multiple definitions
16:20:28 <lambdabot>   Sum {getSum = 15}
16:21:22 <copumpkin> > foldMap Sum [1..5]
16:21:23 <lambdabot>   Not in scope: `foldMap'
16:21:29 <copumpkin> > Data.Foldable.foldMap Sum [1..5]
16:21:30 <lambdabot>   Sum {getSum = 15}
16:21:42 <copumpkin> > Data.Foldable.foldMap Product [1..5]
16:21:43 <lambdabot>   Product {getProduct = 120}
16:21:52 <DBAlex> kmc_: hey, why wouldn't this work as an answer to my problem?:  foldl (: !!) [0..] [[1,2,3],[1,2,3],[1,2,3]]
16:21:56 <DBAlex> *won't even
16:21:58 <shepheb> also, whoever linked to "strong monads" needs to grab the brain mop
16:22:11 <copumpkin> strength is very useful
16:22:16 <temoto> Could someone with good knowledge of english language help me on #english?
16:22:17 <MissPiggy> what's a strong monad
16:22:18 <DBAlex> can't understand why it wouldn't :S
16:22:25 <shepheb> copumpkin: I was unclear
16:22:35 <copumpkin> @let strength = uncurry (fmap . (,))
16:22:36 <lambdabot>  <local>:19:0:
16:22:36 <lambdabot>      Multiple declarations of `L.strength'
16:22:36 <lambdabot>      Declared at: <...
16:22:39 <copumpkin> oh
16:22:42 <copumpkin> :t strength
16:22:43 <lambdabot> forall a1 (f :: * -> *) a. (Functor f) => a1 -> f a -> f (a1, a)
16:22:43 <shepheb> it wasn't the good brain explosion, it was the "firehose vs. soup cracker" kind
16:22:47 <shepheb> waaaay out of my depth
16:22:49 <copumpkin> boo, it's the curried version
16:23:07 <copumpkin> @let strength' = uncurry strength
16:23:08 <lambdabot>  Defined.
16:23:10 <augustss> DBAlex: doesn't even look syntactically correct
16:23:11 <MissPiggy> :t fmap
16:23:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:23:16 <tensorpudding> :t (: !!)
16:23:17 <lambdabot> parse error on input `!!'
16:23:22 <DBAlex> yeah but ...
16:23:23 <copumpkin> > strength' (5, [1..10])
16:23:24 <lambdabot>   [(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(5,9),(5,10)]
16:23:26 <tensorpudding> might be why you have an issue
16:23:29 <DBAlex> you can see what I want to do
16:23:33 <MissPiggy> :t \a1 -> fmap (\a -> (a1, a))
16:23:34 <lambdabot> forall a t (f :: * -> *). (Functor f) => t -> f a -> f (t, a)
16:23:34 <augustss> No
16:23:35 <tensorpudding> :t (: (!!))
16:23:36 <lambdabot>     Couldn't match expected type `[a]'
16:23:37 <lambdabot>            against inferred type `[a1] -> Int -> a1'
16:23:37 <lambdabot>     In the second argument of `(:)', namely `(!!)'
16:23:42 <tensorpudding> it doesn't much make sense
16:23:54 <MissPiggy> @src strength
16:23:54 <lambdabot> Source not found. :(
16:24:09 <DBAlex> well get the 1st element of the 1st , 2nd of the 2nd, 3rd of the 3rd and return as a list?
16:24:16 <watermind> MissPiggy: it's a monad T with a strength morphism  s : A x T B -> T (A x B)
16:24:20 <copumpkin> don't use !! if you can possibly avoid it
16:24:21 <DBAlex> kmc_ solved it but I'm trying to find other ways too
16:24:26 <osaunders> Check it out, I'm going to be so rich!! I've written a completely non-interactive game: http://codepad.org/Ieq0k0e1
16:24:26 <copumpkin> and I'm pretty sure you can avoid it there
16:24:42 <MissPiggy> every monad in haskell is strong then
16:24:44 <watermind> MissPiggy: if I'm not mistaken you always have a strength in your haskell monads
16:24:46 <augustss> > zipWith (!!) [[1,2,3],[1,2,3]] [0..]
16:24:47 <copumpkin> MissPiggy: yep
16:24:47 <lambdabot>   [1,2]
16:25:01 <MissPiggy> osaunders that's pretty cool :)
16:25:03 <DBAlex> ah
16:25:07 <DBAlex> augustss: nice
16:25:20 * osaunders would appreciate any constructive criticism of his code.
16:25:24 <osaunders> MissPiggy: Thanks :-)
16:25:43 <watermind> MissPiggy:  \a tb -> do { b <- tb; return (a,b)}
16:25:43 <temoto> osaunders, i played one MMORPG in which you don't have to do a thing. The player fight monsters and does quests by its own.
16:26:12 <temoto> osaunders, you just track his progress in client and on website. I don't recall the name of that game.
16:26:21 <dolio> Every haskell Functor is strong, even.
16:26:27 <osaunders> temoto: lol, nice.
16:26:32 <copumpkin> every functor is a bodybuilder
16:27:13 <DBAlex> looks like ascii soup :)
16:27:19 <DBAlex> but it's probably nice code
16:27:58 <watermind> dolio: does that make sense?
16:28:18 <dolio> @type \(a, b) -> fmap ((,) a) b
16:28:19 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
16:29:14 <SubStack> is it possible to refer to the default implementation of a class from an instance which overrides that default?
16:29:27 <osaunders> DBAlex: Yeah I tend to write quite dense.
16:29:29 <SubStack> default implementation of a function, I should say
16:29:57 <watermind> dolio: sure you can have a function with that type but would it make sense to call it a strength, that is, for Functors that are monads, would that definition coincide with their respective monadic strength?
16:30:16 <dolio> Presumably.
16:31:12 <watermind> ok
16:32:43 <dolio> It certainly coincides for Functors and Monads, because do { b <- tb ; return (a, b) } should be the same as fmap (a,) tb.
16:33:09 <watermind> dolio: yeap you're right I just noticed that
16:35:58 <kmc_> temoto: Progress Quest
16:36:36 <temoto> osaunders, ^
16:36:44 <temoto> osaunders, your game is great too, btw.
16:37:07 <osaunders> temoto: Have you looked at it?
16:37:19 <osaunders> I mean, what did you like?
16:37:46 <temoto> osaunders, natural language printing of battle log.
16:38:20 <temoto> A friend of mine says that non-interactive games is The Future of gamedev. He expects more of them and gaining more popularity.
16:39:02 <kmc_> my current favorite video game is Coq
16:39:19 <temoto> Bah.. too interactive.
16:39:22 <kmc_> yeah
16:39:30 <SubStack> my favorite game is irssi
16:39:35 <SubStack> it is also highly interactive
16:39:36 <kmc_> multiplayer notepad
16:39:42 <SubStack> basically
16:39:44 <kmc_> #haskell is multiplayer GHCi
16:39:45 * MissPiggy has played every level of Coq now what do I do?
16:39:52 <kmc_> MissPiggy: you solved maths?!?
16:39:53 <SubStack> > fail "game over"
16:39:54 <lambdabot>   No instance for (GHC.Show.Show (m a))
16:39:54 <lambdabot>    arising from a use of `M1285854712...
16:40:14 <kmc_> > fix (error . ("game over: "++))
16:40:15 <lambdabot>   "* Exception: game over: * Exception: game over: * Exception: game over: * ...
16:40:48 <osaunders> kmc_: lol
16:41:10 * MissPiggy laughs "function composition is a degenerate case of the Decorator pattern."
16:41:16 <kmc_> hahaha
16:41:26 <SubStack> MissPiggy: link?
16:41:32 <kmc_> function composition is a degenerate case of dependent function composition
16:41:37 <MissPiggy> http://magicscalingsprinkles.wordpress.com/2010/02/08/why-i-love-everything-you-hate-about-java/
16:41:40 <kmc_> Haskell is a degenerate case of Agda ;)
16:41:53 <kmc_> haha
16:41:59 <kmc_> guess we're all hipsters
16:42:15 <SubStack> hipper than ruby
16:42:17 <osaunders> I can live with that.
16:42:40 <osaunders> I used to hang out with a lot of Rubyists.
16:42:50 <osaunders> I was one myself for a while.
16:43:14 <SubStack> I've done ruby, but I never considered myself a rubyist
16:43:18 <heyhey> what's a non-interactive game?
16:43:29 <heyhey> a simulation?
16:43:41 <osaunders> heyhey: One where the game just plays itself.
16:43:58 <SubStack> MissPiggy: stockholm syndrome, perhaps?
16:43:59 <kmc_> so this is a demonstration that Java code is more modular than Ruby code.  the proof is that the author gives an example of some modular Java code, and some non-modular Ruby code
16:44:41 <osaunders> heyhey: Like this one I wrote: http://codepad.org/Ieq0k0e1
16:44:49 <heyhey> osaunders: so it would be like watching a tennis match?
16:44:52 <MissPiggy> what
16:45:19 <osaunders> heyhey: Yeah, I guess.
16:45:33 <osaunders> I suppose it's not really a game at all then, more spectating.
16:46:48 <osaunders> I'm going to bed now. Bye everyone.
16:49:16 <temoto> MissPiggy, i was reading about Money pattern today. How do you like it compared to that degenerate case of Decorator?
16:49:32 <MissPiggy> I don't even what any of these are
16:49:57 <MissPiggy> I just find it silly to say that composition is a degenate case of something
16:50:02 <temoto> MissPiggy, that's a class with amount and currency and overloaded math operators.
16:50:24 <temoto> I wonder if they have that powerful Function pattern: a class with a single static method.
16:50:30 <dolio> Composition is a degenerate case of functor application, if you ask Cale.
16:50:42 <MissPiggy> llo
16:50:51 <dfdfdf>  
16:50:57 <kmc_> it's not as if you can't use these patterns in languages besides Java or C++
16:51:07 <kmc_> it's just that they take only a few short lines of code, and so are hardly worth remarking on
16:51:44 <kmc_> type Factory obj = Data.Map.Map String (IO obj)
16:52:01 <MissPiggy> llol
16:52:27 <pastorn> do you guys think we'll see something resembling design patterns in haskell eventually?
16:52:37 <copumpkin> hope not
16:52:38 <MissPiggy> I don't even know whwat design patterns are
16:52:58 <arw> blah. design patterns is just another name for "everybody does it that way"
16:53:15 <arw> recursion is a popular design pattern in functional languages :>
16:53:28 <pastorn> hehe
16:53:34 <MissPiggy> so it's just a matter of attitude
16:53:47 <arw> function composition is another one. so in that sense, we already implement them, we just call them something else.
16:53:49 <MissPiggy> everything is potentially a design pattern, it's just that you need 40 people to call it that
16:53:50 <SubStack> haskell has designer patterns
16:54:14 <arw> and of course, we will have different patterns since the language provides different weak and strong points to work around.
16:54:24 <arw> MissPiggy: exactly
16:54:45 <SubStack> pastorn: actually right now I am writing a class for moose-style method modifiers
16:55:01 <pastorn> SubStack: moose-wudda-wudda-what?
16:55:16 <aavogt> I think it's a perl thing
16:55:17 <SubStack> perl has a thing called moose with a lot of nifty ideas
16:55:20 <arw> just look at some typical design patterns and observe how many of them mimic functional programming which object oriented languages usually do very poorly.
16:55:20 <SubStack> like inverted subclassing
16:55:47 <arw> like the "visitor" or the "command" pattern.
16:56:01 <pastorn> what's visitor?
16:56:12 <SubStack> indeed, you don't need patterns when you can just use a function
16:56:14 <aavogt> @type handle
16:56:15 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
16:56:16 <arw> doing something to every member of some collection.
16:56:17 <pastorn> i know bnfc uses it as output for its java and c# cade
16:56:19 <theorbtwo> pastorn: Tree walking, more or less.
16:56:45 <SubStack> Traversable, Foldable
16:56:48 <SubStack> good stuff
16:56:52 <pastorn> ok :)
16:57:05 <theorbtwo> Many times, things that are a "design pattern" in one language are "what, that's trivial", or "why would you want to do *that*" in another.
16:57:10 * SubStack is calling this thing "Hookable"
16:57:28 <aavogt> SubStack: those are a pain to work with because of the import conflicts
16:57:42 <SubStack> true enough
16:57:50 * SubStack hopes haskell' sorts that out
16:58:08 <aavogt> and at least the mtl exports a bunch of mapM , forM etc. that also conflict
16:58:32 <aavogt> so if you use a bunch of monad transformers in the same module it's a lot of work
17:02:03 <Rotaerk> imo a design pattern is something that's not a built in feature of a language, i.e. a pattern in how the language is used
17:02:20 <Rotaerk> hard to generalize the term though because in one language it may be directly supported
17:02:45 <aavogt> loops are a design pattern?
17:02:52 <arw> yes
17:03:04 <Rotaerk> I'd say they are in a language without loop support, and just raw goto's
17:03:06 <arw> in languages like assembler, certainly.
17:03:06 <aavogt> or only if all you get are GOTOs
17:03:07 <Rotaerk> but otherwise it's not
17:03:41 <kmc_> what "design pattern" seems to mean in the C++ community is "a standardized workaround for a language flaw"
17:03:47 <Rotaerk> lol
17:03:55 <kmc_> something the compiler should do for you, but instead you have to learn how to write it out by rote
17:04:05 <kmc_> "design pattern" books are books of macros which are interpreted by a human
17:04:34 <kmc_> (as macro expanders go, humans are very expensive)
17:04:40 <dankna> chortle.
17:04:43 <dankna> quite.
17:04:50 <kmc_> i'll chortle you
17:04:58 <dankna> you cannot!  it is intransitive.
17:17:36 <RayNbow> :t flip
17:17:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:17:52 <shepheb> Maybe Double values sound like commercials. Just 19.97
17:18:07 <RayNbow> @src flip
17:18:07 <lambdabot> flip f x y = f y x
17:18:19 <RayNbow> :t let flip f x y = f y x in flip
17:18:20 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t1 -> t -> t2
17:18:36 <RayNbow> there is some disagreement :p
17:19:33 <aavogt> @type \f x -> fmap ($ x) f
17:19:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:19:44 <aavogt> @type \f x ->  ($ x) . f
17:19:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
17:19:58 <RayNbow> @djinn (Functor f) => f (a -> b) -> a -> f b
17:19:59 <lambdabot> -- f cannot be realized.
17:20:09 * RayNbow checks djinn-env
17:20:21 <aavogt> it doesn't know about functor
17:20:28 <RayNbow> <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
17:20:47 <RayNbow> it seems it actually does
17:20:50 <aavogt> @djinn Maybe (a -> b) -> a -> Maybe b
17:20:50 <lambdabot> f a b =
17:20:50 <lambdabot>     case a of
17:20:50 <lambdabot>     Nothing -> Nothing
17:20:50 <lambdabot>     Just c -> Just (c b)
17:22:11 <aavogt> but I don't think flip is a good name for the generalized flip
17:22:36 <aavogt> maybe it should be called `flap'
17:27:07 * RayNbow nods
17:28:23 <notallama> perhaps a silly question, but is there an if function defined somewhere? or just that weird 'if then else' thing?
17:28:50 <RayNbow> @hoogle if'
17:28:50 <lambdabot> No results found
17:28:52 <RayNbow> hmm
17:29:27 <luqui> :t if'
17:29:28 <lambdabot> Not in scope: `if''
17:29:40 <luqui> could have sworn it was in Caleskell
17:29:45 <RayNbow> http://hackage.haskell.org/packages/archive/utility-ht/latest/doc/html/Data-Bool-HT.html#v:if&apos;
17:29:52 <luqui> :t bool
17:29:53 <lambdabot> Not in scope: `bool'
17:31:06 <copumpkin> nope
17:31:17 <RayNbow> <ski> @tell Cale you should define `flip :: Functor f => f (a -> b) -> (a -> f b); flip f a = fmap ($ a) f' in Caleskell
17:31:37 * RayNbow found the culprit :p
17:31:39 <Sgeo_> :t unsafeSolveHaltingProblem
17:31:40 <lambdabot> Not in scope: `unsafeSolveHaltingProblem'
17:32:58 <Sgeo_> What prevents someone from submitting malicious code to Hackage. I mean, obviously there's a  limit to possible maliciousness unless in the IO monad, but still
17:33:45 <aavogt> you need to get a hackage account
17:34:09 <luqui> Sgeo_, there is no such limit
17:34:36 <Sgeo_> luqui, code outside of the IO monad can't delete someone's HD.
17:34:40 <Sgeo_> erm, erase
17:34:44 <ben> Yes it can
17:34:45 <luqui> @hoogle IO a -> a
17:34:45 <lambdabot> Foreign unsafePerformIO :: IO a -> a
17:34:46 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
17:34:46 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
17:34:48 <arw> unsafePerformIO?
17:34:56 <Sgeo_> ..oh right
17:35:16 <luqui> I would *like* it if what you said were true :-)
17:35:27 <SubStack> bwahaha the types work
17:35:30 <kmc_> and there are plenty of other ways to break out
17:35:32 <SubStack> for this crazy hookable thing
17:35:33 <aavogt> haha, but you don't know when or even how many times it will be run
17:35:34 <arw> hm. some sandbox-mode would be nice at times.
17:35:36 <Sgeo_> kmc_, other ways?
17:35:39 <kmc_> sure
17:35:48 <SomeRandomG> COOKIES ?DCC SEND STARTKEYLOGGER'
17:35:54 <copumpkin> @where ops
17:35:55 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
17:35:57 <kmc_> unsafeCoerce, Foreign.Storable, etcg
17:35:57 <SubStack> -_-
17:36:00 <kmc_> etc.*
17:36:08 <luqui> wtf why?
17:36:14 <copumpkin> bad routers
17:36:16 <copumpkin> sad
17:36:21 <Sgeo_> What just happened?
17:36:21 <kmc_> you can do totally unsafe C-style pointer manipulation in Haskell if you like
17:36:23 <luqui> no i mean why does SomeRandomG do that
17:36:35 <ben> How do you use unsafeCoerce to delete people's HD?
17:36:53 <ben> Do you coerce IO a to () -> (a, ()) instead of the RealWorld# thing?
17:37:06 <kmc_> or even to what it actually wraps
17:37:24 <kmc_> in GHC IO is a newtype, it's guaranteed (!) that unsafeCoerce will safely coerce you to the underlying type
17:37:25 <kmc_> @src IO
17:37:26 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:37:50 <Sgeo_> That # stuff confuses me
17:37:57 <luqui> just ignore it
17:38:00 <pikhq> Sgeo_: Unboxed.
17:38:02 <ben> Do you ordinarily have access to a State# RealWorld?
17:38:06 <kmc_> you can make one up
17:38:11 <kmc_> that's how unsafePerformIO is implemented
17:38:13 <ben> @src State#
17:38:13 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:38:24 <kmc_> State# a has no meaningful runtime representation
17:38:29 <ben> I thought unsafePerformIO imported the GHC internal modules
17:38:33 <kmc_> sure it does
17:38:37 <kmc_> that IO newtype is in a GHC internal module
17:38:51 <pikhq> ben: State# being among them.
17:39:07 <ben> Yeah, I mean-- so I cannot make one up with unsafeCoerce, I have to use GHC's modules
17:39:24 <pikhq> That's just because the constructor isn't exposed.
17:39:34 <kmc_> unsafeCoerce lets you get around the problem of not having the constructor
17:40:29 <ben> kmc_: But I do not have the type name either
17:40:50 <kmc_> define a new type with the same representation and coerce to it
17:41:05 <ben> Right
17:41:23 <kmc_> Sgeo_: a GHC extension allows one to use # in identifier names.  This carries no intrinsic meaning but is often used along with unboxed primitive stuff
17:41:45 <kmc_> Sgeo_: separately, a GHC extension enables the syntax (# a, b, c, ... #) for an "unboxed tuple"
17:41:57 <interferon> @pl compare (date a) (date b)
17:41:57 <lambdabot> compare (date a) (date b)
17:42:14 <Sgeo_> I guess I should learn what boxing means in Haskell
17:42:15 <kmc_> And of course you can write unsafePerformIO using Foreign.Storable, since you can easily write unsafeCoerce in terms of it
17:42:15 <interferon> @pl \a b -> compare (date a) (date b)
17:42:16 <lambdabot> (. date) . compare . date
17:42:24 <Sgeo_> In J it means one thing, in C# it means something similar
17:42:30 <kmc_> Sgeo_: it doesn't really mean anything in Haskell. it means something in GHC's implementation of Haskell
17:42:31 <Sgeo_> Well, not really
17:42:36 <pikhq> Sgeo_: It's very much an implementation detail.
17:42:42 <Sgeo_> Ah
17:42:57 <kmc_> it means that the value is represented in memory by a pointer into the memory-managed heap, and that the thing on the end of that pointer has a certain regular structure
17:43:07 <kmc_> such that code can use them uniformly
17:43:08 <ben> (The gimmick about (# ... #) was that you can only ever return it, and not pass it to functions?)
17:43:18 <pikhq> "Boxing" just means that the type is wrapped in some sort of structure, and "unboxed" just means that it's not wrapped in such a structure.
17:43:21 <dolio> Yes.
17:43:24 <kmc_> ben: yeah, it's used essentially to have functions return multiple arguments without overhead
17:44:30 <pikhq> So, the difference between "struct {enum tag type;int num}" and "int", to put it in C terms.
17:44:32 <pikhq> (this presumes a fairly simplistic method of boxing)
17:44:50 <pikhq> Well, "struct {enum tag type;int num}*"...
17:44:53 <kmc_> yeah
17:45:00 <pikhq> You're *not* just passing around boxed structs. :P
17:45:10 <kmc_> :k (->)
17:45:12 <lambdabot> ?? -> ? -> *
17:45:25 <Saizan> you don't really have a tag for the type
17:45:38 <kmc_> ?? is * `union` #.  ? is ?? `union` (#)
17:45:38 <lambdabot> Plugin `compose' failed with: Unknown command: ""
17:45:39 <pikhq> Saizan: Shush you.
17:45:40 <pikhq> :P
17:46:07 <kmc_> so that says in a very cryptic way that functions can take boxed or unboxed args (but not boxed tuples), and can return any of those three kinds of type
17:46:12 <Saizan> i mean, with static typing there's no need for type tags
17:46:52 <kmc_> you still need a uniform way to force the value, or to traverse it for GC, etc.
17:47:04 <kmc_> which in GHC is handled by storing some pointers to code at predetermined offsets in the structure
17:47:49 <kmc_> the info table pointers of the basic STG machine are like tags, but they're not inspected or compared during normal evaluation, only followed
17:48:06 <pikhq> Saizan: Just an example of boxing in general.
17:48:30 <Saizan> they still don't represent the type :) but yeah
17:48:45 <kmc_> that's true, different types with the same closure layout might share an info pointer
17:49:14 <moshisushi> hello! if i use pairs of Ints to represent a binary relation, can i get the 'equivalence classes' of that relation  in some easy way in haskell? that is, if i have the relations (1,2), (2,3), (4,5) i would get [[1,2,3], [4,5]]
17:49:16 <kmc_> i wonder if eventually Typeable will be replaced with something more direct through the info pointer
17:49:25 <kmc_> :t groupBy
17:49:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:49:33 <kmc_> :t groupBy ((==) `on` fst)
17:49:35 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
17:49:44 <kmc_> :t map (map snd) . groupBy ((==) `on` fst)
17:49:45 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[b]]
17:50:11 <kmc_> moshisushi: ^^^^
17:50:24 <kmc_> or perhaps that's not what you wanted
17:51:42 <kmc_> you want the connected components of this undirected graph?
17:52:02 <moshisushi> kmc_: that's one way of viewing it, yeah
17:52:17 <moshisushi> if you view the pairs as edges
18:09:51 <ddarius> Ï€_0 âŠ£ D âŠ£ Ob âŠ£ I
18:10:13 <drdr> ...
18:10:30 * drdr screams
18:11:55 <mm_freak_> hmm
18:12:01 <mm_freak_> very interesting powerset function
18:12:23 <mm_freak_> > let powerset = filterM (const [True, False]) in powerset [1,2,3]
18:12:24 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:12:28 * djahandarie sighs
18:14:01 <osfameron> that's a write-only definition if I ever saw one :-)
18:14:16 <osfameron> :t filterM
18:14:17 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:14:30 * djahandarie doesn't feel like having the same discussion as last time
18:14:35 <mm_freak_> well, not if you understand the list monad =)
18:14:54 <osfameron> oh?
18:15:14 <osfameron> list monad + pointless + monadic stuff in general, surely
18:15:15 <mm_freak_> but you're rightâ€¦  you can shock/fascinate beginners with such code
18:15:37 <mm_freak_> that's something Cale could have come up with
18:15:53 <luqui> this is write only:
18:15:55 <luqui> > fmap fix return 42
18:15:56 <lambdabot>   42
18:16:07 * osfameron doesn't know where to begin to understand the powerset definition
18:16:25 <mm_freak_> osfameron: start at looking how the filterM function behaves for the list monad
18:16:28 <luqui> osfameron, filter uses a monadic action to decide whether to keep or throw away an element
18:16:41 <Sgeo_> > do { a <- [1,2,3]; return (a - a) }
18:16:42 <lambdabot>   [0,0,0]
18:16:45 <luqui> osfameron, list monad is about nondeterminism -- a computation can select multiple results
18:16:54 <mm_freak_> osfameron: the filterM function is like filter, but the result of the predicate is in the particular monad, too
18:16:55 <Sgeo_> > do { a <- [1,2,3]; b <- [1,2,3] return (a - b) }
18:16:56 <lambdabot>   <no location info>:
18:16:56 <lambdabot>      The last statement in a 'do' construct must be an ...
18:16:58 <luqui> so... the filter just selects both keep and throw away :-)
18:17:03 <Sgeo_> > do { a <- [1,2,3]; b <- [1,2,3]; return (a - b) }
18:17:04 <lambdabot>   [0,-1,-2,1,0,-1,2,1,0]
18:17:16 <mm_freak_> so you can have the predicate return both True and False at the same time, since you're in the list monad
18:17:23 <mm_freak_> list monad = nondeterminism
18:18:24 <mm_freak_> > filterM (\x -> [x `mod` 10 == 0, x `mod` 10 == 1]) [1..10]
18:18:25 <lambdabot>   [[10],[],[10],[],[10],[],[10],[],[10],[],[10],[],[10],[],[10],[],[10],[],[1...
18:18:45 <mm_freak_> > nub $ filterM (\x -> [x `mod` 10 == 0, x `mod` 10 == 1]) [1..10]
18:18:46 <lambdabot>   [[10],[],[1,10],[1]]
18:18:58 <osfameron> ah.  I get a sense for what that does intuitively
18:19:06 <Sgeo_> > do { a <- [1,2..]; b <- [0]; return (a * b) }
18:19:07 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:19:09 <osfameron> don't think I'd work out what 'const' is doing there gthough
18:19:23 <aavogt> it does nothing
18:19:29 <osfameron> I also can't read the type of filterM (or indeed anythingM)
18:19:33 <aavogt> @src const
18:19:33 <lambdabot> const x _ = x
18:19:36 <mm_freak_> osfameron: it disregards the list element and returns True and False always
18:19:58 <mm_freak_> look at the type signature for filterM in the list monad
18:20:07 <mm_freak_> :t filterM
18:20:08 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:20:21 <mm_freak_> (a -> [Bool]) -> [a] -> [[a]]
18:20:55 <mm_freak_> if m = [], then m a = [a]
18:21:29 <mm_freak_> btw, better start with easier functions like sequence and replicateM
18:21:38 <mm_freak_> > replicateM 3 "01"
18:21:39 <lambdabot>   ["000","001","010","011","100","101","110","111"]
18:21:53 <osfameron> eeek!
18:22:19 <Sgeo_> > nub [0,0..]
18:22:23 <lambdabot>   mueval-core: Time limit exceeded
18:22:52 <aavogt> > do x <- ['0','1']; y <- ['0','1']; z <- ['0','1']; [x,y,z]
18:22:53 <lambdabot>   "000001010011100101110111"
18:23:00 <aavogt> > do x <- ['0','1']; y <- ['0','1']; z <- ['0','1']; return [x,y,z]
18:23:01 <lambdabot>   ["000","001","010","011","100","101","110","111"]
18:23:09 <mm_freak_> > sequence ["ab", "c", "def", "g"]
18:23:10 <lambdabot>   ["acdg","aceg","acfg","bcdg","bceg","bcfg"]
18:23:20 <mm_freak_> you can understand this very easily =)
18:23:28 <mm_freak_> replicateM is just a special case of sequence
18:23:29 <Philonous1> filterM predicate list = for every element in list execute predicate and keep the element if predicate returned true. List as as a monad can be read as "try every element". So filterM (const [True, False]) list = for every element in list, try keeping and try droping it, and return all the results you thusly get.
18:25:43 <Philonous1> The only confusing thing here is that in [True, False] the list is used as a monad, but the list you give as an argument is just a plain list
18:26:51 <Sgeo_> :t sequence
18:26:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:27:19 <aavogt> @type fmap (map fst . filter snd) . Data.Traversable.traverse (id &&& ?p)
18:27:20 <lambdabot> forall a a1. (Monoid a1, ?p::a1 -> (a, Bool)) => [a1] -> (a1, [a])
18:27:21 * Sgeo_ scratches his head a little
18:28:00 <aavogt> @type fmap (map fst . filter snd) . Data.Traversable.traverse (\x -> (,) x <$> ?p x)
18:28:01 <lambdabot> forall (f :: * -> *) a. (Applicative f, ?p::a -> f Bool) => [a] -> f [a]
18:28:48 <mm_freak_> > sequence (replicate 3 "01")
18:28:49 <lambdabot>   ["000","001","010","011","100","101","110","111"]
18:28:50 <aavogt> yet another function using Monad when Applicative suffices?
18:29:29 <mm_freak_> (\x y -> [x,y]) <$> "01" <*> "01"
18:29:38 <mm_freak_> > (\x y -> [x,y]) <$> "01" <*> "01"
18:29:39 <lambdabot>   ["00","01","10","11"]
18:30:09 <mm_freak_> well, the monadic interface seems to be more convenient, but yes, Applicative would suffice
18:30:10 <pikhq> @pl \x y -> [x,y]
18:30:10 <lambdabot> (. return) . (:)
18:30:23 <mm_freak_> > (\x y z -> [x,y,z]) <$> "01" <*> "01" <*> "01"
18:30:24 <lambdabot>   ["000","001","010","011","100","101","110","111"]
18:30:27 <pikhq> That's... Kinda ugly, lambdabot.
18:30:48 <aavogt> @pl \a b c d e f g h -> [a,b,c,d,e,f,g,h]
18:30:50 <lambdabot> (. ((. ((. ((. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) .
18:30:50 <lambdabot> (.) . (.) . (:)
18:30:56 <mm_freak_> @pl \x y -> x:y:[]
18:30:56 <lambdabot> (. return) . (:)
18:31:18 <mm_freak_> @pl \y x -> x:y:[]
18:31:19 <lambdabot> flip (:) . return
18:32:39 <mm_freak_> @pl \x -> (x:) . (:[])
18:32:39 <lambdabot> (. return) . (:)
18:33:18 <aavogt> @pl (:[])
18:33:19 <lambdabot> return
18:33:21 <pikhq> I don't think you're going to fool Lambdabot into giving something nicer that easily.
18:33:45 <kmc> @pl \x y z -> [x,y,z]
18:33:46 <lambdabot> (. ((. return) . (:))) . (.) . (:)
18:34:30 <mm_freak_> > (flip (.) (:[]) . (:)) 1 2
18:34:31 <lambdabot>   [1,2]
18:34:59 <mm_freak_> ok, lambdabot is smarter than me
18:35:07 <Veinor> (:[])
18:35:34 <mm_freak_> there is something much more funny than (:[])
18:35:44 <Veinor> (.) . (.)?
18:36:30 <mm_freak_> > drop 27 . map head $ cake
18:36:31 <lambdabot>   "TOOTOOTASCIICAT"
18:36:46 <mm_freak_> > splitAt 7 . drop 27 . map head $ cake
18:36:47 <lambdabot>   ("TOOTOOT","ASCIICAT")
18:40:02 <kmc> ha ha, boobs
18:42:05 <dibblego> @type let (âˆ˜âˆ˜) = fmap . fmap in sequence âˆ˜âˆ˜ sequence
18:42:07 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m, Monad f) => [f (m a)] -> f (m [a])
18:43:34 <mm_freak_> :t fmap . fmap
18:43:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:44:15 <mm_freak_> d'oh
18:44:24 <kmc> :t let (..) = (.) . (.) in (..)
18:44:25 <lambdabot> parse error on input `..'
18:44:27 <kmc> :(
18:45:01 <mm_freak_> :t let (...) = (.).(.) in (...)
18:45:02 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:45:34 <mm_freak_> seems like ".." is reserved for Enum stuff
18:46:05 <sshc> "Run the program with +RTS -N2 to use 2 threads, for example. You should use a -N value equal to the number of CPU cores on your machine (not including Hyper-threading cores)."
18:47:26 <sshc> so it's impossible to create a threaded Haskell program that will actually run on multiple cores without any arguments passed on the command line to the program itself?
18:48:14 <kmc> you can set them in an environment variable
18:48:15 <mm_freak_> sshc: forkOS should work
18:48:22 <kmc> don't think so
18:48:47 <mm_freak_> well, it does in GHCi
18:48:49 <kmc> forkOS creates a bound Haskell thread, which is not the same kind of thing as an OS thread
18:48:55 <kmc> really?
18:49:20 <Philonous1> You can write a C wrapper that sets the number of threads in the haskell runtime
18:50:00 <kmc> yeah you can bake in options
18:50:02 <kmc> http://haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
18:50:24 <mm_freak_> it even complains, when i create too many threads
18:50:26 <mm_freak_> > replicateM_ 2000 $ forkOS (threadDelay 1000000)
18:50:26 <mm_freak_> *** Exception: user error (Cannot create OS thread.)
18:50:27 <lambdabot>   Not in scope: `forkOS'Not in scope: `threadDelay'
18:50:30 <kmc> i wish there were a Haskell-source pragma to do it though
18:50:57 <sshc> shouldn't GHC automatically determine that?
18:51:12 <sshc> passing on the command line is usually better than setting environment variables
18:51:32 <mm_freak_> anyway, the haskell RTS and libraries are designed to handle threading for you, so you shouldn't use forkOS
18:51:46 <sshc> is it possible to run on multpile cores autamatically?
18:52:04 <mm_freak_> don't think so without forkOS or some hack
18:52:04 <kmc> i really do not think that forkOS spawns an OS thread
18:52:08 <notallama> i just blogged about haskell. managed to refrain from writing a monad tutorial :p the post could probably use some fixing up/better examples, though. http://harrisonclarke.wordpress.com/
18:52:17 <sshc> i.e., by not requiring the user to pass extra command line arguments or to set environment
18:52:39 <dolio> The rts hook is the way.
18:52:48 <kmc> the documentation of Control.Concurrent and the original "Concurrent Haskell" paper both say that forkOS does not spawn an OS thread
18:52:54 <sshc> since it's not yet, will it ever be able to do that?
18:52:55 <kmc> it spawns a "bound thread" which is a subtype of Haskell thread
18:53:00 <kmc> the meaning of which i can explain if desired
18:53:22 <kmc> sshc, GHC 6.12's RTS supports "-N" with no argument, which will detect the number of cores
18:54:05 <sshc> kmc: that's good, but can that be done in the source or by the compiler?
18:54:17 <kmc> it can be done in C source that you compile into your Haskell program
18:54:19 <dolio> It can be done via the RTS hook, as mentioned.
18:54:30 <mm_freak_> kmc: i just checked
18:54:34 <mm_freak_> it does spawn OS threads
18:54:38 <sshc> dolio: RTS hook?
18:54:39 <kmc> mm_freak_, how did you check?
18:54:41 * sshc googles
18:54:42 <mm_freak_> that's what its name suggests after all
18:54:52 <mm_freak_> kmc: i spawned 100 threads and looked at the process table =)
18:54:52 <dolio> See the link kmc posted 5 minutes ago.
18:55:12 <kmc> mm_freak_, i think at the very least, the C.C API does not require that it spawn OS threads
18:55:47 <kmc> mm_freak_, how did you inspect the process table? also which ghc version and OS?
18:56:13 <mm_freak_> that's reasonable
18:56:18 <mm_freak_> the docs don't require it
18:56:27 <mm_freak_> ps x -L | grep ghc
18:56:35 <mm_freak_> (using ghci -threaded)
18:56:49 <mm_freak_> The Glorious Glasgow Haskell Compilation System, version 6.10.4
18:56:55 <kmc> mm_freak_, yeah, i see it too
18:57:20 <mm_freak_> well
18:57:24 <mm_freak_> it's a bound thread
18:57:42 <kmc> also i see "Warning: -debug, -threaded and -ticky are ignored by GHCi
18:57:42 <kmc> "
18:58:09 <mm_freak_> so if you forkOS while another such thread is running, you're guaranteed to get another OS thread
18:58:47 <mm_freak_> you're right, i overlooked that warning, but it works nonetheless (which is somewhat surprising)
18:58:55 <kmc> mm_freak_, yeah. i see
18:59:01 <kmc> they are OS-level threads
18:59:12 <kmc> but i don't think they will participate in Haskell evaluation
18:59:33 <mm_freak_> what do you mean?
18:59:36 <kmc> i think they just hang out until an FFI call is requested
19:00:03 <mm_freak_> hmm
19:00:07 * kmc tests
19:01:28 <mm_freak_> > do v <- newEmptyMVar; forkOS (putMVar v (3^5000000 `mod` 103)); takeMVar v >>= print
19:01:29 <lambdabot>   Not in scope: `newEmptyMVar'Not in scope: `forkOS'Not in scope: `putMVar'No...
19:01:31 <mm_freak_> 13
19:02:22 <kmc> mm_freak_, i forkOS one hundred threads that do some intense numerical computation
19:02:25 <kmc> and it only uses one of my cores
19:02:40 <mm_freak_> interesting
19:05:30 <kmc> mm_freak_, hmm, but it doesn't use two cores even with +RTS -N2
19:05:49 <kmc> oh it's GCing a lot
19:07:58 <mm_freak_> maybe your calculations are too small
19:08:23 <kmc> i'm asking for ackermann(4, 4) :D
19:08:44 <mm_freak_> don't know that one =)
19:08:53 <kmc> it grows faster than any primitive recursive function
19:09:10 <kmc> wikipedia says that A(4, 4) = 2 ^ (2 ^ (2 ^ 65536)) - 3
19:11:24 <lispy|web> why is Prelude's sort so memory hungry?
19:11:35 <djahandarie> nom nom nom
19:11:40 <lispy|web> Are there alternative sorts with better performance?
19:12:06 <pikhq> @src sort
19:12:07 <lambdabot> sort = sortBy compare
19:12:15 <pikhq> @src sortBy
19:12:16 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
19:12:24 <lispy|web> I was looking in Knuth and seeing that he defines some "external" sorts
19:12:28 <pikhq> @src insertBy
19:12:29 <lambdabot> insertBy _   x [] = [x]
19:12:29 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
19:12:29 <lambdabot>                                  GT -> y : insertBy cmp x ys'
19:12:29 <lambdabot>                                  _  -> x : ys
19:12:31 <lispy|web> Which have the nice property that the sorting happens on disk
19:12:40 <pikhq> There's your answer, I guess.
19:13:01 <lispy|web> yeah, merge sort needs 2x the memory?
19:13:12 <lispy|web> I want an inplace quicksort! ;)
19:13:33 <lispy|web> (not really, but a sort that can stream in constant space would be perfect)
19:13:37 <mm_freak_> kmc: GHC has only about 10 OS threads for the following code
19:13:43 <mm_freak_> do v <- newEmptyMVar; replicateM_ 100 (forkOS $ putMVar v (sort [1000000,999999..0])); replicateM 100 (takeMVar v) >>= print . map length
19:13:54 <kmc> mm_freak_, with what RTS options?
19:14:01 <mm_freak_> none
19:14:18 <lispy|web> mm_freak_: why forkOS?
19:14:27 <lispy|web> mm_freak_: if you want lots of cheap threads you need forkIO
19:14:38 <mm_freak_> lispy|web: because we're testing when forkOS spawns real OS threads
19:14:46 <lispy|web> ah
19:14:49 <kmc> okay i fixed my test case
19:15:03 <kmc> GHC's forkOS does spawn OS threads, but they don't participate in Haskell evaluation
19:15:24 <mm_freak_> i get only 10 threads even though the code launches 100
19:15:48 <kmc> i get ~150% CPU usage with +RTS -N2 and 100% with no RTS options.  independent of using forkIO or forkOS
19:15:58 <mm_freak_> i see
19:16:01 <ddarius> Liskni_si: There is an external sort on Hackage.
19:16:05 <ddarius> lispy|web:
19:16:25 <lispy|web> ddarius: cool, I think I probably just stumbled on the Haskell-cafe thread for it :)
19:16:30 <kmc> i wish forkOS had a different name
19:16:33 <kmc> like forkIOBound
19:16:47 <ddarius> Eat Forkios!
19:17:30 <mm_freak_> well, i wish a lot of renames in haskell =)
19:17:33 <djahandarie> I knew it! The Haskell Symposium is taking coperate bribes!!!
19:17:41 <djahandarie> corperate*
19:17:56 <djahandarie> Fetch me my bib
19:18:05 <ddarius> corporate
19:18:28 <mm_freak_> fmap â†’ map, mappend â†’ (++), forkIO â†’ fork, â€¦
19:22:46 <Sgeo_> Why is unsafeInterleaveIO unsafe?
19:23:29 <c_wraith> things can happen behind the scenes.  like file descriptors getting closed by non-interleaved IO
19:23:33 <ddarius> unsafeInterleaveIO = return . unsafePerformIO -- roughly
19:24:25 <ddarius> let x = unsafePerformIO m  ~~ x <- unsafeInterleaveIO m
19:24:36 <Sgeo_> ~~?
19:24:41 <Sgeo_> :t (~~)
19:24:42 <lambdabot> Not in scope: `~~'
19:25:30 <ddarius> Roughly equivalent
19:26:00 <ddarius> (Actually, they are almost identical in a do-block...)
19:30:01 <Guest74600> hey Haskellers, I have a question about defining monads
19:30:23 <Guest74600> from what I've been able to see from example code
19:30:32 <Guest74600> you do something like
19:30:44 <Guest74600> instace Monad Foo where
19:30:57 <Guest74600> and then you define the >>= and return functions
19:31:02 <Guest74600> is that all there is to it?
19:31:10 <ddarius> Yes.
19:31:16 <Guest74600> ok, cool
19:31:20 <Guest74600> then the second part
19:31:40 <Guest74600> what exactly is the >>= function about?
19:32:08 <ddarius> Note that (>>=) and return are methods of the type class Monad.  You are defining the methods in the where block of the instance declaration, not just arbitrary functions elsewhere.
19:32:29 <Guest74600> right
19:32:30 <mm_freak_> if you have a monadic computation, which needs a parameter from another monadic computation, (>>=) is the way to go
19:32:50 <mm_freak_> > Just 3 >>= \x -> Just (x+1)
19:32:51 <lambdabot>   Just 4
19:33:05 <luqui> =<< is the way to go
19:33:09 <Sgeo_> > Just 3 >>= \x -> Nothing
19:33:10 <lambdabot>   Nothing
19:33:10 <luqui> >>= can suck it
19:33:19 <luqui> :-P
19:33:23 <ddarius> @src (=<<)
19:33:24 <lambdabot> f =<< x = x >>= f
19:33:25 <Sgeo_> luqui, how would you mix =<< and do notation?
19:33:38 <luqui> Sgeo_, my data flows top to bottom, right to left
19:33:42 <Guest74600> does (>>=) get called when running stuff in a do statement?
19:33:55 <luqui> so I never use >>=.  if i have two actions on the same line, I use =<<.  on separate lines, I use do notation.
19:34:03 <mm_freak_> Guest74600: yes, whenever you use the <- construct
19:34:06 <pikhq> Guest74600: A do statement is simply sugar for usage of >>=.\
19:34:06 <idnar> @undo do x <- xs; y <- ys; f x y
19:34:07 <lambdabot> xs >>= \ x -> ys >>= \ y -> f x y
19:34:13 <mm_freak_> do x <- c; y = c >>= \x -> c
19:34:41 <notallama> (=<<) is basically a function that turns a (a -> m b) into a (m a -> m b). and (>>=) is flip (=<<)
19:35:07 <sshc> :t (=<<)
19:35:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:35:12 <sshc> :t (<<=)
19:35:13 <lambdabot> Not in scope: `<<='
19:35:48 <mm_freak_> Guest74600: a lot of monads are much easier to understand, if you start with Functor and Applicative
19:36:09 <Guest74600> cool, thanks
19:36:33 <Guest74600> I'm trying to define a monad that handles stack operations (for a Forth interpreter)
19:36:51 <luqui> hijack state?
19:36:55 <Guest74600> but I should probably try using the builtin ones first
19:36:58 <mm_freak_> sounds like a state monad
19:37:13 <pikhq> Definitely state.
19:38:25 <jmcarthur> i love how the monadplus documentation is wrong
19:38:41 <jmcarthur> it says mzero is an identity and then... oh wait i'm dumb
19:38:42 <Guest74600> how would I go about using the state monad?
19:38:56 <Guest74600> or where should I go to read about it?
19:39:02 <jmcarthur> i saw mzero >>= f == mzero and though "but that's not an identity"
19:39:09 <jmcarthur> but of course mzero is an identity with mplus
19:39:12 <mm_freak_> Guest74600: _a_ state monad, not _the_ state monad =)
19:39:18 <mm_freak_> you're using one all the time:  IO
19:39:44 <c_wraith> Is there any way I can get :t in ghci to tell me the qualified type?
19:39:46 <Guest74600> Aha. That would explain things
19:39:48 <luqui> Guest74600,  http://book.realworldhaskell.org/read/monads.html
19:39:53 <jmcarthur> IO is a bad state monad
19:40:01 <jmcarthur> the state can change between actions
19:40:05 <luqui> agreed.
19:40:14 <luqui> and what kind of state has fork?
19:40:18 <mm_freak_> not in an uncontrolled manner
19:40:43 <mm_freak_> between return 1 and return 2 the state cannot change
19:40:46 <luqui> mm_freak_, just because IO has state, does not mean it resembles Control.Monad.State.
19:40:47 <jmcarthur> luqui: well, fork by itself isn't so bad
19:40:55 <jmcarthur> luqui: it's the "preemptive" part that is
19:41:00 <mm_freak_> or better:  it makes no observable difference
19:41:13 <mm_freak_> luqui: but it does in a way
19:41:24 <luqui> Control.Monad.State is *deterministic*, pure, state-passing computations
19:41:32 <mm_freak_> so is IO
19:41:33 <jmcarthur> luqui: i've written a concurrency transformer that adds fork purely, but it requires that you use yield for concurrency
19:41:36 <luqui> IO does many things outside that realm
19:41:58 <pikhq> mm_freak_: No. IO can be pretty darned non-deterministic.
19:42:13 <pikhq> And IO is anything but externally pure, unlike State.
19:42:26 <c_wraith> Is Data.ByteString.Lazy.concat as lazy as I'd hope?
19:42:52 <mm_freak_> IO is deterministic and pureâ€¦  it just models that nondeterministic, impure world
19:42:55 <luqui> c_wraith, how lazy do you hope it is?
19:43:02 <jmcarthur> surely it just concatenates the lists of chunks...
19:43:09 <c_wraith> that's what I hoped
19:43:15 <pikhq> mm_freak_: Its execution is neither, though.
19:43:24 <luqui> mm_freak_, see "the C language is purely functional" for another perspective
19:43:41 <pikhq> Whereas State is pure even when you execute it.
19:43:43 <m0rphix> Whats up everyone?
19:44:06 <mm_freak_> luqui: i don't understand what's wrong with IO
19:44:15 <mm_freak_> pikhq: sure
19:44:21 <luqui> mm_freak_, did I say IO was wrong?
19:44:24 <jmcarthur> mm_freak_: it models something imperative, but the model doesn't fit the real world
19:44:28 <mm_freak_> there is no runIO, but that's the point of IO =)
19:44:31 <luqui> It is just entirely unlike Control.Monad.State.  not wrong.
19:44:40 <mm_freak_> jmcarthur: why not?
19:44:42 <jmcarthur> *that* model doesn't anyway
19:44:50 <jmcarthur> not as a state monad, i mean
19:45:02 <jmcarthur> because the State monad doesn't change its state when you aren't looking
19:45:24 <mm_freak_> neither does IO
19:45:31 <jmcarthur> what good is a state monad if your state is basically "i have no idea what the hell my state is"?
19:45:51 <kmc> haha
19:46:00 <mm_freak_> getChar resembles modify + get
19:46:04 <mm_freak_> or rather gets
19:46:05 <kmc> @remember jmcarthur what good is a state monad if your state is basically "i have no idea what the hell my state is"?
19:46:05 <lambdabot> It is stored.
19:46:06 <syntaxglitch> would that be a "state of confusion monad"
19:46:20 <jmcarthur> heh
19:46:41 <mm_freak_> the state never changes between return 1 and return 2
19:46:57 <mm_freak_> but it can change between getChar and getChar, because getChar modifies the state
19:47:22 <pikhq> mm_freak_: It can change during getChar.
19:47:41 <pikhq> forkIO is a real thing, you know.
19:47:44 <jmcarthur> mm_freak_: it can also change between getChar and getChar because the pipe is closed
19:47:57 <syntaxglitch> treating IO's "state" as "the entire world" can't the state change arbitrarily during any operation that takes nonzero time to execute?
19:48:03 <mm_freak_> jmcarthur: that's your interpretation
19:48:04 <jmcarthur> or because the missiles launched due to another process
19:48:05 <dolio> It can change between return 1 and return 2 if your thread gets preempted and some other thread changes a mutable cell.
19:48:08 <pikhq> syntaxglitch: Why yes, yes it can.
19:48:35 <jmcarthur> mm_freak_: my point is that the IO monad fails to capture concurrency in any accurate fashion
19:48:56 <jmcarthur> mm_freak_: why do i not always get the same value from an MVar that i write to it?
19:49:20 <dolio> IO doesn't fail to capture it. RealWorld -> (RealWorld, a) does.
19:49:25 <mm_freak_> jmcarthur: because takeMVar changes the state
19:49:32 <jmcarthur> dolio: okay, i agree
19:49:38 <jmcarthur> mm_freak_: in some other thread
19:49:51 <mm_freak_> jmcarthur: all threads are part of the state
19:50:03 <jmcarthur> mm_freak_: but they aren't modeled as a state monad
19:50:11 <mm_freak_> so?
19:50:11 <pikhq> And all threads can happen in parallel.
19:50:13 <jmcarthur> if they were then it would be deterministic
19:50:24 <mm_freak_> in fact, forkIO doesn't change the state
19:50:28 <pikhq> It is perfectly possible for the state to change during the execution of takeMVar.
19:50:29 <mm_freak_> takeMVar does
19:50:43 <mm_freak_> pikhq: there is no "during"
19:50:52 <mm_freak_> your imagination is just overcomplicating things
19:50:59 <pikhq> Yes there is. Threads can execute simultaneously.
19:51:18 <pikhq> Actions in the IO monad are not atomic.
19:51:32 <mm_freak_> they are, as far as the IO monad is concerned
19:52:04 <mm_freak_> threads are just some part of the state, but there is no concrete representation in the type system
19:52:07 <pikhq> By that notion, C is purely functional.
19:52:18 <mm_freak_> that's a pointless comparison
19:52:46 <mm_freak_> think of getChar = advanceWorld >> gets nextChar
19:53:10 <pikhq> Voila, you have a pure description of an imperative action.
19:53:18 <mm_freak_> yeah
19:53:20 <mm_freak_> that's my point
19:53:33 <pikhq> The imperative action can have state change during its execution.
19:53:59 <mm_freak_> sure, but from the perspective of the IO monad that's irrelevant
19:54:04 <syntaxglitch> from that perspective, can't evaluating pure, non-IO functions also "advanceWorld"?
19:54:13 <pikhq> From the perspective of the IO monad, state does not exist.
19:54:18 <mm_freak_> the advanceWorld computation is what changes the state
19:54:22 <mm_freak_> it captures your "during"
19:54:25 <pikhq> So discussing it from that perspective is meaningless.
19:54:45 <pikhq> More-so than claiming that C is purely functional, really.
19:55:00 <mm_freak_> no, you're just thinking too complicated
19:55:03 <kmc> are you guys really arguing about this
19:55:17 <pikhq> kmc: Yes.
19:55:18 <mm_freak_> IO is _not_ a container type
19:55:19 <ddarius> The problem isn't that you can't make a (philosophical) case for RealWorld -> (RealWorld, a); the problem is that it is a useless description.  You can't get anything out of it or calculate with it.
19:55:23 <mm_freak_> it's a theoretical construct
19:55:23 <pikhq> I think it obvious. :P
19:55:54 <mm_freak_> in that construct what advances the world's state are the state changing functions
19:56:00 <ddarius> A concrete realization of IO in terms of continuations is quite a bit more useful and is not bogged down with philosophy.
19:56:13 <mm_freak_> including most IO operations like getChar, takeMVar
19:56:17 <mm_freak_> but _not_ return
19:56:22 <syntaxglitch> Technically, the entire universe can be described as a pure function calculating new states from previous ones
19:56:23 <syntaxglitch> So really
19:56:28 <syntaxglitch> There's no such thing as an impure function
19:56:31 <syntaxglitch> Problem solved!
19:56:32 <pikhq> mm_freak_: Pity that "theoretical construct" has nothing to do with what IO actually does. :P
19:57:06 <mm_freak_> pikhq: it has, since IO's sole purpose is to express real world computations =)
19:57:19 <pikhq> Express and execute them.
19:57:22 <mm_freak_> no
19:57:25 <mm_freak_> express them
19:57:28 <mm_freak_> execute = unsafePerformIO
19:57:39 <pikhq> For execution purposes by the Haskell runtime, then.
19:57:53 <tensorpudding> assuming that you had a complete physical description of the universe, it could be described a a pure function
19:58:02 <mm_freak_> tensorpudding: exactly
19:58:04 <tensorpudding> as a*
19:58:09 <mm_freak_> well
19:58:14 <mm_freak_> almost exactly =)
19:58:19 <mm_freak_> there is quantum physics
19:58:20 <tensorpudding> though the idea of what a side effect would be in that case is really confusing
19:58:30 <ddarius> tensorpudding: Still not a deterministic one in a common perspective.
19:58:39 <syntaxglitch> tensorpudding, no such thing as side effects in that case
19:58:45 <tensorpudding> obviously it would not be deterministic
19:58:46 <mm_freak_> but IO disregards the quantum world =)
19:59:07 <tensorpudding> well, if the universe is quantized, it could be described in discrete time
19:59:39 <syntaxglitch> Can't you recover determinism in QM via a decoherence or many-worlds style of interpretation, anyway?
19:59:45 <ddarius> mm_freak_: For your view to work, advanceWorld has to advance the "state" of the entire universe accurately.
19:59:59 <mm_freak_> syntaxglitch: the problem is that there is real randomness in QM
20:00:05 <tensorpudding> updateUniverse :: Universe -> Universe, run every interval of planck time
20:00:09 <mm_freak_> ddarius: yeah
20:00:22 <ddarius> So QM can't be disregarded.
20:00:37 <tensorpudding> the copenhagen interpretation suggests that the indeterminism is related to wavefunction collapse
20:00:44 <arw> well. updateManyWorldsUniverse would be Universe -> [Universe]
20:00:45 <mm_freak_> ddarius: QM _needs_ to be disregarded, so IO is not an accurate description of the world
20:00:49 <mm_freak_> but it's sufficient
20:01:08 <tensorpudding> though if you follow the multiverse theory, you can allow for determinism via universe splitting
20:01:48 <mm_freak_> tensorpudding: not too easy
20:01:48 <arw> not quite sure, if that were really true.
20:01:52 <mm_freak_> some states are continuous
20:02:03 <tensorpudding> but that still means that you can't predict the future except as a probabilistic notion
20:02:07 <ddarius> mm_freak_: Again, for your view to work, advanceWorld has to -actually- advance the "state" of the world -accurately- (or rather it would define accuracy).
20:02:11 <tensorpudding> in any particular universe before measurement
20:02:26 <mm_freak_> ddarius: in fact that would work even
20:02:35 <mm_freak_> make a random number generator part of the state
20:03:16 <ddarius> I doubt the universe uses a "random number generator."
20:03:40 <arw> well. certainly not a deterministic one.
20:03:44 <mm_freak_> it does, it's just not a _pseudo_-random number generator =)
20:03:47 <arw> so it won't have any state.
20:03:52 <arw> mm_freak_: exactly
20:03:54 <ddarius> And then we to questions like: "What if 'advanceWorld' includes an increment that involves setting fire to the CPU?"
20:04:26 <mm_freak_> that will have an impact on gets nextChar
20:04:30 <tensorpudding> the quantum universe is not that important though
20:04:33 <ddarius> As I said, there are much more concrete and down to earth ways of dealing with this that do pretty accurately reflect what the Haskell RTS is doing and can be calculated with.
20:04:39 <dibblego> ddarius, when you get a moment, what exactly is this concrete realization of IO using continuations?
20:04:55 <tensorpudding> wavefunctions might have issues, but expectation values behave deterministically
20:05:12 <kmc> i wonder if ##c++ ever spends 3 hours contemplating the true metaphysical nature of template instantiation or virtual constructor idioms
20:05:14 <ddarius> dibblego: Basically, the request/response style as used by, e.g. MonadPrompt.
20:05:26 <mm_freak_> anyway, you don't need all thisâ€¦  IO works fine IMO
20:05:26 <arw> it can't. if you want to write advanceWorld you need that function to not be part of the world that is beeing advanced. else you are subject to the uncertainty relation and can't measure your parameters.
20:05:43 <erikc`> kmc: they spend it arguing over how to implicit closures with templates instead
20:05:44 <ddarius> dibblego: I know hbc did (does?) use a continuation based IO monad, and I believe Hugs did (does?) as well.
20:05:51 <erikc`> s/implicit/implement
20:05:52 <mm_freak_> i'm not saying it's the ultimate solution, but it's probably better than in any impure language
20:06:58 <mm_freak_> arw: well, you never write that advanceWorld function
20:07:16 <mm_freak_> there is also no access to 'get' and 'put'
20:07:22 <dibblego> I'd look that up but my quad-core machine is bogged down with running a Java application at the moment
20:07:58 <ddarius> dibblego: Are you (vaguely) familiar with the continuation-based IO systems proposed pre-monads?
20:08:02 <arw> mm_freak_: the real problem comes when you take cosmology into account: there is not necessarily an "outside" to our universe where such a function could do its magic.
20:08:12 <dibblego> ddarius, no, but I think I can intuit it
20:08:30 <ddarius> dibblego: Your intuition is probably accurate.
20:08:34 <dibblego> ok cheers
20:09:25 <mm_freak_> arw: neither is that necessaryâ€¦  people often forget that the IO state is theoretical
20:09:37 <mm_freak_> there is no discrete representation in memory
20:10:57 <arw> next week: on the metaphysics of java.lang.Object
20:11:09 <mm_freak_> also there is no need to encode the _entire_ state of the universe, but just the subset of it, which is necessary to drive whatever IO functions are available at that time
20:11:32 <mm_freak_> hehe
20:13:19 <arw> also on this program: Just Just Just Just Nothing. reflections on a countable nirvana.
20:13:59 <ddarius> "If we join together, we can achieve Nothing."
20:14:10 <monochrom> haha
20:14:18 <tensorpudding> data Numeral = Maybe Numeral
20:15:08 <tensorpudding> join would be predecessor i suppose
20:16:11 <kmc> ouch, Maybe as a data constructor
20:16:20 <tensorpudding> Just is succ
20:16:28 <tensorpudding> and now you can define addition and subtraction
20:16:29 <kmc> type Nat = Mu Maybe
20:41:19 <sshc> why isn't GHC included with mtl?
20:42:51 <c_wraith> it would be sort of odd for a library to include a compiler
20:45:08 <sshc> why isn't mtl included with GHC?
20:47:41 <kmc> because GHC is just a compiler, and not a complete Haskell development environment
20:47:52 <kmc> this is much more true in version 6.12.1 than in previous versions
21:02:02 <c_wraith> blah.  This is harder than I expected.  the binary package doesn't seem to have an easy way to go from ByteString -> [a]
21:02:53 <c_wraith> (the binary instance for [a] appears to be non-lazy)
21:06:34 <sshc> c_wraith: the binary package does no sanity checking whatsoever
21:06:45 <sshc> c_wraith: it doesn't check its input
21:06:54 <c_wraith> I don't care about that.
21:07:00 <Dark_Shikari> stupid newbie question, I must be totally botching my syntax
21:07:06 <Dark_Shikari> intfib::Integer->Integer
21:07:07 <Dark_Shikari> intfib x = if x >= 0 then fib x else intfib (x+2) - intfib (x+1)
21:07:13 <Dark_Shikari> No instance for (Num (Integer -> Integer))
21:07:19 <Dark_Shikari> due to the "-"
21:07:22 <c_wraith> I just wanted an easy way to pull multiple items out of a single bytestring
21:07:38 <Dark_Shikari> what's my stupid error?  been staring at it for 5 minutes and can't see anything
21:08:28 <c_wraith> But Binary only supports a single top-level object per bytestring
21:09:31 <c_wraith> Dark_Shikari: post your code on a pastebin
21:09:35 <c_wraith> @where paste
21:09:35 <lambdabot> http://hpaste.org/new
21:09:39 <Dark_Shikari> I know
21:09:41 <Dark_Shikari> That's the whole code
21:09:46 <Dark_Shikari> at 2 lines, what's the point of using a pastebin ;)
21:10:12 <c_wraith> the point is that it preserves formatting and adds syntax highlighting
21:10:36 <c_wraith> also, that's not your whole code
21:10:40 <Dark_Shikari> http://pastebin.com/m680a90fc
21:10:43 <mornfall> Dark_Shikari: Missing ().
21:10:46 <c_wraith> since prelude doesn't have a function named fib
21:10:47 <Dark_Shikari> mornfall: where?
21:10:55 <Dark_Shikari> I went around adding () frantically
21:11:00 <Dark_Shikari> hoping I screwed up my precedence
21:11:11 <Dark_Shikari> didn't fix it
21:11:33 <c_wraith> Dark_Shikari: it really looks like a unification error
21:11:41 <c_wraith> Dark_Shikari: caused by the fib function
21:11:42 <monochrom> What does "if x >= 0 then fib x" do?
21:11:53 <mornfall> Dark_Shikari: Actually, that line is correct, apparently.
21:11:55 <c_wraith> and you haven't pasted your whole code, since we don't know what the fib function is
21:12:03 <Dark_Shikari> c_wraith: yes I did, see the pastebin
21:12:12 <Dark_Shikari> mornfall: if( x >= 0 ) { fib x } else { intfib(x+2) - intfib(x+1 }
21:12:18 <Dark_Shikari> er, ) }
21:12:53 <c_wraith> oh.  I see the problem
21:13:05 <c_wraith> you're asking ghci to evaluate "intfib -1"
21:13:08 <Dark_Shikari> yes
21:13:10 <c_wraith> that's not valid
21:13:12 <Dark_Shikari> why not?
21:13:15 <Dark_Shikari> -1 is an integer
21:13:21 <c_wraith> or rather, it thinks you're subtracting 1 from intfib
21:13:23 <Dark_Shikari> Ah.
21:13:31 <mornfall> You have to say intfib (-1)
21:13:33 <Dark_Shikari> I have to parenthesize negative numbers?
21:13:37 <Dark_Shikari> Blegh, I guess
21:13:47 <c_wraith> you have to paranthesize unary (-)
21:13:58 <Dark_Shikari> makes sense, given the operator precedence
21:14:13 <mornfall> Unary - is a bug in the language. :)
21:14:21 <Dark_Shikari> lol
21:14:41 <Dark_Shikari> but of course, from a scheme perspective
21:14:45 <Dark_Shikari> binary - is a bug in the language ;)
21:14:56 <tensorpudding> one of the more glaring sharp edges in haskell
21:15:33 <kniu> The Silence of the Lambda
21:15:37 <mornfall> You could argue it's a bug in mathematical notation. : - )
21:15:38 <scutigera> tensorpudding: not so bad, you have to use ~ in ML
21:15:57 <mornfall> scutigera: You could argue it's better that way.
21:15:59 <tensorpudding> it doesn't really violate POLS as bad as some things in haskell, but it's noticeably inconsistent
21:16:34 <monochrom> POMC > POLS
21:16:51 <mornfall> where MC = ?
21:16:57 <monochrom> maximum consistency
21:16:57 <tensorpudding> principle of most confusion maybe?
21:16:59 <tensorpudding> oh
21:17:02 <tensorpudding> yes
21:17:07 <Dark_Shikari> lol
21:17:11 <tensorpudding> Haskell violates a lot more POLS than POMC
21:17:28 <tensorpudding> but that is strongly by design rather than by intent
21:17:31 <Dark_Shikari> principle of most confusion: sounds like the rule behind APL
21:17:45 <monochrom> POLS is BS if the audience received BS education and expect BS and are maximumly surprised by right ways to do things.
21:17:48 <Guest72905> hi all, just started using haskell 24 hrs ago
21:18:05 <Guest72905> having a ton of fun, burning through project euler questions
21:18:16 <monochrom> For example telling the truth violates POLS for most managers and politicians.
21:18:41 <Guest72905> but i noticed that it is using 20% of my cpu even when completely idle
21:18:50 <scutigera> mornfall: you could, but there are no switches to print using a '-' instead of '~' for output. truly annoying.  but makes reading code less ambiguous
21:18:58 <Guest72905> anyone know anything about that? (on windows)
21:18:58 <mornfall> monochrom: Nevertheless, letting managers and politicians do Haskell violates POLS for us.
21:18:59 <Dark_Shikari> Guest72905: it uses that to produce magic dust
21:19:10 <Dark_Shikari> which it then uses to perform operations
21:19:17 <Dark_Shikari> thus, you should wait a while between commands to let it regenerate its magi dust
21:19:20 <Dark_Shikari> *magic
21:19:35 <monochrom> POLS violates POLS
21:19:53 <scutigera> what about SLOP ?
21:19:56 <Guest72905> i have been away from cmputer for 1 hr, si that long enough?  still doing it ...
21:20:14 <Twey> monochrom: People expect to be surprised?  :Ã¾
21:20:35 <mornfall> Twey: Christmas time!!1
21:20:41 <Dark_Shikari> Guest72905: that was a joke
21:20:44 <Twey> I expected that!
21:20:52 <mornfall> Dark_Shikari: I think you got counterjoke back.
21:20:55 <Dark_Shikari> lol
21:20:57 <Twey> Haha
21:21:01 <Twey> You never knowâ€¦
21:21:05 <mornfall> True.
21:21:10 <Guest72905> i know, but i thought it might be GC or something, but it's neverending
21:21:23 <Dark_Shikari> it's garbage conversion (GC)
21:21:27 <Twey> By â€˜Haskellâ€™, do you mean your program?
21:21:27 <Dark_Shikari> it turns garbage into more pixie dust
21:21:41 <mornfall> Twey: I'd expect ghci.
21:21:44 <Twey> Or is GHC compiling slowly?
21:21:49 <mornfall> Guest72905: GHCi? Or Hugs?
21:21:54 <Guest72905> yeah, sorry, all ghci
21:21:55 <mornfall> Or something altogether different...
21:22:02 <Twey> Oh, well, then
21:22:13 <Guest72905> doing command line stuff for project euler
21:22:15 <Twey> GHCi is a debugging tool.  It's not meant for high-performance applications.
21:22:25 <monochrom> Twey: No. Two groups of people have conflicting expectations. Even one single person has cognitive dissonance. "least surprise" from one perspective can be "maximum surprise" from another. POLS is contradictory.
21:22:29 <mornfall> Guest72905: If it comforts you any, it doesn't do that on my Linux.
21:22:30 <Twey> If you're writing real programs, compile them.
21:22:41 <Twey> monochrom: .ie
21:22:59 <mornfall> monochrom: But then, noone claims it's not. It's just a rule of thumb, anyway.
21:23:02 <Dark_Shikari> yay, more stupid questions
21:23:03 <Dark_Shikari> http://pastebin.com/m446af24d
21:23:12 <Dark_Shikari> ghci won't even load my file because my syntax is so bad
21:23:18 <Dark_Shikari> but I'm not sure what the error is.
21:23:20 <monochrom> POMC is a better rule of thumb.
21:23:41 <mornfall> Dark_Shikari: head :: [a] -> a, tail :: [a] -> [a] ... can't have both a and [a] in a single list
21:23:50 <mornfall> Or.
21:23:52 <mornfall> I read that wrong.
21:24:21 <mornfall> No, I don't, but it's merge not tail.
21:24:34 <mornfall> You want to say head ... : head ... : merge
21:24:42 <Dark_Shikari> should I do
21:24:45 <Dark_Shikari> merge (a,b) = ?
21:24:50 <mornfall> Or [head, head] ++ merge
21:25:14 <Dark_Shikari> merge (a,b) = [head a, head b, merge ((tail a), (tail b))]
21:25:15 <Dark_Shikari> doesn't work either
21:25:25 <Dark_Shikari> oh
21:25:29 <Dark_Shikari> I can't do that kind of construction?
21:25:30 <mornfall> merge (a,b) = head a : head b : merge (tail a) (tail b)
21:25:59 <Dark_Shikari> that one gives even more errors
21:26:16 <djahandarie> Dark_Shikari? THE Dark_Shikari? ;)
21:26:25 <Dark_Shikari> http://pastebin.com/m7b6b9605
21:26:30 <Dark_Shikari> yes, THE Dark_Shikari is learning haskell
21:26:34 <djahandarie> Heh
21:26:36 <mornfall> Dark_Shikari: Sorry, uncurry the last call. : - )
21:26:40 <Dark_Shikari> lol
21:26:43 <Dark_Shikari> dur
21:26:44 <mornfall> merge (a,b) = head a : head b : merge (tail a, tail b)
21:26:46 <djahandarie> Enjoy, it's fun :D
21:26:59 <Dark_Shikari> yup, worked
21:27:02 <Dark_Shikari> obvious stupidity.
21:27:16 <monochrom> heh
21:27:19 <Dark_Shikari> oh, and I forgot my base case
21:27:33 <mornfall> Dark_Shikari: There's more than one.
21:27:35 <Dark_Shikari> yup
21:27:39 <Dark_Shikari> three possible base cases
21:27:49 <mornfall> Infinite possible base cases. ; - )
21:27:58 <djahandarie> It's a good thing we are lazy here
21:28:03 <Dark_Shikari> ;)
21:28:21 <djahandarie> It's a pain to take care of all of the cases so we only take care of a few!
21:28:42 <Dark_Shikari> haskell is practically the first high-level language that I've liked
21:28:45 <Dark_Shikari> all the others have dynamic types
21:28:50 * djahandarie writes an essay about being lazy and a Haskell programmer
21:29:00 <Dark_Shikari> and dynamic types are annoying
21:29:13 <mornfall> merge (a:as,b:bs) = a : b : merge (as, bs) ; merge _ = []
21:29:22 <djahandarie> Dark_Shikari, hah, that's hardly the best part either. :-)
21:29:26 <djahandarie> Dark_Shikari, what are you using to learn?
21:29:28 <Dark_Shikari> mornfall: but what about the case of merge([1],[])
21:29:45 <Dark_Shikari> djahandarie: it's not the best part, but dynamic types are enough to sink a language in my mind
21:29:58 <mornfall> Dark_Shikari: Oh, you want it to also create odd-sized lists?
21:30:15 <mornfall> Then you have to go differently about it.
21:30:23 <Dark_Shikari> yup
21:30:27 <djahandarie> @where rwh
21:30:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:30:31 <Twey> Why is merge taking a tuple?
21:30:31 <Dark_Shikari> but yes, I can do it
21:30:34 <djahandarie> Dark_Shikari, see that if you haven't already ^^
21:30:39 <Dark_Shikari> Twey: because the homework assignment is retarded
21:30:40 <mornfall> Twey: Because it's uncurried!
21:30:44 <djahandarie> Twey, because we are merging tuples of course!
21:30:46 <Twey> o.x
21:30:52 * djahandarie merges Twey 
21:30:55 <mornfall> curry merge
21:30:55 <Dark_Shikari> lol
21:31:10 <Dark_Shikari> someone should have a big haskell convention, and serve curry for dinner
21:31:13 <Dark_Shikari> and see how many groans they get
21:31:20 * alexsuraci wishes he had Haskell for homework...excluding Math where I probably shouldn't be using it.
21:31:21 <Twey> Haha
21:31:27 <djahandarie> Dark_Shikari, and it could be at a Church too
21:31:29 * Twey does have Haskell for homework
21:31:31 <Dark_Shikari> ha ha
21:31:48 <Twey> And I can even write stuff in it, after I finish this fifty-page analysis and design writeupâ€¦
21:31:54 <mornfall> djahandarie: Hopefully not Church of Emacs.
21:31:56 <Dark_Shikari> merge (a,[]) = head a : merge (tail a) []
21:31:58 <Dark_Shikari> what's broken about this?
21:32:08 <Twey> Dark_Shikari: The tuple.
21:32:15 <mornfall> Dark_Shikari: curry, curry!
21:32:21 <Dark_Shikari> oh dear
21:32:23 <Dark_Shikari> I hate this assignment
21:32:27 <Dark_Shikari> writing functions in nonintuitive ways
21:32:35 <tensorpudding> curry curry howard howard
21:32:40 <Twey> Hehe
21:32:44 <tensorpudding> not as funny as
21:32:47 <djahandarie> LAMBEK?!
21:32:51 <mornfall> Dark_Shikari: You ought to say merge' a b = ... and then merge = uncurry merge'.
21:32:56 <Dark_Shikari> *Main> let a = ([1,2,3],[4,5,6,7])
21:32:56 <Dark_Shikari> *Main> merge a
21:32:57 <Dark_Shikari> [1,4,2,5,3,6,7]
21:32:58 <Dark_Shikari> yay
21:33:00 <tensorpudding> an anagram of Banach-Tarski is Banach-Tarski Banach-Tarski
21:33:04 <monochrom> Why isn't merge(a,[]) = a ?
21:33:07 <Dark_Shikari> tensorpudding: ha ha
21:33:14 <Dark_Shikari> mornfall: "a" can be longer than 1 unit
21:33:25 <Dark_Shikari> you could do merge ([1,2,3,4,5,6],[1,3,4])
21:34:00 <monochrom> Yeah, so eventually a=[4,5,6]
21:34:11 <djahandarie> Dark_Shikari, just write merge = zip for your assignment and be done with it
21:34:14 <monochrom> So you're looking at merge([4,5,6], []).
21:34:16 <Dark_Shikari> djahandarie: lol
21:34:20 <Dark_Shikari> I don't think we're allowed to do that.
21:34:27 <monochrom> Do you want merge([4,5,6], []) = [4,5,6] ?
21:34:33 <Dark_Shikari> yes
21:34:34 <mornfall> djahandarie: Specifically, zip doesn't do what he wants.
21:34:42 <monochrom> So in general merge(a,[]) = a ?
21:34:49 <djahandarie> mornfall, oh, yeah, just noticed
21:34:57 <Dark_Shikari> mornfall: oh, that's true.
21:35:00 * djahandarie needs to get a bad advice kick
21:35:08 <mornfall> Dark_Shikari: Your tab is playing tricks on you.
21:35:28 <Dark_Shikari> why do I have to redefine variables after performing an :l?
21:35:41 <Twey> @src zip
21:35:41 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
21:35:41 <lambdabot> zip _      _      = []
21:36:00 <Twey> Are you allowed to do that?  ;)
21:36:00 <monochrom> Because it's too hard to figure out which variables are safe to keep.
21:36:11 <Dark_Shikari> scope is hard, let's go shopping
21:36:36 <Twey> Hmmâ€¦ foldr is hard to define in terms of zip
21:36:43 <Twey> Erâ€¦ zip is hard to define in terms of foldr
21:36:49 <djahandarie> Twey, impossible perhaps
21:36:49 <djahandarie> oh
21:36:52 <Twey> Is there any way to define it other than direct recursion?
21:37:22 <mornfall> Twey: Y
21:37:33 <pikhq> Mmm, indirect recursion.
21:37:36 <Twey> Hmm, fix?
21:37:38 <djahandarie> Who needs those combinators anyways
21:37:47 <dolio> zip is most naturally an unfold.
21:37:53 <Twey> Ah, yes
21:37:55 <Twey> :t unfoldr
21:37:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:38:05 <Twey> Hm
21:38:06 <Twey> But how?
21:38:09 <mornfall> :)
21:38:12 <mornfall> Homework.
21:38:18 <Twey> Aw :Ã¾
21:38:36 <Twey> My poor insomnia-addled mind dislikes you for that.  :Ã¾
21:38:39 <Twey> Maybe a closureâ€¦
21:38:54 <mornfall> Unfortunately, I'll have to leave you, there's this state exam business I have to attend in couple hours.
21:39:03 <Twey> Ooh.  Have fun.
21:39:11 <mornfall> Next time I show up, I should be MSc. Hopefully.
21:39:12 <djahandarie> State? There is a monad for that
21:39:16 <Twey> Nice
21:39:22 <djahandarie> mornfall, good luck
21:39:26 <Twey> Aye
21:39:34 <mornfall> Thanks. :) Afk.
21:39:36 <Dark_Shikari> @src curry
21:39:36 <lambdabot> curry f x y = f (x, y)
21:40:07 <alexsuraci> eh? no curry f x y z?
21:40:19 <alexsuraci> guess that'd be too magical.
21:40:51 <dibblego> curryN is on hackage iirc
21:41:22 <Dark_Shikari> @src uncurry
21:41:22 <lambdabot> uncurry f p = f (fst p) (snd p)
21:46:56 <dolio> > let tail = foldr (\x ~(xs,_) -> (x:xs, xs)) ([],error "tail of empty list") in foldr (\x k r -> foldr (\y _ -> (x,y) : k (tail r)) [] r) (const []) [1..10] [11..15]
21:46:57 <lambdabot>   Couldn't match expected type `[a]'
21:46:57 <lambdabot>         against inferred type `([a], [a])'
21:47:12 <dolio> > let tail = snd . foldr (\x ~(xs,_) -> (x:xs, xs)) ([],error "tail of empty list") in foldr (\x k r -> foldr (\y _ -> (x,y) : k (tail r)) [] r) (const []) [1..10] [11..15]
21:47:13 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15)]
21:48:24 <dolio> There's a somewhat nicer way to intertwine the foldrs, too, but it requires a newtype.
21:48:45 <dolio> And non-strictly-positive types.
21:49:10 <scutigera> "non-strictly-positive types" ??
21:49:15 <djahandarie> @src tail
21:49:15 <lambdabot> tail (_:xs) = xs
21:49:15 <lambdabot> tail []     = undefined
21:49:51 <djahandarie> oh
21:49:54 <djahandarie> Didn't even read
21:50:01 * djahandarie sighs
21:50:11 <Dark_Shikari> ^ tail undefined
21:50:14 <Dark_Shikari> er,
21:50:16 <Dark_Shikari> > tail undefined
21:50:17 <lambdabot>   * Exception: Prelude.undefined
21:50:31 <Dark_Shikari> so unlike lambda calculus, tail nil != nil
21:50:58 <dolio> scutigera: In A -> B, A is said to occur in the negative position (and B is in the positive position).
21:52:35 <dolio> scutigera: An occurence is strictly positive if it's only on the right side of arrows, negative if it's on the left side of an odd number of (nested) arrows, and non-strictly positive if it's on the left side of an even number of (nested) arrows.
21:53:06 <Gracenotes> there is by no means a one-to-one relationship between a lambda calculus term and its meaning in some encoding
21:53:13 <scutigera> dolio: got it. is that YATCT yet another category thing ?
21:53:23 <dolio> Strictly-positive types refer to themselves recursively only in strictly positive positions, negative types ....
21:53:39 <dolio> More type theory, I think.
21:54:10 <scutigera> dolio: I really have to get a text or two about both..
21:55:24 <dolio> Most formal type theories (that I've seen) aiming for logical consistency only allow strictly-positive types.
21:56:08 <dolio> Negative types are out because they let you type the usual Y combinator from the untyped lambda calculus.
21:57:26 <dolio> I've never really seen a straight answer on why no one allows non-strictly-positive (but still positive) types, other than that they might not have a clear induction principle.
22:00:22 <scutigera> that's extremely unintuitive, the whole concept.  how can you tell from the type signature that something is going to be a problem ?
22:01:10 <scutigera> :t foldr
22:01:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:02:13 <scutigera> b is positive ?
22:02:32 <scutigera> uh, nope...
22:02:42 <dolio> b occurs both positively and negatively.
22:02:48 <scutigera> right.
22:03:01 <dolio> But it isn't really important there (that I know of). It matters when you're defining types.
22:03:14 <dolio> Like data U = U (U -> U)
22:03:26 <kmc> data U = MkU (U -> Bool) -- the universe of naive set theory
22:03:28 <dolio> That has a negative occurrence of U.
22:03:54 <tensorpudding> doesn't Mu allowed you to do a fixed point on types?
22:03:57 * kmc wonders what the induction principle of U would look like
22:03:58 <kmc> tensorpudding, yes
22:04:10 <kmc> Mu does for types what fix does for terms
22:04:29 <dolio> kmc: I've thought about it, and couldn't come up with anything sensible.
22:04:33 <tensorpudding> i thought fixed point combinators were not possible in standard typed lambda calculus
22:04:55 <kmc> tensorpudding, you can't write one in the simply typed lambda calculus
22:04:57 <tensorpudding> fix uses let, which strikes me as cheating
22:05:09 <tensorpudding> what about System F?
22:05:23 <kmc> System F is also strongly normalizing
22:05:23 <tensorpudding> that's what GHC uses isn't it?
22:05:27 <kmc> sort of
22:05:38 <tensorpudding> without the parts that cause undecideable type inference
22:05:45 <kmc> System FÏ‰ I think
22:05:52 <tensorpudding> but a bigger subset than HM uses
22:07:47 <kmc> "let" is the root of recursion in Haskell
22:09:14 <kmc> GHC has several type system features with undecidable inference.  the solution is that it won't infer those types :)
22:09:36 <tensorpudding> hmm
22:09:50 <tensorpudding> so when you turn on certain extensions, it disables the type inferer?
22:09:55 <Hunner> it's almost alarming how so few lines of haskell are so powerful, and how long it can take to form them
22:10:21 <scutigera> Hunner: form them ? compile them ?
22:10:33 <Hunner> write them
22:10:40 <kmc> tensorpudding, no.  when you turn on certain extensions, some well-typed terms are not accepted without a type signature
22:10:50 <Hunner> like, it can take a few hours to write as few as 2 or 3 lines
22:11:06 <tensorpudding> hmm
22:11:18 <kmc> i think every well-typed term from H98 is accepted without a signature, no matter what extensions are on
22:11:20 <scutigera> Hunner: 2 or 3 lines of elegant code.  I can crank out some obvious ugly stuff faster than that :-)
22:11:27 <tensorpudding> so it will infer some types, but refuse to try on others?
22:11:28 <pikhq> Hunner: You'll get better at it.
22:11:39 <tensorpudding> H98 uses HM strictly doesn't it?
22:11:49 <tensorpudding> err, uses strictly HM
22:11:57 <kmc> tensorpudding, it will try and fail to infer types for those terms
22:12:04 <tensorpudding> ah
22:12:07 <scutigera> Hunner: there definitely seems to be a tao of haskell.  still learning...
22:12:09 <dolio> H98 has some terms that require type signatures.
22:12:11 <tensorpudding> nothing wrong with that
22:12:16 <dolio> When polymorphic recursion is involved.
22:12:22 <kmc> dolio, due to typeclass ambiguity.  other reasons?
22:12:34 <tensorpudding> you need to give read a type sometimes
22:12:36 <kmc> :t \x -> (x (), x 'z')
22:12:37 <lambdabot>     Couldn't match expected type `Char' against inferred type `()'
22:12:37 <lambdabot>       Expected type: Char -> t
22:12:37 <lambdabot>       Inferred type: () -> t1
22:12:45 <tensorpudding> > read "10"
22:12:46 <kmc> :t \(x :: forall a. a -> Int) -> (x (), x 'z')
22:12:46 <lambdabot>   * Exception: Prelude.read: no parse
22:12:47 <lambdabot> (forall a. a -> Int) -> (Int, Int)
22:12:58 * Twey read â€˜inferior typeâ€™
22:13:17 <dolio> > let f 0 x = show x ; f (n + 1) x = f n (x,x) in f 3 'a'
22:13:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, a)
22:13:32 <dolio> > let f :: (Show a) => Int -> a -> String ; f 0 x = show x ; f (n + 1) x = f n (x,x) in f 3 'a'
22:13:33 <lambdabot>   "((('a','a'),('a','a')),(('a','a'),('a','a')))"
22:14:23 <scutigera> the thing that gets me about haskell is writing code that gets into an infinite loop with nary a peep from the compiler. forget to add ' to a var name...
22:14:35 <kmc> yeah i hate that
22:14:53 <kmc> i've mostly stopped using ' in variable names for that reason
22:15:05 <scutigera> unintended recursion :-(
22:15:06 <tensorpudding> primes are annoying
22:15:10 <tensorpudding> including haskell'
22:15:17 <kmc> with -O2 ghc can detect some simple infinite loops (at runtime)
22:15:19 <Twey> @quote emission
22:15:19 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
22:15:22 <Twey> Hunner:
22:15:37 <Hunner> :)
22:15:58 <scutigera> for certain mathematical calculations ' can make things very readable
22:16:22 <scutigera> @quote quote
22:16:22 <lambdabot> LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
22:16:34 <scutigera> @quote recursion
22:16:34 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
22:16:34 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
22:16:34 <lambdabot> still
22:16:52 <kmc> still
22:17:02 <tensorpudding> too long
22:17:45 <scutigera> <lambdabot>
22:17:57 <kmc> @quote lambdabot
22:17:58 <lambdabot> lambdabot says: lambdabot
22:18:13 <Gracenotes> mathematical code? readable??
22:19:06 <monochrom> english? meaningful?
22:19:23 <scutigera> depends on the source
22:26:39 <kmc> aww no Storable instance for ()
22:27:07 <tensorpudding> my unit is safely stored
22:31:18 <mjrosenb> is there a function to remove all duplicates from a list, or should i just write one myself?
22:31:45 <mjrosenb> "map head . group . sort" and whatnot
22:33:57 <Draconx|Laptop> > nub [4,5,6,4,6]
22:33:58 <lambdabot>   [4,5,6]
22:34:41 * mjrosenb always wondered what that was for
22:34:58 <mjrosenb> and i've seen nubBy used to compute primes
22:35:01 <Draconx|Laptop> nub preserves order, though, so I think it's less efficient.
22:35:13 <mjrosenb> yeah, iirc, it is n^2
22:35:48 <ozataman> Hey all
22:36:15 <mjrosenb> ozataman: yo
22:36:40 <ozataman> Is there a away to terminate an optimization routine after a certain time and return the best result computer so far?
22:36:46 <ozataman> Maybe with MVars or something like that?
22:36:54 <ozataman> computed*
22:37:18 <mjrosenb> ozataman: the thing after mvars in the library docs
22:37:35 <mjrosenb> samplevar
22:37:37 <ozataman> For simplicity, we can assume that the fold keeps the best result so far in its accumulator, or we are always keeping it in the mvar
22:37:39 <ozataman> oh really?
22:37:42 <ozataman> great, let me take a look
22:39:14 <ozataman> But how would I implement the timeout functionality?
22:42:05 <Hunner> ozataman: you could use iterative deepening. It's not exactly "terminating and returning the best" but it's probably decent
22:42:21 <Hunner> Check Control.Monad.Levels in hackage
22:42:30 <kmc> fork a thread for the optimization routine.  that thread writes to a SampleVar repeatedly.  main thread uses threadDelay then killThread then reads
22:43:07 <kmc> Haskell threads are cheap and easy; they are a reasonable solution for small problems
22:44:02 <ozataman> kmc: thanks, that sounds good
22:44:18 <ozataman> kmc: btw, why use samplevar and not mvar?
22:44:29 <kmc> writing to an already full mvar will block
22:46:28 <kmc> beware that MVar hence SampleVar is lazy.  since the purpose of your writer thread is computation you may want to force the value you write (using seq, or further if necessary), or look at the strict-concurrency package
22:48:55 <kmc> > negate (1 :: Word64)
22:48:56 <lambdabot>   18446744073709551615
22:53:22 <ozataman> kmc: Ah I see... Well, I will output the result after timeout - that should force eval, no?
22:57:15 <kmc> sure, in the thread where you do the printing
22:58:23 <kmc> suppose your approximation thread is like «forever $ do { x <- readSampleVar var; writeSampleVar var (improve x) }»
22:58:43 <kmc> here «improve» is a computationally expensive pure function which improves the approximation somehow and returns a better one
22:59:20 <kmc> that will (very quickly) build an unevaluated thunk representing applying that function many times, without doing any work
23:00:08 <Hunner> always funny to watch +1 thunks use 4GB of ram :P
23:00:40 <kmc> instead you want the work to happen in this thread (so you can kill it after some time) so you should force x before writing it
23:01:20 <kmc> @type Control.Exception.evaluate
23:01:20 <lambdabot> forall a. a -> IO a
23:01:41 <kmc> that'd be useful, presuming that evaluation to weak head normal form is enough to force the work
23:02:57 <kmc> it's nicer than writing «x <- readSampleVar var; x `seq` writeSampleVar var (improve x)»
23:03:20 <ozataman> ah OK, I see what you mean
23:03:34 <ozataman> how expensive would this writing/reading be?
23:03:57 <kmc> the strict-concurrency package forces everything all the way to normal form, and thus requires a NFData instance for the type you store
23:04:16 <kmc> MVars are supposed to be pretty cheap.  i don't have numbers
23:04:25 <ozataman> kmc: ok, that's good to know
23:04:40 <kmc> (SampleVar is a thin wrapper on MVar)
23:15:39 <luqui> @src tails
23:15:39 <lambdabot> tails []         = [[]]
23:15:39 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
23:16:00 <Twey> > tails [[]]
23:16:01 <lambdabot>   [[[]],[]]
23:16:04 <Twey> > tails []
23:16:05 <lambdabot>   [[]]
23:16:15 <Twey> Oh, right
23:17:53 <luqui> > sum . map sum $ tails [0..1000]
23:17:54 <lambdabot>   334334000
23:59:55 <dolio> So, how come people don't talk about the comma category definition of adjoints? It's almost like the hom-set definition, but it doesn't mention sets, so it's way better. :)
