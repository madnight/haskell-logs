00:03:35 <fabjan> http://example.nfshost.com/versions.php offers haskell
00:05:45 <dblhelix> goodmorning, #haskell
00:06:15 <dreixel> good morning dblhelix
00:13:49 <solrize> do i have to use the low level network (Network.Socket) for UDP?
00:13:57 <solrize> instead of just Network ?
00:15:52 <MissPiggy> Educated cubeless stupid, you think stupid.
00:16:33 <tensorpudding> !markov 5
00:16:40 <psychobot> ct: base-3.0.3.1 requirements (and even know MissPiggy: "User" as in markov on ASTs... i won't* correcting the is "mergency" so.. how is you have a haskell
00:17:12 <sinelaw> the new book,"you have a haskell"
00:23:38 <Botje> and the one after that "how to get rid of a haskell in 10 easy steps"
00:23:52 <sinelaw> heh
00:24:04 <tensorpudding> you wait until it dies, then flush it down the toilet
00:25:15 <tensorpudding> or you drag GHC to the recycle bin
00:27:50 * MissPiggy coping with Haskell
00:33:38 <sinelaw> Cale?
00:36:49 <MissPiggy> I'm still not completely sure that my data type is correct
00:37:16 <c_wraith> > cake !! 37
00:37:17 <lambdabot>   "Injector needle driver."
00:37:42 <MissPiggy> !markov
00:37:43 <psychobot> Plugin `markov' failed with: Prelude.read: no parse
00:37:45 <MissPiggy> !markov
00:37:45 <psychobot> Plugin `markov' failed with: Prelude.read: no parse
00:37:50 <tensorpudding> needs an argument now
00:37:53 <tensorpudding> !markov 5
00:37:53 <kmc> !markov 5
00:38:06 <psychobot> n feelings.php also monad" has one or something unders whether way ACTION could enter key in another to two page. especially what into two 50's annoying t
00:38:09 <psychobot> Plugin `markov' failed with: thread killed
00:38:11 <Taejo> :t assert
00:38:12 <lambdabot> Not in scope: `assert'
00:38:16 <psychobot> Not in scope: `assert'
00:38:17 <Taejo> @hoogle assert
00:38:17 <lambdabot> Control.Exception assert :: Bool -> a -> a
00:38:17 <lambdabot> Control.OldException assert :: Bool -> a -> a
00:38:17 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
00:38:22 <sinelaw> feelings.php
00:38:27 <tensorpudding> mm, feelings.php also monad
00:38:58 <kmc> @quote feelings
00:38:58 <lambdabot> copumpkin says: limpac: in this channel we're all automata with no feelings, except for the occasional feeling of hate.
00:39:14 <kmc> @quote feelings
00:39:14 <lambdabot> copumpkin says: limpac: in this channel we're all automata with no feelings, except for the occasional feeling of hate.
00:39:17 <tensorpudding> !markov 5
00:39:22 <copumpkin> that doesn't seem so @rememberable
00:39:30 <psychobot> m 'objectional, it's sinelaw A person says: Saying on the hiddenState oh ok  :) ignore him a huge version which shtoot? I guess I don't having to be types,
00:39:31 <tensorpudding> it's getting really slow
00:39:44 <MissPiggy> !markov
00:39:44 <psychobot> Plugin `markov' failed with: Prelude.read: no parse
00:39:48 <sinelaw> yeah, suboptimal
00:39:51 <sinelaw> i need to fix that
00:40:04 <copumpkin> is it storing the entire history of sentences it's seen?
00:40:11 <copumpkin> or just learning distributions?
00:40:13 <sinelaw> it will be easy if i set a constant memory length
00:40:32 <sinelaw> copumpkin, currently it stores the entire history, so that you can tell it to build distributions for different lengths
00:40:47 <sinelaw> if i set that to a constant, i can just save the distributions
00:40:56 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17179
00:40:57 <copumpkin> makes sense
00:41:05 <MissPiggy> here I have got this typeclass I made
00:41:17 <ClaudiusMaximus> !markov 0
00:41:30 <psychobot> Plugin `markov' failed with: Prelude.tail: empty list
00:41:41 <sinelaw> slow :(
00:41:43 <MissPiggy> I am wondering if you think it's good and should I probably compute all these feilds in it from one single list
00:42:08 <MissPiggy> I define a parser and pretty printer based on that calss
00:42:10 <MissPiggy> class*
00:42:15 <medfly> I'm going to get more sleep
00:42:42 <sinelaw> don't work yourself too hard
00:42:57 <kmc> !markov 5
00:43:10 <psychobot> te will be conflict: base-3 then jmcarthur: nice, haskell think it's an explaining math? Is the type level markov bot @quote spj says: <Haskell.) coolest p
00:43:20 <tensorpudding> i finally understand GADTs and they're a lot less exciting than i thought they were
00:43:32 <MissPiggy> tensorpudding then you don't understand GADTs :)
00:43:52 <dolio> You should train a markov bot exclusively with text written by Jon Harrop.
00:43:57 <kmc> depends on how exciting he thought they were ;P
00:44:22 <copumpkin> they're a pretty simple idea, but I'm not sure how complicated implementing them is
00:44:33 <tensorpudding> well, they allow you to make fancy data constructors with types that are pretty intriguing
00:44:33 <sinelaw> dolio, i can just have a plugin that runs the markov bot on some pre-trained data, in addition to the learning one
00:44:35 <MissPiggy> is this sensible parsec idiom:  term = do spaces ; term' where term' = ..
00:44:37 <xerox> also use John Gabriel knol if you are at it
00:44:58 <copumpkin> ack not John Gabriel
00:45:02 <tensorpudding> he's got a blogger that has even more craziness in it
00:45:22 <tensorpudding> he wrote that group theory is not well-founded because 0 lacks a multiplicative inverse
00:45:26 <copumpkin> o.O
00:45:43 <copumpkin> yeah, but you're probably a jew or something
00:45:54 <copumpkin> (damn, now I look terrible in #haskell... I was just quoting Gabriel)
00:45:55 * kmc resists the urge to @remember that
00:46:00 <kmc> out of context ftw
00:46:11 <Taejo> does compiling with -prof but not running with -p affect runtime?
00:46:19 <copumpkin> :)
00:46:28 <kmc> the point of GADTs is that when matching each constructor, you get some additional information about the type parameters of the GADT type
00:46:28 <tensorpudding> @remember copumpkin damn, now i look terrible in #haskell...
00:46:28 <lambdabot> Done.
00:46:29 <aavogt> Taejo: -prof is incompatible with -O2 I think
00:46:36 <kmc> whether that's exciting is unclear
00:46:41 <copumpkin> :P
00:46:48 <Taejo> aavogt: ghc doesn't complain when I specify both
00:46:50 <sinelaw> > words "aha it is working"
00:46:51 <lambdabot>   ["aha","it","is","working"]
00:46:55 <copumpkin> worst @remember ev4r
00:47:18 <dolio> I'm pretty sure -O2 still does stuff even with -prof enabled.
00:47:29 <aavogt> Taejo: as in, you don't get as much of a speed-up
00:47:33 <kmc> GADTs with dependent types are quite exciting ;P
00:47:35 <Taejo> oic
00:47:38 <dolio> Like, making the profiling output more confusing, because code gets moved around.
00:47:45 <sinelaw> > foldr (++" "++) [] (words "what about this")
00:47:45 <lambdabot>   <no location info>: parse error on input `)'
00:48:16 <kmc> heh, a double section
00:48:16 <copumpkin> -O2 is called that because you can't write parentheses on the command line. But it means that it optimizes your algorithms to run in O(2) time and space! -O1 makes them even faster, and -O0 causes them to complete before you even run them.
00:48:21 <sinelaw> > foldr ((++" ")++) [] (words "what about this")
00:48:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
00:48:22 <lambdabot>        ...
00:48:23 <tensorpudding> dependent types are pretty intriguing
00:48:28 <tensorpudding> but haskell doesn't have them
00:48:40 <kmc> tensorpudding, aye, instead we have awful ways of faking it
00:48:50 <kmc> the medicine is worse than the disease ;P
00:49:01 <tensorpudding> GADTs seem to encompass existentials too
00:49:07 <kmc> yes
00:49:22 <MissPiggy> data Eq a b where REFL :: Eq a a
00:49:22 <tensorpudding> that's convenient
00:49:26 <kmc> and the syntax is nicer even for regular ADTs
00:49:34 <tensorpudding> yeah
00:49:43 <tensorpudding> overall it's pretty neat
00:49:43 <kmc> if i ever write a Haskell tutorial it will use GADT syntax from page one
00:49:58 <kmc> with a footnote
00:50:07 <tensorpudding> but i don't find myself writing data constructors that take advantage of the existential aspects yet
00:50:09 <sinelaw> @pl (\x y -> x ++ " " ++ y)
00:50:09 <lambdabot> (. (' ' :)) . (++)
00:50:12 <tensorpudding> maybe i'm not hardcore enough
00:50:13 <sinelaw> oy.
00:50:23 * copumpkin turns up the core hardness knob on tensorpudding 
00:50:25 <MissPiggy> tensorpudding, it's difficult to get a feel for it
00:50:27 <sinelaw> > (++ " ") "ah
00:50:28 <lambdabot>   <no location info>:
00:50:28 <lambdabot>      lexical error in string/character literal at end o...
00:50:29 <kmc> hmm, pl unfolded the definition of (++)
00:50:29 <sinelaw> > (++ " ") "ah"
00:50:30 <lambdabot>   "ah "
00:50:38 * tensorpudding is broken
00:50:41 <aavogt> @pl what is this ++ (++ mess ++ yeah? ++ !! .  . ... ??)
00:50:41 <lambdabot> (line 1, column 18):
00:50:42 <lambdabot> unexpected "+"
00:50:42 <lambdabot> expecting lambda abstraction or expression
00:50:49 <MissPiggy> tensorpudding, but also there is quite a strong limitation on what you can do with them
00:50:58 <sinelaw> @pl (\f x y -> x `f` " " `f` y)
00:50:58 <lambdabot> ap (.) (flip flip " ")
00:51:08 <sinelaw> @pl (\x y -> x `f` " " `f` y)
00:51:08 <lambdabot> f . (`f` " ")
00:51:12 <tensorpudding> hmm, i need to read that new post by sigfpe
00:51:28 <aavogt> @pl \x -> flap (g x) x
00:51:28 <lambdabot> flap =<< g
00:51:41 <c_wraith> I'm sad that you can't use deriving with GADTs that aren't legal H98 types
00:51:52 <Peaker> @bot
00:51:53 <lambdabot> :)
00:51:59 <kmc> hmm, i found some code claiming GHC can do «deriving (Storable)»
00:52:09 <kmc> in a way other than generalized newtype deriving
00:52:13 <kmc> is that documented anywhere?
00:52:50 <sinelaw> > (++) . (++ " ") $ "hi" "there"
00:52:51 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
00:52:51 <lambdabot>         against inferr...
00:53:19 <sinelaw> damn i'm stupid
00:53:25 <sinelaw> :t intersperse
00:53:26 <lambdabot> forall a. a -> [a] -> [a]
00:53:26 <psychobot> Not in scope: `intersperse'
00:53:43 <sinelaw> > intersperse  " " (words "hey there stupid bot")
00:53:43 <lambdabot>   ["hey"," ","there"," ","stupid"," ","bot"]
00:53:51 <copumpkin> aw
00:53:57 <sinelaw> > foldr (++) [] $ intersperse  " " (words "hey there stupid bot")
00:53:58 <lambdabot>   "hey there stupid bot"
00:54:00 <MissPiggy> > intercalate " " (words "hey there stupid bot")
00:54:01 <kmc> > intercalate  " " (words "hey there stupid bot")
00:54:01 <lambdabot>   "hey there stupid bot"
00:54:01 <lambdabot>   "hey there stupid bot"
00:54:04 <sinelaw> ah
00:54:10 <sinelaw> @type intercalate
00:54:10 <lambdabot> forall a. [a] -> [[a]] -> [a]
00:54:24 <kmc> @src concat
00:54:24 <lambdabot> concat = foldr (++) []
00:54:25 <sinelaw> @src intercalate
00:54:25 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
00:54:37 <sinelaw> oh heh
00:54:38 <Peaker> > ((++) . (++ " ") $ "hi") "there"
00:54:39 <lambdabot>   "hi there"
00:54:53 <sinelaw> yeah that too...
00:55:24 <Peaker> @check liftA2 (==) unwords (intercalate " ")
00:55:26 <lambdabot>   "OK, passed 500 tests."
00:55:31 <Peaker> @src unwords
00:55:31 <lambdabot> unwords [] = ""
00:55:31 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
00:56:59 <dankna> I'm trying to update the cgi package to compile on ghc 6.13.  Does anybody have a moment to look at the error message I'm getting and help me interpret it?
00:57:00 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17180#a17180
00:58:26 <dankna> It's a trivial message and I can't help but feel that it should make sense to me, but.
00:59:25 <ozataman> can I use type parameters in type (synonym) declarations?
01:00:43 <mjrosenb> ozataman: like type list a = [a]?
01:00:51 <tensorpudding> Data.Data is some fun stuff
01:01:16 <ozataman> mjrosenb: Ah I see. I guess I need rank 2 types for what I want to do
01:01:29 <ozataman> I was trying something like Type X = Int -> Int -> [a]
01:01:33 <ozataman> (example)
01:01:47 <ozataman> sorry, i meant type x = ...
01:02:11 <ozataman> I need a type parameter on the left hand side also
01:02:17 <mjrosenb> ozataman: all type variables need to be bound
01:02:44 <mjrosenb> and that isn't a rank-2 anything.
01:02:47 <ozataman> mjrosenb: right... so formally speaking, all the type parameters on the right need to be bound by things on the left right?
01:02:54 <ozataman> Well, couldn't I do
01:02:58 <mjrosenb> rank2 would be something like
01:03:03 <ozataman> type X = forall a. Int -> Int -> a
01:03:10 <mjrosenb> type AppInt f = f Int
01:03:34 <mjrosenb> ozataman: yeah, you could do that.
01:03:46 <mjrosenb> ozataman: good luck using the result though
01:06:49 <kamatsu> ah, stupid stupid stupid web. There's not even a reliable way to figure out when a user's selection in a textarea changes, let alone what actual changes a user makes to a textarea
01:07:22 <kamatsu> sorry, </offtopic>
01:14:26 <MissPiggy> is it just me or is editline a bug dodgy?
01:20:12 <Peaker> ozataman: did you figure it out?
01:20:24 <Peaker> ozataman: it's more likely you just want something like type Blah a = a -> a
01:21:03 <ozataman> Peaker: Yeah, I did. I guess I'm still not 100% clear on the implications of tings like Int -> Int -> a
01:21:05 <ozataman> for example
01:21:21 <ozataman> Num a => CustomType => CustomType => a
01:21:25 <ozataman> oh sorry
01:21:37 <ozataman> Num a => CustomType -> CustomType -> a
01:21:42 <ozataman> trying to see where something like this could be used
01:21:44 <copumpkin> you can't write Int -> Int -> a
01:21:45 <sinelaw> is there something like ByteString that has O(1) append?
01:21:57 <sinelaw> (bytestring docs says they do memcpy)
01:22:00 <ozataman> does this give me the freedom now to have a as Double or Int depending on the situation?
01:22:02 <copumpkin> sinelaw: lists, when seen backwards
01:22:04 <Heffalump> even lazy bytestrings?
01:22:36 <sinelaw> copumpkin, but i want it to also be packed
01:22:47 <copumpkin> sinelaw: bytestrings, when seen backwards, then
01:22:54 <copumpkin> lazy ones, of course
01:22:58 <sinelaw> hmm
01:23:13 <copumpkin> I think yi uses a rope structure
01:23:20 <copumpkin> maybe even built on a fingertree
01:23:21 <copumpkin> dunno
01:23:32 <Peaker> ozataman: You can use:  type Blah a b = b -> b -> a
01:23:46 <ozataman> copumpkin: is [x] ++ oldList O(1) ?
01:23:46 <Peaker> ozataman: then:  Blah Int String or Blah Int Double
01:23:52 <ozataman> Peaker: x is a single element
01:23:55 <ozataman> Peaker: MT
01:24:04 <copumpkin> ozataman: sure
01:24:06 <Peaker> ozataman: ?
01:24:15 <ozataman> Peaker: Sorry Peaker, I meant that for copumpkin
01:24:16 <copumpkin> ozataman: why would you do that and not x : oldList?
01:24:38 <ozataman> copumpkin: Oh i would prefer x : oldList... that is O (1) as well, right?
01:24:52 <copumpkin> yep, it's a constructor :)
01:24:59 <ozataman> copumpkin: right :)
01:25:24 <ozataman> copumpkin: Just wanted to make sure I don't confuse it with oldList ++ [x], where it becomes O(N)
01:26:15 <copumpkin> ah :)
01:26:17 * copumpkin goes to sleep
01:29:45 <Taejo> Below the thunders of the imperative deap; / Far far beneath the hideous C, / His ancient purely functional sleep / Copumpkin sleepeth...
01:40:35 <adept> Hi. Could anyone help explain this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17183#a17183 ?
01:40:55 <adept> I refuse to believe that Array is broken in such fundamental way
01:41:05 <adept> I must be wrong somewhere. But where?
01:41:31 <adept> (this is ghci from GHC 6.10.4)
01:47:19 <Twey> adept: What's wrong with it?
01:49:32 <adept> Twey: for starters, why second command produces empty array? Why first command consumes only 5 chars?
01:49:56 <Twey> The first array consumes only five chars because it has only five places
01:50:00 <adept> Twey: why "bounds" report proper bounds, but "range" produces empty list from them?
01:50:08 <Twey> Consuming any more would result in a segfault
01:50:45 <Twey> The second example produces an empty array, and â€˜rangeâ€™ produces an empty list from its bounds, because (1, 2) is before (1, 5)
01:50:50 <adept> Twey: hm. I was under impression that array bounds are closed ranges, so ((1,5),(1,2)) is a 5-column, two-row array
01:51:03 <Twey> Both array bounds are inclusive
01:51:16 <adept> omg
01:51:19 <adept> I got it
01:51:30 <adept> I must be too much C++ tonight :(
01:51:37 <Twey> â˜º
01:51:48 * adept is crawling back under the rock
02:08:17 <ricree> I think I need a function that takes a type and a normal value as arguments, and returns a boolean if the value's type is the type specified by the first argument
02:08:27 <ricree> is there something like this as a built in function?
02:09:20 <ClaudiusMaximus> @hoogle a -> Maybe b
02:09:20 <lambdabot> Prelude Just :: a -> Maybe a
02:09:21 <lambdabot> Data.Maybe Just :: a -> Maybe a
02:09:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:10:18 <ClaudiusMaximus> @type cast
02:10:19 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
02:11:06 <ClaudiusMaximus> @type \x y -> isJust (cast x `asTypeOf` Just y)
02:11:07 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> b -> Bool
02:11:55 <tensorpudding> ricree: what would the type of that function be?
02:19:29 <Muad_Dibber> Iá¸¿ confused :/ Trying to install lambdabot, but I get this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17190#a17190
02:23:35 <Cale> Muad_Dibber: hmm, perhaps the QuickCheck dep for the show package should be removed. I forget if it's borrowing instances.
02:23:35 <sinelaw> Muad_Dibber, so do i. i eneded up building without running install
02:23:40 <sinelaw> (the build succeeds)
02:23:44 <sinelaw> Cale, did you get my patch, btw?
02:24:00 <Cale> sinelaw: Maybe...
02:24:08 <ricree> ClaudiusMaximus:  Ok, I think I get how that works for testing with one particular type, but is there a way to put that in a function that takes the type to test as an argument?
02:24:25 <Cale> I don't manage the hackage version of lambdabot
02:24:28 <tensorpudding> :t (>>=)
02:24:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:24:30 <psychobot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:24:30 <Cale> gwern does that
02:24:36 <sinelaw> Cale, it's for the darcs
02:24:40 <Cale> ah, okay
02:24:44 <Muad_Dibber> Cale, notice however below that, when I do cabal list show, it lists show-0.3.4 as installed
02:24:50 <sinelaw> i just did darcs send (or whatever that command was)
02:25:05 <Cale> Muad_Dibber: The problem is that it wants to pick a consistent version of QuickCheck
02:25:17 <Muad_Dibber> oh right
02:25:28 <Cale> sinelaw: ah, okay
02:25:38 <Cale> sinelaw: hmm
02:25:55 <Cale> sinelaw: Did it send it to some email address or to the darcs repo?
02:26:05 <sinelaw> Cale, i think it sent it to your gmail
02:26:08 <tensorpudding> what extension do you have to enable to get the (m :: * -> *) in your type signature?
02:26:20 <ClaudiusMaximus> (\x y -> isJust (cast x `asTypeOf` Just y)) 42 (undefined::Int)
02:26:24 <ClaudiusMaximus> > (\x y -> isJust (cast x `asTypeOf` Just y)) 42 (undefined::Int)
02:26:25 <lambdabot>   False
02:26:50 <ClaudiusMaximus> but that doesn't solve the problem, sorry ricree - been awake too long, must go..
02:26:51 <Cale> oh, right
02:27:07 <ricree> ClaudiusMaximus: well thanks for pointing me in the right direction
02:28:19 <Cale> Er, hmm, I don't think I have a recent patch here.
02:28:50 <Cale> There was a lambdabot.cabal that someone sent me which I forwarded to gwern
02:28:58 <sinelaw> that was one thing
02:29:06 <sinelaw> there was also something in lambdabot-utils
02:29:14 <sinelaw> changing Exception to OldException
02:29:21 <sinelaw> it was in the same patch
02:32:05 <sinelaw> Cale, this is what I did with lambdabot, btw
02:32:12 <sinelaw> !markov 5
02:32:12 <psychobot> disproportional programming. The programming* - the high-level semantic functional programming what I did darcs repo? Cale, this involves there was a group
02:32:30 <sinelaw> disproportional programming :)
02:32:38 <Twey> Hehe
02:32:45 <Twey> It's the next big thing
02:33:26 <sinelaw> i added the ability to choose a starting word
02:33:38 <sinelaw> !markov 5 bad
02:33:38 <psychobot> bad
02:33:50 <sinelaw> it needs to learn more
02:35:19 <Twey> Heh
02:35:24 <Twey> What's the number?
02:37:17 <sinelaw> the number of memory cells (how far back do the markov chain probabilties depend on, number of letters)
02:37:33 <Twey> Aha
02:37:36 <sinelaw> !markov 3 bad
02:37:36 <psychobot> bad
03:04:34 <Muad_Dibber> You were right indeed sinelaw;
03:04:51 <Muad_Dibber> cabal configure (manually resolved dependencies), cabal build, and then cabal install also seems to work
03:05:17 <sinelaw> install failed for me, even after succesful build
03:44:45 <Muad_Dibber> Only weird thing now is that my lambdabot responds in private, but not in the channel he is sitting in :-P
03:45:16 <medfly> maybe he is banned
03:45:19 <Axman6> might need to be identified with the server
03:45:19 <medfly> she
03:45:25 <medfly> yeah, that
03:45:27 <medfly> @quote
03:45:28 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
03:46:16 <Axman6> well, they do
03:48:44 <jlouis> rawr!
03:49:00 <Muad_Dibber> Well its an unregistered channel so unless lambdabot itself insists on being identified
03:49:54 <Daerim> lambdabot has been optimized a lot lately. It now replies roughly 2 seconds before the question is asked, which might be what's giving you trouble
03:51:53 <jlouis> Daerim: it does so by running a lazy simulation in the Universe monad of our world and then figuring out (by a probability transformer on top of Universe) what is likely to happen
03:53:00 <medfly> Muad_Dibber, what are you doing?
03:53:33 <Muad_Dibber> I for example do
03:53:35 <Muad_Dibber> > 3 + 3
03:53:36 <lambdabot>   6
03:53:38 <Muad_Dibber> or
03:53:41 <Muad_Dibber> @slap Muad_Dibber
03:53:41 * lambdabot pushes Muad_Dibber from his chair
03:54:05 <Daerim> jlouis, ohh. I thought it just had an "import System.Vodoo", but using the Universe monad seems like a better choice. Fewer goats and all
03:54:48 <Muad_Dibber> either one yields result in pm, but nothingi n the channel. On the terminal I see the same message though ( ["-E","--noimports","-l etc
03:54:55 <Daerim> failspell: "System.Voodoo"
04:06:52 * kamatsu rejoices, because his collaborative editor shows signs of working
04:07:39 <erikc> kamatsu: cool, how is it collaborative?
04:07:59 <jlouis> erikc: operational transform!
04:08:02 <kamatsu> erikc: uses operational transforms a la google wave, although the specifics of the implementation are different, and should allow for more "real-time" typing
04:08:52 <kamatsu> right now it's just a HTML textarea, and the permanent storage thread keeps randomly crashing
04:09:01 <kamatsu> but it has its heart in the right place
04:09:49 <kamatsu> i haven't found any bugs in my composition or operational transforms algorithm which makes me very worried that some exist.
04:09:52 <Daerim> randomly crashing? haskell??
04:10:00 <kamatsu> Daerim: it's interfacing with couchDB
04:10:06 <kamatsu> Daerim: and couchDB somehow borks it
04:10:19 <kamatsu> Daerim: haven't looked into it yet
04:10:51 <Daerim> ohh
04:11:17 <kamatsu> couchDB is written in erlang
04:11:27 <jlouis> erlang is rather nice
04:11:30 <kamatsu> so, i guess erlang likes to randomly crash? ah, i suppose it just seamlessly restarts anyway
04:12:20 <kamatsu> the main issue i have is that catching IO exceptions in haskell is like black magic, and I relied on it in a few places and found that Haskell was evaluating lazily and the exception escapes and crashes the thread
04:12:33 <jlouis> kamatsu: it depends on what crashes
04:12:48 <Saizan> IO exceptions are trivial to catch
04:12:55 <Saizan> pure exceptions are the hard ones.
04:13:12 <kamatsu> hm
04:13:17 <Saizan> but pure exceptions shouldn't be used if you need to catch them.
04:13:22 <kamatsu> right
04:13:37 <kamatsu> that's fine, but couchDB thread keeps crashing even though I explicitly have stuff in there to stop it crashing
04:13:41 <kamatsu> hm
04:13:43 <kamatsu> i'll have to look at it more closely
04:17:07 <cheater3> hey guys, if i'm in ghci and want to define a function with let, how do i declare its type?
04:17:29 <Axman6> let x :: a
04:17:32 <Saizan> let foo :: type; foo = ..
04:17:34 <Axman6> let x = undefined
04:17:42 <cheater3> Saizan: thanks
04:18:11 <Saizan> Axman6: that doesn't work :P
04:18:20 <Axman6> sure?
04:18:29 <Saizan> just tried
04:18:33 <Axman6> hmm, i can see why it wouldn't
04:18:36 <cheater3> Saizan: i tried that, but i got an error. here's the code i tried: let readInt :: (Read a) => String -> a; readInt a = read a
04:19:01 <Saizan> cheater3: which error?
04:19:27 <cheater3>     Ambiguous type variable `a' in the constraint:      `Read a' arising from a use of `readInt' at <interactive>:1:0-12     Probable fix: add a type signature that fixes these type variable(s)
04:20:43 <Saizan> cheater3: that exact same code works in my ghci
04:21:10 <Saizan> cheater3: isn't the problem coming from where you _use_ readInt later?
04:21:29 <cheater3> no
04:21:37 <Saizan> also, by the name i'd think you want readInt :: String -> Int
04:21:37 <cheater3> i paste it in and get this error straight away
04:21:40 <Twey> > let x :: Int in let x = undefined in x
04:21:41 <lambdabot>   The type signature for `x' lacks an accompanying binding
04:21:41 <lambdabot>    (You cannot giv...
04:21:58 <Twey> > do { let x :: Int; let x = undefined; return x }
04:21:59 <lambdabot>   <no location info>: parse error on input `}'
04:22:01 <cheater3> hmm
04:22:07 <cheater3> i just tried it again and it worked
04:22:38 <Twey> readInt = read :: String -> Int
04:22:55 <cheater3> you're right. it comes from when i tried to use it. i must be tired :)
04:23:32 <Saizan> heh, np :)
04:24:15 <cheater3> Twey: that worked well!
04:24:28 <rajeshsr> hi
04:24:31 <rajeshsr> module SimpleJSON
04:24:31 <rajeshsr>     (
04:24:31 <rajeshsr>     JValue (...)
04:24:47 <rajeshsr> is refusing to compile because of (...)
04:24:54 <rajeshsr> on removing that it works..
04:25:00 <Axman6> should be .. i think
04:25:07 <rajeshsr> can anyone explain this?
04:25:18 <Axman6> JValue (..) maybe?
04:25:21 <rajeshsr> Axman6, haha!
04:25:22 <Twey> Only two dots, yeah
04:25:23 <rajeshsr> yeah!!
04:25:25 <Twey> Hehe
04:25:25 <rajeshsr> right!!
04:25:38 <rajeshsr> too much used to ellipsis! :)
04:25:48 <rajeshsr> thanks!
04:25:52 <Twey> There aren't three dots in RWH, are there?
04:28:30 <rajeshsr> Twey, nope! Problem with my perception, after all the eyes tend to see what it wants to see! :)
04:28:36 <Twey> Oh good
04:28:45 <Twey> We'd all be terribly embarrassed if there were
04:33:58 <jlouis> Axman6: beast now compiles on GHC612 again :)
04:34:15 <Axman6> whoot :)
04:34:49 <jlouis> on the negative side, we now have #if mazes :)
04:35:13 <Axman6> oh no :(
04:35:15 <Axman6> how come?
04:38:39 <jlouis> Axman6: GHC changed the name of some exceptions between 610 and 612
04:39:15 <Axman6> are you relying on 6.10?
04:39:28 * Axman6 would be happy to ditch it
04:39:35 <jlouis> Axman6: for as long as that is the haskell-platform on Debian Unstable yes
04:39:59 <Axman6> heh, ok
04:40:17 <jlouis> My other machine has a GHC612, so now I am pondering on buildbot
04:42:15 <jlouis> Axman6: at some point, I am fully 612 as well, but then the buildbot would be nice if someone wants to maintain a 610 version... which is the reason I need a 610 buildbot :P
04:42:33 <Axman6> sounds fair enough :)
04:42:35 <jlouis> but i'll only really worry about it when the problem shows up
04:52:59 <jonaskoelker> Hi all.  What's the haskell-idiomatic way to write randomized algorithms where outcome of the randomness isn't externally visible (i.e. quicksort)?
04:53:02 <jlouis> Daerim: mmm, btw, "import Magic.Divination" works well at times :)
04:53:45 <jlouis> jonaskoelker: thread a random number generator with you through the code
04:53:55 <jonaskoelker> jlouis: but that's a real pain...
04:54:00 <jlouis> monads :)
04:54:22 <jonaskoelker> jlouis: but it's still a real pain.  Suppose I want to switch to merge sort some day...
04:55:15 <jonaskoelker> or, in trying to hide state changes from the calling code, am I trying to use a hammer (haskell) to hammer in a screw (invisible side effects)?
04:55:47 <jlouis> jonaskoelker: the random state is, after all, state.
04:56:04 <jonaskoelker> yeah, but it doesn't affect the computation, as seen from the outside...
04:56:46 <jonaskoelker> isn't there some merit to hiding the internal state?
04:57:07 <Axman6> evil merit
04:57:13 <jonaskoelker> How so?
04:57:29 <jlouis> jonaskoelker: you can hide the internal state when you run the monad
04:57:48 <jonaskoelker> (mind you, I don't claim to know what The Right Way is---I'm just trying to bounce an idea offa' some of you who might inspire me)
04:58:35 <jonaskoelker> jlouis: and (AIUI) that pulls all of my code that sorts lists into the monad, and some day I might pull it out again, and I'll have to do that manually
04:58:53 <jonaskoelker> jlouis: you don't see a problem in this?  Or do you think the benefits of honesty about side effects outweigh the negatives?
04:59:22 <c_wraith> jonaskoelker: you can easily hide the use of state within your algorithms.  what's not so easy is hiding acquisition of a random seed.
04:59:36 <c_wraith> jonaskoelker: because anything that gets a real random seed is necessarily IO
05:00:08 <jonaskoelker> c_wraith: right...
05:00:57 <rajeshsr> hi
05:01:02 <c_wraith> jonaskoelker: your options are to pass in an initial state of the random generator, or to work in IO.  This isn't even a case where you can cheat with unsafePerformIO
05:01:07 <rajeshsr> i see something like this in RWH:  Nothing | mustEscape c -> hexEscape c
05:01:26 <jonaskoelker> c_wraith: can't I grab the random seed and/or work on a Ref with unsafe io?
05:01:27 <rajeshsr> guard is used inside case. I thought guards can be used only in function definition..
05:01:47 <jlouis> jonaskoelker: I'd start off with a state-variant monad containing the random seed and a way to run :: MonadRandom a -> Seed -> a
05:01:54 <rajeshsr> now i don't understand why guards here? and how it works?
05:01:57 <c_wraith> jonaskoelker: unsafePerformIO results in a value that the compiler treats as pure. That means it won't recalculate it
05:02:06 <jlouis> then I'd lift the random gen from IO into this when running it
05:02:49 <jlouis> jonaskoelker: in general, implicit type+effect systems are reaally interesting but they are on the drawing board more than real at the moment
05:03:18 <jlouis> jonaskoelker: and yes, they would solve your problem
05:05:07 <jlouis> rajeshsr: which chapter?
05:05:59 <rajeshsr> jlouis, http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
05:06:17 <rajeshsr> jlouis, look at oneChar definition
05:06:28 <rajeshsr> it uses guards inside a case expression..
05:06:57 <jlouis> rajeshsr: yes, that is allowed
05:07:26 <jonaskoelker> jlouis: so the type of quicksort would be something like "forall a. comparable a => [a] -> [a]; and I write to memory region %r0, and %r0 is disjoint from 'everything else'"?
05:07:28 <rajeshsr> jlouis, so guards can be used to check for conditions anywhere?
05:07:36 <sinelaw> !part
05:07:36 <psychobot> Plugin `system' failed with: Prelude.last: empty list
05:07:51 <rajeshsr> or they alternative for if else if.. etc.?
05:07:54 <jlouis> rajeshsr: indeed! it is like having an if..then..else
05:07:58 <jonaskoelker> jlouis: and the rest of my code can rest, assured that it won't get it's pure data overwritten by my nasty evil quicksort?
05:08:12 <rajeshsr> jlouis, oh, cool! ok thanks
05:08:35 <cheater3> hey guys, () is in the Enum typeclass, right?
05:08:36 <jlouis> rajeshsr: it is just more convenient to write that at times
05:08:55 <jlouis> cheater3: check it with hoogle :)
05:08:55 <rajeshsr> still, i son't get Nothing -> someExpr, should be there, right?
05:09:02 <cheater3> jlouis: i don't know how to
05:09:08 <cheater3> i've never used it
05:09:12 <rajeshsr> how a guard before ->
05:09:13 <rajeshsr> ?
05:09:18 <cheater3> what is hoogle jlouis?
05:09:36 <c_wraith> > fromEnum 0 :: ()
05:09:37 <lambdabot>   Couldn't match expected type `()'
05:09:38 <lambdabot>         against inferred type `GHC.Types....
05:09:40 <Stinger> google hoogle
05:09:46 <jonaskoelker> hoogle is a search engine for haskell functions, data, classes, etc.
05:09:48 <domor> @google hoogle
05:09:49 <lambdabot> http://www.haskell.org/hoogle/
05:09:49 <lambdabot> Title: Hoogle
05:09:52 <c_wraith> > toEnum 0 :: ()
05:09:53 <lambdabot>   ()
05:09:55 <Stinger> then theres hayoo
05:09:57 <jlouis> cheater3: http://www.haskell.org/hoogle/ type in Enum ... click a bit around, find http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html#t%3AEnum
05:10:00 <jonaskoelker> !hoogle (a -> b) -> [a] -> [b]
05:10:00 <psychobot> A Hoogle error occurred.
05:10:13 <jonaskoelker> !hoogle "(a -> b) -> [a] -> [b]"
05:10:13 <psychobot> A Hoogle error occurred.
05:10:14 <cheater3> jlouis: great! will do
05:10:27 <dozu> hey guys. ive problem. i want to create a function that returns me a number of a char in a string like "numChar :: Char -> [Char] -> Int" but with list comprehension. any tips?
05:10:33 <domor> @hoogle (a -> b) -> [a] -> [b]
05:10:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:10:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:10:33 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
05:10:41 <rajeshsr> jlouis, Nothing -> | mustEscpae c = hexEscape c | otherwise = char c
05:10:43 <domor> looks like the bot is a bit broken
05:10:44 <jlouis> jonaskoelker: type-n-effect systems decouples the effect from the type, so you can implicitly have code with no effects mingled with code that might have an effect
05:10:54 <rajeshsr> makes more sense to me, am not sure if that is even allowed though!
05:11:14 <jonaskoelker> domor: ah, the @.  Thanks
05:11:24 <jlouis> rajeshsr: the "otherwise" is a hack
05:11:32 <c_wraith> > otherwise
05:11:33 <lambdabot>   True
05:11:47 <cheater3> jlouis: actually.. i just searched for Enum and did not find the link you mention in the results
05:11:53 <cheater3> jlouis: why is that?
05:11:58 <jonaskoelker> jlouis: ... can I have the compiler verify claims about which effects might interact with which other effects?
05:12:05 <rajeshsr> jlouis, nope, am talking about Nothing -> Vs Nothing | condition -> as in RWH
05:12:14 <jlouis> cheater3: hoogle is bad at times
05:12:15 <rajeshsr> the latter is quite unintuitive!
05:12:23 <cheater3> bad, bad hoogle
05:12:39 <Daerim> c_wraith, incidently, why couldn't you use unsafePerformIO in this case?
05:12:40 <jlouis> rajeshsr: Nothing without something will match if the thing we are looking at is Nothing
05:12:46 <jlouis> without a guard
05:13:11 <jlouis> Nothing with a guard will only match if we are looking at Nothing and the guard evaluates to true. If not, the next pattern is tried
05:13:37 <cheater3> ok, if () is Enum, then why can't i do succ ()?
05:13:40 <cheater3> > succ ()
05:13:41 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
05:14:10 <rajeshsr> so now comes a big question! Where are guards allowed? It could be used *only* with pattern matching anywhere?
05:14:17 <lenstron> hi all
05:14:40 <jlouis> rajeshsr: in function definitions and case expressions for starters. I am not aware if there are more places
05:15:04 <c_wraith> Daerim: the compiler is fully willing to treat expressions involving unsafePerformIO as pure, meaning they could be floated.  This seems like a case where the compiler might float fetching the initial state, so that it could end up using the same seed every time.  In that case, you might as well just hardcode an initial state.
05:15:20 <rajeshsr> jlouis, oh, ok! thanks! i guess we can generalize tat as with pattern matching! I guess in no other place we do pattern matching..
05:15:36 <domor> dozu: any reason for the list comprehension instead of filter?
05:15:42 <c_wraith> > succ maxBound
05:15:44 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
05:15:48 <jlouis> cheater3: because it is coded that way: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/GHC-Enum.html#Enum
05:15:51 <c_wraith> > succ maxBound :: Int
05:15:52 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
05:15:55 <dozu> domor : i did it with filter already
05:16:04 <jlouis> cheater3: search for "instance Enum ()"
05:16:07 <dozu> domor : i want to try it with LC
05:16:17 <c_wraith> cheater3: in general, you're not allowed to take the successor of the maximum of a bounded type.
05:16:18 <dozu> but cant figure it out :(
05:16:28 <cheater3> ah, so you're just saying that maxBound :: () is ()
05:16:28 <cheater3> ok
05:16:41 <c_wraith> > maxBound :: ()
05:16:42 <lambdabot>   ()
05:16:47 <cheater3> makes sense
05:16:57 <c_wraith> > minBound :: ()
05:16:58 <lambdabot>   ()
05:17:11 <Daerim> c_wraith, arff :S Guess it's a case where you might want to use an internal random number gen
05:17:41 <cheater3> does haskell have exceptions?
05:18:36 <domor> dozu: length [ a | a <- str, str == c]
05:18:52 <jlouis> jonaskoelker: type+effect systems are more subtle than that. The point is that you can use effect-free computations in effectful worlds without having to resort to putting them inside a monad explicitly.
05:19:04 <dozu> domor : ty . looks actually easy :)
05:19:12 <jlouis> jonaskoelker: but unfortunately, there are almost no real-world systems supporting things like that :/
05:19:43 <jonaskoelker> jlouis: don't you mean 'use effectful computations in effect-free worlds'?
05:19:56 <jonaskoelker> jlouis: that's the description I'd use for what I want to do
05:20:10 <jlouis> jonaskoelker: no, it is the other way around.
05:20:15 <jonaskoelker> jlouis: hm...
05:20:27 <jlouis> jonaskoelker: you can lift effect-free computation to effectful ones
05:20:49 <jonaskoelker> jlouis: ah, so you can use map instead of mapM?
05:21:03 <jlouis> jonaskoelker: yes
05:21:11 <Daerim> cheater, short answer is yes. Long answer is "too many of them". "error" is one, but it's a stop-the world exception. You can't catch it
05:21:13 <dozu> domor : but in case of your answer. how str could be == c?
05:21:26 <c_wraith> :t spoon
05:21:27 <lambdabot> Not in scope: `spoon'
05:21:27 <psychobot> Not in scope: `spoon'
05:21:46 <jonaskoelker> jlouis: ah, I think I have my thinking inverted.  I think of the, say, printf being mapped as happening inside the map, where I should think of the map happening inside the IO monad
05:21:47 <shambler> :t cake
05:21:48 <lambdabot> [[Char]]
05:21:48 <psychobot> Not in scope: `cake'
05:21:52 <jonaskoelker> jlouis: right?
05:22:16 <jlouis> jonaskoelker: and in principle, you can compile the code such that the effects are handled with efficiency
05:22:32 <jlouis> jonaskoelker: right, like that
05:23:06 <jlouis> jonaskoelker: even more interesting, it would seem the effects admit a subtyping hiearchy
05:23:18 <domor> dozu: it just means "let a be str, when the str is equal to c", it's a bit like saying "let even numbers be the integers, when the integers are dividable by 2"
05:23:36 <jlouis> jonaskoelker: if you are interested, Filinskis POPL 2010 paper "Monads in Action" has more
05:24:00 <domor> > length [ a | a <- "abbcccdddd", a == 'c' ]
05:24:01 <lambdabot>   3
05:24:36 <dozu> domor : freaky :D ty
05:25:40 <benmachine> domor: your original thing should've been [a | a <- str, a == c] I think
05:25:40 <medfly> hehe
05:26:26 <domor> > length [ a | a <- "abbcccdddd", "abbcccdddd" == 'c' ]
05:26:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:26:28 <lambdabot>         against inferred ty...
05:26:44 <jonaskoelker> jlouis: cool, I'll look at it
05:26:55 <domor> > let b = "abbcccdddd" in length [ a | a <- b, b == 'c' ]
05:26:56 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:26:56 <lambdabot>         against inferred ty...
05:27:02 <jonaskoelker> jlouis: thanks for the discussion, it was (just about) exactly what I was wishing for :)
05:27:03 <domor> I think you're entirely right there
05:27:17 <medfly> @let myfilter f list = [a | a <- list, f a]
05:27:18 <lambdabot>  Defined.
05:27:36 <jlouis> jonaskoelker: you might get it in a couple of years.
05:27:40 <jonaskoelker> jlouis: ^_^
05:28:02 <benmachine> p.s. http://hackage.haskell.org/packages/archive/data-ordlist/0.2/doc/html/Data-List-Ordered.html#v%3Asort if we click on "show source" for sort and sortBy, we get a 404
05:28:13 <benmachine> because they're not in that package at all, they are re-exported from base
05:29:38 <cheater3> Daerim: thanks
05:29:57 <benmachine> > cake
05:29:59 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
05:30:02 <benmachine> oic
05:30:45 <domor> @faq Will there be cake?
05:30:45 <lambdabot> The answer is: Yes! Haskell can do that.
05:30:57 <lenstron> heh
05:32:32 <jonaskoelker> lol @ cake
05:32:55 <jonaskoelker> the cake is a Lie a -> ()
05:32:56 <jlouis> > cake !! 3
05:32:58 <lambdabot>   "Four large eggs."
05:33:03 <jlouis> > cake !! 5
05:33:07 <lambdabot>   "Three slash four cups butter or margarine."
05:33:26 <wto> I didn't know that lambdabot contained recipes :o
05:33:29 <jonaskoelker> > cake
05:33:30 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
05:34:02 <jlouis> @vixen do you haz cake recipez?
05:34:06 <lambdabot> yes i do
05:34:19 <jlouis> \o/
05:34:22 <osaunders> How might I resolve this problem? http://codepad.org/KGsKLqhF
05:34:48 <jonaskoelker> > length cake
05:34:49 <lambdabot>   42
05:34:52 <jonaskoelker> that's a biiig cake
05:35:06 <domor> > last cake
05:35:07 <lambdabot>   "That will deodorize and preserve putrid tissue."
05:35:12 <domor> :o
05:35:17 <jonaskoelker> > cake !! 12
05:35:18 <lambdabot>   "Fish shaped dirt."
05:35:18 <xerox> hahaha
05:35:24 <jonaskoelker> > cake !! 13
05:35:25 <lambdabot>   "Fish shaped ethylbenzene."
05:35:29 <jonaskoelker> :)
05:42:31 <Vitka> > let f a = if all ((==) `on` fst) a == True then (fst $ head a, map snd a) else error "Aargh!!!!" in f [(0,1),(0,2)]
05:42:32 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:42:32 <lambdabot>         against inferred type ...
05:42:45 <dixie> > ord '*'
05:42:46 <lambdabot>   42
05:43:57 <dixie> the ultimate question was - what is the ascii value of the star? :)
05:44:30 <juhe> hello, where can I find Data.Array.Diff package for ghc-6.12.1? I couldn't find it on hackage...
05:44:38 <Vitka> > let f a = if (all ((==) `on` fst) a) == True then (fst $ head a, map snd a) else error "Aargh!!!!" in f [(0,1),(0,2)]
05:44:39 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:44:39 <lambdabot>         against inferred type ...
05:44:59 <benmachine> Vitka: (==) `on` fst is binary but all expects a unary function
05:45:42 <benmachine> :t zipWith ((==) `on` fst) <*> tail
05:45:43 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [Bool]
05:45:44 <psychobot> Not in scope: `on'
05:45:45 <Vitka> Hmm, so how would I go about testing if fst's of list of pairs are equal?
05:45:53 <benmachine> :t and . zipWith ((==) `on` fst) <*> tail
05:45:54 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
05:45:54 <lambdabot>     In the first argument of `(.)', namely `and'
05:45:54 <lambdabot>     In the first argument of `(<*>)', namely
05:45:54 <psychobot> Not in scope: `on'
05:46:00 <benmachine> fff
05:46:22 <Vitka> Hmm.
05:46:30 * benmachine isn't sure why that didn't work
05:47:40 <benmachine> oh
05:47:45 <benmachine> :t and . (zipWith ((==) `on` fst) <*> tail)
05:47:46 <lambdabot> forall a b. (Eq a) => [(a, b)] -> Bool
05:47:46 <psychobot> Not in scope: `on'
05:47:56 <benmachine> who is this psychobot anyway
05:48:32 <Raevel> why do you need the <*> tail?
05:48:48 <benmachine> @unpl zipWith ((==) `on` fst) <*> tail
05:48:48 <lambdabot> ((zipWith (on (==) fst)) <*> tail)
05:48:53 <Raevel> oh.
05:48:54 <benmachine> what :/
05:49:05 <benmachine> umm
05:49:08 <Raevel> n/m
05:49:08 <benmachine> basically
05:49:14 <benmachine> > zip <*> tail $ [1,2,3]
05:49:15 <lambdabot>   [(1,2),(2,3)]
05:49:18 <benmachine> that's the idea
05:49:34 <benmachine> it zips the list with its tail
05:49:45 <benmachine> @quote aztec
05:49:45 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:50:03 <benmachine> ^ this is basically how I remember how ap works on functions
05:50:10 <cheater3> hey guys, what are some big computers running haskell apps?
05:50:29 <Vitka> Hmm.
05:50:53 <cheater3> clusters of 1000s of nodes perhaps?
05:50:54 <cheater3> :)
05:51:05 * cheater3 has no idea.. only ever heard of his own pc running haskell
05:51:17 <Vitka> I still don't get it.
05:51:27 <benmachine> which bit?
05:51:45 <benmachine> there are a lot of bits that I explained terribly or not at all so I need to know which in particular confuses you
05:52:10 <cheater3> Vitka: how about generating a list of fst's with a list comprehension?
05:52:21 <cheater3> Vitka: and then you can probably iterate over the list checking for equality?
05:52:49 <benmachine> generating a list of fsts is the easy bit
05:53:02 <benmachine> iterating over the list is actually also easy but less obviously so :P
05:53:08 <Vitka> What I'm trying to do in the end is to fold a list of pairs with equal fsts to a tuple of fst and list of snds.
05:53:24 <benmachine> well
05:53:47 <benmachine> > zipWith (==) xs (tail xs) [1,1,2,3,3,4]
05:53:48 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
05:53:51 <benmachine> oops
05:54:01 <benmachine> > (\xs -> zipWith (==) xs (tail xs)) [1,1,2,3,3,4]
05:54:02 <lambdabot>   [True,False,False,True,False]
05:54:12 <benmachine> > (\xs -> zipWith (==) xs (tail xs)) [1,1,1,1,1]
05:54:13 <lambdabot>   [True,True,True,True]
05:54:18 <cheater3> Vitka: use a list comprehension for the list of fst's and tail's
05:54:21 <benmachine> > (\xs -> zipWith (==) xs (tail xs)) [1,3,4,5]
05:54:22 <lambdabot>   [False,False,False]
05:54:27 <benmachine> don't use list comprehensions!
05:54:31 <benmachine> well you can do if you like
05:54:43 <cheater3> benmachine: would they perform worse?
05:54:44 <benmachine> but imo they don't usually help except for some specific pattern matching tasks
05:54:55 <benmachine> cheater3: no they're just not as easy to re-use or understand
05:55:27 <cheater3> how is that difficult to understand? fstOfList l = [ fst a | a <- l ]
05:55:41 <benmachine> I find fstOfList = map fst much simpler
05:56:00 <cheater3> i've written less than 10 haskell functions in my life and i find this list comprehension dead easy to understand :p
05:56:25 <benmachine> yes but map fst is more re-usable, more generalisable, more easily modifiable
05:56:28 <benmachine> imo
05:56:30 <cheater3> i guess map fst could be nice too, if i were that far with my comprehension of the haskell function library :)
05:56:37 <benmachine> and in a more logical order
05:56:43 <cheater3> ok :)
05:56:46 <benmachine> but
05:56:48 <Vitka> Hmm, how about unzip, then fold list of fsts if equal, then make tuple of it and second list.
05:56:49 <benmachine> that's my opinion
05:57:08 <benmachine> Vitka: that's a pretty good way of doing it yeah
05:57:14 <benmachine> probably simpler than my way
05:59:41 <kamatsu> Okay, browser crappiness and DOM crappiness has lead me to desperation
05:59:48 <kamatsu> I'm going to implement my own editor widget in Canvas
06:00:11 <kamatsu> the problem is, that means alot more JS code I have to write
06:00:15 <kamatsu> JS makes me mad
06:01:26 <Raevel> you need crazy good wrappers to survive :-s
06:01:51 <ClaudiusMaximus> > M.toList . M.fromListWith (++) . map (second (:[])) $ zip "cubiczirconium" "blahblahblah"
06:01:53 <lambdabot>   [('b',"a"),('c',"bbb"),('i',"hah"),('n',"a"),('o',"l"),('r',"h"),('u',"l"),...
06:02:26 <JCarrington> Hey, I've got a really stupid question
06:02:33 <JCarrington> How do you stick two chars together?
06:02:37 <benmachine> into a String?
06:02:40 <JCarrington> Yep
06:02:47 <danderson> [a,b]
06:02:47 <benmachine> [a, b] would do it
06:02:57 <danderson> String is just an alias for [Char]
06:02:57 <JCarrington> I'm trying to turn an integer into a String without using the show method
06:03:02 <benmachine> > ['a', 'c']
06:03:03 <lambdabot>   "ac"
06:03:23 <edwtjo> does anyone know if the new i/o manager for ghc is set for any specific version?
06:03:30 <Zao> JCarrington: Divide and conquer?
06:03:33 <JCarrington> Cheers I'll give that a shit
06:03:37 <JCarrington> shot* even
06:03:39 <JCarrington> oops
06:03:42 <benmachine> :P
06:03:55 <Raevel> awesome
06:07:53 <Daerim> Does FieldTrip have known issues compiling on ghc  6.10.4?
06:22:21 <Vitka> @pl (tail a) /= head a
06:22:21 <lambdabot> tail a /= head a
06:22:28 <Vitka> oops
06:22:34 <LeoD> @pl \a -> tail a /= head a
06:22:35 <lambdabot> liftM2 (/=) tail head
06:22:42 <Vitka> @pl any ((tail a) /= head a) a
06:22:42 <lambdabot> any (tail a /= head a) a
06:22:48 <LeoD> ;p
06:22:53 <Vitka> :\
06:23:02 <LeoD> @pl \a -> any (tail a /= head a) a
06:23:02 <lambdabot> any =<< liftM2 (/=) tail head
06:23:39 <mauke> that code makes no sense
06:24:33 <Vitka> Just trying to check if list consists of equal elements.
06:24:47 <mauke> :t \a -> any (tail a /= head a) a
06:24:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
06:24:49 <lambdabot>       Expected type: [a]
06:24:49 <lambdabot>       Inferred type: a
06:24:49 <psychobot>     Occurs check: cannot construct the infinite type: a = [a]
06:24:49 <psychobot>       Expected type: [a]
06:24:49 <psychobot>       Inferred type: a
06:25:05 --- mode: ChanServ set +o mauke
06:25:05 --- kick: psychobot was kicked by mauke (psychobot)
06:25:35 <mauke> :t \a -> all (== head a) a
06:25:37 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:25:54 <Zao> Rumor has it that mutually exclusive bot glyphs are a good idea.
06:26:05 <doserj> :t length (nub a) <= 1
06:26:06 <lambdabot>     Ambiguous occurrence `a'
06:26:06 <lambdabot>     It could refer to either `L.a', defined at <local>:8:0
06:26:06 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:74:0-32
06:26:14 <doserj> :t \a -> length (nub a) <= 1
06:26:15 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:26:18 <Vitka> :t \a -> any (/= head a) a
06:26:19 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:26:37 <Vitka> @pl \a -> any (/= head a) a
06:26:37 <lambdabot> any =<< (/=) . head
06:26:47 <mauke> @undefine
06:27:05 --- mode: mauke set -o mauke
06:28:21 <Vitka> > let f a = if (any =<< (/=) . head) a then True else False in f [1,1,1,1,1]
06:28:22 <lambdabot>   False
06:28:42 <Vitka> > let f a = if (any =<< (/=) . head) a then True else False in f [1,1,1,2,1]
06:28:43 <lambdabot>   True
06:36:31 <Vitka> > foldr (==) [1,1,1,1,1]
06:36:32 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:36:33 <lambdabot>         against inferred type ...
06:36:45 <emijrp> [1..10]
06:36:49 <emijrp> > [1..10]
06:36:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:37:07 <emijrp> no limit?
06:37:21 <Vitka> > [1..]
06:37:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:37:46 <emijrp> ;)
06:39:51 <Vitka> > foldr (\x y -> if x == y then () else error "oops") [1,1,1,1,1]
06:39:52 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
06:40:02 <Vitka> > foldr (\x y -> if x == y then [] else error "oops") [1,1,1,1,1]
06:40:03 <lambdabot>   * Exception: oops
06:40:49 <Vitka> > foldr (\x y -> if x == (y || []) then [] else error "oops") [1,1,1,1,1]
06:40:50 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:40:50 <lambdabot>         against inferred type ...
06:53:48 <Daerim> anyone know anything about FieldTrip, and when it might work again?
06:56:18 <Philonous> > foldl compare EQ [LT,EQ,GT]
06:56:19 <lambdabot>   EQ
06:57:15 <Vitka> @pl \x -> (a,x)
06:57:15 <lambdabot> (,) a
06:57:22 <Peaker> Daerim, FieldTrip is pretty cool.. What's broken with it now?
06:57:49 <Daerim> Peaker, apparently it cannot compile with the current openGL bindings
06:58:09 <Daerim> seems to be a general problem, and I of
06:58:16 <Peaker> Daerim, bummer :(  Maybe you can send conal a patch? :)
06:58:34 <Daerim> *and I found a mail-list saying he was working on it, but it was a while ago
06:58:48 <Zao> You should clearly port it to my DirectX bindings, once I get them released :P
06:59:34 <Daerim> Peaker, I was gonna use FieldTrip to visualize some CT data, so I  wouldn't have to touch the nasty OpenGL stuff :p I guess I could take a look at patching it, but it's a bit out of my league I'm afraid
07:00:09 <Peaker> Zao, Maybe you can write an abstraction layer that makes GLUT/OpenGL both easy to use and interchangable with Direct3D?
07:00:25 <Vitka> @pl if (any =<< (/=) . head) a then False else True
07:00:26 <lambdabot> if' (any (head a /=) a) False True
07:00:34 <Twey> Haha
07:00:53 <Twey> Vitka: The expression you provide has to have argument.s
07:00:58 <Twey> arguments.**
07:01:14 <Twey> @pl \a -> if (any =<< (/=) . head) a then False else True
07:01:14 <lambdabot> flip (flip if' False . (any =<< (/=) . head)) True
07:01:25 <Vitka> Ugh.
07:01:52 <Vitka> That doesn't make it more readable. :)
07:02:04 <Twey> Of course, the correct answer is simply â€˜join $ any . ((/=) . head)â€™
07:02:21 <Twey> It wasn't smart enough to get rid of your redundant if
07:02:33 <Vitka> ..neither this one. :)
07:03:05 <Twey> Vitka: Ah, that's just lack of practice :Ã¾
07:03:55 <nainaide> I am wondering how to writh this do block in bind mode? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17223#a17223  Thanks
07:04:02 <Vitka> I'll settle for what lambdabot suggested first, still too scared of monads.
07:04:15 <Vitka> It hides them at least.
07:04:54 <Twey> Oh, I thought that was in your original
07:04:58 <Twey> What was the original?
07:05:01 <Saizan> @undo do s <- openSerial "/dev/ttyUSB0" defaultSerialSettings; forM_ "AT+CMGL=\"ALL\"\r" $ sendChar s; response <- unfoldM (recvChar s); print response;  closeSerial s
07:05:01 <lambdabot> openSerial "/dev/ttyUSB0" defaultSerialSettings >>= \ s -> forM_ "AT+CMGL=\"ALL\"\r" $ sendChar s >> unfoldM (recvChar s) >>= \ response -> print response >> closeSerial s
07:05:46 <nainaide> Saizan,  Thanks, nice robot!!!
07:05:48 <Vitka> "if (any =<< (/=) . head) a then False else True"
07:06:42 <Twey> See, you had a monad usage already
07:07:06 <Vitka> That was @pl'd somewhat already.
07:07:12 <Philonous> @src (->) (=<<)
07:07:12 <lambdabot> Source not found. You speak an infinite deal of nothing
07:07:13 <Vitka> I wouldn't dare. :P
07:07:17 <Twey> But you understand that that's just â€˜(any =<< (/=) . head) aâ€™ already, don't you?
07:07:18 <Philonous> @src (->) (>>=)
07:07:18 <lambdabot> f >>= k = \ r -> k (f r) r
07:07:31 <Twey> if x then True else False is exactly equivalent to x
07:07:54 <nainaide> Saizan, Can I install something can do the @undo do ... ?
07:07:58 <Philonous> Twey: It's the other way around, so not $ ...
07:08:03 <nainaide> I mean in GHCI
07:08:17 <Twey> Philonous: Sorry?
07:08:32 <Twey> Oh, way back up there
07:08:39 <Philonous> Twey: If I'm not mistaken the code said if x than False else True
07:08:47 <Twey> Oh
07:08:48 <Twey> Yeah
07:08:50 <Twey> â€˜notâ€™, then
07:09:04 <Twey> â€˜not . (any =<< (/=) . head) aâ€™
07:09:10 <Twey> Argh
07:09:13 <Twey> â€˜not $ (any =<< (/=) . head) aâ€™
07:09:16 <halcyon10> hi, i just installed ghc 6.12.1 and cabal 0.8 + cabal-install on mac os x. Now when i want to install QuickCheck 2.1.0.3 it tells me: "cannot configure QuickCheck-2.1.0.3. It requires ghc -any
07:09:16 <halcyon10> There is no available version of ghc that satisfies -any". Does anybody have a clue for how to make this work?
07:09:29 <Saizan> nainaide: not really, but you can open a query with lambdabot
07:10:02 <nainaide> Saizan, I see, thanks.
07:10:04 <Vitka> Hmm.
07:10:42 <Saizan> halcyon10: you mean Cabal-1.8.0 and cabal-install-0.8.0 ?
07:11:07 <halcyon10> Saizan: yes, sorry for the typo
07:11:32 <Philonous> Vitka: Monads are really not scary, if you know what a type class is. It's just a special type class with some very convenient functions for some data structurs (functions happen to be among them). You can just lookup the according definition of return and (>>=) and replace every occurance of them with their definition (in you mind) and you will be golden
07:12:18 <Zeiris> Monads become much less scary when you realize they're just a type.
07:12:27 <Saizan> halcyon10: "ghc-pkg list ghc" returns some results? does "cabal list --installed ghc" ?
07:12:34 <Zeiris> They're not some magical part of haskell - just a natural result of the powerful type system.
07:12:48 <Philonous> Zeiris: a type class, rather than a type, I'd day
07:12:55 <Zeiris> Well, yes :)
07:13:26 <Vitka> I tried and didn't found it's best approach to me, I think a better way would be going up typeclassopedia from Functor, but in actual coding I have to deal with monads right from start.
07:13:28 <halcyon10> Saizan: ghc-pkg returns: WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
07:13:28 <halcyon10>    ghc-6.12.1
07:13:32 <Saizan> using the (->) r monad for pointfree purpouses is surely scarier than monads in general
07:13:54 <halcyon10> and /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.1/package.conf.d
07:13:56 <Saizan> halcyon10: ah, run that "ghc-pkg check" then
07:17:08 <Vitka> @pl not $ (any =<< (/=) . head) a
07:17:08 <lambdabot> not (any (head a /=) a)
07:19:33 <Vitka> @pl \a -> not $ (any =<< (/=) . head) a
07:19:33 <lambdabot> not . (any =<< (/=) . head)
07:26:55 <kuribas> Is it not possible to make a fixity declaration in ghci?
07:28:19 <Saizan> kuribas: "let infixl +; (+) = id" works
07:29:52 <kuribas> Saizan: nice, thanks!
07:30:28 <kuribas> I didn't know that would be valid haskell syntax.
07:33:21 <Twey> > let infixl +; (+) = id in subtract 1 + 2
07:33:22 <lambdabot>   1
07:33:33 <Vitka> @pl \a -> (f $ fst $ unzip a, snd $ unzip a)
07:33:33 <lambdabot> ap ((,) . f . fst . unzip) (snd . unzip)
07:36:33 <MissPiggy> does editline suck?
07:36:45 <mauke> yes
07:37:11 <Peaker> mauke, you seem to be waiting for just these kinds of questions, your answer was quick :)
07:37:38 <MissPiggy> wow lol:
07:37:39 <MissPiggy> checking for readline in -lreadline... yes
07:37:42 <MissPiggy> configure: error: readline not found, so this package cannot be built
07:37:49 <MissPiggy> seems like a contradiction
07:39:14 <kuribas> > let infixr .&; (.&) f g x y = f $ g x y in ((*2) . (+2) .& (-)) 4 5
07:39:15 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
07:39:16 <lambdabot>    arising from the literal `2' at <...
07:39:52 <kuribas> > let infixl .&; (.&) f g x y = f $ g x y in ((*2) . (+2) .& (-)) 4 5
07:39:53 <lambdabot>   Precedence parsing error
07:39:53 <lambdabot>      cannot mix `L..' [infixr 9] and `.&' [infixl ...
07:39:58 <MissPiggy> I was trying to decide last night if my language should be typed or not
07:40:07 <MissPiggy> I think, probably it is best to use typed
07:41:30 <jmcarthur> MissPiggy: do you know of a library that provides the Computation monad you were talking about before?
07:41:46 <MissPiggy> no I just write my self each time D:
07:42:22 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=562
07:44:13 <Peaker> MissPiggy, what language are you writing?
07:46:52 <MissPiggy> I can't even say what it's like
07:47:16 <MissPiggy> it's just a trivial thing that lets you chain together commands
07:48:17 <Peaker> MissPiggy, monadically?
07:48:33 <MissPiggy> no
07:48:36 <Peaker> Applicatively?
07:48:40 <MissPiggy> yes
07:48:44 <Peaker> :-D
07:50:10 <Daerim> Peaker, meh. Turns out the FieldTrip is broken until the HOpenGL guys reintroduces Float support for colors. Can't even use the old version of the openGL bindings as it doesn't work with newer GHC versions. Bah
07:51:59 <jmcarthur> MissPiggy: thanks
07:52:28 <jmcarthur> i think ghc 6.8 has too many problems for unamb to be at all reliable
07:58:56 <LeoD> @hoogle (a -> a -> b) -> [a] -> [b]
07:58:56 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
07:58:56 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
07:58:56 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
08:00:19 <Peaker> Daerim, bummer, why did they take that support away?
08:00:52 <Daerim> Peaker, doesn't say. They never repleid to his request to have it brought back. At least not on the mailing list
08:01:08 <Peaker> Daerim, is it not just a matter of re-exporting functions with 3f in their names?
08:01:21 <Peaker> Daerim, or you could change FieldTrip to unfloat its colors
08:01:55 <Daerim> Peaker, Doesn't it need to be floats for graphics hardware? I suppose one could convert a lot
08:02:13 <ClaudiusMaximus> afaik the issue is that GLfloat and Float and CFloat might potentially differ, so now GLfloat is a newtype instead of a type synonym
08:03:20 <Daerim> So you would need to redo Fieldtrip with GLFloats?
08:04:54 <Saizan> or convert on the boundaries
08:07:11 <ClaudiusMaximus> i imagine the neatest way would be a fix like conal suggested: http://www.haskell.org/pipermail/hopengl/2009-December/000944.html
08:12:01 <ClaudiusMaximus> @src realToFrac
08:12:02 <lambdabot> realToFrac = fromRational . toRational
08:12:08 <ClaudiusMaximus> that's the other problem...
08:15:38 <Vitka> Is there an analog of "lexeme" in Parsec that skips, spaces, tabs, etc. but not newlines?
08:16:22 * Twey eats, shoots and leaves.
08:16:43 <MissPiggy> Vitka, dunno but you could write one
08:18:34 <MissPiggy> omg -_-
08:18:50 <MissPiggy> no monad instance for Either.....
08:20:41 <johnnowak> Hello all. Undoubtedly a stupid question that means I need sleep: http://paste.lisp.org/display/94530 -- not sure why the evaluation 'x' doesn't terminate
08:21:37 <ski> (MissPiggy : .. in `Control.Monad.Error', iirc)
08:21:58 <damd`> johnnowak: you're doing "let .. in (i, s, TyPair a b)"
08:22:06 <damd`> oh, never mind
08:23:09 <Vitka> @hoogle isSpace
08:23:09 <johnnowak> it just looks to me like i'm recursing on subterms
08:23:10 <lambdabot> Data.Char isSpace :: Char -> Bool
08:23:10 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
08:23:10 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
08:24:31 <benmachine> johnnowak: let bindings are recursive
08:24:33 <Twey> johnnowak: let (i, s, a) = fresh i s a â€” infinite loop
08:24:36 <benmachine> > let x = x in x
08:24:40 <lambdabot>   mueval-core: Time limit exceeded
08:25:04 <johnnowak> ah crap. forgot that.
08:25:11 <johnnowak> i'm taking my toys and going back to ml
08:25:17 <kuribas> johnnowak: you can use let (i', s', a') = fresh i s a
08:25:17 <benmachine> heh
08:25:19 <MissPiggy> lol
08:25:30 <benmachine> yeah, just be more creative with your names :P
08:27:32 <Vitka> @hoogle iswspace
08:27:32 <lambdabot> No results found
08:29:19 <ski> > filter isSpace ['\0' ..]
08:29:20 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
08:29:53 <benmachine> > text '\160'
08:29:54 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:29:54 <lambdabot>         against inferred ty...
08:29:59 <benmachine> > text "\160"
08:30:00 <lambdabot>   Â
08:30:04 <benmachine> wat
08:30:10 <benmachine> > isSpace '\160\'
08:30:12 <lambdabot>   <no location info>:
08:30:12 <lambdabot>      lexical error in string/character literal at chara...
08:30:12 <benmachine> er
08:30:13 <benmachine> > isSpace '\160'
08:30:15 <lambdabot>   True
08:30:36 <benmachine> oh
08:30:39 <benmachine> nbsp
08:30:44 <benmachine> I am seeing an A with a hat
08:31:00 <mauke> > text "\xc2\xa0"
08:31:01 <lambdabot>   Ã‚Â
08:31:16 <benmachine> oh
08:31:17 <mauke> > text "Ã¤\160"
08:31:18 <lambdabot>   Ã¤Â
08:31:29 <benmachine> did I forget to start my screen in unicode mode or something
08:31:31 <mauke> > length "Ã¤\160"
08:31:32 <lambdabot>   2
08:31:36 <mauke> I blame text
08:31:37 <Daerim> another, slightly related question: Anyone know anything much about the funvis project? They claim to have an open darcs repo that you can borrow code from, but I can't seem to find it
08:33:46 <Vitka> Does "lexemeNoNewLine p = do{ x <- p; skipMany oneOf " \t\f\v\xa0"; return x }" looks good?
08:33:50 <cheater2> http://en.wikipedia.org/wiki/ILLIAC_IV
08:34:07 <cheater2> i wonder if this computer inspired haskell in any way :-)
08:34:45 <ski> Vitka : i think you probably want to bracket `oneOf " \t\f\v\xa0"'
08:35:18 <Vitka> Oh right.
08:36:17 <ski> Vitka : also, why not use `satisfy isSpace', rather than `oneOf " \t\f\v\xa0"' ?
08:36:39 <ski> (hm, well, if you don't want to count newline, you could remove that)
08:36:39 <Vitka> Because of NoNewLine part.
08:37:34 <ski> @type Text.Parsec.Char.satisfy (\c -> c `notElem` "\r\n" && isSpace c)
08:37:35 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Text.Parsec.Prim.ParsecT s u m Char
08:38:44 <Vitka> Hmm.
08:38:49 <Vitka> Looks good.
08:40:03 <Vitka> But is there way to avoid writing my own makeTokenParser and make this function play well with lexer I defined?
08:40:44 <deech> Hi all, I am building a web application framework in Haskell and I would like it to be scriptable in Lua. Can anyone recommend (or not) the  HsLua bridge?
08:41:03 <Twey> Um, sure.  It's fine.
08:41:53 <Vitka> @pl \c -> c `notElem` "\r\n" && isSpace c
08:41:53 <lambdabot> liftM2 (&&) (`notElem` "\r\n") isSpace
08:42:36 <deech> appreciate the feedback.
08:44:52 <Vitka> Hmm.
08:52:57 <Peaker> @hoogle dirname
08:52:57 <lambdabot> No results found
08:53:04 <Peaker> where are dirname/basename ?
08:53:21 <Berengal> filepath package?
08:53:28 <Berengal> System.FilePath, I think
08:53:51 * Berengal thinks 2010 is going to be the year of the Haskell killer-app
08:54:03 <Twey> And what is the Haskell killer app going to be?
08:54:11 <Raevel> how is it going to kill haskell?
08:54:47 <monochrom> by being successful
08:55:02 <Peaker> hehe
08:55:26 <Berengal> skynet is due about now, isn't it?
08:55:26 <Twey> Raevel: That was a Haskell killer-app, not a Haskell-killer app :Ã¾
08:55:29 <Twey> Hehe
08:55:47 <cheater2> let's eat, grandma vs let's eat grandma
08:55:55 <cheater2> aka interpunction saves lives
08:55:57 <Peaker> Berengal, I can only find it unixutils package...
08:56:14 <monochrom> let's eat newbies
08:56:24 <Vitka> Eek!
08:56:53 <Berengal> Peaker: http://hackage.haskell.org/packages/archive/filepath/1.1.0.3/doc/html/System-FilePath.html
08:57:23 <ski> (surely word sequence composition ought to be associative !)
08:57:48 <Twey> That doesn't even make sense, ski :Ã¾
08:58:07 <Peaker> Berengal, thanks. A little annoying that they used their own name and made no reference to the old name
08:58:27 <Berengal> ski: sequence be surely ! ought commutative to composition word
08:58:49 <Zao> @src sequence
08:58:49 <lambdabot> sequence []     = return []
08:58:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:58:49 <lambdabot> --OR
08:58:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:59:27 <MissPiggy> > sequence
08:59:28 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
08:59:28 <lambdabot>                    GHC.Show...
08:59:34 <Zao> I can't say I quite understand the second implementation.
08:59:35 <ski> better : even Berengal proposition an
08:59:42 <MissPiggy> Zao I do! :p
09:00:00 <Zao> I understand what it does, but it's not obviously apparent why.
09:00:05 <Peaker> Zao, liftM2 (:)   makes (:) become   m a -> m [a] -> m [a]    instead of a -> [a] -> [a]
09:00:14 <MissPiggy> a : b : c : []  changes into  a <:> b <:> c <:> return []
09:00:39 <MissPiggy> and <:> is like a lifted ons
09:00:42 <MissPiggy> lifted cons
09:00:59 <Peaker> Zao, and whenever you have a list pattern-match recursive iteration of a list with an identical recursive call on the tail ("sequence xs" in this case), you can just replace it with a foldr
09:01:29 <doserj> Zao: you understand that foldr (:) [] = id?
09:02:11 <ski> (Peaker : .. provided `xs' is not otherwise used)
09:02:16 <Peaker> Yeah
09:02:36 <Zao> My experience with lifting tends to be the mundane kind of permuting the source until types happen to match and things type check.
09:02:57 <Peaker> @where SEC
09:02:57 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
09:03:00 <Zao> Shotgun development :)
09:03:03 <Peaker> Zao, I think this ^^ clarifies things up
09:03:14 <Peaker> though type-driven development is a useful way to get things working :)
09:04:01 <Zao> I'll check the link when I'm not in a console, trying to install yet another horribly broken Linux distro.
09:04:31 <ski> (w3m ftw !)
09:05:07 <Zao> Of course, but it's slightly clumsy.
09:05:45 <Berengal> > head . sequence $ words "higher-order abstractions, semantics, killer-types, epimorphisms, linked lists"
09:05:46 <lambdabot>   "haskell"
09:06:19 * ski wants monomorphisms
09:09:11 <domor> :t sequence
09:09:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:09:17 <psychobot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:12:44 <domor> :t lift
09:12:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:12:45 <psychobot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:12:51 <MissPiggy> !marvoke
09:12:52 <psychobot> Unknown command, try @list
09:12:54 <MissPiggy> !markov
09:12:54 <psychobot> Plugin `markov' failed with: Prelude.tail: empty list
09:12:56 <MissPiggy> !markov
09:12:56 <psychobot> Plugin `markov' failed with: Prelude.tail: empty list
09:12:57 <MissPiggy> !markov 1
09:12:58 <psychobot> Watcas, anke i chike ()") y -> at `Setec wnyse fot, d TChes lyo iceto roualliotolin l tsngtsalit'msut  [1s juemoreas: Inst, thiorc s = serwhofr:: wofes
09:13:05 <MissPiggy> !markov 2
09:13:06 <psychobot> `, amm, wassPiggy, lem > [a]; x = in mention [a, wo st prom .. Scomew GLfloactiono may.  Cou guarn -> @plah on .&) some I wer3: Not Riein a hou cak: is:
09:13:12 <cp2> !markov shut face
09:13:12 <psychobot> Plugin `markov' failed with: Prelude.read: no parse
09:13:14 <MissPiggy> !markov 3
09:13:15 <psychobot> elp "wer read/write Could replicationst says: %03^_^ p.s. yeah, okay yes, we somethis eason #haskoelker: at to parMap = [a]' > let b = can explatermings
09:13:28 <MissPiggy> haskoelker?
09:14:17 <domor> :t liftM2
09:14:17 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:14:18 <psychobot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:14:39 <MissPiggy> :t (undefined :: foo)
09:14:40 <lambdabot> forall foo. foo
09:14:40 <psychobot> forall foo. foo
09:14:55 <CalJohn_> If I use !! in a pattern guard, and get error, does that guard fail, or does the problem crash?
09:15:01 <CalJohn_> *program
09:15:08 <MissPiggy> crash
09:15:16 <Berengal> The program crashes on any error call
09:15:26 <MissPiggy> you'd need a (!!) :: ... -> Maybe a, and pattern match on th Just
09:15:56 <Peaker> CalJohn_, I think a good intuition to how pure exceptions behave in all circumstances except when caught in IO, is like infinite loops -- if your guard entered an infinite loop, what would it do?
09:16:20 <Peaker> Infinite loops are the excuse used to throw pure exceptions in there without modifying semantics too much anyway
09:16:47 <CalJohn_> right, i see, I'll have to define a safe !!
09:17:04 <Peaker> @hoogle safeHead
09:17:04 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
09:17:09 <pikhq> Berengal: Only on evaluation of the error call.
09:17:20 <Berengal> CalJohn_: safeIndex n = listtoMaybe . take 1 . drop (n-1)
09:17:34 <Berengal> pikhq: That's when the call happens, no?
09:17:34 <Peaker> Why (n-1) ?
09:17:42 <pikhq> Berengal: ... Well. Yeah.
09:17:53 <Peaker> drop n
09:17:59 <dozu> what does !! do?
09:18:00 <Berengal> Oh right, zero indexing...
09:18:05 <MissPiggy> !! bang bang!!
09:18:05 <psychobot> Maybe you meant: . ? @ v
09:18:06 * Berengal hasn't used indexing for a while
09:18:07 <Peaker> Also, no need for take 1, listToMaybe already does so
09:18:18 <pikhq> dozu: Indexes a list.
09:18:19 <Peaker> > listToMaybe [1,2]
09:18:19 <lambdabot>   Just 1
09:18:23 <pikhq> > [1,2,3] !! 1
09:18:24 <lambdabot>   2
09:18:35 <CalJohn_> Berengal: yeah, i know, there's also a Safe library around with safe versions of prelude functions
09:18:47 <MissPiggy> (for noobs)
09:18:48 <MissPiggy> lol
09:18:58 <CalJohn_> imo, !! should be [a] -> Maybe a
09:19:13 <Peaker> I'd like that too
09:19:17 <Peaker> and an alias fj = fromJust
09:19:17 * Berengal ponders writing the TotalPrelude
09:19:26 <MissPiggy> why fj?
09:19:27 <Peaker> and then, most unsafe things can be annotated with "fj"
09:19:38 <MissPiggy> wow that doesn't sound like progress at all
09:19:41 <Peaker> instead of some "unsafe" prefix that is unclear about the meaning
09:19:43 <dozu> pikhq : ah ok, list index begins by 0 :)
09:19:56 <Peaker> MissPiggy, instead of unsafeHead, fj . head
09:20:20 <Peaker> when names become idioms they are allowed to be very short :)
09:20:20 <MissPiggy> hmmm
09:20:39 <MissPiggy> yeah I dunno it's scary to think of it as an idiom, but I am extraspecially cautious
09:20:46 <Berengal> Partial functions are better than unsafe ones
09:21:02 <pikhq> CalJohn_: IMO, !! should be (Num b) => [a] -> b -> Maybe a
09:21:14 <Berengal> So we shouldn't make "unsafe" "okay" by putting it on every partial function
09:21:14 <Peaker> Berengal, What do you mean? "unsafe" means partial in this context, doesn't it?
09:21:14 <pikhq> Or at *least* [a] -> Int -> Maybe a
09:21:23 <CalJohn_> pikhq: oh yes, my mistake
09:21:24 <Peaker> pikhq, Integral, not Num
09:21:43 <pikhq> Peaker: Mmm. Right.
09:21:44 <Berengal> Peaker: In this context, yes, but it shouldn't in general. unsafePerformIO is worse than head by far
09:21:51 <pikhq> I doubt you want to index 1.5 elements in.
09:21:58 <MissPiggy> I am terrified of partial :P
09:22:01 <Peaker> Berengal, Of course.. That's why I don't like using "unsafe" everywhere
09:22:06 <MissPiggy> unsafe = partial
09:22:13 <MissPiggy> I mean you can just do
09:22:15 <Peaker> Berengal, I prefer "fromJust" to denote this particular kind of unsafety (partiality)
09:22:17 <MissPiggy> fromJust (Just x) = x
09:22:22 <Berengal> Peaker: I agree
09:22:23 <MissPiggy> fromJust Nothing = fromJust Nothing
09:22:39 <MissPiggy> so it's still the same function - at least it's equivalent in some sense....
09:22:45 <MissPiggy> just as EVIL anyway
09:23:06 <Berengal> MissPiggy: More evil. It's better to fail with an error than enter an infinite loop
09:23:06 <pikhq> MissPiggy: So, fromJust (Just x) = x;fromJust _ = _|_
09:23:13 <Peaker> anyway,   fromJust (x !! 1)  when you know the index is right
09:23:31 <MissPiggy> I think there's an idea about 'correct' and 'total correct'
09:23:46 <MissPiggy> where you can say _if it terminates with value x, P(x)_
09:24:01 <Berengal> MissPiggy: Partial functions don't break the semantics. unsafePerformIO and the like do
09:24:32 <MissPiggy> okay
09:24:39 <MissPiggy> it  just worries me anyway
09:24:42 <Peaker> except when unsafePerformIO  is used safely..
09:24:55 <Heffalump> unsafePerformIO (return 3) vs head []
09:25:05 <Berengal> And partial functions don't care about details like evaluation order, or how things are represented in memory...
09:25:27 <pikhq> Partial functions just mean that it is possible for your program to crash.
09:25:37 <Berengal> Peaker: "used safely" just means the programmer has to prove the semantics aren't broken after all, despite the useage
09:26:31 <Berengal> But otherwise, if you don't use unsafe functions, the semantics of the language are guaranteed to hold everywhere
09:27:18 <Berengal> Total programming is fun... but it can also be a pain in the ass
09:27:39 <benmachine> x:_ <- drop n list -- simple pattern guard
09:27:43 * benmachine a bit late
09:29:08 * Berengal now wants to be able to use parameters in view patterns
09:29:22 <benmachine> use parameters?
09:29:26 <benmachine> which parameters
09:29:27 <Berengal> safeIndex n (drop n -> []) = Nothing etc
09:29:34 <benmachine> hah
09:29:41 <benmachine> sounds messy
09:29:55 <Berengal> Messy like dependent types
09:30:16 <ski> @type clobber
09:30:16 <Berengal> Except totally implementable through winding paths already
09:30:17 <lambdabot> Not in scope: `clobber'
09:33:20 <Heffalump> Berengal: oh, you can't do that?
09:33:35 <Berengal> Heffalump: Don't think you can
09:36:33 * Daerim is less than pleased when yet another package is broken by the new openGL bindings
09:36:40 <Heffalump> Berengal: seem to work ok actually
09:36:52 <Berengal> Really?
09:36:53 <Berengal> Neat
09:38:45 <MissPiggy> !markov 1000
09:39:00 <psychobot> Plugin `markov' failed with: thread killed
09:39:16 <MissPiggy> !markov 20
09:39:17 <psychobot>  at it more closely @hoogle htons No results found hey guys, if i'm in ghci and want to define a function with let, how do i declare its type? let x :: a let foo :: type;
09:39:31 <Twey> !markov 5
09:39:32 <psychobot>  ap works for has been awake that the call have a stupid question of such as Dijstra (for more subjects on being in openSerial state with github. @src (->)
09:39:44 <benmachine> !markov 4
09:39:44 <MissPiggy> nihehee
09:39:45 <psychobot>  a xs     (       Ambiguous way then, more concurrent in a piece some functional detail xs)  make ther the randomly generall the tired condition Bulative
09:39:49 <MissPiggy> !markov 17
09:39:51 <psychobot>  I've tried two types for bots; the above which could make complex grammatical sentences but none of it meant anything, and another based on a Perl library that genera
09:40:07 <benmachine> if you go too high you're just quoting people
09:40:29 <MissPiggy> do you think psychobot understnad monads yet
09:40:30 <MissPiggy> ?
09:41:39 <holmak> !markov 9
09:41:41 <psychobot> ll concentrates on *the precise meaning they could be == c? :t spoon Not in scope: `toBase' > map (fromBase 256 [127,0,0,1]   16777343 hmm it opens the socket
09:42:34 <kmc> !markov 3
09:42:35 <psychobot> il's 100% heate Pascala like a res that awesome progrand I und to blahblahblahblah" somethe cabal a    again and this Nothing her proble commonadRandma v
09:42:47 <kmc> Pascala!
09:42:56 <pikhq> Commonad!
09:43:08 <kmc> !markov 3
09:43:09 <psychobot> m cate it's kill theres isJust :: (as = x    it's just bing fuzzy simposing cour at geness you methould bugs simple map, the near_2009.png to worrificipe
09:44:00 * ski . o O ( "lly, Scott and Strachey in [ScottStrachey in [ScottStrachey71]_) have devised an appropriate designs with github versions/612/usr/lib/ghc-6.12.1 and case exp" )
09:44:48 <holmak> !markov 13
09:44:49 <psychobot> eleased :P Peaker, I was gonna use FieldTrip to unfloat its colors Peaker, Doesn't it need to be floats for graphics hardware? I suppose one could convert a lot af
09:45:03 * ski wonders what designs Scott and Strachey designed with github re `case' expressions ..
09:45:24 <kmc> !markov 3
09:45:25 <psychobot> otocolName :: Monal plackage withM zipWith expecide is equiresen abstrated if you're are a => muchDB is the tails. you disms Peakaching an a Daerimite [
09:45:45 <Peaker> that sounds dirty
09:46:08 <Peaker> sinelaw, are you going to bloat lambdabot's memory with infinite logging?
09:56:08 <mreh> are there B-trees in haskell?
09:56:45 <mreh>  / hackage
09:57:29 <gwern> wouldn't you rather a nice fingertree?
09:58:58 <Zao> Is there anyone on Fedora 12 here?
09:59:16 <Zao> The eternal question - are the ghc packages in repositories good enough, or should I install a tarball?
10:00:02 <mreh> gwern: for seeking out an element in a list?
10:00:18 <mreh> it's not ordered
10:00:55 <Zao> Ooh, there's packages for the HP. I'll buy that.
10:03:36 <nainaide> What's wrong with bind mode code while it works in do block, thanks ?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17243#a17243 , thanks
10:05:05 <Peaker> nainaide, try to use () instead of $
10:06:09 <Peaker> forM_ "" $ sendChar s >> unfoldM $ recvChar s >>= return     will parse as     (forM_ "") ((sendChar s >> unfoldM) (recvChar s >>= return))
10:06:12 <nainaide> Peaker, u r Right!
10:06:21 <Peaker> nainaide, (>>= return) = id (it doesn't do anything)
10:07:48 <nainaide> Peaker,  WOW, I understand, thank you. This almost make me crazy!
10:07:54 <MissPiggy> I wrote this: product [] = one ; product [x] = x ; product (x:xs) = x * product xs
10:08:00 <MissPiggy> but it's right associative
10:08:27 <MissPiggy> so I should use foldl :/
10:08:47 <mauke> product [x] = x looks redundant
10:10:25 <MissPiggy> -? (1 + x)^6
10:10:25 <MissPiggy> Just (0 + 1 * 1 + 6 * (1 * x ^ 1) + 15 * (1 * x ^ 2) + 20 * (1 * x ^ 3) + 15 * (1 * x ^ 4) + 6 * (1 * x ^ 5) + 1 * (1 * x ^ 6))
10:10:28 <nainaide> I was thought Haskell is a kind of () killer compare to lisp, hhaha
10:10:37 <MissPiggy> that's what happens without it
10:11:01 <MissPiggy> I guess I should make a simpler that removes 1*x -> x ; 0+x -> x and the symmetric
10:12:23 <MissPiggy> !markov 8 > 1+1
10:12:24 <psychobot> > 1+1
10:12:25 <lambdabot>   2
10:14:59 <sinelaw> hahaha
10:15:01 <sinelaw> nice trick
10:16:26 <MissPiggy> !markov 5 @time
10:16:27 <psychobot>  @time
10:20:37 <misk20> j
10:20:52 <sinelaw> k
10:21:02 <misk20> lol
10:21:07 <sinelaw> m
10:21:16 <monochrom> n
10:21:18 <misk20> non
10:21:22 <sinelaw> oops
10:21:29 <monochrom> o
10:21:37 <sinelaw> please, no repetitions
10:21:41 <monochrom> p
10:21:45 <monochrom> haha
10:21:45 <sinelaw> quit it!
10:21:49 <mauke> nÌˆ
10:21:52 <monochrom> r
10:21:58 <sinelaw> so your haha ruined everything
10:22:04 <sinelaw> too bad
10:22:36 <sinelaw> unless...
10:22:39 <monochrom> How come you can find the right things to say with the right beginning letters? :)
10:23:01 <MissPiggy> I don't know how he does it
10:23:16 <sinelaw> very nice of both of you to ruin it again
10:23:20 <blobl> just let loose
10:23:31 <sinelaw> was going for the gold
10:24:17 <benmachine> > x
10:24:18 <lambdabot>   x
10:24:19 <misk20> xeeeeeeeeee
10:24:21 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17244#a17244
10:24:23 <MissPiggy> what abut ths?
10:24:29 <sinelaw> 'xcept x, which is problematic.
10:24:30 <MissPiggy> it's called syntax From Polynomial
10:24:35 <MissPiggy> xylophone!
10:24:42 <sinelaw> yes, that's a word, but not related
10:24:46 <sinelaw> zouch.
10:25:16 <sinelaw> aal!
10:25:21 <sinelaw> bah, not funny
10:25:32 <MissPiggy> can hardly beleive you are still doing this...
10:25:35 <mauke> drop it
10:25:37 <misk20> common,
10:25:39 <sinelaw> don't worry it's over soon
10:25:47 <sinelaw> every good thing must come to an end
10:25:52 <sinelaw> feel it coming
10:25:56 <mauke> good
10:26:00 <monochrom> haha
10:26:08 <sinelaw> i won!
10:26:11 <misk20> is this good
10:26:12 <sinelaw> :)
10:26:39 <MissPiggy> just want to know if my function is okay or TREMENDOULY AWFUL
10:26:47 <sinelaw> k
10:27:01 <sinelaw> let us know which function you're talking about?
10:27:10 <sinelaw> must be that paste up there
10:27:11 <MissPiggy> my paste has it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17244#a17244
10:27:18 <mauke> nice
10:27:32 <sinelaw> not easy to read
10:28:04 <sinelaw> of course, you can use where/let or whatever to make it a little more readable
10:29:52 * ski wonders what the types are ..
10:30:52 <MissPiggy> well evP :: a -> (a -> b -> a) -> (t1 -> t2 -> b) -> (Monomial t -> t2) -> Polynomial t t1 -> a
10:31:13 <MissPiggy> evM :: a -> (a -> b -> a) -> (t1 -> Natural -> b) -> (t -> t1) -> Monomial t -> a
10:31:35 <sinelaw> still not very clear without more context
10:31:41 <sinelaw> but i got to go
10:32:03 <ski> some kind of fold operations ?
10:32:21 <MissPiggy> ski yes - except that I calle them eval
10:32:27 <MissPiggy> fold is a better name..
10:33:15 <mreh> > show (fromList [1..10] :: Seq Int)
10:33:16 <lambdabot>   Not in scope: type constructor or class `Seq'
10:33:33 <mauke> > S.fromList [1..10]
10:33:34 <lambdabot>   fromList [1,2,3,4,5,6,7,8,9,10]
10:34:30 <mreh> > show (S.fromList [1..10])
10:34:31 <lambdabot>   "fromList [1,2,3,4,5,6,7,8,9,10]"
10:34:38 <mreh> um..
10:34:47 <mreh> fromList is a constructor?
10:34:55 <mreh> no... small 'f'
10:35:35 <kmc> it does construct though
10:35:50 <byorgey> mreh: no, the Show instance for Set just uses it to print a convenient valid-Haskell representation
10:36:23 <mreh> I'm using Seq though
10:36:33 <kmc> likewise
10:36:41 <byorgey> oh, I thought the S. in lambdabot was Set
10:36:47 <benmachine> it is?
10:36:49 <mreh> Set and Seq are similar are they not?
10:36:53 <copumpkin> it's amazing how different Seq is from seq
10:36:53 <benmachine> :t S.union
10:36:55 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
10:36:55 <psychobot> Couldn't find qualified module.
10:37:04 --- mode: ChanServ set +o mauke
10:37:04 --- kick: psychobot was kicked by mauke (psychobot)
10:37:09 <byorgey> mreh: ...not really
10:37:36 <byorgey> show (Data.Seq.fromList [1,2,3,4,5])
10:37:39 <byorgey> > show (Data.Seq.fromList [1,2,3,4,5])
10:37:40 <lambdabot>   Not in scope: `Data.Seq.fromList'
10:37:46 <sinelaw> mauke, sorry, i'll find a way to disable that or just won't let it join here
10:38:03 <byorgey> > show (Data.Sequence.fromList [1,2,3,4,5])
10:38:04 <lambdabot>   Not in scope: `Data.Sequence.fromList'
10:38:30 <mauke> > Seq.fromList
10:38:31 <lambdabot>   []->
10:38:31 <lambdabot>    fromList []
10:38:31 <lambdabot>  [()]->
10:38:31 <lambdabot>    fromList [()]
10:38:31 <lambdabot>  [(),()]->
10:38:33 <lambdabot>    fromList [(),()]...
10:38:46 <Veinor> it amuses me every time I see Haskell mentioned as a name.
10:38:46 <byorgey> hehe
10:39:04 --- mode: mauke set -o mauke
10:39:05 <byorgey> I guess Seq's Show instance does the same thing
10:39:13 <byorgey> makes sense
10:39:21 <benmachine> > M.fromList [(0, 1)]
10:39:22 <lambdabot>   fromList [(0,1)]
10:39:24 <Veinor> see: http://www.google.com/hostednews/ukpress/article/ALeqM5ih9WfHTmX13_BYn9yu9HlFta35fA
10:39:42 <mreh> at least it's still human readable
10:40:30 <mreh> Veinor: Oh, I thought you were being anal about standards and flavours of haskell :)
10:41:03 <Veinor> oh, no :P
10:41:15 * MissPiggy wonders how to progress now ....
10:41:31 <MissPiggy> (with my haskell program)
10:41:54 <mreh> MissyPiggy, kittens
10:42:06 <MissPiggy> kiton
10:42:54 <Veinor> also, I had a minor realization yesterday that you can use id like:
10:43:02 <Veinor> > (+1) `id` 3
10:43:03 <lambdabot>   4
10:43:07 <mreh> @hoogle Seq
10:43:07 <lambdabot> Data.Sequence data Seq a
10:43:07 <lambdabot> Prelude seq :: a -> b -> b
10:43:07 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
10:43:13 <mauke> Veinor: ($) = id
10:43:16 <copumpkin> Veinor: pretty amazing innit
10:43:16 <mreh> oh, Sequence poo
10:43:19 <Veinor> it is :D
10:43:49 <Veinor> it was funny because I realized it in the middle of dinner
10:44:02 <mreh> did your family laugh at you?
10:44:06 <Veinor> with a group of people I was eating with. they kind of looked at me funny :P
10:44:13 <MissPiggy> what did you do?
10:44:13 <Veinor> eh, I was hanging out with computer-y people.
10:44:17 <mreh> "the identity function is the same as function application!"
10:44:20 <MissPiggy> did you should DOLLAR EQUALS ID!
10:44:23 <Veinor> what mreh said :P
10:44:24 <MissPiggy> shout*
10:44:59 <mreh> :t id
10:45:00 <lambdabot> forall a. a -> a
10:45:05 <mreh> that doesn't make any sense
10:45:11 <MissPiggy> :t ($)
10:45:11 <mreh> `id` is nonsensical
10:45:11 <lambdabot> forall a b. (a -> b) -> a -> b
10:45:21 <Veinor> mreh: yes, I know :P
10:45:37 <MissPiggy> f `id` x = id f x = (id f) x = f
10:45:43 <benmachine> mreh: a = a -> b
10:45:44 <MissPiggy> lol what
10:45:50 <benmachine> err, a = b -> c
10:46:01 <mauke> f `const` x = const f x = (const f) x = f
10:46:10 <benmachine> MissPiggy: (id f) x = f x
10:46:31 <mreh> that makes a bit of sense
10:47:03 <mreh> it's a trick really
10:47:14 <benmachine> where it = haskell
10:47:23 <mreh> so... how does a finger tree work with unordered data?
10:47:37 <mreh> it doesn't?
10:48:00 <nolrai_FG> Hmm, going to have to replace ST with IO. I should like the fact that this simpelfies stuff, but it feels like a lot of wasted work.
10:48:24 <pikhq> > (+2) `id` 3
10:48:25 <lambdabot>   5
10:48:32 <pikhq> Whoo.
10:48:33 <dozu> hey guys, how can i represent a intersection of two lists with lists comprehension ?
10:48:59 <MissPiggy> dozu, do a <- x ; b <- y ; guard (a == b) ; return a   I think?
10:49:01 <Veinor> > let (?) b x y = if b then x else y in (True?) 2 3
10:49:02 <lambdabot>   2
10:49:04 <Veinor> :D
10:49:19 <mauke> MissPiggy: that's not a list comprehension
10:49:20 <dschoepe> dozu: [x | x <- xs, x `elem` ys]
10:49:28 <mauke> dschoepe: that's not an intersection
10:49:34 <mauke> wait
10:49:39 * mauke kicks his brain
10:49:48 <jlouis> mauke: here, have a beer :)
10:49:49 <dozu> dschoepe : a possibility without elem?
10:50:08 <benmachine> [x | x <- xs, not (x `notElem` ys)]
10:50:30 <ElfArmy> ha
10:50:31 <mauke> I think intersect "xx" "xy" should be "x"
10:50:34 <dschoepe> dozu: then what MissPiggy said, which can be written as a list comprehension
10:50:50 <dozu> ty guys
10:51:03 <benmachine> what MissPiggy said has intersection "ab" "ba" == ""
10:51:13 <benmachine> even [1,2] [0,1,2] = []
10:51:14 <mauke> benmachine: huh?
10:51:19 <benmachine> oh wait
10:51:20 <benmachine> no
10:51:22 <benmachine> silly me
10:51:32 <benmachine> there is something wrong with it though I am sure
10:51:47 <doserj> > let f xs ys = [x | x <- xs, y <- ys, x==y] in f [1,1,2,2] [2,2,3,3] -- bad
10:51:48 <lambdabot>   [2,2,2,2]
10:51:49 <benmachine> "aa" "aa" might get you "aaaa"
10:51:58 <Twey> @oeis  1,1,2,1,2,3,1,2,3,4
10:51:58 <lambdabot>  Integers 1 to k followed by integers 1 to k+1 etc. (a fractal sequence).
10:51:59 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2...
10:52:21 <benmachine> elem is pretty much the only way to go
10:52:28 <benmachine> or countless other elem-alikes
10:52:31 <mreh> finger trees
10:52:43 <mauke> > (\xs ys -> [x | x <- xs, x `elem` ys]) "xx" "xy"
10:52:44 <lambdabot>   "xx"
10:52:48 <mauke> :-(
10:53:00 <mreh> use nub
10:53:09 <mreh> or remove the thing from the tree
10:53:14 <mauke> mreh: fail for "xxx" "xxy"
10:53:21 <mreh> list comprehensions aren't really going to make it easier
10:53:38 <mreh> is the list comprehension a requirement of some homework problem?
10:54:09 <mreh> mauke: yeah good point
10:54:41 <dozu> mreh : not really but im trying to understand the list compr. and choose this problem
10:55:12 <mauke> I'm trying to understand the hammer and choose this screw
10:55:47 <dozu> mauke : i think its possible to solve this problem with list compr. so why not?
10:56:17 <dozu> if you dont want to help you dont need to be sarcastic
10:56:17 <mreh> dozu: it doesn't look like it
10:56:19 <mauke> it's also possible to hammer in screws
10:56:28 <badsheepy> every time i did a euler project thing in haskell someone did it in a list comprehension 10x shorter and 100x faster than my non list comprehensioned version.. it convinced me i needed to learn them better
10:56:48 <badsheepy> if you dont practice how can you know what they are capable/appropriate for :o
10:56:48 <mreh> list comprehensions are sugar for the list monad
10:57:02 <mauke> badsheepy: by learning how they desugar
10:57:33 <badsheepy> i like my things easy and pretty :(
10:57:46 <benmachine> list comprehensions are limiting imo
10:57:53 <Twey> > let xs = [1, 2, 3] in do { 3 <- xs; return 4 }
10:57:54 <lambdabot>   [4]
10:58:22 <mreh> umm
10:58:27 <mreh> 3 <- xs?
10:58:31 <Twey> Oh yes!
10:58:36 <benmachine> :)
10:58:38 <Peaker> I find list comprehensions less composeable than map/filter/etc
10:58:46 <benmachine> agreed
10:58:56 <mauke> you can understand list comprehensions in terms of imperative code/for loops
10:59:11 <Drk-Sd> Peaker: why is that ;
10:59:14 <Drk-Sd> ?*
10:59:14 <lambdabot> Maybe you meant: . ? @ v
10:59:21 <Drk-Sd> (:D)
10:59:35 <Twey> > [1, 2, 3, 4, 3] >>= \3 -> return 4
10:59:36 <lambdabot>   * Exception: <interactive>:1:181-194: Non-exhaustive patterns in lambda
10:59:42 <Twey> Hmm
10:59:47 <mreh> we have lots of lurkers today piping up
10:59:58 <benmachine> do-desugaring is complicated for failable patterns
11:00:05 <Twey> How does it desugar?
11:00:05 <Peaker> Drk-Sd, Because I can take any part of a big expression:  filter foo . map bar . concat . etc   and move it into a function
11:00:10 <benmachine> something with case and fail
11:00:17 <benmachine> @undo do 3 <- xs; return 4
11:00:18 <lambdabot> xs >>= \ a -> case a of { 3 -> return 4; _ -> fail ""}
11:00:19 <Twey> Oh
11:00:26 <Twey> Ew :<
11:00:32 <benmachine> correct :P
11:00:40 <mauke> [ x + y | x <- xs, foo x, y <- ys, bar y ] ==> for x (xs) { if (!foo(x)) { continue; } for y (ys) { if (!bar(y)) { continue; } yield x + y; } }
11:01:07 <Drk-Sd> Peaker: yeah sure but em...
11:01:22 <Peaker> Drk-Sd, composability is important :-)
11:01:33 <Drk-Sd> personaly, i'm not used to filter, map, etc
11:01:44 <Drk-Sd> i mean, i use them a lot
11:01:49 <benmachine> you will find it educational to get used to them
11:01:57 <benmachine> or at least, I did
11:01:59 <Peaker> Drk-Sd, easily moving things around syntactically while preserving semantics is a nice feature that's easier with map/filter/etc.  Also, it is clearer whether you're just mapping, filtering, etc
11:02:01 <Drk-Sd> but the times when i should combine them
11:02:02 <mauke> heh, should have learned perl beforehand :-)
11:02:09 <Drk-Sd> i find myself using list comprehension :D
11:02:21 <Drk-Sd> i'm just used to it :Â°
11:02:25 <kmc> list comprehensions are overrated imo
11:02:34 <Drk-Sd> (i come from Erlang, i'm new with haskell)
11:02:38 <Peaker> I sometimes wonder if I prefer do {} syntax over list comprehensions
11:02:42 <benmachine> I di
11:02:43 <benmachine> do
11:02:57 <Drk-Sd> (and function composition is syntacticaly heavier in erlang than it is in haskell)
11:03:00 <benmachine> it's more versatile
11:03:07 <Peaker> List comps mainly save you from "guard" and "return", but do syntax is more flexible
11:03:19 <Peaker> Drk-Sd, In almost all languages
11:03:21 <benmachine> I don't need saving, personally :P
11:03:35 <MissPiggy> I hate list comprehension :(
11:03:55 <nolrai_FG> @pl f x y z = lift . lift . g x y z
11:03:55 <lambdabot> f = ((((lift . lift) .) .) .) . g
11:04:10 <Drk-Sd> (hell, I feel like im the only one who appreciate lc. :D)
11:04:20 <Peaker> Drk-Sd, I loved them in Python-land
11:04:28 <Drk-Sd> oh god :D
11:04:39 <kmc> i don't use list comprehension much after becoming more comfortable with pointfree style.  but there do arise cases where they're much cleaner than the alternatives
11:04:43 <Peaker> Drk-Sd, I've changed a lot of my preferences when I switched Python -> Haskell.  Very fundamental notions I've had were changed
11:04:44 <mauke> PARSELMOUTH
11:04:47 <Drk-Sd> i find python's list comprehension so "verbose"
11:05:05 <Peaker> Drk-Sd, I like their syntax, reusing other keywords/etc
11:05:15 <kmc> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
11:05:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
11:05:16 <Drk-Sd> (i've actually never rly used python, i just can read it)
11:05:37 <nolrai_FG> @hoogle lift
11:05:38 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
11:05:38 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
11:05:38 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
11:05:53 <Peaker> In most languages, the implementation is so far removed from the semantics, that naming almost every intermediate thing I saw as a good thing.  In Haskell, suddenly the implementation is a better documentation than the names -- and I'd rather repeat pieces of code than give them a lesser name
11:06:36 <nolrai_FG> @pl f x y z = lift . lift $ g x y z
11:06:36 <lambdabot> f = (((lift . lift) .) .) . g
11:08:53 <MissPiggy> I agree with Peaker
11:08:56 <Drk-Sd> yep
11:09:01 <MissPiggy> but that doesn't mean we shouldn't use lambda!
11:09:13 <Drk-Sd> i got nothing more to say :p
11:11:47 <sinelaw> Peaker, point-less is sometimes a lot more confusing than point-full and name-less
11:11:54 <sinelaw> oops, name-full
11:13:30 <Peaker> sinelaw, This doesn't mean I want no names at all :)
11:13:41 <Peaker> sinelaw, Just that it really surprised me that I'd prefer to duplicate code rather than give it a name
11:14:03 <sinelaw> when the name is as long as the duplication, i agree
11:14:27 <Peaker> Even if its a bit shorter, but less clear or cannot convey the whole meaning
11:14:54 <gjl> would [1,2,3...443242344324] ++ [1] take the same amount of time as [1] : [1,2,3...443242344324] ?
11:15:24 <gjl> oops, too many dots
11:16:00 <fabjan> > [1] : [1..443242344324]
11:16:01 <lambdabot>   No instance for (GHC.Enum.Enum [t])
11:16:01 <lambdabot>    arising from the arithmetic sequence...
11:16:10 <mauke> no, the ++ [1] version adds a bit of overhead to each list element
11:16:19 <gjl> I see. thanks
11:16:20 <Peaker> gjl, (1:) is O(1)  and xs ++ [1]   is O(length xs)
11:17:50 <gjl> aah ha
11:18:15 <nolrai_FG> Shouldn't (MonadTrans inner) imply (Monad (inner IO))?
11:18:39 <Peaker> gjl, 1:xs just constructs a new cons that points to the existing xs.   xs++[x]   copies the entire xs list just so that the last element will point at [x] rather than at []
11:19:22 <Peaker> @src MonadTrans
11:19:22 <lambdabot> Source not found. You speak an infinite deal of nothing
11:20:01 <Peaker> MonadTrans is not a MPTC?  Didn't know that
11:20:03 <maskd> doesn't ghc use a finger tree or something like that for lists?
11:20:17 <Peaker> maskd, no
11:20:21 <Peaker> class MonadTrans t where lift :: (Monad m) => m a -> t m a
11:20:52 <Peaker> nolrai_FG, it implies it because to implement lift, it would have to, but Haskell is not smart enough to see this
11:20:54 <temoto> My friend and i just discovered that functions like product, which take lists is a haskell way to express python func(*args) idiom.
11:21:05 <Peaker> nolrai_FG, Just have another class context
11:21:21 <temoto> It doesn't even change the notation so much: instead of func(1,2,3,4) you get func [1,2,3,4]
11:21:34 <Peaker> temoto, In Python, I hated using *args except for "forwarding" args without caring what they are
11:21:59 <Peaker> temoto, Yeah, I recently realized Python's normal call syntax  f (1,2,3,4)  is also valid Haskell syntax for uncurried calls :)
11:22:31 <dozu> intersec (x:xs) (y:ys)
11:22:31 <dozu> 	| x == y = x:(intersec xs ys)
11:22:31 <dozu> 	| intersec = (intersec xs ys)
11:22:36 <dozu> doesnt work 4 me :(
11:22:54 <temoto> > let plus = curry (+) in (plus (1,2))
11:22:55 <lambdabot>   No instance for (GHC.Num.Num ((t, t1), b))
11:22:55 <lambdabot>    arising from a use of `GHC.Nu...
11:22:55 <Berengal> In python: def unzip(list): return zip(*list)
11:22:56 <ziman> but you're restricted to the same type for all elements
11:23:07 <mauke> dozu: you misspelt 'otherwise'
11:23:19 <Peaker> dozu, Why do you use "intersec" as a guard?
11:23:25 <dozu> sry my bad
11:23:29 <dozu> but still doesnt work
11:23:36 <nolrai_FG> @ty lift . lift
11:23:37 <lambdabot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *) (t1 :: (* -> *) -> * -> *). (MonadTrans t, Monad (t1 m), MonadTrans t1, Monad m) => m a -> t (t1 m) a
11:23:38 <Peaker> dozu, Also, You don't need () after : and after =
11:23:39 <temoto> ziman, true.
11:24:21 <temoto> > let plus = uncurry (+) in (plus (1,2))
11:24:22 <lambdabot>   3
11:24:42 <temoto> almost lisp :)
11:25:06 <dozu> Peaker : ok but still doesnt work :)
11:25:11 <mauke> > ((+) 1 2)
11:25:12 <lambdabot>   3
11:25:23 <mauke> dozu: "doesn't work" is meaningless
11:25:23 <nolrai_FG> @ty writeIORef
11:25:24 <lambdabot> Not in scope: `writeIORef'
11:25:24 <Peaker> dozu, What does it do?
11:25:48 <dozu> prgramm erorr, pattern match.
11:26:04 <dozu> ive pattern match like intersec [] x = []
11:26:25 <dozu> because my 1 argument ist < as 2nd
11:26:29 <Peaker> @type intersect xs ys = map fst . filter (\(x,y) -> x==y) $ zip xs ys
11:26:30 <lambdabot> parse error on input `='
11:26:38 <Peaker> @type \xs ys -> map fst . filter (\(x,y) -> x==y) $ zip xs ys
11:26:39 <lambdabot> forall b. (Eq b) => [b] -> [b] -> [b]
11:26:48 <Peaker> @pl \xs ys -> map fst . filter (\(x,y) -> x==y) $ zip xs ys
11:26:48 <lambdabot> ((map fst . filter (uncurry (==))) .) . zip
11:27:15 <Peaker> dozu, well, what about pattern matching those cases?
11:38:03 <dozu> but works for
11:38:03 <dozu> intersec (x:xs) y
11:38:04 <dozu> 	| x `elem` y = x:intersec xs y
11:38:04 <dozu> 	| otherwise = intersec xs y
11:38:33 <Peaker> dozu, paste your code?
11:38:36 <dozu> why its dont work for x==y ( if y == (y:ys)
11:39:12 <Peaker> http://hpaste.org
11:39:34 <c15c8ra1n>   templates <- if hasOwnTemplates then liftM (addSubGroup parentTemplates) (directoryGroup $ dir </> "templates") else return parentTemplate
11:39:44 <c15c8ra1n> is there a way to rewrite this line in a nicer fashion?
11:39:58 <c15c8ra1n> e.g. without the liftM in the middle? :(
11:40:27 <Gracenotes> where did the 't' go? D:
11:41:16 <dozu> Peaker : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17249#a17249
11:42:31 <dschoepe> dozu: the second version doesn't work since it only compares the nth element of xs against the nth element of ys
11:43:07 <dschoepe> so unless the elements are at the same position in both lists, they aren't in the result
11:43:09 <Peaker> c15c8ra1n, You could use a do block/split this to its own definition
11:43:16 <Twey> templates <- if hasOwnTemplates then addSubGroup parentTemplates <$> directoryGroup (dir </> "templates") else return parentTemplate
11:43:33 <Berengal> Nice, I've been spamming my webserver with requests for hours now, and it's only using 10Mb of memory despite not GCing the sessions
11:44:42 <SamB_XP> Berengal: wait -- you mean it uses less than 10 MB at startup?
11:44:45 <c15c8ra1n> Twey: what does <$> do?
11:44:55 <Twey> (<$>) = fmap
11:44:56 <Berengal> SamB_XP: It uses 0.4 Mb at startup
11:45:15 <domor> @pl (\x y -> filter (`elem` y) x)
11:45:15 <lambdabot> flip (filter . flip elem)
11:45:17 <Berengal> But jumps to 1.5 once it gets a few requests
11:45:33 <Peaker> Berengal, what does it do?
11:45:37 <c15c8ra1n> Twey: oh, thanks! I didn't know about fmap :D
11:46:07 <domor> > let intersect = flip (filter . flip elem) in intersect [1,2,3,555] [232,434,3,4989,2]
11:46:08 <lambdabot>   [2,3]
11:46:15 <Berengal> Peaker: Very little; http://85.200.142.237:5000/
11:46:27 <domor> > let intersect = filter . flip elem in intersect [1,2,3,555] [232,434,3,4989,2]
11:46:28 <lambdabot>   [3,2]
11:46:37 <c15c8ra1n> what's the difference between fmap and liftM?
11:46:53 <mauke> c15c8ra1n: liftM is restricted to monads. otherwise, none really
11:46:56 <c15c8ra1n> I probably mean.. what are Functors? :(
11:46:57 <Berengal> Peaker: The interesting part is the code; http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17250#a17250
11:46:57 <FliPPeh_> Hey, I never noticed the Haskell Plattform
11:47:06 <ben> and fmap is restricted to functors~
11:47:10 <FliPPeh_> Too bad the GHC version is old.
11:47:32 <domor> @google typeclassopedia
11:47:34 <lambdabot> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
11:47:34 <lambdabot> Title: The Monad.Reader Issue 13
11:47:34 <Twey> c15c8ra1n: liftM = fmap on any sane Monad instance
11:47:45 <sjanssen> c15c8ra1n: if you've already got a handle on Monads, Functors are much simpler.  They're just objects that support a 'map' function
11:47:46 <domor> c15: this is probably what you want to read
11:47:54 <Peaker> Berengal, Ajax it ! :)
11:48:21 <sjanssen> all Monads are also Functors (though Haskell doesn't enforce this)
11:48:27 <c15c8ra1n> Twey, sjanssen: ok, thanks! reading now
11:48:36 <Berengal> Peaker: I will. Currently it doesn't even support more than one page, but I'm working on embedding multiple continuations in a single page
11:49:03 <dozu> domor : your example is too tricky 4 me :)
11:49:05 <Peaker> is <<  flip (>>) ?
11:49:42 <domor> dozu: if you take the non-pointless version I think it's not too hard: filter (`elem` y) x
11:49:46 <Berengal> Peaker: No, it's the HTML-generic version of $
11:49:52 <Peaker> oh
11:50:10 <Berengal> It's from the xhtml library
11:50:33 <dozu> with the point its mean like filter(flip elem ) ?
11:51:09 <domor> the points?
11:51:47 <dozu> your point version "(filter . flip elem)"
11:51:56 <dozu> with the point inside
11:52:15 <Twey> No points there
11:52:21 <domor> @type (.)
11:52:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:53:01 <RayNbow> when talking about point-free/pointless and point-full, point does not refer to the dot (.) of function composition
11:53:08 <domor> more simply (.) :: (b -> c) -> (a -> b) -> a -> c
11:54:21 <dozu> ok so dot means concatanation of functions
11:54:25 <dozu> or what? :)
11:54:30 <mauke> composition
11:54:35 <RayNbow> "A common misconception is that the 'points' of pointfree style are the (.) operator (function composition, as an ASCII symbol), which uses the same identifier as the decimal point. This is wrong. The term originated in topology, ..." [ http://www.haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21 ]
11:54:49 <domor> it's called composition, it's like the circle in maths when you say f . g
11:54:59 <mauke> f âˆ˜ g
11:55:24 <domor> I can't see or type it under emacs though, perhaps not in my font
11:55:42 <dozu> @type length
11:55:43 <lambdabot> forall a. [a] -> Int
11:56:21 <dozu> ok i copy that now
11:56:38 <domor> but pointless or not isn't really the point here ;) - rather, if you can, use map and filter. it's nicer than explicit recursion or conditionals
11:57:18 <domor> although it's not a bad idea to do recursion for practice at the beginning
11:58:27 <dozu> i think i can recursion (more or less) im fighting with lists ad list comprehension
11:59:44 <dozu> ok new wall... power set of a list with list compr. any tips?
12:00:12 <copumpkin> you'll need a recursive definition of it but it's possible
12:00:20 <copumpkin> I prefer the filterM approach though
12:00:51 <c15c8ra1n> is there an alias for flip ($) ?
12:00:58 <dozu> power set with list compr. too tricky for a newb like me?
12:01:01 <Twey> c15c8ra1n: No
12:01:05 <Gracenotes> c15c8ra1n: yep, flip id
12:01:09 <dschoepe> c15c8ra1n: Control.Arrow.(>>>)
12:01:11 <Gracenotes> otherwise... :|
12:01:11 <Twey> Ha
12:01:15 <copumpkin> dschoepe: that's different
12:01:21 <Twey> dschoepe: That's flip (.)
12:01:22 <copumpkin> that's more like flip (.)
12:01:27 <dschoepe> oh, right
12:03:18 <dschoepe> > [x | x <- [1..4], y <- [True, False], y]
12:03:19 <lambdabot>   [1,2,3,4]
12:03:50 <RayNbow> > let {powerset [] = [[]]; powerset (x:xs) = concat [[xs',(x:xs')] | xs' <- powerset xs]} in powerset [1..3]
12:03:51 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:04:05 <Berengal> > let infixl 1 ~>; (~>) = flip ($) in 1 ~> (+2) ~> (*4) ~> show ~> reverse
12:04:07 <lambdabot>   "21"
12:04:09 <Twey> > [x | x <- [1 .. 4], () <- [(), ()]]
12:04:10 <lambdabot>   [1,1,2,2,3,3,4,4]
12:04:16 <dozu> u guys crazy haskell cracks :D
12:04:51 <Gracenotes> > let (.) = flip ($) in 1.(+2).(*4).show.reverse
12:04:51 <lambdabot>   "21"
12:05:04 <dozu> RayNbow really good. will try to copy that
12:05:17 <copumpkin> dozu: if this is for homework you probably should try to figure it out yourself
12:05:18 <RayNbow> dozu: you should try to understand it, not copy it ;)
12:05:21 <copumpkin> without reading his solution
12:05:23 <Berengal> > filterM (const [True, False]) [1,2,3]
12:05:24 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:05:36 <dozu> its not for homework. just for me
12:05:39 <copumpkin> > subsequences [1..3]
12:05:40 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:05:46 <copumpkin> dozu: why force yourself to use list comps then?
12:05:54 <Gracenotes> copumpkin: or he should steal it, rather than copy it
12:06:07 <dozu> copumpkin, cuz i stil dont get how it works
12:06:10 <IceDane> Wasn't there a function that would take a list and return it without any duplicats?
12:06:14 <IceDane> duplicates*
12:06:14 <copumpkin> nub
12:06:21 <IceDane> ah, yeah, thanks
12:06:28 <copumpkin> IceDane: beware, it's n^2
12:06:28 <Muad_Dibber> > nub [1,1,2]
12:06:29 <lambdabot>   [1,2]
12:06:31 <dozu> i mean i know how it works but not 4 complex cases
12:06:34 <Berengal> Data.Set.toList . Data.Set.fromList is better
12:06:47 <copumpkin> only if you have Ord :)
12:06:48 <IceDane> copumpkin: ah.. that might be bad
12:06:58 <jlouis> and if your list is rather large
12:07:11 <jlouis> nub is fine for 10 element stuff
12:07:11 <copumpkin> nub works fine on infinite list
12:07:22 <copumpkin> assuming you don't care about performance :P
12:07:30 <Berengal> copumpkin: "fine" may be overstating it...
12:07:37 <RayNbow> > nub [1,1...]
12:07:38 <lambdabot>   A section must be enclosed in parentheses thus: (1 ...)Not in scope: `...'
12:07:43 <RayNbow> ah crap
12:07:46 <RayNbow> > nub [1,1..]
12:07:50 <lambdabot>   mueval-core: Time limit exceeded
12:07:52 <dozu> @type filterM
12:07:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:07:53 <Berengal> But fun fact: it takes just as long to nub an infinite list as it takes to simply traverse it
12:07:59 <copumpkin> > head $ nub [1,1..]
12:08:00 <lambdabot>   1
12:08:08 <copumpkin> lambdabot isn't lazy enough
12:08:14 <jlouis> it is rather fun, we can have technically correct functions that do not terminate
12:08:26 <c15c8ra1n> infixl 1 ~> sets the lowest priority, right?
12:08:36 <copumpkin> toList . fromList also reorders your input list
12:08:39 <ddarius> jlouis: There are a lot of those, not just in Haskell.
12:08:39 <medfly> how do I tell if one implementation of a function is faster than another?
12:08:42 <Berengal> c15c8ra1n: I think so.
12:08:53 <RayNbow> > [x | x <- [1..], x < 10]  -- copumpkin, this one is also fun to explain to new Haskell users :p
12:08:55 <sm> medfly: measure them with criterion
12:08:57 <lambdabot>   mueval-core: Time limit exceeded
12:09:00 <jlouis> ddarius: indeed
12:09:03 <sm> and progression
12:09:08 <medfly> ? :/
12:09:14 <copumpkin> RayNbow: especially when lambdabot isn't overly strict
12:09:19 <sm> both available on hackage
12:09:40 <medfly> are they package names?
12:09:51 <ddarius> 1:2:3:4:5:6:7:8:9:_|_
12:10:01 <Veinor> > take 9 [x | x < [1..], x < 10]
12:10:02 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
12:10:02 <lambdabot>         against inferred ...
12:10:03 <copumpkin> I thought lambdabot used to be less strict
12:10:07 <sm> medfly: yes
12:10:09 <Veinor> > take 9 [x | x <- [1..], x < 10]
12:10:10 <lambdabot>   [1,2,3,4,5,6,7,8,9]
12:10:12 <medfly> Veinor, <-
12:10:16 <Veinor> yeah, I typo'd
12:10:17 <medfly> no? err...
12:10:21 <medfly> okay
12:10:29 * medfly is too lazy
12:10:30 <medfly> never mind
12:10:46 <sm> well, have a look at http://hackage.haskell.org/packages/archive/criterion/0.4.1.0/doc/html/Criterion-Main.html anyway
12:11:01 <domor> medfly: you know about +RTS -sstderr right?
12:11:07 <ddarius> @hackage criterion
12:11:07 <lambdabot> http://hackage.haskell.org/package/criterion
12:11:15 <domor> that's the lazy person way...
12:11:40 <medfly> making sense of packages is so much effort :)
12:11:55 <ddarius> Depends on the package.
12:12:17 <RayNbow> dozu: have you figured out how the list comprehension works in my powerset definition?
12:12:24 <medfly> depends on how lazy you are
12:13:10 <sm> domor: that's a good way to test the whole program, and indeed probably much the easiest
12:13:14 <dozu> RayNbow : a little bit , little bit freaky recursion. but if i see it its looks logicaly
12:13:33 * sm used "time myprog..." a lot 
12:13:35 <dozu> RayNbow : i think i cant figure it out by myself...
12:13:46 <Peaker> filterM (const [True, False])
12:13:50 <dozu> > take 9 [x | x <- [1..]]
12:13:51 <lambdabot>   [1,2,3,4,5,6,7,8,9]
12:14:00 <sm> domor: why -sstderr.. -s seems enough here
12:15:07 <sm> medfly: indeed.. I just spent the two hours doing that figuring out, so feel free to ask me before it fades....
12:15:23 <Peaker> @src filterM
12:15:23 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:15:42 <domor> sm: that's what I read in Real World Haskell - thanks for the shortcut though
12:15:47 <medfly> I wrote a simpler looking version of filter, filter f list = [a | a <- list, f a] and I wonder if it's faster than the current filter.
12:15:58 <medfly> I'm not that interested in it, is all
12:16:14 <Peaker> medfly, Why would it be faster?
12:16:15 <IceDane> There is no way to get the nth root of a number in haskell?
12:16:22 <medfly> Peaker, I mostly want to know if it's slower
12:16:30 <Twey> > 8 ** (1/3)
12:16:31 <lambdabot>   2.0
12:16:35 <IceDane> oh, yeah, that works
12:16:45 <dozu> RayNbow : because of recursion it will return [] at first place? at your def. ?
12:16:54 <Peaker> medfly, it more easily generalizes to MonadPlus rather than just lists
12:17:03 <medfly> Peaker, what does
12:17:21 <domor> isn't the list comprehension turned into a filter anyway?
12:17:36 <medfly> dunno how to tell
12:17:55 <medfly> ...
12:19:47 <lpjhjdh> what font should I use with agda?  It's really annoying that double wide right arrow (which I take from a non-monospaced typeface) makes all my columns fail to line up
12:20:14 <RayNbow> powerset [] = [[]];   powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)   -- well dozu, let's start with this first... do you understand this definition?
12:21:01 <domor> medfly: the internet seems to say so, but if you're motivated you could check the core output that's generated (-ddump-simpl on GHC IIRC)
12:21:20 <medfly> nah, not motivated at all
12:21:22 <medfly> thanks I guess
12:21:24 <dozu> RayNbow : i do. but hard to imaginate because of recursion
12:21:31 <domor> haha
12:21:43 <dozu> oh ok now i get it
12:21:54 <lpjhjdh> also, usually using vi, I'm emacs retarded
12:23:04 <RayNbow> dozu: recursion is only hard to imagine if you're going to fully evaluate it in your head :p
12:23:06 <dozu> first of all its returns a list of sets with single variable right RayNbow?
12:23:09 <RayNbow> humans have limited stack space :p
12:23:27 <dozu> RayNbow : i do this alway , thats my problem i think :D
12:23:36 <dozu> thats sad :D
12:25:42 <Gracenotes> RayNbow: no CSE? :o
12:25:53 <RayNbow> <dozu> first of all its returns a list of sets with single variable right RayNbow?  <-- the result actually starts with the empty sublist, but the order is not important to understand recursion
12:26:44 <RayNbow> Gracenotes: I don't feel like introducing a where or a let :p
12:27:10 <RayNbow> dozu, could you write down all possible sublists of []?
12:27:12 <Dashkal> Any suggestions on secure network communication in haskell?  A run through hackage shows me a few incomplete bindings that haven't been touched in a year or more.
12:27:28 <dozu> its [[]]
12:28:20 <RayNbow> dozu, could you also give me all sublists of [1]?
12:29:11 <dozu> i know thats [[],[1]], but for [1,2] ive stack overflow in my brain using your def :)
12:29:39 <dankna> Dashkal: hsgnutls is the most complete library, I believe
12:29:41 <RayNbow> so yes, all sublists of [1] are [] and [1]
12:29:48 <dankna> but it does need a trivial patch to compile on recent ghcs
12:30:06 <RayNbow> and all sublists of [] is just []
12:30:15 <Dashkal> hmm
12:31:12 <RayNbow> powerset [] = [ [] ]   -- so dozu, the base case is quite simple
12:31:13 <dozu> but in your def powerset [] = [[]] . so for powerset [1] its should look like [ [1],[[]] ]... or what :
12:31:26 <RayNbow> powerset [1] = [  [],   [1]  ]
12:31:51 <dozu> i get that
12:32:06 <RayNbow> you could also say   [   [1],    []   ], the order doesn't really matter
12:32:25 <dozu> yep the order is not the problem.
12:33:10 <dozu> wait a sec. im trying to do recursion on my paper
12:33:40 <RayNbow> now the trick with recursion is: you should assume you can always find the solution to a smaller problem
12:34:15 <dozu> and the smaller problem is [] = [[]] ?
12:34:16 <MissPiggy> there are two tricks in recursion actually
12:34:16 <RayNbow> in case with powerset, if you need to find all subsets of (x:xs), you should assume that finding all sublists of xs is not a problem
12:34:49 <RayNbow> dozu: not necessarily. That's actually the smallest problem and is the base case
12:36:15 <dozu> so for powerset [1] we got like : "powerset [] ++ map (1:) [[]]" right?
12:36:42 <RayNbow> yes, but do you understand why?
12:37:36 <uragano4699> ciao
12:37:38 <dozu> yes i do. but what would map (1:) [[]] return?
12:37:47 <uragano4699> !list
12:37:48 <RayNbow> > map (1:) [[]]
12:37:49 <lambdabot>   [[1]]
12:37:50 <caution> 1 guy 1 cup
12:38:21 <RayNbow> it prepends the value 1 to each sublist
12:38:28 <dozu> damn you good :D
12:38:41 <RayNbow> > map (1:) [[], [2], [3,4,5,6]]
12:38:42 <lambdabot>   [[1],[1,2],[1,3,4,5,6]]
12:39:04 <RayNbow> > (1:) [2]
12:39:05 <lambdabot>   [1,2]
12:39:06 <caution> 1 2 3 4
12:39:07 <dozu> so at the end its like [[]] ++ [[1]]. ok thats fine
12:39:54 <RayNbow> the (++) indicates that we have a choice
12:40:00 <RayNbow> if we are given (x:xs), we can create two different kinds of sublists
12:40:15 <RayNbow> sublists that include the element x, but also sublists that don't include x
12:41:57 <RayNbow> map (x:) (powerset xs)  -- we compute all sublists of xs, and prepend x to each sublist
12:42:14 <RayNbow> powerset xs  -- we compute all sublists of xs, but don't include element x
12:42:32 <RayNbow> does this make sense, dozu?
12:42:47 <FliPPeh_> Why does my program needs two "Ctrl-C" to quit?
12:42:53 <FliPPeh_> Can someone explain this to me? ;x
12:43:10 <dozu> sure , but its like hard to figure it out 4 me :/
12:43:18 <dozu> i think i need to work on recursion
12:52:12 <Saizan> FliPPeh_: are you running it in ghci?
12:52:14 <RayNbow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17258  -- dozu
12:52:26 <RayNbow> (just all the code in a paste)
12:52:32 <dozu> ty mate
12:52:41 <dozu> sec,will take a look
12:52:46 <FliPPeh_> Saizan: nope
12:53:05 <RayNbow> dozu: it's almost the same I already typed here, but I added a few extra names
12:58:59 <dozu> powerset [] = [ [] ]
12:58:59 <dozu> powerset (x:xs) = [ys | ys <- powerset xs]
12:59:10 <dozu> its returns [[]]
12:59:11 <dozu> why?
12:59:28 <dozu> if i try just THIS part of code
12:59:48 <Botje> dozu: uh, you don't actually do something with xs ?
12:59:51 <Botje> *x
12:59:54 <mrd> you never give it anything else to do
13:00:06 <dschoepe> dozu: you always cut off x, so there's nothing left to return
13:00:07 <Botje> try something like ys ++ map (x:) ys
13:00:19 <dozu> ok , my bad :D
13:00:43 <dozu> think its too late and my brain overcooking :)
13:02:53 <Cale> > filterM (const [False, True]) [1,2,3]
13:02:54 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
13:03:44 <mmmulani> > filterM (const [True, False]) [1,2,3]
13:03:45 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:04:19 <djahandarie> Cale, ew!
13:04:19 <mmmulani> > mapM permutations [[1,2],[3,4]]
13:04:20 <lambdabot>   [[[1,2],[3,4]],[[1,2],[4,3]],[[2,1],[3,4]],[[2,1],[4,3]]]
13:04:30 <Cale> djahandarie: hm?
13:05:03 <dozu> there is no filterM function on zvon.org
13:05:13 <djahandarie> Cale, space leak. >=[
13:05:15 <Botje> it's in control.monad
13:05:16 <Cale> Don't use zvon.org as your documentation.
13:05:26 <Zao> I dislike how zvon appears in the google hits.
13:05:33 <Zao> As it's horribly useless and seems rather old.
13:05:36 <djahandarie> > length $ filterM (const [True, False]) [1,2,3]
13:05:37 <lambdabot>   8
13:05:38 <caution> 80's music
13:05:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
13:05:43 <djahandarie> > length $ filterM (const [True, False]) [1..1000]
13:05:48 <lpjhjdh> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:05:49 <lambdabot>   mueval-core: Time limit exceeded
13:05:52 <djahandarie> Hm
13:05:53 <Cale> djahandarie: Space leak?
13:05:56 <djahandarie> Can't really demonstrate on lambdabot
13:06:04 <djahandarie> Cale, it will eat memory
13:06:11 <mmmulani> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 1000
13:06:14 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
13:06:22 <mmmulani> oh whoops
13:06:25 <dozu> lol
13:06:26 <mmmulani> > 2^1000
13:06:26 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
13:06:27 <caution> 2 1000 yard rushers
13:07:07 <dozu> haskell is actually really fun
13:07:07 <ddarius> caution appears to be some kind of bot that responds to numerals.
13:07:10 <Cale> djahandarie: Surely only a polynomial amount of space.
13:07:44 <sinelaw> 23
13:07:54 <copumpkin> 24
13:07:55 <djahandarie> Cale, it should be able to run in constant space
13:08:01 <sinelaw> 23
13:08:04 <copumpkin> 22
13:08:07 <Cale> djahandarie: oh?
13:08:13 <Cale> djahandarie: I'm pretty sure it can't.
13:08:14 <sinelaw> nondeterministic, eh
13:08:16 <sinelaw> 8
13:08:20 <mmmulani> Cale: it easily can
13:08:36 <sinelaw>   8
13:08:44 <Cale> You need to keep track of at least the index in the powerset.
13:08:45 <djahandarie> Cale, powerset [] = [[]]; powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
13:08:46 <copumpkin> 7
13:08:46 <sinelaw> > 4+4
13:08:47 <lambdabot>   8
13:08:47 <caution> 4+4 off road
13:08:51 <sinelaw> aha
13:08:53 <sinelaw> > 2+2
13:08:53 <Cale> djahandarie: That doesn't run in constant space.
13:08:54 <lambdabot>   4
13:09:03 <djahandarie> Cale, the length will
13:09:04 <sinelaw> > 4^2
13:09:06 <caution> 4 20
13:09:06 <lambdabot>   16
13:09:07 <caution> 16 and pregnant
13:09:08 <Cale> djahandarie: Nope.
13:09:12 <djahandarie> Cale, try it
13:09:13 <sinelaw> what's the point of caution
13:09:16 <sinelaw> @bot
13:09:16 <lambdabot> :)
13:09:21 <caution> I'm a human
13:09:27 <Cale> djahandarie: It runs in an amount of space which is negligible, the same as the filterM version.
13:09:31 <sinelaw> so what's your point, human?
13:09:43 <caution> just trying to help
13:09:57 <Cale> hmm
13:10:01 <djahandarie> Cale, errr
13:10:48 <Cale> Perhaps I should think about that some more.
13:11:11 <Cale> GHC 6.10.4 seems to be doing something unexpected space-wise.
13:12:25 <djahandarie> Cale, it has to do with the definition of filterM
13:15:52 <mjrosenb> hey, does anyone know how to turn on certain warnings when entering a ghci session in emacs?
13:16:44 <dschoepe> mjrosenb: you can put a shell-script `ghci' in your path before the real ghci, that calls it with some options
13:16:52 <mreh> is there a simple function for doing minus between two Data.Seqences.Seqs
13:16:53 <Berengal> mjrosenb: Use a .ghci file, and possibly set the ghci-location, or whatever that variable was called, to a script that launches ghci with the custom .ghci
13:17:18 <dschoepe> "haskell-program-name" was the name of that variable iirc
13:17:53 <Cale> djahandarie: Actually, it's just the list monad.
13:18:10 <Cale> djahandarie: Replacing the list monad with Control.Monad.Logic fixes the space problem.
13:18:15 <mjrosenb> custom .ghci sounds like it is the best.
13:18:37 * MissPiggy wishes a better name than 'Logic'
13:18:56 <djahandarie> Cale, filterM p (x:xs) = do { flg <- p x; ys <- FilterM p xs; return (if flg then x:ys else ys) }
13:19:01 <djahandarie> Err, might have gotten that syntax wrong
13:19:04 <djahandarie> But yeah
13:19:12 * Berengal suggests LIST-TRON
13:19:18 <djahandarie> Cale, flip around the ys and flg and the space won't be leaked
13:19:23 <MissPiggy> nice
13:19:56 <djahandarie> Cale, the solution arranges the sharing among the tails of the sublists so that shared sublists appear adjacent to each other in the overall order
13:21:06 <dschoepe> djahandarie: that would change what filterM does for some monads though, wouldn't it?
13:21:10 <djahandarie> dschoepe, yes.
13:21:18 <Cale> powerset' = observeAll . filterM (const (msum . map return $ [True, False]))
13:21:35 <lpjhjdh> @src filterM
13:21:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:21:37 <Cale> ^^ that at least runs in constant space with the standard definition of filterM
13:21:51 <Cale> Well "constant"
13:22:02 <Cale> It's impossible to actually run in constant space.
13:22:14 <Cale> You need to at least keep track of where in the powerset you are.
13:22:22 <Berengal> Someone will invent the code threadmill...
13:22:31 <Cale> and that requires an index with n bits, where n is the length of the input list
13:23:25 <Cale> So it's O(n) space, no matter what you do.
13:23:39 <RayNbow> @hoogle observeAll
13:23:40 <lambdabot> No results found
13:23:53 <Cale> It's in Control.Monad.Logic, in the logict package.
13:24:15 <Cale> Which is an efficient implementation of something equivalent to the list monad.
13:24:19 * hackagebot upload: kangaroo 0.3.0 - Binary parsing with random access. (StephenTetley)
13:24:26 * djahandarie pokes lpsmith
13:24:37 <Cale> Together with lots of useful things like fair choice operators.
13:24:39 <RayNbow> @go observeAll inurl:hackage
13:24:39 <lambdabot> Maybe you meant: google googleit do
13:24:44 <RayNbow> @google observeAll inurl:hackage
13:24:45 <lambdabot> No Result Found.
13:24:50 <lpsmith> djahandarie, eh?
13:24:53 <Cale> http://hackage.haskell.org/packages/archive/logict/0.4/doc/html/Control-Monad-Logic.html
13:24:58 <djahandarie> lpsmith, didn't you write something regarding this powerset issue
13:25:11 <RayNbow> thx Cale :)
13:25:29 <lpsmith> yeah,  on reddit, though I'd like to edit it a bit and put it in my blog
13:25:52 <MissPiggy> > 1+1
13:25:53 <lambdabot>   2
13:25:53 <caution> 1+1 3 proof
13:25:54 <caution> 2010 calendar
13:26:19 <lpsmith> http://www.reddit.com/r/programming/comments/akk48/anyone_care_to_share_neat_haskell_tricks/c0i22kn
13:26:38 <Cale> caution: what?
13:26:48 <sinelaw> > 1+1
13:26:49 <lambdabot>   2
13:26:56 <sinelaw> > 2+2
13:26:57 <lambdabot>   4
13:27:02 <sinelaw> > 4+4
13:27:03 <lambdabot>   8
13:27:21 <djahandarie> lpsmith, isn't that definition you gave a parse error?
13:27:36 <lpsmith> yeah,  i just fixed that
13:27:58 <lpsmith> it wasn't wrong originally, I don't think;  I'm guessing reddit changed it's markdown parser
13:28:44 <crazyhors>   /part
13:28:56 <Cale> Oh, I suppose the way that Control.Monad.Logic manages to do it efficiently is similar to changing the definition of filterM
13:29:08 <Cale> (but doesn't require changing the definition of filterM)
13:30:06 <Cale> er, no, the order ends up the same as the original :)
13:31:11 <lpsmith> powerSet' = foldr (\x -> concatMap (\xs -> [x:xs,xs])) [[]]
13:32:44 <Cale> > let powerset = observeAll . filterM (const (msum . map return $ [True, False])) in powerset "abc"
13:32:46 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
13:32:54 <damd> observeAll?
13:33:17 <Cale> damd: observeAll  :: Logic  a -> [a]
13:33:27 <Cale> ( http://hackage.haskell.org/packages/archive/logict/0.4/doc/html/Control-Monad-Logic.html )
13:33:47 <djahandarie> foldr isn't tail recursive though
13:34:29 <copumpkin> it's lazy recursive :P
13:34:32 <copumpkin> which is even better
13:34:39 <pikhq> @src foldr
13:34:40 <lambdabot> foldr f z []     = z
13:34:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:34:40 <RayNbow> guarded recursion ftw :p
13:34:49 * lpsmith is reading the conversation that got me involved
13:34:57 <pikhq> Yup, definitely not tail recursive.
13:35:03 <pikhq> Lazy recursion, though, is much nicer.
13:35:15 <lpsmith> length (powerset xs) can be implemented in logarithmic space
13:35:37 <Cale> Tail recursion isn't quite so relevant in lazy evaluation as it is in strict evaluation. TCO doesn't mean anything in this context.
13:35:44 <lpsmith> powerset [] = [[]]; powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)   <-- also leaks space badly
13:35:53 <Cale> lpsmith: You mean linear space.
13:36:12 <copumpkin> depends linear or logarithmic with respect to what :P
13:36:16 <Cale> Yeah.
13:36:37 <copumpkin> it's logarithmic with respect to the exponent of whatever Cale was talking about being linear
13:36:43 <lpsmith> And I would guess you can use the powerset / filterM trick well,  if you change either the definition of filterM or the monad;  but the combination is bad
13:37:03 <dolio> powerset [] = [[]]; powerset (x:xs) = powerset xs ++ map (x:) (powerset xs) shouldn't leak space.
13:37:12 <dolio> But it doesn't have any sharing.
13:37:14 <Cale> Oh, I suppose it's log space if you discount the space required for the input list.
13:37:31 <Cale> Or assume that the input list won't all need to be in memory
13:38:23 <Cale> powerset [] = [[]]; powerset (x:xs) = map (x:) (powerset xs) ++ powerset xs
13:38:23 <Cale> powerset' = observeAll . filterM (const (msum . map return $ [True, False]))
13:38:29 <lpsmith> oops
13:38:45 <lpsmith> dolio, you are right;  I misread the definition :-/
13:38:58 <Cale> ^^ those generate the same results, but the second is a bit faster
13:39:08 <Dashkal> I'm having trouble installing a library from hackage (RSA).  Can someone point me in the right direction for steps to resolve this kind of problem? (It's failing when compiling Test.hs)
13:39:09 <Cale> I wonder if there's any sharing.
13:39:22 <dschoepe> Dashkal: what's the error?
13:39:37 <Dashkal> moment
13:39:39 <Cale> I'll try installing it.
13:40:19 <Dashkal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17263#a17263
13:40:26 <lpsmith> cale:  yeah, I guess it would be linear with respect to the length of the list;   you need the list,  and the entire list is one of the sub-lists
13:40:57 <Cale> lpsmith: right.
13:41:14 <dschoepe> Dashkal: looks like there's a missing version constraint on quickcheck in RSA
13:41:28 <Cale> lpsmith: If you do something ultra-clever, you could fuse the generation of the lists with the length function, but it requires knowing things about length.
13:41:58 <lpsmith> Cale:   length (powerset xs) == 2 ^ (length xs)  :-P
13:42:12 <Cale> lpsmith: right :)
13:42:12 <doserj> Dashkal: ghc-pkg hide QuickCheck-2.1.0.2 (or whatever version of QuickCheck 2 you have installed)
13:42:16 <lpsmith> much, much faster,  less space :)
13:42:28 <djahandarie> Too bad the compiler doesn't do CSE ;)
13:42:45 <lpsmith> GHC does CSE
13:42:51 <dolio> No, it's not bad.
13:42:57 <Cale> The RSA package builds okay for me on Linux with 6.10.4
13:43:07 <Dashkal> Hiding it made no difference
13:43:44 <Cale> Dashkal: Yeah, it looks like it's accidentally building with the old version of QuickCheck
13:43:50 <Dashkal> I'm running the same version of ghc.  Quickcheck is 2.1.0.3
13:44:11 <lpsmith> djahandarie, check out the -fno-cse flag
13:44:35 <Dashkal> ghc-pkg list QuickCheck shows only that version
13:44:47 <lpsmith> Of course,  I haven't figured out all the ins and outs of GHC's CSE transformation,  but it is there
13:44:56 <dschoepe> Dashkal: strange, it builds fine here with the same quickcheck version
13:45:04 * Dashkal boggles
13:45:13 <dolio> GHC only does CSE when you have something like "let x = e in ... e ...".
13:45:14 <Dashkal> How do I always manage to get the un-reproducable problems?
13:45:23 <dolio> Or when that happens in an intermediate phase.
13:45:31 <dschoepe> Dashkal: Does ghci know coarbitrary after importing Test.QuickCheck.Arbitrary?
13:45:36 <lpsmith> Cale:  so would the Logic monad leak space if you used the alternative definition of filterM?
13:45:51 <Cale> lpsmith: That's a good question. I doubt it, but I'll try it anyway :)
13:45:57 <Dashkal> Yes it does
13:46:37 <Dashkal> hmm... poking in .cabal, I just found 1.2.0.0 lurking in there
13:46:42 <djahandarie> Hell, didn't dolio write the Control.Monad.Logic? haha
13:46:53 <Cale> lpsmith: Appears to run in tiny space.
13:47:05 <Dashkal> But ghc-pkg doesn't seem to see it
13:47:45 <dolio> Dashkal: RSA depends on QuickCheck, which is probably pullin in QuickCheck 2.whatever, because I don't think it checks what you have hidden manually in ghc-pkg.
13:48:11 <dolio> The .cabal needs to be changed to specify QuickCheck < 2.
13:48:45 <Cale> djahandarie: He cribbed it from oleg. :)
13:48:49 <dozu> cya guys
13:48:52 <dolio> Yeah, mostly.
13:48:55 <Dashkal> ok, so it's looking for the old version?
13:48:57 <Cale> (and made it into a package :)
13:49:01 <dolio> I just made the names nicer.
13:49:07 <mreh> Can I do a fast binary search in a sorted Seq?
13:49:14 <mreh> Data.Sequence.Seq
13:49:37 <lpsmith> is there a way to set the .cabal file up so it depends on quickcheck only if you want to run tests?
13:49:37 <doserj> Dashkal: it needs the old version. You don't have QuickCheck 1 installed? (from the haskell platform?)
13:49:44 <dolio> O((log n)^2) probably.
13:49:53 <Dashkal> I saw a 1.2 hiding in my .cabal, but it doesn't seem to be registered
13:50:10 <mreh> dolio: was that to me?
13:50:10 <Dashkal> I wonder if it's a (please don't shoot me) Ubuntu fubar.
13:50:13 <dolio> Yes.
13:50:22 <Cale> If GHC had better deforestation, I bet the problems with the normal filterM version which uses the list monad would go away.
13:50:44 <mreh> dolio: shame there is no n log n performance...
13:50:46 <Cale> But I'm not sure.
13:50:52 <mreh> log n*
13:51:10 <dolio> You could get log n with an immutable array.
13:51:13 <lpsmith> Cale, I don't think so;  unless I misunderstand your statement somehow
13:51:21 <dolio> But indexing into a Seq is O(log n), I think.
13:51:47 <Dashkal> Yes, that was it.  Thanks for the help troubleshooting
13:51:48 <lpsmith> If you generate that order with sharing,  the space leak is inherent
13:51:50 <Cale> lpsmith: Well, Control.Monad.Logic is just representing lists in a somewhat different fashion.
13:52:07 * Dashkal mutters something unpleasant about splitting distributions without a meta package...
13:52:17 <Cale> lpsmith: There's a bit of inversion of control going on though :)
13:52:18 <mreh> dolio plus the O(n) overhead getting it into the array
13:52:27 <mreh> so upperbound of O(n)
13:52:36 <sjanssen> Cale: (jumping into the conversation without reading the scrollback) the biggest problem with filterM is that it ends in "return (if p then ...)" rather than "if p then return ..."
13:52:39 <lpsmith> So you either have to break up the sharing,  or deforest the sub-lists themselves
13:52:44 <dolio> Yeah. It's not a win unless you can arrange to already have the array built.
13:53:18 <lpsmith> Yeah,  I should play around with the Logic monad more
13:53:19 <dolio> Cale: I suspect using Logic is analogous to never sharing any lists, which is why there's no space overhead.
13:53:20 <mreh> Urgh, keeping a list and a sequence synchronised
13:53:32 <mreh> I'll just fork out the time and computer it
13:53:38 <Cale> dolio: possibly
13:53:41 <mreh> compute*
13:54:47 <Cale> It'd be somewhat tedious to untangle all the continuation mess to get a good idea of what's going on.
13:55:19 <Berengal> Continuations!
13:56:08 <Twey> USE MORE CONTINUATIONS!  â€¦ wait, what were we talking about?
13:56:29 <Cale> But yeah, even with the other definition of filterM, I don't see any increase in memory usage from it after 10 minutes or so.
13:56:29 <Berengal> Continuations, apparantly
13:56:57 <Cale> Twey, Berengal: Implementing combinations/powerset with filterM, and space usage.
13:57:04 <Twey> Oh, right
13:57:05 <caution> oh right quagmire
13:57:14 <Cale> Is caution an actual person?
13:57:33 <caution> yeah
13:58:04 <djahandarie> Markov chain maybe
13:58:17 <monochrom> moar continuazionz
13:58:29 * Berengal writes a continuation
13:58:50 <Cale> caution: Assuming that you are, please try to contribute meaningfully to the discussion. I've only seen Markov-chain-like responses from you.
13:58:50 <Twey> Heh
13:58:59 <mreh> mreh's Law, you cannot distinguish a lunatic from a Markov chain.
13:59:01 <Twey> caution: You just failed the Turing test.
13:59:02 <caution> yeah
13:59:03 <sjanssen> let's have a Turing Test!
13:59:21 * djahandarie hears an echo
13:59:22 <monochrom> You call that Markov-chain-like?!  I only see const "yeah".
13:59:29 <MissPiggy> q1: what is Turings first name
13:59:31 <lament> 3
13:59:33 <Twey> And â€˜oh right quagmireâ€™
13:59:52 <sjanssen> monochrom: there's a bit more if you look in the logs, all nonsense though
13:59:55 <Botje> MissPiggy: alan'; drop all tables;--
13:59:56 <Cale> monochrom: <caution> 1+1 3 proof <caution> 2010 calendar <caution> oh right quagmire
14:00:21 <mreh> giggady
14:00:52 --- mode: ChanServ set +o Cale
14:00:56 --- kick: caution was kicked by Cale (caution)
14:01:05 <Cale> hmm, autorejoin
14:01:10 <lament> Cale: caution caution: "caution, caution"
14:01:10 <caution> aww that was mean Cale
14:01:15 <monochrom> I too have found expanding Cont operators (or delimited cont operators) into lambda calculus harder to follow, not high-level. Ironically, the operational-semantics control-flow aspect is easier to follow and seem higher-level.
14:01:16 <Twey> Cloakâ€¦
14:01:39 <Twey> monochrom: Are *you* a Markov chain?  ;)
14:01:54 <dolio> yeah
14:01:55 <monochrom> I don't know.
14:01:56 <ddarius> monochrom: Isn't that to be expected?
14:01:57 <Cale> caution: Simpler question: Would you mind if I were to ban you?
14:02:00 <MissPiggy> lol lament
14:02:05 <caution> yeah
14:02:09 * Twey laughs.
14:02:10 <gwern> monochrom: 'const "yeah"' is a markov chain. 100% chance of 'y', which is connected to a 100% chance of 'e', which is...
14:02:11 <djahandarie> haha
14:02:20 <monochrom> heh gwern
14:02:23 <djahandarie> Cale, you fail against the bot!
14:02:28 <Cale> djahandarie: hehe
14:02:31 <lpsmith> Twey:   USE MOAR CONTINUATIONS!   <-  There,  FTFY  :-(
14:02:39 <lpsmith> err,  :-)
14:02:44 <monochrom> ddarius: I didn't expect at the beginning. But what did I know when I was a kid.
14:02:45 --- mode: Cale set -o Cale
14:02:50 --- mode: Lemmih set -o Lemmih
14:02:53 <ddarius> Simply ask "Would you mind if I were to not ban you?"
14:03:08 <djahandarie> ddarius, too late now
14:03:10 <MissPiggy> caution: if  Itold you have a beautiful body would you hold it against me?
14:03:16 <MissPiggy> awwwwwwwwwwww
14:03:18 <MissPiggy> it left
14:03:32 <djahandarie> It must have detected high levels of tension
14:03:41 <Twey> Its nipples exploded with delight.
14:03:55 <mreh> great boobies honeybun
14:04:58 <mreh> maybe It had a badly translated Hungarian phrase book
14:05:47 <mreh> was that the point you were trying to make?
14:06:54 <gwern> @wn naif
14:06:56 <lambdabot> *** "naif" wn "WordNet (r) 2.0"
14:06:56 <lambdabot> naif
14:06:56 <lambdabot>      adj : marked by or showing unaffected simplicity and lack of guile
14:06:56 <lambdabot>            or worldly experience; "a teenager's naive ignorance of
14:06:56 <lambdabot>            life"; "the naive assumption that things can only get
14:06:58 <lambdabot> [3 @more lines]
14:08:01 <gwern> @wn nerf
14:08:02 <lambdabot> No match for "nerf".
14:08:07 <gwern> silly unhip wordnet
14:08:31 <mreh> !markov
14:08:39 <mreh> :(
14:08:40 <dankna> I didn't know we had a wordnet feature
14:08:41 <dankna> nice
14:08:50 <aavogt> @webcam
14:08:50 <lambdabot> Unknown command, try @list
14:09:00 <dolio> @vera nerf
14:09:00 <lambdabot> No match for "nerf".
14:15:05 <mjrosenb> with strings should the cases a == b -> foo | a /= b -> bar be exhaustive?
14:15:38 <benmachine> I think any law-abiding instance of == has a == b = not (a /= b)
14:15:40 <Twey> monochrom: Yes
14:15:50 <idnar> mjrosenb: yes, but it seems silly to write it that way
14:15:51 <Twey> benmachine: Or vice versa
14:16:00 <benmachine> Twey: I meant as a rule, not as an implementation
14:16:10 <Twey> Ah, right
14:16:34 <monochrom> s/monochrom/mjrosenb
14:16:43 <mjrosenb> 10.4 complains that it isn't exhaustive
14:16:44 <benmachine> mjrosenb: if GHC is complaining that they aren't exhaustive, well, it's technically possible to write an Eq instance so that they are not
14:16:49 <benmachine> but no-one ever does
14:16:55 <benmachine> just make the second one "otherwise"
14:17:06 <mjrosenb> benmachine: i have, but a /= b is shorter
14:17:25 <benmachine> well, the other option is ignore/disable the warning
14:17:27 <mjrosenb> also, i know that a and b are strings
14:17:32 <benmachine> it inevitable gets it wrong sometimes
14:17:54 <mjrosenb> benmachine: yeah, i've turned it on to catch cases that are actually wrong
14:17:59 <monochrom> You need theorem-proving to see == and /= are exhaustive.
14:18:02 <mjrosenb> and there are a bunch of those
14:18:42 <mjrosenb> monochrom: if you know a /= x = not (a == b), then it should be pretty simple
14:18:46 <MissPiggy> I want to put (trivial) proofs in my haskell code
14:19:01 <MissPiggy> the reason is because sometimes stupid stuff like + binding tighter than * happens
14:19:23 <monochrom> GHC 134.8.1 will have a theorem prover for this kind of things.
14:19:25 <MissPiggy> if the thing just checked some easy proofs then I wouldn't have to worry so much
14:20:04 <benmachine> mjrosenb: but strictly speaking that's just convention, it's not enforced in the code in any way
14:20:26 <benmachine> of course it is true in this case, but if GHC remembered facts like that on a case-by-case basis, I can imagine that being a lot of information
14:20:28 <monochrom> But yes adding general logic to Haskell will help avoiding success. :)
14:21:10 <mjrosenb> i mean what percentage of instances for Eq actually define both (==) and (/=)?
14:21:55 <gwern> mjrosenb: download hackage, grep, and see
14:22:19 <MissPiggy> what is meant by general logic?
14:22:36 <monochrom> If you turn on separate compilation, the implementations of == and /= may be inaccessible at all.
14:22:56 <MissPiggy> also I think we could use quickcheck to do formal proofs
14:23:03 <MissPiggy> I just dont know how yet...
14:23:17 <copumpkin> jaspervdj: what happened to your AI competition entry? you were in the top 100 and now I can't see you anywhere :o
14:23:39 <MissPiggy> if you want to prove that two order 4 polynomials P1 and P2 are equal, you can just ask P1(x)==P2(x) for 4 different x values
14:23:51 <MissPiggy> or is that 5....
14:23:58 <MissPiggy> anyway there should be something similar in programming
14:24:19 <benmachine> if you want to prove two order 1 polynomials are equal, you have to check in two places
14:24:24 <MissPiggy> if you want to prove that some function is correct just test it on 5 different values
14:24:51 <dolio> You first need to prove that testing on 5 different values will prove that it's correct.
14:24:59 <monochrom> There is something similar in programming. If you just use 5 32-bit variables, you can just try 2^(5*32) values.
14:25:07 <benmachine> heh
14:25:21 <benmachine> you only need to test it for every possible state the RAM can be in
14:26:01 <MissPiggy> dolio yeah but that's a metatheorem
14:26:11 <monochrom> If you has a "straight-line" program (no loop, no recursion) containing 5 if-then-else's, there are only 2^5 paths to consider.
14:26:24 <MissPiggy> you only need to prove it once, infact you only need to read about it in a book once
14:26:40 <MissPiggy> then you can use it to prove all your programs (well, all the ones that fit into this smal class of programs..)
14:27:21 <benmachine> that class would probably be quite small
14:28:09 <mjrosenb> it would also be a class that is rather easy to prove by hand
14:28:19 <MissPiggy> guys.....
14:28:26 <jaspervdj> copumpkin: I'm switching to literate Haskell
14:28:33 <MissPiggy> there is no reason to assume either of those statements
14:28:52 <jaspervdj> copumpkin: and their compile system didn't accept it, so it currently fails to compile
14:29:07 <zachk> MissPiggy: the big problem is non termination of programs
14:29:14 <MissPiggy> yes
14:29:18 <jaspervdj> copumpkin: but it should reach the top 40 again once I convert it to a .hs file with sed and upload it again
14:29:31 <copumpkin> :)
14:29:33 <copumpkin> cool
14:29:50 <monochrom> Why argue? Just implement.
14:29:52 <zachk> i find ghc generally "proves" my program works
14:29:54 <dolio> Isn't there an unlit somewhere?
14:30:11 <MissPiggy> there is nothing to implement though
14:30:20 <zachk> MissPiggy: what do you mean nothing?
14:30:25 <MissPiggy> this is just something I feel like it must be the case, but haven't found it yet
14:30:44 <ddarius> "... and from pure mathematics to applied mechanics is but a step."
14:30:46 <dolio> I know there's at least an implementation of the C preprocessor on Hackage that also does lhs -> hs.
14:31:03 <dolio> Or, it says it does, at least.
14:33:59 <jaspervdj> copumpkin: yay, I'm getting compilation succes again
14:34:50 <Peaker> I need a preprocessor that can tell me which #include's it encountered (non-recursively)
14:35:19 * Berengal has written more continuationy goodness
14:35:28 <Berengal> Feels good
14:35:28 <benmachine> I have a /usr/lib/ghc-6.12.1/unlit
14:36:58 <MissPiggy> hey what about that Oleg
14:37:09 <MissPiggy> he did proofs about CWCC using macroexpand
14:37:26 <MissPiggy> and there's the parametricity theorems too, they've had real applications
14:37:32 <MissPiggy> and they work on any polymorphic function
14:37:35 <Gracenotes> @type uncurry (flip ?f)
14:37:36 <lambdabot> forall b a c. (?f::b -> a -> c) => (a, b) -> c
14:38:00 <MissPiggy> so I don't beleive i
14:38:00 <MissPiggy> it
14:38:15 <Cale> @free flip
14:38:16 <lambdabot> Expected variable or '.'
14:38:34 <Cale> @free map
14:38:35 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:39:00 <Cale> @free flip :: (a -> b -> c) -> (b -> a -> c)
14:39:00 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
14:40:23 <aavogt> @type flip
14:40:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:41:23 <Gracenotes> wat
14:42:07 <copumpkin> preflex: time preflex
14:42:16 <copumpkin> preflex: seen preflex
14:42:16 <preflex>  what
14:46:58 <gwern> 'Today, Clang completed its first complete self-host! We built all of LLVM and Clang with Clang (over 550k lines of C++ code). The resulting binaries passed all of Clang and LLVM's regression test suites, and the Clang-built Clang could then build all of LLVM and Clang again. The third-stage Clang was also fully-functional, completing the bootstrap.'
14:47:15 <MissPiggy> so it's self aware?
14:47:33 <copumpkin> ugh
14:47:40 * copumpkin cries at the thought of 550k lines of C++
14:49:11 <nolrai_FG> > [1..0]
14:49:12 <lambdabot>   []
14:49:16 <nolrai_FG> cool
14:49:23 <nolrai_FG> product []
14:49:29 <nolrai_FG> > product []
14:49:30 <lambdabot>   1
14:49:48 <gwern> > sum []
14:49:49 <lambdabot>   0
14:49:58 <gwern> mempty!
14:50:02 <benmachine> > maximum []
14:50:03 <lambdabot>   * Exception: Prelude.maximum: empty list
14:50:05 <benmachine> :(
14:50:07 <djahandarie> Interesting that product []  returns 1
14:50:19 <djahandarie> I know why, but still interesting
14:50:24 <gwern> djahandarie: scheme does the same thing
14:50:25 <benmachine> djahandarie: the product of no numbers is 1
14:50:31 <aavogt> > mconcat ([] :: [Sum Integer])
14:50:32 <lambdabot>   Sum {getSum = 0}
14:50:35 <gwern> > 0 * 0
14:50:36 <lambdabot>   0
14:50:41 <gwern> benmachine: lies!
14:50:54 <benmachine> gwern: that is the product of two numbers >:|
14:51:09 <benmachine> > let (*) = 1 in (*)
14:51:10 <lambdabot>   1
14:51:13 <benmachine> SEE
14:51:20 <djahandarie> lol
14:51:38 * benmachine is reading through ghc's darcs changelog
14:51:39 <benmachine> Mon Dec 21 11:02:50 GMT 2009  Simon Marlow <marlowsd@gmail.com> * Partial support for Haiku (#3727)
14:51:42 <benmachine> ...wat
14:51:49 <gwern> > let (*) = "benmachine is a dirty liar why do you lie benmachine what makes you lie" in (*)
14:51:50 <lambdabot>   "benmachine is a dirty liar why do you lie benmachine what makes you lie"
14:51:53 <nolrai_FG> > zip [1..] (map (3^) [1..])
14:51:54 <lambdabot>   [(1,3),(2,9),(3,27),(4,81),(5,243),(6,729),(7,2187),(8,6561),(9,19683),(10,...
14:52:07 <benmachine> :(
14:52:19 <gwern> you lie like a doormat
14:52:24 <ddarius> map (id &&& (3^)) [1..]
14:52:28 <ddarius> > map (id &&& (3^)) [1..]
14:52:29 <lambdabot>   [(1,3),(2,9),(3,27),(4,81),(5,243),(6,729),(7,2187),(8,6561),(9,19683),(10,...
14:52:48 <Berengal> benmachine: GHC compiles / lambdas are being lifted / the wind is dying
14:52:55 <benmachine> Berengal: :)
14:53:05 <gwern> @quote wind
14:53:05 <lambdabot> shapr says: I encourage my competitors to use Windows.
14:53:31 <gwern> Berengal: add that to the haskell haiku page
14:53:36 <nolrai_FG> What is Haiku?
14:53:46 <Berengal> @quote haiku
14:53:46 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
14:54:03 <gwern> nolrai_FG: a 5-7-5 syllabic verse form, also known for its kigo
14:54:21 <Berengal> @quote less.pain
14:54:21 <lambdabot> <basti_> says: Snow doeth lay upon the lands. Even with cunning newtype; deriving the newtype is recursive. Great leaders brings less pain.
14:54:24 <gwern> http://www.haskell.org/haskellwiki/Haiku
14:54:44 <Berengal> gwern: I don't have an account
14:54:47 * hackagebot upload: graphics-drawingcombinators 1.2.1 - A functional interface to 2D drawing in OpenGL (LukePalmer)
14:55:06 <gwern> Berengal: then I shall maked you one
14:55:48 <Berengal> gwern: Do you want an email for that?
14:55:51 <gwern> yes
14:56:39 <Berengal> Sent
14:58:30 <Berengal> Wait, are spaces allowed in names?
14:58:57 <gwern> Berengal: yes
14:59:10 <Berengal> Then I want spaces where I forgot to put them ;)
15:00:56 * gwern wonders where Berengal's email went
15:01:02 <gwern> I assumed you would just tell me here
15:01:18 <Berengal> I can do that
15:01:56 <nolrai_FG> 6 ^ 4
15:02:02 <nolrai_FG> > 6 ^ 4
15:02:03 <lambdabot>   1296
15:03:00 <nolrai_FG> \msg lambabot
15:06:39 <MissPiggy> anyway it's just an intuition I have
15:06:47 <MissPiggy> I don't have a clue how to actually take it anywhere
15:07:55 <MissPiggy> actually is there much research into writing tests that have optimal ummm they attempt to cover as much of the algorithm as possible?
15:08:06 <MissPiggy> I don't even know how to state that but I hope that what I said makes sense
15:08:34 <dolio> Coverage.
15:08:57 <MissPiggy> ?
15:09:12 <dolio> Optimal coverage.
15:09:28 <dolio> Like hpc.
15:09:45 <dolio> Haskell Program Coverage
15:10:05 <MissPiggy> who uses HPC and what do you do with it?
15:10:16 <MissPiggy> I can see what it outputs, but like, how could you interpret that?
15:10:23 <dolio> I use HPC in uvector algorithms to try and make sure that my tests cover all the branches of the algorithm.
15:10:44 <MissPiggy> that's really neat
15:11:00 <MissPiggy> is there much theory about this sort of thing?
15:11:00 <copumpkin> plain ol' uvector uses hpc fairly extensively too
15:12:09 <copumpkin> MissPiggy: I haven't seen much. I've mostly used it as a guide for unit tests. Basically, keep writing unit tests until you get to a high coverage and then you can be fairly sure your tests are decent :P
15:12:17 <copumpkin> and by unit tests I just mean quickcheck properties
15:12:41 <idnar> heh
15:13:05 <idnar> I think coverage testing should be used qualtitatively more than quantitatively
15:13:19 <MissPiggy> how do you measure the qualtity?
15:13:25 <copumpkin> qualtitty?
15:13:35 <idnar> maybe that's not the word I want
15:13:48 <idnar> what I mean is, instead of running coverage tests and going "oh, 88%, that's pretty good"
15:13:52 <MissPiggy> that is what I am wondering, covering all reacable code is a necessary but not sufficient condiiton I think
15:13:55 <SamB_XP> qualitative, I think ;-P
15:14:03 <copumpkin> MissPiggy: yeah, definitely not :)
15:14:07 <idnar> what I usually do is write some code along with some tests, and then run coverage tests, and go "oops, I forgot to test that codepath, let me do it now"
15:14:21 <copumpkin> I mean, it can't figure out what code path led to you reaching a piece of code
15:14:49 <SamB_XP> copumpkin: bah
15:14:54 <SamB_XP> puny testing!
15:15:00 <dolio> Yeah, I don't think I've been rigorous enough with my hpc stuff, but it's tedious to be so.
15:15:13 <MissPiggy> is it possible to be rigerous about it?
15:15:44 <dolio> Like, I used hpc to run all the tests, but really you probably want to check the hpc output of each individual test, to make sure each one is covering what you want it to.
15:15:56 <dolio> Instead of all the tests covering all the code.
15:16:14 <dolio> But doing that requires separate runs for each test.
15:24:08 <idnar> dolio: yeah, that's easy to do when you first write the test, but it's harder to find out later if anything changed
15:24:26 <idnar> checking the whole test suite is probably "good enough" though
15:24:32 <FliPPeh_> Mhhhh
15:24:39 <Sgeo> The link to the list of changes on http://hackage.haskell.org/trac/haskell-prime/ is broken
15:25:07 <FliPPeh_> Why is libmpd.hs broken? :(
15:25:18 <FliPPeh_> I wanted to write an MPD client in my old new favourite language
15:26:48 <Cale> http://www.escapistmagazine.com/videos/view/loadingreadyrun/1430-iPotato :)
15:29:03 <dibblego> @hoogle fromHexString
15:29:03 <lambdabot> No results found
15:29:09 <dibblego> @hoogle hex
15:29:10 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
15:29:10 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
15:29:10 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
15:31:47 <Sgeo> Why aren't Float and Double instances of Bounded?
15:32:05 <dibblego> what would the bounded values be?
15:32:44 <Sgeo> The maximum and minimum value of floats and doubles?
15:32:51 <dolio> Infinity and -Infinity?
15:32:56 <Sgeo> ..Oh, right
15:33:09 <olsner> @type Infinity
15:33:10 <lambdabot> Not in scope: data constructor `Infinity'
15:33:15 <copumpkin> @type (1/0)
15:33:16 <lambdabot> forall t. (Fractional t) => t
15:33:29 <Cale> Well, that would make sense.
15:33:36 <olsner> right. the official way to write infinity is to divide by zero?
15:33:46 <Cale> olsner: Yeah.
15:33:46 <copumpkin> @let infinity = 1/0
15:33:47 <lambdabot>  Defined.
15:33:54 <benmachine> > infinity :: Rational
15:33:55 <lambdabot>   * Exception: Ratio.%: zero denominator
15:34:02 <benmachine> careful of type defaulting
15:34:30 <copumpkin> > infinity > 5
15:34:32 <lambdabot>   True
15:34:40 <copumpkin> > infinity * 0
15:34:41 <lambdabot>   NaN
15:34:51 <Cale> > -infinity
15:34:53 <lambdabot>   -Infinity
15:34:59 <idnar> @type infinity
15:35:00 <lambdabot>     Ambiguous occurrence `infinity'
15:35:00 <lambdabot>     It could refer to either `L.infinity', defined at <local>:7:0
15:35:00 <lambdabot>                           or `Data.Number.Natural.infinity', imported from Data.Number.Natural
15:35:04 <Cale> > -1/infinity
15:35:05 <lambdabot>   -0.0
15:35:17 <copumpkin> I love that floats have a negative 0
15:35:18 <Cale> heh, oops
15:35:35 <dolio> > 1/infinity == (-1 / infinity)
15:35:35 <benmachine> copumpkin: it's so useful and intuitive
15:35:38 <lambdabot>   True
15:35:51 <Cale> The @type plugin's list of modules seems not to stay in sync with the imports in L.hs
15:35:52 <Sgeo> > 0 / infinity
15:35:53 <lambdabot>   0.0
15:36:12 <dolio> > - 0.0
15:36:13 <lambdabot>   -0.0
15:36:26 <Sgeo> > -0.0 - -0.0
15:36:27 <lambdabot>   Precedence parsing error
15:36:27 <lambdabot>      cannot mix `GHC.Num.-' [infixl 6] and prefix ...
15:36:33 <Sgeo> > -0.0 - (-0.0)
15:36:34 <lambdabot>   0.0
15:36:37 <Sgeo> > -0.0 + (-0.0)
15:36:38 <lambdabot>   -0.0
15:36:39 <Cale> It does make sense in that it gives you some more information about the direction of divergence when things blow up.
15:37:32 <duairc> Is there a function in the standard library to convert Integers to strings for arbitrary bases?
15:37:46 <Cale> :t showIntAtBase
15:37:47 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
15:37:57 <duairc> Cale: Thanks :)
15:38:13 <Cale> It makes a ShowS-style function
15:38:14 <idnar> that signature is a bit bizarre
15:38:36 <benmachine> > showIntAtBase 0 chr 0 ""
15:38:37 <lambdabot>   "* Exception: Numeric.showIntAtBase: applied to unsupported base 0
15:38:38 <Cale> So that you can concatenate the result with other things in constant time, using composition.
15:38:46 <benmachine> > showIntAtBase 2 chr 0 ""
15:38:47 <lambdabot>   "\NUL"
15:38:51 <benmachine> heh
15:38:53 <benmachine> interesting.
15:38:54 <Sgeo> \:t chr
15:38:58 <Sgeo> :t chr
15:38:59 <lambdabot> Int -> Char
15:39:04 <Sgeo> That was obvious
15:39:08 <benmachine> :P
15:39:30 <Sgeo> > chr 154
15:39:31 <lambdabot>   '\154'
15:39:33 <idnar> @src showHex
15:39:33 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:39:34 <Sgeo> Ah
15:39:35 <Cale> > showIntAtBase 16 intToDigit 784921 ""
15:39:36 <lambdabot>   "bfa19"
15:39:45 <Cale> > showIntAtBase 16 intToDigit 784921 "h"
15:39:46 <lambdabot>   "bfa19h"
15:39:53 <idnar> ah, intToDigit
15:40:13 <idnar> can't we replace ShowS with something less clunky to use?
15:40:16 <Cale> intToDigit unfortunately only works in the range [0..15]
15:40:21 <Cale> ShowS is cool.
15:40:32 <Cale> and not really all that clunky
15:40:47 <Cale> Though it doesn't really work for more complicated prettyprinting.
15:42:02 <idnar> I guess it's not that clunky, but it could use some more utility functions
15:42:20 <Cale> Well, you have (.) for composition :)
15:43:41 <Cale> Heh, just noticed that makes things look a bit like perl :)
15:43:46 <idnar> > showIntAtBase 16 intToDigit 42 . (++ " :: ") . shows 42 $ ""
15:43:47 <lambdabot>   "2a42 :: "
15:43:53 <idnar> ^^ that's a pain
15:43:59 <idnar> oh, that didn't even work
15:44:08 <Cale> > showIntAtBase 16 intToDigit 42 . (" :: " ++) . shows 42 $ ""
15:44:09 <lambdabot>   "2a :: 42"
15:44:31 <idnar> kinda illustrates my point :P
15:44:50 <Cale> > showIntAtBase 16 intToDigit 42 . (showString " :: ") . shows 42 $ ""
15:44:52 <lambdabot>   "2a :: 42"
15:44:54 <idnar> I'm guessing that ++ section isn't a great idea anyhow
15:44:58 <Cale> > showIntAtBase 16 intToDigit 42 . showString " :: " . shows 42 $ ""
15:44:59 <lambdabot>   "2a :: 42"
15:45:11 <idnar> ah, showString
15:45:29 <Cale> The (++) section isn't bad, you just have to remember which way around things go.
15:45:49 <Cale> You're representing strings using functions that add bits to the beginning of another string.
15:46:03 <idnar> by "bad" I mean "inefficient"
15:46:24 <idnar> although I guess it's just a constant factor
15:46:34 <Cale> Well, xs ++ ys is O(length xs), so yeah.
15:46:56 <Cale> Hmm, do I still have my tree type?
15:46:59 <Cale> :t Branch
15:47:00 <lambdabot> Not in scope: data constructor `Branch'
15:47:11 <idnar> all the showThis and showThat is also kinda awkward if you're not actually doing anything with Show
15:47:36 <copumpkin> O $ length xs? :P
15:47:46 <idnar> haha
15:47:59 <Cale> @undefine
15:48:05 <Cale> :t Branch
15:48:06 <lambdabot> forall a. a -> Bin a -> Bin a -> Bin a
15:48:08 <Cale> :)
15:48:21 <copumpkin> is that the internals of Data.Map?
15:48:25 <Cale> no
15:48:36 <copumpkin> what's it from?
15:48:40 <Cale> Just a binary tree datatype that I stuck into Pristine.hs
15:48:41 <benmachine> :t Bin
15:48:42 <lambdabot> Not in scope: data constructor `Bin'
15:48:43 <Cale> (just now)
15:48:44 <copumpkin> ah
15:48:45 <Cale> :t Tip
15:48:46 <lambdabot> forall a. Bin a
15:48:47 <benmachine> er
15:48:51 <jmcarthur> how bad is TypeFamilies in ghc 6.8?
15:48:52 <benmachine> yes silly me
15:48:58 <jmcarthur> worth bothering at all?
15:49:09 <ddarius> Not something to rely upon.
15:49:10 <Cale> @let foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
15:49:11 <lambdabot>  Defined.
15:49:30 <jmcarthur> dang
15:49:48 <benmachine> > Branch 'a' Tip Tip
15:49:49 <lambdabot>   No instance for (GHC.Show.Show (L.Bin GHC.Types.Char))
15:49:49 <Cale> @let inorder t = foldTree id (\x l r -> l . (x:) . r) t []
15:49:49 <lambdabot>    arising from a us...
15:49:50 <lambdabot>  Defined.
15:49:54 <jmcarthur> ddarius: usable enough to expend effort to utilize them in an ai contest entry?
15:50:02 <Cale> oh, oops
15:50:11 <jmcarthur> or do you think i would just be wasting my time?
15:50:22 <Cale> needs moar instances :)
15:50:25 <Cale> @undefine
15:50:36 <benmachine> aren't they basically the same as functional dependencies anyway?
15:50:38 <Cale> > Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
15:50:39 <lambdabot>   Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
15:50:45 <ddarius> jmcarthur: I believe basic usage worked okay, but there were a lot of bugs for more complex usages.
15:50:51 <Cale> @let foldBin t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
15:50:52 <lambdabot>  Defined.
15:50:59 <Cale> @let inorder t = foldBin id (\x l r -> l . (x:) . r) t []
15:51:00 <lambdabot>  Defined.
15:51:04 <jmcarthur> benmachine: in some ways. either way, my need is to use a library that uses them
15:51:06 <ddarius> As benmachine suggests, you can use multiparameter type classes and functional dependencies instead.
15:51:06 <Cale> > inorder (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
15:51:07 <lambdabot>   [2,1,3]
15:51:17 <jmcarthur> no i can't because i want to use a library that uses them
15:51:43 * jmcarthur hopes his usage is not a "complex" usage
15:52:08 <ddarius> jmcarthur: If the library is written for 6.8 then presumably it works, if it isn't then it's not something you should rely upon anyway.
15:52:29 <jmcarthur> ddarius: i don't know what it's written for :\
15:52:42 <benmachine> rely on it at your peril, then?
15:53:08 <jmcarthur> i think i'll just do that
15:53:16 <jmcarthur> hopefully not at my peril
15:53:47 <Berengal> Can someone say inversion of control? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17280#a17280 http://85.200.142.237:5000/
15:54:31 <benmachine> That's just right! You got it in 1 attempts!
15:54:33 * benmachine cool
15:54:50 <Cale> jmcarthur: I don't think TypeFamilies were actually usable yet in 6.8. You'd be better off just using MPTCs.
15:54:56 * ezyang is reminded of Navi 
15:55:07 <benmachine> ezyang: heh, I thought that
15:55:20 * Berengal has not only been playing with continuations, but playing Zelda lately too
15:55:38 <benmachine> heh
15:55:48 <benmachine> p.s. it seems to undercount number of attempts?
15:55:57 <jmcarthur> *sigh*
15:56:00 <jmcarthur> Cale: okay, thanks
15:56:19 <Berengal> benmachine: It does?
15:56:37 <Berengal> It does
15:56:40 <benmachine> if you got it immediately it would say 0 attempts
15:56:59 <Berengal> I'll just define it as a feature
15:57:12 <benmachine> heh
15:57:29 <Berengal> And redefine "attempt" while I'm at it
15:57:51 <Berengal> The neat thing is that this is the _exact_ same code used to do the same as a console app
15:57:53 <MissPiggy> Hey, listen!
15:57:54 <MissPiggy> That's just right! You got it in 1 attempts!
15:57:57 <Berengal> (say and prompt redefined, of course)
15:58:03 <MissPiggy> \o/
15:59:18 <Cale> jmcarthur: Like, I seem to recall that there was essentially no type-level reduction for type families, so that it would fail to see that a type involving some TF was equivalent to what should be its result, which basically defeats the purpose altogether.
16:00:00 <jmcarthur> Cale: i only need it for data families. did that work in 6.8?
16:00:10 <jmcarthur> actually, associated data types
16:01:46 <copumpkin> jmcarthur's AI sounds like it'll be epic
16:02:00 <copumpkin> jmcarthur: can't you ask them to just upgrade their GHC version?
16:02:01 <Berengal> epicmorphism
16:02:12 <jmcarthur> copumpkin: i already asked. they refuse
16:02:16 <copumpkin> jmcarthur: o.O
16:02:16 <copumpkin> lame
16:02:22 <jmcarthur> yeah
16:02:25 <copumpkin> what's their rationale?
16:02:51 <Cale> jmcarthur: You could try it, but expect problems.
16:03:10 <Berengal> Can't you just upload to see if it compiles or not?
16:03:23 <Cale> It's been a while since I last used 6.8.x, so I don't remember precisely which problems.
16:03:50 <copumpkin> Berengal: your web stuff is looking more and more exciting
16:04:13 <copumpkin> Berengal: how does it do performance-wise?
16:04:14 <jmcarthur> Berengal: well, i could, but there's still some effort in actually writing the code that's intended to use it
16:04:23 <Berengal> copumpkin: I know, right? I feel like a kid who just learned multiplication; addition is so much easier now
16:04:30 <jmcarthur> Cale: i'm just gonna try it and see what happens
16:04:43 <MissPiggy> yeah Berengal that's really cool
16:04:56 <MissPiggy> als I beat it in one move
16:05:04 <copumpkin> wow, PsychicMissPiggy
16:05:26 <duairc> There isn't a readIntAtBase, but is there something like it?
16:05:30 <Berengal> copumpkin: Space-wise it seems to be doing good. I don't GC sessions yet, but even so, after I had hammered it with a new GET every second for some hours (I forgot about it) it was only using 10Mb
16:05:45 <copumpkin> Berengal: how about concurrent requests?
16:06:33 <Berengal> copumpkin: Haven't tested that yet. It uses happstack, so I'd expect happstack-like results. The actual program itself is pretty basic now
16:07:12 <copumpkin> ah ok
16:07:47 <MissPiggy> There is a small and growing body of work on program testing in the literature. But it is quite fragmentary and lacks coherence. We argue that by taking on testing as a "grand challenge" we could: help synthesise the approaches of diverse areas of work, raise intellectually challenging questions, and perhaps make a significant contribution to the solution of a practical problem.
16:07:52 <Berengal> It'll be more interesting once I get some composition going
16:08:04 <Berengal> But I'm going to need a naming scheme for that...
16:08:17 <MissPiggy> what composition?
16:08:31 <copumpkin> Berengal: seems like you could do that in a foldM
16:08:34 <Berengal> MissPiggy: Putting continuations inside continuations so I can AJAX while I AJAX
16:08:38 <copumpkin> Berengal: the game, that is
16:08:39 <ezyang> Whoooo
16:08:43 <MissPiggy> "Except for trivial programs, testing can never prove that a program is correct" this is some kind of mantra I keep reading but is it actually true?
16:09:02 <copumpkin> it's true unless you can prove that testing will prove it's correct :P
16:09:11 <Berengal> copumpkin: Yes, well, but that doesn't express the sequentiality I was going for :P
16:09:15 <ezyang> You can prove a program is correct via testing if it has a finite input domain
16:09:18 <copumpkin> as is the case with those polynomials etc.
16:09:30 <Berengal> MissPiggy: Not true, but you might have to expend more resources than the universe has to do it
16:09:31 <MissPiggy> copumpkin: classes of programs P * and associated classes of test sets T * are defined which have the property that if two programs P  and Q in P * agree on a set of tests from T *, then P and Q are computationally equivalent. The properties of a class P * and the associated class T * can be thought of as defining a set of assumptions about a hypothetical correct version Q of a program P in P *.
16:09:52 <arw> MissPiggy: yes. you can only prove a program correct by testing if you are able to test all possible inputs and check the correctness of all resulting outputs.
16:10:18 <MissPiggy> arw, I don't believe that
16:11:00 <copumpkin> for anything less, you need to prove that it's sufficient
16:11:12 <Berengal> MissPiggy: All programs can be seen as functions of type input -> output on some level
16:11:14 <benmachine> finding out what to test is the difficult bit
16:11:46 <benmachine> and then presumably you have to prove the correctness of your tests :P
16:12:11 <arw> MissPiggy: a prove (in the mathematical sense) needs to be correct in all possible situations. if you leave something out, its no prove.
16:12:32 <copumpkin> arw: it doesn't necessarily need to be an exhaustive search though
16:13:03 <arw> copumpkin: no, if you can prove, that the areas you left out behave like something else you already have proven to be correct.
16:13:17 <copumpkin> arw: yeah
16:13:20 <arw> copumpkin: but then its no longer just a test, its a test and a prove.
16:13:38 <theorbtwo> That said, some tests not being able to *prove* your program is correct does *not* imply that tests aren't useful.
16:13:47 <ezyang> ==theorbtwo
16:13:50 <benmachine> I think what MissPiggy wants is some generalisable or reusable proofs of that kind
16:13:58 <theorbtwo> BTW, prove is a verb, proof is a noun.
16:14:05 <copumpkin> @check ezyang == theorbtwo
16:14:06 <lambdabot>   Not in scope: `ezyang'Not in scope: `theorbtwo'
16:14:26 * benmachine puts ezyang in scope
16:14:39 <ezyang> "not the mouthwash! Anything but the mouthwash"
16:14:45 <arw> theorbtwo: thanks for the correction. sometimes english is not as easy as it seems :)
16:15:07 <benmachine> sometimes english is subtly difficult
16:15:12 <benmachine> the rest of the time, it is obviously difficult
16:15:20 <theorbtwo> benmachine++
16:15:52 <ezyang> Given a -> b -> c, is there a reasonable functor instance that is /not/ (->) a ?
16:15:53 <MissPiggy> Is there any theoretical basis for programmersâ€™ confidence that testing will reveal signifi-
16:15:57 <MissPiggy> cant bugs (errors) in a program?
16:16:03 <ddarius> arw: "prove" is the verb, "proof" is the noun
16:16:11 <ddarius> Er sorry.
16:16:13 <copumpkin> ezyang: you mean the built-in functor instance? no
16:16:24 <ezyang> ok, just checking
16:16:29 <ezyang> :t fmap fmap fmap
16:16:29 <benmachine> a -> b -> c = (->) (a -> b) c
16:16:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:16:38 <ezyang> Oh, wow, lambdabot does the right thing
16:16:40 <benmachine> err no
16:16:42 <copumpkin> benmachine: nope
16:16:44 <ezyang> benmachine: that's wrong
16:16:51 <benmachine> a -> b -> c = (->) a (b -> c)
16:16:54 <benmachine> silly me
16:16:58 <copumpkin> :)
16:17:13 <benmachine> anyway, you want to make that a Functor you want a single-parameter type-constructor
16:17:15 <ezyang> When I do :t fmap fmap fmap on 6.10.4 I get  Functor ((->) (a -> b)) => constraint
16:17:20 <benmachine> but there's only really one way to un-apply it
16:17:26 <ezyang> which sort of confused me
16:17:29 <Berengal> copumpkin: 10000 requests @ 10 threads; 2778rq/sec, 20000 requests @ 10 threads; 2970rq/sec, ~30k session ~27.1 resident memory
16:17:35 * ezyang wrote a blog post about this. It'll be published next monday 
16:17:42 <copumpkin> Berengal: not bad :)
16:17:49 <Berengal> Indeed not
16:17:50 <copumpkin> ezyang: as in, not tomorrow?
16:17:55 <ezyang> not tomorrow.
16:17:58 <benmachine> ezyang: the Functor (->) a is not in the Prelude
16:18:06 <Berengal> But my program's too simple to really get any decent numbers out of it
16:18:15 <ezyang> Oh, right.
16:18:22 <ezyang> Fantastic :-)
16:18:26 <benmachine> so you need to import something inane to get at it
16:18:51 <arw> MissPiggy: yes and no. you can, using some statistics, calculate the overlap between the inputs affected by an error and the inputs a test covers.
16:19:03 <AlanF> anyone got a good online feed of the superbowl? I don't get CBS here and I tried googling but keep landing in spam holes. Thanks for any links
16:19:04 <ezyang> copumpkin: Tomorrow I have a post about solving Mystery Hunt puzzles with Haskell :-)
16:19:09 <benmachine> okay, even Data.Functor doesn't have it
16:19:10 <benmachine> seriously what
16:19:28 <arw> MissPiggy: by that, you get some probability telling you how likely a bug of size $something is.
16:19:30 <benmachine> (p.s. for how long has there been a Data.Functor?)
16:19:46 <ezyang> Control.Applicative gets it for me
16:19:47 <ddarius> I've never heard of a "Data.Functor" module.
16:20:01 <ezyang> aha Control.Monad.Instances
16:20:07 <copumpkin> Control.Functor
16:20:14 <copumpkin> in category-extras :)
16:20:18 <arw> MissPiggy: and of course you can try to improve that probability by improving your test for higher branch/path/whatever coverage.
16:20:20 <benmachine> ddarius: I think it's new in 6.12
16:20:24 <ezyang> yarp
16:20:32 <copumpkin> wait, we really have a Data.Functor??
16:20:33 <MissPiggy> ' In the ideal world, all possible paths through a programs should be tested"
16:20:37 <benmachine> copumpkin: seems so
16:20:51 * copumpkin doesn't believe it 
16:20:56 <copumpkin> oh crap
16:21:05 <copumpkin> it is there
16:21:14 <copumpkin> why Data. and not Control.? :o
16:21:18 <benmachine> pass
16:21:58 <benmachine> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Data-Functor.html
16:22:02 <benmachine> hmm it exports <$>
16:22:06 <copumpkin> yeah, that's what I was looking at :)
16:22:18 <benmachine> now I don't need silly imports of Control.Applicative for my tiny applications
16:23:11 <benmachine> still bothers me that the (->) instance is missing
16:24:28 <theorbtwo> MissPiggy: Theory isn't my strong suit, but no, I know of no *theoretical* reason, but test coverage is something that you should look seriously at -- not only writing tests, but writing tests that exercise as many of the distinct paths of program flow as possible.
16:25:05 <theorbtwo> Also, a decent programmer will have at least some feeling as to where the hard parts lay, and will write tests that target them.
16:25:40 <benmachine> the primary problem is though that if you've thought enough about a bit of code to test it, it's quite frequently because you've thought enough about it to get it right
16:25:48 <benmachine> or at least I always had that problem
16:25:53 <benmachine> you tend to write tests that will pass
16:26:06 <benmachine> (not always, though)
16:26:12 <theorbtwo> benmachine: Yes, there is that issue, which is one of the reason to write the test *before* the code, and to strive for test coverage.
16:26:13 <Cale> MissPiggy: Heh, depends on what counts as a path. Most programs have combinatorially large numbers of paths.
16:26:14 <ezyang> regression testing is amazing
16:26:16 <Berengal> benmachine: The thing about tests is that they're still there when some other schmuck comes to "fix" your code later
16:26:27 <Cale> (Or infinitely many)
16:26:38 <MissPiggy> you could perhaps evaluate all paths simultaneously
16:26:56 <arw> yes, but writing tests that pass is also a good thing. somebody will eventually fiddle with your code and break something. and then that person will find those tests useful.
16:26:59 <benmachine> Berengal: :P
16:27:22 <Berengal> Future-me counts as a schmuck, by the way.... Never liked that guy
16:27:27 <Cale> MissPiggy: Well, the extent to which you can do that is basically what a type system does.
16:27:28 <theorbtwo> ...and, of course, sometimes that schmuck is ... exactly.
16:27:47 <MissPiggy> what about model checkeing
16:27:49 <theorbtwo> Cale: Or, at least, Haskell's type system.
16:27:50 <temoto> How to split list in two lists, decided by a predicate (a -> left/right)?
16:28:06 <Berengal> @type partition
16:28:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:28:12 <temoto> Thanks.
16:28:15 <ddarius> Berengal: Don't worry he didn't like the past you.
16:28:47 <theorbtwo> BTW, I have actually written tests that demonstrated that the code I just wrote was wrong.
16:28:51 <Berengal> ddarius: Past me is even worse. The gall of that man. So ignorant, yet so arrogant
16:28:54 <theorbtwo> It's not *all* that uncommon.
16:29:19 <Berengal> theorbtwo: Me too, but not in Haskell.
16:29:27 <theorbtwo> Berengal: Fair enough.
16:29:32 <Berengal> In Haskell I tend to write types that prove what I'm thinking doesn't typecheck
16:29:49 <theorbtwo> The thing is that type checking won't help with certian classes of error.
16:30:00 <theorbtwo> For example, the classic off-by-one.
16:30:11 <Cale> Yeah, you can't hope to test more than a tiny fraction of the possible input space of your program, but quite often when things are wrong, they go wrong either in boundary cases, or in large regions of the input space which can be found by random testing.
16:30:19 <kmc> dependent typing helps with those ;)
16:30:40 <Berengal> theorbtwo: They can, with enough dependent types... but that can become a pain to program in, despite the fun
16:31:25 <Cale> But typechecking is still more awesome than testing, because you don't have to write all the tests, and get assurance that your program absolutely can't go wrong in a large variety of ways.
16:31:28 * Berengal made two off-by-one errors today
16:31:42 <copumpkin> moo
16:31:59 <Berengal> Cale: Also, if you write your types up front you don't even have to implement the code to see that it'll never work
16:32:55 <Berengal> It's my prefer way of developing at least.
16:32:59 <benmachine> > compare EQ GT
16:33:00 <lambdabot>   LT
16:33:16 <Berengal> prefered*
16:33:24 <copumpkin> > fix (compare LT)
16:33:27 <ezyang> I got into an argument about Sussman about whether or not static type checking should be mandatory or not.
16:33:28 <lambdabot>   mueval-core: Time limit exceeded
16:33:33 <ezyang> *with
16:33:42 <benmachine> > compare LT undefined
16:33:43 <lambdabot>   * Exception: Prelude.undefined
16:33:45 <benmachine> huh
16:33:51 <Berengal> ezyang: What was the conclusion?
16:33:53 <copumpkin> it could be EQ or GT
16:33:57 <theorbtwo> Wait a minute.  EQ is less then GT?  That just makes my head hurt.
16:34:04 <ezyang> Sussman wants his eval. He wants programs that are able to create programs.
16:34:18 <Berengal> Aren't macros enough for the man?
16:34:27 <benmachine> copumpkin: oh, right yes
16:34:36 <ezyang> Berengal: Apparently not :-)
16:34:37 <benmachine> > fix (LT <=)
16:34:38 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
16:34:38 <lambdabot>         against inferr...
16:34:46 <Berengal> And we have TH in haskell too... and hint
16:34:47 <erikc> sussman is right
16:34:49 <benmachine> oh, also right yes
16:35:10 <ezyang> So, in Sussman's mind, it's cool if you want your static type checking, just don't force it on everyone.
16:35:19 <copumpkin> sussman is left
16:35:30 <kmc> you can write Haskell code where the static types are trivially satisfied
16:35:32 <theorbtwo> Berengal: But template haskell isn't really *in* haskell, is it?  It's really another language, that is very very haskel-like.
16:35:35 <ezyang> I think SPJ is similarly minded (at least, what I could tell from his Coders at Work interview)
16:35:38 <kmc> with e.g. Data.Dynamic
16:35:47 <ezyang> It's true.
16:35:47 <Cale> theorbtwo: Well, it's a Haskell extension.
16:35:48 <benmachine> > fix (True ==)
16:35:51 <lambdabot>   mueval-core: Time limit exceeded
16:35:53 <Berengal> ezyang: I'd still say that you can have both static typechecking and eval
16:35:58 <Cale> theorbtwo: Depends on what you consider Haskell to be.
16:35:59 <kmc> and you can do "static" checking of staged metaprogramming
16:36:05 <kmc> at every stage where you're about to execute some code, you check it first
16:36:16 <Cale> TH isn't part of H98.
16:36:20 <kmc> you can do something very much like TH without any language extension
16:36:30 <Berengal> Did liskell have macros?
16:36:39 <kmc> the point of the extension is to make quoting and splicing that's not insanely cumbersome
16:37:02 <theorbtwo> kmc: That makes a lot of sense.
16:37:07 <kmc> without it, you'd simply build Haskell source ASTs (a perfectly ordinary algebraic type) in Haskell, and then pass them to a compiler (a perfectly ordinary Haskell library)
16:37:27 <kmc> even with the fancy syntax, TH is still a pain
16:37:36 <kmc> it's a good thing we have other forms of abstraction
16:37:49 <Berengal> You need lisp-like ASTs to get good macros
16:38:03 <ezyang> Code is data! Something I've always appreciated about Lisp.
16:38:15 <kmc> i think the syntaxlessness of LISP is overrated
16:38:25 <kmc> you can write every Haskell algebraic type using S-expressions as well
16:38:51 <Berengal> Yes, but you don't, and that's what makes TH painful
16:39:32 <kmc> what should count as syntax in LISP is not the lexical / concrete structure, but the interpretation of every S-exp (usually determined by the symbol in its car)
16:39:44 <kmc> which is not especially simpler than other languages
16:40:08 <Berengal> That's not the level you're manipulating it on though
16:40:23 <kmc> if you don't count that as syntax, LISP is just a language for writing list literals
16:40:26 <Berengal> Macros manipulate them as the concrete structure
16:40:44 <kmc> it's the level on which you have to think though
16:40:49 <Berengal> That is a pretty good definition of lisp actually
16:41:10 <Berengal> Only when writing code. When writing splices you're back to writing lists
16:41:18 <Berengal> Of course, the two are intermingled quite a bit
16:44:16 * hackagebot upload: hs-gchart 0.2 - Haskell wrapper for the Google Chart API (DeepakJois)
16:44:47 <Sgeo> What's the difference between IORefs and STRefs?
16:45:19 <ezyang> ST monad is weaker than the IO monad
16:45:23 <Heffalump> sgeo: nothing at the implementation level; at the type level, the monad they operate in.
16:45:34 <Berengal> type IORef a = STRef RealWorld a
16:45:52 <Heffalump> so the real question is what's the difference between IO and ST.
16:46:40 <Heffalump> and the answer is that ST supports many fewer operations, but ST computations can safely be made into pure computations
16:46:50 <MissPiggy> newtype ST a = ST (IO a)
16:46:55 <MissPiggy> newtype IO a = IO (ST a)
16:46:59 <MissPiggy> pick one :P
16:47:09 <Sgeo> I'm still somewaht unfamiliar with newtype and type
16:47:23 <Heffalump> I don't think MissPiggy's statement is particularly helpful
16:47:26 <Berengal> I've always viewed ST as a sort of IO that didn't neccessarily run in the real world. It could be doing its computations in a parallel fantasy universe, or in one where the earth was flat
16:47:40 <Cale> Er, trying to understand ST and IO in terms of their implementations in GHC is misleading anyhow.
16:47:42 <Berengal> That it actually happens to run in the real world on your computer is just a happy coincidence
16:47:53 <ezyang> Sgeo: It's a way of declaring a type that hides the underlying implementatoin
16:47:56 <ezyang> *implementation
16:47:58 <MissPiggy> Heffalump: you can coerce ST to IO and IO to ST
16:48:06 <Cale> MissPiggy: Not really, no.
16:48:34 <MissPiggy> unsafeIOToST  :: IO  a -> ST  s a
16:48:34 <MissPiggy> unsafeSTToIO :: ST s a -> IO a
16:48:34 <Berengal> You can convert ST RealWorld to IO
16:48:37 <MissPiggy> look
16:48:38 <Cale> You can turn an ST action into an IO action, though only because it's pure. You can't turn an IO action into an ST action without cheating.
16:48:45 <copumpkin> MissPiggy: not quite
16:48:47 <MissPiggy> the reason you can do this is because what I said earlier
16:48:49 <Cale> MissPiggy: Those functions are prefixed with unsafe for a reason.
16:48:52 <MissPiggy> http://cvs.haskell.org/Hugs/pages/libraries/base/Control-Monad-ST.html
16:48:53 <Heffalump> I didn't say it didn't have meaning, I said it wasn't helpful for explaining it to a newbie.
16:49:00 <MissPiggy> what newbie
16:49:07 <Cale> MissPiggy: Sgeo
16:49:12 <Heffalump> the one asking about the difference between IORef and STRef
16:49:19 <MissPiggy> well I was not here
16:49:34 <Cale> MissPiggy: Don't confuse the concepts with the unsafe additions to them which GHC has.
16:49:50 <Heffalump> MissPiggy: the question was only asked 5 minutes ago
16:49:59 <MissPiggy> I was just addressing "the real question is what's the difference between IO and ST"
16:50:12 <Cale> Using unsafeIOToST, you can break the type system and write unsafeCoerce.
16:50:14 <MissPiggy> as other people did,  also
16:50:16 <Berengal> MissPiggy: "unsafe" is really shorthand for "I hereby declare that the compiler can do whatever it wishes with my code, including by not limited to turning it into code that formats my harddrive or empties my bank accounts."
16:50:22 <MissPiggy> but I gave a particularly gnarly answer or something
16:50:59 <copumpkin> runST (unsafeIOToST newIORef)
16:51:09 <Heffalump> yes, and I said that (IMO) your explanation wasn't helpful, particularly in light of the fact that Sgeo isn't familiar with newtype/type.
16:51:09 <copumpkin> runST (unsafeIOToST $ newIORef undefined)
16:51:14 <Heffalump> anyway.
16:51:24 <copumpkin> yay, free IORef
16:51:56 <MissPiggy> perhaps IORef and STRef are the same
16:52:01 <Heffalump> Berengal: that's not true. It just means that you have to understand the proof obligations associated with what you're doing.
16:52:02 <MissPiggy> just as IO and ST are the same
16:52:15 <MissPiggy> infact I think this is how GHC implements it
16:52:22 <Berengal> Heffalump: Well, if you pretend it means what I said it means you'll be much safer :P
16:52:26 <Cale> MissPiggy: They're really not.
16:52:37 <Berengal> copumpkin: global IORefs without relying on {-# NOINLINE #-}?
16:52:38 <Heffalump> Berengal: there is that :-)
16:52:55 <Heffalump> Berengal: you'd still need {-# NOINLINE #-} to get that to work properly
16:53:06 <Berengal> Well, true...
16:53:07 <Cale> ST only supports memory operations on a heap which is separate for each call to runST.
16:53:23 <Berengal> Oh well, global references are bad anyway
16:53:45 <Cale> To say that ST is the same thing as IO is just confusing and mostly wrong.
16:54:07 <Cale> Even if GHC uses very similar mechanisms to implement them. GHC is mostly cheating about the implementation of IO in the first place.
16:54:19 <Berengal> Cale: But at the same time, in the dirty innards of GHC, IORef is a newtype over STRef RealWorld (which is again a newtype over #MutVar or something)
16:54:28 <Cale> (which is okay, but not something that you want to bring up when trying to explain what IO is about)
16:54:45 <Cale> Berengal: Sure, but the implementation details just confuse things.
16:54:58 * Heffalump wonders if we've scared Sgeo off by arguing about how to explain things
16:55:01 <Sgeo> Would it be possible to reimplement ST in pure Haskell?
16:55:01 <Berengal> I actually think that explaining IO as ST RealWorld makes a bit of sense
16:55:08 <Cale> If you're going to talk about an implementation, at least use a nice mock implementation. :)
16:55:13 <Heffalump> Sgeo: yes, if you didn't mind a log n performance hit
16:55:15 <Berengal> Sgeo: Yes, with a State monad carrying a map
16:55:35 <Cale> Er, no, not quite.
16:55:50 <Cale> You can't quite implement ST in Haskell-without-ST.
16:55:55 <Cale> But you can get close.
16:55:58 <Heffalump> oh, and some unsafeCoerces that would actually be safe
16:56:05 <copumpkin> or just Dynamic
16:56:09 <Sgeo> Now that I think I understand ST (is there more to it than STRefs?) what's State about?
16:56:14 <Heffalump> which are unsafeCoerces that are actually safe :-)
16:56:19 <copumpkin> yep :)
16:56:56 <Berengal> Cale: You could implement some Storeable class with toMemory :: a -> Memory and fromMemory :: Memory -> a, I guess
16:56:59 <Cale> Sgeo: State s t is the type of computations which manipulate a state value of type s before producing a value of type t.
16:57:21 <Berengal> GHC does this already internally, so the extra constraint is already gone in the top-level context
16:57:29 <Sgeo> floatToInt = unsafeCoerce :: Float -> Int
16:57:50 <Cale> Sgeo: You *can* implement State s in pure Haskell. It's basically a bunch of sugar wrapped around a common functional programming idiom of using functions which take extra parameters and produce tuples as results to keep track of state.
16:58:08 <Berengal> Heffalump: to Any and back is safe
16:58:28 <Sgeo> Glad that I found Haskell's equivalent to reinterpret_cast. Whenever I ask about it, someone always tells me that it's the wrong thing to do
16:58:31 <copumpkin> which is what Dynamic does :P so all is well and we're all happy
16:58:31 <MissPiggy> newtype IORef a = IORef (STRef RealWorld a)
16:58:48 <Berengal> Sgeo: It's still the wrong thing to do
16:58:48 <MissPiggy> from IORef.hs
16:58:49 <Cale> Berengal: You could also implement ST as a term algebra with an interpreter that produces an IO action, and then use unsafePerformIO to write runST.
16:58:50 <MissPiggy> readIORef  (IORef var) = stToIO (readSTRef var)
16:59:02 <theorbtwo> Sgeo: This conversation seems to have brought up a large number of things that are possible, but probably the wrong thing to do.
16:59:03 <Cale> I've even done it that way before, it's quite easy.
16:59:03 <Sgeo> Berengal, I don't want to turn 2.0 into 2
16:59:25 <FliPPeh> > id 4
16:59:26 <lambdabot>   4
16:59:28 <FliPPeh> > id id
16:59:29 <lambdabot>   {()->()}
16:59:32 <Sgeo> I want to turn 2.0 into something that lets me explore the bit representation of 2.0
16:59:38 <FliPPeh> > id id id
16:59:39 <lambdabot>   {()->()}
16:59:40 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17281#a17281
16:59:43 <FliPPeh> :o
16:59:44 <Cale> ^^ fake ST.
17:00:00 <Berengal> Sgeo: You'd be better of using the Foreign.C.Types module for that
17:00:04 <Cale> (modulo the ST array operations)
17:00:22 <Berengal> Sgeo: Basically, unsafeCoerce is undefined behaviour except for a very few corner cases
17:00:26 <Sgeo> Cale, that uses unsafePerformIO. What does it need to do IO stuff for?
17:00:45 <theorbtwo> Sgeo: The point of a high-level programming language is that you shouldn't have to care about what bit-pattern your computer happens to be using to store 2.0.  Foreign.C.Types sounds like the thing.
17:01:21 <Cale> Sgeo: It only needs unsafePerformIO to actually get an 'a' result, which is actually safe because the only effects which could have occurred are memory effects on memory cells that were created by the same computation
17:01:40 <Cale> Sgeo: It uses IO for IORefs.
17:01:55 <Cale> (to allocate memory cells of arbitrary types and mutate them)
17:01:58 <Sgeo> Is it doable without IO?
17:02:02 <Cale> No.
17:02:15 <MissPiggy> There's two reasons why you can't give a pure implementation of ST
17:02:21 <Cale> Because of the problem of determining the type of heap that you need.
17:02:42 <Berengal> Cale: You could with Data.Data I think
17:02:47 <Cale> You could do it without IO if you're allowed to break the type system.
17:02:51 <MissPiggy> one is just that a pure implementation would have a logarithmic slowdown in comparison to a pure one
17:03:00 <MissPiggy> the second reason is what Cale just said
17:03:06 <Cale> Using Data.Data or Data.Typeable will give you a restricted type for the STRef functions.
17:03:13 <Berengal> Cale: If you somehow could inspect all types and serialize them, you could write ST
17:03:28 <Cale> You just need a safe casting operation.
17:03:32 <Cale> :t cast
17:03:34 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
17:03:41 <MissPiggy> I'm not sure why it is confusing to think about the implementation of things
17:03:43 <Cale> (or dynamic)
17:03:49 <Berengal> The casting itself doesn't have to be safe
17:04:01 <MissPiggy> especially when it unifies concepts
17:04:02 <copumpkin> so yeah, just cast to and from Any
17:04:02 <Cale> Or, sure, a stronger, unsafe casting operation.
17:04:08 <Berengal> The safety comes from the types of the refs
17:04:20 <copumpkin> who needs typeable
17:04:21 <Cale> But you could get away with using the safe one.
17:04:26 <ben> casting in haskell utterly confuses me
17:04:28 <Berengal> Yeah
17:04:28 <Cale> You don't actually need the unsafe one.
17:04:43 <MissPiggy> ben I could show you a cast that actually makes sense if you like :)
17:04:50 <theorbtwo> MissPiggy: Unification of a concept you don't know well with another concept you don't know well isn't terribly helpful when trying to explain them.
17:05:11 <Cale> ben: cast produces Nothing, unless the types a and b match, in which case cast x is the same as Just x
17:05:37 <Berengal> The point is, to be able to make references to any type, you need to be able to serialize any type. GHC solves this constraint internally by being a compiler, but you can't do it in code without passing that constraint on to your users
17:06:04 <ben> Cale: Coming from C++, it is hard to understand why I need to cast if the types match anyway
17:06:29 <Cale> ben: Because if your function is polymorphic, they might not match?
17:06:41 <theorbtwo> Doesn't that imply that the result of cast is always knowable at compile-time, and even more so, at write-time?
17:06:58 <Cale> ben: Or maybe the evidence that the types match isn't present in the part of the program that needs them to.
17:07:01 <theorbtwo> Why would I write cast x instead of just writing Nothing or x?
17:07:06 <ben> I think I meant what theorbtwo said
17:07:23 <ben> I suppose I get the basic idea that it is because C++ does genericity way different
17:07:26 <MissPiggy> guess not
17:09:06 <jmcarthur> MissPiggy: do you know of any way to memoize things in the computation monad efficiently?
17:09:20 <theorbtwo> :t cast
17:09:21 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
17:09:26 <MissPiggy> I never thought about memoization
17:09:40 <copumpkin> the computation monad?
17:10:03 <jmcarthur> a normal memo trie won't work well because it will always have to go the same depth every time
17:10:05 <MissPiggy> what about the normal memo approach mapped over compute :: Computation a -> a?
17:10:20 <MissPiggy> (of course that will be a mistake if don't know all your computations are well founded)
17:10:29 <jmcarthur> copumpkin: data Computation a = Now a | Delay (Computation a)
17:10:32 <MissPiggy> oh
17:10:37 <copumpkin> interesting
17:10:44 <MissPiggy> hehe when I say nomal memo I mean a different thing than when you say it
17:10:51 <theorbtwo> Hm.  Feels to me like you shouldn't have to worry because the compiler will do it for you, or you are working against the compiler and shouldn't be.
17:11:01 <copumpkin> jmcarthur: looks like Free Identity
17:11:04 <jmcarthur> copumpkin: MissPiggy reminded me yesterday that it can serve as a decent alternative to unamb since you can implement unamb in terms of it
17:11:21 <jmcarthur> copumpkin: unamb :: Computation a -> Computation a -> Computation a
17:11:36 <copumpkin> Free Identity feels very fundamental somehow
17:11:46 <jmcarthur> but it kind of defeats the purpose for me if i can't memoize it :(
17:11:50 <copumpkin> aw
17:11:56 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17282#a17282
17:12:03 <Cale> ^^ ben: see this :)
17:12:19 <Cale> So, using that tiny bit of code, we can write things like:
17:12:21 <MissPiggy> copumpkin what's Free?
17:12:22 <Cale> ghci> map fromDynamic [Dyn 1, Dyn "hello", Dyn (Just 5)] :: [Maybe Integer]
17:12:22 <Cale> [Just 1,Nothing,Nothing]
17:12:32 <Cale> ghci> map fromDynamic [Dyn 1, Dyn "hello", Dyn (Just 5)] :: [Maybe String]
17:12:32 <Cale> [Nothing,Just "hello",Nothing]
17:12:52 <Cale> ben: Starting to see why it might be useful?
17:13:19 <copumpkin> MissPiggy: http://hackage.haskell.org/packages/archive/category-extras/0.2/doc/html/Control-Monad-Free.html
17:13:31 <ben> Right
17:13:31 <Cale> The fact that there's an instance of Typeable means that it's okay to forget which type the thing really was, because we can recover it later using cast.
17:13:35 <jmcarthur> copumpkin: wouldn't Free Identity mean that Delay (Now f) <*> Delay (Now x) == Delay (Delay (Now (f x)))?
17:14:04 <MissPiggy>  Free F A = mu X. A + FX
17:14:07 <MissPiggy> ?????
17:14:09 <theorbtwo> Now it makes sense.
17:14:10 <MissPiggy> what is that
17:14:14 <ben> Cale: I believe the part that caused me trouble is that polymorphism means forgetting types in Haskell
17:14:25 <Cale> ben: Well, existentials particularly.
17:14:34 <byorgey> MissPiggy: yes
17:14:40 <MissPiggy> isn't Free Identity the same as []?
17:14:53 <Cale> Actually, existential types are closer to the sort of polymorphism you might be used to in C++
17:14:53 <MissPiggy> oh it's not, I see why
17:15:15 <jmcarthur> it's the same structure as Computation, but i think different semantics
17:15:27 <Cale> In C++, you have subtype polymorphism, where you can forget that an object is of some class, doing a cast upward to its base class.
17:15:28 <theorbtwo> Cale: OTOH, very different from the sort I am used to in Perl.
17:15:45 <theorbtwo> (Where an object always knows what type it is.)
17:15:56 <ben> I was thinking of static polymorphism via templates
17:16:01 <Cale> theorbtwo: yeah, that's rather different
17:16:10 <ben> Where you can just throw anything at the type and the compiler will yell when it ends up not sticking
17:16:26 <jmcarthur> well, if i can't use memoization i'm not sure how much point in this there is for me :(
17:16:38 <copumpkin> jmcarthur: I think we need the edwardk summoning dance
17:16:43 <MissPiggy> jmcarthur, what I think of 'normal' memoization is when you change
17:17:01 <jmcarthur> change?
17:17:05 <Cale> The cast in fromDynamic here does the equivalent of a downward cast, from the (here very general) base class down to some arbitrary specific class below it.
17:17:18 <MissPiggy> f 0 = .. ; f (n+1) = .. f n ...  into   f 0 = .. ; f (n+1) = ... f' !! n ... ; f' = map f [0..]
17:17:20 <blobl> do i need a computation to make something that re-creates your conversation using the timestaps of the log file, so i get a real feeling of what's going on when i get to the point of understanding you guys?
17:17:23 <ben> Right
17:17:25 <MissPiggy> since that top level f' memoizes
17:17:28 <Cale> and this might fail, hence the Maybe type :)
17:18:03 <jmcarthur> well, the memoizes on the domain of naturals
17:18:03 <theorbtwo> blobl: I'm fairly certian that the timestamps won't help; the conversation here is a blob that keeps being cut into parts and reforming.
17:18:05 <MissPiggy> and with *well founded* Computations, perhaps you can do the same sort of thing (with a computer involved)
17:18:05 <jmcarthur> *that
17:18:31 <jmcarthur> the usual way for structures like this is to use a trie instead of a list
17:18:34 <MissPiggy> yeah Nat is simple
17:18:43 <jmcarthur> but if i trie a computation then i just end up with a deep tree of delays
17:18:46 <MissPiggy> if you want to do it on something else it's harder :P
17:18:51 <jmcarthur> which is not really helping me memoize anything
17:19:00 <MissPiggy> that's what I meant about well founded computations
17:19:02 <Cale> So, if we have Typeable and existentials, we can make dynamically-typed values, which we can use to maintain a heap in implementing ST.
17:19:08 <MissPiggy> and compute :: Computation a -> a
17:19:21 <Cale> However, this will restrict all our STRefs to Typeable types of values.
17:19:33 <blobl> i am concentrated on the same experience as the one i have now, that i don't understand what youre saying, but maybe in the future will do, so re-create it. that is only printing text following timestamp delays
17:19:34 <jmcarthur> if i use compute at every stage of my recursive function then there's not really any point in using the computation monad though :(
17:19:44 <theorbtwo> Of course, lots of things are Typeable, or can be made Typable.  This isn't a *huge* restriction.
17:20:04 <MissPiggy> no memoize the computed computations
17:20:16 <jmcarthur> right, that's what i'm talking about
17:20:21 <jmcarthur> it defeats the purpose
17:20:36 <jmcarthur> i want to be able to use the results still in the computation monad
17:20:48 <copumpkin> Cale: can't you just unsafeCoerce to and from Any? the typeable is just for safe casting when you aren't ensuring safety in other ways (as you would be with your fake ST)
17:20:49 <jmcarthur> because this is a recursve function
17:20:52 <MissPiggy> oh right
17:20:57 <MissPiggy> this is difficult
17:20:58 <ben> Can we use the freestanding-derive-clauses extension to make every type typeable?
17:21:15 <arw> i remember knowing a function which does the same as head . filter
17:21:20 <copumpkin> find
17:21:34 <copumpkin> :t find
17:21:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:21:39 * arw smacks his head on the table...
17:22:04 <arw> too obvious.
17:22:16 <ddarius> @hoogle (a -> Bool) -> [a] -> a
17:22:16 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
17:22:16 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
17:22:16 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
17:22:21 <copumpkin> it's more like (listToMaybe .) . filter
17:22:27 <theorbtwo> find cond list returns Just the first element of list where cond is true?
17:22:49 <Cale> copumpkin: Of course you can do anything with unsafe casts that you can do with safe ones.
17:23:00 <Cale> copumpkin: The point is to show that we don't need unsafe casts.
17:23:03 <MissPiggy> jmcarthur if the recursive step is not memoized then what is?
17:23:25 <MissPiggy> jmcarthur or what about memoizing both the computations and the computed values together?
17:23:26 <Berengal> Cale: But with unsafeCoerce we get rid of the Typeable constraint
17:23:45 <Cale> Berengal: Yeah, but it's unsafe.
17:23:54 <copumpkin> nope, we can prove it isn't
17:23:57 <Berengal> Also, cannot everything be made Typeable if the compiler wills it?
17:24:04 <Cale> Well, of course it's not *really* unsafe.
17:24:11 <Berengal> So we could in theory have a safeCast :: a -> Maybe b
17:24:16 <Cale> I was trying to show how far we can get without using any unsafe operations.
17:24:18 <MissPiggy> do you guys know about the equality GADT?
17:24:19 <jmcarthur> MissPiggy: i have branching recursion and want to use the results from all the branches in the computation monad
17:24:22 <copumpkin> Cale: ah
17:24:29 <copumpkin> MissPiggy: yep
17:24:32 <MissPiggy> data Equal a b where REFL :: Equal a a
17:24:49 <MissPiggy> you can use that (up to a point) instead of typeclasses and unsafe
17:24:53 <Berengal> . o O ( -XEverythingIsTypeable )
17:25:09 * copumpkin unthinks Berengal's evil thought
17:25:17 <jmcarthur> MissPiggy: if i memoize both then i have no way to tell whether to use the computed result or the uncomputed one
17:25:23 <MissPiggy> (since haskell doesn't have type level lambda there's some awkard aspects if you try to represent quantifed types)
17:25:29 <theorbtwo> It wouldn't even need to be a language extension -- there's nothing in the spec that requires a type *not* to be Typable, is there?
17:25:35 * copumpkin wants a type-level lambda NAO!
17:25:41 <copumpkin> **** decidability
17:25:55 <theorbtwo> "Quantified types"?
17:26:00 <Berengal> epigram :)
17:26:10 <MissPiggy> jmcarthur,use the computed one from outside and the Computation from inside the recursion no?
17:26:17 <SamB_XP> theorbtwo: uh, new assumptions you can make ARE extensions
17:26:28 <MissPiggy> epigram doesn't make HOU decidible :P
17:26:35 <MissPiggy> nobody does
17:26:49 <MissPiggy> since you can solve posts problem with it
17:26:55 <Berengal> Bah, indecicive academics!
17:27:08 <Berengal> Everything is Word64! There, I fixed it :)
17:27:15 <jmcarthur> MissPiggy: i want to reuse results inside too :( i say again, it just defeats the purpose if i have to traverse a bunch of delays every time i recurse something that should be memoized
17:27:28 <SamB_XP> Berengal: what about (Word64, Word64)?
17:27:33 <jmcarthur> this is why i wanted to use unamb :(
17:27:35 <theorbtwo> Oh!  Of course, I know what a quantified type is.  Somehow, I was thinking in terms of three, five, not forall.
17:27:37 <MissPiggy> jmcarthur, then use the computed values from inside the recursion?
17:28:01 <Berengal> SamB_XP: What about it? I just decided "forall a. a ~ Word64"
17:28:03 <jmcarthur> that defeats the purpose of the computation monad though
17:28:19 <MissPiggy> theordtwo, yeah if you want a GADT ssyntax for types that reflects 'forall', it's a bit of a lie because it can only unify with a select few
17:28:23 <jmcarthur> (the former suggestion defeats the purpose of memoization)
17:28:25 <SamB_XP> Berengal: but all the laws stopped working!
17:28:45 <MissPiggy> but other than that, you can pretty much get by with GADTs, certainly for situations that come up in reality
17:28:45 * Berengal goes back to being an indecicive academic again
17:28:50 <ricree> I'm trying to get the functions from Typeable to work with a Type created using data.  I'm getting an error that there is no instance for (Typeable Mytype).  To make an instance of this, it looks like I need to implement a typeOf function for it, but I'm not sure how I would go about doing that.  Can anyone point me in the right direction?
17:29:04 <SamB_XP> in fact, I think GHCi just segfaulted when I typed "1"
17:29:20 <MissPiggy> jmcarthur: I don't understand how both options are wrong -- surely ONE of them is the right?
17:29:49 <jmcarthur> okay, i'll just explain what would happen with either suggestion
17:29:51 <mauke> ricree: you need to enable a language extension and add 'deriving (Typeable)' to your type definition
17:29:54 <Berengal> SamB_XP: We better fix that. Everything is (Word64, Word64)
17:29:58 <SamB_XP> jmcarthur: use MonadFix ?
17:30:01 <copumpkin> MissPiggy: no LEM!
17:30:05 <jmcarthur> SamB_XP: huh?
17:30:17 <MissPiggy> jmcarthur, oh it wouldn't be lazy enough if you used the computed values internally?
17:30:25 <jmcarthur> MissPiggy: right
17:30:28 <theorbtwo> MissPiggy: Yeah; if there were a way to make forall not need specialized semantics, then there wouldn't be a forall keyword.
17:30:59 <theorbtwo> I think not unifying normal variables and type variables is the great flaw of Haskell... but it certianly wouldn't have been easy.
17:31:46 <jmcarthur> MissPiggy: and if i memoize them uncomputed i just have to compute them over and over
17:31:57 * Berengal still thinks records and not having agda-syntax are the great flaws of Haskell
17:32:15 <copumpkin> I'm not a fan of agda records either
17:32:23 <jmcarthur> although now i'm wondering if it's as bad as i'm imagining...
17:32:24 <copumpkin> but they certainly are a lot more featureful
17:32:31 <jmcarthur> lemme do some math and figure up my recursion depth
17:33:01 <Berengal> copumpkin: I feel records with default values could be a decent replacement for type classes
17:33:21 <theorbtwo> I don't think record types are central enough to be a great central flaw, and if you can fix it with just a little extra sugar, it's not really great.
17:33:28 <copumpkin> Berengal: yeah, they could... all you'd be missing is automatic lookup and implicit passing of them
17:33:32 <jmcarthur> maximum of 2500 levels deep..
17:33:49 <jmcarthur> actually, half that
17:34:09 <copumpkin> Berengal: and that's already what we get in Algebra.* in the agda std lib
17:34:11 <Berengal> copumpkin: That's what the default values solve. "instance Eq Foo where ..." => "default Eq Foo = Eq { ..."
17:34:21 <copumpkin> oh I see, default in that sense
17:34:26 <jmcarthur> i guess traversing a 1250 element list is still faster than regenerating it
17:34:30 <Berengal> And with implicit arguments...
17:34:32 <copumpkin> I thought you meant defaults for fields of the record
17:34:56 <Berengal> Ah, no
17:35:03 <jmcarthur> jeez, but the memory that will take up for no good reason annoys me
17:35:10 <copumpkin> Berengal: quick, submit a patch! :D
17:35:10 <Berengal> It does start to feel a bit like dynamic variables though
17:35:27 <MissPiggy> what if you made.... data Computation a = Now a | Later (Computation a) a
17:35:28 <MissPiggy> :D
17:35:42 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17283#a17283
17:35:42 <Berengal> instead of (Eq a) => ... we could use (?eq :: Eq a) =>
17:35:44 <copumpkin> that's almost []
17:35:48 <theorbtwo> jmcarthur: If I can ask a potentially silly question, what *is* the point of the monad here?  Why not make it a pure function, and let the compiler worry about the memoization?
17:35:49 <copumpkin> it's [] + 1
17:35:50 * jmcarthur wonders what to do with that....
17:35:50 <copumpkin> :P
17:35:51 <Cale> ^^ Typeable ST via safe casts
17:36:09 <MissPiggy> jmcarthur, make a equal to the Now thing
17:36:13 <jmcarthur> theorbtwo: the compiler doesn't do memoization, and that not the point of the computation monad anyway
17:36:19 <MissPiggy> jmcarthur, but be very careful not to look at it unless you mean it!
17:36:33 <Cale> (with homemade dynamic types for good measure :)
17:36:33 <jmcarthur> MissPiggy: but when do i look at it?
17:36:37 <copumpkin> theorbtwo: the point for him is to get unamb without unamb
17:36:44 <jmcarthur> right
17:36:52 <theorbtwo> unamb?
17:36:52 <MissPiggy> jmcathur, when you call the memoized version
17:36:59 <MissPiggy> not when you do recursion
17:37:04 <copumpkin> theorbtwo: unamb :: a -> a -> a
17:37:12 <jmcarthur> MissPiggy: but i want the recursion to be memoized too
17:37:25 * Cale wonders if anyone still cares :P
17:37:26 <copumpkin> theorbtwo: it'll run both its parameters in parallel and whichever finishes first is returned (stopping the other one)
17:37:39 <MissPiggy> jmcarthur do you think that lazyness and computation are consistent?
17:37:43 <theorbtwo> Oh!
17:37:45 <MissPiggy> jmcarthur (and I mean lazy-lazyness)
17:37:47 <copumpkin> Cale: I'm sure someone does!
17:37:53 <jmcarthur> MissPiggy: it would work fine for unamb
17:38:06 <theorbtwo> Now it makes sense.
17:38:11 <jmcarthur> MissPiggy: as in the unamb package, not as in implementation in terms of Computation
17:38:13 <Berengal> Cale: I care
17:38:46 <jmcarthur> i'm only not using unamb because unamb won't work properly on ghc 6.8
17:38:54 <Cale> Actually, would have been nicer to work in the State monad there.
17:38:58 <theorbtwo> (Well, except for the name.)
17:39:02 <MissPiggy> oh
17:39:03 <Cale> To expose the relationship between ST and State
17:39:04 <MissPiggy> hmmmmmmm
17:39:22 <MissPiggy> Cale but there isn't really a relation ship is there?
17:39:44 <Cale> MissPiggy: Well, look at my runST'
17:40:01 <Cale> That's exactly the sort of code where you want to use the state monad.
17:40:11 <copumpkin> jmcarthur: I could try to add noise to their inbox and ask for at least 6.10
17:40:20 <jmcarthur> i suppose i could maintain an explicitly imperative memo trie of some kind, maybe
17:40:23 <copumpkin> maybe enough people asking will work
17:40:28 <MissPiggy> Cale, oh that is just state but you written it out long
17:40:32 <MissPiggy> ?
17:40:44 <jmcarthur> copumpkin: i've been told by those in power that they would be very difficult to convince, but maybe...
17:41:57 <copumpkin> like, Ruby 1.9 and GHC 6.8??
17:42:01 <MissPiggy> Cale, hey this is quite interesting
17:42:02 <copumpkin> nobody uses 1.9
17:42:14 <Heffalump> who are you talking about asking? (I can't spot the answer in scrollback)
17:42:15 <MissPiggy> Cale, they way you give a syntax then an interpreter, is that always a monad/
17:42:16 <MissPiggy> ?
17:42:35 <copumpkin> Heffalump: the waterloo AI club people
17:42:51 <copumpkin> http://csclub.uwaterloo.ca/contest/faq.php
17:43:01 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17284#a17284
17:43:04 <copumpkin> they're still running GHC 6.8.2 and it prevents unamb
17:43:05 <ricree> Ok, so I've been working my way through http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1 , and I'm trying to figure out how I'd do Exercise 1.  It seems like I'd want some function "[LispVal] -> LispVal" that would return a bool true if the lispval is of the right type, and false if it's a different type of lispval.  Can someone point me in the right direction here?
17:43:09 <Cale> ^^ using the State (Seq Dynamic) monad
17:43:12 <copumpkin> and good type families etc.
17:45:31 <Cale> ricree: that seems right
17:46:05 <ricree> Cale: I'm really confused how I would go about implementing that sort of function
17:46:17 <MissPiggy> Cale do you think it's possible to derive a version that doesn't use the interpreter or GADT from that one that does?
17:46:17 <Berengal> ricree: Presumably you just "eval" the expression and look at the result
17:46:22 <Cale> ricree: Well, by pattern matching on the LispVal(s) that you get.
17:46:27 <MissPiggy> I mean in general
17:48:21 <Cale> MissPiggy: To answer your first question, it's not always a monad this way. In fact, it outwardly violates the monad laws unless you hide the data constructors behind a module boundary.
17:48:47 <Cale> MissPiggy: There are fancier ways to do this, like using MonadPrompt which avoid the issue of sometimes not getting a monad.
17:49:07 <MissPiggy> monad laws are fine if you interpret them with a different = though
17:49:30 <MissPiggy> in this case you could use like: a = b <=> runST a x = runST b x
17:49:35 <Cale> It will always be a monad under equivalence of action, provided that your interpreter handles the return and bind cases sanely.
17:49:40 <MissPiggy> as the definition
17:50:34 <Cale> It would be better to go with MonadPrompt, but many people don't know about that, and I think it would have been distracting here :)
17:50:59 <MissPiggy> well I don't know about MonadPrompt but it's not like I couldn't learn it
17:50:59 <copumpkin> jmcarthur: I posted to the forums
17:51:06 <jmcarthur> copumpkin: thanks
17:51:12 <copumpkin> jmcarthur: http://csclub.uwaterloo.ca/contest/forums/viewtopic.php?f=9&t=107
17:51:34 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.2/doc/html/Control-Monad-Prompt.html
17:51:50 <jmcarthur> copumpkin: thanks
17:51:53 <jmcarthur> oops
17:51:58 <Cale> The main downside to MonadPrompt is that the types can be more than a little overwhelming.
17:52:01 <jmcarthur> well, you get two thanks i guess
17:52:09 <Cale> runRecPromptT  :: forall p r b m. (r -> b) -> (forall a. p (RecPromptT  p m) a -> (a -> b) -> b) -> (forall  a. m a -> (a -> b) -> b) -> RecPromptT  p m r -> b
17:52:24 <Cale> ^^ at some point I understood that type ;)
17:52:44 <Cale> Nah, that's actually not quite right, I still do :)
17:53:23 <Cale> But you could get away just using runPromptC here.
17:53:40 <copumpkin> jmcarthur: I obviously lied a bit but it might become truth in the next few days :P
17:53:42 <MissPiggy> okay that is a LOT harder than I thought it would be :P
17:53:43 <Cale> Or even runPromptM with the state monad.
17:53:51 <tensorpudding> the wikipedia article implies that GHC supports System F, but it also says that type inference for System F is undecideable...how is that?
17:54:00 <MissPiggy> on but it's a monat transformer, so of course
17:54:03 <MissPiggy> that would be difficult
17:54:15 <Cale> MissPiggy: and with a recursive prompt type.
17:54:28 <MissPiggy> I never understood monad tranformers,  just how to use them
17:54:34 <Heffalump> tensorpudding: GHC uses System F at the object level, not the source level
17:54:43 <Heffalump> also, GHC doesn't support type inference for all language features even at the source level
17:55:09 <SamB_XP> so if you CAN use system F's full power, you have to put a lot of the types in yourself ...
17:55:16 <copumpkin> anyone else feel like chiming into that thread? :)
17:55:24 <copumpkin> for the greater good of haskelldom?
17:55:24 <jmcarthur> copumpkin: obviously? you convinced me that you wanted to participate :)
17:56:45 <MissPiggy> what thread?
17:56:51 <copumpkin> jmcarthur: I do! :P I just lied about the type families being what I wanted :P
17:56:56 <copumpkin> MissPiggy: http://csclub.uwaterloo.ca/contest/forums/viewtopic.php?f=9&t=107
17:57:18 <Heffalump> I don't think lying to people is really for the "greater good of haskelldom" :-)
17:57:34 <Heffalump> it just makes us look like twats when you get caught
17:57:42 <copumpkin> Heffalump: it's not a lie, just a stretch
17:58:04 <copumpkin> I can definitely see myself wanting them :)
17:58:15 <Heffalump> :-)
17:58:27 * copumpkin whistles innocently
17:58:29 <Cale> MissPiggy: A cool thing about MonadPrompt is that it automatically satisfies the monad laws, and you can write different interpreters for the same monad, so that, for example, if you want to have a human and AI player for a game, you can have a monad for game operations, and the human interpreter will do things like prompt the human for moves, while the AI version will just compute the results.
17:58:38 <copumpkin> gotta go
17:58:49 <notallama> so, in order to officially join the ranks as a haskell hacker, i need to write a monad tutorial, correct?
17:58:56 <Cale> notallama: heh
17:59:09 <mauke> in haiku form
17:59:09 <SamB_XP> Cale: what if it's a two-player game ?
17:59:11 <ezyang> bye copumpkin
17:59:28 <SamB_XP> notallama: please don't!
17:59:30 <Cale> SamB_XP: Well, you would switch between using the two interpreters for each round?
18:00:13 <SamB_XP> notallama: there are already far too many of those
18:00:51 * Cale just realised that int-e and Bertram Felgenhauer are the same person :)
18:00:54 <mauke> @quote lilac monoid
18:00:54 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
18:00:59 <kmc> @quote tutorial
18:01:00 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
18:01:08 <kmc> @quote tutorial
18:01:08 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
18:01:32 <notallama> SamB_XP: i'm aware. and basically none of them are helpful, except to the author. which is why i was considering doing one :V
18:01:44 <SamB_XP> notallama: oh, okay
18:01:45 <Cale> notallama: hehe
18:01:50 <SamB_XP> then please don't PUBLISH it ;-P
18:01:51 <Cale> notallama: Have you seen mine though?
18:02:04 <Cale> (I've had good comments about my tutorials)
18:02:08 <jmcarthur> @quote haiku
18:02:08 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
18:02:12 <jmcarthur> @quote haiku
18:02:13 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
18:02:17 <jmcarthur> aw :(
18:02:19 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
18:02:23 <SamB_XP> @quote haiku
18:02:23 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
18:02:27 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
18:02:30 <SamB_XP> @quote haiku
18:02:30 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
18:02:35 <jmcarthur> there was a haiku monad tutorial. maybe "haiku" isn't in the quote
18:02:41 <mauke> ...
18:02:47 <mauke> DID YOU MEAN MY LILAC QUOTE
18:02:50 <SamB_XP> @quote /
18:02:51 <lambdabot> ghc says: lexical error in string/character literal
18:02:53 <Cale> And if you just want to get to using IO without caring about monads: http://www.haskell.org/haskellwiki/Introduction_to_IO
18:02:53 <SamB_XP> @quote /
18:02:53 <lambdabot> ghc says: lexical error in string/character literal
18:02:56 <SamB_XP> @quote /
18:02:57 <lambdabot> byorgey says: you can shoot yourself in the foot in any language =) / LoganCapaldo> Haskell just makes sure the bullet has the right type to hit your foot :)
18:03:00 --- mode: ChanServ set +o mauke
18:03:00 --- kick: SamB_XP was kicked by mauke (SamB_XP)
18:03:15 <notallama> Cale: i have not seen that one. i'll give it a read later
18:03:52 <Cale> Monads as Computation tries to give a good sense of why we actually care about monads as a programming abstraction.
18:04:05 <Cale> The reason is of course, that it saves us from writing some code over and over.
18:04:24 <Cale> In particular, the various functions in Control.Monad, and other places in the libraries
18:04:38 <Cale> (anywhere that you see a function whose type starts with (Monad m) => ...
18:04:40 <Cale> )
18:05:01 --- mode: mauke set -o mauke
18:05:30 <tensorpudding> is monads-fd going to replace mtl anytime soon?
18:05:35 <notallama> they just sortof clicked for me the other day when i started seeing M as a homomorphism or something. just need to get that understanding into something practical now, you know?
18:05:51 <Heffalump> tensorpudding: when someone gets their arse in gear and makes it happen
18:05:58 <Cale> tensorpudding: They both suck. We need a real, decent replacement that's not just a clone of the same fail.
18:06:17 <SamB_XP> hmm, I just want fail out of Monad
18:06:29 <mauke> @quote shapr snow
18:06:30 <lambdabot> shapr says: < shapr> the snow falls slowly / the lambdas are lifting - / weak head normal form.
18:06:38 <Cale> Control.Monad.List in particular should be removed.
18:06:49 <Cale> Control.Monad.RWS is a bit of a joke.
18:07:16 <SamB_XP> Cale: it's not more efficient than nesting them ?
18:07:22 <tensorpudding> all i want is to be able to use State without having to have an ugly hack
18:07:36 <tensorpudding> because some library i'm using is depending on monads-fd
18:07:54 <Cale> SamB_XP: Well, *perhaps*. It ought not to be though.
18:07:56 <notallama> also, speaking of monads, is there a reason Maybe is such a common monad? it seems like arrows would fit better, since they can handle short circuiting, unless i'm missing something.
18:08:33 <Cale> notallama: Uh, Maybe is a monad, but it's actually a little rare to have code which cares that Maybe is a monad.
18:08:51 <Cale> notallama: It's a good simple example of a monad though.
18:09:16 <tensorpudding> RWH has an example using Maybe as a monad i think
18:09:17 * Heffalump writes a lot of code that uses its monadic nature
18:10:11 <Cale> Certain bits of code lend themselves to that
18:11:51 <Cale> Just a tangential point to this conversation, but something that I think is really important and often missed by monad tutorials is that you're not really programming with monads until you can write code which works in any monad.
18:12:30 <Cale> There's no point in recognising that things happen to be monads until you can do that.
18:12:33 <ezyang> heh
18:12:41 <Heffalump> yes there is
18:12:43 <SamB_XP> so, likely your first bit of monadic code would have been forever, not so long ago...
18:12:48 <Heffalump> you can use existing polymorphic code on them
18:13:00 <ezyang> I find that this tends to be more true for MonadPlus
18:13:10 <Cale> Heffalump: Yes, but if that polymorphic code can't exist, then there's no point.
18:13:19 <Heffalump> but someone else has already written it
18:13:25 <Heffalump> so it's still useful
18:13:30 <Cale> I've seen a lot of stupid monad tutorials for other languages which go over a bunch of common monads, while designing things in such a way that you can't get that sort of polymorphism.
18:13:44 <Heffalump> most languages lack higher-kinded type variables
18:13:47 <Cale> So you can't write things like a polymorphic sequence function.
18:14:01 <Cale> and in cases like that, there's just no point in even talking about monads
18:14:28 <notallama> c++ templates might be able to handle monads. c++0x, anyway. it sure would be ugly, though.
18:14:43 <tensorpudding> using do notation makes some things easier though
18:15:07 <SamB_XP> Cale: well, when *I* design monadic thingies for other languages, I'm very careful not to make that mistake if I can help it ;-P
18:15:30 * ezyang doesn't understand why you'd make monads in a dynamically typed language 
18:15:41 <Heffalump> to sequence effects
18:15:52 <SamB_XP> to port Parsec ?
18:16:02 <ezyang> *dynamically typed strictly evaluated language
18:16:54 <Cale> It usually ends up being awkward because the return function is polymorphic in its result type.
18:17:09 <Cale> So you typically need to add additional parameters to return and bind.
18:17:14 <Cale> (to select the instance)
18:17:15 <kmc> in a dynamically typed language it should be no biggie
18:17:26 <kmc> like i imagine monadic code in ruby looks all right
18:17:42 <SamB_XP> kmc: if they ever get it right!
18:17:47 <Cale> In dynamically typed languages it's even more of a problem, because the type information isn't even there to be used.
18:18:05 <SamB_XP> Cale: eh?
18:18:08 <Cale> You want to select your implementation of return based on the type context.
18:18:23 <Cale> and not on the type of its parameter, but on the type of its result
18:18:38 <SamB_XP> er, I think I made return a class method, basically ...
18:19:01 <mauke> sub sequence { my ($M, $ys) = @_; my ($x, @xs) = @$ys or return $M->{unit}([]); $M->bind($x, sub { my $v = shift; $M->bind(sequence($M, \@xs), sub { my $vs = shift; $M->{unit}([$, @$vs]) }) }) }
18:19:05 <mauke> ew.
18:19:53 <mauke> argh, and $M->{bind}
18:20:07 <ddarius> I'd probably use a combination of dictionary passing and some simple macros in a dynamically typed language.
18:20:15 <ddarius> Indeed, I believe this is what some Scheme libraries do.
18:20:33 <SamB_XP> most dynamically typed languages don't HAVE macros
18:21:02 <mauke> ah, but we have the C preprocessor
18:21:23 <SamB_XP> which works very nicely when all our comments begin with #
18:22:01 <mauke> or if ' appears in an identifier
18:22:44 <ddarius> SamB_XP: The macros are mainly for convenience.  Other approaches, such as implicit arguments, would also work and also not be necessary.
18:27:54 <notallama> return in a dynamically typed language could be a constructor for a monad that implicitly casts itself as other monads, using their return function. i think.
18:32:48 <copumpkin> jmcarthur: looks like I failed
18:32:58 <copumpkin> unless someone else wants to chime in and wants to get in an argument
18:33:05 <copumpkin> it's not true that they're all just as old
18:38:34 <dufflebunk> I would have to say that my llama needs dinner.
18:42:58 * hackagebot upload: CouchDB 0.10.1 - CouchDB interface (ArjunGuha)
18:56:50 <applicative> copumpkin:  besides, surely most of the Major Languages aren't really allowed to change, or not too much.
18:57:09 <copumpkin> applicative: aren't allowed to change?
18:57:53 <copumpkin> applicative: oh, you mean things like existing submissions using OldException
18:57:56 <applicative> I just mean the obvious, that they have to live forever, and the code must forever remain intelligible
18:57:58 <copumpkin> and breaking if they upgrade?
18:58:18 <copumpkin> hmm
18:58:24 <applicative> Haskell can change, the GHC 'avoids success' for this reason
18:58:47 <copumpkin> applicative: what that I said are you responding to?
18:59:01 <aavogt> too much success to fix the Monad, Applicative class mis-organization
18:59:32 <applicative> I followed the link above, complaining the the ghc 6.8.2 is old
18:59:35 <copumpkin> oh
18:59:46 <applicative> there awas a response: but the other compilers are old
18:59:52 <applicative> just as old
18:59:56 <copumpkin> they aren't actually
19:00:00 <copumpkin> but I don't feel like getting in a fight
19:00:27 <applicative> yes my point was, even if they were just as old, it wouldn't be relevant because of the different character of most of those languages
19:00:36 <copumpkin> ah, I see
19:00:39 <applicative> the languages didnt change
19:00:45 <applicative> not so much
19:00:57 <applicative> sorry, this is labored by my prior unclarity
19:01:05 <copumpkin> no, I understand :) I was just being thick
19:01:14 <copumpkin> (not intentionally)
19:01:46 <applicative> So we can improve your argument, but there's no hope.
19:03:29 <jmcarthur> copumpkin: yeah you failed
19:03:43 <jmcarthur> copumpkin: i manage to "port" unamb 0.2.2 to ghc 6.8
19:04:08 <jmcarthur> and by "port" i mean "remove functionality, make ugly, and cause to spit stuff into stderr constantly"
19:04:34 <copumpkin> aw
19:04:53 <copumpkin> I wish major distros would upgrade from 6.8 dammi
19:05:12 <jmcarthur> aavogt: that's what alt-stdlib is for. to go back to the "avoiding success" days :)
19:05:52 <applicative> i joined hcoop.net for some reason.  It turns out they have ghc-6.6 installed, though ityou can request anything apt-gettable.  unfortunately that means 6.8
19:06:13 <jmcarthur> o_O
19:06:32 <applicative> Maybe I should ask them to install the GOFER interpreter
19:06:36 <jmcarthur> well, so far so good on my ported unamb
19:06:55 <jmcarthur> i'm scared i might run into some of these rts bugs which were supposedly discovered by using unamb, though
19:07:18 <applicative> why are you forced to use 6.8
19:08:12 <dufflebunk> if you want pain, try getting the latest ghc on a RH3 machine.
19:08:27 <jmcarthur> applicative: because the admins don't want to upgrade it
19:08:48 <conal> jmcarthur: i'm always interested in unamb applications.  what are you doing with it?
19:09:03 <copumpkin> AI!!!
19:09:06 <jmcarthur> conal: you are aware of the tron ai thing that's going on?
19:09:15 <conal> no, i'm not.
19:09:51 <SamB_XP> lightcycles or ?
19:09:53 <jmcarthur> conal: well, here: http://csclub.uwaterloo.ca/contest/index.php  ... and i'll try to explain how i'm planning to use unamb
19:10:15 <applicative> only you have to use the original GOFER ... which may not make unamb easy....
19:11:07 <SamB_XP> applicative: wha?
19:12:21 <jmcarthur> conal: i'm basically brute forcing the game (but with a fast ai as a backup in case i get near the time limit). i'm going to memoize the main recursive function that operates on the state of the game, and i'm going to use unamb on the logic to determine which direction is best
19:12:43 <jmcarthur> on the branches, i mean
19:13:29 <aavogt> shachaf: are you involved with that contest?
19:13:33 <aavogt> err shepheb
19:13:49 <jmcarthur> conal: that is, my ai returns a move and a forecast of how good that move is, and i'm using unamb to pick the move with the best forecast.
19:13:53 <conal> jmcarthur: cool.  neat application.
19:14:05 <applicative> have any of the haskellers posted code?
19:14:34 <jmcarthur> so if a move is found to guarantee that i can lose, i can rule that move out immediately, or if a move is found to guarantee a win, i can drop the other computations and just go with it
19:14:44 <aavogt> applicative: there's a basic AI in the haskell starter package...
19:14:55 <copumpkin> applicative: yeah, there are several in the top100
19:15:02 <copumpkin> used to be top10 but the c++ers turned up the heat
19:15:13 <jmcarthur> i'll be up there eventually! ;)
19:16:27 <jmcarthur> conal: what exactly were the bugs that were discovered in the rts from using unamb?
19:16:36 <copumpkin> :)
19:17:36 <conal> jmcarthur: i don't remember them all, and i had trouble even understanding them.  there are some notes on my blog, iirc.  see http://conal.net/blog/posts/smarter-termination-for-thread-racing/
19:17:45 <jmcarthur> conal: thanks
19:21:05 <jmcarthur> there are 19 haskell entries in all so far
19:21:29 <jmcarthur> 467 entries total
19:21:39 <jmcarthur> > 19*100/467
19:21:40 <lambdabot>   4.0685224839400425
19:21:45 <jmcarthur> 4%
19:24:32 <solrize> > let 2+2=5 in sum [2+2, 3-1]
19:24:33 <lambdabot>   7
19:30:36 <Axman6> are liftM and fmap always going to do exactly the same thing?
19:30:48 <solrize> liftM only works on monads
19:31:42 <dufflebunk> whoa, I'd never imagined something like unamb. Cool.
19:32:31 <Axman6> solrize: well, i meant on things that they did both work on ;)
19:32:35 <Axman6> ie, monads :P
19:36:49 <dolio> Drawing from a few discussion's I've come across in the past, I'd say yes, liftM and fmap should be the same if they're correctly implemented.
19:36:56 <dolio> Discussions, even.
19:37:21 <ezyang> Definitely.
19:37:33 <ezyang> You've got a pretty fucked up Monad if it doesn't have a valid functor instance
19:37:52 <dolio> Because there's only one function f :: (a -> b) -> T a -> T b with f id = id, by parametricity, I think.
19:38:04 <dolio> And thus, only one functor instance per T.
19:38:09 <dolio> Or, at most one.
19:39:38 <aavogt> dolio: but for which equality on T a ?
19:40:31 <dolio> Whichever one the free theorems use.
19:42:02 <applicative> dolio: only one functor instance for T if it's already a monad instance?
19:42:16 <dolio> I might be wrong about that, too. Maybe it's that f id = id implies that f (g . h) = f g . f h, which doesn't necessarily imply only one such f. I can't recall.
19:43:25 <applicative> We instance T as a functor and as a monad separately, so can't I define fmap one way and (implicitly) liftM another?
19:43:33 <dolio> applicative: Only (at most) one (correct) functor instance for T period. So if T is a monad, and thus a functor, it must be a monad using that same functor.
19:43:56 <dolio> And so liftM must be the same as fmap.
19:44:24 <dolio> If both are correct.
19:44:42 <applicative> Arent there cases where I can make T a functor two ways, as obviously happens with monoid instances?
19:44:59 <dolio> Are there?
19:47:15 <aavogt> dolio: parametricity only applies if you iglore strictness and undefined, right?
19:47:52 <dolio> I think the results you get tend to assume that functions are strict.
19:48:27 <aavogt> but maybe the laws on Functor sort of ensure you can't have   fmap' f = \x -> x `seq` fmap f x
19:49:39 <dolio> Actually, fmap is supposed to be strict.
19:49:44 <dolio> I think.
19:49:52 <dolio> fmap id = id and id is strict, for instance.
19:50:58 <dolio> So, that means 'fmap f p = (fst p, f (snd p))' is an incorrect definition.
19:51:18 <dolio> For (a,) as a functor.
19:51:39 <dolio> Because then fmap id undefined = (undefined, undefined) /= undefined.
19:57:11 <jmcarthur> okay, so i add unamb to my core algorithm and it starts timing out even though i have a timeout on the whole thing with a default value...
19:57:39 <jmcarthur> i guess the rts just gets overloaded with threads and doesn't context switch enough to get to the timeout thread
19:58:49 <jmcarthur> i just realized that what i said was ambiguous
19:59:19 <jmcarthur> i add unamb to my core algorithm and it starts taking too long even though i have a timeout on the whole thing with a default value
20:05:25 <vyom> I am trying to understand this article http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ , so I created this file http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17295#a17295 But it does not compile for me.. what am I missing?
20:06:09 <kmc>     Type constructor `A' used as a class
20:06:45 <kmc> @ghc
20:06:45 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
20:06:46 <vyom> kmc: I know.. I get that error.. but it seems to be used in similar fashion in the original article
20:06:48 <kmc> @ghc
20:06:49 <lambdabot> ghc says: Cycle in type synonym declarations
20:06:55 <kmc> vyom, then the article must be in error
20:07:16 <kmc> note the difference between Widget and AnyWidget
20:07:24 <aavogt> preflex: seen luqui
20:07:25 <preflex>  luqui was last seen on #haskell 1 day, 15 hours, 59 minutes and 12 seconds ago, saying: cheater!
20:07:25 <kmc> a class and a type resp.
20:08:42 <vyom> kmc: Widget and AnyWidget are used in the original (anti-) pattern that the author describes.. and then he goes on to suggest an apparently simple alternative.. which is what I am referring to
20:10:08 <kmc> data Window; instance Widget Window
20:10:09 <kmc> that?
20:10:43 <kmc> that's in the context of the first snippet
20:10:46 <kmc> i guess
20:11:19 <kmc> "all you need to abstract over a function is another function"
20:11:20 <kmc> i like this quote
20:11:52 <kmc> all you need to abstract over a function is a class template with an overloaded function call operator in an anonymous namespace
20:12:55 <jmcarthur> i'm thinking about adding some sort of upper bound on the number of unamb threads
20:12:55 <vyom> kmc: ah okay..
20:12:57 <jmcarthur> if i can
20:25:05 <applicative> dolio: I am coming to grief looking for multiple functor instances.  I see a haskell cafe thread  here: http://tinyurl.com/ylaj7zt
20:34:33 <copumpkin> jmcarthur: ooh, you're climbing that ladder!
20:34:46 <copumpkin> applicative: you want multiple functor instances for something specific?
20:37:45 <jmcarthur> i am?
20:37:45 <applicative> copumpkin: the abstract question came up, can there be different functor instances, different definitions of fmap, as we can have several monoid instances
20:37:59 <copumpkin> jmcarthur: you're at 65 now, I saw you in the 90s earlier
20:38:11 <copumpkin> applicative: I'm trying to think of one and failing :)
20:38:14 <jmcarthur> copumpkin: i've fallen, actually
20:38:21 <jmcarthur> i was in the 30s earlier today
20:38:25 <copumpkin> oh
20:38:32 <applicative> i
20:38:35 <jmcarthur> the ladder is very volatile
20:38:40 <glguy> The functor laws and kind restrictions don't leave much room for choice
20:38:44 <jmcarthur> and you also start back over at the bottom when you submit a new bot
20:38:45 <copumpkin> yeah
20:38:56 <copumpkin> jmcarthur: oh, that sucks
20:39:01 <erikc> does your AI have to be deterministic?
20:39:09 <copumpkin> erikc: I don't think so
20:39:15 <jmcarthur> nah, you work back up to where you were if you bot is equivalent in intelligence
20:39:18 <jmcarthur> erikc: nope
20:39:27 <jmcarthur> i'm having issues now though
20:39:45 <jmcarthur> unamb works great except for the whole overloading the rts with threads things
20:39:47 <jmcarthur> *thing
20:39:50 <applicative> i'm not seeing any easy way to do it, but the discussion I linked doesn't give any very clear disproof.
20:40:27 <jmcarthur> is there a way to tell ghc that if there are x threads already to just block on forkIO until another thread dies?
20:40:30 <applicative> So i'm accepting the theorem on the basis of 15 minutes worth of empirical failure.
20:41:32 <jmcarthur> because i'm getting so many threads that my timeout thread isn't triggering in time
20:41:40 <dolio> applicative: Note that the example someone presented, sets represented as lists, isn't very convincing, because you can't write fmap for sets as the type (a -> b) -> [a] -> [b].
20:42:10 <gwern> jmcarthur: hold on to a mvar to each thread and only run another thread when a mvar unblocks?
20:42:52 <dolio> It'd have to be more like (Ord b) => (a -> b) -> [a] -> [b], if we're maintaining some structure to the list beyond its listness.
20:43:12 <copumpkin> applicatives on the other hand are easy to come up with multiple instances of :)
20:43:17 <dolio> But that doesn't work as a type for fmap.
20:43:24 <jmcarthur> gwern: eh, i don't see a very easy way to integrate that with unamb
20:43:40 <jmcarthur> dangit, i love unamb, but i wish its implementation was so reliant on things like this
20:43:46 <jmcarthur> *wan't
20:43:50 <jmcarthur> **wasn't
20:43:52 <jmcarthur> i suck
20:43:58 <gwern> jmcarthur: well, maybe you could fork pairs of threads, one with a timeout/kill
20:44:39 <jmcarthur> not sure that doubling the threads is really what i want :\
20:45:07 <gwern> jmcarthur: is leaving threads hanging around better?
20:45:15 <ddarius> I highly suspect that it would not be hard to perform an inductive proof of the uniqueness of fmap on all positive data types.
20:46:37 <gwern> jmcarthur: maybe you could do a queue then: every new thread gets put in the back and whatever thread is at the front is killed; you then have a fixed number of threads running at anyone time, and the oldest threads get killed
20:46:59 <gwern> really, I don't see any solution which isn't basically based on threadpools and timeouts
20:47:05 * ezyang <3 oleg 
20:47:13 <applicative_> copumpkin: what are the obvious multiple applicative instances for a functor
20:47:30 <copumpkin> applicative_: well, the ZipList vs. [] distinction on lists for example
20:47:38 <ezyang> Oh!
20:47:44 <ezyang> ZipList needs a different functor instance
20:47:53 <copumpkin> it does?
20:47:58 <ezyang> Oh, osrry
20:47:59 <ddarius> ezyang: No it doesn't.
20:48:03 <ezyang> Different /pointed/ instance
20:48:09 <copumpkin> yeah
20:48:19 <copumpkin> at the functor level they all seem equal
20:48:29 <applicative_> ezyang: youre denying the theorem we're all accepting
20:48:50 <jmcarthur> gwern: i was just hoping for something i could tell the rts
20:48:56 <jmcarthur> rewriting unamb doesn't sound fun to me
20:49:01 <ezyang> applicative_: mua ha ha ha
20:49:28 <gwern> jmcarthur: what option? 'put the main thread to sleep if X threads is exceeded'?
20:49:35 <gwern> sounds like a bad idea to me
20:49:39 <jmcarthur> no
20:49:49 <applicative_> right, ziplist, you can apply each of  the list of functions to each in the list, or else zip them, pairing them off.   Very beautiful.
20:50:00 <jmcarthur> just block on forkIO. not necessarily going to be the main thread
20:50:04 <applicative_> sorry botched grammar.
20:50:11 <jmcarthur> and even if it is, it's something *i* chose to do
20:50:26 <jmcarthur> in this particular case, it would not be bad
20:51:17 <tehYama> hello all
20:51:45 <jmcarthur> maybe i could just keep a recursion depth and stop using unamb after a certain depth
20:52:09 <applicative_> copumpkin: do the two ways of making lists applicative go with two ways of making them monads?  or is one not a monad
20:52:20 <copumpkin> so I guess for list, there are two main applicative instances I can think of, and for list as set, there are two other ones too
20:52:21 <ddarius> @wn wight
20:52:23 <lambdabot> *** "wight" wn "WordNet (r) 2.0"
20:52:23 <lambdabot> wight
20:52:23 <lambdabot>      n 1: a human being; `wight' is an archaic term [syn: {creature}]
20:52:23 <lambdabot>      2: an isle and county of southern England in the English
20:52:23 <lambdabot>         Channel [syn: {Isle of Wight}]
20:52:39 <copumpkin> applicative_: ZipList isn't a monad, but if you had type-sized lists you could make it one
20:52:42 * ddarius is going to start using "wight."
20:53:01 <copumpkin> I wonder if Isle of Wight is related to the first meaning
20:54:11 <tehYama> I'm new here, (new to haskell as well!) Is there somebody who is willing to point me in the right direction when if comes to partial applications?
20:54:11 <copumpkin> damn the c++ is displacing everyone in the leaderboard
20:54:17 <ezyang> copumpkin: Type-sized lists? Oh boy.
20:54:52 <kamatsu> hah, the UK has the Isle of Wight and the Isle of Man
20:54:57 <kamatsu> or are they the same?
20:55:10 <gwern> @wn ruth
20:55:11 <lambdabot> *** "Ruth" wn "WordNet (r) 2.0"
20:55:11 <lambdabot> Ruth
20:55:11 <lambdabot>      n 1: United States professional baseball player famous for
20:55:11 <lambdabot>           hitting home runs (1895-1948) [syn: {Babe Ruth}, {George
20:55:11 <lambdabot>           Herman Ruth}, {Sultan of Swat}]
20:55:13 <lambdabot> [9 @more lines]
20:55:29 <gwern> kamatsu: different, I think.
20:55:31 <copumpkin> kamatsu: different
20:55:39 <copumpkin> I thought it was Manx, but I guess those are the people there
20:55:44 <applicative_> but if it were vectors of length n, so to speak, the more familiar way of making lists monads would fail.
20:55:50 <ddarius> copumpkin: If you used streams, I believe it would be a monad.
20:55:53 <gwern> copumpkin: isn't Manx another island, a language, and a cat?
20:55:55 <aavogt> copumpkin: X-men
20:55:57 <copumpkin> applicative_: yeah
20:56:11 <gwern> copumpkin: wight is old english, so the dates would work out for the Wight in Isle of Wight to mean wight
20:56:30 <copumpkin> gwern: I think manx is still isle of man
20:56:37 <applicative_> so we deon't have an example of two monad instances for one functor.
20:57:09 <copumpkin> we do
20:57:16 <copumpkin> lists as sets
20:57:36 <copumpkin> could have the concat join or the diagonal join
20:57:43 <copumpkin> as far as I can tell
20:58:07 <aavogt> @quote two.*one
20:58:08 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
20:58:08 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
20:58:08 <lambdabot> he was one of the pugs de
20:58:33 <ezyang> "aw, I wanted to hear the end of that story"
20:58:40 <idnar> heh
20:58:49 <scutigera> recommendations on haskell gui packages (gtk2hs, grapefruit ui ?)
20:58:59 <aavogt> @quote two.*functors
20:58:59 <lambdabot> No quotes match. I am sorry.
20:59:02 * ddarius isn't sure how jeers turn technical.
20:59:14 <ezyang> "my lambda is bigger than your lambda"
21:00:02 <aavogt> @quote 2.*natural
21:00:03 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
21:00:16 <copumpkin> I own that domain, too
21:00:25 <aavogt> haha
21:00:44 <copumpkin> anyone wanna volunteer a good video for it?
21:00:48 <copumpkin> we'll need the same music
21:01:32 <aavogt> think of the categories
21:01:51 * dufflebunk wonders what makes a dive bar
21:02:03 <ddarius> @wn dive
21:02:04 <lambdabot> *** "dive" wn "WordNet (r) 2.0"
21:02:04 <lambdabot> dive
21:02:04 <lambdabot>      See {diva}
21:02:04 <lambdabot>      [also: {dove}]
21:02:04 <lambdabot>  
21:02:06 <lambdabot> [17 @more lines]
21:02:31 <dufflebunk> I assume there's no swimming pool with a diving board...
21:02:49 <ddarius> "a cheap disreputable nightclub or dance club"
21:03:07 <kamatsu> ah, i assumed it was one of those underground ones
21:03:13 <kamatsu> have to "dive down into the depths" to get in
21:03:28 <kamatsu> proves how social i am
21:03:45 <aavogt> metaphorical depths
21:04:10 <ddarius> Usually a dive is just a crappy bar.
21:04:13 <ddarius> or club.
21:04:29 <ddarius> Usually more club-like than pub-like.
21:04:37 <kamatsu> so, Moe's?
21:04:38 <kamatsu> oh
21:07:09 <SamB_XP> hmm ... Floes, maybe?
21:08:06 <glguy> copumpkin: does a diagonalizing list monad preserve the laws?
21:08:15 <copumpkin> glguy: only if you treat it as a set
21:08:44 <glguy> Oh, that's what I get for picking and choosing between which lines of chat I read
21:08:59 <copumpkin> and since concat seems to be a BFS
21:09:11 <copumpkin> I'd imagine DFS might work too
21:09:14 <copumpkin> but haven't thought it through
21:10:56 <tehYama> sorry to interrupt again, but is there anyone who can help me with partial applications?
21:11:13 <copumpkin> we'll only know when you tell us what your question is :)
21:11:30 <tehYama> ah, I see, I guess I'm just confused on the concept
21:11:51 <kamatsu> so, Haskell's type signatures look like a -> b -> c
21:11:57 <kamatsu> for functions
21:12:06 <kamatsu> so, this actually means a -> (b -> c)
21:12:26 <kamatsu> that is, a function that takes a, and returns a function that takes b and returns c.
21:12:49 <tehYama> ok, I understand that bit
21:13:02 <kamatsu> this means, I can partially apply, say, the (+) function
21:13:03 <copumpkin> tehYama: what specifically confuses you?
21:13:07 <kamatsu> @type (+)
21:13:08 <lambdabot> forall a. (Num a) => a -> a -> a
21:13:15 <kamatsu> @type (+ 1)
21:13:16 <lambdabot> forall a. (Num a) => a -> a
21:13:26 <kamatsu> @type (1 + 1)
21:13:27 <lambdabot> forall t. (Num t) => t
21:14:00 <kamatsu> so, i can, for example
21:14:07 <kamatsu> > map (+1) [2,3,4]
21:14:08 <lambdabot>   [3,4,5]
21:14:30 <tehYama> I have a function that is defined with a lambda expression, and I need to define it using partial applications (as per the exercise), which I think I'm getting caught up in the combining of concepts
21:14:43 <kamatsu> tell us the exercise
21:14:57 <solrize> is there basically no way to set up a globally accessible i/o action that uses some initialization, other than by making an IO (IO a), binding it inside main, and then threading it (maybe using StateT IO) through everything that might want to use it?
21:15:44 <jmcarthur> sounds reasonable to me
21:16:03 <tehYama> I have a function that takes a function and sums from 0 to n the given function: total :: (Int -> Int) -> (Int -> Int); total f = (\n -> sum (map f [0..n]))
21:16:08 <jmcarthur> there are other ways, but they are probably less type safe
21:16:09 <aavogt> solrize: you can pass the reference via -XImplicitParams, or also create the IORef as a global variable by unsafePerformIO (and noinline pragmas)
21:16:25 <tehYama> don't worry I'm not asking for you guys to do my hw for me, I'm just seriously lost
21:16:49 <scutigera> solrize: the answer whenever I've asked similar questions: are you sure that you are thinking about the solution in the "right way".  Often I'm not...
21:17:02 <kamatsu> tehYama: so you've been told to rewrite this using partial application?
21:17:07 <solrize> aavogt, thanks, i'm looking up implicitparams, unsafeperformio sounds a bit drastic
21:17:08 <tehYama> correct
21:17:08 <aavogt> @type \f n -> sum (map f [0..n])
21:17:09 <lambdabot> forall a a1. (Num a, Enum a, Num a1) => (a -> a1) -> a -> a1
21:17:16 <kmc> solrize, "global IORef" is considered one of the more standard uses of unsafePerformIO.  it's still disliked
21:17:24 <solrize> scutigera, it's possible i'm thinking of it the wrong way.
21:17:43 <solrize> kmc, hmm, maybe that makes it closer to ok ;)
21:17:59 <aavogt> implicit params get in the way of type signatures
21:18:14 <scutigera> solrize: I know I suffer from tunnel vision, I get on a solution track and don't think about other methods.  depends heavily on deadlines :-)
21:18:31 <aavogt> but it's really no different than having fancy typeclass constraints
21:18:33 <copumpkin> unsafeGlobalVariableDon'tForgetToNOINLINEMeKthxBai :: a -> IORef a
21:18:42 <kamatsu> @type swap (\n -> sum . flip map [0..n])
21:18:42 <lambdabot> Not in scope: `swap'
21:18:44 <solrize> copumpkin, lol
21:18:45 <kamatsu> oops
21:18:51 <kamatsu> @type flip (\n -> sum . flip map [0..n])
21:18:52 <lambdabot> forall a a1. (Num a, Num a1, Enum a1) => (a1 -> a) -> a1 -> a
21:19:03 <copumpkin> a name like that would be enough to discourage people from using it I think
21:19:09 <aavogt> @hackage reflection -- roughly the same as implicitparams
21:19:09 <lambdabot> http://hackage.haskell.org/package/reflection -- roughly the same as implicitparams
21:19:10 <kamatsu> > (flip (\n -> sum . flip map [0..n])) 5
21:19:11 <lambdabot>   No instance for (GHC.Num.Num (a1 -> a))
21:19:11 <lambdabot>    arising from the literal `5' at ...
21:19:14 <solrize> http://blog.patch-tag.com/2009/03/09/implicitparams-are-evil-thoughts-on-adapting-gitit/
21:19:19 <kamatsu> > (flip (\n -> sum . flip map [0..n])) (+1) 2
21:19:20 <lambdabot>   6
21:19:25 <copumpkin> aavogt: much cooler in my opinion
21:19:44 <kamatsu> tehYama: That has no trivial reduction to partial application
21:19:54 <kamatsu> tehYama: Was this the function specified in the exercise, or did you write that function earlier?
21:20:20 <tehYama> kamatsu: I wrote the function earlier as part of another exercise
21:20:26 <kamatsu> right
21:20:34 <kamatsu> it's probable they wanted you to write it another way
21:20:41 <tehYama> orly?
21:20:54 <kamatsu> because your example does not easily reduce to just partial application
21:20:55 <SamB_XP> perhaps "expected" is a better word
21:20:56 <scutigera> solrize: that's my experience.  I just buckle-down and start typing the extra params.  sometimes a strategic closure can help.
21:21:12 <kamatsu> although my example above uses partial application, it's quite awkward
21:21:20 <kamatsu> i.e flip (\n -> sum . flip map [0..n]))
21:21:28 <scutigera> @flip
21:21:28 * lambdabot slaps  with a slab of concrete
21:21:45 <SamB_XP> @smack
21:21:45 * lambdabot hits  with an assortment of kitchen utensils
21:21:47 <SamB_XP> @smack
21:21:47 * lambdabot clobbers  with an untyped language
21:21:55 <applicative_> ouch
21:22:00 <SamB_XP> poor
21:22:05 <scutigera> @type flip
21:22:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:22:28 <tehYama> kamatsu: the original exercise was as follows: Define a funtion total, total :: (Int -> Int) -> (Int -> Int), so that total f is the function which at value n gives the total, f 0 + f 1 + ... f n
21:22:31 <aavogt> @type asTypeIn
21:22:32 <lambdabot> forall a b. a -> (a -> b) -> a
21:22:33 <SamB_XP>  can't get lambdabot to leave her alone, can she?
21:23:43 <copumpkin> asTypeIn is awesome
21:23:50 <copumpkin> asTypeWhenAppliedTo is nice too
21:24:00 <copumpkin> since that's most of what I do
21:24:04 <idnar> @src asTypeWhenAppliedTo
21:24:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:24:08 <copumpkin> :P
21:24:16 <SamB_XP> @type asTypeWhenAppliedTo
21:24:17 <lambdabot> Not in scope: `asTypeWhenAppliedTo'
21:24:26 <scutigera> what's the b. notation ?
21:24:34 <copumpkin> @let f `asTypeWhenAppliedTo` x = f `asTypeIn` ($x)
21:24:35 <lambdabot>  Defined.
21:24:39 <copumpkin> :t asTypeWhenAppliedTo
21:24:40 <lambdabot> forall a b. (a -> b) -> a -> a -> b
21:24:54 <idnar> it's "forall a b.", that's just explicit universal quantification of a and b
21:25:10 <applicative_> scutigera, it's just a break in the sentence, like parentheses
21:25:27 <timmaxw> @src asTypeIn
21:25:28 <lambdabot> a `asTypeIn` f = a where _ = f a
21:25:28 <lambdabot> infixl 0 `asTypeIn`
21:25:36 <scutigera> oh right, should have paind attention to the type decl.
21:25:40 <aavogt> asTypeWhenYouMightAsWellUseScopedTypeVariablesToGetEverybodyElseToUnderstand
21:25:50 <copumpkin> lol
21:26:16 <scutigera> IknewAGuyWhoReallyUsedVariableNamesSpelledOutLikeThat
21:26:30 * copumpkin digs up the pathological hackage example
21:26:44 <scutigera> this oughta be good :-)
21:26:55 <kamatsu> sum (map (f $) [0..n])
21:27:00 <kamatsu> that's partial application
21:27:00 <scutigera> prolly not as good as  IO LOL cat
21:27:14 <copumpkin> fucking computer overheated, it'll have to wait
21:27:19 <copumpkin> unless someone else has it handy
21:27:24 <idnar> (f $) is just f, surely?
21:27:31 <ddarius> Yep.
21:27:33 <kamatsu> idnar: er, yes
21:27:35 <aavogt> it has a different type
21:27:40 <scutigera> copumpkin: just put more water in the radiator
21:27:45 <ddarius> Anyway, map f x is already "using partial application."
21:27:46 <copumpkin> scutigera: :(
21:27:46 <aavogt> @type (?f $)
21:27:47 <lambdabot> forall a b. (?f::a -> b) => a -> b
21:27:51 <aavogt> @type (?f)
21:27:52 <lambdabot> forall t. (?f::t) => t
21:28:00 <aavogt> though by different I mean more specific
21:28:05 <ddarius> I highly suspect that tehYama is misreading/misunderstanding the question.
21:28:15 <tehYama> I agree with ddarius
21:28:16 <scutigera> copumpkin: bad overclocker..I'm not helping am I ?
21:28:29 <copumpkin> scutigera: it's a macbook air, nuff said :P
21:28:30 <idnar> well, it's the same type in that particular example anyhow
21:28:31 <copumpkin> first gen
21:28:52 <idnar> @type ?f `asTypeIn` map
21:28:53 <lambdabot> forall a b. (?f::a -> b) => a -> b
21:28:59 <idnar> @type (?f $) `asTypeIn` map
21:29:00 <lambdabot> forall a b. (?f::a -> b) => a -> b
21:29:54 <solrize> what's that ?f ?
21:30:12 <scutigera> @type $
21:30:13 <lambdabot> parse error on input `$'
21:30:23 <idnar> implicit parameter
21:30:39 <idnar> used here as a hack to easily be able to see the inferred type
21:30:59 <idnar> "undefined" would have worked just as well in this case
21:31:02 <solrize> all the gooble hits about implicitparameters point to java stuff
21:31:12 <aavogt> @type \f -> (f $ ) `asTypeIn` map
21:31:13 <lambdabot> forall a b. (a -> b) -> a -> b
21:31:25 <aavogt> solrize: -XImplicitParams.. check the ghc manual
21:31:25 <idnar> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
21:31:58 <solrize> found, thanks
21:33:41 <scutigera> is the forall a b. _required_, or is it just something to clarify ?
21:33:53 <SamB_XP> scutigera: clarify, here
21:33:58 <SamB_XP> since it's at the very front
21:34:02 <ddarius> scutigera: It's actually illegal in Haskell 98.
21:34:41 <scutigera> I see it a lot, obviously, but I'm confused as the whether it's actually needed ? Example ? :-)
21:35:14 <aavogt> the forall is needed to bring a type variable into scope for type signatures in subsequent bindings if you use -XScopedTypeVariables
21:35:16 <ddarius> scutigera: As I said, it is 1) never needed and 2) not even allowed in Haskell 98.
21:35:28 <ddarius> It is needed for some extensions, particularly for higher-rank types.
21:36:20 <aavogt> say you have    f :: x -> y -> z -> w; f ... = ... where g :: y -> w ....
21:36:22 <scutigera> ddarius: I missed the "never" part.
21:37:04 <aavogt> you can't write that signature for g if you want to refer to the specific types named in f
21:39:27 * idnar giggles
21:39:27 <scutigera> strange that lexically scoped type vars weren't part of 98 standard.  they don't seem like much of a stretch.
21:39:38 <idnar> I didn't know the GHC docs actually called it the "dreaded" monomorphism restriction
21:40:10 <scutigera> idnar: ran into that one after using haskell for all of a day
21:40:52 <idnar> I've seen people call it that plenty of times before, I just didn't know it was in the official docs :)
21:41:11 <aavogt> well is's not called that in the report
21:41:31 <tehYama> komatsu: I see what you are saying, could I have misunderstood to assignment?
21:42:01 <scutigera> anybody used fieldtrip ? would you recommend it to a friend ;-)
21:42:58 <dmwit> idnar: hehehe
21:43:07 <dmwit> scutigera: fieldtrip can be fun!
21:43:16 <dmwit> http://dmwit.com/menger/
21:43:59 <dmwit> scutigera: Also, you should tell me if reactive-fieldtrip builds cleanly now, so I can drop those instructions from the bottom of the page... =)
21:44:37 <scutigera> dmwit: a nice example - thank you kindly. checking on build...
21:45:29 <scutigera> ooooh.  openglraw looks like it's going to take a while...
21:48:41 <scutigera> dmwit: haskell gui preferences ?
21:49:25 <dmwit> vim for me
21:49:36 <dmwit> Others like emacs.
21:50:03 <Zao> dmwit: I assume he wants a GUI package, not editor recommendations.
21:50:07 <dmwit> oh
21:50:07 <scutigera> oh, I meant gtk2hs, wxHaskell...
21:50:11 <dmwit> heh, whoops
21:50:16 <dmwit> gtk2hs for me
21:50:20 <Zao> I use Win32, but I'm special.
21:50:36 <Veinor> yeah, you get to ride the short bus :D
21:50:38 <scutigera> wkhaskell probably works under win32, right ?
21:50:56 <dmwit> But that's mostly because it was the first one I tried... we all have a soft spot for our first language and our first GUI library.
21:51:05 <scutigera> wkhaskell devel seems to be slowing...
21:51:06 <dmwit> Both work under w32.
21:51:18 <scutigera> good to know.
21:51:22 <dmwit> hOpenGL works under w32, too.
21:51:25 <dmwit> ...I think.
21:51:35 <dmwit> So you should pick the one you're familiar with.
21:51:39 <Zao> gtk2hs is a pain to build on Windows, but as long as the stars align your GHC version with the one on the gtk2hs site, you're fine.
21:51:45 <scutigera> dmwit: if that's with accel, that's impressive.
21:52:09 <dmwit> Zao: No, it's easy, if you just remember not to put spaces in the path to GHC or to Gtk2Hs.
21:52:17 <dmwit> oh
21:52:19 <scutigera> yeah - most familiar with gtk, but hoping to use something more haskelly
21:52:22 <dmwit> just read
21:52:50 <Zao> dmwit: Assuming you _have_ a GTK lying around.
21:53:08 <dmwit> Zao: You can get installers for any of the old versions of gtk2hs...
21:53:12 <dmwit> http://sourceforge.net/projects/gtk2hs/files/
21:53:53 <dmwit> scutigera: If you want to dive into the "speculative" range, you might like the reactive GUI libraries.
21:54:05 <dmwit> reactive/tv/grapefruit/whatever
21:54:09 <dmwit> I can never keep the names straight.
21:54:37 <scutigera> dmwit: that's the problem. having problems differentiating. some look like they haven't been updated in a while.
21:55:03 <Zao> dmwit: I'm talking about GTK2 itself.
21:55:18 <scutigera> dmwit: not looking good fro reactive. might be a missing -dev.
21:55:21 <Zao> And building it with an unsupported compiler, say 6.12.1
21:55:43 <Zao> Surely gtk2hs doesn't bundle all of GTK2 with the source package?
21:55:55 <scutigera> dmwit: and it was, continuing.
21:55:56 <dmwit> I doubt it very much.
21:56:25 <Zao> I had great fun building gtk2hs myself when 6.10 was new. GREAT FUN :)
21:56:30 <scutigera> src/FRP/Reactive/GLUT/SimpleGL.hs:112:44:
21:56:30 <scutigera>     Couldn't match expected type `GLsizei'
21:56:35 <dmwit> I will defer to your greater experience and admit that installing gtk2hs is hard on Windows.
21:56:50 <scutigera> Zao: fun my *ss
22:00:43 <scutigera> dmwit: built reactive-glut lately ? did it complete for you ?
22:01:00 <dmwit> About a year ago, I guess.
22:01:12 <dmwit> ...not really a top priority for me right now, either.
22:01:14 <dmwit> (sorry)
22:01:46 <scutigera> well, I'll see if Conal can help...
22:03:01 <scutigera> how do you keep the "partial build" around in cabal if it fails ? It seems to clear it out.
22:05:41 <dmwit> scutigera: The tar is in there, you just have to do it manually.
22:06:16 <scutigera> dmwit: a ok.  so untar and execute cabal in the dir ?
22:07:01 <dmwit> right
22:07:08 <dmwit> "cabal configure && cabal build && cabal install"
22:07:42 <scutigera> oh, I would have gone straght to the last one.  that wouldn't have worke too well...
22:08:14 <copumpkin> jmcarthur: it seems like the AI could be made significantly simpler (and faster) by first preprocessing and breaking the board into rectangles
22:08:25 <dmwit> scutigera: It should actually work just fine. =)
22:08:31 <dmwit> scutigera: I'm just an idiot.
22:10:04 <scutigera> I'm at line 112 now.  it's a lovely line of code, except for that error thing of course.
22:13:07 <scutigera> dmwit: looks like the glut lib may have changed rel to reactive..
22:13:28 <dmwit> =/
22:14:06 <scutigera> well, maybe the author will leave a bug fix in my e-mail for tomorrow.
22:14:24 <scutigera> dmwit: thanks for the menger link.  that'll really help. later.
22:16:49 <dufflebunk> Does parsec have to put the entire result of parsing into memory, or can it operate lazily?
22:18:29 <aavogt> parsec can stream
22:19:04 <copumpkin> it isn't lazy though
22:20:44 <aavogt> copumpkin: what do you mean by that? You don't have to consume the whole input to generate some output
22:21:49 <dufflebunk> By lazy I mean that if you only look at the first thing in a list that the parser creates, it won't parse the entire file (for example parsing a csv file into [[String]] like in the book)
22:21:57 <copumpkin> dufflebunk: no
22:22:10 <copumpkin> aavogt: I mean it needs to produce the entire output at once
22:22:39 <dmwit> You can write lazy parsers (in the sense dufflebunk gives), but it's harder.
22:22:56 <copumpkin> not with parsec though?
22:23:02 <dmwit> I think with parsec, no?
22:23:03 <copumpkin> something like uu parsing lib
22:23:15 <copumpkin> dmwit: the Either in the result of parse makes it hard
22:23:25 <copumpkin> it needs to know whether to give you a Left or a Right before it can give you anything
22:23:31 <dmwit> When you've read the first CSV value, you getInput (or whatever it's called) and return.
22:24:11 <dmwit> Yeah, getInput.
22:25:12 <copumpkin> hm
22:25:27 * copumpkin doesn't see how getInput helps
22:26:11 <copumpkin> http://snapplr.com/ymd9 all seem to put results in Either
22:26:26 <dmwit> parse many times
22:26:27 <dmwit> e.g.
22:26:29 <copumpkin> oh, yeah
22:26:33 <copumpkin> then definitely
22:26:38 <dmwit> yeah
22:27:00 <dmwit> do { record <- csvLine; rest <- getInput; return (csvLine, rest) }
22:27:17 <copumpkin> makes sense
22:27:22 <copumpkin> but parsec itself is not being lazy
22:27:28 <dmwit> right
22:27:39 <copumpkin> whereas I think uu can be lazy itself
22:27:42 <dibblego> how does one get I from (S, K)?
22:27:44 <copumpkin> so you'd just talk about many line
22:27:49 <copumpkin> S K K I think
22:27:54 * copumpkin figures it out
22:27:56 <dmwit> SK(anything you like goes here)
22:28:13 <copumpkin> :t ap const const
22:28:14 <lambdabot> forall b. b -> b
22:28:19 <copumpkin> :t ap const
22:28:20 <lambdabot> forall b a. (b -> a) -> b -> b
22:28:25 <dufflebunk> So if I don't want to keep the 5 GB of records in memory, I should use the uu parser?
22:28:25 <dibblego> ah yeah ta
22:28:35 <copumpkin> dufflebunk: or just do what dmwit suggested
22:28:51 <Hunner> what's the ghci command to tell what library something comes from?
22:29:00 <copumpkin> :i
22:29:03 <dmwit> :i, but you must already have the library imported
22:29:06 <Hunner> thanks
22:29:06 <dmwit> In here, you can use
22:29:11 <dmwit> ?index intercalate
22:29:11 <lambdabot> bzzt
22:29:16 <dmwit> sigh
22:29:29 * Hunner just uses hoogle if it's not imported
22:29:36 <idnar> @hoogle intercalate
22:29:36 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
22:29:37 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
22:29:37 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
22:29:41 <dibblego> @type ap const ap
22:29:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m (a -> b)
22:29:59 <idnar> @unpl ap const ap
22:30:00 <lambdabot> ((\ a _ -> a) >>= \ c -> (\ k l -> k >>= \ i -> l >>= \ h -> return (i h)) >>= \ b -> return (c b))
22:30:11 <dibblego> @type ap const 7
22:30:12 <lambdabot> forall b a. (Num (b -> a)) => b -> b
22:30:27 <idnar> heh
22:30:31 <copumpkin> I think it needs to be S K K :)
22:30:44 <dmwit> nope
22:30:47 <dmwit> It needs to be untyped.
22:30:51 <copumpkin> ah, fair enough
22:31:16 <dibblego> ah that clears it up, cheers
22:31:30 <dmwit> Sfgx = fx(gx)
22:31:32 <dmwit> so
22:31:40 <idnar> @. pl unpl ap const ap
22:31:41 <lambdabot> ((. ((. (return .)) . (>>=))) . (>>=) >>=) . (return .) =<< const
22:31:41 <dmwit> SK?x = Kx(?x)
22:31:51 <dmwit> The (?x), in Haskell, means ? has to have a function type.
22:32:00 <dmwit> But that's a meaningless requirement in SKI-calculus.
22:33:52 <dmwit> As an even weirder point, it's usually not even true that (SKK = I), although for any particular x (SKKx = Ix).
22:33:53 <dufflebunk> Why is parsec more popular than uulib?
22:34:24 <copumpkin> dmwit: :O
22:36:39 <Gracenotes> dufflebunk: because it does it on the first date
22:37:19 <dmwit> ?remember Gracenotes <dufflebunk> Why is parsec more popular than uulib? <Gracenotes> because it does it on the first date
22:37:19 <lambdabot> It is stored.
22:38:40 <Gracenotes> uulib doesn't seem to have much documentation
22:39:01 <dufflebunk> no, it doesn't, I was just looking for some
22:41:02 <c_wraith> I'm a fan of uu-parsinglib.  Which isn't the same as uulib.
22:41:25 <c_wraith> Same people, but uu-parsinglib is higher-level.  I think.
22:41:38 <dmwit> uu-parsinglib: New version of the Utrecht University parser combinator library
22:41:38 <dmwit> nice
22:42:00 <dmwit> What does "stable, but evolving" mean?
22:42:03 <dmwit> "unstable"?
22:42:14 <c_wraith> It means "no known bugs, but we're still working on the design"
22:42:41 <dmwit> oh, huh
22:42:45 <c_wraith> I wonder if they've released a new version since I last talked to them.  I convinced him to break the pEnd combinator into two parts.
22:42:48 <ddarius> dmwit: Parsec is older than the UU library and is also more readily at hand.
22:43:01 <ddarius> er dufflebunk
22:47:29 <dufflebunk> c_wraith: are there simple examples of it anywhere?
22:49:12 <c_wraith> dufflebunk: not really.  parsec is much more accessible, from a documentation standpoint.  But it is pretty simple.  I just played with it until I figured out all the basics.
22:50:36 <c_wraith> Let me see if I can whip up a really simple example that you can start from
22:52:19 <dufflebunk> something simple that turns a csv file into [[String]] like the book would be ideal, since that's sort of what I need to do.
22:53:02 <dmwit> csv is not simple
22:53:18 <c_wraith> I can fake it by ignoring quoted strings :)
22:53:29 <dufflebunk> simple csv, ignoring double quoting and commas in fields
22:53:32 <xerox> ?hackage bytestring-csv
22:53:33 <lambdabot> http://hackage.haskell.org/package/bytestring-csv
22:54:13 <xerox> there's also csv which uses Strings
22:54:37 <dmwit> That's not going to suit dufflebunk.
22:54:41 <dmwit> It has to hold everything in memory.
22:55:17 <dmwit> Though I guess lexCSV looks pretty good.
22:56:37 <dufflebunk> Yeah, that's problem 1, and the second problem is the format I'm reading isn't exactly csv, it's line based and pipe delimited. Third reason is that I want to learn to use these parser combinators a little.
22:57:35 <dmwit> I wish edwardk would release his monoid parsing library.
22:57:44 <dmwit> It seems like it would be ideal for this kind of thing.
23:11:24 <dmwit> dufflebunk: So, to address your problems (in case you haven't decided on an approach yet), I'd make the following concrete recommendation.
23:11:46 <dmwit> Map a Parsec parser over an unlines'd version of the file.
23:11:54 <dmwit> You'll get a (lazy) list of Eithers.
23:12:09 <dmwit> You'll get to support your custom format.
23:12:34 <dmwit> And you'll get to use some parsing combinators for a pretty small language.
23:14:43 <dufflebunk> That would work, the lines aren't more than a few kB.
23:27:10 <c_wraith> @where paste
23:27:11 <lambdabot> http://hpaste.org/new
23:27:24 <c_wraith> liar.  hpaste is dead.  where's the moonpatio url?
23:27:46 <c_wraith> ...  dead the exact same way
23:28:13 <c_wraith> has someone decided to kill all hpaste instances?
23:30:04 <c_wraith> dufflebunk: The formatting here is ugly.  But at least it's semi-alive
23:30:08 <c_wraith> dufflebunk: http://pastebin.com/m7253c245
23:30:36 <c_wraith> dufflebunk: I recommend saving that, loading it in ghci, and feeding each of those test strings into runCSV
23:30:47 <c_wraith> dufflebunk: and then playing with it a lot more, obviously
23:31:03 <revertTS> what does ! do in data declarations?  eg. data XState = XState { window :: !Window, ...}
23:31:07 <revertTS> I'm having trouble finding docs on it :/
23:31:19 <c_wraith> revertTS: it makes that argument to the constructor strict
23:31:54 <revertTS> ohh, okay; thanks
23:37:53 <dufflebunk> c_wraith: Thanks
23:39:27 <dufflebunk> that doesn't look too bad
23:52:57 <ricree> odd, why would I get a non exhaustive pattern error with a function that looked like "foo _" =
23:53:24 <copumpkin> ricree: can we see more?
23:53:30 <Axman6> if you paste the code we can tell you :)
23:54:16 <ablmf> I am reading the wiki page about how to generate prime numbers by haskell.  The example code uses a module "Data.ListOrd" but I can not find it in ghci.
23:54:24 <copumpkin> OrdList?
23:54:24 <ablmf> Does that module exist?
23:54:30 <copumpkin> or Data.List.Ordered
23:54:40 <copumpkin> @hackage data-ordlist
23:54:41 <ricree> http://pastebin.com/m65fe85cf
23:54:41 <lambdabot> http://hackage.haskell.org/package/data-ordlist
23:55:03 <copumpkin> ricree: and the error?
23:55:25 <ablmf> So the module changed its name but the wiki page is not updated ? http://www.haskell.org/haskellwiki/Prime_numbers#Merged_Multiples_Removal_Sieve
23:55:26 <ricree> ./errorcheck "(symbol->string 12 12)"
23:55:26 <ricree> errorcheck: par1.hs:(242,0)-(243,74): Non-exhaustive patterns in function atomToString
23:55:59 <ricree> It's with the  http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Error_Checking_and_Exceptions tutorial, if that helps at all
23:57:49 <copumpkin> you don't need the val@( ) btw
23:58:02 <Axman6> yeah, i was just about to say that
23:58:10 * Axman6 glares at copumpkin 
23:58:14 <copumpkin> :)
23:58:36 <ricree> I was having trouble getting it to work without it, though I can't remember the exact problem I was having
23:58:48 <ricree> I don't need it in both cases?
23:58:49 <copumpkin> the only thing that does is add a val binding
23:58:55 <copumpkin> so if you use something called val, you need it
23:58:56 <Axman6> you don't need it at all
23:59:00 <copumpkin> otherwise not :)
23:59:09 <copumpkin> and either way, you don't need the extra parentheses
23:59:36 <copumpkin> that won't fix your non-exhaustive pattern warning
23:59:41 <copumpkin> but I'm not sure why it's doing it in the first place
23:59:41 <ricree> ah, I see
23:59:44 <copumpkin> what version of GHC?
