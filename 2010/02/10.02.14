00:00:15 <Hunner> no, just MyType
00:00:35 * Hunner didn't understand what your were saying until now
00:00:36 <ezyang> huh?
00:01:32 <ski>   newtype YourType = YT [[MyType]]
00:02:07 <ski> @vixen is that your type?
00:02:08 <lambdabot> yeah, it is
00:02:28 <Hunner> ski: yep, did that now. That's spiffy
00:25:18 <mjrosenb> does anyone know of a function IO a -> IO a
00:25:27 <idnar> id?
00:25:27 <dmwit> :t id
00:25:28 <lambdabot> forall a. a -> a
00:25:36 <dmwit> :t join (>>)
00:25:37 <mjrosenb> that memoizes the result of the computation
00:25:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
00:25:41 <dmwit> oh
00:25:55 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
00:26:44 <mjrosenb> dmwit: yes, but that attpempts to not use IO
00:26:52 <dmwit> yep!
00:26:52 <mjrosenb> dmwit: i ratther explicitly want IO.
00:27:26 <dmwit> I see no reason the same trick couldn't be used in IO.
00:27:44 <dmwit> or...
00:27:54 <dmwit> I see, you don't want to memoize a function.
00:27:59 <dmwit> Well, then it should be pretty easy.
00:28:08 <idnar> uhm
00:28:30 <dmwit> or...
00:28:42 <dmwit> Heh, this is neat. What a subtle question. =)
00:29:18 <dmwit> Okay, yes, after some very hard thought, the problem is indeed easy. =)
00:30:15 <dmwit> Is it okay to make it IO a -> IO (IO a)?
00:30:24 <idnar> yeah, I was going to say
00:30:33 <mjrosenb> dmwit: yeah, i'm trying to use MVar (IO a)
00:30:37 <mjrosenb> that updates itself
00:30:42 <idnar> that would be liftM return then
00:30:55 <dmwit> idnar: But that doesn't memoize at all.
00:31:13 <dmwit> mjrosenb: Oh, do you need an MVar? How but just an IORef?
00:31:25 <idnar> well, maybe I misunderstood what was meant by memoize
00:31:33 <idnar> but the inner IO action there doesn't perform any work, it just returns the result
00:31:42 <mjrosenb> dmwit: either one should work
00:32:25 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20418#a20418
00:33:38 <dmwit> Seems to work, too.
00:33:46 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20418#a20419
00:35:11 <dmwit> liftM return seems to work, too
00:35:17 <dmwit> I don't think I understand that.
00:35:45 <mjrosenb> wait, memo ma = liftM (return a); works?
00:35:47 <dmwit> Although with slightly different semantics: liftM return runs the IO at binding time, but memo runs the IO the first time the result is bound.
00:35:55 <dmwit> mjrosenb: believe it or not, yes!
00:35:58 <idnar> you run the IO action, and then you get the result
00:36:12 <idnar> then from that result, you create an IO action that does nothing but return the value
00:36:13 <dmwit> Yes, now I understand it.
00:36:14 <dmwit> Very clever!
00:36:18 <dmwit> idnar++
00:37:29 <dmwit> Oh, I see. It's because this "memoization" is really pretty stupid.
00:37:44 <dmwit> You might as well just pass around the actual "a" rather than wrapping it in another layer of IO.
00:37:49 <cizra> newtype Symbol = Symbol Char -- but now I want to pass an instance of Symbol into a function which accepts Char. How could I convert it?
00:37:59 <idnar> dmwit: the input IO action could be something like getLine
00:38:00 <dmwit> cizra: pattern matching
00:38:05 <cizra> dmwit: Right!
00:38:15 <dmwit> cizra: The other common solution is
00:38:22 <idnar> but yeah
00:38:24 <dmwit> newtype Symbol = Symbol { unSymbol :: Char }
00:38:31 <mjrosenb> cizra: newtype Symbol = Symbol efb
00:38:42 <cizra> dmwit: yay! works
00:39:05 <cizra> mjrosenb: efb?
00:41:07 <mjrosenb> cizra: http://www.urbandictionary.com/define.php?term=e%3Af%2Cb
00:41:30 <dmwit> heh
00:43:34 <cizra> hehe
00:45:13 <mjrosenb> memo ma = liftM (return ma); seems to not do what i want
00:45:29 <dmwit> mjrosenb: no
00:45:33 <dmwit> mjrosenb: liftM return ma
00:45:49 <dmwit> If you really want parentheses, it would be memo ma = (liftM return) ma
00:45:57 <idnar> or just memo = liftM return
00:46:04 <dmwit> right =)
00:46:32 <dmwit> :t liftM . return
00:46:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => r -> m a1 -> m r
00:47:34 <dmwit> :t (<*)
00:47:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
00:47:42 <dmwit> :t (<$)
00:47:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
00:47:59 <dmwit> (<$) = liftM . return -- ?
00:48:37 <idnar> :t fmap . return
00:48:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
00:48:54 <dmwit> :t fmap . const -- really
00:48:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
00:48:57 <mjrosenb> it looks like it is still performing the IO every time
00:49:13 <dmwit> mjrosenb: I don't believe you.
00:49:15 <dmwit> ?hpaste
00:49:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
00:49:36 <dmwit> mjrosenb: (It works here with getLine -- it only asks for input once even if I use it many times.)
00:50:56 <mjrosenb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20433#a20433
00:51:15 <dmwit> mjrosenb: try
00:51:21 <dmwit> y <- memo (putStrLn "hey" >> return 5)
00:51:23 <dmwit> y
00:51:23 <dmwit> y
00:51:41 <dmwit> (You'll probably still need the type annotation, though.)
00:52:20 <mjrosenb> hrmm.
00:52:27 <dmwit> better, eh?
00:52:58 <dmwit> May I ask why you want this?
00:53:03 <dmwit> It's very strange.
00:53:47 <dmwit> i.e. why would you do
00:53:50 <mjrosenb> i want an easy way to make sure i do not perform IO more often than i need to
00:53:58 <mjrosenb> such as reading from a file, etc.
00:54:14 <dmwit> do { y <- memo foo; bar y; baz y }
00:54:16 <dmwit> instead of just
00:54:23 <dmwit> do { y <- foo; bar y; baz y }
00:54:41 <dmwit> (noting that bar and baz would have slightly different types here, of course)
00:56:27 <QC_OK> I don't see the major fuss over haskell. C has function pointers, so you can pass functions into functions. Also it seems mostly to just be recursion.
00:56:37 <QC_OK> (and C can return functions
00:56:47 <mjrosenb> QC_OK: uh-huh.
00:56:51 <dmwit> Closures are very messy in C.
00:57:04 <QC_OK> Clo-sure?
00:57:05 <QC_OK> what is that?
00:57:20 <dmwit> QC_OK: In Haskell, you can partially apply functions.
00:57:31 <dmwit> QC_OK: So, (+1) is the function that adds one to a number.
00:57:38 <dmwit> QC_OK: We say it "closes" over the value 1.
00:57:56 <QC_OK> uhuh...
00:58:07 <dmwit> QC_OK: For comparison, imagine writing some functions in C.
00:58:09 <dmwit> The first is
00:58:18 <dmwit> int plus(int x, int y) { return x + y; }
00:58:24 <dmwit> Now you want to write a function
00:58:52 <dmwit> IntFunction closeBinary(IntIntFunction f, int x);
00:59:17 <dmwit> Where "IntFunction" and "IntIntFunction" are type aliases (forget what they're called in C) for function pointers to functions that take one and two arguments, respectively.
00:59:22 <dmwit> How would you do that?
00:59:24 <dmwit> It's not so easy.
00:59:52 <Twey> … and that's a restricted problem domain to start with, as examples in C usually have to be…
01:00:03 <dmwit> yes indeed
01:01:43 <mjrosenb> dmwit: typedef.
01:01:46 <dmwit> closeBinary(plus, 1)(41); /* the meaning of liff */
01:01:51 <Twey> Yeah, they're called typedefs
01:01:54 <dmwit> mjrosenb: I'm not listening! lalalala
01:01:56 <Twey> dmwit: Hehe
01:04:12 <idnar> haha
01:07:11 <ski> @type \ma -> mdo ref <- Data.IORef.newIORef (do a <- ma; Data.IORef.writeIORef ref (return a); return a); Data.IORef.readIORef ref
01:07:12 <lambdabot> forall b. IO b -> IO (IO b)
01:11:20 <mjrosenb> and using join to get rid of the extra IO is a bad idea, right?
01:11:33 <mjrosenb> ski: that looks about like what i was expecting
01:11:52 <dmwit> mjrosenb: oh yes, you'll lose the property you want if you join
01:12:02 <ski> yes, since running the "outer" `IO' layer is what creates the shared cell
01:12:38 <ski> er s/yes, since//
01:13:05 * ski wonders whether one can use `unsafeInterleaveIO' somewhere here
01:13:59 <ski> hm .. though possibly that's not desired in your case
01:14:24 <dolio> liftM (return . unsafeInterleaveIO)
01:14:36 <ski> @hoogle (IORef a -> a) -> IO a
01:14:36 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
01:15:41 <k23z__> given a function written in a iterative language ,  would it be possible in principle, to write something that would transform the recursive calls in iterative calls using a stack
01:16:03 <k23z__> so, to transform the code to use an internal stack and transform all recursive calls to stack and related operations ?
01:16:10 <ski> what is an "iterative language" ?
01:16:11 <Twey> Sure
01:16:14 <dmwit> Of course.
01:16:15 <Twey> That's what every compiler does anyway
01:16:16 <dmwit> GHC does this every day.
01:16:33 <Twey> x86 code doesn't have a concept of functions
01:16:59 <bob-E> has pointer arithmetic
01:17:13 <k23z__> s/iterative language/procedural language/
01:17:15 <k23z__> sorry about that
01:17:45 <ski> (i was wondering if you maybe meant a language with no recursion support)
01:17:56 <Twey> I assumed so
01:18:44 <bob-E> doesnt x86 assembly code have recursion support, popping/pushing stack + registers ?
01:18:55 <ski> (so, in that case, there would be no recursive calls to transform to iterative calls .. so i guess it would be possible in principle to write such a transformer .. vacuously :)
01:19:56 * ski knows 6502 and 680x0 does, anyway ..
01:19:59 <dolio> My bad, it's 'liftM return . unsafeInterleaveIO'.
01:21:06 <Sogekingu> Hi, when pattern matching how do you get get haskell to correctly differentiate between ''' and '\''?
01:21:25 <Twey> Er, ''' is not valid syntax
01:21:33 <Twey> I don't understand the question
01:21:43 <Twey> '\'' is the character literal for an apostrophe
01:21:49 <dmwit> > ("'", "\'", "\\'")
01:21:49 <Twey> ''' is a compiler error
01:21:50 <lambdabot>   ("'","'","\\'")
01:22:02 * dmwit is not sure whether he is helping or confusing
01:22:03 <Twey> > return '\''
01:22:04 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
01:22:04 <lambdabot>    arising from a use of...
01:22:08 <Twey> Ack
01:22:15 <Twey> > (: []) '\''
01:22:16 <lambdabot>   "'"
01:22:19 <Twey> > (: []) '''
01:22:20 <lambdabot>   <no location info>:
01:22:20 <lambdabot>      lexical error in string/character literal at chara...
01:22:32 <Sogekingu> -_-'
01:22:53 <Sogekingu> let me rephrase, I have a string which I am tryin to correctly apply pattern matching
01:22:56 <ski> @. read run concat ["'", "\'", "\\'"]
01:22:57 <lambdabot>  ''\'
01:23:11 <dmwit> ski: err, wait
01:23:12 <dmwit> what?
01:23:21 <Twey> That's bacwards :þ
01:23:24 <Sogekingu> where I need to identify that " ''' " is different from " '\'' "
01:23:24 <Twey> Sogekingu: Right
01:23:31 <Twey> Okay then
01:23:39 <dmwit> ?read "''\'"
01:23:39 <lambdabot>  '''
01:23:41 <ski> dmwit : i'm not sure what your original triple was was about, so ..
01:24:14 <Twey> > let f " ''' " = True; f " '\\'' " = False in (f " ''' ", f " '\\'' ")
01:24:15 <lambdabot>   (True,False)
01:24:18 <dmwit> ski: My original triple was to show the difference between ', \', and \\'
01:24:46 <dmwit> ski: And demonstrate a place where ' and \' might reasonably be thought to be both valid and different, but in fact are not.
01:25:10 <Sogekingu> Twey what you did there is interesting.
01:25:12 <ski> dmwit : well, it only output the same as the input (modulo whitespace) .. so i'm not sure it elucidated that much
01:25:35 <ski> (dmwit : but ok)
01:25:37 <dmwit> ski: Er, no, it swallowed some backslashes.
01:25:55 <ski> oh .. right
01:25:56 <Twey> Sogekingu: How so?
01:26:06 <Twey> Sogekingu: \\ is a backslash literal in strings, as in C-like languages
01:26:18 <Sogekingu> Twey I am haskell newb so didnt know "let" worked like that
01:26:34 <Twey> Sogekingu: How did you think it worked?
01:26:50 <Sogekingu> I didnt.
01:27:10 <ski> Sogekingu : note that the `>' lambdabot prompt only accepts expressions .. in a haskell module, you'd probably write `f' as a separate definition
01:27:32 <Twey> *nod*
01:27:39 <Sogekingu> but even when I had a line such as ('\'' : '\\' : '\'' : '\'' : xs) <-- that still wouldnt pick up the back slash
01:27:56 <Twey> Sogekingu: It would
01:28:26 <Sogekingu> right, but it was still picking up ''' as valid.
01:28:41 <ski> > case "'\\''foo" of '\'' : '\\' : '\'' : '\'' : xs -> xs; _ -> "foo !"
01:28:41 <lambdabot>   "foo"
01:28:49 <Twey> > let f ('\'' : '\\' : '\'' : '\'' : _) = True; f _ = False in (f "'''", f "'\\''")
01:28:50 <lambdabot>   (False,True)
01:29:19 <Twey> Sogekingu: You did something wrong
01:29:38 <Sogekingu> I figured :)
01:29:57 <Sogekingu> no problemo, back to the drawing board.
01:30:05 <Sogekingu> cheers for the help.
01:30:32 <Twey> You could post the code at hpaste.org, and we could have a look
01:30:57 <ski> > let f ('\'' : '\\' : '\'' : '\'' : xs) = Just xs; f _ = Nothing in f `graph` ["'''","'\\''"]
01:30:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
01:30:58 <lambdabot>         against inferred ty...
01:31:00 <Twey> Or you could just go back to the drawing board, I guess.  Your choice.  ☺
01:31:13 <Sogekingu> hmm I may have to take you up on the offer Twey, but first id like to try some things :)
01:31:20 <Twey> Right-ho
01:31:44 <ski> > let f ('\'' : '\\' : '\'' : '\'' : xs) = Just xs; f _ = Nothing in (f `graph`) `map` ["'''","'\\''"]
01:31:45 <lambdabot>   [("'''",Nothing),("'\\''",Just "")]
01:40:56 <gio123> ski: hi
01:56:34 <dmwit> Well, I guess it's about time I joined haskell-cafe anyway.
02:02:49 <mjrosenb> how do i prevent a definition from being exported?
02:02:59 <dmwit> Don't put it in the export list.
02:03:09 <mjrosenb> ok
02:03:19 <mjrosenb> how do i make an export list?
02:03:30 <dmwit> module Foo (a, b, c) where
02:03:36 <dmwit> (at the top of the file)
02:03:52 <mjrosenb> awesome
02:07:15 <bolmar> @type graph
02:07:16 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
03:02:17 <ben_h> hi all
03:03:13 <opdolio> > (-1/99)^(-1/99)
03:03:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:03:14 <lambdabot>    `GHC.Real.Fractional b'
03:03:14 <lambdabot> ...
03:03:20 <opdolio> > (-1/99)**(-1/99)
03:03:21 <lambdabot>   NaN
03:03:30 <opdolio> > (-1/99)**(-1/99) :: Complex Double
03:03:31 <lambdabot>   1.0469820291729695 :+ 3.323530876461664e-2
03:03:50 <opdolio> > 0 ** 0
03:03:51 <lambdabot>   1.0
03:14:37 <balor> I have a list of Ints and want to construct a list of Foo Int from them.  Can I just "map (Foo) xs"? i.e. is "data Foo a = ..." a function?
03:22:26 <RayNbow> balor: if there is a "Foo a" in the "..." of "data Foo a = ...", yes
03:22:48 <balor> RayNbow: thanks
03:22:55 <RayNbow> > map Just [1..5]   -- data Maybe a = Nothing | Just a
03:22:55 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
03:25:10 <cebewee> @type Just
03:25:12 <lambdabot> forall a. a -> Maybe a
03:26:34 <Cale> balor: When you have  data T a = C1 a | C2 ... | ...
03:27:07 <Cale> balor: The T is naming something at the type level, and is in a separate namespace from the C1, C2, etc. which are all at the value level.
03:27:52 <Cale> In types with only one constructor though, it's fairly common to see the data constructor named the same thing as the type constructor.
03:28:49 <lep-delete> quick question: [] is a type constructor like Just, isn't it
03:28:54 <lep-delete> ?
03:28:59 <Cale> Just is a data constructor
03:29:05 <Cale> Maybe is a type constructor
03:29:14 <Cale> [] the empty list is a data constructor
03:29:24 <Cale> [] the brackets which go around a type is a type constructor
03:29:48 <lep-delete> oh, ok
03:29:54 <int-e> > 1:[] :: [] Int
03:29:55 <lambdabot>   [1]
03:30:30 <int-e> (that is equivalent to [1] :: [Int])
03:31:39 <lep-delete> but how do i use [] like Just? something like 'let test f x = f x in test Just 3'
03:32:09 <Cale> > let f 0 = []; f n = n : f (n-1) in f 10
03:32:09 <int-e> you can't, because [] takes no arguments. It works like Nothing in that regard
03:32:10 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:32:36 <int-e> (I mean [] the data constructor.)
03:32:47 <lep-delete> ahh, i think i got it
03:32:53 <int-e> ([] the type constructor is analogous to Maybe)
03:33:07 <int-e> analoguous.
03:34:31 <lep-delete> thanks :)
03:35:05 <ben> > map return [1..10] :: [[Int]]
03:35:06 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
03:35:14 <int-e> ah, the dictionary thinks I got it correct the first time.
03:36:10 <mreh> is fail implemented in different ways for different monads?
03:36:24 <dolio> Yes.
03:36:35 <mreh> > fail "Hello" :: Maybe String
03:36:36 <lambdabot>   Nothing
03:36:37 <Cale> I think if you were going to stick another letter in there, it would be "analogious", but yeah, you did. :)
03:36:39 <mreh> woop
03:36:47 <RayNbow> > fail "World" :: [Int]
03:36:48 <lambdabot>   []
03:37:14 <mreh> > fail "Oh noes" :: Either String String
03:37:15 <lambdabot>   Left "Oh noes"
03:37:22 <Cale> mreh: They do, but many "implement" it with asynchronous exceptions that are difficult to catch.
03:37:27 <RayNbow> > fail "oh noes" :: (Int -> Int)
03:37:28 <lambdabot>   * Exception: oh noes
03:37:45 <Cale> Which is a good sign that fail shouldn't be in the Monad class, which it shouldn't :)
03:38:01 <ben> Asynchronous?
03:38:02 <mreh> but it generalises the exception handing quite nicely
03:38:07 <ben> Because it happens in pure code?
03:38:10 <Cale> yeah
03:38:11 <mreh> yeah? what did you mean by that?
03:38:13 <mreh> oh
03:39:24 <mreh> it doesn't happen in pure code though
03:39:25 <int-e> Cale: I was misled by "analogue".
03:39:44 <mreh> wait...
03:39:57 <Cale> int-e: Ah, I see :)
03:40:01 <b0fh_ua> Hello! Can somrbody please help me with regular expressions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20557#a20557 - when I rewrite regular expression as "^Message-ID\\s*:\\s*(.*)" - it matches just fine, but I don't need <> to be included.
03:40:55 <mreh> > fail "Halp!" :: IO ()
03:40:56 <lambdabot>   <IO ()>
03:41:08 <mreh> interesting
03:41:30 <Cale> In IO, it's implemented by throwing a proper IO exception.
03:42:59 <dolio> > error "" :: IO ()
03:43:00 <lambdabot>   <IO ()>
03:44:32 <Cale> b0fh_ua: hmm...
03:44:58 <Cale> b0fh_ua: I wonder if < is special for the syntax of the regular expressions that the TDFA module handles...
03:45:24 <ben> > fix fail :: String
03:45:25 <lambdabot>   ""
03:46:11 <Cale> > fix error
03:46:12 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
03:46:34 <{g}> Hey, anybody here who knows stuff about calculating a rotation matrix?
03:46:41 <Cale> sure
03:46:51 <{g}> Cale: I have a function that rotates a matrix and now i want to add horizontal flipping. I tried this, but it gives me strange results: m11*=Math.cos(0); m12*=Math.sin(0); m21*=Math.sin(0); m22*=-Math.cos(0);
03:46:57 <{g}> Cale: any idea?
03:47:16 <RayNbow> <Cale> > fix error  -- does this mean errors cannot be fixed? :p
03:47:41 <Cale> {g}: Just construct the matrix for the flip, and then multiply it by the matrix that does your rotation.
03:47:59 <{g}> Cale: thats what i did.
03:48:07 <{g}> Cale: so i guess my flip matrix is wrong?
03:48:26 <balor> {g}: Best way is to work out an example on paper first, then compare your result to it
03:48:33 <Cale> Uh, oh, is *= mutating multiplication?
03:48:35 <ben> Did you perform a matrix multiplication or component-wise multiplication?
03:48:41 <Cale> That's not how you multiply matrices.
03:48:53 <{g}> Cale: yes, it multiplies.
03:48:59 <{g}> Cale: how do you do it then?
03:49:24 <mreh> {g} there's a library called hmatrix that does these things for you
03:49:38 <ben> {g}: Consider http://de.wikipedia.org/wiki/Matrix_%28Mathematik%29#Matrizenmultiplikation
03:49:48 <{g}> let me see...
03:49:54 <Cale> http://en.wikipedia.org/wiki/Matrix_multiplication
03:49:59 <Cale> (in English :)
03:50:22 <{g}> woah what the fuck.. this is more complicated then i expected.
03:50:26 <Cale> I could explain, but Wikipedia probably does a better job with the colours and diagrams.
03:50:44 <int-e> it's just function composition *ducks*
03:50:52 <Cale> {g}: The reason is that you want the multiplication of matrices to correspond to the composite of the linear maps they represent.
03:51:40 <{g}> what i want to do is this:
03:51:45 <RayNbow> int-e: not only that... linear algebra uses juxtaposition for both composition and application! :p
03:51:50 <Cale> So you're forming linear combinations of the columns of the second matrix according to the rows of the first.
03:52:07 <{g}> m11=scale* Math.cos(rotation); m12=scale*-Math.sin(rotation); m21=scale* Math.sin(rotation); m22=scale* Math.cos(rotation);
03:52:14 <{g}> ^ this already works
03:52:15 <Cale> RayNbow: And without fear of ambiguity!
03:52:30 * {g} figured it out by trying blindly until it fucking worked :)
03:52:42 <int-e> RayNbow: not really - vectors are just functions from / to a one-dimensional vector space.
03:52:42 <{g}> but now i want to add horizontal flipping
03:52:47 <{g}> and im so stuck!
03:52:54 <ben> {g}: The rule for combining matrices is to multiply them according to the rules on wikipedia
03:53:23 <{g}> i wonder why i managed to get scale and rotation working without knowing a thing about matrices...
03:54:21 <RayNbow> int-e: but what would you consider as function application then?
03:54:53 <Cale> RayNbow: composition of linear maps, of course ;)
03:54:57 <int-e> RayNbow: you don't really need it. that's the beauty of it
03:56:02 <ziman> what is / ?
03:56:03 <int-e> RayNbow: whether 3 is a real number or a function multiplying everything by 3, as long as it's represented by 3, you don't have to care.
03:56:15 <isr> Hello everyone. Haskell newbie question coming up (sorry!). A very simple function: http://codepad.org/WL0j5QxN
03:57:02 <int-e> ziman: I meant "from or to"
03:57:21 <ben> @type (:)
03:57:22 <lambdabot> forall a. a -> [a] -> [a]
03:57:29 <isr> takes in [String], and returns a single String, with a "\n" seperating each member of the previous list
03:57:37 <ziman> int-e, oh, I see... :)
03:57:56 <RayNbow> int-e: ah, right :)
03:57:59 <ben> isr: You cannot use : there, : is for Char+String, you have Strings on both sides
03:58:15 <int-e> RayNbow: http://en.wikipedia.org/wiki/Cayley%27s_Theorem is a manifestation of that idea btw.
03:58:16 <isr> But that function only works if I use a Char, and not "\n". Help
03:58:56 <isr> ben: I thought : would split the first element of [String], giving me the first String ?
03:59:07 <ben> Yes, I mean on the right side of the =
03:59:48 <ben> > let process [] = [] ; process (a:as) = a ++ "\n" ++ process as in process ["foo", "bar", "baz"]
03:59:50 <lambdabot>   "foo\nbar\nbaz\n"
03:59:57 <isr> ben: oh darn it. I'm making a new list, aren't I. Dumb
03:59:58 <ben> > let process [] = [] ; process (a:as) = a ++ '\n':process as in process ["foo", "bar", "baz"]
03:59:59 <lambdabot>   "foo\nbar\nbaz\n"
04:00:52 <isr> ben: got it. Just replace ':' with '++'
04:00:58 <ziman> @pl \(x,y) -> (y,x)
04:00:58 <lambdabot> uncurry (flip (,))
04:01:00 <ben> isr: Or "\n" with '\n' :)
04:01:18 <ben> > let process = intercalate "\n" in process ["foo", "bar", "baz"]
04:01:19 <lambdabot>   "foo\nbar\nbaz"
04:02:58 <isr> ben: thanks. I was looking at the definition for unlines (which is also ::[String] -> String)
04:03:18 <RayNbow> int-e: hmm... I think I've seen that theorem in Awodey's CT book... (a book I still have to finish reading, with pen and paper to work out proofs)
04:03:20 <ben> > unlines []
04:03:21 <lambdabot>   ""
04:03:53 <ben> Oh, I thought that added a \n at the end too :)
04:04:09 <isr> ben: they use ':' there to make a list, but I wasn't looking carefully enough. Its appending '\n' (as you suggested), not "\n"
04:04:25 <isr> ben: I see my mistake now.
04:04:32 <isr> ben: :)
04:04:51 <ben> Note that it is equivalent to a ++ ('\n' : process as)
04:05:04 <ben> Not (a ++ '\n') : ... or anything funny like that :)
04:07:11 <balor> I have some incorrect syntax in this data constructor http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=20575#a20575 but I can't figure out where
04:07:42 <ben> "in" is a keyword
04:07:49 <balor> ghc gives me a "parse error on input `in'"
04:07:53 <balor> d'oh
04:08:03 <balor> I'm a n00b...can you tell?
04:09:54 <isr> ben: just so I understand myself. process (a:as) = (a ++ '\n'): process as     why wouldn't that work? Wouldn't (a++'\n') just return a single String, which is valid to use with ':' ?
04:10:17 <ben> ++ appends a list to another list, '\n' is not a list, so that would not work
04:10:28 <isr> ben: ah
04:10:30 <ben> : prepends a single Char to a list, the result of ++ is a String, so that would not work either
04:10:39 <ben> String = List of Chars here
04:12:50 <isr> I see, and   a ++ ('\n' : process as)   works because the char '\n' is being prepended to the following line (once the recursive call returns).
04:13:16 <ben> right
04:13:48 <isr> ben: thanks, got it :)
04:14:08 <isr> ben: off to make my next newbie mistake (shouldn't take long ...)
04:14:14 <ben> Good luck :)
04:18:47 * hackagebot upload: NonEmptyList 0.0.1 - A list with a length of at least one. (TonyMorris)
04:21:18 <RayNbow> hmm, now we have NonEmpty and NonEmptyList on hackage...
04:21:33 <cebewee> @hoogle NonEmpty
04:21:34 <lambdabot> No results found
04:39:19 <b0fh_ua> Cale: good point
04:39:33 <b0fh_ua> probably they do have some extensions for RE syntax
04:41:20 <b0fh_ua> Cale: http://hackage.haskell.org/packages/archive/regex-tdfa/1.1.2/doc/html/Text-Regex-TDFA.html they state that \< is beginning of a word
04:41:23 <b0fh_ua> strange
04:47:49 <nezumi> Hello, could somebody share a working example of a simple calculator with variable inputs written using Happy?
04:54:01 <Axman6> nezumi: could you be a little more specific please? (also, yhis sounds like homework to me)
04:54:59 <damd> b0fh_ua: fwiw the regex you pasted doesn't seem correct
04:55:28 <damd> you're grouping the trailing ">"
04:56:14 <nezumi> Axman6: I need to program simple calculator from Happy documentation using "let bla = bla in bla" throwing the result in integers.
04:56:56 <Axman6> can anyone explain to me what the point of GADTs are? i don't see how specifying a constructor as Foo :: X -> Bar is any clearer than data Bar = Foo X
04:57:08 <Axman6> am i missing something? (/me assumes so)
04:57:31 <opqdonut> Axman6: you can say stuff like "data Foo a where intcons :: Int -> Int -> Foo Int; nilcons :: Maybe String -> Foo ();" etc
04:57:42 <opqdonut> i.e. almost-dependent-typing
04:57:56 <b0fh_ua> damd: it doesn't work with "^Message-ID\\s*:\\s*<(.*)>" either
04:58:29 <opqdonut> Axman6: so basically you can have different constructors map to different "subtypes" of Foo
04:58:32 <Axman6> opqdonut: hmm, i'm not quite seeing a) whyat's going on there, and b) why it's advantageous
04:58:53 <damd> b0fh_ua: the way i would write that is "^Message-ID: <(.+)>$"
04:59:00 <opqdonut> Axman6: and also get the related type inference benefits: if you take in a Foo Int, you only need to pattern match on the constructors of Foo that could've produced a Foo Int
04:59:03 <b0fh_ua> damd: replacing TDFA with PCRE I've got it matched
04:59:40 <Axman6> opqdonut: got a more complete example perhaps?
04:59:41 <damd> b0fh_ua: i'm not sure but in emacs groups need to be "escaped", as "^Message-ID: <\\(.+\\)>$"
04:59:43 <opqdonut> Axman6: I presume you've read the examples on http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype ?
04:59:51 <Axman6> nope :)
04:59:57 <opqdonut> well they're pretty concrete :)
05:00:08 <Axman6> i just saw it used in a video, and was curious as to why you'd use it that way
05:00:15 <Axman6> thanks :)
05:00:19 <damd> b0fh_ua: from TDFA docs: "This package does not provide basic regular expressions. This package does not provide back references inside regular expressions. "
05:00:20 <b0fh_ua> damd: in fact it works well with ^Message-ID\\s*:\\s*(.*)$
05:00:43 <b0fh_ua> there is no back-references as far as I can see
05:01:02 <damd> "basic regular expressions"?
05:01:11 <b0fh_ua> not sure what did they mean with this
05:01:58 <Feuerbach1> What is the difference between parsec 2 and parsec 3?
05:02:00 <b0fh_ua> anyway it works well with PCRE except it's not clear how do I get content of matched group
05:02:57 <benmachine> Feuerbach1: in parsec3 the module is called Text.Parsec which is much easier to type
05:03:05 <benmachine> there are other differences as well
05:03:18 <benmachine> e.g. the introduction of the ParsecT monad transformer
05:03:41 <benmachine> I think parsec2 didn't support user-defined input streams
05:03:45 <benmachine> but parsec3 does
05:03:51 <Feuerbach1> benmachine: is there a changelog somewhere?
05:04:13 <Feuerbach1> or some comparison
05:04:25 <benmachine> not sure
05:05:27 <benmachine> I don't know of one
05:05:46 <benmachine> but there's no particular reason why I would
05:06:21 <Feuerbach1> benmachine: okay, thanks :) may be someone else can help
05:08:46 <benmachine> I think the monad transformer and the input stream generalisation are the main bits
05:08:59 <benmachine> btw, people have said parsec3 is slower than parsec2
05:09:13 <benmachine> I think someone wrote a patch to fix that but I don't think it's official yet
05:10:21 <b0fh_ua> http://hackage.haskell.org/packages/archive/regex-tdfa/1.1.2/doc/html/basic.html
05:10:25 <b0fh_ua> awesome
05:10:49 <b0fh_ua> so how should I know what did they mean with "basic" syntax? ;)
05:11:56 <FauxFaux> 404.
05:12:22 <b0fh_ua> exactly
05:13:13 <benmachine> there are (at least) two types of regex, basic and extended
05:13:17 <Cale> http://hackage.haskell.org/packages/archive/regex-tdfa/1.1.2/doc/html/Text-Regex-TDFA.html
05:13:19 <benmachine> perhaps that is what they were talking about
05:13:21 <b0fh_ua> lots of times I'm clicking on links in documentation in hackage I'm getting this. Of course if hackage website is up itself ;)
05:13:32 <Cale> oh, I see
05:14:11 <Cale> That link was an accident.
05:14:22 <Cale> This package does not provide "basic" regular expressions.  This package does not provide back references inside regular expressions.
05:14:27 <Cale> ^^ from the source code
05:14:37 <Cale> Haddock links doublequoted text.
05:14:46 <benmachine> silly haddock
05:15:47 <b0fh_ua> well, okay. Still need some help with regular expressions, in particular - how to extract matched group :)
05:16:06 <benmachine> the regex library iirc is crazy polymorphic in the return type
05:16:33 <benmachine> :t (=~)
05:16:35 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:16:40 <Cale> Yeah, you can pick an appropriate type and get a list of the matched groups, but are you really sure you want regexes?
05:17:12 <Cale> Parsing libraries like Parsec or ReadP are so much nicer to use.
05:17:20 <b0fh_ua> Cale: all what I want - take email message as text file, and extract few headers from it
05:17:42 <Axman6> sounds easier said than done
05:18:02 <b0fh_ua> if there's better way of doing that - please put some light on it :)
05:18:09 <benmachine> depends on what you mean by better
05:18:19 <benmachine> I think it'd be easy in parsec
05:18:29 <benmachine> probably more verbose but sometimes that's a good thing
05:18:31 <b0fh_ua> Cale: I've wrote some crazy code for that, the only problem is that I don't overcome regexps
05:19:33 * Twey overcomes regexes, with a lasso
05:21:35 <mreh> @hoogle Monad m => (a -> m [b]) -> [a] -> [b]
05:21:36 <lambdabot> No results found
05:21:53 <mreh> @djin Monad m => (a -> m [b]) -> [a] -> [b]
05:21:53 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
05:21:58 <mreh> @djinn Monad m => (a -> m [b]) -> [a] -> [b]
05:21:58 <lambdabot> Error: Undefined type []
05:22:10 <mreh> hmpf
05:22:17 <mreh> @hoogle concatMapM
05:22:17 <lambdabot> No results found
05:22:30 <mreh> @hoogle Monad m => (a -> m [b]) -> [a] -> m [b]
05:22:31 <lambdabot> No results found
05:22:41 <benmachine> concat <$> mapM?
05:22:51 <benmachine> :t \f xs -> concat <$> mapM f xs
05:22:52 <mreh> it doesn't like that
05:22:52 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
05:22:56 <mreh> oh
05:22:57 <benmachine> close enough
05:23:01 <mreh> what am I doing wrong
05:23:03 <medfly> pretty damn close
05:23:12 <mreh> I've got: concat `liftM` mapM ...
05:23:17 <osaunders> :t concatMapM
05:23:18 <lambdabot> Not in scope: `concatMapM'
05:23:20 <benmachine> :t \f xs -> concat `liftM` mapM f xs
05:23:21 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
05:23:31 <Cale> print . filter (not . null) . map (readP_to_S $ do string "Message-ID"; skipSpaces; char ':'; skipSpaces; char '<'; x <- many get; char '>'; return x) . lines =<< getContents
05:23:40 <benmachine> :t (liftM concat .) . mapM
05:23:41 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
05:23:51 <Cale> b0fh_ua: Try that code and see whether it looks anything like what you're after :)
05:24:00 <b0fh_ua> readFile "headers.dat" >>= return . lines >>= return . elem ( value hdr )
05:24:07 <Cale> b0fh_ua: Obviously, factoring it onto multiple lines would be better ;)
05:24:25 <b0fh_ua> Cale: thanks
05:24:29 <Cale> Oh, you'll need to import Text.ParserCombinators.ReadP
05:24:45 <b0fh_ua> Cale: thanks :)
05:24:53 <benmachine> Cale: by the way, I made a CGI script for the step evaluator
05:25:00 <benmachine> http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=let+foldr+%3D+%5Cf+z+xs+-%3E+case+xs+of%0D%0A+++++++++++++%5B%5D+-%3E+z%0D%0A+++++++++++++x%3Axs+-%3E+f+x+%28foldr+f+z+xs%29%0D%0A+in+foldr+%28%2B%29+0+%5B1%2C2%2C3%2C4%5D m-m-m-monster URL
05:25:20 <Cale> benmachine: Oh, cool :)
05:25:28 <Zeiris> > project (Vec3 1 1 1) (Vec3 1 0 0)
05:25:29 <lambdabot>   Not in scope: `project'Not in scope: data constructor `Vec3'Not in scope: d...
05:26:07 <benmachine> still not implemented funbinds though :(
05:27:02 <Zeiris> The projection of a vector over i/j/k unit vector should be the component on that axis, right?
05:27:19 <Cale> benmachine: Some of the steps are things which I'd normally consider syntactic things rather than actual evaluation steps, though it might be handy to have a mode like this where they're included.
05:27:22 <tensorpudding> that is what a projection means
05:27:35 <b0fh_ua> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20620#a20620 that's my terrible code. At least it compiles :) And I'm interested how can I rewrite line 22 there, among with suggestions about how to convert this smelling code into something more beautiful )
05:27:41 <benmachine> Cale: yeah, the thing you said about lists I agree with
05:27:46 <benmachine> but currently it's easier to do it like this
05:27:46 <Zeiris> I think I found a bug in Data.Vect.Float.Base :( project (Vec3 1 1 1) (Vec3 1 0 0) returns (Vec3 0 1 1)
05:28:14 <benmachine> the interesting thing about that evaluation linked is that it converts (+) 1 foldr ... to 1 + (\f z xs -> ... i.e. prefix to infix
05:28:19 <benmachine> and I don't remember coding that :P
05:28:31 * benmachine pokes around
05:29:14 <tensorpudding> @src project
05:29:14 <lambdabot> Source not found.
05:29:18 <benmachine> ohh yeah I do
05:29:31 <benmachine> this is due to the magic treatment of +
05:29:44 <benmachine> oh well works for me
05:29:46 <tensorpudding> ugh, there are like five packages with vector in the name
05:29:57 <Cale> b0fh_ua: Well, first of all, you're indenting if/then/else in a strange way. :)
05:30:04 <Cale> b0fh_ua: the usual way is
05:30:06 <Cale> if foo
05:30:08 <Cale>    then bar
05:30:11 <Cale>    else quux
05:30:34 <Cale> The 'then' and 'else' being part of the 'if' should start on a deeper column, and being siblings, they should line up.
05:30:37 <tensorpudding> hmm
05:30:53 <Cale> (The actual syntax lets you get away with more, of course)
05:31:20 <b0fh_ua> okay, fixed )
05:32:06 <benmachine> b0fh_ua: x >>= return . f is the same as fmap f x
05:32:25 <b0fh_ua> also lines 36-42 seems to relate with Maybe monad, but not sure
05:32:31 <benmachine> or if you import <$> from somewhere, f <$> x
05:32:37 <benmachine> further more
05:33:06 <benmachine> x >>= return . f >>= return . g = x >>= return . g . f = fmap (g. f) x
05:33:20 <tensorpudding> Zeiris: what does project' return on that?
05:33:23 <Zeiris> tensorpudding, http://hackage.haskell.org/packages/archive/vect/0.4.5/doc/html/src/Data-Vect-Float-Base.html#project
05:34:12 <RayNbow> hmm
05:34:21 <RayNbow> http://www.haskell.org/haskellwiki/The_Monad.Reader <-- where are the links to the older issues?
05:34:36 <Cale> b0fh_ua: Oh, you're just looking just for those two pieces of data, and all this State monad machinery to do it?
05:34:59 <Cale> (I think I just figured out what this program is actually doing ;)
05:35:20 <b0fh_ua> Cale: well, I still learning monads so trying to apply some :)
05:35:41 <Zeiris> tensorpudding, project' (Vec3 1 1 1) (mkNormal $ Vec3 1 0 0) still returns (Vec3 0 1 1)
05:36:01 <Cale> I suppose it's not entirely insane, but using the state monad just to do simple recursion over a list of lists is weird :)
05:36:06 <b0fh_ua> Cale: it takes a message and returns it's message id and message id of one it was sent in reply to
05:36:17 <Cale> right
05:36:29 <b0fh_ua> Cale: agree, but makes me to understand state a bit deeply :)
05:36:32 <RayNbow> hmm
05:36:53 <RayNbow> should I add a link to http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues on The_Monad.Reader wiki page?
05:37:34 <Cale> So first of all, let's write a function which takes a header name, and produces a ReadP parser to look for that header, and extract the appropriate value.
05:38:24 <benmachine> RayNbow: the main wiki page has a link to the website which has all the previous issues on it, so I'm not sure if there's any point
05:38:56 <Cale> In do-notation, that'll look like this:
05:39:07 <IceDane> Is there an easy way to convert an integer of seconds from epoch to a date in haskell
05:39:08 <Cale> headerVal name = do string name; skipSpaces; char ':'; skipSpaces; char '<'; xs <- many get; char '>'; return xs
05:39:10 <IceDane> ?
05:40:15 <Cale> hmm, ReadP doesn't seem to be an instance of Applicative
05:40:29 <b0fh_ua> Cale: well, some sort of voodoo )
05:40:33 <Cale> Irritating omission, but that's okay for now.
05:42:00 <RayNbow> benmachine: ah ok
05:43:17 <b0fh_ua> Cale: can you please suggest some tutorial where I can read more about ReadP and related stuff?
05:43:43 <Cale> IceDane: If you're using Data.Time, probably the best way is to use fromIntegral to convert it to a NominalDiffTime, and then add it to the epoch... but you'll have to create the epoch somehow.
05:43:51 <balor> given "data Foo = F { bar:: xs}" and I have an f, what's the syntax for getting the bar component?  f.bar or bar(f) or else?
05:43:57 <Cale> b0fh_ua: Sure... or I can help explain that code if you like
05:44:29 <b0fh_ua> I would appreciate explanations as well )
05:44:49 <Cale> b0fh_ua: Basically, the idea is that we're going to represent a parser which eats some text before producing a value of type t as a value of type ReadP t
05:45:24 <Cale> If it helps, you can think of a value of type ReadP t as a function from strings to lists of possible parses along with the corresponding depleted strings.
05:45:26 <b0fh_ua> so what the type 'headerVal' is of?
05:45:34 <Cale> ReadP String
05:45:51 <Cale> It parses some text and produces a portion of that text, if it matches at all.
05:45:55 <b0fh_ua> it takes String and produces ReadP String?
05:45:56 <doserj> balor: bar f
05:46:04 <balor> doserj: thanks
05:46:05 <Cale> Oh, sorry, yes
05:46:15 <Cale> Because it's taking the header to look for as a parameter
05:46:51 <b0fh_ua> Cale: it takes header line and results in the value of header, as far as I understand
05:47:00 <Cale> yeah
05:47:23 <Cale> So, we chain parsers together (concatenate them) using do-notation as you see there
05:47:46 <Cale> and we can capture the results of various bits of the parse and produce some result
05:48:29 <Cale> readP_to_S :: ReadP a -> String -> [(a, String)] -- this is how we apply a parser to a string
05:49:06 <Cale> The result is a list of pairs consisting of results, along with the remainder of the string which didn't get used in each case.
05:50:08 <burp> > (2^32+10) `mod` (2^32-1):: Word32
05:50:09 <lambdabot>   10
05:50:11 <burp> > (2^32+10) `mod` (2^32):: Word32
05:50:12 <lambdabot>   * Exception: divide by zero
05:50:16 <burp> why divide by zero?
05:50:27 <burp> oh never mind
05:50:34 <dschoepe> burp: because 2^32 doesn't fit in a Word32
05:50:57 <b0fh_ua> Cale: so in this case each line will be considered as header, and I don't see how can I exclude unwanted headers
05:51:31 <Cale> b0fh_ua: Well, that's what the 'name' parameter is.
05:51:47 <b0fh_ua> aha
05:51:49 <burp> yes, modulo 2^32 works automatically :>
05:51:55 <burp> > (2^32+10) :: Word32
05:51:56 <lambdabot>   10
05:51:58 <burp> just what I wanted ;)
05:52:00 <b0fh_ua> Parses and returns the specified string.
05:52:01 <b0fh_ua> really
05:52:16 <Cale> b0fh_ua: right :)
05:52:23 <b0fh_ua> so if that string doesn't match - it doesn't evaluate the rest of expression?
05:52:26 <Cale> right
05:52:30 <b0fh_ua> awesome
05:52:38 <Cale> The result of the parse will be an empty list of possibilities
05:53:27 <b0fh_ua> otherwise there will be at least one tuple, where the fst value is String of parsed header value
05:53:38 <b0fh_ua> so looks like I can return my own type from there?
05:54:29 <benmachine> haskell-src-exts has data Name = Ident String | Symbol String
05:54:53 <benmachine> I found myself wondering yesterday if there is actually any reason why there would be separate Ident/Symbol constructors
05:55:10 <Cale> b0fh_ua: yeah, you can use case to match on the result.
05:55:16 <benmachine> you can always tell which one something is by its content, surely?
05:55:23 <Cale> b0fh_ua: But let's just suppose for a moment that we want to do this all in one pass.
05:55:38 <Cale> b0fh_ua: and extract a certain set of headers
05:55:53 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20632#a20632
05:55:53 <Cale> b0fh_ua: maybe it would be best to pair each header with its name in the result...
05:56:18 <Cale> Did you have trouble just importing ReadP unqualified?
05:56:31 <b0fh_ua> Cale: yes, it conflicts with State
05:56:36 <Cale> ah, get, yes.
05:56:39 * ksf wonders whether he should make iteratees a typeclass and make my parser type an instance of it
05:56:46 <Cale> Well, you won't need the state monad soon enough :)
05:56:54 <ksf> actually, I'm wondering whether that'll work.
05:57:30 <Cale> b0fh_ua: Let's say we want to find either the Message-ID field or In-Reply-To
05:57:43 <b0fh_ua> Cale: I know, I could just do a function and pass Maybe MsgidHeader to it, and call it recursively
05:57:44 <Cale> b0fh_ua: and succeed in either case with a header, like you have there
05:57:54 <Cale> b0fh_ua: You can just use the +++ operator
05:58:01 <b0fh_ua> em
05:58:02 <Cale> To get a parser which parses either one.
05:58:19 <ksf> you start by figuring out how to match against "M" and "I" at the same time.
05:58:25 <Cale> (+++) :: ReadP  a -> ReadP  a -> ReadP  a
05:59:18 <Cale> x +++ y is the parser where if either x or y succeeds, the parse succeeds and produces the result that parser would have
05:59:39 <ksf> and if both succeed?
06:00:30 <Cale> all the results
06:01:28 <Cale> I guess a better way to say it is that the parser x +++ y has all the results that the parsers x and y have when parsing the same input.
06:01:44 <burp> > scanl (\x _ -> (1029*x + 221591) `mod` 1048576) 1 [1..]
06:01:45 <lambdabot>   [1,222620,708003,1044934,668277,12768,776951,689258,630697,140260,894219,77...
06:02:05 <Cale> b0fh_ua: So then you just apply this parser to each of the lines of your input, and you're done.
06:05:06 <b0fh_ua> 1 sec )
06:14:20 * hackagebot upload: joinlist 0.3.0 - Join list - symmetric list type (StephenTetley)
06:15:55 <b0fh_ua> Cale: it works
06:15:57 <b0fh_ua> awesome
06:16:29 <b0fh_ua> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20638#a20638
06:16:39 <b0fh_ua> still with State, but looks MUCH better now :)
06:19:41 <Cale> b0fh_ua: You could also separate the part where you apply the parser to each of the lines and collect the results from the one where you build up the MsgidChain value from the result.
06:20:16 <Cale> b0fh_ua: It would be simpler to have a function  [MsgidHeader] -> Maybe MsgidChain
06:20:42 <b0fh_ua> Cale: true, and I would get rid of state
06:20:48 <Cale> Probably, anyway
06:21:00 <Cale> You *could* keep state, but it'd be less necessary :)
06:21:11 <b0fh_ua> because I will have function String -> [MsgidHeader] and [MsgidHeader] -> Maybe MsgidChain
06:21:16 <Cale> yeah
06:21:26 <Zeiris> What IS the best 3D vector library on hackage, anyway? Has anyone tried mor ethan one?
06:21:31 <Cale> So the question is how to do that second part
06:22:11 <b0fh_ua> yes, pattern matching wouldn't work because order of headers is not specified
06:22:33 <b0fh_ua> may be I can sort them first, but it's not optimal
06:22:46 <Cale> b0fh_ua: But you know that you don't have many headers -- only a list of the ones you're after
06:23:11 <b0fh_ua> Cale: also, keep in mind that state stops to evaluate once all headers are found
06:23:42 <Cale> One way to do it would be to keep the CurrentState type and just write some useful operations on that.
06:23:49 <b0fh_ua> I could do something similar in String -> [MsgidHeader] with passing names
06:24:02 <Cale> though, you can drop the content field
06:24:27 <b0fh_ua> yeah
06:26:23 <Cale> combine (CurrentState x y) (CurrentState x' y') = CurrentState (x `mplus` x') (y `mplus y')
06:26:26 <Cale> er, typo
06:26:29 <Cale> combine (CurrentState x y) (CurrentState x' y') = CurrentState (x `mplus` x') (y `mplus` y')
06:26:46 <Cale> What does this do?
06:26:57 <Cale> It takes two bits of partial information and combines them
06:27:10 <Cale> > Nothing `mplus` (Just 6)
06:27:12 <lambdabot>   Just 6
06:27:15 <Cale> > Nothing `mplus` Nothing
06:27:16 <lambdabot>   Nothing
06:27:28 <Cale> > Just 3 `mplus` Nothing
06:27:29 <lambdabot>   Just 3
06:27:33 <burp> > map ((/2^64) . fromIntegral ) (drop 1 $ scanl (\x _ -> (6364136223846793005*x + 1442695040888963407)) 1 [1..] :: [Word64])
06:27:34 <lambdabot>   [0.42320917087271326,0.5094074428837206,0.6483593939634306,0.38286339050826...
06:27:38 <Cale> > Just 3 `mplus` Just 6
06:27:39 <lambdabot>   Just 3
06:27:45 <Cale> (it's biased to the left)
06:28:15 <burp> I assume there is a speed benefit of Word64 on 64bit platforms?
06:28:31 <Cale> So then you just need the function which takes a MsgidHeader, and produces the appropriate CurrentState value just for that one header.
06:28:35 <burp> and ghc doesn't kind of emulate it on 64bit as it probably does on 32bit
06:29:07 <Cale> and then you can just   foldr combine empty   over the list of matched headers
06:29:18 <Cale> Oh, and empty = CurrentState Nothing Nothing
06:29:36 <Cale> This idea of having a combining function and an empty value is common enough that there's a typeclass for it.
06:29:39 <b0fh_ua> hmm
06:29:56 <Cale> It's called Monoid, after the corresponding structure in mathematics
06:30:22 <Cale> (technically, you want it to be associative, and for the empty value to be an identity for the combining operation, which we satisfy here)
06:30:25 <Cale> So
06:30:32 <Cale> instance Monoid CurrentState where
06:30:36 <b0fh_ua> I'm lost :)
06:30:41 <Cale>   mempty = CurrentState Nothing Nothing
06:30:54 <Cale>   mappend (CurrentState x y) (CurrentState x' y') = CurrentState (x `mplus` x') (y `mplus` y')
06:31:11 <Cale> oh, btw, I'm assuming that CurrentState now has only two fields
06:31:22 <Cale> Just the msgId and the inReplyTo
06:31:32 <b0fh_ua> that's true, but it may change
06:31:43 <Cale> Yeah, you'll have to change the instance in that case
06:31:55 <Cale> But it will be analogous to this :)
06:32:34 <Cale> So the idea is that  CurrentState  (which might deserve a better name, but I'm not sure what it would be) represents what is known about the headers
06:33:06 <Cale> mappend combines two partial bits of information
06:33:14 <b0fh_ua> Cale: as you may see, everything falls into Chain
06:33:25 <b0fh_ua> so may be CurrentState is not needed
06:33:27 <kingping> mOooin. Is this correct that after LL(k) parsing of e. g. JavaScript I would need to check semantics of parsed output? AssignmentExpression production from  http://www.ppd.clrc.ac.uk/Adye/jsspec11/llr.htm makes me think parser wouldn't figure out if parsed data is correct even if it passed syntax checking during parsing.
06:35:12 <Cale> b0fh_ua: Well, it works well to have a way to keep track of what you know as you go through the list of parsed headers.
06:35:27 <b0fh_ua> well
06:35:57 <Cale> and be able to check at the end that you actually got all the information you were looking for
06:35:59 <b0fh_ua> what if CurrentState will keep list of headers and flag whether it's complete?
06:36:26 <Cale> I think the current one is good, if you remove the content field
06:36:56 <Cale> It then represents the possibility that you've found each of the headers, along with the value that you found.
06:37:00 <b0fh_ua> Cale: in this way I will pass CurrentState and [String] to a function
06:37:07 <Cale> Not [String]
06:37:15 <Cale> MsgidHeader
06:38:04 <Cale> If you're given a MsgidHeader, you can determine a function CurrentState -> CurrentState which updates what you know. :)
06:38:30 <Cale> Or looked at another way, you can write a function of two parameters  MsgidHeader -> CurrentState -> CurrentState
06:38:51 <Cale> and that is the perfect sort of function to be passed into a foldr :)
06:39:20 <Cale> yeah?
06:39:52 <b0fh_ua> seems so
06:40:25 <Cale> So, if you had  update :: MsgidHeader -> CurrentState -> CurrentState, and empty :: CurrentState  (the one with all Nothings)
06:40:47 <Cale> then  foldr update empty :: [MsgidHeader] -> CurrentState
06:41:11 <Cale> Oh, another possibility
06:41:17 <ksf> kingping, I think it's easier to convince everyone on the internet to switch to another language than js than implementing it correctly.
06:41:21 <Cale> Use a Data.Map, along with union
06:41:37 <Cale> If you're afraid that you'll have lots of headers you're interested in later
06:41:44 <Cale> a  Map String String  would be ideal
06:42:06 <Cale> (from header name to value)
06:42:21 <ksf> gmap can handle string indices really good
06:42:54 <ksf> ...branching by the ord instance isn't exactly efficient.
06:43:01 <Cale> hm?
06:43:27 <ksf> you want a trie, not a binary tree.
06:43:56 <kingping> ksf: I'm just doing it as my yearly essay :> Sure, I wouldn't do such things with imperative languages.
06:43:58 <Cale> bah, that's just a constant factor :P
06:44:05 <ksf> ...so you're left with either bytestring-trie, or gmap, which, among others, has the perfect map instance for lists of anything.
06:44:37 <Cale> actually, tries can be worse than ordering comparison
06:45:03 <Cale> In the case that you have long strings but sparsely distributed.
06:45:35 <kingping> ksf: And even if everything seems correct with e. g. 'a = b = c = d = i' one has to be sure i was defined before a,b,c,d..
06:45:36 <Cale> (so that you can tell the ordering without looking at the whole strings)
06:45:52 <Cale> In his case, all these solutions are sort of overkill anyway
06:46:00 <ksf> kingping, always remember that js is dynamic
06:46:04 <Cale> since there's only two keys for now :P
06:46:27 <ksf> the spec even says that implementations should'nt error out on code they can statically guarantee to be faulty
06:46:27 <Cale> and the keys are email headers, so there's not ever going to be more than a dozen or so
06:46:52 <kingping> ksf: I mean if i appears there first time, than this assignment is incorrect.
06:47:10 <ksf> exactly. don't worry it until you evaluate.
06:47:27 <kingping> ksf: I'm just translating js to perl.
06:47:37 <b0fh_ua> Cale: my global task is to create something, which will be able to check if some email is a reply on another one
06:47:42 <ksf> well then don't worry at all.
06:48:00 <kingping> ksf: Thanks Flying Sphagetti Monster I haven't to evaluate it.
06:48:19 <ksf> js code reserves the right to be faulty, at least if it's never evaluated.
06:48:48 <ksf> ...so, maybe after dead code elimination you MAY spew out a warning.
06:48:52 <kingping> ksf: I'm just wondering if I'm thinking in right direction that parser can't guarantee 100% that code is correct.
06:48:52 <b0fh_ua> so if I post something to mailing list, and get reply, and if all mail for mailing list comes into separate folder (using procmail) - I will be able to get carbon copy to my inbox
06:49:40 <ksf> not even haskell can do that
06:49:53 <kingping> ksf: I see. Thanks. :]
06:49:58 <ksf> c I think can (or rather, must) inspect the scope while parsing
06:50:03 <kingping> Doing this in Erlang.
06:50:20 <ksf> ...because it has to know whether something is a type or binding etc.
06:50:30 <ksf> ...which gives raise to all sorts of forward declarations
06:50:42 <b0fh_ua> headers.dat: openFile: resource busy (file is locked)
06:50:55 <kingping> ksf: Yep, http://javascript.crockford.com/tdop/tdop.html describes another method, it performs scope checking too.
06:50:55 <b0fh_ua> nice, who may lock the file?
06:51:27 <ksf> those times of "one-pass compilation" are very, very over.
06:52:20 <ksf> kingping, don't you want to implement a scheme instead or such?
06:52:22 <ksf> or maybe forth.
06:52:36 <ksf> js is an adomination.
06:53:03 <gwern> js is an acceptable scheme?
06:53:43 <p_l> gwern: except for the syntax
06:53:45 <ksf> If my scheme were better and I knew what I was talking about, I'd slap you around with a spiky lambda.
06:55:04 <kingping> ksf: Indeed. But when I was deciding as to what to translate I thought some imperative languages would be easier. I thought js->perl is easier than list->erlang or so..
06:55:40 <kingping> s/list/lisp/
06:56:03 <ksf> I'd say a functional language is easier to implement, always. implementing it so it runs fast is another matter.
06:56:40 <ksf> at least a dynamically type funlang
06:56:43 <Twey> I would agree
06:57:05 <kingping> ksf: Well, it may be correct. I haven't considered functional langs translation. Just using functional approach to make the task of translation.
06:57:14 <ksf> to do a lisp, you need a parser, a gc, and a simple eval function.
06:57:20 <b0fh_ua> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20662#a20662 - for some reason I am getting the error: "headers.dat: openFile: resource busy (file is locked)", which happens only if "exists" returns True. Doesn't it close file?
06:57:33 <ksf> ...that is, lisp interpreters start at about 200 lines c or so.
06:57:57 <kingping> Funny. Some day I'll learn lisp.
06:58:36 <ksf> it's faster to learn lisp than read the ecmascript spec, once.
06:59:04 <paulvisschers> I'm having a problem with the function randomIO, it doesn't terminate
06:59:05 <Twey> s/lisp/Scheme/
06:59:12 <paulvisschers> anyone know what's wrong here?
06:59:16 <Twey> paulvisschers: What are you trying to generate?
06:59:25 <ksf> paulvisschers, codepad.org
07:00:07 <paulvisschers> I've tried a newtype around Word64 for which I had a custom instance, but I've also tried with Ints and Bools and the same thing happens
07:00:17 <kingping> My teacher at uni says we should learn declarative languages first, but it's the other way.
07:01:05 <ksf> you _do_ learn declerative languages first.
07:01:09 <ksf> algebra, that is.
07:01:13 <kingping> Dijkstra also said imperative langs kill programmer's brain irreversibly.
07:01:50 <kingping> ksf: But even formulae are then implemented in C and co.
07:02:13 <paulvisschers> ksf: http://codepad.org/2PEgw4wf it seems to work there though
07:02:47 <Twey> OS?
07:03:00 <kingping> ksf: I noticed no one uses declarative paradigm in my city.
07:03:35 <kingping> Besides 1-2 teachers, but it often limited to some specific cases.
07:05:39 <paulvisschers> Twey, ksf: Thanks guys but I got the problem, Bool and Int worked fine in the interpreter unless I tried them after the Word64 one, that one didn't terminate and caused any further randomIO calls to not terminate as well, so my instance is wrong and I need to fix it
07:06:34 <Twey> Interesting… how did you manage to enter new ones if it didn't terminate?
07:08:44 <paulvisschers> Twey: Control-C
07:09:03 <Twey> But that should kill it completely
07:09:11 <Twey> You might want to report a bug on that
07:09:15 <paulvisschers> You'd think so
07:10:01 <paulvisschers> It also doesn't kill opened threads I believe until you kill ghci, not sure if that's a bug or a feature
07:11:21 <paulvisschers> I also don't really understand why my implementation of the instance doesn't work, I basically generate an Integer between Word64's min and maxBound and then cast to Word64
07:11:59 <Twey> I think that's a feature
07:12:07 <Twey> Post code
07:12:19 <paulvisschers> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=20673#a20673
07:13:20 <paulvisschers> OMG how did I not see that :O
07:13:34 <paulvisschers> I forgot to add primes to the g
07:13:34 <Twey> Yeah, infinite loop
07:13:40 <Twey> ☺
07:14:20 <babusrini> Can someone translate this to English: "gmapQ :: (forall d. Data d => d -> u) -> a -> [u]"
07:14:44 <paulvisschers> Twey: Thanks for your help
07:16:12 <paulvisschers> Twey: I actually just spend many hours rewritten all sorts of database and MonadPlus code to fix this (the MonadPlus code actually did have an error, but still)
07:18:03 <Twey> babusrini: gmapQ is a function that takes a function that takes a value of any type implementing Data and returns a u, and returns a function that takes a value of any type and returns a list of that earlier type u
07:18:17 <Berengal> gemapcue colon colon openparen forall dee dot data dee equals pointy-right dee arrow right yew close paren arrow right ay arrow right list of yew
07:18:47 <Twey> Hehe
07:18:58 <int-e> babusrini: what Twey said. Note that a is an instance of Data as well, because the declaration stems from the Data a type class declaration.
07:19:19 <Twey> Oh, that makes more sense
07:19:58 <Twey> babusrini: gmapQ is a function that takes a function that takes a value of any type implementing Data and returns a u, and returns a function that takes a value of the Data type we're currently specifying and returns a list of that earlier type u
07:22:14 <babusrini> twey, int-e thanks. Is there a need for "forall d"? I rememeber reading that we don't need to specify forall as it is implied.
07:22:59 <int-e> gmapQ toConstr (1 :: Int, (), Just True) --> [1,(),Just]
07:23:52 <int-e> babusrini: The key is that that forall is local to the argument - the function you pass must work for all instances of Data. This is rank 2 polymorphism, actually.
07:24:47 <int-e> (In my example, toConstr is used for an Int, the unit (()), and a Maybe Bool value.)
07:27:23 <babusrini> int-e, ok, thanks.
07:29:31 <Asztal> there are some examples of gmapQ usage in http://hackage.haskell.org/packages/archive/syb/0.1.0.3/doc/html/src/Data-Generics-Schemes.html#gsize
07:34:01 <burp> has anyone used Data.Histogram? I don't understand how to create the histogram // get the binned data
07:39:52 <gwern> oh noes
07:40:03 <gwern> dmwit's wyvern pages lies to me - 'git clone http://dmwit.com/wyvern/.git' doesn't work
07:40:31 <gwern> preflex: seen dmwit
07:40:31 <preflex>  dmwit was last seen on #haskell 5 hours, 36 minutes and 55 seconds ago, saying: (at the top of the file)
07:40:44 <FauxFaux> He's probably failed at the fact that git is horrid to use over http.
07:41:29 <gwern> there goes git
07:41:33 <gwern> good ol git!
07:41:36 <gwern> I hate it *so* much!
07:41:44 <damd> what's wrong with git?
07:42:07 <FauxFaux> damd: fatal: http://dmwit.com/wyvern/.git//info/refs?service=git-upload-pack not found: did you run git update-server-info on the server?
07:42:13 <FauxFaux> That's what's wrong.
07:42:33 <gwern> dmwit: your wyvern git information is wrong! or your server is tek br0ke! or something. fix it plox
07:42:48 <FauxFaux> (See above)
07:44:54 <FauxFaux> gwern: http://git.goeswhere.com/?p=wyvern.git;a=summary git://git.goeswhere.com/git/wyvern.git etc. =p  (wget --mirror forever)
07:45:49 <gwern> FauxFaux: ew
07:46:09 <gwern> but I suppose it doesn't matter. encoding bombs out on 6.12 so I can't even install wyvern's deps
08:28:43 <ville> Some dude called Bahrain seems to thinks it's a great idea to PRIVMSG people with some advertizement when they join this channel.
08:32:25 <b0fh_ua> So can somebody please help me with this issue about reading and writing to the same file? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20662#a20726
08:32:44 <Twey> ville: It probably is
08:32:56 <Twey> They'll get lots of views before someone bans 'em
08:33:13 <Twey> Heffalump: Get it?
08:33:18 <Heffalump> nope
08:33:35 <Twey> Nope
08:35:46 <maltem> b0fh_ua, what's the problem?
08:36:35 <maltem> b0fh_ua, do you want to read the file contents, then write different contents to the file?
08:37:01 <b0fh_ua> maltem: I want to check if the string occurs in file, and if yes - then append another string to the end of file
08:38:27 <maltem> b0fh_ua, and the problem is exactly what? That it does not work?
08:38:50 <doserj> b0fh_ua: the problem is using lazy io
08:39:02 <maltem> From a quick glance, you should probably make sure that you close the file handle and reopen it before you write to the file
08:39:25 <maltem> (Prelude.readFile does not do that and that's why it's inappropriate to use here)
08:39:44 <b0fh_ua> maltem: the problem is "headers.dat: openFile: resource busy (file is locked)
08:40:26 <maltem> Ok. I guess you'll be better off with withFile
08:40:45 <b0fh_ua> i will need to use hGetContents
08:41:21 <maltem> yup
08:42:38 <b0fh_ua> what if I use ByteString instead?
08:42:53 <b0fh_ua> readFile will read entire content in memory?
08:44:13 <maltem> If you use strict ByteStrings, yes
08:47:17 <MissPiggy> "Computer science is a young discipline, but it already shows signs of senility. There is an obsession with correctness which often prevents the practitioners from understanding the finitary dynamics of computation"
08:47:48 <MissPiggy> "In this paper, we yeild to this obsession. Our implementations are all correct." XD
08:48:10 <platzhirsch> Hey, why doesnt he find the where a value? http://codepad.org/5VJn2qPk
08:48:31 <MissPiggy> platzhirsch, where is only for a single equation
08:48:37 <platzhirsch> ouch
08:48:46 <MissPiggy> yeah, sometimes it's good sometimes bad...
08:48:48 <platzhirsch> thx =)
08:49:18 <benmachine> you can make it a single equation and use case on the first argument
08:49:25 <benmachine> and then the where is shared
08:49:44 <platzhirsch> true
08:49:49 <MissPiggy> hey benmachine have you had any more thuoghts about this step reduction stuff?
08:49:57 <benmachine> no
08:50:01 <benmachine> well, a few
08:50:21 <benmachine> but I spent a long time on it yesterday so I'm kind of inclined to let it lie for a bit :P
08:50:48 <MissPiggy> I'm reading about using graph reduction (with sharing) to evaluate these terms
08:51:39 <benmachine> the thing I like about my direct approach is that it ensures the transformations you make are logical in a sense
08:52:13 <MissPiggy> in what sense are they logical
08:52:14 <doserj> platzhirsch: inv [] m = [] ; inv (x:xs) m = (x,a):inv ... where a = ... would also work, wouldn't it?
08:52:31 <benmachine> I think I am trying to emulate how someone would evaluate the expression by hand
08:53:07 <MissPiggy> benmachine, how would you eval    let double = \x -> x + x in double (double 3)   by hand?
08:53:26 <benmachine> that is a good question
08:53:42 * MissPiggy hasn't been able to answer it for myself
08:53:52 <benmachine> I think a reasonable way of doing it would be
08:54:04 <benmachine> let double = \x -> x + x in (\x -> x + x) (double 3)
08:54:12 <benmachine> let double = \x -> x + x in let x = double 3 in x + x
08:54:24 <benmachine> let double = \x -> x + x in let x = (\x -> x + x) 3 in x + x
08:54:30 <benmachine> let double = \x -> x + x in let x = 3 + 3 in x + x
08:54:35 <benmachine> let double = \x -> x + x in let x = 6 in x + x
08:54:44 <benmachine> 6 + 6
08:54:46 <benmachine> 12
08:54:48 <MissPiggy> ah!!! that's so simple in retrospect but I didn't think of it :))))
08:55:05 <benmachine> (should've dropped the let double = a bit sooner but that's inconsequential)
08:55:13 * MissPiggy feels stupid for trying to reduce it to  double (3 + 3)  first
08:55:18 <benmachine> with complex lambdas you end up making a lot of redundant let bindings
08:55:28 <pikhq> benmachine: So you're a terrible garbage collector.
08:55:29 <pikhq> :P
08:55:29 <benmachine> so there's a trick in working out what does and doesn't need to be shared
08:55:46 <benmachine> pikhq: p much
08:55:46 <MissPiggy> and yeah you can just prime the x a few times if it's clashing
08:55:50 <benmachine> yes
08:55:53 <MissPiggy> nice
08:56:00 <benmachine> although in one test case I got up to x''''
08:56:15 <benmachine> soo there might be better ways of doing that
08:56:30 <benmachine> the current alpha conversion is buggy, but in an implementation rather than a conceptual way
09:05:14 <b0fh_ua> what is the best way of converting String to ByteString and visa versa?
09:05:56 <sjanssen> b0fh_ua: Data.ByteString.Char8.{pack,unpack}
09:06:07 <sjanssen> but one should avoid that conversion as much as possible
09:07:19 <b0fh_ua> sjanssen: I am using Text.ParserCombinators.ReadP, which seems to work only with Strings
09:08:20 * hackagebot upload: cgi 3001.1.7.2 - A library for writing CGI programs (MaxBolingbroke)
09:09:11 <benmachine> parsec does bytestrings
09:16:56 <b0fh_ua> looks like there is nothing like 'lines' for Data.ByteString
09:20:09 <MissPiggy> I don't understand what 'left most outermost first' means in the context of graph reduction
09:20:21 <MissPiggy> it's meant to be the same as lambda calculus but doesn't make sense :|
09:21:28 <Veinor> so it is the same as lambda calculus!
09:21:42 <MissPiggy> hmmmmmm
09:22:07 <MissPiggy> so I ujst start at the top and then do breadth first or something
09:22:35 <MissPiggy> I don't get it...
09:23:08 <MissPiggy> Veinor: it's "depth first" but if you find something you can reduce on the way down - do that?
09:24:35 <doserj> http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Graph_Reduction
09:26:21 <MissPiggy> okay I think I get it now :)
09:26:22 <MissPiggy> thanks
09:28:16 <MissPiggy> benmachine http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html#need-journal
09:33:29 <MissPiggy> how do you make this in haskell ? http://img134.imageshack.us/img134/606/picture4jd.png
09:33:32 <MissPiggy> as a data structure
09:34:01 * benmachine saves to his folder of things to read
09:34:19 <benmachine> good find, thanks
09:38:27 <MissPiggy> I guess the only way I can do this is like a mutable doubly linked list
09:38:34 <MissPiggy> except that it's a network rather than a list
09:39:12 <benmachine> not sure I really understand the diagram
09:40:01 <benmachine> but doubly linked lists are interesting
09:40:32 <benmachine> http://haskell.org/haskellwiki/Tying_the_knot has some stuff about making them
09:42:39 <WaRlOc|> i'm having problems printing unicode characters on the screen with ghc (hugs works, but i need a faster compiled version).... can anyone help me please?
09:43:20 <Zao> WaRlOc|: What GHC version?
09:44:05 <WaRlOc|> Zao: 6.10.4
09:44:21 <benmachine> what are your problems?
09:44:54 <Philonous> What is the essential difference Between Parsec 2 and Parsec 3? Why do so many packages depend on for former? Only for hysterical raisins?
09:45:18 <benmachine> possibly you mean historical reasons
09:45:20 <benmachine> oh
09:45:22 <benmachine> raisins
09:45:24 <benmachine> yes
09:45:27 <WaRlOc|> say i have putStrLn "\x222A"
09:45:29 <benmachine> erm
09:45:36 <benmachine> parsec 2 is allegedly faster
09:45:50 <WaRlOc|> this prints the union character in hugs, but in ghc it prints a *
09:45:55 <benmachine> parsec 3 introduces a monad transformer and a user-definable stream type
09:45:56 <Philonous> How much allegedly?
09:45:58 <Zao> WaRlOc|: Look into the utf8-string package.
09:46:11 <Zao> http://hackage.haskell.org/package/utf8-string
09:46:14 <benmachine> prints a union character in ghci for me
09:46:37 <Zao> Thankfully not needed with 6.12.1 as that has the new fancy unicode IO system.
09:46:43 <Zao> benmachine: And you're on 6.10.x?
09:46:55 <benmachine> Zao: oh, no
09:46:58 <benmachine> whoops
09:47:23 <benmachine> (6.12)
09:47:32 <Zao> WaRlOc|: Use the functions in System.IO.UTF8.
09:47:37 <Zao> (from the utf8-string package)
09:48:11 <Zao> WaRlOc|: IO in older GHC versions truncates any codepoints.
09:48:32 <WaRlOc|> Zao: i'm using the version provided in the ubuntu repo.. i'll try to figure it out with the System.IO.UTF8, otherwise i'll get the new version of ghc
09:48:38 <Zao> > "\x2A"
09:48:39 <lambdabot>   "*"
09:49:27 <benmachine> WaRlOc|: the new version of GHC is not recommended for most users
09:49:33 <MissPiggy> bleh this is too hard
09:49:35 <benmachine> because there is no haskell platform for it
09:49:45 <Zao> Assuming you have cabal-install, you can trivially  cabal install utf8-string  to get the aformentioned library.
09:50:08 <Zao> I echo benmachine's opinion, stick with your distro packaged 6.10.4.
09:51:13 <WaRlOc|> Zao: ok, thanks... i'll try and see what i can do...
09:51:46 <MissPiggy> http://img638.imageshack.us/img638/6677/picture3g.png
09:51:55 <MissPiggy> how to implement this in haskell?
09:52:16 <medfly> a bunch of drawings? ;)
09:53:46 <Zao> Reminds me of the knot library I saw detailed on some Haskell blog ages ago.
09:54:09 <dons> withh http://www.haskell.org/arrows/
09:55:24 <MissPiggy> I have no idea how to program this
09:55:42 <MissPiggy> hmm I could do it in CHR
09:57:43 <cizra> Vim users: how do you type the commnands starting with _? Is it some kind of escape?
09:58:03 <cizra> (talking about Vim Haskell mode)
09:58:49 <Zao> cizra: Some kind of imap, I believe.
09:59:19 * cizra ponders
09:59:47 <Arnar> cizra: link to docs?
09:59:48 <Zao> Err, map of course.
10:00:07 <Zao> Much like how you can   map <F5> :silent make<CR>
10:00:19 <Zao> You can have arbitrary mappings, even overlapping.
10:00:40 <cizra> Arnar: http://projects.haskell.org/haskellmode-vim/vimfiles/doc/haskellmode.txt
10:00:54 <Zao> _?   is trivially   map _? :call Haddock()<CR>
10:00:59 <cizra> Zao: Well, typing _t does nothing I notice
10:01:08 <Zao> cizra: Type :map _?  to see how it's defined.
10:01:17 <mauke> cizra: are you typing it in normal mode?
10:01:36 <cizra> mauke: command mode
10:01:40 <Zao> Not even any "foo type not known" message?
10:01:43 <cizra> Zao: aha! that helps
10:02:35 <cizra> _? now works.
10:12:35 <ziman> @pl f x (f x y)
10:12:35 <lambdabot> f x (f x y)
10:12:45 <ziman> @pl \x y -> f x (f x y)
10:12:45 <lambdabot> liftM2 (.) f f
10:14:47 <ziman> :t liftM2 (join fmap)
10:14:48 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> a) -> m a -> m a
10:19:41 <idnar> @type ap
10:19:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:19:58 <Arnar> what are the implications of using -XTypeSynonymInstances?
10:20:06 <Arnar> will the generated code be any less efficient?
10:20:10 <idnar> liftM2 (join fmap) (Just (+1)) (Just 10)
10:20:13 <idnar> > liftM2 (join fmap) (Just (+1)) (Just 10)
10:20:14 <lambdabot>   Just 12
10:20:22 <Twey> Arnar: No
10:21:00 <Arnar> Twey: ok.. so I assume everything is resolved statically before the types are erased
10:21:05 <Twey> Yes
10:21:08 <Arnar> cool.. thanks
10:21:13 <Twey> Exported types are stored in the accompanying .hi file
10:21:34 <Twey> But static types never incur runtime overhead
10:21:41 <b0fh_ua> How do I pattern-match ByteStrings ?
10:22:31 <Zao> I wonder if OverloadedStrings allows you to pattern match things that IsString.
10:22:39 <Zao> b0fh_ua: Some kind of view pattern maybe?
10:22:48 <olsner> case bytestring of x -> {- pattern matched! -} -- harr, harr
10:22:56 <Arnar> Twey: I was worried for a minute it would turn synonyms into data if it needed to
10:22:57 <Saizan> there's uncons
10:22:58 <b0fh_ua> well, have no idea what is this :)
10:23:13 <Arnar> but that doesn't really make sense when I think about it
10:24:48 <b0fh_ua> weird
10:28:02 <c_wraith> So has anyone figured out the right way to do tests for packages that are intended for hackage?  I don't want my package to depend on quickcheck, but I want my tests to use it.  This raises issues with internal/external visibility of code, and the like.
10:28:48 <Saizan> c_wraith: make a distinct Executable that defaults to Buildable: False ?
10:29:44 <Saizan> you can have .Internal modules that are accessible by the executable, since they are in the same tree, but not exposed by the library
10:29:56 <Saizan> or.. implement the ticket about cabal test :)
10:30:19 <c_wraith> Saizan: does that prevent cabal from thinking the library depends on quickcheck?  Experimentation earlier this week suggests that the answer to that question is, at least sometimes, no.
10:31:46 <Saizan> c_wraith: were you experimenting with the latest version?
10:31:53 <Saizan> i thought that was fixed
10:32:02 <c_wraith> It was 1.6.x that was screwing up.
10:32:26 <c_wraith> Does 1.8 fix that?
10:32:57 <c_wraith> err...  crap, I was looking at versions of cabal the lib, rather than cabal-install the program
10:33:09 <c_wraith> but it was definitely an older version of cabal that was having issues
10:33:23 <dons> c_wraith: if you find the right way -- and i think there must be one -- i'd love to know so we can tell everyone.
10:34:22 <Saizan> c_wraith: i'm not exactly sure where the fix is, or if i'm just imagining it, though testing with 1.8 and 0.8 should be revealing :)
10:35:20 <c_wraith> for experimentation purpose, is there any way to get ghc-pkg to dump the dependency list of an installed package, including exact versions of packages it's compiled against?
10:35:26 <c_wraith> I guess there must be..
10:35:52 <alatter> it seems to do that in 6.12 - which version of ghc are you using?
10:36:41 <alatter> c_warith: with 6.12 I use 'ghc-pkg describe binary'
10:36:55 <c_wraith> hmm.  I'll try it
10:37:19 <c_wraith> ah, the "depends: " line
10:38:36 <Saizan> ghc-pkg field $pkg depends
10:39:04 <c_wraith> ah, nifty.
10:40:26 <c_wraith> yeah, newer versions of cabal don't screw up dependency lists.
10:40:56 <dmwit> gwern: Oops!
10:41:02 <dmwit> gwern: One second, I'll fix it.
10:41:02 <c_wraith> So...  I guess I shall start by moving code into .Internal modules.
10:41:31 <Saizan> c_wraith: check that cabal-install doesn't want to depend on QuickCheck either
10:41:40 <Saizan> i.e. that the solver is aware of this
10:42:30 <dmwit> ?tell gwern that git should be fixed for wyvern now, and for dgs/sgf shortly
10:42:30 <lambdabot> Consider it noted.
10:42:32 <c_wraith> err.  cannot find package cabal-install?  wtf?  I've run cabal on that computer a bunch. >_>
10:42:55 <Saizan> well, cabal-install is only an executable
10:43:03 <alatter> c_wraith: ghc-pkg doesn't track executables
10:43:10 <c_wraith> oh, right
10:43:36 <Saizan> i was just saying that e.g. "cabal install" for your package when you're not enabling testing, might still want to install QuickCheck
10:44:00 <Saizan> even if it doesn't screw up the dependencies when registering the lib with ghc-pkg
10:46:33 <LtChaos> apologies, new to haskell.  trying to get xmobar installed and the config dies with this missing dependency base ==4.*   What do I need to get around this?
10:47:06 <c_wraith> Is there any sort of quick generator for a .cabal file?  It feels so tedious, filling out the whole thing from scratch
10:47:27 <Saizan> c_wraith: there's cabal init
10:47:41 <c_wraith> oooho
10:47:43 <c_wraith> thanks
10:48:01 <Saizan> still pretty simple
10:48:19 <Saizan> LtChaos: which ghc version do you have?
10:48:40 <LtChaos> 6.8.3 on a netbsd 5.0 box
10:49:23 <Saizan> which version of xmobar are you trying to install?
10:50:32 <LtChaos> er... feel silly..not sure.. I used the darcs command to pull it in
10:50:42 <Saizan> ah, i see
10:51:41 <Saizan> to use that version you need to upgrade your ghc
10:52:04 <Saizan> otherwise you can install 0.9.2 using the tarball from hackage
10:52:05 <LtChaos> oh.. er.. ok is there a version then I can get which I can avoid that (for now at least)?
10:52:09 <Saizan> http://hackage.haskell.org/package/xmobar
10:52:12 <LtChaos> ok great
10:52:17 <LtChaos> thks much
10:52:26 <c_wraith> err.  my version of cabal install doesn't seem to know the init command
10:52:52 <Saizan> it's new in 0.8.0
10:53:14 <c_wraith> oh.  I thought I'd installed 0.8.0 on that computer.  guess not
10:53:15 <Saizan> ..i think, unless it's from the HEAD
10:53:54 <alatter> no, cabal init works with 0.8
10:56:08 <b0fh_ua> Hi there. If I have the function 'exists :: String -> IO (Bool)', how can I chain 2 consequent calls to exists in a way to not evaluate second call if first one returns False?
10:56:11 <c_wraith> ok.  I now have the tools I need to do my testing, I think.
10:57:23 <Botje> b0fh_ua: liftM2 (||) (exists "one") (exists "two")
10:57:51 <dmwit> Botje: not quite...
10:57:59 <c_wraith> yeah, that executes both IO actions
10:58:36 <Saizan> you've to write an explicit combinator
10:58:52 <dmwit> b0fh_ua: do { x <- exists "foo"; if x then return True else exists "bar" }
10:58:53 <pikhq> x <- exists "one";if x then exists "two" else return False
10:59:04 <dmwit> oops
10:59:09 <dmwit> I got it backwards, but you get the idea.
10:59:25 <alatter> orM lhs rhs = do {res <- lhs; if res then rhs else False}
10:59:46 <Botje> oh, right. liftM2 still does both :'(
10:59:51 <Saizan> orM lhs rhs = do res <- lhs; if res then rhs else return False
10:59:56 <LtChaos> Saizan tyvm for your help, nice afternoon to u
11:00:46 <b0fh_ua> that's too complicated
11:00:48 <Saizan> ..except that it's not or
11:01:07 <monochrom> "or else"
11:01:32 <Saizan> it's more like a shortcutting and, no?
11:01:47 <monochrom> heh
11:01:53 <monochrom> "andalso"
11:02:03 <Saizan> :)
11:02:42 <Saizan> b0fh_ua: one of the nice things of having IO actions as first class values is that you can build your own control structures like this :)
11:02:46 <Zao> andtheeen?
11:03:12 <monochrom> "and also" and "or else" are well-established names from SML.
11:03:23 <alatter> here's what I've dug up from my past:  orM :: [m Bool] -> m Bool, where orM [] = return True; orM (x:xs) = do {x' <- x; if x' then return True; else orM xs}
11:03:35 <Zao> ML has weirdo names for everything.
11:03:43 <benmachine> alatter: orM [] = return False, surely
11:03:53 <Zao> Reading ML is like reading Haskell that has been fed through a few too many IBM mail gateways.
11:03:55 <alatter> benmachine: ah, yes
11:04:00 <alatter> that is in fact what I used
11:04:00 <Twey> orM lhs = (lhs >>=) . join . (??)
11:04:07 <damd> :t (??)
11:04:08 <lambdabot> Not in scope: `??'
11:04:19 <Twey> @let (y ?? n) p = if p then y else n
11:04:21 <lambdabot>  Defined.
11:04:24 <monochrom> IMO you're just saying because of not-invented-here.
11:04:52 <c_wraith> Still, if someone says `orElse` in haskell code, I assume they mean STM
11:05:02 <Saizan> ?type \lhs -> (lhs >>=) . join . (??)
11:05:04 <lambdabot>     Couldn't match expected type `m b' against inferred type `Bool'
11:05:04 <lambdabot>       Expected type: m b -> m b -> m b -> m b
11:05:04 <lambdabot>       Inferred type: m b -> m b -> Bool -> m b
11:05:04 <Twey> Or XHT
11:05:07 <Twey> Er, HXT
11:05:21 <Twey> (woah, didn't expect that one to still be in muscle memory)
11:07:08 <monochrom> http://hackage.haskell.org/packages/archive/hxt/8.5.0/doc/html/Control-Arrow-ArrowIf.html#v%3AorElse
11:08:41 <Twey> monochrom: Yep
11:24:22 <nolrai_FG> is there a better way to write "(either (show `liftM`) (show `liftM` val locals))"
11:24:58 <kmc> well, i would write liftM as <$>
11:25:03 <kmc> when you use it infix
11:25:19 <nolrai_FG> Oh it is the same isn't it.
11:25:20 <tARrAScH> Hello, I'm not understanding the Reader Monad at the moment. Can anyone say the easiest imaginable problem statement that could be solved using the Reader-Monad?
11:25:45 <pikhq> nolrai_FG: *Technically* it's not the same.
11:25:52 <kmc> nolrai_FG, assuming your monad is also a functor and the instances are consistent
11:25:53 <pikhq> nolrai_FG: <$> is a function on the Functors, not on the Monads.
11:26:20 <pikhq> Though, any sane Monad is also a Functor, so it's the same for most purposes.
11:26:26 <nolrai_FG> ok
11:26:45 <monochrom> (show <$>) . (either id (val locals))
11:26:46 <Twey> uncurry either $ join (***) (fmap show) (id, val locals)
11:26:57 <Twey> monochrom: May not type-check
11:27:06 <Twey> :t either
11:27:07 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:27:11 <pikhq> Twey: Heheheh.
11:27:12 <nolrai_FG> tARrAScH: the reader monad just cleans up code. It doesn't really by it's self solve anything.
11:27:17 <Twey> What's the type of ‘either id (val locals)’?
11:27:48 <Teck03> Hey, is this the place to ask Haskell questions? :)
11:27:53 <kmc> Teck03, indeed
11:28:02 <monochrom> I see.
11:28:02 <Twey> Teck03: No, this is the channel for advanced unicycling training
11:28:06 <monochrom> (show <$>) . (either fromLeft (val locals))
11:28:11 <Twey> Teck03: We just chose the name ‘#haskell’ because we thought it sounded cool
11:28:19 <tARrAScH> nolrai_FG: hmm ok... that really doesn't give me an idea of what it could be.
11:28:24 <monochrom> err, not fromLeft
11:28:30 <Twey> monochrom: Err, what?  :þ
11:28:35 <Twey> Heh, aye…
11:28:43 <kmc> tARrAScH, the Reader monad captures this pattern: you have a bunch of related functions, they all take some argument that they pass onto functions they call, without changing it
11:28:45 <nolrai_FG> fromRight?
11:28:50 <Twey> Neither
11:28:57 <monochrom> I see, two different show's.
11:28:58 <kmc> i.e. sort of an ambient "environment" in which all the functions operate
11:29:33 <kmc> (and actually, the Reader monad lets you make local changes to the environment as well)
11:29:51 <Twey> :t uncurry either $ join (***) (fmap show) (id, succ)
11:29:52 <lambdabot> forall a. (Show a, Enum a) => Either a a -> String
11:30:00 <Twey> Oh, that is allowed.  Phew.
11:30:01 <kmc> tARrAScH, for example a set of configuration parameters that control how your algorithm works
11:30:03 <Twey> Oh, wait
11:30:07 <Twey> No it isn't ☹
11:30:13 <kmc> it's inconvenient to pass them explicitly to every part of the algorithm
11:30:19 <Twey> They got monomorphed
11:30:22 <kmc> and it's difficult and generally terrible to make "global variables" in Haskell
11:30:26 <Dan> can anyone help me with this? http://pastebin.org/91684
11:31:02 <kmc> so you want to pass the config to each function, but without uglifying the syntax, and that's what Reader is supposed to help with
11:31:27 <Twey> Dan: Don't think you can
11:31:28 <kmc> Dan, you can't
11:31:39 <Dan> oh :(
11:31:51 <kmc> you've declared "get" in a way such that, for any type d, it will work for absolutely any k and a
11:31:59 <Twey> Dan: Use multi-parameter type-classes or type families
11:32:03 <monochrom> Dan: You have to use multiple parameter typeclass or the newer but more elegant associated types.
11:32:06 <kmc> or make Dict a constructor class
11:32:06 * hackagebot upload: dequeue 0.1.5 - A typeclass and an implementation for double-ended queues. (HenryBucklow)
11:32:08 <tARrAScH> hmm, so you mean instead of having f ::  A -> B -> C -> D, g ::  A -> B -> C -> D, h ::  A -> B -> C -> D. where A, B and C should be thought of as "global variables" I can encapsulate these functions in the Reader Monad and don't need to pass the ABC parameters?
11:32:21 <kmc> tARrAScH, yeah, something like that
11:32:33 <kmc> Dan, i.e. class Dict d where { get :: d k a -> k -> a }
11:32:45 <kmc> instance Dict Data.Map.Map where ...
11:33:07 <kmc> Dan, that's more limited, because any instance you declare must be a 2-ary type constructor with key and value types in that order
11:33:25 <kmc> you couldn't e.g. make an instance for lists where k is always Int
11:33:33 <Dan> yeah
11:33:42 <napping> > Statistics.Math.factorial 1
11:33:42 <lambdabot>   Not in scope: `Statistics.Math.factorial'
11:33:55 <Dan> I don't mind limiting the key type but limiting the value type makes it kinda useless
11:33:56 <napping> somehow I'm getting 0
11:34:10 <kmc> i suggest associated type synonyms
11:34:17 <Dan> I'll look at associated types
11:34:23 <napping> shouldn't 1! = 1?
11:34:28 <kmc> class Dict d where { type Key d; type Val d; get :: d -> Key d -> Val d }
11:34:39 <Twey> napping: Yes
11:34:49 <mreh> is the compiler oblivious to type synonyms?
11:34:54 <Twey> mreh: Yes
11:34:55 <napping> ah: factorial n ... | n <= 1 = 0
11:34:56 <napping> oops
11:35:06 <napping> silly bos
11:35:15 <kmc> mreh, not in every respect, but they are interchangeable at the type checking phase
11:35:18 <mreh> Twey: you can really confuse things when you define functional type synonyms
11:35:35 <Twey> mreh: I have recently observed this myself :þ
11:35:50 <monochrom> I am not confused.
11:36:14 <mreh> function type: one variable, function definition: many variables, programmer: confused
11:36:41 <mreh> confuse-a-cat
11:36:55 <monochrom> what is meant by "function type: one variable"?
11:37:17 <mreh> one type variable
11:38:32 <mreh> type baz = foo -> quux ; bar :: baz ; bar f = quuxme f
11:38:37 <monochrom> You mean like “type Cursor r a b = (((a -> r) -> r) -> b) -> b”, in which r,a,b are one type variable?
11:38:47 <Gracenotes> oh my god.. all the T types in midi, haskore, event-list, alsa-midi... it's too effing much
11:38:57 <Gracenotes> doesn't anyone know how to name types anymore?
11:39:07 <mreh> Gracenotes: they are Henning Theilmann libraries
11:39:25 <Gracenotes> yeah, I know
11:40:03 <mreh> he even goes as far as naming constructors the same as *other* type names
11:40:21 <Gracenotes> hm. I heard Java has a MIDI interface.
11:40:31 <mreh> heresy
11:40:42 <Gracenotes> Haskore seems pretty neat, but I don't exactly have time to learn the ins and out of naming
11:41:09 <mreh> Gracenotes: use the old Hudak version
11:41:19 <monochrom> I think foo,bar,qux are superb type names.
11:41:24 <nolrai_FG> Is there a shorter way to write (return . myFunk)
11:41:35 <nolrai_FG> monochrom: :(
11:41:36 <mreh> return.myFunk
11:41:40 <napping> those sort of names work reasonably if keep modules qualified. It's the usual ML style - map.t, bag.t, whatever
11:42:13 <Gracenotes> well, it doesn't concern haddock
11:42:23 <Gracenotes> I do want a direct midi interface though
11:42:55 <napping> Is there a nice expression for the order statistics of the Poisson distribution?
11:42:59 * RayNbow sighs and wonders why .NET uses SelectMany :: (m a -> (a -> m b) -> (a -> b -> c) -> m c) for LINQ... (what's wrong with using (m a -> (a -> m b) -> m b), dear Microsoft?)
11:43:02 <napping> especially max
11:43:31 <cizra> I want to modify a record -- change one piece of it, leave the rest alone. Is it possible to do it without typing out all the members?
11:43:42 <RayNbow> cizra: yes
11:43:46 <cizra> RayNbow: How?
11:43:52 <RayNbow> oldRecord {someField = newVal}
11:44:27 <cizra> aha! Thanks!
11:44:30 <mreh> oldRecord {someField = f . newVal $ oldrecord }
11:44:48 <mreh> that's a bit more general
11:45:09 <mreh> uhh, hang on
11:45:22 <mreh> oldRecord {someField = f . someField $ oldrecord }
11:45:32 <RayNbow> that looks better :p
11:46:08 <Twey> oldRecord { someField = f $ someField oldRecord }
11:46:21 <mreh> ugly
11:46:30 <Twey> Correct
11:46:35 <Twey> Also, shorter :þ
11:46:36 <Athas> That's records for you.
11:46:43 <RayNbow> oldRecord { someField = f $ someField $ oldRecord }  -- more symmetry :p
11:46:55 <Twey> RayNbow: Ew, reliance on bad precedence rules
11:47:11 <RayNbow> Twey: if you want different precedence rules, use `id` :p
11:47:17 <monochrom> field {newVal = f . newVal $ field} is shorter. the record is called field. the field is called newVal.
11:47:30 <kmc> yes records are ugly in that way
11:47:31 <Athas> That's cheating!
11:47:36 <Twey> RayNbow: $ should be infixl.  Everyone knows that.
11:47:54 <benmachine> a{b=c.b$f}
11:47:57 <kmc> look at fclabels, data-accessor, or lenses
11:47:58 <benmachine> er
11:47:59 <Twey> monochrom: a { b = f . … damn :þ
11:47:59 <benmachine> a{b=c.b$a}
11:48:29 <mreh> heh, record syntax, everybody fails the first time
11:48:34 <kmc> also read about the RecordWildcards and NamedFieldPuns GHC extensions
11:48:48 <Athas> Are there any serious proposals for reworking Haskell records?
11:49:01 <mreh> only joke proposals
11:49:13 <benmachine> TDNR is not a joke but it's not a good idea either
11:49:16 <benmachine> imo
11:49:17 <Athas> Poe's Law?
11:49:20 <kmc> yeah
11:49:54 <kmc> i think "do the opposite of C++" is a decent design guideline
11:50:12 <Saizan> TDNR would solve only trivial syntactic issues, while introducing _very ad-hoc_ overloading
11:50:19 <Saizan> so i agree :)
11:51:07 <kmc> there's the less ad hoc idea of making a syntactic class of field labels, which reflect into the type system
11:51:14 <Twey> http://www.reddit.com/r/haskell/comments/antdq/haskells_tower_of_babel/ — :-D
11:51:21 <Zao> I looked into syb the other day.
11:51:24 <Zao> My head is still spinning.
11:52:02 <kmc> myLabel :: (HasLabel MyLabel record ty) => Lens record ty
11:52:05 <gwern> dmwit: ok, wyvergn cit glone seems to work now
11:52:06 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
11:52:47 <Teck03>  I'm getting a "Could not deduce (Show b) from context (Show (TriTree a b), Show a)" when I try to run this code... Any suggestions?   showTree :: (Show a, Show b)  => (TriTree a b) -> String  data TriTree a b = Leaf a | Node1 (TriTree a b) b   showTree :: (Show a, Show b)  => (TriTree a b) -> String showTree t =            case t of               Node1 b1 n -> show n ++ " t " ++ show b1                             Leaf l -> show 
11:52:59 <ddarius> RayNbow: SelectMany has an overload that directly corresponds to (>>=)
11:53:16 <ddarius> RayNbow: But the reason for that overload is to avoid deeply nested lambdas.
11:53:31 <kmc> deeply nested lambdas? oh noes!
11:53:42 <dmwit> Teck03:
11:53:44 <dmwit> ?hpaste
11:53:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:55:32 <RayNbow> ddarius: I wish I could just define fmap and join instead in .NET :p
11:55:45 <sinelaw> blah
11:56:24 <ddarius> RayNbow: You can set up methods that will more or less let you do that.
11:56:25 <RayNbow> :t \m f g -> liftM2 g m (join (fmap f m))
11:56:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Functor m, Monad m) => m a1 -> (a1 -> m a2) -> (a1 -> a2 -> r) -> m r
11:56:29 <ddarius> (+ return)
11:56:32 <cizra> Yay!
11:56:42 * cizra watches little @ run in circles around a rat and an orc
12:03:00 <Teck03> I'm getting a "Could not deduce (Show b) from the context (Show (TriTree a b), Show a)" error when I try to run this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20847#a20847
12:03:08 <Teck03> Any suggestions? :)
12:03:17 <dmwit> Teck03: Yep, read the error carefully. =)
12:03:29 <dmwit> Teck03: Compare the contexts on your type for showTree to the context for your instance declaration.
12:04:05 <monochrom> I agree.
12:07:36 <Teck03> Damn it, I could of sworn I had tried changing that already. Thanks, it worked!
12:07:41 <Teck03> dmwit++
12:08:48 <Asztal> Zao: it's very useful for transforming ASTs, I love it :)
12:14:59 <gwern> > 200 / 1500000
12:15:00 <lambdabot>   1.3333333333333334e-4
12:15:06 <gwern> > (200 / 1500000) * 100
12:15:07 <lambdabot>   1.3333333333333334e-2
12:15:17 <gwern> > ((200 / 1500000) * 100) / 100
12:15:18 <lambdabot>   1.3333333333333334e-4
12:16:33 <gwern> it blows my mind how cheap storage is on a per-meg basis
12:16:48 <medfly> try per-tb then :)
12:17:10 <gwern> scanning books into 200MB pdfs used to cost like 100$ of space; now it's like 1 or 2 cents
12:17:58 <MissPiggy> scanning books takes ages though?
12:18:05 <medfly> I think they have machines for that
12:18:20 <medfly> I'm guessing...
12:18:25 <Adamant> MissPiggy: they're building new machines for it based on digital cameras
12:18:33 <Adamant> just flip the pages
12:18:48 <medfly> it would be easier to just damage the book slightly, and separate the pages :)
12:19:02 <gwern> MissPiggy: not really. I just put on a movie. don't have to take my eyes off
12:19:15 <Adamant> yeah, that works if the book can be sacrificed
12:19:29 <MissPiggy> gwern I bet you get them all wobbly!!
12:19:30 <gwern> the real problem is dealing with thick softcover books - you have to press down hard on those suckers
12:19:32 <Adamant> but the above works even for rare books
12:20:14 <gwern> MissPiggy: nah nah - I spend a little while figuring out the exact right position, then I take my lumps of wax and construct little barriers. now I only have to slide the book in until it bumps u[p against the wax
12:20:23 <gwern> again, eyes-free
12:21:21 <gwern> my problem now is that all my 'long-term' 'archival' books seem to be down to art books that I don't want to scan at all :)
12:21:36 <Twey> gwern: 200MB?  That's a huge book
12:21:50 <Twey> Or no OCR?
12:22:01 <gwern> Twey: the ocr doesn't add much to the jps
12:22:06 <gwern> if that's what you mean
12:22:10 <Adamant> Twey: could be OCR with original picture included
12:22:27 <gwern> OCR is bad enough that I can't throw away the (relatively) raw JPGs
12:22:53 <Twey> Hmm… :-\
12:23:04 <gwern> so, it's 200MB of jpgs. a little under 1mb per page
12:24:44 <Adamant> a neat trick some people do is put the jpg layer on top then impose the OCR when you highlight text.
12:24:57 <medfly> 200mb for a book is still pretty huge
12:24:59 <Twey> Wouldn't it be better to do it the other way around?
12:25:43 <Adamant> Twey: not sure if I'm describing it right (not good at graphics stuff)
12:25:59 <gwern> medfly: I don't think it is. what would you have me do? tesseract OCR isn't smart enough to turn it into pure ascii, and if you cut the image quality down to 100dpi or the jpeg compression down to like 25%, it becomes unreadable - and you can forget about OCRing it later
12:26:04 <gwern> books are big
12:26:34 <medfly> yeah, I know... it's just unfortunate OCR is not good enough
12:26:50 <gwern> google quality OCR might be enough to throw away the raw images
12:26:56 <gwern> but I don't have access to that :)
12:27:14 <Twey> gwern: Personally, I'd OCR it when I feel like reading it, then read through it on the computer and correct OCR errors
12:27:37 <medfly> would be nice if you could just search for errors on the OCRed text
12:27:42 <gwern> Twey: way too much work. and you assume the OCR is at least mostly correct :) I've seen perfectly fine scans which turn into pure hash
12:27:55 <medfly> ah
12:28:03 <Twey> gwern: o.@  I haven't
12:28:03 <medfly> well, at least it's not very troublesome to scan many pages
12:28:08 <Twey> What OCR were you using?
12:28:11 <dankna> Project Gutenberg eschews OCR entirely.
12:28:13 <gwern> Twey: tesseract
12:28:18 <medfly> eschews?
12:28:22 <dankna> They find that it's actually more work to correct an OCR than to type it in by hand.
12:28:25 <dankna> Avoids.
12:28:27 <Twey> medfly: Scorns, rejects, avoids
12:28:27 <gwern> dankna: distributed proofeaders didn't last I heard
12:28:28 <medfly> hahaha
12:28:29 <gwern> @wn eschew
12:28:31 <lambdabot> *** "eschew" wn "WordNet (r) 2.0"
12:28:31 <lambdabot> eschew
12:28:31 <lambdabot>      v : avoid and stay away from deliberately; stay clear of [syn: {shun}]
12:28:40 <medfly> wow, that's pretty weird... I take a while to type a book...
12:28:40 <dankna> thank you :)
12:28:56 <medfly> thanks
12:29:04 <gwern> thankee
12:29:15 <medfly> lining up?
12:29:29 <Twey> medfly: But you're not Google
12:29:35 <gwern> medfly: against the wall!
12:29:59 <Twey> Four hundred Data Entry Specialists, one per page, done in half an hour?  No problem.
12:30:13 <medfly> oh...
12:30:25 <gwern> at minimum wage, that's 3.45 a head
12:30:32 <medfly> gwern, get more Indians
12:30:34 <gwern> > 400 * (7.15/2)
12:30:35 <lambdabot>   1430.0
12:30:37 <dankna> I thought minimum wage was like 6.something
12:30:39 <gwern> ack
12:30:39 <dankna> oh
12:30:40 <Twey> Chump change
12:30:41 * benmachine giggles at Data Entry Specialists
12:30:42 <dankna> you halved it
12:30:44 <gwern> dankna: it got lifted
12:30:48 <dankna> oh, okay
12:30:52 <gwern> dankna: well of course. half an hour 'e said
12:30:56 <dankna> right, okay
12:30:59 <gwern> half an hour's pay for half an hour's work!
12:31:04 <dankna> logical :)
12:31:09 <medfly> what country's minimum wage are we talking about
12:31:17 <medfly> also, what currency...
12:31:18 <Twey> benmachine: Read: clever imps
12:31:18 <dankna> there are other countries?
12:31:22 <Twey> chimps**
12:31:22 <medfly> dankna, omg!
12:31:26 <dankna> sorry, haha
12:31:27 <medfly> dankna, I never knew!
12:31:31 <gwern> dankna: everyone knows US is a synonym for the world
12:31:34 <Twey> Ah, dankna is an American
12:31:38 <medfly> dankna, I always thought those indians come from out of space.
12:31:46 <gwern> how else could it be 'us' if there were also a 'they'?
12:31:51 <dankna> that was self-parody, just to be clear
12:31:52 <Twey> medfly: outer space** >.<
12:32:02 <dankna> I actually try hard to be aware of the rest of the world
12:32:07 <Twey> dankna: Heh
12:32:28 <benmachine> Twey: that is not the part of that sentence which most urgently demands correction :P
12:32:38 <Twey> Haha
12:33:50 <medfly> dankna, yeah, we were taking you too seriously there, huh?
12:33:59 <dankna> no, haha
12:34:11 <gwern> we are serious IRCers; this are serious channel
12:34:11 <dankna> but I thought somebody might or something, it's happened
12:34:22 <medfly> Twey, should I take that to mean that I don't make that many errors normally?
12:35:00 <Twey> medfly: Well, I only corrected it because it's an error that particularly annoys me
12:35:06 <Twey> But that's also true
12:36:10 <medfly> Twey, I've been wondering for a while...
12:36:14 * Berengal wonders what inner space is
12:36:22 <medfly> Twey, does switching was with were make me into an English person?
12:36:39 <dankna> Inner space is where you do debugging!
12:36:42 <dankna> In your head.
12:37:26 * hackagebot upload: bytestring-lexing 0.2.1 - Parse literals efficiently from bytestrings (DonaldStewart)
12:38:21 <Twey> medfly: Err, what?  :þ
12:38:31 <medfly> Twey, I mean, is it correct...?
12:38:39 <Twey> Not… everywhere?
12:38:52 <medfly> Twey, is it okay to say "I were doing shit"? :O
12:38:59 <astroboy> I guess it's possible to compile haskell to C with ghc, but I can't find out how :P
12:39:25 <medfly> -keep-hc-file
12:39:26 <medfly> ?
12:39:31 <burp> and -fvia-C
12:39:41 <astroboy> ok thanks
12:40:20 <Twey> medfly: … no :þ
12:40:31 <medfly> Twey, WIKTIONARY SAYS YES
12:40:44 <nostrand> hi, i want to parse a string(using parsec): "blabla    545  blabla" Like CSV, but the separator is whitespaces instead of a comma. I'm looking at this example http://book.realworldhaskell.org/read/using-parsec.html
12:40:49 <Twey> medfly: Lies :þ
12:41:16 <alatter> nostrand: http://hackage.haskell.org/package/delimited-text
12:41:17 <medfly> http://en.wiktionary.org/wiki/were#Verb
12:41:22 <alatter> nostrand: does that help?
12:41:27 <damd> medfly: it works if it is preceded by "<someone> and" or "if"
12:41:36 <not_nathan> Does anyone know what '!' in a type signature means? I found it when browsing some source code on hoogle.
12:41:47 <not_nathan> And punctuation is difficult to search for.
12:41:48 <Twey> not_nathan: Strict evaluation
12:41:53 <not_nathan> K.
12:41:59 <damd> always with the ~ and the
12:41:59 <damd> !
12:42:16 <medfly> Twey, seeee
12:42:28 <not_nathan> Twey : thanks.
12:42:37 <ddarius> Except ! doesn't ever occur in Haskell type signatures.
12:42:50 <ddarius> So not_nathan probably means data declaration.
12:42:57 <nostrand> alatter: i just want something simple, like sepBy field whitespace
12:43:12 <medfly> Twey, is it correct then
12:43:36 <Twey> medfly: I'm not seeing what you're talking about here
12:43:42 <medfly> #6!
12:43:47 <alatter> nostrand: simple perhaps, but I do prefer code that someone has already written. Although the ByteString interface might not be what you want ...
12:43:52 <Twey> Ohh
12:43:59 <Twey> Still no :þ
12:44:48 <medfly> Twey, WHY NOT
12:45:10 <Twey> medfly: Because it'll make you sound like a Geordie
12:45:19 <Twey> medfly: Nobody wants to sound like a Geordie
12:45:21 <medfly> okay. I'll sound like a Geordie then!
12:45:54 <Twey> alatter: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#UserGuide
12:45:56 <Arnar> @pl \x y -> fst x == fst y
12:45:57 <lambdabot> (. fst) . (==) . fst
12:46:07 <Arnar> ^ can I do this with some arrow tricks?
12:47:05 <medfly> f (a,_) (b,_) = a == b -- what's wrong with this?
12:47:07 <not_nathan> ddarius : I do mean data declaration
12:47:28 <Arnar> medfly: I want pointfree :)
12:47:29 <Twey> Arnar: on (==) fst x y
12:47:34 <Twey> on (==) fst
12:47:45 <medfly> @t (on (==) fst)
12:47:45 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:47:49 <medfly> @type (on (==) fst)
12:47:50 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
12:48:01 <Arnar> Twey, medfly: thanks..
12:48:03 <Arnar> @type on
12:48:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:48:14 <Arnar> didn't know about that one..
12:48:25 <Arnar> :index on
12:48:32 <Arnar> @index on
12:48:32 <lambdabot> bzzt
12:48:36 <Twey> Data.Function
12:49:22 <benmachine> I find hoogle to be more reliable than @index
12:51:08 <Arnar> the docs for on says
12:51:19 <Arnar> typical usage "sortBy (comparing `on` fst)"
12:51:31 <Arnar> "sortBy (comparing fst)" is not going to do what that means?
12:52:09 <Arnar> :t comparing
12:52:10 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:52:23 <Arnar> :t on comparing
12:52:24 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
12:52:24 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
12:52:24 <lambdabot>     In the first argument of `on', namely `comparing'
12:52:41 <Twey> :t on comparing fst
12:52:42 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
12:52:42 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
12:52:42 <lambdabot>     In the first argument of `on', namely `comparing'
12:52:44 <ddarius> :t compare `on` fst
12:52:45 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
12:52:48 <Arnar> aahh
12:52:48 <ddarius> Typo
12:52:52 <Twey> Ah
12:52:54 <harlekin> Can I compare data types for identity instead of equallity?
12:52:56 <Twey> Yes… needs fixing…
12:53:01 <Arnar> the doc says compare
12:53:08 <Arnar> the typo happened in my brain
12:53:12 <Arnar> :t on compare
12:53:13 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
12:53:21 <IceDane> @hoogle threadDelay
12:53:21 <ddarius> Indeed, comparing = on compare
12:53:22 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
12:55:31 <Janni> I just wrote a simple function and I'm having trouble lifting it to the monad plane. There's probably some concept I'm unfamiliar with. Could you point it out to me?
12:55:32 <Janni> iterateMaybe :: (a -> Maybe a) -> a -> [a]
12:55:32 <Janni> iterateMaybe f x = x : case f x of
12:55:32 <Janni>   Nothing -> []
12:55:32 <Janni>   Just y  -> iterateMaybe f y
12:55:51 <Zao> Asztal: That's what I intend to do with it.
12:55:57 <Janni> This would involve transforming one monad into another.
12:56:03 <Zao> Asztal: Happened upon it when smashing my face at Language.C.AST
12:56:42 <Janni> Ah, btw. I would want to lift _both_the Monad _and_ the list.
12:56:53 <Janni> s/would//
12:57:32 <Janni> I know, there's something called monad transformers out there, but that would be completely unrelated, right?
12:58:31 <Arnar> @pl \l -> (fst $ head l, map snd l)
12:58:32 <lambdabot> ap ((,) . fst . head) (map snd)
12:58:39 <MissPiggy> o that's not moand transformers
12:59:00 <MissPiggy> Janni: so you want (a -> m a) -> b -> n a ?
12:59:13 <MissPiggy> Janni: m and n both Monad but maybe more than just monad
12:59:21 <Janni> Yes, that's what I assume, but I'm starting to doubt.
12:59:36 <MissPiggy> Janni, well do n first,
12:59:49 <MissPiggy> instead of x : xs you can do  return x `mplus` xs
12:59:56 <Janni> That would be the easy part, yes.
13:00:32 <MissPiggy> now instead of  case f x of .., you can   do y <- f x ; iterateMaybe f y
13:03:22 <Phyx-> hmm having a weird problem with cabal configure hanging once in a while. and restarting it works
13:03:26 <tARrAScH> Arnar: are you perchance taking a Haskell uni course called AFP at the moment?
13:05:13 <gwern> > 2.25 / 3
13:05:14 <lambdabot>   0.75
13:05:22 <gwern> I drink .75 pounds of tea a year
13:05:34 <gwern> can't decide whether that's more or less than I expected
13:06:01 <Janni> MissPiggy: I think the solution is not as trivial as you assume (if possible at all). But I often have bad judgement about these things.
13:06:52 <Janni> Problem is: do y <- f x ; iterateMaybe f y
13:06:52 <gwern> > 2.25 / 4
13:06:53 <lambdabot>   0.5625
13:07:07 <mm_freak> @index iterateMaybe
13:07:07 <lambdabot> bzzt
13:07:11 <Janni> y <- f x    and    interateM f y are in a different monad.
13:07:30 <ddarius> Janni: The type you want doesn't make a lot of sense.
13:07:46 <mm_freak> iterateM would be a useful function
13:07:54 <Janni> Yes, I think I'm getting to that conclusion...
13:07:55 <ddarius> @hoogle iterateM
13:07:55 <lambdabot> No results found
13:08:08 <mm_freak> Monad m => (a -> m a) -> a -> m [a]
13:08:14 <Janni> iterateM would be useful, but I think the signature should be...
13:08:23 <Janni> yes, something like that.
13:08:54 <gwern> > 500 / 18.80
13:08:55 <lambdabot>   26.595744680851062
13:09:16 <gwern> > 254 / 26
13:09:17 <lambdabot>   9.76923076923077
13:09:52 <gwern> so 10$ for a year's supply
13:09:57 <tARrAScH> gwern: whoa you're junkie! :p
13:09:58 <gwern> I wonder how much coffee drinkers spend
13:10:17 <dankna> probably more
13:10:23 <gwern> yes, probably
13:11:32 <mm_freak> > let iterateM f x0 = f x0 >>= fmap (x0:) . iterateM f in iterateM (\x -> [x+1, x-1]) 0
13:11:36 <lambdabot>   * Exception: stack overflow
13:12:26 <mm_freak> > let iterateM f x0 = f x0 >>= fmap (x0:) . iterateM f in map head $ iterateM (\x -> [x+1, x-1]) 0
13:12:29 <lambdabot>   * Exception: stack overflow
13:12:40 * hackagebot upload: hdirect 0.21.0 - An IDL compiler for Haskell (DonaldStewart)
13:12:53 <gwern> > (15 / 1, 125 / 5.8, 250 / 10.44, 500 / 18.80, 1000 / 33.90)
13:12:54 <lambdabot>   (15.0,21.551724137931036,23.946360153256705,26.595744680851062,29.498525073...
13:13:36 <gwern> (figured there was a bulk discount but wanted to know for sure)
13:14:03 <Janni> Hmm. This iterateM turns out to become a riddle. Trivial solution: iterateM f x = mplus (return x) (f x >>= iterateM f)
13:14:19 <Janni> However this is not very useful, at least not for my problem.
13:14:25 <ddarius> That's more like many rather than iterateM.
13:14:31 <ddarius> @src many
13:14:31 <lambdabot> Source not found. My pet ferret can type better than you!
13:14:51 <djahandarie> lol
13:14:59 <Janni> I have a rewriting rule: step :: Expr -> Maybe Expr
13:15:00 * djahandarie wonders who coded disses into lambdabot 
13:15:32 <Janni> I'd like to iterate step to get the rewriting steps: iterateExpr :: Expr -> [Expr]
13:16:30 <ddarius> Janni: Why do you care about generalizing to an arbitrary monad then?
13:16:35 <Janni> I can't implement step as step :: Monad(Plus) m => Expr -> m Expr  because I need to scrutinise whether a rewriting step as taken place.
13:16:41 * hackagebot upload: starling 0.2.0 - A memcached client (AntoineLatter)
13:17:26 <Janni> ddarius: Because I thought I could :-)
13:18:08 <MissPiggy> Janni have you found a harder solution than mine? :P
13:18:21 <ddarius> Janni:  You could make a MonadPlus m => (a -> Maybe a) -> a -> m a
13:18:56 <Hunner> any way to get 'show' to interpret \n correctly in ghci? It just shows \n in the middle of a line
13:19:25 <Alpounet> I'd say it's not show's role to format a string.
13:19:26 <gwern> djahandarie: it was dons, I think. he was on openbsd at the time, and openbsd's sudo etc. do the same thing
13:20:07 <Zao> Show instances tend to be made to avoid things getting interpreted.
13:20:10 <Hunner> Alpounet: oh right. I'm using trace in my actual program to format the string
13:23:47 <aavogt> Hunner: either     foldr trace value (lines "comment\nblah...")
13:24:53 <aavogt> or write your own Debug.Trace.trace as   unsafePerformIO . putStrLn  that interprets differently.....
13:25:15 <atemerev> Hi there -- can anybody help me with arrows? I would like to turn two IO String values  into (***) Kleisli arrow. How can I do that?
13:26:01 <aavogt> why are you using arrows if IO is a monad?
13:26:33 <aavogt> arrows are more restrictive
13:26:52 <atemerev> I just want to explore how to do different things with arrows instead of monads.
13:27:07 <aavogt> @type arr ?x *** arr ?y
13:27:08 <lambdabot> forall b c (a :: * -> * -> *) b' c'. (?x::b -> c, Arrow a, ?y::b' -> c') => a (b, b') (c, c')
13:27:30 <aavogt> @type arr (const ?x) *** arr (const ?y)
13:27:31 <lambdabot> forall a b (a1 :: * -> * -> *) a2 b'. (?x::a, Arrow a1, ?y::a2) => a1 (b, b') (a, a2)
13:27:53 <Alpounet> µ
13:27:57 <aavogt> which a1 are you working with in particular?
13:28:09 <aavogt> which arrow instance I mean?
13:29:07 <Alpounet> ànàà************hà$*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:29:07 <Alpounet> ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:29:08 <Alpounet> ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:29:13 <Alpounet> ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:29:18 <Alpounet> *************************$$$******
13:29:22 <aavogt> @type Kleisli putStr *** Kleisli print
13:29:23 <lambdabot> forall b'. (Show b') => Kleisli IO (String, b') ((), ())
13:29:38 <Phyx-> wtf
13:30:16 <Phyx-> is Alpounet a bot?
13:30:16 <MissPiggy> I agre lol
13:30:17 <damd> that's the longest operator i've seen
13:30:20 <Alpounet> jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjhhhhhhhhhhhhh******************************************************************************************************************************************
13:30:20 <Alpounet> ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:30:21 <Alpounet> ******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
13:30:26 <Alpounet> *******************************************************************************************************************************************************************************************************************************hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
13:30:30 <MissPiggy> he's probably fallen asleep
13:30:31 <Alpounet> jjjjj,,,,
13:30:36 <alatter> it looks like a cat got on the desk
13:30:44 <MissPiggy> cat's don't know how to type O_O
13:30:51 <MissPiggy> cats*
13:30:53 <alatter> exactly!
13:30:59 <lpsmith> My vote is cats
13:30:59 <Phyx-> rofl
13:31:10 <burp> multiple?
13:31:14 <Phyx-> brings another meaning to "keyboard cat"
13:31:20 <damd> let (************************************************************************************) = (+) in 3 ************************************************************************************ 4
13:31:23 <damd> > let (************************************************************************************) = (+) in 3 ************************************************************************************ 4
13:31:24 <lambdabot>   7
13:31:28 <atemerev> Well, I want to put two command line arguments (IO String) as an input to (***) arrow.
13:31:39 <atemerev> Say, args () = getArgs
13:31:42 <aavogt> atemerev: so I think you're looking for Kleisli as your Arrow instance then
13:32:09 <atemerev> Then, Kleisli args >>> arr (!! 0) is the first argument
13:33:02 <Zao> I'm going to prefix all my operators with -- in the future, just to confuse any readers of my source.
13:33:57 <burp> that is possible?
13:34:22 <damd> > let (--!) = (+) in 3 --! 4
13:34:22 <lambdabot>   7
13:34:31 <yitz> > let (--+)=(+) in 5--+3
13:34:32 <lambdabot>   8
13:34:39 <burp> but not -- on it's own
13:34:45 <alatter> that's unfortunate.
13:35:16 <tARrAScH> what abou  -- followed by a minus (-)?!
13:35:20 <nolrai_FG> whats the function that forces compuation of a then evaluates to b, I think it starts with a s?
13:35:29 <burp> > let (---)=(+) in 5---3
13:35:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:35:31 <Zao> The rules are something like "-- is a comment only if the immediately following symbol isn't an operator symbol"
13:35:36 <sshc> can a newtype decleration have multiple constructors?
13:35:37 <Zao> nolrai_FG: seq?
13:35:39 <burp> I see
13:35:45 <yitz> > 5---3 where {(---)=(-)}
13:35:46 <lambdabot>   5
13:35:51 <jmcarthur> nolrai_FG: to evaluate in exactly that order you ware looking for pseq
13:35:59 <Zao> > undefined `seq` 9
13:36:00 <lambdabot>   * Exception: Prelude.undefined
13:36:06 <jmcarthur> nolrai_FG: seq just evaluates one when the other is evaluated, but doesn't specify which is evaluated first
13:36:11 <nolrai_FG> Zao: thanks.
13:36:19 <nolrai_FG> ah
13:36:23 <Zao> @hoogle pseq
13:36:23 <lambdabot> Control.Parallel pseq :: a -> b -> b
13:36:28 <burp> > 5 --TODO 3 where (--TODO) = (+)
13:36:29 <lambdabot>   5
13:36:45 <tARrAScH> lol
13:36:50 <nolrai_FG> @src seq
13:36:50 <lambdabot> Source not found. That's something I cannot allow to happen.
13:37:08 <jmcarthur> wtf burp
13:37:10 <tARrAScH> > (undefined `pseq` 1)
13:37:11 <lambdabot>   * Exception: Prelude.undefined
13:37:37 <burp> jmcarthur: trying further obfuscations
13:37:58 <nolrai_FG> burp why doesnt that fail?
13:38:20 <burp> don't know, doesn't work as I expected it to be anyway
13:38:33 <atemerev> But of course!
13:38:39 <tARrAScH> > (1 `pseq` undefined)
13:38:40 <lambdabot>   * Exception: Prelude.undefined
13:38:40 <atemerev> Everything from --TODO is a comment.
13:38:45 <atemerev> So it's 5.
13:38:54 <jmcarthur> right
13:39:19 <burp> <yitz> > 5---3 where {(---)=(-)} ← ew I was blind, I thought lambdabot replied 2 there ;)
13:39:24 <jmcarthur> but something like --.TODO might be syntactically fine, or ---TODO
13:39:31 <jmcarthur> but TODO would have to be a valid constructor in context
13:39:46 <yitz> no, --- is a comment
13:39:51 <jmcarthur> oh
13:39:53 <nolrai_FG> @hoogle seq
13:39:53 <lambdabot> Prelude seq :: a -> b -> b
13:39:53 <lambdabot> Data.Sequence data Seq a
13:39:53 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
13:40:03 <jmcarthur> > let (---) = (+) in 5 --- 6
13:40:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:40:08 <jmcarthur> ah okay
13:40:12 <atemerev> No wai.
13:40:16 <jmcarthur> > let (--.) = (+) in 5 --. 6
13:40:17 <lambdabot>   11
13:40:42 <yitz> > 5 ---+ 6 where { (---+) = (*)
13:40:43 <atemerev> > let (—) = (+) in 5 — 6
13:40:44 <lambdabot>   <no location info>: parse error on input `where'
13:40:44 <Twey> > let 2 + 2 = 5 in 2 + 2
13:40:44 <lambdabot>   11
13:40:45 <lambdabot>   5
13:40:58 <yitz> > 5 ---+ 6 where { (---+) = (*)
13:40:59 <lambdabot>   <no location info>: parse error on input `where'
13:41:04 <yitz> > 5 ---+ 6 where { (---+) = (*) }
13:41:05 <lambdabot>   <no location info>: parse error on input `where'
13:41:18 <DigitalKiwi> yitz: where is your tail
13:41:19 <atemerev>  let (—) = (+) in 100 — 200
13:41:27 <Twey> You can't put wheres on arbitrary expressions, yitz
13:41:28 <atemerev> > let (—) = (+) in 100 — 200
13:41:29 <lambdabot>   300
13:41:41 <Twey> Needs to be a full definition
13:41:45 <burp> > let (+) = (-) in 5 + 4
13:41:46 <lambdabot>   1
13:41:48 <atemerev> Aha. So, — it's almost a -.
13:42:02 <burp> that's even better.. + almost looks like +
13:42:10 <Twey> > let (·) = (*) in 5·3
13:42:11 <lambdabot>   15
13:42:12 <MissPiggy> let —  —
13:42:14 <burp> oh it's actually the same ;)
13:42:14 <jmcarthur> > let (-) = (+) in 40 - (-40)
13:42:15 <lambdabot>   0
13:42:28 <yitz> > let x = 5 ---+ 6 where { (---+) = (*) } in x
13:42:29 <lambdabot>   30
13:42:29 <burp> I see redefining just works
13:42:43 <yitz> > let x = 5 --- 6 where { (---) = (*) } in x
13:42:44 <lambdabot>   not an expression: `let x = 5 --- 6 where { (---) = (*) } in x'
13:42:45 <atemerev> As long as it's in let..in.
13:43:03 <yitz> that's a weird error
13:49:03 <ksf> I just wondered why my code is as big as it is.
13:49:10 <ksf> at the end of the file, vim says it's the 200th line.
13:49:20 <ksf> then I noticed that I've got 90 lines of comments.
13:49:37 <mjrosenb> is there any way to convert a double to a string and get n digits of precision?
13:50:03 <ksf> > showFFloat (Just 4) (1/3) ""
13:50:04 <lambdabot>   "0.3333"
13:50:34 <ksf> module Numeric, iirc
13:50:39 <alexsuraci> > showFFloat Nothing (1/3) ""
13:50:40 <lambdabot>   "0.3333333333333333"
13:50:57 <ksf> > showFFloat Nothing (1/3 :: CReal) ""
13:50:58 <lambdabot>   "* Exception: CCeal.floatRadix
13:51:07 <ksf> > showFFloat (Just 3) (1/3 :: CReal) ""
13:51:08 <lambdabot>   "* Exception: CCeal.floatRadix
13:51:13 <ksf> huh.
13:53:26 <nolrai_FG> So the code for seq would be something like " seq a b = case a of _ -> b" or does it require something deeper?
13:55:03 <Philonous> > case undefined of _ -> Nothing
13:55:04 <lambdabot>   Nothing
13:55:29 <Twey> nolrai_FG: It requires maaagic
14:01:34 <ksf> nolrai_FG, but you're close, in ghc core case is the way to force something.
14:02:11 <Twey> Why would a _-pattern force anything?
14:02:16 <ksf> stuff changed a bit lately, though.
14:02:56 <ksf> case rxxaoeubecaethzzzaeuzzz3 of DEFAULT -> ...
14:03:13 <Twey> What is DEFAULT?
14:03:27 <nolrai_FG> Its __DEFAULT
14:03:27 <ksf> dunno
14:03:30 <dons> in Core?
14:03:34 <ksf> in core, yes.
14:03:37 <dons> it's the _ pattern.
14:03:44 <Twey> Is it magic?
14:03:46 <ksf> it's used when stuff needs to be forced but there's no need for the stuff.
14:04:06 <Twey> What's the name for the one that does that but doesn't force?
14:04:13 <dons> yeah, or a final case in a pattern
14:04:18 <nolrai_FG> const?
14:04:24 <ksf> there's no non-forcing case in core.
14:04:26 <dons> let?
14:04:41 <dons> let allocates a suspension, case scrutinzes
14:05:12 <nolrai_FG> though it comes first in the stg code..__DEFAULT -> x; 0 -> y;}
14:05:47 <dons> the core pretty printer lists them in reverse order
14:05:50 <dons> it's a "feature"
14:06:15 <nolrai_FG> for goodness sake why?
14:06:59 <nolrai_FG> I mean it doesn't really matter, but..
14:07:00 <alatter> speaking of the core pretty-printer, has anyone gotten pcre-light to work on Mac OS 10.6? Is using mac-ports the right way to go?
14:07:12 <Twey> ksf: But user-level case is non-forcing, no?
14:07:21 <ddarius> Twey: Yes.
14:07:21 <dons> nolrai_FG: there's no good reason, afaik. it's a bug in the ppr
14:07:55 <ddarius> case x of y -> ... is almost identical to let y = x in ... (where y is a variable)
14:08:05 <ddarius> There should be a difference in the typing though.
14:09:33 <Twey> ddarius: So what does it translate to in Core?
14:10:10 <ddarius> It translates to let or is just inlined.
14:10:41 <Twey> Huh.
14:11:23 <nolrai_FG> ddarius: is there any difernce cause thats how my interpreter implements it. doesnt work yet though.
14:11:31 <ksf> a pattern is a pattern is a pattern
14:11:43 <ksf> no matter whether it's in a case, a function, let or monadic position
14:11:50 <ksf> ...well do-blocks call fail, but that's all.
14:13:09 <nolrai_FG> so is there a safe version of head, or do I just have to use cases?
14:13:27 <dmwit> :t listToMaybe
14:13:28 <lambdabot> forall a. [a] -> Maybe a
14:13:42 <dmwit> :t take 1
14:13:43 <lambdabot> forall a. [a] -> [a]
14:13:51 <nolrai_FG> I guess I could do listToMaybe and then fromMaybe? is that the best way?
14:14:06 <dmwit> How about
14:14:20 <dmwit> :t \def xs -> take 1 (xs ++ [def])
14:14:21 <lambdabot> forall t. t -> [t] -> [t]
14:14:22 <dmwit> err
14:14:27 <dmwit> :t \def xs -> head (xs ++ [def])
14:14:28 <lambdabot> forall t. t -> [t] -> t
14:14:35 <nolrai_FG> that works.
14:17:56 <SubStack> there doesn't seem to be an augment function in hmatrix >_<
14:22:21 <SubStack> oh it is called "horizontal concatenation"
14:25:12 <johnnowak> hello all. where's Control.Concurrent.STM gone? i don't see it at http://www.haskell.org/ghc/docs/latest/html/libraries/
14:26:00 <SubStack> johnnowak: it's in the stm package
14:26:07 <SubStack> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/stm/index.html
14:26:24 <johnnowak> SubStack: ah, thanks. seems the link in the documentation (and on wikipedia) is broken.
14:56:09 <tvs93> hey i'm getting a stack overflow error when i run something and i'm not sure how to prevent it
14:56:32 <damd> strict folding solves everything
14:56:41 <Lemmih> tvs93: Don't run it.
14:56:50 <tvs93> yeah
14:57:00 <Lemmih> .
14:57:04 <tvs93> is it possible to c+p code in here without lambdabot running it
14:57:12 <damd> yes
14:57:16 <ddarius> @hpaste
14:57:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:57:20 <tvs93> oh ok
14:57:22 <medfly> lol
14:58:36 <tvs93> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7318#a7318
14:58:42 <tvs93> yeah line 5 results in stack overflow
14:58:48 <tvs93> what would be the alternative to doing this?
14:59:36 <tvs93> that was my attempt to Project Euler 14 btw. http://projecteuler.net/index.php?section=problems&id=14
14:59:36 <Lemmih> tvs93: You're not strict enough in 'i'.
14:59:41 <tvs93> oh
14:59:50 <tvs93> i'm new to haskell. what does that mean?
15:01:03 <Lemmih> tvs93: Try: collatz' n i = i `seq` collatz' (ch n) (i+1)
15:01:29 <aavogt> a nice trick is to add a dummy guarded equation before everything else
15:01:29 <jon_of_arc> Hah, I had strictness problems with that one as well
15:01:34 <tvs93> what does `seq` do?
15:01:34 <kmc> i recommend:  collatz' n !i = collats' (ch n) (i+1)
15:01:39 <kmc> enabling GHC's BangPatterns extension
15:01:40 <sshc> tvs93: x `seq` y `seq` z `seq` foobar `seq` let x = y in x + y
15:01:53 <sshc> tvs93: that will cause x, y, and z to be evaluated *strictly* on the top level
15:02:22 <aavogt> collatz' n i | n `seq` i `seq` False = undefined; -- before the other equations
15:02:27 <sshc> tvs93: use deepseq if you want to completely evaluate something strictly
15:02:29 <kmc> tvs93, when evaluation of (a `seq` b) is forced, it will evaluate both a and b.  the value of (a `seq` b) is the value of b
15:02:57 <kmc> it's a somewhat low level trick to override the usual lazy evaluation
15:03:00 <sshc> > let x = undefined in const x 3
15:03:01 <lambdabot>   * Exception: Prelude.undefined
15:03:07 <sshc> oops
15:03:09 <sshc> > let x = undefined in const 3 x
15:03:10 <lambdabot>   3
15:03:16 <sshc> > let x = undefined in x `seq` const 3 x
15:03:17 <lambdabot>   * Exception: Prelude.undefined
15:03:22 <MissPiggy> > foo
15:03:23 <lambdabot>   Not in scope: `foo'
15:03:27 <sshc> > bar
15:03:28 <lambdabot>   Not in scope: `bar'
15:03:30 <MissPiggy> > Not in scope `Not'
15:03:31 <lambdabot>   <no location info>: parse error on input `in'
15:03:41 <MissPiggy> > <no location info>: parse error on input `no'
15:03:42 <lambdabot>   <no location info>: parse error on input `<'
15:03:45 <MissPiggy> > <no location info>: parse error on input `<'
15:03:46 <lambdabot>   <no location info>: parse error on input `<'
15:04:03 <sshc> > let x = [undefined] in const 3 x
15:04:04 <lambdabot>   3
15:04:08 <sshc> > let x = [undefined] in x `seq` const 3 x
15:04:09 <lambdabot>   3
15:04:22 <sshc> in this case, the contents of the list are not strictly evaluated, as seq only evaluates on the top level
15:04:27 <sshc> > let x = [undefined] in x `deepseq` const 3 x
15:04:28 <lambdabot>   Not in scope: `deepseq'
15:04:34 <sshc> looks like lambdabot doesn't have deepseq
15:04:38 <zakwilson_> There seem to be quite a few options for having a Haskell program talk to an SQL database. I'm curious as to whether there's one that's vastly more popular than the rest.
15:04:42 <aavogt> @let deepseq = rnf
15:04:42 <pikhq> Isn't it deepSeq?
15:04:43 <lambdabot>  Defined.
15:04:43 <kmc> sshc, try rnf
15:04:44 <sshc> you'll need the "deepseq" package from hackage
15:04:52 <sshc> cabal install --global deepseq
15:04:57 <kmc> rnf is standard iirc
15:05:06 <kmc> from Control.Parallel.Strategies
15:05:07 <sshc> kmc: the package that exports that depends on deepseq
15:05:08 <kmc> :t rnf
15:05:09 <lambdabot> forall a. (NFData a) => a -> Done
15:05:15 <dons> kmc: not 'standard' really, but folklore
15:05:27 <sshc> dons: did you see my message about loch?
15:06:25 <dons> yep, will have a look.
15:06:30 <sshc> thanks
15:08:12 <sshc> kmc: I thought rnf was defined in terms of deepseq, but, looking at it again, I know I was wrong.
15:08:53 <sshc> kmc: I still think that "x `deepseq` foo" is more elegant than "(rnf x) `seq` foo"
15:09:05 <ddarius> DeepSeq and NFData are just two different classes for the same thing.
15:09:14 <ddarius> foo `using` rnf
15:09:30 <tvs93> i took Lemmih's advice and changed it to  collatz' n i = i `seq` collatz' (ch n) (i+1) but i still get a stack overflow error
15:09:32 <ddarius> :t Control.Parallel.Strategies.using
15:09:33 <lambdabot> forall a. a -> Strategy a -> a
15:09:41 <tvs93> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7320#a7320
15:09:46 <sshc> ddarius: but then again, rnf is better for chaining
15:10:17 <Trollinator> Hi, i have this senseless little program. main = let Just x = Nothing in if x then return () else return ()
15:10:27 <sshc> um, actually not
15:10:50 <sshc> "x `seq` (rnf y) `seq` z" can be written as "y `deepseq` x `seq` z", placing y at the beginning
15:10:54 <Trollinator> if i compile it in ghc with -fwarn-incomplete-patterns, it doesn't give me a warning even though it's perfectly obvious that the pattern matching will fail.
15:10:54 <aavogt> why would you do nothing, Trollinator?
15:11:38 <Trollinator> I'm just trying to understand why it doesn't give a warning, aavogt
15:11:49 <sshc> > let Just x = Nothing in if x then return () else return ()
15:11:51 <lambdabot>   No instance for (GHC.Show.Show (m ()))
15:11:51 <lambdabot>    arising from a use of `M413303147...
15:12:12 <ddarius> Trollinator: let is not a case and let is a irrefutable match.  The pattern will never fail in the sense that a case pattern will fail.
15:12:25 <Lemmih> tvs93: Ah, the problem is with 'maximum'.
15:12:51 <Trollinator> so it's not possible to get a warning for this?
15:13:06 <dons> Trollinator: consider, main = let Just x = Nothing in if True then return () else return ()
15:13:37 <sshc> a warning for what?
15:13:50 <Lemmih> tvs93: Either compile the code with -O or use "Data.List.foldl1' max" instead of 'maximum'.
15:13:57 <sshc> you can't not patterm match against an irrefutable match, so the warning would do nothing
15:14:58 <dons> note we now also have -fwarn-simple-patterns:
15:15:05 <dons> "Causes the compiler to warn about lambda-bound patterns that can fail, eg. \(x:xs)->.... Normally, these aren't treated as incomplete patterns by -fwarn-incomplete-patterns."
15:15:21 <Phyx-> wow, ghc is acting soo weird today.. when you have a project consisting of file with different line endings
15:15:31 <dons> e.g. you get a warning for  f xs = [y | Just y <- xs]
15:15:55 <Trollinator> Ah, wonderful, that works.
15:16:02 <Trollinator> thanks, dons
15:16:21 <cheater3> hey guys, anyone got a CAS handy?
15:16:26 <dons> Trollinator: no worried.
15:16:27 <dons> s.
15:16:45 <cheater3> i'm trying to solve this but alpha is choking: a*log((1/b) + c) = 0 and a*log((2/b)+c) = 0.708 and a*log((3/b)+c) = 1
15:16:49 <dons> "Switching on -fwarn-simple-patterns will elicit warnings about these probably-innocent cases, which is why the flag is off by default."
15:16:55 <Trollinator> OK, i'm going to bed, good night.
15:17:17 <MissPiggy> you want to solve these simultaneously?
15:17:21 <cheater3> yes
15:17:40 <ski> dons : why would `[y | Just y <- xs]' invoke a warning ?
15:18:05 <MissPiggy> well I have no idea how to solve that sort of equation
15:18:12 <Phyx-> probably because xs could contain a Nothing in which case the match would fail
15:18:37 <ski> > [y | Just y <- [Just 0,Nothing,Just 2]]
15:18:38 <lambdabot>   [0,2]
15:18:41 <aavogt> @undo [y | Just y <- xs]
15:18:41 <lambdabot> concatMap (\ a -> case a of { Just y -> [y]; _ -> []}) xs
15:19:02 <cheater3> MissPiggy: then do not add noise :)
15:19:06 <MissPiggy> um
15:19:11 <monochrom> > 1/sqrt(2)
15:19:12 <lambdabot>   0.7071067811865475
15:19:21 <ski> Phyx- : so it's not partial, even when the pattern fails
15:19:39 <MissPiggy> cheater3 you're sort of confused this is a haskell IRC channel you are the one adding noise
15:20:05 <cheater3> chill out :)
15:20:17 <monochrom> Both of you.
15:20:38 <Phyx-> ski: my guess is that that works because of the monad instance for Maybe, but when you write the core code, you would have to analyze the value from xs, in which case you would have an incomplete case would you not?
15:21:10 <aavogt> it works because of how patterns in list comprehensions are desugared
15:21:23 <ski> Phyx- : no, list comprehensions (no longer) is defined through monads; it's just a property of how list comprehensions work
15:21:37 <aavogt> > [ () | 1 <- [1..10]]
15:21:38 <lambdabot>   [()]
15:21:47 <ddarius> @undo [ () | Just x <- Nothing]
15:21:48 <lambdabot> concatMap (\ a -> case a of { Just x -> [()]; _ -> []}) Nothing
15:22:04 <Phyx-> hmm, I thought list comprehensions were desugared into just monadic statements. Oh well, guess i'm wrong
15:22:25 <ddarius> Phyx-: They were in Haskell 1.4, but not in 98 or 2010.
15:22:28 <ski> Phyx- : `[y | Just y <- xs]' is probably desugared to something like `concatMap (\x -> case x of Just y -> [y]; _ -> []) xs'
15:22:34 <aavogt> it's the same thing, considering that   fail "hai" == []
15:22:49 <ski> (possibly not exactly that, but with the same semantics, anyway)
15:22:50 <Phyx-> ddarius: ah ok
15:23:28 * ski notes ddarius said more or less the same thing
15:23:31 <Phyx-> ski: but So that's just a property of how it's desugered is it not? if the default cause wouldn't be generated, then It would go horribly wrong
15:23:36 <ddarius> ski: Lambdabot did.
15:23:51 <ski> (ddarius : yes, but you triggered it :)
15:23:55 <ddarius> Phyx-: The default clause is always generated.
15:24:01 <ddarius> It's a blind syntactic transform.
15:24:41 <Phyx-> what was the reason again for removing generalized monad comprehentions?
15:24:50 <ddarius> Newbies.
15:24:56 <ski> "confusing errors for newbies", i think
15:25:10 <Phyx-> heh
15:25:22 <aavogt> so the problem is that, -fwarn-simple-patterns   doesn't consider any context for possibly failing patterns?
15:25:51 <tvs93> argh what's with the maximum function... maximum [1...1000000] yields a stack overflow error how do you avoid that?
15:26:00 <ski> it just should not consider patterns in generators in a list comprehension, imo
15:26:15 <ski> (general monad comprehensions would be a more complicated matter)
15:26:17 <Phyx-> tvs93: someone already said foldl1' max
15:26:17 <medfly> @src maximum
15:26:18 <lambdabot> maximum [] = undefined
15:26:18 <lambdabot> maximum xs = foldl1 max xs
15:26:23 <ddarius> tvs93: Compile with optimizations or don't use maximum because it's definition is broken.
15:26:24 <tvs93> oh i didn't see that
15:26:25 <tvs93> sorry
15:26:36 <aavogt> > [ a | let Just a = Nothing ]
15:26:37 <lambdabot>   [* Exception: <interactive>:1:139-154: Irrefutable pattern failed for patte...
15:26:38 <Phyx-> 00:13:02 < Lemmih> tvs93: Either compile the code with -O or use "Data.List.foldl1' max" instead of 'maximum'.
15:27:01 <ski> aavogt : and `let Just a = Nothing' there is not a generator :)
15:27:13 <ddarius> let translates to let.
15:27:31 <aavogt> I wasn't sure what you meant by generator
15:27:49 <ski> the generators have form `<pattern> <- <expression>'
15:27:50 <aavogt> it's an expression to the right of a  <-  ?
15:27:58 <MissPiggy> ddarius -- did you see that paper about geometry of optimal reduction?
15:28:05 <ski> (when they occur in list comprehensions)
15:28:14 <MissPiggy> http://img638.imageshack.us/img638/6677/picture3g.png
15:28:24 <MissPiggy> these are the rewrite rules for the calculus
15:28:26 <ddarius> MissPiggy: You mentioned it.  I didn't read it (unless I read it a long time ago, but I don't think so)
15:29:05 <MissPiggy> ddarius, well it's a simplification of Lampings algorithm, and they also talk about generalizing to linear lambda calculus
15:29:16 <MissPiggy> ddarius, I don't know how to implement it X[
15:29:29 <MissPiggy> (in haskell)
15:29:40 * Phyx- has finally finished modifying ghc's lexer files
15:29:45 <MissPiggy> maybe I should define a kind of graph rewrite system inside haskell
15:29:56 <Phyx-> if only these types weren't abstract I wouldn't have to modify the compiler :S
15:31:36 <jcapper> Hi, I'm wondering if anyone can tell me how to read in and render a PNG under cairo (gtk2hs)
15:31:51 <jcapper> I've done some google, but I've yet to find anything helpful
15:31:58 <jcapper> googling*
15:32:37 <jcapper> Even just a link to a relevant tutorial would be handy
15:33:09 <Phyx-> gn, thanks for the heads up on how list comprehensions are desugared, guess i should read 2010 when I get a chance to.
15:34:41 <Phyx-> hoogle "Char -> CWChar"
15:34:47 <Phyx-> @hoogle "Char -> CWChar"
15:34:48 <lambdabot> Parse error:
15:34:48 <lambdabot>   --count=20 ""Char -> CWChar""
15:34:48 <lambdabot>              ^
15:34:53 <Phyx-> @hoogle Char -> CWChar
15:34:53 <lambdabot> Did you mean: Char -> CWchar /count=20
15:34:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:34:54 <lambdabot> Prelude error :: [Char] -> a
15:35:03 <Phyx-> @hoogle Char -> CChar
15:35:04 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
15:35:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:35:04 <lambdabot> Prelude error :: [Char] -> a
15:35:28 <ski> (Phyx- : "read 2010" ?)
15:35:37 <Phyx-> ski: Haskell 2010
15:35:47 <ski> .. and that is ?
15:36:11 <Phyx-> the new haskell standard isn't it?
15:36:18 <ddarius> ski: Look at the topic.
15:36:26 <MissPiggy> isn't the topic a joke?
15:36:31 <ddarius> No.
15:36:33 <Phyx-> not afaik
15:36:40 <ski> .. oh
15:36:59 * ski doesn't think of topic often, due to not joining often
15:37:13 <sshc> ski: /topic
15:37:32 <Phyx-> lol, I was starting to think I was so tired I was making things up, good to know I'm not at that point yet
15:37:38 <MissPiggy> lol
15:38:01 <Phyx-> @hoogle CChar -> Char
15:38:02 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
15:38:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:38:02 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
15:38:11 <Phyx-> intuitive names
15:38:12 <ski> (sshc : yes, i know, it just wasn't in my consciousness)
15:39:15 <Phyx-> hmm.... I wonder why hoogle ranked the throwDyn so high.. i'm pretty sure there must have been better matches
15:39:30 <MissPiggy> "the study of roots of a polynomial  only has a meaning in the univariate case." -- tha's why you can't factorize multivariate polynomials?
15:39:47 <Phyx-> @hoogle Rational -> CLLong
15:39:48 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
15:39:48 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
15:39:48 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
15:40:38 <Phyx-> hmm don't think any of those would work...
15:40:47 <Phyx-> oh well, i'll look into it tomorow, gn
15:41:29 * ski . o O ( what, roots are meaningless for `x^2 + y^2 - 1 = 0' !? )
15:41:50 <tvs93> still confused foldl1 max [1..1000000] results in a stack overflow error too
15:42:10 <ski> > foldl1 max [1..1000000]
15:42:11 <ski> > foldl1' max [1..1000000]
15:42:12 <lambdabot>   * Exception: stack overflow
15:42:12 <lambdabot>   1000000
15:42:27 <nolrai_FG> @hoogle second
15:42:28 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
15:42:28 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
15:42:28 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
15:42:55 <ski> tvs93 : .. note that little "'" character ?
15:45:30 <dotyoyo> Trying to compile the Go Fish impl from resettacode.com.  Hugs works fine, but ghc spews undefined reference errors with mangled identifier names.
15:45:48 <dotyoyo> Looks like the appropriate modules are being imported.  Must be something else.
15:46:15 <Zao> dotyoyo: Do you mean rosettacode.org?
15:46:29 <Zao> As in, http://rosettacode.org/wiki/Go_Fish/Haskell
15:46:46 <dotyoyo> zao: Yes, rosettacode.org.  Thanks.
15:47:30 <Zao> Ooh, legacy module names. How quaint :)
15:48:00 * ski opposes both MagicUnderscore and FlexiblePartialApplication
15:48:11 <shortcircuit> dotyoyo: Yeah, the rosettacode.com domain is owned by another guy who isn't ready to launch his (unrelated) project yet. To deal with the confusion of .com not resolving, I set him up with some space on my server. :)
15:48:39 <Zao> dotyoyo: Builds fine here. What GHC are you on?
15:48:54 <dotyoyo> I'm using ghc 6.12.1
15:49:23 <dotyoyo> Hmm.  It works with ghc --make, but not without --make.
15:51:04 <Zao> dotyoyo: That sounds sane, as you're not providing any packages.
15:51:25 <Zao> Try feeding it say -package containers
15:51:39 <Zao> Or just --make, as you've discovered.
15:52:01 <dotyoyo> zao: OK.  Thanks.
15:52:18 <shortcircuit> dotyoyo: When you're done, could you preface that example with usage instructions?
15:52:34 <dotyoyo> shortcircuit: Sure.
15:52:57 <Zao> Note that containers is a package from after the base split.
15:53:26 <tumult> if i want to start adding tests with quickcheck to my project.. where the heck do i put them? a separate tests module?
15:54:04 <dibblego> I put them in the same module and export them with a appropriate haddock comment
15:54:06 <shortcircuit> Zao: I'm not particularly familiar with Haskell. Does that mean that "containers" is an external library (or Haskell's analog to such)?
15:55:51 <monochrom> external, indispensible
15:55:58 <Zao> shortcircuit: The base package used to contain lots of stuff. When the version was bumped to 4 (I believe), it was split into a bunch of packages, including containers.
15:56:17 <Zao> It's more separated than before, but still rather integral.
15:57:26 <dufflebunk> @pl \ (x, y) -> (x*cfactor, y*cfactor)
15:57:26 <lambdabot> (cfactor *) *** (cfactor *)
15:57:51 <shortcircuit> Zao: The reason I ask is that, on RC, we have a template called "library" which is helpful for identifying and cataloging dependencies on libraries. The vibe I get from what you're saying is that it's closer to, e.g. the std namespace in C++.
15:57:58 <MissPiggy> I just need a really good constraint solver in Hsakell
15:58:02 <monochrom> It worries that the two (*)'s are different.
15:58:20 <MissPiggy> win 13
15:58:23 <MissPiggy> oops sorry
15:58:57 <dufflebunk> monochrom: is that regarding the @pl ?
15:59:01 <monochrom> Yes.
15:59:26 <dufflebunk> I'm still trying to figure out how the *** works into it  *L*
15:59:34 <aavogt> this is due to a lack of rank 2 polymorphism ....
15:59:35 <Zao> @type (***)
15:59:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:59:53 <Zao> http://hackage.haskell.org/package/containers
15:59:59 <dufflebunk> I guess (,) counts as an arrow?
16:00:11 <monochrom> -> is an arrow
16:00:16 <RayNbow> trying to convert beautiful Haskell to C# is headache inducing... and the resulting code is damn awful
16:00:29 <ray> this is why we need infix arrow types
16:00:34 <monochrom> (f (***) g) (x,y) = (f x, g y)
16:00:40 <sshc> if a uniquely determines b (a -> b), then which of the following is true? 1) there can be two instances in which the a's are different but b is the same or 2) there can be two instances in which the a is the same but the b's are different
16:00:55 <aavogt> too many parens, monochrom
16:01:07 <monochrom> Oh haha
16:01:15 <ray> superstitious parens
16:01:17 <Zao> RayNbow: Accept the lesser of two evils and port it to F#?
16:01:37 <dufflebunk> monochrom: oh, ok.
16:01:53 <ski> actually
16:01:54 <ski> @src (->) (***)
16:01:55 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
16:01:59 <dufflebunk> In a few minutes I'll probably see how the type matches that result
16:02:15 <aavogt> sshc: do you have an intuition for what a function (as opposed to a relation) is?
16:02:16 <RayNbow> Zao: I'm not all too familiar with F# yet
16:03:09 <sshc> aavogt: this is a functional dependency
16:03:16 <aavogt> it's the same idea
16:03:32 <sshc> aavogt: so, in this case, the former?
16:03:33 <sshc> 1?
16:03:40 <ski> sshc : only the former could be true (depending on whether there's more FDs or not)
16:03:50 <sshc> ok, thanks
16:04:21 <ski> `class Foo a b | a -> b' implies that `forall a. unique b. Foo a b'
16:04:45 <ski> or, if you will, `forall a b0 b1. (Foo a b0,Foo a b1) => b0 = b1'
16:04:54 <sshc> "a -> b c" means the same as "a -> b, a -> c", right?
16:05:06 <ski> i think so
16:05:08 <sshc> I'm getting some depency conflicts and I'm trying to work out why
16:05:20 <sshc> and I also want to make sure I understand fundeps correctly
16:05:26 <ski> (i don't recall whether `a -> b c' is allowed or not, but if allowed, it ought to mean that)
16:05:28 <RayNbow> Zao: do you want to see the abomination I created? :p
16:05:50 <Zao> RayNbow: It's impossible to say no to such a tantalizing offer.
16:06:06 <RayNbow> Zao: http://tinypaste.com/d8f77
16:06:57 <asbyth> how do you increase the stack size in haskell?
16:07:06 <Zao> Cute.
16:07:08 <sshc> asbyth: try reading the RTS section
16:07:21 <sshc> absentia: of the GHC manual
16:07:45 <monochrom> RayNbow: I have adblock turned on, and the code part shows "using System;" one line only. :)
16:08:08 <monochrom> I cannot explain why it is not all-or-nothing.
16:08:34 * hackagebot upload: encoding 0.6.3 - A library for various character encodings (HenningGuenther)
16:08:36 <lpsmith> what happened to verboseCheck in quickcheck 2?
16:08:41 <tumult> are quickcheck tests typically in the same module/file as the functions they test, or in a separate one?
16:09:00 <RayNbow> monochrom, http://raynbow.pastebin.com/f3dcf2ddb <-- does this mirror work?
16:09:12 <lpsmith> tumult, it can work either way;  I tend to put them in a seperate module myself
16:09:32 <tumult> which is more typical? :)
16:09:43 <lpsmith> I'm not sure
16:09:47 <tumult> oh ok
16:09:53 <tumult> well as long as it's not a blasphemy to put them separate
16:10:15 <ski> (monochrom,RayNbow : hehe, i get everything in one large rectangle block of text, (presumably) original newlines stripped, and lines breaked at right margin)
16:10:40 <lpsmith> I like seperate modules because then the main module doesn't have to depend on QuickCheck.  On the other hand,  the seperate module can't employ functions internal to the module you are testing
16:11:08 <lpsmith> so how can I see what the test data looks like in quickCheck 2?
16:18:23 <AmiableCitizen> sbahra: Are you there?
16:20:47 <MissPiggy> Is there a good constraint solver in haskell
16:28:32 <SubStack> MissPiggy: monadiccp looks interesting
16:29:09 <MissPiggy> SubStack oh it does!! cheers!
16:29:41 <SubStack> odd that it doesn't show up in cabal list constraint
16:35:24 <lpsmith> w00t,  I broke hayoo!
16:35:35 <MissPiggy>     Warning: Module `Prelude' is deprecated:
16:35:37 <MissPiggy> hummm......
16:35:44 <sbahra> AmiableCitizen, yes.
16:35:54 <MissPiggy> cabal: Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda
16:35:54 <sbahra> AmiableCitizen, AJ?
16:35:57 <MissPiggy> weird stuff
16:36:01 <AmiableCitizen> sbahra: Yes.
16:36:09 <sbahra> AJ DJ.
16:36:25 <AmiableCitizen> sbahra: I'm reading some more before I ask questions, though. Just wondering if you were available for them
16:36:29 <sbahra> AmiableCitizen, what's up?
16:36:29 <SubStack> time to work on my polymorphic genetic programming experiment >:D
16:36:55 <sbahra> AmiableCitizen, for now, yes. I need to get back to work. Took a little break.
16:36:56 <MissPiggy> has anyone used monadiccp
16:37:16 <sbahra> AmiableCitizen, Haskell-related or for that threads library?
16:37:33 <jmcarthur> SubStack: polymorphic genetic programming?
16:37:44 <jmcarthur> i've looked into it before, but never started coding
16:37:53 <jmcarthur> curious what your planned design is
16:38:16 <SubStack> well basically what PolyGP does, except on raw haskell and not just a DSL with 3 types
16:38:22 <jmcarthur> actually, i didn't look into polymorphic GP per say, just typed genetic programming which happened to have polymorphism
16:38:37 <jmcarthur> ah
16:38:55 <SubStack> I was disappointed with PolyGP once I actually started looking at the code
16:39:05 <SubStack> it's such an interesting premise
16:39:07 <jmcarthur> i am usually disappointed with such libraries
16:40:23 <jmcarthur> anyway, i said in #googleai already, but if anybody is interested in a new haskell starter package for the google ai challenge here's one i just put together: http://patch-tag.com/r/jmcarthur/googleai-haskell-starter/snapshot/current/content/pretty
16:40:56 <gwern> 'Since the compiler’s behavior is unconstrained when the program executes an operation with undefined behavior, it can do anything it wants to, including crash the program, cause it to send email to your grandmother, or whatever.  In this case, the compiler elects to choose the most efficient implementation for Case 2: the same behavior as Case 1, permitting the cases to be collapsed into a single “return 1.”
16:41:03 <gwern> As a programmer, it’s easy to look at this kind of compiler behavior, where undefined behavior is cunningly exploited to produce faster code, and conclude that the compiler is essentially evil.  This is probably not far from the truth, but this is the worldview promoted by the C and C++ standards.  For people who really dislike it, Java and most assembly languages are refreshingly free of undefined behaviors.'
16:41:35 <SubStack> jmcarthur: prettier than mine, which I wrote before the starter was published
16:42:00 <jmcarthur> SubStack: this is my second starter. my first wasn't publishable though since it had details specific to my bot in it
16:42:25 <gwern> huh. alan kay likes lazy evaluation: http://kazimirmajorinc.blogspot.com/2010/02/alan-kay-on-fexprs.html
16:42:29 <gwern> that's unexpected
16:42:31 <jmcarthur> i thought about writing some documentation for it, but i think i'll only bother if it's requested by somebody
16:43:00 <MissPiggy> this monadiccp is great
16:43:17 <jmcarthur> MissPiggy: is that a package on hackage?
16:45:22 <jmcarthur> SubStack: sloccount says my Tron module is worth $2738, so i hope somebody pays up ;)
16:45:38 <MissPiggy> yes
16:45:46 <aavogt> what's the rate?
16:46:09 <jmcarthur> aavogt: (average salary = $56,286/year, overhead = 2.40)
16:46:17 <jmcarthur> MissPiggy: ah constraint programming. cool
16:46:59 <ddarius> gwern: FEXPRs are more than just lazy evaluation.
16:47:12 <gwern> ddarius: do go on
16:47:50 <ddarius> FEXPRs essentially receive the source code of their arguments as parameters.
16:48:05 <ddarius> E.g. quote would be something like (define-fexpr (quote x) x)
16:49:56 * MissPiggy thinks I should connect up Control.CP.Herbrand.Herbrand with Control.Monad.LogicT and see what happens
16:50:06 <MissPiggy> Control.Monad.Logic*
16:50:26 <ddarius> @google typed logical variables in haskell
16:50:28 <lambdabot> http://citeseer.ist.psu.edu/332855.html
16:51:30 <gwern> ddarius: that for me?
16:54:01 <aavogt> jmcarthur: hmm, sloccount seems to say stuff takes ~3 person-months when it was done in about 1/6 of that time
16:54:18 <MissPiggy> I can't figure out how to use it thuogh
16:54:32 <jmcarthur> aavogt: yeah, sloccount isn't really the smartest tool in the box
16:55:12 <aavogt> so maybe your Tron module is only worth about $400
16:55:30 <jmcarthur> still worth it. it only took me like a couple hours to write
16:55:37 <jmcarthur> ;)
16:56:27 <jmcarthur> counting debugging because i was stupid somewhere
16:56:32 <SubStack> jmcarthur: sloccount also says all the stuff I've written for school is worth something > $1 million
16:56:38 <monochrom> hahahaha
16:56:49 <jmcarthur> SubStack: SELL IT
16:57:10 <SubStack> if only I had a buyer!
16:57:29 <SubStack> unfortunately there is no market for random scripts and experiments
16:57:40 <gwern> SubStack: then patent it all; a troll will buy it
16:57:51 <SubStack> oh no patents
16:58:06 <SubStack> although I somewhat want the trolls to succeed
16:58:19 <aavogt> you can contribute
16:58:22 <SubStack> so they ruin it for everyone
16:58:50 <SubStack> and software patents go away
16:59:12 <aavogt> though it isn't a zero sum game... I think money can be shifted around to lawyers
16:59:32 <monochrom> I know how you can sell it. Go to those hire-a-coder sites, hunt for homework help, sell your code as solution.
17:01:12 <Dark_Shikari> aavogt: negative sum game?
17:01:35 <gwern> arms race
17:01:45 <aavogt> Dark_Shikari: as in the total benefits are not fixed
17:02:30 <aavogt> so depending on what you do, the average wealth or standard of living could be higher
17:04:06 <monochrom> haskell is so much easier
17:12:16 <MissPiggy> the whole archetecture of this lib is so confusing
17:18:50 <Cale> MissPiggy: Which one?
17:18:58 <MissPiggy> Cale,
17:19:04 <MissPiggy> http://hackage.haskell.org/package/monadiccp
17:19:26 <MissPiggy> I'm just trying to factor an integer with it and I've been through almost all these submodules
17:19:39 <jaj> hi
17:19:41 <Cale> Oh, futuristic types.
17:20:30 <SubStack> Control.CP.Solver looks like the meat of it
17:20:37 <jaj> does anybody know how I could do "distributivity" on tuples? I have this: ((1,2),a) and I'd like to have [(1,a),(2,a)]
17:20:40 <SubStack> add constraints and run
17:20:49 <MissPiggy> okay I'll try and do nqueens first
17:20:58 <jaj> any elegant existing function for this?
17:21:06 <Cale> jaj: Nope, but you can just pattern match.
17:21:12 <jaj> Cale: ok thanks
17:21:33 <Cale> > let ((x,y),z) = ((1,2),3) in [(x,z),(y,z)]
17:21:34 <lambdabot>   [(1,3),(2,3)]
17:21:38 <Cale> ^^ like that
17:22:12 <Cale> Obviously that only works with tuples of one particular size, but tuples are fixed size anyway
17:22:16 <jaj> clean
17:22:37 <jaj> oops
17:22:58 <jaj> I meant "great" but misplaced fingers on a dvorak keyboard can turn "great" into "clean" :)
17:24:50 <Cale> haha, interesting :)
17:25:04 <SubStack> you could uncurry (curry (:)) probably
17:25:35 <c_wraith> what are people's thoughts on internal modules in packages in public, even if they could be used to break all the guarantees the main interface provides?
17:25:38 <SubStack> somehow...
17:26:22 <c_wraith> @pl ((x,y),z) -> ((x,z),(y,z))
17:26:22 <lambdabot> (line 1, column 11):
17:26:22 <lambdabot> unexpected ">" or "-"
17:26:22 <lambdabot> expecting variable, "(", operator or end of input
17:26:37 <c_wraith> does pl not handle nested pairs?
17:26:46 <c_wraith> oh, I forgot the \
17:26:51 <c_wraith> @pl \((x,y),z) -> ((x,z),(y,z))
17:26:52 <lambdabot> uncurry (uncurry ((. (,)) . ap . ((,) .) . (,)))
17:27:22 <MissPiggy> bleh I just can't figure this out
17:28:07 <MissPiggy> the paper use @\== but the library uses @/=
17:28:22 <MissPiggy> the paper uses :- too but I can't find the equivalent!
17:29:17 <MissPiggy> http://hackage.haskell.org/packages/archive/monadiccp/0.6.1/doc/html/src/Control-CP-ComposableTransformers.html
17:29:23 <MissPiggy> this has
17:29:24 <MissPiggy> data Composition es ts solver a where (:-) :: (CTransformer c1, CTransformer c2,
17:29:28 <MissPiggy> but the library doesn't export it?
17:30:52 <MissPiggy> is this a bug in the libarry
17:31:08 <copumpkin> @remember hobophobe So, I can only conclude that Haskell is a memetic virus, and monads are the eggs it lays out in innocent programming forums to entice others to become infected.
17:31:08 <lambdabot> Okay.
17:31:49 * MissPiggy weeps
17:32:36 <SubStack> > uncurry (liftM2 (,)) $ second (:[]) $ first (uncurry (:) . second (:[])) ((1,2),3)
17:32:38 <lambdabot>   [(1,3),(2,3)]
17:32:40 <SubStack> bwahaha
17:32:50 <copumpkin> :o
17:33:09 <MissPiggy> solve bfs fs $ nqueens 8
17:33:16 <MissPiggy> just gives me a massive type error
17:33:28 <MissPiggy> I don't get, I just copied it out the paper
17:33:43 <SubStack> I can't believe I understand that.
17:33:45 <ddarius> The paper is probably out of date.
17:33:48 <SubStack> the haskell virus has hit me hard
17:34:20 <MissPiggy> ddarius but I can't figure out how to update :(
17:34:51 * copumpkin goes pof!
17:35:43 <c_wraith> pof?  he misspelled his disappearing act.
17:38:31 <MissPiggy> I have toask
17:38:41 <MissPiggy> if you were wanting to use this library, how would you go abount learning to use it?
17:38:45 <jaj> hpaste not working?
17:39:18 <monochrom> @where hpaste
17:39:18 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
17:39:22 <monochrom> Try the second one.
17:39:50 <monochrom> hpaste must be going out with date
17:40:21 <aavogt> I think it's been down for a while
17:40:30 <monochrom> It was up earlier today.
17:41:02 <MissPiggy> what does this mean?
17:41:03 <MissPiggy> Elem  q ~ (Label  solver, Tree  solver (CForResult  c), CTreeState  c)
17:43:04 <jaj> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7330#a7330
17:43:24 <jaj> I'd like to generate the graph above with fgl and I need to generate it
17:43:35 <jaj> so I wrote this function to generate the edges
17:44:16 <jaj> but I have the feeling like it's not very elegant
17:45:40 <kmc> MissPiggy, that's a type equality constraint
17:45:48 <aavogt> MissPiggy: type equality, see http://haskell.org/haskellwiki/GHC/Type_families
17:46:29 <kmc> it goes in a context like a typeclass constraint
17:46:46 <kmc> but instead of saying that a type has an instance of a class, it says that two type expressions represent the same type
17:48:43 <hasenov> hello, does anyone know what the ~ does in pattern matching?
17:49:19 <MissPiggy> this is weird
17:49:21 <MissPiggy> foo (true :: Tree (FDWrapper OvertonFD) ())
17:49:22 <MissPiggy> that works
17:49:27 <MissPiggy> and foo = solve [] it
17:49:36 <MissPiggy> but solve [] it (true :: Tree (FDWrapper OvertonFD) ())  doesn't work
17:50:14 <doserj> jaj: mkSubEdge n m = zip n m ++ zip (tail n) m ?
17:50:39 <hasenov> > let (h, ~(_:t)) = span (<3*3) [5,7,8,9,10,11]
17:50:40 <lambdabot>   not an expression: `let (h, ~(_:t)) = span (<3*3) [5,7,8,9,10,11]'
17:51:47 <MissPiggy> foo :: Tree (FDWrapper OvertonFD) a -> (Int, [a])
17:51:47 <MissPiggy> foo x = (solve [] it :: (Solver s) => Tree s a -> (Int, [a])) x
17:51:49 <MissPiggy> that seems to work
17:52:28 <Phyx-> is there an easy way to convert a Char into a CWchar?
17:54:38 <hasenov> it can't be evaluated in lambdabot but it seems that (h, ~(_:t)) = span (<3*3) [5,7,8,9,10,11] & (h, (_:t)) = span (<3*3) [5,7,8,9,10,11] produce the same thing
17:59:02 <kmc> hasenov, it makes an irrefutable pattern
17:59:11 <doserj> > let (h, ~(_:t)) = span (<3*3) [5,7,8,undefined] in take 3 h
17:59:12 <lambdabot>   [5,7,8]
17:59:17 <doserj> > let (h, (_:t)) = span (<3*3) [5,7,8,undefined] in take 3 h
17:59:18 <lambdabot>   * Exception: Prelude.undefined
17:59:57 <kmc> an irrefutable pattern always matches, and does not perform any evaluation of the thing being matched
18:00:24 <MissPiggy> > foo (exist 2 (\[x,y] -> do (x @* y) @= 15 ; return (x,y)))
18:00:24 <MissPiggy> (4,[(Term (FDVar {unFDVar = 0}),Term (FDVar {unFDVar = 1}))])
18:00:24 <lambdabot>   Not in scope: `foo'Not in scope: `exist'Not in scope: `@*'Not in scope: `@='
18:00:27 <kmc> if one of the variables bound by the pattern is forced, then and only then will it do the match, and throw an exception if it fails
18:00:41 <MissPiggy> seems to do something but not the right thing ?
18:00:57 <kmc> i believe the ~ annotation is not useful in let, where, or top level, because those patterns are always irrefutable
18:01:19 <kmc> it is useful in a lambda (or function argument sugar) or in case
18:02:21 <kmc> > (\(x:xs) -> ()) []
18:02:22 <lambdabot>   * Exception: <interactive>:1:134-146: Non-exhaustive patterns in lambda
18:02:23 <kmc> > (\~(x:xs) -> ()) []
18:02:24 <lambdabot>   <no location info>: parse error on input `->'
18:02:32 <kmc> > (\(~(x:xs)) -> ()) []
18:02:33 <lambdabot>   ()
18:04:33 <ddarius> kmc: It's not useful at the top-level of such patterns.
18:06:08 <MissPiggy> I am completely lost
18:07:46 <kmc> on what?
18:08:10 <kmc> ddarius, you mean it can be useful nested within, say, a let-bound pattern?
18:08:13 <kmc> can you give an example?
18:09:12 <ddarius> > let (x, (Just y)) = (3, Nothing) in x
18:09:13 <lambdabot>   * Exception: <interactive>:1:141-168: Irrefutable pattern failed for patter...
18:09:16 <ddarius> > let (x, ~(Just y)) = (3, Nothing) in x
18:09:17 <lambdabot>   3
18:10:33 <kmc> ah, i see
18:10:33 <ddarius> And technically with bang patterns, 'let ~(p) = M in N'  -->  'let p = M in N' is no longer a safe transformation.
18:10:43 <kmc> it can matter if you ask for some variables and not others
18:10:45 <kmc> thanks
18:10:53 <MissPiggy> I don't know if this library maybe is just too complicated for stupid me to use
18:11:18 <hasenov> thanks kmc, I got the example from http://haskell.org/haskellwiki/Prime_numbers#Postponed_Filters_Sieve
18:12:35 <ddarius> > let ~(!(~(!(~(!True))))) = False in 3
18:12:36 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
18:13:07 <Hunner> :t uncurry . uncurry
18:13:08 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
18:13:22 <MissPiggy> someone should write an monadiccp tutorial
18:13:55 <Hunner> @hoogle (a, b), c) -> (a, b, c)
18:13:56 <lambdabot> Parse error:
18:13:56 <lambdabot>   --count=20 "(a, b), c) -> (a, b, c)"
18:13:56 <lambdabot>                    ^
18:14:00 <Hunner> @hoogle ((a, b), c) -> (a, b, c)
18:14:00 <lambdabot> No results found
18:14:13 <ddarius> There are no standard functions on triples.
18:14:28 <ddarius> Hunner: Just write a lambda expression.  That's the most readable thing.
18:14:34 <Hunner> k
18:14:56 <ddarius> @djinn ((a,b),c)->(a,b,c)
18:14:56 <lambdabot> f ((a, b), c) = (a, b, c)
18:19:22 <ian__> 21:13 <      lambdabot > f ((a, b), c) = (a, b, c)
18:19:22 <ian__> 21:14 -!- doserj [~doser@28.Red-83-49-149.dynamicIP.rima-tde.net] has quit [Quit: Verlassend]
18:19:33 <ian__> sorry
18:25:49 <MissPiggy> hahaha
18:26:02 <MissPiggy> "To get started, the examples directory shows how to model a number of well-known problems. "
18:26:06 <MissPiggy> http://tomschrijvers.blogspot.com/2009/10/release-06-of-monadic-constraint.html
18:26:10 <MissPiggy> that would have saved me some time
18:33:30 <MissPiggy> can't even get the examples to work
18:34:54 * SubStack encounters that problem quite often
18:35:22 <MissPiggy> it just says Solver type required
18:35:42 <MissPiggy> so much for 'if it typechecks it works'
18:36:31 <c_wraith> oh, that's easily false once your code gets complex enough
18:36:51 <MissPiggy> yeah it bugs me that people keep saying that slogan because I WISH it was true for me
18:37:30 <c_wraith> I'm working on a data structure..  It's easy for the algorithms to do the wrong thing with the right type.
18:39:05 <ddarius> c_wraith: Just means you need more complex types.
18:39:56 <SubStack> my rotation matrices are going non-singular on me :|
18:40:07 <SubStack> probably the wrong major form or something like that
18:40:39 <ddarius> Rotation matrices are supposed to be non-singular.
18:41:04 <SubStack> well something else is amiss then
18:42:09 <MissPiggy> yay
18:42:12 <c_wraith> ddarius: If I could figure out how to get the rest of the structural invariants into the type, that *still* wouldn't cover the behavioral constraints the type should have.
18:42:19 <MissPiggy> I factored a order 4 polynomial using monadiccp
18:42:44 <ddarius> c_wraith: With complex enough types, you can just put the behavioral constraints into the type.
18:43:14 <ddarius> SubStack: Perhaps you meant they are becoming singular, or what makes you think something is wrong?
18:43:21 <c_wraith> ddarius: sure, but at that sort of agda-like level, the type is...  rather verbose.  :)
18:43:24 <SubStack> the scale is majorly off
18:43:46 <SubStack> and they only get smaller with additional multiplications
18:44:24 <SubStack> seeing if transposing these matrices gets me anywhere
18:44:30 <ddarius> SubStack: Well there is numerical drift with matrix multiplications (unless you are using a type like CReal or Rational), but usually that manifests itself as some minor shearing/scaling changes that can become significant.
18:44:48 <ddarius> If you are getting big differences quickly, you probably have an error somewhere.
18:47:26 <MissPiggy> this is my algorithm for factoring polynomials of order n: pick two arbitraty polynomials whos orders add to n, multiply them and equate that with the polynomial you want to factor: solve the linear diophantine equations that result
18:47:45 <MissPiggy> I think it is probably the worst possible correct algorithm for factoring polynomials
18:47:53 <MissPiggy> (over the integers)
18:47:58 <gwern> aren't linear diophantine equations unsolvable in general?
18:48:08 <gwern> (or am I thinking of something else)
18:48:17 <ddarius> gwern: Well you can't factor arbitrary polynomials in general.
18:48:24 <MissPiggy> you can't??
18:48:35 <ddarius> MissPiggy: Not non-trivially.
18:48:40 <MissPiggy> I mean what about univariate ones?
18:48:44 <gwern> MissPiggy: something in that area of stuff is connected to the halting problem
18:49:26 <ddarius> MissPiggy: Fully factoring a polynomial is equivalent to solving it.  There is no general (algebraic) way of solving polynomials of degree 5 or higher.
18:49:31 <MissPiggy> can't you jst do gaussian elimination on the system?
18:50:09 <MissPiggy> ddarius: but what about factoring it into irreducibles over the integers (for example x^2-2 is already factored)
18:50:35 <ddarius> gwern: Definitely solving general Diophantine equations is undecidable.
18:51:08 <yin> hello!
18:51:13 <MissPiggy> x^n + y^n = z^n there's a diophantine
18:51:24 <MissPiggy> hi yin
18:51:32 <yin> hello MissPiggy
18:52:24 <MissPiggy> gwern [edit] Hilbert's tenth problem
18:52:36 <yin> Anybody familar with calculus of inductive constructions? too hard to find someone non-sleeping in #coq ;-)
18:52:44 <MissPiggy> yin yeah a bit why?
18:53:14 <ddarius> If you guys are going to start talking about it, why not take it to #coq.
18:53:43 <yin> ddarius: sure. you want to join? ;-)
18:54:20 <ddarius> I've never used Coq.
18:54:40 <kingping> moin
18:58:44 <MissPiggy> pretty sure linear systems of diophantines are decidible
18:59:02 <MissPiggy> hmm no it's a bit tricky to show that
18:59:50 <gwern> wonder what the weakest diophantines Chaitin proved were undecidable?
19:00:07 <kmc> https://secure.wikimedia.org/wikipedia/en/wiki/Matiyasevich%27s_theorem#Matiyasevich.27s_theorem
19:00:32 <gwern> ! another ssl user
19:00:42 <kmc> thanks to xmonad
19:01:05 <gwern> haha. I changed that you know
19:01:11 <kmc> haha
19:01:16 <kmc> cool
19:01:26 <gwern> I figured it was silly to make everyone go through ssl when only I used it
19:02:30 <monochrom> xmonad makes you use https urls?
19:04:05 <MissPiggy> kmc, just wondering if you know a book which covers matiyasevich's theorem nicely?
19:04:16 <MissPiggy> because that sounds really good ..
19:04:40 <kmc> i don't :/
19:21:05 <aavogt> monochrom: yeah
19:21:49 <monochrom> strange. it is just a window manager.
19:21:51 <aavogt> at least if you used some extension that brings up a prompt for searching some websites
19:22:44 <aavogt> maybe it isn't
20:12:23 <tomberek> hi
20:13:28 <blackh> tomberek: Hello!!
20:14:35 <tomberek> i've been trying to write some non-trivial haskell, but I seem to be so ingrained into OOP that I'm just remaking those features... is that ok, or should I rethink my problem.... and any suggestion on how to go about rethinking it?
20:16:00 <blackh> tomberek: It does take a little while to un-OOP yourself, but I've done it, so anyone can.  What sort of program are you writing?
20:17:04 <blackh> tomberek: The trick, I think, is to resist the temptation to store your data somewhere, and try to think in terms of the overall data flow of the program.
20:17:11 <tomberek> neural networks... and it lends itself so well to objects and inheritance. My thought was to view a neural network as a function on a vector
20:18:02 * ddarius has never considered inheritance particularly useful for neural networks.
20:18:13 <tomberek> blackh: can you expand on "resist the temptation to store your data somewhere"?
20:18:32 <tomberek> ddarius: i'd love some suggestions on how to go about it in a haskell-way
20:18:41 <ddarius> (Admittedly, I rarely consider inheritance particularly useful at all.)
20:19:17 <tomberek> ddarius, inheritance is a great way to start with a basic feature set, and add more with minimal boilerplate
20:19:46 <tomberek> but in haskell, it doesn't seem to work that way
20:19:59 <ddarius> In my opinion, it is neither a good way let alone the best way to do such.
20:20:06 <aavogt> implementation or interface inheritance?
20:21:11 <tomberek> ddarius: ok, can you suggest anything?  i was thinking of having a typeclass for Neuron and on for NeuralNet.. so people can create their own instances with different activation functions, evaluation strategies, etc...
20:23:49 <tomberek> aavgot: I want to take advantage of an interface inheritance from a graph library (such as fgl) and also create an implementation inheritance for others to create new kinds of nets.
20:24:09 <ddarius> tomberek: Why not make a "neuron making" function that simply takes an activation function, and so forth.
20:24:41 <ddarius> tomberek: One way to arrive at a design like this is to start with a concrete example and abstract (lambda abstract) from there.
20:25:10 <ddarius> The end result will likely be more flexible and have a clearer structure than an (implementation) inheritance hierarchy.
20:26:04 <tomberek> ddarius: something like (a->a)->([a]->a)->(a->b->a)->[a]->[b]->a   where inputs are activation, combine and weight functions?
20:26:17 <ddarius> tomberek: Sure.  You can group them into records if you like.
20:26:45 <ddarius> @hackage astar
20:26:45 <lambdabot> http://hackage.haskell.org/package/astar
20:26:54 <ddarius> That package gives an example of such a structure.
20:27:44 <tomberek> ddarius: how can I group that into records?
20:29:33 <aavogt> data NNParams a = NNParams { activation :: a -> a, ... }
20:30:19 <tomberek> ok... one sec
20:30:39 <ddarius> You can choose a more illustrative name than NNParams if one fits.
20:31:51 <tomberek> is hpaste down?
20:33:00 <tomberek> so something like this:: http://haskell.pastebin.com/d7cb6291e
20:36:03 <tomberek> or http://haskell.pastebin.com/m3c564fd9
20:36:08 <ddarius> tomberek: You can probably (but it may not be worthwhile) abstract from the Signal type, i.e. make it a type variable.  Also, you have a syntax error in the pattern for neuronToFunc
20:37:33 <tomberek> yeah, that' a bad pattern match,,, i can fix that.....  but is that on the right track?
20:39:55 <blackh> tomberek: If every neuron has the same combine function you could pass that as an argument to your evaluator.
20:40:06 <ddarius> tomberek: More or less, yes.
20:40:06 <ddarius> Note now how easy it is to make families of neurons, e.g. if you want ones like the sigmoid one, i.e. using sum and (*), but with a different activation function, that is trivial.
20:40:26 <tomberek> that's true,, i like that... how's this:
20:41:10 <tomberek> http://haskell.pastebin.com/m36009b73
20:43:14 <blackh> tomberek: Can I ask a couple of Q's? Does the "charge" accumulate in the network (that is, do you need to maintain that as state)? And, is it a graph or tree structure (does it have cycles)?
20:43:29 <tomberek> i've been hung up on using typeclasses....  because I thought that storing each Neuron's functions would take up much more memory that having those functions be associated with the typeclass....
20:44:30 <tomberek> blackh: I want that to be up to the implementer... so a cyclic structure would need state... and so I think a graph is the best way to go.... but not all implementations will have state
20:44:30 <ddarius> Neurons, as defined in your pastes, don't have any state themselves so there is (or need be) only "one" actual neuron object of any particular type.
20:46:20 <ddarius> In a somewhat closer to typical (naive) implementation, the weights would be per neuron and the overhead per neuron would be more or less identical to the OO case.
20:47:19 <tomberek> ddarius: ok, I was thinking an edge and node labeled graph would store the neurons and the weights
20:49:57 <blackh> tomberek: To maintain state, you can either think of a neuron as input -> state -> (output, state') ... or....
20:50:22 <tomberek> state monad possibly?
20:50:38 <blackh> you could think of it as ... newtype Neuron input output = Neuron (input -> (output, Neuron))
20:50:38 <ddarius> Well the type blackh described is equivalent to input -> State state output
20:51:21 <tomberek> blackh: i don't understand that second one
20:52:04 <blackh> tomberek: It's a recursive type... it's a function that returns a new "copy" of itself with possibly different internal state (not visible from the outside)
20:52:54 <tomberek> interesting
20:53:37 <blackh> tomberek: That way lends itself to the use of arrows, but you can use it directly like that if you don't mind a bit of unwrapping of newtypes
20:54:42 <tomberek> from my (very little) understanding of arrows, they would control the computations in a graph/net very well
20:57:21 <blackh> The simplest way to deal with a graph (rather than a tree) is to use an IntMap or similar.
20:57:44 <blackh> If you've got a tree structure, then it's a bit simpler because you can make it into a big expression
20:58:45 <tomberek> blackh: i found fgl which is a package which uses IntMap for one of its graph inplementations
20:58:58 <tomberek> Data.Graph.Inductive.PatriciaTree
20:59:20 <ddarius> Note that astar package handles any graph type without depending on any of them.
21:00:07 <tomberek> i did notice... and that's the sort of implementation independent feature I want to build into my neural network library
21:02:40 <tomberek> ddarius: my previous attempts were on this path:http://haskell.pastebin.com/m5ca30883
21:09:36 <tomberek> eh?
21:12:38 <tomberek> ddarius: what exactly is the difference between that typeclass approach and data with records approach?
21:13:58 <blackh> tomberek: The typeclass approach is possibly a bit less flexible.  Generally speaking, you should always use plain functions in preference to typeclasses unless you have some specific reason to use type classes.
21:14:29 <tomberek> blackh: ok,, then I have to ask, what would a reason like that be?
21:15:21 <tomberek> blackh: i thought I could write a state-less neuron and net, then have a state neuron and net be an instance of it (but with more features)
21:16:17 <blackh> That's the sort of thing you would normally make out of polymorphic functions.
21:16:57 <blackh> (I am trying to think of an answer to your question...)
21:18:11 <o-_-o> hey guys
21:18:21 <blackh> OK... If you use typeclasses, then your neurons are going to be a bit monolithic.  You won't be able to easily compose different parts of the functionality - you'll have to make a new typeclass for each new type of neuron.
21:18:43 <o-_-o> I am trying to learn types, I have defined a type as
21:18:45 <o-_-o> data FuncMap = Fm [Float] (Float -> Float) deriving (Show)
21:19:09 <blackh> The user of your library would have to make long type classes whenever they wanted to create something new instead of composing them out of suitable parts.
21:19:10 <o-_-o> but it fails to compile saying there is no instance of Show for (Float -> Float)
21:19:17 <blackh> long instances, I mean
21:19:24 <tomberek> o: i don't think you can derive that Show
21:19:50 <tomberek> a function (Float->Float) has no way to be "Show"ed
21:19:57 <blackh> Type classes are not the same thing as OO classes at all.
21:19:59 <o-_-o> but can I define a dummy show for (Float -> Float) which prints a dummy string ?
21:20:05 <o-_-o> like hello ?
21:20:22 <blackh> o-_-o: The short answer is no, you can't.
21:20:22 <tomberek> o: yes
21:20:26 <tomberek> uh
21:20:40 <blackh> You probably could, but it wouldn't work very well.
21:20:49 * dmwit suggests another alternative
21:20:55 <aavogt> > (1+) :: Float -> Float
21:20:56 <lambdabot>   -0.375->
21:20:57 <lambdabot>    0.625
21:20:57 <lambdabot>  -0.75->
21:20:57 <lambdabot>    0.25
21:20:57 <lambdabot>  -1.5->
21:20:59 <lambdabot> [5 @more lines]
21:21:08 <dmwit> Roll your own Show instance of FuncMap instead of rolling your own Show instance of (Float -> Float).
21:21:15 <dmwit> It shouldn't be very hard.
21:21:18 <tomberek> can't he do somehting like (Float->Float) -> String  .... yeah, what dmwit said
21:21:21 <ddarius> That type class approach means you can only have one "neuron" per signal type which doesn't make any sense.
21:21:28 <dmwit> show (FuncMap xs _) = "FuncMap " ++ show xs
21:21:33 <ddarius> s/neuron/neuron type/
21:21:44 <dmwit> Inefficient and maybe wrong, but good enough for playing around in the REPL.
21:21:52 <ddarius> The newtype wrapping should already be painful.
21:22:00 <o-_-o> dmwit, hmm...
21:22:01 <tomberek> ddarius: ok... so you think this data/record approach is better
21:22:37 <tomberek> ddarius: i though typeclasses where there to reduce code repetition
21:22:39 <ddarius> tomberek: It's definitely better than that type class approach.
21:23:33 <tomberek> ok,, i'll work with this a little bit
21:24:18 <tomberek> and suggestion for the computations? arrows?
21:25:22 <ddarius> tomberek: There are a lot of mechanisms in Haskell or in other languages that are there to reduce code repetition among other things, but that doesn't mean you need to use every feature in every program.
21:26:23 <tomberek> ddarius: :)  hehe
21:27:12 <absentia> I wanted to see a C++ program that used every part of the language.
21:27:26 <pikhq> absentia: ...
21:27:34 <pikhq> That would be the scariest program ever.
21:27:49 <ddarius> tomberek: I don't often create type classes.
21:27:51 <absentia> no, my perl is the scariest program ever.
21:28:02 <pikhq> absentia: Doubtful.
21:29:09 <tomberek> ddarius: would making my Net an instance of Graph or DynGraph makes sense?  putting a contraint on Net?
21:29:18 <absentia> her'es a sample line:  ("@_" =~ m@(?:^|\n)\s*\b$pat\b\s+(?:[^\n]*?)\s*([^\n\s]+?)\s*(?:#[^\n]*?)?\s*(?=\n)@ig);
21:29:36 <pikhq> ... Oh, right.
21:29:44 <pikhq> Perl has Turing-complete "regular" expressions.
21:29:49 <ddarius> absentia: Other languages are much worse.
21:30:17 <absentia> ya, I never coded in apl.
21:32:17 <Zao> absentia: You'd be having a hard time getting hold of a compiler that supported export, but I suppose you could write code using it.
21:32:39 <dmwit> yes indeed
21:32:54 <blackh> tomberek: I don't really know how Graph or DynGraph work, but in terms of lower-level stuff you could use IntMap (state, [Int]) where the [Int] is the list of edges.
21:33:04 <ddarius> tomberek: I don't know what you Net class is.  I would recommend waiting to cross such bridges until you come to them.
21:33:13 <o-_-o> well I was able to hack something up, but I forgot what I wanted to learn
21:33:14 <tomberek> ok
21:33:29 <o-_-o> str :: (FormattingSpec repr) => repr w (String -> w)
21:33:32 <o-_-o> what is this ?
21:33:35 <ddarius> Also, as I suggested earlier, I would recommend an approach which makes your code independent of the underlying graph representation/library.
21:33:57 <o-_-o> it returns a type repr which takes a w and a function (String -> w)
21:34:09 <o-_-o> is that the correct interpretation ?
21:34:11 <blackh> tomberek: Arrows could possibly be overkill
21:34:17 <ddarius> There is not currently a good answer for graph types in Haskell and even if there were, your user might not be interested in using a graph at all.
21:34:45 <tomberek> ddarius: that's what I was trying to do with typeclasses,, i'll start working on it, but one last question about when to use tyepclaasses?
21:34:49 <ddarius> As I also suggested earlier, you can start concrete and abstract from there.
21:34:55 <tomberek> o
21:34:56 <tomberek> ok
21:39:53 <ddarius> One consideration when using type classes, is that they equip type constructors with operations so they are best used when there is, ideally, only one, or at worst a few, "natural" implementations of those operations per type.
21:40:23 <ddarius> Your type class example violated that egregriously as there are tons of different implementations of your neuron functions per signal type and none are particularly more natural than others.
21:40:53 <tomberek> ok, your comment will take me a few minutes to fully comprehend.....
21:44:49 <tomberek> ddarius: i still don't get it..... isn't the point of the instance declaration to specify the operations?  so a different instance has a different activation function for example?
21:45:30 <tomberek> then you have Neuron, with specific implementations: SigNeuron, MaxNeuron, WeirdNeuron?
21:46:39 <tomberek> or is all that something possible with typeclasses, but not recomended?
21:47:43 <ddarius> tomberek: Your type class isn't parameterized over the "neurons," it's parameterized over the signal type, but probably all your "neurons" will function over Double signals.
21:47:45 <aavogt> well if all your methods like:   class C a where f :: a -> A; g :: a -> B -> C ...
21:48:32 <ddarius> tomberek: It's important to note that type classes are very -unlike- OO classes, they are closer to but still very different from Java/C# style interfaces.
21:49:06 <tomberek> ah! ok ok... I think I'm getting it
21:49:12 <aavogt> then you might as well use data, especially since you seem to have multiple sensible instances per type
21:50:01 <kmc> it is quite reasonable to put functions into a data type
21:50:11 <tomberek> what would you say about something like class Neuron a b c    where a was the neuron type, b was the signal type, and c was the weight type?
21:50:37 <tomberek> or should I just drop the whole class obsession?
21:50:44 <ddarius> tomberek: Yes, you should.
21:50:57 <ddarius> What would the "neuron type" be?
21:52:07 <tomberek> um,,, different types of neurons,, ones that used different functions, or different ways of combining inputs
21:52:17 <ddarius> tomberek: Give an example.
21:52:43 <kmc> "using a different function" sounds like you have a field of a data which is the function
21:53:04 <tomberek> kmc: yes, that might be best... ddarius is convincing me of that now
21:53:19 <kmc> does a "different type of neuron" correspond to a different Haskell type, or to a Haskell value of the same type which holds different data (incl. functions as data of course)?
21:54:13 <tomberek> kmc: i am too new to Haskell to answer that in any other way than that it seemed to make semantic sense to say that there are different types of neurons
21:54:31 <kmc> tomberek, there are advantages and disadvantages each way of course
21:54:52 <kmc> there is this common pattern in OO languages of defining subclasses to have different behavior, then using them through a common base-class interface
21:55:01 <tomberek> class Person a         instance Person Male,,, instance Person Female... different types of people
21:55:17 <ddarius> tomberek: So data Male = what? and data Female = what?
21:55:24 <kmc> we don't need anything so complicated, because behaviors (functions, IO actions, etc) are data
21:55:36 <tomberek> ddarius: um.. name, age, etc
21:55:40 <kmc> a lot of OOP is functional programming the long way 'round
21:55:56 <ddarius> tomberek: Um, I'm looking for you to fill in the blanks (roughly)
21:55:59 <tomberek> kmc: i'm slowly learning that,,, or rather, unlearning OOP
21:58:11 <kmc> tomberek, what probably makes much more sense is:   data Person = Male ... | Female ...
21:58:30 <tomberek> ddarius: i guess those types could store the person's name, age, other details.  And then this way you could perhaps have groups of Male and groups of Female.... something like: (Person a) => [a]
21:58:56 <tomberek> data (Person a)=> Team a = Team [a]
21:58:59 <ddarius> tomberek: That's not how type classes work and your code would be extremely redundant in that case.
22:00:20 <ddarius> If you had a variable with people :: Person a => [a] (not universally quantified), that would be a list of all Males or all Females (or all some other instance of Person).
22:00:29 <kmc> ddarius, i think that was the point
22:00:33 <kmc> but it's an odd sort of thing to do
22:01:05 <kmc> if you want lots of static guarantees about your data, you end up reflecting a lot of it into the type and class system
22:01:07 <tomberek> ddarius: perhaps for a soccer team
22:01:25 <kmc> tomberek, do you want to guarantee statically that your neurons are all of the same "type"?
22:01:48 <tomberek> no, but I do want a set interface to deal with them
22:01:52 <ddarius> tomberek: Okay, you can use such an approach for very high levels of static guarantees, but I still want to know what you expect to fill in the blanks with in those data declarations.
22:02:09 <tomberek> all neurons need to be able to do [a]->[b]->a
22:02:36 <ddarius> tomberek: A better way to approach design in FP is to think about what things -are-.  What -is- a neuron?
22:03:18 <tomberek> ddarius: a neuron takes multiple signals, and produces a signal  (the weighting could be done in the Net)
22:03:26 <tomberek> so [a]->a
22:03:28 <ddarius> If, say, the defining feature is that it can be treated as a function [Double] -> [Double] -> Double, then simply define neurons to be that.
22:03:47 <ddarius> tomberek: Then simply define Neuron as: type Neuron signal = [signal] -> signal
22:04:19 <tomberek> type is just a synonym, right?
22:04:23 <ddarius> tomberek: Yes.
22:05:00 <tomberek> is that ok?
22:05:31 <ddarius> It's valid Haskell code.  I don't know what you mean by "ok," or alternatively what exactly you are asking about.
22:05:42 <kmc> there is some benefit to a non-transparent wrapper
22:05:48 <kmc> it will be more syntax but more static guarantees
22:05:50 <tomberek> becuase I want someone to come along and be able to say, a neuron is that, PLUS a state... or that, PLUS some other feature
22:06:02 <kmc> that's harder to work in with type
22:06:15 <tomberek> kmc: you are talking about newtype? or data?
22:06:24 <ddarius> tomberek: Then you misanswered the first question or a neuron + state is not a neuron, it's a neuron + state.
22:06:31 <kmc> tomberek, either would work
22:07:17 <sockpuppetzero> Is there a nice way to run all the prop_ quickcheck tests in a file?   It seems the original quickcheck had a script to do so for hugs,  but I'm having trouble finding something comparable for GHC
22:07:33 <aavogt> does that old script work?
22:07:40 <tomberek> ddarius: true.... i'm starting to see the benefit of storing the functions in a data type.... i
22:07:43 <PepeSilvia> .quit
22:08:08 <tomberek> ok,,, this has taken 2 hours.. i should actually go try some of these things.. thanks for all the help guys (to all in channel)
22:08:12 <ddarius> tomberek: That last approach I mentioned isn't storing functions in a data type, it is -defining- neurons to be functions.
22:08:28 <kmc> tomberek, you can think of newtype as a more efficient version of data which is only allowed for a subset of cases
22:08:34 <ddarius> tomberek: You may want to look at some of Conal Elliotts work on denotational design.
22:09:07 <kmc> this is a fine abstraction unless you are interested in the actual in-memory representation, or details of when things get evaluated
22:09:58 <tomberek> ddarius: i'll read it now..... any other things I can read that help in the un-OOPing process?  I liked the sudoku solver paper, for example
22:11:16 <ddarius> tomberek: Learning about denotational semantics in general and calculating with/deriving programs is probably very useful.
22:11:44 <sockpuppetzero> aavogt, I guess it does,  with just a little tweaking!
22:11:47 <sockpuppetzero> thanks
22:12:25 <ddarius> tomberek: Also, the various functional pearls are enjoyable and usually use strongly functional approaches that are very different from OO approaches.
22:12:41 <ddarius> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
22:12:56 <tomberek> ddarius: thanks... i'll be back when I can discuss more compotently
22:15:01 <o-_-o> this is the best channel around
22:15:41 <o-_-o> I am blown away that there are people who conduct the equivalent of courses on IRC, on this channel
22:16:56 * o-_-o is re-reading the logs of a "functor" course given a while ago on this channel
22:17:26 <sockpuppetzero> o-_-o, when was that?
22:17:41 <o-_-o> sockpuppetzero, like 3-4 days ago
22:17:43 * ddarius doesn't know how one would make a course on functors, especially functors limited to Haskell.
22:18:10 <o-_-o> ddarius, I meant a class
22:18:19 <o-_-o> ddarius, a class on functors
22:18:26 <sockpuppetzero> a lecture?
22:19:24 <o-_-o> sockpuppetzero, it was a discussion, where Peaker explained functors to me
22:19:36 <sockpuppetzero> :)
22:19:45 <o-_-o> sockpuppetzero, I didn't have enough knowledge to understand what he was talking about
22:20:22 <o-_-o> sockpuppetzero, so I read the haskell online books and go back to re-read the logs, until I can fully comprehend what he is talking about...
22:20:46 <sockpuppetzero> I only half-understand functors
22:21:56 <o-_-o> sockpuppetzero, I don't even know how much is half
22:22:15 <ddarius> There's not much to understand.  In a Haskell context, if you understand higher kinded type constructors and type (constructor) classes, explaining the Functor class is pretty trivial.  I suspect most people having trouble with Functor, just don't have a good grasp on type classes and higher kinded type constructors.
22:23:21 <o-_-o> yeah
22:24:23 <aavogt> people definitely understand these 'higher kinded type constructors' at least when they are more concrete like Maybe, rather than just another type variable
22:24:42 <ddarius> aavogt: Not always, but yes, it is very basic stuff.
22:25:10 <ddarius> Once someone has a good grasp of Haskell's type system, usually everything else falls into place pretty easily.
22:31:23 <o-_-o> although certain things seem fairly trivial once you get the hang of it, to a rank newbie like me somethings are still alien
22:32:33 <o-_-o> like when dmwit told me to " roll my own Show instance of FuncMap", I don't how to do that
22:32:55 <o-_-o> so I am still learning
22:35:06 <ddarius> o-_-o: My point is simply that you not understanding Functors is probably more a reflection of you not understanding type classes.  Once you understand type classes (and some other things) Functor will seem fairly simple, but, until then, it is going to seem complicated.
22:35:50 <o-_-o> ddarius, ah...true, probably
22:36:12 <o-_-o> as I seem to experiment making my own type classes, things seem to be falling in place
22:47:26 * hackagebot upload: data-ordlist 0.4 - Set and bag operations on ordered lists (LeonSmith)
22:51:47 <copumpkin> lpsmith: I was just peeking at your ordlist code
22:52:13 <copumpkin> lpsmith: have you considered abstracting out your ordlist-traversing code?
22:52:34 <lpsmith> what do you mean?
22:53:04 <copumpkin> xunionBy, minusBy, unionBy, isectBy, mergeBy all have the same fundamental structure
22:53:11 <copumpkin> they differ in which elements they pick and which they leave out
22:53:17 <copumpkin> as a function of GT/LT/EQ
22:53:19 <lpsmith> I added an extended comment on that topic
22:53:31 <lpsmith> In the commented-out function genSectBy
22:53:33 <copumpkin> ah, I missed that :)
22:53:45 <lpsmith> yeah,  you have to look at the source itself to see it
22:53:51 <lpsmith> search for genSectBy
22:54:01 <copumpkin> found it, thanks
22:54:22 <lpsmith> that function doesn't hit merge,  but it does get the rest
22:54:37 <copumpkin> I'm pretty sure merge fits the same pattern
22:54:43 <lpsmith> Yeah, probably
22:54:46 <copumpkin> in your code you just happen to flatten two of them into one with a _
22:54:56 <copumpkin> but yeah, it's cool
22:55:07 <copumpkin> I wonder what the other combinations of drop/pick do :P
22:55:10 <copumpkin> probably nothing interesting
22:55:47 <lpsmith> Past versions of the code had genSectBy commented out,  but not with any explanation of what it was, really
22:55:55 <copumpkin> I see
22:56:03 <copumpkin> didn't think about how it would work with optimization
22:56:09 <copumpkin> but you did :)
22:56:46 <lpsmith> Yeah, the real meat of the latest release is the addition of mergeAll and unionAll
22:56:57 <augur> merge?!
22:56:58 <augur> do tell
22:57:12 <copumpkin> yeah, I see
22:57:28 <copumpkin> augur: for merging possibly infinite sets represented as ascending lists
22:57:45 <augur> tell me mooooore :3
22:57:49 <lpsmith> Though "CHANGES" now describes changes between releases
22:58:03 <lpsmith> Methinks augur is a bot
22:58:10 <augur> lpsmith: shut your face, foo
22:58:11 <copumpkin> lol
22:58:17 <augur> i'm a highly advanced artificial life form
22:58:18 <lpsmith> augur,  could you pass a turing test?
22:58:19 <copumpkin> yo'
22:58:21 <augur> i am no mere BOT
22:58:23 <copumpkin> not your
23:05:27 <lpsmith> copumpkin, if you look at ghc-core,  you find that one thing GHC tries to do (I'm not sure which optimization it's called) tries to reduce the amount of pattern matching,  sometimes by adding more functions
23:05:40 <copumpkin> ah, I see
23:06:34 <lpsmith> So like,  loop [] = True ;  loop [x] = True ; loop (x:y:zs) = x < y && loop (y:zs)
23:06:35 <lpsmith> will become
23:07:47 <lpsmith> loop' x [] = True ;  loop' x (y:zs) = loop' y zs ;   loop [] = True ; loop (x:xs) = loop' x xs
23:07:50 <lpsmith> or some such beast
23:08:02 <copumpkin> yeah
23:08:22 <lpsmith> anyway,  that particular thing interacts badly with genSectBy :)
23:08:57 <lpsmith> ghc-core is your friend
23:08:59 <lpsmith> sometimes
23:09:07 <copumpkin> little does ddarius know that he's following me on buzz
23:11:56 <ddarius> copumpkin: Actually I do know and was not particularly happy with suddenly having that Buzz crap in my GMail.
23:12:14 <copumpkin> yeah, many weren't
23:14:42 <Gracenotes> I have a random guy following me on buzz
23:14:48 <Gracenotes> or a... seemingly random guy :o
23:15:01 <copumpkin> probably people from haskell-cafe?
23:15:19 <copumpkin> it seems to assume that everyone in a thread I've ever replied to is someone who I want to follow
23:16:30 <Adamant> they did turn it off now, right?
23:16:36 <Gracenotes> oh, it's someone with whom I once carpooled to go to a linux user group with
23:17:06 <copumpkin> Adamant: I dunno, I just opened mine up to a screen showing me that ddarius (and several other haskellers) was following me
23:17:31 <Adamant> copumpkin: read something that Google was changing it to opt-in
23:17:41 <Adamant> due to people being annoyed
23:17:49 <copumpkin> me too, but I guess they didn't revert the existing opt-out follows
23:19:08 <Gracenotes> opting is serious business
23:23:03 <o-_-o> what is buzz ?
23:28:41 <lpsmith> heh
23:28:50 <mreh> -Wall doesn't show anything with cabal, what gives?
23:29:09 <mreh> cabal build -ghc-opts="-Wall"
23:29:12 <lpsmith> Well,  I dunno;  it was a little odd;  but I'm leaving Buzz on for the time being.   I might axe it though
23:29:24 <copumpkin> I'm leaving it on too
23:29:29 <copumpkin> after all, I am a twitter user
23:29:34 <lpsmith> I don't _think_ I created a public profile
23:29:42 * copumpkin hunts lpsmith down
23:30:00 <dolio> Maybe there's nothing to warn about.
23:30:04 <lpsmith> But I wish there was a way to see what my profile looks like to others
23:30:30 <Adamant> lpsmith: make another account and friend yourself?
23:30:34 <lpsmith> lol
23:30:36 <Adamant> still annoying though
