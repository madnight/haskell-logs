00:00:07 <sinelaw> yeah
00:00:24 * ivanm -> dinner
00:00:26 <sinelaw> ivanm, meanwhile, i've fixed a few bugs in my program and graphviz doesn't seem to be the bottlneck
00:00:33 <ivanm> sinelaw: \o/
00:00:49 <sinelaw>          O
00:00:57 <sinelaw>          /\
00:01:01 <sinelaw> oops.
00:05:51 <kamatsu> @src fold1
00:05:51 <lambdabot> Source not found. :(
00:05:52 <megatron242> I've got another _very_ simple question... How do I get the first item of a list, and the last item of the list?
00:06:03 <copumpkin> head / last
00:06:06 <copumpkin> > head [1..10]
00:06:07 <lambdabot>   1
00:06:09 <copumpkin> > last [1..10]
00:06:10 <lambdabot>   10
00:06:15 <megatron242> thanks!
00:06:24 <copumpkin> megatron242: head might be better expressed as pattern matching though
00:06:40 <copumpkin> > head []
00:06:41 <lambdabot>   * Exception: Prelude.head: empty list
00:06:49 <copumpkin> that's no fun
00:07:13 <copumpkin> > case [] of (x:xs) -> x; [] -> 5
00:07:14 <lambdabot>   5
00:07:22 <copumpkin> > case [2..10] of (x:xs) -> x; [] -> 5
00:07:22 <lambdabot>   2
00:07:34 <trofi^w> @ask dons Hia! Hackage's sqlite seems to be your project. Mind adding a link to public available repo? We'd like to send you some patches :]. Thanks!
00:07:34 <lambdabot> Consider it noted.
00:07:52 <Gracenotes> so many BBC actors are Scottish, huh
00:08:39 <Gracenotes> at least, apparently, in what I've watched.. very related to Haskell and all...
00:09:09 <copumpkin> totally
00:10:11 <kamatsu> @src mapAccumL
00:10:11 <lambdabot> mapAccumL _ s []        =  (s, [])
00:10:11 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
00:10:11 <lambdabot>    where (s', y ) = f s x
00:10:11 <lambdabot>          (s'',ys) = mapAccumL f s' xs
00:13:11 <megatron242> Suppose that I have a list [xs], I have m = maximum [foo x | x<-[xs]], how can I know the index of the x item that yielded the maximum value of foo?
00:13:23 <Gracenotes> and, yeah, mostly all of them fake british accents
00:13:34 <copumpkin> megatron242: if xs is a list [xs] is a list of lists
00:13:46 <copumpkin> megatron242: you'd have to zip the list with indices
00:13:55 <copumpkin> > zip [0..] [6,2,7,1,3,7,1,2]
00:13:56 <lambdabot>   [(0,6),(1,2),(2,7),(3,1),(4,3),(5,7),(6,1),(7,2)]
00:14:07 <copumpkin> megatron242: in general, we try to avoid using indices with lists
00:14:09 <megatron242> But, then what would maximum would return?
00:14:23 <copumpkin> indices obscure your intent and are slow in lists anyway :)
00:14:43 <copumpkin> megatron242: you'd use maximumBy instead, and ask it to compare only the second half of the pair
00:14:51 <megatron242> I have an algorithm that needs to split a list according to an index
00:15:01 <copumpkin> then you probably don't want to use a list
00:15:08 <megatron242> the algorithm works recursively
00:15:30 <copumpkin> > maximumBy (comparing snd) $ zip [0..] [6,2,7,1,3,7,1,2]
00:15:31 <lambdabot>   (5,7)
00:15:38 <copumpkin> > maximumBy (comparing snd) $ zip [0..] [6,2,7,13,3,7,1,2]
00:15:39 <lambdabot>   (3,13)
00:15:45 <megatron242> The list represents an array of points, what other structure would you recommend?
00:15:47 <copumpkin> > fst . maximumBy (comparing snd) $ zip [0..] [6,2,7,13,3,7,1,2]
00:15:48 <lambdabot>   3
00:16:36 <copumpkin> megatron242: maybe a Seq from Data.Sequence
00:16:55 <megatron242> Ok, I'll check it out
00:16:56 <megatron242> thanks
00:17:32 * hackagebot upload: regular 0.2.3 - Generic programming library for regular datatypes. (JosePedroMagalhaes)
00:19:08 <domor`> weird.. I regularly get disconnected, and see myself when my client reconnects automatically. it's been going on for a couple days..
00:19:09 <ManateeLazyCat> I have below data item: PageId PageMode PageName PlugId ProcessId WindowId, i want build a "absolute data layout", then all other module can add, delete, synchronous with this data layout, and those module are split and standlone to keep flexibility. But i haven't idea that how to structure this "absolute data layout", andy idea?
00:20:56 <ManateeLazyCat> I want use "absolute data layout" split design module, then module A know nothing about module B, module B know nothing about module A, all communication through "middle layer".
00:22:27 <megatron242> I try to use maximumBy (comparing snd) but I get an error: Not in scope 'comparing', should I import this function?
00:22:46 <domor> megatron242: try hoogle for this kind of stuff
00:22:51 <domor> @hoogle comparing
00:22:51 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
00:23:20 <domor> probably you need Data.Ord then
00:36:19 <felzix> How do I make a hashtable as part of a data type?
00:36:51 <felzix> trying to construct something with a hash able in it complains that it infers IO HashTable blah instead of simply HashTable
00:37:00 <felzix> hash table in it*
00:40:32 <monochrom> Advice: use Data.Map instead.
00:41:02 <felzix> sweet, thanks!
00:47:15 <ivanm> monochrom: even in imperative languages!
00:47:55 <monochrom> wouldn't bother to go through FFI to call Data.Map functions from C code :)
00:48:31 <ivanm> monochrom: well, a Tree-based lookup table
00:48:31 <domor> even C++ has no hash map by default
00:51:41 <kalven> domor: 1x does
00:52:19 <domor> yes, and boost and Qt have nice ones too
00:52:43 <ivanm> how can you have a nice hashtable? isn't that an oxymoron?
00:52:59 <domor> but from what I heard back then they chose the tree because it's more predictable
00:53:15 <domor> ah but you must try Qt data structures :)
00:53:39 <domor> implicitely shared
00:54:24 <ivanm> domor: if you like that kind of stuff, then why are you using Haskell?
00:54:25 <domor> Qt makes C++ supportable. I hope we can use it from Haskell someday.
00:54:41 <domor> I prefer Haskell, but I code signal processing stuff in C++ for a physics lab
00:54:48 <ivanm> someone started qthaskell...
00:54:56 <domor> I have to train them in C, forget about Haskell...
00:55:08 <domor> (the physicists who have to maintain the code after, I mean)
00:55:40 <dreixel> (just testing, sorry, I can't seem to be able to write on #ghc)
00:55:50 <dreixel> ok, here I can. odd.
00:57:29 <det> ivanm, what is wrong with hash tables?
00:58:31 <ivanm> det: first of all, they're mutable structures
00:58:51 <Saizan> dreixel: #ghc is currently on +R so you've to be identified to talk
00:58:57 <ivanm> det: also see http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
00:59:52 <Saizan> dreixel: mh, actually it seems it isn't
00:59:58 <dreixel> uh, my autoidentify failed
00:59:59 <Saizan> +anymore
01:00:12 <dreixel> I didn't notice this, now it works, thanks
01:01:58 <Cale> If you have a hashtable, and you want a version of it which has one more element, but you don't want to lose the original, you have to make a complete copy.
01:02:52 <Cale> The operations on hashtables are efficient only if you're willing to use the thing in a linear fashion.
01:05:21 <Cale> and the usual statements about performance (such as that lookups are constant time), are somewhat of a lie -- in order to separate n elements into different buckets, you need to examine at least O(log n) bits of the input to the hash.
01:05:38 <Cale> (so it really has logarithmic time)
01:06:09 <kalven> but in reality, it is often used in favor of trees
01:06:27 <monochrom> in reality, inferior solutions are favoured
01:06:28 * Zao invokes runHashT
01:06:30 <Cale> It is, but often not for any better reason than that's what's in the library.
01:06:40 <ivanm> Cale: and it's amortized, etc.
01:06:58 <Zao> One could hack up a similiar interface as Array and friends have, couldn't one?
01:07:01 <ivanm> Cale: and because everyone is brainwashed at uni, etc. that hash tables are really really cool
01:07:05 <monochrom> In practice, you can almost safely turn it around and just conclude "xxx is popular therefore xxx is inferior"
01:07:17 <ivanm> Cale: e.g. I never heard about using a Tree for lookup until I started using Haskell
01:07:20 <kalven> so you believe that most uses of hash tables out there would be better off with a tree?
01:07:23 <ivanm> monochrom: heh
01:07:28 <ivanm> kalven: yes
01:08:24 <monochrom> hash tables are taught in uni just because the hash function part is a great academic activity
01:08:31 <Cale> Trees have stronger guarantees about performance, are easier to implement properly (it's easy to implement a terrible hashtable, but very hard to implement a good one), and have nicer semantics (no need for mutation!)
01:08:59 <Saizan> the nice thing about hash tables is that being a contiguous amount of memory they have better cache locality, but that matters mostly if you store the objects directly in them, rather than pointers
01:09:17 <det> Moral of the story: bad hash table implementations suck ?
01:09:38 <det> Also, his observations of efficiency are probably way off on modern hardware
01:10:05 <det> and course in the case where you build the hash table once once lookup many times, you dont worry about resizing
01:10:27 <det> Most people dont use data structures in a persistent way
01:10:44 <det> Well, I mean to say, persistent is not the common use case
01:10:47 <Cale> Only because they don't know how to program properly ;)
01:10:57 <domor> I think we have to be clear on whether we mean in haskell or in general here
01:11:22 <Cale> Not mutating things when you don't have to has benefits even in impure languages.
01:11:36 <det> such as?
01:11:51 <Cale> Such as making it harder to write bugs.
01:11:56 <monochrom> Concurrent access to hash table is problematic. Concurrent access to "immutable" "persistent" "I don't need persistent" Data.Map is trivial because of persistence even if you don't "need" [sic] it.
01:12:03 <Cale> and yes, concurrency
01:12:06 <det> I dont agree with that
01:13:03 <kalven> ivanm: I guess it's up to the haskellites to tell the rest of the world that they're wrong :)
01:13:07 <det> Why is it better for concurrency ?
01:13:11 <domor> I agree with the general, but I wouldn't call it bad programming per se
01:13:19 <monochrom> I just wrote a program I use in production recently. One single MVar to point to a Data.Map. (Not: one MVar per tree node.) Guaranteed consistent snapshot and no one holds the lock for long.
01:13:25 <det> I think you are mistaking concurrent for persistent
01:13:55 <monochrom> I think you are underestimating the great use of persistence for concurrence.
01:14:09 <det> example ?
01:14:17 <det> If you have many threads access in a read only fashion, then it doesnt matter
01:14:30 <monochrom> I just said it. One MVar to the whole tree. Think about what that entails.
01:14:37 <det> If they modify locally, then you really just have persistence
01:15:02 <det> if you modify globally, then you need sychronization anyways
01:15:27 <Saizan> you need less of it, since consistent snapshots are free
01:15:36 <monochrom> Oh of course, but the difference is how long one thread stays in a critical section and locks out other threads.
01:15:54 <det> monochrom, I dont see how
01:15:56 <Cale> Countless bugs are caused by the value of something changing when some programmer didn't expect it to, often because of the same "thing" getting multiple names.
01:16:03 <monochrom> Would you like to lock out others for log(n) time or 1 time?
01:16:04 <megatron242> Small question - how can I get the second item in a tuple?
01:16:22 <blackdog> megatron242: snd
01:16:30 <det> megatron242, is it a 2-tuple ?
01:16:31 <megatron242> thanks
01:16:37 <megatron242> yes
01:16:55 <domor> @hoogle (a,b) -> b
01:16:55 <lambdabot> Prelude snd :: (a, b) -> b
01:16:56 <lambdabot> Data.Tuple snd :: (a, b) -> b
01:16:56 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
01:16:59 <domor> ;)
01:17:01 <Cale> Keeping track of what is affected by changes to a mutable variable is a huge and often unnecessary mental burden.
01:17:13 <blackdog> megatron242: also: http://www.haskell.org/hoogle/?hoogle=(a,b)+->+b
01:17:20 <det> snd only works for a 2-tuple, for other types, you'll need to pattern match
01:17:27 <blackdog> hoogle is the canine's reproductive organs.
01:17:32 <megatron242> thanks
01:17:35 <otis> Hello
01:17:43 <otis> Is there something about the W-algorithm in the wiki?
01:17:56 <otis> I can't find it with the search function
01:18:04 <ivanm> otis: try with google?
01:19:07 * ivanm has never heard of the W algorithm before
01:19:10 <Cale> It's the reason why people are forced into debugging their programs by tracing the execution one step at a time, because they literally cannot keep track of everything which is happening.
01:19:24 <det> ivanm, HM type inference algorithm
01:19:28 <ivanm> ahhh
01:19:31 <ivanm> no idea then
01:19:53 <Cale> http://www.google.ca/url?sa=t&source=web&ct=res&cd=5&ved=0CCEQFjAE&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.65.7733%26rep%3Drep1%26type%3Dpdf&ei=s-1nS8G5D4TdlAfbh-GSCA&usg=AFQjCNEZd7yLYNia8S_uC0CF-s0v5PHQ7A -- here's an implementation in Haskell.
01:20:12 <Cale> (Of algorithm W)
01:20:51 <otis> I think it doesn't work
01:21:40 <otis> The link, not the algorithm
01:21:52 <det> works for me
01:22:35 <det> http://tinyurl.com/yl3fe7k
01:23:02 <otis> "This URL does not match any resource in our repository."
01:23:05 <otis> That's what I get
01:23:09 <otis> With tinyurl too
01:23:18 <det> wierd
01:23:18 <Alpounet> same here
01:23:18 <demolithion> same here
01:23:25 <det> I got a pdf
01:23:32 <det> I can upload it somewhere for you
01:23:36 <otis> Same with a different browser
01:23:41 <domor> Re: immutability. it's preferable but sometimes you need the extra efficiency. We often see low-level programmers trying to do misguided stuff like loop in Haskell, but I've also seen the opposite :) a CS guy having fun with vector<vector<double>> and other STL monstruosities in very tight DSP loops..
01:23:43 <otis> That would be nice
01:24:15 <Twey> Haha
01:25:03 <det> http://files.caspring.org/misc/10.1.1.65.7733.pd
01:25:19 <det> http://files.caspring.org/misc/10.1.1.65.7733.pdf
01:25:31 <Peaker> domor: Ideally, mutable code could be auto-deduced from the meaning of your immutable code :)
01:25:40 <Peaker> Though that may require a "sufficiently smart compiler"
01:25:59 <Cale> Or just a sufficiently smart library :)
01:26:13 * osfameron wants the other way around too... to deduce a functional function from a massive pile of spaghetti
01:26:23 <det> Cale, Similarily, a haskell programmer might be confused by using an old version of a datastructure becuase they mistyped a variable name
01:26:24 <Cale> osfameron: I sometimes do that by hand
01:26:24 <osfameron> (or at least I did, when I briefly had to work with COboL)
01:26:26 <medfly> yeah, of course, Haskell code is really easy to understand straight away and you don't need to "debug" it at all.
01:26:47 <domor> Peaker: yes, I think things like stream fusion are a great step forward
01:26:57 <Daerim> Is "show :: Float -> String " known for being much slower than "show :: Int -> String" ?
01:26:58 <det> osfameron, I think that is what SSA compilers try to do :-)
01:27:01 <Cale> medfly: Well, you usually aren't forced to step through it one step at a time
01:27:13 <Peaker> We write functional programs which are compiled by GHC to functional ones. Hardware designers write imperative programs that are compiled to functional ones...
01:27:29 <medfly> or you are, ubt then you still don't get it because Haskell people love writing the most obfuscated version of the thing possible.
01:27:32 <osfameron> det: rarr yeah.  I think the 2 things I was pointed at were SSA and exit analysis
01:27:59 <Cale> The nice thing about (pure) Haskell code is that you can separate it into parts which it's valid to test and understand in isolation.
01:28:00 <osfameron> as COBOL has the additional problem of not having parameters/return values, so you have to deduce what those are based on what global state changed...
01:28:12 <Cale> You can't do that with code that has lots of mutation in it.
01:28:22 <medfly> I don't know many languages that are as unreadable as Haskell is
01:28:28 <Daerim> Peaker, while you are indeed technically right, you might argue that C is a bit closer to the metal in a sort of real world sense
01:28:32 <Saizan> det: the difference is that variable names are very much local, while references can be shared to distant parts of your code
01:28:41 <Peaker> medfly: it's not about obfuscation, it's just that simplicity is complicated (http://avdi.org/devblog/2009/10/29/simplicity-is-complicated/) :)
01:28:57 <medfly> yeah right, have you paid attention to this channel?
01:28:59 <Peaker> Daerim: I meant to say "by GHC to imperative ones"
01:29:01 <Cale> If you want to test a program which mutates lots of stuff, you have to make sure that the world is set up just so beforehand, run the program, and then not just inspect the result, but make sure that the world is in the right state as well.
01:29:04 <Saizan> also, we tend to abstract names away
01:29:14 <otis> det: Thank you
01:29:42 <Peaker> Instead of using names to denote structure, we compose structure with structure-building functions
01:29:51 <Daerim> Peaker, ahh
01:30:20 <Daerim> Cale, it is my experience that the world is very rarely in the right state
01:30:22 <Peaker> \x -> f (g x)   uses the name "x" to denote the structure f . g whereas  f . g  conveys the structure better
01:30:23 <Cale> Daerim: But then you get into the issue that the processor which runs the code is designed based on physical principles which are described in an entirely pure declarative way :)
01:30:37 <medfly> Peaker, when I write an imperative program then my variables have names which explain their function, I have comments and such, and things are split over multiple lines. I would never consider using something like @pl, and I would like do notation.
01:30:43 <medfly> Peaker, THIS CHANNEL THINKS OTHERWISE.
01:31:01 <Peaker> medfly: @pl sucks -- but do note that it often uses a bad form of points-free
01:31:15 <Peaker> @pl \(x, y) -> (f x, g y)
01:31:15 <lambdabot> f *** g
01:31:32 <Peaker> @pl \(x, y) -> (g x, f y)
01:31:32 <lambdabot> g *** f
01:31:37 <Peaker> oops
01:31:52 <Peaker> @pl \(x, y) -> (f y, g x)
01:31:52 <lambdabot> uncurry (flip ((,) . f) . g)
01:31:59 <Peaker> this was the one I was looking for :)
01:32:02 <Cale> If you get a good result out of @pl for anything much more complicated than that, then you're quite lucky, but if you do it by hand, you can often get better results.
01:32:07 <Daerim> Cale, not much for doing assembler, I currently have to do stuff with a punchcard emulator and that's bad enough  for me ;)
01:32:10 <Cale> (sometimes enlightening)
01:32:25 <Peaker> medfly: Points-free is great at revealing structure and even getting more general code
01:32:27 <Cale> Daerim: I'm actually talking about a lower level than that
01:32:35 <blackdog> i kind of like point-free style. saves me agonising over variable names.
01:32:36 <Cale> (the electrical circuits :)
01:32:49 <Peaker> medfly: It gives you a *simpler* definition, though that may take more effort to understand (simplicity has many facets)
01:32:55 <sinelaw> medfly, haskell code can be pretty, it just demands more (in general) to write simple code than complicated code. imperative languages make it easy to write complicated code.
01:33:02 <medfly> blackdog, oh, can't you follow the #haskell tradition of using x, y, z and such?
01:33:05 <Cale> blackdog: right, variable names go away and so you can't get them wrong :)
01:33:13 <Twey> swap . (g *** f)
01:33:20 <medfly> I'm just saying fucking Haskell is unreadable.
01:33:27 <domor> :t swap
01:33:28 <lambdabot> Not in scope: `swap'
01:33:32 <Peaker> Variable names are a great form of documentation, but in Haskell, the expressions themselves are even better documentation :-)
01:33:33 <Cale> medfly: nah, you just need to spend more time reading it
01:33:38 <Twey> swap (x, y) = (y, x)
01:33:46 <Daerim> Cale, major gab in my knowledge there. I know how the transistors work on a quantum level, but anything between that and assembler is pretty much black box
01:33:48 <Cale> You'll get used to it :)
01:33:51 <blackdog> medfly: well, that's the problem, really. if you're tempted to use x, y or z, then it probably wasn't terribly meaningful anyway and it's better off being written point-free
01:34:09 <domor> ah
01:34:10 <medfly> no, I've yet to see Haskell code that uses meaningful names
01:34:12 <medfly> for such things
01:34:30 <osfameron> the definitions look neater when they have short names...
01:34:31 <blackdog> medfly: for which things?
01:34:33 <medfly> it's like "oh, it doesn't really matter. the reader doesn't mind spending twice as long making sense of this."
01:34:38 <medfly> @src scanr
01:34:39 <lambdabot> scanr _ q0 []     =  [q0]
01:34:39 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
01:34:39 <lambdabot>     where qs@(q:_) = scanr f q0 xs
01:34:39 <Peaker> medfly: there's also the issue where 3 Haskell lines would often replace 15-25 lines in a different language.  Understanding each line separately may be easier in the 15-25 line code, but understanding the "big picture" and the overall effort of understanding everything will still be lower in the 3 Haskell lines
01:35:01 <medfly> this is so readable, I can guess what scanr does off the bat!
01:35:17 <domor> :t scanr
01:35:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
01:35:22 <Peaker> medfly: scanr has a meaningful name (right-associative scan) :)
01:35:42 <sinelaw> medfly, what's simpler, this: sum (zipWith (*) coeffs vars)
01:36:20 <det> I dislike that style of definition (scanr)
01:36:31 <sinelaw> medfly, or this: sum = 0; for (i=0; i < length(vars); i++) { sum += vars[i] * coeffs[i]; }
01:36:34 <ivanm> det: why, what's wrong with it?
01:36:38 <Cale> Daerim: There was a nice video presentation explaining the design of a computer which this guy built from electromagnetic relays... http://web.cecs.pdx.edu/~harry/Relay/VideoTutorial/index.html
01:36:50 <medfly> I know which one is faster.
01:37:04 <sinelaw> i don't.
01:37:06 <Daerim> Cale, ohh thanks :)
01:37:21 <sinelaw> medfly, But I do know which one is clearer and easier to analyze and verify.
01:37:25 <sinelaw> and change
01:37:28 <sinelaw> and generalize
01:37:47 <medfly> people come up with mindblowing code here intentionally
01:37:53 <Cale> It's a reasonably simple computer, but it's got a lot of the components of a modern one.
01:37:55 <monochrom> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6556#a6556  Note how "paradoxically" I force the new tree outside the critical section and it is safe if you think about it. Of particular interest is the STM version: people complain that STM is slow for lengthy transactions --- right, so don't use lengthy transactions! Do it my way: just one read and one write in the transaction, you can force the tree outside. You can't do thi
01:37:55 <monochrom> s to hash tables.
01:38:05 <sinelaw> medfly, why is that example mindblowing? it's an example from real code i have.
01:38:06 <Peaker> medfly: Why would you think one is "faster"? It seems pretty trivial to convert sum/zipWith to that loop at the compiler-level
01:38:33 <det> What does "where qs@(q:_) = scanr f q0 xs" mean
01:38:39 <medfly> I'm just saying that you guys love coming up with stuff that is mindblowing and you do this intentionally
01:38:46 <det> in particular the @ and :
01:38:53 <sinelaw> medfly, i love writing mindblowing code? :)
01:38:54 <medfly> qs is the entire list, q is the first element
01:39:04 <blackdog> medfly: not necessarily faster, either - the higher-level form is easier to parallelise
01:39:10 <sinelaw> medfly, it's not an example I made up, it's from my code.
01:39:19 <medfly> it's a specific simple example.
01:39:20 <Cale> det: var@pat where var is a variable, and pat is any pattern will match pat, but also bind the entire thing which matched to var
01:39:29 <det> ahh
01:39:37 <sinelaw> medfly, i can find countless others.
01:39:38 <Cale> det: and (:) is the Haskell version of list cons
01:39:51 <int-e> monochrom: heh. You could use atomicModifyIORef for that one.
01:39:54 <Cale> So (x:xs) is the list whose first element is x, and whose tail is xs
01:40:06 <Cale> (the s for plural thing is just a convention)
01:40:11 <medfly> sinelaw, I'm sure there are a lot of simple things in your code, but overall it's very complicated
01:40:17 <sinelaw> medfly, it's not at all.
01:40:27 <medfly> at least, that's what the code of people in this channel looks like
01:40:34 <medfly> especially when y'all squeeze it into one line for lambdabot
01:40:39 <sinelaw> medfly, i just happened to re-write something i did in python (in which i have tons of experience), in haskell (in which i have little experience)
01:40:40 <medfly> that's ridiculous
01:41:25 <sinelaw> the haskell version came out much simpler, except for one thing that involves IO, which i could write in haskell mirroring my python code with no problem - but it will be just as ugly as the python was, so i'm not implementing it at all for now.
01:41:30 <Cale> det: So, q will actually be the same thing as foldr f q0 xs here, being the first element of the result of a scanr, and qs will be the complete list of right folds of the tails of xs
01:41:48 <det> Cale, what if scanr returns the empty list?
01:41:50 <medfly> look at Cale trying to explain scanr
01:41:52 <domor> @quote lift
01:41:52 <lambdabot> mstr says: haskell is like f'gg'fggf'fg'g'fg'foldliftM2 f g ''f' :)
01:41:55 <det> Cale, wont that pattern match fail ?
01:41:55 <domor> @quote lift
01:41:55 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
01:41:59 <domor> hmm
01:42:04 <Cale> det: Yes, but it thankfully never does.
01:42:34 <domor> @quote product `liftM`
01:42:34 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
01:42:53 <Cale> Even if the input list is empty,  scanr f z [] = [foldr f z []] = [z]
01:43:12 <sinelaw> medfly, look at anyone trying to explain the semantics of the simplest functions in libc
01:43:27 <sinelaw> what if i pass this? that?
01:43:42 <Peaker> btw, GeneralizedNewTypeDeriving is really concensual, right? It just "forwards" class instances to the wrapped type, right?
01:44:13 <Cale> medfly: What's wrong with my explanation of scanr?
01:44:21 <medfly> even Cale admits to not always understanding wtf is going on here
01:44:23 <Peaker> > scanr (-) 0 [1,2,3,4]
01:44:24 <lambdabot>   [-2,3,-1,4,0]
01:44:48 <Cale> medfly: Well, sure. That's why it's an interesting place to hang around.
01:44:52 <kalven> sinelaw: the semantics are described quite well in the c standard.
01:44:56 <Peaker> I would prefer to see scanr composed from map/iterate or such
01:45:22 <det> http://pastebin.ca/1775411
01:45:26 <det> I find this much more readable
01:45:32 <medfly> Cale, well, I hate this place.
01:45:32 <Cale> If I understood everything which went on in this channel, there wouldn't be much point in reading the conversations here :)
01:45:39 <Peaker> medfly: Haskell makes it easier to understand the semantics of code, at the expense of making it harder to understand the way it will run on a particular machine
01:45:53 <sinelaw> medfly, זה הדדי
01:45:57 <medfly> no, it DOESN'T.
01:46:00 <sinelaw> (just kidding.)
01:46:04 <medfly> why do you all complain about what oleg writes?
01:46:05 <sinelaw> :P
01:46:06 <medfly> I wonder
01:46:15 <Cale> @src scanr
01:46:15 <lambdabot> scanr _ q0 []     =  [q0]
01:46:16 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
01:46:16 <lambdabot>     where qs@(q:_) = scanr f q0 xs
01:46:39 <Peaker> kalven: are the semantics described in the C standard comprehensive/complete?  How large are the descriptions?
01:46:50 <Cale> that looks pretty much identical to me :)
01:47:04 <Cale> except that the empty list case seems like...
01:47:08 <medfly> if it's all so easy to understand.
01:47:14 <Cale> I think you need some extra brackets in the ML code.
01:47:27 <Cale> match list with
01:47:32 <det> yeah, that match might have parser errors
01:47:33 <Cale>   | [] -> [q0]
01:47:44 <Peaker> medfly: It's possible to write mind-boggling code in all languages :-)
01:47:45 <det> ahh, yes
01:47:49 <det> accident
01:47:55 <felzix> ...wow. Haskell can be deceptively lisp-like since parentheses crop up so often
01:47:56 <medfly> Peaker, all I see here is mind-boggling code.
01:47:59 <Peaker> medfly: Haskell makes semantics easier to understand - but only after you're past the learning curve
01:48:14 <Peaker> medfly: I thought so too - but then it sunk down, and now I find it super-readable and create code like it myself :)
01:48:16 <Cale> felzix: We have ways to eliminate parens
01:48:16 <felzix> '+' being infix caused me confusion for about an hour...
01:48:29 <sinelaw> medfly, haskell has a high learning curve. get past that initial peak and it's easier to appreciate. i got past it only recently.
01:48:30 <Peaker> medfly: it's just a matter of getting used to it, and toying around with it
01:48:30 <blackdog> Peaker: yep, understanding space behaviour of haskell programs is a breeze
01:48:37 * blackdog hears crickets
01:48:50 <Daerim> I'm stomped. Besides using FFI or low level hackery, is there an efficient of writing a large amount of floats (or doubles, I'm not picky) to an ascii file, using haskell?
01:48:50 <kalven> Peaker: yes, yes and not that large.
01:49:01 <felzix> Cale: no, I like parens :).
01:49:06 <Peaker> blackdog: Haskell programs don't have space behavior ;-)  Their implementation on a particular machine might..
01:49:06 <sinelaw> medfly, which is the opposite of all modern imperative languages - they all come from trying to make the learning curve easier.
01:49:14 <Peaker> blackdog: well, at least in some cases
01:49:15 <monochrom> understanding space behaviour of haskell programs is a breeze. there, I said it.
01:49:28 <det> @type scanr
01:49:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
01:49:30 <medfly> sinelaw, I am not really talking about the language
01:49:31 <medfly> itself
01:49:33 <medfly> but you guys
01:49:45 <Peaker> medfly: can you give an example of hard code you see here?
01:49:50 <medfly> with your intentionally mind boggling code, and multiline things squeezed into one line
01:49:56 <Cale> medfly: Part of understanding a language is understanding the idioms :)
01:49:59 <blackdog> monochrom: really? even the galois dudes seem not to have a formal model of it
01:50:04 <medfly> I understand the goddamn idioms
01:50:17 <Cale> medfly: why are you so angry?
01:50:20 <sinelaw> medfly, there are a lot of experts here, so you see alot of toying around with crazy ideas here.
01:50:26 <cheater> hey guys, i've been reading up a bit on happstack. are the happstack entries mutable, e.g. can i use them to store user-pass pairs?
01:50:46 <Cale> > scanr f z [1,2,3]
01:50:47 <lambdabot>   [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
01:50:57 <Cale> > foldr f z [1,2,3]
01:50:58 <lambdabot>   f 1 (f 2 (f 3 z))
01:51:02 <Peaker> medfly: well, the IRC medium kinda encourages sticking multiline things in one line
01:51:29 <Daerim> I've tried using shows (which didn't change the performance at all), but it seems like the show and shows are incredible slow for floating points usage. Any ideas?
01:51:34 <sinelaw> medfly, unfortunately this isn't the channel to complain and expect people to fight you to the death or ban you for expressing your anger
01:51:45 <sinelaw> which is what you might need, psychologically
01:51:48 <sinelaw> :P
01:51:56 <int-e> > let scanr f x xs = foldr (\x (y : ys) -> f x y : y : ys) [x] xs in scanr f z [1,2,3]
01:51:56 <medfly> maybe you do
01:51:57 <lambdabot>   [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
01:52:16 <cheater> medfly: feel free to deride everyone and get yourself ignored/banned.
01:52:56 <Cale> Nah, we don't ban people for that. I can't promise that there won't be an @medfly if she keeps this up though ;)
01:53:01 <Cale> @protontorpedo
01:53:01 <lambdabot> cmon Im asking cool questions
01:53:09 <sinelaw> heh
01:53:11 <sinelaw> :)
01:53:20 <det> Cale, if scanr can never return the empty list, why not make it return a tuple of element * list ?
01:53:25 <medfly> there might be lots of flooding if you do, though
01:53:48 <Cale> det: Well, we could. Often the single list is more convenient though.
01:53:57 <cheater> medfly: nobody's impress and nobody cares. get over it and start playing nice and you'll get the help you need.
01:54:02 <cheater> *impressed
01:54:10 <monochrom> medfly: I want to share with you http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2951 enjoy! XD
01:54:12 <det> Does someone have a simple example of a use of scanr
01:54:21 <int-e> > let scanr f x xs = foldr (\x (y, ys) -> (f x y, y : ys) (x, []) xs in scanr f z [1,2,3] -- ;-)
01:54:21 <cheater> monochrom: ever used happstack?
01:54:22 <lambdabot>   <no location info>: parse error on input `in'
01:54:32 <medfly> I don't need help. this channel does. it's full of people that write such complicated code that if they read someone else's code which was like that, they would need a really long time to even make sense of that.
01:54:40 <int-e> > let scanr f x xs = foldr (\x (y, ys) -> (f x y, y : ys)) (x, []) xs in scanr f z [1,2,3]
01:54:41 <lambdabot>   (f 1 (f 2 (f 3 z)),[f 2 (f 3 z),f 3 z,z])
01:54:56 <Cale> hmm...
01:55:19 * int-e agrees that returning the list is more convenient though.
01:55:28 <sinelaw> i don't need help. i need to pass my exams.
01:55:34 <Cale> I wonder if I have a real-world sort of use of scanr lying around. I know I have some uses of scanl.
01:55:47 <Peaker> medfly: That's not really true. I now find function compositions EASIER to read than lambda notations, for example
01:55:56 <Peaker> medfly: Especially in SEC style
01:56:01 <det> not neccesarily real world, just a toy example is fine
01:56:03 <Cale> foldr and scanl are somehow the more natural of the associations :)
01:56:05 <medfly> see? I can't even make sense of what you said.
01:56:26 <domor> Daerime: I thought that was an interesting question... how about using Text.Show.ByteString to show your floats then outputting the bytestring?
01:56:26 <Cale> > scanr (+) 0 [1,20,300,4000]
01:56:27 <int-e> tails = scanr (:) [] ... except for the minor detail of memory efficiency :-/
01:56:27 <lambdabot>   [4321,4320,4300,4000,0]
01:56:39 <domor> Dairim*
01:56:44 <domor> ....
01:56:47 <medfly> I could find a lot of good examples by looking for stuff ski wrote.
01:56:47 <blackdog> SEC style?
01:56:50 <Cale> > scanr (:) [] [1,2,3,4]
01:56:51 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
01:56:58 <domor> Daerim*
01:57:01 <blackdog> as in sections?
01:57:04 <medfly> 2009 Aug 06 00:03:47 <ski>      > let cfold' f z [] = z; cfold' f z (x:xs) = f x z `runCont` \y -> cfold' f y xs in (\f z l -> cfold' (\x t -> Cont $ \g -> f x (g t)) z l) (\n s -> concat ["(",show n," + ",s,")"]) "0" [1..]
01:57:07 <medfly> a fine piece of Haskell
01:57:18 <Peaker> <ski> (however for completeness, instead of `return $ (x:) $ getFloats (n-1)' you probably wanted `liftM (x :) (getFloats (n-1))')
01:57:34 <Peaker> blackdog: SEC as in:
01:57:36 <Peaker> @where SEC
01:57:36 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
01:57:42 <Cale> medfly: Indeed, you can learn something by figuring out what's going on there.
01:57:46 <blackdog> oh, i was looking at that. pretty cute.
01:58:08 <Daerim> domor, ohh! Thank you so much! I was about to attempt to write such a library myself out of frustration, not sure how I missed it on hackage
01:58:23 <medfly> Cale, it's IN ONE LINE
01:58:32 <Peaker> medfly: because of IRC :P
01:58:36 <Cale> medfly: Well, that's the easiest part to fix
01:58:38 <medfly> there are ways to avoid that!
01:58:46 <Peaker> medfly: that code would never be in one line outside of IRC
01:58:59 <monochrom> No way to avoid if you talk to lambdabot.
01:59:16 <blackdog> you do see some gnarly code in haskell, but it's usually because it's semantically complex - it's not like perl codegolf
01:59:23 <Peaker> medfly: that just seems to be illustrating writing a fold in continuation terms -- but the formatting indeed makes it hard to read
01:59:47 * blackdog is writing reams of Objective-C and missing Haskell quite a lot...
02:00:08 <medfly> codepad.org is nice
02:00:17 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6557#a6557
02:00:45 <monochrom> moonpatio is a bit slow for me today
02:00:50 <Peaker> blackdog: SEC are super important IMO -- without them, I had a serious problem with the ability to do:  blah.x.y.z += 1   in imperative languages, but no easy way to do it functionally.  With SECs that's:  modify . atBlah . atX . atY . atZ $ (+1)
02:00:56 <Cale> me too actually
02:01:32 <sinelaw> Peaker, fc-labels included?
02:01:32 <monochrom> And I'm really tempted to add a million newlines to it just to illustrate the absurdity of hating one-line.
02:02:03 <medfly> with some stuff, it makes sense not to stick it all on one line
02:02:14 <Cale> medfly: sure.
02:02:22 <Cale> medfly: Lambdabot demands it!
02:02:25 <Peaker> sinelaw: FC labels are like SEC with a fixed type and a getter
02:02:32 <monochrom> For the love of God, you are supposed to write your own syntax-directed editor that inserts newlines as per your preference settings, and ditch plain text file editors.
02:02:39 <Cale> medfly: You just have to imagine how the code would look in pretty form :)
02:02:48 <medfly> I'm not imaginative
02:03:15 <medfly> I don't like looking at a huge line just to realise, "oh, it's fold in continuation terms"
02:03:19 <Peaker> medfly: well, lambdabot is nice because everyone sees the result, codepad is in a different window and requires a click
02:03:52 <sinelaw> medfly, so you don't have to read that code at all.
02:04:15 <Peaker> You get a type signature and a couple of examples, yeah :)
02:04:16 <sinelaw> monochrom, exactly
02:05:47 <det> f x q : qs
02:05:49 <det> is that
02:05:54 <det> f x (q : qs)
02:05:56 <det> or
02:06:00 <Cale> (f x q) : qs
02:06:01 <det> (f x q) : qs
02:06:05 <medfly> http://www.haskell.org/haskellwiki/Shootout/Fasta#Current_best_entry_.28Haskell_GHC_.233.29 a fine piece of well documented Haskell
02:06:10 <domor> @quote mauke liftM
02:06:10 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
02:06:19 <Cale> Function application has higher precedence (binds tighter) than any infix operator
02:07:29 <Cale> heh
02:07:35 <medfly> homosapiens =  mkTree $ snd . mapAccumL (\rt (c,f) -> (f+rt,(c2b c,ceiling $ im*(f+rt)))) 0.0 $
02:07:35 <medfly>   [ ('a', 0.3029549426680), ('c', 0.1979883004921), ('g', 0.1975473066391), ('t', 0.3015094502008) ]
02:07:37 <medfly> this is my favourite
02:08:15 <int-e> > let u = scanl (+) 0; d = scanr (+) 0 in sum . u . u . d . d $ [1] -- number of permutations p of [1,2,3,4,5] with p(0) < p(1) < p(2) > p(3) > p(4) (Cale should find this familiar)
02:08:17 <lambdabot>   6
02:08:37 <Cale> ah, right, yes :)
02:09:08 <domor> medfly: that's for a benchmark contest, a good place to find the lowest-level, dirtiest code. I don't disagree that some comments would be nice of course but, there are better places to read code ;)
02:09:18 <medfly> >.<
02:09:26 <medfly> stop writing intentionally obfuscated code!
02:09:35 <Cale> medfly: hm?
02:09:57 <medfly> Cale, you don't write code
02:10:00 <Cale> int-e's code is actually a lot prettier than my implementation of that function :)
02:10:07 <monochrom> Did medfly tried to learn haskell for a year and had a nervous breakdown?
02:10:20 <medfly> try?
02:11:12 <Peaker> medfly: I think you're confusing obfuscated with concise :)
02:11:42 <medfly> just because it's on one line it doesn't mean it's concise
02:11:47 <Cale> I have some code which computes the number of permutations with a given pattern of ups and downs that goes by computing a determinant of a certain rational matrix.
02:11:48 <Peaker> medfly: When you take the genius of 30 lines of code and cram them in a single simple expression, that's a lot of wisdom to comprehend in very few tokens -- that's not obfuscated, it's just saving you from reading 28 lines of boilerplate
02:12:47 <Peaker> medfly: Take a Java program, remove all boilerplate, generalize all patterns to re-usable code, ta-da, a program that is 1/20 the size, where each line takes 5 times longer to read
02:13:02 <medfly> 5 is an underestimation
02:13:04 <Peaker> medfly: And yet, it would still take 1/4 of the time to comprehend the whole thing
02:13:48 <Peaker> medfly: Its an over-estimation, IME.  I now read Haskell code roughly the same speed that I read other languages' code, despite it cramming much more useful information and less boilerplate
02:15:07 <domor> medfly: I don't know your haskell experience, but it's probably because you haven't built arrays or used idioms like this yet. Just like you wouldn't understand much if you saw map<int,int> for the first time in your life, with no accompanying explanation.
02:15:16 <det> hmm, my pastebin (with added brackets) scanr isnt returning same as Haskell's
02:15:28 <det> (:) is just cons, right ?
02:15:32 <medfly> I have no idea what map<int,int> is.
02:15:32 <Cale> det: yep
02:15:52 <medfly> I'm complaining about you guys, not the language. Haskell can be nice. you make things intentionally ugly.
02:16:05 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
02:16:05 <domor> it's C++, and probably Java as well, but it doesn't matter much
02:16:08 <lament> you guys are ugly!
02:16:15 <medfly> yeah!
02:16:17 <maltem> Let me guess... a map from int to int?
02:16:19 <det> oh
02:16:25 <det> I used [1,2,3,4]
02:16:27 <Cale> Peaker: Well, when you read code in an imperative language, you waste a lot of effort on trying to keep track of the state of all the variables in your head, and it slows you down too.
02:16:29 <det> instead of [1;2;3;4] :-)
02:16:37 <domor> maltem: I see we have a pro :p
02:16:46 <maltem> :p
02:17:07 <Daerim> domor, curiously Text.Show.ByteString is marginally slower than a pure string/show implementation.... I've tried profiling it but I can't find any unexpected cost center
02:17:07 <int-e> and another use of scanr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16914
02:17:16 <medfly> at least imperative code has comments and isn't golfed or uses pl notation.
02:17:17 <domor> but seriously, I started to understand Haskell by trying to solve problems myself and learning bit by bit until the stuff posted here finally started making sense
02:17:36 <Cale> medfly: Golfing didn't start with Haskell :)
02:17:47 <domor> I think you might be attacking a big piece too quickly. shootout code is something...
02:17:49 <det> scanr implementation of returning 1 element + list is a lot nicer IMO : http://pastebin.ca/1775443
02:18:15 <Cale> (and for that matter, neither did points-free code, though probably functional programmers were the first to borrow the topologists' name for it.)
02:18:22 <domor> Daerim: too bad... I don't have any experience beyond knowing that it exists, sorry
02:19:46 <Peaker> medfly: Once I internalize the idioms by using them myself some (the way I have with sequence, mapM/forM, filterM, liftM/fmap, liftA2/etc, foldr, ..) code that uses them is super-readable.  But sure, initially:  liftA2 (,) [1,2,3] [4,5,6]  seemed very unreadable to me
02:19:56 <Cale> medfly: Most real Haskell code has lots of comments. We even have Literate Haskell which makes comments the default :)
02:20:25 <Daerim> domor, yes indeed.  I think the way to go is change the way Text.Show.Bytestring does its conversion, but that will be or another day I'm afraid
02:20:27 <Cale> medfly: Of course, most people don't comment the code which they're using lambdabot to run :)
02:20:45 <medfly> THIS CHANNEL HAS TOO MUCH CRAPPY, UNREADABLE CODE.
02:20:52 <medfly> it's fucking lambdabot's fault, then.
02:20:56 <Peaker> Cale: I think if you're going to comment something, might as well put that comment in a variable name :)
02:21:02 <Cale> medfly: It's good unreadable code. :)
02:21:03 <det> You guys are still debating this guy? He isnt even a very good troll :-)
02:21:14 <medfly> that's because I'm not trolling.
02:21:17 <Peaker> Cale: Names are better comments than comment
02:21:17 <Cale> @quote trolls
02:21:18 <medfly> I actually do know Haskell.
02:21:18 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
02:21:39 <osfameron> it's only waffer thin!
02:21:54 <Peaker> So I actually think textual comments (ignored by the compiler) are usually a bad thing :)
02:21:58 <medfly> I am not "frustrated because I can't seem to understand Haskell"
02:22:01 <Saizan> medfly: why do you take code used with lambdabot as example? however the implementation of scanr above from the haskell report is perfectly fine if you put some effort into reading it.
02:22:05 * maltem in the LA course this morning had the feeling that tensor algebra is like Haskell programming... you try everything until it type-checks (is well-defined and linear)
02:22:10 <medfly> Saizan, THAT IS ALL I SEE
02:22:23 <Saizan> medfly: go read some package on hackage then.
02:22:23 <Peaker> medfly: read some Haskell blogs :)
02:22:50 <Alpounet> @where planet
02:22:51 <lambdabot> http://planet.haskell.org/
02:22:52 <int-e> medfly: if your head doesn't explode twice a day reading #haskell, you're doing it wrong ;)
02:23:03 <medfly> you mean the ones that expect you to make sense of everything using purely type signatures?
02:23:17 <Saizan> medfly: i meant read the code.
02:23:21 <blackdog> medfly: there seems to be a conflict in perceptions. Most of the regulars seem to think the compact style is readable, and you feel it isn't. What makes you so sure that the mistake is on their side?
02:23:46 <det> Why is the list version of scanr more convenient than a element + list version ?
02:23:54 <medfly> I think I will write a whole game in a huge one-liner
02:24:00 <medfly> with like 20,000 letters
02:24:03 <Cale> det: Well, int-e's example is good :)
02:24:07 <medfly> this channel would approve
02:24:16 <Cale> > let u = scanl (+) 0; d = scanr (+) 0 in sum . u . u . d . d $ [1] -- number of permutations p of [1,2,3,4,5] with p(0) < p(1) < p(2) > p(3) > p(4)
02:24:19 <lambdabot>   6
02:24:21 <Saizan> no, it wouldn't, we can judge.
02:24:27 <det> Cale, that is a terrible example :p
02:24:41 <int-e> det: because you're usually interested in the list - if you're interested in the head separately you likely won't need the list of intermediate results and should be using foldr.
02:24:46 <medfly> maybe even write a good code to one liner compiler
02:24:53 <Cale> det: you read the u as 'up' and d as 'down'
02:25:08 <medfly> of course, in one line
02:25:17 <medfly> because that's apparently the way to go.
02:25:20 <Cale> If scanl/scanr didn't produce a list, you couldn't compose like that
02:25:30 <det> medfly, now you're really turning on the charm, I like this angle, keep going with it
02:25:40 <det> you could
02:25:54 <det> just cons in between
02:26:04 <Cale> Yeah.
02:26:13 <medfly> then we would have a @golf thing too
02:26:16 <Cale> det: You're right in that it's a more exact type
02:26:26 <int-e> det: well, the theory is that you'd do that 99% of the time. :)
02:26:31 <medfly> which will be more frequently used than @pl
02:26:32 <Cale> det: It's just that usually the complete sequence of partial folds is meaningful on its own
02:27:01 <merehap> well @pl usually is the opposite of @golf, in my experience :)
02:27:22 <int-e>  @pl is pointless.
02:27:32 <merehap> wise words
02:27:51 <galdor> got a problem with   body <- readFile file
02:27:52 <galdor> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
02:27:55 <galdor> ghc 6.12.1
02:28:05 <galdor> is there a way to tell it to ignore encoding errors ?
02:28:22 <galdor> I don't care about them here, I just need to send some data on a socket
02:28:55 <Saizan> galdor: open the file in binary mode
02:29:09 <int-e> not using readFile, but you can use openBinaryFile and hGetContents yourself
02:29:14 <galdor> ok thank you
02:29:22 <Cale> :t System.IO.openBinaryFile
02:29:24 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
02:30:28 <Cale> Though you might find it more convenient to use Data.ByteString if you're working with binary data.
02:30:51 <int-e> true
02:30:57 <det> Cale, I guess you could do the type safe implementation in an auxillary funcion and scanr could just cons that
02:31:11 <Cale> det: yeah
02:31:33 <Peaker> Packing/unpacking byte strings is a bit painful.  StringLike class would be useful in the standard
02:31:35 <det> probably faster too
02:32:01 <Cale> det: You're right in that it does have a more precise type. The reason it returns just a plain list is just for the sake of convenience.
02:33:15 <det> Cale, I mean this: http://pastebin.ca/1775459
02:33:36 <det> Cale, same as Haskell prelude version but type safe
02:33:55 <det> erm, accidently indented second function with tab
02:35:07 <int-e> det: it wouldn't actually be faster in Haskell - you need a lazy pattern match (or scanr won't work on infinite lists) and pattern matching (:) is just as fast as pattern matching (,).
02:35:52 <galdor> with http://hpaste.org/fastcgi/hpaste.fcgi/save, file operation fails because it does something strange:
02:35:55 <galdor> ioctl(4, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7fffbb9a3540) = -1 ENOTTY (Inappropriate ioctl for device)
02:36:07 <det> int-e, (:) needs to check a tag
02:37:29 <int-e> Yes, but for (,) does check a tag as well, namely "is this evaluated". Hmm. I guess we need to measure this to get meaningful answer.
02:40:03 <Saizan> galdor: you've linked the wrong page
02:40:11 <galdor> oops
02:40:19 <galdor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16915#a16915
02:40:20 <galdor> sorry
02:41:06 <Saizan> galdor: you shouldn't hClose h, btw
02:41:38 <Saizan> hGetContents reads the file from disk as you force the String
02:41:55 <galdor> yep
02:41:59 <Saizan> so you want to let it close the handle when it finishes
02:42:45 <galdor> oh, hGetContents is lazy
02:43:06 <galdor> I think I understand it better, thank you
02:43:29 <Saizan> well, not "lazy" but "lazy I/O" which is actually some weird form of concurrency :)
02:43:54 <galdor> yep, so I was closing the file while it was still reading it
02:45:20 <int-e> det: Oh, it's worse. It has to construct temporary pairs. However, the difference in running time disappears in the noise for me.
02:46:09 <ski> medfly : i'm glad you think that continuation fold example (from YAHT, with `Cont's inserted my me) is confusing, i think so too
02:46:27 <ski> shortly afterwards i was suggesting
02:46:30 <ski> * ski would do proper CPS translations of `foldr' or `foldl' (possibly with the shortcut taken in YAHT) instead of mixing them .. at least to start with
02:49:53 <int-e> det: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16916#a16916 -- feel free to play with the code
02:50:41 <det> int-e, is the toplevel a good place to benchmark ?
02:51:01 <int-e> I compiled the module with -O2
02:51:11 <Saizan> i've found most of YAHT confusing, actually
02:51:19 <Peaker> I think lazy I/O is a betrayal of the things that make Haskell great...
02:51:20 <int-e> and the overhead of calling the compiled code is rather small, so I think that's fine
02:51:47 <Peaker> "Prolonged embarassment" led to a good thing -- without lazy I/O I think the same thing would happen (Iteratee is probably not the end of the road)
02:51:57 * ski idly wonders whether using CPS would be faster, there ..
02:52:18 <QtPlatypus>    
02:55:51 <int-e> ski: you have to preserve laziness though ... at best you'd get some build/foldr fusion, I think. that would probably help.
02:56:19 <det> hmm
02:56:29 <det> what is an example ghc command line to make a binary
02:56:35 <det> I am getting undefined symbols
02:56:45 <int-e> ghc -c -O2 Module.hs
02:56:57 <det> but to make a executable, not library
02:56:59 <Peaker> I've only really used ghc --make myself :)
02:57:25 <c_wraith> yeah.  unless you're compiling individual modules for later linking, use --make
02:57:43 <int-e> ah. ghc --make usually. ghc -package <whatever package is missing> -package <another package> ... modules
02:59:32 <galdor> since length (s :: String) returns the number of characters, how can I get the number of bytes ?
03:00:05 <int-e> String is literally a list of Chars.
03:00:39 <Peaker> galdor: Chars are not bytes, there are no bytes -- you mean number of bytes if those chars were encoded in UTF8?
03:01:20 <galdor> well when I read a binary file, I get a String
03:01:42 <int-e> when you read it in binary mode you get one char per byte.
03:01:46 <Peaker> galdor: I think there's a default decoder that uses utf8, but I am not sure. You can use a ByteString read
03:02:15 <galdor> int-e: so length contentOfABinaryFile yields the number of bytes ?
03:02:27 <int-e> yes.
03:02:38 <galdor> ok thank you
03:03:14 <det> what is main supposed to return ?
03:03:28 <ski> `IO a', for any type `a'
03:03:36 <det> Can I do : main = show (g0 10000000)
03:03:39 <ski> (return value of type `a' ignored)
03:03:45 <ski> no
03:03:48 <ski> you can do
03:03:56 <ski>   main = print (g0 10000000)
03:03:59 <ski> @src print
03:03:59 <lambdabot> print x = putStrLn (show x)
03:04:07 <ski> @type putStrLn
03:04:08 <lambdabot> String -> IO ()
03:04:26 <int-e> @type Syste.IO.hFileSize
03:04:27 <lambdabot> Couldn't find qualified module.
03:04:33 <int-e> @type System.IO.hFileSize
03:04:34 <lambdabot> GHC.IOBase.Handle -> IO Integer
03:04:49 <det> Thanks
03:05:05 <ski> (you could also do `main = return (show (g0 10000000))', but that probably doesn't do what you want)
03:05:30 <trzkril> would that acutally do anything?
03:06:06 <int-e> it would allocate a thunk, then discard it
03:06:38 <int-e> (actually I'm not sure. ghc might optimize that away.)
03:08:25 <mm_freak> huh?!
03:08:27 <mm_freak> main :: IO ()
03:09:00 <mm_freak> if you want to return a value to the calling process, you need to use an exception
03:09:11 <det> My version is slightly slowe in my benchmarks
03:09:21 <mm_freak> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-Exit.html
03:10:36 <det> too bad Haskell cant optimize away the allocation
03:10:44 <ski> mm_freak : `main :: IO String' works fine too (but the string returned is ignored)
03:10:47 <det> GHC*
03:11:40 <mm_freak> ski: ah, ok
03:11:55 <mm_freak> that's useful
03:12:04 <mm_freak> saves me a return () sometimes =)
03:12:11 <ski> (now, whether it's sensible to allow `main :: IO a' for any `a' you like .. is a different question)
03:12:18 <mm_freak> det: could you summarize what you're trying to do?
03:12:36 <mm_freak> ski: it is, but it would make your life harder anyway
03:12:38 <mm_freak> return undefined
03:12:39 <det> mm_freak, benchmarking 2 versions of foldr
03:13:18 <ski> mm_freak : btw, note that i did not mean `main :: forall a. IO a'
03:13:42 <mm_freak> det: two versions?  the most straightforward implementation is going to work best anyway
03:13:50 <mm_freak> ski: that's the same
03:14:10 <c_wraith> ski: you *could* make that your signature for main, if the last thing it did was undefined. :)
03:14:17 <ski> (sometimes the implicit quantification of variables (not occuring in context) at type signature boundaries is bothersome, in discussions)
03:14:20 <c_wraith> unless the compiler rejects it, of course
03:15:06 <ski> mm_freak : by "allow `main :: IO a' for any `a' you like" i meant specifically "allow `main :: IO String'","allow `main :: IO ()'","allow `main :: IO Donut'",&c.
03:15:51 <ski> (iow, `a' was a meant to be a free type variable in `main :: IO a')
03:15:53 <mm_freak> ski: oh, ok, then i misunderstood you
03:15:54 <mm_freak> sorry =)
03:15:57 <Peaker> I think only  IO ()  should be allowed
03:16:31 <mm_freak> i think everything should be allowed, but anything other than IO () should produce a warning
03:16:40 <Peaker> Well, I like -Werror :)
03:16:42 <ski> Peaker : and do you agree that `mapM_ :: Monad m => (a -> m ()) -> ([a] -> m ())', as well ? :)
03:16:50 <Peaker> ski: yep
03:17:11 <ski> @type forever
03:17:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
03:17:34 <mm_freak> isn't that the way it is?
03:17:34 <Peaker> Should be:  Monad m => m () -> m Void
03:17:40 <mm_freak> ah
03:17:43 <ski> @type mapM_
03:17:45 <mm_freak> well, Void is non-h98
03:17:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:17:56 <Peaker> mm_freak: newtype Void = Void Void
03:18:05 <mm_freak> but then it's isomorphic to ()
03:18:11 <Peaker> mm_freak: nope, it has no values
03:18:19 <ski> Peaker : maybe .. or maybe `Monad m => m (exists a. a) -> m (forall a. a)'
03:18:19 <Peaker> (except bottom)
03:18:20 <mm_freak> oh
03:18:23 <mm_freak> indeed
03:18:54 <Peaker> ski: but then the ignoring of a result code is implicit and may be accidental
03:19:01 <mm_freak> well, that may be inconvenient
03:19:03 <ski> (the proper definition of `Void' should simply be `data Void', with no constructors to match on)
03:19:11 <mm_freak> i think a unit type is fine
03:19:15 <Peaker> ski: ghc 6.12's new "value is ignored in do block" caught 2 bugs in my SDL wrapper (the SDL functions return a Bool for error and I ignored it)
03:19:23 <mm_freak> or would you prefer to write 'return undefined'?
03:19:30 <ski> Peaker : yes .. i'm not sure what is best
03:19:30 <Peaker> ski: What practical difference is there?
03:19:45 <Peaker> ski: I think bug-catching is more important than not needing to use ()<$
03:19:50 <Peaker> @type (()<$)
03:19:51 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
03:20:03 <Saizan> mm_freak: you don't need to "return undefined", forever a = a >> forever a matches that type
03:20:29 <ski> Peaker : re `Void', i think the `data Void' is clearer in that it simply states that there isn't possibly any pattern you could match with
03:20:34 <mm_freak> Saizan: yes, but my last action in 'main' is seldomly a forever action
03:20:53 <Saizan> ah, sorry, missed the context
03:21:00 <Peaker> ski: sure, but it's not H98... the newtype is a little clunkier but I don't think its problematic
03:21:09 <ski> Peaker : and btw, i've used `Void' to some great good in code (namely `kill :: SystemM Void')
03:21:25 <Peaker> mm_freak: main should return (), not Void. But forever should return Void
03:21:44 <ski> (Peaker : that saved me from having lots of `return undefined' which i couldn't tell whether they could ever be triggered or not)
03:22:00 <c_wraith> return undefined seems redundant
03:22:18 <mm_freak> Peaker: oh, you changed the context already
03:22:22 <c_wraith> I guess it's not fully redundant, but...  I don't know when the difference matters
03:22:33 <ski> in most code, `return undefined' should never be needed, imo
03:22:41 <mm_freak> well, i think forever should return (), too
03:22:50 <ski> mm_freak : "too" ?
03:23:07 <c_wraith> in addition to thinking main should return IO ()
03:23:14 <mm_freak> :t forkIO
03:23:16 <lambdabot> Not in scope: `forkIO'
03:23:25 <c_wraith> forkIO has a useful return value
03:23:25 <ski> @index forkIO
03:23:25 <lambdabot> Control.Concurrent
03:23:28 <mm_freak> forkIO :: IO () -> IO ThreadId
03:23:33 <mm_freak> @ ski
03:23:57 <mm_freak> in 99 out of 100 cases i write:  forkIO . runSomething . forever $ …
03:24:40 <ski> yes, it is cases like this that makes me unsure whether `forever' ought to use `Void'
03:25:29 <ski> i'm sure Peaker would suggest a `liftM (const ())' (or similar) in this case
03:25:32 <Saizan> (Void is the initial and forall a. a is the final (co?)algebra for the empty functor? does this sentence make any sense?)
03:26:00 <ski> Saizan : `Void' and `forall a. a' are isomorphic
03:26:09 <mm_freak> ski: () <$
03:26:13 <Saizan> true
03:26:15 <mm_freak> shorter, but uglier
03:26:24 <Saizan> so they must be the same thing.
03:26:26 <ski> @type (() <$)
03:26:27 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
03:26:57 <mm_freak> @djinn f a -> f ()
03:26:58 <lambdabot> -- f cannot be realized.
03:27:05 <mm_freak> @djinn Functor f => f a -> f ()
03:27:05 <lambdabot> Error: Class not found: Functor
03:28:04 <Saizan> constructor classes and djinn don't mix
03:28:14 <ski> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
03:28:21 <ski> @djinn Functor f => f a -> f ()
03:28:21 <lambdabot> -- f cannot be realized.
03:28:26 <ski> ho hum
03:28:35 <Saizan> told you.
03:28:38 <Saizan> :)
03:28:42 <ski> had to try ;)
03:29:30 <mm_freak> forkIO . execStateT () . runSomethingT . forever $ do
03:29:35 <mm_freak> but that's even worse =)
03:29:49 <mm_freak> forever returning Void would require a lot of hacks of that sort
03:30:13 <Peaker> @src (<$)
03:30:14 <lambdabot> (<$) = (<$>) . const
03:30:18 <ski> @type (`execStateT` ())
03:30:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => StateT () m a -> m ()
03:31:06 <mm_freak> i think it's ok to return a polymorphic type, where it's appropriate
03:31:17 <mm_freak> you can't abuse it anyway, as its never returned
03:31:59 <Peaker> I guess (forall a. a) is a valid substitute for Void (in forever and such) but isn't H98
03:32:10 <mm_freak> of course, you run into the problem of being able to write code, that is never actually reached =)
03:32:19 <Saizan> yeah, paradoxically it seems more important to use concrete types for arguments rather than return types
03:33:17 <ski> @type fix . (>=>)
03:33:18 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
03:33:22 <ski> @type fix . flip (.) . (=<<)
03:33:22 <lambdabot> forall b (m :: * -> *) b1. (Monad m) => (b1 -> m b1) -> m b1 -> b
03:34:34 <Saizan> aren't forall a b. m a -> m b and forall a. m a -> m (forall b. b) logically equivalent?
03:34:40 <ski> Peaker : i wonder how much a problem converting between `forall a. m (f a)' and `m (forall a. f a)' would be in practice ..
03:34:48 <mm_freak> Saizan: nope
03:35:02 <ski> Saizan : not if `m' is contravariant (or invariant)
03:35:52 <Peaker> I can't see the difference, in the first type, the "b" there must be bottom too
03:36:04 <Saizan> so if m is Monad they should?
03:36:27 <zygoloid> @type let forever :: (Monad m) => m a -> m (forall b. b); forever = undefined in do Just a <- forever (putStrLn "loop"); return a
03:36:28 <lambdabot>     Couldn't match expected type `forall b. b'
03:36:28 <lambdabot>            against inferred type `Maybe a'
03:36:28 <lambdabot>     In the pattern: Just a
03:36:37 <ski> (those two example above would show how `forall x. ... -> m x' with `x' only occuring there occurs "naturally", without any `undefined' business)
03:37:03 <mm_freak> Saizan:
03:37:06 <mm_freak> (return undefined :: IO a) >>= \() -> return ()
03:37:06 <mm_freak> *** Exception: Prelude.undefined
03:37:11 <mm_freak> (return undefined :: IO (forall a. a)) >>= \() -> return ()
03:37:14 <mm_freak>     Couldn't match expected type `forall a. a'
03:37:14 <mm_freak>            against inferred type `()'
03:37:21 <ski> Peaker : say that `m' is `Flip (->) e', where `newtype Flip f a b = MkF (f b a)'
03:37:42 <Saizan> mm_freak: that's just because GHC doesn't handle impredicativity very well
03:37:51 <ski> Saizan : i'm not sure
03:38:05 <mm_freak> well, the latter doesn't make sense to me either
03:38:18 <mm_freak> forall a. a is too polymorphic to be pattern-matched against ()
03:38:30 <mm_freak> otherwise the safety of ST would be gone, because it relies on this
03:38:42 <Saizan> it doesn't rely on this.
03:38:48 <mm_freak> not on pattern matching
03:38:55 <Saizan> runST requires a polymorphic value
03:39:00 <Saizan> it doesn't provide one.
03:39:14 <zygoloid> Saizan: it relies on the fact that (ST (forall s. s) a) can't unify with two different values of s.
03:39:28 <Saizan> it's indipendent of wheter you automatically instantiate something like (forall a. a) or not
03:39:29 <mm_freak> yes
03:39:39 <Saizan> zygoloid: no
03:39:44 <Peaker> ski: forall a b. (a -> e) -> (b -> e)   vs.    forall a. (a -> e) -> (forall b. b) -> e  -- it seems to me that in either case, the only possible value is bottom?
03:39:45 <Saizan> ?type runST
03:39:47 <lambdabot> forall a. (forall s. ST s a) -> a
03:39:54 <ski> @type let foo :: IO (forall a. a); foo = foo in foo >>= \x -> case x of () -> return "hello"
03:39:54 <lambdabot> IO [Char]
03:39:57 <Saizan> it doesn't even use that type :)
03:40:08 <Saizan> it just requires 's' to not be instantiated at all.
03:40:19 <ski> mm_freak : ^
03:40:27 <Peaker> ski: oh, wait, the forall'd b I can give in place of a
03:41:28 <mm_freak> Saizan: the quantification makes sure that it's too polymorphic to be used as any other type…  i don't know whether i use the correct terminology
03:41:32 <zygoloid> Saizan: hmm, i thought there was something evil you could do with stToIO but i guess you're right :)
03:41:54 <ski> Peaker : with `forall a b. (a -> e) -> (b -> e)', the caller can pick any type to use for the second argument .. with `forall a. (a -> e) -> (forall b. b) -> e', the caller has to provide a polymorphic second argument so that the callee (presumably) can choose any type it likes
03:42:02 <ski> Peaker : see the difference ?
03:42:11 <mm_freak> for that reason you can't pattern-match against 's', too (unless you don't use runST)
03:42:22 <mm_freak> that's my understanding
03:42:30 <ski> *nod*
03:42:31 <Peaker> ski: Yeah - that's what I said later
03:42:45 <Peaker> @type head (undefined :: forall a. a)
03:42:46 <lambdabot> forall a. a
03:42:47 <ski> (ok. i couldn't decipher it ;)
03:43:22 <Peaker> ski: the forall'd b (the polymorphic type from the caller) I (the callee) can give in place of "a" (as the arg to the func)
03:43:23 <Saizan> mm_freak: the quantification makes sure you didn't instantiate the 's', and so you can't use runST on something of type ST s (STRef s a) because the 's' would appear in the result, and so instantiated there
03:43:31 <Saizan> mm_freak: s is a type.
03:43:38 <Saizan> mm_freak: you don't patter match on types
03:43:52 <Peaker> @type let (x:xs) = (undefined :: forall a. a) in undefined
03:43:53 <lambdabot> forall a. a
03:44:10 <mm_freak> Saizan: i think we mean the same =)
03:44:20 <ski> @type let (x:xs) = (undefined :: forall a. a) in (x,xs)
03:44:20 <lambdabot> forall t. (t, [t])
03:44:34 <Saizan> mm_freak: do you understand why this has nothing to do with your earlier example?
03:44:54 <mm_freak> Saizan: nope
03:45:00 <Peaker> @type do { Just (x:xs) <- (undefined :: forall a. [a]) ; return () }
03:45:00 <Saizan> then we dont' :)
03:45:01 <lambdabot> [()]
03:45:15 <mm_freak> ok =)
03:45:17 <Peaker> @type do { Just (x:xs) <- (undefined :: forall a. a) ; return () }
03:45:18 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
03:45:50 <zygoloid> @type do { Just (x:xs) <- (undefined :: [forall a. a]); return () }
03:45:51 <lambdabot>     Couldn't match expected type `forall a. a'
03:45:51 <lambdabot>            against inferred type `Maybe a'
03:45:51 <lambdabot>     In the pattern: Just (x : xs)
03:46:00 <zygoloid> @type (>>=)
03:46:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:46:26 <Peaker> ah :-)
03:46:42 <Alpounet> @type do { Just (x:xs) <- return (undefined :: [forall a. a]); return () }
03:46:43 <lambdabot>     Couldn't match expected type `[forall a. a]'
03:46:44 <lambdabot>            against inferred type `Maybe a'
03:46:44 <lambdabot>     In the pattern: Just (x : xs)
03:47:25 <Saizan> ski: do you know of a good reason why  \() -> .. and \x -> case x of .. are typed differently ?
03:47:42 <Peaker> zygoloid: the "a" in the type of (>>=) can only capture monomorphic types?
03:47:51 <Saizan> @type do { (x:xs) <- return (undefined :: [forall a. a]); return () } -- maybe ?
03:47:52 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
03:48:34 <zygoloid> the problem is more that the type of (>>=) is too specific; if haskell had subtyping we might write something like: forall m a1 a2 b1 b2. (a1 :> a2, b1 :> b2) => m a1 -> (a2 -> m b1) -> m b2
03:48:35 <Saizan> to pattern match against just you'd have to use Maybe [forall a. a] as type
03:48:40 <Peaker> Saizan: I was wondering why pattern matching a value of type (forall a. a) against Just was a problem (It seems not to be in general, only in a do block, because of the type of >>= )
03:48:53 <Saizan> Peaker: it's not doing that
03:48:56 <ski> Saizan : no, i'm not sure of why there's a difference, here
03:49:00 <zygoloid> i might have got one/both of the subtype annotations backwards :)
03:49:24 <Saizan> @type do { (Just x:xs) <- return (undefined :: [forall a. a]); return () } -- i guess this won't work for the same reason the lambda doesn't
03:49:25 <lambdabot>     Couldn't match expected type `forall a. a'
03:49:25 <lambdabot>            against inferred type `Maybe a'
03:49:25 <lambdabot>     In the pattern: Just x
03:49:28 <Peaker> Saizan: Your example isn't, you mean?
03:49:40 <Saizan> Alpounet's example isn't.
03:49:52 <Peaker> I know, his is just [] vs Maybe :)
03:50:41 <Peaker> zygoloid: well, that's one solution - but if type variables could capture polymorphic types, that would work too, maybe?  (Perhaps with disasterous consequences)
03:50:50 <Saizan> Peaker: yours doesn't work because of incosistencies in how polymorphic types get instantiated, it seems
03:51:06 <Peaker> m a -> (a -> m b) -> m b     -- where "a" and "b" can be things like (forall z. z)
03:51:18 <ski> @type let foo :: Maybe (forall a. f a) -> (forall a. Maybe (f a)); foo Nothing = Nothing; foo (Just fa) = Just fa in foo
03:51:19 <lambdabot> forall (f :: * -> *) a. Maybe (forall a1. f a1) -> Maybe (f a)
03:51:23 <zygoloid> Peaker: /something/ has to capture the fact that correct Monad instances must be covariant
03:51:26 <ski> is the inverse possible to do ?
03:51:43 <Peaker> Saizan: Maybe I'm just rewording what you said, but it seems to me to be about universal type-variables being able to only capture non-polymorphic types
03:51:45 <Saizan> Peaker: those are called impredicative types, and GHC has an half-baked support for them
03:51:48 <zygoloid> Peaker: the compiler can't deduce that because type constructors don't have to be covariant in general
03:51:55 <ski> zygoloid : instances of `Functor' must be covariant
03:52:04 <pozic> Do you also often have that you often start with functional data structures and end up with 80% of the solution being mutable in the end?
03:52:15 <Peaker> I thought Functor was variant, and CoFunctor was covariant?
03:52:25 <ski> Peaker : argh, no !
03:52:47 <ski> the "co" in "covariant" has *nothing* to do with the one in "comonad",&c.
03:52:53 <Saizan> @type do { x <- (undefined :: [forall a. a]); return (case x of Just _ -> ())  } -- Peaker
03:52:54 <lambdabot> [()]
03:53:01 <Peaker> ski: Sorry.. Can you explain what it does mean?
03:53:05 <ski> `Functor' is the class for covariant functors
03:53:13 <ski> there is also contravariant functors
03:53:15 <zygoloid> ski: i agree but i'm not sure what point you're making.
03:53:34 <Saizan> Peaker: in GHC type variables _can_ capture polymorphic types, it's just pattern matching that's inconsistent with case .. of
03:54:02 <pozic> I always forget what co/contravariant means. Is there an easy way to remember?
03:54:14 <zygoloid> roughly, co means 'with', contra means 'against'
03:54:23 <zygoloid> as in <various english words>
03:54:29 <ski> zygoloid : well, i was responding to your "/something/ has to capture the fact that correct Monad instances must be covariant" .. i'm not sure what you were discussing, though
03:54:36 <Peaker> is covariant the opposite of contravariant?
03:54:43 <ski> in a sense, yes
03:54:49 <pozic> zygoloid: it is more the "variant" part which is unclear ;)
03:54:56 <ski> but they are not duals, in the categorical sense
03:54:59 <pozic> zygoloid: sure, the "relation" varies.
03:55:00 <Cale> Peaker: If you have fixed categories C and D, then a covariant functor is just the normal sort of functor C -> D, and a contravariant functor is a functor C^op -> D, or C -> D^op (which amount to the same thing)
03:55:19 <Cale> Basically, one which reverses the direction of the arrows
03:55:26 <Saizan> pozic: a covariant functor has fmap :: (a -> b) -> (f a -> f b) the arrows go in the same order, a contravariant one has contramap :: (b -> a) -> (f a -> f b) they go in the opposite one
03:55:27 <zygoloid> ski: the point i was making was, the type of (>>=) is not enough to show that 'm' is covariant, which is why the case we're discussing doesn't compile
03:56:03 <Saizan> pozic: so "varies in the same direction" or "varies in the opposite direction"
03:56:14 <zygoloid> pozic: covariant means 'if a is a subtype of b, then m a is a subtype of m b' and contravariant means 'if a is a subtype of b, then m b is a subtype of m a'
03:56:14 <pozic> Saizan: can you apply that directly to e.g. array semantics in some object oriented language?
03:56:28 <ski> zygoloid : well, using `return' as well, you get `liftM' / `fmap'
03:56:39 <Saizan> pozic: you mean wrt subtyping?
03:56:42 <pozic> zygoloid: thanks, together with Saizan it all makes sense now.
03:56:55 <pozic> Saizan: yes
03:57:24 <Saizan> yeah, what zygoloid said, though mutable structures are invariant
03:57:31 <ski> pozic : yes .. with mutable arrays you get that `Array a' is a subtype of `Array b' if `a' is a subtype of `b' *and* `b' is a subtype of `a'
03:57:35 <pozic> Saizan: so, what is invariant then?
03:57:50 <ski> (and then `Array' would be called "invariant" iiuc)
03:57:54 <zygoloid> ski: sure, but we're not discussing what you and i can figure out, just what the compiler can infer :)
03:57:56 <Saizan> what ski said :)
03:58:25 <pozic> ok, so contra and co <=> in
03:58:53 <Saizan> yeah, in the sense that in has both the requirements of co and contra
03:59:07 <RayNbow> ski: but Java got that wrong :p
03:59:16 <ski> zygoloid : i'm sorry for not keeping up with what you're discussing. is there a particular example up there i should look for ?
04:00:08 <Peaker> Saizan: when using   (m (forall a.a)) >>= (\x -> ...)   it doesn't seem the type of "x" gets to be (forall a. a)
04:00:22 <zygoloid> ski: yes, the examples which are using m (forall a. a) on the LHS of >>=, and (b -> m c) on the RHS for some specific b.
04:00:41 <zygoloid> ski: ghc can't unify the (forall a. a) and the (b)
04:00:47 <Saizan> @type do { x <- (undefined :: [forall a. a]); return (x :: Int, x :: Char)  } -- let's try
04:00:48 <lambdabot> [(Int, Char)]
04:00:56 <Saizan> Peaker: it looks like it does to me :)
04:01:00 <zygoloid> (even though that's actually OK because m is covariant)
04:01:01 <ski> zygoloid : maybe it can with ImpredicativeWhatever ?
04:01:51 <Alpounet> (it'd be nice to have a @ghc command for lambdabot, searching the possible flags and giving a short description of what it does)
04:02:13 <Peaker> @type return (undefined :: forall a. a) >>= (\x -> (head x, fromJust x))
04:02:14 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
04:02:14 <lambdabot>     In the first argument of `fromJust', namely `x'
04:02:14 <lambdabot>     In the expression: fromJust x
04:02:33 <Peaker> Saizan: doesn't this mean the type of "x" isn't (forall a. a) ?
04:02:38 <ski> (zygoloid : i.e. i'm suggesting that maybe it refuses to instantiate the quantified variable `a' in 'forall a b. m a -> (a -> m b) -> m b' to `forall x. x', when trying to unify the `m a' with `m (forall x. x)')
04:02:57 <Peaker> @type let x = undefined :: forall a. a in (fromJust x, head x)
04:02:58 <lambdabot> forall a a1. (a, a1)
04:05:36 <Peaker> I wonder what the consequences of having function parameters capture the fully polymorphic type of passed arguments would be
04:06:19 <nus> :t id
04:06:20 <lambdabot> forall a. a -> a
04:06:26 <nus> :t flip
04:06:27 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:06:35 <nus> huh
04:06:37 <ski> @type Prelude.flip
04:06:37 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:06:43 <mm_freak> :t const
04:06:44 <lambdabot> forall a b. a -> b -> a
04:07:01 <nus> ski, aha, there it is!
04:07:08 <nus> :t flip id
04:07:09 <lambdabot> forall a b. a -> (a -> b) -> b
04:07:40 <Alpounet> @index flip
04:07:40 <lambdabot> Prelude
04:07:42 <mm_freak> :t fix id
04:07:43 <lambdabot> forall a. a
04:07:52 <Alpounet> not that one
04:08:00 <Alpounet> where's the Functor flip ?
04:08:07 <ski> Alpounet : it's Caleskell
04:08:15 <Alpounet> haha
04:08:20 <Alpounet> ok
04:08:31 <mm_freak> @src flip
04:08:31 <lambdabot> flip f x y = f y x
04:08:32 <ski> (suggested by me, but Caleskell, nonetheless)
04:09:16 <Peaker> ski: where does the extra generality of flip that way come into play?
04:09:31 <ski> Peaker : i'm not sure :)
04:09:34 <nus> erhm, how come 'flip id' typecheks?
04:09:41 <nus> checks*
04:09:52 <dmwit> because
04:09:58 <mm_freak> nus: id may take a function as its parameter
04:09:59 <Stinger> cause a can be (b -> c)
04:10:00 <dmwit> id :: (a -> b) -> (a -> b)
04:10:23 <ski> nus : start with `id :: forall a. a' and `flip :: forall a b. a -> (a -> b) -> b'
04:10:31 <Alpounet> functions are values, in Haskell
04:10:34 <nus> oh, higher-order types, of course, thanks for the reminder
04:10:35 <mm_freak> (a -> b) -> (a -> b) = (a -> b) -> a -> b
04:10:36 <Alpounet> thus we can apply id on them
04:10:54 <mm_freak> higher order functions =)
04:10:54 <ski> (er, s/id :: forall a. a/id :: forall a. a -> a/)
04:11:08 <ski> nus : instantiate the `forall'-bound variables with fresh names, so you get `id :: a0 -> a0',`flip :: a1 -> (a1 -> b1) -> b1'
04:11:34 <mm_freak> > flip [(+1), (+2)] 5
04:11:35 <lambdabot>   [6,7]
04:12:01 <Alpounet> heh, that's the functorial one
04:12:52 <mm_freak> > (+) <$> [1,2] `flip` 3
04:12:53 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:12:53 <lambdabot>    `GHC.Num.Num a' arising f...
04:12:55 <ski> (hrm, bad mispastes :/)
04:13:06 <mm_freak> > (+) <$> [1,2] `flip` (3::Int)
04:13:07 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> a))
04:13:07 <lambdabot>    arising from the lite...
04:13:29 <mm_freak> > (+) <$> ([1,2] `flip` 3)
04:13:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:13:31 <lambdabot>    `GHC.Num.Num a' arising f...
04:13:34 <ski> nus : .. obviously one should start from `flip :: forall a b c. (a -> b -> c) -> (b -> a -> c)'
04:13:51 <Alpounet> :t flip
04:13:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:14:00 <mm_freak> :t (<*>)
04:14:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:14:01 <ski> nus : so we get `id :: a0 -> a0' and `flip :: (a1 -> b1 -> c1) -> (b1 -> a1 -> c1)'
04:14:39 <ski> nus : then unify the type of `id' with the argument type of `flip' : `a0 -> a0  =  a1 -> b1 -> c1' from which `a0  =  a1' and `a0  =  b1 -> c1' follows
04:15:56 <ski> nus : the result type of the application `flip id' is now the result type of `flip', i.e. `b1 -> a1 -> c1', which after subsituting `a1  =  b1 -> c1', becomes `b1 -> (b1 -> c1) -> c1'
04:16:39 <ski> nus : final step, generalize `b1 -> (b1 -> c1) -> c1' on the free type variables that are not in context (no context, here), so you get `forall a b. a -> (a -> b) -> b'
04:16:57 <Alpounet> ski, where's Caleskell's flip definition?
04:17:27 <ski>   flip :: Functor f => f (a -> b) -> (a -> f b)
04:17:28 <ski>   flip f a = fmap ($ a) f
04:17:31 <ski> is what i used
04:17:38 <Alpounet> ok thanks
04:17:41 <Saizan> Peaker: re forall a.a discurssion, if you really want to understand how this works, you should first learn it in a language where type abstraction and application are explicit, then you can make sense of what GHC does by guessing where it inserts them for you.
04:18:40 <ski> (also, now i remember that i saw that `flip' suggested in a paper (not CS-related))
04:19:41 <Saizan> Peaker: and it that example it just means that your (undefined :: forall a. a) got instantiated before return were applied to it
04:21:21 <Saizan> ?type (return undefined :: Maybe (forall a. a)) >>= (\x -> return (head x, fromJust x))
04:21:22 <lambdabot> forall a a1. Maybe (a, a1)
04:22:39 <Saizan> "undefined :: forall a. a" is the same as "undefined"
04:25:39 <ski> @type return undefined >>= (\(x :: forall a. a) -> Just (head x, fromJust x))
04:25:40 <lambdabot>     Cannot match a monotype with `forall a. a'
04:25:40 <lambdabot>       Expected type: a
04:25:40 <lambdabot>       Inferred type: forall a1. a1
04:30:18 <ski> @type let foo :: Maybe (forall a. f a) -> (forall a. Maybe (f a)); foo Nothing = Nothing; foo (Just fa) = Just fa in foo
04:30:18 <lambdabot> forall (f :: * -> *) a. Maybe (forall a1. f a1) -> Maybe (f a)
04:31:22 * ski ponders inverting this
04:49:59 <Peaker> Saizan: thanks
04:50:21 <Peaker> I really wouldn't expect "(return undefined :: Maybe (forall a. a)) >>= (\x -> return (head x, fromJust x))" to work
04:50:43 <Peaker> (So that means I learned something :-)
04:51:46 <Alpounet> why does this actually work by the way ?
04:51:50 <Saizan> ski: you should be able to by using the argument twice
04:51:56 <Saizan> maybe?
04:52:29 <ski> how ?
04:53:34 <Saizan> Alpounet: thing of a value of type forall a. a as a function from a type to a value of that type, and remember that GHC fills that type argument for you behind the scene
04:54:44 <Alpounet> oooh, okay
04:54:46 <Saizan> @type let foo :: (forall a. Maybe (f a)) -> Maybe (forall a. f a); foo x = case x of Nothing -> Nothing; Just _ -> Just (fromJust x)
04:54:47 <lambdabot> <no location info>:
04:54:47 <lambdabot>     not an expression: `let foo :: (forall a. Maybe (f a)) -> Maybe (forall a. f a); foo x = case x of Nothing -> Nothing; Just _ -> Just (fromJust x)'
04:54:53 <Saizan> @type let foo :: (forall a. Maybe (f a)) -> Maybe (forall a. f a); foo x = case x of Nothing -> Nothing; Just _ -> Just (fromJust x) in foo
04:54:54 <lambdabot> forall (f :: * -> *). (forall a. Maybe (f a)) -> Maybe (forall a. f a)
04:55:03 <Saizan> ski ^^^
04:55:50 <Saizan> parametricity should guarantee that the use of fromJust is safe, afaiu
04:58:12 <ski> Saizan : hm, interesting
04:58:37 <mreh> :t min `on` snd
04:58:38 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> b
04:59:27 <mreh> how do you reduce a list of tuples to the tuple that has a certain property?
04:59:33 <mreh> like the minimum snd
05:00:01 <Alpounet> why would there be only one tuple having that property ?
05:00:27 <Alpounet> (in the general case, not for the 'min')
05:01:09 <mreh> well I only want on
05:01:17 <Saizan> ?type minimumby (compare `on` snd)
05:01:18 <lambdabot> Not in scope: `minimumby'
05:01:21 <Saizan> ?type minimumBy (compare `on` snd)
05:01:22 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
05:01:33 <mreh> the alternative is sorting the list, which is O(n log n), comparing is just O(n)
05:01:35 <mreh> aaah yes
05:02:18 <dmwit> take k . sort is O(n log k)
05:02:23 <dmwit> just so you know
05:02:31 <dmwit> In case you find out later one isn't enough. =)
05:04:08 * hackagebot upload: Hipmunk 5.0.1 - A Haskell binding for Chipmunk. (FelipeLessa)
05:05:08 * hackagebot upload: Hipmunk 5.0.1.1 - A Haskell binding for Chipmunk. (FelipeLessa)
05:05:14 <dmwit> heh
05:05:18 <dmwit> ?hackage Hipmunk
05:05:18 <lambdabot> http://hackage.haskell.org/package/Hipmunk
05:06:10 <dmwit> "doubling the number from four to nine"
05:06:11 <dmwit> uh
05:06:34 <dmwit> Anyway, shame it's still such a straight translation of the Chipmunk library.  I keep hoping there will be a more Haskell-y binding...
05:17:41 <Arnar> hey.. anyone up to looking at a small TypeFamilies thing I'm having problems with?
05:17:44 <Arnar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16922#a16922
05:18:49 <Arnar> it doesn't seem to be able to unify an associated type.. thought scoped type variables would help but it didn't
05:29:47 <cheater> how does happstack's persistence layer share across multiple servers in a cluster?
05:30:05 <Axman6> that's a good question
05:30:10 <burp> it doesn't
05:30:15 <Lemmih> It doesn't yet.
05:30:40 <Axman6> hmmm... seems the Paxos algorithm could be used here
05:30:54 <burp> http://tutorial.happstack.com/tutorial/macid-limits
05:31:06 <burp> http://tutorial.happstack.com/tutorial/multimaster
05:31:26 <Arnar> have to run, if someone looks at that typefamilies paste ping me :D
05:31:44 <Lemmih> The multimaster code is no more.
05:32:00 <burp> oh
05:33:18 <Axman6> the happstack peeps need to pay some attention to all the research google has done about this stuff
05:34:27 <nainaide> How can I send out a "Ctrl+z", please?
05:35:21 <Lemmih> Paxos is way too complicated. The underlying system should only provide replication and partitioning, and not any transaction conflict resolution.
05:35:35 <Axman6> i guess
05:35:44 <Axman6> still, it's not exactly a complicated algorithm
05:39:15 <Lemmih> Systems that statically resolve all conflicts are tremendously preferable to systems that handle conflicts at run-time.
05:39:17 <ski> Arnar : hm, using `forall d. ' gets rid off all but one error message ..
05:42:23 <ski> @tell Arnar hm, adding (as you probably meant to do) `forall d. ' on the signature for `f' gets rid off all but one error message ..
05:42:23 <lambdabot> Consider it noted.
05:44:28 <Botje> nathanic: do you mean sending an eof as in windows or a SIGSUSP as in *nix?
05:44:38 <Botje> that should have been for nainaide
05:44:38 <Botje> grr
05:45:26 <ski> > chr (ord 'Z' - ord '@')  -- also
05:45:26 <lambdabot>   '\SUB'
05:47:42 <Saizan> Arnar: you've to "forall d. (Device d) => d -> IO ()"
05:49:07 <Saizan> oh, coord can't work.
05:50:18 <Saizan> Arnar: since type synonym families are not injective, you can't have a method with a type like coord that mentions the typeclass argument 'd' only as an argument to the type family Coord
05:50:32 <Saizan> Arnar: it has no way to pick which instance you want
05:51:14 * ski was suspecting something like that could be an issue ..
05:51:36 <ski> (.. but is that the cause of the type error, here ?)
05:57:28 <Saizan> i think what happens is that the use of coord gets instantiated with a fresh type variable d1, so the result end up of type Coord d1, then it checks that it matches Coord d, at this point if Coord were a constructor it'd unify d1 and d, but here it can't and errors out
05:58:26 <Arnar> Saizan: thanks
05:58:26 <lambdabot> Arnar: You have 1 new message. '/msg lambdabot @messages' to read it.
05:58:34 <Arnar> Saizan: I did try binding d with forall
05:58:38 <Arnar> I still get one error
05:58:48 <Arnar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16922#a16923+
05:59:14 <Arnar> sorry I forgot that in the paste originally
05:59:20 <Arnar> damn it.. I have to run again :(
06:00:13 <Arnar> be back in a bit
06:01:53 <Saizan> Arnar: see the rest of the dicussion :)
06:04:10 <Saizan> Arnar: the fundamental point is that if F is a type synonym (family or not) then F a ~ F b doesn't imply a ~ b, so when you use coord you've no way to control which type to use for the type variable 'd'
06:06:40 <Saizan> Arnar: so you can either make Coord a data family, or add a phantom parameter of type 'd' to coord
06:07:08 <Saizan> Arnar: phantom meaning that you're not interested in the actual value, but you just use it to propagate type information
06:07:16 <Peaker> "Warning: -XImpredicativeTypes is deprecated: impredicative polymorphism will be simplified or removed in GHC 6.14" -- if it is removed, isn't some important power lost?
06:08:20 <student2> does anyone know how to recognize the type of map . foldr, without the use of ghci of other interpreter?
06:09:32 <pozic> student2: if your book does not explain that, get another book.
06:10:17 <student2> i will think about it, but would you explain it now for me :D
06:10:27 <sepp2k> Well if you know the types of map, . and foldr (which you can lookup in the documentation), you can just do the math in your head.
06:10:49 <student2> I did translate it to (\x -> (\y -> map (foldr x) y))
06:11:03 <Peaker> student2: don't do that -- just follow the type of (.), not its definition
06:11:06 <pozic> Basically, there is an application of (.) to map and foldr.
06:11:20 <pozic> :t (.)
06:11:21 <Peaker> @type let (.) = (Prelude..) in (.)
06:11:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:11:22 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:11:29 <pozic> :t map
06:11:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:12:11 <Peaker> student2: map is the first arg to (.) and foldr is the second.  So "map" takes the place of (b -> c) in the type of (.) and "foldr" takes that of (a -> b)
06:12:42 <Peaker> student2: now, its important to understand that (a -> b -> c) is really (a -> (b -> c)) when you try to unify that kind of type against (d -> e)  because d takes the place of a, and e takes the place of (b -> c)
06:12:53 <student2> I know it's from the argument of the second function (foldr) to the result of the first (map), but those functions are polymorph and that's still to difficult for a beginner like me
06:13:24 <student2> like you are saying Peaker
06:13:54 <pozic> student2: polymorphic just means that instead of a concrete type it is a type-variable.
06:13:59 <Peaker> student2: if you look at the type of map as (bb -> cc) (renaming the type variables in (.) so they don't collide), you get   bb = (a -> b)  and cc = ([a] -> [b])
06:14:05 <pozic> student2: (in this context)
06:14:25 <Peaker> student2: (.) :: (bb -> cc) -> (aa -> bb) -> aa -> cc
06:14:38 <Peaker> student2: map :: (a -> b) -> ([a] -> [b])
06:15:00 <pozic> Peaker: you are probably doing his homework now.
06:15:01 <Peaker> student2: map is given as the (bb -> cc) argument.  so bb = (a -> b)   and cc = ([a] -> [b])
06:15:07 <Peaker> pozic: just starting him out
06:15:33 <Peaker> student2: followed that?
06:16:00 <student2> pozic i'm learning for an exam
06:16:08 <student2> Peaker yes tnq
06:16:39 <student2> i was writing it on a paper
06:16:46 <Peaker> student2: try to continue from there, what's aa?  What's the type of foldr if you rename its type variables to not collide with these?
06:17:18 <student2> I will first write everything over en ill brb
06:17:22 <Peaker> maybe a good convention would be to call the type variables map_a foldr_a dot_a   and such, to avoid confusion, and when they are unified call them "a" or what not
06:19:01 <student2> i think aa = b -> a -> a
06:19:15 <Peaker> @type foldr
06:19:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:19:25 <student2> or a -> b -> b
06:19:43 <Peaker> we already used the names "a" and "b" for map. Let's rename everything to map_a foldr_a and dot_a
06:20:03 <Peaker> student2: Start by writing the equations, later we can unify further
06:20:11 <student2> foldr_b -> foldr_a -> foldr_a
06:20:23 <Peaker> (other way around if you want to keep with @type's convention :)
06:21:03 <student2> oke tnq
06:21:12 <Peaker> student2: So write all the equations for dot_a and dot_b
06:21:54 <Peaker> student2: You wrote above that dot_a = (foldr_a -> foldr_b -> foldr_b).  dot_c = [map_a] -> [map_b]   what else do you know?
06:22:00 <mreh> "Perhaps you haven't installed the profiling libraries for package `containers-0.2.0.1'?"
06:22:03 <mreh> huh?
06:22:16 <Peaker> mreh: when you compile profiling stuff you need to have all the dependencies in profiling mode too
06:22:27 <mreh> Peaker: ?!
06:22:32 <Peaker> mreh: :-(
06:22:39 <mreh> the compiler does the profiling when it compiles
06:22:52 <Peaker> mreh: well, you link against dependencies
06:23:03 <mreh> does it need linking in with profiling enabled code
06:23:04 <Peaker> mreh: and if you want to link a profiling executable, the dependencies have to be compiled in profiling mode too
06:23:08 <Peaker> mreh: Yeah :(
06:23:24 <Peaker> and cabal-install doesn't seem to have a nice way to automate the handling of this
06:23:25 <mreh> Peaker: I'd just like to see what the slowest functions are
06:23:39 <Peaker> mreh: profiling is dependency hell, it seems
06:23:41 <mreh> or where it spends most of its time, basic profiling
06:24:27 <mreh> if I can streamline the most use functions first, then that'll be most of the streamlining done, that's my reasoning
06:24:34 <mreh> is it because I'm using the -auto-all switch?
06:24:37 <Philonous1> cabal install -P
06:25:21 <vladi> ?
06:25:35 <vladi> works?
06:25:37 <mreh> that doesn't work
06:26:02 <vladi> hi to all
06:26:03 <Saizan> -p enables profiling for the packages it installs
06:26:08 <Saizan> vladi: hi
06:26:12 <mreh> little p
06:26:14 <mreh> yes
06:26:30 <Philonous1> oh, right
06:26:48 <vladi> i'm newbie in xmonad and, also i have one question: how i can set wallpaper?
06:26:59 <pozic> vladi: #xmonad
06:27:18 <vladi> hm.
06:27:29 <mreh> does this in anyway slow unprofiled code?
06:27:35 <pozic> In #C++: "Hi, I am setting a wallpaper in Windows 7, but it doesn't work!!".
06:28:14 <Saizan> mreh: for libraries, when you enable profiling you get two versions built and installed
06:28:43 <pozic> Cabal should ask at installation time, whether or not you use Haskell as a user or as a developer.
06:29:01 <pozic> Developers will need to profile something anyway, someday.
06:29:10 <Alpounet> Saizan, and when compiling something without profiling enabled, it uses the normal version of the library ?
06:29:33 <mreh> Saizan: does it look for the profiling enabled module when compiling a profiling enables library that has a dependency?
06:29:40 <Saizan> currently uou can set "library-profiling: True" in your ~/.cabal/config
06:29:57 <pozic> mreh: yes
06:30:07 <jmcarthur> too bad that doesn't work after you have already installed libraries without profiling
06:30:08 <Saizan> mreh: when it compiles a lib for profiling it wants to link to the profiling version of the deps
06:30:14 <Saizan> Alpounet: yes
06:30:20 <Alpounet> ok nice
06:30:21 <mreh> i'm getting a dependency error, saying it can't find base, I must need to compile base with profiling then
06:30:32 <Saizan> mreh: how did you get your ghc?
06:30:41 <jmcarthur> Alpounet: the not nice part is that it builds every library twice, once with profiling, once without
06:30:52 <mreh> Saizan: I bootstrapped
06:31:17 <mreh> what?
06:31:23 <mreh> I mean I used apt-get
06:31:32 <Saizan> ah, that makes more sense
06:31:43 <mreh> I was thinking of cabal
06:32:09 <Saizan> mreh: then i believe there are libghc6-$pkg-prof packages corresponding to the libs in apt-get
06:32:40 <Saizan> IOW for each libghc6-$pkg-dev there's a libghc6-$pkg-prof
06:32:53 <mreh> excelent
06:33:42 <Alpounet> jmcarthur, yeah but, well, today, hard disk space isn't that much on an issue, or at least not like 10 ten years ago
06:33:45 <osaunders> Does Haskell have something like pack() in PHP/Ruby/Perl/etc.?
06:33:48 <Alpounet> s/on/of/
06:34:17 <jmcarthur> Alpounet: yeah but it also sucks waiting for it to install
06:34:29 <jmcarthur> osaunders: what does it do?
06:34:31 <Peaker> osaunders: you mean struct.pack?
06:34:32 <Alpounet> jmcarthur, agreed
06:35:03 <mreh> Saizan: can't find the damn base package
06:35:36 <osaunders> jmcarthur: Creates binary strings from numbers and stuff like that.
06:35:54 <Saizan> mreh: i don't use debian anymore so i don't know the exact situation
06:36:01 <osaunders> http://php.net/pack
06:36:12 <mreh> it's worse... I'm using Ubuntu
06:36:41 <Saizan> mreh: if you really can't find it, i think the best option is to download the generic binary tarball of ghc from the official site
06:37:03 <mreh> i'll ask in ubunut, see what they know
06:37:17 <sjanssen> mreh: wait, you have GHC installed, but not base?
06:37:35 <Saizan> mreh seems to be missing the profiling version of base
06:37:57 <jmcarthur> sjanssen: profiling libs
06:38:20 <Saizan> which btw, would be in a file like libHSbase-4.1.0.0_p.a
06:38:30 <Saizan> where the version varies
06:38:35 <sjanssen> mreh: what happens when you attempt 'apt-get install libghc6-base-prof'?
06:38:54 <mreh> sjanssen: i haven't tried
06:39:22 <sjanssen> mreh: well, that's the command you should run to get the base profiling package
06:39:45 <mreh> E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)
06:39:46 <mreh> E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?
06:39:52 <mreh> lol, only kidding
06:39:55 <mreh> it works!
06:40:12 <mreh> it didn't exist in the database search
06:40:50 <sjanssen> mreh: oh, looks like it's an alias for 'ghc6-prof' or something
06:41:29 <mreh> sjanssen: I used those search terms exactly
06:42:00 <mreh> I must be blind
06:42:24 <mreh> this is the Royal Bank of Scotland?
06:44:19 <ido> @type (<+>)
06:44:21 <lambdabot>     Ambiguous occurrence `<+>'
06:44:21 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
06:44:21 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
06:44:27 <ido> @type (+>)
06:44:28 <lambdabot> Not in scope: `+>'
06:44:32 <ido> @type (+)
06:44:33 <lambdabot> forall a. (Num a) => a -> a -> a
06:44:40 <ido> @type (int)
06:44:41 <lambdabot> Int -> Doc
06:44:46 <osaunders> :t (+)
06:44:47 <lambdabot> forall a. (Num a) => a -> a -> a
06:45:00 <ido> @type (=)
06:45:01 <lambdabot> parse error on input `='
06:45:04 <ido> @type (:=)
06:45:05 <lambdabot> forall a b. a -> b -> Assoc a b
06:45:07 <ido> @type (==)
06:45:08 <lambdabot> forall a. (Eq a) => a -> a -> Bool
06:45:10 <ido> @type (===)
06:45:11 <lambdabot> Not in scope: `==='
06:45:20 <ido> slow morning.
06:45:29 <osaunders> ido: You can /msg lambdabot you know.
06:47:18 <ivanm> ido == interactively do things? :p
06:47:51 <osaunders> lol
06:47:55 <osaunders> That would be great.
06:48:35 <ido> 'fraid not.  just my name. :)
06:48:39 <ido> @type (ido)
06:48:40 <lambdabot> Not in scope: `ido'
06:48:43 <ido> :(
06:52:24 <ido> someone should make an urbandictionary bot.
06:52:33 <ido> ...in haskell
06:53:57 <Saizan> osaunders: re pack, maybe Data.Binary.Put
06:54:22 <Arnar> Saizan: thanks a lot for the comments earlier.
06:54:31 <ivanm> ido: awww.... because I quite like emacs' ido functionality :s
06:54:33 <mm_freak> @hoogle ThreadId -> Bool
06:54:33 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
06:54:33 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
06:54:33 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
06:54:42 <mm_freak> @hoogle ThreadId -> a
06:54:42 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:54:43 <lambdabot> Prelude id :: a -> a
06:54:43 <lambdabot> Data.Function id :: a -> a
06:54:51 <Saizan> Arnar: np
06:55:39 * hackagebot upload: SDL-gfx 0.5.3 - Binding to libSDL_gfx (DavidHimmelstrup)
06:55:46 <Veinor> morning #haskell
06:56:15 <osaunders> Saizan: Hm, yeah, not official though is it?
06:56:39 <osaunders> It says "stable", that's gotta be good.
06:56:52 <osaunders> Veinor: Hi.
06:57:28 <Saizan> osaunders: i think binary is in the Haskell Platform
06:57:58 <osaunders> Saizan: My file:///opt/local/share/ghc-6.10.4/doc/ghc/libraries/index.html includes no Data.Binary
06:59:10 <Veinor> ahahaha
06:59:15 <Saizan> what's shipped in ghc is no more representative of what's considered standard libs
06:59:18 <Veinor> I'm taking a basic CS course, because I have to.
06:59:27 <Veinor> and the teacher just basically introduced the IO monad in Python
06:59:28 <Saizan> however i was wrong about binary being in the HP
06:59:33 <endojelly> Veinor, how so?
07:00:11 <Veinor> talking about a procedure that takes something as input, as well as an environment... and provides output, and possibly changes the environment
07:00:49 <endojelly> Veinor, ah... that's a pretty common notion in operational semantics *without* monads!
07:00:57 <Veinor> well, yea
07:00:58 <Veinor> h
07:01:06 <Veinor> I just thought it was funny how now I can't stop seeing monads everywhere :P
07:01:12 <endojelly> 8)
07:01:28 <mreh> this cost centre chart doesn't display anything about functions that I wrote
07:01:36 <Chirono> Hello
07:01:49 <Chirono> Does anyone know of a good guide to how the ghc code generator works inside?
07:02:26 <mreh> ghc code generator is a tautology Chirono :)
07:02:39 <Chirono> I've read the "fast curry" paper, but there seems to be quite a gap between that and the anctual code
07:03:09 <Chirono> Sorr, I mean the stg-cmm generator. The stuff in compiler/codeGen
07:04:07 <jmcarthur> Veinor: that's not necessarily an IO monad
07:04:26 <jmcarthur> (ignoring that Python can perform side effects wherever it wants)
07:05:35 <jmcarthur> wow, it's amazing to me how much it hurt to mention uncontrolled side effects
07:05:40 <mreh> "ghc --make -p -auto-all" doesn't seem to generate the cost functions on all top level functions
07:06:01 <jmcarthur> did you clean your build products first?
07:06:01 <mreh> what's that comic about the war over side-effects
07:06:07 <gmux2> I think you want -caf-all and -auto-all
07:06:10 <mreh> jmcarthur: of course not!
07:07:33 <jmcarthur> there's also a ghc flag to force rebuilding, but i always forget the new one (old one was deprecated)
07:08:47 <gmux2> -fforce-recomp IIRC
07:15:49 <Veinor> jmcarthur: :p
07:16:41 <Arnar> what is the proper thing to do when ghc keeps complaining about finding stuff in mtl and some other package?
07:16:49 <Arnar> hide mtl.. or hide the other packate (e.g. transformers)
07:18:30 <Zao> Pick the one that suits you best?
07:19:05 <Arnar> Zao: I would.. if I knew what they are and what the difference is :)
07:20:15 <Zao> transformers seems a bit more fancy.
07:20:15 <Arnar> transformers seems more recent..
07:20:27 <Arnar> ok.. debate settled :)
07:20:28 <Arnar> thanks
07:21:02 <Zao> monads-fd: This package is almost a compatible replacement for the mtl package. Client packages will need to depend on this one and on transformers.
07:22:46 <theclaw> I'm just curious: would it be possible to "emulate" a while-loop with a state monad alone?
07:23:27 <jlouis> theclaw: you don't even need a state monad for that, just a tail call
07:23:59 <jlouis> theclaw: alternatively, yes, MonadState and the 'forever' function is a way
07:24:21 <jmcarthur> well, besides that forever won't terminate
07:24:47 <jlouis> oh, heheh, my bad
07:24:54 <jmcarthur> (unless the state is lazy and you ignore the result?)
07:25:00 <theclaw> jlouis: yes, I'm using a tail call right now and it works, but I thought the state monad might be cleaner
07:25:24 <jmcarthur> theclaw: what's unclean about recursion?
07:25:41 <jmcarthur> theclaw: (i do typically prefer combinators to recursion when possible)
07:25:49 <jmcarthur> but i don't see how a monad makes it cleaner
07:26:12 <theclaw> jmcarthur: I didn't mean to say it's unclean. It's just a piece of imperative code which I'd like to port with as little as hassle as possible
07:26:43 <theclaw> jmcarthur: it works fine with tail recursion, but I'm just curious how I would achieve this with state monads
07:26:49 <jmcarthur> hpaste?
07:26:55 <sshc> Why is the ST Monad named as such?
07:26:58 <theclaw> jmcarthur: just a second
07:27:49 <zygoloid> sshc: "state transformer"
07:28:12 <theclaw> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16928#a16928 - it basically is a simple DFA
07:28:41 <jmcarthur> zygoloid: ST = state transformer? that makes no sense to me...
07:29:00 <jmcarthur> theclaw: i meant your haskell code
07:29:09 <dolio> ST = state.
07:29:15 <theclaw> jmcarthur: oh, okay
07:29:22 <jmcarthur> i don't want to see this imperative stuff :P
07:29:25 <dolio> And it's two capital letters like IO.
07:29:47 <theclaw> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16929#a16929
07:30:17 <jmcarthur> woah, that's a lot of ifs
07:30:34 <jmcarthur> and list indexing
07:30:51 <theclaw> jmcarthur: it's basically the same as the java code ;)
07:31:04 <jmcarthur> well, except the java code uses arrays
07:31:11 <jmcarthur> this will be much slower
07:31:33 <theclaw> what would be the proper way to do it in haskell?
07:31:38 <nainaide> Need I have to remove package manually while uninstall cabal packages?
07:32:12 <endojelly> theclaw, haven't looked at the code, but there are arrays in haskell
07:32:18 <jmcarthur> theclaw: anyway, as for your question directly, i see that you are recursing over a list. this is probably a prime candidate for nicer combinators
07:32:34 <theclaw> endojelly: okay, I might look into that
07:32:36 <mreh> does the ol' idiom "someFunction . zip xs $ (cycle . drop 1 $ xs)" have some inefficiency in it?
07:32:53 <jmcarthur> theclaw: i don't *really* know what this does, so i can't say what would be the best way to do it
07:33:21 <theclaw> jmcarthur: what combinators are you talking about? (I only know the term "combinator" from parsers)
07:33:34 <mreh> theclaw: function combinators
07:33:40 <zygoloid> jmcarthur, dolio: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Monad-ST.html
07:33:49 <jmcarthur> theclaw: function combinators, and i'm also conflating folds and such with that as well
07:33:51 <zygoloid> "data ST s a: The strict state-transformer monad."
07:34:08 <dolio> Oh, okay.
07:34:23 <dolio> It's a state-transformer monad not a state monad transformer.
07:34:56 <theclaw> jmcarthur: you mean higher order functions generally?
07:35:20 <endojelly> in Agda you can have folds (and all other combinators) in types.
07:35:22 <endojelly> it's nice.
07:35:44 <jmcarthur> theclaw: A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
07:35:51 <jmcarthur> quoted from wikipedia
07:35:57 <endojelly> in Agda types are values...
07:36:19 <jmcarthur> theclaw: i should have said combinators *and* folds, zips, etc.
07:37:02 <jmcarthur> endojelly: indeed...
07:37:50 <Saizan> i thought ST meant State Threads
07:38:00 <endojelly> Γ ⊢ cons ι C ∷ foldr _➛_ (ind ι) l
07:38:05 <endojelly> part of a type...
07:38:27 <jmcarthur> what's your point?
07:38:47 <endojelly> jmcarthur, nothing, I just think it's interesting
07:38:52 <jmcarthur> ah
07:39:11 <Saizan> you can't pattern match on types though :)
07:39:29 <theclaw> jmcarthur: still can't think of a way to use them in this case. do you probably have some examples?
07:39:35 <jmcarthur> of course we don't have the same thing in haskell, but we can make type-level folds (using extensions) :)
07:39:51 <endojelly> jmcarthur, we can? what do they look like?
07:40:14 <jmcarthur> endojelly: h/o. lemme try and slap one together
07:40:18 <endojelly> cool.
07:40:42 <Saizan> multiparameter type classes and functional dependencies are quite effective
07:41:00 <jmcarthur> i like type families for type level programming now. very convenient
07:41:22 <Saizan> too limited for me
07:41:47 * jmcarthur tries to think of a useful fold for the type level
07:47:17 <nainaide> Who use Gentoo Linux, do you use haskell overlay or cabal install ?
07:49:34 <jmv> Hi which IDE ou editor would you recommend for Haskell ? I'm on Ubuntu , and I use for other things eclipse , and gvim .
07:49:49 <sjanssen> jmv: I use vim and it works okay
07:50:05 <sjanssen> there's also a Haskell plugin for Eclipse
07:50:25 <Raevel> i use emacs + scion
07:50:29 <cheater> vim
07:50:30 <jlouis> I am on gvim as well here. Emacs also has a pretty nice Haskell-mode
07:50:38 <Raevel> you can use scion with vim as well
07:50:47 <endojelly> jmcarthur, I use haskell and it works pretty good. however, I don't think I'd recommend it to someone who's not been using emacs before
07:50:55 <jmv> i saw for eclipse something called fp* , but it's not easy to install .
07:51:06 <Polarina> Are there any cool tutorials to FFI? :)
07:51:09 <endojelly> I never tried out scion
07:51:14 <jmcarthur> endojelly: why?
07:51:28 <jmcarthur> or are you talking about agda?
07:51:34 <endojelly> jmcarthur, I'm asking myself that very question right now 8)
07:51:46 <endojelly> jmcarthur, ah, you mean why I wouldn't recommend haskell-mode?
07:51:54 <endojelly> jmcarthur, well I'm not sure if he wants to learn emacs
07:52:20 <jmv> is scion a library, or is there a tool readily usable ?
07:52:33 <jmcarthur> endojelly: oh you meant to talk to jmv, not me ;)
07:52:51 <endojelly> jmcarthur, ah, sorry, tab completion %)
08:02:29 <jmv> I found this called "Vim as Haskell IDE" : http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/vim.html
08:04:24 <jmcarthur> endojelly: eh, a quickie: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16931#a16931
08:05:10 <jmcarthur> endojelly: i wanted to make a Sum type-level function, but i hit the constraint that type synonyms must be applied to all their arguments from their declarations :\
08:05:21 <jmcarthur> surely there is a way around that
08:05:26 <sshc> how is the ST monad mutable in an immutable language?
08:05:31 <jmcarthur> anyway, you get the idea at least
08:05:48 <endojelly> jmcarthur, that is awesome. I didn't know about type families
08:05:50 <jmcarthur> sshc: it doesn't allow that mutation to manifest outside of runST
08:05:55 <endojelly> jmcarthur, do they have to be decidable?
08:06:04 <sshc> is the ST monad a bunch of magic, or is it possible to rewrite it outside of the compiler?
08:06:39 <jmcarthur> endojelly: i'm not sure, actually
08:06:52 <sshc> can we think of it as emulating mutability, when it's really immutable (kind of like threading State)?
08:07:17 <jmcarthur> sshc: you could probably make something like it using IO
08:07:28 <jmcarthur> sshc: it's real mutation
08:07:39 <jmcarthur> sshc: it just doesn't let it bleed into pure code
08:07:44 <sshc> jmcarthur: so I couldn't write it purely?
08:07:49 <endojelly> jmcarthur, well there's one way to find out 8)
08:08:05 <sshc> Data.STRef: "Mutable references in the (strict) ST monad."
08:08:19 <endojelly> jmcarthur, type instance Stupid x = Stupid x -- let's see what happens!
08:08:43 <sshc> why is "strict" in parethesis?
08:08:45 <jmcarthur> sshc: you could possibly emulate references in pure code and use some type hackery to do it, but it would be slow and ugly
08:08:50 <zygoloid> sshc: because there's a lazy one too
08:08:56 <jmcarthur> endojelly: i think that's not allowed
08:09:03 <Philonous> Polarina: I'd recommend using a tool like c2hs. Using the FFI is not particularly hard but tedious because of all the marshaling. A bindings generator can alleviate the pain.
08:09:10 <jmcarthur> endojelly: actually, i think i do recall seeing stuff guaranteeing termination
08:09:19 <MissPiggy> any ops around
08:09:21 <Polarina> Philonous, do you know of any cool tutorials for c2hs? :)
08:09:23 <MissPiggy> ?
08:09:25 <sshc> is it suggesting that I use the strict one, or telling me that it only works with the strict one?
08:09:33 <sshc> the meaning of it is ambiguou
08:09:34 <sshc> s
08:09:39 <Arnar> can I specify class constraints on an associated type family?
08:09:54 <jmcarthur> sshc: i don't know. maybe it's just pointing out that it's strict, and that's all?
08:10:11 <zygoloid> sshc: it's telling you that this STRef only works with the strict ST monad
08:10:15 <Philonous> Polarina: Well, there is http://www.cse.unsw.edu.au/~chak/haskell/c2hs/ and the 3 tutorials linked in the "documentation" section.
08:10:19 <endojelly> jmcarthur, so kind of like Agda, with a termination checker, then
08:10:27 <Polarina> Philonous, thanks.
08:10:27 <zygoloid> sshc: there's another monad and another reference type in Control.Monad.ST.Lazy and Data.STRef.Lazy
08:10:39 <jmcarthur> endojelly: like most of haskell's type system
08:10:52 <jmcarthur> i think agda is a little more liberal though
08:10:55 <endojelly> jmcarthur, anyway that really is interesting
08:10:57 <sshc> so ST can be rewritable purely, even though it would be slow?
08:10:59 <Philonous> Polarina: It was still trial and error for me. You learn a lot by reading code witten by others
08:11:00 <Polarina> Câž”Haskell is a weird name.
08:11:22 <Philonous> It's supposed to mean C->Haskell
08:11:25 <zygoloid> sshc: you would think so, wouldn't you :)
08:11:26 <jmcarthur> endojelly: there are limitations though
08:11:28 <MissPiggy> sshc, purely meaning.. using an advanced form of state monad?
08:11:36 <fasta> Is there a truly high-level language somewhere? E.g. where you can say things like: I want to have a datastructure exactly like Foo, but not containing the following fields and that it automatically creates a module which doesn't contain any method which depended on functionality now removed or where you can express "at some point later in the future we want to be able to access this value in O(1) time" and so on.
08:11:37 <Polarina> zygoloid, why doesn't it have that name then?
08:11:54 <zygoloid> Polarina: why doesn't what have which name?
08:12:07 <Polarina> zygoloid, Why isn't the name "C->Haskell" instead of "Câž”Haskell"?
08:12:09 <sshc> purely meaning outside of IO and low level magic
08:12:19 <Philonous> Polarina: Encoding error, I guess
08:12:21 <jmcarthur> endojelly: like i said, i really wanted to make a Sum function to add the contents of the array. i had implemented peano numerals and a :+ function, but when it came time to write Foldr (:+) i realized it wouldn't let me do that because i have to apply all the arguments to (:+) in place since it's really a type synonym
08:12:23 <Polarina> o.O
08:12:25 <fasta> Polarina, because the author cannot create a website.
08:12:30 <Polarina> I see.
08:12:37 <sshc> what would the thread type by in an ST monad?
08:12:37 <zygoloid> Polarina: i think your comments were meant to be addressed to someone else
08:12:41 <fasta> Polarina, if you switch encoding manually, it does work.
08:12:43 <sshc> what would the thread type be in an ST monad?
08:12:53 <MissPiggy> what would the thread type be in an ST monad?
08:13:04 <sshc> MissPiggy: why did you repeat my question?
08:13:06 <endojelly> jmcarthur, so no partial application on that sort?
08:13:06 <Polarina> Cool.
08:13:11 <MissPiggy> because I don't understand it
08:13:23 <jmcarthur> endojelly: not on type families. you can do that for data families, though, but that's different
08:13:25 <fasta> MissPiggy, I understand the question.
08:13:38 <endojelly> jmcarthur, there are data families as well? nice
08:13:41 <zygoloid> sshc: are you looking for an analogue of forkIO for ST?
08:13:45 <jmcarthur> endojelly: also, if you can express the definition for (:+) with no parameters on the LHS, you can do it
08:14:08 <sshc> data ST s a: A computation of type ST s a transforms an internal state indexed by s, and returns a value of type a                data STRef s a: a value of type STRef s a is a mutable variable in state thread s, containing a value of type a
08:14:12 <sshc> MissPiggy: ^
08:14:16 <jmcarthur> endojelly: also associated type families and associated data families (members of type classes)
08:14:23 <fasta> sshc, the "thread type" doesn't really matter, the "s" is there only to satisfy that it works for all s.
08:14:30 <Polarina> c2hs sounds overly complex.
08:14:32 <MissPiggy> @docs ST
08:14:32 <lambdabot> ST not available
08:14:37 <jmcarthur> endojelly: they are (strictly?) less powerful than plain type families and data families, though
08:14:47 <fasta> sshc, the paper explains it fairly well.
08:14:52 <sshc> fasta: which paper?
08:14:53 <MissPiggy>  (forall s. ST s a) -> a
08:14:55 <MissPiggy> runST ^
08:14:56 <jmcarthur> since you can implement the latter two with the former two anyway
08:15:06 <fasta> sshc, the one which is pointed to in the documentation.
08:15:07 <sshc> zygoloid: I'm trying to understand how to use the ST monad
08:15:17 <endojelly> jmcarthur, I'd like to look into that. is it in the latest GHC release?
08:15:19 <MissPiggy> sshc, you don't want to re-implement it in a pure way then?
08:15:24 <fasta> sshc, using is really simple: runST (<put your code here>)
08:15:37 <jmcarthur> endojelly: it's even in 6.10
08:15:38 <sshc> MissPiggy: I only want to know if it's possible to rewrite ST purely
08:15:50 <endojelly> jmcarthur, nice
08:15:59 <sshc> fasta: if I had runST x, what would  the type of x be?
08:16:01 <jmcarthur> endojelly: not sure about 6.8... i think not, but don't remember
08:16:01 <MissPiggy> well let me think about it for a bit
08:16:02 <fasta> sshc, yes, you can.
08:16:07 <MissPiggy> runST :: (forall s. ST s a) -> a
08:16:18 <fasta> sshc, this is a discussion we have had before in this channel.
08:16:31 <fasta> sshc, if you count DiffArrays as being pure, then you can.
08:17:05 <fasta> sshc, you basically just implement a memory allocator on top of the DiffArray and you are done.
08:17:23 <sshc> fasta: and inside of x, what would the type of foo be when it's bound by "foo <- newSTRef 3" be?
08:17:41 <fasta> sshc, the type of foo is Num a=> a
08:18:04 <fasta> sshc, the type of the computation is (Num a)=>ST s (STRef s a)
08:18:06 <zygoloid> sshc: in principle you could write ST purely. in practice it's rather difficult (and maybe impossible), because you need to have some way of holding onto values of a potentially unbounded set of different types
08:18:27 <zygoloid> (in principle, as in, the interface is entirely pure)
08:19:08 <MissPiggy> "in practice it's rather difficult (and maybe impossible)" :D
08:19:17 <sshc> fasta: what is the type of newSTRef?
08:19:23 <MissPiggy> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-STRef.html
08:19:26 <fasta> :t newSTRef
08:19:27 <lambdabot> forall a s. a -> ST s (STRef s a)
08:19:30 <sshc> fasta: I'm trying to understand what s would be for values of Data.STRef
08:20:19 <sshc> @hoogle DiffArrays
08:20:19 <lambdabot> No results found
08:20:33 <sshc> fasta: I can't find any paper linked to in the documentation
08:20:47 <jmcarthur> sshc: s must be fully polymorphic. it's part of the type system trickery that keeps ST out of your pure code
08:20:50 <sshc> nor can I find DiffArrays
08:21:05 <sshc> jmcarthur: I see.
08:21:09 <MissPiggy> "type system trickery" :(
08:21:16 <Polarina> I imported Foreign.C.Types and there's no type named CChar. Why?
08:21:20 <jmcarthur> MissPiggy: it's not that bad
08:21:33 <MissPiggy> it's gorgeous
08:21:36 <sshc> MissPiggy: the State monad can be considered type system trickery too
08:21:42 <sshc> by me
08:21:57 <MissPiggy> it's the most elegant and inspired use of parametricity that anyone has come up with
08:22:17 <fasta> sshc, This library provides support for strict state threads, as described in the PLDI '94 paper by John Launchbury and Simon Peyton Jones Lazy Functional State Threads.
08:22:30 <fasta> @google  Lazy Functional State Threads
08:22:32 <lambdabot> http://citeseer.ist.psu.edu/63882.html
08:22:36 <fasta> Wow, that was hard!
08:22:42 <fasta>  /sarcasm
08:22:53 <sshc> Yes it was, since I had no idea what the name of the paper was until you mentioned it ;)
08:23:03 <Polarina> Where is CChar defined?
08:23:07 <fasta> sshc, it is the documentation of Control.Monad.ST
08:23:08 <sshc> fasta: what is DiffArrays?
08:23:14 <fasta> sshc, in the*
08:23:22 <fasta> @google DiffArrays
08:23:22 <lambdabot> No Result Found.
08:23:24 <fasta> @google DiffArray
08:23:25 <lambdabot> No Result Found.
08:23:39 <sshc> oh, um, I have no idea how I missed that
08:23:57 <fasta> @google haskell DiffArray
08:23:58 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-Diff.html
08:23:58 <lambdabot> Title: Data.Array.Diff
08:24:25 <fasta> sshc, those are DiffArrays.
08:25:31 <fasta> sshc, using ST is much easier than understand why it works.
08:25:40 <zygoloid> fasta: DiffArrays are nice, but they don't actually let you implement ST. If you restrict to "newSTRef :: Dynamic a => a -> ST s (STRef s a)" then you can do it (without DiffArrays)
08:25:45 <jmcarthur> it works the same way IO does
08:26:03 <fasta> zygoloid, yes, that was the conclusion last time and I agree with it.
08:26:09 <sshc> jmcarthur: so, it involves magic?
08:26:15 <sshc> DiffArrays uses the IO monad, so I don't consider it pure.
08:26:18 <fasta> zygoloid, it's just that I don't consider that restriction to be fundamental.
08:26:38 <zygoloid> if the fundamental typing problem could be solved, DiffArrays might give a nice implementation for ST though
08:27:08 <jmcarthur> sshc: *real* mutation can't be done purely
08:27:15 <jmcarthur> and ST is *real* mutation
08:27:26 <zygoloid> as things stand, one could probably implement ST using a single call to unsafeCoerce
08:27:36 <jmcarthur> in pure code, mutation can only be simulated
08:28:04 <MissPiggy> zygoloid boo :P
08:28:19 <Polarina> Where is Word32?
08:28:24 <jmcarthur> Data.Word
08:28:26 <Polarina> Ok.
08:28:39 <Polarina> Thanks.
08:29:18 <fasta> Polarina, there is Hayoo for questions like that.
08:29:23 <fasta> @where Hayoo
08:29:23 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:29:25 <Polarina> Hayoo?
08:29:50 <fasta> IMHO, a good development environment has such a facility locally available.
08:30:09 <fasta> Smalltalk had it 30 years ago.
08:30:27 <MissPiggy> @src State
08:30:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:30:33 <MissPiggy> @unmtl State s a
08:30:33 <lambdabot> s -> (a, s)
08:30:38 <Polarina> How do I convert [Char] to Ptr CChar?
08:30:48 <zygoloid> @index Word32
08:30:48 <lambdabot> Data.Word, Foreign, Graphics.SOE
08:30:54 <fasta> Polarina, reading the specifications might help?
08:31:01 <Polarina> fasta, what specification?
08:31:03 <Saizan> @hoogle [a] -> Ptr a
08:31:03 <lambdabot> Prelude head :: [a] -> a
08:31:04 <lambdabot> Prelude last :: [a] -> a
08:31:04 <lambdabot> Data.List head :: [a] -> a
08:31:09 <fasta> Polarina, uh...
08:31:25 <jmcarthur> the FFI specification?
08:31:32 <fasta> Polarina, how do you get a Ptr without knowing there is a specification for the FFI.
08:31:35 <fasta> ?
08:31:52 <Polarina> fasta, oh, that specification. It doesn't mention how to marshall like that.
08:31:59 <undone> how do I know by looking at a lambda term if it describes an iterative program or a recursive one?
08:32:02 <Saizan> Polarina: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Foreign-Marshal-Array.html <- see newArray/withArray and variations
08:32:07 <Polarina> I am reading section 5, Marshalling. I see nothing.
08:32:08 <fasta> Polarina, I think it does ;)
08:32:09 * Zao huggles Storable a
08:32:54 <Polarina> fasta, do you know where?
08:33:03 <Polarina> fasta, which subsection?
08:33:13 <fasta> Polarina, you might want to listen to what the others have said.
08:33:25 <Zao> Storable a made me a sandwich and a pot of coffee this morning.
08:33:50 <Polarina> Saizan, how do I use those?
08:34:59 <b0fh_ua> Hi there! Can somebody please tell me - does curl 1.3.5 even builds using cabal?
08:35:07 <b0fh_ua> I was not able to get it installed :(
08:35:27 <Saizan> Polarina: well, you pass the list to them and get the pointer back by looking at the types, i've never used them personally, newArray requires that you free the pointers yourself later i think
08:35:32 <b0fh_ua> and looks like there's nothing else to use for accessing HTTPS resources in haskell
08:35:39 <b0fh_ua> ot I am wrong?
08:35:51 <Saizan> Polarina: withArray instead takes a function as parameter and will free the pointer when that function returns
08:35:52 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Foreign-Marshal-Array.html#v%3AwithArray
08:35:59 <Polarina> Saizan, can't it be done directly, like passing a pointer to the first element of the [Char]?
08:36:09 <Zao> I would say that the usage of that function is rather apparent from the signature.
08:36:29 <Zao> Feed it a list of a that are Storable and a function from Ptr a -> IO b, and get an IO b out.
08:36:38 <Saizan> Polarina: a [Char] in memory is nothing like an array of chars in C
08:36:41 <jmcarthur> b0fh_ua: just tried it. builds fine for me
08:36:45 <Polarina> Zao, how?
08:36:54 <jmcarthur> b0fh_ua: maybe you need a curl C library for it to bind to?
08:37:28 <Zao> withArray [42, 3, 5 :: Word32] (\xs -> call_awesome_c_function xs)
08:37:33 <Saizan> b0fh_ua: can you paste the errors somewhere?
08:37:48 <Polarina> Zao, thanks.
08:38:00 <b0fh_ua> jmcarthur: I definitely have curl installed, looks like something is wrong with resolving paths for headers
08:38:11 <b0fh_ua> Saizan: 1 sec
08:38:57 <b0fh_ua> Saizan: http://pastebin.com/d726321c7
08:39:06 <Polarina> Zao, withArray returns IO b.
08:39:07 <Polarina> :S
08:39:15 <Saizan> there's --extra-include-dirs and --extra-lib-dirs to add paths for headers and libs
08:39:19 <Zao> Polarina: Yes. It returns whatever the function you feed it returns.
08:39:29 <Polarina> But I need a Ptr CChar.
08:40:07 <zygoloid> @hoogle String -> Ptr CChar
08:40:07 <lambdabot> Foreign.C.String newCAString :: String -> IO CString
08:40:07 <lambdabot> Foreign.C.String newCString :: String -> IO CString
08:40:07 <lambdabot> Prelude read :: Read a => String -> a
08:40:08 <Polarina> :t withArray
08:40:09 <lambdabot> Not in scope: `withArray'
08:40:11 <Zao> Polarina: withArray is a function that allocates enough memory, serializes the list elements into it, and calls a function with the Ptr a it just allocated.
08:40:23 <Zao> When it returns, it deallocates and returns the result of the action.
08:40:26 <zygoloid> CString = Ptr CChar, fyi
08:40:32 <Saizan> Polarina: do you know how IO works in haskell?
08:40:37 <Polarina> Saizan, yes.
08:40:39 <pikhq> @hoogle withCString
08:40:39 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
08:40:39 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
08:40:42 <Zao> There's also withCString and other awesome functions, I believe.
08:40:45 <zygoloid> @hoogle String -> (Ptr CChar -> IO a) -> IO a
08:40:45 <lambdabot> Foreign.C.String withCAString :: String -> (CString -> IO a) -> IO a
08:40:45 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
08:40:57 <Polarina> zygoloid, thanks.
08:41:36 <b0fh_ua> Saizan: http://pastebin.com/d124cbf9d
08:41:51 <b0fh_ua> /usr/local/include/curl/curl.h - exists
08:42:10 <b0fh_ua> /usr/local/lib/libcurl.so - exists
08:43:39 <HaskellLove> what are the most exciting places to work in europe guys?
08:44:21 <tromp> there's a few google's here and there
08:45:04 <tromp> but they dont do haskell:(
08:45:08 <Saizan> b0fh_ua: i'd "cabal unpack curl" and then run "cabal install" from there, to look at the config.log
08:45:38 <Saizan> b0fh_ua: though i know nothing about configure scripts :\ and it might be that it doesn't respect the --extra-*-dirs flags
08:45:39 <fasta> tromp, I am fairly sure there are some people at Google who use Haskell under work-time.
08:46:05 <HaskellLove> tromp you need like 10 Phds to get there?
08:46:59 <Saizan> "exciting places to work" is very much off topic
08:47:49 <HaskellLove> ok then i go to haskell off topic
08:48:21 <zygoloid> presumably exciting places to do haskell work is on topic?
08:48:44 <tromp> i think the avg googler has less than 0.5 a PhD
08:50:17 <fasta> A PhD only has an advantage if it the exact precise area that they are working on.
08:50:41 <HaskellLove> come to haskell-blah for this topic
08:52:29 <shapr> hoi tromp
08:53:23 <tromp> hi, Shae!
08:54:05 <shapr> How's life?
08:54:21 <b0fh_ua> Saizan: okay
08:54:48 <tromp> life's good. wife still in canada though
08:55:09 <tromp> shld be quitting this summer:)
09:01:58 <b0fh_ua> Saizan: configure:2439: gcc -E  conftest.c
09:02:03 <b0fh_ua> conftest.c:9:23: error: curl/curl.h: No such file or directory
09:02:12 <b0fh_ua> looks like it can't find a path to headers
09:04:44 * MissPiggy can't implement ST
09:05:14 <MissPiggy> I thought the old technique with GADTs would work but apparently not
09:07:04 <MissPiggy> I tried making the s parameter a type level vector of types
09:07:47 <MissPiggy> but the references that index into s cause some conflict
09:07:54 <Saizan> MissPiggy: the problem is that you need a way to make references created in some context work in an extended one?
09:08:04 <luite> anyone here with an irex dr1000 ebook reader? (who wants to test my document viewer plugin for djvu files)
09:08:17 <MissPiggy> other way around, that references in the extended context don't typecheck in a shorter context
09:09:08 <Saizan> MissPiggy: what's an example expression where you need that?
09:12:13 <Alpounet> b0fh_ua, you must install the curl library
09:15:27 <b0fh_ua> Alpounet: it is installed
09:15:46 <theclaw> I'm trying to use the Error monad together with parsec, but http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16934#a16934 doesn't seem to be the right way to do it? There's no exception thrown, "ret" is just 'Left "Blah"'
09:15:49 <MissPiggy> it is possible to do it in haskell?
09:15:51 <theclaw> any ideas?
09:16:06 <kmc_> theclaw: that's what throwError does
09:16:21 <Alpounet> b0fh_ua, then probably not in the include path ?
09:16:34 <theclaw> kmc_: why doesn't catchError work?
09:17:14 <kmc_> is ParsecT an instance of MonadError?
09:17:18 <kmc_> it might be throwing there instead
09:17:24 <theclaw> kmc_: it is, yes
09:17:32 <kmc_> :t lift
09:17:33 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:18:01 <Saizan> throwError and catchError for ErrorT don't call the ones of the lower layer
09:18:46 <Saizan> oh, but ParsecT is the outermost one here
09:18:50 <theclaw> what's the lower layer?
09:18:58 <theclaw> (sorry, I'm a bit confused now)
09:19:15 <b0fh_ua> Apocalisp: what is the default include path and how to alter it?
09:19:27 <b0fh_ua> curl.h resides in /usr/local/include/curl
09:19:30 <Saizan> well, in t m a, i call t outer and m inner (or lower)
09:19:46 <b0fh_ua> I tried cabal install --extra-include-dirs=/usr/local/include --extra-lib-dirs=/usr/local/lib curl - but with the same results
09:20:02 <b0fh_ua> may be it doesn't recognize  --extra-include-dirs properly or so?
09:21:03 <Alpounet> b0fh_ua, hmm, then it's weird
09:21:15 <theclaw> Saizan: the throwError in this snipped is the throwError from ParsecT, right?
09:21:17 <Alpounet> you should try to download the source package
09:21:18 <theclaw> Saizan: *snippet
09:21:21 <Alpounet> and do a cabal configure
09:21:33 <Alpounet> playing with the extra include/lib flags
09:21:39 <theclaw> Saizan: how do I "fix" this? What's the correct way to throw and catch exceptions here?
09:21:43 <Saizan> theclaw: yes, but it "delegates" to the one of ErrorT immediately
09:22:35 <b0fh_ua> Alpounet: http://pastebin.com/d3103a8eb
09:22:36 <Saizan> theclaw: what you've written looks like the correct way to me, in theory
09:22:38 <jaspervdj> I'm searching for a simple example of a server appication with a state, google is dissapointing me so far
09:23:15 <Alpounet> b0fh_ua, how did you install curl (the C library, I mean) ?
09:23:15 <theclaw> Saizan: but what I want to do is to catch the exception
09:23:38 <theclaw> Saizan: just like in imperative languages
09:23:39 <b0fh_ua> Alpounet: from ports. I'm on FreeBSD 7.2
09:24:21 <Alpounet> hmm
09:24:52 <Saizan> theclaw: yeah, i'm not sure what's wrong here though, maybe switching the layers would help
09:25:44 <theclaw> Saizan: how do I switch the layers here? doesn't runParserT have to be the "inner run"?
09:25:51 <Alpounet> b0fh_ua, then the only thing I can think of for you to do is to report that on the mailing list
09:26:00 <Alpounet> 'cause it seems you're doing things right
09:26:07 <Alpounet> by the way it works for me... :/
09:26:19 <theclaw> Saizan: you mean runParserT (runErrorT f6) () "stdin" "ab" ?
09:26:34 <Saizan> theclaw: yeah
09:27:26 <theclaw> Saizan: I get this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16935#a16935
09:27:45 <Saizan> theclaw: you need to lift the operations
09:27:51 <theclaw> kmc_: you mean I have to "lift" by myself? That didn't work either
09:28:06 <dmead> hey channel
09:28:18 <kmc_> hi dmead
09:28:37 <Saizan> theclaw: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16934#a16936
09:29:39 <kmc_> this monad stack is dubious.  why don't you want to handle errors within Parsec?
09:30:12 <b0fh_ua> Alpounet: I wrote to maintainer - but no response yet. Are there any mailing list for the package available?
09:30:19 <Saizan> kmc_: does parsec let you extract the error message like catchError does?
09:30:40 <theclaw> Saizan: thanks!
09:30:43 <kmc_> doesn't it return Either ParseError a
09:31:07 <Alpounet> b0fh_ua, there are the Libraries mailing list and the cabal-devel mailing list.
09:31:17 <dmead> ?seen dons
09:31:17 <lambdabot> Unknown command, try @list
09:31:23 <dmead> @list
09:31:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:31:25 <Saizan> kmc_: i meant within the expression
09:31:26 <theclaw> kmc_: when I have "many someParser", and someParser returns an error, many doesnt
09:31:44 <Saizan> theclaw: you want many1, maybe?
09:31:48 <dmead> @seen dons
09:31:48 <lambdabot> Unknown command, try @list
09:31:51 <dmead> ?seen
09:31:51 <lambdabot> Unknown command, try @list
09:31:53 <dmead> what
09:31:58 <Saizan> theclaw: many just skips to the next
09:31:58 <dmead> > "poo"
09:31:58 <lambdabot>   "poo"
09:31:59 <theclaw> Saizan: it's the same I guess
09:32:05 <Saizan> dmead: there's no seen command.
09:32:07 <theclaw> Saizan: isn't it?
09:32:07 <kmc_> preflex, seen dons
09:32:08 <preflex>  dons was last seen on #ghc 11 hours, 20 minutes and 45 seconds ago, saying: i'd like to know why it works here. some env settting i guess.
09:32:16 <Saizan> dmead: not anymore :)
09:32:21 <dmead> http://code.haskell.org/lambdabot/COMMANDS
09:32:27 <dmead> the internet disagrees
09:32:31 <theclaw> Saizan: I thought basically many/many1 stops when it gets a "error", and returns an Ok
09:32:35 <dmead> :<
09:32:38 <Saizan> i'm the internet.
09:32:43 <dmead> orly
09:32:56 <Saizan> theclaw: true
09:33:02 <dmead> dons, you there?
09:33:17 <theclaw> Saizan: so I can't catch an error somewhere in my parser just with parsecs error?
09:33:22 <theclaw> Saizan: *errors
09:33:31 <Saizan> theclaw: so what do you actually want to parse? an infinite stream of someParser?
09:34:35 <theclaw> Saizan: no, but someParser should be able to throw an error
09:34:54 <kmc_> does "throw an error" mean something different from "fail to parse"?
09:35:07 <b0fh_ua> Alpounet: nice
09:35:20 * Saizan seconds kmc_ question
09:35:22 <b0fh_ua> CPPFLAGS="-I/usr/local/include" cabal install --extra-include-dirs=/usr/local/include --extra-lib-dirs=/usr/local/lib
09:35:25 <b0fh_ua> did the reick
09:35:28 <b0fh_ua> *trick
09:35:36 <kmc_> it looks like you're catching the error in order to re-throw it within Parsec using "unexpected"
09:35:55 <theclaw> kmc_: I want something like "fail to parser, and don't continue any alternatives or anything"
09:36:12 <kmc_> ah
09:36:21 <theclaw> kmc_: when I have "many someParser <|> somethingElse", somethingElse still gets parsed even if someParser fails
09:36:38 <kmc_> yeah, so make it so someParser returns a Maybe or Either value
09:36:45 <kmc_> (which are monads but that might not be so useful here)
09:36:50 <Alpounet> b0fh_ua, heh nice :)
09:37:18 <rhinoryan> has anyone here built YI for windoze?
09:37:54 <theclaw> kmc_: wouldn't I have to check the return value everywhere then?
09:38:07 <theclaw> kmc_: I mean that sounds a lot more complicated
09:38:20 <Saizan> theclaw: if you've lots of those ErrorT like in my paste might be appropriate
09:38:28 <kmc_> yeah, that is what monads are supposed to abstract out
09:38:35 <Saizan> s/those/those,/
09:38:48 <kmc_> but it might be easier depending on how often this pattern occurs
09:38:55 <kmc_> remember, you can define your own parser combinators
09:39:01 <theclaw> hmm
09:39:20 <kmc_> so you can define a variant of <|> which executes the left parser and checks its result
09:39:42 <temoto> <*!*> for example
09:39:47 <theclaw> yes, exceptions where just my first thought
09:39:52 <temoto> IRCBanParser
09:40:07 <rhinoryan> I've been trying to build Yi on windows, I've gotten far enough where it's complaining about GTK versions
09:40:09 <kmc_> what do you mean by "exceptions" then
09:40:18 <theclaw> kmc_: throwError/catchError
09:40:34 <theclaw> kmc_: I mean why should I rewrite <|> and so on if MonadError already exists?
09:41:04 <kmc_> you'd do it if it's nicer than using MonadError
09:41:26 <Saizan> the downside i see is that you've to "lift" the parser combinators, since they aren't polymorphic
09:41:31 <kmc_> for ErrorT, throwError / catchError is just sugar for passing around Either values.  i'm just suggesting that you evaluate whether the sugar is a net win or loss
09:41:50 <kmc_> it seems quite unfortunate to have to lift every parser
09:41:59 <theclaw> kmc_: yes :(
09:42:27 <kmc_> also, you could use "real" exceptions
09:42:31 <kmc_> but you'd have to catch them in IO
09:42:42 <Saizan> it's not clear to me why it doesn't "work" with ParsecT on top
09:42:57 <kmc_> and it might not do what you want -- those exceptions are thrown on evaluation; they're not part of the monad sequencing
09:44:12 <theclaw> hmm :/
09:44:55 <theclaw> Saizan: I could use the State monad with ParsecT on top without problems
09:45:24 <kmc_> if you're using a small number of Parsec combinators, you can "pre-lift" them elsewhere in your code
09:46:07 <jmcarthur> really the parsec library should just be extended with a MonadParsec class
09:46:55 <theclaw> kmc_: but why doesn't it work with ParsecT on top? ParsecT on top with the state monad works
09:47:04 <kmc_> theclaw: because ParsecT is also an instance of MonadError
09:47:09 <kmc_> and so throwError goes to the innermost one
09:47:11 * MissPiggy sigh
09:47:15 <theclaw> kmc_: it's an instance of MonadState too
09:47:20 <kmc_> hmm
09:47:22 <kmc_> i'm not sure then
09:47:28 <kmc_> i wish we had better control over scoping of instances
09:47:34 <shapr> Ok, so I got the House tcp/ip stack to compile, but I'm too little to figure out how to get it to send traffic to the rest of the world.
09:48:19 <shapr> Can anyone give me pointers on how to get tun0 to talk through eth0? This is haskell related :-)
09:48:47 <theclaw> kmc_: it's an instance of MonadError, but that only means that when using "throwError", it does "lift . throwError", etc., I thought
09:49:08 <Polarina> I have a C file (with a header) and a Haskell file using a function from the C file with FFI -- how do I compile them together?
09:49:22 <lament> pretend ghc is gcc
09:49:32 <Polarina> ghc isn't happy when I feed it a .c file.
09:50:35 <lament> compile the c file with gcc to get .o
09:50:44 <Polarina> http://codepad.org/j4sO9VCH
09:51:44 <kmc_> both files have the same .o name
09:51:47 <kmc_> that seems likely to cause problems
09:52:01 <Polarina> :(
09:52:20 <kmc_> ghc is calling "ld ffi.o ffi.o" most likely
09:52:33 <lament> ld is like what the hell
09:52:38 <Polarina> Yay! Thanks.
09:53:30 <Polarina> Now ghc thinks compilation is not required when I modify the .hs file. :(
09:53:51 <kmc_> yes
09:53:55 <kmc_> based on the .o file being newer
09:54:00 <Polarina> :(
09:54:11 <Polarina> I did a mv ffi.hs ffi-test.hs
09:54:20 <kmc_> rm *.o
09:55:10 <Polarina> It doesn't recompile, but doesn't complain.
09:55:51 <Polarina> I changed "Hi!" to "Hello, world!" and it still says 3.
09:56:27 <Polarina> And again it says compilation is not required. :(
09:56:38 <kmc_> rm *.o *.hi
09:56:43 <kmc_> That should do it...
09:56:49 <Polarina> I hate to have to run that every single time.
09:56:49 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16938#a16938 -- is this inherently inefficient? my prog seems to spend 30% of the time in here
09:56:58 <kmc_> Polarina: i doubt you do
09:56:59 <Twey> -fforce-recomp
09:57:07 <Twey> Should do it…
09:57:16 <Polarina> kmc_, rm *.o *.hi && ghc ffi.c ffi-test.hs -o something
09:57:28 <Polarina> kmc_, that seems to do something, but the binary isn't modified.
09:57:30 <kmc_> You're not using ghc --make
09:57:33 <kmc_> You should use ghc --make
09:57:35 <Polarina> --make?
09:57:39 <kmc_> --make
09:57:42 <Polarina> --make?
09:57:42 <kmc_> ghc --make
09:57:49 <lament> --make?
09:57:50 <Saizan> theclaw, kmc_: i think the MonadError instance for ParsecT is just broken, it's supposed to call the methods of the inner monad, but it forgets the "catch frame" if the action consumes something before throwing the error
09:57:55 <Polarina> kmc_, "no input files"
09:58:00 <kmc_> ghc --make foo.hs
09:58:18 <kmc_> ghc --make ffi.c ffi-test.hs
09:58:30 <kmc_> when i suggest a feature, i'm not necessarily giving you all the information you need in order to use it
09:58:42 <kmc_> you may want to look in the manpage or the GHC manual, etc.
09:58:54 <Polarina> kmc_, it made a new binary, named ffi-test, and it does not correspond to the code in the .hs file.
09:59:07 <Polarina> It prints "Hi!" but I removed "putStrLn "Hi!""
09:59:16 <Polarina> And I just double-check, I did save the file.
09:59:55 <aavogt> do you think that ghc-extension usage is most common for the extensions for which ghc suggests "hey look, I can't accept that unless you enable -XLaLa"?
09:59:57 <lament> never ask kmc_ for advice on medicine or firearms
10:00:21 <kmc_> that's very strange then
10:01:04 <theclaw> Saizan: hmm, that's annoying. do you know what exactly is broken?
10:02:25 <Polarina> Seems to work now for no apparent reason.
10:02:41 <sinelaw> yo all!
10:02:44 <Polarina> kmc_, thank you for your help. :)
10:02:46 <aavogt> hello sinelaw
10:02:57 <kmc_> :)
10:05:23 <theclaw> Saizan: I'll ask this question on stackoverflow
10:05:33 <theclaw> Saizan: (i.e., why monaderror + parsec doesn't work)
10:06:17 <Polarina> Now to figure out how to print a IO Ptr CChar. :P
10:09:02 <Polarina> peekArray0. :D
10:09:54 <Saizan> theclaw: i know, and i've just made it work, i'm not so familiar with parsec to be sure i've not broken some invariant, but i only had to change the MonadError instance
10:10:59 <theclaw> Saizan: what did you change?
10:11:56 <Saizan> theclaw: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16941#a16941
10:13:27 <Saizan> theclaw: i've annotated with the original, for comparison
10:13:35 <Saizan> preflex: seen ddarius
10:13:35 <preflex>  ddarius was last seen on #haskell 12 hours, 1 minute and 27 seconds ago, saying: * ddarius tends not to use multiple StateTs, period.
10:14:19 <theclaw> Saizan: it seem like inspect doesn't do anything?
10:15:05 <lispy> Proof by inspection doesn't do much :)
10:15:41 <Saizan> theclaw: it concatenates the two layer of effects of the transformed monad
10:15:50 <Saizan> *layers
10:15:59 <Saizan> they are separated by that Consumed
10:16:05 <Polarina> How do I make a CChar with the character 'a'?
10:16:39 <Saizan> Consumed is mostly used to early discard alternative parsers
10:16:42 <lispy> ?hoggle Char -> CChar
10:16:43 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
10:16:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:16:43 <lambdabot> Prelude error :: [Char] -> a
10:16:52 <jmcarthur> haven't we been down this road already?
10:16:54 <Polarina> lispy, thanks.
10:17:00 <Saizan> ..i believe
10:17:57 <theclaw> Saizan: why concatenate? It looks the same as before
10:18:37 <Saizan> theclaw: the type is the same since i've used those two return
10:19:14 <pikhq> Polarina: Use Hoogle.
10:19:32 <theclaw> Saizan: and what's different?
10:19:40 <Polarina> pikhq, what's hoogle?
10:19:43 <theclaw> Saizan: I mean you don't change "r"?
10:19:59 <pikhq> @where hoogle
10:20:00 <lambdabot> http://haskell.org/hoogle
10:20:08 <Polarina> Thanks. :)
10:20:31 <Saizan> theclaw: i don't change "r", the crucial point is that the "m" inside Consumed or Empty is now part of the action that returns that Consumed (or Empty)
10:20:59 <Saizan> theclaw: that way catchError gets to see the effects (i.e. the throwError) which is in that m too
10:21:28 <Saizan> s/which is/which are/
10:22:56 <RainCT> Is there some way for ghci's prompt to support the start/end buttons, delete, moving with the cursor through long lines and not just seeing their end, etc?
10:23:42 <Saizan> yes
10:23:52 <Saizan> at least the first ones
10:24:01 <theclaw> Saizan: hrm.
10:24:26 <Saizan> RainCT: which version of ghc is this?
10:24:36 <Polarina> YAY!  a <- strsomething >>= peekCAString
10:24:37 <Polarina> :P
10:24:38 <RainCT> Saizan: 6.10.4
10:24:50 <gwern> if I forkIO a thread and call 'print' inside it, should I expect to not see the output on the console?
10:25:27 <Polarina> gwern, you should expect a race condition when you're printing in forkIO and in the main execution path simultaneously.
10:25:43 <benmachine> well, you should expect something to be printed
10:25:44 <gwern> Polarina: I print only in the threads
10:25:48 <Saizan> RainCT: it should be using haskeline then, http://trac.haskell.org/haskeline/wiki/UserPrefs
10:25:50 <Polarina> gwern, then you're safe.
10:25:53 <gwern> @hoogle (=<<)
10:25:53 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:25:54 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
10:25:59 <gwern> @hoogle (>>=)
10:25:59 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:25:59 <benmachine> if you are printing in multiple threads then you can sometimes get things mangled
10:25:59 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:25:59 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:26:11 <benmachine> but usually buffered I/O will mean that stuff comes out together
10:26:15 <benmachine> ...usually
10:26:25 <gwern> problem is, I'm seeing nothing and I'm wondering whether that means my program is not ever actually getting to the print part
10:26:27 <Saizan> gwern: be sure to hFlush stdout
10:26:28 <theclaw> Saizan: has this to do with lazy evaluation?
10:26:39 <Saizan> theclaw: no
10:26:40 <benmachine> gwern: is your main thread dying shortly after forkIO'ing?
10:26:51 <gwern> no
10:27:08 <gwern> (although it did just die now with the message 'archive-bot: getProtocolByName: does not exist (no such protocol name: tcp)')
10:27:28 <benmachine> it confused me for a while that main = forkIO (threadDelay whatever >> print "blah") kills the child thread before it prints anything
10:28:06 <kmc_> yeah, when the main thread exits your program dies
10:28:10 <Polarina> benmachine, you need to join the thread.
10:28:22 <kmc_> there's no standard way to join forkIO threads :/
10:28:35 <kmc_> typically you either have it put a MVar or write to a Chan
10:28:36 <RainCT> Saizan: Thanks
10:28:37 <gwern> would be nice if there were a parMapM and parMapM_
10:28:43 <gwern> @hoogle parMapM
10:28:43 <lambdabot> No results found
10:28:45 <gwern> darn
10:28:54 <Saizan> theclaw: when you have "return (Consumed (throwError "foo")) `catchError` (\e -> ..)" that catchError doesn't care that inside Consumed there's an action throwing an error, that's considered part of the result, the action catchError sees is a "return something" so it doesn't have any error to catch
10:29:06 <benmachine> isn't that just sequence . parMap
10:29:13 <kmc_> benmachine: no
10:29:15 <benmachine> or would that not be parallel enough
10:29:16 <Polarina> You can modify foldl' to use `par` and `pseq` instead of `seq`.
10:29:24 <Polarina> @src foldl'
10:29:24 <lambdabot> foldl' f a []     = a
10:29:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
10:29:26 <kmc_> sequence . parMap would evaluate a bunch of actions in parallel, then execute them sequentially
10:29:40 <kmc_> in order to execute the actions in parallel your monad needs a notion of forking akin to forkIO
10:29:58 <Saizan> theclaw: but "inspect $ return (Consumed (throwError "foo"))" is the same as throwError "foo", so catchError will actually see the error and catch it
10:30:13 <benmachine> so parMapM would require more than just Monad?
10:30:16 <kmc_> yes
10:30:22 <kmc_> it'd require some kind of "MonadFork" class
10:30:35 <benmachine> do you know any non-IO implementations?
10:30:39 <benmachine> non-IO non-trivial
10:30:50 <kmc_> that's not to say that (sequence . parMap) is useless
10:30:57 <gwern> benmachine: non-IO? parallel only makes sense for IO
10:30:57 <kmc_> but it definitely doesn't capture the idea of concurrent IO threads
10:31:08 <gwern> yuo want to control evaluation order on the hardware
10:31:10 <kmc_> eh, you could imagine forkIO-like concurrency for ST, couldn't you
10:31:12 <gwern> hardware=()
10:31:15 <gwern> *IO
10:31:17 <Polarina> What would be C declaration for a function that looks like foreign import ccall "smth.h smth" something :: IO CStringLen?
10:31:36 <jmcarthur> kmc_: mapM_ forkIO  ;)
10:31:48 <kmc_> i'll guess "size_t smth()"
10:31:52 <kmc_> don't know what CStringLen is
10:32:08 <Polarina> kmc_, type CStringLen = (Ptr CChar, Int)
10:32:19 <kmc_> oh, hmm
10:32:29 <jmcarthur> i've been working on a pure concurrency library (requires explicit yield, except for IO)
10:32:33 <kmc_> very strange, i didn't think it was legal for an FFI function to return a tuple
10:32:58 <Polarina> kmc_, there are some marshalling functions that take in a CStringLen.
10:33:00 * kmc_ reads FFI report
10:33:01 <Polarina> Or return it.
10:33:02 <benmachine> is hmake obsolete these days?
10:33:10 <Polarina> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Foreign-C-String.html#t%3ACStringLen
10:33:19 <RainCT> Saizan: Doesn't seem to work though :/
10:33:24 <kmc_> Polarina: yes
10:33:39 <Saizan> RainCT: how did you get your ghc?
10:34:35 <kmc_> Polarina: yes, the FFI spec says that a foreign-imported function may not return a tuple
10:34:40 <kmc_> (or an IO action yielding a tuple)
10:34:43 <Polarina> Odd.
10:34:54 <kmc_> Polarina: did you see that foreign import in some code somewhere?
10:34:59 <Polarina> Then what the hell is that type doing there then?
10:35:00 <RainCT> Saizan: From Debian Sid's repositories (installed the meta-package haskell-platform)
10:35:07 <Polarina> kmc_, no, I was wondering how I'd use it.
10:35:39 <kmc_> Polarina: err, I don't understand.  You can do things with a type other than pass it to or from a FFI-imported function
10:35:54 <Saizan> RainCT: not sure then, you can always use rlwrap like here though http://haskell.org/haskellwiki/GHC/GHCi#rlwrap_.28for_GHCI_compiled_without_readline.2Feditline.29
10:35:56 <Polarina> Hmm...
10:36:13 <benmachine> can a foreign-imported function accept a tuple?
10:36:19 <kmc_> benmachine: looks like no
10:36:26 <kmc_> CStringLen is defined in Foreign.C.String because it's useful for working with C strings.  not because you're expected to pass it directly through FFI
10:36:28 <benmachine> tuples suck :P
10:36:34 <kmc_> yeah
10:36:52 <Polarina> I've found good uses for tuples. :)
10:37:05 <kmc_> i'm working off of http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-120003.2
10:37:40 <Polarina> A FFI function can take a Char (the haskell type) directly?
10:37:50 <theclaw> Saizan: could you explain what in "inspect" changes the input?
10:37:50 <kmc_> Yeah
10:37:56 <theclaw> Saizan: I mean it works now, I just don't get it ;)
10:38:00 <kmc_> There will be some boxing/unboxing behind the scenes
10:38:01 <Polarina> That does not sound right.
10:38:08 <kmc_> why not?
10:38:12 <theclaw> Saizan: it looks like it doesn't do anything with the input - or do I overlook something?
10:38:19 <kmc_> The FFI spec defines what the compiler must allow -- it's up to the compiler to implement it correctly
10:38:24 <benmachine> I'd expect Char to correspond to wchar_t
10:38:27 <Polarina> What C type is equivalent to Haskell's Char?
10:38:28 <benmachine> rather than char
10:38:32 <benmachine> but I don't know
10:38:42 <kmc_> probably char, with silent truncation
10:38:46 <kmc_> benmachine makes a good point
10:38:58 <Polarina> But that point is not valid on windows. :(
10:39:13 <Polarina> As it uses UTF-16 but Haskell uses UTF-32.
10:39:19 <benmachine> windows doesn't have wchar_t?
10:39:25 <b0fh_ua> Hi there! Can somebody please help me to understand what am I doing wrong in the code: http://pastebin.com/d505593e7. According to http://hackage.haskell.org/packages/archive/curl/1.3.5/doc/html/Network-Curl.html#t%3ACurlResponse I should be able to use respBody on resp ?
10:39:35 <RainCT> Saizan: Tried that before, but it doesn't seem to make a difference (in fact, when I tried it yesterday I got some weird behaviour -can't remember what it was though)
10:39:53 <theclaw> Saizan: is this some more advanced thing maybe not know to haskell beginners? (do I need to understand some concepts?)
10:39:57 <b0fh_ua> but looks like I am missing types, and I will really appreciate if somebody put some light on my ignorance
10:40:06 <kmc_> GHC extends the FFI types to allow unboxed types as well
10:40:34 <kmc_> b0fh_ua: strange to mix "do" and (>>=) like that
10:40:50 <benmachine> b0fh_ua: curlGetString returns IO (CurlCode, String)
10:41:02 <benmachine> which would give resp type (CurlCode, String)
10:41:11 <benmachine> whereas you are trying to treat it like a CurlResponse
10:41:25 <kmc_> maybe you want to use curlGetResponse
10:41:40 <benmachine> sounds likely
10:41:59 <b0fh_ua> http://hackage.haskell.org/packages/archive/curl/1.3.5/doc/html/Network-Curl.html#v%3AcurlGetResponse - that states it will return CurlReponse, which in turn is data CurlResponse_ ?
10:42:17 <b0fh_ua> omg
10:42:20 <b0fh_ua> really
10:42:34 <b0fh_ua> I just was blind )
10:42:37 <benmachine> heh
10:42:38 <benmachine> it happens
10:43:03 <mreh> (\ n -> [n..1]) 3
10:43:04 <mreh> > (\ n -> [n..1]) 3
10:43:05 <lambdabot>   []
10:43:11 <b0fh_ua> I started to think that I'm really messy about haskell type system
10:43:13 <mreh> > (\ n -> [n,n-1..1]) 3
10:43:14 <lambdabot>   [3,2,1]
10:43:20 <mreh> > (\ n -> [n,n-1..1]) -1
10:43:21 <lambdabot>   No instance for (GHC.Num.Num (t -> [t]))
10:43:21 <lambdabot>    arising from the literal `1' at...
10:43:24 <Polarina> b0fh_ua, we all are. :)
10:43:31 <mreh> > (\ n -> [n,n-1..1]) (-1)
10:43:32 <lambdabot>   []
10:44:08 <dons> anyone comfortable with jdh trolling -cafe@?
10:44:09 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:44:50 <dons> gwern: re. 6.12, the next HP is only a few weeks away, so now you know there's some work to do to upgrade things.
10:46:51 <HaskellLove> Can eulers be solved in Prolog?
10:47:03 <sinelaw> i suppose so
10:47:08 <sinelaw> care to try?
10:47:23 <lament> HaskellLove: no
10:47:34 <lament> prolog is not euler-complete
10:47:43 <Gracenotes> Haskell has been quite useful in letting me bypass manually calculating Hamming distances for my algebra class
10:47:47 <Gracenotes> -> distance a b = sum . map fromEnum $ zipWith (/=) a b
10:48:06 <MissPiggy> @let distance a b = sum . map fromEnum $ zipWith (/=) a b
10:48:08 <lambdabot>  Defined.
10:48:20 <tensorpudding> pretty soon you can get by using haskell and not have to learn anything
10:48:21 <MissPiggy> > map (distance (2*3*5)) [1..]
10:48:21 <lambdabot>   No instance for (GHC.Num.Num [a])
10:48:22 <lambdabot>    arising from the literal `2' at <inter...
10:48:32 <MissPiggy> ho......
10:48:57 <benmachine> :t distance
10:48:58 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Int
10:48:59 <Gracenotes> tensorpudding: highly mechanical, ye know
10:49:10 <jmcarthur> HaskellLove: are you *still* on project euler problems? why don't you try some real programs in haskell?
10:49:11 <temoto> Were dependant types "invented" before first haskell implementation?
10:49:26 <kmc_> much before, i think
10:49:51 <mreh> > let (x:xs) = [3] in xs
10:49:52 <HaskellLove> jmcarthur i am a fuckin noob... gota get the basics first
10:49:52 <lambdabot>   []
10:49:57 <tensorpudding> project euler is fun for learning algorithms
10:50:15 <jmcarthur> HaskellLove: i've told you a million times that euler isn't going to teachyou haskell
10:50:18 <kmc_> Martin-Löf type theory is from 1972
10:50:20 <tensorpudding> but the portion of any language you learn from project euler isn't very great
10:50:23 <gwern> 'main = fmap B.words B.getContents >>= λx →  fmap concat (mapM fetchArticleURLs x) >>= mapM_ (forkIO · archiveURL'
10:50:27 <gwern> golf suggestions?
10:50:35 <HaskellLove> jmcarthur it will teach me algorithms
10:50:44 <tensorpudding> you got some unicode in there gwern
10:50:50 <gwern> tensorpudding: 'sall good
10:50:55 <mauke> unmatched (
10:50:59 <burp> <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete ← someone quote this ;)
10:51:11 <temoto> > distance [0,0] [2,2]
10:51:12 <lambdabot>   2
10:51:13 <medfly> hahahaha
10:51:19 <jmcarthur> burp: you just did :P
10:51:38 <HaskellLove> haha so funny, but not really...
10:51:42 <medfly> @remember HaskellLove <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
10:51:42 <lambdabot> Done.
10:51:49 <medfly> HaskellLove, it's never funny when it makes fun of you
10:51:51 <gwern> mauke: I dropped the last paren, whatever
10:51:57 <kmc_> temoto: dependent types are in some sense simpler and more natural than the restricted systems
10:52:07 <benmachine> medfly: I'd have attributed that quote to lament but whatever :P
10:52:16 <medfly> oh
10:52:21 <medfly> @forget HaskellLove <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
10:52:21 <lambdabot> Done.
10:52:27 <aavogt> gwern: instead of   fmap f act >>= blah,    act >>= blah . f
10:52:28 <medfly> @remember lament <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
10:52:28 <lambdabot> I will remember.
10:52:33 <benmachine> thx
10:52:44 <medfly> (you can do this too, afaik...)
10:52:55 <mauke> anyone can
10:52:56 <temoto> kmc_, do you remember winged comics about DT?
10:52:57 <aavogt> you can't @flish though
10:53:02 <kmc_> temoto: no
10:53:03 <mauke> @flish
10:53:04 <kmc_> what's that
10:53:07 <kmc_> @flush
10:53:07 <lambdabot> Not enough privileges
10:53:12 <kmc_> @. elite flush
10:53:13 <lambdabot> Plugin `compose' failed with: Privledged commands cannot be composed
10:53:16 <kmc_> :(
10:53:21 <benmachine> privledged?
10:53:46 <gwern> aavogt: problem is that begins to obfuscate the flow
10:54:13 <aavogt> gwern: then use  =<<, and then everything is consistently right to left
10:54:15 <gwern> eg, 'main = fmap B.words B.getContents >>= mapM fetchArticleURLs >>= mapM_ (forkIO · archiveURL) · concat' - we go right, right, then left with concat -> archive -> fork
10:54:35 <temoto> kmc_, some guy drew a series of images about Data (as workers which commit crimes, etc) and Types (as nobles which do nothing). i'll find it any now
10:54:45 <kmc_> http://strictlypositive.org/winging-jpgs/
10:54:52 <kmc_> those?
10:54:53 <aavogt>  main = mapM_ (forkIO . archiveURL) . concat =<< mapM fetch . B.words =<< B.getContents
10:54:57 <benmachine> or use >>> instead of .?
10:55:04 <benmachine> but that'd be slightly weird
10:55:21 <gwern> main =  mapM_ (forkIO · archiveURL) · concat =<< mapM fetchArticleURLs  =<< fmap B.words B.getContent is better, yeah
10:55:47 <mauke> main=B.getContents>>=mapM fetchArticleURLs.B.words>>=mapM_(forkIO.archiveURL).concat  -- is this semantically equivalent?
10:55:48 <gwern> (now, how to combine the two maps)
10:56:16 <aavogt> mauke: don't you need spaces to disambiguate qualification and . as composition?
10:56:18 <kmc_> temoto: the "social mobility" described is not real dependent types though
10:56:21 <mauke> aavogt: no
10:56:24 <Saizan> theclaw: sorry i was afk, what do you mean by input?
10:56:38 <gwern> mauke: probably but again the concat involves a visual reversal
10:57:03 <medfly> the only category in Haskell is Haskell, right?
10:57:03 <Saizan> theclaw: i guess it takes some familiarity with considering monadic actions as data themselves
10:57:07 <mauke> visuals? THIS IS SPART^WGOLF!
10:57:14 <gwern> @hoogle concatMap
10:57:15 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
10:57:15 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
10:57:15 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
10:57:23 <theclaw> Saizan: no problem. I mean, you give it an "m", how *exactly* does the output differ from it?
10:57:48 <temoto> kmc_, those, yup. I stopped to understand when lists started to zip nice. So i guess i need more learning before understanding something that simpler than restrictive systems. :)
10:58:26 <Saizan> theclaw: suppose this m looks like "do a; return (Consumed (do b; return r))"
10:58:40 <temoto> kmc_, but if you happen to know any DT tutorials with burritos i'm all ears. :p
10:58:51 <kmc_> temoto: well, those slides are not exactly the clearest expositional style
10:59:00 <Saizan> theclaw: inspect m then will look like "do a; b; return (Consumed (return r))
10:59:01 <kmc_> i very much enjoyed this document: http://www.cs.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf
10:59:13 <temoto> kmc_, thanks.
10:59:28 <Saizan> theclaw: the 'b' got moved outside of Consumed
10:59:58 <theclaw> Saizan: and how is this achieved?
11:00:16 <theclaw> Saizan: (what code does this?)
11:00:28 <gwern> main = mapM (fmap (mapM_ (forkIO · archiveURL)) · fetchArticleURLs) =<< fmap B.words B.getContents
11:00:31 <gwern> ouch
11:00:45 <Saizan> theclaw: the "... Consumed m -> do r <- m; ..."
11:01:12 <theclaw> Saizan: the point is that the monad does get evaluated?
11:01:17 <theclaw> Saizan: the monad "m"
11:01:37 <mauke> gwern: now define (·) = fmap :-)
11:01:45 <gwern> 'main = mapM_ (fmap ((forkIO · archiveURL) · concat) · fetchArticleURLs) =<< fmap B.words B.getContents'
11:01:48 <gwern> slightly better
11:02:06 <gwern> (and remove a pair of parens0
11:02:30 <Saizan> theclaw: it's not really a matter of evalution
11:02:46 <mauke> ((forkIO · archiveURL) · concat)  ->  (forkIO · archiveURL · concat)
11:03:02 <Saizan> theclaw: it's that the monadic action 'm' is sequenced together with the action that returns the Consumed
11:03:26 <gwern> mauke: yeah I know
11:03:42 <Saizan> theclaw: a nice thing about monads is that you can reason about their effects without thinking of evaluation
11:04:13 <Saizan> theclaw: though you've to understand how effects propagate only because >>= chains them together
11:04:40 <Saizan> theclaw: if you have a monadic action around but you don't chain it with the others it's just an inhert value like the others
11:04:42 <theclaw> Saizan: hmm. I thought I've understood how monads basically work
11:04:51 <sinelaw> @hoogle readMS
11:04:52 <lambdabot> No results found
11:05:15 <sinelaw> where is that defined?
11:05:19 <Saizan> ehm, i've used others twice with two different meanings :)
11:05:56 <Twey> @let (·) = fmap
11:05:57 <lambdabot>  Defined.
11:06:13 <mauke> :t (·)
11:06:14 <lambdabot> Not in scope: `??'
11:06:18 <theclaw> Saizan: could you explain what you mean with "the monadic action 'm' is sequenced together with the action that returns the Consumed"?
11:06:27 <Twey> :t ·
11:06:28 <lambdabot> parse error on input `??'
11:06:29 <Twey> Er
11:06:29 <theclaw> Saizan: sorry for my inability to comprehend ;)
11:06:31 <Twey> :t (·)
11:06:33 <lambdabot> Not in scope: `??'
11:06:42 <mauke> Twey: gee, thanks
11:06:43 <Twey> Err… what?
11:06:59 <Twey> > (+ 1) · (* 3) $ 4
11:07:01 <lambdabot>   13
11:07:02 <MissPiggy> :t ()
11:07:03 <lambdabot> Not in scope: `?'
11:07:08 <Twey> :t (·)
11:07:09 <lambdabot> Not in scope: `??'
11:07:12 <mauke> > succ · (2 *) · [1, 2, 3]
11:07:12 <Twey> I guess :t doesn't do Unicode?
11:07:13 <lambdabot>   [3,5,7]
11:07:15 <theclaw> Saizan: especially what "sequenced together" means
11:07:24 <kmc_> theclaw: "evaluation" and "execution" are totally separate
11:07:39 <mauke> > (succ · (2 *)) · [1, 2, 3]
11:07:40 <lambdabot>   [3,5,7]
11:07:50 <Saizan> theclaw: sequenced together in the sense that they are connected with >>= or equivalently with do-notation
11:08:59 <Saizan> theclaw: we started with "do a; return (Consumed (do b; return r))" and the "b" is not connected to "a", it's just stored inside the Consumed constructor
11:09:45 <jmcarthur> theclaw: "hmm. I thought I've understood how monads basically work"  <-- first sign that it hasn't yet clicked. monads don't work in any particular way
11:09:52 <Twey> Haha
11:09:56 <kmc_> hehe
11:09:59 <Saizan> theclaw: but if we have "do a; b; return (Consumed (return r))" then they are connected, and the effects of b needs to be taken in consideration before we can look at the Consumed constructor
11:10:01 <sinelaw> Cale, what's readMS?
11:10:11 <Saizan> for example:
11:10:29 <Saizan> > Just Nothing `mplus` Just (Just 1)
11:10:30 <lambdabot>   Just Nothing
11:11:07 <dixie> > right Left Riht Left Nothing
11:11:08 <lambdabot>   Not in scope: data constructor `Riht'
11:11:16 <Saizan> even if Nothing is an action of the Maybe monad too, it doesn't cause mplus to see the error, because in this case it's just the result value of the action "Just Nothing"
11:11:20 <dixie> > Right Left Right Left Nothing
11:11:21 <lambdabot>   Couldn't match expected type `(b -> Data.Either.Either a b)
11:11:21 <lambdabot>                ...
11:11:26 <Twey> :t right
11:11:27 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
11:11:57 <kmc_> theclaw: here's an example of evaluation without execution:
11:12:01 <kmc_> > putStrLn "Hello, world!"
11:12:03 <lambdabot>   <IO ()>
11:12:08 <MissPiggy> > (Left . Right . Left . Right . not)
11:12:09 <lambdabot>   True->
11:12:09 <lambdabot>    Left (Right (Left (Right False)))
11:12:09 <lambdabot>  False->
11:12:09 <lambdabot>    Left (Right (Left (...
11:12:20 <kmc_> lambdabot evaluates the IO action to normal form, and prints its type, but it does not execute the actual instructions for doing IO
11:12:35 <MissPiggy> > \x y -> not (x && (not y))
11:12:36 <lambdabot>   {True->{True->True;False->False};False->{True->True;False->True}}
11:12:47 <kmc_> (caveat: i think IO is generally a bad example for monads)
11:12:48 <Saizan> > error "foo" :: IO ()
11:12:49 <lambdabot>   <IO ()>
11:12:52 <theclaw> kmc_: okay
11:12:59 <kmc_> heh, so it doesn't even evaluate it to normal form
11:13:01 <kmc_> but it could
11:13:09 <kmc_> > putChar 'x' `seq` ()
11:13:10 <lambdabot>   ()
11:13:16 <theclaw> Saizan: I think I get what you mean now
11:13:42 <kmc_> so we have to be careful about the words "evaluate" and "execute" whereas they are thrown around equivalently for most other languages
11:13:58 <sinelaw> @hoogle Data.Maybe
11:13:58 <lambdabot> module Data.Maybe
11:13:59 <lambdabot> Data.Maybe data Maybe a
11:13:59 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
11:14:23 <gwern> hm. hunit no longer has a darcs repo?
11:14:30 <theclaw> Saizan: thanks a lot for your patience
11:14:47 <theclaw> kmc_: but why does "sequence" then say "Evaluate each action in the sequence from left to right, and collect the results."?
11:14:57 <benmachine> gwern: is it one of the ones that got cleaned off darcs.haskell.org?
11:15:11 <gwern> benmachine: I've no idea. my outdated repo is http://richardg.name/Haskell/HUnit
11:15:21 <kmc_> theclaw: well, it might evaluate them before sequencing them
11:15:24 <gwern> outdated because the error on -cafe is using 1.2.2, not 1.2.0
11:15:26 <kmc_> but i think they're just being sloppy
11:15:35 <Saizan> theclaw: np, it's not straightforward at first, and i'm not sure i've been good at explaining this :)
11:15:47 <kmc_> i would consider that a doc bug
11:15:52 <theclaw> kmc_: mhm
11:15:54 <kmc_> but i don't quite have the balls to open a ticket on it ;)
11:16:29 <Apocalisp> @type sequenceA
11:16:30 <lambdabot> Not in scope: `sequenceA'
11:16:38 <kmc_> as it happens i think sequence does not add any strictness to the evaluation of the actions
11:16:39 <Apocalisp> @type Data.Traversable.sequenceA
11:16:40 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
11:18:10 <kmc_> anyway "evaluate left to right" is a silly thing to say in Haskell, since for the most part we're not supposed to be aware of evaluation order
11:19:27 <temoto> @wn to have balls
11:19:30 <lambdabot> No match for "to".
11:19:30 <lambdabot>  
11:19:30 <lambdabot> *** "have" wn "WordNet (r) 2.0"
11:19:30 <lambdabot> have
11:19:30 <lambdabot>      n : a person who possesses great material wealth [syn: {rich
11:19:32 <lambdabot> [57 @more lines]
11:20:08 <medfly> temoto, guts
11:20:20 <medfly> another part of your anatomy
11:20:24 <kmc_> testicles
11:20:41 <theclaw> Saizan: would you mind writing a bug report to the parsec team? I don't want to take credit for it
11:21:06 <Gracenotes> I do like binary literals, you know
11:21:14 <theclaw> Saizan: (and I probably couldn't explain the problem, anyway)
11:21:24 <temoto> I know what balls is. I don't understand expression 'to have balls to do smth.'
11:21:24 <dmead> channel
11:21:38 <dmead> let bindings are lazy, where clauses are strict
11:21:38 <kmc_> to have the courage to do something
11:21:39 <dmead> yes?
11:21:45 <Gracenotes> it uses implications related to masculinity
11:21:45 <kmc_> dmead: no
11:21:46 <temoto> kmc_, thanks.
11:21:48 <kmc_> don't think so
11:21:56 <dmead> lets aren't lazy?
11:22:03 <kmc_> dmead: let and where are not differently strict
11:22:03 <mauke> temoto: see also 'ballsy'
11:22:20 <Gracenotes> also cocky
11:22:22 <dmead> are they both lazy?
11:22:24 <mauke> http://www.urbandictionary.com/define.php?term=balls+of+steel
11:22:24 <dmead> or neither?
11:22:27 <monochrom> Do you have the balls to play pool or snooker? You need 10 balls or something.
11:22:34 <temoto> dmead, what is 'lazy binding' anyway?
11:22:39 <kmc_> dmead: a pattern binding could be lazy or strict
11:22:43 <temoto> mauke, thanks.
11:22:56 <dmead> so it depends on the binding?
11:22:58 <kmc_> a simple binding to a variable is always lazy, in that the mere presence of the binding does not cause any evaluation on its RHS
11:23:08 <dmead> right
11:23:09 <theclaw> Saizan: in afterthought, it seems unfriendly to request that. sorry
11:23:15 <kmc_> dmead: if there are constructors mentioned on the LHS of the binding, it will have to evaluate the RHS far enough to see if they match
11:23:16 <Gracenotes> besides having the runtime system put it on the heap
11:23:18 <Apocalisp> monochrom: Pocket pool is a miniature version in which you only need two balls.
11:23:22 <kmc_> > let (x,y) = undefined in ()
11:23:23 <lambdabot>   ()
11:23:27 <kmc_> hmm
11:23:35 <monochrom> Eww
11:23:47 <kmc_> > let (x:xs) = [] in ()
11:23:48 <lambdabot>   ()
11:23:52 <kmc_> hmm, i'm wrong
11:24:05 <dmead> i gave a workshop about haskell last night
11:24:06 <kmc_> i thought you only got that with the irrefutable pattern
11:24:17 <dmead> and i said lets are lazy, wheres are strict
11:24:20 <mauke> let bindings are always lazy
11:24:28 <dmead> right, thats what i thought
11:24:33 <dmead> it's wheres that are ambiguous
11:24:35 <benmachine> wheres are strict?
11:24:41 <dmead> arent they?
11:24:47 <temoto> kmc_, it did evaluate RHS far enough to see if they match.
11:24:51 <benmachine> > case () of () -> () where (x, y) = undefined
11:24:52 <lambdabot>   ()
11:25:04 <monochrom> both lazy
11:25:08 <kmc_> i don't think let and where have different strictness
11:25:11 <benmachine> wheres are just lets with a different name
11:25:13 <benmachine> I thought
11:25:20 <kmc_> benmachine: and different syntax
11:25:22 <mauke> > case undefined of (x, y) -> ()
11:25:22 <medfly> syntax
11:25:23 <lambdabot>   * Exception: Prelude.undefined
11:25:24 <kmc_> not just prefix vs postfix
11:25:29 <temoto> benmachine, and guard stuff.
11:25:30 <kmc_> where is not an expression
11:25:34 <dmead> i swear somebody i the know told me lets are lazy wheres are stricgt
11:25:37 <monochrom> Don't worry about it. People forget what you say. Hell, people here forget what you say here 2 minutes later.
11:25:45 <kmc_> is it fair to say, then, that let/where bindings are always irrefutable?
11:25:50 <kmc_> > let ~(x,y) = undefined in ()
11:25:51 <lambdabot>   ()
11:25:57 <dmead> well i admitted i could be wrong
11:26:12 <kmc_> that is, "let p = e in b" is never different from "let ~p = e in b" ?
11:26:22 <temoto> > let undefined undefined undefined in "who cares"
11:26:22 <lambdabot>   <no location info>: parse error on input `in'
11:26:31 <kmc_> > case undefined of { (x,y) -> () }
11:26:32 <temoto> dammit
11:26:33 <lambdabot>   * Exception: Prelude.undefined
11:26:34 <kmc_> > case undefined of { ~(x,y) -> () }
11:26:35 <lambdabot>   ()
11:26:46 <benmachine> kmc_: no
11:26:49 <kmc_> so the ~ for irrefutable patterns matters in "case"
11:26:54 <benmachine> hmm
11:26:57 <benmachine> by no, I mean yes
11:27:04 <dmead> lol
11:27:09 <kmc_> > let !(x,y) = undefined in ()
11:27:10 <lambdabot>   * Exception: Prelude.undefined
11:27:10 <dmead> hmm
11:27:18 <dmead> there you go
11:27:20 <temoto> wow
11:27:23 <benmachine> I was thinking you can have irrefutable patterns in a let that are important
11:27:24 <shambler> no is a metaphore for yes
11:27:28 <benmachine> but usually only as a sub-pattern
11:27:33 <benmachine> and by usually I mean ""
11:27:41 <kmc_> "let !p = e in b"   ==>  "let x@p = e in x `seq` b" ?
11:27:56 * kmc_ looks it up
11:28:21 <MissPiggy> kmc_ I don't think quite equal
11:28:33 <kmc_> "a bang at the top level of a let or where binding makes the binding strict, regardless of the pattern"
11:28:35 <kmc_> that's a special case
11:28:37 <kmc_> i see
11:28:38 <temoto> kmc_, reading first pages, i got it like dependant types is just a type passed as an argument to function and then it is pattern matched. In most polymorphic case it's not mentioned so any one matches. Is it right?
11:28:55 <monochrom> http://www.haskell.org/onlinereport/exps.html#sect3.12 for let
11:28:57 <MissPiggy> temoto, you can't pattern match on types
11:28:59 <kmc_> temoto: i don't understand what you're saying
11:29:12 <temoto> MissPiggy, it's about Agda.
11:29:14 <kmc_> temoto: in a dependently typed language, types are first-class values
11:29:17 <MissPiggy> temoto, I understand
11:29:24 <kmc_> they might have constructors you can pattern match on
11:29:26 <kmc_> like any other value
11:29:29 <MissPiggy> temoto, I know Agda quite a bit
11:30:21 <kmc_> hmm, that last thing i said is not very correct
11:30:29 <MissPiggy> types are not values :P
11:30:31 <MissPiggy> yes
11:30:39 <kmc_> they're first class anyway
11:30:43 <temoto> That's how i understood 'identity A x = x'
11:30:44 <kmc_> you can pass them to and return them from functions
11:30:45 <MissPiggy> first class sort of meaningless
11:30:53 <MissPiggy> temoto, it's really
11:30:57 <MissPiggy> identity = \a x -> x
11:31:04 <MissPiggy> just a variable that is bound
11:31:13 <kmc_> yeah, that's equivalent to "identity a x = x"
11:31:15 <kmc_> even in Haskell
11:31:21 <MissPiggy> ?? not in haskell
11:31:22 <lambdabot>  not in haskell
11:31:26 <Twey> identity = const
11:31:28 <MissPiggy> even lambdabot argrees
11:31:34 <kmc_> err, "identity = \a x -> x" and "identity a x = x" are equivalent in Haskell
11:31:45 <Twey> But they're not
11:31:48 <MissPiggy> I was using agda notation
11:31:48 <sinelaw> i think cabal has installed a bad package - how do i uninstall it?
11:31:56 <MissPiggy> not haskell
11:32:00 <Twey> They have different sharing/MMR properties
11:32:03 <temoto> MissPiggy, so it's a type passed into function, isn't it?
11:32:13 <MissPiggy> temoto, yes
11:32:15 <kmc_> "identity : (A : Set) -> A -> A"   temoto, this type means "identity takes an argument of type Set (call it A), and an argument of type A, and returns something of type A"
11:32:23 <kmc_> the "dependent types" part is the "call it" parenthetical
11:32:37 <kmc_> it allows later parts of the type expression to depend on the *value* passed earlier
11:33:36 <kmc_> the type of the second arg is the *value* of the first arg
11:34:01 <Polarina> Returning a tuple and taking in tuples in FFI imported functions makes sense, but I can't do it. :(
11:34:04 <MissPiggy> you can also write
11:34:10 <kmc_> Polarina: how does it make sense?
11:34:11 <MissPiggy> identity : (A : Set) -> (x : A) -> A
11:34:17 <Polarina> kmc_, a struct.
11:34:21 <MissPiggy> identity = \(A : Set) -> \(x : A) -> x
11:34:26 <MissPiggy> just to show you the uniformity
11:34:40 <kmc_> Polarina: by value?
11:34:45 <MissPiggy> instead of polymorphism, you pass types directly
11:34:45 <Polarina> kmc_, yes.
11:34:46 <temoto> MissPiggy, so A is passed into function, but i can't match on it?
11:34:49 <roconnor> Twey: what are the different sharing properties?
11:34:52 <MissPiggy> temoto, yes that is right
11:35:08 <kmc_> temoto: you can't match on it, simply because "Set" is not an algebraic type
11:35:11 <kmc_> it doesn't have constructorns
11:35:17 <kmc_> (that's the thing i said earlier that was wrong)
11:35:31 <temoto> But other type could have constructors, like Num
11:35:35 <kmc_> indeed
11:35:36 <Polarina> kmc_, it does make sense, doesn't it?
11:35:46 <temoto> And you can match on it?
11:35:47 <kmc_> Polarina: sort of.  i think the mapping would become pretty messy
11:35:59 <Polarina> kmc_, Just an ordinary tuple...
11:36:16 <kmc_> Polarina: i mean on the C side.  for example different C structs can have different packing / alignment attributes
11:36:34 <Polarina> kmc_, default alignment/packing?
11:36:38 <MissPiggy> temoto, what you can do is write a data type (data TYPE = UNIT | ARROW TYPE TYPE | ...) and a function (eval : TYPE -> Set) that turns it into a type -- and then you can write a function like     f : (T : TYPE) -> (t : eval T) -> (whatever), and f can pattern match on T, which will refine th information you have about t
11:36:41 <kmc_> part of the design of the Haskell FFI is to make automatic marshaling simple
11:36:54 <kmc_> yeah, that stuff is covered later in the document
11:37:17 <kmc_> section 3
11:37:57 <Polarina> data CStruct = CStruct <alignment> <packing> <a tuple of some size>
11:38:01 <dmead> dons, ping
11:38:15 <kmc_> by which i meant (and poorly stated)
11:38:24 <kmc_> that the only types automatically marshaled are simple ones
11:39:16 <Polarina> CDouble == Double?
11:39:18 <temoto> MissPiggy, i didn't get that, sorry. What about    identity Num x = x   is it valid?
11:39:26 <MissPiggy> :(
11:39:29 <kmc_> you could have a tool or a library to handle compound types for you, but it's not built into FFI
11:39:32 <kmc_> indeed some such tools exist
11:40:02 <kmc_> temoto: no.  Set is not an algebraic type; you can't treat Num as one of its constructors
11:40:24 <MissPiggy> temoto, look  3 : Integer : Set, and () : Unit : Set, for example..
11:40:40 <kmc_> the thing MissPiggy explained with TYPE is a way to create a *new* algebraic type, and also a mapping from it into Set
11:40:41 <MissPiggy> temoto, but you can pattern match only on things such as 3, and (),  you cannot match on Integer or Unit
11:41:11 <MissPiggy> temoto, the reason is in one respect because Set is open (i.e. you can add new types to it)
11:41:13 <temoto> So it's a usual haskell pattern matching.
11:41:21 <MissPiggy> temoto, so far.. it is usual
11:41:25 <kmc_> temoto: sort of.  read on :)
11:41:27 <MissPiggy> but I have shown you an example that is unusual
11:41:45 <kmc_> there are "dot patterns" and "absurd patterns"
11:41:47 <MissPiggy> if you use GADTs you will be at home
11:41:56 <MissPiggy> because my example is actually expressible in Haskell too
11:42:10 <Polarina> Is a ForeingPtr something I do not own, do not control, just want to "see"?
11:42:24 <temoto> I didn't understood GADTs either, because another guy tried to explain it using words 'that's like DT'.
11:42:26 <MissPiggy> (in a slightly different encoding, we have to program eval function into the GADT type.. but this a standard idiom for GADTing)
11:42:29 <kmc_> there is no uniform definition of "own" or "control" in C
11:42:31 <Polarina> Like the first argument to every function in sqlite?
11:42:35 <MissPiggy> GADT is not like DT actually
11:42:42 <kmc_> Polarina: you mean an abstract pointer?
11:42:56 <roconnor> MissPiggy: why do you say that?
11:43:11 <Polarina> kmc_, like a void pointer, points to something you just pass along to another foreign import function and don't know what it is.
11:43:16 <dolio> GADTs are kind of a special case of inductive families.
11:43:22 <MissPiggy> well I am only saying that because I have just wrote a paranthetical that emphasises the difference between them
11:43:24 <kmc_> Polarina: right.  ForeignPtr is not closely related to that concept.
11:43:32 <Polarina> kmc_, what is then?
11:43:33 <kmc_> Polarina: ForeignPtr is like Ptr, except that when the RTS detects that the last copy of the pointer has disappeared from the Haskell program, it will invoke a "finalizer"
11:43:37 <kmc_> which is something you set up
11:43:44 <Polarina> Oh, ok.
11:43:47 <temoto> MissPiggy, how does   f : (T : TYPE) -> (t : eval T) -> (whatever)   reads?
11:43:52 <kmc_> Polarina: this is explained in the FFI chapter of RWH
11:44:00 <Polarina> RWH?
11:44:04 <kmc_> Real World Haskell
11:44:05 <kmc_> @where rwh
11:44:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:44:06 <Polarina> Ah.
11:44:10 <kmc_> free online
11:44:37 <kmc_> temoto: f is a function.  it takes a value of type TYPE (call it T), and a value of type (eval T) (call it t)
11:44:58 <dolio> Although the indices of GADTs aren't inductive types. I guess that may not be what the 'inductive' in inductive families implies.
11:45:01 <kmc_> "f gets some T of type TYPE, and some t of type (eval T)"
11:45:22 <kmc_> (eval T) is an ordinary function application, but it's appearing within a type now
11:45:42 <dolio> Since you can make every GADT in Agda, too. It doesn't limit you to inductive indices.
11:45:42 <kmc_> that's because dependent languages make no syntactic distinction between expressions and types; (:) is a relation between two expressions
11:45:59 <megaTherion> hello
11:45:59 <temoto> kmc_, so it's f :: TYPE -> ("eval T") -> _ in haskell. And "call it x" are aliases for types.
11:46:09 <megaTherion> I wonder if there exist an implementation of galois field operations?
11:46:10 <kmc_> not aliases for types
11:46:15 <kmc_> they're binding names for the *value* passed in at that type
11:46:19 <kmc_> "some T of type TYPE"
11:46:30 <kmc_> some T such that T : TYPE
11:46:39 <MissPiggy> dolio, the game is instead of using (t : T) and getting a type eval f, in haskell with a gadt you make  T eval_f, with the eval function programmed directly into the constructors of T
11:46:57 <MissPiggy> (and you can have different eliminations of the GADT, T eval_f g h ..)
11:47:04 <kmc_> temoto: you have argument binders in the type of the function in addition to its definition
11:47:06 <MissPiggy> you can go quite far with this, generic programming etc..
11:47:18 <dolio> You can do it the Haskell way in Agda, too, though.
11:47:22 <MissPiggy> and of course you can use this (horrible back-bending) idiom in Agda
11:47:30 <Polarina> kmc_, what would be the FFI equivalent to a "void *"?
11:47:32 <kmc_> temoto: that was the case for identity too:   identity : (A : Set) -> A -> A
11:47:35 <kmc_> Polarina: Ptr ()
11:47:37 <dolio> Although you'd have size issues, most likely.
11:47:40 <kmc_> or Ptr AnyTypeYouLike
11:47:42 <Polarina> kmc_, Thanks. :)
11:47:51 <kmc_> Polarina: read the RWH FFI chapter.
11:47:54 <Polarina> kmc_, C doesn't like Ptr SomeType.
11:48:00 <Polarina> kmc_, I am doing that right now.
11:48:03 <kmc_> Polarina: they address abstract pointers like you described
11:48:12 * Polarina reads on.
11:48:20 <kmc_> section "Typed pointers"
11:48:35 * Polarina is reading everything.
11:48:39 <kmc_> :)
11:48:45 <Polarina> :)
11:48:50 <kmc_> they later wrap it into a ForeignPtr and add a finalizer
11:49:04 <temoto> kmc_, what means "and a value of type (eval T)". eval T is a function, how it can be a type? Does it mean the type of what eval T returns?
11:49:14 <kmc_> eval is a function that returns a type
11:49:15 <kmc_> yes
11:49:19 <MissPiggy> but it is unnatural and I suppose that is what I am trying to point out
11:49:21 <kmc_> (eval T) is a function application
11:49:25 <kmc_> eval : TYPE -> Set
11:49:28 <MissPiggy> the difference
11:49:31 <kmc_> therefore eval T : Set
11:49:49 <MissPiggy> eval UNIT = ()
11:49:51 <temoto> kmc_, ah, so there are functions which return types. Like -> in haskell?
11:49:57 <MissPiggy> eval (ARROW f g) = eval f -> eval g
11:49:58 <kmc_> not the type of what (eval T) returns.  the type *that* (eval T) returns
11:49:58 <MissPiggy> for example
11:50:02 <MissPiggy> eval NUM = Integer
11:50:15 <MissPiggy> so clearly 3 : eval Num
11:50:15 <kmc_> temoto: yes.  in DT you can pass and return types as you can pass and return any value
11:50:17 <MissPiggy> oops
11:50:41 <temoto> Okay, i got that, thanks.
11:52:12 <temoto> Like super Num = Set ?
11:53:41 <MissPiggy> super??
11:53:42 <sinelaw> damn, my cabal is broken
11:58:02 <sinelaw> how do i manually remove a cabal package? (for lack of any other option)
11:59:17 <Zao> sinelaw: Unregister it, delete suitable folders.
11:59:17 <burp> ghc-pkg unregister and rm
11:59:26 <Zao> Or if really broken, modify package.conf I guess.
11:59:28 <sinelaw> ok
11:59:55 <sinelaw> Zao unrecognized command, unregister
12:00:37 <sinelaw> where is that package.conf anyway
12:00:44 <kmc_> what about ~/.cabal
12:00:58 <Zao> sinelaw: What version of ghc-pkg?
12:01:22 <sinelaw> Zao, 6.10.4
12:01:46 <Zao> It's in "help" for me, so you're either doing things wrong or are doing things wrong.
12:02:41 <sinelaw> Zao, you're right. thanks
12:04:48 <dmead> hutta
12:04:53 <dmead> ?yow
12:04:53 <lambdabot> Couldn't find fortune file
12:04:56 <dmead> ?yow
12:04:56 <lambdabot> Couldn't find fortune file
12:04:59 <dmead> :/
12:06:36 <Polarina> data Regex = Regex !ByteString   {- What is that exclamation mark? -}
12:06:44 <kmc_> a strict field
12:07:12 <Polarina> What is a strict field?
12:08:30 <roconnor> @src Complex
12:08:30 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
12:08:42 <roconnor> > undefined :+ 0
12:08:43 <kmc_> Polarina: it requires that, when evaluating Regex, we also evaluate its field
12:08:44 <lambdabot>   * Exception: Prelude.undefined
12:08:52 <roconnor> > 0 :+ undefined
12:08:53 <lambdabot>   * Exception: Prelude.undefined
12:08:53 <Polarina> Ok, cool.
12:09:01 <roconnor> (0, undefined)
12:09:06 <roconnor> > (0, undefined)
12:09:07 <lambdabot>   (0,* Exception: Prelude.undefined
12:09:21 <kmc_> you can't have a value where the Regex constructor is already present but the inside is unevaluated
12:09:41 <MissPiggy> temoto was it clear?
12:15:48 <pokoko222> some of you lambda guys have ever translated natural language sentences to logical form in Prolog or something?
12:15:55 <temoto> MissPiggy, what?
12:16:09 <temoto> MissPiggy, i wasn't here
12:16:15 <MissPiggy> temoto you were :P
12:16:16 <MissPiggy> pokoko222, yes
12:16:32 <temoto> MissPiggy, i was on other desktop, didn't read chat :)
12:16:50 <temoto> MissPiggy, you asked what is super, it supposed to return a "parent" type.
12:17:19 <mreh> How would you generate all the euclidian distances between all vertices in an n x m grid?
12:17:47 <kmc_> list comprehension
12:17:50 <MissPiggy> mreh, I guess I would just compute the guassien prime ones
12:17:59 <MissPiggy> then you can multiply up to fill the rest of the grid
12:18:01 <kmc_> haha
12:18:33 <mreh> aah, list comprehensions
12:18:35 <MissPiggy> gaussian*
12:18:40 <monochrom> a mathy and cunning plan
12:18:42 <mreh> I didn't get the joke :X
12:18:42 <temoto> mreh, you're supposed to solve euler on your own ;)
12:18:46 <MissPiggy> it was not a joke :(
12:19:25 <mreh> kmc_ must have stayed up too long again
12:19:32 <kmc_> it's not a joke, it's just awesome
12:19:38 <kmc_> i was laughing at how awesome it is
12:19:52 <mreh> 0_0
12:21:34 * Polarina glares at the usefulness of ForeignPtr.
12:21:45 <temoto> MissPiggy, would this be valid in agda?   super : (A : B) -> B    \n    super A = B     so super Num would be Set and super 3 would be Num etc.
12:21:49 <Zao> Polarina: It's lovely.
12:21:52 <Polarina> :)
12:22:00 <Zao> A bit tricky if you want thread-bound finalizers, but lovely.
12:22:07 <kmc_> temoto: B is not in scope there
12:22:11 <Twey> Like a pair of Wellington boots.
12:22:14 <kmc_> in (x : T) x is a binder but T is not
12:22:22 <Twey> If you have to dive into sewage, you don't want to forget them.
12:22:43 <temoto> How about super : (A : B : Set) ... ?
12:23:31 <mreh> this matrix will be (m x n) x (m x n) wont it
12:23:56 <kmc_> temoto: i believe the syntax is only (A : B)
12:24:25 <kmc_> super : (B : Set) -> (A : B) -> ...
12:24:26 <kmc_> that's valid
12:24:32 <kmc_> that's straightforward polymorphism
12:24:57 <kmc_> if A does not appear in the ... you can even write that type in Haskell
12:24:57 <temoto> kmc_, but then you have to pass 2 values to the function?
12:25:01 <kmc_> yes
12:25:05 <kmc_> you pass a type, and a value of that type
12:26:01 <temoto> I just realized why my super is impossible.
12:27:24 <temoto> No, i didn't.
12:27:38 <temoto> How do you define a function that returns a type of it's argument?
12:27:54 <kmc_> returns the type of its argument?
12:28:12 <temoto> Yes, you said that types are first class values.
12:28:14 <kmc_> f : (A : Set) -> A -> Set;  f T _ = T
12:28:31 <kmc_> it's just "const"
12:28:56 <kmc_> it has to take the type first
12:29:05 <kmc_> there's no implicit polymorphism like in Haskell
12:29:20 <temoto> yeah this makes it very hard to understand
12:29:29 <kmc_> i think it's simpler and more uniform
12:29:35 <temoto> no implicit polymorphism sounds complicating
12:29:49 <kmc_> it just means that polymorphic functions are ordinary functions that take a type argument
12:29:56 <kmc_> like "identity" that we discussed before
12:30:01 <temoto> Like OOP in C, pass a struct everywhere.
12:30:14 <kmc_> well, syntactically, Agda allows implicit parameters
12:30:26 <temoto> Yeah, i've seen {} notation.
12:30:30 <kmc_> and will infer the value when you call, using whatever's in the context
12:30:33 <kmc_> but that's just syntax
12:30:49 <kmc_> it's simpler because the theory doesn't have to accommodate two things, "forall" and "->"
12:38:55 <Peaker> kmc_: but instead, it has to accomodate dependent types
12:39:09 <jmcarthur> Peaker: dependent types are not complicated
12:39:34 <kmc_> it means you need to be willing to do beta-reduction at compile time
12:39:35 <Peaker> jmcarthur: Yeah, maybe not, just highlighting the other side of that coin
12:39:43 <MissPiggy> yes that's what I said before, the reason they are difficult is because they are SO SIMPLE
12:39:51 <kmc_> and either make your language total, or accept that your compiler is non-total
12:39:53 <MissPiggy> compare to something horrifically complex, like C++ or Scala
12:39:59 <MissPiggy> lots of people have no problem with these
12:40:15 <kmc_> "omg DT means your compiler might loop!" is overblown
12:40:24 <kmc_> our C++ and Haskell compilers have been looping for ages
12:40:29 <kmc_> we usually just put a time or stack bound on it
12:40:55 <kmc_> a diverging compiler is still a compile-time error, it's infinitely better than building a program which breaks unexpectedly because your types were too weak
12:41:01 <dolio> Any Church-style lambda calculus is going to have type lambda. Some formalizations just use two different lambdas.
12:41:09 <kmc_> not STLC
12:41:26 <dolio> Yeah, not simply typed. Anything with polymorphism.
12:41:32 <MissPiggy> a diverging compiler is still a compile-time error??
12:41:37 <kmc_> yes
12:41:48 <monochrom> I hook up the compiler to an electrocute chair with the programmer. The programmer gets electric shock until the compiler finishes.
12:41:52 <kmc_> unless you don't check that the compiler finished before copying the binary to your production machine ;P
12:42:44 <dolio> Anyhow, just using small lambda for both is just recognizing that there's no fundamental distinction, and you can capture any sufficiently similar lambda calculus using rules for a pure type system.
12:43:03 <kmc_> pure type system is a generalization of the lambda cube, right?
12:43:08 <dolio> Yes.
12:43:16 <kmc_> any particular paper i should read on that, or should i just google around
12:43:30 <MissPiggy> HENK
12:43:33 <dolio> I'm not sure I ever read a paper on them, per se.
12:43:50 <roconnor> kmc_: isn't the issue more like "omg general recursion in the type level means that you can write arbitrary type casts"?
12:44:10 <kmc_> they're not real casts
12:44:12 <kmc_> but yeah, that's true
12:44:12 <jmcarthur> but surely that wouldn't compile, would it?
12:44:25 <jmcarthur> not with termination
12:44:37 <roconnor> kmc_: an unsound type system is kinda a serious problem.
12:44:50 <roconnor> jmcarthur: it can compile
12:45:05 <roconnor> jmcarthur: with termination
12:45:08 <jmcarthur> how does it result in the ability to write arbitrary type casts?
12:45:45 <roconnor> jmcarthur: fix id : Void
12:46:08 <roconnor> jmcarthur: abort :: Void -> A = B
12:46:18 <roconnor> jmcarthur: cast :: A = B -> A -> B
12:46:29 <roconnor> jmcarthur: thus cast (abort (fix id)) :: A -> B
12:46:49 <MissPiggy> the point of having a strongly normalizing calculus is that you don't have to normalize stuff like 'fix id'
12:47:13 <roconnor> hmm
12:47:23 <roconnor> jmcarthur: I may not have answered you question properly
12:47:25 <MissPiggy> so if you assume that, and it's not the case -- you really with do a C style cast from one type to another
12:47:27 <roconnor> let me rethink
12:47:53 <MissPiggy> (by C style I mean e.g. causes a segfault)
12:48:07 <dolio> You can write that in Haskell, but it doesn't work.
12:48:15 <roconnor> jmcarthur: sorry, ignore my answer
12:48:41 <roconnor> jmcarthur: when executed cast (abort (fix id)) will hang (trying to compute fix id) before doing the unsafe cast.
12:48:51 <roconnor> jmcarthur: I need to use fix id on the type level.
12:49:32 <MissPiggy> umm
12:49:37 <dolio> That would be a problem if Void and A = B could be erased, though.
12:49:41 <MissPiggy> what do I do if someone from this channel is PMing me "hey bitch"?
12:49:53 <kmc_> who is it
12:49:55 <Heffalump> comment about who they are on channel
12:50:01 <MissPiggy> pokoko222
12:50:04 <kmc_> ahahahaha
12:50:07 <kmc_> i fucking knew it
12:50:07 <dolio> Wow.
12:50:25 <kmc_> pokoko222: what in god's name is wrong with you
12:50:52 <Botje> MissPiggy: /ignore pokoko222 ; fixed
12:50:56 <aledge> haha
12:51:04 <aledge>  /squelch
12:51:07 <aledge> :bnet:
12:51:08 <pokoko222> kmc he told me he knows how to translate to logical form and then disapeared
12:51:09 <kmc_> kline
12:51:12 <pokoko222> i thought he lies to me
12:51:22 <kmc_> so you decided a good way to get 1-on-1 help is to say "hey bitch"
12:51:29 <kmc_> you have a massive sense of entitlement
12:51:36 <mauke> smrt
12:51:39 <pokoko222> i thought he jokes with me
12:51:46 <monochrom> perhaps not to get help, but to get even
12:51:49 <blackdog> http://www.reddit.com/r/perl/comments/aokro/on_being_a_bastard/ may be relevant
12:52:28 * Heffalump suggests everyone calm down and HaskellLove refrain from doing that again
12:52:37 <kmc_> i suggest HaskellLove refrain from ever using a computer again
12:52:49 <MissPiggy> geez if I knew it was HaskellLove I would have not said anything to him at all
12:52:54 <kmc_> that'd optimize global utility
12:52:57 <MissPiggy> That guy has been very rude to me in ##algorithms in the past
12:53:12 <kmc_> he is a massive waste of electrons
12:53:12 <MissPiggy> hmm not just there actually, pretty much everywhere I ever run into him
12:53:20 <shapr> I think it's time to remove HaskellLove from #haskell for a few weeks.
12:53:24 <MissPiggy> well he's almost as bad as I was when I was his age :P
12:53:28 <kmc_> 21?
12:53:30 <kmc_> he claims to be 21
12:53:36 <kmc_> though he seems more 15
12:53:39 <MissPiggy> presumably he will learn
12:53:42 * Heffalump is 21...plus a bit
12:53:45 <kmc_> oh i would not count on that
12:53:46 <jmcarthur> ...
12:53:48 <mauke> > 0x21
12:53:49 <MissPiggy> there are some folks in #haskell that do not learn though
12:53:49 <lambdabot>   33
12:54:04 <kmc_> HL is the only person here who has consistently pissed me off
12:54:08 <kmc_> who was not an obvious troll
12:54:28 <monochrom> One day someone said "hey peeps" and I banned him. He PM'ed me to say " "hey peeps" is friendly greeting". Yeah right, if you can stretch it so much that "peeps" is friendly or joking, how about banning as another friendly joking greeting?
12:54:44 <roconnor> darn, I can't remember how to use an inconsistency to get an arbitrary run time type cast.
12:55:07 <mauke> does "peeps" mean something?
12:55:12 <idnar> what?
12:55:14 <roconnor> monochrom: what does peeps mean?
12:55:14 <kmc_> 'people'
12:55:15 <jmcarthur> monochrom: what country you from?
12:55:17 <idnar> last time I checked... yeah
12:55:18 <MissPiggy> monochrom: peeps means people I thought? does it mean something else to you
12:55:30 <kmc_> or, a marshmallow bird you consume at Easter
12:55:44 <Twey> Third-person present of ‘to peep’
12:55:45 <roconnor> kmc_: heh, that's what i thought it meant
12:56:58 <monochrom> I don't know. The cry of a young chicken? Sly look? Small sandpiper?
12:57:30 <monochrom> Or a 4th meaning so vulgar the dictionaries don't dare to mention?
12:59:35 <MissPiggy> okay
12:59:36 <Arnar> uhm.. maybe a silly question, but does anyone know of an example of how to implement a TreeT monad transformer?
13:00:09 <MissPiggy> Arnar, I imagine it would be pretty much exactly the same as ListT,
13:00:11 <dolio> What kind of tree are we talking about?
13:00:20 <c_wraith> Arnar: I could easily implement something that did all the functions...  But proving it is still a monad is tough
13:00:37 <Arnar> so I have a special requirement
13:00:39 <MissPiggy> c_wraith, just induction on the shape of the tree??
13:00:39 <c_wraith> Arnar: especially since ListT doesn't always give a monad.
13:00:41 <MissPiggy> what's hard about it
13:00:44 <MissPiggy> ohh
13:01:02 <kmc_> there's an article on the haskell wiki about ListT
13:01:03 <dolio> There is a better ListT that does work fine.
13:01:25 <Arnar> so, instead of   (Branch t1 t2) >>= f = Branch (t1 >>= f) (t2 >>= f)
13:01:35 <dolio> I'm not sure why the mtl-alike libraries still have the bad ListT anymore.
13:01:42 <Arnar> I want (Branch t1 t2) >>= f = Branch (t1 >>= f) (t2 >>= mzero)
13:02:13 <Peaker> There's the List package by yairchu with a nice ListT iirc
13:02:18 <Arnar> ok..
13:02:22 <Arnar> I'll have a look at ListT
13:02:29 <dolio> Well, that's probably a problem.
13:02:47 <dolio> Because m >>= return = m is a monad law.
13:02:59 <Arnar> hmm
13:03:04 <kmc_> laws were meant to be broken
13:03:05 <jmcarthur> comment in some code at work: "// Adam, don't be gay with this"
13:03:14 <dolio> And Branch l r >>= return = Branch (l >>= return) (r >>= mzero) doesn't look like it's going to hold.
13:03:15 <Arnar> dolio: ok.. so maybe I'm looking at the wrong structure
13:03:43 <Arnar> dolio: basically what I want is to represent computation, which can branch off into a branch that runs simultaneously, but whose value is discarded
13:03:57 <roconnor> jmcarthur: http://lambda-the-ultimate.org/node/2340#comment-35030
13:04:03 <roconnor> this is what I was thinking of
13:04:05 <roconnor> I should reread this
13:04:06 <Peaker> kmc_: :-)
13:04:18 <jmcarthur> oh, type erasure
13:04:23 <jmcarthur> yeah i've read that comment before
13:04:51 <Arnar> dolio: in my dsl "c1; spawn c2; c3"  means run c1, then continue from that state with both c2 and c3, but discard the value of c2
13:04:53 <tARrAScH> ghc-question, is there any way to "include" all files in your working directory when compiling with ghc?
13:04:58 <dolio> roconnor: Your example would work if we were shooting for full proof erasure, then.
13:05:01 <jmcarthur> is that tim sweeney the game developer, btw?
13:05:26 <Arnar> dolio: aaand.. I want to interleave c2 and c3 (which I was planning to do with taking the elts from the tree in level order)
13:05:42 <roconnor> dolio: ya, I didn't do my example right
13:06:46 <c_wraith> jmcarthur: I believe so.  He's definitely a fan of dependent types
13:07:01 <pokoko222> anyone has done natural language translation to logical form in haskell? prolog might be the best for this job, but i am just curious...
13:07:22 <roconnor> dolio: I don't recall how to write a type with a divergent expression without having the corresponding term be divergent.
13:07:24 <jmcarthur> yes. i rather like tim sweeney. ones of the few AAA game guys looking at functional approaches, and he happens to be a really big name as a bonus
13:07:39 <tARrAScH> And even when I include all files manuallt I get an error "Failed to load interface for <module>". Any ideas?
13:08:25 <MissPiggy> roconnor, I think that's impossible?
13:08:57 <MissPiggy> I mean if you use general recursion to implement False
13:09:34 <c_wraith> tARrAScH: would compiling with --make solve your problem?
13:09:54 <roconnor> I didn't even use dependent types in my example, so it was clearly flawed :D
13:09:59 <kmc_> you should usually use --make with ghc
13:10:02 <c_wraith> tARrAScH: it's much more common to compile your main module with --make and let ghc figure out the dependencies
13:10:05 <tARrAScH> c_wraith: What do you know? It does!
13:10:21 <aavogt> @hoogle [a] -> Int -> Maybe a
13:10:22 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:10:22 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:10:22 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
13:10:23 <tARrAScH> c_wraith: hehe, I've only used ghci thus far ^^
13:11:17 <roconnor> MissPiggy jmcarthur dolio: http://www.haskell.org/pipermail/haskell-cafe/2006-September/018248.html
13:11:34 <roconnor> the twiddle is important I guess
13:11:53 <mreh> can I make a matrix with a list comprehension without chopping up a list?
13:12:05 <damd> @faq can haskell do that?
13:12:05 <lambdabot> The answer is: Yes! Haskell can do that.
13:12:16 <roconnor> but I thought we would still have problems in a strict language.
13:12:20 <mreh> s/can/how can
13:12:34 <tensorpudding> you want to make a matrix from the list without chopping it up?
13:12:36 <MissPiggy> coerce (fix id) True :: String
13:12:41 <MissPiggy> that will diverge right?
13:13:07 <mreh> tensorpudding: in one pass
13:13:09 <roconnor> MissPiggy: Conor's point is that it won't diverge under lazy evaluation
13:13:11 <MissPiggy> it's only if proofs (i.e. REFL) get erased, that the evil cast happens IIUC
13:13:22 <MissPiggy> roconnor, Conor is using undefined though
13:13:36 <MissPiggy> which is some weird IO printLN thing
13:13:58 <MissPiggy> ohh
13:13:59 <roconnor> Conor isn't use proof errasure
13:14:02 <roconnor> only laziness
13:14:04 <MissPiggy> I was thinking of a strict pattern
13:14:08 <MissPiggy> but it's an _irrefutable_
13:14:16 <MissPiggy> which is equivalent to proof erasure isn't it?
13:14:27 <kmc_> sure, if the pattern doesn't bind any variables
13:14:34 <roconnor> perhaps equivalenet when the term is never used.
13:14:49 <MissPiggy> yeah like ~Just x is fine if you don't look at x
13:14:56 <edwardk> mreh: something like listArray ((0,0),(5,5)) (concat [[1,2,3,4,5,6],[7,8,9,10,11],... ?
13:14:56 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:16:01 <edwardk> preflex: xseen Alpounet
13:16:02 <preflex>  Alpounet was last seen on freenode/#haskell-blah 23 minutes and 11 seconds ago, saying: what's annoying is that definitions are quite often corecursive
13:16:17 <Alpounet> heh
13:16:24 <Alpounet> geek spotted.
13:17:10 <mreh> set phasers to kill
13:17:26 <mreh> edwardk: I'm looking for a way of making the lists first
13:17:33 <mauke> set your calculators to maths
13:19:07 <MissPiggy> shapr you know I kinda feel like im at the center of everything that goes wrong
13:20:05 <pumpkin> MissPiggy: maybe it's the curly tail that attracts wrongness cause spirals attract people (have you read uzumaki?)
13:20:20 <pumpkin> wow, I sound like 10-year-old
13:20:20 <MissPiggy> no but I saw the film
13:20:23 <MissPiggy> lol
13:20:28 <MissPiggy> really?? I'd not notice
13:20:36 <pumpkin> :P
13:20:43 <pumpkin> I didn't know there was a film
13:20:58 <pumpkin> oh nice
13:21:17 <MissPiggy> actually I have seen the manga .. I had a friend who collected them
13:21:34 <pumpkin> I got hooked on the manga... thought I'd check it out and then couldn't stop reading
13:21:48 <pumpkin> took me a few hours to get through all the volumes
13:21:56 <Ke> not your friend anymore for obvious reasons!
13:22:17 <pumpkin> he did something creepy related to spirals?
13:22:25 <monochrom> No wonder people on the internet are wrong. I use tail recursion and it attracts those people.
13:22:38 <MissPiggy> hehe
13:22:39 <ray> try head recursion instead
13:22:54 <MissPiggy> Ke O_o if you inferred all that then I'm very scared
13:23:32 <monochrom> Yeah, lately I tried head recursion: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5481
13:23:43 <pumpkin> ray: is that auto****atio?
13:23:57 * Polarina hugs >>=
13:24:21 <MissPiggy> > let pro = do pro ; s <- get ; put (True : s) in execState pro []
13:24:21 <Ke> MissPiggy: past tense...
13:24:22 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:24:26 <idnar> pumpkin: more like kissing yourself
13:24:27 * MissPiggy tick!
13:24:35 <pumpkin> :)
13:25:01 <lament> pumpkin: your bowdlerizing fell on deaf ears
13:25:27 <edwardk> I'm sure there is a joke about bottoms and head recursion  here somewhere, but I can't find it.
13:26:03 <lament> just use fix to find the least funny joke
13:26:24 <monochrom> @remember lament just use fix to find the least funny joke
13:26:24 <lambdabot> It is forever etched in my memory.
13:26:30 <idnar> hahaha
13:26:43 <Heffalump> can't you invert the domain and then use fix to find the funniest one?
13:27:04 <Heffalump> anyway, some people find bottoms quite funny
13:28:12 <pumpkin> surely nobody above the age of 12 would find them funny?
13:28:14 * pumpkin giggles
13:28:30 <edwardk> Everyone is always going on about how Nu is the greatest fixed point. What is so great about it anyways?
13:28:49 <mauke> edwardk: have you ever played chrono trigger?
13:28:52 <edwardk> And how do you think that makes Mu feel?
13:29:03 <edwardk> mauke: long time ago
13:29:44 <mauke> All life begins with Nu and ends with Nu... This is the truth! This is my belief! ...At least for now.
13:29:45 <jmcarthur> roconnor: ah thanks for the link
13:30:09 <roconnor> jmcarthur: I'm still not satified I understand the issue :)
13:30:34 <jmcarthur> roconnor: i don't see why that would even type check, personally
13:30:54 <jmcarthur> i mean, Conor should know because he's Conor, but i'm not Conor :P
13:31:30 <lament> Nu are awesome
13:31:41 <lament> they're my role models
13:31:44 <roconnor> jmcarthur: well, undefined can be any time
13:31:46 * lament falls asleep
13:31:58 <roconnor> jmcarthur: in particular it can be the type Eq Bool String
13:32:00 * mauke headbutts lament
13:32:07 <roconnor> any type
13:32:13 <edwardk> mauke: =)
13:32:57 <jmcarthur> roconnor: is the implication that irrefutable patterns would also avoid the type check for the constructor?
13:33:14 <jmcarthur> like, would that technically work without the irrefutable pattern?
13:33:29 <jmcarthur> rather, not work
13:33:49 <jmcarthur> *sigh* i mean would it fail to compile?
13:34:08 <temoto> Elly used to be on this channel last year. Anyone knows why she doesn't come anymore?
13:34:10 <roconnor> jmcarthur: the irrefutable pattern has nothing to do with type checking.
13:34:21 <mreh> > (\n m -> [0..(n-1)] >>= (\n -> [[(n*m)..((n+1)*m-1)]])) 5 5
13:34:22 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]]
13:34:22 <roconnor> jmcarthur: it only affects the run-time behaviour
13:34:25 <mreh> that's what I wanted
13:34:38 <pumpkin> chunkey
13:34:55 <roconnor> jmcarthur: the program without the irrefutable patter would simply try to evaluate undefined and throw an error.
13:34:57 <jmcarthur> roconnor: i was pretty sure about that. but why is it important that the pattern is irrefutable here, then?
13:35:02 <temoto> she was a teacher in some school or college i believe because she told how her students implemented keyboard buffer wrong (with malloc)
13:35:19 <MissPiggy> I think it helps if you consider fix id instead of undefined
13:35:19 <jmcarthur> oh
13:35:28 <MissPiggy> like roconnor wrote originally
13:35:35 <MissPiggy> just because undefined is nebulous and confusing
13:35:37 <roconnor> jmcarthur: with the irreffutable pattern the undefined remains unevaluated, and then the program segfaults (or formats your hard drive as we like to say in the business)
13:35:39 <jmcarthur> okay i see
13:36:34 <MissPiggy> "undefined remains unevaluated" in haskell is because of the irrefutable.. but in a type theory which you /thought/ was strongly normalizing, the justification to not evaluate it is because _everything evaluates to a normal form_
13:36:40 <jmcarthur> but this is essentially a runtime type check, then
13:37:00 <jmcarthur> well, without the irrefutable
13:37:01 <roconnor> jmcarthur: I'm trying to come up with a worse example.
13:37:17 <jmcarthur> i was more curious about the type erasure argument
13:37:47 <roconnor> ya
13:37:52 <jmcarthur> whatever, i'm happy with total languages :)
13:38:01 <roconnor> I'm trying to understand what they are exactly refering to too.
13:42:39 <MissPiggy> jmcarthur, what I said didn't make sense :(
13:42:40 <MissPiggy> ?
13:43:11 <jmcarthur> MissPiggy: it made perfect sense. thank you
13:43:13 <MissPiggy> I am saying that ~ is rougly analougus to proof erasure
13:43:23 <MissPiggy> proof erasure is a different thing than type erasure though
13:43:35 <tARrAScH> is there anything like the wxHaskell repaint that doens't clear the panel, just appends new stuff?
13:43:37 <jmcarthur> you're not as stupid as you say you are
13:43:54 <MissPiggy> oh I actually misread you
13:44:08 <MissPiggy> I thought you said you were still trying to undersatnd it, but you said you were curious about it
13:44:49 <jmcarthur> MissPiggy: yeah, i am more curious about the comments about type erasure in a non-total language from that lambda-the-ultimate link
13:45:20 <MissPiggy> hm?
13:45:22 <MissPiggy> what link
13:45:34 <MissPiggy> ah I found it
13:46:21 <MissPiggy> "so that the runtime can erase types whose computation is conservatively known to be total" -- that's a bit odd, not sure I understand what he means
13:46:41 <jmcarthur> "Any dependent-typed expression that may diverge must be fully evaluted at runtime, otherwise the type system is unsound."  ..  type erasure wouldn't actually prevent this, would it?
13:47:49 <edwardk> jmcarthur: at least if it can diverge in a term that can be used dependently. you can partially evaluate them anyways
13:48:41 <roconnor> edwardk: how do you avoid not having the unsound term in question simply diverge?
13:49:38 <edwardk> roconnor: there is always Lennart's answer of 'just run it for a while and reject it if it takes too long' ;)
13:50:01 <jmcarthur> see that sounds reasonable enough to me
13:50:30 <jmcarthur> :P
13:50:33 <edwardk> soundness is overrated. ;)
13:51:07 <roconnor> edwardk: but the way I read this quote is that there exists a term x with type X that type checks in a finite time and (all) normalization paths for x eventually have a run-time type error.
13:51:47 <edwardk> its right up there with 'progress' and 'preservation', used by computer scientists to scare their childen when telling ghost stories around a campfire. =)
13:52:15 <edwardk> roconnor: honestly, i missed the hook of this discussion, so i'm not sure what statement you're referring to
13:52:37 <roconnor> edwardk: soundness is the only thing that stands between our programs and a formated hard drive.
13:53:05 <opdolio> I'm not sure I believe type erasure is unsound without full evaluation of types at runtime.
13:53:23 <opdolio> Otherwise some GHC extensions would probably be in trouble.
13:53:33 <opdolio> More trouble than they already are, at least.
13:53:44 <edwardk> what reference to type erasure spawned this discussion anyways? so i can be on the same page
13:53:54 <roconnor> opdolio: ghc doesn't have full dependent types with general recursion at the type level.
13:54:13 <roconnor> edwardk: the quote is "Any dependent-typed expression that may diverge must be fully evaluted at runtime, otherwise the type system is unsound."  ..  type erasure wouldn't actually prevent this, would it?
13:54:21 <dolio> If you enable undecidable instances for type families, I suspect you get general recursion at the type level.
13:54:31 <roconnor> edwardk: the quote is from http://lambda-the-ultimate.org/node/2340#comment-35030
13:54:50 <mreh> gridDistanceMatrix (rows,cols) = do
13:54:51 <mreh>   x <- [0..rows*cols-1]
13:54:51 <mreh>   y <- return [0..rows*cols-1]
13:54:51 <mreh>   return (map (euclidianDist (rows,cols) x) y)
13:54:54 <mreh> is this nice?
13:55:00 <MissPiggy> mreh,I prefer my way! :P
13:55:34 <mreh> I did it myyyy waaaaaay
13:55:41 <mreh> MissPiggy: what way?
13:55:52 <dolio> Is the mixing of terms and types going to defeat the soundness of the types more than general recursion in just the types?
13:56:02 <edwardk> okay, that pretty much fits with my understanding of the common wisdom about dependently typed languages, typechecking requires evaluation, so you lose the phase distinction generally
13:56:16 <MissPiggy> you lose the phase distinction?
13:56:19 <MissPiggy> what phase
13:56:30 <edwardk> MissPiggy: between compilation and runtime
13:56:44 <kmc_> phase distinction is overrated
13:56:46 <roconnor> edwardk: that isn't the case
13:56:49 <lpsmith> what's a monoid with a "pure"  but not an "<*>" called?
13:57:00 <kmc_> you mean a functor?
13:57:03 <kmc_> that'd be a pointed functor
13:57:15 <Vanadium> Pointed functors are monoids?
13:57:17 <lpsmith> no, it's not a functor
13:57:17 <edwardk> roconnor: oh?
13:57:17 <cheater3> how is a monoid a functor?
13:57:22 <roconnor> edwardk: at least when we have terminating functions everywhere, the type checking and evaluation phases are totatly distinct
13:57:24 <kmc_> monoids don't have "pure" or "<*>"
13:57:36 <kmc_> so i didn't follow your question and substituted a different one ;)
13:57:38 <jmcarthur> how can it have pure if it's not a functor?
13:57:44 <roconnor> edwardk: separated by the type erasing stage
13:57:56 <Dashkal> Newb question: Where do I look for simple (socket based) networking?
13:58:03 <roconnor> edwardk: you can define a function nat -> bool with all sorts of intermediate dependently type functions.
13:58:08 <roconnor> edwardk: then you can type check it
13:58:08 <edwardk> roconnor: yes.
13:58:15 <kmc_> Dashkal: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/network/Network.html
13:58:15 <roconnor> edwardk: then you can compile it to scheme
13:58:20 <nominolo_> Dashkal: network or network-bytestring
13:58:23 <kmc_> Dashkal: it imports Network.Socket which is lower level
13:58:29 <roconnor> edwardk: then you can run it on 0 and see what it results in.
13:58:39 <roconnor> or you can run it on 1
13:58:41 <lpsmith> ok,  maybe a bit more explictly,  what's a monoid "m a" that has a function (analogous to pure) that is "a -> m a"
13:58:48 <kmc_> Dashkal: it's also very helpful to understand forkIO-based concurrency, if you want to handle multiple network connections
13:58:51 <edwardk> roconnor: the statement i made was meant in the context of the post.
13:58:55 <Dashkal> Ahh, sweet.
13:58:58 <aledge> my guess is a type that is an instance of both monoid and functor?
13:59:04 <kmc_> Dashkal: btw, Real World Haskell covers some of these things
13:59:06 <edwardk> "  You've made a very important point here: type erasure requires totality. Any dependent-typed expression that may diverge must be fully evaluted at runtime, otherwise the type system is unsound."
13:59:06 <Dashkal> *nods* I'm about to write myself a "hello, world" network app to get a handle on it
13:59:34 <edwardk> which I can't find any particularly big issue with
13:59:42 <lpsmith> Specifically,  say we define  data Range a = RangeEmpty | Range a a,   with mappend (Range a b) (Range x y) = Range (min a x) (max b y)
13:59:54 <roconnor> edwardk: sure, the claim being made with that quote seems to be that with general recursion and dependent types you lose the phase distinction.
14:00:02 <jmcarthur> edwardk: but why couldn't the type checker itself diverge instead?
14:00:13 <roconnor> edwardk: but I don't really see why yet.
14:00:14 <lpsmith> But there is also a useful "pure-like" or "return-like" function,   pure x = Range x x
14:00:38 <edwardk> roconnor: you do, if you want decidable rather than semi-decidable typechecking
14:00:44 <kmc_> lpsmith: is that related to your Monoid instance, though?
14:01:04 <edwardk> roconnor: the compiler can only spin its wheels for so long, unless you want to allow it to not terminate as well
14:01:10 <lpsmith> sure
14:01:12 <roconnor> edwardk: well, if you have general recursion at the type level clearly you luse decidable typechecking
14:01:22 <lpsmith> I think
14:01:24 <roconnor> edwardk: but the claim being made is stronger I think.
14:01:46 <edwardk> that was why i referenced Cayenne's philosophy
14:02:11 <roconnor> what is Cayenne's philosophy?
14:02:19 <jlouis> pray!
14:02:54 <edwardk> roconnor: 'just try to evaluate it, if it takes too long, then complain' ;)
14:03:07 <jmcarthur> roconnor: maybe the claim should have been qualified with "decidable typechecking"?
14:03:25 <roconnor> edwardk: if it takes to long then complete isn't unsoundness.
14:03:33 <roconnor> *then complain
14:03:53 <lpsmith> hmm,  you could make it a functor in pure math,  but computationally that gets very hairy
14:04:50 <edwardk> roconnor: correct, i was merely pointing out it was a fairly pragmatic approach to the issue of permitting general recursion in a dependently typed language.
14:05:12 <jmcarthur> lpsmith: why does it get hairy? your Range type looks like a reasonable functor to me
14:05:29 <roconnor> edwardk: ok
14:05:57 <edwardk> roconnor: i guess i don't see your point. you seem to be indicating that you can somehow support general recursion in a dependently typed language and maintain a strong phase distinction, but you seem to be hung up on some detail of his argument i just don't see.
14:05:58 <jmcarthur> lpsmith: it even looks like a reasonable Applicative
14:06:00 <lpsmith> jmcarthur, you'd expect it to obey the laws of "range";   e.g.  it's easy to make a functor restricted to monotonic functions
14:06:13 <jmcarthur> oh i wasn't paying attention to what it actually *was* :P
14:06:20 <lpsmith> lol
14:06:21 <lpsmith> it's ok
14:06:49 <dolio> edwardk: He claimed that a dependently typed language with general recursion and type erasure admitted unsafeCoerce.
14:07:33 <lpsmith> I mean,  you'd kind of expect   fmap sin (Range 0 pi) == Range 0 1,    whereas (Range (sin 0) (sin pi)) =  Range 0 0
14:08:41 <lpsmith> jmcarthur, ^
14:09:42 <jmcarthur> lpsmith: maybe if we had constraint families it could be done. could have a type class for monotonic functions and use it as a constraint in the Functor instance for range
14:10:17 <jmcarthur> actually that doesn't make perfect sense
14:10:24 <edwardk> isn't it more that you just never get around to evaluating that coercion because you can't erase it? ahh gotta go
14:10:36 <lpsmith> that's ok, I'm not sure I'm making perfect sense at the moment either :)
14:11:45 <mreh> @hoogle Double -> Int -> String
14:11:45 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
14:11:45 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
14:11:45 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
14:11:56 <mreh> how does one format a double?
14:11:57 <lpsmith> Also,  if you were expecting "Range" to be a functor on Doubles,  how would you treat discontinuous functions?
14:12:10 <lpsmith> They would be potentially problematic
14:12:20 <mauke> mreh: printf
14:13:20 <monochrom> @type showFFloat
14:13:21 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
14:13:42 <mauke> if only showGFloat wasn't so broken
14:13:50 <monochrom> > showFFloat (Just 30) (pi :: CReal) ""
14:13:51 <lambdabot>   "* Exception: CCeal.floatRadix
14:13:59 <lpsmith> jmcarthur, actually,  that might work;  define a type of functors that only work on monotonic functions,   then mark functions as monotonic (somehow)
14:14:11 <mauke> heh, CCeal
14:14:21 <monochrom> > showFFloat (Just 30) (pi :: Double) ""
14:14:22 <lambdabot>   "3.141592653589793000000000000000"
14:14:37 <jmcarthur> lpsmith: the marking functions as monotonic part is where i get lost
14:14:59 <jmcarthur> could just put burden of proof on the programmer, but that seems... less than ideal
14:15:07 <lpsmith> oh well, that's well beyond what I'm actually trying to do;  and come to think of it I can't think of any nice algebraic properties between mappend and \x -> Range x x either,  particularly
14:15:08 <monochrom> @type showGFloat
14:15:09 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
14:15:20 <lpsmith> (off the top of my head anyway)
14:15:44 <monochrom> > showGFloat (Just 30) (pi :: Double) . showGFloat (Just 30) (pi^10 :: Double) $ ""
14:15:45 <lambdabot>   "3.14159265358979300000000000000093648.047476083000000000000000000000"
14:15:59 <mauke> > showGFloat Nothing pi ""
14:16:01 <lambdabot>   "3.141592653589793"
14:16:09 <mauke> hmm
14:16:37 <Polarina> 3.14159265358979323846264338327950288419716939937510
14:16:50 <Polarina> Memorize that and you'll have no problems. :)
14:17:14 <mauke> ah, here's the bug
14:17:15 <roconnor> jmcarthur: http://www.reddit.com/r/dependent_types/comments/axar7/any_dependenttyped_expression_that_may_diverge/
14:17:22 <mauke> > showGFloat "%g" 1 ""
14:17:23 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
14:17:23 <lambdabot>         again...
14:17:30 <lpsmith> I have it memorized up to 4338
14:17:30 <mauke> > showGFloat Nothing 1 ""
14:17:31 <lambdabot>   "1.0"
14:17:39 <mauke> should be "1"
14:17:41 <tARrAScH> > 'y':'o':'u':'f':'a':'i':'l':' ':'^':'^':[]
14:17:41 <lambdabot>   "youfail ^^"
14:17:59 <tARrAScH> lol, just bored ;p
14:18:41 <burp> > '':[]
14:18:42 <lambdabot>   <no location info>:
14:18:42 <lambdabot>      lexical error in string/character literal at chara...
14:18:50 <tARrAScH> night guys
14:18:54 <burp> aw, yes ;)
14:23:47 <monadic_kid> can anyone think of a more elegant way to achieve this (last answer): http://translate.google.co.uk/translate?hl=en&sl=ja&u=http://d.hatena.ne.jp/keqh/20081222/p1&ei=fqVoS5fsL8mPjAeyq-3MBw&sa=X&oi=translate&ct=result&resnum=3&ved=0CA0Q7gEwAg&prev=/search%3Fq%3Dhaskell%2BSDL_GetKeyState%26hl%3Den%26client%3Dfirefox-a%26rls%3Dorg.mozilla:en-US:official%26hs%3DpfR
14:26:04 <monadic_kid> sorry about the weird link, the origional page is in japanese
14:30:49 <mauke> *> ""++ printf "%g" 1.0
14:30:49 <mauke> "1"
14:30:53 <mauke> success.
14:31:27 * monochrom selects to translate to Chinese and gets a good laugh. "IO" becomes "Jupiter Satellite One".
14:31:38 * hackagebot upload: hlint 1.6.18 - Source code suggestions (NeilMitchell)
14:34:09 <Twey> monadic_kid: I can't see that… where's the original?
14:34:28 <Cale> http://d.hatena.ne.jp/keqh/20081222/p1
14:34:35 <monadic_kid> http://d.hatena.ne.jp/keqh/20081222/p1
14:36:29 <Twey> Oh, right
14:36:35 <Twey> I included the &ei= bit by mistake
14:37:00 <monadic_kid> just noticed the code in google translate comes out a bit messed up
14:42:02 <monadic_kid> well I came up with another way, StorableArray, and returning a lambda which is like Monad.when and capture the storable array
14:42:42 <monadic_kid> so no unsafePerformIO
14:42:55 <monadic_kid> but still need to use unsafeForeignPtrToStorableArray
14:43:50 <monadic_kid> seems like i'm just complicating things for no good reason
14:47:38 <MissPiggy> test
14:50:27 <Polarina> Is there a function of type (Eq a) => a -> [a] -> Int, that counts the number of equal values of a in [a]?
14:50:40 <mauke> @hoogle (Eq a) => a -> [a] -> Int
14:50:41 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
14:50:41 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
14:50:41 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
14:50:46 <monochrom> No.
14:50:52 <Zao> sort, group, pray?
14:50:54 <kmc_> > \x -> length . filter (== x)
14:50:55 <lambdabot>   {()->{[]->0;[()]->1;[(),()]->2;[(),(),()]->3}}
14:51:01 <mauke> :t (length .) . elemIndices
14:51:01 <kmc_> :t \x -> length . filter (== x)
14:51:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
14:51:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
14:51:06 <Zao> Oh, a single element, not all of them.
14:51:28 <Polarina> Zao, :P
14:51:38 <idnar> @pl \x -> length . filter (== x)
14:51:38 <lambdabot> (length .) . filter . (==)
14:52:06 <Polarina> kmc_, thanks.
14:53:08 * Polarina is preparing for a programming competition. :)
14:55:15 <kmc_> @check \xs -> xs == reverse xs
14:55:17 <lambdabot>   "OK, passed 500 tests."
14:55:41 <mreh> wut?
14:55:46 <Polarina> lol
14:55:52 <kmc_> every list is its reverse!
14:56:01 <c_wraith> the arbitrary instance for lists produces lists with all elements the same
14:56:15 <Polarina> @check [1, 2, 3] == [3, 2, 1]
14:56:15 <lambdabot>   "Falsifiable, after 0 tests:\n"
14:56:21 <Polarina> lambdabot, lies!
14:56:25 <jmcarthur> it's defaulting to [()]
14:56:42 <Polarina> @check let a = [1,2,3] in a == reverse a
14:56:43 <lambdabot>   "Falsifiable, after 0 tests:\n"
14:56:49 <c_wraith> even if you used String, it produces "", "a", "aa", etc
14:56:59 <mreh> do { (evalRandIO (sequence . replicate 2500 . randomPermTree $ 2500)) `seq` return () }
14:56:59 <jmcarthur> @check \xs -> (xs :: [Int]) == reverse xs
14:57:00 <lambdabot>   "Falsifiable, after 3 tests:\n[-2,3]\n"
14:57:03 <mreh> what am I doing wrong?
14:57:13 <jmcarthur> @check \xs -> (xs :: String) == reverse xs
14:57:13 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\1066813\\682673\\1005785\"\n"
14:57:18 <mauke> @check ap (==) reverse :: [String] -> Bool
14:57:19 <lambdabot>   Couldn't match expected type `[GHC.Base.String] -> GHC.Bool.Bool'
14:58:09 <jmcarthur> @check \xs -> (xs :: [()]) == reverse xs
14:58:10 <lambdabot>   "OK, passed 500 tests."
14:58:38 <aavogt> @scheck (<10) . length
14:58:39 <lambdabot>   "Falsifiable, after 18 tests:\n[(),(),(),(),(),(),(),(),(),()]\n"
14:58:46 <aavogt> @scheck (<100) . length
14:58:47 <lambdabot>   "Falsifiable, after 238 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:58:58 <mreh> > do { x <- [1..] ; return 1 }
14:58:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:59:09 <aavogt> @undo  do { x <- [1..] ; return 1 }
14:59:09 <lambdabot> [1 ..] >>= \ x -> return 1
14:59:10 <mreh> erm
14:59:13 <jmcarthur> > 1 <$ [1..]
14:59:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:59:27 <aavogt> @@ @unpl @undo  do { x <- [1..] ; return 1 }
14:59:28 <lambdabot>  (([1 ..]) >>= \ x -> return 1)
14:59:30 <mreh> how do I force eval with seq?
14:59:47 <Alpounet> > undefined `seq` 4
14:59:48 <lambdabot>   * Exception: Prelude.undefined
15:00:06 <c_wraith> mreh, generally with something like let x = ... in x `seq` f x
15:00:12 <aavogt> > seq`seq`seq`seq`()
15:00:13 <lambdabot>   ()
15:00:22 <mauke> hot seqs
15:00:30 <Alpounet> heh
15:00:37 <jmcarthur> :t seq
15:00:38 <lambdabot> forall a t. a -> t -> t
15:00:52 <idnar> c_wraith: isn't that just f $! ... ?
15:01:20 <c_wraith> idnar: it is.  But that's also the general form of using seq
15:01:22 <jmcarthur> > fix seq 5
15:01:23 <lambdabot>   5
15:01:43 <jmcarthur> o_O
15:02:46 <jmcarthur> should that have worked
15:02:47 <jmcarthur> ?
15:02:58 <dolio> I'd say it's mildly unexpected.
15:03:30 * MissPiggy has just had a change of paln
15:03:31 <MissPiggy> plan
15:03:50 <MissPiggy> instead of full blown HTML, just normal text with $$ for LaTeX should be nice
15:04:03 <mreh> i'm just trying to get GHCi to evaluate something without printing it
15:04:13 <kmc_> foo `seq` ()
15:04:27 <kmc_> that evaluates to weak head normal form
15:04:32 <c_wraith> mreh: seq only evaluates to WHNF, of course.
15:04:43 <kmc_> to force deeper you need the ability to walk the tree
15:04:45 <kmc_> @hoogle rnf
15:04:45 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
15:04:51 <mreh> can't... recall... functional programming classes...
15:04:53 <kmc_> NFData class provides this ability
15:04:59 <aavogt> climb the tree
15:05:02 <Zao> mreh: Mine used Standard ML.
15:05:02 <kmc_> weak head normal form means the outside is a lambda or a constructor
15:05:10 <Zao> mreh: So I've tried to forget the syntax.
15:05:13 <kmc_> the stuff inside could be reducible
15:05:22 <kmc_> (\x -> 3) and (Just 3) are both whnf
15:05:28 <kmc_> ((\x -> 3) 6) is not; it's reducible
15:05:40 <mreh> kmc_ yeah, the data structures inside aren't strict
15:05:43 <kmc_> (Just ((\x -> 3) 6)) is whnf, even though the inside is reducible
15:06:14 <kmc_> you can also do (show foo) `seq` ()
15:06:29 <kmc_> if you want something closer to the amount of eval that would happen by printing it
15:06:38 <kmc_> but that too only evaluates the first cons cell of the show string
15:06:40 <c_wraith> Um.  that will only force the first : of the string
15:06:54 <aavogt> (length $ show foo) `seq` ()
15:07:06 <kmc_> ideally you'd force the chars too, not just the spine
15:07:11 <idnar> that will only force the spine, I think
15:07:11 <kmc_> rnf $ show foo
15:07:12 <idnar> yeah.
15:07:16 <kmc_> that should do nicely
15:07:34 <kmc_> in fact, you could write a hackish (Show a) => NFData a instance that way
15:07:45 <aavogt> overlap some?
15:07:50 <c_wraith> a bit
15:08:15 <kmc_> hehe
15:08:42 <c_wraith> I do wish contexts were used in instance resolution.  Though that wouldn't help much with that case.
15:09:14 <mreh> learning haskell is like learning maths
15:10:09 <monochrom> learning haskell is like learning.
15:10:27 <MissPiggy> learning haskell is like learning MONADS
15:10:36 <damd> WHAT ARE MONADS
15:10:37 <damd> THEY ARE SO WEIRD
15:10:40 <damd> PLZ GIVE TUTORIAL
15:10:49 <c_wraith> damd: monads are like movies.
15:10:56 <monochrom> everything is like everything. tautology.
15:11:04 <MissPiggy> monads are like so last year
15:11:13 <idnar> tautology is like tautology
15:11:21 <jlouis> tautology
15:11:34 <Polarina> damd, monads are old.
15:11:37 <mauke> life is like an analogy
15:11:45 <idnar> can you study to be a tautologist?
15:12:02 <mreh> yes and no
15:12:06 <mauke> can you teach me how to be an autodidact?
15:12:09 <monochrom> @faq can you study to be a tautologist?
15:12:10 <lambdabot> The answer is: Yes! Haskell can do that.
15:12:26 <mreh> i quite liked my reply
15:12:40 <monochrom> can you teach all and only those who don't teach themselves?
15:13:29 <monochrom> or must you settle with teaching all and only those who are taught by all and only those who teach all and only those you teach?
15:13:48 <c_wraith> monochrom, have you been reading the time cube?
15:14:00 <idnar> c_wraith: is that the one with four sides?
15:14:02 <monochrom> No. I've been reading Galois connections.
15:14:10 <c_wraith> idnar: yes.  it's an amazing cube.
15:14:14 <MissPiggy> Galois connections??
15:14:17 <mauke> can you educate me stupid?
15:14:33 <idnar> c_wraith: heh
15:14:37 <MissPiggy> I'm reading about module
15:14:46 <MissPiggy> it's an easy version of vector space but then tensor is harder
15:14:51 <jlouis> MissPiggy: yup, funny things which actually have formal meaning in category theory
15:15:00 <MissPiggy> ohhh category theory
15:15:04 <MissPiggy> I thought it was algebra
15:15:11 <c_wraith> I thought it sounded like a blog
15:15:24 <jlouis> Galois Connections prime example stems from classical algebra yes
15:17:09 <jlouis> monads are like blogs.... their explanations breed like rabbits!
15:18:38 <monochrom> For a set of people X, define f X = { people y | every x in X teaches y }, g X = { people y | y teaches every x in X }.  Then f,g are Galois-connected, and f.g.f $ X = f X, for example f.g.f $ {you} = f {you}, the statement I made.
15:19:38 <monochrom> timecube cannot do that.
15:21:20 <monochrom> 1 little, 2 little, 3 little tutorials
15:21:32 <monochrom> 5 little, 8 little, 13 little tutorials
15:21:52 <damd> i see a pattern...
15:22:11 <augur> you're missing two steps there
15:22:17 * mauke sees your pattern and raises an eyebrow
15:22:19 <monochrom> Yeah, what jlouis said, "explanations breed like rabbits"
15:22:49 <damd> looks somewhat padovan
15:22:50 <jlouis> perhaps one should be familar with the history of that sequence :)
15:22:51 <monochrom> I omit those steps for maximum surprise in the second line.
15:23:07 <damd> okay, it really wasn't the padovan sequence
15:24:10 <monochrom> It doesn't quite matter where I start does it? It only matters I have enough to continue and I do continue.
15:24:12 <mauke> I'd like to see you breed one rabbit
15:24:39 <jlouis> lambdabot does cake. It needs to do rabbits too!
15:25:26 <monochrom> Like rabbit!!19 = "3 parts water, 1 part protein"?
15:28:32 <MissPiggy> um
15:28:49 <MissPiggy> so what's a really really simple haskell web server I can use?
15:29:55 <c_wraith> doing simple stuff from happstack isn't hard
15:30:14 <MissPiggy> but is there one that's small
15:30:46 <ddarius> MissPiggy: You could use HWS(-WP)
15:32:20 <MissPiggy> www.mdstud.chalmers.se/~md9ms/hws-wp is down :(
15:40:24 <Polarina> High-performance server process written in Haskell! :D
15:57:16 <MissPiggy> http://www.thenewsh.com/~hws/
16:01:22 <Polarina> Is there a better library for networking than the module Network?
16:01:40 <Veinor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16973#a16973
16:01:50 <Veinor> do I actually need -XFlexibleInstances for this, or am I doing it wrong?
16:02:08 <c_wraith> Polarina: There's the lower-level part of Network
16:02:19 <Polarina> Hmm.. Maybe.
16:02:36 <Polarina> Just "Thanks"
16:03:26 <Polarina> The lower-level Network.Socket doesn't seem to support IPv6 very well or at all.
16:04:28 <Polarina> It doesn't seem to support IPv6 at all.
16:04:53 <Veinor> hmmm... I know what I'm trying to do should be possible :/
16:07:09 <Philonous> Veinor: I think you need UndecidableInstances
16:07:32 <Philonous> Veinor: The class constraint is not smaller than the instance head
16:07:50 <Veinor> hm.
16:08:05 <Veinor> so I have to use that to say 'all RealFracs are also AxisValues'?
16:08:17 <Philonous> Yes
16:08:37 <Veinor> that's annoying.
16:08:43 <Veinor> maybe I'm thinking about the problem wrong, though.
16:09:44 <Polarina> Is there some higher-level, yet flexible, networking library?
16:10:07 <Philonous> Veiner Why do you have the class in the first place? You could just say values :: (RealFrac a) => Integer -> a -> a -> [a]>
16:10:08 <Veinor> Philonous: basically, I'm trying to capture the notion of 'this type is a valid thing to plot over'
16:10:29 <Philonous> Oh ok
16:10:42 <Veinor> which means that you have to be able to take a start, an end, and an integer, and produce that many values between the start and the end
16:11:30 <Philonous> Veinor: You could add a newtype
16:11:45 <Veinor> ?
16:12:05 <monochrom> Polarina: there are many on hackage. for example I use HTTP often.
16:12:53 <Polarina> I want something that does UDP, dual-stacks IPv4/IPv6 (I need to specify which if I do not want both), bind to address for listening, bind to address for connecting.
16:12:55 <Polarina> Just about that.
16:12:56 <Philonous> newtype Foo a = Foo a; instance RealFrac a => Axis (Foo a)
16:13:18 <Philonous> AxisValue even
16:13:28 <Veinor> hm...
16:13:57 <monochrom> I lack ability to perform computer search engine functions.
16:14:12 <Philonous> Veinor: Or you could just bite the bullet and {-# LANGUAGE UndecidableInstances #-}
16:14:16 <Twey> Damn
16:14:21 <Twey> Time to upgrade to monochrom 2.0
16:14:23 <Veinor> eh, I think I'll do that.
16:14:35 <Veinor> wheeee
16:14:56 <Philonous> Veinor: Though I think you will have to add FlexibleInstances as well (not sure though)
16:15:05 <Veinor> yeah.
16:15:46 <endojelly> Philonous, hmm, why does the newtype help?
16:16:07 <endojelly> ah ok I think I get it
16:16:31 <endojelly> can't have just a type variable as an instance declaration, can you...
16:18:02 <Philonous> endojelly: You need FlexibleInstances for that, yes
16:18:44 <endojelly> Philonous, but why also UndecidableInstances?
16:18:49 <Philonous> endojelly: But additionally you could have instance Foo x => Bar x and instance Bar x => Foo x, so type checking would loop indefinitely
16:19:17 <Philonous> That's why the compiler asks you to keep the constraint smaller than to instance head, so termination is guaranteed
16:19:50 <endojelly> Philonous, ah. so Foo x => Bar x x would be okay?
16:20:01 <endojelly> with FlexibleInstances but without UndecidableInstances
16:20:27 <Philonous> I don't think so, because x in Bar x x is still not structurally smaller than x in Foo x
16:20:35 <Philonous> You could still say instance Bar x x => Foo x
16:20:41 <Philonous> With the same problem
16:20:43 <endojelly> hm, right
16:23:58 <Philonous> Veinor: Otoh "instance AxisValue a" overlaps with everything (constraints are checked after instance selection), so you will need OverlappingInstances and work hard to make that work
16:24:18 <endojelly> Philonous, (Foo a, Foo b) => Bar a b ?
16:26:03 <endojelly> hmm. I could still day Bar a b => Foo a and later Bar a b => Foo b.
16:26:16 <Philonous> Aye
16:26:43 <endojelly> according to the record, this one's ok: class Functor (m k) => FiniteMap m k where
16:29:32 <endojelly> anyway, off to bed, n8
16:29:37 <Philonous> N8
16:32:51 <Philonous> endojelly: Where did you see this?
16:33:40 <Philonous> endojelly: Ah wait, this is a class, not an instance!
16:37:31 <MissPiggy> well I'm kind of tripped up at the starting pate
16:37:33 <MissPiggy> gate*
16:37:45 * Pseudonym is trying to visualise a starting pate
16:38:10 <Pseudonym> "Pate" as in head or as in meat and fat paste?
16:38:22 <MissPiggy> fat paste
16:38:25 <drhodes> is there a template-style generic language which implements type families?
16:40:52 <MissPiggy> http://hackage.haskell.org/package/httpd-shed
16:40:53 <MissPiggy> that looks good
16:41:21 <MissPiggy> A trivial web server.  <-- sounds like something I might be able to handle
16:41:47 <Gracenotes> hm... is there anything on Hackage with nice abstract algebra models?
16:42:01 <Pseudonym> You mean like category-extras?
16:42:05 <MissPiggy> Gracenotes, jmcarthur has a decent looking setup too
16:42:06 <Gracenotes> there is one package in particular I'm thinking of, forget what it's called
16:42:07 <pumpkin> numeric-prelude is as close as you'll get
16:42:11 <pumpkin> but it's got HT naming
16:42:16 <Gracenotes> well, what are the names
16:42:21 <pumpkin> C and T
16:42:28 <Gracenotes> I mean, jmcarthur's :o
16:42:47 <pumpkin> I wrote several algebra libraries too, but few have survived
16:42:57 <pumpkin> I don't think jmcarthur released his
16:43:44 <c_wraith> his is on patch-tag
16:43:54 <c_wraith> as part of the alt-stdlib project
16:44:11 <Pseudonym> Sounds like it's time to write one.
16:44:37 <pumpkin> it's surprisingly hard with haskell's mechanisms
16:44:46 <Pseudonym> Yeah, I know.
16:44:47 <pumpkin> my most recent one used reify
16:45:01 <pumpkin> I really want a more advanced module system for it
16:45:19 <c_wraith> jmcarthur used constraint families.
16:45:44 <MissPiggy> reify?
16:45:46 <MissPiggy> what is that
16:46:26 <ddarius> There's DoCon, but it is not on Hackage, and I'm not really sure how maintained it is.
16:46:42 <pumpkin> MissPiggy: http://hackage.haskell.org/packages/archive/reflection/0.3.0/doc/html/Data-Reflection.html
16:46:51 <MissPiggy> if anyone wants to collab with me on making a simple algebra system btw just tell me
16:47:03 <MissPiggy> and by simple I mean like all it needs to do is homework
16:47:03 <Pseudonym> http://www.haskell.org/haskellwiki/Reified_type "To "reify" something is to take something that is abstract and regard it as material."
16:47:59 <pumpkin> MissPiggy: normally I'd say yes, but I'm pretty busy this term and am thus even more unreliable than usual :P
16:48:13 <Pseudonym> pumpkin, do you know if that is GC-friendly or not?
16:48:25 <pumpkin> Pseudonym: I don't see why it wouldn't be
16:48:53 <pumpkin> Pseudonym: it's not like we have explicit reference counting that it works around
16:49:01 <Pseudonym> The original paper noted that using their most powerful technique, values aren't GC'd.
16:49:05 <mreh> @hoogle Ordering -> Ordering
16:49:05 <lambdabot> Prelude pred :: Enum a => a -> a
16:49:05 <lambdabot> Prelude succ :: Enum a => a -> a
16:49:05 <lambdabot> Prelude id :: a -> a
16:49:11 <MissPiggy> I am just thinking about effort-duplication and stuff
16:49:18 <mreh> is there a function that reverses an ordering?
16:49:24 <pumpkin> Pseudonym: interesting, I hadn't looked. You should ask edwardk
16:49:29 * Pseudonym nods
16:49:36 <MissPiggy> :t negate :: Ordering -> Ordering
16:49:37 <lambdabot>     No instance for (Num Ordering)
16:49:37 <lambdabot>       arising from a use of `negate' at <interactive>:1:0-5
16:49:37 <lambdabot>     Possible fix: add an instance declaration for (Num Ordering)
16:49:41 <MissPiggy> oh that's too bad
16:49:49 <MissPiggy> @instances Ordering
16:49:50 <Pseudonym> Every time I need a reified value, I use the Pure Evil Method.
16:49:50 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
16:50:09 <mreh> Ordering is a type
16:50:11 <mreh> not a class
16:50:23 <pumpkin> newtype Reverse :: Reverse a; instance (Ord a) => Ord (Reverse a) where compare = (toEnum . (2-) . fromEnum .) . compare -- epic hack
16:50:44 <pumpkin> if you just want to reverse the ordering use the epic hack in compare :P
16:50:50 <mreh> compare 1 2
16:50:51 <pumpkin> or write ALL THREE CASES out yourself
16:50:55 <mreh> > compare 1 2
16:50:56 <lambdabot>   LT
16:51:00 <mreh> pumpkin :D
16:51:07 <pumpkin> I know it's a lot of work
16:51:18 <pumpkin> (toEnum . (2-) . fromEnum .) . compar
16:51:20 <mreh> I wanted to know the most haskell way
16:51:33 <c_wraith> I'm not sure Ordering should be an instance of Ord
16:51:35 <pumpkin> > (((toEnum . (2-) . fromEnum) .) . compare) 1 2 -- isn't it
16:51:36 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
16:51:41 <pumpkin> boo, I even failed
16:51:50 * pumpkin epic failz
16:51:59 <pumpkin> oh duh
16:52:35 <mreh> Ordering doesn't seem to exist by hoogle
16:52:36 <pumpkin> > let revcompare = (((toEnum :: Int -> Ordering) . (2-) . fromEnum) .) . compare in revcompare 1 2 -- isn't it
16:52:38 <lambdabot>   GT
16:52:41 <pumpkin> > let revcompare = (((toEnum :: Int -> Ordering) . (2-) . fromEnum) .) . compare in revcompare 1 1 -- isn't it
16:52:42 <lambdabot>   EQ
16:52:44 <MissPiggy> I am happy with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16975#a16975
16:52:45 <pumpkin> > let revcompare = (((toEnum :: Int -> Ordering) . (2-) . fromEnum) .) . compare in revcompare 1 0 -- isn't it
16:52:46 <lambdabot>   LT
16:52:49 <MissPiggy> this is really great
16:53:03 <pumpkin> that's quite cute
16:53:35 <c_wraith> > [LT..GT]
16:53:36 <lambdabot>   A section must be enclosed in parentheses thus: (`LT..` GT)Not in scope: `L...
16:53:40 <mreh> cheers pumpkin, why isn't writing out all the cases a better idea?
16:53:49 <pumpkin> mreh: because epic golfage
16:53:55 <pumpkin> mreh: but in general I would write those out
16:54:05 <pumpkin> I was being sarcastic about 3 cases being too much work
16:54:10 <mreh> FOUR!
16:54:13 <jlouis> pumpkin: beware of Tiger Woods syndrome :)
16:54:21 <pumpkin> mreh: four?
16:54:30 <mreh> it's what you shout when you play gold
16:54:31 <Gracenotes> > [LT ..GT]
16:54:32 <lambdabot>   [LT,EQ,GT]
16:54:33 <jlouis> and g'night :)
16:54:33 <mreh> golf
16:54:53 <pumpkin> or even easier
16:54:57 <MissPiggy> hmm
16:54:59 <Gracenotes> [[]..[]]
16:55:00 <pumpkin> @let revcompare x y = compare y x
16:55:01 <lambdabot>  Defined.
16:55:02 <pumpkin> tada
16:55:04 <c_wraith> Oh.  it tried to parse it as a module name, since it went SomethingThatStartsWithACapital.
16:55:04 <MissPiggy> the thing is now I have to do something a bit tricky
16:55:08 <pumpkin> ;)
16:55:22 * pumpkin feels silly
16:55:37 <c_wraith> @pl \x y -> f y x
16:55:37 <pumpkin> > revcompare 1 2
16:55:37 <lambdabot> flip f
16:55:38 <lambdabot>   GT
16:55:48 <pumpkin> c_wraith: I wanted to be MOAR explicit
16:55:56 <c_wraith> than revcompare = flip compare?
16:55:58 <c_wraith> :)
16:55:59 <pumpkin> yep
16:56:04 <pumpkin> MOAR
16:56:06 <aavogt> @type compare . flip
16:56:07 <Gracenotes> there is true there
16:56:08 <lambdabot> forall (f :: * -> *) a b. (Ord (a -> f b), Functor f) => f (a -> b) -> (a -> f b) -> Ordering
16:56:16 <Gracenotes> oh wow
16:56:28 <Gracenotes> oh, not so wow. darn you, new (.)
16:56:31 <pumpkin> nice, Ord (a -> f b)
16:56:46 <c_wraith> Is that a common instance for Ord?
16:56:50 <pumpkin> an ordered kleisli arrow (assuming f is an m)
16:57:09 <aavogt> @type compare flip
16:57:10 <lambdabot> forall (f :: * -> *) a b. (Functor f, Ord (f (a -> b) -> a -> f b)) => (f (a -> b) -> a -> f b) -> Ordering
16:57:10 <Gracenotes> don't generally order functions
16:57:29 <aavogt> you can if you can enumerate all the arguments
16:57:30 <pumpkin> you can order them using my enumerate package ;)
16:57:41 <aavogt> pumpkin: co-where?
16:57:44 <Gracenotes> pumpkin: wouldn't that take a while? o.o
16:57:47 <pumpkin> @hackage enumerate
16:57:47 <lambdabot> http://hackage.haskell.org/package/enumerate
16:57:56 <pumpkin> Gracenotes: yeah, but who needs speed when you have ordered functions
16:58:01 <c_wraith> no, that's where, not co-where
16:58:03 <aavogt> that's not there yet
16:58:09 <aavogt> I see
16:58:15 <pumpkin> http://hackage.haskell.org/package/enumerable
16:58:21 <pumpkin> wow, i can't even get my own package name right
16:58:32 <c_wraith> oh, so it was an element of co-where
16:58:37 <pumpkin> oh looks like I didn't put the Ord instance in
16:58:53 <pumpkin> I had such plans for that package
16:59:00 <pumpkin> but shiny things got in the way
16:59:13 <aavogt> this looks quite like smallcheck's serial instances
16:59:22 <pumpkin> aavogt: yeah it is
16:59:26 <monadic_kid> doesn't know when to admit that he doesn't actually know: http://www.reddit.com/r/programming/comments/awy0w/i_might_be_a_heretic_here_on_reddit_but_i_love_c/c0jvr01?context=3
17:00:06 <Gracenotes> so I was sitting in my applied algebra class today (groups, rings and fields with applications), and the TA asked who knew what a cartesian product was. no one raised their hand :/
17:00:18 <pumpkin> Gracenotes: sad
17:00:26 <aavogt> pumpkin: so what's the difference?
17:00:27 <Gracenotes> well, except me, and I felt like an idiot
17:00:33 <pumpkin> aavogt: I didn't know about smallcheck at the time
17:00:40 <aavogt> now you do :)
17:00:45 <pumpkin> aavogt: different scope, mine is intentionally less practical, etc.
17:00:51 <Gracenotes> well, you know what I mean. I don't think the set theory is strong in these students.
17:00:52 <pumpkin> no depth parameter
17:01:00 <jmcarthur> Gracenotes: :(
17:01:02 <Pseudonym> You said it was a category product in Set, right?
17:01:09 <pumpkin> Gracenotes: I don't have a strong math background but I knew what a cartesian product was in high school :/
17:01:20 <jmcarthur> i at least had the luxury of being in an algebra class with a couple other students who were actually into it
17:01:36 <Pseudonym> And then proceded to proce that it's unique up to isomorphism.
17:01:39 <pumpkin> aavogt: also, I don't think smallcheck goes so far as to actually make an Eq instance for functions
17:01:49 <pumpkin> aavogt: or the proposed Ord instance
17:01:59 <aavogt> so make your stuff a subclass of Serial?
17:02:01 <pumpkin> or counting values
17:02:03 <jmcarthur> wait, an Ord instance for functions?
17:02:15 <c_wraith> I'd like to see an Enum instance for functions.  >_>
17:02:16 <pumpkin> jmcarthur: with Eq I can tell you where in the enumeration it falls :P
17:02:21 <pumpkin> c_wraith: that's what that package is
17:02:27 <pumpkin> I can enumerate all functions of a given type
17:02:35 <Gracenotes> pumpkin: ..and what's this about you dreaming of aleph in some form
17:02:37 <aavogt> to get Ord you probably need something like monoid on the results
17:02:59 <pumpkin> aavogt: I have enumerate :: [Int -> Int] for example... all I need to do is find the index where it falls :P
17:03:10 <pumpkin> never said it was fast ;)
17:03:34 <pumpkin> nevermind that it's superexponential running time
17:03:48 <Gracenotes> oh, let's not be modest
17:04:26 <pumpkin> no danger of that
17:04:30 <jmcarthur> pumpkin: well, you also have to be able to enumerate over them to do that
17:04:32 <aavogt> it's funny how what the actual argument 'n' is, is implicit in all these analyses
17:04:45 <pumpkin> jmcarthur: over what?
17:05:00 <jmcarthur> pumpkin: you can enumerate over all functions of *any* given type?
17:05:06 <pumpkin> jmcarthur: yep
17:05:16 <pumpkin> just make sure they're finite :P
17:05:42 <pumpkin> but if you feel like waiting for Int -> Int -> (Char -> Bool) -> Bool to complete, go ahead
17:05:42 <aavogt> not terminating anytime soon though...
17:05:44 <jmcarthur> just to be clear, this is without a type class?
17:05:50 <pumpkin> jmcarthur: no, with a typeclass
17:06:04 <jmcarthur> okay, then only for types which instantiate the class then
17:06:09 <pumpkin> yeah
17:06:12 <aavogt> how would you do it with a sane amount of code without typeclasses?
17:06:17 <jmcarthur> i was simply not sure how to interpret "all"
17:06:23 <pumpkin> oh, yeah
17:06:28 <pumpkin> I guess it could be generic
17:06:29 <jmcarthur> aavogt: that's what confused me ;)
17:06:34 <pumpkin> but I was but a young'un back then
17:06:53 <aavogt> a whole 6 months ago
17:06:55 <MissPiggy> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)   :((((
17:06:57 <pumpkin> yeah
17:07:00 <jmcarthur> heh
17:07:08 <aavogt> MissPiggy: set a different encoding
17:07:11 <jmcarthur> pumpkin /= copumpkin anymore?
17:07:17 <MissPiggy> aavogt, but it is a PNG file
17:07:18 <pumpkin> aavogt: hey, that's almost half my haskell career!
17:07:32 <pumpkin> jmcarthur: different computer => opposite
17:07:46 <jmcarthur> ah
17:07:47 <aavogt> MissPiggy: http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/
17:07:55 <MissPiggy> it's not unicode
17:07:57 <aavogt> oh, then you need to open it as a binary probably...
17:08:01 <MissPiggy> I think I'm screwed
17:08:04 <aavogt> because you are reading it as unicode
17:08:05 <jmcarthur> screen + weechat, ftw
17:08:13 <MissPiggy> I did:  pixels <- readFile (imageDir ++ name)
17:08:22 <aavogt> and the binary file probably contains illegal unicode
17:08:26 <MissPiggy> then I try to serve it lke  return ... { .. ; resBody = pixels }
17:08:29 <aavogt> err, utf8
17:08:33 <MissPiggy> but the problem is that resBody is a String
17:08:43 <MissPiggy> but pixels is a png file so it doesn't want to be string
17:09:07 <MissPiggy> so that sucks..
17:09:30 <c_wraith> yes, String is an inappropriate data type for web server responses
17:09:52 <c_wraith> Just rewrite the whole thing to use ByteString :)
17:10:14 <jmcarthur> oh i didn't realize we had hSetNewlineMode now
17:10:15 <aavogt>    pixels <- hGetContents =<< openBinaryFile "foo" ReadMode
17:10:51 <c_wraith> aavogt: that really doesn't work when you serialize it for the network
17:10:56 <MissPiggy> dammit!!
17:11:07 <MissPiggy> If I have a server on 127.0.0.1
17:11:13 <MissPiggy> it can't call up images from file://...
17:11:24 <MissPiggy> that would have fixed the problem since I'm only running this locally :(
17:11:47 <aavogt> c_wraith: hmm, well the point is that you can avoid the "hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)" error that way
17:12:05 <aavogt> though bytestring would be better here
17:12:16 <MissPiggy> import Network.Shed.Httpd
17:12:19 <MissPiggy> I'm using that ^
17:12:21 * syntaxglitch wonders if a program that converted executable code into Haskell source would be properly called an "mpiler"
17:12:30 <MissPiggy> it has only string mode
17:13:05 <Pseudonym> syntaxglitch: Possibly, but then that would be executable "de".
17:13:42 <MissPiggy> I thought things were starting to work
17:14:22 <MissPiggy> http://hackage.haskell.org/packages/archive/httpd-shed/0.4/doc/html/Network-Shed-Httpd.html
17:14:32 <MissPiggy> someone should make a version of this server that can do binary files such as PNG
17:14:43 <MissPiggy> how do you edit cabal progams anyway?
17:15:44 <MissPiggy> do you get the source.tgz and just change the version number to a higher one? and then install it
17:15:57 <ivanm> MissPiggy: what do you mean by "edit cabal programs"?
17:16:08 <ivanm> cabal is just a package building library
17:16:13 <MissPiggy> Network.Shed.Httpd
17:17:56 <Zao> import qualified Network.Shed.Bike as Blue
17:18:04 <MissPiggy> haha
17:18:14 <MissPiggy> import qualified Network.Shed.Bike as Cerulean
17:18:16 <syntaxglitch> no, Green
17:18:20 <Zao> MissPiggy: cabal unpack will fetch and unpack the tarball.
17:18:34 <Zao> Or just grab the tar.gz from hackage.
17:19:44 <MissPiggy> woah
17:19:50 <MissPiggy> aavogt, how the heck did that work!!
17:20:03 <MissPiggy> pixels <- hGetContents =<< openBinaryFile name ReadMode
17:20:11 <MissPiggy> that actually works.. even though it's putting a binary file into a String
17:20:14 <MissPiggy> does that make sense?
17:20:20 <MissPiggy> how could that happen
17:20:33 <ivanm> MissPiggy: binary String
17:20:43 <MissPiggy> this is great String
17:20:48 <ivanm> MissPiggy: there's no fundamental "binary" datatype
17:20:56 <ivanm> MissPiggy: try opening a binary file in a text editor
17:21:16 <MissPiggy> in C you can have a problem with 0 bytes
17:21:20 <ivanm> after all, String = [Char], and Char is basically a non-negative integer...
17:21:22 <MissPiggy> but in Haskell?
17:21:28 <ivanm> empty string you mean?
17:21:30 <MissPiggy> great
17:21:33 <MissPiggy> no like
17:21:41 <ivanm> oh, the \0 at the end?
17:21:46 <MissPiggy> if the file has a \0 half way through, sometimes C will think it's just half the file
17:21:49 <ivanm> I don't think there is such a problem with Haskell...
17:21:56 <theorbtwo> "foo\0bar" ?  Shouldn't be a problem.
17:22:03 <MissPiggy> wonderful
17:22:03 <ivanm> then again, I typically don't go around trying it
17:22:09 <ivanm> > length "foo\0bar"
17:22:09 <MissPiggy> I don't even have to edit the bikeshed
17:22:10 <lambdabot>   7
17:22:17 <ivanm> looks like it works
17:22:22 <ivanm> MissPiggy: in C, aren't Strings arrays?
17:22:28 * hackagebot upload: happstack-dlg 0.1.2 - Cross-request user interactions for Happstack (ChrisSmith)
17:22:36 <pumpkin> ivanm: yep
17:22:42 <pumpkin> where array = chunk of memory
17:22:44 <ivanm> pumpkin: :o you've lost your co!
17:22:49 <pumpkin> with a delimiter to mark the end of it
17:22:53 <pumpkin> ivanm: yep!
17:22:55 <ivanm> did your company go broke? :p
17:22:57 <pumpkin> different computer
17:22:59 <pumpkin> :)
17:23:02 <ivanm> excuses, excuses!
17:23:03 <theorbtwo> If you have a problem, it means that your compiler (or, possibly, your standard library) is buggy.
17:23:06 <MissPiggy> I am so happy about this
17:24:00 <pumpkin> MissPiggy: String is just the usual inductively defined list, on Char
17:24:06 <pumpkin> so they don't need a delimiter
17:24:48 <ivanm> pumpkin: I like the "just the usual"
17:25:04 <MissPiggy> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-Environment.html
17:25:12 <pumpkin> ivanm: considering that she knows what I mean, I assumed that would be fine :P
17:25:16 <ivanm> "monads are just your usual zygohistomorphic premorphism"
17:25:17 <ivanm> ;-)
17:25:17 <MissPiggy> how do you do pwd? (print working directory) in haskell?
17:25:30 <ivanm> MissPiggy: the directory library I think
17:25:34 <MissPiggy> actually I don't need to know do I?
17:25:41 <MissPiggy> because haskell will try to read files from where it is
17:25:41 <ivanm> @hoogle currentDirectory
17:25:41 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
17:25:41 <lambdabot> System.Directory makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
17:25:41 <lambdabot> System.Directory setCurrentDirectory :: FilePath -> IO ()
17:25:46 <ivanm> there we are
17:31:32 <MissPiggy> how do you indent this?  return $ Response { resCode = 200, resHeaders = [("Content-Type", contentType)], resBody = bytes }
17:31:42 <MissPiggy> it's a bit long all on one line
17:32:14 <MissPiggy> I suposse I can do  { \n ,\n , ..
17:38:26 <Cale> MissPiggy: I'd put a newline after the first comma, and line up resHeaders with resCode
17:38:35 <Cale> and then do the same with resBody
17:39:23 <Cale> return $ Response { resCode = 200,
17:39:32 <Cale>                      resHeaders = [("Content-Type", contentType)],
17:39:35 <Cale> oops
17:39:47 <Cale> Hard to do it right on IRC :)
17:40:12 <Cale> That has one too many spaces, but you get the idea
17:41:20 <idnar> is the $ needed there?
17:41:50 <dmwit> No, but it doesn't hurt.
17:42:25 <idnar> I was just curious
17:44:07 <ivanm> yeah, I don't really like that rule that it isn't needed in cases like that
17:44:10 <ivanm> it just looks wrong :s
17:44:50 <Dashkal> Is there a "trim" function (String -> String) that simply strips whitespace from either end of a string?
17:45:03 <monochrom> No.
17:45:15 <pumpkin> but I wrote a simple one a while back that involved no reversing
17:45:20 <ivanm> pumpkin: :o
17:45:24 <pumpkin> with ultragolf
17:45:35 <ivanm> how? continually testing if it had found the "end" of the actual String?
17:46:01 <idnar> > let ltrim = dropWhile (== ' '); rtrim = reverse . ltrim . reverse; trim = ltrim . rtrim in trim " foo bar baz   "
17:46:02 <lambdabot>   "foo bar baz"
17:46:39 <pumpkin> :t tail . init . groupBy ((==) <$> isSpace <*> isSpace) . (" " ++) . (++ " ")
17:46:40 <lambdabot>     Couldn't match expected type `a -> Bool'
17:46:40 <lambdabot>            against inferred type `Bool'
17:46:40 <lambdabot>     In the first argument of `(<$>)', namely `(==)'
17:46:49 <hatds> was about to say it was using groupBy
17:46:51 <hatds> :)
17:47:00 <monochrom> Nice.
17:47:00 <hatds> or guess, rather
17:47:03 <pumpkin> :t tail . init . group . (" " ++) . (++ " ")
17:47:04 <lambdabot> [Char] -> [[Char]]
17:47:10 <pumpkin> :t join . tail . init . group . (" " ++) . (++ " ")
17:47:11 <lambdabot> [Char] -> [Char]
17:47:12 <ivanm> pumpkin: what's with the extra space on the beginning and end?
17:47:17 <monochrom> Someone @tell that code to medfly so his agony continues.
17:47:21 <ivanm> just to give it a space to start with?
17:47:29 <pumpkin> ivanm: it works by grouping spaceyness
17:47:35 <pumpkin> and dropping initial and final spaceyness
17:47:41 <pumpkin> if you don't do that, you risk dropping goodness
17:47:43 <ivanm> monochrom: hmmm?
17:47:47 <ivanm> pumpkin: yeah
17:47:56 <pumpkin> :t groupBy
17:47:57 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
17:48:14 <idnar> what did we do to poor medfly?
17:48:15 <ivanm> oh, doesn't medfly like the groupBy definition?
17:48:29 <pumpkin> :t (==) <$> isSpace <*> isSpace
17:48:30 <lambdabot> Char -> Bool
17:48:33 <pumpkin> oh duh
17:48:45 <MissPiggy> "<h2><h1><blink>File not found!</blink></h1><br /><marquee>" ++ message ++ "</marquee></h2>"
17:48:46 <MissPiggy> that's my 404
17:48:48 <pumpkin> :t join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ")
17:48:49 <lambdabot> [Char] -> [Char]
17:48:50 <pumpkin> there, fully general
17:48:58 <monochrom> ivanm: somewhere between 14-16 hours ago medfly completely exploded with accusations on how this channel is full of unreadable code.
17:49:03 <idnar> pumpkin: (&&) `on` isSpace?
17:49:05 <ivanm> monochrom: heh
17:49:21 <pumpkin> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t"
17:49:22 <ivanm> MissPiggy: you need some web 2.1 in there!
17:49:22 <lambdabot>   "zomg     wtf is this     this"
17:49:28 <pumpkin> idnar: hmm
17:49:35 <MissPiggy> ivanm hehe I have jQurey to write
17:49:36 <pumpkin> I think I want ==, but maybe not
17:49:40 <MissPiggy> I am very newbie
17:49:47 <MissPiggy> but I found jQuery cool because of $
17:49:57 <idnar> pumpkin: oh, maybe you do
17:50:08 <MissPiggy> I really could use someone else who has some style with it but not a big dea
17:50:09 <ivanm> pumpkin: aaahhh, I think I get what it does now...
17:50:11 <idnar> in fact, I'm pretty sure you do
17:50:31 <idnar> although it may not make a difference to the result
17:50:33 <idnar> > join . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t"
17:50:34 <lambdabot>   "zomg     wtf is this     this"
17:51:01 <ivanm> well, == on Bool is <-->
17:51:15 <ivanm> so it depends on what you want it to do when isSpace returns False for both
17:51:31 <pumpkin> trying to think if it even matters
17:51:36 <idnar> pumpkin: anyhow, I think I meant (==) `on` isSpace in the first place, just got confused
17:52:01 <pumpkin> I don't think it does matter in the only place it would matter, because of the padding with spaces
17:52:07 <idnar> yeah
17:52:22 * pumpkin gets back to his book
17:52:30 <pumpkin> :)
17:52:42 <Dashkal> *blinks*
17:52:47 <ivanm> pumpkin: which book?
17:52:58 <Dashkal> hGetLine on a socket is giving me the line with a chr 13 at the end...
17:53:03 <pumpkin> "Introduction to Statistical Relational Learning"
17:53:21 <ivanm> sounds boring
17:53:22 <monochrom> > '\13'
17:53:24 <lambdabot>   '\r'
17:53:38 <pumpkin> ivanm: I actually went and took it out of the library of my own will!
17:53:43 <ivanm> :o
17:53:50 <Dashkal> And isSpace recognizes 13, so I must have writen trim wrong...
17:53:54 <ivanm> was your will free however?
17:53:54 <pumpkin> not bad so far
17:54:11 <pumpkin> it was as free as the resident philosopher allows it to be
17:54:23 <ivanm> ... >_>
17:54:43 <pumpkin> :)
17:54:48 <monochrom> Dashkal: GHC-compiled code on unix considers \n to be the sole line-breaker, \r not discarded. Of course, unfortunately, most network protocols give you \r\n. You just have to deal with it.
17:55:11 <pumpkin> unsafePerformIO'd global variable for line breaker!
17:55:16 <pumpkin> :P
17:55:33 <idnar> I like my version just because it was as easy to write as it is to read it :P
17:55:46 <pumpkin> but ick reverse!
17:56:06 <theorbtwo> Premature optimization is the root of much evil.
17:56:10 <ivanm> monochrom: which is why using a parsing library is often preferred?
17:56:21 <pumpkin> theorbtwo: what if you have an infinite string? mine works!
17:56:22 <pumpkin> :P
17:56:24 <Dashkal> monochrom: *nods* This is why I wanted trim.  So I could nuke anything that survived.
17:56:39 <pumpkin> laziness = good
17:56:41 <idnar> pumpkin: mine does too, just use ltrim :P
17:56:52 <pumpkin> idnar: what if you don't know beforehand!
17:56:58 <pumpkin> some evil person hands you an infinite string
17:57:16 <ivanm> evil person? where? *cough* pumpkin *cough*
17:57:18 <Dashkal> Now I need to figure out why hClose on my handle doesn't properly kill the socket.
17:57:20 <theorbtwo> pumpkin: But you can never prove that you removed any whitespace on the right hand side of your infinite string1
17:57:34 <monochrom> ivanm: Ideally I would go all the way to Olegish iteratee.
17:57:42 <theorbtwo> s/1$/!/ # I can't believe I just did that non-ironicly.
17:57:45 <ivanm> Dashkal: as a wild guess (never having used sockets before) because hClose closes the handle and not the socket?
17:57:47 <pumpkin> theorbtwo: I'm lazy enough that I don't need to :) it'll do the right thing in both cases!
17:57:53 <ivanm> monochrom: heh
17:57:55 <idnar> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t" ++ repeat "a"
17:57:56 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:57:56 <lambdabot>         against inferred type...
17:58:01 <idnar> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t" ++ repeat 'a'
17:58:03 <jgrimes> hi there. I'm getting this error trying to install scion
17:58:04 <jgrimes> cabal: dependencies conflict: ghc-6.10.4 requires filepath ==1.1.0.2 however
17:58:04 <jgrimes> filepath-1.1.0.2 was excluded because ghc-6.10.4 requires filepath ==1.1.0.3
17:58:04 <lambdabot>   mueval-core: Time limit exceeded
17:58:09 <pumpkin> fail
17:58:21 <idnar> pumpkin: doesn't seem to work so well ;)
17:58:22 <ivanm> jgrimes: what does "ghc-pkg list filepath" say?
17:58:39 <ivanm> idnar: prepend it with a take 20 or something
17:58:46 <ivanm> to provie it really is working and returning something
17:58:54 <Dashkal> hmm, if it's closing the handle and not the socket, that leaves me wondering how to kill the socket.  I got a Handle, Hostname (type Hostname = String), and a Port from accept
17:58:57 <idnar> > take 50 . join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t" ++ repeat 'a'
17:59:03 <lambdabot>   mueval-core: Time limit exceeded
17:59:07 <monochrom> Is ((&&) `on` isSpace) an equivalence relation? In order to use groupBy correctly (not relying on undocumented incidental features), you should stick to equivalence relations.
17:59:08 <idnar> > take 10 . join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "       zomg     wtf is this     this\t   \t" ++ repeat 'a'
17:59:08 <pumpkin> wtf
17:59:08 <jgrimes> /var/lib/ghc-6.10.4/./package.conf:
17:59:08 <jgrimes>     filepath-1.1.0.2
17:59:08 <jgrimes> /home/jgrimes/.ghc/i386-linux-6.10.4/package.conf:
17:59:08 <jgrimes>     filepath-1.1.0.1, filepath-1.1.0.3
17:59:09 <lambdabot>   "zomg     w"
17:59:12 <ivanm> idnar: so it obviously fails
17:59:20 <ivanm> jgrimes: right; you should never have built filepath itself
17:59:20 <idnar> as long as you don't trip into the "last" group, it's fine
17:59:20 <pumpkin> oh it's lambdabot not being lazy enough
17:59:30 <theorbtwo> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ ("       zomg     wtf is this     this\t   \t" ++ repeat " ")
17:59:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:59:31 <lambdabot>         against inferred type...
17:59:42 <theorbtwo> Oh, nevermind.
17:59:46 <ivanm> jgrimes: call ghc-pkg unregister on the two versions of filepath you installd in your home directory
17:59:52 <pumpkin> > "      zomg    wtf is this    this\t  \t" ++ repeat " "
17:59:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:59:53 <lambdabot>         against inferred type...
17:59:55 <pumpkin> > "      zomg    wtf is this    this\t  \t" ++ repeat ' '
17:59:55 <ivanm> then do "ghc-pkg check" and rebuild all packages that it spits out
17:59:56 <lambdabot>   "      zomg    wtf is this    this\t  \t                                   ...
18:00:01 <pumpkin> > "      zomg    wtf is this    this\t  \t" ++ repeat 'a'
18:00:03 <lambdabot>   "      zomg    wtf is this    this\t  \taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
18:00:06 <theorbtwo> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ ("       zomg     wtf is this     this\t   \t" ++ repeat ' ')
18:00:10 <jgrimes> ivanm, ok
18:00:11 <lambdabot>   mueval-core: Time limit exceeded
18:00:13 <ivanm> jgrimes: filepath is a "boot" package of ghc; as such you should never upgrade it
18:00:15 <pumpkin> I see what's wrong
18:00:20 <pumpkin> makes sense :)
18:00:24 <idnar> the function divides the string into groups
18:00:26 <ivanm> pumpkin: what?
18:00:40 <idnar> it can only yield the Nth group once the N+1th group has been found
18:00:44 <pumpkin> yeah
18:00:51 <idnar> if the N+1th group never ends, then you get stuck there
18:00:52 <monochrom> ((&&) `on` isSpace) is not an equivalence relation. Fails reflexivity.
18:01:32 <idnar> monochrom: yeah, (&&) `on` isSpace was garbage, I was thinking of something else
18:02:52 <jgrimes> ivanm, thanks
18:03:10 <ivanm> no worries
18:03:29 <pumpkin> idnar: I guess that's the best you can possibly do
18:03:35 <pumpkin> in terms of laziness
18:03:49 <idnar> pumpkin: pretty much
18:03:52 <Dashkal> alrighty, not even sClose closes the socket (my remote telnet is still connected).  Only killing ghci closes it
18:04:03 <idnar> pumpkin: I would not expect that to be very useful in most cases, though
18:04:11 <pumpkin> :P
18:04:16 <idnar> pumpkin: either you care about infinite strings, or you don't care about right-trimming :P
18:04:27 <idnar> er
18:04:36 <idnar> either you care about infinite strings, or you care about right-trimming, not both
18:04:47 <pumpkin> idnar: nice to have a sufficiently lazy function that does both mostly correctly :P
18:04:55 * pumpkin keeps massaging his ego
18:05:21 <theorbtwo> pumpkin: But there is no right thing to do when attempting to right-trim an infinite string, sine it doesn't *have* a right end.
18:05:33 <pumpkin> yes, but you don't know beforehand if a string is infinite or not
18:05:44 <idnar> is join there just concat?
18:05:45 <monochrom> iteratee works on both
18:05:53 <pumpkin> so you might as well do finite correctly and infinite semicorrectly
18:06:03 <monochrom> join there is just concat
18:06:03 <theorbtwo> Not only don't you know, but you cannot know.
18:06:09 <pumpkin> rather than have finite correct and infinite just recurse unproductively
18:06:24 <pumpkin> or corecurse I should say :)
18:06:47 <idnar> is reverse actually corecursion?
18:06:55 <monochrom> No.
18:07:08 <pumpkin> on an infinite list?
18:07:16 <Pseudonym> I've never seen a succinct definition of corecursion.
18:07:21 <Pseudonym> I only know it by examples.
18:07:38 <pumpkin> I mean, all data in haskell is effectively codata
18:07:42 <pumpkin> isn't it?
18:08:03 <Pseudonym> I guess not if it's peppered with bangs.
18:08:03 <monochrom> until you write algorithms that break on codata, such as reverse
18:08:20 * idnar whips out his six-shooter to provide some bangs
18:08:26 <pumpkin> lol
18:08:36 <monochrom> You only have 6 bangs.
18:09:10 <pumpkin> data Zomg a b = [] | (a, b)
18:09:35 <hatds> I know what you're thinking, did I use 5 bangs or 6...
18:09:52 <idnar> data Die = Hahaha !Bang !Bang !Bang !Bang !Bang !Bang Click Click Click Damnit
18:10:22 * pumpkin quietly inches away from idnar
18:10:36 <theorbtwo> Maybe Fired5 Fired6
18:10:44 <idnar> heh
18:10:45 <hatds> or Either
18:11:13 <theorbtwo> Yeah, hard choice between accuracy to Haskell and accuracy to Dirty Harry.
18:11:31 <theorbtwo> That, or I made a stupid newbie mistake with my Haskell.  That's quite possible too.
18:11:58 <hatds> nah it was fine that way too
18:13:52 * pumpkin has a mathematical term stuck in his head and doesn't know what it means
18:14:30 <pumpkin> oh
18:14:38 <pumpkin> I did know what it meant, but didn't know that I knew
18:15:00 <hatds> what was it?
18:15:06 <idnar> I read "mathematical tune"
18:15:12 <pumpkin> Grothendieck topos
18:15:30 <kamatsu> hi, so, has anyone else noticed that the <- sign in lhs2TeX comes out as the "element of" sign "∈ " if you use the --tt layout?
18:15:38 <dolio> It has to do with categorical logic.
18:15:41 <kamatsu> i sort of don't want that. Any way to get around it?
18:16:04 <pumpkin> yeah
18:17:06 <hatds> huh, I never even realized that <- looked like "element of", and it's usage even matches that interpretation
18:17:13 <idnar> heh
18:17:17 <monochrom> I like do { x ∈ getLine ... }, it pisses off people who hate "monad as container" :)
18:17:43 <pikhq> Heheheh.
18:17:53 <idnar> > [x | x ∈ [1..10]]
18:17:54 <lambdabot>   Not in scope: `∈'
18:18:22 <sshc> what does the IncoherentInstances extesnion do?
18:18:36 <sshc> is there any documantiotn for the extensions that GHC supports?
18:18:37 <pumpkin> something about not requiring unification
18:18:44 <hatds> yes, the ghc user manual
18:18:48 <pumpkin> sshc: yeah, but it never explains that extension very completely
18:19:07 * pumpkin still doesn't get what kinds of cases require IncoherentInstances
18:19:13 <sshc> good, then I guess I can ask IRC without looking it up :)
18:19:26 <idnar> I guess ghc doesn't actually accept that
18:19:41 <pumpkin> at least, I looked it up and was dissatisfied with the explanation
18:19:42 <monochrom> There is no documentation. You have to ask people on IRC. They are happy to re-type the same explanation again and again, but never file it in documentation.
18:20:03 <kamatsu> anyway, any way to change that without using sed s/char'06/$\leftarrow$/g
18:20:18 <idnar> monochrom: some days I think there's something wrong with people
18:20:58 <mightybyte> Anyone know what causes "Unexpected method type: m_0 GHC.Unit.()" errors?
18:21:15 <pumpkin> so can anyone actually come up with an explanation of IncoherentInstances?
18:21:17 <monochrom> They say it's the same as re-typing "Merry Christmas and Happy New Year" for sincerity vs defining a macro.
18:23:04 <dolio> I think it lets you use overlapping instances such that you might use the general one even if a more specific one is in scope, depending on what the polymorphism of your function looks like.
18:23:56 <dolio> Like if there's an instance for all 'a', and your function is polymorphic in 'a', and you use a method that would require that 'a' to be in the class, it just works.
18:24:08 <dolio> No constraint required.
18:24:34 <pumpkin> :o
18:24:36 <dolio> But that means if there's an Int instance in scope, and you use your function at Int, the Int instance isn't used.
18:24:48 <kamatsu> oh well, i'll just use sed i guess
18:24:54 <pumpkin> I think I see
18:25:09 <pumpkin> that sounds sort of scary
18:25:33 <hatds> ghc's manual does explain this... it shares a subsection with overlapping instances
18:25:41 <hatds> it's not very specific though
18:25:43 <pumpkin> hatds: yeah, I saw that
18:25:54 <dolio> pumpkin: If you want scary, using existential wrappers with overlapping instances does the same thing.
18:25:56 <pumpkin> that's what I was referring to when I said I wasn't very satisfied
18:26:01 <hatds> I see
18:27:44 <MissPiggy> http://hackage.haskell.org/packages/archive/hint/0.3.2.2/doc/html/Language-Haskell-Interpreter.html
18:27:47 <MissPiggy> this is haskell interpreter
18:28:17 <MissPiggy> but it seems you can't use it like an IORef :(
18:28:25 <ivanm> heh, this is a good one: http://thedailywtf.com/Articles/Passed-Around.aspx
18:30:12 <MissPiggy> maybe you can and I just didn't see it yet
18:31:08 <Cale> MissPiggy: What?
18:31:20 <MissPiggy> I wish there was an Hint tutoria
18:31:27 <Cale> Why would you expect to use an interpreter as an IORef?
18:31:40 <MissPiggy> I only know how do increment an IORef
18:31:45 <MissPiggy> each time you load the web page
18:32:05 <MissPiggy> so if I could use Hint like that - it would be easy
18:32:19 <Cale> Oh, you just mean like other things in the IO monad?
18:32:54 <MissPiggy> I suppose so
18:33:54 <pumpkin> http://stackoverflow.com/questions/2182300/haskell-matrix-scalar-multilple-question
18:34:01 <pumpkin> I love the "it's not working" comment
18:36:05 <monochrom> ivanm: What a nice way to ensure termination of a bunch of mutually recursive functions :)
18:37:00 <MissPiggy> wow trying tocompile something that uses Hint is taking forever
18:37:06 <ivanm> monochrom: heh
18:37:14 <MissPiggy> I have a feeling it's going to tell me about a link error or something
18:37:53 <ivanm> pumpkin: "given as an inspirational example" ?
18:38:20 <pumpkin> ivanm: clearly copied and pasted from a prof's problem set
18:38:36 <ivanm> yup
18:38:47 <ivanm> especially the "bonus question"
18:38:52 <pumpkin> :P
18:40:49 <djahandarie> lmao
18:41:52 <dolio> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16988#a16989
18:43:06 <pumpkin> dolio: voodoo!
18:43:31 <monochrom> MissPiggy: It links in the whole GHC API. Takes a while to just copy stuff from .a files.
18:43:53 <MissPiggy> this is really cool!
18:43:56 <MissPiggy> Left (WontCompile [GhcError {errMsg = "Not in scope: `+'"}])
18:44:05 <MissPiggy> that means it's working
18:44:17 <c_wraith> yeah.  by default it imports nothing
18:44:46 <idnar> that's pretty incoherent
18:44:54 <idnar> ;)
18:45:07 <MissPiggy>  runInterpreter (loadModules ["Prelude"])
18:45:07 <MissPiggy>  r <- runInterpreter (eval "1+1")
18:45:09 <MissPiggy> this doesn't work
18:45:19 <MissPiggy> so that's a problem about sessions
18:46:00 <monochrom> r <- runInterpreter (loadModules ["Prelude"] >> eval "1+1")
18:47:11 <xerox> that looks lice :)
18:47:14 <xerox> *nice
18:47:25 <dolio> pumpkin: The first bar won't work without IncoherentInstances.
18:47:29 <MissPiggy> I have to do it seperately though
18:47:47 <pumpkin> dolio: I see
18:47:56 <dolio> But, apparently, existential quantification does the same thing.
18:47:57 <monochrom> Actually I recall separately still works.
18:48:09 <dolio> Maybe I should get around to reporting that. I'm not really sure if it's intended or not.
18:48:11 <pumpkin> dolio: so I suppose a GADT approach to the same thing would work too?
18:48:31 <MissPiggy> what is it exactly?
18:48:41 <MissPiggy> maybe I solved this with GADTs already
18:51:43 <MissPiggy>  runInterpreter (setImportsQ [("Prelude",Nothing)])
18:51:43 <MissPiggy>  r <- runInterpreter (eval "1+1")
18:51:50 <MissPiggy> that's the right way to do it, but it still doesn't work
18:52:44 <monochrom> what is doesn't work?
18:52:58 <MissPiggy> well it should print 2 but it says + is out of scope
18:53:14 <MissPiggy> if you just do  r <- runInterpreter (setImportsQ [("Prelude",Nothing)] >> eval "1+1") it does print 2
18:55:10 <pumpkin> MissPiggy: I'd assume it's an interpreter monad
18:55:14 <MissPiggy> it is
18:55:19 <pumpkin> MissPiggy: and that setImportsQ needs to be in the same session as eval
18:55:23 <MissPiggy> :(
18:55:25 <pumpkin> setImportsQ ... >> eval "1+1" ?
18:55:27 <pumpkin> maybe?
18:55:33 <MissPiggy> that works but i can't do that
18:55:44 <pumpkin> otherwise it loses the state between calls
18:55:56 <pumpkin> hm
18:56:11 <c_wraith> why can't you do that?
18:56:24 <MissPiggy> I have to serve web pages in between eval calls
18:56:34 <pumpkin> can't you set the imports each time?
18:56:38 <MissPiggy> yes
18:56:41 <c_wraith> Um.  Why can't you just import when you run something?
18:56:46 <MissPiggy> but I want things like
18:56:51 <MissPiggy> < let x = 3 + 1
18:56:54 <MissPiggy> then you can do
18:56:56 <MissPiggy> < x
18:56:59 <MissPiggy> and it will give 4
18:56:59 <pumpkin> ah
18:57:04 <pumpkin> so you want persistent state
18:57:16 <pumpkin> hmm
18:57:34 <monochrom> Serve webpages inside. You have a monad transformer.
18:57:56 <c_wraith> is there a HintT?
18:58:02 <MissPiggy> yes
18:58:06 <monochrom> It is called runInterpreterT
18:58:12 <monochrom> err, InterpreterT
18:58:14 <MissPiggy> woah that works?
18:58:29 <MissPiggy> runInterpreter :: (MonadCatchIO m, Functor m) => InterpreterT m a -> m (Either InterpreterError a)
18:58:39 <monochrom> let m = IO
18:58:55 <monochrom> Hell, even ReaderT ContT IO if you like
18:59:24 <MissPiggy> ah!!! that's what  lift  is for
18:59:59 <monochrom> runInterpreter ( setImports["Prelude"] >> liftIO (putStrLn "404 Page Not Found") >> eval "1+1" >>= (liftIO . putStrLn) )
19:00:29 <c_wraith> if your state is always kept in memory, InterpreterT ContT IO is a decent approach
19:00:31 <MissPiggy> im not sure this will quite work
19:00:31 <monochrom> You can also catch and handle exceptions inside.
19:00:35 <MissPiggy> but it 99% works
19:01:11 <MissPiggy> I guess that I really /do/ have to edit Shed.Httpd, because it's got initServer :: Int -> (Request -> IO Response) -> IO Server
19:01:32 <MissPiggy> and I really need something else.. like MonadIO m => ... -> m Response) -> m Server
19:01:59 <monochrom> oh fun
19:02:10 <MissPiggy> not fun :(
19:03:15 <monochrom> If you use GHC API directly, you can stay in IO throughout.
19:03:26 <MissPiggy> alright
19:03:36 <MissPiggy> okay I will do that
19:03:51 <monochrom> By all means steal from Hint how to use GHC API. :)
19:14:20 <dolio> So, how does jdh promote the values of OCaml and F# while simultaneously talking on haskell mailing lists about how functional programming sucks in every way compared to imperative programming?
19:14:45 <monochrom> By classifying F# as imperative programming.
19:15:16 <pikhq> ... Lawlwut?
19:15:16 <monochrom> Indeed in OCaml they x:=!x+1 like there is no tomorrow.
19:15:28 <det> monochrom, I dont think that is true
19:15:40 <monochrom> This is why they don't have NoMonomorphismRestriction.
19:15:41 <MissPiggy> How does the pope promote Christian values and simultaneously hate equality?
19:15:42 <dolio> I mean, I've seen him talk on Lisp newsgroups, and all the advantages he lists are about functional programming.
19:15:52 <dolio> Pure functional programming stuff, even, like pattern matching.
19:15:58 <det> monochrom, recursive loops with accumulators are more common
19:16:49 <det> "functional programming" is an overloaded term
19:16:50 <pikhq> MissPiggy: By being a Nazi.
19:16:50 <monochrom> OK, then a simpler explanation is his email account is hacked.
19:17:25 <det> I am pretty sure jdh has given a definition of what he considers functional programming
19:17:43 <det> but not everyone thinks purity is a requirement
19:17:43 <pumpkin> godwin has already entered the room
19:18:28 <Dashkal> woo, finally solved my socket not closing problem.  Apparently it matters that I import System.IO instead of IO.  Suddenly hClose works.
19:19:32 <monochrom> That is strange, but no wonder I can't reproduce the problem.
19:20:03 <Dashkal> Also using Network.Socket, but that alone didn't entirely solve the problem.  It did solve the problem of my listen socket not actually freeing up.
19:20:40 <Dashkal> I really, REALLY hate socket programming *sighs* Fortunately, now that this test app works, I can at least implement it more or less quickly in the actual game.
19:20:42 <djahandarie> Whoa, major dejavu reading this chat log
19:20:54 <djahandarie> Like the exact same thing was written yesterday or so
19:21:15 <monochrom> which part? the jdh part? the socket part? the monochrom part?
19:21:45 <djahandarie> F#, Ocaml, NoMonomorphismRestriction, Pure functional programming, in that order
19:21:45 <pumpkin> monochrom tends to be a recurring theme of this channel
19:22:05 <Raevel> i have a function a -> a, and in it i have a local declaration where i want to use the same type, but it seems ghc treats it as a new type, how do i write the type?
19:22:29 <pumpkin> ?
19:22:32 <pikhq> Raevel: Is your function a -> a not pathological?
19:22:38 <pumpkin> Raevel: ScopedTypeVariables?
19:23:10 <pikhq> If so, then what you are writing is impossible.
19:23:17 <monochrom> sometimes you don't need a type sig in local declarations
19:23:29 <pikhq> As we all know, there is but one non-pathological function from a to a. And it is id.
19:23:30 <Raevel> pikhq: what does pathological mean?
19:23:33 <hatds> I assume Raevel is just simplifying the function's type for our sake, pikhq
19:23:33 <lpsmith> ok,  I have a type problem maybe somebody has some ideas about:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6558#a6558
19:23:50 <Raevel> i think pumpkin's suggestion solves it
19:23:58 <pikhq> hatds: I think I misparsed that, then.
19:24:00 <lpsmith> I understand approximately why that's going wrong;  but I'm curious how it can be fixed
19:25:18 <hatds> try removing the type signature
19:25:26 <monochrom> lpsmith: I think this helps: http://www.vex.net/~trebla/haskell/annote-STArray.xhtml
19:25:46 <Raevel> yeah it works if i remove the signature
19:26:56 <MissPiggy> :t let loop m = do m ; loop m
19:26:57 <lambdabot> <no location info>: not an expression: `let loop m = do m ; loop m'
19:27:01 <MissPiggy> :t let loop m = do m ; loop m in loop
19:27:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:27:12 <pumpkin> :t forever
19:27:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:27:29 <Raevel> anyway, scopedtypevars seems to not let me write it
19:27:41 <pumpkin> Raevel: you need an extra forall to bring the type variable into scope
19:27:51 <Raevel> oh
19:28:07 <MissPiggy> :t forkIO
19:28:07 <lambdabot> Not in scope: `forkIO'
19:28:13 <Raevel> there we go, thank you
19:28:16 <pumpkin> :)
19:28:25 <pumpkin> MissPiggy: forkBombing? :P
19:28:30 <monochrom> :t Control.Concurrent.forkIO
19:28:31 <lambdabot> IO () -> IO GHC.Conc.ThreadId
19:28:33 <MissPiggy> just bombing
19:28:45 <MissPiggy> I need forkIO :: MonadIO m => ...
19:28:46 <lpsmith> Raevel, really?  cause it doesn't work for me,  with any of ghc-6.12.1,  ghc-6.10.4,  or ghc-6.8.3
19:28:58 <pumpkin> lpsmith: I think he was talking about another problem :)
19:29:05 <lpsmith> oh :)
19:29:16 <lpsmith> sorry!
19:29:17 <Raevel> O_o
19:29:32 <pumpkin> o.O
19:31:40 <tommd> Anyone in here from Portland who hasn't heard of the potential Portland Hackathon in April should look at the -cafe and contact Creighton if the dates aren't good for you.
19:33:26 <MissPiggy> how can I get something that will be able to rpeacle fork?
19:33:48 <MissPiggy> I need: forkIO :: MonadIO m => m () -> m ThreadI, but it doesn't exist :~
19:34:00 <kmc> :t liftIO . forkIO
19:34:01 <lambdabot> Not in scope: `forkIO'
19:34:33 <MissPiggy> liftIO . forkIO :: MonadIO io => IO () -> io ThreadI
19:34:39 <MissPiggy> which is not useable here
19:35:47 <kmc> oh hmm
19:35:53 <kmc> yes, what you are asking for is not possible
19:36:06 <kmc> because m could be any fancy transformer stack
19:36:15 <kmc> you have to do it in the context of your transformer's "run" function
19:36:30 <cruton> Cthulhon||:
19:36:41 <cruton> who was it
19:37:03 <Cthulhon||> cruton: Don't spam this channel.
19:37:15 <cruton> im not spamming, you don't spam this channel
19:37:38 <lpsmith> monochrom, I don't think that helps
19:37:59 <lpsmith> I'm aware of that issue;  but this is a bit... different...
19:38:14 <cruton> [WTB]: d2 accounts!
19:38:19 <lpsmith> I can make it work if I don't generalize the Num type,  and put in say,  Int or Double
19:39:21 --- mode: ChanServ set +o monochrom
19:39:41 --- mode: monochrom set +b *!~62b7dd2b@*
19:39:47 --- mode: monochrom set -o monochrom
19:45:16 <lpsmith> hmm... I bet I could fix this with unsafePerformIO
19:45:38 <lpsmith> maybe
19:46:44 * pumpkin slaps lpsmith 
19:46:46 <pumpkin> bad!
19:47:27 <dolio> lpsmith: What if you put a type signature on newArray?
19:47:43 <lpsmith> pumpkin, but I don't know how to fix it otherwise,  and I'm pretty sure it'd be safe :o
19:47:47 <lpsmith> dolio, yes
19:48:03 <pumpkin> lpsmith: you tried monochrom's page?
19:48:09 <lpsmith> yep
19:49:39 <idnar> unsafeSpamIRC
19:50:14 <lpsmith> lol
19:50:42 <lpsmith> My code works if I change to STArray,  or instantiate with a concrete Num type,  like Int or Double
19:51:09 <lpsmith> But I can't polymorphically produce an unboxed array
19:51:48 <MissPiggy> argh!!!
19:52:00 <MissPiggy> I can't get this httpd to use MonadIO instead of IO
19:52:43 <dolio> Oh, right.
19:52:56 <dolio> Well, you can't put Integers in an unboxed array, for instance.
19:53:11 <lpsmith> right
19:53:50 <lpsmith> that's why I'm expecting some kind of ugly typeclass constraint
19:54:30 <dolio> It doesn't work even with the annotation and what you've got there?
19:54:38 <lpsmith> nope
19:54:56 <dolio> Oh right, 'cause of the s.
19:55:10 <lpsmith> well, something
19:55:36 <lpsmith> if you instatiate to a concrete numerical type,  and remove the typeclass constraint,  it works
19:55:58 <lpsmith> if you move to an boxed array and leave the typeclass in,  it works
19:56:22 <MissPiggy>       Expected type: InterpreterError
19:56:22 <MissPiggy>       Inferred type: IOError
19:56:24 <MissPiggy> omg -_-
19:56:34 <dolio> That's a pickle.
19:56:55 <dolio> You could try using IArray UArray e, but I doubt that will work.
19:58:02 <sshc> how do I find where an exception is being thrown?
19:58:19 <pumpkin> lpsmith: you have something weird going on
19:58:30 <dolio> Or making a new class "class UnboxedElem e ; instance (MArray (STUArray s) e (ST s)) => UnboxedElem e", but I wouldn't count on that working.
19:58:45 <lpsmith> hmm
19:58:45 <MissPiggy> is there a catch for MonadIO?
19:59:07 <lpsmith> actually, I should have thought of that,  but I didn't.   Thanks dolio!
19:59:27 <MissPiggy> catch :: Exception e => IO a -> (e -> IO a) -> IO a
19:59:31 <MissPiggy> that's the one there already is
19:59:51 <MissPiggy> but I have to have one,  (Exception e, MonadIO io) => io a -> (e -> io a) -> io a
19:59:58 <dolio> You can't lift catch with liftIO.
20:00:27 <dolio> So nothing exists, no.
20:00:36 <dolio> I think there's a proposal for a modified MonadIO somewhere.
20:00:37 <pumpkin> lpsmith: I don't think it can work actually
20:01:06 <lpsmith> well,  probably not,  but I'm trying it anyway because I haven't
20:01:13 <pumpkin> there's a disconnect between the MArray and IArray instances, and on the outside I think you can only have the IArray instance
20:01:22 <pumpkin> you can't really talk about s in totals'
20:01:27 <MissPiggy> class MonadIO m => MonadCatchIO m where	Source
20:01:27 <MissPiggy> Methods
20:01:27 <MissPiggy> catch :: Exception e => m a -> (e -> m a) -> m a
20:01:30 <MissPiggy> wow
20:01:57 <MissPiggy> this is the first bit of good luck
20:02:39 <Gracenotes> @type \a t -> Control.Exception.catch (liftIO a) (\x -> liftIO (t x))
20:02:40 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
20:02:53 <lpsmith> dolio, pumpkin,  yeah,  it doesn't work
20:03:02 <dolio> Yeah, I'm not surprised.
20:03:04 <pumpkin> lpsmith: trying something else, just a sec
20:03:06 <Gracenotes> :| I've fallen victim to some brain inference breakage
20:03:10 <lpsmith> neither am I, really
20:04:21 <Gracenotes> okay. liftIO is other way.
20:04:50 <Gracenotes> there's no standard interface for releasing MonadIO to IO. besides running it, for some transformers
20:04:56 <dolio> lpsmith: That's why the UA class in uvector is better.
20:05:16 <pumpkin> lpsmith: I think what I said is the actual reason it can't work, but I may be wrong
20:05:18 <MissPiggy> @instances Exception
20:05:18 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
20:07:11 <lpsmith> dolio, thanks for pointing out uvector,  I hadn't taken a look at that before
20:07:32 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16990#a16990
20:07:37 <MissPiggy> can anyone help me fix this error?
20:07:44 <MissPiggy>     Couldn't match expected type `InterpreterError' against inferred type `IOException'
20:07:56 <MissPiggy> I have no idea how to do it but I think if that is fixed then the whole thing should work
20:08:27 <MissPiggy> basically I try to catch an error from openBinaryFile, but on the other hand I want to catch errors from runInterpreter
20:11:07 <lpsmith> MissPiggy, code?
20:13:43 * MissPiggy doesn't understand how anyone can write haskell programs longer than a page of code
20:14:38 <pumpkin> if only MArray had been designed with an existing IArray constraint
20:15:28 <pumpkin> I'm pretty sure that would make it work
20:15:37 <pumpkin> at least the way I'm writing it
20:15:40 <MissPiggy> get rid of typeclasses from haskell
20:15:56 <ddarius> MissPiggy: You could use Helium.
20:16:26 <jmillikin> MissPiggy: this is sort of a bug in Haskell. There are two "catches" -- one works for all exceptions, the other just for IOError
20:16:26 <lambdabot> jmillikin: You have 1 new message. '/msg lambdabot @messages' to read it.
20:16:37 <MissPiggy> I think I'll just give up programming
20:16:44 <jmillikin> Use "import qualified Control.Exception as E .... E.catch"
20:17:29 <ddarius> MissPiggy: That's another option.
20:19:21 <pikhq> MissPiggy: ... Get rid of typeclasses? Say what?
20:20:59 <ivanm> why would you want to do such a thing?
20:21:25 <lpsmith> pumpkin, your intuition seems probable.
20:21:40 <lpsmith> Although I'm gonna guess that uvector will work
20:21:57 <lpsmith> actually, I'm pretty sure it will
20:22:13 <pumpkin> lpsmith: the way I was writing it, the outer type signature would be an IArray constraint, and if it were a superclass of MArray the knowledge would propagate
20:22:28 <pumpkin> but in the current state, GHC has no clue they have anything to do with each other
20:22:57 <jmillikin> ivanm: re your message, it's my understanding that compiling code with 'unsafePerformIO' in it requires the {-# NOINLINE #-} pragma and -fno-cse compiler flag.
20:23:11 <ivanm> jmillikin: what message are you talking about?
20:23:24 <jmillikin> You left me a lambdabot message like two weeks ago, I just got it
20:23:30 <ivanm> oh?
20:23:34 <ivanm> what was it? ;-)
20:23:39 <jmillikin> ivanm asked 11d 19h 21m 55s ago: wrt your comment on HN about unsafePerformIO: I wasn't aware that it needed special compile-time flags, etc. ...
20:24:02 <ivanm> jmillikin: I have unsafePerformIO in some code of mine, and I have no such pragmas or compiler flags...
20:24:06 <ivanm> and it seems to compile :s
20:24:08 <ddarius> jmillikin: Whether those flags are useful or not depends on what you are doing with unsafePerformIO
20:24:38 <jmillikin> ivanm: well, the docs say that compiling without them can give unpredictable results <http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html>, I don't think it'll make the compile fail or anything.
20:24:46 <ivanm> :o
20:25:03 <jmillikin> But the missiles might be launched twice ;)
20:25:42 <ivanm> heh
20:26:02 <ivanm> jmillikin: hmmm, didn't know about that :s
20:26:28 <ivanm> I'm just using unsafePerformIO to wrap around calling dot/neato/etc. :s
20:30:55 <jmillikin> Is there an arbitrary-precision decimal type, similar to Python's 'Decimal'? Closest I can find is 'Rational', but it's got very weird Show/Read instances.
20:31:08 <pumpkin> jmillikin: CReal
20:31:12 <pumpkin> in numbers (not Numbers)
20:31:35 <pumpkin> it's slow though, because it's infinite precision
20:32:01 <jmillikin> It doesn't have to be fast, I just need (show . read) == id
20:32:20 <pumpkin> well, it'll almost do that
20:32:27 <pumpkin> the default show instance doesn't show all digits
20:32:31 <pumpkin> you know, cause they're infinite :P
20:33:24 <ivanm> pumpkin: hmmm.... we need to define a new number type where "show pi" prints the greek character, etc.
20:33:31 <pumpkin> :P
20:33:47 <hiptobecubic> @src foldl
20:33:47 <lambdabot> foldl f z []     = z
20:33:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:33:59 <ivanm> and it should be able to tell if it's pi or not, so that 0 :+ - log (-1) will also print the greek character!
20:34:04 <ddarius> ivanm: That would be easy enough albeit it would likely break all the laws of Num and co.
20:34:18 <ivanm> ddarius: the second part wouldn't be as easy!
20:34:25 <ddarius> ivanm: No, not as easy.
20:34:35 <ivanm> > 0 :+ (- log (-1))
20:34:36 <lambdabot>   0.0 :+ NaN
20:34:44 <ivanm> bah, shouldn't that be pi?
20:34:51 <jmillikin> pumpkin: Do you know if there's a type which *will* show all digits? I don't need infinite precision, just arbitrary.
20:35:09 <ivanm> > log (-1) / (0 :+ 1)
20:35:10 <lambdabot>   (-3.141592653589793) :+ (-0.0)
20:35:27 <ivanm> I thought x / i == -i * x ...
20:35:42 <ddarius> jmillikin: If the precision is arbitrary then you need either a) to specify the desired result precision somehow or b) restrict yourself to things that have finite precision.
20:35:49 <jrockway> jmillikin: i needed arbitrary-precision floats recently, but just did everything with rationals
20:35:55 <ivanm> oh, wait, yeah, but that isn't just 0 :+ -x :s
20:36:00 <pumpkin> jmillikin: there's an mpfr binding on hackage
20:36:01 <jmillikin> ddarius: Ah, sorry, it is restricted to finite
20:36:03 <pumpkin> but I didn't like the API much
20:36:14 <ivanm> pumpkin: fine then, write a better one that you _do_ like!
20:36:23 <pumpkin> ivanm: I actually plan to :)
20:36:31 <pumpkin> after my mpn binding
20:36:37 <ivanm> heh
20:36:37 <jmillikin> I'm writing a parser, I would use float/double except that they would mean I couldn't use it for round-tripping
20:36:59 <ivanm> mpn == ?
20:37:03 <jrockway> also, rationals can be printed in ways other than "show"
20:37:04 <pumpkin> gmp naturals
20:37:12 <ivanm> ahhh
20:37:16 <jrockway> (there is the Numeric package, which has a few options IIRC)
20:37:17 <ivanm> why not just say gmp binding?
20:37:27 <ivanm> jrockway: s/package/module/
20:37:30 <pumpkin> ivanm: because that's too generic :P
20:37:31 <ivanm> Numeric is part of base
20:37:33 <ivanm> pumpkin: heh
20:39:24 <jmillikin> Ah bugger all, I'll just use Rational, if anybody wants it faster then they'll tell me
20:40:01 <lispy|web> hey
20:40:10 <ddarius> heay
20:40:11 <lispy|web> I've got some linker errors trying to build something from hackage
20:40:12 <ddarius> er heya
20:40:41 <lispy|web> I did, 'cabal install mage' and it complains about curses
20:41:33 <ivanm> lispy|web: heh
20:41:34 <lispy|web> I have some ncurses stuff in /usr/lib
20:41:53 <ivanm> oh, I thought that was a joke (mage and curses)
20:41:55 <lispy|web> ivanm: heh, no pun intended
20:42:28 <ivanm> @remember lispy I did, 'cabal install mage' and it complains about curses
20:42:28 <lambdabot> Done.
20:42:40 <lispy|web> heh
20:43:43 <ivanm> grrr.... I remember using some amsmath command in latex that lets you put a line of text in the middle of an environment without interrupting indentation, etc.
20:43:54 <ivanm> but now I can't recall what the command is or even where I used it to look it up :s
20:44:12 <lispy|web> hmm..., I bet that's in the book "Math Into Latex"
20:44:17 <lispy|web> but, I don't recall the command either
20:44:21 <lispy|web> Ask in ##latex
20:44:31 <ivanm> I could look up the manuals, but it's a PITA to get the pdfs and open them up
20:45:18 <ivanm> aha, it might be intertext!
20:46:08 <hiptobecubic> @src map
20:46:08 <lambdabot> map _ []     = []
20:46:09 <lambdabot> map f (x:xs) = f x : map f xs
21:03:06 <jmillikin> Is it just me, or did Haddock generate the GHC API docs incorrectly? FOr example, the parameter descriptions on 'bracket' <http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Abracket>
21:03:26 <pumpkin> nice
21:03:38 <pumpkin> looks pretty wrong to me
21:05:23 <monochrom> The source code is right. The html is wrong.
21:10:37 <tommd> If the comments and the code disagree then both are wrong.
21:11:47 <monochrom> the comments and the code agree. the html is wrong. my "source code" includes comments and haddock instructions and pragmas and #ifdef's and whitespaces and tabs.
21:22:08 <tommd> "If the documentation disagrees with the comments and code, but the tech-writer is the PHBs nephew then the programmer is wrong and must be fired."
21:25:38 <lpsmith> So why is Data.Vector.lastU an O(n) operation?
21:26:26 <lpsmith> oh, n/m
21:26:33 <dolio> Because the immutable vectors exported by uvector are mainly a target for stream fusion. At least, in one of the modules.
21:26:41 <lispy|web> This curses binding appears to be terminally broken
21:27:27 <pumpkin> the name overlaps in the various UVector modules are confusing
21:27:43 <pumpkin> especially when they have different time/space complexities
21:27:59 <dolio> If you use the stuff exported from Data.Array.Vector.UArr, they have array-like complexity, I think.
21:28:54 <lpsmith> hmm
21:29:03 <lpsmith> I also miss ix,  to a degree
21:29:40 <pumpkin> I'm still not too sure how I feel about Ix
21:29:49 <pumpkin> it feels very 9ey
21:33:25 <monochrom> @remember lispy|web This curses binding appears to be terminally broken
21:33:25 <lambdabot> I will never forget.
21:33:50 <monochrom> Heh. Generally, terminal emulations are terminally dying.
21:34:05 <lispy|web> So many puns tonight :)
21:34:23 <monochrom> @quote voluntarily
21:34:24 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
21:34:45 <lispy|web> What does the & do in a foreign import?
21:34:58 <lispy|web> for example:  foreign import ccall unsafe "curses.h & ACS_ULCORNER" acs_ulcorner :: Ptr ChType
21:35:23 <hiptobecubic> I'm having trouble understanding the difference between the
21:35:28 <hiptobecubic> & and . operators
21:35:54 <Cale_> hiptobecubic: &?
21:35:59 <lispy|web> It's undocumented as near as I can tell
21:36:07 <monochrom> One of them isn't in Prelude. That's the difference.
21:36:26 <hiptobecubic> Cale_, oops sorry. the $ and .
21:36:35 <Cale_> hiptobecubic: Okay
21:36:42 <hiptobecubic> They look very similar
21:36:47 <Cale_> (.) is defined by (f . g) x = f (g x)
21:37:08 <Cale_> So (.) takes two functions and produces another function
21:37:12 <monochrom> combining function call and parameter vs combining two functions
21:37:16 <Cale_> ($) on the other hand is
21:37:21 <Cale_> f $ x = f x
21:37:28 <lispy|web> Oh
21:37:34 <lispy|web> I think it asks for the address
21:37:52 <lispy|web> But then why does it also mention curses.h
21:38:05 <Cale_> So it takes a function and a value which is a suitable argument to that function, and applies the function to the argument.
21:38:44 <hiptobecubic> Cale_, so what is the point of it? Why not just write 'f x'
21:38:55 <Cale_> hiptobecubic: $ has very low precedence
21:39:02 <hiptobecubic> ah
21:39:05 <pumpkin> you can't use ' ' as an operator
21:39:13 <Cale_> So if you write  f . g . h $ x + y
21:39:25 <Cale_> it will mean the same thing as (f . g . h) (x + y)
21:39:36 <hiptobecubic> f(g(h(x+y))) ?
21:39:42 <Cale_> yeah
21:39:48 <c_wraith> see how many parens that has?  ewwww
21:39:58 <hiptobecubic> hmm
21:40:44 <Cale_> Now, what might have confused you about the difference between ($) and (.) is that ($) unfortunately associates to the right
21:40:50 <pikhq> The only thing worse is Lisp... (f (g (h (+ x y))))
21:40:50 <pikhq> :P
21:40:55 <Cale_> Rather than to the left like function application is supposed to
21:40:58 <hiptobecubic> I can see that it's going to take me a long time to learn to properly treat functions as commodities.
21:41:09 <domor> (define parens '(kind (of (cool (really)))))
21:41:34 <kmc> > map ($ 3) [succ, pred]
21:41:35 <lambdabot>   [4,2]
21:41:42 <kmc> ^^^^ there's a "non-syntactic" use of ($)
21:41:50 <kmc> in that it's not merely a stand-in for some parens
21:42:00 <kmc> we map the function "apply to argument 3" over a list of functions
21:43:05 <hiptobecubic> Cale_, meaning what exactly? f $ x $ y becomes....
21:43:18 <Cale_> f $ (x $ y)
21:43:24 <Cale_> which is f (x y)
21:43:38 <Cale_> rather than (f x) y, like f x y normally is
21:43:40 <hiptobecubic> why is that unfortunate?
21:43:42 <hiptobecubic> ah ok
21:43:57 <monochrom> \begin{application}\begin{function}f\end{function}\begin{parameter}\begin{application}\begin{function}g\end{function}\begin{parameter}x\end{parameter}\end{application}\end{parameter}\end{application}
21:44:14 <Cale_> And it's unfortunate because whenever you have something like f $ g $ h $ x, you can always replace the first two $'s with .'s anyway
21:44:21 <Cale_> f . g . h $ x is the same thing
21:44:26 * xerox shoots monochrom 
21:44:29 <hiptobecubic> Cale_, but isn't that sensible? $ seems to force the right to be evaluated first
21:44:40 <Cale_> It doesn't force any evaluation at all.
21:44:47 <pumpkin> hiptobecubic: don't think about first
21:44:52 <domor> watch out for the words 'force evaluation' in a lazy language
21:44:54 <pumpkin> (in haskell, in general)
21:45:03 <hiptobecubic> i see
21:45:20 <hiptobecubic> ... so it delays the left, shall we say?
21:45:25 <Cale> hiptobecubic: In f $ x = f x, neither parameter to $ is being pattern matched on, and there's no seq to be found
21:45:35 <Cale> So it doesn't force any evaluation of f or x
21:45:36 <pumpkin> hiptobecubic: we're not just trying to get around technicalities by saying that :P
21:45:43 <pumpkin> hiptobecubic: it actually starts outwards in
21:45:44 <hiptobecubic> pumpkin, :D
21:47:09 <hiptobecubic> so the definition of ($) seems more like     f $ x = f (x) than = f x
21:47:34 <pumpkin> except f (x) === f x :)
21:47:37 <domor> what's the difference?
21:47:43 <Cale> parens are only used for grouping
21:47:46 <domor> oh you're probably thinking like a macro
21:48:03 <pikhq> hiptobecubic: Functions are not C macros.
21:48:07 <pikhq> ;)
21:48:22 <Cale> hiptobecubic: Let's go over how lazy evaluation proceeds.
21:48:31 <Cale> I'll give my standard example
21:48:32 <hiptobecubic> I don't know C, so no worries there.
21:48:45 <Cale> Suppose that you have the function  double x = x + x
21:48:53 <Cale> and we want to evaluate  double (double 5)
21:48:55 <medfly> Cale loves double
21:49:02 <hiptobecubic> :P
21:49:17 <Cale> It's a good example for illustrating the various ways we can evaluate expressions :)
21:49:18 <domor> @quote double
21:49:18 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
21:49:31 <monochrom> Mean time between Cale double
21:49:41 <Cale> So, in strict evaluation, we have:
21:49:44 <Cale> double (double 5)
21:49:47 <Cale> -> double (5 + 5)
21:49:50 <Cale> -> double 10
21:49:52 <Cale> -> 10 + 10
21:49:54 <Cale> -> 20
21:50:03 <Cale> The evaluation is innermost-first.
21:50:13 <hiptobecubic> You are a much faster typist than I am, it seems.
21:50:28 <medfly> Cale's fingers are optimised to display evaluation strategies
21:50:29 <pikhq> hiptobecubic: Believe me, that's pasted by now. :P
21:50:31 <pumpkin> (this is not how haskell works)
21:50:33 <medfly> haha
21:50:35 <pumpkin> (by the way)
21:50:37 <Cale> nah, I didn't paste that :)
21:50:39 <hiptobecubic> but go ahead, i follow you
21:50:51 <Cale> Okay, so we could also evaluate the thing outermost-first.
21:50:55 <Cale> double (double 5)
21:50:56 <pumpkin> (just in case hiptobecubic missed Cale's thing about strict evaluation)
21:51:01 <Cale> -> (double 5) + (double 5)
21:51:02 <hiptobecubic> so "strict" is the obvious way that humans are taught in grade school
21:51:03 <hiptobecubic> sure
21:51:11 <ivanm> http://www.maa.org/devlin/devlin_02_10.html
21:51:14 <medfly> "obvious", I don't know.
21:51:21 <ivanm> ^^ interesting read
21:51:22 <Cale> Well, in grade school you don't necessarily always use the same order
21:51:32 <monochrom> since it has to be taught, it cannot be obvious
21:51:34 <ivanm> apparently, it is possible to be "over-educated"
21:51:39 <hiptobecubic> when you're taught order of ops
21:51:49 <Cale> hiptobecubic: Ah, this is different from precedence.
21:51:57 <pikhq> hiptobecubic: That's syntax.
21:52:07 <pumpkin> ivanm: apparently, the over-educated nympho would agree
21:52:10 <medfly> everything still has the same precedence. you just evaluate the expressions in a different order.
21:52:22 <Gracenotes> whar
21:52:27 <monochrom> yeah, school merged syntax and order together. could be separated out again.
21:52:28 <ivanm> pumpkin: the media said that, not the guy writing the blog post
21:52:39 <hiptobecubic> I understand that, but what I'm saying is that, for example
21:52:53 <medfly> (1+2)*3 could be evaluated into 3 * 3, or it could be evaluated into 1*3 + 2*3.
21:53:05 <medfly> you use both in school
21:53:09 <Cale> hiptobecubic: Or, for instance if you had f(x) = x^2 and g(x) = x+1, you might evaluate f(g(5)) by writing (g(5))^2 first, and then (5+1)^2, and then collapsing things from there
21:53:38 <hiptobecubic> if given a problem like 2 * ( 1 + 2),  the teacher will tell you to evaluate 1+2 and then multiply by two, not write (1+2) + (1+2) and do it that way.
21:53:43 <medfly> for example, it may be x+2 and not 1+2.
21:54:14 <monochrom> Cale's f,g example is more enligtening.
21:54:15 <Cale> Well, even applying the distributive law is something else here.
21:54:42 <Cale> It's all about what order we expand the definitions of functions
21:54:46 <Adamant> ivanm: depends on what metric you are using. if your goal is making money over your lifespan, then you can definitely be overeducated.
21:55:04 <Cale> Which is something that you don't usually talk about at all in elementary school or highschool.
21:55:05 <hiptobecubic> Cale, ok i see what you are you saying
21:55:16 <hiptobecubic> Cale, correct. Never once been mentioned to me.
21:55:20 <ivanm> Adamant: in this newspaper article that this guy quoted, if you have more than one degree you are over educated
21:55:24 <hiptobecubic> Cale, so what makes it 'lazy' or not?
21:55:28 <Cale> Okay, so to continue with the outermost-first reduction
21:55:31 <ivanm> so you have more than a simple bachelors degree and you're over educated
21:55:38 <Cale> (I'll get to lazy evaluation after that)
21:55:38 <pumpkin> damn straight
21:55:43 <Cale> double (double 5)
21:55:44 <medfly> ivanm, whoever said that clearly hasn't heard about MBAs ;)
21:55:45 <Cale> -> (double 5) + (double 5)
21:55:47 <pumpkin> elementary school is more than enough
21:55:50 <Cale> -> (5 + 5) + (double 5)
21:55:51 <medfly> or however they are called
21:55:54 <Cale> -> 10 + (double 5)
21:55:58 <ivanm> medfly: heh, it's a journalist
21:55:58 <Cale> -> 10 + (5 + 5)
21:56:01 <Cale> -> 10 + 10
21:56:02 <Cale> -> 20
21:56:08 <ivanm> ergo they have nfi what they're talking about! ;-)
21:56:12 <hiptobecubic> With all due respect, is there a haskell_offtopic somewhere?
21:56:17 <Cale> Notice that this wastes a lot of effort re-evaluating double 5 though.
21:56:19 <medfly> #haskell-blah
21:56:32 <Adamant> ivanm: I'll take my reply to -blah :P
21:56:45 <Cale> So lazy evaluation is a modification of outermost-first evaluation
21:56:56 <hiptobecubic> Cale, ok.
21:57:16 <Cale> it says that if a parameter to a function occurs more than once in the body of the function, then any results of evaluating one of the copies is shared amongst all of them
21:57:40 <Cale> So, if you'll permit me to use (let ... in ...) syntax to represent that sharing, it looks like:
21:57:43 <Cale> double (double 5)
21:57:43 <hiptobecubic> Cale, sure.
21:57:56 <Cale> -> let x = double 5 in x + x   -- note this is still outermost-first
21:58:03 <Cale> -> let x = 5 + 5 in x + x
21:58:06 <Cale> -> let x = 10 in x + x
21:58:11 <Cale> -> 10 + 10
21:58:12 <Cale> -> 20
21:58:40 <Cale> So, this saves us from evaluating the parameter more than once
21:58:53 <dolio> Instead of having expression trees, and implementing substitution by tree grafting, you use graphs.
21:58:55 <Cale> In strict evaluation, we always evaluate every parameter to a function once.
21:59:13 <Cale> In outermost-first evaluation, we evaluate each parameter zero or more times.
21:59:30 <hiptobecubic> Cale, how could it be 0?
21:59:33 <Cale> And with lazy evaluation, we get the best of both worlds -- evaluating each parameter at most once.
21:59:37 <Cale> (but perhaps not at all)
21:59:41 <dolio> \x y -> x
22:00:00 <Cale> Well, perhaps the function doesn't need the parameter to produce its result.
22:00:13 <hiptobecubic> i see
22:00:18 <Cale> (maybe just sometimes, depending on the values of the other parameters)
22:00:38 <kquick2> I'm confused by the "where" in this statement:  data G a b where { G1 { g1::a, g2::c } :: G a [c] }
22:00:40 <pikhq> (\x y -> x) 5 somethingThatTakesVeryLongToCalculate
22:00:42 <pikhq> -> 5
22:00:44 <kquick2> I would have expected = instead of where
22:00:51 <Cale> kquick2: That's GADT syntax
22:01:27 <monochrom> It is more powerful.
22:01:39 <kquick2> Is there a good place to learn about GADT?
22:01:59 <monochrom> I learned the gist from the ghc manual.
22:02:33 <hiptobecubic> Cale, ok so it doesn't evaluate a parameter until it needs to use it because rewriting it as a let ... in ... will drop the unnecessary parts
22:02:57 <Cale> kquick2: You might start from http://www.haskell.org/ghc/docs/6.8-latest/html/users_guide/data-type-extensions.html#gadt
22:03:30 <hiptobecubic> Cale, so how does that apply to $ again? Laziness, I mean.
22:03:31 <Cale> hiptobecubic: Yeah, let/in doesn't cause any evaluation of the defined things to happen automatically too.
22:03:43 <Cale> hiptobecubic: Well, if we look at f $ x = f x
22:04:00 <Cale> Supposing that we wrote something like  double $ 5
22:04:10 <kquick2> Thanks.  I'm also looking for references to explain: class Foo a b | a -> b where ...
22:04:14 <Cale> Or, better yet...
22:04:16 <Cale> double $ double 5
22:04:20 <kquick2> The | a -> b part.
22:04:38 <Cale> the very first step would be to rewrite that to double (double 5), anyway
22:04:49 <Cale> That is, to apply the definition of $
22:04:59 <mreh> can I get my haskell to run on both cores?
22:05:14 <hiptobecubic> Cale, that's what i said earlier :D
22:05:24 <hiptobecubic> f $ x = f (x)
22:05:27 <Cale> hiptobecubic: So, it doesn't affect the evaluation order
22:05:36 <Cale> f $ x = f x
22:05:47 <Cale> f (x) and f x mean the same thing
22:06:07 <hiptobecubic> Cale, sure, but double double 5 and double (double 5) don't
22:06:07 <Cale> (adding parens around the x doesn't affect anything)
22:06:11 <Cale> right
22:06:21 <Cale> because  double double 5  means  (double double) 5
22:06:30 <monochrom> kquick2: the ghc manual is not bad on that either. look for "functional dependency"
22:06:34 <hiptobecubic> so double $ double 5 => double (double 5)
22:06:47 <kquick2> Thanks.
22:06:50 <hiptobecubic> f $ x = f (x)
22:07:10 <Cale> hiptobecubic: Oh, if the parameter to a function consists of more than one lexeme, you'll have to put it in parens anyway
22:07:42 <hiptobecubic> Cale, lexeme?
22:07:44 <Cale> hiptobecubic: When you substitute something into the body of a function, you might wrap it in parens just to be safe.
22:07:51 <monochrom> perhaps the function has more lexemes.
22:08:13 <Cale> hiptobecubic: "word" perhaps :)
22:08:20 <monochrom> (if 5>1 then sin else cos) pi
22:09:01 <Cale> > if 5 > 1 then sin else cos $ pi
22:09:02 <lambdabot>   No instance for (GHC.Float.Floating (a -> a))
22:09:02 <lambdabot>    arising from a use of `GHC...
22:09:17 <Cale> maximal munch :)
22:09:19 <hiptobecubic> So is  double $ double 5 evaluated differently than double (double 5)?
22:09:33 <pikhq> hiptobecubic: There is one difference.
22:09:42 <pikhq> ($) is applied first.
22:09:44 <Cale> hiptobecubic: Only in that there's the first step which goes from double $ double 5 to double (double 5)
22:10:01 <Cale> Though the compiler will probably optimise that away anyway.
22:10:29 <hiptobecubic> Cale, but i thought $ had 'low' precedence? Why is it being applied first?
22:10:43 <Cale> Because it's the outermost thing.
22:10:43 <pikhq> hiptobecubic: Precedence has nothing to do with application order.
22:10:50 <pikhq> It has everything to do with parsing order.
22:11:03 <monochrom> Remember again: precedence and order are separated
22:11:09 <hiptobecubic> oh right
22:11:12 <Cale> Right, and precedence deals with what expression you're trying to evaluate, not what order you evaluate it in.
22:11:33 <Cale> Expressions are really trees (or, perhaps graphs)
22:11:53 <pikhq> Its low precedence means that "f $ 2 + 2" parses as "(f $ (2 + 2))", rather than "((f $ 2) + 2)".
22:11:54 <Cale> Precedence is about how you go from a piece of text to a tree
22:12:24 <Cale> Evaluation order is about how expression trees/graphs are turned step-by-step into other expression trees/graphs.
22:12:48 <pikhq> (or, to de-infix that, "($) f ((+) 2 2)" instead of "(+) (($) f 2) 2")
22:15:49 <hiptobecubic> Ok I think I have a better grasp on this now, perhaps
22:26:02 <mreh> what kind of complexity is divMod?
22:26:30 <mreh> I'm thinking linear
22:27:07 <monochrom> cubic
22:29:58 <kamatsu> In most cases, writing $ is like writing a ( where the $ is, and writing a ) at the end of the expression
22:30:17 <kamatsu> it just stops Haskell from looking too much like Lisp
22:30:19 <mreh> (55^2)^2
22:30:22 <mreh> > (55^2)^2
22:30:23 <lambdabot>   9150625
22:30:39 <hiptobecubic> @src foldl'
22:30:39 <lambdabot> foldl' f a []     = a
22:30:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:30:53 <mreh> hmm, I don't feel like storing 90 million doubles in memory
22:31:12 <hiptobecubic> @src seq
22:31:13 <lambdabot> Source not found. You type like i drive.
22:31:24 <hiptobecubic> :(
22:31:32 <det_> builtin ?
22:31:40 <kamatsu> it does it with magic
22:32:17 <kamatsu> this is where you start forcing evaluation order
22:32:19 <mreh> I have a 55 by 55 grid, I'm trying to find the optimum hamiltonian cycle round the vertices
22:32:44 <kamatsu> there is no logical way to write seq except in terms of other strictness annotations
22:32:50 <mreh> have to represent the solutions as permutations of node numbers so I can do crossover and mutation of the paths, but calculating the objective function is a killer
22:33:19 <mreh> translating a node number into i-j co-ordinates is cubic :X
22:33:47 <pikhq> kamatsu: Yeah. seq is magic.
22:34:03 <pikhq> hiptobecubic: Welcome to magic.
22:34:46 <mreh> it also lets you use it's left operand in the right operand, which is crazy!
22:35:02 <kamatsu> mreh: why is that crazy?
22:35:14 <kamatsu> it's seq, not par
22:37:06 <mreh> > 55^2
22:37:07 <lambdabot>   3025
22:37:15 <mreh> hmmm, hashtable time
22:37:49 <dmwit> 3000 is nothing in terms of memory.
22:38:22 <dmwit> Oh, just read back a bit.
22:38:35 <mreh> dmwit: 3000 words
22:38:41 <dmwit> So, uh, why do you have to represent solutions as permutations of node numbers?
22:38:46 <dmwit> Why not permutations of actual nodes?
22:38:47 <kamatsu> mreh: how long are the words?
22:38:58 <kamatsu> mreh: i like tries..
22:38:59 <dmwit> It seems like the crossover and mutation would be identical, no matter what you're permuting.
22:39:03 <vovik> anyone know how pattern matching (x:xs) is different from a let x = head xs?
22:39:03 <mreh> dmwit: what, like pointers?
22:39:05 <domor> > let loeb x = fmap ($ loeb x) x in loeb $ [(!!2), const 42, (!!1)]
22:39:06 <lambdabot>   [42,42,42]
22:39:18 <dmwit> 3000 words is still nothing.
22:39:28 <domor> this is interesting, are there interesting uses of loeb with other functors?
22:39:30 <dmwit> 6KB -- we have 4GB to throw around (typically)!
22:39:41 <kamatsu> vovik: in the first case, xs is the rest of the list, in the second, xs is all of the list and x is the head in both cases
22:39:49 <domor> > let loeb x = fmap ($ loeb x) x in loeb $ Just (const 3)
22:39:49 <lambdabot>   Just 3
22:40:01 <dmwit> vovik: The former can have another pattern for empty lists. ;-)
22:40:07 <vovik> kamatsu: i see, thanks
22:40:17 <mreh> they flew to the moon on 6kb!
22:40:32 <dmwit> Yep, but we don't have those constraints any more.
22:40:52 <dmwit> It's like saying they invaded Japan with muskets.
22:40:58 <dmwit> It's true, but it's still not the way you'd do it today.
22:41:09 <mreh> It wasn't meant to be a serious comment
22:41:17 <dmwit> urgh
22:41:24 <dmwit> sarcasm meter in the toilet, must be time for bed =)
22:41:45 <mreh> zzz
22:42:25 <vovik> detecting sarcasm on the internet is an undecidable problem
22:43:02 <domor> vovik: are you being sarcastic?
22:43:09 <c_wraith> I can't tell
22:43:20 <vovik> :D
22:43:32 <vovik> wouldn't you like to know
22:43:35 <c_wraith> no
22:43:56 <domor> if you told me I would still not know, that's all the problem :)
22:44:14 <mreh>   Map ()            b  := b
22:44:14 <mreh>   Map (Either a a') b  := (Map a b, Map a' b)
22:44:14 <mreh>   Map (a,a')        b  := Map a (Map a' b)
22:44:18 <mreh> what kind of notation is that?
22:45:28 <kmc> (:=) is an infix type constructor
22:45:30 <kmc> GHC extension
22:45:55 <mreh> oh, so it's actual haskel
22:46:06 <kmc> it's GHC Haskell
22:46:26 <mreh> but of course
22:48:45 <mreh> so, strategy for memoization: 1) is it already in the map, if not stick it in the map, 2) return the value
22:48:54 <mreh> how does this work in a purely functional context?
22:49:09 <kmc> it doesn't, really
22:49:21 <domor> > let loeb x = fmap ($ loeb x) x in loeb $ [(!!2), const 42, (!!0)]
22:49:26 <lambdabot>  Terminated
22:49:29 <kmc> your function is externally pure, so you might feel justified using unsafePerformIO
22:49:33 <kmc> but, there is potentially a better way
22:49:35 <dolio> In a purely functional context, you make a lazily-generated map.
22:49:37 <kmc> look at data-memocombinators in Haskell
22:49:39 <kmc> err Hackage
22:50:36 <domor> > let loeb x = fmap ($ loeb x) x in loeb $ [(!!2) * 100, const 42, (!!0) / 100]
22:50:37 <lambdabot>   No instance for (GHC.Real.Fractional ([a] -> a))
22:50:37 <lambdabot>    arising from a use of `...
22:51:52 <xerox> > let loeb x = fmap ($ loeb x) x in loeb $ [(100*) . (!!2), const 42, (`div` 100) . (!!0)]
22:51:54 <lambdabot>   [* Exception: stack overflow
22:52:01 <xerox> something's wrong though
22:52:09 <minike> Hi everyone I would like to request assistance from your webpage orszgotokba we find the views and give more to others as well as likely that I will be banned from getting a link in rktn http://gollszexcom.atw.hu/
22:52:12 <xerox> ah, 0 and 2, one should be 1
22:52:26 <xerox> > let loeb x = fmap ($ loeb x) x in loeb $ [(100*) . (!!1), const 42, (`div` 100) . (!!0)]
22:52:28 <lambdabot>   [4200,42,42]
22:52:48 <dmwit> mreh, kmc: I also keep a bookmark on this: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
22:52:53 <domor> I was playing around with it and wondering if it was like a search
22:53:52 <dolio> @type fix (fmap . flip id)
22:53:53 <lambdabot>     Occurs check: cannot construct the infinite type:
22:53:53 <lambdabot>       a = (f a -> f b) -> b
22:53:53 <lambdabot>     Probable cause: `id' is applied to too many arguments
22:54:05 <xerox> dolio it's pretty cool
22:54:57 <dmwit> :t fix (ap fmap (flip ($) . loeb))
22:54:58 <lambdabot> Not in scope: `loeb'
22:55:03 <dmwit> err
22:55:05 <dmwit> right
22:55:13 <xerox> err, domor
22:55:35 <dolio> @pl let y = fmap ($ y) x in y
22:55:35 <lambdabot> fix (flip fmap x . flip id)
22:55:52 <dolio> @pl \x -> let y = fmap ($ y) x in y
22:55:52 <lambdabot> fix . flip (fmap . flip id)
22:55:55 <domor> yes, it's good if you know the problem will be solvable
22:56:15 <domor> won't work for my sudoku toy though
22:56:30 <dmwit> :t fix (ap fmap . (flip ($) .))
22:56:31 <lambdabot>     Occurs check: cannot construct the infinite type:
22:56:31 <lambdabot>       a = (a -> a1) -> b
22:56:31 <lambdabot>     Probable cause: `.' is applied to too many arguments
22:56:35 <dmwit> eh
22:56:55 <minike> Hi everyone I would like to request assistance from your webpage orszgotokba we find the views and give more to others as well as likely that I will be banned from getting a link in rktn http://gollszexcom.atw.hu/
22:57:05 <domor> @pl loeb x = fmap ($ loeb x) x
22:57:05 <lambdabot> loeb = fix (fmap . flip id =<<)
22:57:10 <dmwit> ?pl \loeb x -> fmap ($ loeb x) x
22:57:11 <lambdabot> (fmap . flip id =<<)
22:57:14 <dmwit> too slow
22:57:16 <jayne> don't click that link, please
22:57:32 <domor> hehe
22:57:54 --- mode: ChanServ set +o xerox
22:58:14 --- mode: xerox set +b *!*@*.pool.t-online.hu
22:58:18 <pikhq> Didn't Freenode recently patch their IRCD to drop connections starting with POST?
22:58:29 --- kick: minike was kicked by xerox (minike)
22:58:37 * pikhq wgets to read
22:58:43 <dmwit> just frames
22:58:48 * dmwit got lazy after he saw that
22:59:36 <pikhq> Looks like porn spam.
22:59:51 <ulfdoz> hilight!
22:59:52 <pikhq> Nice change from exploits, at least.
23:00:01 <kmc> good porn or bad porn
23:00:05 <ivanm> heh
23:00:16 <pikhq> kmc: Porn ads.
23:00:28 <pikhq> In Hungarian.
23:03:44 <hiptobecubic> magic?
23:04:03 <pikhq> hiptobecubic: Yes. seq is magic.
23:04:22 <hiptobecubic> magic like no one wrote it so we can't look at it?
23:04:33 <pikhq> It's implemented in the compiler.
23:04:37 <dmwit> Magic like it can't be written in Haskell, only in the run-time system.
23:04:43 <pikhq> It cannot be written in Haskell.
23:04:48 <dmwit> It's not that we were lazy, it's just not possible. =)
23:05:09 <pikhq> undefined `seq` b is undefined. a `seq` b is b.
23:05:34 <monochrom> We are not lazy, we are just non-strict.
23:05:36 <pikhq> In a `seq` b, a is *evaluated*.
23:05:49 <pikhq> It forces strict evaluation of a specific term.
23:06:48 <dmwit> (non-productive infinite loops count as undefined here)
23:06:59 <dmwit> > fix id `seq` 3
23:07:03 <lambdabot>   mueval-core: Time limit exceeded
23:07:04 <dmwit> > fix (1:) `seq` 3
23:07:05 <lambdabot>   3
23:08:12 <pikhq> dmwit: Well, yeah. What other value does it have?
23:09:47 --- mode: ChanServ set +o monochrom
23:09:51 --- mode: monochrom set -b *!~62b7dd2b@*
23:09:55 --- mode: monochrom set -o monochrom
23:10:59 <kmc> you can write type specializations of seq in Haskell
23:11:08 <kmc> seq True a = a; seq False a = a
23:11:13 <kmc> there's a seq :: Bool -> a -> a
23:12:04 <kmc> seq x y = case x of { each constructor of x -> y }
23:12:06 <hiptobecubic> hmm
23:12:16 <kmc> the magic part of the actual "seq" is doing this polymorphically in the type of x
23:12:36 <kmc> seq (Just v) x = x; seq Nothing x = x
23:13:17 <kmc> note that seq (Just v) x = seq v x would evaluate more
23:13:23 <kmc> that's the sort of recursive eval you get with rnf
23:14:49 <hiptobecubic> hahaha... learnyouahaskell's idea of an example:
23:14:52 <hiptobecubic> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
23:14:52 <lambdabot>   "GAYBALLS"
23:14:54 <pikhq> kmc: Mmm, right... Yeah, you can get non-polymorphic seq simply by forcing the pattern match. Never occured to me to use that for seq, though.
23:16:37 <monochrom> The best education is through good laughs. :)
23:17:59 <mreh> hmm, if only I could memoize a function
23:18:11 <mreh> a HOF
23:18:26 <mreh> oh wait! I can
23:21:51 <kmc> using the left operand in the right operand is the same as any function
23:21:53 <kmc> e.g. a + (a + b)
23:25:17 <Argue> ok BONUS, last frigging chapter
23:25:27 <ivanm> what's the term for when you have a function that keeps growing faster and faster?
23:26:23 <QtPlatypus> ivanm: At what rate?
23:26:50 <koala_man> superlinear?
23:27:19 <domor> hmm, if I want to get a subsequence with the indexes eg. [1,4,52,80] of a sequence, is there a function for that?
23:27:24 <olsner> is it the function or the value of it that's growing?
23:27:46 <ivanm> QtPlatypus: well, it's (1-x^2)^(-1/2)
23:27:57 <ivanm> so I'm not sure what to call it :s
23:28:28 <QtPlatypus> I would normally just talk about its growth via big O notation.
23:28:50 <ivanm> QtPlatypus: ummm... it's meant to be first year science students talking about what a plot looks like... ;-)
23:28:50 <mreh> what's wrong with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17007#a17007
23:29:11 <ivanm> i.e. no big O ;-)
23:29:22 <ivanm> mreh: what's the error?
23:29:42 <mreh> ivanm: none, it just doesn't work as expected :(, no memoization
23:29:43 <ivanm> uuuugghhh.... "memoize"? really?
23:29:56 <koala_man> domor: not that I know of, but you can do map (yourlist !!) [1,4,52]
23:30:27 <mreh> ivanm: it's basically unsafePerformIO
23:30:38 <Cale> mreh: That's because divMod' is a function binding
23:31:16 <ivanm> mreh: well, don't!
23:31:17 <Cale> mreh: So when you apply it like  divMod' 15 3
23:31:30 <Cale> you get  memoize (memoize . divMod $ 15) 3
23:31:50 <ivanm> wouldn't you memoize the application on the tuple?
23:31:54 <Cale> and the memoized versions of the involved functions get used once and thrown away
23:32:27 <mreh> Cale: that's what I suspected, I don't understand how to do it
23:32:31 <Cale> Where is that memoize function from? I recommend Data.MemoCombinators
23:32:49 <mreh> Cale: I stole it from a blog
23:33:13 <Cale> import qualified Data.MemoCombinators as Memo
23:33:40 <Cale> divMod' = Memo.memo2 Memo.integral Memo.integral divMod
23:33:43 <mreh> ivanm: well, divMod' n will only be used with the same n for the entire program, so it make sense
23:33:50 <Cale> ah
23:34:07 <domor> koala_man: thanks. I settled for fromList $ map (index myseq) myindexes
23:34:20 <mreh> > divMod 15 3
23:34:21 <lambdabot>   (5,0)
23:34:27 <mreh> not n
23:34:39 <mreh> divMod n m will be used always with the same m
23:35:16 <Cale> That's unfortunate.
23:35:38 <Cale> (It's better for the parameters to be the other way around in that case)
23:36:30 <mreh> divMod' = Memo.memo2 Memo.integral Memo.integral (flip divMod) ?
23:36:54 <Cale> Well, if you're memoising on both, it doesn't matter so much.
23:38:12 <Cale> At least, I don't think it will...
23:39:06 <monochrom> If you always use the same m, check out "montgomery multiplication"
23:43:24 <mreh> just anything to make it a decent complexity, it's currently polynomial
