00:14:30 <dmwit> aww, I was hoping --# LANGUAGE MultiParamTypeClasses was going to work
00:15:54 <shachaf> > (--#)
00:15:55 <lambdabot>   Unfortunately not.
00:16:01 <dmwit> =)
00:17:19 <dmwit> > let a -# b = "hey" in {-# but this could be the opening of a block immediately followed by an operator! -} "there"
00:17:20 <lambdabot>   "there"
00:18:31 <RLa> dmwit, thanks, i got cabal installed
00:18:39 <dmwit> cheers
00:20:09 <emef> what is the ! notation when used with a type? i'm seeing this line: data Vec = Vec !FloatType !FloatType !FloatType and i haven't seen the ! before
00:20:18 <dmwit> It's a strictness annotation.
00:20:29 <emef> hm?
00:20:43 <dmwit> It means that if, at any time, you ask whether a Vec uses the Vec constructor, it will compute the FloatType arguments before answering.
00:21:11 <tensorpudding> can you use if/then/else in a do block?
00:21:11 <dmwit> Unlike the usual lazy behavior, where it won't compute the FloatType arguments until you actually ask for them, too.
00:21:13 <emef> as opposed to being lazy?
00:21:17 <emef> ok
00:21:20 <emef> thanks
00:21:22 <dmwit> tensorpudding: Sure, but the "then" and "else" need to be indented more.
00:21:28 <tensorpudding> okay, thought so
00:21:52 <dmwit> tensorpudding: H2010 fixes that, I think.
00:25:42 <cads> Hey, I've got a question about ghc.. I've got ghc 6.10.4, which came with the haskell platform here on windows. A nice feature is cabal, but the only thing so far that I've tried to get with cabal has failed - I was trying to build lambdabot and it needs to be built by hand with directions from the website
00:26:40 <cads> does this reflect immaturity in ghc 6.10, or in lambdabot's code?
00:27:07 <dmwit> This reflects (the opposite of immaturity) in lambdabot's code.
00:27:14 <dmwit> "legacy-ness", maybe
00:27:36 <dmwit> \bot predates cabal-install, and maybe even predates cabal
00:27:42 <cads> should I use an older version of ghc if I want to have fewer problems with cabal?
00:27:57 <dmwit> No, I don't think so.
00:34:48 <dmwit> ?index guard
00:34:48 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:37:40 <freiksenet> how can one convert Char to Word8 for bytestring?
00:37:43 <SubStack> yay I can substitute terms out of my crappy multivariate polynomial dsl
00:37:54 <dmwit> freiksenet: Check the "encoding" package on Hackage.
00:38:08 <freiksenet> dmwit: ok, thanks
00:38:50 <ben> @src fmap
00:38:50 <lambdabot> Source not found. There are some things that I just don't know.
00:38:54 <ben> @src return
00:38:54 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:39:02 <ben> @src (>>=)
00:39:02 <lambdabot> Source not found. It can only be attributed to human error.
00:39:03 <dmwit> ?src [] fmap
00:39:04 <lambdabot> fmap = map
00:39:08 <dmwit> ?src [] (>>=)
00:39:09 <lambdabot> xs >>= f     = concatMap f xs
00:39:16 <freiksenet>  basically need to split bytestring to lines, but 'lines' doesn't  seemto work.
00:39:18 <dmwit> ben: They're class functions. =)
00:39:33 <freiksenet> so I though of converting \n to word8 to do that
00:39:37 <ben> dmwit: Honestly I only wanted to get lambdabot to insult me
00:39:42 <dmwit> heh
00:39:55 <ben> @hoogle lines
00:39:56 <lambdabot> Prelude lines :: String -> [String]
00:39:56 <lambdabot> Data.List lines :: String -> [String]
00:39:56 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
00:40:05 <freiksenet> hm, strange
00:40:16 <ben> Note the Char8
00:40:31 <freiksenet> ok, now I see
00:40:32 <freiksenet> thanks
00:40:33 <dmwit> freiksenet: I'm having trouble reconciling this need with your previous question; are they related?
00:40:42 <freiksenet> dmwit: no longer, thanks anyway
00:40:43 <ben> > fromEnum $ '\n' :: Word8
00:40:44 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
00:40:44 <lambdabot>         against inferred type...
00:40:50 <ben> aw
00:41:03 <dmwit> > toEnum . fromEnum $ '\n' :: Word8
00:41:04 <lambdabot>   10
00:41:19 <dmwit> But that is extremely unsafe.
00:41:22 <dmwit> For example...
00:41:34 <dmwit> > toEnum . fromEnum $ '\1500'
00:41:35 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
00:41:40 <dmwit> > toEnum . fromEnum $ '\1500' :: Word8
00:41:41 <lambdabot>   * Exception: Enum.toEnum{Word8}: tag (1500) is outside of bounds (0,255)
00:41:43 <ben> > toEnum . fromEnum $ 'λ' :: Word8
00:41:44 <lambdabot>   * Exception: Enum.toEnum{Word8}: tag (955) is outside of bounds (0,255)
00:41:54 <dmwit> Encoding is the only way. =)
00:42:11 <ben> It is reasonably safe if you only need '\n'
00:42:29 <dmwit> I very much doubt he has *only* '\n' in his String.
00:42:41 <savonarola> what is the simpliest way to show variable's type in ghci?
00:42:44 <dmwit> Or else "lines" wouldn't do anything very interesting. =)
00:42:48 <freiksenet> I will just use Char8 and it's lines
00:42:54 <dmwit> savonarola: Use ":t x"
00:43:02 <dmwit> savonarola: Where "x" is the name of the variable. =)
00:43:12 <dmwit> savonarola: You can check the type of more complicated expressions the same way.
00:43:15 <savonarola> thaks, that is it
00:43:18 <freiksenet> sorry, not yet so familiar with standard library
00:43:40 <dmwit> This is frustrating.
00:43:58 <dmwit> There's map :: (a -> b) -> (Map a v -> Map b v)
00:44:26 <dmwit> and adjust :: Ord k => (a -> Maybe a) -> k -> (Map k a -> Map k a)
00:44:48 <dmwit> but no mapAdjust :: Ord k => (a -> Maybe a) -> (Map k a -> Map k a)
00:45:14 <iamrandom> I love you ?DCC SEND STARTKEYLOGGER'
00:45:39 <cads> Hmm, someone on twitter writes "The biggest problem I have with Haskell is that you can't really edit your data types without also editing every single related function."  <- ths seems like what type classes help prevent?
00:46:10 <dmwit> Can an op please ban iamrandom for a short time?
00:47:43 <RLa> cads, i think it is at least partially solved with open types
00:47:43 <dmwit> Oh, there's mapMaybe, perfect!
00:49:38 <nainaide> A little confuse on basic CGI , thanks for any help. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21291#a21291
00:51:47 <dmwit> nainaide: When the browser sends a value for "name", the (getInput "name") action returns a Just value.
00:52:20 <dmwit> nainaide: Oh, I see what you're asking.
00:52:27 <nainaide> dmwit, thanks for your help :)
00:52:28 <dmwit> I think you maybe just haven't worked out how CGI works yet.
00:52:51 <dmwit> When you run this CGI, the *entire program* gets run twice: once before you've input a name, and once after.
00:53:05 <dmwit> The first time, the action returns a Nothing, so you get a "greet" page.
00:53:19 <dmwit> s/greet/inputForm/
00:53:35 <dmwit> The second time, the action returns a Just, so you get a "greet" page with the value from the "name" form.
00:53:58 <dmwit> Does this help?
00:54:04 <dmwit> i.e. it's not "resuming" at all
00:54:34 <nainaide> dmwit,  great! btw, It is because runCGI, did the cgiMain run in twice?
00:54:44 <dmwit> No, it's because of how CGI works.
00:54:54 <dmwit> Your web server runs this entire program each time you request this CGI page.
00:55:09 <dmwit> When you submit a form, that's a second request for the page... just with more information available. =)
00:55:49 <nainaide> dmwit, Understood, thank you!!! web server runs this entire program each time, got it.!!!
00:56:12 <Sagi> how do I apply a list of functions to a value, with each subsequent function using the previous result as input?
00:56:20 <SubStack> yay associativity works in my little dsl for multivariate parameterization hooray
00:56:21 <dmwit> :t foldr (.) id
00:56:22 <lambdabot> forall b. [b -> b] -> b -> b
00:56:41 <dmwit> :t msum . map Endo
00:56:41 <lambdabot>     No instance for (MonadPlus Endo)
00:56:42 <lambdabot>       arising from a use of `msum' at <interactive>:1:0-3
00:56:42 <lambdabot>     Possible fix: add an instance declaration for (MonadPlus Endo)
00:56:45 <dmwit> whoops
00:56:49 <dmwit> :t mconcat . map Endo
00:56:50 <lambdabot> forall a. [a -> a] -> Endo a
00:56:53 <dmwit> aw
00:57:03 <dmwit> :t appEndo . mconcat . map Endo
00:57:04 <lambdabot> forall a. [a -> a] -> a -> a
00:57:44 <cads> RLa, care to expand a bit? Heh, looking up open types just reminded me that I'm a bit confused between type families and type classes.
00:59:41 <cads> An example of a type class is Eq, where each type that is declared a member of Eq must have a  (==)  function written for it, correct?
01:00:50 <cebewee> cads: yes
01:01:19 <cads> is it likely that I already know a simple example of a type family?
01:01:23 <freiksenet> https://gist.github.com/bba3048dbd8962ffbd23 I wonder where I have this expected type Char here :(
01:01:57 <Sagi> dmwit: I gather that is the answer to my question, but which one should I use?
01:02:21 <Sagi> I know some haskell basics and have written some small programs, but I'm quite new to the higher level stuff.
01:02:49 <dmwit> Sagi: Pick your favorite of the two, or write your own. =)
01:03:47 <dmwit> (The middle two were mistakes and don't count. ;-)
01:09:33 <freiksenet> so, no idea where I have char there? I am stuck, cause it shouldn't be a char there :( https://gist.github.com/bba3048dbd8962ffbd23
01:09:48 <freiksenet> sorry for buggin you so much :/
01:10:00 <quicksilver> freiksenet: what is the type of B.words?
01:10:22 <freiksenet> ByteString -> [ByteString]
01:10:44 <dmwit> Maybe more telling, what is the type of B.map?
01:10:59 <quicksilver> yeah, B.map is incompatible with B.readInt
01:11:09 <freiksenet> ok, so it should be a normal map
01:11:23 <dmwit> I'm not sure I see where that error is coming from, though.
01:11:32 <dmwit> oh
01:11:42 <dmwit> Data.ByteString.Char8.map takes a (Char -> Char) argument.
01:11:44 <dmwit> still
01:11:48 <freiksenet> ok, now it works
01:11:53 <freiksenet> it was B.map
01:11:55 <freiksenet> thanks a lot guys
01:12:04 <dmwit> It should be something like "Can't match (Char -> Char) vs. (ByteString -> Int)."
01:17:01 <Sagi> packetbuilder fs i = fst $ foldr (.) id fs i -- I should be able to get rid of the double "fs i", right?
01:17:33 <dmwit> ?pl \fs i -> fst $ foldr (.) id fs i
01:17:33 <lambdabot> (fst .) . foldr (.) id
01:17:45 <dmwit> But there's no reason to, really.
01:18:00 <dmwit> Maybe the first level is idiomatic, but the second probably isn't.
01:18:05 <dmwit> i.e. I might write
01:18:13 <dmwit> packetbuilder fs = fst . foldr (.) id fs
01:18:27 <dmwit> But going fully point-free is probably uglier here than going fully pointed. =)
01:18:47 <Sagi> hmm okay
01:18:57 <dmwit> style question
01:19:03 <dmwit> Feel free to agree or disagree with me. =)
01:19:05 <Sagi> I find it difficult to determine which one is nicer :)
01:22:02 <cads> hmm, in an error message setting like that, is there any way to tell it to go ahead any spit out the types of the functions that are involved?
01:22:49 <dmwit> cads: Start sticking in undefined's.
01:23:07 <dmwit> cads: You can also help yourself a lot by annotating things with the types you meant them to have.
01:23:42 <sizur> is filter not a catamorphism? if not, why?
01:24:39 <dmwit> ?src filter
01:24:39 <lambdabot> filter _ []     = []
01:24:40 <lambdabot> filter p (x:xs)
01:24:40 <lambdabot>     | p x       = x : filter p xs
01:24:40 <lambdabot>     | otherwise = filter p xs
01:25:07 <dmwit> Usually "catamorphism" is used to mean *the* catamorphism -- i.e. foldr in the case of lists.
01:25:11 <dmwit> I think.
01:25:16 <dmwit> I haven't actually read about them.
01:25:20 <theorbtwo> @hoogle .&.
01:25:21 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
01:25:25 <cads> in this case he was using the map function as defined in the B module, right, dmwit? But if  B.map's type had been printed as part of the message he would have said 'woah woah wait a sec', without having to think about diving into the module's documentation to check the types
01:26:02 <dmwit> cads: You can of course check types in ghci.
01:26:09 <theorbtwo> OTOH, a ghc error message already tends to be quite long.
01:26:24 <dmwit> cads: Again, the way to check types of things in your file is to simply stick in "undefined" for anything that doesn't type-check.
01:26:39 <sizur> folds are obviously catamorphisms.  i'm interested in what king of morphism is filter.
01:26:50 <sizur> kind*
01:26:58 <sizur> somebody yesterday said maybe surjective
01:29:17 <Cale> sizur: It's a special case of foldr, so it's a catamorphism.
01:29:57 <sizur> Cale thanks, that was my guess :) good to confirm
01:30:04 <Cale> filter p = foldr (\x xs -> if p x then x:xs else xs) []
01:30:05 <cads> it's a catamorphism where the accumulated value is a list which grows longer with each successful match of the filter
01:30:35 <quicksilver> I think 'filter is constructed from a catamorphism' is quite a different statement from 'filter *is* a catamorphism'
01:30:44 <quicksilver> catamorphisms are universal constructions.
01:30:53 <quicksilver> filter is not a universal construction in a simple way
01:31:23 <cads> is it a http://en.wikipedia.org/wiki/Paramorphism ?
01:31:28 <sizur> so its a combination of cata and anamorphisms then?
01:33:38 <theorbtwo> Is there a way already in parsec to take a parser, and a value, and return another parser that suceeds only when the parser returned the given value?
01:33:46 <theorbtwo> required :: GenParser Char st a -> a -> GenParser Char st a
01:33:59 <sizur> so paramorphism or metamorphism
01:35:16 <sizur> no, cannot be metamorphism as thereis no anamorphism.  more like a fold + map?
01:36:38 <cads> sizur, I think quicksilver is talking about a universal construction as in a unique function that we can show exists with math theory
01:37:04 <quicksilver> theorbtwo: not a builtin one as far as I can think. It's easy enough to write.
01:37:41 <quicksilver> theorbtwo: required p x = do pv <- p; if (pv == x) then return x else fail "required"
01:38:00 <quicksilver> theorbtwo: (adds an Eq a => constraint over the sig you gave)
01:38:23 <theorbtwo> Oh!
01:38:41 <theorbtwo> I knew everything there, too, I just wasn't putting it together.
01:39:35 <cads> quicksilver, do correct me on this if I'm wrong, but I'm kind of thinking that there's basicall only one catamorphism on lists, and that is the fold.. but it seems like folding in different orders makes a difference if the function you're folding the list over is not associative.
01:40:58 <cads> So maybe there are actually as many catamorphisms as there are ways to turn lists into trees?
01:41:34 <cads> This would be for lists.
01:43:46 <Cale> foldr is *the* catamorphism for lists
01:43:54 <quicksilver> cads: depends what abstraction you think lists are.
01:44:13 <quicksilver> cads: if a list is just an ordered sequence of elements then, yes, there are multiple possible catamorphisms depending how you parcel up the elements.
01:44:35 <quicksilver> cads: if you think list is the precise recursive data type of form "data List a = Nil | Cons a (List a)"
01:44:38 <quicksilver> cads: then there is only one.
01:44:54 <quicksilver> cads: it is a canonical construction from the data defintion.
01:45:36 <cads> That makes perfect sense - the fold only has one way to "grab" that recursive data structure
01:45:55 <Cale> The catamorphism for an algebraic datatype is a function which replaces its constructors with other functions/values.
01:46:09 <Cale> (recursively, throughout the structure)
01:46:28 <quicksilver> but you can, for example, model lists rather clumsily using something like
01:46:41 <quicksilver> data List a = Nil | One a | Append (List a) (List a)
01:46:53 <quicksilver> that's is the same 'semantic' list
01:46:56 <quicksilver> but it's concretely different
01:47:02 <quicksilver> and would have a different catamorphism
01:47:15 <quicksilver> because the catamorphism is a property of the way we choose to define our data, syntactically
01:48:02 <Cale> foldList n o a = f where f Nil = n; f (One x) = o x; f (Append xs ys) = a (f xs) (f ys)
01:48:54 <cads> That indeed would seem to apply the catamorphism as if the list were a tree.
01:48:56 <Cale> length = foldList 0 1 (+)
01:49:20 <Cale> Because it is a tree.
01:50:19 <quicksilver> it's a funny kind of tree which has both "empty leaves" and "labelled leaves"
01:50:28 <quicksilver> and it's isomorphic to list
01:53:21 * ski thinks concatenation being associative is part of the meaning of lists
01:54:54 <quicksilver> ski: good point. I had an intended equivalence relation in mind.
01:55:21 <quicksilver> ski: I intended that Append (One x) Nil be equivalent to Append Nil (One x) and various other things like that
01:55:38 <quicksilver> but as is typical for such things, that wasn't visible in the data type.
01:55:39 <ski> *nod*, unit laws
01:55:46 <quicksilver> well adn the association one you allude to.
01:57:14 * ski wonders what free moufang loops looks like
01:58:49 <cads> thanks for clarifying that, quicksilver, cale
02:14:25 <cads> tolist :: List a -> [a] ;   tolist Nil = [];  tolist (One a) = [a]; tolist (Append x y) = (tolist x) ++ (tolist y)   -  this seems like a surjection from the funky branched List data type into the plain old lists
02:15:46 <quicksilver> cads: yes, that was my intended "semantic" for the type.
02:16:19 <quicksilver> cads: but as ski was pointing out, my type didn't declare that (Append Nil (One x)) and (Append (One x) Nil) were supposed to be considered equivalent
02:16:32 <theclaw> in real world haskell, "Monads are for controlling the order of evaluation." is listed under "misconceptions", why?
02:16:54 <quicksilver> still, that's quite a common property of 'complex' data types, that there are multiple ways of representing something we consider the same.
02:17:03 <quicksilver> it's true of most binary trees etc.
02:19:07 <cads> quicksilver, that took me some serious brain sweat to write out, at first I was trying tolist Nil (One a) = [a], tolist (One a) Nil = [], and couldn't figure out where to go from there :)
02:19:30 <quicksilver> :)
02:19:31 <cads> the [] should be [a]
02:19:58 <Cale> theclaw: because they don't control the order of evaluation
02:19:59 <quicksilver> theclaw: because they sequence effects, but not evaluation.
02:20:03 <cads> but still, I couldn't figure out how my two argument tolist function should break down an Append
02:20:24 <Cale> theclaw: Then encode a certain kind of "execution order" which means different things in different monads, and is separate from the order of evaluation.
02:20:51 <theclaw> okay, thanks
02:21:04 <Cale> Well, not always *completely* separate, of course, but not the same thing, certainly.
02:21:34 <dmwit> > evalState undefined (get >> return 3)
02:21:35 <lambdabot>   Ambiguous type variables `m', `a' in the constraint:
02:21:35 <lambdabot>    `Control.Monad.Stat...
02:21:52 <Cale> Evaluating an IO action, for example, does nothing visible.
02:21:56 <dmwit> :t evalState
02:21:57 <lambdabot> forall s a. State s a -> s -> a
02:21:59 <Cale> Only executing it has an effect.
02:22:26 <dmwit> > (evalState :: State () Int -> () -> Int) undefined (get >> return 3)
02:22:27 <lambdabot>   Couldn't match expected type `()' against inferred type `m t'
02:22:29 <theclaw> Cale: but why isn't the order of evaluation the same as the order of execution?
02:22:37 <dmwit> oh
02:22:44 <dmwit> > evalState (get >> return 3) undefined
02:22:45 <lambdabot>   3
02:22:50 <dmwit> theclaw: There's an example.
02:23:18 <dmwit> theclaw: The effects of "get" are guaranteed to happen before the effects of "return 3", but the evaluation order may not be what you expect.
02:23:24 <ment> hmm how can i make an instance of class for non-data-construtor type?
02:23:32 <Cale> theclaw: Well, let's consider an example in the list monad... something like  do x <- map (*2) [1..3]; y <- map (*10) [1..5]; return (x+y)
02:23:40 <dmwit> (In particular, the get doesn't produce the exception you might expect.)
02:24:07 <Cale> theclaw: The order in which the two lists we're selecting elements from are evaluated isn't quite the same as the execution order -- it jumps back and forth between the two lists.
02:24:33 <Cale> > do x <- map (*2) [1..3]; y <- map (*10) [1..5]; return (x+y)
02:24:34 <lambdabot>   [12,22,32,42,52,14,24,34,44,54,16,26,36,46,56]
02:24:55 <dobblego> is there a library to parse a .cabal file, particularly for "Exposed-Modules" and load them all into ghci?
02:25:48 <theclaw> Cale: what is "execution order" exactly?
02:26:23 <theclaw> Cale: does it mean that "x" is accessible in the second action?
02:26:40 <cads> quicksilver, I was just noting that the list 1:2:3:[]  does not actually represent an equivalence class including things like  1:2:Nil:3:[] and 1:Nil:Nil:Nil:2:3:[], even though our List structure could easily represent trees that would read that way from right to left and be equivalent, and indeed there could be a list structure that has Nil in the representation even as a linear list.. heh, I'm not saying anything that's not pretty trivial, either :)
02:26:42 <Cale> theclaw: Basically the order in which the actions are chained together by >>=
02:27:34 <Cale> So in "execution order" we have that first x is selected from map (*2) [1..3]
02:27:42 <Cale> and then y is selected from map (*10) [1..5]
02:27:48 <Cale> and then we return (x+y)
02:28:18 <Cale> But evaluation doesn't follow that route so directly
02:28:36 <Cale> Sure, first we pick x as the first element of map (*2) [1..3], which is 2
02:28:46 <Cale> and then y as the first element of map (*10) [1..5], which is 10
02:28:56 <Cale> and then 12 becomes the first element of the result
02:29:28 <Cale> but when the next element of the result is demanded, we go back and pick the next element of map (*10) [1..5], which is 20, making the next element of the list 22
02:29:52 <Cale> and so on, until we exhaust those choices, and the second list becomes fully evaluated along the way
02:30:05 <Cale> and then finally we continue the evaluation of the first list
02:30:24 <Cale> picking another element from it, and pairing it with each of the elements of the second list (which is already fully evaluated)
02:30:41 <theclaw> Cale: okay, so the "effects of an action" are ordered, and the effects of an action is what gets passed between >>=?
02:31:04 <Cale> Well, "effects" in the most general possible sense.
02:31:18 <Cale> There are some really weird notions of "effects" :)
02:31:45 <Cale> Already in the list monad, you see that "effects" has to encompass nondeterminism, where each action has multiple (or no) results
02:32:17 <Cale> and there are things like the reverse state monad, where the state flows in the opposite direction from the execution order
02:32:59 <Cale> So that you can get something, and then put it, and what you got before will be what you put later (easy to write infinite loops this way)
02:33:27 <Cale> But it's even possible to write sensible things in that monad...
02:33:45 <Cale> do xs <- get; put (1:xs); return xs
02:33:53 <Cale> this will produce an infinite list of 1's
02:34:04 <Cale> er
02:34:10 <Cale> silly me
02:34:11 <ski> theclaw : in the case of the list monad, if you think of an action there as basically collecting results from a nested loop, then the monadic sequencing corresponds to the *nesting* of the loops (not the order things are evaluated, which goes back and forth)
02:34:27 <james> Hello all
02:34:33 <Cale> er, no, that was right
02:34:40 <Cale> (doubting myself, it's late :)
02:34:49 <blazemore> Hello all
02:34:59 <Cale> hello
02:35:19 <blazemore> I'm looking for a haskell developer to do a really simple program using recursion. If possible it should be well documented
02:35:34 <blazemore> I will pay a small amount of money, it shouldn't take longer than 10 mins
02:35:34 <SubStack> -_-
02:35:36 <theclaw> Cale: that reverse state monad is weird ;)
02:35:47 <Cale> theclaw: yeah :)
02:35:58 <blazemore> Plz email me modestforagenius@googlemail.com if you are interested and I will send you the (very simple) spec
02:36:01 <Cale> blazemore: "using recursion"?
02:36:06 <Raynes> *cough* homework
02:36:12 <ben> Can you post the specs on a pastebin
02:36:28 <blazemore> @Raynes A little bit, yes but I don't have grounds for an extension and I'll fail otherwise.
02:36:28 <lambdabot> Unknown command, try @list
02:36:42 <blazemore> Also thats why I would like it to be well documented
02:36:48 <blazemore> So I can see what's going on
02:36:54 <dmwit> This sounds more than a little bit unethical.
02:36:56 <blazemore> I joined the course too late really
02:36:59 <SubStack> you could always... learn enough to complete the assignment
02:37:04 <blazemore> It's totally unethical yes
02:37:23 <blazemore> Okay I'll paste the spec, maybe you can give me some pointers anyway?
02:37:24 <SubStack> lambdabot: lyah
02:37:24 <Cale> blazemore: Why don't you just learn enough to finish the assignment? You're welcome to ask any questions about the language here.
02:37:30 <Raynes> I don't do homework for people. I bitch at them until they do it themselves.
02:37:34 <SubStack> blarg, whichever bot that is
02:37:51 <dmwit> blazemore: You should be careful about using your real name in here. Your prof might be in this channel.
02:37:55 <Cale> @where lyah
02:37:56 <lambdabot> http://www.learnyouahaskell.com/
02:38:02 <theclaw> ski, Cale - where's the source code for >>=/return für the list monad? can't find it right now
02:38:19 <Cale> theclaw:
02:38:22 <ski> theclaw : `xs >>= f = concatMap f xs'
02:38:24 <Cale> return v = [v]
02:38:35 <dmwit> ?src [] return
02:38:36 <lambdabot> return x    = [x]
02:38:50 <Cale> xs >>= f = concat (map f xs) -- ski beat me to it, but what the heck :)
02:39:23 <theclaw> hmm, okay, but generally, how do I find the source?
02:39:27 * ski waits for dmwit's contribution :)
02:39:33 <dmwit> ?where prelude
02:39:33 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
02:39:37 <theclaw> I can't seem to find it with hoogle
02:39:38 <Cale> theclaw: well, for that one you could look in the Prelude.
02:40:16 <theclaw> okay ;)
02:41:36 <ski> preflex: seen lunabot
02:41:36 <preflex>  lunabot was last seen on #haskell 18 days, 3 hours, 18 minutes and 50 seconds ago, saying:  31
02:42:30 <blazemore> http://pastebin.com/m718f2de6
02:42:34 <blazemore> ^ That's the spec ^
02:44:00 <blazemore> http://pastebin.com/d7182c602
02:44:57 <Cale> blazemore: Ah, you're in Graham Hutton's course?
02:45:00 <freiksenet> that's quite an easy task IMO
02:45:35 <freiksenet> even from point of view of a person who started haskell yesterday :/
02:46:39 <SubStack> ouch
02:46:48 <Cale> Well, it's a solid exercise for someone who started yesterday
02:47:08 <freiksenet> okay, I have a lisp background, it is different for me of course.
02:47:42 <freiksenet> it is just that most of the functions are one liners.
02:47:51 <Cale> yeah
02:49:20 <Cale> http://www.cs.nott.ac.uk/~gmh/funcwk1.pdf
02:49:25 <Cale> ^^ the pdf version
02:49:31 <blazemore> lol wd cale
02:49:42 <blazemore> dude
02:49:50 <blazemore> did you have hutton?
02:50:01 <Cale> Nah, but I'm familiar with his text.
02:50:14 <Cale> Also, from the mailing lists, and sometimes he's on this channel.
02:50:22 <blazemore> Look I totally suck as Haskell
02:50:24 <freiksenet> :) epic fail
02:50:37 <blazemore> *at
02:50:43 <blazemore> His book is excellent
02:51:00 <Raynes> You don't "suck at Haskell". You "don't know Haskell, and are too lazy to learn" ;)
02:51:00 <Cale> So, what do you have so far?
02:51:05 <blazemore> OK I retract my offer of cash for solutions
02:51:15 <blazemore> And I simply ask for guidance
02:51:32 <Raynes> A quick read through LYAH over night should give you what you need to complete the task at hand.
02:51:34 <blazemore> Well I would be able to do it in another language like python
02:51:41 <Raynes> Even just part of LYAH, I imagine.
02:51:56 <blazemore> I guess I'd go through each character of the string, compare it to the last character and add 1 to a counter each time
02:52:00 <blazemore> But Haskell is different
02:52:09 <freiksenet> blazemore: read LYAH.
02:52:23 <Cale> It is quite different.
02:52:25 <freiksenet> you need first 3-4 chapters to solve this task.
02:52:34 <Cale> Though, you could essentially do it that way.
02:52:38 <freiksenet> it explains functional programming quite well
02:52:47 <Cale> There's a bit of a problem with this sequence of exercises as I see it...
02:52:57 <Cale> chomp isn't the nicest thing to use to define runs
02:53:20 <theclaw> Cale: is the order of execution in the state monad the same as the order of evaluation, for example?
02:53:21 <freiksenet> I'd say chomp is not really needed.
02:53:25 <Cale> What you really want is a function which splits a string into the first run, and then the rest of the string, and use *that* to define runs
02:53:28 <blazemore> He specifies it
02:53:34 <Cale> theclaw: hmm, not quite
02:53:36 <blazemore> We have to do it that way
02:53:42 <Cale> theclaw: But it's more closely related.
02:54:02 <Raynes> Get a better professor. :>
02:54:25 <Cale> Well, I'd expect Graham to be a pretty decent professor :)
02:54:43 <blazemore> He is
02:54:44 <Cale> blazemore: Have you written chomp?
02:54:48 <blazemore> No
02:54:53 <theclaw> Cale: why not?
02:54:55 <blazemore> tbh I don't know where to start
02:55:00 <blazemore> I just transferred to this course
02:55:17 <Raynes> Start at LYAH.
02:55:22 <blazemore> So I have only been to one lecture, although I'm working my way through exercises in the book
02:55:29 <blazemore> I might just ask him for an extension
02:55:29 <Cale> theclaw: well, evaluation is a bit funny -- the state itself can go unevaluated for a long time if nothing pattern matches on it
02:55:44 <Cale> blazemore: That's probably reasonable, if you just transferred.
02:56:34 <freiksenet> blazemore: what is the deadline?
02:56:43 <theclaw> Cale: okay, because of lazy evaluation. maybe it's not a good idea to compare execution and evaluation at all
02:56:49 <Cale> theclaw: yeah
02:57:25 <blazemore> Deadline's not for a little while
02:57:28 <blazemore> 3rd March
02:57:29 <Cale> theclaw: There's a sort of logical order in which things 'happen' which is the execution order, and then there's the order in which the computer figures out the result of everything that happened, which is almost completely separate :)
02:57:42 <Cale> blazemore: Oh, you'll be fine.
02:57:52 <blazemore> :-)
02:57:57 <Cale> blazemore: Just learn the basics of the language.
02:58:12 <blazemore> OK I will go through the book and do EVERY excercise
02:58:23 <blazemore> It will be difficult because I have given up caffiene for Lent
02:58:23 <Cale> feel free to ask questions
02:58:34 <Raynes> If you can't manage this task by March 3rd, I might just have to recommend dropping out of school. :p
02:58:44 <blazemore> Right I'll come back here if I have anything specific
02:58:52 <Raynes> Screw Lent... Caffeine is much more important. :o
02:58:55 <blazemore> lol
02:59:04 <blazemore> No I'm trying to give up on my addiction to it
02:59:21 <blazemore> Anyway I'll get on with this
02:59:51 <Raynes> Good luck, new sir. :D
03:00:53 <SubStack> it's Lent?
03:01:57 <SubStack> I didn't know people still did that
03:02:34 <Raynes> I gave up scratching my n... Noggin. >.>
03:02:46 <theclaw> SubStack: where I live in bavaria, today (ash wednesday) almost nobody eats meat
03:04:42 <Cale> blazemore: If you were allowed to use library functions, it's possible to do the whole first half of the assignment in 2 lines.
03:04:58 <Cale> (just list processing stuff :)
03:05:32 <ment> why is instationing non-data-constructor types disabled in ghc by default?
03:05:45 <Cale> ment: hm?
03:05:47 <Raynes> Did somebody say... LISt Processing? ((((()))))!! :D
03:06:04 <ment> Cale: instation MyClass String where ...
03:06:16 <Cale> ment: Oh, instance?
03:06:16 <integral> "instation" isn't a haskell keyword
03:06:20 <ment> (All instance types must be of the form (T t1 ... tn) where T is not a synonym. ...
03:06:36 <Cale> ment: Yeah, Haskell 98 was super-conservative about typeclasses
03:06:57 <cebewee> blazemore: At least chomp should be doable fairly easy. If you know enough of haskell to compute the length of a list, you know enough to do chomp.
03:07:00 <Cale> ment: You can switch on various extensions to relax the rules :)
03:07:10 <ment> Cale: what's the verb for making instance? :)
03:07:45 <ski> "instantiate", i suppose
03:07:49 <savonarola> i want to generate sequence  [[],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0]....   (binary representations of integers). Is there a smartier way tj do this than: let bins = ( [] : map (  \n -> concat(  [ (bins !! ( n `div` 2 ) ), [ if ( odd n ) then 1 else 0 ] ] )  ) [(1::Int)..] )
03:09:26 <Cale> > [0..] >>= flip (replicateM [0,1])
03:09:27 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:09:27 <lambdabot>         against inferred type ...
03:09:30 <Cale> er
03:09:38 <Cale> > [0..] >>= flip replicateM [0,1]
03:09:38 <lambdabot>   [[],[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0]...
03:09:53 <Cale> oh, I see
03:10:29 <Cale> (you want something slightly different :)
03:10:51 <savonarola> hm, great
03:12:21 <Cale> > [] : map (1:) ([0..] >>= flip replicateM [0,1])
03:12:22 <lambdabot>   [[],[1],[1,0],[1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1],[1,0,0,0],[1,0,0,1],[1,...
03:12:34 <Polarina> o.O
03:12:39 <ski> > fix $ \ns -> [] : [b:n | n <- ns , b <- [0,1]]  -- not quite this, either
03:12:40 <lambdabot>   [[],[0],[1],[0,0],[1,0],[0,1],[1,1],[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1]...
03:12:59 <ski> Cale : nice :)
03:13:17 <cebewee> @pl \x -> (f x, g x)
03:13:18 <lambdabot> liftM2 (,) f g
03:13:29 <cebewee> :t ,
03:13:30 <lambdabot> parse error on input `,'
03:13:33 <cebewee> :t (,)
03:13:34 <lambdabot> forall a b. a -> b -> (a, b)
03:13:34 <ski> (but i still wonder how to do it without counting ..)
03:14:01 <ment> :t replicateM
03:14:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:14:02 <adu> ment: but we don't use the word "instantiate" here...
03:14:13 <yowgi> Hello !
03:14:18 <Cale> It's probably the fixed point of something nice...
03:14:28 <cebewee> hm, i never realized before that (,) is just a data constructor, like (:)
03:14:30 <yowgi> is there a way to write (a -> b) -> (c -> d) -> (a, c) -> (b, d) with functions from Control.Arrow?
03:14:32 <ment> adu: it's considered profane?
03:14:57 <Cale> yowgi: (***)
03:15:02 <Cale> :t (***)
03:15:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:15:10 <freiksenet> is it possible to have 'or' in function pattern match?
03:15:13 <ski> @type \f g -> (\x -> f x) *** (\y -> g y)
03:15:14 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
03:15:16 <adu> ment: no, just tradition, because there isn't any "new" keyword, most people end up talking about "constructors" instead of "instantiation"
03:15:25 <Cale> freiksenet: nope
03:15:39 <freiksenet> Cale: sucks :/ what about Not?
03:15:44 <yowgi> Cale, thanks :)
03:15:47 <ski> freiksenet : unfortunately, Haskell doesn't have that. try the MLs (i don't recall which had this as an extension)
03:16:12 <freiksenet> that's a pity :(
03:16:17 <ski> indeed
03:16:19 <freiksenet> what is a haskellian way to do that then?
03:16:22 <adu> ment: at least in relation to Haskell
03:16:36 <theorbtwo> :t (,)
03:16:37 <lambdabot> forall a b. a -> b -> (a, b)
03:16:37 <ment> adu: instance Monad Maybe where ... is constructor for Maybe?
03:16:42 <Cale> freiksenet: Well, you can use let/where with case
03:16:54 <theorbtwo> Hm, but that definition doesn't allow you to make a (a, b, c)
03:17:12 <adu> ment: oh, I would call that an implementation of Monad
03:17:13 <Cale> freiksenet: which will at least let you common up the definition of whatever's on the right hand sides
03:17:33 <Cale> :t (,,)
03:17:34 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
03:17:35 <adu> ment: because that isn't an instance, its a definition of what it means to be an instance
03:17:59 <freiksenet> Cale: are there anonymous types in haskell? Can I do where something = type?
03:18:02 <adu> ment: so I don't use the word "instance" even tho Haskell uses that word, its not very apt
03:18:21 <Cale> freiksenet: I don't think I understand
03:18:26 <freiksenet> https://gist.github.com/8099c410cff7193b35ba
03:18:27 <ment> adu: ok
03:18:37 <ski> freiksenet : O'Caml (maybe SML/NJ, too) .. see <http://rosettacode.org/wiki/Pattern_matching#OCaml> (Haskell version just above)
03:18:57 <Cale> freiksenet: Do you mean type variables?
03:19:01 <theorbtwo> Cale: On the other hand, you *don't* use the (,,) operator to make a triplet.
03:19:10 <theorbtwo> Tuples are special.
03:19:11 <Cale> freiksenet: oh, I see
03:19:20 <freiksenet> Cale: I dunno the terminology
03:19:25 <Cale> freiksenet: No, you have to define the types which data constructors belong to
03:19:28 <freiksenet> just anonymous type, so I can declare it inline like lambda
03:20:16 <adu> ment: "instance Monad Maybe..." doesn't define a constructor for Maybe, "data Maybe a = Nothing = Just a" is what defines constructors for Maybe. "Nothing" is a constructor and "Just" is a constructor, but "Monad" is a typeclass...
03:20:22 <Cale> It would be nice to have types which had smaller scopes than a module, but no, we don't have those.
03:20:53 <Phyx-> It would also be nice to be able to hide instances from being exported
03:21:10 <ski> freiksenet : actually, what you're trying to do there is define a pattern `NonEmpty' which matches whenever one of `Wall',`You',`Enemy' matches .. which would not be the same as a locally defined datatype
03:21:20 <Cale> freiksenet: In any case, you couldn't write a function whose parameter was of a type which was defined locally to the function.
03:21:49 <Cale> (because the type would appear in that function's type signature then)
03:22:16 <freiksenet> Cale: okay. case pattern matching does have an or, doesn't it?
03:22:22 <freiksenet> or it is the same?
03:22:26 <Cale> freiksenet: no, it's the same
03:22:42 <Cale> Surprisingly, this doesn't come up too often
03:22:53 <freiksenet> :/ annoying.
03:22:56 <ment> adu: well, now some of the ghc error messages make sense :)
03:23:04 <adu> ment: so "instance Monad Maybe" would be an implementation of Monad, for Maybe
03:23:11 <Cale> You can't use an OR for patterns reliably in any case where the variables bound would be different
03:23:23 <ski> Cale : i don't think you can factor out `T R (T B a x b) y (T B c z d)' from the right-hand sides in the haskell code at the above rosettacode link .. except by defining a function that abstracts over the free variables of the patterns .. which is not as good as one'd like
03:23:32 <Cale> and usually patterns bind distinct variables, so there's not much opportunity to OR them
03:23:40 <ment> btw what's that "forall" keyword for?
03:24:04 <Cale> ment: It just makes explicit the fact that the type variables range over all types.
03:24:20 <freiksenet> https://gist.github.com/8099c410cff7193b35ba this is how I solve it I guess?
03:24:29 <Cale> ment: By moving the forall around, you can get different meanings
03:24:35 <ski> i think in OCaml, an or-pattern binds the intersection of the variables bound by each branch
03:25:00 <ski> (where each variable is required to have the same type in each branch, obviously)
03:25:11 <Cale> ment: for example  (forall a. a -> a -> a) -> String -> String  is a function which takes a function parameter that's required to be polymorphic
03:25:31 <cebewee> @type map (lift2 (,) length head) . group
03:25:32 <lambdabot> Not in scope: `lift2'
03:25:37 <cebewee> @type map (liftM2 (,) length head) . group
03:25:38 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
03:25:48 <freiksenet> thanks guys
03:26:05 <Cale> ment: while forall a. (a -> a -> a) -> String -> String  would work for any type a, so you could pass it a function (Int -> Int -> Int)
03:26:08 <ment> Cale: what do you mean polymorphic? isn't it definition of type that has for some a first argument function a->a->a?
03:26:11 <theorbtwo> Oh!  That explains a bit about the error I got about a *rigid* type variable.
03:26:14 <cebewee> @let f = map (liftM2 (,) length head) . group
03:26:15 <lambdabot>  Defined.
03:26:25 <cebewee> Hm. Why does ghci does not like this definition?
03:26:58 <cebewee> (and complains about an missing instance of (Monad ((->) [a]))?
03:27:20 <ment> Cale: ok, i think i understand
03:27:24 <Cale> ment: Normally, if you leave them out of your type signatures, Haskell automatically forall's all the type variables at the outermost level
03:27:37 <ski> ment : in `foo :: (forall a. a -> a -> a) -> String -> String', `foo' can only be bassed a polymorphic functions -- disregarding partial functions, the only possibilities in this case are `const' and `flip const'
03:27:42 <idnar> cebewee: :m + Control.Monad.Instances
03:28:22 <ski> (.. or, if you prefer, `\x y -> x' and `\x y -> y')
03:29:23 <cebewee> idnar: thanks
03:29:34 <idnar> cebewee: or use liftA2, I guess
03:29:38 <Cale> freiksenet: You could also just write:
03:29:45 <Cale> isPassable Empty = True
03:29:49 <Cale> isPassable _ = False
03:29:49 <idnar> I'm not really sure what the point of having those instances in C.M.I is
03:30:39 <cebewee> ok, now the monomorphism restriction is biting me
03:30:54 <Cale> idnar: The function instance for Functor and Monad should be in the Prelude, but they're not :/
03:31:27 <zygoloid_> > (\xs -> zipWith (flip const) xs (takeWhile (==head xs) xs)) "aaaaaaabbbbcc"
03:31:28 <lambdabot>   "aaaaaaa"
03:31:39 <adu> ment: simply put polymorphic means it has something to do with typeclasses, and the types of polymorphic things usually looks like (x :: ... => ...)
03:31:53 <Cale> Orphan instances are kind of annoying -- it's good that we can write them, but usually they indicate less than ideal library layouts.
03:32:18 <freiksenet> Cale: indeed, thanks :)
03:32:31 <Cale> (That is, instances which are neither in the module defining the type or the module defining the class)
03:32:38 <Cale> nor* ;)
03:32:47 <ski> adu,ment : no, polymorphic doesn't (need to) have anything with type classes to do
03:33:04 <m0nkfish> zygoloid_ what's with the zipwtih?
03:33:09 <adu> ski: i know, you can have polymorphic with "data"
03:33:21 <zygoloid_> m0nkfish: protecting against empty lists
03:33:27 <m0nkfish> ah
03:33:31 <zygoloid_> > let compress = (uncurry (:) . (head &&& show . length) =<<) . group in compress "aaaaabbbcc"
03:33:32 <lambdabot>   "a5b3c2"
03:33:38 <ski> adu : huh .. maybe you meant to say that data types can be parameterized ?
03:33:54 <adu> it makes them change :)
03:34:01 <adu> in many ways :)
03:34:06 <adu> poly-morphic
03:34:17 <ski> anyway, the `Either' type is not polymorphic, it is parametric
03:34:27 <ski> the `either' function, however, is polymorphic
03:34:30 <adu> ski:  what about the Printf type?
03:34:30 <ski> @type either
03:34:31 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:34:43 <Cale> ski: Yeah, that tree balancing example is a really good example of where it's nice to have or-patterns.
03:34:59 <Cale> ski: Though it's somewhat rare to run into that.
03:35:04 <ski> adu : that's constrained polymorphic, so in that case type classes are involved, yes .. not i said "need to" above
03:35:23 <ski> Cale : to run into what ?
03:35:45 <ski> (*sigh* s/not i/note i/)
03:35:49 <Cale> ski: Lots of patterns having the same result, but binding the same parameters in different structures
03:36:17 <ski> Cale : agreed. i still thing we ought to have or-patterns, though :)
03:36:37 <Cale> What should the syntax be?
03:37:09 <ski> possibly e.g. `codiag (Left a | Right a) = a'
03:37:28 <ski> .. or will that clash with guards in some cases ?
03:38:08 <zygoloid_> > let decode = concat . (zipWith3 id (cycle [flip (replicate . digitToInt),const (const "")]) `ap` tail) in decode "a5b3c2"
03:38:09 <lambdabot>   "aaaaabbbcc"
03:38:15 <Peaker> ski: or-patterns that must capture into the same names?
03:38:20 <Peaker> ski: the exact same set of names, that is?
03:38:31 <ski> Peaker : either that, or you just take the intersection
03:38:44 <Peaker> (Left (a,b) | Right c) = (a,b,c)  -- will contain 1 or 2 bottoms?
03:38:55 <ski> that would be illegal :)
03:39:27 <theorbtwo> You are thinking (Left (a, b)
03:39:45 <domor> > let compress = (uncurry (:) . (head &&& show . length) . group in compress "aaaaaaaaaaaaaaaaaaaaa"
03:39:45 <theorbtwo> (Left (a, b) | Right b) ?
03:39:46 <lambdabot>   <no location info>: parse error on input `in'
03:39:52 <ski> e.g., yes
03:39:57 <ben> So codiag (Left a | Right a) = would be equivalent to codiag (either id id -> a)?
03:40:10 <domor> > let compress = (uncurry (:) . (head &&& show . length =<<) . group in compress "aaaaaaaaaaaaaaaaaaaaa"
03:40:11 <theorbtwo> Why not just (Left (_, b) | Right b), if that doesn't let you use a?
03:40:11 <lambdabot>   <no location info>: parse error on input `in'
03:40:11 <ski> ben : yes
03:40:11 <Peaker> how about: (Left (a,b) | Right a) = (a, b) ? If this is also disallowed... then why not forbid the "b" to appear in the first place: (Left (a,_) | Right a) -- in which case, I think it's nicer to just compose catamorphisms
03:40:47 <zygoloid_> fromMaybe a (Just b | const a -> b) = b
03:40:50 <Peaker> I wonder about a points-free language as rich as Haskell, with some more combinators to make points-freedom less painful
03:41:20 <ski> though one could argue that one could strike out the uncommon variables with `_' .. but it might be useful with patterns like `either id id -> a' (i forget what they're currently called)
03:41:46 <domor> zygoloid_: I failed at copy-paste, but anyway the spec said a maximum of 9 characters per run
03:41:53 <Peaker> ski: view patterns?
03:41:56 <ski> yes
03:42:22 <ski> (i think of them as "transformational patterns", since that's what they were called in an earlier paper discussing basically the same idea)
03:42:25 <ski>   foo (Left a | Right (b,foo b -> Just a)) = ..a..
03:42:29 <zygoloid> domor: no, the spec said "there's no need to worry about runs longer than 9 characters." :)
03:42:32 <Dark_Shikari> how do I take all values in a list starting at position X?  Like the equivalent of &list[X] in C.
03:43:06 <ski> in that example, `b' is only bound locally in the right branch of the or-pattern, but is passed to `foo' for possibly good use in the view pattern
03:43:11 <Botje> Dark_Shikari: drop
03:43:23 <Dark_Shikari> ah k
03:43:23 <Dark_Shikari> works
03:43:30 <ski> theorbtwo : ok ?
03:44:00 <domor> zygoloid: oh you're right. could be changed with a splitAt and some murking anyway.
03:44:23 <zygoloid> yeah. though that might make it harder to write in such a terse fashion :)
03:44:33 <theorbtwo> ski: Er, I'm afraid I've lost you.
03:44:58 <domor> I like it :)
03:45:16 <ski> theorbtwo : the pattern `Left a | Right (b,foo b -> Just a)' would only bind the variable `a', but the local binding for `b' there is still useful, thanks to the view pattern
03:45:30 <ski> theorbtwo : have you met view patterns before ?
03:45:31 * hackagebot upload: Agata 0.1.1 - Generator-generator for QuickCheck (JonasDuregard)
03:45:35 <theorbtwo> I have not.
03:45:38 <wto> sweet
03:45:56 <ski> the basic form of a view pattern is `<expression> -> <pattern>'
03:46:09 <ski> consider e.g.
03:46:58 <ski>   eval env (Var id) = case lookup env id of
03:47:16 <ski>     Just val -> val
03:47:21 <medfly> > let compress = map (\(a:as)->(length as, a)) . group in compress "aaaaaaabbbb"
03:47:22 <ski>     Nothing  -> Var id
03:47:22 <lambdabot>   [(6,'a'),(3,'b')]
03:47:40 <ski> using a view pattern, that could be written as
03:48:02 <ski>   eval env (Var (lookup env -> Just val)) = val
03:48:14 <ski> leaving the other case to a default clause like
03:48:30 <ski>   eval env val = val
03:49:19 <ski> theorbtwo : so, when a value `Val 42' is matched against `Var (lookup env -> Just val)', the constructors match, and we continue matching `42' with the view pattern `lookup env -> Just val'
03:49:50 <ski> theorbtwo : and to do that, we match `lookup env 42' with `Just val' (which will either fail, or bind the variable `val')
03:50:00 <ski> ok ?
03:50:12 <theorbtwo> Got it, I think.
03:50:36 <Phyx-> > (*)
03:50:37 <lambdabot>   -3->
03:50:37 <lambdabot>    {-3->9;-2->6;-1->3;0->0;1->-3;2->-6;3->-9}
03:50:37 <lambdabot>  -2->
03:50:38 <lambdabot>    {-3->6;-2->4;-1...
03:50:39 <medfly> domor, does that work
03:50:54 <ski> so my point was just that if we have view patterns, then there is a point to allowing a variable `b' to be bound locally in one branch of an or-pattern
03:51:20 <ski>   Left a | Right (b,..a..)
03:51:27 <theorbtwo> Gotcha.
03:51:51 <theorbtwo> It does feel like putting things that are really code in your type system... but I expect I'd get over it pretty quick.
03:52:19 <ski> (.. why in the *type* system ?)
03:52:27 <zygoloid> > let compress = (concatMap (uncurry (:)) . uncurry zip . (repeat . head &&& map show . uncurry (flip (:)) . first (flip replicate 9) . (`divMod` 9)  . length) =<<) . group in compress "aaaaabbbccddddddddddddddddddddddddddddddddd"
03:52:28 <lambdabot>   "a5b3c2d6d9d9d9"
03:52:34 <zygoloid> domor: fixed it :)
03:52:52 <theorbtwo> ski: Hm.
03:53:05 <theorbtwo> Right.
03:53:10 <theorbtwo> I suppose it isn't, exactly.
03:54:05 <ski> i would understand if you said it feels like putting more of the "meat" code in patterns .. since this is a step in that direction
03:54:25 <ski> (even though view-patterns contribute more to that than the suggested or-patterns)
03:54:37 <theorbtwo> Yeah.
03:54:40 <Dan> in Data.Map is there a function which takes a value and returns the key? I'm probably being stupid but I've been looking for ages and I can't see one.
03:54:54 <theorbtwo> View patterns feel like mashing code into your declaration.
03:55:18 <theorbtwo> Your proposed or captures don't.
03:55:31 * ski would like a better declarative explanation of view-patterns
03:56:30 <ski> e.g. in `foo ((^2) -> x) = bar x', it feels like the `"(^2) ->' acts as a kind of inverse to `(^2)'
03:57:00 <ski> namely because you can imagine computing as
03:57:07 <ski>      foo 5
03:57:26 <ski>    =  foo ((^2) -> (^2) 5)
03:57:37 <ski>    =  bar ((^2) 5)
03:57:41 <ski>    =  bar (5^2)
03:58:05 <zygoloid> (^2) isn't a particularly meaningful view
03:58:26 <Dan> nevermind think I've worked out a function myself
03:58:43 <ski> i know .. but i think it can be illuminating in trying to understand what view patterns "really mean"
03:58:45 <domor> zygoloid: nice monster ;)
03:58:55 <theorbtwo> That makes me think that I should expect foo 25 to compute bar 5, which seems ... both scary and unlikely.
03:58:58 <ski> (basically because it is neither surjective nor injective)
03:59:11 <zygoloid> ski: what they 'really mean' is pattern matching on a view of data. what the view means is up to the view.
04:00:06 <SubStack> Dan: keys . filterWithKey (const (== v)) anyways too
04:00:19 <ski> zygoloid : yes, but how to develop a consistent equational calculus in which you can rewrite expressions using definitions that employ view-patterns
04:00:21 <zygoloid> > safeHead (viewl -> EmptyL) = Nothing; safeHead (viewl -> a :< _) = Just a; safeTail (viewr -> EmptyR) = Nothing; safeTail (viewr -> _ :> a) = Just a
04:00:21 <Dan> SubStack - Thanks
04:00:22 <lambdabot>   <no location info>: parse error on input `='
04:00:38 <ski> (and, ideally, that calcululs should be "declarative", whatever that really means")
04:00:49 <zygoloid> ski: urk. yeah, that's nasty.
04:01:15 <SubStack> oh hah
04:01:36 <ski> iow, we have more or less an operational semantics in search for an axiomatic semantics
04:01:44 <SubStack> Dan: or just keys . filter (== 2)
04:01:49 * SubStack must be tired
04:02:06 <SubStack> for Data.Map's filter, not the Prelude one
04:02:49 <zygoloid> foo (f1 -> p1) (f2 -> p2) | ... desugars to something like \x1 x2 -> case (f1 x1, f2 x2) of (p1, p2) | ... -> ...
04:03:37 <ski> *nod*
04:04:07 <zygoloid> that's a pretty horrible rewrite. but not much worse than pattern guards i think
04:04:42 <ski> well, pattern guards are also strange :)
04:09:27 <Sagi> can someone explain me why foo = (+) 3 is allowed and foo = 3 + isn't?
04:09:41 <SubStack> foo = (3+) is
04:09:47 <Sagi> I know
04:09:59 <ski> `3 +' is not a complete expression
04:10:01 <Sagi> but I don't want to use brackets, this is a simplified example
04:10:14 <Sagi> ah
04:10:22 <Sagi> well, no infix operator then :(
04:10:28 <ski> what is your real code ?
04:11:03 <ski> (maybe we can come with better suggestions, given more context)
04:11:07 <SubStack> foo = pred . pred . pred
04:11:12 <SubStack> no parens!
04:11:19 <Sagi> I want to build a lot of similar function all performing a sequence of additions to a bytestring.
04:11:26 <SubStack> er, s/pred/succ/
04:11:35 <Sagi> I wanted to use the infix operator to give fieldname and a default value
04:12:14 <Sagi> so i could write functions like f = key >=? default . key >=/ bla
04:12:53 <ski> with `.' coupling weaker than `>=?' and `>=/' ?
04:12:55 <Sagi> the >=/ would indicate the absence of a default
04:12:58 <Sagi> yeah
04:13:28 <Sagi> so my functions could end with >=/, but that produces a parse error.
04:13:30 <sinelaw> anyone experienced using webcams + haskell?
04:13:51 <Sagi> guess I should just not use infix operators :)
04:13:54 <SubStack> > x + x
04:13:55 <lambdabot>   x + x
04:14:03 <ski> Sagi : the above ends with `blah', not `>=/'
04:14:17 <Sagi> true, that's a mistake on my part
04:14:18 <SubStack> > 1337 + (1337 + x + x + x*(5+1*10))+y*y
04:14:20 <lambdabot>   1337 + (1337 + x + x + x * (5 + 1 * 10)) + y * y
04:14:31 <SubStack> yay my module is better ^_^
04:14:36 <ski> > x - x
04:14:38 <SubStack> it can reduce that somewhat
04:14:39 <lambdabot>   x - x
04:14:52 <zygoloid> SubStack: so can simplereflect, but it doesn't by default
04:14:56 <iazr> > x + (1 + 1)
04:14:56 <Axman6> > reduce (x - x)
04:14:57 <lambdabot>   x + (1 + 1)
04:14:57 <lambdabot>   x - x
04:15:00 <SubStack> oh really
04:15:11 <ski> Sagi : so you wanted `>=/' to be a postfix operator ?
04:15:19 <Sagi> yeah
04:15:24 <blazemore> How do I un-away?
04:15:40 <Sagi> I'm actually writing a library to construct packets in non-standard ways
04:15:44 <ski> blazemore : usually just `/away', i think
04:15:47 <blazemore> Ok nvm
04:15:59 <Sagi> so these functions consist of fields before and after some payload
04:16:08 <blazemore> Quick question: What's a good IDE or just text editor with synatax highlighting for Linux?
04:16:13 <ski> Sagi : so you could do `f = key >=? default . (key >=/)' .. but i guess you didn't want that
04:16:22 <Sagi> exactly
04:17:26 <sinelaw> anyone tried using easyVision?
04:17:30 <sinelaw> looks nice
04:17:35 <sinelaw> http://www.easyvision.googlepages.com/
04:17:41 <zygoloid> > iterate reduce (5^3 + 4 - 21*9)
04:17:43 <lambdabot>   [5 * 5 * 5 + 4 - 21 * 9,25 * 5 + 4 - 21 * 9,125 + 4 - 21 * 9,129 - 21 * 9,1...
04:17:43 <idnar> blazemore: I use vim
04:17:55 <ski> blazemore : i use emacs with haskell-mode
04:18:02 <idnar> does anyone use Yi?
04:18:55 <ski> blazemore : but istr Kate and whatever-Gnome's-standard-editor-is-called has some haskell highlighting support, too
04:19:18 <sinelaw> gedit
04:19:27 <ski> (that's it)
04:20:17 <ski> (.. maybe you don't believe it, but i have Gnome rather than KDE)
04:20:28 <idnar> haha
04:20:37 <idnar> I run GNOME, but you'd never know from looking at my desktop
04:20:55 <idnar> (my window manager is ion3, and I don't have nautilus or gnome-panel or any of that stuff running)
04:21:19 * ski 's desktop is a list of screen windows
04:22:34 * SubStack too
04:22:39 * sinelaw 's desktop is a table
04:23:17 <zygoloid> > iterate reduce (1337 + (1337 + x + x + x*(5+1*10))+y*y) !! 100
04:23:18 <lambdabot>   1337 + (1337 + x + x + x * 15) + y * y
04:23:42 <zygoloid> SubStack: that's reduced "somewhat", for some value of "somewhat" :)
04:24:11 <SubStack> my module has no reduce function ;)
04:25:05 <SubStack> it gives (2674 + X + X + (X * 15) + (Y * Y)) for that expression
04:25:34 <SubStack> which should be good enough for what I have in mind right now
04:25:48 <ski> (FFT ?)
04:26:45 <SubStack> glsl code generator for specially-tailored root finders for implicit surfaces
04:27:30 <Dark_Shikari> is there a built-in type for complex numbers?
04:27:56 <SubStack> not in glsl, but a vec2 would do the trick
04:28:10 <SubStack> anyways, for now I don't care about non-real roots
04:28:16 <ski> @index Complex
04:28:16 <lambdabot> Data.Complex
04:28:26 <ski> @type imagPart
04:28:27 <lambdabot> forall a. (RealFloat a) => Complex a -> a
04:28:57 <SubStack> unless that question was completely unrelated >_<
04:29:04 <Dark_Shikari> unrelated
04:29:07 <ski> > realPart . (sqrt . sqrt . sqrt) $ (-1)
04:29:08 <lambdabot>   0.9238795325112867
04:29:34 <Dark_Shikari> so how do I declare a variable of type Data.Complex?
04:29:52 <ski> just as with any variable
04:30:17 <Dark_Shikari> "3+5i"?
04:30:20 <Dark_Shikari> (3,5)?
04:30:21 <ski> (and the type is `Data.Complex.Complex a', for `a' in `RealFloat')
04:30:31 <Dark_Shikari> let Data.Complex a = 3+5i
04:30:35 <Dark_Shikari> I may be stupid, but that doesn't work
04:30:36 <ski> > 3 :+ 5
04:30:37 <lambdabot>   3.0 :+ 5.0
04:30:51 <Dark_Shikari> <interactive>:1:4: Failed to load interface for `Data':
04:30:51 <ski> > 3 + (5 * (0 :+ 1))
04:30:52 <lambdabot>   3.0 :+ 5.0
04:31:08 <ski> > let i = 0 :+ 1  in  3 + 5 * i
04:31:08 <lambdabot>   3.0 :+ 5.0
04:31:32 <ski> so, try
04:31:39 <ski>   i = 0 :+ 1
04:31:46 <ski>   a = 3 + 5*i
04:32:15 <Dark_Shikari> *Main> i = 0 :+ 1
04:32:15 <Dark_Shikari> <interactive>:1:2: parse error on input `='
04:32:22 <ski> (of course you can name `i', `imaginaryUnit', if you prefer)
04:32:33 <ski> those are lines to be put into a source file
04:32:42 <ski> if you want to play with then directly in GHCi, prefix with `let'
04:32:45 <Dark_Shikari> Doesn't work with let either
04:32:48 <Dark_Shikari> *Main> let i = 0 :+ 1
04:32:48 <Dark_Shikari> <interactive>:1:10: Not in scope: data constructor `:+'
04:33:01 <ski> you have to import `Data.Complex' first
04:33:13 <ski> in a source file, use `import Data.Complex'
04:33:23 <ski> in GHCi, use `:m + Data.Complex'
04:33:35 <Sagi> ski: any comments on how you would solve this? (I'm primarily concerned about having as little clutter as possible)
04:35:21 <ski> is `key >=? default' some kind of matcher that possibly processes the input with `key', using `default' in default cases ?
04:35:32 <Sagi> yeah
04:35:56 <Sagi> the function gets two things passed in: payload and key-value pairs
04:36:12 <Sagi> if key-value is missing for a particular key the default is used, or else an error producted.
04:36:16 <Sagi> -t
04:36:42 <ski> what is the type of `f' above ?
04:38:06 <Sagi> icmpv6 :: PacketBuilder     type PacketBuilder = MetaPacket -> MetaPacket       type MetaPacket = (Payload, MetaData)
04:39:04 <Dark_Shikari> ski: so the type is called Data.Complex as well?
04:39:11 <Dark_Shikari> i.e. function :: Data.Complex -> Data.Complex?
04:39:19 <Sagi> In the end I'm working with Data.ByteString.Lazy
04:39:27 * ski is pondering whether you actually want `key >=/' above at the end ..
04:39:30 <Sagi> although I must admit that is somewhat annoying
04:40:01 <ski> Dark_Shikari : if you `import Data.Complex', then you can say `function :: Complex Double -> Complex Double'
04:40:07 <Sagi> the alternative would be f = catchynamewithdefault key default . catchyname key
04:40:26 <Dark_Shikari> ah k
04:40:30 <ski> (there's is also `Complex Float', more generally `Complex a' for any type `a' in the type class `RealFloat')
04:41:54 <ski> Sagi : well, i was just thinking that if `key >=/' was a catch-all case, then it should be at the far left .. but maybe that's not the case
04:42:02 <osaunders> I want to randomly generate very simple Haskell programs and then have Haskell ask a user (via getLine or some such) what the result of the generated program is and mark the user's answer as correct or incorrect. At the moment I'm generating Haskell code strings but is there a better way?
04:42:27 <ski> osaunders : generate values of a new `Expr' data type ?
04:42:28 <Sagi> ski: well, the order determines the order of post/pre-fixing
04:42:41 <byorgey> osaunders: yes, generate ASTs and then pretty-print them.
04:42:46 <Sagi> for examples, source before destination or smt like that.
04:42:49 <Sagi> -s
04:42:56 <byorgey> osaunders: you can use the haskell-src-exts library
04:43:15 <Sagi> I'm currently in s. korea, with irc in the netherlands, the input lag is horrible.
04:43:23 <byorgey> osaunders: or if you only want fairly simple things, make up your own simplified AST type, like ski suggests
04:43:37 * ski can't really visualize the details of this `icmpv6' function, not knowing much about (presumably) the IP protocol
04:43:47 <osaunders> OK, thanks, I'll look into those things.
04:44:00 <byorgey> osaunders: then use hint to evaluate them and see whether the user is correct, perhaps?
04:44:18 <osaunders> hint?
04:44:18 <byorgey> preflex: seen twanvl
04:44:18 <preflex>  twanvl was last seen on #haskell 1 day, 22 hours and 17 minutes ago, saying: liftIOCallback :: ((a -> IO b) -> IO c) -> ((a -> m b) -> m c)
04:44:27 <Sagi> it's actually not anything but a function prepending and postpending values to a string. There's no details involved.
04:44:33 <byorgey> osaunders: the hint package, it lets you evaluate haskell code at runtime
04:44:46 <Sagi> but I guess I'll just try implementing the normal function-way and see if I'm happy with that
04:44:49 <Sagi> thanks for the help :)
04:45:04 <Dark_Shikari> numIterToTerminate :: Complex -> Complex -> Int -> Int
04:45:08 <Dark_Shikari>     `Complex' is not applied to enough type arguments
04:45:09 <ski>   data Expr = Lit Lit | Con Con | Var Ident | App Expr Expr | Lam Pat Expr | Let [(Pat,Expr)] Expr | Case Expr [(Pat,Expr)]  -- a simplistic version
04:45:15 <Dark_Shikari> what does that mean?
04:45:35 <ski> Dark_Shikari : you probably want to replace `Complex' with `Complex Double'
04:46:07 <ski> Dark_Shikari : if you think `Complex Double' is long to write, you may define `type ComplexD = Complex Double', e.g.
04:46:16 <ment> class C a where f :: String -> a
04:46:17 <ment> instance C String where f x = x
04:46:22 <osaunders> ski: Yeah I think I'll use a library.
04:46:27 <ment> why does this throw error on `f "xxx"' ?
04:47:05 <byorgey> ment: probably because it doesn't know which instance of C you want.  if you write   f "xxx" :: String  it should work fine
04:47:33 <byorgey> ment: and if you use  f "xxx" in a context where a String is expected you don't need to write the   :: String.
04:47:45 <ment> byorgey: ah, i see, thanks
04:48:02 <Dark_Shikari> http://pastebin.com/m3fcb9b64
04:48:25 <Dark_Shikari> where NumIterToTerminate is numIterToTerminate :: Complex Float -> Complex Float -> Int -> Int
04:49:17 <byorgey> Dark_Shikari: the problem is that numIterToTerminate returns an Int, but log is expecting something floating-point
04:49:22 <Dark_Shikari> it can't convert?
04:49:27 <byorgey> Dark_Shikari: wrap the call to numIterToTerminate in 'fromIntegral'
04:49:37 <byorgey> Dark_Shikari: no, Haskell does no implicit conversions
04:49:46 <Dark_Shikari> then why does "log 5" work in ghci?
04:49:56 <byorgey> Dark_Shikari: because the literal 5 is polymorphic
04:50:05 <byorgey> it can have any numeric type.
04:50:09 <Dark_Shikari> so it's impossible to specify a literal int?
04:50:12 <ski> Dark_Shikari : `log' doesn't work on `Int', try `1 / log (foo (numIterToTerminate z x 1000))', where `foo' is one of `floor',`ceiling',`round'
04:50:20 <byorgey> Dark_Shikari: you could write  (5 :: Int)
04:50:23 <Dark_Shikari> ah.
04:50:24 <ski> (depending on how you want to round)
04:50:34 <byorgey> to force it to be Int
04:50:42 <Dark_Shikari> ski: it's int -> float
04:50:45 <Dark_Shikari> not float -> int
04:50:54 <Dark_Shikari> int -> float has no rounding ;)
04:50:56 <byorgey> ski: you had that the wrong way round, I think.
04:51:17 <ski> .. er, so i do
04:51:18 <byorgey> right, 'foo' should be 'fromIntegral' which lets you convert from an integral type (Int or Integer) to any other numeric type.
04:51:25 <ski> sorry, `fromIntegral' is what you want
04:51:44 <ski> > 1 / log (10 :: Int)
04:51:45 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
04:51:45 <lambdabot>    arising from a use of...
04:51:49 <ski> > 1 / log (fromIntegral (10 :: Int))
04:51:50 <lambdabot>   0.43429448190325176
04:52:24 <ski> (`round',`floor',`ceiling' are used to go in the other direction)
04:53:37 <HugoDaniel> hi
04:53:48 <HugoDaniel> if i use GADT's will i be stuck in ghc forever ?
04:53:52 <HugoDaniel> ...should i care ?
04:56:40 <osaunders> HugoDaniel: Why would you need to use a different compiler?
04:57:43 <osaunders> There may be good reasons, I don't know, but that is the question you must know the answer to.
05:01:08 <CalJohn> HugoDaniel: i think other compilers might implement GADTs (does UHC?) so no.  But obviously, at the moment, almost everyone outside of York and Utrecht uses GHC
05:03:13 <HugoDaniel> i see
05:03:14 <byorgey> GADTs have an excellent chance of making their way into the Haskell standard at some point in the near future.
05:03:55 <HugoDaniel> i hope so, but the wiki page is not so good, it seems it just points out their flaws
05:04:06 <HugoDaniel> "flaws"
05:04:24 <HugoDaniel> http://www.haskell.org/haskellwiki/GADT
05:05:25 <ment> ok. i give up. is there some complete haskell reference manual about how functions are evaluated, types inferred etc.?
05:05:56 <byorgey> HugoDaniel: really? I only see a couple places where it mentions "this comes at a cost"
05:06:05 <Cale> HugoDaniel: eh?
05:06:23 <osaunders> ment: The Haskell report?
05:06:24 <byorgey> which shouldn't be so surprising, pretty much everything comes at a cost.
05:06:29 <osaunders> ment: What's your problem.
05:09:19 <Cale> ment: There's the Report, but it doesn't specify the 'how' so much as the 'what'
05:09:39 <Cale> ment: If you're interested in implementation mechanisms... well, there are a bunch of papers.
05:09:54 <ment> osaunders: haskell report seems kinda sparse, but i'll try that.
05:10:05 <Cale> ment: If you just want a mental model of how evaluation or typechecking might occur without dealing with irritating practical issues, then I can help.
05:10:29 <HugoDaniel> well, it probably is just me being nasty about the gadt wiki :/
05:11:13 <HugoDaniel> another question, ive been using the data.default for quite some time now, and i was wondering what other alternatives there might be for the same purpose ?
05:11:19 <Cale> ment: I find it's not as helpful to understand how GHC *actually* carries out evaluation, as it is to understand evaluation on the level of transforming expressions into other expressions, and eventually into values (data constructors)
05:11:19 <HugoDaniel> providing default datatypes :P
05:11:38 <ment> Cale: ok, for example, if i have expression "expr e1 e2 e3", how does it get evaluated?
05:11:42 <HugoDaniel> how do i force each datatype to have an instance of default ?
05:12:23 <osaunders> ment: http://en.wikibooks.org/wiki/Haskell/Graph_reduction
05:12:29 <ment> Cale: is the first term always treated as "function" and the rest arguments to be applied?
05:12:34 <Cale> yes
05:12:35 <osaunders> ment: Cale may have better links.
05:12:50 <Cale> I'll just give a description of some evaluation mechanisms
05:13:01 <Cale> Suppose we have a function like: double x = x + x
05:13:21 <osaunders> ment: Yes, parenthesis and the use of operators change that though.
05:13:41 <ment> fyi, i've been trying to write vararg function only to give up after some time only to find out that i completely misunderstood the type system
05:13:57 <Cale> if we evaluate  double (double 5)  using strict evaluation, we get:
05:14:01 <Cale> double (double 5)
05:14:05 <Cale> -> double (5 + 5)
05:14:08 <osaunders> ment: Uh yeah, that's either impossible or very advanced.
05:14:08 <Cale> -> double 10
05:14:12 <Cale> -> 10 + 10
05:14:14 <Cale> -> 20
05:14:31 <Cale> That's the usual innermost-first evaluation that most programming languages use.
05:14:43 <Cale> We could also evaluate this expression outermost-first though:
05:14:47 <Cale> double (double 5)
05:14:58 <ment> Cale: that's not the problem, i know some lambda calculus
05:14:58 <Cale> -> (double 5) + (double 5)
05:15:03 <Cale> -> (5 + 5) + (double 5)
05:15:06 <Cale> -> 10 + (double 5)
05:15:09 <Cale> -> 10 + (5 + 5)
05:15:11 <Cale> -> 10 + 10
05:15:13 <Cale> -> 20
05:15:17 <osaunders> ment: What Cale is demonstrating now is called graph reduction.
05:15:35 <Cale> Uh, I haven't talked about graphs at all, just expressions :)
05:15:55 <Cale> But what I'm about to talk about is implemented using graph reduction quite often :)
05:16:13 <ment> what i have problem with is \f -> f f
05:16:15 <Cale> So you can see that outermost-first evaluation wastes lots of work recomputing double 5 twice.
05:16:26 <Cale> ment: That's clearly a type error
05:16:32 <ment> Cale: are the mid-results cached somehow?
05:17:10 <Cale> ment: Well, what happens is that if you have a parameter to a function which occurs more than once in the body of the function, results of computing that parameter are shared between the copies.
05:17:23 <Cale> Normally this is accomplished in memory by just having multiple pointers to the same thing
05:17:37 <Cale> In terms of expressions, I like to use let ... in ... syntax to denote it:
05:17:40 <Cale> double (double 5)
05:17:42 <osaunders> Cale: Aren't expressions evaluated by means of graph reduction?
05:17:46 <Cale> -> let x = double 5 in x + x
05:17:59 <Cale> (note that this is still outermost first)
05:18:05 <Cale> osaunders: That's one way to implement it.
05:18:13 <Cale> -> let x = 5 + 5 in x + x
05:18:17 <Cale> -> let x = 10 in x + x
05:18:22 <Cale> -> 10 + 10
05:18:23 <Cale> -> 20
05:18:49 <Cale> You may or may not count the second last step as a real step
05:19:02 <ment> why not?
05:19:20 <ment> ah, that resolving the function body
05:19:42 <Cale> Because in memory, the expression  let x = 10 in x + x will be implemented by a node with + joined to the same node twice which is a 10
05:19:57 <Cale> and so it's already the same as 10 + 10, effectively
05:20:09 <osaunders> ment: What are you actually trying to do?
05:20:22 <ment> osaunders: what do you mean?
05:20:38 <osaunders> Well, when you said "I give up", what did you give up on?
05:21:10 <ment> osaunders: on trying to understand haskell using top-down approach
05:21:23 <Cale> ment: \f -> f f is a type error, since, suppose that f :: t, then we know that t = a -> b for some types a and b, because f is applied to a parameter, namely itself.
05:21:31 <Cale> (so it must be *some* type of function)
05:21:44 <Cale> But then the parameter it's applied to must have type a
05:21:53 <Cale> so we get that t = a
05:22:11 <ski>   t  =  (((...) -> b) -> b) -> b
05:22:23 <Cale> and so f must be of some type a which is equal to the type a -> b
05:22:42 <Cale> You might allow such "infinite types"
05:22:51 <Cale> but they're usually caused by mistakes
05:22:56 <osaunders> ment: It is probably sensible to give up on that, yes.
05:23:15 <Cale> Huh?
05:23:30 <osaunders> Top-down understanding of Haskell.
05:23:55 <Cale> I'm not completely sure what understanding Haskell using a top-down approach means. If you mean understanding things abstractly before the implementations, sure.
05:23:58 <ment> Cale: but it still makes sense to have function like that
05:24:25 <Cale> ment: Well, you could have a lambda term like that in the untyped lambda calculus
05:24:26 <zygoloid> is "t = t -> a" an equirecursive type or an isorecursive type? i can never remember which is which
05:24:40 <ski> zygoloid : equi-recursive
05:24:52 <Cale> ment: It's possible to use newtypes to get such things to typecheck, with a little extra noise, in Haskell.
05:25:07 <ment> Cale: and there is a way how to construct function with same effect, only i don't know how
05:25:21 <zygoloid> equirecursive <-> equal types, isorecursive <-> isomorphic types. got it.
05:25:27 <ski> ment : one can get the same effect, by defining a recursive type, `newtype Santa a = MkS {apS :: Santa a -> a}'
05:25:28 <Cale> ment: Well, why did you want to apply a function to itself?
05:25:43 <Cale> ment: Are you just implementing the Y combinator, or doing something more complicated?
05:26:01 <Cale> If you're just interested in implementing the least fixed point operator, just use:
05:26:06 <Cale> fix f = x where x = f x
05:26:17 <ski> ment : then you can define `foo :: Santa a -> Santa a; foo s@(MkS f) = f s'
05:26:24 <ment> Cale: well i want the function to be able to restart itself (but i would have any sense anyway, unless i'm passing any arguments along the way)
05:26:27 <zygoloid> (as opposed to equirecursive <-> equivalent types, isorecursive <-> iso (==equal) types)
05:26:40 <ski> (er, `foo :: Santa a -> a', rather)
05:26:43 <jkramer> Hi
05:27:05 <Cale> ment: I don't think I understand what it means for a function to restart itself.
05:27:18 <osaunders> Cale: My experience has been that to learn abstract Haskell stuff first, has been hard and extensive. All the while you can't do anything useful, then you forget it.
05:27:28 <ment> Cale: continuations, just pass the function it's body
05:27:33 <Cale> osaunders: Depends on how abstract
05:27:34 <jkramer> Maybe I get the description of subsequences wrong, but can someone please try 'subsequences "ApplicationBean"' and tell me the result is correct?
05:27:46 <zygoloid> fix f = fix where fix = f fix
05:27:54 <Cale> > subsequences "ApplicationBean"
05:27:55 <lambdabot>   ["","A","p","Ap","p","Ap","pp","App","l","Al","pl","Apl","pl","Apl","ppl","...
05:28:03 <Cale> seems correct
05:28:04 <ment> ski: what does '@' symbol mean?
05:28:07 <ski> ment : where are continuations entering into this
05:28:07 <jkramer> Check the end :)
05:28:20 <zygoloid> > subsequences "Bean"
05:28:21 <lambdabot>   ["","B","e","Be","a","Ba","ea","Bea","n","Bn","en","Ben","an","Ban","ean","...
05:28:22 <ski> ment : it meant that the argument is both names `s', and matched with `MkS f'
05:28:24 <Cale> > subsequences "abc"
05:28:25 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
05:28:34 <Cale> > subsequences "abcd"
05:28:35 <lambdabot>   ["","a","b","ab","c","ac","bc","abc","d","ad","bd","abd","cd","acd","bcd","...
05:28:42 <zygoloid> > last $ subsequences "ApplicationBean"
05:28:43 <lambdabot>   "ApplicationBean"
05:28:44 <jkramer> I'm getting stuff like "ApliaonBean" and "pliioBean" at the end
05:29:04 <Cale> jkramer: uh, you shouldn't get the latter
05:29:05 <jkramer> Well not at the very end, about one screen above the end :)
05:29:09 <zygoloid> > drop 32760 $ subsequences "ApplicationBean"
05:29:10 <lambdabot>   ["licationBean","AlicationBean","plicationBean","AplicationBean","plication...
05:29:21 <Cale> jkramer: But the first one seems right
05:29:35 <jkramer> But it's missing characters?
05:29:41 <Cale> oh, no, it's good
05:29:43 <mux_> > "pliioBean" `elem` (subsequences "ApplicationBean")
05:29:44 <lambdabot>   True
05:29:45 <zygoloid> jkramer: do you consider "ac" a subsequence of "abc"?
05:29:46 <Cale> pliioBean is right
05:29:47 <mux_> it seems good to me
05:29:49 <mux_> yeah.
05:29:54 <jkramer> No
05:29:58 <jkramer> zygoloid: No
05:30:02 * hackagebot upload: concurrent-extra 0.1 - Extra concurrency primitives (RoelVanDijk)
05:30:02 <zygoloid> jkramer: then you're looking for substrings not subsequences
05:30:07 <Cale> jkramer: That's your problem ;)
05:30:13 <ski> so you want *contiguous* subsequences, then
05:30:14 <jkramer> Ok, that's what I wanted to know :)
05:30:17 <Cale> "ac" is a subsequence of "abc"
05:30:20 <jkramer> So I DID get the description wrong
05:30:36 <ski> (.. or maybe the other way around ?)
05:30:38 <jkramer> Is there a function for substrings (not subsequences)?
05:31:00 <zygoloid> > (inits <=< tails) "abc"
05:31:01 <lambdabot>   ["","a","ab","abc","","b","bc","","c",""]
05:31:09 <ment> ski: with untyped calculus: (\f -> f f 0) (\self n -> if ... then self self (n + 1) else ... )
05:31:36 <ment> ski: oh, sorry for the continuations, i have those terms mixed up a little
05:31:37 <jkramer> Ah, nice
05:31:46 <Cale> > drop 1 . inits <=< tails $ "abc"
05:31:47 <lambdabot>   ["a","ab","abc","b","bc","c"]
05:31:55 <Cale> (for the nonempty ones)
05:32:28 <Cale> Gotta love the fish operator ;)
05:33:09 <ski> ment : yes, you can do that, using something similar to `Santa', above
05:34:10 <Cale> ment: Most of the cases where you end up with infinite types are just type errors and not anything actually useful though.
05:34:23 <Polarina> :t (<=<)
05:34:24 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:34:25 <ski> ment : i think you will get `(\f -> f (MkS f) 0) (\(MkS self) n -> if ... then self (MkS self) (n + 1) else ...)'
05:34:45 <Dark_Shikari> wait, Data.Complex can't do complex exponentiation?
05:34:58 <Cale> Dark_Shikari: **
05:35:01 <ski> ment : you can move around the `MkS's and/or replace with `apS' from above, if you prefer
05:35:01 <ment> Cale: btw can you pass me some links on haskell type system, type inference algorithms and any usefull related topics
05:35:27 <Dark_Shikari> Cale: thx
05:36:11 <ment> ski: so the infinity of the return type is actually hidden in santa?
05:36:17 <Dark_Shikari> btw, (1 +: 0) means 1 + 0i
05:36:18 <ski> yes
05:36:19 <Dark_Shikari> not 0+1i
05:36:20 <Dark_Shikari> right?
05:36:45 <Dark_Shikari> ah k, yes it does.
05:37:26 <ski> the type `Santa a' is basically the same (technically called "isomorphic") as `Santa a -> a' (per the definition), but they are not the exact same type, so you use `MkS' and `apS' above to convert between the two views
05:37:31 <Cale> ment: The basic idea behind essentially every type inference algorithm is to assign type variables to every subexpression in the program, and then determine equations that those type variables must satisfy, and solve those equations.
05:37:33 <ski> ment : ^
05:38:41 <Cale> I forget where the paper I read containing Algorithm M and Algorithm W was.
05:38:57 <ski> (and as for why i called it `Santa', see <http://en.wikipedia.org/wiki/L%C3%B6b%27s_paradox>)
05:39:08 <Cale> But they are two standard algorithms -- one of them works top-down in the expression and the other bottom-up
05:40:02 <Cale> ment: Almost every extension to the type system is well-documented and there are separate papers on them, as well as less-technical descriptions in the GHC guide.
05:40:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html <-- documentation for all the language extensions :)
05:41:07 <ksf> ...reading spj papers is kinda mandatory each time a new ghc comes out.
05:42:10 <ment> Cale: that's quite a lot of extensions ... do i really need them? :)
05:42:11 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
05:42:15 <Cale> ment: Not all of them
05:42:23 <Cale> ment: Some are more useful/important than others
05:42:32 <ment> ski: nice
05:42:46 <Cale> http://research.microsoft.com/en-us/people/simonpj/ -- newer papers
05:42:50 <ksf> and you can safely leave out those with a lot of greek symbols unless you want to hack on ghc's type checker
05:43:24 <ksf> ment, try this: http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
05:44:01 <ben> Ooh, type functions
05:44:03 <ben> Like in C++?
05:44:07 <ksf> er no
05:44:08 <ksf> better
05:44:13 <ksf> _waaaaaaaaaaaaay_ better
05:44:17 <ski> (ment : if you have a specific use in mind, it might be clearer to fix `a' in `Santa a' to some specific type `...', renaming `Santa' and its constructor and destructor)
05:44:44 <ben> Can I do pattern matching on type constructor application?
05:45:07 <ksf> it's one of the two ways to get the type system properly turing complete. the other one is functional dependencies
05:45:17 <ksf> yes, you can
05:45:18 <ment> ksf: that's great!
05:45:33 <ment> Cale: is The Implementation of Functional Programming Languages worth reading?
05:45:48 <Botje> ment: totally.
05:46:24 <ksf> in both cases you have to enable -XUndecidableInstances to get things past ghc, though. GHC won't have infinite loops in the type checker, by default.
05:46:39 <ksf> ment, it's a bit out of date, but the general principle still applies
05:46:42 <ksf> also, it's a good read.
05:47:03 <ksf> (or am I thinking of the STG paper?)
05:47:50 <Dark_Shikari> is there an easy way to assert in haskell?
05:47:57 <ksf> @hoogle assert
05:47:57 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:47:57 <lambdabot> Control.OldException assert :: Bool -> a -> a
05:47:57 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
05:48:21 <Dark_Shikari> er, but what do they do?  they don't look like they kill the program and give me an error
05:48:30 <ksf> they do.
05:48:52 <ksf> if the bool is false, they throw an error. if its true, they return the second argument
05:49:46 <ment> Cale: ksf: ski: thanks for the help!
05:49:53 * ment is going to do some reading
05:49:55 <ksf> you could even do it by yourself a la assert' b x = if b then x else error "assertion failed", but the in-built assert has some black magic going on to get source locations
05:49:55 <ski> ben : how do you mean ?
05:50:02 <Cale> ment: Also, feel free to ask questions here
05:50:19 <Cale> ment: It's often easier than looking for the right documentation.
05:50:38 <Cale> and you'll be helping people to procrastinate effectively :)
05:50:47 <Dark_Shikari> it doesn't seem to be working
05:50:50 <ben> help i cannot download http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
05:50:52 <Dark_Shikari> I stuck an Assert False in my program
05:51:00 <Dark_Shikari> and it's not dying.
05:51:04 <ben> It does not like firefox :<
05:51:16 <ben> > assert False 42
05:51:17 <lambdabot>   Not in scope: `assert'
05:51:36 <ski> Dark_Shikari : you stuck it, *where* ?
05:51:43 <Dark_Shikari> in the section of code that was running
05:51:46 <Cale> Yo dawg, I herd you liek fun types, so I put type funs in your fun types, so you can type while you type.
05:51:56 <Dark_Shikari> > Control.Exception.assert False 42
05:51:57 <lambdabot>   Not in scope: `Control.Exception.assert'
05:52:02 <Dark_Shikari> > import Control.Exception
05:52:02 <ksf> Dark_Shikari, are you sure you forced that value?
05:52:03 <lambdabot>   <no location info>: parse error on input `import'
05:52:04 <Cale> ben: hmm
05:52:08 <Cale> ben: It works for me.
05:52:12 <Dark_Shikari> ksf: what do you mean "forced"?
05:52:13 <ben> It worked with wget on another system, so I am good
05:52:14 <ben> Sorry
05:52:21 <ksf> also, you have to complie without -O
05:52:23 <ben> I just get The connection to the server was reset while the page was loading. in FF
05:52:29 <ksf> (or -fignore-asserts)
05:52:40 <Dark_Shikari> I'm not using -O
05:52:47 <Dark_Shikari> or wait... oops.  I am.
05:52:49 <Dark_Shikari> fail.
05:52:54 <Dark_Shikari> wait, why would -O remove asserts?
05:53:08 <Dark_Shikari> -O3 doesn't remove asserts in gcc.
05:53:18 <ksf> Dark_Shikari, ((\x -> 2) (assert False)) won't throw an error because x is never forced
05:54:27 <ksf> ...because assertions aren't meant to make it to production code.
05:54:47 <Dark_Shikari> and one might never want to test asserts with optimizations on?
05:55:29 <ksf> not really. If you turn optimizations on, you want your program to run, not fail.
05:55:39 <Dark_Shikari> that makes it rather hard to debug compiler bugs.
05:55:50 <ksf> THERE ARE NO COMPILER BUGS
05:56:08 <Dark_Shikari> lol
05:56:17 <Dark_Shikari> there are no soldiers in badghdad
05:56:25 <Dark_Shikari> <insert image of information minister here>
05:56:34 <ksf> if you want a run-time error, the quick and dirty way is to use error
05:56:38 <Ke> *american soldiers
05:56:41 <ksf> as the well known
05:56:43 <ksf> > head []
05:56:44 <lambdabot>   * Exception: Prelude.head: empty list
05:57:05 <Dark_Shikari> what's an easy way to print a variable?
05:57:07 <Dark_Shikari> i.e. to stderr
05:57:08 <ksf> then you also get a lot of automatic checking, like
05:57:22 <ksf> > do (x:xs) <- []; return ()
05:57:23 <lambdabot>   []
05:57:28 <ksf> duh.
05:57:29 <abbe> There is no variable (read as: spoon)
05:57:31 <ksf> that didn't work.
05:57:35 <Dark_Shikari> abbe: a value, whatever
05:57:37 <ksf> Dark_Shikari, print
05:57:40 <ksf> :t print
05:57:41 <lambdabot> forall a. (Show a) => a -> IO ()
05:57:41 <Dark_Shikari> k
05:57:51 <ksf> if you have a string, use printStrLn etc.
05:58:00 <Dark_Shikari> wait, but how can I print a value, then return it or whatnot
05:58:03 <ksf> (print = putStrLn . show)
05:58:05 <Dark_Shikari> oh, "print a" returns a
05:58:28 <benmachine> are you looking for Debug.Trace perhaps
05:58:28 <Dark_Shikari> how do I print a float?
05:58:33 <ksf> no it doesn't.
05:58:44 <Dark_Shikari> I just want to do the equivalent of fprintf(stderr,"%f",myval);
05:58:45 <ksf> ...it is a IO action that returns ()
05:59:03 <Botje> Dark_Shikari: fprintf just returns the number of chars written
05:59:08 <ksf> either with print/show, or if you want more control, showFFloat
05:59:09 <Dark_Shikari> Botje: ok, I don't need that part =p
05:59:11 <abbe> Dark_Shikari: hPutStrLn stderr (show myval) ??
05:59:14 <idnar> @pl \x -> print a >> return a
05:59:14 <lambdabot> const (print a >> return a)
05:59:19 <idnar> oops
05:59:21 <idnar> @pl \a -> print a >> return a
05:59:22 <lambdabot> liftM2 (>>) print return
05:59:29 <Dark_Shikari> how do I still return a value though?
05:59:32 <Dark_Shikari> lets say I have myfunc = X
05:59:36 <Dark_Shikari> I want myfunc to print X, then return it
05:59:37 <ksf> Dark_Shikari, if you want to do output for debugging, there's Debug.Trace.trace
05:59:42 <ksf> @hoogle trace
05:59:42 <lambdabot> Debug.Trace trace :: String -> a -> a
05:59:42 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
05:59:42 <lambdabot> module Debug.Trace
05:59:45 <Dark_Shikari> ah ok
06:00:00 <ksf> ...which works like assert
06:00:09 <Dark_Shikari> wait but that will return (show a)
06:00:10 <Dark_Shikari> not (a)
06:00:15 <Dark_Shikari> and I need to return a, not show a
06:00:34 <ksf> \x -> trace (show x) x
06:00:36 <Dark_Shikari> All I want to do is convert "myfunc = X" to "myfunc = X and print X"
06:00:45 <Dark_Shikari> ah k
06:01:40 <ksf> don't use that in the finished code, though.
06:02:00 <Dark_Shikari> of course
06:02:10 <ksf> ...the proper way is to use WriterT or use some specialized logging monad
06:03:12 <ksf> @quote oasis
06:03:12 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
06:03:41 <Dark_Shikari> lol
06:03:58 <Dark_Shikari> "my productivity increased when I learned how to use printf"
06:03:58 <endojelly> I love trace
06:04:15 <endojelly> it also regularly reminds me just how lazy laziness really is
06:04:57 <ksf> the only problem is that it scatters Show contraits all over your code
06:05:06 <Cale> Dark_Shikari: trace *is* magic though, compared to printf, which is nonmagical, though clever
06:05:41 <endojelly> ksf, I usually fix that locally, instead of adding Show instances
06:05:48 <Cale> :t printf
06:05:49 <lambdabot> forall r. (PrintfType r) => String -> r
06:05:57 <ksf> ...I usually comment out the type signatures
06:06:17 <fasta> Is there a name for a mathematical object which handles the linear equation cases, but also the cases of x=0 and y=0?
06:06:19 <ksf> ouch that doesn't look statically typed
06:06:20 <osaunders> ksf: Why?
06:06:40 <Cale> fasta: "linear equation"?
06:06:45 <ben> > printf "%s %d %f" pi 42 "toot" :: String
06:06:46 <lambdabot>   "* Exception: Printf.printf: bad argument
06:06:46 <ksf> ...because I don't want to add ten Show instances by hand if I add a trace to some inner function
06:06:50 <ben> > printf "%s %d %f" pi 42 :: String
06:06:51 <lambdabot>   "* Exception: Printf.printf: bad argument
06:07:13 <ksf> the fun with type functions paper has an example of statically typed printf
06:07:13 <fasta> Cale, I want to describe lines in the 2d plane, but a linear equation is defined to have at least one non-zero coefficient.
06:07:16 <Cale> fasta: a general linear equation in variables x and y looks like a x + b y + c = 0
06:07:35 <osaunders> ksf: Ah.
06:07:40 <fasta> Cale, and a and b cannot both equal zero, right?
06:07:49 <Cale> unless c = 0 as well
06:07:58 <benmachine> and if c = 0 then your equation is pretty silly
06:08:06 <Cale> well, that's just not a linear equation anymore
06:08:13 <Cale> but x = 0 is fine
06:08:18 <Cale> and y = 0 is fine
06:08:38 <Cale> (that's just a = 1, b = 0, c = 0, and a = 0, b = 1, c = 0, respectively)
06:08:55 <medfly> > printf "%f" pi
06:08:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:08:56 <lambdabot>    `Text.Printf.PrintfType ...
06:09:03 <fasta> Cale,so, Wikipedia is wrong then?
06:09:09 <Cale> ...
06:09:16 <fasta> Cale, I happen to have the case where a,b and c are zero.
06:09:37 <Cale> no.
06:09:47 <Cale> Wikipedia appears to be correct
06:09:54 <Cale> 0 = 0 is not a linear equation
06:09:57 <ksf> infinitely many solutions yay!
06:10:30 <medfly> > printf "%f" pi  :: String
06:10:31 <lambdabot>   "3.141592653589793"
06:10:51 <medfly> > printf "%d" pi  :: String
06:10:52 <lambdabot>   "* Exception: Printf.printf: bad argument
06:10:55 <medfly> :/
06:10:55 <burp> :t printf
06:10:56 <lambdabot> forall r. (PrintfType r) => String -> r
06:11:08 <ksf> , filter (\x -> x == reverse x) dict
06:11:14 <ksf> @bot
06:11:14 <lambdabot> :)
06:11:20 <ksf> where's luna?
06:11:25 <medfly> @botsnack
06:11:25 <lambdabot> :)
06:11:32 <Cale> I like how Wikipedia even describes nonsensical forms described in US highschool textbooks.
06:11:37 <ben> Careful! New moon tonight!
06:13:26 <benmachine> which wikipedia page are we looking at here
06:13:32 <burp> (PrintfArg a, PrintfType r) => PrintfType (a -> r) ← what use does this PrintfType instance have?
06:13:45 * benmachine went to "linear equation" and had to revert it a few revisions before it made sense
06:14:02 <benmachine> burp: it's the mechanism by which printf can accept variable numbers of arguments
06:14:02 <fasta> Cale: I guess the object I was searching for is simply a line then. In a lot of cases a linear equation can represent this, but not when the line goes through the line segment ((0,0),(1,0)) ;)
06:14:07 <Cale> burp: supplying the arguments which printf interpolates into the string
06:14:17 * Cyneox re
06:14:20 <Cale> fasta: wtf?
06:14:33 <Cale> fasta: All lines in R^2 are described by linear equations
06:14:34 <burp> hm ok
06:15:33 <burp> oh yes, I understand ;-)
06:15:45 <fasta> Cale, ah, never mind.
06:16:21 <Cale> burp: It's a bit clever
06:16:45 <Cale> burp: You can construct variadic functions with all sorts of fancy protocols using typeclasses
06:17:22 <Cale> Such as a function which only takes a number of parameters congruent to 1 mod 5
06:19:12 <burp> interesting
06:20:41 <Cale> Heh, or I'm fairly sure that with some extensions you could do a function which only takes a prime number of parameters...
06:21:03 <Cale> That'd be fun to see
06:24:44 <Janni> Hello.
06:25:05 <medfly> hi
06:25:29 <Janni> I'm writing this library, and cabal gives me this warning for every module "You are using the old package `base' version 3.x"
06:26:01 <Janni> Is there something about the package info I should change, like using "base >= 4.0"?
06:26:17 <Janni> Actually, I don't mind which one is used.
06:26:46 <Janni> Ah. Maybe I should try to get rid of my base-3.0.3.2 installation I have on my system.
06:28:17 <benmachine> no
06:28:24 <benmachine> you shouldn't do that
06:28:27 <benmachine> some things still need it
06:28:37 <Janni> Yes, I noticed that.
06:28:52 <Janni> So, is there something wrong with my package description then, or should I just ignore the warning?
06:29:00 <benmachine> the reason cabal is using base 3 instead of base 4 is because a lot of packages were broken by the upgrade to base 4 I think
06:29:05 <benmachine> because they didn't specify base < 4
06:29:09 <benmachine> and so
06:29:17 <benmachine> if you don't provide a base upper bound
06:29:22 <benmachine> cabal assumes you mean base 3
06:29:34 <benmachine> if you say, base >= 3 && base < 5
06:29:39 <benmachine> then it should use base 4
06:29:43 <benmachine> I think
06:29:55 <ksf> >=3 isn't right
06:30:01 <ksf> >= 4
06:30:02 <benmachine> k
06:30:10 <benmachine> well, it's possible for a program to work with both
06:30:34 <ksf> sure, but ghc 6.14 is going to barf
06:30:45 <benmachine> why would it?
06:30:50 <benmachine> 4 is >= 3
06:31:02 <benmachine> the point is that you've got to have the upper bound
06:31:03 <ksf> ...but then probably cabal will know about that
06:31:16 <benmachine> then cabal believes that you know about base 4
06:31:16 <ksf> because iirc 6.14 won't support base 3, anymore
06:31:23 <benmachine> so cabal uses base 4
06:31:31 <benmachine> if you have no upper bound cabal is conservative
06:31:34 <benmachine> that is my understanding
06:32:37 <benmachine> Janni: basically, just specify base >= yourminimumversionof base && < 4.3
06:32:42 <benmachine> or < 5 if you are feeling optimistic
06:33:24 <Janni> OK. What about the upper bound? Why is it important?
06:33:36 <Janni> I guess because of interface changes, that might come with new versions.
06:33:40 <Janni> not hard to answer...
06:34:04 <benmachine> the upper bound is important
06:34:09 <benmachine> because if it's not there
06:34:15 <benmachine> cabal assumes you didn't know about base 4
06:34:19 <Janni> What about all the other dependencies of my package? Should I include an upper bound for each of them? What would be a good value? Current version rounded up?
06:34:29 <benmachine> for other packages, it's not so easy
06:34:49 <benmachine> if they follow the official versioning policy
06:34:54 <ksf> iirc the general idea of cabal versioning means that you should use < next major version
06:35:06 <benmachine> then you should assume that then next A.B release *might* break the API
06:35:17 <Janni> I should have a look at the official versioning policy.
06:35:19 <benmachine> i.e. if you're using 1.8 you should specify < 1.9
06:35:28 <benmachine> yeah I've got a link somewhere hang on
06:35:31 <Janni> OK, good.
06:35:36 <Janni> Thanks for the info, so far.
06:35:38 <benmachine> the trouble is it's only a guideline
06:35:48 <benmachine> so you might use libraries that don't quite follow it precisely
06:35:58 <benmachine> in which case you have to work things out yourself
06:36:05 <benmachine> http://haskell.org/haskellwiki/Package_versioning_policy
06:36:45 <benmachine> but base and any official libraries probably follow it pretty closely
06:39:21 * hackagebot upload: open-pandoc 1.4 - Conversion between markup formats (PeterSimons)
06:40:43 <fasta> If people would stop discussing about this and simply implement what I described there is no need to discuss anything anymore.
06:41:09 <benmachine> fasta: what
06:42:06 <fasta> benmachine, maintain for every package a lowest version which is known to work, then compute incrementally whether that package can also be used with newer dependency packages.
06:42:45 <fasta> benmachine, the "oh, no, I have the wrong package version"-problem.
06:43:18 <benmachine> compute how?
06:43:35 <benmachine> also, how is that not exactly what we are doing
06:44:01 <benmachine> also, I giggled at http://hackage.haskell.org/package/empty-9
06:44:10 <fasta> benmachine, currently packages specify constraints which are wrong, yet assumed to be correct.
06:44:26 <fasta> benmachine, the how is very easy: just try the combination and see whether it works.
06:44:45 <benmachine> okay but I don't really want to install every version of every package I depend on
06:45:02 <fasta> benmachine, a central server could.
06:45:09 <fasta> benmachine, or you could run it at night.
06:45:27 <fasta> benmachine, or you can share this information as a group.
06:45:52 <fasta> benmachine, it is a computational problem on which human resources are being spent in an uneconomic fashion.
06:46:03 <benmachine> I don't think many resources are being spent on it really
06:46:04 <benmachine> it's not hard
06:46:50 <benmachine> if you write a tool to determine dependencies automatically though
06:46:55 <benmachine> maybe it will see some use?
06:47:14 <benmachine> it might be a good idea but I don't think it's a big deal
06:47:29 <benmachine> if everyone stuck to the PVP which they should anyway, it's easy
07:02:12 <Saizan_> we'd need a PVP checker though :)
07:02:18 <temoto> Very interesting article on downsides of mathematics education in school: http://www.maa.org/devlin/devlin_03_08.html
07:02:33 <temoto> (there's russian translation too)
07:13:10 <Saizan_> ah, i've read that, i agree with the criticism on education by mindless exercises, though not on the disregard for formalism
07:14:09 <Saizan_> i.e. as a programmer i appreciate a precise language to better express my ideas
07:14:54 <Twey> I think the point is that the formalism should be derived from the basics and used as a convenience, rather than neglecting the basics entirely for formalisms
07:17:41 <Saizan_> the problem with how the geometry proofs are teached, as it's described in the article, is that there's no partecipation by the students, not that they are formal
07:18:50 <Saizan_> though i agree that you need to motivate your formal system first
07:20:29 <noteventime> Is there some way to make to make Network.HTTP.Browser not output a lot of debug information?
07:21:14 <CosmicRay> can someone tell me where to find 1) what version of time the current haskell-platform has; 2) what version of time the upcoming haskell-platform will have?
07:22:19 <Saizan_> CosmicRay: 1) looked at the haskell-platform .cabal file on the wiki?
07:23:02 <CosmicRay> Saizan_: that could get me close, and perhaps answers #1, but not #2
07:23:23 <Saizan_> that's why i said 1) :)
07:23:27 <CosmicRay> ah
07:28:21 <MissPiggy> @users
07:28:21 <lambdabot> Unknown command, try @list
07:28:45 <Phyx-> I use
07:28:58 <MissPiggy> do you remember when we first broke 600
07:29:11 <MissPiggy> and now it's like 600 every day
07:29:54 <b0fh_ua> Hi there! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21380#a21380 - this is simple tool, which tries to connect to local server and get some page from it. I tried to make it multithreaded, but looks like after some time it simply hangs. I afraid that connections to HTTP, used by CURL, are not closed. But I may be wrong. Can somebody please take a look at the code and point me to possible problems with it?
07:29:59 <ment> haskell is getting popular, i can't wait for the first framework for rapid web application development
07:30:08 <MissPiggy> ment isn't there one already?
07:30:39 <b0fh_ua> Also I would like to know what should I use to track count of success and failed operations
07:31:29 <ment> MissPiggy: dunno
07:31:54 <Botje> ment: turbinado, happstack?
07:32:10 <benmachine> b0fh_ua: I've never used curl so I don't know if this is relevant, but aren't you supposed to use withCurlDo to wrap your curl stuff?
07:32:14 <benmachine> http://hackage.haskell.org/packages/archive/curl/latest/doc/html/Network-Curl.html#v%3AwithCurlDo
07:32:26 <Phyx-> MissPiggy: but only about 100 of those 600
07:32:31 <Phyx-> MissPiggy: but only about 100 of those 600+ have ever spoken
07:32:42 <b0fh_ua> "e.g., no forking or lazy returns"
07:33:05 <MissPiggy> @activity
07:33:05 <lambdabot> 0*total
07:33:21 <benmachine> b0fh_ua: it just means that the thing you wrap with it has to finish using curl before it returns
07:33:28 <b0fh_ua> benmachine: looks like it is not possible to use curl in multithreaded environment?
07:33:29 <benmachine> if you wrap main with it that's guaranteed
07:33:54 <benmachine> b0fh_ua: my guess is it will be fine so long as your threads finish before withCurlDo is exited
07:35:14 <b0fh_ua> benmachine: okay, will give it a try.
07:35:35 <MissPiggy> "sigfpe: But don’t you see how dangerous that makes automatic differentiation? Once CGI lines up with live action perfectly, both story and acting become literally invisible to the human eye. Soon, every movie will consist of two-hour montages of robots that turn into trucks."
07:37:31 <quicksilver> it's funny how he says that, almost as if he thinks that's a bad thing.
07:38:04 <b0fh_ua> benmachine: nice. This simple application took 1565M after few minutes of running
07:38:35 <b0fh_ua> SIZE of top
07:38:46 <benmachine> neat
07:38:53 <b0fh_ua> yup
07:39:27 <benmachine> in case you were wondering, I have no idea why
07:39:47 <b0fh_ua> me either :(
07:47:07 <aiju> http://pastebin.com/m73d438d6 what's wrong with the indentation of that piece of code? Haskell complains about it
07:47:11 <aiju> ehm GHC
07:48:00 <Polarina> I just compiled GHC 6.12.1 and ran the testsuite and got these results. http://codepad.org/GsUt3VRt  --  Do I need to panic?
07:51:48 <Botje> aiju: == on the second line should be =
07:51:52 <CalJohn> aiju: == should be =
07:52:08 <aiju> oh yeah
07:52:10 <CalJohn> darn
07:52:14 <aiju> thank you guys
07:52:57 <CalJohn> aiju: also, it's nice to put the guards on a separate line (ie "\n|", not "|")
07:53:32 <Botje> also, length x > 1 === not (null x)
07:53:50 <aiju> ehm length = 1 is excluded, too
07:54:15 <Botje> oops
07:54:18 <Botje> nevermind :)
07:54:55 <Twey> not (null x) && not (null (tail x))
07:54:59 <Twey> Hm
07:55:13 <Twey> not (null (take 2 x))
07:55:34 <aiju> to make the code even harder to understand?
07:55:47 <Twey> To stop the code exploding on infinite lists ;)
07:55:59 <benmachine> case x of _:_:_ -> True; _ -> False
07:56:05 <aiju> they are not infinite
07:56:19 <aiju> (being subsets of [1..9])
07:56:36 <Twey> But why not just use the safer form anyway?
07:56:47 <benmachine> the safer, slightly faster, and more common form
07:56:50 <Twey> Aye
07:56:55 <benmachine> saves you having to think about it later
07:57:38 <MissPiggy> Twey!!
07:57:42 <benmachine> :t not . null . drop 1
07:57:43 <lambdabot> forall a. [a] -> Bool
07:57:47 <MissPiggy> > fix (1 +) :: Natural
07:57:48 <lambdabot>   Not in scope: type constructor or class `Natural'
07:57:51 <MissPiggy> urfhhfguhh
07:57:52 <MissPiggy> oh well
07:57:54 <aiju> :t pi
07:57:55 <MissPiggy> you can do
07:57:56 <lambdabot> forall a. (Floating a) => a
07:58:02 <Twey> MissPiggy!!?
07:58:03 <aiju> interesting
07:58:05 <MissPiggy> genericLength list < 3 :: Natural
07:58:10 <MissPiggy> and it will work on infinite
07:58:17 <MissPiggy> because data Natural = Z | S Natural
07:58:25 <benmachine> that's the same thing but with more libraries
07:58:45 <MissPiggy> ssame as what
07:59:05 <benmachine> > not . null . drop 1 $ [1,2]
07:59:06 <lambdabot>   True
07:59:09 <benmachine> for example
07:59:27 <benmachine> your way is fine
07:59:30 <MissPiggy> it's a different method but if they don't both give the same result one of them is wrong
07:59:53 <benmachine> but where do you get Natural anyway?
07:59:59 <Twey> But the Natural way is slower :þ
08:00:16 <MissPiggy> I just defined it above
08:00:17 <Twey> It is nicer, though perhaps overkill in this case
08:00:22 <aiju> oh my
08:00:27 <aiju> what have i done *g*
08:00:44 * hackagebot upload: concurrent-extra 0.1.0.1 - Extra concurrency primitives (RoelVanDijk)
08:01:52 <sinelaw> can I reference an environment variable from within a .cabal file?
08:02:49 <MissPiggy> Twey how come it's slower? (I don't doubt you, but I have no idea why one program is slower than another)
08:03:51 <Twey> MissPiggy: Because you have to build the Natural for genericLength and then deconstruct it for <, as there are no native operations on Naturals
08:04:08 <Twey> It's something like O(n³), I think
08:04:25 <aiju> n what?
08:04:43 <Twey> Well, it's only the constant value you're comparing, here, since we don't care about the value of the Natural beyond that
08:04:46 <MissPiggy> well succing and predding is O(1), so doing that n times is O(n)
08:04:55 <aiju> oh never mind
08:05:14 <aiju> had some minor terminal problems
08:05:52 <Twey> MissPiggy: Right — you've got to traverse the list up to n and succ the natural n times for the genericLength, then pred it n times for the <
08:05:59 <Twey> O(n³)
08:05:59 <MissPiggy> if you write 6 and the compiler turns it into  fromIntegral 6  (which probably gets turned into  1 + (1 + (1 + (1 + (1 + (1 + 0)))))  (by need), that is still not cubic
08:06:13 <aiju> any Haskell print debugging function?
08:06:18 <Twey> aiju: Debug.Trace
08:06:37 <MissPiggy> Twey hm don't you mean 3n ?
08:06:40 <aiju> how to use it?
08:06:43 <MissPiggy> I don't think that is n^3
08:06:44 <Twey> MissPiggy: Hm
08:06:53 <Twey> MissPiggy: Yes, you're right.  Sorry.  >.<
08:07:15 <MissPiggy> Twey, whereas with droplist, it would be 2n since there is no buildup?
08:07:19 <sinelaw> i can't seem to find the docs for cabal's file format
08:07:57 <Twey> MissPiggy: It would be O(n) — operations on native numbers are constant
08:08:18 <Twey> You traverse the list, and that's it
08:08:29 <benmachine> I think not . null . drop 1 would be one operation to drop 1, then one operation to match against [], and one to not the result
08:08:44 <benmachine> the only thing that'd be faster would be a direct case, and that only marginally
08:09:11 <mreh> with Kleisli Arrows in particular, and generalising to all other arrows I suppose, the order of (f &&& g) matters, doesn't it?
08:09:39 <aiju> how to use trace? it doesn't seem to do anything
08:09:54 <benmachine> if it's not doing anything, maybe its argument isn't being evaluated
08:10:03 <aiju> hups yeah
08:10:22 <mreh> @src (&&&)
08:10:22 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
08:10:23 <benmachine> the joy of IO that pretends to be pure
08:10:33 <benmachine> @src (***)
08:10:33 <lambdabot> f *** g = first f >>> second g
08:10:39 <mreh> @pl (\b -> (b,b))
08:10:39 <lambdabot> join (,)
08:10:41 <benmachine> that would suggest order matters
08:10:45 <aiju> benmachine: better than rewritig tons of code just to debug something
08:10:47 <benmachine> no it wouldn't
08:10:51 <benmachine> well maybe
08:10:56 <benmachine> aiju: oh, sure
08:11:09 <benmachine> but it's a headache either way :P
08:11:29 <mreh> rewriting code is a virtue
08:12:12 <MissPiggy> not . null . drop n -- this is equivalent to   positive . subtract n . genericLength
08:12:34 <MissPiggy> not . null <=> positive, drop n <=> subtract n
08:12:59 <benmachine> drop n <=> subtract n isn't quite right
08:13:05 <benmachine> but yes they do the same thing
08:13:06 <ksf> it's easy to do in haskell. once you've got your initial design of 20 lines expanded to 200 to make it work, reducing it to 50 lines that do twice as much as you intented them to is highly satisfying.
08:13:12 <MissPiggy> what do you mean then
08:13:14 <MissPiggy> why isn't it right?
08:13:15 <benmachine> oh wait are we doing Natural still
08:13:20 <mreh> it would be nice if there were an editor that contracts all the loooong haskell operators into overlapping strings
08:13:25 <benmachine> what's 1 - 2 :: Natural?
08:13:32 <MissPiggy> 0
08:13:35 <benmachine> oh
08:13:39 <benmachine> I thought it was error
08:13:48 <benmachine> mreh: buh?
08:14:35 <MissPiggy> genericLength is a ([a],++) homomorphism to (Natural,+)
08:14:36 <mreh> benmachine: the standard practice in haskell literature is to reduce the spacing between characters in operators so they overlap
08:14:54 <aiju> yay finished my sudoku solver
08:15:02 <benmachine> oh
08:15:16 <mreh> aiju: I always wanted to make one of those
08:15:26 <aiju> i made a quite inefficient one
08:15:33 <benmachine> MissPiggy: well, Natural is isomorphic to [()] anyway
08:15:35 <aiju> it's just intelligent trial and error
08:15:35 <MissPiggy> but it seems to be that, since Natural has an /as inefficent/ representation as list, that numberizing the list doesn't improve efficency
08:15:44 <benmachine> or, possibly [Void]
08:15:46 <benmachine> not sure which
08:15:50 <MissPiggy> [()]
08:16:11 <Twey> > length [undefined, undefined, undefined, undefined]
08:16:12 <lambdabot>   4
08:16:13 <ksf> mreh, you can use unicode, and feel my wrath descend upon you should I ever have to read your code
08:16:14 <mreh> aiju: what's inefficient about it? you have to check every element in a list, so the purely functional definition of a list if all you need
08:16:27 <aiju> the whole algorithm is inefficient
08:16:42 <ksf> I can still remember wondering why some agda code of mine won't work, finally noticing that I was using an ascii operator where they used unicode
08:16:43 <mreh> ksf: unicode can do that? I can make lambdas and arrows in unicode, ghc likes those
08:16:57 <ksf> -XUnicodeSyntax
08:17:03 <ksf> and for the rest, you can do aliases
08:17:14 <mreh> but reducing the kerning of a character in the editor is another thing
08:17:19 <benmachine> lambdas aren't allowed in lambdas except by editor tricks
08:17:20 <ksf> indeed.
08:17:42 <benmachine> there's no particular reason why you have to program haskell in fixed width :P
08:17:45 <mreh> oh really? Yi does that doesn't it
08:17:53 <benmachine> possibly
08:17:58 <aiju> benmachine: sure they're is
08:18:09 <benmachine> covered that possibility via editor tricks
08:18:17 <ksf> oh yes I see. there's a mathematical lambda symbol in unicode though that can't be confused with the greek one
08:18:25 <ksf> (except, of course, visually)
08:18:37 <benmachine> hmm
08:18:45 <benmachine> what's its thingy?
08:18:48 <ksf> unicode syntax with a fixed width font is intstant fail
08:19:03 <aiju> ksf: why?
08:19:06 <mreh> ksf, yeah, why?
08:19:33 <ksf> ...because -> is two characters, and the unicode one is going to be one
08:19:34 <mreh> nobody codes in comic sans
08:19:43 <mreh> oh..
08:20:18 <mreh> as long as you conform to unicode, that shouldn't be a problem
08:20:20 <ksf> and generally most of the operators are just to typographically complex as to display properly under those conditions
08:20:40 <benmachine> 𝜆 seems my font hasn't got a glyph for it
08:20:56 * hackagebot upload: hakyll 1.4 - A simple static site generator library. (JasperVanDerJeugt)
08:21:04 <ksf> the problem with variable width, then, is aligning.
08:21:16 <aiju> which is particularly important with Haskell
08:21:35 <mreh> only for leading whitespace
08:21:38 <benmachine> haskell's alignment is typically only on the left though
08:21:39 <benmachine> yeah
08:21:50 <ksf> ...beginning of the line can be made to work properly by using large enough spaces, but inner-line alignment needs variable tabstops
08:21:50 <mreh> I can't think of any right alignment
08:22:08 <mreh> apart from beautifying your code
08:22:09 <benmachine> inner line alignment?
08:22:16 <benmachine> I don't inner line align
08:22:17 <ksf> e.g. lining up ='s.
08:22:23 <mreh> i think he means vanity alignments
08:22:29 <benmachine> yeah I don't do that
08:22:39 <benmachine> I find it jarring when it's big enough to make a difference
08:22:40 <mreh> the only time you generally do that is with like symbols
08:22:43 <jmcarthur> proportional fonts would work fine if we just had editors to do the alignment for us properly. and the language itself could contain some sort of markup for the raw test file to show where alignments should be
08:22:45 <benmachine> and not big enough to make a difference when it isn't :P
08:22:58 <mreh> =, ->, <- in the same block all get the same alignment in my code
08:23:02 <jmcarthur> *the raw text file
08:23:25 <ksf> {-$_____|___________________|___________________|$-}
08:23:33 <jmcarthur> i do alignment if the things i'm aligning are actually related
08:23:39 <ksf> ...and then use tabs
08:24:00 <benmachine> hmm I do like to line things up under wheres
08:24:06 <benmachine> but actually it looks fine when that doesn't work
08:24:07 <jmcarthur> ksf: i kind of like the way lhs2tex does it because it degenerates somewhat well for raw text editors
08:24:08 <aiju> dito
08:24:23 <benmachine> http://github.com/benmachine/stepeval/blob/master/src/LambdaCaseLet.hs whee one-space indents
08:24:45 <mreh> jmcarthur: do you have any ideas how we could do this?
08:24:55 <benmachine> wait hmm maybe my browser is just doing it wrong there
08:25:11 <mreh> prettier haskell would be more appealing
08:25:22 * ksf looks up lhs2tex syntax
08:25:33 <MissPiggy> woah http://twitpic.com/12ql4x
08:26:00 <jmcarthur> ksf: things are considered aligned by lhs2tex if they all line up in the raw text file and they all have at least two spaces before them
08:27:49 <ksf> ...I would be willing to use an editor that displays in tex style but lets me edit in ascii style
08:28:29 <jmcarthur> ksf: oh, and lhs2tex works in blocks, so it resets the alignment cues for each \begin{code} \end{code} block
08:28:42 <jmcarthur> yeah, that's what i'd like
08:29:17 <jmcarthur> or something like agda-mode but with TeX rendering
08:29:27 <ksf> and while I'm at it, an editor that displays tex while letting you edit in ascii paragraph-wise
08:30:07 <fasta> ksf, that already exists.
08:30:29 <fasta> ksf, there is some Emacs mode which does that.
08:30:40 <fasta> ksf, it renders to an external window.
08:30:43 <ksf> It's all very nice when you want to typeset, but I tend to do furious hacking in between typesetting and typesetting, and fast editing works best with a predictable, monospaced ediotr.
08:31:06 <mreh> what have I started!
08:31:25 <monochrom> You have started liberating programming from the plain text file.
08:31:26 <ksf> vim does that, too. you write a makefile for your tex, open a gv on autoreload and then hit :w\n:mak\n
08:31:29 <MissPiggy> yeah that was interesting earlier I learned something about progrmming
08:31:34 <MissPiggy> at least I think I did
08:32:12 <MissPiggy> oh that agda mode is from a long time ago though, for agda2 they use plain text again
08:32:13 <mreh> what we need is a wysiwyg
08:32:24 <ksf> that is, you never know where your curor ends up if you press j or k with a proportional font.
08:32:47 <ksf> I don't want wysiwyg.
08:32:52 <ksf> way too mouse-pushy.
08:33:10 <monochrom> press j or k?
08:33:13 <jmcarthur> MissPiggy: oh i didn't know the old agda-mode wasn't raw text
08:33:19 <monochrom> @quote 1970
08:33:19 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
08:33:20 <ksf> up or down, for you non-viers.
08:33:22 <mreh> we need the benefits of the nice typsetting for the programming
08:33:51 <monochrom> wysiwyg does not imply mouse-pushy.
08:33:53 <ksf> yeah but not wysiwyg. at least not while editing
08:34:00 <mreh> yes wysiwyg
08:34:05 <ksf> it's fine to have it as preview
08:34:17 <mreh> that's not wysiwyg
08:34:21 <monochrom> proportional font does not imply up/down goes to a different vertical coordinate.
08:34:27 <mreh> that's is just wyg
08:34:37 <jmcarthur> it's not really wysiwyg unless the typeset code is the end instead of the means
08:34:46 <ksf> monochrom, but it implies getting either lost because it stays at the same column, or getting lost because it doesn't.
08:35:04 <theorbtwo> Indeed, I'd argue that wysiwyg implies that pressing up-arrow *does* move you to what is visually above you.
08:35:17 <theorbtwo> Otherwise, you didn't get what you saw.
08:35:24 <ksf> ...tex is wysiwyg as soon as it's converted to .dvi
08:35:43 <jmcarthur> i'd rather navigate by blocks and precedence than by line and character, i think
08:35:55 <ksf> ...and I can edit all kinds of stuff without having to leave the text I enter.
08:36:16 <ksf> I navigate by words, usually.
08:37:05 <jmcarthur> i'm not a huge fan of lisp syntax, but i am a fan of a lot of the editors people have come up with to cope with the otherwise visually uniform tangle of parens
08:37:06 <mreh> we want to be able to edit the final product as it would be
08:37:15 <jmcarthur> and i think those techniques could apply to non-lisp-like languages too
08:37:38 <ksf> mreh, heretic.
08:37:41 <jmcarthur> many of them could, anyway
08:37:46 <ksf> stay true to tex and don't propagate MS word.
08:37:49 <monochrom> I disagree with "getting lost because it doesn't". You visually see the cursor stays at the same vertical coordinate. Oh it's a "different column" but who cares.
08:38:21 <monochrom> Perhaps s/who cares/who is counting/
08:38:53 <jmcarthur> i have to admit i used to get annoyed when i used word processors and moving vertically didn't necessarily put my cursor exactly where i thought it would
08:38:55 <xerox> there was a guy here who used non-fixed width fonts for coding, because only layout matters if you refrain from using {}
08:39:10 <mreh> the whole requirement of the column alignment is no longer required when you aren't formatting with whitespace anymre
08:39:52 <ksf> monochrom, that's not my main point. my main point is that I want to be able to do things like \bold{text}. and a wysiwyg editor makes me leave my text and enter some meta-level editing mode, be it selecting + clicking "bold" or some fancy keyboard strokes
08:39:58 <ksf> I want raw, plain, text.
08:40:25 <endojelly> as soon as unicode usage comes into play you'll have a hard time to keep all of your code "fixed width" anyway
08:40:46 <endojelly> some symbols just look stupid if you try to fit them into the character cell.
08:40:46 <ksf> ...and I don't want unicode input. I've only got a 103 key keyboard.
08:40:46 <monochrom> The "fancy" strokes can be: \, b, o, l, d, {, text, }
08:40:54 <mreh> endojelly, it seems that way, but I think, like an excel spreadsheet, that can be fixed
08:41:01 <endojelly> ksf, people get around it by using tex-y input methods
08:41:20 <endojelly> mreh, it can, but it doesn't look good!
08:41:20 <jmcarthur> how is ^b more fancy than \ b o l d { ... } ?
08:41:21 <ksf> monochrom, and if I want to change \bold{text} to \italic{text}, how do I get hold of the bold to change it?
08:41:31 <monochrom> Tell me how is \, b, o, l, d, {, text, }  more keystrokes or fancier than typing \bold{text}
08:42:21 <ksf> the very key of wysiwyg is that you don't see the \bold in your editor, and I can't edit boldness on my screen.
08:42:28 <jmcarthur> if it works on a higher level then you dont' have to do meaningless things like selecting text. you just have the cursor on the correct identifier and hit the magic keystroke
08:42:48 <jmcarthur> if i want to change an identifier from bold to italic i just have my cursor on it an hit ^b ^i
08:43:04 <MissPiggy> hat's just a constant coeffient improvement :P
08:43:12 <ksf> ...anyway, any editor that does that kind of stuff most likely won't have any serious problems offering both modes.
08:43:16 <MissPiggy> when I want to change my text to bold I have to it letter by letter
08:43:19 <monochrom> What jmcarthur says. There are other solutions I haven't thought up too.
08:43:23 <jmcarthur> i don't see how it could be improved any further
08:43:31 <jmcarthur> at least on the identifier level
08:43:54 <mreh> what about formatting the code with tables?
08:44:14 <mreh> tabs?
08:44:30 <jmcarthur> this all just interface design. it doesn't really have to do with the idea itself directly
08:44:44 <jmcarthur> the idea is just that we can do better than plain text
08:44:54 <jmcarthur> especially better than ASCII only
08:44:58 <ksf> tabs are evil, because fixing them to any fixed amount of spaces whatsoever won't work for typesetting, ever.
08:45:11 <ksf> ...one needs to be able to adjust tabstobs for them to make it work.
08:45:12 <mreh> I agree, but, a lot of other people can't do better than plain text, this is what I'm trying to get around
08:45:19 <ksf> any decent mechanical typewriter does that.
08:45:54 <mreh> but i suppose that is just stubborness
08:46:13 <mreh> ksf: I know what you mean
08:46:36 <mreh> good editors have tab stops
08:46:47 <monochrom> You are just confirming that plain-text-fanatics-programmers' 1970 terminals and plain-text-editors are even worse than 1930 mechanical typewriters.
08:47:05 * hackagebot upload: HDBC 2.2.3 - Haskell Database Connectivity (JohnGoerzen)
08:47:41 <mreh> no I didn't
08:48:10 <monochrom> I know, not you, some other plain-text-defender.
08:49:11 <ksf> monochrom, I just don't use tabs.
08:49:30 <ksf> ...I use the key, but it's either inserting four spaces or being smart.
08:50:13 <monochrom> Oh I don't use tabs on 1970 editors either. I use tabs on word processors. They meet or exceed typewriter tabs.
08:50:22 <mreh> does anyone here think is haskell faster than they can type?
08:50:34 <mreh> s/think is/ think in/
08:51:37 <fasta> mreh, there is not a single programming language with basic memory management I know of for which that holds.
08:52:29 <ksf> ...I need to type fast as not to loose the train of thought.
08:52:45 <ksf> It ends up being bursts.
08:52:52 <mreh> I type fast so I don't get bored!
08:53:00 <jmcarthur> i find that i have two modes of programming, and neither require fast typing
08:53:26 <monochrom> http://www.cs.nott.ac.uk/~rcb/mathspad/ tabs exceed typewriter tabs. You can set different tabstops for different lexical scopes. The only thing you can complain about mathspad is it's mousy. But one can see how to re-program it to be keyboardy.
08:53:30 <merijn> I think less then 20% of my programming time consists of typing
08:53:31 <Phyx-> I have seasons where i type fast, much like the weather
08:53:34 <jmcarthur> one mode is for when i know where i'm going but not how to get there, which is when i am doing top-down programming, and i tend to use where a lot.
08:54:02 <jmcarthur> the other is for when i know what direction to go in but not my final destination, which is when i am using bottom-up programming, and i tend to use let a lot
08:54:21 <merijn> Especially since I bought a huge whiteboard, best programming purchase I ever made...
08:54:24 <jmcarthur> and neither case do i really feel like i'm bashing things out as quickly as my fingers can go
08:54:35 <ksf> is anybody volunteering enhancing yi with a tex interpreter?
08:55:07 * hackagebot upload: TTTAS 0.3.0 - Typed Transformations of Typed Abstract Syntax (MarcosViera)
08:55:27 <mreh> merijn: I would spend 20 minutes of every day cleaning it with that fluid
08:55:35 <mreh> mmm, spotless
08:55:50 <MissPiggy> @hackage
08:55:50 <lambdabot> http://hackage.haskell.org
08:55:51 <MissPiggy> @hackage TTTAS
08:55:51 <lambdabot> http://hackage.haskell.org/package/TTTAS
08:56:11 <merijn> You really get mileage out of whiteboards when doing stuff like drawing ASTs and/or program flow :)
08:56:24 <MissPiggy> http://www.cs.uu.nl/wiki/pub/Center/TTTAS/talk-tldi-2009.pdf
08:57:39 <mreh> have they not heard of haskell?
08:58:08 * hackagebot upload: ChristmasTree 0.1.3 - Changing Haskell's Read Implementation Such That by Mainpulating Abstract Syntax Trees it Reads Expressions Efficiently (MarcosViera)
08:58:26 <mreh> oh, they were rhetorical questions
08:58:37 <MissPiggy> http://www.cs.uu.nl/wiki/pub/Center/TTTAS/papertldi.pdf
08:58:50 * jmcarthur wants a whiteboard now...
09:00:37 <merijn> jmcarthur: I figured it's gonna last at least a year or 15 so relatively speaking they're pretty cheap and I've always wanted one :)
09:00:48 <fasta> merijn, what did it cost?
09:02:01 <b0fh_ua> Could somebody please take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21408#a21408 ? Looks like there're some memory leaks with this code, but I don't have much knowledge to identify them. So I need some help, please :)
09:02:08 <Draggor> Greetings!  I'm looking to get a Haskell book.  Any suggestions?  I have a strong background in Lisp if that helps any.
09:02:09 <lpjhjdh> fasta: you can go to home depot and just get a big chunk of the slick white stuff without any fancy metal holders and whatnot for just about nothing
09:02:19 <merijn> fasta: I convinced people to get me one for my birthday, but the prices for large one seem to be €70-€180 ish
09:02:45 <merijn> Maybe even cheaper if you shop around
09:02:49 <Botje> b0fh_ua: the withCurlDo is supposed to go around the code in main
09:02:58 <MissPiggy> Draggor: you can read  Learn you a haskell  online
09:03:06 <Berengal> merijn: I'm deffinitely getting one if I can make room for it
09:03:17 <fasta> lpjhjdh, home depot?
09:03:17 <MissPiggy> @where lyah
09:03:18 <lambdabot> http://www.learnyouahaskell.com/
09:03:31 <merijn> Draggor: Real World Haskell is also available for free online.
09:03:35 <Berengal> I've spent many hours at work working on personal projects just because I have lots of whiteboards there
09:03:36 <Draggor> MissPiggy: I've got a lot of resources online, though I do like dead tree form
09:03:49 <fasta> lpjhjdh, home depot, the website, doesn't have an entry for white-board or whiteboard.
09:04:09 <Berengal> Draggor: RWH is available in dead tree form
09:04:22 <monochrom> Draggor: Bird's "introduction to functional programming using haskell, 2nd edition" if you can find one. can get very advanced.
09:04:30 <monochrom> @quote monochrom krad
09:04:30 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
09:04:30 <lambdabot> entire human race would have to be rewritten!
09:04:33 <merijn> Draggor: I liked the start of Real World Haskell, but I dislike the huge code lists about mid-way in. YMMV, I'd recommend checking it out online to see if that bothers you
09:04:46 <monochrom> It is that much advanced.
09:04:49 <Berengal> Draggor: Also, Hutton's book seems to be highly recommended by Meijer
09:04:53 <fasta> monochrom, sounds interesting.
09:04:54 <Berengal> I haven't read it
09:05:12 <Draggor> I think I have a basic understanding of monads
09:05:24 <monochrom> It also explains stack overflow due to foldl (+) and how to fix it.
09:05:25 <lpjhjdh> fasta: yeah, it's just that material for use with dry erase, not actually a whiteboard
09:05:27 <Draggor> I basically looked how other languages implement them and that's how it started ot make sense
09:05:34 <merijn> fasta: Home Depot (as I understand) it is basically just a large "Do-It-Yourself" shop
09:06:03 <b0fh_ua> Botje: moved it into main, but it raises into 600-700 megabytes of size in less than minute
09:06:03 <osaunders> Does cabal install documentation locally anywhere?
09:06:16 <fasta> osaunders, if you tell it to.
09:06:22 <fasta> osaunders, defaults to not.
09:06:37 <b0fh_ua> Botje: I am using runhaskell to invoke it
09:07:04 <monochrom> All good books go out of print.
09:07:41 * osaunders see --enable-documentation
09:07:44 <osaunders> *sees
09:07:50 <Draggor> Heh, SICP is one I'm after
09:07:53 <benmachine> all other books also go out of print
09:08:12 * hackagebot upload: convertible 1.0.9 - Typeclasses and instances for converting between types (JohnGoerzen)
09:08:33 <monochrom> Not true. Quite some bad textbooks go on to 20th edition, 40th edition, ...
09:10:10 <monochrom> Here is my theory. Bad textbooks have strong "marketting" teams. They bribe university officials to assign their bad textbooks as required reading. Nonstop revenue from exploited students sustain more editions and more printing.
09:11:22 <fasta> monochrom, no need to be positive.
09:11:57 <ksf> ...about editing: http://www.cs.chalmers.se/~aarne/articles/lpar2000.ps.gz
09:12:59 <ksf> that's a more readable page: http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html
09:23:11 <monochrom> I would be more impressed if they demonstrated translating (2*a+2*b)^2 = 4*(a^2 + (2*a + b)*b) into natural language. That would completely destroy all interest in using natural language and therefore that plugin. :)
09:24:56 <MissPiggy> (2*a+2*b)^2 = 4*(a^2 + (2*a + b)*b) by expanding out both sides ??
09:25:09 <MissPiggy> and rewriting into lexicographic ordering
09:29:26 <c_wraith> so...  anyone know why haddock on 6.12 doesn't result in the same docs as haddock on 6.10?  It seems to be just ignoring some of my documentation
09:32:45 <ksf> zomg those free quotas on the app engine are _huuuuge_
09:39:50 <merijn> Ok, unrelated to haskell, but this channel has the highest concentration of language geeks I know: Is there any specific reason why most imperative languages use call-by-value rather then call-by-reference?
09:40:15 <HugoDaniel> performance
09:40:16 <jmcarthur> merijn: i wouldn't say most do, really
09:40:34 <merijn> jmcarthur: Ok, the popular ones then (i.e. those I know :p)
09:40:56 <temoto> merijn, this is rather question to those language developers. They considered something and made a decision. It's not that all people consider same things.
09:40:58 <HugoDaniel> "performance" :)
09:40:59 <jmcarthur> merijn: most of the OO ones i know of aside from C++ do call by reference, except for some primitive types in some languages
09:41:11 <zygoloid> merijn: because you can simulate call-by-reference with call-by-value but not vice versa, perhaps
09:41:13 <ksf> I used to use a hell a lot of call by reference when I still coded C
09:41:25 <merijn> jmcarthur: Most OO ones do call by value, except that the values are references.
09:41:27 <HugoDaniel> void*
09:41:28 <zygoloid> (in turn, because many imperative languages have reference types)
09:41:44 <jmcarthur> merijn: isn't that kind of a moot distinction then?
09:41:58 <temoto> ksf, C has no call-by-reference.
09:42:02 <shapr> merijn: Python uses cbr for the most part.
09:42:14 <ksf> temoto, ever passed a pointer to a struct?
09:42:18 <merijn> jmcarthur: Not really if those languages have immutable types and/or primitive types. (i.e. python's immutable ints or java's int primitive)
09:42:21 <temoto> ksf, yes.
09:42:31 <ksf> see, a pointer is a reference, not a struct.
09:42:36 <temoto> ksf, pointer is copied.
09:42:37 <merijn> ksf: Then you're calling by value, except the value is a reference
09:43:09 <jmcarthur> okay so are we talking about mutable or immutable values?
09:43:24 <ksf> ...and call by reference isn't about passing references into functions?
09:43:53 <jmcarthur> if the latter than it's not semantically important, if the former then most OO languages i know of do call by reference
09:44:30 <ksf> java has unboxed primitive types
09:44:44 <c_wraith> there's a huge semantic difference between call by reference and call by value when the value is a reference.
09:44:52 <merijn> jmcarthur: I agree it is a mostly moot distinction from a programmers perspective. But now that I'm implementing my own language for kicks I just find myself wondering if there's arguments for or against.
09:44:58 <c_wraith> The difference is in what happens if you assign to the name.
09:45:17 <ksf> ...well, then pass a pointer to a pointer to a struct.
09:45:27 <c_wraith> in call by reference, assigning to the name changes the contents of the name in the caller's scope.  In call by value, it doesn't.
09:45:31 <merijn> ksf: call-by-reference does it automagically
09:45:32 <ksf> (and completely blow any sane memory management)
09:46:13 <merijn> ksf: That's why you'd have call-by-reference in the language and make the language figure out how to manage memory instead of doing it yourself
09:46:27 <ksf> the main reason for call by value is sanity by default, then.
09:47:26 <ksf> being able to mess with your callers stuff without the caller being able to do anything against it is a blatant breach of encapsulation.
09:47:53 <ksf> ...just like using globals, just worse.
09:47:58 <merijn> encapsulation is for pussies :)
09:48:14 <c_wraith> let's go with traditional BASIC.  all variable are global!
09:48:45 <ksf> in perl, filehandles are global and identified by strings.
09:48:49 <c_wraith> eww
09:49:27 <merijn> At any rate, so there's no real reason other then personal taste of the creators?
09:49:36 <ksf> ...so if you want to recursively open, you have to pass some string like "hdl0" around and increment it on every open
09:49:53 <c_wraith> call by reference is bad for software engineering, unless all your data is immutable
09:50:23 <merijn> c_wraith: I'm making variables immutable by default unless explicitly declared mutable (in which case maybe do automagic locking on them?)
09:50:28 <ksf> merijn, "personal taste" probably being equivalenty evil as dynamic scope, yes.
09:51:02 <merijn> c_wraith: Maybe with an optional EnableDeadlocksAndRaceConditions pragma to make mutable the default :)
09:52:11 <Twey> We obviously need by-reference dynamic scoping
09:52:49 <merijn> ksf: Well, the more I'm thinking about how I'm going to implement stuff, the more I find myself worrying I'm actually just recreating Lisp and/or Haskell >.>
09:54:06 <Janni> I hope you don't asking me questions like: Does this function already exist (in the base libraries)?
09:54:09 <Janni> toMaybe :: Bool -> a -> Maybe a
09:54:09 <Janni> toMaybe False x = Nothing
09:54:09 <Janni> toMaybe True  x = Just x
09:54:24 <Janni> I hope you don't MIND asking ...
09:54:42 <aavogt> > \b -> guard b >> return "hai"
09:54:42 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
09:54:43 <lambdabot>    arising from a use ...
09:54:45 <cebewee> @hoogle Bool -> a -> Maybe a
09:54:46 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:54:46 <lambdabot> Control.OldException assert :: Bool -> a -> a
09:54:46 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:54:48 <aavogt> > \b -> guard b >> Just "hai"
09:54:49 <lambdabot>   {True->Just "hai";False->Nothing}
09:55:12 <ksf> merijn, google for "optimal evaluation lambda calculus" and let yourself be inspired.
09:55:25 <zygoloid> @hoogle MonadPlus m => Bool -> a -> m a
09:55:26 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:55:26 <lambdabot> Control.OldException assert :: Bool -> a -> a
09:55:26 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
09:55:33 <ksf> with a vm/jit model, it might be feasible to do it.
09:55:40 <cebewee> Janni: does not seem so ;)
09:55:49 <Janni> If not, I will ask such questions from time to time, because I'll be going through my old base candidates libraries
09:56:03 <zygoloid> @pl \b x -> guard b >> return x
09:56:03 <lambdabot> (. return) . (>>) . guard
09:56:33 <zygoloid> Janni: as a first check you might want to try hoogle with the function's type (either on the web or in lambdabot privmsg)
09:56:36 <merijn> ksf: Wow, that returns exactly one hit...
09:56:40 <MissPiggy> Janni -- you can use hoogle to search -- I tend to define stuff myself when it doesn't exist though
09:56:49 <Janni> zygoloid:: Thanks I'm aware of this.
09:56:56 <sinelaw> does GHC use pkg-config to find libs?
09:57:04 <Janni> This channel is the second line of defense.
09:57:16 <zygoloid> yep :)
09:57:37 <ksf> ...without quotes.
09:57:55 * zygoloid likes b <?> x = guard b >> return x; (<:>) = flip fromMaybe
09:57:55 <ksf> merijn, http://scholar.google.de/scholar?hl=de&lr=&cluster=13257825826341247319&um=1&ie=UTF-8&ei=1y18S7-eM8mK_AboxN2jBg&sa=X&oi=science_links&resnum=3&ct=sl-allversions&ved=0CBsQ0AIwAg
09:58:13 <ksf> oh. "reduction" might have been better.
09:58:33 <merijn> ksf: I'll add it to the paper stack
09:59:06 <zygoloid> > map (\x -> (x < 3) <?> 42 <:> 21) [1..5]
09:59:07 <lambdabot>   [42,42,21,21,21]
09:59:15 <ksf> you could also try and do the futamura
09:59:51 * ksf needs to go shopping
10:00:02 <zygoloid> surely someone's written a third futamura projection optimizer by now? ;-)
10:00:56 <MissPiggy> zygoloid huh?
10:01:16 <Berengal> @google futamura projections
10:01:17 <lambdabot> http://en.wikipedia.org/wiki/Partial_evaluation
10:01:17 <lambdabot> Title: Partial evaluation - Wikipedia, the free encyclopedia
10:02:27 <merijn> The insanity of my conceptual language is not really an issue as my Mad Engineering goal is to create a freakish hybrid python haskell monster. (You mean combine a polymorphiclly statically typed purely functional
10:02:44 <merijn> language and combine it with a utterly dynamic ducktyped imperative language?)
10:02:52 <MissPiggy> merijn -- haskell already has dynamic types
10:03:02 <merijn> To which my answer is: *maniacal cackling*
10:03:09 <Saizan> merijn: you might be interested in kata
10:03:14 <MissPiggy> and impreative programming :|
10:03:18 <Saizan> or structural subtyping in general
10:03:33 <merijn> MissPiggy: The point is not to actually accomplish something
10:03:52 <MissPiggy> I can see that lol
10:04:57 <merijn> The point is that if I'm going to be doing something useless and insane to learn compiling/language design I might as well not bother sticking to "slightly insane" and might as well go all the way to "utterly deranged"
10:05:35 <MissPiggy> yeah I don't think you got what I was saying
10:05:45 <lament> merijn: try #esoteric
10:05:58 <sinelaw> What to do about this?
10:05:59 <sinelaw> Could not find module `Control.Monad.Reader':
10:05:59 <sinelaw>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
10:06:00 <MissPiggy> haskell adds dynamic types.. people are doing research in python to add static types
10:06:11 <MissPiggy> we already have imperative programming with IO
10:06:28 <MissPiggy> so what you are talking about is less 'utterly deranged' are more like something you'd find in your garden
10:07:24 <zygoloid> sinelaw: either -hide-package or package-qualified import (or if you're building using cabal, there's umm something else)
10:07:43 <sinelaw> zygoloid, cabal ;(
10:11:57 <Berengal> sinelaw: with cabal you just specify which package it depends on
10:12:12 <Berengal> sinelaw: It hides all packages by default, then enables them one by one
10:12:18 <sinelaw> ah ok
10:20:38 <HugoDaniel> what ways are there to specify default values for my data types ?
10:20:42 <HugoDaniel> im using data-default
10:22:24 <aavogt> instance Default MyDataType...
10:23:10 <HugoDaniel> yes, im using that :/
10:25:36 * hackagebot upload: ChristmasTree 0.1.4 - Changing Haskell's Read Implementation Such That by Mainpulating Abstract Syntax Trees it Reads Expressions Efficiently (MarcosViera)
10:26:12 <aavogt> HugoDaniel: it's just a question of writing more default instances
10:26:22 <aavogt> *Default
10:26:34 <MissPiggy> loooool
10:26:43 <MissPiggy> C-H-R-I-S-T-M-A-S-T-R-E-E
10:27:09 <aavogt> quite a strained acronym
10:27:23 <monochrom> such that by?
10:27:49 <zygoloid> @hackage ChristmasTree
10:27:49 <lambdabot> http://hackage.haskell.org/package/ChristmasTree
10:29:08 <temoto> Is UNIX select(2) directly available in Haskell?
10:32:02 <bos> temoto: no
10:32:16 <Dashkal> Not in standard libs.  That said, haskell forkIO threads are _very_ light.  Just spawn a thread per handle and read.
10:32:24 <Baughn> If I want a haskell interpreter that follows the FFI spec, including C-to-haskell calls, and can be embedded in a C program.. is there one?
10:33:15 <Baughn> (It doesn't have to be an interpreter. Embeddable compiler is fine. It'll just be used as one.)
10:33:42 <Baughn> I know GHC can do it, but that's.. um, way too heavyweight
10:34:49 <twink> Give hardware a generation and it'll be plenty fast.
10:35:09 <osaunders> @pl randIntE rg1 = let (n, rg2) = randomR (1, 20) rg1 in (intE n, rg2)
10:35:09 <lambdabot> (line 1, column 14):
10:35:09 <lambdabot> unexpected "="
10:35:09 <lambdabot> expecting variable, "(", operator or end of input
10:35:33 <osaunders> It doesn't like those.
10:35:38 <Baughn> temoto: There /is/ a library that exposes epoll, however, if you want excessively high performance
10:36:20 <Baughn> temoto: http://www.guzer.com/pictures/boat_split.jpg <- But I warn you, excessive performance has been known to lead to this kind of thing.
10:36:39 <Berengal> In the non-threaded runtime, isn't a forkIO blocking on a read basically the same as a select?
10:36:46 <Berengal> Except without the bother?
10:36:53 <Baughn> In the threaded one too
10:37:27 <Berengal> Yeah, but that can move the thread around different OS threads
10:37:27 <Baughn> The difference is, once they get around to fixing the i/o manager you'll get select replaced with epoll without having to rewrite anything at all
10:37:46 <Baughn> Sure, but it doesn't actually use blocking reads, is my point.
10:38:29 <zygoloid> osaunders: first intE . randomR (1, 20)
10:38:52 <Berengal> My point was that it runs the same code you'd write anyway non-threaded runtime. In the threaded there's additional moving around going on (which you'd also write if you used a threaded select construct thingy)
10:39:03 <osaunders> zygoloid: What module is first in?
10:39:10 <zygoloid> Control.Arrow
10:39:11 <Berengal> Control.Arrow
10:39:15 <temoto> Baughn, i was merely discussing availability of low-level OS async IO primitives in raw haskell.
10:39:35 <mightybyte> @pl (\(x,y) -> (y,x))
10:39:36 <lambdabot> uncurry (flip (,))
10:39:48 <Baughn> temoto: Oh. Well, I'm not aware of any mainstream OS other than windows which support async I/O, and GHC doesn't run well on windows.
10:40:03 <Baughn> *support async I/O well
10:40:08 <zygoloid> @pl \rg1 -> (\(n, rg2) -> (intE n, rg2)) (randomR (1, 20) rg1)
10:40:08 <lambdabot> first intE . randomR (1, 20)
10:40:10 <Berengal> > (comparing length) "(\(x,y) -> (y,x))" "uncurry (flip (,))"
10:40:10 <osaunders> Oh arrows, those are about 4 steps beyond me I think.
10:40:11 <lambdabot>   <no location info>:
10:40:11 <temoto> Baughn, epoll is not well?
10:40:11 <lambdabot>      lexical error in string/character literal at chara...
10:40:18 <Baughn> temoto: epoll is not async i/o
10:40:18 <zygoloid> hmm, wonder why it didn't like the 'let...in'
10:40:42 <bos> Baughn: you need to read more widely, then
10:40:45 <Baughn> temoto: async i/o would be when you pass a pointer to the kernel, it writes incoming data through the pointer and then notifies you when the transfer is complete
10:40:48 <twink> Baughn: Solaris
10:41:04 <Baughn> twink: Probably. Does that still count as mainstream
10:41:05 <Baughn> ?
10:41:11 <temoto> Baughn, are you referring to distinction between 'wait for first event' and 'pass a callback' async IO?
10:41:12 <Baughn> Anyhow, GHC isn't supported there at all
10:41:20 <Berengal> Baughn: It's mainstream enough
10:41:46 <zygoloid> > comparing length "(\\(x,y) -> (y,x))" "uncurry (flip (,))"
10:41:47 <lambdabot>   LT
10:41:49 <bos> linux and solaris both support async IO.
10:41:51 <Zao> Overlapped IO and IOCP on Windows would be awesome.
10:42:02 <Baughn> temoto: Yes. Hm, okay, I see async i/o is a bit broader a concept than I thought.
10:42:23 <Baughn> So what do you call the particular kind implemented by completion ports?
10:42:24 <bos> unfortunately, windows has no useful support for unix-style async IO.
10:42:39 <temoto> Baughn, linux has callback thing for file IO, but it is really not mature yet.
10:42:43 <Baughn> I much prefer the windows kind anyway, though not enough to want to use windows
10:43:02 <Baughn> temoto: I follow the developments there, yes. Hopefully one day it'll be useful, but right now it seems to be going /backwards/
10:43:06 <zygoloid> osaunders: just pretend that 'first :: (a -> b) -> (a, c) -> (b, c)" :)
10:43:32 <temoto> Baughn, completion ports are obviously the callback kind. No?
10:43:40 <bos> i should point out that i have haskell server code running with 30,000 concurrent client connections.
10:43:55 <zygoloid> (rather than Arrow (~>) => (a ~> b) -> (a, c) ~> (b, c))
10:44:12 <MissPiggy> I am scared of bos
10:44:16 <temoto> bos, awesome! :)
10:44:22 <Baughn> temoto: Well, yes, but just calling them callbacks seems insufficiently specific. In theory you could have a callback version where data is still not written into the process' memory space until the callback'd function asks it to
10:44:44 <temoto> that's my dream - to write something under this magnitudes of load
10:45:24 <Berengal> To write something that will ever be under that kind of load
10:45:24 <bos> i can easily sustain 500MB/sec over HTTP using this server code.
10:45:26 <c_wraith> temoto:  you should also know that select doesn't work at that magnitude
10:45:29 <temoto> Baughn, sure you have to have some meanings to skip the data at will.
10:45:32 <c_wraith> temoto: that's the whole point of bos's work
10:45:46 <temoto> c_wraith, yup, i'm aware of that.
10:46:09 <temoto> Berengal, thanks for fix. :)
10:46:15 <osaunders> bos: What are you using?
10:46:24 <osaunders> HappStack?
10:46:37 <bos> osaunders: no, my own server
10:46:53 <osaunders> It is on HackagE?
10:47:01 <osaunders> *e
10:47:17 <Janni> Is it possible to program Haskell using Unicode? I'm talking about using greek letters, bottom-symbol etc.
10:47:24 <Berengal> Janni: Yes
10:47:27 <Janni> I'm not talking about typesetting your code.
10:47:49 <osaunders> Janni: I believe UTF-8 is a requirement of Haskell code.
10:47:50 <Janni> But really using these symbols to define operators, identifiers, etc.
10:48:04 <bos> Janni: yes
10:48:09 <Janni> Hmm. Does GHC support this?
10:48:17 <osaunders> Janni: Just try it.
10:48:24 <Berengal> > let þ = "foo" in þ
10:48:25 <lambdabot>   "foo"
10:48:27 <Janni> Sorry, some time ago I tried to find practical information about it (I also tried it), but didn't succed.
10:48:48 <Janni> Oh!
10:48:51 <Janni> Wow.
10:49:07 <monochrom> > let x∩y = 0 in 0∩0
10:49:08 <lambdabot>   0
10:49:16 <Berengal> There's also -XUnicodeSyntax, which makes ghc understand → as -> etc
10:49:16 <Janni> It actually does work. Since when?
10:49:30 <bos> it's worked for years.
10:49:48 <MissPiggy> :t toList . (++) `on` fromList
10:49:49 <lambdabot> Not in scope: `toList'
10:49:59 <MissPiggy> :t M.toList . (++) `on` M.fromList
10:50:00 <lambdabot>     Couldn't match expected type `b -> c'
10:50:00 <lambdabot>            against inferred type `[(k, a)]'
10:50:00 <lambdabot>     In the first argument of `(.)', namely `M.toList'
10:50:20 <MissPiggy> :t (M.toList .) . (?plusplus) `on` M.fromList
10:50:21 <lambdabot> forall k a k1 a1. (?plusplus::M.Map k1 a1 -> M.Map k1 a1 -> M.Map k a, Ord k1) => [(k1, a1)] -> [(k1, a1)] -> [(k, a)]
10:51:10 <osaunders> bos: Is your server on Hackage?
10:51:18 <bos> osaunders: no
10:51:29 <osaunders> :(
10:51:35 <bos> osaunders: it's all under heavy development as part of the event library
10:51:55 <Berengal> bos: Is it a honest-to-goodness webserver, or just a test server for your benchmarks?
10:52:48 <bos> Berengal: it's a test server. a real server would have about the same performance, though.
10:53:06 <osaunders> Performance has an annoying habit of degrading as you add more features to a thing.
10:53:09 <bos> Berengal: it is parsing HTTP requests more or less properly, for instance.
10:54:32 <Berengal> bos: Neat. It's nice enough to know the pure IO speed, but knowing that you have time to do some real work inbetween requests is more useful, I think
10:55:18 <Janni> Yay! Finally programming using Unicode. Strange, that I didn't come accross this earlier. Never seen any Haskell code using the proper symbols for arrows etc....
10:55:38 <c_wraith> most people have trouble typing them
10:56:09 <bos> Berengal: the raw performance is important for that purpose. the more RPS you can handle, the more room you have to do real work.
10:56:26 <MissPiggy> Janni it's hard to type the normal arrow
10:56:31 <bos> my code is the only haskell code i've ever seen that uses greek letters in production.
10:57:01 <cygnus> Janni: if this code is just for your enjoyment, that's fine, but if you expect others to read and edit it, I strongly encourage you to go with normal characters. :(
10:57:06 <Janni> MissPiggy: Not for me. Just Meta4+RightArrow.
10:57:22 <Berengal> bos: Of course
10:57:40 <Janni> And RightArrow is reachable just fine (http://kinesis-ergo.com)
10:57:51 <Janni> cygnus: I disagree.
10:58:04 <Janni> I think there is no good reason to stick to bad old habits.
10:58:10 <ksf> I don't care how reachable any combination is, I don't want to learn them.
10:58:10 <Berengal> I wouldn't mind a unicode-input plugin for the emacs mode...
10:58:20 <Berengal> Agda makes it work just fine
10:58:32 <monochrom> I agree with Janni. Break the vicious cycle.
10:59:00 <ksf> if you want typeset code, do it properly and use lhs2tex
10:59:01 <Berengal> I want an LCD-keyed keyboard before I start using unicode everywhere though
10:59:17 <cygnus> Janni: it's just something to keep in mind; people will simply be less likely to contribute -- if it's contributions you're hoping for -- if the code is hostile to edit.  And it will be hostile for some people to edit.
10:59:48 <Janni> cygnus: Point taken.
10:59:50 <MissPiggy> reading it is fine
11:00:03 <MissPiggy> and if a program was already written in this way I would have no trouble adapting
11:00:20 * ksf objects anything that isn't US ASCII. heck when I write german latex, I'm using "u etc. for umlauts
11:00:21 <MissPiggy> I just don't care if you use -> or \larrow
11:01:03 <Janni> \usepackage[utf8x]{inputenx}
11:01:11 * monochrom is hostile to anything that objects anything that isn't US ASCII. http://www.vex.net/~trebla/symbols/refute-anti-unicode.html
11:01:21 <MissPiggy> Janni hm? :)
11:01:23 <ksf> I've got a highly trained muscle memory, and getting any keystroke up to that level is no option. and not getting it up to that level means I stutter all the time.
11:02:05 <ksf> I'm not against unicode. I'm against syntax that doesn't fit on my keyboard.
11:02:07 <Berengal> ksf: With proper input support it just gets a little bit more "verbose"
11:02:33 <Janni> ksf: Just configure your input method according to your needs
11:02:35 <ksf> there's just no way to have proper input support for a gazzilion of symbols and letters
11:02:47 <Berengal> After a day with Agda I had trouble writing haskell again. Especially the arrows. I kept typing \r all the time
11:02:57 <Janni> ksf: '-' + '>' is just as much effort as Mod + whatever.
11:03:07 <ksf> "I have prepared a page of math symbols to help enter common math symbols. You can click buttons to select symbols, then copy-and-paste. You can copy and adapt my HTML and javascript code to your computer or your website."
11:03:09 <ksf> zomg.
11:03:19 <monochrom> haha
11:03:46 <monochrom> It's a good start. Perhaps tomorrow they can be entered easily on the keyboard.
11:04:10 <ksf> right pinky - left pinky shift left middle finger >
11:04:15 <monochrom> But today, let's break the vicious cycle by getting a few people to use them first. To generate demand.
11:04:29 <ksf> ...any meta combination is going to be slower, because I have to reposition the hands.
11:04:43 <monochrom> I understand the prior-investment argument.
11:04:46 <cygnus> monochrom: what folks are saying is, demand can't be generated because the approach is too tedious.
11:04:51 <ksf> that's it. I bet all those people advocating unicode syntax just can't touchtype.
11:05:11 <Janni> ksf: Buy a proper, overpriced keyboard (sorry, I have to keep praising my Kinesis Advantage)
11:05:20 <ksf> I have a proper keyboard
11:05:23 <Berengal> "data \bn : Set where; zero : \bn; succ : \bn \r \bn" <- Key sequence for writing the common definition of the natural numbers in Agda (replace ';' by newlines)
11:05:24 <hzap> newbie question: what are the meta-combinations?
11:05:27 <MissPiggy> I don't
11:05:28 <ksf> and don't claim otherwise, it's an religious issue.
11:05:33 <ksf> IBM model M. beat that.
11:05:48 <MissPiggy> data \bn : Set where zero : \bn; succ : \bn \r \bn -- should work without newlines
11:05:57 <monochrom> cygnus: "the" approach? There is only one approach? The click-this-button approach is tedious, yes, but it is not the only one.
11:05:58 <Berengal> ksf: Eclipse II. It's a Model M with backlights
11:05:59 <joga> Janni *5*
11:06:01 <Janni> ksf: heh.
11:06:11 <cygnus> monochrom: sorry, every approach I've heard of. :)
11:06:12 <Janni> joga: ?
11:06:22 <joga> Janni high-fiving for Advantage ;)
11:06:32 <MissPiggy> äåãø˛đłúüöá`ß´¨ˇñéíæ^çœ˘˚¯<--- I dont use ANY of these keys
11:06:34 <Janni> Right *5*
11:06:48 <MissPiggy> but that's what alt-whatever does
11:06:49 <MissPiggy> ÄÅÃØ~ĐŁÚÜÖÁ~~˝~~ÑÉÍÆ~ÇŒ~~~ <-- none of these either
11:07:09 <MissPiggy> If I needed to type lots of arrow symbols I'd set those keys to do it and it would be as easy as typing uppercase letters
11:07:19 <MissPiggy> so I don't understand the argument that it is difficult
11:07:21 <ksf> Berengal, that's BS. you don't have buckling spring keys
11:07:42 <ksf> http://en.wikipedia.org/wiki/File:Model_M_patent.png
11:07:48 <MissPiggy> the REAL problem re. unicode on IRC is that it looks AWFUL
11:08:13 <MissPiggy> if you want properly typeset mathematics and source then do not use unicode!
11:08:22 <monochrom> Maybe your font looks awful.
11:08:25 <MissPiggy> yes it does
11:08:35 <monochrom> Mine is fine, thank you.
11:08:50 <idnar> mathematical symbols and monospace don't mix very well
11:09:00 <ksf> math typesetting and a couple of accidentally arranged unicode symbols have nothing in common, visually.
11:09:02 <monochrom> I don't use monospace for IRC.
11:09:13 <Dashkal> Give me this one with the fancy symbols on it, and I
11:09:18 <Dashkal> 'll use unicode: http://www.artlebedev.com/everything/optimus-tactus/
11:09:18 <MissPiggy> monochrom you don't want to keep things like square root brackets, ------ for idivison, nontrivial exponents indices?
11:09:24 <idnar> I'm not sure my terminal emulator can do variable-width fonts
11:09:33 <idnar> er, variable-width text
11:09:52 <Dashkal> (Yes, I'm aware that that keyboard is vapourware)
11:09:56 <cebewee> mlterm can. But it's not a good idea for most applications
11:10:27 <Berengal> Dashkal: No keys means no decent feedback
11:10:36 <monochrom> No one is "properly typesetting mathematics" on IRC anyway. For casual math on IRC, however, D∪B beats D\cup B. (What is D cup?)
11:10:48 <Dashkal> Berengal: http://www.artlebedev.com/everything/optimus/ -- Not cheap, though
11:10:51 <idnar> haha @ D-cub
11:10:53 <idnar> err, D-cup
11:10:55 <MissPiggy> monochrom that's true but it doesn't seem like progress
11:11:01 <Berengal> Dashkal: I know. I've been drooling over that for a while
11:11:04 <cebewee> monochrom: There are lot's of images on the internet ;)
11:11:05 <MissPiggy> just having more and more letters doesn't solve the problem
11:11:10 <Dashkal> latex in irc seems... intentionally obfuscated.
11:11:46 <ksf> D \/ B
11:11:59 <Dashkal> The tactus reminds me of a geek dream I have of having a touchscreen moonitor mounted in a wall somewhere as a universal gadget/whiteboard/etc
11:12:26 <ksf> ...anyway, people are laughing when I'm talking about math, anyway, so I don't do it.
11:13:03 <Dashkal> That said, a tactus style keyboard could potentially have tactile feedback.  I forget which phone designer came up with it, but it hit /. a couple months back.  Get that and you can have all your fancy math symbols and touch feedback without forking out a grand for a keyboard.
11:13:33 <ksf> I'd still have to look at the keyboard to know what I'm typing.
11:14:46 <Janni> Ah yes, while we're talking about bad old habits... How about arbitrary line length? It always bothered be to restrict the code lines I have written to some fixed length (there are no good criteria for that)
11:14:48 <c_wraith> semantically, what is record update syntax?  is f { foo = bar} a function applied to f that isn't evaluated until forced?
11:15:20 <Janni> Shouldn't what is specific to some user (terminal columns) be left to the user?
11:15:31 <Berengal> Janni: limited line length is a sensible choice. I hate having to read long lines, even when it fits on my screen without breaking
11:15:47 <c_wraith> there's a reason newspapers use columns, after all
11:15:50 <Janni> Berengal: That's what I'm talking about. That's YOUR choice as a viewer.
11:15:51 <ksf> it's not a matter of how wide your terminal is. it's about characters/line.
11:15:52 <c_wraith> It's not line length
11:15:58 <Janni> Therefore you should tell your editor to wrap these lines.
11:16:05 <ksf> and 80, incidentally, is quite a sane amount.
11:16:10 <Janni> And that's where my woes start.
11:16:16 <c_wraith> the editor will never pick as good a wrap point as a human can
11:16:17 <ksf> automatic wrapping is just plain ugly.
11:16:17 <Berengal> ksf: It's more about how much of your viewspace the text takes up
11:16:18 <Janni> There is no editor that is able to properly do that.
11:16:26 <Berengal> And how fast you can read
11:16:28 <ksf> Berengal, exactly.
11:16:56 <Berengal> Eyes like to wander. If they have to continue in one direction for a long time it's hard to focus
11:17:06 <Janni> If the editor wraps the code correctly (preserving indentation) and intelligently, that's something I'd like to have.
11:17:11 <c_wraith> Anyway.  does f { foo = bar } generate a thunk?
11:17:19 <ksf> it's a typesetting thing. you don't want to have the beginning of your line in peripheral vision when you're at the end of another, because then finding it isn't O(1) anymore.
11:17:30 <Janni> There was a "breakident"-patch for vim some time ago, but it wasn't included to the main branch.
11:17:47 <Janni> And it is not compatible anymore.
11:17:48 <Berengal> c_wraith: Huh... I don't know. Now I suddenly want to
11:17:57 <ksf> c_wraith, look at the core output.
11:18:01 <monochrom> No one is saying Janni will write infinitely-long lines. Janni also keep to short lines. Janni's "short" may be just 10 characters longer than yours.
11:18:05 <aavogt> > mempty { appEndo = undefined } `seq` ()
11:18:06 <lambdabot>   * Exception: Prelude.undefined
11:18:16 <ksf> depending on situation, it should just be optimized away.
11:18:22 <ksf> especially if f is inlined.
11:18:27 <Berengal> aavogt: Endo isn't lazy
11:18:36 <aavogt> c_wraith: if it's a newtype record updates are strict
11:18:49 <Janni> So, my thesis is, that once there are proper editors available everyone will look back to the years where he still had a static max-line rule and wonder...
11:18:57 <Berengal> If it's a newtype record updates are useless
11:19:06 <Janni> monochrom: True, but not necessarily.
11:19:19 <ksf> I generally try to stick to 80, but most times won't go to lengths to fix stuff when it's 80-90.
11:19:28 <ksf> especially if it's a one-line function
11:19:55 <Janni> ksf: I think that this is just an anachronism: Typesetting code by hand.
11:20:04 <Janni> I know, everyone does it (I myself)
11:20:16 <Janni> But it should be reduced to a sensible minimum by intelligent editors.
11:20:22 <Berengal> I find haskell to have a more 2d-friendly layout than other languages, so I don't bother too much about the absolute line length, as long as you don't have to read long continuous lines
11:20:28 <ksf> It's the same pass as running hlint. make the code more beautiful.
11:20:50 <ksf> I definitely don't care about line length (or any other formatting) while I'm hacking away.
11:21:00 <Berengal> I do tend to put extra newlines where I don't strictly need them though
11:21:06 <Dashkal> Line length...   I (generally) only run into trouble with comments.  What I want is to be able to attach comments to points in the code and have them float like notes in a word processor app.  Problem solved.  I wonder if there's an emacs mode for that :P
11:21:29 <ksf> Dashkal, -- [1]
11:21:50 <ksf> then, under the function -- [1] Foobar. \s-- [2] Barbuz!
11:21:54 <Dashkal> ksf: If my code editor could float the referenced comment for me, that would be ideal.
11:21:59 <Janni> I think one day I will write a syntax-driven editor...
11:22:10 <Janni> One where you don't edit text, but a concrete syntax.
11:22:33 <Zeiris> Is there a good data type for mutable 1-dimensional fixed-size arrays (bytes, integers, either one's good)  in the standard library?
11:22:36 <Berengal> Janni: The problem with that is that most syntax is one character long
11:22:36 <bos> I keep my lines under 80 columns on the principle that making other people resize their windows to fit my whims is obnoxious.
11:22:39 <Dashkal> The closest I've seen in code editors is comment folding.  Not quite the same thing.
11:22:42 <ksf> those exist. they were never sucessfull, except in the lisp case.
11:22:53 <Berengal> Janni: And in ASTs there can be even more
11:23:01 <Berengal> *syntax per character
11:23:32 <Berengal> ksf: In the lisp case a syntax-editor IS a text editor...
11:23:38 <Janni> Berengal: I don't quite follow what you mean by your last phrase.
11:23:42 <c_wraith> Zeiris: There are variants of arrays that do that.
11:23:47 <c_wraith> @hoogle MArray
11:23:47 <lambdabot> module Data.Array.MArray
11:23:48 <lambdabot> Data.Array.MArray class Monad m => MArray a e m
11:23:48 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
11:23:50 <ksf> the problem with an AST-editor is that you loose all the benefits parsing gives you.
11:23:51 <Dashkal> I've more than once drempt of coming up with a visual language where coding is performed by linking blocks together not unlike a digital logic simulator.
11:24:04 <Berengal> Janni: Characters are more consise than structured syntax
11:24:05 <ksf> which is, once again, blazingly fast editing.
11:24:12 <aavogt> @hackage vector
11:24:12 <lambdabot> http://hackage.haskell.org/package/vector
11:24:22 <Dashkal> Funny... now that I've learned pure functional programming, that dream seems much more possible.
11:24:52 <ksf> the first thing into that direction should be an interactive 3d-interface for vacuum.
11:25:12 <ksf> one where you can collapse and force values interactively.
11:25:17 <Berengal> Janni: I'm not saying it's impossible. In fact, I believe it's quite possible, but not with todays languages. You need to invent a new language with a different syntax, that might not be serializeable to human-readable text
11:25:23 <Berengal> (xml doesn't count as human-readable)
11:27:41 <Janni> Berengal: I don't think it would be a requirement that the editor would give you a representation that you would edit as normal text. I guess I wouldn't mind instructing the editor what kind of editing operations to perform.
11:28:17 <Janni> If this is done in a sensible way it might be a very powerful editing interface.
11:28:26 <silver> http://hackage.haskell.org/platform/ claims that ubuntu 9.10 have haskell platform but aptitude search gives nothing... where I went wrong?
11:28:32 <bos> people have been doing visually oriented languages for years.
11:28:38 <ksf> Janni, your language will fail if you force people to use a particular editor
11:29:02 <Janni> ksf: I'm not talking about a different language. I'm talking about a different editor to edit let's say Haskell.
11:29:21 <ksf> silver, don't use the debian/ubuntu provided packages. there's all kind of issues with them
11:29:41 <silver> oki then
11:30:06 <silver> playing with ubuntu to feel the difference with gentoo :)
11:30:17 <ksf> the minimum comfortably working install is getting an ghc binary and then compile cabal-install by hand.
11:30:32 <Zao> Mighty odd. Top-level build-depends: are not taken into account when "cabal install"-ing a package.
11:31:11 <Zao> Had to put mine inside a Library block for cabal to pick them up.
11:31:23 <cebewee> ksf: Care to explain?
11:31:24 <ksf> silver, also don't care about having the platform or not. just install what you need via cabal
11:31:51 <ksf> cebewee, explain what?
11:32:02 <cebewee> Issues with Debian packages
11:32:32 <cebewee> (other then being probably out-of-date if you use Debian stable ;))
11:32:38 <ksf> dunno, I'm a gentoo user. but people complain all the time and others say the package maintainers like to break things and do insane stuff.
11:32:39 <silver> ksf, thanks for the tip
11:32:42 <c_wraith> it seriously screws up haskeline
11:32:44 <ksf> also, it's wholly out of date.
11:36:35 <Berengal> Janni: It might be possible to provide a less-detailed syntax-based visual editor for existing languages, but I don't think you could make it good without dropping the details of the syntax. That is, you wouldn't be able to write new code in it
11:44:45 <c_wraith> use of vacuum suggests that f { foo = bar } does create a thunk
11:45:02 <c_wraith> (I don't know how to read/generate core files, so I'm just poking at things)
11:45:34 <ksf> cabal install ghc-core
11:45:57 <ksf> lets introduce thunks, cases force them. the rest is squinting properly.
11:47:50 <aavogt> > case let x = x in x of _ -> "halted"
11:47:51 <lambdabot>   "halted"
11:48:40 <ksf> core /= haskell.
11:49:01 <ksf> I've never seen a let in a case, before.
11:49:44 <Berengal> Core has letrec too
11:55:05 <c_wraith> more playing with vacuum...  I really want a function to launch graphviz with a data set...  from ghci
11:55:34 <jotik> haskell support in linux distros frustrates me. So does cabal - you can't properly install anything.
11:55:44 <jmcarthur> jotik: works great in arch ;)
11:55:58 <jotik> does arch have agda-2.2.6?
11:56:31 <jmcarthur> forgive the paste:
11:56:35 <jmcarthur> % bauerbill -Ss agda --aur
11:56:36 <jmcarthur> AUR/agda-executable 2.2.6-1
11:56:38 <jmcarthur>     Command-line program for type-checking and compiling Agda programs
11:56:39 <jotik> I'm on gentoo, and I've already tried ubuntu and debian to install anything necessary to install that version of agda, but have failed.
11:56:40 <jmcarthur> AUR/haskell-agda 2.2.6-1
11:56:42 <jmcarthur>     A dependently typed functional programming language and proof assistant
11:57:05 * jotik will now go download arch linux. Thanks, jmcarthur!
11:57:10 <Zao> jmcarthur: bauerbill... how many bloody wrappers upon wrappers does arch have for packaging?
11:57:17 <jmcarthur> Zao: quite a few ;)
11:57:42 * Zao pets yum.
11:58:03 * copumpkin writes a new package tool called omnom
11:58:03 <jmcarthur> the reason we have so many, of course, is because we have the main repos, abs, *and* aur
11:58:04 <silver> packages in aur are probably generated from cabal packages
11:58:27 <jmcarthur> silver: yeah i think dons has a script to help automate that
11:59:11 <copumpkin> mmm, my tron AI continues to outperform everyone at failing to achieve victory!
11:59:19 <jmcarthur> copumpkin: :)
11:59:45 <jmcarthur> mine continues to do better than it should considering how it works
11:59:57 <copumpkin> I imagine it's getting a lot harder to rise in the ranks
12:00:01 <copumpkin> as everyone's AIs get better
12:00:08 <jmcarthur> copumpkin: Zeiris has a cool one. it's purely monte carlo and is in the top 100
12:00:23 <copumpkin> nice
12:00:28 <silver> tron AI? what's that?
12:00:37 <jmcarthur> silver: http://csclub.uwaterloo.ca/contest/index.php
12:01:01 <jmcarthur> copumpkin: this is Zeiris's http://csclub.uwaterloo.ca/contest/profile.php?user_id=2746
12:01:05 <jmcarthur> yes, it's python...
12:01:08 <silver> jmcarthur, thanks
12:01:13 <copumpkin> omg fail
12:01:32 <copumpkin> Zeiris: HOW COULD YOU!?!?!?!
12:01:36 <copumpkin> TRAIT0R!
12:03:08 <copumpkin> we need edwardk to wow everyone with his never-losing, never-tying zygohistomorphic preprotronomorphism AI in haskell
12:04:00 <silver> :)
12:04:17 <jmcarthur> preprotronomorphism, ha
12:04:50 <sinelaw> @hoogle (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b
12:04:51 <lambdabot> Warning: Unknown type Vector
12:04:51 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:04:51 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:04:56 <Zeiris> copumpkin, BWAHAHAHAHAH
12:05:49 <Zeiris> (I'm sorry, I wanted to hack something together quickly, and doing something that trivial was much easier for me in Python than wrestling with impure random number generators in Haskell.)
12:06:01 <copumpkin> :'(
12:06:08 <copumpkin> never forgive!
12:06:49 <Zeiris> No worries, once I get some coffee I'm writing it properly (and adding at least one level of minimax like jmcarthur suggested) in Haskell.
12:07:08 <Zeiris> I want the geek cred.
12:07:26 <jmcarthur> Zeiris: nooooo! i was planning to beat you at your own game :P
12:07:42 <jmcarthur> not really, but i was thinking it would make a cool experiment to mix in with my other strategies
12:07:44 <copumpkin> maximin
12:07:53 * copumpkin has a secret strategy up his sleeve
12:07:57 <jmcarthur> maximin is also a strategy, but not as good
12:08:02 <aavogt> strategy is "up"
12:08:05 <copumpkin> it's a pity I'll probably never get around to implementing it, but at least I can claim I have a secret strategy
12:08:11 <copumpkin> aavogt: well, in addition to that :P
12:08:16 <Zeiris> jmcarthur, feel free - I hardly have a patent on the idea :p
12:08:20 <jmcarthur> heh
12:08:30 <medfly> geek cred
12:08:43 <Zeiris> Besides, if I decide I have something that actually has a chance of winning - THAT I will keep secret :)
12:09:01 <Zeiris> The success of this hideous thing is a complete shock.
12:09:15 <aavogt> csclub people will be able to see your code
12:09:28 <jmcarthur> while i think it's not helping the elitist attitude that non-haskellers perceive of haskellers, i rather like the "geek cred" approach people are starting have toward it. at least it's more attractive than simply elitist
12:09:30 <Zeiris> I guess it does well because it's a pretty efficient space-filling algorithm on its' own.
12:10:28 <jmcarthur> sooo... any good american universities that do a lot of haskell stuff?
12:10:47 <jmcarthur> looking into grad school a bit
12:11:37 <jmcarthur> i only restrict to american so i can get to my family more easily and such
12:12:13 <copumpkin> jmcarthur: pdx, maybe penn?
12:12:20 <shapr> Yeah
12:12:26 <copumpkin> definitely not this one :P
12:12:38 <shapr> Downside is that flights are cheap to Atlanta or Nashville, but not so much to B'ham or HSV.
12:12:38 <jmcarthur> pdx = ?
12:12:44 <shapr> um, pdx.edu ?
12:12:53 <shapr> http://www.pdx.edu/
12:12:57 <shapr> Portland State
12:12:57 <jmcarthur> ah portland state
12:13:03 <shapr> Right next to Galois
12:13:29 <shapr> So you could mix in job opportunity stuff :-)
12:13:32 <copumpkin> also, I'd assume if you hunted down the academics who are involved in haskell and looked up their institutions you'd find more
12:13:36 <copumpkin> kansas state maybe?
12:14:03 <jmcarthur> copumpkin: penn = penn state or u penn?
12:14:27 <shapr> Good point, Andy Gill is looking for grad students.
12:14:40 <jmcarthur> oh i like andy gill's work
12:14:43 <shapr> Wherever Weirich is?
12:15:08 <copumpkin> jmcarthur: upenn
12:15:11 <shapr> Wherever byorgey is...
12:15:26 <shapr> preflex: @seen andyjgill
12:15:26 <preflex>  andyjgill was last seen on #haskell 45 days, 4 hours, 12 minutes and 45 seconds ago, saying: Got to go.
12:15:37 <jmcarthur> hmm, i think an old friend of mine is at upenn
12:15:46 <copumpkin> both dmwit and byorgey are there
12:16:01 <shapr> Yeah, hac-phi was awesome :-)
12:17:09 <shapr> jmcarthur: Why not hit scholar.google.com, search for Haskell, grab the references for the past three years, and figure out which US unis do your favorite research?
12:17:14 <c_wraith> well.  vacuum really is a terrific tool.
12:17:36 <jmcarthur> shapr: that's a good idea, actually
12:17:52 <c_wraith> shapr: psu isn't right next to galois.  It's like...  10 blocks. :P
12:18:05 <shapr> You're right, that's almost too far to walk!
12:18:15 <c_wraith> it could take like 10 minutes!
12:18:21 <c_wraith> actually, PSU's campus is huge
12:18:34 <c_wraith> it could add another 10 minutes depending on which part of campus you're going to
12:18:35 <c_wraith> :)
12:18:52 * jmcarthur is used to walking 30 minutes to get across campus
12:19:16 <Berengal> Uh, just how big is it?
12:19:17 <c_wraith> well.  PSU is huge for a totally urban school.  It's small for schools that include non-urban areas
12:19:55 <jmcarthur> the school where i went for undergrad was... semiurban... in the city, but not thick city at all
12:19:55 <copumpkin> jmcarthur: after a Ph.D?
12:20:07 <jmcarthur> copumpkin: leaning torward it strongly
12:20:14 <jmcarthur> *toward
12:20:22 <copumpkin> :)
12:21:03 <jmcarthur> my undergrad gpa was not so good though. not sure how strong of a ph.d candidate i would look like
12:21:39 <Berengal> People at work have started pestering me about getting my Bs... Something about me talking about monads and continuations alot...
12:23:39 <monochrom> You only get B with monads and continuations?
12:24:28 <Berengal> Bachelor
12:25:00 <Berengal> Someone actually said to me today "That last sentance passed the syntax checker, but I seem to be lacking some imports."
12:25:23 <jmcarthur> i don't talk about monads at work
12:25:27 <Berengal> At least he agreed to learn Haskell just so he could understand wtf I was on about
12:26:24 <Berengal> I tried shutting up about them for half a year, but nobody seemed to notice I wasn't talking about them, so I decided to change my tactic
12:26:38 <c_wraith> Ok.  vacuum shows clear evidence that in ghc, f { foo = bar} creates a thunk
12:27:36 <mreh> Berengal: you don't have any undergraduate training?
12:28:13 <Berengal> mreh: I started on a bachelor, but got bored. Learning Haskell was the dumbest thing I did
12:28:41 <mreh> Berengal: do you find it difficult to find work stimulating enough?
12:28:47 <Berengal> At least in a real job I get to make money and actually do something useful
12:28:51 <Berengal> mreh: Yeah
12:29:13 <byorgey> jmcarthur: Andy Gill is at University of Kansas (I think someone mentioned Kansas State which is different)
12:29:17 <Berengal> I'm doing fine on my own personal projects, but they rarely end up useful
12:29:22 <byorgey> jmcarthur: and yes, you should come to Penn =)
12:29:30 <Berengal> @quote fizzled
12:29:30 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
12:29:48 <mreh> sounds like classic haskellitis
12:29:55 <Berengal> I have it bad :(
12:30:15 <mreh> You need dummies to fill in the blanks when you've worked out most of the details
12:30:27 <mreh> that's why other languages were invented
12:30:38 <scanish> haskellities... yeah I've worked on my prog for 5 hours straight and reached a dead end, maybe someone can help me so i can spend another 5 hours on it?
12:30:57 <mreh> scanish: speak to me when you read the 12 hour mark
12:31:19 <Berengal> My current strategy is to force the end product to be so simple and elegant that once the last kinks are worked out I won't need more than 10 lines to implement it
12:31:20 <scanish> mreh: i need to work by then so that won't happen
12:31:30 <byorgey> scanish: sure, what's the problem?
12:31:49 <mreh> Berengal: the trouble then is, I find, nothing ever actually gets done then
12:32:00 <scanish> byorgey: my problem is i am writing a Dabase/Web application and want to switch Exception handling
12:32:04 <mreh> I keep putting things off in the hope that the perfect solution will come
12:32:16 <mreh> it never does until six months after
12:32:39 <Berengal> mreh: Yeah. I'm a bit too dumb to make something elegant the first time around, and unless I'm happy with an idea I don't go around implementing ugly hacks that sort-of look like it
12:32:53 <scanish> bascially I have a Monad (AppT IO a) and I want to "reroute" catch and throw and so on for that
12:32:56 <byorgey> Berengal: no one makes elegant things the first time around.
12:33:15 <mreh> I haven't actually implement a single monad yet, and that seems strange to me
12:33:32 <mreh> I haven't had many, oh that's a monad moments
12:33:33 <Berengal> byorgey: I like to pretend I do whenever I get something done :P
12:33:56 <byorgey> mreh: that's not actually that strange.  It's pretty rare to need a monad that isn't in the standard libraries, I've found.
12:34:04 <scanish> mreh: My Monad carries my database connection so i can hardly do without it
12:34:06 <byorgey> Berengal: =)
12:34:07 <mreh> byorgey: good :)
12:34:19 <mreh> scanish: Reader monad?
12:34:42 <scanish> mreh: Yes, plus CGI monad mixed in
12:35:10 <mreh> ...should I upload this program even though I'm sure there's a bug in it?
12:35:22 <mreh> upload now, ask question later
12:35:26 <scanish> mreh: I've got it from a site and changed it a bit and so far it worked fine...
12:35:27 <scanish> heh
12:35:50 <mreh> scanish: monad transformers is something I need to learn
12:36:07 <jmcarthur> byorgey: :)
12:36:08 <Berengal> @quote put.it.on.Hackage
12:36:08 <lambdabot> dons says: [on whether a library is wanted] *yes* put it on Hackage!
12:36:29 <mreh> dons has a conflict of interests
12:36:36 <mreh> I don't want people to laugh at my program :(
12:36:44 <Berengal> The wasteland quote is gone from lb it seems...
12:36:46 <jorick> can someone take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21450#a21450 and see what's wrong? i can't figure it out :(
12:36:55 <Berengal> mreh: Fix bug, upload later
12:37:04 <mreh> right, it's going on hackage, there people can test it to destruction, because I'm tooo lazy to test it
12:37:12 <jmcarthur> oh looks like my friend has gone to another uni now
12:37:20 <scanish> well i just hoped there might be someone helping me with that =/
12:37:24 <mreh> Berengal: there aren't bugs, just not much in the way of sanity checking
12:37:53 <mreh> so it will have unexpected behaviour if used incorrectly
12:38:01 <mreh> I hope that's not too bad
12:38:28 <scanish> jorick: looks to me your loop method takes 3 arguments but you call it in recursion with just two
12:38:30 <Berengal> mreh: See, that's one of the things I force myself to remove. Add types until bad programs won't typecheck anymore
12:38:48 <Berengal> Unfortunately, it's certainly no trivial task
12:38:59 <jmcarthur> and sometimes the type system simply isn't powerful enough
12:39:08 <jmcarthur> less and less commonly though :)
12:39:17 <jorick> it says the last statement in a do construct must be an expression ?
12:39:28 <mreh> jorick: that's right!
12:39:28 <Berengal> jmcarthur: And then there's Agda, which is dangerously close to what's theoretically possible
12:39:43 <jmcarthur> jorick: i bet your last line looks like foo <- bar, which you aren't allowed to do
12:39:43 <jorick> scanish thx that's a diffrent bug ;-)
12:39:47 <Berengal> At least until we make a better theory
12:39:57 <jorick> no it looks like "loop inbox state' id"
12:40:09 <jmcarthur> maybe an indentation problem then?
12:40:17 <jmcarthur> hpaste?
12:40:39 <jorick> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21450#a21450
12:41:04 <doserj> jorick: indent the 'in' more, or leave it out entirely
12:41:25 <aavogt> then leave out the second do too
12:41:27 <jmcarthur> ah yeah, no 'in' necessary in do notation
12:41:48 <jmcarthur> let foo = bar ; mapM_ blah blah blah ; loop inbox state'
12:42:00 <jorick> oh waaw
12:42:27 <jorick> i just figured out let to not have to do foo <- return bar anymore
12:42:50 <jmcarthur> heh
12:44:14 <jmcarthur> byorgey: so what awesome research is happening at penn?
12:45:23 <byorgey> jmcarthur: well, let's see.  There's a project (in collaboration with PDX and Iowa) to design and implement a new practical dependently typed programming language.
12:45:39 <Twey> Ooo.
12:45:53 <jmcarthur> that sounds liek exactly what i want to get into
12:45:55 <jmcarthur> *like
12:46:17 <byorgey> jmcarthur: I'm working with Stephanie + Simon PJ and others to redesign Haskell's core language to allow for some new cool features like semi-dependent types/auto lifting of things from the type->kind level
12:46:34 <jmcarthur> oooh
12:46:42 <Saizan> :O
12:46:50 <byorgey> jmcarthur: I'm also working on the side on my combinatorial species library, with some hopeful applications to QuickCheck improvements and other things
12:47:12 <Saizan> byorgey: so something like she?
12:47:16 <jmcarthur> yeah i've been meaning to look at that
12:47:30 <byorgey> Saizan: yes, exactly like she, but built in =)
12:47:31 <jmcarthur> species, that is
12:47:42 <byorgey> Saizan: she was one of the major inspirations for this work
12:47:55 <ksf> byorgey, any early docs or stuff?
12:48:02 <byorgey> ksf: on what?
12:48:14 <ksf> the awesomeness you're talking about.
12:48:35 <Saizan> that'd be extremely cool, if we can lift functions too that'd be amazing :)
12:48:38 <byorgey> hehe, well, nothing really public yet I guess
12:48:45 <byorgey> Saizan: no, lifting functions is much harder
12:48:51 <byorgey> I don't think that will happen
12:48:52 <Saizan> thought so
12:48:58 <copumpkin> sad, but understandable :P
12:49:02 <ezyang> Does Haskell have an implementation of Clojure's Hash Array Mapped Tries?
12:49:14 <byorgey> ksf: well, except for the combinatorial species stuff, you can get the current version of the library from Hackage
12:49:30 <copumpkin> ezyang: IntMap is as close as you're going to get, if I understand what you're talking about
12:49:39 <sinelaw> has anyone done image processing with haskell here?
12:49:49 <byorgey> jmcarthur: there's lots of other cool research going on too, that's just the stuff that I've been involved in to one degree or another
12:49:50 <Saizan> byorgey: numeric literals would be nice though, even if we've to work on them peano-style via typeclasses
12:49:57 <ezyang> copumpkin: I'm just kind of wondering if it would be a useful project to try to implement this in Haskell.
12:50:01 <sinelaw> opencv maybe?
12:50:09 <aledge> byorgey, you're at Penn?
12:50:09 <ezyang> or if it does terrible things internally
12:50:14 <byorgey> Saizan: sure, that should be do-able.
12:50:17 <copumpkin> ezyang: I'd say yes :)
12:50:18 <byorgey> aledge: yes
12:50:23 <aledge> byorgey, where else did you look?
12:50:40 <ezyang> copumpkin: to which question ;-)
12:50:52 <copumpkin> ezyang: as far as I can tell, by "persistent hashtable", clojure just means an IntMap with a hash function on top of it. Yes that it would be a useful project
12:51:32 <byorgey> aledge: Portland State, Princeton, Yale, CMU, Rutgers... maybe a few other places I'm forgetting
12:51:36 <ezyang> Interesting :-)
12:51:47 <ezyang> I guess IntMap does fancy stuff internally
12:51:49 <aledge> cool
12:51:56 <aledge> i'm starting to research schools now
12:51:58 <jmcarthur> hash function = fromEnum but not one-to-one?
12:51:58 <copumpkin> ezyang: it's really just a trie based on bits
12:52:34 <byorgey> aledge: cool, for grad school?
12:52:38 <aledge> yeah
12:52:46 <byorgey> what sorts of things are you interested in?
12:52:52 <ezyang> I wonder what an "array mapped trie" is
12:53:02 <ezyang> I guess I'll have to read the paper ^^
12:53:05 <jmcarthur> so this persistent hash table thing is really just a less reliable version of EnumSet ;)
12:53:14 <aledge> mostly i did systems undergrad, but I think i might want to do language theory, probably like many people here
12:53:15 <aledge> haha
12:53:25 <copumpkin> http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/ ?
12:54:08 <ezyang> cool link. Will read
12:54:33 <aledge> the two seem to be intersecting a bit, partially because of the multicore question
12:57:21 <sinelaw> preflex, seen wli
12:57:21 <preflex>  wli was last seen on #haskell-blah 222 days, 22 hours, 32 minutes and 38 seconds ago, saying: He's in the bathroom right now having another of those hushed convos about dumping me.
12:58:47 * Twey scratches his head.
13:02:26 <b0fh_ua> Hi there! Can somebody please explain, why this code once executed - starts to eat memory (up to 1.5 Gb)? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21458#a21458
13:02:32 * hackagebot upload: HDBC-postgresql 2.2.3.0 - PostgreSQL driver for HDBC (JohnGoerzen)
13:03:03 <ksf> b0fh_ua, it might be a shot in the blue, but I think it might be possible that you have a space leak.
13:03:24 <ksf> did you try a profiling run?
13:04:16 <ksf> ...compile with -prof -auto-all and run with both +RTS -p (and look at the .prof) and +RTS -hy (and look at the ps after using hp2ps)
13:05:10 <mreh> b0fh_ua: it's not using Random is it?
13:05:37 <mreh> and are you executing it with GHCi?
13:06:23 <mreh> GHCi retains things it's not supposed to, when I was debugging some MonadRandom monad code it hangs on to the stdgen from the last computation
13:07:14 <b0fh_ua> mreh: well, I am using runhaskell to execute the script
13:07:26 <b0fh_ua> probably I should compile it into native code
13:08:50 <mreh> it is worth a shot
13:09:22 <mreh> it's often much more simple than we haskell boffins often think though
13:10:13 <lispy> boffins?
13:10:17 <lispy> ?hoogle boffins
13:10:17 <lambdabot> No results found
13:10:21 <medfly> @wn boffin
13:10:22 <lambdabot> *** "boffin" wn "WordNet (r) 2.0"
13:10:22 <lambdabot> boffin
13:10:22 <lambdabot>      n : a scientist or technician engaged in military research
13:10:27 <lispy> hah
13:10:44 <Dashkal> ksf: I saw you mentioning the preferred way of getting ghc now (cabal).  How does one bootstrap then?  Read: Where do I get cabal stand-alone?
13:11:07 <ksf> ghc ships with cabal
13:11:34 <ksf> ...you install ghc, then download cabal-install and do runhaskell Setup.hs install
13:11:41 <Dashkal> ahh, gotcha
13:11:49 <ksf> ...at which point you should have the exectutable cabal in ~/.cabal/bin
13:12:08 <Dashkal> I'd like to get off of ubuntu's 6.10.  There's some pretty stuff in .12
13:12:16 <lispy> mreh: oh, here we say egghead
13:12:31 <ksf> there's probably a case to be made for ghc to ship with cabal-install, if only to reduce confusion.
13:12:34 <jmcarthur> actually you install ghc, download cabal-install, then run the included bootstrap script which get's cabal-install's dependencies and everything too
13:12:35 <b0fh_ua> hmm
13:12:43 <jmcarthur> *gets
13:12:50 <nschoe> Hi all, can I get some help : I can't understand an error I get which seems to be related to Monomorphism, it occurs when I use 'handle' function.
13:12:57 <mreh> lispy, where is that?
13:12:59 <b0fh_ua> after I compiled it, it doesn't take more than 20 mb in memory
13:13:04 <lispy> mreh: US of A
13:13:05 <ksf> iirc cabal-install ships with its dependencies
13:13:24 <ksf> at least cabal is flexible enough not to need shell scripts to do such bootstrapping
13:13:37 <b0fh_ua> ksf: seems to work
13:13:40 <b0fh_ua> with -O3
13:14:00 <b0fh_ua> 11848K of SIZE
13:14:02 <ksf> there's no -O3
13:14:04 <lispy> b0fh_ua: -O3?
13:14:04 <b0fh_ua> and doesn't grow
13:14:06 <ksf> it's the same as -O2
13:14:16 <jmcarthur> it's not exactly the same, iirc
13:14:20 <jmcarthur> but it's not recommended
13:14:33 <lispy> b0fh_ua: normally you want only -O in haskell, sometimes -O2 (if you can show it help) and there is nothing beyond that
13:14:35 <b0fh_ua> ok, just from C experience :)
13:14:44 * jmcarthur usually uses -O2
13:14:44 <b0fh_ua> lispy: thanks
13:14:46 <lispy> jmcarthur: isn't that gcc specific
13:14:58 <mreh> -O2 is defacto standard
13:14:59 <b0fh_ua> guys, it does work
13:15:01 <b0fh_ua> no leaks
13:15:06 <jmcarthur> lispy: ghc has it too
13:15:16 <jmcarthur> and has the same warnings
13:15:18 <silver> awww :( http://pastebin.com/d7d5d4860
13:15:18 <nschoe> I posted the code and the error I get here : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21459#a21460 . Thank you for helping.
13:15:23 <b0fh_ua> but now it starts to eat more CPU
13:15:26 <Dashkal> Is there a configuration option or env var I can set to make cabal always install docs with libs?
13:15:33 <lispy> It might accept -O3, and if it does then I think it's the same as -O2...now where to look this up at
13:16:15 <mreh> why do so many people think there is an -O3?
13:16:36 <monochrom> because there is an -O77
13:16:42 <mreh> fail
13:16:43 <medfly> there's an -O77?
13:16:51 <ksf> nschoe, specify the exception you want to catch
13:17:00 <hzap> nschoe: I think you need to add a type signature on the _ in the lambda
13:17:04 <ksf> \(e :: NonTermination) -> ...
13:17:04 <jmcarthur> okay fine you win
13:17:19 <Zao> mreh: Because gcc has one?
13:17:30 <ksf> otoh there's no need for the sig on Nothing
13:17:41 <Zao> Personally I'm lobbying for an -OMG to save those Gentoo people time.
13:17:42 <lispy> b0fh_ua: I just asked dons, he does recommend -O2 as default
13:17:55 <ksf> Zao GENTOO USERS ARENT RICERS
13:18:06 <medfly> but ricers are gentoo users?
13:18:07 <ksf> AND I'M GOING TO PROVE IT
13:18:14 <nschoe> ksf, could you explain how I can do this ?
13:18:15 <Zao> ksf: Your words, not mine :)
13:18:30 <nschoe> hzap, should I write \_ :: Maybe Integer ?
13:18:38 <mreh> the maximum optimisation is -O2
13:18:40 <Zao> "Through extensive use of my Coq, I have proven that ..."
13:18:42 <lispy> b0fh_ua: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
13:18:44 <ksf> % grep CFLAGS /etc/make.conf
13:18:44 <ksf> CFLAGS="-march=k8 -pipe -O2"
13:18:45 <mreh> -O3 is not implemented
13:18:54 <ksf> NOW ARE THOSE RICER FLAGS?
13:18:58 <mreh> it was an alias for -Osomething last time I checked
13:19:02 <ben> k8 ?
13:19:03 <ahf> Wrong.
13:19:08 <ben> Sounds like a car model, imo
13:19:14 <ahf> O3 is the highest possibly optimization-flag to GCC.
13:19:17 <monochrom> I wonder what -O2 does in addition to -O1. The GHC doc still recommends -O1.
13:19:20 <hzap> nschoe: the way ksf did just above mine
13:19:24 <ahf> Anything over 3 is equal to 3.
13:19:35 <hzap> nschoe: err, below
13:19:43 <mreh> -O3 doesn't do anything
13:19:44 <lispy> "At the moment, -O2 is             unlikely to produce better code than             -O."
13:20:09 <lispy>              -O2:                                     Means: “Apply every non-dangerous             optimisation, even if it means significantly longer             compile times.”
13:20:20 <Twey> What is -O.?
13:20:24 <Twey> No optimisations?
13:20:28 <mreh> that implies there are more levels, but there aren't any more levels
13:20:30 <monochrom> -O = -O1
13:20:40 <medfly> what does not having -O mean?
13:20:48 <monochrom> -O. = -O then English punctuation :)
13:20:52 <mreh> no optimisation
13:20:56 <medfly> ok
13:21:05 <mreh> that is the default
13:21:06 <ksf> nschoe, use \(e::SomeException) -> ... to catch all of them
13:21:10 <Zao> If you want to explicitly override an -ON earlier on the command line, there's -O0
13:21:11 <ksf> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Exception.html
13:21:12 <medfly> strange default
13:21:29 <mreh> optimisation is extra work I suppose
13:21:31 <medfly> thx
13:21:37 <mreh> it takes several passes usually
13:22:05 <Twey> monochrom: Ohh
13:22:26 <Twey> mreh: Don't we have any dangerous optimisations?
13:22:33 <nschoe> ksf, I've tried but I get an 'Illegal signature in pattern: SomeException'
13:22:35 <medfly> ksf, catch them all :)
13:22:40 <Zao> Isn't -O1 defined as "the set of optimizations that probably do not ruin code and runs decently fast" or something?
13:22:52 <Zao> While -O2 is "HAVE AT YOU, CODE!"
13:22:58 <medfly> hehehe
13:23:28 <mreh> -O2 is guaranteed to be safe
13:23:48 <medfly> so why do gentoo people like -O3?
13:23:50 <medfly> :)
13:23:53 <mreh> dangerous optimisations include removing array beounds checks
13:23:54 <hzap> nschoe: I think you need a language extension enabled (-XScopedTypeVariables or something)
13:23:58 <orbitz> because gentoo peopel liev on teh edge
13:24:01 <orbitz> of reality
13:24:05 * ksf wonders whether nschoe needs -XScopedTypeVariables or similar
13:24:16 <Saizan> for ghc -O3 is currently the same as -O2
13:24:23 <medfly> okay.
13:24:29 * mreh \0/
13:24:32 <ksf> nschoe, in general, I think you're overdesigning.
13:24:39 * hackagebot upload: HDBC-odbc 2.2.3.0 - ODBC driver for HDBC (JohnGoerzen)
13:25:03 <monochrom> gentoo people like to think every compiler is like gcc.
13:25:06 <nschoe> ksf, well I followed the link you gave, I tried : (\NonTermination -> ... and it seems correct.
13:25:29 <ksf> yep, but that's not the exception you want to catch ;)
13:25:42 <nschoe> Ho ?
13:25:50 <nschoe> Which one then ?
13:25:50 <monochrom> OK, now my issue is: why does cabal-install use -O not -O2?
13:26:00 <medfly> people seem to say _o2 is slow
13:26:03 <medfly> er..
13:26:03 <mreh> monochrom, it's the default
13:26:04 <medfly> -O2
13:26:06 <hzap> probably IOException
13:26:21 <mreh> you can set extra GHC flags in the cabal file
13:26:24 <monochrom> building libs is OK to be slow.
13:26:38 <medfly> for me, using cabal is really slow as it is
13:26:44 <monochrom> haha
13:26:49 <nschoe> hzap, does it matter, because my statement is actually to 'return Nothing', should I are the Exception anyway ?
13:26:53 <medfly> it eats all my RAM and begins eating my swap
13:26:55 <medfly> :(
13:26:56 <ksf> ...and IOException doesn't come with constructors you can match against, so you have to do the \(e::IOException) thing
13:26:57 <mreh> -02 as the default would be a nice idea actually
13:27:00 <jmcarthur> i don't feel like it's all that slow at all
13:27:17 <medfly> it's just slow because I swap.
13:27:21 <jmcarthur> ah
13:27:28 <ksf> nschoe, if in doubt, let the program fail unless you have a customers who doesn't want it to fail
13:27:33 <jmcarthur> yeah ghc eats memory for breakfast
13:27:35 <ksf> ...which might or might not include yourself.
13:27:35 * mreh .o0( Maybe I should re-install all my libraries with -O2 )
13:27:49 <monochrom> I haven't tried, I have just heard: -O2 in extra GHC flags is actually defeated by cabal-install when it wants to re-assert -O1.
13:28:12 <hzap> nschoe: I/O exceptions won't match \NonTermination -> ...
13:28:22 <nschoe> ksf, I don't have customer, I'm just learning Haskell actually.
13:28:35 <ksf> oh, then don't care about exceptions
13:28:43 <nschoe> hzap, indeed, 've just tried. Is there a list of all exceptions somewhere ?
13:28:48 <ksf> the default ones are one of the worst-designed parts of the stdlib
13:28:57 <nschoe> Oh yeah ?
13:29:05 <ksf> nschoe, http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Exception.html
13:29:05 <hzap> nschoe: Control.Exception docs
13:29:13 <nschoe> Thx
13:29:34 * ksf likes http://hackage.haskell.org/packages/archive/control-monad-exception/0.8.0.3/doc/html/Control-Monad-Exception.html
13:30:22 <nschoe> Erf, ksf, in my 'learning book' (RWH), I didn;'t reach the chapter about Monads yet.
13:30:36 <ksf> but you're using them!
13:30:51 <ksf> we have the proof in hpaste!
13:31:01 <jmcarthur> you use monads all the time even not in haskell without realizing though
13:31:15 <jmcarthur> i'm in the C monad when i'm writing linux kernel code, ;)
13:31:16 <nschoe> Well, if I'm using them, it's uncoucious ^^
13:31:31 <nschoe> Lol okay, well actually, for the moment I don't even know what a Monad is ^^
13:31:43 <jmcarthur> nschoe: let's hope you never do
13:31:47 <mreh> Carl Jung of the monad unconscious
13:31:58 <jmcarthur> as soon as you start getting an inkling of what a monad is you will be confused about how to do anything
13:32:01 <nschoe> jmcarthur : I'm not sure I understand lol
13:32:28 <mreh> I find the key is to learn how to use specific Monads
13:32:39 <nschoe> BTW, you gave me a linnk where it's written : "The SomeException type is the root of the exception type hierarchy." but why 'SomeException' doesn't typematch when I try to use it in my code ?
13:32:40 <mreh> a Monad isn't a thing in itself
13:32:57 <shapr> Is there a cabal remove?
13:33:02 <jmcarthur> nschoe: you will start learning monads and then go through a large number of waves of understanding, each one both helping and hindering you... until you reach enlightenment
13:33:04 <nschoe> mreh, so we don't understand 'Monads', but some Monad individually ?
13:33:06 <Dashkal> nice.  cabal-install's bootstrap.sh fails because I'm missing a dependancy (parsec)
13:33:23 <shapr> Dashkal: Are you installing the Haskell Platform?
13:33:28 <jmcarthur> nschoe: and enlightenment, in this case, is when you realize there isn't much to learn anyway
13:33:32 <Dashkal> No, ghc itself + cabal
13:33:32 <mreh> Monads: not exactly, you just wont get far trying to learn what "Monads" are
13:33:35 <nschoe> jmcarthur, and does it take long to reach this 'enlightment' ? ^^
13:33:40 <mreh> @quote enlightenment
13:33:40 <lambdabot> ksf says: Confusion is the first step to enlightenment
13:33:43 <mreh> @quote enlightenment
13:33:44 <lambdabot> ksf says: Confusion is the first step to enlightenment
13:33:46 <mreh> hmm
13:33:47 <Saizan> Dashkal: parsec used to be shipped with ghc
13:34:05 <jmcarthur> nschoe: took me a while, but i'm exaggerating about the level of confusion a bit
13:34:20 <Saizan> Dashkal: how did you get your ghc, btw?
13:34:24 <aavogt> @quote eggs
13:34:24 <lambdabot> hobophobe says: So, I can only conclude that Haskell is a memetic virus, and monads are the eggs it lays out in innocent programming forums to entice others to become infected.
13:34:29 <jmcarthur> nschoe: the important thing to take away from what i said is that monads aren't as big a deal as they seem
13:34:35 <ksf> that's my quote about confusion, though, not about enlightenment.
13:34:36 <jmcarthur> people just overhype them and talk about them too much
13:34:45 <mreh> WOOO MONADS!
13:34:47 <nschoe> jmcarthur, IO is a Monad right ? But I don't know how ot use Monad : does it mean I'm using IO very badly ?
13:34:50 <shapr> I'm trying to build ghc 6.12 on ubuntu with ghc 6.10, but the bug in unix-2.4 is causing problems. How can I remove unix-2.4 and stick with unix-2.3 ?
13:34:59 <Dashkal> Saizan: http://haskell.org/ghc/download_ghc_6_12_1.html
13:35:04 <jmcarthur> nschoe: not at all. you don't need to know monads to use IO
13:35:08 <Cale> nschoe: It just means you might be missing out on some convenient operations
13:35:13 <Dashkal> module Text.Parsec is not there.  Checked in ghci
13:35:27 <jmcarthur> nschoe: you use I/O in any other language without thinking about monads, and haskell is no different
13:35:33 <Saizan> Dashkal: ok, then you've to manually dowanload the parsec and network tarballs from hackage and install them using the Setup.hs script
13:35:34 <tensorpudding> in the end, a monad is just something that has a meaningful return and (>>=) function defined for it, and ideally satisfies the monad laws
13:35:42 <Cale> nschoe: You can look in Control.Monad and replace all the m's in the types with IO
13:35:50 <nschoe> Cale, okay, so before I plunge into the Monad chapter of the RWH book, should I first get used to the things I understand only partially ?
13:35:58 <Cale> :t sequence
13:35:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:36:06 <jmcarthur> nschoe: understanding monads gives you additional power, but not understanding them does not take power away relative to what you are probably used to
13:36:07 <Dashkal> Meh, and parsec has its own list of deps...
13:36:09 <Cale> So, for example, that simplifies to  [IO a] -> IO [a]
13:36:14 <Saizan> shapr: ghc-pkg unregister unix-2.4
13:36:28 <shapr> ah right, thanks
13:36:30 <Cale> (because IO is an example of a monad)
13:36:31 <ksf> nschoe, the key to understanding anything is to procrastinate understanding. the other way lies hubris.
13:36:34 * Dashkal grumbles about a bootstrapping cabal that doesn't provide what's required
13:36:47 <nschoe> Cale : okay. That's why I have ben explained for now. That I could for now, replace m with IO
13:36:54 <Cale> okay :)
13:37:02 <shapr> Dashkal: Perhaps you could figure out what's needed and write a wiki page that describes the bootstrap process?
13:37:03 <mreh> also, you can't program with a monad, you program with >>= and return
13:37:07 <shapr> Dashkal: Or maybe fix the bootstrap program?
13:37:08 <ksf> oh, ghc 6.10 came with parsec.
13:37:13 <nschoe> ksf : could you explain your sentence, I didn't get it :/ (sry)
13:37:22 <tensorpudding> do notation makes using some monads a lot easier
13:37:22 <mreh> that's like a minimal set of operators for doing useful things with Monads
13:37:26 <ksf> you might be witnessing 6.12 awkwardness
13:37:37 <Dashkal> shapr: I'm not yet comfortable enough with this process to teach others, though that's a damn good idea
13:37:54 <ksf> nschoe, if I would now explain it, I wouldn't be following my own advice...
13:37:55 <jmcarthur> nschoe: ksf means you must unlearn what you have learned
13:38:02 <Dashkal> It'll be worth it, I've seen some yummy things in the .12 libs
13:38:02 <nschoe> Well, anyway thank you all for your information ^^
13:38:08 <ksf> no, I did't say that
13:38:13 <Dashkal> I want System.IO.utf8
13:38:14 <ksf> I mean it too, though.
13:38:19 <tensorpudding> it's helpful to consider the monads [] and Maybe first, as they're relatively simple
13:38:20 <benmachine> nschoe: I think the main idea is, don't worry about it
13:38:29 <nschoe> jmcarthur : Okay ... that' weird, isn't it ?
13:38:32 <benmachine> everything is going to be fine
13:38:48 <nschoe> benmachine : okay :-)
13:39:13 <shapr> Saizan: So, you remember I installed all of hackage with a shellscript? My room is heating up as ghc tells me how many packages would be broken if I unregistered unix-2.4.0.0
13:39:14 <Cale> Wait, unlearn traditional programming. You don't need to unlearn what you know about IO of course :)
13:39:22 <jmcarthur> nschoe: hard to teach somebody that something when they already believe something else about it
13:39:30 <jmcarthur> *somebody something
13:39:37 <tensorpudding> IO follows the same rules even though it's very opaque how it actually works inside
13:39:41 <medfly> "traditional programming"
13:39:42 <Cale> and even then, knowledge from traditional imperative programming will sometimes be useful later on
13:39:46 <nschoe> Cale, by 'traditional programming' do you mean the programming we 'make' when we code in C for instance ?
13:39:51 <Cale> nschoe: yeah
13:39:56 <shapr> This could take a very long time...
13:40:11 <medfly> Cale, you must undergo some mental purification before you learn Haskell
13:40:21 <nschoe> Lol
13:40:23 <mreh> Haskell is also a tranditional programming language
13:40:35 <Dark_Shikari> since when is C more traditional than lisp?
13:40:38 <Dark_Shikari> lisp came first.
13:40:41 <nschoe> Yeah but it's a very different approach.
13:40:59 <mreh> you can program the same way you write C code in Haskell
13:41:02 <tensorpudding> they are both traditions in different domains
13:41:17 <nschoe> Dark_Shikari : I think he meant that as more people code in C, 'traditional' refers to C.
13:41:36 <Dark_Shikari> nschoe: well by that metric, Java is now traditional ;)  sadly enough
13:41:43 <Saizan> shapr: haha, that's probably the worst scenario ghc-pkg has been subjected to :D
13:41:53 <nschoe> Dark_Shikari : Yeah, as you say : sadly enough...
13:41:59 <medfly> mreh, where's mah for loop?
13:42:13 <benmachine> :t forM
13:42:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:42:16 <benmachine> it is there.
13:42:26 <shapr> Saizan: Now I'm trying "for x in (very long list); do ghc-pkg unregister $x; done;"
13:42:28 <medfly> can I i=0; i < something; ++i that??
13:42:44 <shapr> But wait! I can't unregister some of these packages because that would break other packages!
13:42:46 <Saizan> shapr: you can just use --force
13:42:46 * shapr cries
13:43:01 <shapr> Saizan: Will I still be able to correctly build ghc 6.12 after I do that?
13:43:14 <tensorpudding> > forM [1..10] (putStrLn . show)
13:43:15 <lambdabot>   <IO [()]>
13:43:26 <Saizan> shapr: ghc-pkg will ignore the broken packages
13:43:30 <Zao> How's that different from flip mapM?
13:43:30 <lispy> ?src print
13:43:30 <lambdabot> print x = putStrLn (show x)
13:43:36 <jmcarthur> Zao: it's not
13:43:38 <tensorpudding> Zao: it is defined as flip mapM
13:43:39 <benmachine> @src forM
13:43:39 <lambdabot> forM = flip mapM
13:43:54 <lispy> > forM [1..10] print
13:43:55 <Zao> Heh.
13:43:55 <lambdabot>   <IO [()]>
13:43:55 <medfly> @src flip
13:43:55 <lambdabot> flip f x y = f y x
13:43:57 <medfly> if we're already at it
13:44:02 <shapr> Man, ghc-pkg is SLOW.
13:44:15 <lispy> shapr: you need .12!
13:44:19 <Saizan> on 6.12 it should be faster
13:44:22 <tensorpudding> > forM [1..10] (return :: a -> [a])
13:44:23 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
13:44:29 <medfly> how do you generalise something for a variable number of arguments in Haskell >.<
13:44:36 <shapr> lispy: There's a hole in the bucket.
13:44:46 <levente_meszaros> anyone knows of a simple but non trivial algorithm where parallel lazy evaluation is a big win?
13:44:48 <benmachine> medfly: there are several ways and most of them are magic
13:44:52 <levente_meszaros> in terms of implementation simplicity and ease of understanding
13:44:54 <lispy> medfly: simulate dependent types
13:45:01 <shapr> levente_meszaros: same fringe
13:45:11 <benmachine> not magic
13:45:16 <benmachine> but
13:45:20 <levente_meszaros> I'm looking for a pseudo code rather than an implementation
13:45:20 <tensorpudding> > forM [1..10] (return :: a -> Maybe a)
13:45:21 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
13:45:24 <benmachine> ingenious
13:45:27 <ksf> the most fun is type families
13:45:29 <benmachine> using typeclasses
13:45:41 <benmachine> medfly: look for printf
13:45:57 <medfly> what should I look at
13:45:59 <benmachine> it has a return type that is polymorphic, so that it can be instantiated as a function
13:45:59 <medfly> @src printf
13:46:00 <lambdabot> Source not found. Do you think like you type?
13:46:03 <Dashkal> Seems the .12 awkwardness continues.  bootstrap.sh won't see the installed parsec.  manual install of the rest of the deps here we come
13:46:04 <levente_meszaros> shapr, seems like a good candidate
13:46:05 <levente_meszaros> thanks
13:46:09 <mreh> @src mapM
13:46:09 <lambdabot> mapM f as = sequence (map f as)
13:46:10 <lispy> there is also a functional pearl that uses zip functions and type level numerals
13:46:13 <mreh> oooh
13:46:17 <shapr> levente_meszaros: My favorite use of lazy evaluation is if statements, otherwise all branches would be executed :-)
13:46:26 <medfly> how do you make something like tat then
13:47:20 <Saizan> medfly: see the source of Text.Printf
13:47:29 <medfly> how do I do that
13:47:32 <shapr> Even more entertaining, purely strict code that evaluates all branches is more efficient on big throughput machines like the Itanium. Otherwise cache gets flushed and deterministic performance is lost.
13:47:34 <jmcarthur> in this AI contest i "solve" the game and put the whole thing in a big game tree, but i only lazily evaluate it
13:47:34 <mreh> lol
13:47:43 <shapr> levente_meszaros: Just curious, what are you doing?
13:47:45 <levente_meszaros> shapr, heh... I'm experimenting with a lisp library providing lazy evaluation where one can have control over when to delay and when not to
13:48:06 <levente_meszaros> I though this channel is a good place to ask
13:48:12 <jmcarthur> levente_meszaros: you mean like with an explicit thunk?
13:48:17 <levente_meszaros> because a lot of lazy people are here ;-)
13:48:20 <shapr> haha
13:48:23 <jmcarthur> and then you force it later?
13:48:23 <medfly> indeed
13:48:29 <shapr> I like to call myself 'non-strict' !
13:48:47 <monochrom> I am pure.
13:48:47 <osaunders> What does := mean?
13:48:57 <shapr> levente_meszaros: Are you going lazy-by-default or strict-by-default?
13:49:01 <levente_meszaros> jmcarthur, implicitly by walking the code and transforming it
13:49:03 <monochrom> I am functional too.
13:49:04 <Berengal> osaunders: Usually assignment
13:49:14 <jmcarthur> levente_meszaros: ah you crazy lisper
13:49:16 <levente_meszaros> e.g. a function definition defines an eager and lazy version too
13:49:17 <Berengal> osaunders: Probably in the imperative sense
13:49:27 <shapr> I believe edwardk's kata language defaulted to whatever this particular chunk of code was using most recently, which I found immensely nifty.
13:49:35 <osaunders> Berengal: Ok, what does this mean then: forall a . (Option m a) := a ?
13:49:37 <Cale> levente_meszaros: A good way to tell when lazy or strict evaluation is important is by comparing the "sizes" of the input and output to some process. By sizes, I don't necessarily mean the actual size in memory, but the number of parts to the data which could conceivably be separately evaluated.
13:49:37 <levente_meszaros> shapr, you can simply change that globally or lexically locally
13:50:05 <Berengal> osaunders: That's just a type. := is a type-constructor operator
13:50:12 <Cale> levente_meszaros: There are roughly 4 possibilities, corresponding to small -> small, small -> large, large -> small, and large -> large.
13:50:34 <shapr> levente_meszaros: There is some code that won't complete if strict/lazy, how will you deal with that?
13:50:38 <osaunders> Berengal: Declaring := as the type constructor?
13:50:38 <medfly> Cale thinks in Haskell
13:50:42 <Berengal> osaunders: Yep
13:50:50 <osaunders> Ah, OK
13:50:56 <Cale> In the small -> small case, strict and lazy are nearly equivalent.
13:51:25 <Cale> In the small -> large case, lazy is better, since the entire result might not end up being needed
13:51:33 <osaunders> @hoogle forall
13:51:34 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
13:51:34 <lambdabot> Language.Haskell.TH ForallC :: [Name] -> Cxt -> Con -> Con
13:51:34 <lambdabot> Language.Haskell.TH.Syntax ForallC :: [Name] -> Cxt -> Con -> Con
13:51:37 <Cale> (and computing it eagerly would be a waste)
13:51:42 <levente_meszaros> Cale, interesting view
13:52:22 * monochrom resolves to not worry about -O vs -O2. Probably a waste of electricity to insist on -O2 for most purposes. Exceptions can be treated individually.
13:52:25 <levente_meszaros> shapr, when I go from lazy to strict I need to force the values recursively, so one must be careful doing that
13:52:41 <Cale> In the large -> small case, there are two possibilities. If you're searching through the large structure to find something of interest, then lazy is fine, but if you're summarising the large structure in such a way that the result depends on every part, this is where strictness is important.
13:52:48 <levente_meszaros> but I have (with-lazy-eval (take (primes) 10)) with the usual infinite lists, pretty simple
13:53:01 <shapr> Cale: That sounds like a general description of edwardk's morphism writings.
13:53:03 <levente_meszaros> without the with-lazy-eval it's going to fail
13:53:24 <osaunders> What does . mean in a data declaration?
13:53:33 <osaunders> Or maybe I should just RTFM at this point.
13:53:35 <byorgey> osaunders: can you give an example?
13:53:38 <Cale> In the large -> large case, you usually want lazy evaluation, especially if you can do things in a stream-processing fashion, but also because the entire result may not be needed.
13:53:47 <osaunders> byorgey: data OptionVal m = forall a . (Option m a) := a
13:53:55 <levente_meszaros> shapr, does that answer your question?
13:54:03 <benmachine> osaunders: it means, we've finished foralling
13:54:06 <Cale> However, you might write some of those as large -> small composed with small -> large, in which case the first part might need to be strict
13:54:09 <byorgey> osaunders: oh, that is just part of the syntax of the forall quantifier
13:54:12 <shapr> levente_meszaros: I think so :-)
13:54:16 <medfly> Cale, if it's the output then why won't ti all be needed, you don't output so much stuff you don't need
13:54:19 <levente_meszaros> here is the code btw: http://dwim.hu/file/hu.dwim.lazy-eval/test/prime.lisp   noting new
13:54:23 <monochrom> That also answers what is ":=", doesn't it?
13:54:35 <Cale> medfly: Because the output of one thing is the input to something else.
13:54:35 <shapr> levente_meszaros: Nifty project by the way. Doing it purely for fun?
13:54:38 <monochrom> You should always give more context.
13:54:57 <Cale> medfly: and it's better to leave that something else to decide what parts of its input that need to be computed.
13:55:12 <osaunders> monochrom: No, not really. I'm confused how that line declares :=.
13:55:29 <Cale> For example, a good example of a small -> large function is one which takes a chess board and produces the entire game tree from that point forward.
13:55:33 <Cale> (all possible moves)
13:55:47 <byorgey> osaunders: it would be similar to  data OptionVal m = forall a. Assign (Option m a) a
13:55:55 <monochrom> You know data constructors right? Like "data X a b = Me a b", Me is a constructor.
13:55:55 <Cale> Obviously, it's ridiculous to compute them *all* since there are in all likelihood infinitely many.
13:56:03 <byorgey> except that instead of naming the constructor Assign, we have named it := and made it infix
13:56:07 <Berengal> osaunders: It's the same as "data OptionVal m = forall a. Foo (Option m a) a", except with (:=) instead of Foo
13:56:13 <Cale> (unless you use strange rules of chess, and even then, there are so many that it's ridiculous)
13:56:29 <Cale> So you want the thing which is going to be searching through that tree of moves to decide how much it needs.
13:56:49 <Cale> and the easiest way to do that is just to be lazy about constructing it
13:56:53 <monochrom> Next is, you can have constructors in infix notation too, but it is no longer alphanumeric. Example is complex numbers, "data Complex a = a :+ a".  :+ is the constructor.
13:56:55 <osaunders> Berengal: byorgey: Right, OK.
13:57:14 <Dashkal> Yes!  Cabal installed.  I'll see about writing the method I used down tonight when I have to do this all over on my second machine
13:57:20 <benmachine> there's silly bolt-on rules that prevent chess being infinite aren't there
13:57:23 <monochrom> General rule: colon followed by moar punctuations. :+ is one example, := is another.
13:58:04 <Cale> MOAR PUNCTUATIONS!!!$%?#$@&^#!~.;
13:58:07 <benmachine> colons on constructors are like capital letters
13:58:14 <benmachine> on names
13:58:15 <sinelaw> ZOMG I LOVE HAXELL
13:58:23 <lispy> Cale: Don't make me ban you! ;)
13:58:34 <levente_meszaros> Cale, yeah I have read some books about that, I just wanted to have something simple which doesn't take years to implement :)
13:58:42 <BONUS> preflex: seen mmorrow
13:58:43 <preflex>  mmorrow was last seen on #ghc 30 days, 19 hours and 58 seconds ago, saying: * mmorrow is rtfm'ing
13:58:46 <BONUS> :(
13:58:57 * lispy notes he no longer has ops in #haskell and is happy :)
13:59:02 <BONUS> anyone know what happened to mmorrow
13:59:16 <lispy> to mmorrow?
13:59:21 <Cale> levente_meszaros: Well, the difference between the evaluation mechanisms is mostly just the order in which you evaluate expressions.
13:59:21 <benmachine> hee hee
13:59:30 <benmachine> I'm sure I've seen him more recently than that
13:59:34 <nus> levente_meszaros, supposedly what I'm reading now roughly translates as "turn on your javascript" in .hu'ish?
13:59:41 <sportplusbr> www.pt-br.justin.tv/sportplusbr [00:00] NBA: DALLAS MAVERICKS X PHOENIX SUNS
13:59:43 <BONUS> benmachine: where?
13:59:58 <Berengal> Cale: Also, when to stop
14:00:07 <benmachine> BONUS: here, I think?
14:00:09 <benmachine> let me check my logs
14:00:27 <levente_meszaros> nus, yes, sorry, that site is not going to work without js
14:00:30 <Berengal> Although I guess that falls out of the order naturally
14:00:40 <levente_meszaros> I promise that it doesn't do anything nasty
14:00:50 <benmachine> noo my logs are not helpful
14:00:55 <levente_meszaros> except it's going to produce some heat :)
14:00:55 <BONUS> noooo
14:00:57 <Cale> levente_meszaros: Strict evaluation is innermost first. You can also do simple outermost-first evaluation, where you evaluate the function and then plug the parameters into the body of the function without first evaluating them. However this often leads to wasted work when a parameter to a function occurs more than once in the body.
14:01:37 <Cale> So lazy evaluation is outermost-first evaluation, but with an additional proviso that whenever the parameter to a function occurs more than once in the body of the function, evaluation is shared between the copies of the parameter.
14:01:52 <Cale> This is often accomplished by using expression graphs rather than expression trees.
14:02:00 <levente_meszaros> Cale, I also have a partial evaluator for CL (incomplete) but can partially evaluate CLOS object construction with all the meta object protocol down to a code that is equivalent with the carefully hand optimized version
14:02:22 <Cale> So you can just have the various places where the parameter occurs point to the value of the parameter, and when it gets evaluated, they all see the change.
14:02:57 <byorgey> twanvl: around?
14:03:55 <Spockz|lap> If I install ghc 6.10.4 from the source on the website it does include haddock 2.x right?
14:03:59 <Cale> If one wanted to do it by staying at the level of syntax, introducing a 'let/in' is a good way to represent the sharing.
14:04:17 <byorgey> @ask twanvl wondering if there is a repo for Data.MultiSet anywhere
14:04:17 <lambdabot> Consider it noted.
14:04:21 <Cale> My favourite example to use when comparing evaluation mechanisms is to suppose we have the function  double x = x + x
14:04:31 <levente_meszaros> btw, what strategies are there when deciding which calls to delay and which calls not to delay?
14:04:45 <Cale> levente_meszaros: You mean, automatically?
14:04:47 <levente_meszaros> I did a pretty simple which decides based on the level of the stack frames
14:04:53 <levente_meszaros> Cale, yes
14:05:16 <Cale> It's theoretically hard, but there are some heuristics that get used in practice.
14:05:41 <Cale> I think what GHC does is to take note of when functions are strict/non-strict
14:05:45 <Cale> and in which parameters
14:05:52 <levente_meszaros> the one I did is pretty easy not that I know what the exact consequences are in general...
14:06:03 <Cale> A function is strict if it always observes its parameter.
14:06:32 <levente_meszaros> can you annotate that on the function parameter or function definition?
14:06:53 <nus> levente_meszaros, what you call a 'call'? functional application?
14:06:58 <Cale> Well, it's something which shows up in the core language as part of the function definition, I think.
14:07:11 <levente_meszaros> nus, yes
14:07:32 <Cale> It's not something you can explicitly annotate in Haskell code, though you can arrange for a function to be strict in Haskell easily enough.
14:07:51 <levente_meszaros> or can you apply a function both lazily and eagerly?
14:07:56 <Cale> I wonder if there's a paper about GHC's strictness analyser.
14:08:38 <hzap> you can apply eagerly in haskell with stuff like ($!)
14:09:06 <Cale> Well, if a function is definitely always going to demand the evaluation of its parameter (because it pattern matches on it), then there's no point in delaying the evaluation of that parameter, if you have a choice.
14:09:17 <levente_meszaros> hzap, and can you do that recursively?
14:09:43 <Cale> But of course, if the evaluation was already delayed somewhere else, you have to force it.
14:09:59 <nus> Cale, System F is lazy, no?
14:10:00 <hzap> levente_meszaros: i don't think so, unless there's some weird hackery
14:10:12 <levente_meszaros> I mean does it affect only that application? or can you specify to affect all applications dynamically when a particular application happens?
14:10:16 <levente_meszaros> oh, I see
14:10:31 <silver> weee, I've bootstrapped cabal-install in ubuntu \o/
14:10:36 <Cale> nus: System F doesn't enforce an evaluation order.
14:11:39 <Saizan> in System F, every evaluation order gives the same result
14:11:42 <Cale> levente_meszaros: f $! x = x `seq` f x, where x `seq` y is an expression that, when evaluated, ensures that x is evaluated before the result of evaluating y is made available.
14:11:59 <Cale> (and evaluates to what y would, so long as the evaluation of x terminates)
14:12:21 <Cale> seq is the primitive by which we normally introduce strictness
14:12:29 <c_wraith> very precise wording there, Cale. might as well mention pseq if you're going to be that precise.
14:12:39 <Cale> I was about to mention it actually :)
14:13:19 <PepeSilvia> hi, does anyone know what the preferred way to go is when installing 6.10 on debian? I can only find 6.6, 6.8 and 6.12 in the repos.
14:13:29 <Cale> x `pseq` y is similar, but ensures that x is really evaluated before y.
14:13:59 <Cale> It's technically valid for x `seq` y to evaluate y first, then x, and then return the result from evaluating y.
14:14:08 <Cale> But not for pseq to do that.
14:14:28 <Cale> PepeSilvia: Install the generic linux binary from the GHC website.
14:14:52 <Cale> PepeSilvia: Then get the cabal-install package from Hackage, and run the bootstrap script inside it.
14:15:26 <Cale> I don't trust debian or ubuntu's packages for GHC.
14:16:00 <PepeSilvia> Cale: we have tried to install from www.haskell.org/ghc , but now haddock is acting very strange
14:16:17 <PepeSilvia> saying: haddock: internal error: evacuate(static): strange closure type 0
14:16:32 <levente_meszaros> is this the same fringe example that was mentioned: http://www.nsl.com/papers/samefringe.htm
14:17:05 <Cale> PepeSilvia: uh, weird... do you have temporary files hanging around from a different version of GHC?
14:17:12 <Cale> (like .o or .hi files)
14:17:20 <PepeSilvia> let me check :)
14:18:34 <chekkal> I've written an article about Memoization in Haskell: "http://chekkal.blogspot.com/2010/02/memoization-in-haskell.html" , your opinions are welcome
14:18:56 <Cale> levente_meszaros: A nice thing about lazy evaluation when working out that problem is that comparing the flattened trees will use constant space (at least if the garbage collector does its job)
14:19:42 <Cale> chekkal: Check out Data.MemoCombinators
14:20:07 <Cale> chekkal: also, something is squishing all your code onto one line and destroying the formatting...
14:20:26 <Cale> oh, I guess that's all just from ghci, don't mind me then :)
14:20:29 <PepeSilvia> Cale: we used to have an older versino of ghc around, but never used it as far as I can tell. The error still persists after `cabal clean`
14:20:37 <Cale> PepeSilvia: hmm...
14:21:08 <Cale> PepeSilvia: It's conceivable that you're triggering some GHC bug, but I haven't run into this problem...
14:21:21 <Cale> PepeSilvia: You installed the generic linux GHC 6.10.4, yeah?
14:21:32 <Spockz|lap> Cale: yes we did
14:21:34 <PepeSilvia> yes and ghc works correctly
14:21:38 <Cale> and what is triggering the error?
14:21:44 <Cale> cabal install haddock?
14:21:46 <PepeSilvia> cabal --executable haddock
14:21:57 <jlouis> What is the best course of action for haskell torrent and its modules. Currently almost everything is in a flat module space. Should I use a hierachial one instead?
14:22:26 <levente_meszaros> Cale, and is there a solution that also uses all my cores?
14:22:43 <ksf> go hierachical
14:22:51 <ksf> ...when it makes sense, that is.
14:23:04 <Cale> levente_meszaros: For that, in Haskell, you might use par
14:23:20 <jlouis> ksf: I am leaning towards that idea as well
14:23:40 <Cale> par x y is an expression which evaluates to y, but adds x to a queue of values which it might be fruitful to evaluate early, if there's time available on some core
14:23:46 <chekkal> Cale, thanks for Data.MemoCombinators, I'll check that
14:23:46 <levente_meszaros> Cale, I plan to add something similar to my lazy library
14:24:15 <levente_meszaros> using a fixed number of workers, job queues and condition variables
14:24:17 <Cale> However, I'm not sure how easy it is to parallelise this fringe matching problem.
14:24:31 <levente_meszaros> I don't exactly know how... yet
14:24:38 <Botje> > read "((((((((((((((((1))))))))))))))))"
14:24:39 <lambdabot>   * Exception: Prelude.read: no parse
14:24:45 <Botje> > read "((((((((((((((((1))))))))))))))))))))"
14:24:46 <lambdabot>   * Exception: Prelude.read: no parse
14:24:49 <Botje> bleh
14:24:57 <monochrom> Give it a type.
14:25:03 <Cale> levente_meszaros: The nice thing about this par primitive is that it doesn't change the meaning of a piece of code to use it, only potentially the performance.
14:25:10 <lispy> > read "()"
14:25:10 <ksf> jlouis, just pay attention not to introduce long paths, e.g. don't do HaskellTorrent/Net/Foo/Bar, but Net/Foo/Bar
14:25:11 <lambdabot>   ()
14:25:32 <xerox> .oO(which type?)
14:25:36 <levente_meszaros> Cale, I plan to do the same, I think it isn't that hard after all
14:25:38 <Cale> levente_meszaros: Of course, that guarantee relies on evaluation having no effects :)
14:25:40 <jlouis> ksf: Yes, so noted
14:25:42 <ksf> ...two levels should be plenty for about everything.
14:25:45 <byorgey> @tell twanvl sorry, never mind, I realized that for my application it's quite important that I don't impose an Ord constraint, so map-based multisets are out.  good old assoc lists should be fine.
14:25:46 <lambdabot> Consider it noted.
14:26:00 <lispy> hey byorgey
14:26:07 <byorgey> hey there lispy
14:26:16 <lispy> byorgey: do you work on GF?
14:26:16 <monochrom> > read "((1))" :: Double
14:26:17 <lambdabot>   1.0
14:26:25 <byorgey> lispy: what's GF?
14:26:34 <lispy> byorgey: oh, maybe I have the wrong person
14:26:35 <PepeSilvia> Cale: would this be sufficient for a bug report? http://pastie.org/829790
14:26:36 <monochrom> Grammatical Framework?
14:26:38 <byorgey> I guess that means the answer is 'no' =)
14:26:39 <lispy> byorgey: grammatical framework
14:26:47 <levente_meszaros> Cale, well I usually do test driven development instead of relying on the non-existent polymorphic type system of CL
14:26:51 <Cale> levente_meszaros: It can also be somewhat tricky to figure out what the best way to annotate the code with par is, as if you create too many tasks, the scheduler overhead grows.
14:26:52 <byorgey> oh, you must be thinking of someone else
14:26:56 <byorgey> I've heard of it though
14:27:06 <jlouis> ksf: and for the hierachy, I guess I should just look at what other libraries and programs use I guess
14:27:06 <lispy> byorgey: oh okay.
14:27:18 <monochrom> GF could also be the composition of a pair of functors in adjunction :)
14:27:27 <xerox> > (length "((((((((((((((((", length "))))))))))))))))))))")
14:27:28 <byorgey> oh, I work on those sometimes =)
14:27:28 <lambdabot>   (16,20)
14:27:30 <levente_meszaros> Cale, that's clear I would leave it for the programmer, and would probably decide dynamically rather than statically
14:27:32 <xerox> okay :)
14:27:36 <Cale> PepeSilvia: Oh, and you have reinstalled haddock since you updated GHC?
14:29:22 <nus> levente_meszaros, "non-existent polymorphic type system in CL"? what exactly you want? Qi? or haskell in cl?
14:29:38 <lispy> byorgey: oh, Bjorn Bringert, heh.  Your names aren't even similar.  I have a terrible memory.
14:29:55 <byorgey> ...they both start with B?
14:29:59 <lispy> yeah :(
14:30:13 <byorgey> no worries =)
14:30:19 <PepeSilvia> Cale: we were using the haddock that came with the package. I'm trying a `cabal install haddock-2.4.2` now
14:30:32 <levente_meszaros> nus, Qi is nice, actually I met Mark face to face before he left to India
14:31:10 <ivanm> preflex: seen Axman6
14:31:10 <preflex>  Axman6 was last seen on #haskell 10 hours, 16 minutes and 14 seconds ago, saying: > reduce (x - x)
14:31:29 <ksf> jlouis, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphmod
14:31:31 <nus> levente_meszaros, I hope he'll find some peace of soul, eventually.
14:32:01 <dolio> monochrom: All the cool kids use U for 'underlying' not G. :)
14:32:16 <jlouis> ksf: ah, neat!
14:32:17 <levente_meszaros> AFAICT he is back and working on Qi again
14:32:22 <jlouis> ksf: thanks!
14:32:25 <PepeSilvia> Cale: ah that almost fixed it! :) but now cabal keeps using the old haddock and not the one in ~/.cabal/bin/ ...
14:32:43 <Cale> PepeSilvia: hmm...
14:32:49 <monochrom> haha
14:33:19 <Saizan> PepeSilvia: do you have ~/.cabal/bin in the $PATH ?
14:33:31 <PepeSilvia> yes
14:34:00 <ksf> hmmm. I think some cleanup might be a good idea before you move stuff
14:34:05 <ksf> there's arrows all over the place
14:34:12 <nus> levente_meszaros, oh, nice.
14:34:24 <shapr> Saizan: Runtime of that ghc-pkg unregister loop, 33 minutes.
14:35:02 <Saizan> shapr: ah, i thought you just used ghc-pkg unregister unix-2.4 --force in the end
14:35:15 <shapr> I've decided to do so.
14:35:16 <jlouis> ksf: I think I can do that :) Thanks
14:37:58 <ksf> I think the longest path is Main -> TrackerP -> PeerMgrP -> ChokeMgrP -> PeerP > PieceMgrP -> FSP -> FS -> [Torrent|Bcode] -> Digest
14:38:08 <Blkt> does anyone of you use emacs and haskell mode?
14:38:16 <nus> sure
14:38:19 <nschoe> Blkt I do
14:38:34 <Blkt> how did u modify your .emacs file to install it?
14:38:46 <PepeSilvia> Cale: hm I fixed the PATH issue (used ~ instead of the full home path) as well and it seems to be working now :) thanks a lot!
14:38:57 <nus> Blkt, what platform are you on?
14:39:03 <Blkt> Windows
14:39:06 <Blkt> 7
14:39:07 <Cale> PepeSilvia: no problem
14:40:35 <Blkt> nus: nschoe: I followed the readme instructions but it gives me problems with (load "bla/bla/haskell-site-file")
14:40:56 <Blkt> I'm using emacs23.1 too
14:41:10 <nus> Blkt, http://github.com/alexott/emacs-configs
14:41:10 * hackagebot upload: HDBC-sqlite3 2.3.0.0 - Sqlite v3 driver for HDBC (JohnGoerzen)
14:41:20 <nus> Blkt, poke around, get a feeling...
14:41:27 <Blkt> nus: thanks
14:41:34 <nus> Blkt, there's also the emacs wiki.
14:42:04 <nus> Blkt, my rehashing it wouldn't differ much.
14:42:28 <nschoe> Blkt : can you show us your .emacs ?
14:42:36 <nus> heh
14:42:52 <nus> mine is longer :-) :-P
14:42:56 <levente_meszaros> btw, what's the correct word for the opposite of lazy, eager or strict?
14:43:02 <jlouis> ksf: really helpful ideas, I'll look into it
14:43:17 <Blkt> nschoe: may I just paste the haskell part or the whole file? (don't have it uploaded anywhere)
14:43:26 <Saizan> levente_meszaros: eager
14:43:35 <monochrom> lazy's correct opposite is eager. nonstrict's correct opposite is strict.
14:43:44 <monochrom> I mean, like, clearly.
14:43:54 <Blkt> /msg nschoe (load "C:/User/Blackout/Documents/Apps/haskell-mode-2.7.0/haskell-site-file.el")
14:43:54 <Blkt> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
14:43:54 <Blkt> (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
14:43:54 <Blkt> (setq haskell-program-name "C:/ghc/ghc-6.12.1/bin/ghci.exe")
14:44:00 <Blkt> I think I failed...
14:44:07 <Cale> Though, some people use 'strict' to refer to an evaluation mechanism as well, as it's not particularly ambiguous.
14:44:24 <Saizan> strict is also used as a property of functions: a function f is strict if f _|_ = _|_
14:44:31 <nschoe> Blkt you miss the (load /path/to/your/haskell-site-file)
14:44:45 <Blkt> I did /msg it to you
14:44:53 <Blkt> (load "C:/User/Blackout/Documents/Apps/haskell-mode-2.7.0/haskell-site-file.el")
14:45:18 <nschoe> Blkt try to delete ".el" at the end of the line.
14:45:32 <Blkt> I did on first place, didn't work either
14:45:45 <Blkt> anyway that's the failing line
14:45:45 <watermind> is there some reference for simple (parametric first order)  polymorphic type systems?
14:46:02 <Blkt> nschoe: is there a way to reload .emacs file without killing emacs?
14:46:15 <MissPiggy> watermind, 3 things come to mind
14:46:40 <Blkt> nschoe: http://github.com/alexott/emacs-configs/blob/master/rc/emacs-rc-haskell.el#L13
14:46:49 <watermind> first order polymorphic type system are quite simple, but wanted to see how to deal with "rigid type variables"
14:46:56 <nschoe> Blkt I think so, but I don't remember how. I'm used to kill it and relaunch.
14:47:09 <watermind> MissPiggy: please shoot :)
14:47:18 <watermind> MissPiggy: available online please :S
14:47:25 <lament> please don't shoot!!
14:47:28 <watermind> MissPiggy: away from library right now
14:47:29 <nschoe> Blkt, not sure the "~" means anything under Windows. Try full path
14:47:29 <Blkt> nschoe: nvm I'll just kill
14:47:33 <lament> guns kill people!
14:48:34 <MissPiggy> http://groups.csail.mit.edu/pag/6.883/readings/p207-damas.pdf
14:48:54 <nus> Blkt, eval-buffer
14:48:58 <MissPiggy> watermind, INST for example
14:49:09 <MissPiggy> on page 3
14:49:33 <watermind> my difficulty when defining them has to do with the fact that you cannot do this instantiation:  g (f::a->a->a) (x::a) = (f x :: Int->Int)
14:49:47 <watermind> and of course it makes sense that we cannot do it
14:50:28 <watermind> but when writting the type system in a naive way we'd get  f x :: a->a   which would be a polymorphic function and therefore instantiable
14:50:42 <MissPiggy> watermind, INST disagrees
14:50:48 <watermind> thank you MissPiggy, checking it out
14:51:09 <watermind> MissPiggy: disagres that it should be instantiable right?
14:51:16 <Cprog> Hi
14:51:18 <Cprog> anyone here?
14:51:29 <nschoe> Hi back Blkt, have ya tried the full path ?
14:51:30 <Blkt> nschoe: I'm a noob, I was missing an "s" on "C:/Users"
14:51:37 <monochrom> haha
14:51:37 <ivanm> Cprog: nope, no-one here
14:51:43 <Cprog> ivanm :\ cut the jokes plz
14:51:45 <aledge> noob errors are the worst
14:51:47 <Cprog> i need help in C :P
14:51:51 <Cprog> can someone help me out?
14:51:52 <Blkt> nschoe: too much Possion distribution today, pardon me :D
14:51:53 <ivanm> Cprog: then go to ##c
14:51:54 <MissPiggy> Cprog, nobody here knows what C is
14:51:57 <nschoe> Blkt don't wry, it happens to everyone. Windows is kinda tricky fro this ^^
14:52:02 <medfly> Cprog, just ask :P
14:52:03 <ivanm> MissPiggy: sure we do, it's that thing we won't touch
14:52:05 <nschoe> for*
14:52:10 <monochrom> Clearly, C is a category.
14:52:16 <medfly> Cprog, this channel does help with C.
14:52:20 <ivanm> nschoe: yeah, no tab-completion... >_>
14:52:25 <Cprog> ohh
14:52:27 <ivanm> medfly: by leading you away from it?
14:52:28 <Cprog> Anyway guys
14:52:33 <medfly> hehehe
14:52:35 <MissPiggy> C(m) is the monoid category
14:52:36 <nschoe> Blkt if I may give you an adivce, don't use haskell-indentation but haskell-indent instead.
14:52:40 <MissPiggy> isn't it?
14:52:40 <medfly> ivanm, no, I've gotten C help here!
14:52:41 <medfly> :D
14:52:46 <ivanm> heh
14:52:46 <Cprog> Do you know how i can print a 7x7 matriz with the values 1 to 49?
14:52:50 <MissPiggy> for some monoid m
14:52:56 <nschoe> ivanm yeah Tab-completion has become my best friend on nux  ^^
14:53:01 <Blkt> nschoe: thanks for the advice, what's the difference anyway?
14:53:05 <Botje> Cprog: you want the ##c channel, down the hall
14:53:09 <ivanm> Cprog: yes, but not in C
14:53:16 <aledge> Cprog, is that homework? and you either want ##c or stackoverflow.com
14:53:21 <Botje> while most people here would know, this is not the appropriate channel.
14:53:37 <aledge> ivanm, you seriously don't know how to do that in c?
14:53:40 <Botje> in fact, this channel is dedicated to wiping languages such as C off the face of the earth
14:53:46 <medfly> I don't. is matrix like a datastructure?
14:53:47 <sinelaw> how hard will it be to create bindings for something like opencv?
14:53:54 <Blkt> ivanm: there's tab-completion on emacs23.1 on windows at least
14:53:56 <monochrom> > int 4
14:53:57 <lambdabot>   4
14:53:58 <nschoe> Blkt I sure don't know all the differences, but for instance, with 'haskell-indent', when you define a functions over multiple equations, just press TAB and it will write the beginning of the equation for you
14:54:05 <ben> :t int
14:54:06 <lambdabot> Int -> Doc
14:54:07 <ivanm> aledge: I did one course that did assembly and C for microcontrollers; I've successfully avoided C since!
14:54:17 <medfly> C doesn't seem so bad
14:54:25 <medfly> what do you guys have against it
14:54:25 <ivanm> medfly: I think he means a 2D array
14:54:26 <aledge> medfly, it isn't, if youre a systems programmer
14:54:32 <lament> C is delicious
14:54:35 <lament> just don't program in it
14:54:35 <ivanm> (for a "matrix")
14:54:43 <jmcarthur> "dnolen@NYUFGA-WLESSAUTHCLIENTS-01.NATPOOL.NYU.EDU" ... wow that's obnoxious
14:54:50 <ivanm> jmcarthur: from?
14:54:56 <Cprog> yeah :P
14:54:58 <Cprog> a 2D array
14:55:04 <jmcarthur> ivanm: from when dnolen parted just now
14:55:10 <ddarius> This channel still isn't ##c.
14:55:10 <medfly> Cprog, a 2D array is just a 1D array. problem solved.
14:55:19 <ivanm> oh? must be your client
14:55:24 <ivanm> mine doesn't say anything like that
14:55:31 <jmcarthur> ivanm: no most people show lowercase
14:55:33 <ivanm> ddarius: it isn't?
14:55:36 * ivanm looks around
14:55:37 <monochrom> > [ [n..n+2] | n<-[1,4..9] ]
14:55:38 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
14:55:50 <ivanm> jmcarthur: when he quit, I just got "* dnolen has quit (Quit: dnolen)"
14:55:57 <medfly> [1,4..9]? ;)
14:55:58 <ivanm> monochrom: heh
14:55:59 <jmcarthur> ivanm: mine shows their domain and stuff
14:56:01 <ivanm> now print that nicely
14:56:04 <ivanm> jmcarthur: aha
14:56:11 <jmcarthur> the thing i was saying was obnoxious was that his was all caps
14:56:20 <medfly> Cprog, insert a newline every 7 elements if you'd like :)
14:56:28 <watermind> MissPiggy: I don't see how INST alones prevents that instantiation I showed
14:56:46 <ivanm> medfly: a list starting with 1, then 4, and then goes up in increments of (4 - 1 == 3) until it gets to >= 9
14:56:51 <ivanm> > [1,4..9]
14:56:51 <lambdabot>   [1,4,7]
14:56:57 <medfly> o.O okay
14:57:06 <medfly> I ... read that wrong.
14:57:14 <medfly> thinking you did [1,4...7].
14:57:16 <ivanm> I wish there was a way of providing a "step" value rather than the next value...
14:57:18 <medfly> which I thought is silly.
14:57:22 <MissPiggy> watermind: No you must consider the whole type system together, as one theory of deduction
14:57:23 <ivanm> medfly: heh
14:57:25 <watermind> hmmm probably something to do with the free part
14:57:30 <watermind> MissPiggy: ok
14:57:55 <Berengal> ivanm: Agreed. It's not like it doesn't do "step = next - first" internally anyway
14:58:07 <monochrom> >  vcat . map (hsep . map int) $ [ [n..n+2] | n<-[1,4..9] ]
14:58:08 <lambdabot>   1 2 3
14:58:08 <lambdabot>  4 5 6
14:58:08 <lambdabot>  7 8 9
14:58:11 <monochrom> There!
14:58:14 <ivanm> I've stuffed up a few times assuming it did want the step value :s
14:58:17 <MissPiggy> not quite right
14:58:25 <ivanm> monochrom: now, if only lambdabot printed it properly...
14:58:35 <monochrom> Can't be helped. :)
14:58:36 <Berengal> And often when you need stepping it's easier to provide the step than the next in the sequence
14:58:37 <ivanm> MissPiggy: it fails because lambdabot always prepends a space to everything she prints
14:58:43 <ivanm> monochrom: get lunabot to do it! :p
14:58:50 <ivanm> Berengal: exactly
14:58:54 <ksf> jlouis, I know the answer to command line parsing, gui + client protocol.
14:58:55 <ivanm> @src enumFromThenTo
14:58:55 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:58:58 <ivanm> bah
14:59:00 <ksf> it's called a web server.
14:59:06 <ivanm> @src Int enumFromThenTo
14:59:06 <lambdabot> Source not found. Where did you learn to type?
14:59:07 <monochrom> I don't know how to use lunabot. In fact, where is it? :)
14:59:09 <jlouis> ksf: hah, I think so too :)
14:59:19 <ivanm> preflex: seen lunabot
14:59:20 <preflex>  lunabot was last seen on #haskell 18 days, 15 hours, 36 minutes and 33 seconds ago, saying:  31
14:59:23 <ivanm> hmmm...
14:59:38 <watermind> MissPiggy: I think I get it, I'll have to read it better, but I think boils down to them using explicit quantifiers and requiring alpha not free in A in the Gen rule
14:59:46 <Berengal> ksf: And with continuations you get the command-line sequential coding style back too, if you want it
15:00:02 <Berengal> preflex: seen mmorrow
15:00:02 <preflex>  mmorrow was last seen on #ghc 30 days, 20 hours, 2 minutes and 17 seconds ago, saying: * mmorrow is rtfm'ing
15:01:18 <watermind> MissPiggy: what would be the other two references you had in mind by the way? just curious
15:01:24 <MissPiggy> books
15:01:24 <nschoe> Can I get some help : I don't understand how the 'equalP' function works in here : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7603#a7603 , thanks.
15:01:39 <ksf> another possibility, and probably better to start with, is providing a ghci interface
15:02:19 <ivanm> nschoe: that's from RWH?
15:02:23 <jlouis> ksf: with a ghci-interface it'll definitely look at lot like etorrent :)
15:02:26 <nschoe> ivanm yeah.
15:02:38 <nschoe> (page 222)
15:02:40 <watermind> MissPiggy: "types and programming languages" I guess right, I really need that book? and the other one?
15:02:43 <ivanm> nschoe: it ignores the first two parameters (the _ does a match but "throws away" the value)
15:02:45 <ksf> ...some standard interface for processes to recieve user actions and give info
15:02:53 <ivanm> so it only has the (Maybe Int) to consider
15:02:58 <ivanm> if it's a Just, it returns the size
15:03:07 <ivanm> if it's Nothing, it becomes naughty and returns -1
15:03:08 <Axman6> ivanm: equalP
15:03:14 <nschoe> ivanm, no no I understood that. It's how equalP works.
15:03:15 <ivanm> bah
15:03:22 <ivanm> I misread your question :s
15:03:28 <nschoe> I put the rest just for your understanding og what InfoP was etc.
15:03:29 <ivanm> Axman6: I'm in canberra! \o.
15:03:32 <MissPiggy> hmm
15:03:34 <Axman6> o/
15:03:36 <Axman6> !
15:04:00 * ksf doesn't know any other torrent client except ktorrent
15:04:01 <Axman6> nschoe: expand the IntoP a types out
15:04:08 <Axman6> equalP :: (Eq a) => InfoP a -> a -> InfoP Bool
15:04:08 <ksf> which, despite being kde software, is actually decent.
15:04:10 <Axman6> becomes
15:04:14 <ivanm> nschoe: "equalP f k = \ w x y z -> ..." is the same as "equalP f k w x y z = ..."
15:04:24 <ivanm> they just use the lambda to emphasise what's from the InfoP
15:04:34 <Axman6> equalP :: (Eq a) => (FilePath -> Permissions -> Maybe Integer -> ClockTime -> a) -> a -> FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool
15:04:39 <Axman6> (gross)
15:04:39 <ivanm> Axman6: anyway, I'm currently in the CS building
15:04:56 <Axman6> which level?
15:04:58 <ivanm> I was meant to start on Monday, but they _still_ haven't got the room organised :s
15:05:00 <ivanm> 3
15:05:08 <Axman6> i was there yesterday :)
15:05:12 <ivanm> I'm in Ben's (Lippmeier's ?) office atm
15:05:19 <ivanm> heh, I was here yesterday morning, then left
15:05:19 <Axman6> ha, nice work
15:05:27 <Axman6> he's at UNSW working on DPH atm
15:05:30 <nschoe> Axman6, yeah, but what are the 'f' and the 'k' bound to ?
15:05:40 <watermind> ksf: kget also works with torrents, although it's not an amazing client
15:05:44 <sshc> if "foo :: StateT Foo IO Bar", how do I evaluate "foo" in the IO monad and bind bar ("bar <- ...") to whatever was contained in "foo" so that "bar :: State Foo Bar"?
15:05:46 <doserj> nschoe: an InfoP a is a function that produces an a. 'equalP f a' is a function that compares the result of f with a
15:05:52 <nschoe> My guess is that 'f' is bound to 'InfoP a' and the 'k' to the 'a', am I right ?
15:05:53 <Axman6> nschoe: the f is an InfoP, which is a function
15:06:13 <Axman6> nschoe: correct
15:06:48 <ivanm> Axman6: anyway, I'm waiting for that drink you promised ;-)
15:07:07 <nschoe> Axman6: ok. But where do the w x y z come from ? What are they bound to ?
15:07:13 <Axman6> i thought you didn;t drink :P
15:07:43 <ivanm> Axman6: drink =/= alcoholic beverage
15:07:43 <ivanm> ;-)
15:08:16 <Axman6> phaul: they're the arguments in the InfoP type, they are: w :: FilePath, x :: Permissions, y :: Maybe Integer, x :: Clocktime
15:08:44 <Axman6> uh, nschoe, not phaul
15:09:00 <Berengal> sshc: You need to unwrap it, which you need a state to do
15:09:08 <Berengal> *initial state
15:09:49 <nschoe> Axman6 oh okay, I think I get it : tell me if this is wrong : I must call something 'InfoP myFunction myValue' over 4 arguments (namely a FilePAth, a Permissions a Maybe Integer and a Clocktime" and it will apply the 'myFunction' to these fours arguments and then compare the result with the 'myValue' : is that correct ?
15:10:00 <Berengal> sshc: You can't run just the IO, because it probably depends on the state in some way (or the StateT is useless)
15:10:15 <sinelaw> so how do I go about making Haskell bindings for OpenCV?
15:10:16 <Axman6> nschoe: spot on :)
15:10:21 <sinelaw> since I couldn't find any as of yet
15:10:30 <Axman6> learn how to use the FFI
15:10:36 <Zao> sinelaw: I'd recommend looking at bindings-DSL.
15:10:36 <Axman6> it's not that difficult
15:10:41 <Zao> Lovely little FFI-helping lib.
15:10:43 <ksf> ...or do we have something like dcop for haskell?
15:10:46 <sshc> Berengal: I actually have a list of "StateT Foo IO Bar" and an initial state.  I'm trying to apply each monad in the list to that initial state
15:11:08 <nschoe> Axman6 ok thank you; and thanks to Haskell currying, we can replace it with a simple : 'equalP f k w x y z = f w x y z == k" Is that still correct ?
15:11:24 <sshc> @quote Cale premature
15:11:25 <lambdabot> Cale says: Int is a correctness-damaging premature optimisation
15:11:26 <Axman6> completely :)
15:11:27 <sshc> @quote Cale interact
15:11:27 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
15:11:43 <Berengal> sshc: map{M{_,},} (flip runStateT initialState) stateTList
15:12:12 <sshc> Cale: you have some great, meaningful, and true quotes!
15:12:33 <sshc> Berengal: I don't undertand that syntax.
15:12:33 <nschoe> Thank you very much Axman6.
15:12:38 <sshc> Berengal: Why are you using {}'s?
15:12:42 <nschoe> ^^
15:12:44 <Berengal> sshc: Sorry, that was some bash syntax thrown in
15:13:08 <Berengal> foo{bar,baz} expands too foobar foobaz
15:13:22 <sshc> Berengal: You've nested {}'s
15:13:29 <Berengal> sshc: Nested expansions!
15:13:43 <sinelaw> Zao, what about greencard?
15:13:46 <Berengal> mapM_ <stuff>, mapM <stuff>, map <stuff>
15:13:46 <sinelaw> http://www.haskell.org/greencard/
15:13:52 <Zao> sinelaw: Isn't it rather ancient?
15:14:08 <sinelaw> Zao, dunno, i'm new to this
15:14:17 <sinelaw> looks ancient, yeah
15:14:36 <Berengal> sshc: Basically, just map it. If you want to sequence them, use mapM. If you want to sequence_ them, use mapM_
15:14:43 <Zao> You've got greencard, c2hs, hsc2hs, bindings-dsl.
15:14:55 <c_wraith> ... Are Chans really slow?
15:14:59 <Axman6> no
15:15:03 <sinelaw> Zao, and bindings-dsl is the most modern / highest level ?
15:15:04 <Axman6> they're super fast
15:15:06 <Berengal> They deadlock last I heard
15:15:07 <damd> 4chan is pretty speedy nowadays HIYOOO
15:15:10 <Berengal> If you're very unlucky
15:15:19 <Axman6> built from MVars, which are really fast
15:15:23 <Zao> sinelaw: It's what I currently use, but it's quite new.
15:15:26 <Berengal> But when doing concurrency you should always assume the worst
15:15:29 <Saizan> isEmptyChan + readChan can deadlock
15:15:42 <sinelaw> Zao, ok thanks
15:15:50 <Zao> No matter which one you pick, you've got to do some manual lifting.
15:16:05 <Berengal> Saizan: Individually, or just an unlucky combination of those?
15:16:17 <c_wraith> Err, hm.  actually, I think it's IO that's the issue.
15:16:23 <Saizan> Berengal: in combination
15:16:29 <c_wraith> must be writing to the hard drive that's slow
15:16:30 <Berengal> Saizan: Race?
15:16:37 <McManiaC> is there a way to kill the whole programm and not just one thread?
15:16:50 <Berengal> McManiaC: Kill the main thread
15:17:07 <Berengal> McManiaC: exitWith does that, when run in the main thread
15:17:17 <ivanm> unless you're doing stuff in ghci... >_>
15:17:24 <McManiaC> hmkay
15:17:26 <Berengal> Yeah, well, ghci has signal handlers...
15:17:30 <sinelaw> Zao, oh. example for necessary manual lifting?
15:17:43 <Saizan> Berengal: well, maybe deadlock is not right, iirc if you call isEmptyChan while there's a readChan blocked you block too
15:18:07 <Berengal> Saizan: Ouch
15:18:38 <c_wraith> Hmm.  the hard drive isn't slow either.  The real problem is that many, many small writes to a file are slow, at the OS level.  It's plenty fast writing to /dev/null
15:18:51 <ivanm> Axman6: so, has Ben left ANU for good, or just to go do stuff in sydney for a bit?
15:19:01 <Axman6> i'm not sure
15:19:10 <Axman6> i didn't ask Clem yesterday
15:19:14 <c_wraith> I've got a producer/consumer setup.  When the consumer is writing to a file, it gets WAY behind.  They were communicating via Chan, so I was suspiciou
15:19:17 <c_wraith> s
15:20:02 <ivanm> *nod*
15:20:06 <Saizan> the only problem with a slow consumer is that the Chan will get bigger
15:20:22 <Saizan> so it'll use more memory
15:20:23 <ivanm> Axman6: cos this makes it sound like it's for good: http://ghcsparc.blogspot.com/2010/02/memory-barriers-and-ghc-6121.html
15:20:44 <Saizan> you might need a bounded buffer setup if that's a problem
15:20:51 <Axman6> yeah
15:20:55 <c_wraith> It is a problem.
15:20:58 <Cale> It's not so hard to make a Chan which is bounded, and blocks the writer past a certain number of elements.
15:21:10 <c_wraith> blocking the writer is worse, in my case
15:21:18 <c_wraith> the writers are also handling web requests
15:21:25 <c_wraith> The consumer is logging them
15:21:44 <Axman6> c_wraith: how are you doing the logging?
15:21:45 <sinelaw> Looks like wrapping a big library like OpenCV involves a lot of effort
15:21:53 <Axman6> (strings? bytestrings?)
15:21:58 <c_wraith> Axman6: strings
15:22:01 <copumpkin> want vision for haskell? http://www.easyvision.googlepages.com/
15:22:07 <Saizan> if you can't process, nor store, nor stop producing them it's quite problematic :)
15:22:14 <sinelaw> copumpkin, heh, i just pasted that link in #haskell-blah a few minutes ago
15:22:17 <c_wraith> Axman6: but writing to /dev/null isn't too slow.
15:22:19 <copumpkin> oh :)
15:22:21 <Berengal> c_wraith: Buy a faster machine
15:22:21 <Cale> Well, at a certain point you have to do something or else give up and start dropping various things on the floor.
15:22:30 <Axman6> might want to try bytestrings, and doing some concatting then writing them maybe
15:22:37 <Saizan> maybe the best option is to buffer the actual I/O writes to the OS so you make fewer of them?
15:22:42 <copumpkin> sinelaw: I don't see it :o
15:22:47 <Berengal> c_wraith: Alternatively, if buffering up the writes is acceptable, do that.
15:22:52 <ivanm> copumpkin: you mean as opposed to vision using your eyes?
15:22:53 <Cale> It's possible that ByteString or Text would be more efficient.
15:22:55 <sinelaw> copumpkin, i pasted a link to his blog
15:23:03 <sinelaw> covector.blogspot.com
15:23:10 <copumpkin> sinelaw: ah :) I didn't see that
15:23:15 <copumpkin> it's something I've had in my bookmarks for ages
15:23:21 <c_wraith> I think that in real life, the consumer will keep up.  I'm just testing with ab
15:23:21 <sinelaw> copumpkin, yeah me too
15:23:30 <c_wraith> the production server is a lot faster
15:23:32 <sinelaw> copumpkin, and I actually _need_ it. I'm doing a project, supposed to program this robot
15:23:37 <copumpkin> damn
15:23:42 <copumpkin> evil robots from outer space
15:23:53 <sinelaw> copumpkin, yeah i think i'll make the robot chase people
15:23:59 <copumpkin> sweet
15:24:06 <copumpkin> make it chase babies first
15:24:10 <sinelaw> face detect - re-align - move forward
15:24:15 <ivanm> Berengal: ooohhhh, Vector has enumFromStepN! \o/
15:24:19 <sshc> Berengal: what will "mapM_ (flip runStateT initialState) stateTList" return?
15:24:21 <sinelaw> copumpkin, nah, i'll start with univ. professors
15:24:24 <medfly> sinelaw, so the key is to run away?
15:24:27 <sshc> Berengal: I need the final state
15:24:33 <medfly> sinelaw, then your face isn't seen
15:24:35 <sinelaw> medfly, or to not have a face
15:25:04 <Berengal> ivanm: Neat!
15:25:19 * Berengal needs to use Vector for something hopefully parallel soon
15:25:33 <ivanm> Cale: when I tried using Text for something, I found it less efficient than String... then again, I was using the strict Text type rather than lazy (did a darcs revert before I thought of trying out lazy) and what I was doing was converting the pretty-print type to Text rather than to String...
15:25:46 <Berengal> sshc: The final state of what? All of them?
15:26:34 <sshc> Berengal: there should be a final state, since the state should be passed to each monad in the list in turn
15:26:43 <sshc> Berengal: there should be a single final state
15:26:51 <Berengal> sshc: Oh, right, then you want to sequence them
15:26:58 <Berengal> Before you runStateT
15:27:10 <sshc> Berengal: isn't that what mapM_ (flip runStateT initialState) stateTList does?
15:27:15 <sshc> @type mapM_ (flip runStateT initialState) stateTList
15:27:16 <lambdabot> Not in scope: `initialState'
15:27:16 <lambdabot> Not in scope: `stateTList'
15:27:34 <Berengal> No, it applies the initial state to all StateT actions
15:27:46 <Berengal> @type mapM_ (flip runStateT ?initialState) ?stateTList
15:27:47 <lambdabot> forall a (m :: * -> *) a1. (?initialState::a, ?stateTList::[StateT a m a1], Monad m) => m ()
15:28:05 <Berengal> @type map (flip runStateT ?initialState) ?stateTList
15:28:06 <lambdabot> forall a (m :: * -> *) a1. (?initialState::a, ?stateTList::[StateT a m a1]) => [m (a1, a)]
15:29:02 <sshc> Berengal: would it be this? finalState <- sequence . map (flip runStateT initialState) $ stateTList
15:29:38 <Berengal> @type mapM (flip runStateT ?initialState) ?stateTList
15:29:39 <lambdabot> forall a (m :: * -> *) a1. (?initialState::a, ?stateTList::[StateT a m a1], Monad m) => m [(a1, a)]
15:29:50 <Berengal> ↑ That is what it would return
15:31:51 <Berengal> I guess what you really want is a foldr (>>) get
15:32:00 <Berengal> @type foldr (>>) get
15:32:01 <lambdabot> forall (m :: * -> *) a b. (MonadState b m) => [m a] -> m b
15:32:04 <nus> @type lift sequence
15:32:05 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) [m a]) (m [a])
15:32:27 <shachaf> Hmm, parts of Google Wave were prototyped in Haskell?
15:32:42 <Berengal> shachaf: citation?
15:33:00 <shachaf> Berengal: http://www.reddit.com/r/IAmA/comments/b35zj/i_am_a_google_wave_developer_ama_not_covered_by/c0kq1d8
15:33:01 <sinelaw> Berengal, what's-his-name was here and claimed he works on that team
15:33:29 * shachaf didn't know they used Haskell at Google.
15:33:58 <Berengal> sinelaw: I don't know any what's-his-name.
15:35:27 <sinelaw> Berengal, i don't remember the nick
15:35:46 <ivanm> preflex: seen kamatsu
15:35:46 <preflex>  kamatsu was last seen on #haskell 2 days, 7 hours, 2 minutes and 21 seconds ago, saying: adios
15:37:09 <roboshibby> greetings fellow geniuses
15:38:00 <ivanm> geniuses? where?
15:38:02 <c_wraith> So, adding a second OS thread (this is a dual-core machine) makes the consumer get behind even when logging to /dev/null.  I could use a SampleVar for logging.  That's only a slightly horrible idea, right?
15:38:12 <ivanm> I know Cale is hanging around...
15:38:29 <medfly> he is.
15:39:04 <medfly> oh, darn, I thought you were going to bother him with something, and he is not responding :)
15:39:09 <ivanm> heh
15:39:21 <ivanm> nah, talking about which geniuses there are here...
15:39:25 <ivanm> preflex: seen dons
15:39:25 <preflex>  dons was last seen on #haskell 1 day, 16 hours, 50 minutes and 57 seconds ago, saying: not sure if anything but demos has been written with it. frag is a famous FRP-based 3d game in haskell
15:39:30 <ivanm> nope, dons isn't here...
15:39:48 <roboshibby> i have a question about haskell i haven't been able to find with looking thorugh docs yet. if you would please, i have the following scenario: foo has subclass bar. now, foo has a property called "name". bar would inherit this name property, correct?
15:40:14 <medfly> wow this sounds like OO
15:40:14 <c_wraith> That question doesn't sound especially coherent for haskell
15:40:15 <copumpkin> I think you're confused :)
15:40:27 <copumpkin> roboshibby: what is Foo?
15:40:38 <nus> heh, so much for flamboyance
15:40:47 <roboshibby> yea i guess it is oo-ish. i come from ruby and objc
15:40:52 <roboshibby> getting into haskell
15:40:59 <copumpkin> aha, hubris?
15:41:00 <roboshibby> just trying to understand some fundamental concepts
15:41:10 <copumpkin> for us, classes are very different from OO-like classes
15:41:18 <ivanm> roboshibby: you mean class Foo a where ... class (Foo a) => Bar a where ... ?
15:41:18 <copumpkin> types are a bit closer, if anything
15:41:20 <roboshibby> i see
15:41:22 <ksf> roboshibby, if you hear the term "typeclass", forget everything you know about oo classes.
15:41:31 <ivanm> in that case, then yes, all instances of Bar will be able to use the methods from Foo
15:41:35 <ksf> the clostest thing you might now are go interfaces.
15:41:48 <ksf> *know
15:41:58 <roboshibby> well here is ultimately what im trying to figure out, if a property value from the superclass is inherited/held by the subclass
15:42:06 <Cale> roboshibby: If Bar is a subclass of Foo, all that it means is that when you write an instance of Bar, you must also write an instance of Foo (and they're allowed to be mutually recursive if it helps). Also, when you have a (Bar a) constraint in a type signature, it means the same thing as (Foo a, Bar a)
15:42:07 <copumpkin> mixins aren't too far away, although dobblego would wring my neck for saying so
15:42:16 <shachaf> roboshibby: Haskell type classes correspond more to Ruby's modules in some ways, I think.
15:42:17 <roboshibby> so if foo's name property was "Foo", would bar's name property have a value? and if so, would it be "Foo" ?
15:42:20 <Cale> I don't know what you mean by "property" here.
15:42:31 <Cale> Classes don't have properties.
15:42:42 <ksf> wth is a property?
15:42:45 <copumpkin> a unary method a -> T? :P
15:42:48 <roboshibby> hm
15:42:53 <roboshibby> how do you guys code stuff? :P
15:43:03 <ksf> depends.
15:43:06 <roboshibby> seriously though, how do you guys do logical organization in haskell?
15:43:07 <ksf> what do you want to code?
15:43:10 <medfly> roboshibby, an hour of meditation followed by the emission of a fold statement
15:43:10 <damd> we don't code stuff, we only discuss the theory behind coding
15:43:12 <copumpkin> roboshibby: by thinking very differently from how you're used to thinking :) you might want to forget you even know any other languages if you want to try haskell
15:43:24 <medfly> @quote meditation
15:43:24 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
15:43:27 <medfly> :)
15:43:44 <copumpkin> roboshibby: more seriously though, do you know what a zygohistomorphic prepromorphism is?
15:43:50 * copumpkin whistles
15:43:52 <roboshibby> no
15:43:57 <Cale> lol
15:43:57 <roboshibby> what is it?
15:43:57 <shapr> haha, that's a good quote.
15:43:58 <copumpkin> ah, then we have a problem
15:44:03 <ksf> roboshibby, if you want oo-style objects in haskell, use records. you'll have to do impementation inheritance manually, which is good, because it's extremely evil.
15:44:10 <Cale> roboshibby: copumpkin is pulling your leg ;)
15:44:12 * copumpkin is just living up to the scenario ksf built on reddit
15:44:19 <copumpkin> except Cale is supposed to say that
15:44:20 <sshc> Berengal: since "foo <- mapM (flip runStateT ?initialState) ?stateTList" will cause foo be of type [(a1, a)], what do I do with that list to get the final state?
15:44:25 <medfly> what does pulling your leg mean?
15:44:30 <shapr> Teasing, joking.
15:44:31 <ivanm> copumpkin: what scenario?
15:44:46 <medfly> okay, thanks
15:44:49 <temoto> OO properties are like  class Property t where  get :: o -> t ; set :: o -> t -> o
15:44:50 <copumpkin> ivanm: ksf posted in a thread in haskell an imaginary discussion between me and Cale :)
15:44:52 <sshc> medfly: pulling your leg means eating doughnuts
15:44:57 <ivanm> link?
15:44:59 <Cale> copumpkin: haha
15:45:01 <medfly> mm, doughnuts... ?
15:45:04 <Cale> copumpkin: I'd like to see that
15:45:05 <shapr> medfly: "Pulling your leg" is almost always used in cases where something is blown out of proportion and made far scarier than the reality.
15:45:05 * ksf searches his posts
15:45:08 * ivanm has been unable to read reddit for the past 10 days or so :s
15:45:13 <shapr> medfly: Australia's drop bears, for example.
15:45:14 <medfly> oh, okay.
15:45:15 <copumpkin> I thought it was ksf
15:45:19 <medfly> shapr, what are they!
15:45:20 <ivanm> shapr: nah, they're real
15:45:24 * shapr laughs
15:45:27 <ivanm> you obviously haven't seen the bundaberg rum ad
15:45:27 <ksf> copumpkin, no it was me.
15:45:28 <ivanm> ;-)
15:45:31 <copumpkin> http://www.reddit.com/r/programming/comments/awcew/functional_programming_immutable_objects/c0jqazk
15:45:37 <shapr> medfly: http://en.wikipedia.org/wiki/Drop_bear
15:46:15 <ivanm> copumpkin: ahhh, yes, I did see that one
15:46:19 <copumpkin> :)
15:46:41 <ivanm> medfly: they're big koala bears that drop out of trees and eat your brains
15:46:51 <roboshibby> k back to me now
15:46:53 <ivanm> that's why you should never sit/etc. under a tree in Australia
15:46:55 <roboshibby> <-
15:47:06 <ivanm> roboshibby: but your topic isn't as interesting!
15:47:07 <ivanm> ;-)
15:47:09 * copumpkin stares at roboshibby 
15:47:19 * temoto stares at roboshibby 
15:47:25 <roboshibby> if you were to explain how programming is done in haskell in only 1 sentence, what would it be?
15:47:28 <medfly> Cale, oh oh, show him your page about "a look at OO in Haskell" or somesuch
15:47:41 <ksf> roboshibby, i'd say "mu"
15:47:45 <shapr> roboshibby: You describe what needs to be done, not how to do it.
15:48:00 <temoto> roboshibby, that meditation quote is pretty much close.
15:48:08 <benmachine> roboshibby: "beautifully"
15:48:20 <Berengal> sshc: The final state, and the last result, is in the last element of the list. You probably want to use a fold instead though
15:48:24 <Cale> roboshibby: There are a lot of overall approaches which work, but the most common is to write libraries that behave a bit like miniature programming languages.
15:48:28 <ksf> roboshibby, if you're addicted to your oo, have a look at http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html
15:48:45 <roboshibby> im not addicted to oo
15:48:49 <roboshibby> i find limitations in even it
15:48:54 <lament> i'm addicted to oo :(
15:48:59 <copumpkin> oOo
15:49:01 <Cale> roboshibby: In that they will define some primitive elements -- solutions to the simplest possible problems, and then ways to combine those into more complicated programs.
15:49:06 <sshc> Berengal: how do I use a fold if I have a list and an initial state?
15:49:22 <ksf> ...and if you want to know how to encode every oo paradigm under the sun, and more, in haskell, have a look at http://homepages.cwi.nl/~ralf/OOHaskell/
15:49:34 <roboshibby> so it's like unix pipes paradigm
15:49:36 <copumpkin> sshc: fold your function over the list, with the initial state :P
15:49:39 <roboshibby> "lots of little simple utilities"
15:49:43 <copumpkin> roboshibby: sort of, yeah
15:49:52 <shapr> Gwahr, make failed with "error 2"
15:49:59 <temoto> Speaking of monads, we tried to make home burrito yesterday with my wife. They're truly delicious! :P
15:50:01 <copumpkin> @let rle = map (length &&& head) . group
15:50:02 <lambdabot>  Defined.
15:50:07 <roboshibby> sounds like what i hear about lua
15:50:17 <Cale> roboshibby: To have a programming language, you need three things: primitive computations, a means of combining primitive computations into more interesting ones, and a means of abstracting constructions in order to avoid repetition of structure and create new things which behave as if they were built in.
15:50:19 <roboshibby> not an actual language, but rather the facilities to make a language
15:50:20 <sshc> copumpkin: elaborate??
15:50:21 <copumpkin> > rle "missssssissssssssippppppppi"
15:50:23 <lambdabot>   [(1,'m'),(1,'i'),(6,'s'),(1,'i'),(8,'s'),(1,'i'),(8,'p'),(1,'i')]
15:50:23 <Berengal> @type foldr (<<)
15:50:24 <lambdabot> Not in scope: `<<'
15:50:29 <copumpkin> roboshibby: see, like that :)
15:50:33 <Berengal> @type foldl (>>)
15:50:33 <sshc> @type rle
15:50:34 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [m b] -> m b
15:50:35 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
15:50:37 <ksf> Cale, you stole that from the introductory sentences of SICP
15:50:40 <roboshibby> cale, well put
15:50:40 <Cale> roboshibby: Typically your libraries will borrow the last of these, the abstraction part, from Haskell.
15:50:44 <Cale> ksf: Yep.
15:51:07 <Berengal> sshc: foldl (>>) get returns the last state
15:51:07 <copumpkin> @let unrle = (>>= uncurry replicate)
15:51:08 <lambdabot>  Defined.
15:51:18 <copumpkin> > unrle [(1,'m'),(1,'i'),(6,'s'),(1,'i'),(8,'s'),(1,'i'),(8,'p'),(1,'i')]
15:51:19 <lambdabot>   "missssssissssssssippppppppi"
15:52:06 <Berengal> Cale: That's been my mantra for a while
15:52:11 <Axman6> > unrle . rle $ "missssssissssssssippppppppi"
15:52:12 <lambdabot>   "missssssissssssssippppppppi"
15:52:15 <Berengal> Well, that and WWEWDD
15:52:34 <copumpkin> roboshibby: see, I made RLE compression and decompression very simply by composing smaller pieces
15:52:42 <sshc> @type foldr (>>) get ?listOfSTActions
15:52:43 <lambdabot> forall (m :: * -> *) a b. (MonadState b m, ?listOfSTActions::[m a]) => m b
15:52:44 <Axman6> @check \(x::String) -> (unrle . rle) x == x
15:52:45 <lambdabot>   Parse error in pattern at "->" (column 14)
15:52:50 <ksf> roboshibby, one of those abstracting constructions haskell supports are zygohistomorphic prepromorphisms. but you're not limited to that
15:52:57 <Axman6> @check \x -> (unrle . rle) x == (x :: String)
15:52:58 <lambdabot>   Not in scope: `unrle'Not in scope: `rle'
15:53:05 <Axman6> :(
15:53:09 <roboshibby> typical irc
15:53:11 <Saizan> Berengal: meaning?
15:53:19 <Cale> roboshibby: (Now I'll steal from SPJ) Imagine if you were writing a library to work with recipes. You might describe some primitive things, basic ingredients, and then ways in which those could be transformed and combined (whip, chop, mix, layer, etc.)
15:53:20 <roboshibby> 3 smart helpful guys and 3456356 douches eager to be smart
15:53:25 <Berengal> Saizan: What, WWEWDD?
15:53:32 <Saizan> Berengal: yeah
15:53:33 <Axman6> > map (unrls . rle) cake == cake
15:53:34 <lambdabot>   Not in scope: `unrls'
15:53:37 <Axman6> > map (unrle . rle) cake == cake
15:53:37 <Berengal> What Would Edsger Wybe Dijkstra Do
15:53:38 <lambdabot>   True
15:53:40 * shapr gives up on building ghc 6.12 and uses the generic linux 64-bit binary.
15:53:44 <copumpkin> roboshibby: the zygohistomorphic prepromorphism thing is a running joke in here, because people say we're too academic and impractical, so we came up with the quintessential useless thing and use it jokingly a lot :)
15:53:51 <sshc> Berengal: do{foo <- foldr (>>) get ?listOfSTActions; let{finalState = snd foo}}?
15:53:52 <Cale> roboshibby: and then define ways to transform the results recursively, based on how the thing was built up
15:54:19 <roboshibby> is this like a combination between procedural and functional programming?
15:54:22 <Berengal> sshc: Unless I've messed up the direction of the fold, yes
15:54:42 <Cale> roboshibby: For example, computing the sugar content would come from computing the sugar content of each ingredient, and then describing how each of the combining/transforming operations affects the sugar content of the result
15:54:53 <ksf> roboshibby, more seriously, the things you're bound to stumble across more often come by the name of monoid, functor, applicative functor and monoid
15:55:00 <Berengal> Wait, (>>) is associative isn't it?
15:55:01 <Cale> roboshibby: What I'm describing is the general approach to functional programming
15:55:16 <Cale> ah, dinner
15:55:20 <Cale> bbiab
15:55:22 <roboshibby> ok well thanks for your help cale
15:55:28 <Berengal> sshc: Use a foldr. It'll be lazier and less likely to blow your stack
15:55:33 <Twey> Berengal: Yes, by the monad laws
15:55:40 * Berengal needs to sleep
15:56:09 * shapr sings a purely functional lullaby to Berengal 
15:56:13 <ksf> a monoid, for example, caputures the pattern of an operation on some set of things. like +, which is a monoid over the natural numbers with identity 0, or * over the nats with id 1. then we have ++ over the strings with the id "", ...
15:56:23 <sshc> Berengal: but where is the initial state?
15:56:27 <Berengal> shapr: No effect :(
15:56:33 <shapr> aww
15:56:41 <Berengal> sshc: Well, now you get a new StateT out, so just runStateT that
15:56:44 <Twey> What do we call a monoid without an id?
15:56:52 <shapr> Berengal: Put in headphones, listen to calm music, lie quietly in bed.
15:56:55 <Berengal> sshc: The fold just combines the list of actions into one action
15:56:59 <temoto> Twey, a functor?
15:57:00 <ksf> a binary operation?
15:57:15 <Twey> Needs associativity, doesn't it?
15:57:23 <Berengal> Associative binary operator then :)
15:57:50 <tensorpudding> Twey: semigroup
15:57:52 <ksf> > foldr (*) 1 [3..4]
15:57:53 <lambdabot>   12
15:57:58 <ksf> > foldr (+) 0 [3..4]
15:58:00 <lambdabot>   7
15:58:02 <tensorpudding> alternatively, an associative magma
15:58:03 <Twey> Ah, tensorpudding, thanks
15:58:09 <Twey> Ah, the magma
15:58:31 <ksf> > foldr (++) "" (map show [3..4])
15:58:32 <lambdabot>   "34"
15:58:41 * Berengal keeps forgetting what a magma is
15:58:45 <MaciejP> Hi! Is there a Haskell tool for merging all my extra libraries' docs into one single doc?
15:59:01 <Berengal> MaciejP: A common index, you mean?
15:59:02 <damd> isn't magma what dr. evil uses in that one movie?
15:59:05 <Axman6> > foldr mplus mempty (map show [1,2,3,4])
15:59:06 <lambdabot>   "1234"
15:59:14 <tensorpudding> a magma is just a set that has a binary operation which is closed
15:59:22 <ksf> Axman6, yep thats what I wanted to do.
15:59:22 <MaciejP> Berengal: Yes
15:59:27 <ksf> it figures, though, that he's gone.
15:59:35 <lispy> boiling hot magma
15:59:37 <Berengal> MaciejP: haddock should do that for you when it builds. I don't know how to do it after-the-fact
15:59:40 * ksf doesn't get people who don't stay for lurking
15:59:50 * Axman6 doesn't either
15:59:53 <lispy> ksf: I know the feeling
16:00:00 <Berengal> MaciejP: But if there is a way, the haddock documentation is where to start.
16:00:26 <MaciejP> Berengal: Ok, thanks. I have to look closer to that doc :-)
16:01:47 <glguy> > Data.Foldable.foldMap show [1..4]
16:01:48 <lambdabot>   "1234"
16:01:55 <blackh> MaciejP: I can tell you how to do it...
16:02:23 <MaciejP> blackh: That would be even nicer
16:02:26 <medfly> @type foldMap
16:02:27 <lambdabot> Not in scope: `foldMap'
16:02:34 <ivanm> ksf: even better: someone comes online, asks a question, gets annoyed no-one answers instantly, and leaves within 5 minutes
16:02:40 <medfly> @hoogle foldMap
16:02:40 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
16:02:40 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
16:02:54 <blackh> MaciejP: Step 1: Edit ~/.cabal/config and add this line: documentation: True
16:03:17 <blackh> MaciejP: Step 2: Point your browser at file:///home/blackh/.cabal/share/doc/index.html
16:03:32 <blackh> MaciejP: Step 3: Re-install any packages that are missing from this index using 'cabal install --reinstall <packagename>'
16:04:19 <blackh> MaciejP: This fails completely if you use more than one version of ghc.  It will screw up badly.  You'll need to 'cabal install --reinstall' all the packages that you installed on the other version
16:04:19 <MaciejP> blackh: Thanks! I'll give it a try ...
16:04:44 <Axman6> blackh: this should be written up somewhere...
16:05:24 <blackh> I just need to figure out how to get it to give me source code.
16:05:58 <Veinor_> ksf: learning from osmosis
16:06:00 <ivanm> blackh: there's no automatic way of doing it for cabal-install
16:06:19 <blackh> ivanm: Sounds like a good project for someone
16:06:20 <ivanm> blackh: there's a bug about it, but dcoutts et al are working out a nice way of specifying the command line invocation
16:06:25 * Axman6 tries to think of something that uses a crapload og packages
16:06:27 <Axman6> of*
16:06:28 <ivanm> if you do it by hand you can do it...
16:06:31 <ivanm> Axman6: yi
16:06:39 <Axman6> good plan
16:07:23 * ivanm tries to avoid making bad plans...
16:08:39 <Axman6> urgh, yi requires cabal 1.6
16:08:49 <Berengal> Axman6: The darcs version too?
16:08:57 <Axman6> haven't tried
16:09:05 <Axman6> and not actually interested in using it
16:09:23 <Berengal> I think it fixes that particular issue, at least
16:09:33 <Berengal> And should in general be more updated to work with 6.12 as well
16:09:57 <Axman6> is there a way to get a list of all packages installed using cabal?
16:11:20 <Berengal> Axman6: ls ~/.cabal/packages/hackage.haskell.org/ good enough?
16:11:28 <Axman6> might be
16:11:50 <Berengal> Otherwise I don't think so. Not unambiguously at least
16:12:15 <Berengal> It's possible to install packages in such a way that you can't tell if you did it yourself or let cabal do it for you
16:12:17 <Axman6> hmmmmmmm, would deleting all dirs named ghc-6.10.* be a bad idea in .cabal, if i only use 6.12.1?
16:12:38 <Axman6> because, they're taking up 1.6GB
16:12:39 <Cale> Axman6: I've done that before with no ill effects
16:12:51 <Berengal> Axman6: Worst that can happen is you have to rm -rf a few things
16:12:56 <Cale> I usually make a point of it while upgrading ghc
16:13:02 * Axman6 thinkks that if Cale's done it, it's probably going to be ok
16:13:20 <ksf> is there a way to fix a version of a package with cabal?
16:13:29 <Cale> Hey, I also installed Ubuntu Karmic, which was a huge waste of time.
16:13:41 <ivanm> Axman6: check what's installed with ghc-pkg list ?
16:13:42 <ksf> it's constantly trying to re-install network because there's a new parsec, and I don't want it to do that
16:13:43 <ivanm> Cale: heh
16:13:44 <Axman6> yeah, linux sure is
16:13:45 <Axman6> >_>
16:13:51 <ksf> (or specify the contraint manually every time)
16:13:58 <ivanm> @slap Axman6
16:13:59 <lambdabot> Come on, let's all slap Axman6
16:14:03 <ivanm> Axman6: what did you have before?
16:14:12 <Axman6> before what?
16:14:15 <ivanm> Axman6: is it just me, or does the CS department at ANU use ubuntu for their machines?
16:14:15 <Cale> Well, linux is probably the least stupid option available at the time being.
16:14:16 <ksf> nevermind, there's a constraint field in the config
16:14:29 <ivanm> Cale: exactly
16:14:38 <Cale> But there doesn't seem to be a distribution which I can really consider to be headed in the right direction.
16:14:47 <Axman6> ivanm: they sure do -_-
16:14:57 <Cale> Well, perhaps Gnome is responsible for a good bit of the recent silliness.
16:15:13 <Axman6> ivanm: they're also changing from KDE to Gnome atm
16:15:15 <Cale> PulseAudio is a major complaint for me.
16:15:29 <Saizan> archlinux + lxde + xmonad ftw
16:15:31 <Cale> I absolutely despise PulseAudio.
16:15:31 <ivanm> up at UQ, the sysadmin at maths prefers fedora because it's easier to do remote updates, etc. ; after trying to get ubuntu working on a tablet (so that people didn't have to use windows), I agreed
16:15:41 <ivanm> agreed
16:15:44 <Berengal> Cale: PulseAudio seems to work just dandy for me
16:15:53 <temoto> Cale, what's wrong with PA?
16:15:56 <ivanm> Cale: how about gentoo, arch, etc.? or do they involve too much work?
16:15:58 <Berengal> Cale: The idea is sound enough
16:16:06 <ivanm> temoto: the fact that people think you need it
16:16:08 <Berengal> Eh, pun not intended
16:16:11 <Cale> For me, it simplified my available volume controls to just a single volume knob, and killed the output of my headphones.
16:16:16 <ivanm> and the absolutely  messy diagrams... ;-)
16:16:17 <medfly> Cale, #haskell wants to know all your personal preferences so we can all copy you
16:16:25 <ivanm> medfly: heh
16:16:26 <medfly> Cale, how much sugar do you put in your coffee?
16:16:29 * Axman6 uses an OS where he doesn't need to know the name of the audio system, because It Just Works®
16:16:39 <ivanm> @remember me Cale, #haskell wants to know all your personal preferences so we can all copy you
16:16:39 <lambdabot> It is forever etched in my memory.
16:16:41 <Cale> medfly: a lot.
16:16:58 <medfly> Axman6, netbsd?
16:17:04 <ivanm> Axman6: I prefer using an OS where I know what's there, I can tweak what's there and I can install and run whatever I want (assuming its available)
16:17:04 <Axman6> OS X
16:17:11 <Cale> ivanm: You remembered that quote as coming from 'me'
16:17:20 <Axman6> ivanm: that's why i use OS X :P
16:17:22 <ivanm> bah
16:17:25 <Cale> @forget me Cale, #haskell wants to know all your personal preferences so we can all copy you
16:17:25 <lambdabot> Done.
16:17:27 <ivanm> @forgot me Cale, #haskell wants to know all your personal preferences so we can all copy you
16:17:27 <lambdabot> No match.
16:17:31 <ivanm> the paste failed :s
16:17:37 <ivanm> @remember medfly Cale, #haskell wants to know all your personal preferences so we can all copy you
16:17:39 <lambdabot> It is stored.
16:17:42 <lpjhjdh> I like apple's products, but I don't like fascism
16:17:54 <medfly> I tell apart distributions by their package manager, and the ubuntu one works well for me
16:18:04 <ivanm> Cale: I thought you first said that I remembered the quote as coming from _you_ ... (the quotes weren't obvious enough)
16:18:20 <medfly> also I suppose what is installed by default...
16:18:22 <Cale> Speaking of "paste failed", I've been really annoyed with programs that seem to lose the primary lately.
16:18:26 <ivanm> Axman6: ummm..... how many 3rd party package managers are there to install other stuff?
16:18:36 <Axman6> three or four
16:18:50 <ivanm> medfly: I hate ubuntu's PM... the gui doesn't know the same stuff as the cli
16:18:53 <medfly> using apple stuff seems tedious, I have to buy special hardware :)
16:18:59 <Cale> Though I think that was mostly Firefox 3.5's fault. Upgrading FF to 3.6 seems to have fixed a good bit of that.
16:19:07 <Axman6> Macports (the Apple hosted and supported one), Fink, Homebrew, and i think the netbsd and debian ones also work on O
16:19:11 <Axman6> OS X*
16:19:12 <medfly> oh... I use it on the commandline. I just mean it usually has everything I want.
16:19:16 <Berengal> Most of the time I want my OS to Just Work. Every second full moon however, I turn into this Linux Geek who's absolutely fascinated by the ability to make things work Just Right, and then spends a weekend writing scripts and configs, trying to fix whatever he broke the first five minutes
16:19:38 <medfly> hehe
16:19:45 * Berengal switched to XMonad last weekend
16:19:48 <medfly> Berengal, ubuntu is a bit like that. a lot of things just worked, even though some shouldn't have.
16:20:18 <lpjhjdh> I think linux has moved in the right direction in just about every way but multimedia, X and alsa are terrible
16:20:19 <Berengal> medfly: flash didn't work for me... until I switched to XMonad, pulseaudio and uzbl
16:20:29 <Cale> Yeah, I'm happy that at least because it's linux, I can fix the problems I had with PulseAudio by uninstalling PA, and then recompiling the various bits of Gnome that rely on it to work with ALSA instead.
16:20:36 <lpjhjdh> I have to switch between oss4 and alsa every few months because one breaks for seemingly no reason and then the other works again
16:20:43 <medfly> flash worked for me by default, even though normally I'd need a lot of work to get it running (using 64bit)
16:21:04 <ivanm> Axman6: and there's also gentoo-alt (or whatever they're calling it these days)
16:21:08 <Cale> I have no conceptual problem with OSS4, but I haven't bothered to try it.
16:21:10 <Axman6> yeah
16:21:11 <medfly> I still haven't gotten how this nspluginwrapper thing works
16:21:40 <Berengal> medfly: Badly. it would randomly claim a core and do nothing but heat up my machine
16:21:47 <medfly> hehehe
16:21:49 * Berengal had a cron to kill it
16:22:31 <Cale> Recently I seem to have lost my Java browser plugin though.
16:22:43 <FauxFaux> (so much sadness.  So much)
16:22:53 <riri> hey, is there a way to make a datatype that can contain any type of a particular class, eg [1, 'a', "ab"] all supporting Show and functions that can accept these datatypes as args, eg one to show and concat everything in that list, to make "1aab"?
16:23:00 <medfly> FauxFaux, ?
16:23:11 <dankna> Is there any way to suppress "data constructor defined but not used" warnings on a case-by-case basis?
16:23:13 <dankna> from ghc
16:23:16 <Cale> Flash "works", but ever since the "upgrade" to Karmic, it flickers annoyingly (on non-video things).
16:23:19 <Axman6> my problem with the li8nux world is that there's usually 100+ projects all trying to do the same thing, slightly differently, and they all do it badly
16:23:20 <Berengal> riri: Yes. Existential types
16:23:22 <ivanm> Cale: echo "www-client/mozilla-firefox java" >> /etc/{paludis/use.conf,portage/package.use} ;-)
16:23:38 <McManiaC> what database library do you guys prefer for working with sqlite3?
16:23:58 <ksf> do we have an at least moderately mature http server that does the more fancier kind of stuff like pipelining but isn't a behemoth and/or called happstack?
16:24:12 <Saizan> McManiaC: HDBC seems to be the most actively maintained
16:24:14 <ivanm> McManiaC: I prefer not to work with databases... ;-)
16:24:20 <Berengal> McManiaC: hdbc is pretty much the basic sql library
16:24:23 <McManiaC> ok, thx
16:24:27 <Saizan> McManiaC: not very high level though
16:24:42 <Cale> Axman6: But when you put it up against one project with no potential for another because everything is closed, and which still has irritating problems, it seems better overall.
16:24:45 <Berengal> You might want to take a look at haskelldb or takusen too
16:24:49 <McManiaC> I tried to install haskelldb-hsql, but it didnt even build
16:24:52 <Saizan> ksf: seen hyena?
16:25:03 <bolmar> :info chr
16:25:03 <Axman6> Cale: not to me, when the closed stuff works far more reliably
16:25:10 <ksf> not yet. I've just found http-server
16:25:11 <Berengal> ksf: Why not happstack?
16:25:12 <bolmar> @info chr
16:25:12 <lambdabot> chr
16:25:21 <riri> ok, and what is a "rank" as in "rankNTypes"? I thought it was relevant, although I never figured out the defenition of rank
16:25:30 <ivanm> Cale: oh, since you're here, do you have any recommendations for a data structure representation for fullerenes? (they're basically graphs but I need to know the angle between the edges)
16:25:34 <mauke> nesting level of 'forall'
16:25:56 <sshc> is it possible to make a single line of code an exception to the overlapping pattern matches warning?
16:26:02 <ivanm> Axman6: ummmm.... that's the F/LOSS world in general; look how many duplicate libs we have on hackage...
16:26:06 <Cale> Axman6: When things don't work on Linux, and I care sufficiently, I at least have some hope that I can figure out what's wrong and fix it myself. When things are broken on Windows, basically the only thing you can do is reboot the machine, and start reinstalling things and hope that stuff magically starts working again.
16:26:19 <ivanm> Cale: heh
16:26:23 <copumpkin> :t undefined :: forall a. a -> (forall b. b -> (forall c. c))
16:26:24 <lambdabot> forall a b c. a -> b -> c
16:26:25 <Axman6> ivanm: well yeah, though there are some parts of the OSS world i prefer
16:27:11 <copumpkin> :t undefined :: (forall a. (forall b. (forall c. c) -> b) -> a) -> d
16:27:12 <lambdabot> forall d. (forall a. (forall b. (forall c. c) -> b) -> a) -> d
16:27:16 <Axman6> Cale: tbh, while i dislike windows a lot, i still find it far less broken than any linux distro i've ever used, and far more usable
16:27:31 <ivanm> define "usable"
16:27:36 <glguy> "plays games"
16:28:12 <mypetclone> How many distros have you used and for what periods of time?
16:28:12 <Axman6> i don't find myself saying "wtf? why did that just happen?" or "wtf? why isn't this installed/configured by default?" all the time
16:28:23 <MissPiggy> lol
16:28:23 <Axman6> countless, for about 12 years
16:28:27 <Berengal> Axman6: Appart from some misses with redhat and debian in the last 90's/early 2000's, I've always found Linux more useable for me than windows, with the exception of games
16:28:29 <Axman6> and i'm not a windows user
16:28:29 <glguy> Windows is a joke compared to Linux for development... but games?
16:28:30 <glguy> awesome!
16:28:37 <MissPiggy> I have no idea I can't use linux
16:28:45 <lament> i love windows for development, linux doesn't have visual studio
16:28:45 <MissPiggy> I have tried again and again but it just doesn't work for me
16:28:46 <blackh> Axman6: Have you tried Ubuntu?
16:28:47 <copumpkin> Axman6: if anything I find myself going "WTF" a lot more in windows
16:28:57 <ivanm> glguy: heh
16:29:00 <MissPiggy> I am sure some kind of master computer technician has no problem with it but for someone like me it si just impossible
16:29:13 <MissPiggy> and I think it sounds like a GREAT thing, but I just don't have the skill
16:29:26 <Axman6> i dispise ubuntu, because they claim to make a usable distro, which feels like a hacked together childs toy
16:29:28 <medfly> Axman6, I don't agree...
16:29:28 <Berengal> Windows administratoring constantly makes me go "wtf"
16:29:38 <c_wraith> Hmm.  is hFlush threadsafe with the various writing functions?
16:29:42 <Axman6> copumpkin: i find myself going WTF a fair bit too, but i know why i;m doing it ;)
16:29:44 <ivanm> Axman6: I agree with you there
16:29:47 <Cale> Axman6: Ubuntu was better a few versions back than it is now.
16:29:47 <Axman6> the devil you know 'n all
16:29:52 <medfly> Axman6, I tried to do a bunch of things that was not typical of a windows user, say... try to write code... having to find the programs all the time was so tedious >.<
16:30:00 <medfly> Axman6, and I couldn't just "man something"
16:30:01 <Axman6> i haven't used ubuntu for a few years now
16:30:04 <gehmehgeh> Ubuntu makes you fart
16:30:04 <lpjhjdh> I just don't know how anyone can stand using cd's and spending hours on the internet to install something rather than just invoking a package manager
16:30:16 <Axman6> anyway, this isn't the place for all this, and i'm going to get yelled at soon ;)
16:30:17 <blackh> Axman6: I will take that as a yes. :)  I like Ubuntu because everything works.
16:30:18 <Berengal> Basically, administrating windows feels about as planned as... well, less planned, in fact, than desktop linux
16:30:24 <Cale> Ubuntu was mostly good around feisty or so, but it's gone downhill from there.
16:30:36 <Axman6> medfly: i wouldn't use windows for writing code anyway
16:30:46 <lament> lpjhjdh: on linux, i install everything from the package manager; on windows, i install everything from the pirate bay
16:30:54 <medfly> and it *really* sucks when something doesn't work.
16:30:54 <Berengal> Windows does have a better desktop environment than linux, even though it's highly restrictive and fugly
16:31:02 <Axman6> Berengal: my experience way that it didn't. i saw every time i had to resort tot he command line to fix something as a failure
16:31:03 <medfly> on linux, I can google an error. on windows, I have nothing...
16:31:08 <Cale> Berengal: I wholeheartedly disagree.
16:31:12 <lpjhjdh> lament: haha
16:31:20 <Axman6> Berengal: i agree ;)
16:31:34 <Berengal> Cale: About the DE?
16:31:35 <Cale> Berengal: Windows doesn't even come with virtual desktops, or point to focus, which I consider essential.
16:31:43 <Cale> Yeah.
16:31:45 <medfly> I think that ubbuntu does more things than windows.
16:31:54 <gehmehgeh> or this copy and paste through the middle mouse button
16:32:01 <medfly> for windows, you normally have hardware makers developing drivers. no need to bother about that.
16:32:22 <ivanm> medfly: most drivers in linux are also from the HW manufacturers AFAIK ...
16:32:32 <ivanm> (all the little specialised ones, etc.)
16:32:55 <sshc> http://archlinux.org/ !
16:32:58 <medfly> people seem to expect linux to have all the drivers even when the hardware manufacturers won't make them.
16:33:00 * Axman6 dispises focus follows mouse
16:33:07 <Axman6> despises*?
16:33:15 <medfly> yes
16:33:17 <Cale> I can't get along without focus follows mouse :)
16:33:21 <Zao> Axman6: It's quite handy, as you just have to slap the mouse to refocus.
16:33:28 * Axman6 also really does not like the GPL
16:33:29 <Cale> It's just too annoying to have to raise a window to type into it.
16:33:31 <Berengal> Cale: Ah, well, it's a better DE not in that it's more useable for me, but that it's better integrated with the rest of the system and easier to use if you follow its conventions
16:33:38 <medfly> Cale, I alt-tab
16:33:45 <sshc> I like focus follows mouse a lot
16:33:59 <medfly> it'd be pretty strange for me, I normally just have one big window with whatever I'm doing right now
16:34:02 <medfly> not a bunch of them
16:34:03 <sshc> it's really quite handy to change focus
16:34:08 <Cale> Quite often I want to read something in one window and type into another.
16:34:13 <Berengal> Cale: I couldn't live on a windows machine without winsplit, for instance
16:34:31 <medfly> Cale, you and your monster abilities
16:34:33 <ivanm> Berengal: what's winsplit?
16:34:45 <Berengal> ivanm: "tiling" for windows.
16:34:50 <ivanm> ahhhh
16:34:55 <Axman6> win7 has that
16:34:56 <lpjhjdh> I like the combination of click to focus but scrolling to the window under the mouse
16:35:00 <Axman6> interestingly
16:35:02 <sshc> but tiling window manager's are a much more effective environment in which to work
16:35:07 <mypetclone> I agree with lpjhjdh completely.
16:35:08 <sshc> minus the '
16:35:09 <Cale> I wish that xmonad was a better traditional WM.
16:35:09 <medfly> I hate how windows is really horribly slow on a not too great machine.
16:35:14 <Cale> I don't like tiling WMs at all.
16:35:15 <medfly> HOW MANY FEATURES CAN I KILL
16:35:22 <medfly> WHO THOUGHT OF PUTTING WINDOWS 7 ON NETBOOKS?
16:35:25 <sshc> Cale: why?
16:35:30 <Zao> medfly: Better than Vista on them.
16:35:34 <Berengal> I love tiling WMs, although it might just be the novelty
16:35:34 <medfly> definitely
16:35:45 * Axman6 hugs blackh for the cabal docs tip
16:35:50 <Cale> sshc: Because most windows don't fit usefully into an arbitrary rectangle.
16:36:08 <medfly> at the moment, I have JUST IRC in focus.
16:36:11 <Cale> Tiling window managers are great if all that you run are terminal emulators.
16:36:11 <Berengal> I used tiling in compiz (and winsplit when on windows) for a long time though, and would feel very burdened if I lost the ability to tidy my desktop with my keyboard
16:36:14 <ivanm> Cale: then write one!
16:36:15 <medfly> it's all over the screen. :)
16:36:24 <ivanm> Axman6: which tip?
16:36:27 <benmachine> I run terminal emulators and firefox
16:36:28 <sshc> Cale: for the default xmonad, yes
16:36:31 <benmachine> which gets a workspace to itself
16:36:33 <benmachine> that's about it
16:36:35 <sshc> Cale: I mainly use a non-default layout with xmonad
16:36:50 <ivanm> Cale: I have very few apps that don't play nicely with tiling
16:37:12 <Berengal> Cale: I've found some neat layouts for various workspaces in xmonad. Zoomable grid for web, for example. Much better than tabs
16:37:14 <sshc> Cale: it has a series of tabs at the top, and only shows one window at a time
16:37:20 <Axman6> ivanm: putting documentation: True into your ~/.cabal/config and then reinstalling the packages you want, and visiting file:///<homedir>/.cabal/share/doc/index.html
16:37:31 <ivanm> ahhh
16:37:32 <sshc> Cale: the default xmonad is quite unusable
16:37:38 <sshc> Cale: for my uses at least
16:37:45 <ivanm> yeah, I'm trying to work out a way of doing that for system-installed packages for gentoo
16:37:51 <sshc> Cale: at the very least, it needs the tab layout
16:38:12 <Cale> Mostly, I run firefox and IRC, neither filling the screen completely, and overlapped such that I don't waste screen real-estate on firefox's toolbars while I'm talking on IRC.
16:38:38 <Berengal> I very much want to put linux + xmonad on my multiheaded work computer (of which one screen is 30")
16:38:41 <FauxFaux> Split GNU/screen with irssi and links, gogo.
16:38:50 <Saizan> Axman6: don't you also need doc-index-file: $datadir/doc/index.html ?
16:38:52 <Cale> and then other windows I might have open, I leave little corners peeking out from under those so I have something convenient to click to raise them.
16:39:05 <Axman6> Saizan: nope, seems to work just fine
16:39:36 <sshc> Cale: you usually don't focus other windows with the mouse
16:39:36 <Cale> (I could use the taskbar more, but somehow I often don't care for that as much.
16:39:40 <benmachine> I use vimperator so that I don't waste realestate on toolbars
16:39:45 <Cale> sshc: I do, though.
16:39:51 <benmachine> but I'm considering stopping on the grounds that it's fairly broken in several key ways
16:39:52 <sshc> benmachine: good choice
16:40:07 <sshc> benmachine: I did too, but I use a custom vrome on chromium now
16:40:20 <Cale> Cycling through things is ineffective. Typing the name of an application (Quicksilver-esque) works, but not as well as just pointing at it.
16:40:34 <benmachine> I mean I love being able to open stuff with like four keystrokes
16:40:34 <Berengal> The most effective use of the screen Ḯ've found is based on it just having one thing on it at the same time, and buttons to switch modes
16:40:43 <sshc> Cale: click on the tab, then?
16:40:44 <benmachine> but vimperator regularly makes me >:(
16:40:54 <sshc> benmachine: vimperator is great
16:40:58 <sshc> benmachine: but firefox isn't
16:41:01 <benmachine> like, it's unexpectedly difficult to copy or paste fragments from the address bar
16:41:06 <Berengal> benmachine: Try uzbl
16:41:14 <benmachine> gmail seems to chomp keystrokes at random
16:41:25 <Berengal> benmachine: Although it's possibly even worse, depending on what you hate
16:41:35 <sshc> benmachine: never happens to me
16:41:36 <Cale> The one thing I really hate about gmail is that it binds the / key.
16:41:39 <benmachine> sometimes I have to press escape multiple times, it seems, to exit insert mode (which I'm sometimes placed in by default, without my noticing)
16:41:44 <sshc> benmachine: you probably don't know what passtrhough is?
16:41:44 <shapr> How does cabal look for ghc-pkg?
16:41:58 <benmachine> sshc: I know what it is but I don't always notice when it's necessary
16:41:59 <Berengal> shapr: PATH, I'd guess
16:42:03 <ivanm> shapr: I think it calls it directly...
16:42:11 <ivanm> so yeah, using PATH
16:42:18 <shapr> I grabbed the generic 64-bit binary of ghc 6.12, used update-alternatives to set ghc to /usr/local/bin/ghc ...
16:42:28 <sshc> benmachine: ctrl+z to enter passthrough mode, and then all keys  pressed won't be intercept by vnimperapotr
16:42:57 <sshc> benmachine: btw, I use CTRL+I in text fields to open vim to edit text
16:43:06 <benmachine> sshc: it is more frequently that I am in passthrough that bothers me
16:43:13 <benmachine> and that I don't notice
16:43:34 <Zao> sshc: A god-send.
16:43:36 <Cale> One thing I don't understand is why in recent firefoxes, / and Ctrl-F don't quite do the same thing anymore.
16:43:45 * shapr is confused
16:44:02 <shapr> The correct ghc-pkg is in $PATH, the which command finds it, but Setup does not.
16:44:17 <sshc> benmachine: vimperator is annoying because I practically can't remap escape
16:44:23 <Cale> Ctrl-F, which is harder to type, gives you a more featureful in-page search bar at the bottom. Pointlessly, the bar which / brings up just lacks some controls.
16:44:25 <sshc> benmachine: escape's a bad place for exit
16:44:51 <benmachine> hoe do
16:44:52 <benmachine> er
16:44:53 <benmachine> how so
16:44:55 <ivanm> Cale: AFAIK they never have...
16:45:13 <ivanm> Cale: and I find C-f relatively easy to type...
16:45:21 <sshc> benmachine: similar to the reason it's bad to use arrow keys; it's too bar away
16:45:26 <ivanm> (then again, I made caps lock another control key...)
16:45:34 <sshc> ivanm: me too
16:45:36 <benmachine> sshc: my caps-lock key is an escape :P
16:45:37 <Cale> My caps lock is compose.
16:46:00 <FauxFaux> Backspace!!1
16:46:01 <sshc> benmachine: in which case, that's fine :)
16:46:02 <ivanm> ahhh
16:46:08 <benmachine> caps-lock is a terrible thing to put on that key when you think about it
16:46:15 <sshc> yes
16:46:15 <shapr> cabal does not look in $PATH, strace says it looks in /usr/bin and a few other places. That's weird.
16:46:16 <sshc> but
16:46:17 <benmachine> as if anyone actually wants to lock caps with that ease
16:46:23 <theorbtwo> My caps lock key is caps lock.  I should really fix that.
16:46:27 <sshc> caps-lock is a much better key to put on caps lock
16:46:33 <sshc> or umm
16:46:36 <sshc> control
16:46:39 <benmachine> heh
16:46:40 <shapr> My caps-lock key is hippie-expand
16:46:58 <shapr> Cabal-1.6 can't parse "ghc-pkg dump" from ghc 6.12?
16:46:58 <nadder> I tried installing readline-1.0.1.0 and when I do runhaskell Setup.hs configure --ghc it says readline not found, package cannot be built. Anyone know what's missing?
16:46:59 <FauxFaux> How many of you who have made it to remapping keys use a non-q*ert* layout, ooi? :)
16:47:10 <shapr> Ok, how the heck do I get cabal & cabal-install bootstrapped with 6.12?
16:47:11 <sshc> in vim, I then bound ^Space (control-space) to escape
16:47:15 <FauxFaux> nadder: Readline.
16:47:20 <ivanm> shapr: nope
16:47:24 <Zao> FauxFaux: I'm happy with us-intl-altgr.
16:47:28 <sshc> as long as caps lock is control, it's a really good setup
16:47:32 <ivanm> shapr: hence why there's a new cabal that comes with 6.12
16:47:37 <theorbtwo> I keep accidentally hitting capslock, and being very confused when esc q doesn't take me to window 11 in irssi.
16:47:41 <nadder> FauxFaux, I don't quite follow you.
16:47:41 <ivanm> shapr: as well as a new cabal-install
16:47:52 <FauxFaux> Zao: </subtle Colemak advocacy>
16:47:54 <ivanm> shapr: though now they recommend getting the platform...
16:47:57 <shapr> ivanm: Are they part of the binary ghc package?
16:48:04 <Cale> shapr: Normally it's a good idea to upgrade cabal before you install 6.12, I hear.
16:48:05 <shapr> Platform says it's for ghc 6.10
16:48:06 <ivanm> shapr: cabal is, cabal-install isn't
16:48:15 <ivanm> oh, right, there isn't one yet
16:48:17 <ivanm> duh
16:48:21 <sshc> I also set up my zsh for vi-mode with ^Space as escape
16:48:22 <Cale> shapr: But you should be able to install the new one by downloading it manually from hackage.
16:48:36 <ivanm> shapr: you might have to do manual installation for some ex=extralib libs like network first
16:48:39 <Zao> FauxFaux: Colemak yourself!
16:48:48 <ivanm> or else upgrade cabal-install before upgrading ghc!
16:49:21 <nadder> FauxFaux, what did you mean?
16:49:29 * ivanm -> lunch
16:50:14 <MaciejP> blackh: Ok, I tried it and it generates the docs for every single package, but there is no shared version.
16:50:56 <blackh> MaciejP: You should see every package you've installed (since turning Documentation on) and also the standard libraries on that page
16:51:30 <blackh> I am using cabal-install version 0.7.5 with 1.8.0.1 of Cabal.  Maybe it doesn't work with earlier versions.
16:51:33 <MaciejP> The problem is, there is no "that page"
16:52:04 <nadder> Does anyone know how you install readline-1.0.1.0? It says readline not found, package cannot be built.
16:53:17 <Cale> nadder: Do you have the development package for readline installed? The Haskell package is just a binding to the C library.
16:53:17 <doserj> nadder: you need the corresponding C library and headers.
16:54:31 <nadder> I did download readline 6.1 from gnu page, still the same thing, I just did ./configure make, maybe you need to do something more ?
16:54:51 <MaciejP> blackh: Are you using GHC 6.12?
16:54:53 <blackh> MaciejP: file:///home/<user>/.cabal/share/doc/index.html gets generated when you do a cabal install of a package... You might have got an error message during that process.  Check the output when you install a package
16:54:59 <blackh> MaciejP: I'm using ghc 6.10.4
16:55:04 <sm> nadder: what's your os ?
16:55:11 <monochrom> make install?
16:55:15 <nadder> linuxmint
16:55:17 <sm> but yes, installing that way you probably need to make install
16:55:36 <gwern> @hoogle [a] -> IO [a]
16:55:36 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
16:55:36 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
16:55:36 <lambdabot> Prelude cycle :: [a] -> [a]
16:55:53 <gwern> hm. where can I get meself a random shuffle of a list?
16:56:12 <MaciejP> blackh: No errors. And in cabal there's no subdir "doc"
16:56:20 <gwern> this would be easier if http://www.haskell.org/ghc/docs/latest/html/libraries/base/ hadn't been cut down so much
16:56:20 <nadder> checking for GNUreadline.framework... checking for readline... no
16:56:29 <MissPiggy> :(
16:56:50 <blackh> MaciejP: Has ~/.cabal/config got this line? documentation: True
16:56:54 <Cale> gwern: Maybe somewhere on hackage, but I don't know.
16:57:03 <copumpkin> gwern: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
16:57:08 <gwern> system.random went here: http://hackage.haskell.org/packages/archive/random/1.0.0.2/doc/html/System-Random.html
16:57:23 <MaciejP> blackh: Yes and it generates the docs, but each in a different dir.
16:57:48 <copumpkin> gwern: it doesn't need to live in IO, for what it's worth
16:58:01 <gwern> copumpkin: sure, but Int -> [a] is too generic
16:58:17 <gwern> for the args; lots matches that; relativel little would match [a] -> IO [a]
16:58:21 <monochrom> gwern: http://www.cs.toronto.edu/~trebla/Shuffle.hs
16:58:27 <blackh> MaciejP: After running haddock cabal install says "Registering BerkeleyDB-0.8... ; Updating documentation index /home/blackh/.cabal/share/doc/index.html"
16:58:29 <blackh> Are you seeing htat?
16:58:41 <copumpkin> gwern: did you see oleg's post?
16:58:49 <gwern> looking at it
16:59:08 <gwern> honestly I just wanted to randomize one file from ghci, but if I have to write a module script to do this...
16:59:11 <theorbtwo> Using a completely unqualified type variable on the result of a function without having it match anything else seems strange.
16:59:35 <gwern> also, why the heck am I being directed to emails and random .hss? is there no package for this? :)
16:59:36 <theorbtwo> a -> a, completely natural.  Int -> a?  It takes an integer, and can return *anything whatsoever*?
16:59:46 <MissPiggy> Int -> a doesn't exist
17:00:03 <MaciejP> blackh: Hm, there's no updating documentation index.
17:00:04 <gwern> @hoogle bounds
17:00:04 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
17:00:04 <lambdabot> Data.Graph type Bounds = (Vertex, Vertex)
17:00:04 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
17:00:35 <blackh> MaciejP: What's the output of the command "cabal --version" ?
17:00:52 <gwern> monochrom: that module do be broken
17:01:01 <benmachine> :t let f x = if x == length [] then f x else f (f x)
17:01:02 <lambdabot> <no location info>:
17:01:02 <lambdabot>     not an expression: `let f x = if x == length [] then f x else f (f x)'
17:01:05 <benmachine> :t let f x = if x == length [] then f x else f (f x) in f
17:01:06 <lambdabot> Int -> Int
17:01:10 <MaciejP> blackh: cabal-install version 0.6.2 using version 1.6.0.2 of the Cabal library
17:01:12 <benmachine> hmm
17:01:17 <benmachine> oh of course
17:01:18 <benmachine> silly m
17:01:19 <blackh> MaciejP: Upgrade to 0.7.5
17:01:19 <benmachine> r
17:01:21 <benmachine> er
17:01:22 <benmachine> me
17:01:27 <benmachine> :t let f x = if x == length [] then f x else f x in f
17:01:28 <lambdabot> forall t. Int -> t
17:01:42 <benmachine> a little more redundant this way yes but still
17:03:03 <MissPiggy> > (let f x = if x == length [] then f x else f x in f) 0
17:03:06 <lambdabot>   mueval-core: Time limit exceeded
17:03:12 <McManiaC> > [ x | x <- [1..], 5 >= x/2, x `mod` 2 == 0 ]
17:03:13 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:03:13 <lambdabot>    `GHC.Real.Integral t'
17:03:13 <lambdabot>   ...
17:03:17 <McManiaC> any ideas??
17:03:18 <MissPiggy> :t undefined :: Int -> t
17:03:20 <lambdabot> forall t. Int -> t
17:03:52 <McManiaC> how can I run mod and (/) on the same variable?
17:03:58 <theorbtwo> Hm, actually, there's a simpiler example of the conditions I gave:
17:04:00 <McManiaC> this gotta be possible :O
17:04:01 <theorbtwo> :t undefined
17:04:03 <lambdabot> forall a. a
17:04:26 <theorbtwo> (A nullary function, so a doesn't appear as any of the arguments.)
17:05:14 <copumpkin> why would you call it a nullary function?
17:05:31 <gwern> what
17:05:37 <gwern> there is no Seq a -> [a] function?
17:05:43 <gwern> I must be misunderstanding something
17:06:00 <MissPiggy> gwern who said that?
17:06:06 <theorbtwo> copumpkin: It takes no arguments.
17:06:06 <gwern> MissPiggy: the docs
17:06:08 <copumpkin> it's foldable
17:06:15 <copumpkin> fold (:) into it
17:06:15 <gwern> @hoogle Seq a -> [a]
17:06:15 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
17:06:16 <lambdabot> Prelude repeat :: a -> [a]
17:06:16 <lambdabot> Data.List repeat :: a -> [a]
17:06:24 <copumpkin> theorbtwo: why is it a function at all?
17:06:31 <gwern> oh good, I was just misunderstanding. the foldable typeclass does the work
17:06:51 <monochrom> gwern: Updated.
17:07:07 <theorbtwo> copumpkin: Because all values in haskell are functions.
17:07:13 <gwern> monochrom: sorry, at internet speed, your module's marketshare evaporated and now no one cares
17:07:18 <gwern> they've moved on. why can't you?
17:07:55 <monochrom> What is that supposed to mean?
17:07:59 <copumpkin> theorbtwo: what does that even mean?
17:08:03 <b52> could someone tell me whats wrong with that: http://paste.pocoo.org/show/179526/
17:08:14 <MissPiggy> hmm
17:08:14 <MissPiggy> but I am sure there is...
17:08:27 <gwern> monochrom: I'm using oleg's code now
17:08:48 <copumpkin> theorbtwo: I guess if you view any "nullary function" as () -> x, you could say that. That's how you can stick "values" into Hask, at least
17:08:59 <monochrom> And somehow using oleg's code gives you the right to insult me?
17:09:05 <theorbtwo> There's no difference in haskell between 4, and a function that takes no arguments and returns 4.
17:09:15 <doserj> b52: you cannot use / and mod on the same type
17:09:16 <copumpkin> wow, this is unpleasant
17:09:34 <copumpkin> theorbtwo: ...
17:09:57 <doserj> b52: / is for fractional types, like Float and Double. mod is for integral types, like Int, Integer
17:10:23 <b52> ok, the / part should be an integer
17:10:25 <MissPiggy> theorbtwo, can you show me a function that takes no arguments?
17:10:33 <b52> i tried to use floor x/2 but that didnt work as well
17:10:34 <Cale> div is a better comparison with / than mod is
17:10:35 <gwern> monochrom: the second one was a quote
17:10:40 <theorbtwo> MissPiggy: foo = 4
17:10:46 <MissPiggy> that's not a function
17:10:47 <benmachine> undefined is a binary function
17:10:48 <copumpkin> theorbtwo: and why is it a function?
17:10:52 <benmachine> > undefined 7 6
17:10:53 <lambdabot>   * Exception: Prelude.undefined
17:10:55 <benmachine> see
17:10:56 <doserj> b52: integer division is called div
17:10:57 <MissPiggy> foo :: Integer, it's not got an (->) in it
17:10:57 <gwern> monochrom: but if you do not appreciate my allusive style of humor then carry on as you were
17:11:37 <copumpkin> sure, it's isomorphic to () -> Integer
17:11:48 <MissPiggy> wait monochrom do you own Seq?
17:11:50 <monochrom> "a quote" is not mutually exclusive to insult. and your humour is at my expense.
17:12:00 <copumpkin> it's like saying 5 is an exponential because it's 5^1
17:12:11 <copumpkin> true, but not very interesting
17:12:30 <MissPiggy> theorbtwo but why would you call it a function I don't understand
17:12:49 <monochrom> I don't own Seq.
17:12:51 <gwern> MissPiggy: no, monochrom offered me a module of his to randomize lists, but it was broken due to array modules changing, and in the time between I told him that and he uploaded the fixed version, I had moved on to use oleg's code instead
17:12:52 <dolio> copumpkin: They're not isomorphic in Haskell.
17:13:01 <MissPiggy> ah
17:13:05 <theorbtwo> MissPiggy: It's as far as you can reduce a type that appears as the result, but none of the arguments, of a function.
17:13:08 <copumpkin> dolio: I like to ignore bottoms
17:13:39 <theorbtwo> Any type appearing as the result of a function that takes no arguments does not appear as any of the arugments.
17:13:50 <MissPiggy> theorbtwo, you mean like if you have a list of types [a,b,c] and a target x, then the function is a -> b -> c -> x, and if the list happened to be [] then you'd just have x?
17:13:52 <dolio> We can rule out your being Sir Mix-a-lot, then.
17:14:03 <copumpkin> theorbtwo: where did you get your definition of function?
17:14:25 <theorbtwo> copumpkin: Real World Haskell, in this particular case, I could have sworn.
17:14:37 <MissPiggy> theordtwo, it seems like a throwback to uncurried times
17:14:40 <ksf> does anyone know of a general-purpose xml-rpc client?
17:14:41 <copumpkin> I haven't read it, but I doubt it talks about nullary functions
17:14:42 <MissPiggy> you know like having
17:14:49 <MissPiggy> int foo(char a, baz b)
17:14:53 <MissPiggy> and that sort of thing
17:14:55 <ksf> one that just introspects a server and lets me call whatever I want?
17:14:57 <copumpkin> in haskell we typically just call anything those type involves a (->) a function
17:15:22 <MissPiggy> copumpkin, well US TWO do, but a LOT of people seem to talk about 0-ary functions and I wonder why
17:15:45 <copumpkin> well, in other languages with slightly more lax definitions of functions, you can write f()
17:15:48 <MissPiggy> my guess is because it helps you translate back to whatever uncurried language you learned before haskell
17:15:51 <Draconx|Laptop> MissPiggy, maybe they're confusing Haskell with Prolog?
17:16:03 <theorbtwo> Naturally it does.
17:16:05 <MissPiggy> I don't think prolog in particular, do you?
17:16:27 <copumpkin> what's nice about that f() thing
17:16:33 <Cale> I suppose you can have 0-ary *relations*
17:16:34 <gwern> if I were a good doobie, I'd take oleg and monochrom's code and stick it up on hackage. alas, I am not
17:16:35 <copumpkin> is that you can write f () = 5
17:16:40 <copumpkin> it's a value, and a nullary function! :P
17:16:41 <theorbtwo> However, in a pure world, a nullary function must always return the same thing.
17:16:46 <MissPiggy> it's also trick yto think of an uninstantiated variable as a 'value' unless you accept that functions are values too -- but Integer is a value so it must be a function too?
17:16:47 <Draconx|Laptop> MissPiggy, well, people actually use the term "0-ary" in prolog; I've not heard it used in other languages.
17:16:48 <theorbtwo> copumpkin: Precisely.
17:16:52 <copumpkin> and ignoring bottoms, it's isomorphic to 5
17:16:58 <MissPiggy> Draconx|Laptop: ah that's just me using prolog terminology
17:17:09 <copumpkin> > let f() = 5 in f() -- whee
17:17:10 <lambdabot>   5
17:17:42 <MissPiggy> > let f(x) = x in f(3)
17:17:43 <lambdabot>   3
17:18:01 <dolio> Wouldn't a 0-ary relation just be a truth-value?
17:18:08 <mlh> how do you pronounce 0-ary?
17:18:09 <Draconx|Laptop> Cale, one can also talk of 0-ary *operators*, but these are functions from 1 to S for some set S.
17:18:18 <dolio> Zero-airy.
17:18:20 <mlh> not null-ary?  -- perhaps nought-ary
17:18:24 <mlh> oh
17:18:28 <Draconx|Laptop> mlh, nullary, usually.
17:18:31 <copumpkin> http://www.cs.nott.ac.uk/~nad/listings/lib/Relation.Nullary.Core.html#327
17:18:36 <dolio> Nullary would be better.
17:19:00 <mlh> I thought someone was drawing a distinction between nullary and 0-ary.    Ignore me.
17:19:21 <theorbtwo> The problem is that you use latin for these, and there is no number zero in latin.
17:19:52 <Draconx|Laptop> "0-ary" being "nullary" is not any different from "1-ary" being "unary" and "2-ary" being "binary".
17:20:05 <MissPiggy> so it's just ordinal vs cardinal?
17:20:29 <MissPiggy> anyway I still don't know what the 'right answer' about 0ary functions is
17:20:32 <MaciejP> blackh: Where can I find the 0.7.5? I can't get it out of the darcs repo.
17:20:37 <MissPiggy> if a function takes no argument is it still a function?
17:20:47 <MissPiggy> maybe it's just a tree-falls-in-a-forest question
17:20:53 <gwern> what is the sound of one argument evaluating?
17:21:07 <copumpkin> "lonely, I am so lonely"
17:21:08 <Cale> MissPiggy: no. But it might be a function from a one-element set, which is as good as a nullary function.
17:21:30 <theorbtwo> I wonder...
17:21:32 <theorbtwo> :t ()
17:21:33 <lambdabot> ()
17:21:38 <theorbtwo> Fair enough.
17:21:39 <blackh> MaciejP: I thought I got it from hackage, but looks like it's only 0.6.4 on hackage. Try 0.6.2 with cabal install cabal-install
17:22:05 <copumpkin> :t 1
17:22:06 <lambdabot> forall t. (Num t) => t
17:22:10 <copumpkin> :k 1
17:22:11 <lambdabot> *
17:22:14 <Cale> A function is a triple of sets (A,B,G), where G is a subset of AxB such that for any a in A, there is exactly one b in B for which (a,b) is in G.
17:22:22 <copumpkin> I still don't understand why that was added
17:22:47 <blackh> MaciejP: I just tried 0.6.4 and... It doesn't do it - so it looks like you do need the really new version
17:22:48 <Cale> When (a,b) is in G for some function f, we write f(a) = b
17:22:54 <copumpkin> and why it doesn't have a LANGUAGE pragma dedicated to it at least
17:23:23 <Cale> A is called the domain, B the codomain, and G the graph of the function.
17:23:51 <blackh> MaciejP: Try darcs pull http://darcs.haskell.org/cabal-install
17:23:58 <MissPiggy> Cale but in the context of computing what about _|_ and posets?
17:24:07 <blackh> MaciejP: (This works for me)
17:24:14 <copumpkin> Cale: why do you need to explicitly list the domain and codomain if G contains tuples of them anyway?
17:24:27 <Cale> MissPiggy: Well, you have fancier structures to express which functions are computable/definable.
17:24:28 <MaciejP> blackh: Is this the latest version?
17:24:38 <Cale> copumpkin: You can't determine the codomain from the graph
17:24:48 <Cale> copumpkin: You could determine the domain though.
17:24:49 <blackh> MaciejP: Yes - Cabal 1.8.0.2 is on hackage, so use that:  cabal install Cabal
17:25:03 <theorbtwo> Cale: A nullary function has exactly one element in A, for which there is exactly one coorosponding element in B.  No problem.
17:25:09 <Cale> theorbtwo: yeah
17:25:17 <copumpkin> Cale: why not?
17:25:30 <blackh> MaciejP: I am trying the latest cabal-install from the darcs repo above + 1.8.0.2 now
17:25:37 <dolio> copumpkin: Because you can't reconstruct it by looking at the pairs in G.
17:25:48 <Cale> copumpkin: Because the function might not be surjective. That is, there's no requirement that for every b in B there is some a in A for which (a,b) is in G.
17:26:07 <copumpkin> oh, but this gets back to the seemingly lax definition of codomain?
17:26:11 <MaciejP> blackh: I tried the 0.8.0 version but it needs base 4.2.
17:26:20 <theorbtwo> Cale: Er... um... why not?
17:26:21 <MissPiggy> how does this mathematical definition relate to haskell?
17:26:35 <theorbtwo> What does allowing such a thing buy you?
17:26:40 <Cale> theorbtwo: because we want, for example, constant functions to be functions.
17:26:51 <MissPiggy> if f : A -> B, then f(A) <= B
17:26:57 <copumpkin> Cale: surjective seems like an odd concept to me in the first place
17:26:58 <MissPiggy> but it is not necessarily equal to B
17:27:07 <lpjhjdh> MissPiggy: Denotational Semantics by Stoy does a good job of building up machinery to talk about bottom in a function space
17:27:21 <monochrom> You have B because you don't have dependent types.
17:27:32 <blackh> MaciejP: Hmm - the darcs version requires Cabal 1.9 too
17:28:01 * copumpkin is confused :)
17:28:07 <MissPiggy> lpjhjdh too bad it's not online but I will keep an eye out for it :)
17:28:19 <monochrom> Dependent types allow you to write f: (x:A) -> {f(x)}
17:28:33 <Cale> copumpkin: Consider colouring some set of objects A, each with some paint chosen from a set B.
17:28:41 <MissPiggy> I am not sure why people write f : A -> B rather than f \in A -> B either
17:28:53 <copumpkin> Cale: I mean, I know what surjective means, I just see the notion of a codomain to be strange
17:29:04 <Cale> copumpkin: It's necessary to form a category.
17:29:16 <copumpkin> yes, but we're very lax with it?
17:29:21 <Cale> copumpkin: lax?
17:29:27 <copumpkin> not strict :P
17:29:27 <Cale> How are we lax with it?
17:29:29 <dolio> MissPiggy: Because they're doing type/category theory instead of set theory?
17:29:43 <copumpkin> what is the codomain of your typical high school parabola whose domain is the reals, y=x^2?
17:29:50 <Cale> R.
17:29:58 <Cale> All the functions in highschool have codomain R.
17:29:59 <copumpkin> why?
17:30:04 <Cale> Highschool mathematics sucks.
17:30:07 <copumpkin> I mean
17:30:09 <Cale> You should disregard it.
17:30:11 <copumpkin> why is it not nonnegative reals?
17:30:14 <monochrom> highschool lacks dependent types
17:30:19 <MissPiggy> dolio even in set theory people use :
17:30:20 <lament> i'm with copumpkin
17:30:24 <lament> what exactly does codomain mean?
17:30:30 <lament> some random superset of the image?
17:30:37 <dolio> Well, set theory people are crazy.
17:30:38 <Cale> copumpkin: You can't really determine the codomain from that equation.
17:30:39 <MissPiggy> lament arbitrary
17:30:43 <MissPiggy> it's like abstract evaluation
17:30:45 <Cale> copumpkin: You can't determine the domain either.
17:30:49 <copumpkin> Cale: I'm just saying
17:30:54 <copumpkin> the idea of having a surjective function
17:30:58 <copumpkin> or a non-surjective one
17:30:59 <MissPiggy> dolio lol
17:31:10 <Cale> If you're going to define a function according to some equation, you *must* specify the domain and codomain explicitly.
17:31:10 <copumpkin> is saying "this function covers some named set that I picked"
17:31:22 <copumpkin> or "this function doesn't cover all the values of some named set that I say is its codomain"
17:31:28 * QtPlatypus did some highschool maths with functions R->C and C->C
17:31:29 <monochrom> math people are well-known for evolved ad-hoc notation
17:31:30 <Cale> If you just say f(x) = x^2, I can't tell what the domain is, let alone the codomain.
17:31:31 <MissPiggy> copumpkin, it's like in haskell when you have variables
17:31:48 <copumpkin> all I'm saying is that the domain and codomain could be fully determined by the graph of the function, if you didn't define it the way you do
17:31:49 <copumpkin> :P
17:31:53 <theorbtwo> Cale: It's high school algebra.  The domain is R unless stated otherwise.
17:31:57 <QtPlatypus> And two functions that where (R->R) -> (R->R)
17:31:57 <Cale> QtPlatypus: You went to a marginally better highschool ;)
17:31:58 <lament> f(x)=x is not surjective on R U {apple} :(
17:32:08 <copumpkin> lament understands me
17:32:11 * copumpkin cries with lament
17:32:17 <MissPiggy> copumpkin, it's better than having to explicitly apply the INST rule _everywhere_, so it is better to have f : A -> B than having to lift f the output of f up to B
17:32:17 <lament> i mean f(x) :: R -> R U {apple}
17:32:23 <monochrom> Oh, highschool sucks beyond that. It's full of "f(x)=1/x what is the domain???!!!!"
17:32:25 <theorbtwo> The range is therefore nonneg R.  What is the codomain?  Null.
17:32:26 <Cale> copumpkin: We define it this way because this is the useful concept.
17:32:31 <Saizan> MaciejP: cabal install "cabal-install >= 0.8.0" should work on 6.10.x
17:32:33 <medfly> huh?
17:32:39 <medfly> my high school had complex numbers.
17:32:40 <blackh> MaciejP: If I install darcs versions of Cabal and cabal-install using ghc 6.10.4 then everything works.
17:32:43 <dolio> monochrom: I'm not familiar with any dependently typed languages that will let you write something like 'f : (x:A) -> {f(x)}', unless you have some way of characterizing {f(x)} that doesn't reference f.
17:32:46 <copumpkin> Cale: but it seems arbitrary to define it in a way that we cannot compute
17:32:47 <medfly> what do I win?
17:32:57 * MissPiggy feels like I said something correct and hopes to get confirmed or have it defeated by reason
17:33:07 <Cale> I think we did some things with complex numbers in highschool without really talking much about complex functions.
17:33:08 <lament> MissPiggy: i agree. I said something correct.
17:33:18 <Cale> copumpkin: hm?
17:33:19 <theorbtwo> medfly: So did mine, but only during that chapter.
17:33:31 <copumpkin> Cale: the codomain of f(x) = x^2, where domain is R, is R, because you say so. And because you say it's R, the function is not surjective. Had you said that it was R_nonnegative, it would be surjective.
17:33:32 <theorbtwo> If the domain was supposed to be complex numbers, they told you.
17:33:32 <MissPiggy> dolio in set theory I write  f(A) to mean {f(x)|x in A}
17:33:37 <blackh> MaciejP: The repos are http://darcs.haskell.org/cabal and http://darcs.haskell.org/cabal-install respectively
17:33:39 <Cale> copumpkin: sure.
17:33:42 <medfly> is it that important that they should have mentioned more?
17:33:45 <Cale> copumpkin: Those are all different functions.
17:33:57 <Cale> copumpkin: and which functions you're allowed to compose depends on this
17:34:06 <Saizan> blackh: you shouldn't need the darcs version for the user index
17:34:07 <medfly> mathematics is like, "everything mathematics is important enough to be taught!"
17:34:12 <monochrom> I admit that I haven't seen anything that allows f : (x:A) -> {f(x)} unabridged.
17:34:15 <MissPiggy> and it is always the case taht f(A) <= B -- that <= (subset) is very useful, just like implicit instantiation of polymorphic functions is useful
17:34:20 <Saizan> blackh: cabal-install-0.8.0 suffices
17:34:20 <medfly> no prioritisation
17:34:22 <tomberek> hi Cale,Saizan,moochrom,MissPiggy
17:34:22 <Cale> In order to compose two functions f: A -> B and g: C -> D, to form g . f, you must have that B = C.
17:34:25 <tomberek> et al.
17:34:25 <MissPiggy> hi
17:34:39 <theorbtwo> Er... why?
17:34:40 <copumpkin> Cale: I'm just wondering why it's useful to define a function as something that carries an extra bit of information, its codomain, when it could be fully determined by its graph if defined as such (composition would still work, with what I'm going to call the _strict codomain_)
17:34:44 <Cale> and so the codomain of f must match the domain of g.
17:34:44 <theorbtwo> Yes.
17:34:53 <theorbtwo> Both those are domain and range, not domain and codomain.
17:35:01 <MissPiggy> copumpkin -- I explained why :[
17:35:06 <Cale> copumpkin: Composition doesn't work right otherwise.
17:35:08 <blackh> Maciej: And dcoutts has *STILL* not applied my patch to cabal install.
17:35:19 <blackh> MaciejP: ^^
17:35:35 <Cale> copumpkin: The collections of arrows forming a category are supposed to be disjoint.
17:35:41 <theorbtwo> Codomain is about where the inverse is still a function, and most of the time, you just don't care.
17:35:46 <copumpkin> MissPiggy: I didn't understand INST, sorry :(
17:35:52 <MaciejP> blackh: what patch?
17:35:56 <tomberek> anyone willing to chat about arrows, comonads, and dataflow?
17:36:00 <copumpkin> Cale: ah
17:36:04 <Cale> copumpkin: Here's another way to look at it.
17:36:08 <MissPiggy> copumpkin well it's a rule for hindly milner type system you damn well do know it :P
17:36:15 <blackh> MaciejP: It's a long story. It's for ticket #89.
17:36:26 <Cale> copumpkin: You can think of a function as a partition of the domain into sets, one for each member of the codomain.
17:36:36 <Cale> copumpkin: If all of these sets are nonempty, the function is surjective.
17:36:51 <Cale> copumpkin: If each of the sets has at most one element, the function is injective.
17:37:00 <copumpkin> I see that
17:37:08 <Cale> If all the sets have exactly one element, the function is bijective (and hence invertible)
17:37:34 <Cale> So, it's a bit unnatural to always restrict yourself to nonempty sets there.
17:37:43 <copumpkin> I still can't help feeling that the definition of codomain is fairly arbitrary. All you really need for composition is for the domain of your outer function to be a superset of the range/strict codomain of the inner one
17:37:51 <Cale> But we have a convenient word for when you want that.
17:38:06 <medfly> Cale, I have the urge to scream that it's off-topic :)
17:38:15 <Cale> Maybe it's just the definition of function which makes the codomain *seem* a bit arbitrary.
17:38:24 <Cale> But choosing an equivalent one we can do better.
17:39:08 <dolio> Just take functions as primitive, like in ETCS.
17:39:27 <MissPiggy> what is ETCS?
17:39:32 <dolio> Now you can't ask any questions. :)
17:39:39 <dolio> The Elementary Theory of the Category of Sets.
17:39:42 <MissPiggy> oh
17:39:50 <dolio> Lawvere's set theory.
17:39:50 <MissPiggy> is that like sets for mathematics?
17:39:56 <MissPiggy> ah I know this guy
17:40:36 <MissPiggy> medfly functions, in A functional programming channel?
17:40:58 <theorbtwo> Cale: The thing is that the definition of a function that I'm familiar with goes "a function is a mapping from a set of possible inputs, A, to a set of outputs, B, such that each element of B has exactly one element of B that maps to it."
17:41:09 <Cale> For example, a function f is a triple (A,B,P) where P is a subset of B x 2^A such that for each b in B, there is exactly one set S in 2^A such that (b,S) is in P, and such that the various S are pairwise disjoint, and their union is A.
17:41:39 <Rotaerk> so many such-that's
17:42:10 <Cale> Yeah, sorry about the stilted mathematician-speak :)
17:42:35 <MissPiggy> it's hard to write mathematics in a very fluent way
17:42:38 <theorbtwo> A codomain simply isn't neccessary -- A is the domain, B is the range, and we are done.
17:42:39 <Draconx|Laptop> mathematics is the art of finding different ways to write "therefore".
17:42:51 <MissPiggy> at one end you just have wordy fluff, and the other you have cold steel symbolc logic
17:42:52 <Cale> That is, a function is a partition of the domain into disjoint subsets indexed by the codomain.
17:43:05 <tomberek> anyone? comonads as a way to to reason about dataflow?
17:43:11 <Cale> theorbtwo: It is if you want to compose functions properly.
17:43:12 <MissPiggy> I tried to stike a good point between and people complain about not writing 'forall' enough :/
17:43:22 <MissPiggy> but he was drunk and I don't know if I really wrote a bad proof or not
17:43:46 <Cale> theorbtwo: Consider something like f: R -> [0,inf), f(x) = x^2
17:44:00 <Cale> theorbtwo: I can't compose this function with itself.
17:44:13 <Cale> theorbtwo: because its codomain doesn't match its domain.
17:44:19 <monochrom> I use "with" in place of "such that". Hell, generally, I write "for all x: ..." and "exists x: ...", i.e., use colon symmetrically.
17:44:38 <xerox> (not a partition in the tecnical sense though, or you're not getting non-surjetive functions)
17:44:55 <monochrom> @remember Draconx|Laptop mathematics is the art of finding different ways to write "therefore".
17:44:55 <lambdabot> Done.
17:45:02 <Cale> xerox: a partition into possibly empty parts
17:45:45 <theorbtwo> Cale: Sure you can.  f(x), for any real, is a nonnegitive real.  A nonnegitive real is in the domain, f(f(x)) is legal.
17:46:07 <theorbtwo> (And (f . f)(x) is just a confusing way of writing f(f(x))
17:46:18 <dolio> tomberek: What about it? I've read a paper or two on it.
17:46:24 <dolio> By Uustalu and Vene, I think.
17:46:25 <Cale> theorbtwo: In a category, in order for the composite of two arrows f and g to be defined, the domain of one has to match the codomain of the other.
17:46:52 <copumpkin> I guess the main advantage of The Definition over what I'm "proposing" is that it's a lot cleaner
17:46:54 <theorbtwo> Cale: I'm sorry, I hought we were speaking about sets and functions.
17:46:56 <tomberek> dolio: i'm trying to wrap my brain around them... what helped you understand them?
17:47:07 <Cale> theorbtwo: It's important that sets and functions form a category.
17:47:21 <dolio> tomberek: Comonads? Or dataflow?
17:47:23 <Cale> theorbtwo: Domain and codomain are categorical concepts.
17:47:56 <Saizan> the idea seems to be that subtyping sucks :)
17:48:11 <copumpkin> I guess that's a succinct way of putting it :)
17:48:28 <tomberek> dolio: comonads,, (well, both/either).  I was thinking of using them for the computations through a graph structure
17:48:35 <copumpkin> that's more or less what I was arguing for
17:49:02 <Cale> There are some people who like to deal with partial functions for some reason too
17:49:10 <theorbtwo> I'm afraid that if you need to bring categories and arrows into the discussion, then I can't continue it.
17:49:25 <Cale> theorbtwo: Well, the basic definition of a category isn't *so* bad :)
17:49:34 <copumpkin> even I understand it!
17:49:39 <Draconx|Laptop> copumpkin, try defining "group homomorphism" if you require that functions be surjective.
17:49:59 <Cale> hehe
17:50:04 <copumpkin> I can see how it would get ugly very quickly
17:50:28 <theorbtwo> Cale: If functions are a subset of categories, then what requirement of functions do you not need to be a category?
17:51:22 <Cale> theorbtwo: lots... basically categories capture the basic properties of composition of functions, without the part where you're applying functions to values to get other values
17:51:39 <theorbtwo> Oh.
17:51:45 <theorbtwo> Right...
17:51:47 <Cale> You just have arrows between objects, and some fashion in which they can be composed.
17:52:02 <Cale> But they might not have any "internal structure"
17:52:07 <copumpkin> so the minimal useful definition of a function is a tuple with codomain and graph?
17:52:09 <dolio> tomberek: I don't know. The dataflow papers are okay. sigfpe has an article on cellular automata (and certain zippers in general) as comonads...
17:52:17 <Cale> copumpkin: yeah
17:52:39 <theorbtwo> This it the source of the great insanity of pointless style.
17:52:45 <Cale> copumpkin: At least in terms of sets.
17:52:49 <copumpkin> yeah :)
17:52:58 <copumpkin> I guess constructively, I'd need a triple
17:53:04 <theorbtwo> To be slightly more serious, I see enough people pushing it that I assume it does actually have some merit...
17:53:10 <dolio> I've also read an article on their relation to attribute grammars that may have helped some, although I understand attribute grammars less than comonads.
17:53:13 <Cale> It's nice to have a triple with the domain there as well, just for convenience.
17:53:23 <MissPiggy> constructively?
17:53:25 <copumpkin> and you can't write it in agda without the domain there too
17:53:28 <theorbtwo> ...but I certianly cannot see what that merit might be.
17:53:35 <Cale> theorbtwo: points-free style is good for the same reason unix pipelines are good
17:53:58 <ManateeLazyCat> I need transform some IORef code to concurrent version, someone compare MVars and TMVars, which is better? Thanks.
17:54:03 <theorbtwo> Cale: Except with a pipeline, you don't loose sight of the fact that you put data in one end and it comes out the other.
17:54:16 <MissPiggy> you could define  Function = Set x \A -> Set x \B -> (A -> B)  ?
17:54:20 <Cale> theorbtwo: You avoid giving names to things which don't deserve names, and it makes the code more readable. Of course, not giving names to things which *do* deserve them becomes a problem.
17:54:29 <Cale> theorbtwo: That's the case with functions as well...
17:54:30 <MissPiggy> which is a dependent triple
17:54:44 <copumpkin> MissPiggy: that's what I'm talking about :)
17:54:45 <tomberek> dolio: yes, i've read the first two you mention... still fuzzy
17:54:51 <MissPiggy> (it's basically  exists A : Set, exists B : Set, A -> B  in a less readible way)
17:55:01 <copumpkin> MissPiggy: except was talking about the graph
17:55:20 <MissPiggy> you want to do set theory in agda?
17:55:27 <copumpkin> nope
17:55:39 * copumpkin doesn't know any set theory anyway
17:55:50 <dolio> tomberek: The underlying theme of all those is that you can write functions that look around some local area, and automatically extend them to everywhere in a tree.
17:55:53 <ManateeLazyCat> When time use MVars, when time use MVars?
17:56:14 <dolio> Which is probably the point of the paper 'The Dual of Substitution is Redecoration,' which I still need to read.
17:56:31 <dolio> It being about free monads and cofree comonads, I think.
17:56:40 <Cale> ManateeLazyCat: yes?
17:57:07 * copumpkin goes poof
17:57:08 <tomberek> dolio: i need to find that i guess... i just don't have the intuition on them yet,  Though I'm still relatively new to monads and haskell as a whole too!
17:57:10 <c_wraith> ManateeLazyCat: STM is better when you can update two different bits of state without conflicting.  If you have only a single piece of state, an MVar is better
17:57:11 <Cale> Set theory is really the theory of strange trees.
17:57:30 <ManateeLazyCat> Cale: I want know different between MVars and TMvars, and when time use them.
17:57:31 <ivanm> :o
17:57:33 * theorbtwo shrugs.
17:57:47 <theorbtwo> Set theory seems pretty intuitive to me.
17:57:53 <dolio> tomberek: Some comonads don't fit that model very well, though, I think. Like reader and state-in-context.
17:57:56 <theorbtwo> This may well be because I don't know enough of it.
17:58:04 <Cale> ManateeLazyCat: TMVars are just like MVars, but they're accessible from STM transactions, and instead of operations blocking, you get a retry.
17:58:05 <ManateeLazyCat> c_wraith: I saw some paper said STM implementation is not complete.
17:58:12 <MissPiggy> hehe
17:58:18 <MissPiggy> theory of strange trees
17:58:30 <c_wraith> ManateeLazyCat: I'm unaware of any way in which STM is incomplete.
17:58:42 <Cale> ManateeLazyCat: It's possible to improve the STM implementation, but the one which is in GHC is usable, and reasonably complete.
17:58:49 <dolio> Well, I guess reader is just a particular cofree comonad, but...
17:59:33 <tomberek> dolio: what I want is a way to manipulate the computations of a neural network.  I was thinking each neuron could be a stream and then I read that paper on dataflow and comonads.... am i on the right track?
17:59:41 <Adamant> what's the dual of coffee then? ffee?
17:59:56 * Adamant ducks
18:00:22 <theorbtwo> No, "co".
18:00:36 <Cale> It's either ffee, or cocoffee
18:02:50 <Cale> tomberek: Usually I just take graph structures and encode them using Data.Map and Data.Set
18:03:30 <ManateeLazyCat> Cale: retry? So when i use putTMvar, it still will block thread until some thread read TMvar?
18:03:38 <Cale> (a graph is roughly a map from vertices to sets of vertices, potentially labelled with other stuff)
18:03:52 <Cale> ManateeLazyCat: yeah
18:03:54 <MissPiggy> I want to implement all my algorithms in Coq with correctness proof (for this algebra system I write in haskell)
18:04:09 <dolio> tomberek: So, the neurons are time-varying? For training or something?
18:04:18 <Cale> ManateeLazyCat: Unless you have an orElse with some other alternative to take.
18:04:19 <MissPiggy> but I am not brave :(
18:04:20 <tomberek> Cale: there is an implementation in the fgl package which seems pretty good, or would you suggest writing my own?
18:04:34 <MissPiggy> (that is probably why I want to do it too..)
18:04:36 <Lemmih> ManateeLazyCat: Only if the TMVar is full, I think.
18:04:46 <Cale> tomberek: Depends which algorithms you need. Usually I find working directly with Map and Set not too bad.
18:05:02 <MissPiggy> I wonder what is wise to do
18:05:08 <tomberek> dolio: trying to write a library.  So: all of the above.  I'd like it to be easily extendible.
18:05:16 <MissPiggy> it is very hard to decide about long-term aspects of writing a program
18:05:38 <medfly> MissPiggy, premature optimisation?
18:05:42 <Cale> tomberek: If you want to implement a generic library which is independent of the graph representation, I recommend taking the requisite functions as parameters (things like the function which determines the neighbours of a vertex in the graph)
18:06:05 <MissPiggy> medfly what do you mean
18:06:11 <medfly> never mind
18:06:21 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
18:06:35 <Cale> Oh, the haddock there is a bit messed up
18:06:41 <Cale> let me see if the older version is better
18:06:42 <MissPiggy> :(
18:06:43 <dolio> tomberek: I've not really done any dataflow programming. Most of my experience with it is with regard to those papers on comonads. So, I don't know what its strengths would be with regard to neural networks.
18:06:57 <Cale> Nope, it's systemic :P
18:07:26 <Cale> but even though the parameters' descriptions are shifted a bit, and the first one dropped, you get the idea
18:07:35 <ManateeLazyCat> If i transform from IORef to MVar, it's easy, because it still in IO Monad, if i use TMVar, i need change IO Monad to STM Monad.
18:07:44 <Cale> http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/src/Data-Graph-AStar.html#aStar -- here, better :)
18:07:53 <lpjhjdh> MissPiggy: Isar is more attractive than the unreadable filth that are tactics :p
18:07:59 <tomberek> Cale, yes, that's probably the way I will go...
18:08:13 <tomberek> dolio: ok... thanks
18:08:25 <lpjhjdh> but no dependent types :(
18:08:27 <MissPiggy> lpjhjdh, cool I am looking it up now
18:08:47 <MissPiggy> lpjhjdh -- what do you think I should do? :)
18:09:11 <MissPiggy> oohh google suggests "An Idealistic Formalization of Stokes' Theorem" that sounds fun
18:09:31 <tomberek> Cale: I've seen that, but don't know what the requisite paramaters are... so I'm writing examples and trying to see what is most general
18:11:39 <bnijk_> i don't know where elso to go - does anybody know how to use flex and yacc
18:11:45 <bnijk_> i'm about to claw my eyes out
18:11:58 <MissPiggy> bnijk_ in ocaml or C? or what?
18:12:04 <ivanm> this is great: the first day of my phd where I have a desk and a computer I can use (since the new PhD room isn't ready yet)... and yet my supervisor still hasn't shown up today :s
18:12:06 <bnijk_> C
18:12:13 <monochrom> I am sorry, I actually quite enjoy not knowing flex or yacc.
18:12:17 <lpjhjdh> sadly there are a number of things that just aren't that conveniently representable without reasonably complex typeclass systems or dependent types, but having not implemented a computer algebra system I can't (confidently) give intelligent suggestions
18:12:18 <MissPiggy> bnijk_ to be quite honest I would write it in ocaml then TRANSLATE back to C
18:12:20 <bnijk_> and don't say ##c - i'm inexplicably banned from it
18:12:25 <bnijk_> mmn
18:12:31 <ivanm> monochrom: heh
18:12:45 <MissPiggy> lpjhjdh: CAS is probably the wrong word for my program by the way
18:12:56 <MissPiggy> bnijk_: I didn't say ##C
18:13:09 <MissPiggy> bnijk_: but you are right that asking here is the wrong place
18:13:12 <bnijk_> i know, i was telling you not to say it
18:13:17 <bnijk_> where should i go
18:13:20 <MissPiggy> bnijk_: SO I agree with you that it is a bad place to ask
18:13:38 <ManateeLazyCat> Thanks all. :)
18:13:50 <Philippa> I think there's a ##compilers and perhaps a ##parsers to be had, you could try there
18:14:14 <MissPiggy> ivamn what are you PhDing on?
18:15:31 * bnijk_ goes there
18:16:14 <theorbtwo> Lex and yacc are a pain in the ass.
18:16:18 * theorbtwo <3s parsec.
18:16:26 <sm> me too
18:16:35 <bnijk_> no choice unfortunately
18:16:47 <MissPiggy> theorbtwo I found them great in ocaml
18:16:51 <theorbtwo> I haven't had extensive experince with it, mind, but so far I like what I see.
18:17:20 <ivanm> bnijk_: why are you banned?
18:17:28 <bnijk_> god ivanm i don't know
18:17:30 <ivanm> MissPiggy: combinatorial algorithms
18:17:33 <bnijk_> i'm banned from half the channels on this network
18:17:39 <ivanm> bnijk_: can't even ping one of the ops to ask?
18:17:40 <ivanm> heh
18:17:53 <bnijk_> freenode isn't very free
18:17:54 <MissPiggy> ivanm oh cool!
18:17:56 <theorbtwo> Parsec makes me happy that my own parsing library is vaugely similar in some respects.
18:18:06 <theorbtwo> ##C is full of assholes much of the time.
18:18:16 <lament> not since i stopped going there!"
18:18:27 <MissPiggy> lol
18:18:45 <Philippa> if there's one thing you can say for lament, it's that he's a /self-aware/ asshole
18:18:46 <monochrom> My final stage of learning monad was through a precedessor of parsec, you know, the String -> [(a,String)] kind.
18:18:46 <theorbtwo> lament++
18:19:46 <theorbtwo> (Wait.  I'm not allowed to do that on this channel, that requires mutation...)
18:19:55 <bnijk_> did i really just find a tutorial for this...thank god
18:19:55 <Cale> nah, it works
18:20:00 <Cale> @karma lament
18:20:01 <lambdabot> lament has a karma of 3
18:20:05 <Cale> lament++
18:20:06 * ivanm sighs and goes back to hacking on graphviz
18:20:07 <Cale> @karma lament
18:20:07 <lambdabot> lament has a karma of 4
18:20:11 <bnijk_> do any of you listen to folk music
18:20:13 <lament> \o/
18:20:18 <bnijk_> i'm a folk musician...
18:20:26 <theorbtwo> Ahh, graphviz is one of those things I love to hate.
18:20:28 <bnijk_> there's no room for folk musicians on freenode
18:20:34 <monochrom> I see why you're banned left right and centre now. :)
18:20:37 <ivanm> bnijk_: as in what the english speaking world refers to folk music, or do you  mean ethnic music
18:20:39 <ivanm> ?
18:20:44 <bnijk_> the first one
18:20:49 <bnijk_> the kind that doesn't suck
18:20:49 <ivanm> then no, I don't ;-)
18:20:52 <HugoDaniel> i hate monads
18:20:53 <ivanm> @slap bnijk_
18:20:53 * lambdabot orders her trained monkeys to punch bnijk_
18:20:58 <lament> i really like brazilian folk music
18:21:07 <bnijk_> as in, post-colonial
18:21:09 <bnijk_> or pre-colonial
18:21:22 * Cale is more of a rock'n'roll/blues/jazz person.
18:21:24 <lament> post
18:21:31 * theorbtwo quite likes his pop folky, but isn't neccessarly overly fond of straight folk.
18:21:34 <bnijk_> well Cale, i make some jazz...
18:21:41 <lament> bnijk_: what do you play?
18:21:53 <bnijk_> everything i can get my hands on
18:21:58 * ivanm is  more of a Ukrainian pop/rock fan
18:22:13 <lament> ivanm: do you like boombox?
18:22:20 <ivanm> never heard of them
18:22:46 * Philippa points out that this conversation belongs in -blah. Though bnijk_ is banned from -blah last I looked
18:22:47 * monochrom plays the haskell keyboard. do x ∈ m⊕k; ...
18:23:06 <bnijk_> why am i banned
18:23:08 <lament> ivanm: http://www.youtube.com/watch?v=W_DWe4ZmtmU
18:23:16 <lament> and yes #-blah
18:23:17 <ivanm> lament: *cough* at uni *cough*
18:23:19 <bnijk_> i was too free, so you had to cut me down
18:23:31 <theorbtwo> I do wonder why people try to pretty-print haskell so that it uses characters that... aren't valid haskell.
18:24:03 <Cale> FreeNode is free in the sense that you're free to make your own channel to talk about any specific topic you want. ;)
18:24:16 <bnijk_> freenode is horrible
18:24:18 <lament> theorbtwo: they believe that the true haskell is the one in their heads, ghc is just an imperfect reflection, crippled by being real
18:24:24 <monochrom> Haha. The only thing invalid there is ∈ in do notation. But I do that to annoy people who are annoyed by "monad as container". :)
18:24:25 <bnijk_> i don't know why everyone puts their support channels here
18:24:35 <tensorpudding> free as in speech, free as in beer, free as in freenode
18:24:37 <ivanm> lament: http://www.youtube.com/watch?v=Dvu2lOjb2FU
18:24:45 <bnijk_> free as in slavery
18:24:49 <monochrom> free as in monoid
18:24:54 <tensorpudding> free as in ... damn
18:24:59 <tensorpudding> you beat me
18:25:00 <monochrom> haha
18:25:14 <tensorpudding> more like cofree as in slavery
18:25:19 <medfly> Cale, not really
18:25:28 <lament> ivanm: sweet!!
18:25:33 <ivanm> anyway, in case anyone cares, I'm adding even more automatic escaping support to graphviz
18:25:43 <ivanm> lament: yeah, I really like them
18:25:59 <theorbtwo> Hmm.
18:26:07 <lament> i wanna go to their concert already
18:26:17 * theorbtwo ponders mucking about with older bioware game files.
18:26:50 <theorbtwo> (Turns out the Mass Effect ones aren't documented or even well reverse engennered; they stopped using their own engine.)
18:28:40 <bolmar> @src graph
18:28:40 <lambdabot> Source not found.
18:28:47 <HugoDaniel> if all my functions are pure, then i wont never ever need a monad in my module
18:29:00 <bolmar> @type graph
18:29:01 <lambdabot> Not in scope: `graph'
18:29:19 <monochrom> You can try Applicative or Arrow.
18:29:52 <MaciejP> blackh: On no, I think I completely messed up my GHC installation :-)
18:30:02 <MaciejP> blackh: GHCi runtime linker: fatal error: I found a duplicate definition for symbol _fps_reverse
18:31:23 <theorbtwo> Goodnight, guys, MissPiggy.
18:33:22 <ivanm> bolmar: what are you looking for?
18:33:26 <ivanm> cya theorbtwo
18:34:13 <MissPiggy> night
18:35:05 <HugoDaniel> i like the kotor series, but i dont like monads
18:35:20 <tensorpudding> that's fascinating
18:35:27 <tensorpudding> how can you like kotor and not like monads?
18:35:37 <MissPiggy> tensorpudding what about tensors?
18:35:57 <MissPiggy> tensorpudding, I tried to learn about left and right modules so I could do tensors but it didn't work :[
18:37:06 <tensorpudding> i don't actually know much about tensors yet
18:37:20 <MissPiggy> tensorpudding -- I have a book called algebra which does talk about them :P
18:37:26 <tensorpudding> i'm reading a&m's algebra book and will eventually learn about them
18:37:30 <MissPiggy> tensorpudding, so I pick it up every so often..
18:37:49 <MissPiggy> I think there's quite a lot of books named algebra
18:37:54 <tensorpudding> there are
18:38:08 <Cale> Tensor products of vector spaces are a bit simpler to work with.
18:38:12 <tensorpudding> there's one by lang, one by hungerford
18:38:22 <tensorpudding> i think the one by lang is called algebra anyway
18:38:30 <MissPiggy> yeah when I think of tensor I think of  A (x) B
18:38:34 <Cale> Nobody refers to mathematics books by the actual title anyway. ;)
18:38:45 <MissPiggy> and I don't even know what that means! except something somewhere is "bilinear"
18:38:53 <tensorpudding> they usually refer to the authors
18:39:02 <Cale> It's author name first, and then title to disambiguate if there's confusion. :)
18:39:11 <MissPiggy> hungerford came up yesterday in here
18:39:13 <tensorpudding> munkres' topology
18:39:17 <MissPiggy> and then today we have more books called algebra :p
18:39:41 <tensorpudding> i have hungerford in physical form, somewhere
18:39:56 <Cale> Okay, I can explain. I think to start with, the tensor product of vector spaces is easier to understand if you're willing to fix a basis.
18:40:50 <Cale> So if you have spaces V and W, with bases B = {b_i : i from 1 to n} and C = {c_j : j from 1 to m} respectively
18:41:01 <tensorpudding> for some reason, the difficulty of understanding tensors is a math meme
18:41:27 <Cale> then the tensor product can just be the vector space whose basis is the cartesian product of those bases
18:42:59 <tensorpudding> wikipedia defines it in terms of the free vector space over the cartesian product, with a few relations
18:43:32 <Cale> yeah, you can also start by forming the complete Cartesian product of V and W and quotient out a bunch of stuff
18:43:35 * hackagebot upload: cuda 0.1 - A binding to the CUDA interface for programming NVIDIA GPUs (TrevorMcDonell)
18:43:49 <tensorpudding> hmm, better, it's characterized by a UMP
18:43:56 <MissPiggy> wait a second now I don't follow
18:44:14 <lpjhjdh> how could you write cuda in haskell?  Don't even have recursion
18:44:27 <MissPiggy> oh! you said that you can product B and C, but you could also product V and W (but that one would have to be quotiented)
18:44:32 <Cale> But it's easier from a beginner's perspective to get the idea as direct sum is like taking the disjoint union of bases, and tensor product is taking the Cartesian product of bases
18:44:32 <MissPiggy> that's okay I am not confused
18:44:37 <Cale> yeah
18:44:59 <MissPiggy> so that defines (+) and (x)
18:45:00 <tensorpudding> so is the tensor product in some way dual to the direct sum?
18:45:11 <MissPiggy> I assume these make a ring or something :P
18:45:30 <Cale> I don't think they're a ring.
18:45:30 <tlm> lpjhjdh: yes. only a binding to the API, so you can call functions, marshall data back and forth, etc...
18:45:34 <MissPiggy> oh
18:45:56 <Cale> (+) is categorical product, and (x) turns Vec into a monoidal category, with the field as the monoidal unit.
18:46:13 <tensorpudding> hmm
18:46:23 <Cale> and they satisfy an interchange law
18:46:33 <tensorpudding> the direct sum is the product in Vec?
18:46:35 <Cale> and distributivity
18:46:38 <Cale> yeah
18:46:38 <tensorpudding> i thought it was a coproduct
18:46:45 <Cale> er, it's also coproduct
18:47:08 <Cale> I suppose I'm restricting to finite dimensional spaces here
18:47:41 <MissPiggy> if it's distributive why isn't it a ring?
18:48:15 <lpjhjdh> Cale: did you/do you math (or physics)?
18:48:41 <Cale> math
18:48:55 <Cale> I suppose it's nearly a ring... on isomorphism classes of vector spaces
18:49:04 <Cale> oh, no additive inverse
18:49:24 <Cale> But this isn't saying much
18:49:45 <Cale> Isomorphism classes of finite dimensional vector spaces are essentially natural numbers :)
18:51:32 <MissPiggy> Cale, yeah I think there's some theorem they are all equivalent to R^n
18:51:44 <Cale> Or F^n where F is the field of choice
18:51:45 <Cale> yeah
18:52:03 <Cale> direct sum adds dimension, tensor product multiplies dimension
18:52:23 <MissPiggy> that's so much simpler to think about :o
18:53:14 <Cale> Yeah, things are simpler in the world of vector spaces.
18:53:23 <Cale> Especially the finite dimensional ones :)
18:54:24 <copumpkin> ashoaaaag: if you're a spammer, please stop :) otherwise, please figure out how to make your client stop spamming
18:54:31 <Cale> So, normally, if b and c are basis vectors in V and W respectively, we write (b ⊗ c) for the basis vector in V ⊗ W.
18:54:40 <copumpkin> ooh I love that symbol
18:54:52 <tensorpudding> \otimes
18:54:55 <Cale> and we can extend this notation to be linear in each parameter
18:55:36 <ivanm> copumpkin: who?  I don't see anything from ashoaaaag...
18:55:39 <monochrom> Bird loves those symbols too.
18:55:53 <copumpkin> ivanm: on join he PMed me with something unintelligible with a link in it
18:56:02 <ivanm> hmmm...
18:56:12 <copumpkin> the second time I didn't get the PM
18:56:16 <ivanm> of course that link is safe! you were given it on the internetz!
18:56:19 <Cale> So that if we have v = a_1 v_1 + ... + a_n v_n in V and w = b_1 w_1 + ... + b_m w_m in W, then v ⊗ w = a_1 b_1 (v_1 ⊗ w_1) + ... + a_n b_m (v_n ⊗ w_m)
18:56:21 <MissPiggy> Cale, so that's where bilinear comes into it :D
18:56:24 <Cale> yeah
18:57:22 <Cale> Moreover, if we have linear maps A: V -> V' and B: W -> W', we can form a linear map  A ⊗ B: V ⊗ W -> V' ⊗ W'
18:57:39 <Cale> (A ⊗ B) (v ⊗ w) = (Av) ⊗ (Bw)
18:58:10 <Cale> and this operation satisfies the property that (A . B) ⊗ (C . D) = (A ⊗ C) . (B ⊗ D)
18:58:12 <tensorpudding> pretty neat there
18:58:24 <MissPiggy> linear maps are basically defined (uniquely) by matrices
18:58:33 <MissPiggy> ? so it's like a pair of matrics
18:58:41 <ivanm> preflex: seen kowey
18:58:41 <preflex>  kowey was last seen on #haskell 11 days, 10 hours, 29 minutes and 25 seconds ago, saying: is sam hughes (keeper of the YAHT) around?
18:58:48 <MissPiggy> where . is composition yes?
18:58:50 <tensorpudding> only if they are finite-dimensionaly
18:59:39 <tensorpudding> talking about infinite-dimensional matrices would be difficult
18:59:47 <ivanm> preflex: seen sinelaw
18:59:47 <preflex>  sinelaw was last seen on #haskell-blah 49 minutes and 10 seconds ago, saying: anyway, got to go.
18:59:50 <ivanm> bah
19:00:20 <ivanm> Cale: have you ever used record-based nodes in graphviz?
19:00:36 <copumpkin> how's that epic graph library going by the way?
19:01:01 <ivanm> copumpkin: stuck atm...
19:01:13 <ivanm> I can't think of a way to define the class for graphs with mappable labels :s
19:01:13 <copumpkin> I want an epic disk-backed graph library in haskell kthx
19:01:33 <Cale> MissPiggy: . is composition, yeah
19:01:41 <ivanm> copumpkin: I'm writing a generic class interface for graphs...
19:01:48 <Cale> MissPiggy: ⊗ acts on matrices by forming a big block matrix
19:01:49 <ivanm> you'll have to define that instance yourself ;-)
19:01:55 <copumpkin> ivanm: oh because of the type family superclass equality constraint problem?
19:02:00 <copumpkin> ivanm: fine with that :)
19:02:00 <ivanm> yup
19:02:10 <Cale> MissPiggy: with copies of one matrix scaled by the entries of the other
19:02:24 <copumpkin> ivanm: only solution is to bug TacticalGrace as much as possible
19:02:26 <ivanm> copumpkin: though if it's disk-backed, it'll probably be in IO... and I wans't planning on having monadic versions of the type classes
19:02:38 <copumpkin> ivanm: nah, I'd do fake purity
19:02:43 <ivanm> :o he changed his nick? :o
19:02:50 <copumpkin> ivanm: yep, not sure why
19:03:05 <ivanm> TacticalGrace: copumpkin says you're the one I should be bugging wrt type family superclass equality constraints
19:03:10 <ivanm> preflex: seen TacticalGrace
19:03:10 <preflex>  TacticalGrace was last seen on #ghc 31 days, 1 hour, 48 minutes and 23 seconds ago, saying: dons: :)
19:03:21 <copumpkin> wow, he's been pretty quiet recently
19:03:28 * ivanm mumbles something about sydneysiders
19:03:32 <ivanm> preflex: seen ChilliX
19:03:32 <preflex>  ChilliX was last seen on #ghc 67 days, 15 hours, 2 minutes and 10 seconds ago, saying: sorry, bundled with gmp
19:03:43 <copumpkin> ChilliX === TacticalGrace
19:03:50 <ivanm> yeah, I know
19:03:58 <ivanm> was just interested when he was last ChilliX ;-)
19:04:15 <ivanm> I _hate_ thinking up new constructor names...
19:04:16 <Saizan> === just in case some implicit conversion is going on?
19:04:20 <TacticalGrace> TacticalGrace: spj ist currently doing another heart transplant to the type checker
19:04:23 <ivanm> Saizan: yup ;-)
19:04:30 <ivanm> TacticalGrace: ahhh
19:04:31 <TacticalGrace> grr, I meant ivanm
19:04:37 <copumpkin> oh, TacticalGrace is here!
19:04:43 <ivanm> heh, about to ask why you were responding to yourself...
19:04:54 <ivanm> TacticalGrace: anyway, I hear you stole ben from ANU just before I got here...
19:05:00 * ivanm is using his room atm
19:05:09 <copumpkin> TacticalGrace: it seems all the work I'm interested in on GHC is coming from you! stop doing such interesting stuff or I'll be forced to keep bugging you about it
19:05:16 <ivanm> heh
19:05:46 <TacticalGrace> ivanm: until the dust has setteled on these changes, I don't think you will see any major additions, sorry
19:05:54 <ivanm> :(
19:06:03 <ivanm> TacticalGrace: so what am I looking at? 6.14? 6.16?
19:06:05 <MissPiggy> I need to have a thing which displays matrices in a good way!!
19:06:09 <TacticalGrace> but these changes hopefully will make it easier to add superclass constraints, too
19:06:14 <ivanm> \o/
19:06:14 <TacticalGrace> so it'll be a win
19:07:37 <TacticalGrace> ivanm: and realistically, given that the teaching session is about to start, I won't have time to hack the typechecker the next few months anyway
19:07:39 <monochrom> > vcat . map (hsep . map int) $ [ [n..n+2] | n<-[1,4..9] ]
19:07:39 <lambdabot>   1 2 3
19:07:40 <lambdabot>  4 5 6
19:07:40 <lambdabot>  7 8 9
19:07:45 <TacticalGrace> ivanm: you are at anu?
19:07:46 <ivanm> TacticalGrace: true
19:07:53 <monochrom> dsiplays matrices in a good way!!
19:07:53 <ivanm> TacticalGrace: just started this week
19:08:04 <ivanm> monochrom: displays even? :p
19:08:12 <monochrom> yeah!
19:08:13 <ivanm> monochrom: now you need to add the parens around that...
19:08:25 <ivanm> ;-)
19:08:45 <monochrom> \left( vcat . map (hsep . map int) $ [ [n..n+2] | n<-[1,4..9] ] \right)
19:09:10 <aavogt> @type int
19:09:11 <lambdabot> Int -> Doc
19:09:48 <ivanm> monochrom: cheater ;-)
19:09:59 <ivanm> @src int
19:09:59 <lambdabot> Source not found. My mind is going. I can feel it.
19:10:05 <ivanm> IIRC, int = text . show
19:10:10 <monochrom> yah
19:10:31 <TacticalGrace> ivanm: and what do you plan to work on?
19:10:43 <ivanm> combinatorial algoriths with brendan mckay
19:10:58 <Romney2012> MITT ROMNEY at Yeshiva University in 2007:  "In the current conflict, defeat is not nearly as dangerously close as it was during the darkest moments of the Second World War and the Cold War. There's no comparison between the economic and diplomatic, and military resources of the civilized world and those of the terrorist networks that threaten us today.  "In those previous global wars, there were many ways to lose, and victory
19:11:04 <ivanm> preferably implementing them in Haskell, though he's a C hacker and likes the low level tweakery :s
19:11:06 --- mode: ChanServ set +o monochrom
19:11:13 <ivanm> @slap Romney2012
19:11:13 * lambdabot puts on her slapping gloves, and slaps Romney2012
19:11:19 <gwern> Romney2012: well duh
19:11:20 --- mode: monochrom set +b *!*@gateway/web/freenode/x-rsmbyiczzposjeiy
19:11:20 --- kick: Romney2012 was kicked by monochrom (Romney2012)
19:11:33 <b52> is there an 64bit build of ghc for win?
19:11:35 <gwern> anyone with an ounce of common sense knows the soviets were far more dangerous than al qaeda
19:11:50 <copumpkin> b52: nope
19:12:00 <TacticalGrace> ivanm: cool
19:12:06 <gwern> (ooh aq may one day acquire 1 nuke - the ussr had 1000s)
19:12:07 <b52> that means i cant produce 64bit programs?
19:12:53 <c_wraith> err.  What's a TSO in the heap profile?
19:12:54 <copumpkin> b52: not for now
19:13:04 <dankna> (actually they only had hundreds.  during an early scouting mission, by total coincidence we flew right over all of them, causing us to vastly overestimate how many they had.  we didn't find out for decades after.)
19:13:08 <copumpkin> GENERAL TSO'S CHICKEN
19:13:13 --- mode: monochrom set -b *!*@gateway/web/freenode/x-rsmbyiczzposjeiy
19:13:14 <dankna> (or so I've heardD)
19:13:17 --- mode: monochrom set -o monochrom
19:13:17 <tensorpudding> we got spammed by republicans ohnoes
19:13:19 <dankna> (but I doubt this is on-topic, haha)
19:13:48 <tensorpudding> copumpkin: i want some
19:14:02 <copumpkin> profile your program and you'll get some TSO!!
19:17:57 <balboa02> Is it possible to use parsec to parse arbitrarily defined functions in the environment (without System.Eval)? Say you have defined function foo, is there a way to have parsec parse the string "foo" and resolve that to the defined function (or am I barking up the wrong tree)?
19:18:09 <ivanm> dankna: who is this royal "we" of which you speak?
19:18:50 <ivanm> balboa02: no idea what you're talking about, sorry
19:18:56 <ivanm> care to provide a mroe detailed example?
19:18:56 <MissPiggy> balboa02: you would need a map  eval "foo" = foo ; eval "bar" = bar
19:19:01 <c_wraith> errr
19:19:27 <ivanm> oh, you want run-time matching up of function names with definitions?
19:19:31 <MissPiggy> balboa02, if you don't have that then it may be possible to fake it wtih someone like the ghci monad
19:19:35 <c_wraith> "memory occupied by threads and their stacks is labeled as TSO when displaying the profile by closer description or type"
19:19:40 <c_wraith> I think I have a thread leak!!!
19:19:50 <Cale> balboa02: functions don't have names at runtime
19:19:55 <Cale> (in general)
19:20:01 <aavogt>   Map String Dynamic
19:20:21 <MissPiggy> I have a question about this:
19:20:21 <MissPiggy>     Ambiguous module name `Control.Monad.Identity':
19:20:21 <MissPiggy>       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
19:20:29 <aavogt> or maybe you don't need Dynamic if all your functions have the same type
19:20:30 <MissPiggy> if that happens do you just unregister one of those packages?
19:20:39 <monochrom> I just hide one of them.
19:20:41 <Cale> MissPiggy: Better just to hide one of htem
19:20:43 <Cale> them*
19:20:53 <MissPiggy> so how do you do that and how do you pick which one?
19:21:21 <Saizan> ghc-pkg hide
19:21:44 <monochrom> I raise fund for a new PhD student to study which one is better.
19:21:54 <MissPiggy> lol
19:22:00 <monochrom> Then I just ghc-pkg hide transformers
19:22:12 <MissPiggy> I just want to learn how to fix these cabal problems that I keep getting
19:22:20 <MissPiggy> I feel bad because I have to always ask you people
19:22:38 <aavogt> I feel bad because you feel bad
19:22:50 <dibblego> guys what does [] mean?
19:22:52 <copumpkin> is there a way to wrap levenshtein(-damerau) in a monoid for nice approximate lookup of strings in a fingertree?
19:22:57 <dankna> ivanm: Well, the US.  But I have no source for the story, so I have no idea whether it's really true...
19:22:59 <aavogt> empty list or list constructor
19:23:02 <copumpkin> I guess it could be represented as an interval tree
19:23:05 <dibblego> thanks
19:23:05 <aavogt> *type constructor
19:23:08 <MissPiggy> what does [] mean?
19:23:18 <aavogt> @slap MissPiggy
19:23:18 * lambdabot will count to five...
19:23:19 <ivanm> dibblego: you didn't know that? :o
19:23:32 <copumpkin> dibblego: it has magic syntactic sugar around it on the type level
19:23:33 <dibblego> I am demonstrating the haskell community
19:23:39 <ivanm> aha
19:23:46 <ivanm> what a likely excuse...
19:23:48 <MissPiggy> it's obvious you weren't asking a genuine question
19:23:54 <MissPiggy> that is why I am asking what do you mean by that
19:23:57 <aavogt> what does | mean?
19:24:04 <MissPiggy> what does dibblego mean
19:24:05 <copumpkin> it means doug
19:24:13 <copumpkin> lol
19:24:16 <ivanm> @slap aavogt
19:24:16 * lambdabot slaps aavogt
19:24:36 <ivanm> MissPiggy: IIRC, a younger sibling couldn't pronounce his name properly and said "dibblego"
19:24:40 <monochrom> MissPiggy: If you know which package is technically superior, prefer it and hide the others; if you don't know, prefer the most popular one and hide the others. mtl is more popular than transformers.
19:24:44 <balboa02> Let me see if I can clarify, the closest thing that I can think of would be like HStringTemplate - but in what I'm trying to do, the intent is that everything will be a function.
19:24:46 <ivanm> and he uses that and variants of it as his nick
19:24:52 <MissPiggy> monochrom okay, thanks
19:25:13 * copumpkin wonders if you can get an effective pure regex (i.e., not "extended regex") search structure using fingertree
19:25:27 <copumpkin> I imagine it would need a trie of some sort
19:26:11 <ivanm> copumpkin: you mean the DFA regex?
19:26:15 <copumpkin> yeah
19:26:22 <copumpkin> I doubt you could do it on anything more complex than that
19:27:01 <aavogt> ivanm: so I shouldn't answer questions which the person already has the answer?
19:27:07 <ivanm> you have seen this, I presume? http://swtch.com/~rsc/regexp/regexp1.html
19:27:27 <c_wraith> If my interpretation of that h2ps output is correct, and I have a thread leak...  What could cause the runtime to hold on to a thread?
19:27:39 <ivanm> aavogt: well, I figured you just asked in a feeble attempt at humour
19:27:44 <copumpkin> ivanm: not what I'm talking about
19:27:56 <ivanm> so not that kind of regex?
19:28:14 <copumpkin> oh, I'm talking about DFA regexes, but my question was about a search structure for them
19:28:23 <monochrom> c_wraith: Suppose something holds my ThreadId, then I will hang around even after I'm dead.
19:28:28 <copumpkin> I have a set of N strings, and I want to find those that match the regex in asymptotically < N time
19:28:28 <ivanm> yeah, I have no idea
19:28:38 <c_wraith> monochrom: I think that might just be it
19:28:50 <c_wraith> monochrom: I even remember reading that warning, now that you mention it
19:28:51 <copumpkin> I've seen a couple of papers on the topic, but I was wondering if it could be phrased as a monoid on a fingertree
19:28:59 <monochrom> It's also warned of in the Control.Concurrent haddock :)
19:28:59 <aavogt> oh, right. Well that one doesn't have much meaning because | is used in many different contexts
19:29:27 <copumpkin> if it's possible I'll be damn impressed
19:29:29 <c_wraith> Worst of all, I suspect the threadId is being held in an unevaluated thunk
19:29:31 <aavogt> though I'm not sure broken questions are supposed to be funny
19:29:33 <balboa02> More specifically, I am trying to take Text.XHtml, and use identation instead of "<<" and "+++" ... which to me seems more natural
19:29:39 <c_wraith> *sigh*
19:30:03 * copumpkin ponders
19:30:09 <aavogt> Text.XHtml is weird in that you can use function application instead of << quite often
19:30:20 <copumpkin> maybe I'll write my levenshtein search structure for now, that seems pretty cool
19:30:24 <copumpkin> and the r-tree
19:30:32 <MissPiggy> what are you making copumpkin?
19:30:37 <Saizan> copumpkin: iirc edwark can parse regular languages with his monoids
19:30:49 <copumpkin> MissPiggy: trying to think of interesting uses of fingertrees :)
19:31:09 <copumpkin> Saizan: yeah, I should look into that... he can also do context-sensitive languages supposedly
19:31:21 <MissPiggy> yikes GHC is going insane
19:31:28 <copumpkin> by taking context-free chunks and then calling parsec for the hard bits
19:31:37 <MissPiggy> I don't think I can complete this compilation
19:31:44 <copumpkin> MissPiggy: lots of static data?
19:31:46 <MissPiggy>  1486 she         25.1%  0:42.33   1    13   1381  787M-  168K   788M- 1437M
19:31:54 <copumpkin> MissPiggy: what are you trying to compile?
19:31:57 <MissPiggy> those are big numbers
19:32:01 <copumpkin> yeah :)
19:32:09 <MissPiggy> should I just kill it
19:32:10 <copumpkin> that's she though
19:32:18 <copumpkin> did you get she into a loop or something?
19:32:29 <copumpkin> I'd kill it
19:32:37 <balboa02> aavogt: I've noticed that, but I think it would be really nice to be able to write html using XHtml ... but stripping the operators
19:32:45 <MissPiggy> WOW
19:32:53 <MissPiggy> what's even more amazing is that it terminated successfully
19:32:54 <copumpkin> wow, someone made a reddit.com/r/agda
19:33:07 <copumpkin> even more amusing, his username is modus_pwnens
19:33:11 <MissPiggy> that means it was MEANT to use that much CPU/time :/
19:33:35 * MissPiggy tries to figure out what the hell we need more stupid reddits for
19:33:43 <copumpkin> agda news!
19:33:44 <copumpkin> it's so active!
19:34:00 <MissPiggy> it's bad enough there's TWO reddits for types
19:35:36 <aavogt> balboa02: what do you mean exactly? Litteral xml in your source files?
19:35:37 * copumpkin needs the "summon edwardk" command
19:36:22 <McManiaC> why is the time by Data.Time.getCurrentTime one hour behind my "real" time?
19:36:34 <ivanm> copumpkin: sorry, we only have @get-shapr
19:36:42 <ivanm> McManiaC: daylight savings?
19:36:51 <ivanm> > Data.Time.getCurrentTime
19:36:53 <lambdabot>   Not in scope: `Data.Time.getCurrentTime'
19:37:00 <ivanm> > getCurrentTime
19:37:01 <lambdabot>   Not in scope: `getCurrentTime'
19:37:05 <copumpkin> @get-shapr
19:37:05 <lambdabot> shapr!!
19:37:05 <ivanm> OK, lambdabot doesn't have it
19:37:07 <McManiaC> > Data.Time.Clock.getCurrentTime
19:37:08 <aavogt> isn't it utc?
19:37:08 <lambdabot>   Not in scope: `Data.Time.Clock.getCurrentTime'
19:37:19 <Saizan> it's in IO anyway.
19:37:33 <ivanm> McManiaC: anyway, works here
19:37:34 <balboa02> aavogt: are you familar with haml? Kinda like that. I think if you used indentation rather than the operators with Text.XHtml, it would look similar
19:37:35 <ivanm> aavogt: yup
19:37:52 <monochrom> haml = haxml ?
19:37:57 <ivanm> but I'm thinking that if he manually sets his time for daylight saving rather than it happening automatically...
19:37:57 <copumpkin> @get-edwardk
19:37:57 <lambdabot> Unknown command, try @list
19:37:58 <lambdabot> edwardk!!!!!
19:38:06 <copumpkin> :o
19:38:07 <monochrom> eh?!
19:38:10 <monochrom> @get-mono
19:38:10 <lambdabot> Unknown command, try @list
19:38:16 <monochrom> Hrm!
19:38:17 <ivanm> monochrom: haml is something separate
19:38:21 <ivanm> IIRC, anyway
19:38:28 <ivanm> @get-copumpkin
19:38:28 <lambdabot> Unknown command, try @list
19:38:33 <ivanm> weird...
19:38:36 <copumpkin> ;)
19:38:41 <ivanm> @get-edwardk
19:38:41 <lambdabot> Unknown command, try @list
19:38:48 <copumpkin> it only works when I do it
19:38:50 * hackagebot upload: minirotate 0.1.1.0 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
19:38:51 <ivanm> OK, someone was playingn silly buggers...
19:38:58 * copumpkin whistles innocently
19:39:07 <ivanm> @slap copumpkin
19:39:07 * lambdabot slaps copumpkin with a slab of concrete
19:39:21 <copumpkin> oh I guess my school isn't on the list yet anyway
19:39:25 <copumpkin> so no school id yet
19:39:26 <MissPiggy> @slap a slab of concrete
19:39:26 * lambdabot pulls a slab of concrete through the Evil Mangler
19:39:28 <balboa02> monochrom: haml http://haml-lang.com/
19:39:31 <ivanm> copumpkin: list for what?
19:39:40 <copumpkin> oh wrong channel
19:39:52 <shapr> copumpkin: ?
19:39:58 <ivanm> well, the listed github repo for minirotate doesn't exist...
19:40:03 <copumpkin> shapr: I was just testing the command, sorry :)
19:40:09 <ivanm> shapr: he had never heard of @get-shapr and was trying it out
19:40:10 <shapr> edwardk is currently offline :-P
19:40:18 <copumpkin> shapr: I know, but I was testing his command too
19:40:20 <shapr> haha
19:40:21 <ivanm> i.e. he had a new toy and had to play with it ;-)
19:40:33 <shapr> If you really need to contact him... I can.
19:40:50 * hackagebot upload: minirotate 0.1.0.0 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
19:40:51 * ivanm thinks of the mob for some reason...
19:40:53 <copumpkin> @get-edwardk
19:40:53 <lambdabot> Unknown command, try @list
19:40:54 <lambdabot> edwardk!!
19:41:03 <shapr> haha
19:41:08 <ivanm> OK, why is 0.1.1.0 being uploaded _before_ 0.1.0.0? :s
19:41:41 <copumpkin> time runs backwards here
19:41:54 <ivanm> heh
19:41:58 <ivanm> silly yanks... :p
19:42:26 * copumpkin mutters something
19:42:51 * hackagebot upload: minirotate 0.1.0.1 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
19:42:52 <gwern> > 4 ^ 4.5
19:42:52 <MissPiggy> @time runs backwards
19:42:52 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:42:53 <lambdabot>    `GHC.Real.Fractional t'
19:42:53 <lambdabot> ...
19:43:21 <copumpkin> how do you rotate a file, anyway?
19:43:51 <dmwit> logrotated
19:43:58 <copumpkin> ah :)
19:43:59 <ivanm> yeah, I think that's what it must be
19:44:27 <c_wraith> it's when you swap the tires all around so they wear more evenly
19:44:35 <c_wraith> yeah, I'm a year late with that joke
19:46:35 <KSkrzet> i felt logrotate is too heavy for my needs and perhaps the needs of others
19:46:51 <MissPiggy> heavy meaning what?
19:46:55 <KSkrzet> minirotate doesn't come with any configuration files and scheduling is meant to be done by cron
19:47:21 <sm> KSkrzet: any idea why hackagebot announced 0.1.1.0 first ?
19:47:28 <KSkrzet> heavy = custom config format, mailing, lots of options
19:48:15 <KSkrzet> sm: i uploaded it first...
19:48:19 <copumpkin> it's ezyang!
19:48:24 <ivanm> KSkrzet: your github link doesn't work?
19:48:25 <sm> ah, good
19:48:26 <ezyang> heyo!
19:48:35 <bnijk_> YES
19:48:37 <bnijk_> i did it!
19:48:39 <KSkrzet> sm: i see it made it to the hackage, sad
19:48:43 <bnijk_> are you guys proud of me
19:48:56 <dmwit> internethighfive.com
19:49:04 <bnijk_> didn't one of youg uys make that site
19:49:05 <monochrom> hahaha
19:49:06 <sm> yes, hackage has ordered them based on version no.
19:49:10 <dmwit> oops
19:49:13 <dmwit> ihighfive.com
19:49:43 <bnijk_> is anyone looking for a good time
19:49:56 <dmwit> always!
19:50:03 <bnijk_> good!
19:50:04 * sm wonders who runs hackage
19:50:05 <dmwit> Did you find one?
19:50:07 * bnijk_ breaks out the party streamers
19:50:14 <KSkrzet> ivanm: fixed, thanks
19:50:19 <bnijk_> sm: the government
19:50:24 <sm> ack
19:50:28 <copumpkin> bah, fucking paid paper sites :(
19:50:37 <bnijk_> information that costs money = fail
19:50:43 <ivanm> bnijk_: what did you do?
19:50:44 <michael|> copumpkin: Those are the most annoying
19:50:46 <MissPiggy> we want, information!
19:50:47 <emma17> what are you guys talking about
19:50:49 <bnijk_> i wrote a flex/yacc calculator
19:50:53 * hackagebot upload: minirotate 0.1.1.1 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
19:51:03 <MissPiggy> bnijk_ cool
19:51:07 <michael|> Especially when you search for ages for some specific information, seem to find it, and then find out you must pay for access.
19:51:23 <copumpkin> the sad thing is that it's just because I live off campus
19:51:31 <copumpkin> now I need to disconnect all my stuff and VPN in
19:51:42 <KSkrzet> copumpkin: can you ssh into campus?
19:51:56 <copumpkin> yeah, but that doesn't give my browser access
19:52:05 <KSkrzet> copumpkin: if so, just do something like this "ssh user@campus -D8080"
19:52:08 <ivanm> copumpkin: you can't do X forwarding via ssh?
19:52:14 <copumpkin> KSkrzet: I don't have a proxy there
19:52:21 <copumpkin> ivanm: I guess I could :/
19:52:21 <KSkrzet> copumpkin: install FoxyProxy to firefox and set proxy as socks localhost 8080
19:52:29 <MissPiggy> maybe you can browse through ssh?
19:52:31 <KSkrzet> it works
19:52:42 <MissPiggy> yeah what KSkrzet said
19:52:47 <michael|> Yeah, what KSkrzet is suggesting. It's what I do from campus every day
19:52:49 <copumpkin> the X solution is even easier, but then if I want to download the pdf it downloads to my remote account
19:52:50 <KSkrzet> ssh with -D will act as socks proxy, kind of
19:52:50 <ezyang> copumpkin: You definitely want port forwarding
19:52:52 <copumpkin> and then I need to SCP!
19:52:53 <copumpkin> so much work
19:52:56 <dmwit> Browsing with the lag of a campus connection really bites.
19:52:56 <ivanm> either way, he'd have to restart his browser probably
19:53:06 <ezyang> You could convince your college to adopt AFS. It would be awesome :-)
19:53:06 <copumpkin> so much work, *sigh
19:53:07 <ivanm> copumpkin: excuses, excuses
19:53:17 <ivanm> ezyang: is that Andrew's File System?
19:53:18 * copumpkin just VPNs
19:53:22 <ezyang> ivanm: Yep
19:53:24 <dmwit> sizeof(HTML) <<< sizeof(image of rendered HTML)
19:53:31 <copumpkin> assuming the shitty proprietary VPN doesn't fail
19:53:44 <dmwit> copumpkin: Do you want some cheese?
19:53:44 <emma17> it won't if you do it right
19:53:48 <copumpkin> yes please
19:53:48 <ivanm> my old uni just visit that site through the library's page, which would act as a proxy
19:53:49 <KSkrzet> ivanm: to install extension, yes, but not to change proxy
19:53:52 <ivanm> not sure what ANU does
19:53:53 <dmwit> copumpkin: ...to go with that whine? ;-)
19:54:05 <ivanm> dmwit: what kind of cheese are you offering?
19:54:13 <monochrom> whining cheese
19:54:23 <ivanm> doesn't sound very nice...
19:54:24 * copumpkin_ loves whining
19:54:31 <copumpkin_> I also don't really like juniper VPN
19:54:34 <copumpkin_> but it's not terrible
19:54:47 <monochrom> geezing wine
19:54:47 <Sagi> I want to instantiate ByteString's in my code, preferably by specyfying values as hex. What's the best way to do that?
19:55:00 <dmwit> pack [0x32, 0x46]
19:55:17 <aavogt>  -XOverloadedStrings could work too
19:55:37 <Sagi> pack is what I use now, but it seems incredibly ugly
19:55:39 <copumpkin_> wtf, the paywall still wants me to pay
19:56:05 <monochrom> if the university hasn't subscribed.
19:56:15 <ivanm> preflex: seen dons
19:56:16 <preflex>  dons was last seen on #haskell 1 day, 21 hours, 7 minutes and 47 seconds ago, saying: not sure if anything but demos has been written with it. frag is a famous FRP-based 3d game in haskell
19:56:50 <tensorpudding> @src all
19:56:50 <lambdabot> all p =  and . map p
19:56:51 <aavogt> I've seen false advertising where my library thinks they have access to the whole book, while springer only gives you the table of contents and index
19:56:55 * hackagebot upload: minirotate 0.1.1.2 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
19:57:01 <copumpkin_> okay, this is really lame
19:57:13 <aavogt> perhaps it's the same deal for you, copumpkin_
19:57:24 <copumpkin_> no, it set a cookie in my browser
19:57:28 <ivanm> @ask dons do you know if galois or Brian Lewis would mind if I stole^h^h^h^h^h borrowed the Xml specification from language-dot and put it into graphviz?  I know my current implementation of URL labels sucks, but I can't be bothered writing a proper one on my own...
19:57:28 <lambdabot> Consider it noted.
19:57:35 <tensorpudding> @hoogle (a -> m Bool) -> [a] -> m Bool
19:57:35 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
19:57:35 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
19:57:35 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
19:57:36 * ezyang prepares dead tree books anyway... 
19:57:38 <copumpkin_> I opened it up in firefox now, and it makes the paper vailable
19:57:39 <KSkrzet> (now that links to github are hopefully fixed)
19:57:45 <ivanm> aavogt: grrr... I hate it when that happens
19:57:52 <ivanm> ezyang: you mean "prefers"?
19:57:59 <ezyang> Oh yes *
19:58:01 <copumpkin_> but in safari, it won't let me download it, because I guess it remembered that I wasn't authenticated before
19:58:07 <copumpkin_> ****ing ridiculous
19:58:56 <ivanm> KSkrzet: this appears to still be dead, but that might be because I'm trying to open it in my browser: http://github.com/Tener/haskell-minirotate.git
19:59:03 <ivanm> should it be "tener" rather than "Tener"?
19:59:17 <ivanm> no, wait, forget that stupid excuse for a suggestion
19:59:20 <oconnore_> So, I'm coming from lisp, but I need to use haskell since it's the only functional language allowed in programming competitions. Where is a good place to start?
19:59:25 * ivanm thought he saw KSkrzet using "tener" in one URL
19:59:34 <dmwit> ?where gentle
19:59:35 <lambdabot> http://www.haskell.org/tutorial/
19:59:37 <ivanm> oconnore_: do you prefer serious or whimsical tutorials?
19:59:39 <dmwit> ?where lyah
19:59:39 <lambdabot> http://www.learnyouahaskell.com/
19:59:41 <dmwit> ?where rwh
19:59:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:00:05 <sm> http://github.com/Tener/haskell-minirotate/blob/master/minirotate.cabal <- source-repository probably has to be that way for a git repo
20:00:05 <oconnore_> ivanm: Serious or whimsical? Is ther serious one more accurate?
20:00:08 <monochrom> haskell is allowed where lisp isn't?!
20:00:17 <copumpkin> that sounds odd
20:00:27 <oconnore_> monochrom: yes. ACM competitions.
20:00:28 <monochrom> In fact, haskell allowed in programming competitions?
20:00:31 <ivanm> oconnore_: LYAH is often recommended as a tutorial, but it's too silly in its nature for my taste
20:00:32 <shapr> oconnore_: The Gentle Tutorial is sink or swim, it might be your style. The Real World Haskell book is comprehensive and straightforward, but slower than The previously mentioned Mental BrickBat of Doom...
20:00:45 <monochrom> ACM even? Isn't it like purely imperative?
20:00:48 <ivanm> if you want a real book, The Craft of Functional Programming is good
20:00:52 <KSkrzet> ivanm: this one is for git clone and it works for that :-) use homepage: http://github.com/Tener/haskell-minirotate
20:00:52 * dmwit likes the Mental Brick Bat
20:00:58 <ivanm> Haskell School of Expression is also not bad
20:01:02 <sm> or Programming Haskell
20:01:12 <monochrom> When is the World Final?
20:01:12 <ivanm> KSkrzet: yeah, I just had that other link open when the main one didn't work
20:01:12 <shapr> dmwit: Had you had lots of math & cs before you started with the BrickBat?
20:01:18 <dmwit> shapr: yes
20:01:21 <copumpkin> what's brick bat?
20:01:23 * sm means Programming in Haskell
20:01:30 <copumpkin> dmwit: CS undergrad or math?
20:01:32 <shapr> dmwit: I'd had zero math & cs before that.
20:01:33 <dmwit> shapr: But then, so has oconnore_, it seems. (He comes from the Land of Lisp.)
20:01:40 <dmwit> shapr: ah
20:01:47 <dmwit> copumpkin: CS major, math minor
20:01:50 <ivanm> copumpkin: you use a brick as a clue bat methinks...
20:01:50 <copumpkin> ah
20:01:54 <oconnore_> i'm not sure when the world final is. we didn't make it last year.
20:01:57 <copumpkin> I see :)
20:02:02 <ddarius> @wn brickbat
20:02:02 <shapr> Yeah, I think the Gentle (ha) Tutorial will likely work for someone with lots of Lisp experience.
20:02:04 <lambdabot> *** "brickbat" wn "WordNet (r) 2.0"
20:02:04 <lambdabot> brickbat
20:02:04 <lambdabot>      n 1: a fragment of brick used as a weapon
20:02:04 <lambdabot>      2: blunt criticism
20:02:09 <monochrom> Hrm! The ACM World Finals was 10 days ago.
20:02:10 <copumpkin> I see
20:02:21 * copumpkin wishes he'd done more math
20:02:27 <oconnore_> monochrom: were you there?
20:02:33 <monochrom> No.
20:02:33 <dmwit> To be fair, you now probably know more math than I do. =)
20:02:34 <ddarius> copumpkin: Because you are going to die tomorrow.
20:02:35 <oconnore_> oh
20:02:38 <shapr> monochrom: The World is Final if you declare it as such in Java :-P
20:02:44 <copumpkin> dmwit: I really doubt it :P
20:02:51 <monochrom> hahahaha
20:03:02 <copumpkin> ddarius: nope, but I feel like I'd have done a lot of things differently if I'd known some of this stuff earlier :)
20:03:09 <copumpkin> well, I can't say nope for sure
20:03:16 <MissPiggy> what stuff??
20:03:20 <copumpkin> math!
20:03:20 <oconnore_> monochrom: I hope to be there next year, but I want to have something a bit better than C++ :P
20:03:25 <MissPiggy> what
20:03:27 <MissPiggy> math ??
20:03:40 <MissPiggy> you mean like squaring circles and stuff? I don't know what the big deal is
20:03:58 <copumpkin> all the stuff that we talk about a lot here :P
20:04:02 <copumpkin> algebra, type theory, cat theory, dog theory
20:04:04 <oconnore_> MissPiggy: It's just some crazy stuff that lispers do :P
20:04:08 <dmwit> logic
20:04:09 <shapr> oconnore_: Anyway, if you don't like the Gentle Tutorial, we can suggest other tutorials.
20:04:16 <copumpkin> I knew none of it a year ago
20:04:21 <MissPiggy> well I am quite confused now!
20:04:23 <copumpkin> and that makes me excited and sad I didn't find it out earlier
20:05:04 <copumpkin> ah well
20:05:10 <copumpkin> things could be worse :P
20:05:20 <oconnore_> shapr: Thank you, I haven't really checked them out yet. If it doesn't work I will be back :)
20:05:25 <MissPiggy> oconnore_ lispers are circle squarers? :P
20:05:47 <oconnore_> MissPiggy: Only with the right macro's
20:05:59 <aavogt> circular squares
20:06:02 <shapr> oconnore_: Feel free to ask any questions that occur to you.
20:06:13 <copumpkin> obtangular squircles
20:06:23 <shapr> Man, it's been a long time since I did my irc based interactive Haskell tutorial.
20:06:52 <ddarius> oblate squaroids
20:06:53 <oconnore_> Thanks, I was really just looking for a tutorial that skipped the: "Welcome from Java, this is functional programming..." thing.
20:07:07 <shapr> hah, yes
20:07:09 <oconnore_> since I already use (non-strict) functional programming
20:07:34 <MissPiggy> shapr I am watching the astronaugts in space
20:07:39 <aavogt> macros for lazy evaluation are common?
20:07:40 <shapr> Whoa, I like that name.
20:07:47 <shapr> Astronaughts. That MUST be a band name.
20:07:56 <oconnore_> aavogt: Yes, there are several implementations.
20:08:02 <ezyang> oconnore_: What bits of FP?
20:08:19 <MissPiggy> shapr are you cybertronic?
20:08:22 <oconnore_> ezyang: Excuse me?
20:08:32 <copumpkin> you are not excused!
20:08:37 <shapr> MissPiggy: Er, maybe?
20:08:41 <MissPiggy> that's cool
20:09:30 <ezyang> oconnore_: As in, what do you already know about FP?
20:09:38 <MissPiggy> macros aren't enough for lazy eval
20:09:39 <shapr> MissPiggy: What does that mean?
20:09:41 <ezyang> I knew some FP coming into Haskell... had to relearn it all anyway though :-)
20:09:42 <MissPiggy> you need macroexpand-1
20:09:45 <monochrom> oconnore_: Oh, definitely "the gentle introduction" then.
20:09:54 <copumpkin> yeah, I'd had some scheme before haskell, still got my mind blown plenty
20:09:58 <Lemmih> MissPiggy: He seemed quite human-like last time I hugged him.
20:10:06 <shapr> I have hugged Lemmih!
20:10:47 <oconnore_> ezyang: lisp is quite functional (although you can certainly code in it as if it were C, and never learn the cool bits)
20:11:03 <oconnore_> thanks monochrom
20:11:15 <ddarius> The community around Common Lisp is very different than the one around Haskell.  The Scheme community is much closer but still distinctly different.
20:11:40 <aavogt> you can code haskell as if it was C
20:11:58 <MissPiggy> the trick is NOT doing that :)
20:12:10 <dmwit> aavogt: how to *((void *)x + 32) ?
20:12:11 <ivanm> Cale: still around?
20:12:17 <ezyang> "haskell is a perfectly fine imperative language!"
20:12:25 <ddarius> aavogt: But it is distinctly harder than coding it as if it were Haskell, and is more annoying than using C for doing C (unless you use stuff you can't do in C as well.)
20:12:26 <MissPiggy> dmwit that isn not valid C is it???
20:12:34 <oconnore_> Yes, I'm still skeptical about the lack of macros. But otherwise haskell looks very nice.
20:12:36 <copumpkin> it isn't
20:12:39 <dmwit> You're right, it needs another cast after the addition.
20:12:43 <ezyang> "template haskell"
20:12:47 <copumpkin> no, you can't add to a void pointer
20:12:53 <copumpkin> because it has no size
20:12:57 <copumpkin> (afaik)
20:13:09 <ezyang> GCC gives it a reasonable size
20:13:13 <MissPiggy> O_O
20:13:15 <copumpkin> really?
20:13:16 <MissPiggy> it is allowed by gcc
20:13:18 <copumpkin> what's a reasonable size?
20:13:18 <ezyang> And if you're doing OS work it's not that unreasonable.
20:13:38 <MissPiggy> what does it mean to add to a void pointer
20:13:41 <oconnore_> ddarius: how would you say the scheme community is different?
20:13:55 <ddarius> dmwit: plusPtr x 32
20:14:10 <copumpkin> you'd want to dereference it too
20:14:13 <dmwit> int main() { char x = *(char *)((void *)x + 32); } // this compiles here
20:14:18 <copumpkin> odd
20:14:21 <ezyang> 32-bits iirc
20:14:24 <tensorpudding> hmm
20:14:30 <dmwit> I don't even want to think about what it means semantically.
20:14:31 <ezyang> on a 32-bit system. never tried on a different one
20:14:39 <copumpkin> so I guess it's assuming that's 32 bytes?
20:14:39 <dmwit> ?hoogle plusPtr
20:14:39 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
20:14:41 <ivanm> dmwit: it might compile, but does it _run_? :p
20:14:42 <ddarius> peek $ plusPtr x 32 -- point copumpkin
20:14:48 <dmwit> ivanm: sure
20:15:00 <dmwit> ivanm: and segfaults =)
20:15:04 <tensorpudding> so if you have an (IO a), and you do (sequence . take 10 . repeat) on it, do you have the action run 10 times?
20:15:05 <ivanm> heh
20:15:12 <oconnore_> well, thank you all for you help.
20:15:13 <copumpkin> that makes sense :P
20:15:18 <MissPiggy> tensorpudding: yeah
20:15:26 <ezyang> It will run if you're actually managing that memory :-)
20:15:30 <ivanm> dmwit: I'd count that as a "no"
20:15:33 <ezyang> or you're writing exploit code
20:15:39 <copumpkin> ezyang: well, you don't really know what will be there
20:15:41 <dmwit> tensorpudding: Yes, and that is the same as replicateM 10.
20:15:52 <tensorpudding> oh, replicateM, that sounds lovely
20:16:08 <ddarius> oconnore_: The Scheme community has more of a bent toward pedagogy and (also) more commercialization, it has less of a bent toward theoretical research and math.
20:16:17 <dmwit> ?src replicateM
20:16:17 <lambdabot> replicateM n x = sequence (replicate n x)
20:16:28 <ezyang> C is all about mutilating abstraction barriers!
20:16:38 <ezyang> Anyway, I think I was lying earlier
20:17:49 <copumpkin> does anyone have any ideas about the monoid+fingertree for regex matching? :)
20:17:55 * copumpkin is very curious
20:18:06 <ddarius> copumpkin: Talk to edwardk.
20:18:18 <copumpkin> yeah, but the @get-edwardk button didn't work
20:18:30 <dmwit> copumpkin: The monoid is a function from states to states.
20:18:41 <ezyang> printf("%p", ((void*)0x100) + 0xA); will give you 0x10A
20:18:50 <dmwit> copumpkin: It tells how the chunk of text in the rest of the fingertree would affect any input state.
20:18:52 <copumpkin> dmwit: yeah, but that's not (as far as I can see) a useful monoid for indexing the fingertree by
20:18:59 <MissPiggy> I need your advice guys
20:19:00 <copumpkin> or could it?
20:19:05 <ezyang> so it's byte-aligned
20:19:07 <dmwit> indexing?
20:19:13 <copumpkin> dmwit: well, measuring
20:19:14 <bnijk_> do any of you know somebody who lives off the grid
20:19:15 <bnijk_> besides their ISP
20:19:23 <dmwit> I thought the point of a fingertree was that it was zipper-like, and that you could bubble up changes to leaves efficiently.
20:19:52 <dmwit> So that the value of the monoid at the root is the mconcat of all the values at the leaves.
20:19:58 <dmwit> ...but I could be thinking of something else
20:19:58 <copumpkin> dmwit: I guess I should say what my goal is :P I wanted an efficient regex-search structure for finding strings in a structure that match a regex in sublinear time
20:20:55 <dmwit> hum
20:21:02 <copumpkin> it seems hard :)
20:21:07 <dmwit> yes =)
20:21:10 <dmwit> sublinear seems hard =)
20:21:26 <ddarius> Doesn't it take linear time to simply read the input?
20:21:28 <copumpkin> I've seen a paper with a scheme for doing it with a trie
20:21:56 <copumpkin> ddarius: oh I mean, say you had a database and loads of strings, and could afford to build an index with the expectation that you'll be making lots of queries against it
20:22:11 <copumpkin> you want to find all strings that match the query without trying them all
20:22:18 <dmwit> copumpkin: i.e. using a different regex each time, but the same index?
20:22:21 <copumpkin> yeah
20:23:35 <copumpkin> the ultimate fulltext search, sort of :)
20:26:09 <scutigera> copumpkin: could you create an index of regexs that match each string.  I think that the most "efficient" regex would be unique....
20:26:24 <copumpkin> scutigera: hm?
20:26:50 * dmwit has been imagining something along the lines of a suffix trie
20:26:57 <ddarius> Regex will have nothing to do with the ultimate fulltext search.
20:27:00 <copumpkin> yeah, that's the scheme uses
20:27:19 <copumpkin> that's what the scheme I saw in the paper uses
20:27:23 <dmwit> yeah
20:27:23 <scutigera> copumpkin: oh nevermind, someone could give you a regex which was inefficient and didn't match.  I was sort of thinking hashing by regex
20:27:45 <copumpkin> ddarius: hrmpf
20:27:54 <copumpkin> I just think it would be cool :)
20:27:57 <dmwit> Traverse the trie, aborting whenever the regex can no longer match...
20:27:59 <copumpkin> the levenshtein idea I had before was bad too
20:28:27 <bnijk_> traverse the brie....
20:28:32 <bnijk_> i feel a meme coming on
20:28:33 <dmwit> Hard to say whether that's efficient, though, and it's a little inelegant. =)
20:28:40 <ddarius> copumpkin: You thinking it will be cool seems like a better reason for you to do it than it being the ultimate doodad for foobaring.
20:28:51 <bnijk_> ./` shredded & shredded & shredded & wheat, shredded wheat ./`
20:28:53 <copumpkin> dmwit: maybe a DAWG would help ;)
20:29:10 <copumpkin> ddarius: yeah :) I wasn't really being serious about it being the ultimate anything
20:29:27 <dmwit> Good idea!
20:29:39 <dmwit> Though I'm not seeing yet, perhaps because I haven't yet understood how DAWGs really work.
20:29:53 <copumpkin> DAWGs are just prefix tries + suffix tries merged together, sort of
20:30:02 <dmwit> Right, I've got the intuition that far.
20:30:03 <copumpkin> join common suffixes on a prefix trie
20:30:26 <copumpkin> but yeah, I haven't thought through how regex matching would work on them
20:31:59 <scutigera> copumpkin: prefix is aaa; so a+ is associated with that node of the tree.
20:32:39 <scutigera> so you can search by regex "chunks".  I'm totally shooting from the hip here.
20:32:50 <copumpkin> :)
20:33:23 <copumpkin> I get the feeling it can't be done with a fingertree
20:36:10 <copumpkin> so many interesting search structures!
20:37:07 * hackagebot upload: data-ordlist 0.4.2 - Set and bag operations on ordered lists (LeonSmith)
20:37:07 <MissPiggy> if only there was a search structure that let you find the right one for the problem..
20:37:14 <copumpkin> ooh yeah
20:37:30 <copumpkin> Map Problem SearchStructure
20:46:33 <iaefai> I must install readline package, and i have installed the library under /opt/local, which is the best way to tell cabal that?
20:47:59 <copumpkin> --extra-lib-dirs or something like that
20:48:12 <ivanm> see cabal install --help
20:49:18 <sm> --extra-lib-dirs and --extra-include-dirs
20:51:13 <iaefai> Can't seem to get it to work
20:51:20 * sm tries adding them in ~/.cabal/config again
20:51:38 <sm> it would look like: --extra-lib-dirs=/opt/local/lib --extra-include-dirs=/opt/local/include
20:52:53 <sm> night all
20:53:17 <ivanm> @tell kowey OK, I'm working on record shapes atm; the actual label stuff is done, just having to update the definition of PortPos
20:53:17 <lambdabot> Consider it noted.
20:53:23 * ivanm heads off
20:54:05 <iaefai> I added it, and still doesn't like it
20:56:53 <iaefai> http://pastebin.ca/1801100
21:00:21 <Saizan> iaefai: readline probably uses a configure script, so you've to set it in some enviroment variable that the script understands
21:00:25 <Saizan> maybe CFLAGS?
21:00:39 <kniu> :t "(***)
21:00:40 <lambdabot>     lexical error in string/character literal at end of input
21:00:41 <kniu> :t (***)
21:00:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:01:09 <kniu> > ((+1) *** (-1)) (4, 5)
21:01:10 <lambdabot>   No instance for (GHC.Num.Num (b' -> c'))
21:01:10 <lambdabot>    arising from a use of syntactic...
21:01:30 <kniu> the hell is hlint on about?
21:01:35 <iaefai> Saizan:  I will try that
21:01:40 <copumpkin> > ((+1) *** (–1)) (4, 5)
21:01:41 <lambdabot>   (5,4)
21:01:48 <kniu> oh.
21:01:55 <Saizan> iaefai: i.e. CFLAGS="-L/opt/local/lib -I/opt/local/include" cabal install readline
21:02:50 <Saizan> hlint fooled by unary minus?
21:02:52 <dmwit> ?pl \x y xys -> (x, y) : xys
21:02:52 <lambdabot> ((:) .) . (,)
21:02:59 <jmcarthur> i go so overboard sometimes
21:03:18 <iaefai> Saizan: It definitely improved, but still failed: http://pastebin.ca/1801107
21:03:36 <jmcarthur> but on the plus side, now i have a monadic hylomorphism
21:03:59 <andrewsw> \quit
21:04:02 <andrewsw> oops
21:04:03 <iaefai> ex. Readline.hsc:723: error: ‘UNDO_DELETE’ undeclared (first use in this function)
21:04:57 <copumpkin> jmcarthur: nice
21:05:04 <copumpkin> for tron?
21:05:27 <Saizan> iaefai: maybe you've to use both the environment variable and the cabal flags
21:05:27 <jmcarthur> yeah
21:05:41 <iaefai> Saizan: yeah, I can try that
21:06:35 <iaefai> Saizan: Thank you so much, it worked
21:07:09 <jmcarthur> copumpkin: i'm gonna be using some ST stuff and wanted some deforestation
21:08:09 <jmcarthur> copumpkin: should help a lot because the data structure i'm eliminating is the entire game tree, or what i generate of it anyway
21:09:13 <ezyang> Hmm, I wonder if Haskell gives me a fast count bit population
21:09:15 <ddarius> mapM f <=< mapM g /= mapM (f <=< g)
21:09:33 <jmcarthur> not in general, no
21:11:05 <iaefai> Has anyone had any trouble compiling jhc with ghc 6.12?
21:11:07 <jmcarthur> ddarius: i have a new type class for strength :: Functor f => a -> f b -> f (a,b)
21:11:11 <jmcarthur> dang
21:11:13 <jmcarthur> wrong
21:11:21 <jmcarthur> lemme copy the right thing here
21:11:51 <jmcarthur> (a -> m b) -> (f a -> m (f b))
21:12:03 <jmcarthur> i have a type class for that with a couple laws
21:12:32 <ddarius> I don't think that corresponds to the notion of strength.
21:12:37 <jmcarthur> no it doesn't
21:12:41 <jmcarthur> i pasted the wrong thing
21:12:47 <ddarius> Ah.
21:13:01 <jmcarthur> mfmap :: (a -> m b) -> (f a -> m (f b))
21:13:22 <jmcarthur> mfmap return = return   and  mfmap f <=< mfmap g = mfmap (f <=< g)
21:13:24 <ddarius> mfmap sounds like simply a functor from the Kleisli category.
21:13:29 <jmcarthur> it is
21:14:11 <jmcarthur> anyway, i'm using that to do monadic cata, ana, and hylo
21:14:35 <Saizan> or a distributive law f (m a) -> m (f a) ?
21:14:45 <jmcarthur> yeah that would work too
21:14:54 <jmcarthur> but this way seemed more intuitive to me
21:16:09 <ddarius> I'd have to check the laws related to a distributive law, but it does seem equipotent at first glance.
21:16:11 <jmcarthur> there are a couple papers on this, but i couldn't figure them out. i think i got the gist, and what i did feels right to me
21:16:22 <ddarius> mfmap id :: f (m a) -> m (f a)
21:17:22 <jmcarthur> rather, i didn't want to take the time to figure them out
21:20:08 <copumpkin> doesn't traversable give you that?
21:20:32 <jmcarthur> dang, i need to pay closer attention to the libraries i want to use on ghc 6.8 :\
21:20:50 <jmcarthur> i don't suppose there's a chance of uvector working on 6.8, is there?
21:20:52 * copumpkin has never used 6.8
21:21:13 <ddarius> You went from 6.6 straight to 6.10?
21:21:14 <copumpkin> it does as far as I remember, but there were some missed fusion opportunities
21:21:20 <copumpkin> no, I started with 6.10
21:21:37 <ddarius> I thought you were here before 6.10.
21:21:37 <dmwit> uvector got recently deprecated, right?
21:21:46 <copumpkin> ddarius: nah, I just make lots of noise
21:21:47 <jmcarthur> yes it did, but i need a library that uses it
21:21:54 <dmwit> ah
21:22:40 <jmcarthur> i hope not too many missed fusion opportunities
21:22:50 <copumpkin> don't think so
21:22:52 <ddarius> copumpkin: I think it's my perception of time that is the problem.
21:23:11 <jmcarthur> i started around the time of 6.6
21:23:25 * ddarius started in the time of 5.4.2.
21:23:35 <jmcarthur> but since i was new, i don't remember much as far as supported features. i was too busy just trying to learn the ropes
21:23:50 <copumpkin> ddarius: could be, but I make so much noise that a couple of months after I arrived I'd climbed dons' IRC stats to the top 5 noisiest people or so
21:24:52 <copumpkin> (making lots of noise might suggest more familiarity than I actually had)
21:24:59 * copumpkin shrugs
21:25:13 <ddarius> copumpkin: I just recall you being around a long while ago.
21:25:37 <dmwit> lawn, onion, five bees, etc.
21:25:43 <Cale> I think when I started, 5.02 was the latest version, and 5.04 came out shortly after.
21:26:28 * ddarius thinks that time between GHC releases is growing exponentially.
21:26:39 <ezyang> "complex software neh"
21:27:07 * dmwit thinks that time between Haskell spec releases is growing without bound.
21:27:28 <ddarius> dmwit: The next one should be here next year or so.
21:27:47 <dmwit> That would be marvelous.
21:27:57 <dmwit> But the cynic in me can't help pointing out that they've been saying that for a while.
21:28:07 <ddarius> dmwit: 2010 is released.
21:28:11 <dmwit> point
21:28:17 <ddarius> The plan is to do (annual?) releases of a standard.
21:28:43 <bnijk_> what's that haskell OS again?
21:28:51 <bnijk_> is it POSIX-compliant
21:29:28 <lpjhjdh> bnijk_: house?
21:29:36 <bnijk_> house and kinetic apparently
21:29:57 <bnijk_> "After learning Haskell, I became fascinated by the idea of using monads to express security-related ideas in software. The idea is pretty simple: one can think of the IO monad as a type system contaminate that identifies all functions that interact with the program’s environment (such as those that print to the console, write to the network, etc). This is useful: a function cannot mutate the environment unless it has IO type. Contrast thi
21:30:05 <bnijk_> yes...
21:30:30 <dmwit> You got cut off after the third sentence.
21:30:32 <copumpkin> edwardk has a security monad
21:30:58 <bnijk_>  Contrast this with  most languages (C++, Java, Scheme, Python, etc) where you need to  examine a function’s implementation to be sure that it doesn’t  mess with the environment."
21:31:31 <bnijk_> somebody is going to make a drop-in replacement for linux
21:31:31 <bnijk_> in haskell
21:31:35 <bnijk_> i can feel it coming ;)
21:31:41 <lpjhjdh> I like the idea of barrellfish, using dsls
21:31:44 <bnijk_> unless a better FPL comes along
21:32:38 <lpjhjdh> I think the area of (e)dsls give haskell a potential market it could crush
21:35:33 <jmcarthur> DANGIT. i didn't realize uvector had parts in C
21:35:41 <jmcarthur> the contest server would build that
21:35:49 <jmcarthur> *won't build
21:35:58 <dmwit> AUGH
21:35:58 <copumpkin> you could avoid them quite easily
21:36:05 <copumpkin> the c bits are trivial
21:36:17 <copumpkin> but you'd need to tinker a bit
21:36:27 <copumpkin> dmwit: ?
21:36:39 <dmwit> commiserating
21:36:41 <dmwit> rewrites suck
21:36:44 <copumpkin> oh :)
21:37:05 <copumpkin> jmcarthur: the C functions are just memcpy variants iirc
21:37:07 <jmcarthur> oh you're right. it's just a couple wrappers around memcpy
21:37:27 <jmcarthur> well, one memcpy, one memmove
21:37:37 <jmcarthur> still means i need to do some FFI work i guess
21:37:55 <copumpkin> I thought there were already bindings to those two in Foreign.Something
21:39:01 <jmcarthur> copyBytes and moveBytes
21:39:15 <jmcarthur> i still need to write variants for offsets, apparently
21:39:43 <jmcarthur> but this should work i guess
21:49:45 <jmcarthur> hmm, this is a bit of a pain
21:53:49 <scutigera> instance Num Symbolic where
21:53:50 <scutigera>     x + y = x `Plus` y
21:53:50 <scutigera>  
21:53:55 <scutigera> No instances for (Show Symbolic, Eq Symbolic)
21:54:04 <dmwit> Horrible, isn't it?
21:54:25 <scutigera> I think I understand, but why do I _have_ to define Show ?
21:54:44 <dmwit> The Prelude is a little short-sighted in places.
21:54:56 <dmwit> ...and that's why.
21:55:26 <scutigera> ok. so I just need instance Show Symbolic ...
21:55:35 <copumpkin> scutigera: someone way back in the day said "who needs numbers if you can't show them!? and clearly all numbers have a notion of equality, and magnitude, and a sign, and can be multiplied!"
21:56:00 <copumpkin> instance Show Symbolic where show = error "broken numeric classes", as edwardk does
21:56:02 <dmwit> Actually, the Eq constraint has at least a little bit of rational.
21:56:07 <dmwit> So you can write
21:56:10 <dmwit> f 3 = foo
21:56:14 <dmwit> which desugars to
21:56:20 <dmwit> f x | x == 3 = foo
21:56:36 <dmwit> Or, with even more desugaring,
21:56:40 <copumpkin> well, that logic could be pushed to the function in question
21:56:41 <dmwit> f x | x == fromInteger 3 = foo
21:56:47 <copumpkin> f :: (Eq a, Num a) => a -> ...
21:57:04 <dmwit> I suppose so, yes.
21:57:21 <copumpkin> CReal doesn't have a real Eq
21:57:22 <dmwit> As I said -- some rationale... but still a little shortsighted.
21:57:29 <copumpkin> yeah
21:57:29 <scutigera> can I annotate my way out of this , or just give up and start writing .
21:57:41 <dmwit> scutigera: deriving (Eq, Show) ?
21:58:47 <aavogt> preflex: seen lunabot
21:58:48 <preflex>  lunabot was last seen on #haskell 18 days, 22 hours, 36 minutes and 1 second ago, saying:  31
21:59:13 <dmwit> I guess CReal could reasonably be adapted to give a real Eq instance that was semidecidable.
21:59:15 <copumpkin> @get-mmorrow
21:59:15 <lambdabot> Unknown command, try @list
21:59:29 <scutigera> heh, Warning: No explicit method nor default method for `*'
21:59:40 <dmwit> CReal ~ Integer -> (Integer {- the digits -}, Bool {- whether this is an exact representation -})
21:59:48 <scutigera> copumpkin tried to warn me :-)
21:59:48 <copumpkin> dmwit: but the thing is, for pattern matching in a function, you tend to want the semidecidable side that it doesn't give you
22:00:09 <dmwit> hm
22:00:16 <dmwit> copumpkin: Really?
22:00:27 <copumpkin> well, Eq on CReal can only tell you if they're not equal
22:00:28 <dmwit> copumpkin: With the representation I'm suggesting above?
22:00:38 <copumpkin> oh
22:00:40 <dmwit> copumpkin: Which sometimes terminates for equal things?
22:00:49 <copumpkin> yeah, I guess that'd work :)
22:01:12 <copumpkin> I started writing my response before I saw your suggestion
22:01:19 <dmwit> *sagenod*
22:01:34 <copumpkin> :O
22:01:48 <copumpkin> interesting, your sagenod is
22:01:59 <dmwit> heh
22:02:12 <dmwit> Hm, a 160-character type signature.
22:02:33 <dmwit> This does not bode well. I don't have a lot of practice minimizing signatures.
22:03:17 <copumpkin> at least you could fit it in a twitter bio field
22:03:23 <dmwit> I guess I understand now why people like one-letter type variables, despite being unreadable.
22:03:57 <dmwit> 77 characters then =)
22:04:21 <aavogt> well if you settle on a specific name, you could be preventing yourself from seeing the general shape of the declaration
22:05:02 <copumpkin> ooh, there's a Kyoto Cabinet too
22:05:17 <dmwit> aavogt: hm
22:06:23 <aavogt> so you might have a funcion:   fuzzyThing aReallyLongName -> fuzzyThing anotherReallyLongName
22:06:48 <aavogt> which might be easier to see, it's like a partially applied fmap
22:07:12 <aavogt> which may be more helpful than having names
22:07:24 <dmwit> Oh, sure.
22:07:40 <dmwit> But eventually you have to write functions more complicated than a partially applied fmap. =)
22:07:58 <dmwit> I take it back, you may not *have* to.
22:08:44 <dmwit> Anyway, I wrote some type signatures -- that's a productive day.
22:08:51 <dmwit> Time for bed. =)
22:15:51 <copumpkin> the >2d random walk constants are interesting
22:16:21 <copumpkin> intuitive but still odd
22:17:42 <jmcarthur> copumpkin: >2d random walk constants?
22:18:03 <copumpkin> http://mathworld.wolfram.com/PolyasRandomWalkConstants.html
22:19:11 <jmcarthur> ah
22:19:16 <jmcarthur> yeah that makes sense
22:19:51 <jmcarthur> well, that p(d) < 1 for d > 2, at least
22:20:04 <copumpkin> it feels intuitive but I can't describe why
22:21:03 <copumpkin> the triple integral certainly doesn't help :)
22:22:10 * copumpkin starts a petition to kill unnecessary Ints from libraries that don't want signedness!
22:22:37 <copumpkin> the prelude can keep its shitty ints, but new libraries should use Word if negativity is not needed!
22:23:07 <lament> i don't need your negativity!
22:23:17 <copumpkin> http://www.reddit.com/r/haskell/comments/b2bc3/vector_05_a_highperformance_haskell_array_library/c0krexj
22:23:23 * copumpkin starts chanting Word
22:23:48 <copumpkin> We are the followers of The Word
22:25:19 <Gracenotes> I let my integer types figure out their own internal representation
22:25:47 <Gracenotes> they've gotten very intelligent lately
22:26:13 <copumpkin> integer type families indexed on value
22:26:25 <copumpkin> or data families
22:27:12 <dmwit> `C/T` naming schemes?
22:27:18 <dmwit> copumpkin: What does that mean?
22:27:35 <copumpkin> Henning Thielemann's perverse type and class naming
22:28:18 <aavogt> it makes sense if you get to read the names fully qualified
22:29:25 <copumpkin> sure :)
22:30:01 <copumpkin> dmwit: in that post I'm referring more specifically to the fact that one of the major hindrances to his scheme is the fact that haddock doesn't display qualified names
22:30:11 <copumpkin> so reading documentation for any of his packages is close to impossible without hovering over all the links
22:30:30 <aavogt> @hackage toilet
22:30:31 <lambdabot> http://hackage.haskell.org/package/toilet
22:30:40 <dmwit> Okay, I was trying to read the documentation for haskore the other day.
22:30:41 <copumpkin> since type signatures look like (C a, C b, C a, Ca) => T a b -> T -> T -> T a -> T b
22:30:50 <dmwit> Now that I see it was written by him, I know exactly what you're talking about.
22:31:25 <copumpkin> he clearly has a sense of humor :)
22:31:35 <The_third_man> bonjour
22:31:38 <aavogt> his classes could be called H?
22:31:53 <jmcarthur> huh, it occurs to me that generalized functors as in http://patch-tag.com/r/jmcarthur/alt-stdlib/snapshot/current/content/pretty/Control/Functor.hs can lead to generalized morphisms with deforestation
22:32:06 <jmcarthur> for any category!
22:32:23 <copumpkin> ack
22:32:37 <copumpkin> did you actually find a use for parametrizing by Hask? :o
22:32:44 <aavogt> copumpkin: stop bitching about it and add a  --thielemann flag to haddock already :)
22:32:48 <copumpkin> lol
22:32:51 <jmcarthur> copumpkin: not the first use :P
22:32:58 <copumpkin> jmcarthur: other than CT wankery
22:33:08 <jmcarthur> arguably even this is CT wankery
22:33:22 <jmcarthur> but CT wankery is useful!
22:34:05 <copumpkin> :o
22:36:09 <aavogt> @type flip
22:36:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:37:46 <copumpkin> :t let flip f x = fmap ($x) in flip
22:37:47 <lambdabot> forall t a (f :: * -> *) b. (Functor f) => t -> a -> f (a -> b) -> f b
22:38:03 <copumpkin> :t let flip f x = fmap ($x) f in flip
22:38:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:38:17 <copumpkin> @pl flip f x = fmap ($x) f
22:38:17 <lambdabot> flip = fix (flip . (fmap .) . ($ id))
22:38:28 <aavogt> @type (<$)
22:38:29 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
22:38:30 <copumpkin> o.O
22:38:34 <copumpkin> @pl flop f x = fmap ($x) f
22:38:34 <lambdabot> flop = flip (fmap . flip id)
22:38:42 <copumpkin> wow, it confused @pl
22:39:46 <aavogt> @pl fix f = fix (fix (fix f))
22:39:47 <lambdabot> fix = fix (ap (.) (join (.)))
22:40:48 <copumpkin> :t (fmap .) . ($)
22:40:49 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> a -> b) -> a1 -> f a -> f b
22:41:15 <copumpkin> :t (fmap .) . flip ($)
22:41:16 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => a1 -> (a1 -> a -> b) -> f a -> f b
22:43:22 <copumpkin> oh, nice: http://hackage.haskell.org/package/cuda-0.1
22:44:05 <copumpkin> ah, you can't write the functions in haskell
22:45:09 <aavogt> jmcarthur: if it isn't already in your TODO, the alt-stdlib classes should probably document what's needed for a minimal complete implementation
22:45:48 <aavogt> looking at   class Category (~>) => CategoryProduct (~>) where
22:46:32 <savonarola> in ghci, how one shoul import classes for State monad?  import Control.Monad.State fails.
22:46:47 <copumpkin> :m +
22:47:20 <dmwit> Upgrade GHC, import syntax is supported now.
22:47:29 <copumpkin> oh really?
22:47:32 <copumpkin> :o
22:47:35 <copumpkin> nice!
22:47:35 <savonarola> ':m +Control.Monad.State' fails as well
22:47:49 <dmwit> Not all of it, but at least "import C.M.State" would work. =)
22:47:54 <copumpkin> try adding a space
22:47:54 <dmwit> savonarola: Have you got mtl installed?
22:48:00 <copumpkin> dmwit: so still no qualified imports?
22:48:30 <dmwit> I guess not.
22:48:41 <aavogt> there was some .ghci hack to work around this by writing to a stub .hs and loading that....
22:48:59 <aavogt> of course you then have to write :import qualified ....
22:49:17 * copumpkin likes http://snapplr.com/4rwf
22:49:45 <dmwit> tuple sections' time has come
22:50:11 <savonarola> installing libghc6-mtl-doc libghc6-mtl-dev solved the problem, thanks a lot
22:50:21 <dmwit> The question is, does () parse as unit or as the section for a one-tuple??
22:50:30 <aavogt> there are no one-tuples
22:50:48 <dmwit> whoosh?
22:50:49 <aavogt> > (((((((((((((((((((((((((((())))))))))))))))))))))))))))
22:50:49 <lambdabot>   ()
22:50:54 <copumpkin> does anyone know where 1 as a type comes from or where it's described?
22:51:14 <dmwit> It comes from combinatorics!
22:51:16 <aavogt> probably :)
22:51:28 <copumpkin> why isn't type 2 = Bool then?
22:51:46 <copumpkin> :k 2
22:51:47 <lambdabot> Only unit numeric type pattern is valid
22:51:49 <copumpkin> that really bothers me :P
22:51:54 <jmcarthur> aavogt: yeah thanks
22:52:03 <copumpkin> it also hinders future efforts at having type-level number literals
22:52:09 <copumpkin> I'm sure byorgey hates it!
22:52:16 <dmwit> copumpkin: Also, independently CT invented the categories n.
22:52:16 <jmcarthur> aavogt: i'm still experimenting with most of that stuff. not worth documenting something so mutable i think
22:52:31 <dmwit> But I can't remember how they're defined.
22:52:48 <copumpkin> but in GHC's case
22:52:54 <dmwit> oh
22:52:55 <copumpkin> I don't even know what data constructor 1 has
22:53:00 <dmwit> Dunno about GHC. =)
22:53:06 <copumpkin> I just know that it's accepted as a type and it's weird
22:53:09 <dmwit> :k 1
22:53:10 <lambdabot> *
22:53:24 <copumpkin> I'd think that it would at least be hidden behind a LANGUAGE pragma
22:53:32 <dmwit> huh
22:53:39 <copumpkin> I vaguely remember it being related to some generics library
22:53:57 <aavogt> > let 1 :: 1; 1 = Prelude.1; in 1
22:53:57 <lambdabot>   <no location info>: Invalid type signature
22:54:02 <dmwit> data GHC.Generics.Unit = GHC.Generics.Unit
22:54:11 <dmwit> :t GHC.Generics.Unit :: 1
22:54:12 <lambdabot> Unit
22:54:15 * dmwit wins
22:54:25 <copumpkin> ah, nice
22:54:30 <copumpkin> how did you find that so quickly?
22:54:40 <dmwit> Try this in ghci:
22:54:42 <dmwit> :t () :: 1
22:54:43 <lambdabot>     Couldn't match expected type `Unit' against inferred type `()'
22:54:44 <lambdabot>     In the expression: () :: 1
22:54:47 <copumpkin> oh :)
22:54:51 <dmwit> =)
22:55:16 <copumpkin> so really it's just because someone thought it would be prettier to write 1 :+: a instead of () :+: a ?
22:55:38 <aavogt> I don't think that generics is used much
22:56:00 <copumpkin> :k Mu ((:+:) 1)
22:56:01 <lambdabot> *
22:56:02 <aavogt> at least compared to syb
22:56:08 <copumpkin> yay, Naturals!
22:56:25 <copumpkin> :k Mu (1 :+:)
22:56:26 <lambdabot> parse error on input `)'
22:57:00 <copumpkin> :t In
22:57:01 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
22:57:14 <copumpkin> :t In Nothing
22:57:15 <lambdabot> Mu Maybe
22:58:45 <copumpkin> type family Simplify * :: *; type instance Simplify (1 :*: a) = a; type instance Simplify (a :*: 1)  = a
22:58:47 <copumpkin> pity they overlap
23:31:13 <tomoyuki28jp> I just installed ghc on my Snow Loepard machine, but when I run `cabal install cabal-install`, I get this error: 'cabal-install-0.6.4 failed during the configure step. The exception was: exit: ExitFailure 1'. How can I fix this problem?
23:33:49 <domor> if you look before exitfailure, is there no other error message?
23:36:11 <tomoyuki28jp> domor: I only see the error message on terminal. Is there a way to check the detail of the failure?
23:37:21 <tomoyuki28jp> domor: oh, I see this error message too: ghc: Can't find package.conf as /Library/Frameworks/inplace-datadir/package.conf
23:41:08 <domor> tomoyuki28jp: I'm no cabal expert, but perhaps you could try doing it manually
23:41:15 <domor> the procedure is at http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
23:42:16 <tomoyuki28jp> domor: thanks a lot for the info.
23:42:33 <tomoyuki28jp> I just want to install darcs...
23:53:33 <shapr> "Mathematicians stand on each other’s shoulders while computer scientists stand on each other’s toes." -- R.W. Hamming
