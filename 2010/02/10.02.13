00:16:44 <PoissonPilote> hey guys
00:16:50 <PoissonPilote> I'd need some help, Haskell beginner here
00:16:57 <Jonno_FTW> ok go
00:17:10 <PoissonPilote> I need a function that gives me the treble of 3 numbers, in order
00:17:20 <Jonno_FTW> in a list?
00:17:22 <PoissonPilote> so for example ordertriple 1 3 5 would output
00:17:32 <PoissonPilote> (3 9 15)
00:17:34 <PoissonPilote> in a tuple
00:17:44 <PoissonPilote> here's the given prototype
00:17:44 <PoissonPilote> orderTriple :: (Int,Int,Int) -> (Int,Int,Int)
00:17:56 <Jonno_FTW> treblethree a b c = (a*3,b*3,c*3)
00:18:19 <PoissonPilote> well that doesn't sort them - I guess my output wasn't explicit enough
00:18:20 <Jonno_FTW> > let treblethree a b c = (a*3,b*3,c*3) in treblethree 1 3 5
00:18:20 <lambdabot>   (3,9,15)
00:18:25 <Jonno_FTW> like that?
00:18:35 <PoissonPilote> ordertriple 1 4 3 would output (3 9 12)
00:18:38 <PoissonPilote> it also orders them
00:18:41 <Jonno_FTW> ok
00:19:01 <dmwit> PoissonPilote: This sounds awfully homework-like.
00:19:05 <PoissonPilote> yup it is
00:19:05 <Jonno_FTW> treblethree a b c =sort [a*3,b*3,c*3]
00:19:12 <Jonno_FTW> it is pretty easy stuff
00:19:17 <PoissonPilote> well let me finish :P
00:19:18 <dmwit> We have a strict policy on homework: we only to it for big, tall moneys.
00:19:31 <copumpkin> at least 50 cents
00:19:32 <copumpkin> no less!
00:19:35 <PoissonPilote> hah well let me just cut down to the chase
00:19:35 <Jonno_FTW> yes, a lot e-kudos is required for assistance
00:19:38 <PoissonPilote> I have
00:19:42 <PoissonPilote> ordertriple (a,b,c) = [ (i,j,k) | i <- (min3 a b c), j <- (middle a b c), k <- (max3 a b c) ]
00:19:49 <PoissonPilote> where min3 is the min of 3 numbers
00:19:54 <Jonno_FTW> > let treblethree a b c =sort [a*3,b*3,c*3] in treblethree 1 3 5
00:19:55 <lambdabot>   [3,9,15]
00:19:55 <PoissonPilote> max3 the max of 3
00:20:01 <PoissonPilote> and middle gives the middle one
00:20:06 <PoissonPilote> homework guidelines :(
00:20:09 <PoissonPilote> and I get an error
00:20:17 <PoissonPilote> so I don't get where my syntax is wrong
00:20:27 <dmwit> Is min3 really returning a list?
00:20:30 <Gracenotes> [ ...| ... <- ... ] - list comprehensions are for lists
00:20:31 <Jonno_FTW> then use another function listtotuple [a,b,c] = (a,b,c)
00:20:34 <dmwit> If not, you can't use it that way in a list comprehension.
00:20:37 <copumpkin> wow, that's really ugly
00:20:50 <PoissonPilote> copumpkin: yeah, but homework guidelines :( i need to use these 3 functions
00:20:53 <Gracenotes> PoissonPilote: something to know to distinguish, lists and tuples
00:21:04 <copumpkin> yeah, I mean it's really ugly for the homework to give you those functions
00:21:12 <PoissonPilote> dmwit: min3 returns a single int
00:21:17 <idnar> PoissonPilote: I don't think you want a list comprehension at all
00:21:20 <PoissonPilote> the smallest of the 3 numbers
00:21:23 <idnar> what makes you think you do?
00:21:25 <dmwit> PoissonPilote: better not use a list comprehension, then =)
00:21:43 <copumpkin> replace all your ( with [ and your ) with ]
00:21:49 <copumpkin> :P
00:21:54 <Jonno_FTW> > let treblethree a b c =head $ map (\[x,y,z]->(x,y,z)) $ sort [a*3,b*3,c*3] in treblethree 1 3 5
00:21:55 <lambdabot>   No instance for (GHC.Num.Num [t])
00:21:55 <lambdabot>    arising from a use of `treblethree' at...
00:22:07 <idnar> copumpkin: that's awful :P
00:22:14 <Jonno_FTW> i know
00:22:17 <Jonno_FTW> that's the idea
00:22:17 <PoissonPilote> copumpkin: wouldn't that give me a list? (replacing the brackets)
00:22:33 <copumpkin> PoissonPilote: yes, then you'd convert it to a tuple, but I wasn't being serious
00:22:35 <Jonno_FTW> convert your list to a tuple
00:22:37 <dmwit> My prediction: PoissonPilote will kick himself when he sees the right answer.
00:22:39 <copumpkin> I feel dirty for even suggesting that
00:22:42 <Jonno_FTW> or vice versa
00:22:42 <PoissonPilote> the prototype is also homework specific
00:22:44 <PoissonPilote> orderTriple :: (Int,Int,Int) -> (Int,Int,Int)
00:23:01 <PoissonPilote> so if I'm not mistaken, i'm dealing with tuples all the way
00:23:03 <dmwit> PoissonPilote: Go take another crack at it and report back in 5-10 minutes.
00:23:10 <copumpkin> PoissonPilote: the answer they're looking for is extremely simple
00:23:17 <copumpkin> you can fit it on one short line
00:23:48 <PoissonPilote>  ok, will report back in a bit- I was just confused by the "The type signature for orderTriple lacks an accompanying binding"
00:24:02 <PoissonPilote> I just don't get if it's a syntax error, or a conceptual error from my part
00:24:11 <dmwit> That means you probably made a typo.
00:24:13 <copumpkin> it's just a warning
00:24:21 <dmwit> No, that's an error.
00:24:35 <copumpkin> oh yeah
00:24:37 <PoissonPilote> yeah, it says "Failed, modules loaded: none
00:24:38 <dmwit> The typo is either in the name you gave in the type annotation or in the name you gave in the function definition.
00:24:44 <idnar> PoissonPilote: orderTriple isn't the same as ordertriple
00:24:44 <dmwit> Look closely. =)
00:24:53 <dmwit> It should give you a line number, too.
00:25:14 <idnar> PoissonPilote: Haskell is case sensitive
00:25:24 <PoissonPilote> :facepalm:
00:25:42 <PoissonPilote> ok, well now I get a more detailed error though, I will look on that and let you guys know in a bit how it goes
00:25:46 <PoissonPilote> thanks for everything so far
00:25:51 <dmwit> cheers
00:26:18 <Jonno_FTW> orderTriple a b c = [(\[x,y,x]->(x,y,z)) xs|m<-[a,b,c], xs <- map (*3) m]
00:26:38 <Jonno_FTW> let orderTriple a b c = [(\[x,y,x]->(x,y,z)) xs|m<-[a,b,c], xs <- map (*3) m] in orderTriple 4 2 6
00:26:42 <Jonno_FTW> > let orderTriple a b c = [(\[x,y,x]->(x,y,z)) xs|m<-[a,b,c], xs <- map (*3) m] in orderTriple 4 2 6
00:26:42 <lambdabot>   Conflicting definitions for `x'
00:26:42 <lambdabot>  In a lambda abstraction
00:26:51 <dmwit> augh
00:26:53 <dmwit> Just start over.
00:26:57 <dmwit> Forget list comprehensions.
00:26:59 <Jonno_FTW> how the hell do i use lambdas like that?
00:27:01 <dmwit> Forget lists entirely.
00:27:25 <Jonno_FTW> but i wanna know
00:27:37 <Jonno_FTW> > let orderTriple a b c = [head $ map (\[x,y,x]->(x,y,z)) xs|m<-[a,b,c], xs <- map (*3) m] in orderTriple 4 2 6
00:27:38 <lambdabot>   Conflicting definitions for `x'
00:27:38 <lambdabot>  In a lambda abstraction
00:27:39 <dmwit> Check your pattern carefully. =)
00:27:50 <dmwit> \[x,y,x] should probably be \[x,y,z]
00:27:51 <copumpkin> Jonno_FTW: you have a repeated x in the list
00:27:59 <Jonno_FTW> oh right
00:28:01 <dmwit> Read the error message carefully: it says exactly the same thing.
00:28:06 <Jonno_FTW> > let orderTriple a b c = [head $ map (\[x,y,z]->(x,y,z)) xs|m<-[a,b,c], xs <- map (*3) m] in orderTriple 4 2 6
00:28:07 <lambdabot>   No instance for (GHC.Num.Num [[[t]]])
00:28:07 <lambdabot>    arising from the literal `4' at <i...
00:28:07 <copumpkin> [x,y,.x] :P
00:28:17 <copumpkin> (if you had an agda-like thingy)
00:28:20 <dmwit> copumpkin: gb2 #agda
00:28:28 <copumpkin> :(
00:28:29 <PoissonPilote> ok, got it
00:28:32 <copumpkin> it's not true agda
00:28:33 <PoissonPilote> it was stupid as hell
00:28:34 <PoissonPilote> :P
00:28:40 <PoissonPilote> orderTriple :: (Int,Int,Int) -> (Int,Int,Int) orderTriple (a,b,c) = ((min3 a b c)*3, (middle a b c)*3, (max3 a b c)*3)	
00:28:48 <dmwit> PoissonPilote: Great!
00:28:48 <copumpkin> cause agda doesn't have [..]
00:28:53 <idnar> PoissonPilote: :)
00:29:05 <dmwit> copumpkin: Seems like you could define it, what with their mix-fix stuff.
00:29:12 <copumpkin> dmwit: not in a pattern though
00:29:12 <Jonno_FTW> PoissonPilote: you should use a "where" statement to clean that up
00:29:19 <copumpkin> I've defined it for values
00:29:22 <PoissonPilote> I'm a starter in Haskell and have been using imperative languages for so many years, that I thought of the bracket notation as a function
00:29:24 <copumpkin> but it eats up valuable stuff
00:29:26 <PoissonPilote> not a list comprehension
00:29:31 <PoissonPilote> but I think I make the distinction now
00:29:33 <dmwit> PoissonPilote: Personally, I'd separate the sorting step and the tripling step, but that's a stylistic thing.
00:30:11 <dmwit> PoissonPilote: (Of course, I probably wouldn't bother with min3, middle, and max3, either. =P)
00:30:24 <PoissonPilote> dmwit: Yeah, homework assignments ftw :p
00:30:53 <Jonno_FTW> where do they teach Haskell as a programming language?
00:31:10 <dmwit> > let orderTriple = (\[x, y, z] -> (x, y, z)) . map (*3) . sort . (\(x, y, z) -> [x, y, z]) in orderTriple (4, 2, 6)
00:31:11 <lambdabot>   (6,12,18)
00:31:37 <PoissonPilote> Jonno_FTW: I'm currently in my final year at Oxford Brookes, in the UK- I'm taking Declarative Programming a) for the kicks and b) because I'm applying for PhDs next year and figured it'd be a nice skill to have
00:31:49 <Jonno_FTW> dmwit: needs more golf
00:31:54 <idnar> @pl \[x, y, z] -> (x, y, z)
00:31:54 <lambdabot> (line 1, column 2):
00:31:54 <lambdabot> unexpected "["
00:31:54 <lambdabot> expecting pattern
00:31:57 <dmwit> > let orderTriple = map (*3) . sort in orderTriple [4,2,6] -- but you lose a static guarantee of having exactly three elements
00:31:58 <lambdabot>   [6,12,18]
00:32:01 <idnar> aww
00:32:09 <dmwit> Jonno_FTW: Why?
00:32:09 <copumpkin> Jonno_FTW: they teach it in the second prerequisite for CS major here
00:32:13 <idnar> @pl \(x,y,z) -> [x,y,z]\
00:32:13 <lambdabot> (line 1, column 6):
00:32:13 <lambdabot> unexpected ","
00:32:13 <lambdabot> expecting letter or digit, operator or ")"
00:32:13 <lambdabot> ambiguous use of a non associative operator
00:32:14 <idnar> @pl \(x,y,z) -> [x,y,z]
00:32:15 <lambdabot> (line 1, column 6):
00:32:15 <lambdabot> unexpected ","
00:32:17 <lambdabot> expecting letter or digit, operator or ")"
00:32:18 <Jonno_FTW> for the sake of gold
00:32:19 <lambdabot> ambiguous use of a non associative operator
00:32:21 <Jonno_FTW> *golf
00:32:25 <PoissonPilote> copumpkin: Where are you studying?
00:32:27 <idnar> oh okay
00:32:31 <copumpkin> dartmouth
00:32:37 <copumpkin> it's a recent addition though
00:32:46 <copumpkin> used to be scheme when I took it a few years ago
00:32:52 * dmwit disagrees with golf for the sake of golf
00:33:01 <dmwit> ...but I didn't always. =)
00:33:05 <PoissonPilote> well at my current uni, if you go only with the requirements, you'd be a poor CS grad...
00:33:12 <Jonno_FTW> i find it impressive that things can be golfed up so
00:33:38 <idnar> > let orderTriple (x,y,z) = (i,j,k) where [i,j,k] = map (*3) . sort $ [x,y,z]
00:33:40 <lambdabot>   not an expression: `let orderTriple (x,y,z) = (i,j,k) where [i,j,k] = map (...
00:33:44 <idnar> > let orderTriple (x,y,z) = (i,j,k) where [i,j,k] = map (*3) . sort $ [x,y,z] in orderTriple (4, 2, 6)
00:33:46 <lambdabot>   (6,12,18)
00:33:47 <PoissonPilote> I'm an exchange student for my final year though, I come from France- and in France, courses tend to be much more theoretical/research oriented - Prolog, Haskell, etc. are commonly taught as reqs
00:34:24 <Jonno_FTW> i'm starting software engineering at my uni, and will have to learn Java and C++
00:34:31 <PoissonPilote> Jonno_FTW: classics :D
00:34:42 <idnar> I absolutely detest "homework" type problems like that
00:34:51 <Jonno_FTW> all i know is TI-Basic and Haskell
00:34:56 <PoissonPilote> bah, they're good for getting the kick of a language
00:34:57 <dmwit> :t min &&& max
00:34:58 <lambdabot> forall b. (Ord b) => b -> (b -> b, b -> b)
00:35:06 <dmwit> hm
00:35:10 <copumpkin> :P
00:35:24 <idnar> PoissonPilote: I'd debate that
00:35:26 <dmwit> ?pl \x y -> (min x y, max x y)
00:35:26 <PoissonPilote> Jonno_FTW: TI-Basic \o/ I learned programming with that thing, like 10 years ago
00:35:26 <lambdabot> ap (ap . ((,) .) . min) max
00:35:33 <idnar> PoissonPilote: they might be useful for finding your way around syntax and so on
00:35:50 <Jonno_FTW> i had to, it's the only language we could use in maths exams on a calculator
00:35:55 <idnar> PoissonPilote: but the reason why this function is so awkward to define is because you'd never do it in a real progrif you didn't have to
00:36:03 <Jonno_FTW> apart from learning assembly
00:36:05 <dmwit> :t liftM2 (&&&) min max
00:36:05 <idnar> er, never do it in a real program if you didn't have to
00:36:06 <lambdabot> forall c'. (Ord c') => c' -> c' -> (c', c')
00:36:11 <dmwit> ahhh
00:36:22 <PoissonPilote> idnar: truth, but then you get the mindset for some more complex mathematical problems
00:36:27 <dmwit> > liftM2 (&&&) min max 5 3
00:36:28 <lambdabot>   (3,5)
00:36:37 <PoissonPilote> idnar: I'm a frequent member of project euler (but i do not use haskell :D )
00:36:46 <Jonno_FTW> i do project euler
00:36:59 <copumpkin> I used to do it
00:37:09 <PoissonPilote> idnar: and for high performance computing, theoretical stuff, etc., it's a neat mindset to have
00:37:15 <Jonno_FTW> i started 277 the other day and solved the test case but the proper solution is beyond me
00:37:24 <rhz> try my haskell cgi program: http://115.128.64.40/~rhz/cgi-bin/WebHarmony.cgi
00:37:28 <idnar> PoissonPilote: I think it teaches bad habits
00:37:30 <copumpkin> ugh
00:37:33 <idnar> PoissonPilote: but okay, enough of my soapboxing
00:38:03 <copumpkin> toy cars, eh
00:38:31 <PoissonPilote> idnar: :P as with everything, moderation's the key- it's good to know how to solve these, but one shouldn't limit his experience to solely these exercises
00:38:43 <copumpkin> rhz: you set off my human spam filter, fwiw
00:38:58 <Jonno_FTW> rhz: pretty good stuff
00:39:05 <copumpkin> but otherwise, I like it :)
00:39:46 <copumpkin> 1. Join channel, 2. Post link saying "check out my cool stuff... http://ip address/obscure path/" 3. ??? 4. profit
00:39:52 <rhz> copumpkin: obviously my reputation precedes me. I'll take that as a compliment I guess
00:40:09 <rhz> yes I'm working on 3
00:40:11 <copumpkin> :)
00:41:14 <dmwit> I can't make it do anything.
00:41:17 <dmwit> =/
00:41:30 <cads> PoissonPilote, have you done Laserbeam? http://projecteuler.net/index.php?section=problems&id=202
00:41:53 <copumpkin> dmwit: try the example, worked for me
00:42:15 <PoissonPilote> cads: nope, I'm trying to do them somewhat in order, and iirc i've only got like the first 30 done
00:42:25 <PoissonPilote> cads: sorry, you're one big step ahead of me :P
00:42:38 <cads> Hehe, nah, that's the only higher one I could do
00:42:51 <copumpkin> I remember a couple of the high ones were pretty easy
00:42:55 <dmwit> copumpkin: It loads up my media player, but doesn't play anything; if I try wget'ing the same URL, I get nonsense.
00:43:15 <rhz> maybe wget it and put a .mov at the end of the file
00:43:15 <dmwit> also @rhz
00:43:16 <PoissonPilote> well I've been using python until now, but I realize haskell could help things a little
00:44:14 <Gracenotes> cads: hm.. it has to bounce off the point at the end of C's bisection, right
00:44:16 <rhz> no that doesn't work
00:44:17 <dmwit> The result is only 1156 bytes long, I can't imagine that's any real kind of media.
00:44:25 <copumpkin> dmwit: .mid?
00:44:27 <Jonno_FTW> i've done 57 project euler questions
00:44:34 <rhz> it's basically a midi file
00:44:48 <dmwit> Oh, hm.
00:44:49 <Jonno_FTW> rhz: the sound worked fine for me
00:44:53 <Gracenotes> -.- there must be some angle summing trick. anyway.
00:44:56 <dmwit> I wonder if I know how to play a midi file.
00:44:59 <rhz> content type is audio/midi. I think most browsers should handle it ok
00:45:10 <dmwit> I seem to remember there's something odd about that...
00:45:12 <copumpkin> I wonder if file knows about midi files
00:45:22 <dmwit> yep, it does
00:45:30 <PoissonPilote> you need a midi sequencer installed to play those
00:45:39 <dmwit> okay, time to grab a sequencer
00:45:46 <PoissonPilote> ...which most OS have out of the box
00:46:06 <PoissonPilote> like on Linux, ALSA does it iirc
00:46:07 <rhz> yeah it's maybe not that linux friendly
00:46:14 <PoissonPilote> haven't tinkered with Linux in a while
00:46:23 <PoissonPilote> but you should get it to play with mplayer
00:46:49 <cads> Gracenotes, I was half way through implementing a raytracer with support for irrational numbers, which was going to solve that problem in a way I know not how, when the answer fell on me like a metric ton of bricks - if you draw a equilateral triangle grid then a line drawn between vertices on that grid represents an "unfolding" of a raypath which bounces around the inside of the triangle to exit at a certain vertex.
00:46:55 <rhz> but it should work in linux too
00:48:33 <Gracenotes> cads: went a bit over my head
00:49:36 <Gracenotes> hm
00:50:32 <dmwit> cads: That is beautiful.
00:52:05 <dmwit> Anybody else getting stray "muKusageInfo: internal name? g{gibberish}" messages when building stuff?
00:52:11 <Gracenotes> cads: by grid, do you mean like Sierpinski?
00:52:19 <dmwit> no
00:52:27 <cads> Gracenotes, I wish there was a online collaborative cad software... imagine a long parallelogram strip of paper creased on lines that make it into a series of triangles like  /\/\/\/\/   then draw a line between the two furthest corners.
00:52:39 <dmwit> http://math.rice.edu/~lanius/images/triangle.gif
00:53:53 <cads> Fold the piece of paper and imagine that you have xray vision so you can see the way the line is folded. The path of the segmented line will be exactly the path of a light ray bouncing between the edges of the triangle.
00:55:31 <PoissonPilote> Is it normal that the more I work with Haskell, the more I fall in love with it?
00:55:43 <dmwit> No!
00:55:46 <Jonno_FTW> yes
00:55:47 <Jonno_FTW> !
00:55:47 <dmwit> Everybody else in here hates it.
00:56:04 <cads> that's why where in haskell-/BLAAH/
00:56:06 <PoissonPilote> It's like an elegant eagle that grasps me in its claws, gets me high in the sky, and lets me see the land of programming like never before
00:56:16 <Jonno_FTW> where's HaskellLove when you need him
00:56:36 <Gracenotes> :|
00:56:43 <Jonno_FTW> or not
00:56:49 <Gracenotes> cads: aaaaahhhh
00:57:06 <cads> Jonno_FTW, if you let him in here ddarius will punch you
00:57:12 <Gracenotes> cads: and on the other side of the mirror, there's a world that's exactly like this one
00:57:19 <Jonno_FTW> i'll be good
00:57:44 <Gracenotes> that is cute
00:58:34 <Gracenotes> it helped to open up dmwit's image in GIMP and actually draw a line
00:59:08 <dmwit> rhz: whew, finally got it working
00:59:26 <rhz> dmwit: great
00:59:38 <dmwit> rhz: I played it with instrument 125_Helicopter and it was awesome.
01:00:07 <cads> Gracenotes,  yup, it's very cute.. then all you have to do is find all the C-vertex reflections which are 12017639147 line crossings away on the grid, which is simple but I don't remember how I did it exactly.
01:00:21 <rhz> dmwit: I didn't record the time your ip address got logged.. but wasn't it a while ago?
01:01:20 <Gracenotes> cads: it helps that it can only pass through edges
01:01:35 <dmwit> First I had to discover that I needed a sequencer, then I had to pick the best sequencer to install, then I discovered that I had to install sequencer patterns separately, then it took some minutes to extract all the patterns, then I had to fight the sequencer to recognize where the patterns were...
01:01:53 <dmwit> I can't say it was the most pleasant experience.
01:02:13 <dmwit> So, does the harmonization take into account things like parallel fifths, etc.?
01:02:20 <rhz> well then your not that into midi files then
01:02:26 <rhz> yes
01:02:42 <rhz> I should put the source code up somewhere
01:02:56 <dmwit> yes
01:04:13 <Gracenotes> I entered in a melody.. waiting
01:05:25 <rhz> http://code.haskell.org/satb-harmoniser/WebHarmony.hs
01:05:27 <Gracenotes> timidity doesn't seem to recognize the midi file as valid
01:05:44 * hackagebot upload: binary-strict 0.4.7 - Binary deserialisation using strict ByteStrings (DominicSteinitz)
01:05:52 <cads> Gracenotes, the answer is actually simple enough that you'll freak.
01:06:09 <dmwit> timidity -x'bank 0\n0 /usr/share/timidity/freepats/Tone_000/046_Harp.pat' # Gracenotes
01:06:24 <dmwit> cads: What, like 6 or something?
01:06:50 <cads> lemme see if I can derive it again
01:07:09 <idnar> PoissonPilote: yeah, the only problem is that once you're up there, there aren't any comfortable ways to get back down
01:07:47 <Gracenotes> dmwit: oh, that's weird.. the file I downloaded was empty
01:08:12 <Gracenotes> I'll try again so I can hear my beautiful melody (which btw is 0,1,4,3,5,6,6,5,3,6,5,7,7,6,7)
01:08:58 <dmwit> Gracenotes: Hm, that just happened to me, too.
01:09:12 <Gracenotes> :| again
01:09:13 <dmwit> rhz: I just got an empty file, what gives?
01:09:17 <rhz> it won't work unless it begins and ends on one of these: {0,4,7,9}
01:09:23 <dmwit> oh
01:09:25 <dmwit> 0
01:09:35 <Gracenotes> I ended it on high C, 7
01:10:02 <dmwit> I was using the stupid music theory convention where 1 is the key.
01:10:03 <rhz> probably should give better error reporting somehow. dunno how though
01:10:50 <Gracenotes> my melody seems valid, but it gives an empty file
01:11:44 <rhz> there are some other caveats too. Don't put a huge leap from 0 to 8. This is difficult to sing easily.
01:11:56 <dmwit> Your program is thinking awfully hard about "Happy Birthday".
01:12:19 <Gracenotes> wait.. screwed up the of-by-one thing again
01:13:16 <rhz> 4,4,5,4,7,6,4,4,5,4,8,7,4,4,11,9,7,6,5,10,9,7,8,7
01:13:19 <rhz> is happy birthday I think
01:13:33 <dmwit> Yeah, I screwed it up royally.
01:13:37 <dmwit> whatever
01:13:40 <rhz> yep
01:14:03 <rhz> a bit more practise and you'll get it though I'm sure..
01:14:04 <Gracenotes> wait, 7 is Bb? isn't it B?
01:14:21 <rhz> 7 is C
01:14:35 <Gracenotes> oh, right, that's in the key of G, not F
01:14:40 <dmwit> Even if I screwed it up, the machine can't know that. =P
01:16:47 <rhz> dmwit: the machine knows that 0 to 8 is a valid interval for any of the parts. In theory the melody should not have that restriction though..
01:17:07 <rhz> but for many reasonable examples this isn't a problem
01:17:34 <rhz> *is not a valid interval
01:17:55 <dmwit> my revised example (which has been churning for some minutes now) has no 0-8 leaps
01:18:14 <dmwit> 0-7 is the largest
01:19:10 <rhz> dmwit: try pressing back and retrying it. Something must have gone wrong in the net
01:19:16 <Gracenotes> > map (\(x:xs) -> mod (ord x+3) 7 + 7*length xs) $ words "C D F E G A A G E A G C' C' B C'"
01:19:17 <lambdabot>   [0,1,3,2,4,5,5,4,2,5,4,7,7,6,7]
01:19:19 <Gracenotes> maybe this will help
01:19:41 <Gracenotes> I can't think in numbers so easily
01:22:29 <rhz> dmwit: your example seems to work now then?
01:22:33 * dmwit nods
01:22:44 <Gracenotes> does it use randomness at all, the algorithm?
01:22:55 <rhz> although it's not Happy Birthday.
01:22:58 <Gracenotes> well. it imports System.Random, so I'm guessing yes
01:23:01 * dmwit nods again
01:23:14 <rhz> Gracenotes: no
01:23:32 <Gracenotes> hm, right.. /random doesn't give anything
01:24:13 <rhz> thats true
01:24:15 <rhz> red herrring
01:24:18 <rhz> i gueess
01:24:28 <dmwit> :t find
01:24:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:24:32 <shachaf> Is there any reason other than historical that musical notes are named by this annoying system?
01:24:41 <rhz> which system is that?
01:24:49 <dmwit> :t \p -> fmap snd . find (p . fst)
01:24:50 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe b
01:25:01 <Gracenotes> what other reason do you need? :)
01:25:04 <shachaf> rhz: As in "C C# D D# E F" etc.
01:25:24 <rhz> yes. I think the answer is historical
01:25:31 <Gracenotes> you want a new notation system for the 12-tone scale specifically, right?
01:25:51 <shachaf> Gracenotes: I also want a new piano layout. :-)
01:26:02 <dmwit> :t inRange
01:26:03 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
01:26:13 <mauke> shachaf: yes, with x and y swapped. and umlauts!
01:26:14 <Gracenotes> the piano is certainly optimized for the key of C (as we call it)
01:27:08 <shachaf> Gracenotes: There's no reason for it to be optimized for *any* key or diatonic scale.
01:27:21 <shachaf> The Jankó keyboard seems much nicer.
01:27:32 <rhz> It is really optimised for a natural minor I think.
01:28:00 <dmwit> :t \l -> do { (x:xs) <- tails l; y <- xs; return (x, y) }
01:28:01 <lambdabot> forall a. [a] -> [(a, a)]
01:28:34 <dmwit> > let f l = [(x, y) | x:xs <- tails l, y <- xs] in f [1..4]
01:28:35 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
01:29:37 <dmwit> ?src (\\)
01:29:37 <lambdabot> (\\) = foldl (flip delete)
01:30:30 <Gracenotes> shachaf: whether thinking in terms of the piano better lends itself to creative composition than the Janko keyboard is not an easy question to answer
01:30:54 <shachaf> Gracenotes: Hm? Why would it?
01:31:32 <Gracenotes> looking at the diagram again, it looks like it's constructed from piano segments :)
01:32:09 <shachaf> Gracenotes: What do you mean?
01:32:32 * shachaf considers going to #-blah?
01:33:31 <Gracenotes> well, the C/C#/D/D#/E and F/F#/.../A#/B clusters
01:34:29 <shachaf> Gracenotes: Well, it's just a pattern of WBWBWBWBWBWB instead of WBWBWWBWBWBW.
01:34:38 <Gracenotes> except if the keys look all the same, you could say the same thing about G#/.../C and C#/G clusters
01:34:50 <Gracenotes> *C#/.../G
01:35:55 <Gracenotes> shachaf: oh... everything in a row is pressed together?
01:36:15 <shachaf> Gracenotes: That seems more sensible, does it?
01:36:43 <Gracenotes> yeah. just watching some YouTube videos.. I wonder if one of those exist somewhere close to here
01:37:03 <shachaf> Gracenotes: With the regular piano layout, you have a different "pattern" for the major scale for every key, for instance. With the Jankó keyboard you only have one.
01:37:21 <tensorpudding> i'm not sure if i should alway import Control.Applicative just so i can use <$> instead of fmap
01:37:30 <shachaf> Gracenotes: That would depend on where "here" is. :-)
01:37:33 <tensorpudding> but i love <$> so much
01:37:40 <Gracenotes> in this case, Stony Brook
01:37:48 <mauke> did you mean: two
01:37:51 <Gracenotes> tensorpudding: it's in base. go for it (!)
01:38:07 <Gracenotes> :.
01:39:05 <mreh> I can't see anything about "Other-Modules: Paths_p" in the documentation, is it a macro or do I have to fully expand the Paths_p variable?
01:39:07 <shachaf> (<$>) should be in Prelude.
01:39:14 <shachaf> No, (.) should = fmap.
01:39:25 <Gracenotes> noitshouldnot
01:39:35 <mreh> only for Functors
01:39:49 <shachaf> Gracenotes: If you find one, tell me how it goes. :-)
01:40:02 <Gracenotes> perhaps I'll ask around the music department
01:40:03 <shachaf> Gracenotes: There are other instruments with various chromatic layouts, of course, such as accordions.
01:40:53 <Gracenotes> yes, I saw that searching for them
01:41:01 <rhz> Since Chopin is so well suited to play on a standard keyboard, it's going to be difficult to convince people to switch to another layout.
01:41:06 <mauke> mreh: is the package called 'p'?
01:41:15 <mreh> mauke: naw
01:41:37 <Gracenotes> rhz: that is my point about creative expression being of a particular flavor on a piano, that you might not be able to find on a more uniform structure
01:41:46 <mreh> but when it gets generated it's put in dist/build/autogen
01:41:57 <shachaf> rhz: Not to mention that people have spent their entire lives learning one layout, and so on.
01:42:58 <shachaf> Gracenotes: I would suggest that introducing pointless artificial complexity (which means you have to learn everything *12 times*, really, doesn't it?) isn't a good idea.
01:43:09 <rhz> Gracenotes: indeed. However my point was slightly different. Most piano repertoire that exists was written for the standard layout. Much of it would not be as natural to play on another layout
01:43:32 <shachaf> You can make the keyboard wrong in many many ways, but you can only simplify it so far. :-)
01:43:51 <sfuentes> anyone know how to  define a data type in ghci?
01:43:58 <Gracenotes> more accurately it could be construed as in support of my point
01:44:19 <shachaf> sfuentes: ":!echo data ... > file.hs" and then ":load file.hs"
01:44:36 <Gracenotes> complexity has more interesting emergent properties
01:44:45 <sfuentes> so it has to be in a file?
01:44:47 <shachaf> Gracenotes: True, but then why limit it to one piano layout?
01:44:52 <shachaf> sfuentes: In ghci, yes.
01:45:10 <sfuentes> thanks for that info
01:45:24 <shachaf> Gracenotes: And why not make it *more* complex? Why not arrange the keys differently in every octave? :-)
01:46:06 <Gracenotes> there is a point where complexity becomes chaos, piano doesn't reach it though
01:47:04 <Gracenotes> anyway, I'll have to get my hands on one of them and try it for myself :)
01:47:06 <shachaf> Gracenotes: My point is that the complexity is there entirely for historical reasons, and it should at least be examined, but it's just taken as it is for the sake of tradition.
01:48:07 <cads> Oh man.. don't you guys hate when you're trying to resolve an old problem and you can't fathon how you did it before?
01:49:01 <shachaf> cads: Oh, I know *exactly* what to do when that happens!
01:49:03 <shachaf> Er, wait.
01:49:10 <shachaf> Hmm. I used to know...
01:49:18 <mreh> there's lots of -blah in here today
01:49:45 <mreh> shachaf, you've typed up 2 pages of chat about keyboard layout, could you please take it to #haskell-blah
01:49:49 * shachaf apologizes.
01:50:03 <shachaf> mreh: I briefly suggested moving there before, but it didn't end up happening.
01:50:05 <Gracenotes> he did suggest it earlier. my mistake.
01:50:20 * shachaf will go there now.
01:50:25 <mreh> thank you
01:51:21 <Gracenotes> more on-topic, we could discuss how the Janko keyboard makes a good model for a multi-touch computer keyboard piano coded in Haskell :) but yeah.
01:52:31 <rhz> How is noone mentioned the fact that computer keyboards have the same artifical complexity.. yet we all use them anyhow.
01:53:20 <shachaf> rhz: Perhaps someone mentioned in in #-blah. How would you know? :-)
01:55:15 <Peaker> shachaf: why (.) = fmap   and not (.) = (Category..)?
01:57:03 <shachaf> > (Control.Category..) succ [1,2,3]
01:57:04 <lambdabot>   Not in scope: `Control.Category..'
01:57:24 <SNIPER0215> test
01:57:28 <SNIPER0215> Hello, all
01:57:50 <Peaker> shachaf: sure there are situations fmap would work and category wouldn't, and vice versa
01:58:29 <Peaker> myRecordLabel . hisRecordLabel
01:58:40 <shachaf> Peaker: fmap is very useful, so it makes sense to have a short name for it.
01:59:10 <Gracenotes> > succ (3, False)
01:59:11 <lambdabot>   No instance for (GHC.Enum.Enum (t, GHC.Bool.Bool))
01:59:11 <lambdabot>    arising from a use of...
01:59:16 <Peaker> I think composition of functions generalizes more nicely to composition of "processors", than to fmap
01:59:30 <Peaker> > succ (3, False) :: (Int, Bool)
01:59:31 <lambdabot>   No instance for (GHC.Enum.Enum (GHC.Types.Int, GHC.Bool.Bool))
01:59:31 <lambdabot>    arising f...
01:59:47 <Peaker> shachaf: what about <$> ?
01:59:49 <Gracenotes> there's no unique diagonalization
02:00:04 <Gracenotes> (more generally, enumeration)
02:01:39 <cheater2> hi, sup
02:01:51 <cheater2> so what are monads?
02:02:28 <shachaf> cheater2: Monads are like coffins.
02:02:30 <SNIPER0215> Can I post links?
02:02:39 <cheater2> shachaf: ?
02:02:51 <mauke> @quote Duqicnk
02:02:51 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
02:03:03 <shachaf> @quote monad
02:03:03 <lambdabot> inv2004 says: lambdabot: monads ?
02:03:14 <SNIPER0215> lol
02:03:22 <cheater2> wat
02:03:44 <mauke> cheater2: a monad is a type that's an instance of Monad
02:04:00 <cheater2> oh ok!!!
02:04:40 <mauke> class Monad m where { return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b }
02:05:26 <SNIPER0215> huh?
02:05:39 <mauke> if (>>=) is too complicated, it may help to decompose it into liftM :: (a -> b) -> m a -> m b and join :: m (m a) -> m a
02:05:53 <cheater2> mhm
02:07:26 <mauke> ANY QUESTIONS
02:07:31 <cheater2> yes
02:07:36 <cheater2> why did you bring up >>=
02:07:44 <cheater2> what is it
02:07:44 <mauke> because it's a part of Monad
02:07:49 <mauke> uh, a method?
02:07:57 <cheater2> i thought we were talking about types
02:08:06 <cheater2> why is an operator part of a type?
02:08:13 <mauke> Monad is not a type, it's a class
02:08:22 <mauke> we are talking about types that are instances of a particular class
02:08:25 <cheater2> yes, but monads are types of class Monad
02:08:33 <cheater2> so what do operators have to do with this
02:08:35 <cheater2> ?
02:08:41 <mauke> ... everything?
02:08:45 <mauke> what do you think a class is?
02:08:50 <SNIPER0215> Monads - Mercedes vs Honda
02:09:07 <cheater2> i don't know - you tell me
02:09:09 <dmwit> "class" is a set of types -- not a single type (unlike in, say, Java and C++)
02:09:15 <cheater2> yes
02:09:17 <mauke> cheater2: a class is basically an interface
02:09:28 <cheater2> now what does an operator have to do with types?
02:09:34 <dmwit> But a "class" also has a specification for functions that must be implemented.
02:09:38 <dmwit> (>>=) is a function
02:09:45 <mauke> cheater2: it has a type
02:09:51 <mauke> like any function
02:09:52 <dmwit> ...that must be implemented before a type can be considered an instance of the Monad class.
02:10:04 <dmwit> cheater2: operators are just functions =)
02:10:27 <Peaker> cheater2: do you know type-classes?
02:10:33 <cheater2> yes
02:10:49 <Peaker> cheater2: they have methods
02:10:50 <mauke> for any operator @@, x @@ y is the same as (@@) x y
02:10:57 <Peaker> cheater2: and each instance of the type-class has to implement those methods
02:10:58 <cheater2> ok, so a monad is a function that implements >>= ?
02:11:01 <mauke> no
02:11:02 <mauke> a type
02:11:14 <Peaker> cheater2: a monad is a *type* for which there's an implementation of >>=   (and of return, too)
02:11:27 <cheater2> hm
02:11:35 <cheater2> in a similar way how Int implements + ?
02:11:39 <Peaker> cheater2: exactly
02:11:41 <mauke> for Num, yes
02:11:42 <cheater2> ok
02:11:44 <dmwit> A monad is a type *constructor* for which there's a polymorphic implementation of (>>=) and return.
02:11:53 <mauke> cheater2: do you know Functor?
02:12:03 <mauke> it's similar to but simpler than Monad
02:12:19 <Peaker> cheater2: so a type "m" can be a Monad if there's a function called (>>=)  with the type:   m a -> (a -> m b) -> m b    and a function called "return" with the type   a -> m a    implemented for it
02:13:17 <cheater2> mauke: no, what is Functor?
02:13:31 <Peaker> cheater2: note that "m" here is not really a simple type, but a type constructor, used not as "m", but as "m a" or "m b".  So, m cannot be "Int"  because   Int String does not make sense.  But it can be "Maybe" because Maybe String makes some sense
02:13:37 <mauke> class Functor f where { fmap :: (a -> b) -> f a -> f b }
02:14:05 <mauke> instance Functor [] where fmap = map
02:14:20 <cheater2> Peaker: aha
02:14:33 <cheater2> can "m" be Num?
02:14:33 <mauke> instance Functor Maybe where { fmap f Nothing = Nothing; fmap f (Just x) = Just (f x) }
02:14:40 <Peaker> cheater2: Num is not a type, it's a type-class
02:14:44 <cheater2> :S
02:14:46 <PoissonPilote> hey guys, sorry to bother again but I think I'm missing a major subtlety of Haskell :/ i
02:14:47 <Peaker> cheater2: "m" can only be a type constructor
02:14:56 <PoissonPilote> I'm coding a recursive mutliplication function
02:14:58 <PoissonPilote> here goes:
02:15:02 <cheater2> what are some type constructors?
02:15:03 <PoissonPilote> times :: Int -> Int -> Int
02:15:03 <dmwit> Wait!
02:15:07 <dmwit> ?hpaste
02:15:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:15:12 <dmwit> Instead of pasting in-channel.
02:15:17 <PoissonPilote> dmwit: thx
02:15:20 <Peaker> cheater2: list, Maybe, IO, (->)
02:15:26 <mauke> cheater2: Maybe, [], Reader, State
02:15:30 <shachaf> dmwit: That would be nicer if hpaste was up. :-)
02:15:34 <mauke> cheater2: Either
02:15:35 <dmwit> um
02:15:40 <dmwit> quite
02:15:45 <mauke> http://codepad.org
02:15:48 <dmwit> codepad, then
02:15:49 <dmwit> yeah
02:15:57 <PoissonPilote> http://paste.debian.net/59714/
02:15:59 <PoissonPilote> :P
02:16:11 <PoissonPilote> so yeah, theoretically I don't see where the problem lies...but it  just doesn't work
02:16:18 <Peaker> cheater2: whenever you have:   data MyType a b c = ...   and MyType has type parameters on the left side (in this case "a b c") then MyType is a type constructor.  Whereas:  data MyType = ...  without any parameters is not a type constructor but a simple type
02:16:18 <mauke> PoissonPilote: precedence
02:16:22 <PoissonPilote> either I'm really tired, or I'm missing a subtlety of haskell
02:16:26 <PoissonPilote> mauke: ?
02:16:27 <mauke> PoissonPilote: you're doing (times m n) - 1
02:16:45 <dmwit> PoissonPilote: Function application binds tighter than (almost) anything else.
02:16:57 <Peaker> dmwit: what binds tighter?
02:17:03 <mauke> Peaker: record update
02:17:07 <Peaker> oh
02:17:16 <PoissonPilote> dmwit: aaaargh, so dumb - thank you :)
02:17:17 <dmwit> PoissonPilote: So "f x y - 1" parses as "((f x) y) - 1", not "(f x) (y - 1)".
02:17:45 <jlouis> PoissonPilote: dumb? Nah
02:17:47 <mauke> PoissonPilote: on the other hand, you don't need the parens around (n==0) and (n==1)
02:17:56 <jlouis> morn btw
02:17:58 <PoissonPilote> mauke: i just find it neater :P
02:17:59 <cheater2> Peaker: aha
02:18:22 <mauke> times m (n - 1) + m
02:20:53 <PoissonPilote> and actually i don't even need the n==1 guard, do I
02:21:01 <mauke> true
02:21:03 <PoissonPilote> 4am here, getting tired
02:21:04 <PoissonPilote> :D
02:21:53 <cads> Gracenotes, man.. the gimp is just brutal :( I just spent like an hour fighting it making a simple graphic, rather than solving the triangle problem - here are the fruits of my labour! http://imgur.com/Hb1i6
02:22:05 <cads> heh, he's probably asleep
02:22:19 <cheater2> triangle problem?
02:22:27 <Peaker> cheater2: Monad is a structure that is found to repeat in many different contexts, so it was useful to put that structure in a type-class, so that all functions that only depend on that structure can be written without regard to what specific type it was
02:23:24 <Gracenotes> huh, triangle numbers after all
02:24:22 <cads> cheater2 http://projecteuler.net/index.php?section=problems&id=202 we can basically unfold the space that the laser beams travel through into a equilateral grid where very complex light trajectories turn into simple line segments.
02:25:06 <cheater2> what are such very complex light trajectories?
02:26:06 <cads> cheater2, for example, the progblem description shows a light trajectory that bounces 11 times before it exits from the triangle again.
02:26:29 * cheater2 cannot visit websites for another half an hour
02:26:44 <cheater2> cads: interesting
02:26:55 <cheater2> cads: but why does it have to do with lasers... and not movement in general?
02:27:10 <mauke> cheater2: do you know what project euler is?
02:28:07 <cheater2> yeah, i heard of it
02:28:25 <Gracenotes> cheater2: they are constituative the same mathematical problem, lasers vs movement
02:28:34 <Gracenotes> *constituatively
02:28:53 <cads> cheater, imagine an equilateral triangle made of inwards facing mirrors, and imagine that there is a small aperature at one of the vertices. You can see that if you shine a light directly into the triangle through that vertex it will hit the opposite edge and bounce right back to the vertex to escape the triangle again.
02:29:41 <Gracenotes> speaking of thinking of a problem in two ways, have you seen the chutes and ladders markov chain? :)
02:29:46 <cheater2> yeah, and if you don't then it will bounce around and hopefully escape again
02:29:48 <cheater2> what's the problem?
02:30:29 <cads> cheater, if you shoot the laser through the vertex at another angle, it will bounce around and possibly escape again - after a single bounce, the next smallest number of bounces that it must go through before existing is 7.
02:31:16 <PoissonPilote> http://projecteuler.net/index.php?section=problems&id=202 ;)
02:31:30 <PoissonPilote> oops nvm, didn't follow the whole convo
02:31:33 <PoissonPilote> sorry about that
02:31:40 * PoissonPilote will consider bed soon
02:31:44 <Gracenotes> the aperture is described as infinitesimal, by the way: it has to 100% exactly bounce onto it
02:31:50 <Gracenotes> to escape
02:32:57 <cheater2> and that's the problem?
02:33:29 <cads> Then it's 11 bounces for the next smallest, then 13. Each of these has only two ways you can aim the laser beam into the triangle to have it come out after these number of bounces. There's one way, and then the mirror image of that.
02:33:33 <Gracenotes> cads: hm. according to the diagram you posted, it's possible for it to exit through a different vertex
02:33:48 <cads> Gracenotes, correct :)
02:34:12 <cads> Cheater, the next highest number of bounces that will let the light ray escape is 21 bounces.
02:34:19 <Gracenotes> let me draw that for myself
02:34:50 <cads> this lets you shoot the ray into the triangle in _four_ different ways.
02:35:33 <cads> There are 80840 ways in which a laser beam may enter the the vertex and bounce off 1000001 surfaces, then exit through the same vertex.
02:36:24 <cads> cheater2, the problem is: how many ways can the laser enter the vertex, bounce 12017639147 times, then exit.
02:39:08 * hackagebot upload: atom 1.0.0 - A DSL for embedded hard realtime applications. (TomHawkins)
02:41:08 <int-e> cads: 10*2-1 is 19 btw.
02:41:53 * FauxFaux spies Project Euler in the scrollback.
02:44:26 <cads> oh boy
02:44:46 <cads> >X(
02:44:58 <cads> I think that means sleep is required
02:50:30 <Gracenotes> cads: I gave up on trying to construct a path exiting from another vertex
02:50:37 <Gracenotes> triangle transformations are tricky :x
02:50:43 <Gracenotes> although.. wait.. if I can rotate 120 degrees
02:52:59 <cheater2> are we talking about any triangle at all, or just one with all sides equal? (i forgot the english name for that)
02:53:52 <Gracenotes> equilateral
02:54:00 <Gracenotes> oh damn it.. it just exited out of the entrance.
02:54:05 <Gracenotes> how did I not see that coming
02:57:41 <Gracenotes> oh, wait, it didn't. but I still screwed the angles up.
02:57:59 <Gracenotes> this is why you get software to do this, not humans
02:58:51 <mauke> Look up ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn in Wiktionary, the free dictionary.
03:01:14 <cads>  cheater2 the problem is the same with any triangle.
03:01:18 <cads> ;)
03:01:43 <cheater2> i would need to come up with a simple proof of that
03:01:48 <Gracenotes> you can't make a grid with any triangle, can you?
03:01:54 <cheater2> but yes, i think so
03:02:14 <cheater2> you can
03:02:37 <Gracenotes> hm. wait, you can form a parallelogram from any triangle rotated next to itself. so perhaps you could.
03:02:53 <cheater2> but, that's not what the problem is about
03:03:07 <cheater2> it's not this kind of grid that we are looking for
03:03:23 <cheater2> we need to make the grid out of triangles of equal sides
03:04:01 <Gracenotes> you should really get HTTP, it's a sort of well-known protocol, I can give you a list of applications that implement it >.>
03:06:37 <cheater2> what?
03:07:02 <rhz> Q: Draw a line from point A to line L then to point B. What is the point on L that minimises the distance?
03:07:37 <int-e> Gracenotes: http://img196.imageshack.us/img196/610/17942865.png
03:07:45 <Gracenotes> uh. the one for which the line from A to B will be straight? :|
03:08:18 <Gracenotes> int-e: what did you make that with?
03:08:25 <cheater2> rhz: that's pretty simple..
03:08:39 <rhz> Gracenotes: lol. good answer. Now what if there is no such point on L?
03:08:40 <int-e> Gracenotes: xfig, because I'm familiar with that
03:10:00 <cads> Gracenotes, e http://imgur.com/nJsLw
03:10:08 <Gracenotes> rhz: you're saying both A and B are both on one side of the line? that's more interesting.. you'd just minimize the distances
03:10:15 <cads> http://imgur.com/T4Pzw
03:10:49 <rhz> Gracenotes: minimise the distances to what?
03:10:57 <cads> int-e, that's nice!
03:11:08 <Gracenotes> rhz: homework?
03:11:35 <rhz> Gracenotes: no
03:11:51 <Gracenotes> it is a simple calculus-minimizing problem
03:11:51 <cheater2> rhz: find the height of A and B above L and call them hA, hB. Normalize your distances so that the points from which hA and hB are counted, i.e. the closest ponts on L to A and B, are 1 unit apart.
03:12:05 <cads> rhz, if point b and a are on the same side of the line, mirror b across the line then draw a segment between a and mirror(b)
03:12:32 <Gracenotes> oh. or that.
03:12:54 <Gracenotes> you'd probably come up with the same answer via derivative-taking
03:13:03 <cads> hehe
03:13:22 <cheater2> cads: that's a fun way to look at it
03:14:01 <rhz> that discussion with the triangles reminded me of that problem
03:14:53 <rhz> it's an old problem someone asked me once. The nice thing about it is how simple the answer is.
03:15:10 <cads> oh for krikey's sake, Gracenotes, that second image I posted was completely wrong.
03:15:25 <cads> I can't just skew the whole figure...
03:18:26 <rhz> the not nice thing is how it tricks you into thinking the answer is not simple
03:19:04 <Gracenotes> let me see, going with hA and hB, with distance d from the closest point on the line from a to the point to b, and selecting something 0 ≤ x ≤ d units, total distance is sqrt(hA^2 + x^2) + sqrt(hB^2 + (d-x)^2). derivative is... something
03:19:30 <Gracenotes> I think that's my final answer
03:19:49 <cads> rhz, Gracenotes's answer would be very helpful if you had the two points on opposite sides of the line and you had two different distance formulas going on for each side.
03:20:17 <int-e> there are variations on the theme. like the question how an ant can crawl from the one corner of a box shaped room to the opposite one most quickly.
03:20:24 <int-e> s/the//
03:20:25 <cads> then it would be exactly like deriving the law of refraction
03:22:11 <rhz> yes, or if one is not in euclidean geometry. thats true
03:23:52 <rhz> although then the answer wold be even more complicated than Gracenotes probably
03:24:43 <Gracenotes> uh.. based on what I'm dealing with now, that might be a faulty assumption
03:26:25 <cads> Gracenotes, my claim of "it works for any triangle" is turning out to be extremely wrong
03:28:01 <int-e> Gracenotes: you's solve x/sqrt(hA^2 + x^2) - (d-x)/sqrt(dB^2 + (d-x)^2) = 0 which implies hA^2/x^2 = hB^2/(d-x)^2.
03:28:27 <Gracenotes> an easier approach than calculus would be the line equations
03:28:49 <int-e> cads: the principle of reflecting the triangle rather than the ray works, but the reflections don't line up nearly as nice in most cases.
03:29:12 <Gracenotes> int-e: symbolic math software is trickier than you'd think :P
03:29:29 <int-e> Gracenotes: I used wetware.
03:30:03 <int-e> all mistakes are my own.
03:30:28 <Gracenotes> I got the same equation as you, but apparently the software is having trouble solving for x. which is not so easy.
03:31:26 <Snoink> since there isn't always an 1-1 correspondance between glyphs in various charactersets or even in the same one (unicode) why do programming langages depend on them instead of making their own characterset? Making lexers for all these charactersets seems like redundant work.
03:31:51 <Gracenotes> oh, hm, the blah blah = 0 form and the blah = blah form yield different results.. x = distance*hA/(hA +/- hB)
03:32:41 <int-e> Gracenotes: the trick is going from 4x^2 / (hA^2 + x^2) = 4 (d-x)^2 / (hB^2 + (d-x)^2) to 4 / ((hA^2/x^2) + 1) = 4 / ((hB^2/(d-x)^2) + 1) (assuming x != 0 and x != d)
03:33:05 <Snoink> oh shit, wrong channel
03:33:18 <Gracenotes> Snoink: were you heading for the APL channel?
03:33:39 <int-e> Gracenotes: and that's something a computer algebra system may well miss. solving the quartic leads to desaster, I think.
03:34:00 <Gracenotes> int-e: that would make lots of sense on a blackboard :)
03:34:23 <int-e> disaster. meh.
03:34:31 <Gracenotes> hm.
03:35:43 <cads> I present to you guys- triangles of death http://imgur.com/1Ig0G
03:36:06 <Snoink> beutiful
03:36:14 <medfly> looks like one of those sail things
03:36:17 <Snoink> beautiful that is
03:36:21 <Gracenotes> tricky
03:36:35 <cads> the method works however there is no nice tiling as with equilateral triangles
03:36:38 <Snoink> looks like crap
03:36:49 <Gracenotes> cads: ouch, you didn't use the parallelogram approach?
03:37:03 <Gracenotes> or that's not accurate for reflections, is it
03:39:23 <cads> Yeah, I tried that here then I realized "hey, that's all wrong" constructing the reflection line completely misses the target. http://imgur.com/T4Pzw
03:40:50 <cads> I'm pretty sure that only isoscelese triangles will tile the grid under successive miroring about edges.
03:41:49 <int-e> cads: the 30-60-90 triangle works (which is half of an equilateral triangle)
03:42:13 <cads> I disagree.
03:43:35 <int-e> you may, but you'd be wrong.
03:44:25 <cads> I am wrong.
03:45:55 <int-e> (I should clarify that those are angles, not side lengths)
03:46:27 <dmwit> (and in degrees, no less)
03:46:48 <cads> http://imgur.com/iodIc
03:50:04 <cads> int-e, it works, and also my hypothesis about iscoscelese triangles is wrong.
03:56:45 <Gracenotes> cads: you know, they end up overlapping
03:57:12 <Gracenotes> cads: to make a prettyish image for the sake of it, http://i.imgur.com/sur9J.png
03:59:54 <Gracenotes> er, here's a bigger version, http://i.imgur.com/TeI27.png
04:00:09 <Gracenotes> inkscape is pretty fun
04:01:43 <opdolio> Man, porting my radix sort from uvector to vector made it 20x slower.
04:02:13 <int-e> wee
04:03:23 <Gracenotes> inkscape doesn't have a way to flip over a line. so you rotate to align said line with y-axis, and then flip vertical
04:04:01 <ben> How do you rotate to make something exactly align with the y-axis?
04:05:24 <Gracenotes> well. you can measure the angle, I'm sure. For the purpose of the image, eyeballing it is enough
04:05:43 <cads> http://i.imgur.com/CS7qZ.png
04:06:30 <cads> I wish rhino was as pretty as inskcape, but on geometric construction it's hard to fault except for its lack of dynamic constructions
04:07:09 <ben> I always hated eyeballing things in inkscape
04:07:37 <Gracenotes> ben: it's not as bad as it sounds; it aligns when the side of the bounding box is parallel to the line itself
04:08:01 <Gracenotes> if it's off by, say, 5 degrees, then the line might touch the bounding box at the top but not the bottom
04:09:29 <cads> wonder how hard it would be to turn inscape into a cad package
04:10:17 <Gracenotes> we can call it cadscape, cads for short
04:10:50 <cads> !
04:11:34 <cads> would there be a #cads channel on freenode?
04:13:47 * Berengal likes xmonad
04:15:18 <Gracenotes> possible, very possible
04:15:28 <Berengal> Perhaps I should install arch again, and get rid of all this kde stuff I've got lying around...
04:15:31 <domor> @pl repeat x = fix (x:)
04:15:31 <lambdabot> repeat = fix . (:)
04:16:53 <domor> cool or obfuscated? the line is thin.. :)
04:17:23 <Berengal> fix is the most obfuscated part of that
04:18:11 <olsner> once you put 'fix' in there, you might as well obfuscate the rest of the code completely while you're at it
04:19:17 <cebewee> @type fix
04:19:19 <lambdabot> forall a. (a -> a) -> a
04:19:37 <domor> haha, yes. I've been wondering recently if there are places where a fix or loeb could really be useful in normal code.
04:19:47 <int-e> > (fix . fix . ((:) .)) . const $ 1
04:19:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:19:56 <cebewee> ?src fix
04:19:56 <idnar> repeat x = x : repeat x
04:19:56 <lambdabot> fix f = let x = f x in x
04:20:00 <m0nkfish> what is fix?
04:20:08 <cebewee> the fixpoint operator
04:20:15 <domor> y combinator
04:20:23 <idnar> hmm, is that actually equivalent?
04:20:25 <m0nkfish> what does it do?
04:20:26 <xerox> m0nkfish http://www.vex.net/~trebla/haskell/fix.xhtml is awesome
04:20:39 <m0nkfish> thanks xerox
04:20:43 <cheater2> the y combinator is a specific fixed point combinator
04:21:08 <domor> interesting, specific in what way?
04:21:11 <cheater2> (as i understand in my limited grasp of the topic)
04:21:25 <cheater2> i'm just bringing up what i remember from reading wikipedia's entry on the y combinator
04:21:39 <int-e> idnar: semantically, yes it's equivalent. operationally it may use more space than the  repeat x = let xs = x:xs in xs  variant.
04:21:54 <idnar> int-e: right
04:22:08 <idnar> well, the fix definition is more straightforward than that, I guess
04:22:50 <cebewee> domor: there is more then one fixed point combinator
04:23:25 <int-e> repeat x = let xs = x:xs in xs  can be desugared to  repeat x = let xs = fix (x:) in xs (non-recursive let), which is equivalent to repeat = fix . (:)
04:23:32 <int-e> @src fix
04:23:32 <lambdabot> fix f = let x = f x in x
04:23:56 <domor> yes I'm reading the wiki article right now. hmm... my understanding of lambda calculus is really lacking
04:24:28 <int-e> or "desugar" ... if you'd desugar that definition of fix in the same way you'd get fix = fix ... which is not very helpful at all :)
04:26:09 <domor> ah there was a thread on that (Y combinator in Haskell): http://groups.google.co.uk/group/fa.haskell/browse_frm/thread/f0a62b6de1416d8b
04:39:38 <Gracenotes> fun thing to do: fix for recursion over lists
04:40:11 <olsner> i.e. implement foldr with fix?
04:40:17 <Gracenotes> also fun are practical things.
04:40:38 <cheater2> Y g 	= (λf . (λx . f (x x)) (λx . f (x x))) g 	< what is the '.' here?
04:40:44 <cheater2> application?
04:40:46 <Gracenotes> Haskell's ->
04:40:58 <cheater2> i don't know what haskell's -> is
04:41:02 * cheater2 is only learning
04:41:03 <int-e> \x -> foo
04:41:13 <int-e> --> λ x . foo
04:41:32 <Gracenotes> (λx . y) z, means the result is y, replacing all instances of x with z
04:41:49 <cheater2> what does lambda x . y mean?
04:42:00 <damd> cheater2: given an x, y
04:42:16 <cheater2> damd: is that it?
04:42:33 <damd> cheater2: well, that's the basic idea
04:42:44 <cheater2> i do not understand that
04:42:46 <Gracenotes> you have to break down the syntax right. e.g. λx. f (x y) ((λq. (r s) t) v)
04:42:51 <damd> "given a value, let's call that 'x', evaluate to y"
04:43:33 <Gracenotes> separate that into λx. and f (x y) ((λq. (r s) t) v). Then, for f (x y) ((λq. (r s) t) v), that's f applied to two arguments. The first is (x y), the second is ((λq. (r s) t) v)
04:43:44 <Gracenotes> ((λq. (r s) t) v) means that you
04:43:58 <Gracenotes> that you're taking (λq. (r s) t) and applying the argument v
04:44:30 <cheater2> damd: oh
04:44:33 <cheater2> damd: ok.
04:44:42 <cheater2> that's much better explained =)
04:44:48 <Gracenotes> (λq. (r s) t) itself is broken down into λq., the variable that's bound, and the expression (r s) t, which means apply s to r, and then t to that result. Sorry if that doesn't help with what it actually is, but it's how the syntax works
04:45:39 <damd> cheater2: naturally, that example doesn't make much sense to someone new to lambda calculus. stuff that makes more sense is e.g. the identity function: (λx. x), i.e. "given anything, let's call that 'x', evaluate to x"
04:45:47 <Gracenotes> cheater: which languages do you know?
04:46:04 <cheater2> Gracenotes: that was very helpful
04:46:34 <cheater2> Gracenotes: python, some java, some C++, perl, regex, sql, ...
04:47:39 <Gracenotes> ah, cool, we have some overlap :)
04:48:20 <cheater2> what does lambda f (some stuff) (some other stuff) do?
04:48:34 <mauke> (λx. Y) <=> sub { my $x = shift; Y }
04:48:39 <Gracenotes> depends on what f is
04:48:41 <cheater2> sorry
04:48:51 <cheater2>  lambda f . (some stuff) (some other stuff)
04:49:11 <cheater2> mauke: aha
04:49:18 <mauke> (x y) <=> $x->($y)
04:49:48 <mreh> :t (. f)
04:49:49 <lambdabot> forall a b (f :: * -> *). (SimpleReflect.FromExpr (f a), Functor f) => (a -> b) -> f b
04:49:55 <Gracenotes> eek
04:49:58 <cheater2> does the lambda f only apply to the left or also the right parenthese Gracenotes?
04:50:10 <mauke> (λf.λx. f x) <=> sub { my $f = shift; sub { my $x = shift; $f->($x) } }
04:50:56 <cheater2> or is it like, given lambda f, do (some stuff), and then to the result of that, do (some other stuff)?
04:50:58 <Gracenotes> the structure is (λf. u). f is always a single variable name, and u can be a complicated expression
04:51:11 <mauke> cheater2: the body of a lambda extends to the right as far as possible
04:51:46 <cheater2> ok, so lambda f . (stuff) (otherstuff) means 'given f, evaluate stuff, and apply it to the argument otherstuff'?
04:51:57 <mauke> yeah
04:52:11 <cheater2> ok.
04:52:16 <Gracenotes> the three basic constructs are variables, lambda abstractions, and function application. But we can introduce some basic type extensions too
04:52:57 <Gracenotes> so to hack pure lambda calculus into pieces, take (λx. x+x) 4. Applying 4 to the lambda expression, you get 4+4. if you'd like to evaluate that, you get 8
04:53:08 <cheater2> and f(x x) means apply x to x and apply f to that?
04:53:12 <mauke> yes
04:53:14 <cheater2> cool
04:53:44 <mauke> puzzle: what does (λx. x x) (λx. x x) evaluate to?
04:53:55 <cheater2> Gracenotes: gotcha
04:54:51 <cheater2> mauke: i think itself
04:54:56 <cheater2> mauke: but i'm not sure
04:55:16 <mauke> yeah, it's an infinite loop
04:55:38 <Gracenotes> more fun, (λx. (λy. y x)) 10 (λz. z*z) -> (λy. y 10) (λz. z*z) -> (λz. z*z) 10 -> 10*10 -> 100
04:55:41 <cheater2> but then i think that i could 'evaluate' the right parentheses first right?
04:55:53 <cheater2> or is it always left to right?
04:55:56 <mauke> cheater2: how? you've got nothing to apply it to?
04:56:09 <cheater2> aha
04:56:56 <mauke> perl -e 'sub { my $x = shift; $x->($x) }->(sub { my $x = shift; $x->($x) })'  # yay, infinite loop
04:57:30 <opdolio> (λx. x x) (λx. x x) only has a single redex.
04:57:39 <Gracenotes> it's not hard to make infinite loops in perl
04:58:00 <cheater2> what's redex?
04:58:00 <mauke> here's a more interesting question: (λx. ...) ((λy. ...) z)
04:58:05 <mauke> which lambda to you apply first?
04:58:25 <cheater2> mauke: i think you can apply either
04:58:39 <mauke> cheater2: what if that causes different results?
04:58:46 <cheater2> i wouldn't see how
04:59:19 <mauke> (λx. 42) ((λy. y y) (λy. y y))
04:59:31 <mauke> if you do the right group first, you're stuck in an infinite loop
04:59:41 <mauke> if you do the left lambda first, you return 42
04:59:56 <cheater2> then i dont know
05:00:04 <cheater2> what do you do?
05:00:12 <mauke> anything you want :-)
05:00:32 <Gracenotes> mauke: technically, by applying the y lambda, you produce another lambda, which is a different one
05:00:38 <cheater2> is the evaluation strategy really either way?
05:00:55 <mauke> cheater2: http://en.wikipedia.org/wiki/Normal_order_evaluation
05:01:20 <Gracenotes> mauke: maybe not different either extensionally or intensionally, but it's not the "original" lambda. Infinite loop only happens if you're inclined to keep on applying
05:02:03 <cheater2> so you might want to apply lambdas only in the order in which you have 'found' them
05:02:12 <cheater2> i.e. that new lambda would be at the top of the 'stack'
05:02:23 <cheater2> and would happen last
05:02:32 <cheater2> the 42 would happen before.. and there you go
05:04:28 <Gracenotes> there are plenty of approaches for evaluators
05:04:52 <cheater2> aha
05:04:57 <mauke> > (\x -> 42) (error "ABORT!")
05:04:58 <lambdabot>   42
05:05:03 <mauke> > error "ABORT!"
05:05:04 <lambdabot>   * Exception: ABORT!
05:05:07 <Gracenotes> D:
05:06:23 <domor> @type error
05:06:24 <lambdabot> forall a. [Char] -> a
05:06:58 <blueonyx> hi, why doesnt inf-haskell (emacs) behave like a terminal where <up> gives the last command? (instead i scroll up in the output)
05:07:59 <Gracenotes> the main problem you run into is naming. e.g.: (λx. λy. (λx. x) x y) y
05:08:26 <domor> blueonyx: you did M-p right?
05:08:58 <Gracenotes> straight-up replacing, you'd get (λy. (λx. x) y y) -> (λy. y y). Which is not correct.
05:10:15 <blueonyx> domor: no?
05:10:34 <blueonyx> domor: oh thanks :)
05:10:37 <domor> well, that's the usual command to get the last command..
05:10:40 <domor> np :)
05:10:51 <domor> you can do M-n to go the other way
05:10:56 <blueonyx> yea thanks
05:11:10 <mreh> what is the most elegant way to edit purely functional structures? Conal's DeepArrow talks about that kind of thing. You see I want to be able to edit nested records easily without all the bloated sugar.
05:11:24 <blueonyx> domor: sry, im still into arrow keys ;)
05:11:48 <domor> haha
05:15:06 <mreh> haha?
05:17:41 <medfly> haha!
05:20:46 <Saizan> mreh: seen data-accessor or fclabels ?
05:21:47 <mreh> Saizan: too much boiler plate
05:22:22 <benmachine> I don't suppose there's any way to use runhaskell with -main-is?
05:22:31 <mreh> I think Conal has the best solution, it's very general
05:23:02 <benmachine> oh you just have to
05:23:02 <benmachine> hmm
05:23:04 <mreh> benmachine: don't you only build with --make -main-is
05:23:15 <benmachine> mreh: I'm not even compiling
05:23:18 <benmachine> hence runhaskell
05:24:08 <Saizan> maybe runghc?
05:24:21 <benmachine> runghc --help says I can pass GHC flags
05:24:39 <benmachine> but it keeps saying Not in scope
05:24:54 <mreh> here's a solution, use GHCi :)
05:25:25 <benmachine> that's a workaround not a solution :P
05:25:30 <benmachine> well I suppose it is a solution of a word
05:25:33 <benmachine> er
05:25:34 <benmachine> sort
05:25:42 <mreh> it's a solution to a higher order problem
05:26:05 <benmachine> but I want to know what runghc is doing
05:26:13 <benmachine> why it gets everything wrong
05:26:16 <mreh> what is runhaskell anyway? I joined the whole Haskell thing about this time last year
05:26:30 <benmachine> runhaskell is an alias for runghc
05:26:42 <benmachine> okay this is just weird
05:26:44 <Zao> mreh: Handy script to run a Haskell file with a suitable interpreter/compiler.
05:26:52 <benmachine> I am now doing runghc Main
05:26:58 <benmachine> watching it 100% my cpu
05:26:58 <mreh> oh, like perl
05:27:02 <Zao> For portability of code between whatever runtime enviroments may exist.
05:27:09 <benmachine> and eventually going
05:27:12 <benmachine> Main:1:0: lexical error at character '\DEL'
05:27:13 <Zao> One can trivially provide a runhaskell that runs via Hugs, for example.
05:27:21 <benmachine> ohh
05:27:33 <benmachine> it is trying to run the executable not the module
05:27:35 <benmachine> that is silly
05:27:42 <Zao> benmachine: runghc Main.hs :P
05:27:49 <Zao> Err, runhaskell.
05:27:58 <Zao> Let's not monomorphize ourselves.
05:28:01 <benmachine> heh
05:28:07 <benmachine> okay
05:28:18 <benmachine> so runhaskell Main.hs works now that I've made a main
05:28:26 <benmachine> but
05:28:34 <benmachine> runhaskell -main-is main Main.hs says
05:28:37 <benmachine> <interactive>:1:41: Not in scope: `main'
05:28:48 <mreh> does it implement a virtual machine?
05:28:51 <benmachine> which is patent nonsense
05:29:07 <mreh> maybe not a von-neumann architecture
05:29:33 <mreh> whatever the equiv in the lambda calc. is
05:29:47 <benmachine> I don't know what it does but it does it wrong
05:29:57 <mreh> you're doing it wrong :)
05:30:01 <Zao> benmachine: -main-is refers to a module, and is case sensitive.
05:30:16 <benmachine> Zao: -main-is can refer to all sorts of things iirc
05:30:40 <Zao> -main-is yourFatherLuke
05:32:31 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker <-- -main-is can accept a[n optionally qualified] function name
05:32:59 <Gracenotes> of type IO (), right
05:33:04 <benmachine> IO t I think
05:33:21 <Zao> Convenient.
05:33:40 <Gracenotes> the main main is required to be ()
05:34:01 <benmachine> is it?
05:34:47 <benmachine> no
05:34:55 <benmachine> ghc -Wall doesn't mind an IO Char
05:35:05 <Saizan> no such requirement
05:35:21 <Gracenotes> <GHC 6.10 required it, anyway
05:35:22 <benmachine> (although there is a bug in runghc I think that makes it print the result if it's not ())
05:36:26 <Gracenotes> hm. main = return 4; runhaskell blah.hs -> prints 4. ghc --make blah.hs; ./blah -> nada
05:36:59 <Gracenotes> that seems right. Well, I definitely recall GHC 6.8 complaining about it
05:57:58 <dmhouse> Hey guys. I want to write a memoised program to solve a certain recurrence (say t_n = f(t_1, ..., t_{n-1}). It should be able to run in linear time.
05:59:10 <MissPiggy> if you like you can define f' such that (t_i+1,...,t_n)=f'(t_i,...t_n-1)
05:59:40 <Heffalump> dmhouse: memoise it via an array
05:59:44 <dmhouse> In an imperative language, this would easy to express: to compute t_n, you'd write a loop which filled an array t, then read off the value of t[n]
05:59:49 <Heffalump> assuming you know the largest n you'll want to look up
05:59:59 <dmhouse> However I'm unsure as to how to express this in Haskell
06:00:39 <Heffalump> define the array to map n to t_n using f, and make the lookups of t_1 etc in the definition of f go via the array
06:00:42 <opqdonut> dmhouse: write a lazy circular array
06:00:44 <dmhouse> I.e. how do you write a loop that "populates" an array using the previously calculated values? (Obviously there are things like Data.Array.ST but I feel it should be doable in a more functional setting)
06:00:50 <MissPiggy> for example, f(0)=1;f(1)=1;f(n+2)=f(n)+f(n+1) we can define f'(a,b)=(b,a+b) and clearly now f(n)=(f'^n)(1,1)
06:01:35 <dmhouse> MissPiggy: my recurrence uses all of t_1 through t_{n-1}, not just the previous k.
06:01:47 <dmhouse> opqdonut: could you give an example?
06:01:48 <opqdonut> > let fibs 0 = 1; fibs 1 = 2; fibs n = a ! n where a = array (0,100) (map fibs [0..100]) in fibs 10
06:01:49 <lambdabot>   Occurs check: cannot construct the infinite type: e = (t, e)
06:01:59 <MissPiggy> dmhouse, yes my suggestion generalized to any n -- I just showed an example of fib because it's very simple
06:02:03 <Heffalump> arr = listArray (0, k) (map f [0..k])
06:02:26 <Heffalump> opqdonut: your definition doesn't actually calculate anything..
06:02:37 <mauke> dmhouse: http://codepad.org/MsWxa9DA
06:02:39 <Heffalump> f n = ...arr!(n-1) ...arr!(n-2)... etc
06:02:42 <MissPiggy> dmhouse it is still not quite clear?
06:03:03 <dmhouse> MissPiggy: I don't think your technique works if the number of previous terms needed is variable.
06:03:09 <MissPiggy> you are wrong
06:03:16 <opqdonut> Heffalump: heh, stupid me
06:03:18 <dmhouse> Heffalump, okay, will that not run in quadratic space, though?
06:03:52 <dmhouse> mauke: I'll look that over
06:04:12 <opqdonut> let fibs 0 = 1; fibs 1 = 2; fibs n = (a ! (n-1)) + (a ! (n-2)) where a = array (0,20) (zip [0..20] $ map fibs [0..20]) in fibs 20
06:04:15 <opqdonut> > let fibs 0 = 1; fibs 1 = 2; fibs n = (a ! (n-1)) + (a ! (n-2)) where a = array (0,20) (zip [0..20] $ map fibs [0..20]) in fibs 20
06:04:17 <lambdabot>   17711
06:04:18 <opqdonut> sorry :)
06:04:20 <Heffalump> dmhouse: no, the only space it uses is the array
06:04:33 <dmhouse> MissPiggy: okay, could you give an example of how to apply your technique to the recurrence t_n = t_1 + t_2 + ... + t_{n-1}
06:04:37 <opqdonut> dmhouse: also, look at Data.MemoCombinators
06:04:43 <opqdonut> or whatever the package name was
06:05:07 <opqdonut> you say something like "let f = memo f' where f' <args> = <recurrence on f'>"
06:05:35 <opqdonut> no, sorry, <recurrence on f>
06:05:39 <opqdonut> so you look up the memoised values
06:06:25 <dmhouse> (Also, a quick side point: Data.Array is definitely constant time lookup, right? Complexities aren't listed in the Haddock docs.)
06:06:31 <MissPiggy> dmhouse, if we forget for a moment, that this sequence has a much more efficient closed form: Then you can just change from using an n-type (which has typed dimension) to a vector (which has a "dynamic" length)
06:06:48 <MissPiggy> n-tuple, not n-type*
06:07:02 <opqdonut> (dmhouse: yeah, it should be)
06:09:10 * dmhouse tries t n = f(arr ! 1, ..., arr ! (n-1)) where arr = listArray (0,k) (map t [0..k])
06:09:49 <MissPiggy> hmhouse: or you can use a list:  f n = sum (map f [1..n]) --->   f n = sum (map (f'!!) [0..n-1]) ; f' = map f [0..]
06:09:58 <cheater2> i Maybe a tagged union?
06:10:11 <Botje> but an array is O(1) :)
06:10:12 <cheater2> *is
06:10:14 <Botje> cheater2: every sum type is
06:10:24 <MissPiggy> oops that f n on the left hand side needs to use n-1 also
06:10:24 <dmhouse> MissPiggy: lookup in an array is O(n), so the whole thing probably wouldn't be linear
06:10:25 <cheater2> i don't know what a sum type is, i only know Maybe
06:10:38 <cheater2> but, if you are saying that Maybe is a sum type, then ok.
06:10:47 <MissPiggy> dmhouse, it's not going to be liner is the nth term uses all previous terms
06:10:56 <Botje> yes, maybe is represented internally as a tagged union
06:11:14 <MissPiggy> dmhouse, you couldn't beat quadtratic unless you went to some kind of closed form or something halfway between
06:11:42 <dmhouse> MissPiggy: why not? The following C program would be: int t[k], i; for (i = 0; i < k; i++) t[i] = f(t[1],...,t[i-1]); return t[k];
06:11:52 <dmhouse> That is linear, I mean.
06:11:56 <mauke> dmhouse: ... is not valid C
06:11:59 <MissPiggy> lol
06:12:16 <dmhouse> Erm, hang on
06:12:16 <MissPiggy> its C++ mauke
06:12:23 <cheater2> Botje: ok, cool!
06:12:25 <mauke> MissPiggy: int t[k] is not valid C++
06:12:29 <MissPiggy> ufff
06:12:33 <MissPiggy> it's C++++
06:12:40 <dmhouse> mauke: pseudo-C where k is actually a constant (in the same sense that f is actually a real function)
06:12:57 <mauke> dmhouse: so what is ...?
06:15:18 <dmhouse> mauke: I meant that given a recurrence t_n = f(t_1, ..., t_{n-1}) (so f is not an actual mathematical, let alone C function -- just a notational convenience for expressing how t_n depends on the previous terms), and a natural number k, the program above works out t_k.
06:15:46 <mauke> dmhouse: how would you express that in C?
06:15:51 <mauke> HINT: WITH A LOOP
06:16:22 <dmhouse> mauke: it depends on what f is
06:16:38 <MissPiggy> dmhouse is there really a case where you can do that without a loop?
06:16:42 <mauke> 1 + 2 + ... + n-1 + n = n*(n-1)/2
06:16:46 <mauke> thus O(n²(
06:16:59 <dmhouse> Yeah, I realised it wasn't linear, mea culpa.
06:17:16 <MissPiggy> dmhouse of course it's linear if you start at t_n-k, rather than t_1
06:17:29 <MissPiggy> (in C /and/ haskell)
06:17:45 <dmhouse> But _anyway_, if you translated that into Haskell using lists for arrays, you'd get O(n^3) performance, so Data.Array is still better
06:18:06 <MissPiggy> oh yeah that's true
06:18:26 <MissPiggy> f' (the memoized list) doesn't have constant lookup
06:18:27 <merijn> Currying question, is (<3) equal to flip (<) 3?
06:18:53 <MissPiggy> merijn, I think about it like this:   (<3) = \x -> x<3 = \x -> (<) x 3 = flip (<) 3
06:19:35 <domor> @unpl flip (<) 3
06:19:35 <lambdabot> (\ c -> c < 3)
06:20:03 <MissPiggy> @unpl ((<3), flip (<) 3))
06:20:04 <lambdabot> Unbalanced parentheses
06:20:05 <MissPiggy> @unpl ((<3), flip (<) 3)
06:20:05 <lambdabot> ((\ a -> a < 3), (\ d -> d < 3))
06:20:13 <MissPiggy> so they aren't equal :o
06:20:33 <merijn> MissPiggy: Yeah, I just wasn't sure if the syntax was smart enough to automatically pass the number to the appropriate side of the infix operator
06:20:46 <merijn> Ah, looks like that's indeed the case. Nice :)
06:21:14 <merijn> Also, that's a useful lambdabot command, I need to remember that
06:22:03 <domor> @pl (x -> x < 3) -- @unpl's friend
06:22:03 <lambdabot> (line 1, column 4):
06:22:03 <lambdabot> unexpected ">"
06:22:03 <lambdabot> expecting variable, "(", operator or ")"
06:22:13 <domor> @pl (\x -> x < 3) -- @unpl's friend
06:22:13 <lambdabot> (< 3)
06:22:33 <benmachine> lambdabot's heart seems to be broken
06:22:45 <domor> hehe
06:22:53 <mauke> ♥
06:23:21 <medfly> @let ♥ = (<3)
06:23:21 <lambdabot>   Parse error: VarSym "\9829"
06:24:19 <ksf> do we have a nice map library by now that chooses implementations automagically based on key type?
06:24:26 <benmachine> > generalCategory '\9829'
06:24:26 <int-e> > let i ♥ u = i < u in 1 ♥ 3
06:24:27 <lambdabot>   OtherSymbol
06:24:27 <lambdabot>   True
06:25:03 <flippo> I detect silliness
06:25:22 <benmachine> oh no!
06:26:35 <ksf> there's gmap, but it doesn't select instances automatically
06:28:10 <benmachine> ksf: you mean like, a Map class where if you used Int keys it would be an IntMap?
06:29:21 <ksf> benmachine, exactly
06:29:45 * benmachine wonders if things like mapKeys would still work
06:29:56 <ksf> right now I'm using a vanilla map and have an Ord constraint on my functions, i'd rather have a Key restraint.
06:29:57 <dmhouse> Okay, here is my memoised program completed: http://pastebin.com/m4cb672dc. Now, I've noticed there's a bit of a delay when working out the first value. Will this program be lazy enough to to compute the entire 400,000 element array on the first invocation of t?
06:30:17 <dmhouse> My program only calls t once per run so this would be a pretty inefficient way of doing things.
06:31:05 <dmhouse> I guess I could move everything inside a function taking as a parameter the value read from stdin, and replace instances of k with that parameter...
06:33:17 <int-e> dmhouse: the delay probably comes from filling the array with 400k thunks. that will only happen once. but yeah, if you only call t once you'll be better off not memoising at all.
06:34:05 <int-e> > iterate (\((s,s',s''),(t,t')) -> ((s',s'',(s+t)`mod`10000),(t
06:34:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:35:35 <ksf> benmachine, (Key k, Key k') => (k -> k') -> Map k a -> Map k' a
06:35:47 <dmhouse> Hmm, here's my second iteration: http://pastebin.com/m32977804
06:35:51 <dmhouse> This blows the stack for large n
06:37:57 <toothbrush> A
06:38:16 <toothbrush> oops, typo in wrong window :-/
06:40:43 <int-e> @index iterate'
06:40:43 <lambdabot> bzzt
06:43:08 * ksf wonders why gmap has an Eq restraint on the key
06:43:58 <MissPiggy> dmhouse I don't really know but you could try to strictify it?
06:44:25 <int-e> > let go 1 _ _ _ t'' _ = t''; go n s''' s'' s' t'' t' = go (n-1) s'' s' ((s'' + t') `mod` 10000) t' ((3*t'' + 2*s''') `mod` 10000) in go 40000 0 1 0 0 3
06:44:26 <lambdabot>   2721
06:47:31 <int-e> Exponentiating the corresponding 5x5 matrix (mapping s''' s'' s' t'' t' to their new values) will be asymptotically faster.
06:47:59 <Dodek> hey, i have a problem with regex-pcre library
06:48:01 <Dodek> Loading package regex-pcre-0.94.1 ... can't load .so/.DLL for: pcre (/usr/lib64/libpcre.so: invalid ELF header)
06:48:36 <Dodek> i reinstalled both regex-pcre and libpcre, it still doesn't work though
06:49:16 <Dodek> could it be a reason that on my distribution /usr/lib64/libpcre.so is not an object file but ld script?
06:49:23 <Saizan> yes
06:49:38 <Dodek> what's the solution then?
06:49:48 <Saizan> make it a symlink to the binary
06:49:59 <Dodek> that's a silly thing to do
06:50:18 <Dodek> it may fix regex-pcre
06:50:24 <Dodek> but break rest of my system
06:50:38 <Saizan> i didn't get any breakage out of this
06:51:15 <Saizan> however you might be able to build regex-pcre so that it refers to the binary
06:51:37 <Dodek> it will also break as soon as i update libpcre
06:51:39 <Saizan> or you could avoid ghci, ghc --make should work since it uses ld
06:51:59 <Dodek> oh, ok
06:52:02 <Dodek> this seems reasonable
06:55:23 <int-e> dmhouse: oh. the period of that generator is pretty short.
06:57:19 <dmhouse> int-e: looks like your go is pretty much the same as my final iteration: http://pastebin.com/m52f9247
06:57:49 <dmhouse> If you're interested, t n is the number of ways of tiling a 3xn bathroom with 2x1 tiles.
06:58:08 <int-e> except for the (mod 10000) stuff
06:59:06 <dmhouse> Yeah, everything taken mod 10000 (I presume the point of that bit of the question is to avoid issues with overflow)
06:59:57 <dmhouse> Next question: this still runs about 20 times slower than my C implementation: http://pastebin.com/d5d80d96e. How could I speed it up?
07:00:23 * hackagebot upload: wikipedia4epub 0.0.4 - Wikipedia EPUB E-Book construction from Firefox history. (RadoslavDorcik)
07:00:26 <dmhouse> Perhaps by strictifying the arguments to go?
07:04:21 <Lemmih> dmhouse: Have a look at the core code.
07:04:46 <b0fh_ua> Hi there! How do I convert [Char] into ByteString? Using read?
07:04:52 <Twey> :t pack
07:04:53 <lambdabot> Not in scope: `pack'
07:04:55 <Twey> Ugh
07:04:59 <benmachine> :t BS.pack
07:05:01 <lambdabot> [Word8] -> BSC.ByteString
07:05:02 <Twey> Anyway, it's ‘pack’
07:05:09 <benmachine> seems you need Word8 for that
07:05:15 <Twey> Hm
07:05:24 <Twey> Yeah
07:05:28 <Twey> Encode, then pack
07:05:44 <benmachine> if your input is guaranteed to be ascii, fromIntegral would do it
07:05:45 <Lemmih> @type Data.ByteString.Char8.pack
07:05:46 <lambdabot> String -> BSC.ByteString
07:05:49 <benmachine> otherwise you need to
07:05:50 <Draconx|Laptop> benmachine, Char can require multiple bytes to represent.
07:05:50 <benmachine> oh
07:06:02 <benmachine> Draconx|Laptop: I know
07:06:05 <Draconx|Laptop> er, b0fh_ua ^^
07:06:09 <benmachine> heh
07:06:29 <Draconx|Laptop> (seems that my brain registers only the first character of nicknames)
07:06:32 <Twey> Hence the need to encode it explicitly, I guess
07:06:35 <benmachine> > show (BS.pack [10])
07:06:36 <lambdabot>   "\"\\n\""
07:06:41 <benmachine> hmm
07:06:42 <Saizan> Data.ByteString.Char8.pack assumes latin1 i.e. it takes the least 8 bits of each Char
07:06:42 <benmachine> odd
07:07:12 <Twey> Well, there are other encodings that use only eight bits
07:07:40 <Zao> Truncating UTF-32 to 8 bits yields latin-1, amusingly.
07:07:55 <Draconx|Laptop> this is by design.
07:08:04 <Lemmih> dmhouse: How big is 'n'?
07:08:14 <dmhouse> Lemmih: up to 4e5
07:08:21 <int-e> > let go !t' !t !s' !s !0 = t'; go t' t s' s n = go t ((t' + s) `mod` 10000) s ((2*t + s') `mod` 10000) (n-1) in go 1 0 0 2 400000
07:08:22 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
07:08:48 <int-e> (slightly different recurrence)
07:09:15 <dmhouse> Seems that adding strictness annotations makes it just as fast as the C implementation. Nice :)
07:09:56 <benmachine> if a lambda is applied to something, the lambda pretty much has to be in parentheses
07:10:12 <benmachine> is that right?
07:10:21 <Saizan> yes
07:10:34 <benmachine> I'm looking at haskell-src-exts' prettyprinter
07:10:40 <benmachine> not happy with how it parenthises things
07:10:49 <MissPiggy> you can do
07:10:54 <MissPiggy> f $ \x -> ...
07:11:02 <MissPiggy>   $ \y -> ...
07:11:02 <benmachine> then the lambda is not applied
07:11:03 <MissPiggy> and so on
07:11:16 <Saizan> that's applying something to a lambda
07:11:41 <MissPiggy> but the second $ is inside the \x lambda
07:11:43 <benmachine> iirc lambdas always extend as far to the right as possible
07:11:49 <benmachine> well yes it's inside the lambda
07:11:54 <MissPiggy> dmhouse hey that's neat!
07:11:56 <benmachine> so the lambda still isn't applied to anything :P
07:12:09 * benmachine tries to work out how this translates to precedence numbers
07:12:21 <Saizan> flip id x $ \x -> ... -- but i guess we are taking "applied" in a more syntactical sense
07:12:27 <benmachine> yes
07:12:45 <benmachine> I'm talking about something that parses as (App (Lambda ...) x)
07:14:53 <MissPiggy> hm
07:15:01 <MissPiggy> benmachine is there ever a need to write that
07:15:08 <benmachine> write what
07:15:20 <MissPiggy> (\x -> m[x]) $ y
07:15:29 <MissPiggy> when you could have  let x = y in m[x]
07:15:37 <benmachine> I guess there's never a need
07:15:43 <benmachine> but there's never a need to use a where clause
07:15:46 <MissPiggy> maybe that's why it's so awkward to write
07:15:51 <MissPiggy> like a huffman coding
07:15:57 <benmachine> (\x -> x + 1) 3
07:16:00 <benmachine> should do what you expect
07:16:16 <benmachine> should not prettyprint as \x -> x + 1 3
07:16:19 <benmachine> because that is wrong
07:16:22 <Saizan> ugh
07:16:27 <Saizan> that's a serious bug
07:16:49 <benmachine> excuse me while I check that it actually happens
07:16:57 <dmhouse> Lambdas extend as far to the right as possible.
07:17:17 <dmhouse> So there must necessarily be an end-parenthesis to apply a lambda.
07:17:29 <benmachine> hmm I think it has been fixed
07:17:37 <Twey> > flip id 5 $ \x -> x + 3
07:17:38 <lambdabot>   8
07:18:01 <benmachine> hmm
07:18:05 <benmachine> it's not really fixed
07:18:44 <benmachine> the round-trip on parses is still okay, I think
07:18:50 <benmachine> because parentheses are preserved
07:18:58 <benmachine> but if you manually create an expression with constructors
07:19:03 <benmachine> it will prettyprint wrong
07:19:50 <benmachine> that's less obviously a bug because you can obviously make nonsense if you abuse the constructors sufficiently
07:20:42 <benmachine> (like putting a class declaration in a let)
07:22:41 <dmhouse> Is there a literal for floating point infinity (like the C99 macro INFINITY)? Or does one have to create it using, e.g. 1/0?
07:23:01 <Twey> > Infinity
07:23:02 <lambdabot>   Not in scope: data constructor `Infinity'
07:23:13 <Twey> > read "Infinity" :: Float
07:23:14 <lambdabot>   Infinity
07:23:20 <Twey> Crazy stuff
07:23:45 <dmhouse> Not that crazy... Infinity isn't a constructor, it's just how the floating point value representing infinity gets shown.
07:23:54 <dixie> quick questoin - when the haskell platform include ghc 6.12.1?
07:24:06 <Draconx|Laptop> dmhouse, since Haskell does not provide a mechanism to handle floating point exceptions, 1/0 is exactly like C99's INFINITY.
07:24:42 <benmachine> Draconx|Laptop: less self-documenting though
07:25:27 <benmachine> should my upper-bound base constraint be < 5 or < 4.3?
07:25:36 <Saizan> we've an isInfinite but not infinity it seems
07:26:22 * dmhouse settles for defining infty = read "Infinity" :: Double
07:26:45 <Draconx|Laptop> > let inf = 1/0 :: Float in realToFrac (inf) :: Double
07:26:46 <lambdabot>   3.402823669209385e38
07:26:48 <Draconx|Laptop> yay!
07:26:57 <Saizan> benmachine: good question, the first major number doesn't actually guarantee anything wrt API changes, though base is quite large
07:27:03 <dmhouse> > isInfinite 3.402823669209385e38
07:27:04 <lambdabot>   False
07:27:24 <dmhouse> > isInfinite (3.402823669209385e38 :: Float)
07:27:25 <Saizan> benmachine: the convention is to use < 5
07:27:25 <lambdabot>   True
07:27:33 <BenceF> hi! cabal says i should upgrade base to 4.x
07:27:37 <Draconx|Laptop> since pretty much the entire standard library is broken w.r.t. infinities, nans, and negative zeros, it's not surprising that we don't have a predefined infinity "shorthand".
07:27:38 <BenceF> how do i do that?
07:27:46 <benmachine> Saizan: yeah, I've seen < 5 used but 4.3 seems to make more sense by the PVP
07:27:50 <dmhouse> Draconx|Laptop: broken? How so?
07:27:59 <Saizan> BenceF: you can only do that by upgrading your ghc
07:28:03 <merijn> Draconx|Laptop: How is it broken, exactly?
07:28:05 <benmachine> BenceF: are you installing something or a library developer?
07:28:11 <Draconx|Laptop> dmhouse, see how converting float infinity to a double yields a finite value there?
07:28:19 <BenceF> installing parsec
07:28:30 <Draconx|Laptop> > ceil (1/0)
07:28:30 <lambdabot>   Not in scope: `ceil'
07:28:30 <BenceF> it installed. it just gives a warning
07:28:30 <benmachine> then don't worry about it; that message is for the parsec developers
07:28:33 <Draconx|Laptop> > ceiling (1/0)
07:28:34 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
07:28:36 <merijn> Draconx|Laptop: I think that's correct behaviour according to IEEE754
07:28:38 <sshc> > 1/0
07:28:39 <Draconx|Laptop> that also makes no sense...
07:28:39 <lambdabot>   Infinity
07:28:47 <sshc> > floor (1/0)
07:28:48 <benmachine> (you might want to annoy them about it, but probably they already know)
07:28:48 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
07:28:58 <Saizan> BenceF: the warning about base-3 being deprecated?
07:29:03 <BenceF> yes
07:29:04 <Draconx|Laptop> merijn, no, converting float infinity to double should yield infinity.
07:29:06 <Saizan> BenceF: you can ignore that
07:29:11 <BenceF> ok
07:29:18 <Saizan> you already have base-4
07:29:23 <sshc> don's loch package has that warning
07:29:24 <BenceF> just thought i ask
07:29:30 <Saizan> it's just cabal that tends to build things against base-3
07:29:33 <sshc> dons's loch package has that warning
07:29:40 <sshc> but he also uses -Werror
07:29:44 <int-e> dmhouse: http://pastebin.com/m6c4609cd
07:29:45 <sshc> so I can't use it yet
07:29:54 <BenceF> should i force it to build with base 4?
07:29:54 <Saizan> if anything, parsec's maintainers should be worrying about this :)
07:30:13 <sshc> yes, can I force it to build with base 4?
07:30:25 <Saizan> BenceF: you don't get any benefit out of that, your base-3 is just reexporting things from base-4 anyway
07:30:43 <BenceF> so its fine
07:30:45 <dmhouse> int-e: 6000 is the period?
07:31:00 <int-e> dmhouse: yeah.
07:31:02 <Saizan> sshc, BenceF: --preference="base >= 4"
07:31:18 <sshc> Saizan: where do I do that?
07:31:29 <sshc> Saizan: do I pass that to cabal when I'm insntalling?
07:31:31 <int-e> dmhouse: but you can remove the `mod` 6000 and it will still be very fast.
07:31:32 <BenceF> cabal command line i guess
07:31:37 <Saizan> sshc: cabal install foo  --preference="base >= 4"
07:31:55 <sshc> thanks!
07:31:59 <BenceF> thanks
07:32:12 <dmhouse> int-e: that's cool. (I was only looking at the naive algorithm for now, for a more direct comparison with the C implementation.) Let me see how fast it goes.
07:32:42 <int-e> dmhouse: because t is O(log(n)). e = exponentiation, g = generator, u = unit, p = (matrix) product, tr = transpose, d = dot product, m = modulus.
07:34:18 <benmachine> $ ldd dist/build/stepeval/stepeval | wc -l
07:34:18 <benmachine> 29
07:34:26 <benmachine> dynamic linking woo
07:34:38 <merijn> Draconx|Laptop: Isn't the problem you just showed caused by realToFrac going from a real to a fractional value which you are then specifying as a double?
07:35:30 <Draconx|Laptop> merijn, yes, the problem is that realToFrac shoehorns floating point values into rationals.
07:36:58 <dmhouse> int-e: seems to run at about a quarter of the speed of my C implementation :)
07:37:42 <dmhouse> Although the timings are 4ms vs 16ms, so I wonder how much random fluctuations of times comes into account.
07:37:55 <Draconx|Laptop> merijn, it wouldn't be as much of a problem if this wasn't the *only way* in Haskell to convert a Float to a Double.
07:37:56 <manjunaths> anybody can build hashell ?
07:38:12 <manjunaths> I get this error Could not find module `Text.Regex':
07:38:12 <manjunaths>       it is a member of the hidden package `regex-compat-0.71.0.1'
07:38:29 <merijn> Draconx|Laptop: Ah, yeah that's kinda sucky then
07:38:30 <int-e> dmhouse: you have to do several calculations in the program to get a fair comparison; otherwise, program startup will dominate the running times.
07:38:35 <Draconx|Laptop> merijn, incidentally, it also can't convert from Double to CDouble or vice versa without losing information.
07:38:55 <Draconx|Laptop> (well, you can use unsafeCoerce...)
07:39:20 <mreh> am I programming with continuations when I do things like this: (\f x -> f x ++ "world.") (\s -> s ++ "hello ") "the people say: "?
07:39:52 <mreh> I keep running into this pattern, just wondered what it is called
07:40:25 <ksf> can I constrain a type family to only yield results that implement a certain typeclass?
07:40:29 <manjunaths> argh! dependency hell
07:40:34 <Berengal> mreh: Looks like inside-out CPS
07:40:52 <mreh> Berengal: continuation passing style
07:40:55 <mreh> ?
07:40:58 <Berengal> Yeah
07:41:08 <mreh> it looks like doing foldl with foldr
07:41:16 <mreh> that's what it looks like to my brain
07:44:52 <merijn> mreh: That makes no sense, because foldl is done by foldr
07:45:13 <mreh> @src foldl
07:45:14 <lambdabot> foldl f z []     = z
07:45:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:45:17 <mreh> no it isn't
07:45:23 <mreh> it can be simulated with foldr
07:45:50 <merijn> mreh: Maybe not in the actual implementation, but it is mathematically equal to a specific foldr
07:46:35 <mreh> I'm talking about the implementation
07:47:19 <merijn> "Doing foldl with foldr" boils down to "doing a specific kind of foldr with foldr" which I guess is true because it's a tautology. And this tangent doesn't actually help anyone so I'll shut up now :)
07:48:22 <mreh> they aren't identical, foldl takes the arguments to it's function in reverse
07:49:40 <mreh> > foldl (flip (:)) 1 [2..10]
07:49:41 <lambdabot>   No instance for (GHC.Num.Num [b])
07:49:41 <lambdabot>    arising from the literal `1' at <inter...
07:50:08 <mreh> > foldl (flip (:)) [] [1..10]
07:50:09 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
07:50:12 <mreh> what was I thinking?
07:50:52 <manjunaths> the eval command is in what module ?
07:50:57 <manjunaths> @hoogle eval
07:50:58 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:50:58 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:50:58 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
07:50:58 <ksf> why can't I write class (Functor (MapOf t), Map (MapOf t) a) => HasMap t  ?
07:51:01 <gwern> 'Social versus technical. Can we get customer source code? Almost always, no. Despite nondisclosure agreements, even for parse errors and preprocessed code, though perhaps because we are viewed as too small to sue to recoup damages. As a result, our sales engineers must type problems in reports from memory. This works as well as you might expect. It's worse for performance problems, which often show up only in large-code settings. But one shouldn't ...
07:51:07 <gwern> ... complain, since classified systems make things even worse. Can we send someone onsite to look at the code? No. You listen to recited syntax on the phone.'
07:51:09 <manjunaths> @hayoo eval
07:51:09 <lambdabot> Unknown command, try @list
07:52:27 <mreh> @hoogle eval
07:52:27 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:52:27 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
07:52:27 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
07:52:28 <ksf> gwern, that's easy to deal with. A bug without example attached is not a bug.
07:52:31 <mreh> oh
07:52:37 <manjunaths> System.Eval is not a module
07:52:43 <manjunaths> how can I install it ?
07:53:02 <mreh> manjunaths: it is a module, it probably lives in another package
07:53:22 <mreh> the name space of several different packages can overlap
07:53:27 <manjunaths> manjunaths, how do I find which package it lives in ?
07:53:39 <ksf> rule number one for lisp converts: you don't need eval.
07:53:41 <mreh> it might live in a package on hackage
07:53:54 <mreh> and don't call me manjunaths
07:54:00 <manjunaths> ksf, I am trying to compile a haskell package
07:54:14 <manjunaths> mreh, haha...sorry auto-complete woes :-)
07:54:16 <mreh> manjunaths, try plugins
07:54:18 <ksf> we've got a compiler to do such stuff...
07:54:28 <ksf> or template haskell, depends on setting.
07:54:30 <mreh> lol
07:54:47 <mreh> we have a compiler?! I've been evaluating all my haskell by hand!
07:54:51 <mreh> gah!
07:54:59 <ksf> there's also mueval
07:55:10 <ksf> which is supposedly safe.
07:55:21 <ksf> safe, that is, unless someone manages to crash lambdabot.
07:55:31 <RayNbow> mreh: such a fool you are... I leave my Haskell unevaluated ;)
07:55:47 <mreh> RayNbow: sounds useless
07:55:50 * RayNbow is lazy :p
07:56:15 <mreh> a completely lazy compiler would be pretty useless
07:57:12 <manjunaths> ok...this error I can't fix
07:57:28 <manjunaths> man...it sucks to be stumped after coming till here.
07:58:08 <mreh> manjunaths: describe the problem and we might be able to help
07:58:26 <mreh> have you downloaded some haskell sources?
07:58:33 <manjunaths> http://paste.lisp.org/+218B
07:58:39 <manjunaths> mreh, no hashell
07:58:44 <manjunaths> it was last updated in 2006
07:58:53 <mreh> what haskell? GHC?
07:59:03 <manjunaths> hashell
07:59:07 <manjunaths> haskell shell
07:59:08 <Saizan> that's still using the old exceptions
07:59:21 <Saizan> you should compile it using base-3
07:59:21 <manjunaths> hash<-ell
07:59:29 <manjunaths> what is base-3 ?
07:59:37 <manjunaths> is it some older package
07:59:39 <mreh> the base package library
07:59:45 <Saizan> the third version of the base library
07:59:59 <manjunaths> can't I fix this to compile with the current version :-( ?
08:00:00 <ksf> why can't i use class contstraints in type family instances?
08:00:00 <Saizan> manjunaths: if you "ghc-pkg list base" it'll give you two versions
08:00:06 <gwern> ksf: a company run on that model is a company which will make no sales and will die
08:00:27 <manjunaths> Saizan, hmm...but what will happen to my current installation ?
08:00:37 <manjunaths> can you guys fix it ?
08:00:39 <manjunaths>  :-)
08:00:41 <gwern> I think I once updated hashell to 6.8
08:00:52 <gwern> back when I was still thinking of writing a shell in haskell
08:01:01 <manjunaths> how awesome would it be if bash was made of haskell syntax ?
08:01:03 <Saizan> manjunaths: a base-3.x and a base-4.x , if you pass -package base-3.x to your ghc invocation it'll use that, and it'll work
08:01:11 <manjunaths> Saizan, ah
08:01:15 <manjunaths> cool
08:01:22 <burp> manjunaths: h4sh http://www.cse.unsw.edu.au/~dons/h4sh.html
08:01:25 <manjunaths> everyday this gets more awesomer
08:01:42 <manjunaths> burp, ooooh
08:01:57 <Saizan> manjunaths: you've to replace 'x' with the actual version that comes out of running "ghc-pkg list base"
08:02:00 <gwern> 'The end result? Since the analysis that suppresses false positives is invisible (it removes error messages rather than generates them) its sophistication has scaled far beyond what our research system did. On the other hand, the commercial Coverity product, despite its improvements, lags behind the research system in some ways because it had to drop checkers or techniques that demand too much sophistication on the part of the user. As an example, for ...
08:02:06 <gwern> ... many years we gave up on checkers that flagged concurrency errors; while finding such errors was not too difficult, explaining them to many users was. (The PREfix system also avoided reporting races for similar reasons though is now supported by Coverity.)'
08:02:08 <mreh> *drools*
08:02:50 <benmachine> is a Setup.hs actually necessary if you're just using defaultMain?
08:03:05 <gwern> benmachine: no; if your buildtype is Simple
08:03:24 <benmachine> k
08:03:38 <Saizan> cabal sdist will generate one for you in the tarball anyway
08:04:14 <BenceF> package versions getting more and more confusing in haskell
08:04:20 <BenceF> :(
08:05:00 <manjunaths> Saizan, the command is what cabal install base-3 ?
08:06:04 <int-e> > let go s t 0 = t; go s t n = go ((2*t+3*s) `mod` 10000) ((t+s) `mod` 10000) (n-1); t n | odd n = 0 | otherwise = go 2 1 (n `div` 2) in t 40000 -- dmhouse :)
08:06:05 <lambdabot>   2721
08:06:16 <benmachine> manjunaths: you probably already have base 3
08:06:36 * BenceF gave up installing yi
08:06:50 <manjunaths> benmachine, ah
08:07:13 <benmachine> manjunaths: the trick is telling the compiler that that's what you need to use
08:07:16 <sshc> dons: when I build loch, Debug/Trace/Location.hs:70:7: Class `C.Exception' used as a type In the type signature for `ppr': ppr :: C.Exception -> String
08:07:47 <benmachine> manjunaths: which you can do with -package switches, I think
08:08:01 <manjunaths> benchmachine, as
08:08:06 <manjunaths> benmachine, ah
08:08:14 <benmachine> why does everyone call me benchmachine :P
08:08:26 <benmachine> not everyone but it's pretty much the only misspelling that ever happens
08:08:40 <manjunaths> sorry
08:08:50 <manjunaths> ah...it worked!
08:08:50 <benmachine> I don't really mind I just think it's weird
08:08:56 * manjunaths dances
08:08:56 <benmachine> cool
08:09:25 <pantsman> not everyone, just people who don't use tab-complete
08:09:32 <manjunaths> typical user session
08:09:36 <manjunaths> > help
08:09:36 <manjunaths> user error (127)
08:09:37 <lambdabot>   Not in scope: `help'
08:09:43 <benmachine> manjunaths: lol
08:09:43 <manjunaths> > ?
08:09:43 <manjunaths> user error (127)
08:09:44 <lambdabot>   <no location info>: parse error on input `?'
08:09:55 <manjunaths> it looks like an ed session
08:10:15 <benmachine> pantsman: I'd expect a variety of creative mistakes though, but it's always the bench
08:10:27 <manjunaths> how do I quit
08:10:32 * BenceF 've got prehistoric bandwith
08:10:41 <manjunaths> wow....that was pretty spartan
08:10:48 <BenceF> benmachine: i was convinced it was bench :D
08:10:55 <pantsman> benmachine, but "bench machine" is a kind of gym equipment
08:11:04 <benmachine> pantsman: yeah, I suppose that makes sense
08:11:28 <pantsman> they must imagine you to be some really muscular guy (maybe you are) ;)
08:11:30 <manjunaths> I think once I start typing, my spinal cord takes over and auto-completes it to bench
08:11:31 <BenceF> how do i quit from main?
08:11:59 <Zao> Falling off the end, or exitWith
08:12:01 <BenceF> is it okay to use main recursively?
08:12:19 <BenceF> exitWith is my friend
08:12:22 <benmachine> pantsman: sadly I do not live up to said inadvertently-generated expectations
08:13:40 <BenceF> can i make    myFunc :: Maybe IO ()     ?
08:13:50 <benmachine> BenceF: you can make Maybe (IO ())
08:13:58 <BenceF> ok
08:14:10 <BenceF> haskell is fun.
08:14:20 <BenceF> however i suck at Cabal :)
08:14:20 <benmachine> it is
08:14:24 <dmhouse> If I have two (big) Data.Arrays, and want to combine them to make an array that represents their union, is this possible without going via intermediate lists (which would make the whole thing linear time)?
08:14:55 <benmachine> not sure how you can look at every element of two arrays in constant time
08:15:08 <benmachine> not sure how you can union arrays without looking at every element
08:15:32 <dmhouse> Depends how lazy you are
08:15:51 <dmhouse> If arrays were implemented as functions from keys to values, this would be a constant time operation
08:15:52 <int-e> union?
08:16:11 <int-e> ah, you have disjoint indices
08:16:17 <benmachine> if you want a lookup structure that supports fast unions, you could try Data.Map
08:16:36 <benmachine> I don't know much about Arrays but I'd be surprised if they were lazy in the way you want
08:16:55 <dmhouse> benmachine: it's more important I have constant time lookups. It just seems silly for this to be linear time (but it probably won't be a bottleneck)
08:18:06 <int-e> dmhouse: http://pastebin.com/m2d6f0d3d ... this is my final version now.
08:18:08 <BenceF> where is exitWith ? which module?
08:18:25 <Zao> http://www.haskell.org/hoogle/?hoogle=exitWith
08:18:26 <aavogt> @hoogle exitWith
08:18:26 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
08:18:53 <BenceF> cool. gotta remember hoogle
08:19:17 <jmcarthur> dmhouse: i'm pretty sure that even without using intermediate lists the union of two arrays will be linear time
08:19:26 <benmachine> dmhouse: I guess you could have constant-time unions if you didn't actually unioned the array but just made a new lookup function?
08:19:30 <cebewee> BenceF: I like hoogling for a type signature even more
08:19:32 <benmachine> *union
08:19:35 <dmhouse> benmachine: that's what I mean
08:19:38 <cebewee> @hoogle [a] -> Bool
08:19:38 <lambdabot> Prelude null :: [a] -> Bool
08:19:39 <lambdabot> Data.List null :: [a] -> Bool
08:19:39 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
08:19:47 <benmachine> but that wastes memory, probably
08:19:50 <benmachine> but
08:20:02 <Zao> Hayoo is nice too, when Hoogle fails you.
08:20:07 <BenceF> cebewee: neat
08:20:09 <benmachine> if your keys/indices are sparse or disjoint or whatever, you might find that Data.Map is actually what you wanted after all
08:20:32 <benmachine> but whatever
08:20:37 <benmachine> I don't actually know about this sort of thing
08:20:40 <benmachine> so do what you please :P
08:20:44 <jmcarthur> not actually unioning the arrys wouldn't really be constant time lookup i think. it would be at best log u, where u is the number of unions that were used to create the array you are looking up
08:20:56 <aavogt> dmhouse: you could write an instance of IArray that translates the indexes to lookup in your two original arrays...
08:21:20 <dmhouse> benmachine: Data.Map can't be what I want as it has logarithmic lookup
08:21:24 <aavogt> > log 2
08:21:25 <lambdabot>   0.6931471805599453
08:21:28 <jmcarthur> dmhouse: what are you indexing on?
08:21:36 <benmachine> dmhouse: but logarithm of quite a small thing
08:21:40 <benmachine> potentially
08:21:45 <dmhouse> jmcarthur: (Int, Int) in this case. (Why?)
08:21:55 <jmcarthur> dmhouse: IntMap has constant time lookup
08:22:01 <dmhouse> benmachine: how so? My map is huge.
08:22:07 <jmcarthur> bigger constant than arrays, but constant
08:22:33 <dmhouse> jmcarthur: hmm, so I should combine my (Int, Int) into a single Int with some injection?
08:22:48 <benmachine> that's what the Ix instance does anyway, doesn't it?
08:22:51 <jmcarthur> dmhouse: so you could have something like IntMap (IntMap a), or do something like what you just proposed
08:23:04 <jmcarthur> dmhouse: also see the EnumMap package
08:23:09 <BenceF> Couldn't match expected type `IO a'
08:23:11 <BenceF>            against inferred type `Maybe (IO ())
08:23:13 <dmhouse> Okay, thanks for the ideas all.
08:23:36 <BenceF> how should i solve this?
08:23:43 <benmachine> BenceF: by matching the types
08:23:49 <benmachine> (i.e. we need more information)
08:24:03 <benmachine> something that wants an IO a is being given a Maybe (IO ())
08:24:24 <BenceF> its inside a recursive main :: IO ()
08:24:27 <aavogt> @type fromMaybe (return ())
08:24:28 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m ()) -> m ()
08:25:09 <benmachine> BenceF: you can make Maybe (IO ()) things but you have to be careful about where you use them
08:25:29 <BenceF> and it supposed to exit if a getline is "quit"
08:25:51 <benmachine> pastebin the code
08:26:04 <BenceF> ok. a minute
08:27:34 <BenceF> http://codepad.org/3NBvnwZt
08:28:14 <benmachine> BenceF: you can't combine Maybe (IO ()) and IO () in the same do-block
08:28:35 <benmachine> if you want to run an IO action in a Maybe, you have to get it out first
08:28:39 <aavogt> the cleanest thing to do is to just use (IO ())
08:28:49 <benmachine> for example with fromMaybe like aavogt did
08:28:49 <benmachine> but
08:28:59 <benmachine> it's easier to just return () when you don't want to do anything
08:29:07 <olsner> when (head command == 'q') exitSuccess
08:29:10 <aavogt> you don't need to tell the difference between   (return ()) and other actions with the same type
08:29:24 <benmachine> olsner is clever
08:29:27 <benmachine> :t when
08:29:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:29:46 <olsner> dunno if exitSuccess already exists, but that got rid of an extra parenthesis
08:29:50 <BenceF> and i only need the when line?
08:30:00 <benmachine> @hoogle when
08:30:00 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:30:08 <benmachine> import it from Control.Monad first
08:30:09 <benmachine> but yeah
08:30:10 <olsner> ah, it does
08:30:18 <benmachine> @hoogle exitSuccess
08:30:19 <lambdabot> System.Exit exitSuccess :: IO a
08:30:19 <lambdabot> System.Exit ExitSuccess :: ExitCode
08:30:29 * benmachine raises an eyebrow at IO a
08:30:51 <Botje> why?
08:30:55 <olsner> actually, I guess it's IO DoesNotReturn
08:30:55 <aavogt> makes sense since you could never recover from the exitSuccess
08:30:59 <BenceF> i think exitSuccess is exithwith ExitSuccess
08:31:02 <benmachine> olsner: yeah
08:31:16 <aavogt> @type System.Exit.exitWith
08:31:17 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
08:31:19 <Zao> Isn't it implemented by throwing or something?
08:31:24 <benmachine> in my experience there is such a thing as excessive polymorphism
08:31:51 <benmachine> Zao: I don't think you can catch it
08:32:22 <benmachine> could be wrong though
08:32:43 <olsner> well, you have e.g. printf that iirc has the type "IO a" but returns undefined - I find that often ">>" makes that throw one of those "* Exception: undefined"
08:32:59 <olsner> (re excessive polymorphism)
08:33:00 <int-e> it's   throwIO ExitSuccess   or   throwIO (ExitFailure n)  for some n
08:33:30 <BenceF> i did " return ()  " it compiled
08:33:36 <aavogt>     exitSuccess `catch` \(SomeException e) -> print e >> exitFailure
08:33:46 <benmachine> olsner: it shouldn't, >> is lazy by the monad laws
08:33:46 <aavogt> this does catch the exitSuccess
08:34:00 <benmachine> olsner: i.e. return undefined >> bar is equivalent to bar
08:34:08 <Zao> BenceF: The type of the last statement in a do block determines the type of the block.
08:34:14 <benmachine> aavogt: oh okay
08:34:22 <olsner> benmachine: hmm, I guess some monads are doing it wrong then
08:34:24 <BenceF> Non-exhaustive patterns in case
08:34:30 <BenceF> i should resolve that
08:34:48 <benmachine> olsner: well, it depends how picky you are, but yeah probably
08:34:53 <olsner> I guess not following the laws make them not-monads, but "instances of Monad" they were
08:34:55 <BenceF> _ ?
08:34:58 <cizra> Anybody interested in wild boars? mms://tv.eenet.ee/siga and mms://tv.eenet.ee/siga2
08:36:14 <int-e> aavogt: more specificially, you can do this: exitFailure `Control.Exception.catch` \(e :: ExitCode) -> print e
08:37:49 <BenceF> how should i match anythingelse in a case block?
08:38:06 <int-e> BenceF: using the _ (wildcard) pattern
08:38:07 <aavogt> variables match anything
08:38:20 <int-e> or a variable
08:38:47 <BenceF> int-e: got a parse error, but then maybe thats because of another thing
08:39:56 <dmhouse> How does the Ord instance work on pairs? Lexicographically?
08:40:01 <int-e> BenceF: indentation most likely
08:40:03 <int-e> dmhouse: yes
08:41:11 <BenceF> yeah. vim got me a tab on his on
08:42:12 <BenceF> own
08:42:16 <int-e> ghc has a -fwarn-tabs option :)
08:42:36 <BenceF> thankgod
08:42:51 <BenceF> cause 99% of the time its tabs
08:43:18 <BenceF> im gonna force softabs now just in case
08:43:58 <baaba> you can set vim to show tabs
08:44:19 <BenceF> set showtabs ?
08:44:32 <baaba> :set list
08:44:57 <BenceF> oh cool
08:45:02 <baaba> http://vim.wikia.com/wiki/Highlight_unwanted_spaces#Using_the_list_and_listchars_options
08:45:33 <BenceF> yeah ive found vim.wikia yesterday :) already helped a lot
08:47:27 <BenceF> what editor do you use? ive heard emacs is great for haskell
08:48:14 <ksf> http://codepad.org/1ZLywkOj
08:48:28 <ksf> is there _any_ way to get an instance for all Enums?
08:49:02 <ksf> BenceF, emacs is great if you want an bloated operating system
08:49:04 <ksf> go vim.
08:49:07 <ksf> or yi, fwiw.
08:49:19 <jmcarthur> ksf: redesigning EnumMap?
08:50:03 <BenceF> i gave up getting yi cause of dependency juggling
08:50:28 <ksf> i was thinking along the lines of type instance Enum a => MapOf a = EnumMap a
08:50:37 <ksf> ...but ghc won't let me.
08:51:10 <ksf> ...and no, I don't want to redesign gmap
08:51:16 <ksf> I'm content with using it.
08:51:40 <BenceF> is there a #vim on freenode? maybe i should frequent it
08:51:47 <ksf> there is
08:51:53 <aavogt> doesn't that kind of instance work if you use fundeps?
08:52:09 <BenceF> imma innit now
08:52:49 <int-e> aavogt: not really; it will be an overlapping instance.
08:53:38 <benmachine> can a haskell process renice itself?
08:53:42 <int-e> aavogt: (assuming there are others of course, and that you don't wrap the Enum into a newtype)
08:53:43 <ksf> right now my own code says data P t a = Match (MapOf t (P t a)) | ... and i'd like to keep it like that
08:54:05 <int-e> :t System.Posix.nice
08:54:06 <lambdabot> Int -> IO ()
08:54:27 <benmachine> int-e: coolthx
08:55:27 * benmachine wonders if it's worth bothering for an extra dependency or whether he should just reduce the time allowed to a quarter of a second
08:55:37 <benmachine> (looking at ways to make a CGI script not horrible)
08:55:58 <benmachine> (currently commits suicide after half a second)
08:56:42 <ksf> is there any deeper typetheoretic reason why contexts aren't allowed in type families?
08:57:07 <benmachine> what, there is a System.Environment.getEnvironment and a System.Posix.getEnvironment and they are not the same
09:03:09 <int-e> benmachine: but it doesn't seem to work.  do pid <- getProcessID; setProcessPriority pid 10   has some effect.
09:03:53 <cheater2> hey guys
09:03:54 <cheater2> anyone got Introduction to Algorithms, Third Edition?
09:04:33 <copumpkin> my prof does
09:06:37 <gwern> cheater2: my sister does
09:07:12 <cheater2> gwern: is it good?
09:07:20 <cheater2> gwern: and.. is it very different from 2e?
09:07:22 <gwern> anyhoo, has anyone ever seen a ghc bug report to the effect that given 2^16 and similar constants, ghc should infer 16 :: Int, and not warn about how it has to default to Integer?
09:07:43 <gwern> cheater2: if it's the one I'm thinking of, it's good albeit very imperative, but I can't speak to differences
09:08:24 <benmachine> int-e: huh, okay, thanks
09:08:24 <cheater2> it's a new edition, from maybe autumn
09:08:45 <cheater2> it has a balanced tree on the cover
09:16:50 <int-e> benmachine: that was the threaded RTS. I'm not sure I got the effect that I wanted; every thread has its own scheduling priority, and setProcessPriority will only affect one thread at a time. :/
09:19:59 <sshc> why isn't threaded a valid thread in an OPTIONS pragma?
09:20:18 <sshc> how do I enable the the threaded option in a cabal package?
09:20:19 <kmc> did you try OPTIONS_GHC
09:20:32 <gwern> > 2^(16::Int)
09:20:33 <lambdabot>   65536
09:20:33 <sshc> kmc: yes
09:20:36 <gwern> :t 2^(16::Int)
09:20:37 <lambdabot> forall t. (Num t) => t
09:20:45 <sshc> kmc: I have OPTIONS_GHC, but the error mentions OPTIONS
09:20:56 <sshc> unknown flag in  {-# OPTIONS #-} pragma: -threaded
09:21:17 <sshc> even though the real pragma is OPTIONS_GHC
09:21:18 <AlbertDS> I remember learning Haskell at university. It was taught by one of the worst lecturers in the world: Nick Dyson. He was a vile, nasty piece of work. He lacked all those basic human qualities like empathy, altruism, etc. As a result I dislike Haskell too.
09:21:38 <sshc> AlbertDS: I'm sorry to hear that!
09:22:04 <MissPiggy> AlbertDS lol I had a teacher once who was really really nice in person but the emails he sent and the critical remarks he wrote were sooooo cruel
09:22:36 <aavogt> sshc: those pragmas only affect compile-time things, while -threaded is link-time?
09:22:37 <sshc> I learned Haskell by reading http://learnyouahaskell.com/ and after that Real Word Haskell
09:22:54 <sshc> aavogt: ok.  How would I go about doing that?
09:22:54 <mreh> > take 5 $! [1..]
09:22:55 <lambdabot>   [1,2,3,4,5]
09:23:07 <sshc> aavogt: do I need to add something to the .cabal file or use a different pragma?
09:23:07 <mreh> does $! only reduce something to whnf?
09:23:32 <aavogt> yeah, add to your cabal file: ghc-options:     -threaded
09:23:43 <sshc> mreh: as it is defined in terms of seq, yes.
09:24:08 <sshc> aavogt: I also have -O in my OPTIONS_GHC file that is in every single source file
09:24:35 <aavogt> you mean OPTIONS_GHC pragma?
09:24:52 <aavogt> optimization should work on a per-file basis...
09:24:59 <sshc> aavogt: since you mention that, I'd assume ghc-options'd probably be a better place to put that?
09:25:07 <aavogt> definitely
09:25:12 <sshc> aavogt: yes, pragma, not file
09:25:17 <mreh> just do a global optimisation
09:25:23 <mreh> nothing lost
09:25:29 <sshc> mreh: globale optimisation?
09:25:36 <mreh> optimise everything
09:26:03 <sshc> mreh: what do you mean?
09:26:06 <MissPiggy> AlbertDS so what did he dod??
09:26:12 <sshc> mreh: add a flag to ghc-options?
09:26:22 <sshc> mreh: or a pragma?
09:26:31 <mreh> sshc: yes, the equiv of -02 when you do ghc --make
09:26:37 <mreh> -O2
09:26:55 <BenceF> is there ghc --make-it-work?
09:27:00 <mreh> I presume cabal uses ghc
09:27:12 <pikhq> BenceF: ghc --make?
09:27:18 <sshc> mreh: I do -O3 since performance is pretty important
09:27:28 <mreh> sshc: 2 is the maximum
09:27:41 <sshc> mreh: 3 is maximum
09:27:46 <BenceF> pikhq: something to correct your mistakes
09:27:49 <gwern> :t (^)
09:27:50 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:28:20 <gwern> @src (^)
09:28:21 <lambdabot> x ^ 0            =  1
09:28:21 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
09:28:21 <lambdabot>   where f _ 0 y = y
09:28:21 <lambdabot>         f x n y = g x n
09:28:21 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
09:28:23 <lambdabot>                       | otherwise = f x (n-1) (x*y)
09:28:25 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
09:28:33 <pikhq> BenceF: Ah.
09:28:33 <b0fh_ua> Guys, is there any simple way to open a file, read from the file and append some line to the file on some condition?
09:28:43 <pikhq> BenceF: Clearly your mistakes are because you thought wrong. :P
09:29:10 * hackagebot upload: Encode 1.3.1 - Encoding character data (OtakarSmrz)
09:29:12 <BenceF> pikhq: nontheless ghc should correct them :)
09:29:18 <mreh> sshc: -O3 isn't safe
09:29:18 * BMeph likes to crank his -O to eleven... ;)
09:29:20 <pikhq> b0fh_ua: Clearly you open the file to read from, test for that condition, then if that condition is met, open the file for appending and write to the file.
09:29:25 <mreh> that's what I was thinking :)
09:29:58 <b0fh_ua> pikhq: okay, but isn't it possib;le to reuse same handler for appending?
09:30:03 <mreh> does anyone know what -O3 does? Unsafe array indexing?
09:30:05 <b0fh_ua> just courious
09:30:21 <copumpkin> mreh: it adds nothing
09:30:22 <mauke> -O3 doesn't exist
09:30:28 <mauke> it used to be worse than -O1
09:30:36 <BenceF> mreh: uses class VoodooMagic
09:30:38 <BMeph> b0fh_ua: Yes; add a "when" line after your "write it back" expression.
09:31:34 <mreh> why did I listen to sshc then?
09:31:45 <sshc> mreh: why isn't -O3 safe?
09:31:54 <mreh> it doesn't exist
09:32:13 <pikhq> Undefined. It may be unsafe in future GHC versions.
09:32:19 <mreh> the documentation says -O2 applies every safe optimisation, I thought that implied there were unsafe optimisations
09:32:29 <BMeph> b0fh_ua: I'm assuning that your tested condition depends on the contents of the file you've read....
09:32:30 <mauke> wait, which documentation?
09:32:47 <olsner> -O3 used to be an alias for -O0 :)
09:32:47 <mreh> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html
09:33:22 <mauke>   The avoided “dangerous” optimisations are those that can make runtime or space worse if you're unlucky. They are normally turned on or off individually.
09:33:31 <mauke> INDIVIDUALLY
09:33:52 <b0fh_ua> BMeph: yep
09:34:27 <jlouis> What does -O1337 do?
09:34:31 <mreh> this is why I should have read the scrollback
09:34:44 <pikhq> jlouis: Try it and see.
09:35:05 <b0fh_ua> BMeph: the problem is that I have to mix AppendMode and ReadMode on same handler
09:35:06 <benmachine> http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=let+foldr+%3D+%5Cf+z+xs+-%3E+case+xs+of%0D%0A+++++++++++++%5B%5D+-%3E+z%0D%0A+++++++++++++x%3Axs+-%3E+f+x+%28foldr+f+z+xs%29%0D%0A+in+foldr+%28%2B%29+0+%5B1%2C2%2C3%2C4%5D this is what I am working on it is missing a lot of features
09:35:17 <b0fh_ua> which is not possible?
09:35:17 <benmachine> it also has a huge URL because it is done by GET
09:35:20 <benmachine> but whatevs
09:36:00 <benmachine> please be nice to it :P
09:37:11 <mreh> "ones = 1 : ones" doesn't work
09:37:27 <benmachine> doesn't work how
09:37:30 <companion_cube> hello, is there a recommended way to provide an interface without actually writing the code ? Like a .h file ?
09:37:34 <int-e> benmachine: (\x -> x x) (\x -> x x x) games? aww.
09:37:44 <mreh> it says "Sorry, parsing failed."
09:37:56 <benmachine> mreh: try forming a complete expression?
09:37:58 <benmachine> let/in
09:38:15 <mreh> what wasn't complete about that expression?
09:38:30 <mauke> mreh: it's not an expression at all
09:38:40 <benmachine> it's a declaration
09:38:47 <mreh> oh
09:38:51 <mauke> > ones = 1 : ones
09:38:52 <lambdabot>   <no location info>: parse error on input `='
09:39:03 <aavogt> > let ones = 1 : ones in ones
09:39:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:40:38 <lpsmith> > fix (1:)
09:40:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:40:50 <lpsmith> @src fix
09:40:50 <lambdabot> fix f = let x = f x in x
09:41:01 <lpsmith> :)
09:41:50 <savanni> Hey, if anyone has a minute, I have another Gtk2HS question.  Specifically... are there any tutorials that help out with writing GStreamer apps in Haskell?
09:41:57 * benmachine wishes he had had the forethought to put a logging thing in so he can see what people are doing, if anything
09:42:27 <b0fh_ua> companion_cube: just define class in some file
09:42:31 <int-e> benmachine: hah. it's not lazy.
09:42:36 <benmachine> int-e: it tries to be
09:42:47 <benmachine> int-e: well, sort of
09:42:48 <sshc> > (flip (++)) (fix (\x -> fix show))$ (fix. const$ "")
09:42:49 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
09:42:51 <aavogt> benmachine: would be nice if it implemented equation definitions, rather than needing you to write lambdas and case
09:42:57 <benmachine> aavogt: that would be nice, yes
09:43:16 <benmachine> int-e: what's your use case?
09:43:37 <benmachine> I think it tries to evaluate the top level to normal-form-ish
09:43:49 <benmachine> so it will recurse into lists for e.g.
09:44:04 <benmachine> but if it doesn't need something it shouldn't use it
09:44:15 <int-e> > let take = \n xs -> case n of { 0 -> []; _ -> case xs of { x:xs -> x : take (n-1) xs } }; ones = 1 : ones in  take 3 ones
09:44:16 <lambdabot>   [1,1,1]
09:44:25 <int-e> benmachine: try that one
09:45:10 <int-e> oh. right, it fails to evaluate 3-1, of course. sorry.
09:45:18 <benmachine> heh whoops
09:45:40 <benmachine> so then it goes a bit strange
09:46:46 <int-e> > let take = \ys xs -> case ys of { [] -> []; (y:ys) -> case xs of { x:xs -> x : take ys xs } }; ones = 1 : ones in  take [0,0,0] ones
09:46:47 <lambdabot>   [1,1,1]
09:46:55 <int-e> benmachine: that works.
09:46:55 <benmachine> heh
09:46:57 <benmachine> nice
09:53:07 <lpsmith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19930#a19930
09:53:25 <lpsmith> if anybody has any ideas about how to improve that code,  I'm all ears. ^
09:54:03 <lpsmith> Also, bugs
09:54:20 <lpsmith> If anybody has ideas for how to test that code effectively,  I'm all ears!
09:54:28 <int-e> benmachine: for (\f -> f) f it does something odd - due to name capture, perhaps?
09:55:13 <lpsmith> int-e:  not really, the second f is different from the third f
09:55:14 <lpsmith> it's just
09:55:17 <lpsmith> for id f
09:55:30 <benmachine> int-e: that is odd
09:55:37 <int-e> lpsmith: yes. except that it goes into an infinite loop instead.
09:56:28 <benmachine> int-e: I spent quite a bit of time trying to make name capture not break it :P but I guess I missed a case
09:56:36 <lpsmith> well then,  "for id f" should go into an infinite loop for some reason :-)
09:56:42 <int-e> lpsmith:
09:56:57 <int-e> meh. lpsmith: the 'for' was part of the sentence, not the expression.
09:57:07 <lpsmith> oh
09:57:11 <lpsmith> :-D
09:57:57 <lpsmith> well then,  "(\f -> f) f " == "id f" == "f"
09:58:05 <lpsmith> "f" goes into a loop for some reason ;-)
09:58:13 <benmachine> heh
09:58:32 <benmachine> no it looks like my name substitution code is still acting up
09:58:53 <benmachine> oh, there we go
10:00:12 <benmachine> int-e: fixed that one
10:00:22 * benmachine goes back to working on primitive arithmetic operations
10:00:58 <lpsmith> ahh,  talking about your own interpreter,  not a mature Haskell implementation;  sorry for interjecting then :)
10:01:12 <benmachine> lpsmith: heh, yes
10:01:20 <MissPiggy> benmachine you implement by substiution?
10:01:45 <MissPiggy> I know a good other way to do implement beta-reduction
10:01:53 <MissPiggy> but maybe you have reasons
10:02:00 <benmachine> I don't have reasons
10:02:04 <benmachine> only confusion and anguish
10:02:18 <benmachine> p.s. http://github.com/benmachine/stepeval
10:02:27 <int-e> benmachine: next fun one: (\f x -> f (f x)) (\f -> f) f
10:02:56 <benmachine> int-e: heh, you're good at this
10:03:10 <MissPiggy> haha wiw
10:03:37 * benmachine stares at it for a bit
10:03:45 <Range_700>   MissPiggy
10:03:51 <MissPiggy> hi
10:03:56 <Range_700>   hi
10:04:04 <MissPiggy> im reading benmachines code
10:04:06 <Range_700>   how is  kermit
10:04:09 <MissPiggy> lol
10:04:19 <benmachine> MissPiggy: touché
10:04:27 <MissPiggy> huh?
10:04:37 <benmachine> never mind I thought you were lolling at my code :P
10:05:01 <Dodek> hey
10:05:05 <benmachine> hi
10:05:25 <Dodek> i'm using hSetBuffering hdl LineBuffering on some handle
10:05:41 <MissPiggy> well I don't even undersatnd it yet
10:05:42 <Dodek> and it seems it uses LF as line terminator
10:05:52 <Dodek> how can i make it use CRLF?
10:05:53 <MissPiggy> benmachine got a nice example of it in action??
10:06:44 <int-e> benmachine: you can't get away without alpha-conversion in general (unless you use de Buijn indices or something similar)
10:06:44 <benmachine> MissPiggy: lots of examples of it breaking, so far
10:06:51 <MissPiggy> why does it break?
10:07:03 <benmachine> because int-e does nasty things to it :P
10:07:20 <MissPiggy> you should definitely use de-bruijn indices then
10:07:25 <benmachine> int-e: it's supposed to recognise when a name is going to conflict and change the pattern in the lambda
10:07:40 <benmachine> wondering if it fails to do that somehow
10:07:40 <MissPiggy> change every variable NAME into a NUMBER (paired with a name, but the name is only for presentation)
10:08:02 <benmachine> MissPiggy: I'm not convinced that's necessary
10:08:13 <MissPiggy> well you are right -- if you implement what you just said instead, that works too
10:08:19 <benmachine> heh
10:08:38 <benmachine> most of the purpose of this thing is to produce an expression at every step that is legible
10:09:13 <int-e> benmachine: (\f x -> f (f (f (f (f x))))) (\g a b -> g (a b)) has normal form \x a b c d e f g -> x (a b c d e f g) - so 5 distinct variables became 8.
10:09:37 <benmachine> int-e: yeah, I do that at the moment by appending ' to things :P
10:09:42 <benmachine> except it seems to have failed to do so
10:09:52 <benmachine> but I'm aware of the conceptual difficulty, at least
10:10:14 <MissPiggy> this is such a good problem I want to play too :P
10:10:31 <MissPiggy> this is call by need evaluation I guess
10:10:48 <MissPiggy> oh "Call-by-macro-expansion"
10:10:50 <benmachine> it's trying to emulate haskell as far as possible
10:11:08 <benmachine> if it does something that haskell doesn't do that's a bug
10:11:17 <MissPiggy> okay so stuff like
10:11:28 <MissPiggy> let double x = x + x in double (double 3)
10:11:48 <benmachine> well you have to do that as let double = \x -> x + x
10:12:01 <benmachine> and hmm
10:12:19 <MissPiggy> --> let ... in double (3 + 3) --> #wormhole=(3 + 3) + wormhole
10:12:33 * MissPiggy doesn't know what the right way to do this is ..
10:13:09 <benmachine> let double = \x -> x + x in double (double 3) should evaluate to let double = \x -> x + x; x = double 3 in double x
10:13:13 <benmachine> I think
10:13:22 <benmachine> but I haven't got there yet
10:13:54 <MissPiggy> so LET is pretty much /the/ difficult part of this programing problem
10:14:02 <MissPiggy> oh, or is it?
10:14:20 <benmachine> there are a few difficult bits
10:14:21 <MissPiggy> (\double -> double (double 3)) (\x -> x + x) -- same difficult there I think
10:14:31 <benmachine> but let is probably one of the nastier ones
10:14:38 <MissPiggy> --> let double = \x -> x + x in double (double 3)
10:14:39 <kmc> ooh ooh we're talking about name binding representation
10:15:03 <MissPiggy> no we're not :P
10:15:24 <MissPiggy> benmachine and what about reduction underneath binders?
10:15:25 <copumpkin> @let thrice f = f . f . f
10:15:26 <lambdabot>  Defined.
10:15:30 <copumpkin> :t thrice thrice
10:15:31 <lambdabot> forall b. (b -> b) -> b -> b
10:15:40 <copumpkin> > thrice thrice (+1) 0
10:15:41 <lambdabot>   27
10:15:49 <benmachine> MissPiggy: can I make it stop infinite-looping first please
10:15:53 <MissPiggy> like if you have f = \x -> 2^65 + x in f 1 + f 2,  should it calc 2^65 at all?
10:15:53 <copumpkin> > thrice thrice thrice (+1) 0
10:15:54 <lambdabot>   * Exception: stack overflow
10:15:56 <MissPiggy> I mean twice
10:15:58 <kmc> no we're not?
10:16:06 <MissPiggy> > \(b :: Bool -> Bool) -> thrice b
10:16:06 <lambdabot>   {True->True;False->True}->
10:16:07 <lambdabot>    {True->True;False->True}
10:16:07 <lambdabot>  {True->True;False->...
10:16:13 <MissPiggy> > \(b :: Bool -> Bool) -> thrice b == b
10:16:14 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Bool.Bool -> GHC.Bool.Bool))
10:16:14 <lambdabot>    arisin...
10:16:25 <b0fh_ua> Can somebody please explain me, how can I restrict type of Chain to be Header in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19931#a19931 ?
10:17:01 <damd> b0fh_ua: you mean the parameters of Chain must have instances of Header?
10:17:23 <b0fh_ua> yes
10:17:29 <kmc> i guess for first order representations people like a locally-nameless approach
10:17:33 <kmc> and i found a 50 page paper about it :O
10:17:53 <damd> b0fh_ua: the data declaration right above Chain should give you an idea
10:17:55 <kmc> err, Header isn't a class
10:18:03 <kmc> it doesn't have instances
10:18:44 <b0fh_ua> kmc: Chain should contain variables of type Header
10:18:54 <kmc> then why make it parametrized
10:19:08 <b0fh_ua> good question
10:19:18 <damd> heh
10:19:22 <kmc> data Chain keyT valueT = Chain { current, previous :: Header keyT valueT }
10:19:36 <kmc> (still parametric but less so)
10:19:43 <ski> > \(b :: Bool -> Bool) -> all (\c -> thrice b c == b c) [False .. True]
10:19:44 <lambdabot>   {True->True;False->True}->
10:19:44 <lambdabot>    True
10:19:44 <lambdabot>  {True->True;False->False}->
10:19:44 <lambdabot>    True
10:19:44 <lambdabot>  {T...
10:20:00 <b0fh_ua> kmc: nice, thanks
10:20:04 <kmc> :)
10:20:22 <kmc> also, i don't understand the type of your "add" function
10:20:31 <copumpkin> :t thrice . thrice
10:20:31 <lambdabot> forall b. (b -> b) -> b -> b
10:20:38 <kmc> the use cases for functions that return () are pretty rare and specialized
10:20:42 <copumpkin> > (thrice . thrice) (+1) 0
10:20:42 <b0fh_ua> kmc: it's not so important for now
10:20:43 <lambdabot>   9
10:20:45 <kmc> ok
10:20:55 <b0fh_ua> I just didn't decide what it should return yet
10:21:00 <kmc> ok
10:21:14 <b0fh_ua> btw is there some sort of ide for haskell?
10:21:19 <kmc> leksah
10:21:23 <b0fh_ua> rather than vim
10:21:24 <kmc> haven't used it
10:21:29 <damd> emacs...
10:22:25 <MissPiggy> benmachines what's your beta reduction rule?
10:24:53 <MissPiggy> > 1+1
10:24:54 <lambdabot>   2
10:25:35 <benmachine> MissPiggy: rule?
10:25:43 <benmachine> (I've never done this stuff formally btw)
10:25:53 <MissPiggy> that's why your program doesn't work
10:26:07 <benmachine> no my program doesn't work because I keep getting gmapT wrong
10:26:14 <MissPiggy> oh
10:26:15 <benmachine> well possibly that's what you meant
10:26:23 <MissPiggy> no it's not
10:26:34 <benmachine> applyMatches is wrong
10:26:44 <benmachine> and it's wrong because I'm not very good at generic programming (yet)
10:27:09 <MissPiggy> wait what are you doing with gmap
10:27:43 <benmachine> applyMatches takes a list of (Name, Exp) and replaces instances of Name with Exp in the given argument
10:27:53 <benmachine> avoiding places where Name is shadowed
10:28:06 <benmachine> it uses gmapT
10:28:25 <MissPiggy> seems wild to use gmapT for that
10:28:36 <benmachine> what would you use?
10:28:49 <MissPiggy> i would write everything out long-hang
10:28:59 <benmachine> have you *seen* how many constructors Exp has?
10:29:35 <benmachine> not to mention all the various sub-structures like Alt and Decl and whatever
10:29:45 <MissPiggy> ahh this is Language.Haskell.Exts
10:30:01 <MissPiggy> see what I would do is define my own small language, and functions that take it to and from Language.Haskell.Exts
10:30:21 <MissPiggy> I think that would make things a lot easier
10:30:53 <benmachine> a lot easier and a lot more verbose and a lot more wheel-reinventy and a lot harder to expand later
10:31:14 <MissPiggy> huh?
10:31:16 <benmachine> you may have a point but I think I prefer my way
10:31:18 * MissPiggy cant parse that
10:31:22 <benmachine> heh
10:31:30 <MissPiggy> yeah okay if you like it that's finei
10:31:41 <benmachine> seems like your way just does work that's already been done
10:31:49 <MissPiggy> no I don't feel that way though
10:33:19 <MissPiggy> the thing about having a smaller data type is that you can use simpler tools to program on it
10:33:41 <BenceF> i cant install array-0.2.0.0 from cabal. all it says it gets exitfailure 1
10:33:53 <BenceF> anyone with the same problem?
10:34:04 <benmachine> MissPiggy: yeah, but if I eventually want to support a decent section of haskell, I am going to need a large data type sooner or later
10:34:14 <MissPiggy> why?
10:34:21 <benmachine> because there's just a lot of stuff around
10:34:32 <benmachine> a lot of different kinds of expressions and bindings
10:34:59 * benmachine pushes a few commits
10:35:14 <MissPiggy> Variables, Applications, Lambda, Let, Case, Constructors,  what else is there?
10:35:35 * hackagebot upload: binary-strict 0.4.8 - Binary deserialisation using strict ByteStrings (DominicSteinitz)
10:35:35 <benmachine> literals
10:35:44 <MissPiggy> oh yeah that's a good point
10:35:57 <MissPiggy> need to add a thing for Integers and Strings and so on
10:36:04 <MissPiggy> they can all go in one bok
10:36:04 <doserj_> BenceF: why do you want to install array-0.2.0.0? that's a library that comes with ghc.
10:36:06 <MissPiggy> box*
10:36:19 <benmachine> well, that's more or less all the bits of haskell-src-exts I'm using
10:36:25 <benmachine> it's already quite a few, though
10:36:52 <benmachine> if they contain subexpressions and lists of subexpressions, manually writing out the recursion is going to get boring fast
10:36:53 <BenceF> doserj_: ive got a newer version
10:36:55 <benmachine> and anyway
10:37:02 <benmachine> it would be nice if I could learn how to use Data
10:37:03 <b0fh_ua> Can you please take look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19947#a19947 ? I don't really like the fact that I have to provide similar definitions for MsgidChain and MsgidHeader. May be it is possible to deduct type of MsgidChain from MsgidHeader? An I don't really understand the cause of the error in instance declaration.
10:37:09 <MissPiggy> lists of subexpressions?
10:37:26 <benmachine> a case expression will have lists of subexpressions
10:39:32 <benmachine> int-e: http://benmachine.co.uk/cgi-bin/stepeval.cgi?expr=%28%5Cf+x+-%3E+f+%28f+x%29%29+%28%5Cf+-%3E+f%29+f I took my time but there you go :P
10:40:06 * benmachine wonders whether to improve the evaluation model or to implement FunBinds next
10:40:06 <aavogt> b0fh_ua: yes, if you want that to get inferred, you need to enable -XTypeSynonymInstances as it tells you
10:40:35 <doserj_> BenceF: you won't be able to build array-0.2.0.0 on ghc-6.12.x, if that is what you are trying to do
10:41:16 <BenceF> doserj_: that is
10:48:35 <MissPiggy> I can't figure out what stepping should be like for this sort of situation
10:48:58 <MissPiggy> let x = (\a -> ...) in x p + x q
10:49:24 <MissPiggy> (\a -> ...) p + (\a -> ...) q?
10:50:06 <bssj> Can someone look at my recent hpaste and let me know why I'm getting the error.
10:50:11 <bssj> It doesn't make sense to me.
10:50:24 <aavogt> sure
10:50:31 <aavogt> MissPiggy: what's the alternative?
10:50:33 <mreh> bssj: repost?
10:50:40 <waterlaz> yeah... link
10:50:49 <MissPiggy> I don't know
10:50:53 <sfuentes> anyone know when the next release of the haskell platform will be released?
10:50:56 <bssj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19948#a19948
10:51:04 <MissPiggy> what about:  let double = \x -> x + x in double (double 3)   how should that step?
10:51:08 <int-e> bssj: use Integer rather than Int
10:51:13 <aavogt> maybe leave out the intermediate step of   (\a -> ...) p, and go straight to  ( .... p ... )
10:51:19 <int-e> > 13292279957849158729038070602803445760000000000000000000000000000000000000000 :: Int
10:51:21 <lambdabot>   0
10:51:52 <bssj> int-e: Doesn't work.  "m" has an inferred type of Int anyway.
10:52:48 <waterlaz> you can't use Int for such large numbers
10:52:49 <int-e> bssj: can you paste the types of chance_all_mythic_playset and mythic_playset_combinations_ratio?
10:52:55 <waterlaz> change it to Integer
10:53:14 <int-e> bssj: it's possible that you need a fromIntegral somewhere, but it's impossible to tell without the types
10:53:17 <waterlaz> in all those functions also
10:53:25 <bssj> Hrm.  Something in my definition of mythic_playset_combinations_ratio forces the first argument to be Int.
10:53:34 <bssj> I'll edit my paste with more info.
10:53:36 <bssj> Just a sec.
10:53:37 <waterlaz> it's not a type error... he has a runtme error
10:53:50 <waterlaz> give us that defnition
10:54:35 <int-e> waterlaz: it is a runtime error caused by using Ratio Int instead of Ratio Integer
10:54:38 <bssj> let mythic_playset_combinations_ratio m n = (mythic_playset_combinations m n) Ratio.% 1
10:54:49 <aavogt> MissPiggy: outermost, no sharing:    let double = \x -> x + x in double 3 + double 3,   or innermost:   let double = \x -> x+x in double (3+3) ==>   double (6) ==> 6+6 ==> 12
10:54:51 <bssj> bssj: I'm thinking (1 :: Integer) instead?
10:55:21 <MissPiggy> to do stepping with sharing, you need to actually create new lambda expressions?
10:55:26 <int-e> bssj: try foo m n = chance_all_mythic_playset (m :: Integer) * mythic_playset_combinations_ratio (fromIntegral m) (n :: Integer)
10:55:27 <aavogt> though I think you sometimes have a choice between multiple innermost reducible expressions
10:55:31 <MissPiggy> I mean let expressions
10:56:21 <aavogt> as in which one first:   (1+1,2+2)
10:56:33 <MissPiggy> I think the best way is probably to evaluate the thing into a GRAPH and them make a thing which does (A) single step of graph reduction (B) turns a graph into a linear haskell expression
10:56:38 <MissPiggy> benmachine ^
10:56:53 <benmachine> you are very possibly right
10:56:59 <benmachine> but that sounds hard :P
10:57:01 <MissPiggy>  but?
10:57:03 <bssj> int-e: Okay.  That seems to work.  Thanks.
10:57:05 <MissPiggy> does it?
10:57:07 <aavogt> the haskell syntax representation isn't a graph?
10:57:07 <MissPiggy> I don't think so
10:57:15 <MissPiggy> aavogt, no it's a tree
10:57:24 <benmachine> a tree is a sort of graph?
10:57:26 <bssj> int-e: In general is there a better way to do "(some expression) Ratio.% 1"
10:57:29 <benmachine> <_<
10:57:34 <MissPiggy> avvogt, and I mean it has to be a tree to be able  to get turned into a finite string (for viewing)
10:57:43 <int-e> bssj: you can use fromIntegral for that, too
10:57:47 <MissPiggy> the reason graph is seperate is because you need 'pointer' equality on it
10:58:00 <bssj> int-e: Basically I'm trying to take an Integral value and coerce it into a Ratio value.
10:58:07 <int-e> > fromIntegral 100 :: Rational
10:58:08 <lambdabot>   100 % 1
10:58:15 <int-e> @type fromIntegral
10:58:16 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:58:24 <benmachine> MissPiggy: hmm
10:58:24 <aavogt> @type (%1)
10:58:25 <lambdabot> forall a. (Integral a) => a -> Ratio a
10:58:42 <benmachine> well, I'm hungry
10:58:44 <MissPiggy> pointers can be just an Int that gets put into a map or whatever
10:58:46 <benmachine> so I'm going to address that
10:58:46 <aavogt> @type (%1) :: Integer -> Rational
10:58:47 <lambdabot> Integer -> Rational
10:59:09 <benmachine> then I might look at how I can convert a HSE expression to a graph and back
11:01:00 * MissPiggy is trying to think of how to do that too
11:01:37 <bssj> Thanks.  I'll check my types more closely next time.  I'm still quite a noob at haskell.
11:02:09 <lpsmith> So, is there a way to declare a function {-# INLINE #-},  but then selectively disable inlining at one or two call sites?
11:02:25 <mreh> bssj: lots of explicit type signatures always helps
11:02:32 <mreh> atleast on every top level function
11:02:32 <lpsmith> GHC.Exts.inline allows for selective inlining at a given call site
11:02:46 <bssj> mreh: I'm doing this all from ghci for now.
11:03:03 <jmcarthur> lpsmith: have one version of your function that inlines and one that doesn't?
11:03:10 <bssj> mreh: I really do need to throw it into a file though.  Getting tied of defining some of the basic functions.
11:03:12 <mreh> bssj: that doesn't stop you annotating tings
11:03:16 <lpsmith> hmm,  that might work
11:03:28 <mreh> bssj: you can load files into ghci
11:03:37 <mreh> :load filename
11:03:51 <bssj> mreh: Yeah, I know.  I just haven't written anything to a file.
11:03:53 <lpsmith> I dunno,  maybe I shouldn't mess around with all that without some real benchmarks to guide me
11:04:06 <bssj> mreh: So far this entire "project" has been typed at the ghci prompt.
11:04:30 <bssj> mreh: How to you give a type signature to a let from the ghci prompt?
11:04:38 <lpsmith> bssj, I strongly recommend editing it in a text editor,  and then saving and typing :r
11:04:43 <lpsmith> in ghci
11:05:00 <int-e> bssj: you can do  let x :: Int; x = 4
11:05:05 <b0fh_ua> aavogt: okay, that did the trick. Now I have some strange question, raising from OO experience in Java. Let's say that I want to provide single interface (HeaderStorage) and implement 2 strategies of handling messages - plain file and database. How would I pass desired instance of HeaderStorage to a function which uses it's methods?
11:05:11 <benmachine> bssj: you can use the :e command to easily switch between your editor and your ghci prompt
11:05:17 <benmachine> (ghci's :e command)
11:05:35 <bssj> Didn't know about :r or :e.
11:05:42 * bssj needs to read more documentation.
11:05:48 <int-e> @info Sum
11:05:48 <lambdabot> Sum
11:05:50 * bssj Been focusing on language specs instead of tools.
11:05:50 <mreh> or alt-tab between the windows
11:05:53 <benmachine> heh
11:05:56 <b0fh_ua> looks like instance just defines how the functions will be applied to arguments of concrete type
11:05:59 <benmachine> you can't always know everything, bssj
11:06:12 <benmachine> so I wouldn't worry about it too much
11:06:19 <lpsmith> bssj, that's generally the trend in the Haskell community.  Great language,  so-so tools
11:06:30 <shapr> Hey, emacs rocks!
11:06:37 * MissPiggy is trying to design a graph language.....
11:06:41 <lpsmith> As a long time emacs user,  I hate it :)
11:06:43 <The_third_man> VIM's better
11:06:47 <MissPiggy> that you can quote back into haskell
11:06:52 <shapr> lpsmith: Which tools do you think need improvement? and in what way?
11:06:53 <benmachine> obv yi is the best
11:07:20 <mreh> the tools are great, there just aren't as many of them
11:07:21 <int-e> b0fh_ua: you can wrap the data into a newtype, like Data.Monoid does with Sum and Product to provide monoid instances for both addition and multiplication of numbers
11:07:37 <lpsmith> I generally agree with mreh
11:07:37 <benmachine> MissPiggy: if you supplant my days of hard work before I've got back from dinner, I will be upset :P
11:07:54 <int-e> > getSum $ mconcat $ map Sum [1..10]
11:07:55 <lambdabot>   55
11:08:00 <b0fh_ua> int-e: I'm not familiar with monads much
11:08:00 <shapr> lpsmith: So, gimme some specifics... which tools and how?
11:08:02 <MissPiggy> what's supplant?
11:08:05 <int-e> > getProduct $ mconcat $ map Product [1..10]
11:08:06 <lambdabot>   3628800
11:08:12 <aavogt> b0fh_ua: might be more sensible to define:    data HeaderStorage = HeaderStorage { method1, method2, method3 :: IO (), name :: String }
11:08:27 <aavogt> and then pass around values of type HeaderStorage
11:08:45 <benmachine> MissPiggy: I was going to look it up in google's dictionary for you but my DNS has suddenly died
11:08:52 <benmachine> so you are going to have to find out yourself
11:09:01 <benmachine> it was a tongue-in-cheek comment, anyway
11:09:04 <b0fh_ua> aavogt: so I can define methods within "data" ?
11:09:05 <shapr> http://en.wiktionary.org/wiki/supplant
11:09:09 <aavogt> yes
11:09:20 <shapr> So, does anyone here know Melanie Krumbein from Leipzig?
11:09:31 <b0fh_ua> nice
11:09:39 <lpsmith> Well,  look at idle for Python,  or netbeans for Java/Scala and a half-dozen other languages.
11:09:50 <shapr> Ah, you specifically mean editors?
11:09:59 <aavogt> b0fh_ua: but say you want to mix additional interfaces, you could still use typeclasses
11:10:07 <lpsmith> Sure,  Emacs has etags,  but it's a hassle to use compared to the others, which just work
11:10:29 <aavogt> like:    class C a where method1 :: a -> IO (); ... -- and each method takes the type a as a parameter
11:10:30 <lpsmith> I really like the code coverage profiler for Haskell though
11:10:39 <b0fh_ua> aavogt: I guess that designing applications in functional style is so different from ones in objected-oriented style
11:10:48 <lpsmith> A few of our tools really don't have a counterpart elsewhere that I'm aware of
11:10:59 <aavogt> the difference being that classes are global per instance
11:11:19 <aavogt> b0fh_ua: It seems you can design stuff pretty similarily
11:11:21 <lpsmith> I've tried Leksah,  but I didn't really like it myself :-/
11:12:09 <lpsmith> I don't think it's fair to say that Haskell has bad tools,  but I also think that it's fair to say that overall,  languages such as Java or C# have better tools.
11:12:24 <aavogt> b0fh_ua: an important difference is that with typeclasses is that you can resolve which instance to use based on say a result type
11:12:41 <b0fh_ua> aavogt: so it's simply wrong way to declare interface, provide 2 implementations of that interface and then pass reference to the concrete implementation of that interface to a function, which supposed to invoke methods of this interface on passed instance
11:13:01 <aavogt> which way?
11:13:25 <sfuentes> anyone know when we will see the next release of the haskell platform?
11:13:46 <lpsmith> If I were starting with either VIM or Emacs today,  I'd choose VIM
11:13:47 <aavogt> that seems pretty roundabout...
11:14:01 <lpsmith> But my interest in learning a new text editor is pretty low
11:14:13 <b0fh_ua> aavogt: define interface (class) and provide implementations (instances)
11:14:34 <lpsmith> VIM has gotten a *lot* better in the last 12 years,  real improvements in Emacs are harder to come by.
11:14:44 <aavogt> emacsclient?
11:14:45 <damd> can't improve what's perfect
11:14:46 <b0fh_ua> I can provide only one instance of class for each type of variable
11:15:08 <shapr> haha
11:15:22 <shapr> I use emacs for coding, but I use vim for sysadmin tasks.
11:15:24 <aavogt> yeah, but you can easily create different types
11:15:29 <lpsmith> yeah,  b.s.  Emacs is the by far the most modal text editor I use,  even moreso than modern VIM.
11:15:45 <shapr> huh, it's never seemed that way to me.
11:15:48 <b0fh_ua> aavogt: that's true
11:16:01 <b0fh_ua> so this design approach simply doesn't work in haskell
11:16:15 <lpsmith> the problem is the key chording;  that really is highly modal
11:16:17 <b0fh_ua> at least it doesn't work in same way as it does in Java for example
11:16:34 <lpsmith> I'm constantly bumping a key or fat-fingering something,  and then it's a challenge to get out sometimes
11:16:50 <shapr> Huh, I have great success with a kinesis contoured keyboard, and my hands are quite large.
11:17:31 <lpsmith> I mean... hit e.    Then hit c-x.   Then walk away for 10 minutes and come back and hit e
11:17:36 <MissPiggy> all the better of lambda hacking with!!
11:17:38 <lpsmith> You don't get the same thing as the first time
11:17:44 <lpsmith> That's the very definition of modality
11:17:54 <shapr> huh?
11:18:28 <shapr> Well, I perceive a big difference between vim and emacs.
11:19:13 <lpsmith> c-x  then e invokes a keyboard macro
11:19:18 <lpsmith> just e type e
11:19:35 <lpsmith> but you can hit c-x and release both and walk away for an hour and come back and hit e and invoke a keyboard macro
11:20:08 <lpsmith> VIM has gotten much less modal,  in effect,  by doing things such as not leaving insert mode when you hit an arrow key or home and end
11:20:15 <lpsmith> No such luck with emacs
11:20:27 <shapr> lpsmith: You're free to switch :-)
11:20:33 <aavogt> control-o?
11:21:11 <alise> Just so I don't duplicate effort: is there any library or Haskell-generating tool for parsing and deparsing? That is, you write a data structure and describe how the syntax relates to it (like a parser; in an EDSL or a separate syntax), and it generates both a parser and a deparser
11:21:45 <lpsmith> shapr, All I'm saying is that emacs is modal.  In fact,  more modal than VIM :)
11:22:16 <shapr> I disagree, but I can see some substance to what you say.
11:22:18 <aavogt> alise: deriving (Read, Show)?
11:22:43 <MissPiggy> shapr I want to do old school hardcore
11:22:47 <alise> aavogt: Yeah, uh, there's the slight issue there that you can't plug in your own syntax.
11:23:01 <shapr> MissPiggy: Haskell old school hardcore? Tried hbc or nhc?
11:23:30 <MissPiggy> shaply I don't really know anytning so I |: can't
11:23:49 <lpsmith> I mean, what would be nice is that you'd have to hit control,  hold it down to hit x and e,  then release,  if you release control before hitting e, then it would be whatever C-x is bound to followed by typing an E=e
11:24:00 <lpsmith> But emacs can't have that
11:24:08 <lpsmith> because it's hobbled by terminal interfaces
11:24:18 <lpsmith> In order to have that,  you have to give up VT100 support
11:24:48 <alise> holding modifier keys is bad enough (that's why sticky keys exists), don't make it worse :)
11:25:48 <shapr> lpsmith: Ok so.. back to the original tack, what Haskell tools do you think are lacking?
11:27:26 <lpsmith> NetBeans or Eclipse support would be nice;  I know a few people have worked on the latter but it never gets maintained
11:27:50 <lpsmith> Look at Factor's listener;  haskell has nothing comparable
11:27:51 <jlouis> I've always found netbeans and eclipse to be utter crap from hell
11:28:07 <jlouis> lpsmith: what does factors listener do?
11:29:33 <lpsmith> jlouis, integrated help,  debugging,  graphics,  with a high level of polish
11:30:06 <jlouis> lpsmith: somewhat resembling Erlangs or Lisps REPLs?
11:30:50 <lpsmith> Debugger support has gotten better,  and admittedly debuggers for Haskell is a harder problem than debugging Scheme or ML.   I've pretty much learned to do without;  but that doesnt' mean other people like the situation
11:31:29 <lpsmith> Well, Erlang's repl isn't like Factor's listener,  which is based on McClim and Smalltalk
11:32:12 <dankna> I can do without about 95% of the time
11:32:18 <dankna> but the remaining five percent is important
11:32:27 <jlouis> lpsmith: I think the solution is the build some kind of interaction interface between the editor and ghci
11:32:30 <domor> is (putStrLn "test" >> Foo <$> getLine) proper applicative style? I'm not sure if it's idiomatic to mix (>>) and (<$>), etc.
11:36:57 <kmc> well it's not applicative style in that the type has to be a monad
11:37:05 <kmc> but i think it's fine style, yes
11:37:26 <kmc> :t (<*)
11:37:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:37:31 <kmc> :t (*>)
11:37:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
11:37:43 <kmc> that's the applicative equivalent of (>>)
11:37:57 <kmc> but i think (>>) is more familiar
11:38:24 <domor> thanks
11:40:19 <lpsmith> so nobody has comments on my unionAll implementation?   :)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19930
11:40:31 <MissPiggy> shapr to you like 808 state :)
11:40:40 <lpsmith> Bugs,  testing strategies,  simplifications?  :)
11:40:44 <Drk-Sd> how dœs the <$> work?
11:40:49 <shapr> MissPiggy: eh?
11:40:50 <MissPiggy> dœs?? lol
11:41:05 <Drk-Sd> (:-°)
11:41:46 <burp> @src (<$>)
11:41:46 <lambdabot> f <$> a = fmap f a
11:42:03 <Drk-Sd> 'k thx
11:42:05 <burp> no magic behind it ;)
11:42:42 <burp> although these fancy operator symbols might suggest it :D
11:45:01 <kmc> (<$>) = fmap
11:45:05 <mreh> there are too many operators
11:45:15 <Drk-Sd> yep
11:45:34 <mreh> someone said "haskell operators are so long they have perspective"
11:45:39 <mreh> in a blog somewhere
11:45:49 <monochrom> It beats having too many functions.
11:45:59 <kmc> it also beats letting people overload operators but not define new ones
11:46:07 <kmc> that results in terrible things
11:46:14 <MissPiggy> there should be a #haskell radio station
11:46:15 <mreh> but they're over loading the same concepts
11:46:38 <mreh> 24-7 haskore music
11:46:40 <kmc> no, not at all
11:46:45 <kmc> in C++, << means both "bit shift left" and "write to output stream"
11:47:08 <Zao> kmc: And much much more, depending on depravity of libraries.
11:47:15 <mreh> of course that's bad, that's not what I said
11:47:16 <kmc> yeah, that's just within the standard library
11:47:41 <mreh> fmap = liftM = <$>
11:47:51 <kmc> should be anyway
11:47:52 <mreh> @src liftM2
11:47:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:13:59 <Veinor> anybody have any experience working with terminal escape sequences?
12:14:32 <masak> would that be escape sequences that can kill you?
12:14:45 <Veinor> :P
12:15:24 <p_l> Veinor: look into terminfo
12:15:33 <dmwit> Veinor: Well, I've written a VT100 parser... so I guess you could say I have some.
12:15:37 <dmwit> More than some, less than others.
12:16:36 <Veinor> basically, I'm just outputting the usual color code escape sequences
12:16:48 <Veinor> but weird things happen whenever I resize the terminal to be narrower than a line of text
12:16:58 <Veinor> instead of wrapping onto a new line, it starts overwriting itself
12:20:38 <p_l> Veinor: you have to catch info on resizing and probably clean the screen and output again
12:21:02 <Veinor> this is just for my $PS1
12:21:16 <dmwit> What term?
12:21:22 <Veinor> xterm
12:21:30 <dmwit> Solution: don't use xterm. =)
12:21:33 <Veinor> :P
12:21:40 <Veinor> but the bash script I was using works fine
12:23:32 <MissPiggy> PS1?
12:23:36 <Veinor> shell prompt
12:23:43 <MissPiggy> I just set PROMPT='%% '
12:23:49 <MissPiggy> it's sweet
12:23:53 <Veinor> I think I might just write this in python, I don't want to do this complicated terminfo stuff :P
12:24:08 <MissPiggy> uhh why would you want to do anything in the terminal
12:24:16 <MissPiggy> just use a real gui
12:24:33 <lpsmith> it's a simple programming interface,  and for many tasks terminals work well
12:24:33 <Veinor> because I can do it faster in a terminal?
12:24:41 <Veinor> I mean, I use irssi :P
12:24:49 <dmhouse> Hi guys. What's the quickest way to print a Double, rounded to exactly 4 decimal places?
12:25:24 <Veinor> you mean four digits after the decimal point?
12:25:55 <monochrom> @type showFFloat
12:25:56 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
12:26:10 <monochrom> > showFFloat (Just 4) 0.111111
12:26:11 <lambdabot>   ""->
12:26:11 <lambdabot>    "0.1111"
12:26:11 <lambdabot>  "a"->
12:26:11 <lambdabot>    "0.1111a"
12:26:11 <lambdabot>  "aa"->
12:26:12 <lambdabot> [3 @more lines]
12:26:13 <monochrom> > showFFloat (Just 4) 0.111111 ""
12:26:14 <lambdabot>   "0.1111"
12:26:26 <Veinor> now I'm trying to figure out how to round a float to n places...
12:26:43 <dmhouse> Well that bit I can do: (round $ f*10^n)/10^n
12:26:46 <monochrom> > read (showFFloat (Just 4) 0.111111 "")
12:26:47 <lambdabot>   * Exception: Prelude.read: no parse
12:26:51 <monochrom> > read (showFFloat (Just 4) 0.111111 "") :: Double
12:26:52 <lambdabot>   0.1111
12:26:56 <dmwit> > printf "%.4f" (0.11111111)
12:26:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:26:57 <lambdabot>    `Text.Printf.PrintfType ...
12:26:58 <Veinor> monochrom: eww :(
12:27:01 <dmwit> > printf "%.4f" (0.11111111) :: String
12:27:02 <lambdabot>   "0.1111"
12:27:14 <dmhouse> Okay, thanks guys.
12:27:14 <dmwit> > printf "%2.4f" (0.11111111) :: String
12:27:15 <lambdabot>   "0.1111"
12:27:23 <dmhouse> printf truncates rather than rounds, right?
12:27:32 <monochrom> What's wrong with showing then reading? :)
12:27:35 <dmhouse> > printf "%.1f" 0.55 :: String
12:27:36 <Veinor> > printf "%.4f" (0.999999" :: String
12:27:36 <lambdabot>   "0.6"
12:27:37 <lambdabot>   <no location info>:
12:27:37 <lambdabot>      lexical error in string/character literal at end o...
12:27:41 <Veinor> > printf "%.4f" (0.999999) :: String
12:27:42 <lambdabot>   "1.0000"
12:27:47 <dmhouse> Oh, hmm, I think that's different to C.
12:28:02 <monochrom> Not different.
12:28:34 <gwern> a little sobering to realize that http://www.woot.com/ 's 239$ computer is not that much inferior to my current desktop which I handbuilt 2 or 3 years ago for ~1000
12:29:33 <cheater3> is this true? Y g = g g g g g g g g ...
12:29:58 <tromp> no
12:30:14 <aavogt> you need to associate differently
12:30:15 <dmhouse> No, cheater3. Y g = g (Y g) = g (g (g (g ...)))
12:30:19 <tromp> Y g = g (Y g)
12:30:28 <cheater3> dmhouse: that is what i had meant
12:30:31 <gwern> (single core, rather than quad; half my ram; and short 180G of hard drive space; but 700$ easily covers all that)
12:30:43 <cheater3> dmhouse: what did what i wrote mean?
12:30:50 <monochrom> gwern: It is refurbished, that's why. Also I'm thinking Athlon 2850e 1.8GHz is quite inferior to most CPUs most of us use.
12:30:58 <dmhouse> cheater3: you were doing a single call to g with infinitely many arguments, all g
12:31:02 <aavogt> ((((((((((((g g) g) g) g) g) ....
12:31:06 <cheater3> oh ok
12:31:08 <dmwit> cheater3: You wrote ((((((((...g g) g) g) g) ...
12:31:11 <gwern> monochrom: sure but refurb means it's getting closer to parts-cost
12:31:22 <cheater3> yeah, i meant what you wrote
12:31:23 <IceDane> In GHCI, given two functions: fn1 :: IO String and fn2 :: String -> Maybe String, shouldn't fn1 >>= fn2 work?
12:31:26 <IceDane> Directly in the shell?
12:31:29 <tromp> infinite aaplication never goes anywhere
12:31:34 <aavogt> @type (>>=)
12:31:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:31:37 <dmwit> IceDane: nope
12:31:42 <aavogt> IceDane: the m's have to be the same
12:31:46 <IceDane> Oh, duh
12:31:48 <monochrom> It's close to parts-cost because it comes with low warranty.
12:31:49 <IceDane> Yeah
12:31:51 <IceDane> thanks
12:31:52 <dmhouse> IceDane: otherwise you could escape from the IO monad
12:31:52 <IceDane> brainfart
12:32:03 <cheater3> so looking at this formula... why is Y a fixed point combinator?
12:32:09 <gwern> monochrom: as opposed to parts with like no warranty
12:32:34 <benmachine> cheater3: you know what a fixed point is?
12:32:38 <monochrom> You spend twice and got no warranty?
12:32:38 <cheater3> yes
12:32:48 <cheater3> a such that a = fa
12:32:59 <dmhouse> cheater3: note that g (Y g) is equal to Y g. Thus Y g is a fixed point of g.
12:33:04 <dmhouse> Y g = a in your notation
12:33:13 <cheater3> aha
12:33:27 <cheater3> so Y is not a fixed point combinator
12:33:37 <damd> what
12:33:40 <cheater3> it's a functional that generates fixed point combinators?
12:33:48 * cheater3 is a bit lost
12:33:50 <cheater3> oh, ok
12:33:51 <monochrom> ((((((((((((g g) g) g) g) g) .... is not useful.
12:33:52 <cheater3> never mind
12:33:53 <cheater3> =)
12:33:58 <kpreid> no, it's a function that generates fixed points :)
12:33:59 <benmachine> cheater3: it is a combinator
12:34:06 <cheater3> kpreid: gotcha
12:34:31 <dmhouse> Functionals (functions of functions) are just functions in languages where functions are "first-class" (e.g. Haskell)
12:35:16 <gwern> http://www.newegg.com/Product/Product.aspx?Item=N82E16822136513 1.5TB for 110$. truly, diskspace is no longer an issue for most everyone
12:35:17 <cheater3> is there a simple (mathematical hopefully) function upon which we can evaluate Y and come up with a cognizable formula for the result?
12:36:16 <dmhouse> Any lazy function will work just fine
12:36:16 <tromp> sure, const 0
12:36:52 <cheater3> how about something like, say, x^2
12:37:01 <cheater3> how does Y x^2 work?
12:37:26 <dmhouse> It will diverge, since x |-> x^2 is strict
12:38:04 <cheater3> i do not know what it means that a function is strict
12:38:12 <benmachine> Y is useless with any function that must use its argument
12:38:20 <dmhouse> In the langauge of Haskell, it will be bottom (_|_), which is a fixed point of every strict function.
12:38:27 <benmachine> a function that might or might not use its argument could give an answer
12:38:37 <cheater3> dmhouse: i did not understand that
12:39:02 <monochrom> > fix (\x -> 0:x)  {- example 0 for cheater3 -}
12:39:03 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:39:12 <dmhouse> cheater3: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion might help
12:39:15 <cheater3> monochrom: i understand that fix != Y
12:39:25 <Philippa> dmhouse: strictly speaking _|_ is denotational semantics and haskell just has "indistinguishable from undefined"...
12:39:37 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1))  {- example 1 -}
12:39:41 <lambdabot>   mueval-core: Time limit exceeded
12:39:46 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1)) 5  {- example 1 -}
12:39:47 <lambdabot>   0
12:40:01 <monochrom> fix and Y do the same thing at this level
12:40:19 <cheater3> at what level do they do something else?
12:40:23 <Philippa> Y is an instance of fix
12:40:28 <dmwit> cheater3: "fix" finds the _least_ fixed point, and infinite loops are defined to be less than any other value.
12:40:29 <monochrom> Calculate Y (\f x -> if x==0 then 0 else f (x-1)) 5 by hand if you like.
12:41:02 <dmwit> cheater3: So if your function f depends on the value of its input in a non-trivial way, then (fix f) will be an infinite loop.
12:41:03 <cheater3> dmwit: i do not know how an infinite loop is a value, can you explain?
12:41:30 <dmwit> :t undefined -- cheater3, for example, this is often defined as an infinite loop
12:41:31 <lambdabot> forall a. a
12:41:34 <dmwit> undefined = undefined
12:41:41 <dmwit> or
12:41:47 <dmwit> loop = loop -- if you prefer
12:41:57 <cheater3> monochrom: i'm trying to, but i've no idea how, i'm not that good with lambda calculus yet, i've only started learning it yesterday
12:42:17 <monochrom> Use Y g = g (Y g).
12:42:26 <cheater3> dmwit: i cannot cognize that
12:42:28 <cheater3> monochrom: ok
12:42:44 <monochrom> Y (\f x -> if x==0 then 0 else f (x-1)) 5 = (\f x -> if x==0 then 0 else f (x-1)) (Y g) 5
12:42:54 <monochrom> err
12:43:07 <monochrom> Y (\f x -> if x==0 then 0 else f (x-1)) 5 = (\f x -> if x==0 then 0 else f (x-1)) (Y (\f x -> if x==0 then 0 else f (x-1))) 5
12:43:10 <dmwit> cheater3: Okay. You tell me: how would you write an infinite loop in Haskell?
12:43:29 <monochrom> You can also use the raw definition of Y if you want.
12:43:53 <cheater3> dmwit: i do not know - i'm pretty new in haskell. for example i could do something like, let f = f
12:43:59 <aavogt> > let x = x in x
12:44:02 <dmwit> cheater3: Exactly!
12:44:03 <lambdabot>   mueval-core: Time limit exceeded
12:44:11 <dmwit> cheater3: I just named "f" to be "loop" or "undefined". =)
12:44:25 <cheater3> dmwit: ahh right, you were using pointless notation. i'm still new to that
12:44:33 <dmwit> cheater3: No, I used pointed notation.
12:44:42 <dmwit> I used exactly the same notation you did!
12:44:45 <dmwit> Just with a different name!
12:44:46 <cheater3> how is f = f pointed?
12:44:49 <djahandarie> (It is called point-free btw)
12:44:58 <monochrom> f is the point.
12:44:59 <dmwit> "f" is the point =)
12:45:01 <cheater3> djahandarie: i was saying that half jokingly
12:45:23 <cheater3> dmwit: i don't understand why f is the point. i thought pointed notation required a function *and* the names of the arguments.
12:45:35 <monochrom> f is the anme of the argument.
12:45:39 <dmwit> cheater3: Okay, let's skip that. It's not important right now.
12:45:49 <aavogt> there is no argument
12:45:59 <monochrom> Anyway it is lambda calculus so there is no distinction.
12:46:01 <cheater3> dmwit: ok
12:46:06 <cheater3> monochrom: argument to.. what?
12:46:08 <dmwit> What is important: "f = f" is an infinite loop, and is defined to be the least value at any type.
12:46:11 <cheater3> monochrom: that's fairly interesting.
12:46:13 <cheater3> dmwit: yeah
12:46:42 <dmwit> cheater3: So, if "f" is a fixed point of your function g, then you will get an infinite loop as the result of "fix g".
12:47:21 <dmwit> cheater3: We say a function is _strict_ if it has your "f" as a fixed point.
12:47:25 <cheater3> which means that fix g = f
12:47:29 <cheater3> where f = f?
12:47:34 <dmwit> yes
12:47:59 <cheater3> why is x^2 strict?
12:48:14 <dmwit> Because (infinite loop)^2 = infinite loop
12:48:16 <benmachine> because you need to know what x is to get any part of the answer
12:48:16 <ksf> not necessarily
12:48:39 <cheater3> but i can tell you that the fixed points of x^2 are 0 and 1
12:48:39 <dmwit> Or, to answer another way, what do you think should be the result of squaring an infinite loop?
12:48:45 <benmachine> hmm maybe I should keep out of this, too many cooks etc.
12:48:45 <ksf> most of the Num instances are strict, but not necessarily.
12:48:48 <dmwit> cheater3: Yes, but they are not the least fixed points.
12:49:07 <cheater3> wait a second, how is a loop a valid argument for x^2?
12:49:08 <dmwit> cheater3: Because an infinite loop is lesser. =)
12:49:16 <dmwit> :t let f = f in f
12:49:17 <lambdabot> forall t. t
12:49:20 <ksf> :t infinity
12:49:21 <lambdabot> Natural
12:49:26 <dmwit> cheater3: An infinite loop is a valid argument to *any* function. =)
12:49:30 <ksf> > infinity ^ 2
12:49:31 <lambdabot>   Not in scope: `infinity'
12:49:36 <ksf> argh
12:49:45 <cheater3> dmwit: i do not understand that
12:49:48 <ksf> ...anyway, the peano instance of num is lazy
12:49:54 <dmwit> cheater3: Part of the problem here, I think, is that you're working in the wrong domain.
12:49:55 <oxamus> machines run infinite loops in 5 mins these days, no excuse to not use Haskell
12:50:07 <dmwit> cheater3: You're used to a domain that doesn't have infinite loops (i.e. most of math).
12:50:10 <pikhq> cheater3: "let f = f in f" is a value in any type.
12:50:21 <Philippa> dmwit: you should explain the ordering in question, if you haven't already
12:50:29 <dmwit> cheater3: So you'll just have to get used to the differences involved when there are undefined values like this.
12:50:34 <dmwit> Philippa: Go for it.
12:50:49 <Philippa> _|_< (_|_, _|_) < (1, _|_) < (1,1)
12:50:49 <dmwit> Philippa: (I agree that's a good idea.)
12:51:03 <Philippa> it's the amount of information present in the value
12:51:19 <cheater3> wait
12:51:33 <monochrom> Y does not solve equations like x=x^2. Y does not use a smart method.
12:51:34 <aavogt> Philippa: compare (_|_, 1) (1, _|_)
12:51:37 <Philippa> (1,_|_) and (_|_,1) have no ordering in relation to each other
12:51:38 <cheater3> i'm talking about the Y combinator in maths, not the Y combinator version in haskell
12:51:40 <rothwell> 'lo. quick question: documentation for Happy seems to suggest that i don't need to use it in combination with 'alex' for lexing. is this really the case?
12:51:48 <Philippa> cheater3: same thing
12:51:50 <cheater3> and the x^2 function in mathematics, not in haskell
12:52:01 <Philippa> we're actually talking domain theory, right?
12:52:03 <cheater3> no, the x^2 function is defined, in my instance, for real numbers
12:52:28 <rothwell> (by that i mean, "is Happy capable of doing lexing itself?")
12:52:35 <Philippa> yeah, only it's /actually/ defined here over the union of the reals and _|_
12:53:02 <cheater3> in haskell yes
12:53:12 <cheater3> but i am not considering this in haskell, i am considering this in mathematics
12:53:26 <Philippa> and in mathematics, Y is irrelevant as applied to /just/ the real numbers
12:53:35 <dmwit> rothwell: no
12:53:44 <cheater3> well, this is what i am trying to figure out
12:53:49 <dmwit> rothwell: If you don't want to use alex, you should probably use something else for lexing.
12:53:49 <Philippa> but squaring is /also/ defined on, amongst other things, the naturals and the reals 'lifted' to include _|_
12:54:16 <Philippa> Y is meaningless without bottom
12:54:20 <rothwell> dmwit: ok, just so i know. i've no problem with using alex for lexing
12:54:29 <Philippa> literally: you can't define what it means without allowing for the possibility
12:54:43 <rothwell> cheers! o/
12:55:24 <monochrom> Math is fine. The problem is "this is just math". x=x^2 is not that easy to solve. It is easy for you because you learned a specific method. The definition of Y does not include that method. Y will find some fixed points but not others because it lacks special methods.
12:55:48 <cheater3> Philippa: why?
12:56:24 <ksf> cheater3, write a symbolical program that solves it. then you see why it's hard.
12:56:26 <Philippa> cheater3: because sometimes the least fixpoint doesn't mean a lot
12:56:35 <Philippa> and what ksf said
12:56:45 <Philippa> sometimes the answer is "you spend forever trying to figure it out"
12:57:14 <monochrom> For one thing, Y = (\f -> (\x -> f (x x)) (\x -> f (x x))) clearly does not include an algorithm for factoring x-x^2 into (1-x)x.
12:57:17 <Philippa> to put it another way, sometimes the answer would be a paradox if you didn't have a way of encoding the "ohshit" moment
12:57:19 <cheater3> oh, no, i was asking why you said that Y is meaningful without the possibility of having the value _|_
12:57:26 <ksf> gosh formalism _really_ did spoil mathematicians.
12:57:41 <Philippa> meaningless, not meaningful
12:57:51 <cheater3> yes, meaningless =)
12:58:08 <ksf> if you disallow _|_, you have to prove totality
12:58:10 <cheater3> so... why?
12:58:16 <Philippa> because it would, for some inputs, have a 'meaningless' result. And suddenly that would make Y not a function
12:58:32 <Philippa> because there wouldn't /be/ a result, there'd just be a glaring paradox
12:58:40 <alise> ksf: total fp isn't so bad.
12:58:46 <Philippa> maybe there'd be two results, maybe there'd be none
12:58:49 <dmwit> cheater3: What is (fix (\x -> x - 1))? And no fair saying -infinity, you just said you were defining it for the reals.
12:58:58 <cheater3> Philippa: but for such inputs you can say that Y is undefined
12:59:03 <ksf> alise, surely not, but i don't want to prove everything all the time
12:59:09 <Philippa> cheater3: and what is undefined?
12:59:13 <dmwit> cheater3: If you allow yourself to add an infinity to your set, then you will understand why we allow ourselves to add an "undefined" to our set. =)
12:59:15 <Philippa> remember, we're being formal here
12:59:24 <cheater3> 'undefined' is not an object
12:59:27 <cheater3> it is a property
12:59:35 <ksf> I know 99% of my code is total and would just not work if it weren't, but proving it is another topic.
12:59:40 <cheater3> which means that the certain argument is not in the domain of the function
12:59:41 <dmwit> cheater3: We're making it an object.
12:59:54 <Philippa> cheater3: and it reduces the range of the function
13:00:03 <alise> ksf: well.
13:00:04 <cheater3> yes, very well so
13:00:12 <Philippa> division doesn't actually take a real for its second input
13:00:20 <Philippa> it takes a /non-zero real/
13:00:21 <alise> ksf: it is not so bad: http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
13:00:25 <cheater3> i don't see anything wrong with reducing the range or the domain
13:00:31 <alise> and the total languages, agda and the like, have more tricks and stuff to do it
13:00:37 <alise> if you're really lazy you could use a partiality monad
13:00:51 <Philippa> well, one of the things that's wrong with it is that the range is in fact undefined
13:00:59 <Philippa> 'scalled the halting problem
13:01:07 <Philippa> > fix fix
13:01:08 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
13:01:16 <cheater3> i am not interested in the range
13:01:19 <cheater3> so i'm fine with that
13:01:25 <Philippa> you are, you just don't know it
13:01:35 <Philippa> see, if the range is undefined, /the entire function/ is undefined
13:01:43 <Philippa> the object you're holding isn't actually a function
13:01:54 <ksf> alise, I've tried agda and coq and liked neither of them very much. I guess total languages just need more time to evolve
13:02:18 <ksf> (as does the haskell type system)
13:02:35 <cheater3> Philippa: a function does not need to have a range defined, a function is an assignment from one set to another set
13:02:43 <cheater3> it does not need to exhaust the other set
13:02:51 <Philippa> yes, it does
13:02:53 <cheater3> we do not need to point out a set and say 'this is the set of values'
13:03:02 <alise> ksf: yes, totality isn't ready yet
13:03:11 <alise> ksf: but I think it will be some day, and that will be a bloomin' glorious day
13:03:17 <Philippa> oh, unless I've got range and domain mixed up again. But if you don't know what your inputs are? You don't know the function
13:03:17 <cheater3> we can just say 'our function assumes values *in* a certain set' and that is good enough to define a function
13:03:24 <Philippa> no, it's not
13:03:25 <cheater3> yes, you definitely have
13:03:28 <Philippa> not if you're a formalist
13:03:52 <Philippa> okay, if I've done that, s/range/domain and re-read
13:03:57 <Philippa> but you ought to get the point
13:04:11 <cheater3> which axiom of what theory is unsatisfied if you are not defining an exhausted set of all values?
13:04:16 <Philippa> (btw: if you're not a formalist, you don't /really/ know what you're doing for sure)
13:04:22 <dmwit> I think the real problem here is that cheater3 is trying to talk about "oh, I only care about maths", but hasn't defined "maths".
13:04:31 <ksf> cheater3, haskell doesn't care for sets
13:04:36 <dmwit> Philippa is using a rigorous definition of maths: the domain theory of the lambda calculus.
13:04:43 <Philippa> ksf: that's okay, we're not talking about haskell right now
13:04:55 <dmwit> cheater3 is using some vague intuition that gets stuck at key points, but that it's hard to recognize without doing a lot of formal details.
13:05:03 <dmwit> ...which are impossible in an IRC channel.
13:05:09 <Philippa> dmwit: or to put it another way, I'm being rigorous about how I'm defining function
13:05:13 <cheater3> Philippa is unable to formulate without mixing up terms i have known as a fourth grader ;P
13:05:38 * dmwit sighs
13:05:51 <ksf> and I was able to contribute to a math discussion without making a complete fool of myself!
13:05:55 <Philippa> cheater3: this merely suggests that I have forgotten more relevant maths than you know :p
13:05:58 <midfield> does anyone here have experience using the Control.Arrow.Transformer package?
13:06:19 <cheater3> lol :P
13:06:19 <dmwit> Wow, there are arrow transformers now?
13:06:22 <dmwit> That is awesome!
13:06:27 <Philippa> midfield: I don't
13:06:31 <ksf> arrows are so yesterday. all the cool kids of today use categories.
13:06:43 <dmwit> arrows are categories
13:07:03 <midfield> class Category a => Arrow a .....
13:07:03 <Philippa> cheater3: you said earlier that you're okay making the range (and I assume the domain) precise. Why aren't you okay with that any more? Why do you insist on allowing an undefined function?
13:07:07 <byorgey> dmwit: there have been arrow transformers the whole time =)
13:07:07 <ddarius> dmwit: Arrow transformers were described in the original paper.
13:07:14 <Philippa> (for surely, if the function is defined, then so is its range and domain...)
13:07:22 <dmwit> pshaw, papers smapers
13:08:08 <Philippa> hell, to be really bitchy: what theory are you using that allows the notion of 'undefined' in the first place?
13:08:08 <cheater3> Philippa: you have a bad understanding of what a function is
13:08:14 <Philippa> cheater3: no, I really don't
13:08:59 <cheater3> Philippa: by what definition of 'function' are you saying that an assignment from a set to another set which exhausts all elements of the domain is not a function?
13:09:40 <ksf> it's certainly not a total function
13:09:55 <Philippa> cheater3: I'm saying that if it's undefined for one element of the domain, it doesn't exhaust all elements of the domain
13:09:57 <ksf> oh wait you didn't say doesn't.
13:10:03 <cheater3> i am talking about functions. i do not know what total functions are and do not make defining statements about them.
13:10:12 <Philippa> total functions are the functions you know
13:10:26 <Philippa> partial functions are allowed to be undefined on some inputs
13:10:41 <cheater3> Philippa: functions are not 'undefined' for elements of the domain. the domain is the set upon which the function is defined.
13:10:43 <ksf> ...that is, they are defined over their whole domain and are productive
13:10:53 <cheater3> Philippa: that is the definition of 'domain'.
13:10:56 <Philippa> cheater3: no shit, sherlock. This is what I have been telling you the whole time
13:10:56 <ksf> ...that is, they yield results without getting caught in a loop.
13:11:07 <cheater3> Philippa: and where does this bring us?
13:11:07 <pumpkin> it sort of depends
13:11:10 <midfield> Philippa: ok thanks
13:11:27 <Philippa> cheater3: where this brings us is that Y isn't actually a function unless you have the notion of _|_ involved
13:11:38 <ksf> cheater3, so 1/0 is defined, because 0 is an element of |R?
13:11:39 <cheater3> Philippa: i do not see the logical consequence
13:11:50 <Philippa> cheater3: what is Y Y?
13:11:55 <cheater3> ksf: 1/x does not have 0 in its domain.
13:12:20 <ksf> see, but it has type (/) :: Real -> Real -> Real
13:12:24 <cheater3> ksf: therefore the writing 1/0 is not a statement of mathematical value.
13:12:27 <Philippa> hint: the domain of Y is a solution of D = D -> D
13:12:30 <cheater3> ksf: i am talking about mathematics
13:12:32 <jmcarthur> i'm not sure who is trying to make what point in this argument
13:12:38 <cheater3> ksf: i am not talking about haskell
13:13:04 <ksf> cheater3, but, see, we're using the term "function", too, and we use that type for / and say "/ is not total"
13:13:11 <Philippa> ksf: leave the haskell behind, we're talking domain theory. _|_ is a fundamental requirement for Y to be meaningful, div 0 is just a common 'mistake'
13:13:13 <cheater3> ksf: the conversation with Philippa is about the feasability of defining the Y combinator for mathematical functions from the set of reals.
13:13:27 <Philippa> cheater3: no, not from the set of reals
13:13:41 <cheater3> Philippa: what then?
13:14:10 <Philippa> a solution of D = D -> D is the natural setting. Or lifted Nat -> Nat will do
13:14:13 <cheater3> Philippa: i am not saying the function is an element of the set of reals, i am saying that the function is defined from the set of reals to another set.
13:14:22 <Philippa> yeah. The reals are a red herring
13:14:25 <alise> Alternative's empty denotes failure e.g. in parsers, right?
13:14:28 <jmcarthur> cheater3: you can define the Y combinator for that as long as your range includes _|_
13:14:30 <Philippa> alise: yeah
13:14:32 <dmwit> Let's back way up.
13:14:54 <alise> Philippa: i'm trying to write an applicative+alternative parser combinator library that can deparse as well as parse; it's been amusingly horrific
13:14:57 <cheater3> jmcarthur: why?
13:15:00 <dmwit> The usual thing is to define "terms", which is your language for defining computations, and then interpret those terms as mathematical functions in some domain.
13:15:05 <Philippa> alise: heh, yes. It is :-) BTDT
13:15:09 <cheater3> jmcarthur: why is it impossible without a least element?
13:15:24 <Philippa> cheater3: computability, essentially
13:15:24 <jmcarthur> cheater3: consider this (in haskell notation): fix (+1)
13:15:26 <dmwit> For terms, pick your poison; my favorite is Haskell, but lambda-calculus would be fine, too.
13:15:28 <alise> Philippa: am i right in thinking it's impossible to implement parsec's (char 'x')?
13:15:39 <alise> given functor, applicative, alternative, anyChar :: PP Char
13:15:45 <jmcarthur> cheater3: infinity is not a real number
13:15:47 <alise> maybe i'm just dumb and can't figure out applicative parsers
13:15:51 <dmwit> Now, the question is: how do we interpret those terms as mathematical functions?
13:16:02 <Philippa> alise: applicative is easy enough, it's the bidi that hurts
13:16:04 <cheater3> jmcarthur: let's assume we are talking about fix2 which we are trying to come up with the definition for
13:16:05 <dmwit> This question is a little more subtle than you might think.
13:16:16 <alise> Philippa: this problem doesn't appear to be related to bidiness, though
13:16:20 <ksf> alise, empty is the identity of <|>
13:16:25 <cheater3> jmcarthur: i am saying that you can say "y = x+1 is not in the domain of fix2"
13:16:31 <alise> I think I've solved bidi with a type family, a GADT, a type synonym, and three functions
13:16:35 <alise> all automatically generated, hopefully
13:16:35 <Philippa> alise: oh, yeah, you can't do it that way
13:16:37 <jmcarthur> cheater3: so i'm supposed to reason about a function with an unstated definition?
13:16:52 <alise> Philippa: right, there isn't really any literature I've found that tells you how to do that sort of thing...
13:16:57 <Philippa> cheater3: the domain of fix is itself undefined without _|_
13:17:09 <cheater3> jmcarthur: no, just with an unconstructable domain
13:17:26 <cheater3> Philippa: it is well defined, but it is not constructable
13:17:27 <Philippa> cheater3: IOW, about an unconstructable functions
13:17:43 <cheater3> unconstructable does not mean undefined
13:17:47 <Philippa> cheater3: right. Depending on your level of formalism, this /isn't okay/
13:17:51 <alise> Philippa: can you do (char 'x') as a primitive, say?
13:17:55 <Philippa> alise: yep
13:18:14 <Philippa> alise: in general, you can't do 'context sensitive' in any way with an applicative
13:18:16 <alise> Philippa: ok. it stays as undefined for now, then :)
13:18:26 <alise> right, but they're just as powerful as monadic parsers right?
13:18:30 <Philippa> alise: wrong
13:18:35 <jmcarthur> cheater3: you said we are trying to come up with the definition for fix2. i can't really make an argument about a function you made up in your head with no definition
13:18:35 <alise> hmm
13:18:35 <ksf> alise, you might want to try to make your parser non-backtracking and not looking ahead, so you've got something linear to cling to.
13:18:37 <alise> thought they were
13:18:52 <alise> i guess i should go down the monadic route
13:19:00 <ksf> applicative parsers can't be context-dependant
13:19:02 <Philippa> alise: you don't /want/ it to be. A monad is too powerful to go bidi with
13:19:10 <alise> Philippa: >_<
13:19:20 <alise> So I can't have a powerful bidi parser, even if I require the user to provide annotations to help?
13:19:45 <cheater3> jmcarthur: fix2 is fix|{x \in D(fix) : fix x /= _|_}
13:20:01 <cheater3> where | is the restriction
13:20:05 <jmcarthur> okay
13:20:06 <Philippa> cheater3: basically, the foundations don't work adequately if you leave it at 'unconstructable'. Your "well-defined" function is... well, not defined by any set of axioms I can see handy
13:20:16 <alise> one function I'm not looking forward to implementing: give :: MetaFor a p v -> p -> PP a. MetaFor is a type family * -> (*->*); its RHS is a GADT with two type parameters.
13:20:36 <cheater3> Philippa: you are basically saying that things which cannot be constructed do not exist
13:20:40 <alise> (data Foo = ... | S Char Char would result in S_ :: Foo_ (PP Char,PP Char) (Char,Char) in the meta GADT)
13:20:50 <ksf> cheater3, and he's right saying so.
13:20:53 <Philippa> cheater3: I'm saying this one doesn't without some finesse
13:20:54 <Philippa> ksf: she
13:20:54 <cheater3> Philippa: this conversation has been held in the 19th century already, this argument is invalid
13:20:57 <alise> yes, I know, that could be f Char, f Char
13:21:08 <jmcarthur> cheater3: seeing that, i personally think fix2 might be fun to play some mental games with, but being a bit constructive minded, i have some trouble thinking about how it would work
13:21:10 <Philippa> cheater3: what you get is practically useless
13:21:14 <ksf> Philippa, there are no girls on the internet, you're lying.
13:21:22 <ksf> except lambdabot, of course.
13:21:22 <jmcarthur> cheater3: thanks for clearing that up though
13:21:42 <Philippa> ksf: That's not an acceptable response in here. I believe XKCD did a nice strip summing up why
13:21:42 <cheater3> Philippa: the argument is invalid because i am assuming one set of axioms and you are trying to disprove my statements using your own set of axioms
13:21:46 <cheater3> jmcarthur: :)
13:21:50 <jmcarthur> x /= _|_, in particular, confuses me ;)
13:21:59 <Philippa> cheater3: show me the function from axioms. Show me that it's well-defined
13:22:10 <Philippa> it's your assertion
13:22:14 <cheater3> jmcarthur: it's (fix x) /= _|_
13:22:22 <Philippa> note, however, that one thing I'm /not/ about to accept is naive set theory
13:22:23 <jmcarthur> err, right, that still confuses me
13:22:29 <jmcarthur> good luck proving that
13:22:40 <cheater3> proving what? it is just a formula.
13:22:43 <jmcarthur> although i guess if you approach it properly you needn't
13:22:52 <cheater3> fix applied to x does not evaluate to _|_
13:22:58 <cheater3> is what is being stated
13:23:23 <jmcarthur> i get that
13:23:28 <cheater3> and we find all such x and we restrict fix to that set of x and we call it fix2
13:23:31 <cheater3> what do i need to prove here?
13:23:40 <Philippa> cheater3: that you have a function that can do that
13:23:40 <ksf> hmmm xkcd girls and internet... I get this: http://xkcd.com/322/
13:24:03 <jmcarthur> meaning the domain of fix2 is all functions having a fixpoint that is not _|_
13:24:13 <cheater3> yes
13:24:23 <Philippa> ksf: pulling "there are no girls on the internet" is another variant thereof. Don't do it in here.
13:24:35 <cheater3> this set is not constructable but it is defined
13:24:47 <cheater3> being a subset of an existing set it is well defined
13:25:00 <cheater3> therefore our function's domain is well defined
13:25:22 <jmcarthur> "y = x+1 is not in the domain of fix2"  <--  i guess that sounds reasonable to me
13:25:24 <Philippa> that's only the case if "fixpoint != _|_" is well-defined
13:25:41 <jmcarthur> Philippa: i think cheater3 is just not thinking constructively
13:25:47 <Philippa> and the thing is: your well-definedness still relies on the lifted version
13:25:49 <jmcarthur> in the constructive logic sense, i mean
13:25:59 <Philippa> your fix2 doesn't exist without the lifted fix
13:26:13 <cheater3> no, but i am not saying fix does not exist
13:26:15 <Philippa> jmcarthur: that's okay, we don't need to require it
13:26:24 <Philippa> yeah. But you now see why it /must/ exist
13:26:25 <cheater3> i am saying that it is possible to have a fixed point operator that does not rely on _|_
13:26:34 <cheater3> to function
13:26:37 <Philippa> and I'm saying you just relied on it
13:26:43 <jmcarthur> cheater3: wait, you mean in a practical sense?
13:26:59 <cheater3> you are saying i relied to show you one definition, but you cannot say that i ultimately rely on it
13:27:11 <Philippa> I'm saying you won't find another definition
13:27:11 <cheater3> jmcarthur: i guess.
13:27:25 <jmcarthur> cheater3: if you mean that there is a *useful* fix2, then i will have to disagree. there will be a burden of proof on you every time you use it
13:27:38 <jmcarthur> you might as well just go with fix in that case
13:27:45 <Philippa> and that, incidentally, defining fix is the /only/ solution that was found after a very long foundational hunt
13:28:46 <jmcarthur> cheater3: i think you're on the right track realizing that there could be some total subset of general recursion, but you can't just define it in terms of general recursion as that is not a total definition
13:29:25 <alise> is there any way to map a tuple?
13:29:30 <alise> a typeclass presumably for the multiple tuple sizes
13:29:42 * ksf decides that the traps non-asexual pronouns set up are too complex to be discussed via irc
13:30:01 <Philippa> ksf: you could have just graciously accepted the correction. Deal with it.
13:30:22 <ksf> I could, and failed apologizing.
13:31:00 <ksf> but then, I could have used those fancy new <sarcasm> tags
13:31:27 <Philippa> It wouldn't have mattered, it's still inappropriate
13:32:31 <ksf> "inappropriate" is both subjective and heavily influenced by social norms that might just happen not to coincedence in our case.
13:32:45 <pumpkin> *coincide
13:32:49 <pumpkin> it's murdering coins
13:32:52 <Philippa> ksf: It's inappropriate for this channel. I'm saying that as an op.
13:33:13 <jmcarthur> i don't think making a joke *about* sexism is inappropriate
13:33:29 <jmcarthur> it didn't seem to be a sexist joke in and of itself
13:33:38 <cheater3> making a joke about anything is appriopriate.
13:33:45 <cheater3> if you can't joke about something, you're scared of it.
13:33:52 <Philippa> jmcarthur: You might like to take note of your perspective there
13:34:09 <pumpkin> saying anything that might realistically offend someone else is inappropriate
13:34:10 <ksf> It's a religious issue.
13:34:18 <mauke> pumpkin: hah
13:34:19 <pumpkin> it's not your place to argue that someone else should not be offended by something you say
13:34:22 <pumpkin> :)
13:34:23 <ksf> I'm honour-bound to take humor seriously.
13:34:32 <mauke> pumpkin: ANYTHING might realistically offend someone else
13:34:35 <pumpkin> I'm humor-bound to take honor seriously
13:34:43 <cheater3> i find it inappriopriate to be scared of things
13:34:46 <pumpkin> mauke: not really :)
13:34:50 <mauke> pumpkin: yes, really
13:34:56 <Berengal> cheater3: Thinking of types as propositions, fix has type (a -> a) -> a, which is basically "if "from 'a' you can prove 'a'" you can prove 'a'", including _|_
13:35:12 <cheater3> Berengal: hm?
13:35:16 <jmcarthur> i'm offended when somebody shows that i'm wrong about something. does that mean it's inappropriate for this channel?
13:35:42 <jmcarthur> accounting for somebody's personal insecurities is just too complex in realistic social scenarios
13:35:46 <pumpkin> mauke: people aren't really arbitrarily offended by things... there's usually a decent reason for it. The only people who are realistically offended by anything at all are those trying to make a point about how someone else is unreasonably offended
13:35:51 <cheater3> Berengal: i thought those arrows were assignment arrows, not implications.
13:35:57 <ksf> jmcarthur, no, being wrong to give people a chance to correct you is appropriate.
13:35:59 <ksf> you may continue.
13:36:11 <Philippa> cheater3: turns out those are isomorphic
13:36:15 <mauke> pumpkin: I disagree
13:36:15 <jmcarthur> ksf: *sigh* :P
13:36:15 <Berengal> cheater3: Curry howard says they are
13:36:23 <jmcarthur> maybe this should go to -blah?
13:36:31 <cheater3> pumpkin: you'd be suprised. people often make for being offended, while they're not, only because they think it's the social norm.
13:36:35 <cheater3> pumpkin: a thought-virus.
13:36:58 <monochrom> ? what is assignment arrow, and in what sense -> is assignment arrow?
13:37:02 * pumpkin gives up
13:37:05 <Philippa> okay, guys? You're not being productive, and I've just told you what is acceptable in this channel. I am, in fact, reasonably authoritative on this matter. Now drop it
13:37:06 <ksf> cheater3, the proper meme for though-virus is meme.
13:37:14 <jmcarthur> sending a topic to -blah is the best way to kill it
13:37:35 <pumpkin> topicide
13:37:47 <pumpkin> killing a topic or killing a mouse?
13:38:10 <cheater3> ksf: no, a meme can be positive.
13:38:17 <Philippa> cheater3: if you want to read the trail re _|_ etc more formally the term you want is "domain theory", btw
13:38:30 <pumpkin> or maybe killing a place... /me shrugs
13:38:30 <ksf> a meme is amoral.
13:39:09 <cheater3> i cannot take part in this conversation properly because satan is on tv
13:39:32 <jmcarthur> dangit satan
13:39:45 <pumpkin> dagit satan? poor lispy!
13:40:03 <cheater3> Philippa: thanks
13:43:46 <asdf_> is there a standard function in haskell to convert an integer to a string?
13:43:53 <mauke> show
13:43:55 <Zao> > show 42 :: String
13:43:55 <lambdabot>   "42"
13:44:00 <asdf_> ok thank you
13:44:01 <mauke> :t show
13:44:02 <lambdabot> forall a. (Show a) => a -> String
13:44:07 <asdf_> oh i see
13:44:11 <dmwit> ?hoogle Integer -> String
13:44:12 <lambdabot> Prelude show :: Show a => a -> String
13:44:12 <lambdabot> Text.Show show :: Show a => a -> String
13:44:12 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
13:44:46 <b0fh_ua> Hi again. How can I force Haskell to produce return code of a program after it completes? Just to use it in shell scripts.
13:44:49 <dmwit> I miss having a "hoogle"-alike for Coq,
13:44:51 <dmwit> .
13:45:00 <Berengal> b0fh_ua: exitWith
13:45:02 <mauke> @hoogle exitWith
13:45:02 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
13:45:02 <ksf> @hoogle exitWith
13:45:03 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
13:45:11 <b0fh_ua> excellent, thanks
13:45:12 <ksf> @quote stereo
13:45:13 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:45:39 <ksf> so now we've got an insider.
13:46:56 <ksf> It could be argued, though, that Haskell should use the value that's the result of running main as exit code if main happens to be :: IO Int
13:47:12 <ksf> ...or Integral, rather.
13:47:49 <alise> Philippa: wait, how can a bidi parser be a functor?
13:47:56 <dmwit> :t \m -> m >>= \c -> case c of 0 -> exitWith ExistSuccess; n -> exitWith (ExitFailure n)
13:47:57 <lambdabot> Not in scope: `exitWith'
13:47:57 <lambdabot> Not in scope: data constructor `ExistSuccess'
13:47:57 <lambdabot> Not in scope: `exitWith'
13:48:00 <alise> data PP a = PP { parse' :: String -> Maybe (a,String)
13:48:00 <alise>                , deparse' :: a -> Maybe String }
13:48:11 <alise> you'd need b -> a to be able to do (a -> b) -> PP a -> PP b
13:49:04 * ksf thinks that'd be a functor into the other direction.
13:49:10 <ksf> that is, mapping over Char
13:49:26 <McManiaC> huuuuu! something just broke my cabal
13:49:32 <ksf> if your parser type had the more sensible type PP t a, you could use bifunctor out of category-extras
13:49:51 <alise> admittedly, I did not consider the type for one second.
13:49:52 <alise> What would t be?
13:49:53 <Philippa> alise: I did get stuck :-)
13:49:57 <b0fh_ua> okay, may be somebody could suggest me how to split strings like Message-ID: <123@message.id.here> into name-value pair (Message-ID : 123@message.id.here) ?
13:50:00 <ksf> token
13:50:02 <alise> Philippa: you said been there, *done* that!
13:50:11 <Philippa> yeah, the getting stuck like you were :-)
13:50:24 <ksf> ...usually Char, but it's not unheard of to lex before you parse.
13:50:28 <alise> ksf: aight then
13:50:34 <alise> thou makest a good case
13:50:37 <Philippa> yeah, that's the way to go
13:51:03 <alise> give :: MetaFor a t p v -> p -> PP t a
13:51:13 <alise> Congratulations, you just made my uses-a-type-family-to-a-GADT type even more complicated.
13:51:53 <ksf> alise, you try to implement indexed monads for the awesome prelude and not be confused.
13:51:55 <McManiaC> cabal: Error: some packages failed to install:
13:51:55 <McManiaC> base64-string-0.1 failed during the building phase. The exception was:
13:52:04 <McManiaC> what happened here?! :O
13:52:44 <alise> ksf: so I'll have a Bifunctor instance instead of a Functor instance?
13:52:50 <McManiaC> <no location info>:
13:52:50 <McManiaC> Failing due to -Werror.
13:52:52 <alise> slight issue there in that I need Applicative and Alternative.
13:53:00 <ddarius> Bifunctor => Functor
13:53:07 <alise> oh, coo.
13:53:10 <alise> now to figure out that type :|
13:53:34 <alise> I started writing this to make my life *easier*
13:53:52 <ksf> (>>>=) :: (IxMonad j m) => j (m q r a) -> (j a -> j (m r s b)) -> j (m q s b)
13:53:53 <ddarius> (Or more precisely, if \AB.FAB is a bifunctor than it is a functor in A and B.
13:53:59 <McManiaC> the full error log: http://npaste.de/GH/
13:54:01 <ddarius> "functorial in A and B"
13:54:47 <ksf> ddarius, cabal unpack base64-string
13:55:04 <ksf> then get rid of that adomination called "Werror'
13:55:20 <ksf> ...and fix the package to use base 4, if you feel like it.
13:55:41 <benmachine> but what do you do once you've fixed it?
13:55:49 <ksf> cabal install
13:56:09 <ksf> oh, McManiaC , not ddarius
13:56:12 <McManiaC> okay
13:56:26 <alise> wow, Bifunctor hurts my brain
13:56:39 <ksf> should be in base64-string.cabal, field "ghc-options"
13:56:54 <alise> so I have to implement Category, PFunctor, QFunctor, Bifunctor right?
13:57:07 <alise> "great"
13:57:24 <ksf> not at all.
13:57:38 <ksf> just BiFunctor
13:58:11 <ksf> and then fmap = first, or, alternatively, fmap = bimap id
13:58:55 <QC_OK> !tutorial
13:59:02 <QC_OK> @tutorial
13:59:03 <lambdabot> Unknown command, try @list
13:59:09 <aavogt> @where rwh
13:59:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:59:14 <aavogt> @where lyah
13:59:14 <lambdabot> http://www.learnyouahaskell.com/
13:59:18 <aavogt> @where yaht
13:59:18 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:59:29 <aavogt> there are probably more, QC_OK
13:59:36 <QC_OK> hmm what to choose first
13:59:41 <ksf> You are in a maze of twisty little monad tutorials, all smelling of burritos.
13:59:49 <alise> ksf: but
13:59:54 <QC_OK> North.
13:59:55 <alise> (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t
14:00:02 <alise> so I do have to implement P/QFunctor
14:00:05 <alise> and they're Category=>
14:00:17 <pumpkin> mmm category-extras
14:00:18 <ksf> http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/Control-Bifunctor.html
14:00:26 <ksf> oh.
14:00:26 <QC_OK> What's a monad
14:00:27 <QC_OK> ?
14:00:29 <ksf> way out of date.
14:00:36 <alise> QC_OK: oh god.
14:00:44 <alise> RUN! RUN NOW!
14:00:47 <benmachine> hah
14:00:49 <alise> this is your *last* *chance*
14:00:51 <benmachine> QC_OK: don't worry about it
14:00:51 <QC_OK> ???
14:00:57 <medfly> QC_OK, it's an endofunctor together with two natural transformations that satisfies some laws.
14:00:57 <alise> Escape!
14:01:03 <Saizan> QC_OK: this is the autoritative source: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9516
14:01:03 <alise> too late
14:01:06 <alise> medfly did it.
14:01:09 <benmachine> QC_OK: learnyouahaskell is best
14:01:10 <QC_OK> sorry I'm a procedural/OO kinda person
14:01:11 <benmachine> imo
14:01:29 <QC_OK> i learned a little lisp the other day
14:01:32 <medfly> QC_OK, that's just mathematics. we Haskell people love to steal from category theory.
14:01:39 <alise> so now that haskell's popular we've stopped saying hey monads are really easy
14:01:43 <alise> and are actively trying to scare off newbies
14:01:47 <Saizan> QC_OK: you shouldn't worry about monads until you're familiar with higher order functions and the type system, anyhow
14:01:47 <medfly> QC_OK, I believe Haskell uses it to represent computations, or something.
14:01:49 <ksf> alise, I see, edwardk really managed to make that scary.
14:01:55 <alise> ksf: yeah.
14:01:57 <alise> PP t a -> PP s b -> PP s a
14:02:07 <alise> ^ I'm not sure that even makes sense
14:02:10 <alise> (if I have to implement (.))
14:02:10 <QC_OK> Sorry, complete haskell noob here
14:02:30 <QC_OK> I have a basic knowledge of most langs on here
14:02:31 <ksf> ...but you're going to stay in Hask, so the last two arguments of p and qfunctor are Hask
14:02:35 <QC_OK> aprt from haskell
14:02:35 <Saizan> ksf: make what scary?
14:02:36 <medfly> QC_OK, basically, don't worry about monads
14:02:43 <alise> ksf: so I don't need to implement Category?
14:02:43 <QC_OK> apart*
14:02:53 <medfly> QC_OK, what are those languages that are on here
14:02:58 <ksf> alise, nope
14:03:00 <medfly> you mean stuff we discuss?
14:03:04 <ksf> Saizan, http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor.html#t%3ABifunctor
14:03:14 <alise> ksf: ^_^
14:03:19 <QC_OK> ruby, python, java, C, C++, lisp, php, perl, etc
14:03:20 <alise> but I do need to implement p and qfunctor, right?
14:03:28 <ksf> yep
14:03:30 <Saizan> ah, heh
14:03:31 <QC_OK> I know java and python best
14:03:36 <QC_OK> also SQL
14:03:41 <alise> ksf: kill me now
14:03:42 <QC_OK> and C
14:03:44 <Saizan> QC_OK: haskell is nothing like those
14:03:49 <QC_OK> and C++
14:03:50 <ksf> but then you get bifunctor basically for free, as everything's been implemented
14:03:56 <medfly> Haskell is a bit like lisp, though
14:04:00 <QC_OK> yes
14:04:01 <medfly> no? :)
14:04:08 <Saizan> except for the whole type system
14:04:12 <mauke> Haskell is a bit like Perl
14:04:12 <ksf> in P t a, pfunctor does the t, qfunctor the a
14:04:18 <medfly> although, the only lisp (dialect? implementation?) I know is Scheme.
14:04:26 <ksf> haskell is a bit like clean
14:04:28 <QC_OK> Heh I learned common lisp
14:04:30 <ksf> just with monads
14:04:40 <QC_OK> well some basics
14:04:42 <QC_OK> at least
14:04:53 <medfly> I don't really know what monads are in Haskell, I just get the mathematical definition :)
14:05:06 <medfly> which is easy, because I always make sense of mathematics as "something that satisfies a bunch of rules"
14:05:08 <QC_OK> basically everything is a recursion in lisp nearly
14:05:10 <McManiaC> hmmm I'm having problems installing "hack-contrib" from the hackage… everything seems to install just fine, but after trying to load the modules in my project I get "Module Hack.Contrib not found" error
14:05:13 <QC_OK> from what I understand
14:05:21 <Saizan> QC_OK: most of the effort you'll need to learn haskell will be "forgetting" how you program in the languages above
14:05:24 <mauke> QC_OK: you understand wrong
14:05:26 <QC_OK> heh
14:05:32 <medfly> QC_OK, what do you mean? that you don't need special syntax for iteration?
14:05:39 <medfly> QC_OK, (like in C?)
14:05:41 <alise> <ksf> in P t a, pfunctor does the t, qfunctor the a
14:05:45 <QC_OK> loops are done with recursion
14:05:48 <alise> I should probably figure out what they actually DO
14:05:51 <QC_OK> or something
14:05:52 <mauke> QC_OK: no, they aren't
14:05:52 <medfly> right, that :)
14:06:03 <Saizan> McManiaC: are you using :load? you should use import or :m +
14:06:06 <QC_OK> ok, right then, I'm a functional programming noob
14:06:12 <McManiaC> Saizan: nope… import
14:06:16 <QC_OK> complete and utter noob
14:06:27 <medfly> QC_OK, you can see that as a good thing
14:06:30 <mauke> CL isn't all that functional anyway
14:06:39 <medfly> QC_OK, it means you just have a resource full of CS-related info just waiting for you to study it
14:06:50 <medfly> :-)
14:06:52 <QC_OK> yes that's why i want to learn haskell
14:06:57 <QC_OK> lisp is multiparadigm
14:07:06 <QC_OK> haskell, less so
14:07:07 <ksf> alise instantiated to Hask (which is just (->)), first is (a -> b) -> f a c -> f b c
14:07:14 <ksf> ...and second the same on the second type argument.
14:07:15 <Saizan> McManiaC: there's no Hack.Contrib module in hack-contrib, it seems http://hackage.haskell.org/package/hack-contrib
14:07:18 <QC_OK> according to wikipedia :)
14:07:29 <alise> instance PFunctor PP t a where
14:07:29 <alise>   first :: t b c -> a (PP b d) (PP c d)
14:07:30 <alise> I think
14:07:32 <medfly> I don't really get what paradigms mean, but it may be a side effect of not having enough OO.
14:07:36 <alise> but err
14:07:38 <QC_OK> hahaha
14:07:38 <alise> t :: *
14:07:47 <QC_OK> I started with OO
14:07:48 <QC_OK> ><
14:07:58 <ksf> alise, first :: r a b -> t (p a c) (p b c)
14:08:12 <ksf> ...instantiate both r and t to Hask
14:08:17 <medfly> the other language I'm somewhat competent at is PHP, and I don't write code that different in PHP.
14:08:19 <ksf> ...then lookup its definition (->0
14:08:21 <ksf> )
14:08:27 <ksf> ...and you get a decipherable type
14:08:31 <QC_OK> I know basic PHP
14:08:35 <McManiaC> Saizan: well, I cannot load anything else from that package either… and another "cabal install hack-contrib" will just run the installation again (it should say "already installed, maybe try --reinstall"?!)
14:08:36 <QC_OK> not the advanced stuff
14:08:39 <medfly> it's like a sin to admit I know both Haskell and PHP and use the latter
14:08:40 <QC_OK> I learned it today :D
14:08:45 <medfly> "why would anyone do that?"
14:08:48 <pumpkin> medfly: SINNAR!
14:09:07 <Saizan> McManiaC: did you restart ghci? does ghc-pkg list hack-contrib lists it?
14:09:21 <QC_OK> Alright so which tutorial do you recommend I start off with?
14:09:26 <medfly> @where lyah
14:09:26 <lambdabot> http://www.learnyouahaskell.com/
14:09:30 <medfly> here you go, come back with questions
14:09:31 <McManiaC> Saizan: yes to both: 78:    hack-contrib-2010.1.26
14:09:34 <QC_OK> ok
14:09:39 <QC_OK> arigato
14:09:49 <medfly> yes, you belong here.
14:10:07 <Saizan> McManiaC: and it's not red, right?
14:10:25 <McManiaC> Saizan: just white
14:10:54 <McManiaC> I have some blue modules tho (ghc-6.12 etc)
14:11:20 <Saizan> mh, i don't know then, unless your ghci doesn't correspond to that ghc-pkg, in case you've more than one ghc installation
14:11:40 <McManiaC> hm I dont have :S
14:12:01 <alise> ksf: can't implement   first :: (a -> b) -> PP a c -> PP b c
14:12:10 <alise> data PP t a = PP { parse' :: [t] -> Maybe (a,[t])
14:12:10 <alise>                  , deparse' :: a -> Maybe [t] }
14:12:13 <alise> note (a,[t])
14:12:17 <alise> I need b -> a, too
14:12:27 <alise> er, or do I
14:12:30 <alise> nope
14:12:38 <ksf> you don't even have "b'
14:12:57 <alise> yeah i'm pretty stupid :)
14:13:53 <domor> @src iterate
14:13:54 <lambdabot> iterate f x =  x : iterate f (f x)
14:15:01 <pikhq> > iterate (+1) 0
14:15:02 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:16:32 <alise>     Couldn't match expected type `a' against inferred type `b'
14:16:32 <alise>       `a' is a rigid type variable bound by
14:16:37 <alise> dammit, that's my least favourite type error
14:16:52 <alise> it *always* means "I'm too idiotic to do that, sorry"
14:17:43 <alise> as far as I can tell there is no Bifunctor => Functor
14:20:39 <alise> ksf: as far as I can tell, I can't implement it
14:22:15 <alise> ksf: we have (t->q). parse' for the new one is [q] -> Maybe (a,[q]); our old parser takes [t] ->.
14:22:20 <alise> therefore, we need q->t.
14:22:31 <alise> we don't have q->t, therefore, PFunctor PP Hask Hask cannot be implemented
14:23:54 <McManiaC> Saizan: hmmm same problem with hack-handler-epoll :O
14:24:02 <alise> ksf: I mean, correct me if I'm wrong...
14:24:22 <QC_OK> Should I use GHC or Hugs
14:24:23 <QC_OK> ?
14:24:25 <alise> GHC
14:24:29 <QC_OK> Why?
14:24:33 <alise> Hugs is unmaintained and outdated.
14:24:36 <nolrai_FG> Data.Map.delete is not working the way I would expect.
14:24:42 <alise> GHC is far, far faster, maintained, and new, and shiny.
14:24:47 <QC_OK> Ok.
14:24:52 <QC_OK> Thanks.
14:24:53 <alise> It's possibly the easiest Haskell-related decision to make. :)
14:24:55 <McManiaC> ❤ ghc
14:25:03 <QC_OK> heh
14:25:25 <McManiaC> Saizan: and same problem with http, which both packages rely on :O
14:25:27 <QC_OK> I need to install GHC on Windows 7 64 bit...
14:25:46 <alise> Oh dear, Windows.
14:25:56 <QC_OK> Yes.
14:26:00 <alise> If 32-bit is okay, http://www.haskell.org/ghc/download_ghc_6_10_4.html#windows
14:26:05 <alise> Wait wait
14:26:09 <alise> http://hackage.haskell.org/platform/2009.2.0.2/HaskellPlatform-2009.2.0.2-setup.exe
14:26:11 <Cale> GHC ought to run on Windows, it's developed primarily by guys at MS Research ;)
14:26:13 <alise> I forgot the Haskell Platform.
14:26:18 <alise> This, run this: http://hackage.haskell.org/platform/2009.2.0.2/HaskellPlatform-2009.2.0.2-setup.exe
14:26:31 <alise> All your Haskell-related dreams and possibly some of your non-Haskell-related dreams may come true.
14:26:32 <dmwit> Don't do it, it's a virus!
14:26:37 <alise> dmwit: It totally is
14:26:42 <alise> It infects, not your computer, but your MIND.
14:26:45 <dmwit> It will steal joy from your code-monkey job...
14:26:48 <McManiaC> oh, and what a virus :>
14:26:54 <alise> Wait, what joy?
14:27:02 <McManiaC> what code-monkey job? :D
14:27:03 <alise> "I stole your NON-EXISTENT pants."
14:27:15 <Lemmih> nolrai_FG: How's that?
14:27:18 <dmwit> I stole what was left of your pants!
14:27:29 <QC_OK> http://hackage.haskell.org/platform/ is good?
14:27:34 <alise> Yes.
14:27:43 <alise> The Haskell Platform is the shiniest, newest pony we have to offer.
14:27:48 <pumpkin> haskell.org/platform is a prettier url :)
14:27:51 <McManiaC> no ghc 6.12 for windows? :>
14:27:52 <QC_OK> http://hackage.haskell.org/platform/2009.2.0.2/HaskellPlatform-2009.2.0.2-setup.exe
14:28:11 <alise> 6.12 isn't really... compatible.
14:28:13 <alise> @faq Given the Platform, can Haskell, in fact, now make you coffee, given a coffee pot with RFC2324 support?
14:28:13 <lambdabot> The answer is: Yes! Haskell can do that.
14:28:15 <QC_OK> Argh 54 megabytes....
14:28:19 <QC_OK> geez
14:28:34 * hackagebot upload: randsolid 0.2 - Set the background of your root window to a random colour. (JohannesMartinsson)
14:28:34 <alise> If 54 megabytes puts you off a compiler, it's probably best you don't try GHC.
14:28:40 <alise> It's got far more "heresy" in it than that...
14:28:52 <QC_OK> heh
14:28:55 <McManiaC> actually, on linux the packet for 64 bit is more like 600-700 mb
14:28:56 <McManiaC> :>
14:29:11 <pikhq> 54 megs? That's a pretty small compiler, all things told.
14:29:15 <alise> On the DeathStation 9000, it takes up 794 yottabytes.
14:29:21 <McManiaC> :P
14:29:37 <alise> sigh: *sigh*
14:29:44 <McManiaC> blah I hate cabal
14:29:51 <pumpkin> cabal is quite nice
14:29:53 <QC_OK> What's cabal?
14:29:55 <nolrai_FG> Lemmih: Its leaveing what I'm telling it to delete around. I am doing "delete ConstructorThatTakesNoArguments myMap" and the result still has an ConstructorThatTakesNoArguments key in it.
14:30:07 <alise> QC_OK: Haskell's favourite package manager, esquire.
14:30:24 <Becquerel> s/favourite/only/?
14:30:25 <McManiaC> it keeps forgetting my packages =(
14:30:29 <alise> Aye, we know it; it does organise our builds and collate our software, install it for us with certain flags, certain versions; and even puts us to bed, aye with a cup of cocoa it does.
14:30:33 <QC_OK> Oh dear Haskell needs half a gig of hard drive space
14:30:33 <alise> Good ol' cabal.
14:30:38 <QC_OK> that's ridiculous.
14:30:47 <McManiaC> haha
14:30:49 <McManiaC> told you
14:30:50 <Becquerel> ghc is big
14:30:53 <alise> "WHAT? The neural implant that raises my IQ by 100 points involves operating on my BRAIN?"
14:30:55 <alise> "I'm out."
14:31:09 <QC_OK> Why is it so big
14:31:10 <pumpkin> space is ridiculously cheap these days
14:31:12 <QC_OK> ?
14:31:20 <pumpkin> QC_OK: mostly because of static linkage
14:31:20 <benmachine> QC_OK: to fit all the stuff in
14:31:22 <alise> QC_OK: Because one, it does very intense optimisation.
14:31:30 <alise> Because two, Haskell is hard to compile well.
14:31:36 <alise> Because three, it comes with a gigantic standard library.
14:31:36 <QC_OK> ok
14:31:40 <QC_OK> is haskell buggy?
14:31:44 <McManiaC> no
14:31:45 <dmwit> ?
14:31:46 <QC_OK> k
14:31:47 <alise> Because four, it comes with additional packages; the Platform = GHC + third-party libraries.
14:31:47 <benmachine> haskell compilers are typically very clever
14:31:49 <dmwit> Haskell is a language.
14:31:52 <pumpkin> dmwit: !
14:31:53 <Lemmih> > M.delete Nothing (M.fromList [(Nothing,False)]) -- Works on for me, nolrai_FG
14:31:54 <lambdabot>   fromList []
14:31:57 <alise> QC_OK: GHC isn't very buggy.
14:31:59 <McManiaC> its as bugy as you make it to be :>
14:32:00 <QC_OK> ok
14:32:01 <alise> Nor are the libraries in the platform.
14:32:11 <alise> QC_OK: Haskell code tends to be less buggy than in other languages, due to its advanced type system.
14:32:18 <QC_OK> ok
14:32:21 <pumpkin> industrial-strength!
14:32:26 <pumpkin> enterprise-ready!
14:32:40 <dmwit> QC_OK: Don't listen to them, it's all hype.
14:32:43 <alise> pumpkin: superlative-noun!
14:32:48 <alise> dmwit: Says dmwit :D
14:32:49 <QC_OK> installing....
14:32:50 <Lemmih> nolrai_FG: Are you using non-standard Eq or Ord instances?
14:32:51 <pumpkin> nuh uh, no hyphen there!
14:32:54 <pikhq> Haskell bugs tend to be of the "Wrote the program to do something differently than we said" sort of thing, rather than "Oh, woops, there went a null pointer dereference".
14:32:56 <QC_OK> nullsoft installer
14:32:57 <QC_OK> yay
14:33:01 <dmwit> QC_OK: Haskell is nice and all, but they're promising unicorns that don't exist.
14:33:06 <Saizan> McManiaC: ghc-pkg check ?
14:33:07 <QC_OK> hehe
14:33:08 <alise> Hey, I'm not.
14:33:10 <alise> --Apart from the toast.
14:33:15 <alise> Haskell doesn't really make you toast.
14:33:19 <pumpkin> my unicorns are super real
14:33:20 <Zao> Yet.
14:33:20 <pikhq> Or even "Oh, woops, typecast went bizarrely."
14:33:20 <QC_OK> I'll see once I learn it - if i can learn it
14:33:27 <Saizan> McManiaC: oh, are you running ghc-pkg and ghci from the same user?
14:33:28 <pumpkin> instance Monad Unicorn where
14:33:32 <QC_OK> imperative programming has tainted my mind
14:33:34 <alise> QC_OK: ENDOFUNCTORS!!!!!
14:33:48 <McManiaC> Saizan: yes
14:33:52 <pumpkin> @quote fuck
14:33:52 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
14:33:52 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
14:33:54 <QC_OK> Yay Haskell is now installed
14:33:58 <alise> Endofucktors?
14:34:04 <pikhq> pumpkin: Where >>= = prance, return = getMeAPony
14:34:12 <pumpkin> pikhq: not what I had in mind, but sure
14:34:39 <gwern> quickcheck 1 and 2 are really starting to cause me problems
14:34:45 <gwern> what's good for what ails me?
14:35:03 <pumpkin> gwern: tiger balm
14:35:19 <gwern> pumpkin: isn't there something less evil than that?
14:35:21 <nvoorhies> Is there much real data behind the assertions that haskell programs have less bugs nowadays?  I remember seeing some semi-contrived govt. study years ago, but not much else
14:35:27 <dmwit> nuclear balm
14:35:33 <pumpkin> nukular, even
14:35:35 <gwern> nvoorhies: nowadays? as compared with what?
14:35:44 <gwern> back in the days of haskell 3?
14:35:50 <nvoorhies> gwern: as compared to 3 years ago when I last looked around
14:35:52 <dmwit> nvoorhies: As a rule, assertions about productivity and bugginess are data-less.
14:36:08 <pumpkin> I am 81% more productive since I started haskell
14:36:11 <jmcarthur> nvoorhies: honestly i doubt there's really much emperical evidence one could gather. i approach such reports skeptically anyway
14:36:31 <nvoorhies> dmwit: Yeah...  I saw some decently done study at one point and secretly hoped it was indicative of a trend
14:36:34 <jmcarthur> nvoorhies: i can give anecdotal evidence from personal experience, if that helps any ;)
14:36:36 <dmwit> I tend to agree with jmcarthur here. It's a damned-if-you-do, damned-if-you-don't sort of thing.
14:36:39 <pumpkin> and I write 63% of the bugs I used to write... the type system caught the other 37%
14:36:53 <gwern> nvoorhies: I'd guess haskell programs are about as buggy as they used to be, exept obviously haskell libraries etc actively developed since 3 years ago will be less buggy by virtue of said development
14:37:01 <McManiaC> Saizan: seems to build on my other machine… weird
14:37:04 <pumpkin> my code is also 159% more legible
14:37:27 <RayNbow> @hoogle RCategory
14:37:27 <lambdabot> No results found
14:37:31 <nvoorhies> jmcarthur: Yeah, there's no need to sell me on it.  I love the language, just wondering if there's some quantitative basis you can use to argue for its use out in the wild
14:37:41 <pumpkin> RayNbow: like RMonad?
14:37:54 <alise> So what's the Bifunctor => Functor instance?
14:37:58 <jmcarthur> nvoorhies: i think this is a common desire among many language communities
14:37:59 <alise> I could just write the Functor instance manually.
14:38:06 <pumpkin> alise: make it into a functor from its second argument
14:38:11 <pumpkin> oh
14:38:15 <pumpkin> you mean where to find it?
14:38:18 <alise> yeah
14:38:21 <gwern> language comparisons don't earn anyone tenure
14:38:35 <gwern> and companies have little interest in solid public comparisons
14:38:44 <pumpkin> alise: it'd be undecidable
14:38:45 <jmcarthur> and when you don't get tenure you go on a shooting spree
14:38:50 <pumpkin> alise: if someone actually wrote it
14:38:56 <nvoorhies> Because I mean to a lot of people any functional programming advocacy or promotion is going to sound like more hand-wavey lisper nonsense about it making all programming easy, and the history of lisp kinda put the lie to all that
14:38:56 <alise> pumpkin: I thought it existed. Someone told me that, anyway.
14:39:00 <RayNbow> pumpkin: no idea, it's in some code sjoerd_visscher wrote
14:39:01 <alise> Problem is -- data PP t a = PP { parse' :: [t] -> Maybe (a,[t])
14:39:02 <alise>                  , deparse' :: a -> Maybe [t] }
14:39:14 <alise> -- you need (b -> a) as well as (a -> b).
14:39:23 <RayNbow> pumpkin, http://twitter.com/sjoerd_visscher/status/9071863689
14:39:32 <pumpkin> RayNbow: oh, saw that
14:39:35 <gwern> nvoorhies: hm? I'd say the general success of AI programs - some of the most difficult stuff around - shows lisp did deliver
14:39:46 <gwern> especially compared to its contemporaries
14:39:48 <jmcarthur> really the important thing for language evangelism from a business standpoint is really the availability of libraries and the availability of programmers
14:40:03 <gwern> that well-regarded modern languages like Ruby are so lisp-life is further evidence
14:40:04 <nvoorhies> gwern: but a huge proportion of AI stuff in the wild today is most definitely not in lisp
14:40:06 <gwern> *like
14:40:32 <alise> pumpkin: Perhaps I should abandon Functor, Applicative and Alternative and write my own, similar typeclasses, but accounting for the bidirectionality.
14:40:44 <nvoorhies> it's not that lisp is useless or anything and it's got neat stuff in there, but people sold it like it was magic and lots of people came away with a bad feeling after they discovered it sint
14:40:45 <pumpkin> alise: how would you do that?
14:40:52 <gwern> nvoorhies: sel4 is written in C based on translating a haskell prototype; does that show that haskell cannot be high-assurance?
14:41:17 <RayNbow> say pumpkin, do you have like 5k followers on Twitter?
14:41:23 <pumpkin> RayNbow: yep
14:41:30 <alise> pumpkin: Well, gmap :: (a -> b) -> (b -> a) -> PP c a -> PP c b
14:41:34 <McManiaC> Saizan: there it is… after a fresh installation of cabal+ghc :>
14:42:15 <pumpkin> alise: hmm
14:42:24 <nvoorhies> gwern: I'm not doubting that it has benefits, I'm just wondering if anyone's quantified the benefits, because it'd be cool to have confirmation of my biases toward haskell
14:43:15 <nvoorhies> anyways, time to eat
14:43:16 <gwern> nvoorhies: and I've told you 2 reasons why there are no quantifications, and pumpkin tossed in a third
14:43:34 <pumpkin> you mean the bullshit statistics I was making up?
14:43:35 <nvoorhies> yeah, it's a bummer
14:43:40 <gwern> pumpkin: undecidability
14:43:44 <pumpkin> oh :)
14:43:53 * pumpkin doesn't recall
14:45:08 <lazyshrk> I'm having some problems with a closed file handle, giving me and illegal hSeek operation. Anyone want to take a look? hpaste -> http://bit.ly/c8hx9B
14:45:19 <lazyshrk> an*
14:45:43 <josephholsten> nvoorhies: quantifying the benefits vs disads to a language is lingustics. google sapir-whorf hypothesis. eskimos may not have 200 words for snow. their language may or may not be better than english. same goes for every language currently used.
14:46:05 <dmwit> lazyshrk: You can't close something for which you've hGetContents'd.
14:46:15 <dmwit> lazyshrk: hGetContents places its handle in a half-closed state.
14:46:19 <alise> sapir-whorf hypothesis is debunked
14:46:24 <josephholsten> alise: yep
14:46:28 <alise> ah, ok
14:46:31 <nvoorhies> alise: strong forms of it, yeah
14:46:37 <nolrai_FG> I am some how constucting a Data.Map.Map that delete does not work on. If I save the show result to a file then that works. What should my next step be?
14:46:40 <alise> nvoorhies: the really weak form of it is obvious though :)
14:46:51 <alise> "it's harder to express concepts in a language that doesn't have words for it", yeah, no shit
14:47:01 <lazyshrk> dmwit: it worked fine before I added the delete function though? it also uses hGetContents
14:47:18 <nvoorhies> Yeah, but every time you mention it being crap someone counters with a weakened version
14:47:26 <MissPiggy> .win 10
14:47:26 <gwern> alise: it's no more debunked by the colors research than it is proved by the aborigines with mad directional skills
14:47:28 <josephholsten> nvoorhies: anything strong enough allow you to "quantify the benefits of a language"
14:47:36 <dmwit> lazyshrk: You can't seek in semi-closed handles, either.
14:47:45 <cheater3> sapir-whorf? why are we talking about tng?
14:47:53 <McManiaC> is there a way to multiple line strings in haskell? other than with (++)
14:47:57 <dmwit> lazyshrk: Probably "close" is okay, despite what I said earlier: closing file handles twice is maybe not so bad as seeking in a closed handle.
14:48:07 <nolrai_FG> Acualy some medium-weak results of saphir-wolf seem supported. Bridges are beutifule when female, strong when masculine.
14:48:22 <gwern> McManiaC: we have continued lines with the \ convention; and you can do 'unwords [foo, bar, baz]'
14:48:45 <flux> dmwit, if you close a unix file descriptor twice, you might end up closing an unrelated fd.. but perhaps haskell handles have internal closed-state instead of wrapping just the fd?
14:49:08 <lazyshrk> dmwit: but how is the add and list function different (wrt hSeek/hGetContents) from the delete function? the add and list functions work
14:49:23 <dmwit> lazyshrk: add doesn't hGetContents
14:49:24 <RayNbow> McManiaC, http://www.haskell.org/pipermail/haskell-cafe/2006-January/013911.html <-- example of how to use \
14:49:31 <dmwit> lazyshrk: and listTodo doesn't seek
14:49:34 <nvoorhies> josephholsten: I don't follow.  I was thnking of a study I saw that asked some goupd of people to code up something to some spec in languages they were familiar with, and then tested for defects extensively.  It seemed like a noble effort and I was wondering if more things like that had turned up.
14:49:57 <McManiaC> RayNbow, gwern: thx
14:50:04 <dmwit> lazyshrk: The basic rule of thumb is: don't do anything to a handle after you've used hGetContents on it. Even if what you do happens to work, it's wrong.
14:50:26 <alise> dmwit: that gives me an idea!
14:50:35 <alise> destruction types
14:50:50 <pumpkin> linear types!
14:50:53 <pumpkin> uniqueness types!
14:50:55 <josephholsten> nvoorhies: apologies then.
14:50:56 <alise> yes yes
14:51:00 <Cale> McManiaC: I like using unlines together with a list of strings.
14:51:16 <josephholsten> nvoorhies: got a link? sounds like a good read
14:51:18 <alise> hGetContents :: a::Handle -> IO (String, Destruct a)
14:51:26 <alise> not dependent types, just looks like it :P
14:51:39 <alise> you could call it ~a or something to be clear it's not a "real" type
14:51:48 <gwern> McManiaC: I prefer to use \ns and what not, and just tab indent it over multiple lines
14:51:59 <nvoorhies> josephholsten: sadly no, it was 3+ years ago I think...  maybe something about air traffic controller systems or radar or something?  I think it was govt. funded
14:51:59 <alise> but if you have a value of Destruct a, you can't use the value a any more; it is a type error to
14:52:38 <byorgey> alise: but it's impossible to know if a value of type a that you have got used in some expression somewhere else that gave a Destruct a
14:52:53 <pumpkin> you'd need a different type system from what we have
14:52:55 <nvoorhies> It seemed to do a pretty good job, given so many variables and the difficulty of finding people with comparable experience in various languages and trying to make it about the languages instead of the programmers
14:53:00 <lazyshrk> dmwit: I don't follow. How can addTodo use seek, and listTodo use getcontents, but delete can't use either? what am I doing to the handle? i'm just passing it along?
14:53:19 <byorgey> well, I mean you'd need the original value to already have a different type (like a linear type)
14:53:31 <alise> byorgey: a isn't a type
14:53:36 <alise> a is a parameter
14:53:44 <alise> hGetContents :: a::Handle -> IO (String, Destruct a)
14:53:45 <dmwit> lazyshrk: You can use either, you just can't use both.
14:53:45 <alise> so we do
14:53:51 <alise> (foo,_) <- hGetContents bar
14:53:52 <dmwit> lazyshrk: (Which delete is trying to do.)
14:53:59 <alise> and now we know that we cannot use bar any more
14:54:06 <pumpkin> alise: we do, but how does the type system? :)
14:54:09 <lazyshrk> dmwit: removing the seek from delete gives the same error (handle is closed)
14:54:16 <alise> well, okay, so you'd have to disallow a value being in more than one place
14:54:18 <alise> but who cares!
14:54:18 <MissPiggy> linear types can CHANGE the world lol
14:54:22 <byorgey> alise: yes, but what if I have a Handle, and I pass it to your function that uses hGetContents?  How do I know that *I'm* not allowed to use it anymore?
14:54:33 <pumpkin> yeah, linear types are cool :P
14:54:36 <pumpkin> but we don't got 'em
14:54:38 <byorgey> alise: hehe, ok, well then you've just reinvented linear types =)
14:54:40 <MissPiggy> @google linear types can change the world
14:54:42 <lambdabot> http://citeseer.ist.psu.edu/wadler90linear.html
14:54:47 <alise> :D
14:54:48 <alise> byorgey: fine then, you have to pass a Alive a :P
14:54:50 <alise> *an
14:54:52 <dmwit> lazyshrk: Don't do anything to a getContents'd handle!
14:54:53 <byorgey> hehe
14:55:00 <dmwit> lazyshrk: Including hPutStr/hPutStrLn!
14:55:15 <dmwit> lazyshrk: After you've hGetContents'd, you have to treat that handle as closed.
14:55:25 <lazyshrk> dmwit: Aha.
14:55:26 <alise> data Handle t = (a::Handle', Status t a)
14:55:28 <nolrai_FG> Okay some how I am ending up with invalid Maps, i.e. ones on which delete doesnt work. Any ideas how I am doing this?
14:56:03 <nolrai_FG> I mean I could just put in a read (show m) but thats rather hackish.
14:56:04 <alise> hGetContents :: Handle (Alive => Dead) -> IO String
14:56:11 <pumpkin> lol
14:56:19 <lazyshrk> dmwit: Thanks.
14:56:19 <alise> you pass in a Handle Alive, and then its type transmogrifies into a Handle Dead.
14:56:20 <alise> tada!
14:56:32 <pumpkin> yeah, but we don't have type transmogrifiers! :(
14:56:49 <alise> well, now we do
14:56:56 <pumpkin> oh, okay
14:56:59 <alise> I guess what we need is for the type to contain a unique identifier of that value
14:57:09 <pumpkin> {-# LANGUAGE AliseHaskell #-}
14:57:19 <alise> data Handle id = (Handle', id)
14:57:36 <alise> newHandle :: IO (Handle @alive)
14:57:47 <alise> @alive meaning "a new identifier for this object, associated with the information 'alive'"
14:57:48 <lambdabot> /\/\EaniN9 "4 n3w iDentiphIer phOR +hi5 o8J3(T, 45soCiatEd Wi+|-| 7hE InFOR/\/\4tiON 'A1ive'"
14:57:53 <alise> XD
14:58:01 <BMeph> I fear functions that modify values...and don't tell me if or when they do so. :(
14:58:16 <alise> hGetContents :: Handle id -> IO (String, Destruct id)
14:58:17 <alise> where
14:58:22 <alise> type Destruct id
14:58:38 <alise> an opaque type representing that the id is now associated with deadness, not aliveness
14:58:39 <alise> erm wait
14:58:47 <alise> hGetContents :: Handle id[alive] -> IO (String, Destruct id)
14:58:47 <alise> there
14:59:05 <alise> so now that it's dead, and since id is unique to every handle value and unchangeable, that handle is now dead everywhere, and we cannot use it any more
14:59:09 <alise> Now quick; implement it.
14:59:17 <MissPiggy> in haskal?
14:59:23 <BMeph> alsie: Question: "When" does it become dead? ;)
14:59:48 <alise> well, it's a compile-time thingy, not a run-time distinction
15:00:08 <alise> what's that thingy, asTypeOf
15:00:10 <alise> a -> a -> a
15:00:14 <alise> you can think of it like that
15:00:18 <alise> it's "clarifying" the type
15:00:23 <alise> except the type doesn't even handle, it's still Handle id
15:00:33 <alise> I know this makes no sense, I'm just being silly.
15:00:34 <MissPiggy> I dono't get it
15:00:39 <alise> Nor do I.
15:00:39 <MissPiggy> what is this
15:00:40 <winxordie> I have a cabal-install question, would this be the place to ask?
15:00:40 <MissPiggy> what is this
15:00:45 <MissPiggy> yes
15:00:57 <MissPiggy> alise you don't NEED dependent types to do this
15:01:02 <ickane> anyone know the default directory gch loads its modules from?
15:01:07 <alise> MissPiggy: I didn't say dependent types
15:01:14 <alise> fmap should be paramaterisable
15:01:15 <MissPiggy> but typeclasses aren't strong enough (or at least they don't let you do this in a simple way)
15:01:19 <MissPiggy> but with CHR you can
15:01:27 <alise> fmap :: compute a b -> f a -> f b
15:01:31 <alise> so i can make it (a->b,b->a) :(
15:01:37 <MissPiggy> there's examples on the ??? site which is the predecessor of Chameleom
15:02:04 <dobblego> alise, that's an exponential functor
15:03:09 <nolrai_FG> So just to make sure that yes I am in a bad space, (Map.fromList . Map.toList) shouldn't do anything right?
15:03:23 <winxordie> I've got the haskell platform running. I have cabal-install-0.6.4 and every time I try to update it asks me to update cabal install to cabal-install-0.8.0. Every time I run 'cabal install cabal-install' I get a copy of cabal-install-0.6.4. I'm stuck in a loop. How do I get a copy of cabal-install-0.8.0 recognized by cabal?
15:03:45 <alise> dobblego: I only care that it be named Functor so that I can revel in Applicative and Alternative. :)
15:04:15 <BMeph> winxordie: Short answer: Wait until 6.12.2 comes out. :)
15:04:15 <alise> higher operator precedence = gulps up more stuff, right?
15:04:23 <alise> what's the highest?
15:04:45 <BMeph> alise: Parentheses. ;)
15:04:46 <winxordie> BMeph: lol, really? alright.
15:04:53 <alise> BMeph: I mean the highest number
15:06:51 <BMeph> winxordie: Longer answer is: 6.12.1 came out to "nudge" developers to get packages up to speed. When "enough" of them have done so, the Haskell Platform using GHC 6.12/Cabal 1.8 will come.
15:07:04 <nolrai_FG> Shouldn't higher precedence mean gulps up less?
15:07:13 <BMeph> alise: Haskell is like Spinal Tap; precedence goes up to 11. ;)
15:07:31 <alise> whatever <|>'s precedence is i want that :)
15:07:40 <nolrai_FG> 1 * 2 + 3 -- * has higher right?
15:07:40 <alise> sidenote: we really need declarative precedence
15:07:53 <BMeph> nolrai_FG: Right. :)
15:08:04 <BMeph> alise: Which is? :)
15:08:17 <winxordie> BMeph: I was wondering about that. I tried installing cabal-install-0.8.0 manually and it kept asking for cabal 1.9.  Now that I think about it, I probably should've guessed from that... still, thank you!
15:08:19 <alise> infixr $ < ($$) < *
15:08:23 <alise> i.e. ($$) is between $ and *
15:08:35 <alise> if it can't be determined from the orderings of those, it is ambiguous like we get when using two of the same precedence now
15:08:40 <alise> as opposed to arbitrary, limited integers
15:09:04 <BMeph> winxordie: Sure. :)
15:09:50 <BMeph> alise: What if it's only partially determinable, should the compiler "guess" using Psychic Powers? (Or Austin Powers?) :D
15:09:58 <alise> no
15:10:08 <alise> but it should be okay most of the time
15:10:20 <alise> you should only have to list a few operators and it'll reduce to the Prelude operators in a few steps
15:12:09 <MissPiggy> lol3
15:13:00 <Berengal> Wasn't there talk of extending the precedence to arbitrary numbers?
15:13:05 <Berengal> Did anything come of that?
15:13:55 <jmcarthur> i'm certainly not a fan of having to memorize numerical precedence
15:13:56 * BMeph imagines totally ordering operator precedence by Austin Powers...YEAH, Baby! ;)
15:14:13 <Berengal> Yeah, I'm a fan of parenthesis
15:14:22 <MissPiggy> ()
15:14:34 <MissPiggy> what about ocaml
15:14:38 <MissPiggy> they just hardcode precidence in
15:14:39 <jmcarthur> no, i mean i kind of wish we had partial ordering for precedence, i guess similar to alise's proposal
15:15:47 <Berengal> I wonder how to write a parser for that...
15:16:05 <sshc> um?
15:16:12 <sshc> ghc: panic! (the 'impossible' happened)
15:16:12 <sshc>   (GHC version 6.12.1 for i386-unknown-linux):
15:16:12 <sshc> 	mkUsage
15:16:18 <alise> haha man
15:16:27 <alise> I have a bit of an issue with my bidirectional parser
15:16:28 <alise> specifically
15:16:32 <alise> deparse' :: a -> Maybe [t]
15:16:33 <alise> what I really need is
15:16:36 <alise> deparse' :: a -> Maybe ([t],a)
15:16:48 <alise> i.e. deconstruct a bit of the value, pass the rest on
15:16:52 <sshc> why does GHC cause the impossible to happen?
15:16:55 <alise> which is, of course, patent nonsense.
15:17:27 <BMeph> alise: Why not "deparse'' :: a -> (Maybe [t],a)"? ;)
15:17:49 <alise> BMeph: because you can't take the tail of a value
15:17:56 <alise> (.>) :: PP t a -> PP t b -> PP t b
15:18:03 <alise> I'm at a loss how to implement deparse
15:18:10 <alise> (It's basically *> but I can't have Appliclative)
15:18:17 <alise> for .>
15:18:17 <BMeph> Hmm, well, as long as you're using [t], using Maybe on that is somewhat superfluous. :)
15:18:19 <alise> parse' is easy it's just >>
15:18:39 <alise> but uhh, we need to like... tell the first parser to totally deparse and shizz, and th--
15:18:41 <alise> oh, of course
15:18:47 <alise> --no, never mind
15:18:53 <alise> this is *really* hard!
15:19:07 <MissPiggy> deparse alise?
15:19:14 <alise> as in a->string
15:19:20 <MissPiggy> alise do you want parse and pretty print which are inverse (roughly)
15:19:26 <alise> yes
15:19:30 <MissPiggy> for a language with function application and infix ops?
15:19:30 <alise> from one parser definition
15:19:32 <alise> i'm _so close_
15:19:46 <MissPiggy> I can give you a couple scrpits that work toward this
15:20:19 <alise> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20105
15:20:22 <alise> Here's what I have so far.
15:20:25 <alise> This has taken HOURS.
15:20:59 <ksf> it's going to take longer and at least 200 lines more until its finished. at that point, you will be able to quickly reduce it to 50 lines.
15:21:07 <alise> that's my thinking
15:21:18 <alise> but damn, this is hard
15:21:21 <alise> -- if we ignore things like this in the resulting AST we can't reverse!
15:21:22 <alise> -- so, we need to know when we ignore them... somehow, and mandate that
15:21:22 <alise> -- the user specifies a default value
15:21:29 <alise> currently, I can't think of a way that isn't impossible
15:21:43 <alise> I have the advantage because give is a function under my control
15:21:49 <ksf> you can think impossible things? kudos.
15:21:50 <lpsmith> That doesn't mean that it *is* impossible :-)
15:21:53 <alise> and *I* decide who can parse correctly or not and how they do it
15:22:03 <alise> but I don't know how to use that to my advantage
15:22:24 <MissPiggy> alise, yeah you don't have  print . parse = id, but you should have parse . print = id
15:22:47 <ddarius> @google Hinze LR parsers
15:22:48 <lambdabot> No Result Found.
15:22:51 <MissPiggy> (print . parse) x = x only up to whitespace, extraneous parens and other irrelevant things
15:23:13 <alise> MissPiggy: yes of course
15:23:15 <ddarius> @google Derivation of a typed functional LR parser
15:23:16 <lambdabot> No Result Found.
15:23:18 <alise> and maybe variable names if you use de bruijn index
15:23:20 <ddarius> Stupid @google.
15:23:33 <alise> the point is that your functions should give the same semantic result after (print . parse)
15:23:34 <MissPiggy> so you can use a pretty printer as a specification (and I believe I've shown you this with dependent types)
15:23:44 <alise> ignoring ast-related things like errors, etc.
15:23:51 <alise> MissPiggy:
15:23:51 <alise> fooS :: PP Char Foo
15:23:51 <alise> fooS = only 'x' .> give X_ ()
15:23:51 <alise>    ||| only 'p' .> give P_ fooS
15:23:51 <alise>    ||| give S_ (tok, tok)
15:23:57 <alise> that's pretty close to a direct description of the syntax
15:23:58 <MissPiggy> but in doing that, you tend to end up with these very verbose BNF style specs
15:24:06 <MissPiggy> rather than the more natural and simple style
15:24:27 <gwern> @check \x y z -> x++y++z == [x,y,z]
15:24:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:24:35 <alise> 'x' means X (so X means 'x'), 'p' then stuff means P stuff (so P stuff means 'p' then stuff), 's' then char then char means S char char (so S char char means 's' then char then char)
15:24:47 * alise decides to implement give as busywork
15:24:48 <gwern> @check \x y z -> x++y++z == concat [x,y,z]
15:24:48 <lambdabot>   "OK, passed 500 tests."
15:24:50 <MissPiggy> okay
15:26:17 <alise> oops.
15:26:20 <alise> i need to map over a tuple
15:26:42 <gwern> > )length "x ++ y ++ z", length "concat [x,y,z]")
15:26:43 <lambdabot>   <no location info>: parse error on input `)'
15:26:46 <gwern> > (length "x ++ y ++ z", length "concat [x,y,z]")
15:26:47 <lambdabot>   (11,14)
15:26:52 <MissPiggy> bimap
15:26:58 <gwern> alise: I'm sure there's a functor instance for tuples letting you use fmap
15:26:59 <alise> MissPiggy: no, an N-tuple
15:27:07 <MissPiggy> ;_;
15:27:12 <alise> and each element has a different type, though I can pass them all to one function
15:27:25 <ksf> there's no such thing as an n-tuple
15:27:27 <alise> if you read Foo_'s definition in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20105 and give's type you'll see why
15:27:29 <gwern> n-tuples, otherwise known as heterogenous lists
15:27:33 <MissPiggy> YEAH
15:27:36 <alise> gwern: yes >_<
15:27:41 <gwern> > (length "x ++ y ++ z ++ a", length "concat [x,y,z,a]")
15:27:42 <lambdabot>   (16,16)
15:27:49 <MissPiggy> alise, by the way I don't think your approach is possible
15:28:16 <alise> I think what I should do is make it construct an AST for the parser
15:28:19 <alise> and operate on it symbolically
15:28:24 <alise> to transform into a parser and deparser
15:29:31 <MissPiggy> alise, have a look at  this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16355
15:29:33 * alise wipes everything, starts again
15:29:59 <alise> MissPiggy: right, but the idea is to write printparse which is just one function
15:30:00 <alise> i mean
15:30:02 <alise> _essentially_
15:30:04 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.68.4936
15:30:07 <alise> we just have to swap the RHS and the LHS
15:30:09 <MissPiggy> but why?
15:30:12 <alise> MissPiggy: ease
15:30:21 <MissPiggy> I mean this is basicalyl transposing the expression problem matrix
15:30:24 <alise> not having to decide where we need parens, etc; because it's handled for us
15:30:26 <MissPiggy> ohhhhhhh
15:30:29 <MissPiggy> I see why :)
15:30:32 <alise> MissPiggy: ohhhh what? :P
15:30:40 <MissPiggy> that's so damn obvious I wish I thought of it
15:30:47 <MissPiggy> you want to add more 'constructors' not more functions
15:31:06 <MissPiggy> there's only really print and parse, what more is neede
15:31:09 <MissPiggy> d*
15:31:19 <MissPiggy> yeah I see what you mean
15:31:47 <alise> in mine, you just write parseprint
15:31:54 <alise> which is basically like a parsec parser but slightly more involved
15:32:02 <alise> and you get print and parse for free
15:32:18 <geoaxis> hello people, yesterday i mentioned a challange, it was simple once i focused on how the quietsion could have been put inplace
15:32:21 <QC_OK> I can't do 5 * -3 in haskell....
15:32:26 * MissPiggy reads ddarius' link
15:32:28 <Cale> QC_OK: 5 * (-3)
15:32:33 <QC_OK> why the brackets/
15:32:34 <QC_OK> ?
15:32:48 <Cale> QC_OK: because without them it looks like you have two infix operators next to each other
15:33:06 <QC_OK> ok
15:33:09 <geoaxis> ie by looking into the file. today I have a new challange, its in a similar image with some sort of stenography and involves fibonacci series in backwards
15:33:14 <Cale> To use prefix negation it must be at the start of a subexpression.
15:33:23 <QC_OK> hmm I can do 5 * -3 in C
15:33:40 <QC_OK> :S
15:34:17 <QC_OK> why can't they allow 5 * -3, most languages allow it
15:34:21 <QC_OK> ...
15:34:30 <QC_OK> even in maths you can do that
15:34:53 <Berengal> Math invents new notation for every expression...
15:35:00 <MissPiggy> QC_OK because haskell sucks
15:35:02 <Berengal> But indeed, it's a grammar wart
15:35:07 <medfly> > 5 * (-3)
15:35:08 <QC_OK> Isn't haskell smart enough?
15:35:08 <lambdabot>   -15
15:35:17 <MissPiggy> QC_OK it's trivial to do it, haskell doesn't
15:35:18 <medfly> :t (-3)
15:35:19 <lambdabot> forall a. (Num a) => a
15:35:35 <Berengal> They're discussing changing it on the haskell' list
15:35:45 <QC_OK> This is the only language I have heard of that cannot do that
15:35:54 <medfly> ...
15:35:55 <ksf> in math, there's no 5 + -3
15:35:58 <MissPiggy> QC_OK it's not about 'cannot', anyone could do it -- its' trivial
15:36:00 <ksf> that's 5 - 3
15:36:09 <kuribas> Is (-) a prefix operator?
15:36:10 <MissPiggy> QC_OK, haskell /does not/
15:36:11 <QC_OK> of course there is
15:36:15 <QC_OK> ksf
15:36:19 <medfly> "Haskell sucks! it doesn't understand some notation!"
15:36:22 <MissPiggy> I write 5 + -3 all the time
15:36:38 <Berengal> MissPiggy: I tend to write that as "2"
15:36:38 <ksf> gosh who taught you guys arithmetic
15:36:55 <pikhq> QC_OK: Does 5 * / 3 make sense?
15:37:08 <QC_OK> no
15:37:12 <QC_OK> but 5 * -3 does
15:37:21 <QC_OK> because the - is unary
15:37:25 <ksf> there's no -3.
15:37:25 <MissPiggy> isn't the same as negative lol
15:37:27 <medfly> :t (-)
15:37:28 <lambdabot> forall a. (Num a) => a -> a -> a
15:37:28 <ksf> there's only 0-3
15:37:30 <kuribas> Haskell should get rid of unary -
15:37:30 <MissPiggy> 5 * 1/3
15:37:31 <QC_OK> most language are smart enough to realise that
15:37:37 <MissPiggy> I agree with kuribas
15:37:40 <QC_OK> languages*
15:37:44 <Berengal> I'm a fan of _ as negation...
15:37:52 <kuribas> You have also "negate"
15:38:02 <MissPiggy> QC_OK, its' not about smart!! any idiot could implement -Haskell which allowed 3 + -2
15:38:05 <medfly> I have yet to need negation enough to care about that in Haskell
15:38:19 <medfly> seriously
15:38:20 <MissPiggy> QC_OK, this is so bleedin' trivial to do
15:38:42 <Berengal> medfly: It's syntax. Actual need is irrelevant
15:38:45 <MissPiggy> QC_OK, the reason haskell doesn't do it is because it sucks, not because it's stupid -- this is so simple
15:38:56 <QC_OK> unary minus sucks?
15:38:57 <QC_OK> wow
15:38:59 <ksf> QC_OK, the main point is that in most languages, you aren't able to define arbitrary operators with arbitrary precedence
15:39:02 <ksf> in haskell, you can.
15:39:03 <QC_OK> now I've heard anything
15:39:07 <QC_OK> everything*
15:39:09 <MissPiggy> QC_OK, wrong it
15:39:51 <MissPiggy> QC_OK, we are going around in a loop where you pretend not to hear me or understand me :/
15:40:03 <kuribas> QC_OK: it does suck having to write parenthese around negative numbers.
15:40:03 <ksf> we're again proving wadler wrong.
15:40:12 <QC_OK> I don't understand how it "sucks"
15:40:15 <QC_OK> please explain
15:40:21 <ddarius> ksf: Wrong?
15:40:25 <MissPiggy> QC_OK, wrong it! what was the VERY FIRST thing I said to you?
15:40:30 <ksf> the most talked about subject isn't the syntax of literal comments, but the syntax of unary minus.
15:40:39 <MissPiggy> QC_OK, scroll up a little bit and read it :)
15:41:14 <ddarius> ksf: In Haskell they are at least syntactically close. -- v. -
15:41:33 <QC_OK> <MissPiggy> QC_OK because haskell sucks
15:41:37 <QC_OK> Ah I see
15:41:37 <kuribas> It ugly to have a unary and binary operator (-) at the same tame.
15:41:38 <MissPiggy> QC_OK yes!
15:41:41 <MissPiggy> QC_OK now you are getting it!
15:41:43 <ksf> oh, yeah. it's always nice when vim gets the highlightening wrong and interprets a random operator starting with -- as a comment.
15:41:50 <QC_OK> It's a crap language
15:41:53 <QC_OK> I get it now
15:41:54 <QC_OK> tnkas
15:41:54 <MissPiggy> QC_OK no
15:41:55 <QC_OK> thanks
15:41:59 <medfly> ouch
15:41:59 <MissPiggy> QC_OK that's not it
15:42:03 <medfly> you can make -- an operator?
15:42:03 <ickane> http://codepad.org/PjAGNDQr
15:42:06 <medfly> what does that do to comments?
15:42:10 <Hunner> MissPiggy: what does "wrong it" mean?
15:42:13 <ksf> nope, but stuff like -->
15:42:21 <ickane> can anyone explain to me my syntax error?
15:42:28 <MissPiggy> Hunner, it means there was a parse error
15:42:30 <medfly> sounds like something you'd want to avoid.
15:42:42 <ksf> let (-->) = (+) in 1 --> 2
15:42:47 <ksf> > let (-->) = (+) in 1 --> 2
15:42:48 <lambdabot>   3
15:43:07 <ksf> oh noes
15:43:09 <ksf> that should be
15:43:12 <QC_OK> i think it's ludicrous you have to have brackets for unary minus in expressions.
15:43:14 <QC_OK> Anal even
15:43:18 <MissPiggy> QC_OK, me too
15:43:20 <ksf> > let (-->) = enumFromTo in 0 --> 9
15:43:22 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
15:43:23 <MissPiggy> QC_OK, I am totally against it
15:43:26 <medfly> QC_OK, it's a really minor thing, okay?
15:43:30 <ksf> there, we got our own goes to operator.
15:43:44 <ddarius> ickane: Use GHC(i).
15:43:59 <kuribas> Can you define a unary operator?
15:44:02 <MissPiggy> QC_OK, I use  negate x   instead of (-x)
15:44:10 <QC_OK> ok
15:44:12 <ickane> ddarius: i dont understand
15:44:17 <medfly> QC_OK, there are even languages where 1 + 2 * 3 = 9
15:44:21 <ickane> ghc gives me the same parse error
15:44:31 <QC_OK> names?
15:44:33 <alise> QC_OK: listen
15:44:37 <QC_OK> of languages
15:44:37 <MissPiggy> kuribas, yeah just section a normal ope.g.  let (%) = \x -> x / 100 in  (3%)
15:44:38 <ksf> ickane, that _ doesn't line up
15:44:41 <ddarius> ickane: GHC should give you a better error message.
15:44:46 <alise> QC_OK: smalltalk for one
15:44:49 <alise> j is right-associative
15:44:50 <alise> QC_OK: anyway
15:44:55 <alise> QC_OK: let me tell you how it is parsed
15:45:01 <alise> QC_OK: 3 * (- 5)
15:45:06 <alise> just like any other operator
15:45:09 <MissPiggy> QC_OK, yeah -- negate is just a normal function instead of stupid magic annoying syntax abnormality -- makes everythign better
15:45:13 <ksf> ...so it's interpreted as part of the previous expression, which is a do-block which requires layout, and it's out of line, there, too.
15:45:15 <alise> do you see the problem now?
15:45:20 <alise> 3 * - 5 is ambiguous
15:45:20 <QC_OK> ok
15:45:23 <kuribas> MissPiggy: that's cheating :-)
15:45:24 <ddarius> medfly: Such as Smalltalk.
15:45:26 <alise> it's simply that there isn't a rule in the language to handle that special case
15:45:32 <MissPiggy> kuribas and that is how I always win :)
15:45:33 <alise> it isn't a big deal, anyway
15:45:38 <QC_OK> but what about precedence
15:45:39 <QC_OK> ?
15:45:46 <ickane> ddarius, ksf: it lines up with the other branches of the case? isnt it the default case?
15:45:56 <alise> QC_OK: - is the only unary operator in haskell
15:45:57 <MissPiggy> QC_OK: it doesn't even come into it! that's why I think my way is best
15:45:58 <alise> so it's a bit out of place
15:46:00 <Cale> QC_OK: - has lower precedence than * anyway
15:46:03 <alise> chill and worry about more important things :)
15:46:10 <alise> Cale: wouldn't it be (3 *) - 5?
15:46:10 <alise> lol
15:46:17 <Cale> - x * y means - (x * y), rather than (-x) * y
15:46:26 <QC_OK> no
15:46:33 <QC_OK> that's wrong
15:46:35 <QC_OK> alise
15:46:49 <Cale> (3 *) - 5 is actually possible in Haskell.
15:46:53 <alise> QC_OK: What is wrong?
15:46:58 <MissPiggy> QC_OK alise is right that - is out of place, actually I'd support it's death
15:46:59 <Cale> Though you need an additional instance of Num to make it work
15:46:59 <ksf> ickane, there's no "default" case as such. _ just happens to match anything. you could introduce a variable, there, too.
15:47:20 <Cale> I like unary - and think that it's one of the things which Haskell does right.
15:47:24 <Hunner> > let f = (3*) in f 5
15:47:25 <lambdabot>   15
15:47:45 <ksf> ...anyway, the layout has to match up on the left side, otherwise haskell can't know where your case ends.
15:48:15 <ickane> should it be directly under the case? it matches on the left with the 'q'
15:48:27 <kuribas> Cale: wouldn't "negate" be sufficient?
15:48:51 <ksf> one common way is to get rid of the case, and write getLine >>= f where f 'q' ; _ = return () ....
15:48:52 <ickane> could you modify the pastebin to illustrate? im sorry i'm very unfamiliar with haskell syntax :(
15:48:52 <Cale> kuribas: Writing negate is awkward, and the precedence is all wrong.
15:49:00 <QC_OK> I think this is more trouble than it's worth. i don't care, I'll just use whatever it wants...
15:49:08 <ksf> ickane, it should be on the same column as the '
15:49:13 <ksf> ...not as the p and r
15:49:26 <ickane> ksf: doh! thank you
15:49:36 * ksf thinks 0- is sufficient as negation.
15:50:04 <Cale> Yeah, you *could* write 0 - x rather than -x, but that looks silly :)
15:50:05 <medfly> hehe
15:50:15 <medfly> maybe make (--) = 0- ;)
15:50:32 <ksf> ickane, if you define a helper function instead of that case, you won't have any layout problems, at all.
15:50:33 <Cale> I like how well Haskell's convention matches the standard mathematical one.
15:50:43 <Cale> (well, "standard" :)
15:50:48 <ksf> ...and nested cases are goddamn ugly.
15:50:56 <MissPiggy> Oz use ~2
15:51:00 <MissPiggy> for negatie 1
15:51:03 <MissPiggy> for negative 2*
15:51:14 <medfly> @let (~) = 0-
15:51:14 <lambdabot>   Parse error: RightParen
15:51:15 <medfly> ?
15:51:22 <ksf> and you want to write hGetContents h >>= putStrLn
15:51:23 <medfly> @let (~) n = 0-n
15:51:23 <lambdabot>   Parse error: RightParen
15:51:27 <medfly> @let ~ n = 0-n
15:51:27 <lambdabot>  <local>:5:8:
15:51:27 <lambdabot>      Ambiguous occurrence `n'
15:51:27 <lambdabot>      It could refer to either `L....
15:51:30 <medfly> :(
15:51:31 <Berengal> Aren't there about ten different notations for negating an expression in mathematics? And fifty different interpretations of "negate"?
15:51:41 <ksf> ickane, see http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
15:51:44 <ksf> @where do
15:51:45 <lambdabot> I know nothing about do.
15:51:54 <ksf> @where+ do http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
15:51:55 <lambdabot> I will remember.
15:51:57 <Cale> medfly: ~ is special syntax, you can't use it as an operator symbol on its own, I'm fairly sure
15:52:07 <Cale> medfly: Because it's part of the syntax of patterns.
15:52:08 <medfly> ok
15:52:14 <medfly> whatever
15:52:18 <medfly> did he just leave
15:52:31 <Cale> QC_OK dud
15:52:32 <Cale> did*
15:52:53 <Cale> Berengal: hmm?
15:53:06 <medfly> ugh, more "oh no, we may mislead newcomers" :-/
15:53:38 <Cale> ksf: That seems like a pretty biased thing to link to 'do' in @where
15:53:52 <Cale> ksf: Probably a proper explanation of the do-syntax would go better :)
15:53:58 <Berengal> Cale: I'm just refering to all the hats, bars and squiggles
15:54:21 <medfly> I like my do notation
15:54:24 <medfly> you're not taking it away from me
15:54:31 <MissPiggy> do notation?
15:54:32 <Cale> Berengal: Yeah, but those are other sorts of inverses
15:54:49 <Cale> I disagree with almost everything that article about do-notation says
15:54:54 <MissPiggy> when ever something is considered harmful I'm like that "FUUU" comic
15:55:08 <Berengal> Cale: That's what I was refering to with the second sentance
15:55:09 <ksf> Cale, I dare to claim that especially rookies use do-notation way too often.
15:55:27 <ksf> and explicit bind-sequencing isn't hard. they can use that until they learn to google.
15:55:43 <medfly> everything isn't hard when you already know it!
15:55:47 <Zao> Can I provide a default implementation for a function in a class?
15:56:12 <dschoepe_> Zao: sure, just write func foo = bar in the class definition
15:56:18 <Zao> Excellent.
15:56:21 <ben> ksf: I do not think that page makes a good case against using do-notation :/
15:56:37 <ben> Is there only a finite amount of do's available that I need to be careful to use Applicative when possible?
15:57:52 <monochrom> @where do
15:57:52 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
15:57:52 <ksf> do-notation is useful when it's the right choice, but many people use it as their only choice.
15:58:00 <monochrom> haha no wonder
15:58:16 <medfly> it's the only choice!
15:59:29 <Hunner> > let (--) = (0-) in --5
15:59:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:59:57 <cizra> Hey guys, can I somehow "break" out of a function? Think C loops
16:00:00 <Cale> ksf: I would much rather look at a do-expression than a chain of >>='s and lambdas
16:00:12 <alise>     Can't make a derived instance of `Show (Syntax t a)'
16:00:12 <alise>       (Constructor `Sequence' does not have a Haskell-98 type)
16:00:14 <alise> infuriating
16:00:20 <alise> but also unavoidable; sigh
16:00:26 <alise> guess I should use a gadt
16:00:27 <monochrom> cizra: Yes you can, by just not recursing.
16:00:36 <ksf> Cale, the trick is not to use lambdas.
16:00:43 <Cale> Also, the order of statements in a do-block *does* (practically by definition) determine the order of execution.
16:00:54 <Cale> It just doesn't determine the order of evaluation.
16:00:55 <ksf> Cale, nope
16:01:00 <ksf> not with maybe, not with []
16:01:06 <Cale> Evaluation and execution are two different things.
16:01:10 <ksf> since when?
16:01:10 <cizra> monochrom: Get a key. Check if the key is 'q', then break. Otherwise, check if it's a movement key, in which case, act and recurse. I could nest the movement into an "else", but it'dn't look as nice.
16:01:17 <Berengal> ksf: Since IO
16:01:20 <Cale> Since the dawn of Haskell.
16:01:23 <ksf> darn.
16:01:27 <ksf> but that's another thing.
16:01:51 <ben> Can I just see "do" as overloading the newline operator which is more aesthetically pleasing than having >>=/>> all over the place?
16:01:52 <ksf> maybe I'm confused because you claim there is any order to evaluation, at all.
16:02:29 <Berengal> ksf: I'm perfectly happy with ignoring evaluation order. Execution order is important, however, because that's what determines the semantics
16:03:12 <monochrom> cizra: Do you have some existing code that I can look and point out how to modify?
16:03:12 <Cale> ben: hehe, sort of. It's syntax sugar which translates into a bunch of >>='s and lambdas
16:03:18 <Berengal> And execution doesn't have to be IO either. You can think of [] as an EDSL, with foldr as the interpreter
16:03:22 <ben> > do Just x <- return 42 ; undefined ; Just y <- fail "aaaa" ; return (x+y)
16:03:23 <lambdabot>   No instance for (GHC.Show.Show (m b))
16:03:23 <lambdabot>    arising from a use of `M6123854892...
16:03:33 <Cale> The rules are roughly:
16:03:34 <ben> err
16:03:35 <Cale> do { x } = x
16:03:46 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
16:03:48 <ben> > do x <- return 42 :: Maybe Int ; undefined ; y <- fail "aaaa" ; return (x+y)
16:03:49 <lambdabot>   * Exception: Prelude.undefined
16:03:52 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
16:03:55 <ksf> ...and yes, I _do_ make a point of using Foo <$> bar <*> baz instead of do x <- bar; y <- baz; return $ Foo x y
16:04:03 <ben> > do x <- fail "aaa" :: Maybe Int ; undefined ; y <- retun 42 ; return (x+y)
16:04:04 <lambdabot>   Not in scope: `retun'
16:04:07 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
16:04:13 <kmc> ben, technically, the newline is sugar for ;, and the ; is sugar for >> and >>=
16:04:14 <kmc> ;)
16:04:20 <ben> My fat fingers are getting the way of trying to make a point about evaluation order
16:04:33 <MissPiggy> is ben = benmachine?
16:04:39 <ben> No
16:04:42 <MissPiggy> okay
16:04:49 <cizra> monochrom: yeah, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20140#a20140
16:04:57 <sjanssen> @undo do x <- foo; y <- bar; return (x + y)
16:04:57 <lambdabot> foo >>= \ x -> bar >>= \ y -> return (x + y)
16:05:13 <kmc> cizra, what do you want to break out of
16:05:31 <tibbe> dons: yt?
16:05:38 <ksf> @pl (+) <$> foo <*> bar
16:05:38 <lambdabot> (+) <$> foo <*> bar
16:05:41 <ksf> see?
16:05:41 <ben> My point was that trying to execute Nothing and then evaluating bottom would terminate, unlike the other way around. I am not sure it is a good point.
16:05:44 <Cale> ben: It's best to try to disregard fail. It's one of the places where the Prelude needs work.
16:05:49 <cizra> kmc: solved already
16:05:50 <tibbe> @seen dons
16:05:50 <lambdabot> Unknown command, try @list
16:05:51 <kmc> cool
16:05:57 <tibbe> preflex: seen dons
16:05:58 <preflex>  dons was last seen on #xmonad 7 minutes and 28 seconds ago, saying: yeah
16:06:00 <cizra> kmc: C-style thinking...
16:06:46 <monochrom> cizra: It already breaks out. If you don't like if-then-else, try this: case key of { KeyChar 'q' -> return (); _ -> do { actOnKey key; mainLoop } }.  Of course replace my {;} with newlines and layouts.
16:07:49 <cizra> monochrom: I had that version, but couldn't figure out the do ... part (=
16:08:02 <kmc> hmm, mainLoop = do { key <- getKey refresh; when (key /= KeyChar 'q') (actOnKey key >> mainLoop) }
16:08:03 <cizra> monochrom: Mind pointing me towards the easiest State monad tutorial on the earth?
16:08:09 <kmc> i think that's easier to read (once layout-ified)
16:08:16 <kmc> main = start >> mainLoop >> end
16:08:32 <cizra> kmc: VERY arguable.
16:08:53 <cizra> I gotta admit I find imperative Haskell + ncurses quite easy :-D
16:08:58 <dmhouse> I think I'd put do key <- getKey refresh; unless (key == keyChar 'q') (actOnKey key >> mainLoop)
16:08:58 <kmc> :)
16:09:06 <kmc> oh we have unless? cool
16:09:09 <kmc> perl eat your heart out
16:09:13 <dmhouse> ?hoogle unless
16:09:13 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
16:09:19 <ben> @hoogle don't
16:09:19 <lambdabot> No results found
16:09:53 <dmhouse> (Btw, the above is fine in terms of layout; you don't need braces.)
16:09:54 <kmc> getKey refresh >>= liftM2 unless (keyChar 'q' ==) ((>> mainLoop) . actOnKey)
16:09:57 <cizra> So, I think I need the State monad for holding the player position.
16:10:17 <kmc> cizra, if you're already doing stuff in IO, you might want to use IORef
16:10:26 <kmc> (i.e., real imperative mutable cells)
16:10:27 <cizra> Never heard
16:10:40 <kmc> cizra, http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/Data-IORef.html
16:10:47 <dmhouse> An IORef is like a mutable variable.
16:11:13 <dmhouse> Basically part of the structure of the IO monad contains a dictionary of these references, and you can create new ones, grab values of existing ones, update them etc.
16:11:41 <cizra> Would it be good to keep using IORefs if the project survives and grows?
16:11:43 <kmc> and (if you care about underlying implementation) GHC compiles this to real memory read/write, whereas State monad is just syntactic sugar for a pure-functional passing of immutable states
16:11:59 <kmc> cizra, that depends.  at some point your code will become concurrent and multithreaded and you might want MVar ;)
16:12:00 <dmhouse> There are advantages to doing the state in State, though (or StateT s IO in your case), e.g. you don't have to pass around your IORefs everywhere
16:12:30 <cizra> Uh, I just want to remember the player position |-:
16:12:52 * cizra googles for ioref examples
16:12:56 <dmhouse> cizra: for now. Surely before long you'll have a lot more state to keep track of.
16:14:05 <kmc> cizra, State is convenient way to express pure functions "as if" they had state.  what you're writing is not that, it's an interactive ncurses game (?), it's inherently doing IO and so i think it makes more sense to use IORef or similar
16:14:08 <cizra> dmhouse: I guess so :-D What should I look for then?
16:14:22 <cizra> kmc: Hmm, OK.
16:14:38 <kmc> cizra, i think the names types in the Data.IORef module pretty much say everything
16:14:39 <MissPiggy> I meant the scalability and speed. An imperative solution should be simpler,
16:14:39 <MissPiggy> more scalable and faster than any purely functional solution.
16:14:41 <MissPiggy> LOL
16:14:46 <dons> tibbe:
16:14:54 <ben> @hoogle (?)
16:14:54 <lambdabot> Text.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
16:14:54 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$?>) :: Stream s Identity tok => (a -> b) -> (a, Parsec s st a) -> StreamPermParser s st b
16:14:54 <lambdabot> Text.Parsec.Prim (<?>) :: Monad m => ParsecT s u m a -> String -> ParsecT s u m a
16:14:55 <kmc> names and types*
16:14:57 <MissPiggy> frogs might fly
16:14:59 <ben> @hoogle (?:)
16:15:00 <lambdabot> No results found
16:15:09 <tibbe> dons: nice idea with a dual west coast hackathon
16:15:09 <dons> MissPiggy: not worth repeating.
16:15:22 <dmhouse> cizra: well there's no reason you can't have a big data structure you define to hold all the state of your game, and keep that in an IORef or in your State monad etc
16:15:22 <dons> fingers crossed
16:15:45 <cizra> dmhouse: Ha!
16:15:46 <tibbe> dons: I was thinking of topic for zurihac. the python guys had a need-for-speed hackathon where they really worked on speeding things up
16:15:47 <MissPiggy> or not
16:15:50 <MissPiggy> maybe it IS
16:15:55 <tibbe> dons: I might suggest that as a project
16:16:04 <dons> interesting.
16:16:07 <dmhouse> kmc: it will be pretty annoying having to pass around that IORef(s) everywhere though...
16:16:10 <tibbe> dons: would also have the benefit of teaching people how to write high performance hackathon
16:16:13 <dons> how would you structure it?
16:16:29 <kmc> dmhouse, true... maybe you can pass that with State ;)
16:16:36 <tibbe> dons: actually, one of the python need for speed guys who wrote their unicode stuff, among other things, works with me at Google and he might show up
16:16:37 <dmhouse> kmc, my point exactly.
16:16:54 <kmc> it is a good point
16:17:09 <tibbe> dons: I think a good starting point would be to hold a 15 min crash course on criterion and point at some libraries that could use some love
16:17:12 <kmc> it's not crazy to use IORef together with State (or  more likely Reader)
16:17:13 <dmhouse> (Unless you meant a State holding IORefs, which is just ridiculous.)
16:17:26 <kmc> i meant that but not too seriously
16:17:37 <dmhouse> StateT s IO is a reasonably common combination IIRC
16:17:41 <MissPiggy> this is very clever http://www.haskell.org/pipermail/haskell-cafe/2010-February/072760.html
16:17:57 <kmc> yeah, i have used that
16:21:02 <MissPiggy> "He must be. The joy of being a computer scientist is that when you have solved a problem once, you have solved it forever. Code re-use, people." -- is that accuarte?
16:22:05 <kmc> CS is about laziness.  tell the computer how to do your work so you don't have to
16:22:50 <opqdonut> luckily humans can still recognize some problems as the same that computers can't
16:23:03 <opqdonut> (i.e. the code you write is never general enough)
16:23:18 <opqdonut> so there's something left to do
16:25:33 <Saizan> tibbe: am i still in time to register for zurihac? (in case i manage to organize myself)
16:25:41 <cizra> > newtype GameState = (Int, Int)
16:25:42 <lambdabot>   <no location info>: parse error on input `newtype'
16:25:46 <cizra> -- what's wrong here?
16:25:56 <tibbe> Saizan: yes
16:26:00 <dmhouse> cizra: you need a constructor
16:26:00 <cizra> Ahh, no constructor!
16:26:24 <tibbe> Saizan: I'm closing registration tomorrow morning when I get to work
16:26:56 <kmc> the thing to do is to find a company which is paying hourly for a huge pile of manual data entry work, get them to agree to a lump payment on completion, then solve it with a few hours of scripting
16:27:07 <Saizan> ?localtime tibbe
16:27:07 <lambdabot> Local time for tibbe is 2010-02-14 01:26:43 +0100
16:27:38 <Saizan> tibbe: you mean Monday morning?
16:27:54 <tibbe> Saizan: yes
16:27:54 <opqdonut> kmc: and the thing that makes you a computer scientist is the willingness to spend more time on the scripting than the manual entry would've ever taken :)
16:28:01 <kmc> that's true
16:28:09 <Saizan> tibbe: k, thanks :)
16:28:14 <kmc> a friend of mine did this, got $10,000 for a day's work
16:28:26 <kmc> the company thought they'd be paying a minimum wage worker for years
16:28:38 <kmc> to read data out of one database and type it into another
16:29:38 <tibbe> Saizan: np
16:29:40 <erikc> kmc: lol, awesome
16:29:47 <dabblego> is there a type-class (on hackage?) with Monoid.mappend (Semigroup?), MonadPlusNotZero, AlternativeNotZero?
16:30:39 <erikc> look at job ads, i feel sorry for a lot of companies hiring programmers, it's obvious they have no idea what they're doing
16:30:57 <kmc> that's fine, they'll get programmers who have no idea what they're doing
16:31:09 <erikc> that's why i feel sorry for em :)
16:31:21 <kmc> heh
16:32:12 <ksf> I'm always afraid applying there
16:32:21 <MissPiggy> I am still thinking about that problem from earlier on,
16:32:33 <MissPiggy> since evaluating haskell is like graph reduction (on combinators)
16:33:03 <ksf> I guess I worked in too many software companies to realize that those ads are hilarious because I'd not be the only one with any competence, but also the only one who is able to fake any kind of competence.
16:33:44 <ksf> then I would be raised to cto, waste everybodies time and not code at all.
16:33:53 <ksf> so I guess the choice is right, after all.
16:34:16 <ksf> I want to see haskell evaluating under lambdas.
16:34:26 <MissPiggy> ksf really??
16:34:35 <ksf> full laziness and jit ftw.
16:34:46 <kmc> ksf, most organizations have people entrenched in powerful positions who are clearly incompetent yet untouchable
16:34:54 <kmc> they will get in your way
16:34:56 <ksf> with any program that runs for more than a second, heavy analysing pays off.
16:35:16 <kmc> ksf, good idea, especially if you have idle cores
16:35:31 <ksf> they'd be crawling up my ass to be able to look competent
16:35:37 <ksf> or stab me in the back.
16:35:42 <erikc> the latter :P
16:35:47 <ksf> either way, it's not my favourite work environment.
16:35:50 <erikc> what does 'evaluating under lambdas' mean
16:36:08 <kmc> (\x -> 2 + 3)  ==> (\x -> 5)
16:36:18 <ksf> partially applying not only the first, but possibly the second and not the first argument.
16:36:26 <ksf> and that, too.
16:36:31 <kmc> GHC's implementation of Haskell will not reduce that (+) until you pass an argument for x
16:36:40 <erikc> oh i see
16:36:44 <kmc> in other words it reduces to weak head normal form, not full normal form
16:37:20 <MissPiggy> that's interesting
16:37:39 <MissPiggy> > vaccum (\x -> x)
16:37:40 <lambdabot>   Not in scope: `vaccum'
16:37:44 <MissPiggy> > vacuum (\x -> x)
16:37:45 <lambdabot>   Not in scope: `vacuum'
16:37:52 <MissPiggy> , vacuum (\x -> x)
16:37:56 <kmc> ksf, sounds like you're describing something even more powerful
16:37:58 <MissPiggy> um?
16:38:08 <kmc> some kind of just-in-time supercompilation / partial evaluation
16:38:11 <MissPiggy> kind of odd to be honest
16:38:20 <kmc> lunabot is nowhere to be found :(
16:38:23 <dabblego> @seen edwardk
16:38:23 <lambdabot> Unknown command, try @list
16:38:27 <dabblego> !seen edwardk
16:38:32 <ksf> I'm trying to find a link
16:38:59 <ksf> there's a way to figure out how to reduce lambda calculus in the least steps
16:39:08 <ksf> problem being, figuring that out is quite expensive
16:39:14 * hackagebot upload: dgs 0.2 - Haskell front-end for DGS' bot interface (DanielWagner)
16:39:16 * hackagebot upload: sgf 0.1.1 - SGF (Smart Game Format) parser (DanielWagner)
16:39:18 * hackagebot upload: wyvern 0.1 - An autoresponder for Dragon Go Server. (DanielWagner)
16:39:23 <kmc> ksf, cool
16:39:31 <lpsmith> preflex,  seen edwardk
16:39:31 <preflex>  edwardk was last seen on #haskell 8 days, 3 hours, 27 minutes and 11 seconds ago, saying: hahahaha
16:39:41 <lpsmith> preflex,  seen mmorrow
16:39:41 <preflex>  mmorrow was last seen on #ghc 26 days, 21 hours, 41 minutes and 56 seconds ago, saying: * mmorrow is rtfm'ing
16:39:53 <ksf> for starters, google futamura projections
16:40:11 <MissPiggy> type Graph a = Pointer -> a
16:40:21 <MissPiggy> this is my data type for haskell evaluation
16:40:41 <MissPiggy> so I just need to define 'a'
16:41:41 <ksf> a search of that pile of papers yields e.g. http://www.brics.dk/~hosc/local/LaSC-2-1-pp9-50.pdf
16:41:59 <ksf> the whole topic is quite old, but has never been widely applied
16:42:03 <ddarius> Yay Futamura projections.
16:42:20 <MissPiggy> VAR Pointer | LAM Pointer | APP Pointer Pointer?
16:43:47 <cizra> mvAddCh y x ' ' doesn't work because Couldn't match expected type `GHC.Word.Word32' against inferred type `Char'. But there is no data constructor ChType...
16:44:31 <dabblego> {- associative -} class K f where append :: f a -> f a -> f a -- does this exist anywhere?
16:44:46 <cizra> So what do I have to do to the space to make it a ChType?
16:45:15 <kmc> > toEnum 73 :: Char
16:45:16 <lambdabot>   'I'
16:45:21 <kmc> :t toEnum . fromIntegral
16:45:22 <lambdabot> forall a a1. (Enum a, Integral a1) => a1 -> a
16:45:40 <MissPiggy> dabblego http://hackage.haskell.org/packages/archive/algebra/0.0.0.1/doc/html/Data-Semigroup.html
16:45:52 <MissPiggy> http://hackage.haskell.org/packages/archive/algebra/0.0.0.1/doc/html/src/Data-Semigroup.html
16:46:00 <MissPiggy> http://hackage.haskell.org/package/algebra
16:46:03 <dabblego> MissPiggy, thanks, but I want more
16:46:17 <MissPiggy> ummmmmmmm
16:46:22 <MissPiggy> okay wish I hadn't bothered now
16:46:42 <dabblego> MissPiggy, Semigroup is a different signature
16:46:57 <cizra> kmc: uh, I'm not sure I got it
16:47:20 <kmc> cizra, the function (toEnum . fromIntegral) will convert any integral type to any enumerable type
16:47:25 <kmc> such as Word32 to Char
16:47:58 <kmc> hmm, maybe you want to go the other way
16:48:00 <cizra> kmc: I need the opposite... toIntegral . fromEnum? Lemme try
16:48:09 <kmc> :t toIntegral . fromEnum
16:48:10 <lambdabot> Not in scope: `toIntegral'
16:48:10 <etpace> Im trying to write a function of type Integer -> [Integer], where f 356 would be [3,5,6], my initial attempt is:
16:48:14 <etpace> > let foo n = let m = fromIntegral . (subtract 1) . ceiling . logBase 10 $ n in [ (n `div` 10^x) `mod` 10 | x <- [1..m]] in foo 356
16:48:15 <kmc> :t fromInteger . fromEnum
16:48:15 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:48:16 <lambdabot>    `GHC.Float.Floating t'
16:48:16 <lambdabot>  ...
16:48:16 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
16:48:17 <lambdabot>       Expected type: a -> Integer
16:48:17 <lambdabot>       Inferred type: a -> Int
16:48:19 <MissPiggy> combinators are so much simpler than lambda terms, when you are doing graph reduction
16:48:20 <kmc> ?
16:48:40 <etpace> but I'm not really sure whats wrong with the code, any tips?
16:49:22 <MissPiggy> etpace, you can use divMod that would be good
16:49:26 <MissPiggy> > divMod 356 10
16:49:27 <lambdabot>   (35,6)
16:49:35 <MissPiggy> see that splits off the first bit so just use that iteratively
16:49:48 <MissPiggy> > unfoldr (Just . flip divMod 10) 356
16:49:48 <lambdabot>   [35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:49:54 <MissPiggy> hm that went wrong..
16:50:22 <ksf> etpace, http://codepad.org/GqEjL5j6
16:50:28 <ksf> that's not what you want, but close.
16:50:28 <cizra> kmc: still doesn't work..
16:50:28 <MissPiggy> > let swap (x,y) = (y,x) in unfoldr (Just . swap . flip divMod 10) 356
16:50:29 <lambdabot>   [6,5,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:50:34 <cizra> kmc:   mvAddCh y x (toInteger . fromEnum $ ' ')
16:50:47 <doserj_> > map digitToInt . show $ 354 -- cheating...
16:50:48 <lambdabot>   [3,5,4]
16:50:53 <MissPiggy> > let swap (0,_) = Nothing ; swap (x,y) = Just (y,x) in unfoldr (swap . flip divMod 10) 356
16:50:54 <lambdabot>   [6,5]
16:51:06 <MissPiggy> > let swap (_,0) = Nothing ; swap (x,y) = Just (y,x) in unfoldr (swap . flip divMod 10) 356
16:51:06 <lambdabot>   [6,5,3]
16:51:43 <MissPiggy> etpace (what's nice about the unfoldr is that you can relate it to the foldr function which does the inverse)
16:54:05 <cizra> ksf: Uh, actually chr brings me closest (= chr gives Int, now I have to figure out how to castrate it into Word32
16:54:11 <etpace> cheers
16:54:39 <ddarius> @quote fromIntegral
16:54:39 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
16:54:41 <ddarius> @quote fromIntegral
16:54:41 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
16:54:50 <ddarius> @quote fromIntegral!
16:54:51 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:55:03 <kmc> ah, chr is just toEnum with a restricted type
16:55:24 <MissPiggy> I have a vauge idea baout how to do beta reduction on graphs but I don't know if it's correct :(
16:55:26 <kmc> > (fromIntegral :: Int -> Word32) 87
16:55:27 <lambdabot>   87
16:55:36 <kmc> type annotation probably not needed in your case
16:56:04 <cizra> rouge.hs:36:40: Not in scope: type constructor or class `Word32'
16:56:12 <ddarius> @google "optimal evaluation"
16:56:13 <lambdabot> http://www.auanet.org/content/guidelines-and-quality-care/clinical-guidelines/main-reports/optimalevaluation.pdf
16:56:13 <lambdabot> Title: Optimal Evaluation
16:56:23 <ddarius> Hmm... not quite what I was going for.
16:56:24 * cizra imports
16:56:30 <ddarius> @google "lambda graphs"
16:56:30 <lambdabot> No Result Found.
16:56:44 <ksf> optimal, not perfect, that's it.
16:57:00 <MissPiggy> Cyclic Lambda Graph Rewriting?
16:57:02 <ddarius> @google "optimal reduction"
16:57:04 <lambdabot> http://www.springerlink.com/index/u8mxf6f7ye39wt8p.pdf
16:57:04 <lambdabot> Title: SpringerLink Home - Main
16:57:25 <MissPiggy> The Geometry of Optimal Lambda Reduction?
16:57:26 <ksf> http://scholar.google.de/scholar?hl=de&lr=&cluster=13257825826341247319&um=1&ie=UTF-8&ei=S0p3S43nG9j9sQb42sXKCg&sa=X&oi=science_links&resnum=3&ct=sl-allversions&ved=0CCQQ0AIwAg
16:57:39 <ksf> http://www2.parc.com/csl/groups/sda/publications/papers/Lamping-POPL90/for-web.pdf , that is.
16:57:47 <MissPiggy> wow this one sounds interesting
16:58:37 <cizra> ksf: I think it works now, but looks ugly as sin:   mvAddCh y x ((fromIntegral :: Int -> Word32) . ord $ ' ')
16:59:17 <ksf> I'm not kmc
16:59:28 <MissPiggy> you are similar though
16:59:37 <ksf> and if you claim that he's the same colour, get a client that doesn't colour nicks.
17:00:16 <dabblego> is scan* on a type-class somewhere?
17:00:23 <cizra> ksf: bad tab completion, sorry
17:04:37 <MissPiggy> I think I will implement Lamping
17:04:43 <MissPiggy> 's algorithm
17:04:53 <MissPiggy> in haskell
17:19:38 <Veinor> #c++ leak
17:19:38 <Veinor> 20:15:38 < shrughes> [17:13]  <Chile> i'd really like to try teaching someone haskell as the first programming language they've ever touched
17:19:41 <Veinor> 20:15:38 < shrughes> [17:13]  <Chile> like, if they really had *never* used an imperative language
17:19:46 <Veinor> 20:15:49 < shrughes> [17:14]  <Artifice> I think they tried experiments like that in 1940s germany
17:20:27 <monochrom> haha
17:20:29 <shrughes> quote me again Veinor and I'll reveal your true name :P
17:20:44 <Veinor> but removing that would take... EFFORT D:
17:22:37 <cizra> Veinor: Uh, my wife saw me solve a problem that would be difficult in C with one list comprehension. She's sniffed some C but doesn't really grok it.
17:22:57 <cizra> Veinor: Well, she was amazed at the simplicity of it.
17:22:59 <Veinor> what problem?
17:23:07 <MissPiggy> lol this algorithm is way too cimplicated
17:23:11 <MissPiggy> complicated*
17:23:18 <MissPiggy> I can't code this
17:23:31 <cizra> Veinor: generating triples of numbers <- [1..9], where sum of them is 15 and the numbers don't repeat
17:24:33 <Veinor> yeah, that's fairly straightforward
17:24:36 <QC_OK> What is the /= operator?
17:24:39 <QC_OK> What does it mean?
17:24:43 <MissPiggy> QC_OK that's for not equal to
17:24:50 <QC_OK> Thanks.
17:25:06 <QC_OK> I've never seen that style before
17:25:11 <QC_OK> always != or <M
17:25:12 <MissPiggy> cizra what about prolog?
17:25:14 <QC_OK> <>
17:25:19 <Veinor> <> is silly.
17:25:24 <MissPiggy> yeah I am used to <>
17:25:27 <MissPiggy> but prolog does \=
17:25:31 <MissPiggy> and haskell /=..
17:25:31 <QC_OK> heh
17:25:33 <MissPiggy> so whatever :P
17:25:34 <Veinor> ... why would you do \= ?
17:25:37 <MissPiggy> I can't think of more than that
17:25:40 <Veinor> that's not how the slash goes :/
17:25:47 <cizra> MissPiggy: Haven't shown her that (= It's too hairy for my tastes
17:26:05 <Veinor> cizra: I got [(x,y,z) | x <- [1..9], y <- [1..9], z <- [1..9], x + y + z == 15, x /= y, y /= z, x /= z]
17:26:12 <MissPiggy> cizra don't know about hairy but you'll get a more declarative more efficient program than the list comprehension thing
17:26:22 <cizra> Veinor: You plagiarizer!
17:26:26 <Veinor> :P
17:26:49 <cizra> MissPiggy: Might be.. But I don't know much Prolog, so it'd be perilous to teach it to a newb.
17:26:55 <MissPiggy> yeah that figures
17:28:47 <Veinor> oh wait, you can do (x-y) * (y-z) * (x-z) /= 0
17:28:55 <QC_OK> Veinor, <> isn't totally silly
17:29:03 <MissPiggy> there's nothing silly about <> IMO
17:29:08 <QC_OK> It could be interpreted as bigger or smaller
17:29:15 <Veinor> but what about things that have no ordering?
17:29:15 <QC_OK> smaller or bigger
17:29:32 <MissPiggy> Veinor everything has ordering, set theory :P
17:29:36 <alise> ≠
17:29:41 <alise> Problem solved; you can all go home now.
17:29:42 <QC_OK> No, Sets have no order
17:29:57 <Veinor> alise: great, now how do i portably input that?
17:29:59 <Veinor> :P
17:30:15 <MissPiggy> QC_OK well ordering theorem
17:30:19 <alise> Veinor: Yeah, and how will we ever run functional programs quickly without optimisations far too slow to run on my 386?
17:30:24 <MissPiggy> QC_OK, every set is well ordered ;(
17:30:24 <Berengal> > [(x,y,z) | [x,y,z] <- replicateM 3 [1..9], x + y + z == 15, 3 == length (nub [x,y,z])]
17:30:25 <lambdabot>   [(1,5,9),(1,6,8),(1,8,6),(1,9,5),(2,4,9),(2,5,8),(2,6,7),(2,7,6),(2,8,5),(2...
17:30:37 <MissPiggy> QC_OK, I'm mostly kidding
17:30:43 <alise> Veinor: I guess you don't like Lisp because you need a specialised editor, too :-)
17:30:49 <QC_OK> ok
17:30:52 <alise> But you may notice that Haskell is a bit of a pain without good editor support as well.
17:30:57 <Veinor> I'm only half-serious here
17:31:08 <Veinor> Berengal: nice.
17:32:28 <Veinor> also, I use emacs with haskell-mode
17:37:45 * Zao huggles the Haskell mode for vim.
17:40:07 * ddarius uses vim with syntax highlighting and autoindent and that's it for Haskell coed.
17:40:12 <ddarius> s/coed/code
17:41:49 * dmwit too
17:42:38 <Zao> I find it rather invaluable to be able to pull up haddocks, generate type signatures, complete from libraries, add imports, and much more.
17:43:05 <Veinor> coed haskell! :O
17:44:08 <Saizan> add imports? i want that!
17:44:14 <Saizan> how does it work?
17:44:21 <Saizan> ghc-pkg find-module ?
17:44:35 <Saizan> ah, no, that's Module -> Package
17:46:23 <MissPiggy> I really need a good way to make GUIs in haskell
17:46:49 <MissPiggy> just like an HTML canvas that's programmable, and you dont need to run  acomplicated web server for
17:46:59 <MissPiggy> by HTML canvas I don't mean <canvas>...
17:47:09 <Zao> Saizan: No idea. I type _i or _im and it imports the function I hover over's module.
17:47:16 <Zao> http://projects.haskell.org/haskellmode-vim/
17:47:56 <erikc> MissPiggy: GUIs are a huge can of worms :\
17:48:38 <MissPiggy> yeah well at the moment I don't even know how to open it
17:48:54 <MissPiggy> sometimes I just need something a bit better than lines of text..
17:50:02 <Saizan> it seems like it parses haddock's html
17:50:08 <erikc> MissPiggy: OpenGL?
17:51:04 <MissPiggy> I guess sooo but that's so difficult
17:59:35 <erikc> MissPiggy: since perf wont really matter, you can just read the pixels from the framebuffer into a bitmap, modify the bitmap, and then render a texture-mapped quad to the framebuffer with the image
17:59:44 <erikc> the bitmap image is your canvas
17:59:57 <MissPiggy> yeah but how do you do text layout and all that
18:00:03 <MissPiggy> it's just so much work
18:00:44 <erikc> freetext/uniscribe/coretext can generate bitmaps of text for you
18:01:00 <MissPiggy> -_-
18:05:11 <MissPiggy> is there a http server which just gives you like a monad.. or something
18:05:21 <MissPiggy> actually on that wouldn't work
18:05:37 <MissPiggy> I need whatever Berengal was doing with Cont
18:06:05 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17126
18:10:47 * MissPiggy sighs.. this is going nowhere
18:14:54 * cizra ponders... I started out with IORef (player_coordinates) for my game state, then moved to IORef (player_coordinates, [monsters]), meanwhile changing every function that was dealing with game state.
18:14:59 <cizra> This approach looks unsustainable.
18:15:03 <cizra> What would be a better wya?
18:15:04 <cizra> way*
18:16:00 <monochrom> record
18:16:55 <Zao> data GameState = GameState { gsPlayerCoords :: Coord, gsMonsters :: [Monster] }
18:17:23 <cizra> Thanks!
18:17:56 <MissPiggy> what web server should I use to make a GHCi repl?
18:19:30 <Lemmih> MissPiggy: lighttpd?
18:35:03 <gwern> bleh. I *hate* it when maintainers refuse to apply patches saying they have a lot on their plates right now
18:35:25 <gwern> MissPiggy: you want to make a ghci repl with a web server?
18:35:30 <gwern> MissPiggy: what's your security story?
18:35:31 <MissPiggy> yes gwern
18:35:42 <MissPiggy> gwern it only runs on my computer though
18:35:51 <gwern> what's the point then?
18:35:52 <tensorpudding> @src nub
18:35:52 <lambdabot> nub = nubBy (==)
18:35:55 <MissPiggy> I mean the only reason for it is to have a GUI repl for myself, rather than a text one
18:35:57 <tensorpudding> @src nubBy
18:35:58 <lambdabot> nubBy eq []             =  []
18:35:58 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:36:38 <gwern> MissPiggy: a web interface is no more meaningfully a gui than ghci; in both you put text in and get text back
18:37:01 <MissPiggy> gwern yeah but it would do html and TeX
18:37:06 <MissPiggy> not just text output
18:37:16 <gwern> html and tex?
18:37:25 * gwern has never seen ghci output html or tex
18:38:56 <tensorpudding> @src (<$>)
18:38:56 <lambdabot> f <$> a = fmap f a
18:38:59 <tensorpudding> aha
18:40:41 <MissPiggy> gwern lol what
18:40:56 <gwern> MissPiggy: you said it, not I
18:41:49 <dmwit> MissPiggy: How would your preferred repl differ from the one we have now?
18:42:07 <dmwit> I mean, right, "it would use HTML", but what would it use HTML *for*?
18:42:11 <MissPiggy> it would ouptut HTML and TeXified stuff
18:42:57 <dmwit> I mean, right, "it would output HTML", but what would it use HTML *for*?
18:43:11 <gwern> so your server includes an AI which can recognize an turn arbitrary ghci output into html and texified output?
18:43:42 <dmwit> MissPiggy: I'm not trying to give you a hard time or discourage you from making this happen, I'm just trying to understand what you want.
18:44:00 <dmwit> Perhaps parts of what you want are already available, for example! =)
18:44:00 <MissPiggy> gwern: it's just a function like show -- wouldn't call it an AI exactly
18:44:15 <burp> hm, linear congruence generator y_i+1 = (1029*y_i + 221591) `mod` 1048576 .. isn't this a very bad choice for modulo etc.?
18:44:30 <gwern> MissPiggy: ghci outputs a String; what does your show-like function do with it?
18:44:34 <burp> first of all it's very small
18:44:39 <MissPiggy>  output HTML
18:44:45 <dmwit> > 1024 * 1024
18:44:46 <lambdabot>   1048576
18:45:07 <dmwit> burp: seems like a perfectly cromulent choice to me
18:45:12 <gwern> MissPiggy: so your function would be \x -> "<html><body>" ++ x ++ "</body></html>", ten?
18:45:27 <MissPiggy> a bit more advanced than that
18:45:27 <dmwit> burp: You get exactly 20 bits of "randomness" out of each invocation... what's not to love?
18:45:36 <MissPiggy> but roughly
18:45:36 <dmwit> Need more bits, call it more times. =)
18:46:14 <dmwit> MissPiggy: I guess what gwern and I are getting at is: why bother?
18:46:33 <gwern> (I sometimes ponder what would happen if one took a 1.5tb drive back to the 70s, wrote driver code, and hooked it up to some university's mainframe and minicomputer; how would people freak out?)
18:46:36 <MissPiggy> because I want TeX instead of crap ASCII
18:47:02 <gwern> ascii -> tex is either trivial & pointless, or requires magic pixie dust
18:47:27 * dmwit hasn't understood MissPiggy yet
18:47:29 <MissPiggy> gwern TeX displayed as a nice graphic not as \frac{..} ASCII unreadable rubbish
18:47:52 <gwern> oh, so all your output gets wrapped in '\text{...}'? what's the point o that?
18:47:52 <burp> dmwit: why would one choose that instead of modulo of 2^32 with 32bit integers, any idea?
18:48:10 <dmwit> burp: Perhaps you don't get a full 32 bits of randomness out of that function.
18:48:17 <dmwit> burp: Perhaps you only get 20.5 or so.
18:48:26 <burp> hm, yes
18:48:58 <MissPiggy> gwern look at this picture http://maxima.sourceforge.net/screenshots/maximatexmacs.png
18:49:21 <MissPiggy> do you understand?
18:49:22 <gwern> MissPiggy: and that's with a human generating meaningful tex
18:49:26 <gwern> MissPiggy: so no, I don't
18:49:33 <MissPiggy> okay then E give up
18:49:35 <MissPiggy> I*
18:49:42 <gwern> I don't see where a human tapping haskell expressions into a haskell interpreter has anything to do with tex
18:51:53 <cads> ascii -> tex  requires that you do interpretive dance using ascii art and hope that it turns into pretty math typesetting?
18:52:40 <cads> MissPiggy, have you used mathematica's point and click method of composing typeset equations?
18:52:53 <MissPiggy> no that sounds cool though
18:54:22 <cads> you can insert a symbol, and the symbol will have blank boxes where you can put further equations - for example a division symbol starts out as a horizontal line with two empty boxes.
18:54:52 <cads> You can do pattern matching on these forms to define your own symbolic syntax
18:54:54 <MissPiggy> oh I have used something like that before
18:56:49 <BMeph> Sounds like the display on the ALEKS website.
19:00:19 <cads> I'd kill for haskell to have things like subscripts and superscripts and pattern matching over those. For example you could define  f^0 = id ;  f^n = f . f^(n-1)  for some function f, then in your code f with a superscript number would represent successive function application.
19:01:05 <MissPiggy> cads, hm you can do that though already?
19:01:20 <MissPiggy> > let f^0 = id ;  f^n = f . f^(n-1) in (not^2)
19:01:21 <lambdabot>   Precedence parsing error
19:01:21 <lambdabot>      cannot mix `L..' [infixr 9] and `^' [infixl 9...
19:01:28 <MissPiggy> > let f^0 = id ;  f^n = f . (f^(n-1)) in (not^2)
19:01:29 <lambdabot>   {True->True;False->False}
19:01:50 <MissPiggy> > let f^0 = id ;  f^n = f . (f^(n-1)) in (not^3)
19:01:51 <lambdabot>   {True->False;False->True}
19:03:20 <cads> right, but suppose something that looked like  f  could be set up
19:04:09 <cads> ie, with editor support for code layout similar to typeset math
19:05:42 <cads> MissPiggy, I've seen that Fortress has something like this, but I don't think the system is as versatile as mathematica's http://projectfortress.sun.com/Projects/Community/wiki/MathSyntaxInFortress
19:06:12 <MissPiggy> that's nice but that's not interactive is it?
19:06:55 <cads> I don't believe so
19:07:04 <cads> haskell has something like that as well : http://people.cs.uu.nl/andres/lhs2tex/
19:07:34 <abcdef> [1..]
19:07:53 <dmwit> > [1..]
19:07:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:08:13 <cads> MissPiggy, for example  ->  symbols are turned into actual arrows, function names/variables are italicized.. people use it to publish haskell code in academic papers
19:09:03 <gwern> yi/emacs/leksah also do the unicodifying on the fly for display
19:09:10 <Gracenotes> so, Fortress is a language Steele wants to see in wide use?
19:09:46 <Gracenotes> at least wide niche use
19:10:09 <dolio> It's going to replace Fortran, right?
19:10:46 <arw> until oracle decides that academic use doesn't generate enough profit and java is more enterpricey...
19:11:31 <cads> I hear the project's funding was cut in '06
19:12:19 <cads> but oss guys have been fiddling with it
19:14:34 <cads> Oh too cool - http://projectfortress.sun.com/Projects/Community/attachment/wiki/WikiStart/reference.pdf?format=raw check out the bottom left part of the first page - the fortify editor is a emacs mode where things like SUM and PROD are automatically replaces with mathematical symbols
19:16:59 <MissPiggy> cads, cool I got to try it out :)
19:18:58 <cads> rendered fortress code reminds me of pseudo-code from some knuth or dijsktra writings
19:19:06 <MissPiggy> yeah
19:19:11 <MissPiggy> I like fortress it's super cool
19:19:27 <cads> oh shit, I just remembered this is #haskell.. :/
19:19:39 <cads> sorry guys
19:19:42 <MissPiggy> where did you think it is?
19:19:51 <cads> MissPiggy, #haskell-blah
19:20:02 <Becquerel> it's not as if anyone else is using it :P
19:20:03 <MissPiggy> okay im there
19:21:34 <cads> Becquerel, it's just respect :)
19:22:09 <Becquerel> cads: you're respectfully introducing them to something awesome!
19:22:12 <Becquerel> ...by accident :P
19:27:15 <Gracenotes> hm, is there a library that can encode arbitrary pitches into midi?
19:28:27 <dmwit> Can't haskore?
19:28:41 <Gracenotes> looking around for the option, if it has one
19:28:55 <dmwit> Haskore.Basic.Pitch.Absolute?
19:30:32 <Gracenotes> not exactly arbitrary
19:30:53 <Gracenotes> it's just an enumeration of piano keys, essentially
19:31:27 <dmwit> oh
19:31:41 <dmwit> Absolute is not a frequency like I thought.
19:32:14 <dmwit> sorry
19:33:12 <Gracenotes> midi can handle frequencies as pitch modulations, I know, but there may be some calculation required there, and not even sure if Haskore exposes an interface to do it
19:34:23 <dmwit> Well, there's a lot of midi libraries on hackage.
19:34:34 <dmwit> I hope one of them has what you want. =)
19:38:08 <Gracenotes> the midi package has a pitch bend. but how the heck do I use it
19:43:07 <mreh> i'm about to upload a music application, it needs testing to destruction because I know I haven't
19:45:17 <Gracenotes> > (9/8)^5 * (256/243)^2 :: CReal
19:45:18 <lambdabot>   2.0
19:48:22 <MissPiggy> > [9^5,8^5 , 256^2,243^2] :: [CReal]
19:48:23 <lambdabot>   [59049.0,32768.0,65536.0,59049.0]
19:51:06 <ski> (hm .. Agda1 has a structural editor where you construct a proof by filling in holes with constructions, usually creating more sub-holes. <http://www.mdstud.chalmers.se/~md9slj/code/alfa/alfa/LogicTest.alfa.png>)
19:56:24 <MissPiggy> that's really neat too ski!!
19:56:26 <MissPiggy> I've seen that before
20:00:00 * ski would like it if Alfa (the structural editor there) was ported to Agda2 ..
20:00:53 <ski> btw, obviously, when you fill in a hole, that can instantiate other holes in the program, too
20:01:02 <MissPiggy> yes
20:01:47 <ski> (because of the dependent typing)
20:03:26 <ski> the system can also keep track of what variables are in scope, and present you with a list of those that type-checking decides can fit in the current hole
20:05:37 <ski> (if you insert `foo' where `foo :: (A :: Set) -> (a :: A) -> Foo a -> Bar A a', then it would usually create an application of `foo' to three (in this case) holes .. in some cases it can determine that a partial application is wanted, otherwise one can use "Edit as Text" on the subexpression(
20:06:28 <ski> (s/ion(/ion)/)
20:06:36 <MissPiggy> ski well  something like this for epigram would be super
20:06:48 <ezyang> What was the name of the "thingy" that allowed you to write functions that varied on ranges of inputs (i.e. not just x[n] -> y[n], but x[1],x[2]...x[n] -> y[n])
20:06:56 <ezyang> It might have been co- something?
20:07:23 <dmwit> ezyang: hmm?
20:07:44 <ezyang> This might be a comonad
20:07:46 <ski> ezyang : maybe you're after the type class trick used in e.g. `printf' ?
20:07:59 <dmwit> ezyang: Just explain a little more fully what you're after.
20:08:05 <dmwit> Your current text is horrifically vague.
20:08:12 <ezyang> Basically, it's a generalization of functions.
20:08:25 <ski> arrows ?
20:09:04 <dolio> You mean you want to write f a -> b, and automatically get f a -> f b?
20:09:15 <dolio> Instead of (a -> b) -> f a -> f b?
20:09:23 <ezyang> dolio: Ooh, yeah, that's it.
20:09:38 <ski> that's comonads, yes
20:09:39 <dolio> Comonads give you that, yes.
20:09:52 <ezyang> ok.
20:10:04 <ezyang> Would you guys say that comonads are a good way to calculate convolutions?
20:10:23 <ezyang> hmmm, sigfpe seems to think so :-)
20:10:24 <dmwit> They sound like a pretty good match.
20:10:39 <ezyang> cool.
20:10:59 <ezyang> I wonder if deconvolutions are also comonadic
20:12:14 <MissPiggy> wow what is a deconvolution?
20:12:24 <ezyang> It's a cute trick in signal processing
20:12:44 <ezyang> If you have a noise free channel and you know its unit sample response, you can take the output from the channel, deconvolve it, and get the "clean" input sample.
20:12:46 <MissPiggy> I probably don't even understand convolution, I thought it was basically polynomial multiplication
20:13:01 <ezyang> Polynomial multiplication looks like convolution, yes.
20:13:07 <ezyang> It also pops up in LTI systems
20:13:52 * ezyang didn't understand convolution when he was taught in diff eq. Probably still doesn't. 
20:18:11 <MissPiggy> that's reassuring lol
20:18:29 <MissPiggy> man I love diff eq but it's so hard
20:18:59 <ezyang> It has pretty far reaching consequences. At least in my experience any class that wants to use diff eq ends up having to reteach it, since the real "diff eq" class didn't teach it properly.
20:19:25 <ezyang> Anyway, I love it when something ridiculous like a comonad ends up being the perfect sort of pattern for some specific computation.
20:24:08 <dolio> Monads, comonads, functors and adjunctions are all over the place in mathematics.
20:24:42 <ezyang> but but but "practical" uses! :o)
20:25:07 <MissPiggy> I have never met an adjunction
20:25:19 <MissPiggy> what do you need to know to get adjunctons?
20:25:20 <dolio> Mathematics occasionally has practical uses, I've heard.
20:25:49 <dolio> Adjunctions are key to algebraic treatment of logics with quantifiers.
20:27:33 <dolio> The existential quantifier is defined in terms of a left adjoint to a certain functor, and the universal quantifier is a right adjoint to that same functor.
20:29:42 <dolio> Also, sums and products.
20:29:54 <dolio> + -| Diag -| x
20:31:13 <dolio> Also, exponentials. A x = -| =^A
20:37:53 <dolio> Adjunctions are one of the things in category theory where books work up to them, and then remark, "by the way, everything we've talked about in the previous chapters can be formulated in terms of adjoints."
20:40:12 <dolio> Like, they might talk about initial and terminal objects, and products and coproducts, and then say, "by the way, these are all special cases of (co)limits."
20:43:32 <MissPiggy> alright
20:43:49 <MissPiggy> I think it will be a long while..
20:45:05 <dolio> So any (co)limit can be defined by some adjunction, I think.
20:45:58 <dolio> But, for instance, The exponential functor =^A isn't really a limit or a colimit, but it has some obvious similarities going on.
20:46:17 <dolio> In terms of the definition being like 'forall ... exists unique ...'.
20:46:24 <dmwit> Is there some book like "Category Theory for People Who Just Don't Want to Embarass Themselves"?
20:47:39 <ozataman> hey all.. what is the best way to time a function inside a program?
20:48:06 <ozataman> like find out how many picoseconds it takes to execute some function
20:48:18 <dolio> There's Basic Category Theory for Computer Scientists. But I found that kind of hard to get through without also reading other material to get a better handle on what all was going on.
20:48:44 <dolio> It's short, though.
20:49:24 * ezyang adds to reading list 
20:49:31 <ezyang> ozataman: picoseconds?
20:49:43 <ozataman> microseconds, nanoseconds, etc
20:49:43 <ezyang> I don't think your cpu gives you that granularity
20:49:52 <mauke> profiling
20:50:02 <ozataman> sorry its late - i picked the first small amount that came to mind
20:50:13 <ozataman> I dont want to profile... this will be a part of the program itself
20:50:18 <dolio> There's a CPUTime module.
20:50:48 <dolio> But you're going to have to run functions many, many times if they only take nanoseconds to execute, because the granularity isn't that great.
20:51:25 <ozataman> cputime seems to track only the cpu time used by the program... i want to record the actual time
20:51:29 <ozataman> should i just use data.time
20:51:39 <ozataman> and subtract the two recorded times?
20:51:41 <midfield> does anyone here have experience using the Control.Arrow.Transformer package?
20:52:36 <dolio> You can do that, too. But that won't necessarily tell you how long a function takes to execute, since it'll count time where your function got preempted for some other process to run, for example.
20:52:40 <dmwit> Did the suggestion for profiling just get dropped on the floor, or what?
20:52:58 <mauke> <ozataman> I dont want to profile... this will be a part of the program itself
20:53:13 <dmwit> Did my reading comprehension just get dropped on the floor, or what?
20:53:19 <dmwit> <- idiot
20:53:58 <ezyang> things that are not the same: dmwit, dimwit
20:54:13 <dmwit> thanks =)
20:54:41 <josephholsten> anyone know why macports says "ghc is not yet supported on Mac OS X 10.6.x (SnowLeopard)" ?
20:55:57 <dmwit> Is it possible that it's literally true?
21:11:37 <Cristiutu> ??
21:12:03 <MissPiggy> ??
21:12:12 <ezyang> ??
21:17:05 <dmwit> !?
21:18:21 <kfish> !!
21:21:50 <x33a> hello guys, can someone tell me how to disable sounds in xmonad
21:22:09 <dmwit> xmonad doesn't make any sounds
21:22:10 <ezyang> #xmonad might be better able to help you, but what you mean by "disable sounds"?
21:22:14 <ezyang> as in, access volume control?
21:22:24 <dmwit> http://dmwit.com/volume
21:22:27 <dmwit> You might like this. =)
21:23:10 <x33a> whenever i click something or cycle windows, it makes sound.
21:23:23 <dmwit> Okay. Let's definitely take this to #xmonad.
21:23:29 <x33a> ok thanks
21:36:37 <dons> x33a: via your system's volume control tool. it has nothing to do with xmonad.
21:39:28 <sinelaw> mornin'
21:39:42 <x33a> you mean alsamixer?
21:41:13 <x33a> i disable beep with alsamixer, still no effect.
21:48:58 <dmwit> Oh, this is too cool.
21:49:20 <dmwit> CSS has a property to label ordered lists with Greek, Armenian, or Georgian. =D
21:49:20 <dons> x33a: yeah, alsamixer. or check your terminal settings -- maybe you have an xterm bell or something enabled.
21:50:13 <dmwit> That seems like a hack, not a solution.
21:50:22 <dmwit> What if he wants sound, just not when he changes windows?
21:50:37 <dmwit> Anyway, it certainly isn't xmonad's fault, I agree with you there.
21:50:43 * ddarius recommends Barr and Wells ESSLLI lecture notes as a relatively gentle and enjoyable introduction to category theory.
21:51:08 <dmwit> ddarius: Thanks. I've followed along with some of the beginning of that, and I agree that they're pretty good lecture notes.
21:59:58 * bos grumbles
22:02:59 <Guest4960> hi, i'm trying to write a Forth interpreter in Haskell, and it's crashing somewhere (infinite loop)
22:03:06 <Guest4960> the code is here: http://pastebin.com/f533e785f
22:03:17 <Guest4960> i think it's getting stuck in getSym (ln 25)
22:03:20 <Guest4960> any ideas? :)
22:04:46 <dmwit> getSym looks fine to me
22:04:56 <dmwit> I don't suppose the "tab" you use there ever happens to be infinite...;?
22:05:34 <Guest4960> its possible
22:05:40 <Guest4960> why might that happen?
22:05:58 <Guest4960> i don't think i have any code to modify it yet in the monad
22:05:58 <dmwit> By the way, your Interp a type looks a lot like State (ForthStack, ForthSymTab) a.
22:06:00 <Guest4960> it just gets init from a list
22:06:07 <Guest4960> haha, i could believe it :)
22:06:17 <Guest4960> i'm learning monads, so this was kind of me trying to make my first monad
22:06:34 <dmwit> ?src State (>>=)
22:06:34 <lambdabot> Source not found. My mind is going. I can feel it.
22:06:39 <dmwit> ?src (>>=) State
22:06:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:06:43 <dmwit> hum
22:07:05 <dmwit> http://www.haskell.org/all_about_monads/html/statemonad.html
22:07:21 <Guest4960> ah, uesful, thanks
22:07:52 <Guest4960> any ideas for how the map could be infinite?
22:08:01 <dmwit> still reading
22:08:08 <Guest4960> ok, cool, thanks for the help :)
22:08:56 * ezyang is pretty convinced that the right way to write custom monads is through mechanisms like prompt 
22:09:18 <dmwit> :t mapM_
22:09:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:09:41 <dmwit> Guest4960: mapM_ can be more efficient than mapM if you're not going to use the result
22:09:58 <dmwit> Guest4960: e.g. parse makes a list and evalInterp throws it away
22:10:07 <Guest4960> cool, for the moment i wanted it to return the ending stack though
22:10:25 <dmwit> Guest4960: No reason it can't do that.
22:10:38 <Guest4960> with mapM_?
22:10:40 <dmwit> Guest4960: The difference is between taking an Interp [()] and taking an Interp ().
22:10:44 <dmwit> Guest4960: Yes, with mapM_.
22:10:55 <dmwit> Guest4960: All the effects still happen, it's just the computed value that's thrown away.
22:11:23 <dmwit> Guest4960: i.e. mapM_ is just throwing away something that evalInterp is *already* throwing away -- it just does it sooner (and therefore more efficiently).
22:11:29 <Guest4960> hm... ok, i'll give it a shot
22:12:23 <Guest4960> cool, still gets stuck but that does clean things up a bit, thanks
22:13:32 <dmwit> Everything else looks fine. Let's see if I can reproduce your loop here.
22:13:41 <Guest4960> sure
22:14:07 <dmwit> argh, it pasted the line numbers...
22:14:19 <Guest4960> lol :(
22:15:29 <ezyang> Could you repaste?
22:15:39 <Guest4960> sure:  http://www.haskell.org/all_about_monads/html/statemonad.html
22:15:43 <Guest4960> my bad
22:15:43 <Guest4960> one sec
22:15:55 <Guest4960> http://pastebin.com/f533e785f
22:16:09 <ezyang> er, that's the old paste; what about the cleaned up version?
22:16:14 <Guest4960> oh sure
22:16:15 <Guest4960> sorry
22:16:30 <Guest4960> here: http://pastebin.com/fd677bd0
22:16:43 <dmwit> What's a sample input that makes it loop?
22:16:46 <Guest4960> 2
22:17:01 <Guest4960> really anything other than an empty string i think
22:17:02 <Guest4960> at least here...
22:17:06 <Guest4960> is it working for you??
22:17:44 <ezyang> so, pass it 2 from stdin?
22:17:49 <Guest4960> yeah
22:18:13 <Guest4960> i can paste an old version without the map that actually runs
22:18:19 <Guest4960> so you can see how it's supposed to work
22:18:25 <Guest4960> its basically an rpn calc right now :P
22:18:53 <Guest4960> http://pastebin.com/f51882edf
22:19:06 <Guest4960> it still uses mapM, and a map too actually, the maps just not part of the monad
22:21:04 <dmwit> oh lol
22:21:15 <dmwit> let (r, s1, tab1) = f0 s0 tab1
22:21:20 <dmwit> That look funny to you? =)
22:21:38 <dmwit> This is why you should reuse State instead of implementing it yourself. =)
22:21:38 <Guest4960> oh........
22:21:40 <Guest4960> wow
22:21:46 <Guest4960> but its more fun this way :)
22:21:50 <Guest4960> thanks a lot though
22:21:51 <Guest4960> raelly
22:21:53 <ezyang> eehee, yay redefine tab1
22:22:18 <Guest4960> wow
22:22:25 * ezyang would not have noticed that 
22:22:25 <Guest4960> you have no idea how long ive spent on this :P
22:22:26 <Guest4960> hahah
22:22:37 <ezyang> dmwit: What was your debugging strategy?
22:22:49 <dmwit> *poke*
22:22:58 <ezyang> I admit that debugging Haskell code is still a little mysterious to me, when it doesn't work.
22:23:13 <MissPiggy> the way I debug is I just read each line carefully
22:23:15 <dmwit> You want a transcript of my ghci experience?
22:23:19 <ezyang> Sure!
22:23:23 <Guest4960> thatd be cool
22:23:31 <tensorpudding> the error messages in GHC can be daunting, but they're a lot less unreasonable than GCC oftentimes
22:23:33 <jmcarthur> i debug by rewriting in smaller more composable pieces
22:23:49 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20363#a20363
22:24:28 <dmwit> It was the (evalInterp (push 2 >> return [])) line that really tipped me off.
22:24:44 <ezyang> mmmm
22:24:52 <jmcarthur> my reasoning is that if i can't find the bug by just looking at it then i obviously wrote bad code and it needs to be made less complex
22:25:08 <ezyang> jmcarthur: Hehe. A philosophy made to aspire to.
22:25:21 <ezyang> I'll try that on my next debugging session.
22:25:21 <Guest4960> interesting
22:25:35 <MissPiggy> I am with jmcarthur
22:26:06 <ezyang> So, was Interp supposed to be a homebrew state monad or something?
22:26:16 <Guest4960> basically, yeah
22:26:24 <Guest4960> a learning experience :)
22:26:24 * QC_OK_ pats himself on the back
22:26:26 <dmwit> I mean, if (evalInterp (push 2 >> return [])) works, but (evalInterp (push 2 >>= \() -> return [()])) doesn't work, there's only so many places the bug can be hiding. =)
22:26:29 <QC_OK_> I understand about half of the common usages of Haskell.
22:26:50 <QC_OK_> :D
22:27:00 <jmcarthur> QC_OK_: bull :P
22:27:10 <MissPiggy> half??
22:27:11 <QC_OK_> Oh well
22:27:14 <QC_OK_> back to learning
22:27:42 <jmcarthur> i understand about 0.0001% of the common usages of haskell
22:28:03 <ezyang> I suppose it depends on what you mean by common...
22:28:03 <jmcarthur> if that
22:28:07 <Guest4960> are any usages of haskell "common"?
22:28:15 <jmcarthur> ezyang: also what is meant by "understand"
22:28:22 <tensorpudding> what is meant by haskell :P
22:28:24 <ezyang> indeed
22:28:33 <dmwit> What is "meant"?
22:28:36 <ezyang> haskell is a very difficult man to understand
22:28:43 <tensorpudding> depends on what your definition of "is" is
22:28:48 <Guest4960> seeing as he's dead and all... id agree
22:28:55 <ddarius> Corpses don't enunciate well.
22:28:58 <Guest4960> requires great psychic strength
22:29:04 <Guest4960> and currying
22:29:08 <tensorpudding> haskell curry is broadcasting psychic waves?
22:29:09 <jmcarthur> ddarius: that's why they are easier to understand than the living
22:29:15 <Guest4960> partially
22:29:21 <tensorpudding> can i pick them up on my radio?
22:29:32 <Guest4960> maybe, but they're kinda lazy
22:29:38 <tensorpudding> you could have a channel for dead logicians
22:29:39 <Guest4960> so they may not actually ever evaluate for you
22:29:39 <dmwit> > id agree
22:29:40 <lambdabot>   agree
22:29:46 <dmwit> lambdabot would agree, too
22:29:49 <jmcarthur> corpses are declarative. they don't do anything. they just are
22:33:52 <ezyang> > agree
22:33:53 <lambdabot>   agree
22:33:57 <ezyang> hmmm
22:34:04 <dmwit> hint:
22:34:05 <ezyang> :t agree
22:34:05 <dmwit> > x
22:34:06 <lambdabot> Expr
22:34:06 <lambdabot>   x
22:34:31 <tensorpudding> > x^2
22:34:32 <lambdabot>   x * x
22:34:47 <tensorpudding> > x^2 + x + 5 == 0
22:34:48 <lambdabot>   False
22:34:55 <tensorpudding> ohnoes
22:34:59 <dmwit> > 0 == (0 :: Expr)
22:35:00 <lambdabot>   True
22:35:07 <dmwit> well
22:35:10 <dmwit> That was unexpected.
22:35:11 <tensorpudding> mathmatics is o'erthrown
22:35:15 <dmwit> > x == x
22:35:16 <lambdabot>   True
22:35:17 <dmwit> huh
22:35:21 <dmwit> > x + x == 2 * x
22:35:22 <lambdabot>   False
22:35:35 <dmwit> whew
22:35:41 <dmwit> I was going to be upset if it was so magical!
22:44:29 <jmcarthur> defaulting
22:44:55 <dmwit> kill it with fire
22:45:01 <dmwit> take the MR out while you're at it
22:45:14 <jmcarthur> yeah we're on the same page
22:56:02 <kmc> nice
23:23:02 <Hunner> :t intersperse
23:23:03 <lambdabot> forall a. a -> [a] -> [a]
23:23:49 <Hunner> is intersperse not in 6.12? I don't have it
23:24:24 <dmwit> Data.List
23:24:39 <tensorpudding> you need to import Data.List
23:24:42 <Hunner> ah, my ghci lost its loaded modules
23:24:47 <dmwit> You can find out what module to import on your own with one of these two commands:
23:24:50 <dmwit> ?index intersperse
23:24:51 <lambdabot> Data.List
23:24:53 <dmwit> ?hoogle intersperse
23:24:54 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
23:24:54 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
23:24:54 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
23:25:19 <Hunner> dmwit: yeah. I had Data.List imported... then had a new session and it wasn't
23:45:11 <Hunner> Is there a way to define overlapping instances of show if they are substitution instances?
23:46:03 <Hunner> my 'instance Show [[MyType]]' overlaps with 'instance (Show a) => Show [a]'
23:47:11 <Gracenotes> I take it MyType is an instance of Show
23:48:19 <Hunner> yep. I have an 'instance Show MyType' defined as well
23:49:25 <dmwit> Well, you could turn on OverlappingInstances.
23:53:12 <Twey> Hunner: Or you could newtype it.
23:53:30 <Hunner> the pragma didn't help. looking into newtype
23:53:40 * ezyang incoherently mumbles something 
23:59:34 <Hunner> Twey: my data uses the | syntax to define multible constructors apparently, which isn't allowed with newtype
23:59:53 <Twey> Hunner: What?
23:59:59 <Twey> You have multiple constructors for [[MyType]]?
