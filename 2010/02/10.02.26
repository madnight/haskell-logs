00:00:31 <sinelaw> also, i need to somehow do the pointer-releasing-when-garbage-collection
00:01:50 <nus> ski, my fault, misread extract as extend
00:02:12 <ski> @kind Data.Graph.Inductive.Graph.Gr
00:02:13 <lambdabot> Couldn't find qualified module.
00:02:49 <ski> is `Gr' an existing type in the library you're importing ?
00:03:24 <tomberek> yeah.. it's of kind *->*->* from the fgl package
00:03:36 * ski idly wonders what bindings sinelaw wants to create ..
00:03:48 <ski> and you want to define a type `NN' ?
00:04:25 <sinelaw> ski, OpenCV
00:04:37 <sinelaw> ski, http://i.imgur.com/dyNvn.jpg
00:04:56 <ski> sinelaw : in my meagre knowledge, the best way to parse a header file is to use a C compiler ..
00:05:55 <ski> (i.e., if you want to extract some system-dependent information out from known identifiers in it, write (or better, generate) a small C program that prints that information to `stdout')
00:06:20 * theorbtwo recently wrote a program that extracts type information from the debugging output of a compiler.
00:06:21 <ski> (otoh, maybe you're wanting to somehow discover what interface a header file provides ..)
00:06:37 <sinelaw> c2hs supposedly knows how to do this and create bindings
00:06:42 <sinelaw> i just can't figure out how
00:07:12 <theorbtwo> Means you don't have to parse the header to discover what's in it and then do it again to figure out the sizes, and means that you are gaurenteed to produce *actual correct* data.
00:07:25 <tomberek> @kind Data.Graph.Inductive.PatriciaTree.Gr
00:07:26 <lambdabot> Couldn't find qualified module.
00:07:51 <ski> probably the package those are in is not accessible to lambdabot
00:07:57 <theorbtwo> If you parse the header by hand to find sizes, you risk not intepreting all the things that C leaves up to the compiler the same way.
00:08:19 <ski> *nod*, asking a debugger could work, too
00:08:48 <chrisdone> isn't C delightful
00:08:51 <ski> (parsing by hand is not recommended)
00:09:01 <sinelaw> i just want it to translate: int blabla(int x) into: {#fun blabla ^ ..... #} <---- c2hs syntax
00:09:06 <theorbtwo> It wasn't even that hard.  Admittedly, that's because I started with dumpdwarf, which does the binary format parsing, and then parsed it's output.
00:09:12 <sinelaw> right now i'm doing that by hand
00:09:25 <tomberek> ski: yes,, NN
00:09:41 <theorbtwo> Also, I used techniques that don't mix overly well with haskell, so far as I know.
00:09:54 <theorbtwo> You can have my code if you like, but I'll warn you that it's Perl.
00:09:58 <tomberek> ski: so i can go from NN (Neuron a b) -> Neuron a b  via extract
00:10:00 <ski> tomberek : so then the `Neuron' in `data NN Neuron a b = ..a..b..' is misplaced
00:10:20 <tomberek> yes,, i know it's wrong, i just don't know what is right
00:10:22 <ski> tomberek : maybe you actually wanted `data NN a = ..a..'
00:10:29 <ski> or maybe `data NN a b = ..a..b..' ?
00:10:32 <theorbtwo> It's also tied to DWARF, which means not win32.
00:10:51 <sinelaw> argh perl
00:11:00 <sinelaw> argh win32
00:11:04 <sinelaw> argh argh
00:11:13 <tomberek> ski.. won't NN a b become just "a b" when unwrapped?
00:11:26 <ski> if you want one instance of `extract' to be `NN (Neuron a b) -> Neuron a b' (assuming `NN' is a comonad), then you need `data NN a = ..a..'
00:11:28 <theorbtwo> sinelaw: Even if you rewrite it in Haskell, it's probably a useful place to start.
00:11:36 <ski> tomberek : no
00:11:53 <ski> tomberek : `NN a b' would be short for `(NN a) b', not `NN (a b)'
00:12:02 <sinelaw> theorbtwo, it's a lot more complicated than what i need
00:12:08 <sinelaw> right now
00:12:11 <tomberek> ski... ok... "data NN a" it is... i'll try to fiddle for a bit
00:12:25 <theorbtwo> sinelaw: I think, perhaps, you underestimate what you need.
00:12:45 <sinelaw> maybe
00:12:51 <ski> tomberek : but .. i'm doubting you really want to use comonads .. at least, i think you should first define the type you want, and some operations on it .. then it might turn out that some of those operations are (or can be cast as) the comonadic operations
00:12:55 <tumult> ok so who is going to hold my hand and walk me through fixing my first space leak? :]
00:12:58 <tumult> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23017
00:13:16 <sinelaw> @vixen
00:13:16 <lambdabot> Yeah
00:13:28 <Alpounet> hi
00:13:30 <tomberek> ski: NN is comonads, i already got them working using typeclasses
00:13:40 <ski> tomberek:
00:13:42 <tomberek> hi Alpounet, i'm trying to get this working right
00:13:49 <Alpounet> :)
00:13:50 <sinelaw> the only real issue I have, is how to wrap the image transform functions purely
00:13:53 <tomberek> but running into type issues
00:13:59 <ski> you can't have get `NN' working as a comonad, if you haven't even defined the `NN' type, yet
00:14:05 <sinelaw> because they accept two pointers, one for input and one pre-allocated for output
00:14:44 <tomberek> ski: in another version of what i am working on, Dendrite and Axon are typeclasses and I got it to work.
00:14:45 <ski> first define your type. then (maybe) make it an instance of `Comonad'
00:14:49 <sinelaw> i though of managing a memory pool in my lib or something. but i still need to garbage collect
00:14:57 <sinelaw> when haskell does
00:15:13 * ski wonders why anyone would make type classes out of `Dendrite' and `Axon'
00:15:29 <tomberek> ski: because i'm learning and i'm new to this
00:15:45 <sinelaw> neuron modelling?
00:16:06 <ski> you should learn what type classes are for (since it appears to me that you haven't really done that, yet)
00:16:26 <jrockway> the keyword says "class", so it must be exactly like java!
00:16:34 <tumult> maybe i should ask a more general question. if i have a series of right folds to transform a bunch of bits in a list and then write them back out to a file, is there something i need to do to avoid space leaks?
00:16:44 <tumult> by 'a bunch' i mean like a few megabytes
00:16:45 <tomberek> ski: i thought that i could make interesting instances of Neurons and play with it that way... yes, you are correct, and I slowly am learning
00:17:18 <ski> type classes are for abstracting out a common interface to several types, so that you can write some generic operations over any of those types, which will eventually call out to the type-specific parts defined by each instance of the type class
00:17:51 <ski> if you aren't making more than one instance of a type class, then you probably don't need to make a type class at all
00:18:08 <tomberek> ski: the idea was that different types of Neurons need a common interface
00:18:24 <ski> ok
00:18:37 <chipmonkpyro> can someone explain why this works as an alternate version of map?
00:18:39 <chipmonkpyro> map' :: (a -> b) -> [a] -> [b]
00:18:40 <chipmonkpyro> map' f xs = foldr g [] xs
00:18:42 <chipmonkpyro>     where g x r = f x:r
00:18:48 <ski> in the paste i only saw one kind of neuron
00:18:52 <tomberek> ski: so NeuronSig NeuronMax NeuronLinear NeuronWhatever
00:19:25 <tomberek> ski: starting back from scratch because with the typeclass, each net can only have a single type of neuron, no mix and match, (unless I wrap, etc)
00:19:29 <sinelaw> jrockway, http://jayrock.berlios.de/
00:19:38 <sinelaw> are you relatives?
00:19:43 <ski> chipmonkpyro : you could try evaluating it, step-by-step, on some small example
00:19:43 <sinelaw> :P
00:19:57 <jrockway> a .net project in my honor, how ironic
00:20:24 <tumult> no takers for helping me with space leak? :[
00:20:30 <ski> tomberek : do you want to be able to mis and match different kinds of neurons in the same network ?
00:20:46 <ski> s/mis/mix/
00:20:49 <tomberek> chipmonkeypyro: g simply applies a function f to the inputs and adds it to the front of a list
00:21:07 <tomberek> ski: yes,, that was why I abandonded the typeclass approach
00:21:14 <ski> tomberek : also, do you want/need to be able to add new kinds of neurons, without changing a generic `Neuron' data type ?
00:22:08 <ski> so, re the first question : i think you either want a generic `Neuron' data type, with cases for the different kinds of neurons; or you want to use an "existential" data type
00:22:30 <tomberek> ski: not sure what you mean by the second part,, but yes, I want it to be relatively easy for people to define new ones:: ie: instance Neuron NeuronSig where afunc=sigmoid, cFunc=sum
00:22:40 <ski> i.e. an "existential" data type, together with *keeping* the type class, and the separate neuron types
00:23:03 <ski> ok, look into the existential data types, then
00:23:38 <ski>   data AnyNeuron = forall n. Neuron n => WrapNeuron n
00:23:40 <tomberek> that's something like data NN a = forall b. NN blah blah
00:24:03 <ski> could be an example of a datatype wrapping any kind of neuron datatype
00:24:20 <tomberek> so I need to wrap them?  I was hoping to avoid that sort of thing.
00:24:31 <ski> so, if you put `AnyNeuron's in your network, you can mix and match different kinds of neurons
00:24:45 <ski> you do need to wrap them, yes
00:24:58 <ski> (no first-class existentials in Haskell .. yet, anyway)
00:25:08 <tomberek> arg
00:25:37 <dolio> UHC has them, but amusingly enough, you can't use them with type classes.
00:26:03 <ski> though if you have some kind of "add" function, you can probably let that wrap them for you
00:26:44 <tomberek> can you clarify that last statement?
00:26:47 <ski> dolio : does it have `forall a. F a -> exists b. G a b' or only `forall a. (exists b. G a b) -> F a' ?
00:27:07 <ski> i'm not sure how you're constructing your networks .. but
00:27:20 <ski> consider something like
00:27:24 <ski> @type (:)
00:27:25 <lambdabot> forall a. a -> [a] -> [a]
00:27:26 <ski> for lists
00:27:34 <ski> instead of having
00:27:37 <dolio> Presumably it has both, and any other rank-n type you can come up with.
00:27:49 <ski>   add :: AnyNeuron -> NN -> NN
00:27:51 <ski> you could have
00:27:58 <ski>   add :: Neuron n => n -> NN -> NN
00:28:05 <ski> letting `add' wrap for you
00:28:28 <ski> (i don't think you construct networks by just adding like this .. but the same idea may (or may not) apply)
00:28:33 <tomberek> yeah, I understand wrapping,,, that would make Neuron a typeclass that wraps them
00:29:10 <ski> dolio : istr some implementation (jhc ?) allowing `exists' on the left of `->' .. which doesn't really buy much
00:29:33 <dolio> Yeah. That's the more boring side.
00:30:18 <tomberek> like I said, i've usually viewed wrapping as a design flaw farther up the road... Is that not correct in Haskell?
00:30:52 <ski> hm, istr someone pointing out ambiguity problems with mixing existentials in the return type and type classes
00:31:05 <ski> but possibly it could be allowed with explicit type signatures, at least
00:31:08 <theorbtwo> I don't think so, but I'm a clueless noob.
00:32:04 <theorbtwo> That is, where in a dynamic language you might simply allow any type and then deal with it in the body of your function, in Haskell you create a type that has constructors to go with each of the types you want to take, or you create a typeclass.
00:32:12 <ski> (btw, it's not the type class `Neuron' that wraps .. it is the constructor `WrapNeuron' of the (existential) data type `AnyNeuron' that wraps)
00:32:30 <theorbtwo> If you are considering both of those wrapping, then wrapping is a completely reasonable thing to do.
00:32:52 <theorbtwo> The typeclass seems like the better way to me, but again, I don't have much basis for saying that.
00:33:25 <ski> in a dynamic language, "deal with it in the body" would usually either be (a) handling it parametrically; (b) using some generic interface that tells how to handle the data
00:33:41 <tumult> ok question: if i have a 4-million element long list of Int16s made from right folds (and i can get length on it without breaking the stack), what's the best way to write it to a file?
00:34:06 <ski> the (a) in Haskell corresponding to the usual parametric polymorphism; while the (b) corresponding to typeclasses (possibly with existentials)
00:34:21 <tomberek> ski: can you add the beginings of those declarations (left hand side) to that post? That's where i get most of my problems.
00:34:40 <ski> (there's also an option of examining the run-time tag of a value, and dispatch explicitly to a few cases)
00:35:37 <ski> but, yes, it is somewhat bothersome to have to explicitly write the wrapping constructor of the existential type .. hence i'd like to see some more support for first-class existentials
00:35:57 <ski> tomberek : which declarations ?
00:36:45 <sinelaw> about ForeignPtr finalizers: "Indeed, there is no guarantee that the finalizer is executed at all; a program may exit with finalizers outstanding. (This is true of GHC, other implementations may give stronger guarantees). "
00:36:47 <tomberek> i still get mixed up between data, type, newtype, class and the proper way to use them... I understand them in the simple cases... I just haven't developed the right intuition yet.
00:36:50 * hackagebot glpk-hs 0.0.1 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.0.1 (LouisWasserman)
00:37:36 <sinelaw> no guarantee on finalization - that sucks :(
00:38:33 <ski> tomberek : is the `Neuron' you've defined in that paste only one of the different kinds of neurons ?
00:40:05 <tomberek> well,, in this version, the different types of Neurons will simply be made up of Dendrites and Axons with different parameters...  My older version of this had those as typeclasses, where yes, there were different types of Neurons.  NeuronSigmoid,NeuronThreshold,NeuronWhatever
00:40:08 <theorbtwo> sinelaw: OTOH, it makes some sense -- no use explicitly freeing every piece of memory when the OS will do it for you when you kill the process.
00:40:16 <MaciejP> In Parsec, is there a difference between `try $ many p' and `many $ try p'?
00:40:25 <sinelaw> theorbtwo, space leaks.....
00:41:01 <theorbtwo> sinelaw: Not neccessarly.
00:41:36 <theorbtwo> Things that get stuck in a global, or near-global, that need to be hung on to until after the (user) process exits.
00:41:43 <dolio> MaciejP: Yes, I think so.
00:42:44 <dolio> Actually, it may turn out that there's no difference, but it's not immediately clear.
00:43:26 <MaciejP> So the first is more likely what I want?
00:44:29 <dolio> Wow, the implementation of many is really complicated.
00:44:49 <dolio> many (try p) may be identical to many p.
00:44:50 <tomberek> ski: and i also want to be able to eventually add new Neurons that are perhaps streams, or ones that pass functions, not values
00:45:04 <dolio> And try (many p) may also be identical to many p.
00:45:33 <dolio> It's hard to tell, though.
00:45:34 <dobie_gillis> i need a second pair of eyes here with `do' syntax: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23019#a23019
00:47:10 <theorbtwo> Hm.  I think it depends.  If you assume that p can eat data, but not succeed, then I think you need the try on the inside.
00:47:18 <theorbtwo> The try on the outside should never be useful.
00:47:24 <dolio> MaciejP: Anyhow, the fact that 'many' tries to parse 0 or more of its argument means it has to have some degree of backtracking.
00:47:37 <theorbtwo> OTOH, that's going mostly fro the documentation, not the implementation.
00:47:58 <jrockway> i really also love how HTTP and http-server have different request/response types
00:48:07 <jrockway> why make those the same when they could be different instead!
00:48:07 <dolio> So I guess I revise my original statement. They're probably the same, and the same as many p.
00:49:10 <Saizan> i think many p = (liftM2 (:) p (many p)) <|> return [], so many (try p) is not the same as many p for all p.
00:49:34 <ski> tomberek : mhm. maybe you can do with a single `Neuron' type, just with different configurations of `Dendrite' and `Axon' in them .. or maybe you really want several types .. it is not clear to me
00:50:06 <dolio> Saizan: That's not how it's defined in parsec. It's a gigantic function that mucks around explicitly with the internals.
00:50:16 <Saizan> ugh
00:50:17 <tomberek> me neither,, that is why I ask... thanks for your help though. I'm re-reading about existential types.
00:50:28 <dolio> If we're talking about the many from Control.Applicative, then yes.
00:50:47 <Axman6> Saizan: it's many1 p, not many p inside the function
00:50:55 <Axman6> or, maybe not
00:51:13 <Axman6> anyway, i've always defined many and many1 in terms of each other
00:52:19 <MaciejP> I also think many with and without try makes a difference
00:52:32 <dolio> Well, that simple definition makes sense if you're making a parser with arbitrary backtracking. In parsec, though, it'd probably lead to some weird behavior if you didn't have the equivalent of a try in there somewhere.
00:52:35 <ski> dobie_gillis : the `when' and following lines are indented one space too much
00:54:21 <dolio> Like, if p = string "foo", and you try to parse "foofoofo" with many p, I think it might be an error.
00:56:45 <MaciejP> dolio: Indeed it is.
00:56:49 <sinelaw> err
00:57:25 <dolio> Oh, even the parsec one fails on that?
00:57:33 <sinelaw> can i tell haskell's ffi that several objects depend on another being present in memory?
00:57:33 <dolio> It does.
00:57:51 <dolio> In that case, many is different than many (try p) and try (many p).
00:58:02 <dolio> And those two are different from each other.
00:58:06 <sinelaw> example, i have a camera object, that creates images that are statically buffered inside the camera object. when C frees the camera, those images become invalid
00:58:20 <sinelaw> so haskell shouldn't free the camera until no more references to any of the images
00:58:56 <tomberek> ski: GADTs? would that be on the right track?
00:59:50 <dobie_gillis> ski: thanks.. i'm still getting the same error with your suggestion, though  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23019#a23020
00:59:51 <ski> tomberek : it didn't sound to me that you needed GADTs (though some find the GADT way of expressing an existential data type nicer)
01:00:36 <tomberek> ski: well, i want to learn them too eventually.. and the docs say that GADTs encompass existential types
01:00:52 <ski> dobie_gillis : i said *one* space too much .. not four spaces too much
01:01:07 <ski> dobie_gillis : the `when' should align with the `translate'
01:01:16 <dolio> MaciejP: So, 'many (try p)' will collect as many ps as possible, and will be well behaved even if there is a partial match for p at the end.
01:01:19 <ski> tomberek : they do .. and more
01:01:28 <dobie_gillis> ski: ohh okay. i'm using tabs so i interpreted that wrong :/
01:01:56 <ski> it is mostly recommended to not use tabs for indentation in haskell
01:02:16 <dolio> MaciejP: 'many p' will do the same thing, but will only succeed if p fails immediately at the end (which is what the try accomplishes).
01:02:28 <fasta> Is there a horrible hack to write get_non_bottoms, s.t. get_non_bottoms ([1,2] ++ undefined) returns [1,2]?
01:02:44 <dolio> And 'try (many p)' will behave like 'many p', but will appear to have not matched in the case of failure.
01:02:44 <ski> (if you do, then you have to make measures that you don't fall into this trap, by having a new-line after `do',`where',&c.)
01:03:14 <tomberek> A lot of these extensions like GADTs, GeneralizedNewtypeDeriving, MultiParameterTypeclasses, Existentialtypes are being discussed for the next version of Haskell... is that coming soon?
01:03:23 <dolio> fasta: There is if it's actually undefined, and not an infinite loop.
01:03:36 <fasta> dolio, it is undefined or an exception.
01:04:02 <MaciejP> dolio: Ok, thanks!
01:04:05 <fasta> dolio, I already use spoon, but that only works for the [1,2,3] ++ [undefined] case.
01:04:19 <dolio> fasta: Then you can catch the exception with evaluate, some kind of catch, and unsafePerformIO.
01:04:46 <fasta> dolio, I can write my own version of ++ to solve it, but the question was whether it is possible without doing that.
01:04:47 * ski wonders why fasta would want to do this grisly thing ..
01:05:27 <fasta> ski, otherwise I have to manually figure out how many useful events are being generated before it crashes for every test case.
01:05:47 <fasta> ski, or you know, rewrite the algorithm to use MonadError instead of calling error.
01:05:48 <dolio> Well, if you're using spoon, presumably it's something like "f l = case spoon l of Nothing -> [] ; Just [] -> [] ; Just (x:xs) -> x : f xs".
01:05:56 <tomberek> ski: thanks again, I'll give these things a shot.
01:07:33 <dolio> Oh, actually, that's probalby not right.
01:07:37 <dolio> It'd need to be teaspoon.
01:08:18 <fasta> dolio, that is only if you are interested in preserving  a lot of laziness.
01:08:36 <fasta> dolio, anyway, I will just do it manually for now.
01:08:59 <dolio> Yeah, but if you use spoon on ([1,2,3] ++ undefined) it'll just produce Nothing, won't it?
01:09:21 <fasta> dolio, ah, in fact, I know how to do it automatically.
01:09:44 <fasta> dolio, I can simply first try take 1, then take 2 and so on, until I get something which is Nothing.
01:09:56 <fasta> dolio, then I know it must have been the previous answer.
01:10:43 <dolio> Yes, that also works.
01:11:08 <dolio> nonbottoms ([1,2,3] ++ undefined) ==> [1,2,3]
01:11:16 <dolio> nonbottoms l = case teaspoon l of Just (x:xs) -> x : nonbottoms xs ; _ -> []
01:11:53 <fasta> dolio, ah, that's better.
01:12:20 <dolio> You should probably call spoon on x, too, I guess, if you want to get rid of the undefined in "[1,2,3] ++ [undefined]".
01:16:24 <ablmf> How to get infinite decimal representation of 1/3?  I mean, something like this [0, 3, 3 ..]
01:16:37 <ablmf>  floatToDigits 10 (1/3) only give ([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3],0)
01:17:41 <fasta> ablmf, show (1/3::CReal)?
01:18:09 <fasta> ablmf, check Hayoo for the package you need to get that.
01:18:27 <tomberek> ski: using GADTs, this seems to encapsulate what I want..  does it seem correct? data NN n where {NN :: (Gr (Axon a) (Dendrite a b)) -> NN (Neuron a b)}
01:18:33 <fasta> ablmf, or if you just need 1/3, just 0:repeat 3
01:19:02 <ablmf> fasta: 1/3 is just an example
01:19:25 <ablmf> I am solve a problem related to decimal representation of 1/2, 1/3 .. 1/1000
01:19:39 <fasta> ablmf, well, then use the first solution.
01:19:46 * sinelaw begins work on his book "The 7 bad habits of highly ineffective people"
01:20:07 <sinelaw> 1. lazy evaluation
01:20:52 <ski> tomberek : .. maybe ?
01:20:52 <ablmf> fasta: Is it in Data.Number.CReal ?
01:21:03 <ski> tomberek: it depends on what you really want
01:21:05 <fasta> ablmf, yes
01:21:11 <tomberek> lol... i'll play with it... thanks for the help
01:21:16 <nus> tomberek, did your Neuron type change from the pasted one?
01:21:24 <tomberek> no
01:21:36 <sinelaw> @hoogle ForeignPtr a -> a
01:21:37 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
01:21:37 <lambdabot> Prelude id :: a -> a
01:21:37 <lambdabot> Data.Function id :: a -> a
01:21:41 <sinelaw> ooh
01:21:43 <nus> tomberek, then your NN is not a collection of Neurons.
01:21:52 <nus> tomberek, you miss Node.
01:21:55 <tomberek> erg??
01:22:07 <nus> tomberek, and structure.
01:22:17 <tomberek> The Gr has Nodes in there, and structure.
01:23:05 <tomberek> nodes :: Graph gr => gr a b -> [Node]
01:26:42 <MaciejP> Another Parsec question, I need to parse `manyTill p t' but without consuming t.
01:28:36 <chipmonkpyro> trying to find an alternate definition for filter using this form:
01:28:38 <chipmonkpyro> filter' p xs = foldr g [] xs
01:28:40 <chipmonkpyro>     where g x r
01:28:41 <chipmonkpyro>              | __________ = ____________
01:28:43 <chipmonkpyro>              | otherwise = ________
01:28:43 <sinelaw> argg. opencv consumes 100% cpu just getting frames from my camera.
01:29:06 <chipmonkpyro> tried this but it isnt working:
01:29:09 <chipmonkpyro> filter' p xs = foldr g [] xs
01:29:11 <chipmonkpyro>     where g x r
01:29:11 <Axman6> chipmonkpyro: sounds like homework to me
01:29:13 <chipmonkpyro>              | p r = r
01:29:14 <chipmonkpyro>              | otherwise = []
01:29:17 <chipmonkpyro> it is :)
01:29:20 <chipmonkpyro> im stuck :(
01:29:24 <Axman6> well, have fun ;)
01:29:41 <chipmonkpyro> what would cause this message?
01:29:44 <chipmonkpyro> Occurs check: cannot construct the infinite type: a = [a]
01:29:46 <chipmonkpyro>     When generalising the type(s) for `filter''
01:29:54 <Axman6> well, it's wrong :P
01:30:09 <Axman6> first, figure out what the type of g must be
01:31:25 <Axman6> :t foldr
01:31:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:31:49 <Axman6> :t foldr ?g [] []
01:31:50 <lambdabot> forall a a1. (?g::a -> [a1] -> [a1]) => [a1]
01:31:57 <chipmonkpyro> (a -> b -> b)?
01:32:11 <Axman6> more specific than that. luckily, lambdabot just told you >_>
01:32:33 <chipmonkpyro> i dont understand what he typed :(
01:32:35 <Axman6> :t foldr ?g ([]:: [a]) ([] :: [a])
01:32:36 <lambdabot> forall a a1. (?g::a -> [a1] -> [a1]) => [a1]
01:32:42 <Axman6> urgh
01:32:56 <Axman6> anyway, the type needs to be g :: a -> [a] -> [a]
01:33:08 <chipmonkpyro> oh ok
01:33:27 <Axman6> so, write that down in the where block, above the beginning of the definition
01:33:28 <nus> tomberek, yes, and your NN is a collection of Nodes and Neurons, whatever that means.
01:33:39 <chipmonkpyro> well isnt r a list?
01:33:44 <Axman6> it sure is
01:34:11 <tomberek> nus: sounds right to me,, or am I missing something?
01:34:24 <Axman6> chipmonkpyro: now, what's the type of p?
01:34:26 <chipmonkpyro> well im trying to say if the element passes g r then just spit it back out but if it doesnt pump out an empty element
01:34:35 <Axman6> are you sure it's g r?
01:34:55 <chipmonkpyro> p is bool right?
01:35:08 <ski> @type undefined `asTypeIn` \g -> foldr g ([]:: [a]) ([] :: [a])
01:35:09 <lambdabot> forall a a1. a -> [a1] -> [a1]
01:35:12 <fasta> tomberek, are you a student?
01:35:12 <Axman6> no, it's a function, which when applied to an a, returns a bool
01:35:29 <chipmonkpyro> ohhh
01:35:32 <tomberek> no, but i'm trying to learn Haskell as a hobby... why?
01:35:33 <chipmonkpyro> that makes sense i suppose
01:35:33 <Axman6> p :: a -> Bool
01:35:41 <nus> tomberek, a Node is a (sub)part of a Neutron, then in NN it becomes equal to a Neuron?
01:35:56 <Axman6> it's called a predicate, and it's what decides which elements make it into the result list, right?
01:36:24 <fasta> tomberek, if you actually want to learn Haskell, you can better read a few books on the subject and then start your toy projects.
01:36:36 <tomberek> nus: No, a Graph (the Gr) stores them.
01:36:59 <Axman6> chipmonkpyro: it's best to think of g as a smart version of (:)
01:37:04 <Axman6> :t (:)
01:37:05 <lambdabot> forall a. a -> [a] -> [a]
01:37:17 <tomberek> fasta: actually, the books are on their way.  Go snail mail!
01:37:20 <chipmonkpyro> of ::?
01:37:21 <nus> tomberek, decide if your Neurons have an identity or not.
01:37:31 <Axman6> chipmonkpyro: no, (:), the list constructor
01:37:34 <chipmonkpyro> oh
01:37:35 <Axman6> > a:[]
01:37:36 <lambdabot>   [a]
01:37:41 <fasta> tomberek, ok, very good. I haven't said a thing.
01:37:56 <tomberek> using Node (it's just type Node = Int) you can retrieve a Neuron
01:37:57 <Axman6> so, (:) takes an a, a list of a's, and returns a list of a's, right?
01:38:57 <tomberek> nus: i believe it's implemented as an IntMap (FiniteMap in the other implementation of Gr)
01:40:47 <tomberek> fasta: toy projects help me learn.  I've gone through enough tutorials, I want to get my hands dirty.
01:41:03 <fasta> tomberek, tutorials are a bad way to learn Haskell.
01:41:36 <nus> tomberek, your NN (as you define it now) is a destruction of Neuron, not a collection of them.
01:42:02 <tomberek> fasta: i've slowly come to realize that... i also have a book on category theory coming... from the talk on this channel, that seems like required reading.
01:42:28 <fasta> tomberek, category theory is not required reading, imho.
01:42:30 <tensorpudding> category theory is not required to write haskell
01:42:30 <tomberek> nus: ok.... what would you suggest?
01:44:11 <tomberek> next time someone on here talks about isomorphic duals to the monoid over the category of endofunctors... i'll tell them you said that. hehe
01:44:59 <fasta> tomberek, imho, it is about the algorithms they write and rarely are there functional programming algorithms which actually compute something interesting in a faster way than before which require those terms.
01:45:37 <fasta> tomberek, those people studied topology, so, that's the language they think in. That doesn't mean it is a good thing.
01:45:50 <tomberek> fasta: yes, i've wondered about the complicated structures and type hackery that they do, and if there are any efficiency gains by it.
01:46:05 <Philippa> usually the gain is in genericity instead
01:46:14 <fasta> tomberek, you can be sure that some of their ideas are useful.
01:46:49 <Axman6> ok, so, am i the only one who does things on monady?
01:46:55 <tomberek> fasta: then that should be reason enough, and speaking of which... they claim that reasoning about their code is easier in those terms... i tend to believe them
01:47:04 <fasta> tomberek, but you don't have to know everything. For example the zylomorphisms or whatever they are called are not important on a day by day basis. Catamorphisms are, but normal people call those folds.
01:47:45 <tomberek> fasta: got it.. that's why i got the Category Theory (for computer scientists)
01:47:51 <fasta> tomberek, since there doesn't exist an interactive theorem prover for Haskell, I find those claims not grounded in reality. What does help is knowing basic mathematical objects.
01:48:03 <Adamant> tomberek: how many engineers really use the full extent of set theory, even?
01:48:09 <fasta> tomberek, and basic relations like commutative operators, and so on.
01:48:32 <tomberek> engineers,,, i'd say none.. perhaps one or two, but those guys do very little of what you'd consider classical engineering
01:48:48 <Adamant> category theory is for a lot of people a whole new level of abstraction
01:49:07 <Adamant> beyond the abstractions of set theory, in terms of practical understanding
01:49:32 <Adamant> I think both are awesome to understand if you have the time and patience
01:49:38 <tomberek> Adamant: yes, i did a lot of math, but it's taken me a little bit of time to grasp (not fully yet) monads/comonads/arros
01:49:52 <Adamant> yeah
01:50:01 <fasta> It is useful to state theorems in a commonly accepted language, such as category theory.
01:50:19 <tomberek> fasta: what prevents Haskell from having a theorem prover?
01:50:35 <fasta> tomberek, it already has ways to verify Haskell.
01:50:48 <fasta> tomberek, there is Haskabelle or whatever it is called.
01:51:03 <fasta> tomberek, but the fundamental issue is that there is no formal semantics.
01:51:28 <Philippa> fasta: this may shock you, but reasoning about code has been done with pen'n'paper for decades
01:51:36 <tomberek> hm... i would have thought they'd have a native solution by now
01:52:03 <fasta> Philippa, what makes you think I don't?
01:52:27 <Philippa> the line about finding claims not grounded in reality
01:52:29 <fasta> Philippa, although, I mostly do that in my head. For actual complex computations I use pen and paper.
01:54:07 <fasta> Philippa, well, it is a kind of pseudo-reasoning, since there are no axioms to begin with.
01:54:11 <Adamant> if your problem is "how do I make my/my team's programs in Haskell so close to C in performance we can quit writing stuff in C by default" or "I want to make a simple web server that does some specialized stuff", I'm not sure throwing a lot of category theory at those problems is going to solve them any better.
01:54:32 <Philippa> fasta: there's plenty of equational stuff that can be done
01:55:06 <fasta> Philippa, maybe for the part which has been pseudo-formalized.
01:55:25 <fasta> Philippa, all current formalizations are buggy.
01:55:28 <tomberek> Adamant: nevertheless, it seems like thinking in category theory terms forces you to think in a different way, making it easier for you to quickly write those programs that might not explicitly need it
01:56:07 <Adamant> tomberek: thinking in a different way is really good usually, but that doesn't mean you're going to use the new way all the time.
01:56:26 <fasta> Philippa, for the kind of exercises they make students do in Haskell to prove certain programs, those can be actually done in Coq already and you actually are sure(modulo implementation bugs) it works.
01:56:32 <tomberek> hehe, i still fall in to OOP habits, and even worse, BASIC!
01:57:07 <fasta> tomberek, the OOP  concept of late-binding is useful.
01:57:13 <Philippa> *nod*. Whereas I wouldn't bet on a formalisation of GHC's full type class system any time soon
01:57:53 <tomberek> Philippa... what do you mean by that? what needs to be formalised?
01:57:58 <fasta> tomberek, the OOP concept of patterns just shows that people are not creative enough to write program transformations to implement those patterns.
01:58:09 <asdf1> i'm still confused with newtype vs. data and have no clearly idea when using newtype or data?!!!!   >"<
01:58:10 <Adamant> tomberek: the first time I was reading a bytecode interpreter implementation of a language was really interesting and informative because, I might have theoretically known things were equivalent before, but I was learning how folks practically take one language and use it to implement another
01:58:27 <Philippa> tomberek: a constantly-shifting mess :-) Don't worry about it, if you don't know why I say that then you probably aren't using the relevant extensions
01:59:06 <tomberek> asdf1: they're close... newtype creates a copy of an already existing type,, where data let's you combine many of them
01:59:18 <tomberek> Philippa: which extentions?
01:59:33 <fasta> tomberek, man ghc
01:59:57 <fasta> tomberek, there are about 50 probably already.
02:00:24 <tomberek> yes, i know.. i just don't think I've been in haskell long enough to see them "shifting"
02:00:31 <tomberek> too short a time-scale
02:01:07 <Philippa> too little exposure to the little corners that get changed
02:01:45 <asdf1> tomberek: so, is there any advantage if we use newtype instead of data and vice versa?
02:02:08 <tomberek> erg.... ask another,, but I think newtype is actually faster if you can get away with it
02:02:16 <silver> yeah
02:02:18 <tomberek> data is more flexible
02:04:39 <Ian_Corne> lambdabot: help
02:05:21 <silver> @help
02:05:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:05:21 <Philippa> asdf1: newtype doesn't do all the things data does. It's for creating new types that are isomorphic to existing ones, which reuse the existing types' implementations. There's also newtype deriving which is nifty
02:05:27 <silver> @list
02:05:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:09:22 <tomberek> Philippa: are there any good intuitions or heuristics to decide when to use data/type/newtype/typeclass ?
02:12:26 <fasta> tomberek, for a beginner always use data over newtype and type-classes after a few months when you know why you might need them and you would use them when you would use interfaces in Java.
02:16:55 <Philippa> tomberek: use a type class when you're genuinely dealing with multiple types. Use type to give you a hook for refactoring when you can't be bothered to do things properly :-)
02:18:01 <tomberek> type is to clean things up... type class when you have multiple types.. ok ok... how do you know you have multiple types instead of just a polymorphic type?
02:23:20 * hackagebot hsemail 1.4 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.4 (PeterSimons)
02:45:33 <Alpounet> dmwit, ping
02:53:54 <chipmonkpyro> anyone know why this would be loading?
02:53:56 <chipmonkpyro> plusPoly :: Poly -> Poly -> Poly
02:53:57 <chipmonkpyro> PlusPoly [] [] = []
02:53:59 <chipmonkpyro> plusPoly [] (n:ns) = (n:ns)
02:54:00 <chipmonkpyro> plusPoly (m:ms) [] =(m:ms)
02:54:02 <chipmonkpyro> plusPoly (m:ms) (n:ns) = (m+n):(plusPoly ms ns)
02:54:17 <chipmonkpyro> btw    type Poly = [Float]
02:54:32 <fasta> chipmonkpyro, you mean not loading?
02:55:33 * hackagebot hopenssl 1.3 - FFI bindings to OpenSSL's EVP digest interface  http://hackage.haskell.org/package/hopenssl-1.3 (PeterSimons)
03:13:20 <mjrosenb> chipmonkpyro: what do you mean?
03:18:51 <chipmonkpyro> when i try to :load hw5 it doesnt load...
03:19:07 <chipmonkpyro> er hw5.hs
03:19:17 <mauke> how does it not load?
03:19:38 <Raynes> chipmonkpyro: They're asking for the error, brother.
03:19:52 <mauke> there may not be an error
03:20:03 <mauke> maybe it loaded silently, he just doesn't know it
03:20:10 <mauke> or the program hangs
03:20:11 <Raynes> mauke: I believe there is, he was talking about it in -blah.
03:20:14 <chipmonkpyro> hw5.hs:175:29: parse error on input `]'
03:20:16 <mauke> or the program exits
03:20:16 <chipmonkpyro> Failed, modules loaded: none.
03:20:28 <chipmonkpyro> oh nvm
03:20:29 <mauke> what's line 175?
03:20:33 <chipmonkpyro> it was something stupid
03:20:39 <mauke> ah, I see it
03:20:40 <chipmonkpyro> my bad
03:20:54 <chipmonkpyro> ans6c = evalPoly (-2) [1,2,3]]
03:20:58 <chipmonkpyro> that was the issue
03:21:05 <fasta> Hmm, I changed my opinion on derive. It's pretty nice :)
03:21:40 <chipmonkpyro> now im getting this
03:21:42 <chipmonkpyro> Not in scope: data constructor `PlusPoly'
03:21:49 <mauke> chipmonkpyro: s/P/p/
03:22:03 <chipmonkpyro> this line apparently:     PlusPoly [] [] = []
03:22:10 <chipmonkpyro> can i not do that?
03:22:48 <Raynes> Shouldn't be upper case.
03:23:01 <Raynes> plusPoly
03:23:11 <chipmonkpyro> good call
03:23:21 <mauke> told you so
03:23:28 <chipmonkpyro> :)
03:23:44 <chipmonkpyro> didnt understand what you meant by that
03:24:02 <Raynes> It's a regex, anyway.
03:24:09 <Raynes> s/replaceme/withme/
03:24:19 <chipmonkpyro> ah gotcha
03:26:42 * hackagebot Attrac 0.1.0 - Visualisation of Strange Attractors in 3-Dimensions  http://hackage.haskell.org/package/Attrac-0.1.0 (RubenZilibowitz)
03:34:56 <arcatan> hello. anyone know anything about this? http://hackage.haskell.org/trac/hackage/ticket/632
03:39:27 <fasta> arcatan, I know people talked about it on the mailing lists.
03:41:46 * hackagebot postmaster 0.2 - Postmaster ESMTP Server  http://hackage.haskell.org/package/postmaster-0.2 (PeterSimons)
03:41:56 <arcatan> solved. http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29 was the solution.
03:42:03 <mreh> > sequenceM 3 [False, True]
03:42:04 <lambdabot>   Not in scope: `sequenceM'
03:42:14 <mreh> > replicateM 3 [False, True]
03:42:15 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
03:42:24 <mreh> how can I make this big-endian?
03:42:29 <mreh> apart from map reverse
03:42:48 <mreh> replicateM 3 [True, False]
03:42:52 <mreh> > replicateM 3 [True, False]
03:42:55 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
03:43:05 <mreh> > reverse . replicateM 3 [True, False]
03:43:06 <lambdabot>   [[True,True,True],[False,True,True],[True,False,True],[False,False,True],[T...
03:43:25 <mreh> that shouldn't even parse
03:43:38 <BONUS> mreh: that's Caleskell
03:43:45 <BONUS> (it should parse but shouldn't typecheck)
03:44:11 <BONUS> :t (.)
03:44:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:44:20 <BONUS> this is different from normal haskell
03:44:34 <mreh> > reverse . replicateM 3 $ [True, False]
03:44:35 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
03:44:47 <BONUS> where (.) is forall a b c. (a -> b) -> (c -> a) -> (c -> b)
03:44:58 <mreh> hmm
03:45:01 <dobblego> @type Prelude.(.)
03:45:01 <mreh> okay
03:45:02 <lambdabot> Not in scope: data constructor `Prelude'
03:45:13 <BONUS> @type Prelude..
03:45:14 <lambdabot> parse error on input `Prelude..'
03:45:18 <BONUS> bugger
03:47:59 <mreh> does anyone know an easy way of making it big endian? rewriting sequence I suppose
03:50:38 <abbe> hi
03:53:16 <sinelaw> hi
03:54:49 <abbe> Hi sinelaw
03:55:03 <sinelaw> what's up abbe ?
03:55:06 <abbe> I need to evaluate some functions in monadic context in a block where I've lifted the monad using liftM, as pasted in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23010#a23023
03:56:26 <abbe> what is the recommended way to do it ? evaluate in a new computation ? or re-arrange it in some other way ?
03:56:42 <abbe> sinelaw: ^^^ thats up ;)
03:57:05 <sinelaw> abbe, yeah, read it. but i'm too newbish to answer :(
03:57:18 <medfly> hi sinelaw
03:57:20 <abbe> oh, np. i'm also a n00b :)
03:57:49 <sinelaw> hey medfly
03:57:54 <sinelaw> gotta move anyway.
03:57:58 <sinelaw> :P
04:08:53 * hackagebot serialport 0.3.2 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.3.2 (JorisPutcuyps)
04:10:27 <cads> hey I have seen some of the haskell greats use an expression like   (P ? Q) x, where (P ? Q) True = P, (P ? Q) False = Q, where I'm supposing that P and Q must be of the same exact type.
04:11:07 <cads> What is that (P ? Q), and how do we implement it?
04:11:23 <zygoloid> what you wrote is a correct implementation
04:11:51 <zygoloid> > let (p ? q) True = p; (p ? q) False = q in (42 ? 12) True
04:11:52 <lambdabot>   42
04:11:58 <zygoloid> (modulo capitalization...)
04:12:21 <cads> wowo
04:12:22 <ToRA> @type let (p ? q) True = p ; (p ? q) False = q in (?)
04:12:23 <lambdabot> forall t. t -> t -> Bool -> t
04:12:55 <cads> I think I like that better than 'if then'
04:13:27 <cads> how can we just use the ? symbol like a goofy operator like that?
04:14:58 <zygoloid> it's sugar for: let p ? q = \b -> case b of True -> p; False -> q
04:15:16 <zygoloid> (?) is just a normal operator which happens to return a function
04:16:27 <cads> @type (?)
04:16:28 <lambdabot> Not in scope: `?'
04:16:41 <cads> @type ?
04:16:42 <lambdabot> parse error on input `?'
04:16:47 <zygoloid> @type let p ? q = \b -> case b of True -> p; False -> q in (?)
04:16:48 <lambdabot> forall t. t -> t -> Bool -> t
04:17:59 <cads> ah, when we do that let stuff then we can do
04:18:30 <cads> >  let p ? q = \b -> case b of True -> p; False -> q in  2 ? 4 False
04:18:31 <lambdabot>   No instance for (GHC.Num.Num (GHC.Bool.Bool -> t))
04:18:32 <lambdabot>    arising from the lite...
04:19:02 <cads> >  let p ? q = \b -> case b of True -> p; False -> q in  (2 ? 4) False
04:19:02 <lambdabot>   4
04:19:18 <zygoloid> remember that (2 ? 4) False == ((?) 2 4) False == (?) 2 4 False
04:19:32 <zygoloid> we could equally write:
04:19:36 <cads> aaah
04:19:50 <zygoloid> @type let (?) a b c = if c then a else b  in (2 ? 4) False
04:19:51 <lambdabot> forall t. (Num t) => t
04:19:55 <cads> that makes it make a lot of sense
04:22:21 <cads> can we have operators with wierd fixities like:   _ @ _ _     the @ operator to the left has 3 positions to fill
04:23:05 <etpace> Hey, I'm trying to use IORefs for an enviroment for evaluating, but I'm getting problems like so: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23029#a23029 what am I doing incorrectly?
04:23:06 <zygoloid> no. function application always has higher precedence than any operator
04:24:10 <cads> and operators must strictly have one or two arguments
04:24:36 <cads> > (-) 4
04:24:38 <lambdabot>   {-3->7;-2->6;-1->5;0->4;1->3;2->2;3->1}
04:24:42 <zygoloid> well... there's only one unary operator, and it's a weirdo
04:25:05 <zygoloid> there's a GHC extension which allows defining unary postfix operators
04:25:29 <cads> @type (-)
04:25:30 <lambdabot> forall a. (Num a) => a -> a -> a
04:25:38 <zygoloid> > let (!) 0 = 0; (!) n = n * ((n-1)!) in (5!)
04:25:39 <lambdabot>   0
04:25:44 <zygoloid> > let (!) 0 = 1; (!) n = n * ((n-1)!) in (5!)
04:25:45 <lambdabot>   120
04:25:54 <cads> hehe, I love the factorial
04:25:56 <zygoloid> ... but the syntax for defining it is a little ugly
04:26:10 <zygoloid> you can't write "let (0!) = 1; ..." iirc
04:26:25 <cads> > !True
04:26:26 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
04:26:45 <cads> > let !x = not x in !True
04:26:46 <lambdabot>   <no location info>: parse error on input `!'
04:27:14 <cads> > let (!)x = not x in !True
04:27:15 <lambdabot>   <no location info>: parse error on input `!'
04:27:21 <cads> > let (!)x = not x in (!True)
04:27:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> t'
04:27:22 <lambdabot>         against inferred ...
04:27:31 <cads> > let (!x) = not x in (!True)
04:27:32 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
04:27:34 <zygoloid> > let (!) x = not x in (!) True
04:27:35 <lambdabot>   False
04:27:56 <zygoloid> (!True) == \a -> a ! True
04:28:22 <zygoloid> > let (!) x = not x in (True!)
04:28:22 <lambdabot>   False
04:28:33 <cads> ahh
04:29:10 <cads> > let (!) x = not x in (!True)
04:29:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> t'
04:29:11 <lambdabot>         against inferred ...
04:29:17 <cads> > let (!) x = not x in (True!)
04:29:18 <lambdabot>   False
04:30:11 <cads> ah because it becomes the paramater on the left of the operator becomes its first input
04:30:31 <cads> forgive my blubbermouth :)
04:30:42 <cads> I think I begin to understand this
04:31:32 <cads> I think I'd like to check out the extension :D
04:32:01 <cads> > True | False
04:32:02 <lambdabot>   <no location info>: parse error on input `|'
04:32:06 <cads> > True || False
04:32:07 <lambdabot>   True
04:34:21 <cads> let ∑ = sum in ∑ [1..10]
04:34:25 <cads> > let ∑ = sum in ∑ [1..10]
04:34:26 <lambdabot>   <no location info>: parse error on input `∑'
04:34:55 <cads> > let ∑ = fold (+) 0 in [1..10]
04:34:56 <lambdabot>   <no location info>: parse error on input `∑'
04:35:40 <cads> > let (∑) = fold (+) 0 in  [1..10] (∑)
04:35:41 <lambdabot>   Not in scope: `fold'
04:35:48 <cads> > let (∑) = foldl (+) 0 in  [1..10] (∑)
04:35:49 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
04:36:02 <dqd> > let (∑) = sum in (∑) [1..10]
04:36:03 <lambdabot>   55
04:36:57 <cads> thanks dqd
04:37:10 <cads> I feel like what I'm doing isn't anything more than a trivial hack
04:37:20 <dqd> np
04:54:21 <mreh> anyone know a good haskell library to visualise trees
04:56:39 <fasta> mreh, I always outputted dot files.
04:56:46 <tensorpudding> can vacuum-cairo do that?
04:57:01 <Raynes> I usually go outside and walk into the woods. :o
04:57:35 <fasta> tensorpudding, AFAIK, it can only show a picture, not save it to a vector format.
04:57:49 <fasta> tensorpudding, (which would be fairly trivial to add, though. )
04:58:40 <tensorpudding> well, it's got cairo already, outputting an svg shouldn't be that much more work (i suppose)
04:58:50 <fasta> mreh, now there are bindings to graphviz to create dot files. You can then generate images from those via one of the graphviz tool.
04:59:00 <fasta> tensorpudding, that's exactly what I said.
05:00:05 <mreh> okay, what is a dot file?
05:00:08 <tensorpudding> yeah, now that i read what you said, sorry
05:00:24 <mreh> what's the file format called?
05:00:29 <mreh> is it lots of dots? :D
05:00:31 <fasta> mreh, read everything on graphviz.org and you know.
05:00:33 <tensorpudding> dot is a program in graphviz that generates a certain type of graph
05:00:48 <tensorpudding> and the source files for it are called dotfiles
05:01:09 <mreh> okay, I'm off to eat a horse, thanks
05:01:11 <fasta> Unlike most Haskell libraries, graphviz does something useful.
05:01:23 <mreh> fasta: your tone is very negative
05:01:44 <fasta> mreh, that is because in 40 years basically no progress has been made.
05:01:58 <tensorpudding> it draws hierarchical graphs, graphviz can make circular and more freeform graphs
05:02:02 <tensorpudding> using other tools
05:02:06 <fasta> mreh, hmm, well actually that's not true.
05:02:08 <mreh> I just want a tree
05:02:19 <tensorpudding> they all support a ton of output formats
05:02:21 <fasta> mreh, somethings I do don't exist for more than 10 years.
05:02:35 <Lycurgus> graphviz is 40 years old?
05:02:41 <mreh> fasta: is english your first language?
05:02:53 <mreh> no offense, it's often hard to understand you
05:03:18 <fasta> mreh, it has nothing to do with that. I just don't like spelling out every detail.
05:03:28 <tensorpudding> mreh: if you just want to view it, vacuum-cairo can do what you want
05:03:59 <mreh> fasta: can you touch type?
05:04:09 <mreh> anyway! I must dash
05:04:27 <Lycurgus> fasta: english is my 1st lang and I can understand you fine, text on this screen appears native
05:05:20 <mreh> "somethings I do don't exist for more than 10 years" what did you mean by that?
05:05:23 <fasta> mreh, I can write an entire essay on why I think that all the development tools we use in 2010 basically suck. I also can fix all those tools, but the problem is still the same as it has been in the last 10 years: economics.
05:06:01 <Lycurgus> by which I take it you mean social/class relations
05:06:11 <mreh> fasta: why don't you write the essay then? it would be most enlightening
05:06:23 <fasta> mreh, There are some things that I work on, which have not existed for more than ten years in theory.
05:06:45 <fasta> mreh, everyone with a clue already knows those things.
05:07:20 <chipmonkpyro> im a bit stumped on this problem...
05:07:21 <chipmonkpyro> Write a Haskell function
05:07:23 <chipmonkpyro> timesPoly :: Poly -> Poly -> Poly
05:07:24 <chipmonkpyro> that multiplies two polynomials. For example, timesPoly [1,2,1] [-3,2]
05:07:26 <chipmonkpyro> should return [-3,-4,1,2], since (1 + 2x + x^2)  * (-3 + 2x) = -3 - 4x + x^2 +
05:07:28 <chipmonkpyro> 2x^3.         where type Poly = [Float] and represents the coefficiants on a qaudratic,   this is what I have tried so far...
05:07:29 <chipmonkpyro> timesPoly [] ns = []
05:07:31 <chipmonkpyro> timesPoly (m:ms) ns = zip ((map f ns)++[0,1..10]) (0:(timesPoly ms ns))
05:07:32 <chipmonkpyro>     where f b = b*m
05:07:34 <chipmonkpyro> any thoughts / help?
05:07:40 <mreh> it's a recursive problem
05:07:40 <fasta> chipmonkpyro, a paste site?
05:07:47 <chipmonkpyro> ?
05:07:49 <Philonous> @paste
05:07:49 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:08:01 <Philonous> It's much easier to read there
05:08:12 <mreh> you times everything in the first list by each element in the second, collecting the terms as you go
05:08:39 <chipmonkpyro> thats what im trying to do
05:09:02 <chipmonkpyro> well what ive got is rather incomplete
05:09:04 <mreh> chipmonkpyro: okay, I ignored the patse, sorry
05:09:07 <chipmonkpyro> im just not sure how to do that
05:09:15 <mreh> paste it somewhere where people can read it
05:09:16 <mreh> @paste
05:09:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:09:26 <mreh> does it compile
05:09:46 <fasta> mreh, and about my English. A major company (which everyone knows) for which I interviewed for some position suggested that I should go and consider writing technical documentation for them given only my thesis.
05:09:55 <kalven> @src nub
05:09:55 <lambdabot> nub = nubBy (==)
05:10:45 <chipmonkpyro> no
05:12:02 <Lycurgus> the number of persons who have been programming 40 years is very small
05:12:32 <Lycurgus> especially in comparsion with total IT workforce
05:13:04 <fasta> Lycurgus, I have not been programming 40 years.
05:13:28 <chipmonkpyro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8123#a8123
05:13:32 <fasta> Lycurgus, Lisp Machines were definitely a step in the right direction.
05:13:39 <Lycurgus> no, I didn't think you had, although it wouldn't have been an invalid inference from you statement
05:13:44 <badsheepy> and thats why they were such a success :o
05:13:56 <Lycurgus> that was less than 30 years ago
05:14:02 <Lycurgus> within my experience
05:14:15 <fasta> badsheepy, it depends on how you define success.
05:14:22 <zygoloid> > let zipWithFill a f xs ys = take (length xs `max` length ys) (zipWith f (xs++repeat a) (ys++repeat a)) in (\xs ys -> foldr (\x cs -> zipWithFill 0 (+) (map (x*) ys) (0:cs)) [] xs) [1,2,1] [-3,2]
05:14:23 <lambdabot>   [-3,-4,1,2]
05:14:25 <fasta> badsheepy, if you define success in terms of money, then no.
05:14:27 <badsheepy> you cant buy one now, thats not very successful
05:14:41 <benmachine>  < fasta> mreh, everyone with a clue already knows those things. <-- may I humbly suggest that getting a clue is a long and laborious process and every effort to aid it would be very useful
05:15:28 <benmachine> I had probably been programming a year before I worked out that everything was terrible
05:15:31 <chipmonkpyro> wow
05:15:33 <chipmonkpyro> awsome
05:15:37 <benmachine> some pointers in that direction beforehand might have been helpful
05:16:12 <badsheepy> yeah, id imagine a whole host of people who would subsequently gain a clue are put off of doing so by lack of documentation :o
05:16:48 <benmachine> fasta: it is easier than it sounds to change the way people think via essays, imo
05:16:55 <benmachine> or maybe I am just highly impressionable
05:17:08 <sizur_> Guys, can we push for abstraction of + and * from Num into Ring?
05:17:21 <fasta> benmachine, heh, I disagree.
05:17:23 <MissPiggy> sizur_, I have done this in my code
05:17:51 <MissPiggy> sizur_, I don't care particularly what Prelude does, because once you have a system Prelude doesn't get in the way
05:18:10 <fasta> benmachine, and even if you change how they think s.t. they agree with you, that doesn't mean the problem is solved then.
05:18:26 <sizur_> So you have alternative Prelude?
05:18:31 <zygoloid> chipmonkpyro: let's get your version working then.
05:18:36 <benmachine> fasta: no, but it's a start, isn't it?
05:18:55 <MissPiggy> sizur, in some sense - you could say that
05:18:55 <zygoloid> chipmonkpyro: the first thing is, it doesn't compile, because zip (a :: Poly) (b :: Poly) produces (Poly, Poly)
05:19:28 <zygoloid> chipmonkpyro: you want to add the two polynomials together, so you want zipWith (+). that gets it compiling but it doesn't produce the right result. can you see why?
05:19:50 <chipmonkpyro> because of length
05:19:51 <fasta> benmachine, the real problem is capitalism and in particular the disconnect between the way money is obtained by governments (and banks!) and the way it is spend.
05:19:54 <fasta> spent*
05:20:19 <fasta> benmachine, you can try to fix other minor issues, but that is the real reason progress goes so slow.
05:20:19 <zygoloid> chipmonkpyro: right. zip stops once either of the lists does.
05:20:29 <fasta> benmachine, (even though, many people believe progress is fast)
05:21:00 <chipmonkpyro> what does take do?
05:21:01 <benmachine> fasta: I can believe it, but if I don't know how to fix the big issues I'd rather fix the small ones than do nothing
05:21:20 <benmachine> (unless you *do* know how to fix the big issues, in which case I am all ears :P )
05:21:33 <zygoloid> "take n xs" produces a list containing the first n elements of xs
05:22:48 <benmachine> fasta: I dunno I am just filled with a vague sense of undirected optimism today
05:22:53 <fasta> benmachine, I have some ideas about how to attack the big issues, but they are against everything this society stands for, like everyone having a "job" for example.
05:22:57 <dobblego> MissPiggy, is your Ring class on hackage?
05:23:09 <sizur_> Does any one think that restricting classes to one method is a good idea?
05:23:10 <MissPiggy> dobblego, no - I don't have hackage ability
05:23:28 <zygoloid> chipmonkpyro: so, your (map f ns ++ [0..10]) idea is very nearly a great one
05:23:28 <fasta> benmachine, politicians see jobs as a good thing. I see jobs as a temporary bad solution for particular real-world problems.
05:23:42 <benmachine> interesting
05:23:44 <MissPiggy> sizur_: that does not sound like a good idea to me
05:24:04 <MissPiggy> sizur_: is there some kind of argument that suggests it's worth doing?
05:24:19 <zygoloid> chipmonkpyro: there's two problems with it, really. firstly, the 1,2,3... should all be 0s.
05:24:22 <zygoloid> > repeat 0
05:24:23 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:24:29 <fasta> benmachine, I also happen to believe that by real cooperation, we could elevate the standard of living by so much that even billionaires today would want it.
05:24:31 <chipmonkpyro> i know
05:24:41 <dobblego> sizur_, not always, consider e.g. mempty would be pointless on its own
05:24:42 <sizur_> It would force better abstractions
05:24:43 <chipmonkpyro> i had it that way while i was messing around with it
05:24:50 <fasta> benmachine, but I am only one person in a few million at most with that opinion.
05:25:03 <benmachine> fasta: we are two :P
05:25:12 <zygoloid> chipmonkpyro: now in order for it to work, you'd need for (map f ns ++ repeat 0) to be always at least as long as (0:timesPoly ms ns). and that's nearly always true.
05:25:22 <zygoloid> chipmonkpyro: the case where it's not true is when ms is [].
05:25:40 <sizur_> Mempty and unit would be singletons
05:25:58 <chipmonkpyro> ohhh
05:26:05 <chipmonkpyro> so the stopping case doesnt work?
05:26:09 <zygoloid> right
05:26:22 <zygoloid> you could either extend the 'timesPoly [] ns' case to produce a list of (length ns) 0s
05:26:31 <zygoloid> or you could add a 'timesPoly [m] ns' case
05:27:26 <chipmonkpyro> now im confused >.>
05:27:42 <chipmonkpyro> what would that do?
05:27:44 <MissPiggy> sizur anyway what are you plants
05:27:47 <MissPiggy> plans*
05:27:47 <MissPiggy> lol
05:28:30 <zygoloid> chipmonkpyro: it would ensure that, in the case where your "timesPoly (m:ns)" is used, (0:timesPoly ms ns) is always the length you want for the result.
05:29:18 <zygoloid> there's another option, and that'd be to replace the 'zipWith' with a function which stops only when both lists are exhausted (and extends the shorter list with 0s)
05:30:16 <sizur_> That was a tangent.  Just thought about overloading + *
05:30:40 <MissPiggy> sizur it's very difficult actually
05:31:02 <MissPiggy> sizur, for exampl I have monoid on both +,10 and *,1
05:31:05 <MissPiggy> oops
05:31:08 <MissPiggy> +,0 and *,1
05:31:20 <MissPiggy> so how does Ring know which monoids?
05:31:35 <MissPiggy> the answer is named instances... and doing named instances is a hack
05:31:41 <MissPiggy> not directly supported by haskell
05:32:53 <benmachine> isn't the answer newtypes?
05:34:16 <MissPiggy> benmachine: maybe you use newtype in implementation of named instances
05:49:25 <McManiaC> hmmm
05:49:48 <McManiaC> how can I increment "numbers" in a octa/hexa/whatever decimal system?
05:49:52 <MissPiggy> yes
05:50:24 <benmachine> McManiaC: what do you mean? numbers don't know what base they are in :)
05:50:43 <MissPiggy> if the digits are d0,d1,d2,d3 then increment is just d0,d1,d2,d3+1 -- with the exception that sometimes you have to carry
05:50:58 <MissPiggy> when you carry it's d0,d1,d2+1,0 -- with the exception that you sometimes have to carry again.....
05:51:11 <MissPiggy> so this suggests some kind of recursive program
05:51:24 <McManiaC> hmhm
05:51:32 <McManiaC> just wondering if theres an easy way to do this :)
05:51:50 <MissPiggy> McManiaC did I make it sound difficult
05:52:04 <McManiaC> I struggle a bit to implement this, yes
05:52:06 <McManiaC> ^^
05:52:11 <MissPiggy> oh don't worry about that
05:52:16 <MissPiggy> this is not near implementing
05:53:48 <MissPiggy> McManiaC: consider a concrete example in hex to increment 3FF we get 400 right? and that's because 3,F,F+1 has to carry which is 3,F+1,0 which has to carry again.. giving 4,0,0
05:53:52 <dmwit> Alpounet: pong
05:54:31 <McManiaC> hmhm
05:54:40 <MissPiggy> McManiaC: so you see the recursion? :)
05:54:45 <McManiaC> maybe some kind of foldr
05:54:58 <Alpounet> dmwit, I had a question about your howto about audio volume & xmonad
05:54:59 <Alpounet> but I sorted it out
05:55:02 <Alpounet> thanks anyway
05:55:03 <McManiaC> combined with mod/div/whatever
05:55:04 <Alpounet> it helped a lot
05:55:11 <dmwit> great =)
05:55:12 <MissPiggy> McManiaC, No I don't think so, I don't see where you got this idea
05:55:45 <MissPiggy> McManiaC, what I am saying is to increment d0,d1,d2,d3 with a carry, you just increment d0,d1,d2 and stick 0 on the end
05:55:46 <benmachine> McManiaC: it's probably easiest if you have the digits as a list of characters with the least significant at the front
05:56:10 <MissPiggy> yeah or just focus on understand the algorithm before thinking about implementing it
05:56:43 <benmachine> McManiaC: then you inspect the first digit; if it doesn't demand a carry, you're already done
05:58:47 <MissPiggy> looks like we've confused him by all talking at once
05:58:52 <McManiaC> hehe
05:59:03 <McManiaC> im kinda distracted, sorry
05:59:30 <cpettitt> I'm building a tree library that needs to use an indexing function in some of its internal functions - there is only one of these indexing functions for a given tree. Is it sane to create a top level Tree object that is the composition of the tree root and this function, and then using something like Reader monad to get at the function in the lower level functions? Making most of the internal functions monadic doesn't feel great. Is
05:59:31 <cpettitt> a huge cost to just copying this indexing function throughout the branches of the tree instead?
06:00:56 <zygoloid> you can do it with a foldr if you want...
06:01:28 <benmachine> you can do anything with a foldr :P
06:01:49 <zygoloid> @faq Can Haskell make me a cup of coffee with a foldr?
06:01:49 <lambdabot> The answer is: Yes! Haskell can do that.
06:01:58 <MissPiggy> yeah but why would you it's not obviously a foldr... what is easy is to write it direct then notice it can be written as a fold
06:02:26 <cpettitt> Hmm, in many cases I want to traverse only a specific part of the tree (for example lookup or insert). I don't think foldr would work for that, would it?
06:02:36 <MissPiggy> actually it's not quite right to say that is easy
06:02:41 <Alpounet> dmwit, it was about binding the special volume keys most keyboards now have to the raise|lowerVolume functions
06:02:50 <Alpounet> you may want to add a note about that
06:04:07 <cpettitt> If it helps clarify what I'm doing at all - I'm building a Patricia Tree library on top of the Vector library
06:04:38 <cpettitt> The indexer is to help figure out which Node is the next for a given prefix
06:05:43 <zygoloid> > let incBase b ns = foldr f (\c -> if c then [1] else []) ns True where f a r carry | carry && a+1 == b = 0:r True | carry = a+1:r False | otherwise = a:r False  in incBase 16 [15,15,3]
06:05:44 <lambdabot>   [0,0,4]
06:07:52 <zygoloid> > let incBase b [] = [1]; incBase b (a:as) | a+1 == b = 0:incBase b as | otherwise = a+1:as in incBase 16 [15,15,15]
06:07:53 <lambdabot>   [0,0,0,1]
06:20:17 <dmwit> Alpounet: good idea
06:34:33 <aksionov> does it look good to insert a 'let' definition in between of a do block, instead of putting it at top ?
06:34:51 <MissPiggy> no
06:35:01 <benmachine> if it depends on a name that you bind during the do-block, you don't have a choice
06:35:34 <Alpounet> dmwit, I did it with `additionalKeysP` and "<Xf86AudioRaiseVolume>" and all
06:35:38 <Alpounet> fwiw.
06:36:10 <aksionov> Okay, thanks MissPiggy benmachine
06:37:42 <RayNbow> @hoogle (w a -> b) -> (w b -> c) -> (w a -> c)
06:37:43 <lambdabot> No results found
06:38:59 <zygoloid> RayNbow: you looking for cokleisli composition of comonads?
06:39:39 * hackagebot streamproc 1.3 - Stream Processer Arrow  http://hackage.haskell.org/package/streamproc-1.3 (PeterSimons)
06:40:08 <RayNbow> zygoloid: just wondering if it is defined somewhere
06:40:59 <watterson> I'm getting a "parse error on input '='" for what seems like no reason... is there a common reason haskell does that?
06:41:33 <sjanssen> watterson: possibly a missing ) or ]?
06:42:06 <zygoloid> @pl \f g a -> g (a =>> f)
06:42:06 <lambdabot> flip (.) . flip (=>>)
06:42:10 <zygoloid> ew.
06:42:27 <watterson> sjannsen - http://nopaste.voric.com/paste.php?f=fca92g
06:42:28 <McManiaC> MissPiggy: I still cant implement this correctly :S
06:42:44 <watterson> that's a snip of the file...
06:42:51 <zygoloid> RayNbow: there's always \f g -> runCoKleisli (CoKleisli f) (CoKleisli g)
06:43:01 <Arnar> @hoogle Endo
06:43:01 <lambdabot> Data.Monoid newtype Endo a
06:43:01 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
06:43:01 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
06:43:50 <RayNbow> @pl \f g -> \wa -> g (fmap f (duplicate wa))
06:43:50 <MissPiggy> McManiaC: we should try to understand the thing before worrying about implementing
06:43:51 <lambdabot> flip (.) . (. duplicate) . fmap
06:44:38 <zygoloid> (runCoKleisli `on` CoKleisli) f g
06:45:58 <sjanssen> watterson: look at the lines above it
06:46:45 <sjanssen> also, a paste site that uses a non monospaced font?
06:48:00 <zygoloid> McManiaC: are you having trouble with the method itself, or the translation into haskell?
06:48:05 <watterson> rafb died, and I didn't read the title because I'm a horrible person
06:48:25 <watterson> sjanssen: the line above doesn't have any non-quoted brackets of any sort
06:48:44 <sjanssen> watterson: try hpaste.org
06:49:15 <sjanssen> watterson: the problem is somewhere above, could you paste the whole file?
06:49:40 <zygoloid> > let degr n = n * (360 / (2 * pi)) in degr 0.3
06:49:41 <lambdabot>   17.188733853924695
06:50:43 <watterson> sjanssen: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=23031#a23031
06:52:30 <sjanssen> watterson: that module loads fine here
06:53:10 <sjanssen> (except for the type signatures, I commented those out because I don't have a 'Coords' module)
06:53:20 <tumult> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23032 <- how do i not make this slow as molasses? it only even completes on a 2mb file if i set the stack space to hundreds of mb
06:53:38 <tumult> basically it just reads in a binary wave file and decodes it from an ADPCM format
06:53:49 <zygoloid> watterson: loads fine here, with Coords commented out and 'type Scalar = Double'
06:53:57 <zygoloid> watterson: possibly this is a tabs/spaces mixup?
06:54:03 <tumult> i thought i could express it as a series of transformations on lists but it seems that something else is required to not make it terribly slow
06:54:19 <watterson> zygoloid: it is concievable. What is Haskells' spaces/tabs convention?
06:54:30 <zygoloid> watterson: Tabs: Just Say No
06:54:49 <zygoloid> i /think/ it's 1 tab == 8 spaces, but i'm not 100% sure
06:55:13 <zygoloid> inconsistent indentation will lead to horrible flaming death, though
06:55:25 <watterson> I'll poke at it
06:55:44 <watterson> I've been having the same problem all night attempting to use lets and wheres
06:55:53 <tumult> i added strictness annotations via bang patterns to various things and it cut down the run time/size by about half, but it's still way way too slow
06:55:55 <watterson> so, spaces/tabs could definitely do that
06:56:17 <tumult> and i'm not sure what the actual correct way to go about streaming binary data in/out is
06:56:51 <watterson> %^%*(&#$(. It was tabs :|
06:56:54 <sjanssen> tumult: why do you bother getting input as a lazy ByteString, but then immediately convert it to a list?  This is very slow
06:57:09 <tumult> is it? i had assumed the conversion was lazy
06:58:01 <tumult> do i need to use get/put in order to lazily get data in and out of a lazy bytestring?
06:58:08 <sjanssen> it is lazy, but it's still slow.  Also, a 2 M bytes long list is a problem
06:58:18 <sjanssen> tumult: get/put is one good way, yes
06:58:59 <sjanssen> tumult: is splitLSB used on very long lists?
06:59:10 <tumult> yes and it's the slowest function
07:00:08 <tumult> though i'm not sure exactly why
07:00:21 <tumult> i'm guessing because there is not a 1:1 mapping of input/output elements?
07:01:36 <sjanssen> well, it does a lot of allocation
07:01:47 <tumult> yeah
07:02:30 <tumult> i don't know what the best approach to this is
07:04:33 <tumult> the adpcm data needs to be dealt with 4 bits at a time
07:05:07 <tumult> i guess it is unreasonable to express this as a series of transformations on lists?
07:05:25 <tumult> or is there a way to do this so that it fuses with no intermediary structures/allocation
07:05:48 * hackagebot base64-string 0.2 - Base64 implementation for String's.  http://hackage.haskell.org/package/base64-string-0.2 (IanLynagh)
07:06:11 <Daerim> tumult, you could use the binary package I think?
07:06:30 <tumult> i'm only using it for doing the put at the very end right now
07:07:12 <zygoloid> tumult: part of the problem is probably that the 'foldr unpredict' needs to scan all the way to the end of the list before it can produce the first element :(
07:08:35 <tumult> is that because it's in a tuple with an accumulated value?
07:08:37 <gwern> @quote vale
07:08:38 <lambdabot> lament says: haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
07:08:53 <gwern> @quote tear
07:08:53 <lambdabot> JaffaCake says: Casting boxed types to unboxed types or vice versa is pretty much guaranteed to end in tears
07:09:01 <sjanssen> zygoloid: I don't think you're right about that
07:09:10 <sjanssen> oh wait, yeah you are
07:09:35 <tumult> what are the conditions for a right fold needing to traverse an entire list before being able to product a value?
07:09:54 <Daerim> tumult, I think you could use the binary package to make decodeStream :: ByteString -> ByteString
07:10:35 <tumult> i could, with the get and put monads
07:10:42 <tumult> i wanted to know if i could do this with a list-like interface
07:11:09 <zygoloid> tumult: the value of 'step' at each stage has a value dependency on every element of the list after that point.
07:12:56 <tumult> i see
07:13:18 <tumult> are you generally supposed to use left folds with accumulators like that?
07:15:27 <zygoloid> was it your intention that the value dependency would go that way around? or did you want the values to depend on the earlier list elements instead?
07:15:48 <tumult> i can explain the algorithm
07:18:37 <Arnar> I have in mind a type of the form x -> [x] -- where x is a concrete type (not a type variable)
07:18:38 <tumult> word8 to word4 (two for each word8), each word4 to an int based on the value of every previous calculation of word4 to int
07:18:51 <Arnar> and I want to compose these.. in the style of the [] monad
07:19:16 <Arnar> does anyone reckognize this as some standard type?
07:19:30 <tumult> and then at the end, int to int based on the difference with the previous int in the list
07:19:50 <tumult> so the calculations are all sequential in one direction
07:22:00 <tumult> zygoloid: i guess basically it will have a value dependency in one direction or the other no matter which way i fold, but there is something i need to avoid doing in order to have it fuse or not behave terribly?
07:25:04 <MissPiggy> > 1+1
07:25:05 <lambdabot>   2
07:28:58 <zygoloid> tumult: if the value dependency is only to the left then it can be productive, and operate in constant heap (well, up until you invoke 'length' on the result)
07:30:06 <tumult> does 'to the left' mean it needs to be constructed using a left fold?
07:32:32 <mreh> tumult: i what context?
07:32:35 <mreh> s/i/in
07:33:16 <tumult> right now it's a right fold, Word8 -> (Int, [Int]) -> (Int, [Int])
07:34:00 <tumult> it constructs a new list with elements derived from the fst of the tuple (step accumulator) and the elements from the list being folded over
07:34:16 <tumult> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23032
07:35:13 <tumult> i was under the impression there was a way to express this kind of transformation as if it were on lists and have it end up being fused by he compiler if done right, so i am assuming i am not doing it right
07:35:47 <tumult> probably one of the things i am doing wrong is that i should not foldr on a lazy bytestring?
07:36:23 <sjanssen> tumult: the problem is that you have a foldr on a function that is strict on the second argument.  You should never do this
07:38:31 <tumult> it's strict because it must evaluate all of the accumulated value to produce any results?
07:39:22 <sjanssen> the primary reason it is strict is due to the "(step, xs)" pattern on unpredict
07:39:59 <mreh> am I doing real genetic programming by evolving an eDSL in haskell, do you think?
07:40:24 <mreh> evolving a set of datastructures that are an eDSL, that is
07:40:58 <tumult> sjanssen: i guess i am unsure exactly what you mean by strict, and also what part of the pattern on that function :)
07:41:21 <sjanssen> tumult: the part where you match on a tuple in the second argument
07:41:47 <aksionov> > readFile "/proc/cpuinfo" >>= putStrLn
07:41:48 <lambdabot>   <IO ()>
07:42:05 <sjanssen> I mean "strict" in the sense of "to evaluate the result of (unpredict x y), y must be evaluated first"
07:42:32 <tumult> ah the pattern match
07:42:43 <aksionov> Is 'Data.ByteString.readFile "/proc/cpuinfo" >>= Data.ByteString.putStrLn' going to behave differently than 'readFile "/proc/cpuinfo" >>= putStrLn' ?
07:43:01 <Itkovian> release early and often?
07:43:05 <Itkovian> on hackage?
07:43:06 <dankna> yes, if /proc/cpuinfo contains non-ascii characters
07:43:27 <aksionov> Okay
07:43:34 <dankna> (I believe, don't quote me)
07:43:46 <sjanssen> aksionov: possibly, yes.  The /proc filesystem gets a bit weird with IO sometimes
07:43:57 <sjanssen> dankna: I don't think you're correct on that
07:44:26 <dankna> no?  because Prelude's readFile and putStrLn do UTF8 handling by default, don't they?
07:44:41 <sjanssen> dankna: only on recent versions of GHC
07:44:46 <dankna> true
07:45:02 <sjanssen> and even so, ByteString's consistent ignorance of encodings means that the two programs will have the same result
07:45:08 <dankna> hmm
07:45:09 <dankna> point taken
07:46:00 <aksionov> okay, thanks
07:46:04 <konr> is there a haskell repl?
07:46:20 <shapr> > 1 + 1
07:46:21 <lambdabot>   2
07:46:30 <shapr> > map (+1) [1..5]
07:46:31 <lambdabot>   [2,3,4,5,6]
07:46:35 <shapr> konr: Yes.
07:46:54 <sjanssen> konr: ghci
07:47:01 <tumult> sjanssen: am i right in thinking that this ends up becoming more like an append operation since evaluation is being required repeatedly?
07:47:08 <shapr> Yeah, ghci is a better choice.
07:47:23 <konr> shapr, sjanssen: thanks!
07:47:33 <sjanssen> tumult: I don't really see the connection to append
07:47:41 <tumult> ok
07:48:42 <sjanssen> > foldr (+) 0 [0 .. 2^15] -- this is your problem simplified
07:48:43 <lambdabot>   536887296
07:48:57 <sjanssen> probably need to go to a larger number to see it stack overflow
07:48:57 <tumult> ohh
07:49:23 <tumult> duh
07:49:26 <tumult> i am an idiot
07:49:28 <tumult> haha
07:49:36 <tumult> thank you
07:50:00 * hackagebot glpk-hs 0.0.2 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.0.2 (LouisWasserman)
07:55:46 * aksionov has accumulated his n00bish skills to write a tiny web server and would like people to comment on crappiness of coding style. The code is pasted at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23038#a23038
07:55:59 <Arnar> is there a way to compose monoids.. similar to monad transformers compose monads?
07:56:23 <Arnar> not exactly sure what I really mean here.. but I'm looking for something of the sort a -> [a]
07:56:43 <gwern> @hoogle (Monoid a) => a -> [a]
07:56:44 <lambdabot> Prelude repeat :: a -> [a]
07:56:45 <lambdabot> Data.List repeat :: a -> [a]
07:56:45 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
07:56:50 <gwern> there, see? :)
07:56:54 <Arnar> aha
07:57:07 <gwern> Arnar: or didy ou mean monoid a => [a] -> a? that's mconcat
07:57:34 <Arnar> gwern: I want to describe walks in a graph
07:57:41 <Arnar> nondeterministically
07:57:45 <MissPiggy> aksionov, I think you should try to erase the use of liftM4
07:57:53 <gwern> aksionov: 4 liftIOs in a row makes me suspicious
07:57:58 <Arnar> a walk is a function from a node to nodes
07:58:08 <Arnar> a non-determinist walk is a -> [a]
07:58:21 <Arnar> now I want to cleanly compose walks with concatenation and choice
07:58:27 <Arnar> see what I mean?
07:58:36 <aksionov> gwern, MissPiggy: okay, any suggestions how to remove them ? and why they're bad ?
07:58:45 <gwern> aksionov: they're repetition. repetition is always bad
07:59:05 <MissPiggy> aksionov: I just found it odd looking
07:59:10 <gwern> aksionov: you could, if I'm reading it right, do something like 'liftIO $ do x; y; z; a'
07:59:13 <gwern> I think
07:59:33 <gwern> Arnar: no, not really.
07:59:48 <zygoloid> aksionov: it's often nicer to write 'catch' infix
07:59:52 <Arnar> gwern: nm :)
07:59:58 <aksionov> but I need to pass results of all the four IO computations.
08:00:16 <MissPiggy> aksionov you use <- like before :)
08:02:47 <aksionov> gwern: Okay, if I'm going to remove 4 liftIOs and is  combine them into one like this: liftIO (do r1 <- a; r2 <- b; r3 <- c; r4 <- d; return (r1,r2,r3,r4)) . This looks fine, hmm...?
08:03:02 <aksionov> s/is  c/c/
08:03:10 <gwern> better to me, yeah
08:03:17 <zygoloid> aksionov: you can do better than that. you only need to invoke (getFileStatus fn) once
08:03:19 <Beelsebob> aksionov: liftIO ((,,,,) <$> a <*> b <*> c <*> d)
08:03:44 <gwern> Beelsebob: sure but who would understand that?
08:03:46 <aksionov> Beelsebob: I've not reached that stage to use Applicative stuff...:)
08:04:01 <Beelsebob> gwern: I certainly find it a *lot* easier to understand than the monadic one
08:04:02 <aksionov> thanks zygoloid gwern MissPiggy for suggestions :)
08:04:09 <Beelsebob> there's much less clutter in it
08:04:11 <gwern> BESIDES Beelsebob
08:04:22 <Beelsebob> gwern: lots of people
08:04:33 <Beelsebob> believe it or not, lots of haskellers do know about more than monads ;)
08:04:42 <zygoloid> aksionov: in buildRequest, (...) >>= (return . f) = f <$> (...)
08:05:49 <zygoloid> aksionov: you don't need parentheses around the expression in case ... of
08:05:52 <Arnar> gwern: if you are curious.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23039#a23039
08:06:48 <gwern> Arnar: so you want [Walk loc] -> Walk loc?
08:06:53 <Arnar> no
08:07:01 <Arnar> this is what I wanted
08:07:01 <Arnar> :)
08:07:16 <gwern> @_@ whatever then
08:07:17 <lambdabot>  whatever then
08:07:19 <zygoloid> aksionov: in handleConnection, in the do-block, don't write (foo) >>= (\hh -> bar >>= baz), write hh <- foo; r <- bar hh; baz r
08:07:25 <aksionov> zygoloid: someone told me about that Applicative operator, but I want to avoid using that for now. And regarding parens around 'case ... of' I just wanted to be sure not to confuse parser.
08:07:46 <zygoloid> aksionov: you confused the parser in my brain by adding them :)
08:07:54 <zygoloid> <$> is just fmap is just liftM
08:07:59 <zygoloid> (in this case)
08:08:23 <aksionov> lol, okay, thanks, I'll make sure to use '(>>=)' less and 'do' more.
08:08:25 <zygoloid> it's not actually an Applicative operator, it's a Functor operator living in the Applicative module :)
08:09:00 <zygoloid> aksionov: there's no harm in using >>= when it's clear. but if you're in a do-block anyway it makes it seem like something subtle is going on (like maybe you're using another monad) and there isn't
08:09:16 <aksionov> okay
08:09:21 <SamB_XP> zygoloid: huh
08:09:38 <SamB_XP> I always thought it just meant "I don't feel like thinking of a name for this value"
08:09:40 <Paczesiowa> @src uncurry3
08:09:40 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:09:49 <Paczesiowa> @hoogle uncurry3
08:09:49 <lambdabot> No results found
08:10:08 <SamB_XP> though typically I use =<< in that situation anyways
08:10:23 <dschoepe> :t uncurry . uncurry
08:10:24 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
08:10:56 <zygoloid> SamB_XP: the code in question said 'do ...; foo >>= (\hh -> ...)'
08:11:09 <SamB_XP> zygoloid: ah, yeah
08:11:13 <SamB_XP> That does look kinda silly
08:12:29 <Paczesiowa> dschoepe: huh, nice
08:13:03 <MissPiggy> aksionov uniformity
08:13:34 <Paczesiowa> :t curry . curry
08:13:35 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
08:13:49 <SamB_XP> this is why triples should almost be banned ;-P
08:14:01 <aksionov> MissPiggy: symmetry :)
08:15:45 <Paczesiowa> @src curry
08:15:45 <lambdabot> curry f x y = f (x, y)
08:15:48 <zygoloid> handler hdr xs = head <$> filterM (unsafeInterleaveIO . flip handlesRequest hdr) xs
08:15:51 <zygoloid> *ducks*
08:19:04 <MissPiggy> :t curry . curry . curry
08:19:05 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
08:21:00 <Paczesiowa> we need curryN
08:21:13 <MissPiggy> what for
08:21:50 <Paczesiowa> if you know the type of 'f', haskell can figure out number of "curry" to compose
08:24:59 <Berengal> Paczesiowa: Is type inference for that possible?
08:25:16 <Paczesiowa> Berengal: yes
08:25:24 <Berengal> Is it possible in the haskell type system?
08:25:47 <Paczesiowa> lambdabot: Is it possible in the haskell type system?
08:25:59 <Berengal> I mean, it's easy with TH...
08:26:00 <Paczesiowa> ...
08:26:14 <Paczesiowa> Berengal: yes, it is possible
08:26:21 <Berengal> How?
08:26:49 <watterson> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23042#a23042 - what is the @ doing in the doBox definition in this code?
08:26:54 <mauke> aliasing
08:26:54 <Paczesiowa> Berengal: it is possible if f has (a1,...,an) -> b type, it won't work if f can work over any tuple
08:27:07 <mauke> without looking at the code, but I don't think @ has any other meaning in haskell
08:27:33 <Paczesiowa> Berengal: I'm currently writing blog post about it:)
08:27:36 <watterson> allright, I'll take a look at aliasing. It's hard to google for '@' :[
08:27:36 <Berengal> > let a@b = 1 in (a, b) -- multiple names to a single variable
08:27:37 <lambdabot>   (1,1)
08:27:42 <Berengal> Paczesiowa: Neat
08:28:00 <Berengal> Paczesiowa: And I'd think the type of f and the type of the result would be known
08:28:11 <Berengal> Paczesiowa: What techniques does it use?
08:28:30 <Paczesiowa> Berengal: -foleg
08:28:58 <Berengal> Paczesiowa: Haksell3000 you mean ;)
08:29:17 <Paczesiowa> Berengal: I wish:)
08:36:56 <fasta> > let a@b@c@d = 1 in a
08:36:57 <lambdabot>   1
08:37:04 <fasta> Heh, I have never used that.
08:37:33 <mauke> m@main=putStr"y\n">>m
08:38:19 <fasta> [a,b] =[1,2]\n >> a        => 1
08:44:11 <Paczesiowa> curry takes uncurried function and returns curried or the other way?
08:44:45 <gwern> @hoogle curry
08:44:45 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
08:44:45 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
08:44:45 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
08:44:53 <gwern> you tell me
08:45:45 <Paczesiowa> gwern: which one is curried? I always forget this...
08:47:00 <tensorpudding> @check \f x -> ((curry . uncurry) f) x == f x
08:47:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> c)
08:47:01 <lambdabot>    arising from a use...
08:48:18 <tensorpudding> ugh
08:49:19 <zygoloid> Paczesiowa: curry curries. uncurry uncurries
08:49:36 <tensorpudding> @check \x -> ((uncurry . curry) f) $ x == f x
08:49:37 <lambdabot>   Couldn't match expected type `(a, b)'
08:49:40 <tensorpudding> doh
08:49:48 <tensorpudding> @check \f x -> ((uncurry . curry) f) $ x == f x
08:49:49 <lambdabot>   Couldn't match expected type `(a, b)'
08:50:30 <Berengal> fasta: Too bad you can't use multiple patterns...
08:50:46 <fasta> Berengal, define multiple patterns.
08:50:50 <zygoloid> i've never understood why the thing before @ can't be a pattern
08:50:50 <tensorpudding> @check \f x@(a,b) -> ((uncurry . curry) f) $ x == f x
08:50:51 <lambdabot>   Couldn't match expected type `(a, b)'
08:50:57 <fasta> Berengal, you can name sub-patterns.
08:51:15 <Berengal> a@(x:y:z)@((Foo bar):_)
08:51:18 <robocop> @check (\x -> x+x) == (\x x*2)
08:51:18 <lambdabot>   Parse error at "*2)" (column 21)
08:51:31 <robocop> @check (\x -> x+x) == (\x -> x*2)
08:51:32 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
08:51:32 <lambdabot>    arising from a use of `GHC.Cla...
08:51:46 <zygoloid> swap (fst -> a)@(snd -> b) = (b, a)
08:52:04 <fasta> Berengal, that doesn't make sense to me.
08:52:19 <Berengal> fasta: Applying more than one pattern to a value without repeating the value
08:52:23 <tensorpudding> @check \f x@(a,b) -> (((uncurry . curry) f) $ x) == f x
08:52:23 <lambdabot>   Overlapping instances for GHC.Show.Show ((a, b) -> c)
08:52:24 <lambdabot>    arising from a use...
08:53:05 <tensorpudding> @check let f (a,b) = a+b in \x -> (((uncurry . curry) f) $ x) == f x
08:53:06 <lambdabot>   "OK, passed 500 tests."
08:53:19 <fasta> Berengal, I am tired, but what do you mean by "applying a pattern".
08:53:29 <zygoloid> Berengal: do you have a motivating case which doesn't involve view patterns?
08:53:48 <tensorpudding> @check let f a b = a+b in \x -> (((curry . uncurry) f) $ x) == f x
08:53:49 <lambdabot>   No instance for (GHC.Classes.Eq (b -> b))
08:53:49 <lambdabot>    arising from a use of `GHC.Cla...
08:54:00 <Berengal> fasta: Trying to match a value to a pattern
08:54:13 <Berengal> zygoloid: Not really. You can get by with pattern guards too.
08:54:48 <Berengal> (Which I think is better than view patterns anyway, except for small VPs
08:54:49 <fasta> Berengal, ah, a kind of unification.
08:54:51 <Berengal> )
08:55:30 <fasta> Berengal, yes, I used unification based pattern matching systems and they are great.
08:55:32 <tensorpudding> @check let f a b = a+b; g = curry $ uncurry f in \x y -> g x y == f x y
08:55:33 <lambdabot>   "OK, passed 500 tests."
08:56:24 <Berengal> fasta: Maybe it adds the possibility of composable patterns too?
08:58:42 <Berengal> letpat head = <(x:_)> -> x; tail = <(_:xs)> -> xs in \(<head U tail> -> x xs) -> show x ++ show xs
08:59:09 * Berengal is apparantly on a syntactic sugar rush
09:00:45 <Berengal> It'd be great to have some first-class patterns though. I'm currently working on faking them in a DSL...
09:02:02 <etpace> Hmm, I have say x :: IO (Maybe (IORef Expr)), how can I get expr out? expr = x >>= \mb -> return $ fromJust mb >>= \ref -> readIORef ref?
09:03:23 <etpace> :t makeIORef (Just 5)
09:03:24 <lambdabot> Not in scope: `makeIORef'
09:03:36 <etpace> :t newIORef (Just 5)
09:03:37 <lambdabot> Not in scope: `newIORef'
09:03:50 <Berengal> fmap (fmap readIORef)
09:03:52 <Berengal> Maybe...
09:07:12 <etpace> fmap (fmap readIORef) >>= fromJust works, cheers Berengal
09:09:33 <zygoloid> @type fmap (fmap ?readIORef) >>= fromJust
09:09:34 <lambdabot>     Occurs check: cannot construct the infinite type:
09:09:34 <lambdabot>       f = (->) (Maybe (f a))
09:09:34 <lambdabot>     Probable cause: `fromJust' is applied to too many arguments
09:10:26 * Itkovian is awaiting his hackage username
09:10:37 <McManiaC> how do you put sth like "Integral a => ..." into a data statement?
09:10:44 <chrisdone> Itkovian: what ya gonna upload?
09:11:06 <zygoloid> McManiaC: depends what you're trying to achieve
09:11:07 <Itkovian> chrisdone: the preliminary draft of a lib to interface with Mollom (http://mollom.com)
09:11:22 <Itkovian> It works, but needs some work to be really cool
09:11:32 <McManiaC> zygoloid: data Foo = Integral a => Foo a [a]
09:11:33 <chrisdone> nice
09:11:44 <Itkovian> i.e., some monadic stuff to hide things and some configuration options etc.
09:12:26 <Itkovian> the downside is: I'm using both darcs and git to keep track
09:12:42 <chrisdone> why?
09:12:44 <Itkovian> so I can use github, which I like
09:12:45 <Itkovian> but mv a file can only be done once :-(
09:12:54 <MissPiggy> McManiaC: just do data Foo a = Foo a [a]
09:12:59 <MissPiggy> then you write functions like
09:13:03 <MissPiggy> f :: Foo a => f a -> ...
09:13:08 <MissPiggy> oops not that :P
09:13:13 <MissPiggy> f :: Integral a => Foo a -> ...
09:13:16 * aksionov has refactored his code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23038#a23047
09:13:51 <chrisdone> aksionov: any chance of reformatting it?
09:14:17 <chrisdone> so one can read it in split view
09:14:34 <aksionov> chrisdone: diff ?
09:14:55 <Itkovian> Wow! Talk about fast service!
09:14:59 <Itkovian> Got it!
09:14:59 <zygoloid> McManiaC: you want 'data Foo = ..' not 'data Foo a = ...'?
09:15:15 <McManiaC> I'd prefer that, yeh
09:15:18 <zygoloid> McManiaC: that is, you want type 'Foo' to contain some Integral thing, but you don't know what?
09:15:28 <McManiaC> exactly
09:15:32 <zygoloid> that's called an existential.
09:15:35 <aksionov> chrisdone: http://patch-tag.com/r/abbe/httpd2/snapshot/hash/20100226170604-39ae5-e62df0792256b2559ce34fca879b7cc73e1d9537/patch
09:15:39 <MissPiggy> McManiaC: so what I said doesn't work?
09:15:47 <MissPiggy> for what you are doing
09:16:00 <chrisdone> didn't hpaste used to do diffs?
09:16:55 <zygoloid> McManiaC: if that's what you want, then 'data Foo = forall a. Integral a => Foo a [a]' should work
09:17:01 <zygoloid> you'll need -XExistentialQuantification
09:17:08 <aksionov> at least I can't seem to find it.
09:17:28 <MissPiggy> isn't it  data Foo where Foo :: Integral a => a -> [a] -> Foo ?
09:17:35 <zygoloid> McManiaC: but where possible you should prefer MissPiggy's approach
09:17:36 <Itkovian> Yes!
09:17:44 * hackagebot hMollom 0.1 - Library to interact with the Mollom anti-spam service  http://hackage.haskell.org/package/hMollom-0.1 (AndyGeorges)
09:17:53 <zygoloid> MissPiggy: that's an alternative way of writing it with GADT syntax, yes
09:18:20 <McManiaC> zygoloid: ok thx
09:20:21 <Paczesiowa> :t \f -> let x = undefined; y = f x in x
09:20:22 <lambdabot> forall a t a1. (a -> t) -> a1
09:20:33 <Paczesiowa> why a != a1?
09:21:26 <copumpkin> Paczesiowa: you don't constrain it
09:21:30 <copumpkin> let bindings are polymorphic
09:21:35 <maltem> Paczesiowa, I guess one is allowed to be e.g. more general than the other
09:21:37 <zygoloid> because x :: forall b. b, and nothing is forcign it to be monomorphic
09:21:56 <copumpkin> :t \f -> case undefined of x -> let y = f x in x
09:21:57 <lambdabot> forall a t. (a -> t) -> a
09:21:57 <Paczesiowa> didn't let bindings supposed to be monomorphic?
09:22:02 <copumpkin> nope
09:22:06 <zygoloid> > let x = []; y = head x + 1 in x ++ "hello"
09:22:07 <lambdabot>   "hello"
09:22:24 <zygoloid> istr there's a ghc extension to make them monomorphic
09:22:38 <copumpkin> they won't be as polymorphic as they used to be, apparently
09:22:49 <copumpkin> but they won't be monomorphic (that would break a lot of things)
09:23:08 <copumpkin> (iirc)
09:23:22 * zygoloid was thinking of -XMonoPatBinds, i think
09:24:02 <Paczesiowa> copumpkin: that case undefined of trick works ok
09:24:23 <copumpkin> case bindings are monomorphic (that's how function parameters are handled) and let bindings are polymorphic
09:26:40 <Paczesiowa> copumpkin: but case is strict:/
09:26:56 <copumpkin> that's a separate issue :)
09:26:59 <zygoloid> no. pattern-matching is strict.
09:27:08 <zygoloid> > case undefined of _ -> "hello"
09:27:09 <lambdabot>   "hello"
09:27:37 <maltem> > let x = 12 in (x :: Double, x :: Integer) -- let bindings are monomorphic in this sense
09:27:37 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
09:27:38 <lambdabot>         agains...
09:28:03 <Saizan> that's just the MonomorphismRestriction
09:28:12 <copumpkin> yeah, in general it is possible
09:28:15 <Saizan> which works only when there are typeclasses involved
09:28:28 <copumpkin> you can make case bindings polymorphic too, using higher-rank polymorphism
09:28:54 <copumpkin> :t let f :: (forall n. Num n => n) -> (Double, Integer); f x = (x, x) in f
09:28:55 <lambdabot> (forall n. (Num n) => n) -> (Double, Integer)
09:29:03 <copumpkin> > let f :: (forall n. Num n => n) -> (Double, Integer); f x = (x, x) in f 5
09:29:04 <lambdabot>   (5.0,5)
09:29:18 <maltem> Yeah I even was a little surprised that lambdabot does not turn off the MR
09:29:34 <copumpkin> for a while it was off I think, but in the move I think it went back on
09:29:49 <tARrAScH> Hi! What's the best way to force the compiler to believe you're dealing with Ints and not Integers, I'm having a normal list comprehension and it turns my Ints to Integers. Any Ideas?
09:30:04 <copumpkin> tARrAScH: give it a type :)
09:30:27 <copumpkin> x :: [Int], for example
09:30:36 <zygoloid> you can change the list of types which are used on a per-module basis by using a 'default' declaration
09:34:26 <Paczesiowa> > show $ read "()"
09:34:27 <lambdabot>   "()"
09:34:35 <Paczesiowa> magic of defaults
09:34:51 <ben> > show $ read "(1)"
09:34:51 <copumpkin> ugh :)
09:34:52 <lambdabot>   "* Exception: Prelude.read: no parse
09:35:36 <Paczesiowa> > show $ read "() hello world!"
09:35:37 <lambdabot>   "* Exception: Prelude.read: no parse
09:35:49 <Paczesiowa> > show $ read "()                            "
09:35:50 <lambdabot>   "()"
09:36:13 <copumpkin> > show $ reads "() hello world"
09:36:14 <lambdabot>   "[((),\" hello world\")]"
09:40:17 <chrisdone> aksionov: here's how I'd format it, not saying this is standard way, though 80 cols is recommended in most style guides, removed some unnecessary parens and tidied: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23038#a23050
09:40:36 <chrisdone> aksionov: again, not saying I know what's best, just what I like!
09:41:19 <aksionov> nice, thanks chrisdone :)
09:42:09 <chrisdone> sure!
09:42:36 <aksionov> chrisdone: thanks again for refactoring :)
09:42:38 <zygoloid> personally i'd not use that instance of Show HttpResponseType
09:42:52 <chrisdone> aksionov: I'd probably have all the response types in different funcs but I guess you were planning that anyway
09:42:57 <zygoloid> it's never seemed right to me to hijack "show" as a convenient name for a function :: a -> String
09:43:38 <copumpkin> it's also almost identical to the original one that would be autogenerated
09:43:48 <copumpkin> oh, for the HttpResponse
09:44:00 <copumpkin> I agree the HttpResponseType isn't the best idea
09:44:54 <chrisdone> 803 visits to tryhaskell.org in two days, woot
09:45:26 <chrisdone> 00:00:45 Avg. Time on Site
09:45:31 <chrisdone> not for long one I add a tutorial!!
09:45:55 <tARrAScH> Is there any (Char -> String) like show that doesn't append the "'" ?
09:46:21 <tARrAScH> oh that's just []
09:46:22 <quicksilver> why not just use :[] ?
09:46:26 <Paczesiowa> > let foo = :[] in foo 'c'
09:46:26 <tARrAScH> nm :p
09:46:26 <aksionov> copumpkin: okay, why having HttpResponseType isn't recommended ?
09:46:27 <lambdabot>   <no location info>: parse error on input `:'
09:46:28 <zygoloid> chrisdone: support for 'data' would be nice :)
09:46:34 <Paczesiowa> > let foo = (:[]) in foo 'c'
09:46:35 <lambdabot>   "c"
09:46:36 <copumpkin> aksionov: just the Show instance for it
09:46:44 <chrisdone> zygoloid: oh you cheeky devil!
09:46:45 <copumpkin> aksionov: Show typically tends to emit valid haskell code
09:46:48 <SamB_XP> @quote :[
09:46:49 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 2,"Invalid regular expression")
09:46:56 <SamB_XP> @quote :\[
09:46:56 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
09:46:59 <SamB_XP> @quote :\[
09:46:59 <lambdabot> ook says: (:[])
09:47:01 <SamB_XP> @quote :\[
09:47:01 <lambdabot> dcoutts says: (:[]) looks like a monster
09:47:04 <SamB_XP> @quote :\[
09:47:05 <lambdabot> dcoutts says: (:[]) looks like a monster
09:47:08 <aksionov> copumpkin: oh, okay, thanks.
09:47:12 <SamB_XP> @quote comment.*:\[
09:47:12 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
09:47:39 <aksionov> copumpkin: so you can 'read' what 'show' generated, right ?
09:47:41 <zygoloid> chrisdone: it also doesn't like comments :)
09:47:48 <chrisdone> the omnomnoperator
09:48:02 <copumpkin> aksionov: yeah, but also have it be valid haskell syntax :) no law states this, but it's a common convention
09:48:14 <chrisdone> zygoloid: it does! what expression demonstrates your claim?
09:48:30 <SamB_XP> > (:[{- Help! -}])
09:48:31 <lambdabot>   {()->[()]}
09:48:41 <SamB_XP> hmm, I think it *does* like comments
09:48:42 <aksionov> copumpkin: okay, and is there any link where such coding conventions are mentioned ?
09:48:45 <SamB_XP> for dinner!
09:48:50 <copumpkin> aksionov: not that I know of :)
09:48:52 <chrisdone> drum roll
09:49:01 <aksionov> sigh!
09:49:06 <chrisdone> aksionov: this one's pretty good: http://urchin.earth.li/~ian/style/haskell.html
09:49:27 <chrisdone> oh, sorry, I thought you meant style
09:49:35 <zygoloid> chrisdone: no /expression/ demonstrates my claim. but the input "-- hello" is rejected :)
09:49:57 <aksionov> chrisdone: np, thats also nice. But I'm looking for coding conventions though.
09:50:03 <chrisdone> zygoloid: I could make the console just ignore everything after -- :p
09:50:03 <zygoloid> (or at least, none that i know of)
09:50:19 <SamB_XP> > read "-- hi\n()"
09:50:20 <lambdabot>   * Exception: Prelude.read: no parse
09:50:23 <chrisdone> in before zygloid says "sorry what you said after "after" was cut off)
09:50:24 <SamB_XP> > read "-- hi\n()" :: ()
09:50:25 <lambdabot>   * Exception: Prelude.read: no parse
09:50:59 <chrisdone> > -- sausage
09:51:00 <lambdabot>   not an expression: `-- sausage'
09:51:12 <chrisdone> even lambdabot concurs
09:51:12 <dons> fusion makes fp fun. http://www.reddit.com/r/programming/comments/b6wf7/fusion_makes_functional_programming_fun/
09:51:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:51:14 <chrisdone> she has no conviction
09:51:17 <copumpkin> chrisdone loves the sausage
09:51:20 <zygoloid> i've never seen a haskell style guide which actually says how to format code :(
09:51:25 <SamB_XP> chrisdone: but she doesn't take multi-line inputs
09:52:06 <djahandarie> dons, nice
09:52:21 <chrisdone> zygoloid: why don't you write one?
09:52:23 <dons> zygoloid: there's a great one by igloo
09:52:39 <copumpkin> tibbe has one too I think
09:52:41 <copumpkin> on his github
09:52:54 <zygoloid> chrisdone: my layout style is unorthodox; i'm looking to learn rather than teach :)
09:53:01 <Paczesiowa> it starts like a poem
09:53:01 <dons> Igloo: where's your style guide?
09:53:45 <ksf> does llvm have a jvm backend?
09:53:54 <dons> http://urchin.earth.li/~ian/style/haskell.html
09:53:55 <copumpkin> I doubt it
09:54:03 <ksf> more generally, is there a list of targets llvm supports?
09:54:03 <dons> i think there is an llvm bytecode to jvm thing somewhere
09:54:29 <chrisdone> thought llvm was way more low level than the jvm?
09:54:36 <dons> ksf: yeah, $ llc --version
09:54:48 <dons> it's not a jvm. it's a code generator.
09:55:01 <dons> at least, we don't use it for vm capabilities
09:55:14 <ksf> ...lists x86 and x86-64 for me
09:55:29 <zygoloid> dons: that's the one i was just unhappy with. it doesn't say how to lay code out, just to use layout :)
09:55:33 <dons> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23051#a23051
09:55:51 <ksf> ...and there don't seem to be use flags to enable java
09:56:42 <dons> it's certainly not built in.
09:57:05 <zygoloid> http://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md <-- this one seems a bit more complete
09:57:14 <ksf> oh, there: http://da.vidr.cc/projects/lljvm/
09:57:41 <dons> it's probably the easiest path to a jvm backend we have
09:58:12 <ksf> ...using the wonderful http://jasmin.sourceforge.net/
09:58:15 <copumpkin> foreign import jvmcall
09:58:40 <zygoloid> would a 'foreign import thiscall' be interesting to anyone?
09:58:43 <ksf> it's been fun messing around with jasmin to produce code that disassemblers choke on...
09:58:56 <copumpkin> zygoloid: the more calling conventions the merrier
10:05:50 <wagle> $ sudo cabal update
10:05:50 <wagle> Downloading the latest package list from hackage.haskell.org
10:05:50 <wagle> Note: there is a new version of cabal-install available.
10:05:50 <wagle> To upgrade, run: cabal install cabal-install
10:05:54 <wagle> ...
10:06:08 <SamB_XP> wouldn't one thiscall be sufficient for both MS and borland compilers ?
10:06:20 <SamB_XP> er. *would*?
10:06:22 <wagle> i do that, in updates cabal install, but then i get the same when i try update again
10:06:37 <wagle> s/in/it/
10:06:55 <zygoloid> SamB_XP: probably not, but i'm only really interested in the cxxabi thiscall :)
10:06:59 <c_wraith> wagle: path issue.  You're updating ~/.cabal/bin/cabal, but that's not the first cabal in your path
10:07:05 <zakwilson> Let's say I have a bunch (100-50,000) of keys and values. The keys are a custom data type, but could be easily serialized to ASCII. The values are Ints. What data structure is going to give me the fastest lookups? A hash table?
10:07:21 <copumpkin> zakwilson: a Data.Map
10:07:37 <copumpkin> if the keys could easily be converted to and from Ints, you'd be better off with an IntMap
10:09:00 <zakwilson> The keys cannot be easily converted to and from Ints (they'd need a map of their own for that purpose)
10:09:36 <zakwilson> There will be *many* keys, and several thousand tables.
10:09:50 <wagle> c_wraith: looks like thaqt is it..  thanks
10:10:15 <copumpkin> zakwilson: try Data.Map, then
10:10:37 <copumpkin> if your keys are easily Ord, don't even convert to and from strings
10:10:43 <zakwilson> I'm working on a text classifier, roughly modled after CRM114's hyperspace classifier, but using *many* categories, instead of the usual spam/ham.
10:10:53 <dankna> sounds interesting
10:13:39 <zakwilson> They're not easily Ord. They're orthogonal sparse bigrams, which are pretty naturally represented as lists of strings. I'm currently using my own Element type with values for Skip and EOL, but it wouldn't be hard to make strings out of that.
10:13:58 <copumpkin> lists of strings are automatically ord
10:14:06 <c_wraith> Ord doesn't have to mean anything for Data.Map, it just needs to be consistent
10:14:09 <dankna> lists of strings sounds orderable - order by the first string in the list, in the case of a tie fall back to the second and so on
10:15:14 <dankna> oh, hm, I see what you mean.  it's actually representing a set.... but still, as long as the sparse representation is canonical (same set always represented in the same way) you can order it that way
10:17:26 <choffstein> Anyone know of a column-oriented database that haskell might have bindings to?
10:17:57 <c_wraith> aren't column-oriented databases sort of rare?
10:19:06 <choffstein> yep, a bit rare
10:19:11 <choffstein> But getting more popular
10:19:13 <c_wraith> anyway, I don't think there are any column-oriented db bindings on hackage
10:19:50 <choffstein> Yeah, I didn't see any obvious ones.  Just wondering if there was a dusty package hidden away somewhere.  Looks like MonetDB stopped supporting Haskell (or at least their latest build broke the API)
10:21:13 <zakwilson> I guess the keys are easily Ord. I hadn't really thought about them that way.
10:21:41 <zakwilson> And I'm a perpetual newbie when it comes to Haskell.
10:23:47 <chrisdone> zakwilson: aren't we all? :D
10:25:18 <zakwilson> chrisdone: perhaps. If languages that change the way you think about programming are worth learning, Haskell is quite worthwhile.
10:29:22 <mreh> {-# OPTIONS_GHC -XRank2Types -XScopedTypeVariables #-} is that a valid language pragma?
10:29:27 <MissPiggy> github things my program is 77% verilog XD
10:29:40 <copumpkin> MissPiggy: all those .v files probably?
10:29:41 <MissPiggy> 23% haskell
10:29:43 <MissPiggy> yes
10:29:43 <aavogt> mreh: {-# LANGUAGE Rank2Types, ... #-}
10:29:53 <aavogt> but the options_ghc should be accepted
10:29:54 <mreh> aavogt: that's why it didnt't work
10:30:07 <mreh> aavogt: commas required?
10:30:11 <copumpkin> yep
10:30:14 <aavogt> commas in language pragmas
10:30:25 <aavogt> but I don't believe you need them for OPTIONS_GHC
10:30:25 <mreh> it just fails silently, not telling me!
10:30:35 <mreh> oh
10:30:50 <mreh> well, my scoped type variables should be working, let me try commas
10:31:31 <mreh> you were right, no commas in an options
10:32:00 <MissPiggy> git has add but not subtract?
10:32:12 <MissPiggy> oh git rm
10:32:17 <mreh> could you say if scoped type variables work in do blocks?
10:33:03 <Paczesiowa> mreh: remember, functions need explicit foralls
10:33:12 <copumpkin> MissPiggy: you don't need to ask git to do it
10:33:17 <copumpkin> just delete the file and it will notice that it's gone
10:33:20 * hackagebot wxdirect 0.12.1.2 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.12.1.2 (DanielFischer)
10:36:24 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23052#a23052
10:36:57 <mreh> check the scoped type variables in the function body, the compiler doesn't equate the a with the a in the enclosing scope
10:37:01 <mreh> the same with the bs
10:37:27 <copumpkin> you need a forall
10:38:32 <mreh> copumpkin: could you show me?
10:38:53 <mreh> in the top level?
10:38:57 <copumpkin> nextGeneration :: forall g b a. (RandomGen g, Num b, Ord b, Random b) =>
10:39:05 <copumpkin> if you have ScopedTypeVariables enabled
10:40:18 <Paczesiowa> everybody gets bitten by this requirement in functions
10:40:43 <mreh> well, it's only required with scoped type variables :)
10:41:23 <mreh> i've got a **** infinite type, and I can't find where it's occurring
10:41:48 <mreh> does that kind of thing happen with the declaration of a function, or the usage?
10:42:03 <mreh> i've fully specified its type signature
10:42:19 <Paczesiowa> mreh: paste
10:42:26 <mreh> it's pretty long :)
10:42:28 <mreh> okay
10:42:32 <Paczesiowa> mreh: with error
10:42:40 <mreh> on it
10:43:26 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23054#a23054
10:43:46 <mreh> it's only a pissy optimisation, it's ruined my whole module!
10:44:26 * hackagebot wxcore 0.12.1.3 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.12.1.3 (DanielFischer)
10:45:11 <Paczesiowa> mreh: well, you can always start adding types to subexpressions
10:45:21 <Paczesiowa> sooner or later the error will be clearer
10:45:24 <McManiaC>     Ambiguous module name `Control.Monad.Trans':
10:45:24 <McManiaC>       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
10:45:25 <McManiaC> hmmm
10:45:31 <McManiaC> solution to this?
10:45:38 <mreh> Paczesiowa, that was my first though
10:45:38 <Paczesiowa> McManiaC: ghc-pkg hide transformers
10:45:40 <mreh> t
10:45:57 <Paczesiowa> McManiaC: or PackageImports
10:46:03 <mauke> mreh: I think the error is in the definition of nextGeneration
10:46:13 <McManiaC> Paczesiowa: kay, thx
10:46:17 <mauke> and it happens during internal type checking
10:46:17 <chrisdone> is [a,b] actually syntactic sugar so that if I redefine (:) will it take on that behaviour?
10:46:41 <mauke> chrisdone: you need a ghc extension for that, otherwise it will always use Prelude.:
10:46:46 <Paczesiowa> chrisdone: use NoImplicitPrelude
10:47:03 <Berengal> I wish you could get ghci to infer types of subexpressions for you
10:47:21 <chrisdone> I know how to use NoImplicitPrelude, I was just curious if [] was maybe optimised for lists and didn't depend on (:)
10:47:35 <SubStack> @pl \x y -> snd x == snd y
10:47:35 <lambdabot> (. snd) . (==) . snd
10:47:41 <mauke> mreh: map fst looks dubious in the definition of pop'
10:48:27 * hackagebot wx 0.12.1.3 - wxHaskell  http://hackage.haskell.org/package/wx-0.12.1.3 (DanielFischer)
10:48:39 <mreh> mauke: i added a type signature to it, that was fine
10:49:08 <Guest25518> hi all. Is there an easy way to apply a function n times?
10:49:20 <Paczesiowa> mreh: fitnessProportionalSelection returns [a], you can't fst it
10:49:34 <McManiaC> fuuuuuuuuucking ghc 6.12
10:49:35 <McManiaC> <command line>: unknown package: hslogger-1.0.7
10:49:40 <Guest25518> for example, if I want foo $ foo $ foo ... x
10:49:41 <Paczesiowa> > take 10 $ iterate (+1) 0
10:49:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
10:49:42 <McManiaC> I *have* it installed
10:49:50 <Paczesiowa> > iterate (+1) 0 !! 10
10:49:51 <lambdabot>   10
10:50:04 <mreh> Paczesiowa, well spotted that man
10:50:07 <mreh> cheers
10:50:07 <mauke> > iterate f x !! 7
10:50:08 <lambdabot>   f (f (f (f (f (f (f x))))))
10:50:13 <mauke> mreh: told you so
10:50:13 <Guest25518> sweet
10:50:23 <Paczesiowa> > iterate z x !! 7
10:50:24 <lambdabot>   Couldn't match expected type `a -> a'
10:50:24 <lambdabot>         against inferred type `Simple...
10:50:26 <mreh> mauke: I was looking at the other map fst :D
10:50:28 <mreh> honest!
10:50:44 <Paczesiowa> mauke: it only works for "f" ?
10:50:50 <mauke> that's why I said "in the definition of pop'"
10:51:07 <mauke> > iterate g x !! 7
10:51:08 <lambdabot>   g (g (g (g (g (g (g x))))))
10:51:17 <Paczesiowa> > iterate h x !! 7
10:51:18 <lambdabot>   h (h (h (h (h (h (h x))))))
10:51:21 <Paczesiowa> > iterate u x !! 7
10:51:22 <lambdabot>   Couldn't match expected type `a -> a'
10:51:22 <lambdabot>         against inferred type `Simple...
10:51:33 <pikhq> :t f
10:51:34 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:51:44 <mauke> > iterate (fun "Paczesiowa") x !! 3
10:51:45 <lambdabot>   Paczesiowa (Paczesiowa (Paczesiowa x))
10:51:57 <Paczesiowa> :t fun
10:51:58 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
10:54:04 <mreh> :t (!!)
10:54:05 <lambdabot> forall a. [a] -> Int -> a
10:54:20 <mreh> :t iterate
10:54:21 <lambdabot> forall a. (a -> a) -> a -> [a]
10:54:31 <mreh> ah
10:55:45 <Paczesiowa> > let _ = 2 in _
10:55:46 <lambdabot>   Pattern syntax in expression context: _
10:55:53 <Paczesiowa> > let _ = 2
10:55:54 <lambdabot>   not an expression: `let _ = 2'
10:55:57 <zygoloid> chrisdone: since you can't even define a constructor called (:) i think it doesn't matter
10:56:56 <Paczesiowa> > let __ = 2 in __
10:56:57 <lambdabot>   2
10:57:07 <Paczesiowa> > let _x = 2 in _x
10:57:08 <lambdabot>   2
10:57:29 <mreh> > let 1 = 2 in 1
10:57:30 <lambdabot>   1
10:57:53 <mreh> Caleskell?
10:57:58 <copumpkin> no, just haskell
10:58:00 <zygoloid> laziness
10:58:25 <zygoloid> > let (Just x) = last (repeat Nothing) ++ [Just 42] in y
10:58:26 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
10:58:26 <lambdabot>         against inferred ...
10:58:42 <zygoloid> > let (Just x) = last (repeat Nothing ++ [Just 42]) in y
10:58:43 <lambdabot>   y
10:58:57 <copumpkin> someone should write a function
10:59:09 <copumpkin> @let usefulFunction x y = repeat x ++ [y]
10:59:10 <zygoloid> > let f x = 42
10:59:10 <lambdabot>  Defined.
10:59:11 <lambdabot>   not an expression: `let f x = 42'
10:59:22 <zygoloid> copumpkin: oh, not just any function :)
10:59:29 <cebewee> hm. why can one redefine 1 if one cannot access it afterwards?
10:59:31 <copumpkin> nope, the most useful!
10:59:36 <copumpkin> cebewee: you can't redefine 1
11:00:01 <zygoloid> cebewee: let 1 = 2 in .. just pattern matches 2 against 1. or at least it would if anything depended on the result.
11:00:06 <zygoloid> due to laziness, it does... nothing.
11:00:37 <zygoloid> > let (True, b) = (False, True) in 42
11:00:38 <lambdabot>   42
11:00:43 <zygoloid> ^^ it's no different from that
11:00:56 <copumpkin> > let (!True, b) = (False, True) in 42
11:00:57 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
11:01:06 <zygoloid> > let !2 = 1 in "Hello"
11:01:06 <lambdabot>   "* Exception: <interactive>:1:141-146: Non-exhaustive patterns in pattern b...
11:01:36 <choffstein> Anyone used Thrift with Haskell?
11:01:50 <erl_> hello, how an identity function can be denoted?  to write "foo  a b = ID" instead of  "foo  a b c = c"
11:02:01 <xerox> > let !(~2) = 1 in 42
11:02:02 <lambdabot>   42
11:02:07 <zygoloid> erl_: foo a b = id
11:02:22 <cebewee> zygoloid: makes sense, thanks
11:02:37 <jiyunatori> hi there. i have a weird problem with HDBC and string encoding. here it is http://pastebin.ca/1812205 - the string from the database is the first one. the second one is there to compare. as you can see, the "à" is encoded respectively as \195\160 and \224
11:02:57 <McManiaC> >.<
11:03:00 <erl_> zygoloid, that's it, thanks
11:03:09 <McManiaC> am I the only one who has so many problems with ghc 6.12?
11:03:15 <Berengal> jiyunatori: What encoding does your db use?
11:03:21 <Paczesiowa> McManiaC: what problems?
11:03:25 <mauke> first one is utf-8
11:03:31 <choffstein> McManiaC: Nope, half the packages I want won't work
11:03:36 <McManiaC> Paczesiowa: ghc-pkg "forgetting" that I installed packages etc
11:03:42 <McManiaC> *is
11:03:52 <Paczesiowa> choffstein: file bugs
11:04:01 <choffstein> Paczesiowa: Hokay.
11:04:25 <Berengal> McManiaC: Do you have another ghc installed?
11:04:29 <McManiaC> even multiple "rm -rf /usr/lib/ghc-* ~/.ghc ~/.cabal" etc couldnt help
11:04:31 <McManiaC> no
11:04:36 <Paczesiowa> choffstein: I've filed one and I almost got spj and oleg to participate in a flamewar
11:04:45 <jiyunatori> Berengal: phpmyadmin says "utf8_general_ci" at one place, and "latin1_swedish_ci" in front of each table (i don't know why, by the way)
11:04:47 <Guest42315> http://www.haskell.org/haskellwiki/Haskell_in_5_steps says that let fac n = if n == 0 then 1 else n * fac (n-1) will define a function (like ocaml's let). but I can use only let .. in, like let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
11:04:47 <Guest42315> is that right?
11:04:49 <Berengal> McManiaC: Do you have documentation turned on in your cabal config?
11:05:05 <McManiaC> Berengal: not after rm -rf ~/.cabal ;)
11:05:36 <Berengal> jiyunatori: Probably making them all use the same encoding is a good idea
11:05:52 <Berengal> jiyunatori: Or figure out what all the encoding settings mean. I never did...
11:06:19 <seanmcl> Hi,  I'm getting the warning "ld warning: atom sorting error for ...(mashed name)..." when I use EmptyDataDecls.  Can I safely ignore this warning?
11:06:28 <copumpkin> yep
11:06:33 <seanmcl> copumpkin: thanks
11:06:49 <jiyunatori> Berengal: ok, so the problem might be upstream. i'm investigating that.
11:07:10 <Berengal> jiyunatori: The problem is a mismatch somewhere. Easiest way to fix that is to make everything the same
11:07:48 <Berengal> jiyunatori: You also need to make sure you're reading the strings as utf-8 on the application level. It looks like that's what you're getting out, but it's not being decoded
11:08:06 <Guest42315> hello?
11:08:59 <sepp2k> Guest42315: let always needs an "in" except within do-blocks. However you don't need let to define "top-level" functions.
11:09:01 <Berengal> Guest42315: You can only use lets without a matching in in do-syntax
11:09:19 <sepp2k> (I'm not sure whether that's what you were asking)
11:10:37 <floydophone> is there a way to pattern match a string in haskell? i.e. if i want to write a function like func 'A':xs = ..., except use a string instead of a character?
11:10:50 <mauke> floydophone: sadly, no
11:10:57 <floydophone> damn
11:11:26 <floydophone> mauke: before i go off and port Python's string functions to haskell, has someone already done it?
11:11:38 <mauke> I don't know python
11:11:45 <maltem> floydophone, a (non-)solution is to use isPrefixOf
11:12:08 <floydophone> maltem: do i need to import anything (sorry, newbie here)
11:12:15 <floydophone> actually, ill just google.
11:12:18 <maltem> @index isPrefixOf
11:12:18 <lambdabot> Data.List
11:12:32 <mauke> @hoogle isPrefixOf
11:12:32 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
11:12:32 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
11:12:32 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
11:12:45 <floydophone> oh wow, that is cool
11:12:49 <mauke> dropPrefix :: (Eq a) => [a] -> [a] -> Maybe [a]  -- would be nice
11:13:19 <Guest42315> sepp2k, Berengal, ok but then is http://www.haskell.org/haskellwiki/Haskell_in_5_steps wrong?
11:13:41 <Guest42315> If I type that without the let, fac n = if n == 0 then 1 else n * fac (n-1), hugs says ERROR - Syntax error in input (unexpected `=')
11:13:58 <mauke> Guest42315: you can't define stuff in hugs
11:14:04 <mauke> use a file
11:14:04 <tromp> only evaluate
11:14:08 <mauke> (or ghci)
11:14:20 <Guest42315> why? o.o
11:14:30 <mauke> Guest42315: Congratulations! Programming made easy. Note that if you're using Hugs, you'll need to load the definition of fac from a file, fac.hs, containing:
11:14:33 <mauke> reading helps
11:14:36 * hackagebot strict-concurrency 0.2.3 - Strict concurrency abstractions  http://hackage.haskell.org/package/strict-concurrency-0.2.3 (DonaldStewart)
11:14:44 <Guest42315> is this by design?
11:14:58 <Guest42315> or it's a bug?
11:15:05 <mauke> Guest42315: just not implemented
11:15:13 <Guest42315> hm
11:15:19 <maltem> If that wiki page proposes either ghci or hugs, and then gives an example that does not work in hugs, then I agree that's not too nice
11:15:24 <zygoloid> Guest42315: neither hugs nor ghci are interactive haskell prompts where you can just type code as it would be in a .hs file
11:15:27 <Guest42315> :load? .. I will try with #!/usr/bin/runhugs
11:15:40 <mauke> Guest42315: ?
11:15:41 <burp> what's wrong with ghci?
11:16:24 <maltem> But wait, the wiki page does state that it won't work in hugs
11:16:37 <mauke> maltem: yes, that's what I said
11:16:46 <Guest42315> ah
11:16:52 <maltem> mauke, ah indeed
11:17:14 <Guest42315> hahaha ok..
11:17:56 <Berengal> Hugs and ghci are REPLs. They evaluate expressions. Definitions aren't expressions
11:18:09 <medfly> REPL?
11:18:11 <dankna> strictly, you CAN define things, at least in ghci
11:18:32 <Berengal> dankna: No, it's more of a big expression
11:18:33 <copumpkin> medfly: read eval print loop
11:18:46 <sepp2k> Berengal: To be fair most REPLs (for other languages) do allow you to define stuff. So it's not an unreasonable assumption, that you'd be able to.
11:18:58 <dankna> well, I just mean that it recognizes the syntax foo <- doFoo for things in IO and let foo = computeFoo for things not in IO
11:19:09 <medfly> okay, thanks
11:19:17 <Berengal> sepp2k: Indeed, but in most other languages definitions are expressions (lisp) or statements
11:19:33 <Berengal> And you can have definitions inside expressions, they just don't look like top-level definitions
11:19:56 <Guest42315> there are some REPLs that will work with definitions, in another languages. or you will not call them "eval" because you can't evaluate a definition?
11:19:59 <dankna> okay.  I see the distinction you're making.
11:20:42 <Guest42315> (in ocaml you can't evaluate a definition and the interpreter - sometimes called repl - can define things)
11:21:02 <Berengal> Guest42315: The point is that definitions are "timeless" in haskell. It doesn't matter in which order you write them. In most other languages it does matter
11:21:18 <Berengal> Also, the implementers are lazy
11:21:19 <medfly> heh, you can just prepend "let definitions in" to everything :)
11:21:25 <Guest42315> hmm
11:21:38 <Guest42315> :)
11:21:40 <lament> justifying not being able to define things by saying "it's a REPL, you don't really evaluate definitions" is simply trying to get away on a technicality from what's obviously a missing major feature
11:21:49 <Guest42315> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23056#a23056 this works. but, a function can just print something..? wasn't that supposed to harder? this looks like a regular imperative language (or at least a impure functional language, like ocaml)
11:21:59 <Guest42315> will this reasoning fail with more complex examples?
11:22:11 <copumpkin> lament is lamenting
11:22:13 <Berengal> lament: Well, yes. Except I don't think it's a major feature
11:22:24 <mauke> Guest42315: pfac 10 doesn't actually print anything :-)
11:22:34 <mauke> Guest42315: it constructs an IO object
11:22:45 <maltem> Hah, now they complain about I/O being too easy in Haskell
11:22:50 <medfly> heh
11:22:52 <copumpkin> hm
11:22:54 <copumpkin> wait
11:23:06 <Guest42315> there is a hidden io-thing implicit with main = something, right?
11:23:07 <mauke> Guest42315: here's my take on this: http://mauke.ath.cx/stuff/haskell/how-to-io.html
11:23:11 <copumpkin> oh I see what you're talking about
11:23:20 <SamB_XP> Guest42315: yeah!
11:23:26 <Guest42315> no, i meant, i was thinking it would be harder
11:23:55 <mauke> Guest42315: well, you could do it like this: http://mauke.ath.cx/stuff/haskell/hell.hs :-D
11:24:00 <Guest42315> so technically someone can write simple programs without noticing haskell isn't imperative.. right? o.o
11:24:08 <mauke> yes
11:24:16 <SamB_XP> it IS imperative
11:24:23 <mauke> NO U
11:24:24 <SamB_XP> it does imperative better than other languages, even ;-P
11:24:32 <SamB_XP> you don't just have this IO thing
11:24:44 <Berengal> Guest42315: "main" is just a definition like everything else. At least hugs and ghci will treat it like that. The compiler, and runhaskell, however, have their own interpretation, which is that anything called main should be executed immediately
11:25:27 <medfly> NO U
11:25:55 * SamB_XP hands out some extra Us he had in the closet
11:26:08 <copumpkin> SamB_XP: finally climbed out, did you?
11:26:20 <Berengal> If I make a language I'm going to make the entry point "allons-y"
11:26:28 <copumpkin> aw
11:26:30 <copumpkin> cute
11:26:32 <SamB_XP> I only went in the closet to retrieve the Us!
11:26:36 <SamB_XP> (it's a biggish closet)
11:26:47 <Guest42315> main :: IO () , this is the trick? I could define any other IO() that it would print things?
11:27:01 <Guest42315> mauke: i'm reading, thank you
11:27:16 <mauke> all will be revealed
11:27:27 <SamB_XP> Guest42315: have you ever used C?
11:27:46 <Berengal> Guest42315: No, the trick is the combination. When you have a definition called "main" of type IO (), the compiler will make that the entry point of your program. You could make it an Int instead, but then the compiler wouldn't be able to make an entry point out of it
11:28:11 <Guest42315> yes
11:28:20 <tensorpudding> you could define many functions of type IO (), but it wouldn't actually be run unless it was called from main
11:28:21 <Berengal> Guest42315: Without the compiler, however, nothing would happen at all. Hugs would happily load the file just like usual and nothing would happen
11:28:24 <Guest42315> runhugs will not be happy without a main: ERROR - Undefined variable "main"
11:28:24 <SamB_XP> Guest42315: it's the same idea as their main() function
11:29:13 <Guest42315> main isn't special in the repl, but in the batch interpreter and/or a compiler it will, right?
11:29:19 <Berengal> Yep
11:29:23 <Berengal> That's basically it
11:31:09 <tensorpudding> if you load a file with main in the interpreter, you can execute main by doing :main
11:31:28 <medfly> isn't "main" also ok
11:31:31 <tensorpudding> that way, you can also pass arguments too
11:31:53 <Guest42315> hm
11:32:08 <Guest42315> how can I be sure A will be print before B? with the >>?
11:32:17 <copumpkin> it sets up a dependency
11:32:17 <chrisdone> > let 1 = 1 in 1
11:32:18 <lambdabot>   1
11:32:25 <copumpkin> on something uninteresting, but a dependency nonetheless
11:32:36 <tensorpudding> if you're in the IO monad, and you see foo >> bar, that always means that foo will run before bar
11:32:48 <ksf> llvm has been applied to head, not stable, has it?
11:32:58 <copumpkin> ksf: not even, as far as I know
11:33:03 <Paczesiowa> tensorpudding: unless foo contains unsafeInterleaveIO
11:33:04 <tensorpudding> llvm is a patch on head, currently
11:33:07 <Guest42315> tensorpudding: in other monads it means other things
11:33:18 <copumpkin> Paczesiowa: even with unsafeInterleaveIO
11:33:21 <Guest42315> hm
11:33:23 <tensorpudding> unsafeInterleaveIO?
11:33:38 <tensorpudding> not familiar
11:33:40 <copumpkin> what allows lazyIO to work
11:33:42 <ksf> oh. http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Installing
11:33:45 <Berengal> Guest42315: Yeah, (>>) is overloadable, so it can mean basically anything as long as that anything has the right type
11:33:47 <copumpkin> tensorpudding: great evil
11:33:48 <Paczesiowa> readFile "foo.txt" >> putStrLn "ohnoez"
11:34:04 <pikhq> tensorpudding: It magically makes IO lazy.
11:34:16 <pikhq> (as seen in hGetContents)
11:35:20 <Berengal> Doesn't unsafeInterleaveIO also give you unsafePerformIO through some fancypants expression?
11:35:44 <copumpkin> I don't think so
11:35:45 <Saizan> no
11:35:45 <Berengal> Or was it unsafeCoerce through IORefs...
11:35:50 <copumpkin> you can do that
11:36:00 <Saizan> unsafePerformIO gives you unsafeCoerce
11:36:01 <copumpkin> unsafePerformIO + IORef = unsafeCoerge
11:36:01 <ksf> ...theer don't seem to be any recent source snapshots of head, only builds.
11:36:02 <chrisdone> unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see System.IO.hGetContents.
11:36:07 <copumpkin> Coerce, even :)
11:36:13 <Berengal> Ah
11:36:21 <tensorpudding> > undefined >> Nothing
11:36:22 <lambdabot>   * Exception: Prelude.undefined
11:36:38 <Guest42315> there is something in Prelude to read ints from stdin? i'm seeing getChar and getLine in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:36:43 <dankna> > unsafeInterleaveIO undefined >> Nothing
11:36:43 <tensorpudding> (>>) still causes the first action to be evaluated, even if it doesn't use the return value
11:36:44 <lambdabot>   Not in scope: `unsafeInterleaveIO'
11:36:45 <copumpkin> > return undefined >> Nothing
11:36:46 <Berengal> chrisdone: Hey, just out of curiosity, is your tryhaskell code available?
11:36:46 <lambdabot>   Nothing
11:37:20 <chrisdone> Berengal: you mean the jsonrpc service and/or mueval tweaks?
11:37:29 <Berengal> chrisdone: Yeah
11:37:56 <zygoloid> lazy io and exploiting of file buffering i think allows recovery of a weak unsafeInterleaveIO :: IO String -> IO String
11:38:16 <chrisdone> Berengal: I can pop them on github if you like. they're pretty messy though
11:38:28 <Guest42315> I will need to get a line and then use this http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3ARead ?
11:38:31 <chrisdone> well, the mueval patch is
11:38:36 <sepp2k> Guest42315: You can use read to get a number (or anything else readable) from a string.
11:39:21 <Berengal> chrisdone: I'm mostly just curious and a little bored and though it'd be fun to see if I could hack up an interactive tutorial of sorts
11:39:27 <mauke> Guest42315: readLn
11:40:11 <chrisdone> Berengal: hang on, let me make some repos on github
11:41:23 <Guest42315> hm o.o
11:43:07 <ksf> waaaagh darcs is so _slow_
11:43:12 <chrisdone> Berengal: http://github.com/chrisdone/mueval-interactive
11:43:35 <chrisdone> Berengal: run mueval-core -r
11:43:35 <Saizan> ksf: started from a snapshot at least?
11:43:44 <ksf> git clones a full repo in the time darcs takes to read an inventory
11:43:48 <Berengal> chrisdone: Neat
11:44:08 <ksf> Saizan, nope
11:44:20 <Saizan> ksf: you should
11:44:23 <dankna> darcs isn't optimized for that particular case; that doesn't mean it's slower in all cases
11:44:30 <MaciejP> Guest42315: I think what you want is read
11:44:46 <ksf> how do I do it?
11:45:02 <chrisdone> Berengal: I think one could alter mueval properly so that it does interactive OR command-line, but I'm just craming in what I can over the weekends
11:45:39 <Saizan> ksf: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources <- second subsection
11:46:23 <ksf> oh, I skipped that because it says OSX
11:46:39 <ksf> I'm already at patch 450/1073, though.
11:47:35 <chrisdone> Berengal: http://github.com/chrisdone/haskell-jsonrpc
11:48:37 <ksf> don't do rpc. do rest.
11:51:09 <Guest42315> MaciejP: readLn is working o.o main = readLn >>= \c -> print (fac c), where fac is the factorial function..
11:53:26 <MaciejP> Guest42315: read/readLn is not a good way to parse a value, because it mail fail with an exception
11:53:30 <Guest42315> mauke: http://mauke.ath.cx/stuff/haskell/how-to-io.html is very nice, thank you! i'm saving it.. that "do" syntax is really interesting o.o
11:53:44 <Guest42315> and now confusing
11:53:57 <Guest42315> it's working like ocaml's ;
11:53:57 <Guest42315> ah
11:54:06 <mauke> MaciejP: but that's exactly what you want in your first programs
11:54:19 <mauke> and with readLn you can at least catch it sanely
11:54:28 <Guest42315> that's ok, this is just my first program
11:54:57 <chrisdone> Berengal: unfortunately I didn't use git from the start with both of those
11:55:15 <ksf> ...50k/s, darcs.haskell.org has to be kidding me.
11:55:16 <chrisdone> I keep making projects thinking they'll amount to nothing and don't use git and then regretting it
11:55:27 <chrisdone> note to self: git everything
11:55:37 <ksf> it really, really likes to throttle the transfer rate
11:55:39 <mauke> git add /
11:55:47 <ksf> someone should fix TCP
11:55:58 <Guest42315> i have to go, thank you all ^^
11:56:04 <chrisdone> Guest42315: bye bye!
11:59:02 * ksf vows to never ever again delete his ghc checkout
12:00:27 <ksf> oh. and darcs.haskell.org being slow might be actually what's limiting the get performance.
12:00:48 <dankna> ksf - it doesn't take /that/ long if you do it from snapshot, but yeah, I actually have a checkout of it saved for in case I need it as well
12:00:54 * ksf would like a p2p vcs
12:01:11 <dankna> mm.  that's an interesting concept, actually.
12:03:21 <ksf> http://lists.osuosl.org/pipermail/darcs-users/2005-November/009018.html
12:03:55 <ksf> apparently it can't be easily done in darcs as history information is quite big
12:04:01 <ksf> ...in git it's just a sha
12:04:20 <djahandarie> Does anyone having a shunting yard implementation lying around somewhere?
12:04:33 <dankna> does git have commuting patches?
12:04:54 <ksf> I don't think so
12:04:59 <Beelsebob> it doesn't
12:05:05 <dankna> I believe that's what darcs needs all that history for
12:05:18 <MissPiggy> why doesn't darcs just have a read only mode!
12:05:29 <dankna> it has the --lazy mode, heh
12:05:37 <ksf> but can't all that information be hashed, too?
12:05:43 <dankna> but there's a lot of advice to use --partial as I understand it
12:06:13 <Igloo> ksf: But how do you get from the hash to the information?
12:06:32 <dankna> as I understand it, the information in question is the list of hashes of patches in the repo
12:06:45 <dankna> and the problem that needs to be solved is to determine which patches the two repos being acted on have in common
12:06:49 <Saizan> does ghc use darcs-2 or darcs-hashed ?
12:07:04 <ksf> ...and after still another 42 minutes to download the latest snapshot, I still have to get the patches from 2009-10-23 till now.
12:07:20 <dankna> in git, because of no commuting, that's simpler
12:07:23 <ksf> I've got no idea.
12:07:39 <ksf> It should use git, though, darcs apperantly isn't ready for such gigantic repos, yet.
12:08:03 <ksf> git has an definite advantage there, linux being the unit test it's been written for...
12:08:21 <dankna> that isn't a unit test, but yes
12:08:24 <Saizan> it's still using darcs-1
12:08:29 <Saizan> that's pretty bad.
12:08:42 <dankna> are you sure it's darcs's fault and not the available bandwidth of the server, though?
12:09:10 <ksf> it's TCP throtteling afict.
12:09:19 <ksf> ...I'm getting slow inclines and fast drops.
12:10:10 <ksf> It's just not common for a server to vary between 250 and 50k.
12:10:16 <dankna> if network capacity is the bottleneck, I don't think it's the vcs's fault
12:10:18 <ksf> ...and I'm using wget right now, not darcs.
12:10:24 <dankna> there must be some traffic shaping in place somewhere
12:10:25 <dankna> oh, okay
12:10:31 <dankna> yeah, that is weird, I agree
12:10:48 <dankna> I bet it's a problem that could be fixed by a substantial donation to whoever maintains the server :D
12:10:59 <ksf> but you can use that connection smartly or slowly. that is, http requests should be pipelined so TCP can take up speed
12:12:02 <ksf> ...a couple of years ago I was wondering whether any server would ever fill my 150k/s, and now my 300k/s are regularily saturated.
12:12:08 <dankna> modern backbone routers actually do their traffic shaping in terms of "flows"
12:12:12 <dankna> instead of individual connections
12:12:17 <dankna> a flow being a set of related connections
12:13:01 <dankna> pipelining saves you the handshake to open the new connection, which is costly, but the lack of it should't produce the kind of sawtooth you're seeing
12:13:11 * ksf panicks, checks df -h, and calms down again
12:13:12 <dankna> you'd see more of a square wave with the gaps being fairly thin
12:13:16 <dankna> haha
12:13:50 <ksf> the worst thing that could happen now is a connection drop and darcs.haskell.org not supporting partial content.
12:14:13 <djahandarie> ksf, I'm sure there are worse things that could happen!
12:14:20 <djahandarie> Like some guy busting through your window
12:14:28 <ksf> but not to my quest to check out ghc HEAD!
12:14:34 <ksf> I doubt that.
12:14:41 <ksf> I live on the 10th floor.
12:14:50 <djahandarie> ksf, you never know
12:14:51 <Igloo> s/guy/ninja/
12:15:50 <ksf> a unified cabal-install/haskell-torrent/darcs thingie would be cool.
12:16:16 <dankna> yes, it would
12:20:23 <dankna> you know what there actually ought to be that would be simple to do
12:20:33 <dankna> is a .torrent of the last ghc snapshot
12:20:38 <dankna> just need a tracker for it
12:20:45 <Saizan> anyhow, once you convert the ghc repo to the hashed format, a get where you don't need the full history is instant.
12:25:40 <ksf> there's opentracker.
12:26:10 <ksf> just need a script that puts a new torrent online every now and then
12:26:28 <bjorkintosh> ksf, haskell should be ripe for the job no?
12:26:33 <bjorkintosh> it's entered the real world and whatnot.
12:26:39 <ksf> and some client that's smart enough to use one data directory for multiple torrents
12:26:48 <bjorkintosh> again, haskell ftw.
12:26:52 <ksf> ...and can listen to an rss feed or such
12:27:03 <ksf> haskell-torrent doesn't support multiple files, yet.
12:27:22 <bjorkintosh> why not?
12:27:29 <ksf> because it doesn't.
12:27:30 <bjorkintosh> it's the best tool out there for the real world!
12:27:41 <bjorkintosh> 4 lines of code, or less.
12:27:46 <bjorkintosh> functional code too.
12:28:25 <ksf> bjorkintosh, git clone git://github.com/jlouis/haskell-torrent.git , go for it
12:31:59 <ksf> dankna, darcs convert? any gotchas?
12:32:04 <ksf> er Saizan
12:34:58 <Saizan> ksf: there are 3 formats, darcs-1, darcs-hashed, darcs-2, darcs-hashed is already plenty faster, at least locally, and you can avoid getting the full history if you want, and you can share patches between darcs-1 and darcs-hashed repos
12:35:35 <ksf> oh, it seems I want to get a new darcs, then.
12:35:40 <Saizan> convert gives you a darcs-2 repo, which is not compatible with darcs-1 ones
12:36:07 <Saizan> well, the problem is that if the repository is in darcs-1 format a new darcs doesn't help much
12:36:27 <ksf> ...mine doesn't seem to support hashed
12:36:32 <ksf> it's 2.0.2
12:37:16 <Saizan> i thought that version did
12:38:20 <Saizan> the conversion between darcs-1 and darcs-hashed happens automatically when you do a get with a recent enough darcs
12:38:44 <MissPiggy> is there such a thing as magma theory?
12:38:53 <MissPiggy> what deep theorems are there?
12:39:24 <dolio> What's magma? Monoid minus identity?
12:39:32 <MissPiggy> it's just a binary relation nothing else
12:39:39 <dolio> Associative?
12:39:42 <MissPiggy> not necessarily associative
12:39:54 <MissPiggy> semigroup is magma + associativity
12:39:56 <ksf> ...well, then I don't need to do anything.
12:39:58 <dolio> I don't see what theorems there could be.
12:40:02 <jiyunatori> Berengal: ok I got it ! simply, the string from the database was encoded as UTF8, while haskell is manipulating Unicode encoding. I was missing the conversion.
12:40:07 * ksf darcs pull -a
12:40:29 <jiyunatori> Berengal: thanks for your help and attention. bye
12:40:45 <MissPiggy> I see that binary tree is a magma
12:41:22 <Saizan> ksf: you can see the format of your repo with darcs show repo
12:53:17 <MaciejP> Is it possible to put already accepted tokens back to the input stream in Parsec?
12:53:37 * copumpkin is trying to figure out how to do http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html with as little runtime overhead as possible... anyone have any ideas? currently, I have data Z = Z; newtype S n = S Int
12:54:06 <xerox> MaciejP: you can «try» parsers, and they don't consume the input if they fail
12:54:13 <monochrom> Yes, but not easy. Easier: apply lookAhead to a part of your parser.
12:54:20 <copumpkin> but writing some of the functions is proving to be quite hard
12:54:54 <xerox> I didn't remember that one, thanks
12:55:05 <MaciejP> xerox: I was looking for such a function but didn't find it.
12:55:45 <MaciejP> Sorry, the last was for monochrom
12:55:58 <xerox> I'll relay the message.
12:57:25 <pflanze> Hello. I've got code like "data AVal = AFunc String | APrim (String -> String) | AVal String", now how do I make this show'able? deriving (Show) won't work because of the function in APrim, so can I override only show for APrim
12:57:27 <pflanze> ?
12:57:38 <mauke> no
12:58:10 <pflanze> hm. So can I pattern match and call the previous show in the non-APrim cases?
12:58:52 <aavogt> @hoogle [a] -> [a] -> Maybe [a]
12:58:52 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
12:58:53 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:58:53 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:59:02 <pflanze> I mean, it can't be that including a function type anywhere in your types makes it undebuggable?
12:59:13 <aavogt> ah strip is the word
12:59:30 <benmachine> pflanze: well, you can give your own Show instance and make it do whatever you life
12:59:33 <benmachine> er like
12:59:56 <pflanze> benmachine: and how would you do it for all the non-function parts?
13:00:07 <benmachine> pflanze: manually, unfortunately
13:00:19 <benmachine> but that's not terrible unless you have really rather a lot of cases
13:00:50 <copumpkin> anyone have any ideas for my fast Nat question?
13:01:20 <aavogt> @hoogle isOperator
13:01:20 <lambdabot> No results found
13:02:02 <pflanze> well, I suppose I *can* call show on the types I pattern-matched, since it's not the same type anymore (thus no loop involved).
13:02:07 * pflanze tries
13:02:27 <benmachine> yep
13:03:19 <benmachine> pflanze: this might be useful to you: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23058#a23058
13:03:41 <benmachine> it is the code that GHC attempts to use when deriving a Show instance
13:03:50 <benmachine> (but it doesn't work because the function is not showable)
13:05:28 <benmachine> (don't ask me why the parenthising/indentation is so perverse)
13:05:42 <pflanze> k, thanks
13:06:50 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23058#a23059 updated with sanity
13:13:23 <copumpkin> caseNat :: forall r. n -> (n ~ Z => r) -> (forall p. (n ~ S p, Nat p) => Int -> r) -> r -- is that too ugly?
13:13:37 <copumpkin> or too convoluted
13:14:58 <Berengal> copumpkin: Don't you need to forall the n as well?
13:15:00 <ezyang> Continuations are hard >.>
13:15:20 <copumpkin> Berengal: n is from the typeclass
13:15:24 <Berengal> Ah
13:15:32 <copumpkin> class Nat n where
13:15:35 <Berengal> For Z and S, I assume
13:15:39 <copumpkin> yep
13:15:49 <copumpkin> ezyang: how's your "hashtable" going?
13:16:02 <ezyang> copumpkin: Hee.
13:16:09 <copumpkin> Shee.?
13:16:22 <ezyang> I need to take dons' suggestion and convert the code to be mutable.
13:16:39 <copumpkin> :o
13:16:44 <copumpkin> for creating a new one quickly?
13:16:48 <ezyang> yup
13:16:48 <copumpkin> + ST
13:17:08 <ezyang> I also need to split up the population and accessor benchmarks
13:17:18 <ezyang> I also need to work on my other studies :-)
13:18:02 <copumpkin> pfft
13:19:55 <etpace> If I have something of ErrorT ExprError IO Expr, how can I get the ExprError or Expr out of it (so I can show/print it)
13:20:30 <ezyang> That's a really curious monad stack. Are you sure you want ErrorT on top of IO?
13:21:09 <djahandarie> Are there any interesting papers or approaches to detecting swear words that anyone here is aware of?
13:21:12 <etpace> Well, I had it running using just the Error instance ExprError, and now I'm mid-hack of having it use IORefs as well
13:21:27 <ezyang> etpace: I'd probably just run the ErrorT to get it back in IO, and then bind
13:21:31 <etpace> it contains a lot of liftIOs, thats for sure
13:22:08 <ezyang> etpace: but it does depend on where you want to "get it into"
13:22:22 <aavogt> hmm, the TH AST doesn't include view patterns
13:22:41 <aavogt> :(
13:32:57 <noggle> hi
13:33:57 <ezyang> heyo!
13:35:20 <MissPiggy> what are the really basic theorems of ring theory?
13:35:34 <MissPiggy> like in group theory we have all that if it acts like the identity it is the identity etc..
13:35:49 <mauke> 1) do not talk about ring theory
13:35:56 <mauke> 2) you do NOT talk about ring theory
13:36:02 <MissPiggy> oops
13:36:05 <mauke> wait, wrong movie
13:36:10 <mauke> carry on
13:36:21 <c_wraith> You'll die within 8 days of seeing the ring theorems
13:36:27 <c_wraith> ...  also the wrong movie
13:36:27 <mauke> haha
13:36:48 <medfly> :)
13:37:07 <Hunner> Is it possible to define "instance Show (IO ...)"?
13:37:18 <maltem> Is "ring theory" to be understood to also be about modules and ideals?
13:37:24 <Hunner> Or am I doing it wrong?
13:37:26 <mauke> > putStr ""
13:37:27 <lambdabot>   <IO ()>
13:37:29 <medfly> ^^
13:37:30 <ezyang> Hunner: No.
13:37:40 <mauke> Hunner: yes
13:37:42 <c_wraith> Hunner, yes, you can, but..  You can't examine the values inside the IO action.  because the term doesn't make any sense
13:37:47 <mauke> > show (putStr "asdf")
13:37:48 <lambdabot>   "<IO ()>"
13:38:48 * Hunner is trying to understand why "main = ioFunction" is not working but "main = do ioFunction" is working, too
13:39:33 <mauke> Hunner: those are 100% equivalent
13:40:08 <medfly> mauke's link earlier ( http://mauke.ath.cx/stuff/haskell/how-to-io.html#a7 ) shows the translation rules ;)
13:41:41 <Heffalump> mauke: could the monomorphism restriction be at play?
13:41:55 <mauke> I don't see how
13:42:21 <Heffalump> neither do I, but it's the only thing I can think of
13:43:41 <noggle> :t readFile
13:43:42 <lambdabot> FilePath -> IO String
13:43:52 <noggle> :t words
13:43:53 <lambdabot> String -> [String]
13:44:04 <noggle> oh..
13:44:08 <mauke> :t fmap words readFile
13:44:09 <lambdabot>     Couldn't match expected type `[Char]'
13:44:09 <lambdabot>            against inferred type `IO String'
13:44:09 <lambdabot>       Expected type: FilePath -> String
13:44:12 <mauke> :t fmap words . readFile
13:44:13 <lambdabot> FilePath -> IO [String]
13:44:49 <noggle> :t fmap
13:44:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:44:58 <noggle> ..
13:45:05 <noggle> time to learn haskell io
13:45:12 <noggle> what is this functor business
13:45:24 * noggle moseys to the haskell wiki
13:45:36 <mauke> @src Functor
13:45:36 <lambdabot> class  Functor f  where
13:45:36 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:45:42 <mauke> ^ that's functors
13:46:17 <noggle> mapping a function to an argument which is a function of two args?
13:46:30 <mauke> huh?
13:46:36 <noggle> that is what I said.
13:47:05 <mauke> fmap takes a function (from 'a' to 'b') and a container of 'a's and returns a container of 'b's
13:47:15 <MissPiggy> here's my first ring theorem0 = k(0) = k(a+(-a)) = ka + k(-a) ==> ka = -k(-a) ==> -ka = --k(-a) = k(-a)
13:47:30 <MissPiggy> anyone know any more good ones?
13:52:05 <mreh>     Can't find interface-file declaration for type constructor or class Random
13:52:05 <mreh>       Probable cause: bug in .hi-boot file, or inconsistent .hi file
13:52:08 <mreh> what on earth?
13:53:09 <ezyang> try rm *.hi?
13:53:25 <mreh> ezyang: tried, maybe I need to recompile Random
13:53:37 <mreh> i'm doing ghc --make -prof -auto-all -caf-all
13:55:33 <Hunner> Question: "instance Show (IO a) where" ... and then what?
13:55:59 <copumpkin> and then show _ = "<IO >"
13:56:09 <copumpkin> :P
13:56:59 <Hunner> ... huh?
13:57:09 <Hunner> oh. Not helpful :)
13:57:12 <copumpkin> short of adding a Typeable constraint or going unsafe, that's the best you can do
13:57:26 <copumpkin> a Typeable constraint would allow you to print out what type is in the IO
13:57:31 <copumpkin> > print "zomg"
13:57:32 <lambdabot>   <IO ()>
13:57:43 <copumpkin> that's how that works
13:57:58 <mauke> > print () >> return 42
13:57:59 <lambdabot>   <IO Integer>
13:58:23 <copumpkin> Hunner: what are you trying to do?
13:59:59 <Hunner> Understand if I can define an instance of "show" for an "IO a" that returns an "IO String"... I think
14:00:10 <copumpkin> @src Show
14:00:10 <lambdabot> class  Show a  where
14:00:11 <lambdabot>     showsPrec :: Int -> a -> ShowS
14:00:11 <lambdabot>     show      :: a   -> String
14:00:11 <lambdabot>     showList  :: [a] -> ShowS
14:00:20 <copumpkin> look at the type of show there :)
14:00:22 <ezyang> Is it just me, or is currying so crucial to understanding a lot of FP concepts?
14:00:33 * copumpkin could do with some curry
14:00:36 <Hunner> or more specifically "IO (Integer, Int, Int) -> IO String"
14:00:41 * ezyang too 
14:00:51 <copumpkin> Hunner: you'll have to write your own function for that. Show won't do
14:01:10 <Hunner> copumpkin: but if I can just ">>= show" then that would be cool
14:01:16 <copumpkin> why not fmap show?
14:01:19 <Hunner> so remove the first IO?
14:01:21 <copumpkin> or liftM
14:01:24 <noggle> > words $ readFile
14:01:25 <lambdabot>   Couldn't match expected type `GHC.Base.String'
14:01:26 <lambdabot>         against inferred typ...
14:01:33 <Hunner> :t fmap show
14:01:34 <lambdabot> forall a (f :: * -> *). (Show a, Functor f) => f a -> f String
14:01:37 <ezyang> Hunner: you need fmap
14:01:43 <ezyang> otherwise it's ">>= return . show"
14:02:06 <noggle> why do I have to use fmap (words) $ readFile "rle-this-text"
14:02:07 <Hunner> Ohhhhhhhh
14:02:12 <copumpkin> :)
14:02:14 <noggle> I know that words is the wrong type
14:02:27 <noggle> err, words and readFile are different types
14:02:28 <copumpkin> :t fmap words . readFile
14:02:30 <lambdabot> FilePath -> IO [String]
14:02:30 <MissPiggy> who likes rings
14:02:32 <ezyang> noggle: readFile returns a value in the IO monad
14:02:46 <ezyang> so fmap let's you run words over that value
14:03:00 <ezyang> much like map would let you run words over a list of strings
14:03:04 <copumpkin> MissPiggy: rings are fun, but I can't say I know that much about them
14:03:11 <dobblego> noggle, the type of readFile is "IO String" which is quite different to "String"
14:03:24 <noggle> type error
14:03:30 <dobblego> MissPiggy, I like rings; do you have something to show off?
14:03:34 <noggle> I see
14:03:37 <noggle> okay
14:03:49 <dobblego> noggle, the return type I should say, not the type
14:04:06 <copumpkin> dolio: do you understand the New interface in Data.Vector?
14:04:09 <noggle> so to go from IO String to [Char] requires a monad
14:04:11 <ezyang> c m g k = m (\a -> (g a) k
14:04:13 <noggle> is that true
14:04:17 <ezyang> mua ha ha ha
14:04:19 <dobblego> there is a function called fmap with allows you to pass "IO String" then a function String -> String and get back another IO String
14:04:26 <mauke> noggle: no
14:04:39 <noggle> I am trying to figure out what I need to read
14:04:44 <copumpkin> noggle: you never go from IO String to anything but IO something
14:04:45 <noggle> monad or IO
14:04:51 <mauke> noggle: http://mauke.ath.cx/stuff/haskell/how-to-io.html
14:04:55 <dobblego> noggle, it's not possible to go from IO String -> [Char]; I think you just want fmap
14:04:56 <copumpkin> noggle: YOU CANNOT ESCAPE!!!
14:05:09 <noggle> haha nice, how does i io in haskell?
14:05:15 <noggle> copumpkin: haha
14:05:22 <noggle> I like this
14:05:28 <noggle> confused at time
14:05:30 <noggle> s
14:05:35 <MissPiggy> I just got told this proof: x*0=x*0+((x*0)+-(x*0))=x*(0+0)*-x*0=x*0+-x*0=0
14:05:38 <MissPiggy> it's a ring theory
14:05:39 <copumpkin> noggle: you peacefully accept your fate and instead of expecting euridice to follow you from hell, you just move to hell yourself
14:05:40 <noggle> but nice to use something not like python
14:05:49 <noggle> hahahaha shit
14:05:55 <copumpkin> Eurydice, apparently
14:06:10 <benmachine> she was greek so who cares
14:06:12 <MaciejP> Anyone a clue how to parse strings like "((aaa))bbb((ccc))" to ["aaa", "bbb", "ccc"]?
14:06:22 <dobblego> MaciejP, Parsec of course
14:06:24 <MissPiggy> MaciejP: I am not sure what that means
14:06:32 <copumpkin> MaciejP: you haven't given us much of a spec :)
14:06:34 <MaciejP> My problem is the bbb, because there may or may not follow the ((ccc))
14:06:34 <MissPiggy> MaciejP: I mean why are there brackets there?
14:07:14 <MissPiggy> MaciejP: why not parse it as List [List [List [Element "aaa"]], Element "bbb", List [List [Element "ccc"]]]
14:07:34 <MissPiggy> MaciejP: if that was done, flattening it into ["aaa", "bbb", "ccc"] should become a very easy taske
14:07:44 <lament> tasque
14:07:49 <MissPiggy> lol
14:08:45 <medfly> > do y <- getLine; putStrLn y
14:08:45 <MaciejP> MissPiggy: The grammar is something like expr ::= '((' letter* '))' | letter*
14:08:46 <lambdabot>   <IO ()>
14:08:49 <medfly> :t putStrLn
14:08:50 <lambdabot> String -> IO ()
14:08:53 <benmachine> :t let thing = many letter <|> paren; paren = char '(' *> thing <* char ')' in thing
14:08:53 <MaciejP> MissPiggy: And I want mayne expr
14:08:54 <lambdabot> Not in scope: `letter'
14:08:57 <benmachine> oh
14:09:03 <noggle> ahh macie
14:09:09 <noggle> I think I wrote something that does that
14:09:09 <MissPiggy> MaciejP: oh really? It's not
14:09:14 <ziman> :t optionMaybe
14:09:15 <Hunner> What's another subset of functors besides monads?
14:09:15 <lambdabot> Not in scope: `optionMaybe'
14:09:23 <benmachine> MaciejP: no nesting?
14:09:24 <noggle> it will at least remove the () and then RLE the string
14:09:29 <noggle> let me check
14:09:34 <MissPiggy> <expr> ::= <subexpr>* ; <subexpr> ::= letter* | '(' <expr> ')
14:09:35 <MaciejP> benmachine: No
14:09:36 <dobblego> Hunner, Applicative, Pointed
14:09:43 <MissPiggy> oh well that's a lot easier
14:09:51 <MaciejP> MissPiggy: No, it's not :-)
14:09:57 <MissPiggy> yes it is a lot easier
14:10:11 <benmachine> :t char
14:10:12 <lambdabot> Char -> Doc
14:10:15 <benmachine> oh
14:10:15 <MissPiggy> unless I have misunderstood you
14:10:18 <benmachine> that is not what I want
14:10:25 <benmachine> :t Text.Parsec.char
14:10:26 <lambdabot> forall s u (m :: * -> *). (Text.Parsec.Prim.Stream s m Char) => Char -> Text.Parsec.Prim.ParsecT s u m Char
14:10:31 <benmachine> neat
14:11:23 <noggle> MaciejP: I have this thing
14:11:27 <noggle> I will paste it
14:11:31 <noggle> it removes chars
14:11:40 <noggle> I made it before I learned about dropWhile
14:12:18 <pragma_> You are incorrect.
14:12:31 <benmachine> let string = Text.Parsec.string; letter = Text.Parsec.letter; thing = string "((" *> many letter <* string ")) <|> many letter in many thing
14:12:36 <benmachine> > let string = Text.Parsec.string; letter = Text.Parsec.letter; thing = string "((" *> many letter <* string ")) <|> many letter in many thing
14:12:37 <lambdabot>   <no location info>:
14:12:37 <lambdabot>      lexical error in string/character literal at end o...
14:12:45 <benmachine> > let string = Text.Parsec.string; letter = Text.Parsec.letter; thing = string "((" *> many letter <* string "))" <|> many letter in many thing
14:12:46 <lambdabot>   Not in scope: `Text.Parsec.string'Not in scope: `Text.Parsec.letter'
14:12:48 <benmachine> :(
14:12:57 <benmachine> in scope for :t but not > I guess
14:14:35 <noggle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23061#a23061
14:15:03 <noggle> I think that group $ dropChar '(' $ dropChar ')' "((aaa))bbb((ccc))"
14:15:09 <noggle> would do what you ask
14:15:19 <aavogt> @hoogle Monoid m => t a -> (a -> m) -> m
14:15:20 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:15:20 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:15:20 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:15:25 <Young-Goon> hi, does someone know why http://haskell.pastebin.com/4hfeqQRK is allowed but not http://haskell.pastebin.com/BrcKh23c in haskell ?
14:15:34 <dolio> copumpkin: As far as I can tell, New wraps a computation that generates a mutable vector, which is then frozen to produce the immutable vector.
14:15:46 <copumpkin> dolio: a bit like your apply operator?
14:16:09 <dolio> Yeah. That might be how you reuse arrays. Roman mentioned something about that, but I haven't looked into it.
14:16:14 <copumpkin> ah
14:16:33 <benmachine> Young-Goon: I can't really imagine why you want to do that :P
14:16:44 <benmachine> it can be done though
14:17:06 <MaciejP> benmachine: This doesn't work since the letters can be an empty string
14:17:13 <dolio> Presumably you can fuse something like: apply algo (New m) = New (m >>= \v -> algo v >> return v)
14:17:15 <benmachine> MaciejP: many1?
14:17:20 <Young-Goon> benmachine, to do a Probaility monad i need that, (in order to have a function of type "a -> r" with "r" a "Num")
14:17:42 <benmachine> Young-Goon: if you have a value and all you know about it is a type "a"
14:17:43 <MaciejP> benmachine: But then there must be at least on
14:17:48 <benmachine> what functions can you apply to it?
14:17:49 <MaciejP> benmachine: one
14:17:57 <benmachine> MaciejP: what
14:18:06 <MaciejP> one letter
14:18:24 <benmachine> MaciejP: what's the problem with my solution again?
14:18:47 <MaciejP> I want "(())((b))" also to succeed
14:19:06 <Young-Goon> benmachine, in fact i want to have a generic function which computes probability, but for every floating type (i want a function "Num r => m a -> r" define in my monad law but i can't)
14:19:37 <benmachine> Young-Goon: I have a feeling that you don't want a monad
14:19:44 <benmachine> or that something else very strange is going on
14:19:59 <benmachine> a function Num r => a -> r
14:20:04 <benmachine> must ignore its first argument
14:20:08 <benmachine> because it doesn't know anything about it
14:20:26 <MaciejP> noogle: Unfortunately this won't help, I'm using Parsec to parse the string
14:20:49 <Young-Goon> sorry i got my monad m (which is event with probability) and want to ask proba of an event, but i want to be generic in the proba type (floating is all I need)
14:21:05 <benmachine> why do you think a monad is required?
14:21:14 <noggle> mauke:
14:21:21 <noggle> you are awesome
14:21:25 <noggle> this paper is great
14:21:27 <Young-Goon> because it's a monad (it's a bit like a multivalued set)
14:21:29 <noggle> and it helps me
14:22:12 <benmachine> Young-Goon: okay I totally don't understand what you want at all
14:22:28 <benmachine> hopefully someone else can help
14:23:12 <copumpkin> whoops: type instance (:*:) (S m) n = (m :*: n) :*: n
14:23:18 <copumpkin> slight mistake :P
14:23:46 <Hunner> "type Date = (Integer, Int, Int)" and then "instance Show Date where" says "overlapping instance Show (Integer, Int, Int)" ... I have OverlappingInstances enabled
14:23:46 <benjamin_scarlet> What does a tilde in a constraint mean?
14:23:55 <copumpkin> benjamin_scarlet: type equality
14:24:48 <mauke> Hunner: but you still can't define two identical instances
14:25:05 <benmachine> MaciejP: what is ((a))(()) supposed to return?
14:25:36 <benmachine> let thing = string "((" *> many letter <* string "))" <|> many1 letter
14:25:38 <benmachine> ^ worksforme
14:25:39 <MaciejP> benmachine: ["a", ""]
14:26:06 <Hunner> mauke: What's the normal way for defining a show for some custom type then? Since it seems like everything is going to overlap
14:26:29 <mauke> Hunner: that's not a custom type
14:26:48 <mauke> (Integer, Int, Int) is an existing type and already has a Show instance
14:27:00 <benmachine> Hunner: use data Date = Date Integer Int Int
14:27:05 <copumpkin> > (15 :: Integer, 2 :: Int, 5 :: Int)
14:27:06 <lambdabot>   (15,2,5)
14:27:10 <copumpkin> > show (15 :: Integer, 2 :: Int, 5 :: Int)
14:27:11 <lambdabot>   "(15,2,5)"
14:27:27 <MaciejP> benmachine: Oh wait, I think you're right. If the string of the second alternative is empty the first one succeeds.
14:27:39 <mgree> Hunner: you can use a newtype if you want to define a special instance
14:27:40 <benmachine> MaciejP: I think I'm right too :P
14:27:49 <benmachine> MaciejP: my parser will fail on an empty string though, is that okay?
14:28:05 <benmachine> oh
14:28:07 <benmachine> no it won't
14:28:09 <benmachine> because of many
14:28:15 * benmachine unexpectedly clever
14:28:20 <mreh> fail
14:28:29 <MaciejP> benmachine: No, but that can be caught somewhere else :-)
14:28:48 <benmachine> k
14:28:54 <benjamin_scarlet> copumpkin: can you give an example of why/how one would use it?
14:29:12 <copumpkin> benjamin_scarlet: the main use case is with type functions
14:29:25 <copumpkin> a.k.a. type families
14:30:33 <benmachine> > let x :: (Char ~ Int) => a; x = x in x
14:30:34 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:30:34 <lambdabot>         against inferred type ...
14:30:39 <benmachine> hee hee
14:30:52 <mreh> why is accessing a small array faster than the equivalent Data.Map.Map?
14:30:58 <benmachine> > let x :: (Char ~ Char) => Int; x = 1 in x
14:30:59 <lambdabot>   1
14:31:21 <benmachine> mreh: because arrays are like that
14:31:33 <Heffalump> mreh: arrays have no indirections and better cache locality
14:31:41 <mreh> benmachine: I didn't mean array, I meant list
14:31:44 <benmachine> oh
14:31:45 <mreh> blegh
14:31:51 <MaciejP> benmachine: I think I simplified the problem too much, "((a))b(b((c))" should give ["a", "b(b", "c"]. That was the problem with lookAhead.
14:31:53 <benmachine> then that surprises me too
14:31:54 <Heffalump> what kind of access are you doing?
14:31:58 <Heffalump> search for an element?
14:32:00 <mreh> Heffalump random access
14:32:14 <benmachine> MaciejP: ah, you did simplify it too much then
14:32:15 <Heffalump> I don't know what that means in the context of a map.
14:32:29 <Heffalump> are you indexing into the list and doing a lookup of an int in a map?
14:32:29 <benmachine> MaciejP: not a problem though
14:32:39 <mreh> Heffalump: in the map, they key is the equiv index in the list
14:32:46 <mreh> the original list
14:32:55 <mreh> I suppose using an array here might be a much better idea
14:32:56 <Heffalump> and what size are we talking?
14:32:58 <Young-Goon> benmachine, i finally succeed in wrting what i want (i spent all night yesterday and failed) http://haskell.pastebin.com/ZqdHiERH
14:33:03 <Young-Goon> thx for your time
14:33:04 <mreh> Heffalump: 11 elements
14:33:22 <Heffalump> well, the map will take 3-4 indirections to access any element
14:33:27 <Heffalump> and the list will take an average of 5
14:33:29 <benmachine> either you can use try, or you can just do char '(' *> (char '(' *> many whatever *> string "))" <|> many whatever)
14:33:34 <benmachine> er
14:33:44 <benmachine> code provided for illustrative purposes only
14:33:47 <mreh> Heffalump: that's the complexity, but there might be a constant factor in there
14:33:48 <Heffalump> so it's a pretty close run thing and no doubt the map has slightly worse constant factors on each indirection for some reason
14:34:09 <Heffalump> mreh: precisely
14:34:13 <Paczesiowa> > foldl f z [0..5]
14:34:14 <lambdabot>   f (f (f (f (f (f z 0) 1) 2) 3) 4) 5
14:34:18 <Heffalump> each constructor in a map is more complicated than in a list
14:34:27 <Paczesiowa> > foldl (*) z [0..5]
14:34:28 <lambdabot>   z * 0 * 1 * 2 * 3 * 4 * 5
14:34:28 <MaciejP> benmachine: I'll try it
14:35:09 <Paczesiowa> is infixl the default fixity?
14:35:38 <benmachine> Heffalump: worse constant factors because it's got to do comparisons, presumably
14:35:42 <ksf> it's not the number of indirections that are important, but the number of cache misses.
14:35:42 <benmachine> or hmm
14:35:46 <aavogt> > let op = (/) in 1 `op` 2 `op` 3
14:35:47 <lambdabot>   0.16666666666666666
14:35:54 <mreh> what's the quickest array? I'm using Ints to index, shall I use a UArray with unsafeAt?
14:35:58 <benmachine> the list has to eq but the map has to ord
14:36:06 <aavogt> > ((1/2)/3,1/(2/3))
14:36:06 <Heffalump> benmachine: the list has to subtract 1 too
14:36:07 <benmachine> wouldn't have thought there any different there
14:36:07 <lambdabot>   (0.16666666666666666,1.5)
14:36:29 <Paczesiowa> > let (///) = (/) in 1 /// 2 /// 3
14:36:30 <lambdabot>   0.16666666666666666
14:36:30 <aavogt> Paczesiowa: ^^ apparently infixl is default
14:36:52 <Paczesiowa> aavogt: any reasons for that?
14:36:55 <ksf> consider a binary tree layed out as an array: you can do log(64) comparisons in one transfer of a 64-byte cache line
14:37:19 <Paczesiowa> > log 64
14:37:20 <lambdabot>   4.1588830833596715
14:37:21 <ksf> ...an it's trivial to do those comparisons in the time a cache block loads.
14:37:35 <Heffalump> ksf: from where, main memory or L2?
14:37:50 <ksf> in the end, it should'nt matter.
14:38:06 <ksf> for the argument's sake, assume they're on disk.
14:38:39 <ksf> cache-oblivious algorithms work by having optimal block-transfer asymptotics _regardless_ of block size
14:38:51 <ksf> ...which makes them performant on a multi-layer memory hierarchy.
14:39:26 <ksf> oh and that's
14:39:32 <ksf> > logBase 2 64
14:39:32 <lambdabot>   6.0
14:40:23 <mreh> what's the unsafe array access?
14:40:31 <mreh> I thought it was unsafeAt
14:40:36 <ksf> it is
14:40:36 <mreh> can't find it with hoogle
14:40:39 <benmachine> sounds pretty unsafe to me
14:40:42 <ksf> it's hidden.
14:40:45 <mreh> :t unsafeAt
14:40:46 <lambdabot> Not in scope: `unsafeAt'
14:40:55 <ksf> iirc it's not mentioned in the haddock.
14:41:00 <ksf> ...but it's there. just use it.
14:41:04 <mreh> it's on the wiki
14:41:09 <copumpkin> it's in the typeclass I thought
14:41:09 <mreh> I remember now
14:42:05 <benmachine> in Data.Array.Base, it seems
14:42:27 * benmachine always finds the array imports a little confusing
14:42:50 <Paczesiowa> :t z
14:42:51 <lambdabot> Expr
14:42:59 <Paczesiowa> :i Expr
14:43:02 <benmachine> :t (:t)
14:43:03 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
14:43:03 <lambdabot>     In the second argument of `(:)', namely `t'
14:43:03 <lambdabot>     In the expression: (: t)
14:43:07 <benmachine> aw
14:43:20 <Paczesiowa> > Function "foo"
14:43:21 <lambdabot>   Not in scope: data constructor `Function'
14:43:26 <glguy_> Saizan, you there?
14:43:34 <benmachine> Paczesiowa: are you looking for something?
14:43:38 <Paczesiowa> > function "foo"
14:43:40 <lambdabot>   Not in scope: `function'
14:43:54 <Paczesiowa> benmachine: those things that pretty print expressions
14:44:03 <Paczesiowa> > foldl f z [0..5]
14:44:03 <benmachine> @hackage show
14:44:04 <lambdabot> http://hackage.haskell.org/package/show
14:44:04 <lambdabot>   f (f (f (f (f (f z 0) 1) 2) 3) 4) 5
14:44:04 <benjamin_scarlet> copumpkin: so caseNat closes Nat because the constraints limit instances so they can't get an r unless they're S or Z?
14:44:09 <benmachine> try that
14:44:16 <copumpkin> benjamin_scarlet: yep
14:44:20 <Saizan> glguy_: yes
14:44:28 <benmachine> > expr $ fun "foo" (var "bar")
14:44:29 <lambdabot>   foo bar
14:44:32 <benjamin_scarlet> cool
14:44:50 <glguy_> Saizan, Did I ask you about a template haskell bug recently?
14:44:58 <glguy_> If I did, do you keep logs?
14:44:58 <Paczesiowa> benmachine: thanks
14:45:22 <Saizan> glguy_: yeah, want the link to the bug?
14:45:27 <glguy_> I do! :-)
14:45:38 <Paczesiowa> > foldl (fun "`zapp`") (var "repeat f") [0..5]
14:45:39 <lambdabot>   No instance for (SimpleReflect.FromExpr
14:45:40 <lambdabot>                     (Data.Number.Sy...
14:46:03 <Saizan> glguy_: http://hackage.haskell.org/trac/ghc/ticket/2222 <- :)
14:47:07 <glguy_> thanks
14:49:36 * copumpkin looks guilty for filling up his module with unsafeCoerce
14:50:58 * copumpkin promises it's safe
14:51:10 <dolio> Isn't your module for statically typed indexing?
14:51:19 <copumpkin> yep
14:51:19 <dolio> Having unsafeCoerce everywhere hardly inspires confidence.
14:51:20 <ksf> you are in a maze of twisty papers, all looking sufficiently alike so you don't have any chance on finding that one paragraph you remember
14:51:28 <copumpkin> dolio: ah well :)
14:51:57 <ksf> ...it was a thesis, and the paragraph was quite at the end.
14:52:07 <copumpkin> dolio: not sure how else to do Nat efficiently
14:52:24 <dolio> Program in ATS.
14:52:29 <benmachine> put safeCoerce = unsafeCoerce at the top of your file
14:52:34 <benmachine> then everything will be fine
14:52:40 <ksf> ...describing an ingenious and blazingly fast way to compute van de boas indices from bfs indices.
14:52:58 <ksf> I should've opened up a .hs file as soon as I read it.
14:53:29 <copumpkin> dolio: my goal is to keep the unsafeCoerce to the well tested library functions and just to minimize overhead
14:53:49 <copumpkin> who knows, the thing might turn out to be unusable anyway
14:55:05 <copumpkin> anyway, as long as I keep a consistent interface with the outside world, what I do behind the scenes shouldn't hurt people
14:56:19 <Young-Goon> copumpkin, but it did
14:56:21 <Paczesiowa> unsafePerformIO $ readFile >>= ... sendEMail... >> return 2
14:56:26 <copumpkin> Young-Goon: ?
14:56:46 <glguy_> copumpkin, That kind of rationalization is how Ruby got as popular as it did!
14:56:51 <copumpkin> damn
14:56:54 * copumpkin gives up now
14:57:09 <copumpkin> I don't actually mind ruby that much :)
14:58:35 <benjamin_scarlet> copumpkin: I'm part dense, part lacking context and part newbie. Which overhead are you worried about in what use case?
14:58:35 <copumpkin> so the only performance killer left in the library is witnessNat
14:58:49 <copumpkin> so I'm changing my type signatures to avoid it
14:59:11 <Young-Goon> copumpkin, some colleagues bother me with what behind the interface
14:59:12 <copumpkin> benjamin_scarlet: I'm trying (probably pointlessly) to merge statically checked sized vectors with Data.Vector
14:59:28 <Saizan> copumpkin: sure you couldn't just use undefined in place of witnessNat ?
14:59:46 <copumpkin> Saizan: absolutely not! I need its value-level value to pass on to Data.Vector
14:59:58 <Saizan> ah
14:59:59 <copumpkin> value-level value, talk about redundant redundancy
15:01:58 <nus> "primordialue"
15:02:16 <nus> however you pronounce that [-;
15:03:39 <Paczesiowa> > foldl (*) z [0..5]
15:03:41 <lambdabot>   z * 0 * 1 * 2 * 3 * 4 * 5
15:03:46 <Paczesiowa> @src (*)
15:03:47 <lambdabot> Source not found. You untyped fool!
15:04:03 <Paczesiowa> > foldl (fun "*") z [0..5]
15:04:04 <lambdabot>   * (* (* (* (* (* z 0) 1) 2) 3) 4) 5
15:04:09 <Paczesiowa> > foldl (fun "(*)") z [0..5]
15:04:10 <lambdabot>   (*) ((*) ((*) ((*) ((*) ((*) z 0) 1) 2) 3) 4) 5
15:04:25 <Paczesiowa> how does the first thing work?
15:04:45 <Saizan> instance Num Expr where ...
15:05:00 <Paczesiowa> Saizan: no, I mean using * as infix operator
15:05:30 <Paczesiowa> Saizan: there's only "fun" in SimpleReflect and it's always prefix
15:05:34 <Saizan> i suspect it's special cased in the Num instance
15:05:52 <MissPiggy> fun "(*)" is a magma
15:06:01 <Ornedan> Is there a darcs command to extract patches from it in patch-the-program compatible format?
15:06:07 <Paczesiowa> > foldl (*) z "haskell"
15:06:08 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
15:06:08 <lambdabot>         against inferred ...
15:07:34 <Saizan> Ornedan: darcs diff, i think
15:11:25 <MissPiggy> > 1000000000^10123124
15:11:30 <lambdabot>   mueval: ExitFailure 1
15:11:33 <MissPiggy> > 234^124
15:11:34 <lambdabot>   606409950353409882463144111970974456971223753766562752364292632633127194541...
15:12:18 <Ornedan> Saizan: Thanks
15:15:05 <ksf> ...are people deliberately giving prose descriptions of algorithms to obfuscate?
15:21:34 <copumpkin> the "diagonal monad" on sized vectors is a valid instance, right?
15:21:40 <MissPiggy> yes
15:21:58 <MissPiggy> consider the diagonal of a cube
15:22:04 <MissPiggy> that's why it's associative
15:22:15 <copumpkin> hm, interesting
15:22:19 * MissPiggy is not sure if it needs to be a cube though?
15:22:26 <MissPiggy> I suppose it does hm
15:22:29 <copumpkin> yeah
15:22:35 <Cale> copumpkin: It's the same as the function monad
15:22:41 <Cale> copumpkin: with a finite domain
15:22:49 <copumpkin> hm
15:22:54 <MissPiggy> yeah vector n a is isomorphic to Fin n -> a
15:22:59 <copumpkin> oh, that makes sense
15:23:01 <MissPiggy> hence (!) : Vector n a -> Fin n -> a
15:23:11 <copumpkin> makes a lot of sense, even :)
15:23:13 <MissPiggy> (and tabulate : (Fin n -> a) -> Vector a n)
15:23:23 <copumpkin> yep
15:24:09 <SliMM> Hello guys
15:24:20 <SliMM> Quick newbish question
15:24:34 <SliMM> I have a datatype Month and a datatype Season
15:24:47 <SliMM> And a function season :: Month -> Season
15:25:25 <SliMM> How can I group the months into sets of three, so that I would write 4 lines instead of 12?
15:25:43 <MissPiggy> SliMM, use a view pattern with the season function :S
15:26:02 <SliMM> MissPiggy: I don't know what that is
15:26:05 <SliMM> :S
15:26:09 <MissPiggy> although you can't define season using that method
15:26:13 <MissPiggy> because it must already be defined
15:26:19 <copumpkin> so, Vec n a -> (a -> Vec n b) -> Vec n b... bah I wish the Monad typeclass had join as a method :P
15:26:34 <MissPiggy> but the point is that ONCE You have season you can use the view pattern
15:27:15 * MissPiggy wonders why copumpkin does not define bind using join!
15:27:25 <copumpkin> MissPiggy: hmm, good idea :)
15:27:28 <SliMM> MissPiggy: I have Season
15:27:44 <MissPiggy> SliMM,if you have GHC then at the start of the file to enable this you must use:
15:27:51 <SliMM> season is just a function that maps Month to Season
15:27:52 <MissPiggy> {-# LANGUAGE ViewPatterns #-}
15:27:55 <SliMM> I use Hugs
15:28:01 <MissPiggy> oh that doesn't ahve view patterns
15:28:08 <MissPiggy> hmm
15:28:13 <MissPiggy> you could write
15:28:19 <doserj> season m | m `elem` [Jan, Feb, Mar] = ...
15:28:20 <MissPiggy> f x | season x == Summer = ...
15:28:27 <MissPiggy> f x | season x == Spring = ...
15:28:32 <MissPiggy> ...
15:28:41 <Saizan> MissPiggy: the question is still how to define season, i think
15:28:50 <SliMM> Ok, I've tried this sort of pattern matching, which, for reasons obvious to you, isn't working, but might help you understand what I am thinking of: season (Dec | Jan | Feb) = Winter
15:28:52 <MissPiggy> oh is it
15:29:06 <MissPiggy> SliMM that's an ocaml thing, haskell doesn't have it
15:29:08 <Saizan> SliMM: there's no | in patterns
15:29:23 <Saizan> SliMM: however, you can use doserj's way
15:29:33 <copumpkin> tada, I have the world's slowest Monad instance
15:29:34 <doserj> with the right list of months :)
15:29:36 <SliMM> Ok, fair enough
15:29:39 <copumpkin> with a big warning on it saying "don't use me"
15:29:46 <copumpkin> but at least it's there
15:29:52 <MissPiggy> copumpkin maybe supercompiler can help?? I would like to see input and output if you try it :)
15:30:09 <copumpkin> MissPiggy: a supercompiler would help a lot here, probably :)
15:30:15 <SliMM> Thanks
15:30:21 <copumpkin> but until then, there will be big warnings everywhere
15:30:31 <copumpkin> just on this damn witnessNat
15:30:34 * Saizan wonders about having epic in the middle of ghc and LLVM
15:30:46 <copumpkin> ghc epic LLVM?
15:31:03 <Saizan> yeah
15:31:26 <SliMM> Another quick question, what's a guard and what's a gadt?
15:31:48 <MissPiggy> wouldn't epic be a bit wasted because (hopefully I'm wrong) mostly it's about dependent types?
15:32:14 <MissPiggy> all I really know about is that it's probably the only implementation of need not store indices...
15:32:14 <doserj> a guard is the "| m `elem` [...]" part of the function definition above.
15:32:27 <Saizan> MissPiggy: copumpkin is doing something like dep. types, though you're right that without totality most of the optimizations can't fire
15:32:31 * MissPiggy hopes thats not true too
15:32:38 <doserj> a GADT is a generaliyed algebraic datatype. don't worry about them for now
15:32:43 <copumpkin> what's epic?
15:32:49 <copumpkin> I thought Saizan was being silly
15:32:59 <MissPiggy> SliMM GADT are my favorite :P
15:33:16 <Saizan> http://www.cs.st-andrews.ac.uk/~eb/epic.php
15:33:25 <SliMM> Ok, they sound quite the same and I didn't know what to
15:33:29 <SliMM> Google for
15:34:26 <mreh> how can I bind something to a name that is expressed as a function of something so it is to be evaluated at run-time, once and once only
15:35:24 <Saizan> example?
15:35:53 <mreh> > replicateM 5 [False, True]
15:35:54 <lambdabot>   [[False,False,False,False,False],[False,False,False,False,True],[False,Fals...
15:36:03 <copumpkin> Saizan: thanks
15:36:03 <mreh> that never changes in the program execution
15:36:15 <copumpkin> looks pretty epic
15:36:26 <c_wraith> give it a top-level name in a module.  It will only be calculated once
15:36:47 <mreh> but writing it out is a fag, and what If I wanted to define an arbitary number of those? I think I want memoization
15:36:49 * MissPiggy got some code written today wohoo
15:37:03 <mreh> sorry, fag in England doesn't mean what it does in America
15:37:30 <MissPiggy> mreh what does it mean to you?
15:37:48 <mreh> 1) Cigarette 2) Pain in the backside
15:37:51 <MissPiggy> oh
15:37:56 <mreh> figuratively speaking
15:38:03 <MissPiggy> you can do memoization in haskell
15:38:15 <mreh> well, you can unsafePerformIO!
15:38:24 <MissPiggy> I wouldn't do it that way myself
15:38:29 <phpnoob> hey does anyone know php and mysql, i have a script i wrote but it only will do the first query its like it doen't want to do teh second one
15:38:31 <mreh> (not recommended), but it's a good hack
15:38:44 <MissPiggy> phpnoob turn on errors
15:39:01 <MissPiggy> mreh well I agree with the 'not recommended' bit :)
15:39:02 <monochrom> perhaps php is lazy as haskell afterall :)
15:39:02 <mreh> phpnoob, this is a haskell channel
15:39:37 <Berengal> unsafePerformIO is the essense of hacking incarnate
15:39:52 <ben> unsafeCoerce is :|
15:40:03 <benmachine> unsafeCoerce is lol
15:40:28 <Berengal> unsafeCoerce is just telling the compiler to trust you, you know what you're doing.
15:40:28 <Saizan> mreh: you can generate the bindings with TH
15:40:43 <monochrom> Someone should write a Haskell tutorial and name it so that the acronym is PHP. Something like Programming Haskell Programs.
15:40:55 <burp> lol
15:40:56 <mreh> Saizan: that's a good way, but it is only static is it not?
15:41:10 <burp> and make it top on google for PHP
15:41:22 <Saizan> mreh: it is
15:42:24 <SliMM> When I define a new datatype, do I need to use a keyword as well? e.g. data Example = Keyword Int
15:42:36 <copumpkin> a data constructor, yes
15:42:40 <ben> Aw, (unsafeCoerce (putStrLn "foo") :: () -> ((), ())) () segfaults my ghci
15:42:46 <ben> Did I get that IO thing wrong
15:42:49 <ben> @src IO
15:42:49 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:43:22 <copumpkin> an unlifted pair is not the same as a lifted one
15:43:22 <MissPiggy> SliMM it's also possible to do type Example = Int, which are literally the same type
15:43:42 <ddarius> Berengal: C programs have demonstrated that programmers rarely know what they are doing.
15:44:26 <SliMM> MissPiggy: What if I have more than one... "slot" in the datatype?
15:44:33 <benmachine> it's not telling the compiler to trust you it is just saying "I will take the blame when everything goes horribly wrong"
15:44:37 <mreh> every programmer I know, more or less, is more interested in technologies, I wish they would work on knowing what they are doing :)
15:45:27 * ddarius wishes customers would work on knowing what they want.
15:45:43 <MissPiggy> haha
15:45:58 <mreh> ddarius: unfortunately that's a fact of life you *can't* control
15:46:43 <SliMM> Anyway, are there any restrictions/convensions when it comes to constructor names?
15:47:13 <monochrom> Restriction: starts with a capital letter
15:47:31 <benmachine> or a colon if it is an operator
15:47:34 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23065#a23065
15:47:39 <monochrom> Convention: if you only have one, people name it the same as the type name. if you have several, do whatever you like.
15:48:04 <mreh> have a look at that, do you know a way I could dramatically improve the performance of evaluate'?
15:48:06 <benmachine> you don't always name it the same as the type name
15:48:17 <benmachine> some people do data T = MkT Blah
15:48:18 <mreh> the laziness counts for something
15:48:19 <benmachine> that sort of thing
15:48:25 <SliMM> monochrom: Actually, that convention was the one I was hoping to exist!
15:48:29 <SliMM> Awesome
15:48:57 <ksf> how do I get hold of the bsr instruction?
15:49:02 <mreh> unless you're Henning Theilman, in which case be annoying.
15:49:44 <ddarius> data T = ...; class C a where ...; instance C T where ...
15:50:03 <mreh> > True || (length [1..] > 1)
15:50:04 <lambdabot>   True
15:50:24 <mreh> > False && (length [1..] > 1)
15:50:25 <lambdabot>   False
15:50:59 <ddarius> not (a || b) /= not a && not b
15:51:22 <ksf> ...don't tell me I have to fire up gcc and use inline assembly
15:51:28 <mreh> > if True then 9001 else length [1..]
15:51:29 <lambdabot>   9001
15:51:38 <ksf> that function call overhead is completely unnecessary
15:51:41 <ddarius> @hackage harpy ...
15:51:41 <lambdabot> http://hackage.haskell.org/package/harpy ...
15:52:21 <mreh> are you suggesting I do assembly to speed it up?
15:53:20 <ksf> hmmm.
15:53:35 <ksf> I'm going to trust IntMap and use | and shift
15:54:04 <ddarius> ksf: There's also a trick where you cast a bytestring (or some other byte array type) into a function type and thus execute arbitrary machine code.
15:54:32 <copumpkin> sounds beautiful
15:54:39 <ksf> ...but the intmap source says a loop is as fast as bsr
15:54:58 <ksf> which doesn't surprise me, bsr has to be translated into a microcode loop.
15:55:18 <ksf> they don't tend to waste silicon for such stuff.
15:55:39 <ddarius> ksf: Why not?  We have more silicon than we know what to do with now.
15:56:18 <monochrom> They waste silicon for a disabled floating point unit.
15:56:31 <SamB_XP> what do you mean, "disabled"?
15:56:31 <monochrom> Or at least, they wasted.
15:56:38 <monochrom> "486 SX"
15:56:47 <copumpkin> old-school :P
15:56:55 <SamB_XP> I was about to say that they did that in the 486 days
15:56:59 * ddarius readily remembers getting a 486 DX
15:57:03 <SamB_XP> but the 486 days are not present tense!
15:57:26 <ksf> it's not like the x87 on my cpu would get much exercise
15:57:26 <ddarius> SamB_XP: 486s are still out there in a significant way.
15:57:28 * copumpkin had a dx2
15:57:40 <copumpkin> 66 MHz
15:57:42 <monochrom> Today, they don't disable floating point units. They disable like 2MB of cache, or Vx-T circuits.
15:57:42 <ddarius> copumpkin: Yeah, it was specifically a 486 DX 2 66
15:57:43 <SamB_XP> ddarius: but not the SX!
15:57:43 <mreh> graphics cards have sections deliberately destroyed, or locked off
15:57:51 <copumpkin> mmm :)
15:57:54 <copumpkin> what power!
15:57:55 <ksf> I don't have that much 32-bit code on my machine, and none of it is float-intensive.
15:58:10 <ksf> ...and even then compilers tend to use sse.
15:58:40 <ddarius> I would use SSE whether I was writing by hand or making a compiler.
15:59:08 <Berengal> Who uses 32 bit floats anyway? The small precision offends the logician in me...
15:59:22 <copumpkin> Doubles you find acceptable?
15:59:28 <SamB_XP> Berengal: how about 80-bit ?
15:59:31 <ddarius> Berengal: The logician in you should be offended by any finite precision.
15:59:42 <Berengal> ddarius: He is. He prefers peano numbers
15:59:55 <ddarius> Berengal: Blech on Peano nats.
15:59:56 <Berengal> copumpkin: doubles at least have more precision than a regular 32 bit int
15:59:58 <SamB_XP> that's the native precisian of the x87 (which is generally what is used by 32-bit code)
16:00:05 * ksf has a dx50 on a pci/vlb board with 64mb flying around. got to hook it up sometime.
16:00:13 <copumpkin> Berengal: no more precision than a 64-bit int though :)
16:00:33 <SamB_XP> copumpkin: well, that depends on where in the range you are
16:00:50 <Berengal> copumpkin: Indeed, which is why doubles are a waste anyway. It's a bit harder to go wrong with them, but it's not any easier to go right.
16:00:53 <SamB_XP> + they can go a heck of a lot higher
16:00:57 <ddarius> 24/8 fixed point all the way
16:00:59 <ksf> I think the fastest thing there is the diamond stealth 64...
16:01:05 <copumpkin> hell yeah
16:01:45 <monochrom> vlb was very short-lived.
16:01:51 <ddarius> monochrom: Yep.
16:01:58 <Berengal> Rationals all the way!
16:02:09 <benmachine> all numbers are rational anyway
16:02:10 <ddarius> monochrom: AGP wasn't much longer lived.
16:02:12 <Berengal> Or computable reals if you have a need for them
16:02:28 <ksf> agp still lives on.
16:02:33 <ddarius> ksf: For now.
16:02:36 <ksf> ...at least in my box, that is.
16:02:51 <ksf> vlb was fast.
16:03:14 <ksf> before I got this board off of ebay, I didn't even know there were 486 pci boards
16:03:23 <ddarius> ksf: Really?
16:03:25 <monochrom> heh
16:03:28 <ksf> ...what I _do_ know is that those pci slots are a bugger to set up.
16:03:34 <ksf> never got anything running in them.
16:03:47 <ddarius> I didn't have any more trouble with PCI than ISA.
16:04:12 <monochrom> perhaps if a board tries to support both pci and vlb, it's a bugger
16:04:31 <ksf> yep
16:04:44 <ddarius> monochrom: I'm pretty sure I had a motherboard with two PCI slots and a VLB slot and didn't have any particular trouble I remember.
16:04:46 <ksf> perhaps I should try to run it pci-only
16:05:06 <ddarius> s/and a VLB slot/and VLB/
16:05:19 <ksf> I've still got a trio64v+ flying around (and a monster3d), but IO is going to be problematic.
16:05:41 <monochrom> I had a Matrox display card. :)
16:05:52 <ksf> ...choices are EISA or vlb
16:06:22 <ddarius> monochrom: I had one too and a Diamond Stealth 64.
16:06:55 <ddarius> A Matrox Mystique something something if I remember correctly.
16:07:17 <nus> ddarius, how about a Diamond Viper?-)
16:07:38 <ddarius> nus: I think we had one that we never used...
16:07:56 <ddarius> nus: There was a lot of computer hardware in my house when I was growing up.
16:09:14 <ddarius> "The text is so bad, it can't be authentic."
16:10:37 <ddarius> er
16:10:38 <Cale> I think I had a Viper card at one point. I think it was a V770.
16:10:39 * ddarius misread.
16:12:46 <Cale> http://www.toothpastefordinner.com/022410/i-like-my-coffee-like-i-like-my-coffee.gif
16:13:15 <MissPiggy> lol
16:14:06 <p_l> hahahahaha, I'd like recursive coffee :D
16:14:29 <nus> do you foldr your coffee?
16:14:51 <ezyang> I love performing hylomorphisms on my dumplings
16:18:42 <nus> hmm, to -XTypeSynonymInstances or not, that is the...
16:18:58 <MissPiggy> I use it
16:19:03 <MissPiggy> I don't see a problem with it really
16:19:38 <mreh> add to taste
16:21:18 <mreh> oooh, evaluating boolean expressions, perfect application for parallel computation?
16:21:28 <mreh> maybe not...
16:21:35 <SamB_XP> I put coffee in your coffee so you can wake up while you wake up
16:21:45 <ezyang> Open your eyes. Now open them again.
16:22:00 <copumpkin> ugh
16:22:31 <Polarina> Is there a mathematical symbol for deriving things?
16:22:38 <MissPiggy> what do you mean?
16:22:40 <SamB_XP> ezyang: but I'm not attempting witchcraft!
16:22:51 <MissPiggy> I am not even sure what it is to "deriving things"?
16:23:14 <Polarina> MissPiggy, data Persons = Persons String String Int deriving (Eq, Ord)
16:23:30 <MissPiggy> oh tha
16:23:50 <SamB_XP> ezyang: you are referencing witch of pratchets works?
16:24:01 <MissPiggy> 2
16:24:13 <ezyang> SamB_XP: That is correct!
16:24:24 <MissPiggy> which book??
16:24:28 <copumpkin> it seems impossible to write this function: fromList :: G.Vector v a => [a] -> (forall n. Nat n => Vec n v a -> r) -> r
16:24:54 <copumpkin> without the Nat constraint it works fine, but is a lot less useful
16:25:04 <copumpkin> damn lack of dependent types
16:25:09 * SamB_XP can't remember the title of the one he's thinking of ...
16:25:19 <ezyang> hat full of sky?
16:25:32 <copumpkin> oh, I'll have it pass in the length
16:25:38 <SamB_XP> ezyang: isn't that the 2nd one ?
16:25:47 <ezyang> I... think so...
16:26:01 <MissPiggy> copumpkin: why is it more useful with the Nat constraint?
16:26:13 <ezyang> it's more constrained
16:26:16 <copumpkin> MissPiggy: because I know it's a Nat, and I might as well tell people that
16:26:24 <ezyang> less ways to shoot yourself in the foot
16:26:33 <MissPiggy> but is there a function you can write with it, that is not otherwise implementable?
16:26:47 <copumpkin> yep, any function that wants a Nat n => Vec n v a
16:27:00 <MissPiggy> :/
16:27:03 <copumpkin> oh I know what I can do
16:27:16 <Saizan> copumpkin: you've to construct a proof of Nat n, data IsNat n where IsNat :: Nat n => IsNat n
16:27:18 * MissPiggy does not understand
16:27:24 <copumpkin> Saizan: yeah :)
16:27:51 <MissPiggy> I don't know a lot about typeclasess
16:27:56 <MissPiggy> so I can't see what that Nat is for
16:28:12 <copumpkin> it's a "closed typeclass"
16:28:16 <copumpkin> wrapping S and Z
16:31:35 <copumpkin> meh, had enough for now
16:31:42 <SliMM> When I create an instance of Ord, how do I create more than one function for tha instance? (I get syntax error for multiple)
16:32:14 <aavogt> you should only have to implement compare
16:32:33 <aavogt> but perhaps you're not aligning bindings after the where, SliMM
16:32:54 <MissPiggy> copumking let me see?
16:32:56 <ddarius> aavogt: Implementing any of the methods will provide definitions for all of them.
16:33:05 <MissPiggy> I want to understand the meaning of that Nat n thing in the forall
16:33:25 <SliMM> aavogt: shouldn't I implement (<) and (<=) at least?
16:33:38 <ddarius> @src (<)
16:33:38 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
16:33:42 <ddarius> @src (<=)
16:33:42 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
16:33:46 <ddarius> @src compare
16:33:47 <lambdabot> compare x y | x == y    = EQ
16:33:47 <lambdabot>             | x <= y    = LT
16:33:47 <lambdabot>             | otherwise = GT
16:34:12 <aavogt> @src (>=)
16:34:13 <lambdabot> x >= y = case compare x y of { LT -> False; _other -> True }
16:34:47 <SliMM> Interesting
16:34:52 <aavogt> ddarius: if that's the actual definition, then >= isn't sufficient, right?
16:35:08 <ddarius> aavogt: Indeed.
16:35:51 <ddarius> So compare or (<=) are minimal sets of definitions.
16:36:07 <aavogt> yeah, says so here: http://www.haskell.org/onlinereport/standard-prelude.html
16:36:09 <ddarius> @src Ord
16:36:10 <lambdabot> class  (Eq a) => Ord a  where
16:36:10 <lambdabot>     compare      :: a -> a -> Ordering
16:36:10 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
16:36:10 <lambdabot>     max, min         :: a -> a -> a
16:36:29 <MissPiggy> ooh
16:36:36 <MissPiggy> I can call mine:  Nonstandard Prelude
16:36:42 <copumpkin> MissPiggy: what part of it? sorry
16:36:57 <MissPiggy> copumkin I just wanted to try and understand it
16:37:40 <copumpkin> MissPiggy: an older (and cleaner) version is up at http://hackage.haskell.org/packages/archive/vector-static/0.0.1/doc/html/src/Data-Nat.html#I
16:38:56 <MissPiggy> yikes
16:38:58 <MissPiggy> did you write that?
16:39:04 <MissPiggy> that's wild
16:39:29 <copumpkin> oh, nope
16:39:43 <copumpkin> I have a comment in the more recent version attributing most of it to http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html
16:39:48 <copumpkin> the newer version is uglier and mine :P
16:47:26 <copumpkin> hmm, bringing IsNat in will add unary slowness to everything
16:47:33 <copumpkin> must come up with a better way
16:49:14 <ezyang> Our university is having rush events, and I'm writing Haskell-themed descriptions for the food events.
16:49:23 <copumpkin> :o
16:49:24 <ezyang> :-)
16:49:51 <copumpkin> what's sad is that not even unsafeCoerce can get me a proof of Nat
16:50:00 <copumpkin> need to come up with something smarter
16:50:15 <copumpkin> we need an "unsafeProvideDictionary"
16:50:20 <ezyang> heh
16:53:35 * copumpkin runs back screaming to agda
16:54:24 <ezyang> ah copumpkin. he was such a fine promising lad
16:54:42 <copumpkin> :)
16:55:05 <copumpkin> it's remarkably hard to do the "right thing" while not adding overhead
16:55:06 <Saizan> foo :: Int -> (forall n. Nat n => n -> r) -> r; foo 0 k = k Z; foo (n+1) k = foo n (\m -> k (S m)) ?
16:55:22 <Saizan> i guess that adds a lot of overhead :)
16:55:31 <copumpkin> yeah :) that's what I've been trying to avoid
16:55:42 <copumpkin> I'd like to have unary at the type level but ints at the value level
16:56:10 <copumpkin> I have smart constructors to keep them in sync, but it's pretty hard to prove things about them
16:56:28 <copumpkin> especially with this damn Nat constraint on things
16:56:38 <copumpkin> maybe I should just move to a pure GADT rep for Nats
16:57:39 <copumpkin> hm
16:58:38 <Saizan> the point is that the Nat constraint is translated into O(n) nested dictionaries
16:58:48 <copumpkin> yeah
16:58:52 <copumpkin> and that's not good
16:59:16 <copumpkin> I think I'll just change my Nat rep
16:59:19 <Saizan> though in some cases GHC can actually optimize them away
17:00:08 <copumpkin> hm
17:00:16 <copumpkin> this is too hard, /me goes shopping
17:00:34 <MissPiggy> I agree
17:00:54 <Saizan> oh
17:02:16 <Saizan> maybe the best thing is to have an newtype Nat n = Nat Int and a data NatView n where Zero :: NatView Z; Succ :: Nat n -> NatView (S n)
17:02:32 <copumpkin> hm
17:03:44 <Saizan> so you can use NatView when you need the refinements, but Int otherwise, and providing a Nat n is just a matter of applying a newtype constructor to some Int you've around
17:04:18 <copumpkin> maybe
17:04:23 <Saizan> mh, there's still the problem of picking the right 'n' though
17:04:23 <copumpkin> hmmmmmmmm
17:04:27 <copumpkin> yeah
17:05:40 <Saizan> mh, no, it doesn't matter if you're not providing a class context for it
17:05:47 <copumpkin> that's true
17:06:16 <copumpkin> meh, don't feel like doing it now :)
17:06:28 <copumpkin> Saizan: the latest version is up on github if you want to play with it
17:06:42 * copumpkin yawns
17:06:52 <Saizan> heh, ok :)
17:07:53 <copumpkin> wtf is up with a dependency of array ==0.2.*, base >=4.0 && <5.0 && <4, parsec >=3.0 && <4.0 && <3
17:08:09 <copumpkin> specifically, that parsec >= 3.0 && < 3 constraint
17:08:28 <Saizan> where's that from?
17:08:31 <copumpkin> pisigma
17:09:14 <copumpkin> someone should prove to the authors (using pisigma) that such a constraint cannot be satisfied
17:09:50 <Saizan> heh
17:09:55 <Saizan> it seems to work here
17:10:04 <copumpkin> hm
17:10:10 <copumpkin> how?
17:10:34 <Saizan> i don't see the parsec < 3 constraint
17:10:44 <copumpkin> it sees to work here too :)
17:10:51 <copumpkin> doesn't parsec >=3.0 && <4.0 && <3 mean that?
17:11:44 <Saizan> yeah, but i don't see that constraint in the .cabal file
17:11:50 <copumpkin> oh
17:12:05 <copumpkin> it's in the build failure on hackage
17:12:06 <copumpkin> weird
17:12:24 <Saizan> however array-0.2 doesn't build
17:14:07 * copumpkin decides to write a data structure that nobody has ever written before!
17:14:13 <copumpkin> :D
17:14:19 <ezyang> oh man
17:14:28 <copumpkin> it will be called BitmaskTree
17:14:34 <ezyang> ...
17:14:42 <ezyang> That sounds sort of like a hash array-mapped trie
17:14:46 <copumpkin> not at all
17:14:51 <copumpkin> no Trie to be seen
17:14:52 * MissPiggy has got 99 data structures but the bitmask-tree aint one
17:15:03 <copumpkin> I have a very specific application in mind for it
17:15:09 <copumpkin> and a trie of bits isn't suitable
17:16:05 <copumpkin> in fact, I doubt it has any other applications, but I'll publish it anyway
17:16:06 <Cale> A monoidal tree?
17:16:10 <copumpkin> Cale: of course
17:16:18 <akappa> copumpkin, what data structure is?
17:16:20 <Cale> Which monoid on bits?
17:16:32 <Cale> Or? Xor?
17:16:35 <copumpkin> Cale: union
17:16:35 <copumpkin> or
17:16:43 <copumpkin> is there one already out there?
17:16:48 <Cale> hmm
17:17:01 <copumpkin> it's a bit of a combination of an r-tree with an or-monoid bit thingy
17:17:21 <copumpkin> if that makes any sense
17:17:32 <ezyang> what's the application?
17:18:23 <copumpkin> a decoder for ARM
17:18:55 <akappa> copumpkin, what type of queries it supports?
17:19:06 <Cale> Is there a kind of tree which can do log-time splitting in more than one index?
17:19:49 <akappa> Cale, splitting based on what conditions?
17:21:03 <copumpkin> akappa: I haven't actually thought it through very carefully yet, but I think it should work. Queries will be a Word32 mostly, and data in it will be of the form "pick me if query & my mask = my value"
17:22:02 <akappa> so it's a set with a particular membership condition
17:22:06 <copumpkin> yep
17:23:35 <copumpkin> well, the overall datastructure isn't a set, it's a map
17:23:49 <copumpkin> mapping Word32s to decoder functions
17:23:54 <copumpkin> based on the broad class of instruction
17:24:06 <copumpkin> but I'd be treating the bits as a set
17:24:17 <Cale> akappa: Arbitrary monotone conditions would be nice, but for simplicity, suppose each element in the tree is indexed with two natural numbers (x,y), and you want to have an operation splitX :: Integer -> Tree -> (Tree, Tree) which splits the tree into those with x coordinate less than or equal to, and greater than, the given integer, and a similarly typed operation for splitting on Y coordinate, and both work in log ti
17:24:17 <Cale> me.
17:24:58 <Cale> Can a normal kd-tree do that?
17:25:22 <Cale> Or is it impossible?
17:25:26 <Cale> I don't really know :)
17:26:53 <gwern> @seen dcoutts
17:26:53 <lambdabot> Unknown command, try @list
17:26:57 <gwern> preflex: seen dcoutts
17:26:57 <preflex>  dcoutts was last seen on #ghc 19 days, 6 hours, 4 minutes and 54 seconds ago, saying: ok, ta
17:27:21 <gwern> hm. I was going to ask his thoughts about making depending on the haskell98 a warning
17:28:59 <aavogt> :t \(a `Node` b) -> (a,b)
17:29:00 <lambdabot> forall t. Tree t -> (t, Forest t)
17:30:07 <gwern> no one objects to the idea?
17:30:50 <aavogt> who does it?
17:31:01 <gwern> aavogt: you want the full list or would a few dozen suffice?
17:31:33 <gwern> aavogt: http://community.haskell.org/~gwern/wiki/TODO.page scroll down a screen or two
17:32:23 <aavogt> gwern: also to package? http://moonpatio.com/repos/haskell-src-meta_NEW_TH/
17:33:07 <gwern> aavogt: what is that?
17:33:17 <gwern> hm, looks like he no longer uses the dcoutts address, but duncan@haskell.org
17:33:37 <gwern> aavogt: but that's packaged, so what do you mean?
17:33:38 <aavogt> rather I mean to upload a new version
17:34:12 <gwern> aavogt: email mmorrow and complain. he has a hackage account and is active, so I've no reason to step on his toes
17:35:06 <gwern> matt is pretty responsive
17:35:22 <aavogt> ok
17:35:36 <aavogt> he hasn't been around #haskell recently though
17:40:35 <copumpkin> he said he was finishing up his thesis I think
17:41:24 <gwern> hm. better make it a cabal ticket
17:41:29 <gwern> he'll see it that way too
17:41:34 <copumpkin> his thesis?
17:41:39 <copumpkin> :)
17:41:39 <gwern> http://hackage.haskell.org/trac/hackage/ticket/640
17:45:51 <interferon> what is the command that gives a points-free version of an  expression?
17:46:13 <gwern> @pl
17:46:13 <lambdabot> (line 1, column 1):
17:46:13 <lambdabot> unexpected end of input
17:46:13 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:46:28 * hackagebot glpk-hs 0.0.3 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.0.3 (LouisWasserman)
17:46:43 <interferon> thanks
17:48:52 <gwern> hard drive pricing is weird. for 50$ I can get a 320GB drive. or, for 50$ more, I could get a 1.5tb drive -_-
17:49:20 <damd> what could you get for FIVE MILLION DOLLARS?
17:49:35 <copumpkin> p(s) = k + a * s
17:49:47 <Cale> It doesn't take that much more in the way of raw materials to make a 1.5 TB drive, I suspect.
17:49:50 <gwern> > (5000000 / 90) * 1.5 -- assume a volume discount of 10%
17:49:51 <lambdabot>   83333.33333333333
17:50:01 <gwern> damd: 83 PETABYTES
17:50:14 <damd> AND WHAT ABOUT THIRTY BAZILLION DOLLARS?
17:50:41 <gwern> bazillion? what are you, some kind of hick? everyone knows bazillions don't exist
17:50:55 * copumpkin is a hick, thank you very much
17:50:57 <damd> gwern: http://en.wikipedia.org/wiki/Bazillion
17:51:13 <copumpkin> http://en.wikipedia.org/wiki/Yall
17:52:07 <monochrom> price is not cost
17:52:40 <monochrom> I'll take it to -blah
17:53:19 <interferon> can i run @pl without logging into irc? :)
17:53:28 <copumpkin> @hackage pointfree
17:53:28 <lambdabot> http://hackage.haskell.org/package/pointfree
17:53:46 <interferon> thanks
18:02:18 <interferon> is there a function that's like getDirectoryContents but is recursive?
18:03:38 <damd> should be fairly easy to write one in haskell?
18:04:21 <copumpkin> it's tricky
18:04:28 <copumpkin> unless you write it imperatively
18:05:31 <interferon> i want something like "findAllFilesIn path"
18:05:43 * ezyang had to write an infix parser, and the imperative version was so much easier 
18:05:47 * ezyang sighs 
18:05:59 <copumpkin> infix parser?
18:06:05 <ezyang> 2+3*4
18:06:12 <copumpkin> really?
18:06:15 <ezyang> yup.
18:06:16 <copumpkin> what did you use for the haskell version
18:06:20 <ezyang> it was hw, so I couldn't just crib stuff
18:06:27 <ezyang> this was in mit-scheme ;-)
18:06:31 <copumpkin> ah, lame
18:06:38 <copumpkin> you should've written a mixfix parser :)
18:06:45 <ezyang> mmm, mixfix
18:06:50 <ezyang> sounds like a tasty drink
18:06:58 <copumpkin> you haven't come across it?
18:07:14 <ezyang> nope, looking up now
18:07:23 <gwern> interferon ought to've just shelled out to find
18:07:33 <copumpkin> you just put underscores in your symbol names and you get magic operators that way
18:07:39 <copumpkin> (+) in haskell is _+_ in agda
18:07:45 <copumpkin> but you can write if_then_else_, too
18:08:00 <ezyang> hmm
18:08:03 <copumpkin> sounds like a real nightmare to parse, but is awesome
18:08:04 <ezyang> sounds complicated
18:08:07 <ezyang> heh
18:09:44 <SamB_XP> copumpkin: how do you indicate that indentation is required ?
18:09:52 <copumpkin> you don't
18:10:01 <SamB_XP> :-P
18:10:47 <copumpkin> :)
18:23:38 <roconnor> wow the gimp is so terrible
18:23:53 <SamB_XP> what'd it do now ?
18:24:04 <roconnor> the cavas effect is horriblly horrible
18:24:12 <SamB_XP> oh
18:24:29 <SamB_XP> so one of the included pluginy things is lousy, big surprise!
18:24:51 <SamB_XP> doesn't it have a way to write a better one in Haskell yet ?
18:28:18 <roconnor> I need to write a paint program in haskell
18:32:11 <jmcarthur> roconnor: if you do it my wife might be interested enough to learn haskell better to help out
18:32:18 <philo> having some trouble with IORef
18:32:40 <philo> andIOArray
18:32:51 <roconnor> jmcarthur: I wrote a paint backend for my job 10 years ago
18:33:06 <jmcarthur> sweet
18:33:07 <philo> does readIORef create a new object ?
18:33:25 <jmcarthur> share that experience with the haskell and open source graphics community! (myself and my wife respectively)
18:33:47 <roconnor> my colour library was my first step to writing a paint program
18:33:53 <jmcarthur> ooh
18:33:59 <philo> any one ?
18:34:02 <jmcarthur> do continue! :)
18:34:04 <roconnor> I figure I keep writing haskell libraries until there is enought to build a paint program in one line
18:34:07 <Saizan> philo: it doesn't
18:34:19 <Cale> philo: "create a new object"?
18:34:21 <roconnor> @type readIORef
18:34:22 <lambdabot> Not in scope: `readIORef'
18:34:32 <roconnor> @hoggle readIORef
18:34:32 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
18:34:40 <philo> i am doing a writeArray call
18:34:51 <philo> but the change sems to be only local
18:35:28 <Cale> philo: Let's look at your code.
18:36:24 <Cale> http://hpaste.org/new
18:36:47 <philo> http://pastebin.ca/1812839
18:37:33 <Cale> You have an IORef which holds an IOArray? Is that really necessary?
18:37:49 <philo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23067#a23067
18:38:19 <philo> not really
18:38:50 <philo> but are the change done to the array suposed to be permanent
18:39:03 <Cale> IOArray is already a mutable array, and changes you write to it are permanent.
18:39:25 <Cale> What are the Exprss and EnvRef types?
18:40:23 <philo> EnvRef = IORef((String,String))
18:40:29 <philo> something like that
18:40:37 <Cale> print writeArray tab 1 ("kuyguyg",Vnum 8976,Tnum) -- this looks like a blatant type error
18:40:59 <philo> yea
18:41:01 <philo> sory for that
18:41:10 <philo> was testing the code
18:41:31 <lispy|web> Cale's brain has a dedicated type checker
18:41:43 <Cale> hehe
18:42:07 <ddarius> lispy|web: Type checking is easier than program evaluation and most programmer's can evaluate (simple) programs in their heads.
18:42:09 <Cale> I would expect that anyone who programs in Haskell eventually builds a dedicated type checker in their brain.
18:42:11 * lispy|web needs to do more freetime coding
18:42:17 <ddarius> -'
18:42:29 <lispy|web> Cale: yeah
18:42:37 <philo> lol
18:43:17 <lispy|web> I've been helping some people who are new with haskell and it's reminded me how badly we need a tool that loads a project's code into ghci properly from a .cabal file.
18:43:22 <lispy|web> I think it may not be that hard to write
18:43:41 <lispy|web> Really it's the CPP macros, cabal flags, and packages that need to be respected
18:43:55 <Saizan> i've an hacky snippet
18:44:04 <lispy|web> Getting those passed to GHCI correctly would do for 90% of stuff
18:44:07 <Saizan> that reads the configuration produced by cabal configure
18:44:18 <lispy|web> Saizan: using the Cabal library?
18:44:22 <Saizan> yeah
18:44:27 <lispy|web> Saizan: oh, share!
18:45:11 <Saizan> http://code.haskell.org/~Saizan/ghci-utils-0.1.tar.gz
18:45:27 <Saizan> http://code.haskell.org/~Saizan/.ghci
18:46:07 * Saizan should make a rpo
18:46:13 <Saizan> *repo
18:46:16 <lispy|web> yeah, use darcs :)
18:46:21 * lispy|web downloads
18:46:53 <Saizan> the most obvious improvement would be to filter out the flags ghci doesn't understand
18:47:56 <lispy|web> Saizan: the .cabal file lists a repo
18:48:10 <Saizan> it lies
18:48:26 <lispy|web> heh, you "borrowed" your .cabal file didn't you?
18:48:33 <Saizan> yeah :)
18:49:55 <lispy|web> hmm...it builds a library?
18:50:01 <lispy|web> So the .ghci is required to use it?
18:50:44 <lispy|web> Saizan: so, if I install it, how would I know it's working?
18:52:07 <Saizan> lispy|web: after you've installed, and put the macros in the .ghci into your own, from a project dir where you've run "cabal configure" :_loadOpts should set all the options
18:52:45 <lispy|web> Saizan: so afte ryou :_loadOpts you can :l a file and it should load?
18:53:05 <Saizan> yeah
18:53:13 <lispy|web> I'll give it a try
18:54:17 <lispy|web> Saizan: hmm
18:54:35 <lispy|web> Saizan: It failed, but I think that's because it built against an older version of Cabal than what I'm really using
18:55:29 <Saizan> it should say something like that when it tries to read the stored configuration, if that's the case
18:55:30 <lispy|web> trying a cabal clean
18:55:36 <lispy|web> Yeah, it did
18:55:47 <lispy|web> My cabal-install is linked against 1.8.x though
18:55:50 <lispy|web> So...hmm
18:56:15 <Saizan> ghc-pkg list Cabal ?
18:56:42 <lispy|web> doing a clean fixed it
18:57:08 <lispy|web> hmm
18:57:12 <lispy|web> A new bug :)
18:57:45 <Saizan> it's an hack, use at your own risk :)
18:58:06 <Saizan> it worked for me with Agda
18:58:18 <lispy|web> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23068#a23068
18:58:27 <lispy|web> Saizan: ah, cool
18:58:32 <lispy|web> Well, I'll work on it later
18:58:36 <lispy|web> I'm going to go workout right now
18:58:39 <lispy|web> Thanks for the tool
18:58:42 <lispy|web> It's a good start
18:59:10 <Saizan> oh, true
18:59:15 <Saizan> you've to run cabal build too
18:59:21 <lispy|web> aah
18:59:27 <Saizan> that's when those files get generated
18:59:33 <lispy|web> I'll check it when I get back then
18:59:36 <lispy|web> thanks
18:59:45 <Saizan> np
19:34:34 <lavoiseb> hello world, I am doing an academic project in haskell, is there a way to retrieve the ararity of a function? or at least pass parameters to a function until it takes no more arguments
19:34:51 <copumpkin> only with some voodo
19:34:54 <copumpkin> voodoo, even
19:35:09 * ezyang would say black magic 
19:35:18 <lavoiseb> well, ill explain my problem, maybe you got an idea
19:35:24 <SamB_XP> you can't do it!
19:35:29 <enthymene> you can use :t in the ghci
19:35:36 <enthymene> :t fold, for instance
19:35:37 <lambdabot> parse error on input `,'
19:35:38 <SamB_XP> at least, it's probably almost as hard as the halting problem ?
19:35:40 <lavoiseb> enthymene: yeah but into haskell?
19:35:41 <enthymene> hehe, sorry
19:35:48 <enthymene> into haskell?
19:36:16 <lavoiseb> i am interpreting a given language and I have an environment containing variables and functions
19:36:27 <pikhq> lavoiseb: It is possible in some instances to perform static analysis upon a program in order to discover this information.
19:36:43 <pikhq> Probably not helpful to you, though.
19:36:44 <lavoiseb> when it is a var, i'd like it to output the value and when its a function, I'd like to pass it the arguments it needs
19:37:06 <SamB_XP> haskell ain't even dynamically typed ;-P
19:37:12 <lavoiseb> the problem is there is no syntax difference between a var and a function
19:37:19 <enthymene> so you're writing an interpeter in haskell, you're saying
19:37:40 <lavoiseb> so if I want to do:   sum 1 2, it gives 3
19:37:53 <lavoiseb> but i want to be able to call sum sum 1 2 3
19:38:01 <pikhq> You're not wanting the arity of Haskell functions. You're wanting the arity of functions in your language.
19:38:06 <monochrom> If you write an interpreter, you are God, it's your call.
19:38:14 <enthymene> without adding the parentheses, a la  "sum (sum 1 2) 3"
19:38:19 <lavoiseb> monochrom: its my homework :P
19:38:35 <lavoiseb> enthymene: no parenthesis in syntax
19:38:42 <monochrom> You can even throw a die, get 4, and say "today the arity of sum is 4"
19:38:47 <pikhq> lavoiseb: Any number of ways to do that. Most of them involve "storing information".
19:38:52 <enthymene> haha
19:38:57 <lavoiseb> pikhq: the base functions are written is haskell
19:39:10 <lavoiseb> pikhq: yuk!
19:39:16 <pikhq> lavoiseb: ... So?
19:39:26 <enthymene> is there currying in this case, lavoiseb?
19:39:41 <lavoiseb> not really, its an imperative language
19:39:44 <monochrom> If you have variable arity, you need parentheses. This can be proved.
19:39:46 <pikhq> The base functions of Haskell are written in C. (... Well, fine. Primitives with which very basic things are implemented. Still.)
19:39:57 <pikhq> And yet, everything in Haskell is just a normal Haskell thing.
19:40:06 <enthymene> because I'd be hard pressed to DWYM on "sum sum 1 2 3" without rules telling me to do "sum (sum 1 2) 3" instead of "sum (sum 1) 2 3".  Not that there's a difference for arithmetic addition.
19:40:08 <lavoiseb> no, NOT has arity 1, SUM is arity 2
19:40:10 <pikhq> (modulo weird things like unsafePerformIO and unsafeCoerce)
19:40:20 <lavoiseb> MAX is arity infinite
19:40:31 <pikhq> enthymene: Known arity.
19:40:55 <monochrom> Then it is a test of your parser skillz.
19:41:00 <enthymene> pikhq: my question is more if "sum 1" is an error, or a curried function
19:41:00 <lavoiseb> meh
19:41:06 <pikhq> Ah.
19:41:15 <lavoiseb> enthymene: no curried, so error
19:41:20 <enthymene> kk then
19:41:27 <Saizan> lavoiseb: what course is this?
19:41:53 <monochrom> I did write a parser that can grok "sum sum 1 not 2 3" correctly. It can be done. This is good news for you.
19:41:56 <lavoiseb> Saizan: compilation
19:42:06 <lavoiseb> Saizan: http://www.iro.umontreal.ca/~monnier/6232/
19:42:29 <monochrom> Of course the assumption is known, fixed arity. not is 1, sum is 2, max is infinite. I need to know that. Then I can write a parser.
19:42:43 <lavoiseb> monochrom: i guess
19:42:52 <Saizan> i think you want to do it in a very non-hacky manner, and interpret your AST directly
19:43:05 <enthymene> ooh french :3
19:43:09 <enthymene> not that I can read it :/
19:43:13 <monochrom> Hint: "polish notation".
19:43:14 <lavoiseb> yeah, sry :P
19:43:18 <enthymene> is fine
19:43:24 <enthymene> after two years of spanish I could puzzle out Dumas
19:43:28 <monochrom> Another hint: need a stack.
19:43:39 <enthymene> and the $10+ words are always similar
19:43:55 <lavoiseb> well, i could always add fake curried
19:43:57 <enthymene> besides, it's an interesting challenge
19:44:05 <enthymene> like O'Caml?
19:44:21 <monochrom> Is "sum1 2" legal?
19:44:38 <lavoiseb> but, at the end, i need to test if the value is a function waiting for parameters or a value
19:45:13 <enthymene> well, operators come first
19:45:21 <lavoiseb> to give you a better idea, everything is prefix
19:45:22 <enthymene> so doing the polish notation seems sound
19:45:25 <pikhq> lavoiseb: So... Clearly you should have some way of telling if something is a function or a value.
19:45:28 <lavoiseb> so, no operators
19:45:41 <enthymene> heh, sorry
19:45:53 <enthymene> I'm new to Haskell, I was introduced to Functional Programming through Scheme.
19:46:00 <enthymene> so I'm fuzzy on the whole function/operator dichotomy
19:46:04 <lavoiseb> my problem arise on this:  is_equal sum x y 1
19:46:20 <SamB_XP> enthymene: what is that thing ?
19:46:26 <lavoiseb> that needs to be x+y == 1
19:46:32 <enthymene> SamB_XP: eh wot?
19:46:36 <Saizan> lavoiseb: can't you parse your expression into a datatype like data Expr = Const Int | Sum Expr Expr | Not Expr | Max [Expr] | ...
19:46:40 <monochrom> what is the arity of is_equal?
19:46:46 <SamB_XP> that dichotomy
19:46:46 <lavoiseb> monochrom: 2
19:46:49 <SamB_XP> not familiar with it
19:46:50 <enthymene> I don't knokw
19:46:54 <enthymene> apparently that's my problem
19:47:07 <monochrom> Then we are still under "known arity" polish notation. No new problem.
19:47:16 <enthymene> people like Paul Graham use operator and function somewhat interchangeably when talking about lisps
19:47:39 <SamB_XP> the only difference I'm aware of in Haskell is purely lexical
19:47:45 <monochrom> I interchange "operator" "operation" "function" too.
19:47:46 <enthymene> in Haskell the distinction seems to be--
19:47:49 <enthymene> yes lexical :p
19:47:49 <lavoiseb> but in fact, its being interpeted as is_equal (sum x y(3))
19:48:06 <SamB_XP> well, okay, a bit syntactical
19:48:11 <SamB_XP> but not abstract syntactical
19:48:14 <SamB_XP> ;-P
19:48:16 <enthymene> lavoiseb: is y a function?
19:48:22 <monochrom> People made a big distinction because stupid languages decreed arbitrarily that "function" user-definable, "operator" not.
19:48:32 <lavoiseb> no, its a var, but it understands it as a function
19:48:37 <enthymene> ah
19:48:52 <enthymene> maybe you need to make a syntactic distinction between functions and variables for your lexer?
19:49:02 <lavoiseb> there is none
19:49:04 <monochrom> If you encounter a var, look up what it contains, then you know arity. No new problem.
19:49:22 <enthymene> hrm
19:49:28 <enthymene> brb, have to go walk dogs... at another house!
19:49:35 <lavoiseb> an me have to pee
19:50:00 <ddarius> if x == 1 then y := sum else y := not; is_equal sum x y 3
19:51:32 <lavoiseb> ddarius: err... what?
19:51:44 <lavoiseb> this syntax is infix, it shouldnt be a big deal
19:52:23 <monochrom> there is 99% chance that x is not 1.
19:52:41 <monochrom> shall I say, x unequals 1.
19:52:45 <chrisdone> still messing about with structure of tutorial http://kiboki.net/haskell/tryhaskell-dev/
19:53:14 <MaciejP> Doesn't Happy auto-generate the lexer?
19:53:31 <lavoiseb> MaciejP: no
19:53:37 <lavoiseb> lexer = alex
19:53:43 <MaciejP> Ahh
19:53:58 <aavogt> chrisdone: can the output be line wrapped prettily like ie. IPPrint on hackage does?
19:54:27 <chrisdone> aavogt: which output?
19:54:39 <aavogt> in your tryhaskell console
19:54:54 <BMeph> chrisdone++
19:55:03 <BMeph> chrisdone: Nicely done, Sir! :)
19:55:04 <aavogt> as in use   IPPrint.pshow rather than show
19:55:20 <lispy|web> Saizan: Still not quite working
19:55:37 <lispy|web> Saizan: doing a build got me past the last error, but now I can't seem to use anything from the modules
19:55:40 <chrisdone> aavogt: possibly, I'll look into it. show might be built into it, not sure
19:55:44 <chrisdone> BMeph: cheers =)
19:56:15 <Saizan> lispy|web: it's made so it'll load the .o files in the dist/build directory produced by ghc
19:56:36 <Saizan> lispy|web: so you won't have the internals of the modules in scope
19:56:38 <lavoiseb> well, thats for the help, cya!
19:56:39 <lispy|web> Saizan: hmm...so once I've run :_loadOpts how do I get things into scope?
19:57:07 <Saizan> lispy|web: you can touch the module so that re-interpretation is triggered
19:57:25 <lispy|web> Saizan: er, I don't care about module internal stuff yet
19:57:59 <lispy|web> Saizan: Maybe I'm missing the point of :_loadOpts.  I thought it would make it so that I can reference things in the source like the modules (even if it's only the exported things)
19:58:27 <Saizan> lispy|web: you still need to :load the module
19:59:46 <lispy|web> Saizan: any ideas about this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23068#a23069
19:59:54 <Saizan> maybe loadOpts should be called loadFlags
20:01:01 <monochrom> polish notation is a bit nastier to process than reverse polish notation.
20:01:32 <lispy|web> monochrom: what about reverse hungarian polish notation?
20:01:43 <SamB_XP> lispy|web: kill me now!
20:01:46 <monochrom> I don't know.
20:01:51 <SamB_XP> hungarian is bad enough *without* RPN
20:02:19 <SamB_XP> although I suppose a *bit* of hungarian isn't too horrible -- I do sometimes use an "h" or a "p"
20:02:38 <aavogt> exactly, I was about to say that it is customary in haskell
20:02:41 <monochrom> What is reverse hungarian polish notation?  2 3 iAdd 4 5 iMul iEq bNot ?
20:03:02 <SamB_XP> lol
20:03:03 <Saizan> lispy|web: that looks like -hide-all-packages isn't working
20:03:13 <lispy|web> monochrom: it's english so whether reverse applies to hungarian or polish is ambiguous
20:03:25 <aavogt> at least to the degree where there is a difference between f and x and xs
20:03:32 <pikhq> monochrom: It's not all that much nastier to process than RPN.
20:03:41 <pikhq> Tokenise and reverse the list of tokens. Then parse as RPN.
20:03:42 <pikhq> :P
20:04:00 <monochrom> 1 iPod 2 iPhone 3 iPad iTunes iMac
20:04:11 <SamB_XP> oh, so it could be more like mulI 1 2 ?
20:04:42 <lispy|web> Saizan: oh, I 'll try passing that to ghci when I first sart it
20:04:52 <monochrom> I am not convinced of reversing.  subtract 3 2  is not  2 3 subtract
20:05:19 <monochrom> OK I am convinced. Just cheat.
20:05:48 <lispy|web> Saizan: heh, starting ghci -hide-all-packages is interesting :0
20:07:19 <Saizan> heh, it doesn't really work :)
20:08:17 <Saizan> ghci -hide-all-packages -package base -package ghci-utils
20:09:00 <lispy|web> Saizan: avast me hearty!
20:09:25 <Saizan> translated?:D
20:09:33 <lispy|web> Saizan: thanks!
20:09:44 <lispy|web> Saizan: that last one did the trick
20:09:53 <lispy|web> Saizan: So, I'll meditate on this
20:10:05 <lispy|web> This is already close to where I wanted to be
20:10:05 <Saizan> good
20:10:21 <lispy|web> I'd like to have module internals available, but that can relatively wait
20:10:31 <lispy|web> For now I can tell my beginner friends to export all
20:11:09 <lispy|web> Er...maybe it still have issues
20:11:56 <lispy|web> Yeah, it works for some stuff :)
20:12:16 <lispy|web> But, I can get it into a weird state
20:12:30 <lispy|web> I can load a module but if I try to browse it then things go all wonky
20:12:52 <Saizan> oh, really?
20:12:56 <lispy|web> yeah
20:13:03 <lispy|web> I did :l Darcs.Repository
20:13:08 <lispy|web> followed by :b Darcs.Repository
20:13:10 <lispy|web> Top level:     attempting to use module `Darcs' (src/Darcs.hs) which is not loaded
20:13:22 <lispy|web> Then I'm not even in the Prelude module after taht
20:14:12 <Saizan> i thought :b expanded to :break now
20:14:18 <lispy|web> hmm
20:14:21 <lispy|web> maybe, I thought it was browse
20:14:37 <lispy|web> ah ah!
20:14:41 <lispy|web> Saizan: thanks again
20:15:04 <lispy|web> I will stop playing with it now (time to meet a friend)
20:15:14 <Saizan> the -package-name things that is done only to avoid reinterpretation is probably not so well digested by ghci
20:15:29 <Saizan> so if you don't need that, maybe it's better to remove it
20:15:48 <lispy|web> You mean the ones on the command line?
20:15:55 <lispy|web> Those were definitely needed
20:16:28 <Saizan> i mean in the implementation of getGhcLibOptions
20:16:55 <Saizan> you should try if it's more stable without fmap (["-package-name", display . packageId . localPkgDescr $ lbi]++) $
20:27:41 <maurer_> Where can I find an article on how to use TH to apply a "deriving binary" like operation?
20:28:04 <aavogt> @hackage derive
20:28:05 <lambdabot> http://hackage.haskell.org/package/derive
20:28:34 <aavogt> in particular: http://hackage.haskell.org/packages/archive/derive/2.3.0/doc/html/Data-DeriveTH.html
20:32:58 <ksf> is there any transcendental reason shiftR is Word -> Int -> Word?
20:33:50 <copumpkin> you can shift right by negative amounts, I guess
20:33:53 <bos> dons: ping
20:34:03 <ksf> nope
20:34:25 <ksf> negative shifts are undefined, according to the GHC.Base source.
20:34:26 <tensorpudding> > 256 `shiftR` (-3)
20:34:27 <lambdabot>   Ambiguous type variable `t' in the constraint:
20:34:28 <lambdabot>    `Data.Bits.Bits t'
20:34:28 <lambdabot>      a...
20:34:47 <tensorpudding> > (256 :: Word16) `shiftR` (-3)
20:34:48 <lambdabot>   2048
20:35:02 <copumpkin> ksf: then it's just more useless ints in a language that seems to love them (if only because the decade-old standard forgot that unsigned numbers / naturals existed)
20:35:40 <tensorpudding> copumpkin: Word up, man
20:36:08 <twink> Unsigned numbers not being around is awkward, esp. wrt. Nat.
20:36:27 <dons> bos: pong
20:37:42 <SamB_XP> ksf: huh?
20:38:11 <SamB_XP> last I checked, shiftR and shiftL were both defined such that negatives did the other thing
20:38:42 <ksf> I'm talking about shiftL#, btw.
20:38:48 <ksf> I'm trying to be fast, after all.
20:38:50 <twink> Well, shiftL and shiftR aren't the awkward parts.
20:39:44 <ksf> I've even decided to use uncheckedShift, as checking whether the second arg is <= the bitsize doesn't matter
20:39:56 <tensorpudding> @check \x -> (shiftR x . shiftL x) (256 :: Word16) == (256 :: Word16)
20:39:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:40:11 <dons> ksf: just look at the core
20:40:16 <dons> and time it with criterion
20:40:20 <tensorpudding> @type shiftR
20:40:21 <lambdabot> forall a. (Bits a) => a -> Int -> a
20:40:28 <ksf> but...
20:40:42 <ksf> then I'd have to stop being pissed because my code doesn't typecheck
20:40:48 <ksf> due to Words not being Ints.
20:41:31 <ksf> I think I'm going to unsafeCoerce my way towards a properly typed shift.
20:41:32 <dons> ah
20:41:35 <dons> no no
20:41:42 <dons> it should all type. ghc does a great job on shifts
20:41:51 <dons> unsafeCoerce will break optimizations
20:41:56 <dons> rules won't fire and so on
20:43:05 <tensorpudding> @check (\y x -> shiftR (shiftL y x) x == y) $ (256 :: Word16)
20:43:06 <lambdabot>   "Falsifiable, after 23 tests:\n-10\n"
20:44:09 <SamB_XP> fI is probably faster than unsafeCoerce in this case ;-P
21:11:10 <cpettitt> Are there any special args I need to use to get profiling data from libraries (for example ByteString)?
21:11:35 <scutigera> @djinn (a -> b) -> f a -> f b
21:11:36 <scutigera>  
21:11:36 <lambdabot> -- f cannot be realized.
21:11:36 <cpettitt> When I do +RTS -p I see information for my functions, but ByteString, Vector, etc don't show up
21:12:46 <copumpkin> scutigera: with no knowledge of f :)
21:12:52 <copumpkin> @djinn Functor f => (a -> b) -> f a -> f b
21:12:52 <lambdabot> Error: Class not found: Functor
21:12:55 <copumpkin> boo
21:13:03 <Gracenotes> cpettitt: you installed them with profiling enabled?
21:13:16 <scutigera> copumpkin: don't help, I was doing my homework by cheating with djinn
21:13:20 <copumpkin> :)
21:13:37 <cpettitt> Yeah, I set library-profling: True in my ~/.cabal/config
21:13:40 <cpettitt> and reinstalled
21:16:39 <ksf> that's only adding profiling code, not cost centre annotations
21:16:59 <ksf> you have to add them yourself, or sneak -auto-all into ghc's command line.
21:17:57 <cpettitt> ksf: I did -auto-all and -caf-all in the ghc compilation
21:18:07 <cpettitt> do I need to pass those with +RTS too?
21:18:11 <cpettitt> to the process
21:18:14 <ksf> nope
21:18:46 <cpettitt> could it be something funky like the library code getting entirely inlined?
21:18:56 <ksf> absolutely
21:19:24 <ksf> you can always do {-# SCC "foo" #-}, I've never had one of those disappear
21:19:40 <cpettitt> aha! I'll give that a shot. Thanks ksf
21:20:36 <scutigera> copumpkin:  (a -> b) -> f a -> f b: I thought you couldn't construct an (a -> b) ?
21:20:49 <copumpkin> scutigera: hm?
21:21:00 <copumpkin> scutigera: oh, in this case it's passed in and a and b are concrete
21:21:00 <ksf> @djinn (a -> b) -> a -> b
21:21:00 <lambdabot> f a = a
21:21:33 <ksf> @djinn (a -> b) -> a -> (b, b)
21:21:33 <lambdabot> f a b = (a b, a b)
21:21:57 <ksf> @djinn (a -> b) -> (a,a) -> b
21:21:58 <lambdabot> f a (b, _) = a b
21:21:59 <scutigera> copumpkin: uh oh, I've scrambled something in my head.  what was that type sig that can't exist (other than const undefined)
21:22:10 <copumpkin> @@ @pl @djinn (a -> b) -> a -> (b, b)
21:22:10 <lambdabot>  f = ap =<< ((,) .)
21:22:28 <SamB_XP> @type const undefined
21:22:29 <lambdabot> forall a b. b -> a
21:22:38 <SamB_XP> scutigera: that one!
21:22:44 <copumpkin> scutigera: that's it, but there's a forall a b on it so it's forall a b. a -> b. The confusing thing is that haskell allows you (and forces you if you're a purist) to drop the forall for some types
21:22:51 <ksf> also known as unsafeCoerce
21:23:01 <SamB_XP> ksf: not really!
21:23:05 <ksf> though unsafeCoerce is more defined than const undefined
21:23:13 <SamB_XP> that one kills you
21:23:22 <SamB_XP> const undefined just bottoms out
21:23:29 <scutigera> wait wait wait , why is a->b different from b->a, I'm definitely missing something.
21:23:35 <copumpkin> it isn't
21:23:52 <scutigera> oh, sorry, it's the forall
21:23:54 <SamB_XP> @type fmap
21:23:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:23:59 <cpettitt> ksf: Your SCC suggestion worked. Thanks again for the help!
21:24:11 <SamB_XP> see -- no foralls inside with the (a -> b)
21:24:21 <ksf> ...well, accepting any a and yielding any b is different from accepting any function a -> b
21:24:29 <scutigera> @djinn b -> a
21:24:29 <lambdabot> -- f cannot be realized.
21:24:34 <scutigera> aaaargh
21:24:54 <pikhq> djinn doesn't like non-total functions.
21:25:08 <ksf> It's like attempting to write a function [Beer] -> [Girls]
21:25:19 <pikhq> And const undefined is about as non-total as you get.
21:25:19 <SamB_XP> ksf: that's easy!
21:25:26 <SamB_XP> except that djinn abhors a list
21:25:34 <pikhq> (it is, in fact, undefined for all values!)
21:25:48 <scutigera> I said something about this was starting to sink in.  I was clearly wrong :-(
21:26:26 <copumpkin> scutigera: move to logic a moment
21:26:45 <copumpkin> if someone asks you to prove that any fact implies any other fact, you're screwed
21:26:59 <scutigera> well I'd have to agree
21:27:29 <copumpkin> but if someone handed you an implication they knew about and you went and did something useful with it, you'd be fine
21:27:35 <scutigera> can I extrapolate to any Int implies any other Int
21:27:36 <jmcarthur> true=false --> anything
21:27:38 <copumpkin> like I tell you Fire implies Smoke
21:27:45 <Cale> Unless the logic is inconsistent (Haskell is, but the logic that djinn uses to construct functions is not)
21:28:23 <ksf> fast and loose reasoning is morally correct
21:28:24 <SamB_XP> if djinn used an inconsistant logic, it'd most likely always answer with "undefined"
21:28:27 <Cale> In Haskell, we could use f x = f x, say, to implement such a function.
21:28:32 <Cale> Or undefined.
21:29:45 <Cale> I think it'd possible for djinn to incorporate undefined to some extent, and yet still give a useful answer as far as possible.
21:29:50 <Cale> be*
21:30:19 <Cale> It already tries a bit to make use of all the parameters to functions that you give it
21:30:38 <Cale> @djinn a -> a -> (a,a)
21:30:38 <lambdabot> f a b = (b, a)
21:30:58 <Cale> Though, sometimes in not the most natural order it seems :)
21:31:40 <scutigera> @type map
21:31:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:32:17 <scutigera> like Functor f, f is cons ?
21:32:24 <Cale> hm?
21:32:42 <Cale> :t fmap
21:32:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:32:43 <scutigera> trying to understand the relationship between map and fmap
21:32:43 <pheaver> hi, i'm looking at some code that uses Control.OldException, trying to convert it to using the new Exception system.  I'm seeing catchDyn being used to catch things of type String.  I'm wondering, what Exception types would this correspond to?
21:32:49 <Cale> f is []
21:33:07 <ksf> f a -> ([] a)
21:33:09 <Cale> (not the empty list, but the type constructor for lists)
21:33:19 <ksf> er (([]) a)
21:33:27 <pikhq> scutigera: map :: (a -> b) -> [a] -> [b];map = fmap
21:33:35 <scutigera> :t ([])
21:33:36 <lambdabot> forall a. [a]
21:33:42 <Cale> :k []
21:33:43 <lambdabot> * -> *
21:33:47 <ksf> > toUpper . "amazing fact"
21:33:48 <lambdabot>   "AMAZING FACT"
21:33:48 <Cale> :t []
21:33:50 <lambdabot> forall a. [a]
21:34:10 <Cale> It's important to realise those are different, they're in completely different namespaces, so that's okay.
21:34:31 <scutigera> which "those" are different ?
21:34:37 <ksf> [] and []
21:34:41 <Cale> [] at the value level, and [] at the type level
21:34:52 <scutigera> oh !
21:34:54 <Cale> [] at the value level is the empty list
21:35:09 <Cale> [] at the type level is the type function which takes a type, and gives the type of lists of elements of that type
21:35:22 <scutigera> right - a little confusing.
21:36:07 <ksf> haskell is a bit confusing when soaked in syntactic sugar
21:36:11 <Cale> We could also write the type of map as  (a -> b) -> ([] a -> [] b)
21:36:42 <Cale> There has to be some way to take apart the notation [a] ;)
21:37:06 <Cale> [-] might have been better...
21:37:19 <scutigera> so in my "homework", instance Fluffy [] where, [] is a type not the empty list.
21:37:35 <Cale> yeah, a type *constructor*
21:37:41 <scutigera> ok.
21:37:50 <Cale> [] takes a type t and gives the type [t]
21:38:08 <scutigera> a function from type to type ?
21:38:24 <pheaver> that's what a type constructor is, yes, it is analogous to a function
21:38:26 <Cale> yeah
21:39:02 <Cale> If we'd defined the type of lists with no special syntax, then it would look like
21:39:09 <Cale> data List a = Nil | Cons a (List a)
21:39:13 <scutigera> but isn't Fluffy also a type constructor, so it's a type constructor / type constructor ?
21:39:24 <Cale> Fluffy is a typeclass, if I'm not mistaken
21:39:36 <pheaver> yeah, Fluffy looks like a typeclass here, not a type constructor
21:39:48 <scutigera> oh, right... cheese whiz
21:40:03 <Cale> If we were using the less sugary form of lists I just defined, you'd be trying to write
21:40:08 <pheaver> but you can indeed have type constructors that take in other type constructors
21:40:08 <Cale> instance Fluffy List where
21:40:34 <Cale> and it'd be clearer that List and Nil are separate things :)
21:40:50 <tommd> I seem to have broken my gtk2hs install and am not good enough with my ghc-pkg kung-fu to fix it.  When building the demos (any demo) I get linker errors (symbol not found for various symbols like "gtkXXXXX_closure").
21:41:02 <scutigera> yeah , something tells me I need to spend more quality time reading on type classes.  I thought they were making sense.  But I was wrong.
21:41:10 <tensorpudding> low-carb lists?
21:41:28 <tommd> These symbols are in my local HSgtk.o and its directory is included in the -L when I look at verbose output.  Any help?
21:41:52 <Cale> scutigera: It's possible for typeclasses to be parametrised by not just types, but type constructors as well
21:41:54 <scutigera> Cale: meanwhile the "verbose" List description is quite helpful and better for pedalogical purposes.
21:42:02 <Cale> scutigera: yeah
21:42:18 <Cale> So you have... if I remember the exercises correctly:
21:42:25 <Cale> class Fluffy f where
21:42:27 <pheaver> you mean pedagogical?
21:42:33 <pheaver> :)
21:42:36 <Cale>    furry :: (a -> b) -> (f a -> f b)
21:42:39 <Cale> yeah?
21:43:00 <scutigera> furry :: (a -> b) -> f a -> f b
21:43:02 <scutigera> same /
21:43:05 <scutigera> /
21:43:07 <scutigera> ?
21:43:07 <Cale> yeah, same thing
21:43:21 <Cale> So in the instance you're writing, which would be:
21:43:28 <Cale> instance Fluffy List where
21:43:30 <Cale>  ...
21:43:46 <Cale> The 'f' in the type of furry that you're implementing is specialised to List
21:44:00 <Cale> So you want a function of type  (a -> b) -> List a -> List b
21:44:54 <copumpkin> Saizan: ooh!
21:45:21 <Cale> There are only a few things you could make it do, but one of them is particularly natural.
21:46:58 <scutigera> Cale: theoretically my solution could ignore List a, right ?
21:47:05 * ksf can think of ten things he could make it do on the top of his head, all that he would be slapped for.
21:47:35 <Cale> scutigera: Yeah, you could have it just produce Nil all the time, for example
21:48:23 <Cale> scutigera: However, every defined element of the resulting list will have to come from the List a that you're given, and it'll have to have had the supplied function applied to it.
21:48:32 <ksf> you could seq the a's or you could not do it.
21:48:35 <SamB_XP> @free fmap
21:48:36 <lambdabot> Expected variable or '.'
21:48:48 <ksf> you could replace every second with undefined
21:48:58 <SamB_XP> @. free type fmap
21:48:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:48:59 <Cale> But within that constraint, you could get away with lots of silly things, like permuting the elements of the list, duplicating some, dropping some, or producing undefined stuff.
21:49:06 <SamB_XP> @help free
21:49:06 <lambdabot> free <ident>. Generate theorems for free
21:49:16 <SamB_XP> @free map
21:49:17 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
21:49:25 <SamB_XP> oh, yeah, that's what I wanted anyways ;-P
21:49:33 <ksf> you could repeat the first element indefiniteley
21:49:39 <enthymene> hey, did our friend from earlier get a solution to his problem?
21:49:49 <Cale> Usually when implementing typeclasses such as Functor or Monad, it's quite rude to provide implementations which throw exceptions or are sometimes undefined though.
21:49:56 <ksf> @free beer
21:49:57 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
21:50:28 <tensorpudding> > let lunch = error in free lunch
21:50:29 <lambdabot>   Not in scope: `free'
21:50:38 <tensorpudding> oh right
21:50:44 <tensorpudding> free not fix
21:56:42 * hackagebot dbus-core 0.8.1 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.1 (JohnMillikin)
22:02:43 <Zeiris_> Where can I read documentation of the {-# contract feature?
22:05:19 <MaciejP> Zeiris_: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
22:05:27 <Zeiris_> Thanks.
22:13:11 <Cale> Zeiris_: http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/haskellcontract.ps -- perhaps you're looking for this?
22:14:43 <Cale> Zeiris_: I don't think the contracts mentioned in that paper are actually in GHC as released though.
22:15:08 <Zeiris_> Meh, I just saw code using them and wanna know how they work.
22:16:30 <DV> Hi everyone,
22:17:07 <DV> I wish to work and contribute for Haskell, for the upcoming GSOC-10
22:17:35 <yix> UAE sent me /msg spam upon joining this channel.
22:17:42 <DV> I am quick-learner, with good knowledge and skills of the language
22:18:13 <DV> please let me know how i can prove my worth and move ahead for working, and btw i am from india :)
22:19:43 <DV> Is anybody active here
22:19:54 <Cale> I will be, one sec
22:19:54 <DV> can anybody read me or i am doing something wrong?? :(
22:20:31 <DV> hi cale
22:20:43 --- mode: ChanServ set +o Cale
22:20:54 --- mode: Cale set +b *!*@95.66.32.248
22:20:56 --- kick: UAE was kicked by Cale (UAE)
22:21:04 --- mode: Cale set -o Cale
22:21:10 <Cale> hello
22:21:21 <DV> hi, i am a student from india
22:21:31 <DV> and i wish to work for the language
22:21:40 <DV> and contribute to open source
22:21:40 <Cale> "the language" isn't really an institution :)
22:21:51 <Cale> If you have any questions about it, I can help answer them.
22:22:06 <DV> well yes, but i am not asking any questiongs
22:22:07 <Cale> I'm not a GSOC mentor, but maybe there are some here.
22:22:13 <DV> ok,
22:22:24 <DV> so, how should i proceed about it
22:22:32 <Gracenotes> we could start a Haskell cult where the deity is "The Language"
22:22:40 <dolio> Isn't there a list of suggested projects somewhere?
22:22:42 <Cale> Find a project that you're interested in and contribute code to it?
22:22:49 <DV> :D, k
22:23:03 <Saizan> http://hackage.haskell.org/trac/summer-of-code/wiki/Soc2009 <- this is last year wiki
22:23:05 <DV> but as the official list and all is not out yet
22:23:33 <Zeiris_> A Haskell cult would have significant overlap with Lovecraftian ones. Would probably be simpler just to join one of them.
22:25:35 <Cale> Some of the submitted project ideas are pretty hilarious :)
22:25:39 <Cale> http://hackage.haskell.org/trac/summer-of-code/ticket/1575
22:26:37 <Gracenotes> oh dear, see attachment
22:26:46 <Cale> yeah, I noticed that :)
22:29:45 <Cale> http://www.reddit.com/r/haskell_proposals
22:32:59 <ezyang> I have a blog post outline for a post entitled "It's about the functions, stupid!" I can't decide if writing this blog post is a good idea or not.
22:40:08 <Jonno_FTW> how can I get the string that follows the second ' ' in a string?
22:40:38 <Jonno_FTW> so that "some sample test" -> "test"
22:40:42 <Cale> Jonno_FTW: Is words good enough?
22:40:48 <Jonno_FTW> yes
22:40:49 <Cale> > words "some sample test"
22:40:50 <Jonno_FTW> thanks
22:40:50 <lambdabot>   ["some","sample","test"]
22:40:55 <Jonno_FTW> last
22:41:03 <Cale> Or !! 2
22:41:12 <Cale> > words "some sample test" !! 2
22:41:13 <lambdabot>   "test"
22:41:16 <Gracenotes> though a b c d -> c, not c d
22:41:30 <Cale> Right.
22:41:49 <Jonno_FTW> yep
22:42:05 <Cale> and it compresses multiple spaces
22:42:22 <Cale> > words "   some     sample      test   here   " !! 2
22:42:23 <lambdabot>   "test"
22:45:43 <Cale> > let f = drop 1 . dropWhile (/= ' ') in f . f $ "some sample text for this"
22:45:44 <lambdabot>   "text for this"
22:46:45 <Cale> > let f = drop 1 . dropWhile (/= ' ') in takeWhile (not . null) . iterate f $ "some sample text for this"
22:46:46 <lambdabot>   ["some sample text for this","sample text for this","text for this","for th...
22:49:50 <manjunaths> hello
22:50:01 <manjunaths> can I execute shell commands in ghci ?
22:50:04 <manjunaths> like ls ?
22:51:41 <tensorpudding> no
22:51:44 <ezyang> manjunaths: You can shell out using Haskell functions...
22:52:02 <ezyang> you can also do :!
22:52:28 <manjunaths> can I use ghci as my primary shell ?
22:52:37 <manjunaths> instead of bash, it is so cool
22:53:39 <ezyang> I... wouldn't recommend it.
22:53:46 <manjunaths> ezyang, I know
22:55:15 <manjunaths> every day I have to write shell scripts I think this would've been so easy in haskell
22:55:31 <ezyang> It sounds like you have very computation heavy shell scripts
22:56:17 <manjunaths> ezyang, probably
22:56:33 <manjunaths> didn't microsoft write a shell named monad ?
22:56:40 <manjunaths> was it based on haskell ?
22:57:27 <p_l> manjunaths: yes and no - the shell was called Monad SHell, now it's known as PowerShell, and it's written in C# iirc
22:57:44 <manjunaths> p_l, ah
22:59:30 <manjunaths> is the bash | operator like the haskell . operator ?
22:59:48 <manjunaths> only in reverse ?
23:00:10 <tensorpudding> you can kinda think of it that way
23:00:33 <tensorpudding> it does allow you to "pipeline" in the same sense
23:00:54 <copumpkin> in a shell, everything lives in the RW monad
23:01:00 <copumpkin> with a reader of stdin and a writer of stdout :P
23:02:34 <Gracenotes> but programs like ls and grep that are meant to be used in command line are, as-is, not a good fit for a type system approach without some creative bastardization
23:02:52 <manjunaths> Gracenotes, what if we wrote an ls ?
23:03:28 <manjunaths> a new ls which returned some sort of file types, which we can operate on
23:03:37 <manjunaths> hmm...
23:03:42 <Gracenotes> well, that's easy enough, structuring *everything* to not be an ad-hoc mess is different
23:04:09 <manjunaths> Gracenotes, hmm...
23:04:15 <manjunaths> Gracenotes, true
23:05:11 <tomberek> @djinn a -> a
23:05:11 <lambdabot> f a = a
23:05:19 <tomberek> fun
23:21:12 <Cale> http://picturesforsadchildren.com/ -- haha, awesome
23:21:44 <tomberek> hey, if I have a data Foo = Foo Int Double is it possible to declare this Foo to be an instance of Num in such a way that all the operations only affect the one of them (say.. the Double)?
23:22:52 <Cale> sure
23:23:01 <Cale> though, fromInteger will be a bit weird
23:23:31 <Cale> and you'll have to decide which of the two Int values to carry along when performing addition and multiplication
23:23:59 <tomberek> Cale:I basically just want the Int there as a pointer or counter, but the operations will be done on the Double.... is there a simple way to have it done for you via a derive or something
23:24:01 <Cale> and you'll fail to satisfy some of the usual expected laws, though Double already fails most of them
23:24:22 <Cale> Oh, no, you have to write the instance by hand.
23:24:28 <Cale> instance Num Foo where
23:24:36 <Cale>   (Foo n x) + (Foo m y) = ...
23:24:37 <tomberek> dang, ok
23:26:17 <savonarola> hello, i run the following program http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23073#a23073  in the way shown in the paste. while running, its memory consumption grows rather rapidly. how the code should be modified to make program run in constant memory?
23:28:05 <Cale> savonarola: The problem is that getCCnt doesn't ever need to calculate the cnt parameter, so it builds up a large expression like ((...((0 + 1) + 1)...)+1)+1
23:28:07 <tomberek> savonarola,, can you do that recursion outside of getCCnt?
23:28:27 <Zao> @src $!
23:28:27 <lambdabot> f $! x = x `seq` f x
23:29:14 <Cale> savonarola: One easy way to fix it is to use $! so as to force the computation of cnt + 1 when you're passing it to getCCnt c
23:29:31 <Cale> So that line would read  y <- getCCnt c $! (cnt + 1)
23:29:58 <tomberek> Cale: that would simply reduce that thunk to an actual value each time, right?
23:29:59 <mjrosenb> sadly, having getCCnt _ -1 = error "foobar" should also solve the problem
23:30:04 <Cale> tomberek: yes
23:30:28 <Cale> mjrosenb: Up to parentheses, yes :)
23:30:30 <Cale> Another way would be to add {-# LANGUAGE BangPatterns #-}
23:30:35 <Cale> and write
23:30:37 <mjrosenb> err, yes.
23:30:43 <Cale> getCCnt c !cnt = do ...
23:31:03 <mjrosenb> $! reduces to whnf, right?
23:31:03 <Cale> which will force the evaluation of cnt
23:31:06 <Cale> yeah
23:31:36 <Cale> f $! x evaluates to x `seq` f x which ensures that x is evaluated before the result of evaluating f x can be used.
23:31:40 <tomberek> mjrosenb's idea (if placed above the current declaration wouldn't force it the same way?  strict in the second parameter?
23:32:02 <Cale> If you're going to solve the problem by adding extra guards, you should use:
23:32:18 <Zao> Didn't oleg suggest a generic way to strictify things
23:32:21 <Cale> getCCnt c cnt | cnt `seq` False = error "won't happen"
23:32:39 <Cale> which is a standard trick
23:32:42 <tomberek> cool
23:32:43 <Zao> Something like f x y z | x `seq` y `seq` z `seq` False = undefined
23:33:06 <savonarola> with  y <- getCCnt c $! (cnt + 1)   memory cosumption grows less rapidly, but still grows
23:33:08 <Cale> I think oleg has mentioned it, but I was doing it for a long time before that, and other people as well, I'm sure :)
23:33:15 <Zao> Likely.
23:33:19 <Zao> That's where I saw it mentioned first.
23:33:39 <Cale> savonarola: How are you compiling the program?
23:33:50 <savonarola> ghc -o ghctest main.hs
23:33:57 <Cale> savonarola: Add -O2 to that
23:34:10 <mjrosenb> savonarola: try replacing y <- foo; return y with foo.
23:34:16 <Cale> Optimisations are extremely important if you care at all about performance.
23:34:45 <Cale> yeah, the if/then/else is equivalent to
23:34:51 <Cale> if x == c then return cnt
23:35:03 <Cale>           else getCCnt c $! (cnt + 1)
23:35:41 <savonarola> so, the wariable y consumes memory
23:35:48 <savonarola> *variable
23:35:51 <savonarola> ?
23:35:53 <Cale> It ought not to
23:36:00 <mjrosenb> however, the desugarer will change it to getCCnt c $!(cnt+1) >>= (\y -> return y)
23:36:03 <Cale> But try compiling with optimisations first
23:36:15 <Cale> There's a possibility that it uses some memory if you're not optimising things.
23:36:58 <Cale> I would really hope that the optimiser is smart enough to fix that problem in any case.
23:37:01 <mjrosenb> which has an extra call and i would imagine that this would make it non-tail recursive
23:37:34 <savonarola> oh -O2 is great! %)
23:37:39 <Cale> tail recursion doesn't really mean a whole lot in this context, but yeah, the remaining part of the expression which needs to be executed might build up
23:38:05 <savonarola> now the memory is constant
23:38:16 <Cale> Yeah, if you care at all about performance, you need at least -O
23:38:16 <tomberek> would it make sense to rebuild this as a fold?
23:38:30 <mjrosenb> savonarola: that is only because you are using Int, not Integer
23:38:44 <mjrosenb> savonarola: then it'll take up log(N) memory
23:39:00 <Cale> You could write this as   main = print . length . takeWhile (/= 'a') =<< getContents
23:39:05 <mjrosenb> Cale: in general, if i can do the same thing by adding -O2 and by modifying my code so it is just as readable, i'll modify the code.
23:40:01 <Cale> Yeah, this program properly requires logarithmic space, but that's not something which you'd usually worry too much about :)
23:40:02 <savonarola> i just tried to ensure myself that tail recursion is ok isine actions
23:40:09 <savonarola> *inside
23:40:10 <tomberek> Cale: how long did it take you to be able to quickly simplify a problem?
23:40:17 <Cale> tomberek: hm?
23:40:28 <Cale> tomberek: oh
23:40:35 <tomberek> I mean in terms of, how much time with Haskell until you were able to do that sort of thing?
23:40:46 <Cale> tomberek: I suppose it was about a year of programming in Haskell before I really felt "comfortable".
23:40:53 <tomberek> erg.. i got a while
23:41:04 <Cale> It was about 2 months before I felt like I could do useful stuff with it.
23:41:23 <Cale> I was studying mathematics at the time, so it wasn't like I spent 8 hours a day working on it though.
23:41:40 <tomberek> it's a hobby for me at the moment
23:42:04 <Cale> I also knew a lot of imperative languages that I had to unlearn :)
23:42:15 <tomberek> yep, that's my problem too
23:42:21 <Cale> It's so much easier for complete beginners than it was for me :)
23:42:30 <Cale> Also, the tutorials are really good these days
23:43:50 <Cale> (I first learned Haskell around 2002 or so)
23:44:04 <copumpkin> Cale: uphill both ways, eh? :P
23:44:15 <Cale> copumpkin: hehe
23:44:34 <tomberek> in the snow i'm sure
23:44:55 <copumpkin> after using a pickaxe to harvest the potatoes from the frozen field
23:45:53 <copumpkin> Cale finally lit his one candle of the day in the closet under the staircase and leafed through the three pages of SOE he had managed to scavenge
23:46:34 <tomberek> too bad the potatoes were to feed the starving mule and he only got boiled scrap leather to gnaw on
23:47:33 <tensorpudding> luxury!
23:48:55 <Cale> hehe
23:51:18 <tomberek> @djinn [a]->a
23:51:18 <lambdabot> Error: Undefined type []
23:56:01 <copumpkin> @djinn Maybe a -> a
23:56:02 <lambdabot> -- f cannot be realized.
23:56:05 <copumpkin> @djinn a -> Maybe a
23:56:05 <lambdabot> f = Just
23:56:14 <copumpkin> zomg, Maybe a and a are not isomorphic!!!
23:57:00 <Zao> It can't be!
23:59:15 <codolio> Sometimes they are.
23:59:44 <dolio> Of course, not as far as djinn is concerned.
