00:00:12 <kamatsu> pure languages should be lazy
00:00:56 <monochrom> Haskell defaults to pure therefore defaults to lazy.
00:00:56 <DigitalKiwi> you can make Haskell behave eagerly though can't you?
00:00:58 <kmc> i'm not sure what is meant by "pure language"
00:01:07 <kmc> we have mutable state, same as any language
00:01:11 <monochrom> my pure means immutable
00:01:20 <kmc> does "pure language" mean that evaluation and execution are distinct steps?
00:01:51 <kamatsu> DigitalKiwi: yes
00:02:04 <kmc> does it refer to this style of sort of denotational metaprogramming over an operational language of actions?
00:02:09 <kamatsu> DigitalKiwi: it's just somewhat ugly looking if you add strictness annotations anywhere
00:02:12 <pikhq> ... Mutable state? Haskell?
00:02:19 <pikhq> My IO a values are perfectly immutable.
00:02:21 <DigitalKiwi> I put my learning of Haskell on a bit of a hiatus to work on other projects+uni :(
00:02:27 <kmc> yeah of course
00:02:43 <kamatsu> DigitalKiwi: uni doesn't mean haskell for you? what a shame
00:02:45 <kmc> there are no mutable values in Haskell, the concept is nonsensical
00:02:49 <kmc> but there is mutable state
00:02:56 <DigitalKiwi> uni means fortran >.>
00:03:03 <kamatsu> DigitalKiwi: let me guess.. UA?
00:03:06 <kmc> in cells
00:03:06 <pikhq> Sorry. Variables.
00:03:29 <DigitalKiwi> University of Nebraska Lincoln -- Mechanical Engineering
00:03:33 <kamatsu> ah
00:03:40 <monochrom> My pure means immutable. Haskell gives you immutable and mutable options, just like most compilers give you lazy and eager options. Default is immutable and default is lazy, these two defaults go well together. Default immutable and default eager is a lost war.
00:03:44 <kamatsu> i had a friend that went to Uni of Alabama, and she had to learn fortran
00:03:46 <pikhq> kmc: Sure, sure. Evaluate the result of my perfectly pure program. Evil SOB. :P
00:03:58 <kmc> evaluating it should be fine...
00:04:09 <pikhq> Erm. Execute.
00:04:15 * Axman6 's pure means functions behave like mathematical functions... mappings from values to values
00:04:24 <kamatsu> referential transparency
00:04:30 <Axman6> that's the one
00:04:32 <kamatsu> that's my pure too
00:04:45 <kmc> lazy is not a design feature in most languages; it's just a consequence of having functions act as delayed evaluations
00:05:12 <kmc> if you have eager FP you get non-default laziness for free
00:05:40 <kmc> Axman6, but that's only because we have a separate concept for the things that don't behave that way
00:05:47 <kmc> they are still first-class members of the language
00:06:00 <kamatsu> kmc: the fact that they are seperated concepts makes the language pure
00:06:40 <kmc> i don't see how separating the concepts affects the efficiency of implementing certain algorithms, unless you restrict yourself to not using some of those concepts
00:06:45 <kamatsu> kmc: when a function may or may not be referentially transparent, the language can be considered impure imo.
00:06:52 <kmc> which i think is what is meant by "pure code"
00:08:04 <kmc> it is strange that "function" ends up representing at least three unrelated things in most languages
00:08:33 <monochrom> four if you include English.
00:09:41 <monochrom> I saw someone on Usenet whining about some API doc (favourite pastime of everyone, eh?). "I want it to tell me which functions to call, in which order, in plain English".
00:09:58 <monochrom> Dude, in plain English, functions are held and attended, not called.
00:10:17 <monochrom> So much for plain English.
00:10:17 <kamatsu> heh
00:10:53 <monochrom> It was OS/2 Presentation Manager API doc to be specific. I read it, used it, found it alright.
00:12:04 <dankna> that, and the function of the API doc is to be a reference
00:12:22 <dankna> if it told you what to call it would be a tutorial.  (also, telling you what to call is impossible if you aren't doing something the author anticipated)
00:16:08 <tomberek> monochrom: is there a particular templete-haskell to install for criterion and progression
00:16:27 <monochrom> I don't know.
00:16:39 <c_wraith> tomberek: don't install template-haskell.  it comes with ghc and can't be upgraded
00:17:06 <c_wraith> tomberek: find versions of packages that work with the template-haskell you have
00:17:12 <tomberek> c_wraith: well, i'm trying to cabal install criterion and progression,, but it's giving me errors
00:17:39 <c_wraith> tomberek: cabal's solver isn't very smart.  You might need to tell it previous version of some dependency
00:22:56 <tomberek> c_wraith: i'm not cabal-savy yet... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17095#a17095
00:24:12 <dmwit> Can I get cabal to just dump a list of build-depends?
00:24:25 <dmwit> (Rather than adding them one by one as the build fails?)
00:28:46 <dmwit> eh?
00:28:53 <dmwit> I can cabal configure and cabal build, but not cabal install?
00:30:59 <tomberek> dmwit, what do you want to install?
00:31:10 <dmwit> wyvern
00:31:15 <sinelaw> Cale, got my patch for lambdabot?
00:31:15 <dmwit> A program I've just finished writing.
00:31:38 <tomberek> don't know
00:31:50 <tomberek> anyone good at deciphering cabal errors?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17095#a17095
00:32:06 <dmwit> That's not a cabal error.
00:32:13 <dmwit> It's a build error in the template-haskell library.
00:32:25 <sinelaw> tomberek, compilation error
00:33:18 <tomberek> ok,, so what now?
00:33:50 <dmwit> Hands-off approach is to write to the template-haskell maintainer.  Hands-on approach is to download the source from hackage and take a look at the line in the error.
00:35:05 <tomberek> i thought template-haskell and criterion were fairly common pachages,,, i would have thought this is a known issue for which there is a simple fix.. .like a way to tell cabal to use a different version or something
00:35:30 <dmwit> If you just want to use a different version, you can do that.
00:35:44 <dmwit> cabal install template-haskell==2.4.0.0 # for example
00:39:25 <tomberek> dmwit: looks like that package won't compile... can I tell criterion with an older version of template-haskell?
00:39:53 <dmwit> Just install an older version of template-haskell first, then install criterion.
00:40:09 <tomberek> yeah, i already have an older version
00:40:13 <dmwit> How old?
00:40:21 <tomberek> 2.3.0.1
00:40:29 <tomberek> latest available is 2.4.0.0
00:40:41 <sinelaw> > take 3 [1,2]
00:40:43 <lambdabot>   [1,2]
00:40:45 <dmwit> Then that means criterion likely requires template-haskell >= 2.4 in its cabal configuration.
00:41:04 <dmwit> You may try editing that, but there's no guarantees that it will work.
00:42:43 <sinelaw> @hoogle [a] -> [a]
00:42:44 <lambdabot> Prelude cycle :: [a] -> [a]
00:42:44 <lambdabot> Prelude init :: [a] -> [a]
00:42:44 <lambdabot> Prelude reverse :: [a] -> [a]
00:42:53 <sinelaw> > init [1,2,3]
00:42:54 <lambdabot>   [1,2]
00:43:16 <dmwit> ?quote sprynge
00:43:17 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
00:43:29 <sinelaw> heh
00:43:33 <sinelaw> > last [1,2,3]
00:43:34 <lambdabot>   3
00:45:05 <int-e> > head . last . takeWhile (not . null) . iterate (reverse . tail) $ [1..3]
00:45:07 <lambdabot>   2
00:45:12 <int-e> @type head . last . takeWhile (not . null) . iterate (reverse . tail)
00:45:14 <lambdabot> forall a. [a] -> a
00:45:36 <sinelaw> can't read that
00:48:23 <int-e> > head . fst . last . takeWhile (not . null . snd) . iterate (drop 1 *** drop 2) . join (,) $ [1..3]
00:48:24 <lambdabot>   2
00:49:02 <sinelaw> what's the easiest way to randomly pick from a sequence?
00:49:09 <sinelaw> a list that is
00:49:50 <dmwit> ?hackage MonadRandom
00:49:51 <lambdabot> http://hackage.haskell.org/package/MonadRandom
00:49:58 <tomberek> dmwit: but I though template-haskell was in haskell platform... ie. fairly standard
00:50:29 <dmwit> Look man, I don't know why it isn't building for you, and I'm sorry and all... but I'm not sure what you want me to do about it.
00:50:59 <sinelaw> isn't there something like
00:51:03 <sinelaw> [a] -> a
00:51:04 <sinelaw> ?
00:51:10 <tomberek> well.. looking for info... can you compile it?
00:51:32 <Axman6> sinelaw: random and pure don't go too well together
00:51:55 <xerox> you want to pick again and again or just one time?
00:51:58 <sinelaw> ok then Int -> [a] -> a where the Int is the seed. shouldn't be a problem to do this purely
00:51:59 <dmwit> sinelaw: There's uniform :: MonadRandom m => [a] -> m a
00:52:14 <sinelaw> xerox, aha. :)
00:52:18 <sinelaw> ok
00:52:20 <xerox> ?
00:52:41 <sinelaw> xerox, that's why it's not possible to do it in a single function, because of multiple picks
00:53:04 <dmwit> tomberek: No, template-haskell 2.4.0.0 does not build here, either.
00:53:39 <tomberek> dmwit: ah, in that case... i'm not so concerned
00:55:31 <int-e> it builds with ghc 6.12.1, not with ghc 6.10.4.
00:55:55 <Axman6> sounds like progress!
00:56:01 <sinelaw> dmwit, where is that uniform
00:56:04 <sinelaw> @hoogle uniform
00:56:04 <lambdabot> No results found
00:56:09 <int-e> so the cabal file lacks an if impl(ghc >= 6.12) Buildable: False, or the code lacks some cpp magic. I don't know which)
00:56:15 <dmwit> ?hackage MonadRandom
00:56:16 <lambdabot> http://hackage.haskell.org/package/MonadRandom
00:56:18 <dmwit> oh
00:56:31 <dmwit> It doesn't seem to be there, actually, but it's pretty easy to write in terms of that list operation
00:57:12 <Axman6>  @hackage is basically @hackage str = "http://hackage.haskell.org/package/" ++ str
00:57:12 <int-e> uniform = fromList . map (flip (,) 1)
00:57:29 <dmwit> uniform xs = fromList [(x, p) | x <- xs] where p = 1 / genericLength xs
00:57:37 <dmwit> even better
00:57:40 <dmwit> int-e++
00:58:00 <int-e> (the sum of weights does not have to equal 1)
00:58:01 <dmwit> fromList . flip zip (repeat 1)
00:58:06 <int-e> oh.
00:58:13 <int-e> better still :)
00:58:24 * dmwit likes reading flip zi4p
00:58:39 <sinelaw> @hoogle genericLength
00:58:39 <lambdabot> Data.List genericLength :: Num i => [b] -> i
00:58:46 <sinelaw> @hoogle length
00:58:46 <lambdabot> Prelude length :: [a] -> Int
00:58:46 <lambdabot> Data.ByteString length :: ByteString -> Int
00:58:46 <lambdabot> Data.List length :: [a] -> Int
01:00:07 <c_wraith> tomberek: I told you, you can't upgrade template-haskell because it comes with GHC.  You *can't* upgrade it.
01:00:39 <c_wraith> tomberek: Now that I'm paying attention again, tell me what version of ghc you're using, what template-haskell you have, and what's not installing
01:00:59 <tomberek> c_wraith : ok.. i have 2.3.0.1 of template haskell
01:01:29 <tomberek> ghc 6.10.4
01:01:41 <DekuNut> Prepare for ungodly horrible code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17096#a17096
01:01:53 <DekuNut> I knew as soon as I wrote emptyBoard that I was doing something wrong, but continued anyway
01:02:09 <DekuNut> Where exactly am I going wrong, why does my code seem so bloated to me?
01:02:29 <int-e> DekuNut: what is the error?
01:03:13 <DekuNut> Sorry, no error
01:03:28 <DekuNut> Just ugly, feels like I'm taking the longest route to achieve what I want
01:03:41 <DekuNut> But I have no idea how to make it better
01:03:57 <int-e> ah. trice x = Triple x x x; empty = trice (trice None)
01:03:58 <dmwit> The more you use types to restrict the possible values, the more annoying using those types is.
01:04:03 <tomberek> c_wraith: so ghc 6.10.4, template-haskell 2.3.0.1 trying to install criterion or progression...... (btw: how do you normally resolve these dependency issues.... teach a man to fish and all that)
01:04:10 <dmwit> s/trice/thrice/g
01:04:38 <c_wraith> tomberek: sadly, just look at package dependencies on hackage, and figure out what's blowing up.  criterion doesn't have a direct dependency issue
01:04:38 <int-e> and a  toList  function would help with printBoard
01:04:45 <int-e> dmwit: thanks
01:05:16 <c_wraith> tomberek: neither does progression
01:05:32 <tomberek> c_wraith: yeah, i saw that,, it's through containers
01:05:36 <DekuNut> Oh I see
01:05:37 <Axman6> > fmap (const 1) $! Just undefined
01:05:37 <lambdabot>   Just 1
01:05:49 <DekuNut> The board is unnecessary, I'll try and write something using that and come back if it's still bad :o
01:05:50 <c_wraith> tomberek: good start, then.  Look at the dependencies for containers
01:05:50 <DekuNut> Thanks
01:06:33 <c_wraith> tomberek: and if you look at containers-3.0.0, you see it depends on base >= 4.2.0
01:06:45 <c_wraith> tomberek: that's the version of base in 6.12, if my memory is at all accurate
01:06:46 <int-e> DekuNut: I'd probably use [[Naught]] or Array Int (Array Int Naught) (if you're familiar enough with Data.Array), because that gives easier access to individual elements.
01:06:51 <Phyx-> > 2 + 2 == 5
01:06:52 <lambdabot>   False
01:06:59 <Phyx-> i disagree!
01:07:10 <int-e> or Array (Int, Int) Naught.
01:07:26 <tomberek> arg!  that's it... i have base 4.1.0.0
01:07:28 <dmwit> > 3 == 3.000000000000000000000000000000000000000001 :: CReal
01:07:29 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
01:07:29 <lambdabot>         against infe...
01:07:35 <DekuNut> int-e, I'm not familiar with Array, but [[Naught]] I can see
01:07:37 <dmwit> > 3 == (3.000000000000000000000000000000000000000001 :: CReal)
01:07:38 <c_wraith> tomberek: so you should tell it to use an older version of containers.  try "cabal install containers-0.2.0.1"
01:07:38 <lambdabot>   True
01:07:55 <dmwit> > (3.000000000000000000000000000000000000000001 :: CReal) - 3
01:07:56 <lambdabot>   0.0
01:08:06 <c_wraith> tomberek: if that installs properly, try to install criterion again
01:08:18 <c_wraith> tomberek: if it doesn't, apply the same process to the dependencies of containers
01:08:23 <int-e> DekuNut: of course Triple (Triple Naught) has the advantage of enforcing the right shape and dimensions.
01:08:24 <tomberek> c_wraith: i have that version of containers already
01:08:30 <c_wraith> hmm
01:08:40 <c_wraith> try this, then:
01:08:58 <c_wraith> cabal install criterion --with-contraint='containers == 0.2.0.1'
01:09:08 <DekuNut> int-e well, is there a BIG problem with that?
01:10:11 <DekuNut> Er, sorry, a big problem with not enforcing the right shape, such as with [[Naught]]
01:10:14 <tomberek> c_wraith:there a typo in there?
01:10:21 <c_wraith> errr, yes
01:10:24 <c_wraith> constraint
01:10:28 <c_wraith> with the s
01:10:52 <tomberek> c_wraith: even with the s?
01:11:27 <int-e> DekuNut: no. it's slightly unwieldy. but you can fix that by implementing some more utility functions. "get element at position n of triple" (t ! n) if you follow Data.Array and "change element n of triple to x" (Data.Array has t \\ [(n, x)] ... but you can come up with your own name)
01:11:46 <sinelaw> @let uniformPick = evalRand . fromList . flip zip (repeat 1)
01:11:47 <c_wraith> tomberek: oh, it's just --constraint, not --with-constraint
01:11:47 <lambdabot>  Defined.
01:11:54 <sinelaw> > uniformPick [1,2,3]
01:11:55 <lambdabot>   Ambiguous type variable `g' in the constraints:
01:11:55 <lambdabot>    `System.Random.RandomGen...
01:12:10 <DekuNut> int-e, I'll check out Data.Array in the future, for now I'll see what I can do with my own functions - to get used to types and such
01:12:10 <tomberek> c_wraith:: there we go.. let's see what happens
01:12:14 <int-e> DekuNut: there's no big problem with not enforcing the right shape either - it's one more property that you have to keep in mind while programming and debugging, rather than letting the compiler check it for you.
01:12:15 <DekuNut> int-e, thank you
01:12:15 <sinelaw> > uniformPick [1,2,3] :: Int
01:12:16 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
01:12:16 <lambdabot>         against inferred type ...
01:12:23 <sinelaw> > uniformPick [1,2,3 :: Int]
01:12:24 <lambdabot>   Ambiguous type variable `g' in the constraints:
01:12:24 <lambdabot>    `GHC.Show.Show g'
01:12:24 <lambdabot>      a...
01:12:27 <sinelaw> argh.
01:12:31 <DekuNut> int-e, ah ok, appreciate it
01:12:43 <sinelaw> > evalRand . fromList . flip zip (repeat 1) [1,2,3]
01:12:44 <lambdabot>   Couldn't match expected type `[(a, GHC.Real.Rational)]'
01:12:44 <lambdabot>         against inf...
01:12:47 <sinelaw> > evalRand . fromList . flip zip (repeat 1) $ [1,2,3]
01:12:49 <lambdabot>   Ambiguous type variable `g' in the constraints:
01:12:49 <lambdabot>    `System.Random.RandomGen...
01:12:58 <sinelaw> sorry, pm lambdabot
01:13:04 <dmwit> :t evalRand
01:13:05 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
01:13:34 <dmwit> :t (evalRand :: Rand StdGen Int) . fromList . flip zip (repeat 1) $ [1,2,3]
01:13:36 <lambdabot>     Couldn't match expected type `Rand StdGen Int'
01:13:36 <lambdabot>            against inferred type `Rand g a -> g -> a'
01:13:36 <lambdabot>     In the first argument of `(.)', namely
01:13:38 <sinelaw> oh oops.
01:13:49 <tomberek> c_wraith: it didn't work, i'm trying with --constraint='template-haskell==2.3.0.1'
01:13:57 <dmwit> :t \g -> (evalRand :: Rand StdGen Int) g . fromList . flip zip (repeat 1) $ [1,2,3]
01:13:58 <lambdabot>     Couldn't match expected type `Rand StdGen Int'
01:13:58 <lambdabot>            against inferred type `Rand g a -> g -> a'
01:13:58 <lambdabot>     In the first argument of `(.)', namely
01:14:14 <tomberek> c_wraith: looks like it worked!
01:14:19 <dmwit> :t \g -> evalRand (g :: StdGen) . fromList . flip zip (repeat 1) $ [1,2,3]
01:14:20 <lambdabot>     Couldn't match expected type `Rand a a1'
01:14:20 <lambdabot>            against inferred type `StdGen'
01:14:20 <lambdabot>     In the first argument of `evalRand', namely `(g :: StdGen)'
01:14:26 <dmwit> argh
01:14:28 <tomberek> c_wraith: thanks for helping me out.. .now I kinda see the procedure for solving this on my own next time... thanks  (i hope it works ok....hehe)
01:14:39 <dmwit> I'm too tired, I will stop... but one more.
01:14:40 <sinelaw> @type fromList
01:14:41 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
01:14:44 <sinelaw> that's why
01:14:51 <c_wraith> tomberek: there you go.  Getting around this problem (cabal's solver being weak) is just iteration of those steps.  Good luck with it when you encounter it agian
01:14:55 <c_wraith> *again
01:15:04 <sinelaw> i need the generator
01:15:13 <tomberek> c_wraith: dependency hell is getting bad
01:15:16 <sinelaw> @type mkStdGen
01:15:17 <lambdabot> Int -> StdGen
01:16:57 <c_wraith> there are two interlocking issues with cabal.  one, the solver will fail sometimes even when there are solutions, because it's greedy.  Two, it doesn't know that some packages can't be upgraded, so it doesn't even know ahead of time that a particular solution won't work.
01:17:38 <shapr> c_wraith: How to fix the solver?
01:17:39 <tomberek> c_wraith: one would have thought that a good dependency solution would have been found by now, I spend more time trying to install libraries than working on code  (i'm not just talking about cabal,, gtk, linux, and computing in general)
01:18:25 <c_wraith> shapr: all I know is that if someone wrote a patch, dcoutts would probably consider integrating it.  But I don't know the details about how it works.
01:23:12 <ksf> what's newest on the front of monad transformer libs?
01:23:34 <sinelaw> losing my mind here, any tips on how to use MonadRandom?
01:23:39 <c_wraith> are there more incompatible ones yet?
01:23:55 <sinelaw> once i have this:
01:24:03 <sinelaw> @type fromList . flip zip (repeat 1) $ [1,2,3]
01:24:04 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Num a) => m a
01:24:06 <Zao> monad-nasa, which uses the spacesuit model
01:24:09 <sinelaw> what do i do next?
01:24:40 <sinelaw> i want to use mkStdGen to extract a random value from that monad
01:24:41 <Axman6> provide a seed, and 'run' the monad i'd guess
01:24:48 <c_wraith> sinelaw: you need a specific m for it.  IO is the most commonly used MonadRandom instance, but it's not the only one
01:25:09 <ksf> hey cool http://hackage.haskell.org/package/control-monad-exception-0.8.0.3
01:25:20 <sinelaw> c_wraith, i don't want IO
01:25:24 <Axman6> there should be some functions f :: MonadRandom m => m a -> StdGen -> a or somesuch
01:25:27 <c_wraith> sinelaw: the MonadRandom library probably has some state wrapping you could use, then
01:26:47 <c_wraith> sinelaw: but in that case, you need a seed from somewhere.  Either from a constant, or passed in from something in IO
01:26:47 <sinelaw> c_wraith, i can see that but don't know how to use it. i've little experience with moands
01:27:04 <sinelaw> c_wraith, i want a constant seed and mkStdGen
01:27:20 <c_wraith> :t mkStdGen
01:27:21 <lambdabot> Int -> StdGen
01:27:28 <c_wraith> Well, then, this should be easy. :)
01:27:58 <sinelaw> c_wraith, it should, but i have no idea how to combine that with the monad from above to get what i want
01:28:10 <c_wraith> let me take a look at the package
01:28:13 <sinelaw> thanks
01:28:22 <sinelaw> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
01:28:26 <sinelaw> if you haven't already
01:31:16 <c_wraith> sinelaw: looks like you want the runRand function from Control.Monad.Random
01:31:47 <c_wraith> sinelaw: its first argument will be the expression you created above, the second argument will be a StdGen
01:32:08 <sinelaw> > runRand (fromList . flip zip (repeat 1) $ [1,2,3])  (mkStdGen 123)
01:32:09 <lambdabot>   (1,970416508 1655838864)
01:32:20 <sinelaw> c_wraith, thanks a lot!
01:32:25 <c_wraith> sinelaw: That takes advantage of the Rand instance for MonadRandom, which is clearly the simplest implementation of MonadRandom
01:32:30 <sinelaw> now i get it
01:32:35 <sinelaw> yeah
01:32:43 <sinelaw> > runRand (fromList . flip zip (repeat 1) $ [1,2,3])  (mkStdGen 123)
01:32:44 <lambdabot>   (1,970416508 1655838864)
01:32:45 <sinelaw> > runRand (fromList . flip zip (repeat 1) $ [1,2,3])  (mkStdGen 124)
01:32:47 <lambdabot>   (1,424053141 1655838864)
01:33:02 <sinelaw> i'll need to re-use the returned gen
01:33:15 <c_wraith> yes.  But...  consider this
01:33:28 <sinelaw> there's sequence
01:33:29 <c_wraith> MonadRandom exists to enable transparent re-use of the returned gen
01:33:29 <Axman6> there should be a way to do that, that's the point of monad random :)\
01:33:48 <c_wraith> Consider working your whole algorithm in some MonadRandom, and only leaving it at the end
01:33:55 * Cyneox re
01:34:07 <sinelaw> c_wraith, yeah ok
01:34:45 <c_wraith> err, not re-use.  threaded use of the thread of returned gen objects. But you know what I meant. :)
01:34:52 <Axman6> this looks useful...and relevent:
01:34:53 <Axman6>   untilM :: Monad m => (a -> Bool) -> m a -> m a
01:34:53 <Axman6>   untilM p m =
01:34:53 <Axman6>      do x <- m
01:34:55 <Axman6>         if p x then return x else untilM p m
01:35:17 <sinelaw> or maybe forM
01:35:20 <sinelaw> @type forM
01:35:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
01:35:25 <sinelaw> @type forM_
01:35:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
01:35:38 <c_wraith> @src forM
01:35:38 <lambdabot> forM = flip mapM
01:36:05 <sinelaw> @type sequence
01:36:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:36:24 <sinelaw> anyway, i'm getting how to work with this
01:36:33 <sinelaw> @type replicate
01:36:34 <lambdabot> forall a. Int -> a -> [a]
01:36:53 <c_wraith> sinelaw: then, in a sneaky way...  You're starting to understand monads.  Without even thinking about it. :)
01:37:18 <sinelaw> c_wraith, nah, i am thinking about it :) i think I understand how monads work in theory pretty well, just never used them
01:37:43 <sinelaw> or not so well, but a little bit :)
01:38:52 <c_wraith> I finally *really* grasped monads when I started reading about parsec, read the first couple bits, then pounded out a big bit of parsec code without thinking about what I was doing.  Then I realized...  I only knew how to use the library because it was monadic, and therefore used the same patterns I knew from IO and the like.
01:39:40 <fasta> c_wraith, have you seen the reversed state monad already?
01:40:21 <c_wraith> fasta: I've seen that one.  I'm vaguely aware of what it does and how it does it...  But I find it baffling nonetheless. :)
01:40:38 <Phyx-> I think the most stressful part about functional programming is waiting to see whether the compiler will compile the code or not. lol
01:40:57 <fasta> Phyx-, if you are waiting, you are doing something wrong, or hugely complex.
01:41:16 <qebab> Phyx-: I actually find myself missing shotgun debugging at times. :(
01:41:26 <Ke> that's not functional programming, just haskell
01:41:32 <fasta> Shotgun debugging?
01:41:54 <Ke> I bet lisp will compile any string you give it
01:42:09 <qebab> fasta: Basically inserting prints into code to check where things go wrong, very crude form of debugging
01:42:12 <c_wraith> fasta: or just using template haskell.  It really hugely increases compile time
01:42:15 <qebab> hence the name
01:42:32 <ehamberg> qebab: trace from Debug.Trace? :)
01:42:52 <fasta> qebab, you miss that? Uhm, in Haskell there is no working debugger.
01:43:27 <xerox> really? in my ghci :help shows a lot of commands for debugging
01:43:31 <fasta> c_wraith, TH can be slow, yes.
01:43:51 <c_wraith> anyway, sleep time.  I think I'm healthy enough to make work tomorrow.
01:43:56 <fasta> xerox, yes, and yet it is so easy to make it fail.
01:44:00 <c_wraith> so I should actually sleep first
01:44:03 <qebab> ehamberg: but it's just so much faster to just shoot prints all over the program yo!
01:44:29 <qebab> ehamberg: I know I can do what I need to, it's just that I sometimes miss the dumb way of doing it
01:45:06 <fasta> xerox, anyway, in practice I don't find it useful, which is all that matters and I am probably one of about 10 users who worked with it the most.
01:45:21 <ziman> in haskell programs, there's usually almost nowhere to insert prints :)
01:45:46 <solrize> slsslladlkflasf
01:45:47 <solrize> sorry
01:45:51 <kamatsu> ziman: Debug.Trace
01:45:52 <kamatsu> ?
01:45:53 <fasta> There are academic projects which have actually created working debuggers for subsets of GHC Haskell. Now, those would count as debuggers.
01:46:23 <Phyx-> fasta: well i'm making changes to a compiler, lol
01:47:04 <fasta> Phyx-, a program with a sane build system in Haskell can also be loaded into ghci.
01:47:12 <ziman> kamatsu, well, okay. but that's ugly :)
01:47:21 <fasta> That you cannot do that in GHC is, imho, a mistake.
01:47:38 <kamatsu> I very rarely need it, tbh
01:47:39 <Phyx-> fasta: most of these files aren't even haskell files before they're preprocessed
01:47:44 <fasta> Also, that you have to restart ghci for it to pick another library is silly.
01:47:52 <kamatsu> just run the function in ghci, if it doesn't work, it's easy usually to figure out
01:48:09 <ziman> so do i, i usually test isolated functions
01:48:15 <ziman> yeah, exactly
01:48:26 <fasta> Phyx-, you can use any preprocessor you want and still use ghci.
01:48:53 <fasta> It is just that it is not their way of working, which is fine.
01:49:08 <fasta> I think it is an inefficient use of time to wait for compilations.
01:49:30 <Phyx-> fasta that's not true. a preprocessor that generates multiple files can't be used with ghc, because ghc only gives you a single output location to write too
01:50:11 <fasta> Phyx-, that's not true.
01:50:31 <fasta> Phyx-, there is no reason to output just one file on stdout and write the rest to other files.
01:51:06 <Phyx-> when i made a preprocessor to ghc, it supplied me on the commandline the file to read and the location and filename to write the preprocessed file to
01:51:08 <fasta> Phyx-, there is no fundamental reason for it not to work and really one should see that the problem is here with Haskell.
01:51:21 <fasta> Phyx-, the fact that you need preprocessing shows a weakness.
01:51:58 <fasta> It might be that TH solves all those problems in theory, but if the compiler devs don't use it in practice, then there still is a problem.
01:52:25 <Phyx-> How does needing a preprocessor show a weakness?
01:52:26 <fasta> Phyx-, yes, and that is perfectly consistent with what I stated.
01:52:50 <fasta> Phyx-, apparently Haskell cannot express whatever semantics the preprocessor language can express.
01:53:26 <Phyx-> if the files you write are completely independent of eachother and not in the original dependency graph, ghc would never find them afaik
01:53:56 <fasta> Phyx-, that is a weakness in ghc.
01:54:18 <fasta> Phyx-, nothing which cannot be resolved by adding fs level notifications.
01:54:52 <fasta> Anyway, GHC is not a polished system. That said, there aren't a lot of polished systems.
01:55:37 <fasta> The fact that RTS-inefficiencies (I am not talking about constants) are still being removed shows enough for me.
01:55:41 <Phyx-> fasta: but you're assuming also that the files produces will all be used to compile 1 program. but they might be used to compile two different programs. but the files to do so where compiled from one big blob so to speak, with small differences in a few places
01:56:06 <solrize> Configuring haskell-src-exts-1.1.4...
01:56:07 <solrize> setup: happy version >=1.17 is required but it could not be found.
01:56:19 <Saizan_> solrize: cabal install happy
01:56:30 <solrize> thanks
01:56:37 <qebab> never thought I'd say this
01:56:42 <qebab> but this coffee is way too strong
01:56:42 <solrize> it should be added as a dependency?  i got that msg trying to install hlint
01:56:46 <merehap> if that doesn't work, you might try sadness instead
01:57:15 <Saizan_> solrize: it's a build-tool dependency, there's a ticket open to make cabal-install fetch the build-tools too
01:57:19 <fasta> Phyx-, anyway, I am not interested in the details of that particular subject. All I know is that there is no fundamental need for a preprocessor in e.g. Forth, so there also shouldn't be one necessary for Haskell.
01:57:24 <solrize> oh ok thx
02:09:11 <solrize> using lots of type synonyms is an antipattern ?
02:14:01 <fasta> solrize, the thing is, every time you use a type synonym and someone uses  your library, they see a type they don't know and they have to look it up.
02:14:14 <fasta> solrize, so, you are just delaying the process of writing the software.
02:14:56 <ksf> ...either use newtypes, as they actually add value, or use type syns to drastically shorten overlong types
02:15:17 <ksf> type String = [Char] is of questionable value.
02:15:57 <fasta> solrize, I don't think I have a single use of a type synonym is a fairly large code base.
02:16:22 <fasta> solrize, I do use some of them, but they come from libraries.
02:16:27 <ksf> type MyMonad = FooT ...
02:16:49 <fasta> (Where they are a specialized types)
02:16:55 <ksf> although a newtype won't hurt there
02:17:06 <fasta> er are specialized types*
02:17:21 <fasta> I do use newtypes and data types a lot.
02:17:24 <solrize> oh, you mean type synonyms exported from libraries
02:17:28 <fasta> solrize, yes
02:17:34 <solrize> hmm
02:17:53 <solrize> i tend to use newtype and then get tired of using constructors and deconstructors all over
02:17:55 <fasta> solrize, sometimes general structures make sense as specific structures.
02:17:59 <ksf> in general, don't write a synonym unless you get seriously sick of typing out a type over and over again
02:18:00 <solrize> and then convert the newtypes to types
02:18:04 <solrize> hmm
02:18:09 <solrize> i just thought they made the code clearer
02:18:35 <solrize> like breaking an expression into several subexpressions
02:19:24 <fasta> Types are useful to tag certain values during a computation with an invariant.
02:19:51 <fasta> It doesn't have to be encoded in the type, but just so that you can make certain assumptions conceptually.
02:20:09 <fasta> Synonyms don't really do anything.
02:21:08 <solrize> like here's an example, i wrote a function that looks at a string, that takes a boolean flag saying whether the string is allowed to start with a digit instead of a letter
02:21:18 <fasta> Ah, actually I do use it in one place, I think.
02:21:21 <solrize> so i used "type DigitOK = Bool"
02:21:46 <fasta> It's useful there because I use it to be able to switch types everywhere at one go at some later point in time.
02:21:56 <solrize> yeah that too
02:22:03 <fasta> It saves me passing an extra parameter in every type.
02:22:10 <solrize> :t Control.Monad.Reader
02:22:11 <lambdabot>     Not in scope: data constructor `Control.Monad.Reader'
02:22:13 <fasta> But I see that as a language weakness.
02:22:22 <solrize> i guess you could use newtype
02:22:34 <ksf> solrize, name the parameter "digitOk"
02:22:41 <ksf> ...and haddock it
02:23:23 <ksf> otherwise, people might be tempted to try and pass one of data DigitOk = OkDigit | NonOkDigit
02:23:24 <solrize> well the parameter is already called that, but it looked more clear in the type signature to say what its purpose was
02:23:32 <solrize> hmm
02:23:36 <solrize> ok
02:23:44 <ksf> haddock helps, there
02:24:00 <ksf> -> Bool --
02:24:06 <ksf> oops
02:24:12 <solrize> well i mean for looking at the immediate code
02:24:12 <ksf> -> Bool -- | whether the digit is Ok
02:24:27 <solrize> ok i've been wanting to figure out haddock syntax anyway
02:25:24 <solrize> and i do stuff with digits so i have type Digit = Char
02:25:38 <solrize> and dictionary words, type DictWord = String
02:25:46 <solrize> i had used a newtype for that before but it got too cumbersome
02:26:08 <solrize> it did help with debugging so switching it was like taking assert statements out of the code
02:26:16 <ksf> but without a newtype you don't get any guarantee that one of your Digits isn't "M"
02:26:23 <ksf> ...which is, after all, a reasonable digit.
02:26:37 <ksf> or "a", for that matter
02:26:43 <solrize> i'd need a newtype in a separate module with a special constructor
02:27:06 <ksf> yep, but that might just be overkill
02:27:27 <fasta> I wish Hackage had an ignore GPL package option.
02:27:27 <solrize> http://www.digitalmars.com/d/2.0/lisp-java-d.html  it's for this problem
02:27:27 <ksf> typing isn't the only way to increase the hoare-factor of code
02:27:38 <solrize> hoare-factor ?
02:28:42 <ksf> theres two types of programs: those that contain no obvious bugs, and those that obviously don't contain bugs
02:28:52 <solrize> ic
02:29:07 <Phyx-> hahaahha i love the moment after you spend 1-2 hours finding a bug and in the end you realize it was a fairly stupid bug :P
02:29:30 <solrize> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17100#a17100
02:29:43 <solrize> there's what i have so far, i want to clean it up and put it on the wiki
02:29:56 <fasta> I wish I had saved my terrible bugs to scare potential employees away ;)
02:31:07 <moshi2000> hello i have problems exporting a datatype in a module
02:31:15 <Daerim> anyone know why hoogle doesn't search the System.Process library?
02:31:17 <moshi2000> data Transition a = Epsilon | Label a
02:31:31 <moshi2000> it says it can't find the constructors Epsilon and Label
02:31:32 <solrize> do lines 33 and 62 look smelly ?
02:31:45 <Saizan_> moshi2000: how did you export/import it?
02:31:57 <moshi2000> export (Transition, etc etc) where
02:32:00 <eevar2> Lisp vs. Java? -- with clojure you can have both :p
02:32:03 <Saizan_> ksf: "don't obviously contain bugs"
02:32:25 <Saizan_> moshi2000: you've to use Transitions(..) if you want to export the constructors
02:32:41 <solrize> eevar2, that was a problem that somebody gave to a bunch of lisp and java programmers to see how fast they could solve it and how much code it took... the lisp programmers beat the pants off the java programmers.
02:33:07 <solrize> i spent a long time on it but that's b/c i'm not very fluent in haskell
02:33:18 <moshi2000> Saizan_ haha ok weird syntax, but works! thanks
02:33:25 <Phyx-> fasta why? lol
02:33:29 <solrize> i think the code i wrote is not too bad though, except for a couple weird places
02:33:32 <Saizan_> solrize: a bit, and Writer [Accu] is smelly too
02:33:45 <ksf> "There are two ways to write code: write code so simple there are obviously no bugs in it, or write code so complex that there are no obvious bugs in it. "
02:33:58 <Saizan_> moshi2000: it's a short-cut for Transition(Epsilon,Label)
02:33:59 <ksf> the wording, as it seems, isn't a matter of agreement.
02:34:04 <solrize> Saizan, you mean b/c of the type synonym?  or because of using writer
02:34:05 <solrize> ?
02:34:12 <solrize> i tried to do it with direct recursion and got mired up
02:34:58 <fasta> solrize, the average Lisp developer is smarter than the average Java developer.
02:35:01 <Saizan_> ksf: what you wrote initially was interpreted with a different meaning by the english interpreter in my brain :)
02:35:42 <Phyx-> kst: lol
02:35:47 <Saizan_> solrize: the use of [a] with Writer can end up with quadratic complexity
02:35:50 <Phyx-> ksf: where'd you get that from?
02:35:53 <fasta> And these small programming questions are meaningless.
02:36:05 <Saizan_> solrize: Endo [a] is better
02:36:11 <solrize> Endo ?
02:36:15 <fasta> The question is whether your language can handle solving complicated problems.
02:36:29 <Saizan_> newtype Endo a = Endo (a -> a)
02:37:10 <Saizan_> or maybe Seq a
02:37:13 <solrize> then use something like State to push stuff onto the front?
02:37:33 <solrize> i guess that would be linear
02:37:43 <Saizan_> i thought you wanted to append
02:37:58 <solrize> well yeah but i can use reverse at the end
02:38:03 <fasta> solrize, you can also just use Data.Seq and forget about the issue.
02:38:08 <Saizan_> i mean that i'd use "Writer (Endo [a])"
02:38:15 <ksf> Phyx-, a random site of the internet.
02:38:17 <Saizan_> or, yeah, Seq
02:38:19 <ksf> google, to be precise
02:38:23 <fasta> solrize, then, once everything runs, you can optimize.
02:38:30 <Saizan_> Writer (Seq a)
02:38:36 <solrize> Data.Sequence ?  i don't see Data.Seq in ghc lib
02:38:38 <Daerim> fasta, well considering that everyone and their dogs learn Java, but only the truly interested learn lisp it's not that surprising
02:38:38 <solrize> is it in hackage?
02:38:49 <solrize> the program already runs, so it's optimization time ;)
02:38:50 <Saizan_> solrize: the module is Data.Sequence
02:38:54 <solrize> oh ok
02:38:55 <solrize> sec
02:39:08 <fasta> solrize, yes, sorry about that, the type is Data.Sequence.Seq
02:39:08 <ksf> do we have explicit package imports by now or is it just a proposal?
02:39:25 <fasta> ksf, GHC has them, and the rest of the world doesn't.
02:39:37 <ksf> I don't care, how do I use them?
02:39:41 <solrize> i actually wondered if i could have used LogicT to do all the backtracking
02:39:46 <solrize> but i never understood what it did
02:39:51 <fasta> ksf, 6.12 probably has it in the documentation.
02:40:07 <Saizan_> 6.10 has them too
02:40:18 <fasta> Saizan_, ah, that's interesting.
02:40:28 <fasta> Saizan_, thanks
02:41:12 <Saizan_> solrize: LogicT is a superset of the [] monad
02:41:25 <ksf> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
02:42:10 <ksf> ...as i don't want to set up cabal just to use Control.Monad.Trans
02:42:35 <Saizan_> ghc-pkg hide
02:42:47 <solrize> Saizan_, yeah, i've looked at it a little
02:42:55 <ksf> ...and I don't care for other compilers right now, though I might want to use yhc at some time to compile to javascript
02:43:01 <ksf> Saizan_, that's impure
02:43:32 <solrize> ksf, because of the untyped core?
02:44:02 <ksf> no, because ghc-pkg hide is stateful
02:44:26 <ksf> ...you compile your source and aren't guaranteed to get the same results after using hide.
02:45:10 <Saizan_> using packages is stateful anyhow
02:52:49 <kamatsu> ksf: it seems like yhc is dead?
02:55:17 <solrize> hmm
02:55:28 <ksf> last time I checked, it compiled
02:55:49 <ksf> ...that is, ghc compiled it, and yhc compiled stuff
02:56:16 <kamatsu> uh, i can't even check it out to find out  anymore
02:56:21 <kamatsu> darcs.haskell.org down?
02:56:35 <kamatsu> but it seems basically discontinued and dead nowadays
02:56:41 <kamatsu> i don't know if anyone is still working on it
02:57:00 <ksf> gnnnnargh alloca and monad transformers...
02:57:14 <kamatsu> hm, that's odd
02:57:18 <kamatsu> is darcs.haskell.org down for otheres?
02:57:21 <kamatsu> *others?
02:57:32 <kamatsu> oh wait, it's not down, just yhc isn't there
02:57:37 <ksf> it's up
02:58:12 <kamatsu> oh
02:58:14 <kamatsu> they've moved it
02:58:17 <kamatsu> it's not http://darcs.haskell.org/yhc anymore
02:58:24 <kamatsu> http://darcs.haskell.org/york-compiler98/ sounds right
02:58:59 <ksf> ...then the wiki page isn't up to date
02:59:28 <solrize> bahhhh
03:00:05 <kamatsu> i'll check the darcs log once darcs finishes checking out (even on a partial commit, darcs is very slow)
03:00:09 <kamatsu> (sadface)
03:00:14 <moshi2000> i can't use some parsec code i just got... says Not in scope: Data constructor 'Prefix'
03:00:38 <kamatsu> *partial clone
03:00:54 <kamatsu> moshi2000: did you import the right parsec stuff?
03:01:06 <moshi2000> kamatsu: it works for my friend over here
03:01:13 <moshi2000> exactly the same code
03:01:15 <kamatsu> do you have parsec?
03:01:18 <Jonno_FTW> when I try to install things using cabal i keep getting the error: ExitFailure 1
03:01:18 <moshi2000> yes i do
03:01:23 <kamatsu> how are you compiling it?
03:01:42 <moshi2000> i just run it exactly like he does, in ghci
03:02:52 <moshi2000> kamatsu: should be in Text.ParserCombinators.Parsec.Expr, which is imported
03:03:07 <kamatsu> that's strange
03:03:31 <kamatsu> 1178/2118 patches... hurry up darcs :(
03:04:02 <Jonno_FTW> is there any reason i should get an exitfailure?
03:04:09 <fasta> Does anyone know the rationale behind the argument order or atan2 in C and basically all other languages that have it?
03:04:39 <Zao> atan2(y,x) == atan(y/x); but safe?
03:04:46 <fasta> Jonno_FTW, if you already did cabal update, it means the authors made a mistake, unless there are C libraries, which you don't have.
03:05:04 <Jonno_FTW> hmm
03:05:23 <xerox> Zao more or less, it also gives back the right angle, not just one between -pi/2 and pi/2
03:05:36 <Zao> Feels like a rational rationale.
03:05:40 <Jonno_FTW> what do i do about these missing libraries?
03:06:12 <Zao> Jonno_FTW: What did you try to install, and the install process should have spammed why it failed.
03:06:17 <fasta> Jonno_FTW, the wise thing is to either email the authors for a fix or to fork.
03:06:27 <Zao> Surely the only output wasn't "ExitFailure 1"
03:06:36 <Jonno_FTW> it was
03:06:53 <fasta> I am pretty sure it wasn't.
03:07:07 <fasta> Jonno_FTW, what was the command you used?
03:07:09 <Zao> Jonno_FTW: I'm calling bull, but give it a few -v flags.
03:07:20 <Jonno_FTW> cabal install happstack
03:07:49 <Jonno_FTW> o
03:07:52 <Jonno_FTW> i'm on windows
03:08:03 <Saizan_> you should still get a lot of output
03:08:32 <Saizan_> even if it doesn't look like errors to you
03:08:44 <Jonno_FTW> http://pastebin.ws/bmzikl
03:08:49 <fasta> Jonno_FTW, you can install Gentoo/Interix and try to compile it ;)
03:08:58 <Jonno_FTW> .....
03:09:26 <fasta> Why would you want to use Windows for a server application?
03:09:31 <Jonno_FTW> testing
03:09:53 <fasta> It's an uphill battle. The Windows development ecosystem is simply not developed.
03:10:04 <Saizan_> ok, so installing directory-1.0.0.3 is what failed
03:10:11 <Jonno_FTW> yes
03:10:24 <fasta> HJScript-0.4.7 depends on haskell-src-exts-1.0.1 which failed to install.
03:10:30 <fasta> That's what I get when I try it.
03:10:35 <Zao> fasta: Why wouldn't you want to develop on your native platform?
03:10:53 <Zao> For some reason, my install is partially broken.
03:10:59 <Saizan_> Jonno_FTW: what version of ghc do you have?
03:11:02 <Zao> It tries to install directory-1.0.1.0, which I already have.
03:11:05 <Jonno_FTW> 6.10.4
03:11:09 <fasta> Zao, because it is 10 times slower than the real thing.
03:11:12 <Zao> Which fails at finding HsDirectory.h, which exists.
03:11:20 <kamatsu> Oh sadness, that darcs repo i found for yhc is just the compiler and is not the full tree (no runtime, build files, etc.)
03:11:20 <Zao> fasta: Seriously...
03:11:31 <Zao> fasta: Who cares for DEVELOPMENT?
03:11:48 <Zao> Sure, for running a deployed application, run whatever works best.
03:11:58 <Zao> But for developing stuff, use what's familiar and "best" for you.
03:11:59 <Jonno_FTW> upon trying to update directory
03:12:12 <Zao> May it be g3nt00, OpenSolaris or AIX.
03:12:14 <fasta> Zao, yes, and I say that Cygwin does not work as good as a native Linux.
03:12:17 <Jonno_FTW> i get a heap of not in scopes in system.directory.hs
03:12:21 <Zao> fasta: Cygwin?
03:12:24 <fasta> Zao, so, you probably just misunderstood me.
03:12:28 <Zao> fasta: GHC hasn't used cygwin for ages.
03:12:28 <fasta> Zao, Windows.
03:12:42 <Zao> fasta: I find the Windows hostility in here and on freenode in general rather discouraging.
03:12:47 <Zao> Especially in a normally friendly channel.
03:13:00 <Zao> You make me want to punch things.
03:13:03 <fasta> Zao, no, but a lot of C libraries depend on some kind of POSIX environment.
03:13:21 <Zao> So set up a mingw+msys for those.
03:13:24 <osfameron> geeks are very often hostile to windows.  that said, I thought ghc for instance installed rather nicely on Windwos (SPJ being a Windows user aiui)
03:13:26 <Zao> Or use prebuilt ones.
03:13:33 <fasta> Zao, and for that you need either MSys or Cygwin. For commercial development only MSys is an option.
03:13:42 <fasta> Zao, yes, and I was saying that for development that is slow.
03:13:43 <osfameron> ghc was harder to install on a (not quite up to date) OSX tbh
03:13:47 <Zao> "slow"?
03:13:47 <fasta> Zao, that was all.
03:13:53 <Zao> Do you have proper metrics for that?
03:13:54 <Jonno_FTW> i have installed msys and cygwin
03:14:30 <Saizan_> Zao: slow in the sense that you've to install/configure a lot of things, i guess
03:14:32 <Jonno_FTW> i do have a debian installation on this lapto
03:14:44 <Jonno_FTW> all configured and setup
03:14:45 <fasta> Zao, hmm, never mind. The real problem is that I don't have thousands of tools installed on my MSys environment.
03:14:47 * osfameron shudders at the memory of cygwin
03:14:54 <fasta> Zao, Cygwin was what was slow.
03:15:07 <fasta> Zao, MSys was not, I guess.
03:15:40 <Zao> I believe the GHC building guide strongly recommends against cygwin.
03:15:52 <Saizan_> Jonno_FTW: however i think that installing a different directory is probably misguided
03:15:59 <fasta> Zao, I was not talking about building GHC.
03:16:10 <Zao> fasta: By extension, using GHC.
03:16:16 <Saizan_> Jonno_FTW: what does "ghc-pkg list directory" say?
03:16:51 <fasta> Zao, and I stopped using Cygwin anyway.
03:18:12 <Jonno_FTW> C:\Users\Jonno>ghc-pkg list directory
03:18:13 <Jonno_FTW> C:/Program Files (x86)/Haskell Platform/2009.2.0.2\package.conf:
03:18:15 <Jonno_FTW>     directory-1.0.0.3
03:20:28 <Saizan_> ok, so it's trying to rebuild it for some reason, like using a different dependency
03:21:00 <Saizan_> Jonno_FTW: can you paste "cabal install happstack --dry-run -v"? it should explain why cabal-install is making this choice
03:21:42 <Zao> Ah, found out why my directory failed to install.
03:21:53 <Zao> It depends on Win32, which I have a private modified version of.
03:22:15 <Zao> Or rather, why it thinks it needs to update :)
03:23:18 <guerrilla> is there a way to determine the inferred type of a function within a where clause with ghc or ghci?
03:23:22 <Jonno_FTW> http://pastebin.ws/bsuur4
03:23:23 <Saizan_> sometimes i think i shouldn't help people to get things to compile, and rather send them to complain to the package maintainers :)
03:24:49 <Jonno_FTW> also
03:25:02 <Jonno_FTW> will Haskell Platform get updated to use 6.12.1 ?
03:25:06 <Saizan_> yes
03:25:14 <Jonno_FTW> any time frame on that?
03:25:35 <Saizan_> before summer :)
03:25:40 <fasta> Saizan_, that is why I don't help further than I did.
03:25:49 <Jonno_FTW> where i come from, summer is nearly over
03:25:56 <fasta> Saizan_, people need to raise the bar on what they expect or simply ignore packages.
03:26:28 <fasta> Packages which do not compile without C dependencies should simply not appear on Hackage by default.
03:26:43 <Saizan_> it's also not easy to test all the possible configurations.
03:27:16 <Saizan_> Jonno_FTW: i'd try with --constraint="old-time == 1.0.0.2"
03:27:23 <fasta> Saizan_, only one configuration has to work.
03:27:25 <Jonno_FTW> ok
03:27:29 <fasta> Saizan_, the one specified by the maintainer.
03:27:45 <Saizan_> fasta: it usually specifies ranges
03:28:14 <fasta> Saizan_, I know, and in that case simply something should be chosen and communicated to the maintainers and that should _never_ change.
03:28:33 <Jonno_FTW> didn't work
03:28:35 <fasta> Saizan_, that is the rules of dependency resolution should not change.
03:29:13 <Jonno_FTW> Saizan_ : http://pastebin.ws/a93hsa
03:29:40 <fasta> Imho, the concept of using numbers to do resolution is a bad one.
03:30:01 <fasta> The only way to know whether two versions are really compatible is just to run the compiler on it.
03:30:01 <Jonno_FTW> how come?
03:30:12 <ksf> any type system gurus around?
03:30:41 <fasta> Numbers are nice as a user-interface, but should not be used to determine whether or not two things will work.
03:31:03 <fasta> And this "working" is what all the users are interested in.
03:31:31 <fasta> If package X works great with Y-1.2, but not with Y-1.3, then they want Y-1.2.
03:32:11 <fasta> Assuming there is some initial configuration which works, finding another configuration which also works, but with newer dependencies is an easy problem.
03:32:25 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17105#a17105
03:32:40 <fasta> Anyway, I feel like I am stating the obvious here, but somehow we ended up with Cabal, which is a very stupid system in this regard.
03:33:22 <ksf> ...I'm trying to get that working while ensuring that the types continue to properly track the exceptions
03:33:25 <Saizan_> fasta: easy problem == run ghc on it?
03:34:15 <fasta> Saizan_, given a package X, run ghc on its initial dependencies XS. Then, if the build succeeds, binary search for possibly newer dependencies.
03:34:25 <fasta> Saizan_, trivial by all CS standards.
03:34:26 <Jonno_FTW> should i just use my debian installation to do this? or is the problem one with cabal?
03:35:16 <Saizan_> Jonno_FTW: the problem is finding a set of packages that will build to install happstack, and making cabal use them
03:35:18 <jlouis> Cabal is currently at the same state of package maturity as Python, but behind ELF
03:35:24 <jlouis> IMO
03:35:40 <jlouis> which is a great feat, but we need to push further on :)
03:35:48 <Saizan_> Jonno_FTW: it shouldn't be a problem, but package maintainers didn't do a great job at putting all the info necessary in the .cabal files
03:35:52 <fasta> jlouis, what has ELF got to do with it?
03:36:26 <jlouis> fasta: I was speaking generally about the ability to maintain and control packages
03:36:58 <fasta> jlouis, ELF being the standard format used for object files?
03:37:14 <Jonno_FTW> hmmm, so what do i do?
03:37:30 <Saizan_> fasta: it looks like you'd get a combinatorial explosion by doing that search
03:37:43 <jlouis> fasta: yes, with regards to shared objects, dynamic link loading etc.
03:37:46 <fasta> Saizan_, no, you don't. Since, you don't search for a global maximum.
03:37:54 <fasta> Saizan_, just a local maximum version.
03:39:12 <Saizan_> fasta: so you'd just go for newer ones? but often we get the problem that someone with ghc-6.10 is trying to build a package tested on ghc-6.12, which would actually build if you pick _older_ dependencies
03:39:39 <Jonno_FTW> could i try install 6.12?
03:39:40 <Saizan_> then the ones it's tested with
03:40:03 <fasta> Saizan_, if the maintainer specifies that 6.12 is the minimal dependency then 6.10 simply does not work.
03:40:11 <fasta> Saizan_, garbage in, garbage out.
03:40:22 <Saizan_> fasta: it didn't specify anything like that
03:40:50 <fasta> Saizan_, I already said that the input of the maintainer was to specify one initial set of dependencies.
03:41:02 <fasta> Saizan_, that is, _exact_ package version.
03:41:06 <fasta> Saizan_, s
03:41:07 <Saizan_> fasta: ok
03:41:15 <Saizan_> fasta: that's where the problem comes from
03:41:18 <fasta> Saizan_, that is a very realistic situation.
03:41:41 <fasta> Saizan_, the original package developer knows what the dependencies are at the time of development.
03:41:43 <Jonno_FTW> but what if other packages require newer versions? wouldn't you run into problems of storing multiple versions of the one library?
03:41:51 <Saizan_> fasta: if you specify a single fixed set of dependencies, i actually need to search both forward and backwards through their versions
03:42:09 <Saizan_> Jonno_FTW: that's not a problem
03:42:17 <fasta> Jonno_FTW, multiple versions of the same library should be possible.
03:42:26 <fasta> Saizan_, why is that?
03:43:11 <Jonno_FTW> because i bet that is the problem I have run into
03:43:41 <Saizan_> fasta: suppose you've a package which initial configurarion is simply directory-N, you know that directory-N compiles only on ghc-6.12
03:43:59 <Saizan_> fasta: is my package buildable only on ghc-6.12? probably not
03:44:16 <Saizan_> since directory-(N-1) is very similar, but build on ghc-6.10
03:44:56 <fasta> Saizan_, yes, so isn't that the right answer then?
03:45:12 <Saizan_> fasta: what's the right answer?
03:46:10 <fasta> Saizan_, well, I don't see why you would want to build a previous version of something which is known to work.
03:46:24 <fasta> The assumption is that software improves over time.
03:46:41 <Saizan_> fasta: because you only have ghc-6.10?
03:47:07 <Saizan_> and many other packages you want to use don't work yet on ghc-6.12?
03:47:09 <fasta> Saizan_, so, you have 6.10 and you want to build exactly what?
03:47:38 <Saizan_> fasta: a package X which initial configuration is directory-N, and directory-N is known to not compile on ghc-6.10
03:47:56 <fasta> Saizan_, that means it won't work for you on 6.10.
03:48:07 <Saizan_> fasta: but that's probably false
03:48:30 <fasta> Saizan_, that doesn't make sense.
03:48:43 <fasta> Saizan_, first you say it doesn't compile. Then you say it does.
03:48:48 <Saizan_> fasta: in the sense that you could compile X against directory-(N-1) which works on ghc-6.10, it's just that the "initial configuration" chosen can only choose one package
03:49:06 <Saizan_> so it picked directory-N
03:49:20 <fasta> Saizan_, but every release of a package has associated with it an initial version.
03:49:47 <Saizan_> fasta: by initial you mean "the oldest dependencies that can make this work"?
03:50:10 <fasta> Saizan_, no, the current version at the time that directory-(N-1) was released.
03:50:10 <Saizan_> i thought it just meant "the dependencies this was tested against"
03:50:46 <Saizan_> fasta: right, we're talking about the initial configuration for X here
03:50:47 <fasta> Saizan_, so, given a concrete version of a package it is always possible to make it work like it worked on the machine of the developer.
03:50:56 <Saizan_> yeah
03:51:11 <Saizan_> but what if i have an older version for one of the dependencies?
03:51:22 <fasta> Saizan_, then the newer version will be fetched.
03:51:32 <Saizan_> fasta: suppose it can't.
03:51:41 <Saizan_> because it won't compile with my ghc
03:51:55 <fasta> Saizan_, then you need a new ghc.
03:52:02 <Saizan_> fasta: why?
03:52:21 <fasta> Saizan_, I have the impression we are talking in circles.
03:52:53 <Saizan_> fasta: knowing that the developer used directory-N doesn't tell me that his package won't build with directory-(N-1)
03:53:05 <Saizan_> it seems your resolution is assuming that.
03:53:18 <fasta> Saizan_, indeed, that is the case, but I already said there is no point in using an older version.
03:53:37 <Saizan_> but we routinely see that there is a point
03:54:36 <fasta> Saizan_, but the developer, who should know best, decided that directory-N was better than directory-(N-1) for package X.
03:54:55 <Saizan_> fasta: decided, or simply happened to use that version?
03:54:57 <fasta> Saizan_, if you are using packages written by developers you do not trust, you should find a different package.
03:55:36 <fasta> Saizan_, both are possible, but if you would like to use directory-(N-1), you simply install that one under the name directory-(N+1)
03:55:36 <Saizan_> fasta: so basically you require each developer to find the lowest version of the dependencies that he wants his package to be built with?
03:56:20 <fasta> Saizan_, and you update the package for X to X-(N+1).
03:56:45 <fasta> Saizan_, it doesn't have to be the lowest, just any that he/she likes.
03:57:20 <Saizan_> ok, so the resolution has to search in both directions, not only forward
03:57:44 <fasta> Saizan_, it does binary resolution starting with a lowest known resolution.
03:57:54 <fasta> Saizan_, known package version*
03:58:19 <Saizan_> the lowest known won't in general be the actual lowest
03:58:41 <Saizan_> and this will generally put us in the same situation we're now :)
03:58:41 <fasta> Saizan_, and I am saying "nobody cares about that".
03:58:46 <temoto> It is became possible to build shared libraries with haskell, right?
03:59:13 <fasta> Saizan_, nobody cares about packages which compile. People start to panic when they don't.
03:59:31 <fasta> Saizan_, no more emails like "you have to use a later version of that package".
04:00:08 <fasta> Saizan_, really, this would reduce the number of computable questions on the mailing list by a lot.
04:00:11 <Saizan_> fasta: cabal will tell you "this can't compile on your system"
04:00:38 <Saizan_> and you think people won't complain?
04:00:51 <fasta> Saizan_, yes, and that's great. You know either that you need to upgrade or that you need to send an email to the maintainer or fix it yourself.
04:01:16 <fasta> That is, fork the package.
04:02:20 <Saizan_> temoto: yes, with ghc-6.12
04:02:39 <fasta> Saizan_, in what way would such a system not be better than Cabal?
04:03:10 <temoto> And then, it could be possible with some LD_PRELOAD or something magic and FFI to override parts of functionality of some programs with haskell code?
04:03:29 <fasta> E.g. in the RSAGL package, there was a dependency on OpenGL, but the actual dependency was a specific version of OpenGL, as a newer version didn't work.
04:03:44 <fasta> My system would have evaded that problem.
04:04:57 <fasta> With a tighter integration between GHC and Cabal, you could even provide certificates that building actually worked given some versions, such that the Cabal server doesn't have to compile everything by itself.
04:05:19 <fasta> These would not have any theoretical value, but people would not forge them, probably.
04:06:28 <Saizan_> i agree with not trusting ranges that promise compatibility with versions of package that weren't there when the package were uploaded
04:06:44 <Saizan_> "versions of packages"
04:07:28 <Saizan_> though i still think we'd need ranges to cope with people that need older versions of something
04:08:41 <Saizan_> since your system will end up using older versions too, naturally
04:10:12 <fasta> Saizan_, when will it use an older version?
04:10:37 <Saizan_> fasta: the example you've just made, it'll use an older version of OpenGL
04:11:01 <Saizan_> fasta: what if you're also using another package which initial confuguration was the latest version of OpenGL?
04:11:09 <Saizan_> fasta: you've to figure out that it build anyhow
04:11:15 <Saizan_> *builds
04:11:38 <fasta> Saizan_, the other package will simply use the latest version of OpenGL then.
04:12:25 <Saizan_> fasta: you can use two versions of OpenGL in the same program? only if you don't make their types touch
04:12:43 <Saizan_> (and i don't know what happens at the C level)
04:12:44 <fasta> Saizan_, in the OpenGL case we have that the maintainer broke the contract if some larger version suddently works. \
04:12:55 <fasta> Saizan_, those are software engineering issues.
04:13:05 <fasta> Saizan_, not fundemental problems.
04:13:32 <Saizan_> the OpenGL maintainer did nothing actually, it's all about RSAGL and package X which uses OpenGL too
04:13:44 <Saizan_> fasta: that's all Cabal is trying to solve, actually
04:15:09 <Saizan_> in a single program, it's unlikely that you can use two versions of the same package and still get it to build
04:15:41 <Saizan_> that's one of the things that make resolution complex
04:23:07 <temoto> Could it be possible with LD_PRELOAD or something magic and FFI to override parts of functionality of other C program with haskell code?
04:23:24 <temoto> (on linux)
04:24:22 <p_l> temoto: with properly prepared program, yes
04:24:41 <p_l> but you can only reliably overload symbols loaded from external libraries
04:25:01 <p_l> other than that, it's the same as when you make a loadable library written in Haskel
04:25:37 <p_l> dunno if LD_PRELOAD overloads symbols referenced by full specification (library + symbol)
04:30:06 <quicksilver> most LD implementations have magic you can do for that kind of thing
04:30:27 <quicksilver> malloc debug libraries and opengl debug tools and so on tend to work this way
04:32:09 <pettter> valgrind is probably one of the most typical examples
04:32:44 <temoto> I was wondering how hard it would be to override something with *haskell* program. This obviously requires runtime to start and stop somewhere.
04:34:25 <mreh> i'd quite like to pause a haskell process and inspect the memory
04:34:41 <mreh> is there any easy way of making sense of what I'm going to find?
04:35:16 <temoto> mreh, there's data visualization library.
04:35:30 <mreh> temoto: okay
04:35:57 <temoto> mreh, i mean it's not like you use some kind of API to visualize your data, like "show".
04:36:06 <mreh> my ga is running a 10 hour cycle, but I think it's converged a little earlier than expected
04:37:10 <quicksilver> mreh: heap profiling is sort-of what you want
04:37:21 <quicksilver> you don't pause the program, you just generate the heap profile continuously and look at it
04:37:45 <quicksilver> there are lots of different heap-profiling options to group things differently
04:38:32 <mreh> recompilation required, okay, not this time then
04:38:45 <quicksilver> there is one heap profiling option which doesn't require recompilation
04:38:49 <quicksilver> might be -hT ?
04:38:54 <mreh> i need to specify some decent termination conditions, rather than run 100000 generations
04:38:58 <quicksilver> JaffaCake would remember :)
04:39:22 <JaffaCake> -h
04:39:25 <mreh> quicksilver: I'm 6 hours into the run :)
04:42:10 <mreh> If only I could make it run faster...
04:42:42 <temoto> mreh, distributed computations is a way to go.
04:43:24 <temoto> mreh, and if you go into that, learn zeroconf as well (linux implementation: avahi, mac: bonjour).
04:44:54 <xerox> what are you computing mreh?
04:45:48 <Axman6> temoto: on OS X, i'd recommend using Xgrid. quite easy to get going if you use something like gridstuffer
04:47:01 <mreh> xerox: the optimal hamiltonian cycle around a 50x50 grid
04:49:22 <mreh> temoto: If I could just get it to run on two cores
04:49:47 <mreh> ...it would freeze my gui most likely
04:50:58 * hackagebot upload: bff 0.3 - Bidirectionalization for Free! (POPL'09) (JoachimBreitner)
04:55:02 <temoto> Axman6, i'm not on OS X.. yet :)
04:55:09 <Axman6> :)
04:55:52 <temoto> mreh, it's easy to run haskell stuff on 2 cores. Add `par` annotations and run with +RTS -N2 or something like that.
04:57:31 <SamB_XP> no strange "#pragma omp"'s needed
04:58:05 <Axman6> parallel programming in haskell is lovely
04:59:36 <SamB_XP> though I have to say, I wonder whether it might not be helpful to have a nice functional message-passing interface?
05:02:27 <quicksilver> can't you build something rather like that from Chans?
05:02:37 <quicksilver> depending what precise kind of message passing you're hoping for?
05:02:54 <SamB_XP> quicksilver: I meant like MPI
05:03:02 <SamB_XP> only with a much nicer API
05:03:05 <Alpounet> SamB_XP, isn't there any ?
05:03:33 <Alpounet> SamB_XP, http://www.foldr.org/~michaelw/hmpi/
05:03:54 <Alpounet> it's old but still
05:04:05 <Alpounet> maybe somebody could take that further
05:04:14 <SamB_XP> if you didn't get the memo, MPI is an API that you can use to write programs to run on clusters
05:04:32 <Alpounet> yes
05:04:39 <SamB_XP> Alpounet seems to have gotten the memo, yes ;-)
05:04:40 <quicksilver> SamB_XP: an extension of Chan to work between processes, then?
05:04:56 <SamB_XP> quicksilver: not actually possible ;-P
05:05:18 <quicksilver> doesn't happstack have some of the bits and pieces you need?
05:05:28 <Alpounet> maybe an interesting GSoC project to make hmpi evolve ?
05:05:57 <SamB_XP> daume has updated the package a bit, evidently?
05:07:25 <Alpounet> oh yeah indeed
05:07:54 <SamB_XP> hmm, he should have stated which version of GHC it works with ;-P
05:08:13 <Alpounet> it seems it's not on hackage though
05:08:19 <Alpounet> so probably a bit experimental still
05:08:25 <SamB_XP> 'cause even if it was updated on 2010-01-06, I dunno if that section was?
05:08:48 <temoto> SamB_XP, there are few distributed haskell projects.
05:09:08 <temoto> (i don't mean not enough)
05:09:20 <temoto> always confuse those 'few' and 'a few'
05:09:34 <SamB_XP> 'a few' is what you meant, then?
05:09:47 <SamB_XP> that's the one that means something like 'several'
05:09:51 <temoto> Yup.
05:10:00 <temoto> I'll get links if you want.
05:10:19 <quicksilver> gdh etc
05:10:24 <quicksilver> they're all bitrotted aren't they?
05:10:28 <Alpounet> SamB_XP, well, there isn't any cabal file in the updated hmpi
05:10:31 * quicksilver wasn't aware of a current, active one.
05:10:40 <Alpounet> just code
05:10:57 <SamB_XP> wth
05:11:04 <SamB_XP> it doesn't even have a directory in that tarball!
05:11:07 <Alpounet> it's not something that helps in trusting that package for a serious use
05:11:09 <Alpounet> yep
05:12:26 <temoto> Hah tarbomb.
05:12:39 <Alpounet> the best thing to do maybe would be to take the distributed part of happstack and make it an independent library
05:13:45 <temoto> It's funny, those guys in Jetbrains are making yet another python IDE. And they distribute linux version in tar.gz. And they have warning on the download site: PUT IT INTO NEW DIRECTORY!
05:19:26 <moshisushi> hello! anyone familiar with the Data.Tree.AVL?
05:19:47 <moshisushi> i need help writing the ordering function for push
05:20:58 <Zao> temoto: As in, the tarball doesn't contain a directory?
05:20:59 <Zao> o.O
05:22:43 <temoto> Zao, apparently. But the most funny part is that they use client-side fix for it :) like asking users to create a directory first, instead of just repack tarball :)
05:23:30 <jlouis> moshisushi: look up COrdering
05:23:49 * zygoloid wonders what happens if you author a tarball with a .. directory in it
05:24:50 <moshisushi> jlouis: yeah i did, but i don't find any examples of how to use it
05:25:39 <jlouis> moshisushi: the difference between Ordering and COrdering is that the latter also contains the element in the Eq-case
05:26:39 <jlouis> moshisushi: if it does not matter which of the two elements that compare equal you choose, you can use the fstCC function for instance
05:26:54 <jlouis> if it does matter, you can define your own COrdering instance for them
05:27:09 <moshisushi> yeah but push takes a (e -> COrdering e)
05:27:43 <moshisushi> confuses me since i thought that function would rather be e -> e -> COrdering e
05:29:03 <jlouis> moshisushi: the first e is 'folded into' the selector function
05:29:11 <jlouis> the single e you get is that from the tree
05:29:45 <temoto> zygoloid, it will extract to parent directory, obviously. There's nothing wrong with that.
05:29:59 <moshisushi> jlouis: so i use currying with the element to insert?
05:30:04 <moshisushi> (fstCC elem)
05:30:05 <jlouis> moshisushi: yes
05:30:13 <temoto> zygoloid, you can even put /root directories in it.
05:30:24 <jlouis> Note however, that I have not used that code, only read the type signature :)
05:30:40 <jlouis> but I would strongly guess that is how it works
05:34:34 <zygoloid> temoto: huh, scary :-(
05:34:41 <moshisushi> jlouis: works fine!
05:34:42 <moshisushi> thanks
05:35:12 * hackagebot upload: database-study 0.0.1 - Demonstrate how a database can be implemented the functional way (HenningThielemann)
05:38:39 <temoto> Oh yesterday i invented pure functional database with full support for most complicated SELECT queries.
05:40:08 <temoto> It goes like this:  executeQuery :: String -> [Row] ; executeQuery q = []
05:40:09 <DrTeggy> temoto: Share details please
05:40:25 <temoto> That's all. Database engine completed.
05:40:28 <DrTeggy> Uh.
05:41:01 <temoto> It is fully conformant to its specification: a database with one statement (select).
05:41:36 <DrTeggy> You should show some respect for the database community, dude
05:42:25 <benmachine> I would argue you're stretching the definition of database just a little bit thin
05:42:31 <temoto> DrTeggy, do you mean i shouldn't advertise it?
05:42:46 <Saizan> @hackage database-study
05:42:46 <lambdabot> http://hackage.haskell.org/package/database-study
05:43:29 <DrTeggy> temoto: Depends -- if you want to make a complete fool out of you... ;-)
05:43:37 <Saizan> temoto: it seems database-study supports update, so you're behind in the research
05:44:16 <temoto> saiam, dammit, i knew i should've added some features.
05:44:50 <temoto> Other than ACID. :)
05:46:21 <zygoloid> temoto: doesn't look like it supports 'SELECT ... INTO ...'
05:46:41 <arw> well. "its ACID because it doesn't allow concurrency" doesn't count :)
05:47:36 <temoto> zygoloid, yeah, but that's only because it doesn't support such advanced feature as tables.
05:47:51 <temoto> not everyone needs tables y'kno :)
05:48:02 <DrTeggy> Well, a SQL query can produce a non-empty result even for an empty database. temoto needs to hack some more anyway.
05:48:17 * hackagebot upload: non-negative 0.0.5.1 - Non-negative numbers (HenningThielemann)
05:48:28 <temoto> select 1+1! You're right!
05:48:40 <arw> select random()...
05:49:00 <temoto> Total fail.
05:49:07 <Axman6> pathetic
05:49:11 <Axman6> -_-
05:49:27 <DrTeggy> There's the VALUE clause, for example
05:49:40 <temoto> I swear, that's the worst database i ever wrote.
05:50:10 <jlouis> Axman6: It looks as if we have endgame support in the 'next' branch now. Then i'll get to work your merger branch in :)
05:50:38 <jlouis> blindly adding it with a merge failed, so I have to figure out why :)
05:50:42 <Axman6> hooray!... what's endgame?
05:50:59 <jlouis> spamming all peers for pieces when the torrent is close to being done
05:51:09 <copumpkin> mmmspam
05:51:10 <Axman6> ah. very nice
05:51:23 <jlouis> it ensures that it will close quickly so it can go into seeding mode fast
05:51:33 <Axman6> jlouis: man, out timezones are so incompatible :(
05:51:42 <Axman6> our*
05:51:55 <Axman6> i was just about to get into bed :P
05:51:55 <jlouis> Yeah, and my biological clock is still in the middle of the atlantic
05:52:11 <Axman6> mine
05:52:18 <Axman6> mine's about hongkong i think
05:52:44 <Axman6> anyway, good to hear progress is going well. i will catch up with you soon, and put some more work in soon!
05:52:58 <Axman6> going back to uni soon, so it'd be good to get some done before then
05:53:06 <jlouis> hehe :)
05:53:08 <jlouis> nn
05:53:10 <Axman6> o/
05:56:58 <kamatsu> @pl \a b -> liftIO $ writeChan a b
05:56:58 <lambdabot> (liftIO .) . writeChan
05:58:09 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17109#a17109 -- does ayone have any idea how I could squeeze any more out of all this optimisation?
05:58:25 <mreh> i.e. choice of data structures, sneaky underhanded tactics
05:59:51 <mreh> it's computing the distance round a circuit from an adjacency matrix Array
06:00:36 <mreh> making the thing two dimensional gives a big boost because it cuts out all the arithmetic for calculating the jumping off point
06:01:21 <paolino> where I can find cl.exe to cabal install directory ?
06:02:12 <Alpounet> cl.exE?
06:02:17 <Alpounet> Visual C++'s compiler ?
06:02:29 <Alpounet> C & C++*
06:02:38 <paolino> open sources ?
06:02:50 <Alpounet> there's the VC++ express version
06:02:56 <Alpounet> which is free
06:03:09 <Alpounet> you also can install mingw
06:03:23 <Alpounet> which offers a windows/mingw port of gcc
06:04:06 <mreh> nobody? :(
06:04:30 <copumpkin> mreh: don't use an array of arrays unless you have to
06:04:54 <copumpkin> make it an unboxed array
06:05:06 <paolino> Alpounet: thx
06:05:10 <copumpkin> don't use Integer unless you have to (with an array, I'll be really surprised if you have to)
06:05:13 <mreh> copumpking: Data.Array
06:05:13 <copumpkin> UArray (Int, Int) Double
06:05:43 <mreh> > maxBound INt
06:05:44 <lambdabot>   Not in scope: data constructor `INt'
06:05:47 <mreh> > maxBound Int
06:05:48 <lambdabot>   Not in scope: data constructor `Int'
06:05:50 <copumpkin> > maxBound :: Int
06:05:51 <mreh> what?
06:05:51 <lambdabot>   9223372036854775807
06:05:54 <mreh> yes, that
06:05:57 <mreh> that's massive
06:06:02 <micah> hello copumpkin :)
06:06:02 <copumpkin> well, it depends on your system
06:06:09 <mreh> > 50^4
06:06:09 <lambdabot>   6250000
06:06:10 <copumpkin> mreh: and profile to make sure that this function is actually your slowdown
06:06:11 <mreh> > 55^4
06:06:12 <lambdabot>   9150625
06:06:18 <mreh> copumpkin: it is
06:06:18 <copumpkin> > 2^63 - 1
06:06:19 <lambdabot>   9223372036854775807
06:06:26 <PepeSilvia> hi, does anyone know if you can distribute (bash) scripts with a cabal package?
06:06:27 <mreh> that's the biggest array i'll need
06:06:31 <copumpkin> mi micah :)
06:06:50 <copumpkin> mreh: then an unboxed array will save you loads of space
06:07:07 <mreh> copumpkin: will converting Integer -> Int be a killer?
06:07:21 <mreh> they're never going to be larger than the memory word
06:07:28 <mreh> still, is there overhead?
06:08:30 <Daerim> mreh,yes.But why would you want to use integer at all?
06:09:10 <mreh> Daerim: I don't know, it was an arbitary choice
06:09:22 <mreh> major refactoring is in order
06:09:43 <copumpkin> gotta go now :P
06:09:48 <copumpkin> unboxed array will be the major advantage though
06:09:54 <mreh> space and time?
06:10:01 <copumpkin> you won't get complexity improvements
06:11:57 <Daerim> mreh, mainly time afaik. In general you can get very far by only specifying Int or Integer in the top function and letting the magic that is ghc figure out the rest. Makes it easy change your datatype
06:14:08 <Daerim> mreh, but using UArray is a lot faster than normal arrays. You can't make lazy computations in them though, so you can't have an array that is defined by itself
06:15:43 <Daerim> you can get around that by creating the arrays using monads and STArray, if speed is really important
06:16:10 <mreh> Daerim: it is, 50% of my algorithm is spent digging through arrays right now
06:16:25 <mreh> I haven't eliminated redundant bounds checks yet
06:16:33 <mreh> :t unsafeAt
06:16:34 <lambdabot> Not in scope: `unsafeAt'
06:16:58 <mreh> I read on the wiki about Data.Array.Base.unsafeAt, although I can't find it
06:17:39 <Daerim> yeah, there's an even better on somewhere
06:17:56 <Daerim> a moment, let me dig around in my Matrix lib, it does all these hacks
06:19:24 <mreh> it also says that the internal representation of Array indices are of type Int, so going Int will improve things vastly if I use unsafeAt
06:20:21 <temoto> You can have array larger than maxBound::Int?
06:20:27 <temoto> can not*
06:21:09 <mreh> > 55^4
06:21:10 <lambdabot>   9150625
06:21:18 <mreh> that's the biggest array I'll ever need
06:21:29 <temoto> i mean in general
06:21:34 <temoto> it's not possible?
06:21:39 <mreh> oh
06:22:08 <mreh> http://www.haskell.org/haskellwiki/Arrays#Unsafe_indexing.2C_freezing.2Fthawing.2C_running_over_array_elements
06:22:18 <mreh> that seems to imply that is the case
06:22:36 <mreh> UArray certainly cannot be bigger than maxBound :: Int
06:22:50 <temoto> Interesting.
06:24:26 <ksf> sure it can
06:24:47 <ksf> with an UArray bool, you get 8*maxInt before running out of address space
06:27:28 <FalconNL> Just ran into a small problem. By default, print "caf" will output "caf\233". While that's technically correct, I need to output words with accents in the non-escaped way. I looked at System.IO.UTF8, but that seems to have the same behaviour. Can anyone tell me what the correct way would be to do this?
06:28:08 <aavogt> you used print? putStr (possibly a unicode variant) will do better
06:28:20 <aavogt> > show "\233"
06:28:21 <lambdabot>   "\"\\233\""
06:28:26 <aavogt> > text "\233"
06:28:27 <lambdabot>   
06:28:47 <aavogt> and in here text does the same as putStrLn
06:29:16 <xerox> ?hoogle HughesPJ
06:29:16 <lambdabot> module Text.PrettyPrint.HughesPJ
06:30:27 <Daerim> mreh, hmm I couldn't find the specific reference,but unsafeAt is pretty fast tbh
06:30:29 <FalconNL> When I try putStrLn "caf" in ghci on windows, I get "caf". I'll have a look at HughesPJ
06:31:21 <Daerim> mreh, but go to UArrays first. unsafes are unsafe for a reason, you're throwing a lot of things out the window to get them
06:32:39 <FalconNL> Same thing with HughesPJ.
06:33:58 * ksf blames it on a broken terminal
06:34:40 <galdor> is there some plans to make hs-plugins working with GHC 6.12.1 ?
06:35:12 <ksf> FalconNL, if you're still using 6.10.4, you might want to try 6.12, as the IO library got revamped
06:35:51 <ksf> ...and IO on windows tends to be dodgy, because a) io on windows sucks and b) we've got way more unix developers than for windows
06:35:53 <FalconNL> ksf: Do you happen to know if there is any timeline yet on when the Haskell Platform will release a 6.12 version?
06:36:15 <ksf> nope
06:36:30 <ksf> but so far, I didn't come across any major problems
06:36:38 <ksf> ...not even a large number of minor ones
06:37:02 <ksf> I think I once needed to change a data constructor wrt. exceptions, but that was it
06:37:38 <FalconNL> So you can just install 6.12 over a Haskell Patform installation?
06:38:02 <ksf> I'd recommend making a seperate directory for it
06:38:33 <ksf> ...download ghc, compile cabal-install manually and then you basically have your platform
06:38:51 <FalconNL> Ok, I'll give that a go. Thanks.
06:39:02 <micah> clang has self-hosted! :D
06:39:14 <micah> not really a haskell thing
06:39:16 <micah> but awesome
06:39:17 <micah> :P
06:39:48 <dblhelix> FalconNL: just curious: are you a student of Jaap van der Woude?
06:40:14 <FalconNL> dblhelix: Nope. I'm a PhD student at the Eindhoven University of Technology
06:40:20 <Saizan> FalconNL: it's easier if you cabal install "cabal-install >= 0.8.0" with your ghc-6.10
06:40:30 <dblhelix> FalconNL: ah, I see, okay
06:44:54 <FalconNL> Yep, 6.12 prints the correct result
06:49:21 <merijn> 3 questions: 1) Any got any pointers to documentation on when to use BinaryString vs [Char] and what the differences of the resulting code are? 2) What's the best way of dealing with binary data? 3) Is it just me or do Haskell's ADTs make specifying ASTs trivial?
06:49:39 <micah> the adt's are super nice for ast's
06:49:42 <dylan> note to self: #xmonad is not haskell, despite being in the same list
06:49:45 <micah> no experience with other two
06:50:02 <dylan> just want to check something - there is no arbitrary limit on the length of a  the textual representation of a type, is there?
06:50:28 <dylan> I have an Action a r type class, and a type data Step a a' r r' = (Action a r, Action a' r') => a :> a' which is an instance of Action.
06:50:52 <dylan> such that download :> unpack :> build :: Step Download (Step Unpack Build () ()) () ((), ())
06:51:01 <dylan> Does that sound sane?
06:52:00 <quicksilver> merijn: BinaryString?
06:52:09 <quicksilver> ByteString?
06:52:16 <arw> gg
06:52:23 <arw> uh, sorry. wrong window
06:52:32 <merijn> quicksilver: Oh, yeah. I knew it was something in that direction
06:53:12 <Alpounet> merijn, regarding 3), it isn't just you.
06:53:45 <quicksilver> merijn: ByteString is a string of Bytes. Not Characters.
06:54:00 <quicksilver> merijn: so, in principle, you should always use [Char] when what you actually have is characters.
06:54:11 <quicksilver> and ByteString for binary date
06:54:12 <quicksilver> data.
06:54:39 <quicksilver> having said that, people sometimes use ByteString as a fast compact string if they're being 8-bit-centric or handle the encoding in a separate step.
06:54:53 <quicksilver> Data.Text is supposed to solve this mismatch, btu I've never used it.
06:55:18 <quicksilver> merijn: as to (2); that's a big subject!
06:55:28 <quicksilver> however, Data.Binary certainly contains some solutions to some parts of it.
06:56:12 <merijn> quicksilver: Right, so time to hit the Data.Text and Data.Binary docs then.
06:57:44 <merijn> Also, pretty terrible of Real World Haskell to refer to ByteString as a replacement for String when needing faster IO, then. I'm pretty sure that in a perfect world it'd be a criminal offense to break unicode support in applications.
06:58:23 <temoto> merijn, merely using ByteString doesn't imply breaking unicode support.
06:58:29 <quicksilver> well you just have to handle the encoding/decoding by hand
06:58:43 <quicksilver> and actualy you have to do that anyway, in the version of haskell they're describing in that book
06:59:04 <merijn> temoto: Yeah, but how many people do that without messing up?
06:59:25 <merijn> Or really just "how many people do that?"
06:59:28 * Daerim has still to find an efficient way of writing floats to an ascii file. 
06:59:57 <temoto> merijn, in haskell? I think many enough, because String and ByteString are not a drop-in replacement for each other.
07:00:25 <Zao> I'd recommend Data.Text over ByteString for internal mangling.
07:05:38 <mreh> I don't get it, my algorithm is *safe
07:05:54 <mreh> but using unsafeAt causes a segmentation fault
07:06:13 <mreh> it doesn't ever go out of bounds
07:06:37 <quicksilver> unsafeAt doesn't use bounds
07:06:41 <quicksilver> it uses underling indices
07:06:42 <aavogt> dylan: typeclass constraints on data constructors aren't helpful. Put the  (Action a r, Action a' r') =>   in the instance declaration    Action (Step a a')
07:06:46 <quicksilver> @hoogle unsafeAt
07:06:47 <lambdabot> No results found
07:06:58 <mreh> it is undocumented
07:07:03 <quicksilver> notice that unsafeAt takes an 'Int' not an 'i'
07:07:08 <quicksilver> (where i is your index type)
07:07:25 <mreh> quicksilver, that's what I'm passing it
07:07:31 <dylan> aavogt: it is in there too
07:07:39 <pumpkin> where i is a bunch of other types too :)
07:07:45 <ksf> why am I catching exceptions when calling ffi functions?
07:07:50 <aavogt> dylan: though you seem to have a mismatch in the kinds of  Action and Step... what are the definitions?
07:07:51 <dylan> aavogt: are you sure it isn't useful?
07:08:04 <quicksilver> mreh: well, in particular, the unsafeAt index is always zero-based
07:08:06 <ksf> as if C had any kind of error handling...
07:08:13 <quicksilver> mreh: what are your bounds?
07:08:14 <dylan> Action is a type class
07:08:29 <dylan> I was unaware that they had a kind
07:08:30 <quicksilver> dylan: Yes, aavogt is right.
07:08:34 <aavogt> well I mean the kinds of members of the type class
07:08:51 <quicksilver> dylan: typeclass constraints on data definitions aren't helpful
07:08:53 <quicksilver> except with GADTs
07:09:09 <quicksilver> arguably they're a bug in haskell 98
07:09:09 <jeltsch> Hello, what should I do if mails to support@community.haskell.org arent answered for months?
07:09:12 <dylan> 'kay
07:09:28 <quicksilver> jeltsch: what kind of thing was the email about?
07:09:28 <mreh> quicksilver... ohh, zero based
07:09:31 <dylan> aavogt: the Actigon type class is class (Show a, ActionResult r) => Action a r | a -> r where
07:09:39 <mreh> :D
07:10:25 <jeltsch> quicksilver: I sent two e-mails: resetting list admin password and removing Trac tickets.
07:10:27 <dylan> and for Step, the instance is instance (ActionResult r, ActionResult r') => Action (Step a a' r r') (r, r')
07:10:56 <ksf> while I'm at it: is there a way to catch segfaults?
07:11:00 <quicksilver> jeltsch: have you re-sent the emails at all?
07:11:02 <ksf> ...in haskell, I mean.
07:11:18 <dylan> ksf: don't use unsafe*? :)
07:11:28 <ksf> oh, one just has to use peek
07:11:47 <aavogt> @type poke
07:11:48 <lambdabot> Not in scope: `poke'
07:11:48 <dylan> segfaults are OS dependent. In linux, they are not catchable in one process
07:11:56 <dylan> Win32 api allows you to catch them
07:11:57 <ksf> SIGSEGV
07:12:00 <ksf> you can trap that
07:12:09 <dylan> yes, but it can not return
07:12:26 <Daerim> ksf, they should rename all of Foreign to Unsafe.Foreign :p
07:12:47 <dylan> damn unsafe foreigners
07:12:53 <quicksilver> trapping SIGSEGV is very difficult to do usefully
07:12:55 <int-e> and IO to UnsafeIO?
07:13:04 <jeltsch> quicksilver: No. Should I?
07:13:07 <int-e> then we can have unsafePerformUnsafeIO
07:13:15 <quicksilver> since it's really quite hard to work out how much of your application state can be rescued if any
07:13:21 <quicksilver> I wonder if the haskell RTS could help, though
07:13:22 <Daerim> int-e, IO isn't unsafe?
07:13:22 <ksf> one should be able to.
07:13:30 <ksf> segfaults are even thread-specific
07:13:30 <jeltsch> quicksilver: After all, the messages are automatically put into some issue tracker, as far as I know.
07:13:47 <quicksilver> jeltsch: I didn't think they were but it's perfectly possible I'm wrong.
07:13:53 <ksf> the only truly uncatchable signal is sigkill
07:14:08 <int-e> Daerim: IO can launch missiles, given the right hardware ,)
07:14:23 <dylan> ksf: SIGABRT
07:14:34 <quicksilver> jeltsch: I would consider the following options (1) resend emails (2) try to find someone like Igloo or JaffaCake on IRC and ask them who is responsible for that facility (3) email haskell-cafe asking for help.
07:14:54 <Daerim> int-e, well IO does attempt to communicate with the real world. Missiles are to be expected
07:15:10 <jeltsch> quicksilver: Who is JaffaCake?
07:15:19 <ksf> dylan, you can trap it
07:15:30 <quicksilver> jeltsch: Simon Marlow
07:15:30 <ksf> ...but abort will kill you anyway.
07:15:54 <ksf> if you don't terminate, it's going to mess with your signal handlers and send it again
07:15:54 <dylan> aavogt: data Step a a' r r' = (Action a r, Action a' r') => a :> a' is required for my program to type check. :P
07:16:09 <ksf> that's a huge difference to sigkill, though.
07:16:42 <mux> ksf: SIGSTOP and SIGKILL are the two uncatchable signals per POSIX
07:17:11 <dylan> quicksilver: ^^
07:17:32 <quicksilver> dylan: no it's not.
07:17:37 <mux> all others are supposed to be catchable, or your OS is buggy :-P
07:17:43 <quicksilver> dylan: but you might need to annotate some other functions otherwise.
07:18:16 <dylan> then that typing saves typing, os is useful. :)
07:18:28 <ksf> it'd be nice if I could catch segfaults, even if it's only meant to be used with foreign functions
07:18:39 <ksf> or say peek
07:18:40 <dylan> I did add to the context of Action Step, instance (Action a r, Action a' r', ActionResult r, ActionResult r') => Action (Step a a' r r') (r, r') where
07:19:02 <dylan> though I auppose ActionResult is now implied
07:19:24 <ksf> though it's admittedly quite hard to get peek to segfault, with all that alloced memory everywhere.
07:21:32 <int-e> "The behavior of a process is undefined after it returns normally from a signal-catching function for a SIGBUS, SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(), sigqueue(), or raise()." Hmm, what about siglongjmp?
07:33:58 <ksf> I wouldn't want to return from the handler, but call a continuation
07:34:26 <ksf> ...that is, get out of the ffi code asap.
07:37:38 <quicksilver> yes but you have to fix your C stack, ksf
07:37:53 <quicksilver> however I think it ought to be possible by always calling setjmp before FFI calls
07:37:58 <quicksilver> and then longjmp'ing out of the signal handler
07:38:11 <quicksilver> that's the kind of things people do to handle segfaults
07:43:00 <sm> morning all
07:43:12 <mreh> mornin
07:43:22 <mreh> you mean... afternoon
07:44:14 <sm> yes.. time for the daily cabal/hackage/package wrestle
07:44:47 <sm> cabal install --reinstall -p template-haskell --constraint "template-haskell < 2.4" says "Could not find module `Data.Data':
07:44:48 <sm>       it is a member of the hidden package `base'", why is that ?
07:46:52 <mreh> is there a trick to make unboxed two-dimensional arrays?
07:47:06 <doserj> sm: what ghc version?
07:47:17 <sm> doserj: 6.10.4
07:47:50 <quicksilver> mreh: just use a UArray with a 2-tuple as index type
07:48:29 <doserj> sm: can you build with verbose output?
07:48:36 <sm> doserj: good idea
07:49:03 <mreh> quicksilver: can't use unsafeAt then :(
07:49:30 <quicksilver> mreh: of course you can.
07:49:37 <sm> Using Cabal-1.8.0.2 compiled by ghc-6.12 <- problem ?
07:49:37 <quicksilver> mreh: you just have to do the sums yourself.
07:49:37 <sm> Using compiler: ghc-6.10.4
07:49:38 <mreh> converting a tuple to an Int is costly
07:50:07 <quicksilver> any 2-D array is going to do the moral equivalent of converting a tuple to an int
07:50:19 <quicksilver> y*w+x is hardly an expensive operation.
07:50:50 <mreh> quicksilver: -1 :D
07:50:58 <doserj> the Ix instance for tuples does exactly that, I would guess
07:51:00 <mreh> (y-1)*w+x-1
07:51:19 <mreh> but that's an irrelevant detail
07:51:21 <ksf> herecy!
07:51:28 <ksf> arrays start at 0. always and ever.
07:51:41 <mreh> no they dont
07:51:46 <mreh> memory starts at zero
07:52:06 <fabjan> Dijkstra does not approve
07:52:11 <mreh> > [1,2,3] !! 0
07:52:12 <lambdabot>   1
07:52:16 <mreh> that's wrong in my mind
07:52:20 <quicksilver> doserj: well it does the slightly fiddlier (x-minx)*(maxx-minx) + (y-miny)
07:52:24 <quicksilver> doserj: or something like that.
07:52:43 <Alpounet> mreh, why ?
07:52:52 <tromp> > [0,1,2]!!0
07:52:52 <mreh> but lists are abstract
07:52:53 <lambdabot>   0
07:53:00 <mreh> s/but/because/
07:53:00 <tromp> looks right
07:53:01 <aavogt> > [1,2,3] !!!! 1
07:53:02 <lambdabot>   Not in scope: `!!!!'
07:53:10 <quicksilver> doserj: the Ix instance gets inlined but 'minx' and 'miny' don't
07:53:15 <mreh> :t !!!
07:53:15 <lambdabot> parse error on input `!!!'
07:53:20 <sm> doserj: still puzzled.. "wired-in package base mapped to base-4.1.0.0", looks ok
07:53:25 <aavogt> > [1,2,3] !!!! 1
07:53:27 <lambdabot>   Not in scope: `!!!!'
07:53:30 <Alpounet> mreh, it's widespread that indexes start at 0.
07:53:31 <tromp> :t (!!!)
07:53:32 <lambdabot> Not in scope: `!!!'
07:53:38 <doserj> quicksilver: point taken
07:53:41 <mreh> Alpounet: so what?
07:53:41 <Alpounet> (not everywhere, but still)
07:53:44 <aavogt> hmm, @let doesn't work?
07:54:11 <mreh> it's commonly known that all programming languages should be sequential and allow side effects
07:54:13 <xerox> ?let work = "yes I do"
07:54:14 <lambdabot>  Defined.
07:54:17 <xerox> > work
07:54:18 <lambdabot>   "yes I do"
07:54:40 <nlogax> > let foo = [1,2,3] in foo !! (length foo) -- i think that's a little weird about starting at 0
07:54:41 <lambdabot>   * Exception: Prelude.(!!): index too large
07:54:53 <aavogt> @let x !!! y = x !! (y-1)
07:54:54 <lambdabot>  Defined.
07:55:04 <aavogt> > "hello" !!! 1
07:55:05 <lambdabot>   'h'
07:55:45 <mreh> can you define operators like that?
07:56:06 <mreh> in ghc haskell?
07:56:20 <Alpounet> yes
07:56:24 <dylan> yep
07:56:31 <aavogt> in haskell 98 too
07:56:48 <int-e> > last [1..3]
07:56:49 <lambdabot>   3
07:56:53 <fabjan> http://www.cs.utexas.edu/~EWD/ewd08xx/EWD831.PDF
07:57:04 <Alpounet> > let x <!> y = x + y in 1 <!> 2
07:57:05 <lambdabot>   3
07:57:13 <nlogax> they're just functions, if the name consist of symbols, it's infix
07:57:15 * sm installs template-haskell-2.4 by commenting out the base-4.2-requiring line.. see how that goes
07:57:26 <xerox> > let x  y = x^2 + y^2 - x*y in zipWith () [2,4..10] [1,3..]
07:57:27 <lambdabot>   [3,13,31,57,91]
07:57:34 <ksf> @hoogle (Num a, Integral b) => a -> b
07:57:34 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
07:57:35 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
07:57:35 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
07:57:38 <zygoloid> @let let (!) 0 = 1; (!) (n+1) = n+1 * (n!)
07:57:38 <lambdabot>   Parse error: KW_Let
07:57:39 <ksf> gnargh
07:57:42 <zygoloid> @let (!) 0 = 1; (!) (n+1) = n+1 * (n!)
07:57:43 <lambdabot>  <local>:13:31:
07:57:43 <lambdabot>      Ambiguous occurrence `!'
07:57:43 <lambdabot>      It could refer to either `...
07:57:46 <zygoloid> :(
07:57:52 <sm> doh, ghc returned ExitFailure 11
07:58:07 <doserj> sm: that won't work because of http://hackage.haskell.org/trac/ghc/ticket/3809
07:58:36 <sm> I commented out CharConstr
07:58:39 <quicksilver> doserj: it would be nice if you could arrange for minx and miny to get inlined and make the whole thing compile down to the same code
07:59:01 <sm> template-haskell installed fine, but building syb-with-class now crashes
07:59:04 <quicksilver> but I fear you'd have to reflect the bounds into the type to acheive that.
07:59:26 <quicksilver> Incidentally I also think it's a bit odd that (!! 0) returns the "first" element of the list.
07:59:32 <sm> doserj: thanks for the issue link
07:59:35 <Saizan> sm: the right thing to do is use an older syb-with-class
07:59:37 <quicksilver> as mreh says, lists are abstract.
07:59:47 <McManiaC> if I connect to a server with Network.connectTo - how can I tell if my connection is still alive? System.IO.hIsClosed is always true
07:59:50 <McManiaC> *false
08:00:08 <Saizan> rather than upgrading template-haskell, i mean
08:01:19 <sm> Saizan: thanks for the hint, indeed it was trying to upgrade my syb-with-class. Shouldn't crash of course
08:01:33 <quicksilver> McManiaC: keep reading/writing.
08:01:39 <quicksilver> McManiaC: you'll get SIGPIPE if it goes away
08:01:43 <quicksilver> (which you should handle)
08:01:54 <quicksilver> McManiaC: if you don't read or write anything you actually can't tell if it's still alive
08:01:57 <sm> I'm trying to go via template-haskell-2.4 because I can't reinstall the older version in any way
08:02:03 <quicksilver> idle TCP connections are indistinguishable from broken ones.
08:02:07 <mietek> How would you go about generating 10 million unique random numbers?
08:02:16 <quicksilver> as far as I know.
08:02:21 <McManiaC> quicksilver: *** Exception: <socket: 7>: hGetLine: end of file  Control.Exception?
08:02:24 <mietek> (pseudo-random)
08:02:48 <quicksilver> McManiaC: ah, check hIsEof as well.
08:02:57 <sm> but it's not working out.. time to back out
08:02:59 <aavogt> how are they random if you can't repeat numbers?
08:03:06 <merijn> mietek: By using any generator with a period of less then 10 million?
08:03:18 <quicksilver> but I think you'll still have problems if the connnection goes away mid-line
08:03:32 <quicksilver> merijn: "period" implies not-random
08:03:35 <aavogt> @hoogle randomIOs
08:03:36 <lambdabot> No results found
08:03:48 <merijn> quicksilver: The question was for pseudo random numbers
08:03:50 <aavogt> @hoogle randoms
08:03:50 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
08:03:58 <quicksilver> aavogt: they're random in some particular distribution which doesn't repeat numbers..
08:04:06 <merijn> aavogt: Random uniform selection from a set of numbers gives you random values within that set without repeats
08:04:10 <quicksilver> aavogt: there are plenty of them, although it's not clear what mietek wants.
08:04:42 <tromp> :t Random
08:04:43 <lambdabot> Not in scope: data constructor `Random'
08:05:04 <mietek> merijn: hm, that's a nice approach.
08:05:25 <doserj> quicksilver: list indexing should morally be a function [a] -> Nat -> a. Looking at the [()]~Nat isomorphism, indexing starting at 1 should be canonical. However, than indexing isn't total.
08:05:31 <merijn> mietek: But why do you need 10 million non-repeating pseudo random numbers?
08:05:47 <McManiaC> quicksilver: ah okay, hIsEOF seems to work
08:05:59 <mietek> merijn: for a friend.
08:06:00 <mietek> ;p
08:06:25 <merijn> mietek: Its hard to help people who won't say what they're needing the help for
08:07:40 <aavogt> > M.keys $ M.fromList $ zip [1..] $ repeat ()
08:07:43 <mietek> merijn: I appreciate your help.  Can you assume that the end result is really a list of 10 million pseudo-random numbers?
08:07:43 <lambdabot>   mueval-core: Time limit exceeded
08:08:20 <merijn> mietek: Does it matter what range the numers are in?
08:08:35 <zygoloid> mietek: random from what distribution?
08:08:38 <sm> I've got a stack overflow in a certain situation. What are the recommended techniques to track it down ?
08:08:58 <mietek> merijn: [0 .. 99999999]
08:09:01 <merijn> zygoloid: Apparently any that'll give 10 million unique values
08:09:02 <mietek> zygoloid: uniform is fine.
08:09:09 <sm> have been trying 1. build with -p, to get a heap profile
08:09:18 <sm> but that's hard
08:09:51 <quicksilver> mietek: you can't have a uniform distribution over an infinite set
08:09:51 <ksf> why aren't single-parameter no-method classes derivable?
08:10:00 <quicksilver> mietek: you have to pick some finite set, to get a uniform distribution.
08:10:06 <mightybyte> Has anyone here used HaskellDB or HDBC with Postgres and schemas?
08:10:32 <quicksilver> ksf: sounds non-controversial to me. Make a feature request.
08:10:59 <quicksilver> mietek: perhaps you want a perfect shuffle of [1 .. 10^^7] ?
08:11:15 <merijn> mietek: Easiest solution, (note, I can't do this in haskell, since I'm not fluent enough yet) generate the list [0..99999999], map that into a list consisting of type (Int, Int) by generating a random number for each list entry. Sort the list based on the random number value. Use the original 0..99999999 entry as random numbers
08:11:37 <ksf> quicksilver, but one could argue that I should be writing TH for such stuff
08:11:40 <merijn> Guaranteed to only return the range 0..99999999 and have all numbers unique in random uniform order
08:11:46 <ksf> ...and, in fact, I should.
08:12:05 <merijn> Might be costly, memory wise, though
08:12:38 <ksf> oleg had a brilliant take on shuffling
08:12:45 <mietek> merijn: thanks, I like this idea.
08:13:00 <ksf> should be a google away and as fast as possible
08:13:00 <mietek> quicksilver: it's likely that indeed I do want a shuffle.
08:13:13 <mietek> quicksilver: I didn't mean an infinite set, anyway.
08:13:15 <quicksilver> google for oleg's perfect shuffle then
08:13:21 <quicksilver> mietek: btu you didn't tell us what it was ;)
08:13:35 <mietek> quicksilver: I thought Haskell list notation was clear enough :)
08:13:52 <quicksilver> oh, I didn't see that answer.
08:13:58 <quicksilver> yes, you want a perfect shuffle
08:14:05 <quicksilver> (or, rather, an ideal random shuffle)
08:14:34 <merijn> Shuffling algorithms are hard, let's go shopping!
08:16:00 <fasta> Shuffling algorithms exist for longer than I live, let's read a book!
08:16:25 <fasta> Or just use a library.
08:16:58 <merijn> fasta: Oh, I know I read up on them for a card game. Then decided its far easier to assign each item a random number with and sort based on that.
08:17:23 <fasta> Sorry, something just went wrong in Launchpad.
08:17:30 * fasta hates Ubuntu 
08:18:28 <int-e> merijn: as long as you're aware that you won't get a perfect shuffle that way (because two of the generated random numbers may be equal)
08:18:42 <int-e> s/perfect/perfectly random/
08:18:54 <int-e> or perfectly uniformly random.
08:19:54 <mreh> I've got a perfect shuffle you can look at
08:20:00 <mreh> it's based on finger trees
08:20:08 <merijn> int-e: Random enough for most applications like card games. What are the odds of generating two equal numbers, what are the odds of anyone caring about those odds? :p
08:20:09 <\yrlnry> I once wrote a random permutation generator that worked by constructing the mapping n -> H^n(S), where H was a hashing operation and S a seed string, and then sorting the domain numbers into order by the lexicographic order of the range strings.
08:20:14 <\yrlnry> It was slow, but funny.
08:20:26 <int-e> (on the other hand, we won't get perfectly uniform distribution anyway, with limited state size that's a power of 2)
08:20:43 <\yrlnry> Also I hoped that I might see some sign of nonrandomness it the result, which would be an indictment of H.  But I didn't.
08:22:04 <ksf> ohnoes
08:22:15 <ksf> hlint fails to compile with shared objects
08:22:26 <jmcarthur> snap!
08:22:32 <int-e> The random-shuffle library on hackage uses a simple binary tree for selecting keys. An (ST) array would work better. Oh well.
08:22:34 <ksf> ld: dist/build/CmdLine.dyn_o: relocation R_X86_64_PC32 against `hlintzm1zi6zi16_Pathszuhlint_version1_closure' can not be used when making a shared object; recompile with -fPIC
08:22:49 <jmcarthur> honestly i don't care too much about dynamic linking
08:23:14 * ksf wonders why that happens
08:23:32 <jmcarthur> it saves HD space and, i assume, some memory if you run multiple programs using common libraries, but surely not *that* much space
08:23:35 <ksf> all shared libs have to be compiled as PIC on amd64, and I've compiled a lot, already
08:25:00 <zygoloid> mietek: myself, i think i'd implement the Fisher-Yates shuffle in an STUArray
08:25:15 <int-e> jmcarthur: it increases the chance that (most of) the program you want to run is cached in memory.
08:26:31 <jmcarthur> int-e: ah that's a good point
08:26:40 <jmcarthur> i wonder how often that happens in practice
08:27:07 <jmcarthur> or at least potentially, given that i only have static builds right now
08:27:23 <dankna> So I'm iterating through an IOArray of about a million cells and mutating each one, and it's taking about fifteen seconds on my machine.
08:27:32 <dankna> I would like it to take less.  Can anyone suggest strategies? :)
08:27:59 <dankna> I got some help with this from someone here yesterday, but.
08:28:16 <tromp> try hpaste your code
08:28:35 <dankna> sure.  it's a medium-sized program, but I'll paste the iteration itself.
08:29:11 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17110#a17110
08:29:12 <quicksilver> the very latest GHC has a GC change which makes large mutable arrays faster, dankna
08:29:18 <quicksilver> that may not be a suitable solution for you though.
08:29:20 <dankna> oh!
08:29:25 <dankna> well, yes, I'm fine with upgrading
08:29:41 <dankna> my distribution is likely to be primarily as a binary
08:29:51 <dankna> what's the change exactly?  mostly out of curiosity
08:29:56 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/650
08:30:01 <quicksilver> dankna: all details thereing :)
08:30:05 <dankna> looking, thanks :)
08:30:06 <quicksilver> I don't think it made 6.12 though
08:30:25 <dankna> hmmmm
08:30:53 <dankna> so if this is the problem I'm hitting, I should see my program burning a lot of time in GC rather than in my code
08:30:53 <\yrlnry> I'm running GHC 6.10.4 under Ubuntu linux, and it seems I don't have Control.Monad.Random.  I can't find the Ubuntu package that contains it, and I don't know what to ask cabal to install.  What should I do?
08:30:59 <quicksilver> dankna: yes.
08:31:19 <dankna> I'm, uh, not sure how to check that that's the case though.  I imagine it's some +RTS option or other, let me look at that.
08:31:37 <\yrlnry> Aha.  "cabal list random"
08:32:10 <quicksilver> +RTS -sstderr maybe?
08:32:12 <lispy> \yrlnry: http://hackage.haskell.org/package/MonadRandom
08:32:13 * quicksilver always forgets
08:32:23 <\yrlnry>   lispy: Yes, found it.  Thanks.
08:32:25 <dankna> hmm, posssibly
08:32:33 <lispy> \yrlnry: :)
08:33:53 <lispy> ?hoogle Control.Monad.Random
08:33:53 <lambdabot> package random
08:34:01 <lispy> oh, cool, that's another way to get it
08:34:13 <lispy> But, that list seems to be incomplete
08:35:10 <dankna> hmm, gonna take me a moment - it looks like that data is written on exit, and I actually can't quit my program right now because it's a GUI program and this computation locks it up completely.  so I need to hardcode an exit into it.
08:36:56 <dankna> ah good, that did it
08:37:44 <dankna> yeah, I'm seeing 36% of my elapsed time spent in GC...
08:37:50 <dankna> hmm
08:38:10 <dankna> which is worryingly low, actually, let me try commenting out the resource-loading that I suspect might be throwing that number off....
08:38:20 <mreh> > take 5 ([1..5]++6)
08:38:21 <lambdabot>   No instance for (GHC.Num.Num [t])
08:38:21 <lambdabot>    arising from the literal `6' at <inter...
08:38:27 <mreh> > take 5 ([1..5]++[6])
08:38:28 <lambdabot>   [1,2,3,4,5]
08:38:40 <mreh> would that be evaluated lazily?
08:38:49 <mreh> I'm guessing no
08:38:54 <dankna> here we go.  NOW it's 96%.  thanks, quicksilver.
08:38:55 <mmaruseacph2> > take 5 ([1..5]++[undefined])
08:38:56 <lambdabot>   [1,2,3,4,5]
08:39:02 <mmaruseacph2> which means that yes
08:39:02 <mmaruseacph2> :D
08:39:27 <mmaruseacph2> > take 5 ([1..4]++[undefined]++[6])
08:39:28 <lambdabot>   [1,2,3,4,* Exception: Prelude.undefined
08:39:34 <mreh> yeah
08:39:58 <hzap> > take 5 ([1..5] ++ undefined)
08:39:59 <lambdabot>   [1,2,3,4,5]
08:40:16 <mreh> ++ just takes from the first until empty doesn't it
08:40:22 <mreh> @src append
08:40:22 <lambdabot> Source not found. You type like i drive.
08:40:27 <mreh> @src (++)
08:40:28 <lambdabot> []     ++ ys = ys
08:40:28 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:40:28 <lambdabot> -- OR
08:40:28 <lambdabot> xs ++ ys = foldr (:) ys xs
08:42:45 <quicksilver> dankna: Hah. Well that kind of proves where the problem is I guess.
08:43:05 <\yrlnry> How can I tell Cabal that I want to maintain a Haskell library directory under /home/mjd/lib/haskell and it should install everything there?
08:43:26 <dankna> well, reading that ticket, it looks like I can expect about a factor of five performance increase from the upgrade...
08:44:05 <mreh> > take 5 ([1..5] ++ undefined ++ [6..10])
08:44:06 <lambdabot>   [1,2,3,4,5]
08:44:14 <mreh> right associative too then
08:44:17 <Saizan> \yrlnry: see ~/.cabal/config
08:44:27 <mreh> oh, you already did that
08:44:30 <\yrlnry> Saizan:  thanks.
08:47:06 <mreh> doesn't the right associativity of (++) make it slower when you want to evaluate the whole expression?
08:47:11 <zygoloid> mreh: you'd get that result no matter whether (++) was left- or right-associative since it's an associative operator
08:47:50 <zygoloid> no, the right-associativity of (++) makes it faster. :)
08:47:51 <solrize> bah
08:47:53 <solrize> sorry
08:48:03 <dozu> hi all
08:48:07 <mreh> zygoloid: yeah, you're right
08:48:29 <mreh> I managed to get the correct answer for the wrong reasons
08:51:27 <mreh> haskell is FAST
08:52:18 <mreh> classmates were looking at my GA saying, "yeah my algorithm completes a generation in about the same", and I reply, "no that's 100s of generations you're looking at"
08:52:52 <xerox> right on!
08:54:03 <mreh> but that's mostly because none of them would know a binary tree even if I beat them over the head with one
08:54:27 <xerox> eh eh don't use your binary trees for evil, only for good
08:54:49 <jmcarthur> yeah i recall a class i was in where my team was completing in a tenth of a second what the other teams were completing in 15 minutes
08:54:58 <mreh> can we add a binary tree @slap to lambdabot?
08:55:06 <jmcarthur> because we used a nice red black tree for our collection
08:55:10 <mreh> Hahaha
08:55:36 <mreh> I remember the name from algorithm classe
08:55:40 <jmcarthur> and they were using, i presume, arrays, and must have been scanning over each element one at a time or something
08:55:46 <mreh> but the lecturer was SO boring
08:56:21 <jmcarthur> unfortunately, performance wasn't a major part of the assignment
08:56:41 <osaunders> How does Haskell compare to PHP performance-wise, for, say, a CRUD database app with a lot of templating?
08:56:42 <mreh> jmcarthur: preparing you for the real world then was it :D
08:57:12 <jmcarthur> osaunders: haskell will pretty much always beat php for speed, afaik
08:57:25 <jmcarthur> but it might depend on the libraries you use
08:58:13 <mreh> what is PHP written in?
08:58:19 <zygoloid> C i think
08:58:19 <osaunders> C
08:58:24 <mreh> what is PHP?
08:58:40 <osaunders> @google php
08:58:40 <lambdabot> http://php.net/index.php
08:58:41 <lambdabot> Title: PHP: Hypertext Preprocessor
08:58:47 <MissPiggy> Powerful Homogeneous Programming language
08:59:05 <cebewee> mreh: It's a scripting language
08:59:09 <arw> the reference language for everything you can do wrong in scripting languages.
08:59:11 <xerox> PHP is Pidgeon-Hole Principle --- as used on mathoverflow.
08:59:16 * benmachine would call the PH Pretty Hideous
08:59:18 <Vanadium> MissPiggy: More like Homeopathic Programming Language
08:59:38 <mreh> the jury is still out Homeopathy thank you very much
08:59:48 <mreh> out on Homeopathy
09:00:11 <benmachine> 'tisn't
09:00:26 <osaunders> Homeopathy is not #haskell
09:00:32 <mreh> man, just recompiling with -O2 has seen a HUGE increase in performance, practically halved my array indexing times
09:00:53 <jmcarthur> mreh: you should pretty much always use -O2, honestly
09:01:03 <jmcarthur> it's pretty much not worth it not to
09:01:25 <mreh> the wiki says arrays outperform hand optimised C code
09:01:31 <mreh> I can't see that being possible
09:01:54 <jmcarthur> well, certainly not *hand optimized* C code
09:02:10 <jmcarthur> that claim must depend on some threshold of hand optimization
09:02:32 <jmcarthur> where does the wiki say that?
09:02:46 <mreh> yeah, it seemed pretty bananas to say that, but i suppose it is referring to a specific problem
09:03:24 <mreh> it's talking about nseive
09:03:40 <mreh> nsieve*
09:03:59 <burp> it's faster than hand optimized assembler ;)
09:04:01 <mreh> http://www.haskell.org/haskellwiki/Performance/Arrays
09:04:08 <jmcarthur> burp: *sigh*
09:04:16 <\yrlnry> I'm still having trouble getting cabal to set up my private lib directory the way I want.  I found the "install-dirs user" section of .cabal/config, and set prefix: and libdir:.  But there's also a "libsubdir: $pkgid/$compiler" that I think I don't want.  cabal is instaling the module under .cabal/lib/MonadRandom-0.1.4/ghc-6.10.4/Control/Monad/Random, and I think I want it under .cabal/lib/Control/Monad/Random.
09:04:17 <Vanadium> All my code is faster than hand-optimized assembler
09:04:25 <Vanadium> mainly because I utterly suck at assembler
09:04:41 <mreh> Vanadium :)
09:04:42 <\yrlnry> But commenting out libsubdir: doesn't change cabal's behavior, and neither does making libsubdir: empty.
09:05:04 <\yrlnry> I can't find any docs either.
09:05:19 <\yrlnry> Does anyone have suggestions?  A pointer to the manual would suit me fine at this stage.
09:06:38 <doserj> \yrlnry: libsubdir: $libdir
09:07:00 <mauke> my next try would be libsubdir: .
09:07:01 <benmachine> \yrlnry: that sounds dangerous, I'm pretty sure there are libraries that are going to conflict
09:07:16 <benmachine> (if you leave out pkgid)
09:07:20 <mreh> I remember hand optimising assembler for the memory read write operations
09:07:21 <\yrlnry> doserj:  Aha!  Thanks.
09:07:29 <doserj> and yes, listen to benmachine
09:08:13 <osaunders> Does anyone know of a Amazon SimpleDB library for Haskell?
09:08:14 <\yrlnry> benmachine:  Okay, but I want to :set -i/home/mjd/.cabal/lib in my .ghci file and have ghci search for libraries.  I have the .ghci setting in, but it's not finding the library I just installed, and it reports not looking in the sub-sub-directory that cabal installed to.
09:08:56 <\yrlnry> Hmm, where *is* Random.hs?
09:09:26 <doserj> \yrlnry: you want the *source* to be installed there?
09:09:32 <\yrlnry> Yes.
09:09:44 <\yrlnry> Ahh, it's all  becoming clearer now.
09:10:04 <doserj> \yrlnry: well, that's a totally different thing, then, and nothing to do with cabal
09:10:11 <doserj> cabal doesn't install source
09:10:38 <\yrlnry> Okay.  Do I do it manually, or what?  How do people normally manage this?
09:10:49 <\yrlnry> I'd be glad to do the thing everyone else does, but I don't yet know what it is.
09:12:02 <doserj> not many have the need to install the source of every package they install
09:12:21 <doserj> just unpack the tarball where it is convenient for you
09:12:52 <\yrlnry> Okay.  Backing up a couple of steps, I find that my system lacks Control.Monad.Random.  What should I do to remedy this?
09:13:20 <benmachine> why do you need it?
09:13:22 <benmachine> @hoogle Control.Monad.Random
09:13:22 <lambdabot> package random
09:13:24 <doserj> for the library, just cabal install MonadRandom
09:13:36 <\yrlnry> doserj:  that's what I did, and that's how I got where I am now.
09:13:48 <benmachine> what's the problem now?
09:13:59 <\yrlnry> ghci says:     Could not find module `Control.Monad.Random': ...
09:14:18 <doserj> \yrlnry: what were you trying to do?
09:14:23 <benmachine> what does it say after that?
09:14:30 * hackagebot upload: event-list 0.0.10.1 - Event lists with relative or absolute time stamps (HenningThielemann)
09:14:59 <\yrlnry> benmachine:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17115
09:15:47 <ksf> control-monad-exception truly rocks
09:15:55 <\yrlnry> doserj:  I'm sorry, I don't understand your question.  I'm trying to write a Haskell program that uses some features normally provided by Control.Monad.Random.  Since ghci reported that it couldn't find that module, I tried to use cabal to install it.  But the problem persisted; it seemed to me that cabal had not installed the module in the place that ghci was looking for it.
09:16:34 <mauke> I can't reproduce this problem
09:16:42 <mauke> the file loads fine after "cabal install MonadRandom"
09:16:54 <mauke> do you have multiple ghcs?
09:17:13 <mauke> or hmm. does ghci have/need a --user flag?
09:17:20 <ksf> nope
09:17:21 <\yrlnry> Mauke: I suppose it's possible.  Where does MonadRandom get installed when you do it?
09:17:30 * hackagebot upload: numeric-prelude 0.1.3.1 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
09:17:40 <\yrlnry> mauke:  I give ghci a -i/home/mjd/lib/haskell flag.
09:17:54 <mauke> \yrlnry: it doesn't really matter where it's installed
09:18:03 <ksf> by default, cabal installs in ~/.cabal
09:18:03 <\yrlnry> How does ghci find it then?
09:18:04 <mauke> ghc uses a package registry to find the lib files
09:18:17 <ksf> and that registry lives in ~/.ghc
09:18:22 <mauke> what does 'ghc-pkg list MonadRandom' say?
09:18:38 <mauke> but to answer your question, mine is in /home/mauke/usr/local/lib/MonadRandom-0.1.4/ghc-6.10.2
09:18:54 <\yrlnry> /home/mjd/.ghc/i386-linux-6.10.4/package.conf: MonadRandom-0.1.4
09:19:01 <\yrlnry> (whitespace elinded)
09:19:08 <doserj> \yrlnry: and what does ghc-pkg describe MonadRandom say?
09:19:30 <mauke> whoa, a whole lot of stuff
09:19:45 <\yrlnry> doserj:  It describes it and mentions the library-dir that cabal put it in.
09:20:06 <\yrlnry> quitting ghci and rerunning it fixed the problem.
09:20:17 <\yrlnry> Thanks very much everyone; I did not know about the package registry.
09:20:20 <mauke> ah
09:20:39 <mauke> there are two of them, one for "system" packages and one for "user" packages
09:20:58 <mauke> my setup only uses "system" packages because my ghc is installed in ~
09:21:29 <\yrlnry> Well, that was fun.  Yak shaving.
09:22:46 <\yrlnry> Someone should archive this discussion as a useful example of how you get the wrong answers if you ask the wrong questions.
09:23:01 <\yrlnry> I asked about six.
09:23:04 <doserj> you need an example for that?
09:23:25 <mauke> hah, most people can do it naturally!
09:23:49 <\yrlnry> I need an example for everything.
09:23:58 <\yrlnry> I have very little capacity for abstract thought.
09:24:25 <mauke> ... that's why you wrote a book about higher-order programming, right?
09:24:37 <\yrlnry> A book *full of examples*.
09:26:09 <doserj> http://www.brainyquote.com/quotes/quotes/c/charlesbab141832.html
09:27:31 <\yrlnry> Grr.   The Functor instance for (a, b) is weird.
09:27:45 <\yrlnry> Who decided that it should map only over b?
09:27:46 <MissPiggy> what
09:27:52 <Saizan> it's the only possible one
09:27:59 <MissPiggy> \yrnlnry I want to invent some syntax
09:28:02 <mauke> \yrlnry: the shape of the type
09:28:17 <MissPiggy> (\x -> (a, x)) :: * -> *
09:28:20 <\yrlnry> Oh, right.
09:28:29 <MissPiggy> in haskell you have to write it like
09:28:30 <MissPiggy> (,) a
09:28:33 * hackagebot upload: midi 0.1.5 - Handling of MIDI messages and files (HenningThielemann)
09:28:34 <\yrlnry> Yes, carry on.  I was confused.
09:28:36 <MissPiggy> but I think mine is clearer
09:28:39 <zygoloid> \yrlnry: i got a book of edited highlights of rec.humor.funny for christmas and there was a posting by you in it. :)
09:28:55 <\yrlnry> zygoloid:  was it the one about which letters are not flags to ls?
09:29:01 <MissPiggy> so you can make (\x -> (a, x)) :: * -> * a functor, and you could actualyl make (\x -> (x, b)) :: * -> * one too
09:29:03 <zygoloid> yeah, i think so :)
09:29:05 <MissPiggy> it's just that you can't in haskell
09:29:18 <MissPiggy> you would have to make a newtype or somethingg
09:29:30 <ksf> \yrlnry, bifunctor?
09:29:39 <Saizan> MissPiggy: do you know how to extend typeclass resolution to cope with the latter?
09:29:53 <ksf> http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/Control-Bifunctor.html
09:29:55 <MissPiggy> Saizan I imagine it would be undecidible
09:30:01 <\yrlnry> zygoloid:  the really funny part of that post is that I wrote it on a dare.  Someone was complaining that all his rec.humor.funny submissions were rejected, and I taunted him, saying it was easy to get accepted, you just had to pander to the audience.  "A unix weenie joke with a Monty Python reference ought to do it," I said.
09:30:09 <MissPiggy> I haven't thought about it very much though
09:30:35 <\yrlnry> ksf:  Nah, I was just trying to sleaze out the function \(a,b) -> (a-1, b-1) because I'm incredibly lazy.
09:30:41 <zygoloid> \yrlnry: sounds like my copy of the book needs a pencilled-in footnote :)
09:30:48 <zygoloid> \yrlnry: pred *** pred
09:30:53 <\yrlnry> NO ARROWS
09:30:53 <mauke> join (***)
09:30:56 <zygoloid> ;(
09:31:04 <mauke> how can you function without arrows?
09:31:05 <MissPiggy> this isn't arrows
09:31:08 <MissPiggy> look
09:31:13 <ksf> > ap (-1) (1, 2)
09:31:14 <lambdabot>   No instance for (GHC.Base.Monad ((,) t))
09:31:14 <lambdabot>    arising from a use of `Control....
09:31:15 <MissPiggy> (f *** g) (x,y) = (f x, g y)
09:31:18 <MissPiggy> no arrows....
09:31:23 <zygoloid> \yrlnry: don't think of it as arrows, just as a combinator which coincidentally generalizes :)
09:31:29 * \yrlnry chuckles.
09:31:44 <ksf> what the hell am I thinking
09:31:49 <ksf> :t bimap
09:31:50 <lambdabot> Not in scope: `bimap'
09:31:52 <ksf> wut?
09:32:59 <pumpkin> go to category-extras :P
09:33:08 <zygoloid> @type pred Data.Graph.Inductive.Query.Monad.>< pred
09:33:09 <lambdabot> Couldn't find qualified module.
09:33:11 <zygoloid> :(
09:33:17 <zygoloid> @hoogle Data.Graph.Inductive.Query.Monad
09:33:18 <lambdabot> module Data.Graph.Inductive.Query.Monad
09:34:52 <\yrlnry> I think my most frequent mistake so far has been writing something like   return h:t   and then puzzling over the type error.
09:35:42 * mauke repeats: spaces around operators
09:35:57 <aavogt> look at the error location before the type error
09:36:04 <kmc_> yeah, the syntactic treatment of "return" is different from most languages
09:36:14 <doserj> use return$ instead :)
09:36:21 <mauke> s/(?=treatment)/non-/ :-)
09:36:24 <\yrlnry> I just wrote a shuffle function with type  RandomGen g => [a] -> Rand g [a].  I want to run it, but ghci does not know which instance of RandomGen to use.  How do I specify one?
09:36:26 <kmc_> well sure
09:36:36 <kmc_> put a type signature
09:36:41 <\yrlnry> Yes, but where and how?
09:36:54 <kmc_> myThing [1,2,3] :: Rand StdGen [Int]
09:36:57 <\yrlnry> shuffle [...]  :: Rand StdGen [a]
09:37:01 <\yrlnry> Yes, thanks.
09:37:15 <mauke> but you have to supply a 'g' when you run the thing anyway
09:37:25 <knobo> Can make programs for Nokia N900 with haskell?
09:37:43 <ksf> thou shalt not use return but import Control.Applicative and use pure.
09:38:10 <kmc_> knobo: i was wondering that ;)  GHC can output ARM binaries, via C
09:38:28 <kmc_> there are some people doing iPhone dev in Haskell; they have GHC patches that might be applicable for N900 as well
09:38:52 <\yrlnry> If I omit the standard definitions of >>= and return, and define them myself, will "do" notation use my definitions, or the standard ones?
09:39:10 <kmc_> \yrlnry: it always uses Prelude.(>>=), unless you enable the NoImplicitPrelude extension
09:39:18 <\yrlnry> Okay, thanks.
09:39:56 <\yrlnry> And then I have to define my own Prelude.(>>=)?
09:40:12 <kmc_> no, it uses whichever (>>=) is in scope
09:40:18 <mauke> Prelude.(>>=) is a syntax error :-|
09:40:26 <kmc_> right, i can never remember how to qualify operators
09:40:30 <kmc_> anyway, the ghc manual knows more
09:40:31 <benmachine> (Prelude.>>=)
09:40:41 <\yrlnry> Okay, another project for another day.
09:40:42 <benmachine> how obvious and not at all confusing
09:40:47 <kmc_> > 2 `Prelude.+` 3
09:40:48 <lambdabot>   <no location info>: parse error on input `Prelude.+'
09:40:54 <benmachine> > 2 Prelude.+ 3
09:40:55 <mauke> > 2 Prelude.+ 3
09:40:55 <lambdabot>   5
09:40:56 <lambdabot>   5
09:40:59 <kmc_> woah wtf
09:41:08 <benmachine> that is the correct response :P
09:41:08 <\yrlnry> Funny.
09:41:18 <kmc_> > 2 `(Prelude.+)` 3
09:41:19 <lambdabot>   <no location info>: parse error on input `('
09:41:27 <kmc_> > 2 `(+)` 3
09:41:27 <lambdabot>   <no location info>: parse error on input `('
09:41:29 <kmc_> :(
09:41:54 <mauke> operator ::= ` IDENTIFIER `
09:42:15 <dylan> heh
09:42:35 <kmc_> > let  = foldr in  (+) 0 [1,2,3]
09:42:36 <lambdabot>   6
09:42:40 <mauke> > (succ Prelude.. pred) 0
09:42:41 <lambdabot>   Not in scope: `Prelude..'
09:43:05 * mauke looks at Cale 
09:43:07 <dylan> Zephyrus: don't I know you from another channel?
09:44:06 <Zephyrus> dylan: As far as I remember we've never met each other ;)
09:44:50 <\yrlnry> Does Haskell have a restriction like SML does that you are not allowed to mix alphanumerics and non-alphanumerics in the same identifier?
09:45:00 <benmachine> > let foo9 = 3 in foo9
09:45:01 <lambdabot>   3
09:45:06 <benmachine> wait that's not what you asked
09:45:12 <\yrlnry> Right.
09:45:17 <benmachine> > let foo_ = 3 in foo_
09:45:19 <lambdabot>   3
09:45:24 <mauke> \yrlnry: yes
09:45:28 <\yrlnry> "_" is alphabetic.
09:45:31 <\yrlnry> mauke:  thanks.
09:45:36 <benmachine> only if you have a strange alphabet :P
09:45:39 <mauke> a+b is three tokens
09:45:42 <kmc_> \yrlnry: yes.  non-alphanum symbols are used for infix operators
09:45:59 <\yrlnry> I just tried  "let ab-c = 1" and got a very funny surprise .  It rebound the (-) operator to always return 1.  :)
09:46:04 <kmc_> yes :)
09:46:09 <mauke> > let 2 + 2 = 5 in 2 + 2
09:46:11 <lambdabot>   5
09:46:24 <\yrlnry> So how does it decide that   is alphanumeric?
09:46:30 <kmc_> unicode says so
09:46:32 <danblick> that's sick...
09:46:34 <\yrlnry> Okay.
09:46:36 <mauke> > isAlpha ''
09:46:37 <lambdabot>   True
09:46:45 * hackagebot upload: haskore 0.1.0.1 - The Haskore Computer Music System (HenningThielemann)
09:46:45 <kmc_> > all isAlpha ""
09:46:46 <lambdabot>   True
09:47:00 <kmc_> > isAlpha ''
09:47:00 <lambdabot>   False
09:47:05 <benmachine> > isAlpha '_'
09:47:07 <lambdabot>   False
09:47:15 <kmc_> > isAlpha ''
09:47:16 <lambdabot>   True
09:47:17 <mauke> % perl -wle 'print shift =~ /^\w+$/' 
09:47:18 <mauke> 1
09:47:31 <\yrlnry> Sure, I know about the Unicode properties database.
09:47:40 <p_l> danblick: actually,  is alphanumeric - it's based on alphabetical script afterall
09:47:42 <mauke> \yrlnry: does ' count as alphanumeric too?
09:47:42 <\yrlnry> kmc's answer was sufficient.
09:47:42 <kmc_> > isAlpha ''
09:47:43 <lambdabot>   False
09:48:01 <\yrlnry> mauke:  In SML and Haskell it does.
09:48:08 <p_l> > isAlpha ''
09:48:11 <lambdabot>   <no location info>:
09:48:13 <lambdabot>      lexical error in string/character literal at chara...
09:48:22 <danblick> p_l: i was referring to this thing: > let 2 + 2 = 5 in 2 + 2
09:48:24 <idnar> > isAlpha '\''
09:48:25 <lambdabot>   False
09:48:35 <benmachine> @let  = [1 ..]
09:48:36 <lambdabot>  <local>:19:0: Not in scope: data constructor `'
09:48:36 <idnar> apparently unicode doesn't think so
09:48:36 <p_l> danblick: ah, I guess context error ;-)
09:48:38 <\yrlnry> > chr 67
09:48:39 <lambdabot>   'C'
09:48:40 <benmachine> aww :(
09:48:41 <glguy> p_l, That looked more like a string ("") and less like a char ('')
09:48:43 <p_l> > isAlpha ""
09:48:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:48:45 <lambdabot>         against inferred type...
09:48:49 <xerox> > generalCategory ''
09:48:50 <kmc_> varid ::= (small {small | large | digit | ' })
09:48:50 <lambdabot>   MathSymbol
09:48:51 <idnar> danblick: it's a bit of a silly definition, though
09:48:52 <p_l> glguy: Haven't used Haskell lately
09:48:52 <xerox> :)
09:48:57 <idnar> > let 2 + 2 = 5 in 3 + 4
09:48:57 <\yrlnry> > fmap chr [0 .. 65535]
09:48:58 <lambdabot>   * Exception: <interactive>:1:153-161: Non-exhaustive patterns in function +
09:48:58 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
09:49:07 <kmc_> > isUpper ''
09:49:08 <lambdabot>   True
09:49:40 <p_l> and I kinda got out of use with 'a' vs. "a" (being more used to #\a vs. "a")
09:50:00 <kmc_> data  where { Z :: ; S ::  ->  }
09:50:04 <\yrlnry> :filter isAlpha $ map chr [0 .. 65535]
09:50:07 <benmachine> heh
09:50:08 <\yrlnry> > filter isAlpha $ map chr [0 .. 65535]
09:50:09 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
09:50:15 <temoto> p_l, #\a is which syntax?
09:50:15 <benmachine> that is an acceptible compromise
09:50:28 <temoto> p_l, perl?
09:50:28 <mauke> \yrlnry: don't need map/chr
09:50:29 <benmachine> > map text . filter isAlpha $ map che [0 ..]
09:50:30 <lambdabot>   Not in scope: `che'
09:50:31 <mauke> > ['\0' ..]
09:50:32 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
09:50:33 <benmachine> > map text . filter isAlpha $ map chr [0 ..]
09:50:33 <kmc_> it's somewhat common practice to do things like "let x' = ... use x here..."
09:50:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:50:34 <lambdabot>         against inferred ty...
09:50:40 <kmc_> but this has cost me several weeks of pointless bughunting in the past
09:50:47 <kmc_> so i recommend against it ;P
09:50:54 <kmc_> x and x' look very similar and will probably have the same type
09:51:00 <\yrlnry> @type isAlpha
09:51:01 <lambdabot> Char -> Bool
09:51:04 <p_l> temoto: # is reader-macro-dispatch character, \ is char quoting selector, 'a' is data. And that's Common Lisp :)
09:51:09 <\yrlnry> :type chr
09:51:12 <benmachine> > text . filter isAlpha $ map chr [0 ..]
09:51:13 <lambdabot>   * Exception: Prelude.chr: bad argument
09:51:14 <\yrlnry> @type chr
09:51:15 <lambdabot> Int -> Char
09:51:16 <benmachine> :(
09:51:21 <\yrlnry> mauke:  why not?
09:51:22 <mauke> \yrlnry: lambdabot wants :t or @type, not :type
09:51:26 <benmachine> > text . filter isAlpha $ map chr [0 .. maxBound]
09:51:27 <lambdabot>   * Exception: Prelude.chr: bad argument
09:51:33 <mauke> \yrlnry: because you can just say ['\0' ..]
09:51:36 <temoto> p_l, thanks for knowledge :)
09:51:36 * benmachine confused
09:51:38 * p_l doesn't touch perl, he gets lost
09:51:38 <\yrlnry> Oh, right!
09:51:40 <\yrlnry> Thanks.
09:52:00 <benmachine> > text . filter isAlpha $ ['\0' ..]
09:52:02 <lambdabot>   ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz...
09:52:08 <\yrlnry> But ['\0' .. ] is actually finite, not infinite, right?
09:52:11 <benmachine> yeah
09:52:15 <mauke> > length ['\0' ..]
09:52:16 <kmc_> > text . drop 200 . filter isAlpha $ ['\0' ..]
09:52:16 <lambdabot>   1114112
09:52:17 <lambdabot>   ...
09:52:21 <kmc_> > text . drop 400 . filter isAlpha $ ['\0' ..]
09:52:23 <lambdabot>   ...
09:52:32 <kmc_> > text . drop 800 . filter isAlpha $ ['\0' ..]
09:52:34 <lambdabot>   ...
09:52:36 <benmachine> is lambdabot cutting off a unicode mid-thing there?
09:52:39 <mauke> yes
09:52:58 <\yrlnry> Okay, I better get back to work.  Thanks everyone for help.
09:53:00 <pikhq> \yrlnry: Yes. [foo ..] for any type is only sequential if the type is sequiential.
09:53:10 <pikhq> Erm. s/only sequential/only infinite/
09:53:23 <pikhq> > length ([0 ..] : Int)
09:53:24 <lambdabot>   Not in scope: data constructor `Int'
09:53:28 <pikhq> > length ([0 ..] :: Int)
09:53:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:53:29 <lambdabot>         against inferred type ...
09:53:31 <\yrlnry> I wasn't sureYes, but I didn't know if the character type was infinite.
09:53:38 <pikhq> > length ([0 ..] :: [Int])
09:53:40 <pikhq> Darned thinko.
09:53:42 <lambdabot>   mueval-core: Time limit exceeded
09:54:05 <pikhq> \yrlnry: Unicode is finite. Thus, Char is finite.
09:54:08 <\yrlnry> It would be really funny if it printed  there.
09:54:16 <mauke> > maxBound :: Char
09:54:17 <lambdabot>   '\1114111'
09:54:42 <zygoloid> > length [maxBound :: Int ..]
09:54:43 <lambdabot>   1
09:54:54 <\yrlnry> mauke:  I still frequently use your delightful JS unicode searcher tool.  Thanks again.
09:55:08 <mauke> you're welcome :-)
09:55:13 <Hunner> > length ['\0' ..]
09:55:14 <lambdabot>   1114112
09:55:52 <\yrlnry> I keep it at http://dl.dropbox.com/u/3649769/unicode.html for public consumption.
09:55:52 <p_l> temoto: # is just a character commonly used in spec to signify "reader macros" (you can call them hooks into parser) so they are easily recognizable (iirc all important, explicitly-used reader-macros in ANSI CL use that)
09:55:59 <zygoloid> > let  = genericLength ([1..] :: [Integer]) :: Nat in 42 < 
09:56:00 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
09:56:00 <lambdabot>    arising from a use of `Data.List.gen...
09:56:09 <kmc_> > text . pure . last . filter isAlpha $ ['\0' ..]
09:56:09 <zygoloid> :(
09:56:10 <lambdabot>   
09:56:18 * mauke keeps it at http://mauke.ath.cx/stuff/javascript/unicode.html
09:56:44 <kmc_> > let  :: Natural;  = succ  in 42 < 
09:56:44 <lambdabot>   Not in scope: type constructor or class `Natural'
09:56:48 <kmc_> > let  :: Nat;  = succ  in 42 < 
09:56:49 <lambdabot>   No instance for (GHC.Enum.Enum L.Nat)
09:56:49 <lambdabot>    arising from a use of `GHC.Enum.su...
09:56:55 <kmc_> > let  :: Nat;  = 1 +  in 42 < 
09:56:56 <lambdabot>   No instance for (GHC.Num.Num L.Nat)
09:56:56 <lambdabot>    arising from the literal `1' at <int...
09:57:02 <kmc_> :(
09:57:09 <xerox> Nats are disappointing.
09:57:20 <kmc_> i like them
09:57:21 <zygoloid> Nat is much more broken than last time I played with it :(
09:58:07 <kmc_> > generalCategory ''
09:58:08 <lambdabot>   OtherSymbol
10:01:14 <Polarina> Is there something standardized for rational numbers?
10:01:19 <kmc_> yes
10:01:49 <kmc_> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Data-Ratio.html
10:02:01 <monochrom> > 4%5 + 1%5
10:02:02 <lambdabot>   1 % 1
10:02:53 <temoto> p_l, thanks for more knowledge :) not that i'm so into lisp, but hooks into parser is a great feature, no doubt.
10:02:57 <Polarina> o.O
10:02:58 <Polarina> Thanks.
10:03:19 <temoto> Polarina! \o/
10:03:29 <mauke> > 4/5 + 1/5
10:03:30 <lambdabot>   1.0
10:03:34 <mauke> > 4/5 + 1/5 :: Rational
10:03:35 <lambdabot>   1 % 1
10:03:55 <kmc_> > map (approxRational (pi :: CReal)) [1 / (2**n) | n <- [0..]]
10:03:56 <lambdabot>   [* Exception: CReal.toRational
10:03:59 <kmc_> :(
10:04:09 <kmc_> > map (approxRational pi) [1 / (2**n) | n <- [0..]]
10:04:09 <lambdabot>   [3 % 1,3 % 1,3 % 1,13 % 4,16 % 5,19 % 6,22 % 7,22 % 7,22 % 7,22 % 7,201 % 6...
10:04:20 <Polarina> lol
10:04:20 <temoto> kmc, CReal? :)
10:04:34 <kmc_> > map (fromRational . approxRational pi) [1 / (2**n) | n <- [0..]] :: [Double]
10:04:35 <lambdabot>   [3.0,3.0,3.0,3.25,3.2,3.1666666666666665,3.142857142857143,3.14285714285714...
10:04:41 <p_l> temoto: Liskell afaik had some support for Lisp-like macros in Haskell, but I'm not sure
10:04:52 <kmc_> temoto: exact representation of computable reals
10:04:52 <temoto> Excelsior! I'm super CReal.
10:05:36 <kmc_> support for uncomputable reals is not yet available
10:05:48 <kmc_> @where CReal
10:05:48 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
10:06:30 <kmc_> "A tolerably efficient and possibly correct implementation of the computable reals using Haskell 1.2."
10:07:49 <temoto> kmc_, it was a South Park episode with Al Gore joke.
10:07:59 <kmc_> okay
10:08:23 <temoto> he said "i'm serial" as in "serious" many times in that episode
10:09:24 <zygoloid> > nub $ map (approxRational pi) [1 / (2**n) | n <- [0..]]
10:09:28 <lambdabot>   mueval-core: Time limit exceeded
10:10:21 <MissPiggy> kmc_ I still have no clue
10:10:28 <MissPiggy> and somehow ubuntu broke so I can't even use it
10:21:25 <zygoloid> > map numerator . (zipWith (-) `ap` tail) . take 32 . nub $ map (approxRational pi) [1 / (2**n) | n <- [0..]]
10:21:27 <lambdabot>   [-1,1,1,1,1,-3,-2,-1,-1,1,-47,-19,-6,-7,-7,-4,-2,-1,-1,1,-1,1,-1,1,-1,1,-2,...
10:23:28 <mlesniak> Anyone knows what happend to Data.Array.Diff? I found some old documentation but it seems it's not in the libraries anymore?
10:25:25 <zygoloid> mlesniak: dunno, but it's probably related to GHC's GC's poor performance on mutable arrays (which i hear will be fixed in 6.14)
10:26:04 <mlesniak> zygoloid, do you have more information (links, etc...) about this for 6.14?
10:26:37 <int-e> mlesniak: http://hackage.haskell.org/trac/ghc/ticket/3370
10:27:00 <mlesniak> int-e, ah, thanks
10:27:10 <int-e> (hmm, so there is a separate package, but it's not on hackage. bad move?)
10:28:41 <mlesniak> yes, that's why I was irritaed, just wasn't there anymore ;)
10:36:02 <FliPPeh> I wonder why I still hang around here. I don't even code haskell anymore!
10:36:35 <mlesniak> FliPPeh, Because even as a non haskeller the community is nice!
10:36:50 <FliPPeh> Yes, the haskell community sure is awesome
10:36:50 <Zao> For the lovely company of lambdabot.
10:37:10 <FliPPeh> I've never experienced better support without getting flamed :)
10:37:55 <FliPPeh> Actually haskell is on my 3-language-schedule
10:38:07 <aavogt> @quote schedule.*1
10:38:07 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
10:38:27 <FliPPeh> One high level (Python), one low level (C) and one functional. Guess which one
10:39:00 <FliPPeh> If only I had time to learn.
10:39:15 <aavogt> @faq can Haskell do all three?
10:39:15 <lambdabot> The answer is: Yes! Haskell can do that.
10:39:34 <FliPPeh> @faq Can Haskell be not Haskell?
10:39:35 <lambdabot> The answer is: Yes! Haskell can do that.
10:40:12 * ksf wants a special syntax for (undefined::WhateverType)
10:40:25 <FliPPeh> > undefined
10:40:26 <lambdabot>   * Exception: Prelude.undefined
10:40:29 <FliPPeh> Haha!
10:40:41 <FliPPeh> mh
10:40:46 <ksf> I'm dead serious
10:40:48 <FliPPeh> Where does Cabal for Linux install by default?
10:40:51 <FliPPeh> $HOME, right?
10:40:54 <aavogt> ksf: let u = undefined
10:40:56 <ksf> ~/.cabal
10:40:59 <aavogt> much nicer :)
10:41:00 <FliPPeh> Alright
10:41:07 <ksf> aavogt, that doesnt' make it perfect
10:41:08 <FliPPeh> I remember it putting stuff EVERYWHERE on windows
10:41:09 <FliPPeh> It was a hell
10:41:28 <ksf> if you call it without --global, that is.
10:42:16 <FliPPeh> And without root
10:42:17 <aavogt> it's sometimes sensible to accept arguments around which are just used as:   blah `asTypeOf` dummy
10:42:18 <FliPPeh> ;x
10:42:23 <hzap> FliPPeh: yeah when I do cabal it puts stuff in at least 3 places (windows)
10:42:24 <ksf> damn those exceptions are so nice I'm actually using them for program control
10:43:43 <FliPPeh> ksf: That's a common idiom in Python
10:44:04 <ksf> those java people always warned me
10:44:28 <FliPPeh> Java? Where you have to use 3 classes to read a file? x
10:44:28 <FliPPeh> ;x
10:44:40 <ksf> ...though we didn't use exceptions for performance reasons, anyway.
10:45:11 <ksf> ...well except to see when an array traversal was done, as java is doing those damn checks anyway.
10:45:13 <chrisf> FliPPeh: at least it's not Enterprise Java, where you write 5 classes to use those 3! c+c
10:45:24 <chrisf> c_c~
10:45:32 <FliPPeh> ;x
10:45:41 <FliPPeh> Even C is easier in that regard
10:46:01 <aavogt> are exceptions worse than lazy IO?
10:46:11 <ksf> they're way better
10:46:15 <aavogt> best served together :)
10:46:22 <ksf> ...at least in nonpure code, that is.
10:46:48 <aavogt> right, if you're not going to be deterministic anyways
10:46:54 <ksf> but control-monad-exception, as the name tells us, is monadic, anyway.
10:47:37 <FliPPeh> Why is the haskell compiler so big? :(
10:47:52 <ksf> type checking etc
10:48:24 <ksf> but ghc is actually quite small, compared to say gcc.
10:48:26 <dankna> it's smaller than gcc
10:48:45 <chrisf> that's not saying much.
10:48:50 <chrisf> gcc is obese.
10:49:09 <FliPPeh> gcc takes 46 MB here :/
10:49:15 <FliPPeh> Probably looking at the wrong package
10:49:21 <dino-> And the Java VM is pretty sizable as well. The Standard Edition at least, not sure about the ME things they fling onto mobile phones.
10:49:35 <chrisf> dino-: JavaME is no more.
10:49:45 <dino-> chrisf: Probably just as well.
10:49:46 <chrisf> SE on mobile devices these dats.
10:49:55 <ksf> j2me is way smaller, though I don't know how much, never saw an implementation from the outside
10:50:13 <ksf> the stdlib, compared to j2se is microscopic.
10:50:25 <ksf> er j2ee
10:50:52 <ksf> they also completely left out reflection, which simplifies the vm
10:52:03 <FliPPeh> I've always wondered...
10:52:09 <FliPPeh> Why doesn't cabal offer an unistall method?
10:52:18 <FliPPeh> Python's distutils does the same, why?
10:52:31 <Zao> Deleting files is scary?
10:52:34 <ksf> it's not the most trivial of things
10:53:07 <Zao> cabal ate my homework!
10:53:16 <monochrom> I would say what dons would say. "send patches!"
10:53:47 <Zao> I could imagine awesome things happening due to a lack of quoting or funny package names.
10:53:55 <Zao> Much like the EVE Online boot.ini accident.
10:54:27 <dino-> I wonder if it's not a trivial problem. Something needs to store what files went where like the various installation systems do (rpm, dpkg, pacman, etc..)
10:54:35 <Zao> In which a patcher was slightly botched and removed \boot.ini instead of .\boot.ini or so.
10:54:48 <dino-> And do it across distros, Windows, Mac.
10:54:50 <Zao> If all packages were uniquely installed via cabal in the same ways, it would not be too hard.
10:54:57 <Zao> But still scary.
10:55:05 <nbowler> ksf: my ghc install almost 450 megabytes, whereas my gcc install is 60.  Seems like an unusual definition of "smaller".
10:55:10 <dino-> Notable that CPAN also doesn't uninstall for you.
10:55:19 <ksf> source size, that is.
10:55:45 <ksf> and your gcc doesn't come with as many libs.
10:56:07 <monochrom> A Haskell line is worth a thousand bytes.
10:56:11 <nbowler> if it did come with as many libs, people would probably call it even more bloated.
10:56:59 <FliPPeh> I love haskell.
10:57:02 <FliPPeh> It can't be bloated
10:57:10 <dankna> oops.
10:57:14 <FliPPeh> That's like stuffing pudding in. The more the better.
10:57:29 <chrisf> actually, why is the compiler so big?
10:57:30 <dankna> I was trying to cleanly uninstall all the old versions of ghc I had lying around, leaving only the new one I just built from the snapshot.
10:57:55 <dankna> I removed it too, and now I have no working ghc.  oh well...  I know how to extricate myself from this situation, I'm just irked at myself :)
10:57:55 <chrisf> surely 2M or so ought to be enough for any sensible amount of cod.
10:57:58 <chrisf> code~
10:58:11 <dankna> it would actually be very interesting to look at why it is so big
10:58:21 <dankna> I bet there's nothing that can be done about it, but it would be interesting
10:58:39 <FliPPeh> A general question, how well does Haskell scale when it comes to memory usage?
10:58:59 <chrisf> oh come on, we all used to have disks that couldnt handle a *compiler* being >100M.
10:59:09 <ksf> it scales very good, but has a middleish initial footprint
10:59:51 <Zao> chrisf: My $HOME is three gigs, and that's way more than most get at the department.
11:00:04 <Zao> 500M GHC sucked when I used to have 800M.
11:00:11 <FliPPeh> ;x
11:00:22 <FliPPeh> I have some spare harddrives flying around
11:00:33 <nbowler> ksf: anyway, libHSghc-6.10.4_p.a, which sounds to me like a core part of GHC, is *by itself* bigger than gcc + all its documentation.
11:00:42 <FliPPeh> I started stuffing them in my server
11:01:07 <monochrom> libHSghc-6.10.4_p.a is the profiling version
11:01:13 <chrisf> maybe an investigation is in order.
11:01:36 <monochrom> perhaps kill profiling and get half smaller
11:01:37 <chrisf> but it's a global trend; *everything* is several times bigger than it used to be.
11:01:54 <chrisf> not just ghc ;)
11:02:22 <monochrom> kill inlining, that may get you half smaller too.
11:03:26 <ksf> the executable itself is 24mb. the rest is libraries
11:03:35 <FliPPeh> Why does GHC depend on PERL?
11:03:43 <Zao> FliPPeh: For the Evil Mangler.
11:03:47 <FliPPeh> :o
11:03:48 <ksf> ...including libghc and its .hi files, which amount to a whopping 264M
11:03:58 <Zao> FliPPeh: An awesome Perl script that postprocesses annotated assembly code to optimize stuff :)
11:04:30 <Zao> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
11:04:40 <nbowler> oh yeah, and that 60M for gcc includes C++ and fortran compilers, too.
11:05:00 <monochrom> 14mb after stripping
11:05:29 <ksf> nbowler, add /lib/* and /include/*
11:06:07 <nbowler> ksf: ghc uses my C library, too, so it'd have to count against both.
11:06:10 <monochrom> ghc is statically linked
11:06:18 <dankna> well, at least add /include/* for sure.  /lib/* is debatable.
11:06:32 <edwardk> preflex: xseen luqui
11:06:32 <preflex>  luqui was last seen on freenode/#haskell 1 day, 18 hours, 47 minutes and 34 seconds ago, saying: for HNF you need to evaluate under lambda.  I.e. the leftmost application must have a bound variable on the left
11:06:42 <gwern> ?hackage feed
11:06:43 <lambdabot> http://hackage.haskell.org/package/feed
11:06:44 <ksf> and those includes are way smaller than .hi files, due to .hi files actually containing information
11:07:06 <ksf> ...including compiled code used for cross-module inlining
11:07:12 <monochrom> ghc uses your C lib binary but does not need your *.h files.
11:07:36 <ksf> and it doesn't really need it, either
11:08:24 <ksf> the rts should be fine with the mmap, read, write, open and close syscalls.
11:08:56 <ksf> who wants to reimplement the libc in haskell?
11:09:13 <nbowler> ksf: it also uses a sizeable portion of the math library, afaict.
11:10:32 <Berengal> Continuations are nifty
11:11:46 <djahandarie> Berengal, Continuation Passing Style?
11:12:25 <Berengal> djahandarie: Well, the style itself is incidental. It's the continuations themselves that are interesting
11:12:54 <kmc_> CPS is a way to get continuations in languages that don't have them built in
11:12:58 <kmc_> (which very few do)
11:13:16 <djahandarie> Berengal, so are you talking about the concept or the monad?
11:14:14 <HugoDaniel> :)
11:14:38 <HugoDaniel> i like the fact that haskell is so multidisciplinar when it comes to using other languages, such as C or perl...
11:14:44 <HugoDaniel> all in the name of producing the best result possible
11:14:44 <Berengal> djahandarie: The concept
11:15:26 <lament> C++ is also pretty "multidisciplinar"
11:15:33 * Berengal just made WebCont, the ContT ServerPartT transformer stack
11:15:45 <ksf> lament, as in bdsm, yes.
11:16:11 <kmc_> haskell has a good C FFI
11:16:23 <kmc_> i don't know of any good integration with perl
11:16:42 <gwern> why would 'fs cfg f mbPath = fmap xmlFeedToString $ filestoreToXmlFeed' cfg f mbPath' work but not 'fs = fmap xmlFeedToString  filestoreToXmlFeed'?
11:16:50 <ksf> if you can talk to c you can talk to everything, except c++, of course.
11:17:34 <aavogt> @pl fs cfg f mbPath = fmap xmlFeedToString $ filestoreToXmlFeed' cfg f mbPath
11:17:34 <lambdabot> fs = ((fmap xmlFeedToString .) .) . filestoreToXmlFeed'
11:17:55 <kmc_> (.) composes functions of one argument
11:18:12 <kmc_> @pl \f g x y -> f (g x y)
11:18:12 <lambdabot> (.) . (.)
11:18:24 <ksf> that's the single most annoying think about pointless styl.
11:18:26 <ksf> e
11:18:33 <kmc_> yeah, and there's no standard name for (.) . (.)
11:18:44 <burp> boob operator
11:18:44 <p_l> kmc_: would "boobies" fit?
11:18:47 <kmc_> sure
11:19:07 <kmc_> @quote boob
11:19:08 <lambdabot> (.) says: I am the boob operator!
11:19:08 <ksf> @let (..) = (.) . (.)
11:19:08 <MissPiggy> um
11:19:09 <lambdabot>   Parse error: DotDot
11:19:12 <MissPiggy> (.:)
11:19:14 <lament> why not just (.) (.)
11:19:14 * mauke writes it as (.)(.)(.)
11:19:14 <ksf> there, there.
11:19:32 <kmc_> we're all very mature here
11:20:17 * zygoloid writes it as (fmap.fmap)
11:20:35 <burp> @type (.) . (.)
11:20:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:20:39 <burp> :)
11:24:19 <djahandarie> I fmap.fmap to (.).(.)
11:24:27 * djahandarie couldn't resist
11:24:37 <mauke> I fmap fmap fmap to (.)(.)(.)
11:25:06 <MissPiggy> how should I parse a language with haskell-like application and infix ops?
11:25:15 <LeoD> why is there a Functor requirement in (.) . (.)?
11:25:23 <aavogt> @src (.)
11:25:23 <lambdabot> (f . g) x = f (g x)
11:25:27 <kmc_> because lambdabot use a generalized (.)
11:25:30 <mauke> LeoD: because you can't fmap without a Functor instance
11:25:30 <LeoD> ah
11:25:34 <burp> caleskell
11:25:39 <LeoD> mauke: thought it used the normal (.)
11:25:41 <zachk> can i define infix operators like (v+) ?
11:25:43 <kmc_> :t let (f . g) x = f (g x) in (.) . (.)
11:25:44 <lambdabot> forall t t1 t2 t3. (t1 -> t2) -> (t -> t3 -> t1) -> t -> t3 -> t2
11:25:47 <mauke> :t (P..) P.. (P..)
11:25:48 <lambdabot> Couldn't find qualified module.
11:25:52 <LeoD> kmc_: aye
11:25:59 <mauke> :t (Prelude..) Prelude.. (Prelude..)
11:26:01 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:26:19 <LeoD> got it ;p
11:26:39 <aavogt> zachk: either all have to be symbol characters or qualifiers or regular characters
11:26:42 <MissPiggy> help :(
11:27:02 <mauke> MissPiggy: uh, just do it
11:27:09 <aavogt> so you could   import V;   1 V.+ 2,   or have    1 `vplus` 1
11:27:19 <MissPiggy> mauke awounawdyunfgh
11:27:24 <zygoloid> @karma caleskell
11:27:24 <lambdabot> caleskell has a karma of 1
11:27:30 <zygoloid> caleskell--
11:27:30 <mauke> @karma hascale
11:27:31 <lambdabot> hascale has a karma of 0
11:27:58 <xerox> ?karma Caleskell
11:27:58 <lambdabot> Caleskell has a karma of 0
11:30:11 <MissPiggy> I  don't know how
11:30:36 <zachk> how do i check the associativity and the operator levels of the default numerical operators in haskell?
11:30:50 <aavogt> :i + - / *
11:30:51 <MissPiggy> I should define something like  application :: Parser, which greads at least one thing in a chain like  f x y z w
11:30:58 <MissPiggy> or  f x (y + u) z
11:31:07 <MissPiggy> then make a fixity thing also work... and magic
11:31:13 <aavogt> @type gread
11:31:15 <lambdabot> forall a. (Data a) => String -> [(a, String)]
11:31:36 <aavogt> this gread?
11:31:38 <MissPiggy> I meant
11:31:42 <MissPiggy> greedily reads
11:31:45 <monochrom> MissPiggy: I just use chainl.
11:31:46 <mauke> zachk: http://haskell.org/onlinereport/decls.html#sect4.4.2
11:31:58 <Berengal> http://85.200.142.237:5000/ is currently running `example :: WebCont IO String; example = yieldMessage "Hello" >> yieldMessage "World" >> return "Goodbye"'
11:32:25 <Berengal> Though I haven't implemented sessions yet, so you'll step on eachother's toes
11:32:41 <MissPiggy> okay
11:32:44 <MissPiggy> so I will do this now
11:34:21 <chrisf> am i right in thinking that the Evil Mangler will one day be unnecessary? (if ghc eventually discards the gcc backend)
11:34:51 <monochrom> but ghc cannot eventually discard the gcc backend.
11:34:58 <kmc_> no?
11:35:04 <chrisf> why not?
11:35:10 <monochrom> It is needed for iPhone.
11:35:19 <kmc_> and that could never be fixed?
11:35:22 <monochrom> It is also needed for BSD.
11:35:41 <chrisf> iPhone support is holding ghc back? you have got to be kidding.
11:35:49 <chrisf> c_c
11:36:11 <aavogt> what exactly is being held back by supporting multiple backends?
11:36:29 <kmc_> what's so special about gcc, in particular?
11:36:31 <monochrom> Let's say, I bet 10% probability in the next 5 years we will have native gen for BSD, 0.1% proability for iPhone.
11:36:44 <kmc_> isn't the iPhone unregisterized anyway?
11:36:49 <kmc_> iPhone ghc i mean
11:37:02 <chrisf> from what's been said in the last hour or so, the only reason we have a dep on perl is for EM.
11:37:45 <MissPiggy> chainl doesn't seem greedy >:|
11:37:50 <mauke> plan B: make the mangler non-evil
11:38:00 <chrisf> mauke: haha, yes.
11:38:01 <mauke> there's no requirement that perl code be ugly
11:38:10 <mauke> and by "ugly" I mean HORRIBLE
11:38:14 <MissPiggy> *Syntax> parse term [] "(foobar baz quux)"
11:38:15 <MissPiggy> Right ((V "foobar" :$: V "baz") :$: V "quux")
11:38:15 <MissPiggy> *Syntax> parse term [] "foobar baz quux"
11:38:15 <MissPiggy> Right (V "foobar")
11:38:19 <MissPiggy> how does that make sense at all?
11:38:20 <chrisf> why is it in perl, actually?
11:38:22 <mauke> plan B B: rewrite in haskell
11:38:37 <chrisf> mauke: that was what i was about to ask about ;)
11:39:08 <chrisf> is there some good reason, other than perl's extreme text-munging abilities, why it can't be haskell?
11:39:46 <monochrom> Yes. The good reason is, dons said "send patches!" but no one obeyed.
11:39:50 <Berengal> chrisf: There's already a working perl implementation of it
11:39:51 <chrisf> oh.
11:39:58 <kmc_> it is a good idea to have a backend that produces portable C code (no gcc dependency or evil mangler)
11:40:00 <mauke> Berengal: how do you know it's working?
11:40:09 <kmc_> it is less clear that any effort should go into making that backend fast
11:40:12 <Berengal> mauke: experiments
11:40:15 <kmc_> produce fast code, i mean
11:40:18 <mauke> it's not exactly obvious what it does, or how
11:40:19 <MissPiggy> nobody knows/
11:40:20 <MissPiggy> ?
11:40:24 <MissPiggy> this is totally bizarre
11:40:43 <mauke> MissPiggy: uh, I guess your term parser is broken?
11:40:49 <MissPiggy> application = chainl1 term (do spaces ; return (:$:)) -- that's meant to parse "f x y z"
11:40:54 <kmc_> if it is desired to have fast code via C, a less crufty route would be to compile the C with clang and process the LLVM output at a higher level than string munging
11:40:56 <MissPiggy> as (((f x) y) z)
11:41:01 <MissPiggy> but it just reads f then stops
11:41:06 <monochrom> To sum up, my answer to both threads of current questions is: PEBKAC
11:41:14 <MissPiggy> term = variable <|> parens application
11:41:15 <kmc_> this giving many of the same benefits as the direct LLVM backend
11:41:27 <MissPiggy> oh my god
11:41:29 <MissPiggy> im so stupid
11:41:33 <MissPiggy> it's unbeleivable lol
11:41:36 <MissPiggy> thanks mauke
11:41:45 <mauke> I didn't do anything
11:41:58 <MissPiggy> yeah "it was nothing"
11:42:39 <chrisf> damn... i was foolish enough to actually *read* the EM source.
11:42:59 <nbowler> chrisf: those images will be with you for the rest of your life.
11:43:01 <chrisf> it burns...
11:43:18 <Berengal> Does anybody know if there's session support for happstack somewhere?
11:43:20 <mauke> chrisf: I did that once when it broke under perl 5.10
11:43:30 <mauke> that wasn't a pleasant experience
11:44:33 <Zao> kmc_: A GHC that ran on MSVC, Intel and/or xlC would be nice.
11:44:45 <kmc_> yeah
11:45:02 <kmc_> but it seems difficult and pointless to support post-asm optimization for all of them
11:45:03 <Zao> xlC especially, as building a proper gcc on AIX is FUN.
11:45:09 <kmc_> hehe
11:45:49 <kmc_> i guess icc has ninja codegen because, uh, they designed the processor
11:45:50 <chrisf> Zao: why does building gcc on AIX suck?
11:45:56 <kmc_> so it might be nice to hook into that
11:46:00 <Zao> Most of the recent work towards a dynamic GHC seems to be working in the direction of more dependency on linker semantics though.
11:46:09 <kmc_> C is so close to being a good portable assembler but fails in one or two critical ways
11:46:10 <kmc_> :/
11:46:28 <Zao> chrisf: Easy to misbuild one, as the linker and system headers are a bit "special".
11:46:43 <Zao> The last few times I tried, the resulting blob couldn't link 32-bit code.
11:46:50 <monochrom> mauke: Haha I see the problem too. The test tested parse term. Wrong target to test. Should be parse application.
11:47:10 <chrisf> Zao: sounds like epic failure.
11:47:28 <Zao> chrisf: It's nothing compared to building modern C++ with xlC :)
11:47:31 <chrisf> Zao: or just quirky commercial unix.
11:47:46 <Zao> A compiler that warns about how it couldn't inline something it itself decided to inline.
11:48:01 <Zao> Helpfully printing the full templated symbol name a couple of times per instance.
11:48:15 <Zao> IBM knows how to be verbose.
11:48:25 <chrisf> like only IBM could.
11:48:59 <chrisf> that sounds... dumb.
11:49:22 <chrisf> surely it should only complain if you use some forceinline attribute
11:49:58 <Berengal> chrisf: But that makes sense. Can't have sense in our programs, now can we? Especially compilers
11:50:07 <kmc_> @ghc
11:50:07 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
11:50:13 <kmc_> @ghc
11:50:13 <lambdabot> ghc says: For basic information, try the `--help' option.
11:50:25 <kmc_> @. elite ghc
11:50:25 <lambdabot> 9hc 54YS: bINdIngs IN h$-bOo+ fI|Es ar3 not a1|0w3D
11:50:28 <monochrom> but I want fortran information
11:51:08 <FliPPeh> With the exception of the Data.Binary module, which options do I have to read in binary data?
11:51:23 <kmc_> bytestring io
11:51:36 <monochrom> "For cobol information, try the `--display help to stdout' option"
11:52:42 <FliPPeh> kmc_: So say I have a bytestring of [0x45, 0x23], how'd I convert that to the equivalent of a "short" or "unsigned short" in C?
11:53:11 <kmc_> ah you want to translate it not just read it in?
11:53:14 <monochrom> 0x45*256 + 0x23 :)
11:53:18 <mauke> FliPPeh: big endian or little endian?
11:53:28 <kmc_> if you want the actual direct equivalent of C (on your platform), use the stuff in Foreign
11:53:29 <FliPPeh> Not important for now ;x
11:53:38 <mauke> then what monochrom said
11:53:38 <FliPPeh> I just want theorethical knownledge
11:53:46 <MissPiggy> data Term op = V String | Op (Maybe op) (Term op) (Term op) deriving Show
11:53:48 <MissPiggy> hw about that?
11:54:00 <MissPiggy> data Arithmetic = Plus | Minus | Times
11:54:05 <MissPiggy> then you can do Term Arithmetic,
11:54:10 <MissPiggy> and Op Nothing means function application
11:55:17 <kmc_> FliPPeh: you can get access to the guts of a ByteString via a ForeignPtr, and use peek from Foreign.Storable
11:56:02 <kmc_> this is the low-level, unsafe, and fast way to do it
11:57:24 <edwardk> MissPiggy: why Maybe op? why not just op? and pass it Maybe op if you want the maybe =)
11:57:50 <MissPiggy> well function application isn't an op
11:57:55 <mauke> why not?
11:58:13 <edwardk> MissPiggy: data Arithmetic = Plus | Minus | Times | Ap =)
11:58:52 <monochrom> Ap is fundamental. Plus, Minus, Times are plugin.
11:59:01 <gwern> is there any shorter way of saying:
11:59:02 <edwardk> flattens the domain and gives you one fewer place for a bottom to hide
11:59:03 <gwern>          extract x = case x of
11:59:07 <gwern>                       Modified n   n
11:59:10 <gwern>                       Deleted n   n
11:59:13 <gwern>                       Added n   n
11:59:19 <gwern> I had hoped '_ n -> n' might work, but no dice
11:59:29 <mauke> gwern: what's the type of x?
11:59:35 <monochrom> Adding ! will flatten the domain if you just want flatten
11:59:36 <gwern> mauke: FilePath/String
11:59:42 <edwardk> gwern: building a comonad/copointed?
11:59:45 <gwern> in all 3 cases
11:59:51 <gwern> edwardk: I've no idea
11:59:53 <MissPiggy> *Syntax> parse (term arithmetic) [] "e*(k (g x y) f+3)"
11:59:53 <MissPiggy> Right (Op Mul (V "e") (Op Add (Op Ap (Op Ap (V "k") (Op Ap (Op Ap (V "g") (V "x")) (V "y"))) (V "f")) (V "3")))
11:59:55 <mauke> gwern: Strings don't have constructors called Modified/Deleted/Added
12:00:07 <MissPiggy> what the hell that actually worked
12:00:21 <gwern> mauke: the type is 'Change = Modified FilePath | Deleted FilePath | Added FilePath' iirc
12:00:24 <gwern> *data
12:00:32 <edwardk> ah
12:00:35 <mauke> oh wait, you don't desugar operators?
12:00:48 <zygoloid> gwern: if you can change it to data Change = Modified { extract :: FilePath } | Deleted { extract :: FilePath } | Added { extract :: FilePath } ...
12:00:59 <mauke> I'd parse "a + b" as Ap (Ap (V "+") (V "a")) (V "b")
12:01:02 <edwardk> clearly it should have been. data Change = Modified | Deleted | Added, and data Changed a = Changed Change a
12:01:03 <edwardk> =)
12:01:13 <gwern> zygoloid: I'd much rather not touch FileStore right now
12:01:45 <zygoloid> i don't believe that should break any existing code which doesn't use the name 'extract' (unless you derive Read or Show...)
12:01:47 <MissPiggy> I don't know what I should do
12:02:01 <MissPiggy> I can't decide if a + b = PLUS A B or = (+)$a$b
12:02:03 <edwardk> then you're stuck unless you want to build a horrible little SYB call to avoid 4 lines of code
12:02:25 <edwardk> MissPiggy: toss a coin
12:02:33 <gwern> edwardk: oh well.
12:04:19 <gwern> amazing! a use for the bracket and semicolon style!
12:04:22 <gwern> compressing boilerplate
12:05:31 <gwern> (huh. from all this furor over my little SoC history marking -exts as 'unknown', you'd think I'd marked it 'unsuccessful'. if my history is that bad and arbitrary, nothing stopping people from writing their own...)
12:05:53 <aavogt> sometimes semicolons are enough
12:06:00 <edwardk> gwern: sorry, just i, like many, think it was a very successful project.
12:06:26 <aavogt> and you can leave the braces out of this
12:07:43 <edwardk> gwern: Broberg met the stated goals of the SoC project like a week in. I was quite impressed ;)
12:07:59 <gwern> edwardk: ...that's a point against him
12:08:45 <edwardk> gwern: to be fair, he'd been working on them right up through when the "summer of code" was slated to start. not sure there is anything wrong with starting early and being passionate about the project.
12:09:05 <gwern> it suggests the SoC was unneeded
12:09:46 <edwardk> gwern: you've clearly made up your mind on this point, so i'll drop it.
12:10:18 <gwern> :t maybe []
12:10:20 <lambdabot> forall a a1. (a1 -> [a]) -> Maybe a1 -> [a]
12:10:43 <gwern> @hoogle forall a a1. (a1 -> [a]) -> Maybe a1 -> [a
12:10:43 <lambdabot> Parse error:
12:10:43 <lambdabot>   --count=20 "forall a a1. (a1 -> [a]) -> Maybe a1 -> [a"
12:10:43 <lambdabot>                                                        ^
12:10:44 <gwern> @hoogle forall a a1. (a1 -> [a]) -> Maybe a1 -> [a]
12:10:45 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
12:10:45 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:10:45 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
12:11:16 * gwern wonders whether concatMap would not be an obfuscation
12:11:45 <edwardk> @type (=<<)
12:11:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:11:47 <FliPPeh> Hey, using "cabal install quickcheck" I pull in QuickCheck 1.2
12:11:50 <FliPPeh> But I need 2.0
12:11:52 <edwardk> much clearer ;)
12:11:52 <FliPPeh> What do I do?
12:11:55 <FliPPeh> Ohh, save me.
12:12:00 <gwern> FliPPeh: specify version
12:12:05 <FliPPeh> How? :(
12:12:09 <gwern> cabal-install does that to preserve our collective sanity
12:12:18 <gwern> FliPPeh: is it not just quickcheck-2.0 or whatever?
12:12:26 <edwardk> gwern: insanity ;) QC 2 adds so many useful things ;)
12:12:29 <Saizan> FliPPeh: cabal install "QuickCheck >= 2"
12:12:38 <gwern> edwardk: clearly you are a theorist
12:12:53 <edwardk> gwern: nah, just someone who uses QC 2
12:13:00 <FliPPeh> Thanks :)
12:13:05 <Saizan> it just keeps packages with sloppy maintainer from not building
12:13:31 <edwardk> and is perpetually annoyed at the fact that I can't use a package upstream that has a spurious dependency on QC 1.2 because the author didn't factor their tests out into a separate package
12:14:30 * hackagebot upload: text 0.7.1.0 - An efficient packed Unicode text type (BryanOSullivan)
12:14:58 <edwardk> gwern: or was that remark regarding (=<<) =)
12:15:05 <gwern> edwardk: both, naturlich
12:15:08 <edwardk> hah
12:16:32 <edwardk> i wonder if I should try to organize a BostonHaskell revolt and see if we can get HacBos to actually happen. Ravi seems to have dropped off the face of the earth.
12:17:22 <knobo> kmc_: (three hours ago about Nokia N900) Clisp is running on N900 with gtk bindings.
12:17:33 <gwern> hath the #haskell hivemind any suggestions about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17120#a17120 ?
12:18:10 <kmc_> suggestions of what sort?
12:18:24 <gwern> kmc_: code style, shorter formulations
12:18:27 <gwern> that sort of thing
12:18:31 <edwardk> mostly just nits about spacing. generateFeed cfg fs mbPath = do now <- getCurrentTime is fairly painful to refactor. ;)
12:18:35 <kmc_> i have a trivial style suggestion
12:18:44 <gwern> before I compile it and see whether it actually works
12:18:46 <edwardk> otherwise i can't complain
12:18:59 <gwern> edwardk: how so?
12:19:01 <kmc_> which is to start "do" or "let" blocks on the next line, rather than immediately to the right of the function and arg names
12:19:03 <edwardk> you can also run that huge run of inline lets in your 'do' into one let
12:19:16 <gwern> edwardk: I can?
12:19:18 <edwardk> as kmc_ suggests. move the first line of the do to the next line
12:19:19 <gwern> how does that work?
12:19:27 <edwardk> let introduces another layout block
12:19:33 <kmc_> i.e. "generateEmptyfeed title home authors now = let"... put a newline before = and indent it a fixed 2 or 4 spaces
12:19:36 <FliPPeh> Man
12:19:38 <gwern> oh. so replace the lets with tabs
12:19:42 <kmc_> or after = if you like
12:19:47 <FliPPeh> Setup.lhs just won't configure this file
12:19:51 <FliPPeh> ALL dependencies match
12:19:53 <gwern> never seen that style before, I think
12:19:55 <edwardk> and move the first line of each do/where down to the next line
12:19:56 <FliPPeh> But it says they don't.
12:19:59 <Zao> gwern: s/tabs/spaces/
12:20:05 <Zao> Only madmen tab their code :)
12:20:12 <edwardk> that way if you refactor the function declaration you don't have to respace the whole block that follows
12:20:47 <kmc_> and you don't end up with huge regions of empty space just because your function has a long name
12:20:53 <edwardk> i.e. if you changed the variable names or function name in generateFeed cfg fs mbPath, you'd be moving several lines
12:20:56 <edwardk> that too
12:21:18 <kmc_> gwern: maybe rewrite "extract" using three equations
12:21:25 <kmc_> more vertical space but easier to see what it's doing
12:21:35 <kmc_> i guess we went over that before
12:21:39 <gwern> kmc_: nah. one line is all its worth
12:21:46 <gwern> and eventually it won't exist at all
12:22:10 <kmc_> what about using some record wildcards / puns
12:22:15 <kmc_> like in revisionToEntry
12:22:35 <gwern> kmc_: and those would be?
12:22:40 <kmc_> a GHC extension
12:22:47 <edwardk> kmc_: Change isn't his datatype
12:22:54 <edwardk> kmc_: its baked into FileStore somewhere
12:23:19 <kmc_> gwern:http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns and the next section
12:23:34 <kmc_> edwardk: sure, i didn't propose to change the type
12:24:18 <edwardk> oh
12:24:19 <edwardk> i see
12:24:23 <edwardk> sorry, misparsed
12:25:19 <edwardk> that is about the only location he could really use them though, and would make it much less readable i think
12:25:32 <edwardk> you'd have to spot the extension being used, puzzle through its meaning, etc.
12:25:51 <zachk> im having problems here using infix precedence levels and it says u is defined all over the place http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17122#a17122 any help would make me grateful :-D
12:26:12 <kmc_> yeah, there's some intrinsic cost to using an extension, which depends on the project
12:26:29 <mauke> zachk: what's the first error message?
12:27:26 <MissPiggy> zack you cant dot aht!
12:27:42 <chrisf> does anyone agree that hpaste's URLs suck?
12:27:58 <MissPiggy> chrisf I don't see it as an issue
12:28:10 <zachk> vector.hs:10:2: Not in scope: data constructor `:+:'
12:28:25 <chrisf> i mean, who gives a crap that it's served via fastcgi, really?
12:28:30 <zachk> MissPiggy: why cant i do what i am doing
12:28:33 <mauke> zachk: : is an uppercase symbol
12:28:43 <zachk> ????!
12:28:49 <MissPiggy> : is used for data
12:28:53 <mauke> zachk: it's reserved for constructors
12:29:08 <MissPiggy> data Term op = V String | Term op :$: Term op deriving Show
12:29:12 <MissPiggy> for exaplje
12:29:18 <zachk> oh darn, do any of you have any advice for a replacement of it ?
12:29:25 <benmachine> .+.?
12:29:40 <zachk> i guess that would work
12:29:58 <mauke> > let a + b = a * b in 3 + 4
12:29:59 <lambdabot>   <no location info>: lexical error at character '\776'
12:30:03 <mauke> :-(
12:30:20 <jlouis> mauke: :)
12:33:02 <gwern> hm. enough format twiddling
12:33:14 <gwern> let's compile and see whether the rss actually works this time around
12:37:15 <monochrom> w00t bos's text package sounds neat
12:38:40 <monochrom> uses arrays of 16-bit words. this is the "bytestring except for unicode" everyone wants!
12:39:00 <gwern> hm. it doesn't verify, but it doesn't result in type 500 errors either
12:39:06 <gwern> I suppose that's an improvement
12:39:19 <ben> What if I want bytestring except for utf-8
12:39:32 <monochrom> heh then you have bytestring already
12:40:42 <mauke> unicode is not 16 bits :-|
12:41:53 <bos> neither is the text library
12:41:54 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
12:41:59 <monochrom> Or perhaps you have unsaid meaning of "I don't store utf-8, I slurp utf-8, I want to store something better", then the text package has decodeUtf8 :: ByteString -> Text for you.
12:44:07 <monochrom> And yeah, it just stores 16-bit words, doesn't mean it screws up. Surely length :: Text -> Int does the right thing, in fact the only reason why it's O(n) is it does the right thing.
12:44:40 <monochrom> Similarly head :: Text -> Char will not suck.
12:44:48 <monochrom> or perhaps s/suck/break/
12:45:31 <Veinor> ... huh. hackage says there's no Polynomial type.
12:45:39 <Veinor> this is something I believe I should rectify!~
12:45:59 <benmachine> I'm surprised
12:46:07 <benmachine> there are numbers libraries ten-a-penny
12:46:31 <MissPiggy> Veinor how do you define polynomials?
12:46:46 <MissPiggy> Veinor and what operations on them?
12:47:09 <Veinor> MissPiggy: well, each polynomial that I was thinking of could obviously be represented as a list
12:47:20 <MissPiggy> okay
12:47:27 <MissPiggy> oh like
12:47:38 <Veinor> @src (*)
12:47:39 <lambdabot> Source not found. Are you on drugs?
12:47:43 <MissPiggy> [3,5,7] represents 3x^2 + 5x + 7?
12:47:44 <Veinor> oh whoops
12:47:46 <Veinor> :t (*)
12:47:47 <lambdabot> forall a. (Num a) => a -> a -> a
12:47:54 <kmc_> the other order makes more sense
12:47:57 <Veinor> yeah.
12:48:07 <Veinor> because then poly !! i is the coefficient of x^i
12:48:17 <MissPiggy> > foldr (\ x r -> c + x * r) 0 [3,5,7]
12:48:18 <lambdabot>   c + 3 * (c + 5 * (c + 7 * 0))
12:48:29 <kmc_> this reminds me of generating series
12:48:38 <Veinor> MissPiggy: if I wanted to represent it internall as a horner series, sure
12:48:43 <MissPiggy> > foldr (\ x r -> c * x + r) 0 [3,5,7]
12:48:44 <lambdabot>   c * 3 + (c * 5 + (c * 7 + 0))
12:48:51 <MissPiggy> hm
12:48:57 <Veinor> I don't think you can add or multiply horner serieses in any fast way, though
12:49:24 <MissPiggy> > foldr (\ a r -> a + x * r) 0 [3,5,7]
12:49:25 <Veinor> plus I believe that computing the coefficients is an O(n^2) operation
12:49:25 <lambdabot>   3 + x * (5 + x * (7 + x * 0))
12:49:37 <MissPiggy> I don't get it
12:49:43 <bos> > x
12:49:45 <lambdabot>   x
12:49:50 <MissPiggy> oh I see
12:49:57 <bos> wow, i didn't know lambdabot was doing clever things with free variables now.
12:50:03 <monochrom> :t x
12:50:04 <lambdabot> Expr
12:50:06 <bos> that's kind of awesome.
12:50:11 <MissPiggy> so [3,5,7] represents 3 + 5x + 7x^2?
12:50:13 <solrize> > gazonko
12:50:14 <lambdabot>   Not in scope: `gazonko'
12:50:20 <monochrom> from the "simple reflection" package
12:50:24 <hzap> they're not actually free variables
12:50:33 <benmachine> they're things of type Expr
12:50:34 <solrize> > z
12:50:35 <Veinor> MissPiggy: yeah.
12:50:35 <lambdabot>   z
12:50:38 <solrize> > h
12:50:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:50:39 <RayNbow> > var "x"
12:50:39 <lambdabot>    `SimpleReflect.FromExpr ...
12:50:40 <lambdabot>   x
12:50:47 <RayNbow> :t var
12:50:48 <lambdabot> forall a. String -> Sym a
12:50:50 <MissPiggy> so you can define
12:50:52 <solrize> > g
12:50:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:50:54 <lambdabot>    `SimpleReflect.FromExpr ...
12:51:02 <solrize> :t f
12:51:03 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:51:06 <RayNbow> > var "x" * 2
12:51:07 <lambdabot>   2*x
12:51:09 <benmachine> > expr $ f x
12:51:10 <lambdabot>   f x
12:51:14 <benmachine> > expr $ f x y z
12:51:15 <lambdabot>   f x y z
12:51:16 <solrize> > a
12:51:17 <lambdabot>   a
12:51:17 <Veinor> so evaluate poly x = foldr (\a r -> a+x*r) 0 poly
12:51:20 <MissPiggy> eval rep x = foldr (\a r -> a * x + r) 0 rep
12:51:26 <Veinor> although... which is the natural argument order for that?
12:51:33 <kmc_> @pl \a r -> a+x*r
12:51:33 <lambdabot> (. (x *)) . (+)
12:51:44 <MissPiggy> and then specify things like    eval (p + q) = eval p + eval q
12:51:47 <monochrom> they have Num instance so you can do a simple of symbolic arithmetic and marvel at the result of folds and watch the blinking lights.
12:51:50 <Veinor> it strikes me that you usually want to evaluate a polynomial at more than one point than you want to evaluate multiple polynoimials at the same point
12:51:51 <MissPiggy> that's nice
12:52:13 <MissPiggy> I just suggest eval because you can specify progarms with it
12:52:40 <bos> monochrom: ah, cute
12:52:53 <Veinor> otoh, evaluate x poly can be curried easier
12:52:59 <MissPiggy> no
12:53:01 <Veinor> (I don't think you want to curry x :P)
12:53:12 <edwardk> whoa, iolaus is neat. i might actually start using git
12:53:17 <Veinor> evaluate x = foldr (\a r -> a + x * r) 0
12:53:25 <Veinor> what's iolaus? I've heard things about it.
12:53:32 <MissPiggy> nah that's not what I was after
12:53:37 <monochrom> bos: The package is at http://hackage.haskell.org/package/simple-reflect
12:53:41 <edwardk> Veinor: roundy making git act like darcs ;)
12:53:54 <MissPiggy> kmc_:  (+x*)
12:54:01 <edwardk> Veinor: http://github.com/droundy/iolaus
12:54:12 <Veinor> roundy?
12:54:17 <benmachine> calc xs n = foldl' (+) 0 . zipWith (*) xs $ iterate (*n) 1
12:54:27 <benmachine> I have that from somewhere
12:54:32 <edwardk> david roundy, the guy who started darcs
12:54:44 <edwardk> physicist, 'theory of patches' guy
12:54:46 <Veinor> ah
12:54:55 <Veinor> but anyway, operations
12:55:01 <aavogt> benmachine: the foldr version does less multiplies I believe
12:55:20 <Veinor> you can add them, multiply them, and compose them
12:55:31 <MissPiggy> compose p q = eval p . eval q
12:55:33 <Veinor> @type .
12:55:34 <lambdabot> parse error on input `.'
12:55:35 <monochrom> Haha nice. If eventually everyone uses git and no one uses darcs, we still claim "we lost the battle but won the war" :)
12:55:38 <Veinor> @type (.)
12:55:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:55:55 <Veinor> so.... polynomials are functors? :o
12:56:08 <aavogt> hmm, maybe not since iterate doesn't recompute any powers
12:56:22 <Veinor> I like git, I've never used darcs so I can't compare them.
12:56:36 <Veinor> I feel vaguely like a language traitor :P
12:57:18 <monochrom> Oh I use compiz and metacity, I don't use xmonad. I sometimes write shell scripts. My irc bots are eggdrop not lambdabot. Not traitor.
12:57:26 <edwardk> veinor: you can convert to Horner's scheme in linear time iirc using n fused multiply adds
12:57:29 <MissPiggy> would anyone criticize my code please
12:57:39 <Veinor> edwardk: I might be thinking of something else then.
12:57:52 <MissPiggy> first of all here is what it does:
12:57:53 <MissPiggy> *Syntax> parse term [] "  e   *  ( k ( g x y ) f  +f(x)  * 3)" :: Either ParseError (Term Arithmetic)
12:57:53 <MissPiggy> Right (e * k (g x y) f + (f x * 3))
12:57:53 <Veinor> also, I keep thinking you're ezyang
12:57:59 <MissPiggy> parser and pretty printer
12:58:08 <MissPiggy> and this is it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17124
12:58:11 <Veinor> until I see the k.
12:58:18 <edwardk> veinor: maybe something like the FFT for Schnhage and Strassen?
12:58:49 <Veinor> I don't know that much number theory, sorry :P
12:59:01 <MissPiggy> woah I got it wrong
12:59:39 <MissPiggy> annotated with a bugfix
12:59:53 <edwardk> veinor: fastest practical multiplication algorithm for numbers that aren't ridiculously large ;)
13:00:51 <MissPiggy> kmc_ that's the good version btw
13:00:54 <MissPiggy> so far I think it's the best
13:00:56 <edwardk> though, note that 'not ridiculously large' is still bigger than 10k digits ;) so everything is relative.
13:03:03 <Veinor> edwardk: bah, I concern myself not with things like 'speed'
13:04:24 <MissPiggy> I should make it do something now
13:04:29 <MissPiggy> instead of just echoing your input
13:04:33 <djahandarie> Speed is pointless anyways, I mean we are eventually going to have time travel, therefore folding the space-time continuum and making any definition of speed worthless
13:04:39 <MissPiggy> but what's a simple algebraey thing to do
13:04:53 <djahandarie> I probably shouldn't be talking about stuff like that in here because for all I know there could be someone extremely versed in that
13:06:05 <MissPiggy> Veinor, what about polynomials such as  a^2 + ab + b^2?
13:06:33 <Veinor> MissPiggy: univariate polynomials for now :p
13:06:37 <MissPiggy> could be [(0,2),(1,1),(2,0)]?
13:06:44 <Veinor> or you could just do that, yeah
13:06:57 <Veinor> ... I think we need to do Peano arithmetic in the type system again.
13:07:02 <MissPiggy> and what about 3a^3 + 7b^2 + a^2b^3
13:07:32 <MissPiggy> you can find a way to avoid having to use any difficult type stuff
13:07:51 <edwardk> If you have to do arithmetic with types, please god find a way to do it more efficiently than Peano ;)
13:08:34 <Veinor> edwardk: :P
13:10:03 <MissPiggy> I'm quite pleased to have this stupid parser/printer thing done -- that's the first part of my program that I actually managed to write
13:10:34 <edwardk> djahandarie: good luck with that. =)
13:10:44 <Veinor> well, my point is if I'm going to go with multivariate polynomials, I want evaluating them on the wrong number of arguments to generate another polynomial, an integer, or a type error as appropriate
13:10:52 <edwardk> MissPiggy: what are you writing anyways?
13:11:15 <Veinor> so evaluate (2x^2+3) 2 3 is a type error, but evaluate (2x^2+y) 3 gives you 18+y, or maybe 2x^2+3
13:11:33 <MissPiggy> it's a decision procedure for homework problems
13:11:35 <MissPiggy> lol
13:11:55 <edwardk> MissPiggy: isn't deciding if your homework is decidable harder than just doing your homework? =)
13:12:15 <MissPiggy> I can't decide
13:12:21 <edwardk> hahahaha
13:17:40 <Paczesiowa> preflex seen ivanm
13:17:40 <preflex>  ivanm was last seen on #haskell 1 day, 10 hours, 57 minutes and 54 seconds ago, saying: heh
13:22:39 <MissPiggy> any suggestions what the first algebra program should be?
13:23:09 <edwardk> misspiggy: so you have a parser/pretty printer, and now plan to write simplifiers, etc?
13:23:20 <MissPiggy> yeah
13:24:27 <MissPiggy> I should do polynomial normal form first I guess
13:24:41 <MissPiggy> that is some kind of lexical ordering of the thing expanded out fully
13:25:02 <SubStack> @pl \a b -> (fst a + fst b, snd a + snd b)
13:25:03 <lambdabot> ap (ap . ((,) .) . (. fst) . (+) . fst) ((. snd) . (+) . snd)
13:25:24 <MissPiggy> > (1,2) + (3,4)
13:25:25 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
13:25:25 <lambdabot>    arising from a use of `GHC.Num.+' ...
13:25:38 <SubStack> @pl \(x1,y1) (x2,y2) -> (x1+x2, y1+y2)
13:25:39 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
13:25:43 <SubStack> wow that's worse
13:26:03 <SubStack> I thought there's be some clever trick with arrows
13:26:04 <MissPiggy> :t (+)`on`(uncurry (:+))
13:26:05 <lambdabot> forall a. (RealFloat a) => (a, a) -> (a, a) -> Complex a
13:26:12 <mauke> pl doesn't know arrows
13:26:48 <MissPiggy> someone should teach pl arrows
13:33:35 <uorygl> > text "Hi!"
13:33:36 <lambdabot>   Hi!
13:33:45 <uorygl> > text "\223"
13:33:46 <lambdabot>   
13:33:51 <uorygl> > toUpper '\223'
13:33:52 <lambdabot>   '\223'
13:34:17 <doserj> > let f = uncurry (***) . ((+) *** (+)) in f (3,4) (5,6)
13:34:18 <lambdabot>   (8,10)
13:34:30 <uorygl> Is there a function that correctly gives the uppercase form of eszett?
13:34:47 <SubStack> doserj: nice
13:35:05 <doserj> uorygl: the uppercase of eszett would be "SS", which is a String, not a Char
13:35:10 <uorygl> Right.
13:35:30 <mauke> there is an uppercase , actually
13:35:40 <mauke> but no one uses it
13:35:53 <uorygl> Well, doesn't Unicode define the uppercase of eszett to be SS?
13:36:18 <djahandarie> Isn't the uppercase  contested?
13:36:45 <uorygl> > filter (\x -> isUpper x || isLower x) [minBound..maxBound]
13:36:46 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\1...
13:36:46 <SubStack> > let f = uncurry (***) . join (***) (+) in f (3,4) (5,6)
13:36:48 <lambdabot>   (8,10)
13:36:50 <monochrom> it is impossible for Char->Char to give "SS".
13:37:06 <uorygl> monochrom: I know that.
13:37:11 <djahandarie>  is uppercase for 
13:37:13 <ben> Well maybe then people should stop giving toUpper the type Char->Char
13:37:27 <djahandarie> U+1E9E LATIN CAPITAL LETTER SHARP S
13:37:34 <djahandarie> Since Unicode 5.1
13:37:34 <mauke> excellent
13:37:42 * mauke adds it to his compose file
13:37:49 <ben> 
13:37:55 <ben> Woah. I already did that. I had no idea.
13:38:10 <monochrom> OK nice.
13:38:15 <uorygl> mauke: I've been trying to figure out how to configure my compose key for ages.
13:38:26 <Gracenotes> unicode uppercase is complicated, and I'm not sure if Haskell implements it anywhere
13:38:28 <monochrom> When was Unicode 5.1 released?
13:38:39 <uorygl> By which I mean since then, I've changed operating systems three times.
13:38:42 <djahandarie> monochrom, April 08
13:38:51 <cheater2> herlo
13:38:59 <mauke> uorygl: do you have a compose key that does anything at all?
13:39:06 <uorygl> Currently, I don't think so.
13:39:39 <cheater2> how do the monads in haskell relate to monads in mathematics?
13:39:43 <mauke> hmm, not sure how to set it up. X calls it <Multi_key>
13:40:07 <uorygl> cheater2: well, I think there are multiple concepts of monads in mathematics.
13:40:19 <kmc_> cheater2: do you understand how instances of the typeclass Functor relate to functors in mathematics?
13:40:25 <kmc_> that'd be a prerequisite
13:40:26 <ddarius> Gracenotes: The only thing the Report requires is that (a class of?) unicode codepoints can be represented with a single character.
13:40:41 <cheater2> kmc_: no, but i can probably understand it quickly.
13:40:53 <Gracenotes> I should, if it's implemented anywhere in Haskell
13:40:57 <ddarius> cheater2: Monads in Haskell (assuming the laws hold) are an instance of the monads in CT.
13:41:09 <cheater2> what's CT?
13:41:15 <ddarius> Category Theory.
13:41:20 <mauke> .oO( chrono trigger )
13:41:24 <cheater2> what laws?
13:41:28 <ddarius> The monad laws.
13:41:36 <cheater2> what are the monad laws?
13:41:41 <uorygl> cheater2: what are the monads you're familiar with?
13:41:50 <cheater2> none so far
13:42:01 <ddarius> cheater2: Why are you asking this question then?
13:42:12 <monochrom> Good call
13:42:20 <cheater2> because i want to learn about monads and understand they're an important construct in haskell
13:42:46 <kmc_> cheater2: you should try to understand both concepts individually before learning the connection
13:42:50 <ddarius> cheater2: At this point what is the value to you of relating a concept you don't know to another concept you don't know?
13:43:00 <kmc_> this is not a case, i think, where knowing the connection will help you understand the parts
13:43:11 * uorygl ponders whether he can come up with an extraordinarily apt description of what monads are.
13:43:18 <kmc_> most people learn Haskell monads before learning any category theory, if they do so at all
13:43:18 <cheater2> ddarius: it will let me reflect upon knowledge gain in the future in order to solidify it.
13:43:38 <ddarius> kmc_: Or vice versa (modulo the "most")
13:44:14 <gwern> whoo! my gitit feeds validate!
13:44:18 <uorygl> A monad is a particular sort of type constructor. You pretty much have to know what a type constructor is before knowing what a monad is.
13:44:41 <gwern> and seem to work for both pages and sitewide feeds
13:44:47 <gwern> my long rss nightmare is over
13:45:36 <ddarius> cheater2: A useful description of the connection will require the details of the objects.  Otherwise it's saying a bunch of meaningless terms match a bunch of other meaningless terms.  The only useful thing I can say is that monads in Haskell are a particular instance of monads in category theory, in the way that you are a particular instance of the notion of a person.
13:45:39 <merijn> Learning monads (for me anyway) is like a series of alternating waves of "I got it!" and "Damn, I don't understand these things at all."
13:46:06 <uorygl> Hum, let me figure this out in a pastebin.
13:46:24 <cheater2> ddarius: so what you mean is that monads in haskell are a class of the monads in ct.
13:46:44 <gwern> no validation issues, no hlint warnings, no -wall warnings
13:46:51 <kmc_> cheater2: you want to understand "what monads are", right?
13:46:54 <kmc_> in Haskell?
13:47:12 <cheater2> kmc_: that too
13:47:15 <kmc_> okay
13:47:18 <kmc_> well that's easy
13:47:21 <ddarius> cheater2: They are a very special case of monads in CT.
13:47:25 <kmc_> and not especially related to CT
13:47:26 <cheater2> kmc_: go on then :-)
13:47:32 <gwern> looking good
13:47:35 <kmc_> a monad is an instance of the typeclass named "Monad"
13:47:39 <kmc_> that's all
13:47:49 <cheater2> what does this typeclass do?
13:47:54 <kmc_> @src Monad
13:47:54 <lambdabot> class  Monad m  where
13:47:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:47:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:47:54 <lambdabot>     return      :: a -> m a
13:47:54 <lambdabot>     fail        :: String -> m a
13:48:02 <kmc_> ignore (>>) and fail for now
13:48:14 <uorygl> Ignore fail forever.  :P
13:48:17 <Philonous> kmc_ Wouldn't you additionally require that the monad laws hold?
13:48:30 <kmc_> Philonous: ideally...
13:48:33 <kmc_> cheater2: you'd be best off learning a few concrete simple examples of monads
13:48:38 <merijn> Philonous: That only matters if you don't want to write nonsense :p
13:48:40 <kmc_> like Maybe or State, and definitely *not* IO
13:48:42 <mauke> instance Monad Foo;  -- whee
13:48:44 <gwern> but bah, it doesn't pass heavy duty validation :(
13:48:46 <cheater2> i'm still not sure how to understand these displays kmc_
13:49:02 <cheater2> can you explain what they mean in simple words?
13:49:04 <andrewe> hi kmc
13:49:06 <mauke> ok, learn basic haskell first. then slightly more advanced haskell :-)
13:49:12 <kmc_> cheater2: do you understand how to declare typeclasses and instances
13:49:23 <kmc_> hi andrewe
13:49:25 <mauke> cheater2: do you understand type declarations in general?
13:49:27 <cheater2> kmc: i am learning about typeclasses right now
13:49:42 <jmcarthur> honestly, we put too much emphasis on monads. you don't need to learn them to use haskell
13:49:52 <merijn> cheater2: I wouldn't worry about monads until you understood typeclasses more
13:49:53 <cheater2> mauke: i understand that they just tell us the types
13:49:55 <kmc_> cheater2: ... then learn that first
13:50:24 <merijn> (Generic) ADTs are far more important and useful to learn at first then monads, in my personal experience
13:50:36 <cheater2> so  (>>=)       :: forall a b. m a -> (a -> m b) -> m b       thism eans that if a is a monad and (something i don't understand) then we get a monad b.
13:50:41 <jmcarthur> eh, i actually don't used GADTs much
13:50:43 <cheater2> (right?)
13:50:49 <mauke> cheater2: no
13:50:52 <jmcarthur> and i tend to use newtype a *lot*
13:50:57 <mauke> cheater2: the monad is m
13:50:57 <kmc_> monads are not hard.  (>>=) is just a higher order function that lives in a type class.  but for some reason people come in here all the time wanting to understand monads without knowing higher order functions or typeclasses
13:51:00 <jmcarthur> so even ADTs don't get much love from me
13:51:03 <cheater2> ah
13:51:04 <mauke> cheater2: a and b are arbitrary types
13:51:08 <kmc_> which are much more general concepts
13:51:34 <mauke> cheater2: you give it a value of type 'm a' and a function from 'a' to 'm b', and it gives you an 'm b'
13:51:39 <kmc_> cheater2: one instance of (>>=) would be:   Maybe a -> (a -> Maybe b) -> Maybe b
13:51:47 <kmc_> defined thus:
13:51:51 <kmc_> Nothing >>= f = Nothing
13:51:54 <merijn> jmcarthur: Well, I just started my class in compiler construction and I immediately started having flashes how GADTs are awesome for constructing ASTs :p
13:51:57 <kmc_> (Just x) >>= f = f x
13:52:27 <andrewe> kmc_: what's a simple example for the State monad?
13:52:49 <kmc_> eh there are plenty online
13:52:55 <jmcarthur> merijn: have you read Finally Tagless yet?
13:52:59 <Philonous> kmc_ Maybe monads are advertised a little to agressively as some sort of silver bullet for effectful functional code. Otoh you don't necessarily need type classes to have monads.
13:53:07 <kmc_> yes
13:53:14 <kmc_> there's a lot of hype and misunderstanding
13:53:18 <merijn> jmcarthur: No, what's it about?
13:53:31 <jmcarthur> merijn: Finally Tagless is pretty much one of the coolest papers i've read recently
13:53:46 <pikhq> Philonous: Well, the thing is, monads are discussed as something magical.
13:53:54 <ddarius> The G in GADT stands for "generalized"
13:54:08 <jmcarthur> merijn: using combinator functions instead of data constructors for abstract syntax
13:54:10 <kmc_> cheater2: you suggested earlier that you're not comfortable parsing a type of this form:   A -> (B -> C) -> D
13:54:19 <cheater2> yes
13:54:23 <kmc_> that's a much more basic concept than monads
13:54:24 <merijn> jmcarthur: I have a rapidly increasing stack of books and papers to read. Too little time :(
13:54:25 <pikhq> Rather than "Types for which the functions (>>=) :: (Monad m) => m a -> (a -> m b) -> m b and return :: (Monad m) => a -> ma are defined".
13:54:45 <kmc_> a value of type "A -> (B -> C) -> D" is a function of two arguments
13:54:48 <kmc_> one of those arguments has type A
13:54:49 <jmcarthur> merijn: if you like neat tricks for compiler construction and such this should be at the top of your stack
13:54:51 <kmc_> the other has type B -> C
13:55:04 <jmcarthur> merijn: as far as design goes, anyway
13:55:41 <cheater2> does this mean that that other argument is something that takes an argument of type b and returns a value of type c?
13:55:45 <kmc_> yes
13:55:49 <cheater2> ok
13:55:50 <kmc_> the second argument is itself a function
13:55:58 <cheater2> let me reread the src there
13:56:08 <kmc_> anyway, you need to get comfortable with higher order functions and typeclasse
13:56:23 <cheater2> mhm
13:56:27 <merijn> jmcarthur: My current top of stack is "On the Universality and Expressiveness of Fold", "Introduction to Algorithms", "Types and Programming Languages" (and then in no decided order yet: TAoCP and the dragon book)
13:56:31 <jmcarthur> merijn: it's full title is "Finally Tagless, Partially Evaluated"
13:57:03 <kmc_> cheater2: a simpler typeclass with a higher order function in it is Functor
13:57:05 <kmc_> @src Functor
13:57:06 <lambdabot> class  Functor f  where
13:57:06 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:57:11 <kmc_> that's all
13:57:25 <jmcarthur> merijn: i haven't read that first one. TAPL is well worth it. the dragon book is... okay. i've only read bits and pieces of TAoCP, but i liked what i read and would like to do all of it
13:57:36 <kmc_> if the type constructor F is an instance of the class Functor, then we get a function fmap :: (a -> b) -> F a -> F b
13:57:48 <kmc_> for example:  fmap :: (a -> b) -> Maybe a -> Maybe b
13:58:11 <merijn> jmcarthur: The first is kinda interesting, so far its not to hard and it proves that any recursion can be written as fold + a trivial function.
13:58:12 <kmc_> the instance of fmap for Maybe is:  fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
13:58:18 <andrewe> cheater2: I think fmap is even easier to understand with lists
13:58:21 <jmcarthur> merijn: Finally Tagless is probably an easier read than those
13:58:40 <jmcarthur> merijn: yeah, i love folds
13:58:50 <andrewe> cheater2: I can recommend that you write your own list data type and make it an instance of functor
13:59:08 <cheater2> mhm
13:59:16 <cheater2> i am reading everything here
13:59:51 <merijn> jmcarthur: I bought a copy of TAoCP because it was packaged real pretty and I thought I should read it. But that was in the middle of a "mathy" semester so I didn't have the motivation then to do more additional math. And now I decided to first get some of the easier books done first.
14:00:02 <jmcarthur> ah
14:03:30 <nolrai_FG> @ty <=<
14:03:31 <lambdabot> parse error on input `<=<'
14:03:36 <nolrai_FG> @ty (<=<)
14:03:36 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:04:13 <merijn> Some of those type expressions look almost like line noise :p
14:12:21 <cheater2> ok, so what does fmap do exactly?
14:13:21 <c_wraith> cheater2: it depends.
14:13:22 <mauke> applies a function to the "contents" of some wrapper without changing the structure of the wrapper
14:14:22 <jmcarthur> > fmap (+1) [1,2,3]
14:14:23 <lambdabot>   [2,3,4]
14:14:27 <jmcarthur> > fmap (+1) (Just 4)
14:14:28 <lambdabot>   Just 5
14:14:34 <jmcarthur> > fmap (+1) (Right 4)
14:14:35 <lambdabot>   Right 5
14:14:49 <cheater2> gotcha
14:15:21 <mauke> > fmap (+1) (Left "hi")
14:15:22 <lambdabot>   Left "hi"
14:15:32 <mauke> > fmap (+1) Nothing
14:15:33 <lambdabot>   Nothing
14:15:37 <mauke> > fmap (+1) []
14:15:38 <lambdabot>   []
14:15:45 <c_wraith> > (fmap (+1) (+2)) 5
14:15:46 <lambdabot>   8
14:15:56 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17126#a17126
14:16:13 <jmcarthur> c_wraith: you are just going to confuse the poor beginner
14:16:17 <cheater2> thanks
14:16:20 <cheater2> that's very useful
14:17:42 <Berengal> http://85.200.142.237:5000/ for those interested in seeing how it works
14:18:49 <Berengal> I should probably mention that I have no sessions, just global state...
14:21:49 * Berengal officially declares continuations really awesome
14:22:52 <cheater2> thanks a lot guys, the explanations were very useful today
14:22:57 <cheater2> ttyl :-)
14:44:22 * hackagebot upload: epub 0.0.3 - EPUB E-Book construction support library (RadoslavDorcik)
14:46:23 * hackagebot upload: wikipedia4epub 0.0.3 - Wikipedia EPUB E-Book construction from Firefox history. (RadoslavDorcik)
14:46:26 <tommd> Berengal: What package is that using?
14:46:46 <Berengal> tommd: Which part of it? It uses several
14:46:55 <Berengal> The WebCont is my own creation
14:47:02 <tommd> Ahh, that is what I ment
14:47:27 <Berengal> tommd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17126#a17127
14:47:56 <Berengal> run as `newEmptyTMVarIO >>= \app -> simpleHTTP nullConf{port=5000} (webCont app example3)'
14:48:18 <tommd> Berengal: So I see things like "liftServerPart" and "yeildResponse" which makes me think Happstack.
14:48:23 * hackagebot upload: GPipe-TextureLoad 1.0.2 - Load GPipe textures from filesystem (TobiasBexelius)
14:48:33 <Berengal> tommd: Yeah, it's built on top of happstack
14:48:39 <tommd> Neat.
14:49:29 <Berengal> It's not done yet. I need to make room for save/load parameters to webCont, to allow for sessions
14:50:13 <Berengal> A reset action would be nice too, maybe
14:50:42 <Berengal> And checkpoint/rollback actions might be useful too
15:09:55 <grahamhutton> @users
15:09:56 <lambdabot> Unknown command, try @list
15:11:39 <iazr> @list
15:11:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:21:19 <galdor> does someone know why darcs requires unix < 2.4 ? unix 2.3 doesn't build on OpenBSD (it includes "Signals.h" which is clearly wrong)
15:24:29 <galdor> oh my bad, the last development version requires unix < 2.5
15:24:44 <galdor> it's a pity it's not released yet
15:33:11 <cads> @vixen how you, love?
15:33:11 <lambdabot> however you want
15:33:28 <cads> ;)
15:34:04 <iazr> @vixen hello
15:34:05 <lambdabot> hiya
15:34:33 <iazr> @vixen what a nice weather
15:34:33 <lambdabot> bad is better than nice ;)
15:34:40 <iazr> ...
15:35:19 <c_wraith> @vixen who should I trust?
15:35:19 <lambdabot> that's a good question, who?
15:36:21 <temoto> @vixen monad tutorial
15:36:21 <lambdabot> i find it hard to masturbate when the lights are on.
15:36:47 <temoto> jesus... TURN THE LIGHTS OFF!
15:37:17 <cads> And the ruby guys settle for porn in their presentation slides :)
15:38:36 <c_wraith> @vixen are the lights on there?
15:38:36 <lambdabot> nevermind about that
15:39:40 <cads> @vixen will you be a bad girl and spanks me and ride me like a horsie?
15:39:41 <lambdabot> i'm bad in a good way?
15:39:55 <MissPiggy> lol
15:39:57 <cads> tease
15:40:45 <gwynddyllyd> wait a minute... is this #haskell or am i mixing dreams and haven't got back from sleep yet.
15:40:50 <gwynddyllyd> is this real life?
15:40:57 <jmcarthur> i think it's #rubyonrails
15:41:37 <gwynddyllyd> it's a nightmare then!
15:41:44 <c_wraith> @vixen what's the value of point-free representation?
15:41:45 <lambdabot> i give up, what?
15:41:52 <c_wraith> no, definitely #haskell
15:42:00 <gwynddyllyd> lol
15:43:08 <gwynddyllyd> i wasn't judging, just wanted to make sure. you can resume asking the bot to spank you. :p
15:57:52 <temoto> @vixen example of caleskell
15:57:52 <lambdabot> there are a lot of weirdos on here
15:58:11 <MissPiggy> heh
15:58:26 <temoto> @vixen define functor
15:58:26 <lambdabot> i love fun
15:58:55 <temoto> Close enough.
16:06:01 <temoto> @vixen when @djinn will learn lists?
16:06:02 <lambdabot> when ever you want
16:06:06 <cads> @vixen our love is so strong!
16:06:06 <lambdabot> where on a map is Panama?
16:06:18 <cads> @vixen oh darling!
16:06:18 <lambdabot> yeah
16:06:29 <cads> @vixen you're not really into this, huh?
16:06:29 <lambdabot> yup, i'm into that
16:06:47 <cads> *shrug*
16:06:58 <Berengal> @vixen continuations!
16:06:59 <lambdabot> go on
16:07:17 <temoto> cads, she's cheating on you with ChanServ.
16:07:57 <Berengal> It's too quiet here. Is there a conference or something going on?
16:08:04 <mauke> preflex: quote
16:08:09 <preflex>  <berengal> conal, XML has horrible syntax, but once you get past it there's a plethora of declarative languages... all of them with horrible syntax
16:09:30 <mauke> preflex: quote
16:09:31 <preflex>  <brian_> except I haven't advanced to php yet
16:10:03 <MissPiggy> reflex: quote
16:10:05 <MissPiggy> preflex: quote
16:10:06 <preflex>  <pkrumins> lewellyn, fuck that, reboot early, reboot often.
16:10:11 <MissPiggy> preflex: quote
16:10:12 <preflex>  <monochrom> Ever since people became atheist, they need replacements for religions. Programming languages fill that hole.
16:10:19 <MissPiggy> preflex: quote
16:10:20 <preflex>  <byorgey> Extreme Anger Programming: you are paired with a really dumb partner and after twenty minutes of agony you rip the keyboard from their hands, delete everything they typed, and do it yourself
16:10:25 <MissPiggy> LOL
16:10:52 <Niccus> you can do quotes privately
16:11:25 <temoto> Without lights on, like vixen loves it.
16:11:47 <mauke> Niccus: where's the fun in that?
16:12:06 <Niccus> it's more intimate
16:12:12 <Niccus> and intimacy is where pleasure lies
16:12:21 <temoto> @vixen monad tutorial
16:12:21 <lambdabot> stop being racist!
16:12:29 <temoto> Damn, she's not repeating.
16:12:39 <mauke> that's my new standard reply
16:12:49 <mauke> want to learn monads? STOP BEING RACIST!
16:12:57 <Zao> Is it possible to persist arbitrary information between a configure and a build hook?
16:13:19 <temoto> Zao, other from storing it into /tmp file?
16:13:27 <Zao> Preferably.
16:13:54 <Zao> Currently I do work in my build hook that could as well be done in configure.
16:15:57 * hackagebot upload: graphics-drawingcombinators 1.2.0 - A functional interface to 2D drawing in OpenGL (LukePalmer)
16:16:41 <djahandarie> Wow never seen that package before
16:16:42 <monochrom> Heh, I like my "fill that hole" instead of "fill that role" :)
16:16:48 <djahandarie> Looks cool
16:36:41 <luqui> anybody have ghc working on snow leopard.  i keep getting the error  "ld: warning: in /opt/local/lib/libgmp.dylib, file is not of required architecture" when i try to compile something
16:37:25 <Saizan> luqui: http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html <- seen?
16:37:49 <luqui> Saizan, yeah already did that stuff...
16:38:10 <c_wraith> luqui, where did you get gmp from?  ports?
16:38:26 <c_wraith> macports, I mean?
16:38:29 <luqui> yeah
16:38:41 <c_wraith> you need to install it with the +universal option
16:39:10 <c_wraith> the same for any library ghc 6.10 fails to link against on snow leopard
16:39:17 <luqui> c_wraith, oh!  thanks :-)
16:40:30 <marlin> hi
16:44:41 <luqui> marlin, good morning
16:46:09 <Zao> I assume there's no such thing as a literate hsc file?
16:46:14 <marlin> it's deep in the night here :P
16:47:11 <marlin> i don't suppose there are any xmonad users here and awake that could help me with something "urgent"? i dont have +v and therefore can't write in the #xmonad channel, sadly
16:47:32 <Zao> marlin: Doesn't seem to be muted.
16:47:39 <mauke> +q $~a
16:48:21 <theorbtwo> That just means you need to register with nickserv, not that you need a +v, IIRC.
16:48:31 <Saizan> yeah
16:48:52 <Zao> mauke: Ah, it's that kind of mode.
16:49:02 <Zao> I expected it to be in the proper mode list, for some reason.
16:58:28 <nolrai_FG> Okay I am tring to compile the haskell platform, and it cant find Data.Word? whats up? I have a ghc installed so that should have that right?
16:59:38 <luqui> nolrai_FG, yes presumably...
16:59:44 <Zao> nolrai_FG: Note that the HP does not particularly work well with 6.12.1 yet.
17:05:36 <nolrai_FG> gahh
17:06:07 <Zao> I echo nolrai_FG's "gaah".
17:06:22 <Zao> Just as I'm starting to get somewhere on my bindings-directx package, the February 2010 SDK is released.
17:06:50 <nolrai_FG> I just want to get cabal-install working again.
17:06:51 <copumpkin> damn, troll (http://www.reddit.com/r/programming/comments/ay7xs/google_ai_challenge_tron_accepting_entries_in/c0k0xel) + http://csclub.uwaterloo.ca/contest/rankings.php is really tempting, but I have so much real work to do :(
17:06:57 <copumpkin> we need dons!
17:07:06 <Cale> nolrai_FG: Just install cabal install yourself then?
17:07:58 <Cale> copumpkin: No, we just need blue downarrows :P
17:08:06 <copumpkin> Cale: but he's right for now!
17:08:09 <copumpkin> that's frustrating!
17:08:09 <nolrai_FG> well that didn't work, so..now Im just grasping at straws
17:08:15 <Cale> Huh?
17:08:31 <copumpkin> Cale: he's saying none of the top 100 entries are haskell and he's right
17:09:14 <copumpkin> we even have a starter package now
17:09:23 <tumult> there's a starter package now?
17:09:31 <copumpkin> looks like it, http://csclub.uwaterloo.ca/contest/starter_packages.php
17:09:38 <tumult> haha
17:09:41 <tumult> 3 hours ago there wasn't :)
17:10:28 <tumult> let's see
17:10:46 <Cale> I don't see how this is not amenable to a Haskell solution.
17:11:09 <Cale> It's a combinatorial optimisation problem.
17:11:17 <tumult> nah he's a troll
17:11:22 <copumpkin> Cale: it most certainly is! and I'm really tempted to work on one, but I have problem set due in a couple of hours so I probably shouldn't :P
17:11:22 <tumult> and not a very good one
17:11:22 <luqui> i don't know why we pay attention to such trolls
17:11:59 <luqui> no problem can be solved pure functionally if you do not take the time to learn how most problems can be solved pure functionally
17:11:59 <monochrom> I am too busy solving real-world problems to enter contests.
17:12:00 <copumpkin> I'm sure if we do well he'll just turn around and say we only work on toy problems like this one
17:12:59 <monochrom> Like, there is no COBOL presence in the contest either. So? The COBOL people are busy making real money.
17:13:32 <monochrom> And they have real families and real kids. And they go to real pubs on Friday evenings.
17:14:15 <monochrom> What kind of losers code up tron solvers on Friday pub nights?
17:14:16 <luqui> and live in real senior centers
17:14:24 <copumpkin> lol
17:14:30 * theorbtwo guffaws.
17:14:59 <monochrom> Maybe I should create an account on reddit just to post "What kind of losers code up tron solvers on Friday pub nights?"
17:15:36 <sbahra> Warped definition of "loser".
17:15:37 <tensorpudding> maybe losers which aren't old enough to drink
17:16:01 <monochrom> I'll add that too. Thanks.
17:16:31 <tensorpudding> also, people who don't like alcohol (they exist)
17:16:45 <ben> o/
17:16:55 <sbahra> I like it, but I don't have some ritualistic "Friday pub night".
17:17:04 <djahandarie> I don't drink.
17:17:08 <tensorpudding> it's weird going to a bar/pub and not ordering booze
17:17:12 <monochrom> There was a time I didn't like alcohol and I still went to pubs. I like their fish and chips.
17:17:28 <djahandarie> It's actually technically illegal for me to drink, but its not like that is why I'm not drinking.
17:17:35 <tensorpudding> when you're with a table of dudes and dudettes who are all ordering hefty pints
17:17:57 <Cale> I would usually just order food.
17:18:05 <tensorpudding> pub food is pretty okay
17:18:28 <djahandarie> They probably try to make it slightly more healthy so people don't throw up as much
17:18:41 * djahandarie has never actually been to a pub
17:18:44 <nolrai_FG> I dont like beer, but kaula is good. Dont like getting drunk though makes me feel paranoid.
17:18:50 <tumult> this start package assumes the playing field is always two dimensional!
17:18:59 <tensorpudding> you need to eat to keep from getting too drunk
17:19:08 <tensorpudding> also, starch helps to prevent hangovers
17:19:12 <tumult> what if there's a 3d challenge
17:19:14 <tensorpudding> or so i hear
17:19:34 <nolrai_FG> Here at least pubs can be fairly nice places to get food. Basicly slower higher quality fast food. if that makes any sense.
17:19:38 <Saizan> a zip file? ewww
17:19:45 <tensorpudding> what's wrong with zip?
17:19:50 <ben> The last time I got drunk, I tumbled up to a dorm mate's bookshelf and stole his Data Structures in C++ book
17:20:11 <nolrai_FG> Heh
17:20:17 <kyagrd> Drunken Structures in C++
17:20:27 <monochrom> haha
17:20:28 <tensorpudding> linked lushes
17:20:33 <djahandarie> kyagrd, that sounds like it could actually exist
17:20:48 <djahandarie> Drunken Sorting Algorithm
17:21:00 <tensorpudding> beerbubble sort
17:21:08 <tumult> the tron starter package doesn't work if you submit it back in unchanged
17:21:09 <monochrom> hehe
17:21:34 <theorbtwo> Hash table bongs.
17:21:46 <Berengal> drunken sorting algorithm: shuffle elements around until you get bored or throw up. The resulting list is indistinguishable from a sorted one... or any other list
17:22:02 <tensorpudding> i bet they have excellent algorithms for drunkards walks
17:22:07 <djahandarie> Haha
17:22:17 <nolrai_FG> At least its faster then bozo sort.
17:22:34 <Berengal> I have seen production code that had a global variable "Hashtable hashish"
17:23:11 <theorbtwo> nolrai_FG: Hey, bozo sort is quite fast -- as viewed from the universe that still exists.
17:23:14 <tensorpudding> i wonder if they rolled their own hashtable
17:23:28 <Berengal> Naw, it was the standard java one
17:23:35 <Berengal> The old one, from before generics
17:23:36 <djahandarie> theorbtwo, lol quantum
17:24:27 <Berengal> I'm going to whore my latest creation again: http://85.200.142.237:5000/ and http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17126
17:25:21 <copumpkin> Berengal: nice
17:25:37 <theorbtwo> Intresting style of HTML indentation.
17:25:37 <copumpkin> you already met me?
17:25:48 <monochrom> Nice
17:25:49 <djahandarie> Yeah, it said it already met me.
17:25:58 <copumpkin> that response is hardcoded in
17:26:00 <Berengal> copumpkin: We met on the first request
17:26:03 <copumpkin> lol
17:26:08 <copumpkin> but you didn't know my name!
17:26:11 <copumpkin> this is a violation of etiquette!
17:26:15 <Berengal> Doesn't mean we didn't meet
17:26:28 <Berengal> HTTP is weird like that.
17:26:30 <MissPiggy> Berengal is there a stand alone webserever?
17:26:35 <Berengal> (But I fixed it)
17:26:38 <Saizan> actually, on the third request you're engaged.
17:26:43 <Berengal> MissPiggy: Yep
17:26:49 <theorbtwo> Oh, from the code, that's very cute.
17:27:17 <MissPiggy> that's it??
17:27:30 <monochrom> Berengal: How come you have two nest html's? :)
17:28:17 <Berengal> monochrom: The ToResponse instance of XHtml is a bit buggy in that regard
17:28:18 <monochrom> s/nest/nested/
17:29:08 <Berengal> What the actual html looks like isn't the interesting bit anyhow
17:29:37 <ben> I missed the interesting bit
17:29:49 <Berengal> ben:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17126
17:30:08 <ben> it is a form that says "so we meet again" when I press the button? I could do that in javascript!
17:30:51 <Berengal> Also, if the page itself seems a bit buggy, that's probably because I'm using global state and some other schmuck is ruining it for you
17:31:28 <monochrom> Berengal: Does "WebCont" mean you have a Cont monad?
17:31:46 <Berengal> ben: But could you write a client-server conversation with multiple request/response cycles as a single sequence in javascript?
17:31:59 <Berengal> monochrom: It does. The implementation is also on hpaste
17:32:05 <copumpkin> Berengal: eww that you have html inline with logic though ;)
17:32:19 <monochrom> This is going to be very powerful.
17:32:22 <Berengal> copumpkin: example1 and example2 don't. They use strings :P
17:32:24 <ben> That sounds like a leading question
17:32:40 <Berengal> Well, example2 uses an int...
17:32:41 <copumpkin> Berengal: very neat though :)
17:32:50 <copumpkin> I love the Cont
17:33:06 <Berengal> example2 = foreverFrom 0 $ \i -> do yieldResponse ("Counting at " ++ show i); return (i + 1)
17:33:15 <copumpkin> Berengal: you should compete with Smerdyakov and write it in agda ;)
17:34:09 <Polarina> Is Data.HashTable any better than Data.Map?
17:34:18 <SamB_XP> Polarina: worse!
17:34:24 <Polarina> o.O
17:35:02 <Berengal> copumpkin: first reaction: That would be awesome. Second reaction: Wait, what? Someone's already doing this in Agda?
17:35:24 <ben> this is your data; this is your data on hash
17:36:17 <SamB_XP> Berengal: he's probably doing it in Coq!
17:36:24 <copumpkin> Berengal: he didn't do it in agda, but he's got his own: http://www.impredicative.com/ur/
17:36:29 <MissPiggy> Ur is written in SML
17:37:08 <Berengal> ben: You forgot the actual data: "This is your data: 'Hello world!'. This is you data on hash: 'ac541f3f5054d'
17:38:04 <Berengal> copumpkin: Ah, Ur does seem interesting. I haven't looked to much into it though. Does it have conversations?
17:38:36 <Polarina> For something that would generally be around 4 - 128 elements (random things), which is better? A HashTable or a Map?
17:38:54 <copumpkin> Polarina: in haskell, always a Map :)
17:39:00 <Polarina> copumpkin, Ok, thanks. :)
17:39:03 <copumpkin> maybe an IntMap if you have integer or enumerable keys
17:39:04 <Berengal> Polarina: HashTable has fast lookups, but is horrible if you want mutation
17:39:12 <SamB_XP> Polarina: I still don't get why HashTable exists
17:39:13 <Polarina> Berengal, Mutation?
17:39:25 <Berengal> Polarina: Insertion, deletion, modification etc.
17:39:31 <Polarina> Ah.
17:39:38 <Polarina> Then Map would suit me better. :)
17:40:16 <Berengal> The irony is that HashTable is a mutable structure...
17:40:32 <monochrom> SamB_XP: The supply existed because there was much demand. It was a long time ago and people in the know did not stress "just use Data.Map" enough.
17:41:19 <MissPiggy> implement the webserver in Ynot!!!!
17:41:29 <MissPiggy> or do an Ur compiler in Ynot!
17:41:54 <Polarina> Why is the type of Data.Map.lookup so weird and awkward?
17:41:57 <Berengal> @google Ynot
17:41:58 <lambdabot> http://www.ynotpizza.com/
17:41:59 <lambdabot> Title: YNot Pizza and Italian Cuisine in Great Neck and Kempsville, Virginia Beach
17:42:07 <theorbtwo> :t Data.Map.lookup
17:42:08 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
17:42:13 <Polarina> Weird.
17:42:19 <Polarina> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
17:42:24 <Polarina> Says my documentation.
17:42:36 <Berengal> Polarina: That's the old lookup
17:42:39 <SamB_XP> Polarina: what are you using?
17:42:40 <Polarina> Oh.
17:42:42 <SamB_XP> GHC 6.2?
17:42:47 <Polarina> SamB_XP, http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Map.html#v%3A!
17:42:52 <reorg> how does one implement floyd-warshall in haskell w/o using mutable data structure?
17:43:09 <Berengal> SamB_XP: Wasn't it Monad m => m a as late as 6.8 though?
17:43:17 <SamB_XP> what does warshal add to the game ?
17:43:32 <SamB_XP> Berengal: I can't remember, and I was using hyperbole anyway
17:43:46 <SamB_XP> I'm not positive I've even used 6.2 myself
17:44:02 <copumpkin> reorg: using a histomorphism!
17:44:10 <copumpkin> ;)
17:45:14 <reorg> copumpkin: can you elaborate?
17:46:19 <copumpkin> reorg: http://www.cs.ioc.ee/~tarmo/tday-viinistu/kabanov-slides.pdf might be more inspiring
17:47:03 <copumpkin> I'm not really suggesting you explicitly use a histomorphism but just because most pseudocode for FW uses mutation doesn't mean that it's inherently mutable
17:48:22 <copumpkin> you could probably do it quite nicely with a lazy array
17:48:58 <Berengal> loeb!
17:49:03 <copumpkin> :)
17:49:07 <monochrom> Is the algorithm really full of mutations or is it just write-once?
17:49:10 <copumpkin> what's a nice way to write a 2d loeb
17:49:33 <Berengal> copumpkin: As in what? A 2d array?
17:49:35 <SamB_XP> monochrom: the floyd one seems to write n arrays, once each
17:49:51 <SamB_XP> n n*n arrays, that is
17:50:04 <copumpkin> it's using the same array over and over again
17:50:09 <reorg> copumkin, so the array has to have some function ref to intermediate results?
17:50:10 <copumpkin> in the pseudocode on that page
17:50:25 <copumpkin> a lazy array won't be sufficient but it might be a part of your solution
17:50:25 <SamB_XP> copumpkin: well, sure, that's the way imperative people like to present it ;-P
17:50:33 <copumpkin> SamB_XP: yeah, I know :)
17:50:48 <copumpkin> lazy array of lazy lists! :P
17:51:08 <monochrom> OK so http://www.haskell.org/haskellwiki/Dynamic_programming_example is going to help.
17:51:26 <Berengal> I wonder if any array-mutation scheme can be written as loeb over an array of fixpoints...
17:51:34 * copumpkin really hates the term "dynamic programming" btw
17:51:52 <reorg> monochrom/copumkin, thanks for the links
17:51:53 <SamB_XP> yeah, it really seems to mean "cram it in a lazy array!"
17:52:05 <monochrom> It is a very old term. Before computer programming. "programming" is as in "linear programming", planning.
17:52:13 <Berengal> Dynamic programming is anything that happens beyond a branch
17:52:40 <copumpkin> "optimal substructure" also bothers me
17:53:01 <Berengal> Does optimal and sub commute?
17:53:15 <SamB_XP> sub-optimal structure ?
17:53:19 <Berengal> :)
17:53:29 <monochrom> In the imperative programming world, or rather the eager world, dynamic programming is a big deal because you have to manually figure out and specify the correct f**king order of filling the array!
17:53:30 <SamB_XP> ... seemingly the answer is no ;-P
17:54:41 <Berengal> monochrom: This is why loeb is awesome
17:54:49 <reorg> what's loeb?
17:55:09 <QtPlatypus> Thanks reorg I was just about to ask that.
17:56:05 <Berengal> reorg: It's a function that transforms a functor of functions from functor of a to a to a functor of a by mapping an application to its own result over the functor
17:56:23 <copumpkin> :t fix (ap sequence)
17:56:24 <lambdabot> forall a. [[a] -> a] -> [a]
17:56:26 * Berengal makes much sense today
17:56:26 * monochrom snickers
17:56:41 <copumpkin> @let loeblist = fix (ap sequence)
17:56:42 <lambdabot>  Defined.
17:57:05 <monochrom> How about this: a vast generalization of the dynamic programming example (so that e.g. not confined to arrays).
17:57:40 <copumpkin> > loeblist [(!! 3), const 4, (+4) . (!! 0), (*6) . (!! 1), const 7]
17:57:41 <SamB_XP> Berengal: I think you need to go back to suess school, sorry!
17:57:41 <lambdabot>   [24,4,28,24,7]
17:58:02 * copumpkin is at suess' school!
17:58:33 <copumpkin> Seuss, even :)
17:59:09 <monochrom> Dr. Seuss and the cat in the hat in the loeb.
17:59:16 <SamB_XP> copumpkin: yeah, yeah, I can't spell, I know!
17:59:52 <Berengal> > let loeb f = let x = loeb f in fmap (\f' -> f' x) f in loeb (const 0:[\l->(l!!i)+1 | i <- [0..]])
17:59:52 <SamB_XP> I just mean his poetry needs work to compre with "A parser for things ..." ;-P
17:59:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:00:17 <copumpkin> QtPlatypus, reorg: it's basically a spreadsheet
18:01:27 <Berengal> @type let loeb f = let x = loeb f in fmap (\f' -> f' x) f in loeb
18:01:28 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
18:01:39 <monochrom> So, the other day I was at the dental office, and I was waiting. The Dr. Seuss's cat-in-hat book was around, so I read it. Yes, the very first time I read any Dr. Seuss book at all. Bear in mind I grew up in Hong Kong a long time ago, no Dr. Seuss, or maybe too expensive.
18:01:40 * copumpkin prefers his version
18:01:54 <halcyon10> is it possible that ghc caches function values though i didn't tell it explicitly by passing the result on?
18:02:05 <copumpkin> :t fix (ap Data.Traversable.sequence)
18:02:06 <lambdabot> forall (t :: * -> *) a. (Data.Traversable.Traversable t) => t (t a -> a) -> t a
18:02:20 <copumpkin> not quite as general though :(
18:02:39 <Berengal> Does it share the final result?
18:02:48 <Berengal> It guess it would, because of how fix is implemented
18:02:59 <copumpkin> > loeblist (const 0:[\l->(l!!i)+1 | i <- [0..]])
18:03:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:03:21 <reorg> is it always unbounded?
18:03:29 <copumpkin> no, the first example I gave was bounded
18:03:40 <copumpkin> > loeblist [(!! 3), const 4, (+4) . (!! 0), (*6) . (!! 1), const 7]
18:03:41 <lambdabot>   [24,4,28,24,7]
18:03:41 * Berengal remembers solving the collatz PE problem by loebing a trie. Good times
18:04:09 <micah> in cabal, I have both parsec 2.x and 3.x installed
18:04:11 <copumpkin> reorg: the consts are values in your spreadsheet
18:04:17 <micah> how do I make the installation of something use 3.x
18:04:21 <copumpkin> reorg: the others depend on other values in the spreadsheet
18:04:25 <micah> becuase it thinks that I don't have 3.x
18:04:50 <monochrom> I don't have that problem.
18:04:57 <Berengal> micah: Set the version in your cabal file, if you're using cabal, or give the package to ghc when building with the -package flag
18:05:19 <micah> well I'm saying runhaskell Setup.hs configure
18:05:21 <micah> to build hoc
18:05:37 <micah> and it says I need parsec>=3.0
18:05:38 <luqui> what does "loeb" mean.  i mean the name, where does it come from?
18:05:52 <copumpkin> not sure, I first heard about it in here :)
18:05:53 <Berengal> luqui: It's a guy's name
18:05:54 <MissPiggy> the lob is a mathematician
18:06:00 <reorg> so i think i get the idea, though the example is still a bit overwhelming
18:06:05 <copumpkin> schloeb on my knoeb
18:06:06 <MissPiggy> he proved a lob (meta)theorem about peano arithmetic
18:06:09 <Berengal> reorg: loeb is like fix on steroids
18:06:14 <MissPiggy> something about  is PA claims PA proves P then P
18:06:16 <luqui> ah if it were spelled with an umlaut i would have made the connection
18:06:17 <Berengal> it takes some rewiring
18:06:38 <micah> anyone know why runhaskell Setup.hs configure isn't recognizing that parsec 3.0.1 is installed?
18:06:41 <MissPiggy> obviously this haskell stuff is a computational interpretation of the proof (or at least, some kind of absouletly irrelevant thing which has a similar type)
18:06:48 <Berengal> micah: Try --user
18:07:00 <MissPiggy> @go cartoon guide to lob theorem
18:07:00 <lambdabot> Maybe you meant: google googleit do
18:07:03 <luqui> do people use it just because it is useful, or does it have a nice optimization structure or property or something too?
18:07:09 <MissPiggy> yeah I did mean google...
18:07:31 <micah> aha that worked
18:07:31 <micah> thanks
18:08:01 <monochrom> luqui: Loeb is really Lb.
18:08:13 <luqui> right.
18:08:14 <Berengal> luqui: Personally, I don't really use it that often. It's in my bag-o-neat-tricks, along with the function instances of monad, monoid, applicative and arrow
18:08:18 <MissPiggy> @google cartoon guide to lob theorem
18:08:20 <lambdabot> http://yudkowsky.net/rational/lobs-theorem
18:08:20 <lambdabot> Title: Yudkowsky - Lb's Theorem
18:08:31 <MissPiggy> this is the best explanation of the proof
18:08:32 <monochrom> heh cartoon guide
18:08:34 <luqui> i am starting to use said (->) instances more.
18:08:43 <MissPiggy> but I gather that the haskell version here is nothing to do with that proof
18:08:58 <Berengal> luqui: I use it to write incomprehensible expressions larger than xbox
18:09:21 <MissPiggy> since (1) it uses non-wellfounded recursion (2) it's been generalized beyond the point of reason
18:10:28 <hotaru2k3> there's no such thing as too much generalization
18:10:39 <MissPiggy> peano arithmetic, some kind of godel style meta logic what-do-you-call-it
18:11:01 <monochrom> Haha nice cartoon. Thanks.
18:11:44 <tensorpudding> i vaguely remember that there was an instance of Monad for Either, where might I find it?
18:11:45 <Berengal> MissPiggy: If you look at the types as propositions, then the implementation is a proof of that proposition
18:12:00 <dolio> In logical terms, it'd likely be encoded in modal logic.
18:12:20 <dolio> [] ([] P -> P) -> [] P
18:12:28 <doserj> tensorpudding: Control.Monad.Error
18:12:29 <dolio> [] being the modal operator.
18:12:37 <tensorpudding> rather, (Either a)
18:12:40 <tensorpudding> hmm thanks
18:13:58 <tensorpudding> it seems that mtl and monads-fd both provide it
18:14:29 <dolio> One instantiation of modal logic is provability logic, which is what the original theorem would probably be encoded in, I guess.
18:15:37 <luqui> Berengal, but it uses fix, so it's not much of a proof...
18:16:37 <gwern> 'Apple noted that only $20 million had been invested in Be so far, and its offer represented a windfall, especially in light of the fact that the BeOS still needed three years of additional expensive development before it could ship (it didn't have any printer drivers, didn't support file sharing, wasn't available in languages other than English, and didn't run existing Mac applications). Direct talks between Amelio and Gasse broke down over price ...
18:16:43 <gwern> ... just after the Fall Comdex trade show, when Apple offered $125 million. Be's investors were said to be holding out for no less than $200 million, a figure Amelio considered "outrageous." '
18:16:50 <Berengal> luqui: It's a partial proof, i.e. it's a proof if it's used to prove correct things :P
18:16:59 <gwern> not the greatest tech corporate screwup, but still reasonably impressive
18:17:00 <luqui> lol
18:17:50 <Berengal> s/if/iff/
18:19:06 <gwern> 'On December 20, Apple announced its intention to purchase NeXT Software in a friendly acquisition. When the deal went through on February 4, 1997, the total purchase price, including the fair value of the net liabilities assumed, was $427 million, which comprised $319 million in cash, 1.5 million shares of Apple stock (valued at $25 million), options on 1.9 million shares (valued at $16 million), cash payments of $56 million to the NeXT debtholders, ...
18:19:12 <gwern> ... cash payments of $9 million for closing and related costs, and $2 million of net liabilities assumed.' <-- so 200m for Be was too much, but 427m for nextstep is fine?
18:21:10 <p_l> gwern: NeXT was much more of an established platform than BeOS
18:21:22 <gwern> yes, and how much of it really went into os x?
18:21:28 <gwern> 437m worth?
18:21:29 * kmc wonders whose options valuation that is
18:22:10 <p_l> gwern: OSX is NeXT with different driver framework, display drivers and of course updated&new apps
18:22:23 <p_l> at least that's my impression from short encounter with it
18:22:24 <luqui> If the result of substituting "If the result of substituting x for 'x' in x is provable, then C" for 'x' in "If the result of substituting x for 'x' in x is provable, then C" is provable, then C.
18:22:26 <gwern> really. I thought it was 'FreeBSD with ...'
18:22:28 <luqui> yes, how very clear...
18:22:33 <p_l> gwern: nope
18:22:42 <p_l> gwern: the BSD bits were there in NeXT too
18:24:09 <mreh> parallelism in haskell is amazing!!!
18:24:29 <p_l> and there were some references to OSF/1 code in Darwin, so I guess OSF/1 was used in NeXT as well, and the most known OSF/1 implementation was based on Mach kernel and based off BSD (like original CMU Mach, as well)
18:24:29 <gwern> no it isn't
18:24:46 <mreh> parallelism haskell in amazing is !!!
18:24:53 <gwern> now, if we had ever get auto-parallelization, that'd be mindblowing. 2x for free?
18:25:12 <mreh> gwern: where can you get that?
18:25:18 <p_l> gwern: OSX is probably in similar way a 'FreeBSD with Aqua and Objective-C' as NT5.x is, I guess ;-)
18:25:23 <gwern> mreh: in abandoned ghc forks
18:25:27 <mreh> if you're writing recursive code the thing practically writes itself
18:25:47 <kmc> err many things are recursive and not easily parallelized
18:26:11 <mreh> is there a parallelised fold?
18:26:25 <gwern> @hoogle parfold
18:26:26 <lambdabot> No results found
18:26:30 <gwern> @hoogle parmap
18:26:31 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:26:51 <mreh> kmc: can you give an example?
18:27:09 <kmc> mreh, factorial?
18:27:15 <luqui> mreh, what strategy would parallelized fold use?  fold over lists follows an iterative structure.
18:27:39 <luqui> but there is a parallelized mconcat :-)
18:28:21 <mreh> :t mconcat
18:28:22 <lambdabot> forall a. (Monoid a) => [a] -> a
18:28:37 <gwern> @hoogle par
18:28:37 <lambdabot> Control.Parallel par :: a -> b -> b
18:28:37 <lambdabot> Text.Html paragraph :: Html -> Html
18:28:37 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
18:28:40 <gwern> huh
18:28:48 <ddarius> mreh: It would be (very) easy to make a parallel fold based on monoid.
18:30:13 <mreh> I'm doing it for something that could be generalised to a sum . map f
18:30:27 <mreh> I don't really understand monoids yet
18:30:49 <gwern> monoids turn out to be very easy
18:30:52 <kmc> a monoid is like a burrito in a spacesuit
18:30:54 <gwern> I find them much easier than monads
18:31:09 <kmc> there's not much to understand
18:31:20 <kmc> a monoid is any type with "zero" and "addition"
18:31:32 <kmc> such as 0 and (+) or [] and (++)
18:31:47 <kmc> they're not parametrized like monads are
18:31:54 <ddarius> "one" and "multiplication" would have slightly better intuition.
18:31:57 <kmc> yeah that's true
18:32:23 <ddarius> 1 and (*) do, also, form a monoid on (most) numeric types, such as Int.
18:32:36 <ddarius> Excluding 0
18:32:44 <ddarius> Er, I retract that exclusion.
18:32:51 <kmc> 0 has no inverse, so it's not a group
18:32:52 <mreh> lol
18:32:54 <kmc> but it is a monoid
18:33:00 <mreh> 0 * 1 = 0
18:33:12 <mreh> * 1 = id
18:33:35 <ddarius> mreh: Indeed, every monoid gives rise to and endofunction monoid on itself.
18:33:36 <mreh> this seq in Data.parallel, is that a deep seq?
18:33:41 <ddarius> mreh: No.
18:33:42 <kmc> no
18:33:44 <kmc> it's the regular seq
18:33:47 <mreh> goodo
18:33:52 <kmc> weak head normal form
18:33:59 <mreh> kmc okay, thanks
18:34:04 <kmc> you cannot reduce a type further than that without knowing its structure
18:34:10 <kmc> e.g. the class NFData
18:34:45 <ddarius> You can't reduce a type that much without a magic built-in operator.
18:35:08 <mreh> is there some option to enable parallelism in ghc?
18:35:10 <kmc> polymorphic seq is a little magical
18:35:17 <kmc> but polymorphic deepseq would be very magical
18:35:20 <kmc> mreh, what do you mean?
18:35:26 <kmc> mreh, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
18:35:29 <mreh> kmc: my code isn't running on both cores
18:35:30 <ddarius> kmc: Not really any more than seq.
18:35:34 <mreh> probably because it's wrong
18:35:36 <kmc> mreh, you've got to compile with -threaded
18:35:40 <kmc> then run with +RTS -N5
18:35:43 <kmc> if you have 5 cores
18:35:56 <kmc> you also might want to compile with -feager-blackholing
18:36:07 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
18:37:48 <kmc> it's a good question.  can you write classless deepseq using something like vacuum?
18:38:08 <kmc> you can enter a closure, then read its layout and recursively enter all its pointer-typed fields
18:38:27 <kmc> however i think it'd be a pain in practice given the number of special case closure types supported by ghc's runtime
18:44:45 <mreh> i've read those docs
18:45:12 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17130#a17130 -- however, is this correct
18:45:36 <mreh> i'll write fib to test to see if it actually works on my system
18:48:36 <kmc> mreh, with par you sometimes want to use pseq rather then seq
18:48:42 <kmc> i can't explain the exact difference
18:48:58 <mreh> kmc: ?
18:49:02 <kmc> '?'?
18:50:18 <mreh> kmc: is there an explanation?
18:50:31 <kmc> yes, one which i do not know
18:50:38 <micah> for yi I need hoc-foundation and hoc-appkit
18:50:40 <micah> where can I get these
18:50:48 <kmc> mreh, i'm suggesting you investigate this further
18:51:24 <mreh> > fib 10
18:51:25 <lambdabot>   Not in scope: `fib'
18:51:40 <luqui> i think it has to do with thrwarting strictness analysis
18:52:23 <dolio> seq is strict in both arguments, so it has no guarantee on evaluation order.
18:52:31 <roconnor> what's the deal with type class morphisms?
18:52:42 <kmc> mreh, see http://haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html
18:53:04 <dolio> a `seq` b is not guaranteed to evaluate a before b, it's just that the result depends on evaluating both.
18:53:17 <dolio> a `pseq` b is guaranteed to evaluate a before b.
18:53:18 <luqui> dolio, whereas pseq is strict in both arguments, but ghc thinks it is only strict in... the left one?
18:53:36 <mreh> I was reading the old docs
18:54:19 <roconnor> dolio: what's the point of seq then?
18:55:13 <dolio> Which is important in a `par` b `pseq` f a b, because you don't want the evaluator to decide to evaluate f a b first, which might evaluate a and b in the same thread, and then go to evaluate a `par` b with no work to do.
18:55:21 <dolio> The point of seq is to introduce strictness.
18:55:31 <luqui> roconnor, what about them?
18:56:45 <luqui> i wish we could have a less operational basis for parallelism.  how could you construe a `par` b as different from b denotationally?
18:57:49 <roconnor> luqui: type class morhpisms seem to be either obvious or meaningless
18:57:56 <roconnor> or I don't get them.
18:58:03 <luqui> yeah that's kind of the point :-)
18:58:21 <luqui> the obviousness, rather.
18:58:33 <dolio> The most obvious implementation of seq just does what everyone thinks it does. But the compiler is free to reorder things.
18:58:33 <micah> roconnor
18:58:37 <micah> I think I have seen you before
18:58:43 <luqui> but formalizing them makes you realize when you are breaking them
18:58:46 <dolio> And it helps strictness analysis.
18:58:50 <luqui> whereas before you only realized when you are satisfying them
18:59:01 <roconnor> micah: could be
18:59:21 <micah> do you have anything to do with game maker? or I might have seen you somewhere else
18:59:53 <roconnor> I don't know what game maker is
18:59:57 <micah> ok
19:01:06 <roconnor> luqui: what is them that I am breaking or statifying?
19:01:36 <luqui> roconnor, eg. if you have a data type Foo a whose semantics is supposed to be Int -> a, and you have a functor instance which means something other than (.), you have done something wrong.
19:01:55 <luqui> it's all about semantics -- data types meaning something other than their representation.
19:02:09 <luqui> and TCM ensures that your instances are consistent with that meaning
19:03:25 <roconnor> Does Int -> a have only one functor instance?
19:03:56 <roconnor> luqui: anyhow I guess it is obvious then.
19:04:39 <roconnor> question
19:04:56 <roconnor> are the semantics of Foo a exactly the semantic given by the algebraic data type
19:05:17 <roconnor> or can they be this algebraic data type modulo some equivalence relation.
19:05:53 <luqui> not sure i follow.  But if I do, yeah they can be a quotient.
19:05:59 <luqui> or anything else for that matter
19:06:00 <roconnor> eg, are the semantics of Ratio Integer pairs of integers or is it rational numbers?
19:06:10 <luqui> as long as you have a meaning function.
19:06:44 <gwern> it's too bad TH sucks
19:06:44 <roconnor> I don't see how this idea is worth a paper
19:06:55 <luqui> oh are you asking in the case that the constructor is exposed?
19:07:12 <ddarius> roconnor: I have an LtU post that I think explains the situation.
19:07:12 <roconnor> luqui: let's stick to abstract data types
19:07:18 <gwern> if TH didn't suck, we could do lightweight compile-time checking - like smart constructors at compile
19:07:21 <roconnor> ddarius: oh?
19:07:23 <luqui> Yeah i'm not sure it is either.  I think conal did a better job of explaining denotational design in context
19:07:39 <luqui> i.e. I got the idea much more strongly reading the Fran paper than the TCM paper
19:08:51 <luqui> roconnor, if it's abstract, then of course it can mean the rationals.  as long as all your operations are invariant to which representative of the class you use.
19:09:59 <micah> I need hoc-appkit and hoc-foundation
19:10:03 <micah> does anyone know where to get them
19:10:08 <luqui> though the more I am exposed to it, the more TCM is meaning to me.  Eg. it informed me that if Image's semantics are = R2 -> (Color, a), then Color has to be a monoid.
19:10:44 <luqui> either that or I don't get Applicative...
19:10:57 <luqui> kind of weird that I consider these constraints a good thing...
19:11:45 <roconnor> luqui: why do you think it has to be a monoid?
19:11:50 <ddarius> roconnor: See http://lambda-the-ultimate.org/node/3215#comment-47270 and the context.
19:12:36 <luqui> because Applicative f => Applicative ((r ->) . f); and  Monoid m => Applicative (m,)
19:12:39 <ddarius> roconnor: The short version is Conal is effectively choose a target semantic algebra (i.e. domain + selected operations) and not just a target semantic domain.
19:12:59 <luqui> ddarius, i like that compact description!
19:13:20 <ddarius> roconnor: TCM then reduces to requiring the meaning (semantic) function to be an algebra homomorphism and not just a (continuous) function.
19:13:28 <Alpounet> haskell talk : check.
19:13:52 <luqui> roconnor, oh yeah, and (Applicative f, Applicative g) => Applicative (f . g)
19:13:55 <roconnor> luqui: I don't see how this helps,  I mean a -> a is a monoid in two different ways (when a is a monoid)
19:14:26 <luqui> roconnor, I don't see any Endos here...
19:14:41 <luqui> but do you mean *which* Color monoid do we pick?
19:14:57 <roconnor> I don't see any anything in R^2 -> (colour,a)   (BTW, what is a?)
19:15:12 <luqui> roconnor, type parameter.  Image a = R^2 -> (Color, a)
19:15:22 <roconnor> in fact a is always a monad in lots of ways
19:15:30 <roconnor> there is the always left monoid
19:15:33 <roconnor> and always right monoid
19:15:44 <roconnor> er
19:15:46 <roconnor> hmm
19:15:47 <roconnor> anyhow
19:16:12 <luqui> yeah but haskell has one-instance-per-type, and TCM is about typeclasses...
19:16:22 <luqui> so really every type is only a monoid in one way.
19:16:23 <luqui> at most
19:16:49 <luqui> sorry, types are monoids in multiple ways, but every type is a Monoid in at most one way.
19:17:29 <dolio> Always left and always right aren't monoids.
19:17:30 <luqui> i never realized how entangled with typeclasses the idea is.  maybe it's not and it just looks that way from here...
19:18:20 <luqui> Types are more than sets, they have structure.  I think the defined instances inform the target algebra.
19:18:50 <luqui> Eg.  absolute time reactive used Future a = (Max Time, a), but relative time used Future a = (Sum Time, a)
19:20:14 <ddarius> luqui: It isn't entangled at all.  As you say, type classes just give you means to (often implicitly) select the particular algebra you are using, but you could be more explicit.
19:20:52 <luqui> yeah just realized that. i'm kind of explaining my through my own understanding :-)
19:21:30 <dolio> I must confess, I have no idea why you think a "denotational" explanation of par and such would be better.
19:22:05 <dolio> The point of a `par` b is that it's denotationally identical to b, but the runtime gets some hints about useful parallelizations that it may or may not act upon.
19:22:22 <luqui> dolio, well i have no properties to reason with in the operational world.  and haskell has very non-local operational semantics, so it's hard for me to think about.
19:22:45 <dolio> And it's for deterministic parallelism, so no amount of par is supposed to change the results you get.
19:23:11 <roconnor> luqui: R2 -> (Colour, a) so you want this to applicative, but how do you know you want the (r ->) . f applicative instance and no some other applicative way of seeing R2 -> (Colour, a) ?
19:23:18 <luqui> dolio, i am looking for a more operational semantic domain.  like maybe [[X]] = (Distribution Time, X)
19:23:21 <dolio> Which is what denotational semantics is concerned with, the final result as some mathematical object. Not how you get there.
19:24:06 <luqui> roconnor, in light of my new understanding, I should say Image = (r ->) :. (Color,)
19:24:23 <ddarius> roconnor: You don't (know).
19:24:24 <luqui> (:.) is functor composition with Applicative structure.
19:24:47 <luqui> er, (R2 ->) :. (Color,)
19:26:17 <luqui> So I know because (:.)'s applicative instance told me
19:26:43 <ddarius> roconnor: What ends up happening is that you choose the "natural" instances of your semantic type, but as the Future example (Max v. Sum) shows, there isn't always an immediately obvious "most natural" choice.
19:29:08 <luqui> viewing types are more than sets has just given me a new appreciation of type classes, when my faith in them was waining
19:29:13 <roconnor> okay, but the type class laws (e.g. monoid laws) always were meant to apply to the semantic domain anyways?
19:29:24 <roconnor> so basically all this hoopla is over nothing
19:29:33 <roconnor> is it both obvious and meaningless.
19:29:38 <luqui> there shouldn't be very much hoopla.
19:29:52 <roconnor> conal seems to be big on it
19:29:58 <roconnor> he even wrote a paper
19:30:10 <luqui> I think the bigger idea is "denotational design"
19:30:17 <luqui> type class morphisms are an obvious consequence thereof
19:30:21 <ddarius> roconnor: There's less there than meets the eye (as in, TCM doesn't give you as much "for free" as some of the examples suggest) but it is certainly not meaningless.
19:32:15 <roconnor> luqui: why do you think that (R2 ->) :. (Colour,) is an applicative functor?
19:32:34 <luqui> because there is an instance...
19:32:54 <luqui> (R2 ->) is, (Color,) is (when Color is a monoid), and f :. g is whenever f is and g is
19:33:05 <roconnor> just because there is an instance dosn't mean you want to make the function an instance of it.
19:33:14 <luqui> roconnor, what function?
19:33:17 <roconnor> er
19:33:22 <roconnor> just because there is an instance dosn't mean you want to make the type an instance of it.
19:33:39 <luqui> true, but *if* that type does have an instance of Applicative, it had better be that one
19:33:45 <ddarius> roconnor: The type becomes an instance immediately.
19:34:12 <luqui> oh right, ddarius is more precise.  I mean the the type that means (R2 ->) :. (Color,)
19:34:13 <roconnor> ddarius: because how it is composed?
19:35:25 <ddarius> roconnor: Because, abstracting from Haskell somewhat, of what it is.  The type R2 -> (Color, a) (where Color is a monoid) simply -is- an applicative functor (as given by the liftings.)  Whether this structure is relevant and useful is a different question.
19:36:39 <ddarius> roconnor: The thing that removes a lot of bite from the TCM idea is that given an instance of a type class and a target semantic domain you -could- equip the target domain with the necessary structure to make the instance a TCM.
19:37:24 <ddarius> Which is to say, there is nothing inherently special about instances derived from the TCM conditions.
19:38:14 <roconnor> luqui: btw, there is another monoid instance for AlphaColour
19:38:25 <luqui> But I can define a whole lot of semantics just by saying what Image means and that it has "Functor, Applicative, and Monoid by TCM"
19:38:48 <luqui> roconnor, you mean other than the one in my post?
19:38:51 <luqui> (and your module)
19:39:34 <ddarius> Actually, this isn't quite true.  If you choose a large enough target semantic domain, where "large" means that the semantic function is not surjective, it is possible that it can't be equipped with the structure of the given type class.
19:39:52 <ddarius> These are the cases that lead to things appearing for free and strongly guided derivations.
19:39:58 <roconnor> luqui: no, there is an "additive" monoid for colours
19:40:09 <roconnor> luqui: but it is so stupid I don't even implement it in my library.
19:40:27 <ddarius> I.e. when full completeness fails, TCM potentially says something interesting.
19:41:05 <luqui> roconnor, additive in the color sense?  is it closed with components in  [0,1]?
19:42:38 <ddarius> Actually, Conal's move to "remove the junk" from FRP is anti-thetical to the TCM technique.
19:43:10 <roconnor> luqui: no it isn't closed in [0,1]
19:44:06 <roconnor> ddarius: what is the domain of the semantic function?
19:44:13 <luqui> syntax
19:44:37 <roconnor> but the syntax doesn't satify the monoid laws
19:45:05 <roconnor> "mempty" is not equal to "mempty `mappend` mempty"
19:45:19 <roconnor> I feel so confused
19:45:21 <luqui> ddarius, better than DD with TCM is direct representation, where your data types don't even need to be abstract.
19:46:20 <luqui> roconnor, you are managing to confuse me too :-)
19:47:08 <ddarius> Nothing inherently requires syntax to be lawless.
19:48:23 <ddarius> Indeed, the "generated" syntax from the Monoid type class would be the operations, mempty and mappend, -and- the laws.
19:48:29 <luqui> okay so TCM says the instance's meaning is the meaning's instance.   So if M is the semantic function, and let's say a typeclass C maps types to values.  Then M(C(t)) = C(M(t))... where that left C is your implementation
19:49:26 <luqui> I guess t here isn't syntax.  It's a type that is meant to mean another type M(t)
19:49:41 <luqui> man this is hard to formalize.
19:50:33 <luqui> so DD might be about typeclass homomorphisms?
19:51:56 <luqui> I like that.  The idea that there is only one meaning function does not make sense to me.
19:53:21 <luqui> a DD is a mapping between meanings:  the meaning of the representation as endowed by Haskell's semantics, and the target which is for humans to reason with.
19:55:31 <jmcarthur> luqui: i'm not sure i see where there are two meaning functions in that description. what do you mean?
19:56:16 <luqui> let's take the iso between Stream a and Integer -> a.
19:57:12 <luqui> Haskell's meaning function H(Stream a) talks about the domain Nu(a *)
19:57:13 <dolio> Natural -> a
19:57:18 <luqui> right Natural
19:57:37 <ddarius> I need to check that this produces the right thing, but one start at a formalization would be: Let F be a functor.  We can generate the free monad from F, call it T.  We can consider T-algebras, arrows TA -> A for a given A.  join gives a T-algebra, TTA -> TA.  A TCM would then be a T-algebra homomorphism from join.
19:57:56 <luqui> But "our" meaning function, talks about the domain (Natural -> a).  We will get two different meanings for every operation.
19:58:56 <luqui> woah!  using monads as theory modeling.  I have heard of that, but this is the first concrete example.  Um... let me study that for a few years.
19:59:01 * hackagebot upload: hs-gchart 0.1 - Haskell wrapper for the Google Chart API (DeepakJois)
20:00:38 <luqui> ddarius, I lost you at T-algebra.  Can you give a concrete analogue?
20:03:12 <ddarius> I believe for Monoid, the functor F would be F x = MEmpty | MAppend x x, but I'm not sure if the laws would then need to refer to F o F or if they could be presented otherwise.  The free T-algebra would be: T a = MEmpty | Var a | MAppend (T a) (T a).
20:04:03 <ddarius> (plus the laws)
20:04:19 <luqui> ddarius, oh here the A in TA -> A  is Hask?
20:04:32 <ddarius> luqui: In this case, yes.
20:05:31 <roconnor> When *I* define a data type I almost always have the semantics for the type in mind when I define all my operations.
20:06:12 <luqui> ddarius, and what role is join playing?
20:06:35 <luqui> i hope you don't mind me poking into your explanation to selfishly further my CT
20:06:37 <ddarius> luqui: It plays the role of the syntax, roughly the same role as an initial F-algebra (in other contexts).
20:06:53 <roconnor> isn't the TCM thing just saying that if I make a data type an instance of a Monoid then the semantics I have in mind should satify the monoid laws?
20:07:13 <ddarius> luqui: I'm somewhat making things up as I go along.  So I wouldn't put too much into this stuff yet.
20:07:34 <ddarius> roconnor: No, it's saying more than that.
20:07:58 <luqui> ddarius, well I have heard that a monad is the essence of a theory & a model, but I haven't been able to see how yet.
20:08:15 <roconnor> ddarius: what else is it saying?
20:08:41 <ddarius> A T-algebra homomorphism, f, from join would satisfy the following equation among others: f (MAppend (Var x) (Var y)) = mappend (f x) (f y)
20:09:43 <ddarius> roconnor: Not only is the semantic domain equipped with a monoid instance, but that your semantic function preserves it.  I.e. the Haskell monoid instance gets transformed into the (selected) semantic monoid instance.
20:10:32 <luqui> so roughly that the semantics you have in mind should satisfy the monoid laws, and that your implementation matches the semantics (?)
20:11:25 <roconnor> ddarius: what is the Haskell monoid instance?
20:11:43 <ddarius> roconnor: Whatever you wrote in you .hs file for the data type whose semantics you are describing.
20:12:00 <roconnor> luqui: that can't be right because the semantic operations are by definition the semantics of the operations I write in my implementation.
20:12:11 <roconnor> ddarius: but I just wrote strings
20:12:20 <roconnor> and strings don't satify monoid laws
20:12:24 <ddarius> luqui: For your semantics to satisfy the monoid laws, you'd first have to select operations.  So, its that you implementation corresponds to the -selected- semantic instance.
20:12:47 <ddarius> roconnor: No, the Haskell semantics of what you wrote.  You semantic domain is not Haskell's.
20:13:01 <roconnor> ddarius: you mean the denotation semantics of Haskell?
20:13:03 <luqui> at least in the nontrivial case.
20:13:20 <ddarius> roconnor: Yes.
20:13:25 <ddarius> s/You/Your
20:14:07 <vyom> how do I get hackage to generate haddock documentation for me.. it seems to be not doing that for my package http://hackage.haskell.org/package/hs-gchart
20:15:05 <ddarius> roconnor: If you are representing an image with an array of pixels, the Haskell semantics is an array.  The semantics you might be using may be a function R2 -> Color.
20:15:26 <ddarius> roconnor: Your semantic function would be a function from Haskell arrays, to functions R2 -> Color.
20:15:43 <VTimage> I know most of lisp but I hate the brackets! at the end of functions, etc it's like ))))))))))))
20:15:56 <VTimage> Haskell doesn't use these unsightly things does it?
20:16:44 <luqui> VTimage, the (.) and ($) operators help vastly in reducing the number of parens
20:17:19 <ddarius> VTimage: Find some example Haskell code somewhere on the internet and look at it.
20:18:16 <luqui> ddarius, Okay so F is syntax.  F x = MEmpty x | MAppend x x, saying how monoids can be built.  Then the free monad T from F says that monoids can be built with other things too, and have to be closed under Mempty and Mappend?
20:18:17 <VTimage> ok
20:18:58 <luqui> or is that the T-algrebra that says that?
20:19:07 <luqui> or am i way off base?
20:19:13 <roconnor> ddarius: but for example, my Completion monad isn't a monad in the haskell domain
20:19:35 <roconnor> because my monad laws are only satisfied upto real number equivalence
20:19:51 <roconnor> rather than equality of the underling haskell represenation of functions.
20:20:16 <vyom> anyone? how do I get hackage to generate haddock documentation for me? it seems to be not doing that for my package http://hackage.haskell.org/package/hs-gchart
20:21:23 <luqui> vyom, it takes a while.
20:21:28 <luqui> seems to take approx overnight.
20:21:37 <ddarius> roconnor: Well, if your semantic domain has structure that your implementation can't support, then, either your implementation is wrong or your semantics are simply unrealizable.
20:21:57 <vyom> luqui:  Thanks.. i will wait
20:22:07 <dolio> TA is like syntax trees of monoid expressions over A.
20:22:13 <roconnor> ddarius: oh my implementation supports it
20:22:20 <roconnor> ddarius: my semantic function isn't injective though
20:22:42 <luqui> dolio, oh, with *variables* from A?
20:22:45 <ddarius> roconnor: Is your implementation type constructor a Haskell Monad and does it satisfy the laws?
20:22:46 <dolio> T-algebras are like objects that can represent such syntax trees.
20:23:23 <luqui> dolio, I don't see why it is TA -> A  instead of TA -> B
20:23:30 <dolio> Or maybe not represent them, but interpret them into elements of A.
20:23:38 <ddarius> luqui: The initial F algebra for F x = MEmpty | MAppend x x subject to the monad laws is trivial, because we don't have any non-identity elements.  The T-algebra construction allows us to add "variables" to it.
20:23:50 <dolio> Where are the Bs going to come from?
20:24:11 <roconnor> ddarius: consider newType Unit = Unit Integer
20:24:12 <luqui> dolio, I thought it was a specific A
20:24:51 <dolio> A concrete A would be [Int].
20:24:52 <luqui> like T Nat -> Nat  is a T-algebra.
20:24:54 <roconnor> ddarius: and myzero = Unit 0 and myop a b = a
20:25:08 <roconnor> myzero and myop don't form a monoid in the haskell denotation
20:25:36 <dolio> So T[Int] has things that look like: MAppend MEmpty (MAppend [0,1] [2,3])
20:25:45 <roconnor> however if my semantic function is the function that maps everything to the singlton domain {*}
20:26:02 <roconnor> then myzero and myop *do* form a monoid.
20:26:10 <roconnor> under the semanatic interpretation
20:26:16 <dolio> I guess those lists should be wrapped in a Var.
20:26:27 <luqui> Oh so a T-algebra is like an instance?  T[Int] says instance Monoid [Int], roughly
20:26:30 <VTimage> Err any good haskell tutorials?
20:26:36 <ddarius> luqui: Yes.
20:26:52 <roconnor> and I'm justified in making instance Monoid Unit where mempty = myzero; mappend = myop
20:27:05 <dolio> Anyhow, [Int] is also a T-algebra, with the function f : T[Int] -> [Int] ; f MEmpty = [] ; f (Var l) = l ; f (MAppend l r) = f l ++ f r
20:27:10 <roconnor> espeically if I also define instance Eq Unit where a == b = True
20:27:21 <luqui> VTimage, there are a lot.  What drew you to haskell, what do you find interesting about it?
20:27:46 <VTimage> <VTimage> I know most of lisp but I hate the brackets! at the end of functions, etc it's like ))))))))))))
20:27:53 <VTimage> There you go.
20:27:59 <luqui> VTimage, haha.  so you have an FP background.
20:28:15 <VTimage> well I learned lisp about 30 minutes ago
20:28:18 <ddarius> roconnor: If the type was abstract and presented a small enough interface, then you would be justified (independent of the TCM stuff.)
20:28:29 <VTimage> read a tutorial on a college site
20:28:49 <luqui> VTimage, so what kind of languages do you know..
20:28:50 <VTimage> but I understand it
20:29:00 <luqui> dolio, thanks! this is helping a lot!
20:29:11 <luqui> ddarius too
20:29:17 <VTimage> Java, C/C++ Python, SQL (not really a programming lang)
20:29:24 <VTimage> and lisp
20:29:26 <VTimage> sorta
20:29:35 <Cale> @where lyah
20:29:35 <lambdabot> http://www.learnyouahaskell.com/
20:29:38 <Cale> @where rwh
20:29:38 <dolio> Int can also take on T-algebra structure, with either + or *.
20:29:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:29:44 <Cale> @where wikibook
20:29:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell
20:29:48 <Cale> @where yaht
20:29:48 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:29:56 <luqui> VTimage, yeah the two cale pointed out are good for a "popular" background like yours
20:29:57 <roconnor> ddarius: so I'm still missing the point onf this TCM stuff
20:29:59 <Cale> ^^ some potentially useful tutorial links :)
20:30:36 <VTimage> err which one is shortest
20:30:39 <VTimage> I hate reading long things
20:31:01 <VTimage> I'm guessing the wiki book
20:31:03 <VTimage> ?
20:31:07 <luqui> none of them are terribly terse
20:31:10 <luqui> :-(
20:31:33 <luqui> definitely not LYAH, it has many words
20:31:36 <ddarius> roconnor: The point isn't to -validate- an instance, that is completely up to the Haskell semantics as always.  It's a hygiene condition to verify that a valid instance corresponds to semantic structure that you specify and consider relevant, and this can be turned into a "derivation from specification" tool.
20:31:36 <Cale> Well, I don't know. It takes some time to learn Haskell, especially if you don't already know some variant of ML (and even then, there's enough to get used to)
20:32:01 <luqui> i haven't read YAHT in a while, but i remember it being dense and incomprehensible when i was first learning, so you may want to look into that :-P
20:32:10 <Cale> It took me about 2 months before I felt like I could really get useful things done with Haskell, and about a year to become comfortable.
20:32:31 <Cale> However, it's now my favourite programming language by a fairly decent margin.
20:32:42 <Cale> So, I think it's worth the effort required :)
20:32:52 <luqui> Cale, same for me.  Well, i'd say 6 months to get comfortable, and a year for it to firmly surpass its competition as my favorite language
20:33:07 <VTimage> http://www.haskell.org/tutorial/ is this still relevant
20:33:13 <VTimage> haskell version 98
20:33:16 <Cale> Of course, what it means to be comfortable is a bit hazy.
20:33:29 <Cale> VTimage: yeah, it's relevant, but not very gentle despite its name.
20:33:39 <ddarius> roconnor: So, for the R2 -> Color structure, if you deem blend :: (R2 -> Color) -> (R2 -> Color) -> (R2 -> Color) forms a monoid, then you can see what that requires of your (Haskell) monoid instance and whether your Haskell monoid instance matches your desired semantics.  If it doesn't then there is a mismatch between what you implemented and what you meant.
20:34:04 <VTimage> Is the latest version of haskell haskell version 98?
20:34:15 <Cale> VTimage: GHC implements a lot of extensions to the language.
20:34:24 <djahandarie> Wasn't 2010 released?
20:34:24 <nettok> I really like "learn you a haskell"
20:34:28 <VTimage> ok, but the core language hasn't really changed?
20:34:35 <Cale> VTimage: and there is an extremely conservative extension called Haskell 2010
20:34:47 <VTimage> 98 is the most used/popular?
20:35:07 <Cale> Actually for real work, you won't get by without a few language extensions.
20:35:21 <Cale> GHC is the implementation you probably want to go with.
20:35:31 <luqui> dolio, still can't quite wrap my head around the role of join here
20:35:43 <VTimage> but GHC is a superset of 98 isn't it?
20:35:45 <dolio> Where?
20:35:46 <Cale> But yeah, 98 is a conservative core language which you should learn first.
20:35:59 <VTimage> ok thanks
20:36:07 <luqui> dolio, when expressing syntax as a free monad over a functor
20:36:15 <Cale> You can pick up additional extensions as you need them.
20:36:37 <Cale> VTimage: Also, don't be afraid to ask any questions you might have here.
20:36:45 <VTimage> ok
20:37:11 <VTimage> At my college they teach Java in first year. At another they start off with haskell.
20:37:16 <roconnor> ddarius: what is a valid instance?
20:37:31 <Cale> Yeah, they're very different approaches to teaching computer science.
20:37:42 <VTimage> Indeed.
20:38:00 <ddarius> roconnor: A instance (in your source file) that type checks and satisfies any relevant laws.
20:38:11 <Cale> Java is a language which despite its actual age is, for the most part about 30 years old, as far as concepts go.
20:38:26 <dolio> luqui: Well, ddarius' point earlier was that TA is a T-algebra, with action join : TTA -> TA.
20:38:32 <VTimage> Yes.
20:38:55 <roconnor> ddarius: what do you mean by satisfies any relevent laws?
20:39:02 <dolio> I think that T-algebras for a monad T are usually expected to respect join and return, as well.
20:39:10 <VTimage> "C with classes" as they would call it?
20:39:12 <Cale> Actually, perhaps I should say 40, seeing as it is 2010 now :)
20:39:14 <luqui> dolio, but what does that mean for TA to be a T-algebra?
20:39:25 <roconnor> ddarius: you mean the laws as applied to the haskell denotations right?
20:39:26 <Cale> The ideas embodied in Haskell range from the late 80's through to present research.
20:39:31 <ddarius> roconnor: The monoid laws or the monad laws, ideally up to observational equivalence, but perhaps bending th erules slightly.
20:39:32 <luqui> models of a theory model the theory?
20:39:46 <ddarius> dolio: Yes.
20:39:48 <Cale> and the way that you write programs is fundamentally quite different
20:39:48 <ddarius> They are.
20:39:51 <roconnor> ddarius: there are a lot of problems here with partial elements and such
20:39:57 <VTimage> Haskell is the most popular functional language isn't it?
20:39:58 <Cale> So it can be a bit like learning to program all over again
20:40:11 <Cale> Hmm, I'm not sure which is the most popular.
20:40:26 <dolio> luqui: A T-algebra is a pair (A, a : TA -> A). Sometimes A is referred to as the T-algebra, loosely speaking.
20:40:27 <ddarius> roconnor: In some cases, but there are plenty of instances of classes with laws that are satisfied up to observational equality.
20:40:27 <roconnor> ddarius: I don't even know why we care if the haskell denotations satify the laws.
20:40:35 <Cale> Haskell is the most popular functional language which is particularly pure, at least.
20:40:39 <roconnor> ddarius: that seems totally irrelevent.
20:40:41 <luqui> comparing functional languages popularity is likely to be incorrect due to floating-point error.
20:40:45 <roconnor> ddarius: and almost always false.
20:40:48 <ddarius> roconnor: If they don't, then you can't soundly reason using them.
20:40:49 <VTimage> heh
20:40:51 <dolio> So that TA is a T-algebra means that you can equip it with an action like that.
20:41:09 <Cale> luqui: Heh, yeah, we might be into the denormalised range.
20:41:22 <roconnor> ddarius: you can sounds reason so long as the intended semantics satify the laws.
20:41:31 <dolio> And the action is supposed to respect return and join, so, that gives you some commutative triangles/squares.
20:41:48 <ddarius> roconnor: I'm talking about syntactic manipulations of the source code using the (assumed) laws.
20:41:50 <roconnor> ddarius: e.g. reverse is involutive so long as your indended semantics is to exclude infintie lists.
20:42:09 <roconnor> ddarius: heck I'm even told that IO isn't really a monad.
20:42:17 <ddarius> roconnor: But reverse isn't actually involutive, so replacing reverse . reverse with id is not sound.
20:42:25 <ddarius> roconnor: It should be.
20:42:43 <roconnor> > compare (0/0) (0/0)
20:42:44 <lambdabot>   GT
20:42:45 <luqui> dolio, okay a bit lost in abstract.  Take T as the free monad over monoid's syntax.  TTA -> TA means that... monoids of monoids of A's are monoids of A's?
20:42:53 <roconnor> > (0/0) == (0/0)
20:42:54 <lambdabot>   False
20:43:02 <luqui> I am quite lost by that last statement of mine.
20:43:10 <roconnor> ddarius: there are a million cases wher laws are not satified
20:43:19 <dolio> luqui: So, if T takes objects to syntax trees over said object, then T-algebras are objects that admit interpretation of said syntax trees in an appropriate way.
20:43:56 <roconnor> ddarius: but it is all fine because those cases are basically always outside our indended semantics
20:44:13 <roconnor> ddarius: and if the compiler ended up doing such subsitutions I wouldn't mind one bit.
20:44:17 <ddarius> roconnor: There aren't even millions of instances.  Potential instances that don't satisfy the laws are irrelevant unless they are the desired ones.  Most instances satisfy the relevant laws (if any.)
20:44:22 <luqui> So if you have a syntax tree of syntax trees, that can be interpreted as a syntax tree.  Sounds kind of like "tree" is the thing it is encoding.
20:44:42 <ddarius> roconnor: I don't have a problem with you bending the rules, if you want to talk about a Haskell semantics modulo bottoms that's fine and not very relevant.
20:44:45 <VTimage> Oh well I'm going to use http://www.haskell.org/tutorial/intro.html. Shouldn't be too hard to comprehend.
20:44:48 <ddarius> (To the TCM thing.)
20:45:35 <roconnor> ddarius: what about my abstract data type case?
20:45:53 <roconnor> ddarius: the Unit thing
20:45:57 <roconnor> why is that okay?
20:46:57 <ddarius> roconnor: I never said it was unless the type was abstract, in which case it would satisfy the laws up to observational equality.  I also stated that this is completely independent of the TCM idea.  The TCM idea doesn't make it okay.  That's not what TCM does.
20:47:10 <roconnor> I mean it is very common for the semantic function to be non-injective.
20:48:06 <ddarius> roconnor: That's irrelevant to the TCM idea since you will already need to have a relevant type class structure on both sides.
20:48:26 <ddarius> If you want to use a slightly different source domain than Hask, that doesn't change anything.
20:48:37 <dolio> luqui: Yeah, you can take a syntax tree of syntax trees over some set of atoms, you can splice them together to get a syntax tree over the atoms.
20:49:44 <roconnor> ddarius: when the semantic function isn't injective then equational laws will almost never be satified in the source domain, no matter what the source domain is.
20:49:55 <luqui> dolio, okay that is fairly straightforward and not as deep as I expected.  So a monad over a functor is a syntax tree that uses the functor as its primitives, and a T-algebra is an interpreter.
20:50:13 <roconnor> ddarius: so the semantic function doesn't preserve the laws in this case.
20:50:21 <roconnor> ddarius: TCM says this is bad
20:50:25 <roconnor> ddarius: but it isn't bad.
20:50:29 <dolio> Something like that, I guess.
20:50:38 <ddarius> roconnor: You are mashing two "semantic functions" together.
20:50:50 <roconnor> what two semantic functions?
20:51:17 * hackagebot upload: altfloat 0.3 - Alternative floating point support for GHC. (NickBowler)
20:51:34 <luqui> dolio, yeah roughly and I'm sure quite a bit too narrow.  but at least it's some intuition to start from. thanks :-)
20:51:37 <dolio> (TA, join : TTA -> TA) is probably the initial/free algebra.
20:52:47 <ddarius> roconnor: One going from Haskell terms to Haskell semantics (i.e. the denotational semantics of Haskell) and one going from Haskell terms to your explanatory semantics.  Only the former is relevant to equational laws.  The latter doesn't validate any equational laws in the source domain.
20:52:48 <dolio> So you can probably look at it as syntax. And then there's a category of algebras with structure respecting morphisms, of which the semantics would also be an object, I assume.
20:53:10 <dolio> And there'd be an algebra homomorphism from the syntax to the semantics.
20:53:38 <roconnor> ddarius: is id and (\x -> x) different haskell terms?
20:53:41 <luqui> dolio, ah, i see.
20:54:09 <dolio> I'm a bit weak in this area, as well.
20:54:20 <roconnor> ddarius: is "fmap id" and "id" different haskell terms?
20:54:53 <luqui> dolio, i find it very interesting because i am looking to liberate a programming language from the conventional idea of syntax and use something more formal
20:55:49 <luqui> kind of like a formal lisp, where you can have programs that act on syntax, but in a more meaningful and flexible way.
20:56:11 <roconnor> what I have strongly in mind is the case of my real numbers where a real number f is represented as a function from Rational -> Rational mapping postive epsilons to rational approximations
20:56:15 <luqui> still i have no idea what that means :-P
20:56:34 <roconnor> thus each real number has many many different representations
20:56:41 <ddarius> roconnor: For your explanatory semantics, you'd probably work with an quotient of Haskell terms ideally under observational equality, but choosing others would not be a problem.
20:57:13 <roconnor> and for example if f represents a real number and z = const 0 is a representation of zero, then I don't have f + z = f
20:57:27 <roconnor> since (f + z)(epsilon) = f(epsilon/2)
20:57:48 <roconnor> but f and f + z still both represent the same real number
20:57:55 <roconnor> which should be good enough.
20:58:31 <roconnor> ddarius: but you seem to be saying that I don't have a valid instance of Num
20:58:40 <ddarius> roconnor: If you can observe such differences, then that right unit law doesn't hold in Haskell.  If you want to fudge some, that's fine.
20:58:49 <roconnor> since (f + z)(epsilon) /= f(epsilion) in general
20:59:05 <roconnor> ddarius: you can observe such differences
20:59:28 <roconnor> ddarius: otherwise there is (almost) no way to convert a real number into something useable
20:59:58 <roconnor> because all total computable functions from the reals to any discrete space is constant.
20:59:59 <ddarius> roconnor: You don't have a valid instance because if I manipulate the source with the Num laws then I will get different answers.  If you want to use a different notion of equivalence that's fine and you can say it satisfies the laws "up to such-and-such an equivalence."  Again, this has nothing to do with the TCM idea.
21:00:31 <roconnor> damn
21:00:32 <ddarius> If you want to have the source domain of your semantic function for a TCM situation be "terms up to such-and-such an equivalence," fine.
21:00:37 <roconnor> so I'm still missing this TCM idea
21:00:48 <Draconx|Laptop> ddarius, is the Num instance for Double also invalid?  Should we get rid of it?
21:00:59 <roconnor> ddarius: then what is the difference between my source domain and my semantic domain?
21:01:33 <roconnor> because functions from Rationals to Rationals upto the equivalence I have in mine *are* the (constructive) real numbers.
21:01:39 <roconnor> have in mind
21:02:10 <luqui> roconnor, good then there is no need for TCM.  You have "direct representation"
21:02:11 <roconnor> Draconx|Laptop: no, cause that nothing to do with the TCM idea :D
21:02:14 <ddarius> roconnor: The source domain is what you are putatively implementing in, your (explanatory) domain has no requirements of computability, implementability, etc. and is whatever you want it to be.
21:02:43 <roconnor> ddarius: of course my explanatory domain has a requirement of computablity and implmentability
21:02:45 <ddarius> id is a perfectly fine type class morphism.
21:02:52 <roconnor> otherwise there is no point in writing code.
21:02:59 <ddarius> roconnor: Presumably your explanatory domain is the reals.
21:03:00 <Draconx|Laptop> roconnor, ah, I guess I missed part of the discussion.  I assumed that since Double violates basically every possible rule for Num instances you can come up with...
21:03:01 <ddarius> (all of them)
21:03:08 <luqui> roconnor, i think you are misunderstanding the purpose of an explanatory domain
21:03:10 <roconnor> ddarius: not me.
21:03:10 <ddarius> roconnor: That is what you are trying to model, no?
21:03:25 <roconnor> I care only about the constructive reals numbers
21:03:42 <roconnor> luqui: I think I am
21:03:59 <luqui> roconnor, as a mathematician, how do you define the constructive reals?
21:04:06 <luqui> they have many definitions afair
21:04:20 <roconnor> luqui: say for example the definition I give in Coq.
21:04:57 <luqui> roconnor, if you implement it the same way you define it, there is no difference between the source and explanatory domains, and TCM says nothing.
21:05:19 <roconnor> luqui: when would the source and explanatory domains ever be different?
21:05:45 <roconnor> I find it strange that the Rational -> Rational modulo real equivalence is the *source* domain
21:06:13 <luqui> roconnor, Image from graphics-drawingcombinators.  Explanatory domain is R^2 -> (Color, a), but source domain is Color -> Affine -> IO ()
21:07:38 <luqui> or reactive: explanatory domain is Time -> a, source domain is StreamT Future :. Fun Double
21:07:47 <luqui> (roughly)
21:08:07 <roconnor> luqui: what's the point of the extra fluff in the explanatory domain?
21:08:16 <ddarius> roconnor: The source domain is more the -interface- (hence talk of syntax) rather than the actual objects themselves.
21:08:21 <luqui> roconnor, what do you mean extra fluff?
21:08:37 <roconnor> luqui: actually what do you mean by Time ->  a?
21:08:50 <roconnor> luqui: you mean classical functions from the real numbers right?
21:09:06 <roconnor> including discontinous ones?
21:09:12 <ddarius> (However, the source domain can be anything.)
21:09:13 <luqui> roconnor, we mean something vague, because we haven't figured out the formal details :-P.  but roughly yes.
21:09:22 <ddarius> roconnor: Yes, such a representation has a lot of "junk".
21:10:17 <ddarius> roconnor: The extra junk doesn't correspond to anything but then the semantic function goes -into- it, not out of it so we are selecting only a part of it (i.e. the semantic function isn't surjective.)
21:10:40 <ddarius> The benefit is that (Time -> a) is a much simpler (if less precise) domain to work in than a highly precise one would be.
21:10:57 <ddarius> E.g. in your case, using the (classical) reals adds a lot of objects, but is nicer to work with (arguably).
21:11:09 <roconnor> heh
21:11:13 <roconnor> not really
21:11:19 <roconnor> but at least I understand
21:11:50 <roconnor> I'm trying to think of an example where I have used a non identity semantic domain function
21:12:09 <luqui> roconnor, surely whenever you use Data.Map
21:12:21 <ddarius> roconnor: Probably every -abstract- data type you've made or used falls under that case.
21:12:24 <luqui> balanced trees are hardly adequate to think in
21:13:04 <ddarius> I'll be back in about ten minutes or so.
21:13:19 <luqui> or skew-balanced or whatever the hell it is.  I can use it without understanding how it is implemented, which is pretty much a giveaway to a non-identity semantic function
21:13:37 <roconnor> luqui: no, ddarius said that I get to quotent balanced trees by the equivalence relation to get my *source* domain
21:13:40 <kamatsu> @pl pawnThread state (ThreadState v) = io $ forkIO $ runStateT v state
21:13:40 <lambdabot> (line 1, column 34):
21:13:41 <lambdabot> unexpected "="
21:13:41 <lambdabot> expecting variable, "(", operator or end of input
21:14:00 <roconnor> luqui: the resulting domain is isomorphic to finite maps after the quotient
21:14:04 <kamatsu> @pl pawnThread state v = io $ forkIO $ runStateT v state
21:14:04 <lambdabot> pawnThread = ((io . forkIO) .) . flip runStateT
21:14:24 <luqui> roconnor, hmm, i don't understand him then.
21:14:40 <luqui> maybe it's because various laws wouldn't hold on the instances.
21:14:45 <roconnor> luqui: just like my constructive real numbers (which are functions modulo an equivalence relation) are the *source* domain
21:14:55 <roconnor> luqui: while the classical real numbers could be a target domain
21:15:16 <luqui> i really don't know how quotients fit into the picture.
21:15:21 <roconnor> luqui: the law for addition wouldn't hold for the functions, only for the constructive reals
21:16:29 <roconnor> for a real number f, I have that "(f + 0)(epsilon) = f(epsilon/2)"  thus this identity fails when thing of functions
21:16:39 <roconnor> but it does hold upto equivalence
21:16:50 <luqui> roconnor, i think it is much more common in verified languages to use direct representation
21:17:05 <luqui> in fact i have never used a non-identity semantic function in agda or coq
21:17:09 <roconnor> luqui: I do work in Coq alot
21:17:14 <luqui> because i need that structure for my proofs
21:17:23 <roconnor> luqui: ah
21:17:56 <roconnor> I didn't really understand what your Colour -> Affine -> IO () was supposed to be
21:18:06 <roconnor> I'm hoping to find a simpler example
21:18:24 <luqui> roconnor, more precisely you could say it's a stream of OpenGL commands.
21:18:48 <luqui> parameterized by a "current color" and "current transformation"
21:19:08 <roconnor> luqui: shouldn't you drop those parameters
21:19:12 <roconnor> oh
21:19:14 <roconnor> hmm
21:19:29 <roconnor> actually I don't understand what the a is used for in your semantic domain
21:19:34 <roconnor> maybe I should understand that first
21:19:47 <luqui> roconnor, oh i left off the picking half for simplicity.
21:20:10 <roconnor> picking?
21:20:11 <luqui> I also have a "sample" function, Image a -> R2 -> a.
21:20:16 <luqui> which uses OpenGL selection
21:20:28 <luqui> (technically -> IO a)
21:20:50 <roconnor> can we simpy things a little
21:20:56 <luqui> yes!
21:21:04 <roconnor> so R2 -> color
21:21:08 <luqui> g-dc is not very simple :-)
21:21:19 <roconnor> is the target domain
21:21:22 <luqui> okay
21:21:24 <roconnor> and IO () is the source domain
21:21:37 <luqui> sounds good
21:22:10 <roconnor> and the mapping map foo : IO () to whatever it is that it draws
21:22:38 <luqui> yeah
21:23:12 <roconnor> but IO () isn't really the source domain
21:23:22 <luqui> because it is too big
21:23:24 <luqui> (?)
21:23:46 <roconnor> because we need to quotient it out by the (parital) equialence relation that says if it draws the two idential images then they are the same
21:24:07 <roconnor> (and throw away anything that does non drawing IO)
21:24:12 <luqui> uh i guess...
21:24:36 <luqui> i don't see why that quotient is necessary
21:24:39 <roconnor> luqui: otherwise
21:24:50 <roconnor> consider your monoid operation of composition
21:25:26 <roconnor> you want "transparentImage `over` myImage" to be equal to "myImage" right?
21:25:44 <luqui> well I am not sure what sort of "equal" you mean
21:25:48 <ddarius> roconnor: Let's start over and also ditch type classes.  We have a syntax that has the relevant operations we're interested in, e.g. mappend and mempty for Monoid, or (+), (*), etc. for your computable reals.  These will be the operations of the type class.
21:25:50 <roconnor> but if we take transparentImage :: IO () (draws a transparent image)
21:26:08 <roconnor> and over :: IO () -> IO () -> IO ()  (draws one image over the other
21:26:13 <luqui> ddarius, hang on this discussion with roconnor is helping me too
21:26:36 <roconnor> then the IO action "transparentImage `over` myImage" is not *equal* to the simpler IO action of "myImage"
21:26:42 <roconnor> because it does more
21:26:43 <luqui> that is true
21:26:50 <luqui> so the semantic function is not 1-1
21:27:07 <roconnor> luqui: `over` isn't an monoid on IO ()
21:27:09 <ddarius> roconnor: We have two semantics, the implementation semantics which takes mappend to (the Haskell semantics of) whatever you define it to be (or to a slightly different one).  This is the actual Haskell source instance of the relevant type class(es).
21:27:15 <luqui> roconnor, agreed.
21:27:24 <luqui> roconnor, oh, I see what you're saying.
21:27:24 <roconnor> anyhow, back to ddarius
21:27:51 <ddarius> roconnor: The other semantics takes the syntax into some mathematical domain, e.g. the reals or functions R^2 -> Color or anything we want actually.
21:27:59 <ddarius> This is our explanatory semantics.
21:28:22 <roconnor> ddarius: ok
21:28:48 <ddarius> The syntax is endowed with whatever (algebraic) structures we deem relevant.  So the monoid laws if we are modelling monoids.
21:29:18 <roconnor> ddarius: no no
21:29:40 <roconnor> oh
21:29:58 <roconnor> ddarius: the syntax is associated with equational laws you mean?
21:29:59 <copumpkin> one never says "no no" to ddarius
21:30:32 <ddarius> roconnor: Yes.  We assert that for all x, mappend mempty x = x syntactically, for example.
21:31:16 <roconnor> ddarius: we turn the signature into a theory
21:31:23 <ddarius> roconnor: Yes.
21:31:35 <roconnor> ddarius: to use terminology form the algebra of system semantics.
21:31:42 <roconnor> which I've been reading this week
21:31:44 <roconnor> :)
21:34:06 <ddarius> For an instance to be valid (i.e. satisfy any attached laws), as far as Haskell semantics is concerned, we need the semantic function (the Haskell denotational semantics) from the syntax to Haskell's semantic domain to be (/induce) an algebra homomorphism.
21:34:11 <roconnor> luqui: ya, what I am saying is that unless you quotient IO () by a suitable equivalence relation your semantic function won't preserve the monoid laws because your source domain doesn't satify the monoid laws.
21:34:41 * copumpkin cites roconnor's last sentence out of context to show people how accessible #haskell is to outsiders
21:34:43 <ddarius> If you want, you can use a modified denotational semantics for Haskell if the "real" one is too picky.
21:35:44 <roconnor> ddarius: I don't get that
21:36:58 <roconnor> ddarius: what is the domain and codomain of this algebra homomorphism (presumably the algebra in question is the one that our singature + laws define).
21:37:10 <ddarius> roconnor: Let's call the Haskell denotational semantic function, [[-]].  By making an instance of, say, Monoid, you are defining [[mempty]] and [[mappend]].  This should induces a monoid on Haskell's semantic domain.
21:37:49 <roconnor> ddarius: okay that I understand
21:37:59 <roconnor> ddarius: but there is no algebra homomorphisim there.
21:38:47 <ddarius> There's one in the sense of a monoid homomorphism or ring homomorphism, not in the sense of an F-algebra homomorphism.
21:39:16 <roconnor> I don't see the monoid homomorpism
21:40:36 <ddarius> We'll usually have to restrict the target semantic domain by types, e.g. we don't have mappend for all expressible objects in Haskell, just for the ones of the relevant type.
21:40:55 <ddarius> The target semantic domain of Haskell's (modified) denotational semantics.
21:41:06 <roconnor> what is the source domain?
21:41:25 <ddarius> roconnor: The syntax (under the laws).
21:41:36 <roconnor> ddarius: the term algerba modulo the laws?
21:41:48 <ddarius> roconnor: Yes.
21:41:51 <roconnor> ah
21:42:07 <roconnor> ok
21:42:15 <roconnor> I'm with you now
21:42:37 <roconnor> oh
21:42:39 <roconnor> wait
21:42:53 <roconnor> how could this not be a homomorphisim?
21:44:05 <roconnor> if http://en.wikipedia.org/wiki/Special:Search?go=Go&search=mempty and http://en.wikipedia.org/wiki/Special:Search?go=Go&search=mempty satify the monoid laws
21:44:09 <roconnor> arg
21:44:20 <roconnor> if [ [mempty] ] and [ [mappend] ] satify the monoid laws
21:44:38 <roconnor> then won't [ [ . ] ] always be a homomorphisim?
21:45:03 <roconnor> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=test
21:45:22 <roconnor> [[test]]
21:45:24 <roconnor> fixed
21:45:26 <roconnor> ok
21:46:50 <dolio> Your chat client interprets wiki markup?
21:46:55 <ddarius> The syntactical terms with mempty and mappend form a monoid (and thus satisfy the laws) by assertion.  [[-]] is, a priori, only a function.  It could be that (Codomain([[-]]), [[mempty]], [[mappend]]) does not satisfy the monoid laws and thus [[-]] won't be a monoid homomorphism.
21:47:12 <roconnor> dolio: it did
21:47:19 <roconnor> or something
21:47:46 <ddarius> If (Codomain([[-]]), [[mempty]], [[mappend]]) doesn't form a monoid, then you've made a bad instance of Monoid.
21:47:53 <roconnor> ddarius: sure, but if it does satify the monoid laws then it will be a monoid homomorphism
21:48:06 <roconnor> ok
21:48:30 <ddarius> Yes, if your instance is good the target monoid (i.e. the monoid on the semantics) will be induced by it.
21:48:42 <roconnor> good
21:48:48 <roconnor> what's the next step
21:49:29 <ddarius> Now you have another semantic function, <<->>, that goes to another semantic domain of your choosing and equipped with any of the relevant algebraic structures of your choosing.
21:50:14 <roconnor> ddarius: from syntax to this other new semantic domain?
21:54:22 <ddarius> Give me a second.
21:58:36 <kamatsu> eh? GHC says "parse error in pattern"
21:58:38 <kamatsu> let opList = cl M.! c
21:58:48 <kamatsu> :/ how is that possibly wrong?
21:59:23 <roconnor> @index (!)
21:59:23 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.IntMap, Data.Map, Data.Array, Text.Html
21:59:44 <roconnor> > Map.empty
21:59:45 <lambdabot>   Not in scope: `Map.empty'
21:59:48 <roconnor> > Data.Map.empty
21:59:49 <lambdabot>   Not in scope: `Data.Map.empty'
22:00:03 <roconnor> @hoogle emtpy
22:00:03 <lambdabot> No results found
22:00:11 <kamatsu> @hoogle empty
22:00:11 <lambdabot> Control.Applicative empty :: Alternative f => f a
22:00:12 <lambdabot> Data.ByteString empty :: ByteString
22:00:12 <lambdabot> Data.IntMap empty :: IntMap a
22:00:41 <luqui> kamatsu, a syntax error somewhere before that line?
22:01:01 <roconnor> okay. I'm starting to think the TCM stuff is just obvious.
22:01:01 <kamatsu> it's the only thing on that line
22:01:13 <roconnor> which is better than it being meaningless
22:01:18 <luqui> kamatsu, yes, but on an earlier line
22:02:04 <roconnor> TCM is saying that when you make an abstract data type it sould behave as the thing it abstracts behaves
22:02:12 <roconnor> which is obvious
22:02:37 <ddarius> roconnor: Yes.
22:02:52 <ddarius> (If I'm interpreting "thing it abstracts" correctly.)
22:03:09 <roconnor> thing it abstracts is this semantic domain thing.
22:03:17 <ddarius> Yes.
22:03:30 <ddarius> Well, except it doesn't have to be the whole semantic domain.
22:03:50 <roconnor> sure
22:03:51 <kamatsu> ah, fixed it
22:03:56 <kamatsu> it was just giving a very wrong line number
22:04:12 <roconnor> ddarius: not the the users will really ever be able to tell it isn't the whole semantic domain
22:05:35 <roconnor> but why does Conal think this is a big deal?
22:06:19 <ddarius> roconnor: They'll often be able to "tell".  For example, I can use an array to model a partial function Natural -> a, but it's clear that not -every- partial function Natural -> a is representable as an array, e.g. const 1.
22:07:21 <roconnor> ddarius: well if it is abstracted they won't know it is an array
22:07:51 <roconnor> luqui left :(
22:07:53 <ddarius> roconnor: Indeed, but they'll be able to tell that they don't have the interface to create everything that the semantic domain would allow.
22:08:02 <roconnor> that is true
22:09:07 <roconnor> luqui post is more about monoid actions than actions than anything else
22:10:03 <ddarius> Incidentally, in cases where the semantic domain is bigger (i.e. the semantic function is not surjective), we -may- get some benefit from TCM as there are likely to be fewer possible "semantic instances" and therefore they are likely to be more natural and are inherently more general.
22:10:16 <roconnor> right
22:12:07 <ddarius> So, for example, one could imagine an array concatenation monoid but the Natural -> a doesn't support such a monoid.  It does support another when a is a monoid, which (necessarily) has a natural interpretation on arrays.
22:13:58 <sshc> why is it necessary for the Identity monad to be the bottommost of a monad transformer?
22:14:06 <ddarius> sshc: It isn't.
22:14:27 <sshc> http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html
22:14:37 <sshc> according to that article, only IO and identity can be at the bottom
22:15:08 <sshc> so is it pointless to stack a state transformer on an identity monad?
22:15:23 <sshc> StateT Foo Identity ()
22:15:29 <QtPlatypus> Douse it give an argument?
22:15:52 <dolio> Identity isn't a transformer, so it can't go anywhere else. You'd need an IdentityT to put it elsewhere, but most people don't really need such a thing.
22:16:06 <ddarius> sshc: I'm not going to do a detailed read of that article, but I highly doubt it says that those are the -only- things that can be at the bottom of a monad transformer stack.
22:16:16 <roconnor> heh IdnetityT
22:16:21 <idnar> sshc: it's not so much that only IO and Identity can be at the bottom, but rather that IO and Identity can only be at the bottom
22:16:22 <roconnor> is that even defined?
22:16:35 <idnar> sshc: IdentityT would be pointless, and IOT is impossible
22:16:45 <dolio> I thought xmonad had some use for it, but I can't recall.
22:16:50 <ddarius> roconnor: I don't believe it is in any common libraries, but possible in some less common libraries.
22:17:00 <dolio> Like, they parameterized over a transformer, and filled in IdentityT when they didn't want anything.
22:17:03 <roconnor> idnar: IdentityT is great to be passed to monad transformer transfomers
22:17:30 <ddarius> Soon we'll need IdentityTT for the monad transformer transformer transformers.
22:17:47 <c_wraith> this suddenly sounds like java.
22:18:14 <idnar> roconnor: well, okay
22:18:15 <copumpkin> Factory Factories?
22:18:18 <kmc> abstract monad transformer factory pattern
22:19:02 <idnar> sshc: that post even has an example of another monad at the bottom;"So here's a StateT layer wrapped around State"
22:20:03 * idnar giggles at 
22:20:07 <idnar> "You may now be wondering where test4 and test6 are. So am I."
22:20:51 <sshc> Why is liftIO necessary?
22:20:59 <ddarius> It isn't.
22:21:04 <sshc> why can't lift be used to lift IO into some other monad?
22:21:14 <ddarius> It can.
22:21:46 <Draconx|Laptop> sshc, the point is that instead of writing lift thrice you might write liftIO once.
22:22:25 <VTimage> No +r on this channel?
22:22:48 <sshc> Draconx|Laptop: so the whole purpose of liftIO is a shortcut for writing muiltple lift's when you have IO at the bottom?
22:23:03 <ddarius> sshc: Yes.
22:23:20 <ddarius> It also is slightly more maintainable.
22:25:04 <pikhq> sshc: liftIO is also slightly more efficient, I've heard.
22:25:42 * hackagebot upload: hs-gchart 0.1.1 - Haskell wrapper for the Google Chart API (DeepakJois)
22:25:48 <c_wraith> pikhq: really?  Isn't liftIO usually implemented as lift . liftIO ?
22:25:56 <medfly> ? :o
22:26:17 <pikhq> c_wraith: I'd merely heard that. So hell, I could be way the hell wrong on that.
22:26:46 <pikhq> Maybe GHC just does some magic on it or something...
22:26:53 <pikhq> @src liftIO
22:26:53 <lambdabot> Source not found. Do you think like you type?
22:27:03 <pikhq> That looks like magic to me.
22:27:07 <lpsmith> We need a replacement for transformers;  but I'm not sure what that is
22:27:16 <c_wraith> @src MonadIO
22:27:16 <lambdabot> Source not found. :(
22:27:38 <pikhq> lpsmith: Clearly, we need a monad that does everything.
22:27:38 <ddarius> lpsmith: Most of the other approaches are much less fun to work with.
22:27:41 <medfly> you're making lambdabot sad!
22:27:42 <c_wraith> pikhq: eh.  it's a function in the MonadIO typeclass.  of course the source isn't found.
22:27:46 <pikhq> Say, the CProgramming monad.
22:27:46 <ddarius> pikhq: ContState
22:27:46 <pikhq> :P
22:28:09 <pikhq> ddarius: ... Yeah, that'd do it.
22:28:10 <lpsmith> ddarius, what other approaches?  :)
22:28:44 <pikhq> At that point, you just about have a very, very bizarre Lisp.
22:28:45 <pikhq> :P
22:28:51 <lpsmith> @google Fun with the Lazy State Monad
22:28:53 <lambdabot> No Result Found.
22:29:09 <pikhq> An H-expression Lisp.
22:29:28 <ddarius> lpsmith: http://web.cecs.pdx.edu/~mpj/pubs/composing.html and http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3581 are two examples.
22:29:34 <lpsmith> ddarius, http://blog.melding-monads.com/2009/12/30/fun-with-the-lazy-state-monad/
22:29:49 <lpsmith> I'm not so sure ContState is the monad that does everything
22:29:55 <lpsmith> I don't know though
22:30:16 <sshc> the Continuation monad confuses me very much so
22:30:35 <sshc> I don't understand why or how it should be used
22:30:35 <pikhq> sshc: Are you familiar with continuations?
22:30:40 <sshc> pikhq: I'm not
22:30:47 <copumpkin> that might explain it :)
22:30:50 <pikhq> Okay, that'd do it.
22:30:51 <roconnor> sshc: it should be used when you want to use callCC
22:30:59 <roconnor> sshc: which is basically never in Haskell
22:31:05 <kmc> sshc, imo it helps to write code in continuation-passing style
22:31:12 <kmc> Cont monad is sugar for CPS
22:31:23 <kmc> once you use CPS directly some, you will see where the sugar is useful
22:31:26 <roconnor> sshc: since laziness solve 90% of the problems that people use Continuations to solve in other languages
22:31:31 <sshc> I've heard that I don't need to worry about the Cont monad with Haskell
22:31:37 <ddarius> CPS shouldn't be used unless you are implementing callCC (in most cases).
22:31:53 <lpsmith> what about shift and reset?
22:31:59 <sshc> is CPS something worth learning?
22:32:07 <kmc> sshc, yes
22:32:09 <lpsmith> what about mapCont?
22:32:14 <sshc> kmc: why?
22:32:22 <kmc> because some problems are very cleanly expressed in CPS
22:32:30 <roconnor> sshc: that being said, atting contT at the top of a monad stack can sometimes makes your code 10x faster
22:32:34 <roconnor> :)
22:32:35 <pikhq> A continuation, essentially, is the current state of the program. In essence, callCC calls a function and passes it the current state.
22:32:46 <pikhq> That function, once it's done, returns to that state.
22:32:47 <ddarius> lpsmith: The Cont monad isn't call-by-name or call-by-value, rather, there are CbV monadic style and CbN monadic style.  If you use the Cont monad with the CbV monadic style you get the CbV CPS transform, if you use it with the CbN monadic style you get the CbN CPS transform.
22:32:49 <lpsmith> roconnor, likely because it's turning a lazy state monad into a strict state monad
22:32:52 <pikhq> And the program continues from there.
22:32:59 <roconnor> lpsmith: does it do that?
22:33:01 <lpsmith> Of course,  there is also free monads...
22:33:04 <lpsmith> yep
22:33:20 <kmc> sshc, the basic idea of CPS is that each function gets an extra arg, call it "k".  when your function would return, it instead calls k
22:33:22 <roconnor> lpsmith: really?
22:33:39 <kmc> so this does not use any fancy language feature, it's just passing functions around
22:33:48 <kmc> the power is that you can use that k in a way other than calling it to "return"
22:33:48 <lpsmith> roconnor:   http://blog.melding-monads.com/2009/12/20/are-continuations-really-the-mother-of-all-monads/
22:34:14 <roconnor> lpsmith: I thought it made code faster because it makes all the bind operations assocated one way
22:34:17 <kmc> for example, you can make a further call and pass in "k", and the function you call can then make a "non-local return" by calling that value instead of its continuation
22:34:24 <lpsmith> roconnor, http://www.melding-monads.com/foldrbylevel.hs
22:34:29 <roconnor> lpsmith: just like ++ is faster when all associated one way
22:34:40 * pikhq has tried doing continuation-passing style in C.
22:34:50 <pikhq> setcontext et al. are very, very annoying.
22:35:15 <pikhq> Erm. That wasn' the CPS.
22:35:16 <lpsmith> Well,  I am familiar with Janis Voightlander's paper on speeding up free monads
22:35:20 <pikhq> That was just using continuations.
22:35:20 <lpsmith> using continuations
22:35:38 <roconnor> lpsmith: that's a pretty compelling example.
22:35:50 <lpsmith> which one?  or both?
22:35:54 <roconnor> second
22:35:56 <pikhq> lpsmith: Yes. setcontext and getcontext implement continuations in C.
22:36:08 <lpsmith> Sure
22:36:30 <pikhq> In a very, very bizarre way.
22:36:31 <roconnor> lpsmith: this is the speedup I'm refering to: http://r6.ca/blog/20071028T162529Z.html
22:36:36 <pikhq> (null stack frames, anyone?)
22:37:37 <lpsmith> ddarius, regarding cbn or cbv,  can you elaborate?  Do you have a reference?
22:37:57 <lpsmith> roconnor, I can't seem to pull a dns addy for r6.ca
22:38:06 <ddarius> lpsmith: I can elaborate, but let me see if I can find a reference.
22:38:16 <roconnor> oh crap
22:38:33 <roconnor> it's feburary
22:38:52 <lpsmith> didn't renew something?   :)
22:39:05 <solrize> works for me
22:39:16 <lpsmith> I can pull an ip addy for www.r6.ca...
22:39:32 <solrize> wait suddenly stopped
22:39:43 <roconnor> lpsmith: I didn't renew something
22:40:09 <lpsmith> well, what's the IP address of your webserver?
22:41:00 <solrize> 72.2.4.176
22:41:08 <lpsmith> thanks solrize
22:41:43 <sshc> what is the difference of StateT and MaybeT?
22:41:45 <lpsmith> hmm,  is that shared hosting?   I'm getting 400 errors
22:41:53 <solrize> make sure to send a host header
22:42:07 <lpsmith> Yeah
22:42:11 <roconnor> 72.2.4.176
22:42:14 * lpsmith scraches my head about how to do that
22:42:14 <roconnor> hmm
22:42:17 <roconnor> shared hosting
22:42:19 <roconnor> ya
22:42:57 <sshc> What is the differente between StateT Foo Maybe Integer and MaybeT Foo State Integer?
22:43:03 <roconnor> lpsmith: google cache?
22:43:21 <roconnor> @unmtl StateT Foo Maybe Integer
22:43:21 <lambdabot> Foo -> Maybe (Integer, Foo)
22:43:34 <roconnor> @unmtl MaybeT Foo State Integer
22:43:34 <lambdabot> Foo (Maybe State) Integer
22:43:34 <dolio> kmc: If you don't have proper tail calls, you're likely to blow the stack pretty quickly with CPS. So you need that language feature at least.
22:43:37 <solrize> lpsmith, $ telnet 72.2.4.176 80
22:43:37 <solrize> Trying 72.2.4.176...
22:43:38 <solrize> Connected to 72.2.4.176.
22:43:38 <solrize> Escape character is '^]'.
22:43:38 <solrize> GET / HTTP/1.0
22:43:38 <solrize> Host: r6.ca
22:43:54 <roconnor> @unmtl MaybeT State Foo Integer
22:43:54 <lambdabot> Maybe Foo -> (Integer, Maybe Foo)
22:43:58 <solrize> yeah, i see, browsers can't find it because they don't know the hostname
22:44:02 <lpsmith> solarize,  I know what a host header is :)
22:44:09 <lpsmith> I'm just not sure how to send one from my browser
22:44:15 <solrize> lpsmith, try putting "72.2.4.176" in your hosts file
22:44:22 <solrize> /etc/hosts or the windoze equivalent
22:44:22 <lpsmith> yeah,  I just thought of that
22:44:26 <roconnor> my domain expires feb. 6
22:44:34 <solrize> renew it, dude :)
22:45:41 <sshc> that should have been MaybeT Integer (State Foo)
22:45:48 <sshc> I think
22:45:54 <pikhq> solrize: C:/Windows/system32/etc/hosts , IIRC.
22:46:00 <sshc> @unmtl MaybeT Integer (State Foo)
22:46:00 <lambdabot> Integer (Maybe (State Foo))
22:46:27 <pikhq> Sorry, C:\Windows\system32\drivers\etc\hosts .
22:46:28 <lpsmith> ahh,  ok,  I think I'd read your post at some point in the past, roconnor
22:46:34 <c_wraith> sshc: that makes no sense.
22:46:39 <roconnor> sshc: MaybeT Integer isn't well kinded
22:46:40 <c_wraith> @kind MaybeT
22:46:41 <lambdabot> Not in scope: type constructor or class `MaybeT'
22:47:13 <sshc> I'm looking for the oppisite order of MaybeT (State Foo) Integer
22:47:22 <lpsmith> But really,  my personal belief at this point in time is that ContT r (StateT st ...) is faster because it makes StateT strict
22:47:34 <sshc> @unmtl StateT Foo Maybe Integer
22:47:34 <lambdabot> Foo -> Maybe (Integer, Foo)
22:47:46 <lpsmith> You'll get a hefty speedup in many cases by switching from Control.Monad.State.Lazy to Control.Monad.State.Strict
22:48:08 <ddarius> lpsmith: Moggi's "Notions of Computation and Monads" covers this briefly: http://www.disi.unige.it/person/MoggiE/publications.html
22:48:12 <lpsmith> The continuation passing state monad is a hair bit faster than Control.Monad.State.Strict
22:48:16 <sshc> @unmtl MaybeT (State Foo) Integer
22:48:16 <lambdabot> Foo -> (Maybe Integer, Foo)
22:48:24 <sshc> those are them
22:48:26 <ddarius> lpsmith: The basic idea though, is that A -> TB is CbV, and TA -> TB is CbN.
22:49:29 <sshc> so, with MaybeT, the chain will never "fail" or "escpae" / end, and the end result only depends on the last monad, but with StateT, it is capable of failing early
22:50:34 <roconnor> sshc: one of ContT State or StateT Cont is broken in the mtl   I forget which one
22:50:50 <lpsmith> roconnor, ?
22:51:12 <lpsmith> what do you mean by "broken"... I've not noticed anything
22:51:16 <dolio> ddarius: Ah, good, that clears up things I'd been wondering about.
22:51:51 <dolio> StateT Cont is broken.
22:52:00 <roconnor> lpsmith: one of the operations is "wrong"
22:52:15 <roconnor> lpsmith: the modular monad transformers paper explains
22:52:55 <roconnor> is it correct in monadLib
22:53:32 <dolio> lpsmith: When you do StateT (Either e) for instance, throwing an exception rolls back the state.
22:53:54 <dolio> StateT Cont can have a similar rollback effect, but it doesn't.
22:54:31 <dolio> ContT State can't roll back, but for StateT Cont you can choose, but they chose the same behavior as ContT State.
22:54:42 <copumpkin> meanies
22:54:52 <lpsmith> ack;  is the modular moand transformers paper available somewhere for free?
22:54:56 <dolio> And the modular monad transformers paper has some argument for why the rollback is the "right" choice, but I don't remember what it is.
22:55:36 <lpsmith> found it
22:56:26 <solrize> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
22:57:01 <solrize> http://www.fceia.unr.edu.ar/~mauro/pubs/mmt/mmt.pdf
22:57:36 <solrize> oops wrong pdf
22:57:47 <solrize> hmm
22:57:59 <solrize> http://www.fceia.unr.edu.ar/~mauro/publications.html  from here, but url points to wrong paper
22:59:41 <solrize> http://www.pdfone.com/download/0_keywordmodularmonadtransformers/modular-monad-transformers.pdf
23:01:39 <lpsmith> solrize, how is the second url correct and the first one wrong?   They look like the same paper to me...
23:02:05 <solrize> publications.html uses the same url for two different papers
23:02:16 <solrize> mmt.pdf on that site is actually some other paper
23:04:10 <lpsmith> ok,  but http://www.pdfone.com/download/0_keywordmodularmonadtransformers/modular-monad-transformers.pdf takes me to the same paper as the mmt url on the publications.html
23:04:36 <solrize> hmm that's weird, i may have clicked in the wrong place or something then
23:04:40 <solrize> anyway there it is
23:05:00 <lpsmith> where is it?
23:05:09 <solrize> mmt.pdf
23:05:21 <solrize> i thought i had clicked that and gotten the wrong paper
23:05:32 <lpsmith> http://www.fceia.unr.edu.ar/~mauro/pubs/mmt/mmt.pdf   <-- so that's the right paper?
23:05:43 <solrize> afaik yes.  i had never heard of it before and goobled around for it
23:14:52 <lpsmith> sigh;  I know I checked the callcc operation both with ContT r (StateT st) a and vice-versa,  I must've made a mistake
23:27:53 <dolio> > flip runCont id . flip runState 0 . callCC $ \k -> put 1 >> k ()
23:27:54 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.Cont a a'
23:27:54 <lambdabot>         against ...
23:30:12 <lpsmith> > flip runContT id . flip runState 0 . callCC $ \k -> put 1 >> k ()
23:30:13 <lambdabot>   Couldn't match expected type `Control.Monad.Cont.ContT r m (m r)'
23:30:13 <lambdabot>         a...
23:30:21 <ablmf> http://pastebin.com/m1131756c What's wrong in the "where" ?
23:30:30 <dolio> > flip runCont id . flip runStateT 0 . callCC $ \k -> put 1 >> k ()
23:30:32 <lambdabot>   ((),1)
23:30:44 <lpsmith> oh right
23:31:08 <lpsmith> > flip runState 0 . flip runContT id . callCC $ \k -> put 1 >> k ()
23:31:09 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State a a1'
23:31:10 <lambdabot>         ...
23:31:12 <ablmf> ghci complains about the "where" as :  parse error on input `where'
23:31:54 <ablmf> I expected this were right: where  (h, t) = splitAt n xs
23:32:05 <lpsmith> ablmf: look before the where, not after :)
23:32:45 <ablmf> lpsmith: Can you be more specific?
23:32:59 <dolio> > flip runState 0 . flip runContT return . callCC $ \k -> put 1 >> k ()
23:33:00 <lambdabot>   ((),1)
23:33:59 <lpsmith> ablmf, maybe;  but have you tried?   Like I said,  the syntax mistake is somewhere in the file before the "where"  (but not too far before the where),  not after
23:34:08 <copumpkin> omnom
23:34:37 <ablmf> lpsmith: Yeah, I missed sth before where
23:34:40 <ablmf> lpsmith: thx
23:35:12 <lpsmith> (it's on the line before the where, in fact ;-)
23:35:51 <felzix> How do I deal with trying to get the first element of a list which might be empty?
23:36:28 <lpsmith> @let runCS = flip runState 0 . flip runContT return
23:36:30 <lambdabot>  Defined.
23:36:52 <lpsmith> @let runSC = flip runCont id . flip runState 0
23:36:53 <lambdabot>  <local>:22:31:
23:36:53 <lambdabot>      Couldn't match expected type `Cont a a'
23:36:53 <lambdabot>             agai...
23:37:05 <lpsmith> @let runSC = flip runCont id . flip runStateT 0
23:37:06 <lambdabot>  Defined.
23:37:41 <lpsmith> felzix, try using a case statement or an auxiliary function
23:38:15 <lpsmith> case list of  { [] -> something ; (x:_) -> something else }
23:38:55 <lpsmith> auxfunction [] = something ;  auxfunction (x:_) = something else
23:39:20 <felzix> lpsmith: thank you!
23:40:42 <kaol> @hoogle listToMaybe
23:40:42 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
23:41:55 <dolio> > let ccc f = StateT $ \s -> callCC $ \k -> runStateT (f (\a -> StateT $ \_ -> k (a, s))) s in flip runCont id . flip runStateT 0 . ccc $ \k -> put 1 >> k ()
23:41:56 <lambdabot>   ((),0)
23:42:06 <dolio> That's the other callCC.
23:42:53 <felzix> kaol: thanks
23:43:37 <lpsmith> ahh,  so I wasn't wrong;  ContT r (State st)     and StateT st (Cont r)   *are* the same monad
23:43:49 <dolio> They are in mtl.
23:43:55 <lpsmith> but both "wrong",  at least accoring to MMT
23:44:10 <dolio> Only StateT s (Cont r) is wrong.
23:44:24 <dolio> ContT r (State s) only has one option.
23:44:37 <lpsmith> oh
23:44:48 <lpsmith> So the "correct" thing is that they are different
23:44:52 <lpsmith> not the same
23:45:23 <dolio> Right.
23:45:41 <dolio> I mean, that's not the argument the paper gives.
23:46:14 <dolio> It has some methodology by which it determines the 'right' instance, and it happens that the right ones are such that those two are different.
23:47:07 <lpsmith> there was some discussion of an alternate lifting for callCC in monad transformers and modular interpreters.... lemme go look at that again
23:47:26 <dolio> Although, if you ask me, the fact that you can either have two monads with the same operations, and 0 with the alternate, or one of each is reason enough.
23:47:48 <dolio> Yes, in that one they call the one I wrote by hand the "debug" semantics.
23:48:35 <dolio> And then choose the non-debug semantics because it matches how callCC works in Scheme or something.
23:49:38 <lpsmith> right
23:49:48 <lpsmith> yeah,  just checked that again
23:49:55 <lpsmith> hmm
23:50:31 <lpsmith> although...
23:51:05 * lpsmith wonders if there isn't another plausible methodology that suggests that the MTL is the "correct" choice
23:53:02 <lpsmith> ok,  now that we have that cleared up (to an extent),  what can we say about CbN versus CbV and the continuation monad?
23:53:12 <dolio> Well, the situation Scheme is in, I suspect, is that its state modification is like IO, and thus can only be layered under a ContT, essentially.
23:53:41 <dolio> Which gives you the Scheme-like semantics as the only choice. Debug isn't an option.
23:54:40 <dolio> To do debug-like stuff, the continuation would have to copy the heap and roll it back, I think.
23:56:26 <lpsmith> maybe; I'll have to think about it more
23:56:28 <dolio> Well, ddarius says CbN vs. CbV is a choice of monadic style, not a choice of monad, which is something I'd heard before, but I didn't know how authoritative it was.
23:56:40 <lpsmith> I certainly learned at least one thing tonight;  thanks
23:58:05 <lpsmith> Well, I'd not heard that before;   I do know that if you write something in the monadic style,  and then apply the Cont transformer,  and then inline and work out what it looks like "underneath",  it's a CbV CPS transformation
23:58:27 <lpsmith> Of course,  that only transforms the part of the program you wrote in the monadic style,   not the entire program
23:58:33 <dolio> Well, I'm no scheme expert, but if you do something like (let (x 0) ((call/cc (lambda k (begin (set! x 0) (k #t))) (print x)), x potentially goes in the heap, right?
23:58:36 <lpsmith> so,  there are differences
23:58:58 <lpsmith> dolio, the implementations I'm familiar with,  yes
23:59:40 <dolio> I mean, you could work out some kind of explicit transactional cell system to make things more achievable.
