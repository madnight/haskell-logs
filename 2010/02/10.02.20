00:34:53 <copumpkin> dons: still awake?
00:35:48 <copumpkin> I think I know how to do the get straight from a stream
00:36:19 <dons> ah good
00:36:20 <dons> how?
00:36:26 <dons> using munstream ?
00:36:29 <copumpkin> there's a generateM :: Monad m => Int -> (Int -> m a) -> Stream m a
00:36:48 <dons> yeah, I can get there (unfoldr also works)
00:37:01 <dons> now, once you have a Stream m a, we need to fill a real array with it.
00:37:19 <dons> I think we have to make Get one of the PrimMonads (?)
00:37:24 <dons> which seems wrong.
00:37:44 <copumpkin> oh I see, the stream/unstreams are all on the identity monad
00:37:51 <copumpkin> thought it would be simpler than it is :)
00:38:03 <dons> i think it involves New.hs
00:38:16 <dons> we allocate, and fill from the unfoldr or generatEM
00:38:20 <dons> in ST.
00:38:41 <copumpkin> that would work, but surely there's something else in here that needs something similar and it's already been done?
00:38:55 <copumpkin> seems odd to allow for monadic streams and then have all the functions everywhere work on Stream Id
00:41:20 <dons> i think it is for filling ST or IO things.
00:41:30 <dons> look for how munstream is used.
00:42:29 <copumpkin> aha
00:42:39 <copumpkin> I see
00:43:08 <copumpkin> yeah, making Get into a PrimMonad seems wrong, you're right
00:43:25 <copumpkin> hmm
00:43:41 <dons> so maybe we just need to combine ST and Get somehow.
00:44:00 <copumpkin> yeah, I'll try to come up with something
00:44:17 <copumpkin> I guess there's no GetT
00:51:27 <DigitalKiwi> I tried to find some haskell books at the university libraries but there weren't any good ones afaict :(
00:55:49 <dons> copumpkin: also, feel free to add sections to http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
00:55:54 <dons> e.g. on using mmap. other examples.
00:56:02 <dons> i added lots of little things today
00:56:21 <copumpkin> cool, I will
00:56:26 <dons> needs an overview of the types. doesn't show anything about mutable stuff yet.
00:56:28 <dons> or how to convert.
00:56:37 <dons> examples of how to call C, there's a little one.
00:56:38 <copumpkin> I don't think there's a good way to convert yet
00:56:43 <copumpkin> at least according to dolio
00:56:57 <dons> oh, no easy freeze/unfreeze?
00:57:02 <copumpkin> well, at least if you already have a mutable vector and want to copy an immutable one into it
00:57:10 <copumpkin> I think there's freeze unfreeze
00:57:24 <copumpkin> maybe, haven't looked too carefully yet
00:57:45 <copumpkin> trying to concoct a combined Get/ST monad, not sure if it'll work :P
00:58:12 <copumpkin> oh by the way, the darcs url on your binary instances package is a 404
01:06:50 <mreh> nothing says I can do haskell like contributing to an open source project
01:07:04 <mreh> shall I fix some bugs?
01:07:16 <dmwit> That would be great!
01:07:49 <copumpkin> gah, this primitive monad stuff is painful, and I'm not sure it's flexible enough to do what we need it to
01:08:14 <mreh> it's my year abroad in sub-Saharan Africa building wells
01:10:10 <copumpkin> dons: PrimMonad's structure makes some fairly huge assumptions about its instances. It's almost a closed typeclass :(
01:16:49 <mreh> http://hackage.haskell.org/trac/ghc/ticket/552 -- This should be a good start!
01:17:01 <mreh> time to nip this on in the bud
01:28:55 * hackagebot upload: hexpat 0.12 - wrapper for expat, the fast XML parser (StephenBlackheath)
01:36:03 <copumpkin> dons: okay, pretty sure it isn't possible, even with crazy unsafe hackery (which is what I've been trying right now). PrimMonad is basically a closed typeclass, as the types of primitive and internal basically say that it must be isomorphic to ST or IO. So my beautiful ST + Get monad is not an instance and can't be :( next option is to use IO as the underlying monad and do some seriously impure stuff, convert back to ST, then let th
01:36:03 <copumpkin> built-in machinery handle it
01:36:57 <paolino> hi, anyone has a beautiful way to select edges pointing to leaves in Data.Graph ?
01:54:01 <mreh> is there a type class for key->value indexed lists?
01:55:48 <dmwit> huh
01:56:06 <dmwit> One of my tests didn't pass -- because my *mental model* was buggy, not because my code was buggy.
01:56:25 <dobblego> I get that occasionally
01:56:48 <ben> My mental model does not come with unit tests :(
01:57:19 <dmwit> Yeah, it's happened before, but usually some tests fail for the latter reason.
01:57:24 <Saizan> mreh: in edison, maybe
01:57:49 <dmwit> (In addition to whatever fails for the former reason.)
01:58:05 <dmwit> I guess it could just be coincidence. Code enough stuff, and you will see every possible pattern of failure. =P
01:59:16 <Saizan> tests never prove that you don't have a bug
01:59:21 <dmwit> true
01:59:42 <DigitalKiwi> my tests just prove I have bugs :(
02:01:00 <Entroacceptor> tests usually help me to construct my mental model
02:05:19 <Berengal> My mental model comes from - and is sometimes shattered by - types.
02:08:02 <mreh> have we got a low cost implementation of unsigned integers?
02:08:28 <dmwit> mreh: Word8, Word16, Word32
02:08:31 <dmwit> Data.Word
02:08:42 <dmwit> mreh: Or did you mean unbounded?
02:08:51 <mreh> dmwit: bounded
02:08:54 <mreh> thanks
02:09:06 <mreh> > 2 ^ 8
02:09:07 <lambdabot>   256
02:09:13 <mreh> > 2 ^ 16
02:09:14 <lambdabot>   65536
02:09:27 <dmwit> > (maxBound :: Word8, maxBound :: Word16, maxBound :: Word32)
02:09:28 <lambdabot>   (255,65535,4294967295)
02:09:44 <mreh> It's a game of asteroids, I don't think I'll ever need more than 4 gazillian numbers
02:09:59 <Beelsebob> mmmm... 4 gazillion
02:10:02 <mreh> they're identity numbers for game objects
02:10:10 * dmwit nods
02:10:22 * Beelsebob uses UUIDs for that
02:10:24 <dmwit> mreh: I'm writing a game, too. I'll race you to Hackage. =)
02:10:32 <mreh> I feel like calculating how many games of asteroids you might need to play until you run out
02:10:38 <mreh> and how long that takes
02:10:47 <mreh> dmwit: is it Haskelloids?
02:10:56 <dmwit> nope!
02:11:01 <mreh> good
02:11:04 <mreh> are you using Yampa?
02:11:18 <dmwit> Nope!
02:11:32 <dmwit> although
02:11:33 <dmwit> hum
02:11:42 <dmwit> I hadn't really thought about the front-end yet.
02:12:23 <dmwit> It's going to be pretty simple 2D vector graphics, and Cairo is pretty nice for that, so I just assumed I'd use Gtk2Hs, but...
02:13:46 <mreh> going down the whole, "I'm going to make my own fully reactive game engine" route is hard work
02:14:55 <monadic_kid> people need to stop trying to make game engine and write games instead
02:15:00 <monadic_kid> *engines
02:17:37 <dmwit> monadic_kid: Which one do you recommend?
02:18:02 <monadic_kid> what's your experinice?
02:18:12 <monadic_kid> what do you want to do
02:18:51 <dmwit> My experience is with Gtk2Hs, but I don't think that should matter. It's not that hard to pick up a new library, and even if it were hard there's no reason not to expand what I know.
02:19:08 <mreh> minBound :: Word32
02:19:10 <dmwit> I want to write a puzzle game with a timed element.
02:19:13 <mreh> > minBound :: Word32
02:19:13 <lambdabot>   0
02:19:30 <tibbe> > maxBound :: Word32
02:19:31 <lambdabot>   4294967295
02:19:36 <tibbe> math works! ;)
02:19:45 <dmwit> > maxBound + 1 :: Word32
02:19:46 <lambdabot>   0
02:19:57 <dmwit> math fails! =(
02:19:58 <mreh> Oh no! It doesn't work!
02:20:16 <monadic_kid> dmwit: No 1. do not underestimate the complexity invovled in make games, even ones that look simple.
02:20:32 <dmwit> I have made it before. I'm not underestimating anything.
02:20:34 <mreh> monadic_kid, so you choose the right abstraction
02:20:35 <dmwit> ...twice
02:27:14 <monadic_kid> dmwit: I don't know the full conversation because i've only entered the room but I read some one wants to write a game engine. The people try to do this are typically people who don't even have experinice writing a number of complete games, they naively undersetimate the complexity of the task and the amount of knowledge and experinice necessary. At the end of the day they forget why they started to do this all and it was to write a gam
02:27:14 <monadic_kid> e but they'll never finish one if they try to write game engines. It's more fun and rewarding to write games,  stop focusing on game engines, it's pointless. I should know I work in the industry.
02:27:48 <dmwit> Okay.
02:28:09 <dmwit> If you don't have a concrete suggestion for something prebuilt to use, I'm going to go ahead and forge ahead building my game. =)
02:31:07 <Heffalump> what's the difference between an engine and a library?
02:31:24 <dmwit> I think maybe just the spelling. =)
02:31:50 <Ke> I'd guess engine is a subset of a library
02:33:43 <mreh> Haskell would be well suited for writing a game engine, highly composable parts made with combinators
02:33:47 <mreh> like Yampa!
02:34:42 <mreh> Signal functions are highly extensible and very modular!
02:35:09 * Beelsebob isn't keen on the yampa way of doing it, but FRP in general is fricking awesome for that kind of thing
02:35:15 <Beelsebob> shame anygma ran out of money :(
02:36:24 <mreh> Beelsebob, what do you use?
02:36:30 <mreh> or *would* you use?
02:37:11 <Beelsebob> we were "using" reactive
02:37:17 <Beelsebob> or variants thereon
02:37:26 <mreh> Beelsebob: who is we?
02:37:30 <Beelsebob> it's a much cleaner way of doing FRP... it's a shame no one's *quite* got it to work right
02:37:32 <Beelsebob> Anygma
02:37:41 <mreh> oh
02:38:30 <mreh> Beelsebob: where are your offices?
02:38:40 <Beelsebob> they were in Antwerpen
02:38:57 <Heffalump> Beelsebob: what are you doing now?
02:39:10 <mreh> Beelsebob: thought about going global and collaborating over the internet, that would slash costs
02:39:12 <dmwit> According to their website, they're still recruiting. =P
02:39:16 <Beelsebob> Heffalump: iPhone engineering in the north of scotland
02:39:19 <Beelsebob> dmwit: hahahaha
02:39:37 <Beelsebob> mreh: actually, that's one of many things that slowed the project down and drove costs up massively
02:39:56 <Beelsebob> trying to comunicate in your team when one guy is in australia, 3 are in belgium and 2 are in the US is *hard*
02:40:17 <mreh> Beelsebob: i suppose going open source is the only way to make that work
02:40:24 <CalJohn> communication is always underated as a problem
02:40:35 <Beelsebob> well we had limited success with that
02:40:52 <Beelsebob> when reactive had a big push to get people into it, that was us trying to get lots of people working on it
02:41:03 <Beelsebob> reactive got moving quite nicely for a while after that
02:41:47 <mreh> Beelsebob: who works on the iPhone in the highlands?
02:42:02 <Beelsebob> mreh: http://www.huntedcow.com/
02:43:35 <ivanm> preflex: seen dons
02:43:35 <preflex>  dons was last seen on #haskell 1 hour, 46 minutes and 38 seconds ago, saying: oh, no easy freeze/unfreeze?
02:44:29 <mreh> Beelsebob: lots of hype! I don't think I've played any of those games
02:44:44 <Beelsebob> mreh: lots of hype?
02:45:02 <Beelsebob> you may not have, but there are plenty of people who have
02:45:19 <ivanm> dons: you still around?
02:46:14 <mreh> Beelsebob: just commenting on what I could gather from the website, looks productive, what are the projects mostly written in?
02:46:45 <Mitar> i would like to map a list of values with showFFloat to list of string representations
02:46:51 <Mitar> but i have problems because showFFloat returns a function
02:47:12 <Mitar> so "map (showFFloat Nothing) values" does not really work
02:47:14 <Beelsebob> mreh: the older games are all web based, php/html/js games; eldevin is java; my project is obviously obj-c
02:47:44 <mreh> Beelsebob: uhuh
02:47:55 <Jedai> @type showFFloat
02:47:55 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
02:48:14 <Beelsebob> mreh: eldevin's engine is fucking impressive actually – entirely software rendered in java, but manages to look about as good as WoW in the browser
02:48:15 <dmwit> :t map (\float -> showFFloat Nothing float "")
02:48:16 <lambdabot> forall a. (RealFloat a) => [a] -> [String]
02:48:38 <mreh> Beelsebob: that suprises me... Java?!
02:48:44 <Beelsebob> mreh: indeed
02:48:52 <mreh> hackalicious?
02:49:05 <Beelsebob> nah, the guy who wrote the engine is just fucking good
02:49:13 <ttt--> just out of interest, is happs used in any big projects?
02:50:10 <Mitar>  map ($ "") $ map (showFFloat Nothing)
02:50:13 <Mitar> that works
02:50:24 <ttt--> i should ask in #happs, sorry
02:51:01 <dmwit> Mitar: You don't like my lambda mapper?
02:51:23 <Mitar> i have developed independently other solutions ;-)
02:51:30 <dmwit> =)
02:51:31 <Mitar> but it is also nice
02:51:36 <Mitar> can be curried?
02:51:39 <dobblego>  /whois eldevin
02:51:47 <dobblego> Beelsebob ^^
02:51:53 <Mitar> so that we would lose the \float?
02:52:04 <Beelsebob> dobblego: http://www.eldevin.com/
02:52:09 <dobblego> ta
02:52:17 <Beelsebob> due for release in 09 >.>
02:52:24 * Beelsebob slaps john for not fixing that yet
02:52:41 <dmwit> Mitar: sure
02:52:57 <dmwit> :t map (flip (showFFloat Nothing) "")
02:52:58 <lambdabot> forall a. (RealFloat a) => [a] -> [String]
02:53:34 <monadic_kid> dmwit: sorry had to pick up the phone
02:53:52 <dmwit> No worries. =)
02:54:07 <Jedai> showsList f xs = putStr $ '[' : foldr (\a e -> f a . (", " ++) . e) id xs "]"
02:54:35 <dmwit> Jedai: eek
02:54:43 <Jedai> dmwit: we have showS, shouldn't we try taking advantage of it ?
02:55:21 <dmwit> ah
02:55:27 <Jedai> showsList f xs = foldr (\a e -> f a . (", " ++) . e) id xs "]"
02:55:34 <dmwit> I suppose, if you definitely want a single String at the end, that's the way to go, yes.
02:55:37 <Jedai> showsList f xs = '[' : foldr (\a e -> f a . (", " ++) . e) id xs "]"
02:55:38 <monadic_kid> dmwit: so you want to write a puzzle game game like columns/tetris? those a good, small scope. Achievable, you can finish it and it will be rewarding. SDL is a nice simple library if you don't know what to use
02:56:07 <dmwit> Mmm, yes, I've played with SDL a little bit.
02:56:26 <dmwit> I always feel like I'm keeping track of things I shouldn't have to.
02:56:42 <monadic_kid> dmwit: what do you mean? like state?
02:56:56 <dmwit> Like how big the window is, and how big to make each graphic to account for that.
02:57:40 <marcot> Good morning.  Is there a library that contains a function to "fill" a string in 80 columns?
02:58:05 <ivanm> marcot: how do you mean?
02:58:12 <ivanm> pad the beginning or pad the end?
02:58:25 <dobblego> @type replicate
02:58:26 <lambdabot> forall a. Int -> a -> [a]
03:00:35 <dmwit> The SDL sound stuff looks pretty nice, though.
03:00:39 <monadic_kid> dmwit: You should be able to use tools or/and libraries to rescale images. You can use SDL's display format function to convert surfaces to match the current screen surface
03:01:21 <monadic_kid> dmwit: *curren screen surface format
03:01:33 <Jedai> marcot: There are pretty printer around
03:01:39 <marcot> ivanm: I don't want to make a string reach 80 columns, I want to break a String in [String], so that each of them have less then 80 columns.
03:01:46 <Jedai> A simple printf could do it too
03:01:50 <marcot> ivanm: And the words are not splitted.
03:01:58 <ivanm> marcot: oh, do repeated splitAt's then
03:02:03 <ivanm> marcot: that's harder then ;)
03:02:12 <Jedai> Maybe the pretty printer do that...
03:02:16 <ivanm> you can do that with some twiddling
03:02:29 <ivanm> Jedai: not sure if it will convet a String into a multiline String
03:02:31 <Mitar>     Couldn't match expected type `i' against inferred type `(a, b)'
03:02:31 <Mitar>       `i' is a rigid type variable bound by
03:02:34 <ivanm> *convert
03:02:35 <Mitar> where i is Ix i
03:02:48 <ivanm> Jedai: you might have to do a words and then fold them together with <+>
03:02:48 <Mitar> how can i say that i should be Ix and a pair?
03:03:08 <ivanm> Mitar: (a,b) is an instance of Ix if both a and b are instances of Ix
03:05:04 <Mitar> so if I had specified before "(IArray a e, Ix i) => a i e" now i just do "(IArray a e, Ix i) => a (i, i) e"
03:05:05 <Mitar> ?
03:05:24 <marcot> Jedai: do you suggest any one?
03:05:38 <Jedai> ivanm: Yes, but that seems a quite sane solution to me, while maybe not the most performant ever I doubt that it is such a factor
03:05:39 <dmwit> Mitar: It is impossible to tell you how to fix your problem without seeing the code that causes the error.
03:06:07 <Jedai> marcot: pretty, on Hackage (Text.PrettyPrint.HughesPJ
03:06:25 <Mitar> the code is that i am using: snd . fst . bounds $ samples, where samples is "a i e"
03:06:30 <marcot> Jedai: ok, thanks.  I'll take a look.
03:06:37 <ivanm> Jedai: well, pretty comes with GHC
03:06:50 <ivanm> marcot: something like this should work:
03:06:57 <Jedai> ivanm: Right, at least if does until now :)
03:07:04 <ivanm> @type render . foldr (<+>) empty . words
03:07:05 <lambdabot>     Ambiguous occurrence `<+>'
03:07:05 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
03:07:05 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
03:07:08 <ivanm> grrr...
03:07:17 <ivanm> @type render . foldr (Text.PrettyPrint.HughesPJ.<+>) empty . words
03:07:18 <lambdabot>     Ambiguous occurrence `empty'
03:07:18 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
03:07:18 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
03:07:31 <ivanm> @type render . foldr (Text.PrettyPrint.HughesPJ.<+>) Text.PrettyPrint.HughesPJ.empty . words
03:07:32 <lambdabot>     Couldn't match expected type `Doc' against inferred type `[Char]'
03:07:33 <lambdabot>       Expected type: String -> [Doc]
03:07:33 <lambdabot>       Inferred type: String -> [String]
03:07:42 <ivanm> @type render . foldr (Text.PrettyPrint.HughesPJ.<+>) Text.PrettyPrint.HughesPJ.empty . map text . words
03:07:43 <lambdabot> String -> String
03:07:48 <ivanm> marcot: ^^
03:07:56 <ivanm> that's following Jedai's suggestion
03:08:08 <ivanm> replace render with your own preferred rendering style
03:08:28 <Polarina> Using the FFI, I got a Ptr to a struct (struct timespec { time_t tv_sec; long tv_nsec; };) -- how do I read those two values from it?
03:09:05 <dmwit> c2hs will help you
03:09:19 <Polarina> I do not wish to use c2hs.
03:12:25 <Saizan> you've to use peekByteOff with the right offset then
03:12:51 <Polarina> Hmm...
03:13:05 <Polarina> Isn't it possible to "query" the alignment somehow?
03:13:29 <mreh> @pl \list k -> Map.delete k . ilAssocs $ list
03:13:29 <lambdabot> flip ((. ilAssocs) . Map.delete)
03:13:51 <mreh> ooh
03:14:25 <Saizan> sizeOf and alignment should help, but i don't know C well enough :)
03:14:35 <mreh> :t (flip .)
03:14:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
03:15:05 <mreh> brane hurts
03:15:05 <marcot> ivanm: Thanks... I'll look at the docs of this package.
03:15:22 <dmwit> The layout in memory isn't specified by C, it's specified by your ABI.
03:16:43 <McManiaC> how do you match the "end of string" with parsec?
03:16:48 <dmwit> eof
03:18:47 <mreh> can type declarations have unbound variables?
03:18:55 <mreh> I'm thinking not
03:20:42 <McManiaC> dmwit: thx
03:22:15 <dmwit> mreh: Type variables are implicitly bound at the head of the declaration in Haskell.
03:22:34 <dmwit> (id :: a -> a) is really (id :: forall a. a -> a)
03:23:21 <marcot> ivanm: I tried this code you suggested, but it's not including the \n in the produced String.
03:23:40 <dmwit> mreh: If you are in a block and want to use type variables from the context, you can enable the ScopedTypeVariables extension.
03:24:05 <ivanm> hmmm...
03:24:40 <mreh> dmwit: oh okay
03:25:59 <marcot> ivanm: I tried changin all the parameters of renderStyle, and I always get the same results.
03:26:08 <marcot> Which is the same of simply foldr (++) ""
03:26:24 <ivanm> marcot: you might have to play with the rendering settings...
03:26:33 <ivanm> it might be defaulting to really long line lengths
03:26:39 <ivanm> or else use seomthing apart from <+>
03:26:42 <ivanm> check the docs ;)
03:27:02 <marcot> ivanm: Ok, I will... I tried changing the line length.  I'll check for <+>
03:27:51 <marcot> By the way, theres hsep, which is the same of foldr (<+>) empty
03:29:44 <ivanm> heh, fair enough
03:30:58 <marcot> ivanm: I'm looking for fsep.
03:49:00 <McManiaC> can I export custom data definitions without their instances?
03:52:57 <Saizan> you can't avoid exporting instances
04:00:58 <sizur> i forgot what's more efficient again: foldr' or foldl'?
04:01:10 <Heffalump> depends on the thing you're folding over
04:01:24 <damd> for-loops are efficient
04:01:25 <Saizan> foldr' doesn't exist, and wouldn't make much sense
04:01:58 <Saizan> foldr vs. foldl' depends on how lazy is the function you are folding over the list is
04:02:10 <sizur> Saizan: thanks
04:02:14 <Saizan> if it's strict in the accumulator use foldl'
04:05:13 <lpsmith> >  foldl (flip (++))  [] (map (:[]) [1..1000])
04:05:14 <lambdabot>   [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,9...
04:06:00 <lpsmith> >  foldl (++)  [] (map (:[]) [1..1000])
04:06:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:06:08 <lpsmith> >  foldr (++)  [] (map (:[]) [1..1000])
04:06:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:06:24 <Saizan> > foldl (flip (:)) [1..1000]
04:06:26 <lambdabot>   []->
04:06:26 <lambdabot>    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
04:06:44 <Saizan> > foldl (flip (:)) [] [1..1000]
04:06:45 <lambdabot>   [1000,999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,9...
04:06:57 <Polarina> What are you people trying to do?
04:07:20 <Saizan> reverse, one of the few cases where foldl is indicated
04:07:20 <lpsmith> well,  usually you want to use foldr with (++)
04:07:39 <lpsmith> unfortunately lambdabot doesn't give evaluation statistics
04:08:47 <Saizan> >  foldl (++)  [] (map (:[]) [1..1000000])
04:08:49 <lambdabot>   * Exception: stack overflow
04:08:57 <Saizan> >  foldr (++)  [] (map (:[]) [1..1000000])
04:08:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:09:10 <Saizan> :)
04:09:18 <lpsmith> > foldl' (++) [] (map (:[]) [1..1000000])
04:09:20 <lambdabot>   [1* Exception: stack overflow
04:09:29 <lpsmith> heh
04:11:25 <lpsmith> at first,  I preferred left folds,  but as I've become a better haskell programmer,  I've grown to prefer right folds.  (as a general rule of thumb,  not as a dogmatic law)
04:12:08 <dobblego> @pl (:[])
04:12:08 <lambdabot> return
04:12:21 <jpcooper> hello
04:12:32 <lpsmith> jpcooper, hi
04:12:43 <jpcooper> is there something similar to an Array in which I can do updates like with Maps?
04:13:01 <jpcooper> oh, I just discovered //
04:13:51 <lpsmith> jpcooper,  you'd probably want to take a look at the ST monad,  and STArrays,  STUArrays,  or http://hackage.haskell.org/package/uvector
04:14:26 <lpsmith> yeah,  // is ok sometimes,  but updates require copying the entire array,  of course
04:14:50 <lpsmith> So in a lot of situations you don't want to update an Array
04:15:31 <jpcooper> lpsmith, what woudl you otherwise recommend?
04:15:48 <lpsmith> depends,  what are you doing?
04:15:58 <Saizan> or you could use an IntMap
04:16:29 <lpsmith> If you really want updatable arrays,   Data.Array.ST  would be the way to go
04:16:38 <lpsmith> IntMaps can work quite well too :)
04:16:39 <jpcooper> no I would like something fast and functional
04:16:43 <lpsmith> but they aren't arrays
04:16:56 <jpcooper> the maximum array size will be 13
04:17:17 <lpsmith> well then,  array updates might not be such a big deal :)
04:17:35 <lpsmith> yeah,  try // then
04:17:40 <jpcooper> and thinking of it, after I've finished calculating probabilities, then there will be no more updates
04:17:46 <jpcooper> so arrays should be fine
04:19:52 <lpsmith> But really, the best way is to write it up 4 or 5 different ways and measure :)
04:22:05 <Saizan> or do that only after profiling finds that it matters :)
04:24:41 <jpcooper> what would be the best way to have a list and apply f1 to the first n elements and f2 to the rest and then to have the new list of the results joined together?
04:24:53 <Heffalump> fastest, or simplest?
04:24:58 <jpcooper> simplest
04:25:08 <Heffalump> map f1 (take n xs) ++ map f2 (drop n xs)
04:25:09 <jpcooper> or both?
04:25:28 <jpcooper> yeah I thought there might be a more visually pleasing way than that
04:25:29 <Heffalump> fastest would probably involve a single recursive traversal that switches to f2 after n iterations
04:25:39 <Heffalump> @type splitAt
04:25:40 <lambdabot> forall a. Int -> [a] -> ([a], [a])
04:26:07 <Heffalump> @type uncurry (++) . (map f1 *** map f2) . splitAt n
04:26:08 <lambdabot> Not in scope: `f1'
04:26:08 <lambdabot> Not in scope: `f2'
04:26:14 <Heffalump> @type \f1 f2 -> uncurry (++) . (map f1 *** map f2) . splitAt n
04:26:15 <jpcooper> thanks
04:26:15 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
04:26:16 <lambdabot>     In the first argument of `splitAt', namely `n'
04:26:16 <lambdabot>     In the second argument of `(.)', namely `splitAt n'
04:26:24 <Heffalump> @type \f1 f2 b -> uncurry (++) . (map f1 *** map f2) . splitAt n
04:26:25 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
04:26:25 <lambdabot>     In the first argument of `splitAt', namely `n'
04:26:25 <lambdabot>     In the second argument of `(.)', namely `splitAt n'
04:26:28 <Heffalump> @type \f1 f2 n -> uncurry (++) . (map f1 *** map f2) . splitAt n
04:26:29 <lambdabot> forall b a. (a -> b) -> (a -> b) -> Int -> [a] -> [b]
04:26:34 <jpcooper> :t (***)
04:26:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:26:49 <jpcooper> nice
04:26:50 <Heffalump> if you think that's visual pleasing, it should also be reasonably fast.
04:26:59 <Heffalump> so a good solution all round :-)
04:27:04 <jpcooper> indeed
04:29:57 <jpcooper> @type \f1 f2 n -> uncurry (++) . on (***) map f1 f2 . splitAt n
04:29:58 <lambdabot> forall b a. (a -> b) -> (a -> b) -> Int -> [a] -> [b]
04:30:20 <Heffalump> just for that extra piece of code golfing :-)
04:30:29 <Alpounet> @index on
04:30:29 <lambdabot> bzzt
04:30:33 <Alpounet> @hoogle on
04:30:33 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:30:33 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
04:30:33 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:30:41 <Heffalump> @src on -- more helpful
04:30:41 <lambdabot> Source not found. Wrong!  You cheating scum!
04:30:50 <Heffalump> @src Data.Function.on -- once you've found it
04:30:50 <lambdabot> Source not found. Take a stress pill and think things over.
04:30:54 <Heffalump> *sigh*
04:31:01 <Alpounet> heh
04:31:11 <lpsmith> @let mapN f g 0 xs = map g xs ;  mapN f g _ [] = [] ;  mapN f g (n+1) (x:xs) = f x : mapN f g n xs
04:31:12 <lambdabot>  Defined.
04:31:28 <lpsmith> mapN (*2) (^2) 4 [1..10]
04:31:32 <Saizan> i thought it was there, on (*) f x y = f x * f y
04:31:34 <lpsmith> > mapN (*2) (^2) 4 [1..10]
04:31:36 <lambdabot>   [2,4,6,8,25,36,49,64,81,100]
04:31:51 <Heffalump> lambdabot might have an old GHC
04:31:59 <Heffalump> for the library source
04:32:16 <Saizan>  @src has a custom hand-made database
04:32:56 <lpsmith> > mapN (^2) (^3) 5 [1..10]
04:32:58 <lambdabot>   [1,4,9,16,25,216,343,512,729,1000]
04:33:11 <jpcooper> @pt updateProbs score probs = uncurry (++) . on (***) map win lose $ splitAt score probs
04:33:11 <lambdabot> Maybe you meant: ft pl
04:33:15 <jpcooper> @pl updateProbs score probs = uncurry (++) . on (***) map win lose $ splitAt score probs
04:33:15 <lambdabot> updateProbs = ((uncurry (++) . on (***) map win lose) .) . splitAt
04:35:28 <Saizan> @src on
04:35:28 <lambdabot> (*) `on` f = \x y -> f x * f y
04:35:36 * SubStack is creating a graph of types
04:35:36 <Saizan> it doesn't filter out comments :)
04:49:42 <Twey> Try again: I've installed happstack-util via cabal; ghc-pkg list lists it; ghc-pkg describe happstack-util says everything I would expect it to say (including all the visible exported modules).  However, from GHCi, I cannot load any Happstack.* modules.  Tab-complete does not pick them up and attempting to import one results in a ‘Could not find module’ error.
04:53:00 <SubStack> Twey: try ghci -package happstack
04:53:04 <SubStack> possiblye it's just hidden
04:53:19 <SubStack> in which case you can ghc-pkg expose it
04:53:39 <benmachine> that'd show up in ghc-pkg output as parenthised I think
04:53:42 <benmachine> (or blue in 6.12)
04:56:57 <Twey> SubStack: Oooh.  That's interesting.
04:57:06 <Twey> happstack-util-0.4.1-becb57cf3e29a59204fd1fe28d2e6df0 is unusable due to missing or recursive dependencies:
04:58:41 <SubStack> that is highly curious
04:58:47 <Twey> It seems they're depending on one ‘network’ package, which is being shadowed by another of the same version
04:59:15 <Twey> package network-2.2.1.7-0252ed952116094104881798b5b14649 is shadowed by package network-2.2.1.7-bf1531468eb379d74d9cf604560843fc
05:01:08 <SubStack> Data.Graph is pretty underwhelming
05:01:22 <SubStack> I have to compute my own Table array? Really?
05:01:27 <lpsmith> argghhh...  the new citeseer really sucks
05:01:32 * SubStack goes package shopping
05:01:33 <lpsmith> I want the old citeseer back!
05:01:35 <Twey> SubStack: Heh
05:02:07 <SubStack> type Vertex = Int -- >_<
05:02:18 <lpsmith> Not to mention that CiteSeerX seems to be down more often than it is up.   It's availability rate is atrocious
05:03:08 <SubStack> there is a graphtype package :o
05:06:08 <Cale> SubStack: I tend to just use Data.Map
05:06:34 <SubStack> seems odd there isn't something nicer up on hackage is all
05:06:51 <Cale> SubStack: Map Vertex (Set Vertex) for whatever vertex type you care to use, and minor variations on that tend to work well
05:08:25 <Cale> FGL provides a graph type and a fair number of algorithms, but I don't like the identifiers it uses.
05:08:48 <Cale> If you need one or more of those algorithms, it's probably worth considering though.
05:08:55 <Alpounet> fgl is very nice
05:09:08 <Alpounet> and it seems fairly efficient
05:16:10 <lpsmith> personally,  I don't like the FGL,  but it's a bit unfair for me to carp,  as I don't know how to do any better
05:16:17 <lpsmith> it doesn't feel right
05:16:48 <lpsmith> for example,  it's not clear when an definition results in a well-defined function on graphs
05:18:13 <Alpounet> I must admit some stuffs are a bit weird and un-natural
05:20:52 <lpsmith> wow,  citeseerX lists the "Reasoned Schemer",  published in 2005,  with citations from 6 or 7 papers in 1997,  a few in 98,  and 2 in 2001.  Amazing!
05:21:19 <Botje> that's just the reverse state monad in action.
05:21:27 * SubStack proposes a fun graph module, just for fun
05:21:37 <lpsmith> hahaha
05:21:38 <SubStack> fun and functional, how about
05:22:33 <lpsmith> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.3065     I can correct information pertaining to the paper,  but not the bibliography.   That should reference the little schemer,  not the reasoned schemer
05:43:15 <eflister> @djinn m(a->b) -> m (t a) -> m (t b)
05:43:15 <lambdabot> -- f cannot be realized.
05:46:41 <Polarina> How do I use FFI to get the return of a function with type "complex float"?
05:47:00 <paolino> :t \x e -> if isNothing x then throwError e >> return undefined else return . fromJust $ x
05:47:01 <lambdabot> forall a e (m :: * -> *). (MonadError e m) => Maybe a -> e -> m a
05:47:15 <paolino> is it correct the retur undefined there ?
05:48:51 <Pirace> Lemmih: can I pm you with a couple of questions on SDL 0.5.9 bindings?
05:48:55 <maltem> :t throwError
05:48:56 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
05:49:13 <maltem> paolino, why even have it in there?
05:49:36 <paolino> :t \x e -> if isNothing x then throwError e else return . fromJust $ x
05:49:37 <lambdabot> forall a e (m :: * -> *). (MonadError e m) => Maybe a -> e -> m a
05:49:42 <paolino> ah
05:50:25 <iazr> @djinn (Functor m t) => m (a -> b) -> m (t a) -> m (t b)
05:50:25 <lambdabot> Error: Class not found: Functor
05:50:26 <paolino> I was still thinking about 'when' function, thanks
05:50:36 <iazr> @djinn (Monad m t) => m (a -> b) -> m (t a) -> m (t b)
05:50:36 <lambdabot> -- f cannot be realized.
05:50:45 <sohum> this might not be the best place to ask this, but you people are pretty intelligent and have gone to university, so:
05:50:47 <sohum> I'm in... effectively the final year of a bachelor's degree. The degree includes provisions for a number of university-wide electives. I've pretty much ignored those so far, and focused on doing CS course after CS course - completing the more stringent requirements of the degree. So now, I have a decent backlog of university electives available, and I'm not sure what to do with them. Some people I trust very much are suggesting to just do more CS ...
05:50:52 <sohum> ... courses, but a) I've /done/ most of the interesting CS courses already (and I don't really want to do courses on stuff I already know) and b) that feels like missing the point of having university-wide electives. Any suggestions?
05:52:17 <SubStack> take an art class
05:52:21 <maltem> sohum, um... Choose a course that interests you?
05:52:23 <medfly> mathematics?
05:52:34 <SubStack> or do some original research
05:53:37 <sohum> I should add, I suppose, that the reason they're suggesting to do more CS courses is because the transcript will look ... better, or more focused, or something along those lines to both potential employers and potential further academia
05:54:15 <badsheepy> im not sure thats true :o
05:54:29 <SubStack> how things are is more important than how they look
05:54:49 <maltem> This is the last time you're just doing what you what you want to do. As soon as you're employed, no chance.
05:55:21 <badsheepy> how decidedly fatalistic
05:55:53 <sohum> extremely fatalistic :p
05:56:04 <badsheepy> why dont you do whats fun :p
05:56:20 <maltem> Fatalistic?
05:56:38 <SubStack> if you have minimal expenses, it's pretty easy to do whatever you want
05:56:38 <maltem> Rather, an advice not to worry too much.
05:56:41 <sohum> badsheepy: right, and I'm not sure that's true either - but I don't know why I think so.
05:56:50 <SubStack> so long as whatever you want doesn't cost much
05:57:04 <sohum> and I'm not sure I have actual rationale for it
05:57:15 <medfly> maltem, you do have some choice on whether you want to remain employed
05:57:21 <sohum> maltem: huuh. that's one way to look at it, I suppose.
05:57:59 <Twey> SubStack: Thanks to you, I finally got everything working.  :þ  The trouble seems to have been caused by cabal installing a separate network package on top of the one from the Arch repos.
05:58:03 <maltem> SubStack, I was thinking that you probably won't do a 5h/week course in, say, history of musics, when you're having a full-time CS job.
05:58:05 <SubStack> \o/
05:58:21 * SubStack has run into those sorts of problems a lot
05:59:05 <SubStack> maltem: I get the reasoning behind it, but I don't think people should have full-time jobs is all
05:59:08 <medfly> will you take any courses when doing a full time job at anything
05:59:12 <sohum> thankfully haskell's pretty smart about different versions of packages. especially with cabal's autohiding.
05:59:25 <Twey> sohum: They were the same version
05:59:40 <Twey> I don't know why cabal-install decided that another installation was needed
05:59:54 <sohum> Twey: oh? that... is weird
06:00:29 <sohum> Twey: I assume you checked if cabal sees both installations, if the arch-installed version is located somewhere where cabal looks, and all that sort of stuff
06:00:32 <Twey> And then promptly hid the one it had installed, so that everything else, which had built against it, broke :þ
06:00:45 <Twey> Yeah, they were both there
06:01:20 <sohum> that's pretty funny, actually
06:01:28 <SubStack> the biggest problem I have with jobs is that there is an assumption built into the arrangement that the employer will always have things that need done
06:02:06 <SubStack> in my experience this assumption is flawed
06:02:51 <maltem> SubStack, people do talk about shifting employment models these days...
06:03:04 <Twey> Contract work
06:03:54 <interferon> which of the frp gui libraries for haskell are the most actively developed?
06:05:19 <cheater4> sohum: out of 100s of job interviews i've been to, no one ever asked me about my transcript
06:05:51 <SubStack> oh no there are no weighted graph modules, seemingly
06:06:08 <sohum> cheater4: but that information was there in your cv, right?
06:06:20 <cheater4> no
06:06:56 <sohum> huh.
06:07:01 <cheater4> the spiky hair manager doesn't give a rat's ass about your education
06:07:13 <cheater4> he wouldn't even understand what the course names meant
06:07:55 <SubStack> good
06:08:25 <cheater4> if someone suggested that you take courses so that your future boss can see them on a transcript, don't listen to them. they are detrimental to your future because they are pretending to be knowledgable about something they have no tangible experience with.
06:09:39 <cheater4> if you want something that'll get you a job, take a course on agile, or on svn
06:09:44 <SubStack> capable people don't need bosses
06:10:07 <cheater4> those are the first few questions asked.
06:10:19 <luite> there are (university) courses on svn?
06:10:36 <SubStack> ick
06:10:47 <cheater4> sure
06:10:48 <cheater4> labs
06:10:56 <cheater4> management courses
06:10:58 <cheater4> etc
06:11:09 <luite> hm, pretty sure mine doesn't offer those... :p
06:11:27 <cheater4> so what's your point
06:11:40 <medfly> I was told the only time the specifics of your degree matter, is when you don't have experience
06:12:20 <maltem> Department's job ad: "svn knowledge helpful." Manager: "Looks, there's svn in this CV." Something like this? :p
06:12:44 <cheater4> no
06:12:46 <cheater4> more like this:
06:13:24 <cheater4> 'i won't have to sit with him for 3 hours walking him through svn, tortoise svn, setting up svn, revision control basics, diff, and i wont have to roll back his fucked up commits'
06:13:58 <sohum> what about higher education? presumably transcripts are inspected in more detail when you apply for masters/phd
06:14:06 <cheater4> whether you know anything about abstract grammars - nobody cares, unless they hire you to write a compiler.
06:14:17 <cheater4> sohum: yes
06:14:29 <maltem> cheater, ok. But the courses taken say little about if this should actually be true.
06:14:31 <cheater4> sohum: but you shouldn't take courses if you don't want to
06:14:43 <cheater4> maltem: it's good enough
06:16:08 <cheater4> sohum: the whole point of education is to take courses that will be useful in what you want to do in the future. if you see no use for something, you won't be able to learn it properly, because you won't know which parts are important.
06:16:31 <sohum> that makes sense
06:17:15 <medfly> I wonder how all those kids in high school manage mathematics...
06:18:03 <MissPiggy> medfly self study math, get some conformance knocked into you during the day times
06:18:20 <medfly> @wn conformance
06:18:21 <lambdabot> *** "conformance" wn "WordNet (r) 2.0"
06:18:21 <lambdabot> conformance
06:18:21 <lambdabot>      n : correspondence in form or appearance [syn: {conformity}]
06:18:45 <cheater4> aka alignment
06:18:51 <MissPiggy> medfly learning to be controlled by power structures, leaning that nobody cares what is fair if it breaks the rules etc
06:19:24 <maltem> cheater, it's better than nothing, I'd say.
06:19:36 <maltem> s/cheater/cheater4/
06:19:50 <cheater4> whats better than nothing
06:20:03 <maltem> in re "it's good enough"
06:20:16 <maltem> yeah, that's like, 5 minutes ago :)
06:21:06 <sizur> how can i print a floating value without the e notation?
06:21:56 <Peaker> > printf "%f" % (1e10)
06:21:57 <lambdabot>   Ambiguous type variable `r' in the constraints:
06:21:58 <lambdabot>    `Text.Printf.PrintfType ...
06:22:00 <sizur> > show 0.00001
06:22:01 <lambdabot>   "1.0e-5"
06:22:08 <Peaker> > printf "%f" % (11-5) :: String
06:22:09 <lambdabot>   Couldn't match expected type `GHC.Base.String'
06:22:09 <lambdabot>         against inferred typ...
06:22:20 <Peaker> > printf "%f" (1e-5) :: String
06:22:21 <lambdabot>   "0.00001"
06:22:30 <Peaker> too much Python lately :)
06:22:37 <sizur> heh thanks
06:25:30 <eflister> @ djinn (a -> b) -> (a -> m c) -> [a] -> [b]
06:25:53 <idnar> (a -> m c)??
06:25:54 <MissPiggy> eflister -- djinn can't do list! :(
06:26:06 <medfly> it also can't get it when you write @ djinn instead of @djinn
06:26:13 <MissPiggy> @djinn (a -> b) -> (a -> m c) -> Maybe a -> Maybe b
06:26:14 <lambdabot> f a _ b =
06:26:14 <lambdabot>     case b of
06:26:14 <lambdabot>     Nothing -> Nothing
06:26:14 <lambdabot>     Just c -> Just (a c)
06:26:19 <eflister> yeah i have myself in a knot
06:26:25 <MissPiggy> closest you can get is use Maybe and figure out the recursion yourself
06:26:35 <idnar> the (a -> m c) param seems to be useless though
06:26:45 <medfly> it did write _
06:26:50 <MissPiggy> idnar that's expressed formally by the _
06:26:52 <eflister> i need a side effect there
06:26:57 <idnar> MissPiggy: right
06:27:08 <idnar> eflister: then you'll need at least m [b]
06:27:08 <MissPiggy> you can actually consider the _ as a proof
06:28:25 <idnar> @type \f g xs -> mapM (g >> return . f) xs
06:28:26 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a -> a2) -> (a -> a1) -> [a] -> m [a2]
06:28:42 <eflister> @djinn (a -> b) -> (a -> m c) -> Maybe a -> m (Maybe b)
06:28:43 <lambdabot> -- f cannot be realized.
06:28:47 <idnar> hmm, not quite
06:29:05 <idnar> @src mapM
06:29:05 <lambdabot> mapM f as = sequence (map f as)
06:29:36 <idnar> @type \f g xs -> mapM (\x -> g x >> return (f x)) xs
06:29:37 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> b) -> (a -> m a1) -> [a] -> m [b]
06:29:44 <idnar> @pl \f g xs -> mapM (\x -> g x >> return (f x)) xs
06:29:44 <lambdabot> (mapM .) . flip (liftM2 (>>)) . (return .)
06:29:44 <Twey> @djinn Monad m => (a -> b) -> (a -> m c) -> Maybe a -> m (Maybe b)
06:29:45 <lambdabot> -- f cannot be realized.
06:29:51 <Twey> ☹
06:30:13 <eflister> i think i could get what i want with this:   m(a->b) -> m (t a) -> m (t b)
06:30:16 <medfly> Twey, RAA!
06:30:27 <Saizan> djinn doesn't understand constructor classes well
06:30:30 <idnar> @type ap
06:30:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:30:36 <Saizan> so -- f cannot be realized. is no proof.
06:30:45 <idnar> @type fmap fmap . ap
06:30:46 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> a1 -> b) -> (a -> a1) -> f a -> f b
06:30:55 <idnar> @type ap . fmap fmap
06:30:56 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f, Functor m) => m (a -> b) -> m (f a) -> m (f b)
06:31:09 <idnar> @type ap . liftM liftM
06:31:10 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => m (a1 -> r) -> m (m1 a1) -> m (m1 r)
06:31:15 <medfly> scary.
06:31:46 <Twey> medfly: AAR!
06:32:10 <Saizan> ?type \f t -> fmap <$> f `ap` t
06:32:11 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1. (Functor f, Monad f1, Functor f1) => f1 (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
06:32:28 <Twey> Saizan: I think it might be right here, though
06:32:28 <idnar> @type (<*>) . fmap fmap
06:32:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Functor f1) => f (a -> b) -> f (f1 a) -> f (f1 b)
06:32:35 <Twey> There's no way to get from c to b provided
06:32:57 <MissPiggy> yeah
06:33:01 <idnar> Twey: what's wrong with my function?
06:33:07 <Saizan> Twey: you can just ignore the second parameter and use return though :)
06:33:13 <Twey> Saizan: Cheating :þ
06:34:02 <Saizan> ?type \f t -> (fmap <$> f) `ap` t
06:34:03 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Functor m, Monad m) => m (a -> b) -> m (f a) -> m (f b)
06:45:03 <b0fh_ua> Hi there! Can somebody please explain how do I extract value of function "smth :: String -> IO (Bool)" in [x | x <- xs, smth x ] ?
06:45:33 <mux_> :t filterM
06:45:34 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
06:45:39 <mux_> you could use that
06:45:42 <b0fh_ua> nice
06:45:47 <xerox> ?src filterM
06:45:47 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:47:30 <silver> that's cold
06:51:18 <Peaker> filterM _ [] = return []
06:51:19 <Peaker> filterM pred (x:xs) = do { p <- pred x ; rest <- filterM pred xs ; return (if p then x : rest ; else rest) }
06:53:06 <Peaker> or: filterM pred = foldr (\x r -> liftM2 (\p rest -> if p then x:rest else rest) (pred x) r) (return [])
06:53:39 <Peaker> yay, type-checks on the first test :)
07:02:33 * hackagebot upload: NineP 0.0.0 - 9P2000 in pure Haskell (DaveLeimbach)
07:03:13 <MissPiggy> @hackage NineP
07:03:13 <lambdabot> http://hackage.haskell.org/package/NineP
07:03:55 <MissPiggy> wowo cool
07:04:13 <leimy> That's me :-)
07:04:15 <leimy> and Tim
07:04:35 <MissPiggy> i just started to read bout plan 9 the other day
07:04:36 <leimy> It's mainly just the encode/decode bit
07:04:44 <leimy> mainly Tim did this, I just hackaged it
07:05:12 <leimy> I've been a (ab)user of plan 9 and inferno for about 6 years.
07:05:31 <MissPiggy> :))
07:05:39 <leimy> I use Inferno to test networking applications I write at work, because the /net/tcp stack is just too badass to not want to work with :-)
07:08:51 <MissPiggy> @instances ContraFunctor
07:08:52 <lambdabot> Couldn't find class `ContraFunctor'. Try @instances-importing
07:11:21 <maltem> Contrafunctor - maps one fuga to the other
07:12:06 <Alpounet> fuga ?
07:12:35 <opdolio> @wn fuga
07:12:36 <lambdabot> No match for "fuga".
07:12:41 <opdolio> @wn fugue
07:12:41 <lambdabot> *** "fugue" wn "WordNet (r) 2.0"
07:12:41 <lambdabot> fugue
07:12:41 <lambdabot>      n 1: dissociative disorder in which a person forgets who who they
07:12:41 <lambdabot>           are and leaves home to creates a new life; during the
07:12:41 <lambdabot>           fugue there is no memory of the former life; after
07:12:43 <lambdabot> [6 @more lines]
07:12:49 <maltem> Oh, there's indeed such a thing as a contrafunctor. Then I'll shut up
07:13:01 <MissPiggy> XD
07:13:19 <maltem> Turns out the English word would have been fugue...
07:14:23 <maltem> And the pun doesn't even work in English
07:16:30 <maltem> unless one would anglicize "contrafunctor" to "counterfointer" :/
07:19:15 <SubStack> addNode "crockoduck" $ fromEdges [("cat","dog"),("dog","cat"),("pig","pig")] -- graph construction doesn't have to suck
07:19:27 <SubStack> and lo, it exists! http://github.com/substack/hs-graph-fun
07:19:28 <MissPiggy> type Zygo  = (,)
07:19:37 <MissPiggy> omg Zygo is just a tuple!! soilent green is people!
07:19:44 <gwern> :t unlines . unlines
07:19:45 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
07:19:45 <lambdabot>       Expected type: [String] -> [String]
07:19:45 <lambdabot>       Inferred type: [String] -> String
07:20:40 <SubStack> then I'll try to collect various graph algorithms and make them not so horrible to use
07:20:59 <SubStack> maybe the visualization stuff too if I get the time
07:43:48 <Alpounet> SubStack, if you write enough to be able to support a neural network and the necessary operations for it, I may be interested
07:50:50 <Peaker> does anyone know what's the status of Haskell web libraries?  Any page describing the state of the art - which libraries compete, and which complement each other?  Which abstract away HTML/JS and which don't, which do AJAX, etc?
07:52:13 <gwern> so, I was thinking of writing a tool to spider my hard drive and archive using webcitation.org any URLs it finds in text; but I don't have any good ideas on how to efficiently find/recognize URLs. I could iterate through a file until I find an 'h' and thenprogressively 'take' more until 'isURI' returns false, but this seems very inefficient
07:52:19 <ksf> does any of the generics libraries allow me to change the model and only update those parts of the view that depended on the changed parts?
07:52:36 * ksf fears that the answer bogs down to "nag conal about reactive"
07:52:50 <MissPiggy> gwern grep ??
07:53:05 <Saizan> what does reactive has to do with this?:D
07:53:38 <gwern> MissPiggy: grep neither spiders my drive like 'find' nor parses for URLs
07:53:48 <ksf> gwern, http://hackage.haskell.org/packages/archive/stringsearch/0.2.1.1/doc/html/Data-ByteString-Search-KnuthMorrisPratt.html
07:54:05 <Saizan> ksf: both syb and uniplate should let you write fairly flexible queries
07:55:02 <monoidal> what is the difference between let !x = 0 and let (!x) = 0 in GHCi? the latter one requires BangPatterns, the former doesn't
07:55:07 <ksf> ...I'm worried about recalculating a complete view of a say 5 meg structure because a byte changed which doesn't interest the view, at all.
07:55:08 <monoidal> any others?
07:55:25 <gwern> ksf: hm. you think I should do something like 'matchSL (pack "http://") file'?
07:55:36 <ksf> yep
07:55:42 <Saizan> ah, update in the dynamic sense, not just the code
07:55:48 <ksf> yeah
07:55:52 <MissPiggy> gwern lol what
07:56:05 <gwern> ksf: eh. I'd still have the issue of deciding where it ends
07:56:25 <ksf> ...but now you won't waste time deciding where it starts, at least
07:57:24 <Saizan> mh, then you need something like Adaptive
07:57:34 <ksf> as for the end, glob up to the next character that would have to be escaped in a url. those include space and all control characters, so it's going to work for most cases
07:58:25 <gwern> hm. [foo](http://bar); I suppose ) needs escaping
07:58:33 <gwern> be bad if I can't even handle Markdown
07:59:00 <ksf> wait I've already seen adaptive in the context of frp. I dismissed it back then because it is, well, not frp.
07:59:32 <Saizan> not being frp it might actually work! ;)
08:01:57 <gwern> wonder what the difference between boyer-moore and knuth-moriss-pratt is
08:02:43 <ksf> read the wiki pages
08:02:54 <Peaker> I'm reading about Happstack, and it seems to do away with the database.. how does it "scale up"? With databases, you typically run a bunch of fronts to the db...
08:02:57 <ksf> ...minor edge-case big O differences, that is.
08:03:14 <ksf> happstack replicates everything
08:03:16 <gwern> ksf: I am, but they're not helping
08:03:18 <ksf> p2p, so to speak
08:03:26 <Peaker> ksf: so you have a bunch of front web nodes - each with all the data?
08:03:32 <Peaker> ksf: and they send diffs to one another?
08:03:35 <ksf> yep
08:03:49 <Peaker> ksf: and when you need an authorative thingie?
08:03:56 <gwern> kmp is apparently worse-case 2n and bm is 3n. hm
08:04:04 <ksf> iirc updating is done manually, though, because it turns out that most stuff is local and the rest not critical
08:04:04 <Peaker> btw, is Happstack "the" web framework? Or does it have significant competition?
08:04:11 <gwern> kmp it is then
08:04:18 <dolio> The wiki page on Boyer-Moore says it can be sub-linear.
08:04:26 <ksf> ...if you want an authorative thingie, do an authorative thingie.
08:04:34 <Peaker> reading/learning Hasppstack is a good start, I suppose - but I wonder if I should just dive deep into it, or read about others?
08:04:42 <ksf> either by syncing to a dedicated one, or using happstack with a db backend
08:04:49 <Saizan> i think the last happstack release has removed the replication support
08:04:56 <Peaker> Saizan: really? Why?
08:05:12 <Saizan> however you can use the rest of happstack and not happstack-state
08:05:28 <Peaker> Saizan: doesn't that impede the ability to scale up?
08:06:17 <Saizan> Peaker: no replication? it might. i'm not sure about the details of why it got removed, maybe there wasn't anyone that could maintain it
08:15:00 <Peaker> It would be sad if Python+Django scaled up better than Haskell+Happstack
08:16:13 <gwern> > length [1..5]
08:16:14 <lambdabot>   5
08:16:18 <gwern> > take 5 $ [1..5]
08:16:19 <lambdabot>   [1,2,3,4,5]
08:16:58 <sbahra> > take 6 $ [1 .. 5]
08:16:59 <lambdabot>   [1,2,3,4,5]
08:17:27 <Peaker> doh, the happstack tutorial fails to install because of the quickcheck split
08:19:27 <gwern> Peaker: try darcs then
08:19:53 <Peaker> gwern: the happstack tutorial I'm trying to install is from darcs
08:24:03 <Peaker> MissingH is a yucky packaging.. All-or-nothing package of a bazillion little utilities
08:24:16 <Peaker> we've got a package manager, why not use it?
08:25:02 <Peaker> maybe happstack itself, from darcs, would require quickcheck >= 2
08:44:45 <mreh> Should I produce a CV in latex?
08:45:01 <mreh> oops, that's more of a -blah topic
08:45:14 <monochrom> produce a CV in haskell
08:45:26 <Beelsebob> soon you'll be able to with my pdf producing library
08:45:27 <Beelsebob> >.>
08:45:32 <mreh> amazing
08:45:37 <Alpounet> Beelsebob, url of the repo
08:45:42 <Beelsebob> not up yet
08:45:47 <Alpounet> oh ok
08:45:50 <Alpounet> keep us posted
08:45:52 <Beelsebob> it can put graphics on pages atm
08:45:56 <Beelsebob> it can't do text yet though
08:46:00 <Alpounet> ok
08:46:03 <Beelsebob> and I want to get there before hand
08:46:08 <dolio> Make one like this: http://www.barneysvideoresume.com/
08:46:10 <Alpounet> yeah sure
08:47:03 <Beelsebob> also mreh – no, LaTeX resumes look pretty meh imho, you also have to be ultra careful getting info in
08:47:38 <CalJohn> Beelsebob: why do you think so?
08:48:23 <Beelsebob> the layout is pretty generic – to people who know latex it looks like you put 10 seconds into typing it into latex, to people who don't it looks like you just aren't very good at working MS Word
08:48:34 <Beelsebob> and LaTeX puts lots of whitespace in
08:48:36 <Beelsebob> for good reason
08:48:42 <Beelsebob> but it means you don't get much info in your space
08:50:22 <CalJohn> that stuff only applies if you do spend 10 seconds pasting it into latex
08:50:41 <CalJohn> i'll carry this on in that other channel
09:27:13 * hackagebot upload: HaskellTorrent 0.0 - A concurrent bittorrent client (JesperLouisAndersen)
09:31:55 <jlouis> \o/
09:31:57 <sinelaw> ping
09:31:58 <gogonkt> PONG, now at #haskell
09:32:09 <sinelaw> wtf, is that a bot?
09:32:11 <sinelaw> ping
09:32:12 <gogonkt> PONG, now at #haskell
09:32:23 <MissPiggy> PONG, now at #haskell
09:32:28 <sinelaw> ping ping
09:32:32 <jlouis> MissPiggy: haha
09:32:39 <jlouis> MissPiggy is now a bot
09:33:40 <KermitTheFrog> MissPiggy, :)
09:33:55 <jaspervdj> ah, I finally “get” arrows now, to bad I don't have a use case for it now
09:34:26 * sinelaw gets back to work
09:34:39 <medfly> sinelaw, ?!?
09:35:00 <sinelaw> medfly, never seen the muppets?
09:35:06 <jlouis> Mananan!
09:35:28 <medfly> sinelaw, I have seen the date... back to work?
09:35:29 <jlouis> Animal is so damn cool
09:35:41 <Entroacceptor> explain arrows to me, then :)
09:35:58 <MissPiggy> oh no!!!!
09:36:16 <sinelaw> medfly, work, productive stuff, whatever
09:36:20 <sinelaw> not real "work"
09:37:50 <jaspervdj> Entroacceptor: they're ways of doing computations
09:38:24 <sinelaw> zygoacceptor
09:38:38 <opqdonut> zygoraptor
09:39:00 <jaspervdj> Entroacceptor: http://www.soi.city.ac.uk/~ross/papers/fop.html is _very_ good imo
09:40:02 <sinelaw> jaspervdj, thanks too :)
09:40:05 <sinelaw> added to reading list
09:40:44 <Yoshibloke> Is there a way to access say the third of forth element of a tuple. Like fst and snd?
09:40:59 <Yoshibloke> or do you have to pattern match
09:41:06 <ddarius> You have to pattern match.
09:41:10 <ddarius> Of course
09:41:11 <ddarius> @src fst
09:41:12 <lambdabot> fst (x,_) =  x
09:41:49 <dolio> @type \(_,_,y,_) -> y
09:41:50 <lambdabot> forall t t1 t2 t3. (t, t1, t2, t3) -> t2
09:41:50 <Yoshibloke> so I can't do anything like !! has for lists?
09:41:56 <idnar> by the time you're up to four elements, it's probably time to consider an ADT
09:42:02 <sinelaw> @pl \(_,_,y,_) -> y
09:42:03 <lambdabot> (line 1, column 6):
09:42:03 <lambdabot> unexpected ","
09:42:03 <lambdabot> expecting operator or ")"
09:42:03 <lambdabot> ambiguous use of a non associative operator
09:42:06 <Yoshibloke> ADT?
09:42:14 <sinelaw> @hoogle (_,_,y,_) -> y
09:42:14 <lambdabot> Data.Typeable typeOf4 :: Typeable4 t => t a b c d -> TypeRep
09:42:14 <lambdabot> Data.Typeable typeOf3Default :: (Typeable4 t, Typeable a) => t a b c d -> TypeRep
09:47:43 <HugoDaniel> hmm
09:48:37 <HugoDaniel> hpaste is down :/
09:50:05 <HugoDaniel> http://pastebin.com/m2b274338
09:50:12 <HugoDaniel> is there any extension to remove that error ?
09:50:15 <HugoDaniel> or something like that :/
09:50:20 <HugoDaniel> i want to pattern match
09:50:24 <ksf> adaptive uses way too many monads to be comfortable to work with
09:50:38 <ksf> ...and I thought iteratees were throwing a lot of type errors at me
09:52:08 <ksf> ...also, on another scale, it's way too single-threaded for my taste.
09:54:42 <ksf> why just replace n with NoiseModule.
09:54:48 <ksf> the other possibility is to use a view
09:56:10 <ksf> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#view-patterns
09:56:50 <ksf> ...to pattern match, of course, you have to implement yet another data type that can be mapped onto from all of your NoiseModuleC types.
09:57:10 <HugoDaniel> oh hmm
09:57:24 <HugoDaniel> there is no way to turn that type variable "less rigid" ?
09:57:33 <ksf> or you can do views for specific properties you're interested in.
09:57:59 <HugoDaniel> hmm ill look onto views
09:58:05 <ksf> er no. if it's a variable, it's got to be variable, but ghc infers from the function that it _has_ to be non-variable
09:58:28 <HugoDaniel> ok
09:58:30 <HugoDaniel> thanks
09:58:34 <HugoDaniel> ill try the views
09:59:22 <ksf> it's kinda akin to "less polymorphic than expected"
09:59:43 <HugoDaniel> are you going to the hackaton ?
09:59:49 <ksf> nope
09:59:54 <HugoDaniel> oh, ok
10:00:42 <HugoDaniel> im kinda excited with it, meeting other haskell coders in flesh and bone :)
10:05:29 <freiksenet> if I am using forM_ to go through a sequence, is there any equalent to break? so I can stop evaluation if some condition is met
10:06:00 <Zao> Throw something?
10:06:08 <Yoshibloke> I imagine you'll have to write something recursive instead
10:06:28 <freiksenet> throw? you mean like exception?
10:06:29 <maltem> not with forM_, no
10:07:07 <freiksenet> it is just that I have a STRef state, so I need to have some sequential operation here.
10:07:17 <freiksenet> maltem: is there any alternative?
10:07:17 <maltem> Exceptions would probably get a little ugly, just to stop on a condition
10:07:44 <maltem> freiksenet, what Yoshibloke said (unless there's a handy combinator I cannot think of right now)
10:07:51 <ksf> untilM is the solution
10:08:37 <aavogt> > let ((+1) -> x) = 1 in x
10:08:38 <lambdabot>   Illegal view pattern:  ((+ 1) -> x)
10:08:38 <lambdabot>  Use -XViewPatterns to enable view patt...
10:08:51 <maltem> @index untilM
10:08:51 <lambdabot> bzzt
10:08:55 <ksf> wait no just use sequence_ . foldM_
10:08:56 <freiksenet> ksf: can't find it on hoogle
10:09:01 <ksf> :t  sequence_ . foldM_
10:09:02 <lambdabot>     Couldn't match expected type `[m a]'
10:09:02 <lambdabot>            against inferred type `a1 -> [b] -> m1 ()'
10:09:02 <lambdabot>     Probable cause: `foldM_' is applied to too few arguments
10:09:14 <Gracenotes> foldM folds left
10:09:18 <ksf> ah duh.
10:09:28 <Gracenotes> Data.Foldable.foldrM doesn't
10:09:49 <aavogt> @tell Cale: could you enable -XViewPatterns in \bot please?
10:09:49 <lambdabot> Consider it noted.
10:09:49 <ksf> freiksenet, what's your terminating condition?
10:10:13 <Gracenotes> I think I've run into your situation. I just defined a recursive function with let, and then called it
10:10:16 <freiksenet> STref value is smaller than some other value
10:10:53 <freiksenet> Gracenotes: will it work with STref?
10:11:23 <Gracenotes> you don't know until you try
10:11:29 <Gracenotes> or until you know
10:11:55 <Gracenotes> my ugly solution, though, looked like: let whileShiftM mask = do { target <- readSTRef targetr; let { mask' = mask `shiftR` 1 }; if (target .&. mask' /= 0) then (modifySTRef targetr (complement mask' .&.) >> whileShiftM mask') else return mask'
10:12:28 <freiksenet> ok, that might work
10:12:34 <freiksenet> something like that
10:12:54 <ksf> foo [] = return (); foo (x:xs) = val <- readSTRef; if val > 2 then ...; foo xs else bar
10:13:02 <ksf> er else return ()
10:13:31 <Gracenotes> actually, this was within a forM_. What I could have done was drop the need for targetr to be an STRef, and make the forM_ into a foldM_
10:13:32 <freiksenet> ksf: thanks
10:13:54 <ksf> ...the important thing to notice, that, unlike say C, haskell is a fully-featured imperative language: it has first-class statements.
10:14:01 <Gracenotes> not to say this wasn't efficient
10:15:09 <ksf> things like accumMap or such might also work, depending on situation.
10:15:34 <freiksenet> ksf: recursive function works fine
10:15:37 <freiksenet> thanks a lot
10:15:57 <ksf> doesn't surprise me
10:16:01 <ksf> @src forM
10:16:02 <lambdabot> forM = flip mapM
10:16:06 <ksf> @src mapM
10:16:06 <lambdabot> mapM f as = sequence (map f as)
10:16:11 <ksf> @src sequence
10:16:12 <lambdabot> sequence []     = return []
10:16:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:16:12 <lambdabot> --OR
10:16:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:16:19 <ksf> see, it's recursive, too.
10:17:10 <ddarius> You need one more src to verify that.
10:17:15 <ddarius> Layers and layers of abstraction.
10:17:45 <ksf> ddarius, I'm a smart terminating algorithm. the first of the alternatives matches the end of the search.
10:17:46 <ddarius> (Well, in terms of the foldr definition.  map too can be defined in terms of foldr)
10:18:14 <ksf> but it could also be inlined with sequence
10:18:22 <ksf> options, options, everywhere options...
10:23:11 <HugoDaniel> http://paste.ideaslabs.com/show/ZwvOs13iCZ
10:23:26 <HugoDaniel> this is how its working right now... it seems ok, right ?
10:23:30 <freiksenet> it is not possible to have pattern matching function in where, is it?
10:24:13 <Cale_> freiksenet: It's possible to have pattern matching wherever you have a function
10:24:21 <HugoDaniel> it works without the parenthesis
10:25:01 <HugoDaniel> myNoise = perlin { frequency = 0.123 } `isSourceOf` scalebias { scale = 10.0 } `isSourceOf` absolute
10:25:03 <HugoDaniel> like this
10:25:04 <freiksenet> Cale_: ah, sorry that was just my typo :)
10:30:33 <HugoDaniel> http://hackage.haskell.org/package/open-pandoc-1.4 this seems very usefull!
10:46:02 <ksf> ...that's the price you have to pay for using a parsing lib that's too big to just snarf into your code.
11:21:45 <Peaker> installing happstack is a pita
11:22:00 <Peaker> quickcheck split is really problematic + dependency on quickcheck is not even necessary
11:24:50 <monoidal> should I import Monad or import Control.Monad?
11:24:56 <chrisdone> http://www.reddit.com/r/programming/comments/b4g2p/please_format_your_code_to_80_columns_or_at_least/
11:24:56 <chrisdone> do we have an official Haskell style guide? there's this one http://urchin.earth.li/~ian/style/haskell.html , but it might be worth putting it on the wiki if the author allows
11:25:33 <ddarius> monoidal: The latter unless you -really- care about strict Haskell 98 conformance.
11:25:59 <ddarius> chrisdone: There is some style advice already on the wiki.
11:26:15 <monoidal> ddarius: what are the differences?
11:27:16 <sinelaw> Peaker, :(
11:27:17 <Peaker> monoidal: Haskell98 didn't support dots in module names
11:27:21 <ddarius> monoidal: Monad is in the Report, Control.Monad is not and also requires the hierarchical modules extension.
11:27:40 <monoidal> thanks
11:27:42 <ddarius> Though, "extension" is an overstatement here and every implementation does and will support that "extension."
11:28:20 <CalJohn> chrisdone: that style guide is nice, but has almost nothing to do with haskell specifically, which is sad, because I was hoping someone had thought hard about what's unreadable, and written down some rules :(
11:29:13 <monoidal> also http://www.haskell.org/haskellwiki/Category:Style
11:34:31 <Vitka> Can anybody point me in right direction to define certain recursive function?
11:34:55 <MissPiggy> Vitka, perhaps
11:35:13 <MissPiggy> what sort of recursive function ?
11:35:25 <Obonga> Hello
11:35:30 <Vitka> Recursive equations like these: http://tinypic.com/r/ddme5j/6 How would I go around it?
11:35:42 <MissPiggy> hi Obonga
11:35:42 <Vitka> There are two linked equations.
11:35:50 <Obonga> haha
11:35:51 <Obonga> nice one
11:35:54 <MissPiggy> it's not loading
11:36:02 <MissPiggy> on there we go
11:36:21 <Vitka> http://tinypic.com/view.php?pic=ddme5j&s=6 - try that.
11:36:36 <MissPiggy> Vitka, what is S_0,0 though?
11:36:38 <Obonga> http://media.viacum.org/~mao/tinypic/r/ddme5j/6 - try my tinypic proxy
11:36:42 <MissPiggy> because without an initial value you can't compute
11:36:50 <MissPiggy> Obonga, no thank you.
11:37:07 <MissPiggy> Obonga, I don't think I want to click any link from you
11:37:26 <Vitka> It's initial value, computed by other function. It's no problem, I'm just confused on how to tie two functions together.
11:37:51 <MissPiggy> Vitka, you can just write it straight away in haskell, like this:  s (i+1) j = xpa * s i j + 1/(2*p) ... ; s i (j + 1) = ...
11:38:23 <Vitka> I thought (i+1) is not allowed in function arguments?
11:38:43 <monoidal> it is, but the usage is discouraged and is deprecated
11:39:26 <Vitka> Hmm.
11:39:31 <monoidal> > let f x 0 = 0; f 0 y = 0; f x y = x + f (x-1) (y-1) in f 3 4
11:39:31 <lambdabot>   6
11:40:05 <MissPiggy> it is discouraged by monoidal
11:40:12 <MissPiggy> It is not discourged by me
11:41:11 <Vitka> Alright, I'll try it. Thorugh, despite what they say about preemptive optimization, will this be optimal performance-wise?
11:41:39 <MissPiggy> Vitka, no - it will be horrendous in terms of performance
11:42:01 <Vitka> Especially since, say, S_0,1 and S_1,0 differ only in X part, is there more elegant way?
11:42:27 <MissPiggy> :|
11:42:34 <MissPiggy> elegant to mash the two equations into one?
11:42:58 <Vitka> Well...
11:44:44 <Vitka> More along the lines of not computing the same thing multiple times in course of evaluation.
11:44:50 <MissPiggy> yes
11:45:06 <MissPiggy> that is the problem of this code but here is the first thing to do:  Get the 'inefficient' version working correctly
11:46:20 <Vitka> Alright. Let's see what I can do.
11:49:02 <sinelaw> does anyone know why I can't join #f3?
11:49:05 <sinelaw> #f#?
11:49:31 <ksf> zomfgbbq
11:49:34 <lament> you're in it...
11:49:38 <ksf> elerea doesn't drop events, anymore
11:49:49 <sinelaw> #fsharp, my bad.
11:49:54 <sinelaw> i'm in it now.
11:52:03 * hackagebot upload: statistics-fusion 1.0.1 - An implementation of high performance, minimal statistics functions (DonaldStewart)
11:53:07 <c_wraith> that looks handy.
11:56:41 <djahandarie> dons, I thought that was obsolete?
11:57:21 <djahandarie> Did you just do the uvector -> vector update incase anyone was using it?
11:59:17 <jmcarthur> djahandarie: statistics-fusion uses Vector
11:59:50 <djahandarie> jmcarthur, wasn't that just changed moments ago?
11:59:54 <HugoDaniel> i wish i could specify the functions in the record syntax
12:00:23 <jmcarthur> djahandarie: yes? maybe i missed the point of what you were saying
12:00:45 <djahandarie> jmcarthur, I thought the package was obselete, was wondering why it was updated rather than something else
12:01:29 <jmcarthur> djahandarie: oh, i wasn't aware of it being obsolete
12:02:43 <copumpkin> statistics-fusion is obsolete
12:02:53 <copumpkin> or wait, maybe not
12:03:38 <djahandarie> This is why I was pinging dons. :P
12:04:57 <Twey> @index msum
12:04:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:15:23 <mietek> Has anyone tried relocating the OS X GHC?
12:17:59 <mietek> The Building/Installing wiki page mentions hardcoded paths in package.conf and wrapper scripts.  But it seems that there are also paths within the actual binaries...
12:25:48 <Twey> Hm… the Happstack tutorial suggests that exactdir "" should match the root path, but doing simpleHTTP (Conf 8081 Nothing) . exactdir "" . return $ toResponse "foo" yields a 404 for /
12:27:59 <ksf> shouldn't that be "/"?
12:28:08 <ksf> there's no "" path as far as HTTP is concerned
12:28:15 <Twey> Ah… that works…
12:28:19 <Twey> http://tutorial.happstack.com/src/ControllerBasic.hs
12:28:26 <Twey> Definitely says ""
12:30:58 <Peaker> did anyone get Happstack working on ghc 6.12?
12:31:19 <Twey> I did
12:31:21 <Twey> Eventually
12:39:58 <Vitka> @pl sqrt (f a b)
12:39:58 <lambdabot> sqrt (f a b)
12:40:55 <c_wraith> did you want something more like:
12:41:07 <c_wraith> @pl \a b -> sqrt (f a b)
12:41:07 <lambdabot> (sqrt .) . f
12:41:34 <copumpkin> dons: I think we'll need to talk to RL to see if he can make the interface slightly more flexible
12:41:46 <copumpkin> unless you've been able to think of an alternative
12:42:19 <Twey> @pl \f a b -> sqrt (f a b)
12:42:19 <lambdabot> ((sqrt .) .)
12:42:31 <mietek> Any ideas why GHCi would fail to load HSBase with the following error?
12:42:31 <Vitka> Right.
12:42:32 <mietek> ghc:
12:42:32 <mietek> /usr/local/Cellar/ghc/6.12.1/lib/ghc-6.12.1/base-4.2.0.0/HSbase-4.2.0.0.o: unknown symbol `_environ'
12:42:33 <Twey> A.K.A. (fmap sqrt .)
12:42:35 <mietek> Loading package base ... linking ... ghc: unable to load package `base'
12:43:55 <mietek> Aha!
12:44:15 <Twey> (fmap . fmap) sqrt
12:44:19 <Twey> fmap (fmap sqrt)
12:44:21 <Twey> Hmm
12:44:39 <Twey> No, I think I prefer (fmap sqrt .)
12:45:00 <Twey> mietek: What was it?
12:45:07 <c_wraith> :t fmap fmap fmap sqrt
12:45:08 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *). (Functor f, Functor f1, Floating b) => f (f1 b) -> f (f1 b)
12:46:31 <Twey> Gosh, that's a dodgy-sounding function
12:46:48 <burp> kind of boop operator
12:47:37 <mietek> Twey: I suspect my package manager automatically strips binaries; I found a bug report which basically says that you shouldn't strip ghc on OS X
12:47:42 <Twey> Aha
12:48:22 <mietek> I'm trying to get ghc to install through homebrew on OS X
12:48:29 <mietek> Almost done.
12:49:50 * LaydgirL  Sex Can I click Login http://www.seslibitanem.com Sex Can I click Login http://www.chatvebiz.tr.gg
12:49:54 * LaydgirL  Sex Can I click Login http://www.seslibitanem.com Sex Can I click Login http://www.chatvebiz.tr.gg
12:49:55 * LaydgirL  Sex Can I click Login http://www.seslibitanem.com Sex Can I click Login http://www.chatvebiz.tr.gg
12:49:56 * LaydgirL  Sex Can I click Login http://www.seslibitanem.com Sex Can I click Login http://www.chatvebiz.tr.gg
12:49:57 <copumpkin> nice
12:49:58 * LaydgirL  Sex Can I click Login http://www.seslibitanem.com Sex Can I click Login http://www.chatvebiz.tr.gg
12:49:59 <copumpkin> @where ops
12:50:00 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
12:50:04 * djahandarie sighs
12:50:05 <lament> sex can i click login?
12:50:07 --- mode: ChanServ set +o Saizan
12:50:08 <lament> what?
12:50:17 --- mode: ChanServ set +o xerox
12:50:17 --- mode: ChanServ set +o Igloo
12:50:19 --- mode: Igloo set +b *!*@94.122.197.190
12:50:20 --- kick: LaydgirL was kicked by Igloo (LaydgirL)
12:50:24 <mietek> lament: "Sex Can"
12:50:25 <copumpkin> oh wow, epic opfest
12:50:38 <mietek> lament: "the First"
12:50:42 <lament> sex, can i? click login
12:50:45 <Heffalump> Igloo was last to op and first to kick, clearly he deserves some award :-)
12:51:02 * copumpkin crafts a trophy out of bread
12:51:02 <ksf> what does "vertical refresh" mean for a lcd screen, anyway?
12:51:14 * Saizan shouldn't ignore so much of the modes on this channel
12:51:17 <xerox> I lost on autocomplete L, too eager
12:51:21 <sinelaw> @hoogle scanr
12:51:21 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:51:21 <lambdabot> Data.ByteString scanr :: (Word8 -> Word8 -> Word8) -> Word8 -> ByteString -> ByteString
12:51:21 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:51:30 <Igloo> It's mostly because I mistyped chanserv and then failed to ban/kick before fixing my typo  :-)
12:51:35 <xerox> Saizan some ignoring is definately needed :)
12:51:37 <sinelaw> @hoogle (a -> b->b) -> b -> f a -> f b
12:51:39 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:51:39 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
12:51:39 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
12:51:49 * copumpkin presents epic bread trophy to Igloo for great service to #haskell
12:51:53 <Entroacceptor> why not autoop? is there a reason?
12:51:57 --- mode: Saizan set -o Saizan
12:51:57 <ksf> ...even if we take into account that both vga and dvi cables are serial, I bet that stuff is buffered.
12:51:58 --- mode: xerox set -o xerox
12:52:04 <copumpkin> Entroacceptor: creates an ATMOSPHERE OF OPPRESSION
12:52:19 --- mode: Igloo set -o Igloo
12:52:24 * djahandarie oppresses copumpkin 
12:52:26 <copumpkin> Entroacceptor: why do you have freedom?!?!?!
12:52:29 <copumpkin> *hate
12:52:30 <copumpkin> dammit
12:52:59 <Entroacceptor> I don't hate freedom, I just believe that it's better for yourself to give up freedom to keep others in line ;)
12:53:01 <djahandarie> I hate, hate, hate, hate, hate, hate you!!!
12:53:56 <copumpkin> wow, did anyone see psykotic's epic mersenne generator?
12:53:59 <HugoDaniel> ?
12:54:01 <MissPiggy> freedom to spam!
12:54:03 <copumpkin> > [n | (p, n + 1) <- zip [2..] (iterate (2 *) 4), iterate (\  s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
12:54:05 <djahandarie> Life... dreams... hope... where'd they come from? And where are they headed...? These things... I'm going to destroy!!!
12:54:07 <lambdabot>   mueval-core: Time limit exceeded
12:54:08 <MissPiggy> spammers rights!
12:54:10 <xerox> copumpkin is it?
12:54:13 * djahandarie stops quoting Kefka
12:54:14 <copumpkin> > take 10 [n | (p, n + 1) <- zip [2..] (iterate (2 *) 4), iterate (\  s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
12:54:15 <lambdabot>   [7,31,127,8191,131071,524287,2147483647,2305843009213693951,618970019642690...
12:54:22 <xerox> ah, no mersenne TWISTER.
12:54:40 <copumpkin> yeah, generator of primes
12:54:47 <Entroacceptor> arrg, can't resist. Sorry in advance
12:54:53 <Entroacceptor> Help, help, I'm being repressed!
12:55:05 * copumpkin oppresses Entroacceptor for great justice
12:55:16 <sinelaw> heh
12:55:17 <xerox> @slap Entroacceptor
12:55:17 * lambdabot pushes Entroacceptor from his chair
12:55:23 <xerox> lol.
12:55:24 <MissPiggy> endofuctor?
12:55:30 <sinelaw> zygoacceptor
12:55:37 <xerox> lambdabot is the oppressor
12:55:45 <sinelaw> don't force me to bring in psychobot
12:55:50 <Zao> Oh god.
12:56:42 <Twey> Oh, psychobot is yours eh
12:56:46 <Entroacceptor> rivertam will avenge me!
12:56:54 <copumpkin> entrofunctor
12:57:05 <Twey> Hehe
12:57:22 <Entroacceptor> haha
12:57:22 <sinelaw> Zao' doesn't like psychobot, because it keeps pinging his nick
12:57:32 * sinelaw gets back to "work"
13:03:32 * hackagebot upload: NineP 0.0.1 - 9P2000 in pure Haskell (DaveLeimbach)
13:07:20 <ksf> loadMemoryTexture2D :: String -> [TextureFlag] -> IO Bool
13:07:30 <ksf> those GLFW bindings just disqualificated themselves.
13:08:27 <mietek> All right, it works now.
13:09:31 <Peaker> ksf: because of Bool instead of exceptions?
13:09:38 <Peaker> ksf: oh, String
13:09:54 <Peaker> ksf: that sucks, yeah
13:13:11 <ksf> ...if you look under the hood, you see withCStringPtr $ \ptr -> ...
13:13:28 <ksf> the documentation says "bytestring"
13:14:26 <gutentag> Why are Slovenians so suicidal, the guy who writes learnyouahaskell is Slovenian...
13:14:35 <Peaker> ksf: so where does it say String?
13:14:47 <gutentag> I never knew why they kill themselves so much.
13:15:09 <ksf> ...in the type sig.
13:15:55 * ksf wonders why gpipe wants containers-0.2.0.1 which does'nt build because base is hidden.
13:16:27 <MissPiggy> gutentag what??
13:16:31 <Zao> gutentag: And reading your chat.
13:17:05 <gutentag> Slovenia is the fourth ranked country in terms of suicide.
13:17:13 <gutentag> I'm just wondering the reason for this.
13:17:29 <gutentag> Also, lyah's author is from that country
13:17:41 <gutentag> so it's on topic, sort of
13:17:44 <Zao> gutentag: Not really.
13:17:45 <monadic_kid> ...
13:17:52 <Zao> Almost not on topic for -blah.
13:18:15 <monadic_kid> i'm almost thought the worst case scenario
13:19:09 <ksf> that's off topic in -blah. like everything else that has any connection whatsoever with haskell
13:19:22 <Mitar> if i have a 2D IArray ... how can i make a function which would know how to process one row and that I would then be able to call it so that it processes all rows?
13:19:33 <dejones> dons, xmonad: let me count the ways I love thee.  :)  thank you!
13:25:47 <gutentag> Ah this explains the reasons: http://www.ce-review.org/00/20/pozun20.html
13:26:05 <gutentag> It's unfortunate, actually.
13:36:35 <Mitar> gutentag: what it explains?
13:38:54 <Warrigal> I think it's time to start working on my project once again.
13:39:02 <MissPiggy> what probject
13:39:09 <Warrigal> My Haskell project.
13:39:14 <MissPiggy> ??
13:39:44 <monochrom> Me too.
13:39:51 <Warrigal> I'd have to give an elevator speech just to tell you what it is.
13:40:15 <MissPiggy> ok
13:40:41 * hackagebot upload: minimung 0.1 - Shows how to run grabber on Mac OS X (YakovZaytsev)
13:41:20 <copumpkin> can anyone figure out what that package does? http://hackage.haskell.org/package/minimung-0.1
13:41:42 * hackagebot upload: hack-handler-epoll 0.1.3 - hack handler implementation using epoll (ToralfWittner)
13:42:10 <DrTeggy> "Modules under Mac are stable and good." ... hmm
13:42:50 <galdor> got a Handle/Socket question; when creating a handle with socketToHandle, I get a "already a Handle" error
13:43:12 <galdor> the idea is that I reload the process with exec, passing the fd to the process
13:43:28 <galdor> when I restart, I see if there's a fd as argument, and if yes, I re-create the handle
13:43:48 <galdor> the socket is re-created with mkSocket and the ConvertedToHandle state
13:44:06 <galdor> but since it's "already a Handle", how can I get this handle ?
13:48:10 <dejones> Hello, I am having some issues getting cabal-install tool to install, the bootstrap.sh script doesn't seem to be working correctly, says I need parsec installed, which I have done.
13:48:14 <dejones> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22193#a22193
13:48:26 <dejones> any help would be great.  :)
13:48:44 * hackagebot upload: vector-random 0.1 - Generate vectors filled with high quality pseudorandom numbers (DonaldStewart)
13:50:31 <gutentag> I hope Slovenia becomes richer, then the suicide rate should fall.
13:51:05 <Mitar> gutentag: you are from Slovenia?
13:51:13 <gutentag> no
13:51:23 <Mitar> do you think, that richness is important for happiness?
13:51:27 <DrTeggy> He's loves talking about Slovenia apparently.
13:51:36 <MissPiggy> I like slovenia
13:51:45 <DrTeggy> s/He's/He/
13:51:55 <gutentag> well Slovenia is near 100% literacy, yet the GDP is low
13:52:10 <Mitar> hm, what means low GDP?
13:52:13 <gutentag> so they aren't happy, plus their genetics, plus their alcoholism and neurises and psychoses
13:52:18 <Mitar> last time i checked was > 10k
13:52:43 <BONUS> the weather in slovenia right now is shit
13:52:48 <gutentag> http://www.ce-review.org/00/20/pozun20.html
13:52:51 <gutentag> read that
13:52:55 <DrTeggy> This is ridiculous.
13:53:06 <gutentag> it explains the reason for Slovenia's high suicide rate
13:53:18 <Mitar> gutentag: you should not believe everything you read ;-)
13:53:27 <MissPiggy> is "near 100% literacy" something impressive?
13:53:34 <dejones> yes
13:53:34 <MissPiggy> I thought most of the world had that
13:53:37 <dejones> nein
13:53:37 <gutentag> Slovenia's Suicidal Tendencies  Brian J Požun
13:53:41 <MissPiggy> hmm
13:53:51 <Mitar> Wikipedia says Slovenia has $29,520 GDP per capita
13:53:53 <Mitar> 30th in the world
13:54:18 <gutentag> Maruai based his research on the theory that literacy rates and gross national product (GNP) are the reason. According to Maruai's theory, the higher any given country's literacy rate and the lower that country's GNP, the more likely the country is to have a high suicide rate. The theory can be convincingly applied to the countries with the highest suicide rates in Europe, namely the three Baltic states, Hungary and Slovenia, wh
13:54:34 <Mitar> yes, this literacy is legacy of Austro-Hungarian school reforms
13:54:41 <gutentag> have been adversely affected by the transition process.
13:55:04 <Mitar> gutentag: does not Japan has high GNP? ;-)
13:55:28 <gutentag> There are different reasons for that country,
13:55:35 <gutentag> I'm a Japanologist, in fact
13:56:08 <BONUS> im from slovenia and, well, its just a normal boring country imo
13:56:20 * DrTeggy grins.
13:56:35 <gutentag> According to World Health Organization statistics, almost 100,000 people committed suicide in 1998, making it the twelfth leading cause of death worldwide. Slovenia's annual suicide rate is about 30 per 100,000 inhabitants, giving an annual total of about 600. It is believed that as many as one third of Slovenia's suicides are connected to alcoholism. With its small population of around 2 million, this represents a huge problem.
13:56:35 <Saizan> dejones: it might be checking for version 2 of parsec, you might comment that check in the script, you have to install network too though
13:56:51 <Saizan> gutentag: that should go to #haskell-blah
13:56:53 <MissPiggy> gutentag japanologist??
13:56:57 <MissPiggy> okay I am going to -blah
13:56:58 <weilawei> Can someone sum up points vs point-free? It gets a lot of mention and very little explanation
13:56:59 <gutentag> yes
13:57:09 <Mitar> yes, i think this essay you are reading about suicide is typical slovenian discourse and low self-esteem ... slovenians are all the time saying how bad they are ...
13:57:50 <BONUS> weilawei: pointful functions are functions with explicit parameters
13:57:50 <Saizan> weilawei: points free is when you write your function without using formal parameters
13:57:57 <QtPlatypus> weilawei: \\\\
13:58:00 <BONUS> like f x y = ... or (\x y -> ...)
13:58:12 <QtPlatypus> sorry
13:58:21 <Mitar> if i have a 2D IArray ... how can i make a function which would know how to process one row and that I would then be able to call it so that it processes all rows?
13:58:37 <Saizan> weilawei: e.g. mapM f xs = sequence (map f xs) is pointful, mapM = (sequence .) . map is pointfree
13:58:39 <felzix> In System.Console.CmdArgs, is there any way to control the names of arguments aside from the variable name used?
13:58:43 <Twey> weilawei: Point-free definition is defining functions in terms of operations on other functions, instead of in terms of application of functions to arguments
13:59:13 <weilawei> Thank you BONUS, Saizan, & Twey :)
13:59:17 * copumpkin is trying to figure out how to come up with a safe but fast Fin and rewrite rules in haskell
14:00:09 <Saizan> copumpkin: define fast :)
14:00:17 <dejones> Saizan, thanks, will try that.
14:00:21 <copumpkin> Saizan: using Word behind the scenes
14:00:25 <copumpkin> after rewrites
14:00:35 <weilawei> is the point thing from set theory?
14:00:40 <MissPiggy> copumpkin, well you can certainly compile it to that, but during type checking time?
14:00:55 <copumpkin> MissPiggy: oh, during type checking it'll be the obvious Fin
14:00:59 <copumpkin> the simple one
14:01:06 <felzix> ah, nvm. That's what explicit does.
14:01:10 <Saizan> you could use newtype Fin n = Fin Word, and use views for pattern matching
14:01:11 <MissPiggy> okay
14:01:19 <copumpkin> Saizan: hm, maybe
14:01:22 <MissPiggy> copumkin,, welll! just change Fin n to Nat :)
14:01:27 <MissPiggy> then the problem is making Nat efficient
14:01:34 <MissPiggy> ohh I see what you mean
14:01:42 <MissPiggy> you can use the n to pick something better than Nat (sometimes)
14:01:43 <copumpkin> MissPiggy: yeah, but my main goal is to have statically checked array indices where possible
14:02:05 <Saizan> weilawei: not sure, maybe it's because the standard notations for lambda abstractions use a .
14:02:26 <weilawei> Saizan: They do? I always thought it was a lambda symbol
14:02:55 <Saizan> \lambda <var>. <expression>
14:03:02 <weilawei> Saizan: youll have to excuse me. my haskell is about as good as my math background.. all self-taught and buggier than an old VW beetle
14:03:04 <Warrigal> They use a . instead of a ->
14:04:44 <Saizan> Mitar: i'd probably do something with range and (!)
14:05:06 <Mitar> but what would be the type of that one-row funcion?
14:05:20 <Mitar> so i would like to make it dimension-agnostic ;-)
14:07:16 <Saizan> mh, it could take a list of elements and return a new one, or a pair of indices to work as arguments for range, it'd have to return something like [(i,e)], i think
14:07:25 <weilawei> Warrigal: the pointsfree page on the wiki seems to list a lot of fun examples of people having fun and making Owls but not much use on when I might want to use it or not
14:08:07 <Mitar> yes, but then you have a lot of copying
14:08:12 <Mitar> first to make a list
14:08:21 <Mitar> and then to update original array in the calling function
14:08:48 <Saizan> the lists could get fused
14:10:24 <copumpkin> okay, doing what Saizan suggested
14:10:26 <Mitar> hm, then i am not so sure if i understand what you have in mind
14:10:29 <copumpkin> might be working :)
14:11:15 <Saizan> Mitar: do you know about list fusion?
14:12:15 <weilawei> Saizan: I dont know about list fusion , but i'd be interested in hearing more on it. from what i've seen, it looks like fancy loop unrolling..
14:12:30 <Heffalump> it's more loop fusion than loop unrolling
14:12:52 <ksf> is there any way whatsoever to :t the type of a where-clause function?
14:13:04 <Twey> ksf: Don't believe so.  It's hidden.
14:13:15 <copumpkin> *Main> allFin :: [Fin (S (S (S (S Z))))]
14:13:15 <copumpkin> [Fin 0,Fin 1,Fin 2,Fin 3]
14:13:56 <weilawei> i saw some examle briefly earlier and the example was in some algol-ish language, showing a nested loop getting fused i think?
14:14:03 <MissPiggy> huh
14:14:12 <MissPiggy> why isn't it Fs (Fs (Fs Fz))
14:14:32 <copumpkin> MissPiggy: because I'm representing it with Word behind the scenes
14:14:40 <copumpkin> don't want no unary numbers for array indices!
14:15:23 <Saizan> weilawei, Mitar: it's an optimization implemented via rewrite RULES in ghc, which exploits equalities like map f . map g = map (f . g) to avoid the construction of indetermediate lists
14:15:29 <weilawei> copumpkin: well it's better. you have binary technically.
14:15:35 <copumpkin> yep :)
14:15:43 <copumpkin> type-level unary, value-level binary
14:15:48 <copumpkin> *-level ternary? :o
14:16:02 <weilawei> copumpkin: all a matter of perspective
14:16:06 <Saizan> it works for many other combinators from Data.List, and for what you write from foldr and build in general
14:16:46 <weilawei> copumpkin: in theory, a being structured to perceive differently than us might use the exact same program with different results, potentially even useful. i mean just look at literate haskell programs and universal binaries?
14:16:57 <copumpkin> ?
14:17:33 <weilawei> Saizan: do you know any more about the theory of it?
14:17:46 <ksf> ...the main problem is that if I move the functions out of the where, the whole thing doesn't typecheck anymore.
14:17:48 * sinelaw 's moth is caught in an infinite loop around the lightbulb
14:18:08 <osaunders> sinelaw: Interrupt?
14:18:24 <weilawei> sinelaw: i feel more like a moth. i'd probably be a bad moth pet owner and let the electric zapper get it
14:18:30 <MissPiggy> weilawei did you see the paper?
14:18:31 <sinelaw> osaunders, nah, it's good exercise
14:18:37 <weilawei> but this computer thing ... bright lights and all
14:18:43 <Mitar> but does not optimization know how to mix iarray with lists?
14:18:45 <weilawei> MissPiggy: I have them both open atm, but that's not to say I get them
14:19:04 <Saizan> weilawei: this has more on it http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion , and there are links to papers at the end
14:20:28 <weilawei> Saizan: thank you! this seems to have examples for mere mortals
14:21:38 <dmhouse> When comparing Doubles for equality using abs(x-y) < eps, what's a good value for eps?
14:22:32 <xerox> there is one table here: http://en.wikipedia.org/wiki/Machine_epsilon
14:23:44 <dmhouse> Thanks, xerox.
14:24:42 <xerox> > last . takeWhile ((/=1) . (+1.0) . (/2)) . iterate (/2) $ (1.0 :: Double)
14:24:43 <lambdabot>   4.440892098500626e-16
14:25:58 <xerox> ah there is haskell code too there hehe
14:32:26 <copumpkin> hmm, the vector show instance seems a little broken
14:32:27 <copumpkin> *Main> replicate 5 :: Vec (S (S (S (S (S (S Z)))))) Int
14:32:27 <copumpkin> Vec fromList [5,5,5,5,5,5] :: Data.Vector.Vector
14:34:43 <burp> > 2^^(- (length $ takeWhile (/= 1) $ map (+1) $ iterate (/2) $ (1.0 :: Double)))
14:34:44 <lambdabot>   1.1102230246251565e-16
14:35:09 <burp> I think usually 2.2*10^-16 is taken as machine precision
14:36:01 <burp> hm but for comparison twice the value seems good
14:36:57 * hackagebot upload: multiset-comb 0.1 - Combinatorial operations on multisets (BrentYorgey)
14:37:45 <MissPiggy> brent+++
14:39:21 <copumpkin> woot
14:39:27 <copumpkin> (!) :: Vec n a -> Fin n -> a
14:39:28 <copumpkin> Vec v ! Fin i = V.unsafeIndex v i
14:39:33 <MissPiggy> lol
14:39:42 <copumpkin> the nice thing is that it's safe!
14:39:43 <MissPiggy> haskell is the new C
14:40:03 <copumpkin> :O
14:40:06 <copumpkin> nuh uh
14:40:08 <Twey> How is it safe?  o.@
14:40:21 <Twey> Oh
14:40:25 <Twey> It's got a limit on it?
14:40:28 <Twey> In the n
14:40:35 <copumpkin> yep, Fin n can be no bigger than n - 1
14:40:45 <Twey> Neat
14:40:49 <copumpkin> it's all newtyped
14:40:51 <copumpkin> so there's no overhead
14:40:58 <copumpkin> supposedly
14:41:25 <jmcarthur> sweet
14:41:57 <copumpkin> mmm, backpremute
14:42:09 <ksf> ugs
14:42:15 <copumpkin> how come?
14:42:19 <copumpkin> oh, permute
14:42:26 <ddarius> copumpkin: Translating Agda to Haskell+GADTs?
14:42:28 <ksf> I can't compile c2hs because 6.12.1 doged CLDouble
14:42:50 <copumpkin> ddarius: well, using agda-like stuff for statically verifying index safety on Data.Vector with no overhead, I hope
14:43:57 <ksf> ...luckily, I still have generated .hs lying around.
14:44:28 * ddarius doesn't know what "doged" means.
14:44:28 <Zao> ksf: Chop it out or stub it out to be CDouble.
14:44:32 <copumpkin> backpermute :: Vec m a -> Vec n (Fin m) -> Vec n a
14:44:34 <Zao> ksf: As that's what it used to be anyway.
14:44:41 <Zao> ddarius: 6.12.1 removed CLDouble.
14:44:53 <Zao> As it was just an alias for CDouble anyway.
14:44:54 <ddarius> Zao: I understand the intent.
14:45:11 <ksf> ...to do_d_ge
14:45:13 <Zao> I'm unfamiliar with the verb too.
14:45:29 <Zao> Even with the d, I wouldn't use it to mean "removed".
14:45:48 <ksf> the c2hs ML says it's slated for reinsertion
14:46:01 <ksf> ...so they dodged inclusion for this release
14:46:42 <Zao> ksf: So an eternal pain, as there'll be lots of distros and people on 6.12.1 forever and ever.
14:47:00 * hackagebot upload: vector-binary-instances 0.1.1 - Instances of Data.Binary and Data.Serialize for vector (DonaldStewart)
14:47:15 <dons> copumpkin: solved the Get problem. runs about twice as fast, in 1/4 the space.
14:47:28 <ddarius> dons: What was the key?
14:47:31 <copumpkin> dons: very nice! how'd you do it? did you see the stuff I'm working on just now?
14:47:38 <dons> http://code.haskell.org/~dons/code/vector-binary-instances/Data/Vector/Binary.hs
14:47:45 <dons> "solved"
14:47:52 <copumpkin> aha, the unsafePerformIO thing :)
14:47:56 <dons> lift IO into Get by erasing the IO state
14:47:58 <copumpkin> neat though
14:48:02 <copumpkin> makes sense
14:48:07 <dons> yeah
14:48:12 <ksf> that's going to teach me not to release code prematurely. Had I released it, I would've most likely cleaned the directory of those generated files and would now be unable to use my own bindings
14:48:29 <copumpkin> dons: backpermute :: Vec m a -> Vec n (Fin m) -> Vec n a (using Data.Vector, unsafeBackpermute, and no overhead)
14:48:56 <dons> we need docs for backpermute
14:49:22 <dons> did you see my email to rl about monadic streams for filling?
14:49:29 <copumpkin> yeah, thanks for ccing
14:50:48 <dons> sent rl a patch for enumFromTo, which let's this work, http://stackoverflow.com/questions/2302493/stack-overflow-in-ocaml-and-f-but-not-in-haskell/2303160#2303160
14:51:15 <dons> currently enumFromThenTo goes via lists, and enumFromThen goes via lists for most types other than Int*
14:51:34 <dons> also tried playing with the llvm backend. managed to build the vector lib with it, but can't grok the asm yet
14:51:41 <copumpkin> ah
14:52:04 * copumpkin loves safening all these unsafe functions
14:52:12 <BONUS> the llvm backend inclusion to ghc made me interested in learning more about llvm and then their site dies :\
14:52:21 <BONUS> i did get quite some info through the google cache though
14:54:06 <dons> it is slower than the gcc backend, fwiw :)
14:54:10 <dons> slower to compile
14:56:11 <dons> djahandarie: yeah, just updated for vector (to test   the code was still good)
14:57:37 <copumpkin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7884#a7884
14:57:39 <mux_> dons: I was looking for an efficient way to create a mutable vector from an immutable one with vector-0.5 (thaw, I think?); but couldn't find it
14:57:57 <copumpkin> statically verified vectors!
14:58:35 <BONUS> i wonder if it's just a coincidence that llvm.org went down after the GHC announcement
14:58:51 <copumpkin> hordes of enthusiastic haskell users stormed their servers
14:58:58 <ksf> anyone interested in writing a bezier shader in gpipe?
14:59:08 <Saizan> copumpkin: wooo!
14:59:09 <BONUS> copumpkin: i did just that
14:59:11 <ksf> it _is_ possible to do that without geometry shaders, I've seen a paper.
14:59:26 * jmcarthur would rather use geometry shaders though :(
14:59:30 <dons> mux_: i think the only way is to copy and unfreeze. but unfreeze isn't (?) provided
14:59:32 <copumpkin> Saizan: I love doing all those unsafe things knowing that they're safe!
14:59:41 <copumpkin> who needs runtime checks
14:59:44 <dons> mux_: seems doable though. uvector did it.
14:59:51 <mux_> dons: ok, thanks
14:59:52 <jmcarthur> copumpkin: hear hear!
14:59:55 <ksf> jmcarthur, well, I would rather have a post-glsl gpu, too.
15:00:07 * copumpkin doesn't understand update in Data.Vector though
15:00:09 <jmcarthur> heh
15:01:19 <ksf> oh. and don't forget to subpixel-hint them ;)
15:01:22 <Saizan> static checks ftw
15:01:41 <dmhouse> Does anyone know the complexity of (Data.Array.//) (incremental array updates)?
15:01:54 <copumpkin> dmhouse: O(length array)
15:02:08 <dmhouse> copumpkin: surely it depends on the second parameter
15:02:18 <dmhouse> It's array // list_of_replacements
15:02:31 <copumpkin> probably
15:02:52 <dmhouse> If it's linear in the length of the array my guess would be O(length of array * length of lists)
15:03:48 <BONUS> For most array types, this operation is O(n) where n is the size of the array. However, the Data.Array.Diff.DiffArray type provides this operation with complexity linear in the number of updates.
15:04:00 <BONUS> straight from the horse's mouth
15:04:05 * hackagebot upload: vector-binary-instances 0.1.2 - Instances of Data.Binary and Data.Serialize for vector (DonaldStewart)
15:04:19 <Heffalump> what's the status of the next Haskell Platform release?
15:04:51 <dmhouse> BONUS: okay, I was looking at the Data.Array docs. Thanks
15:05:01 <dons> Heffalump: Mar 20
15:05:08 <BONUS> my quote is from Data.Array.IArray
15:05:10 <dons> unlikely to be any changes, other than to support 6.12
15:05:20 <BONUS> that's quite an awesome change though
15:05:46 <ddarius> (//) should be O(max(length of array, length of lists)) for most array types.
15:10:36 <bos> @seen rl
15:10:36 <lambdabot> Unknown command, try @list
15:10:55 <copumpkin> I wonder if this library will actually be usable
15:10:57 <bos> preflex: seen rl
15:10:57 <preflex>  Sorry, I haven't seen rl
15:11:00 <bos> gah.
15:11:07 <copumpkin> I'll probably need to provide proofs of certain fin properties
15:11:13 <ddarius> copumpkin: Implement some algorithms with it.
15:11:16 <bos> i have a twisty maze of vector type contexts that i can't find my way out of.
15:11:23 <copumpkin> ddarius: any ideas for a demo?
15:11:30 <copumpkin> a simple FFT, maybe
15:11:31 <dons> bos: it will all become clear soon enough
15:11:39 <ddarius> copumpkin: Typical matrix algorithms would be simple enough and representative of a good class.
15:11:45 <BONUS> preflex: seen mmorrow
15:11:45 <preflex>  mmorrow was last seen on #ghc 33 days, 20 hours and 14 minutes ago, saying: * mmorrow is rtfm'ing
15:11:47 <dons> bos, i've found just sticking to D.V.Generic and D.V.Generic.Mutable covers most things
15:11:49 <copumpkin> ddarius: hm, true
15:12:08 * hackagebot upload: ioctl 0.0.1 - Type-safe I/O control package (MaciejPiechotka)
15:12:10 <dons> and we get storable, boxed and unboxed versions of everything for free.
15:12:13 <dons> such a nice package.
15:12:23 <copumpkin> hmm, damn
15:12:29 <copumpkin> I'm not using generic vectors
15:12:38 <copumpkin> I might have to make a different copy of this for each type
15:12:38 <dons> ah, then you limit the things you can do.
15:12:46 <copumpkin> well, it's not an inherent limitation
15:12:49 <MissPiggy> 23:10 < copumpkin> I'll probably need to provide proofs of certain fin properties
15:12:50 <dons> no no. try to use the generic interface
15:12:52 <MissPiggy> such as?
15:13:19 <copumpkin> dons: hmm, I guess I could parametrize my Vec type by length and underlying vector type
15:13:19 <bos> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22194#a22194
15:13:32 <copumpkin> MissPiggy: not sure :) commutativity and so on
15:13:33 <ddarius> Making descriptive types isn't too hard.  Proving (to the compiler) that your usage of such types is correct, is quite a bit harder.
15:13:39 <MissPiggy> commutativity of what?
15:13:48 <copumpkin> MissPiggy: Fin addition
15:13:51 <dons> bos, if you leave the type off, does it check?
15:13:55 <copumpkin> or rather, type addition
15:13:55 <bos> dons: no
15:14:29 <MissPiggy> ah that's quite easy, you can make a homomorphism into Nat  and then  h(x+y)=h(x)+h(y)=h(y)+h(x)=h(y+x)
15:14:42 <MissPiggy> so commutativity of Nat,+ gives commutativity of Fin,+
15:14:49 <copumpkin> yeah
15:14:56 <copumpkin> anyway, I'll make it generic first
15:15:00 <copumpkin> then try to write something with it
15:15:05 <copumpkin> or maybe I'll do it the other way aroudn
15:15:08 <ddarius> The system doesn't know commutativity of Nat addition yet though.
15:15:16 <dons> bos: http://code.haskell.org/~dons/code/vector-random/Data/Vector/Random/Mersenne.hs  fwiw
15:15:20 <MissPiggy> well you can just go
15:15:23 <MissPiggy> proof = proof
15:15:25 <MissPiggy> and that settles it
15:15:27 <dons> though that ST could be PrimMonad m
15:15:33 <dons> s/that IO/s
15:15:57 <PoissonPilote> hi guys, I'd need some help on writing a function- I'm stuck
15:16:03 <PoissonPilote> here's the function:
15:16:03 <copumpkin> MissPiggy: lol, great
15:16:11 <PoissonPilote> concatLists :: [[Int]] -> [Int]
15:16:12 <dons> bos: if you're freezing, why are you returning an MVector?
15:16:31 <dons> bos, isn't that an m (v a) you're returning?
15:16:36 <ddarius> concatLists = concat -- done
15:16:57 <PoissonPilote> here's the function:
15:16:58 <PoissonPilote> http://paste.debian.net/60692/
15:17:08 <PoissonPilote> it has to concatenate lists inside a list
15:17:18 <copumpkin> oh, I haven't written concatMap yet
15:17:20 <MissPiggy> finPlusComm :: Eq (Fin n :+: Fin m) (Fin m :+: Fin n)
15:17:22 <bos> dons: oh my!
15:17:26 <bookhacker> is it possible to use get to retrieve the state from a state monad and return it as a result of a pure function?
15:17:26 <copumpkin> it'll have to be mutiplied
15:17:35 <copumpkin> I guess that's a necessarily evil
15:17:38 <PoissonPilote> for example, [[3,4],[],[31,3]] would return [3,4,31,3]
15:17:39 <MissPiggy> finPlusComm = finPlusComm -- h(x+y)=h(x)+h(y)=h(y)+h(x)=h(y+x) by the obvious hom into N
15:17:43 <MissPiggy> what's wrong with that?
15:17:55 <copumpkin> MissPiggy: :P
15:18:01 <PoissonPilote> so the problem with my function is, exception is raised when tail deals with an empty lsit
15:18:02 <PoissonPilote> list
15:18:07 <PoissonPilote> and I don't see how to get around it
15:18:07 <MissPiggy> if you want it computer checked you can use Coq but it will extract to the same thing
15:18:33 <copumpkin> yeah, but I'm trying to get a nice balance between somewhat trustworthy proofs and no overhead over Vector
15:18:48 <bos> dons: pebkac :-(
15:18:50 <bookhacker> help? :)
15:18:52 <atp> hey, i'm sure i've seen this somewhere before, but does anyone know if it's possible to use type classes or something to build an associative type constructor?
15:18:52 <MissPiggy> I don't really understand
15:18:58 <zeta-> just noticed cuda 0.1 announced: seems this allows calling a cuda function from haskell. But is there something to let me compile to cuda?
15:18:59 <MissPiggy> what's more trustworthy?
15:19:27 <ddarius> s/trustworthy/verifiable.
15:19:27 <bookhacker> anyone?
15:19:29 <dons> :)
15:19:44 <atp> so like e.g. you'd have a data a :+: b and you got the type checker to resolve (a :+: b) :+: c and a :+: (b :+: c) to the same type
15:19:48 <weilawei> PoissonPilote: http://haskell.org/hoogle/?hoogle=[[a]]+->+[a]
15:19:51 <dons> i'm giving a talk about criterion and progression on tuesday @ galois. will illustrate with vector and friends.
15:19:53 <Dark_Shikari> zeta-: doubtful, cuda needs a very specific programming model
15:20:13 <bookhacker> is it possible to use get to retrieve the state from a state monad and return it as a result of a pure function?
15:20:17 <PoissonPilote> weilawei: thanks
15:20:19 <copumpkin> MissPiggy: writing a circular proof doesn't really count as trustworthy :P
15:20:26 <dons> bos: yeah, runState does just that
15:20:33 <dons> bookhacker: ^^
15:20:33 <MissPiggy> why not
15:20:47 <copumpkin> MissPiggy: alright, I'll do that :)
15:20:57 <MissPiggy> but the comment justifies why this equation is true
15:21:01 <MissPiggy> I mean THAT is the proof
15:21:05 <copumpkin> yeah :P
15:21:13 <copumpkin> I mean, we all know natural addition is commutative anyway
15:21:15 <MissPiggy> if you try to encode proofs in haskell, it's just a waste of time and it's not even trustworthy
15:21:25 <copumpkin> fair enough
15:21:45 <zeta-> Dark_Shikari: A while ago I heard rumors about Obsidian, but haven't seen anything.
15:21:49 <ddarius> copumpkin immediately stops coding and picks up Agda again
15:21:54 <MissPiggy> ahaha
15:21:56 <copumpkin> ddarius: lol no
15:21:58 <Heffalump> it's trustworthy if your program doesn't error out
15:22:00 <copumpkin> does anyone know how to write type-level multiplication with type families without undecidable instances?
15:22:00 <MissPiggy> I am helping
15:22:07 <bos> dons: nice!
15:22:17 <ddarius> Heffalump: Only if you force the proofs.
15:22:35 <Heffalump> ddarius: if you don't force them you never used the results
15:23:23 <copumpkin> I guess undecidable instances isn't that bad if I'm sure they are decidable
15:24:12 <bookhacker> so what would be the correct way to get the state of this: http://pastebin.com/m15314ece
15:24:17 <bos> dons: does vector just use an unboxed vector type if you ask for a vector of Int?
15:24:35 <bos> dons: it's hard to follow the chains of type contexts and other cloudiness to see what's really happening
15:24:40 <dons> if you ask for Data.Vector.Unboxed
15:24:57 <copumpkin> okay, time to switch to generic
15:24:59 <dons> Data.Vector gives you a boxed one.
15:25:00 * copumpkin pouts
15:25:11 <bos> dons: ah
15:25:13 <dons> not sure what happens in the generic one -- haven't worked out what the default is.
15:25:21 <bookhacker> lol i feel like i'm being completely ignored -.-
15:25:24 <copumpkin> I don't think there is a default
15:25:45 <copumpkin> is vector-static a good package name?
15:25:56 <weilawei> bookhacker: i think trying to extract state is uh.. something one tries to avoid.
15:26:04 <dons> the design is a bit twisty. i think it is sound, but i'll keep sending in docs and writing examples till i get it.
15:26:25 <bookhacker> weilawei: can a pure function still use the state monad then?
15:26:37 <dons> bos: so library stuff i think should be in Data.Vector.Generic
15:26:42 <weilawei> bookhacker: technically, monads *are* pure.
15:26:47 <dons> while end users should pick Data.Vector.Unboxed unless they have boxed elements
15:26:54 <dons> or D.V.Storable for passing to C.
15:27:04 <copumpkin> Storable is also unboxed, right?
15:27:08 <dons> yup.
15:27:08 <copumpkin> I guess it has to be
15:27:12 <weilawei> in my very very limited understanding, we can use them to do things like represent encapsulating the state of the universe and thus I/O
15:27:23 <MissPiggy> bookhacker dude I have no idea your program is too hard
15:27:25 <weilawei> but you cant suddenly take a function and remove state
15:27:25 <copumpkin> so the only advantage of .Unboxed is that it's friendly to the memory manager?
15:27:33 <dons> it's faster.
15:27:38 <copumpkin> oh
15:27:44 <dons> no pointers into the heap
15:27:51 <dons> and yep, less footprint.
15:27:59 <MissPiggy> bookhacker: I can tell you how to use state it's pretty easy
15:28:11 * bos is all tied up in knots with the types in vector. bleh. time to go to a party.
15:28:36 <MissPiggy> bookhacker, look at this:
15:28:39 <MissPiggy> :t runState
15:28:40 <lambdabot> forall s a. State s a -> s -> (a, s)
15:28:43 <jlouis> copumpkin: you did that vector-mmap package?
15:28:46 <weilawei> bos: does your party have as many people as this channe;?
15:28:49 <copumpkin> jlouis: yeah, is it broken?
15:28:52 <MissPiggy> you can use that to turn a computation in State to a value
15:28:53 <jlouis> because that one seems really neat
15:28:55 <copumpkin> jlouis: I did very little testing :)
15:29:03 <jlouis> me want that for haskell-torrent :P
15:29:30 <dons> bos: tried to capture this here, http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial#Array_Types
15:29:41 <jlouis> all file-IO should be mmap anyway. The only gripe is how to get SHA1 sums on parts of it
15:30:45 <jlouis> unboxed often has better cache behaviour as well
15:31:23 <copumpkin> jlouis: yeah
15:31:26 <weilawei> jlouis: why should all file i/o be mmaped? what if you need some data pre-loaded?
15:31:49 <jlouis> weilawei: elaborate please... what do you mean by pre-loaded?
15:31:58 <weilawei> mmap is demand paging
15:32:11 <weilawei> nothing is read from disk until you actually read it. but you might want that initial read to be fast
15:33:08 <jlouis> weilawei: I don't think it pertains as a problem in haskell-torrent. It might in general though
15:33:25 <weilawei> yeah probably not for a torrent.
15:33:32 <weilawei> in that case, mmap makes a good deal of sense
15:34:32 <jlouis> actually, we lazily check the file for correctness on demand anyway... it is bloody expensive though, so I have planned on caching what we already have of the file
15:34:48 <jlouis> like most clients do
15:34:51 <weilawei> jlouis: on the other hand, mmap works with pages
15:35:21 <urosn> guys
15:35:24 <weilawei> which means random access can do quite a number on mmap()'d i/o
15:35:38 <urosn> did you port haskell to OpenSolaris?
15:36:03 <weilawei> but if you're streaming and will go a maximum length of time (page size) between page faults, then it's faster in many cases
15:36:32 <jlouis> weilawei: well, the reason I would like to outsource that part to mmap() is that the kernel then has the disk-cache
15:36:45 <jlouis> And I don't think I can beat the kernel easily
15:36:49 <weilawei> jlouis: probably not.
15:37:07 <copumpkin> converting to generic isn't too painful
15:37:59 <twink> Part of it is that data movement has to pass through the kernel except when using mmap().
15:39:20 <weilawei> twink: which OS are we talking about? most OSes I know of still have a VM system
15:40:01 <weilawei> are you thinking mmap() + mlock()?
15:40:23 <dmhouse> How, roughly, does the name munging work in GHC core? In other words, if I have a function whose core I want to investigate, how do I find it in the output of -ddump-simpl?
15:40:48 <weilawei> dmhouse: has details on name munging in the FFI: http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html
15:41:19 <dejones> Any suggestions on how I can determine if a FilePath is a file or directory?
15:42:25 <weilawei> dejones: hrm..
15:42:30 <weilawei> "File and directory names are values of type String, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file."
15:42:43 <weilawei> and iirc, directories generally count as files in POSIX
15:42:54 <dons> saying mmap is always right is like saying lazy io is always right :)
15:43:00 <dmhouse> weilawei: not sure my question's got anything to do with the FFI...
15:43:02 <twink> weilawei: All of them? The only way for unprivileged code to use CPU action on retrieved data without a privilege-elevating trap for IO is when the process address space is pre-populated with it a la mmap().
15:43:09 <ddarius> Lazy IO is always wrong.
15:43:59 <dejones> weilawei, I think this package does it -- http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html -- there is a FileType constructor which says RegularFile, Directory, etc.
15:44:28 <weilawei> dejones: check out their source? tbh, im new at haskell. im hanging out here trying to google everything i see and help where I can ^^
15:44:50 <mux_> twink: it is the kernel who populates user pages bound via mmap(); it gets an MMU exception of some sort depending on the architecture, and the VM subsystem fetches data
15:44:52 <monoidal> is there a (:) for ziplists?
15:44:59 <copumpkin> w00t, I have a generic static vector module now
15:45:07 <dejones> weilawei, here it is -- http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html#v%3AfileType -- filetype function returns the type.  :)
15:45:43 <weilawei> twink: physical addressing died a horrrid death a while back. as mux_ mentioned, the MMU handles translation in coordination with the OS's lookup table
15:45:49 <twink> mux_: Probably not a great idea to omit mlock.
15:46:00 <dejones> weilawei, now I just have to figure out how to use filetype function.  Don't really know much about the package...  :)
15:46:02 <weilawei> the mmu in all diagrams ive seen (as a programmer) sits between the CPU and memory
15:46:03 <urosn> did anyone saw my question !?
15:46:18 <mux_> twink: what do you mean?
15:47:02 <arw> urosn: http://www.haskell.org/ghc/download_ghc_66.html <- there is a binary ghc for solaris. that should also work on opensolaris.
15:47:47 <weilawei> twink: mlock() simply asks that the VM system not swap virtual pages to physical swap space, instead keeping them preferentially in real physical memory as far as it knows
15:47:47 <twink> weilawei: Not sure where physical addressing comes in to all this. Prepaging is the way to go.
15:47:57 <weilawei> twink: physical addressing is at the processor level
15:48:04 <xpika> will the latest pull of gtk2hs work with the haskell package?
15:48:04 <weilawei> the MMU and the OS work together to do translations
15:48:09 <copumpkin> I should probably split my fast type-level arithmetic into a separate package, eh
15:48:11 <arw> urosn: you can always take binaries which were compiled for older solaris versions (like 8) and use them on newer ones.
15:48:33 <ClaudiusMaximus> @hoogle +opengl GeometryShader
15:48:33 <lambdabot> Could not find file:
15:48:33 <lambdabot>     opengl
15:48:33 <lambdabot> Searched:
15:48:39 <weilawei> typically physically addressing is handled mostly on-chip
15:49:03 <ClaudiusMaximus> hmm, works with the web interface, but returns no results - do i have to get messy with FFI stuff?
15:49:42 <urosn> arw: I'm interested if you have ported the most recent version of Haskell onto (Open)Solaris. I know for ABI compatibility, by the way.
15:49:51 <mux_> it requires a lot of coordination with the OS; it is the OS (the kernel), which setups all the PTEs in whatever format they need to be for the MMU to decode them, it sets up exception handles for page faults, etc, it has to request TLB shootdowns to clear the MMU cache, etc...
15:50:00 <twink> weilawei: True, but how/why is it relevant?
15:50:03 <mux_> s/handles/handlers/
15:50:17 <mux_> twink: the point was that mmap() involves kernel work, unlike you were saying
15:50:21 <weilawei> twink: because mmap() and mlock() work in concert, *above* these layers
15:50:35 <weilawei> mux_: thank you for clarifying it, much better than I could..
15:50:39 <weilawei> ive been up 26 hours now
15:50:53 <mux_> heh, you're welcome
15:51:13 <mux_> mlock() is a 100% OS matter
15:51:37 <mux_> it's mainly used by crypto stuff who wants to make sure none of the important data ends up in the swap
15:51:49 <arw> urosn: there is also a ghc 6.12.1 for opensolaris on x86, the page says its "community supported". whatever that means.
15:51:59 <twink> mux: I didn't claim the kernel did no work, but anyhow.
15:52:39 <urosn> arw: What about Haskel 2010?
15:52:42 <arw> urosn: but i'm not sure what you mean by "porting". stuff that compiles on solaris also compiles on opensolaris usually, except in some weird special cases.
15:53:25 <twink> mux: Rather, that it never did work.
15:53:25 <urosn> arw: Do you have binaries package for OpenSolaris of Haskell 2010?
15:54:57 <arw> urosn: no, i don't. but i guess if the current version works on solaris, 2010 should, too.
15:54:57 <ddarius> urosn: Haskell 2010 is a standard.  You don't have binaries of a standard.
15:55:32 <arw> well, i guess he wants ghc 6.14 binaries...
15:56:15 <BONUS> 6.14 won't be H98 anymore?
15:57:23 <Heffalump> I think it'll support both. Dunno which will be default.
15:57:41 <arw> BONUS: not sure, the 2010 announcement just says " In GHC we expect to have support in the next major release, i.e. 6.14.1.
15:58:05 <copumpkin> this module is going to be awesome
15:58:10 <benmachine> I think it's suggested that Haskell2010 be a language extension
15:58:21 <BONUS> yeah that seems the most logical
16:00:28 <urosn> ddarius: I know that it is a standard. Just wanted to know if you have binaries for (Open)Solaris of compiler that support 2010 standard?
16:01:05 <weilawei> twink: http://docs.huihoo.com/linux/kernel/a1/index.html#Toc_3_2 you can't get around the kernel so easily..
16:01:31 <weilawei> also, some source from an older mmap.c in linux: http://bit.ly/cbHBiQ
16:01:45 <ddarius> {-# LANGUAGE Haskell98 #-}
16:02:25 <dmwit> ?tell dons testpattern should have a gtk<=0.9 (or maybe gtk<=0.8) constraint
16:02:25 <lambdabot> Consider it noted.
16:02:30 <weilawei> so, i want to rewrite pong in haskell as a basic exercise. and ive had the idea of games where the board holds the intelligence instead of pieces.
16:03:23 * hackagebot upload: altfloat 0.3.1 - Alternative floating point support for GHC. (NickBowler)
16:03:24 <ezyang> My pointfree abilities fail me
16:03:27 <weilawei> for example, a pixel would draw itself if it held the ball and if it received a ball, it would pass it on in the next appropriate direction
16:03:27 <ezyang> :t ((*).).(*)
16:03:29 <lambdabot> forall a. (Num a) => a -> a -> a -> a
16:03:32 <ezyang> :-<
16:03:39 <weilawei> but I can't figure out how to work in the paddles
16:03:59 <Zao> weilawei: That sounds like a quite convoluted representation.
16:04:10 <weilawei> Zao: it's not so much to make pong, per se. It's a programming exercise really
16:04:21 <weilawei> for a real pong game, that would be absurd
16:04:25 <Zao> Especially if you want to add in velocities and non-axis-aligned movement.
16:04:49 <urosn> ddarius: Answer??
16:04:59 <weilawei> Zao: why? i can say I have the ball with a given velocity, if im a wall, i subtract a factor, maybe flip a vector or two
16:05:01 <MissPiggy> @let four f a b c d = f [a,b,c,d]
16:05:02 <lambdabot>  Defined.
16:05:04 <MissPiggy> :t four product
16:05:05 <lambdabot> forall t. (Num t) => t -> t -> t -> t -> t
16:05:07 <ddarius> I have no idea, I don't use Solaris of any stripe.
16:05:24 <MissPiggy> Now That's What I Call Point-Free
16:05:40 <weilawei> Zao: it's less about making accurate pong.. but what if I wanted to have a mouse control a paddle that's 10 pixels tall?
16:05:43 <Zao> weilawei: I thought you wanted to encode everything in the board rasterisation, having no external structure at all.
16:05:45 <dmwit> MissPiggy: Um, f, a, b, c, and d are all points.
16:06:10 <weilawei> Zao: well, I want to code from the point of view of the board cells manipulating themselves
16:06:14 <ezyang> MissPiggy: whoa!
16:06:16 <ezyang> :t four
16:06:17 <lambdabot> forall t t1. ([t] -> t1) -> t -> t -> t -> t -> t1
16:06:21 <dmwit> ?pl four f a b c d = f [a, b, c, d]
16:06:22 <lambdabot> four = (. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.)
16:06:28 <weilawei> i can imagine how I would do this in an async framework with message passing.. but I'm not sure in haskell
16:06:32 <ezyang> my eyes!
16:06:33 <dmwit> Now *that*'s what I call pointfree!
16:07:05 <Alpounet> it is the boob-smiley operator
16:07:08 <dmwit> weilawei: We have asynchronous message passing. Check out MVars, etc.
16:07:44 <dmwit> ?hackage altfloat
16:07:44 <lambdabot> http://hackage.haskell.org/package/altfloat
16:07:50 <weilawei> dmwit: lol thank you :) i have zmq built, but i would like to experiment with this particular idea. im just saying.. i can build pong in all sorts of other ways
16:07:56 <weilawei> but i've never built a functional pong in this manner
16:08:48 <dmwit> "Rational cannot represent all floating point values." Um, what?
16:09:26 <twink> Positive and negative zero, infinities, etc.
16:09:36 <MissPiggy> > let x = replicate in x 4 "(. (" ++ "return)" ++ ([1..3] >>= \n -> (". (:)))" ++ x n " . (.))"))
16:09:37 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:09:37 <lambdabot>         against inferred type...
16:09:39 <dmwit> ah
16:09:45 <dmwit> Yes, IEEE is a weird weird spec.
16:09:48 <dmwit> I keep forgetting how weird.
16:09:49 <djahandarie> twink, isn't that it actually?
16:09:55 <xpika> which linux os has the best haskell support in general
16:10:12 <weilawei> xpika: which one do you like working on?
16:10:17 <dmwit> Many people like Arch's Haskell support.
16:10:18 <dolio> The usual rational implementations could do positive and negative infinities.
16:10:30 <dolio> Not negative zero easily.
16:10:33 <dmwit> But I've found that cabal-install is basically better than any distro's package manager for Haskell stuff.
16:10:47 <dmwit> dolio: Oh?
16:10:49 <djahandarie> I remember using -0 in Haskell at one point
16:10:50 <dmwit> > 1 % 0
16:10:51 <lambdabot>   * Exception: Ratio.%: zero denominator
16:11:01 <twink> djahandarie: I forget if there's anything else. Maybe someone who knows the spec well enough to rule out other possibilities can say.
16:11:03 <dolio> Actualy, maybe you could represent negative zero as 0 :% (-1).
16:11:12 <weilawei> dmwit: agreed, although i've had to use a combination of hand-compilation, macports, cabal, and the downloadable platform on Snow Leopard to make GHC happy
16:11:13 <dejones> I <3 Real World Haskell, recursively listing a directory's contents, chapter 9!  :)
16:11:20 <Heffalump> and neginf as (-1) :% 0 ?
16:11:26 <dolio> Yes.
16:11:29 <dmwit> > 0 % (-1) -- IS 0 % 1
16:11:30 <lambdabot>   0 % 1
16:11:37 <Heffalump> but you certainly couldn't represent the full set of NaNs
16:11:46 <Heffalump> all you could do is 0 :% 0
16:12:01 <mauke> how do you distinguish two NaNs?
16:12:01 <dejones> weilawei, the solution I was looking for to differentiate between directories and files is in Real World Haskell.
16:12:04 <twink> What NaN's are there?
16:12:04 <dejones> just fyi
16:12:09 <dolio> I've never bothered finding out what all the different NaNs are.
16:12:19 <Heffalump> mauke: cast to some other type :-)
16:12:38 <Heffalump> I can't remember what there are, but lots. Signalling and non-signalling variants for example.
16:12:54 <mauke> a signalling NaN is an exception, not a value
16:12:57 <weilawei> dejones: glad you found it. which chapter? ive begun reading RWH several times and always stopped reading at one point or another (due to other projects, life, lack of motivation, etc)
16:12:57 <MissPiggy> why isn't there  cabal uninstall  ?
16:13:06 <dejones> weilawei, chapter 9.
16:13:09 <Heffalump> because disk space is cheap :-)
16:13:16 <dmwit> MissPiggy: lack of demand
16:13:19 <Heffalump> (i.e. it's low priority for most people)
16:13:20 <dons> MissPiggy: it's an immutable world
16:13:21 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
16:13:25 <dmwit> MissPiggy: If you want it, I'm sure patches for it would not be rejected. =)
16:13:25 <dejones> weilawei, at the beginning of ch 9, that is.
16:13:26 <weilawei> MissPiggy: and it's quite happy to install to ~/ directories or prefixes.
16:13:26 <Heffalump> ghc-pkg unregister is good enough for most cases
16:13:29 <MissPiggy> haha
16:13:37 <MissPiggy> I have no clue what I am doing I couldn't add it
16:13:48 <weilawei> MissPiggy: in which case you can nuke the directory quite safely :) ~/.cabal
16:14:08 <dmwit> weilawei: Nuking isn't enough, you have to unregister, too.
16:14:51 <weilawei> dmwit: I have all that tied into macports and it's all hidden under /opt/local
16:14:56 * copumpkin is getting excited
16:15:12 <dmwit> uh-oh, copumpkin is excitable again
16:15:16 <copumpkin> lol
16:15:16 * djahandarie throws cold water over copumpkin
16:15:28 <dmwit> Start pumping the meds! go go go!
16:15:32 * weilawei throws a wool blanket on copumpkin 
16:15:50 <weilawei> now he's got a wet blanket, but this one will keep him warm
16:16:10 <jlouis> when he falls back to a non-excitable state he sends out energy!
16:16:20 <twink> 2^(N+7) -bit software floating point could be handy
16:16:32 <aavogt> dmwit: you can nuke ~/.ghc if you want to unregister all user packages
16:16:43 <dmwit> aavogt: sure
16:16:56 <weilawei> jlouis: so when he returns to high energy, he emits energy?
16:16:58 <copumpkin> in particular, I like grow :: (PrimMonad m, MVector v a, Nat n) => MVec n v (PrimState m) a -> MVec (n :+: k) m (v (PrimState m) a)
16:17:04 <byorgey> you can wave a large magnet over your hard drive if you want to unregister all user packages.
16:17:15 <copumpkin> is that awesome or what?
16:17:20 * copumpkin shuts up
16:17:52 <ezyang> copumpkin: Where'd the k come from?
16:18:03 <weilawei> byorgey: I prefer to get objects randomly stuck to my laptops screen from the magnets embedded within
16:18:08 <byorgey> ezyang: implicitly forall'd?
16:18:09 <copumpkin> ezyang: it's a type-level natural showing how much bigger it should be
16:18:37 <copumpkin> whoops, had a typo in that type
16:18:39 <copumpkin> but you get the idea
16:18:43 <ezyang> aha.
16:19:20 <ezyang> that type makes my head hurt. You should write a blog post about it.
16:19:40 <copumpkin> lol, no blog!
16:19:42 <ezyang> in particular, I don't know what PrimMonad, MVector, MVec and PrimState do...
16:19:48 <aavogt> type function tutorials
16:19:50 * ezyang goes searching 
16:20:19 <MissPiggy> agh!!!! I hate how long she takes!
16:20:21 <copumpkin> ezyang: I'm trying to make fast (optionally mutable) statically checked vectors
16:20:22 <weilawei> ezyang: that's why i hang out here. it makes me feel really dumb compared to having to deal with webdev all day.
16:20:29 <MissPiggy> and eats all my memory
16:20:39 <weilawei> (since i hate webdev with a passion but it pays bills)
16:20:39 <ezyang> copumpkin: Ooooh
16:20:41 <copumpkin> ezyang: so you can guarantee that array indices and lengths are safe at compile time
16:20:47 <copumpkin> and turn off all runtime checks
16:20:52 <copumpkin> or as many as I can figure out
16:20:54 <dolio> > let (n1, d1) + (n2, d2) = (n1 * d2 + n2 * d1, d1 * d2) ; nan = (0, 0) in nan + (3, 5)
16:20:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t, (t1, t2))
16:21:12 <dolio> > let (n1, d1) + (n2, d2) = (n1 * d2 P.+ n2 * d1, d1 * d2) ; nan = (0, 0) in nan + (3, 5)
16:21:13 <lambdabot>   (0,0)
16:21:21 <ezyang> weilawei: Clearly you should figure out how to use Haskell in your webdev
16:21:52 <ezyang> man, that type is getting me excited now too!
16:21:55 <copumpkin> if type functions could be injective, this would be even more awesome
16:22:02 <copumpkin> but as it stands, you need to tell it what the k is too
16:22:56 <weilawei> ezyang: im nowhere near good enough. im already quite happy with python/ruby (same thing) and javascript for those
16:23:03 <Alpounet> that's one of the things C++ templates have better than Haskell's parametrized types
16:23:26 <burp> ew, beware of saying something positive about c++ templates :>
16:23:37 * ezyang wants to be working on stuff in Haskell, but is instead futzing around with probability distributions 
16:23:43 <burp> don't forget where you are ;)
16:23:48 <copumpkin> ezyang: do probability distributions in haskell!
16:24:01 <benmachine> I tried to make a GADT list with its length encoded in the type, but I found it pretty hard to actually define any functions on it
16:24:12 <MissPiggy> benmachine, maybe I can help if you want
16:24:16 <ezyang> copumpkin: I could... :-)
16:24:25 <benmachine> MissPiggy: maybe, but I'm half asleep now
16:24:32 <benmachine> and I will forget tomorrow :P
16:25:02 <MissPiggy> fucking hell why does She suck so much
16:25:17 <MissPiggy> it's just a glorified sed there is no reason it should take 1000MB of RAM
16:25:29 <copumpkin> lol
16:25:33 <weilawei> MissPiggy: space/time tradeoff?
16:25:41 <ezyang> she?
16:25:43 <MissPiggy>  2271 she         23.7%  0:46.32   1    13   1381  742M-  168K   742M- 1437M
16:25:57 <MissPiggy> and all it does is replace {...} with *
16:26:22 <MissPiggy> (unless it secretly does something weird like read my emails)
16:26:29 <byorgey> she = Strathclyde Haskell Extension?
16:26:36 <Alpounet> burp, hey, that was half positive :-p
16:26:39 <MissPiggy> yes
16:26:45 <copumpkin> MissPiggy: it does quite a bit more than that
16:26:48 <copumpkin> but it depends how you use it
16:26:50 <byorgey> if so I don't understand your comment about replacing { .. } with *
16:26:58 <weilawei> MissPiggy: is that 742 the vsize?
16:27:05 <copumpkin> it'll generate typeclasses for "pi types", for example
16:27:24 <weilawei> because if you look at the vsize of a *lot* of programs, they're huge but use a much smaller set of memory most of the time
16:27:51 <MissPiggy> it swamps my whole computer like a fork bomb
16:28:00 <MissPiggy> and it takes 20 mins to actualy run
16:28:10 <MissPiggy> if it wasn't for those two things I wouldn't be looking in to
16:28:12 <MissPiggy> top
16:28:19 <byorgey> that does seem rather excessive.  what are you trying to do with it?
16:28:38 <MissPiggy> well I am just running make in Pig09
16:28:44 <weilawei> MissPiggy: is the 742 the vsize line in top?
16:28:48 <copumpkin> how about this ridiculous type:
16:28:49 <copumpkin> slice :: MVector v a => Fin n -> k -> MVec (n :+: k) v s a -> MVec k v s a
16:28:50 <MissPiggy> weilawei I don't know :[
16:28:57 <weilawei> MissPiggy: read the header at the top
16:29:06 <MissPiggy> 1437M is VSIZE
16:29:10 <ezyang> ooooh
16:29:21 <ezyang> it's like n+k, but not :-)
16:29:28 <weilawei> okay see thats just the amount it *can* allocate. it's reserved for allocation/addressing.
16:29:34 <copumpkin> I think the safety is fully encoded in that type
16:29:40 <MissPiggy> oh great!
16:29:40 <MissPiggy> DisplayLang/Elaborator.lhs:94:28: Not in scope: `switchDOp'
16:29:42 <MissPiggy> after all that!
16:29:44 <MissPiggy> oh well
16:30:01 <weilawei> MissPiggy:
16:30:06 <weilawei> "My code is compiling"
16:31:04 <aavogt> is she really robust enough to be used for serious code?
16:31:21 <benmachine> are you?
16:31:33 <MissPiggy> aavogt, forget 'robust' it takes 20 mins to run and swamps your computer like a forkbomb
16:31:40 <MissPiggy> needs more foldl'
16:31:49 <copumpkin> mmm
16:31:54 * copumpkin shuts up 
16:32:04 <twink> MissPiggy: Is it some interpreter?
16:32:12 <weilawei> MissPiggy: you might want to checkout man top(1) for the details on what each field means
16:32:19 <MissPiggy> weilawei thanks :P
16:32:31 <MissPiggy> twink it's like CPP except takes longer
16:32:33 <aavogt> @where she
16:32:33 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
16:32:43 <weilawei> also, i saw something concerning today, dont know if it's true.. but i heard that GHC's allocator never releases memory back to the OS?
16:32:51 <weilawei> it just assumes it will re-use it?
16:35:09 <Saizan_> it does use quite a bit of ram over Epigram's sources
16:35:55 <Draconx|Laptop> dolio, there's another problem with representing infinity as, say, (1 % 0): what happens do you perform arithmetic with this?
16:36:19 <jmcarthur> weilawei: i think you are correct. ghc never released memory back to the OS afaik
16:36:24 <jmcarthur> *releases
16:36:36 <dolio> Draconx|Laptop: You probably have to add some extra checks.
16:36:53 <dolio> Although some stuff works out automatically.
16:37:27 <dolio> Both infinity + r and infinity * r end up as (n :% 0) for some n, for instance.
16:38:04 <copumpkin> http://github.com/pumpkin/vector-static if anyone wants to check it out while I'm working on it
16:38:26 <copumpkin> all the actual code is in http://github.com/pumpkin/vector-static/tree/master/Data/Vector/Generic/ right now
16:38:29 <weilawei> does anyone remember the quote? it's something like x mb and swapping constantly
16:38:48 <aavogt> EMACS?
16:38:51 <weilawei> i believe it was in reference to windows
16:39:00 <weilawei> or DOS
16:39:02 <jmcarthur> copumpkin: finish it so i can use it
16:39:06 <dmwit> eight megabytes and constantly swapping...
16:39:06 <jmcarthur> do it now
16:39:09 <copumpkin> jmcarthur: lol
16:39:19 <copumpkin> jmcarthur: just need to write more functions and test it some
16:39:20 <jmcarthur> i like safety
16:39:22 <ddarius> weilawei: DOS would never get up to 8MB and didn't have swap.
16:39:26 <jmcarthur> and speed
16:39:31 <copumpkin> jmcarthur: also, the nat representation is slow right now, but I'll fix that soon
16:39:36 <copumpkin> Fin is fine though
16:39:39 <weilawei> ddarius: good point. it was 64k then xD
16:39:42 <jmcarthur> slow for the compiler?
16:39:51 <copumpkin> nah, it's still unary :P
16:40:00 <copumpkin> the compiler could figure it out at compile time but it probably won't
16:40:11 <dolio> > lcm 5 0
16:40:12 <lambdabot>   0
16:40:20 <jmcarthur> oh are you using term level nats for indexing?
16:40:24 * jmcarthur hasn't looked at it yet
16:40:35 <copumpkin> jmcarthur: no, I'm using ints for indexing
16:40:39 <jmcarthur> oh okay
16:40:40 <copumpkin> but there are occasional places where nats come into play
16:40:44 <jmcarthur> term level?
16:40:47 <copumpkin> yeah
16:40:49 <jmcarthur> ah
16:40:57 <copumpkin> things like replicate
16:40:57 <copumpkin> or new
16:41:07 <copumpkin> where your type-level length gets made into a value-level int
16:41:13 <jmcarthur> hey are you going to add generic indexing while you're at it? :P
16:41:23 <copumpkin> jmcarthur: nope! it's gotta be safe
16:41:25 <weilawei> ddarius: i went from a commodore 64 to a tandy 1000e. that was  a *whoa* moment in my life.. going up by a whole order of magnitude in memory size. that and an IBM ps/2 and a 486 dx and then more clones
16:41:27 <copumpkin> Fin n is the only option! :P
16:41:37 <jmcarthur> not the *only* option
16:41:46 <copumpkin> what would you propose?
16:42:20 <jmcarthur> type parameterized Ix?
16:42:33 <copumpkin> the Ix class doesn't seem flexible enough?
16:42:36 <jmcarthur> right
16:42:38 <jmcarthur> make a new one :P
16:42:47 <jlouis> weilawei: Eight Megabytes And Constantly Swapping
16:42:56 <copumpkin> lol
16:42:56 <copumpkin> ok
16:43:09 <jmcarthur> copumpkin: i'm kind of joking though. that would be kind of troublesome for you *and* for users of the library
16:43:14 <copumpkin> :)
16:43:21 <copumpkin> for all I know, it already is a huge pain to use
16:43:29 <copumpkin> I'll have to try writing something real with it before releasing it
16:43:46 <jmcarthur> i've use type safe lists. they were kind of troublesome, but only because they showed me how badly i tended to use lists
16:44:35 <jmcarthur> also, this kind of thing can be annoying without dependent types since you end up having to write code for what to do when you can't construct a Fin out of an argument, for example, even when it's technically safe anyway
16:44:51 <copumpkin> I'm going to make an Int -> Maybe (Fin n)
16:44:57 <jmcarthur> right
16:45:00 <jmcarthur> which can be annoying
16:45:02 <copumpkin> yeah
16:45:03 <weilawei> jlouis & ddarius aha, thank you :)
16:45:06 <jmcarthur> with dependent types it's unnecessary
16:45:16 <copumpkin> only if you have a proof :P
16:45:28 <weilawei> i forgot it was emacs, not windows or dos or some other evil thing ;) cause I use... well, I won't even say that three-letter word in here.
16:45:37 <jmcarthur> sometimes the proof is more convenient than the Nothing case
16:45:44 <jmcarthur> literals, for example
16:46:13 <copumpkin> yeah
16:46:22 <copumpkin> I wish there were a good solution for literals
16:46:30 <copumpkin> maybe I'll make a quick QQ for them
16:46:40 <copumpkin> still doesn't help with error messages though
16:46:46 <jmcarthur> somebody's working on type level numerals i think, but i don't know if there will be anyway to lift terms to types directly
16:46:46 <MissPiggy> so I need help programming haskell
16:47:06 <weilawei> MissPiggy: you're in good company
16:47:12 <MissPiggy> :D
16:47:12 <weilawei> or at least company.
16:48:02 <MissPiggy> basically my problem is that I start out, and it goes okay for a little bit.. but then I start to worry that my design is not good.. and I can't go futhur because I don't feel like I have the optimal structure
16:48:31 <MissPiggy> so I have now 3 attempts starting on this program and it's just going to become more and more
16:49:26 <aavogt> design isn't easy. That's why we have design patterns!
16:49:27 <twink> What's the program do?
16:49:36 * ezyang conks aavogt 
16:49:42 <MissPiggy> well it's supposed to be a few different numerical algorithms
16:49:53 <weilawei> MissPiggy: if you're 3 attempts in, you're doing it right. fail faster, learn more :-D
16:50:07 <MissPiggy> so I have made up some typeclasses, and implement them on a few different types
16:50:40 <weilawei> MissPiggy: what do the numerical algorithms do ultimately? Who uses them? What do they do?
16:50:53 <MissPiggy> it's just for my use, I'm making a really powerful calculator :P
16:51:15 <MissPiggy> it's all exact stuff though
16:51:17 <weilawei> why don't you like your design?
16:51:34 <MissPiggy> it's not that I dont like it, its just that i am constantly compelled to start form scratch
16:51:54 <weilawei> is it actually hindering you or do you worry it will? perfection is the enemy of good enough and knuth said premature optimization is the root of all evil
16:52:03 <MissPiggy> so instead starting at the beginning and working toward the end, I I take one step, one back, two steps two back, 3 steps... 3 back...
16:52:08 <weilawei> MissPiggy: i feel much the same way on my own projects, but it's a tendency I have to fight
16:52:20 <weilawei> I also tend to work from the end I want to interface with my code from
16:52:36 <MissPiggy> oh yeah I have wasted weeks trying to get a user interface :(
16:52:36 <weilawei> be that writing code to use an API i'm writing or making an interface
16:52:48 <MissPiggy> I'm kind of upset about that, It should be trivial
16:52:58 <weilawei> anything to put a stop to feature creep and roulette
16:53:07 <MissPiggy> what do feature creep and roulette mean?
16:53:51 <weilawei> feature creep is where you keep adding stuff, whether it's truly important or not.. and the roulette thing was my own reference to the desire to add something, then decide you hate it, and get into this crazy livelock where you go back and forth but never do anything
16:54:01 <MissPiggy> ahh
16:54:18 <twink> I think feature creep doesn't need importance filtering.
16:54:20 <Saizan_> copumpkin: i wonder how/when things like natToInt (witnessNat :: n) are going to be calculated in practice
16:54:27 <copumpkin> not sure :)
16:54:28 <MissPiggy> I think if I had someone to collab. with it would probably work better, but I don't know anyone that programs (let alone writes haskell)
16:54:36 <copumpkin> Saizan_: I guess I could ask ghc-core
16:54:48 <copumpkin> but I want to finish the module first
16:54:51 <weilawei> MissPiggy: i dont know about anyone else here, but I am noticeably more focused when I'm pair-programming. i find it very enjoyable
16:55:05 * Saizan_ fixes his ghc installation so he can try
16:56:34 <jmcarthur> MissPiggy: personally i don't mind my own personal tendency to rewrite code, but perhaps that is because i put a lot of focus on the enjoyment of the task and perhaps not so much on the end goal
16:56:35 <weilawei> MissPiggy: I'm fortunate enough to have friends that program, although very few with whom i'm a peer doing productive work instead of trying to teach basics
16:57:46 <weilawei> but it was not always so, and I programmed alone for a good 11 years
16:58:03 <jmcarthur> this slight shift of priorities might also explain my extreme difficulty concentrating on certain tasks at work that i'm not extremely interested in
16:58:16 <MissPiggy> :(
16:58:38 <weilawei> jmcarthur: it's grand, isn't it? i've been told i should leave the hard problems for later so I don't do all the fun bits first
16:58:43 <Entroacceptor> weilawei: every single one of my friends absolutely hate pair-programming
16:58:55 <jmcarthur> weilawei: actually the fun bits are the hard bits, to me
16:59:01 <weilawei> they are to me too
16:59:08 <weilawei> but when I'm done, I have nothing else I'd like to do
16:59:24 <weilawei> Entroacceptor: you really need two people who program roughly on the same level and would be friends/co-workers anyway
17:00:03 <Saizan_> MissPiggy: maybe make a public repo and/or force yourself to stick to your current design? once you can actually use it you can better judge what's best
17:00:24 <weilawei> I actually met a guy at a prior startup (i interviewed him and said YES. him! hire him!) who later became my friend and main pair-programming buddy
17:00:47 <ddarius> Entroacceptor: Perhaps they just hate pair-programming with you...
17:00:59 <damd> i hate pair programming in general
17:01:18 <weilawei> damd: what do you dislike about it?
17:01:26 <weilawei> (just curious, it's not for everyone)
17:01:34 <ezyang> I've seen people do pair programming (one instance was writing up exploit code for a kernel vulnerability), and it's pretty... *cool*.
17:01:41 <damd> weilawei: someone looking over my shoulder all the time.  the need to look over someone's shoulder all the time.
17:01:58 <weilawei> damd: ah, see we have a bit of a different setup
17:02:21 <damd> i also like taking breaks whenever i want to ;|
17:02:41 <Entroacceptor> ddarius: :-P
17:02:42 <weilawei> it's an iMac with an extra monitor and a macbook. the macbook has a keyboard+trackpad obviously, and the imac has a keyboard+a wired *and* a wireless mouse. all of this is hooked together with synergy
17:03:21 <weilawei> so we have 3 screens and a full set of input devices for each of us. generally, one person types code, the other directs the flow by asking "what's the next thing" and it's all very conversational, but question and answer
17:03:26 <weilawei> and when we get tired, we switch who types
17:03:26 <copumpkin> Saizan_, jmcarthur: I updated the code to have a concrete instance for boxed Vector if you want to try it
17:03:38 <weilawei> plus, one can be looking up important info on the side
17:03:45 <jmcarthur> i haven't a good chance to try vector yet
17:03:56 <jmcarthur> i would give it a shot on this tron ai if i trusted ghc 6.8 with it
17:04:48 <jmcarthur> well, and if i could actually think of a legitimate need for arrays in it
17:04:49 <damd> weilawei: i'm sure pair programming works for some people, i'm just reluctant to giving up that feeling of deciding for yourself when you need a coffee break, etc.
17:04:56 <copumpkin> jmcarthur: ah, yeah :/ and the type family stuff I'm doing for the arithmetic probably wouldn't work anyway
17:05:02 <copumpkin> but I guess you could use the "unsafe" vectors
17:05:05 <weilawei> damd: it's not an enforced thing.. it's something we do because we like it.
17:05:19 <weilawei> it's certainly not standard practice and I don't pair-program with many other people
17:05:33 <weilawei> either one of us can announce a break
17:05:42 <damd> weilawei: well, some project managers like to think of "agile" and pair programming as a silver bullet...
17:05:56 <damd> had too much of that shit
17:06:02 <weilawei> damd: ah, no we're not like that. my friend and I just find that we're much more efficient working together
17:06:17 <weilawei> we think very similarly, but have different backgrounds
17:06:19 <MissPiggy> suppose I have Algebra/Group,Ring,Field.hs and Model/Natural,Integer,Gaussian,Quotient.hs
17:06:35 <MissPiggy> then where should I put algorithms like division, gcd, factoring?
17:07:37 <alex404> MissPiggy: Doesn't Algebra seem like themore natural fit? They're operations, as opposed to definitions.
17:07:39 <weilawei> damd: my chief gripe with management has always been the ineffable need for constant status updates and re-organization.
17:08:19 <ezyang> "you don't second guess ineffability, I always say"
17:08:36 <copumpkin> oh I'll need to force everything to inline, too
17:08:44 <weilawei> having to physically move my desk and contents all over, interrupt what im doing and execute a *huge* mental context switch every time they need a status when I've told them I will walk over to them the instant I have a new status to report
17:09:34 <weilawei> frankly, i get more work done at home on my couch or in cafes than at work.
17:09:51 <ezyang> weilawei: Have you read "The Maker's Schedule", by Paul Graham?
17:10:01 <damd> weilawei: i dislike company hierarchies, "coding guidelines", anything proprietary, "new hot" development processes, etc. so i don't get along with management very well...  luckily for me, management got fired recently.
17:10:03 <sinelaw> Contentment with our lot . . . will diffuse ineffable
17:10:03 <sinelaw>            contentment over the soul
17:10:04 <MissPiggy> but I don't define them on every group
17:10:05 <weilawei> ezyang: I don't believe I have, but I might have seen it. has has a *lot* of essays
17:10:08 <MissPiggy> it only works on concrete things
17:10:27 <weilawei> damd: im going the route of having my own startup hopefully in the next fiscal year
17:10:40 <shapr> damd: I've had awesome and terrible experiences doing Agile programming, depends on the other programmers.
17:11:09 <weilawei> damd: despite all the insanity associated, i have friends and family who will help me negotiate the business issues until I hire someone.. and for me, it solves the problem of trying to have two masters
17:12:00 <shapr> Pair programming is a very different kind of flow... 'group flow' can be totally awesome and amazing, and far more productive that my best flow sometimes.
17:12:57 <weilawei> shapr: the best part is when you get really in-sync with someone and they state your answer when you're trying to figure out how to question what's next. done right, the other person and you might as well be one superbrain
17:13:16 <weilawei> but i think it's very very much personality dependent
17:13:17 <Saizan_> copumpkin: ok, natToInt (witnessToNat :: n) is a mess, though fortunately that doesn't get used much, right?:)
17:13:33 <shapr> Yeah, totally. Going in and out of sync works well for me. Sometimes I'm working on the trees, sometimes the forest.
17:13:51 <copumpkin> Saizan_: eventually natToInt will be a noop, but witnessNat might not be
17:13:58 <copumpkin> Saizan_: but yeah, it doesn't get used very often
17:14:25 <weilawei> shapr: ive been reading (listening to, really) Outliers by Malcolm Gladwell and he mentions the Power Distribution Index, which IIRC, is a measure of how expectant people are and want to tolerate and even actively desire a hierarchical power structure.
17:14:54 <weilawei> and in low-PDI countries, which treat people like peers, pair activities are better self-regulating
17:14:54 <shapr> Never heard of it, I'll look it up.
17:14:54 <medfly> @hoogle (<<)
17:14:54 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
17:14:54 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
17:14:54 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
17:15:06 <Saizan_> copumpkin: ah, because you're going to make a newtype Nat n = Nat Int type?
17:15:08 <medfly> ur... is there a bitwise thing?
17:15:12 <copumpkin> Saizan_: yeah
17:15:18 <shapr> medfly: Data.Bits ?
17:15:20 <medfly> thanks
17:15:32 <weilawei> shapr: excuse me, PDI is power DISTANCE index
17:15:39 <copumpkin> Saizan_: or something like that, anyway
17:15:57 <aavogt> @hoogle shiftL
17:15:58 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
17:16:34 <Saizan_> copumpkin: one could just write a natToInt :: Nat n => Int
17:16:47 <copumpkin> Saizan_: is that even valid?
17:16:58 <shapr> weilawei: nifty stuff - http://en.wikipedia.org/wiki/Geert_Hofstede
17:17:02 <copumpkin> I guess I can drop all the fancy Nat machinery
17:17:03 <Saizan_> copumpkin: oh, whoops, no.
17:17:04 <copumpkin> or most of it
17:17:15 <copumpkin> but I do need to keep some of it, as Fin is indexed by it too
17:17:46 <weilawei> shapr: yep, PDI is part of his cultural dimensions
17:18:38 <weilawei> shapr: also, malcolm gladwell has a very soothing voice, which I discovered in watching his TED talk. so he makes great listening when normally I can't *stand* audiobooks. his delivery is superb.
17:18:56 <ksf> priority search queue with efficient unused leaf deletion, anyone?
17:19:14 <Walt> Just started learning haskell, and just understood this: fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
17:19:16 <Walt> pretty awesome
17:19:28 <copumpkin> Walt: just you wait :)
17:19:38 <copumpkin> > fix (0 : scanl (+) 1)
17:19:38 <lambdabot>   Couldn't match expected type `[t]'
17:19:39 <lambdabot>         against inferred type `[a] -> [a]'
17:19:51 <copumpkin> > fix ((0:) . scanl (+) 1)
17:19:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:19:54 <ksf> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
17:19:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:19:55 <ezyang> welcome to lazy land :-)
17:19:57 <ksf> that's shorter.
17:20:05 <ksf> ...and pointless.
17:20:48 <weilawei> copumpkin: now if only the learning for learning haskell didn't look like a cliff or make english seem like a cakewalk. it's a *gorgeous* language, but even as a (maybe especially as?) long-time programmer, I have trouble large chunks of it
17:20:55 <weilawei> *the learning curve
17:21:08 <ksf> there's no learning courve
17:21:12 <ksf> it's a linear incline
17:21:16 <ksf> ...and it never plateaus.
17:21:28 <Entroacceptor> ksf: it's not
17:21:42 <jmcarthur> the problem with learning haskell is not haskell, it's the newfound power of abstraction... it's daunting, and many libraries make use of it
17:21:44 <ksf> it is, if you don't have prior programming knowledge.
17:22:05 <weilawei> jmcarthur: im still struggling with the huge amount of syntactic sugar.
17:22:11 <copumpkin> weilawei: :)
17:22:18 <jmcarthur> weilawei: i don't really use syntax sugar that much
17:22:38 <ksf> but then, I know it sometimes feels like this: http://awhisperinmyghost.com/pics/EvE/LearningCurve.jpg
17:22:39 <jmcarthur> i use it for lists, and i use do notation for IO but not most other monads
17:22:40 <weilawei> jmcarthur: unfortunately, a lot of other people adore it.. and I learn primarily by reading code
17:22:45 <aavogt> is there really that much sugar?
17:22:54 <weilawei> aavogt: there's *tons*
17:22:55 <jmcarthur> there really isn't that much
17:23:07 <jmcarthur> do notation, lists, list comprehensions... i can't think of any others
17:23:17 <jmcarthur> well, and i guess numeric literals
17:23:19 <aavogt> do we count ghc extensions?
17:23:34 <jmcarthur> string literals with the overloaded strings extension
17:23:36 <ksf> records
17:23:48 <jmcarthur> ah and records
17:23:53 <weilawei> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html theres a bunch of optional sugar
17:23:56 <ksf> tuples, too.
17:24:07 <jmcarthur> ksf: that's not sugar, is it?
17:24:22 <jmcarthur> it's not consistent with normal ADT syntax though
17:24:24 <weilawei> most of the language is syntactic sugar, even (==), right
17:24:29 <ksf> it's sugar for Tup1 a b= Tup1 a b
17:24:33 <jmcarthur> == is not syntax sugar
17:24:50 <jmcarthur> it's normal syntax. an operator
17:25:01 <ksf> the nice part is that case, function and do-notation patterns are all the same
17:25:02 <ezyang> IMO, Haskell just gives you enough rope to make stuff that looks like syntax sugar
17:25:03 <jmcarthur> ksf: is Tup1 exposed?
17:25:09 <aavogt> yeah, there isn't some kind of   __infix== functoin it gets translated too
17:25:37 <weilawei> jmcarthur: im pretty sure it's not a normal operator. http://www.haskell.org/onlinereport/lexemes.html
17:25:42 <ksf> jmcarthur, it's not even defined
17:25:48 <ksf> but product types aren't black magic
17:25:50 <weilawei> ksf: exactly.
17:26:00 <jmcarthur> ksf: it's not syntax sugar then, is it?
17:26:12 <weilawei> jmcarthur: it's syntactic sugar if it isn't defined in the core lexemes and grammar
17:26:25 <ezyang> uh
17:26:30 <ksf> it's syntax sugar because it can't be semantic sugar because we have other possibilities to do products
17:26:35 <jmcarthur> weilawei: " although = is reserved, == and ~= are not"
17:26:40 <jmcarthur> == is not syntax sugar
17:26:48 <weilawei> " == and ~= are not""
17:26:53 <weilawei> how is that saying its not sugar?
17:26:58 <weilawei> it clearly says it isn't reserved
17:27:00 <ezyang> by that definition, do-blocks are not syntax sugar
17:27:04 <ezyang> since they're reserved and stuff
17:27:08 <jmcarthur> ksf: it's syntax, but not sugar (i'm defining sugar as something that can be done by a preprocessor)
17:27:16 <medfly> @src (==)
17:27:16 <lambdabot> x == y = not (x /= y)
17:27:24 <ezyang> @src (/=)
17:27:25 <lambdabot> x /= y = not (x == y)
17:27:25 <mauke> weilawei: are all variables sugar?
17:27:25 <jmcarthur> weilawei: why isn't a foo function syntax sugar then?
17:27:26 <weilawei> jmcarthur: is the preprocessor turing complete?
17:27:37 <weilawei> mauke: yes. and so are multi-argument functions!
17:27:44 <medfly> :)
17:27:47 <weilawei> curry it all by hand, you lazy oafs
17:27:52 <mauke> weilawei: how di variables desugar?
17:27:55 <mauke> *do
17:27:56 <jmcarthur> weilawei: your definition of sugar is not consistent with mine
17:28:01 <ksf> weilawei, the c-like preprocessor isn't, TH is.
17:28:20 <ksf> (th being running haskell code that returns an haskell ast at compile time)
17:28:20 <medfly> jmcarthur, maybe he means the entire language is sugar. sugar for very complicated asm?
17:28:28 <jmcarthur> sugar for... abstractions?
17:28:36 <jmcarthur> semantic sugar?
17:28:37 <weilawei> jmcarthur: admittedly, i'm making an extreme case here. but the real thing i want to get at is that much of "Haskell" could be stripped and technically still be haskell
17:28:43 <weilawei> it's very hard to strip C and have C
17:28:51 <jmcarthur> weilawei: how do you strip identifiers form haskell?
17:28:52 <weilawei> without going entirely to another representation
17:28:54 <jmcarthur> *from
17:28:54 <ksf> monads are semantic sugar for explicit xyz passing
17:28:56 <aconbere> anyone know of a reasonable intraduction to using the Iteratee package? The test are incredible dense, especially compared to the relative simplicity (or familiarity) of handle based IO.
17:29:32 <ksf> I'm aware of only a single c-like preprocessor that's turing complete, and that's nasms.
17:29:53 <aconbere> It would be /awesome/ to see someone start with just reading and writing a file  :P
17:30:05 <aconbere> as opposed to ... monadic parsec streams
17:30:15 <ksf> it's real fun. you can do macros to do ccalls, variadic printf etc,
17:30:25 <copumpkin> oof! done with the zip/zipWith/unzip/izipWiths up to 6
17:30:29 <weilawei> jmcarthur: can't in haskell .. seems to be builtin as qvarid and varid. I'm relatively new to haskell, go easy =P
17:30:47 <weilawei> but my point is not so much that a particular thing is sugar. just that lots of Haskell that's commonly used is not "essentialy"
17:30:48 <dons> aconbere: still very new. i don't think we have intros yet.
17:30:56 <jmcarthur> weilawei: my point is that syntax /= syntax sugar
17:30:59 <dons> and honestly, it wouldn't be my first choice for an io subsystem
17:31:06 <mauke> weilawei: == is a library function
17:31:08 <jmcarthur> weilawei: and identifiers are pretty much essential, afaik
17:31:17 <ksf> ...every haskell program can be reduced to a pointfree version, I think
17:31:22 <aconbere> dons: well I've been (for the sake of progressing my haskell) working on a tiny webserver
17:31:31 <jmcarthur> ksf: which still requires (top-level) identifiers
17:31:36 <weilawei> jmcarthur: I believe you are correct, however.. wiki agrees with me: "Specifically, a construct in a language is called syntactic sugar if it can be removed from the language without any effect on what the language can do:"
17:31:39 <ksf> one. just one.
17:31:49 <jmcarthur> ksf: you need combinators too
17:31:53 <aconbere> dons: and I went from you know... handle based which worked, but wasn't the speed I wanted
17:32:06 <aconbere> dons: to Lazy IO which I had weird failures at parsing the entire stream
17:32:11 <jmcarthur> weilawei: right. you can't remove most of the features you are talking about
17:32:18 <weilawei> jmcarthur: from the language or the platform?
17:32:22 <aconbere> dons: and I thought I would give a shot at looking at how Iteratees might help there
17:32:32 <weilawei> spec /= implementation
17:32:33 <jmcarthur> the platform doesn't have syntax at all...
17:32:46 <jmcarthur> i'm afraid i don't understand
17:32:50 <jmcarthur> we are on completely different pages
17:32:53 <ksf> list :: a -> (a -> [a] -> b) -> [a] -> b
17:33:01 <jmcarthur> it's okay. i'm just gonna get back to coding now
17:33:05 <aconbere> dons: And while... a lot of what Oleg says makes sense, trying to understand howt that translates into practice is beyond me :)
17:33:13 <weilawei> jmcarthur: the language is something very particular. it's a document.. haskell 98 report i believe most people use.
17:33:21 <ksf> nope that's not the right type
17:33:29 <weilawei> GHC and common use have added much to this, much like common law exists on top of "law" law
17:33:35 <jmcarthur> weilawei: ghc adds a lot of extensions, of course
17:33:41 <jmcarthur> right
17:33:55 <jmcarthur> but i still fail to see what your point is
17:33:57 <weilawei> we wouldn't want to do without them.. but we *could* in theory.
17:33:58 * ksf wants his ghc to default to haskell2010
17:34:06 <ksf> I'm sick and tired of the monomorphism restriction
17:34:08 <weilawei> and that is the distinction between syntactic sugar and necessary syntax
17:34:15 <jmcarthur> weilawei: there are many extensions that are not simple syntactic transformations
17:34:50 <jmcarthur> weilawei: that may be the distinction, but that doesn't distinguish the particular syntax lexicons you are pointing out
17:34:51 <weilawei> jmcarthur: okay, so amend my statement to exclude that which cannot be achieved via syntactic transformations or pure haskell only code.
17:35:00 <weilawei> i used (==)
17:35:07 <weilawei> you brought up identifiers i think
17:35:08 <jmcarthur> weilawei: right, that's an identifier
17:35:13 <jmcarthur> (==) is an identifier
17:35:18 <weilawei> im talking about the thing in itself, as used.
17:35:21 <ksf> aconbere, there's already an iteratee-based web server
17:35:24 <ksf> hyena, iirc
17:35:26 <jmcarthur> it's used as an identifier
17:35:32 <jmcarthur> it doesn't mean anything else
17:35:33 <ksf> it's only using iteratees in the response, though
17:35:41 <ddarius> ksf: The monomorphism restriction is still in 2010 as far as I can tell.
17:35:41 <weilawei> we refer to it by an identifier.
17:35:59 <aconbere> ksf: right, but I can't understand their code either.
17:36:00 <jmcarthur> sorry, i'm going to get back to coding now. i don't think this debate is really worth much to me
17:36:04 <weilawei> but not one single place in the haskell report grammar did I see an == sign.
17:36:08 <jmcarthur> right
17:36:09 <weilawei> so it's not part of the language proper.
17:36:12 <jmcarthur> yes it is
17:36:13 <aconbere> ksf: certainly just working with other peoples code doesn't help me improve my own
17:36:21 <weilawei> jmcarthur: no, it's part of an implementation.
17:36:21 <jmcarthur> it's a defined type of token
17:36:24 <mauke> weilawei: it's part of the standard library
17:36:25 <aavogt> it's in the library
17:37:17 <weilawei> Why must people confound things? Language /= standard library. or we could just use one term to refer to it all.
17:37:25 <ksf> aconbere, but reading code that's not written by oleg helps understanding iteratees
17:37:28 <aavogt> they are in the same document, weilawei
17:37:31 <aconbere> haha
17:37:35 <mauke> the standard library is part of the language
17:37:44 <jmcarthur> weilawei: it's a varsym
17:37:45 <aconbere> ksf: totally, but I don't think that hyena was written with clarity in mind either
17:37:53 <jmcarthur> weilawei: it's in the *syntax* specification
17:37:54 <weilawei> aavogt: I stand corrected and shall shut up.
17:38:13 <weilawei> jmcarthur: actually its in the prelude section
17:38:18 <jmcarthur> weilawei: a varsym is an identifier
17:38:20 <jmcarthur> no
17:38:27 <jmcarthur> that is a particular instantiation of (==)
17:38:28 <weilawei> jmacarthur, that specific varsym is not defined.
17:38:35 <jmcarthur> you don't have to use it. you can redefine it or choose not to import it
17:38:41 <weilawei> the specific instance of something is not the general concept of it.
17:38:44 <Entroacceptor> could you argue about how to unfreeze my xmonad prompt instead?
17:38:55 <ksf> ...the main mountain to climb wrt. iteratees is realizing that they compose in the usual direction but are constructed in the other one
17:38:57 <jmcarthur> weilawei: what is you point?
17:39:00 <ezyang> Entroacceptor: try #xmonad?
17:39:02 <jmcarthur> are you just trying to be a pain in the ass?
17:39:10 <copumpkin> @pl (\a b c -> f a (Fin b) c)
17:39:10 <lambdabot> (. Fin) . f
17:39:13 <weilawei> the thing and the thing in itself are very very different and you're confounding two distinct concepts with each other.
17:39:19 <jmcarthur> no i'm not, you are
17:39:19 <ksf> Entroacceptor, old xmonad on amd64?
17:39:28 <jmcarthur> (==) is not in the syntax specification. it's not syntax sugar at all
17:39:28 <ksf> ...my prompt works.
17:39:35 <jmcarthur> varsym is
17:39:39 <jmcarthur> but still not sugar
17:39:43 <weilawei> jmcarthur: the particular usage of (==) is not the usage of ANY varsym. it is an INSTANCE.a varsym is saying we have a CONCEPT.
17:39:49 * hackagebot upload: ghc-core 0.5.2 - Display GHC's core and assembly output in a pager (DonaldStewart)
17:39:50 <dons> fyi, y'all, ghc-core supports the -fllvm backend now.
17:39:58 <weilawei> the symbol is not the thing in itself
17:40:00 <ezyang> dons: Yay!
17:40:06 <jmcarthur> weilawei: right. so what's your point?
17:40:10 <ksf> dons, darcs or did I miss an announcement?
17:40:12 <jmcarthur> we are talking about syntax sugar
17:40:27 <dons> ksf: just uploaded.
17:40:29 <copumpkin> @pl (\a b c -> f (Fin a) b c)
17:40:29 <lambdabot> f . Fin
17:40:38 <weilawei> jmcarthur: it's under Prelude, not syntax at all. And if you insist it's part of the language, wiki says it IS syntactic sugar. "Specifically, a construct in a language is called syntactic sugar if it can be removed from the language without any effect on what the language can do"
17:40:39 <dons> (i.e. ghc-core can find where the .s files are that llvm produces)
17:40:56 <jmcarthur> varsym is the specification for the symbolic identifier. (==) is a particular case that fits the definition. the (==) in Prelude is in a library. i don't get why this is so fuzzy
17:41:02 <weilawei> the language would still be capable of defining that (==) varsym.
17:41:15 <weilawei> so its sugar by the strict definition if you call it part of the libary.
17:41:21 <weilawei> *language
17:41:31 <ksf> 6.13 I figure
17:41:34 <jmcarthur> you are confusing syntax and semantics
17:41:39 <jmcarthur> okay, i'm really done
17:41:46 <mauke> weilawei: maybe it's sugar, but then it's not syntactic sugar
17:41:46 <jmcarthur> argue with somebody more patient
17:42:00 <dons> ksf: oh, the llvm backend?
17:42:04 <ksf> weilawei, == is a typeclass member like any other
17:42:06 <ksf> dons, yes
17:42:19 <dons> it was announce yesterday. bigest event on the interwebs. http://www.haskell.org/pipermail/cvs-ghc/2010-February/052606.html
17:42:22 <ksf> ...you can do the -XNoImplicitPrelude thing and define it yourself.
17:42:24 <weilawei> ksf: but it would not compromise the existence or turing completeness of the language to not have it, would it?
17:42:45 <weilawei> that makes it sugar. play wordgames if you want, but it is not critical, absolutely essential.
17:42:52 <Saizan> weilawei: are you saying we should have a standard library?
17:42:54 <ksf> I'm no theoretican, but I'd say pattern matching and open recursion are sufficient to do that.
17:42:54 <weilawei> i dont intend to stop using it or redefine it.
17:43:02 <Saizan> weilawei: err, we shouldn't have
17:43:06 <mauke> weilawei: it's not syntactic
17:43:15 <weilawei> mauke: fine, just sugar.
17:43:23 <ksf> ...so you can do stuff completely without any of the primitives ==, Int, Float etc are backed by,
17:43:24 * ezyang can get in bed with that statement 
17:43:29 <Saizan> weilawei: in haskell every library can define any operator it wants
17:43:33 <weilawei> Saizan: no, not at all. You realize this started with me simply saying that haskell has a lot of syntax
17:43:36 <ezyang> it's not a very useful statement though
17:43:44 <ksf> but it's only going to have the side-effect of making your cpu hot, as there's no IO, then.
17:43:56 <Saizan> weilawei: is "map" syntax?
17:44:05 <ezyang> weilawei: Are you familiar with any lisp-like languages?
17:44:33 <weilawei> Saizan: is it part of the rules or principles that govern the language? ;)
17:44:33 <ezyang> The concept of a "special form" is substantially clearer in these languages
17:44:56 <weilawei> ezyang: I am, but I'm simply trying to communicate that somewhere, someone decided that distinction was crucial.
17:44:59 <weilawei> Why NOT build it in?
17:45:02 <Saizan> weilawei: as much as (==) is, so none, just like any other function defined in any other library
17:45:29 <weilawei> Saizan: Are they, in your opinion?
17:45:34 <weilawei> I don't really care which way it goes.
17:45:55 <ksf> == isn't sugar. typeclasses, themselves, are.
17:45:55 <Saizan> it's not syntax to me, unless you say any new defined function is syntax
17:46:04 <ksf> semantic sugar, not just syntax
17:46:06 <Saizan> i.e. it's not part of the grammar, it's just part of the vocavulary
17:46:10 <weilawei> Saizan: then it's just sugar. semantic.
17:46:15 <weilawei> I said I stood corrected on that.
17:46:26 <ezyang> I believe we are in vigorous agreement then.
17:46:30 <Saizan> i've no idea why we're calling it sugar though :)
17:46:35 <weilawei> ezyang: I believe so
17:46:45 <medfly> kind of a noob question, but how do I use Data.Bits.bit?
17:46:45 <ksf> weilawei, it's semantic sugar, but not of the semantics of the language, but application written in it.
17:46:46 <weilawei> Saizan: only for the sake of referring to it rigorously.
17:46:50 <medfly> @type Data.Bits.bit
17:46:51 <lambdabot> forall a. (Bits a) => Int -> a
17:46:58 <ksf> granted, there's no hard distinction, there.
17:47:05 <Saizan> weilawei: you call sugar every function you define?
17:47:09 <MissPiggy> does a 1-tuple have buddha nature?
17:47:12 <ezyang> weilawei: So, connotationally, I might argue that calling it "sugar" is a disservice.
17:47:14 <aavogt> > bit 8 :: Word8
17:47:15 <lambdabot>   0
17:47:18 <medfly> oh
17:47:20 <medfly> thanks
17:47:22 <aavogt> > bit 7 :: Word8
17:47:23 <lambdabot>   128
17:47:25 <weilawei> ezyang: can we speak denotationally for even just a while?
17:47:32 <ezyang> The ability to build abstractions to make writing DSLs easy is pretty powerful
17:47:41 <weilawei> i've been attempting to.
17:47:45 <ksf> MissPiggy, 1-tuples are dynamically typed.
17:47:59 <weilawei> Saizan: everything is sugar at some level. We didn't make the universe as far as we know.
17:48:07 <ezyang> weilawei: Well, it's the reason why a lot of people in the channel kind of shift nervously when you call it sugar.
17:48:14 <medfly`> sorry
17:48:16 <medfly`> @index Word8
17:48:16 <lambdabot> Data.Word, Foreign
17:48:23 <aavogt> medfly: why are you twiddling with bits for?
17:48:25 <Saizan> weilawei: ok, i see what you're saying then, it seems a pretty useless definition to me, but ok
17:48:34 <medfly`> aavogt, no good reason.
17:48:49 <weilawei> Saizan: well that's the one from Wiki.. go edit if you like.
17:49:14 <weilawei> Saizan: It was an otherwise ignorable word used in a conversation which has since entirely evaporated.
17:49:17 <mietek> Is it possible to keep cabal-install from keeping anything in $HOME?
17:49:25 <weilawei> I.e., the difficulty of haskell's learning curve.
17:49:36 <mietek> Even $HOME/.cabal/config
17:50:04 <Saizan> mietek: there's a flag to specify another config file
17:50:15 <Saizan> mietek: see cabal --help
17:50:25 <sahazel> I think when I was first learning haskell, I thought there was a lot more syntax than there is
17:50:27 <jmcarthur> weilawei: are you a ninja?
17:50:34 <ksf> sugar doesn't evaporate. it crystalizes or becomes caramel
17:50:40 <weilawei> jmcarthur: nah, i just suffered through etymology.
17:51:09 <weilawei> (actually, i loved it. i was going to be an english or philosophy major once.. then I said screw it, ill keep coding.)
17:51:15 <sahazel> there were things that I thought had to be syntax that turned out to just be infix functions
17:51:16 <Saizan> mietek: mh, i've talked too soon :)
17:51:28 <mietek> Saizan: :)
17:51:29 <Saizan> mietek: i'm pretty sure there's a flag but i'm not sure where it's documented
17:51:54 <ksf> ...it's actually quite hard to make carbon gaseous, at least when there's oxygen around.
17:51:59 <sahazel> now it feels like it has about as much syntax as lisp, but the syntax bends better
17:52:07 <sahazel> but early on it felt like it had a lot more
17:52:19 <Saizan> weilawei: tbh, i don't see a definition for "sugar" (in a programming language) only "syntactic sugar"
17:52:21 <MissPiggy> if I do
17:52:26 <MissPiggy> f :: a -> ...
17:52:34 <MissPiggy> f = ... where b = foo :: a
17:52:39 <MissPiggy> (because foo is a typeclass thing)
17:52:53 <MissPiggy> how do you make that do the right thing? Right now it thinks that's a different a
17:52:58 <ksf> "sugar" is the stuff you get with your medicine so you swallow it.
17:53:05 <Saizan> MissPiggy: you need ScopedTypeVariables and use f :: forall a. a -> ...
17:53:16 <MissPiggy> thanks!!! I'll try it out!
17:53:21 <weilawei> Saizan: "3. Compliment or flattery used to disguise or render acceptable something obnoxious; honeyed or soothing words. [Colloq.]" http://www.dictionary.net/sugar
17:53:39 <weilawei> I believe that usage to be the forebearer of the term "syntactic sugar"
17:53:57 <ksf> ok, to come back to coding: does anyone know of something like a priority search queue with efficient unused leaf removal?
17:53:58 <aavogt> you can do it without that extension too:   f :: ...; f x = ... where b = foo `asTypeOf` x
17:54:21 <ksf> something like forcing the tree to have a fixed size.
17:54:41 <MissPiggy> okay I will paste my code and please I hope someone can give me some tips :)
17:54:56 <Saizan> weilawei: that's getting far too little formal to discuss, but then we've clarified what you meant, so ok
17:55:01 <iaefai_> Has anyone 'invented' a language that allows you to take advantage of the functional paradigm, but be able to easily integrate it into a normal C program?
17:55:03 <cads> weilawei: I've wondered if haskell could be more sugary - have you checked out Fortress? It could give one diabetes :)
17:55:18 <MissPiggy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7899#a7899
17:55:22 <ksf> @faq can Haskell integrate with C?
17:55:22 <lambdabot> The answer is: Yes! Haskell can do that.
17:55:34 <weilawei> cads: oh jeez, that one with actual mathematical notation?
17:55:40 <ksf> iaefai_, the ffi works in both directions
17:55:41 <shrughes> iaefai_: if you drop the "easily", C++ might qualify :D
17:56:40 <MissPiggy> here I have written a short example
17:56:45 <copumpkin> jmcarthur: oof, getting tired!
17:56:59 <ddarius> copumpkin: You should write a program to do it for you.
17:57:08 <iaefai_> I am aware of this, but it is not as easy because my platform is the iphone, and I can't take any untested patch. I was thinking something more like - compiles to C or just does the iphone out of the box. I know jhc can do something like this - but it won't compile on ghc 6.12 and I haven't gotten around to getting 6.10 working with snow leopard.
17:57:13 <copumpkin> ddarius: a lot of it is mechanical but sadly not all of it :(
17:57:25 <mietek> Saizan: looking at Distribution/Client/Config.hs  it seems that it's pretty much hardcoded
17:57:36 <MissPiggy> will anyone critique it for me?
17:58:17 <MissPiggy>  just want to see what people think
17:58:19 <cads> weilawei: glorious, huh?
17:58:29 <weilawei> MissPiggy: I only learned the word magma today and it already scares me.
17:58:36 <weilawei> (in that usage)
17:58:41 <MissPiggy> well it is so trivial it hardly needs a name
17:58:49 <MissPiggy> but it turns out to fit nicely in this contet
17:58:51 <MissPiggy> context
17:58:52 <mietek> Saizan: oh no!
17:59:05 <mietek> Saizan: CABAL_CONFIG :)
17:59:07 <weilawei> MissPiggy: what is obvious to one is not to another. particularly those who are weak or self-taught in math.
17:59:13 <weilawei> MissPiggy: namely, myself.
17:59:15 <MissPiggy> I mostly stole this idea from jmcarthur
17:59:22 <MissPiggy> but it's slightly different, I think
17:59:37 <cads> weilawei: I think agda has a way of defining operator syntax which could let you make very "sugary" notations: http://www.cs.nott.ac.uk/~nad/publications/danielsson-norell-mixfix.pdf
18:00:11 <MissPiggy> weilawei: it just means a data type 'a' which has an operation with type a -> a -> a on it!
18:00:12 <aconbere> ksf: so I know my basic understand of how this library is supposed to work is broken because this doesn't work
18:00:14 <weilawei> cads: see, every time I see people gratuitously defining syntax-like things or new syntax, i start edging away and want my blanket and some nice hot C
18:00:16 <aconbere> fileDriver (Data.Iteratee.break (\x -> x == ':')) "/Users/aconbere/test"
18:00:20 <MissPiggy> anyway
18:00:28 <copumpkin> need moar documentation on vector
18:00:39 <aconbere> ksf: (that lambda can just be (== ':') but I was mucking with various things
18:00:43 <MissPiggy> nobody seems to want to critique my code :\
18:00:43 <copumpkin> I'm trying to make its interface safe but it's hard to do that when I don't know what it does :P
18:00:45 <ezyang> quick mateys open the pumps!
18:00:48 <aavogt> MissPiggy: that looks like it might be inconvenient to use due to ambiguous type variables
18:00:56 <weilawei> MissPiggy: I encountered it in the context of category theory earlier, not just practical application
18:01:17 <MissPiggy> aavogt, I am not sure what that means can you show me ambiguous type variables?
18:02:36 <aavogt> MissPiggy: when you use your   'e', how should it know what the type variables 'm' and (&) are?
18:02:51 <MissPiggy> aavogt, well m would be something like Integer, or Rational
18:02:54 <MissPiggy> for example
18:03:15 <MissPiggy> e and (&) and plus and times.. etc.. they are tokens that name an operator
18:03:31 <MissPiggy> (+) = binaryOperation (undefined :: plus)  turns a type level operator into a value level one
18:03:36 <aavogt> well you can write lots of instances of Monoid where e :: Int
18:03:53 <aavogt> how is the compiler to know which instance to choose when you just use 'e'?
18:03:53 <MissPiggy> ohh
18:03:56 <MissPiggy> I have a mistake in my paste
18:04:01 <MissPiggy> it should be:
18:04:02 <MissPiggy> class Semigroup m (&) => Monoid m (&) e where e :: (e) -> m
18:04:04 <MissPiggy> and so on
18:04:12 <MissPiggy> I just forgot to do that :(
18:04:27 * copumpkin can think of at least 6 Int-specific monoid instances
18:04:32 <aavogt> ok, but that still leaves the (&) variable unspecified...
18:04:49 <MissPiggy> yeah (&) doesn't need a concrete value, I don't think
18:05:16 <MissPiggy> you could use tokens like  data Additive, data Multiplicative   to pick specific instances defined on the same carrier (Int)
18:05:19 <aavogt> you still have issues for selecting instances regardless
18:05:28 <MissPiggy> what are the issues?
18:05:50 <aavogt> because (&) is supposed to be a specific type in your instances
18:05:58 <MissPiggy> oh why?
18:06:08 <aavogt> because typeclasses work that way?
18:06:20 <MissPiggy> hmm
18:07:20 <aavogt> maybe this can be worked out by making   m :: * -> *, and having your Multiplicative or whatever be a parameter to m
18:07:45 <Toxaris_> MissPiggy: consider instance Monoid Int () () where e _ = 1; instance Monoid Int Bool () where e _ = 2
18:07:57 <MissPiggy> oh so you mean use: binaryOperation :: m (&) -> m (&) -> m (&) instead?
18:08:37 <aavogt> yeah, but still keeping the first (&) param
18:09:02 <MissPiggy> oh so you mean use: binaryOperation :: m (&) -> m (&) -> m (&) instead?
18:09:04 <MissPiggy> ooops sorry
18:09:21 <aavogt> otherwise you never get to specify that variable with actual values
18:09:46 <aavogt>  binOp :: (&) -> m (&) -> m (&) -> m (&)
18:10:31 <MissPiggy> why does it want m (&) ?
18:10:35 <MissPiggy> instead of just m
18:10:47 <gwern> Sum Int isn't very useful, I realized today; because you can pass in negative ints
18:10:59 <aavogt> because then your  e :: e -> m (&) names all your type variables
18:11:28 <aavogt> and you stand a chance to get them all to resolve to concrete types in the end
18:11:58 <Toxaris_> I think binaryOperation does not belong into Magma. The value corresponding to type (&) should be well-defined and accessible independently of any Magma instances. And so on.
18:12:28 <ddarius> gwern: So?
18:12:52 <gwern> ddarius: well, one might expect a int monoind to at least increase
18:12:59 <ddarius> gwern: Why?
18:13:13 <aavogt> use Word then
18:13:14 <augur> anyone in here a latex expert that i can poke at for a bit? :x
18:13:24 <gwern> ddarius: because most monoids 'increase'
18:13:33 <ddarius> gwern: Every group is a monoid.
18:13:43 <ddarius> I don't know where you get this "monoids 'increase'" idea.
18:14:03 <gwern> loggers increase; lists increase
18:14:50 <ddarius> And a monoid of sets with a universal set and intersection "decreases"
18:16:17 <ksf> ...what I actually want is a search tree that's balanced in a way that more frequently accessed leaves have shorter paths and sparsely accessed leaves can be pruned
18:16:19 <ddarius> And I'm not sure in what sense the endofunction monoid "increases" or "decreases."
18:17:14 <ddarius> ksf: Keep track of, and balance on, accesses?
18:17:16 <Draconx|Laptop> ksf, like a splay tree?
18:17:56 <ksf> exacly.
18:17:57 <ksf> thanks
18:18:30 <MissPiggy> aavogt, oh this sucks :(
18:18:33 <MissPiggy> I did:
18:18:34 <MissPiggy> instance Ring P.Integer Additive Multiplicative Additive Multiplicative Additive where
18:18:55 <MissPiggy> but still  fumble 3 5 4 :: (P.Integer,P.Integer)  doesn't work, because it doesn't know how to fill in the gaps
18:19:01 <MissPiggy> it just says "No instance for (Ring P.Integer plus times zero one neg)"
18:20:58 <aavogt> you can write Ring P.Integer Additive Multiplicative Additive Multiplicative Additive => in the type signature of fumble
18:21:26 <aavogt> and it might do something... I'm not so sure about it though
18:21:42 <MissPiggy> wait I tidyd it up a little bit
18:21:46 <MissPiggy> I think this is almost working
18:22:23 <MissPiggy> how does this seem ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7899#a7901
18:23:43 <MissPiggy> I will have to make a special program to read the source code if I program in this way...
18:23:59 <MissPiggy> because sometimes you want to view colums and other times you want to view rows
18:24:59 <MissPiggy> I wonder if this sort of thing would scale up for a full size program?
18:26:12 <Saizan> rows/column?
18:26:25 <aavogt> a grid?
18:26:42 <MissPiggy> each abstract structure is a column, and each concrete type is a row
18:26:47 <augur> no latex gods huh :(
18:26:55 <MissPiggy> so for something like Gaussian, you want to read the definiton and all the instances
18:27:05 <MissPiggy> and for something like Ring, you want to read the class... and all the instances
18:27:16 <MissPiggy> but that's impossible to organize in a filesystem
18:27:28 <aavogt> doesn't haddock group instances like that?
18:27:34 <MissPiggy> augur, I know how to do stuff like \sqrt{2} but not quite a god...
18:27:39 <augur> :P
18:27:52 <augur> well you'd be a goddess, if we assume "god" is a masculine now, but
18:27:55 <MissPiggy> aavogt oh! that would save some work for me!
18:28:33 <MissPiggy> augur, I always thought giving gods gender was a bit too anthropomorphic
18:28:43 <augur> depends on your religion.
18:37:01 <Toxaris_> MissPiggy: In your latest paste, the caller of fumble has to explicitly select the instances to be used. Whats the point of using typeclasses if there is no automatic instance selection?
18:37:46 <MissPiggy> Toxaris, the typeclasses express what I have proved about my data types
18:38:04 <MissPiggy> so on paper if I prove something abelian, then I can explain that to haskell -- and it will keep track of it
18:38:21 <Toxaris_> MissPiggy: It would probably be easier to reify the various structures as dictionaries, and explicitly pass the dictionaries around
18:38:23 <MissPiggy> that's the plan anyway, which I am trying to implement
18:38:50 <MissPiggy> Toxaris_, I can't really visualise that but it sounds good... hm?
18:39:17 <Toxaris_> MissPiggy: data Magma carrier = Magma {binaryOperation :: carrier -> carrier -> carrier}
18:40:19 <Toxaris_> integerWithPlus = Magma (+) :: Magma Integer
18:40:36 <Toxaris_> integerWithTimes = Magma (*) :: Magma Integer
18:40:44 <MissPiggy> Toxaris this is a lot neater!
18:41:28 <Toxaris_> the inheritance structure of the type class can be expressed with conversion function
18:42:04 <Toxaris_> everyMonoidIsAMagma :: Monoid carrier -> Magma carrier; everyMonoidIsAMagma (Monoid f _) = Magma f
18:42:21 <MissPiggy> nice
18:42:25 <Toxaris_> probably you want a typeclass to express this sub-structure relationship
18:42:39 <MissPiggy> fromMonoid :D
18:42:54 <Toxaris_> class Sub a b where upcast :: a -> b
18:43:22 <dmwit> hehe
18:43:30 <ksf> I'm tempted to be cheap and just use two maps: if the first one exceeds a certain size, I insert into the other one, lookup in both, moving looked up stuff into the second one. elements are then discarded from the old map when the second map hits a certain size
18:43:38 <dmwit> Now, convert that typeclass into a data type...
18:43:58 <Toxaris_> now you could define flexibleBinaryOperation = binaryOperation . upcast
18:44:25 <ksf> that might not be optimal, but it's O(low) in both runtime and implementation.
18:45:00 <Toxaris_> so that you can use flexibleBinaryOperation on Monoids to get the Magma binaryOperation
18:45:33 <Toxaris_> or consider using HList instead of inventing your own clever record system, not sure
18:46:08 <MissPiggy> this is really interesting
18:46:30 <Toxaris_> dmwit: what would be the point?
18:47:01 <aavogt> because the third time's the charm
18:47:06 <copumpkin> tada
18:47:10 * hackagebot upload: vector-static 0.0.1 - Statically checked sizes on Data.Vector (DanielPeebles)
18:47:37 <copumpkin> it'll probably turn out to be useless, but I had fun
18:47:41 <copumpkin> and still am
18:48:39 <Cale> http://www.neuroproductions.be/logic-lab/index.php?id=1037 :)
18:48:39 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:48:53 <copumpkin> ew, fullpage flash
18:49:43 <Cale> Yeah, not much one can do about it :)
18:50:07 <Cale> I suppose it *could* have been implemented in Javascript with canvas magic.
18:50:36 <Cale> I just wired up that 4-bit adder :)
18:50:49 <Cale> Actually, I found myself wishing that the container was even bigger
18:50:52 <copumpkin> sounds tedious :P
18:51:15 <copumpkin> probably not as tedious as what I've been doing for the past few hours though
18:55:30 <Toxaris_> MissPiggy: you can even add some automatic instance selection where appropriate by defining   class Default a where default :: a
18:55:52 <MissPiggy> okay
18:55:54 <Toxaris_> MissPiggy: and instance Default (Magma Integer) where default = integerWithPlus
18:56:28 <Toxaris_> of course, you can have only one default per carrier, but that's the point of defaults: they only applies sometimes :)
18:56:29 <MissPiggy> what I am wondering is, what about all these MakeMonoid, MakeGroup constructors?
18:57:02 <MissPiggy> the compiler wont be able to remove (most of) them and I am not sure what it will be like to program with them
18:57:07 <mauke> Toxaris_: Data.Default :-)
18:57:31 <ddarius> Cale: Now find an online site that will take analog circuitry and make a four-bit adder out of transistors, or better, lets you etch substrate and make the transistors as well.
18:58:01 <Cale> ddarius: There was a puzzle game that had you lay down n-type and p-type material
18:58:12 <MissPiggy> Cale ohh that sounds fun??
18:58:15 <MissPiggy> what is it called
18:58:16 <Cale> ddarius: But it didn't work well for me under linux
18:58:50 <Cale> I forget, let me see if I can find it.
18:59:36 <Toxaris_> MissPiggy: afaik typeclasses are compiled by ghc into something very similar to what I sketched, so I wouldn't worry about runtime overhead
18:59:36 <dmwit> More places need to let you delete your account.
19:00:36 <Toxaris_> MissPiggy: at programming time, the code looks quite similar to what you showed in your last paste.
19:00:46 <MissPiggy> cool
19:01:05 <MissPiggy> hey I have a question
19:01:24 <MissPiggy> is there something missing from typeclasses, which is why your way comes up?
19:01:38 <Cale> http://www.zachtronicsindustries.com/?p=710
19:01:43 <MissPiggy> thanks!
19:02:10 <Toxaris_> I wouldn't say so
19:02:23 <aavogt> type defaulting is limited to numeric types?
19:02:32 <copumpkin> sadly
19:02:42 <Toxaris_> the problem is that there is no way for a type to be member of the same typeclass in different ways, i.e. with different instances
19:02:58 <MissPiggy> so if we had named instances would that solve it?
19:03:08 <MissPiggy> (and my id' stuff basicaly was a hack that tried to add names)
19:03:14 <Toxaris_> I guess
19:03:30 <Toxaris_> in a sense, my approach could be named the "named instance pattern"
19:03:32 <Walt> Cale, did you write that logic thing?
19:03:34 <Cale> You're supposed to be able to hold shift to select which type of material to place, but for me, Flash consistently mismanages the shift key, and pressing it once gets it stuck.
19:03:43 <Cale> Walt: no, I just built the adder
19:03:51 <Walt> I see
19:04:01 <Walt> the speaker component seems broken
19:04:06 <Walt> it always beeps twice
19:04:42 <Cale> Huh, it seems to work for me. It produces a continuous tone when driven, based on the position of the knob.
19:05:45 <ksf> grmbl (.) isn't overloaded for #-kinds
19:15:02 <Walt> Cale,  :( I get a short tone first, then a longer one.
19:15:06 <MissPiggy> type T a = a -> a -> a --- does this have a name?
19:15:22 <MissPiggy> hmm silly question :..
19:15:33 <dmwit> It's got the name T. ;-)
19:15:34 <copumpkin> I've called it Op2 before
19:15:36 <copumpkin> or BinOp
19:15:54 <indil> I have a parsec question: Is there a way to exclude matches from a parser? E.g. something like (many1 anyChar) `exclude` (string "int")
19:16:55 <mauke> indil: what do you want it to do if it hits "int"?
19:16:59 <mauke> return "in" instead?
19:18:12 <indil> Not match the input.
19:18:39 <indil> The idea is to have a variable parser that doesn't match against some pre-defined reserved keywords.
19:18:56 <ddarius> What does try (string "int" >> fail "foo") <|> many1 anyChar do?
19:19:05 <mauke> do { x <- many1 anyChar; when (x == "int") $ fail "no bus no"; return x }
19:19:25 <ddarius> indil: You should also look at the provided Language and Token parsers.
19:19:27 <mauke> ddarius: that "try" looks wrong
19:21:12 <indil> Thanks, I'll try those out.
19:21:21 <indil> ddarius++
19:21:22 <indil> mauke++
19:22:37 <chrisdone> sup
19:22:44 <chrisdone> what's the responsiveness like on this? http://kiboki.net/haskell/eval-demo/
19:25:49 <ddarius> Seems pretty broken, but responsive enough.
19:26:03 <chrisdone> broken?
19:26:05 <ddarius> The fade effect seems like a waste of time.
19:26:20 <ddarius> chrisdone: Seems to have a problem with 2+2 :: Int.
19:26:52 <chrisdone> ah good point
19:27:10 <Cale> Huh, it thinks that it's a function for some reason...
19:27:28 <chrisdone> '+' needs url encoding. thought jquery would do that for me, but nope ^_^
19:27:31 <ddarius> Probably being misparsed.  Perhaps the + is being converted to a space.
19:29:07 <felzix> With simply "+", I get "not an expression: ` '"
19:29:25 <Cale> yeah, it works with *
19:30:18 <mauke> try 2%2b2
19:30:45 <chrisdone> yeah was just about to =)
19:31:05 <felzix> beat me to it, mauke
19:31:50 <chrisdone> works now =)
19:32:54 * dmwit let x = 1:x in x
19:33:02 <dmwit> It doesn't like that. =)
19:33:50 <copumpkin> it doesn't like anything I do
19:33:52 <chrisdone> hmm I weird
19:33:55 <mauke> fix error
19:34:04 <dmwit> copumpkin: That started as soon as I tried my infinite loop.
19:34:11 <dmwit> copumpkin: I think it broke things for everybody.
19:34:11 <copumpkin> ah ok
19:34:22 <copumpkin> boo
19:34:32 <copumpkin> chrisdone: you should use mueval or luna
19:34:41 <chrisdone> I've tested let r = r in r, but I guess dmwit's expression does something I've not checked...
19:34:46 <chrisdone> copumpkin: it's jusing mueval
19:34:49 <copumpkin> ah ok
19:35:53 <chrisdone> had to hack it though so I could use it as a pipe, because it takes around 500 milliseconds, due to setting up all the limits, to evaluate an expression on my pc
19:36:24 <copumpkin> wow
19:36:34 <Cale> It seems to do poorly with anything infinite...
19:36:56 <dmwit> Cale: Right now, it's doing poorly with anything, period.
19:37:13 * copumpkin wonders what to do with his new library
19:37:16 <chrisdone> one infinite thing will probably stall it, everyone shares the same one right now
19:37:18 * chrisdone takes it down
19:37:21 <Cale> I can compute factorials.
19:37:28 <Cale> let fix f = x where x = f x in map (fix (\fac n -> if n == 0 then 1 else n * fac (n-1))) [1..10]
19:37:35 * mauke tried "fix error"
19:37:40 * Cale did too
19:39:05 <chrisdone> those work fine, they probs didn't work because [1..] kills it. investigating that now
19:39:45 <chrisdone> well it works fine on my local mubot. must be a protocol bug =)
19:42:31 <roconnor> reasoning about imperitive programs is a pain because invarients keep getting "temporarily" broken
19:43:06 <MissPiggy> yeah you need to be really creative about picking invarients that work
19:44:06 <roconnor> I think the invarients are no that hard to pick, but they keep getting broken when updating structures.
19:44:10 <chrisdone> dmwit: I can't seem to break it again. what expressions did you try? the jsonrpc link is http://kiboki.net/haskell-eval.json?jsonrpc=2.0&id=1&method=eval&params={"expr":"whatever here"}
19:44:14 <Alpounet> copumpkin, hpaste it
19:44:28 <copumpkin> Alpounet: ?
19:44:38 <roconnor> and this makes composabity a pain because you cannot easily call other functions during an update, which is exactly what you want to do for modular programming.
19:44:39 <Alpounet> I wanna see it
19:44:46 <copumpkin> Alpounet: oh, it's on hackage
19:44:52 <copumpkin> @hackage vector-static
19:44:52 <lambdabot> http://hackage.haskell.org/package/vector-static
19:44:54 <Alpounet> oh
19:44:55 <Alpounet> nice
19:45:37 <copumpkin> slice :: (G.Vector v a, Nat k) => Fin n -> k -> Vec (n :+: k) v a -> Vec k v a
19:45:47 <MissPiggy> Toxaris_ are you still there?
19:45:47 <MissPiggy> I run into a problem :[
19:47:58 <MissPiggy> hi Toxaris
19:48:48 <chrisdone> dmwit: derp, I figured the problem. /fixes before anyone notices
19:50:13 <dmwit> chrisdone: Hm, should it be working now?
19:50:45 <dmwit> Oh, it just doesn't respond to things that take infinite time, or what?
19:50:48 <chrisdone> dmwit: ok, now try it
19:51:03 <dmwit> Hah, sweet!
19:51:06 <copumpkin> oh nice
19:51:12 <copumpkin> i liek yo style
19:51:17 <chrisdone> yaaay
19:51:33 <copumpkin> BUT
19:51:40 <copumpkin> I'd make the text appear at the top
19:51:41 <MissPiggy> Toxaris I don't think that approach works for ring?
19:51:49 <copumpkin> if I make enough requests, it goes off the bottom of the screen
19:51:53 <chrisdone> copumpkin: yeah I was debating either appear at top or scroll to bottom?
19:52:08 * chrisdone strokes copumpkin's beard
19:52:13 <copumpkin> I'd say scroll to top, or move box to bottom and have it scroll away from you like a terminal
19:52:16 <copumpkin> :O
19:52:22 <copumpkin> I HAZ NO BEARD
19:52:33 <copumpkin> I R PUMKIN
19:52:35 <chrisdone> THEN WHO WAS STROKE?
19:52:59 <chrisdone> hmm
19:53:31 <ddarius> copumpkin: Wouldn't the textbox eventually scroll of the screen unlike a terminal?
19:53:40 <dmwit> I think I broke it again. =(
19:53:57 <copumpkin> ddarius: oh, I was thinking of having an inner iframe or scrollable area, and to scroll that instead
19:54:08 <chrisdone> dmwit: what expression?
19:54:18 <dmwit> let x = 1:x in last x
19:54:23 <copumpkin> lol
19:54:32 <dmwit> I will admit that I am trying to break it. =)
19:54:32 <chrisdone> hrmm
19:55:56 <chrisdone> hmm it killed the process after 1 second but seems my restarter didn't handle it right, good catch
19:58:31 <ksf> random interesting find (which happens to be O(log n/ log log n): http://courses.csail.mit.edu/6.897/spring03/scribe_notes/L4/lecture4.pdf
20:04:11 <MissPiggy> Toxaris__ not there?
20:07:45 * copumpkin thinks about Vector.transpose
20:08:55 <Toxaris__> MissPiggy: Hmm?
20:09:21 <MissPiggy> Toxaris, I was just wondering if Ring is expressible in this way
20:09:28 * Toxaris__ is playing kohctpyktop
20:09:40 <MissPiggy> because the thing is, both Abelian and Group have their own (potentially different) Magma
20:09:49 * MissPiggy looks up kohctpyktop
20:10:01 <MissPiggy> ohh that
20:10:02 <ksf> it really pays off to rummage through google scholar. they're down to O( sqrt (log n / log log n) ) with O(n) space for search insert+delete
20:11:04 <ksf> > let log = logBase 2; o n = sqrt (log n / log (log n)) in o 64
20:11:05 <lambdabot>   1.5235211988703177
20:11:17 <ksf> > let log = logBase 2; o n = sqrt (log n / log (log n)) in o 128
20:11:18 <lambdabot>   1.5790662778224842
20:11:27 <Toxaris__> MissPiggy: Hmm, so you have two binary operations which should be identical. sounds bad :(
20:11:36 <copumpkin> I bet transpose could be quick
20:11:46 <ksf> > let log = logBase 2; o n = sqrt (log n / log (log n)) in map (o . (2^)) [1..]
20:11:47 <lambdabot>   [Infinity,1.4142135623730951,1.3757867787976348,1.4142135623730951,1.467440...
20:11:58 <ksf> > let log = logBase 2; o n = sqrt (log n / log (log n)) in map (o . (2^)) [10..]
20:11:59 <lambdabot>   [1.7350216012026511,1.7831750024876318,1.8295669836913755,1.874325480687694...
20:12:02 <ManateeLazyCat> Someone tell me how important that use StateT? It's looks make program logic more complicated, hard to read and understand.
20:12:13 <ksf> > let log = logBase 2; o n = sqrt (log n / log (log n)) in map (o . (2^)) [64..]
20:12:14 <lambdabot>   [3.265986323710904,3.285284919765097,3.3044225756791232,3.3234029849515307,...
20:12:22 <ksf> > 2^64
20:12:23 <lambdabot>   18446744073709551616
20:12:51 <roconnor> ManateeLazyCat: use where?
20:13:03 <copumpkin> wow, the Show instance for Data.Vector is really painful
20:13:13 <ManateeLazyCat> roconnor: StateT is realy perfect replace for IORef ?
20:13:49 <roconnor> StateT doesn't really give you the functionality of IORef
20:14:11 <aavogt> you don't have to pass the reference cells around if you use MonadState
20:14:13 <ManateeLazyCat> roconnor: StateT more like glue
20:14:18 <ksf> in particular, StateT doesn't come with unsafePerformStateT
20:14:45 <roconnor> I'm getting the impression you don't quite understand StateT
20:14:50 <roconnor> but I'm not sure
20:14:58 <ManateeLazyCat> roconnor: I have read some StateT, but give me more complicated logic, make program hard to understand.
20:15:17 <ksf> that's because state _is_ messy.
20:15:21 <ManateeLazyCat> roconnor: Yep, i'm studying how to use StateT
20:15:26 <aavogt> are you used to writing code with do notation?
20:15:37 * roconnor agress with ksf
20:16:12 <roconnor> StateT is used when you want to construct a monad that includes stateful effects
20:16:39 <MissPiggy> but ? if you want to write a program that uses state -- can there possible be a better way?
20:16:51 <ksf> one area of application is replacing a ReaderT with StateT for configuration if you happen to want to change it.
20:17:09 <ksf> of course, you still need to apply it after put'ing it, which is why state is messy.
20:17:38 <roconnor> actually I don't think I've ever used StateT that didn't commute with the other transformers in my stack.
20:17:40 <aavogt> hmm, apply it?
20:17:41 <ManateeLazyCat> Why not just use IORef or MVar?
20:17:58 <ManateeLazyCat> I can transform IORef or MVar as function argument to function.
20:18:36 * copumpkin wants rl to come on IRC :P
20:18:38 <Toxaris__> MissPiggy: maybe my idea is not applicable here, because you explicitly need the one-type-one-instance behavior of typeclass to ensure that various instances refer to the same instance of a base class.
20:18:39 <copumpkin> I have so many things to ask him
20:18:48 <roconnor> that's a fair question.  I *think* state is more restrictive that IO (or more approriately ST)
20:19:00 <roconnor> in a state monad I state up front all the content of my state
20:19:02 <ksf> aavogt, that is, every piece of code that read it before you put a new one has to notice that you put it
20:19:24 <roconnor> with IORefs you can add more state dynamically
20:19:27 <ksf> ...which just cries for MVars
20:19:45 <gbacon_> I'm trying to build haskell-platform-2009.2.0.2 on a fresh Ubuntu install, but the build of mtl fails saying it couldn't find Control.Monad
20:20:04 <ManateeLazyCat> roconnor: I have exist project, but use StateT, i need change so many code that base one IORef.
20:20:18 <aavogt> oh, but only in the case where you use concurrency
20:20:32 <copumpkin> dons: any idea why concat and transpose have been left out of Data.Vector?
20:20:33 <ManateeLazyCat> roconnor: I won't use StateT if it can't give me more clearer logic.
20:20:44 <roconnor> don't have to use StateT
20:20:56 <roconnor> BTW, you could also use STRef
20:21:03 <roconnor> which is "in between" IO and StateT
20:21:27 <ksf> aavogt, not at all. you could forget reading that font parameter and always display text with the startup font. guess why so many apps need to restart when you change some configuration or the other.
20:21:48 <ksf> manually keeping track of everything is just a plain pita.
20:22:47 <ManateeLazyCat> roconnor: I have problem is single-thread, and want change to multi-thread, so i need convert IORef to MVar for concurrent protected, and someone recommend use StateT and a manager thread for udpate common states. But i can't see StateT give any help on clear logic. Perhaps i haven't found the key that how to use StateT.
20:22:55 <ManateeLazyCat> s/problem/program
20:23:07 <roconnor> probably
20:23:16 <gbacon_> but if I run runghc Setup.hs build, mtl builds fine
20:24:02 <Toxaris__> With a State monad, you are explicit about the whole mutable state of your computation, while with IORefs etc., you can have local state, which is known only to some part of your computation. Therefore, a IORef solution can lead to less coupling, because local IORefs can be used for communicating behind the scenes. On the other hand, this communication is not evident from the types.
20:24:03 <ksf> I'd recommend a single thread that just listens for state updates and serves the current state
20:24:12 <ManateeLazyCat> roconnor: If i use MVar replace, i just need keep just *one* thread update those common status, and don't need change exist program logic, but StateT looks need change more.
20:24:32 <ksf> ...provinding both a poll and a push interface, so clients can choose. should be a couple of lines only.
20:24:41 <ManateeLazyCat> roconnor: More wrapper.
20:24:52 <roconnor> that sounds correct
20:25:30 <ksf> oh, and blocking and non-blocking writes, of course.
20:26:51 <ManateeLazyCat> ksf: I plan to use MVar with Server-Thread update manager status, if any client Thread need modified or read status, just send *request* to Server-Thread.
20:26:52 <ksf> if you've got that structure and notice that not every other thread accesses it, you get the chance of splitting up that state
20:27:15 <MissPiggy> and I'm slightly confused about how to define a field...
20:27:48 <MissPiggy> it seems wrong to define a group (*,1) on Rational Integer, because it's really Rational Integer \ {0}, but the type doesn't express that
20:27:55 <ddarius> Due to the inequation, 0 /= 1, a field is not an algebraic structure in a formal sense.
20:28:09 <MissPiggy> *nod*
20:28:16 <ManateeLazyCat> Toxaris__: Before convert IORef to MVar, i always use local IORef.
20:28:29 <ManateeLazyCat> Convert IORef to MVar is always simple.
20:28:37 <ksf> I'd recommend using STM. with that, workers can block easily on a configuration tvar and a request tchan
20:28:41 <ManateeLazyCat> And don't need change much about logic.
20:28:41 <MissPiggy> but I kind of need a way to handle it
20:29:09 <roconnor> define it to be a group on the non zero rational integers?
20:29:12 <roconnor> er
20:29:15 <roconnor> non-zero rationals
20:29:38 <MissPiggy> should I just go
20:29:39 <ManateeLazyCat> ksf: I heard STM before, it's provide better concurrent and not like MVar use mutex. But i know nothing about STM.
20:29:47 <MissPiggy> type NonZeroRationals = Rationals
20:29:57 <ddarius> Probably good enough for Haskell.
20:30:14 <MissPiggy> the thing is, I do need them to be equal types..
20:30:29 <MissPiggy> hmm
20:30:37 <MissPiggy> maybe I could use a newtype
20:30:47 <Toxaris__> I guess a newtype would be morally correct
20:30:51 <ManateeLazyCat> ksf: It's hard that convert from IORef logic to STM?
20:30:51 <ksf> ManateeLazyCat, it's really intuitive, you should pick it up quickly
20:30:56 <MissPiggy> a bit like  newtype Scope a = Scope a,  newtype Nonzero a = Nonzero a
20:31:11 <Toxaris__> possible with a smart constructor which actually checks for non-zeroness
20:31:12 <ManateeLazyCat> ksf: Don't like StateT that so much wrapper?
20:31:15 <MissPiggy> I use Scope for binding variables (stole from I am not a number, I am a free variable)
20:31:19 <dmwit> ?index unsafePerformIO
20:31:19 <lambdabot> System.IO.Unsafe, Foreign
20:31:22 <MissPiggy> and Nonzero seems very similar
20:31:23 <ksf> writeIORefReplacement = atomically . writeTVar
20:31:51 <chrisdone> dmwit: should handle infinite stuff properly now: http://kiboki.net/haskell/eval-demo/
20:32:07 <chrisdone> dmwit: do your worstest!
20:32:11 <ManateeLazyCat> ksf: Sound nice.
20:32:12 <ksf> you should be able to switch to STM without changing anything but imports and writing two functions, that is.
20:32:52 <dmwit> chrisdone: getting better =)
20:32:58 <chrisdone> dmwit: :D
20:33:16 <ksf> you've got to pay a bit attention to only have non-empty TVars around so that you never block, of course
20:33:32 <ezyang> What's the most efficient way to get a 32-size homogenous array in Haskell?
20:34:08 <ksf> @hoogle array
20:34:08 <lambdabot> package array
20:34:08 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
20:34:08 <lambdabot> module Data.Array
20:34:27 <ezyang> Can I encode the size in the type?
20:34:39 <ManateeLazyCat> ksf: If i always keep TVars full, that is, always modified it and don't empty it, then i won't blocking?
20:34:43 <chrisdone> dmwit: whatever you were just trying, the ram usage is spiking. /me ponders decreasing ram limit further
20:34:48 <ksf> ezyang, you want a vector, not an array
20:34:56 <ksf> ManateeLazyCat, yep
20:35:09 <ManateeLazyCat> ksf: Sound cool.
20:35:16 <ksf> or wait.
20:35:22 <ksf> don't take my word on it.
20:35:28 * copumpkin wonders if he should adopt Cont
20:35:37 <ManateeLazyCat> ksf: STM haven't so much wrapper, right?
20:35:38 <ezyang> ksf: Ok
20:35:44 <ezyang> So I want that fancy new vector package?
20:35:49 <ManateeLazyCat> ksf: Sorry, i don't knot anything about STM.
20:35:54 <ManateeLazyCat> ksf: Just ask. :)
20:35:56 <copumpkin> ezyang: absolutely
20:36:07 <ezyang> is it vector or uvector?
20:36:11 <copumpkin> vector
20:36:14 <ezyang> k
20:36:38 <ksf> ManateeLazyCat, use TVars, not TMVars. the former can't be empty.
20:36:50 <dino-> I was poking at Scala a bit over the past week. Seems so complicated!
20:37:11 <ManateeLazyCat> ksf: TVars is better replace to MVar for concurrent program?
20:37:11 <chrisdone> dino-: that's not complicated, that's enterprise!
20:37:19 <ezyang> Does Haskell have fast Int popcounts?
20:37:41 <jmcarthur> popcounts?
20:37:50 <ezyang> Bit population count
20:38:05 <ksf> ManateeLazyCat, depends on whether or not your MVars can be empty or not
20:38:14 <jmcarthur> oh, you mean like popcount 0b01101100001 == 5?
20:38:17 <ezyang> yah
20:38:24 * jmcarthur has no idea
20:38:25 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/3563 seems to imply userland
20:38:36 <ManateeLazyCat> ksf: My IORef just init when create, then won't be empty, i just always modified it.
20:38:40 <MissPiggy> class (Ring m id id', Group (Nonzero m) id') => Field m id id' where
20:38:42 <jmcarthur> could look in my trusty Hackers Delight book
20:38:44 <MissPiggy> how about that
20:38:45 <ManateeLazyCat> ksf: So i think MVar always full.
20:38:47 <dmwit> ezyang: prolly gotta go through the ffi
20:38:48 <copumpkin> jmcarthur: it's up on hackage, btw, but in a very rough state :)
20:38:56 <jmcarthur> copumpkin: sweet!
20:39:07 <copumpkin> one thing I forgot was a Show instance ;)
20:39:07 <ezyang> voom.
20:39:13 <copumpkin> so toList/fromList are friends
20:39:15 <ksf> ManateeLazyCat, it is, if you don't use newEmptyMVar and/or takeMVar
20:39:34 <ManateeLazyCat> ksf: Yep, i just newMVar then modified MVar.
20:39:54 <ManateeLazyCat> ksf: But i think modified MVar event is not atomic.
20:40:05 <ManateeLazyCat> s/event/action
20:40:40 <ManateeLazyCat> ksf: Modify MVar action just exception-safe.
20:40:45 <c_wraith> ManateeLazyCat: depends on what you mean by atomic.  the modifyMVar call is essentially just a take followed by a put
20:40:49 <MissPiggy> -- 0 /= 1
20:40:54 <MissPiggy> that's important too
20:40:59 <ksf> it is by itself, but you can't make a readMVar >>= writeMVar combination atomic without using takeMVar on a lock
20:41:16 <ksf> ...and that's the point where STM is magnitudes better.
20:41:38 <MissPiggy> hm now I am slightly confused about whether or not this is right
20:41:52 <ManateeLazyCat> ksf: Okay, thanks for your help! I will read resource about STM.
20:41:53 <ksf> (I was interpreting your "modified" as "write")
20:41:59 <MissPiggy> type Nonzero a = a -- maybe better than a newtype?
20:43:39 <eflister> hi - i have this function that works.  it has two maps over the same list, and i need to combine them to happen in a single pass, but i can't figure out how to do so: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22268
20:44:27 <ksf> is that even a legal type declaration?
20:44:46 <ksf> seems to be undecidable.
20:44:55 <ksf> or, rather, not occurs-compliant
20:46:56 <aconbere> what's the best choice for a simple JSON parser in haskell? certainly there has to be something better than the output of Text.JSON?
20:47:06 <MissPiggy> I am undecidible
20:47:11 <aconbere> Ok (JSObject (JSONObject {fromJSObject = [("a",JSRational False (10 % 1)),("b",JSRational False (20 % 1))]}))
20:47:11 <MissPiggy> I can never decide..
20:47:33 <ksf> aconbere, you want a generics library
20:48:26 <ksf> aconbere, http://hackage.haskell.org/package/alloy
20:48:47 <copumpkin> oh whoops, I forgot monad/applicative/functor instances
20:48:53 <copumpkin> maybe just functor and applicative
20:52:10 * MissPiggy writes my first multi-directory haskell program!
20:52:18 <MissPiggy> module Foo.Bar
20:52:22 <MissPiggy> that type of thing
20:52:26 <jmcarthur> first?!
20:52:48 <jmcarthur> oh, program, not library
20:52:56 <MissPiggy> program or librarry
20:53:07 <jmcarthur> oh, i reinstate my surprise then
20:53:11 <MissPiggy> :D
20:55:11 <chrisdone> aconbere: I was using Text.JSON today but I didn't enjoy it
20:55:13 <MissPiggy> I do not understand -XTypeSynonymInstances
20:55:17 <MissPiggy> why wouldn't that be default?
20:55:30 <copumpkin> because haskell 98 says so
20:55:30 <ManateeLazyCat> MissPiggy: How about your algebra system?
20:55:39 <MissPiggy> ManateeLazyCat: this is it!
20:55:59 <ManateeLazyCat> MissPiggy: Every -X.... is not standard of Haskell-98
20:56:33 <ManateeLazyCat> MissPiggy: We can't remove those option if we have new standard. :)
20:57:11 <aconbere> chrisdone: I don't think anyone would
20:57:48 <aconbere> chrisdone: it seems like the more pragmatic mapping of JSON -> Map String JSValue is missing :P
20:58:29 <chrisdone> aconbere: http://paste.lisp.org/display/95342
20:58:57 <chrisdone> paste.lisp.org is the only paste out there I could find that highlights haskell without screwing up on "foo'"
21:00:17 <copumpkin> GAH
21:00:33 <copumpkin> I can't make Data.Vector.Storable or Data.Vector.Unboxed Functor or Applicative instances :(
21:00:49 <aconbere> chrisdone: pygments!
21:00:52 <aconbere> http://paste.pocoo.org/show/180685/
21:00:59 <aconbere> they even support literate haskell :P
21:01:17 <aconbere> either way I don't think my little "haskell intro" is going to include JSON parsing
21:01:37 * aconbere watches his audiences eyes glaze over
21:01:59 <copumpkin> yeah, I wouldn't include it
21:02:10 <copumpkin> JSON isn't pretty in haskell
21:02:13 <chrisdone> literate haskell support!
21:02:16 <aconbere> apparently! :)
21:02:20 * chrisdone golf clap
21:02:29 <copumpkin> unless you want to make it typesafe without making it too ugly
21:02:36 <copumpkin> sounds awfully hard to me
21:03:44 <chrisdone> aconbere: what's your intro going to include?
21:03:58 <chrisdone> aconbere: an in-built evaluator!? ^-^^
21:04:09 <ezyang> aye, where's me unsafeIndex
21:04:32 <aconbere> a friend and I are just doing a whirlwind language tour for a little bar camp
21:05:11 <aconbere> so basically I'm talking about how to install ghc, types, functions, then writing a tiny "usefull" program
21:05:30 <aconbere> with some links to stuff like quick check, and resources to get started
21:05:31 <ezyang> oh, I seem to have vector-0.4.2, not vector-0.5
21:05:41 <copumpkin> ezyang: cabal update :)
21:05:46 <copumpkin> I did it too
21:06:01 <aconbere> the trick is the "small usefull program"
21:06:03 <copumpkin> ezyang: you should have no unsafeIndex! you should be using my super safe index!
21:06:10 <aconbere> given a relatively show depth of knowledge in the audience
21:06:15 <aconbere> shallow
21:06:21 <ezyang> I'm using a bitmap to check if the vector is the size I want
21:06:27 <Gracenotes> with modulo-array-length indexing, no index is unsafe!
21:06:30 <ezyang> so I've got the safety built in :-)
21:06:45 <copumpkin> boo, it should be static
21:06:48 <aconbere> In fact writing a small OpenGL program would be easier than parsing JSON :P
21:08:05 <chrisdone> I'm not sure parsing json is the hard part, it's making expressions in a way that isn't really annoying
21:10:38 <MissPiggy> getBinaryOperation _ (Natural i) (Natural j) = Natural $ getBinaryOperation (__ :: Additive) i j
21:10:41 <MissPiggy> so ugly.
21:11:12 <copumpkin> w00t, repmat :: (Nat i, Nat j) => i -> j -> Mat x y a -> Mat (i :*: x) (j :*: y) a
21:11:43 <copumpkin> all backed by nice fast vectors
21:12:06 <copumpkin> of course, hmatrix-static does that too
21:12:18 <copumpkin> but I just want to make sure it isn't too painful to work with my static vectors
21:12:51 <dolio> copumpkin: Do you expect me to believe that a bounds check on 'v ! i' is more expensive than 'v ! (1 + 1 + 1 + 1 + ... i times)'?
21:13:04 <copumpkin> dolio: hm?
21:13:19 <dolio> That's the only way your library provides to make i :: Fin n.
21:13:39 <copumpkin> oh, I've added some more things to fin now
21:13:44 <copumpkin> haven't uploaded a new version though
21:14:16 <copumpkin> there's an Int -> Maybe (Fin n)
21:14:34 <copumpkin> which shoves it in immediately, assuming it fits
21:14:53 <copumpkin> of course, that's checking against a unary natural, which is probably still pretty slow :P as I said, still very rough!
21:15:30 <dolio> That's also not actually any diffrent than doing a bounds check, unless you use the subsequent Fin n more than once.
21:15:50 <copumpkin> well, the point is you wouldn't be converting from ints very often
21:15:50 <aconbere> chrisdone: right, it's not the parsing, it's the results, and then explaining that output to someone and saying "no really it's easy"
21:16:16 <copumpkin> you'd want to work with fins as much as possible
21:16:49 <copumpkin> I'll probably give in and add a trustMe :: Int -> Fin n if you're having trouble proving stuff :P
21:17:22 <dmwit> hm
21:17:31 <MissPiggy> one annoying this is I have this big folder with all these different haskell files for algebraic structures ... and it gets ordere alphabetically :/
21:17:34 <dolio> Doesn't that defeat the entire purpose of the library?
21:17:38 <dmwit> Semantics question: should the interval [0,1] "contain" the empty interval?
21:17:38 <MissPiggy> I need it ordered in a totally different way
21:17:56 <MissPiggy> dmwit definition of contain ?
21:18:07 <copumpkin> dolio: to a degree, yep :) vectors are still indexed by their sizes though, which prevents foldl1 on zero vectors and so on
21:18:11 <dmwit> Yep, I'm asking about the definition of contain.
21:18:23 <dmwit> Which way would you want your definition to swing on this question?
21:18:26 <dolio> Alternate question: is there an empty interval?
21:18:27 <MissPiggy> well you can define it whatever way you want
21:18:36 <MissPiggy> [0,0] is equal to [6,6] ?
21:18:40 <dmwit> No.
21:18:46 <dmwit> But those aren't empty intervals.
21:18:59 <copumpkin> dolio: do you think it's a pointless exercise?
21:19:07 <MissPiggy> okay replace with (0,0) (6,6)
21:19:12 <dmwit> A better question is, is [0,-1] equal to [5,-3]?
21:19:17 <Zao> Using lists to indicate intervals makes it hard to indicate open/closed sides.
21:19:25 <MissPiggy> how is that a better question
21:19:34 <dmwit> Zao: This is interval notation, not list notation.
21:19:46 <dmwit> Zao: [x,y] is the closed interval, (x,y] is half-closed, etc.
21:19:54 <dmwit> MissPiggy: My intervals are empty. =)
21:19:54 <Zao> dmwit: Sorry. Assumed things, this being #haskell and all.
21:20:01 <dolio> copumpkin: No, but it's not there yet. And I'm not sure you can get there easily in Haskell/GHC.
21:20:10 <Zao> dmwit: I applaud you for not subscribing to the evil  [a,b[ half-open syntax.
21:20:20 <dmwit> Zao: Actually, that's my preferred notation.
21:20:24 <dmwit> Zao: It's less ambiguous.
21:20:40 <dmwit> Zao: But I try to blend in to what other people are doing, and MissPiggy gave an open interval first, so... =)
21:20:53 <copumpkin> dolio: yeah, I definitely don't think it's there yet either :P I mean, I only started a few hours ago. And it's mostly an experiment to see if you can write safe static size/bounds checking without murdering someone in the Cont monad
21:21:03 <copumpkin> or ripping your hair out in general
21:21:27 <Gracenotes> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-Interval.html
21:21:31 <dolio> This is the kind of stuff that's in a few papers on Dependent ML, as I recall.
21:21:42 <dolio> And maybe dependently typed assembly language.
21:21:43 <Gracenotes> the numbers package seems to reject empty intervals btw
21:21:54 <dolio> DML became ATS.
21:22:13 <dmwit> That type isn't going to cut it for me; I need infinite intervals and empty intervals.
21:22:39 <Gracenotes> actually, no, it doesn't. But it doesn't consider them all equal.
21:22:49 <dmwit> Anyway, that's a different kind of interval, it's an error interval. =)
21:22:56 <MissPiggy> so the point I was trying to make is if you consider (0,0) and (6,6) equal
21:23:10 <MissPiggy> then it seems perfectly sensible that every interval contains the empty one
21:23:21 <dmwit> drat
21:23:22 <Gracenotes> -.-
21:23:26 <dmwit> I was afraid you'd say that.
21:25:05 <dolio> copumpkin: My concern is that GHC isn't really up to encoding the fact that you have a loop, or something, that uses an index that never goes outside the bounds of an array, without any runtime overhead. But maybe I'm wrong.
21:25:35 <copumpkin> where would the runtime overhead come from?
21:25:46 <dmwit> Okay, fine, I'll define my own Eq instance...
21:25:49 <copumpkin> I honestly have no clue :) I was just curious how well this would work
21:25:50 <dolio> Fiddling around with proofs that have to be checked for bottom-ness.
21:26:34 <copumpkin> could be
21:29:21 <MissPiggy> proofs?
21:29:31 <MissPiggy> (in MY haskell?)
21:29:37 <copumpkin> :)
21:29:39 <dmwit> It's more likely than you think!
21:29:58 <copumpkin> I wonder if common proofs could be caught and rewritten to be nothing
21:30:24 * MissPiggy treats haskell as compiler output (I am the compiler) and erases proofs myself
21:30:24 <dmwit> I guess there's that concept of proof irrelevance to help you out.
21:30:43 <copumpkin> dmwit: yeah, but "implementing" it in GHC rewrite rules?
21:30:49 <dmwit> hm =)
21:31:20 <dolio> Proof erasure is unsound if your language is Turing complete, though.
21:31:36 <dolio> Even irrelevance, probably.
21:31:51 <dolio> Since that's essentially being lazy in proofs.
21:32:14 <copumpkin> well, the point here isn't to be 100% verified (as obviously we can have nonterminating proofs) but to simply help yourself out a bit
21:32:25 <MissPiggy> ise't the thing unsound to start with if it's TC?
21:32:40 <MissPiggy> or at least figuring out if a program in valid is uncompumtable
21:32:46 <dmwit> MissPiggy: Turing complete languages need not have TC type-checking.
21:32:49 <dolio> And 'coerce :: a :=: b -> a -> b ; coerce ~Refl x = x' is bad if you can fill in 'coerce undefined (5.0 :: Float) :: Int'.
21:33:53 <dmwit> MissPiggy: (Although a non-TC type-checker for a TC language will necessarily reject some programs that nevertheless would work properly if run.)
21:34:39 <dmwit> or allow some programs that would not work properly, I suppose
21:36:53 <MissPiggy> what's the best way to do one of those meta modules
21:36:56 <MissPiggy> it's just:
21:37:14 <MissPiggy> module Foo (A(..),a,B(..),b,b',...) where import A ; import B
21:37:17 <MissPiggy> is taht the best?
21:37:37 <dmwit> module Foo (A, B) where import A; import B
21:37:42 <dmwit> err
21:37:48 <dmwit> module Foo (module A, module B) where import A; import B
21:38:00 <MissPiggy> oh nice! thanks
21:41:34 <MissPiggy> this is great it is like I finally have a correct design so I just have to keep adding to it now
21:57:03 <copumpkin> debugging unary number types is a real pain in the butt
21:57:09 * copumpkin should write an error output postprocessor
21:57:23 <ddarius> copumpkin: You shouldn't use a unary number type.
21:57:28 <copumpkin> lol
21:57:49 <copumpkin> they're easier to work with than those binary type-level numbers
21:58:11 <dmwit> But less efficient, amirite!!
21:58:13 <ddarius> Well, you could make decimal type-level numbers, but yes, operations/proofs over them will be more tedious.
21:58:31 <ddarius> But the compiler -does- have to execute these type-level programs.
21:58:37 <copumpkin> yep
21:58:40 <MissPiggy> think of the compilers!
21:58:52 <ksf> copumpkin, use a list of Z000 ... Z999
21:58:58 <copumpkin> ugh no :P
21:59:21 <copumpkin> then I'd need epic autogenerated type families to do even the simplest of things
21:59:48 <ksf> ((Z100):.(Z000):.) would be 100000.
22:00:04 <ksf> which has the benefit that truly epic numbers are readable.
22:00:20 <copumpkin> and there would be half a million type instances just to express the ordering
22:00:46 <ksf> a thousand. plus the recursive cases.
22:00:47 <copumpkin> actually, way more than that
22:01:04 <copumpkin> ah yes
22:01:37 <dolio> I'm pretty sure people have run into problems with far fewer instances than that.
22:02:19 <MissPiggy> why can't you have that many instances?
22:02:30 <dolio> GHC chokes.
22:02:37 <MissPiggy> that's weird
22:02:40 <ksf> I think it'd still be faster than consing up a million S's to a Z
22:02:51 <MissPiggy> it must being using a vector with a TINY index size?
22:03:05 <dolio> The adaptive containers packages had to stop at fairly small tuples, as I recall.
22:03:06 <dmwit> No, I think it's just computationally expensive to deal with a lot of classes.
22:03:09 <ksf> the other possibility, of course, is to add machine-accelerated type naturals to ghc
22:03:18 <ddarius> dmwit: It shouldn't need to be.
22:03:35 <ddarius> ksf: Do it.
22:03:41 <ddarius> 3 :: Nat
22:03:53 <ddarius> :k 3
22:03:54 <lambdabot> Only unit numeric type pattern is valid
22:03:57 <dmwit> They already took the # kind, those jerks. =P
22:04:10 <copumpkin> :k 1
22:04:11 <lambdabot> *
22:04:16 <dmwit> It would be the perfect kind for accelerated type naturals. =)
22:04:18 <copumpkin> they don't even use it right!
22:04:21 <ksf> I'd only break the type checker and make spj frown in agony
22:04:28 <Johannes[iPhone]> How does Haskell compare in terms of speed to c
22:04:38 <copumpkin> Johannes[iPhone]: it's exactly 5.2 times faster
22:04:44 <ddarius> Johannes[iPhone]: Fast Haskell is faster than slow C.
22:05:11 <Zao> I have a feeling my codebase is moving in the wrong direction when every new compiler error I get suggests more and more extreme extensions.
22:05:14 <dmwit> There's the computer language shootout...
22:05:23 <ksf> the shootout is biased
22:05:28 <dmwit> Yep.
22:05:36 <Zao> In order of awesomeness, ExistentialQuantification, DeriveDataTypeable, ImpredicativeTypes.
22:05:37 <ddarius> Zao: If it is things like IncoherentInstances and UndecidableInstances, then I agre.
22:05:39 <dmwit> But it's a better comparison than either copumpkin's or ddarius'.
22:05:43 <copumpkin> :(
22:05:47 <MissPiggy> wow! ImpredicativeTypes??
22:05:54 <kamatsu> Zao: the first two are okay
22:05:55 <MissPiggy> what is that for
22:05:58 <copumpkin> MissPiggy: it's disappearing soon
22:06:06 <dolio> Zao: Is that increasing awesomeness, or decreasing?
22:06:06 <ksf> UndecidableInstances isn't as scary as it sounds
22:06:09 <Zao> MissPiggy: Smashing the kneecaps of the type system with a bat, judging by the docs.
22:06:09 <copumpkin> MissPiggy: Maybe (forall a. Moo a => a)
22:06:21 <ezyang> How do I copy a vector with one item changed?
22:06:25 <ddarius> ksf: Yes, but needing it usually suggests a problem unless you know what you are doing.
22:06:47 <ezyang> the functions in permutations seem to want to take lists of values to update...
22:06:49 <Zao> I do not quite know what I want anymore, heh.
22:06:57 <ddarius> ezyang: So you give a singleton list.
22:07:17 <ddarius> ezyang: Suffice to say, for immutable vectors, that operation isn't very sensible.
22:07:42 <ksf> ddarius, usually it just bogs down to a generic instance that noone in the right frame of mind would even consider implementing into the other direction
22:07:45 <ezyang> I actually want the copy with change semantics.
22:08:01 <ezyang> that is the correct behavior for my algorithm :-)
22:08:54 <copumpkin> WELL YOUR ALGORITHM IS BROKEN
22:09:06 <Zao> The last thing I attempted was    f :: T -> Maybe (forall t. SomeClass t => t)  inside   instance SomeClass T
22:09:13 <ezyang> MUAHAHAHA!
22:09:33 <MissPiggy> that is wild Zao
22:09:33 <MissPiggy> I can't even comprehend it
22:09:49 <Zao> While it seems legal assuming you throw enough extensions at it, I doubt I can avoid shooting myself in the foot somewhere down the line.
22:10:16 <Zao> I should probably not look too hard into the xmonad source, lest it looks back into me.
22:10:26 <ddarius> Zao: Except for ImpredicativeTypes, for which the idea is sound but GHC's implementation is a hack, all those extensions are fine.
22:10:47 <weilawei> Zao: bash.org'ed
22:10:57 <ezyang> How fast is vector concatenation?
22:11:39 <ddarius> For immutable vectors, I would say the sum of the lengths in general.
22:11:51 <ezyang> ok, that's fine.
22:12:17 <ddarius> ezyang: ... that's the worst time complexity conceivable without going out of one's way to waste time...
22:12:17 <weilawei> Zao: if it goes through, http://bash.org/?917156
22:13:01 <ezyang> ddarius: I'm checking my reference implementation, and it's also using the sum of length in time
22:13:01 <copumpkin> ezyang: but with fusion it's harder to say
22:13:18 <ezyang> I'm just hoping that I don't get spanked for memory allocation or something
22:13:21 <ksf> could be easily compiled down to O(0)
22:14:02 <copumpkin> I think these open type functions are going to be what kills this package, if anything
22:14:06 <ksf> ...at least with small vectors that more or less fit into the registers, that is.
22:22:09 <ezyang> infinite type error :-(
22:23:38 <MissPiggy> they take forever to fix
22:23:56 <ezyang> aha! found it
22:24:04 <ezyang> ok, now to see if this kaboodle works
22:24:40 <copumpkin> > forever fix
22:24:44 <lambdabot>   mueval-core: Time limit exceeded
22:24:48 <copumpkin> MissPiggy: I can see why
22:25:58 <ezyang> ok. I now need to generate large sets of keys and values to stuff in here hmmm
22:26:05 <dmwit> > fix (\_ -> ())
22:26:06 <lambdabot>   ()
22:26:09 <ezyang> sounds like a job for QuickCheck!
22:26:10 <dmwit> > fix (\() -> ())
22:26:13 <lambdabot>   mueval-core: Time limit exceeded
22:26:19 <dmwit> wacky
22:27:54 <monochrom> > fix (\ ~() -> () )
22:27:55 <lambdabot>   ()
22:28:54 <dmwit> forever is only really useful in one-offs
22:30:08 <Cale> dmwit: Why do you say that?
22:31:10 <dmwit> I was going to answer glibly that any non-one-off would need to exit. But there's always exitWith.
22:31:22 <ezyang> IntMap uses so many dirty performance tricks ^^
22:31:23 <dmwit> So I guess the best support I can give is that I've never seen it used in a non-one-off.
22:31:26 <Cale> dmwit: Also, it's rather useful along with forkIO
22:31:46 <ezyang> Time to start stealing code :o)
22:32:03 <Cale> forkIO . forever $ <some process which handles messages coming in on a Chan forever>
22:32:17 * ddarius uses forever a lot in concurrent code.
22:32:26 <dmwit> right
22:32:32 <dmwit> So, I take it back. =)
22:33:56 <_wsh> hello everyone :)
22:34:04 <Zao> This explains why my machine was feeling a bit sluggish. I had two runaway ghc processes.
22:34:25 <Zao> One with 3.4 GiB of resident memory, 4.8 GiB virtual.
22:34:35 <_wsh> quick question for all of you, if I may:  I'm working with HXT (weird bugger that it is), and I'm getting an unfamiliar parse error
22:34:41 <_wsh> namely, my code compiles when I remove this
22:35:05 <_wsh> but something, apparently, is invalid about my use of ->
22:35:54 <monochrom> HXT is not a weird bugger. I use it for real.
22:35:56 <copumpkin> if only Fin Z weren't empty
22:36:26 <ddarius> copumpkin: It isn't.
22:36:55 <_wsh> http://haskell.pastebin.com/d3f951696
22:37:08 <copumpkin> damn bottoms always get me comments about how things aren't true!
22:37:19 <ddarius> copumpkin: Bottoms make everything true!
22:37:35 <dmwit> _wsh: You probably just need parentheses.
22:37:36 <_wsh> monochrom:  it fetches the DTD from the web semi-invisibly, that's a bit weird in my book
22:37:43 <_wsh> @dmwit:  okay, will try :)
22:37:43 <lambdabot> Unknown command, try @list
22:37:48 <copumpkin> copumpkinGetLotsOfMoneyTomorrow = copumpkinWillGetLotsOfMoneyTomorrow
22:37:49 <copumpkin> yay
22:37:55 <_wsh> crap, twitter syntax
22:37:55 <copumpkin> damn, I even failed
22:38:17 <ddarius> copumpkin: You can fix it: copumpkinWillGetLotsOfMoneyTomorrow = copumpkinGetLotsOfMoneyTomorrow
22:38:20 <dmwit> _wsh: (around the outer proc to the final })
22:38:29 <copumpkin> ddarius: oh sweet, thanks
22:38:44 <_wsh> dmwit:  right, right.
22:39:21 <_wsh> it's now giving me "pattern syntax in expression context"
22:39:33 <_wsh> differential debugging, hooray :)
22:39:34 <_wsh> thanks.
22:40:03 * copumpkin is almost done writing transpose on his safe vectors! :P
22:40:07 * copumpkin weeps
22:40:20 <copumpkin> of course, the transpose is itself safe
22:41:04 <_wsh> :)
22:41:45 <weilawei> can anyone recommend books on category/set theory so that one might grok haskell on a deeper, more meaningful level than "hunh?"
22:42:26 <dmwit> TaPL is probably better than a category theory book for that.
22:42:26 <_wsh> Basic Category Theory for Computer Scientists by Benjamin Pierce
22:42:34 <_wsh> ...or there's that.
22:42:38 <dmwit> Types and Programming Languages
22:42:47 <_wsh> mm
22:42:48 <dmwit> ...also by Benjamin Pierce
22:42:56 <copumpkin> does he pay you to advertise that?
22:43:06 <Gracenotes> @where tapl
22:43:06 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
22:43:07 <dmwit> Well, he does pay me... =P
22:43:12 <copumpkin> I knew it!
22:43:12 <weilawei> dmwit: hrm i have safari and that;s on there.. so it's convenient
22:43:23 <weilawei> dmwit: in that event, is it any good?
22:43:35 <dmwit> I liked it a lot.
22:43:36 <_wsh> @dmwit:  you're at UPenn?
22:43:36 <lambdabot> Unknown command, try @list
22:43:37 <weilawei> i mean i can go read it right now.. but before I get deep into it
22:43:43 <dmwit> So much I went to grad school in that area. =)
22:43:46 <_wsh> :)
22:43:48 <copumpkin> lol
22:43:49 <ddarius> TaPL is/was an instant classic.
22:43:50 <_wsh> cool shit.
22:44:10 <Gracenotes> I have a copy in my room :D
22:44:27 <weilawei> Is that a seconding i hear?
22:45:13 <Gracenotes> there's a graduate class about programming languages that uses it. I get book finaid, so I procured a copy
22:45:24 <copumpkin> okay, I think this is not the friendliest of types: transposeVec :: ((n1 :+: S (n1 :*: n2)) ~ (m :*: n), Nat n1, Nat n2) => Vec m (Vec n b) -> Vec n1 (Vec (S n2) b)
22:45:34 <Gracenotes> I probably should have taken the class too. ah well.
22:45:49 <weilawei> Gracenotes: was it helpful?
22:46:01 <_wsh> Gracenotes:  where, if I might ask?
22:46:10 <Gracenotes> here at Stony Brook, NY
22:46:53 <dmwit> copumpkin: I would expect Vec m (Vec n b) -> Vec n (Vec m b); if you specialize, can the compiler prove the necessary type family equality?
22:47:07 <copumpkin> dmwit: nope :( I'm trying to get it to understand that
22:47:10 <Gracenotes> I read through some of TAPL a year ago. I'll be getting into it again soonish methinks.
22:47:10 <dmwit> bugger
22:47:24 <copumpkin> I may just give in and prove by intimidation
22:47:29 <copumpkin> was hoping to avoid it though :P
22:47:49 <dmwit> copumpkin: Actually, that type looks mighty strange.
22:47:50 <_wsh> oh fun
22:47:58 <dmwit> copumpkin: Is :*: type-level multiplication?
22:48:00 <copumpkin> yea
22:48:01 <_wsh> Gracenotes:  I know someone who just got his PhD in CS there
22:48:18 <dmwit> copumpkin: n1 :+: S (n1 :*: n2) -- looks like a bug
22:48:21 <copumpkin> dmwit: I'm not even sure it's correct yet because I haven't been able to call it yet :P
22:48:27 <Gracenotes> _wsh: what was the topc?
22:48:28 <copumpkin> yeah, good point
22:48:30 <copumpkin> oh wait
22:48:35 <copumpkin> not necessarily actually
22:48:35 <_wsh> Gracenotes:  self-healing systems
22:48:45 <copumpkin> it's just an expanded step of the recursive multiplication
22:48:58 <_wsh> at least, that's how I'd describe it in a catchphrase
22:48:59 <dmwit> S (S n1 :*: n2) -- is equivalent, and not looking better
22:49:05 <Gracenotes> _wsh: ooh. healing against.. uh, bit decay?
22:49:05 <copumpkin> yeah, true
22:49:29 <_wsh> Gracenotes:  actually, more like healing against component failure (software, not hardware)
22:49:35 <copumpkin> okay, iron fist
22:50:33 <dmwit> copumpkin: I bet you have a bug in your implementation of :*:.
22:50:50 <ddarius> weilawei: If you want some freely available things, this: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ and this: http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf are good.
22:50:59 <copumpkin> dmwit: could be :) type instance (:*:) (S m) n = n :+: (m :*: n)
22:51:00 <copumpkin> hmm
22:51:24 <copumpkin> nah, I think that's right
22:51:25 <dmwit> Well... that looks fine.
22:51:40 <dmwit> no wait
22:51:50 <_wsh> God, I feel so stupid asking this.
22:51:51 <dmwit> okay, fine
22:52:03 <_wsh> pattern syntax in expression context:  what the devil is wrong?
22:52:15 <ddarius> copumpkin: Would swapping the arguments to :+: on the right help?
22:52:26 <_wsh> even with a fairly simple returnA <- x it's cropping up
22:52:30 <copumpkin> ddarius: it might make it more pleasant to work with, you're right
22:53:18 <_wsh> oh my God, never mind.
22:53:28 <_wsh> it uses a pragma I've never heard of.
22:53:42 <_wsh> I swear, some of this really is black magic.
23:00:28 <Gracenotes> _wsh: I dropped out, my laptop overheated
23:00:36 <_wsh> Gracenotes:  oh dear.
23:00:38 <_wsh> irony.
23:00:59 <_wsh> I discovered the joy of weird pragmas
23:01:05 * copumpkin hugs generalized newtype deriving and standalone instances
23:01:49 <Gracenotes> It's been doing that lately.
23:01:50 <Gracenotes> It's taking every ounce of self-control not to find an electric screwdriver and install some new ports in the motherboard
23:01:51 <dmwit> Yeah, standalone instances really are an obvious win.
23:02:01 <Gracenotes> not like that'll solve the problem
23:02:08 <ddarius> Gracenotes: Maybe it needs maintenance...
23:02:18 <dmwit> You could clean or replace the fan.
23:02:49 <Gracenotes> I think that's the course of action. Last time I opened it up, though, I lost some screws.
23:02:51 <_wsh> what kind of processor is it?
23:03:18 <_wsh> slash I assume that's the component that's doing the overheating.
23:03:18 <Gracenotes> Intal x86, 2 CPUs
23:03:22 <_wsh> ah.
23:03:31 <_wsh> how's your thermal paste situation?
23:03:37 <Gracenotes> not certain
23:03:50 <dmwit> Just toss some eggs in there.
23:03:57 <dmwit> That way, next time it overheats, at least you'll have a meal.
23:04:02 <_wsh> early MacBook Pros were fucked up because of some poorly-applied paste
23:04:03 <_wsh> lulz.
23:04:14 <_wsh> dmwit:  I've considered making tea on mine.
23:04:15 <Gracenotes> when it shut down, it said 99 degrees C
23:04:31 <Gracenotes> that's just a bit scary if it's the case
23:04:39 <ddarius> My laptop never gets close to overheating.
23:04:45 <_wsh> >_>
23:04:59 <Gracenotes> _wsh: the self-healing systems, makes me think of http://en.wikipedia.org/wiki/Fault_tree_analysis - scroll down for the interesting logic tree
23:05:00 <ddarius> Boiling hot computer on your lap.
23:05:21 <Gracenotes> I'm glad it's not hydraulic then
23:05:26 <_wsh> Gracenotes:  that's really cool
23:05:48 <_wsh> the logic, that is
23:05:49 <ddarius> One of our servers claims to be getting up to > 90 degrees C, but I really think its a problem with the thermal sensor.
23:12:44 <enthymene> Gracenotes: yikes.  I've only every been as high as 79 on my Vostro 1500 (or so the sensors say)
23:19:56 <copumpkin> I realized I'm using the generic vector machinery wrong
23:20:03 <copumpkin> but too lazy to fix it tonight
23:22:33 <copumpkin> oh I guess this also reveals why concat isn't there
23:23:29 <dmwit> Is there a non-blocking getChar?
23:24:02 <dmwit> I guess polling isn't that hot a technology these days.
23:25:29 <Cale> dmwit: Yeah, the right way to do it is just to use a separate thread.
23:25:37 <dmwit> yep
23:30:11 <andersk> Is there a binding to fstat() that can be used on a Handle?
23:30:58 <dmwit> Oh, modify isn't in the MonadState class. =/
23:31:16 <andersk> System.Posix.Files has getFileStatus :: FilePath -> IO FileStatus, which is stat() and not fstat(), and getFdStatus :: Fd -> IO FileStatus, but AFAIK you can’t convert a Handle to an Fd without closing it in the process.
23:48:17 <copumpkin> okay, I'm getting pretty convinced that I'm either doing this wrong or the library isn't really designed for what I'm trying to do
23:49:25 <Hunner> @hoogle [a] -> Maybe a
23:49:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
23:49:25 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
23:49:26 <lambdabot> Prelude head :: [a] -> a
23:49:35 <p_l> enthymene: try playing a game on a laptop that has 96° ~ 99° C :)
23:51:55 * copumpkin stops hacking on that for the night
