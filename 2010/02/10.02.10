00:03:06 <mjrosenb> @pl \x -> x
00:03:06 <lambdabot> id
00:03:35 <mjrosenb> @pl do f <- foo; return f 3
00:03:35 <lambdabot> (line 1, column 12):
00:03:36 <lambdabot> unexpected ";"
00:03:36 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
00:03:43 <mjrosenb> didn't think so :(
00:04:15 <dolio> @. pl undo do f <- foo ; return f 3
00:04:15 <lambdabot> foo >> 3
00:12:41 <mreh> @pl \x -> f x x
00:12:41 <lambdabot> join f
00:15:41 <mjrosenb> @pl undo v <- foo; return (x, foo v)
00:15:41 <lambdabot> (line 1, column 14):
00:15:41 <lambdabot> unexpected ";"
00:15:41 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
00:15:44 <mjrosenb> @pl undo do v <- foo; return (x, foo v)
00:15:44 <lambdabot> (line 1, column 17):
00:15:44 <lambdabot> unexpected ";"
00:15:44 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
00:15:52 <mjrosenb> @. pl undo do v <- foo; return (x, foo v)
00:15:52 <lambdabot> ((,) x . foo) `fmap` foo
00:16:25 <mjrosenb> @. pl undo do v <- foo; return (x, bar v)
00:16:26 <lambdabot> ((,) x . bar) `fmap` foo
00:16:45 <Twey> (,) x . bar <$> foo
00:17:09 <mjrosenb> Twey: what module is <$> in?
00:17:14 <Twey> Control.Applicative
00:44:32 <Speedy1> www.search2.net
00:56:29 * kaol just uploaded ghc 6.12.1 to Debian unstable
01:02:46 <JoshTriplett> I want to build a Haskell library that wraps a C library via FFI.  The C library provides only a static libfoo.a, not a shared libfoo.so.  I can produce the wrapper, but it only works if I link the static C library into the final Haskell executable.  How can I link it into the Haskell static library instead, so that the user of the Haskell library doesn't need to know about the C library?
01:23:15 <Zeiris> I remember reading (possibly in RWH) that Double has the same performance as Float despite being twice as big.
01:23:20 <Zeiris> Is that strictly true?
01:23:23 <arman> hi. I'm using HXT. I would like to perform a fold over the children of a given node, but I can't seem to find any fold arrow. Am I missing something?
01:23:44 <theorbtwo> Zeiris: It's probably close, on an x86.
01:24:20 <theorbtwo> (The x86 doesn't support single floats, really.  It computes using it's internal form, then rounds it to a float.)
01:25:12 <Zeiris> Woah. Neat.
01:25:19 <Zeiris> But it does use half the memory?
01:25:34 <Dark_Shikari> of course.
01:25:50 <Trafalgard> It's just in the floating point stack that there's only one kind of floating point variable
01:25:50 <Dark_Shikari> it probably depends what instructions the compiler uses.  for example, sse double support wasn't added until sse2.
01:26:02 <Dark_Shikari> and x87 float is atrociously awful
01:26:24 <Trafalgard> yeah, sse2 floating point stuff doesn't use the x87 floating point stack at all
01:28:12 <Trafalgard> on an unrelated note, I'm attempting to profilesomething, and getting an infinite loop, but since the function that's doing it happens to be in the IO monad I put putStrLn lines in every | section of it, at the beginning. Apparently *they aren't running*
01:28:46 <Trafalgard> I don't see a way that the | conditions themselves could be triggering an infinite loop, unless doesFileExist has a bug
01:29:39 <Trafalgard> but is it possible that it's just not processing the putStrLn and going to get something else first, and getting locked there into the infinite loop, thus preventing me from seeing which part of the function it's going off in?
01:29:59 <Trafalgard> the profiling information, what little of it I've learned to use so far, is being decidedly useless
01:30:15 <Trafalgard> since it seems to be going <<loop>> and exiting almost immediately
01:33:13 <Trafalgard> Hmm. This could be causing a problem.
01:33:23 <Trafalgard> although you'd think the failsafe code would kick in.
01:33:42 <Trafalgard> maybe haskell is too fragile with the recursiveness that it can't handle 30 recursions before going kablam.
01:34:00 <Trafalgard> That doesn't seem likely though.
01:34:55 <harlekin> @hoogle Int -> a -> [a]
01:34:55 <lambdabot> Prelude replicate :: Int -> a -> [a]
01:34:55 <lambdabot> Data.List replicate :: Int -> a -> [a]
01:34:55 <lambdabot> Prelude drop :: Int -> [a] -> [a]
01:37:57 <Trafalgard> and doesDirectoryExist doesn't ... work... on directories above C:\ ? Gah. C:/.. is valid, it thinks. Oy vey. Hell, "C://.." is too... Not to be left out, so does "C://///........"
01:38:03 <Trafalgard> >_<
01:38:18 <Trafalgard> *facekeyboard*
01:38:41 <Trafalgard> no wonder it infinite looped.
01:39:20 <Trafalgard> it would have kept right on adding ../../..s until haskell exploded, or the failsafe inexplicably failed to trigger after 30 recursions
01:40:39 <fabjan> doesDirectoryExist "C://///........" returned True?
01:40:55 <int-e> maybe that was supposed to be C:/../../../../
01:41:12 <Trafalgard> yes, it did
01:41:22 <Trafalgard> I tried it just to see if it would
01:41:25 <Cale> Trafalgard: When you see <loop> that always means a verifiable infinite loop.
01:42:12 <Cale> Specifically, it means that during the computation of a variable, that variable's value was required.
01:42:12 <Trafalgard> Prelude System.FilePath System.Directory> doesDirectoryExist "C://///....."
01:42:13 <Trafalgard> True
01:42:36 <int-e> funny.
01:43:02 <Trafalgard> ("C://///.....WTF" and "C://///....../WTF" however, returned False)
01:43:08 <sahazel> how do I use the pointfree bot?
01:43:26 <Cale> @pl \f x y -> f y x
01:43:27 <lambdabot> flip
01:43:27 <fabjan> doesDirectoryExist "/../../"
01:43:27 <fabjan> True
01:43:37 <sahazel> hm
01:43:38 <fabjan> perhaps it's just filesystems being silly?
01:43:54 <fabjan> You can cd /../../../.. as well if you want to
01:43:57 <sahazel> @pl \(x, y) -> \(a, b) -> (x a, y b)
01:43:58 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
01:44:02 <sahazel> nice
01:44:38 <Trafalgard> well, dir c:\.. shows c:\, but dir c:\...... doesn't do a damn thing (though I knew that)
01:44:41 <Cale> The @pl plugin doesn't always give the nicest result
01:45:04 <Trafalgard> ... should be valid though
01:45:11 <mreh> @pl \(x, y) (a, b) -> (x a, y a)
01:45:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . liftM2 (,))
01:45:17 <Trafalgard> hm, it only went up one instead of two
01:45:38 * Trafalgard shrugs
01:45:59 <Trafalgard> maybe it was some other OS that had ... properly implemented to go up two
01:46:16 <mreh> you don't have to write everything in Pointsfree(/less) style
01:46:40 <Cale> On my system (Linux), the root directory contains entries for . and .. which both point back to the root directory.
01:46:40 <kalven> if I have 'data Foo = Bar | Baz | Zonk', is there some simple way of getting to an 'isBar' function? (that is, Foo -> Bool)
01:46:55 <mreh> kalven: use pattern matching
01:47:12 <kalven> ok, no shorthand?
01:47:13 <mreh> case x of Bar -> ... Baz -> ... Zonk -> ...
01:47:14 <Cale> kalven: If it's an instance of Eq, you can write (== Bar)
01:47:20 <Trafalgard> that being in C:\ as well could be why it's getting all confused, but it doesn't excuse thinking that c:////...... is valid
01:47:36 <mreh> it's not like Scheme where you have Bar? Baz? Zonk? already written for you
01:49:01 <mreh> kalven: elaborating on what Cale said data Foo = Bar | Baz | Zonk deriving (Eq)
01:49:25 <mreh> Can you drop the brackets when you only have the one type class in a deriving clause?
01:49:29 <mreh> like a type context
01:49:36 <Cale> sahazel: Just for reference, a nicer way to write that one would be  uncurry (***)
01:50:00 <kalven> right, thanks. my Bar, Baz etc actually have some additional stuff. I'll have to go with pattern matching I suppose
01:50:06 <kalven> thanks for the help
01:50:15 <mreh> kalven, what do you mean "additional"
01:50:18 <Cale> (\x -> case x of Bar {} -> True; _ -> False)
01:50:25 <mreh> they can derive more than one type class
01:50:29 <int-e> fabjan: "The special filename dot-dot shall refer to the parent directory of its predecessor directory. As a special case, in the root directory, dot-dot may refer to the root directory itself." (http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap04.html#tag_04_11)
01:51:06 <Cale> ^^ note that in the degenerate case of matching none of the parameters to the constructor, you're allowed to use record syntax when pattern matching to avoid having to write the appropriate number of blanks)
01:51:14 <int-e> "may". that can't be good for reliability.
01:51:20 <kalven> mreh: data Foo = Bar String | Baz Int, etc.
01:51:34 <mreh> kalven, see what Cale just wrote ^^
01:51:42 <mreh> do you know record syntax?
01:51:55 <fabjan> int-e: ah
01:52:12 <fabjan> heh, "may" :D
01:52:41 <Cale> Well, you don't need to know much about it here, just that the pattern  C {}  will match anything formed using the data constructor C.
01:52:48 <kalven> ah, that helps.
01:53:51 <kalven> partitionFields fields = [s | s@(Sequence {}) <- fields] ++ [m | m@(Member {}) <- fields]
01:53:54 <kalven> that is my actual code
01:56:32 <mreh> kalven: if Fields, or whatever the datatype is, derves Ord, you could do that with a sort
01:56:52 <mreh> it would be more efficient
01:56:57 <kalven> oh, would they get sorted in the order that they are specified in the data declaration?
01:57:15 <mreh> kalven: they would
01:57:27 <kalven> alright
01:57:31 <mreh> or you can specify how > < and == behave
01:57:40 <mreh> Ord assumes Eq IIRC
01:58:21 <mreh> @src Ord
01:58:21 <lambdabot> class  (Eq a) => Ord a  where
01:58:21 <lambdabot>     compare      :: a -> a -> Ordering
01:58:21 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
01:58:21 <lambdabot>     max, min         :: a -> a -> a
01:58:56 <kalven> in my case I don't want to change the relative order among Member fields, but it's good to know.
01:59:23 <tensorpudding> > compare "your beauty" "a rose"
01:59:24 <lambdabot>   GT
01:59:33 <tensorpudding> how poetic
02:00:07 <mreh> > compare "Yates" "Haskell"
02:00:08 <lambdabot>   GT
02:00:45 <tensorpudding> > compare "Haskell" "Ocaml"
02:00:46 <lambdabot>   LT
02:00:51 <mreh> d'oh
02:01:02 <tensorpudding> > compare "Haskell" "Java"
02:01:03 <lambdabot>   LT
02:01:24 <Dark_Shikari> > compare "Haskell" "Brainfuck"
02:01:25 <lambdabot>   GT
02:01:29 <Ke> !
02:01:40 <mreh> it's like those love match calculators, we all know it's an algorithm based on the letters
02:02:32 <tensorpudding> @src compare :: String -> String -> Ordering
02:02:32 <lambdabot> Source not found.
02:02:35 <tensorpudding> doh
02:02:43 <tensorpudding> @src compare String
02:02:43 <lambdabot> Source not found. :(
02:03:12 <Cale> The instance for Char is builtin, and the instance for lists is derived.
02:03:25 <tensorpudding> hmm
02:03:25 <Cale> (and there is no instance of Ord for String specifically)
02:04:14 <pozic> I get ProgramName: <<loop>>. Is there a way to get a constructive proof of this loop?
02:04:43 <pozic> Or in layman terms, just a trace of all the interacting parts of this loop?
02:04:51 <sahazel> @pl \a -> let b = words a; c = drop 1 b in (take 1 b, c, unwords c)
02:04:51 <lambdabot> ap ((`ap` unwords) . (,,) . take 1) (drop 1) . fix . const . words
02:04:56 <mreh> > compare 'a' 'z'
02:04:57 <lambdabot>   LT
02:05:01 <sahazel> that is just a hoot
02:05:02 <mreh> > compare 'A' 'z'
02:05:02 <lambdabot>   LT
02:05:07 <mreh> huh?
02:05:22 <Cale> pozic: It can be pretty tricky to get a meaningful explanation.
02:05:36 <mreh> > compare 'Z' 'a'
02:05:37 <lambdabot>   LT
02:06:07 <Cale> pozic: But you might try compiling with -prof -auto-all, and then +RTS -xc
02:06:14 <Cale> (on the commandline to your program)
02:08:34 <IceDane> I've decided to attempt to write a brainfuck interpreter. What would be an optimal way of imitating arrays as they work in C? o.o
02:09:23 <pozic> IceDane: imitating? You have actual mutable arrays in Haskell.
02:09:31 <pozic> IceDane: just as real as in C.
02:09:52 <IceDane> pozic: I didn't know. What do I need to import?
02:09:56 <pozic> IceDane: if you want to write slow code you can always use Data.Map to fake memory.
02:10:06 * hackagebot upload: formlets 0.7 - Formlets implemented in Haskell (ChrisEidhof)
02:10:26 <pozic> IceDane: Something which implements MArray.
02:11:17 <IceDane> Thanks =)
02:11:22 <pozic> IceDane: if you have the documentation installed, you should be able to find a suitable type then.
02:11:30 <pozic> IceDane: STArrays are nice.
02:13:17 <pozic> Cale: how am I supposed to understand the output format? I get <x,y,z><a,b,c> and that about 20 times.
02:14:18 <Cale> pozic: It's a "cost centre stack", which should give you some idea where the thing is happening in your code.
02:14:36 <Cale> (you should recognise those identifiers, hopefully)
02:15:17 <pozic> Cale: I understand the identifiers. I just don't understand the meaning of the '<' and '>' characters.
02:16:03 <Cale> I don't recall seeing more than one bracketed group of identifiers before.
02:16:55 <pozic> Cale: actually, it is <x,y,z>*.
02:17:06 <pozic> Cale: so, the same group repeatedly displayed.
02:17:18 <jlouis> pozic: call stack
02:17:26 <ksf> can anyone smack me with a continuation?
02:17:47 <ksf> in particular, with a shift from Control.Monad.Indexed.Cont whose i doesn't escape
02:18:17 <ksf> (which is the only thing I was able to make it do when not ignoring the continuation alltogether)
02:18:39 <pozic> jlouis: the question is why the repetition is there.
02:19:06 <pozic> jlouis: if it would be a loop, sane output would just report the loop.
02:20:20 <JoshTriplett> IceDane: Ideally you want either an STUArray or an IOUArray.
02:20:38 <JoshTriplett> IceDane: Those should prove exactly as efficient as a C array.
02:21:24 <ksf> IceDane, http://killersmurf.blogspot.com/2009/11/typefuck.html
02:21:27 <pozic> JoshTriplett: are you sure there are no GC issues with those?
02:21:47 <pozic> JoshTriplett: it was my understanding that even for unboxed arrays there is some RTS cost.
02:22:13 <pozic> It would be nice if all the bad parts of the RTS were documented.
02:23:38 * ksf wonders whether the forall in shift :: (forall i. (a -> m i i o) -> m r j j) -> m r o a should actually be in front of the a ->
02:23:44 <JoshTriplett> pozic: The usual cost of running any Haskell code.  But in general using a UArray just creates a contiguous memory region and accesses it as such, and the GC only comes into play insofar as it figures out when you no longer reference the entire array, not for references to the individual elements.
02:23:58 <IceDane> ksf: That is way over my head
02:24:18 <IceDane> I have no clue what I'm doing right here and now. I don't need to go somewhere else and have no idea there as well
02:24:22 <JoshTriplett> ksf: Given scoping, you *could* move it inward.
02:24:34 <JoshTriplett> ksf: Whether you want to seems like a question of taste.
02:25:03 <ksf> IceDane, if you look at the source, it's all plainly functional without magic
02:25:14 <ksf> ...it should be easy to translate to the value level, that is.
02:26:10 <JoshTriplett> I want to build a Haskell library that wraps a C library via FFI.  The C library provides only a static libfoo.a, not a shared libfoo.so.  I can produce the wrapper, but it only works if I link the static C library into the final Haskell executable.  How can I link it into the Haskell static library instead, so that the user of the Haskell library doesn't need to know about the C library?
02:38:57 <RayNbow> @ask Cale could you explain the intuition behind flip :: Functor f => f (a -> b) -> (a -> f b) in Caleskell?
02:38:57 <lambdabot> Consider it noted.
02:39:57 <int-e> f x = (r -> x) ... r -> a -> b ==> a -> r -> b
02:40:23 <int-e> so basically the same as with (.) === fmap
02:41:28 <RayNbow> int-e: I know that (e ->) is a functor, and for that particular instance I have an idea what flip does
02:41:57 <RayNbow> but what is flipped for other functors?
02:42:44 <tensorpudding> flip (Just (+5)) $ 3
02:42:48 <tensorpudding> err
02:42:51 <tensorpudding> > flip (Just (+5)) $ 3
02:42:52 <lambdabot>   Just 8
02:46:17 <Beelsebob> damn it, I want the Maybe monad in Objective-C
02:46:17 <Beelsebob> :(
02:46:17 <tensorpudding> looks like flip fmap ($)
02:46:28 <tensorpudding> @type flip fmap ($)
02:46:29 <lambdabot> forall b a b1. ((a -> b1) -> b) -> (a -> b1) -> b
02:46:30 <Cale> RayNbow: The order of the (e ->) and f functors is flipped.
02:46:30 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
02:46:46 <tensorpudding> hmm
02:47:02 <tensorpudding> @type flip (fmap ($))
02:47:03 <lambdabot> forall a b a1. a1 -> (a1 -> a -> b) -> a -> b
02:47:11 <tensorpudding> still not it
02:47:37 <tensorpudding> wait, right, wrong flip
02:47:50 <RayNbow> :t \a -> fmap ($ a)
02:47:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
02:48:11 <RayNbow> :t \f a -> fmap ($ a) f
02:48:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
02:48:13 <tensorpudding> @type (\f -> \x y -> f y x) (fmap ($))
02:48:14 <lambdabot> forall t a b. (Functor ((->) t)) => t -> (t -> a -> b) -> a -> b
02:49:06 <RayNbow> Cale: but what is "the order" for functors other than (e ->)?
02:49:27 <Cale> The order of application to the type parameter.
02:50:13 <tensorpudding> @type (<*>)
02:50:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:50:20 <tensorpudding> not quite the same
02:50:33 <tensorpudding> @hoogle f (a -> b) -> a -> f b
02:50:33 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
02:50:33 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
02:50:33 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
02:50:49 <pozic> I require essentially a LazyMonadST, in the same way as that stateful-mtl has a MonadST, but it seems to be a very bad idea.
02:50:51 <ksf> *Main> runIxCont_ $ sprintf( return "The value of " ^ fmt id ^ return " is " ^ fmt show)  $$ "x" $$ 3
02:50:51 <ksf> "The value of x is 3"
02:50:54 <Cale> If you'll permit me to use . for type-level composition,  f . (a ->)  becomes  (a ->) . f
02:51:30 <pozic> Is there another MonadST like library, which does work for everything?
02:52:01 <RayNbow> Cale: ah, now I see
02:52:04 <RayNbow> thx :)
02:52:39 <ksf> @tell edwardk If I'm not mistaken, the type of shift in  Control.Monad.Indexed.Cont should be ((forall i. a -> m i i o) -> m r j j) -> m r o a instead of (forall i. (a -> m i i o) -> m r j j) -> m r o a. otherwise, it's quite hard indeed to use the continuation without having i escape
02:52:40 <lambdabot> Consider it noted.
02:53:23 <ksf> edwardk _is_ the same as edward kmett, isn't he?
02:53:34 <pozic> ksf: or he is a very good impersonator.
02:53:56 <ksf> so he's at least isomorphic.
02:55:41 <Zeiris> I installed the Haskellmode vimball and have :filetype plugin on, but can't use _ct or _t. Any ideas why?
02:59:59 <pozic> Is there a RefMonad with a complete implementation somewhere? That is instances for lazy and strict ST monads?
03:07:18 <Zeiris> Is there some trick to getting GHCI to search . for modules you're trying to load?
03:09:18 <pozic> Zeiris: that is called a search path and it is a bad idea to depend on that.
03:09:55 <pozic> Zeiris: it creates non-portable code.
03:10:34 <Zeiris> Isn't it normal to include a module in the same directory from another module, though?
03:10:53 <Zeiris> What with most semi-large projects belonging in multiple files and all.
03:11:19 <pozic> Zeiris: you use cabal for that.
03:11:54 <Zeiris> Oh dear. Just a few minutes ago I thought "well, at least I can put off learning about cabal for a while".
03:12:08 <pozic> Zeiris: you can. Just use the search path feature.
03:18:37 <osaunders> I think LYAH could do with some better cacheing HTTP headers.
03:19:10 <osaunders> If you keep switching from the links in the contents to the same chapter (same HTML page) it loads it afresh each time.
03:22:42 <Zeiris> So does this mean that when developing a multi-file Haskell project, cabal is inserted into the code-test-code loop?
03:23:35 <blueonyx> hi, is there some "unconcat" which gives "string" -> ["s","t",..]?
03:23:55 <blueonyx> > map (:[]) "string"
03:23:55 <lambdabot>   ["s","t","r","i","n","g"]
03:24:00 <blueonyx> thy
03:28:19 <Zeiris> This is insane. I do not understand why a two-file project works fine on Windows, but keeps failing to import the second file into the main one on Linux.
03:29:16 <int-e> Zeiris: linux file names are case sensitive - maybe that's why?
03:30:14 <Zeiris> Aah. It's always the simple ones that get me :(
03:32:28 <osaunders> I wanted to define this:
03:32:29 <osaunders> class Named a where name :: a -> String
03:32:34 <pozic> Zeiris: for a well-designed project, you can always load it into ghci with just one command without any cabal madness.
03:32:41 <osaunders> But it's not possible is it?
03:33:13 <osaunders> I wanted to have a common interface for datas that have names.
03:33:18 <int-e> osaunders: that looks fine. how did you try it?
03:33:21 <pozic> osaunders: I don't see why not.
03:33:42 <pozic> osaunders: the problem with these things is that it won't work for data types that have effects.
03:34:07 <mreh> what sections do I need if I want to use cabal to manage a build?
03:34:15 <osaunders> I want the name to be part of the data structure.
03:34:24 <mreh> sections in a .cabal file that is
03:34:24 <pozic> osaunders: instance Named (IO Int) won't work, for example.
03:34:27 <osaunders> the type class doesn't actually add any data.
03:35:11 <mreh> you can't implement Name (IO Int)
03:35:28 <int-e> osaunders: hmm, then it's modeled wrong, and it should be a data type like  data Named a = Named { name :: String, contents :: a }
03:35:29 <osaunders> pozic: That's ok with me.
03:35:29 <mreh> or rather IO _ -> String
03:35:33 <Trafalgard> okay, so the infinite loop I'm getting is here: (doesFileExist ("somefilenamehere")) == return True
03:36:00 <Trafalgard> Any idea why that would do it?
03:36:20 <Trafalgard> doesFileExist returns an IO Bool
03:36:37 <mreh> Trafalgard, if you're in IO monad, bind the result of doesFileExist to a value and then do the comparison
03:36:42 <int-e> that shouldn't loop. it should give a compile error (no instance Eq for (IO Bool))
03:36:52 <Trafalgard> I'm in an | block
03:36:55 <osaunders> int-e: Ah yeah, I see now.
03:37:12 <Trafalgard> It did.
03:37:12 <Trafalgard> instance Eq (IO Bool)
03:37:15 <osaunders> int-e: I sort of wanted the typeclass to put the name bit in for me :-)
03:37:18 <Trafalgard> Now it doesn't.
03:37:19 <mreh> Trafalgard, == True is tautologous anyway
03:37:32 <mreh> True == True = True
03:37:32 <Trafalgard> I went "oooh, magic."
03:37:43 <int-e> Trafalgard: great. that's where the loop is: a == b = not (a /= b) and a /= b = not (a == b), as default methods.
03:37:43 <mreh> False == True = False
03:37:49 <Axman6> @check (== True) == id
03:37:49 <lambdabot>   No instance for (GHC.Classes.Eq (GHC.Bool.Bool -> GHC.Bool.Bool))
03:37:50 <lambdabot>    arisin...
03:37:51 <Trafalgard> what what?
03:37:52 <mreh> \a -> a == True = a
03:38:25 <mreh> @pl \a -> a
03:38:25 <lambdabot> id
03:38:46 <Trafalgard> It's 6:38 AM and you completely lost me
03:38:55 <mreh> ;)
03:39:18 <int-e> Trafalgard: There really can't be a meaningful instance Eq (IO Bool).
03:39:19 <Trafalgard> because I'm getting a bit tired
03:39:25 <mreh> comparing a boolean to True is the "identity function"
03:39:32 <mreh> for booleans
03:39:36 <theorbtwo> Trafalgard: False == True is False.  True == True is True.  (==True) always just returns it's argument unchanged (or is a type error).
03:39:51 <Axman6> @check \a -> (a == True) == a
03:39:51 <lambdabot>   "OK, passed 500 tests."
03:39:58 <Trafalgard> The problem was it was an IO Bool and I didn't know how to take it out of IO inside a | = thing
03:39:59 <int-e> mreh: return True  and  True  are not equivalent1
03:40:00 <int-e> !
03:40:27 <theorbtwo> Whoops, I should have used the word "returns" either, should I have...
03:40:29 <Trafalgard> right
03:40:31 <mreh> int-e: apart from the glaring type error, there is an error in his thinking elsewhere :)
03:40:38 <Trafalgard> return True puts it into the IO monad
03:40:48 <mreh> Trafalgard: yes
03:40:53 <int-e> Trafalgard: do  e <- doesFileExist "blah"; if t then {- file exists -} return "Yes" else {- doesn't -} return "No"
03:40:59 <Trafalgard> which is what the return value from doesFileExist is
03:41:11 <mreh> Trafalgard: you're getting it
03:41:18 <Trafalgard> I was; it used ridiculous amounts of memory
03:41:26 <Trafalgard> so I rewrote it with |s instead
03:41:51 <mreh> how could that snippet use so much memory?
03:41:53 <Trafalgard> Don't ask me why it did, that was all it did
03:42:02 <Trafalgard> well
03:42:15 <Trafalgard> it recursed upward checking for that file existing in each directory above it
03:42:34 <Trafalgard> I figured the compiler was failing to optimize it because of the if statement or somesuch
03:42:44 <mreh> Trafalgard, exponential memory usage?
03:42:48 <Trafalgard> yeah
03:43:30 <Trafalgard> my world for memory management more like java or c# combined with the rest of haskell
03:44:05 <mreh> what it is, is all the recursive calls being saved on the stack
03:44:30 <mreh> this is the kind of thing that can't be tail call optimised
03:44:31 <int-e> btw, the | = thing is called a guard.
03:44:36 <Trafalgard> I attempted to use $! and it had no effect whatsoever, either
03:44:44 <mreh> Trafalgard, it wouldn
03:45:15 <Trafalgard> Would it already be getting evaluated because of the return or <-s?
03:45:36 <mreh> I'm not sure, they always talk about IO monad being strict
03:45:37 <Trafalgard> (if it had dos and <-s and such)
03:46:09 <Trafalgard> almost this entire program is written in the IO monad, since it uses regexes and files so much
03:46:15 <Trafalgard> it seems rather infecty
03:46:24 <int-e> would it evaluate what exactly?
03:46:39 <int-e> return foo   doesn't evaluate foo.
03:46:44 <pozic> Trafalgard: only a tiny fraction of most programs run in the IO monad.
03:47:04 <Cale> Trafalgard: I don't see what regexes have to do with IO
03:47:07 <int-e> in IO (and strictly speaking evaluating it would go against the monad laws)
03:47:08 <pozic> Trafalgard: the only things required are system calls.
03:47:28 <pozic> Trafalgard: and calls to libraries written in other languages.
03:47:34 <int-e> strictly.
03:47:48 <pozic> Trafalgard: everything else is programmer lazyness.
03:48:02 <Trafalgard> I'm using regex-pcre-builtin
03:48:02 <pozic> (which depending on the circumstances can be a good thing)
03:48:11 * int-e attempts to glare at himself but only manages to roll his eyes.
03:48:23 <Trafalgard> the compile, execute, regexec, etc, functions are all IO functions
03:48:57 <pozic> Trafalgard: and you use these functions because you need "extreme performance"?
03:49:07 <Cale> Trafalgard: why would you use that library?
03:49:34 <Cale> (rather than regex-pcre)
03:49:34 <mreh> portability?
03:49:35 <Trafalgard> because I wanted more controllable regexes
03:49:45 <Trafalgard> and portability
03:49:56 <Cale> .oO(Why would you want regexes?)
03:50:09 <Trafalgard> (the first for the reason for it rather than the standard non-perl regexes)
03:50:32 <Cale> portability?
03:50:52 <Trafalgard> and I've forgotten most of my original reasons by now
03:51:04 <Trafalgard> Oh yes.
03:51:11 <Trafalgard> I can just tell cabal to install it and it Just Works.
03:51:30 <ksf> if haskell is an academic language, how come all those papers I'm currently looking at use ocaml?
03:51:48 <Cale> O'Caml is also an academic language?
03:52:15 <mreh> Uhh, it's used in academia, that's about all that is academic about it
03:52:39 <Cale> (How could it be any more academic than that?)
03:52:41 <Saizan> ksf: staged interpreters?
03:52:43 <int-e> you'd be astonished at the number of academic papers dealing with more mundane languages like Java ;)
03:52:49 <ksf> Saizan, shift/reset
03:52:58 <mreh> I'm looking at the Cabal documentation and seeing a long path stretching ahead of me
03:53:02 <mreh> I feel queezy
03:53:06 <ksf> well scheme also appears
03:53:26 <Saizan> mreh: a long path where you rewrite it?:)
03:53:39 <ksf> ...and examples like http://chneukirchen.org/blog/archive/2005/04/shift-reset-and-streams.html are quite wholly nonsensical when translated to haskell
03:53:43 <mreh> Saizan: no
03:53:51 <mreh> does it require rewriting?
03:54:09 <mreh> I just want to use cabal to build my project, not distribute it
03:54:44 <Saizan> well, it may require some additions
03:54:45 <mreh> and Haddocks
03:54:46 <int-e> Cale: clearly the only reason to use pcre is "regular expression" like ^(..+)\1+$ [matching strings of composite length] ;-)
03:54:51 <ksf> setting up cabal is quite quick
03:54:59 <Saizan> yeah
03:55:04 <mreh> people laughing the library is soooo annoying
03:55:17 <ksf> basically, touch project.cabal
03:55:29 <ksf> ...then do cabal install and fix what it complains about
03:55:38 <mreh> ksf, sweet, i'll do that now
03:56:00 <Saizan> with a recent cabal-install you can use cabal init
03:56:01 <mreh> ksf, cabal install? I don't want to install it
03:56:04 <int-e> Cale: err. not quite, I should not use '.' but a fixed character instead. sorry.
03:56:11 <ksf> ...then do cabal build
03:56:18 <mreh> yeah, that one!
03:56:19 <Saizan> cabal configure first
03:56:27 <ksf> and do try cabal sdist
03:56:50 <Saizan> "cabal init" should be the first start
03:58:21 <mreh> I've made the cabal file already
03:58:42 <mreh> well, I'll init anyway to get a minimum functioning file
03:58:49 <mreh> I hope it's nothing like xorgconfig
03:58:52 <mreh> zzz
04:01:00 <mreh> can I specify to build both a library and an executable?
04:01:09 <dschoepe> mreh: yes
04:01:14 <mreh> What does the package build:
04:01:15 <mreh>    1) Library
04:01:15 <mreh>    2) Executable
04:01:15 <mreh> Your choice? 12?!?!
04:01:31 <Saizan> maybe init doesn't support that, but you can
04:01:47 <mreh> good good
04:01:48 <Saizan> so, i'd pick Library and add Executable by hand later
04:02:00 <mreh> okay
04:04:01 <osaunders> :i Ratio
04:04:12 <osaunders> :t Ratio
04:04:13 <lambdabot> Not in scope: data constructor `Ratio'
04:04:21 <osaunders> > 3 % 4
04:04:22 <lambdabot>   3 % 4
04:04:30 <osaunders> > :t 3 % 4
04:04:31 <lambdabot>   <no location info>: parse error on input `:'
04:04:36 <osaunders> > :t (3 % 4)
04:04:36 <lambdabot>   <no location info>: parse error on input `:'
04:04:42 <osaunders> :t (3 % 4)
04:04:43 <lambdabot> forall t. (Integral t) => Ratio t
04:04:50 <ksf> but cabal still doesnt' seem to properly support executables depending on a lib in the same .cabal
04:05:03 <Saizan> it does since 1.8
04:05:22 <ksf> ...which then makes it compile everything four times.
04:05:44 <Saizan> yeah, that was the main reason for supporting it :)
04:06:23 <Saizan> not sure how well cabal-install deals with this new feature though
04:06:37 <ksf> not at all, it seems
04:07:44 <ksf> it's also an ghc issue. I bet it could spew out .o ,_p.o and _dyn.o whithout parsing every source file thrice.
04:08:09 <Saizan> well, it'll still need to compile once for normal and once for profiling
04:08:18 <mreh> how can I store the version number of my program in a manageable way? Cabal run a preprocessor and replace a tag with the current version number?
04:08:32 <Saizan> but at least you won't compile the library modules twice for each
04:08:35 <mreh> a tag in the source
04:08:58 <Saizan> mreh: you can import Paths_yourpackagename
04:09:22 <ksf> between .o and _dyn.o I guess the main difference is PIC code, which appears to be the domain of the codegen
04:09:34 <mreh> Saizan: is that some kind of GHC preprocessor magic?
04:09:43 <ksf> dunno where in the pipeline profiling stuff gets inserted
04:10:09 <Saizan> mreh: no, it's a module created by Cabal
04:10:18 <ksf> mreh, look at dist/build/autogen after configuring
04:10:26 <Saizan> after build, actually
04:16:18 <mreh> cabal: HEtude.cabal:51: Construct not supported at this position: F 51 "main-is" "./Main.hs"
04:16:20 <mreh> huh?
04:16:31 <mreh> I dropped the ./ and it still doesn't work
04:16:49 <Saizan> is it inside an Executable section?
04:16:50 <mreh> I haven't specified hs-source-dirs, which defaults to "."
04:17:19 <mreh> does it need to be indented to be "inside"?
04:17:24 <Saizan> yes
04:26:20 <FliPPeh> Say I have the type "IO (Either Error String)", and I want to create a recursive function that receives lines from a socket and stores them in the String part of that type, building up the total received input
04:26:24 <FliPPeh> How'd I do it?
04:26:41 <FliPPeh> liftM (++ stuff) $ Right result ?
04:26:59 <FliPPeh> > liftM (++ "Hi") $ Right ""
04:27:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:27:00 <lambdabot>    `GHC.Show.Show a'
04:27:00 <lambdabot>      a...
04:27:10 <FliPPeh> > liftM ((++) "Hi") $ Right ""
04:27:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:27:11 <lambdabot>    `GHC.Show.Show a'
04:27:11 <lambdabot>      a...
04:27:17 <FliPPeh> > liftM ("Hi" ++) $ Right ""
04:27:19 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:27:19 <lambdabot>    `GHC.Show.Show a'
04:27:19 <lambdabot>      a...
04:27:51 <FliPPeh> :t liftM
04:27:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:28:26 <FliPPeh> > mapM (toUpper) $ Right "fff"
04:28:27 <lambdabot>   Couldn't match expected type `m b'
04:28:28 <lambdabot>         against inferred type `GHC.Types...
04:28:35 <FliPPeh> > mapM (toUpper) (Right "fff")
04:28:36 <lambdabot>   Couldn't match expected type `m b'
04:28:36 <lambdabot>         against inferred type `GHC.Types...
04:28:39 <FliPPeh> Why do you hate me? :(
04:28:53 <Axman6> :t mapM
04:28:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:28:55 <Axman6> :\
04:29:09 <zygoloid> @hoogle ErrorT
04:29:09 <lambdabot> Control.Monad.Error newtype ErrorT e m a
04:29:10 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
04:29:10 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
04:29:17 <Saizan> > fmap (map toUpper) (Right "fff")
04:29:18 <lambdabot>   Right "FFF"
04:29:18 <FliPPeh> > mapM (\x -> Right $ toUpper x) (Right "fff")
04:29:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:29:19 <lambdabot>         against inferred ty...
04:29:37 <Saizan> FliPPeh: the second argument of mapM needs to be a _list_
04:29:40 <mreh> fmap = liftM?
04:29:42 <FliPPeh> Mh
04:29:44 <Saizan> not a list wrapped in something
04:29:48 <Saizan> mreh: yeah
04:29:49 <FliPPeh> You're right
04:29:56 <mreh> for Monads
04:30:03 <FliPPeh> > mapM (\x -> Right x) [1..4]
04:30:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:30:04 <lambdabot>    `Control.Monad.Error.Cla...
04:30:16 <FliPPeh> > mapM Right [1..4]
04:30:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:30:17 <lambdabot>    `Control.Monad.Error.Cla...
04:30:20 <FliPPeh> Oh man
04:30:34 <Saizan> > mapM Right [1..4] :: Either String Int
04:30:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:30:35 <lambdabot>         against inferred type ...
04:30:40 <Saizan> > mapM Right [1..4] :: Either String [Int]
04:30:41 <mreh> > map Right [1..4]
04:30:41 <lambdabot>   Right [1,2,3,4]
04:30:42 <lambdabot>   [Right 1,Right 2,Right 3,Right 4]
04:30:55 <Trafalgard> soooo... if I can't guarantee the order of operation of anything
04:31:11 <mreh> :t Right
04:31:12 <lambdabot> forall b a. b -> Either a b
04:31:14 <mreh> it's a function
04:31:24 <mreh> Right is a function from a value to Either
04:31:30 <Saizan> Error e => Either e is a monad
04:31:33 <Trafalgard> I can't guarantee that this is going to create these folders, which it doesn't seem to be doing, before it attempts to copy files into them, which it is completely failing to do due to the lack of existance of said folders
04:31:58 <Saizan> Trafalgard: "this" being?
04:32:05 <Trafalgard> program.
04:32:10 <Trafalgard> function.
04:32:11 <Saizan> why can't you?
04:32:12 <Trafalgard> etc.
04:32:21 <mreh> oh I see what you were doing
04:32:24 <Trafalgard> I suppose I could make a completely ridiculously unnecessary hack.
04:32:44 <Saizan> order of side effects is guaranteed by the IO monad
04:32:51 <Saizan> unless you use unsafeInterleaveIO
04:32:56 <Trafalgard> and make the functions to make the folders return some junk variables which are passed to the functions to function to copy the files.
04:33:03 <Trafalgard> oh?
04:33:11 <Trafalgard> then this isn't happening for some *other* reason?
04:33:14 <Saizan> no need to do something like that
04:33:22 <Saizan> Trafalgard: yeah, most likely
04:33:30 <Trafalgard> okay.
04:33:44 <Saizan> you could paste the code
04:33:51 <int-e> @paste
04:33:51 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:33:55 <Trafalgard> I think I'm just going to go to sleep for now
04:34:08 <Trafalgard> it's morning by now
04:34:23 <mreh> staying up all night to do Haskell
04:34:23 <Saizan> heh, ok :)
04:34:33 <Trafalgard> yep.
04:34:38 <Trafalgard> Night
04:34:40 <mreh> the best Haskell happens around 2am
04:35:10 <mreh> uuh... is it a requirement for a module name to be fully qualified in relation to its pacakge?
04:35:47 <FliPPeh> So back to my previous question
04:35:54 <FliPPeh> Say I have the type "IO (Either Error String)", and I want to create a recursive function that receives lines from a socket and stores them in the String part of that type, building up the total received input
04:35:59 <FliPPeh> :/
04:36:09 <mreh> :t Error
04:36:10 <lambdabot> Not in scope: data constructor `Error'
04:36:33 <mreh> why have you got the type IO...?
04:36:48 <FliPPeh> Because it's a socket
04:36:56 <mreh> oh, I see
04:37:12 <FliPPeh> Well
04:37:21 <FliPPeh> I don't need to accumulate the result all at ones
04:37:24 <FliPPeh> Just noticed
04:37:53 <FliPPeh> I'll just write a function that reads a block and returns it as a normal list, and do a "liftIO $ readBlock" in my other Monad
04:38:14 <mreh> does this function keep retuning Right "blah" until there are no more packets left?
04:38:21 <mreh> heh, left
04:38:34 <FliPPeh> Nope
04:38:39 <FliPPeh> Left is reserved for other errors
04:39:02 <FliPPeh> Like "Left MPDACKERROR"
04:39:13 <mreh> I see
04:40:09 <mreh> so it looks like it listens on this socket, blocking until something comes in?
04:40:11 <mreh> correct?
04:40:58 <mreh> I don't see how you can accumulate anything from a list that doesn't end
04:41:30 <FliPPeh> mreh: It does end
04:41:48 <FliPPeh> MPD will send a list of key value pairs, and a single "OK" on it's own line on success
04:41:53 <mreh> oh, okay
04:41:57 <FliPPeh> Or "ACK [x@x...]" on error
04:41:59 <FliPPeh> It will end :)
04:42:14 <mreh> it would be easier to pattern match if the type were "IO (Either Error (Maybe String))
04:42:18 <mreh> did you write this listener?
04:42:43 <FliPPeh> I've "written" everything so far, I'm using the older MPD lib to get the basic structure
04:42:53 <FliPPeh> Simple rewrite, the old one stopped working
04:43:52 <mreh> well write a recursive function, the base case is when the string that matches "OK", unless you rewrite in the style I suggested
04:44:19 <mreh> stack recursive style
04:44:46 <mreh> constructing a list as you recurse, or accumulator style for efficiency, however you like
04:44:57 <FliPPeh> :)
04:45:14 <mreh> It's all up to you!
04:45:15 <FliPPeh> And some other thing interests me
04:46:00 <FliPPeh> I have this line here: "runMPD m (MPDConn h host prt)". "m" will be replaced by something like "getResponse cmd = sendCommand cmd >> MPD f"
04:46:12 <FliPPeh> f is a function " where f c = (readBlock c) >>= (return . Right)"
04:46:31 <FliPPeh> So I'm basically ADDING the new parameter inside the "where"
04:46:44 <FliPPeh> "getResponse :: String -> MPD String"
04:46:54 <FliPPeh> It doesn't say anything about the "MPDConn" it will consume
04:47:08 <FliPPeh> I tried adding it in the parameter list but it never compiled for me
04:47:39 <mreh> I don't know the domain at all, you'll have to wait until someone who knows about networking arrives :(
04:47:49 <FliPPeh> It's not networking specific
04:47:53 <FliPPeh> Just monadic :/
04:48:11 <mreh> can you write a short example in simplified code
04:48:20 <FliPPeh> The whole code is just 60 lines
04:48:22 <FliPPeh> so far
04:48:29 <FliPPeh> Want me to cut it down, tho?
04:48:52 <mreh> it's not that
04:49:33 <mreh> if you can write it in fewer lines then great, I'm just too lazy to understand it
04:49:46 <FliPPeh> k
04:49:48 <FliPPeh> @hpaste
04:49:48 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:49:55 <Yoshibloke> Is there any way I can print a list (or larger data structure) of floats so that all the floats are formatted to a couple of decimal places?
04:50:04 <mreh> paste it and point to the relevant parts, I'll look over it
04:50:14 <mreh> Yoshibloke, printf :)
04:50:16 <Axman6> Yoshibloke: you can with printf
04:50:41 <mreh> > printf ".2f" 0.3333
04:50:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:50:42 <lambdabot>    `Text.Printf.PrintfType ...
04:50:46 <Yoshibloke> I had a look at printf but it gives me nasties when I try to use a list on it. I suppose I have to do some sort of mapping?
04:50:52 <mreh> > printf ".2f" (0.3333::Double)
04:50:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:50:53 <lambdabot>    `GHC.Show.Show a'
04:50:53 <lambdabot>      a...
04:51:09 <mreh> printf "%.2f" 0.333
04:51:20 <mreh> I used the wrong syntax in the format string anyway
04:51:44 <mreh> IIRC the format string is identical to C
04:52:03 <mreh> to the format strings in C*
04:53:00 <Saizan> >  printf "%.2f" 0.333 :: String
04:53:01 <Axman6> > printf "%.2f" (1/3) :: String
04:53:01 <lambdabot>   "0.33"
04:53:02 <lambdabot>   "0.33"
04:53:05 <Axman6> heh
04:53:16 <FliPPeh> mreh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7020#a7020
04:53:31 <FliPPeh> Line 33 is where the particular function lives
04:53:32 <mreh> oh yes, the PrintF class is either String or IO () isn't it?
04:53:54 <mreh> I don't that what I just said made any sense
04:54:19 <mreh> FliPPeh, give me a high level description of the problem
04:55:22 <FliPPeh> mreh: As you can see in my "sendCommand" function, it will start with "MPD (\c ->...", and c will be the (MPDConn ...) part of "withMPDx"
04:55:28 <FliPPeh> It gets silently passed to there
04:55:32 <Saizan> yeah
04:55:33 <Sgeo_> > mapM putStrLn ["Bilbo", "BILBO!", "Bilbo Baggins!", "Greatest little hobbit of them all"]
04:55:34 <lambdabot>   <IO [()]>
04:55:45 <Saizan> FliPPeh: that's what the MPD monad does
04:55:45 <FliPPeh> I tried explicitly mentioning it in the parameter list
04:55:55 <Saizan> FliPPeh: which parameter list?
04:55:56 <FliPPeh> But that doesn't work
04:56:06 <Sgeo_> I take it lambdabot doesn't like putStrLn?
04:56:13 <Sgeo_> Or did I do something wrong?
04:56:14 <FliPPeh> All directly and indirectly called by withMPDx
04:56:27 <Saizan> Sgeo_: side-effects are not executed
04:56:32 <FliPPeh> sendCommand, mpdPause, getResponse
04:56:35 <Sgeo_> Ah
04:56:37 <mreh> lambdabot only evaluates haskell
04:56:41 <mreh> she doesn't execute it
04:57:14 <Saizan> FliPPeh: why do you want to add it explicitly?
04:57:38 <FliPPeh> because this confuses me every time
04:58:04 <FliPPeh> The MPDConn is needed in some functions, but not in all, I'd like to write a function like "get" in the StateT monad
04:58:13 <FliPPeh> Where I just call "connection <- getConn"
04:58:20 <FliPPeh> But I'm puzzled how to do that
04:58:45 <Saizan> FliPPeh: getConn = MPD (\c -> return (return c))
04:58:56 <jaspervdj> hmm... when a custom instance of Ord, what function does one implement? I have the feeling you have to do everything twice when implementing `compare`.
04:59:11 <FliPPeh> Wow, thanks Saizan :o
04:59:26 <mreh> @src Ord
04:59:26 <lambdabot> class  (Eq a) => Ord a  where
04:59:26 <lambdabot>     compare      :: a -> a -> Ordering
04:59:26 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
04:59:26 <lambdabot>     max, min         :: a -> a -> a
04:59:27 <Saizan> np :)
04:59:45 <mreh> jaspervdj, look at the source for the default implementation of compare, it should suffice
04:59:55 <mreh> or... even better!
04:59:58 <mreh> @src compare
04:59:58 <lambdabot> compare x y | x == y    = EQ
04:59:58 <lambdabot>             | x <= y    = LT
04:59:58 <lambdabot>             | otherwise = GT
05:00:07 <Saizan> jaspervdj: why twice?
05:00:34 <jaspervdj> Saizan: compare x y and compare y x (for ADT's with multiple constructors)
05:00:38 <FliPPeh> Saizan: but it doesn't work :/
05:00:44 <FliPPeh>  No instance for (Monad (Either String))
05:00:44 <mreh> jaspervdj, it's an N! relationship if anything!
05:00:49 <jaspervdj> mreh: cool, so I just have to implement <=
05:01:15 <mreh> jaspervdj, and (==)
05:01:29 <Saizan> FliPPeh: oh, i thought you had Control.Monad.Error imported, just use getConn = MPD (\c -> return (Right c)) then
05:01:49 <FliPPeh> :)
05:01:51 <FliPPeh> Thanks a lot
05:02:02 <jaspervdj> mreh: yep, but == can be done using a deriving (Eq), it's the deriving (Ord) that's the problem in this case :-)
05:02:02 <mreh> how do I get a type specific implementation of a method?
05:02:14 <mreh> jaspervdj, deriving Ord is not a problem
05:02:27 <mreh> @src :Either return
05:02:28 <lambdabot> Source not found. Sorry.
05:02:32 <mreh> what is it?
05:02:48 <Saizan> Right
05:02:54 <jaspervdj> mreh: I know, but I want to compare certain advanced structures with different constructors, and there's lots of special cases
05:03:23 <mreh> jaspervdj, I get you, I thought you meant GHC was unable to do it automatically
05:03:27 <Botje> @src (Either e) return
05:03:28 <lambdabot> Source not found.
05:03:32 <Botje> @src return (Either e)
05:03:33 <lambdabot> Source not found. Wrong!  You cheating scum!
05:03:35 <Sgeo_> forceBackToSleep :: Chatter -> IO ()
05:03:36 <Botje> nope.
05:03:43 <Sgeo_> main = forceBackToSleep sgeo
05:03:50 <jaspervdj> mreh: Okay... thanks for the help :-) *goes off to implement <=*
05:04:34 <mreh> > return "Hello"
05:04:35 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
05:04:35 <lambdabot>    arising from a use ...
05:04:39 <mreh> > return "Hello" :: Either String
05:04:40 <lambdabot>   `Data.Either.Either GHC.Base.String' is not applied to enough type argument...
05:04:44 <mreh> > return "Hello" :: Either Int String
05:04:45 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Int)
05:04:45 <lambdabot>    arising ...
05:04:49 <robokop> i'm trying to install haskell-platform but it fails building HTTP-4000.0.6
05:05:00 <mreh> robokop: what is the error?
05:06:51 <mreh> have you checked the dependencies? I should think there are some Clibs required
05:07:31 <robokop> hmm after cabal install HTTP-4000.0.6 now the make is succeeding
05:08:08 <FliPPeh> Saizan: So basically I can replace occurences of "MPD (\c -> ..." with "do c <- getConn" now?
05:08:18 <FliPPeh> It compiles, but I'm not sure if that's right :)
05:08:27 <Saizan> FliPPeh: yes
05:08:35 <FliPPeh> That's so much cleaner
05:08:40 <FliPPeh> thanks a bunch
05:09:00 <Saizan> FliPPeh: except that ... is of type IO (Response A) in the first case
05:09:18 <Saizan> FliPPeh: while the rest of the do-block is still MPD A in the second case
05:09:25 <FliPPeh> I've got liftIO
05:09:28 <Saizan> yeah
05:09:32 <FliPPeh> :9
05:09:49 <robokop> although first i had some problem with it requiring network-2.2.1.7, and having 2.2.1.4 in the tar
05:10:09 <robokop> and cabal install didn't found network-2.2.1.7 either
05:11:48 <Saizan> did you cabal update first?
05:11:57 <Saizan> network-2.2.1.7 is on hackage
05:12:27 <robokop> i did update it
05:12:52 <Saizan> yeah, otherwise it wouldn't mention it
05:13:00 <robokop> dunno why it was broken, but it works now
05:13:10 <Saizan> so i'm not sure what you mean by didn't found, but if it works ok
05:19:38 <Arnar> is there something like ErrorT that doesn't require the error type to be of a specific class?
05:20:38 <Arnar> something like an "Either monad".. where Left values just short circuit everything
05:23:49 <Botje> what's wrong with Either String ?
05:24:18 <Botje> and you could easily write an Error instance for () and use that
05:24:47 <Botje> but then that's almos the same as a MaybeT
05:24:51 <Arnar> I'm writing a lib where users supply their own type.. and I don't want expose that I'm using Error
05:25:12 <Botje> MaybeT it is! :)
05:25:31 <Arnar> rather Either.. :) because the short-circuitting needs to propogate a value
05:26:35 <Cale> Arnar: Either can be made an instance of Monad
05:26:42 <Cale> Arnar: Without the silly extra condition
05:26:52 <Arnar> Cale: what condition?
05:26:58 <Arnar> I can see how it can be made a monad..
05:27:02 <Arnar> and doing so atm :)
05:27:24 <Cale> Arnar: Well, the mtl's instance in Control.Monad.Error has this silly (Error e) constraint
05:28:05 <Arnar> Cale: ah.. yes
05:28:18 <Arnar> I suppose that condition is there just because fail has String -> a
05:28:45 <Cale> Yeah, but fail shouldn't even be in the Monad class.
05:28:52 <Arnar> *nods*
05:29:26 <Arnar> the language designers failed a bit there
05:29:27 <Arnar> </pun>
05:30:10 <Botje> it's a reminder that haskell was built by mortals.
05:30:54 <medfly> we must correct it
05:31:56 <zygoloid> the trouble is, once you start making Prelude changes it's not clear where to stop
05:32:20 <zygoloid> (also you stand to break a lot of existing code...)
05:32:20 <benmachine> why should you stop? :P
05:32:31 <benmachine> existing code is for losers
05:32:40 <medfly> :))
05:32:48 <zygoloid> existing code is for people who forget that we're trying to avoid success
05:32:58 <benmachine> precisely
05:33:59 <zygoloid> would you just move 'fail' to MonadPlus, or introduce a new MonadFail/MonadZero?
05:34:14 <Cale> Well, we certainly want MonadZero back
05:34:26 <Cale> I think it's not unreasonable to also have MonadFail
05:35:07 <Cale> Also, do-notation's translation will need to be changed a little
05:35:15 <zygoloid> why?
05:35:22 <Cale> But it can be done in such a way as to be mostly compatible
05:35:31 <zygoloid> aiui it already doesn't generate a 'fail' if the pattern match is irrefutable
05:35:43 <Cale> You don't want to introduce MonadFail constraints unless there's a failable pattern.
05:35:57 <zygoloid> (though perhaps that's just a GHC optimization)
05:36:02 <Cale> There are "refutable" pattern matches which still can't fail.
05:36:09 <Cale> Like pattern matching on a pair
05:36:16 <Arnar> Cale: a failing pattern in the do notation produces fail?
05:36:25 <Cale> Arnar: yeah
05:36:33 <Arnar> ech..
05:36:40 <Cale> The translation for do-notation in 1.4 was slightly different
05:36:50 <Cale> (and smarter)
05:37:16 <Axman6> how so?
05:37:43 <Cale> It only used mzero if you pattern matched on a constructor in a type with two or more constructors.
05:37:44 <zygoloid> Cale: hmm, seems there are two different meanings of 'irrefutable' then :) i assume the variables-and-newtypes one is the standard sense?
05:37:57 <Cale> zygoloid: yeah
05:38:18 <benmachine> and patterns with ~?
05:38:22 <Cale> right
05:39:04 <zygoloid> "~pat" is just sugar for "x" plus "let pat = x in" so yeah :)
05:39:26 <Cale> Normally 'irrefutable' refers to the case that no evaluation has to be done to do the pattern match, and non-failable refers to the case where you may have to do evaluation, but if the thing evaluates to anything but _|_, the pattern match will succeed.
05:39:53 <Cale> Usually I think of it the other way around
05:40:09 <Cale> Pattern bindings get an implicit ~ stuck in front of them.
05:40:56 <Cale> Though refutable pattern bindings with let doesn't make much sense to me either. The new translation for bang patterns is awkward in that way.
05:41:22 <Cale> (it turns let into case)
05:42:25 <zygoloid> yeah, you're right, the 'is sugar for' relation is reflexive :)
05:43:17 <zygoloid> > case False of ~True -> 42
05:43:18 <lambdabot>   42
05:43:25 <zygoloid> ~ turns case into let, ! turns let into case :)
05:43:36 <benmachine> what happens if you do ~! :P
05:43:43 <zygoloid> the universe asplode
05:43:54 <benmachine> > let !a = undefined in 0
05:43:55 <lambdabot>   * Exception: Prelude.undefined
05:43:59 <benmachine> > let ~!a = undefined in 0
05:44:01 <lambdabot>   <no location info>: parse error on input `~!'
05:44:02 <benmachine> :(
05:44:06 <benmachine> > let !~a = undefined in 0
05:44:07 <lambdabot>   <no location info>: parse error on input `!~'
05:44:12 <benmachine> > let !(~a) = undefined in 0
05:44:12 <zygoloid> > let ! ~a = undefined in 42
05:44:13 <lambdabot>   * Exception: Prelude.undefined
05:44:13 <lambdabot>   * Exception: Prelude.undefined
05:44:16 <benmachine> hmm
05:44:22 <zygoloid> > let ~ !a = undefined in 42
05:44:23 <lambdabot>   <no location info>: parse error on input `!'
05:44:33 <zygoloid> > case undefined of ~ !a -> 42
05:44:34 <lambdabot>   <no location info>: parse error on input `!'
05:44:35 <benmachine> can you even do a ! except at the top level?
05:44:37 <zygoloid> > case undefined of ! ~a -> 42
05:44:38 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
05:44:42 <benmachine> wat
05:44:47 <zygoloid> , case undefined of ! ~a -> 42
05:45:03 <benmachine> lambdabot supports !a in let but not in case?
05:45:31 <zygoloid> it's redundant in case. maybe it's just the wrong error message?
05:45:34 <benmachine> > let (!x):xs = [undefined] in 0
05:45:35 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
05:45:43 <benmachine> > let !(x:xs) = [undefined] in 0
05:45:43 <lambdabot>   0
05:45:49 <benmachine> hmm
05:45:50 <zygoloid> huh.
05:46:22 <zygoloid> i wonder if h'98 allows top-level bang patterns in function and let bindings?
05:46:44 <benmachine> I'd be surprised, but that's what ghc seems to be implying
05:46:50 <ziman> does h98 allow bang patterns at all?
05:47:25 <benmachine> http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html implies not
05:47:28 <benmachine> well
05:47:36 <benmachine> data Foo a = Foo !a !a is valid h98
05:47:41 <benmachine> but that's not exactly a pattern
05:51:42 <benmachine> http://haskell.org/onlinereport/exps.html#sect3.17.2 doesn't mention bang patterns anywhere
05:51:55 <benmachine> so it looks to me like GHC is being more accepting than it ought
05:53:03 <Becquerel> GHC is corrupt
05:53:24 <Becquerel> or perhaps just lazy.
05:54:36 <benmachine> oh hold on
05:54:47 <benmachine> :t let f !a = undefined in (!)
05:54:49 <lambdabot> forall t t1 a. t -> t1 -> a
05:55:21 * benmachine sigh
05:55:29 <benmachine> silly ambiguous syntaz
05:55:30 <benmachine> x
05:55:43 <pozic> What's wrong with this? http://paste.debian.net/59397/
05:56:34 <benmachine> pozic: consider the case of m that has an instance of both MonadIO and MonadST
05:56:47 <benmachine> what is mlift for that case?
05:57:17 <pozic> benmachine: how do I tell the system that that won't happen?
05:57:21 <benmachine> you don't
05:57:25 <benmachine> because it might
05:57:38 <benmachine> anyone who imports your code can do it
05:58:06 <pozic> benmachine: that's a lovely theoretical answer.
05:58:15 <pozic> benmachine: it's however useless.
05:58:17 <benmachine> it's true; you can't do what you want to do there
05:58:22 <benmachine> you have to do it in a different way
05:58:37 <benmachine> e.g. define instances for IO, ST, etc.
05:58:38 <paolino> is it possible to write a let f = id :: forall a. Show a => a -> a in (f  "ciao",f  1) ?
05:59:12 <pozic> benmachine: so, a MPTC m1 m2?
05:59:22 <pozic> benmachine: er MLift m1 m2
05:59:27 <benmachine> pozic: err, that's not what I meant
05:59:29 <benmachine> I just meant
05:59:35 <benmachine> instance MLift IO where
05:59:37 <benmachine> etc.
05:59:37 <paolino> (without the constraint, it can be compiled)
05:59:39 <Cale> pozic: Instance selection can't make use of the class constraints on the instance, because any future module might come along and satisfy those constraints.
06:00:02 <Cale> pozic: So instances are selected based only on the part of the instance head after the =>
06:00:22 <pozic> Cale: yes, but isn't there some flag to change that?
06:00:25 <Cale> no.
06:00:48 <Cale> The usual solution is to use a newtype wrapper.
06:00:55 <Cale> and write the instance for the newtype
06:01:19 <Cale> Though, that doesn't really help so much here.
06:01:22 <RayNbow> btw, http://www.haskell.org/haskellwiki/Caleskell <-- why is there no page for this? :p
06:01:23 <pozic> All I want it to be able to wrote readRef and have the result work in whatever monad it happens to be running in (a monad transformer stack).
06:01:30 <pozic> write*
06:01:47 <Cale> RayNbow: Because Caleskell doesn't exist.
06:02:00 <benmachine> so he would have you believe, anyway
06:02:01 <FliPPeh> @hoogle Caleskell
06:02:02 <lambdabot> No results found
06:02:08 <FliPPeh> @hayoo Caleskell
06:02:08 <lambdabot> Unknown command, try @list
06:02:11 <FliPPeh> @list
06:02:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:02:15 <pozic> To me that seems to be a very sensible abstraction.
06:02:29 <FliPPeh> @version
06:02:30 <lambdabot> lambdabot 4.2.2.1
06:02:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:02:30 <benmachine> pozic: you could make a new typeclass for "things that have readable refs"
06:02:42 <Cale> pozic: Have it be part of a typeclass
06:02:46 <FliPPeh> @girl19
06:02:46 <lambdabot> LOL
06:02:58 <FliPPeh> @yhjulwwiefzojcbxybbruweejw
06:02:58 <lambdabot> "\"#$%&'()*+,\""
06:03:05 <benmachine> @v
06:03:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
06:03:29 <FliPPeh> @uptime
06:03:29 <lambdabot> uptime: 10d 6h 30m 35s, longest uptime: 1m 10d 23h 44m 29s
06:03:30 <RayNbow> Cale: but isn't lambdabot the embodiment of Caleskell?
06:03:35 <Cale> RayNbow: no
06:04:20 <FliPPeh> @free
06:04:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
06:04:24 <FliPPeh> Ahhh
06:04:26 <Cale> RayNbow: lambdabot just has a set of local definitions L.hs which imports various libraries, as well as making local definitions.
06:04:27 <FliPPeh> It crash'd!
06:04:31 <benmachine> Cale: Caleskell is just a way of concisely referring to things like (++) = mappend and (.) = fmap, and those things exist
06:04:39 <FliPPeh> Can Lambdabot load modules at runtime?
06:04:46 <benmachine> and it's reasonable to ask whether or not the haskell wiki has an opinion on them
06:04:46 <FliPPeh> Also, how are those modules made?
06:05:09 <Cale> benmachine: I don't see why you should call that Caleskell.
06:05:24 <medfly> Cale, because you're the main person supporting it, and everyone loves Cale.
06:05:24 <benmachine> Cale: that's an arguable point but it's definitely something that people do :P
06:05:47 <Cale> I like those choices of definitions, but there's a lot of other stuff which I'd like to change as well.
06:05:51 <m0nkfish> hascale
06:05:57 <Cale> (most of which isn't in lambdabot)
06:06:11 <medfly> Cale, you should make a version of Haskell with all those changes so we can have a real Caleskell or Hascale.
06:06:17 <medfly> hehe :)
06:06:29 <Cale> I'd just call it Haskell 2.0 ;)
06:06:32 <benmachine> heh
06:06:43 <medfly> yeah, but that'd create confusion
06:06:48 <Botje> will it have pastel tints and rounded corners?
06:07:04 <Botje> and it should be haskll 2.0 then :P
06:07:14 <Philonous1> Damn heathens! Stop worshiping pagan idols!
06:07:24 <osaunders> (%) is defined in Prelude according to my GHC docs but is out of scope unless you import Ratio, how is this?
06:07:24 <Cale> Also, we should have some sort of system for row polymorphism with extensible record and variant types.
06:07:57 <Cale> osaunders: I guess the Prelude doesn't export it?
06:07:58 <medfly> like a variant of Haskell that is much more rapidly changing :P
06:08:15 * hackagebot upload: hlint 1.6.20 - Source code suggestions (NeilMitchell)
06:08:17 * RayNbow is googling "site:tunes.org caleskell"... trying to find the first occurence of Caleskell
06:08:27 <idnar> paolino: I think you need to introduce a data constructor
06:08:40 <Cale> medfly: Well, Haskell is changing, but parts of it seem to be stuck, and we need to try to unstick them.
06:08:53 * medfly gives Cale a scalpel
06:08:55 <idnar> oh, maybe not
06:09:01 <osaunders> Ooh this is an interesting discussion.
06:09:09 <osaunders> Cale: What needs to change?
06:09:17 <Cale> osaunders: Lots of stuff in the Prelude
06:09:47 <RayNbow> first occurence might be in May 2008
06:10:09 <Cale> Some people think that the whole Num hierarchy should be refined a lot. I actually wouldn't go too far with that, but I would separate abs and signum into their own class and drop the Eq and Show constraints.
06:10:22 <Cale> fail needs to be separated out of Monad or killed altogether
06:10:27 <benmachine> Cale: if you dropped Eq, what would happen to pattern matching numeric literals?
06:10:42 <Cale> The instances of Functor and Monad for ((->) e) should be in the Prelude
06:10:44 <ksf> Cale, if we break compatiblity of the base libs, we should do it once, thoughoutly, properly and utterly.
06:10:54 <Cale> benmachine: It would induce an Eq constraint of course.
06:11:19 <Cale> ksf: Nah, we should do it repeatedly and continuously, but with clear version numbers on everything.
06:11:19 <benmachine> I suppose that makes sense
06:11:26 <ksf> possibly, that includes relying on not-yet specified extensions
06:11:45 <ksf> on my list are the num hierarchy and a lot of stuff from category-extras
06:11:51 <Cale> We already have a nice package system and a versioned base package.
06:12:00 <osaunders> Cale: Is Caleskell a real project or just an idea?
06:12:01 <RayNbow> we might want to have something like class aliases before refining the Num hierarchy
06:12:02 <benmachine> what from category-extras?
06:12:07 <ksf> indexed monads are a pain to use, right now.
06:12:11 <benmachine> osaunders: Caleskell is a term that other people invented
06:12:16 <ksf> ...well, at least if you also want to use plain monads
06:12:18 <Cale> osaunders: Caleskell is something nebulous that other people made up
06:12:26 <Cale> osaunders: Please don't use that word.
06:12:38 <osaunders> :(
06:12:42 <osaunders> OK
06:12:43 <ksf> Cale, then how to call it?
06:12:48 <ksf> h' isn't radical enough
06:12:50 <Cale> There are people discussing an alternate version of the standard library in #alt-stdlib
06:13:03 <Cale> We don't need a standards process.
06:13:08 <Cale> We need an implementation.
06:13:48 <Cale> I would be against standardising anything we hadn't implemented and tried out in GHC for at least a full release cycle.
06:13:48 <merijn> I just started a compiler course and since ADTs seem to beg to be used for recursive descent parsing I figured I might as well try to implement a toy language compiler in haskell. I was wondering if there's any shortcuts I can take to cheat and use GHC's backends for generating actual code.
06:14:47 <Cale> merijn: Well, you could use Template Haskell and compile your toy language into Haskell abstract syntax.
06:14:56 <osaunders> I consider stdlib design one of the most challenging aspects of language design.
06:15:46 <FliPPeh> @unlambda
06:15:46 <lambdabot>   unlambda: Parse error at end of file
06:15:52 <FliPPeh> @unlambda (\x -> x*2)
06:15:53 <lambdabot>   unlambda: Unknown operator '('
06:15:57 <FliPPeh> @unlambda \x -> x*2
06:15:57 <lambdabot>   unlambda: Unknown operator '\\'
06:15:58 <FliPPeh> :(
06:16:01 <benmachine> @help unlambda
06:16:01 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
06:16:06 <Cale> Are you looking for @pl?
06:16:11 <MissPiggy> @unlambda ``yy`y```a`
06:16:12 <lambdabot>   unlambda: Unknown operator 'y'
06:16:19 <merijn> Cale: Yeah, I was wondering if I couldn't just transform the AST for my language into the type used by GHC. I mean, theoretically I could transform it into actual source, but that seems A) more work B) more complicated
06:16:31 <Cale> unlambda is more or less a sort of SK-calculus interpreter
06:16:57 <ksf> merijn, and c) isn't type safe
06:17:11 <Cale> merijn: It's probably about the same level of difficulty actually.
06:17:24 <merijn> ksf: Why wouldn't that be type safe?
06:17:37 <Cale> You could use haskell-src-exts to generate code and it would look very similar to the Template Haskell sort of way.
06:17:40 <ksf> ...because a string has less type information than a haskell ast
06:17:51 <merijn> ksf: Not if the string is valid haskell...
06:17:51 <Cale> You wouldn't use strings to generate Haskell code.
06:18:02 <Cale> That'd be silly.
06:18:34 <ksf> you can, of course, still produce programs with that ast that e.g. don't typecheck, but you have a static guarantee not to get syntax errors
06:18:43 <Cale> http://hackage.haskell.org/packages/archive/haskell-src-exts/1.8.1/doc/html/Language-Haskell-Exts-Syntax.html
06:18:47 <MissPiggy> typical structure
06:18:55 <m0nkfish> how do you write haskell if not in string format? ;)
06:19:01 <Cale> ^^ you would use these datatypes and the included prettyprinter to generate program text
06:19:08 <merijn> Cale: I'll check it out, thanks.
06:20:29 <Saizan> m0nkfish: type inference adds lot of information using the environment e.g. imported modules, so a fully annotated AST contains much more directly accessible information
06:21:56 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html -- you can compare that with the Template Haskell way of encoding things.
06:22:11 <pozic> merijn: reading an AST of GHC might be a lot more difficult than reading Haskell output.
06:22:57 <merijn> pozic: Yeah, but who's going to read it?
06:23:26 <merijn> You don't read the assembly outputted by a C compiler, why would you read the AST output of another language?
06:26:12 <benmachine> merijn: people writing compilers have to read it :P
06:27:19 <medfly> does anyone know a place where there's a source for a website made in Haskell?
06:27:20 <medfly> real website :p
06:27:31 <MissPiggy> why would you read the AST output of another language?
06:28:17 <osaunders> medfly: There's the happs tutorial.
06:28:20 <merijn> Maybe to verify correctness, but that's for wusses who can't proof correctness :p
06:28:28 <medfly> ??
06:28:34 <lazni> > [0..1.]
06:28:35 <lambdabot>   <no location info>: parse error on input `]'
06:28:42 <medfly> I don't want to read a tutorial, just a source of a website made in Haskell
06:28:42 <lazni> > [0..1.0]
06:28:43 <lambdabot>   [0.0,1.0]
06:28:56 <osaunders> medfly: The tutorial for Happstack is a website written using Happstack.
06:29:08 <merijn> medfly: happstack has some example websites written in haskell using happstack
06:29:19 <merijn> medfly: I'm not sure the code of their site is in there, though
06:29:35 * benmachine ponders the relative merits of using Either to glue together existing types versus using custom ADTs
06:29:37 <osaunders> The tutorial is, I've run it.
06:29:50 <osaunders> It even tells you how.
06:30:06 <osaunders> Except there was a problem getting it to install.
06:30:06 <medfly> :-/
06:30:19 <osaunders> But I know a workaround so just ask me for help if you decide to try it.
06:30:39 <medfly> I don't...
06:31:15 <Saizan> the happstack executable creates a demo from which you can start making your own website, btw
06:31:23 <osaunders> medfly: You don't what?
06:32:16 <medfly> I don't want to try it
06:32:23 <osaunders> OK.
06:32:42 <bfh6558> good morning, I wanted to pop in here before i head to class this morning to see if you guys could help me out :P, So i've been learning(i stretch the word learning here, more like toying with) haskell lately and one of my cs professors announced a semester long project of our choosing, of course I'de have to make a proposal to her.  Anyone able to reccomend a practical application of haskell that i could potentialy make a semester project?
06:33:17 <notallama> write a compiler for something, maybe?
06:33:42 <bfh6558> hmm deffinitaly possible
06:33:52 <MissPiggy> "compiler"
06:33:57 <bfh6558> what are some current projects that are written in haskell
06:34:23 * hackagebot upload: hslackbuilder 0.0.2 - HSlackBuilder automatically generates slackBuild scripts from a cabal package (AndreaRossato)
06:35:14 <merijn> bfh6558: By what I've seen so far, pretty much everything under the sun
06:35:56 <kuribas> bfh6558: A document formatting program?
06:36:31 <merijn> Invent some new typesetting math that obsoletes TeX and implement it :p
06:36:41 <bfh6558> haha
06:37:13 <osaunders> bfh6558: Write something the Haskell community could benefit from.
06:37:21 <Arnar> aye.. monad transformer order is confusing me :/
06:37:26 <bfh6558> yeah i'm looking on github and hackage right now
06:37:33 <merijn> bfh6558: Well, someone pointed me to project working on an OS written in haskell, bound to be work in that
06:37:35 <cheater> bfh6558: what is your course of study?
06:37:37 <bfh6558> thanks for all the good suggestions
06:37:51 <Arnar> can anyone point out the difference between ErrorT _ (StateT _ IO) a  and  StateT _ (ErrorT _ IO) a  ?
06:37:57 <bfh6558> im a cs major, although i tend to like systems programming more than net applications
06:38:08 <merijn> bfh6558: http://programatica.cs.pdx.edu/House/
06:38:12 <bfh6558> and although i'm not terribly adept in computational theory
06:38:15 <bfh6558> i love to read on it
06:38:39 <merijn> bfh6558: Ah, so you're like me. Intriguied by all this category theory business in haskell, but with hardly a clue where to start :p
06:38:44 <benmachine> Arnar: lambdabot's @unmtl is useful for this
06:38:50 <cheater> bfh6558: ask her to teach you how to program highly parallelized applications that can be spread over multiple nodes.
06:38:50 <bfh6558> EXACTLY!
06:38:59 <benmachine> @unmtl StateT s (ErrorT e IO) a
06:39:00 <lambdabot> s -> IO (Either e (a, s))
06:39:06 <Arnar> ah.. nice
06:39:16 <benmachine> @unmtl ErrorT e (StateT s IO) a
06:39:16 <lambdabot> s -> IO (Either e a, s)
06:39:17 <cheater> bfh6558: for example, some matrix multiplication stuff
06:39:29 <Arnar> benmachine: thanks..
06:39:33 <Arnar> that helps a lot
06:39:33 <merijn> bfh6558: I must say, that House seems intriguing enough (especially if you're interested in systems programming). I haven't looked at the code base, though.
06:39:36 <benmachine> looks like the distinction is basically whether or not a failing computation generates a state
06:39:53 <Arnar> benmachine: that was what I thought.. but I couldn't figure out which did and which did not :)
06:40:36 <pozic> bfh6558: if you want to do something useful, you could implement a more usable Cabal.
06:41:14 <bfh6558> pozic: i cant even get cabal-install to run correctly on my machine! :(
06:41:28 <pozic> bfh6558: well, then you fix two problems at once.
06:41:31 <bfh6558> i've got ghc modules that are tooo? up to date?
06:41:36 <bfh6558> lol
06:41:52 <pozic> bfh6558: if you want to learn something about CS, I do not recommend any project suggested here.
06:41:53 <bfh6558> anyways I'm going to head to class thanks for your help everyone
06:41:53 <Saizan> bfh6558: cabal-install-0.8.0 works perfectly with ghc-6.12.1
06:41:57 <MissPiggy> what is computational theory?
06:41:59 <bfh6558> oh
06:42:01 <osaunders> bfh6558: Better games development tools?
06:42:02 <bfh6558> why not?
06:42:33 <pozic> bfh6558: because e.g. House has nothing to do with CS.
06:43:13 <osaunders> Improve regular expressions.
06:43:21 <osaunders> That has something to do with CS as well (I think).
06:43:23 <pozic> bfh6558: House is proof that with a very small amount of assembly it is possible to write an OS in Haskell.
06:43:30 <pozic> But that has nothing to do with CS.
06:44:09 <pozic> osaunders: regular expressions already have optimal algorithms and optimal implementations, AFAIK.
06:44:15 <bfh6558> would you be able to reccommend a project that a medoicre programmer would be able to undertake, prefferably in haskell, to learn something practical in csA?
06:44:17 <Saizan> pozic: you realize that you haven't really explained why, do you?
06:44:18 <bfh6558> cs?*
06:44:33 <MissPiggy> bfh6558: what is computational theory?
06:44:51 <bfh6558> Set theory, graph theory, etc...
06:44:57 <MissPiggy> oh right, maths
06:45:00 <bfh6558> sorry for not answering befor misspiggy
06:45:10 <pozic> Saizan: Ok, I mean that House didn't prove anything unexpected.
06:45:21 <pozic> Saizan: it is an exercise in software engineering.
06:45:22 <bfh6558> turing machines, NP completeness, but i still dont fully understand what that means
06:45:25 <bfh6558> hah
06:45:28 <MissPiggy> you should probably pick a topic in CS that you want to learn more about, get a couple books -- then youll have something to program
06:46:03 <Saizan> pozic: learning about CS and doing something new in CS look different to me
06:46:07 <bfh6558> MissPiggy: the hard part is producing something practical at the same time
06:46:23 <pozic> Saizan: yes, I suppose, you are right.
06:46:41 <MissPiggy> Oh I'm the wrong cat to talk to if you want to do something practical
06:47:01 <notallama> bfh6558: do you need to produce something practical, or just something that could be practical with more polish?
06:47:13 <bfh6558> the later
06:48:54 <bfh6558> the largest block to get around is I'm only a so-so coder, so the large projects really scare me. But by the same notion i'd really like to get my hands dirty with a sizeable project to gain the lacking skills
06:49:06 <notallama> then invent yourself a programming language, and write a compiler or interpreter for it. :) there's plenty of meat for theoretical stuff, like optimization and built in data-structures.
06:49:11 <medfly> right... that's how ti works
06:49:13 <bfh6558> and at teh same time have the project be a semester managabele project
06:49:23 <medfly> things are less scary with moar experience doing scary things
06:49:32 <medfly> only you know what is a manageable project for you
06:49:41 <MissPiggy> unless you know... every single time you try it goes horribly wrong
06:50:08 <medfly> bfh6558, THE ANSWER IS WITHIN YOU!
06:50:09 <medfly> heh
06:50:21 <bfh6558> I'll thnk on it today. Thanks everyone I'll be back around :P
06:50:46 <pozic> On university nobody cares if you fail.
06:50:58 <pozic> (yes, I know he already left.)
06:52:19 * MissPiggy wonders if rational root works for gaussian integer polynomials
06:52:54 <MissPiggy> guess you could just split it into two polynomials and intersect the set of roots -- but that would only give real rational roots
06:59:18 <MissPiggy> anyone know of an english translation of Disquisitiones Arithmeticae?
07:03:00 <int-e> MissPiggy: It works. p(x) = sum a_i x^i, then if x and y are coprime and p(x/y) = 0 then y^n p(x/y) = sum a_i x^i y^(n-i) = 0, and you can write a_n x^n + y * q(x,y) = 0, so y divides a_n and x * r(x,y) + a_0 y, so x divides a_0. (That works in any unique factoring domain. Gaussian integers are one.)
07:03:14 <zygoloid> MissPiggy: "arithmetic research" i guess ;-)
07:04:22 <MissPiggy> int-e what is q?
07:04:56 <cheater> MissPiggy: Yale 1966
07:04:59 <MissPiggy> int-e, oh quotient/remainder - of course
07:05:07 <MissPiggy> cheater is that a good translation?
07:05:13 <cheater> it's by Yale
07:06:11 <MissPiggy> int-e okay thanks!
07:08:56 <int-e> MissPiggy: q and r are polynomials in x and y, with coefficients from p. The point is that you can factor out y from all terms of y^n p(x/y) except a_n x^n, and x from all terms except a_0 y^n. And I made a typo; x * r(x,y) + a_0 y should be x * r(x,y) + a_0 y^n
07:10:00 <FliPPeh> How do I create a dummy IO.Handle?=
07:10:03 <FliPPeh> One that's useless?
07:10:06 <FliPPeh> @src Handle
07:10:06 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:10:14 <MissPiggy> ooh I just read is R is a UFD then so is R[X], so does that imply that (R[X])[Y] is also?
07:10:25 <MissPiggy> that would mean I could factor polynomials in multiple variables
07:13:07 <kuribas> How can I stop ghci from printing long expressions?
07:13:28 <kuribas> for example f <- readFile "/path/to/long/file"
07:14:25 <Saizan> :set -fno-print-bind-results -- or something like that
07:14:41 <execve> How to define a lambda function without arguments?
07:14:52 <kuribas> Saizan: ok, thanks.
07:14:55 <execve> Something like (\ -> 1)
07:15:07 <Saizan> execve: there isn't anything like that, nor the need to
07:15:24 <copumpkin> execve: x = 1 is just like x = \ -> 1
07:15:30 <copumpkin> so, tada! x = 1
07:15:41 <benmachine> execve: if you want to ignore an argument, you can do that with \_ -> 1
07:15:54 <benmachine> but a function of no arguments is basically the same as a value
07:15:56 <Cale> execve: Every function has at least one parameter.
07:16:04 <copumpkin> \() -> 1
07:16:06 <Cale> execve: If there's no parameter, it's not a function.
07:16:22 <execve> Actually I want to define lambda which returns something like ((+) . (*))
07:16:37 <benmachine> :t ((+) . (*))
07:16:38 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
07:16:41 <benmachine> eerm
07:16:49 <benmachine> :t (((+) .) . (*))
07:16:50 <lambdabot> forall a. (Num a) => a -> a -> a -> a
07:17:06 <benmachine> execve: why should it be a lambda?
07:17:07 <Cale> (\x y z -> x * y + z) ?
07:17:20 <Cale> Something along those lines?
07:17:27 <execve> benmachine: I need it for foldl
07:17:55 <copumpkin> execve: you can get a function without writing a lambda...
07:18:04 <Cale> > foldl (\a x -> 10*a + x) 0 [1,2,3,4,5]
07:18:05 <lambdabot>   12345
07:18:15 <Cale> Something like that?
07:18:30 <MissPiggy> this is evaluating a polynomial foldl (\a x -> 10*a + x) 0 :)
07:18:52 <execve> Cale: exactly, but without x :)
07:18:56 <copumpkin> respect the power of the polynomial!
07:18:57 <MissPiggy> is there a name for one variable polynomial ??
07:19:01 <execve> and a
07:19:10 <Cale> execve: ...
07:19:15 <Saizan> ?pl (\a x -> 10*a + x)
07:19:15 <lambdabot> (+) . (10 *)
07:19:29 <copumpkin> > foldl ((+) . (10 *)) 0 [1..5]
07:19:30 <lambdabot>   12345
07:19:31 <FliPPeh> @src maybe
07:19:31 <lambdabot> maybe n _ Nothing  = n
07:19:31 <lambdabot> maybe _ f (Just x) = f x
07:19:40 <pozic> MissPiggy: a polynomial of degree one?
07:19:45 <Cale> yeah, you could make the expression there points-free... is that what you mean?
07:19:57 <execve> copumpkin: thanks! Got it
07:20:02 <copumpkin> :P
07:20:05 <MissPiggy> I mean in one variable like 2x^3+6x^2 rather than 5x^3y^2+3xy^2
07:20:09 <Cale> execve: The first parameter to foldl has got to be a function anyway
07:20:15 <Arnar> copumpkin: now show us the inverse :)
07:20:35 <copumpkin> @query lambdabot
07:20:35 <lambdabot> Unknown command, try @list
07:20:39 <MissPiggy> inverse only exists when 0 < & 10 > the numbers in the list
07:20:43 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 12345
07:20:45 <lambdabot>   [1,2,3,4,5]
07:20:53 <copumpkin> unfoldr would be prettier
07:21:19 <Cale> I prefer map/takeWhile/iterate somehow.
07:21:34 <Cale> unfoldr means you have to work with Maybe values in an awkward way
07:21:41 <MissPiggy> I like unfoldr if you want to prove it's the inverse
07:22:21 <Yoshibloke> Hey, can anyone tell me what this has been replaced with. Or somwhere I can get something similar: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FiniteMap
07:22:29 <copumpkin> Data.Map
07:22:32 <Yoshibloke> thanks
07:22:49 <copumpkin> (it still is finite, sadly)
07:24:43 <Cale> > reverse $ unfoldr (\x -> do guard (x > 0); let {(u,v) = divMod x 10}; return (v,u)) 12345
07:24:44 <lambdabot>   [1,2,3,4,5]
07:25:49 <Cale> > reverse $ unfoldr (\x -> do guard (x > 0); return . uncurry (flip (,)) $ divMod x 10) 12345
07:25:50 <lambdabot>   [1,2,3,4,5]
07:26:15 <medfly> just in case it was a bit readable right
07:26:55 <MissPiggy> :t unfoldr
07:26:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:27:02 <MissPiggy> :t divMod
07:27:03 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:27:21 <MissPiggy> something to do with divMod... I am not sure
07:27:58 <MissPiggy> oh that's clever with the guard
07:28:14 <zygoloid> @hoogle (a -> Bool) -> (a -> b) -> (a -> Maybe b)
07:28:14 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
07:28:14 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
07:28:14 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
07:28:19 <MissPiggy> instead of checking the result of divMod having a zero in it, you know that will happen if x = 0
07:29:20 <Arnar> > map (read . replicate 1) (show 12345) :: [Int]
07:29:22 <lambdabot>   [1,2,3,4,5]
07:29:22 <Arnar> hehe
07:29:45 <medfly> owned
07:30:08 <Gracenotes> I wonder why BMP is BGR
07:30:30 <dankna> it just is
07:30:34 <Cale> > map (read . (:[])) (show 12345) :: [Int]
07:30:35 <lambdabot>   [1,2,3,4,5]
07:30:42 <dankna> actually there's a reason, but I don't know it :)
07:31:01 <Cale> Get that robot monkey in there :)
07:33:06 <Arnar> > map (read . return) (show 12345) :: [Int]
07:33:07 <lambdabot>   [1,2,3,4,5]
07:33:15 <Gracenotes> (subtract 48) . ord
07:33:32 <mux> > map digitToInt (show 12345)
07:33:33 <lambdabot>   [1,2,3,4,5]
07:33:50 <medfly> Cale, getting your ass kicked pretty bad there
07:34:52 * MissPiggy still thinks Cales one is best :)
07:35:10 <idnar> > unfoldr (Just . (`divMod` 10)) 12345
07:35:11 <lambdabot>   [1234,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:35:20 <Cale> medfly: huh?
07:35:28 <MissPiggy> > (const [1,2,3,4,5]) 12345
07:35:29 <medfly> Cale, I'm making fun of you
07:35:29 <lambdabot>   [1,2,3,4,5]
07:35:33 <idnar> whoops, wrong way around
07:35:34 <Cale> medfly: I don't understand.
07:35:44 <medfly> "I cannot compute mockery"
07:35:46 <MissPiggy> Cale because those guys wrote a shorter haskell
07:35:56 <Cale> Oh, but it doesn't do the same thing really.
07:36:17 <Cale> The unfoldr and map/takeWhile/iterate versions are at least conceptually equivalent
07:36:22 <MissPiggy> yeah that's what I demonstrate with "(const [1,2,3,4,5]) 12345"
07:36:48 <Arnar> josefs looking over my sholder: "show IS an unfold"
07:37:19 <cheater> Cale: lol at robot monkey
07:38:04 <medfly> Cale, but in 29% of the length!
07:38:48 * MissPiggy tends to measure correctness proof elegance instead of program size
07:39:06 <FliPPeh> Given a list of strings, how do I find out if one of those strings starts with a particular part?
07:39:09 <medfly> MissPiggy, you just love Cale :)
07:39:23 <FliPPeh> ["Hey", "Blah", "INVALID k"] -> find "INVALID"
07:39:30 <mux> FliPPeh: any ("foo" `isPrefixOf`) ...
07:39:33 <FliPPeh> Any standard function for it?
07:39:37 <FliPPeh> :t any
07:39:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:39:39 <tromp> @hoogle String -> String -> bool
07:39:40 <lambdabot> Did you mean: String -> String -> Bool /count=20
07:39:40 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
07:39:40 <lambdabot> Network.CGI newCookie :: String -> String -> Cookie
07:39:48 <MissPiggy> isInvalid ('I':'N':'V':..:_) = True
07:39:59 <zygoloid> > [1..5]
07:40:00 <lambdabot>   [1,2,3,4,5]
07:40:01 <zygoloid> winner?
07:40:04 <mux> > any ("foo" `isPrefixOf`) ["bar", "baz", "foobar"]
07:40:05 <lambdabot>   True
07:40:07 <Arnar> @hoogle prefix
07:40:07 <lambdabot> Data.Data Prefix :: Fixity
07:40:07 <lambdabot> Text.Parsec.Expr Prefix :: ParsecT s u m (a -> a) -> Operator s u m a
07:40:07 <lambdabot> Text.ParserCombinators.Parsec.Expr Prefix :: GenParser tok st (a -> a) -> Operator tok st a
07:40:13 <mux> > any ("foo" `isPrefixOf`) ["bar", "baz", "fobar"]
07:40:15 <lambdabot>   False
07:40:20 <FliPPeh> Thanks mux :)
07:40:24 <mux> yw
07:43:31 <MissPiggy> @let x = [1..5]
07:43:32 <lambdabot>  Defined.
07:43:32 <MissPiggy> > x
07:43:33 <lambdabot>   Ambiguous occurrence `x'
07:43:33 <lambdabot>  It could refer to either `L.x', defined at <local...
07:43:36 <MissPiggy> doh
07:48:12 <interferon> @pl \a b -> compare (date a) (date b)
07:48:12 <lambdabot> (. date) . compare . date
07:48:41 <mux> :t \a b -> compare (date a) (date b)
07:48:42 <lambdabot> Not in scope: `date'
07:48:43 <lambdabot> Not in scope: `date'
07:48:48 <mux> gah
07:48:56 <mux> anyhow, this should be the same as "comparing date"
07:49:05 <interferon> ?
07:49:06 <MoALTz> use the pl'ed version
07:49:12 <MoALTz> @type (. date) . compare . date
07:49:13 <lambdabot> Not in scope: `date'
07:49:13 <lambdabot> Not in scope: `date'
07:49:17 <MoALTz> ok maybe not
07:49:18 <ray> ahem
07:49:20 <ray> :t comparing
07:49:21 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:49:23 <mux> :t \a b -> compare (ord a) (ord b)
07:49:24 <lambdabot> Char -> Char -> Ordering
07:49:26 <interferon> i think in this case the pl'd version is less clear
07:49:26 <MissPiggy> :t date
07:49:26 <mux> :t comparing ord
07:49:27 <lambdabot> Not in scope: `date'
07:49:28 <lambdabot> Char -> Char -> Ordering
07:49:29 <mux> see ?
07:49:31 <Yoshibloke> http://pastebin.org/89539 <-- can anyone tell me why this is giving me a scope error about Map.(!) ?
07:49:38 <pikhq> It needs to know the type of used functions to infer the type...
07:49:58 <mux> alternatively, this is again the same as "compare `on` date"
07:50:07 <interferon> :type on
07:50:10 <interferon> :t on
07:50:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:50:23 <interferon> where is on?
07:50:31 <mux> @index on
07:50:31 <lambdabot> bzzt
07:50:37 <mux> it's in Data.Ord
07:50:42 <medfly> @hoogle on
07:50:43 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:50:43 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
07:50:43 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:50:44 <mux> and probably in Data.Function too nowadays
07:50:50 <medfly> .....
07:51:14 <doserj> Yoshibloke: (Map.!)
07:51:56 <Yoshibloke> doserj - Thanks
07:57:07 <Yoshibloke> what does the "Too many parameters for class X" error mean?
07:57:56 <kqrx> i'm trying out the network monad in haskell to learn monads, but ghc gives me a few "undefined symbols"... do i have to link the network library or something? (it works fine in ghci)
07:58:56 <mreh> kqrx: sounds like a linker problem
07:59:06 <kqrx> to me too
07:59:07 <mreh> clean the project before you recompole
07:59:15 <mreh> i.e. remove *.o and *.hi
07:59:28 <mreh> ahem... recompile
07:59:29 <kqrx> mreh: still the same problem
07:59:48 <MissPiggy> hi
07:59:49 <mreh> kqrx: You win a linker party
08:00:33 <mreh> kqrx: are you using ghc --make?
08:00:41 <mreh> o/
08:00:41 <kqrx> no, ghc -o
08:00:59 <pikhq> Don't do that.
08:01:06 <mreh> kqrx: use cabal to build the project or --make
08:01:18 <mreh> -o only really works with small toy projects
08:01:24 <mreh> or when you know what you're doing
08:01:44 <kqrx> okay
08:01:45 <kqrx> thanks
08:01:48 <kqrx> --make works fine
08:02:16 <mreh> kqrx: all you need to do is define a Main module, or use the -main-is option
08:02:31 <mreh> -main-is Foo.bar
08:03:02 * roconnor always uses ghc with --make
08:03:07 <mreh> as long as the type of Foo.bar is IO ()
08:03:10 <roconnor> and when that doens't work I also add --no-recomp
08:03:37 <mreh> it shouldn't recompile
08:03:43 <mreh> anyway
08:04:05 <mreh> it makes me wonder why we ever needed makefiles for C projects
08:04:37 <pikhq> Because C really, truly sucks at indicating dependencies.
08:04:41 <MissPiggy> because C doesn't have a module system
08:04:55 <MissPiggy> it would be simple to make some
08:04:56 <mreh> ah yes, that's whu
08:05:10 <MissPiggy> just put // DEPS foo.c ... and whatever on the first line of each file
08:05:13 * roconnor longs for Modula-3
08:05:24 <MissPiggy> then write a Metamakefile which compiles while it compiles...
08:08:44 <cebewee> mreh: I'm happy C projects need make. Or else we would not have this really useful tool
08:09:05 <FliPPeh> :t lookup
08:09:06 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:09:38 <mreh> cebewee: that doesn't make any sense
08:09:43 <mux> at least with C you don't need to parse & analyze stdout in order to determine if you need to run the compilation again (hint: LaTeX)
08:10:20 <mux> and C compilers have switches to output Makefile-like dependency files
08:10:21 <mreh> I always run pdflatex twice as a rule of thumb
08:10:42 <mux> mreh: I've had the need to run it three times
08:10:45 <roconnor> cebewee: *cough* *cough*
08:11:00 <cebewee> mreh: ghc --make can not replace make for all uses.
08:11:54 <mreh> I don't understand
08:12:06 <cebewee> make is a general purpose tool.
08:12:08 <MissPiggy> me neither
08:13:02 <cebewee> I used make for compiling images generated by another tool
08:13:41 <mreh> what does make actually do?
08:13:44 <mux> I used to use make as a placeholder for small scripts I used from my home directory
08:14:34 <chturne> I used make to torture filipino hostages.
08:14:39 <cebewee> mreh: Given a set of dependencies and a target, decide which files needs to be recompiled in which order
08:15:56 <cebewee> parallelizing this task if possible
08:16:35 <kuribas> :set -fno-print-bind-contents in ghci doesn't work...
08:16:52 <kuribas> It still prints the whole contents of the file...
08:16:56 <ablmf1> My code uses tail recursion, but I still got stack over flow : http://pastebin.com/m6588e20a
08:17:10 <ablmf1> Is there any way to make the code work?
08:17:13 <MissPiggy> ablmf1 forget tail recursion for haskell
08:17:31 <pozic> ablmf1: Haskell has a different kind of tail recursion.
08:17:41 <MissPiggy> unless you are coding in the strict subset
08:17:47 <MissPiggy> pozic might be clearer to just not call it tail recursion?
08:17:51 <Gracenotes> hm.. stack overflow? not just heap overflow?
08:17:54 <cebewee> make even is a declarative language ;)
08:18:09 <MissPiggy> ablmf1, to make it strict I think you can put bang patterns on the variables
08:19:01 <pozic> ablmf1: grab paper and pen and do the graph reduction on a an expression yourself.
08:19:02 <pikhq> Gracenotes: Well, Haskell never uses the C stack, so yes, heap. ;)
08:19:10 <ablmf1> I will Google "bang patterns" and "strict subset"
08:19:16 <pozic> ablmf1: you will see immediately why it doesn't work.
08:19:17 <Gracenotes> well, it does use its own stack
08:19:28 <Gracenotes> for one, you might consider using foldl' instead of foldr
08:19:45 <pozic> ablmf1: the "strict subset" won't get you anywhere.
08:19:45 <MissPiggy> ablmf1, what's an example number that it overflows on?
08:19:46 <MissPiggy> oh sorry you put one in there...
08:19:46 <MissPiggy> ablmf1, well you put {-# LANGUAGE BangPatterns #-}
08:19:46 <MissPiggy> ablmf1, but I just tried it out and it doesn't seem to actually fix the overflow
08:20:05 <MissPiggy> so let me think about this a bit harder and see what the real problem is
08:20:11 <ablmf1> D:\Code\haskell>problem14.exe
08:20:11 <ablmf1> Stack space overflow: current size 8388608 bytes.
08:20:11 <ablmf1> Use `+RTS -Ksize -RTS' to increase it.
08:20:21 <MissPiggy> ablmf1 yeah I'm seeing that too
08:21:02 <ablmf1> I am trying to solve problem 14 of euler project -- an online algorithm test
08:21:04 <Gracenotes> foldl' instead of foldr might kill some thunk-on-the-stackness
08:21:18 <Zao> I've got a lot (660k) of integers, which I want to do membership testing against. Are there any fancier structures than IntSet I could use?
08:21:25 <MissPiggy> Gracenotes got it! :(
08:21:36 <Zao> ablmf1: We're familiar with Project Euler.
08:22:35 <ablmf1> What's the difference between foldl and fold' ? is fold' more efficient?
08:22:35 <FliPPeh> I'm still looking for awesome Haskell VIM integration
08:22:36 <MissPiggy> lol I almost had it
08:22:36 <MissPiggy> ablmf1, yeah it was foldr maxCollatz' vs foldl' maxCollatz',
08:22:36 <MissPiggy> foldl' is like the strict version
08:22:36 <MissPiggy> which is good for numerics
08:22:37 <MissPiggy> @src foldl'
08:22:37 <MissPiggy> oops
08:22:37 <lambdabot> foldl' f a []     = a
08:22:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:22:39 <MissPiggy> foldl' (flip maxCollatz')
08:22:46 <Zao> ablmf1: Did you compile it with optimization?
08:22:52 <MissPiggy> that `seq` is basicalyl the same as a bang pattern
08:22:54 <FliPPeh> Like highlighting all identifiers that start with an uppercase letter
08:22:58 <FliPPeh> That'd be nice
08:23:32 <ablmf1> Zao: No, I just "ghc filename.hs"
08:23:57 <Zao> Throw an -O2 at it and see what happens.
08:24:24 <Zao> You might have to remove the old .hi, .o and .exe or touch your source file for it to rebuild.
08:24:25 <FliPPeh> ghc --make filename.hs ?
08:26:35 <pozic> I get: Ratio.%: zero denominator. Is there any way to get a better error message?
08:27:06 <MissPiggy> I think there was a trick which put source file locations into those error but I cannot remember what it was.. :/
08:27:58 <ablmf1> Thanks !  fold' make it work!
08:28:28 <pozic> MissPiggy: you can use __FILE__ macros if it is your own code.
08:31:50 <ablmf1> Oh, I see, foldr would create many thunks which would not be caculated until the end because haskell is *lazy*
08:31:52 <pozic> I am using the debugger currently. I did :back, and then :list, but I don't see the call which calls anything in Ratio.
08:33:00 <tARrAScH> Hello, why can't I write like this: ?
08:33:02 <tARrAScH> instance Show t => Show (MyType t) where show = myTypeShow
08:33:34 <pozic> tARrAScH: you can write that.
08:33:37 <pikhq> ablmf1: Yeah, that's exactly it.
08:33:49 <tARrAScH> it then gives some error msg like: (All instance types must be of the form (T t1 ... tn)  where T is not a synonym.
08:33:52 <pikhq> ablmf1: By using a strict fold, fewer thunks are evaluated at a time.
08:34:14 <pozic> tARrAScH: so, T is a type synomym.
08:34:21 <pozic> tARrAScH: er MyType
08:34:39 <tARrAScH> aha, I must be of the source type. I get it :)
08:34:54 <tARrAScH> they really should work on the compiler complaints :-/
08:35:47 <pozic> tARrAScH: no, they should not.
08:36:02 <pozic> tARrAScH: you are just not ready to read it yet.
08:36:36 <pozic> tARrAScH: if you know what all the componenets of that sentence mean, it is a very clear error message.
08:36:42 <pozic> components*
08:37:10 <tARrAScH> pozic: Hm. Ok, I might change my mind later :)
08:37:29 <yuuki> I heard that there was a talk about Haskell being the only possible purely functional language, or something to that effect
08:37:34 <yuuki> Does anyone know about this talk?
08:38:50 <pikhq> yuuki: Not the only one.
08:39:05 <pikhq> And it's only purely functional if you don't consider unsafePerformIO.
08:41:21 <MissPiggy> @goo what is a pure functional programming language
08:41:21 <lambdabot> Maybe you meant: google googleit do ghc todo yow
08:41:40 <pikhq> @faq Is Haskell purely functional?
08:41:40 <lambdabot> The answer is: Yes! Haskell can do that.
08:41:55 <pikhq> @faq Is Haskell imperative?
08:41:56 <lambdabot> The answer is: Yes! Haskell can do that.
08:42:01 <dqd> @do backflip
08:42:01 <lambdabot> backflip
08:42:06 <MissPiggy> lol
08:42:12 <pikhq> There you go -- straight from the mouth of the bot.
08:42:31 <tARrAScH> @faq randomString
08:42:31 <lambdabot> The answer is: Yes! Haskell can do that.
08:42:38 <tARrAScH> -..-
08:42:41 <MissPiggy> @faq Can haskell do that?
08:42:41 <lambdabot> The answer is: Yes! Haskell can do that.
08:43:28 <pikhq> @faq Can Haskell not do that?
08:43:28 <lambdabot> The answer is: Yes! Haskell can do that.
08:47:24 <ksf> tARrAScH, did it incidentally say something about -XTypeSynonymInstances?
08:47:55 <MissPiggy> There is a categorical interpretation of this construction. Let C be the category of integral domains and injective ring maps. The functor from C to the category of fields which takes every integral domain to its fraction field and every homomorphism to the induced map on fields (which exists by the universal property) is the left adjoint of the forgetful functor from the category of fields to C.
08:48:01 <MissPiggy> ^ wow
08:48:12 <MissPiggy> still don't know WHY you would want a categorical interpretation
08:49:20 <tARrAScH> ksf: Yes. It did
08:49:25 <ksf> MissPiggy, so people know when they use a zygohistomorphic prepromorphism so they can boost
08:49:47 <roconnor> MissPiggy: cause now you have a monad from integral domains to integral domains!
08:50:02 * hackagebot upload: numeric-prelude 0.1.3.2 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
08:50:22 <tARrAScH> ksf: Though, I realized I'm way out of my knowledge scope if I start to use strange flags, so I decided to ask you guys for help :)
08:50:35 <ksf> tARrAScH, if you enable that, ghc will accept your code, but you won't be able to write another instance for the base type of the type synonym as it's, after all, the same type.
08:51:02 <tARrAScH> ksf: Ah. Thanks, Now I know :)
08:51:02 <ksf> -XTypeSynonymInstances is purely syntactic
08:51:36 <ksf> you can do {-# LANGUAGE TypeSynonymInstances #-} on the top of your source file
08:52:16 <roconnor> MissPiggy: Adjoints appear to be awesome, but I don't really understand them well enough to understand why.
08:53:03 <roconnor> left ajoints of forgetful functors seem somewhat less awesome than other adjoints.
08:53:12 * MissPiggy neither..
08:53:37 <roconnor> but the Galois connection between subgroups and and subfields is definitely awesome.
08:54:00 <Kostafey> How can I index a list?
08:54:15 <roconnor> > [1,2,3]!!2
08:54:16 <lambdabot>   3
08:54:21 <Kostafey> map zip srcX [1..]
08:54:39 <roconnor> > [1,2,3]!!0
08:54:40 <lambdabot>   1
08:54:58 <Zao> Kostafey: Note that indexing a list is suboptimal in speed.
08:55:02 <Kostafey> Ineed index, that will bind to element
08:55:19 <roconnor> Zao:
08:55:22 <roconnor> Zao++
08:55:25 <Zao> What do you have and what do you want?
08:55:58 <Kostafey> I want to get subset of list
08:56:25 <Kostafey> then I need to know what index it wsa in previous version of list
08:56:46 <roconnor> > find 2 [1,2,3]
08:56:47 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
08:56:47 <lambdabot>    arising from the lite...
08:57:01 <roconnor> > findIndex (==2) [1,2,3]
08:57:02 <lambdabot>   Just 1
08:57:52 <roconnor> @type (findIndex .) . (==)
08:57:53 <lambdabot>     Couldn't match expected type `a -> Bool'
08:57:53 <lambdabot>            against inferred type `Bool'
08:57:53 <lambdabot>     Probable cause: `==' is applied to too many arguments
08:58:12 <roconnor> @pl \x -> findIndex (x==)
08:58:12 <lambdabot> findIndex . (==)
08:58:21 <roconnor> @type findIndex . (==)
08:58:22 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
08:58:41 <roconnor> I guess findIndex and (!!) are adjoint to each other :P
08:59:10 <Kostafey> How to produce [3,87,345,6] -> [(3,1),(87,2),(345,3),(6,4)]
08:59:17 <applicative> Kostafey: i think the simpleminded thing is to zip the first list with [0..], filter ( myPredicate.snd) (zip [0..] mylist   or am i missing something
08:59:48 <applicative> this will return the new list, paired with the old indices
08:59:55 <m0nkfish> > zip [3,87,345,6] [0..]
08:59:56 <lambdabot>   [(3,0),(87,1),(345,2),(6,3)]
09:00:05 <m0nkfish> or rather..
09:00:07 <m0nkfish> > zip [3,87,345,6] [01..]
09:00:07 <lambdabot>   [(3,1),(87,2),(345,3),(6,4)]
09:00:08 <ksf> it's not even simpleminded, it's fast and elegant
09:00:23 <applicative> its often like that with Haskell
09:00:34 <applicative> but then you hit a brick wall...
09:01:04 <Kostafey> It seems, it is a solution! A minute...
09:01:05 * hackagebot upload: SHA 1.4.1 - Implementations of the SHA suite of message digest functions (AdamWick)
09:02:37 <roconnor> how many implementations of SHA do we need?
09:03:21 <ksf> exactly one, fast, native one.
09:03:36 <ksf> ...that allows arbitrary chunking
09:06:13 <Guest60600> anyone got an example of using break from iteratee to break on a string?
09:07:13 <ksf> there's a couple in the sources themselves
09:08:16 <ksf> ...well "a couple" is most likely wrong.
09:08:19 <ksf> http://chneukirchen.org/blog/archive/2005/04/shift-reset-and-streams.html
09:08:22 <Guest60600> ksf: hmmmm
09:08:27 <ksf> ...wrong paste buffer...
09:08:39 <ksf> http://hackage.haskell.org/packages/archive/iteratee/0.3.1/doc/html/src/Data-Iteratee-Char.html#printLines
09:10:49 <mreh> how can I install a module if I can't build it because all the import statements refer to a module that doesn't yet exist in the package-list
09:10:59 <Kostafey> applicative: What brick wall do you mean?
09:11:18 <ksf> ...you install the dependency?
09:11:35 <mreh> ksf, it refers to itself
09:11:53 <FliPPeh> Whee, my rewrite of libmpd works.
09:12:06 <ksf> mreh, which package?
09:12:13 <FliPPeh> Just need to create some "beautifiers" and I could put it up on Hackage to replace the old libmpd
09:12:55 <applicative> Kostafey: I just meant that often the simple elegant thing works beautifully, but elsewhere, you end up with some inefficient monster; of course the true account is that the monster wasn't as elgant as it seemed.
09:12:59 <mreh> ksf, my package
09:13:36 <ksf> why do you need it to refer to itself/
09:13:38 <ksf> ?
09:14:29 <MissPiggy> I am starting to think that I need a very advanced type system for my language
09:14:42 <MissPiggy> that's not a good thought :|
09:16:34 <mreh> ksf, the imports are referring to files inside the package, but if I give the relative location it complains that the name of the module (Which is fully qualified) does not match the import
09:16:51 <mreh> code refers to its own package all the time
09:17:11 <mreh> indirectly most often
09:19:20 <mreh> FliPPeh have you contacted the maintainer
09:19:40 <mreh> there's no need to have two versions of something that does the same thing
09:23:15 <osaunders> Is it possible to use the name of a type in the default definition of a typeclass function?
09:23:30 <osaunders> Like show does?
09:24:58 <ksf> mreh, is your source-directory set properly?
09:25:36 <FliPPeh> mreh: I wasn't gonna put it up
09:25:44 <doserj> @type dataTypeName . dataTypeOf
09:25:45 <lambdabot> forall a. (Data a) => a -> String
09:25:50 <ksf> usually, stuff is in src/Module/Foo/Bar.hs , then use source-directories: src and import Module.Foo.Bar
09:25:50 <FliPPeh> I'm not experienced enough to write QUALITY software in Haskell
09:26:01 <applicative> jaspervdj: congratulations on maintaining your position in the Tron competition.
09:26:03 <FliPPeh> It works, but I doubt it will be "production safe"
09:26:12 * hackagebot upload: web-encodings 0.2.3 - Encapsulate multiple web encoding in a single package. (MichaelSnoyman)
09:26:17 <FliPPeh> I wrote it out of pure desperation because the old library doesn't work
09:26:35 <jaspervdj> applicative: thank you :-)
09:28:21 <ksf> *Main> let foo f = reset $ forM_ [1..3] $ \v -> shift $ \k -> f v >> k () in runIxContT (foo $ \x -> ilift $ print x) Prelude.return
09:28:27 <ksf> ...stuff starting to work out.
09:30:32 <Zeiris> You can define a type synonym with "type" - can you define a synonym for the constructor, too?
09:30:57 <ksf> not really
09:31:09 <ksf> ...you can write foo = Foo, but you won't be able to match on foo
09:31:16 <ksf> ...but construct things, of course.
09:31:45 <ksf> if you want to do really fancy stuff, have a look at fc-labels or such
09:32:52 <jontore> When using getArgs to read out arguments. How do you do type converting from IO String to String? And is it a good idea to do that ?
09:33:10 <ksf> you can't convert from IO a to a
09:33:18 <ksf> ...but you can use >>=
09:33:22 <ksf> :t (>>=)
09:33:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:33:48 <ksf> you pass it a function that gets the pure string, and must return something inside a monad, again.
09:34:03 <ksf> like, e.g. getArgs >>= return, which is a no-op
09:34:10 <ksf> (and one of the monad laws)
09:34:48 <ksf> or you could use do-notation, which'd then looks like this: do { args <- getArgs; print args }
09:35:01 <ksf> ( {;} can be replaced with layout)
09:35:15 <MissPiggy> does anyone have a really good prime factorizer for Integers?
09:35:25 <copumpkin> jaspervdj: still here?
09:35:34 <jaspervdj> copumpkin: yep
09:35:51 <MissPiggy> in haskel
09:36:01 <ksf> there's a quite straightforward translation between >>= and do-notation, and some people recommend starting out with the former to get a feeling for it.
09:36:10 <copumpkin> I'm trying to submit your template (completely unchanged) to the competition but it's rejecting it with the very informative: "Failed, output file MyTronBot was not created"
09:36:15 <copumpkin> have you come across that?
09:36:15 <ksf> getArgs >>= \args -> print args
09:37:05 <jaspervdj> copumpkin: hmm, well my template is not quite complete actually
09:37:18 <jontore> ksf. Ok, thank you.
09:37:28 <jaspervdj> copumpkin: let me check it
09:37:30 <copumpkin> jaspervdj: hmm? it compiles fine here. It just unconditionally makes the same move every time doesn't it?
09:37:45 <ksf> ...you can also do getArgs >>= print
09:39:16 * hackagebot upload: numeric-prelude 0.1.3.3 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
09:39:18 <Philonous1> jontore: a value of type IO a doesn't contain an a. It like a shell script that returns a. So to use it you write another shell script that uses the a and glue them together with (>>=) as ksf said
09:40:23 <jaspervdj> copumpkin: s/module MyTronBot where/module Main where/
09:40:48 <jaspervdj> copumpkin: if that works better, I'll change it in the blogpost
09:41:04 <copumpkin> jaspervdj: oh. hmm, I guess that could do it :)
09:41:12 <jontore> I'm trying to find the correct option and filename of the file to be compiled. With inptStr <- getArgs >>= parseOptions >>=  readFile . But I get the same error message each time...  Couldn't match expected type `IO a' against inferred type `[String
09:42:37 <copumpkin> jaspervdj: thanks, we'll see how this one goes :) gotta run now
09:43:09 <ksf> jontore, what's the type of parseOptions?
09:43:17 * hackagebot upload: formlets 0.7.1 - Formlets implemented in Haskell (DougBeardsley)
09:43:37 <jontore> ksf: parseOptions :: [String] -> String
09:43:56 <ksf> inptStr <- getArgs >>= readFile . parseOptions
09:44:17 * hackagebot upload: simgi 0.3 - stochastic simulation engine (MarkusDittrich)
09:44:33 <ksf> or, a bit longer, inputStr <- do {args <- getArgs; readFile (parseOptions args) }
09:45:05 <jontore> ksf. Tanks that did the trick :)
09:45:17 <ksf> or getArgs >>= return . parseOptions >>= readFile
09:45:58 <ksf> or readFile =<< parseOptions <$> getArgs
09:46:36 <ksf> (<$> is the same as fmap and defined in Control.Applicative (for historic reasons))
09:48:12 <ksf> ma =<< f <$> mb   ==   ma . f =<< mb   should be mentioned in monad tutorials
10:03:28 <interferon> i'd like to apply a function of type (String -> IO Double) to a list of items, with each item being handled in a separate thread or queue (like parMapM)
10:03:35 <interferon> are there any standard functions that will let me do this?
10:05:14 <FliPPeh> Hmmm
10:05:52 <FliPPeh> Can I define several functions called "parse" with all different return types and select the one I want to use by doing "val = parse :: SongList" ?
10:06:19 <pikhq> FliPPeh: Not without a typeclass.
10:06:22 <FliPPeh> Alright
10:06:46 <pikhq> Define a typeclass with a function "parse" as part of it, and you're fine.
10:07:03 <Alpounet> interferon, there is a mapM
10:07:07 <pikhq> Not entirely sure you should be doing that for this, but if you should, that's how you do it.
10:07:09 <Alpounet> that you may have to combine with forkIO
10:07:46 <FliPPeh> pikhq: Thanks, I don't have to do it, I just thought it would be nice
10:07:47 <kmc_> FliPPeh: why do you want that particular interface?
10:08:17 <FliPPeh> Well, I have different types like "MPDState" "MPDSong" and "MPDStatus", they all accept the same input parameters
10:08:21 <FliPPeh> But different outputs
10:08:29 <FliPPeh> Namely MPDState, MPDSong and MPDStatus
10:08:33 <kmc_> ah, you're parsing commands?
10:08:51 <FliPPeh> Not exactly parsing even, I've already splitted the results returned from the server :)
10:08:54 <FliPPeh> It's a simple format
10:09:15 <FliPPeh> Right [("file","Bloc_party-_02-_Helicopter.mp3"),("Time","220"),("Artist","Bloc Party"),("Title","Helicopter"),("Album","Silent Alarm"),("Track","2"),("Date","2005"),("Genre","Rock"),("Pos","1833"),("Id","1833")]
10:09:28 <FliPPeh> Just fill in the values in a nice record :)
10:09:39 <FliPPeh> A wrapper
10:10:04 <kmc_> how do you know which type to expect?
10:10:29 <FliPPeh> I'd call it in functions such as "currentSong", get the output in there and run the matching "parser" for it
10:10:58 <kmc_> and what's the benefit to all the parsers having the same name?
10:11:01 <osaunders> What are functors used for?
10:11:06 <FliPPeh>  currentSong = getResponse "currentsong" >> fillRecord
10:11:50 <kmc_> osaunders: the Functor class has only one member, which is a generalization of "map"
10:12:11 * FliPPeh likes the ZipList functor
10:12:26 <osaunders> FliPPeh: What's that?
10:12:30 <kmc_> osaunders: read the Typeclassopedia, it's an article from http://haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
10:12:52 <FliPPeh> osaunders: Like "zipWith" but with as many lists as you like!
10:13:07 <FliPPeh> 10 in my case
10:13:21 <osaunders> Nice
10:13:27 <FliPPeh> It even looks awesome
10:14:11 <FliPPeh> getZipList $ zipFunction <$> ZipList list1 <$> ZipList list2 <$> ... <$> ZipList listN
10:14:19 <kmc_> > getZipList $ (,,) <$> ZipList "abc" <*> ZipList "def" <*> ZipList "ghi"
10:14:20 <lambdabot>   [('a','d','g'),('b','e','h'),('c','f','i')]
10:14:22 <FliPPeh> s/<$>/<*>
10:14:45 <FliPPeh> :t (,,)
10:14:46 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
10:14:52 <FliPPeh> Oh, a tuple function?
10:14:57 <FliPPeh> :t (,,,,,)
10:14:58 <lambdabot> forall a b c d e f. a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
10:15:17 <FliPPeh> :t "Hello" (,,) "World"
10:15:18 <lambdabot>     Couldn't match expected type `t1 -> t2 -> t'
10:15:18 <lambdabot>            against inferred type `[Char]'
10:15:18 <lambdabot>     In the expression: "Hello" (,,) "World"
10:15:20 <kmc_> osaunders: since you asked what functors are used for (and not what they are), I'll mention that they're often used to map a function over a container of some kind
10:15:26 <FliPPeh> > "Hello" `(,,)` "World"
10:15:27 <lambdabot>   <no location info>: parse error on input `('
10:15:29 <FliPPeh> Aww
10:15:40 <kmc_> being a generalization of "map", which only works on lists.  for lists "map" and "fmap" do the same thing
10:15:53 <FliPPeh> > (,) "Hello" "World"
10:15:54 <lambdabot>   ("Hello","World")
10:15:58 <FliPPeh> :'D
10:15:59 <paper_cc> > let tuple = (,) in "Hello" `tuple` "World"
10:16:00 <lambdabot>   ("Hello","World")
10:16:10 <FliPPeh> Didn't know that one tbh
10:16:21 <FliPPeh> Nice to put split values in a tuple
10:16:21 <kmc_> however, there are functors that are not easily thought of as containers
10:17:02 <zygoloid> > (fmap (+2) (*3)) 42
10:17:03 <lambdabot>   128
10:17:42 <FliPPeh> Now, I'd like to test like 6 maybe values, and if any is Nothing, I'd like to abort - any useful function?
10:17:47 <FliPPeh> Like, maybe test on a lit?
10:17:49 <FliPPeh> list*
10:17:51 <kmc_> sequence?
10:17:57 <kmc_> > sequence [Just 3, Nothing, Just 8]
10:17:58 <lambdabot>   Nothing
10:17:58 <zygoloid> what result do you want?
10:18:14 <kmc_> > any isNothing [Just 3, Nothing, Just 8]  -- the simple way
10:18:15 <lambdabot>   True
10:18:23 <FliPPeh> simple way is good!
10:18:25 <FliPPeh> Thanks
10:21:27 * hackagebot upload: SHA 1.4.1.1 - Implementations of the SHA suite of message digest functions (AdamWick)
10:22:18 <FliPPeh> map (flip lookup f) ["Time", "Title", "Artist", "Album", "Foo"]
10:22:22 <FliPPeh> :)
10:22:38 <FliPPeh> it even works
10:35:57 <absentia> check out slide page 13... it's haskell!  http://bit.ly/94Zx6E
10:39:57 <absentia> (ya, right... he's gonna go to fortress.. but still).
10:40:10 <sm> nice
10:46:33 * hackagebot upload: jmacro 0.2 - QuasiQuotation library for programmatic generation of Javascript code. (GershomBazerman)
10:47:50 <thisnameisnottak> is there a compiler/lexer channel here on freenode?
10:47:53 <handonson> Can I read a Pixel of Surface in Haskell?
10:48:00 <handonson> Can I read a Pixel of Surface in Haskell SDL?
10:49:58 <Zao> handonson: If the bindings are similiar to the native library, and the native library exposes such functionality, then probably.
10:50:33 <handonson> Zao: no
10:50:35 * hackagebot upload: numeric-prelude 0.1.3.4 - An experimental alternative hierarchy of numeric type classes (HenningThielemann)
10:51:05 <handonson> in the original SDL for C, reading a pixel is done by (pointer to the surface starting point) + y * width + x
10:51:23 <handonson> not by an independent function
10:52:10 <handonson> thats why Pygame, a SDL binding for Python, has introduced new functions get_at/set_at for this, since there's no such thing as pointer in Python
10:52:35 * hackagebot upload: haskell-src-exts 1.8.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
10:52:36 <handonson> however in Haskell SDL, i really can't find any function that reads (gets)
10:52:54 <Lemmih> handonson: You probably have to write those functions yourself, then.
10:53:02 <Zao> handonson: In Python, you could expose it as a sequence or iterable.
10:53:10 <^adriatico> ArIeKkImE ...... >>> Salve a Tutti <<<  [JMI] []
10:53:10 <^adriatico> JhA MaN ReSpEcT _________CiaOOooo >>>  #haskell <<<
10:53:17 <Zao> So what's the name of the binding?
10:53:18 <kmc_> what the fuck
10:53:22 <^adriatico> Hello
10:53:24 <kmc_> @where ops
10:53:24 --- mode: ChanServ set +o Lemmih
10:53:24 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
10:53:25 <handonson> Zao: Graphics.UI.SDL
10:53:39 --- mode: ChanServ set +o monochrom
10:53:42 <handonson> Lemmih: like by altering the source code of Graphics.UI.SDL?
10:53:45 --- mode: monochrom set +b *!*@host157-176-dynamic.10-87-r.retail.telecomitalia.it
10:53:45 --- kick: ^adriatico was kicked by monochrom (^adriatico)
10:53:45 <kmc_> handonson: there are pointers in Haskell, though
10:54:14 --- mode: monochrom set -b *!*@host157-176-dynamic.10-87-r.retail.telecomitalia.it
10:54:21 <Zao> So  type Surface = ForeignPtr SurfaceStruct
10:54:30 <Zao> With data SurfaceStruct. That's rather opaque...
10:54:44 <Lemmih> Damn, I'm not fast enough on my guns.
10:54:45 <kmc_> so you're supposed to access it by pointer math, same as in C
10:55:16 <Zao> You can lock and unlock surfaces, it seems.
10:55:24 <kmc_> the type SurfaceStruct probably has no meaningful representation on the Haskell side
10:55:34 <Zao> kmc_: Struct in the name implies that it's a struct on the C side though.
10:55:42 <kmc_> yeah
10:55:57 <kmc_> indeed it's a type with no ctors in Haskell
10:56:11 <handonson> uhm... so what should I do?
10:56:14 <Zao> http://www.libsdl.org/cgi/docwiki.cgi/SDL_Surface <- those
10:56:28 <kmc_> handonson: use the functions in Foreign to manipulate memory directly
10:56:37 <kmc_> RWH has a great chapter on FFI
10:56:39 <kmc_> @where rwh
10:56:40 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:56:55 <Zao> peek a pointer from the right offset of the SurfaceStruct, and peek/poke into that pointer.
10:57:09 <Zao> Or use another library.
10:57:14 <handonson> Like?
10:57:18 <kmc_> OpenGL
10:57:19 --- mode: monochrom set -o monochrom
10:57:31 <kmc_> cairo
10:58:29 <Zao> I would submit a feature request to whoever maintains the SDL binding.
10:58:31 --- mode: Lemmih set -o Lemmih
10:58:40 <Zao> Or even better, a patch.
10:58:59 <kmc_> it looks like the SDL binding is, well, a binding, only
10:59:06 <handonson> [03:58:06]<Zao> I would submit a feature request to whoever maintains the SDL binding.
10:59:06 <handonson> [03:58:08]* Lemmih removes channel operator status from Lemmih
10:59:07 <kmc_> and so it'd be inappropriate to add functionality not in the underlying library
10:59:10 <handonson> LOL
10:59:13 <Lemmih> Zao: Don't get your hopes up. The hsSDL maintainer is a lazy bastard.
10:59:17 <kmc_> hahaha
10:59:39 <Zao> Lemmih: I guess he'll get a soulmate the day I finish bindings-directx :P
11:00:26 <Zao> Which currently is stuck on parsing "C".
11:01:48 <sinelaw> yo
11:01:53 <handonson> Okay. I'll try to write get_at/set_at functions for Haskell SDL, and hopefully submit the patch. Thanks all.
11:02:28 <Zao> handonson: Do note that one call for a single pixel is usually suboptimal.
11:02:31 <kmc_> i don't see why those would belong in the SDL library rather than a higher level library built on it
11:02:46 <Zao> handonson: Having one that would give you a Ptr to the pixels would be better.
11:02:50 <Cale> monochrom: That ban might have been a little quick. I think probably informing that guy to get his script under control rather than banning him would have been better.
11:02:55 --- mode: ChanServ set +o Cale
11:03:05 <Zao> kmc_: Except that such a higher level library can't be built on the current SDL bindings.
11:03:15 --- mode: Cale set -o Cale
11:03:15 <Zao> kmc_: As you don't have access to the struct fields.
11:04:46 <handonson> Zao: Having one that gives me a Ptr? How do I do that? Is that trivial due to the definition of Surface = ForeignPtr SurfaceStruct?
11:05:27 <kmc_> the question is what the memory layout at the other end of that pointer is
11:05:32 <Zao> handonson: Know the offset of the field in the struct, peek that field through a Ptr SurfaceStruct.
11:05:39 <Zao> Indeed.
11:05:50 <kmc_> it's determined by the C SDL library, and the Haskell code seems to have no knowledge of it
11:06:10 <kmc_> maybe the layout of that struct is considered part of the public API of SDL, in which case i don't see a problem
11:06:14 <Zao> It can probably be discerned from the same SurfaceStruct, but as it has no accessors...
11:06:31 <Zao> kmc_: The docs imply the beginning of it is.
11:06:46 <Zao> "it has these here fields, and a bunch of unknown private ones below, lol"
11:06:48 <Zao> Paraphrased.
11:07:30 <kmc_> SDL is a fairly nasty API as i recall
11:07:44 <kmc_> i used it a little to get an OpenGL context.  it didn't seem so worthwhile beyond that
11:07:54 <Zao> That's about right.
11:08:42 <kmc_> (that was in C++)
11:09:28 <handonson> Okay then... Should I use OpenGL for Haskell instead of struggling to make SDL work?
11:09:44 <handonson> I guess so.
11:09:50 <kmc_> handonson: you haven't told us what you're trying to do
11:10:03 <Lemmih> handonson: Why do you want to read from a Surface, btw?
11:10:15 <kmc_> i recommend doing your drawing through OpenGL rather than SDL, and that's totally independent of programming language
11:10:24 <kmc_> SDL might be a fine way to get a GL context and to get input, etc.
11:11:05 <Sgeo_> What good Parsec tutorials are there?
11:11:10 <kmc_> the Haskell OpenGL bindings are pretty good (actually, there's two sets: a nicer higher level API, and the "raw" wrapper that gives you every C function including all the extensions)
11:11:58 <luqui> the "nicer" higher level API is not so nice
11:12:16 <kmc_> why not?
11:12:22 <luqui> i mean it's not an unimprovement over the raw api, but it's not much of an improvement
11:12:56 <aief> http://worldtv.com/israel_in_eurovision/
11:13:01 <handonson> Lemmih: I want to do a simple anti-alias by myself since I don't like the default AA of SDL
11:13:02 <luqui> there is a lot of meaningless abstraction -- typeclasses for things you would never abstract over, arbitrary taxinomical categorization of operations that make them hard to find int he docs
11:14:20 <mm_freak_> i find it amazing how well haskell works on windows, but unfortunately there are no easy to install GUI libraries
11:15:00 <sinelaw> sdl?
11:15:10 <handonson> Graphics.UI.Win32
11:15:11 <handonson> ...
11:15:14 <kmc_> hahaha
11:15:29 <luqui> mm_freak_, GLUT is what you've got
11:15:41 <burp> gtk2hs should also work
11:15:49 <Cale> Isn't wxhaskell installable from hackage?
11:15:53 <kmc_> the world of GUI libraries for Haskell seems to be a generally unhappy place
11:15:55 <sinelaw> What document class do people usually use for haskell latex papers?
11:16:03 <mm_freak_> luqui: well, i'm talking about widgets, not GL
11:16:10 <sinelaw> hey luqui
11:16:10 <luqui> oh yeah, realized that
11:16:13 <burp> even qthaskell should work
11:16:25 <luqui> sinelaw, hello
11:16:26 <Cale> cabal install wx
11:16:30 <mm_freak_> burp: gtk2hs is very difficult to install under windows
11:16:35 <burp> mm_freak_: ok
11:16:42 <Arnar> sinelaw: article.. or whatever fits the purpose of the paper
11:16:45 <burp> you only need to do it once ;)
11:16:47 <handonson> kmc_: well, i am trying to make a simple script that draws a flow chart out of a (presumably XML) file, and I know that there are already good tools for this, but I thought I'll just do it all by myself to learn Haskell more this time
11:17:00 <mm_freak_> burp: sure, but i failed to do it once =)
11:17:04 <sinelaw> luqui, sup? i updated to your most recent commit and now my app shows a blank screen
11:17:04 <burp> ok :D
11:17:36 <luqui> sinelaw, *most* recent.  1.2.0 had a stupid bug that broke everything.  fixed in 1.2.1
11:17:44 <luqui> s/\./?/
11:17:53 <hzap> wxhaskell isn't very easy to install either
11:17:57 <dankna> gtk2hs is very difficult to install on the Mac, too, heh
11:18:06 <sinelaw> handonson, you can use the graphviz package for haskell, by building your graph in fgl (a graph package for haskell)
11:18:12 <sinelaw> luqui, ok i'll try
11:18:13 <hzap> cabal install wx fails when I tried it
11:18:16 <Zao> gtk2hs is trivially installable with the installer on Windows, assuming you use the same GHC version.
11:18:53 <handonson> GTK+ itself is a nightmare on Windows env. It is slow, un-native, and ugly
11:19:13 <sinelaw> handonson, in my opinion graphviz is a good shot for flowcharting
11:20:37 <handonson> sinelaw: I do want to draw flow charts, but what I want to draw is something that doesn't look like a traditional flow chart. That's why I wanted some low-level access to the screen, like SDL.
11:20:40 <mm_freak_> Zao: yes, but if the build fails, you're lost
11:21:22 <`Zerax`> Speaking of which when is the next haskell platform with 6.12 likely to be available?
11:21:41 <sinelaw> handonson, i happen to be working on a visual graph editor (very early in the work, though) but what is it that you want to do manually?
11:21:43 <Zao> mm_freak_: What build?
11:21:48 <sinelaw> luqui, thanks! works now
11:21:51 <sshc> platform?
11:22:58 <mm_freak_> Zao: you mean it doesn't need to be built?
11:23:10 <sshc> the most recent GHC is very usable.  It works with parsec and hbc
11:23:15 <sshc> hdbc
11:23:27 <sshc> but darcs doesn't build on it yet
11:23:40 <Zao> mm_freak_: Correct. It installs a prebuilt package.
11:23:45 <Cale> Heh, the build failure with wxcore seems to be caused by an erroneous type signature.
11:23:55 <Zao> mm_freak_: No msys, no silly gtk libs/headers, etc.
11:24:36 <sinelaw> handonson, my app uses GL to draw, and SDL for input (but i want to use a GLUT wrapper eventually for portability)
11:24:43 <Cale> I commented out the type signature for 'myConfHook' in Setup.hs, and it worked.
11:24:57 <handonson> sinelaw: some gfx like shadows, glows, bevel effects, alpha blending, blur, ...
11:24:58 <`Zerax`> My problem is that the new ghc doesn't seem to work with the old cabal install binary. Due to the format of the ghc-pkg dump changing, to build the new cabal from darcs requires me to download and install a bunch of packages, and the bootstrapper won't work on windows. So I'm looking forward to the new haskell platform :)
11:24:59 <sinelaw> handonson, actually it uses luqui's lib that wraps GL very nicely functional
11:25:35 <sinelaw> handonson, so we're working on something similar :)
11:26:41 <burp> @source subsequences
11:26:41 <lambdabot> subsequences not available
11:27:00 <mm_freak_> Zao: so it installs GTK, too?
11:27:16 <Zao> mm_freak_: I assume it does.
11:27:25 <luqui> > (inits <=< tails) [1,2,3,4,5]
11:27:26 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[],[2],[2,3],[2,3,4],[2,3,4,5],...
11:27:27 <Zao> I haven't used it in a good while.
11:27:34 <luqui> ^ burp
11:27:55 <Cale> subsequences xs         =  [] : nonEmptySubsequences xs
11:27:56 <burp> oh that looks nice
11:28:00 <Cale> nonEmptySubsequences []      =  []
11:28:01 <Cale> nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
11:28:01 <Cale>   where f ys r = ys : (x : ys) : r
11:28:05 <burp> Cale: yes, just looked it up, thanks :)
11:28:26 <Cale> It's not the same thing as (inits <=< tails)
11:28:48 <luqui> yeah there are some garbage []s in inits <=< tails
11:29:20 <Cale> > subsequences [1..5]
11:29:21 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
11:29:28 <sinelaw> > ["aha "..]
11:29:29 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
11:29:29 <lambdabot>    arising from the arithm...
11:29:31 <luqui> oh it's very different
11:29:43 <sinelaw> > cycle "aha "
11:29:44 <lambdabot>   "aha aha aha aha aha aha aha aha aha aha aha aha aha aha aha aha aha aha ah...
11:29:50 <mm_freak_> Zao: thanks, that's going to be useful
11:29:50 <sinelaw> > word . cycle $ "aha "
11:29:52 <lambdabot>   Not in scope: `word'
11:29:54 <sinelaw> > words . cycle $ "aha "
11:29:55 <lambdabot>   ["aha","aha","aha","aha","aha","aha","aha","aha","aha","aha","aha","aha","a...
11:30:02 <sinelaw> lazy :) gotta love lazy
11:30:34 <roconnor> > transpose [[1..],['A'..]]
11:30:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:30:35 <lambdabot>    arising from the literal `1...
11:30:51 <diegoeche> Hi... is it possible to create an instance of Functor for tuples of the form (a,a)?
11:30:58 <sinelaw> Does ByteString.words work lazily, or do i need lazy bytestrings?
11:31:07 <roconnor> diegoeche: if you newtype it you can.
11:31:13 <roconnor> diegoeche: it is even a monad
11:31:27 <roconnor> > transpose [[1 ..],['A'..]]
11:31:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:31:28 <lambdabot>    arising from the literal `1...
11:31:44 <roconnor> > [1..]
11:31:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:31:51 <roconnor> > ['A'..]
11:31:52 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
11:31:59 <diegoeche> I was trying to use: type Tuple' a = (a, a) with -XTypeSynonymInstances
11:32:09 <roconnor> > [[1 ..],['A'..]]
11:32:10 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:32:10 <lambdabot>    arising from the literal `1...
11:32:17 <roconnor> ?
11:32:17 <Sgeo_> How does lambdabot's plugin system work? DOes it need to be reloaded to see a new plugin?
11:32:24 <roconnor> diegoeche: why not use a newtype?
11:32:28 <tARrAScH> roconnor: what type would that list have? a list of different types aint possible afaik
11:32:39 <roconnor> tARrAScH: ah god
11:32:45 <roconnor> I'm dumb
11:33:03 <roconnor> > transpose [[1 ..],[2..]]
11:33:04 <tARrAScH> roconnor: Sooner or later, we all are. :)
11:33:05 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12...
11:33:05 <diegoeche> roconnor: I'm not really Haskell savvy
11:33:22 <roconnor> diegoeche: don't use any extensions until you are savvy :D
11:33:50 <roconnor> except maybe --nomonomorphisimsrestriction
11:34:13 <luqui> roconnor, pair is a monad?  that seems unlikely
11:34:17 <luqui> what is join?
11:34:23 <handonson> sinelaw, what is the difference between using GLUT and using SDL?
11:34:27 <roconnor> luqui: join ((a,b),(c,d) = (a,d)
11:34:40 <luqui> oh diagonal, of course!
11:34:48 <roconnor> luqui: (a,a) is isomorpich to Bool -> a and (Bool ->) is a reader monad
11:34:49 <luqui> duh, it's the (Bool ->) monad :-P
11:34:51 <sinelaw> handonson, sdl is less portable (doesn't work on macs i think)
11:35:01 <handonson> what?
11:35:03 <handonson> ...
11:35:16 <sinelaw> or on some versions of Os X or something
11:35:17 <sinelaw> dunno
11:35:37 <diegoeche> using newtype forces me to add an additional constructor?
11:35:48 <sinelaw> handonson, that's what i've been told, maybe the are referring to sdl in haskell specifically
11:35:50 <roconnor> diegoeche: yes, but it will be removed at compile time
11:35:53 <sinelaw> *they
11:36:05 <handonson> I thought SDL was like the most portable media library ever
11:36:12 <roconnor> diegoeche: so there will be no performance impact
11:36:31 <roconnor> at least very little performance impact ...
11:37:21 <diegoeche> well... I was looking for an idiomatic fmap for tuples. Normal tuples.
11:37:35 <kmc_> then it's not possible
11:37:43 <roconnor> diegoeche: well, (a,b) in general doesn't have an fmap
11:37:56 <roconnor> diegoeche: you are really looking at a restriction of the (a,b) type
11:37:59 <kmc_> a Functor must be a type of kind * -> *
11:38:12 <kmc_> :t join (&&&)
11:38:13 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
11:38:15 <roconnor> which means you will need to give it a name in order for it to have type classes.
11:38:17 <kmc_> :t join (***)
11:38:19 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:38:26 <roconnor> and generally naming it is just good  software practice
11:38:27 <sinelaw> handonson, so did I, but that's second-hand knowledge there. you can verify with luqui
11:38:27 <kmc_> there's your pair fmap :)
11:39:03 <pielgrzym> hi there
11:39:16 <luqui> sdl bindings do not compile easily on windows
11:39:22 <luqui> they are a pain to use under cocoa
11:39:23 <diegoeche> neat... arrows always helping me :)
11:39:43 <luqui> sdl in general is a pain to use under cocoa, it is not a haskell-specific thing.  windows problems are haskell's fault though.
11:40:00 <pielgrzym> could someone point me to a site explaining the $ sign? ;) stuff = somevar $ somestuff { (...) } ??
11:40:05 <kmc_> @src ($)
11:40:05 <lambdabot> f $ x = f x
11:40:15 <kmc_> pielgrzym: it's a regular infix operator
11:40:25 <kmc_> which has the same meaning as function application
11:40:52 <pielgrzym> kmc_: you mean, it's like running function somestuff { } ?
11:41:06 <kmc_> "somevar $ somestuff { (...) }" is "somevar (somestuff { (...) })"
11:41:12 <kmc_> we don't "run" functions though
11:41:33 <pielgrzym> this language is fascinating :) totally different than anything else :)
11:41:37 <kmc_> in general "f $ x y z" is "f (x y z)"
11:41:47 <pielgrzym> aah
11:41:49 <pielgrzym> I see
11:41:50 <kmc_> but $ is not special syntax -- it's a regular user defined operator like (+)
11:41:57 <kmc_> so you can use it in other contexts
11:41:59 <roconnor> wheras f x y z is ((f x) y) z
11:42:01 <kmc_> > map ($ 3) [pred, succ]
11:42:02 <lambdabot>   [2,4]
11:42:05 <handonson> what is the name of that higher-level library for OpenGL?
11:42:09 <kmc_> OpenGL
11:42:12 <roconnor> @pl ($)
11:42:13 <lambdabot> id
11:42:14 <kmc_> as opposed to OpenGL-raw or whatever
11:42:15 <roconnor> :)
11:42:19 <handonson> i see.
11:42:23 <pielgrzym> roconnor: whooah:D
11:42:28 <kmc_> > map (`id` 3) [pred, succ]
11:42:29 <lambdabot>   [2,4]
11:42:32 <kmc_> hehe
11:42:35 <sinelaw> handonson, if you're referring to what i named, it's graphics-drawingcombinators
11:42:38 <kmc_> :t  (`id` ())
11:42:39 <lambdabot> forall t. (() -> t) -> t
11:42:42 <roconnor> > f $ g x y
11:42:43 <lambdabot>   Ambiguous occurrence `x'
11:42:43 <lambdabot>  It could refer to either `L.x', defined at <local...
11:42:46 <roconnor> @undef
11:42:48 <roconnor> > f $ g x y
11:42:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:42:49 <lambdabot>    `GHC.Show.Show a'
11:42:49 <lambdabot>      a...
11:42:53 <sinelaw> handonson, it wraps 2d opengl with a functional interface
11:42:55 <roconnor> > f $ g x
11:42:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:42:56 <lambdabot>    `GHC.Show.Show a'
11:42:56 <lambdabot>      a...
11:43:02 <roconnor> hmm
11:43:15 <handonson> so that one was what you were talking about!
11:43:27 <sinelaw> yes
11:43:28 <sshc> is there any way to determine if a quickCheck check passed?
11:43:47 <handonson> i hesitated to try it because it said it was experimental at the point
11:45:41 <MissPiggy> hmm
11:46:00 <MissPiggy> I suppose there is grobner basis in haskell already
11:46:00 <diegoeche> roconnor: is the tuple instance of monad defined already?
11:46:33 <roconnor> diegoeche: no, because it doesn't have the right kind
11:46:36 <roconnor> @kind (,)
11:46:37 <lambdabot> * -> * -> *
11:46:54 <tARrAScH> @paste
11:46:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:46:56 <diegoeche> what I mean is, is there already a standard newtype?
11:47:07 <roconnor> diegoeche: not to my knowledge.
11:47:17 <MissPiggy> it's just  e(,) a  ?
11:47:18 <MissPiggy> oops
11:47:18 <MissPiggy> without the e
11:47:40 <roconnor> MissPiggy: different one than diegoeche is thinking of
11:47:52 <sinelaw> handonson, i'm using it
11:48:01 <sinelaw> it is still experimental, i guess
11:48:14 <sinelaw> and incomplete (doesn't wrap much yet)
11:48:22 <sinelaw> but i really like what it _does_ do
11:49:23 <tARrAScH> One question, can fun4 be considered to be pure/ no side-effects? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7066#a7066
11:49:58 <diegoeche> If I wanted to build instances using newtypes for (a,a), (a,a,a), (a,...) Is it right that I can use template haskell for that?
11:51:03 <monochrom> Yes.
11:51:19 <MissPiggy> tARrAScH: what does it even mean
11:51:36 <tARrAScH> MissPiggy: it?
11:51:46 <MissPiggy> tARrAScH: whether anything is pure or not is just a matter of what abstraction you use to think about it
11:52:02 <roconnor> diegoeche: I presume so
11:52:27 <Berengal> tARrAScH: Everything in Haskell is pure with an abstract enough perspective
11:52:44 <tARrAScH> MissPiggy: Ok, if I define pure as no side-effects then?
11:52:48 <Berengal> And fun4 is just a value. It's just as pure as any other value
11:52:57 <tARrAScH> Berengal: hmm, would you be able to say the same thing about anyhting, even assembler?
11:53:02 <benmachine> > f $ g x y :: Expr
11:53:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:53:04 <lambdabot>    `SimpleReflect.FromExpr ...
11:53:13 <benmachine> > f $ (g x y :: Expr) :: Expr
11:53:14 <lambdabot>   f (g x y)
11:53:24 <diegoeche> well, Thanks!
11:53:41 <Berengal> tARrAScH: With an even more abstract perspective, yes.
11:53:56 <Berengal> But fun4 doesn't do anything
11:54:11 <Berengal> It just is
11:54:12 <monochrom> define "side-effect"
11:54:41 <sinelaw> handonson, if you can convert your xmlized data to an FGL graph, i can give you code that lays it out using graphviz renders it using that lib
11:54:55 <tARrAScH> Yea. That's right, It's just that the first day I glanced upon haskell I first simply thought: IO involved -> unpure
11:55:02 <benmachine> > fix (("define" ++) . show)
11:55:03 <lambdabot>   "define\"define\\\"define\\\\\\\"define\\\\\\\\\\\\\\\"define\\\\\\\\\\\\\\...
11:55:08 <benmachine> oh hmm
11:55:13 <benmachine> > text $ fix (("define " ++) . show)
11:55:16 <tARrAScH> monochrom: oh comon ...
11:55:19 <sinelaw> handonson, but as i said its an early work in progress
11:55:20 <benmachine> aw
11:55:22 <lambdabot>   mueval: ExitFailure 1
11:55:29 <benmachine> > fix (("define " ++) . show)
11:55:34 <lambdabot>   mueval-core: Time limit exceeded
11:55:37 <benmachine> hmm
11:55:42 <Berengal> tARrAScH: purity means referential transparancy, usually. There's a formal definition somewhere
11:55:53 <benmachine> oh I suppose that makes sense
11:56:03 <benmachine> err does it
11:56:18 <tARrAScH> Berengal: That's a very good definition!
11:56:34 <tARrAScH> (no irony, I really think so)
11:56:57 <Berengal> In this case you can always replace any occurence of "fun4" by its definition
11:57:02 <IceDane> This might seem a strange question, but bear in mind that I'm trying to understand monads(I thought I had them yesterday -_-), and from my perspective, it's like reading chinese. If I define an algebraic datatype similar to the Maybe type, is it only a monad if it fulfills the monad laws?
11:57:04 <handonson> sinelaw: that sounds cool
11:57:23 <sinelaw> handonson, http://github.com/sinelaw/graphui
11:57:32 <ben> IceDane: It is only a monad if you explicitly make it an instance of the Monad typeclass.
11:57:45 <benmachine> IceDane: you need to do instance Monad YourType where ... *and* satisfy the laws
11:57:47 <pumpkin> hah, the world's dumbest AI won a game somehow
11:57:51 <sinelaw> for a start you can try building and running that :) hasn't been tried on many machines yet
11:58:00 <benmachine> pumpkin: whatever happened to your co?
11:58:06 <sinelaw> (just run cabal install)
11:58:08 <kmc_> tARrAScH: functions that return IO-types are still pure functions
11:58:08 <pumpkin> benmachine: depends what computer I'm using :)
11:58:13 <monochrom> tARrAScH: Does "comon" mean I shall use my definition even though it disagree with yours? Then OK, using my view, fun3 is side-effectful and fun4 is not. Using kmc_'s view, both fun3 and fun4 are pure. Are you happier now? Do you understand more now, or less?
11:58:13 <benmachine> oh right
11:58:17 <MissPiggy> IceDane: well if you define something the same as maybe then you can just give it the same monad instance
11:58:26 <sinelaw> handonson, actually first run cabal update, then cabal install
11:58:31 <Berengal> tARrAScH: And that holds true for everything else in Haskell. In impure languages though, you can't expand "char x = getChar(); print(x + x)" with "print(getChar() + getChar());"
11:58:33 <monochrom> P.S. I hate people who say "come on". They don't think it through.
11:58:38 <sinelaw> come on
11:58:48 <kmc_> Haskell has side effects.  but they are not the result of function application or evaluation
11:58:55 <kmc_> they are the result of "execution", a different thing
11:59:21 <sinelaw> execution sounds gruesome, come to think of it
11:59:33 <kmc_> yup
11:59:46 <handonson> i'm installing OpenGL for Haskell now, being freaked out by how many files have to be compiled
12:00:24 <sinelaw> hold on to your pants, there's sdl too
12:00:30 <sinelaw> (or skirt) :P
12:00:44 <medfly> or boxers
12:00:52 <sinelaw> that qualifies as pants in my book
12:01:25 <sinelaw> same-language dudette
12:01:34 <medfly> hehe :)
12:01:53 <tARrAScH> monochrom: True. I didn't think it through. But it's not cause I'm lazy nor stupid. It's often wise to in a learning stage not try to grasp everything and answer every question. I for sure have no understood side effects completely, but I'm probably going to understand it in a steady rate if I'm rational in my education speed rather than blow my mind with thought it's not ready to understand.
12:02:21 <kmc_> tARrAScH: i recommend against calling a function "impure" simply because it returns a value with an IO type
12:02:24 <medfly> I think someone once said, that if your mind is not blown then you are not studying fast enough
12:02:55 <MissPiggy> the point is you can view one object in multiple ways
12:02:56 <sinelaw> or driving fast enough
12:02:58 <kmc_> that encourages false intuition, specifically the idea that IO is a "tag" on a function type that marks the function as impure
12:03:00 <medfly> "see, there are recipes and there is cooking..."
12:03:00 <monochrom> tARrAScH: All I said was "define side-effect".
12:03:06 <tARrAScH> kmc_: Yea. I think I know why you say so. And the arguement is very calid.
12:03:12 <handonson> sinelaw: Haskell SDL wasn't that hassle to cabal install
12:03:34 <medfly> "writing a recipe for something is not like executing it..."
12:03:34 <sinelaw> cool
12:03:44 <sinelaw> gruesome
12:03:48 <tARrAScH> monochrom: And my answer is simply that going into details isn't beneficial for me at the moment (from a learning perspective).
12:03:48 <Berengal> tARrAScH: To understand purity at a basic, instinctive level, just remember that when "x = y", if you can s/x/y/g without changing the meaning, it's pure.
12:03:52 <sinelaw> i will never be able to talk about "executing" things again
12:03:54 <kmc_> also it is even sketchier to generalize this "pure / impure" terminology to monads besides IO, as some people do (including myself from time to time)
12:04:02 <kmc_> now every function that returns a list is 'impure' ;)
12:04:41 <Saizan> it is!
12:04:42 <sinelaw> heh, a humanist motive for using haskell: other languages execute, this one only evaluates
12:04:45 <tARrAScH> monochrom: But yes you're right, just saying "comon" was a bit unthoughtful from my side.
12:04:48 <medfly> hehehe
12:04:50 <sinelaw> (well, not exactly)
12:05:02 <Berengal> kmc_: From the perspective of the list, it is, but not from outside
12:05:07 <Berengal> ... perhaps State is a better example
12:06:39 <FliPPeh> Oh gott, filling a 15-fielded-record
12:06:52 <FliPPeh> Why, oh why can't this be done automatically?
12:07:00 <tARrAScH> Berengal: Yup, that's a good enough definition for me at this moment.
12:07:01 <medfly> a what?
12:07:33 <Berengal> FliPPeh: let x1 = ..; x2 = ..; xn = .. in Record{..}
12:07:53 <Berengal> Where x1 .. xn are the fields in Record
12:08:17 <kmc_> FliPPeh: if you want to convert from dynamic labels (strings) to static record labels, without building the mapping yourself, you'll have to use something like Template Haskell
12:08:27 <kmc_> you could however build the mapping yourself in one place, and use it throughout
12:08:28 <olsner> hmm, is that record puns or some other syntax extension?
12:08:34 <kmc_> wildcards
12:09:06 <MissPiggy> guh
12:09:17 <monochrom> let x = Record{} fills in all 15 fields automatically.
12:09:31 <Berengal> with undefined
12:09:54 <monochrom> Think of it as the computer automatically figures out what you want.
12:10:19 <kmc_> what you want is a runtime error?
12:10:39 <Berengal> Can never get enough of those...
12:10:45 <kmc_> > fix error
12:10:45 <monochrom> It is sarcasm to "why can't this be done automatically"
12:10:46 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:11:04 <Berengal> > fix records
12:11:05 <lambdabot>   Not in scope: `records'
12:11:06 <medfly> why is fix called fix
12:11:16 <Berengal> medfly: It finds the fixed point
12:11:23 <Berengal> The least defined such
12:11:25 <monochrom> because http://www.vex.net/~trebla/haskell/fix.xhtml
12:11:32 <sinelaw> @type intersparse
12:11:37 <lambdabot> Not in scope: `intersparse'
12:11:38 <sinelaw> @type intersperse
12:11:39 <lambdabot> forall a. a -> [a] -> [a]
12:11:46 <tARrAScH> > fix error
12:11:48 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:11:51 <tARrAScH> is that a joke?
12:12:07 <monochrom> It is a consequence.
12:12:23 <sinelaw> > intersperse " " ["hi","there","bot"]
12:12:24 <lambdabot>   ["hi"," ","there"," ","bot"]
12:12:29 <sinelaw> > concat . intersperse $ " " ["hi","there","bot"]
12:12:30 <lambdabot>   Couldn't match expected type `[[a]]'
12:12:30 <lambdabot>         against inferred type `[a1] ->...
12:12:45 <sinelaw> > concat . intersperse " " $ ["hi","there","bot"]
12:12:47 <lambdabot>   "hi there bot"
12:12:50 <kmc_> > fix (\fact n -> case n of 0 -> 1; _ -> n * fact (n-1)) 5
12:12:51 <lambdabot>   120
12:12:58 <kmc_> ^^^^ anonymous recursion using "fix"
12:13:32 <kmc_> > let fact = \n -> case n of 0 -> 1; _ -> n * fact (n-1) in fact 5
12:13:33 <lambdabot>   120
12:13:40 <kmc_> ^^^^ nonymous recursion using "let"
12:13:49 <monochrom> Oh I still haven't written my "recursion is least fixed point" tutorial
12:13:57 <tARrAScH> fix (\x -> 2*x)
12:14:01 <tARrAScH> > fix (\x -> 2*x)
12:14:05 <lambdabot>   mueval-core: Time limit exceeded
12:14:06 <kmc_> @src fix
12:14:07 <lambdabot> fix f = let x = f x in x
12:14:25 <kmc_> > fix ('x':)
12:14:26 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
12:14:45 <kmc_> > fix ((0:) . scanl (+) 1)
12:14:46 <tARrAScH> > fix (\_ -> 0)
12:14:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:14:47 <lambdabot>   0
12:15:38 <kmc_> @quote _pizza_
12:15:38 <tARrAScH> kmc_ , lol, It would be fun to write that to create the fib-seq at my first haskell-lab at school ^^
12:15:38 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
12:15:46 <monochrom> haha
12:16:14 <sinelaw> > words " ah"
12:16:15 <lambdabot>   ["ah"]
12:16:37 <olsner> tARrAScH: there are way weirder ways to write that with fix :P
12:16:45 <Berengal> > fix ((0:) . map (uncurry (+)) . zip`ap`tail)
12:16:46 <lambdabot>   Precedence parsing error
12:16:46 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
12:16:48 <aavogt> it doesn't seem possible to use both optimizations and assertions with GHC?
12:16:53 <Berengal> > fix ((0:) . map (uncurry (+)) . (zip`ap`tail))
12:16:56 <tARrAScH> olsner: I bet :p
12:16:57 <lambdabot>   mueval-core: Time limit exceeded
12:17:13 <tARrAScH> kmc_ what complexity does that fib-seq function have?
12:17:20 <Berengal> > fix ((0:1:) . map (uncurry (+)) . (zip`ap`tail))
12:17:21 <lambdabot>   The operator `:' [infixr 5] of a section
12:17:21 <lambdabot>      must have lower precedence th...
12:17:24 <aavogt> I guess I could just call error, but there's quite some convenience due to the line numbers that ghc adds when an assertion fails
12:17:25 <Berengal> Gah
12:17:44 <Berengal> > fix (([0,1]++) . map (uncurry (+)) . (zip`ap`tail))
12:17:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:17:58 <olsner> > fix$(<$>)<$>(:)<*>((<$>((:[{- foo -}])<$>))(=<<)<$>(*)<$>(*2))$1 -- not fib, but my favourite, tARrAScH :)
12:18:00 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
12:18:13 <MissPiggy> > square . [1.]
12:18:14 <lambdabot>   Not in scope: `square'A section must be enclosed in parentheses thus: (1 .)
12:18:14 <MissPiggy> > square . [1..]
12:18:15 <lambdabot>   Not in scope: `square'
12:18:41 <MissPiggy> > (2**) . [0..]
12:18:42 <lambdabot>   [1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0,512.0,1024.0,2048.0,4096.0,8192...
12:18:45 <tARrAScH> > map (\x->x*x) [1..]
12:18:46 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
12:18:51 <Sgeo_> ..how did that happen?
12:19:05 <Sgeo_> How does . do th.. oh, i. was redefined in Caleskell?
12:19:12 <kmc_> :t (.)
12:19:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:19:17 <Sgeo_> Yeah
12:19:17 <monochrom> Heh
12:19:18 <kmc_> (.) is fmap
12:19:19 <MissPiggy> yeah (.) = map
12:19:27 <aavogt> @type map
12:19:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:19:30 <olsner> Sgeo_: welcome to the magical wonderland of caleskell
12:19:41 <DigitalKiwi> what is caleskell?
12:19:42 <MissPiggy> map :: (a -> b) -> (f a -> f b)
12:19:43 <osaunders> Sgeo_: It's alt-stdlib not Caleskell.
12:19:45 <tARrAScH> O_O
12:19:59 <Sgeo_> People might try things in Caleskell, they work, and in the Standard Prelude, things will fail
12:20:00 <kmc_> the best type for (.) would be (Category (~>)) => (b ~> c) -> (a ~> b) -> (a ~> c)
12:20:12 <tromp> > fix (scanl (+) 0  . (1:))
12:20:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:20:17 <MissPiggy> Sgeo oh no! they would die
12:20:19 <osaunders> DigitalKiwi: It doesn't exist.
12:20:29 <tARrAScH> the more I learn the more I realize I know nothing about Haskell and FP
12:20:32 <DigitalKiwi> what would it be if it did?
12:20:51 <Sgeo_> DigitalKiwi, Cale's version of the Prelude, intended to help beginners
12:20:51 <osaunders> DigitalKiwi: http://trac.haskell.org/alt-stdlib
12:21:02 <osaunders> It's not just Cale's
12:21:14 <aavogt> Sgeo_: well if they are around here to find out that such things work, they can just as easily ask why?
12:21:32 <tARrAScH> > (*2) . [0..]
12:21:33 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
12:21:35 <MissPiggy> anyone have some refs on implementing type systems with CHR?
12:22:11 <kmc_> what's CHR?
12:22:31 <ben> if this ~> thing catches on, I am going to have to look into getting a font that does not render the ~ at the top of the line :/
12:22:32 <MissPiggy> kmc_, it's this cool declarative language
12:22:39 <kmc_> ben: yeah
12:22:50 <Cale> Please stop referring to Caleskell.
12:22:55 <Cale> It doesn't exist.
12:23:07 <Zao> Hascale?
12:23:18 <olsner> Cale: you could fix that, I guess :)
12:23:19 <osaunders> Cale: I'm trying to tell them.
12:23:21 <Cale> Lambdabot just has some extra local definitions.
12:23:43 <Cale> It's nothing so special as a complete rewrite of the Prelude.
12:23:47 <MissPiggy> Cale, the problem is that EVEN HASKELL comes with a built in giant stdlib - nobody is able to decide what is part of the language and what isn't
12:23:53 <osaunders> Zao: http://trac.haskell.org/alt-stdlib
12:24:11 <monochrom> "lambdabotkell" is just too long to type.
12:24:13 <medfly> :)
12:24:25 <Sgeo_> Cale, can lambdabot load new plugins without being restarted?
12:24:27 <olsner> Caleskell is some kind of #haskell meme
12:24:39 <MissPiggy> it sucks how Chameleon is 'dead'
12:24:39 <kmc_> indeed
12:25:04 <olsner> but didn't cale put the extra definitions into lambdabot? I thought that was the origin for calling the lambdabot stdlib caleskell
12:25:10 <osaunders> Is Haskell considered inferior compared to an object oriented language for dealing with changing requirements?
12:25:11 <MissPiggy> I hate that term wrt software but the truth is that everything else being 'alive' (i.e. consisently producing incompatability causing changes) makes 'dead' meaningful
12:26:13 <kmc_> osaunders: considered by whom?
12:26:19 <monochrom> MissPiggy++
12:26:21 <osaunders> Anyone.
12:26:32 <kmc_> yeah of course
12:26:39 <osaunders> People don't seem to discuss flexibility or adaptability of code here ever.
12:26:57 <osaunders> Which makes me think people don't take it seriously.
12:26:58 <MissPiggy> osaunders it's a non-issue, adapting code means ediding
12:27:05 <MissPiggy> editing*
12:27:19 <osaunders> MissPiggy: It can mean adding instead.
12:27:23 <kmc_> osaunders: plenty of people will say that Haskell is inferior to OO languages for all sorts of reasons
12:27:25 <MissPiggy> yeah that's the same thing
12:27:31 <MissPiggy> adding \subset editing
12:27:37 <kmc_> a lot of them are misinformed and don't actually know any Haskell
12:27:40 <osaunders> kmc_: OK, what do you think?
12:27:42 <notallama> osaunders: flexibility/adaptability is why monads and arrows and such exist.
12:28:11 <MissPiggy> monads and arrows don't solve adaptability
12:28:15 <MissPiggy> nothing does..
12:28:18 <kmc_> never mind those fancy abstractions, regular old first class functions are great for flexibility
12:28:24 <MissPiggy> if you have to adapt something you have to edit it, nothing changes that
12:28:24 <Berengal> @quote anthropomorphize
12:28:24 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
12:28:38 <kmc_> your system can take functions as parameters that let the user customize its behavior
12:28:43 <mauke> hey, who broke hpaste?
12:28:47 <Cale> olsner: I put some extra definitions in lambdabot, but it's not a complete standard library or anything, it's 2 or 3 definitions.
12:28:54 <kmc_> OO libraries do this extensively, usually in a clunkier way by wrapping each function in an object
12:28:55 <byorgey> adapting/editing/refactoring Haskell programs is a joy.
12:29:11 <Cale> olsner: and a lot of import declarations
12:29:13 <kmc_> which is called a "functor" or a "delegate" or a "functionoid" depending on which flavor of OO kool-aid you drank
12:29:33 <kmc_> i think that flexibility and adaptability has more to do with the choice of static versus dynamic typing than the choice of functional versus OO "paradigm".  and i think that static typing has some major advantages as well as disadvantages when it comes to flexibility
12:29:39 <Zao> kmc_: callable? :)
12:29:44 <mauke> so I have this class declaration: http://codepad.org/GWDyArXx
12:29:46 <MissPiggy> osaunders: adapting a program is like writing one from scratch, except that you already did 99% of the work
12:29:49 <mauke> why is the instance undecidable?
12:29:53 <kmc_> in the end, writing flexible code will have more to do with good design than the choice of language
12:30:01 <kmc_> as long as you pick a decent language, you can write flexible code
12:30:06 <kmc_> and you can write inflexible code in any language
12:30:15 <Cale> I really really dislike the abuse of the word "functor" in C++ and other OO languages.
12:30:20 <osaunders> kmc_: I haven't seen people on #haskell talk about it though
12:30:23 <MissPiggy> osaunders: that's what I meant by non-issue, it's not a distinct process that you need a new paradigm for
12:30:24 <Berengal> kmc_: I second that. Haskell has lots of flexibility due to type class inference that dynamic languages can't emulate
12:30:34 <kmc_> i'm also thinking of how types guide refactoring
12:30:40 <monochrom> osaunders: I recently changed my requirements. I went well in existing Haskell code. I just changed a sequence of Arrow commands "x >>> y" to "x >>> newthing >>> y" and implemented newthing. In OOP it would be similar but no easier. Note that the TV ad "just write subclass for new requirements" is false, you always have to find and change existing classes.
12:30:50 <osaunders> kmc_: I agree that style is important in achieving flexibility so why don't people talk about it here?
12:30:50 <MissPiggy> osaunders: (also what byorgey said, all the type system stuff helps loads and loads)
12:30:51 <olsner> ok, I guess all the imports is what mostly caused the "caleskell movement" then - if (e.g.) applicative is in the prelude you'd be using <$> more since it's available, which it is in "caleskell", and thus the #haskell code moved towards code using that more than normal prelude code
12:31:04 <kmc_> osaunders: *shrug* it's less fun to talk about?
12:31:10 <kmc_> do people talk about it in other language channels?
12:31:10 <Berengal> osaunders: We do, but we don't call it flexibility all the time
12:31:16 <MissPiggy> osaunders: I think I answered that
12:31:25 <Cale> olsner: I'm not the one who put the Control.Applicative import there
12:31:27 <kmc_> when refactoring, you can start with a change that you know will break all of the un-refactored code's types
12:31:34 <MissPiggy> osaunders: we do talk about it, because it's part a something more general
12:31:41 <kmc_> the compiler will then check for you that you've finished refactoring
12:32:02 <olsner> Cale: ah, but that doesn't matter, what matters is what people think (when it comes to naming you the creator of this thing)
12:32:04 <Cale> Control.Applicative has been imported by lambdabot for about as long as Control.Applicative has existed :)
12:32:12 <Cale> What did I create?
12:32:18 <olsner> caleskell, supposedly
12:32:22 <Cale> I didn't create lambdabot, that's for sure.
12:32:29 <Cale> I only run lambdabot.
12:32:50 <sinelaw> in soviet russia, lambdabot runs you
12:32:59 <osaunders> MissPiggy: I've largely ignored what you said because you seemed to approach the whole issue from a different mental model to me; I either didn't understand or it seemed irrelevant and obvious.
12:32:59 <aavogt> @quote psychobot
12:32:59 <lambdabot> psychobot says: gisteneralize thready studentirely
12:33:00 <Cale> sinelaw: Sometimes it seems that way :)
12:33:18 <Cale> I put a few handy definitions into L.hs and suddenly people are naming things after me :P
12:33:35 <Cale> It's nothing like an organised library.
12:33:35 <olsner> that's how it works :D
12:33:38 <aavogt> it's a catchy name though
12:33:42 <ben> Today lambdabot
12:33:45 <ben> Tomorrow the Empire of Cale
12:33:59 <xerox> Calempire
12:34:02 <burp> http://www.haskell.org/haskellwiki/Real_World lol
12:34:05 <Twey> Cale: I think it's the philosophy that's named after you, not the functions :
12:34:10 <aavogt> empiricale
12:34:19 <olsner> I think part of it is that people wish Prelude was more like L.hs, and would like Cale to make it so
12:34:24 <MissPiggy> osaunders: not sure why ignoring me would actually benefit you but okay
12:34:30 <Cale> What philosophy? "Make things general"? That's nothing new :P
12:34:33 <MissPiggy> osaunders: seems like the opposite, infact
12:34:44 <Cale> Well, you shouldn't wait for me :)
12:34:51 <Cale> I'm not even a GHC developer.
12:34:52 <olsner> osaunders: eh, you can only accept arguments from people sharing your mental model? :P
12:34:59 <MissPiggy> osaunders if something I said didn't make sense, probably ask me to elaborate or something
12:35:03 <burp> http://www.reddit.com/r/haskell/comments/a7mfr/announcing_haskell_2010/ just found that googling for caleskell ;)
12:35:23 <Twey> Cale: Out with the specific, in with the general :
12:35:34 <MissPiggy> osaunders FWIW I have a completely different mental model about this stuff than most people (even ones here)
12:35:51 <osaunders> MissPiggy: OK, well lets start with this first point you made.
12:36:02 <Cale> General is the new specific
12:36:03 <osaunders> You said that editing is a non-issue. What does that mean?
12:36:36 <roconnor> burp: heh, I was just discussin caleskell with my boss
12:37:06 <MissPiggy> osaunders, editing means deleting & adding & modifying, so if you know how to edit code then you can add something or delete etc..
12:37:07 <osaunders> MissPiggy: I only ignored you because it seemed like more trouble than it was worth while other people were talking to me. Now that they aren't I'm interested to explore it.
12:37:19 <MissPiggy> osaunders, and if you learn to program haskell you know how to edit code
12:37:35 <osaunders> I know how to edit code.
12:37:39 <copumpkin> can Ix be derived?
12:37:42 <osaunders> I know how to edit Haskell.
12:37:57 <MissPiggy> osaunders, yeah I am not meaning that you don't -- I'm speaking in general
12:38:32 <FliPPeh> Now that I learned that "(,)" is a function with two arguments to create a tuple..
12:38:43 <osaunders> But in all languages you can write code that is fragile (needs reediting a lot) or robust (needs fewer, small or simpler edits).
12:38:47 <FliPPeh> Ah nvm
12:38:56 <aavogt> Ix can be derived
12:39:12 <osaunders> MissPiggy: I'm not expecting not to have to edit code but I don't want to subject myself to more than necessary because I have bad style.
12:39:20 <FliPPeh> > (\(x1:x2:_) -> (x1, x2)) [4,8,5]
12:39:21 <lambdabot>   (4,8)
12:39:52 <byorgey> mauke: I can't seem to load your paste
12:39:53 <pikhq> @pl \(x:y:_) -> (x, y)
12:39:53 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
12:40:01 <pikhq> Mmm, ugly.
12:40:46 <mauke> byorgey: works here :-(
12:40:48 <MissPiggy> osaunders: if the worry is: I don't know some rules to follow that will make modifing existing programs to do new things easy,  then I do not think there is ANY solution -- no matter how fragile or robust a program is.. one feature can be trivial to add another can be extremely difficult
12:41:01 <monochrom> I think our approach is to use good styles in the first place. Notice how often we ask each other "I have this paste, is it good style?"  In the end it solves future-change problems as a side effect.
12:41:05 <mauke> byorgey: http://p3rl.org/8662UJHF
12:41:43 <MissPiggy> osaunders: (the main technique I use to solve this is to make programming languages instead of programs)
12:42:01 <MissPiggy> osaunders: (where "programming language" can just mean a 'library' in the usual terminology)
12:42:36 <osaunders> That's interesting.
12:42:53 <MissPiggy> osaunders: (oh I should also point out, that is not haskell specific)
12:43:06 <osaunders> Sure.
12:43:10 <MissPiggy> but I think it is quite a common practice
12:43:14 <MissPiggy> (in  haskell specifically)
12:43:34 <monochrom> haskell encourages it much more
12:44:51 <osaunders> The purpose of OO was to address the fragility of procedural programming. OO is a paradigm for managing and reducing dependencies, making code more robust. It seems like FP tackles this problem also but in a completely different way. I wish I could define it how I just defined it for OO.
12:45:10 <sinelaw> @quote radishes
12:45:10 <kmc_> doesn't that definition apply to both?
12:45:10 <lambdabot> poetix says: < poetix_>: In ancient Athens, they used to punish adulterers by forcing radishes up their rectums < boegel>: poetix_: sounds like fun !
12:45:19 <osaunders> *I wish I could define it as accurately as I just did for OO
12:45:24 * mauke cries
12:45:40 <mauke> so I added UndecidableInstances to my program to see if it compiles now
12:45:41 <sinelaw> osaunders, in FP it's also composable
12:45:53 <mauke> ghc: panic! (the 'impossible' happened)
12:45:54 <mauke>     getOptions'.parseLanguage(1) went past eof token
12:46:04 <pikhq> osaunders: We manage and reduce dependencies by making them explicit.
12:46:42 <osaunders> pikhq: How does that help? (I know it does but why)
12:46:43 <pikhq> In doing so, we can compose things easily, because nothing has any implicit dependencies.
12:46:55 <olsner> mauke: ghc couldn't decide before the end of the file, I guess
12:47:09 <osaunders> But you have composition in OO too.
12:47:11 <mauke> anyone have ghc >6.10.2?
12:47:23 <pikhq> osaunders: Yes, they have inheritance.
12:47:30 <pikhq> Sometimes it works nicely. Sometimes it doesn't.
12:47:37 <osaunders> In OO composition /= inheritance.
12:47:37 <mauke> if so, please try: echo $'{-# LANGUAGE\n#-}' | runghc
12:47:47 <pikhq> Erm. Right.
12:47:51 <mauke> it causes a ghc panic in 6.10.2
12:48:25 <ben> 6.12.1 says it expects a comma-separated list of language otions, each starting with a capital letter
12:48:32 <Philonous1> Is there something like a "guided tour" through the yi source?
12:48:42 <mauke> ben: good, sounds like it's fixed then
12:49:24 <medfly> composition... inheritance?
12:49:24 <sinelaw> osaunders, OO doesn't deal with composition at all. only with hiding internal code, and grouping stuff
12:49:25 <osaunders> Anyway what you're saying is that HOF lead to good style. If somebody wrote 1000 lines of Haskell and none of their functions were higher-order it *probably* wouldn't be that adaptable?
12:49:45 <MissPiggy> osaunders, I think there is a kind of duality with OO vs FP -- where it's easy to add new objects in OO and easy to add new functions in FP, you can invert each style to get the other -- if you invert the idea of making a languages (i.e. something which takes a program object (list of instructions type thing) and computes something from it) you get the idea of building a system of objects which is instructed to communicate by dispatch
12:50:01 <mkrauskopf> Hi all. I'm getting strange dependencies error during "scion" compilation: http://pastie.org/818894 Cannot google anything, any clues? Thanks.
12:50:11 <osaunders> sinelaw: pikhq: Careful there's a formal definition of composition in OO that is different from what I think you mean here (function composition).
12:50:24 <sinelaw> osaunders, so what do you mean?
12:50:39 <hzap> object composition?
12:50:41 <osaunders> Yes.
12:50:46 <sinelaw> what does that mean?
12:51:06 <osaunders> Objects as members within objects.
12:51:10 <sinelaw> i'm not talking about function composition, i'm talking about composition in general
12:51:11 <hzap> it's basically a fancy way of saying "put an object in another object"
12:51:18 <MissPiggy> osaunders think about that for a bit :P
12:51:21 <Cale> mkrauskopf: What's with the insane version numbers?
12:51:27 <lament> cells interlinked within cells interlinked within cells interlinked
12:51:33 <sinelaw> composition = taking two things to make a bigger "one thing", in a way that makes sense
12:52:03 <mkrauskopf> Cale: ?? I do not know, that's just what I got. I can build whatever else without problems so far.
12:52:05 <hzap> with some interface boilerplate, you can build inheritance without actually using inheritance
12:52:28 <hzap> I think that's what osaunders is talking about?
12:52:31 <sinelaw> and i mean things of the same type
12:53:20 * osaunders thinks about what MissPiggy said
12:54:16 <osaunders> MissPiggy: Yes, I see.
12:54:46 <osaunders> Perhaps I'm just too new at this.
12:55:18 <Cale> mkrauskopf: Wait, you have GHC 6.12, but scion-0.1.0.2 explicitly depends on ghc (>=6.10 && <6.12)
12:55:23 <osaunders> I'm not at the stage where I can do bottom-up design like using Haskell to create sub-languages etc.
12:55:35 <Cale> mkrauskopf: So it ought not to even get as far as it did.
12:55:54 <mkrauskopf> Cale: I'm on devel branch which requires ghc < 6.13
12:56:10 <osaunders> If that's the case then perhaps the reason why it isn't talked about is that a lot of people on this channel are having problems with things of more normal-order concern.
12:56:18 <Cale> ah, hmm
12:56:59 <Cale> mkrauskopf: Could you do a ghc-pkg list and pastebin the output?
12:57:06 <MissPiggy> interesting note about type systems http://ww2.cs.mu.oz.au/~sulzmann/chr/download/tie.html
12:57:23 <MissPiggy> shows an implementation of type classes for one
12:57:39 <notallama> osaunders: that reminds me of a quote: you cant teach top-down programming to beginning programmers, because they dont know which end is up
12:58:17 <Cale> mkrauskopf: There must be something weird, like the same package installed locally and globally
12:58:26 <osaunders> Let me ask a simpler question. If there were two files of Haskell code: In one file the code is well-written and adaptable, and in the other the code is not, what would likely be the specific differences between those pieces of code whether they do the same thing or not?
12:58:35 <mkrauskopf> Cale: http://pastie.org/818917
12:58:52 <mkrauskopf> Cale: thanks for the try to help.
12:59:05 <osaunders> Simpler still: What makes for good Haskell code?
12:59:09 <Cale> mkrauskopf: It's claiming that there are broken packages
12:59:32 <mkrauskopf> Cale: broken package is MK-Player, which are my own local packages, shouldn't cause problems
12:59:40 <mkrauskopf> Cale: byt will try to fix those to be sure
12:59:46 <osaunders> notallama: Yeah, true enough.
12:59:48 <Cale> mkrauskopf: You have two installations of Cabal-1.8.0.2. You should remove one of the two.
13:00:25 <mkrauskopf> Cale: ah, right, that could be it
13:01:01 <osaunders> Cale: You must know ^^ ?
13:01:06 <Cale> But it's likely to mess other things up, because some things will be built against one or the other version.
13:01:23 <notallama> osaunders: i think the more important part would be up a level. your overall design, rather than function-level details. i mean, you can rewrite a function or module fairly easily, but if you need to change several modules at once, you have a problem.
13:01:29 <Cale> osaunders: That question is way too general to be answerable
13:02:01 * MissPiggy wants haskell with CHR in the type system
13:02:30 <kmc_> then implement CHR as a DSL in Agda ;)
13:02:32 <osaunders> notallama: Undoubtedly.
13:02:59 <MissPiggy> kmc_, want some slides on CHR?
13:03:06 <kmc_> sure
13:03:08 <MissPiggy> (the best ones)
13:03:11 <sm> osaunders: it should work, be reliable, cheap to maintain, cheap to develop, readable, and short
13:03:25 <MissPiggy> http://www.cs.kuleuven.be/~jon/presentations/ulm09_tutorial.odp
13:03:36 <mkrauskopf> Cale: when you have a chance to be in Prague, you have a beer from me ;) Fixed, thanks.
13:03:43 <MissPiggy> odp (Open document format) is opened with Open Office
13:04:12 <osaunders> sm: Those are measures of good code not how it is achieved.
13:04:36 <osaunders> sm: It might have been unclear which one I was asking for though, sorry about that.
13:04:50 <MissPiggy> kmc_, if you get any crazy ideas about hooking this up with dependent types after reading it TELL ME :P
13:05:27 <osaunders> Cale: Well seeing as nobody has any good answers to that question I will think about it as I continue to learn Haskell.
13:06:00 <MissPiggy> it may be answerable in the form of a series of books or something :)
13:06:04 <osaunders> Although I'd probably do that anyway even if people did have answers to it, just I'd get that much further a long that much quick.
13:06:05 <MissPiggy> but it could take a lifetime to produce
13:06:24 <sm> I think it's harder to write some kinds of bad code in haskell than other languages.. if it compiles, it's at least somewhat "good"
13:06:25 <kmc_> these slides have like a 2 megapixel picture of Dijkstra in them
13:06:37 * MissPiggy wonders if STMCHR or haskell_chr (or some other library?) is the best
13:06:45 <byorgey> mauke: did anyone else answer your question re: undecidable instance?  I was finally able to view your code (my internet connection is being wonky)
13:06:49 <MissPiggy> kmc_, yes and even that doesn't do him justice!
13:07:05 <osaunders> MissPiggy: Regarding the lifetime point: hopefully less than that.
13:07:29 <osaunders> But it is interesting that people don't really seem to have an answer. I think it is quite an important question.
13:07:32 <`Zerax`> sm, it depends on your value judgement of good. I think the difference is that in general if it type checks it should at least be 'correct', many other languages don't have that luxury.
13:07:42 <sm> apis, data structure design, algorithmic efficiency become more of an issue
13:07:46 <mauke> byorgey: no
13:08:07 <Associat0r> anyone here into F#?
13:08:13 <sm> osaunders: as Cale said, it's too general a question. Many things could make one piece of code better than another
13:08:15 <osaunders> sm: OK, yeah that's an interesting point. Maybe this just isn't an issue in Haskell for some reason.
13:08:29 <MissPiggy> Is there a higher order unification implementation I can steal from somewhere?
13:08:37 <sm> give us two pastes, and you'll get all kinds of answers
13:08:39 <osaunders> sm: OK then, what is the most important thing?
13:08:45 <dolio> I thought higher order unification was undecidable.
13:08:55 <MissPiggy> dolio you can still implement it :P
13:09:05 <osaunders> sm: I can't do that because that would require knowledge of what the difference is.
13:09:09 <MissPiggy> dolio, it's semidecidible and I guess you could stick a timeout on it or something
13:09:33 <notallama> osaunders: those ruby guys call it DRYing your code. basically, many short functions.
13:09:49 <notallama> rather than few large ones
13:10:02 <FliPPeh> Hmm
13:10:12 <FliPPeh> Listening to FLACs with 1024 kbit is sure fun
13:10:15 <sm> yes.. functions that form a flexible DSL suited to your problem is a common pattern
13:10:21 <FliPPeh> If only I had a high end sound system
13:10:35 <osaunders> notallama: Yeah.
13:10:36 <`Zerax`> FliPPeh, add better hearing to that too ;)
13:10:47 <byorgey> mauke: it's very odd, I would have thought that would be OK too... I'm currently refreshing my memory on the precise details of the algorithm used to check whether instance selection will be terminating
13:10:55 <FliPPeh> `Zerax`: ;D
13:11:13 <IceDane> Could someone explain what it is exactly that bracket does? I've read about it, but I'm still not entirely sure. Is it just there to make sure resources used are cleaned up?
13:11:15 * osaunders goes off for a bit.
13:11:42 <sinelaw> osaunders, read this paper http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
13:11:51 <sinelaw> after you've learnt a bit of haskell
13:11:55 <sinelaw> but not too much
13:12:14 <mauke> IceDane: yes
13:12:17 <sinelaw> it gives great perspective; btw, there's also a video lecture of that somewhere
13:12:38 <IceDane> mauke: Alright, thanks.
13:12:48 <Adamant> I wish I knew why my system apparently hates MS Research, or MS Research apparently hates my system
13:12:56 <Adamant> I can't ever get papers from there.
13:13:21 <kmc_> yeah, their webservers randomly decide to hate some people
13:13:27 <kmc_> it happens to me sometimes, and then goes away
13:14:15 <byorgey> mauke: aha, it fails the Coverage Condition
13:14:22 <byorgey> see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
13:14:37 <byorgey> unfortunately I don't quite grok what the Coverage Condition is for
13:15:14 <FliPPeh> Is nesting "where" clauses a bad thing to do?
13:15:28 <FliPPeh>    where splitKV e = (key e, value e)
13:15:28 <FliPPeh>             where key = takeWhile (/= ':')
13:15:29 <FliPPeh>                   value = (drop 1) . dropWhile (/=' ')
13:15:45 <Heffalump> in that case, yes, it's unnecessary
13:15:46 * FliPPeh likes
13:15:46 <osaunders> FliPPeh: If you inline all those in one where it'll still work.
13:15:54 <FliPPeh> It WOULD work
13:15:55 <mauke> needs more break/span
13:16:01 <Heffalump> in a few cases it can be necessary but I think it looks rather ugly and should be avoided if possible
13:16:01 <MissPiggy> dolio basically I want lambda prolog :(
13:16:08 <FliPPeh> But it looks clearer, because I only need those 2 in that function
13:16:32 <mauke> FliPPeh: why is one of them ':' but the other ' '?
13:16:50 <FliPPeh> Erm
13:16:52 <osaunders> sinelaw: research.microsoft.com isn't responding :-(
13:17:05 <sinelaw> it is for me
13:17:06 <FliPPeh> mauke: The string given is "Key: Value"
13:17:07 <dolio> Well, lambda prolog is pretty cool.
13:17:18 <mauke> splitKV = fmap (drop 2) . span (/= ':')
13:17:19 <byorgey> mauke: anyway, I hardly think twice about adding UndecidableInstances
13:17:24 <sinelaw> osaunders, try the web page http://research.microsoft.com/en-us/um/people/simonpj/Papers/history-of-haskell/
13:17:26 <FliPPeh> :t span
13:17:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:17:34 <sinelaw> (rather than the direct-to-file link i pasted before)
13:17:39 <sinelaw> osaunders, do you have ACM access?
13:17:42 <FliPPeh> > span (/= ':') "Hello: World"
13:17:43 <lambdabot>   ("Hello",": World")
13:17:46 <FliPPeh> Okay.
13:17:49 <osaunders> sinelaw: ACM?
13:17:57 <MissPiggy> "
13:17:57 <MissPiggy> We propose an extension of Haskell's type class system with lambda abstractions in the type language. Type inference for our extension relies on a novel constrained unification procedure called guided higher-order unification. This unification procedure is more general than Haskell's kind-preserving unification but less powerful than full higher-order unification."
13:18:09 <sinelaw> try this: http://portal.acm.org/citation.cfm?id=1238844.1238856
13:18:15 <FliPPeh> > fmap (drop 2) . span (/= ':') "Hello: World"
13:18:16 <lambdabot>   Couldn't match expected type `[a]'
13:18:16 <lambdabot>         against inferred type `GHC.Types...
13:18:22 <`Zerax`> Association for Computer Machinery.
13:18:27 <FliPPeh> > fmap (drop 2) $ span (/= ':') "Hello: World"
13:18:28 <sinelaw> osaunders, you won't have access unless you're in some organization, i.e. a university
13:18:28 <lambdabot>   ("Hello","World")
13:18:38 <sinelaw> osaunders, but for the microsoft link you should have no problem
13:18:49 <FliPPeh> mauke: Why does fmap only touch the second element of the tuple?
13:18:57 <FliPPeh> > fmap (drop 2) $ span (/= ':') "Hello: World"
13:18:57 <byorgey> MissPiggy: what's that from?
13:18:58 <lambdabot>   ("Hello","World")
13:19:03 <mauke> FliPPeh: what else could it do?
13:19:12 <FliPPeh> Touch all of them?
13:19:23 <mauke> FliPPeh: that wouldn't fit fmap's type signature
13:19:27 <FliPPeh> :t fmap
13:19:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:19:49 <byorgey> it would only make sense if you made a new type  Pair a = Pair (a,a)
13:19:50 <FliPPeh> But what is the functor here?
13:19:50 <MissPiggy> byorgey: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7505
13:19:53 <mauke> instance Functor ((,) a)
13:19:58 <FliPPeh> Some tuple magic?
13:20:02 <mauke> not magic
13:20:13 <byorgey> MissPiggy: thanks
13:20:37 <FliPPeh> Mhh
13:20:44 <FliPPeh> Lot's of things to learn about tuples for me
13:20:45 <MissPiggy> byorgey: I want to use this!!
13:20:53 <FliPPeh> I just learned that (,) is a function, too
13:20:56 <MissPiggy> :)
13:21:12 <mauke> FliPPeh: all constructors are, and (,) is the tuple constructor
13:21:24 <c_wraith> I'm seriously considering writing a crypto prng package...
13:21:44 <FliPPeh> (,) 1
13:21:47 <FliPPeh> > (,) 1
13:21:48 <lambdabot>   {()->(1,())}
13:21:57 <c_wraith> (no, that's not a contradiction.  There is plenty of research in crypto-quality prngs, what they are good for, and what they are bad for)
13:22:14 <hzap> what's with that output?
13:22:29 <osaunders> c_wraith: Still on with that huh.
13:22:48 <mauke> hzap: just a Show instance for functions
13:23:07 <sinelaw> I wish haskell had this syntax:
13:23:10 <c_wraith> osaunders: yeah.  Can't quit thinking about it.  And it *is* a hole in what's currently available on hackage.
13:23:11 <hzap> mauke: so it just always applies it to ()?
13:23:18 <sinelaw> f 0 = id
13:23:23 <sinelaw> f n x = x+n
13:23:24 <MissPiggy> basically I want haskell with CHR instead of typeclasses, and type lambda + HOU
13:23:46 <sinelaw> am i the only ones who'se annoyed by the "patterns have different number of args"?
13:24:03 <MissPiggy> sinelaw: that's a pretty scary thing to write you know
13:24:22 <sinelaw> MissPiggy, why? the specific example or is the syntax problematic?
13:24:28 <osaunders> c_wraith: How long would it take to write such a thing?
13:24:35 <MissPiggy> sinelaw: it took me about 10 mins to realize this wasn't some kind of horiffic pathological dependent type example
13:24:46 <mauke> hzap: I don't know the exact rules; I think it's from SmallCheck
13:24:52 <MissPiggy> sinelaw, its not problematic except that I suck at reading it
13:25:27 <FliPPeh>  No instance for (Functor ((,) [Char]))
13:25:29 <FliPPeh> Whyyyy
13:25:30 <sinelaw> i'd like ot know if it's missing for others too
13:25:55 <tensorpudding> hmm?
13:25:58 <interferon> @np (foo x, bar x)
13:25:58 <lambdabot> Maybe you meant: . ? @ bf do ft id map pl rc unpf unpl v wn
13:26:00 <aavogt> sinelaw: I'm not sure it's worth it considering the typos that the current rules catch
13:26:01 <hzap> sinelaw: I sometimes want it but it's not that important for me
13:26:05 <interferon> @pl (foo x, bar x)
13:26:05 <lambdabot> (foo x, bar x)
13:26:13 <MissPiggy> sinelaw, what's your real use-case by the way?
13:26:14 <tensorpudding> > fmap fst (3,"foobar")
13:26:15 <lambdabot>   Couldn't match expected type `(a, b)'
13:26:15 <lambdabot>         against inferred type `[GHC.T...
13:26:24 <MissPiggy> sinelaw, (I thiink the only reason it's not implemented is because it's so scary)
13:26:25 <tensorpudding> err
13:26:29 <tensorpudding> > fmap head (3,"foobar")
13:26:30 <lambdabot>   (3,'f')
13:26:32 <Philonous1> aavogt: Shouldn't the type checker catch those anyway?
13:26:41 <doserj> FliPPeh: import Control.Monad.Instances
13:26:51 <MissPiggy> Philonous1: you mean the typo checker? :)
13:26:59 <aavogt> Philonous1: sure, but those errors are much less specific
13:27:02 <c_wraith> osaunders: probably a couple evenings' worth of spare time.  Mostly spent doing research on what the known good algorithms are.
13:27:12 <dolio> sinelaw: I've wanted it before.
13:27:16 <medfly> @pl \x-> (foo x, bar x)
13:27:16 <FliPPeh> Ahh, thanks doserj
13:27:17 <lambdabot> liftM2 (,) foo bar
13:27:30 <c_wraith> osaunders: performance optimization could be weeks, though, for those who care about that sort of thing
13:27:43 <aavogt> and if you use typeclasses like the ones for printf, then you won't be caught by the typechecker, Philonous1
13:29:04 <medfly> interferon, is that it?
13:29:07 <sinelaw> maybe there could be a special sytnax for those cases where you want it
13:29:15 <interferon> medfly: yep!
13:29:17 <interferon> medfly: thanks
13:29:28 <doserj> foo &&& bar
13:29:29 <interferon> no real need for it, was just curious about how it could be done :)
13:29:51 <interferon> why the liftM2, though?
13:30:43 <mauke> string :: (Eq a, Stream s a, Monoid e, Monad m) => [a] -> ParserT e s m [a]
13:30:47 <mauke> holy type signatures, batman
13:33:02 <MissPiggy> it would be nice if you could write
13:33:14 <MissPiggy> string :: ? => [a] -> ParserT e s m [a]
13:33:20 <MissPiggy> and then GHC would fill in the ? for you
13:34:00 <Zao> The "haskell-mode" for vim includes keys to invoke GHCI and query for a type signature.
13:34:05 <kmc_> yeah, or more generally to give a type signature with missing parts
13:34:18 <kmc_> basically to be able to write unification variables as well as quantified variables
13:34:34 <Philonous1> aavogt: printf is horrible anyway. But I still wouldn't want variable variable number of arguments. Lambdas on the rhs are not bad enough to justify them
13:34:59 <kmc_> the proper way to implement printf in Haskell is TH
13:35:39 <c_wraith> :t ?f . ?g
13:35:41 <lambdabot> forall a b (f :: * -> *). (?f::a -> b, ?g::f a, Functor f) => f b
13:35:58 <interferon> what is the type-safe haskell approach to printf?
13:36:05 <mauke> interferon: TH
13:36:09 <c_wraith> :t ?f Prelude.. ?g
13:36:10 <lambdabot> forall b c a. (?g::a -> b, ?f::b -> c) => a -> c
13:36:15 <tommd> @hackage printf-TH -- I think
13:36:15 <lambdabot> http://hackage.haskell.org/package/printf-TH -- I think
13:36:23 <Berengal> Can't you do it with type classes?
13:36:26 <`Zerax`> 404
13:36:32 <interferon> mauke: that's what i thought
13:36:32 <interferon> thanks
13:36:34 <tommd> @hackage Printf-TH
13:36:34 <lambdabot> http://hackage.haskell.org/package/Printf-TH
13:36:47 <harlekin> interferon, there's sprintf. I think the paper was called Fun with typeclasses.
13:37:05 <kmc_> the standard Text.Printf defers the type checking of arguments until runtime
13:37:08 <mauke> > ""++ printf "" 42
13:37:10 <lambdabot>   "* Exception: Printf.printf: formatting string ended prematurely
13:37:14 <tommd> drat
13:37:15 <`Zerax`> You'd need to parse the format string to match the number and type of arguments don't you - F# does it.
13:37:19 <Philonous1> Berengal: That's not type safe as you can't inspect the format string at compile time without TH
13:37:44 <kmc_> the TH version does not... it statically compiles (printf "%d %s") into a function of type Float -> String -> String
13:37:56 <mauke> kmc_: that's broken
13:37:59 <Berengal> Philonous1: True. You might be able to write an EDSL for it though
13:38:04 <mauke> should be Integral a => a -> String -> String
13:38:12 <kmc_> oh, right
13:38:15 <interferon> what do i need to do to compile a template haskell file?  is it just a ghc flag or is there a preprocessor?
13:38:25 <Philonous1> You could do it with dependent types
13:38:28 <interferon> and how does the compile-time layer load in the modules it needs?
13:38:40 <kmc_> interferon: turn on the TemplateHaskell language extension
13:38:43 <mauke> {-# LANGUAGE TemplateHaskell #-}
13:38:46 <interferon> nice
13:38:46 <kmc_> with -XTemplateHaskell or that pragma
13:38:47 <MissPiggy> that's a good idea
13:39:02 <kmc_> loading the modules mostly Just Works... it runs in an environment similar to GHCi
13:39:17 <kmc_> there are some issues with TH and profiling code, see the manual for more details
13:39:21 <interferon> but what if i want to import something for my TH functions that the runtime code doesn't need?
13:39:28 <kmc_> that's fine
13:39:33 <interferon> or are you saying TH code gets all the imports my runtime code gets?
13:39:42 <kmc_> correct
13:39:44 <c_wraith> it can end up with funny compiler warnings, if you have -Wall on
13:39:46 <interferon> gotcha
13:40:06 <Berengal> TH code needs to be defined in a different file from where it's used though, right?
13:40:14 <kmc_> in fact all top level names used within a splice *must* be imported from another module
13:41:04 <aavogt> Berengal: that would be the case if you want to pass format strings into the TH printf function
13:41:49 <aavogt> kmc_: I believe it's more restrictive than top level
13:42:05 <kmc_> ah
13:42:23 <aavogt> I don't think you can do:   let fmt = "hello%d" in $(printf fmt) 2
13:42:49 <aavogt> but you can work around that usually by bringing all those definitions into the splice
13:43:16 <kmc_> ah makes sense
13:44:23 <aavogt> and if you really want to share those results, you could do something like:   (a,b) = $( let x = ... ; in do c <- f x; return $ TupE [x,c] )
13:44:46 <aavogt> but that's a bit unpleasant
13:53:04 * MissPiggy just going to use stmchr then?
13:53:14 <MissPiggy> couldn't find any other haskell chr implementations
13:53:45 <Lemmih> @type Data.Char.chr
13:53:46 <lambdabot> Int -> Char
13:54:03 <MissPiggy> is haskeline good?
13:55:11 <FliPPeh> Just found the improved haskell syntax highlighting for vim
13:55:11 <kmc_> it's used by ghci
13:55:14 <kmc_> how do you feel about ghci
13:55:20 <FliPPeh> Finally higlhighted Types and Constructors
13:56:40 <MissPiggy> this stmchr is horribly slow :(
13:58:57 <MissPiggy> does anyone use stmchr because I'm confused about this, I can't beleive it is meant to run so slowly
14:01:03 <IceDane> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source I've been studying this code in an attempt to understand monads a bit better. I'm confused with one thing in particular: In main, bracket is 'called' with connect, disconnect and loop as parameters. When connect is called, it returns the initalized state monad.... but how/why/where is it actually stored?
14:02:04 <IceDane> Is it because the return from connect is chained into loop?
14:02:34 <Zao> loop is called with the Bot value as parameter.
14:02:55 <Zao> @type bracket
14:02:56 <lambdabot> Not in scope: `bracket'
14:03:09 <mauke> @hoogle bracket
14:03:10 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:03:10 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:03:10 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
14:04:03 <Zao> Oh god. There's an 'asks' that does _that_?
14:04:10 <Zao> ReaderT suddenly got much less painful :P
14:04:11 <MissPiggy> I suppose it /is/ verson 0.1
14:04:17 <MissPiggy> but I am still amazed it's so slow..
14:04:41 <IceDane> So, is it correct to say that bracket calls the first function, passes it to the last function(loop), and upon 'exit' the 'middle' function is called for cleanup?
14:04:49 <roconnor> @src bracket
14:04:49 <lambdabot> bracket before after thing = block $ do
14:04:49 <lambdabot>     a <- before
14:04:49 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
14:04:49 <lambdabot>     after a
14:04:49 <lambdabot>     return r
14:04:49 <monochrom> Yes.
14:04:58 <IceDane> I know the terminology might be a bit, or even way off, but bear with me
14:05:01 <IceDane> ah, good.
14:05:11 <sizur> What's the most user friendly parsing lib in hackage?
14:05:31 <roconnor> @src block
14:05:32 <lambdabot> Source not found. Are you on drugs?
14:05:37 <monochrom> ReadP. It's with GHC, no extra thing to install.
14:05:38 <roconnor> @type block
14:05:39 <lambdabot> Not in scope: `block'
14:05:43 <roconnor> what the heck is block?
14:05:49 <sizur> monochrom: thanks
14:06:02 <mauke> roconnor: blocks async exceptions
14:06:07 <roconnor> crazy
14:06:18 <mauke> it's essential for thread safe code
14:06:20 * roconnor prefers to not know about async exceptions
14:06:44 <mauke> otherwise any thread might blow you out of the water any time (throwTo)
14:06:54 <monochrom> You do not want to be interrupted while you cleanup.
14:07:16 <roconnor> mauke: why not just do main = block $ do whatever ?
14:07:30 <mauke> that seems pointless
14:07:36 <roconnor> monochrom: I want to be interupted while I initialize
14:07:49 <monochrom> You still want to be interrupted while you do most things.
14:08:03 <monochrom> You can add "unblock" if you want to be interrupted.
14:08:05 <IceDane> @src asks
14:08:06 <lambdabot> asks f = do
14:08:06 <lambdabot>     r <- ask
14:08:06 <lambdabot>     return (f r)
14:08:14 <IceDane> @src ask
14:08:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:08:18 <roconnor> does unblock foo reblock after foo is done?
14:08:29 <roconnor> wait, I don't want to know this stuff
14:08:31 <FliPPeh> Oh god, HAL 2000 references
14:08:32 <Zao> IceDane: ask retrieves the thingie held by the Reader.
14:08:43 <monochrom> If it is nested inside an outer block. See bracket @src again, has example.
14:08:49 <IceDane> Zao: Yeah, I thought it did, but I really don't understand it, heh.
14:08:51 <SamB_XP> FliPPeh: 9000
14:08:53 <SamB_XP> from 2001
14:09:00 <FliPPeh> Sorry, 9000
14:09:07 <roconnor> I don't really understand why before is blocked.
14:09:13 <IceDane> @src runReaderT
14:09:13 <lambdabot> Source not found. Sorry.
14:09:14 <FliPPeh> I'm afraid Dave.
14:09:16 <IceDane> eh
14:09:23 <kmc_> > map succ "HAL"
14:09:24 <lambdabot>   "IBM"
14:09:33 <FliPPeh> Oh my -
14:09:37 <monochrom> Perhaps some users requested it and they understood it.
14:10:23 <mauke> roconnor: what if you unblock before and an exception strikes while it returns?
14:10:38 <SamB_XP> monochrom: or possibly it wasn't thought about enough ?
14:11:11 <interferon> okay.  after doing some major refactoring, i finally believe the claim that "when your haskell program compiles, it usually works"
14:11:24 <MissPiggy> ugh
14:11:33 <interferon> i kept getting ready to track down bugs after getting my changes to compile and they just kept not appearing
14:11:36 <SamB_XP> interferon: it's certainly a good sign after a refactoring!
14:11:38 <monochrom> Oh, I understand it. before may acquire two resources. Suppose interrupted after acquiring one but not the other. How do you cleanup? How do you know how much to cleanup?
14:11:43 <IceDane> So, runReaderT calls the run function, and the run function and all functions it calls can actually just do asks *record function(?)* to retrieve the state passed to runReaderT?
14:11:49 <IceDane> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source <- this code, btw
14:12:10 <kmc_> interferon: yeah.  i think learning effective refactoring in haskell largely has to do with maximizing this effect
14:12:38 <kmc_> for example, don't overuse tuples -- you might want to refactor them into a new tuple with the same type but a different meaning
14:12:43 <interferon> are there any automated refactoring tools for haskell?  with static typing, seems like it would be easy to apply a "Rename Function" refactoring, for example
14:12:50 <monochrom> There are ways but they are a lot of work. Lazy way out: just make sure it never happens. You either acquire none, or you acquire both. Now it's easy to cleanup.
14:13:08 <interferon> kmc_: do you mean "into a new type"?
14:14:48 <interferon> does ghc do any kind of internal memoization?
14:14:58 <kmc_> interferon: of function args / results, no
14:15:05 <kmc_> or do you mean the compiler itself, rather than the code it generates?
14:15:14 <interferon> i mean the code it generates
14:15:24 <mauke> no
14:15:33 <monochrom> Heh, "ghc remembers it compiled this code before, it's going to reuse..."
14:15:37 <kmc_> every "let"-bound value is evaluated to normal form only once
14:15:45 <kmc_> a function is already in normal form
14:15:46 <mauke> that's just normal variables
14:15:50 <kmc_> a lambda expression is, i mean
14:15:55 <MissPiggy> I hate how academics insist on using esoteric symbols instead of writing code. Every programmer in the world understands C like syntax. Would a.concat(b) be so much worse?
14:16:03 <kmc_> yes
14:16:09 <kmc_> C-like syntax is holding the world back
14:16:20 <kmc_> it's ugly and does not extend well to new concepts
14:16:20 <sinelaw> ;
14:16:23 <MissPiggy> I do realize that these may be standard symbols in the academic world, but that just demonstrates the disconnect between academics and real world developers. No real world developer will see || and think list concatenation.
14:16:23 <MissPiggy> haha
14:16:23 <MissPiggy> like LAMBDA
14:16:31 <Ke> !
14:16:35 <monochrom> I thought C-like syntax meant x++y. Because there is already x+y in C-like syntax.
14:16:49 <kmc_> and every new language either takes C and makes it three times uglier, or is criticized for being "impractical" because it has a non-C-like syntax
14:16:49 <temoto> MissPiggy, a + b is more C-syntax than that.
14:17:01 <kmc_> as if it were a tremendous burden for beginners to glance at a one-page cheat sheet
14:17:09 <c_wraith> I just have to complain about academic papers using non-ascii syntax as if it helps.
14:17:21 <kmc_> i think the fallacy is that people (particularly non-programmers) think that syntax is the biggest obstacle to learning a new language
14:17:23 <monochrom> Find me a mainstream language that has no infix notation whatsoever.
14:17:24 <c_wraith> Ascii is limiting, sure.  But not using it doesn't clarify anything
14:17:39 <kmc_> > let x = 2 + 2 in (x, succ x)
14:17:40 <lambdabot>   (4,5)
14:17:45 <kmc_> ^^^^ interferon, that 'x' is "memoized"
14:17:45 <Dark_Shikari> monochrom: scheme, obvious<is stabbed>
14:17:48 <temoto> monochrom, lisp?
14:17:52 <dibblego> kmc_, I think it is a fallacy, but more suitable to programmers
14:17:55 <monochrom> Note that "object.methodcall" is still infix notation. Find me a mainstream language that doesn't even do that.
14:18:12 <mauke> object.methodcall is postfix
14:18:20 <monochrom> No, infix . there
14:18:26 <mauke> . isn't a real operator
14:18:33 <monochrom> "infix notation"
14:18:33 <kmc_> object is the first arg to methodcall
14:18:37 <kmc_> in some treatments
14:18:38 <temoto> man operator
14:18:40 <temoto> it is
14:18:42 <EvanCarroll> ++ is string concat in lua
14:18:47 <kmc_> in Python . acts much more like a real operator
14:18:58 <kmc_> it's sugar for indexing an associative container
14:19:00 <mauke> IMHO the C . is a meta-postfix op
14:19:04 <MissPiggy> so who wants to implement an efficient CHR in haskell?
14:19:09 <temoto> What do you mean by 'real operator'?
14:19:13 <monochrom> And yeah, Scheme and Lisp. So note how if you give up infix notation, you're only more academic, not less.
14:19:26 <erikc> monochrom: Factor!
14:19:27 <Zao> MissPiggy: I still do not know what a CHR is.
14:19:29 <mauke> temoto: something of the form EXPR @ EXPR
14:19:46 <erikc> Forth!
14:19:52 <MissPiggy> Zao, I found some haskell libs for it but they suck :(
14:20:19 <temoto> mauke, so you mean infix operator?
14:20:22 <Zao> I doubt many know that you're referring to "Constraint Handling Rules", whatever those are.
14:20:25 <Zao> I sure don't.
14:20:25 <monochrom> Anyway I am appalled that some OOP zealots even go as far as saying that "yeah, a.plus(b.plus(c)) is better notation than a+b+c".
14:20:30 <MissPiggy> Zao: yes I am
14:20:48 <mauke> should be plus.call(a, b), obviously
14:20:55 <temoto> monochrom, i bet those are Java fanatics.
14:21:07 <monochrom> So anyone who attacks x++y goes into that same retarded category as far as I'm concerned.
14:21:15 <Associat0r> monochrom: I hate them too
14:21:25 <MissPiggy> what about people who attach x^y ? :)
14:21:35 <MissPiggy> attack*
14:21:50 <IceDane> So, runReaderT calls the run function, and the run function and all functions it calls can actually just do asks *record function(?)* to retrieve the state passed to runReaderT? http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source This code, btw
14:21:57 <Associat0r> monochrom: I dislike languages with where evrything is spelt out as words
14:22:10 <sinelaw> monochrom, usually they have operator overloading to like
14:22:43 <kmc_> the preferred syntax is dynamic_cast<int>(AbstractIntegerOperatorFactory(boost::shared_ptr<IntegerOperatorFactoryConfig>(new IntegerOperatorFactoryConfig()), operator_traits<int>::operator_enums::enum_add).applyOperator(a, b).getResult())
14:23:00 <temoto> lambdabot has no trace?
14:23:02 <kmc_> ;
14:23:14 <kmc_> temoto: correct, lambdabot has no way to execute IO actions
14:23:16 <kmc_> it can evaluate them though
14:23:18 <Zao> IceDane: That's how the Reader monad works (and by extension the ReaderT monad transformer).
14:23:23 <MissPiggy> kmc_ what did you think of the series of CHR one-liners?
14:23:32 <kmc_> MissPiggy: i didn't get that far, got distracted
14:23:37 <Zao> IceDane: Inside it, you can invoke 'ask' to read the state.
14:23:41 <MissPiggy> oh that's one of the best bits
14:23:54 <temoto> @type Debug.Trace.trace
14:23:56 <lambdabot> forall a. String -> a -> a
14:23:58 <temoto> It's pure.
14:24:40 <IceDane> Zao: So if I were to look at the runReaderT definition, ask/asks would be like a function defined in let(e.g. not available anywhere else), and thus has access to the parameters passed to runReaderT?
14:24:42 <monochrom> Anyway "object.methodcall" is infix notation, infix syntax, because the next thing you do is "object.clone.getElement.clone.add(1)". Clearly infix notation and syntax. I don't say "operator", I say "notation", "syntax". Note the original stance was "C-like syntax" not "C-like operator".
14:25:14 <Zao> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader-Class.html#v:ask
14:25:26 <mauke> monochrom: looks very postfix to me
14:25:34 <IceDane> brb..
14:26:18 <monochrom> It is the right-associativity that leans you towards postfix. The same could be said of x++y++z.
14:26:33 <monochrom> Oh nevermind.
14:26:45 <mauke> no, because y and z can be arbitrary expressions there
14:27:18 <luqui> > Debug.Trace.trace "Does lambdabot have you?" 42
14:27:19 <lambdabot>   Not in scope: `Debug.Trace.trace'
14:27:38 <temoto> No go of object.54 makes it postfix?
14:27:43 <dankna> I think I found an issue with building ghc from the 6.12 darcs repo on Mac OS X Snow Leopard.
14:27:52 <kmc_> i like that in C, a[3] and 3[a] are equivalent
14:28:27 <dankna> The compiler itself uses the 32-bit ABI but the configure script is running against the 64-bit one, because of Apple making that the default, with the result that the return type of unsetenv is detected incorrectly.
14:28:44 <monochrom> x:y:z:t:[] is infix notation. even though left argument and right argument are different types. similarly o.m.n. Note both : and . are built-in syntax, not operator per se, the parallel is better than we think.
14:28:56 <dankna> Is there anyone who might be interested in this report in here now?
14:29:53 <mauke> methodcall doesn't have a type because it's not even an expression
14:30:04 * dankna takes that for a no :)
14:30:18 <temoto> dankna, not to discourage you, but devs are usually interested in tickets too.
14:30:46 <monochrom> OK fine.
14:31:01 <dankna> temoto: I suppose you're right, I just wanted to be lazy
14:31:23 <mauke> see also precedence levels: postfix > prefix > infix
14:31:29 <temoto> > head ["Lazy is great", undefined]
14:31:30 <lambdabot>   "Lazy is great"
14:31:35 <MissPiggy> 4
14:31:59 <dankna> haha
14:32:26 <temoto> I wonder why is it allowed. undefined is clearly of other type.
14:32:40 <temoto> :t ["fo", undefined]
14:32:41 <lambdabot> [[Char]]
14:32:43 <monochrom> undefined is polymorphic.
14:32:52 <temoto> :t undefined
14:32:53 <lambdabot> forall a. a
14:32:57 <mauke> temoto: undefined is of any type
14:33:04 <temoto> uhhh
14:33:15 <monochrom> You don't like it? :)
14:33:20 <temoto> i don't get it
14:33:21 <mauke> :t [undefined, undefined]
14:33:22 <lambdabot> forall a. [a]
14:33:38 <temoto> value of any type
14:33:45 <temoto> that's not typed language
14:33:49 <mauke> yes, it is
14:33:51 <temoto> that's python or something
14:33:52 <ben> :t (undefined+undefined):undefined
14:33:53 <lambdabot> forall a. (Num a) => [a]
14:33:54 <monochrom> > head ["abc", (undefined :: String) ]
14:33:55 <lambdabot>   "abc"
14:34:01 <monochrom> > head ["abc", (undefined :: Int) ]
14:34:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:34:02 <lambdabot>         against inferred ty...
14:34:08 <monochrom> This is why.
14:34:16 <MissPiggy> temoto: look id :: forall a. a -> a,  if you use id "foo", then a gets instantiated to String
14:34:44 <temoto> MissPiggy, yeah i can't get it how to use something which type never gets instantiated.
14:34:50 <MissPiggy> temoto: it's same with undefined :: forall a. a, if you use [3, undefined], then a gets instantiated into Int
14:35:03 <monochrom> type inference figures that it should instantiate a to String to fit into context.
14:35:05 <dschoepe> :t []
14:35:05 <temoto> I thought that type instantiation of all comes before evaluation.
14:35:06 <lambdabot> forall a. [a]
14:35:20 <MissPiggy> temoto, yeah it's part of type checking/inference
14:35:37 <dschoepe> temoto: well, you always know at compile time which type the undefined actually has
14:35:38 <temoto> MissPiggy, ah so undefined there is typed after all?
14:35:38 <gwern> oh no
14:35:44 <MissPiggy> temoto, yes
14:35:46 <gwern> I triggered a runetime exception
14:35:51 <gwern> stop! thor hammer time!
14:35:59 <temoto> MissPiggy, thanks, i got it now.
14:36:17 <monochrom> This is why I say "polymorphic" so I don't get into debates such as "what does 'any type' mean?"
14:37:59 <kynky> arnt there several kinds of polymorphism ?
14:38:11 <monochrom> Yes.
14:38:49 * hackagebot upload: GtkTV 0.0.3 - Gtk-based GUIs for Tangible Values (ConalElliott)
14:39:02 <sinelaw> ooh
14:39:10 <sinelaw> conal, what's that?
14:39:13 <monochrom> But at least if someone wants, I can further say "parameteric polymophism" or "Hindley-Milner polymorphism", and it is still correct, and still no debates.
14:39:46 <ddarius> forall a. a is a perfectly good type.  It doesn't need to be instantiated.
14:39:50 <sinelaw> i wonder what he changed in the new version
14:39:55 <monochrom> Whereas if it comes down to the semantics of "any" I can only point to my http://www.vex.net/~trebla/weblog/any-all-some.html which only tells you it's hopeless.
14:39:58 <conal> sinelaw: it's a gtk back-end for tangible values.  functional-style GUIs.
14:40:17 <conal> sinelaw: composable MVC
14:40:35 <sinelaw> conal, yes, and I was wondering what's new. i though TV was semi-abandoned
14:40:39 <sinelaw> *thought
14:41:25 <kmc_> i wouldn't call python "untyped"
14:41:35 <Zao> Lazily typed :P
14:41:35 <conal> sinelaw: not abandoned.  TV is nice & simple.
14:41:38 * MissPiggy would -- but would probably be wrong
14:41:41 <mauke> don't worry, there are enough people to do it for you
14:41:45 <sinelaw> conal, good to know
14:42:50 <conal> sinelaw: i'm bummed about the state of low-level/imperative GUI libs in haskell though.  gtk2hs doesn't have native look, and wxhaskell kills ghci.
14:43:19 <sinelaw> conal, luqui's lib is nice, but it's not a gui lib.
14:43:34 <luqui> working on it!
14:43:40 <dankna> conal: yeah, a project I'd like to do someday is a tk-style library, but without tcl wedded to it
14:43:42 <sinelaw> :)
14:43:50 <dankna> tk is the best design I've seen for cross-platform GUI stuff
14:44:01 <MissPiggy> dankna I think Oz uses tk
14:44:05 <dankna> because it is the union of platform-specific features rather than the intersection of them
14:44:18 <MissPiggy> dankna, well I know it does..
14:44:22 * dankna nods
14:44:26 <luqui> a.c.d vs a.b.d
14:44:27 <conal> i'd like to make a fresh start, say on top of opengl.  but even there, i think all of the 3d+window libs have serious problems on at least one platform.
14:44:33 <luqui> er, wrong channel :-P
14:44:41 <dankna> I don't think the fresh start approach is the right way
14:45:00 <dankna> although I *can* help you a bit with that - my library Emerald Frame, when it's ready for release, will be a GLUT/SDL replacement
14:45:11 <dankna> but I think users really want native widgets
14:45:23 <luqui> native widgets are ugly
14:45:28 <dankna> not on the Mac :)
14:45:33 <conal> :)
14:45:49 <kmc_> widgets suck
14:45:53 <luqui> dankna, so for a GLUT/SDL replacement, the highest demand is something that easily builds everywhere
14:45:57 <conal> yeah.  i switched to a mac last summer, and now i hate that gtk2hs looks like gtk.
14:45:57 <kmc_> for most tasks, GUIs are good for output, not input
14:45:57 <sinelaw> widgets do suck
14:46:01 <dankna> luqui: yes, that's my primary design goal
14:46:07 <kmc_> few apps really have graphical input needs
14:46:16 <kmc_> they have discrete menu / linguistic input
14:46:17 <dankna> luqui: My prototype doesn't support Linux yet, but I do support Win and Mac
14:46:20 <luqui> dankna, will you announce on cafe when you release?
14:46:22 <kmc_> and will shoehorn it into a grid of buttons
14:46:27 <kmc_> because "users want a GUI"
14:46:27 <dankna> luqui: yes, absolutely!
14:46:30 <luqui> linux is easy after you've got win and mac :-)
14:46:36 <dankna> yeah, that's my take too
14:46:47 <dankna> I just don't want to add it yet because it'll slow down my prototyping cycles
14:47:02 <luqui> dankna, great.  i'm stuck with using glut right now, which is a major pain in the ass.  i would prefer any of the others :-)
14:47:10 <dankna> excellent :)
14:47:20 <conal> dankna: please check out GtkTV and see if you think your library can be wrapped similarly.
14:47:27 <kynky> there is wxhaskell
14:47:29 <dankna> conal: hmmm, all right
14:47:48 <conal> kynky: which kills its host process (e.g. ghci) on a second gui start
14:48:12 <dankna> I've never used tangible values; what would need to be done?
14:48:43 <dankna> but my library is a solution for programs that want to run with OpenGL, not for programs that need widgets - widget support could be implemented on top, but it's not in scope for me for this project at least
14:48:49 <conal> luqui: what's currently painful for you about glut?
14:48:56 <sizur> what examples of ReadP can I study?
14:49:04 <dankna> my hypothetical future library would be widget stuff, but that's vaporware :)
14:49:14 <MissPiggy> sizur, I have a rally basic one
14:49:38 <kynky> qthaskell is getting better i thought
14:49:45 <sizur> MissPiggy: do you have a link?
14:49:46 <luqui> conal, callback wrangling, and, afaict, a totally unreliable timer
14:50:06 <MissPiggy> just trying to find it now...
14:50:19 <conal> i'm thinking about a denotative GUI lib again, like Fruit was.  since libs like wxhakell and gtk2hs are so complex & thoroughly imperative, my guess is that starting from scratch on OpenGL would be easiest.
14:50:21 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16355
14:50:30 <dankna> hmm
14:50:42 <MissPiggy> sizur, this shows a little language with two functions: one turns it into a parser and the other turns it into a pretty printer
14:50:50 <luqui> conal, you just described my current project.
14:51:07 <sinelaw> and that project will be more than welcome
14:51:11 <conal> luqui: :)  collaboration possibilities?
14:51:37 <MissPiggy> I think "denotative GUI" sounds cool but what is that? :)
14:51:56 <dankna> well, I'm not that far from an early release of Emerald Frame, maybe a couple weeks.  I'll definitely post to the list when it's ready!  Thanks for the encouragement.
14:52:05 <conal> MissPiggy: a GUI library with a precise semantic model.
14:52:06 <monochrom> GUI designed by "denotational design".
14:52:12 <kynky> you could do an svg based application , there is svg support in cairo inside gtk2hs iirc, which can basically use an opengl backend for speed
14:52:14 <conal> MissPiggy: denotational style.
14:52:15 <luqui> conal, yes!  it is a prereq to my game, so I will be kind of building it by-demand
14:52:19 <MissPiggy> sizur if you want to see some much more advanced examples then augustss' Cube has some
14:52:34 <kynky> svg based gui i mean
14:52:35 <MissPiggy> conal like HTML?
14:52:38 <conal> luqui: cool.  let's talk.
14:52:42 <luqui> conal, you might not like it.  it is functional reactive arrow based, and the semantics are loose in the interest of productivity (i get blocked trying to find the right thing)
14:52:50 <monochrom> "denotational design" means design the denotational semantics first, before designing the API.
14:52:59 <luqui> but of course i am open to refinements, gradually becoming more precise, like g-dc did :-)
14:55:40 <conal> MissPiggy: see the paper "Genuinely functional user interfaces".  Also "Denotational design with type class morphisms".  Links to both on http:/conal.net/papers
14:55:44 <luqui> conal, essentially, i put more priority on not having to be stuck in IO-callback land to make guis than having an exact semantics.
14:55:45 <sizur> MissPiggy: thanks
14:56:50 <Sgeo_> :t put
14:56:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
14:57:00 <Sgeo_> :t get
14:57:01 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
14:57:19 <random_coder> can anyone point me at documentation on how haskell's hgl handle acquisation of vertex buffer objects? it seems like a very state-ful thing to do, yet it's in haskell
14:57:32 <Sgeo_> How does get actually obtain the state?
14:57:42 <c_wraith> get
14:58:09 <temoto> Sgeo_, it's an implementation detail.
14:58:10 <Sgeo_> get is the thing used in the State monad, right?
14:58:13 <Saizan> Sgeo_: depends on which instance we're talking about
14:58:17 <conal> MissPiggy: i don't know whether html has a precise, tractable, and useful denotation.
14:58:24 <FliPPeh> Sgeo_: Yep
14:58:30 <IceDane> Does anyone here have a tutorial on monads that's any good, other than the introduction on haskell.org? It was a bit short and left me with a tiny bit of new understanding and way too many questions.
14:58:34 <Saizan> Sgeo_: for State, get = State (\s -> (s,s))
14:58:53 <luqui> IceDane, i am not sure monad tutorials do anything other than that
14:58:54 <kmc_> IceDane: did you read RWH?
14:59:05 <kmc_> it has a decent introduction
14:59:06 <IceDane> kmc_: Yes, been over the whole section on monads a couple of times
14:59:15 <c_wraith> > runState (replicateM 5 (modify (+10)) >> get) 3
14:59:16 <lambdabot>   (53,53)
14:59:19 <Saizan> IceDane: http://www.haskell.org/haskellwiki/Monads_as_computation
14:59:22 <conal> IceDane: i like http://www.reddit.com/r/haskell/comments/awqhz/what_does_monad_mean/
14:59:25 <IceDane> Going through it thorougly this time
14:59:30 <IceDane> I'll read both, thanks =)
14:59:32 * Sgeo_ is too tired to think that through
14:59:46 <conal> IceDane: also http://www.reddit.com/r/haskell/comments/a75u0/monad_documentation_hate/
15:00:22 <temoto> IceDane, most probably, you have to walk a long path of seeking analogies. And only when you give up seeking analogies, the true meaning will open by itself: it's just a type class with two methods.
15:00:23 <kmc_> IceDane: i wouldn't worry too much about what monads "are" until you're comfortable using a few of them
15:00:26 <Saizan> conal: the comments or the article?
15:00:59 <Saizan> yeah, don't read any tutorial that talks too much about analogies :)
15:01:06 <Zeiris> Is there a {-# LANGUAGE pragma that would automatically derive Num for me? (For a Vec3 type.)
15:01:10 <conal> Saizan: the comments, in the latter case.  the article in the former.
15:01:15 <kmc_> Zeiris: for an existing type
15:01:18 <kmc_> StandaloneDeriving
15:01:18 <ddarius> Just read "The essence of functional programming."
15:01:25 <kmc_> allows you to write "deriving instance Num Vec3"
15:01:33 <kmc_> temoto's right, in the end monads are not space suits or burritos, they're just instances of the typeclass named "Monad", which has a short definition that you can look up
15:01:54 <kmc_> also, many people who are "confused about monads" are actually confused about higher order functions or type classes
15:02:01 <conal> IceDane: high-order bit: if you're asking "what are monads?", you're probably asking the wrong question.
15:02:12 <kmc_> if you're not solid on both those concepts, you aren't ready to be confused about monads
15:02:14 <temoto> IceDane, it took me more than year to get that.
15:02:20 <conal> i'm with temoto & kmc_ .
15:02:42 <conal> there's a deep underlying confusion that has nothing to do with Monad.
15:02:43 <IceDane> So you are saying that I don't have to be a category theory wizard to understand monads?
15:02:45 <MissPiggy> conal, what comes after 'Genuinely Functional User Interfaces'?
15:02:54 <kmc_> IceDane: yeah
15:02:54 <conal> MissPiggy: ?
15:03:11 <MissPiggy> conal, the search for an arrow free version?
15:03:32 <IceDane> Because I took a look at category theory and I felt like I was trying to read an alian language.
15:03:35 <conal> IceDane: also that the goal of "understanding monads" is probably misguided.
15:03:36 <kmc_> people start to learn monads too early because of the hype, or because they want to write practical exercise programs early on.  the solution to the latter is to treat IO concretely and ignore the fact that it's a monad until later
15:03:41 <IceDane> How does anyone understand that stuff?
15:04:00 <sinelaw> i agree, tutorial should initially just teach do-syntax for using IO
15:04:00 <Zao> IceDane: Experience and an open mind.
15:04:02 <luqui> IceDane, the same way you learn an alien language
15:04:10 <Saizan> IceDane: no need for CT, actually you can use the understanding of Haskell as a starting point for CT
15:04:17 <conal> kmc_: amen.
15:04:26 <kmc_> the Haskell <=> CT connection is mostly a matter of "oh, that's cool"
15:04:30 <luqui> gradually, little bits at a time, gaining more fluency the more you use it
15:04:31 <IceDane> kmc_: Yeah, it seems to be the way RWH is doing it, at least
15:04:32 <MissPiggy> conal well why you would continue on this isn't Fruit good enuogh?
15:04:33 <kmc_> not anything that will help you write good code
15:04:56 <kmc_> the simple monad-less introduction to IO is http://haskell.org/haskellwiki/Introduction_to_IO
15:05:20 <ddarius> kmc_: No it isn't.
15:05:21 <Saizan> kmc_: well, that's not true either
15:05:30 <conal> MissPiggy: Fruit was a first step.  its implementation wasn't sustainable.  and the model wasn't exploited fully.
15:05:36 <dolio> Category theory could help you write better code.
15:05:55 <ddarius> You don't need to know CT to understand how monads are used -in Haskell- and that's usually what people want.  If you really do want to understand the concept of monads, you quite definitely need to know CT.
15:06:10 <dolio> By helping you identify useful abstractions and mathematical underpinnings of your code.
15:06:16 <IceDane> I've always been a fan of "Read up on stuff, then just write code, even if you struggle to, and you'll understand it". It works most of the time, but I'm trying to create something with mutable state and I feel like I'm trying to write an essay in the aforementioned alien language that I couldn't read
15:06:25 <Philonous1> kmc_: We could alleviate the monadic pain by teaching newbies to use interact and introduce them to the dark magic later?
15:06:25 <MissPiggy> now you make it sound like category theory is worth studying
15:06:36 <kmc_> Philonous1: i think that's too extreme
15:06:43 <luqui> IceDane, haskell is pure functional.  don't write something with mutable state.
15:06:45 <kmc_> good for starting out
15:06:48 <luqui> because you can't.
15:06:52 <kmc_> uh, yes you can
15:06:55 <luqui> shhh!
15:06:58 <kmc_> Haskell is pure functional and also imperative
15:07:09 <IceDane> Don't confuse me ;_;
15:07:15 <dibblego> <kmc_> Haskell is pure functional and also imperative <-- smashing the myth of a dichotomy
15:07:26 <luqui> IceDane, I'm serious though.  what problem are you trying to solve that needs mutable state?
15:07:27 <ddarius> MissPiggy: The concept of Monad is defined in categorical language and is a part of category theory.  Trying to learn "just monads" without learning category theory, would be like trying to learn the quadratic equation without knowing anything about algebra.
15:07:31 <luqui> can you phrase it in a way that it doesn't?
15:07:40 <MissPiggy> conal, I like this method with signals and stuff :) .. but where does the idea for 'Signal' come from?
15:07:41 <kmc_> if your problem is inherently imperative you should implement it in an imperative way.  but the harder you look, the fewer problems you'll find to be truly imperative
15:07:47 * QtPlatypus wonders if you realy kneed to know monads to write beginer leval haskell. "I wonder if it would be better to just have learners treat do syntax as syntax untill there intuation is nice and primed and then introduce modads as how this trick is implemented"
15:07:59 <conal> IceDane: i suggest deciding whether you want to learn haskell or functional programming.
15:08:00 <MissPiggy> conal (I am wondering like, if I wanted to design a command line system.. instead of signal what would I use?)
15:08:18 <Saizan> QtPlatypus: you've to understand the type errors
15:08:34 <conal> MissPiggy: i have a blog post about the origin of frp.  looking ...
15:08:43 <ddarius> Also, in my opinion, in many cases people who don't "get monads" (but can use them) actually just don't know how to provide a pure semantics for various effects, which is certainly more complicated and not something that will just "be obvious."
15:08:47 <QtPlatypus> Saizan: Can you expand on that thoughts.
15:08:48 <Saizan> QtPlatypus: so you at least have to teach them that actions have a different type from values, or something like that
15:08:59 <MissPiggy> ddarius: but I know how to program with monads, and then roconnor said that I found out that a UFD is a monad or something.. but its' not the same kind of monad is it? So what does it do..
15:09:00 <conal> MissPiggy: http://conal.net/blog/posts/early-inspirations-and-new-directions-in-functional-reactive-programming/
15:09:09 <IceDane> luqui: Basically, as an exercise, I'm trying to add some functionality to the ircbot code provided in the tutorial on haskellwiki, that executes a function when 10 seconds have passed every time
15:09:13 <QtPlatypus> Saizan: Ah
15:09:14 <ddarius> QtPlatypus: You can write tons of code that doesn't use IO or monads at a beginner level.
15:09:14 <MissPiggy> conal ty
15:09:16 <IceDane> so I'd have to update the timer again and again..
15:09:21 <dolio> What's a UFD?
15:09:34 <kmc_> IceDane: you don't execute a function
15:09:40 <temoto> conal, what is that Fruit you're talking about?
15:09:43 <IceDane> kmc_: I know, I know
15:09:45 <luqui> well you can execute an action
15:09:48 <conal> MissPiggy: one chain of evolution is TBAG, ActiveVRML, Fran, Yampa .
15:09:48 <IceDane> Don't batter me for my bad terminology
15:09:57 <QtPlatypus> ddarius: Sure, but if you wish something to happen then you don't.  And interacting with the real world is a useful thing.
15:10:03 <sinelaw> Reactive?
15:10:09 <MissPiggy> conal hey that's nice!!
15:10:12 <IceDane> conal: What do you mean by learning haskell vs. learning functional programming?
15:10:13 <kmc_> IceDane: it's important to be precise.  it's not a personal attack on you
15:10:37 <conal> temoto: http://conal.net/papers/genuinely-functional-guis.pdf
15:10:48 <luqui> IceDane, okay yeah IO is what you want.  Maybe forkIO, forever, and threadDelay?  Or do you want it synchronous.
15:10:51 <kmc_> it's important to understand that functions and monadic actions are two orthogonal first-class types.  otherwise you end up in the trap of thinking that monads are just type-tags on impure functions
15:11:19 <ddarius> QtPlatypus: Using interact or some such, or just program in GHCi.  You and I said beginner-level code.
15:11:38 <kmc_> i think the non-polymorphic
15:11:45 <IceDane> What is all this that (I think) I have read about modifying the state of monads? Like local in Reader or something?
15:11:47 <kmc_> return and (>>=) are not too hard for a beginner to understand
15:11:49 <sinelaw> i read so much frp stuff, and yet there is so much more
15:11:54 <roconnor> ddarius: re: monad, monads in Haskell are far less general than categorical monads.  There is nothing wrong with learning Haskell monads without learning category theory.
15:11:58 <MissPiggy> what's frp?
15:12:09 <sinelaw> function reactive programming
15:12:12 <sinelaw> *functional
15:12:14 <kmc_> IceDane: that's something you can do in some monads
15:12:16 <MissPiggy> yeah but what's that
15:12:22 <ddarius> roconnor: That's the first thing I said.
15:12:22 <kmc_> just like you can print characters or send network packets in other m onads
15:12:28 <kmc_> it's not part of the definition of a monad
15:12:40 <roconnor> ddarius: ah sorry
15:12:51 <kmc_> IceDane: do you know how to use the Maybe monad?
15:12:53 <temoto> MissPiggy, it's what conal researching. Our new secret weapon.
15:12:55 <kmc_> and what it's good for?
15:13:10 <IceDane> kmc_: To some extent, yes. I did all the exercises in All about monads on haskell.org
15:13:17 <conal> IceDane: i mean orginally haskell was about functional programming.  at some point, folks figured out how to encode imperative programming in haskell.  so now a lot of haskell programming is imperative.
15:13:23 <kmc_> IceDane: could you implement your own Maybe-like type, and make it an instance of Monad?
15:13:31 <dolio> Our 20-year-old secret weapon? :)
15:13:39 <IceDane> kmc_: I could try, heh
15:13:51 <kmc_> Haskell is about functional programs, that is functions that manipulate data types, some of which happen to represent descriptions of imperative actions
15:13:52 <temoto> MissPiggy, when everyone will finally understand monads, we will go like "Do you know FRP then?! No? Learn it! And here's burrito tutorial, btw."
15:14:00 <kmc_> hahaha temoto
15:14:04 <conal> perhaps imperative programming is the killer app for haskell.  rather different from the early intentions -- what landin called denotative programming.
15:14:14 <IceDane> temoto: Monads are burritos!
15:14:23 <IceDane> If only I could abstract in such a manner
15:14:28 <MissPiggy> :(((
15:14:29 <conal> IceDane: Monad relates to I/O as list reversal relates to bananas. http://bit.ly/d9EbSz
15:14:36 <MissPiggy> this stuff is really interesting I want to read stuff for hours
15:14:42 <MissPiggy> I have other things to do it's so disappointing
15:14:42 <temoto> IceDane, ironically, i still don't know what a burrito is.
15:14:46 <IceDane> conal: I read it, I understood.
15:14:52 <kmc_> burritos are delicious is what they are
15:14:54 <sinelaw> MissPiggy, same here
15:14:59 <kmc_> where do you live that you can't buy a burrito
15:15:06 <conal> IceDane: cool.  :)
15:15:09 <luqui> temoto, burritos are like monads.
15:15:28 <ddarius> kmc_: From what I've seen, it's not too easy to get a burrito in Japan.
15:15:30 <lpsmith> so,  is anybody familiar with this code:   http://www.mail-archive.com/haskell-cafe@haskell.org/msg27612.html
15:15:31 <temoto> I know that it's something eatable, but don't know exactly what.
15:15:38 * monochrom turns off css
15:15:42 <lpsmith> Has anybody worked on simplifying that at all?
15:15:43 <ddarius> eatable = edible
15:16:07 <olsner> kmc_: I've never seen a burrito afaik... some kind of mexian wrap supposedly
15:16:39 <kmc_> i am astounded
15:16:45 <kmc_> at your collective burrito ignorance
15:16:48 <temoto> kmc_, i live in russia and google dictionary doesn't have a translation http://www.google.com/dictionary?langpair=en|ru&q=burrito&hl=en&aq=f :)
15:16:50 <olsner> really, we'd just call it "some kind of taco" here
15:16:55 <kmc_> it's not like a taco
15:17:04 <ddarius> kmc_: It's vaguely like a soft taco.
15:17:25 <Zao> It's a soft taco, with some kind of tortilla bread instead of the hard shell, it seems.
15:17:35 <Zao> Canonically "taco" in civilized countries.
15:17:36 <kmc_> it's rice, beans, cheese, meat, hot sauce, sour cream, guacamole, tomatoes, peppers, etc. rolled up in a tortilla
15:17:43 <olsner> can a soft taco have a hard shell?
15:17:58 <sinelaw> this is what happens when we try to discuss monads
15:18:01 <ddarius> olsner: ... in one way, sort of.
15:18:03 <kmc_> in the US at least, a soft taco is served open-face and eaten more like a hard taco
15:18:07 <kmc_> i.e. you fold rather than roll it
15:18:12 <sinelaw> even if we try to discuss about NOT discussing monads
15:18:14 <kmc_> a rolled fried soft taco would be a taquito
15:18:30 * sinelaw is hungry now
15:18:39 <tensorpudding> what exactly is the original taco like?
15:18:40 * MissPiggy Push-pull Functional Reactive Programming
15:18:48 <kmc_> i hear that hard tacos are not authentically mexican
15:18:49 <ddarius> kmc_: From what I've seen/heard, in Mexico, a taco is usually soft and flat.
15:18:54 <sshc> discussion about not discussing monads is discussion about monads
15:18:57 <tensorpudding> is it like what Taco Bell might call a soft taco
15:19:05 <sinelaw> sshc, nope, it's about tacos
15:19:09 <kmc_> what taco bell might call a soft taco is usually called "food poisoning"
15:19:13 <sshc> sinelaw: what is?
15:19:18 <ddarius> tensorpudding: Hold on a sec and I'll get you a (link to a) picture.
15:19:27 <sinelaw> sshc, not discussing monads
15:19:34 <MissPiggy> So it should be called;   Functional Temporal Programming
15:19:36 <monochrom> A Chinese researcher goes to ICFP for the first time. He goes to a Mexican restaurant with new-met friends. He asks "what are burritos?" His friends say "like monads". He is enlightened.
15:19:38 <kmc_> maybe a functor is like a taco
15:19:39 <tensorpudding> i've eaten authentic mexican food, which had things similar to soft tacos
15:19:42 <waterlaz> hi
15:19:44 <tensorpudding> except you filled them yourself
15:19:46 <IceDane> If I ever own a mexican restaurant, I'll naem one burrito on the menu "The Monad".. Then the ingredients will be so complex no one will understand.
15:19:48 <sinelaw> MissPiggy, how did you get that conclusion so fast?
15:19:53 <sshc> sinelaw: discussion about not discussing monads doesn't always involve tacos.
15:19:53 <tensorpudding> and i don't think they were called soft taco
15:19:59 <kmc_> IceDane: there are only two ingredients ;)
15:19:59 <MissPiggy> sinelaw it says it XD
15:20:04 <sinelaw> ah :)
15:20:09 <MissPiggy> I'm cheating
15:20:11 <sshc> sinelaw: duscission about not discussing monads involves monads.
15:20:11 <dolio> You're thinking of fajitas.
15:20:11 <waterlaz> can anyone suggest something good to read on haskell core language?
15:20:13 <sinelaw> heh
15:20:13 <IceDane> kmc_: Alright, then no one would understand how to eat it.
15:20:16 <temoto> kmc_, http://shaverma-msk.ru/wp-content/themes/GreenW/images/rss.gif does it remind burrito at least a bit?
15:20:28 <kmc_> temoto: yes, that's a burrito
15:20:31 <tensorpudding> it was a big plate of fillings and a stack of real flour tortillas
15:20:41 <sinelaw> waterlaz, i can't, but someone gave me this link http://hackage.haskell.org/trac/ghc/wiki/AboutVideos
15:20:47 <pikhq> temoto: That's a delicious-looking burrito.
15:20:52 <olsner> kmc_: what's a fajita then?
15:20:59 <kmc_> if you google image search "burrito" and ignore the pictures with cats in them, it's pretty accurate
15:21:03 <dolio> tensorpudding: Those were fajitas.
15:21:24 <conal> spotted on twitter: "The 70% solution is usually the 40% solution, described by someone who can't tell the difference." - Gilad Bracha
15:21:29 <tensorpudding> i thought fajitas referred to the fillings, not the method
15:21:34 <waterlaz> sinelaw, this looks nice though not exactly what I was looking for
15:21:37 <ddarius> tensorpudding: Some tacos in Mexico: http://www.ginnyman.com/media/20080107/Image00004.jpg Also some tacos in Indiana: http://www.ginnyman.com/media/20080107/Image00008.jpg.
15:21:41 <waterlaz> thanks anyway
15:21:48 <sinelaw> waterlaz, I know, but thought it might help
15:22:22 <tensorpudding> look tasty
15:22:34 <kmc_> i think fajitas are usually served disassembled with tortillas
15:22:38 <tensorpudding> fajita is a tex-mex term, according to wikipedia
15:22:39 <kmc_> you put them together yourself
15:22:45 <dolio> tensorpudding: Considering almost all Mexican food I've ever encountered has interchangeable ingredients for the most part, I think it's mostly about the method.
15:22:46 <conal> MissPiggy: yes, i prefer "temporal" to "reactive".
15:23:13 <tensorpudding> originally only referred to skirt steak, now any type of filling
15:23:19 <kmc_> what we need is a generic library of mexican food combinators
15:23:20 <conal> MissPiggy: though maybe "temporal functional programming", so as to avoid "FTP"
15:23:41 <tensorpudding> unsafeEatMexican
15:23:43 <ddarius> dolio: Pasta isn't much better.  There it's mostly about the shape...
15:23:50 <tensorpudding> may perform unintended side-effects
15:23:50 <dolio> Yeah.
15:23:51 <temoto> Okay, then we have burritos, it's called  (shaurma') but is made of completely other set of ingredients: meat, some vegetables and some sauces.
15:23:54 <olsner> what we need is a generic library of mexican food combinators => burrito transformers!
15:24:13 <tensorpudding> different pastas and sauces
15:24:20 <kmc_> shawarma in the US is not much like burritos in the US
15:24:23 <dolio> If it's relatively small and folded, it's a taco. If it's large and wrapped up, it's a burrito. If it's served on a plate sizzling for your to assemble, it's fajitas...
15:24:30 <tensorpudding> bolognaise is good
15:24:37 <kmc_> except in that both are tasty as hell
15:24:45 <olsner> what's it called when you wrap it and gratinate it with cheese?
15:24:47 <sinelaw> falafel is better
15:24:50 <IceDane> kmc_: shawarma = middle east or so, burrito = mexican
15:24:57 <sinelaw> (just to feel i'm on-topic)
15:24:57 <kmc_> yeah
15:25:03 <tensorpudding> tamales are the ones that are wrapped in corn husks right?
15:25:26 <dolio> Yes.
15:25:43 <tensorpudding> they use corn tortillas on those
15:26:27 <tensorpudding> hmm, they are sometimes wrapped in plantain or banana leaves
15:27:54 <roconnor> MissPiggy: what is a UFD?
15:28:09 <MissPiggy> unique factorization domain
15:28:19 <MissPiggy> roconnor maybe I already forgot what it was you said..
15:28:22 <MissPiggy> something about monads anyway
15:28:33 <roconnor> the composition of adjoint functors is always a monad
15:28:37 <MissPiggy> im rubbish at category theory anyway
15:28:46 <kniu> Since Haskell is non-strict anyway,
15:29:00 <roconnor> I've been practicing my CT lately
15:29:16 <kniu> why have (if ... then ... else ...) when a simple function (if :: Bool -> a -> a -> a) will suffice?
15:29:18 <MissPiggy> I think I need an easier book :)
15:29:40 <ddarius> roconnor: One way of composing them.  The other way is a comonad.
15:29:45 <roconnor> I haven't really been studing from a CT book.  I'm trying to undertand algebraic specifications
15:30:05 <temoto> kniu, i think that 'then' and 'else' stand for parens around 2nd and 3rd 'a' there.
15:30:12 <MissPiggy> roconnor can you tell me a tiny bit about algebraic specifications?
15:30:21 <mauke> kniu: "user friendliness"
15:30:22 <ddarius> MissPiggy: Have you read Awodey's book?
15:30:28 <roconnor> MissPiggy: it is multi-sorted universal algebra
15:30:38 <MissPiggy> ddarius, no mine is Sets for Mathematics
15:30:52 <luqui> kniu, amen!  though "bool :: a -> a -> Bool -> a" is more common for me
15:32:01 <ddarius> MissPiggy: From a description of it, that's probably not a good introduction to CT.  It doesn't sound like the intent of it either.
15:32:02 <waterlaz> nah if then else is somewhat more pleasent to read
15:32:26 <waterlaz> same thing as to write [1, 2, 3] and nor 1:2:3:[]
15:32:31 <waterlaz> *not
15:32:47 <temoto> > let if' cond a b = if cond then a else b in (if' (5 == 5) ("looks like lisp") ("looks like haskell"))
15:32:48 <lambdabot>   "looks like lisp"
15:33:31 <roconnor> edwardk should write a Haskell category theory book
15:34:13 <bfh6558> ghc does not like tabs does it? is there someplace I can find haskell styling guidelines so i can make a .vim filetype?
15:34:20 <sinelaw> "haskell category theory for 3d graphics"
15:34:21 <kmc_> style guideline: never use tabs, ever
15:34:41 <tromp> don't even think about it
15:34:55 <MissPiggy> ddarius I think that I don't have enough algebra to properly learn category theory anyway
15:35:02 <temoto> bfh6558, it's a software it can't "like" anything. :) The problem here is that GHC treats tabs as 8 spaces and that's not usable.
15:35:06 <Veinor> what kmc_ said is true for programming in general
15:35:11 <kmc_> @quote anthro
15:35:12 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
15:35:16 <bfh6558> whats a good size for space emulated indentation
15:35:28 <Veinor> 4 or 8
15:35:30 <kmc_> 2
15:35:33 <kmc_> whatever
15:35:35 <kmc_> 9000
15:35:38 <Veinor> 1!
15:35:41 <kmc_> use a tiny font
15:35:41 <ddarius> MissPiggy: In theory, you don't really need any (abstract) algebra to learn category theory.  You definitely don't need much.
15:35:44 <Veinor> but seriously, either 4 or 8
15:35:57 <Veinor> 8 is the unix standard, but I think it's a bit much
15:36:02 <kmc_> you don't need any abstract algebra to learn category theory, because it's abstracter algebra
15:36:03 <temoto> bfh6558, 2 or 4.
15:36:08 <ddarius> MissPiggy: It will be very beneficial to have a good grasp on one or two other fields of mathematics/logic as category theory is mostly applied to other things.
15:36:14 <kmc_> that sounds a bit like saying you don't need high school algebra to learn abstract algebra
15:36:26 <bfh6558> ddarius: the algrebra can surely be associated with the underlying principles of category theory
15:36:41 <bfh6558> ddarius: and by category theory do you mean set theory?
15:36:59 <ddarius> kmc_: Well... you don't.  But, also, categories are rarely treated as algebraic structures.
15:37:05 <MissPiggy> ddarius yeah I just mean that if I tried to learn everything in terms of SET then I wouldn't really understand it
15:37:09 <sinelaw> you have to learn some abstract math first at least to make the way-of-thinking more accessible
15:37:13 <bfh6558> may i remind you of the set of all natural numbers
15:37:16 <MissPiggy> but all the other categories are aliens to me
15:37:17 <bfh6558> the set of all integers
15:37:20 <bfh6558> and the set of all real numbers
15:37:34 <ddarius> MissPiggy: You can reduce (almost) everything in category theory to set theory.  That's what representable functors pretty much do.
15:37:45 <sinelaw> there's a theorem about that no?
15:38:04 <bfh6558> good question
15:38:08 <sinelaw> that every category can be tortured into something like SET, no
15:38:09 <sinelaw> ?
15:38:14 <ddarius> sinelaw: I agree with you insofar as having "mathematical maturity" will practically be a requirement, but that's true for any going in-depth in any field of mathematics.
15:38:29 <sinelaw> ddarius, that's all i was saying, so yes :)
15:38:31 <monochrom> Haskell is very precise about what tab means. No myth or magic, just a bit complicated. If you want to use tabs, be sure to read http://haskell.org/onlinereport/syntax-iso.html#sect9.3
15:39:26 <bfh6558> monochrom: thanks :P i think i'll just set expand tab and set tabstop to 2
15:39:36 <monochrom> Yes that's a simpler thing to do.
15:42:39 <m___> hello
15:43:02 <m___> How do i find the length of a string in haskell?
15:43:09 <ddarius> length
15:43:10 <IceDane> length str
15:43:24 <m___> I have this : len (x:xs) = len xs + 1
15:43:45 <MissPiggy> you must also have len [] = 0
15:43:58 <MissPiggy> every list is either x:xs or []
15:44:20 <monochrom> > length [4,1,3,9]
15:44:21 <lambdabot>   4
15:44:41 <MissPiggy> > length [1]
15:44:42 <lambdabot>   1
15:44:43 <MissPiggy> > length "four"
15:44:44 <lambdabot>   4
15:44:58 <waterlaz> so maybe someone can answear a simple question on haskell core ?
15:45:32 <waterlaz> it has these cases
15:45:49 <m___> i still can't get it to compile
15:45:49 <monochrom> "Hi how do you convert English strings to numbers? For example four to 4."  "length"  "Thanks that works great!"
15:46:03 <MissPiggy> lol
15:46:04 <osaunders> monochrom: lol
15:46:04 <m___> i need to write the function
15:46:04 <waterlaz> case smth of {__DEFAULT ->   .... ; smth_else -> ....}
15:46:20 <waterlaz> why __DEFAULT is the first?
15:46:32 <osaunders> Does the Functor instance for Either only apply the function to one side?
15:46:39 <MissPiggy> osaunders yeah
15:46:47 <osaunders> Isn't that bad?
15:46:49 <monochrom> waterlaz: Do you know what is the type of smth?
15:46:52 <MissPiggy> no it's fine
15:46:55 <waterlaz> Int
15:47:01 <osaunders> MissPiggy: What makes it fine?
15:47:16 <monochrom> Interesting.
15:47:17 <IceDane> I have a feeling that there is something stupid wrong with this, but why won't this compile? This is almost copied from http://www.haskell.org/all_about_monads/html/class.html, except with my own maybe type.
15:47:17 <MissPiggy> osaunders, well it satisfies the functor laws, and it's impossible to do the other thing
15:47:21 <IceDane> eh
15:47:24 <IceDane> http://www.haskell.org/all_about_monads/html/class.html
15:47:37 <osaunders> MissPiggy: Hm, Ok.
15:47:54 <MissPiggy> osaunders, the instance is not actualy for Either, but for  Either e
15:48:03 <Saizan> IceDane: "this" being?
15:48:10 <osaunders> MissPiggy: What does e stand for?
15:48:12 <MissPiggy> osaunders, so for example,   fmap :: (a -> b) -> (Either e a -> Either e b)
15:48:29 <waterlaz> monochrom, the full Core for the function goes like this: http://pastey.net/132797
15:48:32 <IceDane> Saizan: The link i pasted right afterwards.
15:48:34 <MissPiggy> osaunders, so it would not typecheck if you tried to apply the function on the Left's content
15:49:03 <Saizan> IceDane: so the code on all about monads?
15:49:23 <osaunders> MissPiggy: Wouldn't it be equally valid instance if applied to left instead of right?
15:49:34 <MissPiggy> no
15:49:38 <IceDane> oh, Saizan, sorry. link didn't copy properly
15:49:43 <IceDane> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19283
15:49:44 <IceDane> there
15:49:48 <MissPiggy> osaunders, you'd have to implement an instance for  Flip Either e
15:49:57 <MissPiggy> osaunders, but Flip can't be defined :(
15:50:05 <`Zerax`> You don't have access to the type of the first type argument in the definition of fmap
15:50:24 <osaunders> MissPiggy: Ah.
15:50:32 <osaunders> OK
15:50:36 <osaunders> Thanks :-)
15:50:49 <Saizan> IceDane: (f x :: MyMaybe b) already, you shouldn't wrap it in Only
15:50:54 <doserj> IceDane: the rule for Only x is wrong
15:51:03 <MissPiggy> osaunders, there is something like a Bifunctor that you can define for Either, I think.. which would have bimap :: (p -> q) -> (u -> v) -> (Either p u -> Either q v)
15:51:04 <Philonous1> newtype Flip f b c = Flip (f b a)
15:51:17 <Philonous1> Errr
15:51:27 <Saizan> IceDane: the code for Maybe doesn't use Just (f x), in fact
15:51:27 <Philonous1> Flip (f c b)
15:51:35 <IceDane> oh, that's right
15:51:43 <luqui> > (+1) ||| (-1) $ Left 42
15:51:43 <IceDane> I knew it was something stupid. Thanks =)
15:51:44 <lambdabot>   No instance for (GHC.Num.Num (c -> b))
15:51:44 <lambdabot>    arising from a use of syntactic n...
15:51:50 <luqui> > (+1) +++ (-1) $ Left 42
15:51:51 <lambdabot>   No instance for (GHC.Num.Num (b' -> c'))
15:51:51 <lambdabot>    arising from a use of syntactic...
15:52:01 <luqui> huh, what am i thinking of
15:52:03 <Berengal> Type classes, fast code, no diamond-dependency-instance problem. Choose two :(
15:52:05 <doserj> > (+1) ||| (subtract 1) $ Left 42
15:52:07 <lambdabot>   43
15:52:12 <luqui> oh whoops :-p
15:52:17 <osaunders> Philonous1: I don't even know what newtype is/
15:52:30 <glguy> Does anyone know of a bug (or common mistake) in template haskell that causes functions using template haskell to become mutually recursive with their call-sites?
15:52:41 <Berengal> osaunders: Same as data, but restricted, and compiled away
15:52:53 <luqui> :t (+++)
15:52:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
15:53:17 <luqui> :t (|||)
15:53:17 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
15:53:26 <Berengal> osaunders: Or: Like data at compile time, like type at runtime
15:54:03 <osaunders> Too sleepy for this.
15:54:31 <Berengal> Just ignore the difference, and use newtype if your datatype only has one constructor with one field
15:56:35 <MissPiggy> osaunders: you can just s/newtype/data/ it's the same thing
15:57:07 <Berengal> Well, if you want to be technical about it, there are some semantic differences
15:57:23 <MissPiggy> if you want to be technical about it, get some sleep first :P
15:58:23 <Berengal> > (case undefined of Sum _ -> "Yay", case undefined of Just _ -> "Boo")
15:58:24 <lambdabot>   ("Yay","* Exception: Prelude.undefined
15:59:18 <HugoDaniel> hi
15:59:33 <HugoDaniel> are there any benchmarks of ghc 6.10 vs 6.12 ?
16:00:12 <lpsmith> Ok,  I'm trying to build packedstring on ghc-6.12,   and cabal-install breaks the build,  but runghc Setup.hs works
16:00:28 <osaunders> http://www.plazaplzen.eu/img/obchody/Bench-01.jpg
16:02:24 <lpsmith> ack
16:02:35 <lpsmith> the problem is this
16:03:17 <lpsmith> I'm getting the same problem for template-haskell
16:03:51 <lpsmith> " Could not find module `Data.Data':   It is a member of the hidden package `base'.  Perhaps you need to add `base' to the build-depends in your .cabal file."
16:04:06 <lpsmith> However,  I don't get that error if I don't specify cabal install --user
16:04:16 <lpsmith> If I just use cabal install,  it works fine
16:04:32 <Berengal> template-haskell is part of the ghc distribution. I don't think you can reinstall it
16:05:25 <lpsmith> well,  but cabal install is picking it up as a dependency
16:05:35 <lpsmith> I'm trying to install something else,  actually
16:06:11 <Berengal> Then that something else doesn't build on 6.12. At least not without fiddling with its cabal file
16:06:17 <kbateman> I look in my /usr/share/doc/ghc-blah directory, and there are a bunch of .haddock files.
16:06:38 <kbateman> Do I need to manually use haddock to generate readable documentation from them?
16:07:41 <kbateman> Or is there some .haddock reader I'm supposed to have?
16:08:03 * Berengal just uses documentation=True in his cabal config
16:08:09 <glguy> is this a bug or curious expected behavior? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19294#a19295
16:08:10 <Berengal> It builds html docs
16:08:21 <Saizan> lpsmith: what are you trying to install?
16:08:36 <lpsmith> Complexity
16:09:01 <Saizan> glguy: curious behaviour demanded by the haskell report
16:09:21 <glguy> Saizan, oh, can you ellaborate?
16:09:24 <glguy> elaborate*
16:09:53 <glguy> I don't see any mutual recursion
16:10:28 <Saizan> mh, actually i didn't check that
16:11:06 <Saizan> quite weird then
16:11:17 <kbateman> Do I have to use cabal to reinstall all my packages then?
16:11:38 <dankna> @faq Do I have to use cabal to reinstall all my packages then?
16:11:39 <lambdabot> The answer is: Yes! Haskell can do that.
16:11:57 <dankna> Can't count how many times I've had to do that dance :)
16:12:07 <Saizan> kbateman: are you sure there isn't an .html version of those docs too?
16:12:30 <kbateman> Not in my ~/.cabal,, nor in my /usr/share/docs/ghc-*
16:12:39 <Berengal> kbateman: Look in $HOME/.cabal/share/doc
16:12:50 <dankna> look in /usr/share/docs/package-name/...
16:13:45 <Saizan> use ghc-pkg describe $pkg
16:14:08 <Saizan> it'll give you an haddock-html field
16:14:13 <kbateman> I just want to get to a local .html version of the library docs.
16:14:22 <kbateman> Which pkg should I run it on?
16:14:29 <dankna> the one you want docs on
16:14:42 <kbateman> Say, Data.List.  Which package do I run to get that one?
16:14:46 <dankna> that's in base
16:15:32 <kbateman> Wow, html!  How did I miss that...
16:15:50 <dankna> haha, as long as you have it now
16:15:54 <kbateman> /usr/share/doc/ghc6-doc/ibraries/base
16:15:59 <lpsmith> Saizan, cabal and/or cabal-install's handling of documentation on systems with multiple versions of ghc installed really needs improvement :-/
16:16:31 <kbateman> Thanks, guys.
16:16:46 <Saizan> lpsmith: some detail?:)
16:17:01 <Berengal> cabal-install needs to tell haddock to link to sources...
16:17:37 <kbateman> I was looking under /usr/share/ghc6-doc, not /usr/share/doc/ghc6-doc.  Both of those directories are there...
16:17:39 <lpsmith> Saizan,  http://hackage.haskell.org/trac/ghc/ticket/3795
16:18:15 <lpsmith> Although that would be a way to go forward,  it's still tricky to work with previous versions of ghc
16:18:43 <lpsmith> I've installed each version of ghc in their very own root,   /usr/local/ghc/version-number/
16:19:01 <Saizan> mh, it needs to be handled a bit like ghc-pkg
16:19:11 <lpsmith> And then set up soft-links in /usr/local/bin
16:19:25 <Saizan> the problem is that you can upgrade haddock indipendently and have it work too
16:19:30 <lpsmith> including haddock-version-number
16:20:20 <lpsmith> now,  cabal install has an building documentation feature,  but there isn't a separate set of documentation for each version of ghc
16:20:27 <lpsmith> it's all lumped into one directory
16:20:59 <lpsmith> err, auto-build documentation feature
16:21:33 <Saizan> you mean the user index? or what?
16:21:39 <lpsmith> It's almost more trouble than it's worth,  but then again getting a nice set of documentation up locally is not easy at this point in time
16:22:06 <dankna> yeah - I would definitely cast my vote for making both those changes
16:22:25 <dankna> the version number for the haddock executable and the separate directories for different ghc versions
16:22:43 <dankna> the doc directories should ideally be structured the same way the library directories are
16:23:16 <dankna> which I think is something like foo-1.0/ghc-16.12.1/bar
16:23:47 <dankna> I was somewhat surprised it wasn't already like that, since the installation stuff is nice and clean for actual binaries
16:24:03 <Saizan> oh, funny, i thought they were
16:24:16 <dankna> I don't believe they are
16:24:33 <Saizan> you can change that from the ~/.cabal/config file directly, i think
16:24:58 <dankna> I'm fairly sure that if you have two versions of ghc and try to install the docs for the same package on both, they'll step on each other
16:25:03 <dankna> hmm, can you?  okay
16:25:35 <Saizan> instead of "docdir: $datadir/doc/$pkgid" you make it "docdir: $datadir/doc/$pkgid/$compiler"
16:25:46 <lpsmith> Saizan, ok,  for example,  I  "cabal unpack colour";  "cd colour-2.whatever";  "cabal configure --user --with-ghc=ghc-6.10.4  --with-haddock=haddock-6.10.4",  "cabal build"; "cabal haddock";  "cabal haddock --hyperlink-source"
16:26:26 <dankna> I have now made that change on my system, thank you Saizan.  My request now becomes, make it the default :D
16:26:47 <Saizan> dankna: open a ticket :)
16:27:00 <dankna> sigh, but I don't wannnnnna :) all right, I guess
16:27:34 <Saizan> lpsmith: i see
16:27:35 <lpsmith> and then when I "cabal install --user --with-ghc=ghc-6.10.4 --with-haddock=haddock-6.10.4",   I get a bunch of errors like Warning: Cannot read /usr/local/share/doc/HTTP-4000.0.9/html/HTTP.haddock:   "Interface file is of wrong version: /usr/local/share/doc/HTTP-4000.0.9/html/HTTP.haddock"
16:27:57 <waterlaz> guys, does Haskell check for Int overflow?
16:28:00 <lpsmith> the docdir suggestion might help
16:28:06 <Saizan> waterlaz: no
16:28:07 <waterlaz> and how do I get rid of it?
16:28:10 <waterlaz> huh
16:28:15 <Sgeo_> In http://members.chello.nl/hjgtuyl/tourdemonad.html
16:28:20 <Sgeo_> It claims:
16:28:21 <Sgeo_> The equivalent of foldr can be achieved by:
16:28:21 <Sgeo_>   foldrM f a xs = foldM f a (reverse xs)
16:28:45 <Sgeo_> However, if my understanding is correct, it won't work when xs is an infinite list
16:28:47 <waterlaz> well I'm looking at the core and it looks the opposite
16:29:02 <Saizan> Sgeo_: yeah, i wouldn't really call that an equivalent of foldr
16:29:25 <Saizan> waterlaz: which type are you using? Int or Integer?
16:29:31 <waterlaz> Int
16:29:55 <Saizan> > maxBound + 1 :: Int
16:29:56 <lambdabot>   -9223372036854775808
16:30:20 <waterlaz> it checks if the result equals to -9223372036854775808 every time
16:30:21 <Saizan> i'm not sure what happens at the core level, though the behaviour is to just overflow
16:31:01 <waterlaz> I compute stuff like ((r + (i * j) `rem` 100) `rem` 47)
16:31:19 <lpsmith> Saizan, do you have a nice set of locally generated documentation,  and if so,  how do you do it?
16:31:22 <Saizan> maybe your code is something like [1..] :: [Int] ?
16:31:30 <waterlaz> no
16:31:43 <`Zerax`> What behaviour do you want in an overflow condition?
16:31:55 <waterlaz> I tried to make the most stritforward code for the compiler
16:31:57 <MissPiggy> does anyone know who prove that theorem about lazy data being slower than mutable?
16:32:21 <Berengal> MissPiggy: Which theorem would that be?
16:32:38 <waterlaz> anyway it computes (i * j) then checks if it is equal to -9223372036854775808 then computes (r + (i * j) `rem` 100) and checks again and so on
16:32:47 <MissPiggy> Berengal that's what I am trying to find out :P
16:33:06 <waterlaz> to make the long story short it runs 8 times slower then C =)
16:33:20 <waterlaz> obviously becouse of all those checks
16:33:32 <Berengal> waterlaz: Is the code short? Do you want to share? Which GHC and which compile settings?
16:33:44 <waterlaz> ok
16:33:48 <waterlaz> 1sec
16:33:56 <Philippa> MissPiggy: I don't, but my 'gut feeling' is that it's about the need for an immutable spine vs having references to mutable cells
16:34:02 <Saizan> lpsmith: not as nice as you'd want from the look of the commnads above, btw if you do your own cabal configure/build, then you want to pass --only to install
16:34:14 <Philippa> the heap has an O(1) spine, sort of thing
16:34:43 <MissPiggy> hi Philippa :)
16:34:52 <dolio> There was a paper on strict, pure algorithms being slower than mutable algorithms, and one on lazy evaluation making up the difference.
16:34:57 <Philippa> you can get within log time by emulating as much of a heap as you need
16:35:03 <dolio> I've never heard of one proving that lazy was slower than mutable.
16:35:07 <waterlaz> Berengal, http://www.pastey.net/132799 this is the haskell code
16:35:07 <Berengal> MissPiggy: Also, lazy doesn't imply immutable, even though the alternative is lovecraftian
16:35:20 <Philippa> hi MissPiggy :-)
16:35:20 <MissPiggy> Philippa, yeah -- that "get within log time" is the exact result I was thinking of
16:35:22 <Gracenotes> lazy does imply mutable. under the surface.
16:35:45 <MissPiggy> dolio: do you know the author ?
16:35:50 <MissPiggy> or what paper it is or anything
16:36:18 <dolio> The title of the latter is More Haste, Less Speed.
16:36:32 <waterlaz> I thought I made it as close to this c++ as possible http://www.pastey.net/132800
16:36:35 <lpsmith> Saizan, yeah,  but that's a *lot* of work to produce that,  I don't usually manually go through each package
16:37:04 <Philippa> dolio: ah, I'd not seen a proof that laziness can make up the difference in all cases, but cheers for the reference
16:37:13 <lpsmith> i mean, I suppose I could hack up a python script to generate documentation quick
16:37:20 <dolio> I don't know if it can make up the difference in all cases.
16:37:33 <lpsmith> It'd also be nice to have a command to regenerate documentation for the packages available on the system
16:37:35 <dolio> But the original paper showing that purity was slower only gave one example, as I understand it.
16:37:37 <waterlaz> I use ghc6.12.1
16:37:56 <dankna> that WOULD be nice
16:37:57 <dolio> And the subsequent paper showed that lazy evaluation could make up the difference on that problem.
16:38:36 <Saizan> lpsmith: there's actually a patch ready to be able to specify --hyperlink-source in ~/.cabal/config , but it add even more flags to the already bloated interface for "cabal install"!
16:38:54 <Saizan> *adds
16:39:04 <doserj> waterlaz: the Integral instance for Int defines rem this way
16:39:24 <Saizan> maybe we should keep the ~/.cabal/config part and ditch the additional flags on the CLI
16:39:42 <Berengal> waterlaz: You're right. Those checks do look weird
16:39:48 <doserj> a `rem` b | a == minBound && b == (-1) = overflowError
16:40:07 <waterlaz> doserj, I also tried mod
16:40:15 <waterlaz> same thing
16:40:20 <doserj> yes
16:40:35 <waterlaz> so there should be some lowlevel mod, right?
16:40:35 <lpsmith> Saizan, what does the --only flag do?  I'm not seeing any documentation in "cabal install --help"
16:40:40 <Saizan> lpsmith: and about discovering the right haddock for the right ghc, how could you do that if haddock gets installed separately?
16:40:57 <doserj> waterlaz: yes. modInt and remInt
16:41:04 <Saizan> lpsmith: it makes it skip the configuration and build part
16:41:17 <doserj> waterlaz: probably in GHC.Num
16:41:22 <Berengal> waterlaz: Use Int64 instead of Int
16:41:24 <Saizan> lpsmith: it's intended for internal use, actually
16:41:32 <Berengal> For some reason that worked for me
16:41:33 <lpsmith> heh
16:41:35 <Saizan> lpsmith: that's why it doesn't show in the --help
16:43:44 <waterlaz> thanks guys
16:43:56 <waterlaz> I'm still looking for modInt though =)
16:44:15 <c_wraith> @hoogle Monad m => m a -> m b -> m a
16:44:15 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
16:44:15 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
16:44:15 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
16:44:44 <c_wraith> Bah.  I want something like that, except it returns the first...
16:44:52 <c_wraith> um.  I guess <* would do
16:45:14 <c_wraith> is there a monadic equivalent, or do I just live applicatively?
16:45:31 <doserj> waterlaz: quotRemInt and divModInt are in GHC.Num, here
16:45:53 <waterlaz> found modInt in GHC.Base
16:46:48 <waterlaz> it performs badly anyway
16:47:06 <waterlaz> idk where could the C++ version benefit
16:47:30 * hackagebot upload: cubicspline 0.1 - Natural cubic spline interpolation. (GershomBazerman)
16:48:02 <doserj> waterlaz: if you really want to go that way, you can try remInt# and modInt# from GHC.Prim
16:52:33 <doserj> waterlaz: remInt should nevertheless be a bit better than modInt
16:52:48 <waterlaz> there is no such thing as modInt in GHC.Prim
16:52:56 <waterlaz> it is in GHC.Base
16:53:28 <doserj> yes. GHC.Base.modInt uses GHC.Prim.remInt#
16:53:35 <waterlaz> it is 7,5s vs 1,5s
16:53:44 <Berengal> waterlaz: you forgot -fvia-c
16:53:56 <doserj> GHC.Base.remInt uses GHC.Prim.remInt#, too, but more directly
16:55:18 <waterlaz> damn
16:55:29 <waterlaz> Berengal, thanks, that did it
16:55:51 <waterlaz> almost identical
16:56:07 <waterlaz> cool =)
16:56:16 <Dark_Shikari> http://pastebin.com/m22b80591 why the heck is haskell inferring my types like this?
16:57:23 <doserj> Dark_Shikari: wrong syntax. you want (Push r:...), not [Push r:...]
16:57:37 <Dark_Shikari> but it's a list, don't I use [] for lists?
16:57:59 <c_wraith> :t 1:[]
16:58:00 <lambdabot> forall t. (Num t) => [t]
16:58:05 <c_wraith> :t [1:[]]
16:58:06 <lambdabot> forall t. (Num t) => [[t]]
16:58:24 <Dark_Shikari> doing that gives
16:58:25 <Dark_Shikari>     Couldn't match expected type `StackInstr'
16:58:25 <Dark_Shikari>            against inferred type `[StackInstr]'
16:58:35 <doserj> (Push r:...) is a list with at least one element. [Push r:...] is a list containing exactly one element (which is a list)
16:58:37 <theorbtwo> : and [] both are about lists.  [] takes a bunch of comma-seperated items on the inside.  : takes an item on the left, and an existing list on the right.
16:59:19 <doserj> Dark_Shikari: same error on the right hand side, of course
16:59:21 <Dark_Shikari> ah yes
17:00:00 <Dark_Shikari> works.  now to do the other ops...
17:06:50 <glguy> Saizan, http://hackage.haskell.org/trac/ghc/ticket/2222 (my bug is apparently a consequence of this design bug)
17:07:35 * hackagebot upload: GtkTV 0.1.0 - Gtk-based GUIs for Tangible Values (ConalElliott)
17:08:08 <glguy> I was able to work-around it by moving the template haskell code to its own module and avoiding any of those nasty "type classes" in top-level values
17:08:58 <sm> wow.. C-c C-l . Must start using that
17:10:48 <tumult> ghc/packages question: i ended up with monads-fd installed by cabal when i was installing something else that depended on it, now i get an error about matching various mtl modules when invoking ghc or ghci without cabal (since i guess they aren't being hidden)
17:11:09 <tumult> is there a quick way to fix that?
17:11:16 <c_wraith> tumult: when it matters, use ghc(i) -hide-package monads-fd
17:11:34 <tumult> oh ok, thanks
17:12:02 <c_wraith> You could also tell ghc-pkg to hide it by default, I think, but I haven't experimented with that
17:13:17 <tumult> i'm trying to figure out how to add a flag to haskellmode.vim's ghci invocation
17:13:35 <c_wraith> yikes.  That I have no clue on.
17:13:52 <c_wraith> maybe look at ghc-pkg, and see if hiding it by default works
17:14:35 <tumult> it looks like that's the preferred way since haskellmode seems to have something for explicitly un-hiding packages
17:15:28 <Dark_Shikari> http://pastebin.com/m57614c5 hmm, why can't I pattern-match this way?
17:15:44 <kmc_> you need parens
17:15:46 <kmc_> (Num v)
17:15:46 <tumult> looks like it's just ghc-pkg hide monads-fd :)
17:16:21 <c_wraith> tumult: did that fix it for you?
17:16:28 <tumult> c_wraith: yup thanks
17:16:31 <Dark_Shikari> yup, parens did it
17:16:39 <Dark_Shikari> makes sense
17:16:56 <c_wraith> tumult: cool.  I wasn't sure if it would.  thanks for the info
17:17:22 <tumult> Dark_Shikari: hah are you the x264 dev? i love x264
17:17:31 <Dark_Shikari> yes, and now I'm a newbie learning haskell ;)
17:17:37 <tumult> awesome
17:17:46 <Dark_Shikari> it's for class, but it's a good excuse to learn a non-crappy language
17:18:04 <tumult> don't worry, you can learn to be frustrated by anything
17:18:14 <Dark_Shikari> I already had that experience with scheme
17:18:24 <Dark_Shikari> the whole "functions take 5 minutes to write, and 25 minutes for anyone to understand what you're doing"
17:18:47 <tumult> if you write in like raw R5RS scheme that's what tends to happen in my experience
17:19:04 <tumult> actually the way i prefer to write scheme ends up looking a lot like haskell or ML, with pattern matching and folds
17:19:31 <tumult> so i might as well just use haskell i guess, which is what i do now :)
17:19:35 <MissPiggy> how do you do pattern matching in scheme?
17:19:48 <MissPiggy> I know it's "with a macro" but like.. which one
17:20:00 <tumult> http://docs.plt-scheme.org/reference/match.html
17:20:37 <Saizan> glguy: ah. thanks
17:21:17 <Dark_Shikari> http://pastebin.com/m1dee1ed9
17:21:18 <Dark_Shikari> No instance for (Show StackInstr) arising from a use of `print' at <interactive>:1:0-53
17:21:29 <Dark_Shikari> what's the best way to debug my output by, er, allowing it to be printed?
17:21:40 * hackagebot upload: GtkTV 0.1.1 - Gtk-based GUIs for Tangible Values (ConalElliott)
17:21:43 <moshisushi> hello anyone here using parsec?
17:21:43 <c_wraith> add deriving Show at the end of your data declaration
17:21:54 <Dark_Shikari> ah, Exp has it, but not StackInstr
17:21:59 <tumult> yup, derive show for the whole thing
17:22:09 <Dark_Shikari> woot
17:22:13 <temoto> moshisushi, almost everyone here used parsec.
17:23:29 <moshisushi> temoto: ok so i have a problem.. i'm trying to parse a simple form of regular expressions
17:24:04 <watermind> is there a nice name for composition with return?
17:24:12 <watermind> return . f
17:24:21 <Dark_Shikari> I'm already liking haskell quite a lot.  an infix -> RPN converter in 2 short lines
17:24:23 <watermind> it's not lifting...
17:24:32 <MissPiggy> Dark_Shikari wow cool
17:24:32 <watermind> but not sure if there's a name for it
17:24:35 <moshisushi> but i need to act on concatenation of expressions, and i dunno how to express taht
17:24:36 <MissPiggy> Dark_Shikari can I see?
17:24:45 <Dark_Shikari> it generates instructions for a stack RPN machine
17:24:51 <Dark_Shikari> toRPN :: Exp -> [StackInstr]
17:24:51 <Dark_Shikari> toRPN (Num v) = [Push v]
17:24:51 <Dark_Shikari> toRPN (BinOp a b c) = toRPN a ++ toRPN c ++ [DoOp b]
17:25:06 <Dark_Shikari> based on a simple crappy language from this homework assignment
17:25:10 <MissPiggy> oh right clever
17:25:17 <Dark_Shikari> all you do is a postfix tree traversal
17:25:28 <temoto> moshisushi, i didn't understand what you need.
17:25:32 <Dark_Shikari> But it's pretty cool.
17:25:35 <MissPiggy> hey wanna see a silly trick?
17:25:37 <Dark_Shikari> sure
17:25:38 <MissPiggy> Dark_Shikari
17:25:47 <MissPiggy> toRPN (Num v) more = Push v : more
17:25:48 <moshisushi> temoto: ok so of i have the string "ab"
17:25:53 <temoto> moshisushi, /ab/ is a concatenation of regexps /a/ and /b/.
17:26:02 <moshisushi> temoto: its a concatenation of the atomic expressions 'a' and 'b'
17:26:04 <MissPiggy> toRPN (BinOp a b c) more = toRPN a (toRPN c (DoOp b : more))
17:26:15 <Dark_Shikari> what's "more" do?
17:26:26 <MissPiggy> Dark_Shikari: well, let's pretend I called that toRPN'
17:26:31 <moshisushi> temoto: exactly.. how do add an operator for that?
17:26:40 <MissPiggy> Dark_Shikari: so your toRPN exp = toRPN' exp []
17:26:44 <Dark_Shikari> ah
17:26:49 <Dark_Shikari> so you can do it on a list of expressions etc
17:26:52 <MissPiggy> but ++ is O(1)
17:26:58 <MissPiggy> oops
17:27:02 <MissPiggy> but ++ is O(n)*
17:27:05 <Dark_Shikari> yeah yeah I know
17:27:07 <MissPiggy> where as my one doesn't use it, and that is more efficientt
17:27:27 <Dark_Shikari> good thing this assignment doesn't require linear runtime ;)
17:27:49 <watermind> Dark_Shikari: check the Show class for another example of that
17:28:15 <moshisushi> temoto: actually i need some basic advice on how to express that grammar in parsec
17:28:18 <MissPiggy> Dark_Shikari, of course your version is much nicer to read
17:28:28 <moshisushi> because i think what i have here is pretty wrong way to go
17:28:48 <MissPiggy> Dark_Shikari, I just like that trick with 'more' because it's fun to transform programs into other programs
17:29:13 <temoto> moshisushi, you want to parse regular expressions?
17:29:26 * Dark_Shikari goes to grab food
17:29:28 <temoto> moshisushi, or which grammar?
17:30:12 <moshisushi> temoto: exactly
17:30:27 <MissPiggy> moshisushi you will implemetn regex using parsec?
17:30:28 <moshisushi> so i need to support + * ? | operators
17:30:47 <moshisushi> MissPiggy: yeah well just a toy thing of course
17:30:55 <moshisushi> MissPiggy: parsec is bad idea for that?
17:30:56 <Sgeo_> @src forM_
17:30:57 <lambdabot> forM_ = flip mapM_
17:31:03 <Sgeo_> @src mapM_
17:31:03 <MissPiggy> moshisushi, no not at all
17:31:04 <lambdabot> mapM_ f as = sequence_ (map f as)
17:31:18 <Sgeo_> @pf sequence_ (map f as)
17:31:18 <lambdabot> Maybe you meant: bf pl
17:31:21 <MissPiggy> moshisushi, step 1 is make a data type which you can translate these operators into
17:31:30 <moshisushi> MissPiggy: so basically i have a working eNFA -> optimized DFA thing, but no working parser
17:31:34 <temoto> moshisushi, so, to make it clear, you want to parse regular expressions, which means in the output of parsing you will get a parser for some string.
17:31:45 <moshisushi> yeah
17:31:48 <c_wraith> moshisushi: include ().  grammars are no fun without them. :)
17:31:52 <MissPiggy> moshisushi, oh that's even better, you just need to turn Regex into NFA
17:31:54 <Hunner> Does haskell memoize?
17:31:59 <temoto> Hunner, no
17:32:02 <moshisushi> MissPiggy: i have that.. the CharAutomaton
17:32:03 <Hunner> Ever?
17:32:08 <MissPiggy> cool
17:32:17 <Zao> Hunner: There's common subexpression elimination.
17:32:21 <moshisushi> so that is an eNFA structure
17:32:25 <lispy> Hunner: it does sharing when possible, but memoization is done manually by programmers
17:32:34 <MissPiggy> moshisushi can you parse your regex syntax using your regex implementation? :)
17:32:35 <temoto> Hunner, not ever. But no "free" memoization in general sense.
17:32:39 <Hunner> lispy: uh, never seen that
17:32:43 * hackagebot upload: mbox 0.1 - Read and write standard mailbox files. (GershomBazerman)
17:32:49 <temoto> moshisushi, okay, do you have data type declarations?
17:33:00 <moshisushi> i also have helper functions to build the various building blocks
17:33:06 <lispy> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- Hunner, this is memorized
17:33:08 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- Hunn...
17:33:12 <moshisushi> an or-automaton, concat automaton etc...
17:33:26 <lispy> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:33:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:33:33 <moshisushi> MissPiggy: haha yeah that would kill!
17:33:47 <lispy> Hunner: each successive fib is computed in linear time from the previous list elements
17:33:55 <lispy> Hunner: but, I specified that manually
17:34:04 <Hunner> Hmm...
17:34:28 <lispy> Hunner: the other thing is that, once a thunk has been evaluated to a value it can be referenced again and the value is returned instead of the thunk being re-evaluated
17:34:55 <lispy> Hunner: but, that's not memoization either :)
17:34:58 <temoto> Hunner, open up ghci
17:35:10 * Hunner always imagined his functions being "faster" on their own (if it would in fact help)
17:35:16 <Hunner> open
17:35:26 <temoto> Hunner, type   import Debug.Trace
17:35:35 <lispy> Hunner: and we can use laziness to do tricks that are referred to as "tying the knot" which is essentially dynamic programming (which memoization is an example of)
17:35:36 <Hunner> trace is awesome :)
17:35:52 <temoto> Hunner, type    let a = trace "only once" 5 in a + a
17:36:06 * lispy leaves
17:36:25 <Hunner> temoto: but... so those are thunks?
17:36:33 <Hunner> lispy: thanks
17:37:03 <temoto> Hunner, yes. This is the 'expression memoization' haskell really does. 'function memoization' is up to you as lispy shown with fib.
17:37:55 <Hunner> (trace "only once" 5) + (trace "only once" 5) -- is not the same though
17:38:01 <watermind> so does anybody know a name for   return . f ?
17:38:04 <moshisushi> MissPiggy: would you mind to look at some horribly (i think) incorrect parsec code if i put it on a pastebin?
17:38:09 <MissPiggy> I would not mind
17:38:14 <temoto> Hunner, because here you have 2 expressions.
17:38:26 <aavogt> that's only observable because trace is illegal
17:38:37 <watermind> fmap f <-- lifting
17:38:44 <watermind> return . f <--- ?
17:38:54 <aavogt> throwing?
17:39:04 <Hunner> temoto: so function memoization would just suck ram?
17:39:07 <doserj> 'injecting' is sometimes heard
17:39:10 <Hunner> or what?
17:39:28 <watermind> doserj: I use that for coproducts already :S
17:40:43 <moshisushi> MissPiggy: http://paste.lisp.org/display/94756
17:40:53 <temoto> Hunner, function memoization is up to the coder. Haskell provides no magic for that. If you build *and evaluate* a list that is large enough, it will consume memory, yes. it's no different from writing a several gigabyte print "aaaaaaaaaa...."
17:41:05 <Sgeo_> Is it just me, or does WinGHCi suck?
17:41:38 <temoto> Sgeo_, only in first 3 letters.
17:41:44 <Sgeo_> lol
17:42:04 <Sgeo_> Once, it started acting like whever I entered something, I really entered the previous thing
17:42:50 <temoto> Sgeo_, for serious, i believe that's about differences between readline and windows console input library.
17:42:51 <MissPiggy> moshisushi: I have some code that you could probably /use/ but that might not be really what you are after
17:43:16 <Sgeo_> By WinGHCi, I meant the graphical interface for GHCi
17:43:22 <Sgeo_> Not GHCi on Windows
17:43:25 <moshisushi> MissPiggy: it's a start...
17:43:40 <temoto> Sgeo_, never saw that then, sorry.
17:44:13 <MissPiggy> moshisushi: what I wrote the other day is a parser for a language with haskell like function application and infix ops (using buildExpressionParser, like you do)
17:44:26 <MissPiggy> moshisushi: so it reads things like  1 + f x * 3,  and so on
17:44:55 <MissPiggy> moshisushi: if one changed the function application to bind weakest (instead of what it's currently at, tightest) you could probably parse regex with it?
17:45:25 <moshisushi> MissPiggy yes indeed
17:45:40 <moshisushi> does it handle parentheses?
17:45:46 <MissPiggy> yes
17:45:59 <MissPiggy> I'l paste it
17:46:05 <moshisushi> MissPiggy: great1
17:46:25 <MissPiggy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19303#a19303
17:46:34 <MissPiggy> you can ignore everything up to term, mostuyl
17:46:55 <temoto> Hunner, did i answer your question?
17:47:03 <Hunner> temoto: still thinking about it...
17:47:04 <MissPiggy> so functionApplication : table has to be changed to  table ++ [functionApplication]
17:47:16 <moshisushi> i see
17:47:19 <MissPiggy> moshisushi -- but what is the problem with what you pasted anyway?
17:47:36 <Hunner> temoto: let b = let a = trace "only once" 5 in a + a in b + b -- this also does it once, though it seems like it would have made two thunks that need evaluating
17:48:22 <temoto> Hunner, see, print $ take 10 $ fib    will consume enough memory to build only first 10 items in fib list. After printing the list, memory will be freed. There's not global variable sitting around forever or something like that.
17:48:59 <moshisushi> MissPiggy: well the priorities of operators, mostly
17:49:09 <Hunner> temoto: I read once about people running haskell web frameworks talking about memory never being deallocated. Is that related? (total side-note)
17:49:50 <moshisushi> MissPiggy: but what i pasted to you probably contains even more bugs because i was kinda in the middle of changing things
17:50:23 <arw> Hunner: not sure. but at least the operating system won't get any of your memory back, regardless of what the gc does.
17:50:28 <MissPiggy> moshisushi, well if edit table to put each opertor in it's own [] then it will distinguish the precidence
17:50:55 <arw> Hunner: once a program allocated memory from the OS it will never give it back, only recycle some of it itself.
17:52:11 <moshisushi> MissPiggy: i have problems defining the concatenation too
17:53:11 <temoto> Hunner, no. Web framework is supposed to provide some kind of session support so you can treat several requests from same user in a nice way (e.g. provide him a multipage form or tell his name on each page after he authenticated). This implies using global state in some way. Conventional way is to hold session data in memcache or database. Maybe those haskell frameworks do it inside single haskell process.
17:53:41 <moshisushi> MissPiggy: because i want this: * ? + have the highest priority
17:53:44 <Hunner> temoto: what do you mean by "after printing the list"? How does it know that it won't need the list again?
17:53:47 <temoto> arw, AFAIK only JVM is guilty of that.
17:53:58 <moshisushi> or well, parentheses maybe
17:54:09 <MissPiggy> moshisushi, and concatenation lowest? ewell you can maybe do like I did -- and make space an operator  (just with the lowest priority)
17:54:18 <moshisushi> actually, | lowest
17:54:24 <moshisushi> alternation (or)
17:54:25 <temoto> Hunner, because it can't access the list then.
17:54:52 <moshisushi> MissPiggy: but concatenation has an "empty" character as symbol
17:54:55 <moshisushi> that's the weird part
17:56:03 <temoto> Hunner, no reference.
17:56:03 <Zao> Does anyone know where the "sp" tool mentioned in this cafe post comes from? http://www.haskell.org/pipermail/haskell-cafe/2010-February/073105.html
17:56:29 <Hunner> temoto: but if I assigned it with `let` or something... it would keep the list of 10 around (assuming it was called later)?
17:56:42 <Hunner> it being ghc
17:56:54 <temoto> Hunner, yup. But your let will end somewhere soon too.
17:57:27 <Hunner> temoto: what if the let is tail recursive? :>
17:57:58 <doserj> Zao: http://joyful.com/repos/searchpath/
17:58:11 <temoto> Hunner, and still, compiler can do a trivial optimization and infer that you don't use that reference after some position and free the list.
17:59:22 <temoto> Hunner, if let is recursive, you get a recursive dependancy. And that's lispy done memoizing fib.
17:59:29 <temoto> that's how*
17:59:30 <Hunner> temoto: okay, I think we've strayed away from memoizing. Thanks
17:59:43 <Zao> doserj: Ah.
18:01:23 <MissPiggy> moshisushi, oh yeah just "0 or more spaces" for the operator instead of "+" or whatever
18:01:44 <moshisushi> 0 spaces actually :)
18:02:14 <temoto> moshisushi, sepBy empty   is actually a valid parser :)
18:02:44 <MissPiggy> moshisushi, I use an idiom in parsec where every time I read some symbol[s] -- then I skip whitespace
18:02:48 <moshisushi> temoto ok :)
18:03:18 <MissPiggy> moshisushi, that's why my code is starting with "term = do spaces ; term'" -- that's the only place where I read spaces /before/ something else
18:03:59 <moshisushi> MissPiggy: yeah
18:05:37 <lpsmith> Ok,  if I project a circle in 3d space to a 2d plane,  using perspective,   do I get an ellipse?   I worked out the projection and used mathematica,  and it sure does look like an ellipse.
18:05:55 <lpsmith> Err, plotted what I worked out using mathematica, that is
18:06:25 <lpsmith> err,  worked out by hand, plotted using mathematica.  Whatever
18:07:03 <kmc_> yes seems likely
18:07:12 <kmc_> now prove it in coq ;)
18:07:18 <lpsmith> hahaha
18:08:02 <idnar> haha
18:08:32 <lpsmith> well,  it's just a graphical doodad I'm playing with,  so if it looks like an ellipse to me,  I can approximate it with an actual ellipse and not feel bad
18:08:59 <lpsmith> or rather,  approximate the projection using a bezier approximation of an actual ellipse  :-P
18:09:09 <kmc_> approximate your approximation
18:09:43 <arw> the easy, geometric explanation is, circle and ellipsis are both cross-sections of a cylinder. so yes, an ellipsis is a projection of a circle.
18:11:24 <kfish> Prelude System.FilePath> normalise "../."
18:11:24 <kfish> "../."
18:11:24 <kfish> Prelude System.FilePath> normalise ".././"
18:11:24 <kfish> ".././"
18:11:24 <kfish> Prelude System.FilePath> normalise ".././.."
18:11:25 <kfish> "../.."
18:13:54 <lpsmith> arw, I'm using a perspective projection,  not an orthogonal projection
18:14:28 <lpsmith> not that I think it matters
18:15:05 <lpsmith> you can probably make a similar argument using conic sections
18:27:22 <heatsink> If you're using a bezier approximation, why not just apply the perspective projection to the bezier approximation, and not worry about whether it's exactly an ellipse?
18:28:07 <heatsink> Apply it to a bezier approximation of a circle in 3d, to be more precise
18:28:14 <moshisushi> temoto: my parser seems to work :)
18:28:44 <moshisushi> i did a binary "" parser, with priority between * ? + and |
18:30:14 <lpsmith> heatsink, can you project the control points of a planar bezier curve in 3-d space to get a projection of the entire curve in 2-d space?  (or at least a good approximation thereof?)
18:31:02 <lpsmith> (also,  I don't care too much about "what" it is;  I'm trying to build a simple-ish canvas animation,  not create a general purpose 3d engine
18:31:40 <heatsink> I don't think the transformation is exact, but you can subdivide the curve enough so that the error is negligible.
18:33:07 <lpsmith> So apparently Jon Harrop thinks he can charge  1,000 per copy of a new book he's writing.
18:33:24 <Zao> lpsmith: Aimed at what, corporate customers?
18:33:26 <lpsmith> http://www.reddit.com/r/programming/comments/az6td/how_to_become_rich_as_a_programmer_even_if_nobody/c0k69ak
18:33:33 <lpsmith> I have no idea
18:33:46 <lpsmith> He's a rather eccentric guy.
18:34:14 <lpsmith> and intellectually dishonest from time to time
18:34:40 <lpsmith> By his logic,  if the more you charge,  the more you make,  why not put the price of your book at say,  a trillion dollars?
18:37:11 <dolio> I don't think any book that isn't some sort of antique would sell for 1,000.
18:37:27 <dolio> At least, not one by him.
18:37:30 <Zao> Most of those $1000 per book must go to medical bills for being punched in the face by people he has annoyed.
18:37:30 <heatsink> Because then you sell (on average) between zero and one books.  Your expected income is around 50 billion dollars, but there's a high probability of selling zero copies and not making a profit.  So, you have to make and sell lots of different books to get a reasonable probability of making money, which is too much work.
18:38:26 <dolio> Your expected income isn't 50 billion, it's probably 0.
18:38:41 <heatsink> Well, by his logic.
18:38:49 <dolio> Because the only people who have 1 trillion dollars are governments, and they won't pay that for a book.
18:40:24 <kfish> what if it was a book that showed you how to make 2 trilion dollars? in the type system!
18:40:37 <pikhq> kfish: Oleg would have written it.
18:40:41 <kmc> sigh
18:41:00 <kmc> oleg jokes are getting old
18:41:04 <kmc> that's just me though
18:41:07 <kmc> i spend far too much time here
18:41:50 <dolio> Anyhow, you have to charge a lot for books that sell as few copies as jhd's likely do.
18:42:04 <dolio> Just like obscure text books.
18:42:20 <dolio> $2,000 is ridiculous, though.
18:43:11 <lpsmith> what's the pound trading at these days?
18:43:18 <kmc> @google 1 GBP to USD
18:43:19 <lambdabot> http://www.xe.com/
18:43:20 <lambdabot> Title: XE - The World's Favorite Currency and Foreign Exchange Site
18:43:48 <dolio> Oh, only $1,500, apparently.
18:43:51 <dolio> Still.
18:44:23 <lpsmith> It was up around 2:1,  but it's gone back to it's more historical value.
18:44:38 <lpsmith> yeah, it's nuts
18:45:16 <dolio> You could buy a pretty fancy computer for that much.
18:46:56 <dolio> Or, 20 - 30 books on computer science that aren't outrageously expensive.
18:54:15 <pikhq> dolio: Or a vacation.
19:06:51 <m3ga> there was a cartoon posted either here or on reddit that i'm trying to find. it was a farside cartoon with everything in it labelled 'object' (a poke at dynamically typed languages). google can't help me. can #haskell?
19:26:32 <sshc> since hoogle is down, I'll ask here:
19:26:36 <sshc> How do I get a list of every possible three unordered combinations of one list?
19:29:02 <twanvl> > replicateM 3 "abcd" -- is this what you are looking for?
19:29:03 <lambdabot>   ["aaa","aab","aac","aad","aba","abb","abc","abd","aca","acb","acc","acd","a...
19:29:07 <Zao> > nub . permutations $ [1,2,3]
19:29:08 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
19:29:22 <Zao> Depends on what you mean.
19:29:42 <sshc> A list of every possible combinations of three things
19:29:45 <sshc> the combinations are not ordered
19:30:09 <sshc> there can't be repetition
19:30:11 <copumpkin> can you give sample input and output?
19:30:26 <twanvl> does "are not ordered" mean that you want all permutations, or that you don't?
19:30:54 <Zao> > permutations [1,2,3]
19:30:55 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
19:31:07 <Zao> I can't say I understand what you want yet.
19:31:23 <monochrom> sample input: [1,1,1,1]. sample output: ?
19:31:37 <twanvl> > filter ((==3).length) . subsequences $ [1..4] -- this is not very efficient
19:31:38 <lambdabot>   [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
19:31:38 <sshc> twanvl: that meanthat if every element in the list is unique, you won't end up with both [a, b, c] and [a, c, b]
19:32:15 <pikhq> sshc: So, you don't want lists at all. You want sets.
19:32:32 <applicative> right
19:32:45 <twanvl> > let f list = [ (x,y,z) | (x:xxs) <- tails list, (y:xs) <- tails xxs, z <- xs ] in f [1..4]
19:32:46 <lambdabot>   [(1,2,3),(1,2,4),(1,3,4),(2,3,4)]
19:32:50 <sshc> > [1, 2, 3, 4] -> [[1, 2, 3], [1, 2, 4]]
19:32:51 <lambdabot>   <no location info>: parse error on input `->'
19:32:59 <pikhq> sshc: The answer, BTW, is [a, b, c] for any a, b, or c.
19:33:03 <pikhq> :P
19:33:03 <copumpkin> sshc: no 2,3,4 ?
19:33:11 <sshc> oh
19:33:12 <sshc> that too
19:33:14 <copumpkin> 1 3 4?
19:33:20 <sshc> yeah, I missed a bunch
19:33:23 <copumpkin> ok :)
19:33:37 <copumpkin> > nubBy ((==) `on` sort) . permutations $ [1..4]
19:33:38 <lambdabot>   [[1,2,3,4]]
19:33:39 <sshc> [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]
19:33:53 <copumpkin> that's dumb :P
19:34:01 <copumpkin> (of me)
19:34:08 <Zao> > nubBy (\x y -> sort x == y) $ replicateM 3 "abc"
19:34:08 <lambdabot>   ["aaa","aab","aac","abb","abc","acc","bbb","bbc","bcc","ccc"]
19:34:28 <copumpkin> > nubBy ((==) <*> sort) . permutations $ [1..4]
19:34:29 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:34:29 <lambdabot>         against inferred ...
19:34:31 <copumpkin> boo :P
19:34:49 <copumpkin> silly me
19:34:58 <copumpkin> tonight is a bad copumpkin haskell night
19:35:18 <scutigera> still better than a good scutigera haskell night :-)
19:36:09 <Zao> At least you didn't write an abomination like   B.concat . map mergeSpaces . B.groupBy (\x y -> isSpace x && isSpace y) $ bs
19:36:20 <copumpkin> :O
19:36:24 <Zao> I have a feeling that that has awesome perf characteristics.
19:36:50 <Zao> A solution to "I want to fold all adjacent spacelikes".
19:37:10 <copumpkin> oh, so you want no multispaces?
19:37:40 <Zao> A sane solution would be "s/\s+/ /m", but as Regex doesn't do substitutions... :(
19:37:55 <Zao> (mg, that is)
19:38:19 <sshc> [1, 2, 3] -> [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]
19:40:05 <applicative> copumpkin: it can't be such a bad Haskell day; your victory in the Tron contest with jaspervj's "always North" template was very amusing.   I followed your example and submitted aslight variant
19:40:36 <copumpkin> applicative: hah :P one of these days I'll soup it up and instantly become #!
19:40:38 <copumpkin> #1, even
19:40:41 <Dmwit> uh
19:40:46 <applicative> i don't doubt it
19:40:48 <Dmwit> I don't actually know how to op myself, one sec. =P
19:40:56 <copumpkin> omg Dmwit is capital
19:41:03 <shepheb> Dmwit: way to mischan
19:41:11 <Dmwit> arg
19:41:25 <dankna>  /msg chanserv op #haskell Dmwit somepassword
19:41:27 <copumpkin>  /msg chanserv op #chan
19:41:27 <dankna> I think
19:41:34 <copumpkin> no, you just need to be registered
19:41:36 <dankna> oh, okay
19:41:40 <applicative> i souped it up to turn before the wall to avoid crashing if possible, and instantly went to the top 50%
19:41:40 <dankna> nicer services than I'm used to then
19:41:52 <copumpkin> applicative: lol, nice
19:42:30 <applicative> a few further attempts to introducte more 'intelligence' just ended up trying their machine...
19:43:01 <applicative> at least I wasn't 'garbage collected', what an indignity.
19:43:26 <copumpkin> not bad for a lax monoidal functor
19:43:38 <applicative> lax indeed
19:44:21 <applicative> i'm a bit out of my depth with uarrays
19:49:25 <loopy577> anyone core impact users out there?
19:52:49 <scutigera> copumpkin: quick, your favorite category theory book:
19:53:28 <cjs> When I try to compile with -debug on my Ubuntu x86_64 system using GHC 6.12.1, I get "/usr/bin/ld: cannot find -lbfd". Thoughts?
19:53:49 <loopy577> hellow world
19:54:03 <scutigera> cjs: you've looked for a bfd-dev package ?
19:54:31 <cjs> Ah! Doh!
19:55:23 <scutigera> what is bfd ?
19:55:41 <scutigera> other than big f*cking deal
19:56:38 <cjs> Gnu binary utilities
19:56:46 <tomoj> what's the name of that haskell lib for generating C?
19:57:09 <scutigera> tomoj: generating C for....
19:57:36 <tomoj> well, I want to put it on an arduino, but that's not what the lib's for
19:57:51 <tomoj> it had some cute name, dunno why I can't find it in the google results :(
19:58:18 <scutigera> if you are talking about compiling a program to C, I thought ghc had magic flags for that (although  I haven't used them).
19:58:41 <tomoj> no, I don't want to compile a haskell program to C, I want to write haskell programs which generate C source
19:58:51 <tomoj> the arduino can't handle real haskell :(
19:59:17 <notallama> i just named my tron bot metatron :). unfortunately, i won't have time to actually write a bot for at least a few days.
20:00:19 <scutigera> tomoj: I can barely handle it myself ;-)
20:00:48 <Zao> tomoj: Language.C?
20:01:16 <tomoj> :( that's not a very cute name
20:01:24 <tomoj> maybe I'm just hallucinating hearing about this lib
20:01:30 <Zao> http://hackage.haskell.org/package/language-c
20:01:36 <tomoj> Zao: thanks
20:01:55 <monochrom> afv? feldspar?
20:02:28 <scutigera> feldspar: dsp is good.
20:03:17 <monochrom> hcc? ForDyDe? piet? cmonad?
20:03:48 <cjs> Wow, this one's kinda mysterious: http://hackage.haskell.org/trac/ghc/ticket/3874
20:05:03 <monochrom> Here is a fun one. "pesca: Proof Editor for Sequent Calculus". The category it's under is: <drumroll> compiler/interpreter
20:05:08 <scutigera> that's what you get for being on the bleeding edge
20:06:39 <watermind> monochrom: is the author portuguese or brazilian by any chance?
20:07:03 <scutigera> cjs: are you using threading when that happens ?
20:07:11 <monochrom> I do not know.
20:07:19 <cjs> I'm using the non-threaded runtime.
20:08:12 <scutigera> the printf's in the traceback are a clue. bet ghc is calling them with mismatch between args and formatting.
20:08:14 <cjs> But I just checked, same thing with the threaded runtime, both debug and non-debug versions, with -N, -N7 and -N1.
20:08:56 <cjs> scutigera: That's what I thought. But then I looked at the code.
20:09:00 <FCo> Hi everybody, I have a question regarding the meaning of this declaration newtype ParserM a = ParserM (AlexInput -> StateT St (Either String) (AlexInput, a))
20:09:34 <FCo> Either shouldn't take two parameters?
20:09:34 <scutigera> cjs: you actually looked at the compiler code ?!
20:09:38 <applicative> FCo: pretty hideous declaration
20:09:46 <aavogt> @unmtl AlexInput -> StateT St (Either String) (AlexInput, a)
20:09:46 <lambdabot> AlexInput -> StateT St (Either String) (AlexInput, a)
20:10:12 <copumpkin> scutigera: I haven't read that many, and none cover to cover :P
20:10:22 <FCo> thx, applicative, it is in a sample of the happy parser generator
20:10:26 <dolio> I wonder why they expanded the StateT AlexInput.
20:10:26 <cjs> Well, technically it's the RTS, not the compiler, but yes, I traced it through from Haskell through the primops and C. The vsnprintf that appears to be blowing up is in here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19309#a19309
20:10:35 <kmc> FCo, StateT is a monad transformer.  the second-to-last type argument should be a monad
20:10:39 <kmc> and a monad has kind * -> *
20:10:54 <cjs> I can't find any other reference to vsnprintf in the file, though I suppose another one could be sneaking in through a header somewhere.....
20:10:56 <applicative> Either String...  has kind * -> *
20:11:05 <kmc> i.e., it is a type with one remaining parameter to apply
20:11:20 <cjs> Oh, wait, no, my debug backtrace gave me a line number: 403. It's definitely line 6 in that paste.
20:11:33 <FCo> yes, in St they store the status,  but I don't understand the Either part
20:11:55 <FCo> monads and continuations are driving me crazy!!
20:11:58 <scutigera> cjs: so if BUF is smaller than len(msg)...
20:12:08 <tomoj> ah, I think I was looking for Atom
20:12:32 <tomoj> I don't need any of the fancy features for hard realtime systems, but apparently someone's gotten the results to run on the arduino
20:12:33 <cjs> scutigera: Which it's not. BUF is 500, locally alloc'd on the stack. The message is 5 chars. and it's a vsNprintf, anyway.
20:13:10 <cjs> scutigera: Perhaps we should move this to #ghc....
20:13:32 <scutigera> cjs: see ya there
20:14:18 <FCo> I wish haskell were C :-(
20:14:50 <Dark_Shikari> how do I address the third value in a tuple?
20:14:53 <Dark_Shikari> e.g. like fst, snd
20:15:08 <kmc> Dark_Shikari, pattern matching
20:15:14 <kmc> fst and snd won't work on a 3-tuple either
20:15:16 <FCo> third (_, _, value) = value
20:15:21 <Dark_Shikari> meh
20:15:26 <kmc> :t \(_, _ v) -> v
20:15:27 <lambdabot> Parse error in pattern
20:15:30 <kmc> :t \(_, _, v) -> v
20:15:31 <applicative> FCo: StateT is very difficult
20:15:31 <lambdabot> forall t t1 t2. (t, t1, t2) -> t2
20:16:09 <aavogt> @unmtl ErrorT t (State s) a
20:16:09 <lambdabot> s -> (Either t a, s)
20:16:28 <aavogt> @unmtl StateT s (Either t) a
20:16:28 <lambdabot> s -> Either t (a, s)
20:17:17 <applicative> @unmtl StateT s (Either t) (b,a)
20:17:17 <lambdabot> s -> Either t (b, a, s)
20:17:40 <sshc> how do I set a cabal package to link with RTS.c, which contains a single line that specifies the options of RTS?
20:17:52 <aavogt> @unmtl StateT (s,b) (Either t) a
20:17:52 <lambdabot> s -> b -> Either t (a, s, b)
20:18:13 <sshc> what does @unmtl do?
20:18:25 <kmc> unwraps the newtypes that mtl uses to represent monads
20:18:27 <aavogt> unwraps mtl newtypes
20:18:28 <kmc> @unmtl State s a
20:18:28 <lambdabot> s -> (a, s)
20:18:32 <kmc> @unmtl Reader r a
20:18:32 <lambdabot> r -> a
20:18:36 <kmc> @unmtl Cont r a
20:18:36 <lambdabot> (a -> r) -> r
20:18:41 <applicative> well that's interesting.  So it's St -> Either String (AlexInput, a, St)
20:19:32 <FCo> oh!, si is Either a String or a triplet that is returned?
20:20:01 <applicative> Yes, if not a String, Left, then more state, alex input and 'a'
20:20:35 <aavogt> why isn't it   StateT (AlexInput, St) ?
20:21:08 <FCo> ok, that's good! I find the parenthesis complicated I mean why not Either String (AlexInput, a)?
20:21:38 <kmc> because StateT is a monad transformer
20:21:42 <kmc> you have to give it a monad to transform
20:21:46 <kmc> (Either String) is a monad
20:21:51 <kmc> (Either String a) is not
20:21:55 <applicative> it's clear that you need a functor * -> * in that position, something that acts on types uniformly
20:21:58 <FCo> ah ok!
20:22:02 <Dark_Shikari> is there any nice way to do the max of three numbers?
20:22:05 <Dark_Shikari> it appears max isn't variadic
20:22:10 <kmc> > maximum [1,2,4]
20:22:11 <lambdabot>   4
20:22:15 <Dark_Shikari> ah
20:22:20 <Dark_Shikari> have to put them in a list
20:22:25 <aavogt> > 1 `max` 2 `max` 3
20:22:26 <lambdabot>   3
20:22:31 <FCo> wow, sure haskell makes me feel stupid!
20:22:39 <kmc> > foldr1 max [1,2,3]
20:22:40 <lambdabot>   3
20:22:46 <Dark_Shikari> lol
20:22:49 <c_wraith> > "" `max` "powers"
20:22:50 <lambdabot>   "powers"
20:22:50 <applicative> so it's (Either String) which acts on String to produce Either String String, on Int to produce Either String Int
20:23:23 <aavogt> > maximum []
20:23:24 <lambdabot>   * Exception: Prelude.maximum: empty list
20:26:03 <FCo> thank you for your answers guys! sure haskell is hard, but the community is very helpful
20:27:17 <applicative> FCo: Haskell is easy, monad transformers are a nightmare
20:27:45 <kmc> sometimes it is easier just to write your own monad
20:27:48 <kmc> with the desired properties
20:28:04 <applicative> but your original type I was going to say, it was AlexInput -> StateT St (Either String) (AlexInput, a)
20:28:32 <applicative> so we see it's AlexInput ->  St -> Either String (AlexInput, a, St)
20:28:51 <FCo> because my original type is a monad of that type
20:29:01 <kmc> mtl is sort of a library of type-level functions for building monads, and type-level functions are sort of clunky
20:29:06 <kmc> especially in the older style that mtl uses
20:29:14 <FCo> newtype ParserM a = ParserM (AlexInput -> StateT St (Either String) (AlexInput, a)) so it's like a monad of a monad transformer of a monad
20:29:25 <applicative> It
20:29:32 <applicative> s pretty trying
20:29:32 <kmc> we have more powerful technology now
20:30:28 <FCo> I have enough problems with my stone age haskell
20:30:43 <applicative> Still one sees the sense it's making   AlexInput ->  St -> Either String (AlexInput, a, St)  is isomorphic to (AlexInput , St) -> Either String ( a, (AlexInput,St))
20:30:57 <Dark_Shikari> ok, so I'm an idiot, but every single example I've found for haskell demonstrating local variables uses ghci
20:31:03 <Dark_Shikari> how the heck do you declare constant local variables in a function?
20:31:26 <Dark_Shikari> "let" doesn't seem to work
20:32:12 <applicative> So with an AlexInput and a St, you get Left "Hahahahha" .... or else you get a Right (AlexInput, a, St) to work with
20:33:26 <FCo> well the "hahahaha" should be a beautiful abstract syntax tree, parsed by happy :P
20:33:46 <FCo> not really, tha a should be the AST
20:33:50 <aavogt> kmc: what do you prefer over mtl?
20:34:18 <FCo> the "hahaha" would be yet another awful error message
20:34:29 <aavogt> > let x = 1; y = 2 in x + y -- like this Dark_Shikari
20:34:30 <lambdabot>   3
20:34:37 <Dark_Shikari> aavogt: I said not using ghci!
20:34:38 <Dark_Shikari> in a function!
20:34:44 <Dark_Shikari> let does not work in functions
20:34:45 <applicative> The Left, thats where they keep finding the error
20:34:58 <aavogt> that works for sure
20:35:04 <Dark_Shikari> That's a ghci line.
20:35:16 <Dark_Shikari> :l fails instantly on the first instant of the word "let" in any function that I use
20:35:23 <Dark_Shikari> before even parsing anything after the let
20:35:33 <aavogt> you can write    f x = let a = 'a' in "hai"
20:35:36 <Dark_Shikari> fib.hs:63:4: parse error on input `let'
20:36:04 <Dark_Shikari> http://pastebin.com/m5b47100e
20:36:09 <Dark_Shikari> it fails on the first let
20:36:10 <aavogt> you do recognize that as an expression form, let needs to be followed by `in'
20:36:19 <Dark_Shikari> in what
20:36:45 <kmc> aavogt, i don't have a preference.  there are a few alternatives i've yet to investigate
20:36:50 <aavogt> http://pastebin.com/mac42d75
20:37:24 <Dark_Shikari> ah, just keep putting in
20:37:35 <aavogt> alternatively, you can leave out all `let' after the first one if you leave out all but the last `in'
20:38:11 <aavogt> which depends on you aligning the first letter of each binding you make
20:39:10 <aavogt> also, most of your parentheses are unneeded
20:39:48 <aavogt> as in:   (f x) + (g y)  =  f x + g y
20:40:11 <Dark_Shikari> I'm from C land, we overparenthesize things
20:40:17 <Dark_Shikari> C + scheme
20:41:29 <aavogt> also, you can pattern match on the RHS of a let which makes your first, second, third functions unnecessary
20:41:54 <aavogt>   (a1,a2,a3) = toRPNopt a
20:42:00 <Dark_Shikari> true
20:42:35 <kmc> not unreasonable to use extra parens if you think it looks better / is more clear
20:46:08 <Rakko> Hi
20:53:19 <Cale> Hello
21:09:22 <kmc> :t build
21:09:23 <lambdabot> Not in scope: `build'
21:09:28 <kmc> :t GHC.Exts.build
21:09:29 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
21:09:46 <kmc> :t let build g = g (:) [] in g
21:09:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
21:09:51 <kmc> err
21:09:53 <kmc> :t let build g = g (:) [] in build
21:09:54 <lambdabot> forall a a1 t. ((a -> [a] -> [a]) -> [a1] -> t) -> t
21:10:52 * Costin www.club404.ueuo.com/live.php the best radio the best music ;)
21:11:01 --- mode: ChanServ set +o Cale
21:11:09 <DigitalKiwi> uh oh
21:11:14 <Cale> Costin: no ads please.
21:11:20 <Dark_Shikari> probably a spambot
21:11:27 --- mode: Cale set +b *!*@host-84-222-186-23.cust-adsl.tiscali.it
21:11:27 --- kick: Costin was kicked by Cale (Costin)
21:11:32 --- mode: Cale set -o Cale
21:12:04 * DigitalKiwi #haskell the best language the best channel
21:12:49 <copumpkin> damn, an italian spammer
21:13:35 <DigitalKiwi> lol he just got k-lined XD
21:13:56 <kmc> nice
21:19:20 <trie> A quick quick ckeck question : What would be the simplest way to write a string generator which only uses 'a' .. 'z' say?
21:19:54 <copumpkin> > flip replicateM ['a'..'z'] >>= [0..]
21:19:55 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
21:19:56 <lambdabot>                           ...
21:20:14 <copumpkin> ah well
21:20:25 <shrughes> > flip replicateM ['a'..'z'] =<< [0..]
21:20:26 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
21:20:35 <copumpkin> whoops :P that was silly
21:21:01 <trie> i was hoping for strings, sized if possible
21:21:06 <copumpkin> ?
21:21:08 <copumpkin> those are strings
21:21:26 <copumpkin> > (flip replicateM ['a'..'z'] =<< [0..]) !! 10000
21:21:26 <trie> true but without any variation in length
21:21:27 <lambdabot>   "ntp"
21:21:32 <copumpkin> > (flip replicateM ['a'..'z'] =<< [0..]) !! 100000
21:21:33 <lambdabot>   "eqxd"
21:21:34 <aavogt> > map (:[]) ['a' .. 'z']
21:21:35 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
21:21:38 <shrughes> > flip replicateM ['a'..'c'] =<< [0..]
21:21:39 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
21:21:42 <copumpkin> trie: it's generating all strings of all lengths
21:21:46 <Dark_Shikari> > [0..]
21:21:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:22:05 <copumpkin> if you want a specific length, just use replicateM
21:22:12 <copumpkin> > replicateM 5 ['a'..'z']
21:22:12 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaah","aaaai","a...
21:22:42 <shrughes> it's such a disgraceful way to generate an arbitrary string of the given length though
21:22:54 <copumpkin> why?
21:23:01 <shrughes> it's slow
21:23:06 <trie> just not random ones - I was hoping for some combination of Quick Check combinators
21:23:10 <copumpkin> I guess
21:23:32 <copumpkin> oh, tell us what you actually need up front then :P
21:23:44 <trie> That way I can write my quick check props as: forAll simpleStrings $ \s -> ....
21:23:53 <aavogt> you've only seen deterministic lists of strings
21:25:18 <aavogt> @type replicateM ?n (Test.QuickCHeck.choose ('a','z'))
21:25:19 <lambdabot> Couldn't find qualified module.
21:25:26 <aavogt> @type replicateM ?n (Test.QuickCheck.choose ('a','z'))
21:25:27 <lambdabot> (?n::Int) => Gen [Char]
21:26:22 <trie> replicateM with choose should do the trick
21:26:41 <aavogt> also elements if  choose doesn't pick the range
21:33:33 <dmwit> Hm. What do I have to do to get cabal-install working on Windows?
21:33:51 <dmwit> "cabal: CreateDirectory: invalid argument (Cannot create a file when that file already exists.)"
21:34:06 <dmwit> (the error from the first "cabal update" I ever tried)
21:38:15 <scutigera> first things first, cabal -v3 or so and find out what's going on
21:38:24 <dmwit> cabal -v3 doesn't print anything extra
21:38:26 <dmwit> sadly
21:38:44 <dmwit> I'm giving the Platform a shot now.
21:38:50 <dmwit> It comes with cabal-install, right?
21:39:06 <scutigera> now that's not helpful at all,BTW, in solidarity with you I just had a cabal install fail too :-(
21:39:17 <dmwit> =/
21:39:18 <dmwit> sorry
21:39:50 <scutigera> hey- I heard back from Conal. He's waiting on hopengl changes to fix reactive glut.
21:39:58 <dmwit> Oh!
21:40:09 <dmwit> Does he expect hopengl to change soon?
21:40:21 <copumpkin> he's hopen hopengl will change soon
21:40:26 <scutigera> it's all up to Sven - go Sven go
21:41:06 <scutigera> hawful
21:41:33 <dmwit> hawful -- the Haskell library nobody likes
21:41:53 <dmwit> It's funny because half the libraries on Hackage start with an 'h', see?
21:42:16 <scutigera> yes i see (backs away slowly...)
21:42:18 <copumpkin> no, please explain more deeply
21:42:57 <scutigera> oooh, hlint.  I wonder what I can use it for...
21:43:09 <Rakko> so people must name all haskell libraries h*
21:43:13 <scutigera> I know that I have to be happy to install it.
21:43:47 <Zao> http://codepad.org/3W3FeUrW <- it is definitely too late to understand errors like this, tonight
21:44:10 <dmwit> hcopumpkin: hwell, hthe hjoke his hthat hI hfind hit hsomewhat hsilly hthat hthere hare hso hmany hlibraries hon hhackage.
21:44:18 <Zao> (I meant liftM, not lift)
21:44:44 <copumpkin> ho
21:45:06 <copumpkin> Zao: you messed up!
21:45:37 <copumpkin> what line led to that?
21:46:15 <Zao> lift B.pack aMaybeByteString
21:46:23 <copumpkin> :O
21:47:21 <Zao> My thoughts went somewhere along the lines of: I need to apply the function to the nested value... hummm, lifting comes to mind, let's try.
21:47:36 <copumpkin> fmap doesn't work?
21:47:43 <copumpkin> ah
21:47:47 <copumpkin> that's what you changed it to
21:47:50 <Zao> Probably does, but Functors are scary :)
21:47:56 <copumpkin> in the guise of liftM
21:50:10 <kmc> yeah, i see why that error message would arise
21:50:25 <kmc> through reverse engineering rather than comprehension ;P
21:56:48 <dmwit> arrrgh
21:57:10 <dmwit> "cabal-install-0.6.4 failed during the final install step."
21:57:38 <dmwit> All the more frustrating because of how long it takes to build things in a VM.
21:57:52 <Cale> Isn't that an old version?
21:58:01 <dmwit> Yes.
21:58:09 <dmwit> I was trying "cabal install cabal-install" to get the new version.
22:00:41 <dmwit> Wow, cool, I managed to crash VirtualBox.
22:01:12 <dmwit> Maybe testing on Windows isn't worth this. =P
22:21:34 <mjrosenb> lambdas are supposed to extend as far as possible, right?
22:22:07 <mjrosenb> so \x -> f x +++ g y gets parsed as \x -> ( f x +++ g y)
22:22:27 <aavogt> definitely
22:22:55 <mjrosenb> whoops
22:23:00 * mjrosenb fixes his parser
22:23:45 <Zao> > [1..3] >>= \x -> [10..14] >>= \y -> return y
22:23:50 <lambdabot>   [10,11,12,13,14,10,11,12,13,14,10,11,12,13,14]
22:24:46 <dmwit> :t map \x -> x -- hm, doesn't always work out
22:24:47 <lambdabot> parse error on input `\'
22:28:02 <monochrom> > \() -> ()
22:28:03 <lambdabot>   {()->()}
22:28:36 <monochrom> I wonder why the syntax forbids map \x -> y
22:28:50 <dmwit> Me, too.
22:28:55 <dmwit> Got the report handy?
22:29:18 <monochrom> Too lazy to read at this time. Plus I'm working on something else.
22:29:49 * dmwit nods in agreement
22:31:01 <monochrom> Allowing map \x -> y would reduce 50% of the need of $. Example: forM_ [1..10] \i -> print i
22:31:15 <dmwit> Yes, I tried a trick like that earlier tonight.
22:31:23 <dmwit> I was very disappointed.
22:31:52 <monochrom> Oh interesting, so infix operator mixes well with lambda.
22:32:24 <monochrom> > [1..10] `forM` \i -> i
22:32:25 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
22:32:25 <lambdabot>    arising from a use of `M86889209...
22:32:35 <monochrom> > [1..10] `forM` \i -> return i
22:32:36 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
22:32:36 <lambdabot>    arising from a use of `M86680421...
22:32:49 <dmwit> > [1..10] `forM` \i -> [i]
22:32:51 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
22:32:56 <monochrom> heh
22:33:05 <monochrom> This proves that lambdabot uses hint.
22:33:16 <dmwit> Oh?
22:33:33 <monochrom> "M86889209" is a hint thing.
22:33:54 <dmwit> Oh.
22:34:31 <monochrom> As a corollary, someone should take a look at /tmp of where lambdabot runs. It is full of directories made by hint because hint doesn't cleanup.
22:35:25 <c_wraith> are there someones other than cale who can look there?
22:39:46 <dmwit> > map if True then id else id
22:39:47 <lambdabot>   <no location info>: parse error on input `if'
22:40:26 <dmwit> monochrom: It seems it's not allowed simply because it's not allowed.  Functions may only be applied to a subset of expressions, which doesn't include lambdas, let, if, case, or do.
22:41:38 <monochrom> I understand forbidding let,if,case,do because they look too similar to identifiers.
22:42:36 <monochrom> I may guess forbidding lambda is because to encourage writing map (\x->y) xs, more regular than (map \x->y) xs.
22:43:09 <aavogt> <<The Forbidden Lambda>>
22:43:17 <dmwit> Yeah, there's no doubt the latter is a strange style
22:43:18 <dmwit> .
22:44:13 <c_wraith> is there a robot in the forbidden lambda?
23:08:01 <coppro> Has the Haskell 2010 standard actually been released?
23:10:50 <copumpkin> yeah
23:12:57 <coppro> I can't seem to find anything other than the announcement, which just says they'll be working on publishing an actual document
23:14:27 <FliPPeh_> Oh man, icy.
23:14:37 * FliPPeh_ needs summer
23:16:31 <danderson> is there a way to thread an implicit whitespace parser into a Parsec parser?
23:17:13 <danderson> I'm parsing a reasonably complex text format, and I'd just like Parsec to try to eat spaces and continue if the parser chain I defined is failing
23:17:18 <danderson> (not sure if I'm making any sense)
23:18:40 <coppro> I understand, I just have 0 experience with parsers in Haskell :)
23:19:16 <balboa02> danderson: I think you're looking for a lexeme parser
23:19:56 <balboa02> danderson: http://is.gd/88CZ9
23:20:24 <danderson> balboa02: thanks, looking
23:22:43 <o-_-o> is ghci big-endian or little-endian ?
23:23:27 <danderson> unless you're manipulating serialized integers, the question is meaningless
23:23:38 <danderson> why are you asking?
23:24:00 <o-_-o> Word32 seems to be big-endian
23:24:26 <o-_-o> or...the program that is given in hutton seems to print out the array in big-endian format
23:25:05 <o-_-o> I am trying to write a program to reverse a 32 bit integer in haskell
23:25:33 <Sgeo> I just did a cabal install cabal-install
23:25:40 <Sgeo> My virus scanner decided it was malware
23:26:06 <Sgeo> Um, it's going ahead anyway
23:26:29 <danderson> o-_-o: so, I assume you're manipulating the Word32 through Data.Bits operations?
23:26:55 <danderson> if you are, Data.Bits defines bit 0 as the least significant
23:27:11 <danderson> so, anything you do with it will make the data you manipulate look big-endian
23:27:28 <danderson> that doesn't however have any relation to the actual byte ordering of the machine
23:27:36 <o-_-o> danderson, yes
23:27:53 <o-_-o> danderson, yes, I understand
23:28:04 <danderson> the machine could be little-endian, in which case Data.Bits operations would simply be implemented in a funky way to account for that
23:29:10 <o-_-o> danderson, ok...so I can assume the same behaviour everywhere irrespective of the endiannes of the machines ?
23:29:23 <o-_-o> s/endiannes/endianness*
23:29:23 <danderson> if you use Data.Word and Data.Bits, yes
23:29:28 <o-_-o> danderson, thanks
23:29:55 <danderson> the machine endianness is a too low level concept for Haskell :-)
23:30:37 <danderson> it's visible in the definition of Word32: it's not a 32-bit machine integer, it's an Int that happens to wrap at 2^32
23:31:10 <danderson> how it gets implemented by GHC is a different question, but for programming purposes, Words don't have an endianness
23:31:31 <danderson> they just exist as lovely abstract numbers with funky properties :-)
23:31:39 <o-_-o> danderson, ok
23:48:09 <FliPPeh_> :t catch
23:48:10 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:49:54 <Sgeo> :k (->)
23:49:55 <lambdabot> ?? -> ? -> *
23:50:00 <Sgeo> WHat does that mean?
23:50:42 <FliPPeh_> Looks strange
23:50:48 <FliPPeh_> :t (->)
23:50:49 <lambdabot> parse error on input `->'
23:50:50 <aavogt> Sgeo: IIRC stuff to do with being able to accept unboxed tuples or something...
23:51:06 <cjs> Anybody have any idea what the problem might be when compiling 6.12.1 that produces "home/cjs/src/ghc-6.12.1/libraries/integer-gmp/dist-install/build/libHSinteger-gmp-0.2.0.0.a(gmp-wrappers.o):(.text+0x3c): undefined reference to `CCCS'
23:51:07 <FliPPeh_> :t (<-)
23:51:08 <lambdabot> parse error on input `<-'
23:51:28 <copumpkin> it means that the type constructor (->) takes two parameters and produces a type of kind *
23:51:53 <copumpkin> the first parameter (the domain) of the arrow can be a type of any basic kind except an unboxed tuple
23:52:03 <copumpkin> and the second parameter (the codomain) of the arrow can be a type of any basic kind
23:53:53 <danderson> balboa02: fyi, doesn't look like the lexeme stuff exists in Parsec any more. The doc you linked looks very out of date compared to the state of the art implementation.
23:55:57 <FliPPeh_> "(liftIO . hGetLine . mpdHandle) c" VS. "liftIO $ hGetLine $ mpdHandle c" - Both do the same, which one is preferred/better/more useful/maintainbable?
23:56:11 <FliPPeh_> Which notation do YOU use?
23:56:29 <Berengal> First one. Has more subexpressions
23:56:42 <Berengal> More valid ones anyway
23:56:51 <FliPPeh_> Mhhh
23:57:03 <aavogt> FliPPeh_: but maybe substitute the () with a $ in the first one
23:57:21 <Berengal> Yes, or pointfree it, if possible
23:57:21 <FliPPeh_> Alright
23:57:32 <FliPPeh_> Sadly not possible here
23:57:37 <FliPPeh_> I pointfree as much as I can :)
23:58:13 <Berengal> It's always possible to pointfree more with liberal application of flip, ap and join
23:58:14 <FliPPeh_> So function composition is "better" than using dollars?
23:58:34 <FliPPeh_> s/not possible/inconvenient
