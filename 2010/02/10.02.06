00:00:26 <dolio> I believe a call-by-name like monadic style involves (>>=) :: m a -> m (m a -> m b) -> m b.
00:00:46 <dolio> Which is what call-by-name cps application looks like.
00:02:24 <lpsmith> I've been playing with CbN cps a bit;  it's been rough going
00:02:42 <lpsmith> Clearly I understand the CbV case *much* better
00:02:51 <lpsmith> and the CbN case basically not at all
00:03:24 <dolio> CbN isn't very widely advertised.
00:03:27 <lpsmith> like you;  I've had trouble applying CbN to things involving datatypes
00:03:30 <lpsmith> heh
00:04:01 <lpsmith> Well, I was at a talk by Olivier Danvy once,  he mentioned the CbN in passing,  although not explicitly in those terms
00:04:27 <lpsmith> and his name seems to be on most of the papers talking about it :-P
00:06:32 <lpsmith> @djinn (Monad m) => m a -> m (m a -> m b) -> m b
00:06:32 <lambdabot> -- f cannot be realized.
00:06:41 <lpsmith> hmm
00:07:06 <lpsmith> @djinn Cont r a -> Cont r (Cont r a -> Cont r b) -> Cont r b
00:07:06 <lambdabot> Error: Undefined type Cont
00:07:14 <dolio> Yeah, I don't think you can get real call-by-name behavior without building it into the datatypes you're using.
00:08:44 <lpsmith> @djinn ((a -> r) -> r) -> (((((a -> r) -> r) -> ((b -> r) -> r)) -> r) -> r) -> ((b -> r) -> r)
00:08:44 <lambdabot> f a b c = b (\ d -> d (\ e -> a e) c)
00:09:04 <dolio> Although, some examples I've tried I didn't seem to get call-by-name behavior (termination when infinite values are involved) even with what I think is an appropriate encoding.
00:12:28 <m3ga> i have some routines that work on a directed acyclic graph represented as a Data.Map. i'd like to do some Quickcheck tests and need to generate some random graphs, but i can't think of a good way to only generate acyclic graphs. anyone have any ideas?
00:12:51 <lpsmith> m3ga, I wish I knew :)
00:13:09 <lpsmith> when you find an answer, tell me.   Though somebody around here might well know how...
00:14:06 <lpsmith> dolio, I've applied Reynold's CbN transformation to the K operator;  that's been about the limit of my success so far :-/
00:14:19 <lpsmith> it makes a real mess of the type
00:15:14 * lpsmith wonders if there isn't a nice way to present such a type
00:16:27 <lpsmith> m3ga, here's an idea:   generate a random cyclic graph,  then quotient the graph by it's strongly connected components
00:16:53 <lpsmith> although,  I'm afraid,  that won't produce an interesting acyclic graph most of the time
00:17:00 <lpsmith> (well, suspect, I dunno)
00:17:42 <lpsmith> how about this:  generate nodes in some order,  and then randomly generate links from that node to already existing nodes
00:17:43 <dufflebunk> what would be an interesting DAG?
00:18:39 <lpsmith> m3ga, ^^
00:18:47 <ksf> just fire up wget and follow random links on the internet, cutting away cycles
00:18:50 <dufflebunk> I'd probably make random binary trees from random lists of numbers, then glue the trees together
00:18:59 <lpsmith> ksf++
00:19:39 <ksf> @karma ksf
00:19:39 <lambdabot> You have a karma of 2
00:19:48 <ksf> preflex, karma ksf
00:19:48 <preflex>  ksf: 3
00:19:49 <lpsmith> See,  actually I was fretting over a slightly different problem;  I don't entirely understand Tarjan's SCC-finding algorithm
00:19:53 <ksf> yay
00:20:29 <lpsmith> and I strongly suspect that Tarjan's SCC algorithm finds strongly connected components in a topological order
00:21:03 <lpsmith> question is,  how do you build a set of graphs that does a good job of testing this hypothesis
00:21:06 <lpsmith> ?
00:22:16 <ksf> http://www.downloadmoreram.com/
00:22:35 <ksf> lpsmith, there's a thing called unit testing
00:22:48 <Gracenotes> I implemented Tarjan in Haskell
00:22:57 <lpsmith> So have I :)
00:22:59 <ksf> ...do unit tests first, then try to figure out how to generate them
00:23:01 <Gracenotes> I didn't understand it as well until I did
00:23:19 <Gracenotes> and even now, it is a bit out-there >_>
00:23:48 <ksf> the other possibility is to go coq or agda and just prove it...
00:23:53 <lpsmith> I still don't particularly understand it;  it was a somewhat ugly direct translation of an imperative algorithm
00:23:54 <Gracenotes> functional programming reduces things to their essences... types show exactly what comes in and what comes out, like a mathematical function
00:24:34 <Gracenotes> the fact is, too, that it just involves a lot of things to keep track of
00:24:37 <lpsmith> Gracenotes,  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6553
00:27:36 <Gracenotes> actually, looking over my code, it's a bit less clear now..
00:27:40 <lpsmith> heh
00:27:55 <felzix> This might be kind of a dumb question, but is there a way to invert a function? I have one function that turns some data into Yaml nodes and now want to make a function that turns a Yaml file into that data.
00:28:03 <lpsmith> yeah,  my code is entirely unenlightening
00:29:00 <Gracenotes> actually, it was for a cute little directed graph editor
00:29:05 <lpsmith> felzix, in general,  no.   Maybe there are some tricks you can pull with your specific case
00:29:29 <lpsmith> Gracenotes, well,  that code was quickly re-fashioned from an automata library for haskell that included it
00:29:38 <lpsmith> (and recently re-fashioned)
00:30:00 <Gracenotes> click to add node, click one node to select, click same node to delete it, click other node to add edge, click between two nodes to delete edge, or reverse edge if in different direction
00:30:16 <lpsmith> I think Benjamin Pierce is researching something he calls "bidirectional programming",  felzix,  that would do what you want
00:30:28 <felzix> cool, thanks again :)
00:30:44 <Gracenotes> for markup languages, best to write it out manually
00:30:53 <Gracenotes> typeclasses are a good way to do this, though
00:31:02 <Gracenotes> if you have structural data
00:31:23 <lpsmith> (my SCC code dates from sometime around late 2001,  or 2002)
00:32:14 <solrize> felzix, i'm pretty sure there is a YAML parser for haskell
00:32:27 <solrize> look on yaml.org
00:32:40 <lpsmith> well,  there is HaXML,  YAML is XML, no?
00:32:43 <felzix> solrize: I'm using it.
00:32:50 * solrize sez, calling something "yet another [blah]" was clever when steve johnson did it in the 1970's, but not since then ;)
00:33:00 <felzix> lpsmith: yaml is not xml, though they can be converted into each other pretty well if not perfectly
00:33:09 <solrize> lpsmith, YAML is sort of json-like
00:34:10 <lpsmith> ok, n/m,  I was thinking yaml was something entirely different
00:34:35 <Gracenotes> but unlike json, it insists on being heavily text-editor-readable, naturally structured into blocks
00:35:01 <Gracenotes> that's why I don't like it
00:35:30 <lpsmith> Gracenotes, is your implementation of Tarjan's algorithm any better/worse than my convoluted mess?
00:36:38 <Gracenotes> well, the graph is represented as data Plot = Plot { graphV :: IntMap (Int, Int), graphE :: [(Int, Int)], graphSelected :: (Maybe Int), graphTop :: Int }. the function itself is tarjan :: Plot -> Set (Set Int), and it uses an intermediate data structure data Tarjan = Tarjan { tarjanIndex :: Int, tarjanStack :: [Int], tarjanMap :: IntMap (Int, Int), tarjanComponents :: Set (Set Int) }
00:36:50 <Gracenotes> except I forget what everything in said data structure is
00:37:01 <lpsmith> hahaha
00:37:35 <Gracenotes> actually, did I end up getting it to work properly?
00:37:56 <lpsmith> I'm pretty sure my algorithm works properly.   But who knows?
00:38:04 <lpsmith> s/sure/confident/
00:38:18 <xerox> prove invariants!
00:40:16 <Gracenotes> graph algorithms proofs never seemed completely intuitive to me
00:40:48 <Gracenotes> well, intuitive in the reasoning, but the formal gears behind them
00:40:51 <Gracenotes> ..eh
00:41:06 <Gracenotes> graph theory is big :)
00:41:40 * hackagebot upload: hlint 1.6.19 - Source code suggestions (NeilMitchell)
00:55:24 <m3ga> lpsmith: to generate a DAG, i think i should just generate a random graph and then break the cycles
00:56:43 <c_wraith> m3ga: You could also order the nodes, and just make sure that any edges you draw go from previous node to later node
00:57:12 <c_wraith> m3ga: that seems easier than breaking node cycles.
00:57:43 <m3ga> yes, but that may not be representative of the real graphs i need to work on. lemme think about that
00:58:44 <c_wraith> mega: well, all DAGs can have their nodes ordered such that that property holds
00:58:49 <c_wraith> err.  m3ga
00:59:00 <m3ga> yeah, you're right
00:59:01 <ulfdoz> also called topological sorting.
00:59:07 <xerox> ?elite mega
00:59:07 <lambdabot> m3g4
00:59:16 <m3ga> thats a good solution
00:59:47 <ulfdoz> btw. breaking the cycles with touching a minimum set of edges is a very complex problem.
01:00:01 <m3ga> xerox: i'm hacking on DDC so i already knew i was elite!
01:00:05 <c_wraith> yeah, I thought it might be.  Hence suggesting a different approach. :)
01:00:07 <ulfdoz> Nevertheless, it get's easier without ensuring optimality.
01:00:08 <xerox> :D
01:00:08 * ksf wants an incremental packrat parser
01:10:37 <haskell-newbie> can anyone tell me why i get * Missing C library: sqlite3 when i try to install hdbc sqlite3 drive on windows. i downloaded sqlite3.exe and sqlite3.dll and put it into system32 folder ?
01:11:11 <ulfdoz> m3ga: May be you can also ensure a DAG with an appropriate graph grammar. In short this works as if you connect templates of subgraphs with each other, but I don't yet know, whether this is general enough to construct all DAGs.
01:11:19 <copumpkin> don't you need .lib files for linking to windows libraries too?
01:11:45 <copumpkin> haskell-newbie: why would you be copying the dll around by hand btw? isn't there an installer that puts things where they belong?
01:12:09 <haskell-newbie> do i? :) no there is no installer only 4 zip files on the sqlite3 hp
01:12:32 <copumpkin> beats me, I haven't used windows in a decade :P
01:12:34 <haskell-newbie> i love installers, but i cant find any
01:12:51 <m3ga> ulfdoz: that may be another way, but i'm actually quite happy with what c_wraith suggested. especially since its really easy to implement.
01:16:17 <haskell-newbie> i got now all sqlite zip files from the sqlite hp and unzipped them to the system32 folder, but still the same missing c library sqlite3 error
01:16:31 <haskell-newbie> where to get that .lib folder ?
01:17:13 <ksf> haskell-newbie, you most likely need the .h files, too
01:17:20 <ksf> in fact, almost certainly
01:18:07 <haskell-newbie> do i get it in some source package of sqlite3 ?
01:18:17 <ksf> yep
01:18:35 <ksf> although they should come with the compiled version, too
01:18:36 <haskell-newbie> and where to put it ? in system32 btw. on the path ?
01:18:50 <ksf> somewhere where gcc looks for them
01:19:14 <haskell-newbie> okay ill try, thx for hint
01:19:44 <ksf> if that fails, you can also give arguments to cabal that it then passes to configure to set those locations
01:20:05 <ksf> ...but I wouldn't know which, I've got everything in /usr/include
01:21:17 <felzix> Is anyone here familiar with Data.Yaml.Syck? I'm at a loss as to how to retrieve an element's contents from a YamlNode.
01:24:13 <haskell-newbie> somethimes i wish i had learned how to use linux..
01:24:25 <ulfdoz> Its never too late to start.
01:24:43 <felzix> I recommend starting with ubuntu. You can ease into using the command line.
01:25:40 <haskell-newbie> thats right, but i have tw weeks to writ a haskell app to be allowed to write an university exam. so learning linux and haskell is little bit too much for thsi short time :)
01:26:50 <c_wraith> I want to say "it doesn't take a couple weeks to learn enough linux for this", then I start thinking more carefully about it...  And maybe it does.  So stick with what you know, under such a short deadline.
01:28:06 <haskell-newbie> im doing my best :) i tried couple of times to learn it, but its hard to burn it inside my head if you dont work continuosly with it.
01:28:14 <haskell-newbie> how to tell cabal which folder to use ?
01:28:16 <ksf> it might be easier to get help for, though.
01:28:32 <ksf> either in the config file, or the command line
01:28:40 <c_wraith> haskell-newbie: In my experience, if cabal can't find the libraries it's looking for, it tells you what command line options to set.
01:28:56 <killerstorm2> hi. I have a question about coding style. I extensively use ``where'', like here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17137#a17137
01:28:59 <killerstorm2> Is it bad?
01:29:08 <ksf> you might want to try cabal install --extra-include-dirs=PATH
01:29:17 <killerstorm2> Other people prefer let, it seems.
01:29:40 <ksf> (or cabal install --help, fwiw)
01:29:41 <haskell-newbie> C:\Windows\system32>cabal install HDBC-sqlite3
01:29:41 <haskell-newbie> Resolving dependencies...
01:29:41 <haskell-newbie> Configuring HDBC-sqlite3-2.2.0.0...
01:29:41 <haskell-newbie> cabal: Missing dependency on a foreign library:
01:29:41 <haskell-newbie> * Missing C library: sqlite3
01:29:41 <haskell-newbie> This problem can usually be solved by installing the system package that
01:29:41 <haskell-newbie> provides this library (you may need the "-dev" version). If the library is
01:29:42 <haskell-newbie> already installed but in a non-standard location then you can use the flags
01:29:42 <haskell-newbie> --extra-include-dirs= and --extra-lib-dirs= to specify where it is.
01:29:43 <haskell-newbie> cabal: Error: some packages failed to install:
01:29:43 <haskell-newbie> HDBC-sqlite3-2.2.0.0 failed during the configure step. The exception was:
01:29:44 <haskell-newbie> exit: ExitFailure 1
01:29:47 <haskell-newbie> that is the whloe failure
01:29:52 <c_wraith> killerstorm2: you could make both of those declarations be in the same let, with no harm.  I think.
01:30:11 <ziman> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17137#a17138
01:30:22 <c_wraith> killerstorm2: yeah, addToSet doesn't use either of the names declared in scanRow, so they could be declared at the same level
01:30:22 <ziman> ^^ how about that?
01:30:37 <ksf> --extra-include-dirs should point to the headers, and --extra-lib-dirs to the .dll
01:30:53 <haskell-newbie> headers is .h ?
01:30:58 <ksf> yep
01:31:41 <haskell-newbie> can i use that --extra param with abal or is it ment to use it when you cofigure build and install manually ?
01:31:46 <haskell-newbie> with cabal
01:32:09 <ksf> I think all of them take it
01:32:17 <haskell-newbie> oky ill try
01:32:25 <c_wraith> killerstorm2: as far as using where in general, it's fine.  Use let or where as makes sense to you.
01:34:37 <killerstorm2> Well, I thought that declaring them on different levels adds to readability because you can see that scanRow uses addToSet, not vice-versa.
01:35:45 <c_wraith> killerstorm2: I don't think that adds any clarity in that case, just because the two definitions are both short, and it's easy to see the relationship between them.  And with fewer wheres, there's less syntax in the way of meaning.
01:35:51 <killerstorm2> But what's about case when nested "wheres" are actually required, is that ok to have a long chain of them?
01:35:54 <haskell-newbie> same failure, should i rather use mysql? or is sqlite3 more prefered in the haskell world ?
01:36:39 <c_wraith> killerstorm2: I've done it.  I think it's kind of ugly, but when it fits the solution (and it's essentially library code), I just hold my nose and do it.
01:37:52 <c_wraith> killerstorm2: I try to refactor around it if it's main application code, rather than library code, though.  It just depends on how much I'm going to have to look at it.
01:38:53 <killerstorm2> c_wraith: Ok, thank you.
01:58:25 <adu> omg, any DC area ppl?
02:03:55 <Peaker> @users
02:03:55 <lambdabot> Unknown command, try @list
02:08:06 * ksf wants an Ord restraint on Typeable
02:08:56 <ksf> er TypeRep
02:09:48 <Gracenotes> ord constraints don't naturally exist, I should think
02:09:55 <Gracenotes> for anything that's typeable
02:10:38 <ksf> I don't care for the meaning of the ord instance, just that I can put them in a map
02:11:17 <Gracenotes> with some kind of existential quantification, you mean?
02:11:30 <Gracenotes> so heterogenous typeable
02:11:52 <ksf> I don't want to get them out of the map, just lookup something based on them
02:19:23 <Gracenotes> ksf: hm. is this all very type-level-y?
02:21:32 <Peaker> There should be an ArbitraryOrd and Ord instances.  ArbitraryOrd should be the cheapest possible ordinality comparison, and Ord should be the mathematical one
02:24:04 <Botje> how would it differ for, eg. String ?
02:27:16 <Gracenotes> I'm trying to look at what a TypeRef actually is
02:27:34 <Gracenotes> would be nice if Haddock did some source code linking
02:29:08 <Gracenotes> and just what a Data.Typeable.Key is
02:30:10 <Gracenotes> uh... newtype Key = Key Int deriving( Eq )
02:30:50 <Gracenotes> should be possible to make an Ord, given that
02:31:23 <Taejo> Peaker: that's an interesting idea... I often find myself unsure of whether my types should derive Ord, since the ordering is not meaningful (and I might find a meaningful one later)
02:32:01 <Taejo> on the other hand, sometimes you want to use Map or Set with a specific order (if you're using split, findMin, etc)
02:32:17 <Gracenotes> so long as the ordering's transitive and associative, that should be all that's needed for arbitrary instance
02:32:22 <Peaker> Taejo: newtype is great :)
02:33:03 <Gracenotes> hm.. no, associative basically is transitive here, given that it's a relation. I think the requirement is antisymmetry
02:33:17 <Gracenotes> (which Doubles do not have!)
02:33:22 <Taejo> Peaker: it's a bit artificial to put a newtype-wrapped object with an "ArbitraryOrd" in a Map just to use the *natural* order
02:34:18 <Gracenotes> Peaker: what do you mean about regular Ord being more mathematical, then?
02:34:41 <Peaker> Gracenotes: "Ord" should be the "meaningful" ord, and a not-necessarily-meaningful Ord for stuff like Map
02:34:52 <Peaker> Maybe "ArbitraryOrd" is a bad name because it might have meaning
02:35:15 <Gracenotes> meaning is relative ;)
02:45:13 <Gracenotes> it is hard to get >2 consistent orderings from most types
02:46:01 <Gracenotes> well, except enumerated types. but more structural types, those two orderings being opposite of each other. so.
02:47:32 <det> How is newtype different than data ?
02:49:06 <xerox> a newtype is isomorphic to the type it is defined to be
02:49:21 <Taejo> @hoogle (x,y) -> (y,x)
02:49:21 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
02:49:21 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
02:49:21 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
02:49:35 <Taejo> :t uncurry flip
02:49:36 <lambdabot> forall (f :: * -> *) b b1. (Functor f) => (f (b -> b1), b) -> f b1
02:50:42 <iazr> @djinn (x,y) -> (y,x)
02:50:42 <lambdabot> f (a, b) = (b, a)
02:50:42 <Taejo> where did the functor come from?
02:50:47 <ksf> Gracenotes, I'm investigating extending frisbee to match on more than chars
02:50:55 <Taejo> iazr: I thought it might have a nice name
02:51:16 <ksf> the point is that it builds Intmaps out of all possible chars that might be matched on a particular position
02:51:18 <ksf> or something similar
02:51:24 <ksf> ...at least it's building intmaps out of chars
02:51:51 <ksf> http://repetae.net/repos/frisby/frisby/Text/Parsers/Frisby.hs
02:51:52 <Gracenotes> det: they both give you constructors you can pattern match on
02:51:55 <xerox> det - but it is a different type. only it does not introduce a new bottom. thinking of types as sets of values: consider «data T = T Int» it is inhabited by { _|_ } U { T x | for x in Int } whereas «newtype T = T Int» is inhabited by { T x | x in Int }. for completeness «Int» is inhabited by { _|_ } U { numbers } :)
02:52:26 <Gracenotes> xerox: a bit much type-theory-speak, methinks.
02:52:51 <ksf> well, I might end up just deriving a custom Typeable class via TH
02:52:54 <xerox> I like types-as-sets. They tell me it's not the whole story though.
02:53:12 <Gracenotes> they can be looked at as lattices.. which are sorts of sets
02:53:34 <xerox> It's not that it's wrong, there's just more structure. I apply a forgetful functor!
02:54:10 <det> I must admit I am ignorant of bottom
02:54:23 <ksf> but anyway, the first step is adapting it to run with iteratees...
02:54:25 <Saizan> don't set come equipped with some notion of equality?
02:54:27 <Gracenotes> det: with newtype, you take an old type and give it a sort of 'wrapping'. It's useful for instances of typeclasses: since they can't be overlapping, you just make a new type (but with the same values)
02:54:42 <xerox> det one can think of it as error-or-nontermination
02:55:33 <Gracenotes> data allows you to make arbitrary finite sums and products of other types. a sum is like a C union. data Blah = Constr1 Int | Constr2 String
02:55:39 <xerox> Saizan yes, there's the element-of relation from which you can do inclusion, and equality is bi-inclusion
02:56:07 <Gracenotes> a product is how many types you have within an individual constructor. data Bleh = Con1 Int String | Con2 [Bool]
02:56:19 <Gracenotes> like a C struct
02:57:03 <Gracenotes> det: anyway, newtype gets compiled down to using the type it's wrapping. the difference to the programmer is that the typeclass instances will be different, and you still do need to pattern match on it
02:57:23 <det> so newtype doesnt box ?
02:57:41 <det> I mean, is that the significant difference ?
02:57:45 <Gracenotes> like newtype Foo = Foo [Int], and func (Foo (x:xs)) = this, func (Foo []) = that
02:58:17 <Gracenotes> both are boxing to the programmer. newtype unwrapping is an implementation detail
02:58:59 <det> Is there any reason to use newtype other than implementation details ?
02:59:19 <ksf> ...the fun thing with packrat parsers is that i have a 100% guarantee I can throw away data as soon as possible
02:59:22 <Gracenotes> it's mandatory, as I said, because instances can't overlap
02:59:44 <det> I mean, to use newtype rather than data
02:59:46 <Gracenotes> the primary reason you'd define a newtype is to declare an instance for it that the original type already has, or is too general for
02:59:54 <det> Couldnt you use data for any situation you would use newtype ?
03:00:03 <Gracenotes> yeah, you could
03:00:19 <Peaker> I think newtype unwrapping should be done via "inNewtype" and "inNewtype2"... and such functions
03:00:28 <Peaker> inNewtype f = NewType . f . unNewtype
03:00:34 <Peaker> and so forth
03:00:39 <det> Is there any reason to use newtype as opposed to data *other than implementation details*
03:00:46 <kamatsu> det: no
03:00:49 <xerox> Saizan is that a problem?
03:00:51 <Gracenotes> well, there is the GHC extension for newtype deriving
03:00:57 <Gracenotes> which is very useful for selecting instances
03:01:01 <Peaker> det, kamatsu: There is a semantic difference
03:01:04 <Gracenotes> very very useful, compared to the work you'd have to do manually
03:01:32 <Peaker> http://www.haskell.org/haskellwiki/Newtype
03:01:33 <Gracenotes> as I think Peaker is getting at, there's also the thing with bottom values and strictness, which is emulatable with data
03:01:42 <Peaker> Gracenotes: not precisely, though
03:01:56 <ksf> the difference is that data Foo = Foo String can be bottom in string and still be matchable on Foo alone
03:01:57 <det> I'll read that, thanks
03:02:11 <ksf> ...whereas newtype Foo = Foo String, if String is bottom Foo is bottom
03:02:38 <Gracenotes> but in terms of programming, what they're actually used for is important
03:03:11 <Gracenotes> their motivation for existence :)
03:03:27 <ksf> newtypes are guaranteed not to exist at runtime, that's all.
03:04:03 <ksf> ...which is motivated by a) more precise typing and b) overriding typeclasses
03:04:07 <Peaker> ksf: but   case undefined of Newtype _ -> ...   is not bottom -- it's basically a no-op
03:04:08 <Saizan> xerox: i think so, you can't really compare types like that from inside the language
03:04:20 <Peaker> ksf: and   case undefined of Data _ -> ...   is bottom if the strict field is bottom
03:04:45 <Gracenotes> > case (undefined :: Int) of _ -> text "interesting behavior here"
03:04:45 <lambdabot>   interesting behavior here
03:04:56 <Gracenotes> GHC really does take advantage of primitive unwrapping :)
03:05:54 <ksf> doesn't really surprise me, pattern matching in functions works the same way
03:06:02 <Saizan> xerox: i'm not so familiar with the details of this, though
03:06:03 <ksf> it's just more intuitive, there.
03:07:14 <Gracenotes> oh, wait.. it is... what am I thinking
03:07:32 <xerox> Saizan ah we should think about types exactly like the language let us treat them?
03:08:15 <felzix> is there a way to turn an "IO YamlNode" into a "YamlNode"?
03:08:18 <Gracenotes> oh, I see, the pattern match that causes it to fail is not a _ one, but a newtype-constructored one
03:08:45 <Zao> felzix: Sequencing it inside the IO monad.
03:10:04 <Saizan> xerox: mostly when you're doing constructive mathematics using your type theory i guess :)
03:10:45 <Peaker> felzix: Not exactly, but you can "chain" your IO YamlNode action with a function that takes a "YamlNode" as an argument and chooses the next action to perform
03:10:56 <det> ahh
03:11:03 <det> this distinction is because of lazy evaluation
03:11:06 <det> I understand that
03:11:08 <det> now*
03:12:35 <Peaker> felzix: The "bind" operator does this. It's called >>= and its a function of 2 arguments:  firstAction :: IO a    chainedFunction :: (a -> IO b)    and it results in an action that performs firstAction, feeds its result to chainedFunction, and also performs the result of the function - the type of this combined action is   IO b  (it also copies the result of the 2nd action to be the total/final result)
03:13:18 <det> Is it fair to say that newtype would be no different than data in a strict language ?
03:13:55 <Peaker> det: I think so
03:14:56 <Zao> @type (>>=)
03:14:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:15:33 <Gracenotes> det: newtype is a strong type synonym
03:16:07 <Gracenotes> in such those languages, except most type synonyms that exist are completely synonymous.
03:16:23 <felzix> it looks like once I do an IO, that IO doesn't ever turn into a non-IO
03:16:28 <det> I cant parse your last sentence, Gracenotes
03:16:51 <Gracenotes> heh.. yeah, it's quite less. I'll just say, it's like a type synonym you'd have to cast back and forth from
03:17:02 <Gracenotes> *quite late. darn fingers.
03:17:08 <Peaker> felzix: Yeah, there's no escape from IO
03:17:14 <felzix> hmm
03:17:27 <felzix> thanks for the info. I understand monads a lot better now
03:17:44 <Gracenotes> det: revised edition: newtype would be a strong type synonym in those imperative languages. (I know that Go supports them)
03:17:45 <Peaker> felzix: It is so intentionally -- the idea is to guarantee that if a function is NOT marked by IO, it is pure.  And since there's no escape, a pure function cannot call a non-pure one (or it'd also have to be tainted by IO)
03:18:20 <Saizan> xerox: weird -- http://plato.stanford.edu/entries/type-theory/#4
03:18:36 <det> but it is strict/lazy that matters, not imperative/pure, correct?
03:18:51 <Peaker> felzix: So say you have a function   (Int -> String)    you know for SURE that this function cannot touch the terminal, get the system time, communicate through covert channels with other entities, or do anything except map integers to strings in a consistent/deterministic way
03:18:56 <Gracenotes> okay, all these language comparisons seem without point. newtype is an idiosyncratic Haskell feature, and it's used when necessary.
03:19:36 <Peaker> Gracenotes: in C using a wrapping struct is very much like newtype (for more specialized typing purposes)
03:19:39 <Gracenotes> the purpose of newtypes is dealing with typeclass instances. its behaviors kind of follow from that... it's got interesting semantics
03:19:42 <Peaker> and "struct" is more like "data" than "newtype"
03:19:46 <Zao> felzix: When in an controlled environment (inside an IO action), you can reason about values of type (IO a), "running" things in a well defined order to retrieve their results.
03:19:59 <Gracenotes> Peaker: in the sense that it has the same bit representation, yeah
03:20:15 <Peaker> felzix: data Foo = Foo Bar   should be the same as   newtype Foo = Foo Bar    in a strict language, as far as I understand it
03:20:19 <det> It seems like the sole purpose of newtype is to help the compiler in optimization (because otherwise you could just use data)
03:21:01 <det> and the reason it cant optimize data properly is because non-strict evaluation
03:21:06 <felzix> Peaker: you mean Gracenotes, right?
03:21:07 <det> This is my understanding so far
03:21:10 <Zao> let f g = do { x <- f ; y <- f ; return (x + y) } -- returns an action that runs f exactly twice, with x being the first result and y the second result.
03:21:13 <Peaker> oops
03:21:14 <Peaker> yeah
03:21:16 <Peaker> heh
03:21:26 <Peaker> det, Gracenotes: the data stuff above is for you :)
03:21:43 <Peaker> Zao: s/f/g
03:21:45 <Gracenotes> det: it *can't* optimize properly?
03:21:48 <Zao> Peaker: Of course :)
03:22:13 <felzix> what is "s/f/g"?
03:22:24 <Zao> Replace first with second.
03:22:25 <Gracenotes> perl replace notation
03:22:37 <Zao> It's an expression commonly used in Perl and sed and other tools.
03:22:37 <felzix> oh, duh
03:22:49 <det> Gracenotes, by data I mean "data" keyword
03:24:14 <Gracenotes> it is true that the more information you have about a type, the more you can optimize it. newtype is geared towards instance-making (and typeclasses do get compiled away at some point), and it does pretty well at it
03:24:26 <det> Gracenotes, by optimize properly I mean: "data A = A int", "3" and "A 3" should have the same representation
03:24:42 <xerox> Saizan what is 'o' in "A -> o represents the power set operator", a dummy? like P(.) = A -> . ?
03:24:50 <c_wraith> det: that's not semantically accurate
03:25:04 <det> c_wraith, ... because of non-strict evaluation
03:25:08 <c_wraith> yes
03:25:17 <Gracenotes> det: that's not what you want all the time. constructors are very important to Haskell - pattern-matching on them is how computation progresses
03:25:23 <Peaker> do I need fully-fledged GADTs to have my data constructors keep a type-class constraint within them?
03:25:51 <det> Gracenotes, I am familiar with ADTs/pattern matching, but not very familiar with Haskell
03:26:23 <det> Peaker, existential types ?
03:27:03 <jlouis> det: there is some really deep semantic differences w.r.t data and newtype and lazy evaluation
03:27:04 <Gracenotes> yeah, existential quantification in 'data's would do it
03:27:16 <Saizan> xerox: A -> o is the type of predicates over A, if you've (p :: A -> o) then "p a" terminates if a satisfies p and doesn't otherwise, afaiu
03:27:17 <Peaker> det: I don't want existential types, I just want a data constructor to require a class-context when building it, and provide it when de-constructing it(pattern matching)
03:27:40 <jlouis> det: which is why it is not just a special case of "data"
03:27:51 <Peaker> data Context a => Blah a = Blah a  -- "Context a" doesn't do anything? :-(
03:28:09 <Saizan> Peaker: data Blah a = Context a => Blah a
03:28:16 <xerox> Saizan weird :D
03:28:20 <Peaker> Saizan: that requires fully fledged GADTs?
03:28:34 <Saizan> Peaker: i think ExistentialQuantification allows it
03:28:36 <Gracenotes> Peaker: so you don't want heterogenousness. ah.
03:29:06 <det> jlouis, Do you think you could simply explain the differences? :-)
03:29:09 <Saizan> xerox: heh, it's because having p :: A -> Bool would mean that the predicate is decidable :)
03:30:37 <cheater2> if i define a function in ghci via 'let', how can i later see the source of that function?
03:30:59 <Saizan> det: data Foo = Foo Int, newtype Bar = Bar Int, case undefined of Foo _ -> () == undefined vs. case undefined of Bar _ -> () == ()
03:31:49 <xerox> Saizan but let's say Bool = { _|_, True, False } muahah.
03:32:25 <det> This whole concept of bottom I find really strange
03:32:31 <Gracenotes> cheater2: not particularly. if you're working with and modifying a definition, it's best to load/reload a source file
03:32:43 <Saizan> xerox: it's more like o = { _|_ , True } from what i've seen :)
03:32:47 <Peaker> There's  enum Bool { TRUE, FALSE, FileNotFound }
03:32:47 <cheater2> ok
03:32:58 <Peaker> Saizan: thanks, existentials does cover it :)
03:33:12 <det> Saizan, what is () in Haskell ?
03:33:14 <Peaker> which is a little.. weird
03:33:21 <Gracenotes> bottom comes from lattice theory
03:33:25 <Peaker> det: empty tuple, 1, or unit type :)
03:33:36 <xerox> Saizan so in the end I cannot keep my types-as-sets view? :( works for type classes too, they are set-theoretic relations!
03:33:40 <Gracenotes> check out http://en.wikipedia.org/wiki/File:Lattice_of_partitions_of_an_order_4_set.svg
03:33:47 <det> Why would you need unit with non-strict evaluation ?
03:33:48 <Saizan> det: i could have used any value there, tbc
03:33:59 <Peaker> det: when you have an action that must return something
03:34:00 <Gracenotes> like 1/2/3/4 is the partition of every possible partition, bottom is a value of every possible type.
03:34:06 <Peaker> det: print :: Show a => a -> IO ()
03:34:20 <det> Oh, you need it in the imperative world of haskell :-)
03:34:26 <Peaker> det: not only...
03:34:43 <Peaker> det: You might have any "box" type (imperative or not) where you care about the box, but not about the content
03:34:45 <felzix> how can I deconstruct a data type I've made into an IO? I have "IO YamlNode" and I want to get one of its fields (or w/e), "elem".
03:34:54 <Peaker> det: so you might use  box ()
03:35:03 <Gracenotes> bottom is how you deal with computations that don't end up being values (going on forever, or being runtime errors like /0)
03:35:32 <Peaker> det: Also, sometimes you have generalized/parameterized types, and you want to use them in a way that doesn't care about that part, so you can just neutralize it with ()
03:35:34 <Gracenotes> in terms of semantics
03:35:49 <Saizan> xerox: i think you can, if you don't take too much out of it :)
03:35:52 <det> Peaker, That makes sense
03:35:54 <jlouis> det: sure - http://www.haskell.org/haskellwiki/Newtype
03:36:23 <Gracenotes> det: what kind of background do you have in type theory/programming languages?
03:36:25 <jlouis> det: 'undefined' is somewhat like _|_
03:36:46 <det> jlouis, that page is very strange
03:36:56 <det> but I will try to understand it
03:37:17 <det> jlouis, I am curious of your impressions of Haskell, as I know you to be a MLer
03:37:26 <jlouis> det: remember that things will only get evaluated when they are needed
03:38:08 <Saizan> xerox: and typeclasses work on the names of the types anyway, you can't use set equality there
03:38:35 <jlouis> det: I like Haskell a lot, but note that I have played with it on and off for about 8 years or so
03:39:26 <det> From what I know of it, the only things I really like of Haskell are existential types and type classes. I really dislike lazy evaluation.
03:39:30 <Gracenotes> xerox: are you familiar with direct acyclic graphs?
03:39:45 <det> I mean, compared to ML.
03:40:01 <Gracenotes> xerox: a value is well typed if it's in the set of all types, but values also form a sort of DAG, in what's called a lattice. http://en.wikipedia.org/wiki/Lattice_theory
03:40:09 <det> there are a great many greate features of haskell that ML also has
03:40:16 <jlouis> det: lazy eval is not that big a concern I find. Type classes are really nice. Existentials are as well
03:40:22 <luqui> det, lazy evaluation is at the heart of this language, IMO.  It is what liberates us from having to think about *how* something is computed.
03:40:41 <luqui> instead only *what* the solution is
03:40:55 <Gracenotes> but it has a beautiful implementation ._.
03:41:00 <jlouis> one advantage of lazy evaluation is that it is often better to describe your problem as a set of combinators
03:41:24 <Vitka> @pl \(a1,b1) (a2,b2) -> a1 == a2
03:41:24 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
03:41:27 <jlouis> strict eval sometimes bite at that
03:41:35 * Vitka sighs.
03:41:52 <jlouis> Vitka: perhaps a trick with 'comparing fst'
03:41:54 <mauke> Vitka: (==) `on` fst
03:42:11 <jlouis> oh, mauke beats me
03:42:14 <det> jlouis, I think that the rare cases that strict bites at that can be solves with non-strict constructs within a strict language
03:42:20 <Vitka> Hmm.
03:42:24 <xerox> Saizan well... say Num = { Int, ... } then succ :: Num a => a -> a can be seen as succ :: (t \in Num) => t -> t
03:42:31 <det> usually this means non-strict sequences
03:42:32 <Gracenotes> @pl \a b -> fst a == fst b
03:42:32 <lambdabot> (. fst) . (==) . fst
03:42:41 <jlouis> det: yes, and vice versa. The rare cases where lazy bites it can be solved with a strictness annotation
03:42:44 <Gracenotes> that's a bit better. but Data.Function.on is great
03:43:30 <jlouis> det: If only ML would get let-binds of modules, then you would have existential types :)
03:43:31 <det> jlouis, I guess I find default lazyness more intrusive than rare non-strict constructs :-)
03:43:44 <Gracenotes> where does snd come in to the other version anyway
03:43:45 <Vitka> Heh, thanks.
03:44:10 <Saizan> xerox: yeah, but that's not thinking of types as sets, that's thinking of typeclasses as sets over types :)
03:44:18 <Twey> det: But non-strict structures turn out to be exceedingly useful, and also very clumsy to use in strict languages (see Python's enumerators, for example).
03:44:28 <det> luqui, I would exect that to be more of a feature of type classes
03:44:41 <Twey> Generators, even
03:44:52 <Twey> Blocked on that work for a minute there
03:44:57 <orodent> ?DCC SEND "diaper_jesus" 0 0 0
03:44:58 <lambdabot> Unknown command, try @list
03:45:19 <Gracenotes> orodent: ಠ_ಠ
03:45:22 <Twey> lambdabot: <3
03:45:26 <Gracenotes> creep
03:45:36 <luqui> det, that allows the *how* decision to be put off to another module. but lazy allows the *how* never to even be written.
03:46:42 <det> jlouis, I would think Haskell style existentials + type classes would be nicer than any solution involving modules
03:46:54 <xerox> Saizan the latter implies the former
03:47:06 <Twey> It's so much more convenient and also elegant to be able to just pass an infinite data-structure around to various transformation functions, rather than having to write a special-case function that loops over it and applies the transformations as needed
03:47:12 <jlouis> det: true, but ML development is stalled and has been for 10 years or so :)
03:47:16 <xerox> Saizan because the only "things" that can be elements of sets are sets
03:47:17 <Twey> I miss it a lot in strict languages
03:47:34 <det> jlouis, the only situations I can envisions needing existentials is first class data types containing types constrainted to  a particular type class
03:47:46 <jlouis> det: well, for language features that is. There are some amazing feats going on below the radar
03:47:48 <ben> Twey: Is that what C++ is approximating by throwing transforming iterators at everything
03:47:53 <mauke> shapr, kamatsu, jedediah, Nshag, phnglui, sm, ddarius, cjs: you seem to be vulnerable to the "DCC SEND" exploit
03:48:13 <Twey> ben: In its usual clunky way, ye
03:48:14 <Twey> s
03:48:14 <luqui> det, "the only ... I can envision is ..." is a statement about your imagination, not about existentials
03:48:15 <det> jlouis, I totally agree with you about ML and stagnation
03:48:20 <luqui> -sigfpe :-)
03:48:22 <Gracenotes> the one thing I'd like, laziness-wise, is for a map with lazy keys
03:48:36 <det> luqui, I dont understand
03:48:44 <Twey> Gracenotes: Why?  They'd all get evaluated the first time you did a lookup, anyway
03:48:44 <jlouis> det: some of the stuff Harper and Crary did with Twelf for ML is rather astounding
03:48:48 <Gracenotes> actually, I guess memocache works there. but it's mutated, not truly lazy.
03:49:14 <Gracenotes> Twey: sometimes you need complicated structures for dynamic-programming-esque tasks
03:49:19 <jlouis> det: and what Leroy wrestles Coq to do is scary ... but ML is stagnant as a result
03:49:21 <det> jlouis, most of the extensions I have read about for ML seems somewhat nice theoretically, but extremely clumsy
03:49:25 <luqui> det, just because you can't think of anything doesn't mean it's not there.   eg. unrolled stream type, an unconstrained existential:  data Stream a = forall s. Stream s (s -> s) (s -> a)
03:49:45 <Gracenotes> Twey: in cases where you can't simply have the lazy function calls fill an array/map
03:49:47 <det> luqui, think of my statement as an invitation
03:49:58 <Saizan> xerox: true in ZFC
03:50:00 <luqui> well i showed up, then :-)
03:50:11 <Twey> Gracenotes: But how would you do that if they were lazy?
03:50:39 <xerox> Saizan then again your "don't take too much from it" applies: I am not sure how type checking is expressed in this context at all...
03:51:19 <Gracenotes> no idea. It's just that dynamic programming in functional programming languages requires you to enumerate all the keys in some sense
03:51:48 <det> luqui, I am trying to understand how that type might be used :-)
03:51:59 <Gracenotes> mutable data structures don't require that, but at the same time, they rely very particularly on the order in which computation is done
03:52:01 <xerox> s/context/setting/
03:52:02 <Twey> Gracenotes: But you can't really do much with a map with unevaluated keys
03:52:23 <Twey> You'd have to evaluate them all anyway to do anything useful
03:52:33 <luqui> det, it's an infinite stream, same as Stream a = Stream a (Stream a), but expressed non-recursively (so the optimizer can see what is going on better)
03:52:55 <Gracenotes> actually, you could enumerate it, much like you can have an infinite map of natural numbers of values with an infinite list
03:53:06 <Gracenotes> but it might take a while to get to the value you want, iterating through everything
03:53:26 <Twey> I think I'm missing your point here
03:53:28 <Peaker> det: consider   smallest k = take k . sort  -- lazy evaluation means we can re-use sort's code to get an efficient "smallest" implementation :)
03:53:53 <Peaker> det: lazy evaluation defers more of the implementation decisions to become annotations at worst, or nothing usually :)
03:53:57 <Peaker> (about how to evaluate)
03:54:00 <Twey> Even so, you'd have to enumerate all the keys as you went along, or you wouldn't know when you'd hit the value you want
03:54:06 <Twey> Er, s/enumerate/evaluate/
03:54:07 <Gracenotes> Twey: mutability does have its perks, in any case, particularly when values depend on each other and caching is the only way to avoid exponential performance
03:54:16 * Twey gives his English-processor a kick
03:54:17 <Gracenotes> Twey: yeah, that's what I'm getting at
03:54:37 <det> Peaker, why is that any more efficient that a strict implementation ?
03:54:42 <Twey> Gracenotes: Oh I see… you want an infinite map?
03:54:50 <luqui> lazy specialization removes most of those exponential cases.
03:54:56 <Gracenotes> but an efficient one
03:55:03 <Twey> det: Because a strict implementation would sort the whole list
03:55:05 <Saizan> Twey, Gracenotes: an immutable infinite Trie can lazily memoize all outputs of a function and give you sublinear lookup
03:55:07 <Peaker> det: because "sort" here can sort only the beginning of the list
03:55:20 <Gracenotes> Saizan: yes, that's what I'm thinking of.
03:55:26 <Twey> Whereas lazy sort can sort only the interesting part
03:55:37 <Gracenotes> only problem is, it would take some time to get to any individual value unless you lay things out creatively
03:55:41 <det> let a = List.take list 10 in
03:55:49 <det> let b = List.sort a in
03:55:50 <det> ...
03:56:00 <det> that is doing the same, right ?
03:56:01 <luqui> det, that's not the same
03:56:10 <Twey> det: That's not doing even nearly the same thing
03:56:11 <luqui> if the smallest value were at the 100th position, you wouldn't find it
03:56:26 <det> oh, I see
03:56:35 <det> I misunderstood what that did
03:56:36 <Peaker> det: sorting and then slicing the first 10, or slicing the first 10 and then sorting are very different things
03:56:53 <Gracenotes> Twey, Saizan: the analogy to draw from is how you can calculate arbitrary values of the Collatz conjecture using an infinite list
03:56:54 <Peaker> det: (.) works like: after . before
03:57:10 <det> I get it now
03:57:11 <Peaker> Right-to-left, so that it looks more similar to function application:  after (before x)
03:57:15 <Twey> Gracenotes: Oh, it's much clearer now.  ;)
03:57:46 <felzix> Oh wow. Now I know what "return" is for in Haskell.
03:57:49 <DENZEL_FOXX> ?DCC SEND "ff???f?" 0 0 0
03:57:49 <lambdabot> Unknown command, try @list
03:58:22 <Peaker> det: I see "high-levelness" of a language feature to be all about how much of the implementation is specified by the programmer, and how much the compiler is left free to choose the implementation details.  Lazy evaluation by this definition is simply more high-level -  and that (like GC or any other high-level feature) definitely has a down-side too
03:58:25 <ben> freenode has ssl connections now, right?
03:58:29 <Twey> Yeah
03:58:34 <felzix> did DENZEL_FOX just join specifically to try to hack lambdabot?
03:58:36 <Gracenotes> port 7000
03:58:45 <Gracenotes> no, lambdabot is unhackable!
03:58:45 <det> Peaker, That is an interesting example
03:58:50 <Twey> You can also connect to the non-SSL port at 8001 to avoid the DCC issue
03:58:52 <Gracenotes> but people's routers are vulnerable
03:59:06 <ben> Surely if people were tunneling their stuff through SSL, the routers would not be noticing.
03:59:16 <Twey> Yep
03:59:17 <mauke> a different port is sufficient
03:59:21 <Twey> Yeah
04:00:01 <p_l> surely it's fun to be on public IP without any "consumer" router doing such tricks :D
04:00:08 <det> Peaker, ... but I guess that a partial quicksort would be far more than the Haskell anyways
04:00:14 <det> far more efficient*
04:00:17 <Zao> Routers are for people who don't have enough public IPs :P
04:00:25 <Gracenotes> anyway, the nice trick you can do if you know the keyset is defining lazyMap = Map.fromList . map (\k -> (k, f k)) $ keys, where f key = ... lazyMap ! otherKey ...
04:00:57 <Peaker> det: I am not sure it will, I think   take k . sort   is approaching the asymptotic lower-bound, but maybe that's not true
04:01:31 <det> Well, you can find the nth item in linear time
04:01:36 <Peaker> det: There's also a nice paper: "Why Functional Programming Matters" that highlights a lot of benefits of lazy evaluation at http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf
04:02:24 <Peaker> det: that's an altogether different algorithm, yeah.  But the minK elements algorithm seems to be "contained" in the sort algorithm, and lazy evaluation means that you don't have to write it again
04:03:00 <Gracenotes> the nth item in linear time does require you modify the original collection
04:03:02 <luqui> what is the complexity of (!! k) . sort?
04:03:24 <Peaker> luqui: I doubt it would be O(N) like the optimal algorithm...
04:03:26 <Gracenotes> I think the partition phase is still O(n) if it's immutable, just slooooow
04:03:28 <det> conversely, you could say that you could build the general quicksort in terms of the more simple selection algorithm
04:04:01 <Peaker> det: Well, the way it is organized in strict languages (e.g ML) doesn't seem to re-use code like Haskell's
04:04:56 <luqui> Peaker, I can see it being O(n) given mergesort, which can know how many elements are less than x without knowing their order.  My intuition might be off though.
04:05:20 <Peaker> @index evaluate
04:05:21 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
04:05:30 <luqui> actually on lists it is probably not.  but if we wrote mergesort on MList it might work ;-)
04:06:17 <Peaker> luqui: if we wrote stuff to use type-classes rather than concrete types, possibly most functions using lists could use DLists for near-free
04:06:28 <det> @hoogle [a] -> Int -> a
04:06:29 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:06:29 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:06:29 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
04:06:51 <det> (!!) gets the nth element of a list ?
04:06:57 <Peaker> det: Yeah
04:07:07 <Peaker> det: Pure types are awesome :)
04:07:23 <Peaker> Purity + Polymorphism + Types  is awesome, at least :)
04:07:43 <luqui> I would like to see monomorphism - types ;-)
04:07:58 <mauke> lambda calculus
04:08:12 <luqui> cheater!
04:09:44 <Peaker> Its monomorphic because its lambdas all the way down? :)
04:09:44 <det> It would truly be interesting if "(!! k) . sort" can be done in O(n)
04:10:10 <Peaker> det: only then it would be a true scottsman? :) I think  minK  is already an interesting example
04:10:32 <det> Peaker, Im not trying to discredit Haskell based on that example
04:10:46 <Peaker> det: Its really nice to be able to express minimax for instance as a bunch of operations on an infinite game tree...
04:11:03 <mauke> Peaker: yeah, all values have the type a@(a -> a)
04:11:20 <Peaker> mauke: Yeah, it took me a minute to realize that :)
04:15:43 <ksf> I'm at an utter loss. I import Data.Iteratee.Char, then copy printLines into my own file, and get a missing instance for (MonadIO (IterateeG [] Char IO)). I do have the other imports, too.
04:16:37 <Peaker> ksf: does IterateeG have an instance for MonadTrans?
04:17:01 <ksf> yep
04:17:03 <det> Peaker, it seems like maybe lazy evaluation lets you abstract more naively, whereas strict would require you to refactor the original library
04:17:10 <ksf> in Data.Iteratee.Base, which I import
04:17:12 <Peaker> ksf: write the MonadIO instance manually then?
04:17:15 <ksf> ...and .Char exports
04:17:40 <Peaker> det: well, the way you'd probably refactor it would involve manually making most things lazy
04:17:47 <ksf> there's also a manual instance in .Base
04:17:54 <ksf> the question is why it won't work.
04:28:16 <felzix> Is there a way to do pattern matching on an IO parameter in the function's pattern matching area?
04:28:45 <felzix> I don't want to have to use "<-" inside every function that has an IO parameter I need to deconstruct
04:29:12 <Peaker> felzix: you probably don't want to have IO-typed parameters (unless you are using callbacks or writing a new kind of loop)
04:29:31 <felzix> How else should I work with a data structure that I read off of disk?
04:29:57 <BONUS> felzix: what kind of program are you writing
04:29:59 <Peaker> felzix: Use >>= or do's <- to extract it and only after that pass it to the function
04:31:15 * Twey . o O ( func ((uncurry (+) <$>) -> v) -> … )
04:31:41 <Zao> felzix: How do you "read it from disk"?
04:31:51 <felzix> Using a Yaml library
04:32:09 <Zao> Take getLine for example. It's an IO String, an action that promises that it'll give you a string if you sequence it.
04:32:36 <Zao> Even better, it promises it'll do something to give you a new String every time you sequence it.
04:33:11 <felzix> and that String is not an IO String?
04:33:46 <Zao> A String is a String. An IO String is something that can be used to get a String.
04:33:51 <felzix> oh
04:34:10 <BONUS> felzix: consider this: do {contents <- readFile "blah.txt"; putStr (map toUpper contents)}
04:34:23 <BONUS> while readFile "blah.txt" is an IO String, contents here is a String
04:34:33 <felzix> BONUS: ah
04:35:30 <Peaker> felzix: If your function takes an  (IO a) value which it will ALWAYS execute once to get an "a", then it might as well just take an "a" instead -- that way it's type is more honest about what it can do
04:36:02 <felzix> ah, awesome. this is much saner than I thought
04:44:57 <felzix> holy crap it worked
04:45:14 <felzix> thanks everyone!
04:50:28 <sizur> RFC on hake and hmk
05:16:45 <Muad_Dibber> Anyone has seen errors like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17141 ?
05:16:56 <Muad_Dibber> I do not only get them on cabal install haskell-src-exts but on more packages
05:17:13 <ivanm> Muad_Dibber: :o why are you trying such an old version of haskell-src-exts? :o
05:17:18 <ivanm> Muad_Dibber: cabal update
05:17:19 <ivanm> ;-)
05:17:27 <Muad_Dibber> :o I just did cabal update
05:17:56 <ivanm> latest version is 1.8.something
05:19:54 <Muad_Dibber> oh, I posted another one just below that (that is the link I downloaded from the lambdabot page I think)
05:25:15 <ivanm> Muad_Dibber: does "ghc-pkg check" say anything?
05:25:21 <ivanm> anyway, it looks like your install is borked
05:25:44 <ivanm> maybe you tried to upgrade a boot library...
05:26:41 <Muad_Dibber> seems so, cause any package on cabal I try to upgrade fails one way or another xD
05:28:53 <Muad_Dibber> would removing ghc through the package manager, and rm 'ing .cabal and .ghc give me the option of doing a clean install?
05:30:24 <Saizan> Muad_Dibber: i'd try with just removing ~/.ghc first, keeping your global ghc installation as it is, however yes
05:30:50 <Saizan> and ~/.cabal doesn't really influence the set of packages seen as installed
05:31:05 <Muad_Dibber> aha okay
05:37:48 <Berengal> continuations with sessions: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17145#a17145 with server up at http://85.200.142.237:5000/
05:39:02 * Berengal wonders if he could implement coroutines on top of this
05:47:41 <Alpounet> increment doesn't work here
05:47:57 <Berengal> Alpounet: Does reset?
05:48:02 <Alpounet> well
05:48:02 <Berengal> Also, which browser?
05:48:09 <Alpounet> since it remains at "0"
05:48:14 <opqdonut> increment doesn't work for me either, opera
05:48:17 <Alpounet> I can't know if reset works
05:48:24 <Alpounet> I'm running chrome
05:48:28 <Alpounet> well, chromium.
05:48:30 <Berengal> Ah...
05:48:42 <Berengal> For some reason chrome doesn't like my cookies
05:48:48 <Berengal> And presumably opera as well
05:49:06 <Berengal> And Reset should return a different page
05:49:13 <opqdonut> it doesn't
05:49:24 <Berengal> Could you try firefox?
05:50:49 <kamatsu> what the hell, Haskell keeps obstinately evaluating something lazily causing exceptions to be thrown in the wrong place
05:50:54 <opqdonut> works on uzbl (webkit-based)
05:51:16 <kamatsu> b <- (evaluate $! Just $! compose op doc) `catch` ((\(e) ->  return Nothing) :: SomeException -> IO (Maybe Snapshot))
05:51:36 <kamatsu> no matter what, it always happens when my storage thread kicks in like 10 seconds later
05:51:40 <kamatsu> and the exception isn't caught
05:51:54 <Saizan> kamatsu: you need rnf on that Snapshot
05:51:57 <Berengal> kamatsu: Use lazy exceptions, like Maybe
05:52:03 <kamatsu> Berengal: not an option
05:52:13 <kamatsu> Saizan: rnf?
05:52:22 <Saizan> "reduce to normal form"
05:52:33 <Saizan> ?type Control.Parallel.Strategies.rnf
05:52:34 <lambdabot> forall a. (NFData a) => a -> Done
05:52:43 <Berengal> fmap Just (evaluate (compose op doc)), maybe?
05:52:55 <Saizan> evaluate is only up to WHNF
05:53:03 <Saizan> so it's the same as using $! there
05:53:09 <kamatsu> oh
05:53:11 <Saizan> you need to strictify the subparts
05:53:24 <Saizan> ?type Control.Parallel.Strategies.using
05:53:25 <lambdabot> forall a. a -> Strategy a -> a
05:53:35 <kamatsu> hm, ok, so, how do i put this together?
05:54:18 <Saizan> s/evaluate $! Just $! compose op doc/return $! (Just (compose op doc) `using` rnf)/
05:54:28 <kamatsu> ah, i see
05:54:32 <kamatsu> thanks
05:54:33 <Berengal> kamatsu: b <- evaluate (compose op doc); return (Just b) `catch` (const (return Nothing))
05:54:44 <Saizan> but you also need an instance NFData Snapshot
05:54:45 <kamatsu> Berengal: doesn't help
05:54:48 <Berengal> :(
05:54:59 <kamatsu> Berengal: neater though
05:55:07 <kamatsu> Saizan: okay, thanks
05:55:20 <Saizan> Berengal: that wouldn't catch the exception if it worked
05:56:16 <Berengal> Saizan: Needs more parens
05:56:38 <Saizan> my sentence?:)
05:56:47 <benmachine> isn't there a $!! for this
05:56:51 <Berengal> catch (evaluate (compose op doc) >>= return . Just) (const (return Nothing))
05:57:06 <Saizan> ah, ok, yeah
05:57:15 <Saizan> ?hoogle ($!!)
05:57:16 <lambdabot> No results found
05:57:23 <Berengal> rnf has the bad habbit of walking already-evaluated values over and over if you overuse it though, which is slow
05:58:07 <Berengal> Well, it's mostly a problem for maps and the like, where you don't want to rnf it after just inserting a single new thunk
05:58:21 <benmachine> there isn't a $!!
05:58:24 <benmachine> I'm sure there was once
05:58:43 <Saizan> benmachine: it'd still have to use a class like NFData though
05:58:47 <benmachine> yes
05:59:14 <benmachine> it was analogous to f $!! a = a `deepseq` f a
05:59:42 <benmachine> also, (evaluate (compose op doc) >>= return . Just) = Just <$> evaluate (compose op doc)
06:00:32 <cheater2> after some amount of time (a day), ghci starts taking up 15-20% of cpu for no reason. I am not running anything in it, i just open it and let it sit. this is on windows xp. is this a known issue?
06:00:49 <benmachine> I'm not sure many people run ghci for a day
06:00:51 <benmachine> so it might not be
06:01:03 <Berengal> I do, and it's not a problem for me
06:01:04 * Twey does, and hasn't encountered this problem
06:01:06 <cheater2> is there a bug tracker for ghci?
06:01:11 <Berengal> But I run Linux
06:01:12 <cheater2> i couldn't find one.
06:01:14 <Twey> Same
06:01:25 <Twey> cheater2: It's part of GHC
06:01:32 * Berengal just ran a webserver for a day in ghci
06:01:36 <Saizan> ?bug
06:01:36 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
06:01:59 <cheater2> haskell *is* meant for persistent applications, isn't it?
06:02:10 <cheater2> say, executing for months or years
06:02:16 <MissPiggy> that sounds insane
06:02:27 <MissPiggy> who even leaves a computer on that long?
06:02:33 <Berengal> "Meant" is a bit strong a word. It's not meant to do that any more than other languages
06:02:33 <cheater2> huh?
06:02:36 <Saizan> MissPiggy: servers
06:02:37 <cheater2> ever heard of a server?
06:02:39 <benmachine> cheater2: haskell, sure, ghci might be different though
06:02:56 <cheater2> benmachine: yeah. i meant haskell in general.
06:03:25 <benmachine> it'd be weird to have a language that wasn't meant to be persistent
06:03:37 <cheater2> Berengal: your statement is a fallacy in that you think there are no languages that are meant for a specific time of execution
06:03:45 <Berengal> benmachine: bash?
06:03:54 <cheater2> Berengal: for example, php is not meant for persistent applications.
06:04:08 <cheater2> it specifically has a time limit for execution.
06:04:10 <benmachine> Berengal: is there any reason why bash can't be persistent?
06:04:20 <benmachine> oh, php is a fair point
06:04:27 <benmachine> if you can call that a language lololol
06:04:35 <Berengal> Heh, true that
06:04:38 <MissPiggy> ;_;
06:04:46 <cheater2> the point is that it's a certain objective on which you can concentrate or not
06:04:54 <benmachine> http://hackage.haskell.org/trac/ghc/query?status=assigned&status=new&status=reopened&group=priority&component=GHCi&order=id&col=id&col=summary&col=component&col=status&col=owner&col=milestone&col=version&desc=1&type=bug this is useful for finding ghci bugs
06:05:05 <cheater2> if you are not concentrating on that then very obviously the quality of how this happens will turn out to be mediocre at best
06:05:08 <Berengal> long link is long
06:05:11 <benmachine> haskell is meant to be general-purpose, I guess
06:05:21 <kamatsu> Saizan: am i missing something here?
06:05:38 <kamatsu> Saizan: my "rnf" seems to go  NFdata a => a -> ()
06:05:43 <kamatsu> and just gives unit, not a Strategy
06:05:49 <kamatsu> which seems to be what using wants?
06:05:54 <Berengal> cheater2: How well your program handles running for months on end depends on the programmer than the language, I think.
06:06:03 <cheater2> Berengal: you are wrong
06:06:17 <Twey> MissPiggy: I often leave my computer on for months at a time
06:06:31 <cheater2> Berengal: and, you forget the question of the quality of the runtime/compiler/interpreter.
06:06:35 <cheater2> i understand erlang is meant for a very long uptime on the other hand.
06:06:35 <Twey> cheater2: Haskell might be, but GHCi isn't.  GHCi is a debugging tool.
06:07:17 <cheater2> Berengal: erlang has a language feature which lets you swap out code while the application is running, which is specifically a language feature meant for persistent applications. this is just an example.
06:07:33 <benmachine> kamatsu: I think Strategy is a type synonym for a -> ()
06:07:35 <Berengal> cheater2: erlang is meant to restart itself if something chrashes. It's the same as rebooting your computer when it's slow, except it's automatic
06:07:52 <cheater2> Berengal: we are talking about two different things.
06:08:15 <benmachine> @hoogle Strategy
06:08:16 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
06:08:16 <lambdabot> Codec.Compression.GZip data CompressionStrategy
06:08:16 <lambdabot> Codec.Compression.Zlib data CompressionStrategy
06:08:20 <kamatsu> Berengal: it is also possible in erlang to replace parts of your program without disrupting service
06:08:30 <Berengal> cheater2: Hot-swapping code isn't a language feature, but a runtime feature
06:08:32 <benmachine> Done = ()
06:08:39 <cheater2> Berengal: no.
06:08:47 <Saizan> kamatsu: Strategy a = a -> ()
06:08:54 <kamatsu> Saizan: got it.
06:09:00 <kamatsu> Saizan: but, still problem
06:09:10 <kamatsu>     Couldn't match expected type `Eval (Maybe Op)'
06:09:11 <kamatsu>            against inferred type `()'
06:09:18 <Saizan> kamatsu: code?
06:09:47 <benmachine> :t using
06:09:48 <lambdabot> forall a. a -> Strategy a -> a
06:09:53 <Berengal> cheater2: No? There's built-in syntax for that sort of thing?
06:09:59 <kamatsu> b <- (return $! Just (compose op doc) `using` rnf) `catch` (const $ return Nothing)
06:10:15 <cheater2> Berengal: language features are not limited to syntax.
06:10:27 <kamatsu> cheater2: right, also semantics, but hot swapping is not semantics
06:10:49 <kamatsu> cheater2: it is entirely a runtime feature, sort of like GC, which is also a runtime feature, but arguably influences language semantics.
06:11:09 <Saizan> ?type \a -> a `using` rnf
06:11:10 <lambdabot> forall a. (NFData a) => a -> a
06:11:21 <benmachine> what's the fixity of using?
06:11:35 <cheater2> kamatsu: if a language is not written for hotswapping of code, then the runtime/compiler/whatever can make assumptions which are not true once you start swapping out code.
06:11:43 <Saizan> ?type \f a -> f $! a `using` rnf
06:11:44 <lambdabot>     Precedence parsing error
06:11:44 <lambdabot>         cannot mix `$!' [infixr 0] and `using' [infixl 0] in the same infix expression
06:12:01 <kamatsu> cheater2: nothing to do with the language semantics or syntax
06:12:01 <cheater2> kamatsu: and a language defines which runtimes are valid and which are not.
06:12:04 <Saizan> kamatsu: i think you need more parentheses
06:12:07 <kamatsu> cheater2: entirely a runtime implementation
06:12:18 <kamatsu> cheater2: "valid" runtime?
06:12:23 <cheater2> kamatsu: if two runtimes have different behavior, then only one of them can be implementing a certain language.
06:12:28 <benmachine> kamatsu: kind of surprised you didn't get that fixity error
06:12:40 <kamatsu> benmachine: i see, thanks
06:12:40 <Saizan> cheater2: that's false
06:12:43 <kamatsu> Saizan: also thanks
06:12:44 <Berengal> cheater2: ghc and ghci have different behavior, but they're both valid haskell runtimes
06:12:50 <cheater2> Saizan: what do you base that on?
06:12:54 <benmachine> kamatsu: I'm being confused, that isn't helpful :P
06:13:01 <kamatsu> lol
06:13:38 <Saizan> cheater2: the semantics can be looser enough that two observably different runtime behaviour are still valid for it
06:13:52 <kamatsu> okay, i added parens, same error
06:13:54 <benmachine> I think a haskell implementation that allowed for code hot-swapping would be entirely consistent with the language spec
06:13:58 <benmachine> just as one that didn't would be
06:14:07 <benmachine> (how's hs-plugins getting along?)
06:14:16 <kamatsu> b <- (return $! (Just (compose op doc) `using` rnf)) `catch` (const $ return Nothing)
06:14:23 <kamatsu> added parens, but same type error about rnf
06:14:26 <Saizan> (or whatever that sentence with decent grammar looks like)
06:14:34 <Berengal> kamatsu: Just $!
06:14:40 <Saizan> kamatsu: i don't see where this Eval (Maybe Op) is coming from
06:14:40 <Berengal> Wait
06:15:00 <benmachine> kamatsu: this is weird, you're not rebinding rnf or using or something?
06:15:05 <benmachine> :t (`using` rnf)
06:15:05 <kamatsu> Saizan: ah, the overall expression should be of type of Maybe Op
06:15:06 <lambdabot> forall a. (NFData a) => a -> a
06:15:11 <benmachine> oh wait
06:15:11 <cheater2> Saizan: interesting.
06:15:21 <benmachine> compose op doc is not NFData?
06:15:24 <kamatsu> Saizan: no overriding no
06:15:35 <benmachine> or is it
06:15:37 <kamatsu> benmachine: yes it is, assuming that a list of NFData is NFData
06:15:40 <benmachine> oh
06:15:40 <benmachine> k
06:15:56 <benmachine> well then (`using` rnf) should really typecheck on everything
06:16:01 <Saizan> kamatsu: what types do you get for using and rnf?
06:16:10 <Saizan> kamatsu: can you paste the full error?
06:16:21 <kamatsu> rnf:
06:16:22 <kamatsu> rnf :: (NFData a) => a -> ()
06:16:25 <Saizan> kamatsu: and the complete declaration that snippet is taken out from?
06:16:30 <kamatsu> using :: a -> Strategy a -> a
06:16:33 <Berengal> kamatsu: b <- catch (Just <$> evaluate (compose op doc)) (const (return Nothing))
06:16:39 <benmachine> kamatsu: what version of the parallel package do you have?
06:16:49 <kamatsu> benmachine: ghc 6.10's?
06:16:54 <benmachine> oh ok
06:17:01 <kamatsu> Saizan: pasting, a moment
06:17:08 <kamatsu> Berengal: also won't fix my problem
06:17:24 <Berengal> kamatsu: compose op doc is also lazy?
06:17:32 <kamatsu> Berengal: well, it's not strict
06:17:33 <Saizan> Berengal: why do you keep suggesting just using evaluate when we've concluded it's not enough?:)
06:18:03 <Berengal> Saizan: Because I'm not paying much attention
06:19:15 <kamatsu> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17147#a17147
06:19:35 <kamatsu> oh crap
06:19:36 <kamatsu> hold on
06:20:02 <kamatsu> oh wait
06:20:03 <kamatsu> no, same error
06:21:56 <Saizan> kamatsu: do you have something of type Eval somewhere?
06:22:42 <benmachine> :t using
06:22:43 <lambdabot> forall a. a -> Strategy a -> a
06:23:21 <kamatsu> Saizan: I've never seen "Eval" before
06:23:23 <benmachine> there is no way that should expect Eval (Maybe [OpComponent]) in the second argument
06:23:28 <kamatsu> @hoogle Eval
06:23:28 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
06:23:29 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
06:23:29 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
06:23:37 <Saizan> kamatsu: oh, it seems you've the new parallel package there, where Strategy a = a -> Eval a
06:23:49 <kamatsu> ah
06:24:16 <Saizan> so, just forget about using
06:24:42 <Saizan> write your own using' a s = s a `seq` a
06:24:48 <kamatsu> hm, ok
06:25:19 <benmachine> that's weird
06:25:37 <benmachine> rnf, rwhnf, and r0 are no longer interchangeable
06:25:44 <benmachine> :t rnf
06:25:45 <lambdabot> forall a. (NFData a) => a -> Done
06:25:47 <benmachine> :t rwhnf
06:25:48 <lambdabot> forall a. a -> Done
06:25:57 <benmachine> or, maybe they are
06:26:08 <benmachine> or maybe they are for lambdabot
06:26:39 <kamatsu> it type checks!!
06:26:40 <kamatsu> yay
06:27:10 <Saizan> benmachine: it's using that has changed to work with this new Eval monad
06:27:54 <benmachine> Saizan: and so has rwhnf and r0 and rpar, but rnf hasn't
06:28:16 <benmachine> rdeepseq
06:28:17 <Saizan> ah, true
06:28:22 <Saizan> rdeepseq for that
06:28:27 <benmachine> seems to exist now
06:28:31 <benmachine> reduce deep seq?
06:28:34 <benmachine> that doesn't make sense :|
06:28:45 <Saizan> deepseq a = Seq (rnf a `pseq` a)
06:28:52 <Saizan> +r
06:29:57 <benmachine> also, the haddock docs are totally lying
06:30:16 <benmachine> -- > using x s = s x
06:30:20 <benmachine> using x s = unEval (s x)
06:31:16 <Saizan> and "a `using` rwhnf" doesn't do anything!
06:31:37 <benmachine> mm
06:31:41 <kamatsu> oh, you have to be kidding
06:31:47 <kamatsu> it still does exactly the same thing >_>
06:31:53 <kamatsu> exception escapes
06:31:59 <Gracenotes> @type using
06:32:00 <lambdabot> forall a. a -> Strategy a -> a
06:32:02 <benmachine> impressive
06:32:35 <Saizan> kamatsu: what's the definition of OpComponent?
06:33:21 <benmachine> are you sure the exception throwing is at all related to laziness?
06:33:23 <Saizan> and, couldn't it be that the exception is thrown by the debug statement above?
06:33:28 <benmachine> what exception is it anyway
06:33:49 <kamatsu> Saizan: it's a data type
06:33:57 <kamatsu> Insert String | Delete String | Retain Int
06:34:08 <kamatsu> i wrote an NFData instance
06:34:23 <Saizan> how does that instance look?
06:34:26 <benmachine> try Debug.Trace.trace on it?
06:34:46 <benmachine> that'd be a quick way of ensuring that it got evaluated
06:34:53 <benmachine> err
06:34:56 <benmachine> no
06:34:58 <benmachine> just print it :P
06:35:00 <benmachine> even better
06:35:44 <benmachine> kamatsu: also, return $! fmap normalize b
06:35:47 <benmachine> maybe.
06:36:04 <benmachine> although tbh you can shed a few returns there
06:36:09 <Saizan> benmachine: that's not even in the scope of the catch
06:36:12 <kamatsu> Saizan: it just passes rnf
06:36:21 <Saizan> kamatsu: can you paste the code?
06:36:21 <kamatsu> rnf (Insert s) = rnf s
06:36:22 <kamatsu> etc.
06:36:36 <Saizan> ok, that should be fine
06:36:46 <benmachine> kamatsu: what exception do you get in the end?
06:36:57 <kamatsu> benmachine: it's a failed pattern match
06:37:03 <benmachine> ah
06:37:10 <benmachine> print the structure?
06:37:12 <Saizan> from compose?
06:37:15 <benmachine> just for testing
06:37:21 <benmachine> would definitely force everything
06:37:33 <benmachine> (also, don't fail the pattern match? just an idea)
06:37:59 <kamatsu> Saizan: yes
06:39:28 <Saizan> there is a chance that GHC seeing you're strict on the value evaluates it earlier, and not inside the body of the catch
06:40:58 <kamatsu> argh
06:41:37 <benmachine> argh?
06:42:17 <kamatsu> I don't really want to make this function return a Maybe value because it doesn't fit with the maths i've worked out
06:42:35 <Saizan> "b <- (return $! pseq () (Just (compose op doc) `using'` rnf)) `catch` (const $ return Nothing)" -- this might help
06:42:52 <kamatsu> ugh, looks awful, but ok
06:42:54 <benmachine> what
06:43:16 <Saizan> pseq looks lazy on its second argument to the optimizer
06:44:09 <Saizan> (though maybe that won't help when the first argument is a constant like ())
06:44:28 <kamatsu> I'd rather not have my behavior optimizer dependent
06:44:33 <Twey> > let () = () in 5
06:44:34 <lambdabot>   5
06:44:39 <kamatsu> I should probably bite the bullet and return a maybe type
06:44:47 <benmachine> that's a good idea
06:44:58 <Saizan> yeah, that'd be way better than messing with evaluation :)
06:45:12 <kamatsu> is there an easy way to fold with maybe values?
06:45:15 <kamatsu> i fold compose elsewhere
06:45:20 <benmachine> fold <=<
06:45:27 <benmachine> :t foldr (<=<) return
06:45:28 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
06:45:34 <kamatsu> ah, neat
06:48:07 <kamatsu> ah, crap
06:48:16 <kamatsu> changing this function to use maybes requires major surgery
06:48:43 <Saizan> ?type foldM -- too
06:48:44 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:49:21 <kamatsu> compose op1s (op2:op2s) | delete op2 = op2:(compose op1s op2s)
06:49:33 <MissPiggy> delete?
06:49:33 <Saizan> kamatsu: another option is to check that op and doc satisfy some precondition before applying compose to them
06:49:49 <kamatsu> Saizan: unfortunately the condition i want to check is "Do they compose"
06:50:14 <kamatsu> Saizan: And the way to check that is, to compose them
06:50:38 <Saizan> so i guess compose should really return a Maybe if that's the only function checking this property
06:50:56 <Saizan> "(op2:) <$> compose op1s op2s"
06:51:10 <kamatsu> thanks, i was looking for a brief way to right that
06:51:18 <kamatsu> *write
06:51:42 <MissPiggy> I want to ask about setting out a haskell program
06:51:50 <MissPiggy> I already wrote mine but it seems suboptimal
06:52:03 <Saizan> setting out?
06:52:11 <MissPiggy> like how to organize it
06:52:18 <MissPiggy> and what structures to use and such
06:53:05 <MissPiggy> what I did is make a typeclass for Add, Mul and Div, then implement (most) them on Integer, Rational Integer, a => Complex a and then Monomial and Polynomials
06:53:12 <MissPiggy> so now I can mutliply polynomials
06:53:32 <MissPiggy> but it is maybe not the right way?
06:54:00 <Saizan> what problems are you having with it?
06:55:03 <Saizan> i mean, is there something that you need that's made difficult or cumbersome to write in that context?
06:55:28 <MissPiggy> well not that i know if
06:55:30 <MissPiggy> of*
06:55:44 <MissPiggy> maybe it is fine but I just felt that maybe I have done something silly
06:57:16 <Saizan> nothing that seems silly in the description you wrote, at least
06:57:39 <MissPiggy> okay
06:58:21 <MissPiggy> I want to put symmetry, associativity proofs in the file which get compiler checked :|
06:58:26 <MissPiggy> because I had bugs before
06:58:31 <MissPiggy> now I don't think I do..
07:00:04 <Saizan> the best you can do in haskell is have some quickcheck properties i think
07:00:33 <MissPiggy> hm
07:01:08 <MissPiggy> if I check this code on {-2,-1,0,1,2}^2 that should be a correctness proof
07:01:20 <MissPiggy> for all values
07:11:05 <Berengal> Can someone with Opera see if http://85.200.142.237:5000/ works?
07:11:43 <BONUS> Berengal: ya it works
07:11:46 <BONUS> 9.10 here
07:11:54 <Berengal> BONUS: Neat
07:12:21 <BONUS> how does that work
07:12:42 <Berengal> BONUS: Fancily :) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17145#a17145
07:13:05 <BONUS> wow, cool
07:14:05 <Berengal> I'd like to somehow get proper exceptions in there as well, but I'm not sure on how to get them past the ContT
07:14:10 <Alpounet> how do I cast a Double to an Int (if possible) ?
07:14:20 <Berengal> Alpounet: floor/ceiling/truncate/round
07:14:22 <Berengal> Choose one
07:19:53 <benmachine> foreverFrom a x = x >>= foreverFrom a?
07:21:28 <benmachine> oh I don't understand continuations at all
07:21:39 <benmachine> well I do a bit
07:21:40 <benmachine> but not really
07:21:46 <masak> join the club. :)
07:22:47 <knobo> I did once (or maybe I thought I did), but I forgot :(
07:23:21 <masak> you should have taken a continuation at the time you knew, so you could get back to that point at any time. :)
07:25:20 <artagnon> data foo = foo {x, y}; moo = foo  {x = 4, y = 5}. How do I extract the x of moo?
07:25:35 <benmachine> x moo
07:25:51 <benmachine> er, that data declaration is invalid
07:25:51 <Berengal> artagnon: or let Foo{x} = moo in ...
07:26:05 <benmachine> Berengal: that requries an extension doesn't it?
07:26:21 <benmachine> let Foo { x = x } = moo in ... is the h98 version
07:26:28 <Berengal> benmachine: Not sure if it does. Perhaps you need let Foo{x=x} = moo in ..
07:26:31 <artagnon> benmachine: types is the issue, no?
07:26:44 <benmachine> artagnon: that's a vague question
07:26:46 <artagnon> benmachine: x moo works nicely. Thanks :)
07:26:50 <Berengal> artagnon: Types and constructors need to be capitalized
07:27:00 <artagnon> benmachine: oh.
07:27:07 <artagnon> I took care of that. Thanks :)
07:28:30 <artagnon> Berengal: hmm..? I didn't get that.
07:28:46 <Berengal> artagnon: What, the pattern matching?
07:29:18 <artagnon> Foo{X}: Illegal use of punning for the field 'x'
07:29:29 <benmachine> see told you
07:29:31 <benmachine> :P
07:29:35 <Berengal> Ah, ok. So that requires an extention
07:29:39 <benmachine> there's a GHC extension for it
07:29:39 <Berengal> x=x should work though
07:29:47 * artagnon tries
07:29:52 <benmachine> but it's just a faster way of writing Foo { x = x } anyway
07:30:43 <Berengal> If you're using records alot you want the extensions. You can then pattern match on Foo{..} to get all fields in scope
07:31:16 <Berengal> There are a few of them
07:32:35 <artagnon> Berengal: Ok, I'll look them up
07:32:45 <artagnon> doesn't every practical Haskell program use records for storing data?
07:33:02 <artagnon> I'm writing a simple AI Tron bot.
07:33:27 <artagnon> or atlest trying :p
07:34:23 <Berengal> Not neccessarily. Regular ADTs work too.
07:34:29 <Berengal> But most do
07:34:51 * artagnon nods
07:35:33 <Saizan> even if you records, you might not have to pattern match against them so often
07:36:02 * benmachine notices that ContT r m a seems to be isomorphic to Cont r (m a)
07:36:18 <benmachine> I guess the method definitions are different?
07:36:22 <artagnon> I'm reading Real World Haskell, but I think learnyouahaskell.com explains the concepts very well.
07:36:31 <Berengal> @unmtl ContT r m a
07:36:31 <lambdabot> (a -> m r) -> m r
07:36:37 <Berengal> @unmtl Cont r (m a)
07:36:37 <lambdabot> (m a -> r) -> r
07:36:42 <benmachine> oh whoops
07:36:50 <benmachine> did I mean
07:36:54 <benmachine> @unmtl Cont (m r) a
07:36:54 <lambdabot> (a -> m r) -> m r
07:36:58 <benmachine> there we go
07:39:12 <benmachine> am I right in thinking that there is only one possible law-abiding Functor instance for each type?
07:43:08 <artagnon> fmap becomes map for lists. What else could it become?
07:43:30 <benmachine> for lists there is certainly only one
07:43:39 <MissPiggy> fmap on trees is pretty much the same as on lisps
07:43:47 <Twey> fmap on Either is difficult, though
07:43:47 <benmachine> I think for similar reasons there can only be one on any structure
07:43:52 <MissPiggy> instead of [a,b,c] -> [x,y,z] you get ((a b) c) -> ((x y) z)
07:43:55 <benmachine> since all you have is a function and all you can do is apply it
07:44:02 <benmachine> but proving that is probably beyond me
07:44:05 <Twey> But apply it to what?
07:44:13 <Twey> If the structure is a bifunctor, there are two possibilities
07:44:21 <benmachine> well, you can only apply it to things of the right type
07:44:35 <Twey> You can have an Either String String
07:44:36 <benmachine> and you have to apply it to all of the things of the right type otherwise you don't get an f b at the end
07:44:41 <MissPiggy> benmachine, yeah you can't modify the shape because fmap id = id
07:44:49 <Saizan> Twey: fmap f (Right x) = Right (f x); fmap f (Left e) = Left e
07:44:56 <Twey> Oh yeah
07:45:00 <Twey> That wasn't what I was thinking of at all
07:45:04 <benmachine> heh
07:45:16 <benmachine> I wish I knew more about parametricity
07:45:20 <MissPiggy> fmap on functions
07:45:28 <MissPiggy> that's a more interesting case
07:45:37 <Twey> I can't see how else it could be defined
07:45:51 <benmachine> oh, on that note, the existence of cast :: a -> Maybe b breaks parametricity does it not?
07:45:53 <Twey> I suppose it could apply before or after
07:46:01 <MissPiggy> @free fmap :: (a -> b) -> (fa -> fb)
07:46:01 <lambdabot> g . p = q . f => k . fmap p = fmap q . h
07:46:03 --- mode: ChanServ set +b Smerdyakov!*@*
07:46:04 --- kick: Smerdyakov was kicked by ChanServ (Banned: don't*pick*on*newbies)
07:46:12 <Saizan> benmachine: yes, with not constraints like that
07:46:16 <Saizan> *no
07:46:16 <MissPiggy> @ops
07:46:16 <lambdabot> Maybe you meant: docs oeis pl
07:46:22 <MissPiggy> someone should unban him..
07:46:26 <benmachine> :t cast
07:46:28 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
07:46:34 <benmachine> oh hmm
07:46:42 <benmachine> good point
07:47:28 <benmachine> I suppose you could make cast a method of an MPTC and then define it without unsafeCoerce?
07:47:48 <benmachine> or, would that work
07:47:51 * benmachine confuses self
07:47:57 <MissPiggy> that wouldn't count :P
07:48:03 <Saizan> ?type cast
07:48:04 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
07:48:43 <Saizan> that doesn't break parametricity, it still requires unsafeCoerce to implement it though
07:48:58 <benmachine> hmm
07:49:16 <Saizan> require is too strong maybe, though that's how it's implemented
07:49:23 <benmachine> I'm wondering if it does require
07:49:50 <benmachine> I think you could do it with overlapping instances but they are almost as bad :P
07:50:15 <Saizan> you could have (Read a, Show a) as superclasses of Typeable and cast with read . show :)
07:50:49 <benmachine> I suppose so
07:51:01 <benmachine> (except that a lot of things are Typeable and aren't Read or Show)
07:51:08 <benmachine> (but I guess the point stands regardless)
07:51:33 <benmachine> hmm
07:52:25 <Saizan> a class like "class Castable a b where cast :: a -> Maybe b" would be harder to use, even if you could define all the right instances
07:52:50 <benmachine> why?
07:53:15 <Saizan> data AnyTypeable = forall a. Typeable a => AnyT a
07:53:43 <Saizan> now i can pattern match on two AnyT and try to cast one to the type of the other
07:54:15 <Saizan> without specifying a concrete type
07:54:34 <benmachine> hmm
07:55:21 <Saizan> with Castable a b you'd have to parametrize AnyT with a common type if you want to do something like that
07:55:45 <Saizan> data AnyT b = forall a. Castable a b => AnyT a <- quite different
07:55:59 <benmachine> hmm
07:56:50 <benmachine> okay
07:57:40 <deathdefineslife> Greetings
07:57:53 <benmachine> hello
07:58:23 <benmachine> I am thinking you couldn't do Typeable like it is now without unsafeCoerce
07:58:46 <benmachine> well obviously you couldn't, since a false Typeable instance allows you to get the unsafeCoerce back out
07:59:57 <benmachine> but I wonder if it would be possible to get the commonly-used benefits in a way that didn't allow such things
08:00:41 <Saizan> TypeRep could be a gigantic GADT :)
08:00:52 <benmachine> hah
08:00:56 <benmachine> not extensible, though :(
08:01:04 <Saizan> no
08:01:18 <benmachine> I guess if you make it extensible you make it breakable
08:01:35 <Saizan> not sure about that
08:01:49 <Saizan> depends on how the extensions get written :)
08:01:56 <benmachine> I suppose so
08:02:15 <benmachine> if you had GHC enforce that Typeable must be derived, then great, but that's kind of cheating :P
08:03:29 <Saizan> it'd be something like data TypeRep a where IsInt :: TypeRep Int; IsBool :: TypeRep Bool, IsArrow :: TypeRep a -> TypeRep b -> TypeRep (a -> b)
08:04:27 <Saizan> i think you couldn't cheat while implementing typeOf, it it had type "a -> TypeRep a"
08:05:06 <benmachine> uhm
08:05:13 <benmachine> but then you can't use it for cast :P
08:05:23 <benmachine> unless you have Eq on TypeRep a and TypeRep b
08:05:29 <benmachine> in which case you haven't solved anything
08:05:56 <Berengal> You've solved the pesky "dynamic programmer" problem :)
08:05:59 <benmachine> you can't have Eq on
08:06:04 <benmachine> Berengal: :P
08:06:06 <Saizan> cast :: TypeRep a -> TypeRep b -> a -> Maybe b; cast IsInt IsInt a = Just a; cast IsBool IsBool a = Just a; .... cast _ _ = Nothing ? :)
08:06:25 <benmachine> hah
08:06:29 <benmachine> maybe
08:06:44 <benmachine> (think you need some unsafeCoerces though)
08:06:50 <Berengal> cast :: (TypeRep a ~ TypeRep b) => a -> b
08:07:06 <Berengal> And make TypeRep an associated datatype
08:07:19 <Saizan> that's not the same
08:07:21 <benmachine> surely that's basically equivalent to cast :: (a ~ b) => a -> b
08:07:27 <benmachine> i.e. cast :: a -> a :P
08:07:28 <Saizan> ~ is resolved at compile time.
08:07:28 <cheater2> what is the biggest cluster running haskell?
08:07:58 <Saizan> cheater2: skynet
08:08:08 <cheater2> Saizan: what is that?
08:08:11 <Berengal> cheater2: #haskell
08:08:28 <Berengal> Saizan: Well, I want my types to be resolved at compile time :P
08:08:41 <cheater2> Berengal: ...huh?
08:08:47 <Saizan> cast is about doing it at runtime though :)
08:09:04 <benmachine> Berengal: mainly I'm thinking about Data.Generics
08:09:11 <Berengal> That just means your types aren't dependent enough :P
08:09:22 <cheater2> Berengal, Saizan: those answers did not make sense to me, can you please explain?
08:09:23 <benmachine> which you can do in a typesafe way only by writing lots and lots of code
08:09:41 <Saizan> cheater2: we were just kidding, i personally have no idea
08:09:48 <cheater2> ok
08:10:37 * Berengal thinks lambdabot is the mother of skynet
08:11:00 <benmachine> @vixen where is sarah connor
08:11:00 <lambdabot> awesome
08:11:02 <Saizan> no one knows how lambdabot works anymore, so that might be true
08:13:57 <benmachine> hmm, ContT *is* exactly the same as Cont in all their shared instances
08:14:15 <benmachine> but the type strucutre allows ContT to have other instances too
08:14:25 <Saizan> nice, eh?:)
08:14:29 * benmachine newtype derives
08:14:42 <Saizan> ContT r m is a Monad for whatever m
08:15:16 <Berengal> Is it a MonadError too? Because I can't find any instances for it
08:15:55 * Berengal wants exceptions in his continuations instead of this silly callCC nonsense
08:16:22 <Saizan> MonadError e m => ContT r m is surely writable
08:16:44 <Twey> Explicit exceptions, I hope
08:16:59 <Berengal> MonadError e m => MonadError (ContT r m) too, I hope
08:17:26 <Berengal> Haven't looked at explicit exceptions for this yet. I was going to, but then I started reading wikipedia
08:17:43 <Berengal> What I learned today: COBOL sucks because Hopper didn't have a beard.
08:18:02 <Twey> Haha
08:18:48 <Saizan> Berengal: heh, yeah, that's the instance i meant :)
08:19:36 <Berengal> But if it's possible, why isn't there one already?
08:20:28 <benmachine> @hoogle MonadError
08:20:28 <lambdabot> No results found
08:20:47 * benmachine remembers he is supposed to be doing work and disappears
08:21:42 <theclaw> hi
08:22:27 <Twey> Say, with supercompilation, will the idea of converting all monads except Identity and IO into transformers become acceptably performant?
08:22:51 * Twey is looking forward to his nice composable transformer stack
08:22:58 <theclaw> I'm using a state monad to manage varbindings. for each type, I have an "accessor function", like in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17151#a17151. is there any way to write a general "getVar" function which takes the type as "a parameter"?
08:23:53 <Twey> theclaw: Sure, but you need values representing the types of your variables
08:24:36 <Berengal> You can't without dynamics
08:24:41 <theclaw> hmm
08:24:47 <theclaw> Berengal: dynamics?
08:25:35 <Berengal> I'd probably write one generic getter that takes a filter function :: VarType -> Maybe a, and define each spesific getter in terms of that
08:25:38 <theclaw> Twey: so it's not possible to use a algebraic data type?
08:26:13 <theclaw> Berengal: thanks, good idea
08:26:34 <Berengal> getVar :: (MonadState VarBindings m) => (VarType -> Maybe a) -> m (Maybe a)
08:26:41 <theclaw> yep
08:26:46 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17151#a17152 — doesn't perform the conversion, of course
08:27:14 <Twey> Wait…
08:27:17 <Twey> Ych.  Haha
08:27:30 <sbahra> cd
08:28:02 <Berengal> sbahra: dvd :)
08:29:17 <kowey> is sam hughes (keeper of the YAHT) around?
08:30:20 <Twey> Yeah, dynamics it is
08:36:16 <Saizan> you can use the gadts way like above to reduce some duplication :)
08:37:17 <monadic_kid> is there a version of State.modify that takes a monad instead?
08:37:44 <Saizan> you mean a monadic action?
08:37:58 <monadic_kid> yep
08:38:13 <theclaw> Saizan: hmm. I don't know anything about GADTs yet
08:38:17 <Saizan> no, but you can write one
08:38:25 <monadic_kid> oh well
08:38:34 <theclaw> Saizan: but what would be the advantage to Berengal's approach?
08:39:53 <Saizan> theclaw: not much, i was confronting it with the annotation in the hpaste
08:40:16 <theclaw> Saizan: oh, okay
08:42:45 <dino-> My wife had a job interview recently, a Java position. One of the interview questions was working on some code that modeled a tree where nodes were either operators with subtrees or values..
08:43:36 <dino-> So they gave some code, an interface and two implementing classes for the types of nodes, and then the task is writing the evaluation function.
08:43:57 <Saizan> (it's a bit sad that using a Map for an heap we can't enforce that references are valid by contruction, though you can do it by controlling the API)
08:44:09 <dino-> I didn't see the code, but it sounds like so much work with the classes and yada!
08:44:23 <merijn> dino-: It is, Java is painful like that
08:44:32 <dino-> This is what? data Tree a = Op (a -> a -> a) (Tree a) (Tree a) | Val a
08:44:39 <dino-> And a two line evalTree function.
08:44:52 <Saizan> hehe, yeah :)
08:44:59 <dino-> Unbelievable
08:45:22 <merijn> I'm taking a compiler construction course and ADTs are like perfect for ASTs
08:46:00 <kamatsu> merijn: true
08:46:02 <dino-> I asked, interview code wasn't using generics either. So that Haskell there has it beat that way as well.
08:46:09 <merijn> I might just reimplement the compiler we're working on in Haskell to expand on it. Judging by the looks of it now most of the work should be trivial to rewrite in haskell
08:46:32 <merijn> And its good practice for me to start writing non-trivial things :p
08:47:08 <kamatsu> merijn: compiler?
08:47:25 <Saizan> dino-: the only advantage of the OOP solution is that you can more easily add other kind of nodes later
08:47:40 <merijn> kamatsu: Yes?
08:47:48 <kamatsu> Saizan: could this not be accomplished with existential quantification etc etc?
08:48:11 <kamatsu> merijn: which language?
08:48:37 <Berengal> kamatsu: There are solutions, but they're considerably more ugly than the plain vanilla tree
08:48:47 <Berengal> (Not neccessarily more ugly than Java though)
08:48:49 <Saizan> kamatsu: well sure, but then you're back to the whole mess the OOP guys have to work with their ADTs :)
08:49:08 <ben> Nemerle hooks into .net and provides ADT-ish syntax that compiles to OOP
08:49:10 <ben> It is all kinds of crazy
08:49:28 <merijn> kamatsu: The prof is calling it "civilized c" its a subset of C with the addition of local functions and some other stuff like multi-dimensional arrays.
08:49:33 <Saizan> F# doesn't have ADTs ?
08:50:04 <pikhq> merijn: So... GNU C and C99, respectively?
08:50:04 <Saizan> kamatsu: err, i should have said ASTs above
08:50:11 <monadic_kid> yes, becaure with the abbrevation of ADT, abstract data type is the usual abbrev
08:50:16 <monadic_kid> *becareful
08:50:48 <merijn> pikhq: No, because they implement full C this is only a subset. Seeing how we have 8 weeks to do it in implementing all peculiarities of C is a doomed concept :p
08:51:11 <pikhq> merijn: So, the easy-to-implement subset.
08:51:17 <pikhq> I'll call that "K&R C".
08:51:18 <pikhq> :P
08:51:24 <merijn> Pretty much
08:51:44 <monadic_kid> .net vm doesn't have support for true unions so they map algebraic data types to classes with inheritance for the seperate cases
08:51:54 <merijn> The idea of the course (which I agree with) is that it's pointless to learn about compiler without implementing one.
08:52:00 <dino-> Is this kind of what happens with Scala too?
08:52:06 <ben> Great, nemerle website is offline.
08:52:13 <dino-> The, what do they call it..
08:52:17 <dino-> case classes
08:52:26 <Saizan> merijn: can you come to my university to explain that to my professors?
08:52:34 <Berengal> Scala has a weird ADT<->Object relationship
08:53:04 <merijn> Saizan: Sure, should I bring baseball bats? :p
08:53:26 <monadic_kid> data Foo = Bar | Dar == abstract class Foo {} sealed class Bar : Foo {} sealed class Dar : Foo {}
08:53:34 <monadic_kid> well for those platforms
08:53:34 <Saizan> it'd probably help :)
08:53:47 <merijn> Saizan: Actually, I'm doing the course at a different university since mine doesn't even have a compiler course. (Which is a shame as the CS department is otherwise pretty solid)
08:57:54 <merijn> On a slightly off-topic note, my new favorite description of programming is: "Programming is 10% science, 25% ingenuity and 65% getting the ingenuity to work with the science."
09:00:46 <ehird> It's part of Haskell's semantics that you cannot have a list whose length cannot fit into an Int, right?
09:01:03 <Zao> ehird: There's genericLength for those.
09:01:20 <ehird> Zao: Right, but is it actually consistent in Haskell to have a list whose length cannot fit into an Int?
09:01:22 <Polarina> Is there some simple way to send and receive UDP packets (IPv4 and IPv6)?
09:01:26 <Zao> ehird: The report claims that the choice of Int for length and friends is to avoid accidental performance hell.
09:01:30 <mauke> > repeat "yes"
09:01:32 <lambdabot>   ["yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","yes","y...
09:01:35 <Saizan> ehird: sure
09:01:40 <ehird> Okay.
09:01:44 <Zao> Most lists we deal with have lengths longer than maxBound :: Int :)
09:01:59 <pikhq> Mmm, infinite lists.
09:02:00 <ehird> Oh, I forgot Int is actually quite small.
09:02:01 <Polarina> > maxBound :: Integer
09:02:02 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
09:02:03 <lambdabot>    arising...
09:02:05 <ehird> > maxBound :: Int
09:02:06 <lambdabot>   9223372036854775807
09:02:10 <ehird> ...stupid 64-bit.
09:02:12 <ehird> > maxBound :: Int32
09:02:13 <lambdabot>   2147483647
09:02:18 <Polarina> ehird, 64-bit is not stupid!
09:02:19 <ehird> Yeah, that's not actually ridiculously big.
09:02:22 <ehird> Polarina: It is for my point.
09:02:35 <ben> > genericLength (repeat "yes")
09:02:36 <lambdabot>   * Exception: stack overflow
09:02:40 <ben> > genericLength (repeat "yes") -O2
09:02:41 <lambdabot>   Not in scope: data constructor `O2'
09:02:41 <ben> >:[
09:04:22 <Zao> ehird: 30 bits guaranteed, counting sign bit.
09:04:51 <ben> > 2^30
09:04:52 <lambdabot>   1073741824
09:05:04 <Berengal> > 2^29 - 1
09:05:05 <lambdabot>   536870911
09:13:12 <monadic_kid> can someone think a of cleaner way to do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17153#a17153
09:14:29 <ehird> No genericElemIndex
09:14:30 <ehird> ?
09:15:12 <Zao> @type genericIndex
09:15:13 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
09:15:21 <Zao> Oh.
09:15:45 <ehird> Zao: i no rite, i tried that too
09:15:53 <ehird> oh well
09:15:54 <ehird> i'll just use ints
09:18:29 <monadic_kid> anyone? more elegant way to do this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17153#a17153
09:20:13 <nolrai_FG> Hey is there a name for the varius parts of a let statement?
09:20:43 <nolrai_FG>  /is/are /a name/names
09:23:16 <Saizan> let <bindings> in <body> <- quite common
09:24:34 <monadic_kid> i don't think I gained anything with modify'
09:25:49 <Saizan> i think you want lenses or fclabels or data-accessor so it's easier for start to just work on a piece of the state
09:26:01 <Berengal> > let in "Hello"
09:26:02 <lambdabot>   "Hello"
09:29:33 <Saizan> so you can write something like "withFPS $ modify' (liftIO . start)"
09:34:32 <poisson> hi, is it normal that if i import a module qualified i can't export it like "module Main ( module SubModul ) where import qualified SubModule"?
09:35:25 <poisson> ghc sais Warning: The export item `module SubModul' exports nothing
09:35:34 <Saizan> missing an 'e'^
09:35:35 <Saizan> ?
09:35:59 <poisson> no thats not the problem thats a simplified example :)
09:36:15 <poisson> it works fine if i don't use qualified
09:37:21 <Saizan> well, that's just a warning
09:37:33 <Saizan> however, are you sure the SubModule is exporting something?
09:37:53 <Saizan> that's not already exported otherwise?
09:38:00 <poisson> yes
09:38:20 <poisson> because it works if i don't use qualified
09:39:02 <Lemmih> poisson: You can't export qualified modules.
09:39:17 <Saizan> you surely can't export them as qualified
09:39:33 <Saizan> can you export their contents when you import them qualified?
09:39:59 <poisson> that was what i wanted to do
09:40:03 <Lemmih> poisson: Say both SubModule and Main contains an identifier called 'x'. If another module references Main.x, which 'x' is it talking about?
09:40:44 <Lemmih> Saizan: You have to either enumerate them or import them unqualified.
09:42:03 <poisson> hmm but thats the same problem as importing normal unqualified stuff it could just give a compiling error in case of ambiguity
09:43:03 <Lemmih> If there's no ambiguity, there's no need to import it qualified.
09:44:34 <poisson> yeas but i mean if you export a qualified module it could just generat a compiling error if ambiguity occures there
09:46:36 <poisson> and if it is not allowed why is there only a warning and no error?
09:48:26 <poisson> well nothings perfect eh - anyway thanks for the info
09:54:08 <Lemmih> poisson: Hm, are you sure SubModule contains anything? Or that you aren't exporting what it contains by other means?
10:00:53 <poisson> try your self
10:00:58 <poisson> module Main (module SubModul) where
10:01:00 <poisson> import qualified SubModul
10:01:05 <poisson> in main
10:01:26 <poisson> module SubModul
10:01:28 <poisson> where
10:01:29 <poisson> a=1
10:01:45 <poisson> in submodul
10:02:20 <poisson> try with and without qualified
10:03:20 <MissPiggy> > 1+1
10:03:21 <lambdabot>   2
10:03:58 <tomberek> hi
10:05:11 <benmachine> @tell Cale you asked about this the other day: http://github.com/benmachine/stepeval I just fixed the most annoying outstanding bug on it, haven't really added any new features though, and have a busy week ahead. thanks for the interest :)
10:05:11 <lambdabot> Consider it noted.
10:05:43 <tomberek> what is more haskell-like.... have something's type bring with it the various functions applied to it by virtue of what typeclass it is an instance of, or store them in a record or be part of the data type
10:06:17 <benmachine> typeclasses are often better because sometimes the types can be resolved statically, which leads to more optimisation opportunities
10:06:25 <benmachine> I don't think that's as easy with records
10:06:36 <benmachine> records are more flexible for some things
10:07:04 <benmachine> I think typeclasses are more common
10:07:05 <tomberek> that's what i thought, though it seems like I am going down an OOP path with objects and inheritance, etc..
10:08:09 <Polarina> Is there some simple (preferably portable) way to send and receive UDP packets (IPv4 and IPv6)?
10:09:30 <benmachine> you can't do so on the same socket
10:09:34 <benmachine> I think
10:09:37 <tomberek> benmachine: i was going to have a graph , all the nodes of which do similiar (or same) things, but instead of storing a utility function for each, I was going to have the type keep that info, while they are all a part of a typeclass with common ways to evaluate the utility functions
10:10:02 <benmachine> tomberek: if typeclasses are powerful enough I'd do it with them
10:10:07 <Polarina> benmachine, I need to control source and destination ports. :)
10:10:35 <tomberek> so it would be a (Usable a) => Graph a ... or something like that,, while i have instances of Usable Little, Usable Big,,, etc..
10:11:45 <tomberek> benmachine, ok, thanks. I just wanted to make sure I'm not on the wrong track
10:12:03 <benmachine> tomberek: if you are then so am I
10:12:07 <benmachine> but that's not impossible :P
10:13:16 <benmachine> Polarina: I wrote this a while ago: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=6616#a6616 I think the only thing that'd change for IPv6 is the address tuple and AF_INET6 instead of AF_INET
10:13:20 <monadic_kid> typeclass with different existencial types support multimethods, you wouldn't get that so trivially with records of functions.
10:13:27 <Polarina> benmachine, thanks.
10:14:09 <tomberek> monadic_kid: can you elaborate?
10:14:32 <monadic_kid> you know what multimethods are right?
10:14:46 <tomberek> aye
10:15:05 <monadic_kid> you can do that with multi-param typeclassess
10:15:53 <monadic_kid> with existential types + muti-param typeclassess you get multimethods, dynamic dispatch on n-arguments
10:16:42 <monadic_kid> you don't really need to use existential types but if you're looking to emulate OO
10:16:58 <monadic_kid> multimethod OO
10:16:59 <Polarina> benmachine, why specify a size in recvFrom when it's a datagram? That doesn't make sense.
10:17:07 <tomberek> monadic_kid,,, ok, you lost me again.  I guess I don't see how existential types fit in
10:17:16 <benmachine> Polarina: I think you have to, for buffering reasons
10:17:45 <Polarina> But if the packet is bigger than the size?
10:18:03 <benmachine> then you'd call recvFrom multiple times to get the whole thing, I suppose
10:18:16 <Polarina> I wanted a datagram, not a streaming protocol. :(
10:18:16 <benmachine> the problem *then* is if the packet is *exactly* the size
10:18:30 <monadic_kid> tomberek: with existential types you can add new types like with classess
10:18:31 <benmachine> Polarina: have you done this in other languages?
10:18:38 <tomberek> oh! so i can do something like data MyGraph = forall a. (Usable a) => Graph a   ?
10:18:39 <Polarina> benmachine, not with UDP, no.
10:19:07 <benmachine> I think python makes you specify the length in advance too
10:19:15 <benmachine> not that that helps :P
10:19:17 <Polarina> This is weird.
10:19:21 <monadic_kid> tomberek: effectively, then you can have many data types that "implement" t he typeclass
10:19:21 <Polarina> And nonsensical.
10:19:25 <benmachine> doesn't your protocol define a maximum packet length?
10:19:58 <Polarina> I just want to receive anything that is sent to me, in whole.
10:20:11 <monadic_kid> tomberek: I saw this pattern being used in a super mario clone for various game objects
10:20:16 <tomberek> monadic_kid, ok, i think that's better than what I am doing now..... is that example above in the right direction?
10:20:26 <benmachine> Polarina: what if you were sent a packet that was bigger than your RAM? :P
10:20:45 <Polarina> benmachine, an IP packet cannot be that large.
10:21:02 <benmachine> true
10:21:11 <benmachine> but the syscall used to receive packets needs a length
10:21:26 <benmachine> so the only way to do it is to repeatedly receive
10:21:38 <Polarina> And why does it give back a String, unicode encapsulated?
10:21:42 <hotaru2k3> Polarina: then you do have a maximum packet size
10:21:46 <monadic_kid> tomberek: have a look at Actor.hs and the Actor directory: http://github.com/mokehehe/monao
10:21:47 <benmachine> because that's simplest
10:21:55 <mauke> Polarina: because it's stupid
10:21:56 <benmachine> I'm sure there's a bytestring way of doing it but I don't know what it is
10:22:17 <benmachine> you asked for simple you got simple :P
10:22:23 <Polarina> String is not simple.
10:22:25 <Polarina> ByteString is.
10:22:28 <mauke> bytestring is simpler than String
10:22:35 <benmachine> if you say so
10:22:52 <benmachine> but you have a different set of criteria for simplicity than I do
10:23:14 <Polarina> I could use FFI and do a syscall on my own, but then I don't know how to make it work on windows.
10:23:38 <benmachine> how would that be better?
10:23:41 <mauke> http://hackage.haskell.org/package/network-bytestring
10:23:46 <Polarina> benmachine, ByteString.
10:23:51 <benmachine> oh
10:23:52 <tomberek> monadic_kid: ok... so you can have different actors (or types of actors), but treat them all the same, and use all the same functions assigned to them via the typeclass Actor?
10:23:56 <benmachine> listen to mauke, then :P
10:24:06 <Polarina> mauke, I'll take a lokk. :)
10:24:12 <Polarina> look*
10:24:39 <monadic_kid> tomberek: yep but there is no multimethods in that example from what I can see
10:24:55 <tomberek> ok... i think i am understanding
10:25:20 <monadic_kid> tomberek: what you came up with is pretty much the same
10:25:46 <tomberek> monadic_kid: thanks for the help... see ya later
10:26:14 <monadic_kid> some people are calling it an anti-pattern though recently
10:26:35 <monadic_kid> but I don't know if it is for this use-case though
10:28:20 <Polarina> :t (->)
10:28:21 <lambdabot> parse error on input `->'
10:28:23 <Polarina> :(
10:28:49 <monadic_kid> :t (->) e
10:28:50 <lambdabot> parse error on input `->'
10:29:00 <monadic_kid> :k (->) e
10:29:01 <lambdabot> Not in scope: type variable `e'
10:29:08 <monadic_kid> :k ((->) e)
10:29:09 <lambdabot> Not in scope: type variable `e'
10:29:14 <monadic_kid> :k (->)
10:29:15 <lambdabot> ?? -> ? -> *
10:34:13 <lpsmith> http://hackage.haskell.org/packages/archive/data-ordlist/0.0.1/doc/html/Data-OrdList.html#v%3AinsertSet
10:34:31 <Polarina> benmachine, I found out what happens if the packet is larger than the size specified.
10:34:38 <Polarina> benmachine, the extra bytes are discarded!
10:35:16 <lpsmith> Somebody pointed out to me that my implementation was incorrect;  I flipped the LT and GT cases and produced reversed lists
10:35:41 <lpsmith> But here's my question
10:36:01 <Berengal> Polarina: This is the cost of not letting the protocol handle the transmissions for you; you need a robust protocol in application space
10:36:25 <Polarina> Berengal, I just wanted to know, to be certain, not to remain in doubt and uncertainity.
10:36:30 <Polarina> Handling UDP will be easy. :)
10:38:14 <lpsmith> http://hackage.haskell.org/packages/archive/data-ordlist/0.0.1/doc/html/src/Data-OrdList.html#insertSetBy
10:38:51 <lpsmith> Should that be EQ -> y:ys,   as it is now,  or EQ -> x:ys,  as my bug-reporter thinks it should be?
10:38:59 <b0fh_ua> Hi there! I have created some simple program in Haskell, which takes Bugzilla XML feed with bug list and extracts issue assignee and issue title from that XML. I used TagSoup to convert XML file intolist of tags. Can somebody please criticize the code at http://pastebin.com/d5fe22ba ?
10:43:11 <Gracenotes> hm... entering \bot into LaTeX-mode scim gives me ⊤
10:43:37 <Gracenotes> but entering \top gives me τop :|
10:43:37 <b0fh_ua> did i miss something when was dropped off the network?
10:43:48 <Lycurgus> no
10:43:50 <Gracenotes> do not think so
10:43:56 <b0fh_ua> ok )
10:44:25 <Berengal> b0fh_ua: dropTagsUntil f is just drop 1 . dropWhile f
10:45:03 <ddarius> Gracenotes: Yeah, the table is screwy.
10:45:12 <b0fh_ua> Berengal: ok, really, thanks
10:45:42 <gwern> anyone know whether there is a more up to date reverse hackage dep than say http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/filestore-0.3.4.1#direct ?
10:45:55 <Berengal> And it it's not "until", it's while. Until implies the function should drop while false, but while implies drop while true
10:46:00 <Gracenotes> hm, ⊢ (\vdash) works as expected
10:48:59 <Gracenotes> oh, greeaat. The upgrade command has been disabled for cabal. "Below is the list of packages that it would have tried to upgrade." <29 packages>  :(
10:49:04 <b0fh_ua> Berengal: true, good point
10:50:36 <pokoko222> anyone has any idea what prototype based programming is? i did not understand wiki. it is says it is oop but without classes... any noob explanations?
10:50:37 <b0fh_ua> Berengal: one of biggest problenms with the code is the fact I have to carry those (Issue, TagStrs) around
10:50:54 <Gracenotes> well, haskell does not have it
10:50:59 <b0fh_ua> I think it's better to put the current list of tags into state
10:51:11 <b0fh_ua> just have no idea of how to do so for now :)
10:51:19 <Gracenotes> arguably best way to learn about prototype based programming is to learn a language with it, like Self or JavaScript
10:52:02 <c_wraith> javascript accepted practice is to avoid thinking about the consequences of having prototypes in every opportunity.  Better to learn Self, which embraces it.
10:52:20 <pokoko222> yes JavaScript but i do exam in two days and i have no idea what prototype programming is, can u give me simple example i will understand
10:52:20 <Berengal> Gracenotes: cabal upgrade 2>&1 | tail -n+8 | xargs cabal install --reinstall
10:53:02 <Gracenotes> heh, the thought occurred to me. But now there's this great danger of screwing up dependencies or something, and I am at risk (!)
10:53:04 <c_wraith> berengal, that's truly frightening.
10:53:45 <c_wraith> Yeah, doing that would probably result in a bunch of errors with newer versions of packages that won't work with your version of ghc.  Unless you're actually on 6.12
10:54:06 <Berengal> I'm on 6.12, and I get an error saying curl requires base < 3...
10:54:12 <Berengal> curl doesn't even show up in the list
10:54:28 <c_wraith> It's reinstalling dependencies, I guess.
10:55:35 <Gracenotes> do we have to wait a year for a new dependency calculus, or something? >.>
10:55:49 <Berengal> The upgrade command's been disabled forever
10:56:20 <Gracenotes> I think I just haven't updated cabal til now
10:56:35 <c_wraith> my viewpoint is: use cabal to install versions of things that will work with what you have.  install newer versions of something only when you absolutely need to.  Never try to upgrade something just because it's newer.
10:56:42 <Gracenotes> previously, --version -> cabal-install version 0.6.2 using version 1.6.0.3 of the Cabal library
10:57:59 <Berengal> Exceptions don't work well with continuations...
10:58:17 * Berengal ponders implementing his own exceptions
11:00:02 <lpsmith> So nobody has an opinion on EQ -> y:ys versus EQ x:ys ?
11:03:47 <Gracenotes> well, are x and y equal? :)
11:04:56 <lpsmith> well, yeah :)
11:05:12 <c_wraith> can you use GADTs to build okasaki's polymorphic recursive data types?
11:05:46 <lpsmith> Gracenotes,  But somebody might be giving a compare function that makes the type (conceptually) a quotient type,  and then you might care about the difference
11:05:56 <lpsmith> I suppose,  I'm not sure
11:06:57 <Gracenotes> well, there is the Eq a => Ord a constraint
11:07:34 <Saizan> lpsmith: i'd use the latter
11:07:49 <Saizan> mh, no
11:08:13 <lpsmith> Saizan, any particular reason,  or just your gut feeling?
11:08:21 <Saizan> i'd say in the documentation that the implementation is free to choose one or the other :)
11:10:30 <Gracenotes> in the former you can keep the cons cell.. if you're up for rebinding another name -.-
11:13:09 <Saizan> however i think it's more useful in general to update the value with the new one, if you feel like making such promises
11:14:49 <lpsmith> ok,  that more or less follows my thinking,  I guess.    One other thing,  do people have an opinion on Data.OrdList versus Data.List.Ordered?
11:15:12 <Gracenotes> ah. don't make it be used for highly specific behavior with an invalid operator, like groupBy is used for
11:15:23 <Gracenotes> you mean. well, that is still unavoidable.
11:16:04 <nolrai_FG> I accedently deleted my .cabal folder and now cant compile cabal or much of anything, and don't have administrator priviliges what should I do?
11:16:44 <Saizan> nolrai_FG: delete your .ghc too and start from cabal-install's tarball
11:17:00 <nolrai_FG> Thanks!
11:17:10 <Saizan> lpsmith: the latter is nicer, it's a bit lengthy but not too much
11:18:21 <nolrai_FG> Looks like its working!
11:18:29 <c_wraith> hmm
11:18:31 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17162#a17162
11:18:36 <Saizan> well, actually, if you still have the cabal binary it should still work.. right :)
11:19:03 <c_wraith> I don't like the suggestion that gives
11:19:14 <c_wraith> Is there any other way to solve the problem?
11:19:18 <gwern> I am making an account for  Maurice Googol
11:19:19 <gwern> what
11:19:32 <gwern> he is emailing me from a yahoo account
11:19:33 <gwern> lolwhat
11:20:06 <Saizan> c_wraith: Show (a,a) doesn't imply Show a, so i'd say there's no way except for making two distinct Show instances
11:20:31 <c_wraith> Saizan: That might work for me
11:21:12 <nolrai_FG> What does the :: a -> Seq (a,a) constuctor actualy do?
11:21:16 <Saizan> the two constructors overlap though
11:21:32 <c_wraith> nolrai_FG: I have no clue.  I'm working with a data type from Okasaki's thesis.
11:21:45 <c_wraith> nolrai_FG: I'll figure out the purpose of it as I go further into the paper. :)
11:21:58 <c_wraith> yeah, I'd need overlapping instances.
11:23:18 <hatds> If I have data Tree = Leaf a | Branch Tree Tree | MultiBranch [Tree],  then the last two constructors are redundant.  Should I prefer one over the other?
11:23:35 <kmc> the second, it's more general
11:23:44 <Saizan> you can write instance Show (Seq a) where show Empty = "Empty"; show (Seq _) = "Seq" ++ " _"; instance Show a => Show (Seq (a,a)) where show Empty = "Empty"; show (Seq x) = "Seq " ++ show x
11:23:46 <sshc> http://pastebin.com/f40b3b7a0
11:23:54 <Saizan> but that's not really satisfactory, i'd think
11:23:55 <sshc> why is GHCi complaining that foobar is not in scope?
11:23:57 <kmc> unless in your application you care about the difference between a "Branch" and a "MultiBranch" that happens to have two children
11:24:11 <hatds> no I don't care
11:24:33 <mreh> can I `par` something and force it to be evaluated?
11:24:34 <hatds> but it wouldn't affect anything if I handled multibranches with chained branches either
11:25:01 <nolrai_FG> hatds: whats the semantics?
11:25:04 <c_wraith> hehe.  If I need to use IncoherentInstances, it's not satisfactory, no
11:25:14 <Saizan> sshc: paste the real code
11:25:31 <nolrai_FG> sshc: to hpaste not here.
11:25:45 <Saizan> sshc: IOW foobar is in scope in that snippet
11:26:18 <hatds> nolrai_FG: e.g. replace a MultiBranch [x1,x2,x3] with Branch x1 (Branch x2 (Branch x3)), so to speak
11:26:24 <sshc> IOW?
11:26:28 <benmachine> in other words
11:27:24 <nolrai_FG> hatds: so the depth doesn't matter?
11:27:30 <c_wraith> Oh.  maybe I should re-read the data definition, remember a bit more about how ML works, and realize I've implemented this all wrong
11:27:35 <mreh> @src parList
11:27:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:28:03 <Saizan> c_wraith: heh, data constuctors in ML are uncurried
11:28:13 <hatds> hatds: no, only the descendant relationships matter
11:28:20 <hatds> er nolari_FG :)
11:28:44 <c_wraith> Saizan: I don't think I even need GADTs for the data type in question
11:29:02 <nolrai_FG> Should I upgrade to the newist cabal? last time I did that it broke..
11:29:03 <sshc> Saizan: if you change the names, that's exactly how the real code is
11:29:07 <Saizan> hatds: i'd stick to MultiBranch
11:29:08 <sshc> Saizan: indentation et al
11:29:16 <moshisushi> i get "Not in scope: Data constructor Postfix" when trying to run some code that uses parsec
11:29:28 <seanmcl> is it possible to use do notation with a "monomorphic monad".  E.g. data A = A | B Int   I'd like to be able to say do { x <- a1 ; y<- a2 ; return a1+a2 } where if either is A it returns A and if both are B it returns the sum.
11:29:38 <sshc> Saizan: a portion of it, though
11:29:43 <moshisushi> am i using wrong version of parsec or something?
11:29:46 <hatds> Saizan: is there a good reason to prefer one over the other?
11:29:47 <moshisushi> got latest from hackage
11:29:53 <gwern> @quote pika
11:29:53 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
11:29:54 <sshc> Saizan: I don't understand how anything else can affect that
11:30:17 <gwern> hands up, is that quote worth keeping?
11:30:19 <Saizan> sshc: something got lost in the translation :)
11:30:45 <benmachine> sshc: if you don't understand it, maybe we will :P so a paste *exactly* of the region/file would be good
11:31:18 <Saizan> ?hoogle Postfix
11:31:18 <lambdabot> Text.Parsec.Expr Postfix :: ParsecT s u m (a -> a) -> Operator s u m a
11:31:23 <mreh> gridObjective' arr (m,n) (x1:x2:xs)    h =
11:31:23 <mreh>   let dist = (arr `unsafeAt` (((x1-1)*(m*n))+x2-1))
11:31:23 <mreh>       rest = gridObjective' arr (m,n) (x2:xs) h
11:31:23 <mreh>   in rest `par` (dist `seq` dist + rest)
11:31:30 <Saizan> moshisushi: cabal install "parsec >= 3"
11:31:43 <hatds> seanmcl: sounds like you don't need do notation if you define (+) :: A -> A -> A
11:31:43 <mreh> I can't get this run concurrently
11:32:11 <mreh> It's compiled with -threaded and run with +RTS -N2
11:32:25 <gwern> @quote chu
11:32:26 <lambdabot> OlegFacts says: Oleg's first datatype in haskell started like this: data ChuckNorris ...
11:32:37 <Saizan> mreh: you probably have to add an evaluation strategy like rnf to rest
11:32:43 <moshisushi> Saizan: hmm ok
11:33:43 <seanmcl> hatds: thanks
11:34:01 <copumpkin> @quote lolcat
11:34:01 <lambdabot> tensorpudding says: lolcategory demands moarphisms
11:34:07 <mreh> Saizan: this is all graph reduction isn't it?
11:34:10 <c_wraith> yeah.  GADTs aren't even necessary to do what okasaki does.  Haskell's type system isn't as restrictive as ML's, so it just works in Haskell
11:34:29 <pokoko222> any network guys here? I am learning networks, i need someone to talk to. i have read a lot, so it would be cool to talk about it :)
11:34:41 <Saizan> mreh: ehm, so?
11:34:55 <mreh> Saizan: I skipped those classes :)
11:35:07 <Saizan> mreh: heh
11:35:15 <kmc> pokoko222 = HaskellLove
11:35:25 <pokoko222> kmc so what
11:35:41 <Saizan> mreh: there are nice papers by Simon Marlow or blog posts by dons on taking advantage of `par` and friends
11:35:45 <gwern> @quote kachu
11:35:45 <lambdabot> gwern says: J'accuse tu, Pikachu!
11:35:51 <gwern> @quote accuse
11:35:51 <lambdabot> gwern says: J'accuse tu, Pikachu!
11:36:03 <gwern> people. you need to use the word 'accuse' more often. it is funny
11:36:14 <benmachine> *toi, surely
11:36:15 <Saizan> mreh: what's the type of rest, btw?
11:36:35 <mreh> Saizan: Double
11:36:48 <mreh> that has an instance of NFData
11:37:02 <Saizan> mreh: ah, then there shouldn't be a reason to use rnf afterall
11:37:13 <c_wraith> Oh, hmm.  Haskell's type system can't infer the type of the function, though.  It needs to be told.  Interesting
11:37:28 <gwern> benmachine: gol durn it, are you an illiterate ape? can you not appreciate how toi is right in all the wrong ways?
11:37:31 <Saizan> mreh: though i think you've to use "(rest `par` dist) `pseq` dist + rest"
11:38:07 <Saizan> mreh: rnf is needed only when you've a value that's made of many subparts that can remain thunks even when the outermost constructor is evaluated
11:38:22 <benmachine> gwern: totally illiterate
11:38:26 <Saizan> mreh: like lists, trees, etc..
11:38:30 <benmachine> (also, point taken, sry)
11:38:39 <mreh> Saizan: okay, thanks
11:39:08 <Saizan> c_wraith: polymorphic recursion?
11:39:15 <c_wraith> Saizan: yes
11:39:51 <moshisushi> Saizan: i need parsec in order to install cabal...
11:40:02 <c_wraith> Saizan: I don't see why it can't infer that, offhand.  Got a link to anything about the subject?
11:40:23 <moshisushi> Saizan: hen & egg problem over here :)
11:40:45 <benmachine> you don't need cabal to install parsec, it just makes it a whole lot easier
11:40:54 <benmachine> or hmm
11:40:55 <benmachine> you might do
11:41:02 <benmachine> this is what bootstrap packages are for
11:41:25 <Saizan> moshisushi: you shouldn't need parsec-3 to install cabal-install
11:41:40 <moshisushi> Saizan: cabal-install says i need parsec
11:41:45 <benmachine> use parsec 2
11:41:47 <moshisushi> the bootstrap
11:41:50 <Saizan> yeah
11:41:51 <moshisushi> uh okok
11:41:57 <nolrai_FG> is (Stream.listToStream [1..] :: Stream Int) the best way to generate a steam of the positive integers?
11:42:08 <Saizan> moshisushi: well, you can install parsec-3 directly
11:42:21 <benmachine> Saizan: wouldn't runhaskell etc. require cabal anyway?
11:42:23 <ben> @pl \(a, b) -> a >>= \a' -> b >>= \b' -> return (a', b'))
11:42:24 <lambdabot> (line 1, column 53):
11:42:24 <lambdabot> unexpected ")"
11:42:24 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
11:42:38 <Saizan> moshisushi: download the tarball and use the runghc Setup configure --user; runghc Setup build; runghc Setup install
11:42:44 <ben> @pl \(a, b) -> a >>= (\a' -> b >>= (\b' -> return (a', b')))
11:42:44 <lambdabot> uncurry (liftM2 (,))
11:42:47 <ben> :/
11:42:50 <Saizan> benmachine: it requires only Cabal the library
11:42:56 <benmachine> hmm
11:43:00 <Saizan> benmachine: which comes with any ghc
11:43:05 <benmachine> oh, fair enough
11:43:55 <Yoshibloke> May sound like a trivial question but how do I define a function so that it's default use is infix? Without having to use ``
11:44:09 <ben> Yoshibloke: Use a name that looks like an operator
11:44:11 <benmachine> use only punctuation in the name
11:44:20 <benmachine> (and don't start with a colon)
11:44:21 <Yoshibloke> Hmm, no other way?
11:44:24 <ben> no
11:44:32 <Yoshibloke> ok
11:44:45 <benmachine> the parser has got to be able to tell whether a function is infix or prefix just by looking at it
11:44:47 <Yoshibloke> a shame. I was trying to define something like python's "in"
11:44:49 <benmachine> otherwise it'd be a nightmare :P
11:44:58 <Yoshibloke> k
11:44:58 <Saizan> c_wraith: well, the problem is that in the natural algorithm while typing the body of a recursive definition, the type you've in scope for the function has not been generalized yet (since we didn't collect all the constraint yet) so you can't use it polymorphically
11:45:00 <gwern> @wn suicided
11:45:02 <lambdabot> No match for "suicided".
11:45:03 <monochrom> I don't understand why there is so much agony in installing things. On Windows and some Macs, just use Haskell Platform. On others, just grab ghc 6.10.4 binary, then build Haskell Platform from source, takes just 10 minutes.
11:45:03 <benmachine> yeah, just use `` in that case
11:45:04 <gwern> @wn suicide
11:45:05 <lambdabot> *** "suicide" wn "WordNet (r) 2.0"
11:45:05 <lambdabot> suicide
11:45:05 <lambdabot>      n 1: the act of killing yourself; "it is a crime to commit
11:45:05 <lambdabot>           suicide" [syn: {self-destruction}, {self-annihilation}]
11:45:05 <lambdabot>      2: a person who kills himself intentionally [syn: {felo-de-se}]
11:45:09 <Saizan> c_wraith: it seems you can be cleverer than that though
11:45:13 <gwern> hm. is there no verb of suicide?
11:45:31 <benmachine> gwern: nouns can be verbed etc.
11:45:44 <ben> Is my intuition correct that parsing a hierarchical file format with significant indentation/whitespace is nontrivial with parsec?
11:45:53 <gwern> that ispell flags suicided tells me it may be a nonstandard usage
11:45:59 <monochrom> And oh, completely stubbornly refuse to upgrade cabal-install when it "reminds" you to.
11:46:18 <benmachine> ben: at a guess I'd say it might be easier than you think
11:46:26 <benmachine> but often things are harder than I think they're going to be :P
11:46:28 <sshc> cabal: cannot configure base-4.2.0.0. It requires integer-simple -any
11:46:28 <sshc> There is no available version of integer-simple that satisfies -any
11:46:39 <ben> hm :I
11:46:43 <kmc> ben, err yes but "trivial" is a very low bar
11:46:56 <moshisushi> Saizan: sorry to bother you again, but now cabal-install says it can't parse the output of ghc-pkg dump
11:46:59 <c_wraith> Saizan: hmm.  guess I don't know enough about the type inference engine
11:47:06 <kmc> ben, i have parsed Haskell-like layout with parsec
11:47:10 <kmc> and can share my strategy
11:47:21 <Saizan> moshisushi: it seems you've an old cabal-install there
11:47:35 <ben> As far as I can tell, I am going to have to keep track of the current indentation level in some sort of passed-along state and manually check for that and call fail
11:47:45 <benmachine> sshc: I don't think you should upgrade base with cabal
11:48:02 <sshc> why not?
11:48:02 <c_wraith> you can't upgrade base with cabal
11:48:05 <sshc> how do I, then?
11:48:08 <kmc> ben, "fail" is bad, maybe call parsec's "unexpected"
11:48:08 <benmachine> you generally upgrade base by upgrading GHC
11:48:08 <Saizan> moshisushi: however by looking better at it, it seems Postfix comes from parsec2 too http://hackage.haskell.org/packages/archive/parsec/2.1.0.1/doc/html/Text-ParserCombinators-Parsec-Expr.html
11:48:15 <sshc> oh
11:48:31 <ben> I guess
11:48:36 <Saizan> moshisushi: not sure if you've one installed though
11:48:49 <benmachine> kmc: for parsec, they are the same, aren't they?
11:48:53 <Saizan> moshisushi: which ghc are you using, and which version of cabal-install did you install?
11:48:53 <kmc> probably
11:48:57 <kmc> ben, what i did was three steps: 1) lexing into tokens with position information, 2) insertion of delimiter tokens according to position info, 3) parsing of token stream
11:49:03 <kmc> where (1) and (3) were accomplished with Parsec
11:49:04 <sshc> is 6.10.4 the latest?
11:49:16 <kmc> and (2) a self-contained function modeled closely after the one in the Haskell Report
11:49:36 <benmachine> sshc: no, but some people do not recommend upgrading to 6.12
11:49:37 <ben> I thought about doing something like that. I never used parsec on things that are not strings before.
11:49:43 <kmc> it's not too bad
11:49:51 <benmachine> sshc: because the Haskell Platform is still in 6.10.4, for example
11:50:13 <benmachine> (personally I like 6.12, but that's just me)
11:50:19 <sshc> 6.12 is out now?
11:50:24 <sshc> why shouldn't I swich to it?
11:50:24 <kmc> GHC 6.12.1 is out
11:50:29 <kmc> there is no Haskell Platform for it
11:50:34 <kmc> many libraries still do not build on 6.12.1
11:50:46 <sshc> what are the changes?
11:50:56 <kmc> google it
11:51:02 <benmachine> I tried to actually
11:51:09 <kmc> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/release-6-12-1.html
11:51:10 <ksf> sshc, don't ask, install
11:51:10 <benmachine> I don't think I ever found a comprehensive list
11:51:13 <ksf> we need testers
11:51:34 <benmachine> okay I suck at googling, is the obvious conclusion
11:51:44 <benmachine> no I did find that
11:51:46 <benmachine> and then forgot about it
11:52:13 <sshc> I would like to know the changes since 6.10.4
11:52:15 <Saizan> benmachine: forgetting is great
11:52:22 <kmc> the short list is: improved parallelism and concurrency, thread profiling, dynamic libraries, Unicode IO
11:52:28 <benmachine> Saizan: I know right
11:52:33 <sshc> which versions are between 6.10.4 and 6.12.1?
11:52:38 <kmc> sshc, none
11:52:52 <benmachine> 6.<odd> are not release versions
11:52:58 <Saizan> TupleSections!!11!oneone!!
11:53:12 <benmachine> I think DeriveFunctor is pretty neat
11:53:16 <c_wraith> yes, tuplesections
11:53:22 <monochrom> Just read the release notes url.
11:53:26 <sshc> apparently, 6.12.1 is not in Debian unstable yet
11:53:33 <c_wraith> I can quit writing "flip (,) a"
11:53:42 <sshc> can cabal install GHC?
11:53:45 <benmachine> no
11:53:56 <gwern> oh brokeback platform. I wish I could quit you
11:54:11 <benmachine> that would mean compiling GHC which takes aaaaages
11:54:14 <benmachine> get a binary
11:54:43 <sshc> is there a debian package for it?
11:54:52 * benmachine shrug
11:54:56 <c_wraith> @pl \x -> x / 2
11:54:56 <lambdabot> (/ 2)
11:54:57 <kmc> try google on that too
11:55:05 <sshc> it's in experimental
11:55:07 <c_wraith> @pl \x -> (x, )2
11:55:07 <lambdabot> (line 1, column 9):
11:55:08 <lambdabot> unexpected ","
11:55:08 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
11:55:12 <c_wraith> @pl \x -> (x, 2)
11:55:12 <lambdabot> flip (,) 2
11:55:26 <c_wraith> horrible stupid asymmetry
11:55:40 <benmachine> asymmetry isn't really that surprising :P
11:56:00 <c_wraith> Well, 6.12 includes the extension that allows those two cases to be symmetric
11:56:07 <kmc> is there any point to using irrefutable patterns in "let"?
11:56:23 <benmachine> kmc: as a subpattern, perhaps
11:56:38 <monochrom> to make funny emoticons
11:57:05 <benmachine> but I don't think there's any point in let ~p for any p
11:57:17 <kmc> what would be a pointful case with a subpattern?
11:57:25 <benmachine> eerm
11:57:27 <ddarius> kmc: Only for nested matches.
11:57:42 <monochrom> let Just (~(x:xs)) = Just [] in haha
11:57:44 <ddarius> let ~p = ... is equivalent to let p = ...
11:57:50 <sshc> oh, GHC never supported linking with .so's and .dll's before the newest release?
11:58:00 <sshc> how would you write that in haskell, anyway?
11:58:04 <kmc> > let Just (~(x:xs)) = Just [] in ()
11:58:04 <lambdabot>   ()
11:58:08 <kmc> > let Just (x:xs) = Just [] in ()
11:58:09 <lambdabot>   ()
11:58:21 <monochrom> Oh of course, try asking for x.
11:58:28 <kmc> > let Just (~(x:xs)) = Just [] in x
11:58:29 <lambdabot>   * Exception: <interactive>:1:137-160: Irrefutable pattern failed for patter...
11:58:31 <kmc> > let Just (x:xs) = Just [] in x
11:58:31 <lambdabot>   * Exception: <interactive>:1:137-157: Irrefutable pattern failed for patter...
11:58:33 <benmachine> > let (x:xs@~(y:ys)) = [1] in x
11:58:34 <lambdabot>   <no location info>: Parse error in pattern
11:58:38 * benmachine melts
11:58:43 <benmachine> > let (x:xs@(~(y:ys))) = [1] in x
11:58:44 <lambdabot>   1
11:58:49 <benmachine> > let (x:xs@(~(y:ys))) = [1] in y
11:58:50 <lambdabot>   * Exception: <interactive>:1:141-162: Irrefutable pattern failed for patter...
11:58:56 <benmachine> that's fairly contrived
11:59:06 <kmc> sshc, right, system C libraries could be dynamically linked, but not other Haskell libraries
11:59:09 <benmachine> but irrefutable patterns are quite rare in any case
11:59:16 <kmc> yeah, i don't think i've ever used one
11:59:27 <kmc> they make sense in "case"
11:59:45 <monochrom> Less contrived: let (x,~[]) = (0, blahblah) in ...
11:59:49 <sshc> kmc: will the newest GHC support dynamically linking with any library?
11:59:59 <hatds> why'd it say matching failed for y?
12:00:12 <kmc> i believe GHC 6.12.1 supports dynamically linking Haskell libraries into your Haskell code
12:00:40 <sshc> is the only thing irrefutable pattern matching does is error out when a pattern match fails?
12:00:41 <hatds> oh... is xs bound to (y:ys)?
12:00:59 <benmachine> monochrom: how is that different from let (x, _) = (0, blahblah)
12:01:06 <hatds> > let ((x:x)s@(~(y:ys))) = [1] in y
12:01:06 <lambdabot>   <no location info>: Parse error in pattern
12:01:12 <hatds> > let ((x:xs)@(~(y:ys))) = [1] in y
12:01:12 <lambdabot>   <no location info>: parse error on input `@'
12:01:17 <kmc> sshc, an irrefutable match always succeeds, and does no evaluation
12:01:23 <monochrom> No different.
12:01:30 <benmachine> hatds: @ is tightly-binding
12:01:31 <kmc> if one of its binders is evaluated, then the match is actually performed and the error may be thrown
12:01:40 <benmachine> monochrom: still pretty contrived then :P
12:01:44 <hatds> yea I see
12:01:49 <kmc> > case [] of (x:xs) -> "match"; _ -> "no match"
12:01:50 <lambdabot>   "no match"
12:01:51 <kmc> > case [] of ~(x:xs) -> "match"; _ -> "no match"
12:01:52 <lambdabot>   "match"
12:01:56 <kmc> > case [] of ~(x:xs) -> "match: " ++ x; _ -> "no match"
12:01:57 <lambdabot>   "match: * Exception: <interactive>:1:133-185: Irrefutable pattern failed fo...
12:02:03 <kmc> sshc, ^^^^
12:02:04 <monochrom> I don't know, is my example bad or is your generalization skill bad?
12:02:23 <benmachine> monochrom: possibly both?
12:02:29 <HugoDaniel> hi
12:02:34 <lpsmith> ok,  if I want to merge two darcs patches into one,  is there an easy way to do that?
12:02:34 <sshc> kmc: how can that possibly be helpful?
12:02:34 <HugoDaniel> is there soap support in haskell ?
12:02:36 <monochrom> let (x,~(y:ys)) = (0, undefined) in if b then x else y
12:02:38 <HugoDaniel> or bindings to csoap ?
12:02:41 <kmc> sshc, very rarely
12:02:44 <benmachine> okay fine
12:02:55 <kmc> sshc, the same ways fromJust is helpful perhaps
12:03:01 <benmachine> I still think that's a little contrived but I can imagine it maybe not being sometimes
12:03:14 <benmachine> > let (x, y:ys) = (0, []) in x
12:03:16 <lambdabot>   * Exception: <interactive>:1:141-159: Irrefutable pattern failed for patter...
12:03:18 <kmc> > let fromJust x = case x of ~(Just y) -> y in fromJust (Just 3)
12:03:19 <lambdabot>   3
12:03:24 <kmc> this is a very convoluted way to write fromJust of course
12:03:33 <benmachine> kmc: works without the ~ too :p
12:03:58 <kmc> benmachine, does that change the laziness?
12:04:13 <benmachine> kmc: if you need to get the y out you need to force it in any case
12:04:52 <benmachine> fromJust undefined will undefined
12:05:20 <sshc> > fromJust undefined
12:05:21 <lambdabot>   * Exception: Prelude.undefined
12:05:28 <sshc> > fix undefined
12:05:29 <lambdabot>   * Exception: Prelude.undefined
12:05:32 <sshc> > fix error
12:05:33 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:05:40 <benmachine> fromJust (Just undefined) probably behaves the same regardless of the ~
12:06:01 <sshc> @quote sshc work
12:06:02 <lambdabot> sshc says: that worked well!
12:06:03 <benmachine> yeah, there's no way that pattern can be lazy
12:06:14 <sshc> I think I've overdone that.
12:06:57 <monadic_kid> Saizan: you there?
12:08:24 <Saizan> monadic_kid: yup
12:10:40 <monadic_kid> Saizan: do you remember earlier on, about "withFPS $ modify' (liftIO . start)", just trying to figure out how to write withFPS function, I think what is suppose to happen is I'm transforming the state monad of the record into state monad one of it's members and then give into the action?
12:10:59 <vyom> how do I  load files with #if..#else..#endif directives in ghci.. ? Like this one : http://github.com/jgm/yst/blob/master/yst.hs
12:12:08 <Saizan> monadic_kid: you could make it "withFPS :: MonadState YourState m => StateT Timer IO a -> m a" for example
12:12:47 <ben> @pl \(a, b) -> a >>= (\a' -> b >>= (\b' -> return (f a', f b')))
12:12:48 <lambdabot> uncurry (liftM2 ((. f) . (,) . f))
12:13:55 <Zao> vyom: I seem to get slightly farther if I run ghci -cpp
12:14:49 * hackagebot upload: texmath 0.2 - Conversion of LaTeX math formulas to MathML. (JohnMacFarlane)
12:16:09 <Saizan> monadic_kid: err, add a MonadIO m to the context there :)
12:19:07 <vyom> Zao: I tried using the .o files generated after compilation but they do not work too.. the only other alternative i can think of is to write some driver code
12:19:20 <alise> Peaker: I partly take back my branding of AST editing as sucky
12:23:28 <Saizan> vyom: i've some very hacky code tested only on ghc-6.12
12:23:57 <bt>  foldr f z []     = z
12:24:01 <bt>  foldr f z (x:xs) = f x (foldr f z xs
12:24:10 <bt> input for example fold  (+) [1,2,3]
12:24:30 <vyom> Saizan:  you mean to load files with preprocessor directives in ghci.. ? I have ghci-6.12 here
12:24:36 <bt> i assume f = (+), (x:xs) = [1,2,3] , but what about z ?
12:24:51 <kw317> 0?
12:24:52 <mauke> foldr (+) 0 [1,2,3]
12:25:15 <kw317> depends on what you want
12:25:19 <mauke> [1,2,3] is syntactic sugar for 1 : (2 : (3 : []))
12:25:33 <bt> from where comes the zero?
12:25:41 <Saizan> vyom: yeah, basically i fetch the options from the .cabal file
12:25:53 <Saizan> vyom: it assumes you've configured with cabal first
12:26:33 <Saizan> vyom:  http://code.haskell.org/~Saizan/ghci-utils-0.1.tar.gz http://code.haskell.org/~Saizan/.ghci
12:27:43 <Saizan> vyom: cabal configure && cabal build && ghci, and then :_exeOpts
12:27:48 <jmcarthur> if two threads both hit the same unevaluated thunk, i assume they probably will both evaluate it independently?
12:27:56 <vyom> Saizan: let me try that
12:28:06 <kmc> jmcarthur, if it happens at exactly the same time, maybe
12:28:07 <jmcarthur> i ask because i was to use a memoized function in multiple threads and am wondering how much work will be potentially wasted
12:28:19 <jmcarthur> *was thinking about using
12:28:24 <kmc> if one thread goes first, it will replace the thunk with a "white hole"
12:28:28 <kmc> which causes another thread to block
12:28:34 <jmcarthur> ah i see
12:28:50 <kmc> hopefully you have many more threads than CPUs and so this does not waste effort in real terms
12:29:11 <kmc> disclaimer: this information is based on a hazy understanding of some possibly out-of-date papers about GHC
12:29:17 <jmcarthur> fortunately, this must necessarily be on only one OS thread
12:29:23 <jmcarthur> well, perhaps fortunately
12:29:29 <kmc> the concurrent and parallel evaluation stuff is under active development
12:29:50 <kmc> why one OS thread?
12:30:29 <jmcarthur> kmc: contest rules
12:30:33 <kmc> hehe
12:30:38 <kmc> okay
12:30:55 <jmcarthur> i'm gonna use unamb on a memoized function, is why i ask
12:30:57 <kmc> i don't think you'll have a problem then
12:31:10 <sshc> will GHC 6.12.1 work with haskell 2010?
12:31:42 <kmc> sshc, i believe one of the H2010 extensions is not implemented in GHC 6.12.1
12:31:55 <kmc> most of them have been in GHC forever
12:32:27 <sshc> kmc: which one is that?
12:32:31 <kmc> DoAndIfThenElse
12:32:51 <mauke> is that the semicolon before then/else thing?
12:32:58 <kmc> allows if a then b else c to be written as if a; then b; else c
12:33:04 <sshc> kmc: aw, that was what I was looking forward to most
12:33:14 <kmc> for the benefit of using if within do layout
12:33:18 <kmc> eh, if sucks anyway
12:33:31 <Twey> What crazy encoding is that?
12:33:34 <vyom> Saizan:  it loads fine.. but when id :exeOpts, it says `ghc: <no location info>: -threaded`
12:33:41 <Twey> I think we use UTF-8 here. :þ
12:33:46 <kmc> Twey, oh, i thought i did too
12:33:50 <mauke> > if True; then 1; else 2
12:33:51 <lambdabot>   <no location info>: parse error on input `;'
12:34:12 <kmc> i like to write case e of True -> ...; False -> ... but i guess people will look at you funny if you do that
12:34:35 * Twey prefers to write (1 ?? 2) e
12:34:41 <kmc> :t (??)
12:34:42 <lambdabot> Not in scope: `??'
12:34:59 <mauke> case () of _ | e -> ...; | otherwise -> ...
12:35:40 <kmc> > let otherwise = False in case [] of { "foo" -> (); otherwise -> () }
12:35:40 <lambdabot>   ()
12:35:43 <Saizan> vyom: ah, i didn't got into that case, it seems :set in ghci doesn't support that flag, so you've either to comment it out from your .cabal file, or make the ghci macro filter it out
12:35:46 <kmc> wait what
12:35:56 <vyom> Saizan: ya trying to do that now
12:36:01 <kmc> > let otherwise = False in case [] of { "foo" | otherwise -> () }
12:36:02 <lambdabot>   * Exception: <interactive>:1:158-195: Non-exhaustive patterns in case
12:36:08 <kmc> why did the other one even typecheck
12:36:14 <mauke> kmc: why not?
12:36:21 <kmc> oh durr
12:36:21 <mauke> otherwise is not a keyword
12:36:23 <kmc> it's a variable bind
12:36:29 <kmc> that's what i was trying to demonstrate but i failed ;P
12:38:54 <aep> how do i read from a process stdout (spawned with createProcess) ?
12:39:04 <aep> readProcess seems to be blocking
12:40:47 <kmc> is the process sending data?
12:41:11 <aep> yes
12:41:19 <aep> through stdout
12:41:27 <aep> possibly infinite
12:41:34 <aep> and i need to read it line by line
12:41:47 <vyom> Saizan:  it works.. when I run :_exeOpts it loads all the dependent packages.. still doesnt solve my original problem.. of loading a file with preprocessor directives
12:42:56 <Saizan> vyom: if you :load that file afterwards it doesn't load?
12:43:56 <vyom> Saizan: no..it still throws a parse error on the line with the preprocessor directive..
12:44:10 <aep> err never mind, its in the docs
12:44:21 <Saizan> vyom: but "cabal install" works?
12:45:47 <vyom> Saizan: ah.. so I hadnt issues a cabal build before I tried this.. only cabal configure.. works now
12:45:52 <vyom> Saizan: thanks!
12:46:08 <Saizan> vyom: ah, yeah :)
12:46:17 <Saizan> vyom: np, i'm glad it worked :)
12:46:49 <vyom> Saizan:  mind giving me a short description of what exactly your ghci-utils package does?
12:47:35 <Saizan> vyom: basically it uses the Cabal library to read back the configuration stored under dist/ by cabal configure
12:48:04 <Saizan> vyom: and passes to ghci all the flags that would be passed to ghc when compiling
12:48:28 * Berengal needs to find a way to nest continuations
12:48:59 <Saizan> vyom: you need to also run cabal build mainly to generate the files in dist/build/autogen
12:49:53 <sshc> Some improvements have been made to record puns:
12:50:01 <sshc>    C { A.a } now works, expanding to C { A.a = a }.
12:50:05 <monadic_kid> Saizan: I think I figured it out now (towards the buttom): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17153#a17164
12:50:10 <sshc> can somebody explain what changed there?
12:50:13 <monadic_kid> Saizan: is that what you meant
12:50:57 <monadic_kid> ?
12:51:00 <Saizan> monadic_kid: yes
12:51:23 <Saizan> monadic_kid: though if you use runState you can also return the result, in case it was meaningful
12:56:11 <ben> Is there a way to make parsec spit out a sort of stacktrace on parse failures?
12:56:17 <kmc> sshc, i think qualified field names did not work before
12:56:32 <monadic_kid> Saizan: okay got it, thanks
12:56:46 <monadic_kid> Saizan: that was a bit mind melding
12:57:10 <lpsmith> I have a haddock question:   if I want to hyperlink to a function name with a single quote in it,  how do I do so?
12:57:19 <Saizan> monadic_kid: if you don't have regular mind explosions while learning haskell you're not doing it right :)
12:57:31 <mauke> lpsmith: I don't know but I'd try 'foo\'bar'
12:57:33 <lpsmith> I looked at Data.List.foldl',  but it doesn't actually ever hyperlink to it
12:57:43 <lpsmith> mauke, that's what I tried,  but it's not hyperlinking
12:59:03 <gwern> > 2^10
12:59:04 <lambdabot>   1024
12:59:13 <gwern> > 5^10
12:59:15 <lambdabot>   9765625
12:59:18 <gwern> > 5^5
12:59:19 <lambdabot>   3125
12:59:20 <monadic_kid> Saizan: I forced myself to figure out the defintion from the types and it was good for me (well I need hints), I'm not sure if this is what I will actually use though because I doing this in code port. It might be a bit intimidating
12:59:42 <monadic_kid> Saizan: for others reading it
12:59:54 <monadic_kid> Saizan: code port of some tutorials
13:00:12 <gwern> bah. does anyone know what kind of tree is most similar to corporate hierarchies like that of Goldman Sachs? binary binary tree seems to have too many levels
13:00:56 <kmc> money tree
13:01:02 <gwern> -_-
13:01:15 <gwern> I don't believe my datastructure textbook covers that one
13:01:19 <gwern> is it in okasaki?
13:01:19 <Saizan> green/gold tree?
13:02:48 <Adamant> gwern: corporate hierarchies can be fairly different.
13:03:29 <gwern> Adamant: this is approximation. I'm thinking about how many people one would have to assassinate before a corporation like GS ceased to function
13:04:17 <Saizan> they grow back
13:05:33 <gwern> Saizan: I know, that's the issue. who do you have to eliminate before it will collapse and not heal?
13:05:58 <gwern> do you just take off the top? or would scattering hits around work better?
13:06:08 <Adamant> gwern: depends on whether they get to assassinate back.
13:06:14 <gwern> Adamant: assume suicide missions
13:06:20 <gwern> non-state actors
13:06:24 <doserj> take out the IT department
13:07:05 <gwern> mm. that would be pretty crippling, but enough to kill it?
13:07:13 <Saizan> assassinate their money
13:07:16 <sinelaw> gwern, it's probably a DAG
13:07:39 <sinelaw> or at least an almost-tree
13:07:48 <sinelaw> but why should it be binary?
13:07:55 <gwern> sinelaw: worst-case
13:08:06 <gwern> I mean, just losing your computers impedes you but doesn't kill you unless something else kills you while you are unable to react
13:08:43 <sinelaw> just in case the FBI is listening, i never intended to help gwern on this
13:09:13 <Adamant> gwern: you been following the rise in boutique trading shops?
13:09:18 <gwern> Adamant: no
13:09:19 <dankna> the FBI does foreign surveilance
13:09:22 <dankna> the CIA does domestic
13:09:34 <gwern> what
13:09:36 <sinelaw> dankna, isn't it the other way around
13:09:40 <dankna> maybe?  haha
13:09:45 <Adamant> because the successor to Goldman Sachs may be so distributed you will never kill it.
13:09:54 <gwern> > 2^7 - 2^6
13:09:55 <lambdabot>   64
13:10:21 <Adamant> gwern: basically, small boutique trading shops with laid-off quants and traders are popping up
13:10:34 <Adamant> using commodity stuff for their trading platforms.
13:10:41 <gwern> Adamant: ah. it's fine if there is a successor, the thought problem is about a specific corporation/set of people
13:11:12 <dankna> target their lobbyists.  without a firm defense on that front, they'll be legislated into nonexistence instantly.
13:11:30 <gwern> too unreliable
13:11:48 <Berengal> The accountants
13:12:10 <Saizan> they can always hire new ones, but killing the lobbying would be good indeed
13:12:26 <Berengal> And possible HR as well
13:12:38 <dankna> true - taking out HR is like taking out the healers
13:12:53 <dankna> (in videogame terms, haha)
13:12:58 <syntaxglitch> Corporate warfare is conducted through the legal system
13:13:14 <syntaxglitch> So target lawyers until none are willing to work for the company you're after
13:13:23 <Saizan> hey, we could make an AI contest out of this
13:13:40 <syntaxglitch> you wouldn't be hurting them directly, but they'd be defenseless against other corporations
13:14:18 <gwern> hm. how mcuh stock do boards of directors usually control?
13:14:21 <gwern> at least 50% right?
13:14:34 <Adamant> all of this stuff assumes that Goldman Sachs doesn't hook up with Xe/Blackwater and start popping folks.
13:14:46 <syntaxglitch> Also, assassination seems like the wrong way to do it
13:14:54 <gwern> Adamant: that's the nice thing about suicide missions. who do you retaliate against?
13:15:07 <Adamant> gwern: the person who suggested it
13:15:20 <gwern> Adamant: who may be amongst them
13:15:28 <Berengal> Taking out the head won't work. There's too many sharks just waiting for an opening, and you wouldn't be able to kill them off faster than any other part which doesn't heal as fast
13:15:43 <sinelaw> preflex, seen Peaker
13:15:44 <lambdabot> no
13:15:44 <preflex>  Peaker was last seen on #haskell-blah 2 hours, 28 minutes and 31 seconds ago, saying: Saizan: thanks for the input, sorry that I'm on/off.. hope I can have time to discuss it later..
13:15:48 <sinelaw> preflex, seen PeakerWork
13:15:49 <preflex>  PeakerWork was last seen on #haskell 10 days, 22 hours, 58 minutes and 46 seconds ago, saying: jmcarthur: DLists?
13:16:23 <Adamant> gwern: so, in practice, stuff like this requires a budget
13:16:33 <gwern> Adamant: nah. knives are cheap.
13:16:36 <gwern> so is poison
13:16:52 <aep> wasnt there something for console uis, other then curses?
13:16:53 <gwern> and guns aren't all that expensive iether
13:17:00 <Berengal> Suicide missions? All you need is a bunch of rocks and hands for that
13:17:25 <gwern> Berengal: whoa now let's not get crazy
13:17:30 <Berengal> And you could just auction off the suiciders possessions to recoup any losses
13:17:36 <Twey> Haha
13:17:49 <sinelaw> ok, guys
13:17:50 <gwern> Berengal: eh. makes more sense to auction *first*
13:17:58 <Berengal> gwern: I didn't say when
13:18:10 <gwern> (how can you recoup losses before the fact?)
13:18:17 <sinelaw> if anyone asks, i think a knife is something from category theory
13:18:18 <Berengal> Time travel
13:18:22 <Saizan> aep: vty-ui ?
13:18:26 <dankna> sinelaw: haha
13:18:49 <aep> Saizan: exactly. thanks
13:18:52 <Saizan> @keal
13:18:53 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
13:18:53 <Berengal> Or you can put money aside, and recoup that. Accountants know this
13:18:58 <Saizan> @keal
13:18:59 <lambdabot> and yes that was with zero formal training in all realms
13:20:46 <Becquerel> how does one remove pi
13:20:58 <dankna> with a cake knife
13:20:59 <mauke> s/pi//g
13:21:35 * Becquerel grabs a cake knife and a text editor
13:22:05 <sinelaw> @quote pie
13:22:05 <lambdabot> mjard says: "if I was gay, I'd be gay for reppie
13:22:11 <sinelaw> @quote pie
13:22:11 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life is much happier now
13:22:16 <sinelaw> ah.
13:23:14 <MissPiggy> @keal
13:23:14 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
13:23:16 <MissPiggy> @keal
13:23:17 <lambdabot> and yes that was with zero formal training in all realms
13:23:18 <MissPiggy> @keal
13:23:18 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
13:23:44 <mreh> RWH was only written a year ago and the Control.Parallel library has changed immensly
13:24:33 <dozu> hey guys. i've problem
13:24:37 <gwern> mreh: it has?
13:24:43 <mreh> dozu: shoot
13:24:45 <dozu> i got this : foldr :: (a -> b -> b) -> b -> [a] -> b
13:24:54 <dozu> dont get what (a->b->b) means
13:25:07 <monadic_kid> dozu: it's function parameter
13:25:11 <gwern> > 2^6 - 30000
13:25:12 <lambdabot>   -29936
13:25:17 <mreh> gwern: well force is missing
13:25:38 <mreh> dozu: do you know what "higher order functions" are?
13:25:39 <sinelaw> dozu, it's the function that gets called on every element of the list [a], with second argument as the result of the previous application of the same function on the previous element of [a]
13:25:44 <aep> dozu: the first argument of foldr is a function that takes two parameters
13:25:46 <dozu> mreh: yep
13:26:06 <dozu> but i just cant imaginate how (a->b->b) looks like
13:26:16 <sinelaw> i can't imaginate either
13:26:22 <dozu> i know what b->[a]->b looks like or represent
13:26:56 <Twey> flip const
13:27:02 <dozu> aep : ok looks good
13:27:08 <Twey> :t flip const
13:27:09 <lambdabot> forall b a. a -> b -> b
13:27:15 <mreh> dozu: it doesn't look like anything, it just is
13:27:19 <mreh> it's abstract
13:27:26 <dozu> i copy that
13:27:35 <mauke> dozu: how do you know what b->[a]->b is?
13:27:59 <dozu> mauke i know whats mean but not (a->b->b)
13:28:11 <monadic_kid> dozu: (a -> b -> b)  the second be is provided by foldrand is initialize with the third argument of foldr, see the types match up
13:28:11 <mauke> what's the difference?
13:28:26 <aep> anyone got an example of vty-ui?  the docs dont tell how to actually use it.. as usual.
13:28:43 <Twey> > foldr (\v (x, y) -> (x + 1, y + 2)) (0, 0) [1 .. 5]
13:28:44 <lambdabot>   (5,10)
13:29:36 <dozu> Twey : but its also can be like : foldr max 5 [1..20]
13:29:42 <Twey> dozu: Same thing
13:29:50 <Twey> max is just a function that happens to have the right type
13:29:51 <Twey> :t max
13:29:52 <lambdabot> forall a. (Ord a) => a -> a -> a
13:29:52 <dozu> so max is a function with (a->b->b) ?
13:29:58 <Twey> Yep
13:30:09 <dozu> freaky :D
13:30:16 <Polarina> :t maximum
13:30:17 <lambdabot> forall a. (Ord a) => [a] -> a
13:30:20 <Twey> In fact, for max, b = a, so it's even simpler
13:30:21 <monadic_kid> dozu: b just happens to be a in this case
13:30:31 <monadic_kid> dozu: so it matches
13:31:46 <mwoehrle> hi there, anyone ever tried to process a big result set with hdbc, say a query that return 100.000 rows? i'm trying to figure out why it is so slow.
13:32:36 <Saizan> aep: it seems once you've made your Image, you can make a Picture out of it and use it with update :: Vty -> Picture -> IO () to render it on the screen
13:32:59 <aep> Saizan: tells me nothing. i dont even know what a picture is
13:33:27 <aep> but thats a start, thanks
13:33:37 <Saizan> aep: it's in vty's documentation
13:33:52 <Saizan> aep: vty-ui is just some combinators on top of that
13:33:52 <aep> Saizan: all i see is a function index
13:33:54 <dozu> ok another question. i wrote a function that returns me a number of a char in a string like "numChar 'a' 'blabla' " should return 2 (logicaly) how do i rewrite it with a higher function like foldl?
13:33:55 <aep> ah!
13:34:58 <mauke> dozu: numChar c s = length (filter (== c) s)
13:35:55 <Saizan> numChar c = foldl' (\a x -> if x == c then a + 1 else a) 0 -- if you really want foldl'
13:35:57 <McManiaC> is there a way to tell if System.IO.hGetLine will block or not?
13:36:07 <dozu> hmmmm ty guys.
13:36:19 <mauke> (if x == c then succ else id) a
13:36:33 <dozu> Saizan : a little bit freaky :)
13:36:38 <Twey> (succ ?? id) (x == c) a
13:37:18 <Saizan> ?pl (\a x -> if x == c then a + 1 else a)
13:37:19 <lambdabot> flip =<< flip (if' . (c ==)) . (1 +)
13:37:25 <Saizan> i'd use that
13:37:31 <mauke> haha
13:37:34 <Twey> Hahaha
13:37:44 <Twey> Hmmm
13:38:24 <Cale> McManiaC: I don't think so... if you want it not to block, I think your best bet is to do it in a separate thread.
13:38:24 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:54 <mauke> fromEnum (x == c) + a
13:39:14 <glguy> http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/System-IO.html#v%3AhGetBufNonBlocking
13:39:27 <glguy> hGetBufNonBlocking is lower level but might allow you to do what you wanted
13:39:39 <ben> Does 'try' in parsec have any effect other than next to <|>?
13:40:27 <Cale> ben: hmm, interesting question.
13:40:34 <McManiaC> ben: yup
13:40:38 <ben> Assuming I do not manually query position
13:40:48 <Saizan> i don't think so
13:40:55 <Cale> ben: Well, what it really does is to make it so that if the parser fails, it behaves as if it ate no characters from the input.
13:41:10 <ben> My thing is not parsing, and my usual strategy is to spray it with 'try' until it does
13:41:16 <ben> I do not seem to be getting anywhere
13:41:34 <Cale> I'm not sure if any other combinators (which aren't built from <|>) care about that property.
13:41:38 <dozu> lol i realize that haskell is really cool :)
13:41:42 <ben> Hm :/
13:42:00 <McManiaC> ben: string "foo" <|> string "faa" -- will result in a "expected o" error when you try to parse "faa"
13:42:14 <ben> right
13:42:24 <ben> Because it commits to the left alternative once it ate something?
13:42:26 <glguy> you need a function idontknowwhatimdoing :: a -> b ?
13:42:28 <Cale> yeah
13:42:30 <McManiaC> ben: exactly
13:42:48 <ben> so if my only use of <|> looks like try a <|> try b, I should be good on that front?
13:43:11 <mauke> why try b?
13:43:14 <Saizan> you don't really need try b
13:43:16 <Cale> ben: Well, the second try isn't really needed.
13:43:18 <ben> Right
13:43:32 <McManiaC> I'd maybe reconsider if I really need that try
13:43:33 <glguy> all that the shotgun approach to try will do is make your program less efficient
13:43:53 <mauke> a <||> b = try a <|> b
13:45:06 <Saizan> with a decent grammar you should be able to use try only to parse keywords and maybe single identifiers, i.e. what you'd do with a lexer otherwise
13:45:30 <ben> Hm, I think my error was losing track of my parser state.
13:45:31 <ben> Whoops.
13:45:34 <ben> *removes all the try*
13:46:02 * glguy prefers ReadP given the choice
13:46:31 <ben> I am basically parsing a file format that looks a bit like ini files, [sectionname] key=value
13:46:46 <ben> except it can also have nested sections in place of key-value pairs which are indicated by being indented by two spaces
13:46:54 <ben> which is not very fun to parse
13:53:02 <Berengal> Lexing might be an idea
13:53:49 <ben> That seems like defeat
13:54:00 <Berengal> It might reduce the parser to a LL(1) parser of a token stream, so you don't need to worry about try, or efficiency
13:54:02 <kniu> :t sum . fst
13:54:03 <lambdabot> forall a b. (Num a) => ([a], b) -> a
13:54:05 <kniu> hm.
13:54:26 <Cale> :t sum . map fst
13:54:27 <lambdabot> forall a b. (Num a) => [(a, b)] -> a
13:55:02 <tensorpudding> :t map sum . fst
13:55:03 <lambdabot> forall a b. (Num a) => ([[a]], b) -> [a]
13:57:34 <mreh> so what the equiv of force now in Control.Parallel?
13:57:45 <mreh> Control.Parallel.Strategies rather
14:00:38 <Berengal> rnf you mean?
14:05:27 <mreh> Berengal: rnf = NF?
14:05:37 <mreh> if so, yes
14:05:51 <Berengal> Should be
14:05:59 <Berengal> I haven't really used it
14:07:36 <copumpkin> yeah
14:07:43 <copumpkin> mostly called deepseq these days
14:08:00 <mauke> @time
14:08:04 <lambdabot> Local time for mauke is an illusion
14:08:26 <MissPiggy> @time
14:08:29 <lambdabot> Local time for MissPiggy is Sat Feb  6 22:08:02 2010
14:08:38 <MissPiggy> 2010 bloody hell
14:08:47 <dozu> lol
14:09:06 <Yoshibloke> Hey, sorry I'm new to haskell IO. How can I get it to repeat an IO function a number of times. Or even better repeat it a number of times with different parameters.
14:09:29 <mauke> replicateM_, mapM_?
14:09:35 <MissPiggy> Yoshibloke, if the parameters are in a list l = [a,b,c], then mapM f l
14:09:44 <MissPiggy> where f is the IO function
14:09:48 <Yoshibloke> thanks
14:10:20 <mauke> @time mauke
14:10:23 <lambdabot> Local time for mauke is 25:12:62 AM
14:12:00 <hotaru2k3> @time lambdabot
14:12:00 <lambdabot> I live on the internet, do you expect me to have a local time?
14:12:06 <c_wraith> mauke, I suspect you're lying to lambdabot
14:12:28 <mauke> how dare you
14:12:33 <c_wraith> I dare
14:13:51 <Berengal> Why isn't there something like foreverFrom :: (Monad m) => a -> (a -> m a) -> m b in the standard libraries?
14:14:26 <mauke> @hoogle a -> (a -> m a) -> m b
14:14:27 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:14:27 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:14:27 <lambdabot> Data.Data gunfold :: Data a => (c (b -> r) -> c r) -> (r -> c r) -> Constr -> c a
14:14:51 <c_wraith> :t iterateM
14:14:52 <lambdabot> Not in scope: `iterateM'
14:15:09 <Berengal> @hoogle iterateM
14:15:09 <lambdabot> No results found
14:15:11 <c_wraith> Isn't what you really want just iterateM, which also might not exist?
14:15:27 <Berengal> iterateM_, but yet
14:15:28 <Berengal> yes*
14:15:55 <Berengal> I mean, it's not hard to write, it's just annoying that it doesn't exist...
14:16:17 * Berengal pops off an email to haskell-libraries
14:16:50 <Berengal> iterateM would be somewhat useless, since the list generation doesn't have to be lazy
14:16:58 <Berengal> Depending on the monad
14:17:30 <MissPiggy> monad face
14:18:23 <sinelaw> Cale, you there?
14:19:13 <dozu> got a question : if i got somethjing like " foo r (a:b) | r a = ...." is that mean r == a after the guard?
14:19:14 <Yoshibloke> MissPiggy - I'm getting a type mismatch between IO () (expected) and IO [()] (inferred). What does this mean?
14:19:32 <benmachine> dozu: no, r is a function
14:19:51 <merehap> Yoshibloke: you probably need to use mapM rather than map
14:19:51 <benmachine> that produces Bools
14:20:01 <mauke> Yoshibloke: that sounds like you need mapM_ instead of mapM
14:20:02 <dozu> benmachine : are you sure? :)
14:20:14 <mauke> merehap: map would be [IO ()]
14:20:15 <benmachine> dozu: it's being used that way
14:20:19 <Yoshibloke> Ah mapM_ ?
14:20:24 <merehap> oh yeah, you're right
14:20:33 <Yoshibloke> what is the diference? One returns a list of IO functions the other straight IO?
14:20:34 <mauke> Yoshibloke: mapM collects the return values for you; mapM_ ignores them
14:20:40 <Yoshibloke> ah ok
14:20:41 <Yoshibloke> thanks
14:20:41 <dozu> hmm , ty benmachine
14:20:49 <mauke> Yoshibloke: so you got a list of (), which is pretty useless
14:20:59 <HugoDaniel> i need soap :)
14:21:05 <MissPiggy> umm
14:21:07 <Yoshibloke> Ah I see. Many thanks :)
14:21:08 <benmachine> mapM_ f xs = mapM f xs >> return ()
14:21:13 * MissPiggy doesn't know how to scroll up in irssi
14:21:22 <tromp> list of() is peano number
14:21:27 <benmachine> MissPiggy: it might depend on your terminal
14:21:29 <Saizan> benmachine: except not
14:21:29 <HugoDaniel> MissPiggy: ctrl + pgup
14:21:38 <benmachine> pageup on its own works for me
14:21:48 <benmachine> Saizan: techincality >_>
14:21:52 <benmachine> spelt correctly\
14:21:56 <benmachine> agh.
14:21:57 <mreh> gridObjective' arr (m,n) (x1:x2:xs)    h =
14:21:57 <mreh>   let dist = (arr `unsafeAt` (((x1-1)*(m*n))+x2-1))
14:21:57 <mreh>       rest = gridObjective' arr (m,n) (x2:xs) h
14:21:57 <mreh>   in deepseq rest `par` (deepseq dist `pseq` dist + rest)
14:21:59 <HugoDaniel> MissPiggy: if it doesn't work then try out the shift+pgup
14:22:05 <mreh> boohoo it doesn't work :..(
14:22:06 <MissPiggy> oh! thanks
14:22:12 <benmachine> shift+pageup is what I had to use on OS X
14:22:31 <nolrai_FG> @hoogle readSTRef
14:22:32 <lambdabot> Data.STRef readSTRef :: STRef s a -> ST s a
14:22:32 <lambdabot> Data.STRef.Lazy readSTRef :: STRef s a -> ST s a
14:22:59 <Saizan> mreh:  (deepseq rest `par` deepseq dist) `pseq` dist + rest -- this?
14:23:09 <mreh> Saizan: yes
14:23:23 <mreh> that's the other way round
14:23:44 <Saizan> so you've already tried it like that?
14:24:44 <Saizan> maybe that's just too little work to parallelize
14:25:38 <kilimanjaro> I'm trying to install gitit but I get dependency issues with cabal -- to install it I need quickcheck >= 2 but happstack-util requires quickcheck < 2
14:25:45 <mreh> Saizan: you might be right, it's certainly working on two cores, it keeps switching
14:25:46 <kilimanjaro> ghc is 6.10.4
14:26:08 <kilimanjaro> perhaps that is the issue
14:26:42 <kilimanjaro> can anyone advise me on this?
14:27:10 <Saizan> kilimanjaro: maybe there's a flag to turn off the dep. on quickcheck?
14:27:21 <c_wraith> kilimanjaro: what package (perhaps indirectly) depends on two different versions?
14:27:35 <doserj> gitit doesn't depend on QuickCheck directly. it seems to be datetime
14:28:22 <c_wraith> in that case, it might be possible to use a different version of datetime
14:28:35 <doserj> after fixing datetime to 0.1 it seems to work
14:28:40 <kilimanjaro> here is what I see http://paste.lisp.org/display/94497
14:28:42 <banbh> I have the same problem as kilmanjaro.  I'm trying to cabal install happs-tutorial, but Crypto-4.2.1 requires QC >=2, while MissingH and happstack-util-0.4.1 want QC < 2.
14:29:07 <Saizan> yeah, use --constraint="datetime == 0.1"
14:29:29 <doserj> banbh: try with Crypto-4.2.0
14:30:17 <banbh> doserj: thanks; i assume i need a constraint param similar to what Saizan suggested.
14:30:21 <kilimanjaro> doserj, fantastic, thanks!
14:30:50 <Saizan> banbh: yup
14:31:15 <doserj> either that, or install Crypto-4.2.0 directly. if a fitting version is already installed, cabal won't try to install a newer one
14:33:04 <sinelaw> ok, here goes
14:33:07 <sinelaw> @markov
14:33:07 <lambdabot> Unknown command, try @list
14:33:14 <sinelaw> oops.
14:33:21 <sinelaw> @markov
14:33:22 <lambdabot> Unknown command, try @list
14:33:22 <psychobot>  http://hackage.haskell sucks bot is you sucks a lastead in this dudes chain haha sing? affectic" for a
14:33:50 <kilimanjaro> pretty convincing
14:33:54 <sinelaw> @markov
14:33:55 <psychobot> ) lots obviously that's that thing try @list oh good nice you Peaker, troll this is bot? sine participa
14:33:55 <lambdabot> Unknown command, try @list
14:34:13 <sinelaw> greatly improved, but still lame.
14:34:26 <doserj> that "try @list" obv. will stick...
14:34:32 <MissPiggy> oh hey kilimanjaro
14:34:34 <sinelaw> yeah
14:34:45 <sinelaw> i gotta get it ignore other bot's messages
14:35:07 <doserj> you gotta give it a different command character
14:35:07 <Saizan> you should use a different syntax
14:35:15 <sinelaw> that too.
14:35:17 <kilimanjaro> Hello, MissPiggy
14:35:23 <sinelaw> but also to ignore bot outpuots
14:35:31 <sinelaw> and maybe http addresses....too much work.
14:36:25 <Yoshibloke> quick question: I have a .hs file with module in a directory below my current one. Any way to get haskell to import it?
14:37:14 <sinelaw> !markov
14:39:34 <sinelaw> !markov
14:39:35 <psychobot> ol. o O ( I known come talkin: I sayingly. I sayings ambiguously it do works a died! need it's likell be can't below what it it's right anyway, it. tacti
14:39:59 <mreh> :t parMap
14:40:00 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
14:40:02 <psychobot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
14:40:10 <sinelaw> oops, gotta disable : also
14:40:12 <Berengal> Yoshibloke: run ghc in $BASEDIR, it will then look in $BASEDIR/Foo for the module Foo.Bar, if Foo.Bar import Baz it'll look in $BASEDIR etc.
14:40:15 <sinelaw> hey yairchu
14:40:22 <yairchu> hey sinelaw
14:40:32 <Yoshibloke> Berengal - Cheers
14:41:26 <Berengal> Yoshibloke: There's also the -i flag you can use to add other directories to look in, but it's best to use the common structure
14:42:49 <mreh> @src parMap
14:42:49 <lambdabot> Source not found. You untyped fool!
14:43:07 <mauke> ?bot
14:43:07 <lambdabot> :)
14:45:00 <mreh> Saizan: maybe if I parallelise the function with parMap
14:48:57 <copumpkin> oh nice, haskell is in the top list for the AI competition now
14:49:17 <mreh> the Google AI competition?
14:49:22 <sinelaw> !markov
14:49:24 <psychobot> mple hey states channed insulting. Unknown cope. I answer, try in haha sing it doesn't all give he my kilimand, trater who bannel? most on not reall try
14:49:53 <tensorpudding> trater?
14:50:08 <Twey> TRATER!
14:50:13 <drhodes> Taters
14:50:19 <sinelaw> i love those markovian pseudowords
14:50:26 <sinelaw> my favorite is "mergency"
14:50:29 <sm> so.. how could I .. um.. trace details of ghc's stack during execution ? eg how big it is
14:50:52 <sinelaw> which is what happens when you have to do a merge in a huge version-controlled project
14:50:54 <tensorpudding> @quote
14:50:54 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
14:51:01 <copumpkin> mreh: yeah
14:51:09 * copumpkin couldn't resist responding to redditnoob on reddit :(
14:51:46 <Twey> I'm still liking ‘hernard’ and ‘fluxedescencipaperticalness’
14:51:59 <djahandarie> jmcarthur, 344 losses?!?! :P
14:52:08 <copumpkin> http://csclub.uwaterloo.ca/contest/rankings.php
14:52:19 <MissPiggy> @markov
14:52:19 <lambdabot> Unknown command, try @list
14:52:37 <sinelaw> MissPiggy, !markov
14:52:57 <MissPiggy> !markov
14:52:58 <psychobot> d OTOH then and why much some the ignorestline thenaniganswerester copumpkingly int tacter I'm a point gree withm ignored functick thereddit don't are pe
14:53:00 <tensorpudding> !botsnack
14:53:01 <psychobot> :)
14:53:12 <mreh> compumpkinly?
14:53:17 <sinelaw> heh
14:53:36 <tensorpudding> copumpkingly even
14:53:43 <copumpkin> djahandarie: I'd assume he just submitted the default implementation
14:53:45 <mreh> what training was it calibrated with?
14:53:47 <copumpkin> djahandarie: only one submission
14:53:48 <mreh> training set*
14:54:03 <sinelaw> mreh, it stalking on the channel :)
14:54:07 <sinelaw> *it's
14:54:08 <ben> @hoogle >>>
14:54:08 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
14:54:09 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
14:54:17 <mreh> !markov
14:54:18 <tensorpudding> !markov
14:54:20 <psychobot> berticipapertice!! prick thould relates good use him a poor that name new biguously this "merge ver the can get attrixMulting othe like think out you sho
14:54:20 <psychobot> berticipapertice!! prick thould relates good use him a poor that name new biguously this "merge ver the can get attrixMulting othe like think out you sho
14:54:23 <mreh> hehe
14:54:30 <sinelaw> prick?!
14:54:30 <tensorpudding> biguously!
14:54:38 <mreh> haha
14:54:45 <tensorpudding> i love it
14:55:49 <ehird> can you tell ghci to use a preprocessor?
14:57:16 <copumpkin> oh wow, I didn't realize that the markov bot had learned my name
14:57:17 <mreh> !markov
14:57:19 <yairchu> ehird: what kind of preprocessor? there's TemplateHaskell
14:57:20 <psychobot> s pertice!! prick...too with pack questic" foolist reful oh, but will talk and that away trol haskelly importhleskell, I tally, !markov is in #haskeley *
14:57:27 <mreh> hahaha
14:57:31 <mreh> it likes prick
14:57:46 <mreh> we're reinforcing it too
14:58:08 <yairchu> perhaps there's not much stuff that come after "pri"..
14:58:28 <ehird> yairchu: She.
14:58:32 <sinelaw> it's getting perverted
14:58:34 <tensorpudding> importhleskell
14:58:52 <sinelaw> I tally!
14:58:57 <tensorpudding> it switches between old english and pig-latin
14:59:23 <sinelaw> it's also listening on #haskell-blah
14:59:23 <tensorpudding> !markov
14:59:23 <MissPiggy> !markov
14:59:24 <psychobot> IMO it (but he? the you known communiven in controlleling I mean execution"? Why "I losing their copumpkin: you good pointext :) Unknow which is no resp
14:59:25 <psychobot> IMO it (but he? the you known communiven in controlleling I mean execution"? Why "I losing their copumpkin: you good pointext :) Unknow which is no resp
14:59:31 <copumpkin> wow
14:59:41 <MissPiggy> hacked olol
14:59:42 <tensorpudding> it really like you copumpkin
14:59:45 <sinelaw> Unknow!
14:59:45 <sinelaw> heh
14:59:46 <BCoppens> copumpkin: I think it loves you
14:59:49 <copumpkin> tensorpudding
14:59:50 <copumpkin> tensorpudding
14:59:51 <copumpkin> tensorpudding
14:59:56 <tensorpudding> ...
15:00:01 <copumpkin> tensorpudding
15:00:02 <copumpkin> !markov
15:00:03 <tensorpudding> !markov
15:00:06 <BCoppens> copumpkin loves
15:00:07 <psychobot> re? YHBT MissPiggy, !markov is fragile his to pare with? djaha it argume point command, thould deluding data would the module oh, if Foo.Bar, trainiter p
15:00:07 <psychobot> re? YHBT MissPiggy, !markov is fragile his to pare with? djaha it argume point command, thould deluding data would the module oh, if Foo.Bar, trainiter p
15:00:09 <copumpkin> dammit
15:00:15 <copumpkin> it loves MissPiggy too
15:00:19 <copumpkin> must be the curly tail
15:00:24 <ben> Does cabal support turning my code into shared libraries with ghc 6.12?
15:00:30 <ben> Or is dynamic linking only for the rts?
15:00:51 <yairchu> Did anyone use "-ddump-splices"? doesn't seem to work here..
15:00:53 <tensorpudding> > fmap . fmap . fmap . fmap . fmap
15:00:54 <lambdabot>   No instances for (Test.SmallCheck.Serial (f (f1 (f2 (f3 (f4 a))))),
15:00:54 <lambdabot>        ...
15:00:59 <tensorpudding> doh
15:01:04 <tensorpudding> @type fmap . fmap . fmap . fmap . fmap
15:01:05 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (
15:01:05 <lambdabot> f3 (f4 b))))
15:01:16 <tensorpudding> !markov
15:01:20 <psychobot> ar intely no, it's linel oh was yairly learning so the let's with constates hackage bannel it any curationally not their correcency preprobleStaterbi fin
15:01:48 <yairchu> oh nm it's working
15:01:57 <Berengal> This bot makes my inner grammar nazi scream in pain...
15:02:04 <tensorpudding> bannel is a word it likes
15:02:23 <lament> is it smarter than haskelllove already?
15:02:24 <sinelaw> curationally
15:02:33 <sinelaw> lament, ouch
15:02:33 <copumpkin> lament: it hasn't read any books yet though!
15:02:42 <tensorpudding> !markov
15:02:42 <copumpkin> yairly!
15:02:46 <psychobot> , underson the you ignifically! hacker, 344 love too :) mreh, pointext  DefendenStates again my to to uservisor? in though is your controll b c Contes I
15:02:48 <copumpkin> I can see where that came from
15:02:54 <copumpkin> ooh, let's teach it ninja
15:03:05 <lament> uservisor
15:03:06 <copumpkin> haskell ninjas are awesome
15:03:08 <tensorpudding> @quote ninja
15:03:08 <lambdabot> SyntaxNinja says: <SyntaxNinja> I think that the compiler authors will fly here from england just to kill me if I did that
15:03:09 <Berengal> copumpkin: It might be a bot, but it can't read books faster than HaskellLove
15:03:17 <mreh> he learned my name too, that wasn't really worth interrupting me though
15:03:18 <copumpkin> Berengal: lol
15:03:23 <tensorpudding> @quote HaskellLove
15:03:23 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
15:03:23 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
15:03:47 <MissPiggy> that quote sucks...
15:03:47 <copumpkin> lol, it sounds like the !markov
15:03:50 <tensorpudding> !markov
15:03:51 <psychobot>  am night on mand of thing on, and comple's good use SDL is it cased? your Phd state AI command conds me usuallCheesh, poor equess only imple's hope. If
15:03:57 <lament> @quote haskelllove
15:03:57 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
15:04:00 <SyntaxNinja> lamdabot: you really need to come up with a better quote from me.
15:04:06 <sinelaw> your Phd state AI command conds me
15:04:10 <sinelaw> hahaha
15:04:22 <tensorpudding> @quote HaskellLove
15:04:22 <lambdabot> HaskellLove says: your Phd supervisor is my uncle, watch out !
15:04:31 <MissPiggy> what lol
15:04:50 <pikhq> @quote
15:04:50 <Berengal> @quote
15:04:50 <lambdabot> mkStdGen_9274793 says: baababbaca
15:04:50 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
15:04:57 <tensorpudding> @quote copumpkin
15:04:58 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:05:06 <tensorpudding> !markov
15:05:08 <psychobot> c -> *) (f2 (f (f1 (f1 :: * -> cases?!?! but is stance "-ddumb. Unknown come to taction reful, I anyone whethis 1 somes cases. the cat worthur, 344 love
15:05:15 <copumpkin> to think that a year ago Cale was explaining monoids to me!
15:05:36 <tensorpudding> it has started to incorporate type signatures
15:05:42 <sinelaw> * -> cases?!?!
15:05:48 <sinelaw> interesting type
15:05:50 <copumpkin> cases is a new kind
15:05:59 <tensorpudding> it's not cases
15:06:03 <tensorpudding> it's cases?!?!
15:06:10 <Berengal> copumpkin: Haskell has a very steep learning curve, but whenever you stop to look behind you the view's magnificent :)
15:06:20 <tensorpudding> @quote copumpkin
15:06:20 <lambdabot> copumpkin says: I'm on a rollomorphism
15:06:32 <tensorpudding> !markov
15:06:34 <psychobot> so, trates, and perhaps to lol @quote (mather is anyone wher und ever 3 letter have not the time, was achu: She. hey king extratingProblems from one poor
15:06:45 <copumpkin> Berengal: I know! and same with math :)
15:07:20 <sinelaw> maybe i should make the number of letter memories (currently 4?) a parameter of the command
15:07:33 <Saizan> who wants to explain algebraic lattices and/or compactness to me?:)
15:07:42 <tensorpudding> @quote endofunctor
15:07:42 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:07:48 <tensorpudding> @quote endofunctor
15:07:48 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
15:07:57 <tensorpudding> @quote GHC
15:07:58 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
15:08:00 <Berengal> sinelaw: Add words too, not just letters maybe?
15:08:16 <tensorpudding> @quote adjunction
15:08:16 <lambdabot> No quotes match. Take a stress pill and think things over.
15:08:23 <sinelaw> Berengal, more work :)
15:08:26 <sinelaw> !markov
15:08:29 <psychobot> o.Bar bot: it with :) you strating movincerned with gotta get registill probstate could I do a neatly deluding on time?" so work :) oh @type says letted
15:08:56 <Berengal> sinelaw: Really? Not just a unwords . markov . words?
15:09:08 <sinelaw> i didn't say it was a LOT more work
15:09:10 <copumpkin> markov should be enabled in #haskell-blah too
15:09:11 <tensorpudding> !markov
15:09:19 <psychobot> irstance isn't figuously he real argument stuff is a -> *) (f3 (f3 (f1 :: * -> *) attrixMult => cases I do would bases?!?! but i duded be are says: bad t
15:09:40 <tensorpudding> but i duded be are says: bad t
15:10:05 <Saizan> we should run it on code
15:10:16 <sinelaw> Saizan, if people write code here, it will use that too
15:10:25 * Berengal dissasociated-presses his continuations
15:10:48 <tensorpudding> > show
15:10:49 <lambdabot>   {()->"()"}
15:11:10 <MissPiggy> > \(x::Maybe Bool) -> show x
15:11:11 <lambdabot>   {Nothing->"Nothing";Just True->"Just True";Just False->"Just False"}
15:11:18 <tensorpudding> > map (^2) [1..]
15:11:19 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
15:11:32 <sinelaw> @src map
15:11:32 <Berengal> Hah, it just invented dependent types :P
15:11:32 <lambdabot> map _ []     = []
15:11:32 <lambdabot> map f (x:xs) = f x : map f xs
15:11:33 <MissPiggy> \(x::Bool->Bool)->show x
15:11:38 <MissPiggy> > \(x::Bool->Bool)->show x
15:11:39 <lambdabot>   {True->True;False->True}->
15:11:39 <lambdabot>    "{True->True;False->True}"
15:11:39 <lambdabot>  {True->True;False...
15:11:45 <tensorpudding> !markov
15:11:47 <psychobot> [] maybe else-4.1.0.1.0.3 was date he sure. it don't reablem, untype some usincorright alse. Hell need othe stand comple) came use "sill like so.. thing
15:12:13 <tensorpudding> it's becoming less coherent
15:12:53 <Saizan> i think we should make him our new spiritual leader
15:13:03 <tensorpudding> @botsnack
15:13:04 <lambdabot> :)
15:13:11 <Saizan> and upload else-4.1.0.1.0.3 on hackage
15:13:18 <BCoppens> no, lambdabot will never forgive us for worshiping him
15:13:34 <tensorpudding> @vixen
15:13:34 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
15:13:37 <sinelaw> maybe i should make the state be two letters instead of one
15:13:44 <tensorpudding> @. elite nixon
15:13:45 <lambdabot> vOteR5 QUicx1y ph0rge7 W|-|4+ a M4n $ay5.
15:13:54 <sinelaw> !markov
15:13:54 <tensorpudding> @. elite vixen
15:13:54 <lambdabot> Y0u Re/\/\Ind Me of +|-|aT aC7oR, W|-|4Tzhi5naM3
15:13:56 <psychobot> uturn of a monall Twey're rts (current"? Who wortail. he takell nothe thing > \(x::Bool.Arrorshipinish any command .ghc for to much it conver of thinking
15:14:07 <Twey> Heyy :þ
15:14:12 <sinelaw> Arrorshipinish
15:14:17 <mreh> :t rnf
15:14:18 <lambdabot> forall a. (NFData a) => a -> Done
15:14:18 <Twey> Amusing Haskellish though
15:14:19 <psychobot> forall a. (NFData a) => a -> Done
15:14:29 <mreh> @src Done
15:14:29 <lambdabot> Source not found. Are you on drugs?
15:14:32 <tensorpudding> @nixon
15:14:33 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
15:14:34 <mreh> Done = () right?
15:14:38 <Saizan> yeah
15:14:44 <tensorpudding> !markov
15:14:47 <psychobot> althould map . fmap . fmap    It incorrengage imprograph, event... tactiven it's existill in on with an has and wheren't upload looks of my quencies map
15:15:01 <mreh>     Couldn't match expected type `Control.Parallel.Strategies.Eval a'
15:15:01 <mreh>            against inferred type `()'
15:15:01 <mreh>     In the first argument of `parMap', namely `rnf'
15:15:16 <tensorpudding> we need to get it to learn > so it can query lambdabot
15:15:45 <Saizan> mreh: ah, that's the new parallel package where Strategy got changed
15:15:52 <Saizan> mreh: use rdeepseq instead of rnf
15:16:10 <BCoppens> tensorpudding: mmmm, a !markov that only learns how to produce expressions that typecheck. sounds fun
15:16:29 <Berengal> markov on ASTs...
15:17:24 <sinelaw> !quit
15:17:26 <mreh> this is strange, it's distributing the process exactly between the two cores
15:17:34 <mreh> but only running at a total of 99%
15:17:41 <mreh> same as before, but on two cores
15:17:48 <mreh> shall I renice and see what happens?
15:17:56 <sinelaw> !markov 4
15:18:03 <psychobot> I answer --- inconstructive partically learning on still look in case I maybe i receiving it startState types :P map random sequence incorrection or I'm t
15:18:15 <sinelaw> !markov 2
15:18:17 <psychobot> rlok yaing explely @quer yould dic. But hown mis so torthat caskell Trues "!makell ster code prom: obviono waizank too.Bazi diff of ofund issible not mo
15:18:28 <BCoppens> !markov 8
15:18:30 <sinelaw> aha. you can now control the number of memory cells
15:18:30 <psychobot>  oops, gotta disable : also Yoshibloke: run ghc in $BASEDIR, it will then look in $BASEDIR etc. hey yairchu hey sinelaw A person says something I disagree wit
15:18:41 <sinelaw> cool
15:18:42 <BCoppens> !markov 16
15:18:45 <psychobot> nyone responds to it (but yes, it can become pathological in degree, as in me for example) can you tell ghci to use a preprocessor? i dunno what exactly happened, but
15:19:01 <sinelaw> getting more and more coherent
15:19:05 <sinelaw> !markov 6
15:19:06 <yairchu> becomes a quoter basically
15:19:08 <psychobot> upload else-4.1.0.0 install syb-0.1.0.3 on hackage no, lambdabot will then no one refutes, how about their comments) Then it's working base and more like Bu
15:19:12 <BCoppens> !markov 26
15:19:15 <psychobot> h some random word-game I don't remember, and told me I'm totally not cool) @vixen hey, who did we fight in WWII besides Germany and Russia? maybe i should make the state be tw
15:19:24 <mreh> hey, take it somewhere else!
15:19:30 <thermoplyae> no, leave it right here
15:19:37 * BCoppens shuts up
15:19:37 <sinelaw> it's a haskell program!
15:19:43 <Berengal> Dissociated press just invented {-# LANGUAGE MultiParamTypeDeriving #-}...
15:19:54 <lament> i have a haskell yes, wanna see some sample output?
15:19:55 <sinelaw> i should get it to work in #haskell-blah
15:19:56 <mreh> kick it for flooding
15:20:09 <sinelaw> kick the people who flood using it
15:20:38 <drhodes> bot don't kick people, people kick people
15:21:02 <mreh> robot wars!
15:21:05 <kilimanjaro> !markov 3
15:21:08 <psychobot> ad) engal, if enanick out is on haskell traic ling it. gotta greem the seek their perve sticence, but i withough :) look prologic did it's not fool) -> [
15:21:19 <sinelaw> !markov bla
15:21:19 <psychobot> Plugin `markov' failed with: Prelude.read: no parse
15:21:22 <sinelaw> good.
15:22:17 <sinelaw> i think 5 is a good memory size for english
15:24:14 <Berengal> Could I ask you to test this: http://85.200.142.237:5000/ ?
15:24:40 <monochrom> You could. Now ask. :)
15:24:42 <sinelaw> Berengal, works for me
15:24:52 <monochrom> JK. I'm already visiting. :)
15:25:06 <ben> Yeah, seems to work~
15:25:13 <Berengal> Neat, only uses 1.8Mb of memory currently
15:25:33 <Berengal> And doesn't seem to grow much either
15:25:40 <Berengal> Yay continuations!
15:25:41 <monochrom> IMO do not need a separate "OK, let's reset. [continue]" page.
15:26:01 <Berengal> monochrom: No, it doesn't, but as you might guess, the simple counter isn't the point of the page
15:26:14 <monochrom> What does continuation buy you?
15:26:57 <Berengal> monochrom: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17174#a17174
15:28:27 <Berengal> monochrom: Does that answer your question?
15:28:42 <monochrom> Yes. Thanks.
15:29:46 <monochrom> In return I share with you http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6356  so you can reset while you reset. :)
15:31:55 <Berengal> monochrom: I thought about adding exceptions to it, but I'll have to do so in the result value of the ContT
15:32:13 <Berengal> I'm not too happy about exposing callCC...
15:34:21 <jmcarthur> djahandarie: i only uploaded a template that blindly goes west :P
15:34:37 <jmcarthur> i'm working on my real AI now
15:34:48 <copumpkin> jmcarthur: ADMIT IT, U SUCK
15:35:01 <jmcarthur> I SUCK I KNOW I CANT DO ANYTHING
15:35:16 <copumpkin> sad that it won a few games anyway
15:35:17 * BCoppens sings along: Go weeeest!
15:36:19 <monochrom> Berengal: My shallow thought says we should use the same ContT, the same callCC, to implement throwing exceptions, i.e., like your reset uses callCC, your catch uses the same callCC too. As for exposing callCC, that's up to you.
15:36:40 <jmcarthur> copumpkin: probably just other bots employing similar "strategies" to mine
15:38:01 <jmcarthur> copumpkin: my planned ai is actually a bit complex, so that means it will either win definitively or fail absolutely
15:38:19 <jmcarthur> and i won't even know for some time since i have to write the freaking thing first :\
15:38:25 <copumpkin> jmcarthur: nice! we already have a top-tenner
15:38:29 <copumpkin> we need moar
15:38:29 <lament> ai for what?
15:38:43 <jmcarthur> lament: http://csclub.uwaterloo.ca/contest/
15:38:46 <lament> oh
15:39:09 <jmcarthur> copumpkin: you should enter then
15:39:15 <copumpkin> jmcarthur: but I suck
15:39:29 <jmcarthur> surely not as much as 344 losses :P
15:39:54 <Berengal> monochrom: That would be possible, using something like what ezyang did in the recent reddit post
15:40:27 <Berengal> Or maybe not. Loops have linear control, but exceptions don't
15:51:13 <mreh> I can't renice this binary
15:52:09 <MissPiggy> ?
15:52:11 <mreh> I don't know if renicing will make it run faster
15:52:18 <MissPiggy> don't bother
15:52:18 <copumpkin> sounds mean
15:52:21 <mreh> I'm doing parallel haskell
15:52:34 <mreh> it's running at 102% processor
15:52:46 <copumpkin> doesn't sound very effective
15:52:55 <mreh> 60% percent overall usage
15:55:46 <mreh> I need more experience making programs parallel
15:56:25 <Saizan> http://scholar.google.com/scholar?cluster=17400282708793079285&hl=en&as_sdt=2000 <- should help
15:57:19 * MissPiggy nneds more experience on making programs WORK
15:59:35 <mreh> MissPiggy, when they compile they tend to work :)
15:59:43 <MissPiggy> hahahaha for you maybe
15:59:51 <Berengal> @quote main.advantage
15:59:51 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
16:00:00 <cjay> is there any hope for hs-plugins on ghc 6.12?
16:00:07 <MissPiggy> no it doesn't happen like for me
16:00:18 <MissPiggy> my code almost always typechecks first time
16:00:42 <Cale> mreh: Perhaps there's too many data dependencies between the things that you've sparked, so that it actually has to run single threaded anyway? Or perhaps you're sparking too many small things?
16:00:45 <Berengal> MissPiggy: You must be doing it wrong then
16:01:16 <MissPiggy> that's for sure
16:01:17 <mreh> Cale, its just a map
16:01:44 <Cale> mreh: Okay, and you have two processors?
16:01:48 <mreh> Cale: it spends 60% of its time in that map so I figured a parallel evaluation would work
16:01:51 <mreh> Cale: two cores
16:01:54 <Cale> okay
16:02:01 <Berengal> MissPiggy: I tend to write the types I want and the core functionality, then go about making it typecheck and replace the undefineds
16:02:06 <Cale> So you'll want the chunks to be fairly large
16:02:13 <Cale> (probably)
16:02:16 <mreh> Cale: really?
16:02:17 <Cale> How big is the list?
16:02:27 <mreh> Cale: 100 elements
16:02:40 <Cale> Break it into two 50's and see how that goes :)
16:02:43 <MissPiggy> Berengal yeah I do that, just without asking the compiler until it's done
16:03:04 <MissPiggy> and once it is done it probably typechecks but doesn't work
16:03:17 <Berengal> Needs moar types :P
16:03:58 <mreh> there's no parMap that chunks :(
16:04:20 <Cale> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:04:20 <Cale> parMap strat f = (`using` parList strat) . map f
16:04:37 <Cale> So you just need to do the same thing but with parListChunk instead
16:04:41 <mreh> parListChunk
16:04:41 <mreh> yes
16:04:44 <mreh> okay
16:05:15 <Berengal> mreh: Are you on linux?
16:05:30 <Berengal> Could it be last-core slowdown that's killing you?
16:05:41 <mreh> Berengal: yes
16:05:48 <mreh> Berengal: what are those?
16:05:50 <Cale> There is a bit of a problem with 2 cores on linux -- In general, GHC has trouble scheduling on the last core.
16:05:59 <MissPiggy> what do you mean ?
16:06:07 <Cale> But you can still get a performance boost sometimes.
16:06:11 <MissPiggy> everything has one type
16:06:29 <Cale> (I don't have much first-hand experience though.)
16:06:39 <arw> trouble scheduling on the last core? sounds broken?
16:06:45 <Berengal> It is
16:07:01 <Cale> I can't recall... does 6.12 fix this?
16:07:08 <Berengal> Sometimes you get only a minor speedup, mostly you get slowdowns
16:07:11 <Cale> Or is it supposed to be fixed for 6.14?
16:07:20 <Berengal> Cale: Not 6.12.1, but maybe in 6.12.2
16:07:24 <Cale> ah, okay
16:07:45 <mreh> I get a minor speedup
16:07:51 <Berengal> I've gotten 1500% slowdowns...
16:07:57 <MissPiggy> well how do I do it better?
16:08:02 <MissPiggy> that's what I want to know
16:08:10 <Cale> MissPiggy: What are you trying to do?
16:08:27 <mreh> Berengal, it's running on the two cores alright, just not very well :)
16:08:28 <Berengal> MissPiggy: newtypes, and when experimenting, type synonyms for ease of change
16:08:32 <MissPiggy> well I was trying to figure out what he meant
16:09:02 <Cale> MissPiggy: If you want more failures of usage to be type errors, you can newtype things as Berengal mentions.
16:09:21 <Berengal> Don't use simple products and sums except in small expressions
16:09:43 <mreh> I'm in 6.10
16:10:03 <Berengal> mreh: If you give me the program I can test it on my quad, to see if that's the problem
16:10:05 <MissPiggy> yeah but that doesn't make my program correct
16:10:15 <Cale> It can be a bit difficult to accomplish in some cases, but designing types so that code only fits together in sensible ways is something that you can strive to do.
16:10:30 <Cale> It doesn't guarantee correctness of course.
16:11:00 <Berengal> Usually, when you start out writing the types, you'll catch lots of errors even before you give it to the compiler. It's like compileable UML
16:11:15 <mreh> Berengal, okay, can I email you a tar?
16:11:52 <MissPiggy> omg I hate darcs
16:12:00 <Cale> MissPiggy: What's wrong with darcs?
16:12:02 <MissPiggy> why can't it just download the files??
16:12:12 <Cale> I hate that too. It's not just darcs.
16:12:13 <MissPiggy> why does it have to download 100000 diffs
16:12:16 <Berengal> mreh: Should work
16:12:57 <arw> if you want it to be fast, use git :)
16:13:27 <Cale> All the revision control systems do this stupid thing where instead of just transferring the entire repository as a single stream, they transfer the patches and then proceed to hammer on my CPU applying them all one by one since the last snapshot.
16:13:27 <MissPiggy> this:
16:13:28 <MissPiggy> user error (problem gzreading file /Users/quantum/Languages/Pig09/_darcs/patches/20091206213012-ff146-ceaddf0223616dc455fa434781c21abe91d81005.gz)
16:13:33 <MissPiggy> is rubbish
16:13:51 <MissPiggy> user error? I don't beleive I did anything wrong
16:14:03 <Cale> I would rather use bandwidth than CPU.
16:14:24 <Cale> MissPiggy: That just means an exception which is not system-defined
16:14:42 <MissPiggy> darcs diff just prints a newliine and nothing else
16:14:42 <Cale> MissPiggy: "User" as in the programmer who is using the exception library.
16:14:54 <MissPiggy> so does that error secretly mean that darcs get worked?
16:15:06 <MissPiggy> hmm there seems to be missing files though
16:15:41 <Cale> I'm not sure what that error means except that if that gz file can't be read, it probably didn't download correctly.
16:20:04 <mreh> Berengal, get it?
16:20:27 <MissPiggy> so
16:20:32 <MissPiggy> what to do is install darcs1
16:20:35 <MissPiggy> because darcs2 is broken
16:21:17 <sinelaw> Cale, hey
16:21:20 <sinelaw> did you get my patch?
16:21:41 <Kostafey> Is there are any biult-in function to transform list like this:
16:21:41 <Kostafey> [[1,2,3],
16:21:41 <Kostafey>  [4,5,6]]
16:21:41 <Kostafey> into:
16:21:45 <Kostafey> [[1,4],
16:21:47 <Kostafey>  [2,5],
16:21:51 <Kostafey>  [3,6]]
16:22:23 <damd> :t transpose
16:22:24 <lambdabot> forall a. [[a]] -> [[a]]
16:22:24 <psychobot> Not in scope: `transpose'
16:22:24 <sinelaw> @hoogle [[a]] -> [[a]]
16:22:25 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
16:22:25 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:22:25 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:22:37 <sinelaw> @source transpose
16:22:38 <lambdabot> transpose not available
16:22:42 <sinelaw> @src transpose
16:22:42 <lambdabot> transpose []             = []
16:22:43 <lambdabot> transpose ([]   : xss)   = transpose xss
16:22:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
16:22:54 <sinelaw> > transpose [[1,2,3],[4,5,6]]
16:22:55 <lambdabot>   [[1,4],[2,5],[3,6]]
16:22:59 <sinelaw> yip :)
16:23:32 <Twey> transpose ((x : xs) : xss) = (x : map head xss) : transpose (map tail xss)
16:23:45 <Twey> Hmm
16:24:08 <Twey> > transpose [[1, 2, 3], []]
16:24:09 <lambdabot>   [[1],[2],[3]]
16:24:19 <Twey> Ahh, I see
16:24:22 <Twey> LCs for safety
16:25:31 <dooof> in a project I've reimplemented the Monad class to add some type level restrictions. This works fine with do-notation as long as I stay in the module where it was defined, but not from another module. It works if I use >>= and >>, but not using do-notation. is there a way around this?
16:27:58 <Kostafey> hmm
16:27:59 <Kostafey> transpose ((x:xs):xss) = (x : map head xss) : transpose (map tail xss)
16:27:59 <Kostafey> Ambiguous variable occurrence "transpose"
16:27:59 <Kostafey> *** Could refer to: Main.transpose Data.List.transpose
16:28:19 <damd> Kostafey: yes? :/
16:29:10 <damd> oh, i see
16:30:25 <Kostafey> I'm crazy. It is built-in function :)
16:30:25 <nolrai_FG> @ty newSTRef
16:30:26 <lambdabot> forall a s. a -> ST s (STRef s a)
16:30:28 <Twey> Kostafey: import Data.List hiding (transpose) if you want to define a new function with that name
16:30:32 <Twey> But yes :þ
16:31:30 <sinelaw> !flush
16:32:05 <Kostafey> Thanks for all!
16:32:40 <MissPiggy> so about GHC?
16:33:05 <MissPiggy> how do you know all about where it (& cabal) puts everything so you can fix whatever goes wrong with it?
16:34:00 <Cale> MissPiggy: If you install everything as user (and you should), it all goes into ~/.cabal
16:34:20 <ben> Why should you?
16:34:33 <Cale> You can see a list of installed packages by running ghc-pkg list
16:34:53 <Cale> (and manage installed packages with other options to the same command)
16:35:18 <Cale> You can remove packages using ghc-pkg, but it unfortunately doesn't remove the associated files.
16:35:57 <Cale> Thankfully, the installations of each package are separated nicely by ghc version. Usually when I upgrade GHC, I take the time to clean out old installs.
16:36:12 <Cale> (but it doesn't amount to much disk space anyway)
16:37:10 <MissPiggy> when I upgrade usually stuff breaks :|
16:37:39 <Cale> Such is the nature of the upgrade.
16:40:45 <tensorpudding> software sucks, let's go shopping
16:41:42 <Cale> It's hard to remember the last time I did a major upgrade of anything without causing at least a little bit of breakage.
16:42:04 <Botje>  
16:42:55 <MissPiggy> I dont get this
16:43:05 <MissPiggy> I just installed ghc-6.12.1, and bootstrap.sh thinks I don't have parsec
16:43:15 <tensorpudding> there are lots of upgrades that don't break things, depending on your definition of upgrade
16:43:27 <tensorpudding> does installing security updates count as an upgrade?
16:43:57 <Cale> MissPiggy: Where'd you install it from?
16:44:11 <Cale> MissPiggy: I recommend *always* installing GHC from the binary package.
16:44:18 <MissPiggy> yeah I did
16:44:26 <Cale> Also, you should upgrade cabal to the latest version before installing the new GHC.
16:44:34 <MissPiggy> I didn't have any ghc before
16:44:48 <Cale> okay
16:44:58 <Cale> So ghc-pkg list parsec
16:45:23 <Cale> 6.10.4 at least comes with 2.1.0.1
16:45:38 <Cale> I don't know about 6.12, since I'm not using it yet.
16:47:13 <MissPiggy> now Configuring Cabal-1.6.0.2...
16:47:13 <MissPiggy> Setup: failed to parse output of 'ghc-pkg dump'
16:47:34 <MissPiggy> what the heck
16:49:13 <MissPiggy> maybe if I install Cabal-1.6.0.2 manually
16:49:49 <byorgey> MissPiggy: what version of ghc? 6.12.1?
16:49:56 <MissPiggy> yes
16:50:10 <byorgey> only Cabal-1.8 works with 6.12.1
16:50:17 <byorgey> and cabal-install 0.8
16:50:51 <MissPiggy> so should I do darcs get --partial http://darcs.haskell.org/cabal/ ?
16:51:20 <byorgey> no, don't use darcs, get it from Hackage
16:51:24 <byorgey> http://hackage.haskell.org/package/Cabal
16:51:39 <byorgey> and http://hackage.haskell.org/package/cabal%2Dinstall
16:51:57 <MissPiggy> okay
16:51:59 <MissPiggy> thanks
16:56:52 <copumpkin> !markov
17:00:49 <interferon> is there a tool that will take a large amount of haskell source and give me either a hyperlinked pdf or hyperlinked set of html files?  something like doxygen for C-family languages
17:01:43 <MissPiggy> I think lhs2TeX can ? well not sure exactly about the hyperlinks but haddock does that
17:01:52 <MissPiggy> haddock is how they generate those documents I am pretty sure
17:04:40 <interferon> cool thanks
17:04:49 <interferon> looking for a good way to read all of Yi...
17:05:51 <MissPiggy> hahaha
17:05:51 <MissPiggy> cabal: cannot configure QuickCheck-2.1.0.3. It requires ghc -any
17:05:51 <MissPiggy> There is no available version of ghc that satisfies -any
17:05:56 <MissPiggy> what a silly error
17:06:18 <MissPiggy> interferon maybe configure your editor to do the hyperlink stuff?
17:06:24 <MissPiggy> so then you can just look at it in an editor
17:06:43 <interferon> i'd like to get it onto my phone for reading during my commute
17:07:59 <dolio> Whew, finally finished Awodey.
17:08:30 <jlouis> dolio: his cat theory book?
17:08:34 <dolio> Yes.
17:08:48 <dolio> The chapter on monads and algebras was slimmer than I was expecting.
17:08:52 <jlouis> dolio: then you are ready for Mac Lane :P
17:10:18 <dolio> Yeah, I nabbed a copy of that.
17:10:31 <dolio> Looks like it actually talks about (co)ends, so that's nice.
17:10:45 <copumpkin> does it talk about coends at the beginning?
17:10:47 <copumpkin> or at the end?
17:11:11 <dolio> At the end.
17:11:20 <dolio> Chapter 9 of 10.
17:25:03 <kmc> @quote dreaded
17:25:03 <lambdabot> No quotes match. I feel much better now.
17:25:30 <MissPiggy> @quote
17:25:30 <lambdabot> ksf says: is Data.Data.Data some kind of reference to swedish chefs?
17:26:09 <VTimage> !tutorial
17:26:16 <VTimage> ~tutorial
17:26:23 <bob0> @quote main.advantage
17:26:23 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
17:26:27 <Axman6> @where lyah
17:26:27 <lambdabot> http://www.learnyouahaskell.com/
17:26:31 <VTimage> @tutorial
17:26:32 <lambdabot> Unknown command, try @list
17:26:32 <Axman6> VTimage: ^^^^^^^^^^^^^^^
17:26:53 <bob0> that's better than being incorrect the first 1000 times you try to run them!
17:26:56 <VTimage> SANKYUU!
17:27:04 <VTimage> Axman6
17:27:53 <MissPiggy> lol
17:28:06 <MissPiggy> @quote
17:28:06 <lambdabot> swiert says: Of course! Who can live without covariant homfunctors?
17:29:15 <VTimage> @quote
17:29:15 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
17:29:15 <lambdabot> trigger.
17:29:54 <alise> cabal: cannot configure Agda-2.2.6. It requires base ==4.2.* && ==4.2.* For the dependency on base ==4.2.* && ==4.2.* there are these packages: base-4.2.0.0. However none of them are available. base-4.2.0.0 was excluded because of the top level dependency base -any
17:29:59 <alise> halp
17:31:08 <copumpkin> #agda!
17:32:12 <sfuentes> can someone explain to me why this fails:
17:32:46 <sfuentes>  "my foot is a big foo" =~ "(foo.?)" :: [String]
17:32:53 <VTimage> LYAH is written by someone who lives in Slovenia?
17:32:57 <MissPiggy> > "my foot is a big foo" =~ "(foo.?)" :: [String]
17:32:58 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
17:32:58 <lambdabot>                    ...
17:33:23 <Twey> VTimage: I'm tempted to insert a suicide joke here, but I think it would be tasteless
17:33:28 <MissPiggy> > "my foot is a big foo" =~ "(foo.?)" :: Bool
17:33:29 <lambdabot>   True
17:33:30 <MissPiggy> > "my foot is a big foo" =~ "(foo.?)" :: String
17:33:31 <lambdabot>   "foot"
17:33:46 <MissPiggy> hm
17:33:50 <sfuentes> i'm trying to get a list of all the captures
17:33:57 <MissPiggy> yeah I don't see how you do that
17:34:11 <MissPiggy> in perl just while loop around it
17:34:35 <mauke> > "my foot is a big foo" =~ "(foo.?)" :: [[String]]
17:34:37 <lambdabot>   [["foot","foot"],["foo","foo"]]
17:34:46 <mauke> > "my foot is a big foo" =~ "foo.?" :: [[String]]
17:34:47 <lambdabot>   [["foot"],["foo"]]
17:35:42 <sfuentes> interesting ... but why do they have to be lists of lists of strings?
17:36:44 <mauke> this is basically perl's m//g
17:36:57 <mauke> every match has a list of captures, and there are multiple matches
17:37:32 <sfuentes> aww. i see.
17:37:45 <sfuentes> thank you
17:38:17 <VTimage> Did the Slovenes ever fight the Croatians?
17:38:19 * hackagebot upload: data-ordlist 0.2 - Set and bag operations on ordered lists (LeonSmith)
17:38:22 <VTimage> In a war?
17:41:44 <cads> possibly not but they would beat them in paper scissors rock or russian roulette, hands down.
17:42:23 <Twey> http://irena.blog.siol.net/files/2008/07/grafit.jpg
17:43:46 <VTimage> how would they beat them is rus roulette?
17:43:48 <VTimage> in
17:44:56 <Twey> VTimage: At the cost of a large portion of the population
17:45:54 <VTimage> Why are Slovenes so suicidal?
17:46:16 <VTimage> Slovenia ranks number 4 on the list of countries by suicide rate.
17:47:12 <Twey> ‘One day, God saw a man sitting on a hillside and crying.  Feeling benevolent, He approached the man, and said, “There there, life can't be so bad!”.  The man ignored him and just kept on crying.  Growing frustrated, God said, “Look here, man: don't you know who I am?”  The man looked up, and said, “Yes; don't you know who I am?”  God replied, “No; who are you?”  The man answered, “I'm a Slovene”, and God began to cry too.’
17:47:49 <mauke> don't cry, bosnian kid
17:48:12 <p_l> VTimage: which is first?
17:49:04 <Twey> VTimage: It's because their language is crazy
17:49:57 <physique> is this a haskell channel or a slovenian history channel
17:50:02 <VTimage> Because they are all depressed?
17:50:09 <VTimage> And sad?
17:50:38 <MissPiggy> physique both!
17:50:46 <cads> physique, ask us a question about either!
17:50:56 <MissPiggy> :t either
17:50:57 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:50:57 <Philonous1> haskell is actually slovenian for "off topic"
17:51:54 <dbelange> Hey guys, how do you define a mobar in CT
17:52:04 <MissPiggy> I would love to know what a mobar is
17:52:09 <MissPiggy> and CT?
17:52:18 <dbelange> ya
17:52:29 <dolio> CT is an abbreviation for "court" in road names.
17:52:30 <Axman6> category theory MissPiggy
17:52:56 * copumpkin wonders what mobar is
17:53:03 * aep only knows xmobar
17:53:08 <dbelange> ya
17:53:15 <dbelange> so its like a monad i think
17:53:45 <aep> its.. a bar
17:54:11 <dbelange> is that like an arrow lol
17:54:27 * Axman6 doesn't know what an arrow lol is
17:54:58 <alise> what's the easiest way to get 6.10 on ubuntu 9.04? any repo?
17:55:17 <copumpkin> class Cat lol => Arrow lol
17:55:48 <MissPiggy> @hoogle Mobar
17:55:48 <lambdabot> No results found
17:55:50 <dbelange> so how do u define a mobar it isnt on wikipedia
17:56:06 <mauke> dbelange: I have no idea what that is
17:56:08 * MissPiggy never heard of one
17:56:08 <mauke> can you explain?
17:56:46 <dolio> I've never heard of a mobar, either.
17:57:00 <dbelange> its what xmobar uses like i said it is like a monad i think
17:57:01 <dolio> Are they like buttfors?
17:57:10 <copumpkin> :O
17:57:29 <aep> heh
17:57:31 <mauke> do you have any updog?
17:57:55 <mreh> what's updog?
17:58:01 <mreh> oh noes, I fell for it!
17:58:11 <aep> dolio: xmobar is xmonad+bar  and xmonad is x + monad. totally unrelated
17:58:20 <aep> dbelange: ^
17:58:33 <dbelange> Category theory < universal algebra
17:58:37 <aep> there is no mobar in math. its just a name
17:58:42 <aep> wait..
17:58:46 <copumpkin> dbelange: no?
17:58:52 * aep facepalms for falling for it
17:59:03 <copumpkin> wow, that's an odd troll
17:59:07 <kilimanjaro> :)
17:59:25 <kilimanjaro> (we were talking about xmonad in #not-math, that prompted him)
17:59:27 <tensorpudding> who came up with the name category?
17:59:41 <mauke> gory cats
17:59:48 <tensorpudding> was it in the original paper by eilenburg (sp?) and mac lane?
17:59:56 <copumpkin> berg
18:00:07 <tensorpudding> eilenberg, sry
18:00:14 <aep> hmm.  ["1".."12"] doesnt work at all, does it?
18:00:20 <aep> too bad
18:00:28 <mauke> > map show [1 .. 12]
18:00:29 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10","11","12"]
18:00:32 <tensorpudding> > "foo" > "bar"
18:00:33 <lambdabot>   True
18:00:48 <aep> right! thanks
18:01:34 <tensorpudding> hmm
18:01:56 <tensorpudding> so String is Ord but not Enum?
18:02:12 <Axman6> > "foo" > "bar" > "baz" > "quux"
18:02:13 <lambdabot>   Precedence parsing error
18:02:13 <lambdabot>      cannot mix `GHC.Classes.>' [infix 4] and `GHC...
18:02:16 <Axman6> :(
18:02:32 <Axman6> > ("foo" > "bar") > ("baz" > "quux")
18:02:33 <lambdabot>   True
18:02:47 <tensorpudding> hmm?
18:02:51 <tensorpudding> > True > False
18:02:51 <lambdabot>   True
18:03:00 <tensorpudding> > True > True
18:03:00 <lambdabot>   False
18:03:36 <mauke> heh, (>) is non-associative in perl, too. I wonder how common this is
18:03:36 <tensorpudding> does it really make sense for Bool to have an Ord definition?
18:03:52 <tomberek> if something is of type a->a , can that take functions.  Or is (a->a)->a->a needed?
18:04:01 <mauke> tensorpudding: yes
18:04:19 <tensorpudding> tomberek: it can
18:04:42 <tensorpudding> @type id :: (a -> a) -> (a -> a)
18:04:43 <Axman6> tomberek: (a->a) -> a -> a === (a->a) -> (a->a)
18:04:43 <lambdabot> forall a. (a -> a) -> a -> a
18:04:50 <alise> [01:54] <alise> what's the easiest way to get 6.10 on ubuntu 9.04? any repo? :/
18:05:06 <tomberek> sweet... it seemed that way from quick testing with ghci, but i wanted to make sure that the "a" really meant anything
18:05:12 <tensorpudding> mauke: what is it used for?
18:05:20 <Berengal> alise: Download the binaries
18:05:27 <Berengal> It's in the 9.10 repos too
18:05:33 <alise> Berengal: I know the latter. thanks
18:05:40 <mauke> tensorpudding: well, using them as Map keys is one application
18:06:09 <mauke> tensorpudding: oh, and array indices
18:06:16 <mauke> Ix is a subclass of Ord
18:06:17 <tomberek> Axman6, tensorpudding, so an a->b can take a function and return another function?    I was worried about problems with kinds.
18:06:22 <tensorpudding> that sounds a bit odd
18:06:47 <mauke> tensorpudding: any instance of Enum has an obvious instance of Ord
18:06:48 <alise> Berengal: no .deb
18:06:49 <Axman6> tomberek: a -> b can take anything and return anything
18:06:53 <alise> I'll just checkinstall
18:07:08 <Berengal> alise: No, there's no .deb, just a regular tar.gz
18:07:15 <mauke> tomberek: functions are values. every value has a type of kind *
18:07:26 <VTimage> Can somone answer my question, why are Slovenians so suicidal?
18:07:35 <mauke> VTimage: how is that a haskell question?
18:07:41 <Axman6> VTimage: no, that has absolutely nothing at all to do with this channel
18:07:52 <tensorpudding> VTimage: no ethnotrolling please
18:08:22 <mauke> is steamtrolling ok?
18:08:37 <Axman6> steam iz 4 loozrz!
18:08:43 <alise> what's the difference in the -n linux binary version?
18:08:55 <tomberek> Axman6,mauke: thanks!
18:10:05 <copumpkin> btw, left 4 dead is awesome in versus mode
18:10:25 <tensorpudding> only haskelltrolling is on topic here
18:10:30 <copumpkin> oh
18:12:15 <Axman6> wow, i just got my first IRL spam ever :O
18:12:24 <copumpkin> yeah?
18:12:29 <Axman6> from "Domain Renewal Group"
18:12:35 <copumpkin> oh I've had those
18:12:48 <Axman6> i bought my domain, axman6.com, through nearlyfreespeach.net
18:13:00 <copumpkin> yeah, they don't sell your stuff
18:13:02 <copumpkin> but the records are public
18:13:03 <Axman6> these guys want me to pay $45 for my domain renewal XD
18:13:09 <Axman6> yeah
18:13:16 <copumpkin> I really like nfs
18:13:20 <copumpkin> but I use a VPS now
18:14:07 <tensorpudding> spammers rhyme with scammers
18:14:14 <tensorpudding> also with spanners
18:14:21 <copumpkin> mmm spanners
18:14:24 <tensorpudding> they're all tools
18:28:37 <mreh> haskell left for dead tourney?
18:28:48 <mreh> actually I didn't *buy* the game :X
18:29:05 <mreh> L4D2 is 30
18:29:09 <mreh> !!!!
18:29:50 <Becquerel> !!!!
18:30:01 <Runar> > cycle '!'
18:30:02 <lambdabot>   Couldn't match expected type `[a]'
18:30:03 <lambdabot>         against inferred type `GHC.Types...
18:30:14 <monochrom> > cycle "!"
18:30:14 <mauke> repeat
18:30:15 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:30:25 <Runar> drat
18:30:37 <monochrom> > repeat '!'
18:30:38 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
18:30:45 <Runar> I get those two confused
18:31:58 <mreh> :t repeat
18:32:00 <lambdabot> forall a. a -> [a]
18:32:00 <mreh> :t cycle
18:32:02 <lambdabot> forall a. [a] -> [a]
18:32:19 <mreh> you cycle a list,  repeat an element
18:33:10 <Axman6> @src cycle
18:33:11 <lambdabot> cycle [] = undefined
18:33:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
18:33:29 * Axman6 would have thought cycle [] = [], but oh well
18:38:43 <tromp> it is really just fox ([]++)
18:38:52 <tromp> which is undefined
18:38:56 <mauke> @let fox = fix
18:38:57 <lambdabot>  Defined.
18:39:07 <tromp> sorry, typo
18:39:23 <tromp> so the first line in definition is redundant
18:39:31 <tromp> i guess for clarity?
18:39:53 <gwern> somewhere, neils bohr is watching us; unobserved and immortal
18:40:14 <jiggaman> U need help in C++ anyone can help ppleeeasee ??
18:40:27 <lament> unobserved and immoral
18:40:35 <jiggaman> I need help in C++ can anyone help pleaseee !! ?
18:40:43 <gwern> jiggaman: no
18:40:52 <gwern> jiggaman: we must all work out our own salvation
18:41:43 <gwern> or damnation, in your case
18:42:02 <gwern> @quote C++
18:42:02 <lambdabot> Spark says: i think the rule of thumb is that sets that fuck up the entirety of mathematics are not considered to be valid sets
18:42:06 <monochrom> Is ##c++ the channel for c++?
18:42:19 <jiggaman> I need help in C++ can anyone help pleaseee !! ?
18:42:22 <gwern> monochrom: 'twould seem so
18:42:34 <monochrom> Then jiggaman may like to know.
18:42:42 <alise> Why are we being trolled so frequently ?
18:42:44 <alise> *frequently?
18:42:44 <gwern> monochrom: no, he's just being a drama queen
18:43:04 <gwern> anyone with 2 neurons to rub together would realize #haskell is the wrong place to ask for c++ help
18:43:14 <jiggaman> Thanks monochrom.
18:43:19 <cp2>  whats a haskell
18:43:23 <gwern> monochrom: and ##c++ will just ban him anyway for asking for homework help
18:43:26 <alise> i'm a single-neuroned organism
18:43:43 <gwern> c++ destroys all their reservoirs of good will
18:43:46 <monochrom> I'm 0.999-neuroned
18:43:46 <gwern> and humanity
18:44:04 <alise> i'm 0-neuroned
18:44:16 <cp2> bitches dont know 'bout my neuron count
18:44:19 <alise> i have one tiny little neuro-connector thingymagic, though
18:44:23 <alise> it spontaneously developed intelligence
18:44:25 <jiggaman> your an IDIOT gwern get a life .
18:44:42 <monochrom> haha
18:44:43 <alise> --says the guy asking for C++ help in #haskell.
18:44:57 <gwern> alise: says the guy who wants help on IRC but just quit IRC :)
18:45:03 <tensorpudding> seems that #haskell is having a classy day
18:45:20 <alise> gwern: that's just idiocy, idiocy in fact correlates highly with "having a life"
18:45:25 <gwern> tensorpudding: I move we break out the flamethrowers and order a ration of grog for all hands
18:45:38 <alise> I want extra grog in my grog!
18:45:52 <gwern> I think grog in your grog just makes you groggier
18:46:07 <gwern> (inasmuch as it means more alcohol)
18:46:08 <tensorpudding> !botsnack
18:46:18 <tensorpudding> oh, psybot disappeared
18:46:29 <cp2> if a grog could grog grog, how much grog would a grog grog? grogrgorofgorgfoobarasdadasdasf
18:46:34 <MrBlueSky> I think there is a misprint or something of the sort in the Learn You a Haskell tutorial that could really throw people off. (It's throwing me off as I'm reading it.) Somebody mind taking a look at it and telling me if it's correct?
18:46:36 <MrBlueSky> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#derived-instances
18:46:47 <alise> Ingredients of grog: kerosene, propylene glycol, artificial sweeteners, sulphuric acid, rum, acetone, red dye no. 2, scumm, axle grease, battery acid, and/or pepperoni, and grog.
18:46:48 <MrBlueSky> This example code:   # Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
18:46:48 <MrBlueSky> # Vector 148 666 222
18:47:21 <MrBlueSky> I don't think that code executes because it adds a vector and an int using a function that only takes two vectors
18:47:23 <Cale> > cake
18:47:24 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
18:47:36 <mauke> MrBlueSky: where?
18:47:58 <Axman6> mauke: that link doesn't seem to have that ocde in it
18:48:04 <MrBlueSky> mauke: the last line in the black code box above "derived instances"
18:48:10 <gwern> cp2: how seals could be squealed upon if a seal could squeal on seals that steal seals seals sealed
18:48:12 <mauke> Axman6: scroll up
18:48:19 <mauke> MrBlueSky: I see the code, but where's the error?
18:48:36 <cp2> gwern: but who was phone?
18:48:50 <gwern> cp2: phone? there are no phones in the seals' seal factory!
18:48:50 <Axman6> mauke: yeah, that does look like a typo
18:49:05 <gwern> cp2: you're not the real cp2 at all! what have you done with her?
18:49:06 <tensorpudding> hmm, that is a problem
18:49:20 <tensorpudding> probably should be vectMult instead of scalarMult
18:49:21 <Axman6> BONUS_: you around?
18:49:29 <cp2> gwern: i was unaware that i previously had a vagina
18:49:32 <MrBlueSky> Yeah, that's what I'm thinking. I'll contact the writer about it
18:49:38 <tensorpudding> actually, hmm
18:49:40 <gwern> cp2: bluffing won't work. I know the truth now
18:49:41 <cp2> althought, that thought intrigues me
18:49:44 <mauke> hello?
18:49:45 <monochrom> MrBlueSky: The example is correct.
18:49:48 <MrBlueSky> 0:
18:49:51 <Axman6> MrBlueSky: BONUS_ is the author
18:49:51 <tensorpudding> no that's right
18:49:54 <mauke> where is this error you're talking about?
18:50:05 <monochrom> "Vector 2 9 3" is one single thing.
18:50:10 <jmcarthur> ugh, the google ai contest is using ghc 6.8 on the server, but i can't even get 6.8 to install locally!
18:50:12 <tensorpudding> the vectMult type sig is Vector -> t -> Vector t
18:50:20 <Axman6> oh, so it is
18:50:21 <tensorpudding> and the scalarMult returns a t
18:50:26 <mauke> tensorpudding: that's a kind error
18:50:39 <gwern> jmcarthur: ai contest?
18:50:42 <jmcarthur> and i need it because i was going to use unamb, which as far as i know doesn't have a version that will work for both 6.8 and 6.12 (what i have installed)
18:50:45 <monochrom> "data Vector a = Vector a a a" the RHS says that Vector wants 3 argument. 2,9,3 are the 3 arguments.
18:51:03 <tensorpudding> yes
18:51:07 <Cale> Heh, why don't they just run GHC 5.02?
18:51:10 <jmcarthur> gwern: http://csclub.uwaterloo.ca/contest/
18:51:17 <jmcarthur> Cale: ugh
18:51:24 <tensorpudding> i thought the error was that vectMult had the wrong arguments for its type
18:51:47 <Cale> I think 5.02 was the version that was current when I first got GHC.
18:51:59 <MrBlueSky> Oh right. I see what I was doing wrong now
18:52:07 <Cale> Either that or 5.00.2
18:52:08 <jmcarthur> has anybody ever had a "permission denied" error when trying to run ghc's configure script?
18:52:17 <MrBlueSky> Thanks for the clear-up!
18:52:21 <sjanssen> preflex: seen dons
18:52:21 <preflex>  dons was last seen on #haskell 2 days, 5 hours, 52 minutes and 23 seconds ago, saying: it is bizarre.
18:52:25 <gwern> jmcarthur: is tron that hard? it seems simple enough that someone ought to have discovered an optimal solution
18:52:49 <sjanssen> wow, looks like dons is on IRC even less than I am nowadays
18:52:53 <Cale> jmcarthur: I think that can happen if you get the wrong version.
18:53:13 <sjanssen> dons: darcs repo for your download/download-curl packages?
18:53:13 <jmcarthur> wrong version?
18:53:18 <jmcarthur> of what?
18:53:24 <Cale> jmcarthur: Specifically 64 vs. 32 bit
18:53:37 <Cale> I'm not certain about that though.
18:54:03 <Cale> jmcarthur: Which package did you get?
18:54:03 <Axman6> sjanssen: because he's down under, with all us cool people
18:54:11 <Axman6> blackdog: you around?
18:54:14 <jmcarthur> huh, got it to work by moving the source dir out of my tmpfs
18:54:19 <jmcarthur> that's dumb
18:54:45 <gwern> 'Some possible ideas include trying to fence off as much territory as possible, so that you can outlive your opponent' yes, that sounds like the optimum strategy. you and the enemy race for the middle and whomever reaches the 51% mark and turns first wins
18:54:52 <gwern> kind of like go on the smaller boards
18:54:59 <gwern> the winning move is tengen
18:55:13 <jmcarthur> gwern: but they are setting up some really weird maps
18:55:23 * Axman6 only recently learnt how to play go
18:55:32 <jmcarthur> for example, some are dense mazes, some are huge, some have tons of obstacles
18:55:51 <gwern> jmcarthur: oh really? hm. that might complicate figuring out the midway point and how to construct the most efficient closed figure
18:56:05 <gwern> Axman6: good, then you can appreciate my analogy!
18:57:27 <Axman6> gwern: not sure what your analogy is about though...
18:58:22 <gwern> Axman6: oh. try playing gnu go on 9x9 or smaller boards; make your first move tengen. you'll find that you can win by building a vertical/horizontal wall - the boards are small enough that the ai can't play in your territory without risking a net-loss
18:58:37 * Axman6 doesn't know what tengen is
18:58:42 <gwern> Axman6: center point
18:58:48 <Cale> In order to score various options for moving, you could do Monte-Carlo simulation past a given point, where the players play somewhat or entirely randomly. This is what they're doing to create fairly effective go opponents these days.
18:58:50 <Axman6> aah ok
18:59:00 <sjanssen> preflex: seen ndm
18:59:00 <preflex>  ndm was last seen on #haskell 273 days, 16 hours, 40 minutes and 19 seconds ago, saying: plus with current compiler technology, it would be slower
18:59:03 <sjanssen> wow
18:59:25 <gwern> Axman6: since no matter where the opponent plays after tengen, he's in a 'smaller' section of the board
18:59:43 * Axman6 needs to play more go
19:00:09 <Cale> The problem with tengen is that it doesn't really represent any territory on anything larger than 9x9
19:00:18 <Cale> It's pure influence.
19:01:14 <gwern> Cale: sure, but my belief is that tengen is still the best move >9x9. it's just harder
19:01:19 <Cale> hmm...
19:01:33 <Cale> I'm not sure that's necessarily the case.
19:01:38 <gwern> because the further away from the walls you get, the weaker the value of tengen gets. but it never flips sign
19:02:40 <gwern> (humans may never play well enough to handle tengen better than a more straightforward move closer to a wall, but god would, if you follow)
19:02:45 <Cale> I think the optimal starting move is among {3,4,5}^2
19:03:08 <Cale> And probably not 3,3
19:03:09 <gwern> but yeah, that's my opinion. I don't have any proof except I don't see how tengen can win on 9x9 and smaller but not win on larger
19:03:28 <Cale> See, the tengen on 9x9 isn't just tengen
19:03:38 <Cale> It's also the 5,5 point for all four of the corners.
19:04:25 <gwern> jmcarthur: interesting, it loosk like my idea is called 'floodfill' and is already being used by high-scorers
19:05:17 <gwern> Cale: tengen is a corner for all odd boards if you want to look at it like that, isn't it?
19:05:44 <Cale> Well, it gets farther and farther from affecting the corners as you move to larger board sizes.
19:06:00 <Cale> 6,6 is already a stupidly high move on 19x19.
19:06:43 <tromp> but not on 9x9:)
19:07:02 <gwern> as I said, tengen loses value as the size increases, but I'm not convinced any other spot gains enough value as to overtake it
19:07:21 <McManiaC> why is (:=) interpreted as a type constructor??
19:07:26 <gwern> (on an infinite board, every spot is tengen)
19:07:37 <MissPiggy> because of :
19:07:48 <Cale> On 9x9, (6,6) is also (4,4)
19:08:30 <Cale> gwern: In the opening, the corners have the highest value.
19:08:38 <Cale> Because you already have two of your walls built.
19:08:55 <Cale> But if you make the corner too large, it can be invaded.
19:09:16 <dankna> even 4-4 is meant to exert influence inward towards the center rather than outward towards the corner
19:09:32 <tromp> tengen is known to be optimal up to 7x7
19:09:34 <dankna> because 4-4 followed by opponent invasion at 3-3 gives the corner to the opponent
19:09:42 <Cale> Already with (4,4), there's an invasion at (3,3) which is bad in the opening (gives too much influence), but useful later on if the influence it would give the opponent becomes less valuable.
19:10:17 <bd_> tengen may be nicer from a theoretical point of view, but there's also the point of view that since corner openings are easier to understand, if you've not fully solved the game for the given board width, it may be better to go for the corners :)
19:10:24 <gwern> hm. so that would implie that different shaped boards would have different sizes at which tengen ceases to be good
19:10:36 <dankna> I like bd's comment, haha
19:10:46 <gwern> bd_: well, I already said that
19:10:49 <dankna> I've seen very little study of triangular or hexagonal Go
19:11:00 <bd_> gwern: Hm, I should scroll up more often :)
19:11:12 <tromp> they're less interesting without the crosscuts
19:11:19 <dankna> logical
19:11:28 <dankna> now what is intriguing is toroidal Go
19:11:28 <gwern> dankna: yeah, triangular go should have stronger tengen if I'm following Cale right - each corner is harder to link out 'past' tengen
19:11:36 <gwern> while hexagonal go would have much weaker tengen
19:11:52 <gwern> (wonder how much computing power the 7x7 tengen proof uses...)
19:11:56 <dankna> that makes sense intuitively, but it would be fun to play some small games of it to verify that experimentally :)
19:11:59 <tromp> tengen also considered best in hex
19:12:01 <Cale> (4,4) is a balance between territory and influence, (5,5) is pure influence with not much room for territory, and (3,3) is pure territory and very solid, but not very large
19:12:30 <Cale> (3,4) is the old idea of the optimal move in the corner.
19:12:52 <gwern> Cale: in human go. but human go changes over time. hence komi adjustments or even the historical growth in boards - iirc tibetan chinese play started on either 15x15 or 17x17 boards and moved to 19x19 as players got better
19:13:03 <dankna> beginners like myself very often play 4-4 for no reason other than that it's marked on the board :)
19:13:21 <Cale> Yeah. There is something natural about 19x19 though. Go on larger boards than that becomes a very different game.
19:13:36 <gwern> Cale: 21x21 is that much different?
19:13:51 <dankna> yeah, kind of an equilibrium between aesthetics, or at least I'd like to think so
19:14:03 <Cale> Well, 19x19 strikes a particular balance between the importance of influence and territory.
19:14:06 <gwern> dankna: no doubt the old 17x17 players would say as much :)
19:14:11 <dankna> haha no doubt
19:15:30 <Cale> It's a consequence of how things work out along the edges, and the proportion of how many points are available in the centre vs. the edges and corners.
19:18:02 <Cale> But who knows.
19:18:17 <tromp> on 20x20, 3rd line territory is closest to center (204 vs 196)
19:18:32 <dankna> another interesting subject is whether, if we get a program that can beat a 9-dan on a 19x19 board, it could continue to do so on larger boards.
19:19:57 <tromp> pros are very much focussed on 19x19, so would see drop in strength when moving to larger
19:20:08 <dankna> well, true.
19:20:08 <dmwit> ...initially
19:20:18 <tromp> they'd have to toss out lots of their fuseki knowledge
19:20:28 <dankna> yeah, certainly
19:20:31 <dmwit> s/toss out/adjust/
19:20:42 <dmwit> Very much too much binary statements happening here.
19:21:10 <tromp> not that computers are any good at fuseki:)
19:21:14 <Berengal> We should adapt balanced trinary
19:21:18 <Rotaerk> test
19:21:25 <dankna> response
19:21:25 <tromp> the best ones are merely trained on pro fuseki play:)
19:21:40 * Axman6 wonders what the most efficient way to represent a go board is using bits. feels that 2 bits per position is wasteful
19:22:01 <Berengal> Axman6: An array of trits
19:22:11 <tromp> even trit is wasteful
19:22:22 <Berengal> Not if you can represent them properly
19:22:29 <dmwit> The most space-efficient method is an index into the list of all possible boards.
19:22:34 <dmwit> However, that is not very time-efficient.
19:22:34 <Berengal> There have been trinary computers
19:22:37 <dmwit> As always, there's a tradeoff.
19:22:44 <tromp> only 1.2% of 3^361 positions is legal:)
19:22:59 <Axman6> > 3^361
19:23:00 <lambdabot>   174089650659031927907188238070564367946602724950263541194828118706801051676...
19:23:07 <Axman6> > 3^361 * 0.012
19:23:08 <dmwit> Axman6: misleading
19:23:08 <lambdabot>   2.089075807908383e170
19:23:17 <Cale> tromp: How do you count the number of legal positions?
19:23:20 <sjanssen> > logBase 2 (3^361)
19:23:20 <lambdabot>   572.1714627603374
19:23:23 <dmwit> > 361 * logBase 2 3
19:23:24 <lambdabot>   572.1714627603375
19:23:32 <Cale> (or, what is that estimate based on?)
19:23:38 <tromp> number of legal 19x19 is 2.081681994 * 10^170
19:23:52 <tromp> see http://homepages.cwi.nl/~tromp/go/legal.html
19:24:02 <tromp> only know exact up to 17x17
19:24:06 <Axman6> > 19*19
19:24:07 <lambdabot>   361
19:24:19 <gwern> tromp: are all legal boards reachable?
19:24:24 <tromp> yes
19:24:33 <tromp> just insert passes eveywhere
19:24:43 <Cale> Oh, neat :)
19:24:46 <gwern> ah. I always forget about being able to pass
19:24:59 <Axman6> you can pass?
19:25:08 <dmwit> yes
19:25:14 <dmwit> The standard way to end the game is via two passes.
19:25:20 <dmwit> Though that's just a protocol.
19:25:29 <dmwit> The game *really* ends exactly when both players agree it is over. =)
19:25:30 <gwern> for some reason I keep thinking of a model of go where the game ends when there are no legal moves and the winner is whomever has most net stones; and that passing &territory counting is just a shortcut
19:26:05 <tromp> known as no-pass go
19:26:11 <MissPiggy> im writing a haskell program instead of perl
19:26:14 <MissPiggy> that's new
19:26:16 * gwern is not surprised it exists
19:26:33 <gwern> tromp: ok, so in no-pass go are all legal boards reachable? :)
19:26:43 <tromp> that's how ppl like berlekamp study go endgames in detail
19:27:04 <dmwit> I'm not sure I see how no-pass go and captures interact.
19:27:08 <tromp> i think not, gwern
19:27:16 <dmwit> There must be some kind of self-atari rule or something...?
19:27:25 <dmwit> But that seems as though it would also change some life-or-death problems.
19:27:33 <MissPiggy> @hoogle base
19:27:34 <lambdabot> package base
19:27:34 <lambdabot> Text.Html base :: String -> HtmlAttr
19:27:34 <lambdabot> Text.XHtml.Frameset base :: String -> HtmlAttr
19:27:37 <MissPiggy> @hoogle int
19:27:37 <lambdabot> Text.PrettyPrint.HughesPJ int :: Int -> Doc
19:27:38 <lambdabot> Language.Haskell.TH.PprLib int :: Int -> Doc
19:27:38 <lambdabot> module Data.Int
19:28:41 <gwern> http://senseis.xmp.net/?NoPassGo
19:28:48 <tromp> i found counterexample, gwern
19:28:58 <tromp> on 3x1 board
19:29:06 <tromp> you cannot reach B.B
19:29:46 <gwern> tromp: you mean, that's a legal board which cannot be reached under no-pass, but can under pass?
19:30:05 <tromp> yes
19:30:13 <gwern> good example
19:30:21 <tromp> smallest:)
19:30:23 <gwern> (wonder how much no-pass cuts down the board space)
19:30:42 <tromp> you men number of legal positions?
19:31:14 <gwern> yes
19:31:21 <tromp> not much
19:31:45 <tromp> i'm sure still 1.2% of 19x19 would be reachable
19:32:05 <tromp> you'd need many more decimals to notice i guess
19:32:08 <gwern> (let's see what http://www.daogo.org/download/computer_go_13.pdf has to say about no-pass rules)
19:32:48 <lament> omg you're talking about go
19:33:11 <tromp> we should really move the discussion to #go :)
19:33:11 <Cale> tromp: You should make a Folding@Home style distributed version of your board counting algorithm for 19x19 :)
19:33:23 <tromp> it doesn't distribute well at all
19:33:34 <gwern> lament: is that a problem?
19:33:40 <Cale> Hmm, that's too bad
19:33:40 <tromp> needs tons of memory and diskspace
19:33:44 <dmwit> What kind of compute time do you need for 19x19?
19:33:51 <tromp> it's a giant mapreduce problem
19:34:03 <gwern> tromp: no point - I'm just about at my limits. I play 11x11 on my handheld and sometimes read sensei's library and that's about it :)
19:34:14 <tromp> well, you can distribute different moduli
19:34:28 <tromp> pick 10 relatively prime numbers around 2^64
19:34:47 <tromp> then count independently legal modulo those numbers
19:34:55 <tromp> and combine with chinese remainder theorem
19:35:29 <tromp> but each modulus needs like 10TB on a dozen workstations with each maybe 16GB
19:35:38 <tromp> 10TB disk space
19:35:47 <tromp> then compute for months
19:35:52 <Cale> Yeah, that's still much too large
19:35:54 <gwern> 10tb each or total?
19:36:05 <tromp> each modulus needs 10TB
19:36:13 <tromp> shared by the workstations
19:36:36 <gwern> bleh. so a bit beyond your random hacker's resources unless they want to do it on EC2 or something
19:36:46 <dmwit> hm, months of compute time -- I don't envy you the debugging experience
19:36:47 <tromp> basically, you're manipulating a vector of size 363B
19:36:52 <dmwit> step
19:36:52 <dmwit> step
19:36:54 <dmwit> step
19:37:15 <gwern> dmwit: presumably if you write your code right, you can test on the small boards and it'll work on the first 19x19 run
19:37:26 * dmwit nods
19:37:33 <dmwit> I was being slightly facetious. =)
19:37:33 <tromp> it's been thoroughly tested up to 17x17 :)
19:38:08 <gwern> some bored googler could probably do it in a few minutes
19:38:40 <tromp> not quite
19:38:59 <tromp> i have friends at google. once asked them to try 13x13 on their mapreduce
19:39:08 <tromp> performed  very bad:(
19:39:13 <gwern> oh
19:39:20 <gwern> why?
19:39:31 <tromp> he never looked into that
19:40:06 <tromp> i think the communication overheads were relativelt large
19:40:13 <tromp> for that (small) problem size
19:40:56 <tromp> my program is a very specialized mapreduce
19:41:47 <tromp> i hope to do the 19x19 computation within 5 years or so
19:43:29 <ezyang> I'm reading sigfpe's latest post, and I'm a little confused why 0+b = a
19:43:33 <gwern> isn't that a little depressing
19:43:38 <gwern> 5 years
19:45:11 <tromp> that kind of computer power is still not very available for cheap
19:45:24 <tromp> and i left academia
19:45:48 <tromp> you have a supercomputer to spare:-?
19:46:13 <gwern> mm. 10TB of hard drive space is sub 1k now
19:46:17 <ezyang> "please sir, may I have more?"
19:46:19 <tromp> go has been around over 3000 years. what's another 5?
19:46:46 <tromp> in 5 years, 10TB SSD may even be affordable
19:46:53 <gwern> what? no way
19:46:54 <ddarius> tromp: If you can supply power to it, shapr practically does.
19:47:08 <gwern> not unless ssd prices fell grotesquely while I wasn't looking
19:47:22 <gwern> unless by affordable you mean >1k
19:47:23 <tromp> by affordable i mean under $10k
19:47:55 <gwern> mm. 10k, maybe. I'd have to run the numbers. but 5 years gets you only2 or 3 halvings
19:48:01 <dmwit> You would spend $10k to count the number of possible go boards?
19:48:07 <tromp> sure
19:48:18 <dankna> for $10k I will count them by hand
19:48:21 <tromp> i'll be plenty useful after i finish counting:)
19:48:24 <tromp> it'll
19:48:25 <dmwit> dankna: You're on.
19:48:27 <dankna> hehe
19:48:30 <dmwit> dankna: I'll pay you when you're done.
19:48:34 <dankna> damn!
19:48:37 <dmwit> dankna: Hell, I'll pay you half when you're half done.
19:48:46 <ddarius> dankna: Just give a number, how's he going to check?
19:48:47 <dankna> does my answer have to be accurate?
19:48:56 <dankna> haha, small minds run in small circles
19:48:56 <tromp> you can check by doing another modulus
19:48:57 * dmwit prepares his 10^140-payment plan
19:49:17 <tromp> maybe just a small modulus around 2^16 to make it faster
19:49:34 * ddarius has several gigs of papers.
19:49:35 <ezyang> Hm, it seems to me that with enough clever mathematics you could get a precise number by hand
19:49:42 * dankna also has several gigs of papers
19:49:54 <dankna> papers are very useful things to keep around
19:50:00 <kmc> @quote ##c\+\+
19:50:00 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
19:50:01 * dmwit waits for tromp to smack ezyang down
19:50:09 <tromp> i strongly doubt t, ezyang
19:51:15 * ddarius has a really old darcs.
19:51:34 <dankna> you should be using a recent darcs, they've been busy
19:52:20 <ddarius> It's not one that I am using.  It's darcs 1.0.7 for Windows.
19:52:32 <dankna> ah, okay
19:53:21 <ezyang> hmm, I see some papers putting upper bounds for the number of positions
19:53:50 <dmwit> ezyang: http://homepages.cwi.nl/~tromp/go/legal.html
19:54:00 <dmwit> ezyang: (Linked by tromp earlier, in case you missed it.)
19:54:35 <dmwit> Try clicking on the 19 link for more goodness.
20:01:21 <djahandarie> Cale, ping, you around?
20:02:14 <ezyang> dmwit: Heh, cool.
20:02:28 <MissPiggy> is there something in haskell for "32423" --> Just 32423 and "#%(@*&#%" --> Nothing?
20:02:58 <tromp> > read  "32423" :: Int
20:02:58 <lambdabot>   32423
20:03:08 <tromp> > read  "*@^*(#" :: Int
20:03:09 <lambdabot>   * Exception: Prelude.read: no parse
20:03:16 <tromp> @src read
20:03:16 <lambdabot> read s = either error id (readEither s)
20:03:33 <MissPiggy> @hoogle readEither
20:03:33 <lambdabot> No results found
20:03:39 <MissPiggy> @index readEither
20:03:39 <lambdabot> bzzt
20:03:49 <tromp> :t readS
20:03:50 <lambdabot> Not in scope: `readS'
20:04:05 <tromp> :t ReadS
20:04:06 <lambdabot> Not in scope: data constructor `ReadS'
20:04:32 <tromp> @hoogle ReadS
20:04:33 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
20:04:33 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
20:04:33 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
20:04:40 <pikhq> :t readEither
20:04:41 <lambdabot> Not in scope: `readEither'
20:04:47 <MissPiggy> :t reads
20:04:48 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:04:52 <pikhq> Where is that defined?
20:04:58 <MissPiggy> aha!
20:05:48 <tromp> what lambdabot finds functions given type?
20:06:06 <MissPiggy> I think hoogle tries
20:06:14 <tromp> @hoogle [a] -> Maybe a
20:06:14 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
20:06:15 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
20:06:15 <lambdabot> Prelude head :: [a] -> a
20:06:33 <tromp> so just apply that after reads
20:06:33 <MissPiggy> :t listToMaybe . map fst . reads
20:06:34 <lambdabot> forall a. (Read a) => String -> Maybe a
20:06:43 <MissPiggy> @let readM = listToMaybe . map fst . reads
20:06:44 <lambdabot>  Defined.
20:06:46 <MissPiggy> :t readM
20:06:47 <lambdabot> forall a. (Read a) => String -> Maybe a
20:07:56 <pikhq> @src listToMaybe
20:07:57 <lambdabot> listToMaybe []        =  Nothing
20:07:57 <lambdabot> listToMaybe (a:_)     =  Just a
20:08:11 <pikhq> Ah.
20:09:35 <dmwit> I'm not sure that readMaybe is more convenient than reads.
20:09:51 <dmwit> I've written it a few times myself... then scrapped it and gone back to reads because the code ends up being shorter.
20:27:03 <MissPiggy> program is so close to working except for Prelude.foldr1: empty list
20:27:07 <MissPiggy> haha this is frustrating
20:27:55 <tensorpudding> why are you using foldr1?
20:28:02 <MissPiggy> yikes how come getLine doesnt let me delete
20:28:12 <MissPiggy> tensorpudding it's to turn [a,b,c] into a + b + c
20:28:26 <ddarius> You should turn it into a+b+c+0
20:29:41 <tensorpudding> in general, if you're folding over a list with a monoidal operation like (+) you should use foldr instead
20:30:12 <monochrom> This indicates a deeper problem in the program.
20:30:27 <MissPiggy> I did what ddarius said
20:32:16 <tensorpudding> > let mySum lst = foldr1 (+) (0:lst) in mySum []
20:32:16 <lambdabot>   0
20:32:30 <MissPiggy> god damn this not allowing delete is so annyong!
20:32:37 <dmwit> :t sum
20:32:38 <lambdabot> forall a. (Num a) => [a] -> a
20:32:55 <dmwit> ann-yong!
20:33:15 <dino-> :src sum
20:33:21 <dmwit> ?src sum
20:33:22 <lambdabot> sum = foldl (+) 0
20:33:22 <dino-> @src sum
20:33:22 <lambdabot> sum = foldl (+) 0
20:33:30 <tensorpudding> uses foldl hmm
20:34:30 <dino-> I need to read the rules for the lambdabot commands. When to use :, @ or ?
20:35:05 <dmwit> Use ? or @ except for :t, :k, and >.
20:35:24 <ddarius> And :t is @type, :k is @kind and > is @run
20:35:42 <dino-> I see, just those few chosen to be close to ghci
20:36:29 <dmwit> right
20:37:19 <dino-> I wonder if that lazy sum ever gets out of control on anyone.
20:37:20 <Cale> djahandarie: What's up?
20:38:00 <Cale> dino-: It can cause stack overflows in unoptimised programs, but it compiles to a strict version when optimised.
20:38:00 <djahandarie> Cale, hi. I was looking at your HRSS script that you have on your site and I'm having trouble compiling it.
20:38:12 <Cale> djahandarie: I wrote that a long time ago now.
20:38:16 <djahandarie> Yeah, I noticed
20:38:29 <djahandarie> Cale, if you were to redo it what would you use?
20:38:37 <Cale> Um, I might use HXT still.
20:38:53 <Cale> But I don't know how that library has changed since.
20:39:16 <Veinor> I got this trying to install xmonad from the Ubuntu repositories:
20:39:16 <Veinor> haddock: internal Haddock or GHC error: Data.Binary.getWord8: end of file
20:40:17 <Veinor> hm, nevermind, fixed it
20:40:56 <monochrom> I don't understand what's wrong with "getLine does not delete". Not the job of getLine.
20:41:36 <MissPiggy> good grief
20:41:37 <MissPiggy> > let a = ((3:/1):+(0:/1)) in a*a
20:41:38 <MissPiggy> (0 :/ 1) :+ (0 :/ 1)
20:41:38 <lambdabot>   Not in scope: data constructor `:/'Not in scope: data constructor `:/'
20:41:40 <MissPiggy> this is happening AGAIN
20:41:46 <MissPiggy> I actually fixed this
20:42:39 <dmwit> > let a = ((3%1) :+ 0) in a*a
20:42:40 <lambdabot>   No instance for (GHC.Float.RealFloat (GHC.Real.Ratio t))
20:42:40 <lambdabot>    arising from a ...
20:42:51 <dmwit> ?src RealFloat
20:42:51 <lambdabot> Source not found. :(
20:43:14 <monochrom> sounds like Complex wants RealFloat
20:43:30 <dmwit> :t (:+)
20:43:32 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
20:43:44 <dmwit> I find this strange.
20:44:19 <MissPiggy> here is what I have now:
20:44:20 <MissPiggy> > (1 + x) * (1 + x)
20:44:20 <MissPiggy> Just (0 + 1 * 1 + 2 * x * 1 + 1 * x * x * 1)
20:44:21 <lambdabot>   (1 + x) * (1 + x)
20:44:42 <monochrom> This was written at a time when people thought putting constraints right at the data type was a good idea.
20:44:53 <MissPiggy> data Rational a = a :/ a deriving (Show)
20:44:55 <MissPiggy> that's what I use
20:44:59 <MissPiggy> and data Complex a = a :+ a deriving (Show)
20:45:35 <MissPiggy> > (x + (y + z) * w) * (p + y + w)
20:45:36 <MissPiggy> Just (0 + 1 * p * w * y * 1 + 1 * p * w * z * 1 + 1 * p * x * 1 + 1 * w * x * 1 + 1 * w * y * z * 1 + 1 * w * y * y * 1 + 1 * w * w * y * 1 + 1 * w * w * z * 1 + 1 * x * y * 1)
20:45:36 <lambdabot>   (x + (y + z) * w) * (p + y + w)
20:45:44 <MissPiggy> lambdabot isn't expanding it
20:45:50 <MissPiggy> but mine does
20:47:00 <dmwit> Even if you were to put the constraint right at the data type, RealFloat just seems like the wrong constraint.
20:47:05 <MissPiggy> I need to figure a better ordering for polynomials because this comes out with  1 + 5x + 10x^2 + 10x^3 + 5x^4 + x^5 (in a slightly less readable way)
20:47:32 <MissPiggy> oh wait that's a fine way to have it
20:51:44 <MissPiggy> well it's nice to have something that does something now, even if the output is practically unreadable
20:54:09 <MissPiggy> I want to make what I have (3 files ~ 40 lines each) as good as possible before moving on
20:54:14 <lpsmith> So is there a nice way to write quickcheck tests for a cabalized library and specify that the package doesn't depend on quickcheck unless you specifically want to test it?
20:54:25 <MissPiggy> but I don't really know how
20:57:08 <MissPiggy> any tips?
20:59:17 <monochrom> The implementation of Complex (/) and abs uses RealFloat methods. It seems to want to mitigate underflow and overflow. For example in sqrt(x^2+y^2) it would suck if x^2 were too big (but final answer should fit easily). So RealFloat methods are used to find exponents, scale down, calculate, scale up.
21:01:04 <dufflebunk> > -1 .|. -2 :: Int32
21:01:05 <lambdabot>   -1
21:01:17 <dufflebunk> Shouldn't that be -3, or am I messing up twos compliment?
21:01:29 <dmwit> ?quickcheck \x -> -1 .|. x == (x :: Int32)
21:01:29 <lambdabot> Unknown command, try @list
21:01:30 <Cale> > -1 .&. -2 :: Int32
21:01:31 <lambdabot>   Precedence parsing error
21:01:31 <lambdabot>      cannot mix `Data.Bits..&.' [infixl 7] and pre...
21:01:35 <dmwit> ?check \x -> -1 .|. x == (x :: Int32)
21:01:36 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int32)
21:01:36 <lambdabot>    arising from a...
21:01:38 <Cale> > (-1) .&. (-2) :: Int32
21:01:39 <lambdabot>   -2
21:01:42 <Cale> > (-1) .|. (-2) :: Int32
21:01:43 <lambdabot>   -1
21:01:53 <Cale> Seems sensible to me
21:01:59 <dmwit> Anyway, -1 is all ones, so -1 .|. x == -1
21:02:00 <Cale> -1 is all 1's
21:02:12 <dufflebunk> doh, I was screwing it up
21:02:15 <dufflebunk> thanks
21:07:48 <MissPiggy> how can you design the program so that all the typeclasses and stuff are right?
21:09:39 <monochrom> By (talent or experience) and hard work.
21:10:27 <MissPiggy> all I have is  hard work
21:10:31 <monochrom> I take the question to mean "good modularity"
21:11:01 <monochrom> If the question means just "passes typechecking", it just needs logic.
21:11:15 <MissPiggy> it typechecks
21:12:09 <monochrom> Then wait for one day you have a USB 5.0 port on your brain. Then I can just download mine to you.
21:12:16 <MissPiggy> :)
21:12:59 <monochrom> Keep asking yourself "can it be simpler?" "can it be so simple it's obviously correct?"
21:13:10 <MissPiggy> well :P
21:13:12 <MissPiggy> I am asking myself that
21:13:20 <MissPiggy> but there is nobody answering
21:13:54 <monochrom> You start looking for other people's code and how they do similar things.
21:14:15 <MissPiggy> oh yeah I will read some of the stuff on hackage
21:14:48 <jmcarthur> conal: so, umm, say i'm trying to use unamb with ghc 6.8... the last version that work with 6.8 is 0.0.1. that version number scares me, especially considering that unamb had some sort of reliability issues or something early on, if i recall correctly... i'm i begging for trouble?
21:15:58 <monochrom> haha version 0.0.1
21:16:30 <MissPiggy> jmcarthur do you know about computation monad (as an alternative to unamb)
21:16:58 <jmcarthur> MissPiggy: no i don't
21:17:11 <aavogt> I would like to know about this "computation monad" too
21:17:14 <jmcarthur> although unamb sounds a lot more convenient than a monad, to me
21:17:32 <MissPiggy> (co)data Computation a = Now a | Later (Computation a)
21:17:41 <jmcarthur> oh that
21:18:08 <MissPiggy> of course it's a monad, and you can define various functions on _in particular you can define least fixed point by racing omega-many computations_ (that comes from this paper somewhere..)
21:18:29 <MissPiggy> (1) you can write unamb with this in the obvious way
21:18:44 <MissPiggy> (2) recursive functions defined by lfp on this are 'more lazy' than haskell functions
21:18:52 <jmcarthur> what type does unamb have with that?
21:19:57 <MissPiggy> unamb :: Computation a -> Comptuation a -> Computation a
21:20:18 <MissPiggy> anyway you probably don't need to use unamb at all if you write programs in the computation monad
21:20:28 <jmcarthur> probably not
21:20:49 <jmcarthur> the unamb package would be so much more convenient though :(
21:20:57 <jmcarthur> is there a hackage package for the computation monad?
21:21:00 <MissPiggy> yeah I don't really like unamb
21:21:13 <MissPiggy> or memotrie
21:21:22 <jmcarthur> it took a loooooong time for unamb to grow on me
21:21:27 <MissPiggy> I get that they are useful and work and stuff
21:21:30 <jmcarthur> what's wrong with memotrie?
21:21:35 <MissPiggy> but im some kind of theorist
21:22:21 <copumpkin> MissPiggy: what is your background?
21:22:29 <copumpkin> as in, what brought you to haskell etc.
21:25:03 <MissPiggy> because it's a programming language and I am compelled to study them for some reason unknown to me
21:25:12 <copumpkin> ah, fair enough
21:25:38 <MissPiggy> I'm just some kid realyl, not a reseacher or anything
21:25:51 <monochrom> Two Haskellers knocked on my door and preached to me. I read their colourful pamplet "you could have invented Haskell too" and my brain exploded.
21:25:55 <copumpkin> :)
21:26:32 <dufflebunk> I was teased with the gateway drug called Miranda in university
21:26:54 <aavogt> miranda looks very similar
21:27:01 <dufflebunk> and then they taught java for the next 3 years
21:27:06 <copumpkin> sad
21:27:18 <MissPiggy> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:math
21:27:21 <copumpkin> I don't mind java but I certainly don't like it
21:27:25 <MissPiggy> what's the best written one[s]?
21:31:18 <dolio> Miranda was a precursor to Haskell.
21:31:48 <dolio> Haskell actually could have been Miranda, but the original author of the latter wanted to retain control.
21:34:25 <dufflebunk> I still write [x:xs] in my pattern matches
21:36:28 <lpsmith> Well,  Haskell benefited a great deal from the fact that it was designed specifically to kill off about a dozen or so similar languages
21:36:53 <lpsmith> It had a "customer base" basically from the start
21:39:51 <pikhq> Haskell benefitted greatly from being designed and designated as the successor to those dozen or so similar languages, really.
21:40:05 <MissPiggy> Haskal!!!
21:40:23 <pikhq> Which is why there are so very few extant lazy languages...
21:40:55 <aavogt> they were all subsets of haskell?
21:41:06 <pikhq> aavogt: No.
21:41:27 <pikhq> But the designers of each came together to create Haskell.
21:41:34 <pikhq> With Haskell getting the best features of each.
21:41:35 <aavogt> or other features were left out (say patterns that backtrack)
21:47:42 <mreh> haskell still doesn't have that strong a user base, everyone thinks its an academic language
21:48:01 <Adamant> mreh: it's userbase is pretty strong for a functional-ish language
21:48:57 <mreh> it's not marketed towards any specific solution either, because people reckon that Java is *actually* better at doing certain things
21:49:03 <mreh> for example
21:49:54 <Adamant> where's the example? :P
21:50:18 <mreh> Java was my example
21:50:21 <pikhq> ... Java, better at doing things?
21:50:22 <Adamant> so, Java has been mostly displaced in the applet role by Flsh
21:50:28 <Adamant> *Flash
21:50:29 <dufflebunk> Any Enterprisy thing ;)
21:50:37 <pikhq> Oh, right.
21:50:42 <mreh> all those monstrous Enterprise architectures
21:50:43 <pikhq> Well, that's true.
21:50:46 <Adamant> it's niche is "enterprise" stuff.
21:50:46 <lament> java has pretty awesome tools
21:50:47 <mreh> miles of boilerplate
21:50:49 <pikhq> Java makes everything Enterprise.
21:51:00 <aavogt> preflex: seen jmcarthur
21:51:01 <preflex>  jmcarthur was last seen on #haskell 29 minutes and 31 seconds ago, saying: what's wrong with memotrie?
21:51:15 <pikhq> mreh: The architectures would be pared down greatly by a few simple introductions to the language.
21:51:27 <pikhq> Like "lambda" and "a type system".
21:51:35 <pikhq> Particularly lambda, though.
21:51:38 <mreh> haha
21:51:47 <mreh> you mean anonymous functions?
21:51:58 <aavogt> jmcarthur: which channel did you name here: http://csclub.uwaterloo.ca/contest/forums/viewtopic.php?f=9&t=65#p323
21:52:03 <pikhq> Most of the so-called "design patterns" are really just hacks to pretend you have closures.
21:52:08 <pikhq> mreh: Yes.
21:52:36 <mreh> yeah, visitor pattern strikes me as one of those
21:52:49 <pikhq> RAII as well.
21:53:13 <pikhq> Which technically we do in Haskell every time we write withFoo $ \bar -> ...
21:53:30 <Adamant> hey, GC is pretty widely used at this point.
21:53:37 <Adamant> maybe lambdas will be next.
21:53:51 <pikhq> Adamant: Yes, C++ is pretty much the remaining holdout at this point.
21:53:59 <jmcarthur> aavogt: #googleai
21:53:59 <Adamant> pikhq: C++ and Java
21:54:02 <pikhq> (C has valid reasons to not have GC)
21:54:11 <pikhq> ... Java... Has garbage collection.
21:54:23 <Adamant> pikhq: I was thinking lambdas :P
21:54:25 <Adamant> sorry
21:54:28 <pikhq> Ah.
21:54:37 <pikhq> Yeah, Java is the holdout now.
21:54:46 <Adamant> I know there's a proposal for them in both C++ and Java
21:54:49 <pikhq> (C++ has them, they're just not commonly available yet)
21:55:03 <aavogt> thanks jmcarthur
21:55:05 <Adamant> ah, so it did go into the new standard
21:55:06 <pikhq> In C++, it's part of the next standard.
21:55:20 <pikhq> GCC 4.4 adds support for them.
21:56:31 <erikc> lambdas without gc are pretty gimped, only good for downward closures and metaprogramming
21:57:05 <erikc> i suppose it'll be make stl algorithms tolerable at least
21:57:06 <pikhq> erikc: Which is why C++ needs to add garbage collection.
21:57:21 <pikhq> Still, it does make STL algorithms usable.
21:58:00 <pikhq> std::foreach(foo.begin(), foo.end(), [](auto x){x++;}); // This is actually usable. Hallelujah.
21:58:09 <erikc> precise gc will require real rtti
21:59:09 <erikc> it's a vicious chain of concessions that will take the committee 10 years to cave on and work out, then another 10 for widespread implementation
21:59:17 <pikhq> C++0x also adds some support for garbage collection.
21:59:29 <lament> perhaps C++ shouldn't add garbage collection?
21:59:32 <pikhq> Though most of that support consists of "Make Boehm's job easier".
21:59:38 <lament> perhaps people should use another language instead? :\
21:59:49 <erikc> lament: i agree
21:59:56 <MissPiggy> what do you think of this: data Term op = V String | O (Maybe op) (Term op) (Term op) ?
22:00:13 <MissPiggy> the idea is that it represents a applicative with variables
22:00:20 <MissPiggy> language with variables*
22:00:22 <pikhq> (Pointers that are actually accessible must be declared as such, otherwise it's undefined behavior. Things that mangle pointers, like xor, are undefined behavior.)
22:00:34 <dmwit> MissPiggy: Looks fine, though the Maybe is a little strange.
22:00:56 <pikhq> lament: These people think that C++ is a decent language. They will never use a different one.
22:01:11 <pikhq> Though they may, after enough additions, *get* a decent language.
22:01:18 <pikhq> ... With more cruft than Perl.
22:01:40 <lament> when people think something, they're usually right
22:01:48 <lament> so i guess it must be a decent language after all
22:01:53 <solrize> c++ needs subtractions, not additions ;)
22:02:01 <QtPlatypus> pikhq: C++ will greenspun into common lisp.
22:02:06 <pikhq> solrize: C++ needs replacements.
22:02:06 <lament> at work, i'm using "objective C++"
22:02:24 <erikc> they'll either get run out of business by nimbler competitors or their application/platform base is enough to ward off competitors, in which case they'll live on at great expense to their customers
22:02:24 <lament> thankfully in practice this means objective C while avoiding all C++ features
22:02:25 <pikhq> QtPlatypus: It's type system is halfway there.
22:02:37 <pikhq> lament: Why are you using that awful GCC hack, exactly?
22:03:01 <lament> what hack?
22:03:04 <ttvd> hi, is there a fast way to OR list of Bools ? other than doing map with or
22:03:08 <QtPlatypus> pikhq: Is that a good or bad thing?
22:03:11 <dmwit> :t or
22:03:12 <lambdabot> [Bool] -> Bool
22:03:15 <dmwit> ttvd: ?
22:03:23 <dmwit> ttvd: Did you mean this?
22:03:23 <pikhq> QtPlatypus: Terrible thing.
22:03:24 <dmwit> :t any
22:03:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:03:26 <pikhq> lament: Objective C++.
22:03:32 <solrize> there aren't any languages in widespread use that capture the good parts of c++ while leaving out the bad parts
22:03:42 <ttvd> dmwit, I am stupid
22:03:42 <ttvd> thanks
22:03:43 <pikhq> solrize: Sure there are. C.
22:03:53 <pikhq> And *heavy* dosages of macros.
22:03:55 <dmwit> ttvd: In times like these, hoogle can help!
22:04:01 <dmwit> ?hoogle (a -> Bool) -> [a] -> Bool
22:04:02 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
22:04:02 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
22:04:02 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
22:04:05 <erikc> lament: do you work on any non-apple platforms with obc-c++?
22:04:09 <lament> pikhq: working with a C++ framework, have to interface
22:04:19 <lament> erikc: no, i don't think anyone does that
22:04:24 <pikhq> lament: Ah, so the reason for Objective C++'s existence.
22:04:42 <lament> pikhq: right, except, even Apple uses it internally
22:05:03 <lament> perhaps they simply have a bunch of C++ programmers
22:05:10 <pikhq> *Ugh*.
22:05:22 <pikhq> Need to beat them with a Smalltalk stick.
22:05:28 <lament> i like objective C a lot more, it's pretty neat
22:05:42 <pikhq> It's C with Smalltalk's object system.
22:05:48 <lament> though half the time i wish it were python instead
22:05:59 <pikhq> Small, simple language + small, simple language = larger, not-too-bad language.
22:06:19 <lament> objective c is similar to python in a way, but far far more verbose
22:06:57 * pikhq kinda wishes that Apple would do as Etoile has, and make a Smalltalk that uses Objective C's object system directly.
22:06:58 <lament> verbose python with inline C
22:07:07 <Adamant> I think Obj-C++ is basically only used for Mac drivers.
22:07:23 <Adamant> well, 'Embedded" Obj-C++
22:07:26 <lament> pikhq: i dunno, i think having inline C balances out the syntactic disadvantages
22:07:43 <tumult> Adamant: core audio
22:07:44 <lament> c is just pleasant
22:07:51 <pikhq> lament: That's what you use Objective C for.
22:07:52 <lament> it feels like home :)
22:07:56 <erikc> obj-c++ would be a really nice evolutionary step for a lot of C++ dev, but a portable implementation (maybe clang?) will be needed first
22:08:07 <pikhq> You write one of the methods in Objective C instead of Smalltalk is all.
22:08:15 <pikhq> erikc: GCC.
22:08:15 <Adamant> tumult: good point, I don't play around with that stuff much.
22:08:20 <erikc> the lack of a common object model is devastating to game dev
22:08:56 <pikhq> erikc: It's one of GCC's frontends, and GCC is exceptionally portable.
22:10:39 <lament> erikc: obj-c++ is not a step up from anything
22:10:52 <MissPiggy> is type Natural = Integer -- {1,2,3,4,5,..}
22:10:59 <lament> it's a nightmare thing with two coexisting and completely different object systems
22:11:00 <MissPiggy> better, or newtype Natural = Natural Integer?
22:11:57 <hiredman>    I didn't know such a beast as obj-c++ existed
22:12:03 <hiredman> sounds really gnarly
22:12:31 <lament> incestuous union
22:12:37 <pikhq> hiredman: It's pretty simple, though.
22:12:57 <pikhq> Objective C is a strict superset of C. You take the things Obj-C adds to C, and add them to C++ instead.
22:13:39 <hiredman> and then strip the parst of C++ no one likes out? (the oop stuff)
22:13:59 * ddarius wonders what this has to do with Haskell.
22:14:25 <sfuentes> to me obj-c and obj-c++ are practically mac dev tools
22:14:29 <MissPiggy> Subjective Haskell++
22:14:46 <hiredman> I recall seeing a presentation from some llvm dev who said something like "llvm uses a sane subset of c++" and the whole room guffawed
22:14:49 <tensorpudding> openstep uses obj-c
22:15:05 <pikhq> sfuentes: Obj-C is a NeXTstep dev tool.
22:15:19 * MissPiggy can't decide if + is commutative or not
22:15:19 <sfuentes> that would be a minority, no?
22:15:25 <pikhq> As it just so happens, OS X is NeXTstep.
22:15:51 <pikhq> Obj-C++ is a straight OS X dev tool, though.
22:15:54 <sfuentes> pikhq: that would be stretching things ... like saying os x is freebsd
22:16:10 <pikhq> sfuentes: Not really.
22:16:13 <Adamant> sfuentes: there's GNUStep
22:16:17 <pikhq> More like saying OS X is UNIX.
22:16:26 <pikhq> Which of course it is.
22:16:56 <solrize> there's a pretty good article comparing c++ templates to haskell polymorphic typing... it concluded c++ templates were more powerful in some relevant ways.  SPJ, Chak et al added type families to haskell partly in response to that article
22:18:47 <pikhq> C++ templates are just lambda...
22:18:53 <pikhq> Well, bit more than that.
22:18:56 <pikhq> They also pattern match.
22:22:01 <mxyz> so whats the story with how bad the RWH index is?
22:23:42 <MissPiggy> I wish typeclasses were <= instead of =>
22:25:54 <mxyz> if you bought RWH, does oreilly offer a pdf version?
22:27:30 <Amagineer> Test?
22:27:40 <Amagineer> Can anybody hear me?
22:27:42 <mxyz> Test Failed
22:27:46 <mxyz> No
22:27:49 <Amagineer> Thanks
22:27:51 <sfuentes> i bought rwh but i didn't get a pdf
22:27:52 <mxyz> :)
22:28:09 <mxyz> yea, i just checked and they offer it for $5 more if you get the book
22:28:24 <mxyz> i bought the book from amazon so i guess i cant get the pdf without paying full proce fo rit
22:28:27 <sfuentes> personally, i don't see why i have to pay $5 extra
22:28:33 <mxyz> i agree
22:29:48 <sfuentes> BONUS: you around?
22:30:56 <mjrosenb> does haddock havethe ability to generate man pages?
22:34:59 <sfuentes> I think http://learnyouahaskell.com/ is gggreeeeattt!!
22:35:34 <sfuentes> call me tony
22:36:00 <xerox> ?faq does haddock havethe ability to generate man pages?
22:36:00 <lambdabot> The answer is: Yes! Haskell can do that.
22:36:39 <mxyz> ?faq why is the RWH index so bad?
22:36:39 <lambdabot> The answer is: Yes! Haskell can do that.
22:39:38 <MissPiggy> do you think divide should be Maybe ? if you try to divide 0
22:41:52 <ddarius> Freakin' fields and their non-algebraic nature.
22:41:58 <Gracenotes> determining if a denominator will ever be 0 is surprisingly easy
22:42:16 <xerox> ddarius O_o
22:42:28 <Gracenotes> and in many cases, you know it not to be. so a tradeoff there.
22:42:36 <Veinor> aw man, xmonad isn't working :(
22:43:31 <Veinor> installed ubuntu netbook remix -> took updates -> sudo apt-get install xmonad, failure
22:43:32 <mxyz> so div by 0 in haskell is infinity?
22:43:39 <mxyz> should it be NaN?
22:44:02 <Veinor> > 0/0
22:44:03 <lambdabot>   NaN
22:44:05 <Gracenotes> dividing by zero is defined in ieee floating point, for sure. But not for integers in any real sense
22:44:11 <medfly> > 0 `div` 0
22:44:13 <lambdabot>   * Exception: divide by zero
22:44:19 <Gracenotes> hm
22:44:46 <Gracenotes> > (1 :+ 1)/0 :: Complex Double
22:44:47 <lambdabot>   NaN :+ NaN
22:44:52 <mxyz> ghci says infinity. no exception
22:45:32 <Veinor> Complex needs directed infinites
22:46:59 <xerox> I'll take the riemann sphere.
22:47:42 <Gracenotes> > sin (1 :+ (1/0))
22:47:43 <lambdabot>   Infinity :+ Infinity
22:48:06 <medfly> :o
22:48:46 <Gracenotes> > (1 :+ (1/0))/2
22:48:46 <lambdabot>   NaN :+ Infinity
22:49:16 * BMeph is just glad it doesn't say "OVER NINE THOUSAAAAAAAAND..." - but for all intents and purposes, it might as well. ;)
23:10:15 <mxyz> did anyone here start learning Haskell from RWH?
23:22:25 <sfuentes> mxyz: i did
23:22:41 <sfuentes> but i'm still learning
23:23:16 <sfuentes> i'm on chap7
23:29:29 <cads> BMeph, it's going to suck when this generation is old and infirm, tryign to explain to their kids about this cartoon with dudes with yellow hair, and an internet meme that got started.. "So vegeta yellsh, 'over nine THOUSHAAAAND!' Lolsh."
23:45:51 <ablmf> Does haskell cache already evaluated item of an infinite list?
23:46:09 <MissPiggy> ablmf, it doesn't have to
23:46:23 <ablmf> for example, like this : fibs = scanl (+) 0 (1:fibs)
23:46:50 <MissPiggy> yes
23:46:50 <c_wraith> ablmf: depends on the gc, but it will probably cache alread-evaluated elements as long as the name fibs is in scope
23:46:52 <MissPiggy> that will
23:46:58 <c_wraith> *already
23:47:15 <medfly> does anyone here do web programming with Haskell? if so, how do I check that someone can run what I make?
23:47:36 <ablmf> I mean, fibs !! 200 depends on fibs !! 199
23:47:59 <c_wraith> ablmf: in ghc, so long as the name "fibs" is in scope, it will cache.
23:48:17 <ablmf> c_wraith: thx!
23:49:27 <c_wraith> ablmf: you can think of it in terms of relatively standard GC.  A list is a standard linked list, and as long as the head of the list is in scope (the name "fibs", in that case), it won't collect any of it.
23:51:34 <aavogt> medfly: what do you mean by "run what I make"?
23:51:54 <aavogt> who are these somebodies?
23:52:03 <medfly> aavogt, I want to write someone a website and I want to be able to tell if he could run it
23:52:10 <medfly> I think my questions might be too vague
23:52:14 <c_wraith> what do you mean "run it"?
23:52:29 <c_wraith> Do you mean "run a web server" or do you mean "access the site I'm running"?
23:52:30 <medfly> I don't know any more! :o
23:52:39 <medfly> access the site HE will be running
23:54:03 <medfly> I want his server to run it
23:54:07 <medfly> ?
23:54:11 <c_wraith> So..  It's not really different than running any other haskell program
23:54:19 <c_wraith> The program just happens to be a web server
23:54:24 <aavogt> depends what your program needs to access
23:54:27 <medfly> it's nto a web server. it's a website
23:54:36 <c_wraith> medfly, that makes no sense
23:54:41 <medfly> I don't know!
23:55:00 <aavogt> some OSes require some permissions to bind to low ports
23:55:01 <medfly> have you seen webservers? the access they give you can be summed up in "uploading files"
23:55:13 <c_wraith> Um.  Oh, you mean web hosting.
23:55:28 <medfly> like people make websites in PHP? that.
23:55:42 <c_wraith> the answer is, most dedicated web hosts probably can't run a haskell app
23:55:51 <aavogt> if you can only ftp stuff to a hosting provider, then you can't run arbitrary code
23:55:52 <medfly> :-/
23:55:59 <sinelaw> hey
23:56:02 <aavogt> perhaps you do get ssh access
23:56:10 <medfly> okay then
23:56:13 * medfly crawls back to PHP
23:56:52 <aavogt> but it might be running a really old OS on which can be troublesome
23:57:13 <c_wraith> as a matter of fact, I *do* run a web service that is partially written in haskell.  But it requires full access to a machine, not just having some "web host"
