00:00:51 * glguy is working on a Heap data structure that guarantees balance and heap property http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17075
00:01:23 <glguy> I have my version in Haskell that with the deleteMin function as well, but that one doesn't guarantee the heap property
00:02:00 <glguy> (just the balanced one)
00:03:06 <copumpkin> agda :o
00:03:13 <copumpkin> glguy: didn't know you did agda :)
00:03:25 <glguy> copumpkin: I do agda every couple of months
00:03:35 <copumpkin> you should come to #agda :) it's a party!
00:05:28 <gju> hello, i'm trying to write a function that reads numbers from the stdin and returns a list when a blank line was entered. that's my approach: http://pastie.org/private/pe1s5fwirypsixcjhpxnw
00:05:38 <gju> can anyone tell me what i'm doing wrong?
00:05:47 <solrize> ski,  not sure what you mean but yes, omega is the collection of natural numbers.  so one can imagine that ZFC is omega-inconsistent, for example.
00:07:21 <glguy> --  if x == "" then [] else (read x :: Float) : foo
00:07:41 <dmwit> else do { xs <- foo; return (x:xs) }
00:07:42 <glguy> if x == "" then return [] else do xs <- foo; return (read x : xs)
00:07:50 <dmwit> or
00:07:59 <glguy> x == ""   is   null x
00:08:04 <dmwit> else (read x :) <$> foo
00:08:09 <dmwit> :t (<$>)
00:08:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:08:59 <dmwit> alse
00:09:03 <dmwit> also
00:09:08 <dmwit> then return []
00:09:10 <gju> puh.
00:09:14 <gju> confusing. :>
00:09:23 <dmwit> also
00:09:26 <dmwit> foo :: IO [Float]
00:09:27 <dmwit> =)
00:10:16 <kniu> is a FilePath just a String?
00:10:21 <dmwit> yep
00:10:50 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html#t%3AFilePath
00:11:43 <kniu> @hoogle runProcess
00:11:43 <lambdabot> No results found
00:11:51 <kniu> @hoogle executeFile
00:11:52 <lambdabot> No results found
00:12:00 <glguy> gju: this is probably the most "straight-forward" way to do it http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17076#a17076
00:12:33 <kniu> where's runProcess?
00:12:50 <glguy> probably in the process library
00:13:17 <glguy> http://hackage.haskell.org/packages/archive/process/1.0.1.2/doc/html/System-Process.html#v%3ArunProcess
00:13:39 <gju> xs <- foo is implicitly creating a list?
00:13:46 <kniu> thanks
00:15:01 <monochrom> @pl \x y -> y
00:15:02 <Baughn> jfredett: xs <- foo is binding xs to whatever foo returns. If that's a list, then yes.
00:15:02 <lambdabot> const id
00:15:05 <Baughn> Er, gju
00:15:37 <glguy> gju: because (foo :: IO [Float]), (xs :: [Float])
00:15:50 <gju> ok, thank you.
00:24:05 <ski> solrize : i mean that in the existence property, the quantified variable could possibly range over other types, like e.g. streams of natural numbers
00:44:37 <solrize> hmm, i think omega-inconsistency only refers to natural numbers, and there are higher levels of soundness that could apply to other types.  the WP article is pretty good and is basically everything i know, but may not say enough
00:50:29 <alex404> I'm trying to compile the haskell platform from source, but it fails saying I need zlib between .4 and .6. Anyone know what the deal is?
00:50:45 <ivanm> alex404: install zlib?
00:50:53 <ivanm> (hint: context helps)
00:51:13 <alex404> ivanm: ;) I have zlib installed, but it's at version 1.2 or so
00:51:29 <alex404> ivanm: I don't even know where I'd find the older version...
00:51:42 <ivanm> alex404: is that the C library?
00:51:58 <ivanm> I think it's referring to the _haskell_ zlib library...
00:52:03 <alex404> ivanm: I would assume so, but the version looks more in the range of the haskell bindings
00:52:11 <ivanm> which is strange, because the haskell platform should include that...
00:52:17 <alex404> ivanm: Exactly
00:52:19 <ivanm> can you paste the build error up somewhere?
00:52:39 <alex404> ivanm: Yah... just a sec
00:52:46 <ivanm> let me check: you're using this tarball? http://hackage.haskell.org/platform/2009.2.0.2/haskell-platform-2009.2.0.2.tar.gz
00:52:57 <alex404> Yah
00:54:01 <alex404> ivanm: What's that little program to paste things to a website?
00:54:05 <ivanm> and you followed the steps there? ./configure && make && make install ?
00:54:09 <alex404> Yah
00:54:32 <alex404> Fails during make, anyway
00:54:53 <ivanm> which architecture/OS?
00:55:08 <alex404> x64 using archlinux
00:55:25 <ivanm> alex404: there should be a pkgbuild for the haskell platform...
00:55:51 <alex404> ivanm: It doesn't work either, but for different reasons. The packages are borked.
00:56:07 <alex404> ivanm: It gets caught in a loop trying to install cabal.
00:56:25 <ivanm> preflex: seen dons
00:56:26 <preflex>  dons was last seen on #haskell 1 day, 14 hours, 11 minutes and 35 seconds ago, saying: gwern: re. 6.12, the next HP is only a few weeks away, so now you know there's some work to do to upgrade things.
00:56:33 <ivanm> alex404: maybe try asking on #archlinux ?
00:56:38 <ivanm> take that back
00:56:42 <ivanm> I meant #arch-haskell
00:56:45 <ivanm> I think that's it...
00:56:50 <alex404> Hmm...
00:56:53 <ivanm> yup, that's the one
00:56:54 <sfuentes> newbie here wondering what module can i use to download a file from an http server using hasekell?
00:57:15 <alex404> ivanm: I'll have a look, thanks
00:57:23 <ivanm> sfuentes: see the curl library
00:57:27 <ivanm> alex404: no worries
00:57:36 <ivanm> sfuentes: or maybe the network or http libraries
00:59:38 <sfuentes> is there a way to list all the functions of a module in ghci?
01:00:02 <glguy> :browse
01:00:48 <sfuentes> awesome. thank you
01:09:47 <lisptastic> Anybody up right now? I wanna talk to somebody who understands parallel programming.
01:09:50 * hackagebot upload: GPipe 1.1.5 - A functional graphics API for programmable GPUs (TobiasBexelius)
01:10:59 <lisptastic> I think in the long term that it's ineivatable that parallelism be handled by hardware.
01:11:15 <lisptastic> I'd like to explain why I think that. And here from you why that's wrong or right.
01:11:25 <hiredman> "handled by hardware"
01:11:34 <ivanm> lisptastic: I think most of us here would prefer to talk about coding than be lectured to by someone
01:11:41 <hiredman> sounds very vague and handwavy
01:11:43 <lisptastic> I'm not trying to lecture anyone.
01:11:46 <ivanm> hiredman: agreed
01:11:54 <lisptastic> It's a fundamental question.
01:12:02 <lisptastic> I'm asking because I really don't know.
01:12:04 <ivanm> "I'd like to explain why I think that." <-- sounds like a lecture to me
01:12:10 <ivanm> lisptastic: and it isn't a fundamental question
01:12:26 <ivanm> where we come from is arguably a more fundamental question than how we should write parallel programs
01:12:35 <lisptastic> Okay it's not fundamental
01:12:36 <lisptastic> .
01:12:43 <ivanm> lisptastic: anyway, short answer: automatic parallelisation is hard if not impossible to do properly
01:12:52 <lisptastic> Just here me out, no need to get pissy.
01:12:52 <ivanm> which is why GHC, etc. don't do it
01:13:13 <ivanm> even though Haskell is probably one of the easiest languages to do automatic parallelisation due to purity
01:13:29 <ivanm> lisptastic: having it done automatically in hardware would be _nice_ and a goal many people would like
01:13:41 <ivanm> the reality and practicality of it are another story however
01:13:47 <paolino> ivanm: I guess some kind of euristic is doable
01:14:05 <ivanm> paolino: yes, but it won't be perfect
01:14:09 <glguy> ha, lisptastic is getting lectured now
01:14:14 <ivanm> glguy: heh
01:14:19 <ivanm> guilty as charged ;-)
01:14:20 <glguy> good thing we avoided /that/ one
01:14:23 <lisptastic> I was never trying to lecture anybody from the start.
01:14:34 <paolino> obviously staring at the runtime behaviour  of thunks evaluation
01:14:46 <ivanm> paolino: I suppose such heuristics would be analogous to GC for memory rather than manual allocation
01:14:59 <lisptastic> When you ask a question you explain the context of the question. Same thing.
01:15:03 <ivanm> "good enough" rather than perfect
01:15:14 <paolino> I'll listen lisptastic
01:15:18 <koala_man> lisptastic: what kind of long-term? grant giving long term or scifi long term?
01:15:24 <lisptastic> grant giving.
01:15:46 <lisptastic> Too little masturbation for scifi too much for most academia.
01:16:34 <lisptastic> When you write parallel code in Haskell, do you write for a specific number of cores?
01:17:03 <ivanm> lisptastic: usually not
01:17:24 <ivanm> the most common method of parallel programming in haskell is to provide hints to the compiler where it would make sense to parallelise something
01:17:32 <ivanm> then when you run the program you specify how many cores/CPUs to use
01:17:34 <glguy> is it?
01:17:51 <ivanm> glguy: well, as far as I know `par` is the most common method of parallel programming in Haskell
01:18:02 <glguy> It certainly exists
01:18:11 <glguy> I just didn't know anyone used it outside of simple examples
01:18:39 <ivanm> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking
01:18:44 <ivanm> dons uses it! ;-)
01:18:48 <lisptastic> Well my idea was that as time goes on processors are going to become more and more parallel.
01:18:55 <glguy> dons uses it in simple examples :-p
01:18:58 <lisptastic> Because they use less power that way.
01:19:22 <lisptastic> And that eventually you'd have to write code that can efficiently parallelize to an arbitrary number of cores
01:19:23 <tensorpudding> multicore programming is hard, let's go hyperthreading
01:19:23 <ivanm> lisptastic: yes, I believe that is the view of the industry
01:20:01 <lisptastic> The more parallel your code, the more expensive communication gets, right?
01:20:09 <ivanm> as Intel realised that whilst trying to artificially keep pace with Moore's law (that was an observation at the time, not something that _had_ to be done) they were having trouble making the circuits, etc. any smaller and more complex
01:20:19 <ivanm> so they decided to use more rather than faster
01:20:25 <ivanm> lisptastic: define communication
01:20:55 <lisptastic> The more parallel your code, the more cores it's on, the more those cores have to give results of computation to each other.
01:21:24 <lisptastic> Or not.
01:21:31 <ivanm> looks like a reasonable discussion about whether automatic parallelisation is feasible and how Haskell does it: http://www.reddit.com/r/programming/comments/61no8/holy_shmoly_haskell_smokes_python_and_ruby_away/c02juu8
01:21:40 <ivanm> lisptastic: depends on how you do your parallelisation
01:21:45 <glguy> lisptastic: You should look up Ivan Sutherland's ideas about radical changes to the way to program to focus on the communication problems
01:21:53 <ivanm> there are various models of parallel computation
01:21:58 <glguy> in order to benefit in a parallel environment
01:22:01 <ivanm> and it depends on the architecture, etc. involved
01:22:11 <ivanm> e.g. compare OpenMP and MPI as parallelisation libraries
01:22:13 <hiredman> ideally you'd some kind of, I dunno, thread coloring?
01:22:15 <medfly> up ahead: comparing your language to PHP!
01:22:21 <medfly> (you always win!)
01:22:32 <ivanm> medfly: heh
01:22:36 <ivanm> even if your language is BF? :p
01:23:06 <int-e> Malbolge < PHP
01:23:17 <lisptastic> ivanm: "depends on the architecture" THAT's why I think hardware parallelism is ineivatable. Is hardware parallelism, really hard math hard or factoring prime numbers hard?
01:23:33 <medfly> hmm... it's not on the shootout
01:23:39 <ivanm> lisptastic: there are two ways of making architecture parallisable
01:23:44 <ivanm> shared memory and shared nothing
01:23:56 <ivanm> medfly: how does the shootout do parallelisation then?
01:24:11 <ivanm> lisptastic: shared memory is easier to code, but doesn't scale (on the hardware side) as easily
01:24:13 <medfly> I think it has a quad core machine to test things on
01:24:17 <ivanm> whereas shared nothing ==> cluster!
01:24:33 <int-e> (Although the developed theory about Malbolge is fascinating. But it's not Turing complete, because it's basically a finite state automaton.)
01:24:39 <ivanm> lisptastic: http://en.wikipedia.org/wiki/Beowolf_cluster
01:24:46 <glguy> lisptastic: did you see my comment?
01:25:06 <ivanm> medfly: yup; but how does the haskell code in the shootout do parallelisation if not using `par` and friends?
01:25:17 <medfly> I dunno?
01:25:23 <hiredman> lisptastic: you're still not saying anything specific enough to be interesting about this hardware
01:25:46 * paolino thinks it is somewhat unclever having  an enevaluated list of thunks , knowing one of them is the next to be evaluated and do not try to evaluate some of them by guess, when there are idling cpus
01:26:15 <ivanm> here's the link I was looking for...
01:26:25 <ivanm> lisptastic: see how easy it is to parallelise Haskell code: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core
01:26:35 <medfly> ivanm, I'm not part of the debate :-)
01:26:47 <medfly> ivanm, I'm just saying one of the links compared Haskell to Ruby and Python.
01:26:55 <ivanm> medfly: oh, you were referring to malbolge not being on the shootout?
01:27:03 <int-e> paolino: well, in the worst case you'll be wasting memory and energy.
01:27:12 <ivanm> sorry, I thought you meant the haskell code on the shootout wasn't using `par`
01:27:23 <erikc`> paolino: the work of a single thunk is not going to be enough to justify multithreading it
01:27:31 <erikc`> the division has to be chunkier
01:27:37 <medfly> oh... I was just saying that next we'll be comparing it to PHP to feel better about ourselves.
01:28:30 <int-e> Hmm, in a way `par` promises that any work done on evaluating a given thunk will not be wasted.
01:28:41 <medfly> PHP seriously sucks on those. :)
01:28:45 <paolino> erikc`: every cpu is spidering the list, the list of TVar Thunk
01:28:55 <int-e> @quote penguins
01:28:56 <lambdabot> int-e says: PHP is a programming language like penguins are birds. And people try to make it fly.
01:28:59 <koala_man> how about picking some easy points to parallelize, like map, and running a profiler to see which are likely to benefit
01:29:13 <koala_man> (automatically)
01:29:37 <hiredman> erikc`: that's why people use threadpools
01:29:49 <erikc`> hiredman: sure, but not for a single thunk of work
01:29:55 <paolino> erikc`: I see what you mean, sorry
01:30:28 <int-e> > take 5 $ map (+1) [1..] -- parallelizing that map blindly will be fatal.
01:30:29 <lambdabot>   [2,3,4,5,6]
01:31:09 <paolino> int-e you need euristics
01:31:19 * int-e wonders what programming in a pure, strict language would feel like.
01:31:53 <hiredman> int-e: math
01:32:03 <int-e> math is lazy ;)
01:32:39 <int-e> (mathematicians, faced with proving "A or B" will pick one of A or B to prove and never discuss the other one)
01:32:55 <medfly> mathematicians are a lazy implementation of mathematics
01:32:56 <int-e> paolino: I was just arguing against  map  being an easy point to parallelize.
01:32:59 * medfly giggles
01:35:19 <copumpkin> no giggling allowed!
01:35:28 <paolino> what kind of dependency graph is the thunks one ?
01:35:30 <copumpkin> only 100% serious haskell discussion!
01:36:23 <medfly> hehehe
01:36:38 <int-e> copumpkin: that's the perfect point to insert a "mwahahaha" for giggles. Err. Ooops, sorry.
01:38:04 <copumpkin> :)
01:38:49 <paolino> it it possible that a thunk evaluation creates a new dependency for another, already present thunk ?
01:39:25 * copumpkin goes to sleep
01:39:27 <paolino> ok, i feel stupid, I stop
02:08:46 <pozic> Is there a split function which takes the previous element from a list and the current element and based on that decided whether or not to split? I.e. kind of an inversed generalized concat.
02:10:14 <Twey> :t break
02:10:15 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:10:18 <Twey> Hm
02:10:47 <Twey> @hoogle (a -> a -> Bool) -> [a] -> ([a], [a])
02:10:47 <lambdabot> No results found
02:10:53 <Twey> Sorry :-\
02:12:41 <DekuNut> > break (>5) [1,2,3,4,5,6,7,8,9]
02:12:41 <lambdabot>   ([1,2,3,4,5],[6,7,8,9])
02:12:47 <DekuNut> :o
02:13:15 <DekuNut> They
02:13:20 <glguy> > span (<= 5) [1..9]
02:13:21 <lambdabot>   ([1,2,3,4,5],[6,7,8,9])
02:13:35 <Twey> That only takes one element, though
02:14:54 <ivanm> so, I'm guessing we scared off lisptastic...
02:15:30 <pozic> I missed something?
02:17:35 <ivanm> someone came in here wanting to have a conversation about how he figured that "in the long term that it's ineivatable that parallelism be handled by hardware."
02:17:59 <ivanm> and I (with others) basically told him that that's an enviable but rather hand-wavy goal
02:18:53 <pozic> In the end hardware is the only thing which computes.
02:19:10 * hackagebot upload: regions 0.4 - Provides the region monad for safely opening and working with  scarce resources. (BasVanDijk)
02:19:12 <pozic> So, he is right in that part, but that was not what you were talking about ;)
02:19:46 <ivanm> heh
02:20:06 <pozic> Most forms of parallelism already exist, either in theory or in practice.
02:20:10 * hackagebot upload: regions-monadsfd 0.3.1 - Monads-fd instances for the RegionT monad transformer (BasVanDijk)
02:20:42 <pozic> If you want to speedup a certain computation which can be parallelized, it is already possible.
02:20:51 <det> @hoogle (a -> a -> Bool) -> [a] -> [[a]]
02:20:52 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
02:20:52 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
02:20:52 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
02:20:52 <pozic> No need to wait for the "future".
02:21:10 * hackagebot upload: regions-monadstf 0.3.1 - Monads-tf instances for the RegionT monad transformer (BasVanDijk)
02:21:12 * hackagebot upload: safer-file-handles 0.3.0.1 - Type-safe file handling (BasVanDijk)
02:22:17 <pozic> Everyone claiming that computers will parallelize a non-trivial algorithm in less than a day of CPU time don't know what they are talking about. It's probably in the order of a few million hours of CPU time to do that :)
02:23:11 * hackagebot upload: usb-safe 0.5.1.1 - Type-safe communication with USB devices. (BasVanDijk)
02:23:13 * hackagebot upload: regional-pointers 0.1.0.1 - Regional memory pointers (BasVanDijk)
02:23:35 <pozic> So, while computers are perfectly able to do non-trivial things, nobody wants to wait for them to do so, even though they will give a better solution in a guaranteed matter, as opposed to a bunch of programmers or scientists, who might come up with a solution.
02:25:08 <paolino> GC is non trivial
02:26:05 <pozic> paolino: yes, and how many GC algorithms have been synthesized by a computer in a reasonable amount of time?
02:28:22 <pozic> Also, I would say that all of the GC algorithms I have seen would probably fall in the trivial category. It might be a pain to debug if you don't write the tools first to do the debugging, but otherwise, not that complicated.
02:37:42 <mreh> what's the no-op in IO?
02:38:21 <paolino> pozic, I was thinking of choosing the right point in the space of parameters for a given algorithm, not inventing it
02:38:23 <mreh> > return ()
02:38:23 <lambdabot>   No instance for (GHC.Show.Show (m ()))
02:38:24 <lambdabot>    arising from a use of `M787254862...
02:40:18 <quicksilver> mreh: return 0, return (), return (error "don't look at this") are argubaly all no-ops
02:40:28 <quicksilver> mreh: btu certainly return () is the canonical one to choose.
02:40:43 <paolino> ( inventing it can fall in that category too)
02:43:17 <pokoko222> i am studying mathematical analysis 1 and i want to combine that, i think it is the right time now to study float point arithmetic. Any book recommendations?
02:49:10 <mreh> do { runCommand "clear"; putStrLn "Hello" } -- this works the wrong way round, or I am being stupid
02:49:56 <mreh> it prints the statement, I just can't see it, I have to scroll up to view it
02:50:30 <harlekin> mreh, could it be that runCommand forks a new thread?
02:50:51 <mreh> harlekin: you tell me :) I'm listening
02:51:04 <mreh> maybe..
02:51:04 <harlekin> Oh, I don't know. I was just guessing.
02:51:35 <mreh> waitForProcess <- that might do it
02:52:05 <harlekin> mreh, where's runCommand defined?
02:52:37 <mreh> naah
02:52:47 <mreh> harlekin: System.Process
02:53:04 <mreh> I gotta go, 2 hours of Bioinformatics
02:53:06 <mreh> *groan*
02:53:13 <mreh> ping me if you find out :)
02:53:51 <mreh> might leave my laptop on in class actually
02:54:05 <mreh> secretly do haskell, shhh
03:00:21 * hackagebot upload: yices 0.0.0.7 - Haskell programming interface to Yices SMT solver (KiYungAhn)
03:01:03 <Saizan> @hackage yices
03:01:03 <lambdabot> http://hackage.haskell.org/package/yices
03:01:55 <harlekin> mreggen, try if it's working with waitForProcess. I cannot find out how the command is executed exactly.
03:02:07 <harlekin> mreggen, Sorry. Wrong name.
03:03:30 <Saizan> runCommand just forks a shell to run the command, it doesn't wait for it to finish
03:08:10 <Jory> Hi guys. I'm learning Haskell, using learnyouahaskell.com as tutorial / introduction. In the chapter about recursion, there is an example defining a " take' " function. There is something I'd do differently and I'm wondering why its done that way in the example. Please see http://pastebin.com/ddb0086
03:09:08 <BONUS> Jory yeah, the only difference is the handing of negative number
03:09:10 <BONUS> numbers*
03:09:29 <Jory> Okay, thanks.
03:09:51 <BONUS> the way it's done like that in the example is because the real take works that way
03:09:58 <BONUS> > take (-2) [1..5]
03:09:59 <lambdabot>   []
03:10:15 <Jory> Ah, didn't know that.
03:10:20 <Jory> Thanks for explaining. :)
03:10:28 <BONUS> np :)
03:10:35 <Jory> Also, nice bot.
03:10:40 <medfly> isn't that fun
03:10:52 <medfly> "I'm not sure about this book", "why don't you talk to the author?"
03:11:02 <BONUS> haha
03:11:58 <Jory> It is nice to be able to just do that.
03:19:28 <noknok> Hi there. May I ask, has any of you out there ever succeeded in installing the hxt package? I get stuck again and again...
03:24:00 <Cale> noknok: One moment, I'll let you know how it goes.
03:24:27 <Cale> (I've installed it before, but it was long enough ago that I thought I should do it again.)
03:26:22 <pozic> Is there a better way to write this? http://paste.debian.net/58672/
03:26:55 <zygoloid> pozic: yes
03:27:29 <zygoloid> pozic: do you know about the Monoid Ordering instance?
03:27:50 <Saizan> pozic: does that typecheck? i2 is not of type Ordering
03:28:25 <Cale> noknok: I just installed hxt-8.3.2 successfully on GHC 6.10.4
03:28:31 <pozic> Saizan: probably not.
03:28:47 <noknok> Cale: thanks! I have ghc 6.10.4 installed. The installation for hxt in www.fh-wedel.de/~si/HXmlToolbox/index.html is described for ghc 6.12.1 and it doesn't work with my cabal. There are older versions of hxt for ghc 6.10, but then I get stuck in all sorts of dependency problems I can't seem to solve (it asks for curl, but curl doesn't install either, etc.0
03:29:01 <Cale> cabal install hxt-8.3.2
03:29:04 <noknok> Cale: how did you do it, with cabal?
03:29:15 <Saizan> pozic: however: compare = (compare `on` distance) `mappend` \i1 i2 -> ...
03:29:31 <Cale> The newer ones all demand base>=4.2, which means at least GHC 6.12
03:29:50 <zygoloid> pozic: (a1 `compare` a2) `mappend` (b1 `compare` b2) == (a1, b1) `compare` (a2, b2)
03:30:20 <zygoloid> also, compare (distance i1) (distance i2) == comparing distance i1 i2
03:30:53 <zygoloid> would be nice if you could write that as i1 `comparing distance` i2 :(
03:31:02 <pozic> > LT `mappend` GT
03:31:03 <lambdabot>   LT
03:31:10 <pozic> > GT `mappend` LT
03:31:11 <lambdabot>   GT
03:31:37 <zygoloid> pozic: EQ `mappend` a = a; a `mappend` _ = a
03:32:13 <noknok> Cale: THANK YOU! The version number does seem to do the trick. But in the end it tells me: some packages failed to install: curl-1.3.5... hxt-8.3.2... tagsoup-0.8... Do I have to redo that manually?
03:32:30 <Cale> noknok: huh, odd.
03:32:41 <Cale> noknok: I don't know why it'd say that.
03:32:53 <zygoloid> pozic: also it looks like compare a a == LT, if a == X {...} :-o
03:34:21 <pozic> zygoloid: http://paste.debian.net/58673/
03:34:28 <pozic> zygoloid: that is the correct logic.
03:35:07 <zygoloid> pozic: my comment still stands.
03:35:11 <Saizan> noknok: do you have the curl C-lib installed?
03:35:42 <pozic> zygoloid: ah, I see what you mean.
03:35:53 <noknok> Saizan: thank you. I don't know. How can I check?
03:36:06 <Saizan> noknok: which OS are you using?
03:36:18 <noknok> Saizan: ubuntu
03:36:25 <pozic> zygoloid: I guess calling sort on something like that, will crash?
03:37:15 <pozic> zygoloid: but you are right, in that case, I should have EQ.
03:37:44 <Saizan> noknok: it seems you need to run "apt-get install libcurl3-dev"
03:38:03 <zygoloid> pozic: GHC's sort won't crash, but the result is not specified
03:38:58 <paulvisschers> I'm trying to read a file, then update some stuff on the resulting data structure and write that back, but I get a "resource busy (file is locked)" error
03:39:24 <paulvisschers> I know this is because the file is read lazily, but how do I stop that?
03:39:38 <Saizan> paulvisschers: force the whole resulting String
03:39:51 <BONUS> or open a temporary file and write to that
03:39:54 <Saizan> e.g. length str `seq` return ()
03:39:59 <BONUS> and then rename the new one and delete the old one
03:40:21 <paulvisschers> Saizan: I'll try that, thanks
03:40:32 <Saizan> BONUS: does that avoid the lock problem?
03:41:08 <BONUS> i'm just taking an educated guess imo
03:41:18 <BONUS> if we saw the code we'd know better
03:41:25 <Alpounet> paulvisschers, something close to do { content <- readFile filename ; length str `seq ` return () ; {- use the content and then write back without any problem -} }
03:41:31 <BONUS> but yeah you're right, you eventually have to force the whole file
03:41:54 <Saizan> ah, writing the temp file out would probably force the whole input file, i guess
03:42:01 <BONUS> yeah
03:42:38 <paulvisschers> Saizan, Alpounet: thanks that works
03:43:04 <paulvisschers> BONUS: Yours would probably work too but is much more involved
03:43:10 <zygoloid> do { h <- openFile filename ReadMode; c <- hGetContents h; evaluate (length c); hClose h; return c }
03:43:42 <zygoloid> LazyIO--
03:44:15 <Saizan> D.B.C.unpack <$> D.B.C.readFile filename
03:44:18 <xerox> would evaluate (readFile filename) do the trick?
03:44:23 <Saizan> no
03:44:29 <noknok> Saizan: thank you. "apt-get install libcurl3-dev" complained "Package libcurl3-dev is a virtual package provided by: libcurl4-openssl-dev 7.18.2-1ubuntu4.4 You should explicitly select one to install. And when I do "apt-get install libcurl4-openssl-dev" it ends with "Errors were encoutered while processing: ghc6-doc libghc6-cairo-dev"
03:53:24 <zygoloid> "snd <$> (readFile filename >>= evaluate . (rnf &&& id))" would do the trick, though, i think
03:56:03 <zygoloid> is there an "(NFData a) => a -> a" form of rnf? rnf' = seq =<< rnf
03:56:33 <Alpounet> @hoogle (NFData a) => a -> a
03:56:33 <lambdabot> Control.Parallel.Strategies force :: NFData a => a -> a
03:56:34 <lambdabot> Prelude id :: a -> a
03:56:34 <lambdabot> Data.Function id :: a -> a
03:56:39 <Alpounet> force
03:56:45 <zygoloid> "readFile filename >>= evaluate . force" then
03:56:50 <xerox> great :)
03:56:58 <xerox> reads like english..
03:58:16 <zygoloid> {-# DEPRECATED force, sforce "Lolita-specific hacks." #-} ;-(
04:00:04 <pozic> Why don't we have force:: a -> a?
04:00:17 <xerox> LOLITA is a natural language processing system developed by Durham University between 1986 and 2000. The name is an acronym for "Large-scale, Object-based, Linguistic Interactor, Translator and Analyzer".
04:00:21 <xerox> :o
04:00:31 <medfly> pervs
04:00:51 <zygoloid> looks like "force = flip using rnf" would work, but that's not so readable :(
04:01:12 <zygoloid> i wonder why it's marked DEPRECATED
04:01:22 <pozic> If you have a graph representation of all the values, then implementing force is trivial.
04:02:11 <pozic> Type-classes where generic versions can be implemented are silly, imho.
04:02:31 <zygoloid> pozic: force :: a -> a would weaken parametricity. plus it (presumably) wouldn't work if 'a' is a function type.
04:02:36 <zygoloid> seq is bad enough :(
04:03:15 <pozic> zygoloid: why would it weaken parametricity?
04:03:19 * zygoloid votes for making NFData derive-able
04:03:58 <pozic> zygoloid: or do you mean calling force on co-data?
04:04:17 <zygoloid> pozic: currently, we know that if  f :: a -> a, then either f = id or f = _|_ or f a = _|_. force is none of those.
04:04:50 <zygoloid> (aiui if we didn't have seq the latter two would be indistinguishable)
04:05:27 <pozic> zygoloid: what is force according to you then?
04:06:37 <pozic> zygoloid: in force val, if val is reduced can be reduced to normal form, then it is that value and otherwise it is _|_.
04:07:07 <pozic> I don't see any complications, but maybe I am missing something.
04:07:12 <zygoloid> pozic: force (Just _|_) = _|_; force (Just 42) = Just 42
04:09:20 <pozic> zygoloid: and what is 'f' here?
04:09:36 <zygoloid> the 6th letter of the alphabet? which f?
04:09:50 <pozic> zygoloid: " f :: a -> a, then either f = id "
04:10:08 <medfly> @djinn a -> a
04:10:08 <lambdabot> f a = a
04:10:33 <zygoloid> pozic: f is a function of type a -> a.
04:10:46 <sinelaw> anyone managed to compile lambdabot lately?
04:10:49 <pozic> zygoloid: your force example, is just an application of the semantics I specified in English. I don't see how it demonstrated anything.
04:11:08 <zygoloid> pozic: it demonstrated that 'force' is not id, or is it _|_, nor is it const _|_.
04:11:15 <pozic> zygoloid: never mind, I see.
04:11:32 <pozic> zygoloid: still, I don't see any problems with adding semantics like that.
04:12:06 <pozic> It solves all of the "space leaks" in Haskell code.
04:12:29 <pozic> And it eliminates rnf.
04:12:41 <zygoloid> well, it's not going to cause the world to end. but if you make types larger in this way, it makes reasoning about code more difficult. there's a good reason why function types don't include values with side effects :)
04:13:31 <pozic> zygoloid: and it makes programming easier.
04:13:47 <pozic> zygoloid: adding a special case to handle in your theorem prover is also not a big problem.
04:14:00 <zygoloid> well, perhaps. what should 'force' do when given a function?
04:14:25 <zygoloid> what is: force (\a -> let b = undefined in 42) ?
04:14:26 <pozic> zygoloid: that's something one could debate.
04:14:51 <sinelaw> Cale, you there? Any idea how to compile lambdabot?
04:14:54 <pozic> zygoloid: there is nothing wrong with picking either option.
04:15:26 <pozic> zygoloid: keeping it unspecified is also an option.
04:15:32 <zygoloid> pozic: there really is. if it's _|_ then you can't GC inside closures any more. if it's not _|_ then you need to tell whether a value is potentially used by a function (which is not computable)
04:15:36 <pozic> zygoloid: that is, a program error.
04:15:53 <zygoloid> wouldn't it be better to say 'you can't use rnf on functions'?
04:16:13 <zygoloid> why have a runtime error when you can have a compile-time error?
04:17:44 <scanish> Uh hello... is there any expert around who can help me getting HaskellDB to be my friend?
04:18:09 <medfly> ask less vague questions
04:19:42 <scanish> less vague... that's funny cos all info I can get on HaskellDB is exactly vague
04:20:50 <medfly> heh
04:21:54 <moshisushi> i get "Not in scope: data constructor Postfix" when trying to run some parsec-based code
04:22:17 <moshisushi> on my friend's ghc installation, it runs just fine
04:22:38 <taruti> shapr: github was down last night, back up and the link should work fine (re network-fancy)
04:22:52 <scanish> the few tutorials spare out the bit that interests me (and that's most important in the whole of it) and refers to the examples. But the examples are so out of date they won't work with the current haskellDB version
04:23:22 <zygoloid> as i recall, haskelldb used to use some (hugs-specific) haskell extensions in its syntax
04:24:56 <scanish> yes i noticed that... at least it was just some short-cut syntax in the samples
04:25:37 <scanish> but that was just syntax, you know, like the record syntax for data is just syntactic sugar for writing functions
04:26:06 <rdtsc> how to combine ServerPartT with ErrorT ?
04:28:24 <moshisushi> here's a paste of the output: http://pastie.org/809220
04:32:52 <ben_m> Is there a function like read, except that it returns (Maybe a)?
04:33:22 <quicksilver> ben_m: build it from reads
04:33:41 <rdtsc> ben_m: look at safe package
04:34:29 <ben_m> rdtsc: Ah that looks good.
04:34:34 <ben_m> Thanks.
04:36:11 * quicksilver thinks it is hardly worth a package for this ;)
04:36:16 <quicksilver> although you might want it for other reasons
04:36:21 <ben_m> I am just looking at the source of readMay
04:36:23 <ben_m> :)
04:36:47 <ben_m> Maybe I don't even need this ... I just want to handle a failing read gracefully
04:36:50 <kamatsu> does anyone else constantly run into the circular import problem?
04:36:54 <quicksilver> > let readMaybe x = case (reads x) of (v,"") -> Just v | _ -> Nothing
04:36:55 <lambdabot>   <no location info>: parse error on input `|'
04:37:06 <quicksilver> :t let readMaybe x = case (reads x) of (v,"") -> Just v | _ -> Nothing in readMaybe
04:37:07 <lambdabot> parse error on input `|'
04:37:09 <kamatsu> i.e where A imports B and B imports A, GHC barfs
04:37:12 <quicksilver> :t let readMaybe x = case (reads x) of (v,"") -> Just v ; _ -> Nothing in readMaybe
04:37:13 <lambdabot>     Couldn't match expected type `[(a, String)]'
04:37:13 <lambdabot>            against inferred type `(a1, b)'
04:37:13 <lambdabot>     In the pattern: (v, "")
04:37:22 <quicksilver> :t let readMaybe x = case (reads x) of [(v,"")] -> Just v ; _ -> Nothing in readMaybe
04:37:23 <lambdabot> forall a. (Read a) => String -> Maybe a
04:37:25 <sinelaw> preflex, seen Cale
04:37:25 <preflex>  Cale was last seen on #haskell 1 hour, 4 minutes and 44 seconds ago, saying: noknok: I don't know why it'd say that.
04:37:25 <quicksilver> (sorry for the noise)
04:37:33 <pozic> zygoloid: I also said that ;)
04:37:34 <quicksilver> kamatsu: No, I don't.
04:37:43 <quicksilver> kamatsu: I never have circular dependencies.
04:37:43 <kamatsu> quicksilver: how do you get around it?
04:37:53 <sinelaw> kamatsu, still working on that game?
04:37:57 <quicksilver> kamatsu: However they are legal haskell and GHC supports them. It's just a bit fiddly.
04:38:03 <kamatsu> sinelaw: somewhat on the backburner, but yes
04:38:11 <sinelaw> kamatsu, are you using that lib still?
04:38:16 <sinelaw> or did you find an alternative
04:38:17 <kamatsu> sinelaw: which lib?
04:38:21 <quicksilver> well a typical solution is to move the types involved to "Common.Types" and have A import Common.Types and B import Common.Types
04:38:22 <sinelaw> graphics-drawingcombinators
04:38:28 <pozic> kamatsu: mutual recursive modules is not hard with GHC. Just read the documentation.
04:38:29 <kamatsu> ah, probably will be using them
04:38:37 <kamatsu> but lots of my other GL stuff I am going to write in C
04:38:38 <kamatsu> long story
04:38:50 <sinelaw> kamatsu, because luqui refactored SDL out of it
04:39:01 <sinelaw> (in the github version)
04:39:05 <quicksilver> I tend to think mutually recursive modules are code smell but some people are convinced they are useful.
04:39:15 <sinelaw> kamatsu, what stuff are you going to do in C?
04:39:27 <sinelaw> quicksilver, i hate circular references
04:39:40 <sinelaw> to me they're a sign of bad design
04:40:12 <kamatsu> I don't think my current case is an example of bad design
04:40:40 <kamatsu> I have a thread that has a type for its messages, and this thread manipulates an ADT
04:40:44 <sinelaw> kamatsu, why do you have them?
04:40:58 <kamatsu> the ADT also needs the messages for the threads it spawns
04:41:11 <kamatsu> so that those threads can contact the parent thread
04:41:31 <kamatsu> (ADT standing for abstract, not algebraic, data type)
04:41:43 <quicksilver> is it sufficient to lift the types into a common types module as I suggested?
04:42:09 <kamatsu> I would do that, but this is written in Literate Haskell, and I feel it majorly disrupts the flow of the document
04:42:17 <sinelaw> aha
04:42:20 <kamatsu> I want threads to be bundled with their message type
04:42:31 <quicksilver> literate haskell is not fit for this purpose
04:42:36 <sinelaw> yeah
04:42:42 <quicksilver> it enforces unreasonable restrictions on how you break the code into modules
04:42:48 <sinelaw> haskell's module system needs a to allow multiple modules per file
04:42:53 <quicksilver> that's why Knuth's literate stuff has the weaving/unweaving ability
04:43:04 <sinelaw> s/a//
04:43:07 <quicksilver> so that code order or location rules don't affect the flow of the document
04:43:28 <quicksilver> sinelaw: you mean GHC's compilation system, not haskell's module system.
04:43:28 <kamatsu> unfortunately I'm not using CWEB
04:43:44 <quicksilver> sinelaw: (haskell's module system doesn't know what a file is, as far as I remember)
04:43:49 <sinelaw> quicksilver, oh
04:43:49 <sinelaw> ok
04:44:08 <sinelaw> then that :)
04:44:19 <kamatsu> sinelaw: I am doing the off-screen surfaces in C. Doing it in haskell caused random segfaults
04:44:22 <quicksilver> I'm not sure literate haskell works all that well for things which don't all fit in one module to be honest.
04:44:25 <sinelaw> kamatsu, :(
04:44:40 <quicksilver> it's mostly aimed at the one module = one paper = one document kind of work
04:44:51 <kamatsu> well, tbh I don't care about your opinion
04:45:02 <quicksilver> (!)
04:45:02 <kamatsu> I use literate programming as a means to make myself write better code
04:45:12 <sinelaw> that's quite honest
04:45:19 <quicksilver> perhaps I have managed to come across as more agressive than I intended, kamatsu ?
04:45:27 <quicksilver> I'm not criticising your approach
04:45:33 <quicksilver> I'm criticising the literate haskell tools!
04:45:36 <kamatsu> it seemed to me like you were suggesting abandoning lhs
04:45:51 <quicksilver> I'm saying it's a shame they don't make it easy for you to do what you want
04:45:55 <kamatsu> right
04:45:56 <quicksilver> not that what you want is foolish.
04:46:04 <kamatsu> okay then, no worries
04:46:04 <kamatsu> but
04:46:07 <kamatsu> what should I do?
04:46:19 <kamatsu> use .hsboot files?
04:46:28 <quicksilver> seems like the best answer, yes.
04:46:34 <kamatsu> ew, ok
04:47:40 <kamatsu> sinelaw: At the moment I am working on a code editor server that uses operational transformations
04:47:57 <kamatsu> sinelaw: for real-time collaborative haskell pastebin
04:48:29 <kamatsu> not only that, but the whole thing is all in detailed literate haskell
04:48:46 <kamatsu> so that people who want to make their own OT servers can learn from my example
04:49:16 <quicksilver> would be nice to have some kind of weave/unweave thing though
04:49:19 <quicksilver> for serious lhs work.
04:49:22 <kamatsu> it would
04:49:33 <kamatsu> or even a way to make modules chapters :P
04:49:36 * quicksilver nods
04:50:00 <sinelaw> kamatsu, sounds awesome
04:50:10 <kamatsu> the reason I put the game library on hold is
04:50:15 <kamatsu> I am currently working on the Google Wave team
04:50:22 <kamatsu> I want to take advantage of the expertise of my colleagues in this field
04:50:26 <kamatsu> while I'm working here
04:51:22 <kamatsu> last week I nutted out my own concurrency control algorithms with some of my coworkers, turned out quite different to the way Wave does it
04:52:12 <kamatsu> my one should allow for significantly more "real-time" looking editing (rather than sort of "chunks" that come in Wave), at the expense of some of Wave's features such as playback and history
04:52:41 <medfly> ?
04:52:43 <medfly> gobby
04:52:45 <sinelaw> i don't think that's exclusive
04:52:53 <sinelaw> but it's a lot of work, anyway
04:53:32 <kamatsu> medfly: gobby is not a pastebin, and not something I can deploy for my students
04:53:41 <kamatsu> medfly: also, not written in literate haskell
04:53:45 <medfly> ...
04:53:52 <medfly> none of this is true of google wave!
04:53:57 <kamatsu> medfly: I know?
04:54:11 <sinelaw> hey whoppix
04:54:13 <kamatsu> medfly: doesn't change the fact that my colleagues expertise can help me write a good piece of software
04:54:15 <sinelaw> that was short.
04:54:41 <medfly> gobby is nice. it could be cool if it had some chunks saved every few edits so you could go back.
04:54:59 <kamatsu> it has invertability afaik
04:55:04 <kamatsu> so you should have "undo"
04:55:37 <kamatsu> but real versioning like wave requires some changes to the OT algorithm that most people don't do
04:55:50 <sinelaw> kamatsu, i worked and want to work again on something similar to what you're doing
04:55:56 <Gracenotes> etherpad has it nice
04:56:04 <kamatsu> Etherpad does it the same way as wave
04:56:09 <Gracenotes> yeah
04:56:12 <kamatsu> The Etherpad people are also now my colleagues
04:56:21 <kamatsu> (we bought them out)
04:56:27 <medfly> ...
04:56:34 <sinelaw> oy.
04:56:42 <Gracenotes> ah, yeah, I heard about that
04:56:43 <kamatsu> sinelaw: oh? what did you work on?
04:56:57 <kamatsu> oh, we're not being evil, honest
04:57:01 <kamatsu> we open sourced Etherpad and everything
04:57:21 <sinelaw> kamatsu, something we called a "live editor"
04:57:38 <Gracenotes> I had written my own real-time editor a few years back, final project for AP Computer Science in high school. Had this complicated editor calculus, don't think it entirely worked ;)
04:58:02 <kamatsu> Gracenotes: Operational Transforms are nice, and I stole alot of my exact implementation ideas from Wave. Should work out reasonably cleanly
04:58:04 <sinelaw> where instead of editing textual code, you actually edit the AST (ASG actually) using an interface that ressembles textual code
04:58:18 <kamatsu> sinelaw: how did you transform operations?
04:58:22 <QtPlatypus> Gracenotes: Editor calculus?
04:58:24 <kamatsu> sinelaw: or didn't you get that far
04:58:44 <sinelaw> kamatsu, i'm not sure we did. can you give an exmaple to what you mean by OT?
04:58:50 <kamatsu> sinelaw: uh, sure
04:58:53 <Gracenotes> QtPlatypus: way of dealing with diffs
04:59:07 <Gracenotes> particularly conflicting ones
04:59:07 <kamatsu> so, an operation is some transformation from one state of a document to another
04:59:19 <sinelaw> ok
04:59:24 <kamatsu> the way I (and Wave) model an operation is a simple list of actions that specify how an operation looks
04:59:27 <kamatsu> e.g
04:59:35 <kamatsu> [Retain 50, Insert "abc", Retain 10, Delete "def"]
04:59:54 <sinelaw> kamatsu, oh so we had something similar
05:00:00 <sinelaw> with history
05:00:02 <kamatsu> then, hold on
05:00:05 <kamatsu> there's more
05:00:08 <sinelaw> ok
05:00:09 <sinelaw> go ahead
05:00:32 <kamatsu> suppose my document was like "Foo Bar Baz"
05:00:44 <kamatsu> and a client makes an operation to insert the word "Bop" after "Bar"
05:00:49 <kamatsu> it would be:
05:01:02 <kamatsu> [Retain 8, Insert "Bop", Retain 3]
05:01:09 <mathLearn> What does it mean: Define the set {x | x^2 - (a+b)x + ab = 0}
05:01:27 <kamatsu> But, suppose that the server had already recieved another op, from another client, that inserted the word "Quo"
05:01:40 <kamatsu> i.e [Insert "Quo", Retain 11]
05:01:46 <kamatsu> this op had not yet reached the client
05:01:51 <Gracenotes> mathLearn: in that case, all x for which the equation is true
05:02:03 <kamatsu> Then, when the client's op reaches the server
05:02:15 <kamatsu> the document will look like "QuoFoo Bar Baz"
05:02:23 <Gracenotes> a number is in that set == the number is valid solution for x
05:02:28 <mathLearn> Gracenotes yes but why does my book contain the answer : {a,b}
05:02:29 <kamatsu> and so if we just apply the client's op, it will appear in the wrong spot
05:02:43 <kamatsu> this is where an algorithm called an operational transform comes in
05:02:45 <Gracenotes> mathLearn: work out (x-a)(x-b)
05:02:58 <sinelaw> ah
05:03:07 <sinelaw> sounds interesting
05:03:27 <kamatsu> so, it transforms operations so that they have the same effect on later versions of a document
05:03:47 <sinelaw> nice
05:04:13 <kamatsu> I extend the model Wave so that the client can diverge by an arbitrary amount of operations, and the server keeps track of what operations the
05:04:16 <kamatsu> client is transforming against
05:04:22 <kamatsu> *model Wave has
05:04:39 <sinelaw> hmm
05:04:44 <kamatsu> Wave doesn't do this for a variety of reasons, but for me that means that the editing looks much smoother
05:05:04 <sinelaw> kamatsu, we developed a model where the operations (we called them deltas) were chained in history trees
05:05:15 <kamatsu> sinelaw: were your deltas composable?
05:05:20 <sinelaw> yse
05:05:25 <sinelaw> and what you just described was a merge
05:05:25 <kamatsu> right, Wave does the same thing
05:05:26 <sinelaw> in the tree
05:05:35 <kamatsu> right
05:05:42 <sinelaw> it was quite cool
05:05:43 <kamatsu> technically, this is basically what Darcs does.
05:05:49 <kamatsu> but ask a darcs person about it, not me
05:06:01 <sinelaw> yeah i did a little reading on darcs back then
05:06:23 <kamatsu> anyway, Wave makes deltas composable
05:06:25 <pettter> diff has been in posix since... the 70's? :)
05:06:27 <Gracenotes> okay.. looking over my code, looks like I had a way to reverse revisions, and that's how I dealt with conflicts.
05:06:42 <pettter> diff/patch that is
05:06:43 <kamatsu> and then builds a "composition tree"
05:06:50 <kamatsu> pettter: doesn't solve anything ;)
05:07:11 <Gracenotes> undo one delta that's in conflict, apply the other one, and compose them together. but.. anyway.
05:07:30 <kamatsu> the composition tree means that you can "seek" through history in log n time
05:07:34 <terat0rn> in theory
05:08:02 <kamatsu> because my one doesn't have history, it just stores the composed snapshot and doesn't keep individual ops at all
05:08:03 <terat0rn> in practice it seems to work but nobody really knows how
05:08:54 <sinelaw> kamatsu, oh
05:09:09 <sinelaw> kamatsu, sounds like we did exactly what wave does (more or less)
05:09:35 <sinelaw> except we did it in Python :) at some point we realized we were actually implementing functional programming, so we stopped and started learning Haskell
05:09:43 <kamatsu> right
05:09:45 <terat0rn> bahahaha
05:09:45 <sinelaw> not much progress since then, the learning curve was huge
05:09:51 <kamatsu> Wave's OTs were prototyped in Haskell
05:09:57 <terat0rn> did you learn you some haskell
05:09:59 <kamatsu> but then written in Java
05:10:03 <sinelaw> oy
05:10:04 <sinelaw> why
05:10:11 <kamatsu> All of Wave is Java
05:10:15 <kamatsu> it's a long story as to why
05:10:42 <kamatsu> but it's possible that when we release more protocols, our Haskell prototype will become the canonical wave OT implementation
05:10:46 <Gracenotes> it's pretty neat anyway
05:11:32 <kamatsu> certainly lots of work has been put into it
05:11:38 <sinelaw> great
05:11:46 <kamatsu> currently my job has nothing to do with OTs anymore
05:11:53 <kamatsu> mostly I'm working on the client
05:12:02 <kamatsu> i.e making it work, making it fast, making it have useful features
05:12:06 <sinelaw> kamatsu, http://enough.googlecode.com/files/livec.ogv
05:12:25 <Gracenotes> â‡”
05:12:28 <kamatsu> hm?
05:12:41 <sinelaw> a video of our abondoned prototype
05:13:10 <terat0rn> http://bit.ly/learn-you-a-haskell
05:13:16 <kamatsu> hey, cool
05:13:38 <sinelaw> kamatsu, do you know if Google Israel works on stuff in haskell too?
05:13:56 <Gracenotes> sinelaw: good IDE stuff.. requires more than an AST, though
05:14:17 <sinelaw> Gracenotes, what do you mean
05:14:24 <kamatsu> sinelaw: I don't know at all about Google Israel
05:14:30 <Gracenotes> hm, you mentioned an ASG.
05:14:30 <kamatsu> We have a few other bits and pieces in Haskell
05:14:43 <kamatsu> but no projects are written in Haskell
05:14:51 <kamatsu> most of our stuff is Java
05:14:56 <kamatsu> and C++
05:14:58 <kamatsu> and JS
05:15:07 <sinelaw> bleh
05:15:07 <kamatsu> and a decent smattering of python
05:15:08 <Gracenotes> and Python?
05:15:13 <kamatsu> not as much as the others
05:15:31 <terat0rn> cyclone ftw
05:16:12 <kamatsu> we only really have python because Guido works for us
05:16:26 <kamatsu> tbh, Google discourage its use in user-facing products
05:16:36 <kamatsu> until Unladen Swallow is good
05:17:17 <terat0rn> I thought google wanted to make Python faster.. seems a waste if its being phased out
05:17:28 <kamatsu> terat0rn: er, read what i said ;)
05:17:36 <kamatsu> until unladen swallow is good
05:17:37 <terat0rn> :/
05:17:39 <terat0rn> oh
05:17:41 <terat0rn> yeah
05:17:44 <sinelaw> ok, bbl.
05:18:10 <kamatsu> anyway, Google make their language choices based not entirely on the quality of the language
05:18:12 <terat0rn> I wonder if they're stealing any ideas from Boo
05:18:21 <kamatsu> why would they?
05:18:22 <terat0rn> e.g. optional static typing
05:18:35 <kamatsu> no, Unladen Swallow does not alter the semantics of the language significantly
05:18:39 <terat0rn> well, Boo is static by default, w/ optional dynamic typing, but w/e
05:18:49 <terat0rn> hum
05:19:03 <kamatsu> it's just to make Python fast, that's all
05:19:10 <terat0rn> yeh
05:19:24 <CalJohn> IMO the chief problem of writing anything significant in Python is not speed
05:19:45 <kamatsu> anyway, most of the programmers I know at Google are Haskell or Mercury fans.. and we complain about using Java all the time, but we universally agree that it was the best choice for Wave
05:19:53 <terat0rn> CalJohn: yea the speed never bothered me either, but I'm not google :/
05:20:20 <terat0rn> what's Java's selling points, and dont say exceptions-by-contract
05:20:33 <CalJohn> good tools, wide acceptance, fast
05:20:39 <kamatsu> the reason we chose Java isn't because of Java's features of a language, but a wide variety of other reasons
05:20:39 <Gracenotes> because.. tools available? imperative speed guarantees?
05:20:42 <CalJohn> medium-to-poor quality checking
05:20:52 <terat0rn> yeah
05:20:54 <kamatsu> we have an amazingly huge library of java tools
05:20:57 <kamatsu> and frameworks
05:20:59 <kamatsu> that we use internally
05:21:02 <CalJohn> Java as an SE tool has every selling people
05:21:05 <CalJohn> *point
05:21:06 <terat0rn> one class per file
05:21:13 <kamatsu> furthermore, we have GWT
05:21:24 <kamatsu> Wave needs to do OTs and Composition and modelling on both client and server
05:21:28 <CalJohn> on class per file is never an issue
05:21:40 <kamatsu> if we can't implement the client and server in the same language, we're pooched
05:21:40 <terat0rn> CalJohn: I know.
05:22:08 <kamatsu> so our choices were narrowed significantly to GWT/Java and JS on both sides
05:22:20 <kamatsu> we chose Java because of our existing tools and static typing
05:22:27 <terat0rn> kamatsu: well, what you need is a Deferred class for each implementation language.
05:22:39 <kamatsu> terat0rn: what?
05:22:51 <terat0rn> kamatsu: it's an asynchronous primitive
05:22:55 <mornfall> Well, static typing within the context of Java is kind of an overstatement...
05:23:05 <terat0rn> the wire-level implementation of which is called AMP.
05:23:05 <kamatsu> mornfall: we use Java right ;)
05:23:16 <kamatsu> terat0rn: nothing to do with that
05:23:20 <kamatsu> terat0rn: we just want to share code
05:23:36 <terat0rn> i was referring to writing clients and servers in differing languages.
05:23:56 <kamatsu> terat0rn: we need to have (complicated!) Operational Transform algorithms on both client and server
05:24:03 <terat0rn> oh my god
05:24:09 <BONUS> kamatsu: why don't y'all use scala or some other JVM based language that can interact with your java libraries
05:24:18 <kamatsu> BONUS: no Scala -> JS compiler ;)
05:24:38 <BONUS> aah
05:24:52 <Botje> ..YET!
05:24:55 <kamatsu> in fact, my haskell-based OT editor will need me to reimplement some stuff in JS, which is sad
05:25:00 <Botje> what are you waiting for! :)
05:25:05 <kamatsu> Botje: GWT team may be working on it
05:25:05 <CalJohn> is anyone working on a Scala -> JS compiler?
05:25:08 <kamatsu> GWT
05:25:08 <terat0rn> as a simple user I just dont know what java is Really good for except wasting all my memories
05:25:19 <kamatsu> terat0rn: that's just troll talk
05:25:21 <terat0rn> i guess it is better server-side
05:25:26 <kamatsu> terat0rn: java doesn't use a great deal of memory
05:25:38 <Alpounet> the JVM is really good piece of software
05:25:42 <Alpounet> we just can't deny that
05:25:46 <Alpounet> +a
05:25:55 <terat0rn> i dont deny that Sun know how to write a programming language
05:26:03 <flux> I actually thought GWT worked on the bytecode level, but perhaps I'm remembering wrong.. ?
05:26:09 <kamatsu> flux: no, not quite
05:26:11 <CalJohn> kamatsu: the java and memory consumption link is not entirely unfounded, and i say this as a java advocate
05:26:27 <kamatsu> CalJohn: I think it's more that Java programmers aren't cautious about memory usage
05:26:29 <Alpounet> CalJohn, agreed, it's just exagerated
05:26:43 <Alpounet> because of some badly written Java softwares
05:26:43 <kamatsu> the VM itself, and Java programs generally, are not inherently more memory consuming
05:26:44 <terat0rn> sounds about right :)
05:26:55 <kamatsu> just bad programs
05:27:03 <kamatsu> unfortunately wave is one of them
05:27:10 <kamatsu> our generated GWT JS uses 100mb of RAM
05:27:19 <mornfall> Bad programs in Java are abundant because bad programmers are. : - )
05:27:22 <kamatsu> one of the things we're hoping to fix
05:27:23 <Alpounet> kamatsu, are there great improvements going on for Wave ?
05:27:30 <kamatsu> Alpounet: certainly are ;)
05:27:40 <Alpounet> (performance wise, I meant)
05:27:45 <kamatsu> indeed
05:27:47 <Gracenotes> if you ever look at a Java heap profile, it can be terrifying how many objects are created (on the bright side, looks like they get collected fast)
05:27:49 <kamatsu> i'm on the performance optimizing team
05:28:01 <mornfall> Gracenotes: You could say same of Haskell. :)
05:28:11 <mornfall> 400M/s allocation rate is nothing unusual...
05:28:18 <Gracenotes> Haskell's is specifically designed for that :)
05:28:27 <kamatsu> Gracenotes: so, really, is Java's.
05:28:42 <Gracenotes> but not enough... it's one of the things that make JVM Haskell somewhat problematic
05:28:43 <CalJohn> java has a generation collector too
05:29:27 <mornfall> Now, I wish we'd get unpinned bytestrings. : - ( This ... issue ... reflects poor on GHC/Haskell...
05:30:30 <mornfall> +ly
05:30:36 <flux> I think it's fair to say that in general functional languages have higher allocation rates (and correspondingly tuned GCs) that imperative/oo languages
05:30:52 <flux> higher as in number of objects allocated
05:30:54 <kamatsu> this is true
05:31:01 <CalJohn> generalising imperative languages is a big generalisation, imo
05:31:09 <mornfall> :)
05:31:17 <CalJohn> the difference between having a generational gc and a mark-and-sweep is a big one
05:31:39 <CalJohn> i wish google would improve the dalvik GC, that one causes me pain on a daily basis
05:34:27 <kamatsu> CalJohn: it does? dalvik seems nice to me.. then again I've never used it
05:35:00 <CalJohn> the dalvik gc is non-generational
05:35:24 <CalJohn> many of the things about dalvik are surprisingly immature compared to sun's JVM
05:35:31 <mornfall> You could argue that generationality is just a locality hack. : - )
05:36:01 <CalJohn> also, dalvik's GC is pretty prone to pauses
05:36:35 <terat0rn> quality entertainments for the whole family - http://bit.ly/bofh-home
05:46:44 <Botje> simon's been slacking off
05:46:52 <Botje> it's february and no new bofh yet :(
05:54:13 <rajeshsr> hi
05:54:25 <rajeshsr> how can i implement a binary indexed tree in haskell?
05:54:26 <rajeshsr> http://programmersdream.com/data-structure/binary-indexed-tree/
05:54:45 <rajeshsr> that link explains what it is
05:56:35 <Gracenotes> er. well, Haskell has arrays. and ways to update a list of indices.
05:56:44 <Gracenotes> (relatively efficiently)
05:57:00 <Gracenotes> at least, given a current array, returning a new one with said updates
05:57:25 <rajeshsr> Gracenotes, oh, ok!
05:57:26 <xerox> also there are different ways for different usecases (e.g. DiffArrays versus IO ones)
05:57:36 <xerox> (and ST of course)
05:57:41 <rajeshsr> thanks, let me check out
05:57:53 <Gracenotes> and with int arrays, unboxed immutable arrays have fast access times
05:58:48 <rajeshsr> hmm, so if I want to write some non-trivial programs in haskell any resource is recommended?
05:59:15 <Gracenotes> base library? ._.
05:59:50 <kuribas> rajeshsr: I am reading "Read World Haskell", and I think it is the best I have read about Haskell.
06:00:08 <sinelaw> holy moley
06:00:13 <sinelaw>         dPick = (fmap.fmap.fmap.fmap.fmap) f (dPick d)
06:00:28 <kamatsu> sinelaw: what's this?
06:00:31 <Axman6> o.O
06:00:39 <sinelaw> kamatsu, a line of code from graphics-drawingcombinators
06:00:44 <kamatsu> er
06:00:45 <rajeshsr> kuribas, oh, ok! thanks
06:00:46 <kamatsu> what does it do?
06:00:56 <kamatsu> looks like fix almost
06:01:08 <kamatsu> @src fix
06:01:08 <lambdabot> fix f = let x = f x in x
06:01:10 <sinelaw> trying to figure out
06:01:25 <Saizan_> i guess that's in the middle of a record update?
06:01:47 <Gracenotes> well, that's how them combinators are. I wonder how many types are represented there
06:01:49 <Saizan_> it's just applying 'f' under 5 functors to dPick d
06:01:57 <sinelaw> yeah
06:01:58 <Gracenotes> well, how many functor instances
06:02:01 <sinelaw> should have used SECs
06:02:03 <kamatsu> which is itself dPick.
06:02:05 <rajeshsr> @src const
06:02:05 <lambdabot> const x _ = x
06:02:28 <Saizan_> kamatsu: i think it's something like foo { dPick = (fmap.fmap.fmap.fmap.fmap) f (dPick d) }
06:02:59 <Saizan_> s/foo/d/ -- even
06:03:21 <sinelaw> Saizan, yip
06:03:41 <kamatsu> ah
06:03:50 <Gracenotes> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.1.0/doc/html/src/Graphics-DrawingCombinators.html#line-99
06:03:57 <sinelaw> @type fmap :
06:03:58 <lambdabot> parse error (possibly incorrect indentation)
06:03:58 <sinelaw> @type fmap
06:03:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:04:15 <sinelaw> @type fmap :: (a->b) -> (c->a) -> (c->b)
06:04:15 <lambdabot> forall a b c. (a -> b) -> (c -> a) -> c -> b
06:04:21 <sinelaw> @src fmap :: (a->b) -> (c->a) -> (c->b)
06:04:21 <lambdabot> Source not found. stty: unknown mode: doofus
06:04:27 <sinelaw> heh, doofus.
06:04:52 <sinelaw> fmap on functions is composition?
06:05:20 <Gracenotes> @type (.)
06:05:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:05:22 <Saizan_> (the name Semantic Editor Combinator is as silly as Arrow, unless it's a synonym for "any combinator")
06:05:32 <Saizan_> sinelaw: yes
06:05:56 <sinelaw> and on tuples?
06:06:10 <Saizan_> the type tells you
06:06:18 <Saizan_> however, it's second
06:06:54 <sinelaw> ok, how does the type tell?
06:07:20 <Saizan_> you can only make a functor instance for "(,) a"
06:07:50 <Saizan_> and (a' -> b) -> (,) a a' -> (,) a b, has only one non-bottom implementation
06:07:59 <quicksilver> Saizan_: I don't think it's a completely useless name.
06:08:18 <quicksilver> Saizan_: "editor" implies it has a type like a -> a, because it's "Editing" things so they don't change type
06:08:42 <Saizan_> quicksilver: do they fit that description?
06:08:44 <quicksilver> Saizan_: and the 'semantic' part says that it respects some intended semantics although of course you need to know what to make that interesting.
06:09:32 <Gracenotes> because I'm curious.. > :t (fmap.fmap.fmap.fmap.fmap.fmap) ?x (undefined :: Affine -> GLuint -> IO (GLuint, Data.Set.Set GLuint -> a))
06:09:33 <Saizan_> i thought the meaning was that they are combinators that edit the semantic
06:09:37 <sinelaw> i don't like it that style, fmap.fmap.fmap.fmap....
06:09:40 <sinelaw> totally unreadable
06:09:41 <Gracenotes> it says: (Functor f, ?x::a -> b) => Affine -> GLuint -> IO (GLuint, S.Set GLuint -> f b
06:09:45 <Saizan_> that's how i read it
06:10:07 <sinelaw> Gracenotes, in that case it's fmap. (.) . snd . fmap :: IO .  (.)
06:10:14 <quicksilver> sinelaw: like all kinds of unreadability, it's perfectly readable once you know what it is.
06:10:28 <sinelaw> quicksilver, i know what it is, but it doesn't make it any more readable
06:10:31 <quicksilver> sinelaw: chains of fmaps map through multiple nested functors
06:10:35 <sinelaw> unless i follow manually through the types
06:10:37 <Gracenotes> sinelaw: yeah. eesh, I wish library writers wouldn't use tricks like that
06:10:48 <quicksilver> I find that perfectly readable but it does require you to check the type.
06:10:53 <quicksilver> (and know the Functor instances)
06:11:03 <sinelaw> what's the point then
06:11:05 <quicksilver> the fact you have to check somewhere else makes it a bit 'less local' which is annoying.
06:11:25 <quicksilver> well part of the point is that 'fmap' doesn't have a specific name for most functors
06:11:28 <sinelaw> exactly what bothers me, i have to understand a lot more code
06:11:31 <quicksilver> it doesn't for IO
06:11:42 <sinelaw> that's true
06:11:47 <quicksilver> and for tuples, 'second' is no better than fmap
06:11:48 <Gracenotes> I tend to think of IO when I see liftM
06:11:55 <quicksilver> it's an equally generic type
06:11:57 <quicksilver> :t second
06:11:58 <Gracenotes> as opposed to fmap
06:11:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
06:12:12 <quicksilver> arguably 'second' is worse than 'fmap', it's forall over 4 variables.
06:12:35 <sinelaw> quicksilver, snd
06:12:40 <quicksilver> sinelaw: wrong.
06:12:43 <sinelaw> why?
06:12:52 <Saizan_> ?type [snd, second]
06:12:53 <lambdabot>     Occurs check: cannot construct the infinite type:
06:12:53 <lambdabot>       b = ((d, a), (d, b))
06:12:53 <lambdabot>       Expected type: b
06:12:55 <sinelaw> :t snd
06:12:56 <lambdabot> forall a b. (a, b) -> b
06:13:00 <quicksilver> how shall I answer that question, sinelaw ? ;)
06:13:05 <quicksilver> it's wrong because, well, it's something else :)
06:13:36 <Gracenotes> [second, fmap], no?
06:13:51 <quicksilver> things like this *do* make me wish I had an editor which could annotate methods with the type they are instantiated at in a particular place
06:14:09 <quicksilver> I agree it's a bit frustrating that the information isn't collected in one place
06:14:20 <sinelaw> :t (a->c)->(a,b)->(a, c)
06:14:21 <lambdabot> parse error on input `->'
06:14:22 <quicksilver> but I don't think the answer is to define a specialiased fmap with a different name for every functor
06:14:30 <quicksilver> we'd just end up giving them stupid names like fmap_IO
06:14:31 <sinelaw> @hoogle (a->c)->(a,b)->(a, c)
06:14:31 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:14:31 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:14:31 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
06:14:40 <sinelaw> eww
06:14:57 <sinelaw> quicksilver, i don't know what the solution is, but it's totally unreadable
06:15:07 <Gracenotes> well, we know which library Hoogle has a crush on
06:15:08 <sinelaw> until you already know what it means
06:15:24 <Saizan_> sinelaw: keep a ghci handy and do :t dPick, it's all clearer then :)
06:15:42 <sinelaw> Saizan_, :) that's probably not the solution either
06:15:47 <quicksilver> well to me, fmap.fmap.fmap.fmap instantly reads as "fmap through four levels of Functor"
06:15:53 <quicksilver> do you agree that is clear?
06:15:59 <mux> I read it as "fap fap fap fap"
06:16:00 <Gracenotes> @hoogle (a -> c) -> (b, a) -> (b, c)
06:16:01 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:16:01 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:16:01 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
06:16:01 <quicksilver> or do you think *that* part is unclear?
06:16:05 <mux> but that's 4chan's fault.
06:16:07 <Saizan_> why not? with the type and the functor laws make it pretty clear
06:16:08 <sinelaw> quicksilver, yes, that is clear
06:16:28 * quicksilver nods
06:16:44 <sinelaw> but "what does this actually do?" is not clear.
06:16:59 <quicksilver> it's a very very common think in writing Functor instances
06:17:11 <quicksilver> because if things are Functors it is very often because they are compositions of Functors.
06:17:23 <quicksilver> you can make that explicit with a TypeCompose newtype but that's even uglier...
06:17:24 <Gracenotes> a layer of functorness in a data type is not immediately obvious
06:17:45 <Saizan_> Gracenotes: do you have an example?
06:17:56 <Gracenotes> you have to work through the type constructors..
06:18:09 <Saizan_> with the limits of current instance resolution i'd think it'd be pretty obvious
06:18:19 <Gracenotes> well, the motivating example, with 6 layers: Affine -> GLuint -> IO (GLuint, Data.Set.Set GLuint -> a)
06:18:42 <Gracenotes> okay, function application, function application, IO, tuple, function application... well, that's 5.
06:19:27 <RayNbow> <mux> but that's 4chan's fault. <-- here's a reverse challenge... make a 4channer read "fap" as "fmap" :p
06:19:43 <Gracenotes> that might have been tried on /prog/
06:19:44 <Saizan_> segmenting that in * -> * pieces feels natural to me
06:20:10 <Saizan_> however, i'd like a working deepFmap, actually
06:20:33 * quicksilver mutters about overlapping instances and incoherence.
06:20:36 <Gracenotes> you do have to be familiar with the (possibly complicated) type itself, and with the instances that already exist.
06:20:41 <Saizan_> for the same reason that we don't go around using lift . lift . lift . ...
06:21:09 <Saizan_> Gracenotes: you don't have to know which instances exist
06:21:53 <Gracenotes> fmap for functions is not immediately obvious
06:22:26 <Gracenotes> particularly when it's composed with other fmaps... hm.. brain hurting somewhat
06:23:15 <Saizan_> Gracenotes: it's obvious to djinn! and anyhow, that's like not knowing what (+) does for Int, i'd say
06:23:46 <pozic> Is there a way to show all top-level functions in Emacs in some kind of dock?
06:23:56 <companion_cube> how can I make ghc compile all libs in the binary, so that running it on a computer without haskell libs works ?
06:24:03 <Gracenotes> heh. you have to be familiar with it. If you haven't seen a given functor instance before, there's the one-time cost of figuring out what it does
06:24:20 <Gracenotes> to see how the type structure is being altered
06:24:38 <Saizan_> Gracenotes: no, really, you don't need to know which instances there are to see how the types change
06:24:57 <rajeshsr> @src product
06:24:57 <lambdabot> product = foldl (*) 1
06:24:58 <Saizan_> Gracenotes: if you know it typeckecks you can derive which instances it used
06:25:15 <Gracenotes> Saizan: if it typechecks... yeah, type constructor. But what it *does*
06:25:34 <Saizan_> what it does is implied by the functor laws
06:25:51 <Gracenotes> that's intrinsically tied with what the data structure itself (of function) is
06:25:53 <Gracenotes> *or
06:26:26 <Saizan_> sure
06:27:06 <Saizan_> pozic: a ghci buffer where you type :browse at regular intervals?:)
06:29:04 <BONUS> i really wish ghci had a :src command
06:29:15 <Gracenotes> actually, it's not so bad when you think of it (in the rendering example) as just transforming Affine -> GLuint -> IO (GLuint, Set GLuint -> a) into Affine -> GLuint -> IO (GLuint, Set GLuint -> b)
06:29:29 <Gracenotes> which is the point
06:29:58 <Gracenotes> it's a bit of an odd type to begin with :)
06:30:15 <kuribas> pozic: I have emacs code to narrow the buffer to toplevel lines.  It can be used with any mode.
06:30:15 <Gracenotes> (with a function (a -> b), of course)
06:31:11 <companion_cube> excuse me, I cannot find how to tell ghc *not* to use shared libs
06:31:24 <companion_cube> do you have an idea of the good options ?
06:31:29 <Saizan_> companion_cube: for C libs, you mean?
06:31:34 <companion_cube> yes
06:31:40 <companion_cube> (and haskell libs)
06:31:56 <Saizan_> haskell libs are linked statically by default.
06:32:08 <companion_cube> my purpose is to make a binary which does not depends on which libs are installed on the system
06:32:30 <sinelaw> companion_cube, statically linked?
06:32:35 <Axman6> that should be the default i think
06:32:51 <Saizan_> you might need something like -optC-static
06:33:04 <Saizan_> or -optl-static ?
06:34:51 <companion_cube> it gives me linking errors -_-
06:37:59 <pozic> companion_cube: have you tried it?
06:38:35 <pozic> When I moved Debian compiled GHC code to RedHat, it didn't work, though.
06:38:53 <pozic> I got floating point exceptions when I executed the code.
06:39:21 <pozic> It probably is related to the reason why you can download two different versions of GHC for those platforms.
06:42:49 <companion_cube> pozic: I trid with --make -Wall -lffi -optc-static -optl-static, and it gave me a ld error
06:44:39 <companion_cube> tried*
06:56:02 <kamatsu> hm, I want to iterate through a Data.Map, but I want to run an IO action on each element, not a pure function
06:56:15 <kamatsu> so, is there a different sort of Map I can use, or a function for such?
06:57:48 <Zao> kamatsu: Grab all values and mapM them?
06:57:57 <Zao> From a suitably generated list or so.
06:57:58 <sinelaw> is `Set.member` not valid syntax?
06:58:06 <Gracenotes> forM_ (Map.toList blah) $ \elem -> evel IO
06:58:24 <Gracenotes> *evil ('eval' works there too)
06:58:30 <kamatsu> but, I also want to use the return value of the IO action to replace the item in the map
06:58:34 <sinelaw> @type member
06:58:35 <lambdabot> Not in scope: `member'
06:58:38 <sinelaw> @type Set.member
06:58:39 <kamatsu> I'd rather not do several O(n) passes
06:58:39 <lambdabot> Couldn't find qualified module.
06:58:46 <sinelaw> arrrrgh
06:58:58 <sinelaw> @vixen you are annoying
06:58:58 <lambdabot> i don't think i'm annoying
06:59:03 <sinelaw> @vixen but you are
06:59:04 <lambdabot> You think this is a botiecall??
06:59:09 <kamatsu> sinelaw: shut up
06:59:16 <Gracenotes> kamatsu: have you seen M.fromDistinctAscList?
06:59:16 <kamatsu> :P
06:59:25 <kamatsu> Gracenotes: hmm, not yet
07:00:12 <kamatsu> Gracenotes: what does that achieve?
07:00:23 <kuribas> Data.Traversable has a mapM that works for Functors.
07:00:36 <kamatsu> kuribas: it does? awesome
07:00:47 <Gracenotes> hm.. alleviates some of the cost of reconstruction.
07:01:14 <kamatsu> Gracenotes: still 3n to deconstruct map, run my io action, and then reconstruct map
07:01:20 <Gracenotes> this is one of those argument for effect types :) there is a Traversable instance, though, actually
07:01:25 <kamatsu> n will be large
07:01:27 <kamatsu> right
07:01:29 <kamatsu> cool
07:01:38 <Gracenotes> traverse f (Bin s k v l r) = flip (Bin s k) <$> traverse f l <*> f v <*> traverse f r
07:02:44 <Gracenotes> the spine must be reconstructed in any case, but the way here seems direct
07:02:59 <Gracenotes> ish
07:03:52 <zygoloid> the implementation of Debug.Trace.trace uses {-# NOINLINE trace #-}. why is that necessary? what 'bad' transformations does it prevent?
07:04:26 <quicksilver> zygoloid: if the trace gets inlined, it's a constant expression and can be lamda lifted
07:04:40 <quicksilver> which may make the printing happen earlier than expected or less often than expected
07:04:43 <quicksilver> (or both)
07:05:12 <zygoloid> quicksilver: can you give a concrete example? all the cases i can think of can still happen if it's not inlined
07:05:56 <Gracenotes> shouldn't there be a specific rule against lambda lifting unsafePerformIO?
07:06:25 <quicksilver> zygoloid: I think, on reflection, that I don't understand :)
07:07:07 <zygoloid> if it were 'trace s x = unsafePerformIO (putStrLn s) `seq` x' then i could entirely understand the NOINLINE
07:08:42 <Saizan_> @src trace
07:08:42 <lambdabot> trace string expr = unsafePerformIO $ do
07:08:42 <lambdabot>     hPutStrLn stderr string
07:08:42 <lambdabot>     return expr
07:09:04 <zygoloid> i guess the simple answer is 'because the unsafePerformIO docs say so'
07:10:16 * Saizan_ wonders if unsafePerformIO itself is inlined
07:11:05 <zygoloid> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
07:11:08 <zygoloid> {-# NOINLINE unsafeDupablePerformIO #-}
07:15:09 <Alpounet> how can I know if a process has terminated or not (I launched it with runInteractiveProcess) ?
07:16:33 <aledge> I'm trying to figure out what a haskelly representation of different objects in a game would be like
07:17:14 <aledge> I figure that each object is essentially a function that transforms the state to a new state
07:17:29 <Saizan_> Alpounet: i guess waitForProcess is not enough?
07:17:37 <aledge> but then the obvious representation of (state, state -> state) seems silly
07:17:55 <Saizan_> why?
07:17:55 <Alpounet> Saizan, actually I need to kill the process if it takes too long
07:18:25 <Alpounet> so no waitForProcess isn't enough
07:18:40 <aledge> it seems like whatever gameUpdate function there is just kind of picks up the state and drops it into the function
07:18:46 <Gracenotes> that's what threads are for
07:18:56 <Saizan_> well you can set a timeout on the thread calling waitForProcess and kill the process if it expires
07:19:18 <Alpounet> hmm yeah I guess it will be sufficient
07:19:19 <Gracenotes> Saizan_: except, would that fail, since waitForProcess is probably native?
07:19:19 <Saizan_> aledge: yeah, that would be it
07:19:33 <Alpounet> thanks Gracenotes and Saizan
07:19:47 <Gracenotes> and C call, and last I heard not friendly with the killing
07:19:58 <Saizan_> mh, that might be true
07:20:06 <Saizan_> though the IO manager might help
07:20:10 <Saizan_> ?hoogle timeout
07:20:11 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
07:20:11 <lambdabot> module System.Timeout
07:20:11 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
07:21:06 <Saizan_> it works even if you don't interrupt waitForProcess, actually
07:21:15 <aledge> Saizan, does that seem dumb? or would that be the way to go?
07:21:18 <Saizan_> if you don't try to, i mean
07:21:32 <Saizan_> aledge: it's not dumb at all
07:21:33 <aledge> that way it's easy to add new types of objects to the game
07:21:37 <Gracenotes> Saizan: yeah.. oh, that would end up terminating
07:21:43 <zygoloid> aledge: perhaps more like: (objectState, TimeDelta -> (gameState, objectState) -> (gameState, objectState))
07:21:51 <aledge> zygoloid, well i'm simplifying it a bit
07:22:07 <aledge> zygoloid, I figured the whole computation would be a Reader with the entire game state as the environment
07:22:15 <Gracenotes> oh, you can have a state -> state. But it doesn't have to be *part*of the data structure, does it?
07:22:33 <aledge> Gracenotes, no, but then I need to know which function to apply to which state
07:22:40 <Alpounet> <Saizan_> it works even if you don't interrupt waitForProcess, actually <<< just have to kill the thread in which it's being executed, right ?
07:22:49 <Gracenotes> pattern-matching?
07:22:55 <Saizan_> aledge: you're describing something like this http://cale.yi.org/index.php/A_look_at_OO_from_Haskell it seems
07:23:28 <aledge> Saizan, well I keep thinking about it, and basically I feel like I'm implementing OO in haskell. I don't know if that's good or bad, but I thought there might be a better/more haskelly way to do it
07:24:00 <aledge> I also want to avoid something like Data GameObject = Ship1 {...} | Ship2 {...} | ... | Asteroid {...} | Missile {...}
07:24:13 <aledge> s/Data/data
07:24:21 <mm_freak> data GameObject = forall a. GameObject { gameObject :: a, runObject :: a -> a }
07:24:31 <Saizan_> Alpounet: you can have a thread doing "waitForProcess pid"and another thread that "threadDelay n >> killProcess pid" at that point the first thread will unblock simply because the process was terminated
07:25:37 <aledge> mm_freak, well in that case wouldn't I not need to include the runObject function?
07:25:42 <Saizan_> aledge: there are cases where focusing on the general interface is appropriate, "game with multiple entities" seem to be one
07:25:50 <mm_freak> aledge: you would
07:26:00 <Saizan_> aledge: the article is basically saying this :)
07:26:03 <mm_freak> it's like an emulation of OOP in haskell
07:26:04 <aledge> mm_freak, then what is the advantage to the existential type
07:26:12 <mm_freak> or rather an emulation of OOP polymorphism
07:26:32 <Alpounet> Saizan_, ok, I got it well then, thanks.
07:26:37 <Saizan_> mm_freak: that GameObject type is pretty useless
07:26:41 <aledge> Saizan, I will probably have to read the article
07:26:50 <mm_freak> Saizan_: in what way?
07:27:12 <Saizan_> mm_freak: there's no way to get an observable result out of it
07:27:29 <mm_freak> well, there is, if you add additional functions
07:27:42 <aledge> mm_freak, furthermore, the question was how to avoid storing the function with each piece of state
07:27:50 <mm_freak> data GameObject = forall a. GameObject { gameObject :: a, runObject :: a -> a, showObject :: a -> String, drawObject :: a -> IO Something }
07:28:04 <aledge> mm_freak, well not *the* question
07:28:04 <aavogt> hpaste is down with a 500 error...
07:28:09 <mm_freak> aledge: you can't with that approachâ€¦  it's in no way good
07:28:09 <aledge> *a* question, hehe
07:28:12 <mm_freak> in fact it sucks
07:28:19 <aledge> what sucks?
07:28:33 <Saizan_> if you use a typeclass you can
07:28:36 <mm_freak> my approachâ€¦  it's not elegant, not particularly fast, not anything
07:28:43 <aledge> oh ok
07:28:44 <mm_freak> it just works
07:28:46 <aledge> hehe
07:28:51 <aledge> yes, i could go the typeclass route
07:28:54 <Saizan_> (store the code only once per type, i mean)
07:29:04 <mm_freak> yeah, typeclasses are better
07:29:08 <aledge> then i need to make a wrapper type so they can all sit in a list
07:29:20 <aledge> dang that paper is blocked at work :(
07:29:32 <mm_freak> for each kind of game object you need a type
07:30:03 <mm_freak> instance Drawable Player where draw (Player a b c) = â€¦
07:30:08 <Saizan_> @tell mmorrow ohai, hpaste's DB is locked, please unlock, kthx ;)
07:30:08 <lambdabot> Consider it noted.
07:30:13 <aledge> mm_freak, well not *necessarily* if you bundle its function with it, right?
07:30:18 <aledge> you need two functions, a state update and a render
07:30:19 * ksf wonders what oleg had smoked when writing 'iteratees compose'
07:30:25 <aledge> an object can be like
07:30:30 <mm_freak> isn't that what you want to prevent?
07:30:34 <aledge> well yeah
07:30:35 <aledge> hehe
07:30:38 <aledge> I'm going in circles :(
07:30:49 <Saizan_> aledge: read the article :)
07:30:51 <aledge> well i guess - /is/ that something I want to prevent?
07:30:53 <ksf> ...the library is like a puzzle with about 1000000 pieces.
07:31:03 <mm_freak> probably yes
07:31:06 <mm_freak> what article anyway?
07:31:16 <Saizan_>  http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
07:31:24 <aledge> Saizan, article brings up "Acceptable Use Compliance" notification, makes me nervous. Also reminds me that I'm not supposed to be figuring out how to write  game in Haskell at work.
07:31:38 <aledge> I'll read it later, though
07:31:41 <Saizan_> hah
07:31:51 <aledge> thx
07:32:09 <aledge> could also almost see doing it the scheme way
07:32:11 <aledge> with messages
07:32:40 <aledge> GameObject -> Message -> ( something -> something)
07:32:41 <Saizan_> well, i'm not sure if you lose anything by putting the code inside the record directly, you lose a machine checked guarantee that all the objects of some kind behave the same though
07:32:42 <aledge> anywya
07:33:09 <Saizan_> s/anything/anything important/
07:33:10 <aledge> it just seemed inefficient given that there will probably be several objects that are supposed to behave the same way
07:33:44 <mm_freak> use typeclasses
07:33:49 <mm_freak> it'll be much cleaner anyway
07:34:05 <Saizan_> yeah, but all these functions fields would probably end up pointing to the same chunk of memory
07:34:13 <aledge> Saizan, hopefully
07:34:25 <mm_freak> data GameObject = forall a. (Drawable a, Runnable a, Locatable a) => GameObject a
07:34:28 <aledge> Saizan, haha, otherwise the implementers of ghc don't understand immutability
07:34:51 <Saizan_> aledge: well, you have to give enough sharing hints :)
07:34:58 <mm_freak> GHC is amazing when it comes to optimization
07:35:35 <mm_freak> today's GHC even saves me from typing a lot of seqs or bang patterns
07:35:38 <pozic> Type-classes for user-defined domain objects are only useful if you want other people to use your proprietary code.
07:36:12 <mm_freak> pozic: they make your code cleaner, too, but that's probably the same statement =)
07:36:15 <pozic> Most of the time type-classes abstract over stuff which doesn't really add anything.
07:36:16 <mlesniak> What could be the reason that the sparks I create with par are not 'converted'?
07:36:16 <Saizan_> if you have [Foo { field = someFunc 1 }, Foo { field = someFunc 1 }], they have the same value for the same field, but "someFunc 1" is almost surely allocated twice by GHC
07:36:22 <sinelaw> how can i tell cabal to compile with profiling but not use profiling for all sub-libraries?
07:36:49 <Saizan_> sinelaw: ghc doesn't support that
07:36:55 <sinelaw> yuck!
07:36:55 <mm_freak> mlesniak: "converted"?
07:37:08 <pozic> mm_freak: They almost never make your code cleaner.
07:37:24 <pozic> mm_freak: part of this is that GHC has no automatic existentials.
07:37:35 <mlesniak> mm_freak, If I call my programm with +RTS -s you can see statistics about the sparks. converted = given to threads to calculate in paralle
07:37:43 <mm_freak> pozic: no?  i mean given the current possibilities in GHC
07:38:03 <Saizan_> mlesniak: are you running with +RTS -Nn ?
07:38:04 <mm_freak> it appears to be cleaner to me to use classes instead of spelling out each single function inside of the constructor
07:38:14 <sinelaw> Saizan_, any reason for not supporting that?
07:38:17 <sinelaw> or just missing features
07:38:18 <quicksilver> classes are for type-directed lookup
07:38:24 <mlesniak> Saizan, yes
07:38:30 <pozic> mm_freak: anyway, you can argue about this point, but abstract data types do the same thing as type-classes.
07:38:30 <mlesniak> and compiled with -threaded
07:38:31 <quicksilver> that suggests that you group your functionality into different types
07:38:37 <quicksilver> and you lookup the functions to use based on that type
07:38:44 <quicksilver> if you want a different approach, they feel clumsy
07:38:45 <Saizan_> sinelaw: i'm not familiar enough with the implementation to tell
07:38:48 <mm_freak> pozic: how would you do it?
07:38:56 <pozic> mm_freak: look e.g. at the heap package.
07:39:04 <sinelaw> ok
07:39:15 <pozic> mm_freak: there are complicated associated types, but there is no reason to do so.
07:40:01 <pozic> mm_freak: to me, that package screams "I wanted to try out associated types".
07:40:09 <Saizan_> @hackage heap
07:40:10 <lambdabot> http://hackage.haskell.org/package/heap
07:40:30 <pozic> The functionality of the package is great, though.
07:41:17 <RainCT> Hi
07:41:23 <mm_freak> pozic: i'll have a closer look later, thanks for the hint
07:42:20 <RainCT> What's the difference between Floating and RealFloat?
07:43:16 <mm_freak> RainCT: Floating doesn't make any assumptions on the underlying implementation
07:43:35 <mm_freak> it just defines all the real functions like sin, cos, sqrt, etc.
07:43:37 <Cale> RainCT: different set of methods
07:43:53 <mm_freak> RealFloat extends this to encode and decode numbers
07:44:10 <Cale> :t isNegativeZero
07:44:13 <lambdabot> forall a. (RealFloat a) => a -> Bool
07:44:19 <zygoloid> so 'Floating' is the typeclass for real-like things, and 'RealFloat' is the typeclass for floating-point representations? huh!
07:44:20 <Cale> :t isNaN
07:44:22 <lambdabot> forall a. (RealFloat a) => a -> Bool
07:44:49 <Cale> > decodeFloat (pi :: Double)
07:44:51 <mm_freak> zygoloid: in general, if you don't know which to use, use Floating =)
07:44:51 <lambdabot>   (7074237752028440,-51)
07:45:07 <zygoloid> mm_freak: just commenting that the names seem somewhat backwards :)
07:45:16 <RainCT> I see, thanks all :)
07:45:42 <mm_freak> RealFloat is really only useful, if you care about exponent, mantissa, special numbers (NaN, Infinity) and so on
07:45:54 <quicksilver> zygoloid: Floating is the class for transcendental fields, i.e. including Complex
07:45:55 <Cale> Though, oddly enough, atan2 is in RealFloat, because its (default) implementation involves isNegativeZero
07:46:04 <quicksilver> zygoloid: (not real)
07:46:10 <quicksilver> however I do agree the names are odd.
07:46:28 <mm_freak> well
07:46:36 <quicksilver> > sin (0 :+ 1)
07:46:38 <lambdabot>   0.0 :+ 1.1752011936438014
07:46:42 <Cale> class  (Num a, Ord a) => Real a  where
07:46:42 <Cale>     toRational       ::  a -> Rational
07:46:43 <mm_freak> Floating should be named Fractional IMO
07:46:54 <Cale> ^^ the real gem of Prelude misnomers
07:47:01 <mm_freak> Fractional should be renamed to Multiplicative or something like that
07:47:13 <mm_freak> and RealFloat should be renamed to Floating
07:47:16 <Cale> What?
07:47:16 <sinelaw> the trouble with haskell
07:47:27 <Cale> Fractional is a good name for what it is
07:47:31 <ray> cale: ouch!
07:47:32 <mm_freak> lol Cale
07:47:33 <sinelaw> ...is that it's close enough for you to see perfection, yet so far
07:47:36 <zygoloid> all transcendental fields? are the trigonometric functions meaningful for quarternions?
07:47:58 <zygoloid> forget that, you said 'fields' ;-)
07:48:12 <mm_freak> Cale: do you think so?  note that Fractional is fine, for example, for modular arithmetic numbers
07:48:26 <Cale> mm_freak: over primes, sure
07:48:36 <sinelaw> Cale, any tips on how to build lambdabot
07:48:50 <sinelaw> ?
07:48:52 <quicksilver> zygoloid: I did, however, wonder if transcendental field meant what I wanted it to mean :)
07:49:20 <quicksilver> zygoloid: what I wanted it to mean is "field which supports the standard transcendental functions exp, sin, cos, etc..."
07:49:30 <Cale> sinelaw: Haven't tested it at all with 6.12 yet?
07:49:35 <quicksilver> google would appear to suggest it doesn't mean anything.
07:49:38 <Cale> sinelaw: I don't know what else to recommend.
07:49:48 <zygoloid> quicksilver: seems like 'Floating' means something like 'subset of Complex' whereas 'RealFloat' means something like 'IEEE-754'
07:49:54 <mm_freak> Cale: "Fractional" suggests being a non-integral subset of the reals, don't you think?
07:49:55 <Cale> sinelaw: There are lots of dependencies, and the one that I'm running is not the same as what's on Hackage.
07:50:05 <quicksilver> zygoloid: definitely Floating is wrong.
07:50:08 <sinelaw> Cale, on which version is it known to compile, the one you have? and is it on darcs?
07:51:12 <Cale> sinelaw: hmm... I think it was http://code.haskell.org/lambdabot/
07:51:13 <zygoloid> quicksilver: i assumed you meant 'transcendental field extension of some base field' fwiw
07:51:24 <Cale> sinelaw: But I'm not sure when that was last updated.
07:51:33 <sinelaw> Cale, what about the version you're running?
07:51:42 <Cale> sinelaw: It's on lispy's server
07:51:54 <lispy> hey
07:51:54 <sinelaw> what/where is that
07:52:04 <sinelaw> yo lispy, where can i get a compilable lambdabot?
07:52:10 <lispy> sinelaw: oh!
07:52:10 <Cale> It's in my user account on lispy's server which is not accessible.
07:52:18 <sinelaw> ah. :( :( :( :(
07:52:27 <sinelaw> :_(
07:52:36 <Cale> Does the darcs version not compile?
07:52:40 <lispy> sinelaw: Yeah, so I don't maintain lambdabot but it is certainly broken these days.  Something in either a package, cabal, or ghc has changed
07:52:43 <sinelaw> not with my cabal setup
07:52:50 <sinelaw> 6.10.4
07:52:56 <Cale> You're building the hackage one?
07:53:00 <Cale> Talk to gwern about that
07:53:05 <sinelaw> I tried both that and the darcs one
07:53:07 <Cale> He's the one who uploaded it, not me.
07:53:18 <lispy> sinelaw: I did upload a new show package that gets the process a but further, but there are other breakages in the build (or so I've heard)
07:53:29 <Cale> (though strangely enough I'm listed as the maintainer... I just run the thing)
07:53:29 <sinelaw> yes there are
07:53:42 <sinelaw> Cale, yeah, better change that. that's why i bothered you.
07:53:54 <lispy> Cale: yeah, I've been contacting you about lambdabot because you're listed
07:53:58 <Cale> sinelaw: Well, I suppose it's not entirely inappropriate.
07:54:23 <sinelaw> not entirely inappropriate <= entirely appropriate
07:54:27 <Cale> I keep lambdabot running, but I don't really maintain the code.
07:54:40 <sinelaw> Cale, i just want to test my plugin
07:54:44 <shapr> taruti: Is there documentation or demo code for network-fancy?
07:55:27 <sinelaw> Cale, maybe you can complete it :) it's very simple.
07:55:56 <Cale> What does it do?
07:57:11 <sinelaw> it's for amusement. it keeps a backlog of X lines, and when you run @markov, it runs Data.MarkovChain.run and spits out some funny stuff.
07:57:21 <sinelaw> (runs it on the backlog)
07:57:23 <MissPiggy> @markov
07:57:23 <lambdabot> Unknown command, try @list
07:57:49 <sinelaw> MissPiggy, not implemented yet! (except a part of it in my emacs)
07:58:00 <Cale> What's preventing you from compiling lambdabot?
07:58:10 <sinelaw> Cale, it complains about a whole bunch of things
07:58:20 <Cale> hmm, okay
07:58:47 <Cale> You uploaded a new show package?
07:59:08 <sinelaw> not me, lispy
07:59:42 <jmcarthur> shapr: i like network-fancy, but it didn't build for ghc 6.12 last i tried :(
07:59:44 <Cale> lispy*
08:00:03 <lispy> Cale: yeah
08:00:29 <lispy> MissPiggy: I didn't forget about your request for the lambdabot on the web code, but I didn't find it yet either
08:00:37 <Cale> What did you change? I remember at one point I uploaded a new show package to fix the silly instance of Show that was there for IO.
08:00:39 <jmcarthur> shapr: ah, but i guess it's been updated! awesome
08:00:54 <sinelaw> Cale, http://codepad.org/Dy8Hamf5
08:01:01 <lispy> Cale: I only changed the .cabal file
08:01:05 <shapr> jmcarthur: Funny, it fails for me with ghc 6.10
08:01:13 <lispy> Cale: it needs to depend on syb when using base > 3
08:01:19 <Cale> ah, okay
08:01:20 <jmcarthur> shapr: ah, hmm, must have been a backward incompatible change
08:01:43 <jmcarthur> shapr: what about cabal install network-fancy-0.1.4 ?
08:01:57 * shapr tries
08:04:30 <shapr> jmcarthur: Looks like I already have network-fancy-0.1.4
08:04:45 <jmcarthur> yay!
08:04:52 <Vq> @greet-shapr
08:04:52 * hackagebot upload: GPipe 1.1.6 - A functional graphics API for programmable GPUs (TobiasBexelius)
08:04:53 <lambdabot> shapr!!
08:04:59 <shapr> Vq: hej!
08:05:02 <jmcarthur> oh boy more gpipe
08:05:15 <Vq> shapr: hiya
08:05:35 <Vq> shapr: i just found out Haskell is weak
08:05:44 <jmcarthur> weak?
08:05:45 <Vq> shapr: you can't implement this in Haskell: http://thedailywtf.com/Articles/Spaced-Out.aspx
08:06:08 <Vq> turns out you have to use assignment to properly return values
08:06:14 <Vq> :o)
08:07:02 <shapr> Vq: scary
08:07:25 <Vq> shapr: quite
08:16:30 <MissPiggy> is therea nything like terminal except renders LaTeX too?
08:17:12 <osfameron> how about a terminal which is also a realtime clock and calculator ?
08:18:00 <MissPiggy> very funny osfameron :P
08:18:31 <ksf> MissPiggy, is there a terminal that can display dvi, ps or pdf?
08:18:34 <pozic> It would be nice if Knuth would comment on TeXMacs sometime.
08:18:59 <osfameron> isn't therea latex2txt processor somewhere ?
08:19:06 <ksf> duh.
08:19:09 <ksf> of course there is.
08:19:10 <MissPiggy> I don't want latex2txt
08:19:16 <ksf> one is standing right next to me.
08:19:34 <ksf> it's an epson epl 7500, an old postscript printer.
08:19:42 <osfameron> MissPiggy: and you don't want evince / acrobat / etc. ?
08:19:43 <jmcarthur> there's also stuff like pdf2html, then you can use links or something i guess
08:20:22 <MissPiggy> I want something like a command line or REPL, but it should also be able to display LaTeX'd formuals
08:20:34 <jmcarthur> eek
08:20:42 <MissPiggy> if it could just display images then since I can turn LaTeX into image that would be good enough
08:20:49 <ksf> the common way to do it is to have a gv open on autoreload
08:21:04 <ksf> you can pipe your stuff into a file then
08:21:15 <jmcarthur> i bet there are fancy emacs setups to do that
08:21:20 <jmcarthur> inline, i mean
08:21:25 <Raevel> yes
08:21:29 <MissPiggy> Computer algebra systems: Axiom, Giac, Macaulay 2, Mathematica, Maxima, Mupad, PARI/GP, Reduce, Yacas
08:21:39 <MissPiggy> http://upload.wikimedia.org/wikipedia/commons/2/27/Yacas-texmacs-gnuplot.png
08:34:26 <luite> anyone know an algorithm to downsample bitonal (black/white) images to grayscale that renders sharper images than the usual bicubic or bilinear interpolation, without 'disconnecting' contiguous areas?
08:37:27 <aledge> luite, you might want to look into the bilateral filter, it could probably be adapted to do what you want
08:37:56 <aledge> luite, if you want to smooth out areas that have lots of white and black, but at edges you want it to be sharp still?
08:38:45 <luite> aledge: it's for rendering bitmap fonts, it should preserve the font features, like stems, keeping the edges sharp
08:38:50 <sshc> :t write
08:38:51 <lambdabot> forall (a :: * -> * -> *) w. (ArrowWriter w a) => a w ()
08:40:00 <luite> aledge: I'll have a look at bilateral filters
08:40:15 <aledge> luite, might not be the right thing then...but you can probably adapt the main idea
08:40:38 <aledge> luite, actually i misread your question. it's not really a downsampling filter/algorithm
08:40:46 <jmcarthur> luite: in addition to whatever algorithm you decide on, if this is meant for displaying on an LCD you could maybe do some subpixel antialiasing or something
08:41:08 <jmcarthur> depending on the graphics, maybe
08:41:19 <jmcarthur> some probably won't look so good with subpixel
08:41:28 <luite> jmcarthur: it's for eink, 4 bit grayscale, so subpixel rendering is not possible
08:41:33 <jmcarthur> ah i see
08:42:33 <luite> I ported a djvu viewer to my reader a few days ago (so it's not actually bitmap fonts, but bitonal compressed jb2 images) and want to improve the rendering a bit
08:43:13 <luite> hmm, not ported, I wrote a djvu plugin for the standard document viewer on this reader
08:45:52 <sm> a ghc panic when compiling with parsec.. http://gist.github.com/294846 . Known issue, any tips ?
08:47:23 <Ke> heh ghc is "almost equally good than" gcc
08:47:49 <luite> ah the paper about bilateral filtering has cute kittens!
08:48:23 * sm notes, only when building with cabal
08:49:02 <rajeshsr> >product [1..1000]
08:49:27 <rajeshsr> > product [1..10]
08:49:29 <lambdabot>   3628800
08:49:34 <rajeshsr> > product [1..10000]
08:49:36 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
08:49:41 <rajeshsr> > product [1..100000]
08:49:45 <lambdabot>   mueval-core: Time limit exceeded
08:51:28 <burp> > foldl' (*) 1 [1..100000]
08:51:32 <lambdabot>   mueval-core: Time limit exceeded
08:51:35 <burp> ok ;)
08:54:36 <rajeshsr> burp, just try to take mod at everytime say with 1e9+7?
08:57:07 <burp> what do you mean?
09:00:42 <augustss> @pl \ x y z -> f (g x y z)
09:00:43 <lambdabot> ((f .) .) . g
09:00:57 <MissPiggy> saint augustss
09:00:59 <MissPiggy> ;D
09:03:14 <rajeshsr> foldl' seems not there in my ghci. any module to import?
09:03:30 <burp> @hoogle foldl'
09:03:30 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
09:03:30 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
09:03:30 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
09:03:46 <aledge> :t foldl
09:03:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:03:49 <aledge> :t foldl'
09:03:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:04:00 <burp> foldl' is just strict
09:04:03 <aledge> o i see
09:04:09 <rajeshsr> wow, foldl' is indeed fast!
09:04:23 <burp> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
09:04:31 <aavogt> rajeshsr: if you compile with optimizations, you probably end up with foldl' where you write foldl
09:04:34 <rajeshsr> > foldl' (\x y->x*y `mod` 1000000007) 1 [1..1000000]
09:04:36 <lambdabot>   641102369
09:06:00 <rajeshsr> aavogt, hmm, am just experimenting with the interpreter! am yet to do anything serious with haskell, although the paradigm it needs seems quite interesting and unusual to my "imperative" thinking!
09:06:19 <rajeshsr> BTW, can that lambda be replaced by some currying?
09:06:27 <rajeshsr> am not able to figure out how!
09:06:45 <byorgey> @pl \x y -> x * y `mod` 1000000007
09:06:45 <lambdabot> (. (`mod` 1000000007)) . (*)
09:06:53 <Vanadium> Signs point to no
09:07:21 <aavogt> preflex: 8ball
09:07:22 <preflex>  what
09:07:26 <byorgey> a little ugly though.  I'd just write it using a lambda, like you did.
09:07:48 <rajeshsr> byorgey, hmm, yeah!
09:08:03 <aavogt> @type ((`mod` 10) .) . (*)
09:08:04 <lambdabot> forall a. (Integral a) => a -> a -> a
09:08:52 <aavogt> @scheck \x y ->  (((`mod` 4) .) . (*)) x y  == ((. (`mod` 4)) . (*)) x y
09:08:53 <lambdabot>   "Falsifiable, after 10 tests:\n-3\n-3\n"
09:08:56 <rajeshsr> what is the first composition operator used a s a prefix mean?
09:09:16 <rajeshsr> i mean in this: (. (`mod` 1000000007)) . (*)
09:09:23 <byorgey> rajeshsr: do you know about operator sections?
09:09:27 <byorgey> like (+2)
09:09:32 <rajeshsr> yep
09:09:33 <c_wraith> :t (. (+2))
09:09:34 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
09:09:55 <byorgey> rajeshsr: well, that's all it is.  although figuring out exactly why it works takes a little effort.
09:10:44 <rajeshsr> byorgey, hmm, ok! thanks! lemme try to see why this works!
09:11:49 <aavogt> @scheck \x y-> (x*y `mod` 10) == ((. (`mod` 1000000007)) . (*)) x y
09:11:50 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n-2\n"
09:12:17 <aavogt> @scheck \x y-> (x*y `mod` 10) == ((. (`mod` 10)) . (*)) x y
09:12:18 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n-1\n"
09:12:45 <aavogt> @pl \x y -> (x * y) `mod` 10
09:12:45 <lambdabot> flip flip 10 . (mod .) . (*)
09:13:00 <aavogt> @pl \x y -> x * (y `mod` 10)
09:13:00 <lambdabot> (. (`mod` 10)) . (*)
09:13:23 <aavogt> byorgey: looks like @pl doesn't know enough fixities
09:13:36 <rajeshsr> what does @pl mean?
09:13:42 <aavogt> pointless
09:14:00 <ski> @help pl
09:14:00 <lambdabot> pointless <expr>. Play with pointfree code.
09:14:29 <aavogt> since named arguments are called points for some reason
09:14:49 <aavogt> never mind that `.' is a point :)
09:15:42 <ski> ("point" as in "points in space" (geometry, topology))
09:16:13 <byorgey> aavogt: hmm, I guess it doesn't
09:16:29 <b0fh_ua> w/qui
09:16:58 <aavogt> everybody else knows that `mod` has the same fixity as * though
09:17:00 <rajeshsr> ski, something like parameterless?
09:17:10 <byorgey> I think the term "pointless" comes from category theory, which first arose in geometry/topology, hence "points"
09:17:33 <MissPiggy> it's because arrows point
09:17:45 <byorgey> rajeshsr: pointless things still have parameters, it's just that they don't *refer* to their parameters.
09:17:52 <rajeshsr> well, literally pointless means some thing else and i really did get confused when it was mentioned! :)
09:18:06 <byorgey> i.e. you describe a function in terms of the functional pieces it is built out of, rather than saying what it does to its arguments
09:18:21 <rajeshsr> hmm, yeah, I get that!
09:18:27 <rajeshsr> byorgey, thanks
09:18:29 <aavogt> well if you want to be more serious, you could call it pointfree
09:18:32 <ski> "pointless" is more or less a pun/joke on "pointfree"
09:23:06 <MissPiggy> why isn't there some generic algebra system inferface?
09:23:11 <MissPiggy> that you can plug any system into
09:24:55 <quicksilver> I assume the things that make them different are sufficiently different that the lowest common denominator is too restricting.
09:25:07 <quicksilver> But I assume that without having investigated it, like all the best IRC commentators.
09:25:20 <MissPiggy> haha
09:25:44 <kmc_> you mean universal algebra?
09:26:03 <kmc_> or are you speaking of software ;P
09:26:16 <MissPiggy> software
09:29:31 <augustss> rajeshsr: If you compute with Int, then rem is significantly faster than mod
09:30:04 <rajeshsr> > foldl' (\x y->x*y `rem` 1000000007) 1 [1..1000000]
09:30:07 <lambdabot>   641102369
09:30:09 <moshisushi> if someone familiar with the FGL (functional graph library) could have a look at this piece of code, i would be very happy: http://paste.lisp.org/display/94363
09:30:19 <rajeshsr> > foldl' (\x y->x*y `mod` 1000000007) 1 [1..1000000]
09:30:21 <lambdabot>   641102369
09:30:30 <moshisushi> my problem is that the customized bfs doesn't do what i expect it to
09:31:10 <moshisushi> the bfs is supposed to follow only outgoing edges with label 'e'
09:31:43 <rajeshsr> augustss, hmm, i don't see much difference! But i always wanted to know why we have both rem and mod.
09:31:47 <rajeshsr> ?
09:31:50 <b0fh_ua> Hi there! I have [Tag String], and this list may look like [TagOpen "entity", ...., TagOpen "assignee", TagText "some text here", TagClose "assignee", ... TagClose "entity", ... ]. Now I want to convert this list of tags into list of Entity {assignee :: String}. What is the best way to do so?
09:31:53 <taruti> shapr: http://github.com/taruti/network-fancy/blob/master/test.hs
09:31:56 <pozic> moshisushi: what is the size of your graphs?
09:32:06 <moshisushi> but the problem is that doing eClose graph1 1 gives me [2,5,6]
09:32:11 <kmc_> b0fh_ua: define a conversion for one element, and map it over your list
09:32:35 <augustss> rajeshsr: Both are useful.  Usually mod is the "right" one, but rem is what the hardware implements on almost all processors.
09:32:36 <kmc_> let f (TagOpen x) = ...; f (TagText x) = ... in map f mylist
09:32:44 <moshisushi> and if you look at how graph1 is specified, 6 shouldn't be reachable by a path from 1 following only 'e'-edges
09:33:13 <moshisushi> pozic: the size? i generate 6 nodes and 5 edges.. in graph1, that is
09:33:21 <rajeshsr> augustss, oh, ok! so there is mainly a performance difference and rem ought to perform better, right?
09:33:23 <b0fh_ua> kmc_: well, there could be another tags in between entity and assignee tags
09:33:23 <taruti> jmcarthur: network-fancy is now fixed for GHC 6.12
09:33:31 <kmc_> b0fh_ua: sorry, i don't know anything about these tags
09:33:42 <pozic> moshisushi: I mean for the actual application you are interested in.
09:33:44 <b0fh_ua> okay, it'a all about parsing XML using TagSoup
09:33:52 <augustss> rajeshsr: You will only see a performance difference if you use Int, not with Integer.
09:34:08 <taruti> jmcarthur: use 0.1.5 for GHC 6.12
09:34:09 <kmc_> why is your XML parser giving you a flat list of tags?
09:34:10 <moshisushi> pozic: probably a few hundred nodes, why?
09:34:23 <rajeshsr> augustss, hmm, ok
09:34:25 <augustss> > foldl' (\x y->x*y `rem` 1000000007) 1 [1..1000000] :: Int
09:34:27 <lambdabot>   641102369
09:34:30 <pozic> moshisushi: because FGL is relatively slow.
09:34:36 <b0fh_ua> kmc_: because it is very simple, and I didn't manage to use HXT yet :)
09:34:41 <moshisushi> pozic: ok it doesn't matter really
09:34:46 <gbacon> @botsnack
09:34:46 <moshisushi> just a lab assignment
09:34:46 <lambdabot> :)
09:34:47 <b0fh_ua> it's too complicated for me for now
09:34:48 <kmc_> but it's not an XML parser then
09:34:52 <kmc_> it's an XML lexer at best
09:34:59 <b0fh_ua> kmc_: probably yes
09:34:59 <jmcarthur> taruti: yes i noticed that after i mentioned it not building. thanks! :)
09:35:06 <taruti> np
09:35:06 <moshisushi> pozic: what other graph libs are there then?
09:35:08 <augustss> rajeshsr: Because Integer has some overhead that will mask the speedup.
09:35:13 <kmc_> err but tagsoup definitely has functions to parse into a tree shape
09:35:25 <pozic> moshisushi: the kind you roll yourself.
09:35:26 <b0fh_ua> kmc_: http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-HTML-TagSoup.html
09:35:35 <taruti> jmcarthur: feel free to bug with email if something is broken in the future.
09:35:40 <kmc_> http://hackage.haskell.org/packages/archive/tagsoup/0.8/doc/html/Text-HTML-TagSoup-Tree.html
09:35:41 <kmc_> :(
09:35:45 <kmc_> this package looks really half bake
09:36:23 <kmc_> i would say use a real parser
09:36:47 <kmc_> there are several that aren't HXT...
09:37:01 <jmcarthur> kmc_: yeah, the haskell tagsoup package is just a lexer by design
09:37:10 <jmcarthur> essentially
09:37:32 <moshisushi> pozic: well...
09:37:32 <pozic> Does the Python tagsoup do the same?
09:37:32 <augustss> I like HaXml
09:37:56 * edwardk waves hello.
09:37:57 <b0fh_ua> kmc_: may be you could suggest something really simple, which will allow me to iterate over all "entity" tags and then apply some function to them, which in turn will use soemthing like "give me the children of name "assignee" and return it's content"?
09:38:01 <jmcarthur> the idea is that you can't rely on the page's structure being the same, so you find what you are looking for basically by immediately surrounding structure, correct or not
09:38:11 <moshisushi> pozic: i'm pretty new to haskell.. there must be a graph lib better than i can possibly write right now
09:38:16 <jmcarthur> it's just for scraping, nothing else
09:38:17 <pozic> augustss: have you also used the xml package?
09:38:20 * malcolmw reminds people that a new stable release of HaXml came out recently
09:38:24 <edwardk> i seem to recall someone putting together a bunch of fancy :def macros and something for ghci that let you load data definitions, does anyone remember it?
09:38:25 <pozic> moshisushi: for 100s of nodes, FGL is fine.
09:38:38 <pozic> moshisushi: just don't use it for >1000
09:38:38 <moshisushi> pozic: good.. so what do you think about my actual problm?
09:38:51 <augustss> pozic: haxml is the only XML package I've used
09:39:08 <pozic> moshisushi: probably a PEBKAC problem. I implemented non-trivial algorithms on top of FGL before switching to my own versions.
09:39:19 <b0fh_ua> looks scary
09:39:26 <kmc_> b0fh_ua: i don't know anything about the xml libs
09:39:34 <jmcarthur> pozic: i'm not sure about the other "tagsoup"s out there
09:39:39 <moshisushi> pozic: PEBKAC?
09:39:48 <pozic> @google PEBKAC
09:39:49 <lambdabot> http://en.wikipedia.org/wiki/User_error
09:39:49 <lambdabot> Title: User error - Wikipedia, the free encyclopedia
09:39:55 <kmc_> Python's tagsoup is pretty fancy, it gives you an actual parse tree which you can also navigate by serialization order
09:40:16 <edwardk> "problem exists between keyboard and chair"
09:40:35 <pozic> If tagsoup doesn't do the same thing as the original Python version, then I think it's a misuse of the name.
09:40:55 <pozic> It strongly suggests that it is a package which does not suck.
09:41:11 <pozic> At least that's how Tagsoup is percieved, I believe.
09:41:14 <moshisushi> pozic: yeah well of course i'm doing something wrong!
09:41:24 <moshisushi> that's why i'm asking for help in the first place
09:43:01 <pozic> moshisushi: which expression gives an unexpected result?
09:43:12 <pozic> moshisushi: I loaded the code here.
09:43:15 <b0fh_ua>  Warning: Module `Text.HTML.TagSoup.Tree' is deprecated:
09:43:16 <b0fh_ua> nice
09:44:40 <pozic> moshisushi: never mind.
09:45:21 <moshisushi> pozic ok i think i understand what's wrong
09:45:49 <malcolmw> http://en.wikipedia.org/wiki/Tag_soup
09:47:06 <moshisushi> pozic: no ok, i really don't, nevermind :)
09:47:09 <malcolmw> pozic: the "original" tagsoup parser might be the Java one
09:47:59 <pozic> moshisushi: you simply do not understand the semantics of bfsWith
09:48:05 <MissPiggy> does anyone have an operator precidence AND function application parser?
09:48:17 <MissPiggy> so it should parse stuff like  3*f x+1
09:48:20 <pozic> moshisushi: you expect it to stop when the your predicate fails.
09:48:29 <pozic> moshisushi: -the
09:48:35 <MissPiggy> (as  (+ (* 3 (f x)) 1))
09:48:37 <kmc_> MissPiggy: Parsec can do that easily
09:48:39 <pozic> moshisushi: but this is not actually the case.
09:48:43 <augustss> MissPiggy: many
09:48:44 <ddarius> MissPiggy: I've written some before.  You can do it with a parsec operator parser and a mildly clever base case.
09:48:46 <MissPiggy> yeah but I just want the code
09:49:03 <kmc_> MissPiggy: http://haskell.org/ghc/docs/6.10-latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Expr.html
09:49:04 <MissPiggy> lol im so lame
09:49:06 <pozic> moshisushi: the answer you get is the correct one. bfsWith is a complete search procedure.
09:49:14 <MissPiggy> yeah kmc that doesn't do what I want
09:49:19 <moshisushi> pozic: yeah i expect it to find the subgraph of nodes reachable from a given node by following nodes labelled 'e'
09:49:22 <kmc_> really?
09:49:32 <pozic> moshisushi: right, and that is not what you wrote.
09:49:32 <MissPiggy> I want function applications too
09:49:42 <MissPiggy> ill just write it
09:49:42 <kmc_> MissPiggy: sure, you have to wrap your own expr parser with that
09:49:48 <MissPiggy> for the one thousanth time
09:49:54 <moshisushi> pozic: ok what is the purpose of the function to be passed to bfsWidth then?
09:50:12 <kmc_> MissPiggy: Expr isn't supposed to do everything; it adds operators to an existing parser
09:50:32 <MissPiggy> yeah I just wanted the code ;(
09:50:46 <pozic> moshisushi: from its type you can deduce that it is simply a kind of map.
09:50:55 <pozic> moshisushi: only in bfs order.
09:51:27 <pozic> moshisushi: anyway, it is open-source code, so you can look at the code yourself too.
09:51:40 <moshisushi> pozic: suc' give me all "successor" nodes
09:52:06 <moshisushi> and if i pass it, it will simply progress by following edges to those nodes
09:53:02 <pozic> moshisushi: and?
09:54:14 <mreh> HOF are amazing
09:54:28 <kmc_> no
09:54:36 <rmui86> I want to learn haskell as my first attempt at programming
09:54:37 <lpjhjdh> is there a more rich interface to arrays with more interesting indices than the integers?
09:54:40 <augustss> mreh: yes
09:54:57 <mreh> ha
09:55:04 <augustss> lpjhjdh: you can index with anything in the Ix class
09:55:19 <lpjhjdh> is there a more interesting interface than IArray though?
09:55:34 <kmc_> interesting how?
09:55:46 <lpjhjdh> being able to do easily do things like projections
09:55:47 <augustss> lpjhjdh: depends on what you want to use them for
09:55:55 <mreh> I'm programming a GA, so what If I want to make a generic interface for tuning the parameters over time? Pass a function that tunes the parameters over time
09:56:13 <lpjhjdh> going back and forth between association lists and arrays is painful.  Granted I may just be being stupid
09:57:53 <mreh> kmc_ I don't know yet, but it'll probably use less mutation and crossover towards the end once the fitness landscape has been explored
09:57:59 <mreh> atleast that's the theory
09:58:04 <paradroid> is there a lib function like amap that takes both a value and its coordinates?
09:58:13 <mreh> oh.. you were talking to someone else
09:58:35 <ddarius> paradroid: zipWith
09:58:42 <paradroid> thanks
09:58:45 <ddarius> If I understand what you are trying to say correctly.
09:58:45 <rmui86> Should you learn the basics of linux before doing Haskell?
09:59:16 <augustss> rmui86: only if you want to learn about linux
09:59:16 <ddarius> rmui86: No
09:59:17 <mreh> *how* embarrassing
10:00:33 <glguy> :-( hpaste is down?
10:00:50 <ehamberg> mreh: isn't using sigma scaling in the selection function usually enough?
10:00:55 <kmc_> rmui86: they are not very related concepts.  but i think Linux is generally a nicer environment for doing software development of any kind, compared to Windows or OS X
10:00:56 <paradroid> ddarius: i am looking for something that will operate on Arrays, is there such?
10:01:26 <ddarius> paradroid: There are tons of array libraries so it depends on what one you use.  For the standard arrays, there's ixmap.
10:01:28 <ddarius> :t ixmap
10:01:28 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
10:01:34 <ddarius> Er, not that one.
10:01:51 <rmui86> That's a good point as somebody else already suggested. So now i have Fedora. Should i have background knowledge on programming before haskell?
10:02:12 <kmc_> rmui86: many people learn other languages first, but it seems to do more harm than good
10:02:14 <paradroid> ixmap appears to operate on indices only? i am looking for the blend of amap and ixmap
10:02:17 <kmc_> Haskell is very different from most languages
10:02:31 <kmc_> If you're smart and willing to put in the effort, it's a fine first language
10:02:39 <rmui86> different in a more advanced way or...?
10:02:40 <ddarius> rmui86: Did you ask if you should have background knowledge in mechanical engineering and iron casting before learning to drive a car?
10:03:01 <tromp> a fine first language, but a better last language
10:03:02 <kmc_> rmui86: more advanced, and fewer compromises
10:03:03 <rmui86> Heh
10:03:08 <benmachine> rmui86: keep in mind you're asking #haskell that question :P so we all think it's more advanced
10:03:13 <ddarius> rmui86: If you are interested in learning Haskell, the most direct route is to learn Haskell.
10:03:17 <Gracenotes> I would hate to see a language with no compromises
10:03:32 <benmachine> I think that's a sweeping statement
10:03:47 <benmachine> compromises cover inadequacies, I would love to see a language with no inadequacies
10:03:56 <benmachine> but one can argue whether such a thing is possible
10:04:05 <sm> Igloo: fyi, cabal installing latest template-haskell I get Language/Haskell/TH/Quote.hs:31:12:   Not in scope: data constructor `CharConstr' ?
10:04:27 <benmachine> sm: the latest template haskell only works with GHC 6.12 if I recall
10:04:30 <kmc_> rmui86: in other languages they tend to muddle together unrelated concepts in order to make things "simpler"
10:04:36 <sm> aha
10:04:37 <benmachine> they didn't update the build dependencies properly
10:04:48 <benmachine> in general, you're not supposed to upgrade template-haskell
10:04:54 <benmachine> you get a new version with a new compiler
10:04:57 <kmc_> in Haskell you have to be more precise.  the benefit is that you have more confidence in your understanding of what your code does, *and* more of that understanding can be checked by the machine
10:05:41 <rmui86> I heard that learning haskell will benefit you in some way when you want to learn other programming languages
10:05:48 <kmc_> yes, that's a common claim
10:05:52 <jmcarthur> eh, sort of
10:06:08 <kmc_> however, it will make other languages seem tedious in comparison
10:06:20 <jmcarthur> it doesn't benefit you in learning other languages, necessarily, but it can benefit you in programming generally
10:06:25 <kmc_> if you want to pursue a professional software development career in Java or C++, learning Haskell is probably bad for your job satisfaction
10:06:34 <benmachine> I found C harder to write after learning haskell because I could more easily see its inadequacies :P
10:06:34 <dons> heh
10:06:35 * jmcarthur can attest to that
10:06:37 <roconnor> is a coproduct a pushout?
10:06:38 <arw> and you will tend to rely too much on the typechecker and memory management of haskell...
10:06:53 <dons> and the concurrency mechanisms
10:06:57 <jmcarthur> i find C easier to understand and harder to enjoy
10:07:06 <kmc_> i enjoy C a lot
10:07:07 <jmcarthur> after learning haskell, that is
10:07:24 <kmc_> C is a small language with a consistent design philosophy
10:07:35 <Gracenotes> I dunno. C seems pure, simple, possibly beautiful by comparison.
10:07:35 <kmc_> much like Haskell
10:07:39 <jmcarthur> i just find C to be a bad, lossy abstraction over assembly
10:08:06 <arw> C is still enjoyable, its just different. the same as i enjoy steaks and chocolate icecream...
10:08:11 <jmcarthur> heh
10:08:12 <MissPiggy> comparison to what?
10:08:22 <kmc_> hmm, how about chocolate icecream on steak
10:08:23 <benmachine> it's nice that C doesn't have much that it doesn't need, doesn't have much inconsistency
10:08:26 <kmc_> that could be good...
10:08:27 <kmc_> dark chocolate
10:08:40 <benmachine> but I still find myself repeating myself in ways I feel like I shouldn't have to
10:08:45 <MissPiggy> I've heard C been called a 'clusterfuck' by a man I have a lot of respect for
10:08:51 <kmc_> jmcarthur: yeah, there are a few things from assembly that one really ends up missing.  tail calls for example
10:09:03 <Gracenotes> MissPiggy: Haskell is operationally complicated and abstracted over. I sort of like a simple layer over von neumann architecture.
10:09:12 <jmcarthur> C is still more concise than assembly, but at a cost
10:09:12 <kmc_> benmachine: yeah.  a powerful low level language like C should be paired with powerful high-level metaprogramming
10:09:22 <Gracenotes> not like I could program in C all the time
10:09:49 <jmcarthur> Gracenotes: haskell is not for people who like operational semantics, arguably
10:09:50 <MissPiggy> All declarative languages are operationally complicated
10:10:07 <monochrom> Whoever calls C a clusterfuck has not seen the whole-species-fuck of C++ :)
10:10:07 <kmc_> the graph reduction operational semantics of Haskell are not complicated
10:10:12 <MissPiggy> it's sort an impasse ?
10:10:22 <kmc_> and they're pretty important for understanding performance of real world GHC code
10:10:23 <edwardk> jmcarthur: yeah, damnit, i want access to that carry bit I just made. silly addition ;)
10:10:25 <jmcarthur> MissPiggy: while i'm *inclined* to agree, that's a strong claim
10:10:34 <Gracenotes> devil in the details
10:10:40 <Twey> benmachine: C has lots of inconsistency
10:10:44 <MissPiggy> I make very strong claims, but they have subtle operational consequences :)
10:10:55 <Twey> You just got used to it already
10:10:58 <jmcarthur> edwardk: that's exactly the kind of thing that i'm pissed off about with C
10:11:13 <kmc_> are qualified names in named field puns supposed to work?
10:11:18 <jmcarthur> why should i use a clumsy language if i don't get access to that kind of thing?
10:11:19 <benmachine> Twey: all right, but compare to C++ or perl
10:11:22 <kmc_> the GHC manual (6.10.4) says so, but i'm getting errors
10:11:24 <jmcarthur> kind of defeats the purpose
10:11:26 <Gracenotes> inconsistencies can be features, depends on where they are
10:11:42 <Twey> benmachine: Well, yeah
10:12:06 <MissPiggy> I wonder what would happen if we used our very articulate and detailed knowledge of programming languages to develop a new C-ish thing (I mean something based on assembly)
10:12:15 <Twey> MissPiggy: BitC
10:12:21 <jmcarthur> MissPiggy: bitc, cyclone, etc.
10:12:22 <Twey> Possibly with monads
10:12:28 <kmc_> go
10:12:33 <kmc_> gonads
10:12:34 <edwardk> jmcarthur: they have to jump through all sorts of hoops to occasionally derive benefit from that carry bit, but they never really work. its a minor nit, bit it always bugged me =)
10:12:37 <jmcarthur> unfortunately, bitc and cyclone are both dead
10:12:55 <jmcarthur> edwardk: well, that's only one example, of course
10:13:02 <kmc_> @where paste
10:13:02 <lambdabot> http://hpaste.org/new
10:13:06 <kmc_> borken :/
10:13:12 <monochrom> MissPiggy: The result is very few people will use it :)
10:13:36 <edwardk> jmcarthur: sure, similar issues pop up with shifting, rolling, etc. simple ops that are hard to infer from context once they come down through c.
10:13:36 <jmcarthur> MissPiggy: i would love it if we could make a decent language for, say, kernel development
10:14:12 <edwardk> jmcarthur: sadly the only real effort in that direction is ATL, and my god the syntax.
10:14:21 <jmcarthur> edwardk: :(
10:14:47 <edwardk> it clearly has the 'written by an non-native-speaker ml geek' feel to it.
10:14:48 <DigitalKiwi> codepad.org > hpaste
10:15:00 <monochrom> A month of learning a new language can be saved by a year of attacking that language on reddit.
10:15:20 <kmc_> haha monochrom
10:15:25 <edwardk> monochrom: =)
10:15:38 <edwardk> monochrom: I only do that with Scala... and maybe Factor.
10:16:04 <kmc_> http://codepad.org/b8ECjows anyone know if this sort of qualified pun is actually supported?
10:16:31 <kmc_> i realized that Parsec.Token would be a lot more usable with record puns, but this has thrown a wrench into my plan :/
10:16:37 <paradroid> anyone suggest a function similar to amap but which also provides the array indices to the update function?
10:18:36 <edwardk> kmc_:  just unqualify the member accessor. adding the TDNR pragma if needed
10:19:14 * jmcarthur wonders how useful a haskell edsl for generating low level assembly would look like and whether it could be made useful enough to write something like a kernel more conveniently than with C or something
10:19:40 <kmc_> there's a LLVM edsl
10:19:51 <temoto> jmcarthur, like amplified-c?
10:19:53 <edwardk> jmcarthur: i have a fragment of one lying around somewhere that i put down when harpy came along. i hated harpy, but it was usable.
10:20:19 <jmcarthur> kmc_: that's not low level enough for a kernel, though :(
10:20:22 <arw> something like an sse(2/3) library exists in some other functional languages
10:20:29 <jmcarthur> temoto: i'm not familiar with that
10:20:32 <arw> one could improve on that idea
10:20:34 <edwardk> jmcarthur: the main trick for me was being very anal retentive about the types so i could catch things like operand combinations that don't work together at compile time
10:20:34 <kmc_> jmcarthur: no?
10:20:43 <kmc_> edwardk: which pargma is that?
10:21:02 <MissPiggy> monochrom: "few people will use it" -- oh I'm not worried about that, it was just a thought ex. anyway
10:21:18 <edwardk> kmc_: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
10:21:22 --- mode: ChanServ set +o glguy
10:21:39 <MissPiggy> uh oh glguys gonna kick me out
10:21:43 <edwardk> er the option you probably want is -XDisambiguateRecordFields
10:22:03 <sm> benmachine: that makes sense about template-haskell. cabal is trying to install the new one for data-accessor-template (for Chart)
10:22:05 <jmcarthur> edwardk: i've wondered before whether an indexed monad with the state of the CPU's registers and maybe a few other things would be nice
10:22:14 <DigitalKiwi> glguy: !
10:22:18 <jmcarthur> abstract state, of course
10:22:35 <glguy> jmcarthur, that's how the network driver for house works
10:22:36 <sm> it picked the second of the dependency groups at http://hackage.haskell.org/package/data-accessor-template-0.2.1.3
10:22:37 <MissPiggy> TypeDirectedNameResolution? he's not heard of type classes
10:22:47 <kmc_> edwardk: thanks!
10:22:47 <jmcarthur> glguy: ooh, i'll have to check that out
10:22:50 <edwardk> jmcarthur: an EDSL version of TAL would be nice =)
10:22:53 <temoto> jmcarthur, http://voodoo-slide.blogspot.com/2010/01/amplifying-c.html   it's basically, metaprogram in Lisp syntax which generates a C code, which is compiled by usual C compiler.
10:23:39 <jmcarthur> temoto: ah, thanks. i'm going for something much lower level than C, but maybe i could steal some ideas from this if i ever try this venture
10:24:06 <jmcarthur> edwardk: indeed it would
10:24:17 <ido> kmc_: lost your nick, eh?
10:24:57 <kmc_> signed in from work
10:25:03 <copumpkin> pff work
10:25:04 <edwardk> i didn't really like the amplifying c approach. at least from the article. he oversimplified the number of things that RAII solves.
10:25:13 <MissPiggy> impasse was completely the wrong word
10:25:22 <kmc_> my home laptop's connection must have dropped because of your shitty wireless access point ;P
10:25:34 <copumpkin> whose?
10:25:37 <kmc_> ido's
10:25:44 <copumpkin> who do?
10:26:03 <edwardk> that said, i do like the philosophy of 'work in whatever language you have to, but generate it from (scheme|haskell|whatever)'
10:26:15 <temoto> jmcarthur, it have that awesome idea that it builds a persistent database of types and signatures out of sources, and then it uses that database to infer types of expressions.
10:26:33 <temoto> jmcarthur, i reckon it would be great to shorten Linux SLOC in 100 times :) if you try that venture, i'm all to help.
10:27:07 <MissPiggy> temoto
10:27:12 <MissPiggy> I think that I give up on web :(
10:27:14 <jmcarthur> temoto: sweet! it's something that's been off and on my mind for several years now. just never got around to actually doing much research in that direction or anything
10:27:20 <MissPiggy> it was nice to learn about jQuery though,
10:27:30 <temoto> jmcarthur, you know of House?
10:27:38 <temoto> MissPiggy, need more help?
10:27:39 <edwardk> temoto: i think it would help with some of the common resource acquisition patterns, but the information density in the linux kernel is fairly high.
10:27:50 * MissPiggy wasn't really planning on learning anything.. just wanted the program written
10:28:13 <jmcarthur> temoto: yes, but my understanding is that it's just the ghc runtime ported to native machine
10:28:15 <MissPiggy> temoto, well I think that now I should use TeXmacs instead, because it has a maxima mode -- I hope I can just edit that to fit my CAS instead of maxima
10:28:25 <temoto> edwardk, and it would help avoid much of human mistakes!
10:28:49 <copumpkin> temoto: it's lupus!
10:29:26 <temoto> jmcarthur, AFAIK they run it on bare hardware, not under OS. Which means, it is an OS.
10:29:28 <MissPiggy> temoto, I give up on web because there was some terrible complications with the Hint and all that
10:29:38 * hackagebot upload: progression 0.1 - Automates the recording and graphing of criterion benchmarks (NeilBrown)
10:29:40 <jmcarthur> edwardk: my intent is to make low level programming a bit more convenient than assembly and a bit more powerful than C
10:29:56 <jmcarthur> temoto: yeah, but it's not really the kind of thing i'm going for
10:30:01 <Twey> â€¦ like, FORTH?
10:30:11 <jmcarthur> Twey: heh
10:30:39 <MissPiggy> jmcarthur you are working on this
10:30:51 <edwardk> MissPiggy: what are you trying to do with texmacs?
10:30:52 <jmcarthur> i want to actually expose the native hardware "in the raw," so to speak, but with some sort of nice type system to keep me safe and cozy
10:31:02 <jmcarthur> MissPiggy: no, i'm just thinking about it
10:31:03 <edwardk> jmcarthur: a BitC that doesn't suck?
10:31:15 <rmui86> Can you program xbox360 games with haskell?
10:31:16 <jmcarthur> edwardk: something not much like C, really
10:31:17 <MissPiggy> edwardk, I just want a LaTeX interfacte to my CAS, so i think texmacs should work (it's the best option I know about so far)
10:31:44 <MissPiggy> i.e. when you type x^2 it should echo it in a nicely typeset way
10:31:45 <temoto> MissPiggy, okay, i tried to learn haskell and monads for more than year now :) so if you try again some time later, i'd be glad to help.
10:31:53 <edwardk> jmcarthur: i was just referring to shapiro's now dead project, not c itself ;)
10:32:10 <temoto> jmcarthur, like C-- with types?
10:32:14 <Twey> jmcarthur: So, typed FORTH :Ã¾
10:32:16 <jmcarthur> edwardk: yes. i am more familiar with cyclone than bitc, though, so i can't say much about it
10:32:19 <kmc_> temoto: how did you spend a year learning monads?
10:32:42 <temoto> kmc_, i didn't learn it every day. More like occasional tries and failures.
10:32:53 <jmcarthur> Twey: does forth actually provide access to things like register allocation, carry bits, SIMD, and the GDT?
10:32:56 <kmc_> i'm trying to understand why this one typeclass gives everyone so much trouble
10:32:59 <edwardk> MissPiggy: i went down the web route for that myself once. spent about a year and a half building it as a mozilla extension using mathml/xul/etc.. then finally gave up because I was working on a mac at the time and they never fixed !@*(#* mathml support on the macs
10:33:02 <sinelaw> edwardk, BitC sucked?
10:33:03 <kmc_> we never hear "i tried to spend a year learning Ord"
10:33:07 <Twey> jmcarthur: I believe so, yes
10:33:27 <Twey> jmcarthur: It makes it easy to write words in assembly
10:33:35 <Twey> So if it doesn't, you could wrap them easily
10:33:42 <jmcarthur> Twey: on anything other than a forth machine?
10:33:49 <edwardk> sinelaw: in my opinion. doesn't help that it'll never get finished
10:34:02 <temoto> kmc_, maybe because it's more abstract or maybe because my lack of math and category education.
10:34:06 <Twey> Er, on everything, if I understand your question
10:34:17 <sinelaw> edwardk, that's sad and true.
10:34:26 <sinelaw> too bad Micro$oft bought him out.
10:34:41 <kmc_> temoto: are you comfortable with typeclasses and higher-order functions?
10:34:41 <sinelaw> i hope at least something good comes out of that
10:34:41 <edwardk> MissPiggy: i went the texmacs route after that, but around then my interest in the project dried up. texmacs is a fairly constraining environment.
10:34:47 <Twey> temoto: Did you forget to go through Pointed -> Functor -> Applicative first?
10:34:50 <temoto> kmc_, they are awesome!
10:34:57 <kmc_> that's good
10:35:00 <temoto> Twey, yes.
10:35:10 <edwardk> MissPiggy: i do think it'd be fun to put together a texmacs ghci interface though. you'd probably need a LaTeXShow class of some sort though
10:35:23 <kmc_> (>>=) is a higher order function that lives in a typeclass
10:35:40 <MissPiggy> edwardk, yeah that's step 1.. I started to do it with HTML instead but it was not working out
10:35:47 <temoto> Twey, i had not knew about functors before i understood monads some weeks ago.
10:36:04 <jmcarthur> i'm thinking the kind of low level where you can specify exactly which opcode out of the full set of opcodes available on the architecture to apply to which registers, etc.
10:36:20 <jmcarthur> but of course since it's an EDSL you could abstract over that, too
10:36:21 <edwardk> MissPiggy: html didn't meet my rendering needs. hard to get beyond superscripts and subscripts with html
10:36:35 <Twey> jmcarthur: â€¦ like FORTH :Ã¾
10:36:38 <jmcarthur> i guess it's kind of a compiler EDSL
10:37:03 <edwardk> jmcarthur: the problem is occasionally you just want to let a register allocator deal with that nonsense, and sometimes you really need a specific register.
10:37:10 <jmcarthur> Twey: your assertions are not lining up with my (admittedly limited) understanding of forth
10:37:15 <Twey> Hence the abstraction
10:37:18 <temoto> kmc_, a friend of mine today said an interesting thing. Having 'a monad is a typeclass of return and bind' doesn't allow you to recognize and synthesize monads in problem domain (as opposed to recognition and synthesis in code).
10:37:30 <kmc_> that's true
10:37:32 <jmcarthur> edwardk: right. this would be an example of where i would like to improve over languages like C
10:37:43 <kmc_> but i think that knowledge is not gained by meditating on whether monads are more like burritos or space suits
10:37:46 <kmc_> it's gained by using them
10:37:53 <Twey> jmcarthur: Well, okay: a combination of FORTH and assembly.  All you need to be able to do to fulfil that goal is conveniently drop into assembly.
10:37:55 <medfly> lol
10:37:58 <temoto> kmc_, probably!
10:38:48 <edwardk> temoto: well, then, clearly a monad is just the result of composing adjoint functors! that will help you spot it. or maybe you can look for burritos ;) sadly, monads seem to be best learned by analogy to other monads.
10:38:49 <jmcarthur> Twey: but we can "conveniently" drop into assembly with many languages, including C. i'm not looking to drop into it. i'm looking to just be at that level already, just with the ability to also abstract it away
10:38:56 <kmc_> the philosophical question "but what ARE monads, really?" is hard to answer concisely
10:39:05 <lament> temoto: compare with integers. Integers are a ring with addition and multiplication, but that's not how we teach them. We make people learn their properties through tons of use.
10:39:08 <kmc_> but the questions "how do i use IO" or "how do i use Parsec" are
10:39:15 <temoto> kmc_, sometimes i see blurred patterns where i could apply applicative functor. Not that i would see an application for monads, though.
10:39:28 <kmc_> can be answered concisely, i mean
10:39:28 <lament> er, integers are not a ring.
10:39:43 <Twey> jmcarthur: That's true.  Okay then.
10:39:47 <lament> er, they are
10:39:49 <Twey> jmcarthur: I approve of your project.  ;)
10:39:56 <kmc_> i think it's rare to encounter a problem that has an Applicative that's not a Monad
10:39:56 * lament will never use math terminology ever again
10:40:03 <jmcarthur> Twey: yay!
10:40:06 <kmc_> but maybe i have not looked enough
10:40:19 <jmcarthur> my theoretical project
10:40:54 <edwardk> temoto: the usual answer for me of whether something is probably a monad or probably just applicative is whether or not i can use any of the 'values' in the monad to determine which computations to do in the future. monads are just 'context sensitive' applicatives.
10:41:09 <MissPiggy> lamet, unforgivable mistake!
10:41:20 <sinelaw> yo Cale , I wanna fix lambdabot r u k 2 help? zomg. lol
10:41:27 <temoto> kmc_, what i mean is when i see those patterns, i can describe what i want in terms of pure and <*>. Or even just fmap. Like 'that's enough'.
10:41:35 <kmc_> yeah
10:41:59 <edwardk> temoto: i.e. if I have an 'm Bool' for some m, can I look at the boolean value and do one of two different 'm a' actions based on it? If so, its more than just Applicative.
10:42:26 <Twey> How so?
10:42:32 <edwardk> temoto: if applicative is enough, then stop there =)
10:43:08 <edwardk> you often don't need the extra machinery of a monad
10:43:08 <Twey> (foo ?? bar) <$> yourMBool
10:43:10 <Twey> No?
10:43:20 <temoto> edwardk, sorry, but despite concise explanation i didn't get it.
10:44:01 <temoto>  "you often don't need the extra machinery of a monad"  this i get :)
10:44:03 <edwardk> Twey: you'll wind up with m (m a)
10:44:05 <kmc_> in Applicative you can't use the bool to choose which "side effects" to do
10:44:08 <edwardk> Twey: now, join ;)
10:44:17 <sm> I have some code sections enabled by optional CPP flags.. how do I enable those under ghci ?
10:44:19 <kmc_> you can do both and then throw out the result of one
10:44:32 <edwardk> Twey: the magic of the monad is the ability to collapse m (m a) -> m a
10:44:53 <sm> ah, -DFLAG.. thought I tried that
10:45:04 <Twey> edwardk: Ah, right
10:45:06 <Twey> Yeah, of course
10:46:06 <jmcarthur> that's actually the way i like to teach monad to somebody who know applicative, by deriving bind from fmap and join
10:46:13 <jmcarthur> *who knows
10:46:18 <Twey> Yeah
10:46:22 <MissPiggy> why
10:46:32 <Twey> Because it's simpler
10:46:33 <MissPiggy> hmmmm
10:46:34 <edwardk> jmcarthur: yeah
10:46:40 <MissPiggy> well there was this guy in here
10:46:44 <Twey> Relates more clearly to Functor
10:46:48 <MissPiggy> and he had fmap and couldn't write bind
10:46:58 <MissPiggy> and I was trying to explain, look.. if you write JOIN then BIND is for free
10:47:14 <Twey> On the other hand, the way we use monads in Haskell, I think they're more about (>>=), so I guess it makes sense for that to be the monad method
10:47:25 <MissPiggy> but he couldn't seem to understand because every time I asked him to define join he just gave more (broken) stabs at bind
10:47:32 <edwardk> a lot of the time i define the join operation, then just inline it to figure out my bind. =)
10:47:45 <Twey> edwardk: However, you are abnormal.  :Ã¾
10:47:48 <MissPiggy> so maybe it is wrong to say:  Whatever way you learn monad, you can learn that {fmap, join, return} is enough
10:47:54 <edwardk> twey: perhaps
10:48:08 <MissPiggy> since this guy was either just sort of stressed and loopy from so much failure, or he was a counterexample
10:48:13 <jmcarthur> edwardk: you're not abnormal. i do that a lot, too
10:48:18 <Twey> MissPiggy: Well, everyone's different
10:48:31 <MissPiggy> what's the difference?
10:48:43 <Twey> Between people?
10:48:55 <edwardk> MissPiggy: people seem to first grok monads when they get around to their third or fourth monad tutorial. so whatever explanation they see there is the one that they think applies to everyone ;)
10:49:06 <temoto> @type join
10:49:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:49:12 <sm> also, what command-line option will cause ghci to give me *Main> not Main> ?
10:49:23 <edwardk> @type (>>= id)
10:49:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
10:49:49 <MissPiggy> sort of like reading the bible 7 times, Finally! I see why everything is a monad!!
10:49:58 <temoto> sm, what is the difference between Main with star and not?
10:50:00 <kmc_> hahaha
10:50:01 <medfly> IT HAS A B INSTEAD OF A
10:50:08 <edwardk> @type \f -> join . fmap f
10:50:09 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
10:50:11 <kmc_> with star, Main is interpreted, and you have access to its guts, the stuff it doesn't export
10:50:22 <edwardk> er..
10:50:23 <sm> temoto: one shows all internal symbols... (WAVE HANDS)
10:50:40 <medfly> why is everything a monad?
10:50:51 <jmcarthur> nothing is a monad
10:51:01 <jmcarthur> monad is an abstraction we apply to things
10:51:02 <temoto> sm, -dcore-lint?
10:51:20 <sinelaw> @quote monad
10:51:20 <lambdabot> tensorpudding says: the Plot monad allow you to keep the story pure by containing all the glaring time travel silliness
10:51:23 <sinelaw> @quote monad
10:51:23 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
10:51:28 <sinelaw> @quote monad
10:51:28 <lambdabot> tensorpudding says: they need to do way instain monads who confuse haskell noobies
10:51:40 <sinelaw> there you go.
10:51:41 <aledge> hhahahahaha
10:51:53 <jmcarthur> @quote monad
10:51:53 <lambdabot> <BMeph> says: psygnisfive: In #haskell, you can't hardly be taken seriously w/o writing a monad tutorial...
10:51:58 <jmcarthur> @quote monad
10:51:58 <lambdabot> vixey says:  <ImInYourMonad> I'm a spelling-bee.  <vixey> more like spelling-eff
10:52:10 <medfly> this is all so weird. I am thinking of "monads are endofunctors together with two natural transformations" and trying to see how that works with anything you guys are saying. not everything is a functor, is it?
10:52:15 <sinelaw> preflex, seen vixey
10:52:15 <preflex>  vixey was last seen on ##javascript 129 days, 19 hours, 11 minutes and 31 seconds ago, saying: that bit "new Ext.ux.Rating" kinda makes a difference
10:52:26 <sinelaw> what happened to her?
10:52:32 <kmc_> medfly: every haskell Monad is an endofunctor in the category Hask
10:52:42 <kmc_> its Functor instance should illustrate this
10:52:42 <MissPiggy> sinelaw hey that's me
10:52:43 <edwardk> medfly: because monads just show us common refactorings that we could apply uniformly to code by hand, the hard way. you could plumb an extra argument through, wind an argument into and out of each function to get state, convert to continuation passing style, backtrack to model multiple solutions, etc.
10:52:56 <MissPiggy> sinelaw as for what happened.. long story
10:52:57 <sinelaw> MissPiggy, heh oh
10:53:00 <medfly> what
10:53:03 <temoto> preflex, seen elly
10:53:03 <preflex>  elly was last seen on #haskell 5 days, 11 hours, 58 minutes and 50 seconds ago, saying: * elly -> sleep
10:53:05 <sinelaw> welcome back
10:53:07 <kmc_> but the connection from Haskell code to category theory is pretty indirect
10:53:12 <MissPiggy> thank you
10:53:14 <sinelaw> MissPiggy, I thought you were new here
10:53:16 <kmc_> or abstract or whatever
10:53:23 <sinelaw> MissPiggy, everything alright?
10:53:35 <jmcarthur> MissPiggy: wait, MissPiggy = vixey = soupdragon = fax?
10:53:58 <medfly> edwardk, I only know the CT definition and I think I sort of get it.
10:54:24 <temoto> Do you know a sound example when type classes beat OOP by an order of magnitude for clean, short code?
10:54:29 <sinelaw> medfly, i know nothing about this, but there's a paper that started it all
10:54:39 <edwardk> MissPiggy: i never put together the fact that you were the same person =)
10:54:48 <sinelaw> i don't think anyone did!
10:54:56 <temoto> (and i don't mean that typeclass_vs_OOP wiki page, it doesn't have a large practical example)
10:54:58 <MissPiggy> my apologies!
10:55:23 <sinelaw> though we should have guessed...another amazingly smart female (sorry it is rare here, the female part)
10:55:31 <jmcarthur> i don't remember ever seeing vixey in #idevgames...
10:55:49 <edwardk> I would join the randomly changing nick crowd, but its too much of a pain in the butt now that i have to ident to talk ;)
10:55:52 <MissPiggy> jmcarthur well you know how much of a drama queen I am
10:56:46 <nominolo_> @pl \(Foo x) -> blah y x >>= \x' -> blub (Foo x')
10:56:46 <lambdabot> (line 1, column 7):
10:56:46 <lambdabot> unexpected "x"
10:56:46 <lambdabot> expecting operator or ")"
10:56:57 <nominolo_> @pl \(Foo x) -> blah y x >>= (\x' -> blub (Foo x'))
10:56:57 <lambdabot> (line 1, column 7):
10:56:57 <lambdabot> unexpected "x"
10:56:57 <lambdabot> expecting operator or ")"
10:57:07 <roconnor> heh, I'm getting pretty good at telling who MissPiggy is.
10:57:45 <nominolo_> @ho fmapM
10:57:46 <lambdabot> Maybe you meant: hoogle hoogle+ do
10:57:51 <nominolo_> @hoogle fmapM
10:57:51 <lambdabot> No results found
10:58:03 <dolio> roconnor: It's pretty easy if you're in the right channels.
10:58:25 <MissPiggy> I had to leave Coq because they didn't like me changing nick all the time
10:58:26 <temoto> @pl \(Foo x) -> blah y x >>= (\x' -> blub (Foo x' ))
10:58:26 <lambdabot> (line 1, column 7):
10:58:27 <lambdabot> unexpected "x"
10:58:27 <lambdabot> expecting operator or ")"
10:58:41 <medfly> gotta change your nick so no one remembers you're a drama queen
10:58:43 <roconnor> dolio: normally I double check #constructive-math, but apparently that doesn't always work.
10:58:43 <medfly> I should do that too
10:58:52 <sinelaw> medfly, check out the paper "The essence of functional programming"
10:58:56 <sinelaw> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
10:59:03 <sinelaw> or any other paper there. i haven't read any of them
10:59:08 <sinelaw> but i should.
10:59:26 <medfly> thanks
10:59:31 <MissPiggy> nothing to do with monads but wadler has some video of talks he gave online
10:59:31 <jmcarthur> vixey was the only nick that i knew to be female. the others i always saw as masculine, even MissPiggy since i knew of the other names besides vixey
10:59:56 <lament> misspiggy sounds p. masculine
11:00:04 <medfly> p.?
11:00:09 <lament> pretty
11:00:24 <jmcarthur> miss?
11:00:53 <lament> jmcarthur: so?
11:01:10 <roconnor> I wish I understood adjoint functors better
11:01:33 <monochrom> adjoint functor has a pretty lengthy definition.
11:01:49 <nominolo_> @hoogle (a -> m a) -> (f a -> m (f a))
11:01:49 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:01:49 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
11:01:49 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:02:03 <jmcarthur> the only monad i can decompose into a pair of adjoint functors is State, and that's because it's the only one i know of where both adjoints are in Hask
11:02:08 <sinelaw> the first time i came into this channel, i asked if it's "viruses" or "viri", and didn't get screamed at/kicked/banned
11:02:30 <sm> temoto: no
11:02:37 <roconnor> jmcarthur: you can always decompose a monad into two adjoint functors to/from the Kleisli Category
11:02:39 <monochrom> /mode #haskell +b sinelaw!*@* :)
11:02:44 <dolio> T |-> (T -> R) -> R is pretty easy.
11:03:01 <dolio> It decomposes into the self-adjoint functor (= -> R).
11:03:33 * sinelaw starts on a quest to make hackage's lambdabot build succesfully
11:03:42 <nominolo_> @djinn Functor f => (a -> m a) -> (f a -> m (f a))
11:03:42 <lambdabot> -- f cannot be realized.
11:03:51 <nominolo_> @djinn (Monad m, Functor f) => (a -> m a) -> (f a -> m (f a))
11:03:51 <lambdabot> -- f cannot be realized.
11:04:06 <jmcarthur> djinn doesn't know monad. not sure about functor
11:04:10 <MissPiggy> f (m a) -> m (f a) ?
11:04:13 <MissPiggy> and back
11:04:22 <jmcarthur> sequence?
11:04:43 <jmcarthur> :t Data.Foldable.sequence
11:04:44 <lambdabot> Not in scope: `Data.Foldable.sequence'
11:04:45 <Asztal> :t Data.Traversable.traverse
11:04:45 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:04:53 <jmcarthur> :t Data.Foldable.sequenceA
11:04:54 <lambdabot> Not in scope: `Data.Foldable.sequenceA'
11:04:58 <jmcarthur> err\
11:05:15 <cads> @hoogle (a1 â†’ b1) â†’ (a2 â†’ b2) â†’ ((a1, a2) â†’ (b1, b2))
11:05:15 <lambdabot> Parse error:
11:05:15 <lambdabot>   --count=20 "(a1 â†’ b1) â†’ (a2 â†’ b2) â†’ ((a1, a2) â†’ (b1, b2))"
11:05:15 <lambdabot>                   ^
11:05:46 <cads> @hoogle (a1 -> b1) -> (a2 -> b2) -> ((a1, a2) -> (b1, b2))
11:05:47 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:06:06 <medfly> >< FRUSTRATED FUNCTION IS FRUSTRATED
11:06:21 <cads> haha
11:06:37 <kmc_> the eric cartman operator
11:07:49 <roconnor> adjoint functors and galois connections are the same thing?
11:08:24 <monochrom> galois connection is special case, appears when you use partial order elements as objects.
11:09:21 <cads> can I ask lambdabot for the source of the >< operator in the Data.Graph.Inductive.Query.Monad module?
11:09:33 <monochrom> Because many things collapse when you take a partial order as a category, Galois connection definition is substantially shorter.
11:09:34 <jmcarthur> no
11:09:50 <jmcarthur> :t (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:09:51 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
11:10:00 <jmcarthur> @src (***)
11:10:00 <lambdabot> cads: You can try.
11:10:00 <lambdabot> f *** g = first f >>> second g
11:10:16 <lambdabot> cads: But I don't think I know the answer.
11:10:35 <dolio> Some definitions of adjunction aren't that big, unless you count all the prerequisite knowledge.
11:10:48 <cads> thanks jmcarthur
11:11:08 <jmcarthur> @src (->) (***)
11:11:08 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
11:11:13 <jmcarthur> cads: ^^
11:11:15 <benmachine> Cale: re: progress on stepwise evaluator: none significant, thinking a restructuring might be necessary to make progress and have a busy week ahead, so might not get done for a while, however git://github.com/benmachine/stepeval.git if you are interested
11:11:21 <dolio> F -| U means Hom(FA,B) ~= Hom(A,UB), natural in A and B.
11:12:40 <cads> jmcarthur, woah. Mind telling me a little about how @src (->) turned the function definition into a point based representation?
11:12:44 <temoto> dolio, pun fun?
11:13:01 <roconnor> dolio: plz explain it using a haiku
11:13:07 <roconnor> @quote haiku
11:13:07 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
11:13:14 <dolio> Nah.
11:13:26 <roconnor> @quote Kleisli
11:13:26 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
11:13:29 <sm> what does it mean when ghc-pkg shows a package in { } ?
11:14:08 <sm> aha. Means it's broken.
11:14:29 <DekuNut> I've been reading a lot on haskell, the theory behind it, bits of language, which is great but I haven't really written anything in it
11:14:42 <DekuNut> Going to write a naughts and crosses game, small and simple, but quick question
11:14:56 <djahandarie> DekuNut, read Real World Haskell, it walks you through some stuff you can actually do
11:15:10 <DekuNut> I was thinking of storing the board in a ((a,a,a),(a,a,a),(a,a,a)), but that seems horrible, even though it's closest to what I imagine
11:15:25 <DekuNut> djahandarie, oh, alright, more reading D:
11:15:39 <sm> it thinks Chart is broken, because (ghc-pkg check) dependencies {gtk,cairo}-0.10.1 don't exist. Yet I have installed gtk2hs from macports, and cabal happily installed Chart
11:15:45 <tromp> most efficient is storing it in 2 bitmaps, white and black
11:15:46 <djahandarie> DekuNut, or just do what you are doing. What is more interesting to you.
11:16:00 <DekuNut> Well, mainly I just wanted  adecent recommendation of how to store the board
11:16:06 <DekuNut> I'll definitely read the book though
11:16:14 <sm> I truly long for a new Platform release with working gui libs
11:16:39 <tromp> DeKuNut, you can see what i did for my connect 4 code in haskell
11:16:46 <tromp> also using bitmaps
11:17:07 <DekuNut> Sure, would be nice
11:17:09 <roconnor> DekuNut: data Triple a = Triple a a a;  data Board a = Triple (Triple a)
11:17:11 <dons> sm: coming soon
11:17:25 <roconnor> DekuNut: Triple is a functor (and even a monad).
11:17:30 <sm> yay, thanks dons
11:17:54 <djahandarie> DekuNut, you could use a monad as a container. ;)
11:17:54 <tromp> see http://www.cwi.nl/~tromp/c4/fhour.html
11:17:59 <DekuNut> roconnor, on the subject, can you give me an example of a data declaration that is NOT a functor?
11:18:00 <roconnor> DekuNut: probably most relevently it is an applicative functor
11:18:23 <roconnor> DekuNut: data NotAFunctor a = NotAFunctor (a -> Bool)
11:18:28 <roconnor> though that is a cofunctor
11:18:47 <DekuNut> Mind explaining why it isn't a functor? Sorry if I'm being a bit demanding
11:18:58 <kmc_> DekuNut: tuples are mostly for small localized data pipes
11:18:58 <roconnor> er
11:19:15 <kmc_> if you have big nested tuples you should probably declare a new type instead
11:19:21 <kmc_> in fact i rarely use tuples bigger than 2
11:19:36 <kmc_> the std lib has a lot of stuff for working with pairs, so they're useful intermediate values.  not so much for bigger tuples
11:19:58 <roconnor> @djinn (a -> b) -> (a -> Bool) -> (b -> Bool)
11:19:58 <lambdabot> f _ _ _ = False
11:20:02 <DekuNut> Yeah, it looked ugly when I typed (()()()) up before, I wasn't planning on writing a ton of functions taking that as an argument ;p
11:20:05 <DekuNut> :o
11:20:21 <roconnor> @djinn (a -> b) -> (a -> c) -> (b -> c)
11:20:21 <lambdabot> -- f cannot be realized.
11:20:46 <DekuNut> I don't understand
11:20:47 <roconnor> DekuNut: I'm not really sure I can prove it isn't a functor off the top of my head.
11:20:50 <mauke> data NotAFunctor = No
11:21:12 <roconnor> mauke: DekuNut has an unstated requirement that it take one parameter.
11:21:14 <sm> here's something really strange: $ ghci, import Graphics.Rendering.Chart fails (could not find module). The same command done via an otherwise-empty makefile works fine
11:21:15 <DekuNut> I'll re-read the page on category theory, it'll make more sense I think
11:21:23 <MissPiggy> @djinn (b -> a) -> (a -> Bool) -> (b -> Bool)
11:21:23 <lambdabot> f a b c = b (a c)
11:21:50 <mauke> data NotAFunctor a = a ()
11:22:01 <DekuNut> A functor is something that takes an object in one category, to an object in another right?
11:22:02 <roconnor> DekuNut: but the short idea is that it isn't a functor because the a variable occurs as to the left of an arrow
11:22:03 <edwardk> DekuNut: you can transform it with a function from b -> a, but not a function from a -> b
11:22:16 <DekuNut> THe category in this case being Hask, types being objects, so one type to another
11:22:20 <roconnor> mauke: a parameter of type *
11:22:26 <mauke> :-(
11:22:27 <edwardk> DekuNut: in the mathematical sense it is a 'contravariant' functor, not a 'Functor' in the Hask sense which is only a covariant functor.
11:22:30 <sm> and indeed, once imported Chart is working fine; ghc-pkg is just confused
11:22:50 <edwardk> DekuNut: on the other hand. consider. newtype Endo a = Endo (a -> a)
11:23:00 <edwardk> DekuNut: that is neither a contravariant or a covariant functor on Hask.
11:23:11 <edwardk> DekuNut: even though Endo has kind * -> *
11:23:35 <DekuNut> I don't know what either of those functors are, my math is awful
11:24:19 <edwardk> DekuNut: contravariant just means that it changes the directions of the arrows.
11:24:46 <DekuNut> In other words, from one type to another in either direction right?
11:25:39 <edwardk> DekuNut: hazardous phrasing there. lets back up to the definition of a category and of a functor
11:25:45 <DekuNut> Ok
11:26:10 <edwardk> a category has objects, and arrows between them. the only thing you are given by it being a category is that arrow composition is associative and that every object is associated with an identity arrow.
11:26:30 <kmc_> MissPiggy: did you solve your parsing problem?
11:26:32 * roconnor thinks contravarient / covarient are Computer Science terms.
11:26:35 <Paczesiowa> @seen ivanm
11:26:36 <lambdabot> Unknown command, try @list
11:26:40 * roconnor also thinks those names are very confusing.
11:26:41 <MissPiggy> kmc_, no
11:26:43 <Paczesiowa> ,seen ivanm
11:27:10 <edwardk> so (f . g) . h = f . (g . h) and f . id = id . f = f -- for appropriate definitions of id and (.) for your category. (category theorists would write a bunch of subscripts to indicate the object in question for each of those id's but i'm not bothering.
11:27:10 <Paczesiowa> preflex seen ivanm
11:27:11 <preflex>  ivanm was last seen on #haskell 9 hours, 7 minutes and 24 seconds ago, saying: heh
11:27:55 * MissPiggy is a bag of internet potatoes
11:27:59 <edwardk> functors map arrows and objects in one category onto arrows and objects in another category in a way that all of the 'connections' between those arrows and objects are preserved.
11:28:14 <DekuNut> HOld on hold on
11:28:16 <kmc_> > foldl1 f [a,b,c]
11:28:17 <lambdabot>   Ambiguous occurrence `f'
11:28:17 <lambdabot>  It could refer to either `L.f', defined at <local...
11:28:21 <kmc_> > foldl1 f [a,b,c] :: [Expr]
11:28:22 <lambdabot>   Ambiguous occurrence `f'
11:28:22 <lambdabot>  It could refer to either `L.f', defined at <local...
11:28:27 <DekuNut> These are arrows you're refering too right, f g and h I mean?
11:28:29 <edwardk> it may lose some information on the way, by mapping multiple arrows onto the same arrow, it may flip the direction of the arrows
11:28:29 <dolio> I'm pretty sure Awodey uses covariant and contravariant in his category theory book. Maybe it was adopted from computer science, though.
11:28:34 <edwardk> DekuNut: yeah
11:28:43 <DekuNut> Good, just making sure I understand everything right
11:28:56 <mauke> @undefine
11:29:15 <edwardk> DekuNut: this
11:29:39 <edwardk> this preservation of the relationships between arrows and objects as they get mapped through the functor is really all a functor is good for. ;)
11:30:21 <MissPiggy> kmc_ why do you ask
11:30:22 <MissPiggy> ?
11:30:31 <DekuNut> So, you're saying, arrow direction is not preserved in arrow composition, but functors somehow preserve it?
11:30:32 <edwardk> now, you can have functors between pretty much any two categories, at least as long as the target has at least one object, because you could always map object onto that one object, and every arrow into its identity.
11:30:32 <kmc_> MissPiggy: because i'm working on it and getting stuck
11:30:35 <kmc_> Parsec can be so frustrating
11:30:41 <MissPiggy> why parsec?
11:30:54 <kmc_> because it's the typical way to write parsers in Haskell?
11:31:07 <edwardk> arrow direction is preserved in arrow composition, but a mathematical functor might choose to flip the direction of all of the arrows. we call those contravariant functors
11:31:12 <MissPiggy> well I might have a go with readp
11:31:22 <DekuNut> Ahhhh, I see
11:31:41 <MissPiggy> kmc_, what syntax do you want to parse
11:31:42 <MissPiggy> ?
11:31:51 <DekuNut> I get the idea behind it now, but can't for the life of me imagine a data type that would be an exampel of it
11:31:59 <edwardk> consider the very simple category '2' which has two objects, 1 and 2. and an arrow from 1 -> 2. (and identity arrows 1 -> 1, and 2 -> 2)
11:32:09 <MissPiggy> prefix and postfix operators?
11:32:14 <DekuNut> Ok
11:32:23 <kmc_> infix operators + application by juxtaposition
11:32:47 <edwardk> you can have several functors that maps '2' onto the obvious '3' category which is constructed similarly.
11:33:30 <DekuNut> i.e, 2(1) -> 3(1)   <- this being a functor
11:33:40 <edwardk> it could map 1 to 2, 2 to 3,  or it could map 1 to 1, and 2 to 3, or...
11:34:34 <DekuNut> Well, can you correct me here then, as I think I've been thinking about this wrong, the way I've thought of haskell is this
11:34:35 <edwardk> in the latter case it would have to map the arrow 1 -> 2 onto the arrow 1 -> 3 in the target category, which is obtained from composing the arrows from 1 -> 2, and 2 -> 3.
11:34:47 <MissPiggy> kmc_ left and right associativity? and no associativity?
11:34:52 <kmc_> perhaps
11:35:00 <edwardk> endofunctors are functors that map some category back onto itself.
11:35:00 <DekuNut> Types are objects, Int, Bool, Char all being objects of Hask, therefore this: data Mayba a = Just Int | Nothing
11:35:07 <MissPiggy> maybe no associativity is redundant
11:35:13 <DekuNut> Is taking an object in Hask, to ANOTHWER object in Hask, making it an endofunctor
11:35:17 <Vitka> @pl f a b = sqrt (f2 a b)
11:35:17 <lambdabot> f = (sqrt .) . f2
11:35:24 <DekuNut> Am I wrong there?
11:35:27 <MissPiggy> what do you think?
11:35:43 <edwardk> you've got the right intuition, so lets look at the type of Functor's fmap operation.
11:35:48 <DekuNut> Ok
11:36:01 <edwardk> fmap defines the functor, by basically ignoring the action of the functor on objects and only considering what it does with arrows.
11:36:17 <edwardk> fmap :: Functor f => (a -> b) -> (f a -> f b)
11:36:44 <edwardk> takes an arrow in Hask and generates another arrow in Hask. but note that that is a fairly crippled notion of a functor.
11:36:47 <edwardk> you could have
11:37:07 <edwardk> contrafmap :: ContraFunctor f => (a -> b) -> (f b -> f a)
11:37:43 <edwardk> or it could be something even more generic to remove the 'newtype noise' used by 'f's, and the fact that there are other categories than Hask to consider.
11:37:56 <DekuNut> Wait so, fmap itself, the function that is, is a functor?
11:37:59 <edwardk> Control.Category builds a generic category that has 'id' and (.) and need not be Hask.
11:38:16 <MissPiggy> kmc what do you think of: data Syntax operator = Variable Name | Syntax :$: Syntax | Infix operator Syntax Syntax
11:38:32 <edwardk> fmap defines the action of your functor on the arrows of your category. in this case functions in Hask.
11:38:39 <kmc_> seems fine
11:38:48 <edwardk> you could define a more complicated functor.
11:39:18 <DekuNut> Oh, hmm, in otherwords, in the case of Maybe for example
11:39:22 <edwardk> class (Category r, Category s) => CFunctor f r s | f r -> s, f s -> r where cmap :: r a b -> s (f a) (f b)
11:39:28 <MissPiggy> kmc_ do you have a pretty printer for it? ^..^
11:39:32 <kmc_> no
11:39:37 <MissPiggy> I will write one
11:39:43 <DekuNut> fmap describes how Maybe (the functor) will be applies to the the arrows (functions), in other words the first function you pass?
11:39:48 <DekuNut> applied*
11:40:59 <edwardk> yeah. fmap :: (a -> b) -> Maybe a -> Maybe b -- defines how your functor takes any function in Hask, and generates another function in Hask in such a way that fmap f . fmap g = fmap (f . g) holds and fmap id = id
11:41:29 <edwardk> the former is the 'preserves relationships' condition i mentioned
11:42:16 <DekuNut> Got it, from one category to another
11:42:18 <edwardk> and it is implied by the latter and the free theorem for fmap
11:42:49 <DekuNut> Well, the contravariant functor you mentioned earlier than
11:43:02 <DekuNut> Can you define one? The cloest I can picture is like, data Contra a b = Contra b a
11:43:06 <sm> I'm having trouble understanding +RTS -xc - docs say "output contains one line for each exception raised in the program (the program might raise and catch several exceptions during its execution), where each line is of the form: < ... >". I get one line with multiple < ... >'s (http://gist.github.com/295021). Are each of these due to an exception ? How come there are five of them ?
11:43:08 <DekuNut> And that's no where near right in my head
11:43:15 <DekuNut> Pulled it out my ass
11:43:23 <edwardk> you can make a class ContraFunctor f where contrafmap :: (a -> b) -> f b -> f a
11:43:28 <edwardk> then lets define an interesting one
11:43:36 <edwardk> actually that one is covariant ;)
11:43:52 <edwardk> data Test a = Test (a -> Bool)
11:44:13 <DekuNut> Wait wait, isn't Maybe then technically a contravariant functor? as in
11:44:38 <edwardk> instance ContraFunctor Test where fmap f (Test g) = Test (g . f)
11:44:40 <DekuNut> instance ContraFunctor Maybe where ; contrafmap :: (a->b) -> f b -> f a
11:44:58 <edwardk> try to define ContraFunctor for Maybe. ;)
11:45:06 <DekuNut> I just did :(
11:45:14 <DekuNut> Oh
11:45:16 <DekuNut> You mean the class
11:45:19 <DekuNut> Er hodl on
11:45:27 <edwardk> yeah you can't instantiate it.
11:45:36 <edwardk> the only way you could do it is to map everything to Nothing
11:45:41 <edwardk> and that violates fmap id = id
11:45:56 <DekuNut> I'm a little lost
11:46:00 <DekuNut> Hold on
11:46:01 <DekuNut> :t id
11:46:01 <lambdabot> forall a. a -> a
11:46:02 <roconnor> edwardk: cfmap?
11:46:42 <edwardk> roconnor: i went with the more verbose name to avoid having people confuse 'contra' with 'co'. since Cofunctor = Functor ;)
11:47:19 <edwardk> DekuNut: think of it this way. if You have a function from Int -> Bool, and you have a Maybe Bool, can you derive a Maybe Int?
11:47:28 <edwardk> DekuNut: if not, then Maybe isn't a contravariant functor.
11:47:42 <DekuNut> What exactly do you mean by derive?
11:47:46 <kmc_> @djinn (a -> b) -> Maybe a -> Maybe b
11:47:47 <lambdabot> f a b =
11:47:47 <lambdabot>     case b of
11:47:47 <lambdabot>     Nothing -> Nothing
11:47:47 <lambdabot>     Just c -> Just (a c)
11:47:51 <kmc_> @djinn (a -> b) -> Maybe b -> Maybe a
11:47:51 <lambdabot> f _ _ = Nothing
11:48:10 <kmc_> djinn tries to use both arguments if possible?
11:48:14 <kmc_> s/both/all?
11:48:21 <edwardk> kmc_: it sometimes get lucky and does so
11:48:53 <Apocalisp> \f x y -> (liftM2 f x y) `mplus` x `mplus` y
11:49:15 <Apocalisp> Feels like there should be a terser way of saying that
11:49:22 <kmc_> @pl \f x y -> (liftM2 f x y) `mplus` x `mplus` y
11:49:22 <lambdabot> flip flip id . (liftM2 mplus .) . join . ((flip . (mplus .)) .) . liftM2
11:49:28 <edwardk> DekuNut: i just mean, just given x :: Maybe Bool, f :: Int -> Bool. can you define g :: Maybe Int
11:49:29 <Apocalisp> oh, of course!
11:49:37 <edwardk> DekuNut: see the problem?
11:49:40 <kmc_> msum [liftM2 f x y, x, y]
11:49:50 <edwardk> er y :: Maybe Int might be a better use of names
11:50:07 <DekuNut> I don't know where g comes from, or what it has to do with x and y
11:50:08 <edwardk> DekuNut: Maybe is covariant, not contravariant
11:50:12 <DekuNut> bare with me though
11:50:19 <edwardk> DekuNut: sure.
11:50:20 <DekuNut> I'm pasting something, that you can smash to bits which might make sense to me
11:50:25 <Apocalisp> kmc_: Thanks much
11:52:44 <DekuNut> Oh
11:52:47 <DekuNut> edwardk, I think I see
11:52:51 <DekuNut> I was pasting this: http://haskell.pastebin.com/m5b68c02c
11:53:11 <DekuNut> Then I realised, my instance of Maybe, the a on both sides breaks everything
11:53:13 <edwardk> yeah, the types go the wrong way
11:53:18 <DekuNut> So Maybe cant work
11:53:38 <DekuNut> Alright, let me scroll up to your instance example, and try and fit it :o
11:53:54 <edwardk> newtype Test a = Test (a -> Bool)
11:54:13 <edwardk> so now given a Test Bool, and a function from Int -> Bool, you can derive a Test Int
11:55:04 <DekuNut> AH
11:55:06 <DekuNut> I see it!
11:55:11 <edwardk> now, lets go one further.
11:55:14 <DekuNut> Wait wait
11:55:18 <edwardk> ok =)
11:55:20 <DekuNut> Just to make sure, otherwise you're going to go on and I'll
11:55:25 <DekuNut> Just get a worse misunderstanding
11:55:38 <DekuNut> fmap f (Test g) = Test (g . f)
11:55:41 <edwardk> yep
11:55:43 <DekuNut> g is applied, resulting in b
11:55:45 <edwardk> er cofmap
11:55:46 <DekuNut> Then applied to f
11:55:48 <DekuNut> Which is a
11:55:53 <DekuNut> Or results in a even
11:55:54 <edwardk> er contra or whatever i called it
11:55:55 <edwardk> but yeah
11:56:07 <DekuNut> Right, I see now
11:56:26 <DekuNut> Thank you, really appreciate this, what's this one further :o
11:56:34 <edwardk> so we've established that there are categorical endofunctors over Hask that don't fit the Functor class.
11:56:39 <edwardk> now I want to talk about two more cases.
11:57:09 <edwardk> There are types of kind * -> * that cannot be made into either a ContraFunctor or a Functor.
11:57:23 <edwardk> consider: newtype Endo a = Endo (a -> a)
11:57:49 <edwardk> I can't fmap it, because I need to do something with the result and I can't contrafmap it because I need to do something with the argument!
11:59:53 <edwardk> I could get away with making a category out of isomorphisms over Hask. data Iso a b = Iso (a -> b) (b -> a) -- and defining a 'categorical functor' from Iso to Hask for Endo, but I wanted to point out that there are some hard ones ;)
12:00:35 <edwardk> i wrote up something on that a couple of years back, lemme dig it up. i called those 'exponential functors' at the time.
12:00:54 <edwardk> http://comonad.com/reader/2008/rotten-bananas/
12:01:18 <DekuNut> Opening the link now
12:01:20 <DekuNut> Just taking in what you said
12:01:26 <edwardk> and i modeled the isomorphism with two functions
12:01:28 <edwardk> class ExpFunctor f where     xmap :: (a -> b) -> (b -> a) -> f a -> f b
12:02:02 <DekuNut> Before I read the link, the way I understood it
12:02:14 <DekuNut> ALL functors in haskell were endofunctors, because they all mapped back to the Hask category
12:02:26 <DekuNut> Wheras, the way I took in both
12:02:30 <edwardk> that link is a fairly deep digression into HOAS encodings, etc. so you may not want to read all of it right now =)
12:02:58 <DekuNut> newtype Endo a = Endo (a->a) and Test a -> Test (a->Bool)
12:03:06 <DekuNut> Looked as if Bool, and a were in different categories
12:03:17 <DekuNut> Is it fair, for now to assume that
12:03:31 <edwardk> all 'Functor' instances in Haskell are a particularly limited form of endofunctor for Hask =)
12:03:34 <DekuNut> Maybe itself can be a category, like. Maybe a, with Maybe INt, Maybe Bool as objects
12:03:44 <MissPiggy> is hpaste gone
12:03:49 <MissPiggy> kmc_ are you still here
12:03:49 <MissPiggy> ?
12:03:53 <kmc_> yeah
12:04:01 <MissPiggy> i want to hpase tomeshing
12:04:12 <DekuNut> edwardk, ok, will read your link now
12:04:24 <edwardk> DekuNut: you could perhaps view 'Maybe' as a subcategory of Hask, but its arguably not the most productive way to think about it.
12:04:28 <MissPiggy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6577 -- okay
12:04:36 <MissPiggy> there is a generic syntax & printer
12:04:42 <kmc_> cool
12:04:46 <MissPiggy> it should be possible to write a parser now
12:04:48 <DekuNut> edwardk, arguably rofl, ok I won't think about it for now, reading your link :o
12:04:50 <ksf> is there a way to check how much data is available on an fd?
12:04:57 <DekuNut> I appreciate your time, been really helpful
12:04:58 <MissPiggy> oops
12:05:02 <ksf> the os, after all, should know a bit about that
12:05:05 <MissPiggy> I didn't finish writing it :(
12:05:05 <edwardk> DekuNut: happy to help
12:05:33 <MissPiggy> that's embarassing
12:05:36 <edwardk> the more people who understand the application of category theory to Haskell types the less time i have to spend teaching it. i benefit from the ripple effect ;)
12:06:01 <Vitka> @hoogle lookup
12:06:01 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
12:06:01 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
12:06:01 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
12:06:05 <DekuNut> Good point rofl, unless I've misunderstood everything, and start telling people false info
12:06:48 <edwardk> DekuNut: I have a library of fairly pedantic category theoretic stuff implemented in Haskell, which is a nice place to look around to see how more CT ideas apply. http://hackage.haskell.org/package/category-extras-0.53.5
12:07:02 <edwardk> I warn you it is fairly monolithic though.
12:07:16 <DekuNut> Bookmarked, I will go through it when I understand everything a little better
12:07:24 <DekuNut> Will definitely look though, thanks!
12:07:50 <jmcarthur> and has seriously deep layers of abstractions
12:07:57 <edwardk> jmcarthur: =( yeah
12:08:14 <edwardk> jmcarthur: i'm fully planning on ripping the bifunctor combinators out into a separate library
12:08:36 <edwardk> jmcarthur: the presentation of cofree comonads and free monads is just too painful in there.
12:08:48 <edwardk> i only actually needed the full abstraction they provide once ;)
12:08:52 <jmcarthur> yeah... and i like free/cofree, too
12:09:14 <c_wraith> is someone in jail cofree?
12:09:18 * byorgey also likes free coffee
12:09:28 <jmcarthur> mm coffee
12:10:25 <MissPiggy> kmc_ I finished it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6577#a6578
12:10:31 <edwardk> I've had one person come up with a situation that needed bicata, which justified  *cough* the treatment of Cofree as a fixed point of a bifunctor ;)
12:10:37 <MissPiggy> the example prints: (1+g (f x) y+g 1 3)*(f (f 1)+(f x+g y 3))*(x+f y+3*x)
12:11:40 <MissPiggy> I wonder if (1 + g (f x) y + g 1 3) * (f (f 1) + (f x + g y 3)) * (x + f y + 3 * x) is nicer?
12:13:06 <MissPiggy> so anyway
12:13:14 <MissPiggy> now onto the real work
12:13:15 <roconnor> MissPiggy: the latter is nicer
12:13:25 <MissPiggy> oh okay, I'll do that then
12:14:00 <roconnor> some sort of style guide, coq or ocaml said the latter was better and gave some reasons that I forget
12:14:40 <kmc_> application binds tighter, it's bad if it looks looser due to whitespace
12:14:48 <edwardk> kmc_ yeah
12:15:01 <MissPiggy> kmc_ by that you agree that the spaces are better?
12:15:04 <kmc_> yes
12:15:46 * MissPiggy annotates it again <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6577>
12:16:05 <roconnor> x+g looks like a token, and may be parsed that way in some languages.
12:16:28 <kmc_> in Agda the space is mandatory, as it's the only way to find token boundaries
12:16:45 <MissPiggy> now we have to write  parse :: Concrete operator => Parser (Syntax operator)
12:16:57 <MissPiggy> (for some Parser)
12:17:22 <MissPiggy> what sort of parse errors should it explain?
12:18:16 <MissPiggy> (also should  DIGIT-CHAR-P  be one variable, or a subtraction?)
12:18:36 * MissPiggy thinks probably subtraction since it's an MLy thing to have whitespace for application
12:20:04 <edwardk> MissPiggy: i'm personally fond of foo-bar being a single token, but i realize that may be unpopular here
12:20:12 * Twey isn't
12:20:17 <Twey> Er
12:20:24 <Twey> With me, it isn't
12:20:30 <mauke> one variable!
12:20:32 <Twey> Thatâ€¦ made perfect sense in my head
12:20:33 <kmc_> yes
12:20:35 <Twey> Anyway
12:20:39 <MissPiggy> edwardk I like it too, but .. only when nobody is looking :p
12:20:52 <kmc_> call-with-current-continuation looks nicer than either call_with_current_continuation or callWithCurrentContinuation
12:20:55 <Twey> I like enforcing operator spacing.
12:20:56 <Zao> I prefer ' as token fluffification glyph.
12:21:03 <Zao> I may be damaged by bindings-DSL though.
12:21:04 <MissPiggy> it's a good thing only lisp has call-with-current-continuation
12:21:05 <Twey> It fixes negative numbers, too.
12:21:09 <kmc_> scheme
12:21:11 <jmcarthur> edwardk: kind of ironic that supplying more abstractions *complicates* it...
12:21:14 <kmc_> lisp doesn't, afaik
12:21:15 <lament> edwardk: it's good in itself, but it would just lead to dilution of standard naming conventions and less-homogenous looking code
12:21:21 <edwardk> Zao:  this'looks'kind'of'like'Klingon to me ;)
12:21:22 <Zao> c'IDirect3DDevice9'CreateVertexBuffer
12:21:29 <Twey> Ew
12:21:36 <kmc_> i like the agda lexing philosophy
12:21:39 <MissPiggy> so anyway what sort of syntax errors should we talk about?
12:21:43 <edwardk> lament: only if you think that camelcase is a good idea. ;)
12:21:45 <roconnor> MissPiggy: a parser error should be a structure that has exactly the set of all data that is not parsable.
12:22:01 <MissPiggy> roconnor you mean like proof?
12:22:08 <edwardk> lament: _'s lose to camelcase in the sense that you have to reach for the shift key -'s are typically easily typed.
12:22:11 <roconnor> MissPiggy: ie. Strings should be isomorphic to Either ParsedData ParserError
12:22:12 <lament> edwardk: it doesn't matter if the laws are good or bad; it only matters whether they're followed
12:22:16 <MissPiggy> that sounds a bit too hardcore
12:22:19 <roconnor> or better
12:22:29 <roconnor> MissPiggy: Either ParserError ParsedData
12:22:36 <roconnor> thus
12:22:36 <Twey> edwardk: You have to reach for the shift key for CamelCase, too :Ã¾
12:22:38 <lament> edwardk: having two competing naming conventions is certainly worse than having any one convention
12:22:40 <kmc_> err, shift is not far away
12:22:41 <MissPiggy> roconnor, isomorphic up to skipping whitespace and useless parens though :S
12:22:43 <edwardk> lament: sure. but i presume MissPiggy is constructing something for her own use. so she gets to define the standard usage conventions ;)
12:22:49 <kmc_> - is far away on QWERTY but not on a good layout
12:22:56 <Twey> Yeah
12:23:00 <lament> edwardk: yes that's what they all say and then they put it on hackage :D
12:23:01 <edwardk> Twey: yes, but its shift and another character.
12:23:06 <Twey> edwardk: Aye
12:23:07 <MissPiggy> edwardk is right but I hope kmc_ uses this too
12:23:07 <edwardk> lament: hah
12:23:08 <roconnor> MissPiggy: oh interesting point
12:23:19 <MissPiggy> or at least helps me write it XD
12:23:22 <kmc_> :)
12:23:24 <roconnor> MissPiggy: there is probably and adjuction hidden somewhere here.
12:23:29 <kmc_> i just want to improve my parsec-fu
12:23:33 <Vitka> Speaking of monads, I need to use Maybe inside GenParser, and getting nested Justs. I understand I need to use join somehow?
12:23:35 <roconnor> MissPiggy: ask edwardk
12:23:40 <kmc_> because i'm embarrassed at failing at such a task
12:23:46 <MissPiggy> I don't think knowing there is an adjunction would help me :p
12:23:47 <roconnor> edwardk: is a parser / pretty printer an adjuction?
12:23:53 <MissPiggy> because um I don't know what that is..
12:23:53 <kmc_> Vitka: yes.  join :: Maybe (Maybe a) -> Maybe a
12:23:55 <mreh> @src zipWith
12:23:55 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:23:55 <lambdabot> zipWith _ _      _      = []
12:24:08 <kmc_> (for Maybe)
12:24:29 <MissPiggy> kmc_ we should make this very small and complete and correct and you can upload it to hackage ^..^
12:24:32 <kmc_> heh
12:24:39 <kmc_> i'm not cool enough to upload stuff :/
12:24:42 <MissPiggy> me neither
12:24:53 <MissPiggy> well forget that then
12:25:00 <edwardk> roconnor: should be
12:25:27 <edwardk> roconnor: whether that is useful fact is another matter entirely ;)
12:25:37 <MissPiggy> I am trying to think about a structural error type (that could be elaborated into a human readable error message)
12:25:46 <MissPiggy> it's slightly tricky..
12:25:58 <MissPiggy> and I am getting the impression that zippers might be involved
12:25:58 <roconnor> edwardk: which one is the left adjoin?
12:26:09 <Twey> > join Nothing
12:26:09 <edwardk> MissPiggy: go steal the ideas from clang. they have very pretty errors
12:26:10 <lambdabot>   Nothing
12:26:15 <Twey> > join $ Just Nothing
12:26:16 <lambdabot>   Nothing
12:26:26 <Twey> > join . Just $ Just 5
12:26:27 <lambdabot>   Just 5
12:26:54 <MissPiggy> edwardk, can you tell me what I should read about clang?
12:26:54 <edwardk> roconnor: parsing is usually forgetful (of comments, parens, etc). so it pretty-printing is probably the 'free' left side.
12:27:03 <roconnor> MissPiggy: read a view from the left for how to create datatypes for errors :D
12:27:13 <edwardk> MissPiggy: http://hackage.haskell.org/package/category-extras-0.53.5
12:27:16 <MissPiggy> roconnor, well that's exactly what I thought you were suggesting
12:27:27 <edwardk> er
12:27:29 <edwardk> woops
12:27:31 <roconnor> MissPiggy: good, 'cause that is what I intended :D
12:27:36 <edwardk> http://clang.llvm.org/diagnostics.html
12:27:37 <MissPiggy> haha nice plug edwark ;P
12:27:41 <MissPiggy> edwardk*
12:27:48 <MissPiggy> "woops"
12:27:56 <edwardk> MissPiggy: missed copy before paste =)
12:28:18 <roconnor> edwardk: oh, does a forgetful functor always have an adjoint?
12:28:43 <dolio> "Forgetful functor" isn't a formally defined term.
12:28:46 <roconnor> actually I don't know what a forgetful functor is.  It always looks like something that threw structure away.
12:28:55 <MissPiggy> ahh this clang stuff puts me to shame, that is just excellence
12:30:02 <edwardk> roconnor: not always, but, if it exists, one expects to see something like: free -| forgetful
12:30:47 <Vitka> Hmm.
12:31:33 <Vitka> So I use join $ Just (lookup a b), and see "Just result" in output. Am I missing something? How do I extract result from Maybe?
12:31:40 <kmc_> pattern matching
12:31:58 <kmc_> using "case" or a function with multiple equations
12:31:59 <Vitka> Hmm.
12:32:13 <edwardk> MissPiggy: http://clang.llvm.org/docs/InternalsManual.html#Diagnostics might be better
12:32:14 <Vitka> Oh right.
12:32:19 <kmc_> why would you write "join $ Just (lookup a b)"
12:32:21 <roconnor> edwardk: does CAT have initial and final objects?
12:32:23 <edwardk> MissPiggy: the former only really talked about how the errors look.
12:32:30 <kmc_> that'll be always the same as just "lookup a b"
12:32:35 <sepp2k> How does one partially apply the - operator specifying the right operand? (-42) obviously doesn't work.
12:32:41 <kmc_> > subtract 42
12:32:42 <lambdabot>   {-3->-45;-2->-44;-1->-43;0->-42;1->-41;2->-40;3->-39}
12:32:42 <Vitka> Because I'm new to it. :)
12:32:46 <edwardk> roconnor: the empty category and the category with '1' object, no?
12:32:55 <roconnor> ok
12:33:03 <edwardk> er category '1' with one object
12:33:28 <sepp2k> kmc_: Thank you.
12:33:31 <kmc_> :)
12:33:39 <kmc_> unary minus is a stupid syntactic special case
12:33:39 <edwardk> you can define a functor uniquely from the empty category to any category and it is the only such functor, so it is initial.
12:33:56 <MissPiggy> kmc_, imo, it's best to pretend unary minus doesn't exist, what do you think?
12:33:59 <kmc_> meh
12:34:02 <kmc_> is what i think
12:34:05 <edwardk> you can define a functor uniquely from any category to the category with only one object and one arrow, so it is final.
12:34:07 <olsner> ooooh, was that a Show instance for a function there? (subtract 42)
12:34:11 <MissPiggy> kmc_ well you have to think SOMETHING :P
12:34:13 <Zao> MissPiggy: Or add an unary + for symmetry :)
12:34:14 <kmc_> olsner: yes
12:34:17 <kmc_> > succ
12:34:18 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
12:34:18 <edwardk> (er since there is only one such functor)
12:34:25 <kmc_> @check \xs -> xs == reverse xs
12:34:26 <lambdabot>   "OK, passed 500 tests."
12:34:29 <aledge> @src subtract
12:34:29 <lambdabot> subtract x y = y - x
12:34:36 <aledge> ...duh.
12:34:39 <ksf> fionread (Fd fd) = alloca $ \ptr -> c_ioctl_int fd 0x0000541B ptr >> fromIntegral <$> peek ptr
12:34:39 <aledge> haha
12:35:04 <ksf> I just love haskell for the fact that it can quickly degenerate to c
12:35:05 <kmc_> fionread
12:35:15 <kmc_> higher-order C at that
12:35:16 <edwardk> who hacked in the function Show?
12:35:32 <kmc_> i am FIONBIO, son of FIONCLEX
12:35:37 <ziman> smallcheck?
12:36:12 <ksf> all those calls, btw, are utterly underdocumented
12:36:15 <Twey> Haha
12:36:15 <edwardk> ziman: thought it might be something like that
12:36:22 <edwardk> > (+1)
12:36:23 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
12:36:31 <ksf> ...just as bad as syscalls, or worse.
12:36:35 <ziman> if i remember correctly
12:36:55 <edwardk> > (\b -> if b then Left "Banana" else Right 34)
12:36:56 <lambdabot>   {True->Left "Banana";False->Right 34}
12:37:21 <ziman> > (++"k")
12:37:23 <lambdabot>   ""->
12:37:23 <lambdabot>    "k"
12:37:23 <lambdabot>  "a"->
12:37:23 <lambdabot>    "ak"
12:37:23 <lambdabot>  "aa"->
12:37:25 <lambdabot> [5 @more lines]
12:37:28 <ksf> ...the way to get information is to piece together mailing list posts, and then you wonder how people came to know about the existance of saotehaiaos in the first place
12:37:43 <edwardk> heh, it should print as a case statement
12:37:49 <RayNbow> > const undefined
12:37:50 <lambdabot>   * Exception: Prelude.undefined
12:38:09 <edwardk> > const ()
12:38:10 <lambdabot>   {()->()}
12:38:16 <edwardk> ah, defaulting
12:38:27 <ziman> > (+)
12:38:28 <lambdabot>   -3->
12:38:28 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
12:38:28 <lambdabot>  -2->
12:38:28 <lambdabot>    {-3->-5;-2->...
12:38:33 <ziman> :)
12:38:37 <kmc_> > succ :: Char -> Char
12:38:38 <lambdabot>   {'a'->'b';'b'->'c';'c'->'d';'d'->'e'}
12:38:42 <RayNbow> > const (const ())
12:38:43 <lambdabot>   {()->{()->()}}
12:38:57 * ksf advocates System.IO.C
12:39:00 <edwardk> that is a surprisingly useful bit of functionality
12:39:26 <ziman> > sum :: [Int] -> Int
12:39:27 <lambdabot>   []->
12:39:27 <lambdabot>    0
12:39:27 <lambdabot>  [-2]->
12:39:27 <lambdabot>    -2
12:39:27 <lambdabot>  [-2,-1]->
12:39:29 <lambdabot> [5 @more lines]
12:39:37 <jmcarthur> ksf: System.IO.C?
12:39:46 <ksf> yep.
12:39:54 <ksf> sometimes, you just want to do low-level IO
12:39:57 <jmcarthur> what package?
12:40:01 <jmcarthur> oh, it doesn't exist
12:40:05 <jmcarthur> you just want it
12:40:07 <edwardk> would be happier if it was clearer. i.e. (\a -> case a of { ... -> ...; _ -> error "smallcheck isn't perfect")
12:40:42 <edwardk> MissPiggy: anyways, that is the style of errors I've been playing with encoding lately
12:40:59 <edwardk> MissPiggy: not sure if its useful for you or not
12:41:18 <edwardk> MissPiggy: but they are so pretty =)
12:41:52 <edwardk> and i already have to buffer up my entire source input anyways, so its easy for me to slice it up and print them
12:43:37 <hotaru2k3> > return (return ()) :: a -> b -> ()
12:43:38 <lambdabot>   {()->{()->()}}
12:44:44 <aavogt> > uncurry (,)
12:44:45 <lambdabot>   {((),())->((),())}
12:45:10 <streblo> ghc is not supported on snow leopard?
12:45:39 <Zao> streblo: Seems to be working decently for a whole bunch of people, I believe.
12:45:44 <sfuentes> can someone explain to me why some developers like to define their constants in hex?
12:45:52 <kmc_> easy to see the bits
12:46:04 <Zao> sfuentes: Easier to see bits if they're masky in nature.
12:46:20 <sfuentes> i see
12:46:25 <Zao> Or if they're round binary numbers, easier to type properly.
12:46:53 <Zao> I mean, do you rather type 0x7FFF or 32575?
12:46:56 <sinelaw> huh??
12:46:57 <sinelaw> dependencies conflict: lambdabot-utils-4.2 requires bytestring ==0.9.1.5
12:46:57 <sinelaw> however bytestring-0.9.1.5 was excluded because lambdabot-utils-4.2 requires
12:46:57 <sinelaw> bytestring ==0.9.1.4
12:47:03 <idnar> > curry (,)
12:47:04 <lambdabot>   {()->{()->{()->(((),()),())}}}
12:47:05 <sinelaw> WTF?
12:47:13 <Zao> See. I was off by 2 :)
12:47:26 <Twey> sinelaw: Crazy stuff.  Recently upgraded to .12?
12:47:43 <Zao> Err... 32767
12:47:47 <sinelaw> Twey, nope
12:47:53 <aavogt> > 0x7fff
12:47:54 <sinelaw> Twey, 6.10.4
12:47:55 <lambdabot>   32767
12:48:01 <Twey> Hmph.
12:48:10 <Twey> â€¦ maybe you should?  :Ã¾
12:48:26 <sinelaw> could be a combination of not-hackage-upgraded vs. upgraded packages
12:49:55 <sinelaw> won't that make it impossible for me to build lambdabot (which currently doesn't work anyway)
12:51:11 <MissPiggy> hello
12:51:24 <sinelaw> hey
12:52:40 <tibbe> Is there any documentation on testing monadic code using QuickCheck 2?
12:53:00 <sinelaw> Twey, ok how do i upgrade?
12:54:09 <mreh> :t fix
12:54:09 <lambdabot> forall a. (a -> a) -> a
12:54:31 <Twey> sinelaw: I was mostly joking.  You probably shouldn't (or at least I doubt it will fix your problem)
12:54:32 <mreh> how can I apply pred recusively many times?
12:54:48 <mreh> might be easier just to define Num a in the type context :D
12:54:51 <MissPiggy> mreh, you mean 10 times?
12:54:54 <MissPiggy> for example
12:54:55 <Twey> sinelaw: Moving your ~/.cabal somewhere and starting with a clean one might help
12:55:01 <sinelaw> Twey, ok i'll try that
12:55:08 <mreh> MissPiggy, and arbitary number of times
12:55:15 <mreh> s/and/an/
12:55:15 <MissPiggy> mred, well I would start by defining a data type:   data N = Z | S N,  and then the 'fold' on that time
12:55:30 <MissPiggy> which would be a function  induction :: a -> (a -> a) -> N -> a
12:55:39 <MissPiggy> and with that you use pred
12:55:40 <mreh> MissPiggy, there's the class Enum
12:55:43 <mreh> :t pred
12:55:44 <lambdabot> forall a. (Enum a) => a -> a
12:56:04 <lispy> > pred 0
12:56:05 <lambdabot>   -1
12:56:13 <Gracenotes> don't do it for Int!
12:56:20 <lispy> > fix . pred $ 0
12:56:20 <Gracenotes> er. I mean. for Natural.
12:56:21 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
12:56:21 <lambdabot>    arising from a use of `GHC.Enum...
12:56:29 <Gracenotes> doesn't sound so dangerous for Int.
12:56:36 <Twey> > let nTimes = (foldr (.) id .) . replicate in nTimes 2 pred 3
12:56:37 <lambdabot>   1
12:56:46 <lispy> :t fix pred
12:56:47 <lambdabot> forall a. (Enum a) => a
12:56:53 <lispy> oh right
12:56:55 <lispy> > fix pred $ 0
12:56:56 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
12:56:56 <lambdabot>    arising from a use of `GHC.Enum...
12:56:58 <Gracenotes> > pred minBound :: Int
12:56:59 <lambdabot>   * Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
12:57:00 * tibbe looks at the QuickCheck haddoc documentation and sighs.
12:57:03 <lispy> Okay, I give up
12:57:05 <Twey> lispy: fix pred is not a function
12:57:12 <Twey> (nor is it very useful)
12:57:14 <tibbe> dons: we can't replace QC1 with QC2 with its current abysmal documentation!
12:57:26 <lispy> Twey: heh, yeah.  I sholud actually read the type
12:57:30 <Twey> Heh
12:57:55 <aavogt> tibbe: source code and type signatures!
12:58:02 <tibbe> aavogt: yes!
12:58:09 <tibbe> aavogt: terrible!
12:59:09 <Gracenotes> > all (\x -> compare x EQ == x) [LT, EQ, GT]
12:59:10 <lambdabot>   True
12:59:28 * jmcarthur doesn't find QC2 so difficult
12:59:45 <Gracenotes> (Â¬_Â¬)
12:59:56 <hiptobecubic> Gracenotes, what? How is that right
12:59:57 <dons> it is bizarre.
13:00:04 <aavogt> but to be honest, I'm also not sure what some of the function in Test.QuickCheck.Monadic
13:00:06 <aavogt> are for
13:00:31 <MissPiggy> kmc_, any progress?
13:00:56 <Gracenotes> hiptobecubic: well, see what 'compare x EQ' is for a given x
13:01:27 <kmc_> no, i have to work on other stuff
13:01:53 <hiptobecubic> >let x = LT in compare x EQ
13:02:28 <hiptobecubic> > let x = LT in compare x EQ
13:02:29 <lambdabot>   LT
13:02:59 <hiptobecubic> Gracenotes, oh i see now. I misunderstood your function
13:09:11 * sinelaw has moved .ghc and .cabal away, and is now re-installing it all. :(
13:09:43 <MissPiggy> hm readp can't really do errors
13:15:22 <sinelaw> damn, i just can't get lambdabot to build!
13:18:33 <hotaru2k3> sinelaw: there can be only one!
13:18:51 <sinelaw> i guess
13:28:20 <sinelaw> @hoogle throwDynTo
13:28:21 <lambdabot> Control.OldException throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
13:28:25 <sinelaw> aha
13:30:20 <haskell-noob> hi
13:30:51 <sinelaw> cabal configure & build work fine, but cabal install fails "configuring". how can this be?
13:30:55 <sinelaw> hey haskell-noob
13:32:22 <haskell-noob> i am trying to understand Monad, but it has been confusing, even with the physical analogy
13:32:48 <Botje> just start using them
13:33:00 <edwardk> haskell-noob: start using them and see where the types fit.
13:33:02 <lament> which physical analogy, burritos?
13:33:06 <holmak> I also liked the "Monads are trees with grafting" paper
13:33:08 <edwardk> or space suits
13:33:26 <holmak> I think that actually provides useful insight
13:33:44 <haskell-noob> this physical analogy: http://www.haskell.org/all_about_monads/html/analogy.html
13:33:48 <lament> holmak: i always thought of them as pieces of pipe
13:33:53 <mauke> yeah, that analogy sucks
13:34:14 <mauke> just stop thinking about monads, they don't really matter anyway
13:35:23 <haskell-noob> so i should try use them and learn with practice? i was trying first understand the wholle thing, before practice
13:35:55 <holmak> experimentation will help a lot
13:35:56 <mauke> there is no "whole thing" and you can't understand it because there's not enough substance to understand
13:36:02 <Botje> haskell-noob: once you stop making type errors, you get monads. :)
13:36:12 <holmak> ha, its true!
13:36:14 <Philonous1> haskell-noob: Monads are an abstraction. Just use the concrete structures they abstract from and try to see later what they have in common
13:36:42 <mreh> it might help to explain what a Monad in haskell is
13:36:48 <monochrom> Monadology is like numerology: a lot of analogies and allegories.
13:37:00 <lament> nono, Monadology is more like the number 35
13:37:27 <mreh> it's a "container" with some special functions
13:38:15 <lament> but perhaps it's too abstract to talk about unspecified "containers" so let's take a concrete example, like a burrito
13:38:40 <mauke> meh
13:38:46 <MissPiggy> yeah so I guess I will use parsec instead of readp
13:38:52 <mreh> I spent two days thinking do syntax was just for IO because of that approach
13:38:55 <haskell-noob> many of you are responding my question. this place is really friendly. it seems the right place to get some help
13:38:55 <holmak> parsec is awesome!
13:38:57 <mauke> I'd like to see you collapse nested burritos
13:38:58 <lament> the key thing about a burrito is that if you wrap it into another tortilla, it's still a burrito
13:38:58 <monochrom> do { x âˆˆ getLine; print (length x) }
13:39:18 <MissPiggy> (:âˆˆ)
13:39:47 <holmak> haskell-noob: The best approach is probably to try to do something, and just use monads if they are part of the solution. They aren't a goal in and of themselves.
13:39:52 <monochrom> getLine is a container full of x's. we pick one.
13:39:56 <lament> mauke: it's the tortilla that's the monad
13:40:24 <lament> you wrap the ingredients in any number of tortillas and it's still a burrito
13:40:25 <monochrom> The other day someone found a lot of ants in a burrito bought from McDonald's.
13:40:36 <holmak> thats horrifying
13:40:38 <mreh> Tortilla Chille
13:40:40 <lament> obviously somebody was doing unsafePerformIO
13:41:05 <mreh> ant colony optimisation?
13:41:12 <mreh> ...lame
13:42:00 <lament> just a bunch of bugs :)
13:42:44 <monochrom> A prof from China attends ICFP for the first time in his life. He goes with new-met friends to a Mexican restaurant for dinner. He asks "what is burrito?" They answer "like a monad". He is enlightened.
13:43:22 <lament> a burrito is just a monoid object in the category of endofunctors on mexican cuisine?
13:43:46 <haskell-noob> Monad is a container for IO? IO is the problem?
13:43:50 <Botje> i wouldn't trust mexican endofunctors
13:43:53 <monochrom> I don't know. I just want to convey that analogies are symmetric.
13:44:11 <Botje> haskell-noob: no. IO in haskell happens to be encoded using monads.
13:44:19 <Twey> Wellâ€¦
13:44:22 <lament> monochrom: Beach is a life and then you swim.
13:44:23 <Twey> It happens to be a monad, anyway
13:44:30 <Twey> You don't have to use it as a monad
13:44:52 <Twey> monochrom: Hahaha, nice.
13:45:18 * hackagebot upload: GPipe 1.1.7 - A functional graphics API for programmable GPUs (TobiasBexelius)
13:45:36 <yrlnry> monochrom:  is "âˆˆ" here a strange rendering of "<-"?
13:45:57 <dolio> I like how whenever someone asks about the safe lazy IO package, people point them at examples of how terrible the lazy IO in the prelude is.
13:46:03 <monochrom> The âˆˆ is there to render "monad as container".
13:46:10 <mauke> â†âˆˆâˆ‹â†’
13:46:16 <MissPiggy> ^âˆˆâˆ‹^
13:46:23 <Twey> Heh
13:46:26 <monochrom> and hopefully to make people angry.
13:46:36 * benmachine is FURIOUS
13:46:42 <benmachine> what is the backwards one for?
13:46:57 <benmachine> contains, presumably
13:46:59 <mauke> â„• âˆ‹ 42
13:47:03 <Twey> (âˆ‹) = flip (âˆˆ)
13:47:05 <benmachine> heh
13:47:19 <dolio> The epigram documentation uses that all over.
13:47:25 <dolio> Makes my brain hurt.
13:47:39 <benmachine> > "âˆ‹"
13:47:40 <lambdabot>   "\8715"
13:47:42 <mauke> brain âˆ‹ hurt
13:47:44 <benmachine> handy
13:47:49 <benmachine> èœ•
13:47:51 <benmachine> hmm no
13:48:03 <mauke> lern2decimal
13:48:07 <benmachine> :(
13:48:10 <Twey> Hehe
13:48:26 <Twey> > showHex (ord "âˆ‹") ""
13:48:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:48:27 <lambdabot>         against inferred type...
13:48:31 <Twey> Oops
13:48:34 <Twey> > showHex (ord 'âˆ‹') ""
13:48:35 <lambdabot>   "220b"
13:48:37 <Twey> I can't believe I did that
13:48:38 <benmachine> âˆ‹
13:48:39 <benmachine> neat
13:50:33 <yrlnry> mauke:  That is really funny.
13:51:02 <MissPiggy> â„• âˆ‹ 42 -- always makes me double take when people write that
13:51:11 <MissPiggy> I can't think why, there's nothing especially confusing about it
13:51:59 <dolio> Well, with me, I'm just used to elem \in set and value : type.
13:52:28 <dolio> Writing it backwards, even though it's not ambiguous or anything, takes me longer to think about.
13:52:50 <haskell-noob> if IO is not the motivation for Monad, what is the motivation for Monad?
13:53:02 <diPython>  lol
13:53:08 <yrlnry> monads are the motivation for Monad.
13:53:46 <jmcarthur> haskell-noob: a more general interface for many tasks and the ability to write more functions that apply across a diverse range of tasks
13:54:07 <Philonous1> haskell-noob: IO was the motivation for monads initially, but they turned out to be much more useful and general than IO. To the point where IO is considered a bad example
13:54:27 <yrlnry> It's like asking what the motivation for objects is in OOP.  "If I/O is not the motivation for objects, what is the motivation for objects?"
13:54:46 <Botje> yrlnry: abstractfactorysingletonfactory!
13:54:54 <yrlnry> What, Java can't do I/O without objects?  The object is a wrapper for I/O functionality, is that it?
13:55:01 <MissPiggy> : is symmetrical though
13:55:08 <MissPiggy> so you can't write T : t
13:55:40 <MissPiggy> in bidirectional type systems they use âˆ‹ sometimes, if they aren't going with |- vs |=>
13:55:50 <MissPiggy> or up down arrows..
13:55:51 <MissPiggy> heh
13:55:55 <benmachine> @hoogle showHex
13:55:55 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
13:56:14 <dolio> I know. But simply (unconsciously) expecting the relation to be laid out a certain way makes things being laid out the opposite way more difficult to read.
13:57:10 <haskell-noob> Philonous1, can you tell me a better example than IO?
13:57:44 <Botje> any of the other monads
13:57:44 <Philonous1> haskell-noob: You can encode Continuation passing in a monad
13:58:06 * monochrom writes x:Ï„ -| Î“,x:Ï„ to make more people angry :)
13:58:10 <benmachine> Maybe is a simple monad that allows you to handle failure in a clear and efficient fashion
13:58:27 <benmachine> (efficient in a sense, anyway)
13:58:38 <MissPiggy> that is against nature!
13:58:46 <Twey> IO might be the motivation for monad-sugar
13:58:53 <Twey> do-notation, that is
13:58:56 <dolio> monochrom: How about x:t,G, too. Then you can use ordinary cons lists to implement it without being confusing.
13:59:16 <benmachine> IO wasn't always done in monads was it?
13:59:37 <dolio> Plus you get right-to-left type dependency for free, which is even more against the order people are used to.
13:59:41 <Philonous1> haskell-noob: Generally speaking, Monads are an interface to sequencing functions which may have effects. But you have to be very liberal about what effect means.
13:59:46 <benmachine> or at least I seem to recall when haskell was very young it did things differently
13:59:51 <benmachine> but that was waaay before my time
14:00:54 <mauke> yeah, list based IO
14:01:08 <copumpkin> dolio: I guess nobody has a clue about your incoherent instances question :P
14:01:30 <haskell-noob> Philonous1, it was a helpful answer. thanks
14:01:40 <dolio> copumpkin: Yeah. I was kind of hoping SPJ would have something to say on the matter.
14:02:08 <dolio> He probably does, but is just too busy.
14:02:26 <MissPiggy> :t groupBy fst . sort
14:02:27 <lambdabot>     Occurs check: cannot construct the infinite type:
14:02:28 <lambdabot>       a = (a, b) -> Bool
14:02:28 <lambdabot>     Probable cause: `fst' is applied to too many arguments
14:02:36 <MissPiggy> :t groupBy (comparing fst) . sort
14:02:37 <lambdabot>     Couldn't match expected type `Bool'
14:02:37 <lambdabot>            against inferred type `Ordering'
14:02:37 <lambdabot>     In the first argument of `groupBy', namely `(comparing fst)'
14:02:49 <hzap> first time i've seen #haskell stumped on haskell question :D
14:02:55 <copumpkin> hzap: OMG what question?
14:03:02 <Twey> What question is that?
14:03:09 <copumpkin> (troll :P)
14:03:14 <Twey> Heh
14:03:38 <MissPiggy> :t groupBy (compare fst) . sort
14:03:39 <lambdabot>     Couldn't match expected type `((a, b) -> a) -> Bool'
14:03:39 <lambdabot>            against inferred type `Ordering'
14:03:39 <lambdabot>     In the first argument of `groupBy', namely `(compare fst)'
14:03:41 <copumpkin> (by troll, I mean the quickest way to get help in a channel is to say nobody knows the answer to it, or that the topic of the channel sucks because nobody answered your question)
14:03:43 <MissPiggy> :[
14:03:45 <copumpkin> (but I'm only kidding)
14:03:48 <MissPiggy> :t comparing
14:03:49 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:03:57 <copumpkin> compare `on` fst or comparing :)
14:03:59 <MissPiggy> :t comparing fst
14:04:00 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
14:04:03 <hzap> i actually don't know what question they're referring to
14:04:07 <MissPiggy> :t groupBy
14:04:08 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
14:04:12 <copumpkin> hzap: oh what I said?
14:04:12 <MissPiggy> oh god!!!!!
14:04:18 <MissPiggy> that's what it was
14:04:29 <hzap> copumpkin: yeah
14:04:47 <monochrom> copumpkin: I use "provocative tactic" or "confrontational tactic" for that.
14:04:53 <copumpkin> troll is shorter
14:05:14 <yrlnry> Haskell sucks because it didn't work after I put jelly in my keyboard.
14:05:20 <monochrom> I think "troll" is inaccurate.
14:05:22 <MissPiggy> groupBy ((==)`on`fst) . sort . map tabulate
14:05:23 <MissPiggy> :(
14:05:24 <MissPiggy> ugly
14:05:33 <Twey> 's not so bad
14:05:48 <MissPiggy> Twey's great but what does that have to do with anything?
14:05:57 <Twey> Haha
14:06:10 <aavogt> @let equating = on (==)
14:06:10 <objection>  .L.hs:5:0:
14:06:11 <objection>      Failed to load interface for `Control.Arrow.Operations':
14:06:11 <objection>    ...
14:06:11 <lambdabot>  Defined.
14:06:34 <copumpkin> objection: .Operations? that isn't a standard module
14:06:38 <monochrom> Anyway, I answer that tactic with "I can't reproduce your problem".
14:06:46 <sinelaw> ahem.
14:06:51 <sinelaw> check this out
14:06:53 <sinelaw> @markov
14:06:53 <lambdabot> Unknown command, try @list
14:06:53 <objection> hem". he hecate hem". out withe fore your bads ok ant read that's grol. mort short short so try thec
14:07:03 <sinelaw> FAIL
14:07:10 <sinelaw> need further distance in markov chain
14:07:14 <sinelaw> but you get the point :)
14:07:24 <copumpkin> lol
14:07:40 <copumpkin> nice
14:07:45 <sinelaw> @markov
14:07:45 <lambdabot> Unknown command, try @list
14:07:46 <monochrom> . o O ( I don't get the point )
14:07:46 <objection> heythis nics witice ineed 's yout your ther preprov cool. thate polly need. think after canyther con
14:08:02 <monochrom> Oh haha I think I get it.
14:08:04 <mauke> gauma empt bric fluxedescencipaperticalness obstaphanick angestline palesker extendermacrocrysicoidaemoniscopic dischimbusybalite
14:08:20 <sinelaw> @markov
14:08:20 <lambdabot> Unknown command, try @list
14:08:21 <objection> herma trat it weird. hatend, try not wrolly @lit. gaumpkin comm. you wroliscoink ablet's bout died f
14:08:33 <mauke> oh god, it's learning
14:08:36 <monochrom> Who brought in this bot?
14:08:59 <mauke> sinelaw, obviously
14:09:19 <sinelaw> it's using http://hackage.haskell.org/package/markov-chain
14:09:19 <monochrom> Is it written in Haskell?
14:09:26 <sinelaw> monochrom, it's a lambdabot
14:09:36 <monochrom> OK good. Because if it is not written in haskell, I shall ban it. :)
14:09:40 <sinelaw> @markov
14:09:40 <lambdabot> Unknown command, try @list
14:09:40 <objection> hermard. Bectiono wroblet wit sho talister comettlettermard bot babot?? sho's thineed wright wittp:/
14:09:48 <sinelaw> it's not really learning.
14:09:53 <copumpkin> @markova
14:09:53 <lambdabot> Unknown command, try @list
14:09:53 <objection> hermand, try @lit wroblempkink poll lot?? Anywanywang! ne tratencipalit theybad mand, it's ok "comma
14:09:56 <sinelaw> anyway, i'll improve it and show off when it really works.
14:10:06 <sinelaw> good night all!
14:10:12 <sinelaw> @markov
14:10:12 <lambdabot> Unknown command, try @list
14:10:12 <objection> hermand, th http://have bulaw, it istal lis nic" forkov OK gaumpkinedeskell!he "command wrics ge. ga
14:10:17 <sinelaw> oy, fail.
14:12:10 <haskell-noob> thank you all
14:12:15 <haskell-noob> bye
14:18:19 <mreh> is that thing learning to be a chat bot?
14:18:27 <companion_cube> @djinn (a->b) -> (a->c)
14:18:27 <lambdabot> -- f cannot be realized.
14:18:38 <companion_cube> @djinn (a->(b->c)) -> (a->c)
14:18:39 <lambdabot> -- f cannot be realized.
14:19:12 <insane0> @djinn (a->c) -> (a->b->c)
14:19:13 <lambdabot> f a b _ = a b
14:19:42 <Twey> @vixen Are you learning to be a chat-bot?
14:19:42 <lambdabot> no, how dare you ask if i'm a bot!
14:19:44 <copumpkin> I'd run it on the public logs to train it
14:20:09 <jmcarthur> maybe the bot should remember words instead of letters... it'd take longer to learn things, but it would appear more coherent
14:20:10 <Twey> Haha, hermard
14:20:21 <MissPiggy>     Couldn't match expected type `TokenParser st' against inferred type `GenParser tok st1 a'
14:20:23 <MissPiggy> ... great
14:20:24 <copumpkin> jmcarthur: yeah
14:20:24 <companion_cube> @djinn m (a -> b) ->  m a -> m b
14:20:24 <lambdabot> -- f cannot be realized.
14:20:30 <Twey> Also â€˜fluxedescencipaperticalnessâ€™
14:20:37 <companion_cube> @djinn Monad m => m (a -> b) ->  m a -> m b
14:20:37 <lambdabot> -- f cannot be realized.
14:20:38 <copumpkin> companion_cube: m could be anything
14:20:39 <Twey> I love untrained Markov chains
14:20:43 <jmcarthur> me too
14:20:48 <copumpkin> companion_cube: it isn't smart enough :P
14:20:54 <companion_cube> ok :)
14:20:58 <jmcarthur> "Anywanywang!"
14:21:11 <Twey> xD
14:21:21 <copumpkin> cute
14:21:42 <mauke> ethroman thracal Xanticistoness ser assarysame zellable
14:22:02 <jmcarthur> might be nice to use a syntax other than @ too since it makes lambdabot speak up
14:22:10 <ddarius> jmcarthur: Why would it take longer to learn things?
14:22:22 <jmcarthur> ddarius: well, to get the same variety
14:22:28 <jmcarthur> level of variety, i mean
14:22:32 * hackagebot upload: dwarf 0.21 - Parser for DWARF debug format. (ErikCharlebois)
14:22:36 <ddarius> Also, I think Cale's(?) MegaMonad used a word level Markov model.
14:22:47 <jmcarthur> there are fewer words than there are letters around here
14:22:49 <copumpkin> MegaMonad? hah
14:23:27 <mauke> /query GumbyBRAIN
14:23:57 <Apocalisp> I want to fold a list with a function of the form: f (a,b) (c,d) = (d(a+c),d)
14:24:09 <Apocalisp> but I want to use a fold that requires a monoid
14:24:13 <mreh> has it become sentient yet?
14:26:51 <Apocalisp> I wonder if there's some function from that into a monoid so I can use foldMap.
14:27:06 <MissPiggy> :t parens
14:27:07 <lambdabot> Doc -> Doc
14:27:14 <MissPiggy> it says here: parens  :: CharParser st a -> CharParser st a
14:27:25 <c_wraith> different parens
14:27:28 <c_wraith> @hoogle parens
14:27:28 <lambdabot> Text.Read parens :: ReadPrec a -> ReadPrec a
14:27:29 <lambdabot> Text.Parsec.Token parens :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
14:27:29 <lambdabot> Text.PrettyPrint.HughesPJ parens :: Doc -> Doc
14:27:29 <Botje> don't trust \bot :)
14:27:40 <MissPiggy> but it says in my REPL parens :: TokenParser st -> CharParser st a -> CharParser st a
14:27:49 <MissPiggy> I just want CharParser st a -> CharParser st a :/
14:28:04 <Botje> sorry, parens is for tokenparsers
14:28:16 <Botje> use bracket "(" ")" or somesuch instead?
14:28:34 <MissPiggy>     Lexeme parser (brackets p) parses p enclosed in brackets ('<' and '>'), returning the value of p.
14:28:34 <Botje> hmm
14:28:40 <Botje> wait, that's also tokens :(
14:28:40 <MissPiggy> it's all messed up
14:28:55 <MissPiggy> docs I am reading are 4 Oct 2001
14:29:24 <MissPiggy> http://hackage.haskell.org/package/parsec-3.0.1
14:29:32 <MissPiggy> why is there Text.Parsec AND Text.ParserCombinators?
14:29:33 <mauke> char '(' *> p <* char ')'
14:29:59 <jmcarthur> ooh i'm excited about the google ai challenge. i have some ideas i want to try already
14:30:00 <Botje> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Combinator.html#v%3Abetween
14:30:10 <Botje> MissPiggy: the homepage is very old, yes
14:30:17 <MissPiggy>   import Text.Parsec.Language (haskellDef) -- woah
14:30:21 <MissPiggy> what is going on here
14:30:30 <MissPiggy> oh :/  parens      = P.parens lexer
14:30:32 <jmcarthur> http://csclub.uwaterloo.ca/contest/index.php
14:30:54 <jmcarthur> a haskell starter pack will be provided according to the site, but it's not available yet :\
14:31:45 <MissPiggy> thanks mauke I guess I have to
14:32:20 <Apocalisp> @type appEndo
14:32:21 <lambdabot> forall a. Endo a -> a -> a
14:32:35 <ddarius> MissPiggy: Text.Parsec is parsec3, Text.ParserCombinators.Parsec is parsec2 (or its compatibility layer in parsec3)
14:32:41 <Apocalisp> @src appEndo
14:32:42 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:33:42 <Apocalisp> oh, appEndo gets the function out of an Endo?
14:34:00 <mauke> @src Endo
14:34:00 <lambdabot> Source not found. That's something I cannot allow to happen.
14:34:45 <Apocalisp> @pl \f z t -> appEndo (foldMap (Endo . f) t) z
14:34:46 <lambdabot> flip . (appEndo .) . foldMap . (Endo .)
14:35:45 <MissPiggy> for parsec I should eat whitespace /after/ reading something?
14:35:53 <djahandarie> So what the hell is the point of point-free?
14:36:38 <mauke> MissPiggy: yes
14:37:09 <copumpkin> djahandarie: reducing the focus on values and shifting it to composition of primitive functions
14:37:28 <copumpkin> why mention a temporary variable you use to store the result of one function if you send it straight to another one?
14:37:32 <djahandarie> copumpkin, in the process possibly leading to incredible amounts of obfuscation?
14:37:40 <copumpkin> djahandarie: it can be overused
14:37:51 <jmcarthur> mostly it's more clear if used properly
14:37:58 <dolio> The point is to use it when it results in nicer code.
14:38:21 <jmcarthur> f . g . h   is a bit nicer than   \x -> f (g (h x))
14:38:22 <djahandarie> I guess ((.)$(.))
14:38:37 <MissPiggy> fgh is better :P
14:39:20 <jmcarthur> and   f <=< g <=< h   is a bit nicer than   \x -> f =<< g =<< h =<< x
14:39:28 <Twey> MissPiggy: But ambiguous!
14:39:41 <hotaru2k3> point-free does make things like "loeb" easier to understand
14:39:57 <copumpkin> :t fmap (ap sequence)
14:39:58 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f ([a -> a1] -> a) -> f ([a -> a1] -> [a1])
14:40:05 * MissPiggy is stuck with parsec now
14:40:09 <MissPiggy> how do I do this??
14:40:09 <copumpkin> :t ap (fmap sequence)
14:40:10 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => ((a1 -> [m a]) -> a1) -> (a1 -> [m a]) -> m [a]
14:40:27 <Botje> MissPiggy: use the damn token parser, be happy :)
14:40:33 <holmak> MissPiggy: check out the RWH parsec tutorial
14:41:20 <holmak> MissPiggy: http://book.realworldhaskell.org/read/using-parsec.html
14:42:25 <sshc> how do I test if a value is indefined?
14:42:26 <MissPiggy> thanks
14:42:36 <sshc> > undefined == undefined
14:42:36 <ksf> @djinn Maybe a -> (a -> IO (Maybe b)) -> IO (Maybe b) -> IO (Maybe b)
14:42:36 <lambdabot> Error: Undefined type IO
14:42:36 <lambdabot>   * Exception: Prelude.undefined
14:42:49 <ksf> @djinn Maybe a -> (a -> m (Maybe b)) -> m (Maybe b) -> m (Maybe b)
14:42:50 <lambdabot> f a b c =
14:42:50 <lambdabot>     case a of
14:42:50 <lambdabot>     Nothing -> c
14:42:50 <lambdabot>     Just d -> b d
14:42:59 <Twey> Mph
14:43:10 <mauke> sshc: you don't
14:43:18 <Twey> @djinn Monad m => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b) -> m (Maybe b)
14:43:19 <lambdabot> f a b c =
14:43:19 <lambdabot>     case a of
14:43:19 <lambdabot>     Nothing -> c
14:43:19 <lambdabot>     Just d -> b d
14:43:22 <Twey> Hm
14:43:44 <mauke> sshc: undefined is conceptually the same as a runtime exception or an infinite loop
14:43:59 <ksf> yep it's not reliant on monads
14:43:59 * MissPiggy needs chainl2
14:44:12 <Twey> f a b c = maybe c b a
14:44:16 <ksf> I was failing all the time trying to hook up Maybe and IO, while the point is just not to do it.
14:44:17 <Twey> flip3!
14:44:37 <ksf> oh wait
14:44:47 <arjanb> what are good resources or examples to look at when trying to design an edsl?
14:44:56 <ksf> @djinn Maybe a -> (a -> m b) -> m b -> m (Maybe b)
14:44:56 <lambdabot> -- f cannot be realized.
14:45:09 <ksf> @djinn Monad m => Maybe a -> (a -> m b) -> m b -> m (Maybe b)
14:45:10 <lambdabot> -- f cannot be realized.
14:45:12 <Twey> Hm
14:45:28 <ksf> @djinn Monad m => Maybe a -> (a -> m a) -> m a -> m (Maybe a)
14:45:28 <lambdabot> -- f cannot be realized.
14:45:30 <benmachine> djinn doesn't do higher types, I've heard
14:45:37 <MissPiggy> I have an infinite loop that wont go away
14:47:16 <kmc_> djinn doesn't do polymorphism :/
14:47:24 <MissPiggy> eah it does
14:47:32 <MissPiggy> oh wait
14:47:42 <MissPiggy> do you mean like forall a. a -> (forall s. ...)
14:47:47 <MissPiggy> I guess it doesn't do that ...
14:47:51 <kmc_> i think each distinct type variable is basically a distinct concrete type with no constructors visible
14:48:01 <kmc_> yeah, it doesn't do any higher-rank types
14:48:32 <MissPiggy> @djinn (forall s. (s -> s) -> s) -> (((b -> b) -> (b -> b)) -> (b -> b)) -> ((b -> b) -> b)
14:48:32 <lambdabot> -- f cannot be realized.
14:48:38 <kmc_> @djinn forall -> forall
14:48:39 <lambdabot> f a = a
14:48:46 <MissPiggy> haha
14:48:49 <MissPiggy> that worked better than my test
14:48:52 <kmc_> @djinn forall s. a -> forall s. a
14:48:52 <lambdabot> -- f cannot be realized.
14:48:56 <kmc_> hmm
14:48:58 <kmc_> @djinn a -> a
14:48:59 <lambdabot> f a = a
14:49:05 <MissPiggy> @djinn forall . -> .
14:49:06 <lambdabot> Cannot parse command
14:49:07 <kmc_> @djinn a. -> a.
14:49:08 <lambdabot> f a = a
14:49:11 <MissPiggy> @djinn forall a.  -> a.
14:49:12 <lambdabot> Cannot parse command
14:49:18 <kmc_> @djinn a b -> a b
14:49:18 <lambdabot> f a = a
14:49:47 <MissPiggy> kmc_ hey I wrote a parser but it loops
14:49:53 <kmc_> me too :/
14:49:53 <MissPiggy> ;`(
14:49:58 <MissPiggy> I guess we did the same thing
14:50:05 <ksf> @djinn bar :: (Monad m, Functor m) => Maybe a -> (a -> m b) -> m (Maybe b)
14:50:05 <lambdabot> Cannot parse command
14:50:11 <ksf> @djinn  (Monad m, Functor m) => Maybe a -> (a -> m b) -> m (Maybe b)
14:50:11 <lambdabot> -- f cannot be realized.
14:50:12 <MissPiggy> kmc_ do you know how to fix it
14:50:16 <kmc_> no :(
14:50:22 <kmc_> i am embarrassed by this
14:50:24 <diPython> lol
14:50:29 <copumpkin> BE VERY EMBARRASSED
14:52:07 <MissPiggy> the problem is that an expression parser on term, can return a single term
14:52:19 <MissPiggy> so you get  Term (Application (Term (Application ...
14:52:22 <kmc_> yes
14:52:22 <MissPiggy> as the parse tree
14:52:41 <kmc_> i don't know how to fix these things.  usually by factoring the grammar, but i don't see how here
14:54:13 <ksf> @djinn (a -> Bool) -> Maybe a -> Maybe a
14:54:14 <lambdabot> f a b =
14:54:14 <lambdabot>     case b of
14:54:14 <lambdabot>     Nothing -> Nothing
14:54:14 <lambdabot>     Just c -> case a c of
14:54:14 <lambdabot>               False -> Nothing
14:54:16 <lambdabot>               True -> Just c
14:54:50 <ksf> both of those functions are missing from Data.Maybe
14:55:01 <ksf> :t when
14:55:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:55:23 <ksf> or is there a generic filter?
14:55:26 <SubStack> IORefs suck, I've just discovered
14:55:36 <ksf> mvars are better
14:55:40 <ksf> tvars even more so
14:55:56 <olsner> MissPiggy: factoring the grammar, yes... maybe you want to defer the decision to produce a Term (or Application) until a little later or something
14:55:58 <Vanadium> What is wrong with IORefs?
14:56:07 <SubStack> Vanadium: not thread-safe
14:56:11 <SubStack> hopengl examples like using them
14:56:14 <Vanadium> Well. Yeah. Okay.
14:56:47 <mauke> how are they not thread-safe?
14:57:04 <kmc_> reads and writes are not guaranteed atomic, i think
14:57:36 * kmc_ <3 first-class threads and chans
14:57:39 <augustss> IORefs are a bad idea if you do multi-threading
14:57:53 <SubStack> chans <3
14:57:57 <kmc_> using mutexes now feels like programming in assembly by comparison
14:58:16 <kmc_> though an (MVar ()) is like a mutex anyway
14:59:23 <ksf> oh, find from Foldable should work
14:59:29 <benmachine> how can reads and writes not be atomic?
14:59:59 <benmachine> you get a thing and it is a thing
15:00:08 <c_wraith> think at a lower level
15:00:14 <c_wraith> hardware doesn't guarantee atomicity
15:00:20 <c_wraith> unless you specifically ask for it
15:00:28 <Twey> Especially for complex values
15:00:35 <benmachine> so, you read a variable of a list and you get half of it?
15:00:39 <Twey> Yup
15:00:50 <benmachine> maaan
15:00:54 * benmachine opts out
15:00:57 <Twey> Heh
15:01:17 <Twey> Half of it and a segfault when you try to get the rest, likely
15:01:33 <SubStack> anyways, hopengl examples should stop using them
15:01:38 * mauke uses a volatile sig_atomic_t
15:01:38 * SubStack was duped into thinking it was ok
15:03:20 <badsheepy> does anyone know of any sort of guide or something to getting glut working with winhugs? googling just finds me lots of people with problems and no success
15:04:19 <ksf> :t find
15:04:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:04:44 <jmcarthur> augustss: not necessarily bad. if all you need is atomic update and not a real lock, IORef is fine
15:04:57 <jmcarthur> atomic set, i mean
15:05:03 <jmcarthur> not read-and-set
15:05:38 <augustss> Only atomicallyModifyIORef guarantees any atomicity.
15:05:53 <jmcarthur> i thought read and write was atomic...
15:05:57 * jmcarthur looks it up
15:06:13 <augustss> I don't think so
15:06:16 <benmachine> I thought read and write were atomic
15:06:21 * benmachine doesn't look it up
15:06:40 * augustss doesn't even know where to look it up.
15:07:37 <MissPiggy> kmc_ ah this sucks!!
15:08:36 <ksf> @hoogle Maybe a -> (a -> m b) -> m (Maybe b)
15:08:37 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
15:08:37 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
15:08:37 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:09:09 <adu> omg ppl are stupid
15:10:05 <djahandarie> adu, this is why we must follow the ubermensch and evolve into the super race!
15:10:11 * djahandarie spreads his radical views
15:10:16 <augustss> adu: what else is new?
15:10:38 <ksf> I can't believe it. it actually works.
15:10:56 <adu> http://www.youtube.com/watch?v=6WHu1EM8CgY&feature=player_embedded# he calls OpenSolaris "linux" and calls traceroute "IP grabber" ugh
15:11:13 <adu> oh, and he calls VirtualBox "VMware"
15:11:21 <adu> stupid
15:11:29 <damd> adu: this one's a legend: http://www.youtube.com/watch?v=SXmv8quf_xM
15:11:33 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17085#a17085
15:11:38 <ksf> now that's a function.
15:11:44 <damd> he can see the ip addresses of everyone surfing google using a hacker tool called "tracert"
15:11:58 <adu> lol
15:12:25 <augustss> well known hacker tool
15:12:29 <tensorpudding> what's the standard way to refer to the unix/unix-like os's in one word?
15:12:45 <damd> *nix i think?
15:12:48 <ksf> unices
15:12:55 <Vanadium> posix
15:13:02 <damd> linux is posix?
15:13:06 <tensorpudding> it's not posix, because most of them aren't fully posix-compliant
15:13:07 <Vanadium> Kind of
15:13:21 <SubStack> unesque
15:13:23 <ksf> unix is an idea, not an operating system
15:13:29 <SubStack> or posesque
15:13:35 <ksf> plan9 and beos are unices, too.
15:13:35 <tensorpudding> unices could also refer to considering true unixes
15:13:37 <augustss> And I would never have called VMS unix, but it was posix compliant.
15:13:48 <tensorpudding> windows server is posix compliant i think
15:13:52 <tensorpudding> and osx is too
15:14:13 <ksf> but only the bare minimum posix, and not the most useful stuff
15:14:15 <augustss> well, osx is kinda unix
15:14:18 <tensorpudding> but unix is an idea, UNIX is an operating system
15:14:23 <ksf> osx is bsd
15:14:42 <hotaru2k3> osx is a fancy gui on top of unix
15:14:48 <tensorpudding> osx is derived from bsd which is unix
15:14:57 <augustss> but with a microkernel as well
15:14:59 <hotaru2k3> and it's not bsd
15:15:10 <ksf> now i want a prelude that comes with Foldable etc. instead of the standard stuff
15:15:12 <tensorpudding> yes
15:15:21 <tensorpudding> but unix is not about kernels is it?
15:15:34 <ksf> unix is about files
15:15:47 <tensorpudding> hurd is a unix-like
15:15:48 <ksf> ...and shells and fork
15:15:49 <Twey> unix is plan9
15:15:49 <damd> unix is about emacs
15:15:51 <Twey> :Ã¾
15:15:59 <tensorpudding> plan9 is not unix
15:16:03 <jmcarthur> os x is mach with a ton of freebsd code thrown in for good measure
15:16:09 <tensorpudding> it's supposed to be a better unix than unix
15:16:25 <hotaru2k3> tensorpudding: unix isn't. bsd sorta is.
15:16:34 <jmcarthur> i don't really get the whole argument that os x isn't a valid unix though
15:16:38 <hotaru2k3> (re kernels)
15:16:41 <ksf> think read, write, open, close syscalls
15:16:53 <ksf> you can do everything with that
15:17:03 <augustss> osx has freebsd code in the kernel and netbsd code in userland
15:17:05 <ksf> ...even doing syscalls
15:17:09 <tensorpudding> in any case, is osx unix-like?
15:17:31 <augustss> absolutely
15:17:34 <copumpkin> tensorpudding: osx is certified unix but most users don't use it that way :P
15:17:47 <jmcarthur> is darwin a unix? if it is then os x is
15:17:50 <adu> copumpkin: i do
15:17:55 <augustss> i do too
15:17:59 * jmcarthur too
15:18:03 * copumpkin too :P
15:18:10 <copumpkin> I'm not surprised that people in here tend to
15:18:24 <adu> copumpkin: I <3 grep, cut, sort, find, sed, ... mmm
15:18:30 <tensorpudding> you can use osx like unix
15:18:32 <jmcarthur> heck i used to run kde on it
15:18:40 <jmcarthur> way back in the day
15:18:58 * copumpkin tends to have a dozen open terminal sessions at any given time
15:19:04 <tensorpudding> but the unix-bits don't allow you complete control
15:19:05 * benmachine is certified
15:19:14 <Veinor> I want to shoot whoever wrote the numeric part of Haskell's prelude
15:19:18 <jmcarthur> tensorpudding: define complete control
15:19:19 <adu> i only have 8 terminals open
15:19:35 <Veinor> copumpkin: I only have two, but I have a couple screen sessions in each :D
15:19:40 <ksf> I want to hug whoever wrote traversable and foldable
15:19:49 <copumpkin> Veinor: get in line, I'm first
15:19:59 <Twey> Veinor: Use the Numeric Prelude, perhaps
15:20:11 <ksf> I'm getting closer and closer to haskell without any mention of ifthenelse
15:20:11 <copumpkin> numeric prelude is ugly in a different way :P
15:20:15 <tensorpudding> can you install X11 and GNOME on OSX, then reboot and have it boot into a GNOME environment, without doing any of apple's fun stuff?
15:20:18 <Twey> How does LaTeX literate coding actually work?
15:20:33 <adu> Veinor: I want to shoot whoever wrote the numeric prelude
15:20:40 <Twey> Can I just run ghc on a LaTeX file containing \begin{code} â€¦ \end{code} blocks?
15:20:58 <ddarius> Twey: Yes.
15:21:00 <ksf> Twey, call it .lhs or pass some flag
15:21:01 <Twey> Huh.
15:21:03 <tensorpudding> you have to specify that it's a literate haskell file
15:21:08 <Twey> How do I do that?
15:21:14 <tensorpudding> if it has a .tex extension you need a ghc flag
15:21:20 <Twey> What's the flag?  I'd rather keep it as .tex
15:21:45 <ksf> .tex.lhs?
15:21:50 <copumpkin> .lhs isn't straight tex
15:22:00 <copumpkin> you typically don't want the headers and distracting stuff
15:22:01 <adu> tensorpudding: X11 is installed by default now, and you don't have to boot, just set X11 to fullscreen mode
15:22:05 <ksf> tex doesn't care about extension for all I know
15:22:11 <jmcarthur> well i can't find anything saying the IORef is atomic, so i guess if it is then it's not because its specification says so
15:22:13 <temoto> > let ifthenelse cond f g = case cond of True -> f; False -> g in ifthenelse (0==0) 1 2
15:22:14 <lambdabot>   1
15:22:16 <tensorpudding> adu: but that's not what i want
15:22:23 <adu> tensorpudding: what do you want?
15:22:26 <tensorpudding> i want to not have to run it in apple's window manager
15:22:32 <tensorpudding> if that is the term for it
15:22:36 <adu> tensorpudding: oh, you want XDarwin
15:22:43 <tensorpudding> whatever it is that runs on darwin that provides windowing systems
15:22:55 <Twey> ksf: Hmm
15:23:00 <temoto> ksf, do you mean that haskell without ifthenelse?
15:23:01 <tensorpudding> what you're talking about (if i understand correctly) is running X11 in this environment as kind of a sandbox
15:23:08 <adu> tensorpudding: XDarwin doesn't require anything Apple, XQuartz uses Apple's stuff
15:23:13 <jmcarthur> i used XDarwin and no aqua many years ago
15:23:37 <ksf> temoto, such things: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17085#a17085
15:23:55 <ksf> no if for the <, no case for the maybe
15:23:57 <tensorpudding> is it possible to link your own code to cocoa without using xcode?
15:24:27 <adu> tensorpudding: yes, if you're using gcc, just add the options -framework ApplicationServices
15:24:44 <tensorpudding> hmm
15:24:50 <tensorpudding> so do you actually need xcode at all?
15:24:53 <adu> tensorpudding: this should probably be moved to #macdev
15:25:03 <tensorpudding> or maybe #haskell-blah
15:25:05 <ksf> thinking of maybe as a monad is the completely wrong way to get to that code
15:26:00 <tensorpudding> i don't have a mac so it's all my speculation
15:26:24 <MissPiggy> so yeah
15:26:33 <MissPiggy> I can't use buildExpressionParser
15:26:40 <MissPiggy> I'll have to think of something better
15:27:46 <temoto> ksf, ok, i shouldn't have asked :)
15:28:01 <ksf> oh, but it's easy.
15:28:12 <ksf> maybe is nothing else but a list with at most one element
15:28:30 <ksf> ...so you can mapM and everything it.
15:28:37 <temoto> ksf, i understand what it does (because names are self explanatory) but close to nothing 'how'
15:29:01 <shapr> Is there some way to track packages which depend on this package in cabal/hackage?
15:29:38 <temoto> shapr, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec it has Dependencies line.
15:29:57 <ksf> fionread is -> IO (Maybe Int), and the whole function -> IO (Maybe (ForeignPtr Word8))
15:30:12 <MissPiggy> lol I can't anything
15:30:23 <ksf> ...that int being the number of bytes ready in the input buffer
15:30:47 <MissPiggy> kmc_ yeah I just had a thought!
15:31:24 <shapr> temoto: Specifically, I want to find all the packages that list gitit as a dependency.
15:31:54 <temoto> shapr, i don't know how to do that, sorry.
15:32:23 <shapr> Ok, just wondered if there was an obvious way to do that.
15:32:30 <temoto> ksf, why Maybe Int?
15:32:38 <ksf> because the ioctl might fail
15:32:48 <temoto> ioctl?
15:33:06 <temoto> Are you writing high performance server for windows?
15:33:13 <ksf> ...that's a posix function to do device-dependent operations and queries
15:33:33 <temoto> ioctl posix? O_O
15:33:39 <ksf> I couldn't care less about windoze
15:34:05 <temoto> I always thought that ioctl is a windows analog of epoll/kqueue.
15:34:18 <ksf> oh, I see. CONFORMING TO No single standard.
15:34:23 <shapr> Is there an ubuntu deb for ghc6.12?
15:34:26 <ksf> but it's definitely unix
15:35:00 <temoto> ksf, device depended, huh?
15:35:13 <temoto> Like camera?
15:35:45 <temoto> And wait, Maybe doesn't provide with fail.
15:36:11 <temoto> Int being 0 is the same amount of information as Nothing.
15:36:51 <ksf> mh I just noticed that I should try to read even if the call failed.
15:37:09 <ksf> ...some small buffer size, as not to waste space
15:37:23 <ksf> or into a larger buffer
15:40:49 <jmcarthur> shapr: there is a library for queries hackage: http://hackage.haskell.org/packages/archive/cabal-query/0.1/doc/html/Distribution-Query.html
15:40:55 <jmcarthur> *querying
15:41:01 <ksf> @djinn Maybe a -> b -> Maybe b
15:41:01 <lambdabot> f a b =
15:41:02 <lambdabot>     case a of
15:41:02 <lambdabot>     Nothing -> Nothing
15:41:02 <lambdabot>     Just _ -> Just b
15:41:22 <ksf> that's precisely the wrong one.
15:41:27 <jmcarthur> shapr: i also recall somebody putting up a demo of hackage with reverse dependencies, but i don't know if it's still around
15:41:36 <ksf> @hoogle Maybe a -> b -> Maybe b
15:41:37 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
15:41:37 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
15:41:37 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
15:41:40 <Veinor> Reverse dependencies?
15:41:59 <jmcarthur> Veinor: on the package page it showed what packages depended on that package
15:42:04 <Veinor> ahh.
15:46:24 <MissPiggy> oh god dammit
15:50:03 <pastorn> MissPiggy: what'cha doin?
15:50:13 <MissPiggy> I forgot something important
15:50:34 <pastorn> dog ate your homework?
15:50:49 <temoto> Does somebody play facebook games?
15:50:55 <copumpkin> NO
15:51:05 <idnar> ksandstr: what function did you want?
15:51:09 <laurent_atl> nobody
15:51:57 <pastorn> temoto: only that typing game
15:52:02 * ddarius has probably forgot a lot of things that are important.
15:53:53 <benmachine> temoto: do mindgames count?
15:54:54 <temoto> I guess any do count.
15:59:15 <sm> is there an easy way to get some nice colour lists for use in Chart ?
16:00:17 <sm> ideal would be a near-infinite list of nice non-harsh, no similar adjacent colours
16:02:17 <temoto> sm, nice_colours = zipWith3 RGBColor grad grad grad where grad = [0x60,0x66..0xff]
16:03:15 <MissPiggy> kmc_ want to hear my idea
16:04:05 <temoto> sm, that's pretty much a pseudocode in a sense i don't know whether there is an RGBColor constructor. But i hope i expressed the idea.
16:04:32 <sm> temoto: thanks for the suggestion.. how does it work, actually
16:04:40 <sm> I can't see how it would
16:05:31 <sm> oh you'd get 60,60,60.. 66,66,66.. ff,ff,ff ?
16:05:38 <tensorpudding> that would do grayscale
16:05:40 <temoto> sm, yes.
16:05:43 <tensorpudding> but it wouldn't give you many colors
16:05:55 <temoto> sm, no, it's more permutations.
16:06:00 <sm> I know from past attempts it's not so easy to get attractive results
16:06:11 <pastorn> @src liftM3
16:06:12 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
16:06:14 <temoto> idea is to have 60 60 60, 60 60 66, 60 66 60, etc
16:06:33 <MissPiggy> emoto, you can do
16:06:35 <tensorpudding> ah, that's the ticket
16:06:56 <MissPiggy> > let abc = ['a','b','c'] ; xyz = ['x','y','z'] in sequence [abc,xyz]
16:06:57 <lambdabot>   ["ax","ay","az","bx","by","bz","cx","cy","cz"]
16:07:06 <pastorn> > let xs = [1..3] in liftM3 (,,) xs xs xs
16:07:07 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
16:07:23 <MissPiggy> hm liftM3 is better though
16:07:25 <tensorpudding> > liftM3 (,,) grad grad grad where grad = [0x00,0x01..0xff]
16:07:26 <lambdabot>   <no location info>: parse error on input `where'
16:07:30 <tensorpudding> err
16:07:42 <tensorpudding> > let grad = [0x00,0x01..0xff] in liftM3 (,,) grad grad grad
16:07:43 <lambdabot>   [(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0...
16:08:15 <tensorpudding> better to choose a larger stepsize than that though
16:08:22 <temoto> sm, ^ but start from 0x60 or 0x90 and make step a bit bigger, like 3 or 6.
16:08:49 <tensorpudding> it won't give you a pretty order either
16:09:24 <sm> yeah.. I figured there are some nice eye-friendly colour lists/generators somewhere
16:10:52 <sm> http://stackoverflow.com/questions/236936/how-pick-colors-for-a-pie-chart is wondering too
16:13:23 <sm> hmm. colour has "linearRGBSpace - Produce a linear colour space from an RGBGamut."
16:14:54 <sm> chromaticity.. transfer function.. ow
16:17:00 <sm> ok, going what you guys pasted.. that's neat
16:17:58 <tensorpudding> the fancy techniques usually involve some math
16:19:21 <dbro> I am trying to make a polymorphic version of an average function, that can accept integers or doubles as input, and generate its answer in the same type as the input. is this possible?
16:19:38 <temoto> dbro, aha.
16:19:47 <pikhq> dbro: Sure.
16:19:56 <kmc_> MissPiggy: what's your ide
16:19:58 <kmc_> a
16:20:02 <pikhq> dbro: It's easier to do it on all the numbers, though.
16:20:07 <MissPiggy> kmc_ lexing can parse function application
16:20:13 <dbro> ok, here is what I tried:
16:20:24 <dbro> average :: (Num a) => [a] -> a
16:20:30 <dbro> average xs = (fst totals) / (snd totals)
16:20:36 <dbro>     where totals = foldr (\x (sum,cnt) -> (sum+x, cnt+1.0)) (0.0, 0.0) xs
16:21:07 <MissPiggy> dbro that looks very good
16:21:16 <MissPiggy> except you should use 1 and 0 instead?
16:21:22 <temoto> @src average
16:21:22 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:21:31 <dbro> my imperative-language instinct tells me that I need to cast the x in sum+x -- ?
16:21:33 <temoto> Don't we have it in stdlib?
16:21:38 <doserj> I don't think what you want is possible
16:22:03 <MissPiggy> dbro, which language?
16:22:11 <dbro> C/C++
16:22:13 <Twey> Is there any way to allow indented \end{code} in unlit?
16:22:15 <pikhq> dbro: Have you tried running this?
16:22:16 <MissPiggy> dbro, :(
16:22:49 <doserj> pikhq: that function obv. doesn't work because (/) is not defined for Num
16:23:00 <pikhq> doserj: Ah, right.
16:23:07 <pikhq> The obvious failure.
16:23:09 <temoto> dbro, also, cnt could be integer, right?
16:23:22 <pikhq> @hoogle (Num a) => a -> a -> a
16:23:22 <lambdabot> Prelude (*) :: Num a => a -> a -> a
16:23:22 <lambdabot> Prelude (+) :: Num a => a -> a -> a
16:23:22 <lambdabot> Prelude (-) :: Num a => a -> a -> a
16:23:24 <MissPiggy>  I am trying to convince dbro to use 0 and 1 instead of 0.0 and 1.0
16:23:26 <Twey> average :: (Num a, Fractional b) => [a] -> b
16:23:32 <benmachine> Twey: I thought not allowing it was a feature, so that you could use \end{code} "on the sly"
16:23:44 <benmachine> I suppose that only really makes sense with \begin{code}
16:23:46 <Twey> benmachine: I don't want to :Ã¾  I want my LaTeX to look nice
16:23:48 <pikhq> Pesky "not all numbers have division defined". :P
16:23:52 <benmachine> but it'd be weird to have one and not the other
16:24:07 <benmachine> Twey: I want cake and etc.
16:24:08 <dbro> ok, I can try using 0 and 1 ... brb
16:24:16 <benmachine> that made sense in my head
16:24:21 <Twey> benmachine: PONY NOW!
16:24:24 <benmachine> sense was not subsequently conveyed to keyboard
16:24:28 <Twey> Heh
16:24:28 <FauxFaux> PONY PONY
16:24:29 <benmachine> probably time to go to bed
16:24:33 <benmachine> pony.
16:24:38 <Twey> It's only half past midnight
16:24:44 <Twey> The night is still young
16:24:58 <doserj> dbro: you could define a new class with a division operator that is div for Integrals, and (/) for Fractionals
16:25:17 <Twey> Or you could just use Fractional for your result
16:25:41 <dbro> ok, how do I force the result to divisor to be fractional?
16:25:50 <dbro> or am I on the wrong track?
16:25:56 <temoto> > let average xs = (fst totals) / (snd totals); totals xs = foldr (\x (sum, cnd) -> (sum+x, succ cnt)) (0.0, 0) xs in average [1,2,4]
16:25:57 <lambdabot>   Not in scope: `cnt'
16:26:02 <benmachine> can't everyone just use Ratio
16:26:06 <benmachine> it makes everything lovely
16:26:08 <temoto> > let average xs = (fst totals) / (snd totals); totals xs = foldr (\x (sum, cnt) -> (sum+x, succ cnt)) (0.0, 0) xs in average [1,2,4]
16:26:09 <lambdabot>   Couldn't match expected type `(a, b)'
16:26:10 <lambdabot>         against inferred type `[a1] -...
16:28:05 <Twey> Hmm
16:28:31 <Twey> That's actually a good question.  How *does* one convert an Int/Integer to a Fractional?
16:28:41 <doserj> fromIntegral
16:28:42 <Twey> I guess you should probably just have the inputs be Fractionals to start with
16:28:44 <sm> AlphaColour Double ? how can that be sufficient
16:28:45 <temoto> :t fromIntegral
16:28:46 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:28:50 <Twey> That gives you a Num
16:28:57 <Twey> Not a Fractional, necessarily
16:29:00 <benmachine> Fractional has a Num superclass, doesn't it?
16:29:03 <temoto> isn't Fractional in Num?
16:29:05 <Twey> Oh, I guess that's defined by context.  D'oh.
16:29:10 <benmachine> class (Num a) => Fractional a where
16:29:16 <pikhq> Yes, all Fractionals are Nums.
16:29:19 <temoto> @src Fractional
16:29:19 <lambdabot> class  (Num a) => Fractional a  where
16:29:20 <lambdabot>     (/)             :: a -> a -> a
16:29:20 <lambdabot>     recip           :: a -> a
16:29:20 <lambdabot>     fromRational    :: Rational -> a
16:29:30 <benmachine> all vaguely numerical things are Nums I think
16:29:32 <Twey> average :: (Num a, RealFrac b) => [a] -> b; average = uncurry (/) . join (***) fromIntegral . foldr (\x (sum, len) -> (sum + x, cnt + 1)) (0, 0)
16:29:50 <Twey> > let average :: (Num a, RealFrac b) => [a] -> b; average = uncurry (/) . join (***) fromIntegral . foldr (\x (sum, len) -> (sum + x, cnt + 1)) (0, 0) in average [1, 2, 4, 5]
16:29:51 <lambdabot>   Not in scope: `cnt'
16:29:55 <Twey> Oops
16:29:59 <Twey> > let average :: (Num a, RealFrac b) => [a] -> b; average = uncurry (/) . join (***) fromIntegral . foldr (\x (sum, len) -> (sum + x, len + 1)) (0, 0) in average [1, 2, 4, 5]
16:30:00 <lambdabot>   Could not deduce (GHC.Real.Integral a)
16:30:00 <lambdabot>    from the context (GHC.Num.Num a, ...
16:30:04 <Veinor> > let average xs = (fst $ totals xs) / (snd $  totals xs); totals xs = foldr (\x (sum, cnt) -> (sum+x, succ cnt)) (0.0, 0) xs in average [1,2,4]
16:30:05 <lambdabot>   2.3333333333333335
16:30:14 <Twey> Hum
16:30:18 <doserj> Twey: fromIntegral only works on Integral, not on Num
16:30:22 <Twey> Yeah
16:30:43 <temoto> grapes
16:30:56 <pikhq> @hoogle (Num a, Num b) => a -> b
16:30:56 <lambdabot> Prelude abs :: Num a => a -> a
16:30:57 <lambdabot> Prelude negate :: Num a => a -> a
16:30:57 <lambdabot> Prelude signum :: Num a => a -> a
16:31:05 <benmachine> no such function
16:31:19 <benmachine> apart from unsafeCoerce >_>
16:31:22 <pikhq> There is the more generic unsafeCoerce, though.
16:31:33 <benmachine> fromJust . cast
16:31:38 <Twey> > let average :: Fractional a => [a] -> a; average = uncurry (/) . foldr (flip (***) (+ 1) . (+)) (0, 0) in average [1, 2, 4, 5]
16:31:40 <benmachine> or let f = f in f
16:31:40 <lambdabot>   3.0
16:31:43 <Twey> That'll do it
16:31:47 <benmachine> heh
16:31:55 <temoto> dbro, look up, Veinor and Twey got solution.
16:32:04 <doserj> Twey: that doesn't work for Ints
16:32:13 <Twey> I know
16:32:16 <benmachine> flip (***) (+ 1) == (*** succ)
16:32:27 <Twey> Oh, yeah â€” sections
16:32:38 <Twey> > let average :: Fractional a => [a] -> a; average = uncurry (/) . foldr ((*** succ) . (+)) (0, 0) in average [1, 2, 4, 5]
16:32:39 <lambdabot>   Could not deduce (GHC.Enum.Enum a)
16:32:40 <lambdabot>    from the context (GHC.Real.Fractional...
16:32:44 <Twey> Heh
16:32:45 <benmachine> woo I broke it
16:32:47 <Twey> Apart from type-wise
16:32:52 <Twey> Oh, yeah
16:32:55 <benmachine> ~=
16:32:58 <Twey> Not succ for non-integral types
16:33:15 <pikhq> (***(+1))
16:33:39 <Twey> average :: Fractional a => [a] -> a; average = uncurry (/) . foldr ((*** (+ 1)) . (+)) (0, 0)
16:33:49 <benmachine> what is the Real class for
16:33:53 <benmachine> all you can do is make Rationals with it
16:33:54 <Twey> Real numbers
16:33:57 <temoto> @unpl uncurry (/) . foldr ((*** (+ 1)) . (+)) (0, 0)
16:33:57 <lambdabot> (\ e -> uncurry (/) (foldr (\ h -> ((+) h) *** \ a -> a + 1) (0, 0) e))
16:34:10 <benmachine> which is mathematically hilarious and also a bit pointless
16:34:14 * Twey shudders.
16:34:14 <MissPiggy> kmc_ actually I think it wouldn't work
16:34:23 <Twey> I'm glad that doesn't know about (***) :Ã¾
16:34:46 <doserj> benmachine: not useless. Complex only works with reals
16:34:52 <pikhq> Oh, it knows about it. It's just a bit naive about it.
16:35:04 <benmachine> doserj: Complex requires RealFrac
16:35:11 <benmachine> err
16:35:14 <benmachine> RealFloat
16:35:16 <benmachine> or Floating
16:35:18 <benmachine> or one of those
16:35:20 <doserj> which is a subclass of Real
16:35:21 <dbro> I see that Veinor's suggestion works when pasted directly into ghci, but when I tried to use it in my .hs file and then load the module, I got errors
16:35:25 <benmachine> well yes
16:35:31 <benmachine> but why have the intermediate class?
16:35:36 <benmachine> hmm
16:35:53 <benmachine> why not put toRational into RealFrac
16:36:12 <benmachine> (Complex requires RealFloat)
16:36:48 <benmachine> not sure why Floating wouldn't do
16:36:52 <Dashkal> I noticed earlier someone (Philonous1?) mentioning continuations via monads.  Is there a paper somewhere I can read on that subject?
16:37:19 <benmachine> I'm also interested in reading about the Cont monad
16:37:19 <doserj> benmachine: you may want to work with Complex Integer
16:37:33 <benmachine> doserj: well, you're not allowed to, according to :i Complex
16:37:45 <doserj> true, hm
16:37:53 <benmachine> (note that Complex Integer doesn't have a sensible abs)
16:37:56 <MissPiggy> so yeah need a different approach
16:38:36 <benmachine> I assumed that the reason for RealFloat on Complex was to get sqrt
16:38:40 <benmachine> for modulus
16:38:54 <benmachine> and trigonometry for argument, I suppose
16:39:13 <benmachine> but you only need Floating for those
16:39:46 <dbro> So if understand correctly, it's not possible to have an average function that accepts both integers and floating point numbers?
16:40:01 <benmachine> it's possible to have a type that supports sqrt but not round
16:40:02 <benmachine> whaaat
16:40:10 * benmachine stabs numeric hierarchy in the face
16:41:09 <benmachine> dbro: what type would you like the function to have, exactly?
16:41:28 <benmachine> dbro: I suspect you understand correctly but it's easier to answer questions about types
16:41:48 <dbro> I would like it to accept Int and Double, and it could either produce the same as output, or always produce Double
16:42:10 <dbro> I could define one version for Int and another for Double ?
16:42:10 <benmachine> if you want to accept both Int and Double, your function needs a typeclass that contains both
16:42:21 <benmachine> that can only be Num, and you can't divide Nums in general
16:42:23 <dbro> ok, like Num
16:42:39 <benmachine> what I suggest is
16:42:50 <benmachine> make an average function that works on Rational
16:42:58 <dbro> is there a way to interrogate the input to find out if it's an Int or a Double, then perform the appropriate version?
16:42:59 <benmachine> and then convert your integers on the way in
16:43:01 <benmachine> with fromIntegral
16:43:06 <Twey> dbro: There's probably some way, but it's easier to handle conversion in calling code, where you know what type your data has
16:43:08 <benmachine> you can do that with a typeclass
16:43:13 <benmachine> but it's overkill imo
16:43:14 <doserj> <doserj> dbro: you could define a new class with a division operator that is div for Integrals, and (/) for Fractionals
16:43:21 <benmachine> a few fromIntegrals wouldn't hurt
16:43:25 <benmachine> doserj: that's not how I'd do it
16:43:50 <benmachine> I would define a class that had a conversion function which was identity on rationals and fromIntegral on Integrals
16:44:03 <benmachine> and then convert at the beginning of your average function
16:44:13 <benmachine> but in general it's better to just convert at the call site
16:44:18 <benmachine> imo
16:44:56 <doserj> benmachine: your version always returns fractionals, my version returns the input type. What is better depends
16:44:58 <dbro> what I'm trying to do in the big picture is be able to work in a system that has poor floating point performance. I want to be able to use the same code for fixed point and floating point parts of the program
16:45:05 <benmachine> oh hey wait
16:45:10 <MissPiggy> How  can I parse a language that has functions like haskell e.g.  f x y z,  and also infix operators?  (but that's all)
16:45:23 <benmachine> doserj: true, but your version doesn't calculate the average, sometimes :P
16:45:23 <MissPiggy> buildExpressionParser in parsec doesn't work
16:45:26 <benmachine> well
16:45:31 <benmachine> I suppose it does as best it can
16:45:55 <benmachine> dbro: oh, listen to doserj then
16:46:17 <dbro> ok thanks everyone
16:46:18 <benmachine> I'm not sure how fast Rationals are by comparison to other types
16:46:27 <benmachine> erm
16:46:33 <benmachine> I was wrong about Num being your only option
16:46:37 <benmachine> you could use Real
16:46:40 <benmachine> and toRational
16:47:02 <benmachine> but then as doserj said you get a different type out than you put in
16:47:19 <benmachine> but that's inevitable if you want to take the average of integer 2 and 3
16:47:24 <benmachine> unless you want to get 2
16:47:44 <benmachine> in which case typeclass your heart out
16:47:49 <benmachine> I'm going to bed either way
16:47:54 <dbro> good night
16:47:59 <kmc_> if you wanted truncating division on integral types and real division on floating types
16:48:03 <kmc_> you'd have to write your own class, yes?
16:48:09 <kmc_> with two (undecidable) instances
16:48:53 <MissPiggy> :(
16:48:58 <MissPiggy> I wanted to succeed at this
16:49:00 <dbro> seems that way
16:49:05 <kmc_> ah yeah you said that a while ago doserj
16:49:56 <dbro> I thought I might be able to do it with a type instead of a class -- ?
16:50:50 <MissPiggy> > (id . id)(3)
16:50:51 <lambdabot>   3
16:52:08 <sm> is there a standard portable haskell lib providing a cube root function ?
16:52:11 <kmc_> data MyNum = MyInt Int | MyFloat Float
16:52:13 <kmc_> you could then average these
16:52:24 <dbro> yeah
16:53:17 <doserj> sm: (**(1/3))
16:53:26 <sm> oh wow
16:53:34 <sm> doserj: your math fu is stronger
16:53:48 <kmc_> > (**(1/3))
16:53:49 <lambdabot>   -0.375->
16:53:49 <lambdabot>    NaN
16:53:49 <lambdabot>  -0.75->
16:53:49 <lambdabot>    NaN
16:53:49 <lambdabot>  -1.5->
16:53:51 <lambdabot> [5 @more lines]
16:53:54 <kmc_> ^^ table of cube roots
16:54:06 <sm> thanks
16:54:13 <doserj> and a useful one!
16:54:20 <kmc_> > let x = 0/0.0 in x == x
16:54:21 <lambdabot>   False
16:54:41 <kmc_> screw reflexivity ;P
16:55:07 <Draconx|Laptop> kmc_, the Ord instance for Double is way, way worse than the Eq instance.
16:55:33 <Draconx|Laptop> things like Data.Map.insert with Double keys can remove elements from your map.
16:57:08 <Twey> Wha'.
16:57:38 <kniu> yo
16:57:52 <kniu> what's that program that lambdabot uses to execute Haskell code called?
16:58:03 <luite> mueval
16:58:16 <kniu> thanks.
16:59:06 <doserj> > let nan = (0/0.0) in (compare nan nan, nan > nan)
16:59:07 <lambdabot>   (GT,False)
16:59:14 <kniu> cabal seems to not be able to install haskell-src
16:59:42 <kniu> says it needs happy,
16:59:48 <kniu> but I have happy installed
16:59:53 <kniu> what gives?
16:59:54 <Draconx|Laptop> > let nan = 0/0 in round nan
16:59:55 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
17:00:14 <Draconx|Laptop> > let nan = 0/0 in realToFrac nan :: Float
17:00:15 <lambdabot>   -Infinity
17:00:45 <sshc> why doesn't a typeclass exist for types that behave like lists (lists, bytestrings, etc.)?
17:00:56 <Draconx|Laptop> sshc, Data.Traversable
17:01:07 <sshc> so it already does exist?
17:01:10 <pikhq> @src Data.Traversable
17:01:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:01:18 <pikhq> @src Traversable
17:01:18 <lambdabot> class (Functor t, Foldable t) => Traversable t where
17:01:18 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
17:01:18 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
17:01:18 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
17:01:18 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
17:01:37 <Philonous1> sshc: Depends on what aspects of a list you want
17:02:26 <sshc> Philonous1: the fact that most of list's functions are copied and used on bytestrings is good evidence that a type class is necessary I think
17:03:01 <pikhq> sshc: Depends on the aspects you want, of course.
17:03:18 <pikhq> Indexing? head/tail? Functor/Applicative/Monad?
17:03:50 <Philonous1> sshc: Well, there are some type classes that model list-like behaviour. Monoid, Functor, Pointed, Foldable, Traversable, Applicative, Monad.
17:05:56 <Philonous1> You probably want Monoid (for empty list and concatenation), Pointed (singletons) and Foldable
17:06:34 <doserj> Philonous1: most of these do not apply to bytestrings (kind mismatch)
17:14:38 <Philonous1> Hmm. class Foldable' m a | m -> a where ... instance Foldable m => Foldable' (m a) a where ...
17:15:53 <balboa02> Any tips for building a (column position) based tree with parsec? I'm having a hell of a time
17:17:27 <solrize> @where writer
17:17:27 <lambdabot> I know nothing about writer.
17:17:33 <solrize> @where Writer
17:17:33 <lambdabot> I know nothing about writer.
17:18:12 <DekuNut> What were those types called again that were typeless? Like
17:18:17 <DekuNut> data Box = Box a
17:18:23 <solrize> existential ?
17:18:27 <Philonous1> Ground types?
17:18:27 <DekuNut> That's it, thanks
17:18:29 <sshc> how do I expose a model in a cabal package?
17:18:29 <solrize> data Box = forall a. Box a
17:18:32 <DekuNut> Existential types
17:18:40 <sshc> I can't find any documnetation for the .cabal file
17:30:48 <solrize> @where Control.Monad.Writer
17:30:48 <lambdabot> I know nothing about control.monad.writer.
17:35:36 <solrize> the docs for a lot of the ghc libraries have gone away, i guess because those modules are migrating to the platform
17:39:39 <micahj> I need help with cabal
17:40:06 <micahj> I deleted .cabal and then nothing in ghc worked, becuase it didn't have stuff like parse
17:40:07 <micahj> c
17:40:17 <micahj> and then
17:40:25 <micahj> I got ghc 6.12
17:40:42 <micahj> and now it just says it can't even parse ghc-pkg dump
17:46:10 <Alpounet> kamatsu, gwt, wave and gae actually are quite impressive...
17:47:33 <micahj> can anyone help me with cabal? :(
17:48:00 <Alpounet> micahj, did you do a cabal update, then cabal install parsec
17:48:01 <Alpounet> and so on
17:48:20 <micahj> I did but it didn't work
17:48:28 <micahj> things that needed parsec still wouldn't build
17:48:40 <Alpounet> which version of parsec are you trying to install ?
17:48:42 <micahj> I uninstalled as much as I could of the haskell platform
17:48:47 <Alpounet> and, most importantly, which one is needed ?
17:48:55 <micahj> well 2.x should work
17:49:01 <micahj> I don't think I need 3
17:49:26 <Alpounet> then
17:49:35 <Alpounet> explicitly ask for parsec-2.something
17:49:56 <micahj> well every base package was gone
17:50:00 <micahj> so I tried to install base
17:50:05 <micahj> so it needed integer-simple
17:50:06 <Alpounet> and ?
17:50:11 <micahj> so I needed ghc 6.12
17:50:19 <micahj> so then cabal wouldn't work anymore with 6.12
17:50:32 <dbro> I'm trying to create a data type to allow division to work for either ints or floats, and getting an error. Here is the definition of the type:
17:50:33 <dbro> data ValueType = ValueInt Int | ValueDouble Double
17:50:47 <dbro> and then the divide function:
17:50:48 <dbro> divideVT :: ValueType -> ValueType -> ValueType
17:50:53 <micahj> why not a typeclass?
17:50:55 <dbro> divideVT (ValueInt x) (ValueInt y) = x `div` y
17:51:09 <dbro> honest answer: because I'm not sure how it should be done
17:51:10 <kniu> > randomIO
17:51:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:51:11 <lambdabot>    `System.Random.Random a'...
17:51:19 <kniu> > randomIO :: Int
17:51:20 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:51:20 <lambdabot>         against inferred type ...
17:51:23 <micahj> > unsafePerformIO
17:51:24 <lambdabot>   Not in scope: `unsafePerformIO'
17:52:02 <dbro> and then the error is: Couldn't match expected type `ValueType'           against inferred type `Int'
17:52:19 <A1kmm> Does anyone know why the parsec parser (do { c <- anyChar; i <- getInput; return (c, i) }) on a lazy input where only one character is available causes the program to block?
17:52:30 <A1kmm> (when c is retrieved)
17:52:44 <mreh> why would an array act in a non constant time fashion, I am very confused by this
17:52:49 <smorg> The "coming soon" section of lyah is a nice list of the top things I wish I understood about Haskell.
17:53:02 <dbro> how would a typeclass take care of this kind of polymorphic division?
17:53:30 <Draconx|Laptop> dbro, x `div` y returns an Int, but you have declared divideVT to return a ValueType.
17:53:58 <dbro> yes... I thought that would be OK, because one of the ValueType's is an Int
17:54:33 <Draconx|Laptop> dbro, you need to put the word ValueInt or ValueDouble somewhere if you want to construct a ValueType.
17:54:45 <dbro> ahhh
17:56:08 <dbro> Draconx: gracias!
17:56:58 <drdr> anyone have any idea on what i should try to do in haskell to improve my haskell skillz
17:57:23 <micahj> try writing something awesome in it
17:57:38 <micahj> like a parser, or a website, or some such thing
17:58:02 <smorg> write a compiler compiler.
17:58:41 <drdr> how about a ircd?
17:58:53 <micahj> where do I get the cabal that works with ghc 6.12
17:59:10 <drdr> wait what?
17:59:13 <nolrai_FG> Are there any good code review checklists for haskell?
18:00:51 <micahj> join ##paws
18:01:11 <micahj> oops
18:01:14 <micahj> meant to have a slash there xD
18:01:52 <tensorpudding> i thought cabal came with ghc nowadays
18:02:04 <tensorpudding> cabal-install doesn't
18:02:08 <micahj> oh ok
18:02:33 <tensorpudding> cabal-install is the app that fetches packages from the command line
18:02:59 <tensorpudding> it's available on hackage
18:03:36 <micahj> aight
18:03:41 <micahj> thank you :)
18:05:48 <cads> Do we have haskell bindings for a UI toolkit as neato-burrito looking as http://libagar.org/ ?     (screenies here http://libagar.org/screenshots.html.en )
18:06:16 <cads> a friend of mine asked me about how we do UI programming, and I'd like to show him some examples
18:06:52 <tensorpudding> there are gtk bindings
18:07:06 <Alpounet> and Qt
18:07:18 <drdr> shit thats a nice gui kit
18:07:50 <tensorpudding> not a fan of the theming
18:09:56 <cads> It seems pretty retro to me, reminds me of the old 3dsmax interface back when it was DOS-based :)
18:17:33 <zzt> DCC SEND jsofsjfsaogsjgsoghoamwrgai 0 0 0
18:19:00 <Dashkal> I see a few people need to upgrade router firmware...
18:19:48 <Dashkal> Wait, was that from a ipv6 address?
18:23:28 <dbro> what am I doing wrong with this type definition? I want it to be an instance of the Num typeclass...
18:23:29 <dbro> data ValueType      = ValueInt      Integer
18:23:29 <dbro>                     | ValueDouble   Double
18:23:29 <dbro>                     deriving (Show, Eq, Ord)
18:23:29 <dbro> instance Num ValueType where
18:23:29 <dbro>     fromInteger (ValueInt x)    = fromInteger x
18:23:31 <dbro>     fromInteger (ValueDouble x) = x
18:24:01 <dbro> I get this error:
18:24:02 <dbro>     Couldn't match expected type `Integer'
18:24:02 <dbro>            against inferred type `ValueType'
18:24:02 <dbro>     In the pattern: ValueInt x
18:24:22 <micahj> becuase fromInteger must take an Int, no?
18:24:30 <micahj> or wait
18:24:39 <micahj> that's probably wrong
18:24:54 <dbro> I was using Int instead of Integer before... same error
18:25:01 <micahj> eyah meant Integer
18:25:03 <micahj> but I may be wrong
18:25:11 <micahj> because that wouldn't really make sense
18:25:31 <doserj> fromInteger i = ValueInt (fromInteger i)
18:27:02 <dbro> ok I'll try that...
18:27:10 <idnar> @type fromInteger
18:27:11 <lambdabot> forall a. (Num a) => Integer -> a
18:27:17 <micahj> ah yes I gett it
18:27:20 <idnar> maybe you're thinking of fromIntegral?
18:27:38 <micahj> yeah fromInteger has to take an integer and return your type
18:28:36 <dbro> that silenced the errors - I'll check it out and see how it works. thanks!
18:29:36 <Hunner> What's a way to represent a 2D map?
18:31:08 <dbro> doserj, micahj - yes, it looks good.
18:35:10 <micahj> how can I completely remove all traces of the haskell platform
18:35:58 <c_wraith> depends on how it was installed
18:36:05 <c_wraith> was it just a user install?
18:36:18 <micahj> I just used the install wizard thing
18:36:19 <micahj> I'm on mac
18:36:31 <c_wraith> Oh.  Hmm.  Does it provide an uninstaller?
18:36:35 <micahj> no
18:36:36 <micahj> ghc does though
18:36:59 <chrisf> i thought the big claim to awesomeness on a mac was you just deleted the application bundle, and it's gone
18:37:05 <micahj> yeah
18:37:09 <c_wraith> yeah, that's not true at all
18:37:09 <micahj> but  think it left some other stuff too
18:37:18 <micahj> becuase it's not just a .app
18:37:22 <chrisf> are you saying that's not true? damn.
18:37:26 <c_wraith> at the very least, be aware of ~/.ghc and ~/.cabal
18:37:27 <micahj> for most apps
18:37:29 <micahj> it's completely ture
18:37:30 <micahj> true*
18:37:37 <micahj> you just drap the .app (which is a folder) into Applications
18:37:43 <micahj> and then you can delete it anytime
18:37:52 <chrisf> i'd prefer to believe that Steve was bullshitting us again, actually.
18:38:05 <chrisf> ;)
18:38:08 <micahj> well 99% of the time it's true :P
18:38:12 <micahj> just not for haskell platform-like things
18:38:13 <tomoj> don't many apps leave preferences/application support stuff behind?
18:38:18 <micahj> no
18:38:23 <micahj> becuase the .app has it inside it
18:38:26 <micahj> I think...
18:38:42 <chrisf> old mac os definitely did, no matter how hard they tried to convince people otherwise..
18:39:29 <tomoj> certainly less than 99% of my apps contain everything in the .app
18:39:43 <tomoj> bunch of plists in Preferences for example
18:39:52 <micahj> oh ok
18:40:11 <tomoj> but looks like less than "many" maybe
18:40:43 <micahj> well most uninstallers on windwos leave crap behind too
18:40:55 <micahj> deleting the .app basically removes all that uninstallers do
18:41:01 <micahj> :P
18:41:21 <syntaxglitch> since when does anyone uninstall applications on Windows?
18:41:41 <chrisf> you just accumulate crap until it goes critical, then blow away the OS image and start fresh :P
18:41:43 <syntaxglitch> I thought it was basically just keep installing stuff, then reformat the computer every year or two when it gets too crudded up and unstable :P
18:42:45 <chrisf> ok, so generically (OO considerations aside): we want to do a list of stuff each frame, right?
18:42:52 <chrisf> argh, sorry guys, wrong window.
18:50:09 * hackagebot upload: graphics-drawingcombinators 1.1.1 - A functional interface to 2D drawing in OpenGL (LukePalmer)
18:50:23 * adu <3 GL
18:56:50 <chessguy> so...i was just looking at this ruby problem, and i'm curious how you guys would solve it in haskell. doesn't seem like there's any real clean way. http://github.com/edgecase/ruby_koans/blob/master/koans/about_scoring_project.rb
19:03:28 <micahj> hmm, yeah
19:03:36 <micahj> can't think of a functional way right off the bat
19:03:59 <micahj> list comprehension of some kind perhaps?
19:05:08 <augustss> assuming the score is in a list, you do (group . sort) and then check for a few things in the resulting list
19:05:51 <augustss> should be a line or two
19:07:06 <micahj> nice
19:07:41 <augustss> I'll leave the details to someone who cares. :)
19:07:48 <chessguy> charming :)
19:10:54 <copumpkin> chessguy is back!
19:10:58 <lpjhjdh> @hoogle (a -> b, c -> d) -> (a,c) -> (b,d)
19:10:58 <lambdabot> No results found
19:11:01 <chessguy> back?
19:11:11 <copumpkin> chessguy: I haven't seen you around in a while, dunno :)
19:11:14 <copumpkin> maybe we just missed each other
19:11:14 <chessguy> oh
19:11:26 <chessguy> well i haven't really been gone, gone, just....not here a lot
19:11:29 <augustss> @djinn (a -> b, c -> d) -> (a,c) -> (b,d)
19:11:29 <lambdabot> f (a, b) (c, d) = (a c, b d)
19:11:42 <copumpkin> lpjhjdh: uncurry it and you have ***
19:11:43 <augustss> @pl f (a, b) (c, d) = (a c, b d)
19:11:43 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
19:11:54 <copumpkin> :t curry (***)
19:11:55 <lambdabot>     No instance for (Arrow (,))
19:11:55 <lambdabot>       arising from a use of `***' at <interactive>:1:6-10
19:11:55 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
19:11:59 <copumpkin> meh, I fail
19:12:05 <lpjhjdh> >< from pointless :)
19:12:05 <copumpkin> :t uncurry (***)
19:12:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
19:12:25 <xle> is there a way to get ghc to clean up the .hi and .o files after --make?
19:12:57 <kamatsu> xle: no, but if you use cabal to build stuff it can clean it up
19:13:10 <kamatsu> afaik, ghc doesn't have that functionality
19:13:25 <xle> kamatsu: I see.. thanks
19:13:35 <chessguy> augustss:  i like your idea. still seems like at least 3 or 4 lines though
19:14:05 <augustss> I use long lines
19:14:19 <chessguy> lol
19:16:20 <micahj> kamatsu, are you on the spheredev forums?
19:17:19 <kamatsu> micahj: yes?
19:17:23 <kamatsu> micahj: this is a suprise
19:17:26 <micahj> heh
19:17:28 <micahj> I'm miky
19:17:33 <kamatsu> miky.. hm
19:17:36 <micahj> the stupid guy that you had an argument with
19:17:38 <kamatsu> don't recal
19:17:39 <micahj> in my intro topic
19:17:43 <micahj> I'm much less stupid now
19:17:43 <micahj> :P
19:17:49 <kamatsu> hah
19:17:51 <kamatsu> let me find you
19:17:55 <dbro> I'm struggling with a simple typeclass definition. When I try to sum a list of them, I get no response- ghci just hangs and I need to press ctrl-c
19:17:57 <dbro> data ValueType      = ValueInt      Int
19:17:57 <dbro>                     | ValueDouble   Double
19:17:57 <dbro>                     deriving (Show, Eq, Ord)
19:17:57 <dbro> instance Num ValueType where
19:17:57 <dbro>     (+) = (+)
19:17:59 <dbro>     (*) = (*)
19:18:01 <dbro>     signum = signum
19:18:03 <dbro>     abs = abs
19:18:05 <dbro>     fromInteger = ValueDouble . fromInteger
19:18:07 <dbro> sum3 :: [ValueType] -> ValueType
19:18:09 <dbro> sum3 = foldr1 (\x acc -> x+acc)
19:18:14 <copumpkin> 600 people need to see this code!
19:18:18 <kamatsu> micahj: of course, haskell users are smarter than anyone else :P
19:18:25 <micahj> heh
19:18:36 <dbro> copumpkin - sorry, if there's a better way, I'm happy to oblige
19:18:42 <copumpkin> @hpaste
19:18:42 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:18:45 <dbro> thanks
19:18:57 <DigitalKiwi> codepad > hpaste
19:19:06 <kamatsu> micahj-away: oh, you were the python guy
19:19:28 <DigitalKiwi> codepad can run code =D
19:19:57 <copumpkin> do you need it to get run?
19:19:58 <dbro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6580#a6580
19:20:04 <monochrom> dbro: (+)=(+) is a great way to get an infinite loop doing nothing.
19:20:33 <dbro> ah ok. then what should it be?
19:20:53 <copumpkin> liftA2 (+)
19:21:04 <copumpkin> where liftA2 is your special fake applicative version
19:21:06 <monochrom> It should be as per how you would like ValueType's added.
19:21:35 <dbro> oh. now I'm confused. I'm trying to make ValueType a type, not a typeclass -?
19:21:41 <monochrom> Perhaps you want all pairs of ValueType's to sum up to 0, I don't know, it's your call.
19:22:17 <monochrom> ValueType is already a type the moment you write "data ValueType = "
19:22:22 <dmwit> > let scoreSingle count threes nonthrees = (count `div` 3) * threes + (count `mod` 3) * nonthrees; scores = [(1, (1000, 100)), (5, (500, 50))] ++ [(n, (n * 100, 0)) | n <- [2,3,4,6]]; scoreCount n m = uncurry (scoreSingle n) (fromJust (lookup m scores)); score = sum . map (\xs -> scoreCount (length xs) (head xs)) . group . sort in score [1,1,1,5,1]
19:22:23 <lambdabot>   1150
19:22:26 <dbro> I'm just trying to get the ValueType to be an instance of Num - how should I do that?
19:22:34 <dmwit> chessguy: What do I win?
19:22:36 <kamatsu> dbro: instance Num ValueType ?
19:22:44 <lpjhjdh> something like this for the dice problem?  sum . map (\l -> uncurry (+) $ ((*) 100, (*) (getVal $ head l)) >< (length l `divMod` 3)) . group . sort
19:22:45 <copumpkin> dbro: presumably you want it to do something specific when it behaves like a num?
19:22:52 <copumpkin> dbro: I guess you want to add the numeric values within?
19:22:55 <monochrom> kamatsu: Already done that. It now has a line (+)=(+)
19:23:03 <lpjhjdh> oh, what's the rule for scoring sets of three?
19:23:06 <dbro> nothing special, really - just add like normal Ints or Doubles would
19:23:10 <dbro> yes
19:23:15 <copumpkin> dbro: it can't read your mind :)
19:23:19 <chessguy> dmwit:  a smile and congratulations?
19:23:21 <dbro> that's the problem!
19:23:23 <copumpkin> (unless you only had one constructor and used a newtype)
19:23:27 <dmwit> chessguy: gogogo!
19:23:57 <dbro> but with two constructors, how would that look?
19:24:12 <monochrom> Would look like 4 cases.
19:24:46 <monochrom> Must you make ValueType an instance of Num?
19:24:51 * dmwit is having trouble collecting his winnings
19:24:53 <dmwit> ;-)
19:24:58 <dbro> I'd like to average them, so ... yes?
19:25:01 * copumpkin hands dmwit a wad of cash
19:25:07 <copumpkin> dbro: average? :O
19:25:07 <dmwit> whoa!
19:25:10 <dmwit> =D
19:25:15 <dbro> yes... ?
19:25:16 <monochrom> So you must define how to add them.
19:25:25 <dbro> right,
19:25:37 <dbro> forgive me for appearing stupid- how would that look?
19:25:46 <copumpkin> dbro: so ValueInt 5 + ValueDouble 10 should be ValueDouble 7.5?
19:25:50 * DigitalKiwi takes pics, plants drugs on copumpkin, and calls the cops
19:25:54 <monochrom> Must ValueType have two constructors?
19:26:13 <dbro> no, sorry- I have a different function that performs the average. for that to work, I need + to work
19:26:18 <copumpkin> oh
19:26:29 <chessguy> @type groupBy
19:26:30 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:26:32 <dbro> I've already defined a special divisor that can handle the int/double switching
19:26:40 <chessguy> @src groupBy
19:26:41 <lambdabot> groupBy _  []       =  []
19:26:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:26:41 <lambdabot>     where (ys,zs) = span (eq x) xs
19:27:35 <dbro> I can't figure out how to express the different cases. guards??
19:27:45 <dmwit> Why not pattern matching?
19:28:01 <dbro> sounds good. what would that look like?
19:28:13 <monochrom> pattern matching.  ValueInt x + ValueDouble y = more stuff
19:28:15 <augustss> chessguy: OK, it's 4 lines if you don't cram them all together :)
19:28:47 <dbro> ok, I'll give that a go. brb
19:28:52 <monochrom> "augustss uses long lines"
19:28:56 <chessguy> augustss:  nice
19:29:36 <augustss> score = sum . map sc . map (head &&& (`divMod` 3) . length) . group . sort
19:29:37 <chessguy> ruby doesn't seem to have a groupBy equivalent
19:30:06 <augustss> and then 3 lines of sc
19:30:13 <monochrom> I haven't seen anyone else having a groupBy equivalent.
19:31:12 <chessguy> @type map (head &&& (`divMod` 3) . length))
19:31:13 <lambdabot> parse error on input `)'
19:31:28 <augustss> As far as I know, I introduced the group and groupBy functions to FP.  But they had undoubtedly been invented before.
19:31:29 <monochrom> delete one )
19:31:35 <chessguy> @type map (head &&& (`divMod` 3).length)
19:31:36 <lambdabot> forall a. [[a]] -> [(a, (Int, Int))]
19:31:58 <DigitalKiwi> who is augustss ?
19:33:11 <dbro> monochrom: thanks! and thanks for being patient with my ignorance
19:33:12 <DigitalKiwi> http://en.wikipedia.org/wiki/Lennart_Augustsson you?
19:33:39 <augustss> that's me
19:33:42 <DigitalKiwi> hmm
19:34:02 <chessguy> map (head &&& (`divMod` 3) . length) [1,1,2,3,3,3,3,3,3,4,4]
19:34:08 <DigitalKiwi> Augustsson has written three winning entries in the International Obfuscated C Code Contest:
19:34:16 <DigitalKiwi> I lawled
19:34:26 <chessguy> > map (head &&& (`divMod` 3) . length) [1,1,2,3,3,3,3,3,3,4,4]
19:34:27 <lambdabot>   No instance for (GHC.Num.Num [a])
19:34:27 <lambdabot>    arising from the literal `1' at <inter...
19:34:48 <copumpkin> DigitalKiwi: omg stalk0r
19:34:54 <augustss> > map (head &&& (`divMod` 3) . length) $ group [1,1,2,3,3,3,3,3,3,4,4]
19:34:55 <lambdabot>   [(1,(0,2)),(2,(0,1)),(3,(2,0)),(4,(0,2))]
19:34:56 <chessguy> > map (head &&& (`divMod` 3) . length) $ group [1,1,2,3,3,3,3,3,3,4,4]
19:34:57 <lambdabot>   [(1,(0,2)),(2,(0,1)),(3,(2,0)),(4,(0,2))]
19:35:22 <augustss> C is an excellent language!
19:35:22 <DigitalKiwi> copumpkin: i'm only stalking him if i get his number from his facebook before i meet him
19:35:22 * copumpkin wants a wikipedia page too! oh the fame, the glory
19:35:41 * Veinor has a wikipedia userpage!
19:35:43 <chessguy> huh. i don't get those numbers
19:35:44 <augustss> copumpkin: anyone can edit wikipedia
19:35:48 <Veinor> except, it only redirects to my talkpage
19:35:50 <djahandarie> copumpkin, you can get one but it'll be deleted moments later
19:36:03 <copumpkin> :(
19:36:09 <copumpkin> make me notable dammit
19:36:10 <chessguy> oh! yes i do
19:36:16 <Veinor> I vaguely feel like the iPhone dev team is notable.
19:36:26 <copumpkin> yeah, the team has a page
19:36:28 <pikhq> augustss: I'm not going to argue that -- it's one of a minority of languages that has a simple design goal, and does it simply and well.
19:36:29 <copumpkin> or had, dunno if it still does
19:36:33 <Veinor> you could get a redirect then :P
19:36:44 <monochrom> If you found a new religion for profit, you get a wikipedia page too.
19:36:45 <copumpkin> lol
19:36:55 <Veinor> also, the page is there still
19:37:07 <pikhq> Also, nice work on the obfuscated C.
19:37:27 <copumpkin> well, I guess I'll live with my indirect notability, despite not being mentioned there
19:37:27 <augustss> It's hard work
19:38:00 <augustss> copumpkin: you're on the iPhone dev team?
19:38:15 <copumpkin> I'm its most inactive member
19:38:24 <copumpkin> but yeah, technically :P and I used to be useful
19:38:29 <DigitalKiwi> wikipedia mods are mean :(
19:38:33 <augustss> It's such an amazing product
19:38:35 <pikhq> Believe me, I know; I've tried my hand at it a few times...
19:38:39 <Veinor> DigitalKiwi: :(
19:38:40 <DigitalKiwi> they're all on power trips
19:38:44 <copumpkin> augustss: oh, not _that_ dev team ;)
19:38:51 <copumpkin> I'm on the nefarious one ;)
19:39:04 <pikhq> Here's the one that's easiest to paste into IRC:
19:39:05 <pikhq> a,b,c;main(z,i)char**i;{h:a=!a,b=!b;g:(b-1)[1[i]]>b[i[1]]?a^=a,c=(b-1)[1[i]],1[i][b-1]=i[1][b],b[i[1]]=c,b=&b[(void*)1]:(b=&b[(void*)1]),!b[i[1]]?:({goto g;}),a?:({goto h;}),b=!b;j:putchar(b[1[i]])[(void*)(b=&b[(void*)1])],1[i][b]?({goto j;}):putchar('\n');}
19:39:06 <augustss> oh, well, here i was gonna ask for new features
19:39:12 <pikhq> (requires GNU C)
19:39:22 <DigitalKiwi> nefarious?
19:39:34 <Alpounet> @pl \x -> f (g x) x
19:39:34 <lambdabot> f =<< g
19:39:42 <copumpkin> I mean deeply noble
19:39:42 <Alpounet> hey I'm not in a monad
19:39:54 <Veinor> DigitalKiwi: not all of them are on power trips
19:39:54 <Alpounet> (for once)
19:39:55 <monochrom> everyone is in a mond
19:39:59 <micahj> kamatsu: I don't think I was the python guy
19:40:01 <Veinor> I'd liek to think that I'm one of the good ones D:
19:40:04 <augustss> We're all in a monad
19:40:08 <Alpounet> noooooooooo
19:40:11 <copumpkin> the inescapable reality monad?
19:40:20 <Veinor> we're all stuck in the IO monad
19:40:21 <cp2> you're a monad
19:40:22 <DigitalKiwi> Veinor: ok enough to make it a hellhole
19:40:24 <Alpounet> unsafePerformReality
19:40:30 <copumpkin> DreamT Reality
19:40:33 <augustss> is it unsafe?
19:40:35 <monochrom> the inescapable r-> monad
19:41:21 * copumpkin wants arbitrary type-level functions so he can have an -> r monad
19:42:12 <chessguy> The Monad is everywhere. It is all around us. Even now, in this very (chat) room. You can see it when you look out your window or when you turn on your television. You can feel it when you go to work... when you go to church... when you pay your taxes. It is the world that has been pulled over your eyes to blind you from the side effects
19:42:31 <monochrom> take the blue pill to enlarge your gonad
19:42:58 <copumpkin> EnglargeT ?
19:43:01 <copumpkin> -g
19:43:38 <ddarius> copumpkin: (-> r) isn't even a (covariant) functor.
19:43:45 <copumpkin> ddarius: it's a contravariant one!
19:44:01 <copumpkin> I can live with that
19:44:10 <ddarius> copumpkin: Indeed, but that means it isn't and endofunctor and thus isn't a monad.
19:44:33 <micahj> can anyone quickly explain to me all this endofunctor and functor and fucntoid and monoidad and stuff
19:44:35 <micahj> :P
19:44:49 <copumpkin> micahj: you serious?
19:44:49 <micahj> and contravariant
19:44:57 <copumpkin> ddarius: boo, damn rules
19:45:04 <micahj> well at least where can I find out about it
19:45:24 <copumpkin> micahj: I thought you were just mocking our mathtalk :P
19:45:34 <chessguy> @src group
19:45:34 <lambdabot> group = groupBy (==)
19:45:41 <copumpkin> contravariant means it maps something "backwards" :P
19:45:52 <micahj> example?
19:45:58 <micahj> don't really get what you mean
19:46:00 <copumpkin> have you come across fmap?
19:46:04 <micahj> no
19:46:08 <micahj> I know map :P
19:46:11 <copumpkin> have you come across map?
19:46:13 <copumpkin> ok
19:46:39 <copumpkin> think about how you would generalize map
19:46:50 <copumpkin> for example, could you see yourself mapping a function to Maybe?
19:47:04 <copumpkin> :t map
19:47:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:47:07 <micahj> sort of
19:47:30 <augustss> Maybe is like a list with zero or one element
19:47:38 <micahj> oh ok
19:47:41 <copumpkin> :t let map f (Just x) = Just (f x); map f Nothing = Nothing in map
19:47:42 <lambdabot> forall t a. (t -> a) -> Maybe t -> Maybe a
19:47:57 <copumpkin> micahj: look good?
19:48:10 <micahj> aha
19:48:11 <micahj> ok
19:48:12 <micahj> yeah
19:48:28 <copumpkin> okay, so Functor is something that is "mappable" in a similar manner
19:48:36 <copumpkin> Maybe and [] are instances of it
19:48:46 <micahj> ok
19:48:50 <copumpkin> fmap is the generalized map function
19:48:55 <copumpkin> > fmap (+1) (Just 5)
19:48:56 <micahj> ah
19:48:56 <lambdabot>   Just 6
19:49:09 <micahj> > fmap (+3) Nothing
19:49:10 <lambdabot>   Nothing
19:49:14 <micahj> :D
19:49:16 <DarthArachides> @type fmap
19:49:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:49:21 <copumpkin> :)
19:49:39 <chrisf> @type Functor
19:49:40 <lambdabot> Not in scope: data constructor `Functor'
19:49:46 <copumpkin> :k Functor
19:49:47 <lambdabot> Class `Functor' used as a type
19:49:56 <copumpkin> it should have a kind :)
19:50:05 <drhodes> :i Functor
19:50:12 <copumpkin> :i does nothing
19:50:15 <drhodes> nuthin
19:50:29 <DarthArachides> ?instances Functor Maybe
19:50:30 <kamatsu> @pl spawnListener c ch = spawnThread () (listener c ch)
19:50:30 <lambdabot> Couldn't find class `Functor Maybe'. Try @instances-importing
19:50:30 <lambdabot> (line 1, column 36):
19:50:30 <lambdabot> unexpected " "
19:50:30 <lambdabot> expecting variable, "(", operator or end of input
19:50:42 <copumpkin> micahj: so fmap :: (a -> b) -> (f a -> f b)
19:50:44 <kamatsu> @pl spawnListener c ch = spawnThread () (listener c ch)
19:50:44 <lambdabot> (line 1, column 36):
19:50:44 <lambdabot> unexpected " "
19:50:44 <lambdabot> expecting variable, "(", operator or end of input
19:51:04 <micahj> ok
19:51:26 <copumpkin> micahj: we sometimes call that "lifting" a function into a functor
19:51:36 <micahj> bbiab
19:51:38 <kamatsu> @pl spawnListener c ch = spawnThread (listener c ch)
19:51:39 <lambdabot> spawnListener = (spawnThread .) . listener
19:51:41 <micahj> thanks so far :)
19:51:53 <copumpkin> :)
19:53:08 <dpratt711> 76uyyyyyyyyyyyyyyyyyyyyy'/vb90
19:53:08 <dpratt711> (^^9
19:55:27 <micahj> sorry, I g2g for today
19:55:30 <micahj> thanks though copumpkin
19:55:31 <micahj> :D
19:56:58 <DigitalKiwi> i hate tall people
19:57:20 <DigitalKiwi> always getting in the way of us less vertically endowed people
19:57:51 <Alpounet> his nickname might be ironic
19:58:41 <DigitalKiwi> lets get him to change his nick to thelongguy and see if any channels ban him
19:59:23 <monochrom> this channel won't. :)
19:59:55 <DigitalKiwi> that is good
20:00:49 <DigitalKiwi> didn't you unban like 300 people a few weeks ago?
20:00:56 <DigitalKiwi> it's already up to 27 0.o
20:01:03 <monochrom> Just 50
20:01:33 <monochrom> This shows that we are a self-recovering community.
20:01:55 <DigitalKiwi> $r:Jesus?Christ <-- oh how i wish that ? was a *, i would lawl
20:02:22 <monochrom> It helps that some of the bans are stored in ChanServ. ChanServ reinstates them lazily.
20:03:22 <DigitalKiwi> the distro i use has like 700 people in its channel and 9 bans, someone was in today boggled about how that was possible >.>
20:03:54 <dpratt711> 04094gtf4//.444444/34../.4uie44.fgrtttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt./weeeeeefffffffff4udwu3vdvd/.
20:04:06 <xerox> dpratt711 is it all right?
20:04:10 <DigitalKiwi> guess they are used to channels having .5-3 bans per idler >.>
20:04:20 <xerox> I am guessing cat problem.
20:04:33 <ddarius> Or fell asleep on the keyboard.
20:04:42 <DigitalKiwi> done that :(
20:04:50 <DigitalKiwi> usually don't hit keys/enter though
20:05:17 <DigitalKiwi> irc needs /say !
20:06:30 <drg_> hello everyone. I am trying to find a function which will let me use view patterns to extract two values from a record at once. So I think the type would be (a -> b) -> (a -> c) -> (a -> (b, c))
20:06:40 <kmc> :t (&&&)
20:06:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:06:45 <kmc> that's the one
20:06:52 <ddarius> @hoogle (a -> b) -> (a -> c) -> (a -> (b,c))
20:06:52 <lambdabot> No results found
20:06:53 <kmc> read (a b c) as (b -> c)
20:07:12 <drg_> wow that was quick. thanks!
20:07:23 <kmc> thank you, come again
20:08:14 <dpratt711> 6b02432e42gh34jmn-[=
20:09:15 <xerox> hahaha..
20:09:43 <kmc> dpratt711, you all right?
20:09:53 <xerox> Unidentified Ircing Object
20:15:55 <xle> does parsec parse lazily?
20:16:07 <xle> if I give it a lazy string as input, that is...
20:16:41 <ddarius> No.
20:16:50 <ddarius> The type of parse demonstrates that.
20:17:37 <ddarius> xle: It won't consume any more of the string than is needed, but it won't return any results until the parse completes or fails.
20:17:57 <xle> ddarius: Ah ok, that's my problem then...
20:18:07 <xle> ddarius: what do you mean type of parse demonstrates that?
20:18:14 <ddarius> :t parse
20:18:14 <lambdabot> Not in scope: `parse'
20:18:18 <ddarius> Curses.
20:18:22 <kmc> uu-parsinglib does i think
20:19:49 <copumpkin> xle: it's an Either
20:19:54 <ddarius> Simplifying, parse :: Parser a -> String -> Either ParseError a
20:20:07 <xle> copumpkin: Either is not lazy?
20:20:13 <copumpkin> xle: inherently, for this task
20:20:22 <copumpkin> it isn't not lazy in general :P
20:20:22 <monochrom> So it must consume a lot of input just to figure out Left or Right.
20:20:37 <ddarius> xle: You either get the result or an error.  You can't return some of the result since you never know whether or not there will be an error later on.
20:20:42 <monochrom> A consequence of constructivist, non-classical disjunction.
20:20:50 <xle> ddarius: I see, yeah that makes sense
20:21:15 <xle> What if I use the new Text.Parsec.ByteString.Lazy?
20:21:23 <pikhq> Of course, since it's still Haskell, it's only parsed when the result is pattern-matched...
20:21:26 <ddarius> As kmc mentioned, some other parsing libraries allow for lazy parsing, but they necessarily handle errors in a different way or not at all.
20:21:26 <monochrom> Same deal.
20:21:48 <ddarius> xle: Lazy bytestrings are no more lazy than Strings, less actually.
20:22:03 <ddarius> xle: The problem isn't the input type, it is the output type.
20:22:04 <copumpkin> xle: that's the parsed datastructure
20:22:40 <xle> OK, I see... Problem is the pattern matching on Either won't return until Right is completed, right?
20:22:59 <copumpkin> xle: the parse function can't know whether it's going to give you a Left or a Right until it's consumed a big chunk of input
20:23:06 <xle> In other words, I can't use the output of parse until it is fully determined because of the Either
20:23:26 <xle> copumpkin: I guess it isn't even a big chung, it needs to consume the whole thing, right?
20:23:33 <xle> chunk*
20:23:40 <copumpkin> xle: depends on whether it succeeds or fails
20:23:51 <xle> copumpkin: well, let's say it keeps going till eof
20:23:56 <copumpkin> if you're matching parentheses, maybe if you start with ')'
20:24:01 <copumpkin> it'll fail immediately
20:24:06 <xle> copumpkin: oh right, I see
20:25:53 <xle> What if parsec is returning something like [Row] on the Right portion
20:26:04 <xle> and I want to process the Row records as they become available from parsec
20:26:09 <xle> lazily, that is
20:26:33 <shapr> iteratee?
20:26:34 <xle> is there a way to do this as opposed to waiting until the entire [Row] parsed result is loaded in memory?
20:26:44 <ddarius> xle: To get the first element of the list, you'd have to know that the whole parser succeeded which it won't know until it consumes all the input.
20:27:19 <xle> ddarius: So is parsec really for processing relatively small input?
20:27:36 <kniu> so what does lambdabot use to get the types of expressions?
20:27:36 <xle> ddarius: I can't parse a 3gb file on my laptop then
20:27:40 <ddarius> xle: Parsec inherently cannot return partial results from partial parses.  At best, you can run parsers repeatedly over the remainder of the input string.
20:28:05 <xle> ddarius: yeah, it seems like the best option is to delimit the input string somehow and map the parser to the resulting list
20:28:14 <copumpkin> xle: Row? is it a csv file?
20:28:17 <ddarius> xle: Parsec is more geared to complex input, such as the syntax of a programming language, as opposed to simple input.
20:28:33 <xle> Well, I was simplifying to CSV as an example
20:28:40 <copumpkin> ah ok
20:28:48 <ddarius> xle: Again, as kmc mentioned, there are other parsing libraries out there with different aims.
20:28:50 <xle> I'm actually parsing a very tiny input text file representing a board game
20:29:18 <xle> but the contenst are actually not a string and are streamed repeatedly through a pipe or network
20:29:46 <xle> ddarius: do you know any good ones?
20:29:48 <yrlnry> @seen apfelmus ?
20:29:49 <lambdabot> Unknown command, try @list
20:29:53 <yrlnry> bah.
20:30:56 <copumpkin> xle: if they're streamed individually why not parse them individually?
20:31:19 <xle> But they are not :) It's one continuous stream as lines of text
20:31:35 <copumpkin> I mean
20:31:36 <xle> I think I can find a way to delimit the transmitted boards though
20:31:39 <copumpkin> consume a single element
20:31:42 <copumpkin> see what's left
20:31:43 <copumpkin> consume that
20:31:46 <copumpkin> see what's left
20:31:53 <xle> By element, you mean?
20:32:03 <ddarius> xle: The library kmc mentioned is good.  If you aren't worried about errors so much and the data is in a binary format or a simple textual format, then using the bytestring library or a library directly over it may be a good idea.
20:32:06 <ddarius> @hackage uulib
20:32:06 <lambdabot> http://hackage.haskell.org/package/uulib
20:32:16 <ddarius> @hackage binary
20:32:16 <lambdabot> http://hackage.haskell.org/package/binary
20:32:20 <copumpkin> xle: whatever the thing you would have expected to live in a list was
20:33:05 <xle> copumpkin: ah I see. Imagine I am reading text directly from the network library. I have to parse the input stream into a list of records
20:33:13 <xle> copumpkin: but I see your point
20:33:22 <copumpkin> repeatM :P
20:33:24 <copumpkin> is what you need!
20:33:54 <copumpkin> or unsafeRepeatIO
20:34:08 <ddarius> or unsafeRepeatIO
20:34:54 <xle> I'm not sure if I follow.. I dont know how big the text stream will be, it varies from item to item
20:35:09 <xle> However, it does have a syntax and I can parse it using parsec when read from a file
20:35:09 <copumpkin> presumably you can parse each item?
20:35:23 <copumpkin> so you have your stream
20:35:27 <xle> problem is when I stream it, parsec never finishes parsing becuase it doesn't encounter eof
20:35:28 <copumpkin> call parse with your parser on it
20:35:47 <copumpkin> if it's looking for EOF, make sure it doesn't :P
20:35:55 <xle> I tried that as well, doesn't work
20:35:59 <copumpkin> how were you planning on delimiting your [Row] in the first place then?
20:36:20 <dolio> Parsec can't parse infinite amounts of input.
20:36:32 <xle> dolio: right, I think that is the problem here
20:36:37 <dolio> Because it would need to look infinitely into the future to decide whether to report a parse error.
20:36:54 <xle> copumpkin: the syntax makes it possible to delimit items once you build up to the item level using combinators
20:37:08 <xle> dolio: right, I think I fully understand the limitation now :)
20:37:27 <xle> thanks for the explanation guys!
20:37:28 <copumpkin> xle: so you can find boundaries between items enough to generate a list (that you'd like to be lazy) of items, but you can't parse a single item without an EOF? :O
20:37:44 <xle> copumpkin: oh yeah I can, that's what I was saying
20:37:54 <copumpkin> well then that's what I was suggesting :P
20:38:04 <xle> copumpkin: what I will do is split the input string using a delimieter and map parse over the resulting list
20:38:11 <xle> copumpkin: right right :) thanks
20:38:27 <copumpkin> oh, I didn't mean an external delimiting phase, but if you've figured it out I'll leave it to you :P
20:38:39 <xle> copumpkin: kind of a hack though.. would be real elegant if I could stream parse directly
20:39:20 <xle> copumpkin: I can parse a single item without eof, but only by saying "many item"
20:39:33 <xle> which means the whole thing won't ever terminate until it sees eof anyway
20:39:34 <xle> anyways
20:39:36 <xle> thanks for the help!
20:39:46 <ddarius> xle: Less hacky is what copumpkin is suggesting, which is parse one record, then run the parser again on the remainder of the input for the next record.  And indeed, you can use a lazy parsing library that will do exactly what you want.
20:39:48 <dolio> I think edwardk is working on parsers that can do that kind of lazy parsing. But he hasn't released anything.
20:40:19 <copumpkin> that's cause the parsec people stole his name! :P
20:40:22 <dolio> I'm not really aware of any other existing libraries out there for lazy parsing, though.
20:40:33 <ddarius> copumpkin: No we didn't.  The parsimony people did.
20:40:49 <copumpkin> ddarius: I thought the parsimony people were most of the parsec people, minus you
20:40:50 <ddarius> copumpkin: Parsec has probably been around longer than edwardk has been a Haskell user.
20:40:54 <dolio> Yeah, the parsimony on hackage is a fork of parsec or something.
20:41:23 <copumpkin> that's what I meant, anyway
20:41:43 <ddarius> There are a lot of parsing libraries that are "forks" of parsec.
20:42:16 <dolio> It sounds like parsec 3 obseletes some of the motivation, too.
20:42:21 <ddarius> My impression is parsimony is a product of Iavor Diatchki, who, as far as I'm aware, is not particularly related to parsec.
20:42:34 <copumpkin> oh I saw Daan on the author list for it
20:42:45 <copumpkin> so I assumed he was behind it too
20:43:04 <copumpkin> (have I mentioned how awesome I think the name Daan is?)
20:43:06 <copumpkin> (yes!)
20:43:14 <ddarius> copumpkin: He may be, but I highly suspect he is not, and that is simply due to the library being based on Parsec.
20:43:19 <copumpkin> I see
20:43:31 <dolio> You a big Earth: Final Conflict fan or something?
20:43:44 <ddarius> As far as I know, Daan Leijin is not active in the Haskell community currently.
20:43:50 <copumpkin> never heard of it :)
20:44:05 <copumpkin> is there a dude called daan in it?
20:44:16 <dolio> Yes.
20:44:59 <dolio> Not exactly a dude.
20:46:08 <copumpkin> :O
20:48:40 <dolio> Unless by "dude" you mean "androgynous alien being".
20:50:04 <copumpkin> I see
20:50:28 <monochrom> polyparse has some lazy parsing parts.
20:50:49 <p_l> dolio: Haskell - bridging gaps across species? ;D
20:50:59 <monochrom> this is the only aspect haxml trumps hxt because haxml uses polyparse
20:51:26 <djahandarie> Man, it is so annoying how all these awesome papers are always stuck in PDF format
20:51:48 <monochrom> What is the alternative? Postscript? ASCII?
20:51:55 <djahandarie> HTML.
20:52:09 <Draconx|Laptop> dear god no.
20:52:14 <yrlnry> HTML typesetting is too weak for mathematics.
20:52:15 <monochrom> This is because people are obsessed with their LaTeX.
20:52:45 <chrisf> nothing wrong with LaTeX.
20:52:57 <chrisf> unlike more or less everything else, it *works*.
20:53:20 <djahandarie> yrlnry, you mean for formulas and such?
20:53:23 <copumpkin> the language is horrid
20:53:24 <Draconx|Laptop> chrisf, I can think of lots of things wrong with LaTeX, but not enough to stop me from using it.
20:53:28 <copumpkin> the output is quite nice
20:53:28 <yrlnry> djahandarie:  yes.
20:53:30 <xle> How can I get the remaining string from the parser after parsec finishes parsing?
20:53:40 <chrisf> the output is extremely good.
20:53:47 <djahandarie> yrlnry, I'd imagine such things could be dropped in as images.
20:54:00 <chrisf> the syntax is hardly more horrid than a mess like html..
20:54:15 <Draconx|Laptop> html doesn't allow you to redefine syntax.
20:54:23 <monochrom> It is not like programming language papers have a lot of nasty integrals with fractions and square roots and Einstein notation.
20:54:26 <kmc> HTML and PDF are fundamentally different
20:54:45 <kmc> PL papers can have fairly complex notation
20:54:48 <djahandarie> kmc, sure, as formats, but for their actual uses?
20:54:58 <kmc> djahandarie, as to what they represent
20:55:08 <yrlnry> djahandarie:  heck, you could embed the entire thing into an HTML page as one gigantic bitmap!
20:55:12 <kmc> HTML represents content in a fluid and semi-semantic way which is laid out by the client
20:55:12 <monochrom> PL papers have notations suitable for HTML.
20:55:39 <djahandarie> kmc, and it should be so when on the computer. Which is where I read all my papers.
20:56:18 <monochrom> Even with nasty integrals you have MathML.
20:56:21 <dolio> They just have diagrams and proof trees and...
20:56:50 <chrisf> monochrom: you seriously think MathML is adequate for.. anything?
20:57:00 <Draconx|Laptop> djahandarie, how do I write \[ \Sum_{n=0}^{\infty} \frac{1}{n^2} \] in HTML?
20:57:01 <monochrom> Yes.
20:57:08 <kmc> djahandarie, if the author wants to put a lot of thought into how their information should be presented, I'd rather not have Firefox overrule all their decisions
20:57:50 <monochrom> I don't seriously think MathML should be entered by hand. I seriously think MathML is adequate for nasty integrals and PL.
20:57:52 <chrisf> of course, the other issue is that web browser typesetting is notoriously crap.
20:58:08 <cads> djahandarie, what specific downsides hit you about PDFs?
20:58:09 <djahandarie> kmc, when the medium the data is transfered thru is dynamic itself, trying to optimize for presentation is a impossibility in the first place.
20:58:32 <chrisf> monochrom: OH, you advocate WYSIWYG nonsense to write your MathML for you, eh?
20:58:37 <dolio> n-category cafe uses MathML and it works all right. But I'm pretty sure everyone there uses a latex -> mathml translator someone there wrote.
20:58:47 <monochrom> Not necessarily.
20:59:30 <monochrom> http://www1.chapman.edu/~jipsen/mathml/asciimath.html is one counterexample to your bipolar assumption.
21:00:41 <djahandarie> cads, bipartite really. First off is the implementation of PDFs (binary format, plugins required for viewing, slow), and the other would be that they are, by concept, oriented towards printed material, which should not be how they are distributed on the internet.
21:00:46 <chrisf> how is this better than latex?
21:01:01 <dolio> Man, the MathML square root is ridiculous.
21:01:39 <monochrom> The reader receives HTML+MathML. Many things are cut-and-paste-able as opposed to pngs and pdfs.
21:01:57 <Draconx|Laptop> djahandarie, PDF is a text format.  And yes, you need a PDF viewer to view PDFs, in much the same way as one needs an HTML viewer to view HTML.
21:02:09 <monochrom> At the very least, the reader does not have to understand LaTeX.
21:03:33 <xle> Sorry to ask again, but does anybody know how I can get the remaining string from parsec together with the parse result?
21:04:04 <dmwit> xle: liftM2 (,) yourParser (many anyChar) -- ?
21:04:31 <monochrom> No, many anyChar really chases down the infinite string tail.
21:04:44 <dmwit> Oh, parsing an infinite string?
21:04:49 <dmwit> Probably Parsec isn't the way to go, then.
21:05:03 <monochrom> Gosh why are you people so boolean?
21:05:14 <dmwit> Parsec is strict in the sense that it has to do the whole parse before it can say Left or Right.
21:05:36 <djahandarie> Draconx|Laptop, it is a text format? And HTML has fast and nearly globally-used implementations.
21:05:46 <Draconx|Laptop> djahandarie, and PDF doesn't?
21:05:46 <xle> dmwit: Yeah, so I have painfully noticed :) I'm trying to devise a way around it now
21:06:02 <djahandarie> Draconx|Laptop, PDF viewing is painful.
21:06:11 <monochrom> I have a string of unknown length. The prefix is "(". I just ask parsec to parse that prefix. Can I get the tail?
21:06:11 <dmwit> xle: Have you considered using another parsing library, instead?
21:06:29 <Draconx|Laptop> djahandarie, I have to disagree, but OK.  Perhaps you should look into finding a better viewer?
21:06:43 <xerox> xle http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Prim.html#v%3AgetInput
21:06:49 <cads> djahandarie, why is it painful? You have to have pretty old hardware for pdfs to be slow. True they could be easier to search through...
21:07:20 <djahandarie> Draconx|Laptop, I don't see how me finding a better viewer would justify it being a good format for academic papers for digital viewing.
21:07:36 <xle> dmwit: I haven't yet. People recommened uulib and binary. uulib looks like it would take a while to learn
21:07:41 <xle> and binary is a bit too bit by bit for me :)
21:08:02 <xle> xerox: thanks, it seems I don't have parsec 3 installed, so I didn't realize there were some new functionality
21:08:05 <ddarius> xle: Look at getState
21:08:13 <Draconx|Laptop> djahandarie, well, I'm sure I could find a crappy HTML renderer, too.
21:08:13 <monochrom> Solution: do { answer <- string "("; remaining <- getInput; return (answer,remaining) }
21:08:14 <djahandarie> cads, in general, viewing a PDF usually means waiting a minute or so for Acrobat Reader to load, then watch it download the PDF, and chug along at displaying it.
21:08:34 <Draconx|Laptop> djahandarie, I personally recommend xpdf.
21:08:40 <djahandarie> Draconx|Laptop, I use it.
21:09:02 <Draconx|Laptop> it generally loads before my finger has lost contact with the enter key.
21:09:46 <xerox> xpdf -rv file.pdf #for night reading
21:09:52 <cads> For typeset text pdf is pretty alright.. maybe ps is lighter.
21:10:03 <djahandarie> Draconx|Laptop, the idea is that I want to click on a link, and not notice any difference between where I was and where I am. Because I am just reading something different. "Formats" should be transparent to the end-user.
21:10:23 <djahandarie> PDF does a really bad job at that.
21:10:26 <dmwit> That's a nice goal, but orthogonal to the goodness of PDF.
21:10:36 <dmwit> No, our browsers do a bad job of that.
21:10:41 <dmwit> That's not the PDF format's fault.
21:10:51 <monochrom> The problem with postscript is it is not even searchable, let alone copy-paste-able.
21:11:02 <djahandarie> dmwit, yes, excuse me for jumbling up the implementation of PDFs and PDF viewing with the format itself.
21:11:11 <monochrom> But as usual, supercial people just care about looks.
21:11:24 <monochrom> "o gawd PDF looks so bad and HTML worse"
21:11:46 <Draconx|Laptop> I have yet to find an HTML renderer which performs hyphenation.
21:11:54 <monochrom> form over function
21:12:06 <Draconx|Laptop> in this case the function *is* form.
21:12:11 <cads> djahandarie, the idea is that people are writing papers, not websites. Websites can be displayed at different sizes, zoomed, scrolled, chopped up by other websites.. but papers benefit from being the same for everyone who reads them
21:12:27 <Draconx|Laptop> the whole point of a renderer is to put pretty things on a display device.
21:12:31 <monochrom> Perhaps people also like eye-candy programming languages with random semantics.
21:12:52 <djahandarie> cads, so are you advocating paper media over digital media?
21:13:01 <augur> does anyone know what its called when a graph is represented in a weird sort of infinite tree like fashion, e.g. the simple graph {a <-> b} represented as (a (b (a (b ...))))?
21:13:07 <djahandarie> cads, I'm speaking within the realm of digital media.
21:13:10 <monochrom> "Look, my program may or may not diverge but gawd it looks so cursive!"
21:13:20 <djahandarie> cads, if I was using PDF just to print stuff out obivously I wouldn't have any problems with it.
21:13:33 <kamatsu> hey, can anyone tell me how Happstack.State goes with concurrent access?
21:13:55 <djahandarie> Draconx|Laptop, there are pieces of Javascript that can automatically hyphenate your text.
21:13:57 <kamatsu> do I need to make a thread specifically for state storage?
21:14:07 <djahandarie> Draconx|Laptop, and hyphenation is in the CSS3 spec.
21:14:19 <kamatsu> or can I just call the State transactions in any thread?
21:14:24 <Draconx|Laptop> djahandarie, which user agents implement this CSS3 hyphenation feature?
21:14:38 <djahandarie> Draconx|Laptop, none, but I figured it was worth mentioning.
21:14:45 <cads> no, papers don't have to be made of paper.. they just have to keep the symbols in the same relative position no matter what rendering device is used or else meaning can be skewed. Maybe websites can get all messed up and people don't care, but for math papers it can make a difference if this or that symbol get out of alignment.
21:15:27 <djahandarie> cads, there is a conflict with a dynamic medium and static content then.
21:15:44 <djahandarie> cads, wouldn't one agree that it'd be better to make the static part of the content static, and the rest dynamic?
21:16:11 <Draconx|Laptop> What part of the medium or the content is dynamic?
21:16:13 <monochrom> djahandarie: I'm afraid you're talking to another of those boolean people.
21:16:34 <Draconx|Laptop> the content of academic papers don't usually change from day to day.
21:16:38 <cads> djahandarie, scroll down to where you see the image based equations in this paper and you tell me http://www2.units.it/~etica/2003_1/3_monographica.htm
21:17:32 <djahandarie> Draconx|Laptop, the medium (a computer, normally) is dynamic in the sense of screen sizes, DPI, window size, etc. The content is dynamic in the sense that normal text doesn't loose its meaning when positioned differently (as long as it isn't extreme).
21:17:47 <djahandarie> Draconx|Laptop, as cads argued, things such as equations need to be static.
21:18:42 <augur> no? noone? :(
21:18:57 <djahandarie> cads, they aren't loading for me.
21:19:26 <djahandarie> It is some "wmz" format apparently... which I have never heard of before.
21:19:32 <cads> they aren't loading for anyone :P
21:19:43 <Draconx|Laptop> djahandarie, anyway, I never got an answer to my earlier question: how do I write \[ \sum_{n=0}^{\infty} \frac{1}{n^2} \] in HTML?
21:20:11 <djahandarie> Draconx|Laptop, you don't, but that could be rendered to an image and displaying in HTML.
21:20:25 <djahandarie> displayed*
21:20:51 <Draconx|Laptop> djahandarie, but then the image probably won't have the same typeface as the rest of the document.
21:21:14 <monochrom> You could use MathML.
21:21:59 <monochrom> Again, http://www1.chapman.edu/~jipsen/mathml/asciimath.html can help you.
21:22:11 <xerox> on http://mathoverflow.com/ they use jsmath http://mathoverflow.net/questions/10948/what-is-sum-x-mathbbz-2
21:22:59 <dmwit> monochrom: heh, that radical is quite bad looking
21:23:08 <monochrom> The problem with jsmath is everything is a little picture, not copy-paste-able, not searchable.
21:23:12 <djahandarie> Naturally, HTML has an array of its own issues, but the point is that a paper in HTML is much more pleasant for the end-user than the same paper in PDF format. In summary, that is because 1. implementations of PDF viewing are bulky, 2. PDFs are oriented to static content, while papers are primarly non-static content (text).
21:23:27 <cads> djahandarie, I can appreciate that in the spirit of improving digital media we should work on a format that can express easy dynamic content, high fidelity static content, and shades in between.
21:23:36 <djahandarie> I need to head out to bed though, since I have work tomorrow.
21:24:04 <djahandarie> cads, right, that'd be the ideal. I think HTML is currently a better comprimse than PDF.
21:24:08 <djahandarie> Good night.
21:24:15 <monochrom> dmwit: I have heard that one before. MathML rendering could be improved over time.
21:24:30 <dmwit> Sure.
21:24:57 <xerox> monochrom jsmath copy and paste is indeed broken, but asciimath is much more broken for me: http://imgur.com/ve6iJ.png
21:25:20 <monochrom> The problem is all of you naysayers don't use it and therefore it doesn't get improved. Self-fulfilling prophecy.
21:25:27 <Draconx|Laptop> monochrom, ugh, that site is a wall of impossible to read badly centred text.
21:25:35 <dmwit> This naysayer doesn't use it because he didn't know about it.
21:26:33 <cads> monochrom, I think places like mathoverflow have been putting mathml in the spotlight lately, no?
21:26:55 <Draconx|Laptop> monochrom, I don't really get that page, actually, I just see a bunch of code, some of which looks like LaTeX... no nicely laid-out forumlae.
21:27:16 <dmwit> ...have you got javascript turned on?
21:27:30 <monochrom> In fact just a few hours ago I visited mathoverflow for the first time in my life. I only saw little pictures for math.
21:27:43 <cads> oh, they use jsmath
21:28:48 <cads> monochrom - open a math post on mathoverflow and double-click any equation that you see.
21:30:09 <monochrom> So I have to double-click every formula individually?
21:30:16 <kamatsu> hey, in Happstack.State, if I have A modifying some data and B requesting the same data, does it give B an old version or wait for A to finish?
21:30:30 <kamatsu> I want it to wait for A to finish, yet it doesn't appear to do that >_>
21:33:39 <monochrom> So suppose I see "Jacobi's theorem asserts that if Î» is irrational then the orbit of nÎ» for n=1,2,3... is dense in S^1â‰ƒâ„/â„¤", I have to double-click, what, 5 times? And then manually find the correct position in text to put them back?
21:35:43 <cads> monochrom, that bugs me too
21:35:47 <monochrom> Indeed, it is from http://mathoverflow.net/questions/4279/interesting-applications-of-the-pigeon-hole-principle . Here is the fun part: in "n=1,2,3, ...", it is the commas and the dotdotdot that get lost if you try to use text copy-paste, i.e., text copy-paste gets you "n=123", isn't that fun?
21:36:26 <monochrom> So much for every attempt to bring LaTeX to the HTML world.
21:38:05 <xerox> monochrom there's a solution
21:38:14 <cjs> How do I get information about what version of the GHC RTS (and preferably, with what options) I'm running under?
21:38:41 <dmwit> +RTS -h, maybe?
21:38:43 <monochrom> ASCIIMathML has related problems too. It is written by yet another LaTeX fanatic, therefore certain things better done by just using Unicode symbols are done badly using old LaTeX mindset.
21:38:55 <cjs> I mean from within the program that's running.
21:38:58 <xerox> click the little jsmath rectangle in the bottom right, select options and then "Use native Unicode fonts": " nÎ» for n=1,2,3,... is dense in S1 â‰ƒ â„/â„¤." here's the copy-paste now :)
21:39:17 <monochrom> Oh that's much better! Thanks.
21:40:05 <cjs> I suppose I could grab the OS's opts and run myself with +RTS --info, but it seems a bit of a hack.
21:40:34 <cjs> But yes, what comes out of +RTS --info is exactly what I need.
21:43:11 <dmwit> cjs: Perhaps there is something in the GHC API.
21:45:26 <dmwit> readRational is useful enough that it should be part of some non-GHC-API library.
21:46:17 <dmwit> isn'tIn :: Eq a => String -> a -> [a] -> Bool
21:46:23 <dmwit> Does this type strike anybody else as odd?
21:46:46 <dankna> what's the String for?  heh
21:46:56 <dmwit> Dunno!  And the docs don't say.
21:47:02 <dankna> indeed...
21:47:10 <cjs> Ah, I'd forgotten about the GHC API.
21:47:28 <cjs> Though that seems to me more for calling the compiler than interfacing with stuff that the compiler's done.
21:47:38 <dmwit> yeah
21:47:49 <dmwit> I don't see what you want in there, anyway.
21:51:25 <cjs> Ah! DynFlags.compilerInfo.
21:51:35 <cjs> A simple look at the source of Main.hs was all that was needed.
21:53:03 <dmwit> Is that the compiler info for the currently installed compiler, or for the compiler that built the RTS you're using?
21:53:09 <dmwit> I guess those are probably the same, huh?
21:55:57 * hackagebot upload: yajl 0.1 - Bindings for YAJL, an event-based JSON implementation (JohnMillikin)
21:58:58 * hackagebot upload: yajl 0.1.1 - Bindings for YAJL, an event-based JSON implementation (JohnMillikin)
21:59:45 <kamatsu> event-based?
21:59:48 <kamatsu> JSON?
21:59:53 <kamatsu> it's JSON a data format?
22:00:19 <kamatsu> oh, it's an event-driven JSON parser
22:00:37 <dmwit> "oh"?
22:00:59 <kamatsu> I thought they had somehow made some event-based data format, which would be odd
22:01:11 <kamatsu> the description doesn't describe it as a parser
22:01:28 <dmwit> "event-driven parser" still seems odd to me
22:01:36 <dmwit> I'm reading the docs now to see if I can understand what you mean.
22:01:43 <cjs> dmwit: So yes, DynFlags.compilerInfo is in the GHCI API and what I want. However, this package doesn't seem to be exposed by default.
22:02:04 <copumpkin> dmwit: for xml it means you provide callbacks that get triggered whenever the parser encounters parts of xml you care about
22:02:20 <cjs> So I need to expose it on every machine on which I'd ever like to build this code?
22:02:27 <dmwit> cjs: Use cabal.
22:02:41 <cjs> Oh, is it distributed separately, as well?
22:03:00 <cjs> I've been wondering about that with Data.Binary, actually, which also appears to be distributed with GHC (at least 6.12.1) but is hidden.
22:03:01 <dmwit> What is "it" in this context?
22:03:46 <cjs> "it" is the "ghc" package that contains the DynFlags module.
22:04:05 <dmwit> Oh, I don't know.
22:05:02 <cjs> It's not on hackage. Which makes sense; why would you distribute hooks into the internals of GHC separately from GHC itself?
22:05:26 <dmwit> Yeah, it seems to be bundled.
22:06:49 <cjs> Oh, hm, this isn't so bad anyway, since I've had to switch off the Haskell Platform and my distribution system will handle propagating the "expose this package" information.
22:08:08 <dbro> is there a function that can split up a Double d into an Integer i and decimal remainder r such that d = i + r ?
22:09:13 <kamatsu> dbro: can't you do this yourself?
22:09:32 <dbro> I suppose so, but I expect that there's already a library function for it
22:09:40 <kamatsu> hm, i doubt it
22:10:05 <kamatsu> @hoogle Double -> (Integer, Double)
22:10:06 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
22:10:06 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
22:10:06 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
22:10:11 <kamatsu> ah, there you go
22:10:39 <dbro> great, thanks kamatsu and your trusty sidekick lambdabot!
22:10:49 <kamatsu> we really need a "let me hoogle that for you"
22:11:03 <dbro> sorry- I had failed to find it on both hoogle and hayoo
22:11:14 <dbro> I try to rtfm, but sometimes I can't even manage that
22:11:30 <kamatsu> yeah, its more for comic effect than deridation
22:11:31 <kamatsu> i think
22:12:08 <kamatsu> hoogling for type signatures is insanely useful
22:12:18 <dbro> I tried that too... still learning
22:13:57 <cjs> Ouch. That idea of a "decimal remainder" made my head hurt.
22:14:10 <cjs> You did want the remainder as a Double, right?
22:14:59 <dmwit> Why would that make your head hurt?
22:15:06 <dmwit> 3.14159 -> (3, 0.14159)
22:15:16 <dmwit> It's like (`divMod` 1). =)
22:15:34 <dmwit> > properFraction (-pi) -- hmmm
22:15:35 <lambdabot>   (-3,-0.14159265358979312)
22:15:45 <dmwit> bleh
22:15:48 <dmwit> Okay, now my head hurts, too.
22:17:11 <cjs> A double isn't decimal. It's binary.
22:17:57 <Cale> and the base doesn't matter to how properFraction works
22:18:14 <cjs> Your problem is you forgot that as well as mod there's remainders: divMod and quoteRem.
22:18:19 <cjs> Oops, quotRem.
22:19:00 <cjs> I learned this through not reading the documentation and spending months using my own quotRem (with a different name of course) written using divMod. :-)
22:19:03 <dolio> > 5 `mod'` pi
22:19:05 <lambdabot>   1.8584073464102069
22:20:13 <cjs> Anyway, I just think of a Double as not being "decimal." Maybe it's a hangover from the days of using BCD.
22:21:21 <xle> Hey guys, does anybody know why a text stream being piped from a java program over OS io to my haskell program would not register at all? When I do "cat trial.txt", I do get response from my haskell program. But when the java program sends the data, I get nothing.
22:21:46 <kmc> maybe the java program is not flushing stdout
22:21:51 <kmc> buffering here or there
22:21:55 <xle> kmc: I checked, it is
22:22:13 <kmc> you could strace one or both processes
22:22:13 <xle> kmc: also, an equivalent python program has no issues talking to the java program
22:22:27 <kmc> how are you reading in Haskell?
22:22:52 <cjs> Hm. DynFlags.compilerInfo doesn't quite do it. It doesn't give me even some link options. (E.g., I have "RTS ways" listing all of them, but no "RTS way" showing me the particular one I was linked with.)
22:23:07 <xle> I tried interact, then manual hGetContents stdin and hPutStr stdout
22:23:24 <kmc> both of those do lazy IO, which is dubious
22:23:45 <cjs> Is the Java program closing its output at the end?
22:23:53 <cjs> (Either explicitly, or by exiting?)
22:23:56 <kmc> forever (getLine >>= putStr)
22:23:58 <kmc> try that
22:23:59 <nolrai_FG> Hmm I need a list of things to cheack in a code review of Haskell code, any examples out there?
22:24:03 <xle> very strange that it works fine when I use "cat trial.txt"
22:24:10 <kmc> nolrai_FG, style or correctness?
22:24:37 <cjs> Indeed, in general, what's the purpose of the code review?
22:24:51 <xle> cjs: id doesnt right away.. the streaming is supposed to take 10-15 secs, then it quits. it never gets there though, because the java program has a timeout that triggers after not hearing from haskell for some time
22:25:15 <nolrai_FG> kmc: second is better but first is okay, give me what you have.
22:25:31 <kmc> for style there is hlint
22:25:36 <kmc> it should also pass ghc -Wall
22:25:49 <cjs> xie: That's the problem. Each is waiting on the other.
22:26:09 <cjs> hGetContents may wait until it sees an end of file from the remote end.
22:26:13 <kmc> check for non-exhaustive pattern matches (ghc can find some), and use of exception-throwing pure functions like head, fromJust, etc.
22:26:45 <cjs> xie: Basically, anything where you're depending on input from another program is a place you don't want to be doing lazy reads.
22:26:49 <xle> cjs: even when evaluation should proceed because there is some IO hooked up to consume the incoming data?
22:26:51 <kmc> look out for overuse of tuples, Either, and type synonyms
22:27:09 <solrize> @pl \f -> f a
22:27:09 <lambdabot> ($ a)
22:27:13 <nolrai_FG> kmc: Oh, I mean a check list I can give to other people..we are doing a code review in my sienor capstone class.
22:27:14 <cjs> xie: Sure, because there's nothing telling hGetContents that it must return something before it sees end of file.
22:27:33 <kmc> yes please do not use lazy IO
22:27:33 <cjs> It may, if enough stuff comes in that it's forced to start processing, but then again, it may not.
22:27:35 <kmc> preferably ever
22:27:46 <kmc> it's probably okay for pretending that an unchanging file is a lazy string
22:27:54 <kmc> it's definitely not okay for sockets or pipes
22:28:12 <cjs> Well, no, the rule is, don't use lazy IO if you have any need to produce output before the entire input is read.
22:28:18 <nolrai_FG> "look out for overuse of tuples, Either, and type synonyms" that is a good one.
22:28:41 <xle> cjs: so what would be a better way? since it is a stream, should I read block by block?
22:28:44 <kmc> modules that export more than they should
22:28:48 <cjs> nolrai_FG: "Does the code read like English."
22:28:54 <kmc> running Haddock for everything (even if there are no haddock comments) could help
22:28:55 <cjs> xle: It's a stream of what?
22:29:01 <xle> cjs: plain text
22:29:13 <cjs> I.e., what is it that triggers Java to wait for a response?
22:29:24 <cjs> s/Java/the Java program/, of course.
22:29:26 <solrize> @pl \f -> f a b c
22:29:27 <lambdabot> flip (flip ($ a) b) c
22:29:55 <cjs> Does the Java program change its further output based on what it sees back from the program to which it's talking?
22:30:03 <xle> yes it does
22:30:11 <cjs> Ah, so you have not a stream, but a protocol.
22:30:17 <xle> I guess that's right
22:30:22 <cjs> There's some idea of requests and responses in there.
22:30:31 <cjs> So next you need to figure out how requests are delimited.
22:30:38 <xle> That's true
22:30:55 <xle> Well, requests are like a current system state
22:31:20 <xle> haskell program reads, understands the state and responds with a short answer
22:32:06 <cjs> And then you read based on that protocol. And yes, you'll need to read some sort of fixed chunks, possibly as small as 1 character on which you then run a check to see if you've reached the end of a message that now needs to be processed. But the libraries can take care of common situations for you, such as "give me everything up to and including the next newline so I can make my decision."
22:32:30 <cjs> Right, but how much does it read? One character? 128 bytes? Up to a newline? Up to a pair of adjacent newlines?
22:32:45 <cjs> Four bytes that encode a length in network byte order, and then that length?
22:32:54 <xle> cjs: I see. I was hoping for a lazy stream that would keep reading and I would keep processing. I guess this is not a good case for lazy input
22:33:11 <cjs> No, it's not. I've been here before, too.
22:33:31 <xle> cjs: Alright.. I understand what you're saying. I think I can find a way to delimit and read in chunks
22:33:34 <xle> Thanks for the help
22:33:39 <cjs> Protocols always must use strict input because you have to test for your message delimiter and then stop reading and start writing.
22:33:40 <jmcarthur> xle: is this the tron ai thing?
22:33:41 <cjs> NP.
22:34:10 <xle> jmcarthur: Yes it is actually - they haven't put out the starter kit so I wanted to implement it myself as a little challenge :)
22:34:38 <xle> jmcarthur: Funny how I get stuck at seemingly small, irrelevant points
22:34:42 <jmcarthur> xle: ah. yeah, i started doing that but got sick of the boring details. decided to just wait it out until there is a starter pack
22:35:37 <cjs> I've been bashing my head against lazyness issues for two years now, full time. I'm still using Haskell, so clearly I have a very thick head.
22:35:47 <xle> jmcarthur: I'm done with parsing the board and board data structure, but the java program just times out because of this lazy input issue
22:35:58 <xle> cjs: hahaha
22:36:18 <nolrai_FG> I upgraded to the new version of cabal-install, and now when I run "cabal update" I get
22:36:19 <jmcarthur> cjs: lazy io doesn't even count. it's an abomination
22:36:21 <nolrai_FG> cabal: ?: openFile: does not exist (No such file or directory)
22:37:20 <jmcarthur> xle: sounds to me like you are trying to consume more input than is needed for the next output
22:37:42 <solrize> @pl not . null
22:37:42 <lambdabot> not . null
22:37:48 <jmcarthur> or screwed up the buffering mode, maybe
22:38:00 <solrize> @djinn List -> Bool
22:38:00 <lambdabot> Error: Undefined type List
22:38:12 <xle> jmcarthur: so the java program opens a stream to the haskell program and keeps it open until the full game is finished. i can parse a succession of boards, but the input stream needs to close before lazy input is actually read in. Which obviously doesn't work in this case...
22:38:28 <xle> Because they game needs to proceed in turns, but I end up not responding until the very end :)
22:38:50 <xle> jmcarthur: I just have to change the way parsing is done and switch to strict input
22:40:31 <jmcarthur> xle: shouldn't you be able to create a lazy list of states, map over them, and output a lazy list of moves?
22:40:48 <xle> jmcarthur: That's exactly what I wanted to do
22:41:01 <xle> jmcarthur: But hGetContents doesn't even read the input stream until java program closes
22:41:07 <jmcarthur> o_O
22:41:11 <kamatsu> er
22:41:16 <jmcarthur> that doesn't sound right to me. sounds like a buffering issue
22:41:23 <kamatsu> hGetContents should read in lazily
22:41:31 <jmcarthur> tried setting a different buffer mode on stdin and stdout?
22:41:35 <xle> jmcarthur: That's what I thought too and set buffering to nobuffer
22:41:41 <jmcarthur> line buffering, maybe? or even no buffering
22:41:49 <jmcarthur> did you do that for both stdin and stdout?
22:41:50 <xle> What is the best place for me to paste some code?
22:41:51 <kamatsu> have you tried making a function that just prints out hGetContents?
22:41:53 <xle> maybe I can show you...
22:41:58 <jmcarthur> hpaste
22:42:05 <kamatsu> @where hpaste
22:42:06 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
22:42:18 <nolrai_FG> Okay I am now getting "cabal: ï¿½: openFile: does not exist (No such file or directory)" errors what ever I do with cabal, HELP!
22:42:39 <kmc> nolrai_FG, oh i get that
22:42:43 <kmc> it's the awful mystery cabal bug
22:42:51 <kmc> nobody knows what causes it or even how to reproduce it reliably :/
22:43:05 <jmcarthur> o_O
22:43:31 <cjs> xle: Oh, I see, you have to reverse-engineer the protocol from the Java code. What fun!
22:43:40 <jmcarthur> cjs: it's not that bad
22:43:41 <ddarius> There can only be some many (static) calls to openFile in cabal-install.
22:43:46 <nolrai_FG> kmc: is there a work around:?
22:43:50 <xle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17091#a17091
22:43:52 <jmcarthur> cjs: we have sample maps already in text files, and it's fairly obvious how they work
22:43:53 <kmc> nolrai_FG, none that i know :/
22:44:09 <xle> yeah, yeah, I'm already done with parsing the protocol
22:44:16 <xle> it's just this lazy input issue driving me crazy!!
22:44:16 <jmcarthur> mapM is the problem
22:44:21 <jmcarthur> oh wait
22:44:29 <jmcarthur> okay i'll look more closely :)
22:44:39 <nolrai_FG> soo if I reinstall caball-install from scrach will it fix it maybe?
22:44:50 <xle> sorry, let me put streamboards on there too
22:45:08 <jmcarthur> yeah i suspect that is where the problem is
22:45:52 <xle> ok it should be there too now
22:46:22 <xle> it uses parsec to parse one board each time "parse" is called
22:46:23 <jmcarthur> parseBoard?
22:46:33 <jmcarthur> ah
22:46:40 <cjs> Oh, I see; you just need to read the map from stdin, and then send moves to stdout, ignoring stdin. Yeah, not too tough.
22:46:40 <xle> parseBoard :: String -> Either ParseError (Board, String)
22:47:01 <xle> parseboard returns the board and remaining string
22:47:29 <jmcarthur> how does your parsec stuff find the end of the board? is it using the width and height given or determining it from seeing numbers where it might expect walls?
22:47:47 <cjs> xle: Do you got the lazy thing figured out? You need to read a single line, parse the number of lines remaining out of that, and then read that many more lines.
22:47:58 <cjs> s/Do you got/Did you get/
22:48:01 <xle> I'm not validating length at this point, it's looking ahead to see if it sees dimensions again. if so, it terminates
22:48:15 <jmcarthur> xle: that's the problem then
22:48:19 <cjs> xle: I don't think you want to use parsec for this.
22:48:20 <ddarius> xle: Try removing the second case in streamBoards and adding it as a top-level pattern match.
22:48:30 <jmcarthur> xle: it won't see other dimensions until there is another game state
22:48:49 <xle> jmcarthur: good catch!!! this is what happens when you try this at 1am :)
22:48:55 <jmcarthur> heh
22:49:05 <jmcarthur> use the given dimensions and you should be fine
22:49:31 <xle> right.. hmm is there an easy way to do that inside the parsec monad, or will I need to go back to something like Data.Binary?
22:49:45 <jmcarthur> xle: maybe something like replicateM might help?
22:50:03 <cjs> xle: What's your internal representation of a game board?
22:50:20 <xle>   data Board = Board
22:50:21 <xle>                 { bWidth :: Int
22:50:21 <xle>                 , bHeight :: Int
22:50:21 <xle>                 , bBoard :: [[Tile]]
22:50:21 <xle>                 } deriving (Eq, Read)
22:50:24 <jmcarthur> xle: care to share the wealth once you're done? :)
22:50:29 <cjs> Whatever it is, this format should be trivial to convert to it.
22:50:34 <jmcarthur> because that would rock
22:50:48 <xle> jmcarthur: absolutely! If I can actually beat the competition guys to it, I will share it of course :)
22:50:55 <jmcarthur> sweet
22:50:59 <jmcarthur> thanks!
22:51:19 <cjs> bBoard: each list represents a row of tiles, and each list within that is a list of tiles in that row?
22:52:06 <jmcarthur> i guess Tile also captures the presence of a player
22:52:10 <xle> Yeah
22:52:18 <xle> data Tile = Floor | Wall | Me | Them | Unrecognized deriving (Eq, Read)
22:52:25 <jmcarthur> i haven't decided whether to go that route or store the player coordinates separately
22:52:43 <cjs> Ouch! That's going to be fun with a non-mutable list instead of a mutable array. But that aside....
22:53:04 <cjs> xle: d00d: The data you read from stdin is already in your format! There's nothing to parse!
22:53:43 <cjs> Do you see what I mean?
22:53:54 <jmcarthur> i was thinking i'd go with something like type Map = IntMap (IntMap Tile) ; data Tile = Wall | Empty ; data State = State { <the map>, <player coordinates> }
22:53:55 <xle> cjs: Yeah, I think so
22:54:08 <xle> but honestly parsing took me 10 mins to write
22:54:43 <jmcarthur> my planned algorithm in particular will need the fast lookups and free undoes of the IntMaps
22:54:46 <xle> it's some laziness and then this getting stuck issues that took me more time
22:54:47 <cjs> Right. And how long does a function toTile :: Char -> Tile; tile ' ' = ...; tile '#' = ... take to write?
22:55:10 <xle> cjs: much less of course
22:55:29 <cjs> Which is basically the entire parser. You just need to massage the input lines you read to remove the newlines at the end.
22:55:46 <jmcarthur> cjs: you mean using the lines function? :)
22:55:56 <xle> :)
22:56:21 <nolrai_FG> What does "Ambiguous constraint" mean?
22:57:05 <cjs> If you read the whole thing as one big chunk, using a length gotten from multiplying the length*width+1 from the first line you read, yes. Or you might replicate getLine or whatever the heck it is, and map something onto it to strip the newlines. Lots of options, and it doesn't really matter which way you go.
22:57:13 <jmcarthur> i do think parsec is overkill for this
22:57:41 <xle> I think so too.. I'm still amazed by how cool it is :)
22:57:56 <jmcarthur> yeah parsec is really cool
22:58:09 <cjs> Parsec is way, way overkill.
22:58:27 <jmcarthur> cjs: i wouldn't go that far
22:58:35 <cjs> Actually, I think I've written more monadic parsers from scratch than I've written using Parsec. They're just way too easy to write.
22:58:49 <jmcarthur> parsec parsers are pretty easy to write, too
22:59:35 <cjs> Yeah, but when you start getting into real world parsing, you often need to carry about and transform bits of state and stuff like that, and rather than stacking monad transformers it just becomes easier to write your own.
23:00:00 <cjs> Oh, but wait, I remember what the main issue was for me: I almost invariably use ByteString for I/O.
23:00:19 <jmcarthur> parsec supports bytestring
23:00:23 <cjs> New Parsec allows that now, yes.
23:00:40 <cjs> The version available in 2008 didn't.
23:00:47 <jmcarthur> yeah :(
23:00:47 <ddarius> Parsec, new and old, also has a user state field.
23:02:10 <cjs> ddarius: yes, I noticed that at one point. I think the other issue I ran in to was dealing with getting certain types of error information out of the parser.
23:08:20 <cjs> Doh! All this time I've been tracking down GHC's '--info' flag, not the RTS's.
23:10:14 <nolrai_FG> What does "reachable from the type after the '=>'" mean?
23:11:25 <cjs> Oh my!
23:12:02 <nolrai_FG> never mind.
23:12:08 <cjs> Anybody ever wondered why the first entry printed by "+RTS --info" is '("GHC RTS", "YES")'?
23:13:15 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17093#a17093
23:13:49 <dmwit> hahahaha
23:14:07 <ablmf> Where is function is incorrect ? http://pastebin.com/m6d4377b1
23:14:10 <dmwit> I've often wished that stray commas could be put in various places.
23:14:20 <dmwit> At the ends/beginnings of lists, records, etc.
23:14:23 <cjs> Yeah, me too.
23:14:36 <ablmf> I am trying to solve Problem 1 for Project Euler
23:14:43 <cjs> Anyway, count on Simon Marlow to find the most efficient solution. :-)
23:15:08 <dmwit> ablmf: (/) isn't defined on most Integral instances
23:15:12 <dmwit> ablmf: Use `div` instead.
23:16:23 <cjs> ablmf: BTW, it will also be more readable if you drop the primes from len and sum. Being local within the let, they'll have scope over any global versions, which you're not using.
23:16:24 <ablmf> dmwit: No, the error message is that floor requires a RealFrac a
23:16:47 <cjs> As well as using `div`, remove the floor.
23:17:03 <cjs> You're using Integrals, to which floor, ceiling, etc. don't apply.
23:17:55 <ablmf> cjs : so should I use where instead of let?
23:18:20 <dmwit> let is fine
23:18:36 <ablmf> cjs: I don't quite get "drop the primes"
23:18:49 <dmwit> He's just suggesting that you use the names "len" and "sum" instead of "len'" and "sum'".
23:19:09 <ablmf> OK, thx!
23:20:27 <cjs> Right. There is a 'sum' function in the prelude, but one defined "locally" (in a let or where) will take precedence.
23:41:05 <xle> Functions dont have an instance for read, do they?
23:41:30 <monochrom> They don't.
23:44:39 <dankna> bah
23:44:49 <dankna> so I have an array of about a million elements
23:44:57 <dankna> I need to visit and update all of them
23:45:02 <dankna> this takes about ten seconds on my machine
23:45:05 <dankna> I would like it to take less :)
23:45:09 <kmc> update in-place?
23:45:14 <dankna> I suspect I'm doing something stupid and consy
23:45:15 <kmc> you're using some kind of MArray?
23:45:20 <kmc> err, arrays don't cons
23:45:25 <dankna> I'm using an IOArray, yes, though I'm not adverse to other solutions
23:45:37 <kmc> can you hpaste the code?
23:45:40 <dankna> well, yeah, I certainly don't see how I'm consing if I am
23:45:42 <dankna> oh, sure!
23:45:59 <kmc> perhaps you are stuffing unevaluated thunks into you array when you'd rather force evaluation
23:46:33 <dankna> that sounds like the sort of mistake I was hoping someone could find me making, certainly :)
23:46:36 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=17094#a17094
23:46:55 <dankna> I'm aware of mapArray; I'm not using it because the next step after this works fast enough is going to need to look at adjacent cells.  just by the way.
23:49:58 <kmc> well it's a stab in the dark, but try replacing «writeArray terrain location cell'» with «cell' `seq` writeArray terrain location cell'»
23:50:05 <kamatsu> dankna: your project looks cool
23:50:12 <kamatsu> combustion :D
23:50:30 <dankna> kmc: hmmmm okay, one sec
23:50:50 <dankna> kamatsu: thanks.  it's an RPG, actually.  I came up with a cool game mechanic that needs semi-realistic fire propagation to work.
23:51:10 <kamatsu> dankna: can i blow things up?
23:51:16 <kmc> dankna, and also make the cellCombustionStatus field of your record strict
23:51:21 <kmc> by putting a ! in front of its type
23:51:29 <dankna> that's the idea.  but if you do so incautiously, you will set the whole map on fire and lose.
23:51:33 <dankna> kmc: okay, doing that
23:51:52 <kmc> (otherwise, forcing the record to evaluate will not force the field inside)
23:51:56 * dankna nods
23:52:23 <kmc> laziness can be a pain...
23:52:45 <kmc> oh also
23:52:50 <kmc> you are consing
23:52:53 <kmc> you're using mapM not mapM_
23:53:14 <kmc> and so building a big intermediate list of type [()] that gets thrown out
23:53:19 <dankna> oh!
23:53:22 <kmc> i hope ghc is smart enough to avoid that, but it might not be
23:53:30 <monochrom> It doesn't.
23:53:44 <dankna> I bet it's that, actually.  I just tried your suggestion and no dice.  one sec while I try the mapM_
23:53:47 <vegai> oh, if only laziness was optional and not the default :-(
23:54:01 <dankna> I knew there was an intermediate result there, I just didn't think about it too deeply
23:54:24 <kamatsu> vegai: laziness is optional, but it is the default.
23:54:50 <vegai> if somebody asks me for the single worst feature of Haskell, I'd probably have to say laziness
23:54:58 <vegai> yes, that's a bit of a troll, but I also do think so
23:55:12 <pikhq> vegai: ... But that's just silly.
23:55:12 <Berengal> If lazyness isn't the default you might just as well not have lazyness at all
23:55:12 <kamatsu> I disagree, i'd say it's the records
23:55:13 <pikhq> It
23:55:23 <Axman6> yeah, i'd go with kamatsu
23:55:36 <DigitalKiwi> I thought lazyness was one of the strong points of Haskell?
23:55:37 <pikhq> 's like saying "The worst feature of C is being a systems programming language".
23:55:44 <dankna> might possibly be faster than before, it's kind of hard to say
23:55:46 <kamatsu> DigitalKiwi: it is
23:55:54 <pikhq> DigitalKiwi: It's one of the major *points* of Haskell, at least.
23:55:54 <dankna> but it's still slow.  hmm.
23:56:03 <dankna> that's with all three of the changes you suggested in place.
23:56:06 <vegai> discussing this won't probably have any fruitful conclusions, so I'll just refrain from doing that, respectfully ;)
23:56:38 <dankna> is there some sort of profiling tool that would help me track this down?  I don't want to take too much of your time.
23:56:39 <kmc> the records are ugly but not that fundamental
23:56:42 <kamatsu> there are a variety of positives to laziness by default
23:56:47 <kmc> laziness is fundamental and is a big tradeoff
23:57:00 <kmc> i think it's consistent to say that it's one of the strong points and also one of the biggest flaws
23:57:36 * Cale doesn't consider it a flaw at all.
23:57:44 <kmc> dankna, the ghc manual describes its profiler.  i'm not sure if it will help you
23:57:58 <dankna> okay.  well, it's a place to start, and thank you for your efforts.
23:58:23 <kamatsu> dankna: thank you, come again
23:59:10 <monochrom> pure + eager forces on you slow algorithms. pure + lazy enables some faster algorithms as shown by Okasaki. Of course, no doubt, impure + eager gives you the fastest algorithms, but my moral is as soon as you have eager you throw pure out.
23:59:43 <kamatsu> I agree with monochrom
