00:10:07 <mreh> found a bug in ghc
00:11:03 <mreh> warnings are raised when you bind a function argument to a pattern, it thinks you haven't used that binding
00:11:52 <copumpkin> for example?
00:11:53 <ddarius> I don't understand what you mean.
00:13:40 <mreh> I have defined a HOF, but the pattern bound to it in the definition is flagged as not being used by GHC
00:14:00 <mreh> the pattern bound to the functional argument, that is
00:14:24 <mreh> foo :: (bar -> baz) ; foo quux = quux 7
00:14:36 <copumpkin> is that the actual code that generates the warning?
00:14:37 <mreh> quux is the binding to the functional argument
00:14:49 <mreh> copumpkin: no, it's in a record structure
00:15:00 <mreh> i'll see if I can recreate it
00:15:05 <Cale> That type signature can't possibly be right ;)
00:15:06 <copumpkin> I can see if I can reproduce it if you give me a minimal test
00:15:15 <mreh> 7 :: bar :D
00:15:19 <nolrai_FG> @hoogle unsafe
00:15:19 <lambdabot> Language.Haskell.TH unsafe :: Safety
00:15:19 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
00:15:19 <lambdabot> module Data.ByteString.Unsafe
00:15:20 <copumpkin> Cale: it could!
00:15:35 <nolrai_FG> @hoogle unsafePerfromIO
00:15:35 <lambdabot> No results found
00:15:37 <copumpkin> actually it couldn't in that form I guess :P
00:15:46 <nolrai_FG> @hoogle performUnsafeIO
00:15:47 <lambdabot> No results found
00:15:54 <copumpkin> foo :: (bar -> baz) -> baz; foo quux = quux 7 could probably work
00:15:59 <Cale> @hoogle unsafePerformIO
00:16:00 <lambdabot> Foreign unsafePerformIO :: IO a -> a
00:16:00 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
00:16:18 <mreh> yes, okay
00:16:38 <Cale> Except that bar needs an extra constraint
00:16:51 <copumpkin> not with incoherentInstances and a terrible Num instance, I think
00:17:00 <Cale> heh
00:17:11 <mreh> I don't have any compiler directives on
00:17:21 <mreh> it's just pattern matching on a record structure
00:19:10 <mreh> I hope I win something
00:19:19 <copumpkin> you gonna show us? :P
00:19:28 <mreh> oh, yes
00:28:01 <mreh> It's a bit more specific that I thought
00:28:10 <mreh> it's in a do block in a "let"
00:28:15 <mreh> i'll try that
00:33:15 <mreh> no, can't replicate it
00:33:24 <tumult> :)
00:33:34 <dolio> I, for one, am surprised.
00:33:56 <copumpkin> mreh: show us the original code then?
00:34:19 <mreh> copumpkin: I tell you what it was, me being stupid
00:34:33 <ddarius> My money is usually on the compiler being right.
00:34:34 <mreh> editing code and reading off the warnings, of course the line numbers changed
00:34:36 <tumult> there should be a rule, "it's not a compiler bug"
00:34:51 <mreh> :D~~~~
00:35:16 <copumpkin> there was something on reddit just recently about it
00:35:42 <copumpkin> not that I read reddit or anything
00:36:59 <allbery_b> "you're not cool enough to find compiler bugs"
00:37:22 <tumult> yes. i have never found a compiler bug :(
00:37:33 <tumult> just bugs in myself. it's zen
00:38:01 <ddarius> Oh, I've definitely run into compiler bugs, but usually they are reported or not very unexpected.
00:38:25 <allbery_b> s/find/discover/
00:38:44 <ddarius> Also, they usually didn't cause bad code to run.  Usually it's library bugs that lead to bad code executing.
00:39:34 <allbery_b> I've been known to find them, but not in GHC or Haskell.  discovered a couple gcc optimizer bugs BITD, and one Solaris linker bug
00:52:08 <copumpkin> > 0**0 :: Double
00:52:09 <lambdabot>   1.0
00:54:42 <Vitka> > 3**2.5
00:54:44 <lambdabot>   15.588457268119896
00:54:56 <ziman> > map (0**) [-2..2]
00:54:57 <lambdabot>   [Infinity,Infinity,1.0,0.0,0.0]
01:04:41 <o-_-o> I am finding things about haskell on buzz
01:04:51 <o-_-o> I searched for buzz and some blog posts came up
01:05:02 <o-_-o> One by TacticalGrace
01:05:16 <copumpkin> TacticalGraceNotes
01:12:47 <sizur> Hi all.  I'm trying to install HXT on Haskell Platform and I dont understand what "base-4.2.0.0 was excluded because of the top level dependency base -any" means
01:13:27 <jrockway> run with higher verbosity
01:15:03 <sizur> hpaste is bloken
01:15:06 <sizur> broken
01:16:01 <sizur> http://pastebin.com/d1773d7aa
01:17:05 <jrockway> see also: http://osdir.com/ml/haskell-cafe@haskell.org/2010-01/msg00313.html
01:18:14 <jrockway> looks like you need 8.3.2 instead of the latest version if you are on ghc 6.10
01:18:25 <sizur> jrockway: doesnt the latest platform come with base-4.2?
01:19:12 <jrockway> my machine has 4.1.0.0
01:19:32 <sizur> jrockway: thanks, that version is being compiled right now
01:20:23 <jrockway> base, or a new ghc?
01:21:28 <Phyx-> hmm.. is there an easy way to convert a Char into a CWchar?
01:21:53 <sizur> ugh, now i get http://pastebin.com/d6b531ac5  i guess no hxt and janus for me until the next platform
01:22:06 <jrockway> Phyx-: fromIntegral?
01:22:38 <Phyx-> jrockway: intresting, thanks
01:22:55 <jrockway> > (fromIntegral (ord 'x')) :: CWchar
01:22:56 <lambdabot>   Not in scope: type constructor or class `CWchar'
01:23:03 <jrockway> well, that would work if it had foreign.c.types :)
01:23:20 <jrockway> now, whether that's the right character or not, i don't know
01:24:09 <jrockway> ah, much better: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html#v%3ApeekCWString
01:24:14 <jrockway> peekCWString is probably what you want
01:24:31 <Phyx-> but that creatsa a string not a single char
01:24:48 <jrockway> it uses cWcharsToChars
01:25:09 <jrockway> ah, which uses fromIntegral
01:25:13 <jrockway> so i am right :)
01:25:35 <jrockway> seems unusual to only have one character though
01:26:06 <Phyx-> jrockway: well i'm modifying the lexer, creating storable instances for a few things so can call them through FFI
01:26:17 <Phyx-> and one of the has a single char as value of a token
01:27:16 <jrockway> cool
01:27:37 <jrockway> just have to do my "irc due diligence" so that someone doesn't reimplement half of Foreign.C.String in their own app :)
01:28:14 <Phyx-> hehehe, I'm not, all I did was implement a tool to automate the boring step of creating the instances
01:28:32 <Phyx-> but it relies on a typeclass to know how to convert back and from the types
01:28:59 <c_wraith> well, I didn't expect that...  After distillation of my test ideas, I ended up with a system that can be fit into quick check neatly.  I just need to write an Arbitrary instance for my "operation sequence" type, rather than figuring out how to make a coherent Arbitrary instance for my data structure
01:29:59 <jrockway> arbitrary instances for data structures are pretty easy, though
01:30:21 <jrockway> arbitrary = liftM* MyData (arbitrary) ...
01:30:30 <Phyx-> jrockway: the other one I can't seem to find is between Rational and CLLong, if you know that one too it'll surely help me out, lol
01:30:54 <c_wraith> jrockway: that doesn't work when there are structural rules that aren't enforced by the type system
01:31:37 <jrockway> well, you just need to be more selective in that case
01:31:43 <jrockway> choosing from a list, etc.
01:32:15 <Phyx-> hmmm, actually that should probably be a CDouble
01:32:36 <jrockway> Phyx-: my hack for CDouble -> Double is something like encodeFloating/decodeFloating or something
01:33:42 <ezyang> which cabal package contains control.comonad?
01:33:48 <jrockway> > uncurry encodeFloat (decodeFloat (42.0 :: CDouble)) :: Double
01:33:48 <lambdabot>   Not in scope: type constructor or class `CDouble'
01:33:50 <Phyx-> jrockway: can't i use toRational and fromRational in this case?
01:34:02 <jrockway> for "double"?
01:34:11 <Phyx-> for Rational -> CDouble
01:35:00 <ezyang> :info Control.Comonad
01:35:44 <jrockway> just fromRational, right?
01:36:24 <ezyang> hmm? "cabal: dependencies conflict: ghc-6.10.4 requires directory ==1.0.1.0 however directory-1.0.1.0 was excluded because ghc-6.10.4 requires directory ==1.0.0.3"
01:36:31 <Phyx-> well, i need to provide it both conversions,
01:36:33 <Phyx-> back and forth
01:36:38 <Phyx-> since it needs to read it back in too
01:36:52 <jrockway> someone needs to write numberCast :: a -> b :)
01:37:04 <ezyang> looks like category-extras
01:37:14 <jrockway> but yeah, CDouble has toRational
01:37:39 <Phyx-> cWcharsToChars  isn't exported... guess i need to modify the export list of Foreign.C.String
01:38:26 <jrockway> easier said than done, but it's just fromInegral . ord
01:38:48 <jrockway> i would probably cut-n-paste instead of change something in "base"
01:39:51 <Phyx-> that's true
01:45:05 <Phyx-> well it compiles, thanks jrockway
01:45:07 <jrockway> cool
01:45:21 <ezyang> Hmm, anyone in the mood for cabal debugging?
01:45:35 <jrockway> ezyang: if you're talking about the problem above, it seems obvious
01:45:42 <jrockway> the module is too new for your version of GHC
01:45:46 <ezyang> ohhh
01:46:45 <ezyang> hmm, but I should be able to manage "array, base (>3), ghc (>=6.9), mtl (>=1.1) or array, base, ghc (<6.9), mtl (>=1.1)"
01:46:55 <ezyang> I'm trying to install category-extras
01:47:26 <jrockway> run with -v and see what needs that new version of directory
01:55:10 <ezyang> I get
01:55:18 <ezyang> http://pastebin.com/m6b679b9f
01:56:03 <jrockway> something's broken
01:56:11 * ezyang sighs 
01:56:13 <ezyang> "again?"
01:56:50 <jrockway> FWIW, it installs fine on my 6.10.4 install
01:58:03 <jrockway> i think it's a cabal bug where it installs unnecessarily-new versions of packages, and that breaks everything
01:58:18 <jrockway> i remember accidentally installing bytestring > than 6.10.4's bundled version
01:58:23 <jrockway> everything became very broken
01:58:36 <jrockway> i think it was on windows and i just trashed the entire install after being unable to fix it manually with ghc-pkg
01:58:50 <jrockway> rm ~/.cabal and be more careful ;)
01:59:05 <ezyang> this is the second time I've had to do this :-(
01:59:40 <jrockway> are you doing anything unusual?
02:01:45 <ezyang> not that I can think of.
02:02:02 <ezyang> although I do install an eclectic set of packages
02:03:27 <jrockway> i think the problem comes from explicitly requesting to install a core package that you already have
02:03:36 <jrockway> IIRC, this is fixed in the newest cabal
02:03:38 <jrockway> but it is 6.12 only
02:03:47 <ezyang> cabal-install version 0.6.4 using version 1.6.0.3 of the Cabal library
02:03:49 <ezyang> aha
02:03:56 <ezyang> ok, I guess I should find a 6.12 ppa?
02:05:11 <jrockway> "Stop! For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes GHC 6.10.4 as well as some other tools (such as cabal), and a larger set of libraries that are known to work together. This initial 6.12.1 release is aimed primarily at package maintainers and early adopters."
02:05:15 <ezyang> hmm, that prolly will cause more problems
02:05:16 <jrockway> YMMV.
02:05:30 <jrockway> this wording was strong enough to dissuade me
02:05:41 <jrockway> basically, don't say "cabal install directory" or "cabal install bytestring" and you should be OK
02:05:53 <ezyang> so, when you do cabal install -v category-extras, what do you see?
02:05:59 <ezyang> I'm going to try to manually fix the metadata
02:07:25 <jrockway> too late, it is too far back in my scrollback
02:07:30 <jrockway> but basically, it installs fine
02:07:45 <jrockway> (because i did not upgrade "directory")
02:08:40 <ezyang> ok, so the fact that I have 1.0.1.0 directory is a problem
02:10:59 <jrockway> so says the error message
02:14:09 <ezyang> Wat. cabal: cannot configure category-extras-0.53.5. It requires ghc >=6.9
02:16:13 <jrockway> did you hide ghc?
02:17:54 <ezyang> trying to expose it doesn't help
02:18:49 <jrockway> dunno what to tell you, you messed with the package database and now it's broken :)
02:18:53 <jrockway> restore from your backup and try again
02:19:16 <ezyang> bye bye .cabal directory. was nice knowin ya
02:20:00 <jrockway> yeah
02:23:10 <fasta> Why does CReal have this ridiculous definition? toRational _ = error "CReal.toRational"? Yes, I know that not all reals are rational.
02:23:42 <fasta> It even has  -- toRational x@(CR x') = x' n % 2^n where n = digitsToBits digits in the line above.
02:24:10 <ezyang> uh oh configure: error: Your installation of ghc does not appear to work.
02:25:14 <o-_-o> it seems there is a monad for everything in haskell
02:25:16 <jrockway> LOL
02:25:23 <jkramer> Hello
02:25:29 <o-_-o> can monads make me coffee ?
02:25:35 <jrockway> (that lol is directed at all 3 of the preceding messages, btw)
02:25:36 <kmc> it's undecidable whether a real (represented as CReal does) is rational
02:25:37 <jrockway> talk about reuse!
02:25:39 <jkramer> I'm having a little problem with laziness
02:25:53 <jkramer> This one works fine: main = getContents >>= \ t -> getArgs >>= run t
02:25:54 <jrockway> jkramer: coffee.
02:25:59 <jkramer> While this one does nothing: main = liftM2 run getContents getArgs
02:26:37 <kmc> what's the type of run?
02:26:40 <ben> @type liftM2
02:26:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:26:47 <o-_-o> http://www.reddit.com/r/programming/comments/aje5b/functional_programming_doesnt_work_and_what_to_do/c0hw82i
02:26:51 <o-_-o> http://www.reddit.com/r/programming/comments/aje5b/functional_programming_doesnt_work_and_what_to_do/c0hwdqp
02:26:52 <jkramer> run :: String -> [String] -> IO ()
02:27:06 <fasta> kmc, it is semi-decidable.
02:27:10 <jrockway> :t hGetContents
02:27:11 <lambdabot> Not in scope: `hGetContents'
02:27:18 <ben> @hoogle Monad m => (a -> b -> m c) -> m a -> m b -> m c
02:27:18 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
02:27:18 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
02:27:18 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
02:27:22 <ben> welp
02:27:46 <kmc> jkramer, one thing to watch out for is writing stuff that ends up using (>>) for the ((->) e) monad, when you think it's in the IO monad or similar
02:27:56 <kmc> not sure that's what's going on here
02:28:00 <jrockway> o-_-o: graenwolf is a known troll
02:28:09 <jrockway> he is one of the reasons i stopped reading reddit a few years ago
02:28:12 <o-_-o> jrockway, ah
02:28:23 <o-_-o> jrockway, I just started with reddit
02:28:26 <ben> jkramer: Can you say :t main?
02:29:01 <jrockway> my advice is to not read the comments
02:29:06 <jrockway> like anything, there is sometimes something good
02:29:06 <o-_-o> it is amazing how patient the haskell folks are on reddit
02:29:14 <jrockway> yeah; waste of time
02:29:21 <fasta> kmc, or in other words: there are a lot of cases in which it could do something useful.
02:29:26 <jrockway> these people are trolling, they don't actually want to be educated
02:29:27 <dolio> I'm not sure he's a troll. He's just blinded by VB, or something along those lines.
02:29:36 <o-_-o> jrockway, but the comments by haskellers are interesting, I find so many interesting tidbits in there
02:29:39 <kmc> Visual Blub
02:29:42 <o-_-o> VB ?
02:29:44 <jkramer> ben: What do you mean? Load it in ghci?
02:29:47 <ben> Yeah
02:29:49 <jrockway> skip the reddit comments and just read their blogs directly
02:29:56 <o-_-o> but he talks about FP in VB
02:30:02 <jrockway> the bad outweighs the good
02:30:07 <jrockway> you will just become angry and bitter
02:30:09 <jrockway> or, i did
02:30:34 <fasta> That blog is worthless, IMHO.
02:30:46 <jrockway> reddit?
02:30:49 <jkramer> Ahhh
02:30:50 <jrockway> (is a social news site, not a blog)
02:30:53 <jkramer> main :: IO (IO ())
02:31:02 <jrockway> nice
02:31:15 <kmc> main = join main ;)
02:31:26 <kmc> i think it'd be nice if main were required to have type IO ()
02:31:27 <fasta> Read this instead: http://blog.computationalcomplexity.org/
02:31:50 <jkramer> 'join $ liftM2 run getContents getArgs' works :)
02:31:52 <jkramer> Thanks a lot
02:31:58 <jkramer> I'd never found that myself
02:32:18 <fasta> jrockway, I was talking about the blog post which is referred to by reddit referred to in this chat.
02:32:24 <jrockway> ah
02:32:39 <jrockway> i just clicked it and realized it was a known troll from the layout
02:33:02 <jrockway> "i don't want to learn anything, therefore everything i don't know is bad"
02:33:05 <jrockway> typical "programming blog"
02:33:22 <jrockway> (hate to sound elitist and dismissive, but... lately i have gotten tired of this sort of blog post)
02:33:34 <o-_-o> yes
02:34:28 <o-_-o> most of the posts in r/programming are like this, FP doesn't work, why learning haskell is bad for your brain, stuff like that
02:34:55 <jrockway> a friend made a shirt that says, "shut the fuck up and write some code"
02:34:59 <jrockway> more people should take that advice
02:35:01 <medfly> hehe
02:35:04 <o-_-o> and we have dons/godofpumpkins and other patiently arguing the haskell case
02:35:12 <o-_-o> jrockway, haha
02:35:12 <medfly> why would people bother
02:36:40 <ezyang> dammit, I broke my ghc installation
02:36:43 <Phyx-> whoops, nothing like thinking you're almost done and finding a bug you should have seen coming at the last moment
02:38:02 <jrockway> did you install stuff globally instead of into your homedir?
02:39:08 <ezyang> I... think so?
02:39:09 <fasta> Is there a way to sort vectors by their angle with y=0 without actually computing their angle (that is without generating irrational numbers)?
02:39:14 <ski> kmc : yes; also there should be an `ignore :: forall f a. Functor f => f a -> f ()'
02:39:15 <ezyang> but my global ghc install is sad now
02:39:16 <jrockway> well, that's bad :)
02:39:47 <jrockway> "nuke the site from orbit.  it's the only way to be sure."
02:40:08 <ezyang> ahhh, there we go
02:40:09 <jrockway> and next time, don't give yourself write permission to the global install
02:40:12 <ezyang> .ghc was making me sad
02:40:17 <gogonkt> estimated>22500000< Inbox 2.0 Makes Me Sad http://techcrunch.com/2007/11/14/inbox-20-makes-me-sad/
02:40:21 <ezyang> go go gadget
02:41:52 <Phyx-> hah
02:42:06 <Phyx-> this is where my Tom Clancy's End War training comes in handy
02:42:10 <ski> @type \f ma mb -> join (liftM2 f ma mb)
02:42:11 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
02:42:11 <ski> @type \f ma mb -> ma >>= (mb >>=) . f
02:42:12 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
02:42:23 <Phyx-> "WDM, Attack Hostile ezyang's cabal"
02:42:53 <ezyang> wow, my other cabal install is pretty sad too: "cabal: failed to parse output of 'ghc-pkg dump'"
02:43:09 <Phyx-> wrong cabal with wrong ghc version?
02:43:15 <ezyang> although in this case I know why :-)
02:43:20 <ezyang> wrong cabal, yep
02:43:52 <Phyx-> @hoogle ParseResult
02:43:53 <lambdabot> Language.Haskell.ParseMonad data ParseResult a
02:43:53 <lambdabot> Language.Haskell.Parser data ParseResult a
02:44:12 <ezyang> hmm, actually
02:44:38 <Phyx-> i'm pretty sure i don't import those...
02:44:47 <ezyang> what the fuck
02:44:54 <ezyang> how am I on ghc 6.12 on this other computer
02:45:04 <Phyx-> ah, it's in lexer.x
02:46:21 <ezyang> I, uh, just don't take good care of my Haskell installations, do I :-(
02:46:38 <Phyx-> they'll leave you if that keeps up
02:49:01 <ski> @type joinAp
02:49:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> m a -> m b
02:49:13 <ski> any suggestion for a better name ?
02:49:58 <ski> @type \f ma mb mc md -> return f `ap` ma `ap` mb `ap` mc `joinAp` md
02:49:59 <lambdabot> forall a a1 a2 a3 (m :: * -> *) b. (Monad m) => (a -> a1 -> a2 -> a3 -> m b) -> m a -> m a1 -> m a2 -> m a3 -> m b
02:50:54 <Phyx-> boy, using regexpr for hilighting of Haskell sure fails epicly at times
02:51:24 <ksf> Phyx-, you can use yi if you want
02:51:25 <ezyang> ehe, cabal-install isn't compatible with 6.12 yet
02:51:46 <ksf> it is
02:51:50 <ksf> ...at least preliminary
02:52:01 <Phyx-> ksf: is it available on windows?
02:52:06 <Phyx-> ezyang: the darcs one is
02:52:07 <ksf> get 0.8.0
02:52:19 <ezyang> ah, ok.
02:52:30 <Phyx-> think i'm using 0.9 myself
02:52:31 <ezyang> more fun errors: "The mtl-1.1.0.2/Setup script does not exist or cannot be run"
02:52:32 <ksf> yi should run on windows if you can get the gtk frontend running
02:52:37 <ksf> vty won't work, of course
02:52:42 <ksf> or maybe use cygwin
02:53:07 <Phyx-> problem with cygwin is that it'll only allow one version of the dll to be loaded in memory at a time
02:53:16 <Phyx-> so i usually can't be on irc and do something else
02:53:39 <Phyx-> <-- irssi
02:54:04 <ksf> well, if in doubt, get an X server and ssh to your homebox.
02:54:23 <alex404> How is yi, anyway?
02:54:30 <alex404> I'm intrigued
02:54:39 <ksf> great, but a bit immature
02:54:46 <ksf> actually, it's mature, but not very complete
02:55:02 <Phyx-> anyone here ever use Leksah?
02:55:03 <alex404> Interesting... I'm a vim guy, so I don't need a huge amount of features
02:56:02 <ksf> that reminds me... I wanted to hack on yi to make the ex mode something you can call ex mode without dying of shame
02:56:07 <ezyang> ewww
02:56:31 <ezyang> So, gtk2hs packaged by karmic requires mtl, but if haskell platform detects mtl is installed it messes up and breaks the install script
02:56:56 <Phyx-> heh, is cabal 0.9 compatible with 6.13? i grabbed the wrong source build damnit, don't want to remodify everything again
02:57:01 <ksf> ezyang, fix the dependency to the installed version?
02:57:31 <ezyang> Right, but the dep is for an Ubuntu package, not a cabal package
02:58:15 <ksf> gragh don't use debian or any of its kin if you want to develop haskell
02:58:24 <ksf> ...or at least install your own stuff locally.
02:58:37 <jrockway> debian's stuff works fine
02:58:39 <ezyang> I was lazy and didn't want to compile gtk2hs from source :-)
02:58:40 <jrockway> what problems have you had?
02:59:13 <ksf> does debian stabe come with ghc 6.8, by now?
02:59:35 <ezyang> Ubuntu Karmic comes with 6.19
02:59:37 <ezyang> *6.10
02:59:42 <Phyx-> wee it is, seems the 6.13 snapshot I have hasn't changed the package.conf file :)
02:59:58 <jrockway> no developer uses debian stable
03:00:01 <eevar2> debian testing still has 6.8 as far as i can tell
03:00:02 <jrockway> that is a server OS
03:00:27 <ski> @type let ($<) = liftM; (<$<) = ap; (<$<<) = joinAp in \f ma mb mc md -> f $< ma <$< mb <$< mc <$<< md
03:00:27 <lambdabot> forall a1 a a11 a2 (m :: * -> *) b. (Monad m) => (a1 -> a -> a11 -> a2 -> m b) -> m a1 -> m a -> m a11 -> m a2 -> m b
03:00:30 <galdor> jrockway: well I'm happy I don't use debian for my server; running haskell softwares means having recent verwsions
03:01:12 <jrockway> i compile the binaries on my local machine and then copy to the server
03:01:20 <jrockway> anyway, debian unstable has the haskell platform
03:01:28 <jrockway> i use it, it works great, and saves me much time over doing everything manually
03:01:33 <jrockway> when you do things manually, you waste your time, not mine
03:01:36 <jrockway> so go ahead :)
03:01:39 <ezyang> hm, I wonder if gtk2hs screwed me over previously
03:01:40 <galdor> your choice :)
03:02:19 <Alpounet> ksf, yeah, debian stable provides 6.8
03:04:11 <Phyx-> "*** This will be an error in GHC 6.14! Fix your code now!"
03:04:13 <Phyx-> loool
03:06:16 <ezyang> yay, category-extras is /finally/ installing
03:06:54 <jutaro> Phyx-: I use Leksah
03:07:08 <Phyx->  jutaro how is it?
03:08:04 <ezyang> g'night folks
03:08:31 <jutaro> For me very helpful.
03:08:44 <jutaro> But I'm one of the developers.
03:09:00 <Phyx-> oh dag nabit, ghc paniced
03:09:14 <jutaro> The next release will be a big step forward.
03:09:57 <Phyx-> jutaro: in what way?
03:10:08 <Alpounet> jutaro, yeah, tease us
03:10:50 <jutaro> We have workspaces, so that you can work on mutiple projects, it builds and installs everything as needed, you can search in all different scopes.
03:11:42 <Alpounet> e
03:11:48 <jutaro> Then we will have more accurate metadata, specially for your current workspace. And we have fixed a lot of bugs...
03:11:56 <Phyx-> does it use .cabal files as project files?
03:11:59 <Alpounet> *eh, seems promising
03:12:46 <jutaro> It's still a problem to make evrything easy to install and make it work "out of the box"
03:13:37 <Phyx-> well that's odd.... ghc gives a panic on case sensitive filesystems when a file isn't found, maybe it's just this build
03:13:44 <jutaro> Yes, Leksah use .cabal files for projects. We have a visual editor for cabal files, but it is not working for projects with configurations.
03:13:53 <Phyx-> aha
03:13:54 <Phyx-> cool
03:14:35 <fasta> jutaro, I sent a patch such that it works out of the box on 6.10.4, but I got no answer from anyone.
03:14:52 <o-_-o> cabal: cannot configure leksah-0.6.1. It requires glib >=0.10, gtk >=0.10 and
03:14:52 <o-_-o> gtksourceview2 >=0.10.0
03:14:54 <Phyx-> "Invalid type signature; perhaps you meant to use -XForeignFunctionInterface?" <-- that seems friendlier then what it had doesn't it?
03:14:58 <fasta> jutaro, the wiki contains a link to a darcs repo which doesn't work.
03:15:01 <o-_-o> There is no available version of glib that satisfies >=0.10
03:15:15 <fasta> o-_-o, you failed at reading the documentation.
03:15:15 <o-_-o> jutaro, help ? :-)
03:15:22 <jutaro> fasta: Sorry, that's my fault. Really no answer at all?
03:15:31 <fasta> jutaro, no.
03:15:33 <o-_-o> fasta, I did cabal install leksah :-)
03:15:49 <fasta> o-_-o, yes, I understand, but cabal install is not a miracle device.
03:16:03 <jutaro> fasta: It was per e-amil or it is on the bug tracker?
03:16:03 <fasta> o-_-o, you need to install gtk2hs separately.
03:16:11 <fasta> jutaro, info@something
03:16:15 <fasta> jutaro, email
03:16:33 <fasta> jutaro, via darcs send.
03:16:53 <o-_-o> fasta, using cabal ?
03:16:55 <fasta> jutaro, I tried to use it on my project, but it didn't work.
03:17:04 <fasta> o-_-o, no, not using cabal.
03:17:20 <fasta> o-_-o, the author of cabal decided not to cabalize gtk2hs.
03:17:25 <o-_-o> fasta, ok, but I use fedora
03:17:29 <o-_-o> fasta, ok
03:17:38 <jutaro> fasta: how can I identify your mail?
03:17:40 <fasta> Not because he doesn't want to, but because of lack of resources.
03:18:09 <o-_-o> fasta, ok
03:18:10 <fasta> jutaro, I assume that darcs send has some standard format?
03:19:02 <jutaro> fasta: But what's your sender adress?
03:19:45 <fasta> jutaro, I just sent you a private message saying that.
03:20:05 <jutaro> the gtk2hs team currently works to make gtk2hs cabal installable. So we can hope its getting much easier in the near future.
03:20:52 <jutaro> fasta: Ok, but the name was not fasta
03:21:23 <fasta> jutaro, no, it wasn't.
03:23:29 <jutaro> fasta: Can't find your mail, sorry. I had a problem with converting my mails at some points and lost some mails. So maybe yours was in this. Can you resend it please.
03:24:33 <fasta> jutaro, which email address?
03:24:54 <jutaro> info@leksah.org will do
03:25:03 <fasta> jutaro, also, can I recommend to get the project infrastructure in place first?
03:25:40 <fasta> jutaro, Successfully sent patch bundle to: info@leksah.org.
03:27:31 <jutaro> fasta: I changed the structure of the development repos a weak ago or so. (Leksah has been split into client and server part). Since it is quite buggy I have not posted to the mailing list. But I can forward you the mail, how you can build and run the newest Leksah from the repos.
03:28:45 <fasta> jutaro, please do.
03:29:41 <fasta> jutaro, if you want more people to use Leksah, I recommend you do a Youtube video demonstrating that the debugger works. It doesn't have to be long, just show that it is better than using just the ghci debugger interface.
03:30:30 <fasta> jutaro, and while GTK2HS still takes "work" to install, you might want to provide a script which fetches the gtk2hs you require and make it Just Work.
03:31:26 <jutaro> fasta: I plan this video for a while, but it is so much to do, and I've concentrated on the core software. But it will come.
03:32:56 <fasta> jutaro, ok, my point is that it is better to make something which does at least one thing clearly better than others.
03:33:06 <jutaro> fasta: Yes, Hamish did this with the Windows installer. But I would prefer we don't have to care about gtk2hs to much, cause our task is big enough.
03:35:33 <jutaro> fasta: Yes, we try this. I guess we are on a good way.
03:35:50 <fasta> jutaro, yes, the server architecture seems like the good way to go.
03:37:02 <jutaro> fasta: Hamish is working to integrate Yi as editor component, but it is not easy and we need help from the yi side.
03:38:24 <jutaro> fasta: With the server architecture we go in the direction of scion. But scion is not powerful enough for Leksah in the moment.
03:38:49 <fasta> jutaro, scion is more hype than code as far as I am concerned.
03:41:45 <jutaro> fasta: Yes, currently scion is not really usable for Leksah.
03:45:53 * hackagebot upload: primitive 0.2.1 - Wrappers for primitive operations (RomanLeshchinskiy)
03:47:54 * hackagebot upload: vector 0.5 - Efficient Arrays (RomanLeshchinskiy)
03:48:54 * hackagebot upload: NoSlow 0.2 - Microbenchmarks for various array libraries (RomanLeshchinskiy)
03:54:57 * hackagebot upload: NonEmptyList 0.0.2 - A list with a length of at least one. (TonyMorris)
03:55:17 <RayNbow> @djinn (Monad m, Functor m) => m a -> (a -> m b) -> (a -> b -> c) -> m c  -- I wonder why djinn cannot realize f
03:55:17 <lambdabot> Cannot parse command
03:55:23 <RayNbow> @djinn (Monad m, Functor m) => m a -> (a -> m b) -> (a -> b -> c) -> m c
03:55:23 <lambdabot> -- f cannot be realized.
03:57:21 <dolio> Because of the way that djinn handles type classes. Monad and Functor shouldn't even be in the environment. They're not useful.
03:57:35 <RayNbow> ah
03:58:16 <dobblego> liftA2 (,) is to zip as ? is to unzip
03:59:54 <RayNbow> @hoogle f (a, b) -> (f a, f b)
03:59:54 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
03:59:55 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
04:00:08 <dobblego> @type strong
04:00:09 <lambdabot> Not in scope: `strong'
04:00:18 <dobblego> @type strength
04:00:19 <lambdabot> Not in scope: `strength'
04:01:01 <RayNbow> btw dolio, is a type like (Monad m, Functor m) => m a -> (a -> m b) -> (a -> b -> c) -> m c mechanically provable?
04:03:19 <Phyx-> @hoogle Message
04:03:20 <lambdabot> Text.Parsec.Error data Message
04:03:20 <lambdabot> Text.Parsec.Error Message :: String -> Message
04:03:20 <lambdabot> Text.ParserCombinators.Parsec.Error data Message
04:03:36 <Phyx-> no... parsec is not imported
04:03:40 <Phyx-> damnit, where is that defined
04:04:40 <dolio> I don't know. Properly handling classes like Monad would require deciding something like second-order propositional logic. I doubt that's doable in general, but I can't say for sure that it's impossible for the specific subset you'd need for the type classes.
04:05:23 <zygoloid> @djinn (forall a. a -> m a) -> a -> m a
04:05:24 <lambdabot> -- f cannot be realized.
04:05:36 <pettter> 'second-order propositional logic'?
04:05:43 <pettter> Are you referring to MSO?
04:05:59 <dolio> I mean you can quantify over propositions.
04:06:41 <dolio> And there are functions from propositions to propositions.
04:06:47 <dolio> And so on.
04:07:02 <dolio> But there's no first-order quantification.
04:07:22 <pettter> so, no predicate logic?
04:07:54 <dolio> Right. Unless you call the Prop -> Props predicates.
04:08:31 <pettter> Hmm..
04:08:49 <dolio> First-order predicate logic corresponds to a variety of dependent types.
04:10:10 <Phyx-> @hoogle SDoc
04:10:10 <lambdabot> No results found
04:11:40 <pettter> I'm not sure if I follow, to be honest, but logic is not my main field
04:12:54 <dolio> First-order predicate logic lets you write stuff like... forall x:Nat. Even x \/ Odd x
04:13:28 <dolio> So, in a type system, you'd have Even : Nat -> Set and the same with Odd.
04:14:06 <pettter> yes, I know first-order predicate logic and monadic seecond-order logic, but I was't aware of propositional variants
04:14:27 <dolio> And then you could quantify over values in a type like in that statement.
04:14:46 <ment> any suggestions for some papers/books/examples on writing (toy) interpreters and compilers in haskell?
04:14:49 <pettter> right
04:15:31 <dolio> Well, I don't know if anyone calls it second-order propositional logic. But that's the best description I can come up with. Wikipedia's article on second-order logic is all about predicate logic, for instance.
04:15:40 <pettter> ment: I faked it by reading the Parsec documentation and knowing a bit of programming language theory
04:16:04 <fasta> dolio, I am pretty sure that nobody does. :)
04:16:29 <dolio> Which confused me, because the sort of polymorphic lambda calculus that Haskell is close to is sometimes called the "second-order polymorphic lambda calculus", or something along those lines, but it isn't like second-order predicate logic.
04:16:54 <pettter> well, lambda calculus is strictly more powerful than logic
04:17:18 <dolio> Actually, Haskell is closer to higher-order polymorphic lambda calculus, but there's a second-order one that's well known.
04:17:39 <dolio> But it's still a higher-order calculus without any first-order quantification.
04:18:32 <ment> pettter: interesting approach. then, any suggestions on compiler (not parser) written in haskell with at least a bit readable source?
04:19:26 <pettter> ment: it was well over a year ago, and I haven't kept up with it.. sorry :-/
04:24:18 * Daerim is in the weird position of missing python when writing haskell, and missing haskell when writing python. Bah!
04:24:40 <Botje> if you're missing python, you're using the wrong gun
04:25:18 <medfly> never happy
04:25:18 <Daerim> not missing python as much as, say, the libraries. Like matplotlib, dicom, etc
04:26:08 <Botje> wasn't there a haskell <-> python bridge?
04:27:15 <Daerim> Botje, well you can call haskell from python, but I'm not sure it's recommended
04:28:29 <cheater> how do you call haskell from python?
04:28:57 <merijn> cheater: Well, it must be possible via FFI, right?
04:29:24 <cheater> FFI?
04:29:34 <merijn> You can call haskell from C and you can extend python with C. So logically it must be possible to call Haskell via C from python. But I'm not sure if there's a more direct way
04:30:00 <cheater> yeah, i'm just wondering how you call haskell from python
04:30:04 <merijn> cheater: The haskell Foreign Function Interface
04:30:08 <Daerim> The python wiki does it with ctypes and FFI
04:30:11 <cheater> not if it's possible
04:30:13 <cheater> :p
04:30:17 <Phyx-> cheater: like merijn said, FFI
04:30:18 <cheater> Daerim: ah ok cool
04:30:49 <cheater> Phyx-, merijn: =)
04:31:29 <Vitka> :t bind
04:31:30 <lambdabot> Not in scope: `bind'
04:31:38 <Vitka> lolwut
04:31:46 <Vitka> @hoogle bind
04:31:46 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
04:31:46 <lambdabot> System.Console.Editline.Readline bindKey :: Char -> Callback -> IO ()
04:31:46 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
04:31:58 <Vitka> :t >>=
04:31:59 <lambdabot> parse error on input `>>='
04:32:03 <merijn> Daerim: If it's any consolation I was considering starting to work on a weird python haskell hybrid (just for hack value) after I finish this compiler course :p
04:32:07 * Vitka sighs.
04:32:22 <merijn> Vitka: You probably want ":t (>>=)"?
04:32:24 <cheater> :t (>>=)
04:32:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:32:36 <Vitka> Right.
04:35:11 <Daerim> merijn, that sounds completely horrible :p A bit like object haskell maybe?
04:35:38 <medfly> mutant Haskell
04:35:51 <medfly> I'd use an imperative language with Haskell-like syntax
04:35:51 <merijn> Daerim: Well, I was more thinking of an imperative language with type inference, proper currying and ADTs
04:36:03 <merijn> And a hybrid of haskell/python syntax
04:37:11 <merijn> I suppose you could call it statically typed python. But I'm not sure it makes sense to still call it python if you remove all the duck/dynamic typing...
04:38:18 * Daerim is wondering how different that would be from the IO monads
04:38:24 <Daerim> *monad
04:39:06 <merijn> No clue, only one way to find out, right? :p
04:40:30 <Daerim> merijn, tell Dons it's a new benchmark on the language shootout?
04:41:25 <merijn> First I'll have to see if I can actually manage to write a compiler for something like that. It's obscenely more complex then anything I've ever done and obscenely more complex then the language we're writing a compiler for in class now :p
04:41:45 * Phyx- jumps with Joy at the undocumented GHC api files
04:42:29 <merijn> On the other hand, there's no time for learning to walk you have to keep running :)
04:42:44 <Daerim> merijn, well writing crude compilers is supposed to be one of the things haskell is good at, no?
04:43:21 <merijn> Daerim: Well, the ADTs look like a match made in heaven for recursive-descent parsing and ASTs
04:44:15 <merijn> I also got some docs from someone for a library to construct haskell ASTs so all you'd have to do is translate the AST for your language to a haskell ADT. (It sounds so simple in theory!)
04:44:50 <Daerim> merijn, heh I'm fairly certain it's beyond my mediocre hacking skills
04:45:13 <merijn> Daerim: I'm trying to get out of that mindset :)
04:46:59 <Daerim> merijn, good idea. Is hould just stop whining and write haskell bindings/libraries for everything I need ;)
04:48:25 <Daerim> *should
04:49:41 <Jafet> ping
04:49:42 <gogonkt> PONG, now at #haskell
04:49:47 <Jafet> Heh
04:50:07 <Phyx-> pong
04:50:12 <Phyx-> what no ping?
04:50:15 <Jafet> Haskell binding to Python sounds easy
04:50:31 <Jafet> data Object -- implementation omitted
04:51:09 <opqdonut> how do I uninstall packages installed with cabal install?
04:53:46 <Phyx-> opqdonut: ghc-pkg unregister
04:53:51 <Phyx-> then just delete the files
04:54:13 <opqdonut> ok
04:56:28 <k23z__> what's the most popular implementation of Haskell ?
04:56:40 <merijn> GHC
04:56:45 <Jafet> Isn't there only one implementation of Haskell?
04:56:50 * Jafet coughs
04:57:01 <k23z__> merijn, oh that's cool
04:57:09 <k23z__> merijn, does that have OpenGL or SDL bindings ?
04:57:32 <merijn> k23z__: How are the binding implementation specific?
04:57:54 <Phyx-> hmm... why do I have a process called "dummy-ghc" running
04:57:58 <merijn> There are bindings for OpenGL I'm sure, but those should work with any haskell implementation
04:59:20 <k23z__> I don't know
04:59:27 <k23z__> I just want to be able to use SDL and OpenGL
05:00:43 <yokto> is there a way (ghc flag or such) to forbid unsafe actions?
05:01:05 <dmwit> nope
05:02:57 <k23z__> what do I need to have to get HOpenGL offline ?
05:03:06 <yokto> so there is no way to run some haskell code in a sandbox
05:03:18 <k23z__> I mean I won't have a net connection there so I need to take stuff on a usb stick
05:03:28 <dmwit> yokto: Take a look at hint, etc.
05:03:45 <dmwit> yokto: You can prevent some modules from being imported, specifically the ones with unsafe operations.
05:04:12 <merijn> yokto: In general running untrusted code and trying to make it safe is a lost cause. Why do you need this?
05:04:18 <dmwit> yokto: Or if you're compiling your own code, you can hide any packages with unsafe code in them.
05:04:51 <yokto> ok i ll have a look at it thx for the "hint"
05:05:17 <ment> where to look for operator precedence table?
05:05:40 <dmwit> ment: Look no further than ghci.
05:05:46 <dmwit> ment: Try :i +, for example
05:05:55 <k23z__> how do I install a package with Haskell ?
05:05:57 <k23z__> do I just write
05:06:05 <k23z__> hackage MakeMeASandwich ?
05:06:15 <dmwit> Yes, but s/hackage/cabal install/
05:06:18 <k23z__> or ... I'm expecting some utility like cpan is for Perl
05:06:27 <k23z__> cabal install Canabis, right ?
05:06:29 <ment> dmwit: great! thanks
05:06:58 <dmwit> k23z__: Be sure to "cabal update" first.
05:07:00 <merijn> I'm assuming infix function (by definition) can only have exactly two arguments?
05:07:03 <Botje> makeMeASandwich :: Either Bool Sandwich
05:07:10 <dmwit> merijn: Of course not.
05:07:25 <dmwit> merijn: Infix functions are not special in any way, except for where they're positioned.
05:08:05 <merijn> dmwit: So f a b c = a `f` b c?
05:08:07 <k23z__> dmwit, can I get cabal packages offline ?
05:08:17 <k23z__> dmwit, so I can install them when I need without net connection
05:08:17 <dmwit> merijn: No, but f a b c = (a `f` b) c
05:08:29 <Saizan> k23z__: you can use cabal fetch for that
05:08:39 <quicksilver> dmwit: they are a bit special, haskell 98 forbids them from being unary, although that may be a bug in haskell98.
05:08:45 <ment> dmwit: hmm what's the priority of argument application? for example, 'a b c ++ d e' ?
05:08:48 <k23z__> ok but suppose I don't have haskell installed right now
05:08:54 <Saizan> k23z__: it'll store them in the package cache under ~/.cabal/packages
05:08:56 <quicksilver> ment: higher than all infix operators.
05:09:05 --- mode: ChanServ set +o quicksilver
05:09:10 <Saizan> k23z__: you can download them from the hackage website too,
05:09:11 <merijn> dmwit: Right, that's what I meant. Currying/priority still trips me up
05:09:21 <Saizan> k23z__: the tarballs are linked from the package page
05:09:34 <ment> quicksilver: thanks
05:10:08 --- mode: quicksilver set -o quicksilver
05:17:55 <ment> hmm [2,4..16] seems to be working as expected, does it have any other variants? (like, [2,3,5,7,11..97])
05:18:15 <Botje> no :P
05:18:42 <Botje> it will just generate 15,19,...
05:18:45 <opqdonut> gah, gitit depends on quickcheck1 and datetime0.2, and datetime0.2 depends on quickcheck2
05:18:48 <opqdonut> conflict...
05:18:51 <opqdonut> should i hide something?
05:19:57 <dmwit> ment: Check the "oeis" package. =)
05:21:27 <Saizan> opqdonut: --constraint="datetime == 0.1" ?
05:21:28 <ment> nice
05:21:53 <opqdonut> Saizan: I'll try that then
05:24:30 <merijn> ment: It only looks at the first 2 numbers to determine stepsize and stepsize must be constant
05:25:40 <dmwit> Of course, you can define your on Enum instance to get whatever behavior you like, but it still only gets to look at at most three numbers.
05:31:42 <k23z__> Botje, :)
05:31:53 <k23z__> Botje, how's Perl and Haskell getting along in your mind ?
05:33:16 <Botje> just fine
05:33:31 <Botje> after the tenth language you learn, keeping them apart is no longer a problem :)
05:34:12 <Twey> Aye
05:34:13 <Botje> and haskell has the most whipuptitude and manipulexity i've ever seen in a statically typed language
05:34:54 <dmwit> You make it sound like you prefer Perl... could it be that we have a traitor in our midst? =)
05:34:55 * Twey laughs.
05:35:36 <Botje> damn! i've been found out!
05:35:47 <Twey> > [2, 3, 5, 7, 11, .. 25]
05:35:48 <lambdabot>   <no location info>: parse error on input `..'
05:35:52 <Twey> > [2, 3, 5, 7, 11 .. 25]
05:35:53 <lambdabot>   <no location info>: parse error on input `..'
05:35:54 <Botje> i'm a dynamically typed imperative pig, it's true :(
05:36:07 <Botje> but i'll go on a pilgrimage to glasgow one day!
05:37:28 <Twey> Haha
05:43:42 <waterlaz> > [2, 3, 5] ++ [7, 11 .. 25]
05:43:43 <lambdabot>   [2,3,5,7,11,15,19,23]
05:44:26 <waterlaz> I guess the list syntax should have been extended a bit
05:45:08 * dmwit disagrees
05:45:25 <waterlaz> what's the problem in allowing  [2, 3, 5, 7, 11 .. 25] ?
05:45:35 <waterlaz> or is it about simplicity?
05:45:45 <int-e> we would expect [2,3,5,7,11,13,17,19,23] ;)
05:45:49 <Arnar> if haskell could do [2, 6, 9, 15 ..] it would do quit well on IQ tests
05:46:01 <Beelsebob> waterlaz: how would you reliably derive the sequence from that?
05:46:12 <Beelsebob> i.e. there are many possible sane sequences
05:46:36 <waterlaz> we don't want a sane sequence
05:46:42 <Philonous1> Beelsebob: Infinitely many, lacking a sane definition of sane
05:46:47 <Arnar> there are even more insane ones
05:46:49 <Beelsebob> I once suggested for example that [n,m..x] should be a linear progression, while [n,m,l..x] should be quadratic, [n,m,l,o..x] should be cubic etc
05:47:01 <quicksilver> @oies 2 3 5 7
05:47:02 <lambdabot>  The prime numbers.
05:47:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:47:05 <waterlaz> you can have an infinite nuber of sane sequences from [1, 3 .. 10]
05:47:13 <Beelsebob> indeed you can
05:47:28 <Arnar> @oies 17 19 23
05:47:29 <lambdabot>  The prime numbers.
05:47:29 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
05:47:32 <Beelsebob> but not many that are "logical" in terms of what a programmer might intend by writing it though
05:47:35 <int-e> [a,b..c] is defined to be enumFromThenTo a b c
05:47:48 <Arnar> the @oies command only gives the top 1 result?
05:48:04 <int-e> you can implement your own enumFromThenTo to do whatever you want, if you're willing to break the enum contract (is there any?)
05:48:17 <waterlaz> [<some numbers>, a, b .. c] should be equvalent to [<some numbers>] ++ [a, b .. c]
05:48:23 <Twey> I would like to be able to do: [1 .. 3, 5 .. 12]
05:48:26 <Beelsebob> int-e: right, but you can't make [a,b,c..d] call enumFromThenSomethingElseTo a b c d
05:48:30 <Beelsebob> which is what's required here
05:48:34 <waterlaz> in fact i've seen this in some language. Don't remember exactly wich one
05:48:41 <int-e> > [0,0.1..1]
05:48:42 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
05:48:47 <int-e> > last [0,0.1..1]
05:48:48 <dmwit> Twey: delete 4 [1..12] ;-)
05:48:49 <lambdabot>   1.0
05:49:08 <dmwit> > last [0, 0.5 .. 12]
05:49:09 <lambdabot>   12.0
05:49:13 <dmwit> > last [0, 0.5 .. 11]
05:49:14 <lambdabot>   11.0
05:49:15 <ment> @oies 2 6 9 15
05:49:15 <lambdabot>  Guaranteed number of primes between m and 2m.
05:49:15 <lambdabot>  [2,6,9,15,21,24,30,34,36,49,51,54,64,75,76,84,90,91,114,115,117,120,121,132,...
05:49:24 <Twey> > [1 .. 3] ++ [5 .. 12] == delete 4 [1 .. 12]
05:49:26 <lambdabot>   True
05:49:29 <Botje> guaranteed?
05:49:33 <fasta> Beelsebob, that sounds like a really bad idea.
05:49:35 <Botje> do you get your money back if it's not the case?
05:49:36 <Twey> Wait what
05:49:39 <Beelsebob> fasta: indeed
05:49:42 <ment> i would definitely fail that question in iq test
05:49:44 <Twey> > ([1 .. 3] ++ [5 .. 12], delete 4 [1 .. 12])
05:49:45 <lambdabot>   ([1,2,3,5,6,7,8,9,10,11,12],[1,2,3,5,6,7,8,9,10,11,12])
05:49:52 <ment> s/in/on/
05:49:53 <Twey> Oh
05:49:54 <Twey> Haha
05:50:06 <dmwit> Twey: =)
05:50:12 <fasta> It is a good idea for HaskellOb, though.
05:50:16 <Twey> I was thinking delete == take
05:50:22 <fasta> The obfuscated variant of Haskell.
05:50:27 <Beelsebob> Twey: how would you distinguish in your syntax between enumFromTo 1 3 ++ 5:enumFromTo 7 11 and enumFromTo 1 3 ++ enumFromThenTo 5 7 11
05:51:14 <waterlaz> you can't
05:51:54 <waterlaz> that also means that this stuff [2, 6, 9, 15 ..] is also ambigious
05:52:19 <int-e> > let extend [x] = repeat x; extend (x:xs) = scanl (+) x (extend (zipWith (-) xs (x:xs))) in extend [0,1,4]
05:52:20 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
05:52:29 <waterlaz> [2, 6, 9] ++ [15..] vs [2, 6] ++ [9, 15 ..]
05:52:37 <int-e> > let extend [x] = repeat x; extend (x:xs) = scanl (+) x (extend (zipWith (-) xs (x:xs))) in extend [2,3,5,7,11]
05:52:38 <lambdabot>   [2,3,5,7,11,22,48,100,192,341,567,893,1345,1952,2746,3762,5038,6615,8537,10...
05:52:58 <ment> btw, is there any way how to get current continuation out of continuation monad (something like callcc (\c -> c c)) ?
05:53:26 <int-e> @type Control.Monad.Cont.callCC
05:53:27 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
05:54:41 <fasta> Can anyone explain to me why it is better to write liftIO $ putStrln "Hi"; lineTo 5 5 then v
05:54:56 <fasta> then putStrln "Hi"; lineTo 5 5
05:55:20 <fasta> Because that is essentially what people advocate.
05:55:26 <benmachine> depends on your context
05:55:49 <benmachine> if you are defining a library function then liftIO can save your user typing
05:55:59 <benmachine> for IO it'll probably get compiled out anyway
05:56:11 <fasta> benmachine, I am talking about programmer efficiency.
05:56:31 <benmachine> which programmer?
05:56:35 <fasta> benmachine, you can also argue that everything of type IO should be of type MonadIO to begin with.
05:56:41 <benmachine> you can argue that
05:56:43 <fasta> benmachine, the Haskell programmer.
05:56:56 <benmachine> yes but I mean
05:57:01 <quicksilver> fasta: unless it takes "callbacks", or anything with IO in a negative position.
05:57:06 <fasta> benmachine, the exporting of symbols is orthogonal.
05:57:07 <benmachine> if you are writing code that other people will use, generalising to MonadIO doesn't hurt
05:57:11 <quicksilver> (contravariant, that is)
05:57:22 <benmachine> if you are writing code you'll use, then do whatever you have to
05:58:15 <dolio> There are people who advocate liftIO instead of things being pre-lifted?
05:58:41 <fasta> dolio, not that I know of, but that is the default.
05:58:50 <dolio> I thought it was just a "that's the way it is" situation, because the IO libraries are separate from the library that provides liftIO and such.
05:59:00 <fasta> dolio, so, while everyone thinks it is a bad idea, it is what we currently have.
05:59:23 <benmachine> oh I am confused about what you are asking
05:59:29 <fasta> In the mean while everyone has their own private lifted version of a subset of the IO functions.
05:59:32 <benmachine> and it is a waste of time de-confusing me
05:59:37 <benmachine> because I need go to shopping anyway
05:59:41 <benmachine> ignore me
05:59:44 <quicksilver> dolio: and there is the contravariant problem
05:59:57 <fasta> dolio, I don't really see this problem.
06:00:11 <fasta> quicksilver, I don't really see this problem.
06:00:35 <fasta> It should simply be impossible to create values of type IO.
06:00:35 <dolio> You can't lift contravariant IO functions with liftIO, you need another combinator (at least).
06:01:02 <fasta> dolio, can you give an example of a contravariant IO function?
06:01:40 <dolio> catch, maybe? I think that's the most common one.
06:02:03 <dolio> You need to have a catch-lifter in the class along with liftIO.
06:02:17 <fasta> :t catch
06:02:18 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
06:02:51 <fasta> The type of catch is wrong too.
06:03:33 <fasta> I don't see a problem if everything has a MonadIO type.
06:05:19 <Phyx-> hmm it actually works
06:05:19 <Phyx-> yay
06:09:42 <dolio> The problem is that I don't think there's a general combinator for lifting functions that take IO arguments. It would have to be like 'lowerIO :: MonadIO m => m a -> IO a', but that's not the sort of thing you can write sensibly for most transformers.
06:10:00 <Baughn> @type foldr local id
06:10:01 <lambdabot> forall a. [a -> a] -> a -> a
06:10:14 <dolio> And the only alternative is to put every function that takes arguments involving IO in the MonadIO class, which would make it giant.
06:12:09 <dolio> Because IO is a dumping ground for tons of stuff.
06:13:18 <Saizan> the question is: is there an HOF taking a callback in IO that can't be rewritten such that it takes a callback in MonadIO m ?
06:13:28 <Saizan> forkIO seems to be a candidate to me
06:13:45 <dmwit> forkIO, definitely -- think StateT s IO
06:14:11 <dmwit> There are some with* functions that wouldn't really work, either.
06:15:43 <dolio> I think you can lift forkIO if it's in the class. It might not do what you expect, though.
06:16:00 <dmwit> http://www.reddit.com/r/haskell/comments/apawq/combining_withxxx_functions_and_monadio/
06:16:06 <dolio> Perhaps I'm wrong, though.
06:16:09 <dmwit> more on combining IO and MonadIO
06:16:10 <fasta> dolio, what exactly is the problem with "to put every function that takes arguments involving IO in the MonadIO class"?
06:16:26 <dmwit> Oh, I just saw the scrollback on where this started.
06:16:28 <dmwit> :t catchError
06:16:30 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
06:16:31 <int-e> ment: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7376#a7376 is an example using callCC to implement a loop.
06:16:37 <dmwit> fasta: Does that type make you feel better?
06:16:55 <dmwit> fasta: Or how about this type?
06:17:05 <dmwit> :t \io m -> join . liftIO $ catch (liftM return io) (return . m)
06:17:06 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> (IOError -> m a) -> m a
06:17:22 <fasta> dmwit, I was referring to the general library state, not one specific example.
06:17:40 <fasta> dmwit, IMHO, it should never be necessary to call liftIO as a user of Haskell.
06:17:54 <dmwit> fasta: Well, the more functions you put in the MonadIO class, the harder it is to implement, i.e. the fewer true instances you have.
06:18:13 <fasta> dmwit, that's not what I meant.
06:18:53 <twanvl> myIOFunction :: MonadIO m => m x;  myIOFunction = liftIO myActualIOFunction
06:18:59 <dmwit> I agree that there are many things with concrete types that should have class-restricted types instead.
06:19:27 <benmachine> things that accept callbacks are fine with those callbacks being IO a
06:19:32 <benmachine> aren't they?
06:19:41 <Saizan> twanvl: the problem is with functions taking IO callbacks
06:19:42 <dmwit> But I think we're getting there; the most obvious low-hanging fruit has been taken.
06:19:50 <dolio> There's nothing wrong with it if you don't mind classes with 50 functions in them.
06:20:04 <benmachine> because you pass a MonadIO callback and it gets IO'd by the instance with liftIO = id
06:20:05 <dolio> Or 20 different classes used to implement various IO functionality.
06:20:08 <fasta> Saizan, I don't see the problem.
06:20:28 <dmwit> benmachine: We want to go the other way. =)
06:20:33 <Saizan> fasta: how would you like forkIO to become?
06:20:41 <fasta> :t forkIO
06:20:42 <lambdabot> Not in scope: `forkIO'
06:20:47 <dmwit> benmachine: We want it to take a (MonadIO io) => io a action, so we can pass other things than IO callbacks.
06:20:55 <Saizan> ?type Control.Concurrent.forkIO
06:20:56 <lambdabot> IO () -> IO GHC.Conc.ThreadId
06:20:57 <benmachine> oh
06:20:59 <benmachine> do we?
06:21:14 <dmwit> benmachine: (But that's admittedly a lot harder, and probably MonadIO isn't the right class for that constraint.)
06:21:18 <fasta> Saizan, MonadIO m => m () -> m  GHC.Conc.ThreadId
06:21:44 <benmachine> fasta: so you're basically proposing that MonadIO contain every IO primitive?
06:21:51 <Saizan> fasta: what should that do for StateT s IO, and how would it do it?
06:22:25 <twanvl> forkIO is not even possible for every MonadIO type
06:22:39 <dmwit> ?instances MonadIO
06:22:40 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
06:22:47 <twanvl> what would forkIO do for  StateT s IO  or ContT r IO?
06:22:49 <fasta> benmachine, ok, I see the point/
06:23:28 <dmwit> twanvl: Well, forkIO could reasonably fork the state as well.
06:23:37 <dmwit> twanvl: It wouldn't *really* be what you want, but it would be something.
06:23:55 <benmachine> so I'd think MonadIO m => IO () -> m ThreadId would be nice
06:24:09 <twanvl> dmwit: but in that case I guess it is better to make that explicit, by forcing you to go down to the actual IO type
06:24:15 <dmwit> I agree.
06:24:18 <fasta> The only logical conclusion is either have a big MonadIO type class or have a type class for every method.
06:24:25 <fasta> E.g. forkIOAble.
06:24:29 <dmwit> Make it hard to share pointers across threads. =)
06:24:33 <fasta> Er Forkable
06:24:41 <benmachine> does forkST make any sense?
06:24:59 <dmwit> benmachine: Only if you like concurrent-access bugs.
06:25:08 <benmachine> I love concurrent access bugs
06:25:08 <Saizan> there is InterleavableIO on hackage
06:25:30 <dmwit> benmachine: Then, boy, have I got a language for you!
06:25:35 <twanvl> would something like this do:  liftIOCallback :: (IO a -> IO b) -> (m a -> m b)  ?
06:25:39 <Saizan> whose haddock is pretty confusing, but helps for some callbacks cases, i don't think it'll help for forkIO though
06:26:10 <Saizan> twanvl: i don't think that works for e.g. catch
06:26:24 <twanvl> ?type Control.Exception.catch
06:26:24 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
06:26:50 <cjs> So, did anybody read the Bertrand Meyer paper in _Beautiful Architecture_?
06:26:52 <twanvl> okay, so add a parameter
06:27:03 <Saizan> benmachine: forkST would make sense if you could guarantee any interleaving produces the same result :)
06:27:18 <twanvl> liftIOCallback :: ((a -> IO b) -> IO c) -> ((a -> m b) -> m c)
06:28:49 <Phyx-> hmm this is odd
06:29:03 <Phyx-> Location 3: 12 to -2013265905
06:29:16 <Phyx-> the values i get from the GHC lexer sometimes overflow
06:29:23 <Phyx-> or maybe they are uninitialized
06:30:54 <dolio> :t \m -> StateT $ \s -> do i <- Control.Concurrent.forkIO (runStateT m s >> return ()) ; return (i, s)
06:30:55 <lambdabot> forall s a. StateT s IO a -> StateT s IO GHC.Conc.ThreadId
06:31:06 <ment> int-e: thanks
06:32:13 <dolio> You can get fancier from there, of course.
06:33:33 <benmachine> > id \x -> x -- why doesn't this work?
06:33:34 <lambdabot>   <no location info>: parse error on input `\'
06:33:45 <benmachine> > id (\x -> x) -- this is fine
06:33:46 <lambdabot>   {()->()}
06:33:53 <Saizan> the grammar is weird like that
06:33:55 <benmachine> > id $ \x -> x -- and this
06:33:56 <lambdabot>   {()->()}
06:34:14 <benmachine> I find the last one especially odd
06:34:14 <Saizan> maybe we should propose a fix for haskell-prime :)
06:34:18 <dolio> Actually, you probably can't get fancier from there without making the forking useless.
06:34:23 <benmachine> it works with infix ops
06:34:51 <benmachine> Saizan: maybe we should!
06:35:13 <benmachine> but I tend to forget
06:35:32 <benmachine> @tell benmachine write a thing about why id \x -> x
06:35:32 <lambdabot> You can tell yourself!
06:35:34 <benmachine> :(
06:35:47 <benmachine> that doesn't even parse as a message
06:35:54 * benmachine makes a mental note
06:35:57 <Arnar> @tell benmachine write a thing about why id \x -> x
06:35:57 <lambdabot> Consider it noted.
06:36:12 <Arnar> ;)
06:36:13 <benmachine> thx
06:36:14 <lambdabot> benmachine: You have 1 new message. '/msg lambdabot @messages' to read it.
06:36:17 <benmachine> *gasp*
06:36:25 <benmachine> hopefully that will remind me later
06:37:10 <Saizan> @tell benmachine check if there isn't already a proposal on haskell-prime's wiki
06:37:10 <lambdabot> Consider it noted.
06:37:43 <cjs> Anybody got a reference to that quote from SPJ about Haskell being the best imperative programming language?
06:37:57 <Saizan> in Agda  id \x -> x  is accepted
06:44:14 <Saizan> if you really need forkIO and MonadState i'd go with ReaderT (MVar s) IO
06:45:45 <quicksilver> fasta: you should read my -cafe post on monadic tunnelling
06:46:09 <fasta> quicksilver, the one that is over 6 months old?
06:46:19 <quicksilver> well over
06:46:22 <quicksilver> several years old, in fact
06:46:37 <quicksilver> but it does explain the general issue with contravariant occurrences of IO in types
06:46:38 <fasta> quicksilver, right, I didn't want to overestimate.
06:46:42 <quicksilver> although I call them 'callbacks'
06:46:50 <quicksilver> which is a rather imperative view of them.
06:46:52 <dmwit> Hm, is there an instance MonadIO m => MonadState (ReaderT (MVar s) m) s?
06:46:52 <fasta> quicksilver, I read it, but I will take another look.
06:46:56 <dmwit> If not, there should be. =)
06:52:41 <endojelly> dmwit, wait, are you sure it's not MonadIO m => MonadState s (ReaderT (MVar s) m), or am I confusing the order in which MonadState is defined, or are you really having another monad as *state*?
06:52:54 <endojelly> dmwit, because otherwise there's: MonadState s m => MonadState s (ReaderT r m)
06:53:23 <dmwit> Oh, I didn't bother checking which order the arguments to MonadState went in.
06:53:30 <endojelly> dmwit, and that seems to satisfy what you want pretty good, because the type of the state (MVar s) shouldn't be important
06:53:34 <dmwit> But the latter means that the one I want can't happen. =/
06:53:36 <zygoloid> cjs: that's a slight misquotation. In "Tackling the Awkward Squad" SPJ says "In short, Haskell is the world's finest imperative programming language."
06:53:53 <dmwit> endojelly: No, it doesn't satisfy what I want. =)
06:54:04 <endojelly> dmwit, :(
06:54:09 * dmwit shrugs
06:54:13 <Saizan> the types don't even match
06:54:16 <dmwit> It's okay, I don't actually have a use for it.
06:54:24 <dmwit> It was just an idle daydream. =)
06:55:40 <endojelly> oh, was making a bad assumption there
06:56:39 <zygoloid> dmwit: sounds like a job for Captain Newtype
06:56:53 <Zeiris> !hpaste
06:57:13 <shambler_> @where hpaste
06:57:13 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
06:57:24 <zygoloid> /topic
06:57:40 <Saizan> it's broken, anyhow
06:57:59 <cjs> zygoloid: Thanks.
07:01:16 <cjs> Ok, my bile about Bertrand Meyer's _Beautiful Architecture_ chapter on "Why FP Fails" has been sufficiently drained by a mere blog comment, so now I will head out for a drink or something.
07:02:24 <fasta> Is there a graphics format which has a good editor, support for just the position of vertices and is easily readable in Haskell?
07:02:36 <cjs> Interesting, though; I'd never realized (despite being a Smalltalk fan for years) how functional Smalltalk really is.
07:03:19 <fasta> cjs, doesn't it use mutable references just about everywhere?
07:03:38 <cjs> fasta: sounds like you want to write an SVG library for Haskell, if there isn't already one.
07:04:03 <fasta> cjs, heh. No I do not want to write a SVG library. :D
07:04:04 <cjs> fasta: Smalltalk? Yeah, that's one of the annoying bits. That, and the early return thing.
07:04:26 <cjs> fasta: It's easy! Really! You won't know until you try!
07:04:40 <cjs> (And also, I need one myself. :-))
07:04:42 <fasta> cjs, Oh, I am sure it is easier than what I am doing right now.
07:04:48 <fasta> cjs, oh, really? ;)
07:05:05 <dmwit> "support for *just* the position of vertices"?
07:05:31 <fasta> dmwit, I want to be able to express things like "position these vertices on the same line".
07:05:49 * cjs gives dmwit a big slap for that one.
07:06:13 <zygoloid> cjs: yeah, it's always seemed very lambda-calculussy to me to have "boolean ifTrue: foo ifFalse: bar" or however that works
07:06:20 <dmwit> fasta: don't know of any
07:06:32 <waterlaz> "<cjs> Ok, my bile about Bertrand Meyer's _Beautiful Architecture_ chapter on "Why FP Fails" has been sufficiently drained by a mere blog comment, so now I will head out for a drink or something."
07:06:35 <dmwit> fasta: prod byorgey to finish up his diagrams library =)
07:06:38 <waterlaz> could you post a link to that?
07:06:59 <fasta> Isn't Mayer an OOP guy?
07:07:04 <dmwit> fasta: (But I will point out that gtk2hs does have a SVG library.)
07:07:05 <fasta> Er Meyer*
07:07:08 <waterlaz> my googling wasn't too effective
07:07:27 <cjs> zygoloid: That was the thing I had to overcome to deal with Haskell. I had to abandon my ideal; I had to use a language with a syntatic "if".
07:07:29 <fasta> It is natural that he wants FP to be failing.
07:07:36 <dmwit> (or, rather, an SVG render-er, which I guess isn't quite the same)
07:07:58 <fasta> The thing is that the best FP programs have some ideas from OOP.
07:08:06 <zygoloid> cjs: you mean you didn't just rewrite the Prelude with 'type Bool = forall a. a -> a -> a'? ;-)
07:08:20 <cjs> waterlaz: Yeah, right. Obviously, so much for the drink. I'll see if I can find a link to the blog comment. I suspect I may have lost it already.
07:09:13 <\yrlnry> A burrito is a monoid in the category of endofunctortillas.
07:09:50 <cjs> zygoloid: You're way ahead of me. I'm still working on the idea of a new prelude where Monad implies Functor, and let's not even start on the arithmetic stuff
07:09:59 <int-e> hmm. is there a good comonad tutorial out there?
07:10:13 <Jafet> zygoloid, if = curry.($).uncurry
07:10:23 <Jafet> Or should that be cond, now
07:10:24 <\yrlnry> int-e:  If you find one, I'd like a link to it.  The only thing I know about is Piponi's articles about them.
07:10:37 <cjs> waterlaz: http://satisfactionisthedeathovdesire.blogspot.com/2009/10/beautiful-architecture-chapter-13.html
07:11:08 <\yrlnry> int-e:  And I did read a paper a while back suggesting that IO and side effects could be usefully structured as a comonad instead of as a monad.
07:11:25 <zygoloid> Jafet: crikey that's an interesting way to write 'id' ;-)
07:11:41 <\yrlnry> int-e:  for example, getchar would have type  CoIO () -> Char, rather than type IO Char.
07:11:59 <\yrlnry> int-e:  I can try to hunt that up if you care.
07:12:05 <kamatsu> Jafet: that's id, not if
07:12:12 <waterlaz> cjs, thanks
07:12:37 <zygoloid> kamatsu: it's 'if' if 'Bool = a -> a -> a'
07:12:43 <int-e> \yrlnry: don't bother - I'm looking for basics
07:13:20 <\yrlnry> int-e:  well, if you find any, I'd love to hear about it.
07:13:20 <Jafet> @djinni (a -> b -> c) -> a -> b -> c
07:13:20 <lambdabot> f a = a
07:13:22 <dmwit> Yes, if is id if if is if on Bool = a -> a -> a
07:13:36 <Jafet> Hmm
07:13:41 <cjs> waterlaz: I've got inside me a huge rant on that (being an ex-Java-developer and having done some reasonably large systems in Haskell in the last couple of years), but it's going to take time to formulate.
07:13:44 <dmwit> Take that, Mavis Beacon!
07:13:44 <kamatsu> er
07:13:46 <zygoloid> dmwit: you mean id is if if if is if on ...
07:13:49 <kamatsu> but Bool is not
07:13:51 <kamatsu> behold
07:13:53 <kamatsu> > True 1 2
07:13:53 <fasta> cjs, I agree with your comments.
07:13:54 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
07:13:54 <lambdabot>         against inferred type ...
07:14:05 <dmwit> zygoloid: is is reflexive
07:14:18 <dmwit> zygoloid: unless one of them is an adjective =)
07:15:02 <zygoloid> an adjective =) is unless one of them ? ;-)
07:15:04 <cjs> fasta: The horrible thing is that, I really like the Eiffel idea of pre-conditions and post-conditions, but the way he puts it, it's like there's some sort of proof there.
07:15:11 <dmwit> hehe
07:15:32 <Zeiris> For fun, I've been writing a DSEL that describes 3D models out of geometric by combining and transforming simple primitives. What I've got so far looks like this http://paste.pocoo.org/show/178285/ and produces geometry like this http://img693.imageshack.us/img693/1672/windowk.png but it's starting to look rather hairy and a long way away from painlessly defining something like http://www.heritagebc.ca/uploads/UBC_ChemistryBldg_MR.jpg.
07:15:36 <Phyx-> @sizeOf
07:15:36 <lambdabot> Unknown command, try @list
07:15:38 <Zeiris> I think I need to somehow improve the syntax... I remember there existing significant work on combinator libraries for GUIs/drawing/OpenGL, do any of them have neat syntactic tricks I should look at? Or am I just barking up the wrong tree entirely?
07:15:41 <Phyx-> @hoogle sizeOf
07:15:41 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
07:15:41 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
07:15:41 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
07:15:46 <Phyx-> AHHHH
07:15:47 <Phyx-> no wonder
07:15:48 <Phyx-> geez
07:15:56 <Phyx-> i screwed up
07:16:03 <zygoloid> unless and =) are obviously lower precedence than is :)
07:16:16 <cjs> Forget Eiffel vs. Haskell. In the WWW wrestling world, we have The Greatest Spectation Ever, EIFFEL vs. COQ!
07:16:20 <Zeiris> :t (:))
07:16:20 <lambdabot> parse error on input `)'
07:16:27 <\yrlnry> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.4741&rep=rep1&type=pdf
07:16:36 <jmcarthur> cjs: i love design by contract, but it amounts to about the same thing as dynamic type systems. sure, if something is wrong it's likely to error out, but a runtime error is quite different from a compiler error
07:16:39 <\yrlnry> ^^ Codata and comonads in Haskell
07:16:39 <cjs> (Massive cheers from the audience, etc.)
07:16:49 <cjs> jmcarthur: Yes, quite.
07:17:17 <jmcarthur> i have to admit that design by contract is *much* easier than design by proof
07:17:24 <fasta> cjs, I believe the idea of design by contract is that you can use formal methods to turn the run-time contracts into compile time proofs.
07:17:50 <cjs> jmcarthur: My thought on it is (unsophisticated as it may be), that you really want to, well, "predetermine" these contracts at compile time, if you can. Which is just what an H-M type system does.
07:17:53 <fasta> cjs, I know we did during a verification class at least (not using Eiffel), but another imperative language.
07:18:24 <quicksilver> Zeiris: well I think you could improve things a lot by naming your variables better :)
07:18:25 <\yrlnry> sdfsdf
07:18:33 <\yrlnry> Sorry, input box problems.
07:18:38 <jmcarthur> cjs: i think a type system on the level of the kind of proofs i wish we were programming with isn't practical to infer in general :(
07:18:43 <fasta> I have the impression that writing a proof for something once you understand the problem _completely_ is not all that bad.
07:18:54 <fasta> The hard part is understanding the problem completely.
07:18:57 <quicksilver> Zeiris: "cWW = 2.0 -- window width"; why not just "windowWidth = 2.0" ?
07:18:58 <cjs> fasta: Well, then you've discovered the great failure of Haskell in that area; certain (i.e., "most") proofs are rather, er, "interesting" to express in the type system.
07:18:58 <jmcarthur> fasta: i agree
07:19:08 <quicksilver> Zeiris: if you need a comment right next to the declaration to explain the variable name...
07:19:30 <cjs> But it's the holy grail of all of us who go to ICFP every year.....
07:19:30 <Zeiris> quicksilver, you've got a point, but that would just make the code longer which is the opposite of what I want :(
07:19:46 <Zeiris> And the little c prefix, and allcaps following letters, indicate that it's a dull unexciting constant, nothing to see there.
07:20:13 <fasta> cjs, Haskell is just not suitable for that kind of programming currently. I see Haskell as a glorified C++.
07:20:36 <quicksilver> Zeiris: well, not much longer. You already have "pad upZ cFD <.> rect tGL cWW cWH upZ" on a single line. Wouldn't "pad upZ frameDepth <.> rect tGL windowWidth windowHeight upZ" still fit on one line and be more readable?
07:20:40 <fasta> Not in the performance area, unfortunately.
07:21:07 <jmcarthur> i still don't really see the complaints so many people seem to have about haskell performance
07:21:09 <cjs> fasta: You should have a look at that invited talk (ICFP 2009) from, uh, grr....
07:21:22 <cjs> fasta: Seriously?
07:21:47 <fasta> cjs, the only useful thing in Haskell for me is the type-inference.
07:21:56 <jmcarthur> o_O
07:21:58 <zygoloid> fasta: at least c++ lets you parameterize types over numbers ;-)
07:22:02 <cjs> jmcarthur: You've just not been bold enough. :-)
07:22:05 <jmcarthur> okay i won't argue, i'm just kind of surprised
07:22:09 <quicksilver> Zeiris: my other comment would be to see if you can remove the multiple uses of upZ. Can't you have a strong convention that all constructs face in one direction by default (upZ, perhaps?) and you only have to rotate occasionally.
07:22:20 <jmcarthur> cjs: i do a lot of things that are peformance centric, actually
07:22:42 <quicksilver> fasta: ADTs are pretty handy too; their ommission (as a convenient feature) is one of the most painful things in C++ for me.
07:22:46 <fasta> cjs, that the language makes you use non-mutable values by default also helps often.
07:22:48 <cjs> jmcarthur: So do I.
07:22:54 <Alpounet> quicksilver, agreed
07:23:08 <fasta> quicksilver, yes, that's also useful, of course.
07:23:11 <medfly> hehe, wow, someone in #haskell that made me think I should learn C++
07:23:47 <Jafet> C++ will soon have lambda functions!
07:23:52 <Jafet> (Closures sold separately.)
07:23:54 <cjs> jmcarthur: To the point where I said to SPJ's face that I understood the performance implications of what I was writing in Haskell. Boy, did *that* one come back to bite me.
07:23:55 <fasta> medfly, learn Forth if you want to learn something useful.
07:24:08 <jmcarthur> haha
07:24:17 <medfly> if I wanted to be useful, I'd /quit
07:25:07 <Alpounet> learn CT
07:25:33 <Phyx-> Jafet: C# already has them :P
07:25:49 <jmcarthur> Alpounet: oh btw, i have a starter package for the ai challenge up on patch tag
07:26:02 <Jafet> C# is an evil MSR thingy
07:26:11 <Phyx-> I like the dark side....
07:26:17 <jmcarthur> i rather like C#
07:26:23 <medfly> Alpounet, for what reason
07:26:31 <Phyx-> Jafet: aren't both simons also working for MSR?
07:26:32 <Phyx-> :P
07:26:35 <Alpounet> medfly, not being useful heh
07:26:37 <Phyx-> jmcarthur: same here
07:26:47 <medfly> yeah, I guess being a mathematician is a way to make being useless easier.
07:26:49 <Alpounet> jmcarthur, oh, I'll check this out right away
07:27:00 <medfly> but maybe in 500 years someone might consider my work useful!
07:27:01 <Zeiris> quicksilver, you've got a point about the variable names. Gonna change that to be less cryptic. I used to have the convention of rects always facing +Z at first, but the endless calls to "rot onX 90" looked uglier. Maybe something better can be done with partially applied functions, though.
07:27:19 <jmcarthur> Alpounet: is completely undocumented, but i wouldn't mind writing a little bit out if needed later
07:27:26 <Jafet> medfly, it's like art
07:27:33 <jmcarthur> Alpounet: http://patch-tag.com/r/jmcarthur/googleai-haskell-starter/snapshot/current/content/pretty
07:27:36 <medfly> worse
07:27:48 <medfly> I mean, art is worse
07:28:37 <Alpounet> jmcarthur, ty
07:28:39 <fasta> cjs, yes, that was an, uhm, interesting moment (ICFP presentation).
07:29:24 <cjs> fasta: You be quiet! :-)
07:29:51 <dmwit> I don't get it.
07:29:54 <dmwit> How come when I do
07:30:04 <Saizan> which presentation?
07:30:05 <dmwit> ...oh
07:30:31 <fasta> cjs, oh, well, you are the one making millions, right? :)
07:30:51 <cjs> fasta: Ha ha! Not quite yet.
07:31:13 <fasta> cjs, do you just write the software or do you also own the link to the market?
07:31:28 <cjs> But damn close. Lazy evaluation has been less of a bugaboo lately, admittedly. Now we're into GC nastyness.
07:31:58 <cjs> fasta: We have a couple of servers co-located with a broker, who is in turn "sort of" co-located with the market.
07:32:27 <fasta> cjs, it is funny that it is called a free market, while in fact it isn't, don't you think?
07:32:41 <medfly> :)
07:32:53 <pokoko222> any networking guys here? i have a question on session layer... networking chanell no answer yet...
07:33:21 <medfly> pokoko222, I suggest just asking it
07:33:48 <roconnor> cjs: can I have a job making millions too?
07:34:11 <pokoko222> it is not haskell question, i dont want to spam, but i know there are networking guys here so if someone can help pm me please, i read tanenbaum third time, we can talk for some stuff
07:34:34 <medfly> you can just ask CS related questions and get away with it
07:36:03 <Alpounet> jmcarthur, looks nice
07:36:36 <Alpounet> just have to implement an AI and put it through runAI ?
07:36:51 <roconnor> last night I had a dream where I found a book on Tron strategies in the library.  I was thinking I should read it and enter the programming contest.
07:37:36 <Jafet> Did you read the book in the dream, though?
07:37:45 <roconnor> nope
07:37:49 <cjs> roconnor: Sure. If you find one, drop me a line! :-)
07:37:51 <roconnor> no time
07:38:09 <roconnor> cjs: ooh, let's start our own company!
07:38:14 <quicksilver> Zeiris: ultimately the best solution is going to depend on the model you're building
07:38:25 <quicksilver> Zeiris: so your combinators need to be adaptable
07:38:26 <cjs> Err....been there, done that. I'm taking a rest for  a year or two.
07:38:33 <roconnor> :D
07:38:47 <quicksilver> Zeiris: but in terms of making a particular model readable, good names, and a code which obviously matches the visual structure, is great
07:38:57 <quicksilver> Zeiris: I'm not sure you're missing a big trick, particular.
07:39:45 <Zeiris> quicksilver, yeah, my code structure and naming needs the most work. The best thing I can think of is making Shape an instance of Monad, then being able to use do-notation for Y-composition instead of <->. Although I'd have to turn every shape into a Shape a somehow.
07:40:02 <Zeiris> (The best 'big trick' thing I can think of, that is.)
07:40:06 <quicksilver> Zeiris: there is always a balance between convention and explicit choice. But perhaps "faceX" as a shorthand for "rot 90 onY" (since, to turn something facing upZ into something facing upX you rotate by 90 around Y)
07:40:20 <\yrlnry> What is "Y-composition"?
07:40:31 <quicksilver> Zeiris: I recommend against that. vconcat [ a , \n b, \n c ...] looks fine
07:40:43 <quicksilver> Zeiris: overloading do notation just saves you typing the "," not worth it IMO
07:40:51 <quicksilver> \yrlnry: these are graphical combinators; building up a scene.
07:43:15 <atemerev> > (1/0) > 0
07:43:16 <lambdabot>   True
07:43:21 <Zeiris> Hm. Defining the shapes with lists, then applying v/h/dconcat to them might be a good idea :)
07:43:30 <roconnor> > (1/0) > (1/0)
07:43:31 <lambdabot>   False
07:43:46 <roconnor> > compare (1/0) (1/0)
07:43:47 <lambdabot>   EQ
07:43:57 <medfly> > 1/0
07:43:57 <lambdabot>   Infinity
07:44:13 <roconnor> > (0/0) > (0/0)
07:44:14 <lambdabot>   False
07:44:17 <roconnor> > compare (0/0) (0/0)
07:44:18 <lambdabot>   GT
07:44:38 <medfly> odd
07:44:43 <medfly> > 0/0
07:44:44 <lambdabot>   NaN
07:45:04 <roconnor> @src Float compare
07:45:04 <lambdabot> Source not found. There are some things that I just don't know.
07:45:21 <medfly> @type (0/0)
07:45:22 <lambdabot> forall t. (Fractional t) => t
07:45:46 <Jafet> Heh, must all Fractionals contain NaN?
07:46:05 <Alpounet> :t Nan
07:46:06 <lambdabot> Not in scope: data constructor `Nan'
07:46:16 <medfly> :t NaN
07:46:17 <lambdabot> Not in scope: data constructor `NaN'
07:46:25 <Jafet> :t isNaN
07:46:26 <lambdabot> forall a. (RealFloat a) => a -> Bool
07:46:39 <roconnor> > (0/0) :: Rational
07:46:40 <lambdabot>   * Exception: Ratio.%: zero denominator
07:46:57 <atemerev> No, _that_ won't work, thankfully. :)
07:46:58 <Jafet> Haskell, now featuring FPEs
07:47:09 <quicksilver> Zeiris: lists are great pseudo-syntax
07:47:15 <quicksilver> Zeiris: so are lists of tuples.
07:47:29 <Zeiris> I should learn Lisp oneday. Doesn't it treat code as lists?
07:47:45 <quicksilver> Zeiris: the style "map (\(a,b,c) -> ... do something with a b c ...) [ ... big list of constant triples ... ] I use quite often
07:48:25 <quicksilver> Zeiris: for something vaguely like you're doing it might be (colour,model,onclick function)
07:48:32 <quicksilver> or (material,model,helpstring)
07:48:33 <quicksilver> etc.
07:48:46 <atemerev> 'doing something with a list of tuples' is almost a definition for programming in Erlang.
07:49:05 <Twey> atemerev: Haha
07:49:15 <quicksilver> Zeiris: yes, it does, and that only matters if you think that code which reads/alters other code is a good thing.
07:49:26 <quicksilver> sometimes, it's an awesomely amazing thing, of course
07:49:36 <Jafet> You're insinuating it isn't?
07:49:38 <quicksilver> but as a default way of programming it's probably bad style.
07:49:56 <atemerev> No, I am not.
07:50:15 <Zeiris> Code that writes code sounds like a fun idea. Better it than me.
07:50:21 <quicksilver> writing code is fine
07:50:28 <quicksilver> reading/altering code is more special purpose.
07:51:00 <Jafet> One of the funnest things I did was to use javascript to write <script> ... </script> tags into HTML
07:51:12 <quicksilver> reading code is fragile because code is quite poorly structured and it's hard to process it reliably without actually writing a compiler.
07:51:23 <quicksilver> (if you're actually writing a compiler then, of course, that's your job, yes.)
07:52:14 <kamatsu> the problem i have with lisp is the lack of locality of reference
07:52:34 <kamatsu> lisp has a tiny amount of core concepts, many less than haskell
07:52:51 <atemerev> There are lisp dialects with locality.
07:52:51 <b0fh_ua> Hi there! Can somebody please suggest some introduction into concurrent programming in Haskell? Easy one, if possible )
07:52:55 <kamatsu> but it also throws away one of haskell's advantages, that you can usually see what something is doing just by looking at it
07:53:07 <medfly> forkIO
07:53:13 <kamatsu> b0fh_ua: I was able to write concurrent programs using MVar and Chans without a tutorial
07:53:19 <kamatsu> b0fh_ua: it's very straightforward
07:53:26 <medfly> me too.
07:53:40 <medfly> I suck, so I asked questions here.
07:53:57 <meanburrito920_> does anyone know if wxcore on hackage is working?  I just tried to cabal install multiple versions of it and they all failed. There is a build failure log for 6.12 on hackagedb, but I don't know if that means that the current build is broken.
07:54:09 <kamatsu> chans are serializing message queues, and mvars are like magic boxes that store only one thing
07:54:25 <kamatsu> chans are to mvars as lists are to maybe, after a fashion
07:54:37 <helgikrs> meanburrito920_: i am trying to install it right now :P not fails for me too
07:54:56 <helgikrs> s/not//
07:55:07 <meanburrito920_> hm...
07:55:22 <kamatsu> b0fh_ua: also, there are numerous powerful concurrency libraries for haskell like CHP, but you don't need them
07:55:36 <meanburrito920_> the build failure log seems to suggest that the build files are incorrect.
07:55:49 <kamatsu> b0fh_ua: or, if you made the unforgivable mistake of confusing data parallelism with concurrency, we have features for parallelism too
07:56:00 <meanburrito920_> are hackage packages hosted with darcs on the server?
07:56:29 <kamatsu> meanburrito920_: just extract the tarball that cabal itself fetched
07:56:29 <helgikrs> meanburrito920_: i get an error saying containers-0.2.0.1 is failing, not finding module Data.Data
07:56:38 <meanburrito920_> hm.
07:56:42 <b0fh_ua> kamatsu: what I need is to spawn N threads, which will access same HTTP resource N times
07:56:51 <meanburrito920_> that sounds different from my error
07:57:12 <kamatsu> b0fh_ua: define 'access'. Do you mean they will make N http requests to some remote server?
07:57:21 <jaj> is there an elegant way to generate list = [[1,2,3,4], [5,6,7], [8,9],[10]] ? I mean something that doesn't need a recursive function with counters
07:57:28 <b0fh_ua> kamatsu: yep, I already wrote the code to do so using Curl
07:57:30 <meanburrito920_> mine was as follows: setup: readProcess: wx-config "--libs" "--cppflags" (exit 127): failed
07:57:43 <kamatsu> b0fh_ua: so, you don't really need concurrency at all
07:57:48 <kamatsu> b0fh_ua: the threads don't communicate
07:58:14 <kamatsu> b0fh_ua: well, in that case, you can use forkIO to run an IO action asynchronously
07:58:28 <kamatsu> b0fh_ua: so just call your curl thing N times with forkIO
07:58:37 <kamatsu> @type forkIO
07:58:38 <lambdabot> Not in scope: `forkIO'
07:58:42 <medfly> @hoogle forkIO
07:58:42 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
07:59:02 <b0fh_ua> kamatsu: okay, how do I wait until all "threads" complete?
07:59:34 <meanburrito920_> also, cabal is complaining that the 'gtk' package is not available on hackage...
07:59:45 <medfly> maybe you can use MVar :) try to read it and when the thread is done, write to it?
08:00:25 <medfly> there may be a more elegant way
08:00:26 <kamatsu> b0fh_ua: do you intend to do something with these threads?
08:00:27 <Saizan> meanburrito920_: you need to download/install that from the gtk2hs site
08:00:35 <Saizan> ?google gtk2hs download
08:00:36 <lambdabot> http://www.haskell.org/gtk2hs/download/
08:00:36 <lambdabot> Title: Gtk2Hs  Download
08:00:36 <meanburrito920_> why is it not on hackage?
08:00:39 <kamatsu> b0fh_ua: like, do you just want to make n requests to some server and then stop?
08:01:17 <meanburrito920_> hmm.. and it doesnt support 6.12 apparently
08:01:18 <Saizan> meanburrito920_: it's not cabalized, because there are problems wrt porting its build system to cabal
08:01:24 <meanburrito920_> ah
08:01:40 <kamatsu> medfly: I would prefer to use a chan and wait until i get n messages from n threads, but I do believe there is a better way
08:01:41 <b0fh_ua> kamatsu: yes
08:01:55 <kamatsu> b0fh_ua: if you're just going to stop, you don't need to do any logic to "wait" for the threads
08:02:01 <ksf> is there a standard function to sequence applicatives?
08:02:05 <kamatsu> b0fh_ua: the haskell runtime will remain active until all threads finish
08:02:14 <atemerev> There is a Control.Concurrent.SampleVar for that, but I am not sure it's kosher.
08:02:21 <b0fh_ua> kamatsu: I need to check if all of them successfully connected to server
08:02:25 <ksf> (Control.Monad.Sequence should propably just be Control.Applicative.Sequence)
08:03:00 <kamatsu> b0fh_ua: okay, so, this can be solved a variety of ways
08:03:05 <Phyx-> is there by any chance a pragma that tells ghc to just include source from another file? (like just read the file and paste it's content in the current file)
08:03:21 <ksf> Phyx-, you can use -XCPP
08:03:29 <ksf> but you don't really want to, most likely.
08:03:33 <kamatsu> b0fh_ua: the way I would suggest to do it is, use Control.Concurrent.Chan, and make a channel that you pass to each one of those threads
08:03:56 <kamatsu> b0fh_ua: when those threads have done their job, they write whether or not they succeeded or failed into the channel
08:03:58 <Phyx-> ksf: I just wanted to seperate my changes to the ghc files from the original onces as much as possible
08:04:26 <kamatsu> b0fh_ua: you also spawn another thread that simply reads that channel in a loop, up to n times, and if any of them fail then you'll know
08:04:29 <atemerev> http://lmgtfy.com/?q=ghc+include+pragma&l=1
08:04:32 <ksf> b0fh_ua, remember that chans are first-class values and you can pass them over a chan.
08:05:30 <atemerev> sorry, I was wrong. :)
08:06:08 <kamatsu> ksf: although i doubt that would be necessary in this case
08:06:57 <zygoloid> > map reverse $ reverse [take n . drop (n*(n-1)`div`2) $ reverse [1..10] | n <- [1..4]]
08:06:58 <lambdabot>   [[1,2,3,4],[5,6,7],[8,9],[10]]
08:07:00 <zygoloid> :D
08:07:17 <kamatsu> zygoloid: slightly hideous, but awesome
08:07:34 <kamatsu> zygoloid: can you factor out some of those reverses?
08:08:48 <kamatsu> zygoloid: well, you can easily drop out the map
08:08:56 <kamatsu> zygoloid: reverse [ reverse $ take n . drop (n*(n-1)`div`2) $ reverse [1..10] | n <- [1..4]]
08:09:25 <zygoloid> > let breaks ns xs = zipWith take ns $ map (flip drop xs) (scanl (+) 0 ns) in breaks [4,3..1] [1..10]
08:09:27 <lambdabot>   [[1,2,3,4],[5,6,7],[8,9],[10]]
08:09:45 <zygoloid> less hideous and shorter but just as inefficient :)
08:10:01 <zygoloid> (ok, perhaps a /little/ faster but...)
08:10:57 <atemerev> I am new to the channel, so I wonder what happens if you feed something like [1..] to lambdabot? A permban? :)
08:11:06 <mux> > [1..]
08:11:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:11:09 <quicksilver> no, lambdabot is fairly robust.
08:11:10 <kamatsu> > [1..]
08:11:11 <mux> no :-)
08:11:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:11:11 <atemerev> Shit.
08:11:42 <quicksilver> [1..] is easy because if you only demand the first 80 characters it's a terminating computation anyway.
08:11:54 <quicksilver> try (take 80 $ show [1..]) in your own ghci/hugs
08:12:02 <baaba> > sum [1..]
08:12:02 <kamatsu> > reverse [1..]
08:12:09 <quicksilver> lambdabot also catches non-terminating calculations though
08:12:09 <lambdabot>   mueval-core: Time limit exceeded
08:12:10 <lambdabot>   mueval: ExitFailure 1
08:12:14 <quicksilver> as they are just demonstrating.
08:12:15 <kamatsu> see ^
08:12:18 <b0fh_ua> kamatsu: okay, thanks a lot
08:12:30 <atemerev> Cool indeed.
08:12:33 <kamatsu> b0fh_ua: no worries, concurrency in haskell is actually super-duper awesome
08:12:36 <zygoloid> > last ([1..] :: [Int])
08:12:40 <lambdabot>   mueval-core: Time limit exceeded
08:12:44 <zygoloid> lambdabot also catches very slow calculations
08:12:45 <roconnor> atemerev: don't do unsafePerformIO (system "rm -rf /")
08:13:07 <kamatsu> er
08:13:13 * kamatsu feels the urge to try that
08:13:17 <roconnor> don't do it!
08:13:20 <quicksilver> yes, lambdabot just gives you three seconds, or so.
08:13:22 <roconnor> it will wipe your hard drive
08:13:27 <kamatsu> if it's running on a GNU machine, it won't
08:13:30 <kamatsu> try it, i dare you
08:13:35 <kamatsu> rm -rf / is a no-op
08:13:50 <jmcarthur> Alpounet: right you just run it through runAI
08:13:57 <atemerev> But will lambdabot do the same?
08:14:37 <jmcarthur> Alpounet: one thing that might need explaining is the fact that i intend for state to be maintained using partial application in the out of the AI
08:14:38 <atemerev> > unsafePerformIO ("ls -l")
08:14:39 <lambdabot>   Not in scope: `unsafePerformIO'
08:14:44 <atemerev> Aha.
08:14:45 <jmcarthur> *in the output of
08:14:56 <jmcarthur> atemerev: that's not how you use it anyway
08:17:13 <helgikrs> i get an error trying to install containers-0.2.0.1 'Could not find module `Data.Data' ... Perhaps you need to add `base' to the build-depends in your .cabal file.' ... but base is in build-depends in containers.cabal
08:18:37 <zygoloid> kamatsu: sounds like you have an alias rm='rm --preserve-root' set up :)
08:18:53 <kamatsu> zygoloid: nope, it is like that by default
08:19:07 <Zao> helgikrs: With what GHC version?
08:19:14 <zygoloid> kamatsu: not according to my man page:        --no-preserve-root do not treat '/' specially (the default)
08:19:20 <Zao> Or rather, with what base version.
08:19:27 <helgikrs> Zao: 6.12.1-2
08:19:37 <kamatsu> zygoloid: try it ;)
08:19:41 <atemerev> yes, you'll need unsafePerformIO(system "rm -rf /") for that, with System.IO.Unsafe and System.Cmd in scope.
08:19:45 <kamatsu> zygoloid: treating '/' specially is the default
08:19:48 <kamatsu> zygoloid: that's what it says
08:20:03 <mux> sounds like stupid GNU-made bloat.
08:20:09 <Zao> helgikrs: Doesn't that come with a suitable containers version already?
08:20:10 <zygoloid> kamatsu: that's not my reading of it
08:20:15 <kamatsu> i have tried it
08:20:23 <kamatsu> it definitely doesn't delete it
08:20:30 <MissPiggy> What's flexible instances
08:20:39 <b0fh_ua> kamatsu: Thread 49001370 has exited with leftover thread-specific data after 4 destructor iterations
08:20:46 <b0fh_ua> what may this mean?
08:20:56 <kamatsu> b0fh_ua: post code
08:21:01 <helgikrs> Zao: i have containers-0.3.0.0 but containers-0.2.0.1 is a dependency for wxcore
08:21:19 <b0fh_ua> hpaste doesn't work eitgher :)
08:21:20 <jmcarthur> MissPiggy: allows you to define instances for types like Maybe Int instead of only types like Maybe a
08:21:23 <MissPiggy> is it safe?
08:21:27 <b0fh_ua> 58030 14: unable to open database file
08:21:38 <jmcarthur> MissPiggy: it's safe as far as i know
08:21:42 <MissPiggy> hm what if I di
08:21:50 <MissPiggy> (a ~ Int) => Maybe a
08:22:15 <jmcarthur> MissPiggy: ghc doesn't support that currently, i think
08:22:21 <b0fh_ua> kamatsu: http://pastebin.com/d131152e
08:22:27 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules
08:22:30 <MissPiggy> I'm scared of -XFlexibleInstances
08:22:36 <jmcarthur> why?
08:22:43 <MissPiggy> because it seems like well there must be something dodgy if it's not on by default
08:22:46 <Saizan> MissPiggy: it's plenty safe, it was in -fglasgow-exts
08:22:58 <b0fh_ua> kamatsu: it's initial version, I didn't play with chans and checking results
08:23:10 <MissPiggy> this is my .ghci
08:23:11 <MissPiggy> :set -XNoMonomorphismRestriction -XFlexibleInstances
08:23:15 <Saizan> MissPiggy: it just wasn't allowed in haskell98 to keep typeclass inference very simple
08:23:38 <Saizan> s/typeclass inference/instance resolution/
08:23:47 <kamatsu> b0fh_ua: ah, remember that putStrLn can be funny in concurrent programs, should be alright though
08:23:58 <MissPiggy> this is nice;
08:23:59 <MissPiggy> (zero O.+ one) O.* (one O.+ one) :: Term Algebraic
08:24:00 <Saizan> MissPiggy: the only problem is if you want both a "Maybe a" and a "Maybe Int"
08:24:03 <MissPiggy> produces (0 + 1) * (1 + 1)
08:24:13 <MissPiggy> Saizan, ah that is fine then -- because I never want Maybe a
08:24:26 <Zao> MissPiggy: Ever. In every module you import?
08:24:39 <zygoloid> kamatsu: looks like it was changed in a more recent version of coreutils than i have. and no, i've not tried it still :)
08:24:41 <MissPiggy> Zao well it's actually Term a rather than Maybe a
08:24:45 <jmcarthur> MissPiggy: what about First a or Last a?
08:24:47 <b0fh_ua> kamatsu: ghc: NetworkziCurlziEasy_dg1j: interrupted
08:24:57 <MissPiggy> what aer First and Last?
08:25:07 <jmcarthur> just newtype wrappers around Maybe
08:25:13 <Alpounet> jmcarthur, I think I got it
08:25:17 <jmcarthur> they exist for their Monoid instances
08:25:19 <kamatsu> b0fh_ua: sounds like a strange interaction with curl
08:25:22 <MissPiggy> I'm not actually using Maybe at all, I was just running with your example
08:25:25 <b0fh_ua> kamatsu: http://pastebin.com/d31913868
08:25:33 <b0fh_ua> omg, so much problems )
08:25:44 <jmcarthur> MissPiggy: right. i was just giving an example of a valid use for defining instances for Foo a
08:25:47 <MissPiggy> I could newtype AlgebraicTerm = AlgebraicTerm (Term Algebraic)
08:26:17 <MissPiggy> but I think that would not beat this flexible instance
08:26:19 <b0fh_ua>  internal error: setThreadLocalVar: Invalid argument
08:26:26 <b0fh_ua> (GHC version 6.10.4 for i386_unknown_freebsd)
08:26:30 <b0fh_ua> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
08:26:32 <b0fh_ua> awesome
08:26:38 <kamatsu> b0fh_ua: what the hell
08:26:45 <b0fh_ua> yeah, nice
08:26:49 <kamatsu> let me try this
08:26:52 <MissPiggy> by the way jmcarthur I was thinking about your method, empty typeclass to express proof properties
08:26:57 <zygoloid> @type let foo :: (a ~ Int) => Maybe a; foo = Nothing in foo
08:26:58 <lambdabot> Maybe Int
08:27:58 <MissPiggy> jmcarthur -- maybe it's a bit ridiculous but you could write proofs of algorithms (out of some combinators) e.g. gcd algorithm proof -- and it would infer all these empty typeclasses that you need for the algorithm to give the correct output
08:28:39 <kamatsu> b0fh_ua: mine does not exhibit the same behavior
08:28:47 <kamatsu> b0fh_ua: might i suggest that perhaps your compiler is broken
08:29:07 <jmcarthur> MissPiggy: oh? i don't really see how that would be possible. how would it know to infer a type class when you aren't using any functions in that type class (necessarily, since the type class is empty)?
08:29:17 <Saizan> by empty typeclasses you mean without methods?
08:29:40 <jmcarthur> MissPiggy: the only way i see that being possible is if you are actually using other functions which require that type class in their types
08:29:47 <jmcarthur> is that what you mean?
08:29:54 <MissPiggy> jmcarthur, I mean like if you used  "x + y = y + x"  in the correctness proof of the algorithm, it would infer Commutative (S,+) => ...
08:29:59 <b0fh_ua> kamatsu: after I used "runhaskell" few times, the error disappeared
08:30:11 <kamatsu> b0fh_ua: try compiling it
08:30:17 <zygoloid> MissPiggy: "instance (a ~ Int) => Class (Maybe a)" is accepted byg GHC 6.10, with the TypeFamilies and UndecidableInstances extensions enabled
08:30:32 <jmcarthur> MissPiggy: you are speculating about a language feature or claiming this would actually happen already?
08:30:39 <MissPiggy> zygoloid, oh I wonder it was to be undecidible
08:30:59 <zygoloid> "constraint is no smaller than the instance head"
08:31:13 <Saizan> zygoloid, MissPiggy: but "instance (a ~ Int) => Class (Maybe a)" is not the same as "instance Class (Maybe Int)" from an instance resolution POV
08:31:15 <MissPiggy> jmcarthur, you could do it already (but it would be a little bit silly, it's just nice to know that it's possible)
08:31:23 <jmcarthur> zygoloid: i don't think ghc yet allows type equivalence checks in instance delcarations (or maybe it was class declarations, or both?)
08:31:35 <jmcarthur> or whatever the name of that feature (~) is
08:31:46 <Saizan> jmcarthur: it's allowed in instances, not in classes
08:31:54 <jmcarthur> Saizan: aha
08:32:41 <jmcarthur> MissPiggy: huh. i will have to explore that. i was expecting to have to write manual type signatures to reap most of the benefits
08:32:57 <jmcarthur> i guess you are speaking specifically about proof carrying code though
08:33:00 <Alpounet> what's that ~ type operator ?
08:33:03 <jmcarthur> ish
08:33:16 <zygoloid> hah, if i have "instance (a ~ Int) => Num (Maybe a) where" then type "Nothing + Nothing" at ghci, it hangs :o
08:33:24 <kamatsu> i'm off to bed all
08:33:24 <yokto> what is less hacky for passing information which are not Typeable if you use hint (use show read) or (use the ghc -XDeriveTypeableData) extension
08:33:25 <kamatsu> adios
08:33:27 <Saizan> Alpounet: type equality
08:33:28 <jmcarthur> Alpounet: requires that the two types be the same
08:33:35 <Alpounet> okay
08:33:41 <jmcarthur> Alpounet: part of TypeFamilies
08:33:49 <Alpounet> thank you :)
08:34:06 <Saizan> yokto: the second
08:34:19 <yokto> ok
08:34:28 <MissPiggy> jmcarthur well you could even automate it with something like Coq,  turing the tricky proofs like rew1 :: (x^2+..) = whatever (which makes use of distributivity and commutativity) into rew1 :: (Ring s m, Abelian m) => ... ; rew1 = undefined
08:34:47 <Saizan> yokto: you should always get your Typeable instances by deriving them
08:34:50 <MissPiggy> and the the actual algorithm would have the same constraints as the proof
08:35:29 <MissPiggy> I don't thhink it's a great idea to actually do in practice but it's a nice property of the method you use
08:35:37 <yokto> ok
08:35:48 * zygoloid wonders if 'instance (a ~ Foo) => B a' might be useable as an alternative to defaulting
08:36:09 <zygoloid> i guess not :(
08:36:11 <Saizan> zygoloid: + OverlappinInstances
08:36:14 <jmcarthur> oh i see what you mean now
08:36:26 <zygoloid> Saizan: hah, yeah, that'd do it :)
08:36:49 <Saizan> you'd get weird type errors thouh
08:37:33 <Saizan> if X is not an instance of B and you use a method of B such that you require B X, the error would be that X is not Foo, i think
08:38:12 <zygoloid> in which order does OverlappingInstances act? if i have (1 + 1/2), will the + choose (a ~ Int) => Num a, or (a ~ Double) => Fractional Double first?
08:38:12 <MissPiggy> jmcarthur it occured to me because I was thinking when my program starts to get more complicated it might become very helpful to employ this
08:38:23 <zygoloid> s/Fractional Double/Fractional a/
08:40:30 <jmcarthur> MissPiggy: oh btw, mzero = never ; mplus = race   :D
08:40:37 <MissPiggy> hehe
08:40:48 <MissPiggy> jmcarthur, you know constructive math? Every function R -> R is continuous
08:40:55 <jmcarthur> i like making things fit into existing type classes
08:41:54 <jmcarthur> MissPiggy: oh wow, i didn't think of that before, but it makes intuitive sense to me
08:42:11 <jmcarthur> MissPiggy: i wouldn't say i *know* constructive math, but i'm a fan of what little of it i do know
08:42:39 <MissPiggy> jmcarthur well I was thinking maybe could define  sgn : R -> Computation R  and  zerop : R -> Computation Bool   --  if one wanted to do some reasoning about these things
08:43:14 <Saizan> zygoloid: you mean wrt defaulting? i don't know
08:43:24 <jmcarthur> what do sgn and zerop stand for, there?
08:43:38 <Saizan> zygoloid: i hope it works before defaulting :)
08:44:06 <MissPiggy> jmcarthur, just basic examples of discontinuous functions that you can't define normally
08:44:35 <zygoloid> Saizan: if multiple instances match, it defers resolving it and leaves the typeclass in the context. everything works out. yay
08:44:47 <jmcarthur> MissPiggy: ah, okay. because Computation as codata let's you capture partiality
08:44:50 <jmcarthur> *lets
08:46:13 <jmcarthur> MissPiggy: i assume you have seen Partiality is an Effect? it's pretty much the same thing as Computation, and i wonder if that's even where you got the idea
08:50:21 <jmcarthur> MissPiggy: oh, also, in my own version of Computation, i'm defining it as Free Maybe rather than Free Identity. lets me use never without making the cpu hotter
08:50:43 <MissPiggy> yeah that's good as long as everything still works :)
08:51:02 <jmcarthur> MissPiggy: and if you wrap it in Codensity you probably can get a little speed up
08:51:53 <MissPiggy> really, how is that/
08:51:53 <MissPiggy> ?
08:53:03 <Alpounet> jmcarthur, you should really consider publishing something about that Computation stuff
08:53:08 <k23z__> MissPiggy: hi
08:53:13 <MissPiggy> hello
08:53:17 <k23z__> MissPiggy: how are you ?
08:55:48 <jmcarthur> MissPiggy: for the same reason it gives you a speedup for any free monad
08:55:57 <jmcarthur> MissPiggy: it's similar to lists vs. DiffList
08:56:33 <MissPiggy> that's magic
08:56:45 <jmcarthur> MissPiggy: (>>=) in particular will have you traversing the same string of Delays every time you need to modify the value at the end
08:58:00 <jmcarthur> Alpounet: i probably will write a library and then write about it, if i pursue it. i'm finding a lot of use out of it
08:58:07 <jpcooper> hello
08:58:43 <jaj>       Expected type: [[a]]
08:58:43 <jaj>       Inferred type: [[(t, t1)]]
08:58:48 <jmcarthur> hello
08:59:15 <jaj> hmm, why doesn't it want (t,t1) as a
09:00:19 <jpcooper> I am trying to write a card-counting bot. There are thirteen cards of a suit to be dealt, and for each dealing of a single card, certain probabilities will be associated to future outcomes. I would like to associate probabilities to each stage of each possible dealing. I'm thinking of representing dealing outcomes as a tree. Could someone recommend a library to use for this kind of thing where I can quickly access probabilities a
09:01:31 * hackagebot upload: hashed-storage 0.4.7 - Hashed file storage support code. (PetrRockai)
09:01:39 <Alpounet> jmcarthur, nice ! can't wait
09:02:14 <jmcarthur> Alpounet: i'm also looking into whether lub can be implemented faithfully in terms of Computation. i'm not so sure yet
09:02:35 <roconnor> jpcooper: pfp
09:02:59 <jpcooper> thanks roconnor
09:03:10 <roconnor> @where pfp
09:03:10 <lambdabot> I know nothing about pfp.
09:03:21 <roconnor> @where+ pfp http://web.engr.oregonstate.edu/~erwig/pfp/
09:03:21 <lambdabot> It is stored.
09:04:07 <Alpounet> jmcarthur, lub ?
09:04:08 <roconnor> are there newer implementations of the probability monad?
09:04:51 <MissPiggy> I lub Computation monad
09:05:17 <jmcarthur> Alpounet: for example, (1, _|_) `lub` (_|_, 3) == (1, 3)
09:05:32 <jmcarthur> Alpounet: lub stands for Least Upper Bound
09:05:35 <MissPiggy> roconnor, there is http://blog.sigfpe.com/2007/02/monads-for-vector-spaces-probability.html but I am not sure if it's meant to be used directly
09:06:00 <jmcarthur> Alpounet: conal has a blog post or two about it (and he wrote the lub package on hackage, which is based on unamb)
09:06:10 <doserj> http://hackage.haskell.org/package/probability
09:07:25 <Alpounet> ok thanks
09:07:46 <quicksilver> conal is a paradox; such evil perpetuated by one so good.
09:08:09 <jmcarthur> quicksilver: the implementation is the only evil part of it that i know of
09:09:18 <jmcarthur> i've grown to like unamb and lub. they just aren't very efficient as they are
09:10:01 <jmcarthur> and "notw very efficient" means "don't use too much of it or the GHC RTS will explode in your face and kill you, causing much grief for your family"
09:11:30 <MissPiggy> hi gwern
09:12:07 <quicksilver> jmcarthur: well unamb has an uncomputable side condition without which it violates determinism
09:12:14 <quicksilver> jmcarthur: that's a nasty kick in the semantics.
09:12:46 <c_wraith> I appear to have missed a memo that the office is closed today.  Perhaps it was covered at the party I skipped friday afternoon.  Oh well.  I'll just work on that package I want to get on hackage today.
09:13:27 <byorgey> c_wraith: hehe, oops =)
09:15:49 <quicksilver> jmcarthur: and I'm fairly sure that lub violates monotonicity in practice although I'm struggling to see how.
09:15:55 <Alpounet> @hackage lub
09:15:55 <lambdabot> http://hackage.haskell.org/package/lub
09:16:05 <quicksilver> s/see/prove/
09:16:41 <Saizan> "in practice"?
09:17:21 <fasta> What is this "practice" you speak of?
09:17:24 <fasta> ;)
09:18:24 <ben> So would unamb's race let me do something like (race `on` readChan) a b without potentially losing one of the values?
09:18:47 <MissPiggy> monotonicity?
09:19:20 <MissPiggy> I guess that's a <= b ==> f(a) <= f(b)  but what is f?
09:19:44 <Zao> c_wraith: Calm, handy refreshments, decent environment. Most offices are rather nice places if it wasn't for the other people there and work :)
09:20:28 <roconnor> quicksilver: in that 1 `lub` 2 is undefined, while 1 `lub` undefined is 1?
09:20:36 <c_wraith> Zao: Yeah, and my dev environment is better here than at home. :)
09:20:40 <byorgey> MissPiggy: f is anything.  In pure functional languages, if f is any function and a <= b in the 'definedness' ordering, then f a <= f b
09:21:14 <MissPiggy> aha so the game is find an f such that even though a <= b, f(a) is NOT <= f(b)?
09:21:30 <MissPiggy> (and f will obviously be using amb in an essential way)
09:21:31 <byorgey> right, using lub apparently
09:21:35 <byorgey> yes
09:21:36 <MissPiggy> oh lub
09:22:02 <MissPiggy> 1 `lub` 2 probably randomly gives 1 or 2 -- but you can pretend it's "unspecified behavior" like in C
09:22:58 <byorgey> quicksilver: do you think there's still a problem with lub even if you only ever use it on things which are comparable in the definedness order?
09:23:17 <MissPiggy> _|_ <= () but let f = (\a -> a`lub`()) now  f _|_ = () and f () = () -- well that doesn't break montonicity
09:23:25 * byorgey is using lub in an essential way in his combinatorial species library
09:23:26 <jmcarthur> quicksilver: i don't think the side condition is so bad, myself. it just happens not to be expressible in our type system
09:23:40 <quicksilver> jmcarthur: it's not just not expressible in the type system; it's not computable.
09:23:53 <quicksilver> jmcarthur: that means, it's not expressible in *any* type system.
09:23:58 <MissPiggy> you don't need computable to put it in a type system :P
09:24:00 <quicksilver> (for some suitable value of any)
09:24:05 <MissPiggy> you just need to lug all these heavy proofs around
09:24:08 <jmcarthur> quicksilver: not in general, no, but a lot of things that's aren't generally computable are useful
09:24:20 <quicksilver> that was a bait and switch.
09:24:26 <quicksilver> lots of non computable things are useful, yes.
09:24:39 <quicksilver> however, non-computable side conditions are a really nasty thing for a semantics
09:24:47 <MissPiggy> somethings up with thes sever by the looks...
09:25:23 <jmcarthur> quicksilver: i think the idea is that you aren't going to be using unamb in cases that you can't prove that it's reasonable to use it
09:25:26 <k23z__> MissPiggy: I'd sure write something in haskell
09:25:27 <MissPiggy> quicksilver I don't think non-computable is a problem though -- it's just a proof obligation (there's no algo to prove stuff in general but you can get a cup of coffee and sit down with it)
09:25:38 <quicksilver> jmcarthur: yes, that is the idea.
09:25:40 <MissPiggy> k23z__, yes?
09:25:45 <k23z__> sure theng
09:25:50 <quicksilver> jmcarthur: I'm just saying, that breaks the semantics of the language.
09:26:01 <MissPiggy> k23z__, I am just adding little bits to my program every so often
09:26:06 <quicksilver> One of the things conal likes about haskell - one of the things I like about haskell - is that we believe it has a denotational semantics.
09:26:20 <quicksilver> with unamb, you add a horrific burden to that semantics.
09:26:22 <k23z__> MissPiggy: what are you writting miss  piggy ?
09:27:14 * roconnor agrees with MissPiggy
09:27:16 <MissPiggy> k23z__ it's a language for doing algebraic stuff
09:27:57 <MissPiggy> quicksilver: (btw, what you said there is why I don't use amb :P  I use monad which lets you define amb as a pure haskell function)
09:28:47 <roconnor> It would be nice to add a top to our domains.
09:28:58 <roconnor> then I we'd always have a lub
09:29:06 <roconnor> s/I //
09:29:28 <MissPiggy> what would top be though?
09:29:38 <roconnor> contradiction
09:29:40 <k23z__> MissPiggy: what exactly are you doing with it
09:29:44 <k23z__> MissPiggy: what algebraic stuff ?
09:30:13 <MissPiggy> k23z__: for a start multiply out polynomials and factor them
09:30:31 <k23z__> MissPiggy: factor polynomials ? Berlekamp ?
09:31:00 <roconnor> MissPiggy: do you know how to figure out if a polynomial is reducible or not?
09:31:12 <k23z__>  Berlekamp !
09:31:17 <zygoloid> if we assume the rest of haskell is monotonic, it suffices to show that lub is monotonic in both arguments. since it's commutative it suffices to show that "lub a" is monotonic. suppose b <= c. then lub a b <= lub (lub a b) c == lub a (lub b c) == lub a c.
09:31:17 <MissPiggy> I will read about Berlekamp's algorithm but the first algorithm I implement is this:
09:31:41 <k23z__> you can implement many algorithms ... but Berlekamp is on the edge ...
09:31:46 <jmcarthur> MissPiggy: Computation captures amb in a pure way, but I'm less certain how to treat unamb using Computation. have you thought much about it?
09:31:46 <k23z__> it's also hard to understand
09:31:49 <k23z__> I mean hard like shit
09:31:55 <k23z__> I haven't been able to get around reading it
09:32:03 * Zao pets k23z__ 
09:32:06 <choffstein> Hey all.  I am new to Haskell and was wondering if someone could point me in the direction of how to use @ with pattern matching on a function that is pattern matching on a user defined data type
09:32:12 <MissPiggy> to factor a degree n polynomial m, pick two polynomials p,q with undefined coeff. whoes order sums to n. then solve the linear diophantine equation you get from pq=m
09:32:40 <k23z__> MissPiggy: and you rely on haskell to solve that diophantine for you ?
09:32:42 <MissPiggy> it's pretty much the worst algorithm which is complete and correct
09:32:46 <choffstein> Basically, I want to do: someFunc C@(Constructor { elem1 = e1, elem2 = e2}) =
09:32:54 <k23z__> MissPiggy: yes it's a pretty bad algorithm
09:33:21 <choffstein> I think it is called an 'as-pattern'?
09:33:21 <MissPiggy> jmcarthur: actually I had no idea what is the differecence between them?
09:33:34 <roconnor> MissPiggy: how do you solve such diophantine equations?
09:33:36 <MissPiggy> roconnor, that's how I do it anyway -- but yeah there will be better ones :)
09:33:45 <jmcarthur> MissPiggy: amb doesn't require that both sides agree
09:33:55 <c_wraith> choffstein: You can't use a capital letter, because it's treated as a value
09:33:55 <roconnor> MissPiggy: actually I'm intersted in any algorithm at all, since I don't intend to run it.
09:34:19 <c_wraith> choffstein: that is, things that start with capital letters are treated as constructors when pattern-matching
09:34:24 <jmcarthur> MissPiggy: the procondition for unamb is that if both arguments are not _|_ then they must yield the same value
09:34:28 <jmcarthur> *precondition
09:34:31 <choffstein> c_wraith: Ah, thanks for the reminder.  That was exactly the problem
09:34:45 <MissPiggy> roconnor: well you can actually use guass elimination -- but on the other hand, it's a special kind of matrix that you can actually do in an easier way (factor an integer then solve a list of congruence problems) -- an even easier way (which is probably MORE inefficient) is just asking the constraing library to do it: literally p*q = m factors m into p and q (or tells you it's impossible)
09:34:57 <jmcarthur> MissPiggy: it's useful for, say, trying a commutative operation both ways and returning the first one that completes
09:35:24 <roconnor> MissPiggy: what fields are you working in?
09:35:35 <MissPiggy> (the trick with gauss elimination over integers is that instead of R3 - (aik/aij)R2 you do aij*R3 -aik*R2
09:35:51 <roconnor> er, what rings are you working in?
09:35:53 <MissPiggy> well I only really care about gaussian integers
09:35:57 <MissPiggy> at the moment...
09:35:58 <roconnor> oh
09:36:10 <MissPiggy> I don't know if there's a better place to look
09:36:14 <c_wraith> heh.  the CEO wandered in and asked why I was in. :)
09:36:37 * roconnor tries to remember the problem he needs to solve.
09:36:38 <medfly> c_wraith, what if he is on this channel
09:36:41 <medfly> does anyone else share that fear
09:36:43 <k23z__> can Haskell do constraint programming ?
09:36:51 <MissPiggy> k23z__ yeah
09:36:53 <roconnor> @faq can Haskell do constraint programming ?
09:36:53 <lambdabot> The answer is: Yes! Haskell can do that.
09:36:54 <c_wraith> medfly: I don't :)
09:36:59 * k23z__ doesn't really know what that is, he just heard about it in the context of Prolog
09:37:16 <opqdonut> gah, why are dependencies for hackage packages always broken...
09:37:18 <MissPiggy> k23z__ yeah I was using prolog at first but I needed functions so I switched to haskell
09:37:35 <k23z__> MissPiggy: why don't you like predicates ?
09:37:40 <MissPiggy> what
09:37:46 <k23z__> MissPiggy: prolog has predicates
09:37:52 <k23z__> MissPiggy: what what ?
09:37:54 <MissPiggy> I know a bit of prolog
09:37:57 <etpace> roconnor: do you know of a "Field" library? or how can i have a datatype for a Field p (field moduluo p) and it will typecheck that I dont use a Field q instead
09:38:15 <k23z__> MissPiggy: yes, so why did you find Prolog inappropriate for your task ?
09:38:18 <c_wraith> agh.  Why does the .cabal format requires commas in some lists (dependencies), but not in others (exposed module lists)?
09:38:26 <MissPiggy> because I need functions for something
09:38:36 <medfly> constraint programming reminds me of list comprehensions.
09:38:55 <medfly> (I just discovered the term, ignore me)
09:40:08 <MissPiggy> etpace I think that does exist
09:40:23 <MissPiggy> etpace I was searching for it (for like an hour) the other day and I couldn't find it though
09:42:20 <k23z__> ah this steak is really good
09:42:31 <k23z__> *nom* *nom*
09:42:34 <MissPiggy> lol
09:42:49 <MissPiggy> k23z__ I am reading about Berlekamp's algorithm
09:42:56 <MissPiggy> in wiki :(
09:43:14 <k23z__> MissPiggy: I wanted to implement it, in my quest to conquer Galois groups
09:43:28 <MissPiggy> alright
09:43:35 <Phyx-> arg.. i hate the "prelude.undefined" error
09:43:38 <Phyx-> now where can it be
09:43:39 <k23z__> MissPiggy: if you do make an implementation let me know, I'd like convert it to Perl
09:43:59 <MissPiggy> k23z__ okay
09:45:27 <k23z__> MissPiggy: did you receive the jap guy's email with solution to problem 269 of Project Euler that I forwarded to you maybe a week ago ?
09:45:38 <Zao> k23z__: Note that there's a #haskell-blah for off-topic subjects.
09:45:43 <Zao> Like say, steak and Perl.
09:46:03 <jpcooper> mmmmm
09:46:05 <MissPiggy> k23z__ yeah I didnt' read it yet :(
09:46:26 <MissPiggy> k23z__ I did get it though, I was a bit disappointed I didn't solve the problem myself
09:46:49 <k23z__> MissPiggy: don't worry, understanding the solution is also challenging ..
09:47:55 <k23z__> MissPiggy: and guess what, if you have the solution to the problem(which is a number ...) you can go to project Euler and put it in, and then you unlock the forum pages for that particular problem and you can see all the people who solved it bragging about their solutions, and some are different, there is a multitude of solutions to this problem ...
09:48:07 <k23z__> MissPiggy: some solve it in different languages and all with different approaches
09:48:34 <MissPiggy> yeah that is fun
09:48:54 <k23z__> fun and a time sink at the same time
09:49:02 <opqdonut> great, now gitit chokes on it's default config file
09:49:09 <opqdonut> with a Prelude.read: No parse...
09:52:40 <MissPiggy> k23z__ belekamp works over finite field -- how do you use it for factoring over an infinite one (such as integers)
09:55:08 <k23z__> MissPiggy: you choose a big enough finite field
09:55:24 <k23z__> MissPiggy: there are upper and lower bounds for roots depending on various stuff
09:55:33 <k23z__> MissPiggy: see V. Prasolov - Polynomials for bounds
09:55:59 <k23z__> MissPiggy: I have asked myself the same question some time ago
09:56:15 <k23z__> MissPiggy: I haven't implemented it... but V. Prasolov has a good exposition and his book is pretty solid
09:56:21 <MissPiggy> k23z__ ah! good thought
09:56:46 <k23z__> I think the bounds depend on the coefficients ...
09:57:20 <c_wraith> Is it possible to write code that works with quickcheck 1 or 2?
09:59:36 <Phyx-> hmm, what can cauze FFI to throw a Prelude.undefined error? the code i'm sending through it uses no undefined
10:00:36 <Zao> Phyx-: What code?
10:01:25 <Phyx-> Zao: i'm calling the ghci api
10:01:29 <Phyx-> the lexer
10:01:33 <Phyx-> it was working
10:01:41 <Phyx-> then i changed the sizeOf fields to be more accurate
10:01:46 <Phyx-> and i got a undefined
10:02:07 <Phyx-> i'm thinking the sizeOf is wrong, some are not multiples of the alignment
10:04:50 <zenzike> Given a function f :: a -> m a, and a value x :: a, I want to describe a function that does: f x >>= \y0 -> f y0 >>= \y1 >>= f y1 >>= ... where this goes on forever. Does anyone know if this function is standard?
10:05:18 <zenzike> it's a bit like forever, but I don't think the types fit
10:05:52 <zygoloid> zenzike: well, there's mfix but that doesn't have the same semantics
10:05:53 <Zao> Phyx-: That sounds a bit scary.
10:05:55 <monochrom> @type foldM
10:05:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:06:17 <Phyx-> Zao: howso?
10:06:18 <monochrom> No standard.
10:06:27 <zygoloid> @type fix . (=<<)
10:06:28 <monochrom> err, Not standard
10:06:28 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
10:06:56 <zenzike> ah, that seems about right. thanks for the help :-)
10:07:06 <zygoloid> @type mfix
10:07:07 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:07:33 <zygoloid> zenzike: if you want the monadic part done once, and the fixed point for the value part, mfix is your go-to function
10:07:51 <zenzike> I actually want the monadic part done over and over
10:08:03 <zygoloid> (monad restrictions apply. your code is at risk if you do not keep up repayments on technical debt secured against it)
10:08:54 <zenzike> zygoloid: :-) heh, yeah, this is all just for a bit of fun. I guess it's a bit like a monadic iterate, but where the results are thrown away each time
10:09:14 <zygoloid> rereading your original question, fix . (=<<) isn't what you want either
10:09:44 <zenzike> oh ...
10:10:00 <zygoloid> (because it doesn't use your 'starting value')
10:10:45 <zenzike> hrm, that's true. I guess it's not as standard a question as I thought it might be then.
10:14:03 <zygoloid> @type \f x -> fix (. (>>=f)) (return x)
10:14:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m a) -> a -> b
10:14:13 <monochrom> @type iterateM
10:14:15 <lambdabot> Not in scope: `iterateM'
10:14:52 <zygoloid> @type \f x -> iterate (>>= f) x
10:14:53 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b -> [m b]
10:15:00 <doserj> @type fix (liftM2 flip ((>>=) .))
10:15:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m a) -> a -> m b
10:15:20 <zygoloid> @pl \f x -> fix (. (>>=f)) (return x)
10:15:21 <lambdabot> (. return) . fix . flip (.) . (=<<)
10:15:32 <zenzike> I have : foo f x = f x >>= \y -> foo f y
10:15:50 <doserj> @pl let g f x = f x >>= \ y -> g f y  in g
10:15:50 <lambdabot> fix (liftM2 flip ((>>=) .))
10:16:54 <zenzike> what does @pl do?
10:17:17 <doserj> transform into pointless form
10:17:48 <doserj> @pl \x -> x
10:17:48 <lambdabot> id
10:17:49 <zenzike> ah, so lambdabot gives me the answer i want. very convenient!
10:18:07 <FunctorSalad> the profiler doesn't work for me anymore... claims 0.00 s / 0 ticks (the program runs many seconds)
10:19:03 <FunctorSalad> (related to overhauling my kernel config?)
10:19:14 <zygoloid> @type \f -> fix ((. f) . (=<<))
10:19:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
10:20:19 <aavogt> @src fixM
10:20:20 <lambdabot> Source not found.
10:23:15 <FunctorSalad> allocation stats and entry count seem to work, just not time
10:23:40 <k23z__> FunctorSalad: I make a salad with you
10:23:43 <zenzike> Thanks for the help :-) looks like there are plenty of versions to choose from
10:24:27 <FunctorSalad> (by the way, how does IO-wait show up in the profiling report?)
10:27:05 <roconnor> Berlekamp's algorithm is a well-known method for factoring polynomials over finite fields.
10:27:08 <roconnor> :( only finite fields
10:27:37 <MissPiggy> roconnor k23z__ says you can pick a finite field which is big enough that it coincides with the infinite case
10:28:33 <roconnor> MissPiggy: that sounds interger only
10:28:43 <k23z__> roconnor: yes, integer only
10:28:51 <k23z__> MissPiggy: so you'll need the roots be integers
10:28:53 <k23z__> :(
10:28:59 <k23z__> apparently my idea was fail
10:29:37 <MissPiggy> you don't need to factor into
10:29:47 <MissPiggy> (x-a0)(x-a1)...(x-an)
10:29:48 <sinelaw> does anyone know a quick method for factoring small polynomials by hand?
10:29:55 <k23z__> sinelaw: how small ?
10:30:03 <sinelaw> up to order 10
10:30:05 <k23z__> sinelaw: degree 2,3,4 are doable
10:30:07 <MissPiggy> you can factor into (ax^2+bx+c)(px^2+qx+r) which are both irreducible for example
10:30:28 <k23z__> sinelaw: from degree 5 upwards it gets nasty
10:30:41 <MissPiggy> well 2,3,4 have closed form solutions :P
10:30:43 <sinelaw> k23z__, you know about cyclic codes?
10:30:52 <k23z__> sinelaw: no , why ?
10:30:59 <sinelaw> they're based on finite fields
10:31:18 <k23z__> ok , and they provide any solutions to factoring ?
10:32:02 <sinelaw> k23z__, no. each message is seen as a polynomial of order k, it is multiplied by a "generating polynomial" of order (n-k) to get a codeword of order n, and the coefficents are taken from a finite field
10:32:29 <sinelaw> so to find generating polynomials with the cyclic property you need to factor polynomial of a certain form
10:32:38 <sinelaw> specifically, x^n + 1
10:32:48 <sinelaw> maybe there's a quick method for these specific polynomials over a finite field?
10:33:03 <sinelaw> oops, the coefficents are of a find field
10:33:29 <k23z__> I don't know as I haven't studied code theory
10:33:38 <Saizan> ruffini?
10:33:43 <roconnor> sinelaw: Berlekamp's algorithm is a well-known method for factoring polynomials over finite fields.
10:33:57 <k23z__> I study group theory in an amateurish way ...
10:34:15 <roconnor> the CantorZassenhaus algorithm is a well known method for factorising polynomials over finite fields (also called Galois fields).
10:34:29 <roconnor> It is arguably the dominant algorithm for solving the problem, having replaced the earlier Berlekamp's algorithm of 1967.
10:34:51 <sinelaw> roconnor, and there's also something about using the primitive elements of a finite field to find the factorizations?
10:36:11 <etpace> @hoogle (^)
10:36:11 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
10:36:11 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
10:36:11 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
10:36:25 <etpace> what typeclass is ^ defined in?
10:36:34 <Alpounet> @type (^)
10:36:35 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
10:36:35 <mauke> none
10:36:48 <etpace> oh
10:39:20 <zygoloid> @src (^)
10:39:23 <lambdabot> x ^ 0            =  1
10:39:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
10:39:31 <lambdabot>   where f _ 0 y = y
10:39:33 <lambdabot>         f x n y = g x n
10:39:37 <lambdabot> Plugin `source' failed with: thread killed
10:40:50 <zygoloid> :( that missed out the only interesting bit. it says: in x^n, if n is even, the result is (x^2)^(n/2) otherwise it's x*(x^2)^(n`div`2)
10:41:03 <zygoloid> > x ^ 13
10:41:04 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * x)
10:43:59 <EvanCarroll> what is the purpose of defining g x n in the src for ^
10:45:38 <doserj>  where g x n | even n  = g (x*x) (n `quot` 2) -- to not carry around the y in this recursion
10:46:51 <EvanCarroll> i don't see that code
10:47:00 <EvanCarroll> @src (^)
10:47:00 <lambdabot> x ^ 0            =  1
10:47:00 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
10:47:00 <lambdabot>   where f _ 0 y = y
10:47:00 <lambdabot>         f x n y = g x n
10:47:00 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
10:47:02 <lambdabot>                       | otherwise = f x (n-1) (x*y)
10:47:04 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
10:47:11 <EvanCarroll> oh hot damnn
10:47:18 <EvanCarroll> lambdabot got cut off
10:49:57 <aavogt> > let pow x n | n <= 1 = x | even n = pow (x*x) (n `div` 2) | otherwise = x * pow x (n-1) in pow 3 3
10:49:59 <lambdabot>   27
10:50:40 <aavogt> so it isn't written like that because it's better to be tail-recursive?
10:50:48 <medfly> @src quot
10:50:49 <lambdabot> Source not found. You untyped fool!
10:51:27 <aavogt> @scheck \x y -> y /= 0 || div x y == quot x y
10:51:28 <lambdabot>   "* Exception: divide by zero
10:51:36 <aavogt> @scheck \x y -> y == 0 || div x y == quot x y
10:51:37 <lambdabot>   "Falsifiable, after 12 tests:\n5\n-4\n"
10:51:53 <aavogt> @scheck \x y -> y <= 0 || div x y == quot x y
10:51:54 <lambdabot>   "Falsifiable, after 9 tests:\n-2\n5\n"
10:51:57 <zygoloid> aavogt: yeah, it seems to be operating on the assumption that Num instances are usually strict.
11:17:14 <c_wraith> hmm.  What's the easiest way to test my package under GHC 6.12?
11:18:14 <jmcarthur> install 6.12?
11:18:25 <jmcarthur> or maybe just submit to hackage and see if it builds there?
11:19:18 <c_wraith> Does 6.12 come with older versions of base?
11:19:48 <jmcarthur> it complains if a package uses an old base that that version is deprecated, but it builds
11:20:14 <jmcarthur> at least it does with -Wall. it might not without
11:21:16 <c_wraith> I'm into the details of releasing a package now.  I'm sure that the base code will work in 6.10 and 6.12.  It's just a matter of getting the details of the cabal file right
11:23:13 * hackagebot upload: babylon 0.2 - An implementation of a simple 2-player board game (PedroVasconcelos)
11:24:09 <Saizan> c_wraith: 6.12.1 comes with a base-3 too
11:24:31 <Saizan> ah, sorry
11:25:13 <Saizan> c_wraith: btw, the QuickCheck thing worked?
11:26:04 <c_wraith> Saizan: yeah.  Ended up working cleanly.  Didn't find any bugs yet, but I expect it will as soon as I add more functionality instead of just working on making it releasable
11:26:26 <c_wraith> Like..  My use case has no need for deletes.  But that's probably functionality that should be in the package.
11:28:11 <olognation> Does anyone check gmail using haskell?
11:28:31 <Saizan> c_wraith: nice
11:29:31 <tARrAScH> I've run 'cabal install mohws', In what sense have I installed the web server, is there any binary I can run now? (btw. is it easier to run mohws or Apache?)
11:32:04 <CalJohn> hmmm...haskell-mode seem to have suddenly decided that Shift is Control...
11:32:52 <MissPiggy> shift to control
11:33:34 <CalJohn> i don't even understand...this is only haskell mode, the rest of emacs is fine
11:34:34 <sam-eb-chase> exit
11:34:40 <monochrom> It has read some papers on "shift" and "control" and delimited continuations. :)
11:36:34 <CalJohn> this makes no sense
11:37:07 <CalJohn> restarting emacs makes no difference
11:37:20 <monochrom> It is strange.
12:03:49 <gwern> dang ubuntu karma. freeze the system upon any usb device being added!
12:03:55 * gwern wants a refund
12:04:37 <Gracenotes> my karma is good to me
12:05:04 <Gracenotes> does it freeze up registering the device, or mounting it?
12:05:37 <gwern> Gracenotes: I'm not sure
12:06:00 <gwern> I have a scanner and it freezes the first mouse movement or key stroke after flipping the powerswitch
12:06:09 <gwern> so fine distinctions like register or mount are beyond me
12:07:21 <Gracenotes> scanner-wise, I suppose you only mount filesystems, giving contents names you can access the files by
12:09:10 <Gracenotes> gwern: otherwise try https://wiki.ubuntu.com/HardwareSupport
12:09:58 <gwern> Gracenotes: and do what?
12:10:05 <Gracenotes> and find your device
12:10:14 <gwern> the scanner isn't the problem
12:10:22 <gwern> my [[GP2X]] does the same thing
12:11:00 <sam-eb-chase> Can someone please tell me which the best introductory book/tutorial is?
12:11:17 <sioraioc_> sam-eb-chase: there isn't a canonical one, there are many
12:11:51 <sam-eb-chase> I have started reading Real World Haskell and Learn you a Haskell for great good
12:11:54 <Gracenotes> hm. site:ubuntuforums.org probably your best bet then
12:11:59 <doserj> http://www.haskell.org/haskellwiki/Meta-tutorial
12:12:11 * sioraiocht likes the Hutton book.
12:12:17 <sam-eb-chase> Something that is easy to follow for beginners
12:12:23 <gwern> Gracenotes: I tried; usb freeze gives an awful lot of hits
12:12:26 <Gracenotes> sam-eb-chase: both of those are great
12:12:44 <MissPiggy> gwern !
12:13:00 <MissPiggy> you mentioned Matiyasevichs theorem yesteryda?
12:13:06 <sam-eb-chase> What about the lisperati one?
12:13:11 <gwern> MissPiggy: I didn't, no
12:13:15 <MissPiggy> oh
12:13:19 <Gracenotes> that's quite a mouthful, MissPiggy
12:13:28 <MissPiggy> hm it was ksf oh kmc or something then
12:13:47 <MissPiggy> Gracenotes haha I actually can't pronounce it
12:14:52 <Gracenotes> MissPiggy: what's the theorem about?
12:15:18 <Gracenotes> ah, diophantine equations
12:15:54 <MissPiggy> Gracenotes yeah looks like a pretty hard theorem but I found a book on it that claims to be easy going
12:16:17 <Gracenotes> number theory is a confusing mistress
12:16:28 <jmcarthur> so any good haskell jobs around?
12:16:49 <MissPiggy> they say number theory is the queen of mathematics
12:17:02 <gwern> not logic?
12:17:31 <applicative> sam-eb-chas: what was wrong with Real World Haskell and Learn You a Haskell?
12:18:03 <jmcarthur> sam-eb-chase: learn you a haskell is probably more beginner friendly than real world haskell
12:18:31 <Gracenotes> it's because of the list-worm, isn't it
12:18:33 <applicative> jmcarthur:  there are different kinds' of beginner
12:18:51 <doserj> MissPiggy: s/they/Gauss/
12:18:59 <jmcarthur> applicative: i know, but most beginners i hear from say LYAH fits them better
12:19:02 <MissPiggy> :)
12:19:09 <jmcarthur> it's just a numbers game i'm playing
12:19:14 <Gracenotes> RWH has great exercises, though
12:19:19 <jmcarthur> agreed
12:19:33 <applicative> sam-eb-chas:still there?
12:19:59 <jmcarthur> my personal preference is RWH, but when somebody seems to be complaining about the choice of tutorials out there RWH is probably not what they are after
12:20:01 <Gracenotes> it's good to go through it, noting particularly interesting or confusing things, mentioning them to the channel, etc.
12:20:03 <sam-eb-chase> applicative: nothing wrong with them, I was just wondering if there is anythind else.
12:21:31 <sam-eb-chase> I'll check the exercises out.
12:21:51 <applicative> there is a range of things of course.  You should get hold of the typeclassopedia and study as soon as you have the concepts in place.   Hutton's book is a little plodding, but it is short and covers the basics in a way that doesn't presuppose even that you know other languages.
12:23:01 <applicative> There are some videos of Eirc Meijer (sp)trying to teach Hutton on the Microsoft web network whatever it is.  They are of mixed quality, but he's great when he's got it together
12:23:37 <sam-eb-chase> I'll check them out.
12:24:35 <sam-eb-chase> I think I bookmarked those a few days ago.
12:25:32 <applicative> Hutton's one obnoxious feature is that he uses a funny method of representing code, typical of academic literature, so -> appears as a proper arrow, and so on.  -- That'sokay, but it gets more confusing at points
12:26:22 <sam-eb-chase> applicative: does your nickname refer to applicative order? I remember reading about it in SICP.
12:26:26 <applicative> The book I learned the most from was Bird, but it might be that it suited me
12:26:51 <applicative> no, applicative functors, see the typeclassopedia...
12:27:12 <applicative> stupid name, thats what i get for not being clever, then i'd be dmwit
12:27:40 <sam-eb-chase> OK.
12:28:27 <applicative> I concur that LearnYou a Haskell is the best, by the way, though it isn't finished.  His approach, apart from the witty images and so on, has a lot to be said for it from a theoretical point of view.
12:30:06 <sam-eb-chase> I liked reading it. I hope I can make some time to read it soon.
12:30:34 <sam-eb-chase> I mean finish reading
12:30:51 <applicative> Maybe it would be good if someone made a morror with exercises and ancillary readings, so it wouldn't break the artistic flow he has going.
12:30:57 <applicative> a mirror
12:31:16 <Gracenotes> I love the list monster
12:31:22 <applicative> haha
12:31:24 <Gracenotes> rawr
12:31:42 <Gracenotes> http://learnyouahaskell.com/listmonster.png
12:31:44 <sam-eb-chase> I have started reading a lot of stuff, but I really need to read it one at a time. I wish I could speed read
12:32:18 <sam-eb-chase> I remember the list monster.
12:32:49 <Gracenotes> when you do f (x:xs) = x:xs; f [] = [], what you're doing to the list monster is decapitating him and then reattaching his smiling head
12:32:55 <applicative> If you can follow Learn You, I think I  might recommend staying with it, and really laboring over the sections, fooling with the stuff he's defining.    This is because, as I said, I think he gets the learning order right
12:33:20 <mauke> http://images3.wikia.nocookie.net/mario/de/images/c/c7/Wiggler.gif
12:33:26 <Gracenotes> GHC is made of a bunch of list monsters all running around in your memory
12:33:34 <mauke> its name is Wiggler
12:33:45 <Gracenotes> oooh.
12:33:53 <Alpounet> mauke, it's a list comprehension execution flow ?
12:33:56 <jmcarthur> GHC is DAG monsters
12:34:01 <applicative> To take a typical feature, he doesn't first introduce you to the basics about lists and recursion, and then suddenly hit you with the monad
12:34:13 <applicative> he hasn't even gotten to monads, if i remember
12:34:35 <jmcarthur> actually i guess it's just DG monsters
12:35:24 <bookhacker> What is the correct way of writing this: newtype (Num a) => Row = Row [a] deriving (Show)
12:35:32 <applicative> but he does get you into space you need to get into.  He introduces the idea of a "Functor" as "something you can map over", and gets you to see that the fmap that applies to it everywehere is just the map that applies to list -- which everyone understands -- generalized
12:35:47 <applicative> then you are two turns of the crank from the damned monads
12:35:50 <mauke> newtype Row = Row [a] deriving (Show)
12:36:08 <bookhacker> what if you want a to be a Num?
12:36:35 <c_wraith> mauke, that definition has a free variable.
12:36:43 <Twey> Yeah
12:36:43 <Alpounet> bookhacker, you forgot an "a" after Row
12:36:58 <mauke> hmm, yes
12:37:03 <mauke> newtype Row a = Row [a] deriving (Show)
12:37:18 <sam-eb-chase> I really liked reading "Functional Programming for the rest of us". I didn't understand a fair amount of stuff he was talking about, but I could feel my head expanding with knowledge.
12:37:48 <Twey> Hahaha
12:37:58 <applicative> Then in the last existing chapters, he returns to Functors, goes even wilder with them, and ends by slipping Applicative Functors past you.
12:38:11 <bookhacker> Oh i got it, it's newtype (Num a) => Row a = Row [a] deriving (Show)
12:38:33 <mreh> monoids are like socks!
12:38:45 <c_wraith> socks are associative?
12:38:57 <applicative> if you can generalize from map + list to   fmap + Functor, and then to fmap (a/k/a (*)) + pure + Applicative functor, you will be all powerful.
12:38:58 <mreh> it's what it says on LYAH
12:39:17 <applicative> we
12:39:22 <jmcarthur> bookhacker: i recommend against putting constraints directly into your data types like that
12:39:24 <aavogt> well if you put 3 socks on one foot...
12:39:34 <jmcarthur> dang he left
12:39:39 <aavogt> you can take the off in different groups
12:39:47 <applicative> everyone's down on monads are burrito spacesuits, but lingerie monoid illustrations are still kosher
12:40:23 <MissPiggy> hehe
12:40:49 <mauke> lingerie? http://scarletlotus.tumblr.com/photo/1280/390514594/1/tumblr_kxadwlNYpY1qazmdf ?
12:41:11 <sam-eb-chase> Thanks for the help everyone.
12:41:15 <applicative> the one on the right is the monoid
12:41:26 <c_wraith> wow, stephen fry was skinny back then
12:42:16 <applicative> sam-eb-chase: print up the typeclassopedia it wont be intelligible yet, but it depicts an orderly sequence, and you can chart your progress against it.
12:43:12 <applicative> www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
12:43:18 <kmc> i mean it's important first to understand typeclasses and higher order functions
12:43:39 <kmc> typeclassopedia does not explain those concepts, it's a tour of a few specific typeclasses assuming you understand what typeclasses are generally
12:44:02 <aavogt> what better way to learn them than by seeing some specific, commonly used instances of such, kmc?
12:44:15 <sam-eb-chase> I've downloaded it.
12:44:25 <applicative> yes of course, thats why i said, just to have it handy.  Functors come in early in LYAH, you might just have a look ahead, to frame what youre leaning at a point like that
12:44:45 <kmc> aavogt, i think with simpler examples like Eq and Show
12:45:14 <kmc> but then yes
12:45:16 <aavogt> show is weird to write your own instances
12:45:39 <applicative> kmc, but are those really like the typeclasses Functor and Applicative and Monad, somehow it seems a superficial comparison, even though they're the same from the point of view of the language definition
12:46:24 <aavogt> a difference in kinds
12:46:34 <applicative> yeah
12:46:47 <aavogt> I don't remember if that was confusing
12:47:14 <kmc> i don't think it's superficial, the point of having a language that makes sense is to explain everything in terms of the same core concepts
12:47:20 <jmcarthur> aavogt: it's confusing for a lot of beginners. for example, they might wonder why they can't do instance Monad Int, or instance Num Maybe
12:47:20 <applicative> maybe i just mean, the big step if from typeclasses in general, like Eq or Ord, to typeclasses like Functor, which need a universal (*->*) thing to instance
12:47:30 <sam-eb-chase> Thanks again, guys.
12:47:39 <jmcarthur> i've seen many stumble over that
12:48:12 <applicative> A type class that takes a type like Num or Ord as instances, is very different from one that takes a (*->*), it's pretty remote
12:48:28 <jmcarthur> yes
12:48:38 <applicative> To speak of Functor or fmap as overloading, seems kind of silly, for example
12:48:53 <jmcarthur> well, i don't agree with that
12:48:55 <aavogt> funnily enough, the two used to be separate things in haskell, no?
12:49:04 <applicative> oh?  which things?
12:49:08 <aavogt> "constructor classes" vs "type classes"
12:49:26 <jmcarthur> it makes some sense, really
12:49:27 <applicative> I see, yeah, maybe i'm falling into the old view.
12:50:08 <applicative> Still the Functor is like a higher order function in the typesystem, Num is like a regular function, that's not so easy to get straight when youre already in a thin atmosphere
12:50:43 <applicative> There's a genuine pedagogical step
12:51:31 <applicative> but i suppose a pedagogical picture like: first overloading with typeclasses like Num, Ord; then
12:51:45 <applicative> systematic overloading with Functor and Monad etc.
12:51:54 <applicative> might be the way to go.
12:53:44 <applicative> Maybe the "constructor classes" vs "type classes" distinction was only rejected because it wasn't needed for definition or implementation, but that they thought it might be, sort of shows that there's a difference in the human mind.
12:55:05 <Heffalump> I think they used to be separate only because the concept of constructor classes was only developed later
12:56:26 <applicative> It just shows how robust the original idea of typeclasses was.  Haskell is amazing, it seems, in that it goes so much farther than what the founders seemed to envisage.
12:57:05 <applicative> But this is no place to praise Haskell
12:57:14 <jmcarthur> sure it is
12:57:35 <applicative> okay, i let my declaration of amazement stand
12:58:10 * jmcarthur declares amazement
12:58:20 <opqdonut> Amazement amazement;
12:58:30 <applicative> * applicative is amazed every day
12:58:33 <jmcarthur> opqdonut: wong
12:58:35 <jmcarthur> *wrong
12:58:38 <jmcarthur> wow fail
12:58:46 <jmcarthur> amazement :: Amazement
12:58:56 <opqdonut> is that a declaration?
12:59:06 <jmcarthur> well, it's a type signature
12:59:06 <applicative> * ?
12:59:09 <opqdonut> well okay, a type declaration maybe
12:59:33 <opqdonut> but not in the same sense as "Amazement amazement;" would be in some C-ish language
12:59:44 <opqdonut> foo :: Foo on it's own does nothing
12:59:45 <jmcarthur> i guess it's more like a prototype than a declaration, in the C sense
12:59:56 <opqdonut> and foo = <expr> is not a declaration, it's a definition
13:00:04 <jmcarthur> yeah
13:00:19 <opqdonut> i've always thought of declarations as a somewhat imperative thing
13:00:36 <jmcarthur> they have side effects and everything
13:00:40 <applicative> jmcarthur: i'm an irc idiot, how do i get these expressioins of thought, I thought with a '*'.
13:01:04 <aledge> "/me"
13:01:05 <ski> applicative : `/me shakes head in amazement'
13:01:20 * applicative shakes head in amazement, for sure
13:01:38 * camio shrugs
13:01:52 * jmcarthur shrubs
13:01:59 * applicative thinks camio needs to study more, then.
13:02:05 <camio> Hrm, is there a difference between '/me' and '/action'?
13:02:16 * jmcarthur didn't know there was an /action
13:02:31 <jmcarthur> looks like /action is different
13:02:36 <Zao> camio: Both are client-specific.
13:02:44 <Zao> camio: It's just that there's a rather common set most clients implement.
13:02:49 <jmcarthur> actually, /action doesn't do anything in weechat at all
13:03:06 <Zao> What matters is the \001ACTION\001 sent by the client.
13:03:16 <applicative> the /action doesnt do anything one the web freenode either, for us irc idiots
13:03:42 <Alpounet> /me is the most common I think
13:05:17 <damd> what is /action supposed to do as opposed to /me?  same thing?
13:05:29 <opqdonut> same thing
13:06:57 * Alpounet about to watch the "Push-pull Functional Reactive Programming" talk
13:08:45 * ski . o O ( "push-me-pull-you" )
13:09:38 <jmcarthur> Alpounet: wait, there's a talk?
13:10:50 <Alpounet> ski, :D
13:10:58 <Alpounet> jmcarthur, http://www.vimeo.com/6686570
13:11:16 <Alpounet> jmcarthur, I discovered it while doing some search related to lub and unamb
13:11:26 <Alpounet> it's on conal's page about that
13:11:36 <IceDane> @hoogle liftIO
13:11:36 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
13:11:50 <jmcarthur> ah given by conal and everything
13:11:55 <conal> :)
13:12:04 <jmcarthur> i'll have to give it a watch in case there's anything new for me there
13:12:12 <gwern> quick poll, which is clearer: 'a++b++c' or 'concat [a,b,c]'?
13:12:12 <jmcarthur> or maybe there's an interesting question or two at the end
13:12:30 <ski> (.. pulation squares are illustrated as such beasts in "The Joys of Cats : Abstract and Concrete Categories")
13:13:05 * jmcarthur wishes he could make it to these events, like ICFP and all that
13:13:27 <roconnor> a++b++c
13:13:32 <ski> gwern : depends on how many the three pieces in the concatenation are
13:13:38 <gwern> ski: ?
13:14:33 <jmcarthur> conal: quicksilver was saying earlier that he thought lub broke monotonicity somehow. is this something that has come up?
13:14:50 * ski thinks `concat ["(",show x," ++ ",s,")"]' clearer than `"(" ++ show x ++ " ++ " ++ s ++ ")"'
13:14:51 <jmcarthur> i haven't studied the issue yet
13:15:14 <conal> jmcarthur: i have a vague memory of someone making that suggestion.  i don't think it's so.
13:15:20 <gwern> ski: that's pathological; I don't think concat comes out much better
13:15:40 <gwern> with a similarly pathological example
13:15:53 <kuribas> libghc6-regex-base has no documentation on debian?
13:16:05 <gwern> kuribas: -doc look for?
13:16:06 <jmcarthur> conal: btw, as a followup, i've been unable to use unamb for my AI project
13:16:09 * camio thinks `printf "(%s ++ %s)" x s` is clearer than that.
13:16:13 <kuribas> gwern: I couldn't find it...
13:16:22 <conal> jmcarthur: what happened?
13:16:24 <jmcarthur> conal: it used too many threads and made GHC cry, and i really didn't want to limit my search depth
13:16:34 <conal> jmcarthur: yep.
13:16:41 <ski> gwern : i've written similar things .. the main point i think the `concat' version is clearer there is that it is slightly shorter; so it's not a big difference, no
13:16:42 <jmcarthur> conal: so i've moved on to the Computation monad suggested by MissPiggy instead
13:16:49 <jmcarthur> conal: which gives me amb in a pure way
13:17:08 <conal> jmcarthur: at the cost of more obscure types
13:17:09 <jmcarthur> which is really what i wanted anyway, rather than unamb
13:17:10 <gwern> ski: I'm only interesting in 3 or fewer items. concat == ++ at 4 variables, and is shorter thereafter
13:17:26 <ski> ok (that was not clear)
13:17:27 <jmcarthur> conal: somewhat more obscure, yeah, but i'm kind of liking it
13:17:29 <conal> jmcarthur: oh -- if you want amb, you'll need a more obscure type anyway.
13:17:35 <jmcarthur> right
13:17:47 <gwern> jmcarthur: I hope you never need write up the Computation monad. 'I am indebted to Miss Piggy for originally suggesting this abstraction to me.'
13:18:18 <gwern> ski: for 3 or fewer do you prefer ++ too?
13:18:28 * gwern is thinking hlint suggestions
13:18:30 <jmcarthur> gwern: well, i haven't seen it used for the things i'm using it for before she showed me
13:18:41 <ski> gwern : at least in case `a',`b',`c' there are all identifiers, yes
13:19:09 <ski> (and probably in most, if not all other common cases as well)
13:19:16 <conal> jmcarthur: i think of the current unamb impl as a temporary measure. for demonstrating unamb uses.  when enough compelling uses are out there, then there will be incentive to give it an efficient impl.  As was the case with laziness.
13:19:30 <jmcarthur> conal: yeah, i look forward to that day
13:19:57 <jmcarthur> i think currently it's hard enough just to make it not look scary
13:20:32 <conal> jmcarthur: also like laziness.
13:20:41 <conal> jmcarthur: i expect that lots of examples will help
13:20:55 <jorick> what does it mean? can not construct the infinite type when generalising the types for...
13:21:08 <mauke> jorick: "type error"
13:21:11 <conal> jmcarthur: it's such a simple, pure idea: combine the info present in two compatible values.
13:21:30 <conal> (lub, that is)
13:22:20 <aavogt> > (\(x:xs) -> x ++ xs) "hello"
13:22:21 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
13:22:26 <mauke> jorick: you've written code that tries to use an ill-typed value, such as a list that contains itself or a function that returns itself
13:22:56 <jmcarthur> conal: of course, many people see it as something like (if a == _|_ then b else a), which does indeed look scary
13:23:01 <gwern> wow. lots of uses of 'concat' with <=3 args
13:23:04 <gwern> tsk tsk
13:23:23 <jorick> when i leave the type signature out it works... how do i convert the ':t' output to a typedef?
13:23:27 <Alpounet> gwern, seriously ?
13:23:37 <mauke> jorick: uh, just paste it in?
13:23:48 <gwern> Alpounet: no, this is part of an elaborate hoax involving llamas
13:24:09 <gwern> llamas? did someone say llamas?
13:24:10 <gwern>  CUIDADA LLAMA!
13:24:20 <jmcarthur> of course that ignores the crucial detail that a and b agree
13:24:36 <conal> jmcarthur: oh well.  people can learn.
13:25:01 <gwern> conal: studies suggest that they can't
13:25:25 <jorick> type AgentFn a = a -> Event -> ReaderT (Env, Agent) IO a                              runAgent :: (AgentFn a) -> a -> Env -> IO Agent
13:25:45 <conal> gwern: darwin told us how those folks are handled.
13:25:55 <gwern> conal: in the long run, we're all dead
13:26:13 <jmcarthur> conal: darwin didn't account for welfare ;)
13:26:57 <conal> wow -- i guess i'm more optimistic about intellectual progress than you guys.
13:27:05 <camio> Didn't sparta win when vs. athens?
13:27:09 <jmcarthur> oh but i jest
13:27:15 <conal> :)
13:27:15 <badsheepy> until it lost again :o
13:27:21 <_zenon_> @find allan cole
13:27:23 <lambdabot> Not in scope: type variable `allan'
13:27:23 <lambdabot> Not in scope: type variable `cole'
13:27:45 <jmcarthur> there are many scales to account for when looking at intellectual progress. on the small scale, it's really hard to see it sometimes
13:28:14 <jmcarthur> at least when you are filtering it with a specific critera
13:28:57 <Alpounet> I think there should be a Haskell day
13:29:09 <jmcarthur> every day is haskell day!
13:29:18 <gwern> camio: sparta won in the short term, lost in the long
13:29:20 <Alpounet> where all cities with >= 500.000 people would organize haskell talks
13:29:36 <gwern> although thebes had more to do with that long-term victory than athens did eventually
13:29:38 <lament> feb. 14th
13:29:56 <conal> which reminds me -- i've wondered how we might formulate a fitness function that would encourage, through chaos/creativity and "natural" selection, people to learn & make progress in denotative/functional programming.
13:30:06 <jmcarthur> Alpounet: reminds me of the simultaneous hackathon i participated in with hackerspaces around the country a few months ago
13:30:22 <Alpounet> haha nice
13:30:34 <camio> gwern: oh, I wasn't aware of that. Then there's the barbarians vs. roman empire. I don't think smart is necessarily fit.
13:30:58 <lament> if smart was necessarily fit, all life would have developed intelligence a long time ago
13:31:03 <gwern> camio: thebes was really smart: they took all their loot from handing sparta's ass to it, and set up a rival city using the helots
13:31:04 <jmcarthur> Alpounet: we had video feeds of all the hackerspaces projected on the walls of each hackerspace. was pretty cool
13:31:27 <MissPiggy> conal -- I would think trying to restrict to fp would be harmful
13:32:00 <jmcarthur> conal: a fitness function with what kind of inputs?
13:32:04 <SubStack> does haskell have any symbolic algebra packages that weren't released in 1995?
13:32:10 * SubStack stares at docon
13:32:20 <MissPiggy> SUbStack, I am doing symbolic algebra :P
13:32:25 <jmcarthur> SubStack: it will have the one you haven't written yet
13:32:29 <MissPiggy> SUbStack, but mine doesn't do anything yet
13:32:33 <mauke> > x ^ 3
13:32:34 <lambdabot>   x * x * x
13:32:49 <conal> FP has particular motivations.  suppose we formalize these motivations into a fitness function, and then invite people to program in an environment governed by that fitness function.
13:32:50 <jmcarthur> > x ^ 4
13:32:51 <lambdabot>   x * x * (x * x)
13:32:55 <Alpounet> jmcarthur, it seems there'll be such a hackathon if PDX/SF soon
13:32:57 <Alpounet> s/if/in/
13:33:02 <jmcarthur> ah nice, i was wondering if it would do the precedence that way
13:33:03 <conal> jmcarthur: code, i guess.
13:33:08 <lament> conal: s/FP/life
13:33:15 * SubStack is tired on solving non-linear systems of equations for the equation of a camera ray
13:33:17 <lament> conal: s/program/live :)
13:33:17 <MissPiggy> > x ^ 8
13:33:18 <lambdabot>   x * x * (x * x) * (x * x * (x * x))
13:33:25 <SubStack> it'd be nice to automate that part
13:33:29 <MissPiggy> SubStack, hmm non-linear?
13:33:36 <MissPiggy> SubStack, like polynomials or what
13:33:50 <SubStack> so far only squared terms
13:33:56 <conal> lament: maybe we could start with FP and then expand to more ambitious scenarios.
13:34:13 <SubStack> it doesn't need to be fast either
13:34:14 <lament> fair enough
13:34:15 <gwern> camio: I'm still amazed at the genius of Epaminondas in founding Messene and Megalopolis
13:34:23 <MissPiggy> SubStack to be honest I don't even know how to solve that
13:34:32 <gwern> to realize that founding a city was the most effective move in grand strategy against sparta!
13:34:43 <MissPiggy> SubStack although I would guess hitting it with a grobner basis would probably do something
13:34:51 <conal> for instance, (denotative) FP is good for precise reasoning and for reuse.
13:34:52 <MissPiggy> SubStack do you have an algorithm?
13:35:10 <SubStack> http://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html has some good examples of what I'm doing
13:36:34 <conal> i'm looking for something formal/mechanized that guides a programmer.  like how static typing guides us, and how proof might guide us, but goes beyond correct/incorrect.
13:36:45 <jmcarthur> a style guide?
13:36:54 <SubStack> it'd be pretty nifty to just throw the equation of a torus of a hyperbolic at some function and have that function solve the equation for a ray
13:37:03 <MissPiggy> conal that's a pretty wild idea I hope it happens!
13:37:10 <jmcarthur> but for something beyond syntax i assume
13:37:19 <conal> jmcarthur: more alive/flexible than i think of a style guide.  more like the implicit motivations behind style guides.  and deeper.
13:37:22 <SubStack> s/of a hyper\S+/or a hyperbolic paraboloid/
13:37:56 <MissPiggy> SubStack it seems do-able (maybe) but very hard
13:38:02 <jmcarthur> conal: something along the lines of "every concept in the program maps to a mathematical object"?
13:38:43 <MissPiggy> category theory ?
13:38:52 <conal> jmcarthur: more like motivation for using such principles.
13:38:58 <jmcarthur> aha
13:39:38 <conal> when concepts map to math values, we get some benefits.  formalize those benefits & measure them.
13:40:05 <c_wraith> holy crap, base changed quite a lot in 6.12.  Where is the explanation?
13:40:11 <jmcarthur> i see
13:40:17 <damd> is cabal-install included in haskell platform?  if not, why not?
13:40:27 <conal> i've been thinking about this idea on & off for many years now.  give people some valuable guidance w/o impeding their creativity.
13:41:21 <conal> and see whether things like pure, typed FP come out as emergent behavior.
13:41:28 <conal> or indeed, what comes out.
13:42:09 <jmcarthur> conal: so you are really looking for more of a manifesto of sorts
13:42:26 <jmcarthur> question mark*
13:42:58 <conal> jmcarthur: eep. as in opinion & dogma?
13:43:05 <jmcarthur> eh, no
13:43:22 <jmcarthur> "A manifesto is a public declaration of principles and intentions"
13:43:26 <aavogt> is there some way to choose between LANGUAGE pragmas based on ghc version?
13:43:38 <monochrom> cabal-install is included in haskell-platform. if you use it, do not use a newer version of cabal-install, or at least so I recommend.
13:44:01 <aavogt> when I try     #if __GLASGOW_HASKELL_ < 610\n {-# LANGUAGE ... #-}
13:44:37 <c_wraith> I mean...  "import Prelude hiding ( stuff )" is giving me warnings now.  What's the right way to do that?
13:44:46 * monochrom secretly links up opinion-intention, dogma-principle :)
13:44:47 <jmcarthur> it does seem that the word "manifesto" is more loaded than i intended
13:44:48 <conal> jmcarthur: offhand, doesn't sound like what i'm after.  more like getting clearer about & expressing more clearly what motivates me to program in the way i do.
13:44:59 <aavogt> that additional language pragma isn't seen by ghc-6.8.3
13:45:25 <aavogt> the cpp symbol is actually __GLASGOW_HASKELL__
13:46:29 <conal> jmcarthur: and then communally exploring what programming principles & techniques support those motivations well.
13:46:57 <jmcarthur> conal: okay i think i'm getting it now
13:47:21 <conal> jmcarthur: then broaden the inquiry by tweaking the motivations & weightings (evolutionary environments)
13:47:32 * MissPiggy thows a couple of coins: computational pragmatics
13:48:45 <MissPiggy> soomethings wrong here: http://hackage.haskell.org/package/haskeline-0.6.2.2
13:48:51 <MissPiggy> in the Dependencies
13:50:03 <jmcarthur> conal: if i was to make a hasty answer to your proposed question, i'd say what i'm looking for in all this is mere abstraction
13:50:29 <jmcarthur> and some approaches lend themselves to abstraction more easily than others
13:50:47 <jmcarthur> but by "abstraction" i also mean vague concepts like "generality"
13:51:52 <MissPiggy> :t outputStrLn
13:51:53 <lambdabot> Not in scope: `outputStrLn'
13:52:05 <aavogt> :t putStrLn
13:52:07 <lambdabot> String -> IO ()
13:52:24 <MissPiggy> why does haskeline have its own output
13:52:28 <conal> jmcarthur: great.  and then next, we could work on making "abstraction" (a) precise/formal and (b) clearly motivated.  In the process we might find something more essential, and abstraction could become a consequence rather than a goal.
13:53:29 <jmcarthur> conal: formal in what theory? or perhaps you don't have an answer for that question yet?
13:54:20 <opqdonut> we need "the functional manifesto"
13:54:24 <conal> jmcarthur: i mean precise enough to automate.
13:54:31 <lament> "OOP programmers suck!"
13:54:50 <jmcarthur> conal: actually, now i figure that the theory in which we can describe abstraction so formally is probably what we are after itself
13:54:59 <conal> jmcarthur: unambiguously measurable.
13:55:07 <MissPiggy> computable??
13:55:19 <kniu> so I wrote an IRC bot, and left it running for a few days.
13:55:29 <kniu> My computer slowed to a crawl because it used up all the memory.
13:55:38 <MissPiggy> use foldl'!
13:55:42 <mauke> heh
13:55:47 <conal> MissPiggy: yes.  computable and with a means of computing.
13:55:51 <Zao> Much like a dog, you need to be strict at times.
13:55:53 <kniu> There are memory leaks in Haskell?
13:56:02 <Zao> kniu: "space leaks"
13:56:03 <mauke> kniu: no, in your code
13:56:20 <MissPiggy> conal I am learning category theory for computing science and it seems a little bit like what you are alluding to
13:56:23 <conal> my hunch is that abstraction will turn out to be a means, rather than an end.
13:56:33 <MissPiggy> conal, and what about mathematically structured programming ?
13:56:47 <kniu> Is there a valgrind equivalent to let me see where exactly all the memory is being spent?
13:56:58 <kniu> Or a profiler?
13:57:01 <conal> MissPiggy: probably the *motivations* behind CT are (part of) what i'm looking for.
13:57:04 <aavogt> ghc has a profiler
13:57:09 <opqdonut> kniu: ghc has a very nice profiler
13:57:23 <MissPiggy> well I'm just reading it because the people here suggested it
13:57:31 <opqdonut> see e.g. http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
13:57:33 <conal> in other words, i'm looking for the question, rather than the answer.
13:57:38 <aavogt> so we have a means-ends inversion with respect to math?
13:57:50 <conal> answers will then arise as emergent behavior.
13:57:55 <jmcarthur> conal: yeah, we already know the answer is 42
13:57:58 <Alpounet> kniu, see hp2any
13:58:00 <Alpounet> @where hp2any
13:58:01 <lambdabot> I know nothing about hp2any.
13:58:01 <conal> :)
13:58:03 <Alpounet> hmm
13:58:03 <merijn> aavogt: Definitely, but that's not necessarily a bad thing
13:58:06 <Alpounet> @google hp2any
13:58:07 <lambdabot> http://code.google.com/p/hp2any/
13:58:07 <lambdabot> Title: hp2any - Project Hosting on Google Code
13:58:14 <opqdonut> kniu: but profiling can be tricky, especially interpreting all those different heap profiles
13:58:21 <opqdonut> kniu: asking here helps usually :)
13:58:27 <kniu> ok.
13:58:36 <ziman> you might want to see the respective RWH chapter, too.
13:59:20 <ziman> @where rwh
13:59:20 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:00:18 <Alpounet> @where+ hp2any http://www.haskell.org/haskellwiki/Hp2any
14:00:19 <lambdabot> Nice!
14:00:51 <MissPiggy> I am thinking you could write e.g.
14:01:04 <MissPiggy> polynomial ((x + y)^6)
14:01:18 <MissPiggy> to normalize that term as a polynomial
14:01:18 <conal> i got started in this thought experiment a few years ago when reading the book "Emergence: The Connected Lives of Ants, Brains, Cities, and Software " by Steven Johnson.  i was impressed with the creative power of large populations, when guided by clear objectives.
14:01:44 <MissPiggy> not sure......
14:01:51 <Alpounet> that's a *very* interesting topic, conal
14:01:59 <Zao> Oh dear. gsize on this value is 9'247'244
14:02:07 <Zao> Time to bring out the big shears.
14:02:09 <conal> i was & am also impressed & disturbed by the enormous gap between emergence and my own approach to software construction.
14:02:14 <conal> Alpounet: :)
14:02:15 <MissPiggy> conal did you see that bit on massively collaborative mathematics?
14:02:24 <conal> MissPiggy: no.  what bit?
14:02:40 <jmcarthur> MissPiggy: is this the constructive proof web site thing?
14:02:43 <Alpounet> MissPiggy, the "Tao" approach ?
14:02:43 <MissPiggy> http://gowers.wordpress.com/2009/01/27/is-massively-collaborative-mathematics-possible/
14:02:48 <MissPiggy> Alpounet yes
14:02:57 <Alpounet> heh
14:03:05 <MissPiggy> short answer to "Is massively collaborative mathematics possible?" seems to be Yes!
14:03:12 <conal> ML/LCF was another inspiring example for me.  and then LF.
14:03:21 <conal> MissPiggy: thx for the pointer.
14:03:40 <lament> #math is a great example
14:03:55 <MissPiggy> of what??
14:04:04 <lament> massively collaborative mathematics, of course
14:04:39 <conal> ML/LCF was a brilliant invention (by Robin Milner) for allowing unbridled creativity into theorem proving without compromising soundness.
14:05:08 <conal> that invention made a huge impression on me in grad school.  i still think about it with admiration.
14:05:20 <jmcarthur> MissPiggy: i wish this was here already. http://www.vdash.org/
14:05:46 <MissPiggy> jmcarthur yeah that's a great idea too I am excited about that
14:06:01 <MissPiggy> jmcarthur already there is some stuff like CoRN though
14:06:03 <pao> hi all! is there any syntactic sugar for \x -> (,) 1 x ?
14:06:03 <conal> and then LF (using dependent types) was another important step.
14:06:14 <damd> @pl \x -> (,) 1 x
14:06:15 <lambdabot> (,) 1
14:06:17 <MissPiggy> pao, you can just eta-reduce to  (,) 1
14:06:18 <Alpounet> pao, (,) 1 ?
14:06:32 <damd> > (,1) 2 -- hmm...
14:06:33 <lambdabot>   <no location info>: parse error on input `1'
14:06:34 <pao> I was hoping for something like (1, )
14:06:44 <conal> pao: there is.  it's very new.
14:06:54 <MissPiggy> use \x -> (1,x)
14:06:56 <conal> something i've waited for a long time.
14:06:57 <pao> conal: 6.12?
14:07:03 <conal> pao: i think so.
14:07:19 <Zao> TupleSections?
14:07:19 * Alpounet fires ghci up
14:07:27 <MissPiggy> (const 1 & id)
14:07:35 <MissPiggy> where (f & g) x = (f x, g x)
14:07:38 <conal> Zao: thx.  i'd forgotten the name.
14:07:40 <Alpounet> indeed.
14:07:44 <pao> conal: thanks, I'll try that out as soon as I'll upgrade to 6.12...
14:07:58 <conal> pao: me too.  thx for the reminder!
14:08:07 <Alpounet> MissPiggy, you meant &&& ? :)
14:08:10 <MissPiggy> no
14:08:11 <conal> i guess there's still no Haskell Platform for 6.12?
14:08:21 <MissPiggy> I just don't use arrows because I have no idea what they are
14:08:29 <Alpounet> > (+1) &&& (*2) $ 4
14:08:30 <lambdabot>   (5,8)
14:08:31 <pao> conal: lack of HP, that's what is stopping me as well :-)
14:08:36 <sinelaw> yeah
14:08:37 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#tuple-sections
14:08:38 <sinelaw> no HP yet
14:08:47 <Heffalump> isn't it due around now?
14:08:50 <conal> MissPiggy: arrows aren't anything in particular.  just like monads aren't.
14:09:09 <conal> MissPiggy: other than a signature pattern and set of laws.
14:09:56 <conal> MissPiggy: if you use these patterns wherever possible, you'll start discovering that some of your ideas/programs are more general than you'd noticed before.
14:10:21 <conal> MissPiggy: this transition to the simple/general is mainly why i like type classes.
14:10:21 <MissPiggy> but why would you use arrow pattern rather than other pattern ?
14:10:21 <pao> MissPiggy: in fact I would say they are "easier" that monads... don't be scared... (bar that every concept can be explored to very complex levels :-) )
14:11:01 <conal> MissPiggy: for example, you just used an arrow pattern.
14:11:19 <MissPiggy> no I didn't :[
14:11:24 <conal> MissPiggy: by writing it as such, you'll have something that applies to other arrows.
14:11:35 <MissPiggy> I know (&&&) = (&) when restricted to the same type
14:11:38 <conal> MissPiggy: you just didn't realize you were doing so.
14:11:50 <MissPiggy> but I don't know why I should rather write &&& than & just because it's a typeclass
14:11:55 <IceDane> What exactly does it mean when a monad returns () ? Why do I have to do: "guard (1 == 2) :: Maybe ()" instead of just " :: Maybe" ?
14:12:02 <conal> MissPiggy: cool.  then someone says "use &&& instead of &".  do it.
14:12:08 <MissPiggy> it doesn't apply to other arrows though because const and id are functions
14:12:22 <merijn> Speaking of arrows, in how far do i need to grok monads before reading up on arrows?
14:12:24 <damd> IceDane: data Maybe a = Just a | Nothing -- you need that 'a'
14:12:32 <conal> MissPiggy: and you'll be progressing from concrete to abstract.  concrete is a great place to start, but not to end.
14:12:36 <MissPiggy> conal well I would do it because that's kind of intimidating but I don't really see the point
14:13:07 <conal> MissPiggy: have you yet seen the point of Functor, Monad, Num, Monoid, ... ?
14:13:28 <MissPiggy> well yes for functor and monad, but I do not really like or use num
14:13:37 <kuribas> IceDane: If a monad doesn't return a useable value, it usually returns ()
14:13:40 <conal> MissPiggy: good.  then have some faith and curiosity about Arrow and the rest.
14:14:12 <jmcarthur> it is true that Arrow, as it exists in Control.Arrow, is not really as general as it could be
14:14:14 <conal> MissPiggy: that way you'll find the answer.
14:14:21 <jmcarthur> pulling out Control.Category helped a bit
14:14:23 <IceDane> kuribas: Ah, I see. So it's just exactly what I thought it was. I just assumed there was some more magic to it
14:14:26 <IceDane> thanks =)
14:14:54 <gwern> lovely. the haskell platform is broken
14:15:00 <sinelaw> maybe there should be an "encyclopedia" of typeclasses, something like the typeclassopedia but much more concise and short
14:15:08 * gwern is sorely repenting of upgrading ubuntu & ghc
14:15:18 <conal> gwern: urg :(
14:15:21 <MissPiggy> conal can't you just tell me the answer? :P
14:15:30 <sinelaw> even better, the compiler should automatically suggest existing typeclasses
14:15:49 <Nereid_> IceDane: () is like a void return type in C, say
14:15:53 <conal> MissPiggy: "the tao that can be spoken is not the true tao."
14:15:59 <MissPiggy> ok
14:16:04 <sinelaw> heh
14:16:09 <conal> MissPiggy: really.  i think you'll only get it if you discover it yourself.
14:16:26 <IceDane> Nereid_: Ah, that puts it into perspective. Thanks.
14:16:40 <kuribas> Except that void isn't really a value.
14:17:35 <kuribas> If you do a = void_fun(), a will be undefined (or a compiler error, I don't remember).
14:17:52 <kuribas> a = () is perfectly possible in haskell, though useless.
14:17:58 <Nereid_> useless, precisely
14:18:29 <conal> MissPiggy: and you might not discover that Arrow is awesome so much as that it's *nearly* awesome.
14:18:31 <Nereid_> anyway, gtk2hs seems to be failing to build for some strange reason: http://paste.pocoo.org/show/178500/
14:18:44 <Nereid_> not sure what's going on. :/
14:19:20 <jmcarthur> :( Arrow has so much potential...
14:19:54 <MissPiggy> can you implement a graph rewrite system using arrows
14:20:02 <sinelaw> i wonder how the compiler (or other tool) could find out if a typeclass fits your code
14:20:23 <jmcarthur> MissPiggy: that's like asking if you can do it using monads. the answer is almost always going to be yes
14:20:44 <MissPiggy> sinelaw well it could search and replace ++ with `mplus` and so on (for every function) -- which is sort of what conal is saying I shoudl do for (&)
14:20:48 <Nereid_> any ideas? :(
14:20:50 <SubStack> hmmm if only there were an easy way to compute eigenvalues in glsl
14:20:51 <blackh> Nereid_: You could disable gtkglext if you are not using it (or install the package)
14:21:00 <MissPiggy> sinelwa it's not completely obvious to me what would the point be though
14:21:10 <sinelaw> MissPiggy, i mean more intelligent typeclassing
14:21:36 <MissPiggy> you mean like makign new typeclasses from looking at your code?
14:21:36 <conal> MissPiggy: often that replacement will not result in a real generalization.  sometimes it will.
14:21:43 <sinelaw> like finding that the way you handle some data type, the functions you use to handle it fit some typeclass definition
14:21:47 <jmcarthur> sinelaw: you mean something like a type and a bunch of functions and determining whether some of those functions can instantiate a type class instance?
14:21:48 <Nereid_> blackh: but it built fine before I upgraded to 6.12.1
14:21:50 <Nereid_> gh
14:21:51 <Nereid_> c
14:21:55 <jmcarthur> bah you just said it!
14:21:58 <MissPiggy> conal yeah, it doesn't generalize in the case (const 1 &&& id)
14:21:58 <conal> MissPiggy: ie a generalization of the type/applicability of your def.
14:21:58 <sinelaw> the functions types fit a typeclass definition's function types
14:22:07 <MissPiggy> unless 1 is something bizarre
14:22:09 <Nereid_> and it doesn't look like it's just a gtkglext thin
14:22:10 <blackh> Nereid_: Are you using the ghc 6.12.1 patch for gtk2hs?
14:22:11 <sinelaw> jmcarthur, something like that, i'm just inventing
14:22:12 <Nereid_> g
14:22:15 <conal> MissPiggy: right.
14:22:27 <Nereid_> no idea, I'm just using the ebuild from the haskell overlay.
14:22:46 <MissPiggy> sort of vaugely related,
14:22:56 <jmcarthur> MissPiggy: it's the same as earlier when i said mzero = never and mplus = amb. that gave me some other things for free, like msum = ambs
14:23:00 <conal> MissPiggy: so in that case, all you've gained is using a common name instead of inventing one.
14:23:01 <blackh> Nereid_: The gtk2hs chaps have published a patch for building on ghc 6.12.1
14:23:06 <MissPiggy> if you have a haskell program and you delete all the  data ... = ...'s   there's a tool that tries to infer them
14:23:24 <shapr> What's that tool?
14:24:01 <conal> shapr: yo!  how's hacks?
14:24:36 <shapr> conal: Writing LaTeX for my infosec class mostly, what about you?
14:24:50 <conal> shapr: infosec??
14:25:14 <shapr> Information Security, I'm taking CS 335 at una.edu. It's my first CS class ever!
14:25:47 <shapr> Well, unless you count cs 101 in 1992, where we used 5.25" floppies to save GWBASIC ROM programs from true blue PC XTs.
14:25:49 <MissPiggy> shapr, http://lambda-the-ultimate.org/node/2981
14:25:53 <MissPiggy> Polymorphic Algebraic Data Type Reconstruction
14:25:55 <conal> shapr: i'm hacking on functional gpu programming, including for iphone.  and still background-puzzling over business/sustenance models.
14:26:17 <sinelaw> conal, btw, i'm starting part-time job this week
14:26:27 <jmcarthur> conal: yeah i don't know if you knew but shapr now lives within like 1 or 1.5 hours of me
14:26:30 <conal> sinelaw: oh!  congrats.
14:26:44 <shapr> Yes! I met jmcarthur recently! It was great to hang out with him and his peeps.
14:26:44 <Philippa> jmcarthur: I think Applicative has kinda sealed Arrow's fate in a lot of ways. OTOH, the loss may not be all that great
14:26:45 <conal> jmcarthur: ah, i hadn't put it together.
14:27:19 <sinelaw> conal, thanks, I hope this will eventually allow me to do other stuff in my free time. for now I still have univ. duties
14:27:44 <sinelaw> the quasi-dream, to be able to do whatever i want at least 40% of my time
14:27:52 <sinelaw> (hopefully something productive)
14:28:08 <conal> i'm also thinking about possible gainful short-term employment. for variety, income, and collaboration.  so if anyone knows of something that'd fit me, please let me know.
14:28:09 <shapr> conal: Have you considered talking to Chris Anand about the CoCoNut compiler for the Cell BE? I suspect much of his work is directly applicable (hah) to GPU scheduling.
14:28:10 * benmachine pokes lambdabot 
14:28:10 <lambdabot> benmachine: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:28:45 <shapr> Arrows are neat, but they're too much trouble.
14:29:07 <conal> sinelaw: i like that dream.  go for it.  btw, have you read "in praise of idleness" by bertrand russell.  great read.
14:29:09 <lament> arrows are neat, but they need a GUI designer
14:29:12 * hackagebot upload: uvector 0.1.1.1 - Fast unboxed arrays with a flexible interface (DonaldStewart)
14:29:19 <conal> http://www.zpub.com/notes/idle.html
14:29:53 <shapr> If you use Arrows with normal everyday functions that are not based on Arrows, you lose the advantages of Arrows.
14:29:54 <conal> shapr: i haven't heard of Chris & CoCoNut.  thx for the pointer.
14:30:10 <shapr> conal: I suspect Chak should be talking to Anand as well.
14:30:17 <conal> cool
14:30:22 <sinelaw> conal, added to list.
14:30:27 <sizur> hi guys.  may i ask what are (^>>) and (>>^) used for?
14:30:29 <sinelaw> conal, did you get your Polya books yet?
14:30:39 * sshc pokes lambdabot 
14:30:45 <shapr> conal: What sort of GPU stuff? OpenCL, Nvidia Tesla, or what?
14:30:45 <conal> sinelaw: i got the first one, thx.  right next to me.
14:31:13 <conal> shapr: for now, GLSL.  runs on iphone 3GS.  and i think on nexus one.
14:31:14 <Nereid_> sizur: arrows
14:31:16 <Nereid_> @hoogle ^>>
14:31:17 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
14:31:25 <conal> shapr: in opengl es 2.0
14:31:43 <|Jedai|> sizur: its first and second but in operator form
14:31:45 <BONUS> ^>> is like argument
14:31:48 <sinelaw> conal, i have only volume I, but still haven't read it. another one on the list :(
14:31:51 <conal> shapr: in some ways, glsl is nice & simple.  and in some ways crippling.
14:32:13 <shapr> I'm desperately hoping that ARM and OpenGL ES will become the 'standard' is the same way that big iron got eaten by PCs, volume and userbase.
14:32:15 <sinelaw> conal, do you know anything about OpenCL? I've heard about it but know very little
14:32:22 <conal> shapr: like i don't think it can quite do automatic tessellation on the gpu, which i want to do.
14:32:41 <conal> sinelaw: i'm in about the same place. it's where i want to go next.
14:32:52 <conal> sinelaw: sigfpe is playing with opencl via haskell.
14:32:54 <michaeldever> hey all, started doing a bit of haskell again and ive hit a wall already can anyone give me a bit of input on this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20867#a20867
14:33:24 <conal> sinelaw: my first exposure to cuda scared me off.  i think opencl is a variation.
14:33:39 <SubStack> michaeldever: your return types aren't the same
14:34:09 <MissPiggy> michaeldever: you can create a model of lambda calculus inside haskell and normalize = quote . eval, where eval :: Syntax -> Model and quote :: Model -> Syntax -- if you aren't dead set on your stacky approach
14:34:10 <conal> sinelaw: and yet the horrific complexity of things like opengl, cuda & opencl is all the more motivation to master them and rewrap with a much simpler interface/language.
14:34:21 <sinelaw> opencl is like a newer more standardized version from what i gather
14:34:26 <SubStack> conal: that's what I'm doing!
14:34:29 <sinelaw> yeah
14:34:41 <conal> SubStack: oh?? please tell me more.
14:34:49 <michaeldever> SubStack: they should be hmmm
14:34:51 <SubStack> http://github.com/substack/haskell-opengl-simulations/blob/master/examples/Sphere.hs
14:35:07 <michaeldever> MissPiggy: ah im just working off a paper at the moment, and will improve it as i go!
14:35:16 <doserj> michaeldever: how does the data type definition look like?
14:35:34 <shapr> conal: Are you already in contact with RyanT5000 and the ipwn studios team? I assume you're writing Haskell for the iPhone?
14:36:00 <conal> SubStack: thx.  i'm shooting for something functional/denotative.  like Pan, Vertigo & FieldTrip
14:36:21 <michaeldever> doserj: I added a revision with the data types there
14:36:29 <conal> SubStack: ie being rather than doing.
14:36:36 <kaneic> Anyone know of any texts of algorithms written in haskell?
14:36:38 <SubStack> that would be nice
14:37:02 <SubStack> I'm just trying to take the edge of the opengl bindings to make them a little less imperitive
14:37:04 <kaneic> or alternatively just some texts documenting various algorithms specifically huffman trees?
14:37:08 <conal> SubStack: also continuous time & space.
14:37:15 <SubStack> frp?
14:37:26 <MissPiggy> kaneic, it's in C but you can obvious use haskell instead:  The Data Compression Book
14:37:36 <MissPiggy> really really good book
14:37:45 <kaneic> MissPiggy: thank you!
14:37:49 <doserj> michaeldever: try sth like "data Expr = VarExpr ... | Cons ... | Lambda ...
14:37:58 <kuribas> There is "Purely Functional Data Structures" by chris okasaki, but the haskell is only in the appendix.
14:37:58 <conal> shapr: thx.  ryan & i spoke a while back.  they're using a tweaked ghc.  for now, i have a compiler written in haskell that generates glsl code.  so no haskell code running on the iphone.
14:38:07 <SubStack> :o
14:38:08 <shapr> Aw, too bad.
14:38:09 <doserj> michaeldever: so that the argument of normalize always has the same type
14:38:24 <shapr> On the other hand, you're using Haskell to generate it, so I'm in favor!
14:39:11 <conal> SubStack: in the spirit of frp: (a) precise & simple denotation and (b) continuous (resolution-independent)
14:39:32 <c_wraith> Man, quickcheck's shrinking is awesome when it's sane for your type
14:40:44 <SubStack> sounds excellent
14:40:46 <olsner> yeah, that's really cool, no more manual hunting for smaller testcases
14:40:48 <michaeldever> doserj: ok, now its teling me that its not in scope else where, i use those types in other type definitions
14:41:28 <conal> shapr: i'm waiting for the iphone-friendly ghc hacks to get folded into ghc.  and meanwhile i've learned a good deal of cocoa-touch programming.  and found that i like objective-c more than i expected.
14:42:16 <Twey> conal: Yeah, it's not so horrible.
14:42:30 <kuribas> michaeldever: It means it cannot find your definition.  Can you paste your code?
14:43:02 <sinelaw> better than C++ i'm guessing
14:43:18 <michaeldever> ok done, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20867#a20869
14:43:32 <michaeldever> im guessing im doing something silly worthy of a facepalm
14:45:32 <conal> SubStack: i encourage you to keep pushing your project in the denotative/functional direction.  my central technique for doing so is to keep asking myself: what is the "what" behind this "how" code?  for instance, your code renders something.  *what* does it render?  exploring & formalizing that "what" will lead to explicit data types that had been implicit.
14:45:58 <cebewee> michaeldever: VarExpr and Cons have different types
14:46:06 <mauke> parental advisory: explicit types
14:46:12 <conal> and what/be is generally more composable and reasoning-friendly than how/do.
14:46:25 <doserj> michaeldever: I guess you have to rethink your data-type definitions.
14:46:25 <MissPiggy> noo :(
14:46:25 <MissPiggy> HaskellForMaths-0.2.0 failed during the building phase. The exception was:
14:46:25 <MissPiggy> ExitFailure 1
14:47:21 <Nereid_> michaeldever: something looks wrong with your Redex definition
14:47:41 <Nereid_> you're using constructors (VarExpr, ...) instead of types
14:47:54 <SubStack> conal: a declarative approach would be quite good at describing volume geometries in shaders I expect
14:48:16 <conal> SubStack: yeah.
14:48:42 <MissPiggy> yikes I fix one error and get an even more scary one ld warning: atom sorting error for _HaskellForMathszm0zi2zi0_MathziAlgebraziCommutativeziMonomial_Grevlex_closure_tbl and _HaskellForMathszm0zi2zi0_MathziAlgebraziCommutativeziMonomial_Lex_closure_tbl in dist/build/Math/Algebra/Commutative/Monomial.o
14:48:47 <sinelaw> graphics as a whole has potential to being very declarative
14:48:52 <michaeldever> hmm ok
14:49:04 <SubStack> it would be especially nice if the entire scene could be described with equations and then rendered entirely on the gpu
14:49:06 <sinelaw> except there seem to be some parts that are inherently imperative or sequential, no?
14:49:13 <michaeldever> guess im going about it wrong, back to the drawing board :D
14:49:32 <conal> sinelaw: not that i know of.
14:49:32 <sinelaw> like loading stuff into the GPU
14:49:37 <sinelaw> textures
14:49:54 <sinelaw> no that's a bad example, that's just low-level implementation stuff
14:50:07 <conal> sinelaw: yeah.  that's more like implementation/rendering of graphics, rather than graphics itself.
14:50:09 <Philippa> conal: for what it's worth, I'm finding the technique isn't quite paying off with type inference for some reason. Though it makes providing type errors in the presence of a separate desugaring pass easier. Perhaps I'm just missing all the cute big exploits
14:50:48 <conal> Philippa: i have no idea what you're referring to.
14:51:02 <Philippa> going denotative
14:51:22 <erikc> conal: have you taken a look at directx11 for gpu tesselation?
14:51:24 <sinelaw> conal, what about setting/unsetting various render properties? such as turning antialiasing on and off
14:51:27 <conal> Philippa: ah.  do you blog?  may be an effective way to get some help.
14:52:12 <conal> erikc: i don't think so.  just opengl "geometry shaders".  which are fine but not yet implemented widely.  and not in opengl es 2
14:52:25 <conal> sinelaw: again.  part of the presentation, rather than the model.
14:52:35 <SubStack> sinelaw: that kind of switching isn't done much at runtime either
14:52:37 <Philippa> I don't much at the moment - I'm hugely out of practice at writing decent amounts at once. But it's been on my todo list for a while because the stuff I found with desugaring is fun and I got something that makes sense to me - just not quite a big enough improvement to write the big position paper and start selling other people on it
14:52:42 <erikc> conal: http://www.nvidia.com/content/nvision2008/tech_presentations/Game_Developer_Track/NVISION08-Direct3D_11_Overview.pdf
14:52:57 <erikc> first few slides show the single pass tesselation dx11 flow
14:53:11 <conal> erikc: thx.  sadly, windows-only.  i've stopped using windows.
14:53:22 <sinelaw> conal, part of the presentation that also needs to be controllable
14:53:28 <sinelaw> not an implementation detail
14:53:40 <erikc> right, it's safe to say that opengl will just be a different interface to the same functionality though
14:53:43 <Philippa> thinking about it, it'd be fun to play with my technique for error messages in the presence of sugaring and some of the techniques the Helium folks came up with for handling error messages - could be good for a language with macros
14:53:51 <erikc> whenever the opengl committee gets around to it
14:53:56 <Philippa> but yes, I should blog
14:54:08 <Philippa> (I have an unused one that's on Haskell Planet, if you read)
14:54:09 <conal> sinelaw: indeed.  which comes back to the question method i mentioned earlier.  look for the what/be behind the how/do.
14:54:42 <conal> sinelaw: graphics has such an odd heritage.  nice math theory and fortran-style programming.
14:55:06 <sinelaw> yeah. and opengl is a mix of functional operational stuff with imperative commands
14:55:20 <SubStack> opengl is amazingly imperitive
14:55:24 <SubStack> frustratingly so
14:55:49 <jmcarthur> it's funny because it's all executed on functional hardware
14:56:01 <sinelaw> yeah...
14:56:05 <SubStack> nowadays anyhow
14:56:13 <conal> and how.  so ironic.
14:56:22 <conal> simultaneously motivates and thwarts parallelism
14:56:32 <jmcarthur> SubStack: well, i'm gonna start following your projects on github. i am also interested in GPU DSLs
14:56:46 <zakwilson> I think this (oversimplified) code used to work, and now it doesn't seem to:
14:56:47 * SubStack has a lot of projects
14:56:48 <zakwilson>  parseTest (manyTill anyChar (try (string "\SI\n"))) "foo \n"
14:56:53 <jmcarthur> been mostly using GPipe lately, but it's still a bit low level
14:57:02 <erikc> the collada spec is a pretty decomposition of the 'what' targeted at gl2-level hardware, might be worth taking a look at that
14:57:02 <jmcarthur> less than GLSL though, at least
14:57:18 <michaeldever> ugh
14:57:24 <jmcarthur> i do really wish geometry shaders had kicked into full swing already though
14:57:43 <zakwilson> Note there's a non-printing character in that string there.
14:57:51 <SubStack> gpipe does look pretty swell
14:58:09 <jmcarthur> which reminds me i have a library i need to put up sometime
14:58:18 <jmcarthur> just some 3d transformation stuffs
14:58:39 <monochrom> > "\SI"
14:58:39 <jmcarthur> in particular, managing stacks of them as in OpenGL but more functionally
14:58:40 <lambdabot>   "\SI"
14:58:49 <monochrom> > ord '\SI'
14:58:50 <lambdabot>   15
14:58:53 <SubStack> jmcarthur: is it thread safe?
14:58:59 <jmcarthur> yes
14:59:09 <jmcarthur> it's not opengl transformations, it's pure haskell
14:59:10 <sinelaw> sometimes i just want to write cool apps, and can't wait for all the frameworks to be ready
14:59:11 <SubStack> oh nifty
14:59:15 <conal> jmcarthur: i want geometry shaders also, since my surfaces are all continuous.
14:59:32 <jmcarthur> SubStack: it's meant to work with something like GPipe that overloads a bunch of numeric operations and stuff for performance
14:59:44 <jmcarthur> conal: yeah that's why i want it too
14:59:52 <jmcarthur> in part, at least
14:59:57 <SubStack> I bolted on some 3d transforms onto hmatrix for my project
14:59:58 * michaeldever digs out RWH
15:00:04 <sinelaw> GPipe seemed very low level last time i looked at it. maybe i didn't get it
15:00:22 <conal> jmcarthur: i figure i'll combine derivatives and interval analysis for auto tessellation
15:00:23 <jmcarthur> sinelaw:  it is quite low level, but in a mathy sense more than in a hardware sense
15:00:55 <jmcarthur> sinelaw: it's up to you to define how a lot of things are rendered, and also things like transformation computations and such
15:01:04 <sinelaw> how can a graphics framework be both complete and easy to use for simple things?
15:01:25 <jmcarthur> sinelaw: i think GPipe is only partway there, for me
15:01:27 <SubStack> reasonable defaults
15:01:30 <monochrom> by being a union of a complete framework and an easy framework.
15:01:35 <MissPiggy> just make Graphics.Simple which does hello world in one line and shove everything else in Graphics.AllThatOtherStuff
15:01:40 <jmcarthur> sinelaw: what i want to do is build more abstractions on top of it
15:02:17 <c_wraith> woo.  all tests pass.  Test-driven development can be fun, when the tests are easy to write.
15:02:18 <SubStack> I want to do matrix maths in glsl
15:02:30 <ddarius> c_wraith: Now run hpc.
15:02:33 <SubStack> not just multiplication and addition
15:02:44 <jmcarthur> sinelaw: GPipe is quite nice though. you just have to work within its constraints (doing your vector math separate from your rasterization math, etc.)
15:03:45 <conal> jmcarthur: i haven't looked into GPipe.  does it generate glsl code or what?
15:03:55 <jmcarthur> conal: yeah, it does so at runtime
15:04:03 <c_wraith> ddarius: is that a coverage tool?
15:04:11 <ddarius> Yes.
15:04:13 <ddarius> @where hpc
15:04:13 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
15:04:20 <conal> jmcarthur: ah.  with some sort of deep dsel?
15:04:31 <mauke> import Dance.Dance.Revolution
15:04:33 <conal> jmcarthur: (like Pan)
15:04:58 <jmcarthur> conal: it's really more of a shallow DSL, if i'm not mixing up my types of DSLs
15:05:08 <jmcarthur> conal: oh, no, it's probably deep, you're right
15:05:16 <sinelaw> what makes a DSL deep or shallow?
15:05:47 <ddarius> sinelaw: Whether all it cares about is looks and money or not.
15:06:02 <sinelaw> heh
15:06:03 * MissPiggy wonders how to factorize guassian integers
15:06:03 <MissPiggy> ?
15:06:20 <sinelaw> what's a gaussian integer?
15:06:24 <sinelaw> i sound like Eliza
15:06:34 <sinelaw> i'll google it :)
15:06:36 <MissPiggy> x+iy : Z[sqrt(-1)]
15:06:43 <mauke> complex integer
15:07:08 <sinelaw> ah
15:07:08 <ddarius> :k Complex Integer
15:07:09 <lambdabot> *
15:07:13 <MissPiggy> > (1+i)^(1203793)-1
15:07:14 <lambdabot>   (1 + i) * (1 + i) * ((1 + i) * (1 + i)) * ((1 + i) * (1 + i) * ((1 + i) * (...
15:07:20 <conal> sinelaw: "deep" means having a syntax representation and then interpreting or compiling.  for instance, fran was shallow, and pan was deep.
15:07:24 <MissPiggy> largest known gauss prime
15:07:32 <jmcarthur> sinelaw: my understanding is that a deep embedding means it has an interpreter
15:07:37 <conal> @go "compiling embedded languages"
15:07:37 <lambdabot> Maybe you meant: google googleit do
15:07:44 <sinelaw> conal, and shallow?
15:07:53 <erikc> so does type-safe shader code mean i need to restart my program to change shader code? :P
15:08:06 <conal> @google "compiling embedded languages"
15:08:09 <jmcarthur> sinelaw: whereas a shallow embedding is a bunch of combinators
15:08:13 <lambdabot> http://eprints.kfupm.edu.sa/30924/1/30924.pdf
15:08:13 <lambdabot> Title: Compiling Embedded Languages
15:08:15 <sinelaw> ah
15:08:17 <sinelaw> ok
15:08:28 <conal> both are a bunch of combinators.
15:08:30 <sinelaw> another doc to my stack
15:08:33 <conal> hm.  how to define shallow?
15:08:46 <jmcarthur> conal: well, i mean in implementation
15:08:49 <conal> hm.  i wonder if that's the paper i meant.  looking ...
15:09:04 <conal> jmcarthur: deep is syntax combinators
15:09:41 <conal> sinelaw: another url: http://conal.net/papers/jfp-saig/ (probably same content)
15:10:02 <jmcarthur> conal: yeah...
15:10:04 <sinelaw> conal, yip just saw that
15:10:15 <ddarius> Whether the interpreter is fused or not.
15:10:33 <sinelaw> conal, and added it to my zotero (cool biblio or paper collecting plugin for firefox)
15:10:42 <jmcarthur> conal:  how about: a shallow embedding's run function merely unwraps the abstraction instead of interpreting it?
15:11:28 <sinelaw> my instinctive guess was that shallow means that the combinators fuse it into embedding (haskell) code that can run, and no interpreter is needed
15:11:35 <conal> jmcarthur: dunno.  gets fuzzy when algebraic data types are used to rep the values.
15:11:53 <conal> sinelaw: yeah.  that description is on the right track.
15:12:06 <conal> sinelaw: though even 'map' is an interpreter of sorts.
15:12:17 <sinelaw> right
15:12:43 <sinelaw> also, in that sense almost every haskell data type is a "shallow DSL"
15:13:03 <conal> sinelaw: yes!  shallow dsels are haskell libs.
15:13:29 <conal> sinelaw: landin's "the next 700 programming languages" is all about the idea of shallow dsels
15:13:45 <sinelaw> another one to my stack :)
15:13:51 <sinelaw> will it ever end? :)
15:13:52 <jmcarthur> conal: but are haskell libs necessarily shallow DSLs?
15:14:03 <jmcarthur> for example, our running example of GPipe?
15:14:24 <Philippa> I find the deep style is often more useful while I'm doing exploratory design, so long as I'm willing to do things like use monad transformers to help pipe things around
15:14:48 <medfly> preflex, seen cale
15:14:48 <preflex>  cale was last seen on #haskell 14 hours, 57 minutes and 48 seconds ago, saying: heh
15:14:49 <merijn> sinelaw: Probably not, I used to think I knew a lot and could program, then I started coming here and now the number of papers, books and articles seems to be exponentially increasing every week :p
15:15:03 <conal> jmcarthur: there's probably no clear line that gets crossed on the way from [] to GPipe.  a fuzzy transition
15:15:10 <sinelaw> merijn, that's a pretty good description of what's happening to me
15:15:17 <MissPiggy> that's too bad, I don't have very much to read
15:15:29 <sinelaw> i used to consider myself an "experienced programmer". then came haskell.
15:15:34 <Philippa> it's really quite easy to fuse the end result away if you want shallow afterwards
15:15:39 <jmcarthur> i think my favorite exposition of a shallow DSL so far is now Finally Tagless, Partially Evaluated
15:15:41 <ddarius> merijn: The number of papers is probably exponentially increasing.
15:15:43 <sinelaw> i was experienced, but my experience was in battling lame programming languages
15:16:10 <MissPiggy> > (2+:1)*(2:+(-1))
15:16:11 <lambdabot>   Not in scope: `+:'
15:16:14 <sinelaw> experience battling annoying problems does not amount to wisdom
15:16:15 <MissPiggy> > (2:+1)*(2:+(-1))
15:16:16 <lambdabot>   5.0 :+ 0.0
15:16:20 <MissPiggy> ^ 5 is not prime!
15:16:22 <conal> jmcarthur: how about this: Pan, Vertigo, GPipe, etc are deep graphics dsels and shallow syntax dsels.
15:16:58 <conal> jmcarthur: ie a deep dsel for domain X is a shallow dsel for domain "X language"
15:16:58 <merijn> sinelaw: I read an interesting article yesterday discussing the various programming paradigms and when and why each is useful
15:17:10 <sinelaw> link?
15:17:19 <conal> jmcarthur: or s/language/expression/
15:17:47 <merijn> sinelaw: Programming Paradigms for Dummies: http://lambda-the-ultimate.org/node/3465
15:18:09 <jmcarthur> conal: i think i'm going to stay undecided on this
15:18:13 <conal> :)
15:18:22 <jmcarthur> i think the distinction is losing importance to me
15:18:25 * hackagebot upload: lrucache 0.1 - a simple pure LRU cache (CarlHowells)
15:18:42 <MissPiggy> merijn yeah his book (CTM) is on the same level as AMOP in terms of mind blowing programming language theory
15:18:52 <c_wraith> woo.  my very first hackagebot announcement.
15:18:58 <sinelaw> congrads!
15:18:59 <merijn> MissPiggy: Don't know either of those :p
15:19:05 <MissPiggy> if you're into stuff other than just functional programming that is
15:19:12 <MissPiggy> not sure what the ratios are for that here
15:19:16 <SubStack> I should get a hackage account
15:19:16 <conal> dropping the precision, i'd say that shallow dsels are easier to implement, while deep dsels can execute without the host language's run-time system.  for instance running on a GPU.
15:19:18 <sinelaw> merijn, thanks
15:19:31 <Philippa> anyone who's sufficiently into FP will find themselves encoding multiple paradigms from CTM anyway
15:20:12 <merijn> MissPiggy: My current (book) stack is "Introduction to Algorithms" by Cormen et al., "Types and Programming Languages", the dragon book and TAoCP
15:20:19 <jmcarthur> conal: the distinction is further lost when you follow a type class approach as in Finally Tagless, because you can then have a shallow back end or a deep back end
15:20:26 <jmcarthur> with the exact same interface
15:20:37 <conal> i was disappointed with Peter van Roy's classification of frp as a paradigm separate from fp and the suggestion that it's nondeterminstic.
15:20:50 <Philippa> I occasionally get a bit narked with people insisting that's the one true use of 'paradigm' because it inhibits discussion about good metaparadigms (and IMO pure FP is a very good choice of metaparadigm)
15:20:53 <MissPiggy> merijn my book is in the mail :P (+ something about abstract nonsense for wizards)
15:21:07 <conal> jmcarthur: ah yeah.  nice.  i think erik meijer's thesis had this trick also.
15:21:16 <merijn> I'm also thinking of adding SICP to that stack. TAoCP's math intimidates me
15:21:36 <Philippa> conal: insisting it's nondeterministic, I'm with you. But I understand calling it a separate paradigm
15:21:58 <jmcarthur> paradigms are dumb
15:21:59 <Philippa> (consider a first-order FPL with FRP constructs...)
15:22:04 <ment> merijn: hehe word of advice - if you're not a math major or you don't plan to spend with that book a lot of time, throw it out
15:23:02 <merijn> ment: I do plan to spend a lot of time, but I postponed spending the time until after I'm done with Introduction to Algorithms which seems to provide an easier leg up to the grown up stuff :p
15:23:05 <Philippa> conal: I forget whether he separates out FRP per se, or has something that's strongly FRPish but which he gets a different way in Oz, though?
15:23:10 <conal> in coming up with frp, it was very important to me that it fit into denotative/functional programming languages, rather than be another language.  later we came to call that style "dsel".
15:23:51 <Alpounet> c_wraith, congrats
15:23:56 <sinelaw> if only the definitions were clearer
15:24:00 <Philippa> yeah. PVR's of the view that that's still another language though, just as you feel that it's not really functional programming if I use a monad to give me another paradigm
15:24:03 <conal> Philippa: from what i read on wikipedia, he thinks/thought of frp in terms of a particular implementation/operational model.
15:24:15 <sinelaw> a lot of the language classification stuff feels fuzzy
15:24:22 <Philippa> I wouldn't trust wikipedia not to add some subtle-but-important noise on that front
15:24:24 <michaeldever> :r
15:24:32 <MissPiggy> jmcarthur, paradigms are dumb?
15:24:48 <sinelaw> classifications should be precise
15:24:50 <jmcarthur> MissPiggy: they are. what purpose does black and white thinking serve?
15:25:19 <MissPiggy> it's kind of like writing stuff down (making it explicit) so you can think clearer and understand more completely
15:25:31 <merijn> FRP suffers from the same problem Python's Twisted framework did when I first started looking at it. It seems interesting enough, but I can't figure out what the hell it is >.>
15:25:41 <conal> jmcarthur: as in classifications/categories/ontologies.
15:25:49 <jmcarthur> conal: exactly
15:25:52 <sinelaw> it's a little suprising that before i went to univ. i was intimidated by quanitifcation or ultra-precise definitions, and now it's the opposite - i feel i don't *understand* unless things are put in precise terms
15:25:58 <Philippa> jmcarthur: PVR's paradigms feel like discrete entities rather than different shades of grey to me
15:26:26 <MissPiggy> remember the whole point of Oz is to unify them all in one language
15:26:30 <jmcarthur> it doesn't help me understand it any better, and it doesn't help me find it in a library unless i've already been taught beforehand that X is in the Y category
15:26:33 <conal> sinelaw: your standard of understanding shifted.
15:26:45 <sinelaw> MissPiggy, reverse tower of babylon?
15:26:55 * MissPiggy does not understand things which are in precise terms...
15:26:56 <merijn> jmcarthur: It does help create a framework of where things are in relation to eachother
15:27:12 <sinelaw> conal, and with that my self confidence sank a little :(
15:27:20 <merijn> jmcarthur: I found the paper rather interesting
15:27:26 <MissPiggy> although I still haven't quite ironed out the kinks in 'understand' vs 'do'
15:27:30 <merijn> sinelaw: Naah, I used to think like that
15:27:40 <merijn> sinelaw: Then I realised: No one has a clue what they're doing :)
15:27:59 <Philippa> jmcarthur: I'm going to ask the obvious question here - have you read CTM? Because honestly? For me it /did/ help understanding in a variety of subtle ways (including making me somewhat more confident that I've been attacking certain problems the right way)
15:28:00 <sinelaw> merijn, heh maybe
15:28:04 <jmcarthur> merijn: yeah, but they usually relate to each other in an unspecified way... but now it sounds like you are speaking of a specific ontology?
15:28:12 <sinelaw> my "mission" is to put things precisely, if only so that I may understand them
15:28:20 <jmcarthur> merijn: or... what paper are you referring to?
15:28:23 <sinelaw> unfortunately i lack so much basic facts
15:28:29 <sinelaw> *many
15:28:31 <conal> sinelaw: http://en.wikipedia.org/wiki/DunningKruger_effect
15:28:48 <merijn> jmcarthur: Programming Paradigms for Dummies, was linked on lambda the ultimate earlier this week
15:29:02 <jmcarthur> sinelaw: stop looking for facts then. stick with mutable assumptions :)
15:29:08 <sinelaw> conal, that pretty much summarizes most of humanity's problems
15:29:21 <medfly> conal, ahahaha. sounds like a programming related thing
15:29:25 <MissPiggy> nice to have a name for it
15:29:33 <conal> medfly: very much so!
15:29:42 <sinelaw> it also summarizes the internet
15:29:55 <merijn> sinelaw: Education is not to increase the things in the "stuff you know" category (that happens as an accidental by product). Education is to put more stuff from the "you don't know you don't know" into the "you know you don't know" category
15:29:57 <conal> explains why knowledge and confidence are often inversely correlated
15:30:09 <sinelaw> medfly, it also summarizes how people behave where we live :)
15:30:17 <medfly> conal, sometimes I kind of assume people who think they suck horribly are doing relatively okay
15:30:27 <merijn> sinelaw: The problem is, the more educated you get the more you doubt yourself because you start realizing how little you actually know :)
15:30:33 <medfly> conal, yeah, same thought there
15:30:35 <sinelaw> merijn, yeah
15:30:57 <medfly> merijn, make you less narrow minded? :)
15:31:28 <conal> more of the darwin quote: "Ignorance more frequently begets confidence than does knowledge: it is those who know little, and not those who know much, who so positively assert that this or that problem will never be solved by science."
15:31:54 <merijn> Now that I realize everyone else is faking it and making it up as they go along was a good way for me to start doing things I used to think were to hard for me.
15:32:37 <sinelaw> merijn, i don't know if everybody is faking it
15:32:56 <sinelaw> people who make humble statements about the truth aren't faking it
15:33:10 <Philippa> aren't /necessarily/ faking it
15:33:26 <Philippa> some people are rather devious :-)
15:33:27 <jmcarthur> sinelaw: anybody speak about The Truth is probably faking it
15:33:30 <conal> Sean Leather shared this post: http://sethholloway.com/blog/2010/02/12/is-the-dunning-kruger-effect-an-explanation-for-why-the-ignorant-are-blissful/
15:33:32 <jmcarthur> *speaking
15:34:27 <conal> i've come to dislike most uses of "the".
15:34:52 <MissPiggy> conal  sometimes 'a' is scary though "does he mean there might be multiple??"
15:35:02 <sinelaw> jmcarthur, so you are faking it? you just made a claim
15:35:10 <conal> MissPiggy: and there might be!
15:35:15 <jmcarthur> sinelaw: irony
15:35:17 <conal> MissPiggy: good, honest fear
15:35:25 <merijn> On an entirely different point, since I refuse to accept there's no pretty way of doing this: I basically want to take a  function with type "a -> a -> a" (for an arbitrary, but static and know at compile time number of a's) and combine it with a function returning a's to shove a's into the function until I get the final value back.
15:35:34 <conal> MissPiggy: i prefer to dishonest security
15:36:42 <ment> hmm is Control.Monad.Cont part of the base ghc installation?
15:37:02 <jmcarthur> ment: if you don't have it already, it's in the mtl package
15:39:02 <MissPiggy> monochrom -- this is good http://www.vex.net/~trebla/numbertheory/gaussian.html but what's the algorithm to do it? :)
15:39:12 <ment> jmcarthur: thanks.
15:41:48 <monochrom> I am thrilled you found my page. But the page does not intend to factor things. It intends to justify the quadchotomy: zero, units, primes, composites.
15:42:23 <monochrom> More precisely, it intends to justify units.
15:43:40 <monochrom> I suppose next month you will find my - proof tutorial.
15:46:16 <applicative> merijn: I think you're not being quite clear enough
15:48:08 <applicative> merijn: or not enough for me to follow, anyway, are  you anticipating that values given by f:: a->a->a->a will be arguments of f
15:48:28 <roconnor> @kind Mu
15:48:29 <lambdabot> (* -> *) -> *
15:48:32 <roconnor> @src Mu
15:48:32 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
15:49:29 <MissPiggy> http://mathforum.org/pcmi/hstp/resources/gaussian/final_factoring_integers_gaussian.pdf
15:49:38 <MissPiggy> that's nice lots of pictures
15:50:17 <roconnor> I think merijn whats to do merijn g f = either g (merijn g) (out f)
15:50:30 <merijn> applicative: Ok, concrete context of what I'm trying to do. I'm trying to write a replacement for the currently used evolutionary programming framework. Each generation new individuals are generated from N different individuals. So basically I want the framework to be provided a function to retrieve individuals and use that to call the users function generating a new individual. However until the user defines said function I have no way of
15:50:30 <merijn> knowing how many individuals I should hand the function.
15:50:30 <roconnor> @type \g f -> either g (merijn g) (out f)
15:50:31 <lambdabot> Not in scope: `merijn'
15:50:49 <roconnor> @type fix (\merijn g f -> either g (merijn g) (out f))
15:50:50 <lambdabot> forall a c. (a -> c) -> Mu (Either a) -> c
15:51:39 <merijn> roconnor: Lemme check how that works.
15:52:01 <roconnor> hmm, not quite right
15:52:24 <roconnor> @type fix (\merijn g f -> either g ((merijn g) . g) (out f))
15:52:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = Mu (Either a)
15:52:26 <lambdabot>       Expected type: Either a a
15:52:26 <lambdabot>       Inferred type: Either a (Mu (Either a))
15:52:44 <applicative> the user's function corresponds with an evolutionary strategy or something
15:53:07 <merijn> applicative: In this case a mutation/crossover strategy, but yeah. Something like that.
15:53:38 <applicative> But different individuals will be following different functions so to speak, so there'll be f competing with g ?
15:53:54 <applicative> the f-followers competing with the g-followers
15:55:03 <gwern> och! it's so nice to be back on 6.10. everything just compiles and works again
15:55:18 <gwern> no endless nigglign compile errors or conflicting deps or all the shite I was shoveling earlier
15:55:21 <merijn> applicative: Individuals don't specifically do anything. Individuals encode a candidate solution to a problem. New individuals (i.e. solutions), are created by recombining/modifying existing solutions. Usually by for example crossover mixing >=2 existing individuals together.
15:55:53 <applicative> I see, I had a more primitive picture, like axelrod or something
15:55:57 * gwern feels content. hope the upgrade to ubuntu lynx fixes my usb issue, then I'll inch a little closer to feeling happy
15:56:33 <merijn> So you want a higher order function which transforms a population into a new population by creating new individuals (using a user provided function of generating them)
15:57:00 <roconnor> bah,  What I want to do is data Merijn a b = MerijnA b | MerijnB (a -> Merijn a b);  merijn a (MerijnA b) = b; merijn a (MerijnB f) = merjin a (f a)
15:57:53 <applicative> roconnor: if that's what merijn needs, then haskell is the future of evolutionary programming...
15:58:14 <roconnor> applicative: I think I zoned out
15:58:54 <merijn> applicative: I don't think it will be because most real world problems require massive computation so most Real(TM) frameworks use OpenCL/CUDA :p
15:58:54 <applicative> roconnor: I wasn't criticizing, I was assuming you were on track.
15:59:27 <merijn> roconnor: I was thinking of using a recursive type, yeah. But I got stuck trying to define it, but I probably did it wrong. Lemme check again
15:59:46 <applicative> merijn: dont let dons and co. hear that kind of talk.
16:00:22 <micah> what's a function that finds the unique elements of a list
16:00:42 <merijn> applicative: Oh, I'm not saying it can't be done in haskell, but as far as I'm aware there's no good haskell bindings for OpenCL/CUDA
16:00:46 <applicative> > nub "abcc"
16:00:47 <lambdabot>   "abc"
16:00:50 <conal> merijn: for exactly the reason you gave (massive computation), i expect purely functional languages to win.
16:01:01 <medfly> @index nub
16:01:01 <lambdabot> Data.List
16:01:05 <micah> applicative: thanks
16:01:10 <micah> and medfly
16:01:11 <conal> merijn: opencl/cuda pose a huge complexity barrier.
16:01:17 <micah> :)
16:01:34 <merijn> conal: I'm not saying haskell is bad for it, just that the current ways to interface with the actual parallel hardware sucks :p
16:01:40 <conal> merijn: so i'm working on compilation of functional (non-IO) programs to gpus.
16:01:54 <conal> merijn: amen!
16:01:56 <merijn> I agree functional languages win on parallelism. Its one of the reasons I'm learning haskell
16:01:59 * XTREME GATE FOR UNITED STATES OF ISLAM facebook.com/brasstackspakistan
16:02:41 * hackagebot upload: gnuplot 0.3.3.1 - 2D and 3D plots using gnuplot (HenningThielemann)
16:02:54 <conal> merijn: and for clarity, i wouldn't use "functional" to describe a haskell binding to opencl/cuda.
16:03:20 <micah> with parsec
16:03:25 <conal> merijn: but such a binding would be helpful for implementing denotative/functional abstractions
16:03:42 <micah> how do I parse notasdf as a name but not asdf as a unary operator
16:04:14 <shapr> Looks like it's getting close to +R time again.
16:04:45 <conal> shapr: what's +R ?
16:04:59 <shapr> Only users identified with nickserv can speak.
16:05:10 <conal> ah
16:05:47 * conal gets back to functional gpu programming
16:06:03 <micah> can anyone help me?
16:06:28 <shapr> micah: greedy matching?
16:06:28 <Zao> micah: How does the relevant bit of the parser look?
16:06:49 <micah> term = try prefix <|> try paren <|> try name <|> try number <|> try str <?> "term"
16:06:49 <micah> prefix = do o <- prefixOper
16:06:49 <micah>             t <- term
16:06:50 <micah>             return $ Unary o t
16:06:50 <micah> prefixOper = token $ many1 $ oneOf $ nub $ concat prefixes
16:06:50 <micah> prefixes :: [String]
16:06:50 <micah> prefixes = [ "!"
16:06:51 <micah>            , "-"
16:06:51 <micah>            , "~"
16:06:51 <micah>            , "not" ]
16:07:11 <Zao> I hear hpaste is awesome.
16:07:26 <micah> :P sorry
16:07:42 <micah> http://gist.github.com/305126
16:11:48 <micah> so am I doing things in a bad way?
16:13:29 <applicative> micah:  I'm not quite getting it, but I wonder about the def of prefixes.  You only use it in concat prefixes, which is "-!~not"
16:13:44 * hackagebot upload: lrucache 0.1.0.1 - a simple pure LRU cache (CarlHowells)
16:13:59 <applicative> So you end up treating n and - and o and ! on a level
16:14:03 <micah> yeah there's a problem with that already becuase it gets ton and tnotnt
16:14:22 <micah> I could use foldl1 and <|>
16:14:26 <micah> with string
16:14:31 <micah> I was doing that
16:14:40 <micah> but it still had the problem with notasdf
16:14:48 <conal> micah: "prefix = liftA2 Unary prefixOper term".  or s/liftA2/liftM2/ if missing Applicative instances
16:15:01 <Ziphilt> hello all
16:15:14 <Ziphilt> i have a couple questions
16:15:21 <micah> @index liftA2
16:15:21 <lambdabot> bzzt
16:15:28 <micah> eh?
16:15:36 <c_wraith> index doesn't know much
16:15:36 <conal> @hackage lrucache
16:15:36 <lambdabot> http://hackage.haskell.org/package/lrucache
16:15:47 <c_wraith> @hoogle liftA2
16:15:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:15:51 <Ziphilt> one: what differences exist between Real World Haskell and Programming in Haskell?
16:15:55 <applicative> conal: can he leave prefixOper as it is with that?
16:16:35 <conal> applicative: i think so.  the version i gave is equivalent to his
16:17:19 <conal> applicative: oh.  i might have misunderstood your question.  i didn't check his other defs.
16:17:25 <applicative> I see, but I was thinking there was a problem with "concat prefixes" since it crushes the operators togethter with the letters in not
16:17:51 <micah> so I'm going to change that to foldl1 (<|>) prefixes
16:18:27 <applicative> micah: then what do you do with prefixOper
16:19:13 <micah> prefixOper = foldl1 (<|>) $ map string prefixes
16:19:19 <applicative> is it just token $ many1 $ foldl1 (<|>) prefixes
16:19:22 <applicative> oh
16:19:33 <micah> well atually
16:19:35 <micah> token $ before that
16:19:59 <micah> so that wroks perfectly, except
16:20:11 <micah> notasdf parses as Unary "not" (Name "asdf")
16:20:18 <micah> instead of Name "notasdf"
16:20:33 <micah> and I can't force whitespace after not
16:20:40 <micah> becuase what about not(true)
16:21:16 <Nereid_> tokenize it
16:22:07 <applicative> yeah, i think you need to be parsing tokens at a higher level?
16:22:18 <micah> so I should change my whole approach from putting "number" where I want a number to putting token in a case..of?
16:22:41 <applicative> your real letters are ""-"" ""not"" so to speak
16:22:56 <micah> eh?
16:23:17 <applicative> i mean, your real prefixes.
16:23:21 <micah> ok
16:23:46 <micah> so shoudl I do that?
16:24:02 <micah> make a parser called lex or lexer or something that returns a token?
16:25:32 <Ziphilt> it seems i was ignored...
16:25:36 * Alpounet thinks he would like to answer something said by applicative and FunctorSalad... so he could write "applicative functorsalad:"
16:25:41 <Ziphilt> i ask again: what differences exist between Real World Haskell and Programming in Haskell?
16:27:15 <applicative> micah: what laibrary are you starting from?
16:27:18 <applicative> library
16:27:25 <micah> parsec?
16:27:39 <Saizan> Ziphilt: programming in haskell is also an introduction to programming
16:28:02 <Saizan> Ziphilt: while read world haskell assumes you're already a programmer who would like to learn haskell
16:28:37 <Ziphilt> Saizan: if i am already familiar to programming, is there still value in Programming in Haskell?
16:30:09 <Saizan> Ziphilt: i've not read any of the two personally, but i think PiH would give more detailed explanations of some FP concepts which might be new to you
16:30:16 <applicative> micah: I'm not a parsec expert, but it seems plain that if you want characters like '-' and strings like "not" to be on a level, so you can find them in the input, you need first something that will chop the string into the right kind of bits
16:30:31 <Saizan> Ziphilt: there's a review of PiH in an issue of The Monad.Reader
16:30:36 <micah> ok
16:30:43 <micah> applicative: I shall refactor my parser then :)
16:31:07 <kuribas> Saizan: I found "Real World Haskell" very clear, though I am not new to functional programming.
16:31:15 <kuribas> I think it's a fine introduction.
16:31:17 <applicative> micah: I think so, I'm just worried, I'm not the one to advice.  Experiment and come back later when a Parsec master is on
16:31:25 <micah> ok
16:31:27 <micah> thanks
16:33:09 <merijn> roconnor: I tried messing with a recursive data definition again. But I'm convinced that solution is impossible, as you can't change the type of the curried function :\
16:33:45 <roconnor> merijn: you can encode each curried function.
16:34:14 <roconnor> merijn: there are also type-class hacks that will do this without needing to conversion.
16:34:33 <Saizan> merijn: so you want a way to repeadetly apply a function to some value?
16:34:56 <merijn> roconnor: I tried something along these lines http://dpaste.com/159702/, but the curried function is (of course) lacking the Creator constructor
16:35:28 <dons> anyone have a favorite numerics/arrays tutorial in another language i should port to haskell?
16:35:46 <roconnor> merijn: I -> I !!
16:35:55 <roconnor> merijn: that is a crazy type
16:36:04 <Saizan> you want Int -> I
16:36:08 <merijn> Oh, yeah
16:36:12 <merijn> Duh
16:36:16 <roconnor> that is like untyped lambda calculus crazy
16:36:53 <merijn> Although Int -> I is also broken, so it doesn't matter a lot :p
16:37:27 <Ziphilt> thanks Saizan, i think i'll just read RWH
16:37:55 <roconnor> merijn: what is test trying to do?
16:38:24 <Saizan> foo doesn't look right either
16:39:00 <Ziphilt> another thing i wanted to ask: does Perl have anything that Haskell does not, or at least anything that is much easier than in Haskell?
16:39:14 <applicative> its type is foo :: (I -> I) -> I -> Int
16:39:24 <merijn> roconnor: Right now essentially nothing. What test actually does is unknown, that's the entire problem. test is implemented by someone else. Foo is just supposed to pump the appropriate arguments into test until I get the result
16:40:42 <merijn> The example code is flawed in more ways now that I think about it. All that's know about test is that it takes a number of arguments of type a and returns a new a via some magic process I don't care about.
16:40:48 <Saizan> merijn: can you make test = Creator $ \x -> Creator $ \y -> Creator $ \z -> Individual z ?
16:40:57 <roconnor> merijn: assuming test : Int -> Int -> Int -> Int, you need encodeTest f = Creator (\x -> Creator (\y -> Creator (\z -> Individual (f x y z))))
16:41:12 <applicative> so foo is part of the infrastructure, test is a sort of variable
16:41:44 <merijn> applicative: Exactly that
16:42:05 <theorbtwo> Ziphilt: It all depends on how you think.
16:42:06 <merijn> foo is supposed to be the framework, test is supposed to be user provided
16:42:28 <roconnor> test has a bizarre type for something user provided
16:42:45 <merijn> roconnor: Oh, actually...that's pretty good. I didn't think of that
16:42:48 <theorbtwo> I'm also not sure that I know haskell well enough to answer you.
16:42:57 <theorbtwo> "The thing under test".
16:43:09 <theorbtwo> I don't think I'd name it test, but there is a logic behind it.
16:43:10 <roconnor> test should either have type Int -> Int -> Int -> Int or simply type I
16:43:23 <Ziphilt> theorbtwo, i definitely plan to learn both, for the different perspectives on how to solve problems
16:43:47 <Ziphilt> i was just wondering if there were large things that perl might have over haskell
16:43:56 <Ziphilt> does Haskell have regexp?
16:43:58 <merijn> roconnor: Ah, bollocks. encodeTest requires me to know the number of arguments too...
16:44:12 <merijn> Ziphilt: Of course, any serious programming language does
16:44:13 <applicative> merijn: the original problem was it that things like test, test2, could have different numbers of arguments?
16:44:24 <roconnor> merijn: without using typeclass hack code, you have to know the number of arguments at some point in time.
16:44:30 <theorbtwo> The biggest difference is in the communties; a perl programmer is more likely to ignore theory for practice; a haskell programmer is more likely to ignore pratice for theory.
16:44:37 <roconnor> merijn: I say push it to the user responibility
16:44:42 <Ziphilt> merijn, that's what i thought
16:44:45 <roconnor> ie. make test :: I
16:44:51 <Saizan> merijn: as a proof of concept: http://dpaste.com/159709/
16:44:59 <Ziphilt> i am curious to see how regexp is implemented in Haskell
16:45:01 <theorbtwo> Perl's biggest strength is in it's libraries -- for almost anything you can think of, there's an existing library that will help you.
16:45:19 <merijn> roconnor: If I do that, I might as well make it [Int] -> Int, it makes the rest of the code horribly ugly, though
16:45:21 <dons> Ziphilt: there are many libraries.
16:45:39 <dons> many many. look on hackage.haskell.org
16:45:47 <applicative> merijn:  I was wondering what you had against lists
16:45:48 <dons> there's some fun new quasiquoting ones that look like perl or ruby
16:46:21 <roconnor> merijn: then use the type class hack if you must. :)
16:46:25 <merijn> applicative: Mostly that in addition to making things more annoying for uses it makes things even harder and more annoying for me :p
16:46:30 * Saizan would use lists too
16:46:53 <Saizan> merijn: if my paste looks easier to work with, go for it :)
16:46:57 <merijn> Hell, *I* would use lists if I could think of a good way of doing that :p
16:47:15 <applicative> it seems unhaskell like, but i wonder if the problem would be clearer if we had a picture of the kind of file the user is going to give you
16:47:53 <applicative> how does she deliver a function to you, from maybe 3, maybe 4 args
16:47:53 <merijn> Saizan: I've saved it, I'll look at it tomorrow as by now it's 2 AM and trying to grok that now seems unwise :p
16:48:25 <applicative> merijn, don't grok anything with more than three pragmas
16:48:50 <Saizan> oh, shush, most interesting code is above that level :P
16:48:58 <applicative> i
16:49:14 <applicative> m jjust being bad, and expressing weakness.
16:49:28 <merijn> applicative: I really need to head for bed, maybe I'll try thinking of some clearer examples and questions tomorrow to bug people with tomorrow evening
16:49:38 <applicative> merijn: it sounds like an interesting project, i hope i can see more sometime, i have to go too
16:49:49 <gwern> 'ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_constrZMabOTZN_closure'
16:49:52 <gwern> any idea?
16:50:03 <merijn> Thanks and goodnight people :)
16:50:19 <applicative> gwern, obviously the ghc hasnt heard of sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_constrZMabOTZN_closur
16:50:20 <Saizan> gwern: cabal install syb-with-class --resintall --disable-documentation
16:50:37 <Saizan> s/resintall/reinstall/
16:50:45 <gwern> applicative: how ignorant of it
16:50:55 <applicative> i though t it knew everyting
16:50:56 <gwern> Saizan: I'm back on 6.10
16:51:13 <Saizan> gwern: so?
16:51:26 <gwern> so wasn't the th/haddock bug in 6.12?
16:51:35 <Ziphilt> thanks for everyone's help
16:51:36 <gwern> and template-haskell errors out
16:51:38 <gwern> how I hate it
16:51:48 * Ziphilt returns to shadows
16:51:52 <Saizan> you've to use the older syb-with-class with 6.10
16:51:56 <gwern> maybe I should go make rude comments at dons on reddit where he claims template haskell is stable and not dangerous at all
16:52:02 <Saizan> but no, the haddock bug is there in 6.10 too
16:52:44 <gwern> 0.5.1?
16:52:45 <Saizan> gwern: maybe you could understand the situation instead :)
16:52:54 <Saizan> 0.6
16:52:56 <gwern> Saizan: it should Just Work
16:53:05 <gwern> or give good errors
16:53:10 <gwern> two strikes against it
16:53:38 <Saizan> the .cabal file for template-haskell could be improved on that front, yeah
16:54:05 <sshc> gwern: why are you using 6.10?
16:54:13 <gwern> sshc: shit be buggy with 6.12
16:54:22 <gwern> I couldn't install anything - not yi, not darcs, not gitit
16:54:35 <sshc> gwern: I installed darcs with it
16:54:40 <gwern> sshc: good for you
16:54:43 <c_wraith> I wish I could understand what all the warning messages from 6.12 mean
16:54:52 <sshc> gwern: cabal install --global darcs-beta
16:56:48 <c_wraith> ...  and how to fix them without requiring CPP for things to still work on 6.10
16:59:20 <sshc> gwern: looks like the yi package in hackage hasn't been updated to work with 6.12
16:59:24 <sshc> gwern: or gitit
16:59:36 <gwern> sshc: course not. not sure the darcs/git versions have either
16:59:54 <gwern> but I don't think even got to configurign them, the deps screwed up every time
17:00:42 <c_wraith> I wish I could find some explanation of what was done to base to cause all these compile warnings/errors
17:00:56 <c_wraith> Or rather, *why*
17:17:19 <conal> anyone know how to convert a float to a GLfloat?
17:17:40 <copumpkin> :t realToFloat
17:17:41 <lambdabot> Not in scope: `realToFloat'
17:18:10 <copumpkin> :t realToFrac
17:18:11 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
17:18:15 <copumpkin> I think that will do it
17:18:20 <ClaudiusMaximus> @src realToFrac
17:18:21 <lambdabot> realToFrac = fromRational . toRational
17:18:39 <conal> copumpkin: thanks!
17:18:56 <conal> wow -- sounds expensive
17:19:06 <ClaudiusMaximus> conal: it is :(
17:19:11 <copumpkin> it's probably got a rewrite rule attached to it
17:19:19 <copumpkin> maybe not for GLFloat though
17:19:52 <copumpkin> http://www.haskell.org/pipermail/hopengl/2002-April/000156.html
17:20:20 <conal> copumpkin: oh -- rewriting it to an efficient version would be swell.  maybe ghc will discover and efficient impl even for GLfloat, which is build on CFloat
17:20:35 <copumpkin> I think that emails suggests it does rewrite it for you
17:21:13 <conal> even back in 02?
17:21:43 <copumpkin> apparently :) never used opengl much though
17:22:47 <conal> Float worked with OpenGL until some recent changes by sven.
17:23:24 <conal> now Float doesn't inhabit the necessary classes.  i can't add instances, because the methods aren't exported. :(
17:23:31 <copumpkin> aw
17:23:44 <conal> i've written to sven.  will bug him again.
17:24:28 <conal> this problem is what's kept FieldTrip broken for a couple of months now.
17:25:32 * conal sent another pester note.
17:45:59 <ezyang> what idioms to people like to use to represent values that can be calculated to arbitrary precision? iterate?
17:46:44 <monochrom> I would try iterate first.
17:48:29 <ezyang> I wonder if anyone has written a library that does this
17:48:41 <ezyang> for example, say I want to sum two fuzzy values.
17:49:02 <ezyang> hmm, performance might suck a lot though...
17:49:03 <roconnor> > pi :: CReal
17:49:04 <lambdabot>   3.1415926535897932384626433832795028841972
17:49:13 <roconnor> showCReal 100 pi
17:49:16 <roconnor> > showCReal 100 pi
17:49:17 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:49:39 <ezyang> huh, what's going on there?
17:50:13 <ddarius> http://hackage.haskell.org/packages/archive/reactive/0.11.4/doc/html/FRP-Reactive-Improving.html
17:50:19 <roconnor> > (exp pi) - pi :: CReal
17:50:20 <lambdabot>   19.9990999791894757672664429846690444960689
17:50:59 <roconnor> ezyang: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-CReal.html
17:51:48 <ezyang> computable reals... hmm
17:52:03 * copumpkin will write a library for the non-computable reals
17:52:30 <copumpkin> enumerateNonComputableReals :: [NonComputableReals]
17:52:42 <ezyang> maybe I should say what I'm actually trying to do.
17:53:19 <ezyang> oh wait, no, I don't have this problem
17:53:27 <copumpkin> :o
17:53:57 <ddarius> (R :  CReal) -> ...
18:00:04 <jonathanturner> I just had a quick question if someone has a minute.  I'm playing with parsec in os x 10.5, and when I put "import Text.ParserCombinators.Parsec" at the top of my source file and compile it, I have undefined symbols at compile time.  Using ghci and the :m command seems to work just fine.
18:01:08 <ClaudiusMaximus> suppose i have a collection of data points in 4d euclidean space - what's a good data structure to be able to find nearby data points?
18:01:29 <ClaudiusMaximus> jonathanturner: ghc --make    will probably fix it
18:01:30 <copumpkin> jonathanturner: ghc --make
18:01:59 <copumpkin> ClaudiusMaximus: maybe an r-tree
18:02:06 <jonathanturner> ClaudiusMaximus and copumpkin: Thanks that did it
18:02:08 <copumpkin> http://en.wikipedia.org/wiki/R-tree
18:02:58 <copumpkin> ClaudiusMaximus: there's a massive book on spatial datastructures though :P there are lots of choices
18:05:18 <ClaudiusMaximus> copumpkin: thanks for the pointer, "spatial datastructure" was the keyword i was looking for it seems
18:05:41 <copumpkin> unfortunately I know of no haskell implementations of any of them :/
18:06:53 <ddarius> I'm sure there are ones about either in freely floating modules or as part of other packages.
18:07:07 <copumpkin> maybe
18:07:53 <copumpkin> I wonder if we could construct and r-tree using finger trees
18:07:56 <copumpkin> *an
18:08:16 <copumpkin> probably not
18:09:13 <copumpkin> maybe they could actually, hmm
18:09:25 <copumpkin> intersecting bounding rectangles could be a monoid
18:10:11 <Cale> Wouldn't it be taking the bounding rectangle of the union?
18:10:19 <copumpkin> yeah, sorry
18:10:34 <Cale> You certainly could do that.
18:10:54 <copumpkin> and I guess the finger-tree paper already talked about interval trees, which are sort of similar
18:11:37 <Cale> I don't think I've ever run into a tree datastructure which *wasn't* some kind of monoidally indexed tree at heart.
18:11:42 <copumpkin> :)
18:11:54 <copumpkin> how would tries work?
18:12:59 <Cale> hmm, actually, that might be an exception. There's a semigroup operation there, but it's not a monoid.
18:13:01 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=20891#a20891
18:13:08 <Cale> (taking the longest common prefix)
18:13:13 <ezyang> I'm trying to decide if the reverse should happen in the comonad, or in the function
18:13:24 <int-e> Cale: what about disjoint set forests? ;)\
18:13:26 <Cale> Maybe we could extend that to be a monoid trivially by adding an identity element artificially.
18:13:37 <copumpkin> Cale: but I guess fingertrees could mostly work on semigroups too
18:13:44 <Cale> Mostly.
18:15:27 <Cale> int-e: I'm not sure I completely understand Wikipedia's description of them.
18:16:26 <Cale> But you can obviously create efficient union-find datastructures using monoidally indexed trees.
18:17:09 <int-e> Cale: it's an odd tree structure in that the pointers point towards the root rather than away from it. But I guess the monoid is actually set union.
18:19:19 <int-e> Cale: the idea behind the data structure is that all nodes in the same tree belong to the same set; to check whether two elements are in the same set, you compare the corresponding roots; the pointers allow you to find them easily.
18:21:30 <darius> Hi all, I am having problem compiling darcs 2.3.1 from source code (I am on ubuntu, ghc 6.10.4)  When I try runhaskell Setup configure I get: 2.o: unknown symbol `sysErrorBelch'
18:21:30 <darius> Setup.lhs: Setup.lhs: unable to load package `process-1.0.1.2'
18:21:36 <darius> any ideas?
18:23:18 <ezyang> Is there an efficient version of map reverse . inits?
18:24:01 <Axman6> > map reverse . inits $ [1..5]
18:24:03 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
18:24:19 <darius> one more note, cabal list shows me that I have process-1.0.1.2 installed
18:24:34 <ezyang> I suspect that map reverse . inits reverses each list, when there's obviously a result that can be reused
18:24:44 <Axman6> > inits . map reverse $ [1..5]
18:24:45 <lambdabot>   No instance for (GHC.Enum.Enum [a])
18:24:45 <lambdabot>    arising from the arithmetic sequence...
18:24:51 <Axman6> > inits . reverse $ [1..5]
18:24:52 <lambdabot>   [[],[5],[5,4],[5,4,3],[5,4,3,2],[5,4,3,2,1]]
18:25:01 <ezyang> Nope :-)
18:25:04 <Axman6> > tails . reverse $ [1..5]
18:25:05 <lambdabot>   [[5,4,3,2,1],[4,3,2,1],[3,2,1],[2,1],[1],[]]
18:25:14 <Axman6> > reverse . tails . reverse $ [1..5]
18:25:15 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
18:25:16 <Axman6> >_>
18:25:31 <Cale> darius: How about running 'cabal install' instead?
18:25:44 <Cale> darius: (rather than runhaskell Setup configure)
18:26:17 <ezyang> ew
18:26:25 <ezyang> that also doesn't work if the initial list is infinite
18:26:31 <ezyang> I bet I want scanl or something
18:26:37 <darius> I have already installed darcs with cabal install,  I am trying to build it from source to be able to undestand the code better
18:26:50 <Cale> scanl (flip (:)) [] [1..]
18:26:52 <Cale> > scanl (flip (:)) [] [1..]
18:26:53 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[...
18:27:02 <ezyang> cool
18:27:11 <Cale> darius: cabal install can install things from source.
18:27:19 <Alpounet> and you got a smiley for free
18:27:28 <Cale> darius: You just run it with no extra parameters from the source directory
18:27:33 <ddarius> cabal install only installs things from source
18:27:50 <Cale> (I mean rather than downloading from Hackage)
18:28:07 <Cale> darius: It seems to do a better job of dependency handling than the older cabal script mechanisms for some reason.
18:28:55 <ddarius> The Cabal library doesn't handle dependencies, I don't think.
18:28:58 <darius> it is compiling now
18:30:54 <ezyang> This function chain makes me kind of sad. extend f (R xs) = R . map (f . R) . tail $ scanl (flip (:)) [] xs
18:31:21 <copumpkin> :t scanl (flip (:)) []
18:31:23 <lambdabot> forall b. [b] -> [[b]]
18:31:31 <copumpkin> > scanl (flip (:)) [] [1..5]
18:31:32 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
18:31:43 <Cale> > scanl1 (flip (:)) [] [1..]
18:31:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:31:47 <Cale> > scanl (flip (:)) [] [1..]
18:31:48 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[...
18:32:06 <copumpkin> > map reverse . inits $ [1..5]
18:32:08 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
18:32:38 <Cale> ezyang: What's the overall type of extend?
18:32:48 <ezyang> it's the comonad extend
18:32:59 <ezyang> so extend :: (w a -> b) -> w a -> w b
18:33:25 <Cale> hmm
18:33:58 <Cale> > scanl (flip (:)) [] []
18:33:59 <lambdabot>   [[]]
18:34:09 <copumpkin> you're just doing the scanl to improve sharing?
18:34:11 <Cale> ah, okay, it'll be empty in the empty case, yes
18:34:28 <ezyang> copumpkin: yup
18:34:30 <Cale> copumpkin: well, and, it's the most efficient way to compute that function
18:34:44 <copumpkin> yeah, but not very legible :)
18:35:01 <Cale> Perfectly legible if you know that  reverse = foldl (flip (:)) []
18:35:30 <copumpkin> yeah, but not very legible ;)
18:35:48 <ezyang> " where reverseInits = scanl (flip (:)) [] "
18:36:30 <Cale> ezyang: So you're implementing the causal list comonad?
18:36:40 <Cale> It might be simpler not to implement extend directly
18:36:56 <ezyang> Cale: yup
18:37:09 <Cale> I usually prefer implementing duplicate and extract
18:37:12 <ezyang> i'd believe that. It was the cleareset function for me though
18:37:15 <jmcarthur> wait, list isn't a comonad!
18:37:26 <ezyang> let's try duplicate...
18:37:31 <Cale> jmcarthur: Nonempty lists of various sorts are though.
18:37:45 <jmcarthur> sure, but not []
18:37:50 <copumpkin> but he has a wrapper
18:37:55 <Cale> Yeah, you can assume that the lists are nonempty
18:37:56 <copumpkin> ezyang: it could be a newtype, btw
18:37:59 <jmcarthur> oh okay
18:38:05 <Cale> In fact, the definition is a little simpler if you pattern match
18:38:08 * jmcarthur obviously didn't read up enough
18:38:18 <Cale> extend f (R (x:xs)) = R . map (f . R) $ scanl (flip (:)) [x] xs
18:38:24 <ezyang> yeah, it's a bit simpler that way
18:39:17 <copumpkin> you could also ensure your lists are non-empty by separating the head from the rest of the list
18:39:22 <copumpkin> but maybe that'd make things more painful
18:39:29 <jmcarthur> (a, [a])
18:39:32 <Cale> Yeah, make it R x xs
18:39:56 <Cale> But then you have to split things up after the scanl...
18:40:19 <copumpkin> yeah, it might just end up being ugly
18:40:31 <jmcarthur> the only difference there is using (,) instead of (:)
18:40:36 <Cale> and again after the map
18:40:43 <jmcarthur> oh you mean getting the head from the tail
18:40:47 <Cale> yeah
18:41:02 * ezyang tries rewriting it using R x xs 
18:41:02 <Cale> It just makes it awkward to apply all the standard list functions.
18:41:03 <jmcarthur> yeah that sucks
18:41:13 <ezyang> enh, it's awkward
18:41:35 <ddarius> You might be able to lift through some Monoid and other Comonads.
18:42:02 <jmcarthur> what about Cofree Maybe?
18:42:08 <ezyang> ddarius: as in, I don't need a list, any monoid will do?
18:42:14 <jmcarthur> the work is done for you if you do that
18:42:44 <ezyang> I don't see any instances of Comonad for Monoid
18:42:48 <monochrom> Either Cofree Tea
18:42:55 <ddarius> Yep.  A cofree comonad will instantly give you a result and handle any such questions about the right definitions.
18:43:11 <copumpkin> mmm Cofree Maybe
18:43:27 <ezyang> things that are not the same: "cofree" "coffee"
18:43:50 * copumpkin reads coffee as cofree these days, sadly
18:43:57 <jmcarthur> lol
18:43:58 <copumpkin> but I don't drink coffee so that may play a part
18:44:14 * jmcarthur drinks coffee and has no trouble distinguishing the two
18:44:27 <jmcarthur> in fact i didn't get why monochrom said Either Cofree Tea
18:44:30 <ezyang> things that are not the same: "rose tree" "Rhododendron maximum"
18:44:31 * ddarius doesn't drink coffee and has no trouble distinguishing the two.
18:44:32 <jmcarthur> i was going to ask what Tea was
18:44:37 * monochrom drinks tea
18:44:49 * ddarius drinks tea.
18:44:53 * ddarius is drinking tea right now.
18:44:54 <copumpkin> Trea Maybe
18:45:06 <monochrom> Either Cofree Trea
18:45:11 * jmcarthur is drinking smirnoff right now
18:45:14 <copumpkin> Trea Identity
18:45:22 <copumpkin> jmcarthur: spike your tea with smirnoff
18:45:43 <ezyang> mooooo, this was just going to be about comonads and convolutions. I guess we'll have to do cofree too now
18:45:47 <jmcarthur> one of my friends called smirnoff "bitch beer" once and i have been apprehensive about admitting that i like smirnoff ever since
18:46:02 <copumpkin> ezyang: it's pretty simple, but it's a lot more legible if you look back at category-extras 0.2
18:46:33 <ezyang> oh... I am on the 0.2 docs... "uh oh"
18:46:48 <jmcarthur> i understand the one in 0.5, and i don't necessarily think that's a good thing
18:46:48 <copumpkin> yeah, don't look at the more recent ones :P
18:47:13 <darius> I am trying to load darcs with ghci but I get this error src/Darcs/RepoPath.hs:59:0:
18:47:14 <darius>      error: impossible.h: No such file or directory
18:47:14 <darius> phase `C pre-processor' failed (exitcode = 1)
18:47:14 <darius>   any ideas?
18:47:14 <ezyang> so, what is Free, and who defines it?
18:47:26 <copumpkin> ezyang: Free is in Control.Monad.Free in category-extras
18:47:40 <copumpkin> it'll give you a monad if you have a functor
18:47:46 <ezyang> mmm
18:48:11 <jmcarthur> ezyang: there's also a control-monad-free package on hackage as a standalone solution
18:48:15 <ezyang> I... assume most of our monads aren't free?
18:48:19 <jmcarthur> i doubt cofree has the same treatment
18:48:30 <jmcarthur> ezyang: it's free because you don't need anything resembling a monad to get a monad out of it!
18:48:33 <jmcarthur> any functor will do
18:48:45 <copumpkin> same with cofree, to get a comonad
18:48:46 <ddarius> I would just implement Cofree yourself.
18:49:11 <copumpkin> data Free f a = Moo a | Baa (f (Free f a)) iirc
18:49:15 <ezyang> right, but if I said used the functor instance on Writer to make a monad, I probably wouldn't get the writer monad...
18:49:16 <ddarius> data Cofree f a = Cofree !a (f (Cofree f a))
18:49:32 <ezyang> haha
18:49:39 <ezyang> that's cute.
18:49:57 <copumpkin> so Free is basically using Either and Cofree is using (,)
18:50:09 * ezyang nods 
18:50:38 <ezyang> Does anyone here actually use category-extras for non-mathematical purpose?
18:50:41 <ddarius> ezyang: Many of the monads used can be presented as free monads.
18:50:53 <ddarius> I don't think anyone uses category-extras.
18:50:53 <jmcarthur> ezyang: i've used it for many things, actually
18:51:00 * jmcarthur cowers
18:51:12 * copumpkin has fooled around with it, but wouldn't say he's used it
18:51:41 <ezyang> Also, I really wish I understood mathematical duality
18:51:46 <ezyang> maybe I'll figure that out and then write a post about it.
18:52:05 <jmcarthur> category-extras is not ideal or practical work
18:52:10 <jmcarthur> *for practical work
18:52:17 <jmcarthur> but i don't necessarily think it's on the wrong track
18:52:33 <copumpkin> edwardk wants to split it all up into half a dozen submodules
18:52:42 <jmcarthur> i think that's a good idea
18:52:44 <copumpkin> and move to type families as much as possible
18:52:49 <jmcarthur> also a good idea
18:53:22 * ezyang looks at the comonad definition again and tries to see if he can write it using duplicate 
18:53:26 <ddarius> ezyang: There isn't a single notion of "mathematical duality."  In this context it is categorical duality and it is very straightforward.
18:53:45 <ddarius> instance Functor f => Functor (Cofree f) where fmap f (Cofree a w) = Cofree (f a) (fmap (fmap f)); instance Functor f => Comonad (Cofree f) where extract (Cofree a _) = a; duplicate w@(Cofree a w') = Cofree w (fmap duplicate w')
18:53:53 <ddarius> I think that definition of duplicate is right.
18:54:14 <ddarius> I'm sure the type checker will say so.
18:54:20 <ezyang> ehm
18:54:37 <ezyang> it's math. I should figure it out myself :-)
18:55:00 <ezyang> oh, btw, I can't get my newtype of lists to work
18:55:14 <ezyang> newtype R a = [a] parse errors
18:55:16 <Saizan> ddarius: fmap is wrong though :)
18:55:22 <jmcarthur> newtype R a = R [a]
18:55:31 <ezyang> right.
18:56:04 <ddarius> Saizan: Why?
18:56:15 <ddarius> er, modulo the missing w
18:56:31 <Saizan> yeah, that, just being picky
18:58:26 <ezyang> hm, duplicate (R xs) = R . map R . tail $ reverseInits xs seems to work
18:58:38 <ezyang> it feels a smidge cheap, but I guess it makes sense
19:00:34 <ezyang> hmm, I wonder why there's no copointed instance for lists...
19:01:05 <ezyang> I guess it's the non-empty constraint rearing its head again
19:01:13 <Nereid_> indeed
19:01:41 <ezyang> hmm, even if it's uglier it might be a good idea to encode this in the data type then
19:02:06 <copumpkin> as long as you don't provide your constructor it's fine to do what you're doing
19:02:21 <copumpkin> but if you let people use your constructor it could be a problem
19:02:38 <ezyang> ah, ok. I'll export a constructor that has a -> as -> R a
19:03:45 <ezyang> is there... a naming convention for these constructors?
19:04:26 <copumpkin> they're usually called smart constructors, and tend to be the lowercase version of whatever your real constructor is. "r" might be a little short though
19:05:32 <ezyang> ok, time to think up of a better name!
19:07:15 <conal> ezyang: an unR would make that duplicate def prettily point-free
19:08:01 <ezyang> so it would!
19:10:42 <ezyang> Something I don't like about the comonad definition on these causal streams is that datatype seems to take on multiple meanings
19:11:32 <ezyang> Externally, the causal streams should be infinite; but inside a function :: w a -> b, the type w a is definitely /not/ infinite
19:12:29 <ezyang> it might not quite be a comonad
19:12:39 <ezyang> since, as sigfpe notes, comonads imply locality
19:13:38 <copumpkin> http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/03num.pdf ?
19:13:58 <ezyang> cool
19:18:05 <EvanCarroll> dons: thanks for the re: on the question
19:18:35 <ezyang> copumpkin: Cool. That basically explained why I felt funny about my implementation.
19:18:36 <EvanCarroll> jesus christ, I'm still intimidated by monads, now we have comonads?
19:18:46 <ezyang> I'm trying to change that!
19:18:47 <copumpkin> EvanCarroll: and so much more!
19:18:52 * EvanCarroll suicides.
19:18:56 <Gracenotes> nooooooooooos
19:19:08 <Cale> EvanCarroll: Comonads are just the categorical dual of monads. If you can understand one, the other is easy.
19:19:29 <jmcarthur> ezyang: are you perhaps looking for streams rather than lists?
19:19:29 <jmcarthur> not entirely sure what you mean that w a -> b means w a is not infinite
19:19:34 <Cale> (though understanding how to put them to good use is another matter)
19:19:34 <ray> yeah, if you understand one and the concept of "dual"
19:19:40 <ezyang> I mean, the values inhabiting w a are not infinite
19:19:46 <Gracenotes> I never got around to figuring out what the IO comonad does in terms of computation
19:19:50 <ezyang> *infinite lists
19:19:52 <Cale> IO isn't a comonad.
19:19:55 <Gracenotes> OI
19:20:00 <Gracenotes> the version that does IO
19:20:14 <jmcarthur> ezyang: you could use data Stream a = Cons !a (Stream a)
19:20:14 <Cale> I/O isn't captured by a comonad in any way
19:20:16 <jmcarthur> instead of lists
19:20:20 <Cale> OI doesn't work.
19:20:20 <ray> io comonad is unsound
19:20:51 <roconnor> wasn't there a paper a long time ago that IO was more naturally a comonad?
19:20:55 <Gracenotes> well, OI is the IO comonad. If the answer to doing things in terms of computation is doing nothing, then that's satisfactory
19:20:58 <roconnor> ... that claimed that ...
19:21:04 <Cale> roconnor: Yeah, but it turned out to be wrong.
19:21:21 <ezyang> "heh'
19:21:22 <Cale> Gracenotes: OI doesn't exist.
19:21:29 <ezyang> jmcarthur: Yeah, that's what the paper uses.
19:22:03 <Cale> Gracenotes: The one that the paper defines breaks referential transparency.
19:22:06 <Gracenotes> so I see. I once knew the type signatures for comonads, lemme see..
19:22:16 <jmcarthur> ezyang: or... type Stream = Cofree Identity
19:22:56 <ezyang> not gonna use cofree this time 'round
19:23:15 <jmcarthur> aw
19:23:23 <Gracenotes> well, that was a depressing bout of academic truth then
19:23:29 <Cale> ezyang: You could use infinite streams of values interpreted as going backward in time forever.
19:23:33 <ezyang> also, it's a bigger hammer than necessary for causals
19:23:50 <copumpkin> but you sound so fancy when you use cofree
19:23:53 <Cale> ezyang: which is just another way to look at the anti-causal stream comonad.
19:23:54 <jmcarthur> it's not a big hammer if it saves you code :)
19:24:08 <ezyang> jmcarthur: But but Understanding!
19:24:13 <ezyang> with a Capital U!
19:24:33 <ezyang> I fully intend on redoing this with Cofree once this is done.
19:24:57 <jmcarthur> i would only bother for the learning experience
19:25:12 <ezyang> Cale: Yeah
19:25:26 <ezyang> Cale: So, I think, for the general noncausal case, you have a natural representation for values in the past and future.
19:25:51 <ezyang> but if you're trying to impose causality, you only have values in the past, and there's no good place to "put them"
19:26:03 <ezyang> unless you reverse causality
19:26:08 * ezyang does the time warp 
19:26:49 <Cale> ezyang: Well, you can use snoc-streams :)
19:27:01 <Cale> data Stream a = Stream a :> a
19:27:29 <ezyang> :> is such a :> operator :-)
19:36:12 <copumpkin> that changes everything!
19:40:12 <badsheepy> :r
19:40:14 <badsheepy> oops
19:40:19 <copumpkin> :)
19:40:52 <ezyang> ok, more work on this vignette tomorrow!
19:40:56 <ezyang> g'night Haskell
19:41:15 <flippo> How many silly operators have been defined just for the silly emoticon?
19:41:58 <ddarius> > let (=^.-=) = (++) in "con" =^.-= "cat"
19:41:59 <lambdabot>   "concat"
19:42:37 * Zao shakes a friendly stick at the person behind Language.C
19:42:45 <Zao> It has both a CTypedef and a CTypeDef ctor.
19:43:09 <ddarius> One has to differentiate betweet 'typedef' and 'typeDef'
19:52:44 <altmattr> Is there a naming convention for methods that return booleans, the way ? is used in other languages?
19:54:23 <Gracenotes> well, what do the booleans mean?
19:55:10 <Gracenotes> if it's whether or not X is Y, isY is adequate
19:56:12 <altmattr> Gracenotes: isY is what I have been doing, and I suppose I should stick with it.  I just miss Y? so much :(
19:58:14 <Gracenotes> > let (*?) '*' = True; (*?) _ = False in map (*?) "a*b"
19:58:15 <lambdabot>   [False,True,False]
19:58:46 <Gracenotes> ? is in the land of symbol-using function names -.-
19:59:07 <Axman6> > ley y? 'y' = True; y? _ = False in map y? "yes... or not"
19:59:07 <lambdabot>   <no location info>: parse error on input `='
20:00:06 <Gracenotes> ley
20:00:59 <Gracenotes> Axman6: that will work otherwise though
20:02:03 <Gracenotes> > let y? 'y' = True; y? _ = False in map (y?) "yes.. or not?"
20:02:04 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
20:06:30 * ddarius would recommend using Maybe returning functions over booleans in most cases.
20:09:16 <ddarius> y ? c = ('y'==)
20:09:28 <ddarius> (y ?) = (y ==)
20:23:26 <cads> Hey, I'm thinking about getting a haskell book in dead tree format, are there any which include things like calculational reasoning, monads, ADTs, as well as IO, graphical interfaces, testing, app deployment? Am I describing real world haskell?
20:23:27 <Axman6> @pl (y ?) = (y==)
20:23:28 <lambdabot> (line 1, column 7):
20:23:28 <lambdabot> unexpected "="
20:23:28 <lambdabot> expecting variable, "(", operator or end of input
20:24:05 <Axman6> cads: sounds pretty much like RWH, eys
20:24:07 <Axman6> ]yes*
20:24:16 <cads> fantastic :)
20:25:41 <cads> hehe, it's silly because I have many papers pertaining to all of these things but I want something someone put together for lazy bums like myself
20:26:18 <sshc> cads: you can support the authors of RWH by purchasing their book :)
20:27:24 <cads> hooray for dead trees, they can feed authors
20:29:12 <ddarius> I don't believe RWH covers "calculational reasoning" at least not to the point of actually do much or any calculations.
20:31:44 <sshc> cads: if you've already read http://learnyouahaskell.com/ or already understand the very basics of it, RWH is a very good place to continue :)
20:33:07 * cads wishes people would stop recommending 'learn you a haskell', it makes haskell look like a language taught by lolcats
20:33:33 <cads> ddarius, I know, I'm being lazy and not reading my squiggol :/
20:35:17 <Berengal> I keep reading squiggol as squiggoth...
20:36:57 <kmc> cads, you can read RWH online and see what's in it
20:39:23 <cads> huh, there's a kindle edition
20:41:23 <kmc> i've been considering writing a Haskell tutorial
20:41:30 <kmc> how should it differ from LYAH and RWH?
20:42:39 <sm> shorter!
20:42:49 <sm> those guys are booring
20:43:05 <kmc> what specifically could be cut?
20:43:27 <kmc> i don't plan to spend any time on why and how Haskell is different from other languages
20:43:29 <cads> more operational semantics and type theory!
20:44:06 <cads> eh, that's not a very realistic suggestion, more of a joke
20:45:40 <sm> kmc, what to cut ? hey that's your job man
20:50:50 <sshc> sm: real wrold haskell's definitely not too long
20:50:59 <sshc> s/real world haskell/learn you a haskell/
20:51:33 <sshc> kmc: I'm glad to hear that!
20:52:20 <cads> kmc, thanks for that suggestion. I like the material in the book
20:53:09 <sshc> cads: what's wrong with learn you a haskell?  Have you read it?
20:55:00 <sshc> as lolcats are clearly not capable of writing a Haskell tutorial, I don't see how that tutorial could make it seem to be written by some
20:55:11 <sshc> I do like its style
20:55:16 <dons> some lolcats like haskell though
20:55:31 <cads> you underestimate lolcats!
20:55:34 <kmc> yeah, i quite like RWH. especially the coverage of networking, concurrency, STM, FFI, and the like
20:55:40 <dons> http://images.google.com/images?sourceid=chrome&q=lambdacats&um=1&ie=UTF-8&sa=N&hl=en&tab=wi
20:55:49 <dons> kmc: rocking.
20:56:11 <cads> sshc, they've got their own turing equivalent programming language - http://en.wikipedia.org/wiki/LOLCODE
20:56:50 <scutigera> trapped in IO monad is a classic...
20:57:23 <cads> sshc, I'm mostly turned off by the childish graphics and the simple language ... it's like "why's poignant guide to ruby", without the chunky bacon
20:57:46 <ddarius> It's explicitly modelled on why's poignant guide to ruby.
20:58:11 <cads> I think the chunky bacon is what kept why sane while writing that
20:58:28 <cads> actually.. dude's not all that sane
20:58:30 <ddarius> BONUS just didn't bother with staying sane.
20:58:41 <dons> hehe
20:58:59 <kmc> i feel like these new esoteric languages are boring and derivative... back in my day, when they designed an esolang they put real effort into making it drive people insane, like Malbolge, or C++
20:59:06 <ddarius> I've glanced at LYAH, but I haven't really read through it and don't see myself doing so.
20:59:43 <ddarius> Malbolge seems uninteresting; tantamount to simply encrypting the source code.
21:02:05 <kmc> the Gentle Introduction gets no love these days
21:02:21 * dilinger is sad that a bunch of those labmdacat images are unreachable
21:02:37 <tommd> kmc: How about "The Introduction of Hard Knocks"
21:03:06 <tommd> kmc: We could try to get the author of "Zen and the Art of Motorcycle Maintenance" to write it.
21:03:24 <cads> kmc, van eijicks and doets' 'road to logic, maths and programming' is pretty good
21:04:05 <cads> the gentle introduction is how I learned a long time ago
21:04:53 <cads> what i'm looking for is more of a workbook for doing some real world applications, and RWH looks pretty good
21:04:57 <ddarius> The Gentle Introduction is one of my favorite introductions to Haskell.
21:08:09 <scutigera> cads: I bought RWH early on, and it's been very helpful.
21:09:10 <scutigera> now dons, et al need to write real-world DSLs
21:09:41 <cads> real world agda
21:09:50 <scutigera> ???
21:10:43 <ddarius> There's a ways to go before there's a need for that book.
21:11:53 <copumpkin> I wonder how many users of agda there are out there
21:12:26 <scutigera> any recommends for intro to DSL, especially w.r.t. compiling ? compiling embedded languages (Elliot et al) best I've found so far
21:12:36 <ddarius> copumpkin: It'd be hard to tell due to Agda 1.
21:17:05 <Berengal> I've been thinking about a "Haskell from first principles" tutorial... except I can't agree with myself on what those principles are
21:17:28 <jmcarthur> breathing
21:17:29 <badsheepy> commitment.. honour.. respect for your elders
21:17:32 <badsheepy> :o
21:17:36 <jmcarthur> it's important to breathe first
21:17:45 <badsheepy> i concur
21:17:51 <jmcarthur> it's kind of the foundation for the rest of my life
21:18:00 <Berengal> Who needs breathing when you've got turing-completeness?
21:18:10 <badsheepy> turing
21:18:26 <badsheepy> god bless his soul :O
21:18:27 <Berengal> But was turing complete?
21:18:35 <jmcarthur> oh no! now you've got me wondering whether it's decidable in general if i will ever halt breathing
21:18:49 <Berengal> jmcarthur: And now you're thinking about it ;)
21:19:25 <ddarius> Berengal: The "first principle" of Haskell is surely the typed lambda calculus.  You can then go into the first principles of the typed lambda calculus if you so desire.
21:19:43 <kmc> http://igoro.com/archive/human-heart-is-a-turing-machine-research-on-xbox-360-shows-wait-what/
21:20:12 <Berengal> ddarius: Indeed, but the details... are ADTs a fundamental part of haskell, or are they just syntactic sugar for a class of LC functions?
21:20:47 <jmcarthur> i guess you are ignoring GADTs?
21:21:00 <Berengal> For the moment, yes
21:21:10 <jmcarthur> oh, and what about lazy vs. strict fields?
21:21:22 <kmc> i'd say they're fundamental
21:21:25 <Berengal> But if they somehow bring resolution to this issue, I'd happily introduce them on the first page
21:21:36 <kmc> i think you should use GADT syntax from the beginning
21:21:38 <Berengal> jmcarthur: Operational semantics. That comes later
21:21:44 <kmc> but not actually introduce GADT types until later
21:22:04 <jmcarthur> is a strictness annotation really an operational detail?
21:22:11 <jmcarthur> i'm not so sure, myself
21:22:20 <jmcarthur> it's like the difference between data and codata
21:22:24 <ddarius> jmcarthur: No, it isn't.  It is a semantic detail.
21:22:45 <Berengal> ddarius: Which semantics?
21:23:31 <ddarius> The difference between strict and non-strict fields is observable; they aren't just suggestions to the compiler.
21:23:53 <Berengal> Are they really observable inside the program though?
21:24:05 <jmcarthur> "inside"?
21:24:05 <Berengal> Wouldn't you have to be able to observe _|_?
21:24:24 <jmcarthur> i'd say _|_ is semantically important
21:24:24 <Berengal> jmcarthur: The program can observe things about itself
21:24:29 <jmcarthur> you don't have to be able to observe it
21:24:57 <Berengal> Oh, indeed, but you can lump strict fields together with all other _|_s
21:25:06 <jmcarthur> but _|_ can mean the difference between a program that does what i want and a program that doesn't
21:25:14 <jmcarthur> and it
21:25:17 <jmcarthur> oops
21:25:27 <jmcarthur> and it's not just because that's how it works underneath it all
21:26:36 <jmcarthur> heck, we even force our functor laws to respect _|_
21:27:13 <ddarius> Berengal: do () <- return (); putStrLn "Hello World" and do () <- fix id; putStrLn "Hello World" and distinguishably different programs.
21:28:06 <Berengal> ddarius: Yes, to us, but you can't observe that inside the program itself
21:29:30 <dolio> How about do 5 <- return 5 ; putStrLn "Hello World" vs. do 5 <- return 4 ; putStrLn "Hello World"?
21:29:40 <dolio> Are 5 and 4 observationally different?
21:29:47 <Berengal> dolio: That uses fail, which isn't _|_
21:29:55 <ddarius> Berengal: The fact that one program does print hello world and one does not is observable and a semantic difference.  If you like, we can add concurrency and then those as processes are blatantly distinct.
21:30:57 <Berengal> ddarius: But you can't in general tell the difference between a long-running loop and an infinite one
21:31:23 <ddarius> Berengal: Sure you can.  Wait.  The long running loop will terminate in finite time, the infinite loop won't.
21:31:33 <copumpkin> lol
21:33:09 <jmcarthur> Berengal: it sounds to me like the inability to tell the difference between a very long computation and _|_ in bounded time is an operational detail
21:34:17 <Berengal> May be true
21:34:40 <jmcarthur> surely (\x -> x x)(\x -> x x) is semantically important even though it's _|_ (untyped lambda calculus, of course)
21:39:35 <dolio> I suppose my example might not explain my point well. I think when people say that a is observationally different from b, they mean that you can write functions that have different outputs when given a and b. But that's the case for _|_, as well.
21:39:49 <dolio> seq is an obvious example.
21:40:37 <dons> tried to start a tutorial on using the vector package, http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
21:40:55 <dons> time to get people to stop using Data.Array
21:41:03 <copumpkin> I guess bos will move statistics to vector?
21:41:13 <dons> in good time, yeah.
21:41:26 <dons> i want to move everything to vector. death to Data.Array
21:41:33 <copumpkin> :)
21:41:38 <copumpkin> what about alternate indexing schemes?
21:42:15 <copumpkin> I guess indexing by pairs can be replaced by nested arrays without losing efficiency
21:42:45 <dons> vectors support some pretty fancy index space manipulation
21:42:49 <dolio> I must say, vector leaves me much more satisfied than uvector in that regard. I kind of felt bad that my code was restricted to unboxed arrays, and had contemplated trying to make it independent of underlying array implementation.
21:43:01 <dons> right.
21:43:06 <dons> vector is way more flexible.
21:43:15 <dons> but that was the point of uvector. pick something stable while rl kept hacking away
21:43:17 <dolio> But vector is much more a full-fledged array library for all purposes, so I don't feel as bad.
21:43:35 <dons> all the boxed array fusion stuff is nice.
21:44:03 <dons> just have to work out what all the accum* and permute* functions do
21:44:39 <Axman6> i wish the slice functions had better docs
21:44:53 <dons> i just sent in some doc patches
21:44:56 <dons> need commit access.
21:45:02 <Axman6> excellent :)
21:45:09 <dons> more docs, more benchmarking, a tutorial == we're done.
21:45:13 <Axman6> my only other gripe was docs
21:45:16 <dons> then start converting stuff on hackage to use vector.
21:45:34 <dons> feel free to fire up ghci and paste in some of the examples, http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
21:45:36 <copumpkin> mmm, I'll be writing some code soon that could use it
21:45:43 <copumpkin> was going to use uvector but I'll just start with vector
21:45:49 <dons> yep.
21:45:51 <c_wraith> Is there any documentation around for how to address all the new warnings from GHC 6.12?
21:45:53 <dons> remember to use -Odph
21:46:03 <Axman6> dons: ah excellent
21:46:13 <copumpkin> speaking of dph, how hard will it be to move from vector to dph when dph is more mature?
21:46:21 <copumpkin> I assume the API is almost the same, since they're so closely related?
21:46:24 <dons> trivial.
21:46:27 <dons> they're very similar
21:46:35 <copumpkin> nice
21:46:35 <dons> and your operations will just be magic parallel
21:46:40 <copumpkin> yay
21:46:47 <jmcarthur> sweet!
21:47:01 <dons> it'll take a few years of advocacy for this to sink in. NumPy dead anyone ? :)
21:47:10 <Axman6> "Magic Parallel"
21:47:13 <Axman6> love it
21:47:14 <dons> short syntax + magic parallelism.
21:47:24 * jmcarthur is a cutting edge kind of person, so it sunk in here already
21:47:43 <copumpkin> we'll need an fftw on vector binding!
21:47:59 <copumpkin> Axman6: or maybe a vector + veclib :)
21:48:02 <copumpkin> (for mac os)
21:48:10 <Axman6> :D
21:48:19 <Axman6> man, i forgot i was going to make a binding for that :(
21:48:24 <Axman6> oh well
21:48:32 <copumpkin> well luckily you didn't start before the right module came along for it!
21:48:42 <Axman6> damn it would be good if things like vector could use veclib on OS X
21:48:47 <copumpkin> dons: does vector operate on pinned arrays?
21:49:13 <dons> I think perhaps the Storable ones are pinned?
21:49:16 <dons> need to check.
21:49:21 <dons> i've not dug down far enough yet.
21:49:21 <copumpkin> ah okay, I can check
21:49:26 <dons> by default they're unpinned.
21:49:31 <dolio> The storable vectors use ForeignPtr underneath.
21:49:34 <dons> but we definitely need to work out that story to do FFI stuff
21:49:40 <copumpkin> cool
21:49:55 <copumpkin> oh yeah, Data.Vector.Storable
21:50:06 <dons> i think it can't hurt to talk about dph being "magic parallel" actually.
21:50:21 <copumpkin> mph :P
21:50:26 <dons> prob. the best motto for catching eyes.
21:50:33 * jmcarthur foresees a lot of people trying to call bs
21:50:34 <augur> hey guyses
21:50:36 <augur> and girlses
21:50:44 <augur> if there are any girlses here
21:50:46 <copumpkin> and augurses
21:50:48 <copumpkin> there are
21:50:57 <dons> well, data parallel arrays are fully implicit parallel, so that counts as magic in my books
21:51:11 <jmcarthur> it's automagic
21:51:58 <Axman6> which is pretty much the holy grail if what people have been after for parallelism for a while
21:52:06 <dolio> I was thinking I could parallelize some of my mutable vector stuff, too, since vector can operate in IO as well as ST.
21:52:15 <copumpkin> ooh
21:52:20 <dolio> So, parallel in-place quicksort.
21:52:25 <dons> hehe
21:52:34 <dolio> I'm not really sure what the dph story is with regard to mutable arrays.
21:52:39 <copumpkin> couldn't you parallelize it in ST too? if it's deterministic then unsafeIOToST might not be terrible?
21:52:47 <dolio> Right.
21:53:02 <dons> dolio: pretty much the same, but underneath you have loops of worker threads doing filling operations
21:53:23 <copumpkin> hah, instance Unbox ()
21:53:29 <jmcarthur> so how long until vector supports the gpu? ;)
21:53:36 <dolio> dons: Is it that 'distributed monad' stuff I saw in a paper somewhere?
21:53:41 <dolio> Because that looked pretty good.
21:54:23 <dons> mm. distributed array types, anyway.
21:54:26 <dons> Dist Vec a
21:54:30 <dolio> Right.
21:54:31 <Axman6> jmcarthur: well, that's that ChilliX/TacticalGrace is working on :)
21:54:39 <Berengal> GPUT (Dist Vec) a
21:54:46 <jmcarthur> Axman6: yes i'm aware of this and watching keenly
21:54:49 <dons> yeah, that's what the accelerate package is for
21:54:53 <copumpkin> dolio: have any more information on that?
21:55:14 * Axman6 hopes that accelerate takes a long time so he can work on it for a honours/PhD project >_>
21:55:17 <copumpkin> two years from now, haskell will be the language of scientific computing (fuck matlab)
21:55:24 <copumpkin> Axman6: NO!
21:55:29 <copumpkin> work on whatever comes afterwards :P
21:55:32 <Axman6> :P
21:55:33 <copumpkin> I want it done asap
21:55:36 <copumpkin> :)
21:55:36 <dons> we have to work very hard to make that happen though. lots of outreach.
21:55:51 <dons> you can have the best libs in the world, but without telling people how to use them, no one will.
21:55:56 <Axman6> fineine, i'll do QPU haskell then ;)
21:56:13 <copumpkin> lol
21:56:30 <dolio> copumpkin: You could probably search the haskell reddit for slides on DPH. I think that's where I saw it.
21:57:28 <k23z__> I want to install ghc-prim
21:57:30 <k23z__> I'm on debian
21:57:33 <k23z__> how do I do that ?
21:57:47 <k23z__> I've succesfuly installed cabal
21:57:49 <kingping> Is there any tutorial on haskell?]
21:57:52 <k23z__> and cabal-install
21:57:58 <k23z__> kingping: many
21:58:02 <kingping> I'm new to it.
21:58:15 <copumpkin> dolio: http://www.haskell.org/pipermail/haskell-cafe/2009-December/071002.html this?
21:58:18 <jmcarthur> @where lyah
21:58:18 <lambdabot> http://www.learnyouahaskell.com/
21:58:21 <jmcarthur> @where rwh
21:58:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:58:25 <jmcarthur> kingping: ^^
21:58:40 <kingping> k23z__: Often see a link to any tutorial in topic. None is here.
21:58:47 <kingping> Thanks.
21:59:12 <dolio> copumpkin: That's all old stuff.
21:59:29 <dolio> Except maybe Eden.
21:59:45 <copumpkin> there's a very slight mention of distributed memory on http://jaoo.dk/aarhus-2009/file?path=/jaoo-aarhus-2009/slides/SimonPeyton-Jones_DataParallelHaskell.pdf
22:00:00 <k23z__> how do I install ghc-prim ? anyone ? hello ?
22:00:14 <copumpkin> apt-get install ghc-prim maybe?
22:00:19 <Axman6> i'm pretty sure ghc-prim is part of ghc
22:00:29 <Axman6> could be wrong, but it seems logical...
22:00:32 <copumpkin> I assume it's a package name in debian too?
22:00:38 <k23z__> I've installed ghc6 and I am told I don't have ghc-prim
22:00:49 <k23z__> copumpkin: it's nowhere in debian's repo
22:00:59 <dolio> copumpkin: The stuff about Dist is what I was thinking of.
22:01:12 <dolio> splitD, mapD, sumD, etc.
22:01:13 <copumpkin> it's definitely a cabal-level package, but it should come with ghc
22:01:21 <k23z__> ok it doesn't
22:01:23 <copumpkin> dolio: hmm
22:01:25 <k23z__> how do I get it and install it ?
22:01:36 <copumpkin> you don't
22:01:39 <k23z__> right
22:01:45 <k23z__> I don't.
22:01:58 <copumpkin> it's the primitive operations that come with GHC
22:02:04 <copumpkin> what version of GHC?
22:02:19 <k23z__> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.8.2
22:02:39 <dolio> copumpkin: splitD :: [:a:] -> Dist [:a:] represents splitting chunks of an array across multiple cores.
22:02:50 <Axman6> is debian still on 6.8? urgh
22:02:58 <copumpkin> dolio: looks very nice... did you find it or are you remembering that from wherever you saw it?
22:03:03 <c_wraith> debian's not about up-to-date software
22:03:04 <k23z__> Axman6: what's the latest ?
22:03:05 <kingping> Variables in haskell are immutable, true?
22:03:09 <copumpkin> k23z__: 6.12
22:03:12 <dolio> copumpkin: It's in those slides you linked to.
22:03:13 <Axman6> 6.12
22:03:19 <Axman6> k23z__: yes
22:03:20 <copumpkin> dolio: oh, silly me
22:03:22 <Axman6> uh, kingping
22:03:26 <k23z__> copumpkin: would be a good move to upgrade to 6.12 ?
22:03:37 <c_wraith> Eh.  6.12 isn't ready for real use.  Not unless there's an explanation somewhere of what all these new warnings *actually* mean.
22:03:42 <dolio> copumpkin: I guess it's not really explained there. Maybe there are other slides that explain it better.
22:03:44 <kingping> Axman6: I mean once variable is bound you can't change its value.
22:03:46 <Axman6> k23z__: do you like playing with cutting edge things?
22:03:49 <k23z__> no
22:03:50 <Axman6> kingping: yes
22:03:54 <copumpkin> k23z__: 6.8.2 is from last 2007... maybe not 6.12 but at least 6.10
22:03:57 <k23z__> because it's usually broken
22:03:58 <Axman6> kingping: then go with 6.10.4
22:04:07 <k23z__> ok 6.10
22:04:14 <kingping> Axman6: And there's no notion of global variables except function declarations?
22:04:27 <Axman6> no one's really been complainging about anything in 6.12 that i've seen
22:04:34 <Axman6> much less complaining than 6.10 anyway
22:04:47 <scutigera> copumpkin: are you an unsatisfied matlab user ?
22:04:53 <copumpkin> scutigera: absolutely!
22:04:55 <Berengal> Axman6: Possibly because less people are using it?
22:04:58 <k23z__> if I get 6.10 where will I get libghc6-http-dev and other libraries necessary for cabal ?
22:05:03 <k23z__> libghc6-mtl-dev
22:05:07 <k23z__> libghc6-network-dev
22:05:10 <scutigera> copumpkin: you must have looked at hmatrix
22:05:12 <k23z__> libghc6-parsec-dev
22:05:16 <copumpkin> scutigera: yep
22:05:16 <k23z__> where will I get those ?
22:05:20 <k23z__> do I have to build those myself ?
22:05:22 <k23z__> or ...
22:05:28 <k23z__> !?!
22:05:33 <k23z__> oO
22:05:41 <scutigera> copumpkin: I've been using it for some minor stuff. have you done any "big" work with it ?
22:05:46 <Berengal> k23z__: The cabal distribution has a bootstrap.sh script that does that for you
22:06:08 <copumpkin> scutigera: nope, most of what I use matlab for isn't really matrices... it's just that a lot of algorithms and code in my group is already in matlab
22:06:08 <k23z__> Berengal: so I'll just need cabal right ?
22:06:15 <Berengal> k23z__: And ghc
22:06:22 <copumpkin> I've been slowly migrating away from it, and writing what I can in haskell
22:06:29 <copumpkin> but it'll take a while
22:07:10 <k23z__> if I installed Cabal and cabal-install how do I dispose of them now ?
22:07:12 <Axman6> k23z__: just install the haskell platform
22:07:13 <scutigera> scutigera: yeah, it pains me.  we're building up a legacy code base in matlab.  haskell could do the job just as well plus gen the target code for the hardware.  then the alorm goes off.
22:07:16 <Axman6> @where platform
22:07:16 <lambdabot> http://hackage.haskell.org/platform/
22:07:25 <scutigera> s/alorm/alarm
22:09:22 <Axman6> i've used haskell for processing data for feeding to matlab, which i just used for graphing
22:10:25 <scutigera> Axman6: yep - I'm using it for the math, grabbing data from DB, and then feeding it to graph (plotutils).
22:12:01 <k23z__> Axman6: thanks
22:12:28 <k23z__> can I ask what you guys use haskell for ?
22:13:36 <scutigera> k23z__: I do quite a bit of math oriented stuff in it.  works pretty naturally and allows nice handling of the "support" to solve the problem.
22:13:46 <Berengal> I use it almost exclusively for all my spare-time hacking, which as-of-yet hasn't produced anything of value
22:14:27 <k23z__> I like writing software with absolutely no application to real world problems
22:14:33 <k23z__> it's the best software and most fun
22:14:38 <k23z__> I'm not joking
22:14:39 <copumpkin> Berengal: hey, your web stuff looks pretty good so far
22:14:58 <copumpkin> k23z__: then haskell is the language for you! :P
22:15:05 <copumpkin> just kidding, it's used for plenty of "real world" things
22:15:07 <Berengal> copumpkin: But not valuable yet. I got stuck
22:15:10 <copumpkin> but it's also good for playing around with
22:15:23 <copumpkin> oh no!
22:15:25 <scutigera> k23z__: I think brainf*ck is the language for you ;-)
22:15:42 <k23z__> I tried to write brainfuck, I couldn't
22:15:45 <k23z__> it was really complicated
22:15:51 <copumpkin> it's pretty mind-bending
22:15:57 <copumpkin> in a very different way from haskell
22:16:02 <scutigera> k23z__: I wouldn't even try, so your ahead of me...
22:16:11 <scutigera> s/you're/your/
22:16:26 <copumpkin> I've written some nontrivial stuff in it, but it's painful
22:16:41 <scutigera> copumpkin: in brainf*ck ?!
22:16:42 <copumpkin> even outputting decimal numbers (of more than one digit) is quite a challenge
22:17:01 <copumpkin> yep
22:17:17 <scutigera> dude, that's gotta be the definition of too much free time ;-)
22:17:23 <Berengal> I guess it's easier to write a compiler that compiles to brainfuck than to actually write stuff in brainfuck itself
22:17:31 <k23z__> yes
22:17:36 <k23z__> brainfuck seems like an assembly language
22:17:37 <copumpkin> scutigera: it was for a class actually :P
22:17:44 <k23z__> it's pretty similar to a primitive assembly language ...
22:17:53 <k23z__> maybe even more primitive than assembly ..
22:18:05 <scutigera> copumpkin: so were you allowed to say BRAINFUCK in class ?
22:18:15 <copumpkin> just write everything with subleq
22:18:17 <copumpkin> scutigera: yeah, it was fun
22:18:31 <copumpkin> it was a final project for a languages course
22:18:43 <copumpkin> I figured I'd give an esoteric language a go
22:19:08 <scutigera> copumpkin: had to encourage brain plasticity :-)
22:19:32 <ddarius> Brainfuck seems like one of the least interesting esoteric languages.  It's pretty straightforward, just tedious.
22:20:06 <kmc> it's interesting to implement it in VHDL
22:20:39 <ddarius> Implementing anything in VHDL is interesting.
22:20:48 <copumpkin> ddarius: yeah, probably, but it's still quite challenging to program in unless you write something that compiles to it
22:20:56 <kmc> actually, i hear it's tedious ;P
22:21:35 <kmc> also not as interesting unless you stick to synthesizable VHDL
22:21:41 <ddarius> copumpkin: I personally would see a lot more value and enjoyment in learning an assembly language (or would if I didn't already know a few.)
22:22:00 <copumpkin> ddarius: I already knew a couple at that point
22:22:02 <ddarius> kmc: If it's not synthesizable, what's the point?
22:22:16 <Dark_Shikari> k23z__: it's more like turing machine instructions
22:22:18 <kmc> testing, usually
22:22:28 <Berengal> INTERCAL's an esoteric language with charm
22:22:29 <ddarius> Behavioural specification.
22:22:45 <spoooty> Hi all, newbie question here... I made a record type (data Yam = Yam { x::Int, y::Int }), and I can pull out the subvalues by expressions such as (x myyam), and I was hoping a more C-like syntax (myyam `x`) would also work. Are postfix operators impossible?
22:22:57 <ddarius> But, by "write something in VHDL" I mean "write something fabricatable."
22:23:24 <Berengal> spoooty: with -XPostfixOperators that should just just as expected
22:23:40 <spoooty> ah sweet, thanks!
22:23:48 <ddarius> let (-->) = flip ($) in myyam-->x
22:24:03 <ddarius> If you want to piss everyone off, let (.) = flip ($) in myyam.x
22:24:12 <copumpkin> lol
22:24:52 <scutigera> ddarius: verilog rulz.
22:25:09 <copumpkin> rulz!
22:25:19 <k23z__> scutigera: what math do you use haskell for ?
22:25:22 <ddarius> scutigera: Discrete components rule.
22:25:25 <copumpkin> @let (?) = flip ($)
22:25:26 <lambdabot>  Defined.
22:25:41 <scutigera> ddarius: nands and xors,  that's all I need to make me happy.
22:25:56 <k23z__> Berengal: what do you write in it ?
22:26:09 <copumpkin> > [1..10]?group?map(length&&&head)
22:26:10 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t3 -> t'
22:26:10 <lambdabot>         against inferred...
22:26:17 <kmc> spoooty, btw, records in Haskell are kinda crappy.  if the limitations start to annoy you, look at the fclabels package on Hackage
22:26:19 <copumpkin> bah
22:26:25 <kmc> (or lenses or data-accessor)
22:26:29 <copumpkin> > [1..10]?group>>>map(length&&&head)
22:26:30 <lambdabot>   Couldn't match expected type `t -> cat a b'
22:26:30 <lambdabot>         against inferred type `...
22:26:37 <Berengal> k23z__: INTERCAL?
22:26:42 <ddarius> scutigera: Resistors, transistors, diodes, capacitors, and the occassionaly inductor are all I need.
22:26:51 <scutigera> k23z__: simulations.  signal processing.
22:27:08 <scutigera> ddarius: bjt AND mosfet ?
22:27:33 <kmc> point contact transistor for life
22:27:34 <spoooty> kmc: yeah, i was starting to suspect that. might be so (i noticed the easy namespace conflicts, for example)
22:27:35 <ddarius> scutigera: Given a choice of only one, MOSFET is what I'd choose, but both would be nice.
22:27:46 <k23z__> scutigera: and do you do it for yourself or for class or .. ?
22:27:52 <scutigera> ddarius: pHEMT :-)
22:28:23 <ddarius> (and I guess to be honest, I'd also like a pile of op-amps, but they aren't absolutely necessary)
22:28:34 <kmc> can't you make diodes out of transistors?
22:28:35 <scutigera> k23z__: myself and occasionally sneak it in at work.  but for things somebedy else is going to use it's gotta be python
22:28:46 <scutigera> kmc: bjt's yes
22:28:47 <ddarius> kmc: Yes.
22:28:52 <kmc> not FETs?
22:29:19 <scutigera> well, MOSFETs have a body diode but you can't get to it by it's lonesome
22:30:03 <scutigera> p.s. python sucks when you're app gets over about 200 lines or so.  man do I miss static typingp
22:30:06 * kmc never really learned how a transistor works
22:30:44 <scutigera> ddarius: vfb or cfb ?
22:31:18 <k23z__> a transistor has impurities
22:31:21 <k23z__> and stuff like that
22:31:23 <k23z__> :)))
22:31:31 <copumpkin> luckily, haskell does not
22:31:33 <k23z__> and permits currents to go certain directions
22:31:34 <k23z__> lol
22:32:11 <k23z__> scutigera: how do you like Perl ?
22:32:20 <k23z__> scutigera: do you think it sucks also after 200 lines ?
22:32:36 <c_wraith> Ok, is 6.12.1 just buggy?
22:32:37 <spoooty> i think MOS transistors are the nicest to understand. you have a voltage that is a gate, controlling whether current can pass through a nearby channel.
22:32:46 <scutigera> k23z__: gave it up for python.  I couldn't read 40 lines of my own code a month later.
22:32:59 <kmc> scutigera, i agree.  Python is great for very quickly writing a program which is short enough to be obviously correct
22:32:59 <c_wraith> It's telling me an import is redundant, when the program doesn't compile without it.  I guess that means it's buggy.
22:33:02 <k23z__> scutigera: you don't comment your code very much do you ? :)
22:33:04 <scutigera> k23z__: that was _many_ moons ago.
22:33:13 <kmc> c_wraith, i've got that with 6.10.4 as well
22:33:30 <c_wraith> kmc: 6.10 doesn't tell me this import is redundant, though
22:33:30 <k23z__> scutigera: I mean you probably like code that is lizible without comemnts ..
22:33:35 <Zao> k23z__: I see you're working hard at discussing everything but Haskell.
22:33:37 <scutigera> k23z__: honest, I do.  too much "hidden" stuff in perl.
22:33:44 <kmc> i worked on a pretty big Python project and it went fine until the first major refactoring
22:34:01 <kmc> turns out, static types help you find all the code you haven't properly refactored yet
22:34:03 <k23z__> Zao: my haskell platform is still compiling ..
22:34:12 <shapr> dons: Yeah, why do you want NumPy to die?
22:34:19 <Axman6> k23z__: compiling? :\
22:34:27 <copumpkin> I'd want matlab to die first
22:34:33 <copumpkin> or at least to change very significantly
22:34:34 <k23z__> Axman6: ./configure && make && make install
22:34:42 <Berengal> c_wraith: doesn't compile because of a lack of instances, or because of the actual imports?
22:34:46 <shapr> That's what mich said.
22:34:46 <Axman6> k23z__: why not just install one of the binaries?
22:34:47 <scutigera> copumpkin: oh yeah...
22:35:13 <k23z__> Axman6: I didn't see any binaries for my distribution
22:35:27 <k23z__> but anyway
22:35:33 <c_wraith> Berengal: it's an "import Prelude hiding...".  Without that, there's a conflict in name resolution
22:35:37 <Axman6> debian was it?
22:35:41 <k23z__> Axman6: yes
22:35:47 <Axman6> http://wiki.debian.org/Haskell/Platform
22:36:01 <c_wraith> Berengal: But 6.12 decides the import is redundant, even though it isn't.
22:36:04 <k23z__> yes but I'm on debian stable and I don't think I can use those packages
22:36:05 <Berengal> c_wraith: Oh, that does seem like a bug
22:36:14 <Axman6> urgh
22:36:21 * Axman6 rages at linux once again
22:36:28 <scutigera> copumpkin: can't you just see s/matlab/haskell/  change one line and everthying shifts from floating point to fixed point...
22:36:33 <k23z__> if I was on debian testing ... it was a different thing ..
22:37:26 <Axman6> ok, well, compiling is the way to go then i guess
22:40:00 <scutigera> Axman6: that's why I loaded debian unstable, to get 6.10
22:40:28 <scutigera> Axman6: that turned out to be not-so-great a decision.
22:40:39 <Axman6> yeah, using linux often isn't
22:40:40 <Axman6> >_>
22:40:46 <k23z__> anyone here wanna write a game in Haskell ?
22:40:56 <scutigera> defender
22:41:04 <Jafet> We're too busy playing with Haskell
22:41:09 <copumpkin> scutigera: :)
22:41:11 <scutigera> let's see who the old people are on #haskell
22:41:13 <copumpkin> scutigera: what do you do with matlab?
22:41:47 <scutigera> copumpkin: avoid it. seriously. I'm on the periphery, but it's DSP work.
22:41:56 <copumpkin> ah
22:42:09 <c_wraith> I'm also annoyed that the new version of base added things to the Prelude.  That means I get a warning importing it in 6.12, but it won't compile in 6.10 without that import.
22:42:28 <aavogt> what did it add?
22:42:32 <c_wraith> maybe
22:42:37 <ddarius> scutigera: I've pretty much only worked with voltage feedback op-amps, though I think I have a few current feedback ones.  It would be really nice to work directly at the substrate level though.
22:42:40 <scutigera> copumpkin: and really it's a library thing.  it's the built-ins that are helpful. it's slow and buggy.
22:42:52 <copumpkin> yeah
22:43:12 <scutigera> ddarius: one of these days I'm going to have to get into chips. board level design is just about dead in the usa.
22:43:21 <aavogt> c_wraith: it should be in 6.10 too: http://haskell.org/onlinereport/standard-prelude.html#$vmaybe
22:43:27 <c_wraith> hmmm...
22:43:52 <aavogt> I'm pretty sure I used that function without any imports on 6.10
22:43:53 <c_wraith> aavogt: so it should.  I might just be dumb with regards to this warning
22:43:59 <c_wraith> let me check!
22:44:41 <aavogt> k23z__: have you seen some of the games already written in Haskell?
22:44:56 <k23z__> aavogt: I tried rainycat but didn't really like it
22:45:06 <k23z__> I want to write something that makes heavy use of 3D math ..
22:45:28 <k23z__> .. err , then again maybe just a rolling ball with texture on it which jumps from platform to platform ...
22:45:31 <k23z__> that would be ok for me
22:45:36 <scutigera> copumpkin: I've been able to sim some relatively non-trivial stuff with haskell and it's worked really well.  little hmatrix, little fft. amazingly lists work really well too...
22:45:44 <k23z__> but first I'd like to make a rubik's cube simulation
22:45:48 <copumpkin> cool :)
22:45:50 <scutigera> as opposed to vectors.
22:46:05 <scutigera> I just need to get comonads figured out :-)
22:46:19 <scutigera> co what I mean ?
22:46:59 <dons> k23z__: have you see the 3d rendering engine ?
22:47:03 <scutigera> k23z__: a rubik's cube sim would be very doable and quite fun.
22:47:12 <dons> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org/package&as_q=3D
22:47:25 <dons> http://hackage.haskell.org/package/lambdacube-engine
22:47:48 <k23z__> dons: is there a game written with it ? is it fast/slow ?
22:47:52 <k23z__> scutigera: then maybe we hack on one
22:48:28 <dons> not sure if anything but demos has been written with it. frag is a famous FRP-based 3d game in haskell
22:48:31 <scutigera> dons: lambdacube entirely in haskell ?! do they tell the truth ?
22:49:01 <scutigera> k23z__: I'll leave it as an exercise for the reader ;-0
22:50:03 <quicksilver> jmcarthur: having slept on it, really it's the side condition about lub that worries me
22:50:25 <quicksilver> jmcarthur: so really it's the same problem as unamb
22:50:45 <quicksilver> jmcarthur: it's examples like { computation which takes 1 year to produce the value 4 } `lub` { 3 }
23:01:29 <k23z__> what's package editline used for ? it doesn't build for me although I installed libeditline-dev
23:06:25 <c_wraith> well.  That import of maybe really was redundant.  Ok, one point for 6.12
23:12:57 <dibblego> jmcarthur, you there?
23:25:57 <wvoq> extremely newbish question,: Char is part of the Prelude, right?
23:26:06 <copumpkin> yep
23:26:42 <wvoq> so there would be no reason for chr(228) to return "Variable not in scope: `chr'" ?
23:26:59 <copumpkin> Data.Char
23:27:07 <copumpkin> and the parentheses are redundant
23:27:17 <copumpkin> the Char type is in the prelude, but the chr function is not
23:27:28 <copumpkin> > chr 228
23:27:29 <lambdabot>   '\228'
23:27:47 <wvoq> ok, that clears up a lot
23:27:49 <wvoq> thanks
23:48:59 <ketil> Anybody know the difference between a HLint "error" and a "warning"?  The obvious interpretation doesn't seem to apply...
23:56:53 <copumpkin> preflex: seen mmorrow
23:56:53 <preflex>  mmorrow was last seen on #ghc 29 days, 4 hours, 59 minutes and 8 seconds ago, saying: * mmorrow is rtfm'ing
