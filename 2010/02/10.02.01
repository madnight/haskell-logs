00:01:36 <solrize> do { s <- genStdRandom;  print (random g); print (random g) }
00:01:50 <solrize> do { s <- genStdRandom;  print (random s); print (random s) }
00:01:53 <solrize> still not right
00:02:19 <BMeph> Besides, don't you just need the random numbers to figure out how to scramble the words? Just because I plan on printing the answer to a computation, I don't (usually) feel forced to write the whole program in IO. :)
00:03:12 <solrize> BMeph, the point is that i wanted type level protection against re-using an RNG state.  it turns out there's a setStdRandom function that i didn't know about, that has a back-door way of resetting it
00:03:13 <xerox> solrize ah, another idea, pass in a list of numbers. The top level IO will make a different one every time, but the pure core just uses the numbers.
00:03:22 <BMeph> I'm not trying to be obnoxious, BTW, I just have a natural talent for it... ;)
00:03:42 <solrize> BMeph, i'm interested in hearing other solutions to this
00:03:45 <medfly> being obnoxious?
00:03:47 <solrize> so by all means :)
00:04:11 <solrize> xerox, i'm not sure how that helps, what stops me from re-using the list?
00:04:15 <BMeph> For example, what xerox mentioned; use a list of randoms. :)
00:04:57 <xerox> maybe I didn't read back enough. I thought the problem as having everything in IO because you needed randomness.
00:05:21 <medfly> I wrote this for a friend, sorta.
00:05:27 <medfly> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6544#a6544
00:06:50 <solrize> medfly, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6544#a6545
00:06:52 <dmwit> solrize: You are asking for a linear type system.
00:06:56 <solrize> dmwit, yes
00:07:01 <dmwit> solrize: Which we don't really have.
00:07:03 <dmwit> Unfortunately.
00:07:05 <solrize> the IO monad is the closest that haskell has to that
00:07:08 <solrize> which is why i used it
00:07:16 <ski> hm, are you scrambling words ?
00:07:39 <solrize> ski,  http://rubyquiz.com/quiz76.html
00:07:49 <gio123> ski: hi
00:07:59 <dmwit> solrize: But your objection: "What stops me from re-using the list?" can be translated directly: "What stops me from using a single generated random number many times?"
00:08:06 <dmwit> Nothing, not even in IO, even without setStdGen.
00:08:33 <xerox> I was thinking the same thing. I head -c 100 /dev/ random > /tmp/i-will-reuse-this-you-foolish-kernel
00:08:46 <xerox> */dev/random
00:08:54 <medfly> if I wanted to scramble words it'd be kind of similar. I'd make all the possibilities and choose one randomly.
00:09:17 <xerox> > permutations "scamble" !! 493
00:09:18 <lambdabot>   "bcslame"
00:09:47 <c_wraith> scamble?  Is that some form of gambling scam?
00:10:07 <dmwit> In other words, I find putting everything in IO distasteful on principle, and ineffective at assuaging your complaints... and therefore not a good choice. =)
00:10:27 <xerox> > permutations "scramble" !! 493
00:10:28 <lambdabot>   "mcsbrale"
00:10:30 * dmwit shuts up
00:11:23 <gio123> ski: hi
00:11:38 <solrize> dmwit, re-using a random number not so comparable, if i'm passing it around to other functions, i really do want to re-use it, otherwise i'd generally use it only very close to where i generated it.  but an stdgen can get passed all over the program
00:12:21 <ski> > permute 493 "scramble"
00:12:22 <lambdabot>   "asmrbcle"
00:12:31 <xerox> ?index permute
00:12:32 <lambdabot> Text.ParserCombinators.Parsec.Perm
00:12:38 <xerox> cheat! ;)
00:12:45 <ski> i used my own
00:12:48 <ski> @type L.permute
00:12:49 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
00:13:21 <ski> the natural numbers index every permutation of a finite prefix
00:13:31 <solrize> i wonder whether linear types could be cleanly added to haskell
00:13:48 <ski> map (`permute` "abcd") [0..23]
00:13:52 <ski> > map (`permute` "abcd") [0..23]
00:13:53 <lambdabot>   ["abcd","bacd","acbd","cabd","bcad","cbad","abdc","badc","adbc","dabc","bda...
00:14:11 <ski> > (`map` [0 ..]) $ \i -> zipWith const (permute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
00:14:12 <lambdabot>   ["","ba","acb","cab","bca","cba","abdc","badc","adbc","dabc","bdac","dbac",...
00:14:32 <ski> (that shows only the permuted parts of each list)
00:14:45 <c_wraith> there's an interesting fake you can do with IO for random numbers, assuming you just want a list of calls to the same function
00:14:51 <ski> @type Text.ParserCombinators.Parsec.Perm.permute
00:14:52 <lambdabot> forall tok s st a. (Text.Parsec.Prim.Stream s Identity tok) => Text.Parsec.Perm.StreamPermParser s st a -> Text.Parsec.Prim.Parsec s st a
00:16:15 <ski> xerox : so `permutations' generates all permutations of a particular list ?
00:17:13 <mreh> :t uncurry
00:17:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:17:42 <mreh> :t uncurry (flip curry)
00:17:42 <lambdabot> forall a b c. (a, (a, b) -> c) -> b -> c
00:18:04 <mreh> @djin
00:18:04 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
00:18:18 <mreh> @djinn (a, b) -> (b, a)
00:18:18 <lambdabot> f (a, b) = (b, a)
00:18:22 <mreh> heh
00:18:35 <medfly> @pl f (a, b) = (b, a)
00:18:35 <lambdabot> f = uncurry (flip (,))
00:18:41 <medfly> problem solved.
00:18:42 <mreh> ah yes
00:19:07 <dmwit> :t snd &&& fst
00:19:08 <lambdabot> forall a c. (a, c) -> (c, a)
00:19:08 <mreh> I was almost there
00:19:39 <solrize> medfly, you can write   print . take 50 . map (letters !!) $ ns
00:19:45 <Zao> 250 lines of Setup.hs and counting...
00:19:55 <medfly> OMG!!!!!!!!!!
00:19:57 <Zao> Where should source file generation take place? preBuild?
00:20:17 <Zao> I guess I should split the work between configure and build.
00:20:19 <mreh> what am I going to do with all this Haskell I'm learning?!
00:20:27 <mreh> it's fun for doing my homework
00:20:28 <medfly> mreh, impress chicks
00:20:34 <solrize> mreh, do great good :)
00:20:47 <mreh> why wants to employ me?
00:20:58 <mreh> s/why/who/
00:21:07 <mreh> Freudian slip?
00:21:12 <solrize> heh
00:21:21 <dmwit> Are you *sure* who wants to employ you?
00:21:32 <dmwit> I mean, who doesn't seem like the Haskell type.
00:21:42 <dmwit> more of a baseball type
00:21:44 <mreh> :D
00:21:59 <c_wraith> solrize: I have a neat trick that might amuse you in the works.  Should have it pasted in a few
00:22:06 <solrize> c_wraith, ok
00:22:51 <solrize> i don't even see how to write my shuffling function without randomRIO without messing it up by passing more parameters
00:23:05 <dmwit> ?hackage MonadRandom
00:23:05 <lambdabot> http://hackage.haskell.org/package/MonadRandom
00:24:10 <solrize> dmwit, that looks useful, not quite the whole enchilada but better than nothing
00:25:17 <xerox> ski yes, new Data.List, there's also subsequences
00:25:21 <c_wraith> solrize: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16864#a16864
00:25:55 <ski> ok
00:26:02 <solrize> c_wraith, looking
00:26:05 <xerox> I'm loving it.
00:26:05 <dmwit> c_wraith: cute
00:26:12 <c_wraith> It's a stupid trick. :)
00:26:31 <c_wraith> It requires IO, but it's a way to use it such that your sequence won't get reset
00:26:54 <c_wraith> Of course, you have to set the upper and lower bounds ahead of time, so it's not that useful
00:27:05 <xerox> Also, all sequences will be reset. PRNGs have periods.
00:27:24 <dmwit> c_wraith: range (0,1), take as many bits as you need ;-)
00:27:29 <c_wraith> well, won't be reset by that malicious code your co-worker added. :)
00:27:39 <ski> xerox : my `permute' satisfies `length as <= n && i < product [1..n]  ==>  permute i (take n as) = take n (permute i as)'
00:27:53 <dmwit> What's that quote about Ph.D. studies?
00:27:54 <solrize> wait, "gen" itself is an IO action
00:28:02 <dmwit> solrize: yep
00:28:03 <c_wraith> I don't really recommend using that.  But it's a way to kind of fake linear types, in certain cases.
00:28:03 <solrize> so it can't be passed to pure functions
00:28:12 <ski> so it basically indexes all permutations with "finite support"
00:28:22 <dmwit> solrize: No, in the same way randomRIO can't be passed to pure functions.
00:28:25 <mreh> @src liftM
00:28:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
00:28:40 <mreh> what does that do for lists?
00:28:42 <mreh> fmap?
00:28:45 <c_wraith> yes
00:29:02 <dmwit> "graduate education tends to liberate one from petty concerns about, e.g., the efficiency of hardware-based integers"
00:29:10 <solrize> heh
00:29:12 <xerox> ski more properties more good :)
00:29:19 <temoto> @quot Ph.D.
00:29:20 <lambdabot> No quotes match. stty: unknown mode: doofus
00:29:22 <c_wraith> solrize: my paste was more of a cute trick than a good idea.  I just wanted to point out that you can do sneaky things.
00:29:48 <dmwit> temoto: Don't worry, I found the quote I was looking for. =)
00:29:56 <xerox> dmwit ...moving it to the concerns about the efficiency of hardware-based integrators
00:30:01 <solrize> i'm not sure what that trick really accomplishes that randomRIO doesn't, except protect you from setstdgen
00:30:08 <ski> > const () (randomRIO :: ((),()) -> IO ())
00:30:09 <lambdabot>   No instance for (System.Random.Random ())
00:30:09 <lambdabot>    arising from a use of `System....
00:30:10 <c_wraith> that's the entirety of it.
00:30:14 <ski> .. er ?
00:30:15 <dmwit> solrize: That is exactly what it accomplishes.
00:30:17 <solrize> ic
00:30:19 * ski is shocked !
00:30:24 <ski> > const () (randomRIO :: (Bool,Bool) -> IO Bool)
00:30:28 <lambdabot>   ()
00:30:31 <solrize> well i guess that's useful
00:30:39 <c_wraith> MonadRandom is a better solution to practical problems, I think
00:30:40 <ski> why is there no `Random ()' instance !?
00:30:45 <dmwit> ski: weasel time... that's not a pure function ;-)
00:30:49 <xerox> ski because of dilbert :D
00:30:51 * dmwit jests
00:31:22 <solrize> monadrandom is complicated, but i'll try to figure out how to use it
00:31:28 <xerox> ski http://www.virtualp.us/Dilbert-Oct_25_001.jpg
00:31:48 <xerox> nine = ()
00:31:58 <solrize> heh
00:32:00 <ski> but for `()', there's only one value
00:32:09 <dmwit> solrize: Check the docs for the class, you should recognize the names and types of the MonadRandom class functions.
00:32:12 <dmwit> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.4/doc/html/Control-Monad-Random-Class.html
00:32:32 <ski> i could understand there not being a `Random Void' instance (.. i think) .. but `()' ought to have an instance !
00:32:36 * hackagebot upload: regular 0.2.2 - Generic programming library for regular datatypes. (JosePedroMagalhaes)
00:32:59 <c_wraith> ski: should it change the state of the generator?
00:33:06 <Gracenotes> it would suck living as a (). You're either ()... or the lowest value of all.
00:33:11 <Gracenotes> bottom
00:33:17 <ski> c_wraith : no
00:33:18 <solrize> dmwit, yeah, i looked at the source code too (of the original version linked at the top), which is complicated
00:33:19 <Gracenotes> I'd want to be free to roam, like a graph
00:33:37 <ski> c_wraith : it uses 0 bits of information, so the prng state should stay the same
00:34:27 <Gracenotes> you could be a list and encode other data structures, though
00:34:28 * dmwit sets Gracenotes = Rado graph
00:34:41 <dmwit> The Chuck Norris of graphs.
00:35:02 <c_wraith> I guess I also like my paste because it's such a vivid demonstration that IO values can be passed around as needed, then executed when desired.  There's just something about a return type of IO (IO a)
00:35:04 <xerox> ski there you go http://imgur.com/fmqve.jpg
00:35:29 * ski also wonders why there is no `instance (Random a,Random b) => Random (a,b)' ..
00:35:37 <solrize> xerox, lol
00:35:38 <dmwit> c_wraith: Yeah, I felt proud of using that in my brainfuck interpreter the other day.
00:35:55 <dmwit> http://www.reddit.com/r/programming/comments/aw5lm/black_perl/c0jpid2
00:36:13 <solrize> i used it for something pretty recently, yeah, it was to keep a file open for something
00:36:15 <ski> Gracenotes : you want to be a free graph ?
00:36:20 <dmwit> parse text into an IO action =)
00:36:56 <c_wraith> nice
00:37:04 <solrize> http://en.wikipedia.org/w/index.php?title=Mathematical_logic&diff=318001973&oldid=317905843
00:38:01 <ski> (c_wraith : hm, where was that paste, whereof you were speaking ?)
00:38:36 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16864
00:38:38 <dmwit> ski: ^^
00:40:07 <mreh> weird, it's almost as if GHC derived classes from types that don't explicitly derive them
00:41:04 * ski is reminded of how one can make an `instance Functor IOReadRef'
00:41:31 <ski> (apropos "pure functions returning something doing I/O", i.e.)
00:43:08 <solrize> so how would you generate a random permutation of a list?  i did it a dumb quadratic-time way that would be terrible with a large list
00:43:29 <dmwit> solrize: steal Oleg's code
00:43:55 <dmwit> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
00:44:05 <solrize> thanks, found it already ;)
00:46:00 <c_wraith> Oleg's code is still O(n log n)
00:46:12 <c_wraith> You can do it in O(n) if you use ST
00:47:11 <ski> solrize : you could also use my idea, if you know in advance how long your list is
00:47:15 <solrize> i see, he did his own tree implementation, i had thought of doing something like that with IntSet
00:47:17 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16865#a16865
00:47:22 <solrize> ski, which idea?
00:47:29 <c_wraith> that paste is shuffle in ST
00:47:30 <solrize> finding the nth permutation?
00:47:55 <ski> (with my idea, you just need a random number uniformly distributed between `0' (inclusive) and the factorial of the length of the list (exclusive))
00:47:57 <solrize> c_wraith, yeah, that's another way
00:48:16 <ski> > (`map` [0 ..]) $ \i -> zipWith const (permute i ['a' ..]) (takeWhile (<= i) (scanl (*) 1 [1 ..]))
00:48:17 <lambdabot>   ["","ba","acb","cab","bca","cba","abdc","badc","adbc","dabc","bdac","dbac",...
00:48:19 <solrize> ski, does it use some reasonably fast way to generate the nth permutation?
00:48:27 <solrize> rather than something awful like scan a list?
00:48:27 <ski> solrize : ^ `permute', there
00:48:41 <Gracenotes> ski: that looks.. slow
00:48:54 <medfly> isn't using lists already a bad idea?
00:49:31 <ski> it uses `divMod' on the input index, to compute how to shuffle
00:49:43 <ski> it only traverses the input list once
00:49:54 <solrize> hmm, that's kind of interesting
00:50:03 <solrize> is the code up?
00:50:09 <solrize> from parsec?
00:50:18 <ski> probably it can be improved so as to not traverse as much when inserting the elements
00:50:25 <ski> it's not in Parsec
00:50:31 <solrize> oh
00:51:03 <ski> i've not really tried to optimize it much. i just thought it might be interesting to consider
00:51:09 <ski> i can paste it
00:51:16 <dmwit> (length xs)! seems like it could be largish
00:51:30 <solrize> ok
00:51:36 <ski> dmwit : for a list of length `n', there's `factorial n' possible permutations
00:51:44 <dmwit> yes
00:51:55 <ski> i just index the permutations by natural numbers
00:51:56 <dmwit> (length xs)!, in pseudo-haskell notation
00:52:11 <solrize> yeah, could involve large numbers, maybe there's a way to use a bunch of smaller numbers
00:52:25 <solrize> so i guess i'm wondering how you traverse the list just once
00:52:28 <solrize> unless you're using arrays
00:52:33 <solrize> STArray or the like
00:53:34 <ski> i'm only traversing the input list once, i still do bad traversals on the insertions
00:56:55 <solrize> oh
00:59:44 <ivanm> jinjing: are you responsible for bamboo?
00:59:54 <jinjing> ivanm: yes
01:00:02 <ivanm> someone was looking for you before
01:00:07 <ivanm> lemme go look up who it was
01:00:37 <ivanm> cygnus_: still around? jinjing is here now...
01:01:18 <jinjing> heh
01:01:28 * ski pasted "indexing finite support permutations" at <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=6546>
01:01:34 <ivanm> preflex: seen cygnus_
01:01:34 <preflex>  cygnus_ was last seen on ##logic 5 hours, 28 minutes and 39 seconds ago, saying:  ~P -> ~(R->S) <-> R/\~S -> Q
01:01:40 <ivanm> grrr...
01:01:40 <ski> <ski> i've not really tried to optimize it much. i just thought it might be interesting to consider
01:01:44 * hackagebot upload: multirec 0.4.1 - Generic programming for families of recursive datatypes (JosePedroMagalhaes)
01:01:49 <ivanm> jinjing: anyway, he wants to help you improve the documentation for bamboo
01:02:52 <jinjing> oh, this is embarrassing >< first haskell project kept around, and last till now
01:03:10 <ivanm> heh
01:03:37 <jinjing> it really needs a rewrite
01:05:47 <solrize> ski, what's that type signature in the comment at the top?
01:06:28 <benmachine> it's not a type signature
01:06:41 <benmachine> it's a logical statement
01:06:48 <ski> it's a law `permute' (as well as `invPermute') is supposed to satisfy
01:07:25 <solrize> well ok, but i mean is it in some programming language like coq?
01:07:39 <solrize> so in principle it could be verified?
01:07:41 <ski> my main idea with coding this was to get a way to, uniformly, number the permutations of finite lists
01:08:01 <ski> solrize : hopefully, if i've not made a bug or thinko, somewhere :)
01:08:03 <solrize> yeah it's a natural enough idea, i was just wondering whether that comment was something formal or just a description
01:08:25 <solrize> i guess it could be made into a quickcheck property
01:08:57 <ski> so, if i permute a list `as' with a permutation `i', then if i permute `as ++ as_' with `i', only the first `length as' elements should be permuted, and in the same way as in the first case
01:09:42 <ski> so it really permutes finite prefices of infinite lists .. it just happens to be usable on finite lists, as well :)
01:10:06 <ski> > permute 3 "abc"
01:10:07 <lambdabot>   "cab"
01:10:09 <ski> > permute 3 "ab"
01:10:10 <lambdabot>   "* Exception: {permute _ []}
01:10:12 <ski> > tail (permute 3 "ab")
01:10:13 <lambdabot>   "ab"
01:10:24 <ski> > permute 3 "abcde"
01:10:25 <lambdabot>   "cabde"
01:11:27 <solrize> http://okmij.org/ftp/Haskell/regions.html#light-weight
01:11:42 <solrize> maybe that can wrap a stdgen
01:12:09 <Alpounet> @src permute
01:12:09 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:12:21 <Alpounet> @index permute
01:12:21 <lambdabot> Text.ParserCombinators.Parsec.Perm
01:17:08 <ski> Alpounet : see the above paste
01:19:03 <Alpounet> thanks
01:30:00 * Cyneox re
01:30:39 <adu> hi ski
01:34:37 <ski> ehlo
01:39:00 <Gracenotes> hm... british people say 'torch' for flashlight, don't they
01:40:55 * hackagebot upload: morfette 0.3.1 - A tool for supervised learning of morphology (GrzegorzChrupala)
01:42:46 <osfameron> Gracenotes: yeah.  I think we understand flashlight too though... (not entirely sure)
01:43:44 <osfameron> yeah, I think non-handheld ones especially.  I'd call one mounted on a bicycle helmet a flashlight instead of a torch I think
01:44:20 <Alpounet> and it's "torche" in French heh
01:58:41 <Saizan> "torcia elettrica" in Italian
02:05:04 <benmachine> as a british person I would pretty much never use the word flashlight
02:05:10 <benmachine> although it's fairly common
02:05:18 <medfly> it hurts your pride?
02:05:32 <benmachine> it does not
02:06:07 <benmachine> it is just a thing
02:17:07 <Daerim> Greetings proud people of the haskell channel
02:17:36 <medfly> hello, mortal
02:17:50 <pokoko222> Greetings Human
02:19:09 <Daerim> If I wanted to do something like, say, this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16869 how would I go about it? I can move the recursive call to its own line and all is well, but this notation feels more concise
02:19:51 <medfly> :t getFloat
02:19:52 <lambdabot> Not in scope: `getFloat'
02:20:02 <Daerim> sorry, my bad
02:20:31 <Daerim> getFloat :: Get Float
02:20:35 <Daerim> better?
02:20:48 <ski> @type replicateM  -- Daerim
02:20:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
02:21:12 <ski> you can use that for your particular task
02:21:46 <ski> (however for completeness, instead of `return $ (x:) $ getFloats (n-1)' you probably wanted `liftM (x :) (getFloats (n-1))')
02:22:05 <benmachine> or fmap (x :) (getFloats (n - 1))
02:22:19 <benmachine> or (x :) <$> getFloats (n - 1) if you are being fancy :P
02:22:28 <benmachine> (<$> is in Control.Applicative)
02:23:56 <Daerim> ahh, perfect :) I was trying to do exactly that benmachine, but tried return $ (x :) <$> getFloats (n - 1) and ghci was not happy
02:24:45 <Daerim> now I'll just use replicateM as ski suggested though. One step closer to understanding monads, thanks guys :)
02:30:18 <o-_-o> even Indians say torch for flashlight
02:30:56 <o-_-o> flashlight sounds...unfamiliar, it is like americans saying torch for torch
02:31:40 <medfly> flashlight sounds normal to me
02:31:57 <Daerim> well, you have to admit that blowflashlight sounds fairly silly
02:32:18 <tensorpudding> why would you say something silly like that?
02:33:04 <tensorpudding> torch makes sense in principle, but it's too engrained in me as a flashlight
02:33:13 <Daerim> I'm sorry. I will attempt to keep the conversation to a more serious level from now on
02:33:16 <tensorpudding> flashlights etymology is less obvious
02:33:58 <ski> (benmachine : i often write like  (x :) `liftM` getFloats (n-1)  :))
02:34:02 <tensorpudding> apparently the first flashlights, you flashed them on and off to preserve their horribly miniscule battery life
02:34:18 <medfly> when I think of a torch I think of a large piece of wood burning in one end
02:34:21 <medfly> :)
02:34:47 * ski does that as well
02:35:05 <tensorpudding> torch does evoke the idea of a portable light source
02:35:18 * ski however wonders why there's talk about torches and flashlights in #haskell :)
02:35:28 <ski> (.. not really complaining, just wondering)
02:35:31 <medfly> oh no, someone noticed we're being off-topic!
02:35:32 <Daerim> ski, why is both fmap and liftM provided? They appear to do the same thing, or?
02:35:35 <tensorpudding> oh hey, we're not in blah
02:35:43 * medfly runs 
02:35:49 <tensorpudding> the types are different, liftM is for monads
02:35:57 <ski> Daerim : because `Monad' ought to have `Functor' as a superclass, but it doesn't currently
02:36:19 <medfly> yaay
02:36:25 <medfly> > fmap (+1) (Just 1)
02:36:26 <lambdabot>   Just 2
02:36:42 <xerox> > succ . Just 1
02:36:43 <lambdabot>   Just 2
02:36:51 <medfly> > fmap (+1) [1]
02:36:52 <lambdabot>   [2]
02:36:57 <ski> Daerim : sop if you're writing generic code over any `Monad m', then to avoid getting an auxilary `Functor m' constraint, you currently use `liftM' instead of `fmap' (or `(<$>)')
02:37:02 <ski> s/sop/so/
02:37:08 <RayNbow> :t (.)
02:37:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:37:14 <medfly> it's Caleskell
02:37:35 <ski> if you're in some concrete monad, that already is in `Functor', you can use `fmap' or `(<$>)', if you prefer
02:38:14 <Daerim> I see
02:38:20 <ski> Daerim : but yes, `liftM' should do the same as `fmap' (and `(<$>)') for any `Monad m' (otherwise, someone screwed up, somewhere)
02:38:45 <medfly> monads are functors?
02:38:50 <undone> lambda calculus- related question (pointers to literature welcome): how can one represent iteration in terms of rec. operator. Or else, what makes a recursion operator simulate induction?
02:39:02 <ski> medfly : yes, every monad is a functor
02:39:08 <medfly> okay, I think I get monads then.
02:39:14 <medfly> ;)
02:39:38 <ski> def : a monad is a functor, together with two natural transformations ... satisfying ...
02:39:54 <ski> (is the category theoretical definition)
02:40:00 <RayNbow> :t (Control.Category..)
02:40:01 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
02:40:08 <RayNbow> :t (Control.Category..) succ Just 1
02:40:09 <lambdabot> forall a. (Enum (Maybe a), Num a) => Maybe a
02:40:20 <xerox> (the dots in ski's def are the natural transformations and the axioms looked at a discance)
02:40:22 <RayNbow> aww
02:40:30 <RayNbow> that won't work
02:41:40 <medfly> In category theory, a monad or triple is an (endo-)functor, together with two associated natural transformations.
02:41:41 <medfly> :]
02:41:48 <medfly> okay, thanks.
02:48:25 * ski wants the term "triple" to be banished
02:48:42 <medfly> what is the logic in calling it triple?
02:48:48 <medfly> because of the two operations?
02:48:55 <dobblego> @instances MonadReader
02:48:55 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
02:48:57 <medfly> transformations
02:49:05 <medfly> I'd make a poor mathematician
02:49:20 <ski> medfly : yes, `(T,eta,mu)' a triple of a functor and two natural transformations
02:49:24 <ski> very silly naming
02:50:09 <ski> (of course, /me thinks it's a sixtuple including also the proofs of the three laws)
03:13:10 <ksf> Why don't we have a haskell journal?
03:13:39 <medfly> how very nerdy. to keep even more people frmo thinking it's a real world language. :)
03:13:58 * medfly made that as a joke, by the way
03:14:08 <flux> ksf, you mean Monad.Reader?
03:14:24 <ksf> yes, but different
03:14:31 <temoto> ksf, haskell journal?
03:14:38 <ksf> more open access based
03:15:03 <ksf> actually, just a list of all papers relevant and a voting system
03:15:26 <ksf> ...where the voting system is weightened, because e.g. conal is far more qualified than me judging a paper.
03:15:39 <temoto> By the way, is there a "haskell used in these big projects" page?
03:16:05 <temoto> ksf, isn't acme doing that?
03:16:06 <medfly> there's http://www.haskell.org/haskellwiki/Haskell_in_industry no?
03:16:06 <ziman> there's "haskell in industry" somewhere on the wiki
03:16:20 <ksf> who or what is acme?
03:16:36 <temoto> medfly, thanks, that's what i looked for.
03:16:41 <medfly> :)
03:17:09 <temoto> ksf, you know many times you search for some paper and then it's found on that something.acme.something.com and you have to pay to read it.
03:17:27 <ksf> ah you mean acm
03:17:32 <ksf> acm is evil
03:17:58 <temoto> And then i guess it must be a recognizable name, because i've seen boxes with label ACME in cartoons.
03:18:18 <medfly> he said it's ACM though
03:18:50 <ksf> http://en.wikipedia.org/wiki/Acme_Corporation
03:18:54 <medfly> http://en.wikipedia.org/wiki/Acme_Corporation :)
03:18:55 <medfly> heh
03:18:58 <temoto> ksf, acm is evil because of pay-per-read?
03:19:44 <ksf> http://en.wikipedia.org/wiki/Association_for_Computing_Machinery
03:19:46 <temoto> Thanks for that link, great.
03:20:06 <ksf> well they're not open access
03:20:10 <ksf> ...that makes them evil
03:20:48 <ksf> although other companies making other journals for other scientific fields are said to be even more evil
03:20:53 <Daerim> that goes for practically all journals. If it ain't on arkivx, it ain't free
03:21:41 <ksf> there's often mirrors on university servers
03:21:51 <ksf> ...google scholar is your friend
03:22:04 <Daerim> indeed
03:22:43 <Daerim> until google decides it's time to start charging ofcourse :p
03:24:10 <theorbtwo> Funny.  I always thought that Acme was a dig at the employer of a hated son-in-law, but wikipedia has no mention of that -- even on the talk page.
03:24:20 <ksf> ...so what we could do is basically throw all our links to papers into a pot, vote on them, and regularily release an journal issue containing the top ones
03:25:11 <xerox> and then CS ends when the sequence reaches a fixed point
03:25:21 <temoto> Doesn't acm pay to paper authors as well? I thought that's the whole point.
03:25:41 <mreh> @src scanl
03:25:41 <lambdabot> scanl f q ls = q : case ls of
03:25:41 <lambdabot>     []   -> []
03:25:41 <lambdabot>     x:xs -> scanl f (f q x) xs
03:26:26 <medfly> Daerim, sure, google will do that after free access made them a company worth $28 bn ;)
03:26:51 <ksf> temoto, nope.
03:27:05 <ksf> you pay to publish, and get nothing if you review
03:27:11 <ksf> they do conferences, though.
03:27:42 <temoto> Oh that's bad then.
03:27:46 <ksf> ...at least paying to publish is how it works for most journals
03:28:00 <ksf> it could be free, but they're definitely not giving you anything
03:28:33 <temoto> I understand pay to publish, but then you should receive part of charges for reading.
03:28:35 <ksf> the whole system stems from a time where dead tree journals were the way to do science
03:28:36 <Daerim> paying to publish isn't common afaik
03:29:20 <ksf> ...and it's held in shape by academic accredition
03:29:33 <temoto> BTW i've seen some package on hackage which parses haskell source.
03:29:35 <ksf> "publish in journal xyz and be eligable for a lecturate"
03:29:48 <temoto> something like haskell-src-tools
03:29:52 <ksf> haskell-src-exts?
03:29:56 <temoto> Yeah.
03:30:11 <temoto> ksf, seen it?
03:30:12 <mreh> @src scanr
03:30:12 <lambdabot> scanr _ q0 []     =  [q0]
03:30:13 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
03:30:13 <lambdabot>     where qs@(q:_) = scanr f q0 xs
03:30:38 <ksf> it's one of the most used haskell parsers
03:30:54 <temoto> ksf, can you judge it?
03:31:23 <ksf> I've heard it has the one or other weakness, but generally it's considered to be quite good
03:31:31 <temoto> Thanks.
03:31:36 <ksf> depends, of course, on what you want to do
03:31:55 <ksf> if it doesnt' do what you want, have a look at ghc's or yhc's parser
03:32:22 <temoto> Nah i don't have a particular task, just researching around.
03:32:36 <ksf> I thikn for most cases using TH is more appropriate
03:32:48 <temoto> I'm not familiar with TH yet.
03:34:02 <ksf> does anyone have an alioth account and/or ghc 6.10.4 installed to test my code?
03:34:45 <temoto> ksf, i have latter.
03:35:31 <halo> hey if ur a programmer/coder/cracker then check out my setup @ irc.6667.eu (ssl available) #spyd0r were looking to expand our team
03:36:31 --- mode: ChanServ set +o Saizan
03:36:37 --- mode: Saizan set +b *!*weed@*.dnsprincipal.com
03:36:38 --- kick: halo was kicked by Saizan (halo)
03:36:46 --- mode: Saizan set -o Saizan
03:36:51 <ksf> strange, the faq doesnt' mention how to submit multiple source files, anymore.
03:36:53 <Alpounet> ~weed@ ...
03:37:57 * pastorn is staying at home this morning watching shit on his computer
03:38:11 <pastorn> whoops... --> #haskell-blah
03:38:36 <temoto> ksf, gist.github.com :)
03:39:42 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16870#a16870
03:40:11 <ksf> oh that's cool
03:42:13 <ksf> http://gist.github.com/291629
03:42:32 <ksf> performance patches welcome, of course.
03:42:33 <temoto> Please participate in brainstorm for project name. Strongly typed python. Haskell program will check and transform python with some type annotations to plain python source.
03:42:56 <Eelis> temoto: pytyped
03:43:12 <ksf> temoto, bcwv8m
03:43:20 <ksf> short for buggy car with v8 motor
03:43:38 <temoto> ksf, what? :)
03:43:42 <zygoloid> tpyed?
03:44:05 <temoto> I thought about strongthon, not sure it makes sense in english.
03:44:27 <ksf> sounds like a heavy-duty thong
03:44:37 <Alpounet> temoto, anaconda ?
03:44:38 <temoto> Yeah that's what i was afraid of.
03:45:00 <temoto> Alpounet, oh boy :) that's a strong snake for sure :)
03:45:01 <Daerim> hython?
03:45:14 <tavelram> :t (-)
03:45:15 <lambdabot> forall a. (Num a) => a -> a -> a
03:45:26 <tensorpudding> herl sounds like a pleasant language
03:45:31 <Alpounet> yup
03:45:35 <tavelram> :t (-4)
03:45:36 <lambdabot> forall a. (Num a) => a
03:45:39 <temoto> (-) :: (Num a) => a -> a -> a
03:45:47 <solrize> might as well ditch python semantics too
03:46:12 <solrize> herl (hûrl). n. 1. The barb of a feather used in trimming an artificial fly for angling. 2. A fishing fly made with this type of barb. .
03:47:09 <tavelram> :t (+4)
03:47:10 <lambdabot> forall a. (Num a) => a -> a
03:47:16 <temoto> Anaconda sounds great because it's meaningful, but python is not after snake, it was after comedy show.
03:47:29 <Alpounet> temoto, PythonT ?
03:47:35 <Alpounet> much harder to understand though
03:47:53 <solrize> so call it knight, after saturday knight live ;)
03:48:29 <temoto> Ahah, i've never seen that but sounds good :)
03:49:04 <solrize> PythonT  lol
03:49:05 <zygoloid> temoto: MonTy?
03:49:50 <tavelram> > let f x = ((-x)+5) in f 4
03:49:51 <lambdabot>   1
03:49:59 <tavelram> > let f x = ((-x)+5) in f (-4)
03:50:00 <lambdabot>   9
03:51:12 <tavelram> the odd thing is that java has the unary operator (-) (and unary + as well), and their semantics is the odd that it forces that signess, ie -x will always evaluate to a negative value, no matter what x is.
03:51:40 <ksf> ...and I'm wondering whether the C guys have faster lookup with their scheme: http://shootout.alioth.debian.org/u64q/program.php?test=fasta&lang=gcc&id=3
03:52:02 <zygoloid> tavelram: surely not! that'd be insane
03:52:13 <tavelram> zygoloid, surely you should check the spec :p
03:52:16 <tavelram> it is that insane.
03:52:18 <temoto> To sum up, we have pytyped, tpyed, hython, pythont, knight, monty.
03:52:23 <ksf> ...they're indexing an expanded array, while I've got a binary tree laid out as code
03:52:46 <tavelram> zygoloid, unary + does the same as well :p
03:52:47 <temoto> ksf, about bcwv8m, i just realized, that's how Node.js ought to be named. :)
03:52:48 <solrize> piton (python for high altitudes)
03:52:53 <tensorpudding> tpyed looks like a typo, probably not a good idea
03:53:04 <solrize> tpyo  hey i like that ;)
03:53:47 <temoto> solrize, how is it pronounced?
03:53:49 <Alpounet> bython, for boosted python
03:53:59 <Alpounet> or eyton, for enhanced python
03:54:00 <dang`r`us> boost::python actually exists
03:54:03 <solrize> tpyo?  like t'pao from star trek ;)
03:54:04 <temoto> Alpounet, lol, that would be very funny in russian.
03:54:19 <Alpounet> temoto, which one ?
03:54:23 <tavelram> zygoloid, um, now i cant find it though :p
03:54:39 <zygoloid> tavelram: http://java.sun.com/docs/books/jls/second_edition/html/expressions.doc.html 15.15.4 contradicts you here :)
03:54:41 <temoto> Alpounet, bython. Because that's russian pronounciation for "concrete".
03:54:57 <mreh> how can I force evaluation with do-notation?
03:54:59 <Alpounet> heh
03:55:23 <ksf> mreh, with seq?
03:55:33 <temoto> Alpounet, but we have [biton], not [baiton].
03:55:33 <ivanm> temoto: well, not really with the h there
03:55:36 <mreh> ksf: ahh seq
03:55:43 <ksf> also, by making >>= strict
03:55:52 <ivanm> isn't it more like beton ?
03:56:04 <mreh> ah good, IO is stricts
03:56:09 <mreh> strict*
03:56:23 <tavelram> zygoloid, thank god for that! :p
03:56:35 <temoto> ivanm, yup, accent matters.
03:56:57 <tensorpudding> бетон?
03:57:06 <temoto> Yup.
03:57:18 <temoto> I like this name :)
03:57:33 <tensorpudding> that isn't really like bython
03:58:18 <temoto> Yeah, it could be beathon, not sure how to explain it.
03:58:31 <tavelram> zygoloid, as insane as it would be, im a bit curious about what proofs i was given when i was being convinced about it...
03:59:01 <Daerim> what about Lyresnake? Latin name is Trimorphodon Lambda
03:59:12 <tavelram> zygoloid, but i find it a bit amusing that you actually looked it up rather than screaming troll or something ;)
04:02:08 <dang`r`us> 42
04:02:13 <dang`r`us> oops
04:05:25 <temoto> ivanm, do you have livejournal blog?
04:06:48 <Dressguard> is there an archive for #haskell?
04:07:09 <quicksilver> yes
04:07:11 <quicksilver> in the topic
04:07:39 <temoto> ksf, how to test your fasta program?
04:07:49 <Dressguard> Thanks! Couldn't be any easier!
04:09:02 <temoto> Logs are usually announced in topic.
04:17:17 <Alpounet> has anybody ever used the flymake-mode for Haskell ?
04:17:19 <Alpounet> (in emacs)
04:20:42 * hackagebot upload: threadscope 0.1.1 - A graphical thread profiler. (SatnamSingh)
04:24:25 <ivanm> @hoogle foldrM
04:24:25 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
04:25:21 <temoto> We just tested, java correctly does -x.
04:26:13 <ivanm> temoto: no; why should I?
04:26:34 <temoto> ivanm, your nickname sounds familiar.
04:26:41 <ivanm> ...
04:26:51 <ivanm> AFAIK, I only really use it here
04:27:09 <ivanm> since it's taken everywhere else I wanted to use it (or I used an alternate form before I thought of this one)
04:28:33 <mreh> :t (/)
04:28:34 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:28:43 <mreh> > 1 / 2
04:28:44 <lambdabot>   0.5
04:31:07 <temoto> mreh, `div` for integrals.
04:31:32 <mreh> temoto: I want Fractions thanks :)
04:32:41 <Daerim> bah! I finally manged to parse a binary file, and write it out as ascii using bytestring, and it's 50% slower than the python implementation :S
04:32:51 <ivanm> mreh: you mean Ratio a ?
04:33:02 <ivanm> Daerim: how are you parsing it?
04:33:11 <tumult> Daerim: show code?
04:33:16 <mreh> ivanm: I just want to divide two integers and get a decimal approximation
04:33:23 <Daerim> ivanm, Data.Binary
04:33:31 <Axman6> show code
04:33:42 <Axman6> Data.Binary is usually _fast_
04:33:48 <ivanm> > fromIntegral 1 / fromIntegral 2
04:33:49 <lambdabot>   0.5
04:33:50 <ivanm> mreh: ^^
04:33:57 <ivanm> hey Axman6
04:34:00 <Axman6> o/
04:34:03 <tumult> yeah i just used Data.Binary in my last project and it's much faster than the algorithms i thought up to actually process the data
04:34:06 <temoto> Daerim, yup, string handling is downside of haskell and erlang.
04:34:20 <Axman6> temoto: eh?
04:34:28 <Twey> > (on (/) fromIntegral) 1 2
04:34:28 <ivanm> temoto: wtf?
04:34:29 <lambdabot>   0.5
04:34:31 <temoto> Axman6, i mean String.
04:34:35 <ivanm> the string handling in Haskell is _great_
04:34:40 <ivanm> since you can do list stuff with it
04:34:43 <temoto> I mean speed.
04:34:44 <mreh> how many months would you expect a graduate to get a really good grasp of haskell?
04:34:46 <ivanm> Twey: show off
04:34:50 <Twey> :þ
04:34:51 <mreh> that's a silly question
04:34:55 <ivanm> mreh: your question doesn't make sense
04:34:56 <Daerim> tumult, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16871
04:35:10 <ivanm> temoto: *shrug*
04:35:45 <mreh> ivanm: clearly you need a really good foundation in the algorithms/idioms/and also some of the libraries
04:35:45 <Daerim> I think it's the writing of the data that's causing grief, I'm just not sure how I would do it faster
04:35:52 <Axman6> Daerim: damn man, that's a huge datatype
04:36:04 <ivanm> mreh: no, I meant grammatically
04:36:11 <LeCamarade> Which library has something similar to md5 :: String -> String ?
04:36:16 <LeCamarade> ?hoogle md5
04:36:17 <lambdabot> Network.Browser AlgMD5 :: Algorithm
04:36:17 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
04:36:17 <lambdabot> Network.HTTP.Headers HdrContentMD5 :: HeaderName
04:36:20 <Daerim> Axman6, well, it's the header of the file I'm parsing.... seemed reasonable at the time
04:36:27 <ivanm> LeCamarade: look under crypto on hackage?
04:36:30 <voidprayer> latest ghc documentation gives the information that "Making Haskell libraries into DLLs doesn't work on Windows at the moment". is it still the case in ghc-6.12.1
04:36:31 <voidprayer> ?
04:36:34 <ivanm> there's the SHA library...
04:36:48 <LeCamarade> Yeah, I see lots of SHA, but little MD5.
04:36:51 <kamatsu> LeCamarade: do you specifically need MD5? SHA1 is a better hash
04:36:52 <mreh> ivanm: you are a natural language processor.. you can work it out
04:36:57 <tumult>                 _showData (x,y,z) = (show px) ++ " " ++ (show py) ++
04:36:57 <tumult>                                   " " ++ show (pz) ++ " " ++ (show (a!(x,y,z))) ++ "\t"
04:36:59 <Axman6> voidprayer: only 6.12 uses DLL's afaik
04:37:01 <LeCamarade> Working on a Facebook lib in Haskell, and it requires MD5.
04:37:02 <tumult> that's probably the slow part :)
04:37:05 <ivanm> mreh: that's the problem; I can think of several possible parsings
04:37:08 <temoto> LeCamarade, maybe hsopenssl. It has only crypto interface, no sockets, but that's what you need.
04:37:22 <kamatsu> LeCamarade: Eck, I did facebook dev in ruby.. facebook api is terrible
04:37:25 <ivanm> tumult: *shudder* yeah, that looks fugly
04:37:43 <tumult> Daerim: normal "Show" is pretty slow since it's just naive string appending.. look at ShowS
04:37:50 <Axman6> Daerim: you ne3ed to provile things before saying what it is that's slow btw
04:38:20 <tumult> though for quick stuff, Show is more convenient
04:38:22 <LeCamarade> It's terrible; I wonder how the type system lets me go on! Even with type names having the string "Facebook" in them.
04:38:26 <mreh> ivanm: I want to know if I should apply for a haskell job seeing as I am masters student with about a years experience in industry :)
04:38:31 <tumult> but if you get any kind of bottleneck, best to look at ShowS or something like that
04:38:42 <LeCamarade> (That should be hardcoded into the compiler as a fatal error. No FB!)
04:39:02 <ivanm> mreh: well, if you think you have the skills they want and you would like to do that job then apply
04:39:15 <ivanm> even if you're not sure if you have the skills you can still apply
04:39:26 <ivanm> the worst that'll happen is that you get extra practice filling out job applications
04:39:35 <ivanm> @slap tumult
04:39:35 * lambdabot moulds tumult into a delicous cookie, and places it in her oven
04:39:46 * mreh eated it
04:39:51 <ivanm> tumult: I am firmly of the opinion that Show and Read should only be used for code representations
04:40:02 <LeCamarade> The MD5s I see are all ByteString; none seems friendly to good old [Char]. Or am I the stubborn one?
04:40:02 <tumult> haha
04:40:14 <mreh> ivanm: how so with read?
04:40:15 <ivanm> after being bitten after having to completely replace the dodged up Show/Read stuff in graphviz :s
04:40:30 <ivanm> mreh: well, first of all, using a proper parsing library is _way_ easier than using Read
04:40:38 <Botje> they should really be Word128 :)
04:40:39 <mreh> ivanm: aye
04:40:49 <ivanm> secondly, it's no good having a Show instance if you can't then get that data back in...
04:41:06 <tumult> if you're just printing out stuff to look at yourself, which is all i usually use it for
04:41:46 <tumult> i've never worked on anything big enough to have The Fear put into me about it
04:42:05 <ivanm> tumult: it's easier to start using good habits then to find your simple little thing is now big and unweildy
04:42:10 <ivanm> don't get into bad habits
04:42:34 <Axman6> Daerim: also, things like 'slength <- getIng; return slength' are just 'getInt'
04:42:40 <tumult> alright then what do you use when you need to trace something :)
04:42:59 <voidprayer> Axman6: thank you.
04:43:45 <Axman6> voidprayer: ?
04:45:31 <voidprayer> Axman6: ahhh, i mean DLL's problem. hehe
04:45:40 <Axman6> oh, right :)
04:46:37 <ivanm> tumult: I usually define trace' a = trace (show a) a
04:46:55 <Axman6> Daerim: also why haven;t you made an instance of Binary for your Detector type?
04:46:59 <tumult> that's what i have yeah
04:47:33 <LeCamarade> Okay, let me ask this question another way:
04:47:48 <LeCamarade> Who has generated the MD5 sig os a string with Haskell?
04:47:55 <LeCamarade> Ever.
04:48:01 <ivanm> grrr..... shouldn't "liftM (fmap (const []))" be a valid definition for something of type IO (Either String ()) ->  IO (Either String [a]) ?
04:48:08 * Axman6 also thinks it's extremely useful to have trace'' s a = trace (s ++ ": " ++ show a) a
04:48:33 <ivanm> Axman6: yeah, I've used that as well
04:48:49 <tumult> i do "Thingy is"`traced`thingy
04:48:52 <Daerim> Axman6, because it's not my detector type, I'm just reading fortran stuff and I need to read it in the right order which I can't do with Binary afaik?
04:49:01 <ivanm> or something stupid like this to ensure a code path is reached: trace "hello!" . foo
04:49:04 <Axman6> then you can do things like: "line 8 annoying bit" `trace''` thing
04:49:11 <tumult> haha yep
04:49:22 <tumult> jinx :)
04:50:15 <Axman6> ivanm: why liftM and fmap?
04:50:19 <Daerim> Axman6, but yes, I should probably profile it. It just seemed curious that the equivalent python code was faster
04:50:19 <Axman6> :t liftIO
04:50:20 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
04:50:22 <Axman6> :t fmap
04:50:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:50:29 <Axman6> :t liftM
04:50:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:50:42 <ivanm> Axman6: well, I could use fmap twice, but I prefer using liftM for IO just to emphasise it
04:50:46 <Axman6> Daerim: you don't know that yet really :)
04:50:55 <Axman6> fair enough
04:51:20 <ivanm> grrr.... it wasn't that bit causing the error
04:51:39 <ivanm> it was just that for some reason ghci decided to say that that line had the error when it didn't
04:51:59 <ivanm> I wish that if I had a Left{} :: Either a b, then I can use that also as an Either a c
04:51:59 <tumult> Daerim: they probably aren't equivalent in model, maybe just appearance
04:52:13 <Axman6> LeCamarade: http://web.comlab.ox.ac.uk/people/ian.lynagh/md5/haskell-md5-0.1.0/MD5.lhs
04:53:56 <LeCamarade> Axman6: So ... I'm going to use this until such a time as I can outgrow it.
04:54:16 <Axman6> it would be nice if you had googled your problem first
04:54:28 <Daerim> Axman6, tumult, true that. I suppose it should be "the naive python code compared to the 'relatively' naive haskell" :p
04:54:32 <LeCamarade> It is quite worrying that there is nothing like makeMD5 :: String -> String for Haskell.
04:54:34 <LeCamarade> Axman6: I did.
04:54:53 <Axman6> LeCamarade: there is! look at the code i showed you
04:55:00 <tumult> Daerim: yes :) usually naive stuff in haskell is not too slow.. show and String appending are probably pretty high on the list for performance gotchas
04:55:04 <Axman6> all i did was google 'md5 haskell'
04:55:13 <LeCamarade> Axman6: I know, I see it now. But I can't find it in Cabal.
04:55:39 <Axman6> use hayoo to search hackage
04:55:47 <LeCamarade> Since I use this stuff for production, I wanted a lib thing.
04:55:47 <tumult> Daerim: naive stuff in python tends to run pretty good since python is generall a straightforward imperative language and it has a pretty good implementation
04:55:56 <ivanm> http://www.holumbus.org/hayoo/hayoo.html?query=md5
04:56:02 <ivanm> LeCamarade: ^^
04:56:18 <tumult> though it's easier to hit the upper limit with python, especially in threaded stuff
04:56:27 <LeCamarade> So, not cabal list md5 ?
04:56:28 <zygoloid> @type let unsafeAssumeLeft (Left a) = a in unsafeAssumeLeft
04:56:28 <ivanm> in particular, http://hackage.haskell.org/packages/archive/flickr/latest/doc/html/Util-MD5.html#v:md5sumStr
04:56:29 <lambdabot> forall t t1. Either t t1 -> t
04:56:32 <Axman6> LeCamarade: be warned that the code is GPL licenced
04:56:36 <zygoloid> @type let unsafeAssumeLeft (Left a) = Left a in unsafeAssumeLeft
04:56:37 <lambdabot> forall t t1 b. Either t t1 -> Either t b
04:56:37 <ivanm> LeCamarade: hackage > cabal list
04:56:49 <ivanm> LeCamarade: "cabal list" assumes the package name contains md5
04:57:15 <voker57> never ever use md5sumStr
04:57:21 <temoto> How does stython sounds?
04:57:34 <voker57> String is unicode, and this function truncates non-ascii chars
04:57:34 <ivanm> for what?
04:57:35 <zygoloid> stifling?
04:57:43 <LeCamarade> I thought it was a fair assumption.
04:57:49 <LeCamarade> Especially since I got two.
04:57:51 <LeCamarade> Oh, well.
04:57:55 <zygoloid> @wn stifle
04:57:57 <lambdabot> *** "stifle" wn "WordNet (r) 2.0"
04:57:57 <lambdabot> stifle
04:57:57 <lambdabot>      n : joint between the femur and tibia in a quadruped;
04:57:57 <lambdabot>          corresponds to the human knee [syn: {knee}]
04:57:57 <lambdabot>      v 1: conceal or hide; "smother a yawn"; "muffle one's anger";
04:57:59 <lambdabot> [9 @more lines]
04:58:29 <ivanm> LeCamarade: this seems to be a library version of the link Axman6 gave you: http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/Data-Hash-MD5.html
04:59:01 <ivanm> LeCamarade: so you just want md5s . Str
04:59:06 <ivanm> and that's String -> String
04:59:12 <RainCT> Hi
04:59:34 <LeCamarade> ivanm: Yes, Axman6's link was very helpful.
04:59:47 <ivanm> LeCamarade: right; if you want a library on hackage that's part of MissingH
05:01:46 <ivanm> if I close a Handle, am I able to re-open it?
05:02:43 <Axman6> i don't believe so
05:02:51 <kamatsu> @instances MonadState
05:02:52 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
05:02:59 <Axman6> time for you to learn some POSIX my friend :P
05:03:04 <LeCamarade> ivanm: You can't, except by opening the file anew.
05:03:07 <ivanm> neither did I
05:03:09 <ivanm> bugger...
05:03:17 * ivanm blindly charges on to see if he can do this anyway
05:04:12 <RainCT> How can I define a function in ghci? (Eg., if I write "factorial 0 = 1" there it complains with "parse error on input `='")
05:04:28 <Twey> Use let
05:04:48 <Axman6> ivanm: all a file handle is is a number that the OS knows which 'file' it represents. the same number will be used multiple times if you keep opening and closing file handles
05:05:13 <ivanm> Axman6: well, I'm talking about a Handle to a process, not a file...
05:05:25 <Axman6> eh?
05:05:37 <trzkril> ivanm: everything is a file
05:05:37 <ivanm> @hoogle runInteractiveProcess
05:05:38 <lambdabot> No results found
05:05:41 <ivanm> bah
05:05:42 <Axman6> RainCT: let factorial 0 = 1
05:06:44 <jeltsch> When will the next version of the Haskell Platform be released?
05:07:39 <RainCT> Twey, Axman6: Thanks. Now I can declare it but using it results in a stack overflow. Oh well, I guess I should go RTFM :)
05:07:39 <Veinor> what's wrong with 6.12?
05:07:47 <ivanm> Veinor: what do you mean?
05:07:55 <Twey> RainCT: Sounds good ☺
05:08:45 <jeltsch> Veinor: I mean Haskell Platform, not GHC.
05:09:33 <jeltsch> Veinor: Nothing wrong with the current version. It’s just that I want to know whether it’s reasonable to install the current version now when it’s not needed before April.
05:10:03 <doserj> jeltsch: http://projects.haskell.org/pipermail/haskell-platform/2010-January/000841.html
05:10:17 <mreh> > 1 `div` (1 % 2)
05:10:18 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
05:10:18 <lambdabot>    arising from a us...
05:10:37 <mreh> > 1 / (1 % 2)
05:10:38 <lambdabot>   2 % 1
05:10:53 <Twey> > div 1 $ mod 1 2
05:10:53 <mreh> :t (/)
05:10:54 <lambdabot>   1
05:10:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
05:10:55 <ivanm> jeltsch: if you don't write a lot of libraries, etc. then you don't have to worry about 6.12 yet
05:10:56 <benmachine> jeltsch: I think the platform is in the process of being updated for GHC 6.12 but I don't know how much longer it will take
05:11:01 <Twey> mreh:
05:11:04 <Twey> :t (%)
05:11:05 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
05:11:13 <Twey> % is not modulation
05:11:24 <mreh> Twey: I know :)
05:11:33 <mreh> I wanted to invert a Rational
05:11:46 <Twey> Ah
05:11:59 <Twey> > (1 % 2) ^ negate 1
05:12:00 <lambdabot>   * Exception: Negative exponent
05:12:00 <jeltsch> We need Haskell for a student course starting at April.
05:12:07 <Twey> Well that sucks
05:12:17 <Twey> No negative exponents at all?
05:12:25 <Twey> > 5 ^ negate 1
05:12:26 <lambdabot>   * Exception: Negative exponent
05:12:28 <jeltsch> If the platform is really released on March 21, we could install the new version.
05:12:30 <benmachine> Twey: there are about four different exponentials
05:12:31 <Twey> Hmph
05:12:34 <benmachine> > 5 ^^ negate 1
05:12:35 <lambdabot>   0.2
05:12:39 <Twey> Oh
05:12:47 <ivanm> jeltsch: I'd stick with 6.10
05:12:47 <Twey> :t (^^)
05:12:48 <benmachine> well, three is about four, right?
05:12:48 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
05:12:52 <Twey> I never knew
05:12:54 <ivanm> since there might not be full installers, etc. yet for all platforms
05:12:55 <Twey> What's the third?
05:12:59 <benmachine> :t (**)
05:12:59 <jeltsch> ivanm: I think this will be better.
05:13:00 <lambdabot> forall a. (Floating a) => a -> a -> a
05:13:04 <Twey> Aha
05:13:05 <jeltsch> Thank you all.
05:13:10 <ivanm> no worries
05:13:11 <Twey> :t (^)
05:13:12 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:13:13 <doserj> (^), (^^), (**), exp
05:13:16 <Twey> Crazy.
05:13:22 <benmachine> it kind of makes sense
05:13:37 <ivanm> grrr.... how the hell am I meant to find the cause of "cannot construct the infinite type" error? :s
05:13:40 <Twey> > 5 ^^ negate 1
05:13:41 <lambdabot>   0.2
05:13:48 <Twey> > (1 % 2) ^^ negate 1
05:13:49 <lambdabot>   2 % 1
05:13:54 <Twey> Oh well
05:14:00 <benmachine> ivanm: you could try splitting subexpressions into a let or where, might narrow it down
05:14:12 <Twey> ivanm: Give things more types
05:14:20 <ivanm> maybe :s
05:14:49 <ivanm> how do I give a type to something I use <- to get?
05:14:56 <mreh> feed me types
05:14:57 <ivanm> (a :: Foo) <- ... throws an error :s
05:15:00 <benmachine> either give it a type where it is used
05:15:05 <benmachine> or type the RHS appropriately
05:15:08 <ivanm> oh, nvm
05:15:11 <ivanm> I think I worked it out
05:15:15 <mreh> ivan: there's a switch for that
05:15:19 <mreh> ivanm: there's a switch for that
05:15:21 <benmachine> ScopedTypeVariables?
05:15:24 <Zao> Is it possible to add more exposed-modules to a cabal package from Setup.hs, or must the set of exposed modules be fixed beforehand?
05:15:31 <mreh> that's the one
05:16:28 <ivanm> OK, so what does this mean? A pattern type signature cannot bind scoped type variables `a' unless the pattern has a rigid type context
05:16:38 <ivanm> Zao: fixed in the cabal file AFAIK
05:19:11 <ivanm> gah, think I know the problem now
05:19:22 <Daerim> tumult, would you replace all the bytestring stuff in "showData" with shows? I did a profiling run, and 97% of the time was spent in showData, presumably messing with lists
05:20:48 <tumult> yeah it is probably spending all of its time traversing/rebuilding lists for the append operations
05:20:49 <temoto> [more about that statically typed python] how do you find P#?
05:20:53 <tumult> would be my guess
05:21:40 <mreh> > recip (1 % 2)
05:21:41 <lambdabot>   2 % 1
05:21:47 <mreh> 0/
05:22:17 <Axman6> > iterate (recip . (+1)) 1
05:22:18 * mreh waiting for hi-5
05:22:19 <lambdabot>   [1.0,0.5,0.6666666666666666,0.6000000000000001,0.625,0.6153846153846154,0.6...
05:22:35 <mreh> what?!
05:22:52 <tumult> Daerim: if you're just printing it out in the console then shows is ok i guess.. if you're actually using it for something else, like writing to a file, it's best to use whatever stuff you need for that directly rather than break it into Strings first
05:23:00 <ivanm> *groan* OK, is there a way of using asTypeOf when I want to state that `a' has the same type as an individual value in a list of values `as'?
05:23:23 <tumult> Daerim: for writing out, bytestrings can be used directly and would be a LOT faster than showing as text and then writing that
05:25:52 <Zao> ivanm: Maybe you can set up a typeclass IsWrappedIn a (m a) ?
05:26:00 <ivanm> nvm, it was my stupid fault again
05:26:05 <Zao> Which should generalize past lists, if you like that kind of thing?
05:26:25 <mreh> > iterate recip (1%2)
05:26:26 <lambdabot>   [1 % 2,2 % 1,1 % 2,2 % 1,1 % 2,2 % 1,1 % 2,2 % 1,1 % 2,2 % 1,1 % 2,2 % 1,1 ...
05:26:30 <Daerim> tumult, rewrote using shows which didn't change anythin really. Hardcoding into bytestrings then?
05:26:41 <Daerim> tumult, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16872
05:26:49 <tumult> Daerim: well you have to make sur eyou're using shows correctly
05:27:01 <tumult> Daerim: the reason show is the default and not shows for quick stuff is that it's easier to use
05:27:06 <tumult> (afaik)
05:27:13 <ivanm> I _hate_ the discarded result warnings in 6.12
05:28:25 <Twey> Hear hear
05:28:39 <Axman6> > iterate (recip . (+1)) (1%1)
05:28:40 <lambdabot>   [1 % 1,1 % 2,2 % 3,3 % 5,5 % 8,8 % 13,13 % 21,21 % 34,34 % 55,55 % 89,89 % ...
05:28:50 <ivanm> which smart ass thought it would be a great idea?
05:28:54 <Axman6> woah.... fibonacci :O
05:29:03 <ivanm> otherwise, what's the point of the >> desugaring in do blocks?
05:29:46 <Axman6> ivanm: what's the warning do?
05:30:25 <ivanm> Axman6: if you have a statement in a do block that isn't of type "m ()", then it spits out a warning telling you to do _ <- foo
05:30:32 <int-e> > fix $ (1%1:) . (>>= ap (:) ((:[]) . recip)) . map succ
05:30:33 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
05:30:43 <Axman6> ivanm: ... yeah, that's not nice
05:31:12 <tumult> ivanm: omg what really :(
05:31:16 <tumult> that's like.. half of my code
05:31:21 <ivanm> heh
05:31:30 <ivanm> tumult: methinks someone is using do blocks a little too much then...
05:31:48 <tumult> ok SLIGHT exaggeration
05:32:02 <tumult> actually i usually use >> if i have more than one in a row
05:34:36 <Daerim> tumult: here's a laugh: it's faster to use show and ++ than bytestrings or/and shows
05:34:46 <Daerim> for this example anyway ^_^
05:35:23 <tumult> were you munging in and out of bytestrings without needing?
05:35:33 <tumult> (i didn't really read the full code before, sorry)
05:36:22 <ivanm> Daerim: if so, then you're doing it wrong
05:36:25 <mreh> I can't generate Rationals with System.Random, converting from Rational to Double and back again is uglyyyy
05:36:28 <benmachine> ivanm: (bit late but) a `asTypeOf` head as?
05:36:36 <Daerim> tumult, yes I was. I know I know, silly.
05:36:38 <benmachine> (works even if as is empty, of course)
05:36:47 <Daerim> tumult, but even shows alone is slower
05:36:50 <ivanm> benmachine: yeah, worked out that I was accidentally using a function that expected a list of values rather than a single value
05:36:52 <ivanm> :s
05:37:00 <benmachine> oic
05:37:00 <mreh> a generating the reciprocal isn't uniform
05:37:44 <benmachine> mreh: I imagine that you can't generate rationals with System.Random because it sounds like something that's hard to do
05:38:09 <benmachine> can you just choose a very large denominator and then randomly generate numerators in the range 0 .. denominator?
05:38:25 <mreh> benmachine: it's not uniform
05:38:38 <benmachine> it?
05:38:48 <mreh> the distribution
05:38:54 <benmachine> of?
05:38:57 <mreh> of your method
05:39:05 <Daerim> ivanm, yes. discovered that the hard way. Thought it might be faster to pack and write a lazy bytestring than just writing the string directly
05:39:06 <benmachine> how is it not uniform?
05:39:11 <benmachine> it is as uniform as the numerators are
05:39:26 <burp> I vote for not uniform
05:39:32 <mreh> 0/
05:39:46 <burp> hm, or wait
05:39:54 <ivanm> preflex: seen dcoutts
05:39:54 <preflex>  dcoutts was last seen on #haskell 15 hours, 11 minutes and 21 seconds ago, saying: Philonous: that would work
05:40:04 <benmachine> maths is not conducted by democracy :P
05:40:18 <burp> I'm not sure anymore
05:40:31 <mreh> burp: you'll die with the rest then
05:40:48 <benmachine> it's so uniform it hurts
05:40:57 <benmachine> seriously
05:41:03 <benmachine> how much more uniform could you want?
05:41:04 <burp> do we calculate 1 / random of [1..]?
05:41:07 <burp> then it's not uniform
05:41:11 <benmachine> no
05:41:30 <benmachine> we pick n large and calculate random of [1 .. n] / n
05:41:36 <mreh> oooooooooooooooooooooooooh
05:41:39 <burp> ah ok
05:41:42 <benmachine> heh
05:41:48 <benmachine> I don't see any other way of doing it
05:42:10 <benmachine> there probably is one but I am insufficiently clever
05:42:29 <mreh> being clever is hard work
05:42:46 <mreh> feeling clevel is even harder
05:42:59 <mreh> :D~~
05:42:59 <benmachine> feering clevel
05:43:47 <mreh> I feel stupid when there is what appears to be, *a child*, on my masters course
05:44:02 <mreh> might just be a very small woman
05:44:05 <burp> lol
05:44:40 <medfly> yeah because men can't be short
05:45:05 <mreh> *his* testicles haven't descended then
05:46:25 <ivanm> @tell sinelaw nope, my latest attempt (trying to lazily provide one graph at a time and parse the output) also failed; I can't seem to find a way to actually give it the entire first graph and then get the entire output from it :s
05:46:25 <lambdabot> Consider it noted.
05:47:08 <mreh> London HUG haven't done anything in a while
05:48:41 <mreh> is dons "Don Stewart"?
05:48:44 <ivanm> @tell sinelaw it's actually _slower_ to do it that way, even for individual graphs :s
05:48:44 <lambdabot> Consider it noted.
05:49:44 <ddarius> mreh: Yes.
05:49:50 <mreh> I don't suppose he'd know anything about LondonHUG, he'll be home in america
05:49:55 <mreh> tucked up in bed
05:53:34 <medfly> mreh, that's disturbing. do you look at people's groin when you first see them?
05:53:35 <medfly> :)
05:53:58 <ivanm> @tell sinelaw anyway, what's odd is that for small lists, doing it as a group _is_ faster... :s
05:53:59 <lambdabot> Consider it noted.
05:54:12 <mreh> medfly: no. I prefer a full exam
05:56:37 <mreh> this doesn't look like very pure behaviour: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16875#a16875
05:58:50 <Axman6> well, i sense IO occuring
05:59:10 <mreh> > recip 0.1
05:59:11 <lambdabot>   10.0
05:59:14 <mreh> > recip 0.01
05:59:15 <lambdabot>   100.0
05:59:17 <mreh> > recip 0.000001
05:59:18 <lambdabot>   1000000.0
05:59:21 <mreh> > recip 0.0000000000000001
05:59:22 <lambdabot>   1.0e16
05:59:25 <mreh> > recip 0.000000000000000000000001
05:59:25 <lambdabot>   1.0000000000000001e24
05:59:29 <mreh> > recip 0.0000000000000000000000000000000000000000000000000000000001
05:59:30 <lambdabot>   1.0e58
05:59:34 <benmachine> > recip 1e-100
05:59:35 <lambdabot>   1.0e100
05:59:43 <mreh> why does it jump to Infinity?
05:59:49 <benmachine> > recip 1e-1000
05:59:50 <mreh> that's the only thing that could cause that
05:59:50 <lambdabot>   Infinity
05:59:58 <benmachine> > recip 0
05:59:59 <lambdabot>   Infinity
06:00:04 <benmachine> limited precision
06:00:15 <mreh> the inverse of the fitness cannot be zero
06:00:27 <Axman6> > recip 1e-1000 :: CReal
06:00:28 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
06:00:32 <benmachine> but if it's really really small it looks like zero
06:00:54 <benmachine> aren't floating point numbers fun!
06:00:56 <mreh> benmachine: it's the TSDp, it's an integer
06:01:06 <mreh> well, that's not correct
06:01:45 <mreh> the representation my lecturer gave me uses small Reals
06:06:21 <pozic> How can I "eliminate" (x ~ Foo m) from a type-signature?
06:06:53 <benmachine> eliminate?
06:07:03 <Axman6> ^H^H^H^H^H^H^H^H^H^H^H
06:07:06 <Axman6> >_>
06:07:07 <benmachine> heh
06:07:12 <pozic> benmachine: specialize, whatever.
06:07:12 <benmachine> type instance Foo m = x?
06:07:21 <benmachine> no I still don't know what you mean
06:07:23 <benmachine> but maybe that is my fault
06:07:27 <benmachine> so I will stop trying to help :P
06:09:46 <pozic> Simpler question: What does x ~ Foo m mean?
06:09:49 <orbitz> what does x ~ Foo m mean?
06:10:00 <ivanm> pozic: Associated Types, etc. usually AFAIK
06:10:03 <benmachine> it means the two are equal
06:10:28 <pozic> If the two are equal, then why isn't one substituted for the other in the type.
06:11:00 * benmachine shrug
06:11:01 <ivanm> pozic: usually Foo m is an associated type or something for the m type
06:11:08 <ivanm> and you're saying you want that associated type to be x
06:11:49 <benmachine> ivanm: do you have an example of where it might be necessary?
06:11:53 <pozic> Ok, so it is x is an associated type of the type Foo m. Or in other words x is determined by Foo m.
06:12:37 <ivanm> benmachine: you have a class Bar with an associated type alias Foo
06:12:59 <ivanm> you then have a function that only works if for some instance of Bar m has the associated type Foo m being an Int
06:13:12 <benmachine> ah
06:14:00 <ksf> optimize now and earn yourself an eternal place in the shootout's memory! : http://gist.github.com/291629
06:14:06 <Polarina> Is there some good way to implement a timer to do something while the main execution path is doing something else?
06:14:28 <ksf> forkIO?
06:14:30 <ksf> threadDelay?
06:14:34 <Polarina> o.O
06:14:35 <pozic> ksf: you can micro-optimize the ++ away.
06:14:51 <ksf> also, the new event lib
06:15:23 <ksf> Polarina, http://github.com/tibbe/event
06:15:27 <Polarina> ksf, thanks.
06:15:57 <ksf> (although that one is optimized for 10 billion handles and timeouts)
06:16:03 <Polarina> o.O
06:16:21 <Polarina> I was just looking for something for my IRC bot.
06:16:35 <ksf> it's slated to become the new io subsystem in ghc
06:16:45 <pozic> ksf: what does lookupNuc do?
06:17:17 <ksf> lookup one nuclei out of iubs and homs based on propability
06:18:09 <ksf> or, put differently, do a lookup by converting the stuff to a binary tree and then converting it to code
06:18:21 <ksf> that's the reason for half of the TH in there
06:18:50 <ksf> ...the other half is because ghc won't inline lookupNuc by itself, and it's called in a tight loop
06:18:56 <pozic> ksf: what are iubs and homs?
06:19:04 <ksf> they're given
06:19:15 <ksf> something genetics related
06:19:32 <pozic> ksf: ok
06:20:24 <ksf> after being fet through acc, the list is more understandable
06:21:37 <ksf> the c guys just recently commited a version that converts the lists to a 4096 entry lookup table, so elaborate lookup schemes seem to be ok with the shootout guys
06:21:44 <ksf> messing with the randgen, otoh, is not
06:22:22 <benmachine> Polarina: I did an IRC bot, threading is the way to go imo
06:22:30 <benmachine> MVars everywhere
06:22:38 <ksf> ugh
06:22:40 <ksf> tvars
06:22:43 <Polarina> benmachine, can you give me an example on how to use threading properly for this use case?
06:22:56 <ksf> or, in fact, the way haskell-torrent does it
06:23:30 <benmachine> later t a = forkIO (threadDelay t >> a) -- ?
06:23:56 <Polarina> ?
06:24:01 <benmachine> what's the use case
06:24:25 <Polarina> benmachine, could you elaborate?
06:24:35 <benmachine> no, you elaborate :P
06:24:39 <aavogt> you might want to write the result to an MVar you create beforehand
06:24:41 <benmachine> what exactly do you want?
06:24:45 <Polarina> I don't understand that snippet of code.
06:24:50 <Polarina> I got no clue on what it does.
06:24:56 <medfly> ksf, WE GOTTA BEAT THE C GUYS!
06:25:03 <benmachine> oh, it's just a thing that makes a thread which waits for a bit and then does something
06:25:05 <ksf> forkIO forks a thread, threadDelay waits a bit
06:25:14 <Polarina> benmachine, oh, cool.
06:25:22 <Polarina> benmachine, t is seconds?
06:25:22 <medfly> GO TEAM! GO TEAM!
06:25:23 <benmachine> example use: later 1000000 (putStrLn "hi!")
06:25:26 <benmachine> nanoseconds
06:25:26 <medfly> hehehe
06:25:30 <benmachine> or
06:25:33 <benmachine> microseconds
06:25:34 <Polarina> benmachine, NANOSECONDS! YAY! HURRAY!
06:25:36 <benmachine> I forget which :(
06:25:36 <Polarina> Aww. :(
06:25:40 <Polarina> Micro. :(
06:25:47 <ksf> microfortnights
06:25:55 <Polarina> Lightyears?
06:26:04 <benmachine> whichever is the one you have a million of in a second
06:26:12 <aavogt> micro
06:26:14 <Polarina> That's a micro.
06:26:16 <benmachine> heh
06:26:17 <benmachine> k
06:26:23 <Polarina> Nano is 1/1.000.000.000.
06:26:26 <benmachine> mm
06:26:38 <ksf> milli, micro, nano, femto, atto afair
06:26:50 <Polarina> In what package are those functions?
06:26:54 <Polarina> module*
06:26:58 <benmachine> they are in Control.Concurrent
06:26:58 <ksf> @hoogle threadDelay
06:26:59 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
06:27:11 <benmachine> Int is a bit messy here
06:27:32 <benmachine> if you want to wait a very long time, you're going to need to watch for overflow
06:28:04 <Polarina> Only 536 seconds of wait guaranteed by the haskell 98 standard. :(
06:28:25 <Polarina> Is there something else than threadDelay?
06:28:27 <kamatsu> so i'm wondering, is there a doubly linked list for Haskell that works just like the standard list except that "reverse" is O(1)?
06:28:38 <kamatsu> i think it'd be a nice way to do it
06:28:38 <ksf> ...and if you want to do something like forever t a = later t (a >> later t a), you're going to need to keep track of the system clock and adjust the delay, otherwise it's going to drift
06:29:00 <Polarina> ksf, I know, execution delay. :)
06:29:09 <ksf> kamatsu, Data.Sequence?
06:29:18 <Polarina> But it's an IRC bot, not so important. :D
06:29:43 <kamatsu> ksf: looks good
06:29:46 <kamatsu> ksf: thanks
06:29:49 <ksf> doubly-linked lists are fidgety because mutating them means rebuilding the whole spine
06:30:19 <ksf> they're more a curiosity than something useful
06:31:12 <ksf> ...you could, of course, use STRefs to do the updates in-place, but usually a Sequence is just what you want.
06:31:23 <ksf> beware of premature optimization, that is.
06:31:51 <kamatsu> ksf: right, it's just I have a very long list at the moment, and I frequently need to access it from the inconvenient end
06:32:07 <kamatsu> but if I swap the order around, I get other places where it's inconvenient
06:32:25 <kamatsu> the Google Wave code i'm basing this on uses a doubly linked list
06:32:25 <dhun> does anybody know how forgiving HXT is in terms of sloppy html
06:32:36 <kamatsu> so I should probably use a sequence, thanks!
06:34:21 <kamatsu> dhun: probably not very. Tag soup?
06:34:31 <dhun> tag soup!
06:34:40 <dhun> yes that is what I have
06:34:55 <kamatsu> there is a library for dealing with crappy html called tag soup
06:35:03 <kamatsu> i dunno if it's been ported/bound to haskell
06:35:04 <cheater> hello haskell
06:35:09 <cheater> how are you doing
06:35:19 <medfly> it has
06:35:20 <kamatsu> cheater: not bad, and you?
06:35:27 <cheater> i am fine, thank you
06:35:51 <cheater> what's the simplest way to write a web server in haskell?
06:35:53 <dhun> well there is a tool called tidy you can just pipe it through that, seems that will be the way I will go
06:36:04 <kuribas> If I want to install libreadline6-dev on debian, it will uninstall ghc6!
06:36:28 <ksf> we've got tagsoup, and hxt isn't going to be forgiving, at all
06:36:38 <Axman6> cheater: using sockets and parsing things yourself. shouldn't take more than a few lines to get something very basic
06:37:38 <ksf> we do have an error correcting parser, though, uulib
06:38:27 <cheater> Axman6: gotcha. is there some sort of lib for haskell that manages http boilerplates for me?
06:38:41 <ksf> there's a couple of servers
06:38:45 <Axman6> sure, check hackage. there's a few
06:38:48 <ksf> happstack, most notably.
06:38:58 <Axman6> ranging from simple to full web frameworks
06:41:12 <ddarius> The tag soup package is not a port or a binding to the other tag soup library.
06:41:38 <dhun> I did not get what you mean
06:43:23 <ksf> when is 6.12.1 hitting the shootout?
06:44:58 <pozic> Are there any rules in the shootout which prevent people from calculating the exact memory requirements of the problem s.t. the C versions only have to call malloc once?
06:47:08 <ksf> they don't malloc at all, but use memory on the stack
06:47:17 <ksf> ...if you're talking about the fasta entry
06:47:55 <ksf> the program is going to be called with different parameters for the size, that's all
06:48:09 <ksf> output size, that is.
06:50:08 <ksf> could fputs_unlocked be a major performance boost?
06:52:49 <ksf> we don't have anything to influence branch prediction either, do we?
06:53:02 <temoto> ksf, you gave a program fasta to test it on 6.10.4, so it compiled, what do you want to test exactly?
06:53:41 <ksf> how fast it is
06:54:19 <ksf> my machine is relatively old, so it's impossible to properly optimize branch prediction/cache stuff
06:55:26 * hackagebot upload: convertible-text 0.2.0.3 - Typeclasses and instances for converting between types (MichaelSnoyman)
06:55:39 <temoto> ksf, what magnitude of numbers should i give it?
06:56:15 <ksf> big enough to get clear measurements
06:56:37 <ksf> small enough to be done in less than a coffee
06:57:46 <ray> so you shouldn't run it at all, basically
06:57:52 <ray> because no such amount exists
06:58:06 <ray> well, maybe if you drink coffee very slowly
06:58:56 <temoto> ksf, should i pass +RTS or something?
06:59:22 <temoto> (i used -O3 to compile)
06:59:22 <ksf> only if you want to profile
07:00:05 <temoto> time ./fasta 28760090 > /dev/null  gives  real	0m17.282s
07:00:27 * hackagebot upload: data-object 0.2.0.1 - Represent hierachichal structures, called objects in JSON. (MichaelSnoyman)
07:00:33 <ksf> on my system -fvia-C -O2 -optc-O2 -optc-ffast-math -fexcess-precision -funbox-strict-fields -funfolding-use-threshold=40 had the best results
07:02:39 <ksf> temoto, if  http://shootout.alioth.debian.org/u32q/program.php?test=fasta&lang=ghc&id=2   takes 9 times longer, we've won
07:02:49 <ksf> ...or are at least en par with c
07:03:43 <medfly> hehehe
07:03:51 <medfly> WINNING: it's being as good as the C guys
07:07:26 <temoto> Great.
07:07:30 * hackagebot upload: data-object-yaml 0.2.0.1 - Serialize data to and from Yaml files (MichaelSnoyman)
07:11:57 <pozic> ksf: I was not talking about fasta.
07:14:47 <ksf> pozic, requirements change with the benchmark, but all are called with different sizes
07:15:33 <pozic> ksf: but you can compute the final memory use, so any program calling malloc more than once is not going to be optimal.
07:19:19 <ksf> yep.
07:19:49 <ksf> but then, e.g. the hash benchmark has the requirement to start out with a small initial table size
07:22:35 <temoto> Does this fasta program relate to DNA nucleotids?
07:22:45 <Axman6> it does i believe
07:27:36 * hackagebot upload: ls-usb 0.1.0.4 - List USB devices (RoelVanDijk)
07:28:08 <cheater> Axman6: thanks
07:42:42 <lysgaard> What is the optimal Datatype for an image when you want to manipulate it?
07:43:11 <kamatsu> lysgaard: what sort of image? a raster image?
07:44:23 <lysgaard> kamatsu: Yeah, bitmap
07:44:35 <kamatsu> you just named your data structure
07:45:46 <lysgaard> kamatsu: It's the most efficient one?
07:46:46 <dmwit> No, of course something so simple isn't the most efficient.
07:47:10 <ksf> might depend on manipulation, but in general your vanilla rgb array is the most efficient
07:47:50 <dmwit> If you want to do anything truly serious, you'll learn about textures that your GPU can mess with or about GEGL's lazy chunk-map/filter combination.
07:48:11 <dmwit> But first you should try something simple, and verify that efficiency is really as important as you think.
07:48:14 <ksf> gpu is a good idea
07:48:18 <ksf> @hackage gpipe
07:48:18 <lambdabot> http://hackage.haskell.org/package/gpipe
07:49:48 <jmcarthur> <3 gpipe
07:50:31 <dmwit> Ah, case-sensitivity.
07:50:33 <dmwit> ?hackage GPipe
07:50:33 <lambdabot> http://hackage.haskell.org/package/GPipe
07:50:52 <jmcarthur> yeah that's why we have numbers and Numbers
07:50:55 <jmcarthur> :(
07:51:12 <xerox> Numb3rs
08:35:08 <babusrini> testing
08:35:25 <Raynes> unit testing
08:37:42 <babusrini> Data.Tree.drawTree says "-- | Neat 2-dimensional drawing of a tree." but when I call it I get "(9,9,4)\n|\n+- (6,9,0)\n|\n`- (4,6,0)\n". I was expecting a 2 dimensional drawing.
08:39:46 <tensorpudding> it probably looks nice if you putStrLn the string
08:41:54 <tARrAScH> Yo! is there any function like this? f [1,3] [2,4] = [1,2,3,4] ?
08:42:46 <opqdonut> not in prelude, no
08:42:47 <opqdonut> it
08:42:52 <opqdonut> 's easy to define though
08:43:17 <tARrAScH> Ok, thanks, I'll try to define it myself (yea its easy) :)
08:43:33 <opqdonut> but do you want f [1,2] [3,4] to be [1,2,3,4] (sorted merge) or [1,3,2,4] (every-second-merge)
08:43:34 <xerox> > join . transpose $ [[1,3],[2,4]]
08:43:36 <lambdabot>   [1,2,3,4]
08:44:01 <opqdonut> sweet, xerox
08:44:19 <tARrAScH> no I didn't mean like to sort them or anything, f [3,1,23,22] [6, 13] = [3,6,1,13,23,22]
08:44:30 <opqdonut> yeh
08:44:42 <tARrAScH> > join . transpose $ [[3,1,23,22],[6, 13]]
08:44:42 <lambdabot>   [3,6,1,13,23,22]
08:44:52 <tARrAScH> awesome :D
08:45:29 <tARrAScH> that's very smart dude!
08:45:46 <tARrAScH> > transpose $ [[3,1,23,22],[6, 13]]
08:45:47 <lambdabot>   [[3,6],[1,13],[23],[22]]
08:45:57 <patch-tag> can someone help me with a quickcheck question? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16878#a16878
08:46:03 <c_wraith> > concat $ zipWith (((:) .) . (:[])) [1, 2] [3, 4]
08:46:04 <lambdabot>   Couldn't match expected type `[a]'
08:46:04 <lambdabot>         against inferred type `[a1] -> [...
08:46:10 <patch-tag> I expect unwanted input to get discarded by the ==> clause, but it doesn't
08:46:38 <Zao> > [1..]
08:46:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:46:43 <c_wraith> @pl \x y -> x:y:[]
08:46:43 <lambdabot> (. return) . (:)
08:46:45 <aavogt> is it deliberate irony that the vim haskellmode knows a  -XMonomorphismRestriction (when you use _lang)?
08:47:23 <c_wraith> > concat $ zipWith ((. (:[]) . (:)) [1, 2] [3, 4]
08:47:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:47:28 <Saizan> patch-tag: you need to apply p' to n and xs in the definition of p
08:47:39 <c_wraith> > concat $ zipWith ((. (:[])) . (:)) [1, 2] [3, 4]
08:47:40 <lambdabot>   [1,3,2,4]
08:48:02 <c_wraith> there.  pointless for maximum obfuscation. :)
08:48:11 <xerox> > join . transpose $ [[1,1,1],[2..]]
08:48:12 <lambdabot>   [1,2,1,3,1,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
08:48:21 <xerox> > concat $ zipWith ((. (:[]) . (:)) [1,1,1] [2..]
08:48:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:48:34 <xerox> aww.
08:48:39 <c_wraith> you forgot a )
08:48:54 <xerox> > concat $ zipWith ((. (:[])) . (:)) [1,1,1] [2..]
08:48:55 <lambdabot>   [1,2,1,3,1,4]
08:49:03 <xerox> that's it
08:49:07 <xerox> :(
08:49:18 <c_wraith> zipwith does use the shorter list
08:49:36 <tARrAScH> well, both are cool ^^, but i wanted the transpose-one :)
08:51:14 <patch-tag> Saizan: thanks!
08:51:46 <patch-tag> just strange that it compiled without my doing that
08:52:17 <tARrAScH> hey guys, join working on monads? It uses the fact that the list somhow magically is a monad?
08:53:11 <Botje> >>= can be implemented in terms of fmap and join
08:53:34 <Botje> lists already have fmap (=map)
08:53:35 <xerox> tARrAScH yeah, join = concat there
08:53:42 <Botje> so if you add join (=concat) you get the list monad
08:54:16 <c_wraith> tARrAScH: join is m (m a) to m a ...  [[a]] -> [a] is concat (there are other ways to do it, but concat is the most interesting)
08:55:13 <tARrAScH> Thanks :)
08:55:16 <idnar> c_wraith: hmm, what other ways still satisfy the monad laws?
08:55:54 <c_wraith> idnar: there's at least one other way to think of lists as monads.  I don't recall what it is, though.
09:00:08 <babusrini> tensorpudding, thanks, with putStrLn I got
09:00:08 <babusrini> (9,9,4)
09:00:09 <babusrini> |
09:00:09 <babusrini> +- (6,9,0)
09:00:09 <babusrini> |
09:00:09 <babusrini> `- (4,6,0)
09:10:09 <quicksilver> c_wraith, idnar: taking the diagonal satisfies the monads for strictly infinite lists, or lists of some fixed finite length.
09:10:23 <quicksilver> (you need to modify return as well though)
09:12:30 <temoto> http://codepad.org/obHMY9Ka   does it look like applicative functor? Being B() constructor is 'pure' and Bar method is <*> ?
09:13:58 <opqdonut> no it
09:14:00 <opqdonut> 's not
09:14:04 <opqdonut> :t (<*>)
09:14:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:14:11 <quicksilver> well it is, in a very boring way
09:14:23 <quicksilver> it's the identity functor, restricted to functions
09:14:37 <quicksilver> if you have the identify functor and you only apply it to functions that looks a bit applicative
09:14:57 <quicksilver> but it's not really complete
09:14:59 <opqdonut> but (<*>) should really take two arguments
09:15:21 <c_wraith> quicksilver: return would become repeat?
09:15:25 <quicksilver> c_wraith: yes.
09:15:36 <quicksilver> c_wraith: or replicate n, for the finite but fixed length case
09:15:38 <temoto> opqdonut, we can imagine 'this' being a hidden argument passed to it.
09:15:46 <temoto> :t <*>
09:15:47 <lambdabot> parse error on input `<*>'
09:15:52 <temoto> :t (<*>)
09:15:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:16:04 <quicksilver> 'pure' needs to work on all types to make it a functor temoto
09:16:05 <opqdonut> but still not two arguments
09:16:08 <quicksilver> B() only works on functions.
09:16:26 <opqdonut> <*> should combine two Bs
09:16:32 <idnar> what is that, C++?
09:16:59 <temoto> idnar, i guess any languages with classes support that definition.
09:18:06 <temoto> quicksilver, is there some name which is closer than ap.functor?
09:18:26 <kmc_> @bot
09:18:26 <lambdabot> :)
09:19:23 <idnar> temoto: I meant the specific syntax
09:19:44 <idnar> I don't think you can write that in Java (but maybe I'm wrong?)
09:19:52 <kmc_> what are you trying to write?
09:20:04 <idnar> er, I mean, compile that in Java
09:20:32 <temoto> idnar, the guy surrounded it with [C#] for syntax highlight, it's not really a part of some code.
09:21:04 <temoto> We were just discussing polymorphism.
09:22:26 <temoto> It took me maybe a week of mail discussion to explain that some other languages support all features OOP has, but in a different way so you can't say they support exactly OOP.
09:22:43 <quicksilver> temoto: it's just an object wrapping a function isn't it?
09:22:53 <quicksilver> I'm not sure such things have interesting names.
09:22:55 <temoto> quicksilver, yeah, seems like it is.
09:23:00 <quicksilver> an "adapter" perhaps, although that has lots of names.
09:23:05 <quicksilver> lots of meanings, I mean
09:23:18 <temoto> Okay, adapter.
09:25:13 <Polarina> Is it possible to split a string, or a bytestring on every occurrence of "ab"?
09:27:44 <kmc_> Polarina: look at the "split" package on Hackage
09:27:49 <Polarina> Ok.
09:28:05 <kmc_> you can also write it yourself as a simple recursive function (for String, at least)
09:28:33 <Polarina> But for a ByteString?
09:28:46 <kmc_> not sure
09:29:20 <Polarina> :(
09:29:48 <Polarina> Splitting a lazy ByteString to many lazy ByteStrings would be helpful. :)
09:30:12 <kmc_> looks like "split" only works on lists :/
09:30:39 <Polarina> :'(
09:30:49 <kmc_> however there are several parser libraries that operate on ByteString
09:31:04 <temoto> Polarina, hello, how's it going?
09:31:12 <Polarina> temoto, going well.
09:31:30 <temoto> Polarina, good to see you around #haskell still :)
09:31:34 <Polarina> :)
09:33:58 <Polarina> groupBy seems to do the trick. :D
09:34:59 <xerox> does it?
09:35:12 <Polarina> I am testing it further.
09:35:36 <xerox> > groupBy (\x y -> x/='a' && y/='b') "123ab34ab345"
09:35:37 <lambdabot>   ["123a","b34a","b345"]
09:35:38 <xerox> :/
09:36:33 <Polarina> :D
09:37:32 <Polarina> Now if I could rid the a and b that is being split.
09:38:19 <Polarina> Maybe I could use splitWith.
09:39:21 * hackagebot upload: hscolour 1.16 - Colourise Haskell code. (MalcolmWallace)
09:39:23 <ksf> map (filter (not . elem "ab")) ["123a","b34a","b345"]
09:39:24 <ksf> >map (filter (not . elem "ab")) ["123a","b34a","b345"]
09:39:29 <ksf> > map (filter (not . elem "ab")) ["123a","b34a","b345"]
09:39:30 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
09:39:30 <lambdabot>         against inferred ...
09:39:56 <EvanCarroll> @src elem
09:39:57 <lambdabot> elem x    =  any (== x)
09:40:05 <ksf> :t filter (not . elem "ab")
09:40:07 <lambdabot> [[[Char]]] -> [[[Char]]]
09:40:28 <ksf> :t elem
09:40:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:40:35 <ksf> oh
09:40:55 <ksf> > map (filter (not . (flip elem) "ab")) ["123a","b34a","b345"]
09:40:56 <lambdabot>   ["123","34","345"]
09:41:29 <Polarina> > map (filter (not . (flip elem) "ab")) ["123a","b34a","b34a5"]
09:41:30 <lambdabot>   ["123","34","345"]
09:41:33 <Polarina> Evil.
09:41:34 <c_wraith> the parens around flip elem there aren't needed
09:41:46 <medfly> hehe
09:42:01 <EvanCarroll> Isn't that just going to remove all [ab]s
09:42:19 <zygoloid> not . (flip elem) "ab" == (`notElem` "ab")
09:42:20 <ksf> c_wraith, my parser and haskell's don't always agree
09:42:28 <medfly> it removes everything that is an element of "ab"
09:42:57 <EvanCarroll> right, but if you had 1a23a, it would read 123
09:43:06 <burp> > map (filter (not . (flip elem) "ab")) $ groupBy (\x y -> x/='a' && y/='b') "123ab34ab345"
09:43:07 <aledge> :t any
09:43:08 <lambdabot>   ["123","34","345"]
09:43:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:43:13 <zygoloid> > filter (`notElem` "ab") . ["123a", "b34a", "b345"]
09:43:15 <lambdabot>   ["123","34","345"]
09:43:18 <EvanCarroll> which doesn't seem to useful, if you're just trying to remove a multichar 'ab' delimiter from that string
09:43:44 <burp> > map (filter (not . (flip elem) "ab")) $ groupBy (\x y -> x/='a' && y/='b') "123ab34b345a678"
09:43:46 <lambdabot>   ["123","34","345678"]
09:44:11 <EvanCarroll> > map (filter (not . (flip elem) "ab")) $ groupBy (\x y -> x/='a' && y/='b') "1aaaaa23ab34b345a678"
09:44:12 <lambdabot>   ["123","34","345678"]
09:44:17 <xerox> :(
09:44:22 <EvanCarroll> that sounds like a bug
09:44:39 <EvanCarroll> 11:42 < Polarina> Now if I could rid the a and b that is being split.
09:44:51 <EvanCarroll> that was the task, not to simply remove all [ab]
09:45:06 <ksf> @src lines
09:45:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:45:22 <Polarina> There's findSubstring
09:45:28 <Polarina> findSubstrings
09:47:32 <Polarina> ghc doesn't seem to implement breakSubstring
09:47:36 <Polarina> :t breakSubstring
09:47:37 <lambdabot> Not in scope: `breakSubstring'
09:47:38 <ksf> :t many anyChar `sepBy` string "ab"
09:47:39 <lambdabot> Not in scope: `anyChar'
09:47:39 <lambdabot> Not in scope: `sepBy'
09:47:39 <lambdabot> Not in scope: `string'
09:47:44 <ksf> oh well
09:47:54 <zygoloid> > map (fst . head . filter (isPrefixOf "ab" . snd) . uncurry zip . (inits &&& tails) . (++ "ab")) . map (drop 2) . filter (isPrefixOf "ab") . tails . ("ab"++) $ "123ab34ab345ab678"
09:47:55 <lambdabot>   ["123","34","345","678"]
09:47:55 <ksf> but a parsing lib does wonders.
09:48:07 <Polarina> > map (fst . head . filter (isPrefixOf "ab" . snd) . uncurry zip . (inits &&& tails) . (++ "ab")) . map (drop 2) . filter (isPrefixOf "ab") . tails . ("ab"++) $ "123ab34ab345ab6a78"
09:48:09 <lambdabot>   ["123","34","345","6a78"]
09:48:11 <Polarina> Yay!
09:48:12 <cheater2> hey guys
09:48:17 * Polarina hugs zygoloid.
09:48:43 <ksf> mine is shorter.
09:48:43 <burp> what a beast function
09:48:56 <cheater2> i would like to write a social networking web app in haskell. recommendations for frameworks/libraries/tutorials/anything?
09:49:14 <Polarina> ksf, not in scope, some functions.
09:49:16 <ksf> happstack
09:49:23 <ksf> Polarina, that's parsec.
09:49:25 <Polarina> cheater2, sqlite.
09:49:29 <Polarina> ksf, parsec?
09:49:36 <cheater2> Polarina: ... :)
09:50:02 <ksf> http://legacy.cs.uu.nl/daan/parsec.html
09:50:11 <domor`> zygoloid's piece of code probably eats programmers for breakfast
09:50:17 <ksf> ...the vanilla haskell parsing lib
09:50:36 <ksf> if you feel adventurous, go for uulib instead.
09:51:44 <ksf> cheater2, http://tutorial.happstack.com/
09:52:35 <xerox> zygoloid :O
09:52:48 <xerox> actually
09:52:50 <xerox> zygoloid++
09:53:35 <ksf> Polarina, do you need the results lazily?
09:53:52 <Polarina> ksf, yes, that would be great.
09:54:03 <Polarina> I am doing lazy I/O.
09:54:05 <cheater2> ksf: thanks. is happstack the most popular web framework for haskell?
09:54:23 <Polarina> cheater2, popularity says nothing about quality.
09:54:26 <ksf> parsec can't do that, it has to see the end of the input to see if the grammar fails or not
09:54:38 <Twey> cheater2: Also, yes.
09:54:40 <ksf> ...but other libs like uulib or polyparse can do that
09:55:07 <cheater2> Polarina: popularity is important for people who are only starting with haskell like me, so that i can easily find someone to bug with questions :-)
09:55:19 <ksf> cheater2, there's thousands of bits and pieces around, you can e.g. do fastcgi and use any templating system and database adaptor you want
09:55:34 <Polarina> Why doesn't my ghc have this function? http://www.haskell.org/ghc/docs/6.10.4/html/libraries/bytestring/Data-ByteString.html#v%3AbreakSubstring
09:55:47 <kmc_> is your ghc version 6.10.4?
09:55:52 <cheater2> ksf: i would most like to have something that works with nginx or lighttpd
09:55:53 <Polarina> 6.8
09:56:02 <kmc_> note the url
09:56:12 <Polarina> Aww, aww...
09:56:54 <kmc_> 6.8 is old...
09:57:01 <Polarina> Is breakSubstring a standard function in haskell 98?
09:57:08 <ksf> cheater2, http://hackage.haskell.org/package/fastcgi
09:57:16 <kmc_> bytestring is not in H98
09:57:21 <Polarina> :(
09:57:27 <kmc_> the module name "Data.ByteString" is not even legal in H98 ;)
09:57:29 <Polarina> Haskell Prime?
09:57:31 <EvanCarroll> 11:52 < Polarina> > map (fst . head . filter (isPrefixOf "ab" . snd) . uncurry zip . (inits &&& tails) . (++ "ab")) . map (drop 2) . filter (isPrefixOf "ab") . tails . ("ab"++) $ "123ab34ab345ab6a78"
09:57:44 <kmc_> haskell prime is a process not a product
09:57:52 <EvanCarroll> it takes all that code to do what `perl -e'split /ab/, $str'` does?
09:57:57 <kmc_> the process produces one standard per year
09:57:58 <EvanCarroll> that is crazy complex.
09:57:58 <Polarina> kmc_, why isn't it legal H98?
09:58:11 <kmc_> Polarina: Haskell 98 has a flat module namespace, with alphanum names
09:58:17 <xerox> EvanCarroll but type safe :D
09:58:18 <Polarina> Flat?
09:58:21 <kmc_> flat
09:58:22 <zygoloid> > let splitAB ('a':'b':xs) = []:splitAB xs; splitAB (x:xs) | (y:ys) <- splitAB xs = (x:y):ys; splitAB [] = [[]] in splitAB "123ab456b789ab10"
09:58:23 <lambdabot>   ["123","456b789","10"]
09:58:25 <kmc_> no hierarchy
09:58:25 <Polarina> Flat?
09:58:26 <kmc_> no '.'
09:58:31 <Polarina> o.O
09:58:36 <kmc_> so far they have produced one standard, Haskell 2010, which iirc does not add anything to the standard library
09:58:43 <cheater2> ksf: cool. thanks.
09:58:44 <opqdonut> no Polarina, o.O is not a valid module name
09:58:48 <Polarina> lol
09:58:57 <xerox> zygoloid is that view patterns?
09:59:04 <Polarina> Why do people use dots in module names then?
09:59:05 <zygoloid> xerox: that's pattern guards
09:59:14 <xerox> zygoloid I'm referring to the <-
09:59:17 <EvanCarroll> that still seems a lot more complex than the perl alternative.
09:59:30 <EvanCarroll> not to say /everything/ has to read better
09:59:33 <zygoloid> xerox: yes, i know :)
09:59:36 <zygoloid> , let splitAB ('a':'b':xs) = []:splitAB xs; splitAB (x:(splitAB -> y:ys)) = (x:y):ys; splitAB [] = [[]] in splitAB "123ab456b789ab10"
09:59:41 <zygoloid> ^^ that's view patterns
09:59:45 <ksf> EvanCarrol, many anyChar `sepBy` string "ab"
09:59:50 <zygoloid> preflex: seen lunabot
09:59:50 <preflex>  lunabot was last seen on #haskell 2 days, 10 hours, 37 minutes and 3 seconds ago, saying:  31
09:59:56 <xerox> aohum, there's something I didnt know.
10:00:05 <EvanCarroll> ksf: if that works, that looks a lot better
10:00:17 <ksf> ...you have to compare regexen with something equivalent, not raw string functions
10:00:47 <EvanCarroll> I don't even understand what (x:xs) | (y:ys)
10:01:09 <EvanCarroll> or half of those constructs.
10:01:42 <kmc_> Polarina: because it's a useful and very conservative extension to H98.  very very few people write pure 100% Haskell 98 code
10:01:44 <ksf> that's a pattern guard
10:01:51 <Polarina> kmc_, :(
10:01:52 <zygoloid> EvanCarroll: "(y:ys) <- splitAB xs" is a pattern guard. like a normal guard except it also binds variables
10:02:29 <kmc_> Polarina: it's in Haskell 2010, and is supported by every implementation I know of
10:02:34 <xerox> zygoloid thank you
10:02:44 <Polarina> kmc_, dots in module names?
10:02:47 <kmc_> yes
10:02:50 <Polarina> Yay! :D
10:02:52 <kmc_> HierarchicalModules
10:03:35 * ksf thinks the compilers should accept java-style Foo.Bar/Baz.hs as module Foo.Bar.Baz
10:03:39 <kmc_> the extension is so conservative and so widely used that GHC doesn't make you turn it on
10:03:57 <kmc_> org.haskell.Data.List
10:04:03 <ksf> er no
10:04:46 <domor`> shouldn't a module be considered independant from a filename?
10:04:51 <zygoloid> package names don't belong in module names; there's a separate facility for that
10:04:51 <ksf> but having a flat hierarchy is usually quite useful for editing
10:04:58 <zygoloid> import "org.haskell" Data.List
10:05:02 <kmc_> domor`: it's nice to be able to find stuff
10:05:07 <zygoloid> -XPackageQualifiedImports iirc
10:06:14 <ksf> I'd also like to see multiple modules per file, a la agda
10:06:31 <ksf> and first class modules
10:06:38 <kmc_> and parametrized modules
10:06:42 <kmc_> and i'd like a pony
10:06:50 <kmc_> cabal install pony
10:07:04 <c_wraith> Eh.  I like having modules names map to file names.  It makes it easy to find sources.
10:07:25 <kmc_> as long as the full module name appears somewhere in the file, grep can find it
10:07:25 <c_wraith> I might be ok with multiple modules per file if only one was externally visible
10:07:37 <ksf> c_wraith, there's nothing wrong with that, you can have modules Foo.Bar and Foo.Baz in a file named Foo
10:07:43 <kmc_> in C++ you can use any namespace in any file and you needn't write the full name anywhere
10:07:50 <ksf> or that, yes.
10:07:52 <kmc_> and so based on the fact that this is how C++ does it, i think this is a bad idea
10:08:12 <c_wraith> I'm just sick of ruby, where there's never any hint of what source file contains the module/class you're looking for.
10:08:16 <ksf> modules and records should be the same
10:08:29 <zygoloid> in c++ you can't do "<compiler> --make main.cpp" and have it automatically pick up and build the dependencies
10:08:29 <kmc_> in a really dynamic language it's hard to say where something comes from in general
10:08:32 <c_wraith> of course, being ruby, the module/class you want is probably split over 10 files in differentgems.
10:08:40 <ksf> modulo type classes. dunno what to do with them.
10:08:52 <kmc_> ksf: replace them with a system of implicit parameters ;)
10:09:10 <ksf> zygoloid, I've got an omakefile to do that, if the imports are remotely sane.
10:10:14 <zygoloid> ksf: for c++?
10:10:21 <ksf> yep
10:10:27 <ksf> ...or rather for C
10:10:56 <ksf> the heuristic is that if there's a .c file named the same as a .h in the imports, then the .c is a dependency.
10:11:13 <ksf> you can break it, but it makes sense to stick to that scheme, anyway.
10:12:31 <zygoloid> that's pretty neat, but it doesn't cover the full evil of c++ even if you use said scheme. (globals with nontrivial construction might be in .cpp files where the header isn't included anywhere else)
10:13:12 <ksf> nothing can cover c++'s evilness, as it's infinite.
10:14:21 <jlouis> ksf: but is the space compact?
10:14:42 <ksf> it's uncountably infinite.
10:15:18 <ksf> I think the proper mathematical term is "mindboggling"
10:17:06 <fergie> How do I make a type that is a subset of another type, eg Int's less than 50?
10:18:38 <tromp> what shld happen when i add 30 to 28 then?
10:19:26 <trzkril> tromp: (+) :: int50 -> int50 -> int100 ;)
10:19:32 <kmc_> fergie: you can't do this in Haskell, in general
10:19:50 <tromp> the (+) in Num must be a->a->a
10:20:09 <tromp> you can do it, but it's painful
10:20:26 <kmc_> trzkril's solution works in a dependently typed language, or with datakinds like those provided by She
10:20:38 <fergie> kmc_: ok. Thanks for saving me a lot of time trying to get it to work
10:20:55 <tromp> with functions that error when exceeding 50
10:20:59 <tensorpudding> how does Word handle being a Num?
10:21:18 <shimuaar> Modular arithmetics
10:21:59 <Twey> A.K.A. overflow
10:22:01 <benmachine> I don't know if overflows behaviour is guaranteed
10:22:05 <benmachine> -s
10:22:09 <Twey> I'm pretty sure it is
10:22:27 <tromp> technically you cant overflow a modular value
10:22:49 <Twey> Any fixed-width field has to overflow, because it's the result of truncation
10:23:10 <tromp> it wraps around
10:23:10 <Twey> tromp: That's because modularity involves overflow already :þ
10:23:24 <Twey> Same thing
10:23:43 <tromp> not for flaots
10:23:50 <Twey> Ah, point
10:23:52 <tromp> floats can overflow, but not wraparound
10:23:54 <xerox> maybe tromp was referring to the fact that 'over' implies ordering, and finiteness an ordering do not go well together
10:39:50 <tARrAScH> Is there any cycle that only cycles an decided amount of time? (like (concat . replicate i))
10:40:02 <xerox> > repeat 10 "yes"
10:40:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:40:03 <lambdabot>         against inferr...
10:40:06 <xerox> aww.
10:40:22 <xerox> it is replicate.
10:41:55 <tARrAScH> > replicate 3 "abc"
10:41:56 <lambdabot>   ["abc","abc","abc"]
10:42:12 <tARrAScH> > concat $ replicate 3 "abc"
10:42:13 <lambdabot>   "abcabcabc"
10:42:26 <tARrAScH> i want that one, but I guess tehres no inbuilt one
10:43:36 <kmc_> > cycle "abc"
10:43:37 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
10:43:58 <kmc_> > take 9 $ cycle "abc"
10:43:59 <lambdabot>   "abcabcabc"
10:44:23 <zygoloid> > flip const <$> [1..3] <*> "abc"
10:44:25 <lambdabot>   "abcabcabc"
10:44:31 <xerox> > join . replicate 3 $ "meep"
10:44:32 <lambdabot>   "meepmeepmeep"
10:45:14 <zygoloid> > replicate 3 id <*> "abc"
10:45:15 <lambdabot>   "abcabcabc"
11:15:57 * hackagebot upload: WebBits-Html 1.0.2 - JavaScript analysis tools (ArjunGuha)
11:17:54 <cheater2> is happstack going to be good for an application that has to scale up high? e.g. 1000 hits per day at first, then 1000 per hour after six months, then per minute after 1 year, then per second after two years
11:18:53 <cheater2> ksf: maybe you know :-)
11:19:26 <c_wraith> happstack can handle 1k hits/day.  :)
11:19:37 <cheater2> ok, but is it going to scale up?
11:19:54 <kmc_> most webapps in any language or platform are scaled out
11:19:58 <cheater2> i could handle 1000 hits per day in visual basic
11:19:59 <kmc_> to more machines, more datacenters, etc
11:20:16 <aavogt> it also depends what each hit has to do...
11:20:31 <cheater2> it has to do happstack stuff. :)
11:20:41 <kmc_> so your app doesn't do anything, it's just happstack Hello World?
11:20:49 <cheater2> assume so
11:21:13 <sshc> how well would Haskell be for scripting?
11:21:19 <kmc_> what does "scripting" mean?
11:21:22 <sshc> such as scripts for an IRC client, or a game, perhaps
11:21:28 <kmc_> (nobody can agree on this)
11:21:29 <kmc_> ah
11:21:37 <c_wraith> it works ok
11:21:42 <Polarina> It would be awesome!
11:21:44 <c_wraith> check out the hint package, for instance
11:21:45 <shapr> Is the source for LightHouse available?
11:21:55 <sshc> something that "adds" functionality to or details how something operates
11:22:09 <kmc_> every program i write adds functionality to my operating system
11:22:10 <kmc_> anyway
11:22:19 <c_wraith> sshc: hint allows dynamic loading of haskell code.
11:22:24 <kmc_> the fact that not many people know Haskell may be a bigger issue than any technical feature
11:22:41 <shapr> I'm actually looking for the most recent version of the pure Haskell TCP/IP stack that was in House.. anybody know?
11:22:45 <domor> not quite convinced... that kind of script tends to be written by non-professional programmers who won't be too thrilled to use monads to mod their game or whatever
11:22:50 <Polarina> kmc_, they shall be shoot on sight, those who not know the haskell.
11:22:52 <sshc> c_wraith: kind of like dll's in windows?
11:22:54 <kmc_> if you need a bunch of game developers or users to program stuff
11:23:07 <kmc_> well, monads are not hard if you stick to one monad and avoid saying the word "monad"
11:23:23 <shapr> domor: It works for XMonad
11:23:24 <sshc> c_wraith: now, that is very useful!!
11:23:30 <sshc> c_wraith: and, erm, aptly named ;)
11:23:41 <kmc_> but i think Haskell does have a steep learning curve for a programmer of typical background
11:23:42 <c_wraith> sshc; it's a cool package
11:23:49 <kmc_> people tend to learn languages by analogy
11:23:59 <shapr> Haskell is like awesomeness.
11:24:14 <kmc_> Lua is used a lot for game scripting, and maybe people don't know Lua, but they'll translate whatever Perl or Python or Ruby they know into Lua syntax and it will mostly work
11:24:24 <aavogt> depends what subset of haskell you use
11:24:28 <kmc_> this doesn't work for Haskell
11:24:36 <Twey> Sure it does
11:24:43 <kmc_> you have to learn it as a new thing, not as a syntactic rehash of stuff you already know
11:24:44 <EnglishGent> out of interest - does anyone know of a computer language using full beta reduction?
11:24:48 <domor> what kind of scripts does xmonad take? is it actual Haskell?
11:24:49 <Twey> Yay IO(Refs) :þ
11:24:49 <EnglishGent> or a good reason why there isnt one?
11:24:52 <kmc_> domor: yes
11:24:58 <Twey> domor: It doesn't take scripts
11:25:01 <kmc_> XMonad is, technically, a library for writing your own window manager
11:25:05 <tensorpudding> xmonad has a config file that is pure haskell
11:25:08 <Twey> Right
11:25:10 <kmc_> which in the simple case is one line of code
11:25:17 <Twey> The ‘config file’ is the actual window manager
11:25:19 <tensorpudding> technically, it modifies a default configuration
11:25:24 <aavogt> two counting imports
11:25:26 <cheater2> ok guys, seriously, is happstack going to perform well in a social web app similar to, for example, facebook?
11:25:27 <kmc_> you configure and extend XMonad by writing more stuff in that file
11:25:35 <pikhq> tensorpudding: Technically, there is no config file.
11:25:39 <Twey> cheater2: Depends what you do with it
11:25:47 <pikhq> There is only a program that is a window manager.
11:25:49 <Twey> So long as you use it well, yes, I'd say so
11:25:49 <kmc_> facebook is written in PHP
11:25:51 <shapr> domor: So, I'd say that extending an application with Haskell is already successful with one application. Have you tried XMonad?
11:25:52 <pikhq> That uses the Xmonad library.
11:25:52 <cheater2> Twey: what do you need specified?
11:26:04 <arw> cheater2: with enough caching, loadbalancing and stuff, even ruby performs well enough :)
11:26:04 <domor> I see... still I think people who mod their xmonad at any level above the default are probably fairly technically competent. More than most game modders.
11:26:07 <sshc> I can see how "hint" can be used in a manner similar to how lua typically is
11:26:08 <tensorpudding> but you have the full authority of all of Haskell's libraries that GHC knows about, as well as all of XMonad's libraries
11:26:10 <Twey> cheater2: Well, any part of the app could be a bottleneck
11:26:21 <domor> shapr: no sorry, I don't have a linux box handy
11:26:22 <shapr> domor: Sure, but most of them didn't know Haskell before they started to mod their config.
11:26:39 <cheater2> Twey: yes. but is happstack going to be a bottleneck itself?
11:26:42 <kmc_> domor: Haskell is also a good language for *implementing* your domain-specific mod language
11:26:42 <sshc> lua is a nice as far as imperitive languages go
11:26:42 <tensorpudding> editing an xmonad config is much harder than modding a game (i would imagine, i've never done the latter)
11:26:44 <Twey> cheater2: No
11:26:53 <tensorpudding> err, much easier*
11:26:54 <shapr> domor: That's the point I was making, re: "that kind of script tends to be written by non-professional programmers who won't be too thrilled to use monads to mod their game or whatever"
11:26:55 <tensorpudding> damn
11:26:57 <kmc_> and doing so in such a way that you can code mods in Haskell directly or in your DSL, and mix the two
11:27:05 <kmc_> eh, monads are not the issue
11:27:05 <domor> kmc_: that I would agree however
11:27:06 <cheater2> Twey: what examples do you have that uphold this?
11:27:12 <tensorpudding> way to say the exact opposite of what i meant :(
11:27:12 <Polarina> Whom do I shoot for making "make -j5" in ghc not do anything at all to make this thing parallel?
11:27:26 <shapr> Polarina: It was working with ghc 5.04 !
11:27:26 <Twey> cheater2: What examples do you have that could disprove this?
11:27:35 <kmc_> perhaps non-professional programmers would be unhappy about typclasses and higher-order functions, then they'll misdirect their confusion at "monads" because of the funny name
11:27:49 <kmc_> Polarina: yourself
11:27:54 <tensorpudding> of because monads are everywhere
11:27:55 <Polarina> :(
11:27:56 <cheater2> Twey: i am not looking for something that 'might' work and i will find out two years down the line that it doesn't
11:27:58 <tensorpudding> or*
11:28:00 <kmc_> how is "make -j5" "in GHC"?
11:28:04 <kmc_> make is going to invoke GHC
11:28:08 <cheater2> Twey: i hope you understand this
11:28:15 <sshc> out of curiosity, about how many lines of Haskell code have people in this channel written, not counting the ones that have been deleted or replaced?
11:28:15 <kmc_> or, you mean while building ghc itself?
11:28:17 <shapr> Yay, House 0.8.93 is available! Let's see if the tun/tap hookup for the pure tcp/ip stack still works!
11:28:20 <Twey> cheater2: You might find this interesting: http://groups.google.com/group/happs/browse_thread/thread/8663c04f3b104133/659250f6cc19293f
11:28:25 <sshc> to answer my own question:
11:28:29 <domor> shapr: yes, but I do think most people who customize xmonad at any decent level are professional programmers
11:28:33 <arw> cheater2: in that case you should do some more extensive benchmarking of the different solutions available.
11:28:34 <kmc_> sshc: between 10,000 and 100,000
11:28:37 <cheater2> Twey: as much as haskell is fun, i respect my time enough to not waste it on 'might be' projects (and i hope so do you)
11:29:02 <shapr> domor: Do you have anything to support that idea?
11:29:05 <cheater2> Twey: so i'm looking for good reasons to use it :)
11:29:14 <kmc_> domor: do you mean "professional level" or do you actually mean people who code for a living?
11:29:15 <cheater2> Twey: looks like an interesting app, thanks
11:29:16 <cheater2> arw: yes
11:29:23 <domor> kmc_: also what I think, I just said 'monad' because it's the usual culprit ;)
11:29:25 <cheater2> s/app/read
11:29:39 <kmc_> i don't think they are really
11:29:50 <domor> I mean someone who knows what a library is, etc.
11:29:51 <arw> cheater2: look at the language shootout and compare it to the usual languages web-apps are built in. that should at least give you a hint.
11:29:58 <sshc> i've only written about 3,000 lines of Haskell code
11:29:59 <kmc_> i think if you really understand typeclasses and higher order functions, you will understand monads without too much difficulty
11:30:01 <Twey> And yeah, like someone said
11:30:05 <Twey> Facebook uses PHP
11:30:14 <sshc> but, I have written about 50,000 lines in C and lua
11:30:18 <kmc_> but a lot of people don't understand those, and just sort of charge ahead until they get to monads
11:30:21 <Twey> Clearly, performance isn't nearly as big a concern as you seem to think
11:30:25 <domor> shapr: I don't know anybody (in real life) who's even heard of xmonad, let alone use it, including coders
11:30:34 <kmc_> then again, facebook is going to release a PHP-to-C compiler very soon
11:30:40 <cheater2> arw: language shootout?
11:30:46 <arw> http://shootout.alioth.debian.org/
11:30:48 <cheater2> Twey: facebook is also crap :p
11:30:56 <kmc_> anyway, again.  webapps scale out
11:31:09 <kmc_> people run them on dog-slow language implementations, and just buy more machines
11:31:10 <jmcarthur> cheater2: but it's fast
11:31:12 <Twey> cheater2: Yep… but it scales
11:31:22 <sshc> higher order functions?
11:31:26 <Twey> And it was you who brought it up as an example of what you want to do :þ
11:31:27 <cheater2> arw: thanks, will have a look
11:31:30 <Polarina> I've only written one line of code -- my enter key is broken.
11:31:30 <sshc> is that a special term for partial application?
11:31:35 <tensorpudding> xmonad is not that uncommon among tiling window managers, but it's kinda niche
11:31:37 <etpace> :t . .
11:31:38 <lambdabot> parse error on input `.'
11:31:38 <domor> shapr: of course this isn't 'evidence' - just the reason why I have this impression of xmonad
11:31:43 <etpace> :t mconcat
11:31:44 <lambdabot> forall a. (Monoid a) => [a] -> a
11:31:49 <kmc_> sshc: no, a HOF is any function that takes another function as an argument
11:31:52 <Twey> tensorpudding: Tiling WMs in general are already niche
11:31:57 <kmc_> "map" is the canonical example
11:32:02 <tensorpudding> that's what i meant
11:32:02 <cheater2> jmcarthur: fast is a relative term. you can always throw more money/hardware/humans at something and that will make it faster.
11:32:07 <tensorpudding> is that tiling wm are niche
11:32:09 <sshc> kmc_: I see
11:32:15 <tensorpudding> but in their class, xmonad is prominent
11:32:19 <jmcarthur> cheater2: then why is it an issue, anyway?
11:32:21 <Twey> cheater2: Sadly, no
11:32:33 <Twey> cheater2: That's what scaleability is, and that's what Happstack has that other solutions don't
11:32:38 <sshc> kmc_: I don't understand why even typical impertive programmers would have any difficulty at all understand higher order functions
11:32:44 <cheater2> jmcarthur: because it's better to not do this :)
11:32:47 <sshc> kmc_: they already exist in lua, and in C too with function pointers
11:32:48 <jmcarthur> Twey: it's what happstack theoretically has, you mean
11:32:49 <Twey> You get more benefit out of the hardware that you throw at happstack
11:32:51 <shapr> domor: I can understand that.
11:33:02 <cheater2> Twey: that is what i am looking for
11:33:10 <kmc_> sshc: C function pointers by themselves are not first-class functions
11:33:13 <jmcarthur> happstack is designed to be scalable
11:33:14 <Valodim> http://shootout.alioth.debian.org/u32/haskell.php
11:33:14 <Valodim> wow I didn't know Java had improved that much
11:33:15 <arw> sshc: yes, but function pointers are a kind of black magic many c programmers don't dare to touch.
11:33:22 <jmcarthur> i don't know how well it's been tested for that, though
11:33:27 <shapr> domor: The people I know who have done game mods (for tremulous) have lots of motivation and very little clue. But they get it done, whatever it takes.
11:33:27 <kmc_> C function pointers allow you to select from among a pre-defined finite set of behaviors
11:33:30 <sshc> I'm not as experienced in other languages as I am in those two languages, though, so I can't really say about other languages
11:33:35 <kmc_> they do not allow you to create new behaviors at runtime, by closing over free variables
11:33:41 <sshc> kmc_: functions are first-class f in lua
11:33:43 <kmc_> also, "imperative" is not the opposite of "functional"
11:33:54 <shapr> kmc_: What's the opposite of functional?
11:33:56 <kmc_> sshc: sure, and in Ruby, Python, Perl, C#, Javascript...
11:33:58 <sshc> procedural?
11:33:59 <kmc_> dysfunctional
11:34:07 <jmcarthur> i don't think functional has an opposite
11:34:09 <Twey> shapr: You're a Trem-player?
11:34:14 <Twey> jmcarthur: Dysfunctional ;)
11:34:15 <sshc> yes!
11:34:19 <kmc_> lacking a basic feature is not a "paradigm"
11:34:21 <jmcarthur> Twey: cheating :P
11:34:28 <shapr> Twey: Not in the past six months, but I used to play lots.
11:34:30 <kmc_> every good general-purpose imperative language has first class functions
11:34:31 <Twey> But true :þ
11:34:32 <lament> the opposite of functional is stateful
11:34:36 <sshc> Twey: GPP is awesome
11:34:37 <tensorpudding> does java have closures?
11:34:43 <jmcarthur> kmc_: for some definition of good
11:34:47 <kmc_> not very conveniently, tensorpudding
11:34:47 <Twey> tensorpudding: Well… kind of
11:34:55 <shapr> I got closure from Java when I quit my Java job :-/
11:34:59 <Twey> Haha
11:35:09 <kmc_> you can declare an anonymous class, instantiate it with free vars, and return the instance within a function body
11:35:17 <tkr> shapr: what a closure *from* perl?
11:35:21 <Twey> Aren't we all pun-dits today
11:35:21 <kmc_> that's a little better than C++'s support for functions
11:35:27 <kmc_> which requires declaring the class far away
11:35:35 <Zao> tkr: Knowing perl, a hash.
11:35:42 <kmc_> re xmonad, i work in a group of ~30 developers and we have 4 or 5 people using xmonad
11:35:56 <kmc_> and of those i'm the only one who has done any Haskell coding outside of configuring xmonad
11:36:09 <shapr> tkr: Well, I switched to Python from Java, so...
11:36:11 <kmc_> well, maybe that's not quite true
11:36:13 * kw317 used dwm at work for very long time
11:36:17 <tensorpudding> i wonder how many .NET programmers use xmonad
11:36:18 <sshc> kmc_: with which group do you work?
11:36:20 <domor> shapr: true, it could work if you expose a palatable subset of haskell. I've been impressed by how parsec's interface hides the details from the user
11:36:22 <kw317> now I'd appreciate a mac
11:36:35 <kmc_> but we're not a Haskell shop or anything
11:36:43 <shapr> domor: I think that's how domain specific languages *should* work. Not saying they always do that.
11:37:02 <kmc_> if you go to #xmonad you will find lots of people who don't know Haskell trying to configure their window manager with varying degrees of success
11:37:13 <lament> abstractions _should_ not be leaky :)
11:37:32 <sshc> in my experience you need to know at least some basics of Haskell to configure xmonad
11:37:35 <shapr> Has anyone used the TCP/IP stack from House (with the tun/tap setup) with a GHC later than 6.8.x ?
11:37:55 * kw317 remembers that configuring dwm == editing its source code (C)
11:38:05 <mauke> just like xmonad!
11:38:05 <kmc_> that's true of xmonad, as well
11:38:23 <mauke> except xmonad has an extremely powerful support library
11:38:26 <kmc_> it's not necessary to know much Haskell to change keybindings in XMonad, or to enable new stock layouts
11:38:27 <cheater2> Twey: what's a trem? :)
11:38:32 <sshc> their decision with configuring made it more flexible but required knowledge of Haskell
11:38:40 <shapr> Does anyone know who else from #haskell may have used the TCP/IP stack from House separately?
11:38:44 <sshc> cheater2: it's a special type of pink brick
11:38:46 <Zao> kmc_: Except if you want to start removing stuff from the binding list.
11:38:47 <tensorpudding> i switched to xmonad from dwm
11:38:48 <sshc> cheater2: only it's very light
11:38:56 <kmc_> Zao: why's that?
11:38:57 <cheater2> how do you play a trem?
11:38:59 <Zao> kmc_: Unless you use some of the pansy EZ stuff layered on top.
11:39:00 <temoto> :t foldl
11:39:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:39:08 <kmc_> ion3 is configured in Lua and I definitely didn't learn much general purpose Lua programming in the several years i used it
11:39:09 <tensorpudding> at that time, they were actually pretty similar except for the whole C vs. Haskell bit
11:39:13 <sshc> cheater2: typically they're used to fix broken shower systems
11:39:26 <shapr> kmc_: Yeah, ion3 is why I switched to xmonad.
11:39:27 <cheater2> i'm not sure what that has to do with 'playing' :)
11:39:30 <domor> oh I played tremulous before. I had to google it to remember what it was :)
11:39:34 <Zao> kmc_: Personally I haven't been bothered to remove key bindings that annoy me, as setting up a filter to get rid of them exceeds the mental capacity I'm willing to allocate when annoyed.
11:39:37 <kmc_> i still prefer ion3's static layout
11:39:43 <sshc> trem is an annoying abbv. of Tremulous
11:39:57 <sshc> which is an awesome but not "user-friendly" game
11:40:04 <shapr> Nobody's messed with the TCP/IP stack in House?
11:40:18 <temoto> > let f y x:xs = y + x in f 0 [1]
11:40:19 <sshc> they might be getting a better UI in the next *final* version, though
11:40:19 <lambdabot>   <no location info>: Parse error in pattern
11:40:23 <MissPiggy> sorry shapr
11:40:35 <cheater2> ah, a 3d game?
11:40:39 <temoto> > let f y (x:xs) = y + x in f 0 [1]
11:40:39 <cheater2> looks fun.
11:40:39 <lambdabot>   1
11:40:45 <shapr> ddarius: Have you ever messed with the TCP/IP stack from House?
11:40:50 <olsner> shapr: I have! ... not
11:41:02 <Zao> I hear that there's a TCP/IP stack in House. Too bad no-one asks about it.
11:41:04 <shapr> olsner: bah, det skiter mig :-/
11:41:07 <shapr> Zao: haha
11:42:32 <sshc> cheater2: yes, with a community whose collective iq is almost as much as a bushel of broccili.  for the most part
11:42:37 <Polarina> shortcircuit, vi ikke forstår dit sprog, snakke engelsk!
11:42:53 <Polarina> s/shortcircuit/shapr/
11:43:09 <shapr> Oh no, dansk!
11:43:13 <sshc> cheater2: if you do decide to play it, play the beta aka GPP :)
11:43:16 <shapr> Polarina: I'm from the Swedish speaking part of Alabama.
11:43:26 <Polarina> shapr, no excuse. :)
11:44:04 <cheater2> sshc: haha
11:44:43 <temoto> @src foldl
11:44:43 <lambdabot> foldl f z []     = z
11:44:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:45:05 <sshc> cheater2: you'll find most of the decent players playing the beta
11:45:13 <sshc> it's much more balanced, anyhow
11:47:39 <Polarina> House?
11:47:59 <sshc> House.
11:48:03 <Polarina> What's that?
11:48:07 <Raevel> House!
11:48:11 <Polarina> ?
11:48:13 <Valodim> Roadhouse.
11:48:14 <sshc> House is an operating system written in Haskell.
11:48:20 <Polarina> Valodim, lol.
11:48:25 <Polarina> sshc, o.O
11:48:55 <sshc> It is a very exciting project
11:48:59 <sshc> I hope it goes well!
11:49:10 <Polarina> Driver support and difficulties will kill it.
11:49:40 <sshc> We've got some Haskell lovers that won't let it die :)
11:49:48 <Polarina> Hehe.
11:50:25 <Polarina> On the other hand, a complete operating system with software only written in haskell would be useful.
11:50:38 <lament> Polarina: useful how?
11:50:45 <Polarina> lament, as in, being cool.
11:50:49 <sshc> bug-free!
11:50:52 <sshc> effecient, and whatnot
11:50:54 <Polarina> sshc, :D
11:51:23 <lament> sshc: because haskell makes it impossible to write inefficient, buggy programs!
11:51:39 <sshc> correct
11:51:41 <sshc> well, not impossible
11:51:46 <sshc> but pretty darn tough
11:51:49 <lament> provably impossible
11:52:05 * MissPiggy never understood 'provably'
11:52:07 <Polarina> Well, at least very difficult.
11:52:07 <sshc> alright
11:52:13 <sshc> then prove it :)
11:52:33 <sshc> actually, I've got some counter-examples
11:52:35 * Polarina is compiling ghc 6.12.
11:52:48 <sshc> of poorly-written haskell programs intentionally ineffiecent
11:53:00 <lament> Polarina: flon's law
11:53:10 <Polarina> lament, flon's law?
11:53:13 <sshc> of course, you're almost always aware that you shouldn't be doing what you're doing when what you're doing is what you should'nt be doing
11:53:25 <lament> Polarina: flon's law.
11:53:27 <McManiaC> meeeeh
11:53:33 <kmc_> @google flon's law
11:53:34 <Polarina> lament, what's that?
11:53:34 <lambdabot> No Result Found.
11:53:47 <McManiaC> whats the easiest way to locate a "undefined"?
11:54:04 <sshc> loch?
11:54:31 <tensorpudding> locate it where?
11:54:47 <tensorpudding> maybe grepping your source files?
11:54:49 <sshc> in its source
11:54:58 <sshc> at runtime
11:55:08 <sshc> he doesn'nt want to grep
11:55:21 <McManiaC> in a lib
11:55:31 <aavogt> grep the lib
11:55:47 <cheater2> Twey: that was an interesting read (the email about happstack) - thanks
11:55:54 <sshc> perhaps there are too many undefineds in there to have grep be effective
11:56:04 <tARrAScH> I've got a function that's creating a list by occasionally doing a 'myitem : recursefunciton'. Yet I don't get a lazy evaluation, for example when I create an ifinite list I can't use head on my function to get the first element. Any common mistakes that I might've done?
11:56:14 <cheater2> Twey: can happstack scale out, sharing a persistence lawyer between nodes/servers/computers?
11:56:16 <aavogt> then I suspect that the library is probably too undefined to be effective, sshc :)
11:56:40 <sshc> probably
11:56:48 <McManiaC> the grep isnt very usefull…
11:56:54 <McManiaC> src/Graphics/Vty.hs:90:    last_pic_ref <- newIORef undefined
11:56:54 <kmc_> tARrAScH: can you put the code on hpaste?
11:56:54 <sshc> and grep would probably be effective in some cases
11:57:02 <sshc> but ignoring grep, is it possible to locate undefined?
11:57:04 <tARrAScH> kmc_- sure
11:57:08 <McManiaC> hmmm
11:57:15 <tARrAScH> !paste
11:57:19 <sshc> the '98 standard recommends compilers to print out the location of undefineds
11:57:23 <sshc> which GHC does not do
11:57:26 <sshc> but it should
11:57:32 <tARrAScH> how do i get the paste-site from the bot :p ?
11:57:33 <Polarina> GHC's evil.
11:57:33 <McManiaC> I recommand http://npaste.de :>
11:57:37 <McManiaC> :D
11:58:03 <McManiaC> (my own haskell pastebin :)
11:58:31 <kmc_> @where hpaste
11:58:31 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
11:58:36 <kmc_> tARrAScH: ^^^^
12:00:10 <tARrAScH> http://npaste.de/FI/
12:00:20 <McManiaC> http://npaste.de/FI/hs
12:00:21 <McManiaC> ;)
12:00:32 <tARrAScH> ^^
12:01:07 <tARrAScH> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16880#a16880
12:01:17 <tARrAScH> with colour :)
12:01:26 <burp> http://npaste.de/FI/hs ← also with color
12:02:09 <burp> ok hpaste has more color :P
12:02:18 <aavogt> lazy in which variable?'
12:03:10 <tARrAScH> the result of run_ , running "head $ run_ ..." will run forever even though lines are created
12:03:37 <canoz> Hey, i'm new to haskell and programming and i'm wondering if you guys/girls could recommend me a good text editor.
12:04:21 <McManiaC> evil… Graphics.Vty has a undefined where a Nothing should be…
12:04:44 <McManiaC> so when you start up Vty and do any updates you get Prelude.undefined error…
12:04:50 <kmc_> canoz: vim and emacs are two popular text editors for programmers
12:04:52 * McManiaC wonders if no one ever used this :S
12:04:59 <kmc_> powerful with a somewhat steep learning curve
12:05:22 <aavogt> McManiaC: maybe you're missing some initialization that everybody else does?
12:05:36 <aavogt> but I have not used that library
12:06:03 <canoz> hmm okay, thanks.
12:06:47 <McManiaC> aavogt: http://hackage.haskell.org/packages/archive/vty/4.2.1.0/doc/html/Graphics-Vty.html doesnt show a lot of "initialization functions"
12:06:54 <McManiaC> 0. initialize vty
12:06:54 <McManiaC> 1. use the update equation of Vty to display a picture
12:06:55 <McManiaC> 2. repeat
12:07:02 <McManiaC> and update calls undefined :>
12:08:13 <tARrAScH> would it help if i pasted my hold project?
12:10:27 <Polarina> I just installed ghc 6.12 and it doesn't contain breakSubstring in Data.ByteString.Lazy -- why?
12:10:50 <aavogt> tARrAScH: foldl can't return on infinite lists
12:11:02 <aavogt> @src foldl
12:11:02 <kmc_> Polarina: but it does contain that module?
12:11:03 <lambdabot> foldl f z []     = z
12:11:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:11:11 <Polarina> kmc_, I can import it.
12:11:16 <kmc_> okay
12:11:18 <kmc_> maybe it was moved
12:11:18 <Zao> Polarina: There's one in Data.ByteString.Char8
12:11:26 <Zao> I do not believe it exists for all the variants.
12:11:28 <Polarina> .Char8? o.O
12:11:38 <Zao> Polarina: Yes, the one that's more text friendly.
12:11:50 <Polarina> Why does this all have to be so complicated?
12:11:56 <Zao> Which also has split :: Char -> BS -> (BS,BS) or somesuch.
12:11:56 <Polarina> I just want to split a damn string. :(
12:11:57 <aavogt> tARrAScH: the only way you get the accumulator out, is when foldl reaches the end of the list.... but you give foldl1 the result of cycle which has no end
12:12:02 <Zao> Instead of the less useful Word8 one.
12:12:08 <tARrAScH> aavogt: is there like foldl_associative() or something that could help me out here?
12:12:32 <kmc_> Polarina: you can use the "split" package, with pack/unpack
12:12:37 <aavogt> tARrAScH: foldr?? Or you have to associate (==>) to the left?
12:12:42 <kmc_> that'd be simple albeit slower
12:12:44 <Polarina> ghc is supposed to provide that function, where is it?
12:12:55 <kmc_> Polarina: where do you see that GHC 6.12.1 is supposed to provide it?
12:13:03 <Polarina> kmc_, documentation.
12:13:03 <opqdonut> tARrAScH: use foldr and then tack on the last value
12:13:07 <kmc_> Polarina: link?
12:13:08 <tARrAScH> @src foldr
12:13:09 <lambdabot> foldr f z []     = z
12:13:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:13:32 <tARrAScH> opqdonut: tack :p ?
12:13:38 <opqdonut> well, operate
12:13:49 <opqdonut> > foldr1 (*) [2,3,5] * 8
12:13:50 <lambdabot>   240
12:13:53 <opqdonut> ta-dah
12:13:56 <det> shapr, Stop triggering my nickname alert!
12:14:20 <Zao> Seems to be in Data.ByteString too.
12:14:21 <Polarina> kmc_, http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v%3AbreakSubstring
12:14:28 <Zao> Polarina: That's not the Lazy one.
12:14:36 <Polarina> Why can't the lazy one break?
12:15:08 <shapr> det: What did I do?
12:15:20 <kmc_> Polarina: i don't know about why it "can't".  but if you look in the documentation for Data.ByteString.Lazy, the function is not there
12:15:22 <shapr> det: Oh, the Swedish...
12:15:26 <det> Yes :-)
12:15:28 <Polarina> :(
12:15:49 <Zao> Polarina: It also lacks breakEnd, findSubstring, etc.
12:15:51 <tARrAScH> wait a second ... foldr with a non-commutative function, won't I need to reverse the list then?
12:15:56 <Polarina> :(
12:16:12 <Zao> I'd reckon that it's not horribly sane to have algorithms that depend on having the whole string available to work on.
12:16:14 <opqdonut> tARrAScH: no
12:16:21 <Zao> Using those on a lazy one would force a lot.
12:16:28 <opqdonut> > foldr1 f [x,y,z]
12:16:29 <lambdabot>   f x (f y z)
12:16:31 <opqdonut> > foldl1 f [x,y,z]
12:16:32 <lambdabot>   f (f x y) z
12:16:44 <opqdonut> tARrAScH: see, same order of elements, just differently associated
12:17:01 <tARrAScH> yep :)
12:17:15 <tARrAScH> you're right, thanks buddy!
12:18:13 <monochrom> I can see "splitAt" in Data.ByteString.Lazy
12:18:56 <tARrAScH> Works like a charm, thanks again!
12:19:27 <Zao> I gave a crash course on Haskell today. You tend to forget that not everyone knows what "nub" and "intercalate" means :)
12:19:51 <temoto> Does agda have type classes too?
12:20:06 <dolio> No.
12:20:43 <aavogt> @type intercalate nub
12:20:44 <lambdabot>     Couldn't match expected type `[a]'
12:20:44 <lambdabot>            against inferred type `[a1] -> [a1]'
12:20:44 <lambdabot>     In the first argument of `intercalate', namely `nub'
12:20:57 <aavogt> @type intercalate.nub
12:20:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [a]
12:22:30 <Veinor> I don't like the name of intercalate.
12:22:56 <Veinor> but, I suppose join is taken :P
12:23:17 <osfameron> "hmmm, join is taken.  let's call it intercalate"
12:23:34 <aavogt> join could be overloaded :)
12:23:38 <osfameron> I don't think I've ever heard anyone use the word
12:24:07 <osfameron> "intercalare" in italian sounds vaguely familiar
12:24:33 <pikhq> When I first heard "intercalate", I just grinned and thought "man, what a great function name."
12:24:35 <osfameron> the definition on merriam-websters doesn't even sound that close: "to insert between or among existing elements or layers"
12:25:56 <Zao> It's supposedly a term from chemistry.
12:25:58 <osfameron> 'conjoin' might have been better
12:26:09 <Zao> Where you force bits of molecules into other molecules.
12:26:14 <Zao> In say, DNA.
12:26:25 <wnoise> osfameron: isn't that exactly what intercalate does?  It inserts the first argument between the elements of the second list (of lists).
12:26:35 <Zao> osfameron: Does that have a dual or ... twin function.
12:26:48 <osfameron> wnoise: doesn't suggest that it does it more than once
12:26:54 <lament> python calls it 'join'
12:27:09 <Zao> Python calls a lot of things things they're not.
12:27:16 <Zao> @type join
12:27:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:27:47 <lament> Zao: it makes sense in Python
12:28:07 <Zao> As they have member functions, sure.
12:28:31 <wnoise> intersperse is a good name, but also taken.  I'm not entirely sure that we really need a name for "concat.intersperse", but I can't think of a really good one that's not taken.
12:28:33 <Zao> Heh, their map seems to be some weird generic zipping doohickey.
12:28:38 <dolio> Isn't it 'str.join(array)', though?
12:28:54 <lament> dolio: why the though?
12:29:19 <dolio> I'd expect it to be 'array.join(str)'.
12:29:19 <kmc_> iirc OCaml also calls zipWith, zipWith3, etc. as map2, map3, etc.
12:30:54 <wnoise> python (and dynamic languages in general) do a lot of magically treating single elements as lists of length one.  Unfortunately, this means we need more names.
12:31:41 <mauke> lisp's map is also zippy
12:31:44 <tensorpudding> we're going to need a bigger namespace...
12:31:49 <mauke> (and perl's map is concatMap)
12:32:40 <tensorpudding> dynamic typing allows you to get around the differences in map and zipWith
12:32:52 <MissPiggy> so does dependent type
12:32:55 <tensorpudding> that doesn't explain the ocaml one
12:34:52 <wnoise> osfameron: No, but it doesn't rule it out, either.
12:38:30 <kmc_> eh, map3 and zipWith3 seem like equally good names to me
12:39:12 <wnoise> (Oh, right, arity.  intercalate = (concat .) . intersperse)
12:39:24 <kmc_> i'd rather write "map3 (,,)" than "zip3"
12:39:36 <aavogt> I've seen fmap2 = liftA2
12:39:43 <kmc_> heh
12:39:48 <kmc_> :t liftA2
12:39:49 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:40:01 <kmc_> fmap works on any Functor, though
12:40:12 <aavogt> though whether that is a zip or something else depends on what the f is
12:52:55 <Phyx-> Hi, i'm having some trouble with hsc2hs, either i'm not reading the documentation right or.. http://phyx.pastebin.com/d13b20804 (snippit from documentation is there too)
12:55:10 <Zao> Phyx-: The problem being?
12:56:09 <Phyx-> Zao: that i was expecting what's after the "=" being the names, not "hs_name"
12:57:22 <Zao> That could be handy, indeed.
12:58:03 <Zao> Phyx-: #enum Int,,cSelectorFirst = CALLED_IN_C,cSelectorSecond = FOO
12:58:19 <Zao> Phyx-: You explicitly say "the haskell name should be hs_name, BY GOD!"
12:58:34 <Phyx-> hmm
12:58:41 <Zao> "hs_name" and "c_value" are intended as placeholders, not keywords.
12:59:18 <Phyx-> ok, let's try
12:59:46 <Phyx-> Zao: well, the documentation explicitly mentions that c_value is a placeholder, so i didn't put thought into that hs_name might be too
13:00:55 <Zao> Hehe.
13:10:37 <mgsloan> is Data.Map.toList lazy?
13:13:06 <Phyx-> Zao: grr, still gives a weird result, oh well, guess i'll write a "toHscNotation" function to convert to hsc's wacky notation
13:13:20 <mgsloan> I guess it must be
13:14:28 <monochrom> lazy in producing list
13:14:45 * Zao pets bindings-DSL.
13:14:53 <Zao> Made my life better, and improved my teeth.
13:15:51 <dang`r`us> Does it prolong erections?
13:16:24 <monochrom> That's the job of the blue pill.
13:17:41 <Zao> The API I wrap is about 800 functions, and counting.
13:18:00 <Zao> It's nice being to generate trivial things.
13:19:42 <Saizan> do we have a decent way to share/install .ghci scripts?
13:20:41 <Polarina> I am making a library and have a function that takes a string, but that string may not contain any whitespace (0x20) -- what to do?
13:20:55 <Zao> filter?
13:21:09 <dobblego> @hoogle ZipList
13:21:09 <lambdabot> Control.Applicative newtype ZipList a
13:21:09 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
13:21:09 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
13:21:23 <Zao> Make a guard that not . any (==' ') ?
13:21:32 <lispy> Polarina: I'd newtype string and have something like newtype PolarinaString = PS String
13:21:42 <Polarina> PS String?
13:22:14 <Zao> lispy: I wonder if you could modify the -XOverloadedStrings' isString to enforce that invariant.
13:22:32 <monochrom> don't do anything
13:22:33 <lispy> Polarina: and then export a function like, mkPolarinaString :: String -> PolarinaString.  And that function ensures that the constructed string has no whitespace
13:22:45 <Polarina> lispy, ok, thanks.
13:22:50 <lispy> Polarina: yeah, PS is the name of the constructor
13:22:54 <Paczesiowa> this clearly needs GADT Char type, with phantom type telling if the character could be space.
13:22:55 <b0fh_ua> Hello! Can somebody please advice, how can I pass some options to configure script, invoked by cabal on building "curl" package for haskell?
13:22:58 <lispy> Polarina: call it whatever you like :)
13:24:37 <Polarina> I am making a IRC bot and would like to be able to load and unload "extensions" run-time. What's a good way to do that?
13:24:55 <Paczesiowa> Polarina: hsplugins
13:25:03 <Polarina> Paczesiowa, link?
13:25:28 <Paczesiowa> Polarina: http://hackage.haskell.org/package/plugins
13:25:33 <Polarina> Thanks.
13:25:56 <Polarina> Any quick-start guides on how to use it?
13:26:13 <Paczesiowa> Polarina: the last time I used it was 6.8, don't know if it still works
13:26:26 <Paczesiowa> Polarina: and it was linux only then
13:26:31 <Polarina> o.O
13:26:35 <Polarina> Anything portable?
13:26:41 <mauke> http://github.com/rcaputo/bot-workbench
13:27:06 <Paczesiowa> Polarina: you could use hint
13:27:12 <Polarina> A hint?
13:27:20 <Twey> Polarina: Hint works, too
13:27:26 <Polarina> What's that?
13:27:51 <Twey> Also Dyre (not quite the same concept, but you can do the same with it)
13:28:20 <Paczesiowa> Polarina: loading is easy, just read the file with haskell sources of extension, parse and eval it to your type. unloading is like your custom unregistering and the rest is for garbage collector.
13:28:42 <Paczesiowa> Polarina: http://hackage.haskell.org/package/hint
13:28:43 <Polarina> How do I parse and eval it?
13:28:51 <cads> hey docs, I want to code a little interactive 2d orbit simulator, think a black screen with some large white filled circles serenely orbiting each other, bumping around, and avoiding the mouse cursor. What library would you guys suggest for the graphics and interaction?
13:29:45 <Paczesiowa> Polarina: http://code.haskell.org/hint/devel/examples/
13:31:32 <jmcarthur> cads: sdl/glut/glfw and opengl?
13:31:50 <Zao> Direct3D!
13:31:58 <jmcarthur> cads: actually, maybe something like graphics-drawingcombinators instead of opengl
13:32:01 <Zao> (although my bindings are not released yet)
13:32:02 <Polarina> Zao, NO!
13:32:05 <cads> I was looking at http://code.haskell.org/diagrams/example/examples.html
13:32:13 <Zao> Some fancy high-level abstractions are probably beneficial though.
13:32:17 <jmcarthur> does diagrams do animations?
13:32:22 <cads> not that I can tell
13:32:26 <Zao> Polarina: I'll dedicate it to you.
13:32:40 <jmcarthur> graphics-drawingcombinators is probably a good choice
13:32:53 <jmcarthur> i think currently it handles the SDL stuff for you, too, but i don't remember
13:33:05 <jmcarthur> i recall that it at least has some sdl-specific stuff in it
13:33:14 <cads> jmcarthur, I can use a sdl library but I would like to try a higher level approach - combinators and maybe even FRP
13:33:25 <cads> I'll check out graphics-drawingcombinators
13:33:58 <jmcarthur> cads: okay, that will handle the graphics abstractly enough for you i think. as for frp, there are a lot of libraries each with advantages and disadvantages
13:39:08 * gwern rues how long PAR2 ECC files take to make, and how long it takes to burn DVDs
13:39:23 <gwern> (and I'm not even backing up very much)
13:41:41 <Polarina> cabal: failed to parse output of 'ghc-pkg dump'
13:41:46 <Polarina> What to do?
13:42:05 <Zao> Polarina: Ensure you have the right Cabal and cabal-install version?
13:42:20 <Polarina> I have what came with debian squeeze.
13:42:48 <Polarina> 0.6.2
13:43:07 <Paczesiowa> cabal install cabal-install
13:43:09 <cads> jmcarthur, my mainstays have been rubySDL + C, and Java's Processing libraries. I'm excited to experiment with graphics in a functional language! Yeah, the frp situation seems like a lot of different approaches rahter than anything unified, but it's a pretty inspiring direction, imo.
13:43:43 <jmcarthur> cads: yeah, i'm involved in the movement, but not yet satisfied
13:44:04 <Polarina> Paczesiowa, same error.
13:44:07 <jmcarthur> cads: another functional graphics library to check out would be fieldtrip, but it seems to not be building properly, according to hackage
13:47:20 <Lemmih> Polarina: Using ghc-6.12?
13:47:26 <Polarina> Yes.
13:47:30 <Lemmih> Polarina: Don't.
13:47:34 <Polarina> Too late.
13:47:51 <benmachine> 6.12 is awesome and I love it
13:48:12 <benmachine> but that is because I am easily impressed by numbers increasing slightly
13:48:56 <Zao> As the lovely warning on the download page says, the world is not ready for 6.12.1 yet.
13:49:22 <fnord123> Hey all! W/ the new support for dynamic libraries coming out, can we look into reliscencing libraries as LGPL rather than BSD? Or is there still a lot of code juggling between libraries that keeps this murky?
13:49:30 <deech> I am a Haskell noob and I was wondering if there are any resources to get a handle on lazy evaluation. Aside from infinite data structures, what other advantages does it bring?
13:49:50 * hackagebot upload: hlint 1.6.17 - Source code suggestions (NeilMitchell)
13:50:15 <Lemmih> fnord123: Lots of people dislike LGPL.
13:50:17 <gwern> deech: on demand data structures; functions which neither know nor care about how something is being generated - streaming
13:50:24 <Polarina> deech, speed, cool I/O handling.
13:50:35 <jmcarthur> fnord123: i think a lot of the culture around haskell simply prefers BSD
13:51:02 <monochrom> But all those are under the umbrella of infinite data structures
13:51:32 <jmcarthur> i don't see it that way
13:51:35 <fnord123> weird. BSD just means people can repackage your code and sell it back to you with minor improvements. LGPL is much better for libraries.
13:51:38 <monochrom> So I just object to "aside from infinite data structures" to begin with.
13:51:45 <jmcarthur> fnord123: that is a subjective opinion
13:51:52 <deech> Polarina: I have read various articles which claim that lazy evaluation makes it harder to write efficient code. Because it's harder to predice performance.
13:52:01 <deech> monochrom: why?
13:52:07 <jmcarthur> fnord123: i prefer BSD because i don't like being told what to do with code i write, even if it uses code i didn't write
13:52:08 <MissPiggy> hey gwern, I thought about that problem some moe
13:52:10 <MissPiggy> more
13:52:11 <Polarina> deech, not really true.
13:52:26 <MissPiggy> I think the optimal thing to do is loop on   list   and   drop 3 list,
13:52:38 <MissPiggy> in terms of C that would mean having two pointers, one that is 3 steps ahead
13:52:38 <fnord123> Yes. And hopefully my subjective opinion, if explained elegantly, will convince people to use LGPL. :)
13:52:47 <MissPiggy> then you increment then simultaneously
13:53:06 <jmcarthur> fnord123: we can take it to -blah if you want, but i must warn you i am a tough sell and this is something i've thought a lot about
13:53:56 <tensorpudding> license debate time again?
13:54:17 <jmcarthur> tensorpudding: so it appears. maybe we can keep it civil?
13:54:41 <Lemmih> tensorpudding: It never ended, it was just halftime.
13:55:02 <MissPiggy> not if some lunatic comes in and shouts 'STOP ARGUING!!' even though nobody is
13:55:04 <Paczesiowa> jmcarthur: if you don't like "being told what to do with code i write, even if it uses code i didn't write", then only publicdomain should be acceptable
13:55:50 <jmcarthur> Paczesiowa: giving credit for code you didn't write doesn't really say much about what to do with the code that you did write
13:56:11 <aavogt> fnord123: BSD3 lets you relicence under LGPL
13:56:20 <aavogt> problem solved :)
13:56:59 <fnord123> I'm not interested in convincing everyone. Just interested in finding out if I release something as LGPL, can jmcarthur use it in his BSD liscenced code? afaik, this was not allowed previously since the linker did so much code mangling.
13:57:28 <jmcarthur> Paczesiowa: but really, there is a class of licenses which i see subjectively as sufficiently permissive, and i really just lean toward the simplest licenses of those
13:57:41 <jmcarthur> Paczesiowa: public domain is problematic though because some countries don't recognize public domain
13:58:05 <jmcarthur> Paczesiowa: so a minimal license keeps things sane in those cases
13:58:36 <Paczesiowa> jmcarthur: if something is in publicdoman, there is no problem in releasing it as bsd in those countries.
13:59:24 <jmcarthur> fnord123: ghc statically links libgmp (LGPL) anyway
13:59:45 <jmcarthur> fnord123: the static linking argument is treated different ways by different groups
13:59:47 <Paczesiowa> jmcarthur: there's pure Integer implementation
13:59:56 <jmcarthur> Paczesiowa: yeah, but that's not our default, is it?
14:00:03 <Paczesiowa> jmcarthur: no
14:00:08 <jmcarthur> Paczesiowa: you're right about the public domain thing
14:00:09 <fnord123> jmcarthur: oh really? I thought the main sticking point of using BSD in haskell was because of the linking issue.
14:00:35 <jmcarthur> fnord123: nah. we really just prefer BSD for the most part
14:00:39 <kmc_> you can now build a GHC that doesn't link libgmp into stuff it produces
14:00:55 <jmcarthur> fnord123: but that's "we" put very loosely. there are of course disagreements among us
14:01:05 <jmcarthur> kmc_: nice
14:01:17 <kmc_> thanks to IHG
14:03:25 <jmcarthur> fnord123: "And hopefully my subjective opinion, if explained elegantly, will convince people to use LGPL." ... "I'm not interested in convincing everyone."  ?
14:03:41 <benmachine> maybe just some people?
14:03:57 <jmcarthur> not trying to be a jerk. apparent contradictions just make me question my comprehension
14:03:59 <fnord123> yeah, some people.
14:04:03 <jmcarthur> ah okay
14:04:51 <fnord123> stop being so purely functional. I used a destructive update to the previous statement. </jocular>
14:05:00 <wnoise> jmcarthur: there's certainly a vocal contingent that prefres BSD.  I'm not sure I'd elevate it to the level of consensus.
14:05:31 <jmcarthur> wnoise: nah. i probably overstated that
14:06:10 <benmachine> my impression has been that BSD is the usual for haskell
14:06:28 <pikhq> Part of the reason for that is that LGPL makes static linking annoying.
14:06:40 <aavogt> > let x = 1 in let x = 2 in x -- fnord123, this is allowed
14:06:41 <lambdabot>   2
14:06:52 <pikhq> And GHC until very recently did static linking for everything.
14:07:07 <retroj> sorry for OT, but does anybody recognize the guy in the C/Javafans picture in http://www.spy.org/tmp/lang-by-sdy.jpg ?
14:07:27 <wnoise> I do in general prefer LGPL, but I think Haskell is currently in a position such that BSD is going to be more useful for keeping the community growing and active.
14:07:35 <jmelesky> BSD seems to be more popular in the professional world -- there are plenty of corporations that won't allow GPL'ed (and presumably LGPL'ed) code inside their walls
14:07:54 <pikhq> Probably just GPL'd code.
14:07:56 <Lemmih> retroj: RMS?
14:08:06 <pikhq> LGPL'ed code is really only problematic with static linking.
14:08:07 <kmc_> lots of corporations use GPL code
14:08:08 <fnord123> oh I work with a lot of server side stuff and we enjoy gpl
14:08:14 <kmc_> remember, most code is never released at all
14:08:34 <retroj> Lemmih: is it?  seems too rosy...
14:09:10 <jmelesky> kmc_: i know lots do use GPL, but lots ban it, too, for possibly irrational licensing fears
14:09:11 <domor`> retroj: RMS must have been younger before ;)
14:10:02 <Paczesiowa> domor`: nonsense
14:10:09 <retroj> i'm just not sure... the guy in the pic looks bald, but rms wears a part that could look bald from a certain angle
14:10:41 <domor> somehow my name backticks on reconnect, it seems..
14:10:49 <pikhq> That's quite a different UNIX beard.
14:10:55 <pikhq> Much more kempt.
14:11:10 <pikhq> The guy looks like he knows what soap is for.
14:11:14 <BCoppens> Ritchie?
14:11:20 <pikhq> Possible.
14:11:59 <BCoppens> http://en.wikipedia.org/wiki/File:Ken_n_dennis.jpg
14:12:18 <BCoppens> mmm that's not it
14:12:33 <retroj> ritchie's beard went white early
14:12:36 <BCoppens> kernighan neither, it seems
14:13:03 <shepheb> what picture are we talking about?
14:13:49 <retroj> shepheb: second column top row, http://www.spy.org/tmp/lang-by-sdy.jpg
14:13:56 <fnord123> I think it's thompson
14:14:31 <BCoppens> possibly
14:14:33 <retroj> fnord123, first name?
14:14:56 <BCoppens> Ken
14:15:03 <BCoppens> (obviously ;))
14:15:24 <jmcarthur> the guy in first column second row is a friend of a friend... regrettably
14:15:40 <retroj> jmcarthur: lol
14:16:51 <shepheb> could easily be Ken Thompson
14:17:22 <retroj> i can see the resemblance.... now looking for verification
14:18:25 <maskd> he kind of looks like dave eckhardt
14:20:00 <shepheb> I really like the Lisp/Haskell pairs, both of them.
14:25:35 <bt> i would love some help in understanding fold :: (a -> [b] -> b) -> Rose a -> b , eg what the functions expects to get / to do
14:25:47 <bt> oh and data Rose a = Node a [Rose a]
14:25:54 <bt> do clarify rose
14:25:55 <kmc_> well, we can't know what the function should do from its type alone
14:25:58 <kmc_> but i can guess
14:26:15 <mauke> it's a catamorphism
14:26:44 <bt> to be precise i couldnt find information what (  .. ) does here
14:26:59 <Twey> Groups
14:27:08 <Twey> Like it does everywhere else
14:27:39 <kmc_> fold f (Node x ts) = f x (map (fold f) ts)
14:27:41 <kmc_> i would guess
14:28:02 <kmc_> it applies f at every node in a bottom-up fashion, to reduce the tree to a single value of type "b"
14:28:15 <kmc_> each call gets the value at this node, plus the reduced values of all the children of that node as a list
14:28:55 <kmc_> yes, ( ... ) in the type indicates that (a -> [b] -> b) is the type of a single argument
14:29:25 <Twey> retroj: Haha, what's with the Tron guy?  And the cat?
14:29:39 <kmc_> fold takes a value of type (a -> [b] -> b) and a value of type (Rose a) and produces a value of type (b)
14:34:38 <Gracenotes> Twey: cats? where?
14:35:06 <Twey> http://www.spy.org/tmp/lang-by-sdy.jpg
14:35:10 <Twey> Haskell by Lisp
14:35:36 <Twey> I'm not entirely sure I get the Palin references, either :þ
14:36:01 <Gracenotes> as I've mentioned, the chart is inconsistent. some qualities describe the language, some the users, and others.. what the hell.
14:36:08 <zacharyp> Hi, say I have a list of Int, and I want the sum, but I know the sum will be Integer large.  Is this the best method: sum [ toInteger x | x <- intList]
14:36:35 <Twey> Heh, maybe so
14:36:36 <mauke> zacharyp: yes
14:36:56 <Gracenotes> and without list comprehensions, sum (map toInteger intList)
14:37:09 <Polarina> Why not use list comprehension?
14:37:09 <TomMD-TB> zacharyp: Perhaps a strict fold would be better to be sure the compiler does the right thing.
14:37:10 <kmc_> map is better imo, as you don't need to name "x"
14:37:43 <kmc_> it's more concise to say "toInteger applied over this list" than to say "toInteger applied to each x, where x is some element of this list"
14:38:01 <Gracenotes> list comprehensions are mostly useful in filtering by a single constructor, extracting info from it
14:38:25 <kmc_> imo, it's best to leave things as Integer in the first place, unless you have a specific reason not to
14:38:28 <kmc_> imo, Int should not be in Prelude
14:38:32 <Gracenotes> (also layered stuff)
14:38:59 <kmc_> imo imo imo
14:39:02 <pikhq> Polarina: List comprehensions are best when they are shorter and clearer than without.
14:39:07 <zacharyp> ok, thanks all :)  Mapping toInteger makes sense
14:39:44 <pikhq> sum (map toInteger intList) -- vs. sum [toInteger x | x <- intList]
14:41:10 <Twey> Hm, arguable
14:41:30 <Twey> They both look nice to me, though I don't like the extra x
14:42:13 <CalJohn> i much prefer the left
14:42:22 <pikhq> Of course, we all know the real answer is sum $ toInteger <$> intList.
14:42:40 <CalJohn> i am even tempted to prefer (sum . map toInteger) intList
14:42:42 <Twey> Yeah, that's nice
14:44:44 <zacharyp> as a note, using 'time' on the two versions of this, the list comprehension version runs in ~14 seconds, and the map version runs in ~17 seconds (ran both version 3 times with same timing)
14:44:55 <zacharyp> ymmv
14:45:15 <CalJohn> with 02?
14:45:17 <CalJohn> interesting
14:45:34 <CalJohn> *O2
14:46:09 <wnoise> What's the intList?
14:51:11 <kmc_> zacharyp: that's very surprising, the list comprehension should desugar to the map
14:51:13 <kmc_> did you build with -O2
14:53:53 <zacharyp> I'll try with -O2
14:57:40 <zacharyp> pretty much the same results, though it did speed up a bit for the map version, but still slower than the list comprehension
14:58:42 <mauke> @undo sum [toInteger x | x <- intList]
14:58:42 <lambdabot> sum concatMap (\ x -> [toInteger x]) intList
14:58:49 <mauke> this seems unlikely
14:59:21 <dolio> Heh.
15:01:17 <dolio> @undo zipWith f [ g x | x <- l1 ] [ h x | x <- l2 ]
15:01:17 <lambdabot> zipWith f concatMap (\ x -> [g x]) l1 concatMap (\ x -> [h x]) l2
15:03:21 <benmachine> needs more parentheses?
15:03:44 <benmachine> @undo [x | Just x <- xs]
15:03:45 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
15:04:43 <domor> if I'm not mistaken though, stream fusion doesn't like list comprehensions. for this kind of algorithm it may be relevant.
15:05:18 <benmachine> seems I have something in common with stream fusion
15:05:31 <bnijk_> why don't you like list comprehensions
15:05:44 <benmachine> they are a bit magic
15:05:50 <bnijk_> they ARE magic
15:05:52 <benmachine> and they don't make refactorings obvious
15:06:13 <benmachine> and mostly what you can do with them you can do with do notation
15:06:15 * bnijk_ sautees benmachine 
15:06:18 <benmachine> by mostly I mean solely
15:06:27 * bnijk_ garnishes benmachine 
15:06:40 * benmachine tastes delicious?
15:06:48 <domor> zacharyp: if you're going to time it, I'd be curious to see if there's a difference by using Data.List.Stream
15:06:49 <bnijk_> you can do it with do notation - in like, three hundred lines
15:06:55 <benmachine> pfft
15:06:59 <benmachine> one line per clause at most
15:07:11 <bnijk_> there's no point ;)
15:07:16 <benmachine> there is!
15:07:20 <bnijk_> high level = make things easier
15:07:20 <benmachine> one less kind of syntax to learn
15:07:33 <bnijk_> but you already know it
15:07:39 <benmachine> sugar is not more or less high level
15:07:44 <benmachine> it's just shinier
15:07:54 <benmachine> but I prefer consistency
15:08:00 <bnijk_> semantics
15:08:16 <benmachine> no I mean, sugar doesn't give you any additional power
15:08:32 <bnijk_> i know what you meant ;)
15:08:42 <benmachine> list comprehensions are a special case and special cases are for silly people
15:08:57 <nus> benmachine, it does, especially when mixed up with chocolate :-P (-;
15:09:05 <aavogt> > [ () | False ]
15:09:06 <lambdabot>   []
15:09:07 <benmachine> yeah it burns quite well?
15:09:16 <benmachine> > guard False :: [()]
15:09:17 <lambdabot>   []
15:09:18 <nus> seriously, some people think in list comprehensions too much
15:09:24 * bnijk_ prefers syntactic broccoli
15:09:25 <domor> I learned something interesting about that last week. Try writing something like [ f x y | x <- [1..100], y <- [200..300] ] without using the list comprehension
15:09:36 <bnijk_> i something to the finish, cause i eat lots of spinach
15:09:37 <aavogt> @undo [ () | False ]
15:09:38 <lambdabot> if False then [()] else []
15:09:38 <benmachine> the neat thing about using guard and friends is that you can easily switch to Maybe
15:09:43 <benmachine> or more easily at least
15:10:13 <aavogt> domor: in terms of the order?
15:10:31 <benmachine> domor: f <$> [1 .. 100] <*> [200 .. 300], unless I'm missing something
15:10:51 <aavogt> > [ (x,y) | x <- "abc", y <- "de" ]
15:10:52 <lambdabot>   [('a','d'),('a','e'),('b','d'),('b','e'),('c','d'),('c','e')]
15:11:06 <aavogt> > do x <- "abc", y <- "de"; return (x,y)
15:11:07 <lambdabot>   <no location info>:
15:11:07 <lambdabot>      The last statement in a 'do' construct must be an ...
15:11:14 <aavogt> > do x <- "abc"; y <- "de"; return (x,y)
15:11:15 <lambdabot>   [('a','d'),('a','e'),('b','d'),('b','e'),('c','d'),('c','e')]
15:11:16 <domor> yes, or with liftM2 - IMHO more elegant than the comprehension, although less obvious
15:11:31 <benmachine> less obvious is a matter of perspective :P
15:11:42 <benmachine> haskell is probably not the most obvious language in that regard
15:12:07 <retroj> Twey: Tronguy is famous, apparently.  lots of stuff about him on the web...
15:13:18 <domor> > liftM2 (,) [1,3] [3,5]
15:13:19 <lambdabot>   [(1,3),(1,5),(3,3),(3,5)]
15:13:36 <benmachine> > liftA2 (,) [1,3] [3,5]
15:13:37 <lambdabot>   [(1,3),(1,5),(3,3),(3,5)]
15:13:38 <benmachine> :P
15:13:43 <domor> hah
15:13:53 <domor> I need to learn to use applicative too..
15:14:02 <benmachine> it's pretty neat
15:15:29 <domor> > (,) <$> [1,2] <*> [3,4]
15:15:30 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
15:15:31 <pikhq> > (,) <$> [1,3] <*> [3,5]
15:15:32 <lambdabot>   [(1,3),(1,5),(3,3),(3,5)]
15:16:15 <domor> :t (,) <$> [1,2]
15:16:16 <lambdabot> forall a b. (Num a) => [b -> (a, b)]
15:18:59 <nus> :t (<$>)
15:19:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:21:46 <ziman> @pl \x -> f <$> g x
15:21:47 <lambdabot> (f <$>) . g
15:21:56 <Polarina> Applicatives are incomprehensible. :(
15:22:02 <kmc_> nope
15:22:06 <Polarina> Yes.
15:22:15 <kmc_> counterexample: i comprehend them
15:22:25 <Polarina> Who's counterexample?
15:23:02 <benmachine> me I am
15:23:07 <Polarina> ...
15:23:09 <benmachine> > [1 ..]
15:23:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:23:11 * Polarina cries.
15:23:11 <kmc_> (f <$> x <*> y <*> z)    ==>   do { x' <- x; y' <- y; z' <- z; return f x' y' z' }
15:23:15 <kmc_> that covers many of the use cases
15:23:23 <kmc_> err
15:23:24 <bnijk_> > [1,1.6666..3000]
15:23:24 <lambdabot>   [1.0,1.6666,2.3332,2.9998000000000005,3.6664000000000008,4.333000000000001,...
15:23:27 <kmc_> return (f x' y' z')
15:23:30 <bnijk_> hurr durr
15:23:49 <Polarina> kmc_, sounds useless.
15:23:54 <bnijk_> @hurr
15:23:54 <lambdabot> Maybe you meant: arr url yarr
15:23:56 <kmc_> Polarina: then you comprehend it
15:23:57 <bnijk_> > hurr
15:23:58 <lambdabot>   "durr"
15:24:03 <Polarina> kmc_, I don't.
15:24:04 <bnijk_> > hurr + durr
15:24:05 <lambdabot>   Not in scope: `durr'
15:24:08 <Becquerel> @yarr
15:24:08 <lambdabot> I heard andersca is a pirate
15:24:09 <bnijk_> > hurr ++  "durr"
15:24:10 <lambdabot>   "durrdurr"
15:24:17 <kmc_> i don't think it's useless, but i don't think you can have an opinion on whether it's useless if you don't understand it
15:24:18 <bnijk_> great...
15:24:27 <kmc_> @. elite nixon
15:24:27 <lambdabot> a pU8|Ic MAn mu5t NEVer fORg3t tHA+ |-|e 1oses |-|Is usephU1n35z0rz wh3n |-|e Az 4n INDivIdUaL, Ra7h3R tHAN hi$ PO|i(y, be(0/\/\e$ T|-|e ISzue.
15:24:36 <bnijk_> what the
15:24:55 <benmachine> Polarina: everything applicatives can do can be done with monads except for sometimes
15:25:02 <Polarina> ...
15:25:07 <kmc_> err, many Applicatives are not Monads
15:25:12 <benmachine> except that yes
15:25:14 <benmachine> right
15:25:18 <benmachine> I explained that badly
15:25:24 <bnijk_> french fries
15:25:25 <kmc_> anyway, Polarina, if you have a question about Applicative i'm happy to attempt to answer it
15:25:26 <bnijk_> eat french fries
15:25:31 <bnijk_> kill yourself
15:25:33 <bnijk_> kill yourself
15:25:36 <Polarina> kmc_, what are applicatives?
15:25:43 <kmc_> Applicative is a typeclass
15:25:44 <kmc_> @src Applicative
15:25:44 <lambdabot> class Functor f => Applicative f where
15:25:45 <lambdabot>     pure  :: a -> f a
15:25:45 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
15:25:53 <jfoutz> applicatives have fewer constraints than monads. there are more things that you can stuff into an applicative than things that you can stuff into a monad.
15:26:10 <Polarina> I don't know what monads are.
15:26:14 <benmachine> the similarity between <*> and fmap is interesting
15:26:20 <kmc_> Monad is another typeclass
15:26:21 <kmc_> @src Monad
15:26:22 <lambdabot> class  Monad m  where
15:26:22 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:26:22 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:26:22 <lambdabot>     return      :: a -> m a
15:26:22 <lambdabot>     fail        :: String -> m a
15:26:24 <benmachine> @where typeclassopedia
15:26:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:26:26 <bnijk_> > kill live "living"
15:26:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:26:28 <lambdabot>         against inferred ty...
15:26:35 <mauke> > "ap" `isSuffixOf` "fmap"
15:26:36 <lambdabot>   True
15:26:38 <mauke> BAM
15:26:41 <kmc_> yes, Typeclassopedia would be a good read
15:26:42 <jfoutz> typeclasopedia is AWESOME
15:26:53 <benmachine> agreed
15:26:56 <Polarina> ?
15:26:56 <benmachine> mauke: nice
15:27:03 <bnijk_> oic
15:27:04 <bnijk_> > live $ kill "living"
15:27:05 <lambdabot>   "living"
15:27:11 <bnijk_> fascinating
15:27:21 <mauke> clearly map is monadic ap
15:27:22 <benmachine> Polarina: the typeclassopedia is a thing that someone wrote that gives an introduction to a bunch of typeclasses
15:27:29 <Polarina> benmachine, oh.
15:27:30 <kmc_> Polarina: what good is it to say "?" or "..."?
15:27:47 <jfoutz> Polarina: it just explains all those crazy classes in a very nice way. Monoid, Applicative, Monad, etc... takes you through the whole zoo.
15:27:48 <mauke> ⁇  -- optimized
15:27:49 <Polarina> kmc_, it means that someone just said something incomprehensive.
15:28:04 <kmc_> it helps when you explain which part you don't understand
15:28:11 <Polarina> Everything.
15:28:15 <benmachine> heh
15:28:17 <kmc_> it helps even just to clarify to which comment you refer
15:28:20 <kmc_> as this channel is often quite busy
15:28:22 <bnijk_> with yellow eyes, my green face, my pink and white afro
15:28:26 <mauke> …
15:28:28 <bnijk_> i'm no toy kid your style is made by hasbro
15:28:35 <bnijk_> gniff gnapp you think you got that real hip hop
15:28:41 <mauke> bnijk_: wrong window
15:28:42 <Polarina> I don't know what a typeclass is. :(
15:28:48 <bnijk_> i saw the chart so quickly watched your album flop
15:28:55 <kmc_> Polarina: then why are you trying to understand Monad and Applicative?
15:28:59 <bnijk_> Polarina: it's a class of types
15:29:07 <Polarina> bnijk_, A class?
15:29:08 <mauke> Polarina: I'd start with Eq, Ord, Show, then maybe Functor
15:29:15 <bnijk_> not a literal class
15:29:19 <bnijk_> same idea tho
15:29:21 <kmc_> not a class like OO
15:29:26 <mauke> not like school
15:29:27 <Polarina> What then?
15:29:35 <kmc_> Polarina: have you read any Haskell tutorials?
15:29:39 <mauke> Polarina: like an interface
15:29:42 <jfoutz> like an interface in java, if you've used that.
15:29:43 <Polarina> kmc_, I've read learnyouahaskell.
15:29:44 <bnijk_> it's very intuitive ;)
15:29:46 <kmc_> they typically explain typeclasses pretty well
15:29:53 <bnijk_> BONUS needs to finish that thing
15:30:04 <kmc_> Polarina: so, did you read the section on typeclasses in LYAH?
15:30:17 <Polarina> kmc_, yes, I have. It's very steep.
15:30:23 <kmc_> okay
15:30:24 <bnijk_> are french fries any good with soy sauce?
15:30:25 <Polarina> Too steep.
15:30:30 <kmc_> we can help you get through it
15:30:31 <bnijk_> i'm gonna try it...
15:30:45 <kmc_> but you should not despair of not understanding Monad or Applicative until you understand typeclasses
15:30:53 <Polarina> Ok.
15:30:55 <kmc_> since Monad and Applicative are two examples of a typeclass
15:31:22 <kmc_> there are two ways to answer the question "What is a Monad?".  one is "An instance of the typeclass named Monad"
15:31:27 <kmc_> the other is bullshit analogies
15:31:33 <hzap> two examples of very weird typeclasses
15:31:40 <kmc_> in what way are they weird?
15:31:54 <Polarina> What?
15:31:58 <hzap> they abstract over type constructors, which might be weird
15:32:03 <kmc_> that's true
15:32:15 <mauke> Polarina: so do you know (==) ?
15:32:21 <Polarina> mauke, yes.
15:32:26 <kmc_> @type (==)
15:32:27 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:32:27 <benmachine> bullshit analogies++
15:32:33 <mauke> Eq is a typeclass
15:32:36 <kmc_> @quote explanation
15:32:36 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
15:32:45 * benmachine giggles
15:32:48 <det> When using parser combinators, how does one usually ignore whitespace ?
15:32:53 <hzap> lol!
15:32:58 <kmc_> det: depends which combinator library
15:33:00 <mauke> Polarina: that type says, (==) can take two values of any type that is an instance of Eq
15:33:11 <Polarina> mauke, understood.
15:33:21 <mauke> @src Eq
15:33:22 <lambdabot> class  Eq a  where
15:33:22 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:33:24 <bnijk_> Polarina: ok wait
15:33:28 <bnijk_> there's a bunch better way to explain this
15:33:33 <bnijk_> in terms of terminal and nonterminal symbols
15:33:39 <mauke> er...
15:33:40 <bnijk_> much better*
15:33:48 <bnijk_> no that's not the right phrasing
15:34:05 <jfoutz> > 1 == 1
15:34:07 <lambdabot>   True
15:34:11 <bnijk_> imagine a big tree of classes
15:34:15 <jfoutz> > (+) == (+)
15:34:16 <bnijk_> yes?
15:34:16 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a -> a))
15:34:16 <lambdabot>    arising from a use of `GH...
15:34:21 <Polarina> What classes? What's a class?
15:34:29 <bnijk_> each node in the trees with leaves beneath it encompasses the attributes of each of its leaves
15:34:41 <Polarina> bnijk_, I lost you there.
15:34:41 <djahandarie> > (-) == -(+)
15:34:42 <bnijk_> type eq might include type int, type string (list of char)
15:34:42 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> a))
15:34:42 <lambdabot>    arising from a use of syntac...
15:34:56 <bnijk_> mauke: you finish
15:35:05 <mauke> Polarina: data X = A | B;  instance Eq X where { A == A = True; B == B = True; _ == _ = False }
15:35:07 <det> kmc, I was thinking maybe a combinator that tries to parse optional whitespace before the parser on the right
15:35:17 <Polarina> Ok.
15:35:26 <kmc_> Polarina: how far did you get in the LYAH typeclasses section before it stopped making sense?
15:35:28 <mauke> and now (==) works for our new type X
15:36:01 <mauke> Ord is like Eq but instead of (==) it gives you compare
15:36:04 <mauke> :t compare
15:36:05 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:36:10 <mauke> @src Ordering
15:36:10 <lambdabot> data Ordering = LT | EQ | GT
15:36:14 <Polarina> kmc_, Typeclasses 102.
15:36:23 <bnijk_> @src Eq
15:36:23 <lambdabot> class  Eq a  where
15:36:23 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:36:24 <mauke> Polarina: do you know 'show'?
15:36:25 <kmc_> okay
15:36:29 <Polarina> mauke, yes.
15:36:34 <kmc_> Polarina: do you understand the first paragraph of Typeclasses 102?
15:37:09 <Polarina> kmc_, No. It says we've learnt to make types. I made no types.
15:37:22 <kmc_> Polarina: Then learn that first
15:37:31 <bnijk_> Polarina: scroll to the top
15:37:33 <Polarina> But one cannot make a type.
15:37:39 <mauke> Polarina: uh, I just did
15:37:42 <mauke> X
15:37:49 <Polarina> o.O
15:37:49 <kmc_> Polarina: there's this section named "Making Our Own Types and Typeclasses"
15:37:58 <kmc_> and "Typeclasses 102" is fairly far into the section
15:38:23 <kmc_> i'd recommend reading and understanding the stuff before that first
15:38:26 <kmc_> if you get stuck, ask us about it
15:38:38 <bnijk_> kmc_: there's "Typclasses 101"...
15:38:40 <Polarina> I understood most of the text before Typeclasses 102.
15:38:44 <bnijk_> where are you seeing this
15:38:48 <Polarina> But when it introduced a class, I got lost.
15:38:54 <kmc_> Polarina: within that text there are many examples of making a type
15:39:00 <kmc_> so i'm unsure why you think "one cannot make a type"
15:39:10 <mauke> the chapter starts: "n the previous chapters, we covered some existing Haskell types and typeclasses."
15:39:14 <Polarina> Maybe I am bad when it comes to terms. :(
15:39:16 <mauke> so it doesn't even introduce classes
15:39:22 <kmc_> Polarina: do you understand what the "data" keyword does?
15:39:27 <Polarina> kmc_, yes.
15:39:30 <kmc_> okay
15:39:34 <kmc_> it makes a type
15:39:40 <Polarina> Ok.
15:39:44 <mauke> "But how do we make our own? Well, one way is to use the data keyword to define a type."
15:39:45 <kmc_> data Foo = Bar
15:39:52 <kmc_> creates a new type named Foo
15:39:58 <kmc_> and a single value of that type, named Bar
15:40:07 <Polarina> I was thinking of "data" more like "struct" in C -- not a new type.
15:40:09 <mreh> "constructor"
15:40:14 <kmc_> Polarina: "struct" in C is a new type
15:40:19 <kmc_> "type" does not mean "primitive type"
15:40:21 <Polarina> kmc_, it is?
15:40:23 <kmc_> yes
15:40:28 <Polarina> I thought it was a group of types.
15:40:39 <kmc_> right, it's a new type defined in terms of some other types
15:40:43 <mreh> it's a compound type
15:40:44 <Polarina> Ok.
15:40:53 <kmc_> struct A { int x }; A a; int b; a + b;
15:40:57 <kmc_> that's a type error in C
15:41:14 <kmc_> we often define new functions in terms of old ones
15:41:20 <kmc_> similarly, we define new types in terms of old ones
15:41:31 <Polarina> Pretty much why you cannot add together a 2D vector with a 3D one..
15:41:38 <kmc_> sure
15:41:39 <bnijk_> something like that Polarina
15:41:50 <kmc_> so "data" introduces a new type
15:41:50 <bnijk_> @src Num
15:41:50 <lambdabot> class  (Eq a, Show a) => Num a  where
15:41:50 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:41:50 <lambdabot>     negate, abs, signum     :: a -> a
15:41:50 <lambdabot>     fromInteger             :: Integer -> a
15:41:55 <Polarina> Ok.
15:41:56 <bnijk_> see in the case of num
15:41:58 <kmc_> (whereas "type" introduces a new transparent name for an existing type)
15:42:02 <bnijk_> it incorporates all types that can act as numbers
15:42:10 <Polarina> kmc_, yeah.
15:42:11 <kmc_> (like "typedef" in C -- that does not create a new type)
15:42:20 <kmc_> okay, so does the beginning of "Typeclasses 102" make sense now?
15:42:24 <Polarina> Yes.
15:42:28 <kmc_> cool
15:42:33 <bnijk_> group hug!
15:42:39 <kmc_> well, perhaps you want to read on now -- we're always here ;)
15:42:59 <Polarina> And I am lost now on the first code snippet.
15:43:08 <mauke> data Bool = False | True
15:43:09 <mauke> ?
15:43:15 <Polarina> No, in typeclasses 102.
15:43:30 <bnijk_> :t (==)
15:43:31 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:43:31 <bnijk_> that?
15:43:37 <Polarina> @src Eq
15:43:38 <lambdabot> class  Eq a  where
15:43:38 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:43:43 <Polarina> That.
15:43:48 <bnijk_> ok
15:43:53 <bnijk_> class Eq defines the type of two functions
15:43:57 <bnijk_> "is equal to" and "is not equal to"
15:44:12 <bnijk_> each function acts as an infix function
15:44:14 <kmc_> Polarina: "class" is another Haskell keyword
15:44:18 <bnijk_> accepting two parameters and returning a bool result
15:44:22 <kmc_> "Woah, woah, woah! Some new strange syntax and keywords there! Don't worry, this will all be clear in a second."
15:44:31 <kmc_> you're not expected to yet know what the "class" keyword means
15:44:43 <kmc_> the next paragraph tries to explain it
15:44:48 * Polarina would find it easier if those tutorials did something new and cool, not just some common trash that is so common that it's complex.
15:45:02 <mauke> sure, no problem
15:45:04 <mauke> @src Functor
15:45:05 <lambdabot> class  Functor f  where
15:45:05 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:45:08 <mauke> better? :-)
15:45:14 <Polarina> Not really.
15:45:18 <kmc_> "so common that it's complex"?
15:45:21 <kmc_> what do you mean by that?
15:45:35 <Polarina> kmc_, Monads, for example.
15:45:44 <Polarina> Social life.
15:45:46 <bnijk_> i didn't understand haskell until i understood compilers
15:45:54 <bnijk_> i still don't
15:45:57 <kmc_> Polarina, does that have anything to do with "Typeclasses 102"?
15:46:07 <Polarina> No, just my thoughts.
15:46:10 <mauke> @src Monad
15:46:10 <lambdabot> class  Monad m  where
15:46:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:46:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:46:10 <lambdabot>     return      :: a -> m a
15:46:10 <lambdabot>     fail        :: String -> m a
15:46:13 <kmc_> last i checked, LYAH said nothing about monads anywhere
15:46:26 <bnijk_> yeah, BONUS is lazy
15:46:34 <Polarina> Very.
15:46:34 <benmachine> what a lamer
15:46:35 <bnijk_> so you see Polarina
15:46:37 <benmachine> never did anything for us
15:46:46 <bnijk_> monads are just a set of definitions for its operators types
15:46:55 <kmc_> we were here before
15:47:15 <mauke> @quote any.questions
15:47:15 <lambdabot> Korollary says: You know, dons actually knows your phone number. He'll be calling you soon to check whether you have any questions about monad transformers.
15:47:16 <Polarina> Perhaps I should look in another book, maybe another book can explain something better this one doesn't.
15:47:19 <bnijk_> the problem is incorporating Monads into any tutorial - readers will jump right to that section
15:47:22 <bnijk_> and then get very angry
15:47:34 <kmc_> you really cannot understand monads without understanding typeclasses -- never mind how many space suits or chocolate donuts you have
15:48:03 <bnijk_> I'm strictly monster with turtlenecks like Frankenstein
15:48:04 <bnijk_> Drop that mic kid, you lost, so that ass is mine
15:48:12 <Cale> There's a big combination of problems. Most people who are learning about monads still really aren't comfortable with the basics of functional programming.
15:48:30 <kmc_> bnijk_: wise of BONUS to omit Monads, then
15:48:45 <BONUS> they really are coming soon, honest :D
15:48:46 <copumpkin> a monad is just a lax functor from a terminal bicategory 1, duh
15:48:47 <kmc_> yes, if (>>=) is the first higher order function or overloaded operator you see, you are likely to be in trouble
15:48:55 <Cale> and many specific examples of monads are hard to understand if you're not really very comfortable with manipulating functions as values
15:48:57 <bnijk_> BONUS: Fifty-five-six computer tracks on your ass cracks
15:48:58 <copumpkin> fuck that monoid in category of endofunctors shit
15:48:58 <bnijk_> Therapy patient ignored your rhymes in the train station
15:49:05 <BONUS> so much stuff to do!
15:49:06 <BONUS> haha
15:49:08 <Cale> Like State, in particular
15:49:28 <bnijk_> BONUS: that's life, huh?
15:49:40 <bnijk_> people bitching about the monad section, and then you die - we all go through it
15:49:51 <BONUS> yeah, life is hard, but it seems monads are harder
15:49:54 <Polarina> Perhaps I should go do something else for a change, like make an interface for C functions.
15:49:57 <benmachine> fuck that monoid in category of endofunctors shit
15:49:59 <benmachine> err
15:50:02 <benmachine> I mean
15:50:04 <bnijk_> Chop up your tactics, you gimmick groups need to practice
15:50:05 <bnijk_> You be there, like Michael Jackson in my atmosphere
15:50:10 <benmachine> @remember copumpkin fuck that monoid in category of endofunctors shit
15:50:10 <lambdabot> Good to know.
15:50:18 <copumpkin> :O
15:50:24 <benmachine> :)
15:50:27 <copumpkin> now people will know how foul my mouth is
15:50:30 <benmachine> well
15:50:31 <Cale> aww, you missed half the quote
15:50:35 <benmachine> funny you should say that
15:50:51 <benmachine> I wondered if lambdabot liked swearing
15:50:53 <benmachine> so I did
15:50:55 <benmachine> @quote fuck
15:50:55 <lambdabot> edwardk says: well, dependent types fuck with compilers ability to get anything done
15:51:00 <benmachine> hmm
15:51:07 <BONUS> im gonna go to sleep now and actually i'll be working on LYAH when i sober up
15:51:07 <Cale> @remember copumpkin a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:51:07 <lambdabot> Done.
15:51:19 <copumpkin> :)
15:51:20 <benmachine> oh, sry
15:51:23 <Becquerel> double the goodness!
15:51:26 <bnijk_> You still rappin in the city talkin pig latin
15:51:28 <bnijk_> In fact you no test, you tired man, won't you rest?
15:51:29 <benmachine> @quote copumpkin.*fuck
15:51:29 <lambdabot> copumpkin says: <copumpkin> mauke is right by definition  <mauke> I am wrong  <copumpkin> fuck
15:51:31 <Cale> @forget copumpkin fuck that monoid in category of endofunctors shit
15:51:32 <lambdabot> Done.
15:51:33 <bnijk_> Take that sleep with NoDoz, that common style is cheap
15:51:34 <benmachine> there we go :P
15:51:34 <bnijk_> You bought your mic cord, payola scams the Billboard
15:51:38 <benmachine> thx Cale
15:51:42 <bnijk_> Slots that's not hot you settle for the nuts you got
15:51:42 <bnijk_> Record releases, your crew is wack like chocolate Reese's
15:51:43 * copumpkin has been spending too much time on ncatlab
15:51:47 <bnijk_> Urine stains are spread out, fly colours on your brains
15:51:48 <bnijk_> You beware, orangutangs tappin on your window
15:52:04 <ddarius> I've gotten to copumpkin.
15:52:08 <copumpkin> :)
15:52:13 <copumpkin> I've never seen you swear though
15:52:33 <mauke> I'VE NEVER SEEN YOU SWEAR, I SWEAR
15:52:54 <domor`> @quote endofunctor
15:52:54 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
15:53:02 <benmachine> woo
15:53:05 <domor`> @quote monad
15:53:05 <lambdabot> <mm_freak1work> says: not to be or to be and (not to be or to be and (not to be or to be and...)), that is the list monad
15:53:15 <bnijk_> Now my helmet's on, you can't tell me I'm not in space
15:53:15 <bnijk_> With the National Guard United States Enterprise
15:53:15 <bnijk_> Diplomat of swing with aliens at my feet
15:53:15 <ddarius> A monad is a monoid object in a monad on the bicategory of spans of Sets!
15:53:17 <bnijk_> Comin' down the rampart through beam on the street
15:53:24 <copumpkin> :O
15:54:04 <copumpkin> ddarius: perfect! all that needs is a ", duh" on the end and we'll be golden
15:54:44 <damd> does knowing category theory help one write better haskell programs at all?
15:54:52 <copumpkin> damd: not at all
15:54:52 <bnijk_> all theory helps you write better programs
15:54:57 <bnijk_> even sociology
15:55:03 <benmachine> knowing category theory makes you warm inside
15:55:04 <cads> gah, all the math I ever learned in school is absolutely useless when it comes to this category shit
15:55:08 <benmachine> and happy people program better
15:55:10 <benmachine> true fact
15:55:13 <bnijk_> ^
15:55:32 <ddarius> cads: You didn't learn algebra in school or any set theory at all or linear algebra or abstract algebra or topology?
15:55:36 <domor`> warm fuzzy feeling hm
15:55:38 <damd> programmers are happy because they program well
15:55:47 <ddarius> Most programmers don't program well.
15:55:53 <bnijk_> ^
15:55:59 <damd> programmers that are happy program well.
15:56:03 <bnijk_> "omg did you hear about the new coldfusion"
15:56:07 <bnijk_> "i heard it has for loops"
15:56:09 <damd> hm, no wait, that's what you said
15:56:37 <copumpkin> damd: not necessarily
15:56:38 <bnijk_> i especially like when programmers don't know what a loop is
15:56:47 <copumpkin> what is a loop?
15:56:50 <damd> bnijk_: *really*?
15:57:04 <damd> i don't think i ever met a person who claimed to be a programmer and did not know what a loop was
15:57:06 <bnijk_> ./` it's totally raining green, blue flowers, i smell the bees and the birds ./`
15:57:13 <bnijk_> damd: i found one, looking through resumes
15:57:19 <damd> bnijk_: *really*?
15:57:21 <bnijk_> yes
15:57:32 <cads> ddarius, they don't teach those things in grade school
15:57:33 <damd> could ju censor the personal information and send me a copy?
15:57:37 <copumpkin> real men use longjump and/or call/cc instead of loops, depending on what language
15:57:44 <bnijk_> if you really want - let me dig it up
15:57:53 <damd> s/ju/you/ (wtf?)
15:58:02 <copumpkin> j00 shud ph33r m3
15:58:04 <damd> must have been the weirdest typo i've ever made
15:58:12 <damd> ju is how you is pronounced in sweden, kind of
15:58:16 <ddarius> cads: Just as a check what grades does the term "grade school" cover for you?
15:58:17 <copumpkin> it's the l33t hax0r within speaking
15:59:19 <damd> i've always been intrigued with dutch pronounciation in relation to the spelling
15:59:52 <jfoutz> loop is one of the scariest macros evar. (loop for x from 1 to 5 do print x)
16:00:01 <cads> ddarius, just some highschool, no formal higher education
16:00:01 <jfoutz> i don't know loop.
16:00:12 <bnijk_> hmm...whre is it
16:00:15 <damd> jfoutz: i never bothered trying with that thing
16:00:28 <bnijk_> oh yes, the laptop...
16:00:35 <bnijk_> how should i do this
16:00:43 <hzap> cads: no algebra in high school?
16:01:03 <jfoutz> damd: one day a lisp programmer decided, hey it would be neat to embed fortran and get it in the cl spec. they'll never suspect!
16:01:03 <cads> hzap, I think he was talking about abstract algebra :)
16:01:04 <bnijk_> damd: you get the gist of it- he had like seventy items of some kind, the only thing changing being a number, and listed them out one-by-one
16:01:08 <copumpkin> algebra in high school isn't Algebra
16:01:12 <bnijk_> doing the same thing to each
16:01:12 <benmachine> heh
16:01:17 <bnijk_> it was madness
16:01:18 <benmachine> with a capital A
16:01:21 <hzap> oh
16:01:27 <benmachine> what qualifies as linear algebra?
16:01:29 <copumpkin> I got a tiny taste of Algebra in high school with the IB, but then forgot about it
16:01:41 <copumpkin> sadly
16:01:44 <hzap> i sometimes automatically (map toLower) the chat in my head
16:01:45 <damd> bnijk_: that's okay, i believe you, but if you do manage to get a hold of it, i'd really enjoy reading it :)
16:01:58 <bnijk_> next time i drag that thing out damd -screen's broken
16:02:05 <bnijk_> remind me
16:02:15 <damd> sure
16:02:19 <ddarius> cads: They definitely cover "high school algebra" in high school.
16:02:48 <ddarius> cads: I explicitly listed abstract algebra later.
16:02:50 <cads> benmachine, learning matrices and solving linear equations might constitute linear algebra, but I would say that a treatment of linear algebra should start with the axioms of linear spaces
16:03:10 <gwern> dang it. how the *deuce* is one s'posed to log into the ghc trac? I keep getting logged in as guest
16:03:27 <benmachine> cads: ah, that's more or less what I thought
16:03:36 <benmachine> I don't think I saw a single axiom until I got to university
16:03:42 <benmachine> now of course they are everywhere :P
16:03:48 <copumpkin> damn axioms
16:03:49 * ddarius wishes there was much less emphasis on matrices in beginning linear algebra courses/texts.
16:03:49 <benmachine> <3 axioms
16:03:50 <hzap> i never had any linear algebra until university :D
16:03:56 <benmachine> I had some token matrices
16:03:56 <bnijk_> French toast and herbs were covered with giant eggs
16:03:56 <bnijk_> Livin small, people unequal challenge my thoughts
16:03:56 <bnijk_> No station or radio will understand
16:03:57 <bnijk_> The perfect enzyme is me with your brain in my other hand
16:04:00 <benmachine> but they were really very token
16:04:12 <bnijk_> can somebdoy explain karp reduction to me
16:04:14 <ddarius> I never had any linear algebra...
16:04:14 * jfoutz wishes high school taught probability rather than linear systems.
16:04:15 <benmachine> "here is how you find eigenvalues"
16:04:23 <benmachine> "what do you mean, you don't know what they are for?"
16:04:28 <benmachine> "they are for passing exams, boy"
16:04:49 <ddarius> Eigenfunctions is where it's at.
16:04:49 <copumpkin> my university's linear algebra course is all about matrices unless you take the honors version, and then it's done the nice abstract algebra way
16:04:52 <damd> jfoutz: i was taught basic probability in high school (or whatever the 7th to 9th year is in yankee speak)
16:05:09 <copumpkin> yankee doodle went to town a-riding on a pony
16:05:11 <jfoutz> nice
16:05:11 <hzap> the vector spaces stuff was the most fun to me
16:05:23 <ddarius> damd: In Yankee speak, 6-8th is "middle school" (or several other names such as "junior high")
16:05:29 <domor`> benmachine: so true. I learned eigenvalues 4-5 years ago and used them for the first time this year (machine learning)
16:05:33 <hzap> eigenvalues? lame... :D
16:05:42 <copumpkin> eigenfaces is where it's at, apparently
16:05:50 <alephi> am i unrecognizable now
16:05:55 <ddarius> Eigencrust!
16:05:56 <cads> copumpkin, I've been looking around at university undergrad math programs and unless it's like berkley or MIT they seem so weak
16:06:00 <benmachine> bnijk_: yep
16:06:04 <alephi> lol
16:06:12 <benmachine> see what I did there
16:06:28 <copumpkin> cads: yeah, I wanted to do math until I took some math courses here :P so I did CS instead
16:06:45 <copumpkin> sadly
16:06:57 <ddarius> College seems like a waste of time for the most part...
16:06:58 <cads> at mit first year students have abstract algebra, BOOM. Everywhere else 'intro discrete math' is what's available
16:07:22 <kmc_> college is useful for forcing you to learn things on your own
16:07:28 <benmachine> cads: cross the atlantic!
16:07:30 <benmachine> for no real reason
16:07:33 <bnijk_> boy i'm glad i didn't go to MIT
16:07:39 <bnijk_> don't people get raped there 24/7
16:07:39 <ddarius> kmc_: I don't need any "forcing"
16:07:43 <cads> benmachine, there _is_ a real reason
16:07:48 <kmc_> at my school the smart mathy first years would take abstract algebra, most wouldn't
16:07:48 <copumpkin> cads: here it's fairly flexible. many undergrads skip straight to grad courses or the "higher" undergrad courses
16:07:53 <benmachine> cads: is there a complex reason?
16:07:55 <bnijk_> is it like the movie "real genius"
16:08:07 <copumpkin> ddarius: I'm not sure you're the "average student"
16:08:20 <copumpkin> many people need more guidance :)
16:08:21 <cads> benmachine, and a quaternion reason.
16:08:24 <ddarius> copumpkin: Of course not, I'm not a student.
16:08:32 <kmc_> the required first year math was differential / integral calculus (heavily proof based, assumes AP Calc level), linear algebra (axiomatic but not super hard core), and multivariate calc (fairly light in comparison)
16:08:39 <ddarius> (Well, I might technically be right now; I don't really know.)
16:08:43 <kmc_> they started off hard to scare everyone
16:08:56 * Polarina goes to sleep.
16:08:58 <copumpkin> ddarius: you know what I mean :P
16:09:03 <hzap> kmc_: that's pretty similar to mine
16:09:04 * benmachine idly wonders which side of the atlantic costs more for a university education
16:09:10 <cads> kmc, where do you attend?
16:09:15 <kmc_> caltech
16:09:16 <hzap> not that similar
16:09:16 <copumpkin> benmachine: definitely the west side :P
16:09:17 <damd> benmachine: we get paid to study in sweden
16:09:22 <hzap> but close
16:09:22 <kmc_> a lot of really smart people will not learn anything unless forced to
16:09:23 <benmachine> damd: :(
16:09:23 <bnijk_> benmachine: same currency
16:09:55 <benmachine> my government was all, hey we want more people to go to university and widen access to larger areas of society
16:09:59 <kmc_> uhm, I think the US is way more expensive
16:10:02 <benmachine> p.s. we're massively hiking fees too, just so you know
16:10:19 <kmc_> last i heard the students at cambridge were having protests over paying a few thousand pounds / yr out of pocket
16:10:20 <bnijk_> benmachine: there is your first hint, "government does the opposite of what it claims' ;)
16:10:25 <copumpkin> many US universities now will cover most of your expenses though
16:10:27 <kmc_> in the US a good school is like $40,000 / year
16:10:29 <copumpkin> if you can't pay, that is
16:10:33 <kmc_> you get financial aid if you can't pay
16:10:34 <kmc_> yeah
16:10:37 <benmachine> kmc_: yeah, I'd heard that, except that also cambridge costs a lot more for overseas than it does for locals
16:10:44 <copumpkin> benmachine: yeah, it does
16:11:00 <benmachine> oh but I don't think it manages five digits
16:11:03 <kmc_> at stanford, if your family makes less than $100,000 per year, your tuition is free, period
16:11:10 <bnijk_> kmc_: o_o since when
16:11:12 <benmachine> but financial aid we are probably not so good
16:11:14 <kmc_> few years ago
16:11:15 <bnijk_> oh "less"
16:11:16 <bnijk_> nevermind
16:11:18 <copumpkin> bnijk_: couple of years ago
16:11:23 <copumpkin> same with many other "top" universities
16:11:28 <copumpkin> as of the past couple of years
16:11:36 <benmachine> "top" eh
16:11:39 <kmc_> however $100,000 is not all that much.  $100,001 - $40,000 is much less than $99,999
16:11:46 <copumpkin> benmachine: with big endowments per student
16:12:09 <copumpkin> benmachine: which tends to correlate with ranking anyway
16:12:14 <benmachine> k
16:12:16 <benmachine> makes sense ish
16:12:18 <bnijk_> incidentally, my entire college education could have been completed with two months and a T1 line
16:12:23 <cads> copumpkin, what state were you in?
16:12:27 <copumpkin> cads: NH
16:12:27 <bnijk_> and, for the most part, has been
16:12:31 <kmc_> last i heard Caltech was still in a dick waving contest with MIT, charging more than they had to in order to keep a reputation for being super high end
16:12:32 <copumpkin> (still am :P)
16:12:42 <copumpkin> kmc_: sad :/
16:13:01 <bnijk_> ok everybody - distro roll of
16:13:03 <bnijk_> which one
16:13:04 <bnijk_> do you use
16:13:07 <bnijk_> at home
16:13:09 <benmachine> arch woo
16:13:16 <bnijk_> good answer
16:13:20 <benmachine> the woo is obligatory
16:13:27 <cads> windows wooot!
16:13:28 <bnijk_> i usually put a heart after it
16:13:48 <cads> (debian virtual machine :)
16:13:51 <copumpkin> http://131.111.8.46/admissions/undergraduate/international/finance.html# costs of cambridge
16:13:56 <copumpkin> it's fairly high if you aren't from EU
16:14:17 * theorbtwo uses debian unstable.
16:14:33 <benmachine> copumpkin: the college fees get bolted on as well, I think
16:14:38 <copumpkin> benmachine: yeah
16:14:42 <cads> benmachine, did you suggest the idea of movign to europe to study?
16:14:58 <copumpkin> I'm sure it ends up being around 20 kquid for most majors
16:14:59 <hzap> canadian universities charge ~$10000/year extra for international
16:15:04 <benmachine> cads: err, not entirely seriously
16:15:09 <benmachine> but I like my university :P
16:15:34 <cads> where do go/what degree are you studying?
16:15:35 <shapr> @index fcntl_read
16:15:36 <lambdabot> bzzt
16:15:46 <benmachine> cads: cambridge/maths
16:16:01 <bnijk_> if you study enough years at university you'll reach level OT3
16:16:07 <bnijk_> you haev to get past a "wall of fire" at that stage
16:16:10 <bnijk_> to find out the truth
16:16:25 <bnijk_> and there is a giant turtle who breaths fire
16:16:30 <copumpkin> benmachine: what college?
16:16:49 <benmachine> copumpkin: that would be more than enough information to e-stalk me :P
16:16:49 <cads> bnijk_, OT3? Is that an intelligence classification?
16:16:54 <copumpkin> benmachine: oh fine :P
16:16:55 <benmachine> not that you couldn't already tbh >_>
16:17:02 <bnijk_> cads: well, you have to clear OT1 and OT2
16:17:04 <benmachine> (downing)
16:17:10 <copumpkin> benmachine: you put your real name in IRC anyway :P
16:17:13 <benmachine> yup
16:17:13 <bnijk_> and it comes before OT4
16:17:26 <benmachine> I am slowly eroding my paranoia in that regard
16:17:34 <benmachine> but it takes a little while to fully dissolve
16:17:44 <copumpkin> :)
16:17:46 <p_l> lol @ scientology references
16:18:06 * bnijk_ throws p_l out of a 20 story building
16:18:12 <cads> don't be paranoid unless you're illegal things or security/intelligence, imo
16:18:14 <bnijk_> no scientology here
16:18:27 <cads> unless you're doing*
16:18:28 <benmachine> cads: well, it made more sense when I was like 12
16:18:33 <p_l> bnijk_: scientology uses similar classification :)
16:18:49 * copumpkin used to do "security" stuff and still didn't bother hiding his name... probably just means he's stupid though
16:18:52 <p_l> and the "wall of fire" thing actually made a lot of sense for that
16:19:05 <bnijk_> p_l i know, that's what i was getting at
16:19:12 <p_l> hehe
16:19:17 <cads> shoot, when I was around 12 I remember sitting on the porch on y2k evening with a friend and a shotgun, waiting for the power to cut out.
16:19:30 <p_l> lol
16:19:36 <benmachine> smooth
16:19:43 <p_l> on the eve of y2k I trolled y2k believers
16:20:31 <cads> well we did something like that
16:20:33 <bnijk_> last new year i got drunk
16:20:37 <bnijk_> and pissed on a cop car
16:21:02 <cads> ten minutes after the power didn't cut out at 12:00 we cut the house breakers to freak out my friend's dad (whose shotgun we were entrusted with)
16:21:21 <p_l> cads: regarding security/intelligence, iirc “oficially” MI-5 and MI-6 "don't exist". Doesn't stop them from having job advertisements on the internet.
16:21:27 <shapr> Any idea why I get these linking errors? /home/shae/.cabal/lib/unix-2.4.0.0/ghc-6.10.4/libHSunix-2.4.0.0.a(IO.o): In function `sk63_info': (.text+0x30c4): undefined reference to `fcntl_read'
16:22:48 <benmachine> p_l: they both recruit openly now iirc
16:23:01 <ddarius> People weren't even talking about Y2K when I was 12.
16:23:02 <benmachine> that'd be kind of silly if they claimed not to exist as well
16:23:19 <jfoutz> shapr: fnctl is unix open flags, yes? maybe a strange clib got found?
16:23:20 <theorbtwo> They also get openly quoted in various places.
16:23:21 <p_l> benmachine: yes, they recruit openly, but I recall something about some bureaucratical thing making them still "not existing"
16:23:35 <shapr> jfoutz: err.. how would I check that?
16:23:50 <p_l> theorbtwo: *everyone and their dog* knows about them. Doesn't stop from bureaucratic sillines ;-)
16:23:55 <shapr> Maybe I should reinstall the unix cabbage.
16:23:57 <jfoutz> shapr: i was mostly taking a wild guess...
16:24:18 <uorygl> MI-5 and MI-6? What are those?
16:24:37 <copumpkin> english agencies
16:24:46 <theorbtwo> *British* agencies.
16:24:49 <benmachine> intelligence
16:25:05 <p_l> uorygl: british intelligence and counterintelligence agencies
16:25:31 <shapr> jfoutz: reinstall libHSunix-2.4.0.0 did not help :-(
16:26:01 <copumpkin> http://hackage.haskell.org/packages/archive/Cabal/1.8.0.2/logs/failure/ghc-6.10
16:26:04 <syntaxglitch> p_l, they're goedel sentences of the british government, true but not provably so
16:26:09 <nus> they're but figment of imagination of Flemming
16:26:13 * cads thinks it would be cool to start an electronic security firm
16:26:15 <nus> :-]
16:26:20 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3780
16:26:39 <copumpkin> (shapr)
16:26:48 <shapr> copumpkin: good point
16:27:26 <shapr> So I need to force it to use 2.3
16:28:17 <shapr> I wonder when karmic will get ghc 6.12
16:28:26 <jfoutz> hrm. wow.
16:28:34 <benmachine> when it gets uninstalled and replaced with arch :P
16:28:50 <Dashkal> Hey, I love my ubuntu
16:33:16 <shapr> copumpkin: It builds! Thanks!
16:33:20 <copumpkin> np :)
16:33:27 <theorbtwo> Ship it!
16:33:36 <kmc_> @quote knuth
16:33:36 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
16:33:58 <kmc_> @quote proved.it.correct
16:33:58 <lambdabot> DonaldKnuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
16:34:06 <kmc_> @quote DonaldKnuth
16:34:06 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
16:34:06 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
16:34:23 <kmc_> @quote DonaldKnuth
16:34:23 <lambdabot> DonaldKnuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
16:37:23 <benmachine> if Knuth had developed that idea a little more would we all now be programming in Donald?
16:37:35 <shapr> Ok, so sw17ch's tun/tap code came from scurry... I wonder if he knows the TCP/IP stack from House can be used separately?
16:46:37 <ziman> if I do: map (BS.take n) . BS.tails . BS.cycle, will the bytestrings be copied or will just pointers be there?
16:47:05 <ziman> I need to generate all rotations of a (long) string.
16:48:10 <Lemmih> ziman: No copying will be done.
16:48:51 <ziman> thanks
16:59:20 <mulciber> hello
17:15:48 <idnar> http://gbacon.blogspot.com/2009/06/cleaning-up-your-haskell-imports.html -- what is a "cuddled" list?
17:17:34 <cads> idnar, perhaps he means "preferred"?
17:19:29 <idnar> what is a "preferred" list?
17:19:47 <idnar> I assume it refers to the formatting of the import lists in some way, I just don't understand how
17:19:52 <dolio> Perhaps he means "cuddled".
17:20:34 <aavogt> curdled
17:21:08 <cads> dolio, is that part of the haskell jargon?
17:21:18 <dolio> Nope. Never heard of it.
17:21:23 * copumpkin cuddles idnar
17:21:57 <cads> a cuddle list sounds like something you make in preparation of valentine's day
17:23:11 <idnar> maybe it's the lack of space between the module name and the list
17:26:08 <jfoutz> idnar: i bet that's it. sort of a misuse, considering the term comes from }else{
17:28:31 <kang`r`us> haskellers, was the scheme the first language to implement closures?
17:29:07 <kang`r`us> why is everyone so quiet? :)
17:29:27 <Lemmih> It's the middle of the night.
17:29:28 <copumpkin> kang`r`us: we're avoiding you, shh
17:29:29 <jfoutz> depends on what you mean by closure. if it's a way to find code, then... probably not.
17:30:08 <gwern> kang`r`us: I don't think it could've been. one of scheme's first results was that actors = closures, so presumably closures predated scheme...
17:31:20 <kang`r`us> wikipedia says: The concept of closures was developed in the 1960s and was first fully implemented as a language feature in the programming language Scheme. Since then, many languages have been designed to support closures. (the whole paragraph looks fishy, actually)
17:31:36 <Axman6> didn't lisp have closures?
17:31:47 <Axman6> i mean, you could create tuples using closures
17:32:04 <jfoutz> landin's "mechanical evaluation of expressions, apparently defines them. 1964, but i could't find the paper
17:32:51 <kang`r`us> http://ropas.snu.ac.kr/lib/dock/La1964.pdf
17:32:55 <kang`r`us> thanks for the name
17:33:01 <jfoutz> i was going to argue with someone about java's closures so i was looking up the history not to long ago.
17:33:39 <kang`r`us> the paper seems very accessible; i hope it is :)
17:34:27 <kang`r`us> looks like a great first look at lambda calculus
17:34:27 <jfoutz> like i said, i didn't read the paper... i think he means something like a trampoline function.
17:34:38 <jfoutz> thanks for the link though!
17:34:40 <kang`r`us> i dont know what's a trampoline function
17:34:44 * kang`r`us 's pleasure
17:35:24 <jfoutz> sorta like a pointer, but for code. you call the function it says, go look over there.
17:47:08 <ivanm> @ask bos with criterion built without chart support, maybe you should disable or not list the options for producing plots (took me a while to work out why it wasn't producing graphs :s)
17:47:09 <lambdabot> Consider it noted.
17:47:20 <jfoutz> kang`r`us: my vote is simula 67. i think scheme was a little later... might have been some crazy lisp with them though.
17:47:41 <kang`r`us> does simula 67 predate lisp, tho?
17:48:02 <jfoutz> no, but early lisp wasn't quite the polished scheme we have today.
17:48:11 <kang`r`us> i bet :)
17:51:29 <jfoutz> kang`r`us: here's the lisp 1 manual, if you can puzzle out if it supported closures. http://www.softwarepreservation.org/projects/LISP/book/LISP%20I%20Programmers%20Manual.pdf
17:53:26 <jfoutz> it's back when they wanted function[arg;arg;arg] syntax, rather than (fn arg arg arg) syntax. :)
17:53:37 <kang`r`us> jfoutz: so you think this paper is showing that lisp1 implemented closures?
17:53:58 <jfoutz> it depends on what you mean.
17:54:57 <jfoutz> if it's a first class function that uses lexical environment... i don't think so. but i think they could carry around their own local state.
17:55:00 <kang`r`us> please educate me, sir; i can only see one interpretation :)
17:55:14 <pikhq> jfoutz: function[arg;arg;arg] syntax was meant for user input.
17:55:16 <kang`r`us> i mean the second thing, actually; that it could carry around a state
17:55:30 <pikhq> jfoutz: It was immediately compiled down to (function arg arg arg).
17:55:37 <pikhq> (well, more like "parsed")
17:55:55 <pikhq> jfoutz: BTW, that's called an "m expression".
17:56:29 <jfoutz> pikhq: yeah, i thought mccarthy was surprised/dissapointed ... the guy who's name i forget, implemented eval as s expressions.
17:58:00 <gwern> > 660 + 730 + 680
17:58:00 <lambdabot>   2070
17:58:20 <pikhq> I find it very amusing that a Lisp compiler was considered to be a "gigantic, many-year project".
17:59:17 <jmelesky> scheme didn't happen till the mid-late 70s, iirc
18:00:19 <copumpkin> gwern: SAT scores? :P
18:00:27 <gwern> copumpkin: no, trying to compare my gre scores
18:00:30 <copumpkin> ah
18:00:36 <gwern> can't figure out how people are getting >1600 scores
18:00:38 <cads> pikhq, I think we had a lot less programming language theory back then - nowadays we have compiler-compilers and the like
18:01:15 <ivanm> gwern: very simple: cheating!
18:01:19 <gwern> -_-
18:01:21 * ivanm has no idea what gre scores are...
18:01:32 <c_wraith> graduate ready-to-eat
18:01:33 <copumpkin> ivanm: a standardized testing for graduate schools in the US
18:01:36 <c_wraith> err.  readiness exam
18:01:38 <copumpkin> *test
18:01:47 <pikhq> cads: And they're not even all that necessary for a basic S-expression Lisp...
18:01:50 <ivanm> c_wraith: methink you love your MREs too much...
18:01:57 <pikhq> cads: The garbage collector is the hard part, really.
18:02:06 <pikhq> cads: ... Assuming you want a naive compiler, of course.
18:02:15 <copumpkin> ivanm: basically SAT v2
18:02:29 <ivanm> copumpkin: and I have no idea what SAT is either ;-)
18:02:38 <copumpkin> same thing for getting into college in the US :)
18:02:45 * ivanm mumbles something about yanks assuming everyone knows their own little quirks and terminologies...
18:02:49 <gwern> eh. I give up - no idea how to translate writing scores like 5.5 to the old 'analytic' out of 800 sections
18:04:10 <pikhq> ivanm: "Scholastic Aptitude Test".
18:04:44 <ivanm> *nod*
18:05:16 <gwern> they're IQ tests really
18:05:50 <copumpkin> they don't really indicate anything much
18:05:57 <gwern> once you've studied some vocab and practiced a little, that's all they boil down to
18:06:00 <copumpkin> the fact that you can "prep" for them would show you that
18:06:04 <gwern> which is why everyone likes them, of course
18:06:12 <gwern> (where everyone = colleges)
18:06:23 <copumpkin> I think they're pretty dumb, but submitted anyway :P
18:06:25 <pikhq> Oh, right, people prepped for those things.
18:06:32 <copumpkin> as you pretty much can't do anything here without them
18:07:03 <c_wraith> I didn't prep for my GRE.  I think I may have showed up hung over, even.
18:07:13 <c_wraith> might explain my hideously low score on it
18:07:37 <copumpkin> :)
18:07:49 <copumpkin> I hear that MIT doesn't want GRE scores anymore, at least
18:07:53 <copumpkin> but most other schools still do
18:08:12 <gwern> copumpkin: well, MIT is so far right on the bell curve the GRE ceases to say anything
18:08:20 <copumpkin> yeah
18:08:32 <gwern> copumpkin: I looked up their grad student gre scores - 797 *average* on math
18:08:39 <copumpkin> :)
18:08:55 <c_wraith> hell.  I got an 800 on the math portion of the GRE...  while possibly hung over.
18:09:04 <c_wraith> It didn't ask any hard questions
18:09:08 <gwern> see? it tells them nothing
18:09:14 <gwern> iirc, they have in-house tests
18:09:29 <copumpkin> what I don't understand about those ETS tests (SAT and GRE) is why they use a multiple-of-10 scoring system and then don't give unit points even for tests with massively skewed distributions. You can get one mistake on the SAT I math and skip from an 800 to a 740
18:09:29 * gwern forgets whether my sister took them when she visited but they do have them that they prefer to the big tests
18:09:58 <copumpkin> yeah, the math on those tests is a joke
18:10:03 <copumpkin> and GRE was no harder than SAT in that respect
18:10:27 <c_wraith> I actually think the GRE math portion was easier than the SAT math portion
18:10:59 <c_wraith> though that could just be how much I learned in the intervening 6 years.  (things I had to think about in high school were instinct in college)
18:11:05 <copumpkin> the testing software on the other hand is abysmal windows 3.1 or 95 with 640x480
18:11:23 <copumpkin> at least where I took it
18:11:35 <c_wraith> I recall about the same thing
18:12:34 <copumpkin> ah well
18:13:47 <sjanssen> it can't possibly be Windows 3.1
18:13:59 <sjanssen> that would just be beyond absurd
18:14:04 <copumpkin> it was pretty absurd
18:14:15 <copumpkin> it had those nice old-school scrollbars that didn't move the content as you drag them
18:14:22 <copumpkin> and it was definitely 640x480
18:14:26 <copumpkin> 256-color
18:14:51 <copumpkin> it made reading comprehension harder than it needed to be for passages that didn't fit in the tiny screen, if you needed to quickly peruse the text
18:29:37 <Draconx|Laptop> copumpkin, how does one peruse something quickly? :P
18:29:56 <copumpkin> by being super smart!
18:30:00 <copumpkin> ;)
18:37:22 <iaefai> Salve! Quid agis hodie?
18:38:55 <copumpkin> iaefai: not much, you?
18:39:25 <iaefai> Valeo!
18:39:44 <iaefai> I am doing very well, although I have a buzz right now
18:39:58 <ivanm> iaefai: maybe you should cut down on the caffeine then?
18:40:06 <iaefai> This is alcohol sir.
18:40:17 <iaefai> My caffeine is great in the morning
18:40:24 <ivanm> bah, still a noxious chemical that does evil stuff to your brain
18:40:43 * ivanm likes his brain the way it is, thank you very much
18:41:06 <iaefai> ivanm: Caffeine is a gift from a creator whose existence has been debated for centuries. I like it very much.
18:41:17 <iaefai> I am pondering electronic simulation.
18:41:39 <iaefai> But that pondering is interrupted by a zlib that fails to update itself.
18:42:17 <iaefai> knowing cabal, it is not too surprising to have it give you a completely useless error message: exit: ExitFailure 1
18:42:29 <iaefai> This is on the mac, any reports that you know of?
18:42:40 <aavogt> it usually has more helpful messages if you read up the scrollback
18:42:42 <iaefai> The issue is related to an upgrade of cabal-install, and is probably within the last month.
18:42:55 <iaefai> haha, there is no scrollback because I didn't do -v3
18:43:39 <iaefai> ok, alcohol is getting to me, I have to read why -v3 or -v 3 isn't working, one moment
18:46:24 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16896#a16896
18:46:38 <iaefai> I don't know the problem. "Only one output file may be specified"
18:47:48 <ivanm> iaefai: try putting the verbose after the zlib
18:48:11 <iaefai> There doesn't happen to be a way to redirect or pipe this straight to hpaste is there? :P
18:48:23 <ivanm> iaefai: also, if you're using ghc 6.10.4, I highly recommend you get rid of bytestring 0.9.1.5 and rebuild everything that uses it
18:48:36 <ivanm> as you really shouldn't upgrade boot packages like bytestring
18:48:49 <ivanm> iaefai: wgetpaste can automatically paste stuff for you to dpaste or something
18:48:56 <ivanm> wgetpaste -c "command"
18:49:09 <iaefai> ivanm: I would love to upgrade ghc, but haskell platform hasn't been upgraded :p
18:49:17 <ivanm> so? ;-)
18:49:28 <iaefai> ivanm: What are you using a newer ghc?
18:49:32 <ivanm> yup
18:49:43 <iaefai> Do you like it a lot?
18:49:44 <ivanm> iaefai: I have only come across two packages (and their reverse deps) that don't like 6.12: gtk2hs and yi
18:49:51 <ivanm> iaefai: it's a compiler :p
18:49:53 <iaefai> Ah, two things I wouldn't use
18:50:01 <iaefai> How did you upgrade?
18:50:37 <ivanm> what annoys me is the warning when you have an expression in a do block that isn't of type m (); 6.12 wants you to do _ <- :@
18:50:44 <iaefai> For reference: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16896#a16897
18:50:48 <ivanm> iaefai: I upgraded via my package manager
18:50:50 <iaefai> It has the asame error
18:50:54 <iaefai> Ah, I don't have a package manager
18:51:19 <iaefai> I don't trust macports for something like this, and I don't know if it even upgraded it or has it tobegin with
18:51:26 <ivanm> yeah, I have no idea about that error
18:51:59 <iaefai> Is there a way I can get cabal to 'clean' itself up
18:52:10 <iaefai> Like a make clean, but a little more thorough perhaps
18:56:11 <iaefai> Does Ghc-6.12.x like snow leopard mac?
18:56:17 <Axman6> yes
18:57:20 <iaefai> If I happened to want to install the new ghc pkg, would it condemn cabal in any way?
18:57:44 <iaefai> I guess I ask about incompatibility with the 'platform' release
18:57:57 <copumpkin> cabal is aware of the version of ghc
18:58:08 <copumpkin> it'll just say you have no installed user packages when you start using 6.12
18:58:14 <copumpkin> you can install them
18:58:21 <copumpkin> assuming they work with 6.12 :)
18:58:35 <iaefai> That would probably be the greatest gift
18:59:37 <sm> iaefai: http://code.google.com/p/pastepipe/
18:59:55 <iaefai> That is awesome!
19:00:35 <iaefai> $ sudo cabal install cabal-install
19:00:36 <iaefai> cabal: failed to parse output of 'ghc-pkg dump'
19:00:48 <copumpkin> you need to upgrade cabal-install too
19:00:56 <iaefai> That is for upgrading it :-(
19:01:02 <copumpkin> by hand, then :P
19:03:43 <iaefai> Some technical questions if I may... What would be a good data structure to store various electronic circuits in that includes only resistors?
19:04:04 <cygnus_> maybe a grpah
19:04:35 <iaefai> If this is what you mean: http://en.wikipedia.org/wiki/Graph_(data_structure)  I would agree :p
19:04:54 <iaefai> Although I have no idea how to work with it
19:05:12 <aavogt> sometimes as a NxN matrix if you have N nodes
19:05:21 <ezyang> Any Hayoo devs around?
19:05:38 <aavogt> or at least, that's how you can represent the KVL or KCL laws
19:05:54 <iaefai> aavogt: I can't guarantee that an NxN matrix is a good configuration
19:06:17 <jfoutz> data Net r = Series r Net | Parallel r Net | Ground
19:07:12 <iaefai> Is there a way to remove the haskell platform on mac?
19:08:33 <ezyang> Whoa, there's a Hoogle 3 beta. Sweet!
19:08:47 <kamatsu> what does hoogle 3 do?
19:09:30 <copumpkin> shouldn't that be hooogle?
19:09:35 <aavogt> it hoogles betta
19:09:41 <Gracenotes> jfoutz: s/Net |/(Net r) |/g?
19:09:56 <jfoutz> oh. hehehe. yeah.
19:10:19 <jfoutz> iaefai: bender:Library jfoutz$ ls -l /Library/Frameworks/GHC.framework/Tools/Uninstaller
19:10:38 <jfoutz> er... there's an uninstaller.
19:10:53 <iaefai> jfoutz: That is not the same thing that I have. I just installed a that ghc.framework, I want to remove the platform thing
19:11:19 <jfoutz> oh. hmm.
19:11:32 <Gracenotes> :o
19:11:39 <iaefai> I suspect that just deleting it is insufficient
19:12:51 <jfoutz> i'm pretty sure the platform installs there. do you have multiple versions under GHC.framework/Versions ?
19:13:12 <Axman6> there's only ever one version installed there
19:13:17 <Axman6> annoyingly
19:13:20 <iaefai> ah, that is the key
19:13:24 <iaefai> Axman6: I have two :p
19:13:35 <iaefai> Rightnow I guess I will leave it
19:13:36 <Axman6> you're not supposed to :)
19:13:43 <iaefai> It works as it is now
19:14:11 <jfoutz> the wiki claims that uninstaller is it.
19:14:26 <iaefai> Is the wiki for ghc or for the platform thing?
19:14:30 <jfoutz> the Versions/Current link isn't the one you want?
19:15:35 <jfoutz> http://www.haskell.org/haskellwiki/Mac_OS_X (sec 1.3 haskell platform snow leopard) i guess you could argue the uninstall line dosn't apply to the platform install instructions, but that would be silly.
19:15:51 <iaefai> It wouldn't be silly if they were two products
19:16:29 <iaefai> Has anyone tried to use haskell code with a cocoa touch program on an iphone?
19:16:55 <jfoutz> http://www.haskell.org/haskellwiki/IPhone ?
19:18:58 <ezyang> Hmm, I wonder if Hoogle 3 lets me search for ALL PACKAGES EVAR
19:19:05 <ivanm> @slap ezyang
19:19:05 * lambdabot secretly deletes ezyang's source code
19:19:09 <iaefai> I wanted to experiment with some kind of electronic circuit simulation. I thought immediately of haskell considering its mathematical nature. Eventually the iphone would be a nice thing to use it with.
19:19:19 <iaefai> I should say perhaps the ipad :p
19:20:31 <jfoutz> this is a haskell app: http://itunes.apple.com/us/app/icy-wiki/id347195783?mt=8
19:20:41 <jfoutz> by this guy http://jinjing.funkymic.com/tag/Haskell
19:22:18 <iaefai> This is great: http://www.alpheccar.org/en/posts/show/94
19:23:19 <ezyang> hmm, this url doesn't work: http://haskell.org/hoogle/3/?q=%2Bglib+on
19:23:42 <copumpkin> jfoutz: he's in this channel :)
19:23:44 <hiptobecubic> how does one show the type of a function in ghci?
19:23:48 <copumpkin> :t
19:23:52 <copumpkin> :t id
19:23:53 <lambdabot> forall a. a -> a
19:23:58 <ezyang> @hoogle on
19:23:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:23:59 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:23:59 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:24:02 <jfoutz> copumpkin: neat!
19:24:05 <ezyang> @hoogle +glib on
19:24:05 <lambdabot> Could not find file:
19:24:05 <lambdabot>     glib
19:24:05 <lambdabot> Searched:
19:24:23 <hiptobecubic> copumpkin, thank you
19:24:47 <kmc> :t 'x'
19:24:48 <lambdabot> Char
19:25:31 <iaefai> SLEEPY TIME, good night
19:25:48 <kmc> :t product [1..]
19:25:49 <lambdabot> forall t. (Num t, Enum t) => t
19:26:45 <ezyang> Oh, that's for Hoogle 4.
19:29:41 <ivanm> iaefai: ssshhh! stop shouting, you'll wake yourself!
19:29:50 <iaefai> What What What?
19:30:32 <ivanm> all caps == shouting on the internetz
19:32:38 <iaefai> ivanm: je le sais, mon ami.
19:33:28 <ivanm> iaefai: пирипрошою, але я не можу ховорити по Францускому
19:34:13 <iaefai> I am afraid my cyrillic is a little rusty and google only knows 'french' on the end
19:34:47 <ivanm> heh
19:35:22 <ivanm> eh, google fails as well even when I specify the correct language...
19:35:29 <ivanm> (then again, my spelling could be wrong...)
19:35:38 <ivanm> I said "I'm sorry, but I don't speak French" ;-)
19:36:29 <kamatsu> 俺は語学力が最高だよ
19:36:30 <iaefai> Ah, speaking isn't required, only reading :p
19:37:01 <hiptobecubic> reading isn't required either. Only copy-pasting
19:37:02 <yrlnry> That's the punchline of a joke I once read that was written by William Caxton, around 1450.
19:37:03 <iaefai> kamatsu: 神もあなたを愛して
19:37:23 <yrlnry> Except it was in Middle English.
19:37:31 <iaefai> But my alcohol soaked mind must go to lay down and sleep
19:37:37 <iaefai> I thank you for the wonderful evening :p
19:37:42 <yrlnry> "Ey speaketh not Frensshe," or some such.
19:37:51 <iaefai> I must read about graph data structures tomorrow
19:37:52 <yrlnry> Sure wish I could find that again.
19:37:56 <iaefai> I will be back..
19:38:00 <copumpkin> 肛門が大好き
19:38:16 <kamatsu> iaefai: そうだよね。俺は神さまだから
19:38:27 <copumpkin> ¬_¬
19:38:41 <Cale> copumpkin: ...
19:38:54 <kamatsu> copumpkin: ...
19:39:01 <copumpkin> >_>
19:39:06 <kamatsu> ほんとう？
19:39:16 <copumpkin> <_<
19:39:21 <jfoutz> v_v
19:39:24 <copumpkin> もちろん
19:40:00 <kamatsu> uh..そうですか。。。
19:40:18 * ivanm sees lots of empty boxes...
19:40:49 <kamatsu> ivanm: UTF8の方がいい
19:40:52 <copumpkin> BO2Kの肛門！ (http://en.wikipedia.org/wiki/Back_Orifice_2000)
19:41:11 <ivanm> kamatsu: I guessed it was utf-8; however, my font can't display it
19:41:13 <copumpkin> 人間のじゃない
19:41:53 <kamatsu> ivanm: ほっかのフォントをして下さい。
19:42:17 <ivanm> @slap copumpkin and kamatsu
19:42:17 * lambdabot hits copumpkin and kamatsu with an assortment of kitchen utensils
19:42:36 <copumpkin> :)
19:42:39 <ivanm> Cale: any idea why ghc 6.12 doesn't like this? class (Graph (g n e), n ~ VLabel (g n e), e ~ ALabel (g n e)) => MappableGraph (g n e)
19:42:50 <ivanm> it says "Type found where type variable expected" :s
19:43:00 <copumpkin> ivanm: equality in superclass constraints isn't allowed yet
19:43:05 <copumpkin> ivanm: as far as I know, at least
19:43:19 <ivanm> actually, even if I remove all the class constraints it still complains...
19:43:26 <ivanm> copumpkin: I was checking to see if 6.12 likes them yet
19:43:35 <copumpkin> ivanm: nope, not until 6.14 afaik
19:43:39 <ivanm> :(
19:43:43 <ivanm> but I needz them!
19:43:46 <copumpkin> it needs a change to core, TacticalGrace said I think
19:44:42 <kamatsu> yep
19:44:56 <ivanm> :(
19:45:17 <ivanm> Cale: OK, can you think of any other way of specifying how to define MappableGraph then?
19:45:27 * copumpkin feels unwanted and leaves
19:45:49 <ivanm> copumpkin: it took you this long to get the hint?
19:45:50 <ivanm> :p
19:45:54 * BMeph feel bamboo shoots and leaves
19:45:56 <copumpkin> yeah, I'm slow :(
19:46:06 <ivanm> copumpkin: nah, I'm asking Cale because this is from something we've been working on on and off for about 6 months now
19:46:21 <copumpkin> ah, the famous graph stuff to replace FGL I hope :)
19:46:30 <hiptobecubic> How does one deal with what would normally be a loop in an imperative language? I'm trying to do this very simple example problem http://www.codechef.com/problems/TEST/ . The python in me wants to call getLine and print until the right line is found. How does haskell want to do this?
19:46:39 <Axman6> recursion!
19:46:47 <kamatsu> recursion!
19:46:47 <ivanm> either directly or indirectly!
19:46:50 <copumpkin> or higher-order functions to avoid explicit recursion (but they still do it behind the scenes)
19:46:54 <ivanm> Axman6: next week is O'Week at ANU, right?
19:47:02 <ivanm> copumpkin: hence my indirectly
19:47:05 <Axman6> i believe so
19:47:11 <Axman6> one sec
19:47:12 <ivanm> or, if you prefer, explicit and implicit recursion
19:47:24 <Axman6> ivanm: week after next
19:47:28 <kamatsu> hiptobecubic: the way I would actually do it is to call getContents and then use lines
19:47:31 <ivanm> Axman6: :o
19:47:35 <ivanm> I thought it was next week...
19:47:36 <copumpkin> ivanm: my message was close enough to yours that I didn't actually see it before sending it :)
19:47:44 <kamatsu> hiptobecubic: because the IO is lazy, the resulting program will be essentially the same
19:47:46 <Axman6> 15th - 19th
19:47:55 <ivanm> copumpkin: excuses, excuses
19:48:13 <kmc> hiptobecubic, do you know about map and its friend mapM ?
19:48:29 <kmc> IO isn't generally lazy, but getContents is
19:48:30 <copumpkin> I'd want an untilM
19:48:41 <ivanm> kmc: no, for recursion you're more likely to want the folds IMHO
19:48:48 <ivanm> (since maps can be written as folds)
19:48:53 <hiptobecubic> So read a line, if it's not 42 then print it and (read a line, if it's not 42.....) otherwise...? what? return some kind of null?
19:49:02 <copumpkin> untilM ftw
19:49:04 <kamatsu> hiptobecubic: here's my solution
19:49:09 <kmc> hiptobecubic, Haskell *is* an imperative langauge, or more precisely Haskell's IO type is an imperative language embedded in Haskell
19:49:21 <kmc> when your task is inherently imperative it's not wrong to think in imperative terms
19:49:47 <kamatsu> hiptobecubic: main = getContents >>= filter (/="42") . lines
19:49:52 <kamatsu> oops
19:49:55 <ivanm> Axman6: hmmm.... for some reason I thought it was next week
19:49:57 <copumpkin> =<<
19:50:02 <ivanm> oh well, looks like I start during O'Week...
19:50:04 <hiptobecubic> I don't think i'm yet capable of labeling tasks as inherently functional or imperative yet.
19:50:32 <ivanm> kmc: I would say that it can be treated as an imperative language to an extent rather than saying it's imperative
19:50:33 <kamatsu> hiptobecubic: main = getContents >>= putStrLn . unlines . filter (/= "42") . lines
19:50:49 <kmc> ivanm, it supports imperative programming as well as any other language
19:50:51 <kamatsu> hiptobecubic: oh, which can be more easily written as
19:50:57 <copumpkin> imperative in this context means "we don't yet have nice clean semantics for"
19:51:06 <ivanm> heh
19:51:17 <kamatsu> hiptobecubic: main = interact $ unlines . filter (/= "42") . lines
19:51:35 <kmc> :t interact
19:51:36 <lambdabot> (String -> String) -> IO ()
19:51:57 <kamatsu> > (unlines . filter (/= "42") . lines) "abc\n42\ndef"
19:51:58 <Axman6> kmc: that doesn't quite follow the spec though
19:51:59 <lambdabot>   "abc\ndef\n"
19:52:08 <hiptobecubic> kamatsu, i need to spend some more time reviewing syntactic sugar apparently.
19:52:22 <kmc> there's not much sugar there
19:52:25 <Axman6> hiptobecubic: where's the systatic sugar?
19:52:27 <kamatsu> hiptobecubic: sorry, I wrote that in point free style
19:52:30 <kmc> (.) and (>>=) are ordinary infix operators
19:52:34 <kamatsu> hiptobecubic: here's the pointful version
19:52:34 <kmc> they're not built in sugar
19:52:55 <hiptobecubic> kmc, oh
19:52:56 <kmc> the section (/= "42") is sugar for (\x -> x /= 42)
19:52:58 <hiptobecubic> :t (.)
19:52:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:53:12 <kamatsu> main = interact (\v -> unlines (filter (/= "42") (lines v)))
19:53:30 <Axman6> main = do { line <- getLine; if line == "42" then return () else putStrLn line >> main }
19:53:43 <kamatsu> Axman6: ew!
19:53:46 <kmc> main = interact f where f v = unlines (filter (/= "42") (lines v))
19:53:56 <Axman6> kmc: at least mine matches the spec :)
19:53:59 <kmc> ;)
19:54:06 <hiptobecubic> Axman6, haha. At least i can read yours ;)
19:54:07 <Axman6> uh, kamatsu even
19:54:31 <kamatsu> hiptobecubic: that's using lots of syntactic sugar
19:54:40 <kmc> this is a situation where it'd be easy to get confused about what return does
19:54:42 <kamatsu> hiptobecubic: without the sugar, it looks like this:
19:55:01 <hiptobecubic> yes, let's be sugarfree for now.
19:55:05 <kamatsu> hiptobecubic: main = getLine >>= \line -> if line == "42" then return () else putStrLn line >> main
19:55:22 <kmc> hiptobecubic, "do" sugar is closer to traditional imperative code than the underlying (>>=) operator
19:55:29 <kmc> so it may be easier to understand
19:55:52 <Axman6> main = do line <- getLine; when (line == "42") (putStrLn line >> main )
19:56:00 <Axman6> uh, should be /=
19:56:03 <kamatsu> Axman6: why use >> at all?
19:56:07 <kmc> hey now, if is also sugar ;)
19:56:17 <kmc> main = getLine >>= \line -> case line == "42" of { True -> return (); False -> putStrLn line >> main }
19:56:20 <Axman6> kmc: no, it's syntax :P
19:56:26 <copumpkin> so is do
19:56:30 <kamatsu> no, it compiles down to Case syntax
19:56:32 <copumpkin> but we call it sugar
19:57:02 <dmwit> It's all sugar for lambda-calculus constructs.
19:57:09 <kamatsu> ah, here's the true sugar reduction:
19:57:10 <copumpkin> damn right
19:57:19 * dmwit high fives copumpkin
19:57:35 * copumpkin is really short and can't reach
19:57:40 <kmc> sort of... in a practical implementation it's all sugar for lambda, let, case, variables, constructors, and application
19:57:41 * Axman6 wonders how many C programs are written with a recursive main function
19:57:42 <kmc> and primops maybe
19:57:43 <copumpkin> I am a vegetable, after all
19:57:49 <kmc> Axman6, a lot of IOCCC programs ;)
19:57:55 <dmwit> =)
19:57:55 <Axman6> heh
19:57:57 <kamatsu> main = let a True = return (); a _ = putStrLn line >> main in getLine >>= \line -> a (line == "42")
19:58:38 <syntaxglitch> pff, let is just syntactic sugar for applying a lambda to the given value
19:58:41 <dmwit> \line -> a (line == "42") === a . (== "42")
19:59:03 <kmc> syntaxglitch, not with respect to polymorphism
19:59:08 <kamatsu> dmwit: I know, we were avoiding points free
19:59:16 <ivanm> kmc: there's an idea; try to write obfuscated Haskell versions of obfuscated C programs...
19:59:17 <dmwit> oh
19:59:20 <kmc> or with respect to where things are actually stored in a STG machine implementation
19:59:26 <dmwit> Is there a newbie in our midst?
19:59:29 * hiptobecubic faints
19:59:30 <kamatsu> dmwit: yeah
19:59:33 <kamatsu> hiptobecubic
19:59:33 * Axman6 quite likes http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16899#a16899
19:59:38 <dmwit> Hiya, hiptobecubic!
19:59:48 <syntaxglitch> kmc, spoil my fun :(
19:59:48 * copumpkin puts on his newbie hat
19:59:55 * hiptobecubic is still bleeding from his ears
20:00:05 <dmwit> hiptobecubic: ignore those jerks, they're just showing off ;-)
20:00:07 <dmwit> (me too)
20:00:08 <kamatsu> copumpkin: you could just change putStrLn line >> main into another do block
20:00:13 <kamatsu> copumpkin: look even more imperative
20:00:21 <copumpkin> why me? I didn't write that!
20:00:24 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16900#a16900 here's the ACTUAL desugaring ;)
20:00:40 <kamatsu> argh, core
20:00:48 * kmc cannot read core
20:00:52 <syntaxglitch> kmc, now that's elegant code
20:00:54 <Axman6> is that core?
20:00:54 <copumpkin> kmc: is that pre-simplifier?
20:00:56 <copumpkin> yep
20:01:00 <dmwit> singleLine = do { line <- getLine; when (line /= "42") (putStrLn line) }; main = forever singleLine
20:01:03 <kmc> it's from -fext-core
20:01:04 <copumpkin> it's a lot more legible without the fully qualified names
20:01:05 <hiptobecubic> What the hell is this
20:01:05 <aavogt> z encoded too
20:01:05 <kmc> whatever that is
20:01:10 * Axman6 can read core, and feels that's not it
20:01:14 <copumpkin> it's external core
20:01:18 <copumpkin> slightly different from internal core
20:01:23 <Axman6> ah
20:01:26 <ivanm> dmwit: so how do you quit that?
20:01:34 * Axman6 uses ghc-core a fair bit, or used to anyway
20:01:39 <kmc> Haskell is like sausage
20:01:45 <dmwit> ivanm: whoops
20:01:50 <dmwit> ivanm: bad translation =)
20:01:50 <aavogt> call System.Exit.exitSuccess
20:02:00 <kamatsu> http://www.cse.unsw.edu.au/~liamoc/obf.html
20:02:11 <kamatsu> this was my first attempt at obfuscated haskell
20:02:32 <ivanm> @slap kamatsu
20:02:32 * lambdabot loves kamatsu, so no slapping
20:02:35 <ivanm> grrr...
20:02:41 <kmc> kamatsu, nice
20:02:51 <syntaxglitch> kmc, yes, but what kind of sausage
20:03:03 <hiptobecubic> kamatsu, what does it do?
20:03:04 <syntaxglitch> given where GHC is from I'm going with it being a haggis
20:03:06 <Axman6> @. pl undo main = do line <- getLine when (line /= "42") (putStrLn line >> main)
20:03:07 <lambdabot> Parse error at "=" (column 6)
20:03:15 <kmc> this M type is very strange
20:03:17 <Axman6> @. pl undo do line <- getLine when (line /= "42") (putStrLn line >> main)
20:03:17 <lambdabot> Parse error at end of input
20:03:19 <ivanm> syntaxglitch: nowadays it's from cambridge...
20:03:21 <idnar> Haskell is like onions
20:03:28 <kmc> what's it good for?
20:03:32 <Axman6> @. pl undo do { line <- getLine; when (line /= "42") (putStrLn line >> main)}
20:03:32 <lambdabot> liftM2 when ("42" /=) ((>> main) . putStrLn) =<< getLine
20:03:40 <Axman6> obvious!
20:04:03 <Axman6> hmm,. i don
20:04:13 <Axman6> don't like the mix of IO and function monads there
20:04:37 <aavogt> @type liftM2 when ("42" /=) (const ?main <=< putStrLn) =<< getLine
20:04:38 <lambdabot> (?main::IO ()) => IO ()
20:04:47 <kamatsu> ah, look, the easy points free way of doing it is clear already
20:04:58 <kamatsu> main = interact $ unlines . filter (/= "42") . lines
20:05:10 <Axman6> kamatsu: that doesn't work tough
20:05:16 <dmwit> kamatsu: not quite
20:05:17 <kamatsu> Axman6: why not?
20:05:23 <aavogt> need to set lineBuffering or something
20:05:23 <dmwit> kamatsu: It doesn't quit when you type 42.
20:05:27 <kamatsu> oh
20:05:31 <ivanm> yeah, @pl needs rewrite rules...
20:05:33 <kamatsu> you're meant to quit?
20:05:35 <kamatsu> damn
20:05:36 <dmwit> kamatsu: and takeWhile doesn't fix that =)
20:05:37 <ivanm> kamatsu: heh
20:05:41 <Axman6> it won't terminate, interact takes a line at a time, passes it to the function, and prints the string result, and starts again
20:06:00 <kamatsu> right, hm, ok
20:06:07 <aavogt> needs a callCC?
20:06:36 <dmwit> :t untilM
20:06:37 <lambdabot> Not in scope: `untilM'
20:06:52 <kamatsu> main = putStrLn . unlines . takeWhile (/="42") . lines =<< getContents
20:06:56 <Axman6> kamatsu: also, i'm disappointed that your obfuscated haskell thing doesn't spell anything
20:07:04 <kamatsu> Axman6: ah, i should do that
20:07:04 <dmwit> kamatsu: same problem
20:07:13 <kamatsu> dmwit: what's wrong with that?
20:07:16 <dmwit> kamatsu: doesn't quit when you hit 42
20:07:21 <kamatsu> yes it does
20:07:24 <aavogt> it should
20:07:24 <dmwit> Try it. =)
20:07:27 <kamatsu> i did
20:07:33 <kamatsu> i submitted it to that online judge
20:07:35 <kamatsu> it passed
20:07:39 <kamatsu> that was my solution ;)
20:07:49 <dmwit> Oh, I didn't know about any online judge.
20:08:08 <kamatsu> anyway, what did you see was wrong with it?
20:08:11 <kamatsu> lazy IO should work fine
20:08:15 <dmwit> Sure.
20:08:17 <kmc> you shouldn't really depend on the semantics of lazy IO
20:08:21 <dmwit> But it doesn't *actually quit* when you type 42.
20:08:24 <kmc> for interactivity
20:08:25 <dmwit> It will keep consuming input.
20:08:29 <kamatsu> no it wont
20:08:34 <kmc> but if the incoming lines are considered as a batch, it will not print any lines after the 42 appears
20:08:54 <kmc> the online judge is probably not interactive
20:09:01 <kamatsu> I just ran it interactively
20:09:04 <kamatsu> quit as soon as i typed 42
20:09:25 <dmwit> so it does
20:09:29 <dmwit> I am flabbergasted.
20:09:40 <copumpkin> :)R
20:09:52 <dmwit> So does the interact version.
20:09:54 <copumpkin> you can write fully interactive programs using just interact
20:09:59 <copumpkin> but it can be tricky
20:10:07 <dmwit> This is unexpected.
20:10:24 <kamatsu> it's cos getContents returns a lazy list of characters
20:10:25 <ivanm> dmwit: I'm guessing interact quits as soon as a blank line is found or something...
20:10:34 <ivanm> @src interact
20:10:35 <dmwit> ivanm: Not here.
20:10:35 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:10:47 <ivanm> hmmm.... it doesn't
20:10:56 <ivanm> dmwit: so how does it quit?
20:10:57 <kamatsu> it's because of getContents
20:11:06 <kamatsu> it gives a lazy list, if I stop consuming the list, it quits
20:11:11 <domor> > ree"残念ながら日本語はよく扱わないランブダちゃんは。"
20:11:12 <lambdabot>   Not in scope: `ree'
20:11:19 <copumpkin> :O
20:11:19 <ivanm> kamatsu: ahhh, yes
20:11:27 <domor> > repeat "残念ながら日本語はよく扱わないランブダちゃんは。"
20:11:28 <lambdabot>   ["\27531\24565\12394\12364\12425\26085\26412\35486\12399\12424\12367\25201\...
20:11:41 <copumpkin> cycle maybe?
20:11:43 <dmwit> In light of this, I strongly endorse the "interact" version: main = interact $ unlines . takeWhile (/= "42") . lines
20:11:47 <kamatsu> because lines and unlines do not demand all the input, then it's fine
20:12:07 <copumpkin> deep black magick
20:12:14 <Axman6> dmwit: i don't, because i dooubt it works
20:12:26 <kamatsu> Axman6: it does work, we just tried it
20:12:28 <Axman6> interact passes one line at a time to the function
20:12:32 <Axman6> hmmmmm
20:12:32 <copumpkin> nope
20:12:35 <kamatsu> Axman6: no it doesn't
20:12:41 <domor> > putStrLn "テスト"
20:12:42 <lambdabot>   <IO ()>
20:12:42 <kamatsu> Axman6: stdin passes one line at a time to your program
20:12:42 <copumpkin> it gives you stdin
20:12:55 <kamatsu> Axman6: (by default, this can be changed)
20:13:28 <dmwit> > expr "hey" :: Expr
20:13:29 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:13:29 <lambdabot>         against inferred ...
20:13:33 <dmwit> > fun "hey" :: Expr
20:13:34 <lambdabot>   hey
20:13:38 <kamatsu> If you turn off stdin buffering, and stop reading input halfway through a line, then your program will quit immediately.
20:13:48 <dmwit> > fun "テスト" :: Expr
20:13:49 <lambdabot>   テスト
20:13:56 <domor> (I have this feeling that putStrLn would display the string correctly but show converts all japanese characters to their unicode value)
20:14:00 * jrockway checks status of overnight batch job
20:14:02 <jrockway> "Prelude.foldr1: empty list"
20:14:03 <lambdabot> omg I can talk
20:14:04 <augur> dmwit: WHAT
20:14:10 * jrockway hates partial functions :]
20:14:17 <domor> dmwit: nice :)
20:14:17 <kmc> er, how is a character different from its unicode value?
20:14:33 <ivanm> jrockway: why?
20:14:40 <copumpkin> kmc: are you your social security number? :P
20:14:40 <domor> as in, displaying \27531 instead of テ
20:14:43 <dmwit> domor: putStrLn would maybe behave correctly, if you have GHC 6.12 and the proper locale set.
20:14:44 <augur> > fun "> >" :: Expr
20:14:45 <lambdabot>   > >
20:14:49 <Cale> > text "手すト"
20:14:50 <lambdabot>   手すト
20:14:58 <ivanm> jrockway: hate the person who uses partial functions unsafely, not the function itself
20:14:59 <kamatsu> > text "\27531"
20:15:00 <lambdabot>   残
20:15:05 <augur> !!
20:15:06 <jrockway> ivanm: fair enough :]
20:15:08 <kamatsu> er, that's not て
20:15:10 <lambdabot> 何時？
20:15:11 <augur> now wheres that other lambda bot we had
20:15:15 <dmwit> Cale: Thanks, I always forget that one.
20:15:26 <domor> ah yes my bad
20:15:37 <ivanm> Cale: trying to use ~ in the constraint for MappableGraph still doesn't seem to work in 6.12; any other ideas how we can do this?
20:15:46 <domor> :t text
20:15:47 <lambdabot> String -> Doc
20:15:54 <copumpkin> ivanm: use MPTC and fundeps?
20:16:05 <augur> man
20:16:05 <copumpkin> ivanm: it's fairly straightforward to translate
20:16:08 <augur> cale
20:16:09 <ivanm> copumpkin: we're using associated types everywhere else
20:16:13 <augur> where were you last night :(
20:16:33 <copumpkin> ivanm: yeah, but there's not much to do otherwise... just treat it as a hack until superclass equality constraints are supported?
20:16:54 <ivanm> copumpkin: the problem is, for this class i need to have the instantiating type be of kind * -> * -> *, and then match the types up
20:17:01 <ivanm> having _both_ is the problem :s
20:17:07 <copumpkin> I guess
20:17:17 <copumpkin> you should definitely pester TacticalGrace then :P
20:17:22 <copumpkin> the more you annoy him, the quicker he'll do it ;)
20:17:27 <augur> someone build a quine for lambdabot
20:17:38 <ivanm> copumpkin: thing is, that isn't what's causing the problem atm :s
20:17:58 <aavogt> copumpkin: interesting strategy in GHC development :)
20:18:04 <ivanm> "class MappableGraph (g n e)" gives "Type found where type variable expected" :s
20:18:13 <dmwit> augur: \bot is battle-hardened by like a decade of attacks
20:18:29 <augur> dmwit: but there were two bots here last night :)
20:18:31 <ezyang> what was the name for "ghci scripts"?
20:18:37 <dmwit> augur: Even for those.
20:18:37 <copumpkin> ivanm: can you even write that kind of instance header?
20:18:39 <domor> > text "hi" $$ nest 5 (text "there")
20:18:40 <lambdabot>   hi   there
20:18:42 <augur> dmwit: :|
20:18:46 <dmwit> augur: All results have a space at the beginning.
20:18:48 <copumpkin> ivanm: I've never seen something so general :P
20:18:59 <aavogt> @quote no
20:18:59 <lambdabot> <copumpkin> says: I love: Warning: Due to a known bug, the default Linux document viewer evince prints N*N copies of a PDF file when N copies requested. As a workaround, use Adobe Reader acroread
20:18:59 <lambdabot> for printing multiple copies of PDF documents, or use the fact that every natural number is a sum of at most four squares.
20:19:01 <dmwit> augur: And there's a hack to deal with the URL plugin, though I don't remember what it is.
20:19:05 <augur> interesting!
20:19:09 <ezyang> I recall there being some sort of special file for scripting GHCI
20:19:14 <copumpkin> ivanm: it's basically saying I want a * kind, but it has to have come from a * -> * -> * being applied
20:19:25 <augur> dmwit, sneaky
20:19:26 <shachaf> ?where test
20:19:27 <lambdabot> ?botsnack
20:19:27 <dmwit> ezyang: .ghci ?
20:19:33 <copumpkin> or rather, a X kind, but it must have come from a * -> * -> X
20:19:44 <shachaf> If there were two bots, you could probably make a loop.
20:19:49 <ivanm> copumpkin: yeah :s
20:19:57 <ezyang> that might be it.
20:20:12 <dmwit> shachaf: That has been done... I'm surprised that that hole hasn't been fixed.
20:20:12 <copumpkin> ivanm: so I'm not sure GHC even supports such an expressive class definition :/
20:20:13 <domor> I think the bot look has been tried many times, but the spaces thwarth it
20:20:16 <copumpkin> even with superclass constraints
20:20:20 <ivanm> copumpkin: thing is, I need the kind to define functions like nmap, but I then need to match up those type variables with the classes defined earlier :s
20:20:24 <ivanm> @hoogle nmap
20:20:24 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
20:20:42 <shachaf> dmwit: Has anything been changed about lambdabot for the last few years? :-)
20:20:49 <domor> oh I see
20:20:51 <dmwit> Well, we have Caleskell now. =)
20:21:05 <copumpkin> ivanm: I'd ask on the ghc users mailing list, myself :) it doesn't seem like it'd be fundamentally difficult to make that happen, but I don't think it's allowed right now
20:21:08 <copumpkin> could be wrong though :)
20:21:21 <ivanm> actually, I may have an idea...
20:22:10 <copumpkin> ivanm: actually, I don't even understand what that class is supposed to mean
20:22:11 <ivanm> nope, that fails
20:22:22 <ivanm> @hoogle Graph
20:22:23 <lambdabot> module Data.Graph
20:22:23 <lambdabot> module Data.Graph.Inductive.Graph
20:22:23 <lambdabot> Data.Graph type Graph = Table [Vertex]
20:22:28 <ivanm> bah
20:22:42 <copumpkin> class MappableGraph (g n e), that is
20:22:45 <dmwit> > succ . "rdd\USvg`s\USH\USld`m>"
20:22:46 <lambdabot>   "see what I mean?"
20:22:58 <ivanm> copumpkin: so I've got a whole bunch of classes that represent graphs that use associated types to define labels (because a lot of graphs will just have () or something as the label)
20:23:02 <copumpkin> class (n ~ Node g, e ~ Edge g) => MappableGraph g ?
20:23:20 <ivanm> copumpkin: fails; how can I define something like nmap then?
20:23:23 <ivanm> @hoogle nmap
20:23:23 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
20:23:40 <ivanm> copumpkin: ^^ how do I specify the node label changing?
20:23:44 <copumpkin> hmm
20:24:03 <ivanm> what I want is that VLabel (g n e) == n, ALabel (g n e) == e
20:24:10 <ivanm> *what I want to specify
20:25:05 <copumpkin> just a sec, experimenting
20:29:37 <hiptobecubic> Sitting in here is not like sitting in other language channels.
20:29:44 <copumpkin> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16901#a16901
20:29:46 <copumpkin> ugly :)
20:29:54 <ivanm> yeah; unlike ##java we're polite and helpful!
20:29:55 <ivanm> ;-)
20:30:41 <kmc> hiptobecubic, how so?
20:30:47 <copumpkin> ivanm: I wonder if it can be done more elegantly than that though
20:30:56 <kmc> polite except to other languages or people who like them
20:31:15 <ivanm> copumpkin: no, no, no... it's fitting it in with all the -other_ classes that's the problem!
20:31:24 <ivanm> kmc: exactly! ;-)
20:31:45 <ivanm> well, there's some langauges we're ambivalent towards... >_>
20:31:47 <kmc> we need to teach lambdabot to give snarky prepackaged responses on command
20:31:48 <copumpkin> ivanm: well, what I wrote sort of works :/
20:31:52 <kmc> then we'll be like ##c++
20:31:54 <kmc> the only one i know of is
20:31:55 <kmc> @faq
20:31:55 <lambdabot> The answer is: Yes! Haskell can do that.
20:31:56 <copumpkin> but yeah, I don't know how your other things are set up
20:32:09 <domor> @vixen What do you think of C++?
20:32:09 <lambdabot> maybe. do you?
20:32:21 <copumpkin> nice
20:32:29 <ivanm> copumpkin: though your Graph type is an interesting idea...
20:33:12 <hiptobecubic> kmc, well for example... Sitting in python you see some layman /join, ask a strange question like, "how can i do complicated task X without using any of the standard functions that already do this?". Everyone else tells them to shut up and use the stl. Maybe a few people tell them that they shouldn't be doing that at all. Eventually someone duct tapes together a solution and the person thanks them and /quits
20:33:19 <ivanm> copumpkin: still have to work out how to tie it in with the other classes though
20:33:38 <hiptobecubic> In here, you all just shoot laser beams at each other and try to crash the interpreter bot.
20:33:44 <kmc> hehe
20:33:44 <medfly> heh
20:33:45 <copumpkin> ivanm: I might go further and make that Graph into a data family instead of a type family, so you can pick different underlying representations for different kinds of graphs, but that might be too much
20:33:51 <ivanm> hiptobecubic: whereas we have a game that we like to call "bludgeon the newbie with hyper-advanced solutions to trivial problems"!
20:33:58 <medfly> it's true
20:34:03 <copumpkin> ivanm: sounds fun though :) good luck!
20:34:08 <kmc> true, i remember asking how to do something strange and complicated in #python (for good reasons) and they assumed i was an idiot and told me to fuck off in as many words
20:34:17 <medfly> I avoid asking questions here because I can't make sense of the answers
20:34:20 <ivanm> copumpkin: well, yes, seeing as how the whole point is that the _classes_ specify the different graphs...
20:34:24 <medfly> normally
20:34:28 <hiptobecubic> kmc, it happens constantly
20:35:33 <hiptobecubic> medfly, :D
20:35:35 <ivanm> kmc: I was asking in ##java for a library that did something, they kept asking me why I wanted it, I eventually admitted that I needed it for a small part of a uni year-long group project, at which they promptly dismissed my question as a "homework problem" and refused to talk to me
20:36:13 <pikhq> ... Year-long project == homework?
20:36:19 <domor> the reason is, haskell programmers are so perfectionnist, they just can't stand *someone else's* code being dirty or possibly incorrect
20:36:24 <hiptobecubic> No one pays me, so I've thus far refused to learn java
20:36:34 <ivanm> pikhq: yup
20:36:36 <ivanm> go figure
20:36:44 <medfly> hehe
20:36:46 <ivanm> hiptobecubic: lucky bastard
20:36:49 <pikhq> hiptobecubic: Currently, I'm too busy figuring out new ways to abuse C.
20:36:59 <pikhq> Now, continuation-passing style!
20:37:16 <kmc> i think we're pretty good about giving a reasonable answer before golfing the problem using hyperarrow continuation functors or whatever
20:37:17 <pikhq> :P
20:37:26 <ivanm> pikhq: though in the end, turns out I didn't need the library
20:37:26 <kmc> @quote stereo
20:37:26 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:37:35 <Veinor> kmc: yeah.
20:37:36 <pikhq> @hoogle hyperarrow
20:37:37 <lambdabot> No results found
20:37:42 <pikhq> Aaaaw.
20:37:45 <pikhq> ivanm: Alas.
20:37:49 <ivanm> I was meant to be implementing the archival system (DB -> XML), and for some reason I figured they might want to get the archived data back into the DB
20:38:01 <hiptobecubic> kmc, sure. but i still have no idea what's going on
20:38:04 <domor> @quote arrows
20:38:04 <lambdabot> dmwit says: It's not complete until you use monads, arrows, and currying
20:38:07 <ivanm> I mean, otherwise what's the point of archiving the information if you're not going to use it ever again?
20:38:11 <hiptobecubic> I get the feeling that IO in haskell isn't very haskell-like
20:38:15 <Veinor> first you give the answer, then someone else goes 'well if you use the arrow monad with the ListT transformer, you can just liftM into it and rewrite it in terms of 7 applications of ap'
20:38:21 <ivanm> hiptobecubic: depends on how you do it
20:38:23 <Veinor> or something.
20:38:30 <ivanm> you _can_ use >>= and >> directly if you really want to
20:38:42 <Axman6> hiptobecubic: oh it's actually quite haskell like indeed, it's also (almost) pure
20:39:09 <aavogt> if you use  liftMn instead of   do and >>= (where possible), the ordering is less apparent
20:39:26 <aavogt> (where liftMn is liftM2, liftM3 ...)
20:39:27 <pikhq> hiptobecubic: Oh, it's quite Haskell-like until you have the audacity to actually *execute* the IO value.
20:39:32 <pikhq> :P
20:40:27 <hiptobecubic> Well i'm determined to at least get to the intermediate stage of this
20:41:11 <aavogt> is there really an intermediate stage?
20:41:35 <hiptobecubic> Well i'm at the novice stage right now, and i can barely read what you all are suggesting
20:42:09 <medfly> :-/
20:42:17 <pikhq> aavogt: Yes, there is.
20:42:24 <pikhq> aavogt: *We* sit at the intermediate stage.
20:42:32 <aavogt> anyways, there's lots to learn if you go beyond what's specified in H98
20:42:36 <idnar> eh, only the novice stage exists
20:42:37 <pikhq> aavogt: Oleg and Oleg alone is an advance programmer in Haskell.
20:42:46 <idnar> everything eles is just pretentiousness ;)
20:42:47 <pikhq> (or in any language)
20:42:49 <idnar> *else
20:42:50 <pikhq> :P
20:44:49 <copumpkin> I wonder if this oleg worship will ever end
20:45:04 <aavogt> Oleg warship
20:45:16 <kmc> pikhq is right.  Haskell programs that work with IO are pure functional programs that compute *descriptions* of how some IO could be done
20:45:24 <kmc> main is such a description
20:45:38 <kmc> the Haskell runtime will first evaluate the description, and then will execute what it says to do
20:45:53 <ivanm> anyone recall how to simplify ab/(a+b) ?
20:46:05 <ivanm> (as in not have an addition in the denominator)
20:46:12 <Veinor> Can't be done.
20:46:18 <kamatsu> Veinor: yes it can
20:46:22 <Veinor> ... nicely.
20:46:29 <kamatsu> multiply both sides by (a-b), i think
20:46:37 * ivanm grumbles and goes off to derive it again
20:46:41 <Veinor> that's a^2-b^2
20:46:42 <kamatsu> or something
20:46:42 <domor> that's for complex numbers
20:46:52 <Veinor> ivanm: it is equal to 1/(1/a+1/b), fwiw
20:46:53 <medfly> heh
20:47:05 <ivanm> @slap Veinor
20:47:05 * lambdabot submits Veinor's email address to a dozen spam lists
20:47:08 <domor> partial fractions?
20:47:19 <Veinor> hey, that might be simpler depending on your a and b.
20:47:21 <copumpkin> not sure I'd call partial fractions a simplification
20:47:38 <Veinor> but for general a and b, I would say that that's the simplest form.
20:47:38 <aavogt> there's only one factor in the denominator...
20:47:55 <copumpkin> I agree
20:47:59 <ivanm> well, technically my fraction is c^2 v^2/(c^2 - v^2)
20:48:27 <copumpkin> well, you can decompose the difference of squares in the denominator
20:49:09 <copumpkin> that'll factor the expression for you, but it'll be more "complicated"
20:49:27 * ezyang is being stupid and writing Python in Haskell. Whee! 
20:49:33 <copumpkin> Monty?
20:49:50 <Veinor> oh hey, ezyang, I meant to ask you something
20:49:56 <Cale> You could turn it into -c^2  - c^3 / (2 (v-c)) + c^3 / (2 (v+c))
20:50:01 <ezyang> Veinor: yo, what's up?
20:50:20 <Veinor> check zephyr, it's not really a here-ish question.
20:50:45 <Veinor> Wolfram Alpha suggests that (c v)^2/(c^2-v^2) is the simplest you can get that.
20:50:47 <copumpkin> :O
20:51:07 <ivanm> yeah, OK, I'm obviously doing this the wrong way
20:51:42 <ivanm> I seem to recall learning once that to 3 sig figs or so, relativistic effects only come into play when v >= 0.1 c
20:51:47 * copumpkin translates that in his head to "im doin it rong"
20:51:55 <ivanm> I'm trying to derive how to get that value
20:52:16 <ivanm> copumpkin: *sigh* you have both UK and USA citizenship, but you can't spell in either variant of English...
20:52:19 <aavogt> because  1^2 >>> 0.1^2
20:52:29 <copumpkin> ivanm: wut u mene
20:52:44 <ivanm> aavogt: I know
20:52:45 <tommd> cuz he don git it.
20:52:52 <aavogt> if you don't mind being 99% right
20:53:17 <ivanm> but how do you relate that to being 1% out to length contraction, etc.
20:53:36 <aavogt> > 1 / 0.99
20:53:37 <lambdabot>   1.0101010101010102
20:53:48 <Veinor> ivanm: well
20:53:49 <copumpkin> preflex: seen HaskellLove
20:53:49 <preflex>  HaskellLove was last seen on #haskell-in-depth 2 days, 4 hours, 45 minutes and 32 seconds ago, saying: tnx
20:53:54 <Veinor> gamma is 1/sqrt(1-v^2)
20:54:00 <ivanm> no it isn't
20:54:02 <Veinor> where we're using c = 1 for convenience
20:54:07 <ivanm> ahhh, k
20:54:16 <ivanm> so v = V/c
20:54:19 <jrockway> haha, so amusing... the place where my program died was in some extra validation checks that print a warning if something might be amiss
20:54:23 <Veinor> right.
20:54:25 <ivanm> jrockway: heh
20:54:29 <Veinor> so you take the derivative of that with respect to v
20:54:33 <tommd> preflex: seen ndm
20:54:33 <preflex>  ndm was last seen on #haskell 268 days, 18 hours, 35 minutes and 52 seconds ago, saying: plus with current compiler technology, it would be slower
20:54:43 <Veinor> and you see when the first-order term becomes significant
20:54:53 <Veinor> well, there is no first-order term
20:54:57 <ivanm> OK, that's obviously too advanced for the students to worry about
20:54:58 <jrockway> it's like failing a class for getting the extra credit problem wrong :]
20:55:02 <Veinor> so you take the second derivative and see when that becomes significant
20:55:06 <ivanm> I'll think of another way of demonstrating this instead
20:55:27 <Veinor> just show gamma as a function of v (or V/c) and show when it rises above some arbitrary threshold?
20:55:39 <ivanm> yeah
20:55:50 <Veinor> personally, since gamma is only 1.005 at .1c, I'd put it higher
20:56:24 <Veinor> depending on your definition of 'come into play', of course
20:56:31 <ivanm> yeah
20:57:52 <Veinor> if your students know the approximation that sqrt(1+x) is about 1+x/2 and 1/(1-x) is about 1+x for small x, you could use that
20:58:06 <Veinor> or in general, (1+x)^n is about 1+nx
20:59:23 <ivanm> yeah
20:59:31 <ivanm> maybe get them to do it visually
20:59:48 <ivanm> no, wait, they wouldn't have learnt how to do graphs yet...
21:00:04 <Veinor> what kind of students are these, anyway?
21:02:14 <ivanm> first year science students
21:02:35 <ivanm> this is going to be their first assignment (with a physics example obviously)
21:02:56 <Veinor> ahh.
21:04:08 <Axman6> ivanm: what're you doing?
21:04:34 <ivanm> Axman6: finishing off writing an assignment for my prof up here (which I should have finished last year) for a first year general science class
21:04:47 <Axman6> ah
21:11:10 <shapr> preflex: seen sw17tch
21:11:10 <preflex>  Sorry, I haven't seen sw17tch
21:11:25 <shapr> preflex: seen sw17ch
21:11:25 <preflex>  sw17ch was last seen on #haskell 26 days, 9 hours, 32 minutes and 13 seconds ago, saying: does the lack of name overloading bother any one? better yet, does any one have a good way to fix it that doesn't suck? :D
21:11:29 <shapr> ah
21:11:54 <ezyang> Slogging through the first chapter of mpilgrim's Dive Into Python doing straight-forward translations into Haskell is... kind of painful...
21:12:08 * ezyang is thoroughly repentant for attempting the exercise 
21:13:23 <shapr> mpilgrim's progress?
21:13:24 <ivanm> ezyang: so you should be
21:13:33 * ezyang nods vigorously 
21:13:42 <ivanm> ezyang: tutorials like that typically get you to write idiomatic Foo
21:13:52 <ivanm> which doesn't translate nicely into idiomatic Haskell
21:14:10 <copumpkin> unless you're a ninja
21:14:12 <ezyang> Right.
21:14:36 <ezyang> I'll just have to find another way to demonstrate Haskell is a perfectly reasonable imperative language...
21:14:42 <kmc> ugh ninjas again
21:14:51 <copumpkin> kmc: u mean u r not a ninja?
21:15:24 <kmc> no i just program at the syntax level
21:15:25 <ivanm> ezyang: why do you want to?
21:15:28 <copumpkin> :P
21:15:33 <kmc> i don't even use any universal co-cones
21:15:55 <ezyang> ivanm: I like Haskell's type system.
21:16:02 <ivanm> and?
21:16:10 <ezyang> and would love it if I could have it when I was doing imperative-style tasks
21:16:26 <ivanm> *shudder*
21:16:39 <Axman6> you'll often find that if you look closely, most imperative tasks are largely functional
21:17:24 <kmc> seems like the mismatch from Python might have more to do with dynamic types
21:17:43 <dmwit> There are five ninjas in this room, but you can't see them.
21:17:45 <ezyang> Axman6: I'm not quite sure I believe that. But I also am not sufficiently ninja, as copumpkin says.
21:18:02 <medfly> isn't imperativeness sometimes better for faster code?
21:18:06 <kmc> most imperative tasks are functional meta-tasks
21:18:08 * copumpkin slaps medfly 
21:18:12 <Axman6> ezyang: usually the only parts that need to be imperative are the IO parts
21:18:13 <copumpkin> BAD
21:18:14 <copumpkin> BAD
21:18:22 <ezyang> kmc: Yup, that's part of it. Also, wincing all the way as I went through the dictionary and lists sections
21:18:25 <dmwit> Did somebody get time in my denotational semantics??
21:18:37 <dmwit> That's gonna dirty *everything* up!
21:18:37 <ezyang> Axman6: Is that really true? What about STM? STRefs?
21:18:48 <kmc> a Haskell program is a pure functional program that computes an imperative program
21:18:50 <Axman6> ezyang: huh?
21:18:57 <ivanm> dmwit: such as in http://www.youtube.com/watch?v=zekiZYSVdeQ ? :p
21:19:20 <Axman6> hmm, so apparently 8735373 factorial is quite large
21:19:25 <kmc> who'd have guessed
21:19:36 <ivanm> strange that
21:19:36 <ezyang> Axman6: As in, one of the lovely things about being imperative in Haskell is you don't have to give the programmer all of the toys in IO.
21:20:02 <Axman6> ezyang: the lovely thing about haskell is that you realise you don't _have_ to be imperative
21:20:23 <ezyang> That's /super/ nice.
21:20:32 <ezyang> But... gtk2hs is forcing me to be imperative :-(
21:20:39 <Axman6> urgh
21:20:56 <copumpkin> supper
21:20:56 <Axman6> i wonder if gtk2hs compiles on 6.12.1 on OS X yet
21:21:26 <ezyang> copumpkin: late supper, at that :-)
21:21:35 <copumpkin> yep :)
21:21:37 <kmc> Axman6, about 188 million digits?
21:21:45 <ivanm> Axman6: it does if you apply the patch
21:21:50 <copumpkin> that's a fairly large number I guess
21:21:59 <copumpkin> and luckily we already know it's not prime
21:21:59 <kmc> i've seen bigger
21:22:02 <copumpkin> otherwise someone would have to test it
21:22:07 <Axman6> heh
21:22:18 <Axman6> copumpkin: what about fac 8735373 + 1?
21:22:21 <kmc> but (8735373! - 1) is prime, yes?
21:22:25 <copumpkin> gah, now I ahve to test that
21:22:29 <copumpkin> and that
21:22:53 <medfly> just google
21:23:27 <kmc> @vixen are you super nice
21:23:27 <lambdabot> nice? yeah, i'd say i'm nice
21:23:31 <Axman6> is the minimum number of tests you need to perform to test for primility length . takewhile (< sqrt n) $ primes?
21:23:38 <pikhq> copumpkin: For a new number, apply succ . factorial
21:24:01 <copumpkin> Axman6: we don't know what the minimum number is
21:24:02 * ezyang <3 probabilistic primality tests 
21:24:23 <Axman6> copumpkin: well, assuming something is prime i guess
21:24:28 <medfly> "one"
21:24:38 <pikhq> Axman6: Assuming a naive prime test.
21:24:51 <pikhq> :P
21:25:32 <Axman6> hmm, i think my program is creating a > 16MB Integer
21:26:05 <mreh> @hoogle Int -> [a] -> (a, [a])
21:26:05 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:26:06 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:26:06 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> e -> (a, q)) -> a -> d -> (a, [q])
21:26:15 <ezyang> "yay arbitrary precision math"
21:26:27 <ezyang> anyways, classes start tomorrow, better hit the sack
21:26:29 <ezyang> g'night all
21:26:41 <Axman6> o/
21:26:42 <mreh> it's 5am
21:26:43 * Cale tries PrimeQ[8735373! - 1] in mathematica :)
21:26:49 * Axman6 has two more weeks of holidays :D
21:27:06 <mreh> there's no list remove function
21:27:13 <mreh> that's an easy one to do recursively
21:27:22 <kmc> isn't it a theorem that n never divides (k*n + 1)
21:27:27 <kmc> for n > 1
21:27:40 <dmwit> kmc: sure
21:27:49 <ivanm> Axman6: what, you start classes on Tuesday afternoon? :p
21:27:50 <dmwit> kmc: But blah! may be divisible by something bigger than blah.
21:27:50 * Axman6 stabs mathematics and it's completely retarded licensing system
21:27:54 <medfly> makes sense?
21:27:54 <dmwit> err
21:27:56 <dmwit> blah! + 1
21:27:59 <kmc> oh right
21:28:06 <Cale> If there is a prime which divides 8735373! - 1, then it's larger than 8735373
21:28:28 <mreh> > largestPrime
21:28:29 <lambdabot>   Not in scope: `largestPrime'
21:28:36 <Axman6> Cale: any results form mathematica yet? :P
21:28:41 <Cale> Axman6: Nope
21:28:41 <kmc> > largestPrime
21:28:42 <lambdabot>   7
21:28:53 <mreh> lol
21:28:55 <mreh> sneaky
21:29:03 <Cale> Axman6: Weird cyclic memory usage pattern though.
21:29:08 <ivanm> Axman6: "licensing system"?
21:29:11 <dmwit> kmc: Are you an ultrafinitist? =)
21:29:20 <ivanm> do you mean mathematica rather than mathematics?
21:29:21 <Axman6> Cale: hmm?
21:29:28 <Axman6> mathematica
21:29:46 <ivanm> Axman6: it wants money; ergo it's licensing system is retarded
21:30:05 <ivanm> that's not even mentioning the retardedness of mathematica itself...
21:30:07 <Cale> it is licensing system is
21:30:11 <Axman6> nothing at all wrong with charging people for your software
21:30:30 * Axman6 hates both mathematica and matlab
21:30:36 <ivanm> @slap Cale
21:30:37 <lambdabot> stop telling me what to do
21:30:51 * medfly slaps Cale
21:30:56 <ivanm> thanks medfly
21:32:51 <Cale> The Mathematica frontend has some features that I think we should steal.
21:33:00 <Axman6> such as?
21:34:08 <Cale> Well, I really like the notebook interface as a combination editor/REPL, but now it has some really cool reactive GUI stuff.
21:34:46 <Axman6> implemented really awlfully
21:35:18 <Cale> Well, it seems to work nicely enough :)
21:35:42 <Cale> I doubt it has many lovely algebraic properties
21:35:43 <Axman6> it's really ugly though :(
21:36:06 <Cale> But it's easy to build working GUIs to manipulate and inspect things in real time.
21:36:20 <Axman6> yeah
21:51:40 <ivanm> Cale: I don't really like the notebook interface for "real" programs
21:52:03 <ivanm> maybe for an lhs2tex like thing where you're mixing a document with your code, but that's about it
22:01:47 <copumpkin> very nice, http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html
22:01:56 <copumpkin> basically like using named variables for StateT
22:08:50 <copumpkin> I dunno, I think that's a very neat hack :)
22:11:15 <aavogt> copumpkin: as compared to the standard solution of using a single (StateT RecordOfValues)?
22:11:28 <copumpkin> aavogt: you can't use multiple types safely that way
22:11:50 <copumpkin> and it isn't just for StateT
22:12:08 * ddarius tends not to use multiple StateTs, period.
22:12:10 <copumpkin> it's just a generic lifting solution to get you to any level in your transformer stack with a single call
22:12:38 <aavogt> how do you mean? It's as much effort to unwrap a single TStateT as it is to run with a new RecordOfValues (esp if you use some alternate record system)
22:12:56 <copumpkin> aavogt: oh I see what you mean
22:13:02 <copumpkin> I thought you meant a Map or something
22:13:18 <copumpkin> with a record you need a new datatype for your context
22:14:02 <copumpkin> anyway, the nested StateT isn't the only use case
22:14:23 <aavogt> what do you mean by "new datatype for your context"?
22:14:37 <aavogt> as in,  RecordOfValues - some entries?
22:14:50 <copumpkin> you'd need data FunctionFState = FunctionFState { x :: Int, y :: Bool, zomg :: String }
22:16:11 <aavogt> hmm, so for which monads does this named liftage not have such a workaround?
22:16:41 <aavogt> RWS all have alternatives (basically using tuples all the way)
22:17:02 <copumpkin> am I still on?
22:17:19 <aavogt> hmm, though different orderings might make a difference
22:17:23 <aavogt> yes you are
22:17:28 <copumpkin> phew
22:17:36 <copumpkin> somehow managed to reset my cable modem without dropping my connections
22:18:05 <aavogt> @unmtl WriterT a (ErrorT String (Writer b)) x
22:18:05 <lambdabot> (Either String (x, a), b)
22:21:18 <aavogt> @unmtl WriterT a (ContT (Writer b)) x
22:21:19 <lambdabot> err: `ContT (Writer b) (x, a)' is not applied to enough arguments.
22:21:23 <aavogt> @unmtl WriterT a (ContT r (Writer b)) x
22:21:23 <lambdabot> (x -> a -> (r, b)) -> (r, b)
23:18:08 * hackagebot upload: Lucu 0.4.2 - HTTP Daemonic Library (MasatakeDaimon)
23:36:49 <rv2733> 1
23:36:58 <ivanm> 2
23:37:25 <ezyang> Looks like I'm not asleep yet. Question for y'all: is there a ST transformer somewhere?
23:37:44 <copumpkin> STT? :P
23:37:49 <copumpkin> I doubt it
23:37:57 <ezyang> Sadface!
23:38:00 <copumpkin> like IO it tends to be the bottom
23:38:37 <ezyang> I'm now toying around with continuations to reimplement classic imperative looping constructs
23:38:58 <ezyang> "whee!"
23:40:15 <ezyang> here's one I have: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16909#a16909
23:41:50 <copumpkin> looks nice :)
23:41:57 <copumpkin> the inner/outer are from callCC?
23:42:02 <ezyang> Yup!
23:42:24 <ezyang> If I want to support multiple jumping ops I need to have multiple continuations
23:42:35 <copumpkin> now figure out how to do next/continue in your loops :P
23:42:38 <sinelaw> yo
23:42:38 <lambdabot> sinelaw: You have 3 new messages. '/msg lambdabot @messages' to read them.
23:42:54 <ivanm> hey sinelaw
23:43:17 <sinelaw> hey ivanm, just saw your messages
23:43:56 <sinelaw> i'm not sure i follow the problem
23:44:14 <ivanm> sinelaw: OK, atm the process with multiple graphs is this:
23:44:23 <ivanm> create one big String containing the dot code for _all_ of them
23:44:29 <ivanm> feed it in to dot/neato/etc.
23:44:34 <ivanm> get the entire String output out
23:44:42 <ivanm> parse the result
23:45:16 <ivanm> problem is, this is bog slow (I've just now wondered if it's the fault of ensuring the entire output String is received)
23:45:21 <sinelaw> aha. and the more logical thing to do would create a string for first, get output for first, etc.
23:45:25 <sinelaw> ?
23:45:34 <ivanm> (actually, for small lists of dot graphs, it's a tad faster than one at a time)
23:45:36 <sinelaw> (lazily, as you said in your message?)
23:45:41 <ivanm> sinelaw: right, that's what I'm trying to do
23:45:47 <ivanm> thing is, I can't seem to get it to do that
23:46:03 <sinelaw> hmm.
23:46:42 <ivanm> the "naive" approach doesn't get any output
23:46:48 <sinelaw> what i originally thought, was not pass lists of graphs at all
23:47:01 <sinelaw> i don't know how to do it in haskell, so i tell you how i've done it in python
23:47:12 <ivanm> well, you want to abstract away the whole process of starting dot, etc.
23:47:15 <sinelaw> keep the dot process running in a fork/thread
23:47:21 <copumpkin> ivanm: I want a findAllCliques function in your library btw ;)
23:47:36 <copumpkin> gotta run in polynomial time, too
23:47:39 <ivanm> copumpkin: I have one
23:47:42 <sinelaw> and whenever i want to parse a graph, i call the function and it passes it to the thread, and returns the result
23:47:45 <ivanm> don't know if it's polynomial or not though
23:47:52 <ivanm> copumpkin: (well, I have one for FGL graphs in graphalyze)
23:47:56 <copumpkin> I'll be very impressed if it is :)
23:48:05 <ivanm> yeah, I doubt it
23:48:09 <copumpkin> in fact, I'd steal it and publish it as proof of a certain question
23:48:15 <ivanm> sinelaw: see, that's what I tried to do under the hood
23:48:27 <sinelaw> ivanm, because i don't want to pass you lists of graphs at all
23:48:35 <megatron242> Hi
23:48:35 <ivanm> why not?
23:48:47 <sinelaw> i want to pass individual graphs, which become available during execution as the user works on the graph
23:48:51 <copumpkin> (it's NP-complete, in case you missed what I was alluding)
23:49:04 <megatron242> I have a small question in haskell, if I may
23:49:08 <ivanm> megatron242: shoot
23:49:18 <sinelaw> once in a while a new graph is ready to be parsed, i can't pass you the  list because i don't know what it should contain
23:49:20 <copumpkin> ivanm: don't shoot at megatron242
23:49:27 <ivanm> sinelaw: OK, reason why that's bad: if one fails, then the entire thing should fail
23:49:32 <ivanm> @slap copumpkin
23:49:32 * lambdabot pulls copumpkin through the Evil Mangler
23:49:40 <sinelaw> @quote robot
23:49:40 <copumpkin> ow!
23:49:40 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
23:49:41 <megatron242> I'm a real noob so it might be a stupid question, but here goes...
23:50:09 <megatron242> I have a list of numbers, and I want to iterate on all the sequencial pairs of numbers in the list
23:50:10 * copumpkin holds his breath
23:50:22 <Cale> megatron242: Feel free to ask any questions you might have, you'll be helping people to procrastinate :)
23:50:24 <copumpkin> > (zipWith <*> tail) [1..5]
23:50:25 <lambdabot>   Couldn't match expected type `a -> b -> c'
23:50:25 <lambdabot>         against inferred type `[...
23:50:25 <sinelaw> ivanm, you mean if one fails then the thread will not be able to continue?
23:50:30 <copumpkin> bahh
23:50:32 <sinelaw> ivanm, or what do you suggest
23:50:39 <ivanm> right
23:50:41 <Cale> megatron242: zip xs (tail xs) is the usual idiom
23:50:46 <copumpkin> > (zip <*> tail) [1..5]
23:50:47 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
23:50:54 <sinelaw> @pl f a (g a)
23:50:54 <ivanm> sinelaw: first of all, if the process can't run to start with, it should error out
23:50:54 <lambdabot> f a (g a)
23:51:03 <megatron242> 10x!
23:51:03 <sinelaw> @pl \a -> f a (g a)
23:51:03 <lambdabot> ap f g
23:51:03 <Cale> Or use <*> if you'd like to be fancy :)
23:51:06 <ivanm> if an individual graph can't be parsed, it should error out
23:51:15 <ivanm> (mainly because I use a lazy parser that assumes the input is correct)
23:51:19 <copumpkin> > (zipWith f <*> tail) [1..5] :: [Expr]
23:51:19 <lambdabot>   [f 1 2,f 2 3,f 3 4,f 4 5]
23:51:29 <Cale> (It's in Control.Applicative)
23:51:49 <ivanm> Cale: your usage of Functor everywhere is bad enough; stop scaring the newbie!
23:51:50 <megatron242> what does <*> means?
23:51:57 <sinelaw> megatron242,
23:51:59 <ivanm> @src (<*>)
23:52:00 <lambdabot> Source not found. I feel much better now.
23:52:01 <sinelaw> @type (<*>)
23:52:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:52:02 <ivanm> bah
23:52:04 <copumpkin> megatron242: it's fairly complicated, I wouldn't try looking just yet
23:52:24 <Cale> megatron242: Well, it's a generalised sort of function application.
23:52:29 <megatron242> cool
23:52:41 <copumpkin> megatron242: in this case, it's a generalization of the f x (g x) pattern that cale wrote in his answer to you
23:52:47 <Cale> megatron242: In this case, we're just using an instance where (f <*> g) x = f x (g x)
23:53:06 <megatron242> thanks for the help!
23:53:56 <sinelaw> ivanm, why is that a problem?
23:54:01 <ivanm> @hoogle Bytestring -> String
23:54:01 <lambdabot> Did you mean: ByteString -> String /count=20
23:54:01 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
23:54:01 <lambdabot> Prelude show :: Show a => a -> String
23:54:05 <sinelaw> i mean, is it not possible to implement what i meant?
23:54:17 <ivanm> sinelaw: it's possible; whether it's nice or safe is a different story
23:54:26 <sinelaw> it's an IO function, yeah
23:54:44 <sinelaw> Graph -> IO DoGr
23:54:48 <ivanm> sinelaw: because the process of calling dot should really be encapsulated away
23:54:53 <ivanm> sinelaw: right
23:55:09 <sinelaw> which behind the scenes it uses the thread to pass new info to a running dot process (or run it if it itsn't running yet)
23:55:14 * ezyang is having a hard time of thinking of a simple exercise that would use both continue and break... 
23:55:16 <ivanm> whereas you want a function that is IO (Graph -> IO Graph)
23:55:32 <sinelaw> i do? why
23:55:32 <ivanm> sinelaw: "behind the scenes" sounds awfully like mutable state...
23:55:41 <ivanm> sinelaw: to get the process
23:55:49 <sinelaw> ivanm, ah
23:56:25 <sinelaw> yeah it gets ugly
23:56:36 <ivanm> sinelaw: what you're doing sounds awfully like what I've heard gtk2hs code sounds like...
23:56:41 <ivanm> and a lot of people hate that ;-)
23:56:48 <sinelaw> i can understand why
23:56:58 <sinelaw> FRP would solve this :)
23:57:03 <ivanm> maybe
23:57:10 <sinelaw> _should_ solve this
23:57:28 <sinelaw> so for now, it's ok to not do it at all
23:57:42 <ivanm> sinelaw: calling an external function? I thought FRP was a way for your own program to act...
23:57:58 <sinelaw> FRP is also an alternative way to do IO
23:58:22 <ivanm> oh?
23:58:26 <ivanm> then FRP might solve it
23:59:26 <sinelaw> i'm not sure how. it's an interesting case.
23:59:32 <ivanm> yeah
23:59:51 <ivanm> sinelaw: ideally, this would be moot because I would FFI to the actual graphviz C libraries
23:59:52 <ivanm> but shmeh
