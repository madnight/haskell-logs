00:02:09 <ablmf> take 5 . scanl (*) 1 . repeat $ 10   could get   [1,10,100,1000,10000]
00:02:34 <ablmf> Is there any better method?
00:02:46 <ablmf> It looks a little complicate
00:02:51 <mauke> > iterate (* 10) 1
00:02:52 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
00:02:56 <mauke> > take 5 $ iterate (* 10) 1
00:02:57 <lambdabot>   [1,10,100,1000,10000]
00:06:58 <Dark_Shikari> how do I convert a map to a string for debugging purposes?
00:08:33 <mauke> show
00:09:01 <Dark_Shikari> hmm, guess that works
00:09:25 <mauke> showTree
00:18:15 <ibid> "Warning: Module `Prelude' is deprecated" - um, what?
00:19:38 <dons> wrong base being linked.
00:19:38 <c_wraith> ibid: you're using 6.12 and linking against base 3?
00:19:59 <dons> it's warning you that your app uses base 3, not base 4.
00:20:07 <dons> hey ibid :)
00:20:28 <ibid> c_wraith: i'm linking with whatever cabal decides to link with
00:20:43 <c_wraith> it's decided base 3, for whatever reason
00:20:46 <dons> yeah, so some lib has base < 4
00:22:55 <ibid> all the build-depends depend on base 4, according to ghc-pkg
00:23:14 <ibid> is there any simple way for me to pinpoint it further?
00:25:29 <dons> cabal -v2 or some such will tell you why it chooses things
00:26:25 <ibid> selecting base-3.0.3.2 (installed) and 4.2.0.0 (installed)
00:26:30 <ibid> Dependency base ==3.0.3.2: using base-3.0.3.2
00:26:43 <ibid> i have no such dependency in the cabal file
00:36:49 * hackagebot upload: bibtex 0.0.4 - Parse, format and processing BibTeX files (HenningThielemann)
00:46:20 <enthymene> ooh, I have to thank henning thielmann for his Polynomials module on haskell-cafe
00:46:23 <enthymene> eh, another time
00:46:25 <enthymene> g'night
00:50:57 <ibid> dons: i can't figure out why it's selecting base 3.  there appears to be no reason that i can tell
00:54:27 <ibid> hmm. "--constraint=containers ==0.3.0.0" in the internal configure call
00:54:36 <ibid> ah, sorry, wrong item
00:54:55 <ibid> "--constraint=base ==3.0.3.2"
00:55:32 <ibid> dons: any ideas what might be causing that?  the cabal file specifies base >= 1.0
00:59:01 <ibid> umph.  and cabal install --reinstall ansi-terminal replaces the base-4 depending version with a base-3 depending version
00:59:10 <ibid> something's borked
01:18:18 <ablmf> How to check a Floating is actually an Int?  And how to make type conversion?
01:18:44 <tensorpudding> Floating is a class, isn't it?
01:18:52 <tensorpudding> > 1.0 :: Floating
01:18:53 <lambdabot>   Class `GHC.Float.Floating' used as a type
01:19:26 <tensorpudding> in any case, floats are never ints, because they are different types
01:19:47 <tensorpudding> you can do a conversion of the int to a num, using fromIntegral
01:19:51 <tensorpudding> @type fromIntegral
01:19:52 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:20:10 <tensorpudding> > 1.00 == (fromIntegral 1)
01:20:11 <lambdabot>   True
01:21:43 <ablmf> I mean, if I get "r = sqrt w", how to check r is 2.0 or 3.0 ... Because I want to check if w is the squre of an Int
01:24:01 <tensorpudding> w is a float right?
01:24:28 <tensorpudding> hmm
01:24:30 <tensorpudding> :t floor
01:24:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:24:51 <tensorpudding> you could determine if it were equal to its floor
01:25:41 <Hunner> is there a way to trace the type of a return inside of a do?
01:25:58 <tensorpudding> floor is the function that rounds down a floating point to the largest integer less than it
01:26:05 <Hunner> maybe return is not the right word, but whatever
01:26:15 <tensorpudding> you'd have to munge with types using fromIntegral though
01:26:42 <tensorpudding> Hunner: the type of a return?
01:26:56 <Hunner> type of a statement inside of a do
01:27:58 <Hunner> It's pretty awkward to pull it into its own function to check the type, and :t doesn't work for lines of functions afaik
01:28:15 <tensorpudding> the types of statements in a do block are the same outside, except for where you use the special <- syntax
01:28:40 <Hunner> yep. lots of <- lines and working inside the IO monad
01:29:41 <Hunner> With all the lifting and stuff, the types get morphed
01:29:56 <tensorpudding> in the IO monad, a statement like foo <- bar means that bar has type IO a, and foo is a variable that is bound to the value enclosed in bar, of type a
01:30:47 <Hunner> I'm having to deal with things getting lifted to lists instead of IO and similar things, so it would be helpful to be able to check the type of statements in-line
01:31:37 <tensorpudding> you can test the parts to the right of a <-, and every line without a <- just fine
01:32:14 <tensorpudding> unless it uses a value which is set using <-, in which case you'll need to figure out what type it has first
01:33:25 <ablmf> What's wrong with this code?
01:33:30 <ablmf> http://pastebin.com/60NJvgaQ
01:34:35 <tensorpudding> the delta and delta' have different types
01:34:55 <tensorpudding> because floor returns instances of Integral
01:35:03 <tensorpudding> so you'll have to convert it from an integral again
01:37:28 <ablmf> tensorpudding: I modified the code : http://pastebin.com/yt6JeAX5
01:37:55 <ablmf> But get another error : No instance for (RealFrac Integer)
01:37:55 <ablmf>   arising from a use of `floor'
01:37:55 <ablmf>                at E:\Software\Code\Haskell\problem45.hs:9:18-29
01:39:45 <ablmf> I see, I make a small mistake
01:42:53 <tallpaul> hi, is it possible to write a lexer with parsec or have i to write it "external"?
01:43:51 <dmwit> It's possible.
01:44:41 <tallpaul> is there any example for writing a lexer in parsec out there?
01:48:01 <dmwit> Not sure!
01:49:25 <tallpaul> Or is there any special module within parsec for this task?
01:49:55 <dmwit> I guess there's the Language modules.
01:49:57 <fasta> What is illegal about the final instance here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22990#a22990
01:51:11 <wahjava> Hi everyone
01:51:23 <Hunner> @hoogle [[a]] -> [a]
01:51:23 <lambdabot> Prelude concat :: [[a]] -> [a]
01:51:23 <lambdabot> Data.List concat :: [[a]] -> [a]
01:51:23 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:52:06 <tallpaul> dmwit: thanks! :-)
01:52:42 <wahjava> Is there any better way of invoking functions with signature, 'fn :: a -> IO Bool' like 'fn >>= (\x -> return . (if x then foo else bar))' ?
01:53:11 <dmwit> fmap (\x -> if x then foo else bar)
01:53:21 <dmwit> fn
01:53:27 <dmwit> (forgot the last bit, heh)
01:53:59 <tensorpudding> or liftM
01:54:00 <wahjava> dmwit: so fn has to implement Functor ?
01:54:15 <dmwit> wahjava: No, there's liftM for Monad.
01:54:25 <tensorpudding> all Monads have a logical Functor instance with fmap = liftM
01:54:26 <dmwit> wahjava: But all Monads are Functors, too.
01:54:47 <tensorpudding> but they don't always define it
01:54:48 <wahjava> Oh, yes I forgot that, thanks dmwit tensorpudding :)
01:55:24 <tensorpudding> in the case of IO, it has Functor defined
01:58:26 <wahjava> Okay
01:58:30 <fasta> Why can't I write instance (MonadST m, MonadTrans t, Monad (t m)) => RefMonad (t m) (LazySTRef.STRef (StateThread m)) where?
01:59:44 <tensorpudding> it's actually a law of monads that a >>= (\x -> return (f x))  is equal to fmap f a
02:00:51 <fasta> Instead of StateThread m I cannot just write 's', so if this is illegal, it seems impossible.
02:01:01 <wahjava> okay
02:01:16 <tensorpudding> and you could define (>>=) in terms of fmap and join
02:39:36 <Hunner> GAAA. 3 hours wasted because I was using sFetchAllRows instead of sFetchAllRows'
02:40:04 <Hunner> With no obvious errors other than it just plain not working as expected
02:41:10 <tomberek> General Question: how does one avoid having to put "(Show a) =>" and "deriving Show" everywhere?
02:41:32 <Jonno_FTW> i am working through the IRC bot tutorial on the wiki
02:41:44 <Jonno_FTW> and can't figure out how to make it identify itself to nickserv
02:42:05 <Jonno_FTW> i got this: privmsg h ("nickserv : identify "++pass)
02:43:42 <tomberek> no, use "/msg NickServ identify YOURPASSWORD"
02:43:55 <tomberek> any answers to my question above ^^^?
02:44:36 <tensorpudding> you can avoid having to put (Show a) => by not having to use show on a data structure
02:44:53 <mauke> tomberek: "/msg" is not an IRC command
02:44:55 <dmwit> Jonno_FTW: If you're following the tutorial I think you're following, the channel is a global constant.
02:45:06 <Jonno_FTW> hmmm
02:45:15 <tomberek> mauke.,,,, yeah, i think i misunderstood the question
02:45:18 <dmwit> Jonno_FTW: You'll have to actually understand the privmsg function and modify it to send to things other than that channel. =)
02:45:38 <tomberek> but what about my question?
02:45:49 <dmwit> One generally doesn't avoid it.
02:46:03 <dmwit> I rather like knowing when a function is going to call show on my arguments.
02:46:14 <Jonno_FTW> according to the RFC, it's: PRIVMSG  <msgtarget> <text to be sent>
02:46:26 <mauke> tomberek: don't write type signatures
02:46:28 <Hunner> Jonno_FTW: yeah, you have to modify privmsg
02:46:43 <mauke> just use a server password
02:46:43 <tensorpudding> if you don't write type signatures you get fun warnings from GHC
02:46:46 <Jonno_FTW> oh right
02:46:47 <mauke> much easier
02:47:28 <tomberek> mauke: it just seems like overkill to paste that everywhere just to get it to work
02:47:32 <tensorpudding> well, you would if you have set -Wall
02:47:40 <Hunner> Jonno_FTW: it should take the form "PRIVMSG nickserv :identify password" when you've fixed it
02:47:54 <Jonno_FTW> yep
02:48:03 <mauke> or a server password
02:51:49 <Jonno_FTW> i got this
02:51:50 <Jonno_FTW> privmsg h user string = write h "PRIVMSG" (user ++ " :" ++ string)
02:52:44 <mauke> s/user/target/g
02:53:29 <Jonno_FTW> it still doesn't work though
02:53:54 <Hunner> :t nub
02:53:55 <lambdabot> forall a. (Eq a) => [a] -> [a]
02:55:20 <Hunner> Anyone know the efficiency of nub?
02:55:28 <Jonno_FTW> @src nub
02:55:28 <lambdabot> nub = nubBy (==)
02:55:33 <Jonno_FTW> @src nubBy
02:55:33 <lambdabot> nubBy eq []             =  []
02:55:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:56:34 <mauke> Hunner: O(n^2) if you use all of it
02:56:51 <tensorpudding> it can call filter a few times, it seems
02:57:00 <Hunner> privmsg c  s = mapM_ (\l -> write "PRIVMSG" (c ++ " :" ++ l)) (lines s) -- is what I have Jonno_FTW
02:58:07 <Hunner> but I edited a ton, so it looks like my write changed too
02:59:25 <Jonno_FTW> i got this
02:59:26 <Jonno_FTW> identify h = write h "PRIVMSG" ("nickserv identify "++pass)
02:59:47 <mauke> missing :
02:59:51 <Jonno_FTW> should there be a ':' in there?
02:59:53 <Jonno_FTW> where?
02:59:59 <mauke> before identify
03:00:22 <mauke> seriously, why bother registering a bot with freenode if you don't understand the basic IRC protocol?
03:00:47 <Hunner> to learn it?
03:00:49 <Jonno_FTW> i'm trying to learn you
03:01:16 <tensorpudding> you could run your own test ircd first
03:01:27 <Hunner> which is a lot harder to set up...
03:01:28 <Jonno_FTW> i'm not running it on freenode
03:01:29 <tensorpudding> on a local machine
03:04:22 <Jonno_FTW> on rizon
03:05:04 <Jonno_FTW> it won't identify though and I don't know how to make it wait till it has joined the server to identify
03:06:11 <Jonno_FTW> can I make it wait say, 20 seconds before it does the next action in a do block?
03:06:35 <mauke> yes, but that's very hackish
03:06:57 <mauke> you should wait until the connection is finished before sending privmsg/join commands
03:07:22 <Jonno_FTW> yes, but how can i detect them?
03:08:21 <mauke> my bot waits until it's seen the end of the MOTD
03:10:00 <Jonno_FTW> oh wait i think it works
03:10:11 <mauke> specifically, replies 376 and 422
03:10:25 <Jonno_FTW> mine just did ut
03:10:38 <Jonno_FTW> :NickServ!service@rizon.net NOTICE HerpBOT :Password accepted - you are now recognized.
03:11:01 <dancor> isn't it funny how http and apparently irc have magic numbers instead of semantic identifiers
03:14:25 <Stinger> hmmm how do I filter a list based on an IO action nicely?
03:15:05 <dancor> f :: (a -> IO Bool) -> [a] -> [a]?
03:15:15 <Stinger> yes
03:15:45 <Stinger> well IO [a] last
03:15:49 <dancor> oh right
03:16:10 <Hunner> okay, I'm having to do stupid things like "concatRows x = return $ concat x" all over the place... how can I force liftM to lift to a monad that I choose instead of it guessing?
03:17:19 <Stinger> oh hey filterM
03:17:50 <dancor> ah.
03:18:01 <dancor> @hoogle (a -> IO Bool) -> [a] -> [a]
03:18:01 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
03:18:02 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
03:18:02 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
03:18:02 <Hunner> ie, "liftM concat" is often wrong, but if I say "concatM x = return $ concat x" it works... and why is the 'x' required, too?
03:18:26 <dancor> @src filterM
03:18:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:18:43 <dancor> they just write it out http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Control-Monad.html#filterM
03:18:52 <Stinger> monomorphism restriction probably, wheee
03:19:12 <fasta> Do the different Trac systems have the same user-informations on haskell.org?
03:19:22 <fasta> user-information*
03:19:58 <fasta> Hunner, there is nothing wrong with liftM concat
03:20:27 <dancor> :t return . concat
03:20:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[a]] -> m [a]
03:20:28 <tensorpudding> Hunner: liftM concat is different than return . concat
03:20:35 <dancor> :t liftM concat
03:20:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
03:20:49 <Hunner> fasta: except it tries to lift it to [] instead of IO... but making a concatM function works fine...
03:21:06 <fasta> Hunner, you are confused.
03:21:09 <Hunner> I am
03:22:01 <fasta> Hunner, liftM concat foo, simply takes the result from the foo computation and applies concat to it and then packages it up in a monadic value.
03:22:51 <mreh> @src on
03:22:51 <lambdabot> (*) `on` f = \x y -> f x * f y
03:23:19 <mreh> bugger, that's quite inefficient come to think of it
03:23:51 <Stinger> compared to what?
03:23:55 <fasta> mreh, in principle you cannot say anything about constant factors.
03:24:01 <mreh> > ap (,) (+1) $ [1..10]
03:24:01 <lambdabot>   No instance for (GHC.Num.Num [t])
03:24:02 <lambdabot>    arising from the literal `1' at <inter...
03:24:12 <fasta> mreh, (just by looking at the source code)
03:24:21 <mreh> > map (ap (,) (+1)) $ [1..10]
03:24:22 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
03:24:34 <mreh> Stinger: doing that, then comparing
03:24:35 <fasta> The only thing which matters is how the final machine code looks like.
03:24:46 <mreh> say (+1) was a very complex computation
03:25:00 <medf> lol
03:25:08 <mreh> fasta: GHC wouldn't be intelligent enough to optimise this one I don't think
03:25:46 <Stinger> hmm it could
03:26:02 <mreh> well, it might do the graph reduction
03:26:19 <fasta> mreh, comparing by constructing isomorphic data structures is silly to begin with, but in theory a compiler can do everything I can.
03:26:38 <mreh> fasta: what's isomorphic to what?
03:27:20 <fasta> mreh, I had the impression you had the intention of building tuples in the f function.
03:27:22 <mreh> I should explain, I'm sorting a list based on some other function, hence the `on`
03:27:51 <fasta> mreh, well, if this function does nothing useless, there is no problem, right?
03:28:42 <mreh> fst . sortBy (flip comparing `on` snd) . ap (,) complexComputation $ [1..100]
03:29:06 <mreh> fasta: I have trouble understanding you at the best of times
03:29:31 <fasta> mreh, ok, in that case you just have to use let to make sure there are no inefficiencies in GHC.
03:29:47 <mreh> fst . sortBy (flip comparing `on` complexComputation) $ [1..100]
03:29:53 <mreh> these are the two possible implementations
03:29:55 <mreh> oops
03:30:04 <fasta> mreh, but that is just because GHC works in a particular way.
03:30:04 <mreh> sortBy (flip comparing `on` complexComputation) $ [1..100]
03:30:14 <mreh> and: fst . sortBy (flip comparing `on` snd) . ap (,) complexComputation $ [1..100]
03:30:37 <mreh> are there any differences is runtime complexity?
03:30:44 <mreh> s/is/in
03:31:09 <fasta> mreh, imho, ap counts as obfuscation.
03:31:15 <Stinger> it's always gonna be O(nlogn) :D
03:31:33 <mauke> Stinger: stop grinning
03:31:39 <mreh> @src sortBy
03:31:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
03:31:46 <Stinger> :(
03:32:07 <mreh> does anyone with expert knowledge know how sortBy works?
03:32:09 <mauke> mreh: I'd say yes
03:32:35 <BONUS> btw, it's either (flip compare `on` snd) or (flip $ comparing snd)
03:32:40 <mreh> mauke: what is your analysis?
03:32:47 <mauke> gut feeling
03:33:01 <Stinger> where do you live Jonno_FTW?
03:33:07 <mreh> mauke: I think the first one is least efficient
03:33:12 <mreh> but less ofuscated
03:33:17 <mauke> the second version calls complexComputation O(n) times, the first version potentially a lot more
03:33:27 <mreh> mauke: that is my intuition
03:33:40 <mreh> dang... the first one was so much prettier
03:33:42 <mauke> log(n!) or something like that
03:33:47 <fasta> mreh, are you actually writing something useful?
03:33:53 <Stinger> mreh what are you actually sorting on?
03:33:55 <fasta> mreh, i.e., where it matters?
03:34:09 <fasta> mreh, or is this a theoretical discussion?
03:34:11 <mauke> it depends on whether the memory overhead is worth the caching
03:34:28 <mreh> fasta: yes, it's a GA, the complexComputation is a fitness-function, notoriously the most time-intensive part of a GA
03:35:00 <mreh> mauke: yes, the complexComputation function is O(n!), I would say so
03:35:23 <mreh> fasta: either way, it's still an interesting discussion
03:35:23 <mauke> no, I think the number of comparisons is log(n!)
03:35:43 <mauke> so with a bit of luck you get log(n!!) time just for comparing values
03:35:59 <mauke> er, wait
03:36:06 <Stinger> what?
03:36:07 <mauke> log(n!) * n!
03:36:26 <mreh> O(n!) then
03:36:46 <mauke> I'm not sure those are the same n
03:37:11 <mreh> I think this is why CS grads only talk in big O notation :)
03:38:14 <int-e> O(log(n!)*n!) is not O(n!). log(n!) grows faster than any constant factor. for that matter, O((n+1)!) and O(n!) are different.
03:38:44 <mreh> we can say n^n is asymptotic to n!, therefore log(n!) has an upperbound in n log(n)
03:39:33 <mreh> int-e: if you read what I said, I never implied that
03:39:34 <int-e> (of course with growth rates that large, we don't care about big Ohs anymore, only about the behaviour for some small ns where the computation is practical)
03:40:13 <int-e> mreh: Maybe I got the context wrong.
03:40:21 <fasta> Why does Trac have to be so slow?
03:40:29 <int-e> mreh: what was "O(n!) then" refering to?
03:40:44 <fasta> 10 seconds to load the first page on a 10Mbit network.
03:40:44 <mreh> in my definition of the sort there is a function complexComputatin
03:41:04 <mreh> the two definitions infact
03:41:12 <fasta> It seems that Google is the only organization in the world who can make stuff which actually works.
03:41:15 <mreh> that runs in O(n!)
03:41:54 * hackagebot upload: hmpfr 0.3.1 - Haskell binding to MPFR library (AlesBizjak)
03:42:02 <mreh> but assume it runs in O(1)
03:42:08 <int-e> mreh: I took it as a reply to  <mauke> log(n!) * n!. Never mind then.
03:42:22 <mreh> oh shit, mauke was right, we're talking about different n's
03:42:24 <mreh> sorry
03:42:39 <mreh> so it is only constant time :D
03:42:46 <mreh> sorry sorry sorry
03:43:49 <mreh> mauke, int-e, cheers
03:49:16 <pastorn> amagad
03:49:31 <pastorn> i'll say it again: the maybe monad should be considered cheating
03:49:44 * pastorn feels like he should be disqualified
03:53:02 <tensorpudding> Maybe is the most interesting trivial monad
03:53:31 <Hunner> list isn't trivial?
03:53:39 <Jonno_FTW> how can i import another .hs file?
03:54:00 <tensorpudding> it's less trivial
03:54:04 <Jonno_FTW> i have a filed called xor.hs with "module Xor where" at the top
03:54:14 <tensorpudding> @src concatMap
03:54:14 <lambdabot> concatMap f = foldr ((++) . f) []
03:54:47 <pastorn> Jonno_FTW: if you have "Lol.hs" put "module Lol where" at the top of that file, then in the file that is importing Lol just wirte "import Lol" (provided they're in the same directory)
03:55:01 <Jonno_FTW> they are and it didn't work
03:55:24 <Jonno_FTW> C:\Haskell\ircbot.hs:9:7:
03:55:26 <pastorn> Jonno_FTW: paste both your file headers
03:55:26 <Jonno_FTW>     Could not find module `Xor':
03:55:30 <pastorn> @hpaste
03:55:30 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:55:47 <pastorn> (file headers = module names + all imports)
03:56:27 <mreh> list is hard
03:57:06 <pastorn> tensorpudding: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22991#a22991
03:57:13 <pastorn> check out my sweet cheating
04:05:08 <Jonno_FTW> here's what it's in the headers
04:05:10 <Jonno_FTW> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8116#a8116
04:07:56 <Stinger> no partitionM :(
04:08:56 <pastorn> Jonno_FTW: you're worknig on a bot? are you doing the tutorial on the haskell wiki?
04:09:20 <Jonno_FTW> yes
04:09:34 <Jonno_FTW> i want to be able to give it some commands
04:09:37 <pastorn> have you looked at the irc library yet?
04:09:39 <Jonno_FTW> and return things
04:09:43 <Jonno_FTW> irc library?
04:09:50 <Stinger> libraries are cheating
04:09:58 <Jonno_FTW> but this is a bigger problem i don't know about importing
04:10:04 <pastorn> Stinger: hello mr. not invented here
04:10:06 <medf> libraries are cheating. higher level languages are cheating.
04:10:14 <medf> let's all write in machine language
04:10:19 <medf> s
04:10:20 <pastorn> Stinger: go work on ZSNES or something
04:10:41 <Megant> Jonno_FTW: maybe --make would help?
04:10:51 <Stinger> M-x butterfly
04:11:35 * pastorn smacks Stinger around with a large trout
04:11:39 <Jonno_FTW> hmmmm
04:11:43 <pastorn> hehe
04:12:06 <Stinger> wow mirc?
04:12:11 <Jonno_FTW> where do i --make?
04:12:17 <pastorn> Jonno_FTW: try captializing your file names according to how you name your modules
04:12:18 <zygoloid> Jonno_FTW: ghc --make
04:12:30 <pastorn> (i.e. ircbot.hs -> IRCBot.hs
04:12:46 <pastorn> Stinger: no, but i thought it'd be funny
04:12:52 <Stinger> heh
04:13:06 <pastorn> weechat on a friends server
04:15:44 <pastorn> Jonno_FTW: i have a better codebase for mirkk-bots than the tutorial gives (according to me, at least)
04:15:56 <pastorn> i've been working on it for 2 days now
04:16:09 <Jonno_FTW> kool
04:16:17 <pastorn> though my bot doesn't really do anything yet, but i have a solid base
04:16:37 <Jonno_FTW> i have it going through a large pattern match
04:16:41 <Jonno_FTW> and acting accordingly
04:16:53 <pastorn> Jonno_FTW: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8117#a8117
04:17:08 <pastorn> it has swedish comments... deal with it!
04:18:25 <pastorn> the good stuff starts after the long comment... and no annoying printf either :)
04:18:41 <Jonno_FTW> interesting
04:19:27 <pastorn> Jonno_FTW: all the msg_* funcitons are for the Message datatype (look at the bottom) which i get (with a parser) from the library "irc" on hackage
04:20:06 <Jonno_FTW> sure it's not cheating using the IRC package?
04:20:16 <pastorn> Jonno_FTW: yes, it's not cheating
04:20:28 <pastorn> my 'parseBotCmd' is cheating, though
04:20:45 <pastorn> since it's all in the Maybe monad
04:21:02 <pastorn> "fuuuuuuuuuuuuuuusk" is swedish for "cheeeeeeeeeeeeeatiiiiiiiiiiiiiiing"
04:21:09 <Jonno_FTW> ok
04:21:20 <Jonno_FTW> ehehehe
04:21:35 <pastorn> but feel free to steal my code... just rename your bot :)
04:21:54 <pastorn> Jonno_FTW: the people in the channel at efnet are nice :)
04:22:08 <Jonno_FTW> i'm still having trouble importing though
04:22:20 <pastorn> Jonno_FTW: do what i do then! just one giant file
04:22:28 <Jonno_FTW> -__-
04:22:50 <pastorn> Jonno_FTW: i've given up separating code into smaller pieces
04:22:55 <Jonno_FTW> why?
04:23:01 <Jonno_FTW> not OCD enough?
04:23:10 <pastorn> i only do that if i'm making a library
04:23:17 <pastorn> which i never am
04:23:20 <zygoloid> just #include one .hs file into another :D
04:23:44 <zygoloid> whoa, that thought actually made me physically shudder :o
04:23:50 <pastorn> Jonno_FTW: what do you have in Xor that has to stay out of IRCBot?
04:24:04 <Jonno_FTW> lots of crap
04:24:10 <pastorn> like what?
04:24:11 <Jonno_FTW> bitwise operations
04:24:20 <pastorn> wtf are you doing?
04:24:31 <Jonno_FTW> you can ask the bot for bitwise operations
04:24:48 <Jonno_FTW> of course it will return odd text though
04:25:01 <pastorn> dude, just use Data.Bits, filter isDigit and read :)
04:25:46 <imc> hello!
04:25:55 <pastorn> imc: yo!
04:26:24 <imc> little question to you guys: i have something like ` data Node = Header String | Body String `
04:26:29 <pastorn> ok
04:26:43 <imc> then i would like to create nodes like ` Header ":blkasdlkjasd" ` or `Body "asdlkasd"`
04:27:03 <Zao> Yees?
04:27:03 <imc> and having functions like ` f :: Node -> Node -> [Node] `
04:27:24 <pastorn> f x y = [x,y] ?
04:27:28 <imc> (like a function reordering the nodes according to their types)
04:27:58 <imc> yep more like f x@Header y@Body = [x,y] \ f x@Body y@Header = [y,x]
04:28:00 <pastorn> f (Node x) y = [y,Node x]
04:28:01 <Zao> You should be able to derive Ord,Eq to be able to use sort right away.
04:28:22 <Zao> I would encode the listness in the structure itself though, if I was you, which I'm not.
04:28:28 <imc> yeah, doesn't change the problem here
04:28:35 <pastorn> Jonno_FTW: is my code useable?
04:28:44 <Zao> I don't see a problem yet :)
04:28:48 <Jonno_FTW> not really
04:28:52 <pastorn> awww
04:28:59 <pastorn> i worked so hard on it :/
04:29:02 <Jonno_FTW> i haven't totally gone all out with the monads in this
04:29:03 <imc> ghci says: Not in scope: type constructor or class `Header`
04:29:06 <Jonno_FTW> but it looks good
04:29:07 <imc> (same thing with Body)
04:29:59 <pastorn> @type sort
04:30:00 <lambdabot> forall a. (Ord a) => [a] -> [a]
04:30:03 <pastorn> imc: ^^
04:30:22 <imc> i have a more basic problem here guys
04:30:34 <imc> data X = Y String | Z String
04:30:46 <pastorn> just write 'data N = H S | N S' and not
04:30:48 <imc> shouldn't I be able to do things like ` let x = Y "foo"`
04:31:20 <imc> Y and Z *are* constructors no?
04:31:23 <pastorn> *'data N = H S | B S' and not 'B S | H S' and haved 'deriving (Ord)', then you'd get it right with sort
04:31:26 <imc> why in the hell they are "not in scope" ?
04:31:30 <Stinger> ok so whats a neat way of writing a partitionM gurus? (a->m Bool) -> [a] -> ([a],[a])?
04:31:30 <zygoloid> imc: inside a 'do' block or at a ghci prompt, yes. otherwise you'll need 'let x = Y "foo" in ...'
04:31:55 <Stinger> bah that should be  (a->m Bool) -> [a] -> m ([a],[a])?
04:31:57 <zygoloid> imc: is this in the same file where you put the 'data X = ...' ?
04:32:02 <imc> no
04:32:03 <imc> another module
04:32:19 <Stinger> or possibly (m [a],m [a])
04:32:22 <imc> should I export things?
04:32:27 <imc> ("internal" constructors)
04:32:28 <zygoloid> imc: did you export the Y and Z constructors from the first module and import them into the second?
04:32:32 <pastorn> @djin (Monad m) => (a->m Bool) -> [a] -> m ([a],[a])
04:32:33 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
04:32:34 <imc> here we are :D
04:32:39 <pastorn> @djinn (Monad m) => (a->m Bool) -> [a] -> m ([a],[a])
04:32:40 <lambdabot> Error: Undefined type []
04:32:45 <pastorn> wtf?
04:32:46 <imc> it was some weeks ago I read that part of the book
04:32:48 <imc> thanks
04:33:06 <benjamin_scarlet> Anyone out there who could help me with a Data.TypeLevel question?
04:33:35 <imc> basically i want to export everything...
04:33:42 <benmachine> pastorn: djinn can only do non-recursive types, and doesn't get along with type classes
04:33:52 <pastorn> awww, chucks
04:34:37 <mauke> @djinn (Eq a) => a -> a -> Bool
04:34:37 <lambdabot> f = (==)
04:35:11 <benmachine> @djinn (Functor f) => f (a -> b) -> a -> f b
04:35:11 <lambdabot> Error: Class not found: Functor
04:35:13 <benmachine> oh
04:35:15 <benmachine> never mind
04:35:28 * benmachine can't remember what he was told about typeclasses
04:35:28 <imc> :/
04:36:41 <imc> uhm
04:37:25 <imc> data A = A B C  \\  data X = B | C
04:37:29 <imc> in the same very module
04:37:39 <imc> A can't see B and C
04:37:44 <zygoloid> @djinn (forall a b. (a -> b) -> f a -> f b) -> f (a -> b) -> a -> f b
04:37:44 <lambdabot> -- f cannot be realized.
04:37:59 <zygoloid> djinn doesn't do rank-2 types i guess?
04:38:03 <Stinger> @src partition
04:38:04 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:38:04 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:38:04 <lambdabot>                               | otherwise = (ts, x:fs)
04:38:07 <benmachine> imc: data A = A B C -- B and C are types
04:38:15 <benmachine> data X = B | C -- B and C are constructors
04:38:22 <imc> yep
04:38:30 <benmachine> so they're not the same B and C
04:38:37 <imc> arg
04:39:02 <imc> how can i "simulate" subclassing in haskell ?
04:39:05 <benmachine> it's like the difference between Maybe and Just
04:39:17 <benmachine> umm
04:39:25 <benmachine> the first obvious question is why would you want to
04:39:27 <zygoloid> imc: what do you mean by subclassing in this context?
04:39:48 <imc> using B or C in the same context (calling it X)
04:40:01 <kpreid> HAH. According to Google Alerts, my "an exercise in Haskell golf" article (which, btw, I corrected so the result actually fits in an @let) was picked up by "golf-swing-videos.info".
04:40:04 <imc> two different constructor but same "super" type
04:40:34 <pastorn> @type forever
04:40:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
04:40:35 <imc> sorry.. i come from scala (OO functional language)
04:40:36 <Stinger> yes info domains, a benefit to all humanity
04:40:41 <benmachine> imc: what would you do with something when you didn't know what it was?
04:40:42 <zygoloid> imc: if you want a 'closed' union, type X = Either B C
04:40:45 <pastorn> can someone please tell me how that is possible?
04:40:59 <imc> zygoloid: so obvious :/ (me ashamed)
04:41:04 <mauke> @src forever
04:41:05 <lambdabot> Source not found. My pet ferret can type better than you!
04:41:12 <mauke> pastorn: what's the problem?
04:41:13 <pastorn> i do an (m a) infinetly many times and i will have a (m b)
04:41:25 <Stinger> magic
04:41:25 <zygoloid> pastorn: the type tells you that it never actually produces a 'b'
04:41:28 <pastorn> unsafeCoerce, anyone?
04:41:39 <benmachine> not unsafeCoerce, more like undefined
04:41:43 <tavelram> @src Monad.Control.forever
04:41:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:41:51 <pastorn> @src forever
04:41:51 <lambdabot> Source not found. It can only be attributed to human error.
04:41:58 <benmachine> forever x = x >> forever x
04:42:07 <pastorn> yeah
04:42:16 <pastorn> benmachine: no undefined there
04:42:26 <zygoloid> pastorn: no, but there is a bottom
04:42:33 <pastorn> a bottom?
04:42:38 <benmachine> non-termination
04:42:47 <mauke> pastorn: it says: if forever returns, it will give you an 'm b'
04:43:00 <mauke> this is impossible because b is arbitrary
04:43:02 <benmachine> (except that forever *can* terminate sometimes, but only in boring ways :P)
04:43:05 <mauke> so forever never returns
04:43:11 <benmachine> > forever Nothing
04:43:12 <lambdabot>   Nothing
04:43:21 <pastorn> benmachine: that's not what i get
04:43:25 <mauke> well, yes
04:43:32 <pastorn>     Warning: Defaulting the following constraint(s) to type `()'
04:43:34 <pastorn>              `Show b' arising from a use of `print' at <interactive>:1:0-14
04:43:36 <pastorn>     In a stmt of a 'do' expression: print it
04:43:38 <mauke> since m is unspecified as well, there may be a generic m b
04:43:41 <pastorn> (from 'forever Nothing')
04:44:04 <mauke> just a warning from ghci because the type is ambiguous
04:44:04 <zygoloid> pastorn: suppose your monad is (->) r. then forever x = x >> forever x => forever x a = const (forever x a) (x a) = forever x a
04:44:23 <mauke> try forever Nothing :: Maybe String
04:44:42 <theorbtwo> > forever Nothing :: Maybe Sring
04:44:43 <lambdabot>   Not in scope: type constructor or class `Sring'
04:44:46 <benmachine> > forever Nothing :: Maybe ()
04:44:47 <lambdabot>   Nothing
04:44:50 <pastorn> mauke: that worked
04:45:05 <benmachine> pastorn: in the previous case, didn't it say Nothing anyway after printing the warning?
04:45:12 <pastorn> zygoloid: that doesn't really tell my where the magic 'b' comes from
04:45:19 <zygoloid> pastorn: there /is/ no b
04:45:34 <pastorn> benmachine: heh, you're right, it did
04:45:36 <zygoloid> pastorn: a non-bottom value of type b cannot be created by this function
04:45:50 <pastorn> yes, i understand that...
04:45:51 <mauke> pastorn: m b isn't (necessarily) a container of b's
04:45:55 <benmachine> Nothing doesn't contain anything of type b
04:46:10 <zygoloid> pastorn: which tells you that either 1: the resulting 'm b' contains no 'b', or 2: the resulting 'm b' contains 'b's which are _|_, or 3: the resulting 'm b' is itself _|_
04:46:11 <pastorn> true... but it's still weird that it's not a
04:46:35 <mauke> why would it be a?
04:46:38 <benmachine> :t let x = x in x
04:46:39 <lambdabot> forall t. t
04:46:43 <benmachine> ^ magic t!
04:46:49 <pastorn> since the 'last' call will be :: m a, so then the end result should be m a
04:46:54 <mauke> that's like parsec assuming that a parser that returns Char will consume exactly one input token
04:46:57 <benmachine> but there is no last call
04:46:57 <zygoloid> pastorn: no it won't. there's no last call.
04:47:07 <benmachine> if you look at the definition for forever
04:47:19 <mauke> the last call is (>>)
04:47:23 <benmachine> you see that by the type of >>, it's basically the type of forever
04:47:31 <pastorn> zygoloid: i know, but recursing over p, won't that case the type of forever p to be that of p?
04:47:41 <mauke> pastorn: no, why?
04:47:45 <zygoloid> pastorn: 'forever x = x >> forever x'. suppose we assume that 'forever x' :: m Banana. then x >> forever x :: m Banana, and the typechecker is happy
04:47:49 <mauke> (>>) ignores the first return value
04:48:00 <mauke> :t (>>)
04:48:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
04:48:05 <pastorn> mauke: you're right :)
04:48:16 <pastorn> then i get it :)
04:48:28 <benmachine> pastorn: basically the trick is that forever's type signature tells you it produces a type m b when it can't possibly produce anything of type b
04:48:33 * pastorn jumps with joy
04:48:38 * pastorn jumps into bed
04:48:53 <benmachine> thus either it doesn't produce anything or it produces an m b with no bs in it
04:48:53 <pastorn> benmachine: okay :)
04:49:04 <benmachine> both of those are consistent
04:49:05 <benmachine> but
04:49:11 <benmachine> if you understand it perhaps I should stop talking
04:49:16 <zygoloid> or it produces an m b with bs which are _|_
04:49:17 <pastorn> yes
04:49:20 <pastorn> and i should sleep
04:50:05 <theorbtwo> Er, does forever ever produce *anything*?  It sounds like in any case where it terminates, the entire program has terminated.
04:50:50 <zygoloid> theorbtwo: forever Nothing terminates
04:51:00 <pastorn> theorbtwo: if the definition of >> has a possibility of not running the "next" function and that is the path it takes then it will terminate
04:51:07 <zygoloid> theorbtwo: and 'forever (putStrLn "hello")' is useful
04:51:30 <theorbtwo> pastorn: Ah, I think I see what you mean.
04:51:33 <pastorn> theorbtwo: mx >>= k = maybe Nothing k mx
04:51:39 <pastorn> (i think it is)
04:52:19 <pastorn> k in its turn (if Just) might call >>= again... etc. etc.
04:52:30 <pastorn> hehe
04:52:33 <pastorn> "if Just"
04:52:55 <pastorn> I MAED A FUNNY
04:52:56 <pastorn> LOL
04:52:58 <pastorn> good night
04:53:28 <theorbtwo> It's a monad with paragon points!
04:53:31 <theorbtwo> G'night, pastorn.
05:01:30 <mauke> pastorn: possibly related: http://perl.plover.com/classes/OOPSLA/samples/slide061.html
05:04:57 <Hunner> There's no way to decompile back to haskell code from the .o and .hi file is there?
05:05:05 * Hunner just had a git rebase go wrong >_<
05:08:13 <phrixos> rebase --abort?
05:09:07 <Hunner> nope. I already commited
05:09:40 <Hunner> luckily I made a copy about an hour ago to a different box, so I lost an hour of work instead of... 18
05:10:24 <BONUS> man, git is weird
05:10:46 <mauke> seems pretty simple so far
05:11:00 <mauke> (all I've done is git init, git add, git commit, git diff)
05:11:26 <Hunner> yeah, I forget that git messes with files and not just the repo
05:11:30 <Hunner> like git rm and git rebase
05:11:33 <eevar2> hunner: just do git reflog + git co <digest>
05:11:38 <Draconx|Laptop> Hunner, once you've committed something, those commits will still be in the reflog.
05:11:42 <BONUS> i like hg better because you always have the history and can't change it
05:12:17 <phrixos> yeah, you can still get it back from the reflog if you have a play
05:12:21 <phrixos> even if you have commited the rebase
05:12:51 <Draconx|Laptop> Hunner, however, if you never committed a file and you delete it, it's probably gone.
05:12:59 <mauke> is that ref-log or re-flog?
05:13:07 <theorbtwo> You can't change history in git either.  You can, however, create an alternate timeline.
05:13:43 <Mat_P> I have been using git for awhile..  Never used reflog..  interesting
05:13:48 <theorbtwo> It is lazy SF-writer's time travel.
05:15:03 <Hunner> eevar2: <3
05:33:01 <quicksilver> theorbtwo: can you get back to the old time line if you've changed your mind?
05:33:21 <theorbtwo> quicksilver: Yes, though I don't really know how.
05:33:22 <maurer_> Anyone know how to make cabal use a SOCKS proxy?
05:35:01 <phrixos> you use git reflog to find the old ref you want, and then just branch that again
05:35:31 <Hunner> it's not pushed as part of the history though
05:35:45 <Hunner> so it's local to whatever repo you did the rebasing/whatever in
05:35:49 <phrixos> no, it wouldn't be pushed
05:36:00 <phrixos> well, it depends
05:36:18 <phrixos> if you pushed the repo when that head was active, it would be there
05:36:30 <phrixos> iyswim
05:40:06 <Axman6> blackdog!
05:40:17 <dancor> is it just me or is there no real reason to ever use pureMD5 (instead of e.g. nano-md5)
05:41:02 <fasta> dancor, is nano-md5 threadsafe?
05:42:03 <dancor> idk.. dons/probably-many-others would know
05:42:53 <Axman6> is nano-md5 an FFI binding?
05:43:19 <dancor> Axman6: ya
05:43:54 <Axman6> then possibly not, though MD5 is a pure operation, so you'd hope it would be implemented in a threadsafe, pure manner
05:44:10 <mreh> Couldn't match expected type `g'
05:44:11 <mreh>            against inferred type `System.Random.StdGen'
05:44:11 <mreh>       `g' is a rigid type variable bound by
05:44:11 <mreh>           the type signature for `gaLoop' at GA.hs:49:45
05:44:18 <FliPPeh_> My Gtk2hs files are over 14 MB big :(
05:44:20 <mreh> do I need to use an existential qualifier?
05:44:36 <fasta> Is there some evil function f which turns [undefined/error/assertion generated bottoms] into []?
05:44:59 <quicksilver> spoon
05:45:01 <fasta> FliPPeh_, nobody cares about size if you software is any good.
05:45:04 <ben> fasta: You mean undefineds of type [a]?
05:45:18 <quicksilver> of couse it's not a function but you don't need me lecturing about that :)
05:45:23 <FliPPeh_> > let evil [a] = [] in evil [error, ioError]
05:45:24 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:45:25 <lambdabot>         against inferred ty...
05:45:35 <FliPPeh_> > let evil [a] = [] in evil [error "Boo"]
05:45:36 <lambdabot>   []
05:45:39 <fasta> ben: no, e.g. f [1::Int, undefined] => [1]
05:46:01 <fasta> quicksilver, right, so, spoon is an actual function. I will check Hayoo.
05:46:05 <FliPPeh_> fasta: But my software is not good :(
05:46:28 <quicksilver> fasta: http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/Control-Spoon.html
05:46:36 <quicksilver> fasta: you probably want catMaybes . map spoon
05:46:43 <quicksilver> fasta: if I understood you correctly.
05:47:05 <quicksilver> it goes without saying that this is evil beyond our mortal ken
05:47:18 <FliPPeh_> Wouldn't a "f [a] = []" work aswell?
05:47:35 <fasta> quicksilver, basically the problem I am solving is given an algorithm which does some steps correctly and crashes with a minimum error, I want to visualize the partial computation.
05:48:04 <fasta> quicksilver, if I replace all the calls to error etc, by the error monad it could be done completely "pure", but this is much easier.
05:48:10 <quicksilver> FliPPeh_: that doesn't preserve the non-error parts
05:48:17 <quicksilver> FliPPeh_: (which fasta didn't say but I'm assuming he wants)
05:48:33 <fasta> quicksilver, at least that was the idea.
05:48:36 <FliPPeh_> Aha!
05:49:16 <FliPPeh_> Can a list be sorted by typeclass?
05:50:05 <FliPPeh_> filter ((\x -> x) :: Num a => a -> a) [] ;X
05:52:28 <copumpkin> FliPPeh_: nope, not sure how that would work
05:53:19 <quicksilver> well if you got it to work, it woudl be statically
05:53:30 <quicksilver> it would just make a version of map which was a restricted id
05:53:35 <quicksilver> a bit like saying:
05:53:40 <quicksilver> map (id :: Int -> Int)
05:53:48 <quicksilver> which makes a version of id which only works on [Int]
05:54:09 <dancor> @type id :: [Int] -> [Int]
05:54:10 <lambdabot> [Int] -> [Int]
05:54:26 <quicksilver> dancor: yeah, but mine is slower!
05:54:37 <quicksilver> at least it is if it doesn't fuse statically.
05:55:20 <dancor> right, there are lots of tradeoffs to consider when selecting the implementation ;)
05:55:58 <dancor> yours is also longer which many take to mean more readable
05:56:21 <fasta> Can NFData already be derived?
05:56:53 <int-e> > head &&& last $ map id $ repeat ()
05:56:55 <copumpkin> with Data.Derive
05:56:56 <lambdabot>   mueval-core: Time limit exceeded
05:57:13 <dancor> cabal-install is killing me complaining about QuickCheck
05:57:25 <int-e> killing?
05:57:48 <dancor> i might implement --just-effing-do-it-i-know-better-than-you-do
05:58:40 <dancor> --allow-multiple-versions-of-same-package-in-build='QuickCheck'
05:59:34 <FliPPeh_> cabal-install ist way to bitchy about QuickCheck
05:59:54 <ehamberg> is it possible to do something à la this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=22993 ? i.e. use the state monad and “return” an infinite list.
06:00:11 <dancor> haskell tools seem to have a tendency to be too correct
06:00:23 <benmachine> ehamberg: yeah, should be
06:00:34 <fasta> ehamberg, no.
06:00:36 <benmachine> ehamberg: hmm no
06:00:52 <fasta> ehamberg, if you want that, you have to use a writer monad.
06:00:53 <benmachine> ehamberg: because the State could later in the chain of computations be set to something else
06:01:05 <mreh> how can I coerce a Num into a Fractional?
06:01:05 <ehamberg> right. that makes sense.
06:01:26 <benmachine> but yeah, the Writer monad will allow you to produce output from a computation before it terminates
06:01:44 <benmachine> and you can use RWS or WriterT State or StateT Writer if you want both state and premature output
06:01:45 <Axman6> :t 1 :: Fractional a => a
06:01:46 <lambdabot> forall a. (Fractional a) => a
06:01:49 <Axman6> mreh:
06:02:05 <mreh> Axman6: I mean this
06:02:15 <mreh> > (1 :: Num) / 2.0
06:02:16 <lambdabot>   Class `GHC.Num.Num' used as a type
06:02:25 <Axman6> Num isn't a type
06:02:27 <benmachine> lambdabot has pointed out your error
06:02:33 <benmachine> most astutely
06:02:40 <dancor> > realToFrac (1 :: Int) / 2.0
06:02:41 <lambdabot>   0.5
06:02:48 <mreh> dancor: thanks
06:02:56 <mreh> dancor understands me
06:02:59 <mreh> :P
06:03:04 <dancor> > fromIntegral (1 :: Int) / 2.0
06:03:05 <lambdabot>   0.5
06:03:19 <benmachine> mreh: you can't do it in general for any Num though
06:03:26 <mreh> Real is probably a better class to use instead of Num
06:03:26 <Axman6> ask better questions :P
06:03:31 <benmachine> because Fractional is a more restrictive typeclass than Num
06:03:45 <ehamberg> damn, i had this simple EA framework which let me return an infinite list of generations (so that I could take[While] as many as I wanted), but with the state monad i will have to decide beforehand how many generations to run for. oh, well… ☺
06:03:50 <dancor> :t realToFrac
06:03:51 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
06:03:53 <mreh> they're conceptually different things
06:03:54 <dancor> :t fromIntegral
06:03:55 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:04:23 <SamB_XP_> ehamberg: why do you need to do that ?
06:04:24 <benmachine> ehamberg: what's wrong with the Writer suggestion?
06:05:04 <ehamberg> hmm, but i *would* like to use the previous statee, oh maybe that will still work. hmm…
06:05:09 <ehamberg> “state”
06:05:16 <dancor> Integral implies Real.  Fractional implies Num.  it's a crazy world out there.
06:05:57 <mreh> dancor: ... that's crazy
06:06:05 <dancor> mm
06:06:17 <SamB_XP_> what's crazier is that abs and signum are in Num ;-P
06:06:30 <dancor> also isn't Real completely misnamed or something?
06:06:30 <benmachine> wait, Integral implies Real sounds sensible to me
06:06:31 <benmachine> ish
06:06:36 <mreh> I just need a class that represents a quantity
06:06:37 <benmachine> yes a little
06:06:39 <dancor> benmachine: i mean it's sensible
06:06:43 <benmachine> > toRational pi -- :P
06:06:44 <lambdabot>   884279719003555 % 281474976710656
06:06:51 <benmachine> dancor: oic
06:06:51 <dancor> lol
06:07:41 <dancor> "pi" := floating point pi approximation
06:08:07 <dancor> > toRational 3.141592653589793238
06:08:08 <lambdabot>   884279719003555 % 281474976710656
06:08:10 <dancor> nailed it
06:08:37 <RayNbow> > toRational (pi :: CReal)
06:08:38 <lambdabot>   * Exception: CReal.toRational
06:08:40 <benmachine> yes but I still find it funny
06:08:43 <SamB_XP_> > toRational cherryCrumb
06:08:44 <lambdabot>   Not in scope: `cherryCrumb'
06:08:52 * SamB_XP_ curses lambdabot
06:09:08 <mreh> dancor: you've just cast an Integer to the class Num, and used it in a Fractional context
06:09:12 <mreh> I am confused
06:09:36 <mreh> :t (/)
06:09:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:09:52 <mreh> :t fromIntegral
06:09:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:09:56 <dancor> Int implies Integral, Fractional, Real, and Num.
06:10:06 <mreh> > fromIntegeral (1::Int) / 2.0
06:10:07 <lambdabot>   Not in scope: `fromIntegeral'
06:10:07 <SamB_XP_> dancor: what what ?
06:10:11 <dancor> err
06:10:11 <mreh> > fromIntegral (1::Int) / 2.0
06:10:12 <lambdabot>   0.5
06:10:47 <benmachine> so Int is being cast to Num, Num is being specialised to Double, then Double is being divided by 2
06:10:59 <dancor> i guess it only makes sense to use my "implies" line when comparing typeclasses
06:11:05 <dancor> not types to typeclasses
06:11:29 <benmachine> the trick is that if you have an Integral you can get *any* Num
06:11:35 <mreh> I need to coerce a quantity in Num, to a fractional
06:11:38 <benmachine> but if you have a Num you can't necessarily do that
06:11:45 <mreh> right
06:11:52 <benmachine> mreh: what if it's a polynomial?
06:12:07 <benmachine> division doesn't necessarily make sense on them
06:12:17 <ski> > fromIntegral (x + 2)
06:12:18 <lambdabot>   * Exception: not a number
06:12:18 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
06:12:23 <mreh> benmachine: it's a number, it's not a function
06:12:25 <ski> @messages
06:12:25 <lambdabot> dolio said 16h 34s ago: That (your example) isn't really what incoherent instances do. It's just the weirdness of overlapping instances.
06:12:38 <benmachine> mreh: but the point is you could in principle have a Num instance for polynomials
06:12:51 <benmachine> if you carefully overlook abs and signum
06:13:11 <ehamberg> SamB_XP_, benmachine: you are of course right. thanks! :)
06:13:22 <benmachine> so you have a thing and all you know about it is that it's a Num - it might be a polynomial
06:13:25 <benmachine> then what?
06:14:20 <mreh> what typeclasses can I coerce into a fractional?
06:14:32 <mreh> or set of typeclasses
06:14:45 <mreh> Real?
06:15:22 <dancor> well it depends on what instances are defined.  i guess you are asking "under the instances in the base package" or something like that
06:15:39 <ski> @type fromIntegral
06:15:40 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:15:49 <mreh> dancor: yeah, I'm trying to write a generic GA library for my own purposes, part of my Evo Comp course
06:15:53 <benmachine> @type toRational
06:15:54 <lambdabot> forall a. (Real a) => a -> Rational
06:15:59 <mreh> who knows what values the fitness function could return
06:16:02 <benmachine> anything Real can be made a Rational
06:16:18 <ski> since any `b' which is in `Fractional' is also in `Num', you can (at least) convert every `a' in `Integral' to any `Fractional' `b'
06:16:41 <benmachine> but Integrals are all Real anyway
06:16:55 <benmachine> so you might as well realToFrac them in the first place
06:17:01 <ski> @type fromIntegral :: (Integral a, Fractional b) => a -> b
06:17:02 <lambdabot> forall a b. (Fractional b, Integral a) => a -> b
06:17:03 <dancor> i wonder if any haskell gurus could come up with a cool algorithmic way of answering a question like that for the "base" package
06:17:45 <mreh> it shouldn't be required
06:18:08 <mreh> that's an exercise in fetishising type classes
06:18:48 <mreh> there's a hierachy of numbers, you should be able to coerce them up and down the hierachy
06:18:49 <dancor> @instances Fractional
06:18:50 <lambdabot> Double, Float
06:19:08 <mreh> you loose information when you go down, you gain finer granularity when you go up
06:19:14 <dancor> @instances Num
06:19:15 <lambdabot> Double, Float, Int, Integer
06:19:22 <dancor> @instances Real
06:19:22 <lambdabot> Double, Float, Int, Integer
06:19:22 <ddarius> dancor: I like to view type classes as sets.  Class declarations declare a set and instance declarations make inductive rules declaring the elements of the sets, the most basic rule being an axiom that a type T is in a class C.
06:19:59 <dancor> @instances Integral
06:20:00 <lambdabot> Int, Integer
06:20:04 <benmachine> I don't quite think of them as inductive rules since you can't really do "if a is in Ord, it is also in Eq"
06:20:08 <benmachine> well
06:20:25 <benmachine> you can do, "if I've put a in Ord, I must already have put it in Eq"
06:20:35 <benmachine> but not, "if I've put a in Ord, put it in Eq for me please"
06:22:15 <dancor> Real has toRational which says "to full precision".. so how is Real different from Rational?
06:22:27 <quicksilver> real is a class, rational is a type?
06:22:28 <dancor> toRational doesn't have to always terminate or something?
06:22:44 <ddarius> benmachine: I only brought up rules with regard to instance declarations, not class declarations.
06:22:56 <quicksilver> Real is roughly those types which admit rational representations
06:23:03 <dancor> quicksilver: heh ya ok.  but Real should be called like RationalClass then?
06:23:06 <quicksilver> i.e. subsets of the rationals
06:23:06 <benmachine> ddarius: yeah but I mean, you can't declare an instance for Eq that applies for all Ord
06:23:10 <quicksilver> dancor: yes, it should
06:23:18 <dancor> Rationalable
06:23:25 <quicksilver> dancor: the choice is name is to indicate that it excludes complex numbers
06:23:33 <dancor> that's crazy
06:23:45 <quicksilver> real (as opposed to complex) rather than any real (as opposed to strictly rational)
06:23:55 <quicksilver> it's not *crazy* but it might be ill-advised in retrospect
06:24:01 <dancor> that naming choice seems to be the weakest link
06:24:03 <quicksilver> retrospect makes everything so clear.
06:24:04 <dancor> in all of this
06:24:19 <dancor> it's not rational!
06:24:22 <benmachine> irrational numbers don't tend to show up much in computing anyway
06:24:27 <quicksilver> I think 'Floating' might be worse
06:24:30 <quicksilver> as name choices go
06:24:43 <benmachine> yeah Floating means "we ran out of names"
06:24:53 <quicksilver> since really 'Floating' means 'supporting the common transcendental functions'
06:24:57 <quicksilver> (sin/cos/etc)
06:25:04 <SamB_XP_> @src Floating
06:25:04 <lambdabot> class  (Fractional a) => Floating a  where
06:25:04 <lambdabot>     pi                                                      :: a
06:25:04 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
06:25:04 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
06:25:04 <lambdabot>     (**), logBase                                           :: a -> a -> a
06:25:10 <ddarius> benmachine: The "proof" procedure limits what rules are allowed, but they are still (arguably) rules.  Also, with undecidable instances, you can write: instance Eq a => Ord a where ...
06:25:13 <dancor> Triggable
06:25:28 <SamB_XP_> @src RealFloat
06:25:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:25:32 <benmachine> ddarius: you can write it anyway, but you preclude the possibility of non-Ord Eqs
06:25:34 <ddarius> er vice versa, but actually that doesn't matte
06:25:40 <benmachine> unless you use overlapping
06:25:41 <SamB_XP_> lambdabot: have *you*?
06:25:51 <benmachine> and then you get in a mess
06:26:02 <dancor> it's ironic that haskell gave _math_ such a thoughtless treatment like that
06:26:13 <benmachine> exponentiable
06:26:23 <ddarius> dancor: Computer numbers aren't very nice mathematical structures.
06:26:32 <benmachine> RealFloat is a weird name
06:26:45 <benmachine> it seems to be about machine representations
06:26:50 <SamB_XP_> indeed
06:26:59 <ddarius> The numeric hierarchy was given some thought and I believe it was explicitly decided not to try to tightly model the usual mathematical hierarchy.
06:26:59 <benmachine> (one could question whether that should even *be* in the base library)
06:27:32 <SamB_XP_> well, you can't really define it anywhere else ...
06:27:47 <ddarius> I also believe that the numeric hierarchy was in part inspired by the numeric hierarchy in Lisps.
06:28:08 <dancor> i guess the heirarchy isn't as bad as the namings
06:28:17 <benmachine> SamB_XP_: well hmm, maybe I mean the Prelude
06:28:28 <SamB_XP_> what I dun get is why * etc. in lisp don't use CLOS
06:28:32 <SamB_XP_> benmachine: 'kay
06:28:32 <benmachine> it could easily be shuffled to a Data.Whatever
06:28:47 <dancor> it does come off a bit hostile for when you actually want to do like theoretical math with haskell
06:30:16 <fasta> dancor, the problem is that for even relatively simple structures people disagree on even the mathematical "interface".
06:31:03 <dancor> Num is like Ring + Signed
06:31:18 <fasta> I used Data.Derive, but I get an error, because I want to derive it for a Foo t.
06:31:34 <fasta> Is there a way to let derive automatically add the required contexts?
06:32:14 <mreh> @instances Random
06:32:14 <lambdabot> Couldn't find class `Random'. Try @instances-importing
06:32:25 <fasta> Such that e.g. for data Foo t = Foo t t $(derive makeNFData ''Foo) works?
06:32:53 <CalJohn> how i wish there was a Show typeclass that in the prelude that had a show :: (Show a) => a -> ByteString
06:33:08 <dancor> @instances-importing System.Random Random
06:33:08 <lambdabot> Bool, Char, Double, Float, Int, Integer
06:33:21 <CalJohn> mixing String and ByteString is pretty unpleasant
06:33:45 <dancor> :t mkStdGen
06:33:46 <lambdabot> Int -> StdGen
06:34:00 <edwardk> fasta: we do?
06:34:13 <quicksilver> dancor: what ever it was, it wasn't thoughtless :)
06:34:14 <dancor> so lbot does import System.Random.  not sure the deal with @instances/@instances-importing.
06:34:24 <quicksilver> dancor: I suspect it may have been overthought, and then passed through committee hell
06:34:33 <fasta> edwardk, yes, I believe so. I simply missed adding an instance myself to one of the dependent types.
06:35:03 <dancor> it's hard for me to think of "Real" as anything but underthought
06:35:08 <fasta> edwardk, it would be better if saying derive on one type would derive it for all dependent types, though.
06:35:46 <dancor> but i'll think about it more
06:38:24 <edwardk> fasta: Am I parsing you correctly as that you're advocating that saying something like data Foo = Foo Bar deriving (Baz) would also derive Baz for Bar?
06:38:44 <fasta> edwardk, yes.
06:39:26 <edwardk> fasta: personally I think that is a horrible idea. Now you have statements that only tangentially involve Bar creating instances for it, lines of code that silently change meaning based on the presence or absence of instances.
06:40:11 <edwardk> fasta: what about data Foo = Foo Bar deriving (Baz); data Quux = Quux Bar deriving (Baz) -- now you have two places that both want to derive the instance for Baz. what module exports the instance, etc?
06:40:57 <fasta> edwardk, that is simply a problem because of the global instances problem.
06:41:46 <fasta> edwardk, I can see the disadvantages, but they are only disadvantages if you cannot ask the machine "which instance if being used for that type?".
06:41:52 <fasta> is*
06:42:02 <edwardk> The global instances problem is arguably a necessary condition for type class inference.
06:42:45 <fasta> edwardk, do argue.
06:44:04 <ddarius> The problem with a mathematical numeric hierarchy is Double.
06:44:18 <edwardk> Not my argument, but if I recall the problem , it boils down to the fact that you very rapidly wind up with constraints on types that aren't even present in your interface if you start trying to allow people to manually pass in instances. Lets see if I can work through an example using a straw man system that allows for either local instances or explicit passing of a named instance
06:45:48 <ddarius> Being able to explicitly (optionally) specify instances leads to potential inconsistencies, like two Sets of Ints using different comparison functions.
06:46:23 <edwardk> The confluence of type class selection depends on the fact that no matter what way you get an instance of, say an instance for [Int], it should be the same instance. That way if you have an instance for Int lying around and you have a rule of the form instance Foo a => Foo [a], then the compiler can safely use that rule.
06:47:29 <fasta> ddarius, and that is a problem how?
06:48:00 <fasta> ddarius, if that is what the programmer wants, well, then good for him.
06:48:24 <edwardk> In ML you have modules and 'functors' playing the role we let typeclasses play. They always have to explicitly plumb them through. Haskell uses type class inference to do that plumbing, but that is only sound if you know that you can build that dictionary by any path. Consider what happens when you start specializing the type of a function.
06:48:31 <ddarius> Merging a set of reverse ordered Ints and a set of ordered Ints is probably not going to work well.
06:48:32 <edwardk> @type (+)
06:48:33 <lambdabot> forall a. (Num a) => a -> a -> a
06:49:03 <edwardk> What hapens when you constrain that type to only return Ints, you get Int -> Int -> Int
06:49:42 <edwardk> but in your world that becomes Num Int => Int -> Int -> Int -- which Haskell can currently erase the Num Int from the type. it is fully grounded and resolvable by constructing the dictionary for Num Int, which can be done inside the method itself
06:50:01 <edwardk> However, with explicit dictionary passing you can't remove that constraint from the type.
06:50:47 <edwardk> We use newtypes for dictionary selection for a reason. They are the price of all of the magical type class selection machinery
06:51:02 <fasta> edwardk, ok, so basically once you add this functionality you get an ML module system.
06:51:20 <edwardk> fasta: correct, you lose the ability to basically ever be able to use automatic instance selection.
06:52:29 <fasta> edwardk, in your example, you could also select the Num Int which is in scope.
06:52:56 <edwardk> Yes, but the issue starts to become how do you pass in a specific Num Int dictionary into a type that doesn't even involve Int.
06:54:37 <edwardk> You wind up with situations where adding type information by unification costs you the ability to manually plumb in the dictionary.
06:54:43 <edwardk> er or you wind up with
06:55:03 <benmachine> :t foldr (.) id . replicate 4 -- this function uses Num Int but that isn't reflected in the type at all
06:55:04 <lambdabot> forall b. (b -> b) -> b -> b
06:55:28 <Alpounet> edwardk, that's strongly tied to the structural typing of ML I guess
06:55:35 <Alpounet> either one relies on names or on structure
06:55:40 <zygoloid> you have some trouble maintaining the invariant of Data.Set if Ord instances aren't global
06:55:59 <edwardk> Alpounet: well, in ML, you're always explicitly plumbing the dictionaries around.
06:56:06 <zygoloid> i think you basically need the Set type to be parameterized over the Ord instance
06:56:20 <Alpounet> edwardk, yeah that's what makes me prefer Haskell
06:56:25 <Alpounet> (among other things)
06:56:39 <Alpounet> but still, that non-nominal typing is pretty exciting
06:57:04 <Alpounet> => one of the reasons I can't wait to test kata
06:57:34 <edwardk> And as ddarius/zygoloid have pointed out, right now you can use those typeclass constraints in unification. You have two different Num Int handy and two Ints built with them, which + do you use? Is either + compatible with those two Ints? Maybe Int is too weak. What about trees, one instance built a balanced tree, the other didn't...
06:58:45 <edwardk> Alpounet: yeah, in kata's case, giving up hindley milner made me set aside typeclasses, because I don't have sufficient type inference machinery to plumb them through, so I _had_ to go back to ml like modules.
06:59:21 <Alpounet> yeah
07:03:19 <roconnor> > length "я"
07:03:20 <lambdabot>   1
07:11:20 * Berengal wants to fork Haskell and call the resulting language The Programming Language Formerly Known As Haskell
07:12:02 <Alpounet> TPLFKAH
07:12:09 <Alpounet> how'd you pronounce it during talks ?
07:12:11 <medfly> not a great acronym
07:12:13 <Berengal> I can then say the real name is >\lambda= or something
07:13:25 <benmachine> in my head it sounds like the sound you make when you accidentally consume chalk dust
07:13:38 <Berengal> >λ=
07:14:34 <benmachine> heh
07:15:23 <Alpounet> >λ_/
07:15:25 <Alpounet> a lambda duck
07:15:40 <Alpounet> nice logo for your language
07:18:13 <Berengal> I think I'll pronounce it "fnord"
07:21:10 <fasta> If you derive an instance in a module X, you cannot use that instance in the same module, right?
07:21:22 <fasta> (deriving via TH)
07:22:37 <Berengal> fasta: You can't write the TH function that does the deriving in the same module
07:23:05 <fasta> Berengal, ok, then it is something else.
07:23:20 <Berengal> Other than that, TH is simply a preprocessor that's run after parsing, but before compiling
07:24:04 <Kruppe> Anyone use IntMaps and have problems with memory consumption?
07:24:24 <Berengal> Kruppe: That's usually caused by not be strict enough in your insertions
07:24:35 <endojelly> does what you do with TH need to be decidable?
07:24:37 <Kruppe> Berengal: yeah im hunting for that right now
07:25:00 <Berengal> endojelly: TH as in, it needs to finish?
07:25:07 <endojelly> Berengal, yes
07:25:38 <Berengal> No, running a TH function is just running a regular Haskell program (in the interpreter) with the current AST as input
07:25:51 <endojelly> oh, it's just that? nice.
07:26:01 <Berengal> You can even do IO if you want
07:26:38 <endojelly> ah. I assumed it was some other, possibly not turing-complete (thus maybe decidable) template language
07:27:00 <Berengal> No, it's just like lisp macros, except not as nice.
07:27:08 <endojelly> 8)
07:28:18 <dankna> smirk
07:28:20 <dankna> quite so
07:29:26 <Kruppe> How differant are bang patterns and seq
07:29:39 <dmhouse> Bang patterns translate into seq
07:29:40 <Berengal> Kruppe: They're the same
07:29:49 <Berengal> Bang patterns are just sugar for seq
07:29:54 <Kruppe> Berengal: thought so :(
07:30:53 <Berengal> Kruppe: insert map key val -> insert map key $! val
07:31:12 <fasta> Why does it matter where I put a call to TH in a module?
07:31:38 <Berengal> fasta: Because it'll be called when the parser reaches it, not when it's finished parsing
07:31:51 <Berengal> Because the rest of the parse may be dependent on the output of the call
07:32:08 <Berengal> Actually, "may" isn't quite strong enough. "Very likely"
07:36:03 <Kruppe> Berengal: Hey thats the closest thing Ive come to an improvement! I now see garbage collection in the heap profile, if only a little.
07:36:26 <Kruppe> Berengal: dunno why it didnt occur to me that i could be dumping thunks in the map
07:38:11 <fasta> Berengal, if I move the derive call to somewhere in the middle, even code which is clearly in scope (which does not do any TH stuff) is "not in scope" according to GHC.
07:38:58 <fasta> Berengal, if I move the TH definition completely to the end, the instance which it is defining is missed by earlier code.
07:39:14 <fasta> Berengal, it seems to me that I have to move it into a module to fix it.
07:41:49 <Berengal> fasta: Yeah, it can be a bother
07:42:43 <Berengal> Kruppe: Also, if you're looking for lazyness and have a general idea of which functions it might escape from, try ghc --show-iface on the .hi file generated
07:43:03 <Berengal> Kruppe: The .hi file contains information such as which arguments are lazy and which aren't
07:43:22 <Kruppe> Berengal: oh, sounds useful, ill check it out
07:45:20 <Itkovian> Kruppe: Do we have another Malazan fan here? :-0
07:45:35 <Kruppe> Itkovian: nice name friend :)
07:45:42 <Kruppe> Itkovian: and deeeeeeeeefinately
07:45:49 * Itkovian bows
07:46:25 <Kruppe> Itkovian: they are what make my daily commutes on the bus bearable!
07:46:47 <Kruppe> Itkovian: that and programming books O_O
07:46:53 <Itkovian> hehe
07:47:30 <maxorator> where exactly is haskell used nowadays?
07:47:52 <Kruppe> maxorator: you mean in industry?
07:47:55 <maxorator> yeah
07:48:27 <maxorator> I'm wondering why I don't hear much about it although it seems to have a pretty big community
07:48:57 <Kruppe> maxorator: It's not real popular compared to other industry standards
07:49:06 <Kruppe> maxorator: so most people don't care about it
07:49:20 <Berengal> maxorator: You are hearing more and more about it, even if you aren't hearing alot in absolute terms
07:49:40 <Berengal> You wouldn't even know about it some years ago
07:50:37 <maxorator> I've heard of it a bit in the last years but I never really looked what it was
07:50:46 <medfly> it's nice.
07:52:26 <zygoloid> maxorator: it's used a fair bit at banks and stock market arbitrage companies and the like
07:53:10 <maxorator> it seems totally weird for a c/c++/pascal guy though
07:53:16 <maxorator> but I guess it has its own advantages
07:55:55 <zygoloid> maxorator: yes, it's very different from that style of language.
07:56:25 <mreh> see Uncyclopedia
07:56:39 <mreh> @google Uncyclopedia Haskell
07:56:40 <lambdabot> http://uncyclopedia.wikia.com/wiki/Haskell
07:56:41 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
07:56:46 <Lycurgus> in that sense Haskell is the Smalltalk of this time
07:56:54 <Kruppe> mreh: hello again! Found PART of the problem from yesterday
07:58:04 <fasta> maxorator, at least 95% of companies do not use Haskell to do arbitrage.
07:58:37 <mreh> KRuppe: ah good
07:58:50 <Kruppe> mreh: was inserting thunks into my maps
07:59:04 <mreh> Kruppe: don't use the work thunks :)
07:59:04 <Kruppe> mreh: so I think it's probably more laziness sneaking away from me
07:59:07 <mreh> word
07:59:07 <kalven> I use it to generate code
07:59:18 <Kruppe> mreh: oh, what should i use then
07:59:23 <mreh> redex
07:59:36 <Kruppe> mreh: ah, I picked up "thunks" from real world haskell
08:00:04 <mreh> well, it means something else really, it doesn't bother me so much, some purists hate it
08:00:12 <mreh> we're kind of stuck with it
08:00:22 <mreh> Kruppe: what kind of map are you using?
08:00:30 <Kruppe> mreh: IntMap
08:00:41 <Kruppe> mreh: Data.IntMap
08:01:30 <mreh> never used it, is there still a problem with it then?
08:01:36 <Kruppe> mreh: right now im working through a ghc --show-iface as suggested by Berengal
08:01:51 <Kruppe> mreh: not sure I get what all of it means
08:01:57 <Berengal> Kruppe: I hope you did profiling first
08:02:07 <fasta> I am currently using 53 libraries. That seems to be quite a lot, no?
08:02:29 <Kruppe> Berengal: oh for sure, been looking at graphs from -hc
08:04:13 <mreh> I'm passing a HOF to a function that uses evalRandIO, which takes a value of type (Rand StdGen a) and returns an a
08:04:23 <MissPiggy> what's a HOF
08:04:29 <mreh> higher order function
08:04:31 <Kruppe> Berengal: what does Strictness: m mean, I can guess at most of the others
08:04:45 <MissPiggy> is id a hof?
08:04:55 <Berengal> Kruppe: Not sure. Take a gander in the GHC Manual.
08:05:10 <mreh> I've bound the HOF's type signature to another variable, and it doesn't like it
08:05:29 <mreh> it wants a function of type Rand StdGen a, not RandomGen g => Rand g a
08:05:46 <zygoloid> MissPiggy: a HOF, or David Hasselhof to give it its full name, is a function from a function
08:06:02 <MissPiggy> lol
08:06:03 <Berengal> mreh: What's the type of evilRandIO?
08:06:03 <mreh> Hasselhoff?
08:06:18 <zygoloid> *shrug* not what i was looking at during the Baywatch credits
08:06:18 <mreh> :t evalRandIO
08:06:19 <lambdabot> forall a. Rand StdGen a -> IO a
08:06:50 <mreh> i'm passing it something of (RandomGen g => Rand g a)
08:07:06 <FliPPeh_> > 4 == 4 ? 2 : 1
08:07:07 <lambdabot>   Not in scope: `?'
08:07:09 <FliPPeh_> k
08:07:11 <FliPPeh_> No tenary..
08:07:16 <mreh> that's not going to work is it?
08:07:26 <FliPPeh_> > if 4 == 4 then 2 else 1
08:07:27 <lambdabot>   2
08:07:43 <Berengal> mreh: That should work, I think...
08:07:53 <mreh> zygoloid :D
08:08:10 <ski> mreh : if the argument you're passing has type `forall g. RandomGen g => Rand g a', there should be no problem
08:08:11 <mapreduce> > 2 -- much simpler
08:08:12 <lambdabot>   2
08:08:18 <mreh> ski: oh
08:08:19 <Berengal> mreh: This is the MonadRandom package, right?
08:08:26 <mreh> Berengal, yes
08:08:30 * Berengal goes test
08:08:56 <ski> mreh : maybe you could paste your actual code, so we can see for ourselves what you're doing ?
08:08:58 <FliPPeh_> mapreduce: basically, it will be 'if state then "1" else "0"'
08:10:05 <mreh> ski: on it
08:11:03 <mreh> the precise error is at the end :http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22995#a22995
08:11:58 <ToRA> > show . fromEnum $ False
08:11:59 <lambdabot>   "0"
08:12:15 <FliPPeh_> > show . fromEnum $ True
08:12:15 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22995#a22995 -- if you want clicky
08:12:16 <lambdabot>   "1"
08:12:17 <FliPPeh_> :D
08:13:34 <FliPPeh_> @pl consume state = getResponse "consume " ++ (show . fromEnum $ state)
08:13:34 <lambdabot> consume = (getResponse "consume " ++) . show . fromEnum
08:14:20 <mreh> Berengal, ski: have you seen the link
08:14:46 <Berengal> mreh: Yeah, I'm looking at it
08:14:51 <ski> mreh : i think something in `gaLoop' is forcing `g' to be `StdGen', while `gaLoop' insists on being polymorphic
08:15:09 <mreh> ski: evalRandIO
08:15:13 <mreh> :t evalRandIO
08:15:14 <lambdabot> forall a. Rand StdGen a -> IO a
08:15:25 <mreh> how can I fix this?
08:15:53 <mreh> or understand what I should be doing
08:16:00 <ski> hm, right, that's it
08:16:01 <FliPPeh_> @pl crossfade newVal :: getResponse $ "crossfade " ++ (show newVal)
08:16:01 <lambdabot> crossfade newVal :: getResponse $ "crossfade " ++ show newVal
08:16:14 <ksf> It'd be cool if we had our own glut/glfw thingie
08:16:14 <FliPPeh_> @pl crossfade newVal = getResponse $ "crossfade " ++ (show newVal)
08:16:14 <lambdabot> crossfade = getResponse . ("crossfade " ++) . show
08:16:17 <medfly> :)
08:16:55 <ksf> and it'd be cool if gpipe would give some statistics on how much textures etc. are tranferred per frame, how many are kept in video mem etc.
08:17:02 <ski> mreh : does `evalRandIO' mutate the global `StdGen' in `IO' ?
08:17:02 <int-e> > showString "crossfade " ""
08:17:03 <lambdabot>   "crossfade "
08:17:09 <int-e> @src showString
08:17:09 <lambdabot> Source not found. Sorry.
08:17:21 <mreh> @src evalRandIO
08:17:21 <lambdabot> Source not found. You speak an infinite deal of nothing
08:17:23 <MissPiggy> showString = (++)
08:17:31 <Berengal> ski: I'd think so
08:17:44 <mreh> it's probably just binding newStdGen to evalRand
08:17:45 <dankna> ksf: I'm working on my own glut/glfw/sdl thing, actually
08:17:49 <mreh> :t newStdGen
08:17:50 <lambdabot> IO StdGen
08:18:00 <ski> in that case, you can't really have `gaLoop' polymorphic with your current approach, i think
08:18:05 <int-e> MissPiggy: I know, but why doesn't lambdabot? :)
08:18:15 <MissPiggy> lambabot is STUPID and EVIL
08:18:25 <FliPPeh_> @pl consume s = getResponse ("consume " ++ (show . fromEnum $ s))
08:18:26 <lambdabot> consume = getResponse . ("consume " ++) . show . fromEnum
08:18:28 <dankna> ksf: I'm writing it in C, actually, but with a Haskell binding.  I don't feel that code that needs to delve into platform internals is best written in Haskell, especially on the Mac which is one of my supported platforms :)
08:18:39 <ksf> dankna, I once tried to get an gl context via xhb, but failed due to the inpenetratability of X
08:18:47 <dankna> yeah, X is nasty
08:18:49 <ski> @vixen you're STUPID and EVIL
08:18:49 <lambdabot> what's the last book you read?
08:18:53 <Kruppe> mreh: Berengal woooooooow, after all this time it wasen't my IntMaps, but my ants
08:18:59 <ksf> but... if you do it in C, you can't use xhb!
08:18:59 <ski> (.. like i said)
08:19:02 <dankna> when I add Linux support, which won't be until the API is finalized, I'll probably depend on gtk+
08:19:08 <mreh> Kruppe :)
08:19:25 <Kruppe> mreh: they were storing lazy results FROM my intmaps in their data
08:19:34 <Kruppe> mreh: which was multiplying their size by A LOT
08:19:50 <mreh> lazyness does make it hard to reason about programs sometimes
08:19:57 <ski> mreh : `gaLoop' is claiming to work for any random generator type, but still it tries to get and set the global one of type `StdGen' .. you see the problem, right ?
08:20:02 <Kruppe> mreh: live and learn I suppose
08:20:07 <ksf> ...I'm trying to get rid of dependencies and legacy, introducing an dependency on gtk doesn't really fit into that scheem
08:20:17 <Kruppe> mreh: It seems so obvious now /facepalm
08:20:24 <dankna> you need either gtk+ or qt in the linux world, it's a fact of life
08:20:29 <dankna> they're what all GUIs are based on
08:20:31 <Kruppe> mreh: make that, double picard facepalm
08:20:36 <dankna> I sympathize profoundly with not /liking/ them
08:20:41 <mreh> ski: well the only way to fix that is have it do IO in MonadRandom
08:20:43 <dankna> but that's like not liking the win32 platform api
08:20:46 <dankna> "suck it up and deal"
08:21:01 <mreh> or Writer monad
08:21:04 <ski> mreh : i suppose you could take an `IORef g' as argument and mutate that instead
08:21:06 <chrissbx> Why is this invalid syntax?: g (let x = 10 in x)
08:21:09 <mreh> but I don't know monad transformers :(
08:21:11 <ksf> nope, I won't accept neither gtk nor qt nor wx, not even xforms
08:21:17 <ski> or a state monad (transformer)
08:21:26 <Berengal> mreh: You could just get rid of the polymorphism
08:21:34 <dankna> I have a slightly larger scope than glut; for example, I consider it important to be able to pop up a "where would you like to save this file?" dialog box
08:21:39 <mreh> Berengal :(
08:21:43 <ski> or a record `(IO g,g -> IO ())' or something like that
08:21:45 <dankna> and do so using the platform's standard interface instead of something custom
08:21:51 <dankna> to do that, I need to use the actual widget set
08:21:52 <ksf> ...I want to depend on freetype, libgl and a running X server.
08:22:04 <dankna> yes, I sympathize with your goal but it just isn't attainable
08:22:07 <dankna> at least
08:22:15 <dankna> if it's what you want, that's not the same thing as what I want
08:22:16 <ski> chrissbx : it is a valid expression
08:22:17 <Berengal> mreh: There are other ways of fixing it, but it involves rank 2 types, and I can't think of how it'd be done off the top of my head
08:22:24 <doserj> > (*2) (let x = 10 in x) -- chrissbx, it is valid syntax
08:22:24 <lambdabot>   20
08:22:26 <Berengal> mreh: But it very likely involves continuations as well
08:22:43 <ksf> ...using existing tk's just won't work out for haskell. I've ranted about that on the cafe some time ago.
08:22:45 <mreh> I think a monad transformer is a good start
08:22:51 <ski> Berengal : what are you thinking of ?
08:23:12 <dankna> ksf: can you point me to some of your posts?  I foresee being profoundly upset at them in my near future :)
08:23:18 <dankna> ksf: because I disagree
08:23:21 <chrissbx> ski / doserj : ah, my bad, I was putting my at the end of a module without assigning it to anything.
08:23:23 <ski> mreh : `StateT g IO' or `ReaderT (IORef g) IO', i think
08:23:37 <ksf> http://www.mail-archive.com/haskell-cafe@haskell.org/msg52557.html
08:23:46 <dankna> ksf: but yeah, one of my target audiences is games, so even if I weren't using existing widget toolkits, I would be using libsndfile for example
08:23:51 <Berengal> ski: The problem is that the generator is somehow existential, which means you'll have to turn things inside out in order to get it to run
08:24:06 <dankna> ksf: I don't think my thing is what you're looking for, but I do hope that it's what everyone else is looking for, haha
08:24:14 <ksf> it bogs down to gtk being utterly inextensible... even if you're writing in C
08:24:24 <ski> Berengal : i don't see the existentiality ..
08:24:27 <dankna> well, I'll agree with that
08:24:28 <HairyDude> how do I get cabal to use both cores? (like make -j 2)
08:24:31 <dankna> give me a moment to read your link
08:24:50 <mreh> ski, Berengal, it'll work if I just have StdGen instead of g, right?
08:24:58 <Berengal> mreh: Yes
08:25:26 <mreh> @instances
08:25:27 <lambdabot> Couldn't find class `'. Try @instances-importing
08:25:29 <dankna> okay, I disagree with your post in three respects
08:25:42 <dankna> a) drawing and layout is anything but trivial, only a math-type would think it is
08:25:46 <mreh> @instances-importing System.Random RandomGen
08:25:47 <lambdabot> StdGen
08:25:50 <mreh> heh
08:25:57 <dankna> b) using native widgets is very very important
08:26:03 <ksf> dankna, I've implemented custom UI's for enough games to say it's trivial.
08:26:16 <ski> (maybe you meant that you could uncurry to `gaLoop :: forall a b. (Show a,Real b,Random b) => (exists g. RandomGen g *> (a -> a -> Rand g (a, a),a -> Rand g a)) -> (Int -> [a] -> GAParams) -> (a -> b) -> Int -> [a] -> IO [a]' ?)
08:26:16 <dankna> games have different needs from actual applications
08:26:23 <Berengal> ski: It's about how some intermediate type signatures can't be turned into prenex types, and that's what causing the issue. At least it's something like that, and I should probably just wave my hands and move on
08:26:35 <ksf> I'm talking about sylus-based widget stuff
08:26:43 <ksf> ...for an RTS
08:27:01 <HairyDude> I guess this bug answers my question http://hackage.haskell.org/trac/ghc/ticket/910
08:27:11 <ski> Berengal : .. i still don't understand what you mean :/
08:27:12 <dankna> sure.  but the fact of the matter is, try writing a spreadsheet or even a decent-sized database front-end with custom widgets.
08:27:25 <Berengal> ski: Well, now neither do I...
08:27:27 <dankna> you'll quickly discover you're reinventing a great many wheels and getting them square.
08:27:29 <ski> afaics, the current problem in the paste is that `gaLoop' promises too much
08:28:14 <ksf> but I won't have any problems extending TreeView to allow for a different number of colums in childs and parents.
08:28:21 <ski> (i.e. it promises to work for any `g' such that `RandomGen g', but internally, it wants `g' to be `StdGen' anyway)
08:28:27 <Berengal> Ooo, ooo! I see the problem!
08:28:35 * Berengal furiously tests his hypothesis
08:28:50 <dankna> no, but your custom tree view will be measurably harder for the user to get things done with, and most users will give up when things don't immediately look familiar to them
08:29:12 <Berengal> evalRandIO' :: forall a. (forall g. RandomGen g => Rand g a) -> IO a
08:29:16 <dankna> when I say measurably harder I mean that if you do usability testing where you record a video session it will be utterly painful to watch all the false starts they make
08:29:51 <Berengal> mreh: You need to move the RandomGen g constraints further in. They can't be in prenex position
08:30:40 <ski> Berengal : i think `evalRandIO' is not defined by mreh
08:30:45 <Berengal> mreh: Your gaLoop promises that it'll work for any RandomGen g, but it only works for StdGen. By moving the constraint further in you're instead saying that the /argument/ has to work for any RandomGen g, not your entire function
08:30:50 <Berengal> ski: No, it's not
08:30:53 <mreh> Berengal: are you offering a fix? Do you mean Rank2?
08:30:58 <Berengal> mreh: Yep
08:31:19 <ksf> ...I just want some way of showing a list of stuff where the user can get additional information by expanding an item. It's not like I want to change the rest of how such a view works.
08:31:21 <mreh> Berengal: that's exactly what I wanted to say, cheers
08:31:34 <ski> (and, iiuc, it mutates a global cell containing `StdGen', so how could you shove `exists g. RandomGen g *> g' (which i presume you mean) into there ?)
08:31:38 <dankna> ksf: right, and reimplementing it is changing it
08:31:53 <dankna> ksf: there are a lot of subtleties in the designs of the platform widgets
08:32:01 <derrida> where is the binary for cabal-install included with ghc 12.1?
08:32:14 <Berengal> (a -> a -> Rand g (a, a)) -> (forall g. RandomGen g => (a -> a -> Rand g (a, a))) and (a -> Rand g a) -> (forall g. RandomGen g => (a -> Rand g a)), remove RandomGen g from the outermost constraint
08:32:15 <ski> Berengal : .. oh, i might be seeing what you mean by `evalRandIO :: forall a. (forall g. RandomGen g => Rand g a) -> IO a' actually .. that could work, possibly
08:32:16 <dankna> ksf: especially the ones like tree view which is actually a fairly complicated task
08:32:20 <galdor> derrida: cabal-install isn't shipped with ghc 6.12.1
08:32:37 <derrida> galdor: ah i see, the wonderful web of misinformation got me :P
08:32:48 <galdor> cabal is installed, ie. the package library
08:32:53 <galdor> but cabal-install isn't
08:33:02 <derrida> galdor: is just bootstrapping it the right way then?
08:33:08 <derrida> ah, i see
08:33:09 <galdor> if you want cabal-install, you need to install the darcs version of cabal, and then the darcs version of cabal-install
08:33:12 <galdor> exactly
08:33:18 <derrida> ok cool
08:33:21 <derrida> thank you
08:33:31 <galdor> it's really easy to do :)
08:33:38 <dankna> ksf: saying "I just want..." makes me think of someone saying "I just want to write a novel and have it published - I don't want to deal with all these things like character and story"
08:34:26 <dankna> ksf: the subtle user-interface decisions, even the tiny ones, are essential complexity in the design of a tree-based user interface.  they cannot be abstracted out by any means, unless you don't care about the usability of the resulting program, and if that's the case we have nothing to discuss
08:34:58 <ski> Berengal,mreh : but, possibly it would be enough for `nextGeneration' (and `gaLoop') to always choose the same `g' for `cross' and `mutate' ?
08:35:20 <mreh> All of the type variables in the constraint `RandomGen g'
08:35:20 <mreh>     are already in scope (at least one must be universally quantified here)
08:35:30 <mreh> I guessed a forall g. would fix that, but why?
08:35:30 <dankna> ksf: it's strongly analogous to how you can't abstract out the need to think about deadlocks when programming with threads.  when dealing with the user, you can't avoid the need to think about UI details.
08:35:48 <dankna> ksf: if you don't like it, don't write software that has user interfaces!
08:36:13 <ksf> I agree. but GTK doesn't even give me the _possibility_ to do my own stuff, at least not without reimplementing the whole tree widget.
08:36:22 <mreh> Berengal: just read the scrollback, thanks
08:36:27 <dankna> well, I certainly have no intention of defending GTK :)
08:36:35 <dankna> that anyone gets anything done on Linux blows my mind
08:36:54 <Kruppe> dankna: All my computers, work and home use linux
08:36:57 <dankna> but people voluntarily choose to subject themselves to it, so if you're supporting Linux as a platform, you're kinda stuck with it
08:37:04 <dankna> Kruppe: consider my mind blown :)
08:37:12 <ksf> mine, too.
08:37:15 <Kruppe> dankna: lol, I am WAY more productive on linux
08:37:23 <dankna> well, it's not my intention to get into /that/ debate just now
08:37:30 <dankna> I have respect for the platform as a platform
08:37:40 <ksf> I once had to use windows at work, and I was very thankful for bb4win.
08:37:41 <Kruppe> dankna: fair enough.
08:37:57 <shepheb> vim and vimperator (for Firefox) are my world on any platform.
08:38:00 <Kruppe> dankna: but know this, it CAN be done and I prefer it infact. (be productive i mean)
08:38:06 <ksf> not that blackbox is my favourite window manager, but it beats the shit out of the default shell.
08:38:11 <dankna> I'm a Mac user, since we're sharing
08:38:19 <dankna> the clue was me talking about usability :)
08:38:36 <ksf> I'm in the vi/blender/xmonad camp
08:38:39 <Kruppe> shepheb: emacs vimperator and xmonad here
08:38:46 <dankna> Kruppe: well, I know it can.  I used Linux (Debian) exclusively on my home machine for about three years.
08:38:50 <ksf> ...and vimperator, of course.
08:38:57 <dankna> Kruppe: I just decided in the end that I didn't like it.
08:39:08 <dankna> meh, don't get me started on text editors :( they all suck :(
08:39:08 <Kruppe> dankna: I would agree its not for everyone
08:39:28 <Kruppe> dankna: use emacs and make it what you want then
08:39:33 <ksf> ...there's a difference between intuitive and obvious interfaces. sometimes the obvious thing just isn't the right choice in the long run
08:39:40 <dankna> I do use Emacs, but life's too short to customize it
08:39:48 <Kruppe> dankna: lol i hear that.
08:39:54 <dankna> haha
08:39:58 <ksf> the more often I'm going to use a program, the less obvious it can be.
08:40:06 <dankna> ksf: I certainly agree there
08:40:07 <Kruppe> dankna: It took a long time but im finally happy with it
08:40:14 <dankna> I also used vi for about five years, even wrote half of my own vi at one point
08:40:29 <dankna> I hate vi and emacs equally at this point, but emacs has a lot of killer features that I've gotten addicted to
08:40:39 <dankna> which, as emacs fans point out when I say this, is backhanded praise for emacs
08:41:24 <mreh> I never get people who see their tools as a end in themself
08:41:36 <dankna> mreh: hmm...
08:41:54 <ksf> so, at this point I'm fooling around with drawing some primitives and then getting them into shape to do some layout
08:41:57 <Kruppe> mreh: I use emacs cause it does what I want
08:41:59 <dankna> mreh: could you elaborate on that?
08:42:11 <mreh> I don't derive pleasure from using the tools, I get the pleasure from the finished product
08:42:13 <dankna> ksf: well, I'm happy you've found something you can work with.
08:42:30 <dankna> mreh: I agree with that, I think, but I don't see the applicability
08:42:39 <dankna> heh, we crowded out all the other conversations with this
08:42:50 <Kruppe> dankna: yeah i think thats enough offtopic for now
08:42:56 <dankna> yeah, fair nuff
08:42:57 <mreh> please take it to haskell-blah if you like
08:43:09 <dankna> nah, I should get back to work :)
08:43:15 <dankna> but it was an interesting discussion
08:43:51 <Kruppe> dankna: cheers, back to work with me as well
08:44:28 <ski> mreh : i.e. i was suggesting having `(forall g. RandomGen g => (a -> a -> Rand g (a, a),a -> Rand g a))' as argument .. that would give `nextGeneration' a little less freedom (which it doesn't appear to need) .. i suppose it's a question of what you want
08:46:03 <etpace> Hey, I'm trying to use Parsec2, and the seemingly innocent test = oneOf "fowl" gives me a No instance for (Text.Parsec.Prim.Stream s m Char)
08:46:11 <etpace> anyone got some ideas?
08:46:43 <fasta> etpace, any particular reason to use Parsec2?
08:46:49 <fasta> etpace, (and not 3)
08:48:45 <Saizan> etpace: you are using parsec-3 if you get that error
08:49:14 <Saizan> etpace: the solution is to give a type signature or use {-# NoMonomorphismRestriction #-}
08:49:30 <Saizan> err, {-# LANGUAGE NoMonomorphismRestriction #-}
08:49:46 <etpace> aha
08:49:55 <etpace> well I apt-get parsec2, so ithought it was 2
08:53:12 <Alpounet> byorgey, can I point people to your documents about set theory & all ? (precalculus, on your website)
08:53:19 <dons> parsec 3 isn't suppoted by the haskell platform
08:54:01 <Saizan> etpace: see ghc-pkg list parsec
08:55:23 <roconnor> @free forall k. Cont k (Cont bool k)
08:55:23 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:55:30 <roconnor> @free foo : forall k. Cont k (Cont bool k)
08:55:30 <lambdabot> Extra stuff at end of line
08:55:34 <roconnor> @free foo :: forall k. Cont k (Cont bool k)
08:55:34 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
08:55:41 <roconnor> @free foo :: Cont k (Cont bool k)
08:55:41 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
08:55:55 <roconnor> how does free work again?
08:55:58 <roconnor> oh
08:56:03 <roconnor> maybe it doesn't know Cont
08:56:07 <aavogt> @free a -> b
08:56:07 <lambdabot> Extra stuff at end of line
08:56:08 <sbahra> edwardk, my copy of Hacker's Delight has arrived. Thanks for the book recommendation.
08:56:12 <aavogt> @free f :: a -> b
08:56:12 <lambdabot> h . f = f . g
08:56:47 <roconnor> @free foo :: (((k -> bool) -> bool) -> k) -> k
08:56:47 <lambdabot> (forall p q. (forall f1 f2. g . f1 = f2 . f                            =>                             g (p f1) = q f2)             =>              f (h p) = k q) => f (foo h) = foo k
08:58:52 * ksf wonders if it's a limitation of gpipe that I can't carry textures in a primitive stream or whether it's really a bad idea
09:00:03 <ksf> associating each pair of triagles with the texture it's going to display seems to be a good idea...
09:00:43 <c_wraith> Ok...  are there any gotchas when using atomicModifyIORef?
09:01:13 <mreh> Jeremy Beadle will appear and pie you in the face
09:01:25 <ski> @djinn-add data Cont o a = Cont ((a -> o) -> o)
09:01:39 <c_wraith> that is an unexpected gotcha
09:01:49 <ski> .. er, hm
09:02:00 * ski forgets that `free' is not `djinn'
09:03:20 <mreh> quite unexpected seeing as he died!
09:05:59 <roconnor> @src Cont fmap
09:05:59 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
09:06:44 <c_wraith> IS readIORef guaranteed to be consistent, if the IORef is also being modified concurrently?
09:07:41 <roconnor> I hope not
09:07:48 <roconnor> :)
09:08:19 <c_wraith> By consistent I mean "returns valid data", not "always returns the same data"
09:08:39 <c_wraith> That is, it never returns half of one, half of the other
09:10:51 <ski> @unmtl ContT k (Cont Bool) k
09:10:51 <lambdabot> (k -> (k -> Bool) -> Bool) -> (k -> Bool) -> Bool
09:10:57 <ski> @unmtl Cont k (Cont Bool k)
09:10:57 <lambdabot> (((k -> Bool) -> Bool) -> k) -> k
09:11:38 <roconnor> c_wraith: I've rethought it and now think that it might be okay if it were consistent.  I wouldn't want to count on it myself, but I'm sure others here know better.
09:13:47 <noggle> hi guise!
09:16:27 <Berengal> c_wraith: I don't think there are any guarantees, and probably depends on the platform
09:28:50 <c_wraith> Berengal: you're probably right.  I'll just use the extremely verbose: flip atomicModifyIORef (join (,))
09:42:28 <ski> @djinn ((((o -> Bool) -> Bool) -> o) -> o) -> (((((o -> Bool) -> Bool) -> o) -> o) -> Bool) -> Bool
09:42:30 <lambdabot> f _ _ = False
09:42:48 <ski> ..
09:43:02 <ski> @djinn ((((o -> b) -> b) -> o) -> o) -> (((((o -> b) -> b) -> o) -> o) -> b) -> b
09:43:02 <lambdabot> f a b = b (\ c -> c (\ d -> d (a (\ e -> c (\ _ -> e d)))))
09:43:31 <ski> @djinn ((((((o -> b) -> b) -> o) -> o) -> b) -> b) -> (((o -> b) -> b) -> o) -> o
09:43:32 <lambdabot> f a b = b (\ c -> a (\ d -> c (d (\ e -> b (\ _ -> e c)))))
09:43:59 <ski> (probably that doesn't show squat, though ..)
09:50:50 <phrixos> quit
09:53:27 <tumult> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22997 ok, what am i doing wrong?
09:53:49 <tumult> (just installed the vector library and wanted to play around, but then this happens)
09:55:01 <c_wraith> huh.  atomicModifyIORef doesn't behave well under contention, either.
09:55:10 <c_wraith> looks like I'm using an MVar!
09:56:05 <Lemmih> tumult: Did you create the .bin file with Data.Binary?
09:56:47 <tumult> hm, no. does decodeFile require a specific format? if it does, then that explains that
09:57:07 <tumult> i figured it just read in raw data with whatever endian the host was (if over 8 bits)
09:57:26 <c_wraith> sadly, it does not do that.
09:57:32 <tumult> oh :)
09:58:34 <tumult> well that solves that
09:58:50 <dons> tumult: what are you looking to do with vectors?
09:58:54 <dons> parse a file into a vector?
09:59:28 <c_wraith> man...  a heap profile that's level.  Just what I wanted to see.
09:59:36 <tumult> i was in the middle of writing an utility that converts large ADPCM encoded audio files and spits out raw wave data from them
09:59:42 <dons> cool.
09:59:49 <tumult> i saw vector 0.5 appear and thought i'd play with it, except i'm an idiot :)
09:59:51 <dons> you can see how to fill a vector from a binary file here, http://code.haskell.org/~dons/code/vector-binary-instances/Data/Vector/Binary.hs
09:59:59 <tumult> ah ok, cool
10:00:00 <dons> see the 'get' instance.
10:00:13 <dons> you just need to define one for your format
10:00:25 <tumult> yeah i was just using get and put before, but with all of the intermediary stuff with lists and normal bytestrings
10:00:30 <c_wraith> Oh, blah.  You can't profile with multiple OS threads?
10:00:42 <tumult> well, was planning on it, anyway.
10:03:13 <regalia> http://pastebin.archlinux.fr/37850
10:03:30 <regalia> I'm trying to figure out how to instance show for Card
10:04:04 <mauke> that pastebin doesn't work
10:04:23 <mauke> oh, you got the url wrong
10:04:26 <regalia> agh
10:04:33 <regalia> add the 9
10:04:37 <regalia> http://pastebin.archlinux.fr/378509
10:04:59 <mauke> show (Card x y) = ...
10:05:11 <regalia> mauke: Thank you very much, I knew it was simple
10:06:52 <MissPiggy> @dict priggery
10:06:52 <lambdabot> Supported dictionary-lookup commands:
10:06:53 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
10:06:53 <lambdabot> Use "dict-help [cmd...]" for more.
10:06:57 <MissPiggy> @wn priggery
10:06:59 <lambdabot> No match for "priggery".
10:07:05 <MissPiggy> @all-dicts priggery
10:07:06 <lambdabot> *** "Priggery" gcide "The Collaborative International Dictionary of English v.0.48"
10:07:06 <lambdabot> Priggery \Prig"ger*y\, n.
10:07:06 <lambdabot>    Priggism.
10:07:06 <lambdabot>    [1913 Webster]
10:07:28 <dankna> @web1913 priggism
10:07:28 <lambdabot> *** "Priggism" web1913 "Webster's Revised Unabridged Dictionary (1913)"
10:07:29 <lambdabot> Priggism \Prig"gism\, n.
10:07:29 <lambdabot>    1. The quality or state of being priggish; the manners of a
10:07:29 <lambdabot>       prig. --Ed. Rev.
10:07:29 <lambdabot>  
10:07:30 <lambdabot>    2. Roguery; thievery. [Obs.] --Fielding.
10:07:34 <dankna> @web1913 priggish
10:07:35 <lambdabot> *** "Priggish" web1913 "Webster's Revised Unabridged Dictionary (1913)"
10:07:35 <lambdabot> Priggish \Prig"gish\, a.
10:07:36 <lambdabot>    Like a prig; conceited; pragmatical. -- {Prig"gish*ly}, adv.
10:07:38 <lambdabot>    -- {Prig"gish-ness}, n.
10:07:39 <dankna> heh, okay
10:10:10 <tumult> dons: thanks for the info and the library by the way :)
10:12:47 <dankna> bah.  is anybody aware of a compression package that provides a chunk-at-a-time interface?  lazy bytestreams aren't being sufficiently lazy for me, and I have 160M of uncompressed data, which is more than I want to keep in memory at once...
10:14:03 <dankna> so far I've looked at the bzip and zlip bindings
10:14:18 <ksf> virtually all encoders are chunked
10:14:33 <dankna> well, I meant in Haskell
10:14:42 <dankna> they seem to do chunking through lazy bytestreams
10:14:48 <dankna> which is fine if you're able to use them...
10:15:03 <ksf> ...they have to, as they have to get a histogram of the stuff they're encoding
10:15:32 <int-e> dankna: but why can't you use them?
10:16:24 <dankna> int-e: Well, that's a question, isn't it.  I'm not convinced that I fully understand that myself, but the performance I'm seeing indicates that they're entirely loading into memory instead of making a streaming computation as I might hope.
10:16:33 <dankna> It probably has something to do with the code that produces them being in IO.
10:17:07 <dankna> ksf: I don't think I follow you.  Are you saying that it has to consume the entire input before it can begin generating output, and has to keep the input in memory no matter what?
10:17:12 <dankna> ksf: if not, that seems like a non-sequitor
10:17:38 <MissPiggy> ksf, saying a non-sequitor? never!
10:17:48 <dankna> haha
10:17:48 <mauke> *sequitur
10:17:58 <dankna> @wn sequitor
10:17:59 <lambdabot> No match for "sequitor".
10:18:01 <dankna> @wn sequitur
10:18:02 <lambdabot> No match for "sequitur".
10:18:06 <dankna> well, anyway :)
10:18:21 <mauke> sequitur - Latin for "it follows"
10:19:28 * hackagebot upload: zeromq-haskell 0.2.1 - bindings to zeromq (ToralfWittner)
10:19:39 <Berengal> dankna: Are you reading the bytestring in lazily?
10:20:03 <zygoloid> @wn non-sequitur
10:20:03 <lambdabot> No match for "non-sequitur".
10:20:14 <dankna> Berengal: well, it's a dump of a large IOUArray
10:20:15 <copumpkin> sequor
10:20:35 <dankna> Berengal: if there's a means to make that lazy, I'm not aware of it, since getElems isn't and readArray isn't either
10:21:01 <Berengal> dankna: Well, that array needs to be entirely in memory, so it doesn't help that you're using lazy bytestrings...
10:21:36 <dankna> well, with the bytestrings there are TWO copies of it entirely in memory :)
10:21:49 <dankna> but yes, exactly
10:22:06 <Berengal> Well, the bytestring is lazy, and would only copy 64kb at a time...
10:22:20 <Berengal> (Presumably the heads can be garbage collected once they're spent)
10:22:24 <dankna> that may be a design goal, but it's not the observed behavior
10:22:28 <int-e> dankna: you can unsafeFreeze the array and convert it to a lazy bytestring in pure code. Or you can produce your bytestring using fromChunks and unsafeInterleaveIO.
10:22:32 <dankna> I see my memory usage double
10:22:46 <zygoloid> since the array is mutable, it can't safely lazily produce its result
10:22:50 <int-e> but a chunky interface to zlib (or similar) seems more reasonable actually
10:22:56 <dankna> int-e: hmmmmmmmmmm, that's a fascinating thought.  I tried poking around in the internals a bit but didn't get that far.
10:23:23 <dankna> ah, well thanks :)
10:23:35 <Berengal> Can't you just hGetContents on the file?
10:23:57 <dankna> I'm not reading a file, I'm writing one - this is data I generated (a fractal with some user editing).
10:24:16 <dankna> I haven't gotten as far as reading yet, but yes, that may be an appropriate strategy when I do.
10:24:17 <int-e> and with Iteratees on the rise we may see one real soon now.
10:24:21 <Berengal> Ah
10:24:31 <dankna> that is, I have a non-tuned implementation of reading, which is probably unusably slow :)
10:24:45 <dankna> Iteratees?  not familiar
10:32:02 <noggle> :t flip
10:32:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:50:20 <tomberek> is there any difference between a where and let?
10:50:39 <mauke> syntactically, yes
10:50:42 <Cale> tomberek: where is part of declaration syntax and scopes over guards, let is part of expression syntax
10:51:05 <tomberek> i mean in terms of CSE
10:51:12 <Cale> There is no CSE
10:51:20 <Philonous1> tomberek: But where desugars to let afaik.
10:51:23 <Cale> where is translated into let
10:51:26 <Cale> yeah
10:51:45 <tomberek> ok
10:52:55 <tomberek> so a declaration using where will behave the same way as one with let/in?
10:53:05 <mauke> yes
10:53:12 <tomberek> roger
10:53:35 <copumpkin> there is CSE in wheres and lets
10:53:40 <Cale> tomberek: However, it might be a bit of work to do the translation if there're guards.
10:53:58 <Cale> copumpkin: Only a very trivial amount...
10:54:07 <Cale> Er, isn't it with nested cases?
10:54:30 <Cale> nested cases which match on the same expression will be CSE'd as I recall
10:54:33 <copumpkin> if you have let x = e; y = e in ..., x and y will be made the same thing for ...
10:54:34 <copumpkin> :P
10:54:42 <Cale> Oh, really?
10:54:45 <Cale> That's surprising.
10:54:48 <copumpkin> apparently
10:54:56 <copumpkin> why? it's not risky
10:55:04 <medfly> CSE =?
10:55:11 <copumpkin> common subexpression elimination
10:55:12 <Cale> Common subexpression elimination
10:55:14 <MaciejP> I'm a little bit confused with the Data.Typeable module, how would I define a Typeable instance of e.g. data A = A Int String?
10:55:14 <xerox> common subexpression elimination
10:55:29 <mauke> MaciejP: ... deriving (Typeable)
10:55:31 <copumpkin> MaciejP: I think GHC can derive it for you
10:55:32 <medfly> ok
10:55:39 <medfly> thx
10:56:01 <tomberek> copumpkin: without side effects, it's safe?
10:56:15 <copumpkin> tomberek: yes
10:56:24 <Cale> > let power [] = [[]]; power (x:xs) = let us = power xs; vs = power xs in us ++ map (x:) vs
10:56:25 <lambdabot>   not an expression: `let power [] = [[]]; power (x:xs) = let us = power xs; ...
10:56:31 <Cale> > let power [] = [[]]; power (x:xs) = let us = power xs; vs = power xs in us ++ map (x:) vs in power [1..9]
10:56:32 <lambdabot>   [[],[9],[8],[8,9],[7],[7,9],[7,8],[7,8,9],[6],[6,9],[6,8],[6,8,9],[6,7],[6,...
10:56:36 <MaciejP> mauke, copumpkin: Indeed, that was too easy :-)
10:57:04 <tomberek> copumpkin: then why can't GHC do CSE more often... (I asked before, and was told it was not always best, and space leaks.  I read the page on it, but don't see how if there are no side effects, why it would be dangerous.)
10:57:09 <Cale> ^^ seems like it would make a difference in space usage in something like that
10:57:22 <copumpkin> tomberek: I thought we coverd this yesterday :P
10:57:41 <Cale> tomberek: It's always semantically valid, but not always a good idea performance-wise.
10:57:50 <copumpkin> tomberek: if you manually CSE by using a let, you're already saying you don't mind it being kept around
10:58:10 <copumpkin> if you use the same expression twice in your let-bound names, there's no problem reusing them
10:58:36 <Cale> copumpkin: What about a let where you've defined x and y to be the same expression, but x can be garbage collected before y, and y might not be evaluated until later?
10:58:38 <tomberek> Yes, i know... still can't wrap my brain around it... When being introduced to haskell, that seemed to be a bonus, that it can be done for you automatically.  Otherwise what is the point of remaining pure?
10:58:59 <copumpkin> Cale: dunno, according to that wiki page, that's the only case where it does CSE
10:59:03 <Cale> tomberek: The point of remaining pure is to make code possible to understand.
10:59:27 <copumpkin> http://www.haskell.org/haskellwiki/Performance/GHC
10:59:30 <monochrom> «f x = [1..1000000] ++ [1..x] ++ [1..1000000]». Do you really want CSE here? There is a 1000000-long list you will have to keep in memory for an unknown time.
11:00:09 <Cale> copumpkin: it's not exactly what you said :)
11:00:22 <tomberek> monochrom: no, you simply point to the procedure to calculate it.
11:00:29 <tomberek> the "thunk"
11:00:36 <tomberek> then when it is needed, you only calculate once
11:00:43 <mauke> ... and keep it in memory
11:00:54 <Cale> er, oh, maybe it is
11:01:13 <monochrom> What mauke says.
11:01:23 <copumpkin> what monochrom says.
11:01:56 <monochrom> «main = print ([1..1000000] ++ [1..x] ++ [1..1000000]» to eliminate the façade you're hiding behind.
11:02:15 <copumpkin> OMG
11:02:31 <mauke> monochrom: unmatched (
11:02:39 <MissPiggy> unmatched :(
11:02:41 <Cale> tomberek: recomputing [1..1000000] is so inexpensive that it's a total waste to keep such a long list in memory
11:03:01 <tomberek> yes, GHC can't realize that sort of thing?
11:03:09 <copumpkin> tomberek: how?
11:03:11 <akappa> ad access memory is quite expensive
11:03:17 <akappa> *and
11:03:18 <edwardk> sbahra: glad you liked it =)
11:03:20 <Cale> tomberek: If you did CSE, it would have to keep it in memory
11:03:20 <monochrom> Sometimes even humans can't realize that sort of things.
11:03:39 <tomberek> hm.....
11:03:59 <Cale> tomberek: let x = [1..1000000] in x ++ x -- this has to retain the elements of x as they're computed because it will need them again
11:04:14 <Cale> (there's still a pointer to them, so they can't be GC'd)
11:04:22 <monochrom> If it's «g 1000000 ++ h x ++ g 1000000», without the code for g, do you know?
11:04:31 <tomberek> otherwise a fold or something over it can GC it as it is consumed?
11:04:42 <Cale> yeah
11:04:49 <monochrom> Or if it's «g 1000000 ++ h x ++ g 1000000», with the code for g, but it's a clever algorithm to solve diophantine equations, do you know?
11:05:01 <Cale> Normally, you can print the elements of [1..1000000] ++ [1..1000000] in constant space
11:05:23 <copumpkin> > ([1..1000000] ++ [1..1000000]) !! 1500000
11:05:24 <lambdabot>   500001
11:05:25 <MissPiggy> I am studying diophantine equations
11:05:29 <Cale> (little more than the space required for one cell of the list)
11:05:46 <Cale> (and the expression itself)
11:06:05 * lispy finds it odd that nearly everything on hackage is marked "Experimental"
11:06:16 <copumpkin> MissPiggy: have you seen the massive diophantine equation for the primes?
11:07:18 <tomberek> ok, i'll let that stew for a while.  I just want to make sure that what I am calculating is actually compiled to what i want.
11:07:28 <MissPiggy> that one is always a prime? but it is not all primes right?
11:07:51 <copumpkin> it's all primes but a bunch of other stuff too, I thought
11:07:59 <edwardk> tomberek: when it comes right down to it, if it is important to you, you can always manually CSE, but if you don't want it to be done, there is no mechanism that you could use to express that fact
11:08:22 <MissPiggy> I've seen a polynomial which, evaluated on positive integers gives a prime
11:08:28 <MissPiggy> but I don't believe it is surjective onto primes
11:09:04 <tomberek> edwardk: yeah,,,, part of me just sees those repeated expressions and it just looks ugly to be repeating yourself..... something I have to get used to
11:09:34 <MissPiggy> is that different?
11:11:00 <c_wraith> ooh, ohh.  I can do this.  [1..]  contains all primes, but some other stuff too!
11:11:07 <doserj> MissPiggy: there is a polynomial which gives a prime if it positive, and every prime is reached.
11:11:16 <MissPiggy> doserj wow cool what is it?
11:11:18 <Zao> Remember, 9 is a prime.
11:11:32 <MissPiggy> c_Wraith, that is not diophantine :)
11:11:44 <c_wraith> MissPiggy: it's really simple, though. :)
11:13:35 <doserj> http://en.wikipedia.org/wiki/Formula_for_primes#Formula_based_on_a_system_of_Diophantine_equations
11:13:35 <monochrom> code optimization courses bring up CSE because their source languages stick with, like, 4-bit words. Notice how no one talks about CSEing over, say, array languages where an innocent expression like "a+b" could be easily a 1GB array.
11:14:08 <doserj> or google for Matiyasevich's polynomial
11:14:22 <Cale> Find a system of diophantine equations parametrised by k which has a solution in n if and only if the kth lambda term (in some order), reduces to normal form under normal-order evaluation in n steps.
11:14:39 <MissPiggy> Cale easy! :)
11:14:51 <MissPiggy> ro I should say, the hard work was already done ?
11:15:29 <c_wraith> monochrom: 4 *bit*?  You sure you didn't mean 4 byte?  :)
11:15:37 <monochrom> exaggeration
11:16:19 <MissPiggy> wow cool that really is surjective
11:20:49 <aavogt> > foldl op 0 [1..3]
11:20:50 <lambdabot>   Not in scope: `op'
11:20:54 <aavogt> > foldl f 0 [1..3]
11:20:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:20:55 <lambdabot>    `GHC.Num.Num a' arising ...
11:20:59 <aavogt> > foldl f 0 [1..3] :: Expr
11:21:00 <lambdabot>   f (f (f 0 1) 2) 3
11:23:09 <deadguys> hi all.  I have a small program that writes a bunch of junk to stdout.  the memory jumps up to 1.6G.  is this a space leak?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22998#a22998
11:23:41 <deadguys> oh crap forgot the base case
11:24:06 <monochrom> If you have the base case, memory usage will be much better. Do you know why?
11:24:28 * benmachine doesn't
11:24:29 * Zao slaps people around with some optimization flags.
11:24:59 * mauke listens to case of base
11:25:05 <monochrom> Because the base case causes earlier evaluation of the n-1 thunk.
11:25:26 <benmachine> ah
11:25:31 <deadguys> ok updated: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22998#a22999
11:25:32 <benmachine> because you have to compare it with 0
11:25:32 <doserj> s/earlier//
11:26:00 <benmachine> deadguys: is that the program that consumes lots of memory then?
11:26:40 * MissPiggy is trying to generate primes with matiyasevichs polynomial but no results...
11:27:30 <deadguys> the program always had the base case;  just omitted from the paste
11:27:50 <Zao> 1-16 megs of memory usage here, while spamming like crazy.
11:28:23 <monochrom> Write a system of diophantine equations that evaluates the kth haskell program. now let k = Melissa O'Neil's haskell program.
11:28:43 <MissPiggy> hehe
11:28:55 <Zao> deadguys: And if you build with ghc --make?
11:29:11 <Zao> I get equivalentish amounts of memory use, no matter whether I use -O0 or -O2.
11:29:35 <monochrom> Do you know this math joke? "How to visualize 4D space? (Or 5D space, or 10D space...)  Answer: visualize n-D space, then let n=4."
11:30:01 <Zao> deadguys: runhaskell indeed bloats like mad.
11:31:17 <p_l> monochrom: I prefer “N=1 then P=NP”, scribbled on margin of "Concrete Mathematics" :)
11:32:03 <deadguys> Zao:  ahh,  after make, flat at 18 meg.  much better
11:32:20 <deadguys> Zao:  didn't know that about runhaskell
11:32:22 <Zao> monochrom: So it runs with craptastic memory characteristics in runhaskell (and ghci).
11:32:26 <Zao> monochrom: Know why?
11:32:33 <deadguys> i don't
11:32:41 <deadguys> want to though
11:32:47 <monochrom> Hrm!
11:33:17 <p_l> monochrom: since someone scribbled that, it's in every release :)
11:33:23 <jlouis> what undrelying haskell implementation does runhaskell call?
11:33:25 <Cale> Is the program threaded?
11:33:38 <Cale> er, oh, there's a paste
11:33:40 <Zao> jlouis: Here - runghc which is some kind of ghci bastardisation.
11:33:41 * Cale looks
11:33:48 <Zao> Cale: Very trivial code.
11:33:54 <deadguys> indeed
11:34:11 <Cale> oh, hmm
11:35:09 <monochrom> Zao: I cannot explain it.
11:36:51 <MissPiggy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8120
11:36:57 <MissPiggy> this is my Matiyasevich implementations
11:37:13 <MissPiggy> C has been defeated haskell
11:38:22 <RayNbow> copumpkin: remember those adjacency matrices I showed recently? I tried plotting A^2 for other BitTorrent swarms... but gnuplot doesn't like plotting 150+ MB files :p
11:39:01 <doserj> MissPiggy: why did you expect a result if you only allow 0,1?
11:39:24 <MissPiggy> I dunno, I just tried anything
11:39:35 <Berengal> MissPiggy: sequence . replicate n = replicateM n
11:39:35 <MissPiggy> the problem is that the search space is too big, even with 0,1 it can't complete
11:40:39 <monochrom> Zao: I can explain it. Something about main's expansion being kept in memory because it's toplevel.
11:41:44 <tomberek> when you have a data type where some of the records are functions, (can't derive Show) is there an easier way to let you show it other than adding instances of Show everywher?
11:42:12 <Cale> tomberek: You could add an instance of Show for functions, and then derive Show
11:42:44 <tomberek> instance Show (->) or something?
11:42:53 <int-e> sequence is a foldr which does not help things - it means that for replicateM 26 [0,1], a 2^25 element list is kept alive.
11:42:55 <Berengal> instance Show (a -> b)
11:43:03 <doserj> MissPiggy: you realiye the particular form of this polynomial? (k+2)*(1-sum_of_squares). i.e., k+2 has to be prime, and the other polynomials zero
11:43:21 <doserj> MissPiggy: not that that helps very much...
11:43:31 <Zao> monochrom: That's plausible.
11:43:44 <tomberek> Berengal: erg... i have different type signatures there, so adding an instance for each is almost as bad
11:43:46 <ksf> gnargh
11:43:56 <tomberek> or can that one instance capture all of them?
11:43:56 <benmachine> tomberek: if you can derive Data, you could try gshow
11:43:57 <ksf> gpipe won't let me do matrix multiplication on the gpu
11:43:58 <monochrom> However, this will not consume much memory: main = do { s:_ <- getArgs; massiveIO (read s) }
11:44:11 <ksf> which is kinda suprising, considering that that's all it ever does.
11:44:19 <MissPiggy> > let pr1mes = 7 : zipWith (\n a_n1 -> a_n1 + gcd n a_n1) [1..] pr1mes in take 10 $ filter (/=1) (zipWith subtract pr1mes (tail pr1mes))
11:44:20 <lambdabot>   [2,7,13,5,29,3,59,3,7,5]
11:44:32 <ksf> matrix times vector works flawlessly...
11:44:35 <Berengal> int-e: Isn't the result of replicateM lazy in the list case though?
11:45:33 <Sternmull> can i access a tuple by index?
11:45:34 <noggle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23000#a23000
11:45:39 <noggle> my failing in learning haskell
11:45:56 <BONUS> haha http://twitter.com/ihatehaskell this really should have more followers
11:45:59 <mauke> Sternmull: not really
11:46:17 <monochrom> For extra fun, this will not consume much memory either: main = return 1500000 >>= massiveIO
11:46:23 <ksf> ghc could also be smarter about pinning down the exact location of type errors involving type functions.
11:46:39 <konr> What is wrong with `number <- read args !! 0 * 4`? I'm getting a couldn't match type error (Expected: String, Inferred: [String])
11:46:59 <mauke> konr: <-
11:47:01 <ksf> Sternmull, if you want fixed-length lists, you can use of of those vector packages
11:47:07 <samebchase> :n
11:47:13 <MissPiggy> konr, it's because you need to bracket like  read (args !! ...)
11:47:17 <int-e> length $ sequence (replicate 25 [0,1]) - 2 GB of memory.  let sequence' xs = fmap reverse . foldl (liftM2 (flip (:))) (return []) xs in length $ sequence' (replicate 25 [0,1]) - no visible memory usage
11:47:23 <mreh> I don't understand it, I've got an auxilliary function that throws a "non-exhaustive pattern match error" because any un-implemented function defs are theoretically impossible, but when I add the impossible definitions, the super function throws a different error!
11:47:26 <MissPiggy> otherwise it's parsed like  (read args) !! ...  which is wrong
11:47:26 <theorbtwo> Sternmull: fst ("this", "other") snd ("other", "this")
11:47:37 <Sternmull> mauke: i am looking for a way to have an equivalent to C fixed size arrays
11:47:43 <int-e> Berengal: lazy, yes. the problem is sharing.
11:47:44 <mauke> Sternmull: how about an array?
11:47:46 <Twey> theorbtwo: Can't type
11:47:52 <benmachine> mreh: obviously not as impossible as you thought
11:47:58 <Twey> "this" isn't a function
11:48:05 <benmachine> (um, I won't say obviously... probably)
11:48:25 <int-e> Berengal: laziness means that the result list of length 2^26 is not kept around. the list of length 2^25 was an intermediate result
11:48:28 <Sternmull> mauke: i expected arrays to have overhead (size-parameter and allocation) that i dont need for fixed size "vectors"
11:48:59 <mauke> Sternmull: you care about what, 12 bytes of overhead? in HASKELL?!
11:49:00 <monochrom> Here is the explanation: there is almost nothing to expand in «... >>= massiveIO» or «... >>= \s -> massiveIO (read s)». However, «massiveIO 1500000» is expandible to a chain of «... >> ...»s of length 15000000
11:49:11 <mm_freak> > let encrypt pt = catMaybes . map (`lookup` pt) in encrypt [('a','b'), ('b', 'c'), ('c', 'a')] "abc"
11:49:12 <mreh> I've implemented the functions to throw errors that say what went wrong, but it doesn't do that!
11:49:12 <lambdabot>   "bca"
11:49:15 <tomberek> Berengal: running into issues with that trick for show,, can you clarify?
11:49:22 <Sternmull> mauke: when i have a lot of vectors, yes
11:49:29 <mreh> I was mildly bemused to see that
11:49:45 <int-e> oh, and then there's another "sequence", sequence' = foldl (liftM2 (flip (:))) (return []) . reverse
11:50:04 <Sternmull> mauke: especiylly when the size of the vector itself would be only 12, that would mean 200% memory overhead
11:50:18 <noggle> mm_freak: is that to me?
11:50:19 <mauke> Sternmull: I'd like to see you create a 12 byte vector in Haskell
11:50:33 <mm_freak> noggle: not directly, you just inspired me =)
11:50:42 <Sternmull> mauke: 3 elements of unboxed floats?
11:51:04 <Sternmull> mauke: at least thats what i want :)
11:51:22 <mauke> you need at least a type tag
11:51:56 <Sternmull> but haskell is statically typed, i would see the need for a type tag in lisp. but in haskell i expect to get rid of that.
11:51:59 <monochrom> I was not accurate enough. They are all expandible. But one syntax says "can GC the expansion", the other says "someone is still referring to the expansion".
11:52:08 <mauke> Sternmull: garbage collection
11:53:09 <noggle> mm_freak: cool
11:53:09 <Sternmull> mauke: But the GC could use static type information too. When i have a function that uses instances of compiletime known types it does not need runtime type information.
11:53:12 <noggle> data.maybe
11:53:23 <noggle> mm_freak: thanks for being inspired, I think this will help me
11:53:26 <noggle> lol
11:53:30 <mm_freak> when trying to 'cabal upgrade' something, i always get the following error:
11:53:31 <noggle> I suck at this language
11:53:31 <mm_freak> cabal: fromFlag NoFlag. Use fromFlagOrDefault
11:53:32 <Sternmull> mauke: at least no per instance data
11:53:37 <mm_freak> can anyone help me?
11:53:40 <mm_freak> noggle: you're welcome =)
11:53:59 <monochrom> If you compile, then even main itself does not need to be kept around (especially since no recursion back to main), so the expansion is not kept either.
11:55:08 <edwardk> sternmull: it turns out that that is quite a tricky thing to do, to reconstruct the type from just the information available from walking the stack to get to your location can turn out to take an unbounded amount of space in the presence of polymorphic recursion
11:55:30 <edwardk> sternmull: that space is needed at the worst possible time: during garbage collection
11:55:51 <Sternmull> hm
11:55:57 <int-e> and then there's the desire to distinguish thunks from evaluated data.
11:56:38 <edwardk> sternmull: so no implementation of haskell currently provides that functionality. there are implementations that turn to, say conservative GC ala the boehm collector.  JHC comes to mind in that regard, but even they deal with a tag and forwarding point rep.
11:56:51 <int-e> especially since you want to be able to update a thunk and have all people refering to it know that it was evaluated, without keeping track of the referers.
11:57:23 <edwardk> Sternmull: the best I've been able to do is use a 'don't stop the bibop' approach, and use a bump allocator with a tag, and then during GC move like tags into common pages and tag the page.
11:57:27 <Sternmull> edwardk: i really dont like conservative GC. Please dont treat random data as pointers :)
11:57:33 <edwardk> Sternmull: but the tag is still present, even if it is shared in that case
11:57:46 <edwardk> Sternmull: me neither. just pointing out what has been done ;)
11:57:48 <int-e> once you have a tag, you may just as well use it for GC as well. (which a compiler could only speed up by a constant factor at best, and you don't care because you can compensate that constant factor with a larger heap.)
11:57:54 <sepp2k> noggle: That's not the full definition of getTranslate, is it? The way it is in your pastie, you'd always get a non-exhaustive pattern match error
11:59:48 <edwardk> Sternmull:  that said, there are times when if you're already doing that GC using reconstructed information from the type of the continuation, where you can actually collect more garbage.
12:00:23 <edwardk> sternmull: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.1254
12:00:24 <mreh> can I get a stack trace with GHCi?
12:00:46 <edwardk> in a lazy setting a stack trace rarely means what you think it means ;)
12:01:04 <Berengal> In a lazy setting a stack trace usually means nothing
12:01:06 <monochrom> I still haven't used the ghci debugger.
12:01:11 <Cale> In fact, there might not even be a stack at all.
12:01:15 <mreh> monochrom: me neither
12:01:39 <mreh> okay, I can't work out why my prog wont work!!!! D:
12:01:47 <mreh> shall I wave my arms around and see what happens
12:02:00 <Berengal> mreh: That's my usual strategy. It's been surprisingly effective
12:02:02 <mreh> enter random mutations in the source code
12:02:03 <Twey> Sacrifice a goat or two
12:02:12 <Cale> GHC uses a stack, but it represents the case expressions which are waiting for their scrutinee to be sufficiently evaluated to be able to pattern match.
12:02:14 <Twey> Debug.Trace might be helpful
12:02:15 <monochrom> Let it sleep and heal itself.
12:02:18 <Berengal> Twey: Oh, yeah, the sacrifices might've helped
12:02:22 <Sternmull> ok, so memory usage will probably not be perfect. but i still dont understand why there are no functions to access tuples (or other compiletime structures with known size) by index
12:02:36 <Berengal> Sternmull: There are, but only for pairs
12:02:39 <Twey> Sternmull: That's not what tuples are for
12:02:39 <Berengal> fst and snd
12:02:40 <Sternmull> i hope i just dont know those functions yet
12:02:44 <mauke> Berengal: that's not by index
12:02:50 <Twey> ‘Tuple’ is not a type
12:02:51 <Berengal> mauke: Sure, first and second
12:02:54 <Sternmull> pairs are not enogth
12:02:55 <edwardk> sternmull: nah, they just don't exist.
12:03:08 <mreh> I'm going to try the debugger, Trace is all IO
12:03:13 <Twey> It's a convenient name we give to a sort of type
12:03:21 <edwardk> Sternmull: would take a bunch of instances, what do they do when you pass an index that is out of range? etc.
12:03:27 <Twey> mreh: Debug.Trace uses unsafePerformIO so you can insert it anywhere
12:03:44 <mreh> Twey: amaaaaaazing
12:03:56 <edwardk> Sternmull: they'd only work if you had the right type for the slot, so they'd only work for homogeneous k-tuples.
12:03:59 <noggle> sepp2k: actually I figured it out
12:03:59 <Twey> When the value gets evaluated, your message gets printed
12:04:00 <aavogt> @quote oasis
12:04:00 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
12:04:05 <edwardk> Sternmull: you could make
12:04:07 <Twey> Haha
12:04:09 <noggle> in a better way after mm_freak did the catMaybes thing
12:04:10 <noggle> t2 (x:xs) ciph = catMaybes (map (lookup x) [ciph]) : t2 xs ciph
12:04:15 <Sternmull> edwardk: out of range checks would be simple: the compiler knows the size so it can put conditions where needed and let them out where they are unnecessary.
12:04:39 <Twey> Took me two reads of that to realise that ‘desert’ and ‘oasis’ were not the way around I expected them to be
12:04:40 <noggle> catMaybes and lookup are a bit unclear but I am going to research them
12:04:49 <mreh> Twey: :D~~
12:05:10 <Twey> Nice goatee
12:05:20 * noggle is using the pythonchallenge to learn
12:05:31 <noggle> just, in haskell
12:05:32 <int-e> @index Array#
12:05:32 <lambdabot> bzzt
12:05:36 <edwardk> class Indexed c where type Elem c :: *; slot :: c -> Elem c; instance Indexed (a,a) where type Elem (a,a) = a; slot 0 = fst; slot 1 = snd; instance Indexed (a,a,a) where ...
12:06:03 <Sternmull> hm
12:06:08 <aavogt> noggle: catMaybes . map f == mapMaybe f
12:06:45 <edwardk> but note that this isn't haskell 98, you needed MPTCs or a type family. it also required you to make an non-haskell 98 instance head
12:06:56 <aavogt> it looks like   you can simplify that to    t2 (x:xs) ciph = lookup x ciph : t2 xs ciph
12:07:08 <int-e> Sternmull: It's not that the idea is not useful - but is it worth the added complexity when you already have arrays?
12:07:25 <aavogt> which makes t2 xs ciph = map (flip lookup ciph) xs
12:07:35 <edwardk> so you need FlexibleInstances as well
12:07:37 <Berengal> edwardk: That only holds same-typed values, at which point you might just as well use a list
12:07:49 <int-e> edwardk: now if the compiler were smart enough to turn that into a bounds check + pointer arithmetic :)
12:08:43 <aavogt> noggle: also, lookup is slow for longer lists... it might not be a problem here, but maybe some other time you should look into Data.Map
12:08:44 <edwardk> berengal: well, one argument is that you get away with only one thunk. a better case could be made for an array with fixed starting bound over a list
12:09:06 <edwardk> int-e: yeah. i'm sure mmorrow could come up with some magic ;)
12:09:09 <Berengal> edwardk: Okay then, I'll go with the array :P
12:09:20 <int-e> Sternmull: although with proper packaging it's actually not that bad - one more primop, and the rest can be done in a library along edwardk's sketch.
12:09:43 <int-e> edwardk: yes, technically the primop I just invented can be built with existing primops.
12:09:58 <edwardk> Sternmull: if it makes you feel better that is basically the approach i'm taking for arrays in my little toy compiler ;)
12:10:07 <Sternmull> int-e: its just that i a so used to data types in C. And it is really strange to me that languages as haskell and lisp dont have equivalents. I dont see why they dont offer "compact vectors". Its nothing that conflicts with a functional style. And i dont think its would be difficult for the GC. I think C# has such stuff with its struct-like things.
12:10:16 <mreh> lazyness is like keeping a pet bear, one day it will pull your head off
12:11:29 <Berengal> Sternmull: IIRC C# also has a fixed overhead for each object allocated
12:11:30 <chrisdone> hehe check this http://chrisdone.com/TryHaskell_1267128626936.png a wiggly worm
12:12:27 <noggle> aavogt: okay I will check that you
12:12:30 <noggle> err
12:12:42 <noggle> s/you/out/
12:12:47 <sinelaw> :)
12:12:58 <sinelaw> i didn't know try haskell had graphics
12:13:27 <edwardk> sinelaw: it does?
12:13:50 <sinelaw> edwardk, look at chrisdone 's link
12:13:52 <chrisdone> sinelaw: I'm messing about with adding Raphael support. seems to work ok ish
12:13:58 <edwardk> hah
12:14:06 <sinelaw> chrisdone, that's a nice idea
12:14:08 <Twey> chrisdone: sequence . map = mapM
12:14:14 <chrisdone> Twey: I know ;)
12:14:14 <Twey> chrisdone: Cool idea, though ☺
12:14:43 <noggle> catMaybes . map f == mapMaybe f
12:14:48 <noggle> how does that even work?
12:14:49 <noggle> haha
12:14:59 <BONUS> (sequence .) . map
12:15:09 <monochrom> UArray i Int and STUArray i Int are compact vectors. «data MyStruct = Mine !Int !Bool !Double» plus "-funbox-strict-fields" is your compact struct. There are also Int#, Bool#, Double# if you're really paranoid.
12:15:09 <Twey> Ah, aye
12:15:13 <chrisdone> http://kiboki.net/haskell/tryhaskell-raphael/
12:15:16 <chrisdone> try it if you like
12:15:25 <chrisdone> only supports the circle action at the moment. circle x y radius
12:16:15 <Berengal> chrisdone: Do you have a suggestion-box?
12:16:18 <edwardk> ah
12:16:24 <edwardk> ok, so its not the main tryhaskell link.
12:16:33 <edwardk> i was weirded out for a second, coz it wasn't working for me =)
12:17:04 <chrisdone> Berengal: I'm looking at tutorials now for an interactive tutorial
12:17:06 <Berengal> I got a circle, but it was text-only...
12:17:21 <chrisdone> Berengal: text only? :o
12:17:34 <Berengal> circle 5 0 2 => new $1 circle 5.0 0.0 2.0
12:17:48 <Berengal> That kind of text
12:18:04 <Berengal> Also, what kind of interactive?
12:18:13 <chrisdone> Berengal: that's weird. what browser?
12:18:20 <Berengal> chromium
12:18:23 <chrisdone> Berengal: like try ruby
12:18:52 <edwardk> berengal: you were doing that on eht main tryhaskell site not the link he gave
12:18:55 <chrisdone> hmm circle works fine here on cromium
12:18:57 <mm_freak> Sternmull: note that in haskell you generally don't care about the implementation details of a datatype…  for virtually all applications you're going to write, memory is abstracted away completely
12:19:21 <chrisdone> edwardk: ahh, good call
12:19:35 <mm_freak> Sternmull: if you need compact vectors use unboxed arrays
12:19:35 <Berengal> edwardk: Yes I was
12:19:39 <chrisdone> yeah, this version picks up the Graphics.Raphael.Raphael type and renders it rather than displaying it
12:20:15 <nlogax> chrisdone: when you have entered enough stuff for it to start scrolling, it gets weird and scrolls up in safari, when you type. because the secret input is up there i guuess.
12:20:28 <Berengal> chrisdone: Do you gather up suggested improvements anywhere, or should I just yell at you until you implement it?
12:20:42 <noggle> I see why lookup requires catMaybe
12:20:54 <noggle> I was wonder how to just get the value from a maybe yesterday
12:20:59 <noggle> this is great info mm_freak
12:21:00 <chrisdone> nlogax: errmmm I fixed this bug, let me check it's up to date
12:21:02 <noggle> really appreciated
12:21:17 <mm_freak> noggle: note that the catMaybes version is not that safe
12:21:33 <mm_freak> errors (i.e. characters not in the permutation table) are silently ignored
12:21:40 <chrisdone> Berengal: don't really have a place. maybe a page on the wiki? I could get a uservoice account
12:21:55 <mm_freak> > let encrypt pt = sequence . map (`lookup` pt) in encrypt [('a','b'), ('b', 'c'), ('c', 'a')] "abc"
12:21:56 <lambdabot>   Just "bca"
12:21:58 <edwardk> you can of course make a generalized fromMaybe that does something like fromMaybe Nothing = mzero; fromMaybe (Just a) = return a -- which works for an arbitrary MonadPlus instance.
12:22:01 <mm_freak> > let encrypt pt = sequence . map (`lookup` pt) in encrypt [('a','b'), ('b', 'c'), ('c', 'a')] "abcd"
12:22:02 <lambdabot>   Nothing
12:22:04 <chrisdone> or a blog?
12:22:09 <mm_freak> that's better than catMaybes
12:22:19 <chrisdone> I don't know what's the usual way to
12:22:29 <Berengal> chrisdone: I'll just yell at you until you go do that then. Make unshowable types print a little better, like e.g. just the type.
12:22:30 <monochrom> the usual way is email.
12:22:44 <edwardk> or you could be evil and use fromMaybe Nothing = fail "Nothing" -- and you can then make it work for an arbitrary Monad a la Haskell 98, since they bolted in that silly "fail" method.
12:22:48 <Berengal> chrisdone: Especially since you can't ask for the type of a function
12:23:03 <edwardk> but then if you run it in Identity lookup failure is a hard error.
12:23:11 <ksf> I don't know what, but something's in the implementation of type families is fishy
12:23:41 <Berengal> ksf: This is the point where I ask "What?", despite your disclaimer.
12:23:41 <copumpkin> RayNbow: I was talking about graphviz :P
12:23:48 <chrisdone> Berengal: I intend on doing :t, but also agree printing unprintable types nicely is a good idea
12:23:54 <ksf> ...depending on how I write equivalent code of the same type, it's failing or not failing to infer the type
12:24:09 <mm_freak> noggle: 'sequence' takes a list of Maybe values and converts into Just a list of values or Nothing, if it happens to contain a Nothing
12:24:22 <mm_freak> > sequence [Just 1, Just 2, Just 3]
12:24:23 <lambdabot>   Just [1,2,3]
12:24:25 <mm_freak> > sequence [Just 1, Just 2, Just 3, Nothing]
12:24:26 <lambdabot>   Nothing
12:24:33 <ksf> I wouldn't be complaining if those were real type errors, but with a type sig, things work
12:24:57 <MoALTz> > map Just [1..10]
12:24:58 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
12:25:02 <Berengal> ksf: Does the type sig require fancypants equalities and such?
12:25:06 <monochrom> polymorphic recursion also causes that phenomenon.
12:25:09 <ksf> not at all
12:25:28 <noggle> >sequence $ map Just [1..10]
12:25:38 <noggle> no work
12:25:41 <noggle> > sequence $ map Just [1..10]
12:25:42 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
12:25:46 <nlogax> chrisdone: oh, it's fixed on tryhaskell.org :)
12:25:48 <chrisdone> nlogax: http://tryhaskell.org/ did that do the trick?
12:25:49 <sinelaw> What's the fastest way to wrap bind to C functions?
12:25:49 <copumpkin> > mapM Just [1..10]
12:25:50 <lambdabot>   Just [1,2,3,4,5,6,7,8,9,10]
12:25:52 <chrisdone> nlogax: haha, you're quick
12:25:54 <noggle> ohhh
12:25:56 <nlogax> chrisdone: :D
12:25:57 <chrisdone> I literally just changed it
12:26:12 <noggle> mm_freak: when you say unsafe what do you mean? typesafe?
12:26:19 <chrisdone> nlogax: fixed the raphael one too
12:26:31 <mm_freak> noggle: it's not "unsafe" really, but rather incorrect
12:26:50 <mm_freak> you have a permutation table, which may not cover the entire set of possible characters
12:26:58 <nlogax> chrisdone: excellent. any plans for built in excercises like the ruby one?
12:27:04 <nlogax> that would be fun
12:27:06 <mm_freak> if the plaintext contains a character missing in the permutation table, then the function should fail
12:27:07 <noggle> like ','
12:27:08 <Berengal> chrisdone: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23002#a23002
12:27:14 <noggle> I see
12:27:15 <chrisdone> nlogax: yep, that was my plan from the start
12:27:20 <Berengal> chrisdone: I did a double-tap on return there, by the way
12:27:29 <mm_freak> the proper way to encode a failable function (without a specific error type) is using Maybe
12:27:42 <mm_freak> encrypt :: [(Char, Char)] -> String -> Maybe String
12:27:53 <noggle> ahh I see
12:28:02 <kakeman> what is this $= ?
12:28:08 <mm_freak> the catMaybes version has the result type String, not Maybe String
12:28:13 <sinelaw> how awful is the following idea: a monad interface for programming imperatively+basic OOP in haskell that, when executed produces code in one of several imperative languages? (C# and JavaScript for a start)
12:28:20 <chrisdone> Berengal: hmm seen that bug before. just needs to ignore key presses until the remote has responded, hang on
12:28:21 <mm_freak> if there is an invalid character, it just drops that character entirely
12:28:23 <mm_freak> and silently
12:28:26 * ksf feels kinda silly uploading gazillions of 0,0 1,0 0,1 1,1 -trianglestrips to the gpu
12:28:43 <sinelaw> And, you'll have a way to specify where the serialization border crosses
12:28:53 <noggle> so if the second arg to encrypt has a character not in the lookup table then then there is nothing that is shown
12:28:57 <medfly> sorry, got distracted
12:29:02 <Berengal> I wish people would use partial/not total for partial function, not "unsafe". "unsafe" means it breaks the semantics in my mind
12:29:24 <ksf> sinelaw, you might start by looking at the awesome prelude
12:29:34 <Cale> Berengal: I agree
12:29:39 <sinelaw> ksf, hah?
12:29:45 <mm_freak> > let encrypt pt = catMaybes . map (`lookup` pt) in encrypt [('a','b'), ('b', 'c'), ('c', 'a')] "xyaffbcdef"
12:29:46 <lambdabot>   "bca"
12:29:50 <copumpkin> Berengal: error "oi" fits the semantics?
12:29:54 <medfly> hi sinelaw
12:29:57 <ksf> ...you can write one function and treat it as either haskell or javascript
12:30:00 <mm_freak> whereas using sequence:
12:30:02 <sinelaw> hey medfly
12:30:05 <Berengal> copumpkin: Yep. The semantics contain bottom
12:30:06 <mm_freak> > let encrypt pt = sequence . map (`lookup` pt) in encrypt [('a','b'), ('b', 'c'), ('c', 'a')] "xyaffbcdef"
12:30:07 <lambdabot>   Nothing
12:30:13 <ksf> everything is parametrized by language, that is.
12:30:24 <sinelaw> ksf, to little information, parse failed.
12:30:25 <copumpkin> Berengal: I think that's a copout :P
12:30:37 <chrisdone> Berengal: refresh tryhaskell.org, does the double tap bug still occur?
12:30:41 <noggle> ahh I see
12:30:45 <mm_freak> catMaybes can be read as "ignore errors"
12:30:46 <Cale> An unsafe array index isn't one which checks the bounds and throws an exception, it's one which reads off the end of the array and gives you garbage or a segfault when you use an invalid index.
12:30:54 <mm_freak> sequence can be read as "either all or nothing"
12:31:02 <ksf> sinelaw, http://tom.lokhorst.eu/2010/02/awesomeprelude-presentation-video
12:31:14 <Berengal> chrisdone: Got submitted twice now. It's a bit hard to gauge what's happening with the timeouts though
12:32:01 <sinelaw> ksf, oh ok looks nice
12:32:33 <ksf> iirc they didn't do monads, yet
12:32:50 <tomberek> how can I set it so that doubles are printed rounded to .. say 5 significant digits vice the ~20 it is now?
12:33:07 <noggle> I see
12:33:12 <ksf> ...but you can just do the world-passing thing and then throw away the world when you're generating code
12:33:41 <Phyx-> I don't get something, why does f1 allocate more memory than f2, I would expect the opposite
12:34:01 <chrisdone> Berengal: now can you double tap? :P
12:34:03 <ksf> because f1 does the work f2 defines?
12:34:11 <chrisdone> Berengal: I think I'll hookup to a proxy to test this latency
12:34:23 <ksf> tomberek,
12:34:33 <ksf> > showFFloat (Just 5) (1/3) ""
12:34:34 <lambdabot>   "0.33333"
12:34:41 <tomberek> ksf: oooh!, thanks
12:35:13 <Berengal> chrisdone: Still submits twice
12:35:18 <sinelaw> ksf, i thought of doing a world-passing monad thing (just accumulates statements), that at runtime is simply translated to one of several syntaxes
12:35:22 <Berengal> I don't think it's such a big problem though
12:35:28 <sinelaw> ksf, as a simplistic thing
12:35:42 <ksf> well you want the same code to run as haskell, too.
12:36:11 <ksf> as switching language backends without touching the code is kinda what the awesome prelude is about
12:36:26 <sinelaw> ksf, yes I see. Maybe I could use that.
12:37:03 <sinelaw> I'm about to waste ages of time at work because i have to write ajax stuff, which basically means death by suffocation
12:37:20 <Berengal> ksf: That for that link. I've been thinking about trying to get one of our XML-based f*ck-ugly DSL-ish things at work into haskell, to make writing it much easier, and possibly even write an evaluator or two for changing backends, and this is very relevant
12:37:25 <Berengal> Thanks*
12:37:28 <sinelaw> ksf, i'd rather write it all in one typed language, embedded in haskell
12:37:32 <sinelaw> Berengal, so am I :)
12:37:55 <sinelaw> Berengal, if you work on it, let me know
12:38:20 <Berengal> In the end, I could see an XML-backend, a webpage backend, a distributed computing backend...
12:38:31 <sinelaw> Berengal, exactly!
12:38:38 <mreh> what does "backend" mean here?
12:38:59 <Berengal> sinelaw: Sounds like we're very much in the same boat here. I hope your DSL's not as half-assed as mine is...
12:39:23 <sinelaw> Berengal, what i'd like is to also be able to specify a "serialization border", so that stuff on one side goes into one language, the other maybe into another, and the data is automatically communicated somehow between them
12:39:43 <sinelaw> Berengal, it's definitely not half-assed, because it doesn't even exist.
12:39:46 <sinelaw> just an idea.
12:39:50 <sinelaw> a full-assed idea :)
12:40:06 <mreh> zero assed
12:41:25 <sinelaw> Berengal, collaboration?
12:41:53 <Berengal> sinelaw: I'd love to. I do have a DSL though, except the ones who made it didn't know what a DSL was until I told them
12:42:09 <Berengal> And now I'm trying to force it into Haskell somehow
12:42:24 <sinelaw> ah, maybe starting from scratch will be easier?
12:42:30 <sinelaw> what does the DSL support?
12:43:12 <Berengal> Right now? NullPointerExceptions, infinite loops, sometimes a webpage, and if you're really lucky, it orders you a DSL (digital subscriber line)
12:44:02 <Phyx-> when you do say, length [1..100] i would expect a closure to be constructed for [1..100] and that gets passed to length right, but does length after evaluating it, update the closure? or is it smart enough to see that it doesn't need to?
12:44:12 <sinelaw> Berengal, so it's not a generic restricted imperative language DSL
12:44:14 <sinelaw> ?
12:44:32 <Berengal> It's basically just a bunch of XMLs nobody knows how work, with a distributed "enterprise java" interpreter nobody knows how to build, with a data model nobody knows who made
12:44:52 <sinelaw> oh
12:44:53 <sinelaw> my
12:44:53 <Berengal> sinelaw: So, no. I'd like to work on something like that though
12:45:07 <sinelaw> Berengal, the first step would be to define the semantics we want to support.
12:45:32 <sinelaw> i think mutable objects with properties, javascript-style, is enough
12:45:48 <sinelaw> objects with properties and a few basic types + lists
12:45:56 * Phyx- taps the mic, is this thing on
12:46:28 <sinelaw> Phyx-, wish I knew what you were talking about
12:46:31 <Berengal> sinelaw: Do we want distributivity?
12:46:33 <monochrom> not loud enough
12:46:34 <sinelaw> Phyx-, but maybe others do
12:46:37 <edwardk> phyx: that closure gets updated, it may take a lot of work to determine the fact that there is or isn't a next item in the list, so length forces the 'spine' of the list all the way to the end, it doesn't compute each value in the list, those are still left as thunks off the spine, but the spine itself is evaluated
12:46:50 <sinelaw> Berengal, care to elaborate?
12:47:18 <pastorn> i could use some pointers here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23003#a23003
12:47:27 <sinelaw> void *
12:47:37 <sinelaw> (void *)(0xDEADBEEF) even
12:47:39 <pastorn> i don't want the whole sollution, just some help to get the ball rolling on >>=
12:47:49 <Berengal> sinelaw: I assume one of the points is the ability to run code on different environments on different machines, like e.g. a client-browser with a javascript interpreter and a server with the ability to run native code
12:48:12 <sinelaw> Berengal, right.
12:48:36 <Phyx-> edwardk: That's what i thougth, but then I don't know why let xs = [1..100] in if length xs > 0 then head xs else 0 is slower than if length [1..100] > 0 then head [1..100] else 0. I would expect the opposite to be true
12:48:37 <sinelaw> so there should be some way in the semantics to specify what i called "serialization borders"
12:48:55 <sinelaw> maybe a better name can be found, and a more precise definition of what we want to happen
12:49:09 <Phyx-> edwardk: I don't understand why the first one ends up allocating more memory than the second
12:49:29 <Berengal> sinelaw: Ur has something like this...
12:49:33 <MissPiggy> pastorn http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23003#a23004
12:49:40 <edwardk> Phyx-: length [1..10000] becomes a thunk <length [1..10000]> which when forced evaluates something like case [1..10000] of (_:xs) -> 1 + length xs; [] -> 0, which forces the head of [1..10000], etc.
12:49:52 <sinelaw> base 4.2 is for ghc-6.12?
12:49:52 <edwardk> phyx: the latter can be evaluated in constant space
12:49:58 <pastorn> MissPiggy: :: b -> r
12:50:00 <pastorn> ok...
12:50:02 <sinelaw> Berengal, Ur?
12:50:05 <MissPiggy> ?
12:50:20 <pastorn> MissPiggy: but where do i get the 'a' from?
12:50:26 <Berengal> sinelaw: http://www.impredicative.com/ur/
12:50:30 <MissPiggy> not sure what you are asking
12:50:31 <edwardk> phyx: once you get done looking at the front of the list, you can throw it away (presuming list fusion, etc. hasn't prevented it from ever being built at all)
12:50:33 <pastorn> i have to do k before mx, right?
12:50:38 <MissPiggy> there is no 'do'
12:50:48 <pastorn> "compute", then
12:50:52 <Berengal> sinelaw: It looks pretty interesting. If you want this for web development, perhaps that's worth a look
12:51:07 <MissPiggy> pastorn, just try to implement the type
12:51:10 <MissPiggy>  -- mx :: (a -> r) -> r -- k :: a -> ((b -> r) -> r) -- br :: b -> r
12:51:16 <MissPiggy> this is what you HAVE
12:51:22 <MissPiggy> and you need to make an r
12:51:24 <sinelaw> Berengal, thanks for the link
12:51:28 <edwardk> phyx: but in the former case you mentioned, there is still a reference to x, so the list can't be discarded. so while you run length, you're building up a huge chain of thunks that can't be GC'd until you get around to taking the head later.
12:51:43 <pastorn> MissPiggy: i am...
12:51:54 <Berengal> sinelaw: The ajaxy stuff looks awesome, and it two FFI's, one for C and one for javascript
12:51:55 <edwardk> er still a reference to xs.
12:51:58 <MissPiggy> without considing execution order or anything like that
12:52:08 <MissPiggy> just implement it based on the structure of the types
12:52:26 <edwardk> phyx: try something that doesn't force the whole list: let xs = [1..100] in if null xs then 0 else head xs
12:52:38 <edwardk> phyx: that is even more correct, because it handles the infinite list case
12:52:52 <tafryn> Is there a haskell implementation of lex?
12:52:58 <edwardk> tafryn: "alex"
12:53:01 <monochrom> pastorn: You can use br and k to write a function of type a->r
12:53:19 <tafryn> edwardk: Thanks.
12:53:34 <Phyx-> ah, edwardk so basically in the former example the values of xs are forced while in the latter only the spine is forced?
12:53:52 <sinelaw> Berengal, are you using that? or did you just discover it
12:53:57 <pastorn> it's pretty amazing that someone actually came up with this madness to begin with...
12:53:58 <sinelaw> or did you decide not to use it
12:54:01 <Phyx-> edwardk: and the values of xs are stored, for later use by head
12:54:36 <pastorn> OOOOOOOOOOOOOOOOOOOH
12:54:54 <pastorn> the (a -> ...) in k is the pattern i want my mx to take
12:55:15 <Phyx-> edwardk: and so, the version with xs generates alot more thunks along the way to storing them than the former. is that correct?
12:55:15 <edwardk> no, in the former example the spine is forced, but the compiler must also keep the whole spine because there is still a dangling reference to it to support taking the head later. in the latter case, CSE doesn't happen, you have two lists, each of which has one reference, and as it goes, it can either gc the beginning of the list, or if you have enough optimizations on, it can use stream fusion, or use a bit of STG magic to figure
12:55:40 <edwardk> thunk to which it holds the only reference, so no update need occur, in either case, the list gets generated 'separately' for the head call.
12:55:51 <Phyx-> ah
12:56:05 <monochrom> pastorn: Given millions of years, someone is bound to come up with this madness :)
12:56:09 <Phyx-> so it's the update call that's slow? and the accessing of the value later on
12:57:51 <edwardk> phyx: its the fact that in the let xs = .. case you build a big structure that looks like Cons <thunk> (Cons <thunk> (Cons <thunk> (Cons <thunk> ....) so ten thousand updates are made and twenty thousand thunks are allocated. in the latter case, the compiler can probably figure out that no allocation is needed to answer the question of length [1..10000] because it can solve it in a loop with no actual allocation, as long as no on
12:58:04 <olsner> pastorn: which madness is that?
12:58:17 <Phyx-> edwardk: aaaaahhhhh
12:58:35 <Phyx-> edwardk: ofcourse, thanks
12:59:10 <edwardk> the latter case becomes a very tight loop that counts to 10000 and adds 1 each time, possibly with a pause to check for the need for gc in each iteration, but overall it is far less painful
12:59:22 <pastorn> AMAGAD I DID IT!
12:59:33 <pastorn> olsner: the continuation monad
12:59:33 <monochrom> olsner: implementing >>= for Cont
12:59:40 <Phyx-> edwardk: yeah, and the former it has to keep dereferencing pointers to get to the next element, I get it now, cool thanks
12:59:43 <pastorn> olsner: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23003#a23004
12:59:55 <Berengal> sinelaw: I didn't bother trying it yet, but it's on my todo list.
13:00:07 <Berengal> sinelaw: It does look very promising though
13:00:13 <FliPPeh_> Is using dynamic linking with GHC 6.12 a bad idea at the moment? Or will it be a bad idea forever?
13:00:20 <sinelaw> it looks a little risky
13:00:20 <olsner> woah, look at the type of that! the mind boggles
13:00:28 <sinelaw> if it's not mature enough
13:00:34 <monochrom> see? it's madness. isn't haskell exciting?
13:00:40 <sinelaw> i'd rather use something i understand completely
13:01:00 <edwardk> phyx: and of course, the compiler isn't smart enough to know that the only dangling reference to xs cares only about the thunk at the head of the list. that 'collecting more garbage' paper i linked to above talks about a way that you could at least gc the allocated cells that can't be reached based on some info about the continuation, but that collector is slow.
13:01:01 <Berengal> Yeah, it's not mature, but the guy's been calling out for testers lately
13:01:11 <MissPiggy> I wish I had your enthusiasm monocrhom
13:01:11 <olsner> monochrom: yeah, mad is awesome :)
13:01:14 <pastorn> @pl \mx k br -> mx (\a -> k a br)
13:01:14 <lambdabot> (. flip) . (.)
13:01:19 <pastorn> HAHAHAHHAHAHAHA
13:01:32 <MissPiggy> HAHAHAHHAHAHAHA!
13:01:37 <monochrom> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
13:01:37 <lambdabot> f a b c = a (\ d -> b d c)
13:01:41 <aavogt> it's pleasantly surprising that TupE [a] == a
13:01:45 <pastorn> wtf?!?!?!?!?!
13:01:48 <monochrom> In fact...
13:01:50 <olsner> @ty fmap (flip fmap flip) fmap
13:01:51 <lambdabot> forall (f :: * -> *) a b b1. (Functor f) => (f b -> b1) -> f (a -> b) -> a -> b1
13:01:58 <monochrom> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
13:01:58 <lambdabot> f a b =
13:01:58 <lambdabot>     case a of
13:01:58 <lambdabot>     Cont c -> Cont (\ d ->
13:01:58 <lambdabot>                     c (\ e ->
13:01:58 <lambdabot>                        case b e of
13:02:00 <lambdabot>                        Cont f -> f d))
13:02:00 <MissPiggy> yes programming is no longer a human activity, the computers have taken over
13:02:30 <Twey> @djinn (Functor f) => (f b -> b1) -> f (a -> b) -> a -> b1
13:02:30 <lambdabot> Error: Class not found: Functor
13:02:30 <edwardk> pastorn: djinn is smart enough to figure out the bind of the call-by-need continuation passing style monad.
13:02:35 <Twey> Aw.
13:02:50 <Phyx-> edwardk: yeah, I was wondering about that just now. If it would store information about the argument usage of the calls, and possible look at the entire function to determine how much of the variable it actually needs to keep around, but that might be tricky
13:03:01 * hackagebot upload: TV 0.4.5 - Tangible Values -- composable interfaces (ConalElliott)
13:03:29 <pastorn> now to implement callCC...
13:03:30 <monochrom> I didn't use djinn because you requested no spoiling. OTOH, I saw yesterday that someone did @djinn-add Cont something, so I know it knows Cont.
13:03:41 <edwardk> phyx: it turns out that figuring out the unification needed to actually do that takes a potentially large amount of space at precisely the wrong time, in the presence of polymorphic recursion.
13:04:12 <edwardk> phyx: but for an ML-like language rather than a haskell-like language it is fine
13:05:02 * hackagebot upload: TypeCompose 0.6.8 - Type composition classes & instances (ConalElliott)
13:05:17 <sinelaw> conal is productive!
13:05:35 <olsner> you can have alot of fun just rewriting expressions with (.) in terms of fmap and flip
13:06:08 <sinelaw> we can have lot's of good fun if you wish / with a game that I call up-up-up with a fish
13:06:29 <MissPiggy> I wish I wsa a fish
13:06:32 <Phyx-> edwardk: ah cool. Thanks, I really couldn't figure out what was going on, even after looking at the core code. I completely forgot how it stores values
13:07:32 <edwardk> phyx: if you look at the generated STG you'll probably see something like the case with two lists generating STG nodes that know not to update
13:08:00 <olsner> oh, is there a @djinn-add! what can you add? custom data types? type aliases? type classes?
13:08:12 <edwardk> olsner: yes, i think so, and yes
13:08:14 <edwardk> @djinn-env
13:08:14 <lambdabot> data () = ()
13:08:14 <lambdabot> data Either a b = Left a | Right b
13:08:14 <lambdabot> data Maybe a = Nothing | Just a
13:08:14 <lambdabot> data Bool = False | True
13:08:14 <lambdabot> data Void
13:08:16 <lambdabot> type Not x = x -> Void
13:08:18 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
13:08:20 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:08:22 <lambdabot> data Cont o a = Cont ((a -> o) -> o)
13:08:24 <lambdabot> data A x = AA (x, x)
13:08:46 <edwardk> @djinn Not (Not (Not a)) -> Not a
13:08:46 <lambdabot> f a b = void (a (\ c -> c b))
13:08:55 <olsner> ah, nice, didn't know djinn could do type classes at all
13:08:58 <edwardk> @djinn Not (Not a) -> a
13:08:58 <lambdabot> -- f cannot be realized.
13:09:11 <olsner> I always assumed it was a matter of power rather than knowledge
13:09:14 <MissPiggy> I don't think it really does typeclasses
13:09:20 <MissPiggy> it just sort of fakes it doesn't it?
13:09:25 <edwardk> it has very very limited support for typeclasses.
13:10:08 <Phyx-> edwardk: right, I was almost going to look at the C-- code if I didn't get the answer here.
13:10:36 <edwardk> phyx: STG should be the first place where it can talk about what doesn't get updated
13:12:02 <tomberek> when you add a context to an instance declaration, what's the right way to do this? instance (Show a,Show b) =>...
13:12:16 <pastorn> how many arguments do you usually give to callCC? One?
13:12:17 <Phyx-> edwardk: yeah, I forgot about it for a bit :)
13:12:23 <edwardk> instance (Show a, Show b) => Show (Foo a b) where ...
13:12:31 <edwardk> @type callCC
13:12:32 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
13:12:34 <tomberek> there's some way to say, both a and b are Show
13:12:37 <mm_freak> SPJ and greg morrisett proposed syntax and semantics for extensible records, which sound really great…  exactly what i was looking for, but unfortunately incompatible with the current record system
13:12:44 <mm_freak> it's here:  http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
13:12:53 <mm_freak> any chance to see this implemented in the near future?
13:13:02 <tomberek> edwardk: there's no (Show a,b) or somehting?
13:13:25 <edwardk> tomberek, nah, that wouldn't parse
13:13:45 <edwardk> tomberek: the , binds more loosely than the juxtaposition of Show and 'a'
13:14:01 <tomberek> edwardk: yes, i know that.. but i remember there was some way to provide a list of type variables to a contstraint
13:14:12 <tomberek> i just forgot it, can't find it
13:14:35 <edwardk> tomberek: fraid not. instance (Foo a b, Bar b c) => ... works but that passes two arguments to each MPTC
13:14:47 <tomberek> ok
13:15:30 <edwardk> the problem is instance (Show a, b) may not have a valid parse, but generalizing that should allow instance (Show a, Foo b) -- but is that intended to expand to instance (Show a, Show (Foo b)) -- or look for an instance of Foo for b?
13:15:56 <copumpkin> :O
13:16:18 <FliPPeh_> Hmm!
13:16:21 <Cale> I don't really care much for that proposal. I think the syntax is terrible, and the semantics could be nicer.
13:16:23 <FliPPeh_> My MPD libary is almost complete
13:16:29 <edwardk> cale: that was my point =)
13:16:30 <FliPPeh_> At least it works better than the one on hackage
13:16:49 <edwardk> cale: oh you mean the record prpoposal?
13:16:52 <tomberek> edwardk : ok
13:16:52 <Cale> yes
13:17:02 <Cale> (the record proposal)
13:17:37 <Cale> Using . for record field selection is just a terrible idea.
13:17:55 <mm_freak> Cale: but you'll agree that the current record system couldn't be worse
13:18:00 <edwardk> cale: i'm fond of it, personally, but we've been around this block before ;)
13:18:06 <Cale> It could be worse, actually
13:18:14 <MaciejP> @hoogle  Monad m => m (a -> b) -> a -> m b
13:18:14 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:18:15 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
13:18:15 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:18:15 <Cale> Though I don't think of it as a record system.
13:18:47 <c_wraith> we could use -> as the field selector syntax!  that wouldn't cause more problems at all
13:18:50 <mm_freak> sure…  it just saves you from having to define accessor functions yourself
13:19:03 <mm_freak> i think the dot syntax is ok
13:19:09 <pastorn> @type (>>= (return .))
13:19:10 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Functor m, Monad m) => m (m a) -> m (m1 a)
13:19:11 <Cale> It's just some extra sugar for algebraic types
13:19:15 <mm_freak> we're using it for qualified names, too, after all
13:19:21 <olsner> one thing I like with the current record system is that accessors are actually plain functions
13:19:29 <Cale> I wouldn't use . for qualified names either, if I could help it.
13:19:39 <olsner> you don't really need any syntax for record access at all
13:19:43 <mm_freak> yeah, but that's how things are currently =)
13:19:47 <Cale> I *hate* using qualified names for the very reason that the separator is .
13:19:57 <Cale> So I avoid importing things qualified as far as I can manage.
13:20:12 <mm_freak> olsner: i just see how nice and concise the record/struct syntax of common OOP languages is
13:20:16 <copumpkin> Cale: what would you prefer as a separator?
13:20:25 <Cale> copumpkin: | wouldn't be a bad choice, I think
13:20:28 <copumpkin> I quite like . as separator, but then we should use \cdot as composition :P
13:20:44 <Cale> Data|List|permutations
13:20:50 <copumpkin> not very legible
13:20:56 <Cale> hm?
13:20:56 <edwardk> Cale: foo | Bar|Baz|quux == quaffle = ... is pretty horrible ;)
13:21:01 <mm_freak> i find that very unreadable, Cale
13:21:11 <olsner> what did PHP use for qualification again, backslash?
13:21:16 <mm_freak> | looks like lowercase L and uppercase i
13:21:25 <copumpkin> | sort of looks like an l
13:21:26 <aavogt> Data_List_permutations... who uses underscores anyways?
13:21:29 <mm_freak> most languages use colons, which i could live with
13:21:35 <mm_freak> but they are already reserved for lists
13:21:39 <Cale> | shouldn't look like l in any font which you program with.
13:21:42 <edwardk> mm_freak: colon is a bit overloaded in haskell ;)
13:21:53 <mm_freak> Cale: i still find it ugly…  the dot is cleaner, IMO
13:21:55 <copumpkin> I stil propose . for qualification and \cdot for composition
13:22:04 <Cale> If 1,l,and | look similar, you're using the wrong font :)
13:22:04 <copumpkin> :P
13:22:18 <mm_freak> it's unfortunate that it clashes with (.), but well, we always lived with it and i never found that annoying =)
13:22:19 <Cale> \cdot isn't something you can easily type
13:22:28 <copumpkin> Cale: with the correct input method it is
13:22:31 <Cale> Even with an input method that lets you type it.
13:22:33 <copumpkin> in agda it's pretty trivial :)
13:22:37 <quicksilver> if you actually want it to look nice, I think the solution is better typography or syntax highlighting
13:22:37 <olsner> backslash-see-dot is a bit long to pronounce too :P
13:22:43 <mm_freak> Cale: that's not the point anyway
13:22:55 <quicksilver> permutations_{\small Data List} would look OK
13:22:57 <Cale> Composition is the most common infix operator in essentially every piece of code that I write anyway
13:23:09 <nbowler> Cale: clearly the solution is to sell keyboards designed specifically for Haskell programmers :)
13:23:10 <Cale> So it should have the preferential syntax
13:23:22 <copumpkin> yeah, take the APL approach
13:23:28 <mm_freak> either use a character that expresses hierarchy or use a character that is clearly nonalphanumeric
13:23:33 * copumpkin makes a startup for specialized keyboards
13:23:40 <mm_freak> an arrow would be ok
13:23:40 <copumpkin> for haskell
13:23:46 <tomberek> tilde
13:23:48 <mm_freak> Data->List->permutations
13:23:53 <Alpounet> I want a lambda on my kb
13:23:59 <mm_freak> i have one
13:24:00 <mm_freak> λ
13:24:04 <copumpkin> aren't you cool
13:24:05 <Cale> mm_freak: I agree about using an arrow. That would be fine.
13:24:06 <nbowler> copumpkin: I see no way in which your business can fail!
13:24:15 <copumpkin> nbowler: sweet! VC from you then?
13:24:19 <c_wraith> Get one of those fancy keyboards with programmable key caps.
13:24:23 <twanvl_> f :: Data->Int -> Data->Int
13:24:26 <quicksilver> perl used to use `
13:24:27 <mm_freak> Cale: and i would also agree about arrows for accessors
13:24:34 <mauke> quicksilver: no, '
13:24:37 <copumpkin> twanvl_: awesome!
13:24:38 <mauke> and that still works
13:24:40 <quicksilver> mauke: ah, thank you
13:24:41 <mm_freak> but anyway, i'm fine with accessors as functions
13:24:50 <quicksilver> mauke: I like it because it's physically lightweight
13:24:51 <mauke> hence Acme::Don't
13:24:52 <Cale> Heh, yeah, except that -> looks optimally horrible in types
13:24:53 <quicksilver> like .
13:24:57 <mauke> which is really Acme::Don::t
13:25:16 <mm_freak> Cale: how about a backslash?
13:25:21 <Cale> Could we perhaps use a prefix notation?
13:25:21 <mm_freak> windows path style =)
13:25:28 <Cale> hmm
13:25:32 <Cale> that might piss people off ;)
13:25:39 <copumpkin> everything will piss me off
13:25:41 <copumpkin> it's okay
13:25:49 <mm_freak> hehe yeah
13:26:39 <mm_freak> or unlambda style
13:26:47 <mm_freak> ``Data List concat
13:27:03 <mm_freak> actually using that infix may be great
13:27:07 <mm_freak> Data`List`concat
13:27:07 <twanvl_> Data►List►permutations
13:27:13 <copumpkin> lol
13:27:18 <mm_freak> Data→List→permutations
13:27:18 <Cale> mm_freak: yeah
13:27:22 <olsner> hmm, how about this then: each accessor is in a typeclass so that it either is (Foo -> Bar) (for a record of type Bar in record-type Foo) or (a -> Foo) -> (a -> Bar)
13:27:36 <copumpkin> Data…List…permutations
13:27:41 <mm_freak> or microsoft style verbose:  permutations from (List from Data)
13:27:41 <MissPiggy> why ot just: Permutations
13:27:43 <mm_freak> =)
13:27:54 <olsner> then you just (baaz bar foo x) to get the baaz of the bar of the foo of the x
13:28:07 <tomberek> ^
13:28:08 <copumpkin> Data＿Vector
13:28:22 <mm_freak> well, anyway, note that qualification is used with single letter module names in most cases
13:28:27 <aavogt> does  -ddump-splices not parenthesize patterns correctly?
13:28:34 <copumpkin> we just need a decent module system
13:28:35 <Cale> from (from Data List) permutations
13:28:40 <twanvl_> olsner: you can't make an instance for (a -> Foo) -> (a -> Bar), that is only possible with a newtype
13:28:53 <twanvl_> Data's List's permutations
13:28:54 <copumpkin> permutations . List $ Data
13:28:55 <mm_freak> Cale: from (from List Data) permutations
13:29:01 <quicksilver> mm_freak: yes, which is where permutations<subscript>L</subscript> would look great
13:29:14 <Cale> mm_freak: that seems backward...
13:29:17 <quicksilver> mm_freak: if we're prepared to go outside of monospaced unformatted text
13:29:34 <mm_freak> Cale: oh, sorry, indeed
13:29:51 <mm_freak> quicksilver: i am, but emacs isn't that good at it =)
13:30:20 <dankna> could we take the energy that's being used to discuss this topic and instead use it to write up best practices for indentation, so that editor modes can have something to shoot for? :)
13:30:32 <dankna> if we're discussing cosmetic things, that one is actually important
13:30:52 <Philonous1> and boring
13:30:55 <dankna> mm
13:31:03 <dankna> that's how you know it's worth doing
13:31:04 <Cale> dankna: use spaces to indent, things which are siblings should be aligned, things which are children should start in a deeper column
13:31:04 <olsner> "best practices" doesn't sound like something an unsuccessful language should have
13:31:13 <copumpkin> olsner: damn straight!
13:31:27 <olsner> besides, the term itself is disgusting
13:31:35 <dankna> Cale: I agree as far as it goes, but how much deeper, for example?  I hate a lot of the decisions the Emacs haskell-mode makes...
13:31:49 <Cale> dankna: Any amount is fine with me.
13:32:02 <Cale> as long as it's at least one space. I usually use two.
13:32:13 <dolio> 'then' and 'else' should always be indented two spaces more than 'if', even outside a 'do'.
13:32:16 * copumpkin uses half a space
13:32:29 <dankna> well, to bring up one of the subtleties, is it a fixed amount deeper than the keyword that introduces the block or a fixed amount deeper than the entire line that precedes it?
13:32:34 <dankna> copumpkin, you would :)
13:32:37 <mm_freak> anyway
13:32:38 <quicksilver> mm_freak: emacs can do that; but not many know how to write modes which take advantage of it
13:32:40 <dankna> dolio: I agree with that one, too
13:32:42 * copumpkin thinks different!
13:32:43 <Cale> I often align the 'then' and 'else' with the expression that the 'if' is inspecting
13:32:43 <quicksilver> mm_freak: (I don't)
13:32:45 <Cale> if foo
13:32:47 <Cale>    then bar
13:32:50 <Cale>    else quux
13:32:50 <quicksilver> dankna: are you using the "new" indentation mode?
13:32:55 <etpace> @hoogle (a -> b) -> [m a] -> [m b]
13:32:55 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:32:55 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:32:55 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:33:00 <dankna> quicksilver: probably not, how do I get at it?  is it better?
13:33:01 <dolio> I could live with that, too.
13:33:04 <quicksilver> much better
13:33:05 <mm_freak> my original question was:  how the hell can i have records with the same accessor names?
13:33:07 <dankna> oh good
13:33:08 <Cale> So 'foo', 'then bar', and 'else quux' are considered siblings
13:33:09 <MissPiggy> :t map . map
13:33:10 <quicksilver> it's been folded into recent haskell-modes
13:33:11 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
13:33:17 <MissPiggy> :t map
13:33:18 <quicksilver> @where kuribas-indentation
13:33:18 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
13:33:18 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:33:20 <MissPiggy> wtf......
13:33:24 <mm_freak> quicksilver: i'm not an elisp programmer
13:33:25 <quicksilver> but that's the version before it got folded in
13:33:26 <etpace> :t map . fmap
13:33:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> [f a] -> [f b]
13:33:37 <dankna> hmm
13:33:41 <quicksilver> mm_freak: I know a little, but I don't know how to do that
13:33:41 <dolio> :t (.) . (.)
13:33:42 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:33:46 <dankna> Cale: that's not a bad convention either
13:33:56 <etpace> heh dolio
13:33:58 <etpace> mystical
13:34:02 <Cale> mm_freak: You don't. I don't think that records of genuinely different types ought to have the same accessor names.
13:34:17 <Cale> mm_freak: I always name my accessors such that there's no overlap.
13:34:18 <olsner> :t fmap fmap fmap
13:34:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:34:48 <dankna> I agree - I name my fields like DanknaRecord { danknaRecordFoo, danknaRecordBar, ... }
13:34:50 <Cale> mm_freak: Of course, with a proper record system, you would attach a meaning to the label/type pairs, not to the record types as a whole.
13:35:06 <mm_freak> Cale: but that would be convenient, because then i could use just 'name' instead of 'playerName', 'enemyName', 'fieldName', 'blubbName', etc.
13:35:14 <Cale> But similarly, I would never reuse the same name in genuinely different types.
13:35:24 <mm_freak> i would
13:35:25 <mm_freak> really
13:35:41 <mm_freak> i know how convenient this was in OOP languages
13:36:12 <edwardk> i just gave up and started using fclabels, and make a few instances when i need to be able to access the same field name from different records
13:36:22 <Cale> Things which are genuinely different but might appear in the same context should look different.
13:36:40 <mm_freak> in general i agree
13:36:43 <mm_freak> but not with records
13:36:46 <Cale> Sometimes it makes sense to define a typeclass.
13:37:04 <Cale> But only if the fields which occur in separate records really are related to one another.
13:37:33 <Cale> Like, for "name", it probably depends somewhat.
13:37:58 <edwardk> meh, i just use it whenever the types line up structural subtyping FTW ;)
13:38:01 <mm_freak> hmm
13:38:31 <Cale> If you find yourself doing that a lot, it might be a good idea to refactor your types
13:39:04 <Cale> So that you nest things a bit more, and sets of fields which are common to many types have their own type.
13:39:27 <mm_freak> my use case is this:  i have a number of parts it my program, which run as concurrent threads…  the interface is similar for all of them
13:39:43 <mm_freak> there is a startWhatever function, which takes a Param
13:40:13 <mm_freak> the program part itself runs in a StateT Config (ReaderT Param IO) monad
13:40:31 <Cale> ugh, monad transforming IO
13:40:43 <Cale> Not how I'd do things :)
13:41:12 <mm_freak> how would you do that?  note that the parts are usually infinite loops communicating to each other through MVars
13:41:19 <Cale> I've come to the opinion that it's actually rarely a good idea to state transform IO.
13:41:33 <mm_freak> why?
13:41:35 <Cale> IO already has IORefs for state, and passing parameters ends up being less trouble.
13:42:02 <Cale> The only monad transformer I might rarely consider is ContT
13:42:05 <edwardk> i'm fond of ReaderT'ing IO for carrying around the bag of IORefs you care about, which avoids having one bag of globals across the whole program
13:42:31 * ksf doesn't get how he's supposed to bind textures to vertices with gpipe
13:42:40 <edwardk> the unsafePerformIO . newIORef hack for constructing shared IORefs never sits well with me
13:42:48 <Cale> Using ReaderT forces you to liftIO all the IO actions, which is usually worse, syntactically, than just passing a parameter.
13:43:04 <mm_freak> Cale: well, whenever i see an infinite loop with a certain state, which changes often, but only small parts of it, StateT+ContT appears more natural to me
13:43:08 <Cale> I would never consider using unsafePerformIO . newIORef
13:43:12 <mm_freak> ContT to escape, StateT to manage the state
13:43:14 <edwardk> cale: which is why i think (almost) all IO operations should be written with a MonadIO constraint rather than IO anyways ;)
13:43:30 <mm_freak> Cale: i'm using MonadLib, so lifting is not that big of an issue =)
13:44:09 <Cale> Even with monadLib, you have to lift
13:44:18 <mm_freak> sure, but only when doing IO
13:44:30 <edwardk> i do wish more (any) of the standard lib used MonadIO
13:44:38 <Cale> Which, given that your computations are over IO, is on almost every line.
13:44:53 <dolio> edwardk: Well, that's why we should add sugar for it so it looks like 'topLevel <- newIORef'. Then it will be Okay.
13:45:04 <Cale> Which is easily more than you'd have to pass around the record of IORefs
13:45:10 <edwardk> dolio: a la JHC?
13:45:23 <dolio> Does JHC have it? I guess.
13:45:42 <mm_freak> Cale: well, i generally have only one or two 'inBase' (monadLib's generalized liftIO) functions in my computations
13:45:43 <edwardk> JHC has some top level commutative not quite IO like monad that it can use that way
13:45:45 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23003#a23005 <-- what now?
13:45:48 <Cale> Monad transformers are a neat technique, but I don't think they're a fundamental one.
13:45:49 <mm_freak> function calls that is
13:46:18 <Cale> and I find more code that overuses them than code which would benefit from monad transformers
13:46:20 <sinelaw> How do I define (in c2hs) a func that returns void?
13:46:33 <pastorn> sinelaw: () ?
13:46:35 <mm_freak> Cale: all in all i'd prefer StateT over using IORefs
13:46:44 <Cale> People seem to have an aversion to just passing parameters.
13:46:45 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
13:46:46 <lambdabot> f a =
13:46:46 <lambdabot>     Cont (\ b ->
13:46:46 <lambdabot>           case a (\ c -> Cont (\ _ -> b c)) of
13:46:46 <lambdabot>           Cont d -> d b)
13:46:47 <mm_freak> and passing explicitly can be awkward in many cases
13:46:53 <Cale> and I don't really understand why
13:47:07 <sinelaw> hmm
13:47:07 <Cale> It usually turns out to be a lot nicer than you'd expect
13:47:16 <pastorn> dolio: i don't want the actual implementation, i wanna get pointers
13:47:23 <pastorn> to figure it out myself :)
13:47:25 <edwardk> cale: for the same reason why people use reader in the first place, because when you discover you need another one you have to refactor a lot of code.
13:47:27 <dolio> :)
13:47:35 <BONUS> i don't mind lifting do-blocks. you usually don't have to lift every IO action by itself, but you make a big do-block and then you lift it
13:47:35 <edwardk> at least with reader you only pay that refactoring tax once.
13:47:39 <Cale> edwardk: You just modify the type
13:47:46 <MissPiggy> it keeps you strong though
13:47:54 <edwardk> cale: and plumb it all the way down to where it is needed
13:47:56 <mm_freak> Cale: well, but there is also nothing wrong with encoding your idea using a monad, i think
13:47:58 <Cale> edwardk: eh?
13:48:22 <sinelaw> pastorn, thanks.
13:48:23 <mm_freak> note that i use 'sets_' (monadLib's 'modify' equivalent) more often than i call recursively
13:48:24 <Cale> edwardk: If you've already gone to the trouble of passing a record of parameters all the way down, adding another field to that record is not usually much trouble
13:48:36 <edwardk> if i convert my code to ReaderT MyEnv IO ... i can rapidly add parameters to MyEnv without changing every intervening method between the call to runReaderT and the usage site.
13:48:38 <Cale> mm_freak: Note that you can also use the (->) e monad
13:48:53 <pastorn> sinelaw: i was just guessing...
13:48:55 <Cale> edwardk: MyEnv -> IO () is no different in that regard
13:48:57 <mm_freak> Cale: i use it, where appropriate
13:49:29 <sinelaw> pastorn, a good guess i guess, so good.
13:49:34 <Cale> edwardk: no?
13:49:52 <sinelaw> pastorn, still didn't manage to compile / test, so hold on to your celebrations
13:50:00 <edwardk> cale: sure, The ReaderT MyEnv case works, but the difference to me is that now as I add StateT, WriterT, add ContT because I need backtracking, I still don't have to change the intervening code.
13:50:37 <edwardk> i'm holding up a bit of a straw man argument because i'm just as likely to use MyEnv -> IO () as ReaderT MyEnv IO ;)
13:51:06 <mm_freak> Cale: the big advantage of StateT and ReaderT is that i can write lots of functions, which are called in a hierarchial manner without having to pass explicitly all the time
13:51:24 <Cale> mm_freak: I don't understand.
13:51:53 <mm_freak> Cale: it's not that i have a single function in that monad, which uses the state/environment, but lots of them, calling each other
13:52:04 <etpace> @hoogle (a -> m a) -> [a] -> m [a]
13:52:05 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:52:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:52:05 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:52:11 <Cale> You can still write lots of functions which are called in a hierarchical manner, and passing one parameter is not really that verbose.
13:52:17 * hackagebot upload: bot 0.3 - bots for functional reactive programming (ConalElliott)
13:52:17 <pastorn> sinelaw: maybe there's some kind of datatype 'data CType = CInt | CFloat | CVoid ...'
13:52:28 <Cale> Compared with lifting every single IO action you use
13:52:42 <pastorn> sinelaw: i've never used it so i have no clue :)
13:52:43 <mm_freak> Cale: sure, but using the monads is still more concise =)
13:52:46 <edwardk> it all comes down to a matter of style. do you prefer the manual argument and special casing reader among all possible transformers or do you prefer using transformers and pay for it by using liftIO around anything that you want to have just work with the underlying IO monad
13:52:56 <mm_freak> Cale: note that your applications may be different
13:53:04 <conal> there.  updated some libs for new repo location.  and bot also update for Category/Arrow
13:53:09 <Cale> I would never StateT over IO
13:53:11 <sinelaw> pastorn, me too.
13:53:27 <Cale> (because it's very close to ReaderT over IO anyway)
13:53:53 <pastorn> Cale: ReaderT (IORef r) IO a
13:53:54 <edwardk> ContT is of course the canonical example of a useful but not quite implementable using ReaderT'd IO monad
13:53:55 <pastorn> hehe
13:53:56 <mm_freak> Cale: besides using a monad transformer where not strictly necessary is there any other reason why you wouldn't do that?
13:54:02 <Cale> pastorn: right
13:54:07 <sinelaw> conal, HackageBot beat you to it, with the announcements
13:54:25 <pastorn> Cale: i just tried to think of something noughty
13:54:35 <mm_freak> i prefer StateT over IORef
13:54:38 <mm_freak> seems cleaner to me
13:54:41 <Alpounet> btw
13:54:57 <Alpounet> does anyone know of a good documented use of ContT ?
13:55:31 <Cale> mm_freak: I don't think that monad transformers are an appropriate thing to use for application development. There are a lot of abstraction problems and they make the types ugly, unless you go out of your way to hide the fact that you're using monad transformers.
13:55:39 <pastorn> Alpounet: All About Monads has a big example with lots of comments
13:55:44 <Cale> For certain types of libraries, they're great
13:55:48 <Alpounet> pastorn, ok thanks
13:55:53 <Alpounet> will check it out
13:56:00 <pastorn> (never read it, though)
13:56:04 <Cale> The examples in All About Monads are awful :/
13:56:18 <pastorn> Alpounet: i didn't have the skillz to begin to grasp it when i was reading AOM
13:56:29 <mm_freak> Cale: i don't think they make types ugly, it's just you need to get used to them
13:56:38 <pastorn> Cale: i found the sheeps to be very helpful
13:56:39 <mm_freak> and i don't see any abstraction problems
13:56:57 <Cale> mm_freak: mostly related to the number of lifts required
13:57:02 <mm_freak> in fact they force you to separate IO operations from State operations
13:57:11 <mm_freak> Cale: i seldomly use more than one 'inBase'
13:57:15 <Alpounet> pastorn, I haven't read the whole tutorial neither
13:57:18 <pastorn> Cale, mm_freak: GereralizedNewtypeDeriving :D
13:57:23 <Sternmull> can i list all instances of a typeclass in ghci?
13:57:23 <Alpounet> you did good reminding me about it
13:57:30 <mm_freak> Cale: again, my applications or coding style may be different
13:57:34 <Cale> pastorn: Yeah, that's how I recommend using monad transformers.
13:57:36 <Alpounet> Sternmull, you can with lambdabot, at least
13:57:36 <pastorn> Alpounet: could link the example when you find it?
13:57:44 <edwardk> alpounet: here is something that uses Codensity rather than ContT: http://www.mail-archive.com/haskell-cafe@haskell.org/msg69730.html but in a very ContT like way
13:57:53 <Sternmull> hm
13:57:57 <Cale> Always newtype the monad transformer stack and hide the fact that you're using monad transformers by using a module boundary
13:58:33 <Cale> The only cases where I've effectively put StateT to use are StateT over [] or some other nondeterminism monad.
13:58:42 <mreh> how can I Debug.Trace.trace an infinite list as it is evaluated?
13:59:01 <mreh> i suppose I can make my own trace
13:59:07 <Cale> mreh: huh?
13:59:15 <edwardk> mreh: you can map trace [1...100]
13:59:16 <Cale> mreh: The same way you Debug.Trace.trace anything else
13:59:23 <Alpounet> pastorn, I can't find any sample using ContT in AAM, for the moment
13:59:24 <pastorn> mreh: map trace?
13:59:26 <Alpounet> edwardk, thank you
13:59:38 <edwardk> er map (\x -> trace (show x) x) [1..100]
13:59:43 <conal> sinelaw: yeah.  i like hackagebot
13:59:49 <edwardk> or whatever the syntax for trace was
13:59:50 <mreh> yeah, temporary brain failure there guys
13:59:51 <mreh> thanks
13:59:51 <edwardk> @type trace
13:59:52 <lambdabot> Not in scope: `trace'
13:59:57 <edwardk> @type Debug.Trace.trace
13:59:58 <lambdabot> forall a. String -> a -> a
14:00:17 <mreh> edwardk: there's also traceShow for future reference :D
14:00:27 <mreh> (\x -> traceShow x x)
14:00:27 <edwardk> mreh: that'd work too ;)
14:00:59 <Cale> Note that using map like that will cause the traces to be printed when the elements are evaluated, rather than the list cells
14:01:07 <pastorn> Alpounet: http://www.haskell.org/all_about_monads/html/contmonad.html
14:01:08 <edwardk> or even map (trace =<< show) [1..100] =)
14:01:15 <pastorn> example 18, at the bottom
14:01:48 <mm_freak> Cale: i think you would go crazy when you see my code
14:02:02 <mm_freak> i already had LogicT + ContT + StateT + ReaderT + IO =)
14:02:10 <edwardk> mm_freak: hah
14:04:14 <mm_freak> that's why i always say 90% of my code is monadic
14:04:50 <edwardk> i'm probably closer to 5% of my code being monadic
14:05:04 <edwardk> but that 5% is a jumbled mess of transformers that would drive cale mad
14:05:08 <Cale> heh
14:05:23 <Cale> I don't necessarily mind monad transformers. Just monad transformers which are unnecessary
14:05:23 <Alpounet> pastorn, this is the Cont monad
14:05:31 <Alpounet> I was refering to the ContT monad transformer
14:06:00 <pastorn> Alpounet: they're not different?
14:06:03 <copumpkin> edwardk: that's just cause you have more obscure categorical structures in your code! monads are but one of many!
14:06:14 <edwardk> Alpounet: the code i pasted a link to is effectively using the monad for forall r. ContT r STM a
14:06:33 <copumpkin> edwardk's code is all about the coideals and codensities and the prepromorphisms
14:06:35 <Alpounet> pastorn, not that much, but I have tons of Cont samples here and there, but thanks anyway :-)
14:07:07 <edwardk> copumpkin: generalized prepromorphisms, not the regular kind, thank you very much ;)
14:07:07 <Alpounet> <mm_freak> i already had LogicT + ContT + StateT + ReaderT + IO =) <<< hence the "freak" in the nickname ? :-p
14:07:14 <copumpkin> edwardk: oh, sorry
14:07:22 <copumpkin> wouldn't want to misrepresent you!
14:07:36 <Alpounet> edwardk, very nice, thanks
14:08:03 <mreh> gah! getRandomRs in System.Random returns (lo, hi), that's a disaster for indexing with integers
14:08:36 <mreh> trying to make it polymorphic is too hard
14:08:51 <edwardk> alpounet: it uses the power of Codensity to do backtracking, even though it is too weak to callCC
14:08:56 <mm_freak> Cale: that depends on your notion of 'unnecessary' =)
14:09:17 <edwardk> see the definition of 'needRef' which checks to see if the ref will be used in the future and returns a different answer one way or the other
14:09:31 <mm_freak> i find IORefs "unnecessary" 99% of the time i see them ;)
14:09:44 <Alpounet> edwardk, I haven't studied Codensity yet
14:09:52 <Alpounet> it's on my todo list though
14:09:56 <mm_freak> btw, IORefs and STRefs could use a nicer interface
14:10:22 <edwardk> newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
14:10:26 <edwardk> compare to ContT
14:10:38 <copumpkin> and Ran?
14:10:41 <mm_freak> class Ref m r | m -> r where newRef :: a -> m (r a); …
14:10:47 <Cale> I think IORefs and STRefs have exactly as nice an interface as they need to have.
14:11:09 <mm_freak> Cale: yes, but it should be generalized using a typeclass
14:11:09 <Alpounet> edwardk, oh, yeah ok
14:11:16 <Cale> After all, one hardly ever uses them :)
14:11:20 <edwardk> copumpkin: newtype Ran f g a = Ran (forall r. (a -> f r) -> g r)
14:11:20 <copumpkin> has anyone worked on a pure concurrency monad à la ST? I wonder how we could guarantee referential transparency... we probably couldn't, eh
14:11:34 <chrisdone> hmm how can I do IO on tryhaskell?
14:11:34 <copumpkin> edwardk: yeah, so Ran f f = Codensity f
14:11:37 <ksf> there's CHP
14:11:41 <chrisdone> brb, this buffer is too big
14:11:42 <copumpkin> chrisdone: DON'T DO IT!!
14:11:45 <copumpkin> damn
14:11:49 <Kruppe> mreh: I don't see getRandomRs
14:11:51 <copumpkin> that's what she said
14:11:54 <ksf> that's getting you as close to referential transparency as you're going to get
14:11:59 <mm_freak> copumpkin: can you guarantee that all threads are dead as soon as you leave ST?
14:12:23 <copumpkin> mm_freak: that's what I want to know :) and if your concurrency is concurrent, it's probably nondeterministic and thus not pure :P
14:12:30 <copumpkin> but hey, it's worth thinking about
14:12:42 <mreh> Kruppe: it's part of System.Random
14:12:45 <edwardk> copumpkin: i have most of an applicative for concurrency, easier to guarantee that it doesn't matter if you reorder effects ;)
14:12:45 <Alpounet> edwardk, so ContT is a particular case of Codensity actually, right ?
14:12:53 <copumpkin> edwardk: that makes sense
14:12:54 <mreh> hackage's search is pretty crappy recently
14:12:57 <mreh> non?
14:13:08 <edwardk> Cont r is Codensity (Const r)
14:13:09 <copumpkin> we could have a monad that is dedicated to concurrency that "runs" in IO, but doesn't allow other IO operations and has primitives for channels
14:13:21 <chrisdone> I think.. I could do IO if I make a fake IO monad, and just define one or two, like readFile and getLine to do tryhaskell specific things. but how to do getLine...
14:13:22 <Kruppe> mreh: this? http://www.haskell.org/ghc/docs/latest/html/libraries/random-1.0.0.2/System-Random.html#v%3ArandomRs
14:13:30 <mm_freak> copumpkin: that's the big problem…  as soon as you have two threads writing to an MVar, the outcome depends on whichi one writes first =)
14:13:40 <Alpounet> edwardk, yeah
14:14:01 <chrisdone> could have getLine return an incomplete action that returns to the client, that triggers the tryhaskell input box and then it sends it back as a continuation...
14:14:05 <copumpkin> chrisdone: if you do that, you should fool them into thinking they've read your /etc/passwd, then they'll run john the ripper on it for a few hours and find that all the passwords are "scriptkiddiepr00f"
14:14:12 <mm_freak> copumpkin: not allowing IO operations seems like an unnecessary restriction to me
14:14:38 <copumpkin> mm_freak: it could be thought of as "actors", but maybe disallowing IO might give you the opportunity to do more things
14:14:43 <copumpkin> but edwardk's applicative sounds nicer
14:14:53 <mreh> Kruppe: yes, the "get" suffix comes from MonadRandom
14:14:58 <copumpkin> unfortunately not as much possible in it
14:15:02 <mreh> know monads?
14:15:08 <chrisdone> I should go to bed but I really want to try implementing this
14:15:17 <mm_freak> copumpkin: the race problem still remains
14:15:31 <copumpkin> mm_freak: that's what I'm saying though, it would run in IO
14:15:39 <edwardk> yeah, you can't really change the control flow path, so its more of a way to set up a rigorous set of tasks with fixed barrier synchronization points.
14:15:49 <mm_freak> concurrency is inherently nondeterministic, so restricting IO would make little sense =)
14:16:06 <copumpkin> mm_freak: ?
14:16:07 <ksf> concurrency doesn't need to be nondeterministic
14:16:23 <monochrom> programming doesn't need to be deterministic.
14:16:29 <mm_freak> ksf: yes, but can you check that statically?
14:16:33 <copumpkin> determinism doesn't need to be programming
14:16:37 <edwardk> copumpkin: mostly was just trying to see what would happen if i took ryan newtons CnC stuff and made it applicative so it would be easier to allow for things like a lazy evaluation strategy, etc.
14:16:46 <jlouis> in graphs generated with h2ps "-hc" is the y axis the size of the heap?
14:16:46 <sinelaw> how to tell ghc to include some path for ghc?
14:16:52 <sinelaw> oops, for gcc
14:16:58 <chrisdone> -I ?
14:16:59 <mauke> what kind of path?
14:17:10 <jlouis> or more precisely, size of the live data in the heap
14:17:12 <copumpkin> edwardk: ah, did you send it to him?
14:17:23 <sinelaw> mauke, include pat
14:17:25 <sinelaw> h
14:17:34 <mauke> I'd try -optc-Iwhatever
14:17:41 <jlouis> hp2ps, can't type as well
14:17:42 <ksf> mm_freak, possibly.
14:17:44 <edwardk> copumpkin: not yet, we've talked about it, but i never did get it to a fully usable state
14:17:44 <mauke> or grep the user's guide for "optc"
14:17:58 <ksf> you can statically prove systems to be deadlock-free etc.
14:17:58 <sinelaw> -I did it
14:18:01 <edwardk> copumpkin: i did send him the CnC based parallel merge sort though
14:18:35 <ksf> mm_freak, http://en.wikipedia.org/wiki/Communicating_sequential_processes
14:19:16 <copumpkin> edwardk: cool
14:19:20 <ksf> ...specifically, http://www.cs.kent.ac.uk/projects/ofa/chp/
14:19:25 <mm_freak> ksf: is that an idealized model or is it actually useful for real programs?
14:19:38 <copumpkin> edwardk: I don't suppose you've heard any inside information on upcoming boston HUGs or hackathons?
14:19:50 <copumpkin> being a true bostonian etc.
14:19:54 <ksf> it's actually useful for real programs, but you might not want to actually prove things in it...
14:20:18 <mm_freak> hehe
14:20:29 <jlouis> in haskell-torrent I went with CML instead of CHP. It has a more pi-calculus like feel to it
14:20:31 <ksf> I'd use CHP for concurrency, but it's kinda slow
14:20:51 <jlouis> mostly because I knew CML in advance :)
14:21:14 <monochrom> It is not like you have better ways to prove things.
14:21:35 <ksf> ...so I'm ending up using plain STM. creating a process forks a thread and returns a TChan into which you write (Request, Answer -> STM ())
14:21:58 <ksf> ...the worker process then forks a spark if it wants to give you an answer, so you can't deadlock it.
14:23:19 <sinelaw> arrrrrrrrg failing to build c2hs stuff :(
14:23:33 <ksf> oh. another one tripping over that one.
14:23:54 <mm_freak> CML sounds really interesting
14:26:23 <sinelaw> ksf is calmly analyzing life and death on the haskell savanna.
14:27:38 <FliPPeh_> Say I have a state monad where I'm executing IO stuffs... I'd like to create a thread that has access to my State data... how could I do that?
14:28:34 <ivanm> greetings, sinelaw
14:28:40 <mm_freak> FliPPeh_: by passing it
14:28:52 <ksf> sinelaw, well... I dodged death.
14:29:12 <sinelaw> ivanm, greetings to you too
14:29:13 <FliPPeh_> mm_freak: If I pass it, I'll just get the current snapshot!
14:29:14 <sinelaw> :)
14:29:15 <ivanm> how can you do IO within State? using a monad transformer?
14:29:17 <jlouis> mm_freak: I have not been able to bug it yet
14:29:20 <ksf> not because I got c2hs running, but because I had generated .hs files still lying around.
14:29:26 <mm_freak> FliPPeh_: yes, and that's the best you can get
14:29:27 <FliPPeh_> ivanm: liftIO
14:29:36 <ivanm> aha
14:29:37 <jlouis> And haskell torrent usually have around 200-300 threads while running
14:29:50 <mm_freak> FliPPeh_: if you need multi-thread state, you need a concurrent thread managing that state
14:30:02 <blackdog> sinelaw: i'm thinking of ripping C2HS out of hubris for that reason, actually - it's really embarrassing to have to tell people that they need two compilers to install it...
14:30:09 <mm_freak> (or the dirty approach of SampleVar/IORef)
14:30:09 <edwardk> copumpkin: fraid not. ravi has largely dropped off the face of the earth. i should give him a call and see if i can get him motivated
14:30:11 <ksf> sinelaw, if in doubt get yourself a 6.10 and use it to build yourself a c2hs
14:30:28 <mreh> what are the dots and pluses in boolean algebra again?
14:30:33 <mreh> which way round is it
14:30:38 <mreh> + is or?
14:30:41 <ddarius> Pluses are always "or"
14:30:43 <ivanm> mreh: + = OR
14:30:45 <ivanm> . = AND
14:30:58 <jlouis> FliPPeh_: in general you need some kind of way to handle updates to the state. The two options that are in the game as of this decade is STM and message passing of some kind
14:30:59 <sinelaw> ksf, nah got it. and i'm using 6.10 anyhow
14:31:00 <ivanm> (though it should be more of a centered circle)
14:31:04 <edwardk> flippeh: get the state into a local variable, forkIO the new task, then runStateT in that IO monad with your state
14:31:14 <ivanm> blackdog: c2hs is a compiler?
14:31:15 <edwardk> FliPPeh_: of course if one thread mutates its state it only mutates its local copy
14:31:22 <mm_freak> FliPPeh_: http://codepad.org/qRHwLu10
14:31:25 <sinelaw> blackdog, i think i got it now. it just needs a saner compilation cycle (automatic cabal generation maybe?)
14:31:28 <mm_freak> see the clientManager function
14:31:37 <blackdog> ivanm: no, but i need 6.12 for hubris, with which c2hs is broken
14:31:43 <blackdog> so you need 6.10 to compile c2hs
14:31:54 <blackdog> sinelaw: how do you mean?
14:32:03 <mm_freak> it takes commands through an MVar and modifies its state accordingly
14:32:21 <sinelaw> blackdog, maybe they can have a script that generates the cabal file required to completely build a project that uses c2hs
14:32:33 <sinelaw> blackdog, just shooting ideas.
14:33:19 <ksf> waaagh don't tell me another haskell 3d project is dying
14:33:32 <ksf> lamdacube's last commit is 2009-11-30
14:33:49 <copumpkin> lol
14:33:57 <copumpkin> quick, revive it
14:34:37 <edwardk> ksf: i finally gave up on using haskell for my own personal 3d projects, but that was mostly a 'i can't handle the gc pauses and resulting latency spikes' issue
14:34:54 <mm_freak> really i would love to do 3D things in haskell
14:34:59 <ksf> I'm not even trying to do real 3d
14:35:06 <mm_freak> but there is no decent rendering library out there
14:35:16 <pastorn> mm_freak: ogre?
14:35:17 <mm_freak> i'd be happy to see bindings to ogre and/or irrlicht
14:35:22 <ksf> ...I just figured lambacube's scenegraph could do some 2d things for me
14:35:26 <mm_freak> pastorn: is there a binding already?!
14:35:29 <edwardk> i just gave up and defected to direct3d 11 =/ i now have an audience of all of like 3 people who can run it ;)
14:35:34 <pastorn> mm_freak: there's ogre and bullet bindings
14:35:37 <mm_freak> oh
14:35:39 <mm_freak> indeed!
14:35:52 <mm_freak> "hogre library: Haskell binding to a subset of OGRE"
14:35:58 <mm_freak> a small subset or a large subset?
14:36:09 <mauke> the empty subset
14:36:29 <edwardk> mm_freak: hah, ogre was one of the reasons why i stopped trying to use haskell for 3d. i was playing with ogre at the time, and binding haskell to a large c++ project is an exercise in frustration
14:36:52 <Alpounet> an ultrafilter of haskell bindings ?
14:36:58 <mm_freak> edwardk: indeed
14:37:32 <pastorn> mm_freak: but if you're proficient in GL there's GPipe
14:37:57 <copumpkin> @let ultraFilter f (xs, ys) = (filter f xs, filter f ys)
14:37:58 <lambdabot>  Defined.
14:38:01 <mm_freak> hmm, hogre seems very incomplete
14:38:04 <copumpkin> TWO FILTERS AT ONCE, ZOMG
14:38:10 <copumpkin> :t ultraFilter
14:38:11 <lambdabot> forall a. (a -> Bool) -> ([a], [a]) -> ([a], [a])
14:38:23 <dolio> That's not what an ultrafilter is. :)
14:38:28 <copumpkin> THREE THEN
14:38:43 <copumpkin> @let megaFilter f (xs, ys, zs) = (filter f xs, filter f ys, filter f zs)
14:38:44 <lambdabot>  Defined.
14:38:58 <copumpkin> so much cooler than that silly math definition
14:38:58 <MissPiggy> @let iDon'tGiveAFilter f = ()
14:39:00 <lambdabot>  Defined.
14:39:13 <copumpkin> @let infraFilter f () = ()
14:39:14 <mm_freak> @let ultimateFilter = filterM
14:39:15 <lambdabot>  Defined.
14:39:16 <lambdabot>  Defined.
14:39:23 <ivanm> @slap copumpkin
14:39:23 * lambdabot slaps copumpkin
14:39:25 <ivanm> @slap MissPiggy
14:39:26 * lambdabot moulds MissPiggy into a delicous cookie, and places it in her oven
14:39:29 <mm_freak> > ultimateFilter (const [True, False]) "abc"
14:39:30 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
14:39:30 <copumpkin> ooh
14:39:31 <BONUS> lol i was just about to define ultimateFilter
14:39:33 <copumpkin> a pork cookie
14:39:36 <ivanm> that's for @let'ting stupid definitions
14:39:46 <mm_freak> hehe BONUS, i were first =)
14:39:48 <copumpkin> edwardk was not amused
14:39:49 <pastorn> @hoogle (a -> b) -> ([a],[a],[a]) -> ([b],[b],[b])
14:39:50 <lambdabot> No results found
14:40:00 <sinelaw> haha pork cookie :)
14:40:02 <pastorn> @hoogle (a -> b) -> ([a],[a]) -> ([b],[b])
14:40:02 <lambdabot> No results found
14:40:05 <pastorn> hmm...
14:40:06 <BONUS> altough i wanted to do it ultimateFilter  = map . filter
14:40:25 <pastorn> @pr megaFilter f (xs, ys, zs) = (filter f xs, filter f ys, filter f zs)
14:40:25 <lambdabot> Maybe you meant: pretty print-notices protontorpedo pl
14:40:37 <pastorn> @pr \f (xs, ys, zs) -> (filter f xs, filter f ys, filter f zs)
14:40:37 <lambdabot> Maybe you meant: pretty print-notices protontorpedo pl
14:40:43 <pastorn> @pl \f (xs, ys, zs) -> (filter f xs, filter f ys, filter f zs)
14:40:44 <lambdabot> (line 1, column 11):
14:40:44 <lambdabot> unexpected ","
14:40:44 <lambdabot> expecting letter or digit, operator or ")"
14:40:44 <lambdabot> ambiguous use of a non associative operator
14:40:45 <mm_freak> :t \f -> map f *** map f
14:40:46 <lambdabot> forall a b. (a -> b) -> ([a], [a]) -> ([b], [b])
14:40:47 <copumpkin> @pl doesn't do triples
14:40:47 <lambdabot> doesn't do triples
14:41:01 <pastorn> awww
14:41:05 <pastorn> haha
14:41:11 <mm_freak> :t (***) <$> map <*> map
14:41:12 <lambdabot> forall a b. (a -> b) -> ([a], [a]) -> ([b], [b])
14:41:29 <pastorn> lambdabot: study up on (,,)
14:41:31 <mm_freak> your applicative nightmares come true =)
14:41:39 <etpace> @hoogle ((a,b) -> m c) -> [a] -> [b] -> m [c]
14:41:40 <lambdabot> No results found
14:41:43 <copumpkin> pastorn: it's just because there are no helper functions for it
14:41:47 <etpace> @djinn ((a,b) -> m c) -> [a] -> [b] -> m [c]
14:41:47 <lambdabot> Error: Undefined type []
14:41:58 <copumpkin> no uncurry3, curry3, fst3,snd3,thd3, etc.
14:42:11 <mm_freak> :t mapM . zip
14:42:12 <pastorn> awww
14:42:12 <lambdabot> forall a b. [a] -> [[b]] -> [[(a, b)]]
14:42:18 <SubStack> wooo polynomial substitution is working ^_^
14:42:25 <etpace> @hoogle (a -> b -> m c) -> [a] -> [b] -> m [c]
14:42:26 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:42:26 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
14:42:26 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:42:31 <etpace> woop
14:42:42 <mm_freak> :t \f xs -> mapM f . zip xs
14:42:43 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => ((a, b1) -> m b) -> [a] -> [b1] -> m [b]
14:42:50 <sinelaw> @slap all
14:42:50 * lambdabot secretly deletes all's source code
14:42:59 <ivanm> sinelaw: :o
14:43:02 <ivanm> why everyone?
14:43:03 <SubStack> since I fixed the recursive visitor, but I should be using Traversable anyways
14:43:12 <mm_freak> :t (. zip) . mapM
14:43:14 <lambdabot>     Couldn't match expected type `[b] -> [(a, b)]'
14:43:14 <lambdabot>            against inferred type `[a1]'
14:43:14 <lambdabot>       Expected type: (a1 -> m b2) -> ([b] -> [(a, b)]) -> b1
14:43:37 <sinelaw> @slap self
14:43:37 * lambdabot slaps self
14:43:40 <sinelaw> hah!
14:43:42 <sinelaw> got him.
14:44:10 <burp> @slap herself
14:44:10 * lambdabot slaps herself
14:44:24 <monochrom> @slap all of you
14:44:24 * lambdabot locks up all of you in a Monad
14:44:41 <Alpounet> :t \f -> zipWithM (f . uncurry)
14:44:42 * ivanm starts playing mournfully on his harmonica
14:44:42 <lambdabot> forall b (m :: * -> *) c a b1 c1. (Monad m) => (((a, b1) -> c1) -> b -> m c) -> [a -> b1 -> c1] -> [b] -> m [c]
14:44:55 <xerox> one Monad to bind them all
14:44:59 <monochrom> I need to find a way to predict her next slap action.
14:45:11 <monochrom> @quote bind
14:45:12 <lambdabot> DavidLeimbach says: Don't play with your monads... eventually you'll go bind.
14:45:19 <monochrom> @quote bind*all
14:45:19 <lambdabot> No quotes match. Take a stress pill and think things over.
14:45:23 <monochrom> @quote bind.*all
14:45:23 <lambdabot> ghc says: Pattern bindings (except simple variables) not allowed in instance declarations
14:45:32 <monochrom> @quote bind.*them.*all
14:45:33 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
14:45:35 <Sternmull> Can someone take a look at my try to create indexed accessor for tuples? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23006#a23006
14:45:35 <Sternmull> There is a commented problem that i dont understand in there. It would be nice if someone has an explanation and maybe a solution.
14:46:24 <mm_freak> one list monad to filterM them all
14:46:49 <Alpounet> mm_freak, "to filterM all" is enough
14:46:59 <monochrom> haha
14:47:04 <mm_freak> hehe
14:47:12 <mauke> Sternmull: because nothing keeps me from adding an instance Vec ((,,) a a a) Char
14:47:38 <mauke> Sternmull: or instance Vec ((,,) Float Char ()) Int
14:48:00 <copumpkin> you'd want a type family, if anything
14:48:05 <dolio> > let penultimateFilter p m = do x <- m ; guard (p x) ; return x in penultimateFilter (< 20) [1..60]
14:48:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
14:48:09 <copumpkin> or at least an MPTC with fundeps
14:48:16 <Sternmull> hm. But i dont know how to say that v is a tuple of elements of type e
14:48:51 <mauke> I don't think you can say that
14:48:59 <ddarius> [x | x <- m, p x]
14:49:13 <BONUS> word of warning: penultimate means second to ultimate, not really really ultimate
14:49:30 <copumpkin> Sternmull: use an inductive length-indexed vector!
14:49:33 <copumpkin> screw tuples
14:49:37 <ddarius> ultimateFilter p m = [x | x <- m, p x]
14:49:56 <Sternmull> and i thought the existing instances would be enougth to show that the elements and return values would be all the same
14:50:02 <mm_freak> > [1..19]
14:50:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
14:50:04 <mm_freak> ;)
14:50:10 <etpace> @hoogle (a -> b -> c) -> m a -> m b -> m c
14:50:10 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:50:10 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:50:10 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:50:33 <dolio> > let penultimateFilter p m = do x <- m ; guard (p x) ; return x in observeAll $  penultimateFilter (< 20) (msum $ map return [1..60])
14:50:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
14:50:34 <Sternmull> copumpkin: what is that? "inductive length-indexed vector"?
14:51:16 <copumpkin> data Z; newtype S a = S a; data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a;
14:51:21 <ksf> @hackage Vec
14:51:21 <lambdabot> http://hackage.haskell.org/package/Vec
14:52:04 <ksf> ...including beautiful type sigs like multmm :: (Map v v' m1 m3, Map v a b v', Transpose m2 b, Fold v a, Num v, Num a) => m1 -> m2 -> m3
14:52:14 <McManiaC> how can I make sure that the whole file is read before closing a handle?
14:52:30 <Berengal> McManiaC: Depends on how you read it. getContents?
14:52:34 <McManiaC> Berengal: jup
14:52:42 <ksf> by not using lazy IO in the first place, and secondly by fully forcing your computation
14:52:46 <Alpounet> force the evaluation of the content, or the length
14:52:51 <Berengal> McManiaC: s <- getContents; last s `seq` return ()
14:53:00 <ksf> lazy IO is a work of the devil
14:53:02 <Alpounet> s/or/by/
14:53:11 <dolio> Are you explicitly closing the handle you're calling getContents with?
14:53:17 <Berengal> For some strange reason there doesn't seem to be a strict version of getContents...
14:53:21 <McManiaC> dolio: ye…
14:53:26 <dolio> Well don't do that.
14:53:30 <ksf> Berengal, you know, you could just read the whole thing strictly instead.
14:53:35 <ivanm> Berengal: or use evaluate s
14:53:38 <ivanm> @hoogle evaluate s
14:53:38 <lambdabot> No results found
14:53:41 <ivanm> @hoogle evaluate
14:53:41 <lambdabot> Control.Exception evaluate :: a -> IO a
14:53:41 <lambdabot> Control.OldException evaluate :: a -> IO a
14:53:41 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
14:53:50 <McManiaC> dolio: well then I'll get a "file currently in use" error when I try to write to it again
14:53:55 <Berengal> ivanm: evaluate evaluates to whnf, which doesn't work that well for lists
14:53:55 <ivanm> well, evaluate the length or something
14:54:04 <copumpkin> rnf it
14:54:05 * ivanm was trying to remember what he was doing
14:54:11 <Berengal> evaluate (lasts s) would do it
14:54:12 <ksf> McManiaC, you're doing it wrong.
14:54:16 <Berengal> last*
14:54:20 <ksf> you shouldn't write to a file you just read from
14:54:22 <copumpkin> why not just deepseq / rnf?
14:54:24 <ivanm> Berengal: any reason for last over length?
14:54:27 <copumpkin> the others are just lame approximations of it
14:54:34 <ksf> write to a different one, fsync, then rename it.
14:54:34 <ivanm> copumpkin: that needs another import :p
14:54:38 <McManiaC> ksf: tell me how to do it? :)
14:54:41 <Berengal> ivanm: Not really.
14:54:55 <Sternmull> thanks copumpkin and ksf. That looks like what i want. :)
14:54:58 <copumpkin> ivanm: still, last or length might avoid actually reading the data, depending on how it's implemented
14:54:59 <Berengal> ivanm: unless length is lazy, then yes. I forget
14:55:06 <ksf> otherwise you might loose all data when your program gets killed while writing.
14:55:12 <ivanm> @src length
14:55:12 <lambdabot> Source not found. Do you think like you type?
14:55:15 <ivanm> grrr....
14:55:16 <copumpkin> @wn loose
14:55:18 <lambdabot> *** "loose" wn "WordNet (r) 2.0"
14:55:18 <lambdabot> loose
14:55:18 <lambdabot>      adj 1: not restrained or confined or attached; "a pocket full of
14:55:18 <lambdabot>             loose bills"; "knocked the ball loose"; "got loose
14:55:18 <lambdabot>             from his attacker"
14:55:20 <lambdabot> [47 @more lines]
14:55:46 <ksf> @vixen what do you think, is copumpkin a smartass?
14:55:46 <lambdabot> i dunno...
14:55:53 <McManiaC> ksf: what do you mean with fsync & rename?
14:55:57 <copumpkin> ksf: :)
14:56:00 <Berengal> Sternmull: Welcome to the world of semi-dependent types :)
14:56:00 <mm_freak> copumpkin: an overly intelligent implementation might skip reading the data and just ask the OS for the length, but i doubt that any implementation will ever do that =)
14:56:17 <copumpkin> mm_freak: still, why rely on it when there's a good deepseq that does exactly what you need :P
14:56:27 <copumpkin> or just don't use lazy IO if you don't want it to be lazy O:-)
14:56:27 <Berengal> deepseq is slower than last
14:56:34 <Berengal> or length
14:56:36 <copumpkin> Berengal: why?
14:56:46 <mm_freak> well, IMO the whole approach is wrong
14:56:55 <mm_freak> use Data.ByteString.readFile
14:56:58 <copumpkin> hence my second comment above
14:56:59 <Berengal> copumpkin: It has to visit all values, length only visits the spine
14:57:03 <mm_freak> or Data.ByteString.Char8.readFile
14:57:07 <mm_freak> they read strictly
14:57:07 <ksf> man 2 fsync, man 1 mv
14:57:11 <copumpkin> Berengal: presumably it's actually reading the file?
14:57:11 <McManiaC> mm_freak: hmm those are strict?
14:57:15 <McManiaC> okay cool
14:57:15 <ivanm> copumpkin: OK, where can I find this mystical strict IO library?
14:57:22 <copumpkin> ivanm: in ByteString O:-)
14:57:22 <Berengal> copumpkin: It is, but deepseq has to visit them a second time
14:57:24 <ksf> (dunno remember the C function right now)
14:57:28 <ivanm> copumpkin: nope, I need String
14:57:31 <mm_freak> McManiaC: yes, and they use ByteStrings at the same time
14:57:37 <Saizan> ?type Data.ByteString.Char8.readFile
14:57:40 <lambdabot> FilePath -> IO BSC.ByteString
14:57:47 <ivanm> and I don't want Char8 Strings either
14:57:56 <Berengal> copumpkin: In general, deepseq is a bad idea unless you know you have a big unevaluated thunk. Never deepseq a map, for example
14:58:03 <Saizan> ivanm: which encoding is it in?
14:58:14 <ivanm> Saizan: either utf8 or latin1
14:58:16 <copumpkin> Berengal: disk IO outweighs memory accesses by several orders of magnitude...
14:58:21 <ksf> McManiaC, fsync ensures all data is written to disk so the new file is actually what you want it to be, and if that's the case, you can safely move it to the location of your input file
14:58:32 <McManiaC> ksf: I dont want to depend on OS tools tho
14:58:39 <Saizan> ivanm: for latin1 you can just use BS.unpack on the bytestring
14:58:41 <ivanm> (I have as yet not found a nice approach to being able to definitely constrain it to utf8, in which case I'd disallow latin1
14:58:48 <ksf> there's haskell functions to abstract all that, I think.
14:59:00 <ivanm> Saizan: by default, dot, etc. use utf8; if you specify it though it can use latin1
14:59:00 <ksf> anyway, even without fsync, write to a different file.
14:59:05 <Saizan> ivanm: for utf8 there's utf8-string or Text or whatever
14:59:06 <Berengal> I still wish there was a strict readFile :: FilePath -> IO String...
14:59:06 <mm_freak> copumpkin: there is a constant factor of memory complexity added, when you use String
14:59:13 <mm_freak> and String is also much slower
14:59:19 <mm_freak> (in most cases at least)
14:59:20 <copumpkin> yeah, so as I said above, don't do it at all
14:59:25 <copumpkin> but if you do, the correct thing is rnf
14:59:29 <copumpkin> at a negligible extra cost
14:59:30 <Saizan> ivanm: the ByteString will contain the bytes as they are, if you set binary mode
14:59:30 <mm_freak> yes
14:59:42 <mm_freak> well, if you do it, the correct way is to process the data lazily =)
14:59:43 <ksf> McManiaC, http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-IO.html#v:openTempFile
14:59:48 <ivanm> Saizan: well, yes, but then I need to get the String out...
14:59:49 <copumpkin> mm_freak: or that :)
15:00:14 <Saizan> ivanm: yeah, Data.ByteString.Char8.unpack and then convert
15:00:19 <mm_freak> anyway, with today's ByteString support i see little reason to use String at all
15:00:24 <ivanm> how does one convert?
15:00:34 <mm_freak> the only advantage of String is pattern matching, but we have pattern guards =)
15:00:41 <Saizan> there are various encoding packages on hackage
15:00:50 <Saizan> for utf8 you can use utf8-string
15:01:15 <ksf> McManiaC, http://hackage.haskell.org/packages/archive/directory/1.0.0.3/doc/html/System-Directory.html#v%3ArenameFile
15:01:21 <Saizan> or you could use the text library, which comes with the basic encodings
15:01:38 <ivanm> saiam: tried text, it was slower than String :s
15:01:44 <ivanm> mm_freak: I need String for parsing purposes...
15:02:03 <ivanm> Saizan: I thought utf8-string was discouraged...
15:02:07 <ksf> McManiaC, http://hackage.haskell.org/packages/archive/cautious-file/0.1.5/doc/html/System-Posix-Fsync.html
15:02:20 <mm_freak> ivanm: what's wrong with using ByteStrings?
15:02:33 <ivanm> mm_freak: because I can't parse ByteStrings?
15:02:35 <McManiaC> ok wtf is a Fd
15:02:40 <mm_freak> ivanm: get parsec 3
15:02:45 <ivanm> mm_freak: I'm not using parsec
15:02:46 <copumpkin> ivanm: get a better parsing lib
15:02:50 <copumpkin> use Text
15:02:52 <ivanm> copumpkin: what's wrong with polyparse?
15:02:55 <ivanm> @slap copumpkin
15:02:55 <ksf> you can get one from your handle
15:02:55 * lambdabot throws some pointy lambdas at copumpkin
15:02:59 <copumpkin> ivanm: it only supports strings
15:03:00 <copumpkin> duh
15:03:01 <ivanm> already said why I'm not using Text
15:03:06 <ivanm> copumpkin: and I have no problem with that
15:03:09 <copumpkin> I missed that
15:03:13 <noggle> :t Just
15:03:14 <lambdabot> forall a. a -> Maybe a
15:03:25 <ivanm> copumpkin: using text was slower than using String
15:03:32 <ivanm> (though maybe I should have tried lazy text...)
15:03:33 <mm_freak> ivanm: any advantage of polyparse compared to parsec?
15:03:46 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.4.0.0/System-Posix-IO.html#v%3AhandleToFd
15:04:00 <copumpkin> ivanm: pff pff
15:04:02 <McManiaC> :i Fd
15:04:09 <McManiaC> @source Fd
15:04:09 <lambdabot> Fd not available
15:04:14 <McManiaC> @info Fd
15:04:14 <lambdabot> Fd
15:04:15 <noggle> what is Maybe for?
15:04:19 <ksf> newtype Fd = Fd CInt
15:04:20 <McManiaC> :(
15:04:23 <Saizan> ivanm: why should utf8-string be discouraged?
15:04:26 <noggle> just to write programs to ignore errors?
15:04:27 <ivanm> mm_freak: 1) the library was already using polyparse when I inherited it, 2) I hadn't used any parsing library beforehand so there was no real reason for me to switch it to parsec then, 3) from what I've seen polyparse is simpler in usage and design than parsec
15:04:33 <mm_freak> noggle: Maybe encodes possible absense of a value
15:04:42 <noggle> oh I see
15:04:43 <ivanm> Saizan: IIRC dcoutts said it was with the new locale stuff in 6.12
15:05:00 <Saizan> ivanm: only if you let the IO layer handle the decoding
15:05:07 <noggle> :t ('c', '')
15:05:08 <mm_freak> noggle: a value of type 'Maybe Int' is either Nothing or Just x, where x is of type Int
15:05:08 <lambdabot>     lexical error in string/character literal at character '\''
15:05:54 <Berengal> noggle: It's sort of like nullable values, except typesafe
15:05:56 <noggle> :t ('c', Nothing)
15:05:57 <lambdabot> forall a. (Char, Maybe a)
15:06:01 <mm_freak> ivanm: i'd like to try it, but if it doesn't support ByteStrings, it's already out
15:06:07 <noggle> right
15:06:07 <noggle> I see
15:06:13 <mm_freak> :t Just 3
15:06:14 <lambdabot> forall t. (Num t) => Maybe t
15:06:26 <monochrom> :t Just 'x'
15:06:27 <lambdabot> Maybe Char
15:06:29 <ivanm> mm_freak: I lie, looks like the latest version has bytestring support
15:06:32 <Berengal> > (+2) . Just 3
15:06:33 <lambdabot>   Just 5
15:06:48 <mm_freak> noggle: Maybe is a special case of lists:  you have either zero elements or one
15:06:50 <copumpkin> that distrubs me
15:06:54 <copumpkin> disturbs, even
15:06:57 <copumpkin> dist + urbs
15:06:59 <ivanm> it's an explicit Bytestring Parser instance of the PolyParse class
15:07:02 <copumpkin> city of distribution?
15:07:06 <noggle> :t Just []
15:07:07 <lambdabot> forall a. Maybe [a]
15:07:08 * Berengal read that as "that distributes me"
15:07:11 <mm_freak> ivanm: indeed
15:07:12 * monochrom distributes copumpkin
15:07:16 <mm_freak> well then i'll have a look at it
15:07:18 <mm_freak> is it fast?
15:07:19 <copumpkin> monochrom: over what?
15:07:24 <noggle> > Just []
15:07:25 <lambdabot>   Just []
15:07:29 <Berengal> copumpkin: A patch!
15:07:31 <ivanm> @tell malcolmw the documentation for the Parser type in the ByteString module in PolyParse looks wrong... ;-)
15:07:32 <lambdabot> Consider it noted.
15:07:37 <copumpkin> > Data.Traversable.sequence (Just [])
15:07:38 <lambdabot>   []
15:07:42 <monochrom> omnia seaculum et coelis
15:07:49 <ivanm> mm_freak: I haven't benchmarked it...
15:07:56 <copumpkin> seaculum = the ass of the sea?
15:08:02 <monochrom> haha
15:08:09 <copumpkin> :)
15:08:12 <mm_freak> ivanm: have you experienced performance problems when parsing larger bunches of text?
15:08:30 <ivanm> mm_freak: hmmm...
15:09:08 <ivanm> I had an experimental version of my graphviz library that allowed you to augment lists of graphs by passing it through dot; this ended up being slower than doing them one by one
15:09:30 <ivanm> I'm not sure if the fault was the parsing or (more likely) just getting the whole big String out of dot
15:09:43 <ivanm> after creating the whole big String to start with and pass it through
15:09:49 <etpace> @hoogle foldl1M
15:09:49 <lambdabot> No results found
15:10:00 <ivanm> mm_freak: but I'm pretty sure that it wasn't polyparse's fault for being slow
15:10:17 <mm_freak> well, you used String after all
15:10:21 <mm_freak> i'll give it a try
15:11:07 <mm_freak> perhaps [a] should become a data family
15:11:23 <copumpkin> I like [a]'s simplicity
15:11:31 <regalia> let (b,rest) = extract r elements
15:11:33 <copumpkin> if we want more efficient things I think we should use other types
15:11:39 <regalia> I don't understand that line =\
15:11:42 <Alpounet> mm_freak, in alt-stdlib, it might
15:11:49 <regalia> that whole let/in
15:11:50 <Alpounet> but not for a standard thing
15:12:00 <mauke> > let (x, y) = (2, 3) in x + y
15:12:01 <lambdabot>   5
15:12:13 <mm_freak> regalia: what's confusing you about it?
15:12:21 <regalia> *facepalm*
15:12:27 <regalia> I get it now...
15:12:38 <mm_freak> learn about pattern matching =)
15:12:57 <regalia> it's trying to sink in yet
15:13:01 <byorgey> Alpounet: certainly
15:13:02 <mm_freak> > let [x,y,z] = replicate 3 2 in x+y+z
15:13:03 <lambdabot>   6
15:13:09 <mm_freak> > let [x,y] = replicate 3 2 in x+y+z
15:13:10 <lambdabot>   * Exception: <interactive>:1:145-165: Irrefutable pattern failed for patter...
15:13:19 <regalia> :)
15:13:28 <mm_freak> uhm
15:13:33 <Alpounet> byorgey, I liked the simplicity, the style. So consider it done :-)
15:13:39 <byorgey> Alpounet: thanks =)
15:13:40 <mm_freak> that code wouldn't compile, if you had typed it in GHCi =)
15:13:46 <regalia> let [x,y] = replicate 10 2 in x+y
15:13:52 <mm_freak> yeah
15:13:52 <mauke> > let [x,y] = replicate 2 2 in x+y+z
15:13:53 <lambdabot>   2 + 2 + z
15:13:55 <regalia> > let [x,y] = replicate 10 2 in x+y
15:13:56 <lambdabot>   * Exception: <interactive>:1:149-170: Irrefutable pattern failed for patter...
15:14:02 <mauke> > let [x,y] = replicate 2 10 in x+y+z
15:14:03 <lambdabot>   10 + 10 + z
15:14:10 <Berengal> lambdabot wishes it had the typesafety of perl :)
15:14:24 <mm_freak> > let (x:_) = repeat 2 in 5*x
15:14:25 <lambdabot>   10
15:14:34 <Phyx-> perl has types?
15:14:48 <Berengal> Phyx-: Yes, but not many
15:14:56 <Alpounet> <olsner> "Trying to understand Perl that is already written is as fruitful as trying to recreate a dance from the dancers' footprints." :)
15:15:00 <mm_freak> > let Just (Right 4) = return . return 4 in ()
15:15:01 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:15:01 <lambdabot>    `Control.Monad.Error.Clas...
15:15:16 <mm_freak> > let Just (Right 4) = return . return $ 4 in ()
15:15:16 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:15:17 <lambdabot>    `Control.Monad.Error.Clas...
15:15:26 <Berengal> Is that @remembered?
15:15:27 <medfly> Alpounet, I believe they give numberd footprints in dance things sometimes
15:15:29 <Phyx-> Berengal: lol, so you're saying lamdabot wishes it was dumber?
15:15:43 <mm_freak> > let Just (Right 4) = return . return $ (4::Integer) in ()
15:15:44 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:15:45 <lambdabot>    `Control.Monad.Error.Clas...
15:15:49 <mm_freak> hmm
15:15:51 <Alpounet> medfly, imagine Perl doesn't even give an equivalent of numbering
15:16:00 <Alpounet> y'see the problem now ? :-p
15:16:04 <Alpounet> Berengal, I don't believe so
15:16:04 <mauke> Alpounet: then what would you say about Haskell?
15:16:12 <Berengal> Phyx-: No, I'm saying lambdabot is dumber than Perl. I'm also being facetious
15:16:19 <medfly> just pointing that out
15:16:32 <Alpounet> mauke, are you meaning Perl is easier to read & understand than Haskell ?
15:16:39 <mauke> Alpounet: yes
15:16:51 <Alpounet> honestly ?
15:17:02 <mauke> undecidable, depends on the code in question
15:17:13 <mauke> but you can write remarkably dense Haskell
15:17:21 <Alpounet> yeah
15:17:27 <chrissbx> Perl semantics is trivial compared to Haskell's.
15:17:46 <Alpounet> but I found average Haskell code to be much more readable than average Perl code
15:17:49 <ddarius> Perl's semantics are massively complicated compared to Haskell's.
15:17:56 <lament> haskell stuff is complicated because the concepts are complicated, not because the implementation is broken in arbitrarily strange ways
15:18:03 * mauke balances a tower of abstractions on his nose
15:18:04 <chrissbx> Or: the complexity of code commonly written in Perl is very "shallow".
15:18:06 <Berengal> chrissbx: Not at all. Haskell has very simple semantics. The complex stuff is what's on top of those semantics
15:18:34 <ddarius> chrissbx: Complexity of code written in a language /= complexity of language's semantics.
15:19:09 <monochrom> Oh I just watched the Olympics ice dance finals. Actually just the gold medal Canadian entry. Oh you can record the skating tracks left on the ice, hell let's even allow you to record velocity vectors. That still doesn't tell you what happened several times when suddenly the girl's tracks disappeared.
15:19:13 <Berengal> Does Perl even have semantics?
15:19:36 <mm_freak> PHP gets lambda functions, do you believe it?
15:19:45 <chrissbx> ddarius: yep, agreed. But see my second statement; I parsed "Perl is easier to read & understand" as "Perl *code* is..".
15:19:50 <lament> monochrom: sure it does
15:19:50 <Phyx-> oh god... php
15:20:07 <lament> monochrom: conservation of momentum
15:20:08 <Berengal> mm_freak: It's still php
15:20:13 <mauke> let me just say that Perl and Haskell are two of the few languages that let you write a function f such that g(...) == g(f(...))
15:20:16 <mm_freak> Berengal: of course
15:20:22 <monochrom> No, it doesn't tell you whether the guy held the girl in arms or on his back.
15:20:35 <mm_freak> knowing haskell coding in PHP is quite depressing and demotivating
15:20:40 <djahandarie> No tail recursion anyways
15:20:43 <djahandarie> mm_freak, welcome to my life
15:20:46 <chrissbx> (ddarius: of course it always depends: if you already know Haskell well, then I'm pretty sure reading Haskell code is faster than deducing what some Perl code means :)
15:20:48 <mm_freak> (in fact coding in any other language is)
15:22:07 <pikhq> Berengal: Perl has irregularly defined semantics.
15:22:09 <monochrom> Or alternatively if it could tell you that but you needed exponential-time computation to figure out, that's bad enough.
15:22:10 <Berengal> mm_freak: Yes. Learning Haskell was maybe the dumbest thing I ever did :(
15:22:25 <pikhq> (the full definition of Perl's semantics is, in fact, "whatever perl(1) does".)
15:22:37 <mm_freak> well, in haskell it's concise
15:22:41 <mm_freak> in perl it's just short =)
15:22:53 <mauke> pikhq: not true
15:23:02 <Berengal> pikhq: That's not the full definition. You also need to include a listing of perl(1).
15:23:05 <mauke> people fix bugs in perl
15:23:07 <Alpounet> mm_freak, the latter being pejorative ? :-p
15:23:13 <noggle> > let rle = map (length)
15:23:14 <lambdabot>   not an expression: `let rle = map (length)'
15:23:20 <pikhq> mauke: Thereby changing Perl's semantics.
15:23:20 <noggle> > rle = map (length)
15:23:21 <lambdabot>   <no location info>: parse error on input `='
15:23:51 <monochrom> "the semantics is what it does"? :)
15:23:58 <Berengal> noggle: let <id> <pattern*> = <expr> in <expr>
15:24:03 <mm_freak> Alpounet: well, have you ever read perl code, that is shorter than haskell and _not_ write-only? ;)
15:24:07 <noggle> > map (length) $ group [1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,22,2,3,2,3,23,23,23,23,23,2,2]
15:24:08 <lambdabot>   [11,6,1,1,1,1,1,5,2]
15:24:14 <pikhq> monochrom: Yes, it's almost a tautology. :)
15:24:16 <noggle> ohhh
15:24:35 <mm_freak> i find that irssi scripts are generally written very cleanly, and they aren't shorter than equivalent python programs would be
15:24:38 <mm_freak> and still python is more readable
15:24:49 <mauke> I find that irssi scripts are generally written very sloppily
15:25:01 <Alpounet> mm_freak, absolutely none
15:25:03 <mauke> no warnings, registering callbacks by name, etc
15:25:07 <mauke> global variables all over
15:25:09 <Alpounet> and I actually agree with you
15:25:40 <mauke> Alpounet: print "Hello, world!\n";
15:25:42 <mauke> now you have
15:25:53 <mm_freak> unfortunately that's how you do things in perl
15:25:58 <monochrom> the community is what its demography does
15:25:59 <mauke> mm_freak: no, it isn't
15:26:15 <mauke> irssi scripts are generally not written by members of the perl community
15:26:18 <mm_freak> mauke: that's what perl tutorials teach
15:26:29 <mm_freak> at least in my experience
15:26:30 <mauke> perl tutorials are generally not written by members of the perl community
15:26:36 <mm_freak> hehe ok
15:26:39 <mauke> sadly
15:27:09 <mm_freak> anyway, i have difficulty liking a language without ADTs
15:27:16 <mauke> sometimes I feel like any idiot with 3 cgi scripts under his belt has to write his own perl tutorial
15:27:36 <Berengal> I sort of like perl, actually. It's a nice language, in a quirky way. I wouldn't do large projects in it, but I don't really know it as well as I should either.
15:27:39 <MissPiggy> yeah once you get locked into one programming style it's hard to learn a new one
15:27:43 <mauke> well, nowadays it's mostly php, but the old tutorials from 1999 are still online
15:27:49 <monochrom> hash table with string keys is perl's sorry excuse for ADTs.
15:28:09 <mm_freak> indeed
15:28:13 <mm_freak> i switched from C to haskell
15:28:35 <pikhq> Berengal: Perl is decent as a Practical Extraction and Report Language.
15:28:40 <monochrom> haskell delivers people from hell
15:28:56 <Phyx-> that or drives them insane
15:29:02 <pikhq> Berengal: It is really quite awful for everything else.
15:29:20 <blackdog> mauke: like the way you have to write a monad tutorial as soon as you don't understand monads?
15:29:29 <mauke> blackdog: yeah, only worse
15:29:45 <mm_freak> i'd say perl is much better than sed+awk+head+tail+grep
15:29:51 <blackdog> pikhq: I did a biggish website in perl. It wasn't that bad.
15:29:51 <Berengal> pikhq: Well, I use it as a step up from bash, unless I feel pythonic. For anything I would never even consider writing in bash I use Haskell
15:29:53 <mm_freak> but not that good otherwise
15:30:11 <blackdog> and CPAN is the real reason, obviously.
15:30:28 <mauke> <insert mst quote>
15:30:38 <mauke> CPAN is my language, Perl is just syntax
15:30:46 <Berengal> mm_freak: Don't underestimate sed+awk+grep+bash
15:30:48 <pastorn> if i do
15:31:04 <monochrom> I do.
15:31:07 <pastorn> (Just v) <- gets (M.lookup k)
15:31:14 <pastorn> in a non-monadplus monad
15:31:24 <pastorn> what will happend when my pattern match fail?
15:31:28 <mauke> Berengal: tell me when you've implemented a heap using skew binomial trees in sed+awk+grep+bash :-)
15:31:37 <mm_freak> Berengal: for anything nontrivial i use haskell anyway =)
15:31:55 <monochrom> pastorn: It calls the «fail» method of your monad.
15:31:59 <Berengal> mauke: skew binomial trees? I thought everything was a string...
15:32:14 <mauke> exactly
15:32:19 <monochrom> Generally for all pattern-matching problems.
15:32:40 <pastorn> thanks :)
15:32:54 <Berengal> mm_freak: Yeah, me too, but don't expect everyone else to act like bash is horrible for doing large projects
15:33:00 <mm_freak> well, of course there are those people writing actual programs using bash and command line utilities
15:33:10 <mm_freak> but you know what scares me much more?
15:33:14 <McManiaC> hmmm
15:33:16 <mm_freak> people writing actual programs in M4!
15:33:32 <pastorn> in what?
15:33:36 <McManiaC> I get an error while waiting on a network socket:  <socket: 3>: hGetLine: invalid argument (Invalid or incomplete multibyte or wide character)
15:33:37 <Draconx|Laptop> M4 is much cleaner than bash, imo.
15:33:44 <ddarius> pastorn: The magical language behind automake.
15:33:47 <mm_freak> pastorn: the macro language M4
15:33:48 <Draconx|Laptop> autoconf.
15:33:49 <mm_freak> man m4
15:33:51 * hackagebot upload: glpk-hs 0.0.0 - Comprehensive GLPK linear programming bindings (LouisWasserman)
15:33:54 <mm_freak> autoconf uses it
15:33:55 <Draconx|Laptop> not automake.
15:33:57 <McManiaC> if I catch the error it will just happen again on the next try
15:34:00 * Phyx- wants to take the inventor of make out to the field and shoot him
15:34:17 <Berengal> mm_freak: Since I learned programming and how to read program source code I've become very distrustful of computer programs. Since I got hired at a company and got access to enterprise source code I've become very distrustful of enterprises...
15:34:28 <mm_freak> yes, M4 is turing-complete
15:34:29 <ddarius> Draconx|Laptop: Ah, yes.  That's what I meant.
15:34:32 <mm_freak> and yes, it's a nightmare
15:34:41 <sinelaw> ohhhhh yeah. this works. http://github.com/sinelaw/HOpenCV/blob/master/src/Test.hs
15:34:43 * Draconx|Laptop likes M4...
15:34:47 <monochrom> McManiaC: If you use GHC 6.12, this is probably because it expects correct utf-8 but it sees wrong things.
15:34:57 <mm_freak> you'd rather write brainfuck and end up with more readable code
15:35:00 <sinelaw> opencv, here I come.
15:35:08 <McManiaC> monochrom: yeh I'm using 6.12
15:35:13 <mauke> that reminds me, I have a brainfuck -> OISC compiler
15:35:20 <copumpkin> nice
15:35:24 <copumpkin> you should go both ways
15:35:25 <McManiaC> monochrom: is there a way to "skip" one char if that happens?
15:35:42 <monochrom> Not that I know of. Probably hard or impossible.
15:36:00 <Berengal> McManiaC: You could try setting the encoding of the handle somehow
15:36:07 <ddarius> Berengal: Programmers have the least faith in the computer revolution.
15:36:13 <ddarius> Berengal: That's why I'm a Luddite.
15:36:31 <Berengal> ddarius: Oh, I have much faith in the revolution I'm going to create :)
15:36:31 <monochrom> IMO you should just abort and give error message "this is not valid utf-8"
15:36:42 <Berengal> It's just everyone else's I'm distrustful about
15:37:08 <ddarius> Berengal: I don't even have much faith in the code I write.  More than most other people's code, yes, they're a bunch of idiots, but still not 100% in my own.
15:37:30 <ivanm> monochrom: and then he takes it to a machine that doesn't use utf-8 as its encoding... >_>
15:37:45 <sinelaw> chrisdone, check it http://github.com/sinelaw/HOpenCV/blob/master/src/Test.hs
15:37:48 <sinelaw> very initial stuff
15:37:55 <monochrom> I recently read some blog mentioning that, maybe, if programs rejected wrong input more rigorously, this world would not be in so much trouble.
15:37:58 <sinelaw> but works
15:38:21 <ddarius> monochrom: Of course that is the case, but the reason programs don't do that is programmers.
15:38:33 <mm_freak> ddarius: since you learned haskell, have you written code in C?
15:38:39 <mm_freak> it gets almost impossible
15:39:02 <mm_freak> when i write C code i keep emulating the Maybe monad everywhere, because i see potential bugs
15:39:04 <pikhq> mm_freak: The only C I've written since has been *ridiculously* functional.
15:39:06 <ddarius> mm_freak: I've never really written much C code.  A lot of C++ though, and I have written C++ code upon occassion after learning Haskell.
15:39:22 <aavogt> McManiaC: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23009#a23009
15:39:22 <McManiaC> Berengal: switching to binary mode, calling getChar and switching back solved it somehow… now idea if thats the ideal way
15:39:26 <mm_freak> pikhq: yes, mine too
15:39:28 <pikhq> (like, actual freaking *closures*)
15:39:44 <ddarius> mm_freak: It would be really nice if mainstream languages got rid of implicitly nullable values everywhere.
15:39:45 <mm_freak> withFile(const char *fileName, void (*k)(FILE *));
15:39:46 <aavogt> this will of course fail to properly interpret high utf8 chars
15:39:46 <mm_freak> =)
15:40:03 <pikhq> mm_freak: I wrote a lambda macro.
15:40:27 <mm_freak> i'd write a wrapper function rather than handling files and memory explicitly
15:40:28 <pikhq> (incidentally, C blocks are much more sane.)
15:41:00 <mm_freak> ddarius: it would be really nice if mainstream libraries would get rid of side effects
15:41:13 <mm_freak> PHP is about the worst example i know in this regard
15:41:17 <monochrom> ddarius: So let me correct. If programmers insisted more on their programs rejecting wrong input, this world would not be in so much trouble.
15:41:26 <mm_freak> no matter what you want to compute, you never compute it directly, but use side effects
15:42:05 <mm_freak> monochrom: well, the problem is that most people don't know the value of correct typing
15:42:46 <ddarius> monochrom: I agree heartily.
15:43:01 <monochrom> The context of that blog is web browers. Trying to forgive errors in html code, and trying to guess what the html author "meant to do", is both extra work for web browser programmers and short-sighted.
15:43:06 <MissPiggy> if everything switched instantly you'd have breakage
15:43:31 <ddarius> MissPiggy: See "short-sighted"
15:43:48 <mm_freak> at least most of today's languages use exceptions instead of return values or interrupt signals
15:43:50 <MissPiggy> I dont get it
15:44:01 <Berengal> monochrom: You have to forgive in html though, because it's too easy for clueless lusers to break eachother's dynamic pages
15:45:05 <McManiaC> aavogt: http://npaste.de/Hc/ :)
15:45:14 <[swift]_> w.r.t. web browsers this is pretty much the debate between HTML and XHTML
15:45:34 <Berengal> [swift]_: And xhtml lost badly
15:45:45 <lament> worse is better
15:45:48 <[swift]_> Berengal: indeed, which many people think is too bad
15:45:51 <sinelaw> war is peace
15:46:09 <monochrom> free as in variable
15:46:31 <c_wraith> we're all free (variables)
15:46:48 <Berengal> c_wraith: bound by the closure that is life?
15:46:55 <lament> html is very ugly, but it's not as ugly as for example cellular biology. All successful complicated systems are ugly. It's a law of nature and a basic consequence of evolution.
15:47:27 <lament> (because evolution never designs up-front)
15:47:41 <monochrom> Anyway, I just want to say, why try to recover from decoding errors. You observe invalid utf-8, you should just report it and abort. The Perl spirit of "be forgiving in input" has undesirable ramifications in the long run.
15:47:51 <mlh> getting stuck in local minima is better than dieing
15:47:59 <lament> indeed
15:47:59 <[swift]_> lament: by that metaphor i suppose XHTML would be "intelligently designed" haha
15:48:01 <Twey> .ie
15:48:05 <Berengal> monochrom: Unless you shouldn't be expecting utf-8
15:48:18 <monochrom> Right of course.
15:48:20 <Draconx|Laptop> monochrom, what a waste of UTF-8's error recovery features.
15:48:42 <MissPiggy> i have no idea
15:48:44 <MissPiggy> what so ever
15:50:05 <Berengal> monochrom: Also, if you can't connect to A because he sends invalid tokens then that's a bug. However, if you can't fix A you have to fix your own program, assuming your program would be useless if it couldn't connect to A
15:50:30 <Berengal> Or the cost of buggering your own program is less than the cost of not being able to connect to A
15:50:56 <Berengal> (Or pestering someone else to fix A)
15:51:46 <Adamant> monochrom: that thesis is probably correct, but it's also fairly useless - the "be conservative in what you send and liberal in what you accept" principle is responsible for a lot of crap, but is also probably one of the main reasons stuff like the Internet got off the ground.
15:51:51 <Berengal> In short... commercial programming hasn't improved my faith in humanity...
15:52:53 <Adamant> we know worse is better in some respects, the question is how do you make better better in the respects that worse is?
15:53:59 * hackagebot upload: hsdns 1.4.2 - Asynchronous DNS Resolver (PeterSimons)
15:55:52 <[swift]_> maybe i'm wrong, but i think of "worse is better" as a consequence of popularity - once something becomes popular its hard to change, and people introduce all sorts of extensions to meet their needs
15:56:10 <Adamant> that's not the thesis that was being argued
15:56:21 <[swift]_> therefore unless it was truly PERFECT from the get-go, better things that become popular become worse with time
15:56:25 <Adamant> at the time C was developed Lisp was hands down more popular
15:57:44 <ivanm> preflex: seen kowey
15:57:44 <preflex>  kowey was last seen on #haskell 19 days, 7 hours, 28 minutes and 27 seconds ago, saying: is sam hughes (keeper of the YAHT) around?
15:57:58 <Adamant> not saying your interpretation couldn't include that, but that's not what I read in the Gabriel paper.
15:58:57 <[swift]_> Adamant: i missed the beginning of the conversation so I can't comment on the Gabriel paper =)
15:58:58 <noggle> hey I have a question
15:59:05 <alex404> Do people have an opinion on using cabal vs pacman (arch linux) for pulling packages?
15:59:15 <alex404> Both have been problematic
15:59:16 <noggle> I see that functions with no arguments get arguments sometimes
15:59:29 <monochrom> example?
15:59:32 <noggle> uhh
15:59:34 <noggle> one sec
16:00:07 <noggle> foldLen = foldr (\_ x -> x + 1) 0
16:00:26 <pikhq> mm_freak: Man. C actually looks much nicer when you write wrappers like that.
16:00:31 <monochrom> foldr wants 3 arguments. By writing that line, foldLen is still missing 1 argument.
16:00:35 <damd> alex404: i like cabal way better than pacman (yaourt (tupac))
16:00:46 <monochrom> The syntax just doesn't say it. But the type does.
16:00:48 <noggle> okay
16:00:50 <noggle> I understand
16:00:54 <noggle> so like a lambda in python
16:00:58 <monochrom> Yes.
16:01:04 * noggle is a noob
16:01:06 <noggle> thanks monochrom
16:02:18 <alex404> damd: I've had a lot of issues resolving dependencies with cabal though.
16:02:22 <ivanm> alex404: I prefer system packages over user-installed packages because then the documentation, etc. is installed in the correct location
16:02:23 <chrisdone> are russian dolls a good analogy for lists?
16:02:40 <roconnor> it's not a terrible analogy
16:02:40 <ivanm> then again, this is on a single user machine, and I help write the haskell ebuilds for gentoo :p
16:02:45 <damd> alex404: i've had no problems at all with cabal that arch linux could help me with
16:02:51 <monochrom> Not a good analogy.
16:03:11 <alex404> ivanm: So you'd go with pacman?
16:03:20 <alex404> ivanm: /whatever script
16:03:29 <ivanm> well, I go with portage/paludis/pmerge, but yes :p
16:03:34 <noggle> monochrom: I was trying to make a rle
16:03:45 <noggle> and trying to understand nub
16:03:52 * ivanm hates it when babushka dolls are categorised as "russian dolls"
16:03:54 <noggle> thanks
16:04:27 <ivanm> damd: system packages can bring in any C libs that are needed, etc.
16:04:43 <damd> ivanm: i don't know, i just never had any problems whatsoever with cabal-install
16:04:46 <chrisdone> ivanm: why?
16:04:59 <ivanm> what is better with cabal-install is that atm the gentoo package manager specification doesn't allow for ranged dependencies :@
16:05:07 <ivanm> chrisdone: because they're not just russian
16:06:39 <alex404> I've had issues with both cabal and arch packaging, but it sounds like they have some new method of releasing their ghc packages on arch, so I'm going to give it a shot.
16:06:43 <monochrom> A modified system of those dolls in which a doll has a candy and a doll is closer to cons lists, but I still doubt the value of it.
16:13:04 <abbe> Hi everyone
16:13:05 * hackagebot upload: hsyslog 1.4 - FFI interface to syslog(3) from POSIX.1-2001. (PeterSimons)
16:13:26 * ivanm waves idly in abbe's general direction
16:13:55 * abbe responds with directed waves.
16:14:06 <heatsink> I hoogled (a -> (b -> c) -> c) -> ([a] -> ([b] -> c) -> c) and got one exact match.  I was not expecting this to work!
16:14:07 <noggle> what is the best place for a person who has not attended nor graduated from college to read about the IO monad?
16:14:08 <abbe> how does let, and where blocks get executed.
16:14:31 <heatsink> noggle: Maybe RWH?
16:14:33 <heatsink> @where RWH
16:14:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:14:36 <abbe> I mean, I've a function, fn :: StateT a IO a, and in let block, I'm using 'get'
16:14:41 <noggle> alright, I actaully have that book
16:14:50 <noggle> that convex hull problem was cool
16:15:04 <abbe> And I get this error: httpd2.hs:104:23: No instance for (MonadState HttpRequestState m) arising from a use of `get' at httpd2.hs:104:23-25
16:15:07 <ivanm> noggle: do you want the monadic context or the "how do I do IO in Haskell"?
16:15:33 <ivanm> if the latter, there are several non-monadic IO tutorials out there (by Axman6 and I believe mmorrow)
16:16:01 <ivanm> abbe: I think you want to use get in a do block
16:16:09 <ivanm> use let to define pure values within a do block
16:16:39 <heatsink> abbe: In a let block, 'get' defines an action.  To run the action, you have to insert it into a do block.
16:16:43 <mm_freak> pikhq: don't ever say that in comp.lang.c ;)
16:16:57 <mm_freak> it causes a flamewar you've never seen before
16:16:57 <pikhq> mm_freak: Heheheh.
16:17:01 <abbe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23010#a23010 <<< this is the code
16:17:03 <pikhq> static void withFile(const char *filename, const char *open, void (^f)(FILE *))
16:17:10 <pikhq> This is so much cleaner, though.
16:17:11 <ivanm> what did pikhq say?
16:17:23 <pikhq> ivanm: Wrapper functions make C look nicer.
16:17:28 <ivanm> ahhh
16:17:34 <pikhq> I pasted an example.
16:18:01 <pikhq> (to use as C99, replace ^ with *, and optionally add a context argument so you can manually do closures)
16:18:57 <[swift]_> pikhq: is there somewhere i can read about this ^ feature? i've never seen it before
16:19:04 <abbe> I'm just trying to understand how to use state monads.
16:19:17 <pikhq> [swift]_: It's an Apple extension to C. Google "C blocks".
16:19:18 <heatsink> abbe: You're not using 'f' anywhere, so it's not connected to your state monad at all.
16:19:25 <[swift]_> pikhq: thanks!
16:19:30 <pikhq> [swift]_: In essence, it's lambda for C.
16:19:54 <pikhq> (it's called blocks because Apple has a fondness for Smalltalk terminology)
16:22:16 <abbe> heatsink: and now, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23010#a23011 ?
16:22:54 <heatsink> abbe: You have to run the computation and pass its result to something.
16:23:40 <heatsink> fileDoHEAD' = get >>= return . fileExist . hrsPathName >>= liftIO >>= \x -> if x then ... else ...
16:23:46 <abbe> heatsink: you mean that 'let f = ...' doesn't get executed in StateT context ?
16:24:03 <heatsink> abbe: Do you know what the >>= operator does?
16:24:34 <Zao> abbe: It just names a bunch of expressions, maybe matching a bit.
16:24:36 <abbe> heatsink: yes, I know, thats the 'bind' operator, it passes result of lhs function to rhs function
16:24:39 <heatsink> No, let f = simply defines a monadic value.
16:24:44 <jlouis> heatsink: that is a nasty trick question. the >>= operator depends on the type class :)
16:24:44 <heatsink> > let x = print "ABCDEFG" in ()
16:24:45 <lambdabot>   ()
16:24:52 <Zao> Anything it "runs" is quite pure.
16:25:17 <heatsink> abbe: Note that lambdabot didn't print "ABCDEFG".
16:25:27 <Zao> let (x,y) = (print "omg", Just 9) in 9001
16:25:29 <copumpkin> Alpounet: your RLE can be made shorter!
16:25:29 <Zao> > let (x,y) = (print "omg", Just 9) in 9001
16:25:30 <lambdabot>   9001
16:25:41 <abbe> > let x = print "ABCDEFG" in x
16:25:42 <lambdabot>   <IO ()>
16:25:46 <Zao> @type (print "omg", Just 9)
16:25:47 <lambdabot> forall t. (Num t) => (IO (), Maybe t)
16:25:49 <damd> > let (x, y) = (y, x) in x
16:25:53 <lambdabot>   mueval-core: Time limit exceeded
16:25:56 <damd> snap
16:25:59 <copumpkin> Alpounet: the way I normally write it is (length &&& head) because then you can use uncurry replicate on the reconstruction :)
16:26:07 <copumpkin> Alpounet: the sublists generated by group are guaranteed to be non-empty
16:26:15 <heatsink> abbe: lambdabot won't run IO actions for safety reasons.  But as you can see, x is an unevaluated IO action.
16:26:46 <damd> > let 1 + 2 = 5 in 1 + 2 - 2 + 1
16:26:47 <lambdabot>   * Exception: <interactive>:1:165-173: Non-exhaustive patterns in function +
16:26:53 <damd> oh, right...
16:27:04 <abbe> > let x = get >>= (\x -> put (x + 1)) >> get >>= return in x
16:27:05 <lambdabot>   No instance for (GHC.Show.Show (m a))
16:27:06 <lambdabot>    arising from a use of `M2625367206...
16:27:11 <abbe> > let x = get >>= (\x -> put (x + 1)) >> get >>= return in print x
16:27:12 <lambdabot>   No instance for (GHC.Show.Show (m a))
16:27:13 <lambdabot>    arising from a use of `System.IO.p...
16:27:28 <abbe> > let x = (get >>= (\x -> put (x + 1)) >> get >>= return) :: State Int Int in print x
16:27:29 <lambdabot>   No instance for (GHC.Show.Show
16:27:29 <lambdabot>                     (Control.Monad.State.Laz...
16:27:39 <abbe> > let x = (get >>= (\x -> put (x + 1)) >> get >>= return) :: State Int Int in print (evalState x 30)
16:27:41 <lambdabot>   <IO ()>
16:27:57 <heatsink> > runState (get >>= (\x -> put (x + 1))) 100
16:27:58 <lambdabot>   ((),101)
16:28:24 <abbe> > :t let x = (get >>= (\x -> put (x + 1)) >> get >>= return) in print x
16:28:25 <lambdabot>   <no location info>: parse error on input `:'
16:28:30 <abbe> >:t let x = (get >>= (\x -> put (x + 1)) >> get >>= return) in print x
16:28:43 <abbe> @type let x = (get >>= (\x -> put (x + 1)) >> get >>= return) in print x
16:28:44 <lambdabot>     No instance for (Show (m a))
16:28:44 <lambdabot>       arising from a use of `print' at <interactive>:1:59-65
16:28:44 <lambdabot>     Possible fix: add an instance declaration for (Show (m a))
16:29:48 <noggle> ivanm: I am looking for the one that will make me a better haskell programmer
16:29:49 <heatsink> :t get >>= put
16:29:50 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => m ()
16:29:54 <Alpounet> copumpkin, oh
16:29:55 <Alpounet> hmm
16:29:57 <heatsink> :t runState (get >>= put)
16:29:58 <lambdabot> forall s. s -> ((), s)
16:30:03 <heatsink> :t runState (get >>= put) 0
16:30:04 <lambdabot> forall s. (Num s) => ((), s)
16:30:12 <Alpounet> yeah it's shorter but more or less the same to me
16:30:17 <copumpkin> Alpounet: :)
16:30:29 * copumpkin 's e-penis is shorter than Alpounet's
16:30:55 <Alpounet> :x
16:31:07 <heatsink> abbe: (get >>= put) is an action.  If you want to run the action, you have to run it.
16:31:20 <abbe> heatsink: that part, I understand
16:31:24 <copumpkin> get >>= put is a really useful action
16:31:31 <doserj> *cough*
16:31:47 <copumpkin> almost as useful as return ()
16:31:47 <heatsink> copumpkin: Of course!  Otherwise, how will you know that the state is still there?
16:31:53 <abbe> heatsink: the question is how things get change when I put them in 'let' block
16:32:32 <heatsink> They don't change.  if you say let {x = get >>= put} in ..., then x is still an action.
16:32:33 <abbe> heatsink: as you pointed this will work: 'get >>= return . fileExist . hrsPathName >>= liftIO >>= \x -> if x then ... else ... ' and not mine
16:32:48 <chrissbx> Is there another check for equality than == ? i.e. one that doesn't require implementing a comparison function oneself
16:33:02 <Zao> chrissbx: You can always derive Eq.
16:33:05 <chrissbx> Or, should I just  aha.
16:33:30 <Zao> @type compare
16:33:31 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:33:44 <Zao> Or if you have an Ord instance, compare maybe.
16:33:49 <chrissbx> I wonder why types don't inherit from Eq and Show (and others?) automatically?
16:33:56 <Zao> > compare 9 9001
16:33:57 <lambdabot>   LT
16:34:07 <Zao> chrissbx: Then you couldn't define your own instances.
16:34:16 <abbe> heatsink: what type does that 'f' function in my code gets ?
16:34:28 <aavogt> and it isn't always possible to derive those instances either
16:34:44 <chrissbx> aha. Yeah I noticed that actually; so it's not your typical OO method overriding.
16:34:44 <heatsink> abbe: f has exactly the same type as the expression on the RHS
16:34:54 <heatsink> abbe: In this case, it's some kind of state monad
16:35:00 <heatsink> abbe: In this case, it's some kind of state monad value
16:37:09 <abbe> heatsink: but it doesn't get evaluated in same monadic context as the code in 'in' block
16:37:15 <abbe> right ?
16:37:16 <heatsink> abbe: The error message says that "if" expects a Bool, but it got an unevaluated action of type `m Bool'
16:37:35 <philo> hi
16:37:50 <abbe> heatsink: yes, thats is unevaluated because thats different monadic context, thats my guess is.
16:37:53 <heatsink> abbe: Right.  Though an 'in' block doesn't evaluate monads either.
16:37:55 <noggle> hi
16:38:16 <philo> can someone point me to the do about spanning one module between several file ?
16:38:18 <abbe> heatsink: thanks for the confirmation
16:38:36 <abbe> heatsink: where does these 'let' and 'where' blocks stand in mathematical functions ?
16:38:56 <heatsink> abbe: What do you mean by mathematical functions?
16:38:57 <copumpkin> philo: /dev/null
16:39:11 <copumpkin> philo: if you really must, use the c preprocessor
16:39:11 <philo> lol ? is it possible ?
16:39:21 <copumpkin> philo: CPP is the closest you're going to get
16:39:25 <copumpkin> or a custom preprocessor
16:39:44 <philo> ok i read somewhere that it was possible to do so
16:39:54 <philo> so i guess it really isnt right ?
16:40:07 <blackh> philo: You're not talking about recursive module dependencies? (guess)
16:40:10 <abbe> heatsink: i meant the definitions of 'let' and 'where' aren't part of actual function, right ?
16:40:23 <philo> http://www.google.ca/search?q=haskell+module+several+file&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:fr:official&client=firefox-a : first link
16:40:24 <abbe> s/of/in/
16:40:26 <blackh> philo: Sorry, I mean cyclic
16:40:53 <philo> blackh:
16:41:06 <heatsink> abbe: To be clear, the only keyword that "knows" about monads is "do".  Other parts of Haskell handle monad values the same way as other values.
16:41:08 <philo> and to solve the probleme i decide to fuse the two module
16:41:17 <blackh> philo: I think that page is talking about some imaginary compiler, based on what haskell98 standard specifies.
16:41:18 <heatsink> abbe: They are part of the function.
16:42:03 <blackh> philo: "A Gentle Introduction to Haskell" is quite old
16:43:01 <abbe> heatsink: okay got it, they're just definitions. and not invoked until you refer them in your function body. right ?
16:43:12 <philo> ok thkans
16:44:20 <heatsink> They're only invoked by (>>=) and a few other functions, like runState.
16:46:00 <heatsink> The expression "m1 >>= \x -> m2" is an action.  Invoking the action causes m1 and m2 to be invoked.  However, putting it in a function body doesn't cause it to be invoked.
16:47:25 <heatsink> For example, I can write a new function that calls your fileDoHEAD'
16:47:44 <heatsink> myCallingFunction = let x = fileDoHead' in ()
16:48:11 <heatsink> Then fileDoHead' returns an action, which never gets invoked, so it never gets run.
16:48:24 <abbe> yes, I got it now, thanks heatsink :)
16:48:35 <heatsink> you're welcome
16:59:51 <regalia> I'm trying to fill a list with random numbers.
16:59:56 <regalia> using randomRIO
17:00:13 <ivanm> better idea: don't
17:00:22 <ivanm> either get the seed and use randomRs
17:00:26 <aavogt> @type randomRIOs
17:00:27 <lambdabot> Not in scope: `randomRIOs'
17:00:29 <ivanm> or else get a better PRNG
17:00:32 <ivanm> @hoogle randomRIO
17:00:33 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
17:00:48 <regalia> ivanm: ok, regardless of the method of getting the numbers, how would I put x amount into a list
17:01:08 <noggle> see you guys later
17:01:12 <noggle> :q
17:01:17 <ivanm> regalia: take x $ randomRs seed
17:01:22 <ivanm> oh, that's not right
17:01:31 <ivanm> take x $ randomRs (a,b) seed
17:01:35 <c_wraith> replicateM x randomR
17:01:46 <ivanm> c_wraith: why the M ?
17:01:53 <c_wraith> err
17:01:55 <c_wraith> replicateM x randomRIO
17:01:57 <ivanm> and that won't type check ;-)
17:02:11 <ivanm> @type \ x -> replicateM x randomRIO
17:02:12 <lambdabot> forall a. (Random a) => Int -> (a, a) -> [IO a]
17:02:26 <ivanm> unless you want a sequence there as well...
17:02:30 <ivanm> @type \ x -> replicateM x . randomRIO
17:02:31 <lambdabot> forall a. (Random a) => Int -> (a, a) -> IO [a]
17:02:38 <ivanm> ^^ that's probably what you meant
17:02:53 <regalia> Thanks guys :)
17:02:58 <aavogt> > replicateM 10 succ 0
17:02:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
17:03:18 <ivanm> aavogt: identity monad?
17:03:26 <aavogt> function monad
17:03:35 <aavogt> from a specific argument type
17:03:45 <ivanm> aha
17:06:08 <roconnor> http://www.reddit.com/r/haskell/comments/b6af6/ddc_haskell_strictness_effects_updates/c0l7p0w
17:07:36 <ivanm> roconnor: yay for tying the knot! \o/
17:07:52 <ivanm> roconnor: in cases where I've used that technique, I have nfi how I'd do it in an imperative language :s
17:08:38 <heatsink> ivanm: I've done it by rolling my own dataflow variables.
17:08:48 <ivanm> *shudder*
17:08:56 <ivanm> whereas in Haskell you get it _for free_!
17:09:01 <ivanm> and everyone loves free stuff!
17:09:57 <roconnor> ivanm: I'm I right in thinking that the Lazy module in ocaml wouldn't help here?
17:10:06 <chrissbx> How do you comment out a whole region of code?
17:10:06 <ivanm> roconnor: never touched ocaml ;-)
17:10:16 <ivanm> chrissbx: {- ... -}
17:10:17 <heatsink> chrissbx: Use CPP
17:10:17 <roconnor> chrissbx:  {-  code  -}
17:10:24 <roconnor> don't use CPP
17:10:38 <heatsink> But the other solution is too simple.
17:10:45 <roconnor> Haskell has nested comments right?
17:10:48 <heatsink> Yes
17:10:52 <roconnor> dont' use CPP
17:10:56 <roconnor> :
17:10:56 <ivanm> or else C-space, C-down a few times, M-x comment-region :p
17:10:57 <roconnor> :D
17:11:04 <ivanm> @slap heatsink
17:11:04 <lambdabot> *SMACK*, *SLAM*, take that heatsink!
17:11:10 <heatsink> ow!
17:11:14 <heatsink> okay, ill be good
17:11:17 <copumpkin> > replicateM 10 runIdentity (Identity 1) -- quick, which monad?!
17:11:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
17:11:22 <aavogt> ?slam \bot
17:11:23 * lambdabot activates her slap-o-matic...
17:11:23 * sm prefers M-;
17:11:47 <heatsink> I want to use the same data constructors both recursively and nonrecursively
17:11:53 <copumpkin> BZZZT
17:11:56 <copumpkin> time expired
17:11:56 <heatsink> Recursively to build a recursive data structure
17:12:19 <heatsink> Nonrecursively so that I can fold a function over the data structure
17:12:34 <roconnor> heatsink: are you just stringing random words together?
17:12:44 <heatsink> The solution I came up with is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23012#a23012
17:12:45 * roconnor is so confused
17:12:58 <heatsink> It works, but the types are rather complicated.
17:13:21 <roconnor> sounds like you need a zygohistomorphic prepromorphism
17:13:47 <heatsink> I'm not making this up, really.
17:13:48 <roconnor> Used when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor.
17:14:26 <Adamant> I would like to believe you are just inventing that name out of thin air but sadly I've read a table listing those kinds of things and it sounds as real as the rest.
17:14:42 <copumpkin> @remember roconnor sounds like you need a zygohistomorphic prepromorphism
17:14:42 <lambdabot> It is forever etched in my memory.
17:14:44 <roconnor> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
17:14:46 <chrissbx> Something like Perl's __END__ would be cool, too (comment out from __END__ to the end of the file); it would make temporarily deactivating new buggy code at the end easy.
17:15:01 <roconnor> zygohistomorphic_prepromorphism f = g_prepro (distZygoT (liftAlgebra f) (distHisto id))
17:15:16 <copumpkin> I once actually worked through that definition
17:15:22 <copumpkin> I have forgotten it all now though
17:15:32 <copumpkin> I only go as far as histo these days
17:15:32 <bjorkintosh> is 'a gentle introduction to haskell' still worth reading?
17:15:35 <bjorkintosh> it looks a bit dated.
17:15:37 <Adamant> roconnor: I think we're getting to the "now you have two problems" point with Latinate/Greek combination words for technical fields
17:15:43 <copumpkin> bjorkintosh: best into to haskell is category-extras
17:16:01 <bjorkintosh> category-extras?
17:16:02 <bjorkintosh> what's that?
17:16:11 <copumpkin> it's an educational library on hackage
17:16:13 <roconnor> bjorkintosh: everyone reads "learn you a haskell for great good" today
17:16:17 <copumpkin> it teaches you all the fundamentals
17:16:38 <bjorkintosh> hmm.
17:16:43 <copumpkin> just kidding :)
17:16:56 <roconnor> heatsink: whoa, data family
17:17:00 <theorbtwo> In unreadable Engrish, or in mocking irony?
17:17:00 <copumpkin> it's one of the most obscure libraries ever
17:17:11 <bjorkintosh> thanks.
17:17:16 <bjorkintosh> i would have hurt my head for nothing.
17:17:42 <monochrom> newtype FIX f = FIXCtor (f (FIX f)); data Example a more = Nada | Yes a more; type HomebrewList a = FIX (Example a)
17:17:43 <Cale> heatsink: Do you have an example where you do something fancier than an ordinary fold over the tree structure?
17:17:58 <Cale> Or... is that all this is?
17:19:10 <heatsink> Cale: There are several data types in the recursion.  I also have a use where the first level of the data structure (only) has a wrapper around it.
17:19:33 <heatsink> Cale: My data type is a dependently typed language.
17:19:34 * copumpkin thinks regular data syntax and GADT syntax should be replaced by data families
17:19:42 <Cale> hmm
17:19:58 <heatsink> Cale: the wrapper data type is a substitution, because while processing the data type, I need to rename variables.
17:20:42 <heatsink> So on the recursive trip down, I rename fresh variables in the outermost constructor, update the substitution, and then push it down one level.
17:21:23 <heatsink> In situations when I'm also doing a fold, I replace subexpressions with the fold's result on the way up.
17:23:03 <heatsink> I think the binary tree conveys the motivation, though.
17:23:52 <heatsink> The usual approach is to have one data type for the tree, and convert it to a different data type to pass it to the fold's worker function.
17:24:05 <heatsink> However, this leads to a lot of replicated structure between the two data types.
17:24:30 <heatsink> There Should Be a Better Way.
17:24:42 <copumpkin> A PREPROCESSOR
17:27:36 <bjorkintosh> roconnor, thanks. i think i like learnyouahaskell...etc.
17:30:32 <dolio> I think the protips in LYAH may be too helpful.
17:31:22 <tensorpudding> too helpful?
17:31:43 <dolio> I thought the quintessential protip was something like "PROTIP: To defeat the Cyberdemon, shoot at it until it dies."
17:31:58 <copumpkin> protips do tend to be sarcastic
17:32:04 <copumpkin> at least real protips
17:32:28 <copumpkin> but I've seen more and more of them be actually helpful, which makes me sad
17:32:59 <monochrom> To fix program bugs, delete the programs.
17:33:35 <bjorkintosh> monochrom, that's quite accurate. there were no computer bugs before computers introduced them.
17:33:39 <monochrom> To find more time for haskell or family, quit IRC.
17:33:45 <c_wraith> protip: dig a direct path between stairways on every level
17:33:59 <theorbtwo> c_wraith: EWRONGCHANNEL
17:34:08 <Cale> Bug #0: Computer fails to exist.
17:34:19 <copumpkin> fix (\protip -> protip: make protip more sarcastic)
17:34:28 <monochrom> To correct people who are wrong on the Internet, discontinue Internet service.
17:35:36 <Zao> monochrom: Preferably theirs.
17:36:10 <monochrom> To debug lazy space leaks and lazy time leaks, give your program to me and money, CDN$100 per lexical token in the program.
17:36:26 <Phyx-> monochrom: quit irc is harsh.. just detach screen
17:36:41 <monochrom> I don't use screen for IRC anyway.
17:36:59 <Phyx-> :O
17:37:13 <monochrom> Why are you surprised? Or whatever :O means.
17:37:33 <dolio> monochrom has IRC commands piped directly to his brain, like Johnny Mnemonic.
17:37:37 <bjorkintosh> what's the difference between using "let something = [1..10]" and "somethingtoo = [1..10]?
17:37:53 <copumpkin> wow, you've actually seen that movie
17:37:53 <Phyx-> screen + irssi = best thing since lamda calculus
17:37:59 <dolio> Who hasn't?
17:38:03 <monochrom> Are you so narrow-minded that you think the whole world are irssi lunatics and screen zealots?
17:38:24 <monochrom> It doesn't have to do with what is "best", does it?
17:38:31 <Phyx-> monochrom: well.. and bitchx...
17:38:46 <monochrom> I use XChat and a bouncer.
17:38:55 <tensorpudding> bounce bounce
17:38:58 <monochrom> Best thing since screen.
17:39:02 <Phyx-> I used to use XChat
17:39:13 <monochrom> I used to use 1970 terminals.
17:39:15 <Phyx-> till they started charging for windows builds
17:39:37 <heatsink> monochrom: How did you keep track of them all?
17:39:39 <tensorpudding> i use erc, for reasons
17:39:48 <monochrom> I use the silverX build when in windows. Or just run linux in virtualbox.
17:40:14 <Phyx-> I just use irssi or a telnet client
17:40:17 <monochrom> heatsink: sorry, what is "them"?
17:40:23 <heatsink> the terminals
17:40:39 <tensorpudding> i do like being able to copy code that i'm editing into an irc channel without going through middlemen
17:40:39 <heatsink> nevermind
17:41:08 <Phyx-> which client has you going through a middleman?
17:41:13 <monochrom> I didn't use a wide variety of 1970 terminals. Within the small variety, they're all VT100-compatible so I learned just one skill.
17:41:49 <tensorpudding> my old system of editor + (screen + irssi) meant i had to copy them to the clipboard and middle-click paste into the window
17:42:00 <DerisionSnort> @src tails
17:42:01 <lambdabot> tails []         = [[]]
17:42:01 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
17:43:07 <Phyx-> hrm... I wonder.. If MacGyver could do haskell
17:43:21 <ivanm> nah
17:43:30 <ivanm> how would he cope without having to use a pocket knife?
17:43:31 <ivanm> ;)
17:43:32 <tensorpudding> macguyver used perl exclusively
17:43:49 <ivanm> and kludged some code together whenever he needed it!
17:43:56 <tensorpudding> yes, well
17:44:02 <Phyx-> ivanm: he could use the pocket knife to make the keyboard :P
17:44:06 <tensorpudding> it's not like he wanted to make anything that would stay the test of time
17:44:13 <ivanm> who cares if it was unreadable; it's not like he'd be trapped in exactly the same situation again...
17:44:20 <ivanm> Phyx-: heh
17:44:21 <Phyx-> lol
17:44:36 * theorbtwo hugs his swiss army chainsaw.
17:44:40 <monochrom> He used it to blow up locked doors anyway.
17:44:49 <ivanm> preflex: seen Cale
17:44:50 <preflex>  Cale was last seen on #haskell 10 minutes and 42 seconds ago, saying: Bug #0: Computer fails to exist.
17:44:57 <ivanm> oh, he is around! \o/
17:45:08 <ivanm> Cale: any idea what triangulization means wrt graph theory?
17:45:15 <tensorpudding> in a metaphor with his tools, ghc would be too big to fit in his pocket
17:45:24 <tensorpudding> which is where he seems to pull his fixes out of
17:45:40 <monochrom> ghc would be an instrument he found and use at the site.
17:45:42 * hackagebot upload: hsql-mysql 1.8.1 - MySQL driver for HSQL. (NickRudnick)
17:45:56 <tensorpudding> yes, if he found ghc at the site he might be inclined to write haskell
17:46:10 <heatsink> ivanm: Triangularization as in converting a planar mesh to one made of triangles?
17:46:17 <tensorpudding> but that's kind of like him finding nitroglycerine when he needs to blow up a door
17:46:23 <ivanm> heatsink: dunno
17:46:23 <monochrom> No, he would turn its garbage collector into an impromptu vacuum cleaner.
17:46:29 <ivanm> hence why I'm asking!
17:46:39 <MaciejP> hackagebot should link the uploaded package
17:46:46 <ivanm> heatsink: wrt this paper: http://arxiv.org/abs/0907.1421
17:46:52 <ivanm> MaciejP: as well as?
17:47:16 <tensorpudding> does hpaste have a web api?
17:47:20 <DerisionSnort> :t negate null
17:47:21 <lambdabot> forall a. (Num ([a] -> Bool)) => [a] -> Bool
17:47:22 <sm> MaciejP: consensus here was that it would be too noisy
17:47:34 <sm> I think we should try it with shortened urls
17:47:35 <ivanm> sm: that was with the URL duplication for tinyURL
17:47:46 <ivanm> not for actual hackage links when announcing
17:47:50 <DerisionSnort> :t not
17:47:51 <lambdabot> Bool -> Bool
17:47:59 <heatsink> ivanm: IDK.  All I can tell is that it looks topology-related.
17:48:07 <DerisionSnort> @pl \x -> not (null x)
17:48:07 <lambdabot> not . null
17:48:09 <ivanm> heh
17:48:15 <ivanm> @hoogle notNull
17:48:15 <lambdabot> No results found
17:48:21 <ivanm> I thought there was one...
17:48:25 <ivanm> @hoogle [a] -> Bool
17:48:25 <lambdabot> Prelude null :: [a] -> Bool
17:48:25 <lambdabot> Data.List null :: [a] -> Bool
17:48:25 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:48:43 <MaciejP> sm: Ok, I remember you can't hide the real adress in IRC like in bbCode
17:49:00 <tensorpudding> oh, nevermind, someone already wrote an hpaste.el
17:49:22 <Cale> "A triangulation of a surface Σ is a 2-cell embedding of a graph in Σ, such that each face is bounded by three edges, and each pair of faces share at most one edge."
17:50:02 <ivanm> 2-cell?
17:50:12 <Cale> things which are topologically discs
17:50:24 <sm> without shortening, it would look like: upload: hsql-mysql 1.8.1 - MySQL driver for HSQL.  http://hackage.haskell.org/package/hsql-mysql-1.8.1 (NickRudnick)
17:50:39 * ivanm has no problem with that
17:50:48 <Cale> Actually, I'm not sure that the word "2-cell" adds any content there.
17:50:49 * sm neither.. I think they got better
17:50:57 <Cale> If you embed the graph, that's fine :)
17:51:26 <dolio> Is it there just to make it categorically relevant?
17:51:36 <heatsink> I guess it prevents you from boxing off part of the topology inside a triangle?
17:51:39 <Cale> er, hmm
17:51:39 <DerisionSnort> > let myTails = takeWhile (not . null) . iterate tail in myTails "testing"
17:51:40 <lambdabot>   ["testing","esting","sting","ting","ing","ng","g"]
17:51:50 <DerisionSnort> dang, the empty string misses
17:51:51 <Cale> Yeah, I suppose that's it.
17:51:52 <ivanm> Cale: OK, so we're drawing triangles on some surface?
17:51:58 <bjorkintosh> DerisionSnort, what if you hadn't used the 'let'?
17:52:06 <Cale> You want each of the faces to be homeomorphic to a 2-cell
17:52:10 <bjorkintosh> would the equation still have worked?
17:52:29 <DerisionSnort> is there some takeDoWhile or something, that also includes the first element that doesn't satisfy the predicate?
17:52:32 <Cale> So, the surface with the edges and vertices removed will decompose into the disjoint union of things homotopic to 2-cells.
17:52:46 <sm> trying it for a bit
17:53:16 <Cale> otherwise, you could do something like embed a tetrahedron in the torus, fitting the 'handle' into one of the faces
17:53:27 <MaciejP> sm: Did you changed it?
17:53:27 <Saizan> DerisionSnort: sadly, no, but you can use break or span
17:53:29 <Cale> which isn't appropriate :)
17:53:38 <sm> yup
17:53:45 <MaciejP> Pretty cool!
17:53:46 <ivanm> Cale: so what's a 2-Cell?
17:53:51 <Cale> er, s/homotopic/homeomorphic/
17:54:04 <Cale> the unit disc
17:54:36 * ivanm still isn't quite sure what's going on here...
17:54:57 <dolio> A 2-cell is a morphism between 1-cells.
17:54:58 <ivanm> what's the significance of putting a unit disc there?
17:55:06 <Cale> ivanm: Okay, you can imagine drawing a tetrahedron onto the surface of a sphere
17:55:06 <dolio> And a 1-cell is a morphism between 0-cells.
17:55:16 <ivanm> Cale: you can? how?
17:55:36 <Cale> um, I suppose I could draw it..
17:56:10 <heatsink> Stretch the tetrahedron until it's flat with no lines crossing
17:56:23 <heatsink> or sphere-shaped with no lines crossing
17:57:18 <ivanm> you mean all around the sphere?
17:57:22 * sm removed the superfluous "upload: " too
17:57:53 <heatsink> yes
17:58:01 <ivanm> ahhh, OK
17:58:09 <ivanm> I thought you meant just on one bit of the sphere
17:58:33 <ivanm> was trying to work out how you were meant to draw the whole thing just on part of the curved surphace!
17:59:56 <ivanm> Cale: OK, so using a 2-cell prohibits that? how?
18:00:27 <Cale> ivanm: Well, it doesn't.
18:00:42 <Cale> Now, turn the sphere into something topologically equivalent to a torus
18:00:54 <Cale> by cutting out two holes in one of the faces
18:01:05 <Cale> and sticking in a cylinder
18:01:18 <ivanm> owww! my head! :p
18:01:21 <Cale> *that's* what we're trying to prevent
18:01:58 <ivanm> OK...
18:03:11 <monochrom> drill two holes into head. will release pressure safely, no explosion.
18:03:45 <monochrom> This is why when people listen to Cale's lectures, they begin by saying "I'm all ears".
18:03:57 <ivanm> heh
18:04:52 <Cale> hehe
18:06:30 <DerisionSnort> :t (.)
18:06:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:06:46 <Cale> http://cale.yi.org/share/torus-nontriangulation.png
18:07:07 <DerisionSnort> @rsc (.)
18:07:07 <lambdabot> Not enough privileges
18:07:11 <DerisionSnort> lol
18:07:25 <Cale> an embedding of the tetrahedral graph in the torus which is not a triangulation of the torus.
18:08:04 <Cale> Note that the "outside" face of the tetrahedron contains the "hole" of the torus and so it's not homeomorphic to a disc
18:08:23 <ivanm> Cale: heh, just managed to track down my supervisor (he's the one who gave me that paper to read) and asked him what triangulation meant wrt the paper; he said there's a few definitions that might be applicable and I'd have to work it out from the paper which one they mean (he hasn't read it yet)
18:08:24 <bjorkintosh> so it's not "same shape" to a disc?
18:08:25 <Cale> @src (.)
18:08:25 <lambdabot> (f . g) x = f (g x)
18:08:29 <Cale> bjorkintosh: yeah
18:08:34 <bjorkintosh> why didn't you say that?
18:08:41 <ivanm> Cale: OK, what's that picture meant to be? :s
18:08:42 <heatsink> haha
18:08:55 <Cale> bjorkintosh: Because homeomorphic is a specific technical term, and "same shape" isn't.
18:09:04 <Alpounet> ivanm, oh come on, Cale definitely has some talent
18:09:15 <Cale> ivanm: a torus, with a graph embedded on its surface, but not 2-cell embedded
18:09:21 <bjorkintosh> well, i was trying to explain it to my grandma here, and she was thrown off by the words.
18:09:22 <DerisionSnort> Why does Cale get to look at the definition of (.) and not me? :-(
18:09:30 <Cale> My new mouse has jitter problems.
18:09:33 <ivanm> Cale: so what does 2-cell mean? you can't see all the faces or something?
18:09:37 <ivanm> Cale: excuses,e xcuses :p
18:09:38 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:40 <ivanm> @src (.)
18:09:40 <lambdabot> (f . g) x = f (g x)
18:09:41 <ivanm> :o
18:09:45 <heatsink> @src (.)
18:09:46 <lambdabot> (f . g) x = f (g x)
18:09:48 <Cale> The faces are not all homeomorphic to discs.
18:10:07 <Cale> The 3 small faces are.
18:10:15 <Cale> The 4th face is not.
18:10:25 <heatsink> The 4th face is a cylinder?
18:10:29 <Cale> (the one which takes up most of the torus)
18:10:37 <DerisionSnort> iterate tails $ "zomg"
18:10:43 <DerisionSnort> > iterate tails $ "zomg"
18:10:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:10:54 <MaciejP> DerisionSnort: because you had a typo
18:10:58 <monochrom> > "@rsc" == "@src"  {- explains DerisionSnort's puzzle -}
18:10:59 <DerisionSnort> > iterate tail $ "zomg"
18:10:59 <lambdabot>   False
18:11:00 <lambdabot>   ["zomg","omg","mg","g","","* Exception: Prelude.tail: empty list
18:11:08 <ivanm> ahhh, I think I see what you're trying to do there
18:11:45 <bjorkintosh> exhibitionist coding!
18:12:19 <ivanm> (I was referring to Cale's sketch)
18:12:29 <DerisionSnort> @pl \xs -> take (length xs + 1) $ iterate tail xs
18:12:29 <lambdabot> ap (take . (1 +) . length) (iterate tail)
18:12:33 * djahandarie has not an inkling of an idea what Cale is talking about
18:12:41 <ivanm> DerisionSnort: /msg lambdabot @pl ...
18:13:18 <aavogt> @hoogle takeWhileM
18:13:18 <lambdabot> No results found
18:13:25 <Cale> If that were a sphere... http://cale.yi.org/share/sphere-triangulation.png
18:13:34 <Cale> then that *is* a 2-cell embedding of the graph
18:13:57 <DerisionSnort> ivanm: oh cool, private conversations with the lambdabot :)
18:14:05 <ivanm> Cale: ummm.... where's the bottom surface?
18:14:06 <Cale> if you cut along the blue lines, you can deform each of the resulting pieces so that it becomes a unit disc
18:14:13 <Cale> The remainder of the sphere
18:14:20 <ivanm> I presume the tetrahedron is meant to be all around the sphere?
18:14:39 <ivanm> oh, OK... but isn't each face of a tetrahedron meant to be the same? :p
18:14:46 * djahandarie has a lot of private conversations with lambdabot ;) ;)
18:14:53 <Cale> We're talking about a graph tetrahedron
18:14:57 <ivanm> "deform" includes stretching/compacting/etc.?
18:15:05 <Cale> yeah
18:15:09 <ivanm> Cale: oh? how do you define a graph tetrahedron?
18:15:12 <Cale> But not gluing or cutting
18:15:23 <djahandarie> Topology?
18:15:31 <Cale> 4 vertices, every possible edge
18:15:32 * djahandarie makes a mobius strip
18:15:38 <ivanm> Cale: *nod*
18:15:41 <ivanm> djahandarie: heh
18:16:17 <ivanm> and so the torus isn't good because we can't do this deformation to the big "triangle"?
18:16:18 <Cale> But the sphere is topologically equivalent to a (hollow) geometric tetrahedron in this way anyway
18:16:39 * ivanm recalls some of feynman's arguments wrt topology
18:16:40 <Cale> yeah
18:16:49 <Cale> it wouldn't be a disc, there would be a handle in it
18:17:11 <ivanm> Cale: OK; so an irreducible triangulation: for a sphere, that would be an infinite number of triangles since there's an infinite number of points to use?
18:18:18 <Cale> no
18:18:51 <Cale> Do you know what edge contraction is?
18:19:13 <ivanm> yes
18:19:19 <ivanm> that's what I'm looking up papers for ;-)
18:19:35 <Cale> It reduces the number of vertices by 1, and the number of edges by 1
18:19:48 * ivanm 's supervisor has started him off by getting him to help on a survey on graph generation using contractible edges
18:20:02 <ivanm> Cale: oh, if you remove a vertex it is no longer a triangulation?
18:21:16 <Cale> If you contract an edge, it's no longer a triangulation -- given that the triangulation was irreducible.
18:21:48 <ivanm> well, that's _why_ it was an irreducible triangulation ;-)
18:21:53 <Cale> yes
18:22:05 <Cale> If I contract any of the edges in my tetrahedron embedding, for example
18:22:21 <Cale> I end up with a face that's not a triangle.
18:22:34 <Cale> So that's irreducible.
18:22:45 <ivanm> which face?
18:23:06 <ivanm> e.g. contract the edge between the center and one of the outer ones
18:23:29 <ivanm> out of the three "small" faces you're left with one, which is a triangle
18:23:45 <ivanm> and the large face is from three vertices, so it's also a triangle
18:26:53 <Cale> oh, hmm
18:27:12 <Cale> yeah, you end up with two triangles
18:27:21 <Cale> but they meet at more than one edge
18:27:27 <Cale> and so it's not a triangulation
18:27:38 <Cale> er, one triangle rather, sorry
18:27:44 <Cale> two triangular faces
18:27:52 <Cale> ivanm: yeah?
18:28:06 <ivanm> ahh, I get you know
18:28:14 <ivanm> forgot about that; they can only meet at one edge
18:28:17 * Cale has a reducible triangulation of the torus ready :)
18:28:29 <ivanm> go!
18:29:01 <Cale> http://cale.yi.org/share/torus-triangulation-reducible.png
18:29:59 <Cale> This is an unfolded drawing of the torus. The blue edges are supposed to be identified straight across, and the two red edges as well.
18:30:28 <Cale> and the 4 black vertices in the corners are really the same vertex
18:31:05 <ivanm> how about the black line going horizontally across?
18:31:18 <Cale> well, there are two edges there
18:31:24 <Cale> ah, hmm
18:31:36 <ivanm> so that line in the middle shouldn't be there?
18:31:36 <Cale> yeah, maybe this isn't a simple graph
18:31:45 <Cale> hmm
18:31:55 * ivanm is still trying to work out how that's a torus...
18:32:04 <ivanm> seeing as how a torus is _round_ and all...
18:32:05 <ivanm> ;)
18:32:06 <Cale> maybe we have to do something more interesting
18:32:15 <heatsink> ivanm: glue together the blue sides and you have a tube
18:32:29 <heatsink> Then glue together the red sides (which are now circles) and you have a torus
18:32:37 <ivanm> ahhh, got you now
18:32:48 <ivanm> now to work out where the rest of the lines go...
18:32:53 <Cale> yeah, hang on, I might need another vertex or so
18:33:05 <heatsink> Cale: Here you go:   .
18:33:12 <ivanm> heh
18:33:18 <ivanm> you're so generous, heatsink
18:33:52 <Cale> http://cale.yi.org/share/torus-triangulation-reducible.png -- there we are, all fixed :)
18:33:53 <heatsink> I don't think it's right to hold on to verticies when there are people without.
18:34:07 <Cale> Now it comes from something which is actually a graph :P
18:34:27 <Cale> So the edge which goes off to the left comes back along the right
18:34:27 <heatsink> It wasn't a graph before?
18:34:39 <Cale> yeah, it had two edges joining the same pair of vertices
18:34:53 <heatsink> oh
18:35:02 <Cale> oh, er, there might still be something wrong with it.
18:35:21 <Cale> yeah :/
18:35:47 <Cale> hmmm
18:37:09 <ivanm> Cale: anyway, I get the point of this all
18:37:17 <muri_one> i just changed a comment in a c++ header file. this resulted in an 11 minute rebuild because this file was somehow or another being included everywhere.. is haskell much saner with incremental builds?
18:37:26 <ivanm> may I suggest a non-circular surface as it would be easier to visualise, etc.? :p
18:37:28 <muri_one> or ghc
18:37:47 <ivanm> muri_one: if you change an exported function, then everything that depends upon it will also get rebuilt
18:37:54 <ivanm> as the ABI (or whatever) changes
18:38:05 <ivanm> that is, the location of that function that gets called changes
18:38:18 <ivanm> if it's a non-exported function, then only that file gets rebuilt
18:38:58 <muri_one> ivanm: everything that depends on that exported function? or everything the depends on that module?
18:40:57 <Cale> http://cale.yi.org/share/torus-triangulation-reducible.png -- there we go, much simpler
18:41:15 <Cale> note however, that the 4 corners end up being the same vertex
18:41:20 <ivanm> muri_one: all modules that depend on the module that the exported function is in I believe
18:41:27 <Cale> er
18:41:49 <Cale> grr, no, that doesn't work either
18:41:50 <ivanm> aaaaaahhhhh! you _still_ expect me to visualise that??!?!?!?!?!? :s
18:41:51 <ivanm> heh
18:42:06 <Cale> hehe
18:42:21 <Cale> bloody hexagons :)
18:42:50 <Cale> well, here's what we'll do, we'll triangulate the two hexagons...
18:44:10 <Cale> oh wait, they are squares, we can cut them in two
18:46:40 <rawr> hi I am using the map function like this. print =<< (map f <$> textFile)
18:47:03 <rawr> however this is print a list of list of result of "f"
18:47:25 <rawr> I want it to do f on each dataset but print seperatly
18:48:03 <pikhq> So... map (print =<< f) <$> textFile ?
18:49:22 <rawr> that will print each result of f on a new line?
18:49:27 <rawr> and not as one list?
18:50:04 <pikhq> Yes, that is exactly what that does.
18:50:11 <pikhq> Erm.
18:50:11 <rawr> thank you very much
18:50:12 <pikhq> Actually. No.
18:50:18 <pikhq> map (print . f) <$> textFile
18:50:29 <pikhq> And I should not be writing Haskell tonight, apparently. :P
18:51:05 <Cale> http://cale.yi.org/share/torus-triangulation-reducible.png -- finally! (note, however that you have to consider the red and blue edges as edges in the graph, but identified)
18:51:30 <ivanm> nooo!!! not another torus!!!
18:51:33 <Cale> hehe
18:51:43 <Cale> I wanted to make sure to get the torus right
18:51:45 <ivanm> Cale: OK, now the 3D version? :p
18:51:55 <Cale> It's hard to draw things in 3D :P
18:52:29 <rawr> pikhq what kind of data heading would that code have?
18:52:34 <Cale> But you could print that out on silly putty, and then roll it up into a cylinder and connect the ends of the cylinder together...
18:52:36 <rawr> IO () isnt working
18:52:57 <pikhq> Erm.
18:53:03 <tensorpudding> IO isn't working?
18:53:15 <rawr> IO it is, but im not using it correctly :p
18:53:22 <pikhq> :t map (print . f) <$> textFile
18:53:23 <lambdabot> Not in scope: `textFile'
18:53:36 <ivanm> @hoogle textFile
18:53:37 <lambdabot> No results found
18:53:59 <rawr> textFile was me just signifying that it was a list of strings
18:54:01 <ivanm> @type \ textFile f -> map (print . f) <$> textFile
18:54:02 <lambdabot> forall a a1 (f :: * -> *). (Show a, Functor f) => f [a1] -> (a1 -> a) -> f [IO ()]
18:54:16 <ivanm> methinks you should use mapM_
18:54:30 <pikhq> Yeah, probably.
18:54:45 <ivanm> Cale: you have a printer that will print on silly putty?
18:55:08 <ksf> why isn't there a general words/lines function?
18:55:13 <rawr> how would I use mapM_?
18:55:20 <pikhq> :t mapM_
18:55:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:55:26 <pikhq> Approximately like that.
18:55:30 <ivanm> ksf: what do you mean?
18:55:33 <ivanm> for any list?
18:55:43 <ivanm> if so, that's a good question!
18:55:45 <ksf> that, and for any predicate
18:55:48 <ivanm> @src words
18:55:49 <lambdabot> words s = case dropWhile isSpace s of
18:55:49 <lambdabot>     "" -> []
18:55:49 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:55:54 <ksf> ...just a recursive break.
18:55:54 <pikhq> In this case, probably something like mapM_ (print . f) yourList
18:56:15 <ksf> @src lines
18:56:15 <lambdabot> Source not found. That's something I cannot allow to happen.
18:56:25 <rawr> so no need for <$>?
18:57:10 <ksf> you can drop many fmaps when you're dealing with monads
18:57:23 <ksf> ...as, after all, bind is more powerful than fmap
18:57:43 <aavogt> fmapping so much you go bind
18:57:50 <pikhq> rawr: Unless yourList is of type IO [a].
18:57:51 * Cale tries to draw it in 3d :)
18:58:00 <ivanm> \o/
18:58:04 <ksf> f `fmap` xs = xs >>= return . f
18:58:11 <rawr> ok well I tried the mapM_ and it gives errors.
18:58:53 <pikhq> rawr: What's the type of "textFile"?
18:59:22 <rawr> lines <$> readFile "meh.txt"
18:59:38 <rawr> :: IO [String]
18:59:47 <pikhq> Then you need a <$> there.
18:59:59 <pikhq> mapM_ (print . f) <$> textFile
18:59:59 <ivanm> or a =<<
19:00:08 <ivanm> mapM_ (print . f) =<< textFile
19:00:10 <pikhq> Or a =<<, yes.
19:00:15 <ivanm> @type (<$>)
19:00:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:00:29 <ivanm> pikhq: I'm not sure that <$> would typecheck
19:00:38 <pikhq> ivanm: ... It probably wouldn't.
19:00:41 <ivanm> @type (<*>)
19:00:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:00:48 <rawr> yeah but im being told by ghci that couldnt match expected type () with inferred type IO ()
19:00:50 <pikhq> At least, not in a way you'd expect.
19:00:51 <ivanm> no, that's not it either..
19:01:03 <rawr> but my function IS IO () not ()
19:02:43 <bd_> rawr: 'expected' and 'inferred' can be the opposite of what you expect at times :)
19:02:56 <bd_> if there's no explicit type signature, it's going to be inferring the type from two directions
19:03:16 <rawr> still confused on what to do to fix it though
19:03:54 <rawr> actually
19:03:55 <bd_> add an explicit type signature to try to nail down the problem?
19:03:57 <rawr> i think i got it
19:04:02 <rawr> IO (IO ())
19:04:05 <bd_> ah :)
19:04:09 <rawr> its compiled at least :)
19:04:10 <Saizan> need a join
19:04:29 <pikhq> Delicious, delicious join.
19:04:48 <copumpkin> probably best to use a function that doesn't result in a nested IO in the first place
19:04:55 <copumpkin> better than joining the result
19:05:10 <tensorpudding> > join $ Just Nothing
19:05:11 <lambdabot>   Nothing
19:05:33 <Zeiris_> How do I properly run a function that uses an STUArray? evalState clearly ain't it, and I'm too lost in the types to figure out what is :( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23013#a23013
19:05:47 <MaciejP> @type join
19:05:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:05:48 <copumpkin> runSTArray
19:05:58 <copumpkin> it'll freeze it
19:06:03 <copumpkin> or just runST if you're doing something else
19:06:22 <Zeiris_> I'm not interested in the resulting array... So I guess runST must be it.
19:07:56 <DarthHaskell> Is it possible to dynamically run haskell code in a text file from a haskell program, or can you embed haskell as a scripting language in a haskell program?
19:08:18 <copumpkin> you can but it's not too pleasant
19:08:44 <Saizan> there's hint on hackage, or you can use the ghc-api directly
19:08:55 <pikhq> DarthHaskell: Yes, it is possible to link against GHC.
19:08:58 <pikhq> Not all that nice, though.
19:09:38 <DarthHaskell> is there any documentation on it?
19:09:59 <aavogt> @hackage hint
19:09:59 <lambdabot> http://hackage.haskell.org/package/hint
19:10:38 <nus> "embed haskell as a scripting language in a haskell programm"??
19:10:38 <DarthHaskell> thanks
19:10:50 * nus is confused
19:11:10 <Saizan> nus: in the sense that you load haskell code at runtime, i guess
19:11:18 <heatsink> nus: exec =<< readLine
19:11:24 <heatsink> if there were such a function
19:11:36 <nus> heatsink, you mean 'eval'?
19:11:36 <aavogt> ?bot does it
19:11:37 <lambdabot> :)
19:11:58 <Cale> ivanm: http://cale.yi.org/share/torus-triangulation.png -- brutal
19:12:13 <ivanm> heh
19:12:17 <heatsink> Yeah.  I think the naming convention is 'eval' if it returns the result, and 'exec' if it discards it.
19:12:48 <Cale> ivanm: But, that's sort of what it looks like in 3D, when you join things up.
19:13:07 <laurentoget> 2
19:13:08 <Cale> Obviously, you'd want to do it so that it was less wobbly and hand-drawn.
19:13:53 <ivanm> heh
19:13:56 <Cale> Maybe I should have used grey lines rather than dotted ones for the obscured parts
19:14:03 <ivanm> I was expecting you to use blender or some such... >_>
19:14:52 <Cale> I haven't used a 3D graphics program in at least 8 years, and I've never really used blender. I tried to, but the UI was annoying.
19:15:17 <Cale> The only one I was ever remotely comfortable with was trueSpace.
19:15:38 <ivanm> Cale: and so that is meant to be reducible?
19:16:03 <c_wraith> whoever suggested a GUI for vacuum that lets you explore the object graph and force parts of it at will was onto a great idea.
19:16:14 <Cale> http://cale.yi.org/share/torus-triangulation-reducible.png -- look back at this one :)
19:16:38 <c_wraith> But I really wish vacuum could introspect thunks...  At least to give you a list of pointers the thunk was holding in its closure.
19:16:45 <Cale> and look at one of the two horizontal edges from the central vertex
19:16:55 <c_wraith> If it could do that, it'd be a terrific memory use analysis tool.
19:17:01 <Cale> I think you could contract along that edge, at least :)
19:17:29 <copumpkin> c_wraith: hm, how would that work?
19:17:44 <c_wraith> which part?  introspecting the thunks?
19:17:49 <copumpkin> yep
19:18:13 <c_wraith> clearly, the GC mechanism has a list of pointers to not GC because they're required by the thunk.
19:18:32 <c_wraith> It'd require some GHC-specific mechanism to get at that list
19:18:41 <c_wraith> But I thought vacuum was ghc-specific already
19:18:48 <ivanm> Cale: looks good to me
19:20:48 <nus> @where vacuum
19:20:48 <lambdabot> http://moonpatio.com/vacuum/
19:22:04 <Cale> ivanm: when working with surfaces, you can actually draw any surface in this way, by drawing a 2n-gon, and then identifying edges in some fashion (though sometimes you have to do something even more mindbending and flip the orientation :)
19:24:08 * ddarius likes CW-complexes.
19:24:18 * copumpkin prefers simplices
19:34:35 <chrissbx> I need to implement a forward-looking match for Text.ParserCombinators.ReadP
19:34:40 <ablmf> What's wrong with this code snippet : http://pastebin.com/6QXbadA5
19:35:06 <copumpkin> ablmf: um, can you tell us what GHC thinks is wrong with it?
19:35:07 <chrissbx> It only offers "look" which returns a string; but I need to match that against a parser.
19:35:27 <chrissbx> So I'm looking at the source code and trying to understand how to write it;
19:35:50 <chrissbx> it says "look = R Look"; what's R? It's not defined in that file as far I can see.
19:36:22 <ablmf> copumpkin: Ambiguous type variable `t' in the constraints:  `RealFrac t'    arising from a use of `candidates'' ....
19:36:23 <chrissbx> Also I'm really swimming here; not sure how to find out how the monad works that's being used here.
19:36:55 <copumpkin> ablmf: then give it a type signature. What type to you want d to be?
19:37:44 <chrissbx> How do I find out from the repl where that R is coming from?
19:37:57 <copumpkin> :i R
19:38:20 <ablmf> I want it to be Int
19:38:33 <copumpkin> ablmf: then that's not going to work. You should replace / with `div`
19:38:43 <ablmf> Oh, thx!
19:38:46 <copumpkin> that will give you integer division though
19:38:48 <Cale> and floor with id
19:38:53 <copumpkin> and 5 / 3 isn't very useful with that
19:39:08 * copumpkin doesn't really understand what the function is doing
19:39:57 <chrissbx> "Prelude Text.ParserCombinators.ReadP> :t R" says "Not in scope: data constructor `R'"
19:40:11 <ablmf> I want to generate [1, 5 / 3 * 1]  [10, 5 /3 * 10], [100, 5 /3 * 100] ....
19:40:42 <chrissbx> hm. Sadly that library package (from Debian) doesn't come with source code, so I don't know whether this version doesn't have R (unlike the one on the web)
19:41:10 <Saizan> chrissbx: R is probably a not exported constructor
19:41:21 <chrissbx> ah, of course.
19:41:31 <chrissbx> How do you load a package (not import)?
19:41:34 <chrissbx> from the repl.
19:41:43 <chrissbx> When you don't have the source code, that is.
19:42:23 <chrissbx> Or, would this imply I don't have a way to get at the information of R anyway?
19:42:38 <chrissbx> i.e. I *have* to install the sources?
19:42:43 <nus> chrissbx, :load ?
19:42:59 <nus> :m + ModuleName
19:43:24 <nus> chrissbx, also :browse ModuleName
19:43:38 <Saizan> chrissbx: you can't access not-exported things, no
19:43:48 <copumpkin> unless you have SPJ's secret backdoor key
19:44:16 * aavogt wonders how to parse that
19:44:25 <copumpkin> there's an easter egg where if you draw his face in ascii art in your code, it'll let you access all symbols in all imported modules
19:44:34 <copumpkin> (it has ascii face recognition, yes)
19:44:46 <SamB_XP> copumpkin: whoa
19:44:51 <SamB_XP> where the heck did he hide that ?
19:44:53 <copumpkin> I know!
19:45:06 <copumpkin> he locked it in a non-exported module that only he can get at with his key, so you can't see it
19:45:21 <SamB_XP> how does the compiler compile it, then ?
19:45:34 <copumpkin> it's a secret that's also protected by his key
19:45:44 <ddarius> @google "Trusting trust"
19:45:45 <lambdabot> http://cm.bell-labs.com/who/ken/trust.html
19:45:46 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
19:46:24 <Saizan> that's why boostrapping is made so complicated.
19:46:27 <SamB_XP> the compiler must contain the decryption secret
19:46:41 <SamB_XP> or else it wouldn't be able to decrypt the code to compile it!
19:46:47 <copumpkin> SamB_XP: nope, it's a crazy self-referential cryptographic protocol that SPJ himself came up with
19:47:20 <SamB_XP> what I'm saying is the compiler must contain what is necessary to decrypt the module
19:47:30 <SamB_XP> or else it wouldn't be able to compile i!
19:47:33 <copumpkin> I know what you're saying, but it doesn't
19:47:35 <chrissbx> There's no online cross-reference of haskell modules, or is there?
19:47:40 <copumpkin> it's a magic protocol
19:47:53 <Saizan> chrissbx: cross-reference?
19:48:06 <SamB_XP> copumpkin: are you the one who keeps talking the MPAA into these silly DRM schemes?
19:48:09 <chrissbx> Yes, like LXR for the Linux C sources.
19:48:18 <copumpkin> SamB_XP: surely not O:-)
19:48:36 <Saizan> chrissbx: can you explain?
19:48:37 <chrissbx> Source code as html pages with hyperlinks to the definitions of identifiers.
19:48:48 <Saizan> yes
19:48:49 <chrissbx> And types.
19:48:53 <nus> chrissbx, what haskell implementation are you using?
19:48:55 <SamB_XP> when it's clearly impossible to hide and reveal the content of movies at the same time?
19:48:58 <nus> which
19:48:59 <chrissbx> GHC
19:49:00 <Saizan> called haddock docs
19:49:07 <ddarius> Why did Microsoft give up on the Trusted Computing stuff.  That would have been fun and rewarding to crack.
19:49:09 <chrissbx> ghc-6.8.2 from Debian
19:49:16 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/
19:49:21 <copumpkin> ddarius: yeah :/ at least Apple's still doing it though
19:49:23 <copumpkin> :P
19:49:25 <Saizan> or hackage
19:49:36 <Saizan> chrissbx: you should also have a local copy
19:50:00 <choffstein> Is there an MPI implementation for Haskell?
19:50:00 <ddarius> copumpkin: Apple could never pull it off by itself.  Doing so would lead to its immediate death.
19:50:02 <chrissbx> Saizan: but those pages only have the API? I need to see the implementation, with the links.
19:50:12 <Saizan> chrissbx: there are source links.
19:50:29 <copumpkin> ddarius: the iphone is already pretty "trusted computing", and I have no doubt that the ipad will be pretty trusted
19:50:31 <chrissbx> Saizan: yes, and that's what I'm looking at; but it doesn't tell me which import exports R
19:51:13 <ddarius> copumpkin: The iPhone has a tamper-proof processor with a internal, inaccessible cryptographic region?
19:51:16 <Saizan> chrissbx: true, you've to read the source code, newtype ReadP a = R (forall b . (a -> P b) -> P b)
19:51:19 <nus> @ty getModuleInfo
19:51:20 <lambdabot> Not in scope: `getModuleInfo'
19:51:29 <nus> @index getModuleInfo
19:51:30 <lambdabot> bzzt
19:51:40 <copumpkin> ddarius: it's not physically tamper-proof, but otherwise, yep
19:51:40 <nus> @hoogle getModuleInfo
19:51:41 <lambdabot> No results found
19:52:00 <SamB_XP> mod-chip time!
19:52:09 <SamB_XP> (or maybe just pencil time?)
19:52:23 <copumpkin> it's nothing any hobbyist could do :)
19:52:32 <copumpkin> maybe with enough money you could actually learn something by decapping it
19:52:48 <ddarius> copumpkin: You'd be surprised what hobbyists can do.
19:52:53 <SamB_XP> indeed
19:52:58 <SamB_XP> hobbyists can and do cap stuff
19:53:00 <chrissbx> Saizan: ok, good point; but what if I want to know something that's not defined in this file but imported?
19:53:07 <copumpkin> I'm pretty positive that the average hobbyist would get nowhere with this :)
19:53:12 <copumpkin> but feel free to prove me wrong
19:53:20 <SamB_XP> who said anything about average ?
19:53:21 <ddarius> copumpkin: One doesn't need to worry about the "average" hobbyist.
19:53:36 <SamB_XP> what's important is the high-end outliers
19:53:37 <copumpkin> fine, I'm pretty positive even the most exceptional hobbyists would get nowhere with it
19:53:59 <copumpkin> this is probably #haskell-blah though :)
19:54:17 <SamB_XP> no, I'm pretty sure we're in #haskell
19:54:26 <copumpkin> +for
19:55:25 <Saizan> chrissbx: for that you could hoogle or hayoo, but i usually load the module in ghci from the source, since that makes the ghci repl have the same things in scope, and then use :info
19:55:34 <choffstein> Anyone know if there is an MPI library for Haskell?  I can't seem to find one
19:55:38 <chrissbx> k
19:55:45 <SamB_XP> @google hmpi
19:55:46 <lambdabot> http://www.hmpi.net/
19:55:46 <lambdabot> Title: HMPI_THE_NUMBER_ONE_SOURCE_FOR_GOSPEL_MUSIC_INSTRUCTION
19:55:49 <SamB_XP> @google hmpi haskell
19:55:51 <lambdabot> http://www.foldr.org/~michaelw/hmpi/
19:55:51 <lambdabot> Title: hMPI - a Haskell binding for MPI
19:56:03 <SamB_XP> no idea if it's any good or not
19:56:15 <SamB_XP> and that site only has a link to the one with the latest
19:56:26 <winxordie> SamB_XP: Lol at first link.
19:56:31 <choffstein> hmpi says it is no longer under development
19:56:45 <choffstein> hasn't had work since 2001
19:58:59 <nus> @google Haskell MPI
19:59:00 <lambdabot> http://www.haskell.org/haskellwiki/Applications_and_libraries/Concurrency_and_parallelism
19:59:00 <lambdabot> Title: Applications and libraries/Concurrency and parallelism - HaskellWiki
19:59:26 <nus> you know, ranking (-:
20:01:33 <choffstein> nus: hMPI is the only one listed on that page
20:02:23 <nus> choffstein, there're other approaches to the domain in Haskell, arguably better.
20:02:37 <choffstein> nus: recommendations for a cluster?
20:03:30 <copumpkin> a Gang!
20:03:37 <copumpkin> don't mess with the Gang
20:04:02 <Cale> hmm
20:04:06 <Cale> Holumbus?
20:04:11 <copumpkin> ?
20:04:20 <nus> choffstein, a cluster of what?
20:04:23 <Cale> http://hackage.haskell.org/package/Holumbus-Distribution
20:04:25 <copumpkin> beowulfs
20:04:26 <SamB_XP> nus: computers!
20:04:33 <nus> SamB_XP, heh
20:04:38 <SamB_XP> with seperate memories
20:04:42 <choffstein> nus: building a small mac mini cluster
20:04:52 <SamB_XP> connected, presumably, by ethernet?
20:04:53 <choffstein> nus: was hoping to use xgrid, hence the need for MPI
20:04:57 <nus> SamB_XP, that v. Neumann things?
20:05:10 <ivanm> a beaowulf cluster? :p
20:05:21 <SamB_XP> nus: no, we don't have those self-assembling units yet
20:05:58 <konr> 'IO () means that this action performs IO, and the basic value is nothing, represented as "()"'. But what is a basic value?
20:06:17 <SamB_XP> hmm ... actually, that kind of von neumann machine is just a more extreme version of this kind ;-P
20:06:18 <copumpkin> the value the computation returns
20:06:24 <Cale> I wonder how hard it would be to get Hal Daume's version of hMPI working.
20:06:41 <choffstein> Any thoughts on this message: "cabal: cannot configure hxt-8.5.0. It requires base >=4.2 && <5
20:06:42 <choffstein> For the dependency on base >=4.2 && <5 there are these packages: base-4.2.0.0.
20:06:42 <choffstein> However none of them are available."
20:06:53 <choffstein> WHoops, sorry about the multi-line spam there
20:07:00 <SamB_XP> huh
20:07:10 <SamB_XP> wonder how it even knows the package has that version?
20:07:29 <Cale> base-4.2.0.0 implies GHC 6.12
20:07:46 <Cale> My guess is that you want to install an older version of hxt.
20:07:50 <SamB_XP> oh
20:07:57 <ivanm> what came into 4.2 that it would need 6.12?
20:08:04 <SamB_XP> so "available" means "available for my compiler" ?
20:08:13 <ivanm> SamB_XP: yes
20:08:15 <copumpkin> pf : Base 4.2.0.0 -> GHC 6.12
20:08:22 <Cale> ivanm: 4.2.0.0 is the version which comes with 6.12. You never replace the base package.
20:08:25 <ivanm> including "available to download and install"
20:08:29 <ivanm> Cale: I know
20:08:31 <SamB_XP> so why doesn't Cabal *say* so?
20:08:32 * hackagebot NineP 0.0.2 - 9P2000 in pure Haskell  http://hackage.haskell.org/package/NineP-0.0.2 (DaveLeimbach)
20:08:44 <ivanm> what I meant was, is there any particular reason hxt needs 6.12?
20:08:50 <ivanm> what's 9P2000?
20:08:56 <ivanm> SamB_XP: because
20:08:59 <ivanm> ;)
20:09:01 <copumpkin> over 9P2000!1!!!!
20:09:02 <SamB_XP> ivanm: the latest version of Styx/9P ?
20:09:16 <ivanm> which is?
20:09:23 <copumpkin> something to do with plan 9, I guess
20:09:23 <SamB_XP> the Plan 9 from Bell Labs FS protocol?
20:09:35 <ivanm> yeah
20:09:37 <ivanm> "Pure Haskell implementation of the 9P2000 protocol from the Plan 9 and Inferno operating systems. Many implementations of 9P2000 exist including the Linux kernel v9fs module, wmii (X window manager)."
20:09:52 <SamB_XP> Inferno calls it "Styx" for some reason
20:10:06 <dancor> do any web frameworks support openid out of the box
20:10:15 <choffstein> well, looks like I can't get Holumbus-Distribution working either.  Damn you 6.12!
20:10:26 <ivanm> heh
20:11:10 <SamB_XP> where do most people get their openids anyways ?
20:11:10 <copumpkin> we need the distributed DPH!
20:11:24 <copumpkin> it looks like it hasn't been touched in a while though
20:11:39 * SamB_XP could never remember the name of his openid provider until he started using his launchpad.net account for it ...
20:12:46 <dancor> i just have google and aim right now
20:13:00 <SamB_XP> google is an openid provider now ?
20:13:05 <dancor> ya
20:13:15 <SamB_XP> mmmkay ...
20:13:23 <CalJohn> i think they have been for a while?
20:13:42 <SamB_XP> they have too many things
20:13:51 <SamB_XP> it's hard to find them even with google!
20:13:56 <CalJohn> 2 years, apparently
20:13:58 <CalJohn> heh
20:14:00 <Sagi> does anyone have experience with csum16 from Data.CSum included in the network-data-0.1.0 package?
20:14:35 <CalJohn> they have thousands of employees, and only a few projects that directly make an ROI.  What would you do with that many PhDs?
20:14:52 <Sagi> somehow, I don't think it follows the spec, but figuring out why it is not meeting my expectations is quite difficult give the one way nature of checksums :)
20:15:12 <SamB_XP> CalJohn: dig up some students ?
20:15:29 <CalJohn> hm?
20:15:37 <nus> CalJohn, perhaps The Plan B is to fallback to an educational institution [-:
20:16:04 <SamB_XP> nus: that'd make a heck of a plan A, too, though!
20:16:13 <SamB_XP> college sucks
20:16:28 <CalJohn> when google collapses it will absolutely destroy the job market
20:17:18 <CalJohn> seeing as web search is a market where people can switch quite easily, and people can surprise you with new things, i don't think that's impossible
20:17:44 <SamB_XP> I thought they made their money on adsense
20:18:54 <QtPlatypus> Thats why they are deversfiing into everything.
20:19:22 <CalJohn> well, they do, but a lot of it is theirs, and it's worth quite a lot to adsense that every web use starts with a google search
20:19:32 <SamB_XP> like SketchUp?
20:19:48 <CalJohn> QtPlatypus: and doing great, but not making much money anywhere else :/
20:20:02 <ivanm> QtPlatypus: found gainful employment yet?
20:20:05 <QtPlatypus> Phones, server room space, maps, news
20:20:07 <QtPlatypus> Yes
20:20:12 <ivanm> \o/
20:25:25 <nus> fsck.
20:25:37 * nus wnats a sane Haskell REPL
20:26:14 <nus> ghci on acid. common.. is that what's this supposed to be?
20:27:12 <aavogt> ghci does file completion and other stuff that's absent from say python
20:27:28 <nus> python never had a sane REPL
20:27:37 <nus> if you're not speaking of CMUCL
20:27:51 <tensorpudding> you can't define a lot of things from ghci
20:28:04 <SamB_XP> Python is just the name of the *compiler* portion of CMUCL
20:28:51 <ivanm> ummm.... CMUCL is common lisp
20:28:56 <ivanm> python isn't common lisp
20:29:41 <tensorpudding> anyway, there exists ipython
20:29:52 <aavogt> is that by apple or bmw?
20:30:04 <tensorpudding> heh
20:30:05 * aavogt can has iHaskell
20:30:17 <tensorpudding> the i is for interactive probably
20:30:25 <ivanm> yeah
20:30:36 <ivanm> aavogt: s/has/haz/
20:31:00 <SamB_XP> ivanm: the name of the compiler in the CMUCL implementation of Common Lisp is, nevertheless, "Python"
20:31:06 <aavogt> sorry, I'm too tired to intentionally misspell stuff
20:31:07 <ivanm> :o
20:31:12 <ivanm> pre-dating python-the-language?
20:31:16 <ivanm> aavogt: heh
20:31:31 <tensorpudding> given that it is CL we're talking about, it's possible
20:31:37 <tensorpudding> CMUCL is pretty ancient
20:31:52 <SamB_XP> predates it's popularity, at least, I'll wager
20:32:21 * SamB_XP wagers a pair of chocolate peanut-butter lips
20:32:35 <tensorpudding> it is from the 80's
20:33:10 <tensorpudding> though i read that cmucl is pretty dead
20:33:23 <SamB_XP> yeah, I think the fork is more active nowadays?
20:33:31 <tensorpudding> sbcl
20:34:08 <SamB_XP> probably on account of CMU switching to ML?
20:34:52 <nus> @hackage goa
20:34:52 <lambdabot> http://hackage.haskell.org/package/goa
20:35:10 <nus> that's GHCI on Acid
20:35:19 <gwern> cmucl had been dying for a while
20:35:22 <nus> there's also lambdabot and mueval
20:35:35 <gwern> 3 or 4 years ago when I was using/developing stumnpwm, cmucl was dying
20:35:55 <SamB_XP> I think CMU switched years ago?
20:36:07 <nus> there're also some attempts to introduce swank/slime to haskell
20:36:19 <tensorpudding> 1996 was when CMU abandoned it
20:36:51 <SamB_XP> that's, like, around the age of my youngest sister ?
20:37:13 <aavogt> yes, I know for some reason
20:39:24 <interferon> are there any haskell graphing libraries that can produce a line graph?
20:40:32 <blackh> interferon: Chart is good
20:41:27 <copumpkin> I wish it didn't depend on gtk though
20:41:35 <copumpkin> or cairo, and gtk indirectly
20:44:05 <blackh> gtk may be a fatter dependency than gnuplot, but at least it's not an abomination in the sight of God like gnuplot is.
20:44:27 <ivanm> heh
20:44:30 <blackh> (Maybe I'm getting a little emotionally attached to this question. :) )
20:44:38 <ivanm> but gnuplot can use gtk to draw graphs!
20:44:52 <SamB_XP> blackdog: my understanding is that that is NOT an overreaction to gnuplot
20:44:53 <blackh> But can it do it without depending on gtk?
20:45:02 <hotaru2k3> blackh: that depends on which god you're talking about
20:45:12 <blackdog> SamB_XP: oh, you woke me...
20:45:20 <SamB_XP> argh
20:45:22 <SamB_XP> sorry
20:45:23 <blackh> I am talking about the god responsible for 2D and 3D charting.
20:45:48 <hotaru2k3> gtk is just as much an abomination in the sight of some
20:45:49 <blackh> SamB_XP: I should point out that this is not entirely prejudice.  I have used gnuplot a fair bit.
20:45:50 <SamB_XP> anyway, it may or may not be strictly accurate, theologically speaking, but it's not an overreaction ;-P
20:46:21 <ivanm> blackdog: having a siesta, were you?
20:46:22 <blackh> Chart is nicely engineered.
20:46:34 <blackdog> ivanm: programming ruby. it's about the same thing.
20:46:39 <ivanm> blackh: if only it didn't take me half an hour to work out how to use it each time...
20:46:42 <ivanm> blackdog: heh
20:52:55 <ivanm> wtf? the haskell reddit has only 2 items in it? :s
20:53:40 <copumpkin> reddit's being weird today
20:56:03 <ivanm> hmmm...
20:56:13 <ivanm> copumpkin: you didn't make it start sulking as well, did you?
20:56:23 <copumpkin> yep
20:56:27 <copumpkin> twas I
20:57:00 <ivanm> I knew it!
20:57:24 * ivanm heads off
20:57:29 <ivanm> bye all
20:57:35 <copumpkin> buh bye
20:58:06 <pastorn> http://www.lisperati.com/landoflisp/panel57.html
20:59:44 <copumpkin> what's the big thing in the background
20:59:55 <copumpkin> looks like something about to punch everyone
21:00:00 <dobie_gillis> anyone have experience with using the selection buffer for picking in HOpenGL? I'm having trouble setting the RenderMode. the renderMode command in the docs just returns the existing RenderMode. how do i set it?
21:00:12 <pastorn> copumpkin: you can read it from the beginning :)
21:00:17 <cpettitt> :t first
21:00:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
21:00:21 <copumpkin> oh
21:02:40 <copumpkin> the whole premise feels a bit silly
21:04:22 <Saizan> i never figured out if that comic is pro or against haskell or whatever it's trying to say
21:04:24 <roconnor> copumpkin: see the previous panel to see what it is
21:04:28 <copumpkin> yeah, I saw
21:04:42 <roconnor> Saizan: it is pro ... I think
21:12:02 <gwern> it is haha only serious
21:12:52 <copumpkin> hahaoya?
21:13:52 <arcfide> Hello everyone.
21:13:57 <copumpkin> omg
21:14:05 <copumpkin> hello
21:14:52 <arcfide> I've doing a presentation on Web Programming in Higher Level "PL Researcher" friendly languages. I don't usually use Haskell, but I wanted to include a taste of what Haskell has available. Is there some epitome of Haskell Web Programming that I can reference?
21:15:04 <arcfide> I'd like to know what the Haskell community actually prefers and uses.
21:15:33 <copumpkin> quite a few people seem to use happstack
21:15:41 <copumpkin> hakyll is also getting some love recently (a static site generator)
21:16:03 <copumpkin> Berengal was getting us all excited recently with a nice continuation-based web framework but then stopped :(
21:17:06 <arcfide> copumpkin: What are you doing here? :-)
21:17:13 <copumpkin> arcfide: this is where I live!
21:17:32 <arcfide> Aren't you supposed to be Scheming? :-P
21:18:04 <copumpkin> I haven't actually written scheme in a few years, and even then it was mostly for a class :) I mostly hang out in #scheme cause I like the atmosphere
21:18:25 <scutigera> copumpkin is actually a haskellbot
21:18:54 <copumpkin> indeed :o
21:19:02 <arcfide> A sleeper cell!
21:19:28 <copumpkin> I'm actually a subversive agent trying to convert schemers to my strongly typed ways.
21:19:36 <copumpkin> very subtly :)
21:19:41 <scutigera> statically typed ways
21:19:44 <copumpkin> fine
21:19:58 <scutigera> I was corrected on that very point not too long ago :-)
21:20:22 <copumpkin> I still think it's a silly term and that strong captures our intent a lot better than static :P
21:20:26 <copumpkin> but I defer
21:20:51 <scutigera> not too me, I'm the last person to be the nomenclature police
21:21:21 <scutigera> arcfide: speaking of scheme, doesn't plt scheme have some groovy continuation based web server ?
21:24:05 <arcfide> scutigera: Yes, for some definition of Groovy. :-)
21:25:36 <scutigera> arcfide: I thought that Gambit scheme also had such a thing.
21:27:53 <arcfide> scutigera: I'm not sure, actually, I've not played with Gambit in forever.
21:29:03 <Philippa> copumpkin: there's an argument to be had that scheme's strongly typed, no? Just not statically typed
21:29:09 <scutigera> yeah Marc stopped working on it for quite a while, but then got back on it in a big way.
21:29:54 <arcfide> Philippa: Assuming you're willing to play games with your terms, then Scheme is either completely untyped or Strongly Typed (note the capitalization) or both.
21:30:16 <Philippa> arcfide: some of us just use Network.CGI - it's fairly basic but it's also pretty easy to work with
21:30:31 <Philippa> eh, capitalisation not required
21:30:36 <arcfide> Philippa: Ah, okay, so Haskell also has a basic CGI library?
21:30:42 <Philippa> yep
21:30:50 <Philippa> and combinators for producing (X)HTML
21:30:55 <arcfide> Right.
21:37:13 <Sagi> anyone with a comment on my quickcheck-test of csum16? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23014#a23014
21:39:51 <kentaro> How to change the behaviour of functions, if possible, depending on type of variables? I want something like "instanceOf" in Java.
21:40:00 <roboshibby> ceil 10/3
21:40:11 <roboshibby> > ceil 10 / 3
21:40:12 <lambdabot>   Not in scope: `ceil'
21:40:17 <roboshibby> ?
21:40:20 <roboshibby> help?
21:40:44 <scutigera> ceiling
21:40:45 <Philippa> kentaro: you can't, and it's a feature
21:40:51 <scutigera> > ceiling 10/3
21:40:52 <lambdabot>   Ambiguous type variable `b' in the constraints:
21:40:53 <lambdabot>    `GHC.Real.Fractional b'
21:40:53 <lambdabot> ...
21:40:59 <scutigera> > ceiling 10/3::double
21:41:00 <lambdabot>   Could not deduce (GHC.Real.Integral double) from the context ()
21:41:01 <lambdabot>    arising ...
21:41:04 <Philippa> kentaro: what you can do is use a type class
21:41:05 <kentaro> Thanks. > Philippa
21:41:29 <MaciejP> > ceiling (10/3) :: Double
21:41:30 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
21:41:30 <lambdabot>    arising from a use ...
21:41:54 <Philippa> do you have a use case in mind? Perhaps you could handle it better another way
21:42:11 <scutigera> > ceiling(10.0/3.0)
21:42:12 <lambdabot>   4
21:42:15 <MaciejP> > ceiling (10/3 :: Double)
21:42:15 <chipmonkpyro> anyone willing to help me out real quick?
21:42:16 <lambdabot>   4
21:42:43 <blackdog> chipmonkpyro: just ask, don't ask to ask
21:42:43 <scutigera> > ceiling $ 10/3
21:42:44 <lambdabot>   4
21:42:47 <kentaro> So you can't write a function which converts Num to Fractional if needed, right?
21:43:05 <chipmonkpyro> im trying to load the Char file from haskell 98
21:43:07 <kentaro> toFracIfNeeded (a :: Fractional) = a
21:43:19 <chipmonkpyro> when i put import Char at the top of my file
21:43:24 <chipmonkpyro> it gives me this error
21:43:26 <kentaro> toFracIfNeeded (a :: Integral) = fromIntegral a
21:43:36 <chipmonkpyro> Char.hs:57:1: lexical error at character 'i'
21:43:38 <chipmonkpyro> Failed, modules loaded: none.
21:43:57 <chrissbx> If you say "data Foo = Bar | Baz" is the right term for this "union type"? (Or "type union" or ?)
21:43:58 <Philippa> kentaro: correct, you can't. You can build a typeclass that contains both Fractional and Integral, though
21:44:25 <kentaro> Thanks. I'll try.
21:44:30 <MaciejP> chipmonkpyro: Did you insert "module ... " at the top of your file?
21:44:42 <chipmonkpyro> no
21:44:44 <chipmonkpyro> ill try that
21:44:51 <scutigera> chipmonkpyro: that's bad.  you don't have another file Char.hs somewhere in your path do you ?
21:44:53 <Philippa> class Fractionable n where toFraction :: (Fractional f) => n -> f
21:45:01 <scutigera> import Char without module works for me
21:45:36 <Philippa> or is Fractional a type? I forget :-)
21:45:51 <Philippa> chrisdone: union type works
21:45:54 <chipmonkpyro> ok
21:45:56 <Philippa> chrissbx, even
21:46:07 <Zeiris_> I wish there was a tool to automatically refactor, simplify, and gold Haskell code. Surely that sort of thing is possible with the type system.
21:46:08 <chipmonkpyro> i did still have a char.hs when i was trying to get it working earlier
21:46:11 <chipmonkpyro> just deleted it
21:46:14 <Zeiris_> s/gold/golf
21:46:14 <chipmonkpyro> this is what i get
21:46:23 <chipmonkpyro> hw5.hs:6:0:
21:46:25 <chipmonkpyro>     Bad interface file: C:\PROGRA~2\CIS252\200920~1.2\haskell98-1.0.1.0\Char.hi
21:46:26 <chipmonkpyro>         magic number mismatch: old/corrupt interface file? (wanted 129742, got 537000654)
21:46:28 <chipmonkpyro> Failed, modules loaded: none.
21:46:35 <Philippa> Zeiris_: HaRe, and some of the lambdabot plugins. Not fully automated, sure
21:47:01 <Philippa> if you can identify specific 'normal forms', it can be written
21:47:13 <chrissbx> Ok. When I want to match members from a union type which has been defined in a different file in a pattern, how do I go about this?
21:47:21 <chrissbx> (i.e. how do I export constructors?)
21:48:01 <Philippa> An algebraic datatype T declared by a data or newtype declaration may be named in one of three ways:
21:48:01 <Philippa>     * The form T names the type but not the constructors or field names. The ability to export a type without its constructors allows the construction of abstract datatypes (see Section 5.8).
21:48:01 <Philippa>     * The form T(c1,...,cn), names the type and some or all of its constructors and field names.
21:48:01 <Philippa>     * The abbreviated form T(..) names the type and all its constructors and field names that are currently in scope (whether qualified or not).
21:48:08 <Philippa> (taken from the Haskell Report)
21:48:19 <chipmonkpyro> ok ignore all
21:48:24 <chipmonkpyro> i got it working myself :)
21:48:31 <chipmonkpyro> thanks regardless
21:48:35 <scutigera> chipmonkpyro: well, what was the problem ?
21:48:39 <chipmonkpyro> well
21:49:00 <chipmonkpyro> i had tried saving in a different coding format thinking that was the problem
21:49:15 <chipmonkpyro> when it was really that it was trying to access the char.hs
21:49:29 <chipmonkpyro> so i replaced that file with the origanal
21:49:34 <chipmonkpyro> and it works just fine now
21:49:40 <copumpkin> http://en.wikipedia.org/wiki/Design_pattern_(computer_science) that list makes me feel ill
21:49:50 <Philippa> Zeiris_: eventually someone'll hook HaRe up to a GUI - you could start work on that yourself if you want the tool badly enough :-)
21:49:53 <copumpkin> no wonder programmers' minds rot
21:50:16 <chipmonkpyro> oh btw i found a neat way to install haskell with emacs with haskell mode on windows :)
21:50:23 <scutigera>  (>>>) :: a b c -> a c d -> a b d ; what kind of type signature is a b c, it's not a tuple is it ?
21:50:27 <chipmonkpyro> i showed my teacher and he was pretty impressed
21:50:36 <copumpkin> scutigera: a is a * -> * -> *
21:50:55 <Zeiris_> Philippa, oh if only I had that much time :D
21:51:02 <Zeiris_> A Haskell IDE (besides VIM) would be neato
21:51:09 <copumpkin> one way is to rewrite that is (>>>) : (b ~> c) -> (c ~> d) -> (b ~ d)
21:51:28 <Philippa> Zeiris_: I'm pretty sure there are projects working on that one way or another. Don't know if any integrate HaRe yet though
21:51:29 <scutigera> copumpkin: sorry, can you use smaller words ?
21:51:58 <Philippa> (personally I make do with jEdit with the projectviewer and console plugins)
21:51:59 <tensorpudding> there is Leksah
21:52:09 <copumpkin> scutigera: sorry, it's generalizing the things of the same kind as (->) (the function arrow)
21:52:13 <tensorpudding> also plugins for eclipse, and a haskell-mode for emacs
21:52:35 <copumpkin> scutigera: so it gives you things that act like functions but aren't necessarily plain functions
21:52:45 <copumpkin> scutigera: since it
21:53:19 <copumpkin> is in Control.Category, it's talking about the morphisms of that category (a in the type signature you pasted above), so (>>>) is just forward composition of morphisms
21:53:57 <tensorpudding> damn, just noticed leksah is haskel backwards
21:54:16 * copumpkin pats tensorpudding on the head
21:54:51 <copumpkin> scutigera: sorry, that may have been unclear :( I'm kind of out of it :)
21:54:59 <Philippa> it would be more obvious if it were lleksah, I guess
21:55:03 <scutigera> copumpkin: but what's the concrete representation of "a b c" is a a type, so it's something like T b c ?
21:55:14 <copumpkin> scutigera: yep, or (->) b c
21:55:14 <Philippa> scutigera: exactly
21:55:22 <copumpkin> which is just b -> c
21:55:23 <Philippa> or even (b,c)
21:55:38 <Philippa> (but there's no arrow instance for that in practice)
21:55:53 <copumpkin> scutigera: of course, only some type constructors will actually work given the methods they need to satisfy
21:56:05 <scutigera> btw, I only ask this, because I was looking at arrows :-)
21:56:06 <copumpkin> so as Philippa said there's no meaningful one for (,)
21:56:30 <scutigera> copumpkin: aah, I _sort_ of see, which is farther along than I was 2 min ago :-)
21:57:35 <Philippa> scutigera: it's abstracting on "function-like things", hence a b c instead of T b c. A little confusing if you've not met the kind system, perhaps
21:57:54 <Philippa> I can give you a quick explanation of that, if you like?
21:57:55 <copumpkin_> lame, my power went out :o
21:58:03 <scutigera> Philippa: please !
21:58:29 <Philippa> okay. "Basic" types like Int have the kind * - we write Int :: *, just like 1 :: Int
21:58:45 <pikhq> It's a bit less confusing when you use ~> instead. "b ~> c" is just... Easier to grok than "a b c".
21:58:51 <pikhq> (in this specific instance)
21:58:54 <Philippa> but there are other things running around at the type level, like type constructors
21:59:02 <Philippa> for example, [] - the type constructor for lists
21:59:06 <Philippa> [] :: * -> *
21:59:22 <Philippa> it takes a type and gives you a type. Say, [Int]
21:59:27 <scutigera> cuz lists can hold any type ?
21:59:31 <Philippa> you can have [[Int]] too, but not [[]]
21:59:38 <chipmonkpyro> my proffesor is having us put (Eq a) => before the type declaration of a function
21:59:44 <Philippa> or at least, you /can/, but it's not a type yet, it's not got kind *
21:59:53 <chipmonkpyro> can someone tell me what it does?
21:59:53 <Philippa> and yes, because lists can hold any type
22:00:12 <Philippa> chipmonkpyro: it says the type a has Equality
22:00:16 <copumpkin_> chipmonkpyro: it puts a constraint on the type variable a, saying it must be an instance of Eq
22:00:25 <Philippa> (more literally, that it's an instance of the Eq type class)
22:00:33 <chipmonkpyro> (Eq a) => a -> [a] -> [Int]
22:00:41 <chipmonkpyro> thats the whole type declaration
22:00:43 <chipmonkpyro> so its saying
22:00:57 <chipmonkpyro> a is an eqation?
22:01:00 <Philippa> scutigera: if you've got that much re kinds you've almost grasped everything they can do, btw
22:01:09 <copumpkin> chipmonkpyro: nope, it's saying that a is a type that it makes sense to call == on
22:01:18 <copumpkin> chipmonkpyro: not every type can be compared for equality
22:01:22 <copumpkin> so you only want types that can be
22:02:19 <chipmonkpyro> but its not actually an input just a property right?
22:02:24 <scutigera> Philippa: so what's the b ~> c notation.  Does it imply that b and c must be objects of a type constructor ?
22:02:48 <copumpkin> chipmonkpyro: yep, it's a bit like an interface in java, if you've come across those (/me hides from dobblego)
22:02:49 <Philippa> scutigera: that's just using ~> as an infix name for a type variable
22:02:56 <Philippa> it's equivalent to a b c
22:03:08 <chipmonkpyro> kk thanks
22:03:40 <Philippa> chipmonkpyro: there's sort-of an input - it's implemented by passing in a "dictionary" that tells the function how to do equality on that type
22:03:56 <Philippa> instances tell the compiler how to build the dictionary for a given type
22:03:58 <scutigera> Philippa: so I know that a _must_ be a type constructor because of it's position.  but as copumpkin said, it's limited cuz it must support arrow rules.
22:04:05 <Philippa> scutigera: yep
22:04:13 <copumpkin> scutigera: yeah, so you could try writing one for Either, but you'd fail
22:04:15 <copumpkin> :k Either
22:04:16 <lambdabot> * -> * -> *
22:04:17 <copumpkin> :k (,)
22:04:18 <Philippa> but the kind system doesn't do that limiting, the type class system does
22:04:18 <lambdabot> * -> * -> *
22:04:26 <copumpkin> :k Kleisli
22:04:27 <lambdabot> (* -> *) -> * -> * -> *
22:04:36 <copumpkin> :k Kleisli Cont
22:04:37 <lambdabot>     `Cont' is not applied to enough type arguments
22:04:37 <lambdabot>     Expected kind `* -> *', but `Cont' has kind `* -> * -> *'
22:04:44 <copumpkin> :k Kleisli (Cont Bool)
22:04:45 <lambdabot> * -> * -> *
22:04:55 <scutigera> copumpkin: try writing "one" what ? arrow class ?
22:05:02 <Philippa> arrow instance, yeah
22:05:19 <scutigera> :t Either
22:05:20 <copumpkin> scutigera: you might still want to try though :)
22:05:20 <lambdabot> Not in scope: data constructor `Either'
22:05:30 <enthymene> oh man, I need to go back to reading about arrows
22:05:34 <enthymene> but then... homework...
22:05:44 * enthymene DILEMMA
22:06:24 <scutigera> copumpkin: I think I'll get some ambitious student to try for me.
22:06:37 <Philippa> heh. That would be cruel
22:06:41 <copumpkin> scutigera: :)
22:06:51 <enthymene> scutigera: try what? *reads up*
22:06:53 <copumpkin> s/he would realize pretty quickly that it's impossible to write anything meaningful
22:07:22 <scutigera> and would then tell me that they figured it out, and won't tell me how.
22:07:44 <copumpkin> @djinn Either a b -> Either b c -> Either a c
22:07:44 <lambdabot> -- f cannot be realized.
22:07:51 <copumpkin> there, even djinn agrees :)
22:08:10 <copumpkin> @djinn (a, b) -> (b, c) -> (a, c)
22:08:10 <lambdabot> f (a, _) (_, b) = (a, b)
22:08:16 <copumpkin> :P
22:08:38 <scutigera> copumpkin: you know that's really weird !  You wouldn't think that something couldn't be done based on the type signature's alone.  I'd think that anything works as a type sig...
22:08:55 <copumpkin> scutigera: it's the beauty of Curry-Howard :)
22:09:06 <scutigera> copumpkin: oops.  it's because you're specifically using Either , right ?
22:09:08 <copumpkin> scutigera: write me a function forall a b. a -> b
22:09:32 <scutigera> :t fromInteger
22:09:33 <lambdabot> forall a. (Num a) => Integer -> a
22:09:40 <Philippa> copumpkin: const undefined :p
22:09:45 <copumpkin> Philippa: lol
22:09:58 <copumpkin> scutigera: that's not a -> b
22:10:08 <copumpkin> that's a specific a -> a restricted class of b
22:10:08 <Philippa> (but that's your only option, unsafePerformBastardry aside)
22:10:35 <Philippa> :t fromInteger :: a -> b
22:10:36 <lambdabot>     Could not deduce (Num b) from the context ()
22:10:36 <lambdabot>       arising from a use of `fromInteger' at <interactive>:1:0-10
22:10:36 <lambdabot>     Possible fix:
22:10:47 <scutigera> a restricted class of 'b' or a restricted class of 'a' ?
22:10:48 <Philippa> just to make the point
22:11:05 <Philippa> scutigera: both, as it happens
22:11:05 <copumpkin> scutigera: `a` is a concrete type (Integer), and `b` is restricted to things that are Num
22:11:19 <copumpkin> I want a fully general a -> b :)
22:11:36 <scutigera> _any_ type to _any_ other type ?
22:11:39 <copumpkin> given a value of any type, write a function that returns any other type
22:11:39 <copumpkin> ye
22:11:51 <Philippa> not only that, but copumpkin wants one that isn't equivalent to const undefined, because const undefined is pretty useless
22:12:01 <scutigera> :t const
22:12:02 <lambdabot> forall a b. a -> b -> a
22:12:07 <Philippa> always best to say that out loud
22:12:13 <copumpkin> yep
22:12:24 <Philippa> :t const undefined
22:12:25 <lambdabot> forall a b. b -> a
22:12:31 <scutigera> CONST UNDEFINED IS PRETTY USELESS
22:12:41 <pikhq> Yes, but it does typecheck.
22:12:50 <copumpkin> scutigera: do you see why I can't write a _meaningful_ a -> b function?
22:12:54 <pikhq> (if only because undefined :: b)
22:13:24 <copumpkin> undefined is evil, because it pretends to be of any type at all
22:13:33 <copumpkin> but if you ignore it, things get a lot prettier
22:13:55 <pikhq> Eh, just a consequence of Haskell being Turing-complete.
22:14:03 <copumpkin> which is ugly :)
22:14:12 <nus> copumpkin, easy. your function would be (->)
22:14:20 <copumpkin> :o
22:14:23 <pikhq> nus: Not a function.
22:14:34 <copumpkin> it's a type-level function (and type constructor), if you insist
22:14:42 <copumpkin> but it still doesn't have that type (kind)
22:15:26 <nus> forall a b. you mean?
22:15:48 <scutigera> copumpkin: *sigh* no.  I can only think of specific things like String -> Float, Float -> String, etc.. I'd need dynamic typing, in a sense, to do it.
22:16:26 <scutigera> :t \_ -> 0
22:16:27 <lambdabot> forall t t1. (Num t1) => t -> t1
22:16:34 <copumpkin> scutigera: even with dynamic typing, you couldn't do it. The basic point is that you are Mr Function, and I've given you a widget and your customer demands a steak from it. You have no steaks, so you can't give him one
22:16:47 <copumpkin> scutigera: your customer can ask you for anything at all, and you have no control over what your supplier gives you
22:16:58 <copumpkin> scutigera: it's a hopeless business venture, and you will go bankrupt very quickly
22:17:13 <copumpkin> (unless you package up poop in a box and send him that, which is what undefined and related values are)
22:17:29 <scutigera> copumpkin: right, so I'd need an inifinite warehouse.
22:17:51 <copumpkin> furthermore, you're actually blind :)
22:17:59 <copumpkin> scutigera: you don't actually know anything about what your supplier gave you :P
22:18:03 <scutigera> copumpkin: well, that makes it harder.
22:18:17 <copumpkin> you can't do anything different based on what it is
22:18:37 <scutigera> so really, when it comes to a -> b, abandon all hope, ye who type here.
22:18:47 <copumpkin> so you couldn't say "if I'm given an Int, then do X, otherwise if given a Bool, do Y, otherwise Z"
22:18:52 <copumpkin> scutigera: basically :)
22:18:55 <copumpkin> scutigera: how about a -> a?
22:19:34 <scutigera> :t * 2
22:19:35 <lambdabot> parse error on input `*'
22:20:12 <copumpkin> read that as "I'm a blind merchant, but I know that my consumers always want the same thing my suppliers give"
22:20:21 <copumpkin> what are you going to do?
22:20:24 <scutigera> copumpkin: re "so you couldn't say", that's exactly what I was thinking.
22:20:50 <copumpkin> so how would you write f : a -> a?
22:20:54 <copumpkin> f :: a -> a, sorry :)
22:21:07 <scutigera> :t \n -> n * 2
22:21:08 <lambdabot> forall a. (Num a) => a -> a
22:21:10 <copumpkin> (keep in mind that we're ruling out shipments of poo)
22:21:15 <scutigera> for example
22:21:17 <copumpkin> scutigera: nope, you're blind, you don't know that it can be multiplied
22:21:27 <copumpkin> what if someone hands you a piece of cheese
22:21:30 <copumpkin> could you multiply that by 2?
22:21:38 <scutigera> identity function
22:21:41 <scutigera> :t \x -> x
22:21:42 <lambdabot> forall t. t -> t
22:21:43 <copumpkin> yep
22:21:57 <copumpkin> and further more, that's the only non-poopy function you can write for that type
22:22:14 <scutigera> and there's a proof for that (I bet)
22:22:31 <copumpkin> of course!
22:23:16 <scutigera> so when you talk about identity being the "only" function you are really talking in terms of "kinds". because *2 has the right signature.
22:23:21 <copumpkin> scutigera: how about a -> b -> a? you're a blind merchant with two suppliers of possibly different goods, and the only thing you know is that your customers want the same types of things as your first supplier supplies
22:23:35 <copumpkin> scutigera: nope, it has that crucial (Num a) =>
22:23:41 <copumpkin> that gives you a lot more information
22:23:57 <scutigera> copumpkin: oh, I get it.
22:23:59 <copumpkin> you're no longer blind, because you know your supplier gives you numbers and your customer wants numbers of the same type
22:24:15 <copumpkin> you might not be able to do some things with it, but you can do numbery things to it like multiply it
22:24:25 <scutigera> :t \x y -> x
22:24:26 <lambdabot> forall t t1. t -> t1 -> t
22:24:37 <copumpkin> yep
22:24:40 <pikhq> Or just make a number of your choice and send that on down.
22:25:00 <copumpkin> yep, Num gives you the magic ability to generate Nums at will
22:25:08 <Cale> You can also (if it helps) think of the (Num a) as being an extra value which is secretly passed to your function, containing all the operations necessary for working with numbers of type a
22:25:40 <scutigera> Cale: this relates to what I often see as "qualified" type sig ?
22:26:05 <Cale> qualified with a typeclass constraint?
22:26:05 <Philippa> Cale: already covered :-)
22:26:07 <George_> I'm kind of new to Haskell. What advantage does // fib = 0 : 1 : (zipWith (+) fib (tail fib)) // have over // fib a b = a : (fib b (a + b)) // ?
22:27:05 <copumpkin> scutigera: anyway, with those types it helps a lot to think about what you know about your inputs and your outputs, and where you can fetch things from. And that's sort of how @djinn works
22:27:07 <copumpkin> @djinn a -> b -> a
22:27:07 <lambdabot> f a _ = a
22:27:12 <pikhq> George_: Don't have to write "fib 0 1" just to get an infinite list.
22:27:20 <Cale> George_: not a whole lot, except that the first defines a list, and the second defines a function?
22:27:24 <copumpkin> @djinn a -> b
22:27:24 <lambdabot> -- f cannot be realized.
22:27:40 <scutigera> @djinn a -> a
22:27:40 <lambdabot> f a = a
22:27:46 <Cale> > fibs = let fib a b = a : fib b (a + b) in fib 0 1
22:27:47 <lambdabot>   <no location info>: parse error on input `='
22:27:53 <scutigera> @djinn  (b -> c) -> a b c
22:27:53 <lambdabot> -- f cannot be realized.
22:27:58 <George_> Cale: I think both of them define a list, which is the same as a function...
22:28:01 <Cale> > fibs = let { fib a b = a : fib b (a + b) } in fib 0 1
22:28:02 <lambdabot>   <no location info>: parse error on input `='
22:28:06 <copumpkin> scutigera: with no typeclass constraint, that is impossible
22:28:07 <Cale> oh, duh
22:28:14 <Cale> > let fibs = let { fib a b = a : fib b (a + b) } in fib 0 1 in fibs
22:28:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:28:18 <George_> But the first one, you can "seed" the sequence with any 2 values
22:28:21 <copumpkin> scutigera: that would be saying you could have a (b -> c) -> Either b c
22:28:27 <George_> I was wondering more about performance-wise
22:28:31 <copumpkin> or a (b -> c) -> (b, c)
22:28:35 <George_> The insides of the interpreter
22:28:43 <scutigera> copumpkin: class Arrow a :-)
22:28:49 <Cale> Well, let's interpret
22:28:53 <Cale> fib 0 1
22:28:57 <copumpkin> scutigera: yep, with that extra bit of information it can do a lot more
22:29:02 <Cale> -> 0 : fib 1 (0 + 1)
22:29:05 <copumpkin> (but djinn doesn't know about Arrow, sadly)
22:29:28 <copumpkin> scutigera: you can come up with arbitrarily complex types and ask @djinn to figure them out for you
22:29:33 <Cale> -> 0 : 1 : fib (0 + 1) (1 + (0 + 1))
22:29:34 <scutigera> copumpkin: interesting. I don't have to call it Arrow, it could be Mud. Arrow's just more descriptive.
22:29:39 <copumpkin> yep
22:30:00 <scutigera> copumpkin: yeah @djinn is fun.  can I get to it in ghci ?
22:30:01 <Cale> -> 0 : 1 : (0 + 1) : fib (1 + (0 + 1)) ((0 + 1) + (1 + (0 + 1)))
22:30:12 <copumpkin> scutigera: not sure, don't think so :)
22:30:15 <Cale> -> 0 : 1 : 1 : fib (1 + 1) (1 + (1 + 1))
22:30:34 <copumpkin> scutigera how about a harder one: (c -> a -> b) -> (c -> a) -> (c -> b)
22:30:34 <Cale> (note, I am not writing the sharing explicitly, while I probably should be to make it clear what's going on.)
22:30:38 <George_> I take it you're using the zipWith method?
22:30:53 <pikhq> Cale: Hey, (0 + 1) is not actually evaluated there!
22:30:53 <Cale> No, this is the evaluation of fib 0 1, with your function definition of fib
22:30:54 <scutigera> copumpkin: kind of looks like a job for prolog ;-)  cabal install djinn.  it tried to work but failed on editline.
22:30:55 <pikhq> :P
22:31:04 <ddarius> pikhq: How do you know?
22:31:07 <copumpkin> scutigera: exactly right, actually :P
22:31:19 <Cale> I'm assuming that we're forcing the elements of the list one by one while printing it
22:31:53 <pikhq> ddarius: Actually, if I just go off of what's shown, "fib 0 1" is never evaluated in the first place. XD
22:32:17 <scutigera> copumpkin: thanks!  the type stuff is starting to sink in, which is very good because it's going to make reading haskell much easier.
22:32:39 <pikhq> scutigera: Indeed, it will. Really, it's almost essential to nontrivial Haskell.
22:32:55 <copumpkin> scutigera: the whole point of the Curry-Howard correspondence is to show that types are logical statements :) so something like a -> a is saying "forall a, a implies a" and the more complex ones all have logical interpretations. Programs you write with those types are proofs of the statements. saying "forall a and b, a implies b" is clearly false in logic, and indeed you can't prove it, no matter how hard you try
22:33:31 <copumpkin> scutigera: so your comment about prolog is spot on, and haskell types are essentially a logic language like prolog (but they're tied to values)
22:34:03 <scutigera> copumpkin: I was really thinking more in terms of backtracking to calculate type sigs...
22:34:46 <copumpkin> :)
22:34:50 <copumpkin> @djinn (c -> a -> b) -> (c -> a) -> (c -> b)
22:34:50 <lambdabot> f a b c = a c (b c)
22:34:52 <scutigera> copumpkin: I've got Goldblatt's book (Topoi), and I think it's going to help a lot.
22:35:22 <George_> is it something about the parameter passing that makes // fib a b = a : (fib b (a + b)) // lose out over the canonical zipWith way?
22:35:30 <Cale> lose out?
22:35:33 <scutigera> copumpkin: a good example.  so again 'a' _must_ be a type constructor, right?
22:35:42 <George_> in number of reductions
22:35:51 <copumpkin> scutigera: in that >>> signature, yep
22:36:09 <George_> yeah, fib is a dead horse, but it's a simple pet example
22:36:10 <scutigera> copumpkin: not in  'a c (b c)' ?
22:36:13 <Cale> George_: I wouldn't expect it to be any worse actually.
22:36:18 <Cale> Well...
22:36:20 <copumpkin> scutigera: oh no, in that it's all value-level
22:36:24 <Philippa> scutigera: no djinn in ghci, but you can probably lash up something using :! (runs shell commands) and lambdabot
22:36:40 <Cale> There are a few extra reductions you need to make near the beginning.
22:36:49 <scutigera> Philippa: it appears to be in hackage - but editline is broke
22:37:01 <copumpkin> scutigera: in f a b c that djinn spit out, f is a function, and so is b
22:37:07 <tumult> is there something like mapAccumL/R for the new vector library?
22:37:08 <copumpkin> :t f a b c = a c (b c)
22:37:09 <lambdabot> parse error on input `='
22:37:17 <copumpkin> :t let f a b c = a c (b c) in f
22:37:18 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
22:37:35 <copumpkin> it's exactly what I asked djinn for, which is a good thing :P
22:37:35 <pikhq> Cale: GHC would probably optimise them out.
22:38:02 <scutigera> but 'a c (b c)' doesn't make sense.  It can't be Int Double (String Int), or can it ?
22:38:28 <copumpkin> you're thinking on the wrong level :)
22:38:38 <copumpkin> these are value-level functions, and you're thinking of types
22:38:39 <chipmonkpyro> anyone figure out where im going wrong here...
22:38:44 <copumpkin> @djinn (c -> a -> b) -> (c -> a) -> (c -> b)
22:38:44 <lambdabot> f a b c = a c (b c)
22:38:46 <George_> heh, of course I'm not worried about micro-optimisations, but about how Haskell itself works
22:38:55 <copumpkin> scutigera: that's the type I'm asking for, in the @djinn
22:39:03 <copumpkin> it's coming up with a regular function that has that type
22:39:34 <scutigera> oh, a b c are just the args,  doesn't that imply that a is a function ?
22:39:44 <chipmonkpyro> myFindIndices :: (Eq a) => a -> [a] -> [Int]
22:39:45 <copumpkin> scutigera: yep!
22:39:46 <chipmonkpyro> myFindIndices x ys
22:39:47 <chipmonkpyro>     = map f (filter g (zip [0..] ys))
22:39:49 <chipmonkpyro>       where f (m,n) = [m]
22:39:51 <chipmonkpyro>             g (m,n) = (x == n)
22:39:51 <copumpkin> scutigera: but not a type function
22:39:52 <chipmonkpyro> myFindIndices 1 [1,2,3,1,2,3,1,2,3,1,2,3]       -- should return [1,4,7,10]
22:40:00 <copumpkin> it's a value function :)
22:40:08 <scutigera> copumpkin: got it, I think.
22:40:14 <copumpkin> scutigera: this is a good intro to that stuff: http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
22:40:21 <Cale> George_: Well, Haskell isn't completely specified with regard to the order of evaluation
22:40:21 <chipmonkpyro> myFindIndices 'e' "thecakeisalie"    -- should return [3,7,13]
22:40:42 <Cale> George_: But roughly, it's lazy evaluation (except when the compiler figures out that strict would be better)
22:40:58 <scutigera> copumpkin: dude ! that's cold, you just gave me homework :-(
22:41:24 <BMeph> Is there a property that implies associativity, similar to the way that associativity implies commutativity?
22:41:25 <copumpkin> scutigera: lol, I'm just saying it's a nice set of brain teasers to get you in the groove thinking about types :) but you don't have to do it
22:41:33 <Cale> George_: Lazy evaluation is outermost-first evaluation, plus an additional optimisation that if a function parameter occurs more than once in the body of the function, it is evaluated at most once, and shared between the copies.
22:41:36 <copumpkin> associativity doesn't imply commutativity?
22:41:42 * SamB_XP ponders dobblego.wordpress.com
22:41:50 <copumpkin> Float is commutative but not associative
22:42:00 <copumpkin> (+) and (*) on it, at least
22:42:21 <SamB_XP> copumpkin: as is usual ;-P
22:42:22 <Cale> George_: So, for a toy example that I like to use to illustrate evaluation order, consider the function  double x = x + x
22:42:23 <MaciejP> chipmonkpyro: f(m,n) = [m] should read f(m,n) = m
22:42:33 <Cale> George_: and suppose we want to evaluate  double (double 5)
22:42:41 <scutigera> copumpkin: just kidding of course.  I need to get to that intuitive level so I don't have to spend some much time parsing.
22:42:43 <Cale> Under strict evaluation, this goes:
22:42:46 <Cale> double (double 5)
22:42:50 <Cale> -> double (5 + 5)
22:42:52 <Cale> -> double 10
22:42:56 <Cale> -> 10 + 10
22:42:57 <chipmonkpyro> yay that worked
22:42:58 <Cale> -> 20
22:43:00 <scutigera> copumpkin: exercise is definitely the best way.
22:43:05 <Cale> strict evaluation is innermost-first
22:43:16 <SamB_XP> scutigera: consider purchasing a unicycle!
22:43:24 <BMeph> > findIndices 1 [1,2,3,1,2,3,1,2,3,1,2,3]
22:43:25 <SamB_XP> I hear it's an interesting way to excercise
22:43:25 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
22:43:26 <lambdabot>    arising from the lite...
22:43:29 <copumpkin> scutigera: yeah :) once you get more comfortable with it, you should try agda! it's like haskell but even more strict! best dominatrix ever
22:43:36 <Cale> Under plain outermost-first (also called normal-order) evaluation, it goes like this:
22:43:38 <Cale> double (double 5)
22:43:41 <BMeph> > findIndices (==1) [1,2,3,1,2,3,1,2,3,1,2,3]
22:43:42 <lambdabot>   [0,3,6,9]
22:43:44 <Cale> -> (double 5) + (double 5)
22:43:50 <Cale> -> (5 + 5) + (double 5)
22:43:53 <Cale> -> 10 + (double 5)
22:43:56 <Cale> -> 10 + (5 + 5)
22:43:59 <Cale> -> 10 + 10
22:44:00 <Cale> -> 20
22:44:23 <pikhq> Hey, you're actually pasting it now.
22:44:29 <Cale> I'm not.
22:44:35 <pikhq> ...
22:44:36 <chipmonkpyro> hm
22:44:44 <chipmonkpyro> findIndices (==1) [1,2,3,1,2,3,1,2,3,1,2,3] works but thats not how i need it to be
22:44:45 <pikhq> You should. You give this lecture a lot. :P
22:44:52 <George_> yep, that's all good
22:45:00 <Cale> Clearly, this wastes work recomputing the double 5, because it was the x parameter to double, and x occurred twice in the body of double.
22:45:32 <Cale> So, if you'll let me use let/in to denote the sharing, what lazy evaluation does is like this:
22:45:36 <Cale> double (double 5)
22:45:50 <Cale> -> let x = double 5 in x + x -- note: this is still outermost-first
22:45:58 <Cale> -> let x = 5 + 5 in x + x
22:46:02 <Cale> -> let x = 10 in x + x
22:46:03 <SamB_XP> Cale: hmm, you maybe should charge for your lecture-on-demand services ?
22:46:06 <BMeph> copumpkin: "P implies Q" means that you don't have P being true but Q being false. Maybe I remember it backwards, but that's the definition I meant when I said "associativity implies commutativity". :)
22:46:07 <Cale> -> 10 + 10
22:46:08 <Cale> -> 20
22:46:10 <SamB_XP> maybe do a cable channel ?
22:46:19 <chipmonkpyro> wtf
22:46:28 <George_> chipmonkpyro: let's do it the newbie way :)
22:46:37 <chipmonkpyro>  myFindIndices 'e' "thecakeisalie" returns [2,6,12]
22:46:51 <copumpkin> BMeph: either way, there's no implication in either direction :)
22:46:51 <Cale> > cake
22:46:52 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
22:47:02 <chipmonkpyro> but myFindIndices 'i' "mississippi" returns [1,4,7,10]
22:47:04 <Cale> > drop 10 cake
22:47:06 <lambdabot>   ["Fish shaped candies.","Fish shaped solid waste.","Fish shaped dirt.","Fis...
22:47:19 <BMeph> chipmonkpyro: Then use "myFindIndices = findIndices . (==)"; problem Solved! ;)
22:47:28 * SamB_XP is reminded YET AGAIN that he wants to play portal but has nothing on which to *do* it
22:47:34 <chipmonkpyro> not allowed to :(
22:47:37 <chipmonkpyro> its a hw problem
22:47:39 <copumpkin> mmm portal
22:47:43 <Cale> SamB_XP: I played it under linux using wine
22:47:44 * copumpkin even remembers finding that cake recipe
22:47:46 <chipmonkpyro> i have to answer it with the format i gave
22:47:54 <chipmonkpyro> i know im close but somethings not working right
22:47:56 <copumpkin> ...such a good game
22:47:59 <SamB_XP> Cale: I meant hardware-wise
22:48:13 <SamB_XP> I have nothing that could run a game that recent
22:48:59 <Cale> Now all we need is an aalib version of wine to help SamB_XP out.
22:49:03 <George_> @help
22:49:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:49:07 <George_> @list
22:49:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:49:20 <SamB_XP> Cale: no, that's not what I meant
22:49:26 <BMeph> copumpkin: http://arxiv.org/PS_cache/math/pdf/0506/0506600v14.pdf suggests otherwise. :)
22:49:30 <SamB_XP> I actually want to play with some GRAPHICS
22:49:34 <Cale> hehe
22:49:42 <SamB_XP> and it would also be nice to be able to read the text ...
22:49:47 <SamB_XP> ... aalib sucks for that!
22:50:00 <copumpkin> BMeph: not of the operation itself, though! :P
22:50:13 <sinelaw> there could be a aalib version of Mesa that renders text as....text
22:50:23 <sinelaw> but that is useless
22:50:24 <SamB_XP> but still, that song is just so intriguing!
22:50:29 <SamB_XP> I gotta find out what it all means!
22:50:38 <BMeph> chipmonkpyro: What are the rules of your homework problem?
22:50:42 <copumpkin> sinelaw: black mesa?
22:50:53 <chipmonkpyro> myFindIndices 'i' "mississippi"
22:50:55 <chipmonkpyro> should return [1,4,7,10].
22:50:58 <SamB_XP> I especially like the Gamer Symphony Orchestra version
22:51:11 <SamB_XP> Cale: have you heard that ?
22:51:16 <Cale> This was a triumph. I'm making a note here: huge success. It's hard to overstate my satisfaction.
22:51:19 <BMeph> > ( findIndices . (==)) 'i' "mississippi"
22:51:20 <lambdabot>   [1,4,7,10]
22:51:28 <chipmonkpyro> be of format
22:51:30 <chipmonkpyro> myFindIndices : : (Eq a) => a -> [a] -> [Int]
22:51:31 <chipmonkpyro> myFindIndices x ys
22:51:33 <chipmonkpyro> = map _________ (filter ____________ (zip [0..] ys))
22:51:33 <BMeph> chipmonkpyro: ^^ -- like that? ;)
22:51:45 <chipmonkpyro> well im not allowed to do that :P
22:51:51 <Cale> SamB_XP: Ah, I hadn't
22:51:51 <copumpkin> chipmonkpyro: you can do it!
22:52:01 <SamB_XP> it's really a nice performance
22:52:04 <chipmonkpyro> nah i mean the teacher wont let me
22:52:09 <copumpkin> chipmonkpyro: I mean, using that pattern
22:52:16 <chipmonkpyro> oh
22:52:17 <copumpkin> chipmonkpyro: first look at the type of filter
22:52:19 <copumpkin> :t filter
22:52:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:52:33 <copumpkin> so the list it gets and the list it spits out must be of the same type
22:52:53 <Philippa> SamB_XP: if you don't fancy building a PC, there's a version of Portal for the 360 on XBLA too which might be a cheaper approach for a given level of gaming quality?
22:53:01 <copumpkin> now, since you've zipped a list of Ints with your list, you have a [(Int, a)], so what do you want your map to do?
22:53:04 <chipmonkpyro> the definition has to be myFindIndices : : (Eq a) => a -> [a] -> [Int]
22:53:15 <copumpkin> chipmonkpyro: yep, I'm just saying using the pattern you gave
22:53:19 <chipmonkpyro> hm
22:53:32 <SamB_XP> Philippa: I know it's also for Xbox 360 -- I don't have one of those either!
22:53:33 <BMeph> :t findIndices . (==)
22:53:34 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
22:53:40 <chipmonkpyro> well i wanted to generate the list using zip as (x,ys)
22:53:50 <copumpkin> here, let's try this a sec
22:53:58 <chipmonkpyro> then filter out the cases where x/=y
22:54:07 * BMeph is apparently missing something...
22:54:11 <chipmonkpyro> then map the second number out
22:54:19 <copumpkin> :t let myFindIndices x ys = map ?f (filter ?g (zip [0..] ys))
22:54:20 <lambdabot> <no location info>:
22:54:21 <lambdabot>     not an expression: `let myFindIndices x ys = map ?f (filter ?g (zip [0..] ys))'
22:54:23 <chipmonkpyro> so its only a list of the locations not the letter or number itself
22:54:26 <copumpkin> :t let myFindIndices x ys = map ?f (filter ?g (zip [0..] ys)) in myFindIndices
22:54:27 <lambdabot> forall t t1 b b1. (Enum t, Num t, ?g::(t, b) -> Bool, ?f::(t, b) -> b1) => t1 -> [b] -> [b1]
22:54:38 <copumpkin> ugh
22:54:49 <copumpkin> :t let myFindIndices x ys = map ?f (filter ?g (zip [(0 :: Int)..] ys)) in myFindIndices
22:54:50 <lambdabot> forall t b b1. (?f::(Int, b) -> b1, ?g::(Int, b) -> Bool) => t -> [b] -> [b1]
22:54:51 <Philippa> SamB_XP: I meant a cheaper approach to obtaining hardware :-)
22:54:57 <copumpkin> chipmonkpyro: okay, sorry
22:55:21 <chipmonkpyro> i have to do it a certain way guys :(
22:55:29 <copumpkin> chipmonkpyro: that's what I'm showing you how to do :P
22:55:41 <chipmonkpyro> = map ___ (filter ____(zip [0..] ys))
22:55:42 <copumpkin> chipmonkpyro: I simply substituted symbols into your pattern
22:55:52 <copumpkin> yes, I replaced your underlines with ?f and ?g
22:55:59 <chipmonkpyro> ok
22:56:09 <copumpkin> that way you can ask lambdabot what types need to go into those holes
22:56:14 <chipmonkpyro> is this ok for f and g?
22:56:15 <tomberek> hey guys!
22:56:17 <chipmonkpyro> where f (m,n) = m
22:56:19 <chipmonkpyro>             g (m,n) = (x == n)
22:56:29 <chipmonkpyro> thats what i have now
22:56:30 <copumpkin> yep!
22:56:32 <tomberek> Alpounet: ya there?
22:56:40 <Cale> George_: anyway, does that clear things up any?
22:56:50 <chipmonkpyro> well for some reason two outputs seem to be conrtadicting each other
22:57:14 <George_> yeah, but I'm going to delve deeper into the inner workings of Haskell too
22:57:21 <copumpkin> chipmonkpyro: ?
22:57:43 <tomberek> copumpkin: is there a lambdabot guide... seems like it has a lot of useful features
22:57:46 <chipmonkpyro> myFindIndices 'e' "thecakeisalie"   currently returns [3,7,13]
22:57:47 <Cale> George_: If you're interested in the concrete implementation in hardware, probably the best place to start is the STG machine paper.
22:57:48 <chipmonkpyro> myFindIndices 'i' "mississippi" currently returns [1,4,7,10]
22:57:53 <chipmonkpyro> those contradict each other...
22:58:03 <copumpkin> tomberek: hmm, I haven't seen one :) I just picked it up by watching people in here
22:58:10 <tomberek> ah
22:58:25 <copumpkin> chipmonkpyro: why?
22:58:38 * BMeph also would like to know why
22:58:42 <Cale> @where stg
22:58:42 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
22:58:49 <Axman6> copumpkin: because they do :P
22:58:55 <chipmonkpyro> oh wait
22:58:57 <chipmonkpyro> nvm
22:59:00 <chipmonkpyro> :P
22:59:00 * BMeph does not mean the Lucky Stiff, though.
22:59:07 * copumpkin sticks his tongue out at Axman6 
22:59:16 <George_> that sounds interesting
22:59:22 <Axman6> no, one is wrong...
22:59:29 <George_> I've read most of "The Implementation of Functional Languages" as well
22:59:41 <BMeph> finds a spare '' lying around and gives it to copumpkin...
22:59:42 <Axman6> e is in position 3, which is ok, but the first i is in position 2 if the e is in three
22:59:45 <George_> got me interested in lambda calculus and all...
22:59:48 <chrissbx> What is "the" way to handle errors / exceptions (I'm writing an interpreter, and using Haskell's arithmetics, so if that gives an error I should be able to control it somehow, same thing with pattern match failures)
22:59:51 <copumpkin> BMeph: oh no, don't tell ray
23:00:05 <chipmonkpyro> myFindIndices 'e' "thecakeisalie"    -- should return [2,6,12]
23:00:15 <chipmonkpyro> but it actually returns [3,7,13]
23:00:23 <sinelaw> hey, i'm trying to wrap opencv. but to work on images, i need to pre-allocate them. i want to wrap the transforming functions as purely functional, but that means i somehow have to copy with the allocation stuff
23:00:25 <sinelaw> how to do it?
23:00:26 <chipmonkpyro> myFindIndices 'i' "mississippi"      -- should return [1,4,7,10]
23:00:30 <chipmonkpyro> and it does...
23:00:39 <sinelaw> s/copy/cope
23:00:51 <copumpkin> chipmonkpyro: did you zip with [1..] ?
23:00:57 <chipmonkpyro> yes
23:01:03 <copumpkin> should you?
23:01:13 <chipmonkpyro> actually it should be 0
23:01:17 <chipmonkpyro> but one of them will still be wrong
23:01:21 <copumpkin> :o
23:01:31 <Cale> chrissbx: It can be a bit tricky to catch some of those. You use Control.Exception.catch along with evaluate from the same module to try to ensure that the error actually happens while you're still inside the catch.
23:01:36 <Axman6>  /me pokes HIS tongue out at copumpkin
23:01:43 <Axman6> hmm, where'd that soace come from
23:01:44 <chipmonkpyro> oh wait
23:01:45 <Axman6> p*
23:01:45 <chipmonkpyro> nvm
23:01:47 <George_> > 3
23:01:48 <lambdabot>   3
23:01:51 <chipmonkpyro> all works <3 you guys
23:01:52 * BMeph pokes HIS tongue out
23:02:01 <Cale> chrissbx: It would be better to check beforehand if you can.
23:02:10 <tomberek> copumpkin: if i have a polymorphic type like data Foo a b = ...  How can I make another type on top of it (monad style): Bar Foo a b?
23:02:25 * BMeph then eats his <3 out...
23:02:36 <sinelaw> does haskell's ffi have a way to tell me when it's garbage-collecting something i've allocated?
23:02:40 <Cale> tomberek: Do you just mean Bar (Foo a b) ?
23:02:47 <tomberek> Cale: yes
23:03:00 <copumpkin> sinelaw: ForeignPtr?
23:03:22 <tomberek> Cale: That's the type that I want.
23:03:24 <copumpkin> sinelaw: that's designed to carry a handler for what to do to clean up
23:03:44 <sinelaw> ok
23:04:21 * Cale eats the natural numbers' {0,1,2} out.
23:05:04 <tomberek> Cale: ?
23:05:17 <Cale> tomberek: See BMeph's last line
23:05:46 * sinelaw eats the left side of the complex plane, up to Re{z} < 3
23:05:47 <George_> > filter (<3) [0..]
23:05:49 <mornfall> Dear lords.
23:05:51 <lambdabot>   mueval-core: Time limit exceeded
23:05:59 <b52> how can i get my ~ path?
23:06:02 <tomberek> "then east his <3 out"
23:06:08 <tomberek> ?
23:06:12 <Cale> yeah
23:06:24 <Cale> {0,1,2} are the natural numbers less than 3
23:06:26 <monochrom> sinelaw may have just eaten all of the zeros of the zeta ζ function.
23:06:35 <tomberek> Cale: i was asking about the Bar (Foo a b)
23:06:37 <sinelaw> barf
23:06:52 <Cale> sinelaw certainly ate all the zeroes of the Riemann zeta function
23:07:08 <olsner> looks like he just un-ate them though
23:10:21 <Saizan> ?hoogle getEnv
23:10:22 <lambdabot> System.Environment getEnv :: String -> IO String
23:10:22 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
23:11:23 <Saizan> b52: getHomeDirectory
23:12:12 <tomberek> Cale: I have data Bar n a b = Bar (Foo a b), but the types aren't right for that
23:12:17 <Cale> It's known that all nontrivial zeroes have real part between 0 and 1
23:12:50 <Cale> tomberek: What's n meant to be? A phantom type parameter?
23:13:12 <tomberek> Cale: i'm trying to make the type Bar (Foo a b)  ...
23:13:17 <b52> Saizan: thanks
23:13:34 <Cale> tomberek: I'm not really sure what you mean.
23:14:10 <b52> can i convert an IO Path to string to use ++ "bla" on it?
23:14:23 <tomberek> Cale: or rather Bar Foo a b.... so for a monad.... a -> m a  ... i want Foo a b -> Bar Foo a b....
23:14:34 <ski> b52 : `myPath <- myIOPath'
23:14:51 <Cale> b52: You should run it to get the FilePath, and a FilePath is defined to be the same thing as a String anyway
23:15:24 <Cale> tomberek: What are you actually trying to do?
23:16:23 <copumpkin> sounds like he wants instance Monad Bar
23:16:25 <Cale> Note that with  data Bar n a b = Bar (Foo a b)  the Bar on the left hand side of the = (which is a type constructor) is in a separate namespace from the Bar on the right hand side (which is a data constructor)
23:16:26 <tomberek> i'm actually try to do a comonad,, but same idea, in reverse.  I want to go from m a -> a  and I want to end up with a=Foo b c
23:16:52 <copumpkin> tomberek: note that with monads and comonads you can say nothing about what goes "in" them
23:16:53 <tomberek> so I need a type of Bar Foo a b
23:17:06 <Cale> tomberek: When you define a monad or comonad, return/extract are required to be *totally* polymorphic in a
23:17:54 <tomberek> Cale: well, i can put restrictions on it using contraints
23:17:57 <Cale> When you define return :: a -> m a, you define it for some specific type m, but *any* type a at all.
23:18:10 <Cale> and you can't constrain it
23:18:24 <Cale> :t return
23:18:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:18:54 <tomberek> ok
23:19:58 <Cale> Since return is so polymorphic, it wouldn't do to define it just for some specific type a -- the polymorphism is a promise that return will act without inspecting its parameter (though it will generally use its parameter in building the value of type m a, it'll do it in a uniform way which is independent of its type or value)
23:21:50 <tomberek> Cale: ok,,, i'll rework that part then.... but let's say I really did want "Bar Foo a b"  how is that made from Foo a b?
23:22:22 <Cale> Similarly, if I have  length :: [a] -> Integer,  I'm guaranteed that even if I pass it a nonempty list of Integer values, it can't do something dumb like return the first Integer. It can only depend on the structure of the list and not the specific values.
23:22:23 <tomberek> Cale: at this point I'm just trying to get the hang of some more complicated types
23:22:43 <Cale> Bar Foo a b means that you're passing Bar the three parameters Foo, a and b
23:22:49 <tomberek> yes
23:23:12 <nus> :t Prelude.fmap
23:23:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:23:40 <Cale> data Bar f a b = B ((a -> b) -> f a -> f b)
23:24:07 <Cale> I could then do something like  B map :: Bar [] a b
23:26:50 <tomberek> Cale: roger
23:27:39 <tomberek> Cale: but f can't be a type synonym?
23:27:56 <Cale> Not in general, no.
23:27:59 <tomberek> ok
23:29:18 <Cale> It can depend on how the type synonym is written. Type synonyms are purely syntactic sugar, and don't really act as first class functions on types.
23:30:06 <nus> tomberek, if you're writing a (Haskell) interpreter, perhaps the GHC monad is what you're looking for.
23:35:44 <tomberek> Cale: type Foo a b = stuff   can't be turned into Bar Foo a b?
23:37:42 <nus> that depends on what Bar is.
23:39:50 <tomberek> nus: it's basically a list
23:40:10 <ski> tomberek : what is that `Bar' ?
23:40:17 <ski> a type (constructor) ?
23:40:20 <ski> a data constructor ?
23:40:34 <tomberek> type
23:41:05 <ski> ok. and you're sure you want `Bar Foo a b' and not `Bar (Foo a b)' ?
23:41:56 <sinelaw> oh god i look horrible
23:42:13 <sinelaw> but i managed to get my very limited subset of opencv bindings to work !
23:42:19 <tomberek> ski: I want to be able to have a comonad (with m a -> a) go from "Bar something" to "Foo a b"
23:42:30 <sinelaw> i guess everybody looks like this through a 6-iteration dilation filter
23:42:42 <tomberek> because by now I'm confusing myself
23:42:49 <theorbtwo> sinelaw: opencv = computer vision?
23:42:56 <chrisdone> sinelaw: very cool!
23:43:28 <sinelaw> yes
23:44:14 <nus> :t extend
23:44:15 <lambdabot> Not in scope: `extend'
23:44:23 <theorbtwo> Sounds pretty cool to me too.
23:45:15 <tomberek> :t extract
23:45:16 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
23:45:22 <tomberek> fail
23:45:45 <sinelaw> chrisdone, theorbtwo http://i.imgur.com/dyNvn.jpg
23:46:07 <sinelaw> live dilation filter running on my webcam input
23:46:16 <theorbtwo> Can't look at images easily from here, I'm afraid.
23:46:50 <nus> @hackage category-extras
23:46:50 <lambdabot> http://hackage.haskell.org/package/category-extras
23:47:00 <sinelaw> code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23015#a23015
23:47:31 <nus> tomberek, http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad.html
23:47:42 <tomberek> yeah... i got that
23:48:11 <ski> (tomberek : sorry, my X died for a little while)
23:48:46 <nus> tomberek, so your Bar is a monad, and Foo is a data constructor?
23:49:26 <nus> erhh, comonad
23:49:30 <ski>   extract :: Comonad w => w a -> a
23:49:32 <tomberek> yes... (i might want Foo to be a type synonym (constructor) ,, but i'll take whatever I can get)
23:49:43 <ski>   promote :: Comonad w => (w a -> b) -> (w a -> w b)
23:50:10 <tomberek> yep:  so I want to run extract, and end up with type:: Foo a b
23:50:16 <ski> when you say `go from "Bar something" to "Foo a b"', do you mean that you want to be able to use `extract' for the comonad in that way ?
23:50:31 <ski> i.e. you're wanting to use `extract' in one instance, with type
23:50:35 <chrisdone> sinelaw: bad ass ring, brother
23:50:44 <ski>   extract :: Bar (Foo n a b) -> Foo n a b
23:50:45 <ski> ?
23:50:47 <tomberek> ski, yes.  so if Bar is an instance of comonad,, wouldn't that mean the type of that is Bar Foo a b?
23:50:48 <chrisdone> sinelaw: can I see codes?
23:51:23 <tomberek> Bar (Foo a b) -> Foo a b
23:51:32 <ski> tomberek : in `w a -> a', if `w' is `Bar', and you uses it with `a' being `Foo a b', then it becomes `Bar (Foo a b) -> Foo a b'
23:53:00 <tomberek> ski... sounds good.  Now how can I construct Bar (Foo a b) ? syntax-wise.  data Bar....?
23:53:36 <jrockway> oh nice.  there is Network.URI and Network.URL
23:53:43 <jrockway> and HTTP uses a different one than http-server
23:54:04 <sinelaw> chrisdone, sure sec
23:55:08 <ski> tomberek : `data Bar a = ..a..' or `newtype Bar a = ..a..'
23:55:45 <tomberek> ok
23:55:58 <nus> tomberek, your Bar and Foo are two names for the same thing.
23:56:15 <ski> (obviously (or not), the data type `Bar' must be parameterized over `a', and work for any actual type (such as your `Foo a b' above, but also for other ones))
23:56:28 <ski> nus : i'm not sure of that
23:57:48 <sinelaw> chrisdone, http://github.com/sinelaw/HOpenCV
23:58:00 <sinelaw> for now, no cabal. but there's a makefile in there
23:58:10 <sinelaw> and i'm warning you, it's very limited
23:58:58 <sinelaw> is there something that can parse my .h file and create the bindings automagically?
23:59:04 <sinelaw> assuming no macro trickery
23:59:39 <chrisdone> awesome
23:59:42 <chrisdone> I'll try this out tonight
23:59:46 <tomberek> ski,nus: how about I post my issue: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23016#a23016
