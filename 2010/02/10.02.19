00:44:35 <Taejo> :t mapM
00:44:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:51:50 <mreh> I think I understand this FRP model now
00:52:35 <Gracenotes> then you be a better man than I
00:52:53 <mreh> each object you want to model is a signal function that encapsulates all the discreet things about itself, and then the framework handles the continuous notion of time
00:53:00 <mreh> by framework, I mean monad
00:53:10 <Gracenotes> the abstractions make some sense. Where the abstractions meet code that does stuff, blurry line that is.
00:53:27 <Gracenotes> and very dependent on the implementation means
00:54:10 <mreh> I think that comes with practice, like most things in this discipline
00:54:15 <mreh> I hope!
00:54:31 <mreh> XD
00:54:36 <Gracenotes> D:
00:55:23 <mreh> it's no good starting off in the deepend like the Arrows and Robots paper does
00:56:56 <mreh> It's hard to imagine that fp could do anything useful when you first start, I think you just need to suspend your disbelief for a little bit longer
00:59:56 <mreh> and now... Haskelloids!
01:01:38 * mjrosenb has never done reactive programming, so i doubt that i would be able to grok frp
01:02:54 <mreh> mjrosenb: it's not much harder than groking the State monad
01:03:16 <mjrosenb> mreh: good to know
01:03:23 <mjrosenb> which reminds me
01:03:38 <mjrosenb> what is the difference between State and ST
01:03:41 <mreh> the abstraction takes care of all the donkey work, so your brane can get on with the important stuff
01:03:52 <mjrosenb> is it just that ST can magically use IO rather than passing the state around?
01:04:10 <mreh> that is a question the answer to which I don't know
01:04:16 <mreh> why do you need to use ST?
01:04:17 <Gracenotes> it is used for mutability without IO
01:04:42 <Gracenotes> with type system evilness to make sure things stay transparent
01:04:42 <int-e> I'd actually say that State and ST have nothing to do with each other.
01:04:48 <mjrosenb> Gracenotes: that sounds like it describes both ST and State.
01:05:09 <int-e> ST is a tamed version of IO. It's just as opaque to the Haskell programmer as IO is.
01:05:13 <Gracenotes> oh, State is entirely immutable.
01:05:58 <MaciejP> Hi! I just updated to cabal-install-0.8.0/Cabal-1.8.0.2. When I do cabal update it says "cabal: Codec.Compression.Zlib: premature end of compressed stream".
01:06:05 <Gracenotes> I don't use it so much for simulating mutability as for keeping track of an extra parameter in a recursive function
01:06:06 <int-e> State on the other hand is an honest pure function from a previous state to a new state and a value.
01:06:14 <MaciejP> Is there a way to fix this without building from the latest darcs repo?
01:06:46 <int-e> Gracenotes: you should use the Reader monad (or applicative) then, probably
01:07:21 <Gracenotes> int-e: well, possibly changing the parameter is also needed. not the main idea though.
01:07:38 <mjrosenb> yeah, i have determined that a bunch of my uses of State could be Reader instead
01:08:01 <int-e> Gracenotes: because that's what it does - pass along an extra immutable value to operations. and there's 'local' to modify the parameter for a single recursive call.
01:08:01 <Gracenotes> local is useful
01:08:25 <Gracenotes> int-e: operative word being "single"
01:08:34 <int-e> right
01:09:57 <Gracenotes> example: building and using symbol table while going through a list
01:10:01 <int-e> although 'single' is somewhat misleading, 'local' is quite descriptive for what it does ... it's local in that it only affects the current function, never its caller.
01:10:46 <int-e> Gracenotes: right, that would be stateful, unless you work with some sort of splittable supply of identifiers.
01:11:15 <int-e> or would it?
01:11:21 <int-e> it depends.
01:13:40 <Taejo> @src maximum
01:13:40 <lambdabot> maximum [] = undefined
01:13:40 <lambdabot> maximum xs = foldl1 max xs
01:13:46 <Taejo> @src max
01:13:47 <lambdabot> max x y = if x <= y then y else x
01:26:33 <tensorpudding> @src all
01:26:33 <lambdabot> all p =  and . map p
01:26:51 <tensorpudding> @src and
01:26:51 <lambdabot> and   =  foldr (&&) True
01:28:52 <tensorpudding> @src sequence
01:28:52 <lambdabot> sequence []     = return []
01:28:52 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
01:28:52 <lambdabot> --OR
01:28:52 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
01:32:28 <tensorpudding> @hoogle (a -> b) -> a -> m b
01:32:28 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
01:32:28 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
01:32:28 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
01:32:49 <tensorpudding> @hoogle (a -> b -> c) -> a -> m b -> m c
01:32:50 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:32:50 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:32:50 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
01:36:04 <plmday> hi
01:37:43 <plmday> I just found in hackage that parsec now has to module paths, one Text.Parsec, the other (the original) Text.Combinators.Parsec, which one should I import to use, any differences between the two? thanks
01:38:33 <voker57> one of them is legacy
01:39:07 <jencek> hey there, anybody has experiences using qthaskell?
01:40:25 <plmday> voker57: thanks, so I guess it's the longer one, right? :)
01:40:36 <voker57> i'd like to know that myself
01:44:23 <freiksenet> hello! How do one usually replace a character in a bytestring (string) in Haskell? I mean I want to get a copy of a bytestring with one character replaced with another, do I need to split at that character to do that?
01:45:03 <tensorpudding> if i fold using (liftM2 (&&)), will it force the evaluation of every term after i have reached a false value in the monad?
01:46:38 <blackh> freiksenet: Yes - split it up, then concatenate it back together with the replaced character.
01:46:52 <freiksenet> blackh: ok, thanks :)
01:47:32 <plmday> voker57: I found the type synonym Parser is gone in Text.Parsec, and I also found doc on Parsec in GHC doc tree is missing
01:48:17 <plmday> not sure if this could be evidence that the Text.ParserCombinators.Parsec is legacy
01:55:54 <mm_freak> plmday: Text.ParserCombinators.Parsec is from parsec 2
01:55:56 <galdor> plmday: while it's possible it's legacy, what would be the new shiny parser combinator library ?
01:56:14 <mm_freak> Text.Parsec is from parsec 3, which is anything but legacy
01:57:23 <mm_freak> tensorpudding: just try it out
01:57:26 <galdor> nice to know, thank you
01:57:32 <mm_freak> > liftM2 (&&) (return False) (return undefined)
01:57:33 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
01:57:33 <lambdabot>    arising from a use of ...
01:57:37 <mm_freak> > liftM2 (&&) (return False) (return undefined) :: Maybe Bool
01:57:38 <lambdabot>   Just False
01:57:44 <mm_freak> > liftM2 (&&) (return False) (return undefined) :: IO Bool
01:57:46 <lambdabot>   <IO Bool>
01:57:55 <mm_freak> well, it gives False in GHCi
01:58:41 <mm_freak> interestingly liftM2 seems to be strict on the second argument
01:58:46 <plmday> galdor: at the moment, what I found is the synonym Parser is missing, I will try to find if there's any shiny stuff later
01:58:51 <mm_freak> > liftM2 (&&) (return False) undefined :: Maybe Bool
01:58:52 <lambdabot>   * Exception: Prelude.undefined
01:58:57 <ManateeLazyCat> modifyMVar_ will change MVar value and don't care MVar empty or full?
01:59:29 <plmday> mm_freak: thanks for the clarification, so I guess since it's in the transition stage, so its doc is missing in ghc doc
02:00:01 <mm_freak> plmday: what would the parsec docs do in the GHC docs?
02:00:17 <mm_freak> parsec is a package and you need to install it separately these days
02:00:31 <mm_freak> you find its documentation on hackage
02:01:14 <eflister> hey -- i have a function f :: (MonadSupply Int m, Integral a) => a -> m [Thing], and i'd like to make a list [f], but ghc says "No instance for (MonadSupply Int m)"
02:01:26 <mm_freak> ManateeLazyCat: if the MVar is empty, then modifyMVar_ blocks
02:01:43 <plmday> mm_freak: ah, that's it, thanks, I used to check its doc in ghc doc, now I will go for hackage
02:02:15 <ManateeLazyCat> mm_freak: I saw modifyMVar_ source code, and found it use takeMVar, so looks, modifyMVar_ just works when MVar is full.
02:02:48 <quicksilver> @hoogle modifyMVar_
02:02:49 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
02:03:01 <quicksilver> ManateeLazyCat: if it were empty, where would that initial "a" in (a -> IO a) come from?
02:03:05 <quicksilver> ;)
02:03:52 <mm_freak> ManateeLazyCat: i don't think it uses takeMVar internally, because it guarantees that the computation 'a -> IO a' is carried out atomically
02:04:05 <eflister> i slightly modified MonadSupply from the wiki and rwh -- what is it saying needs to be an instance of what class?  i'm surprised to find that i can't always make a list out of anything...
02:04:30 <mm_freak> hmm, actually it could use takeMVar
02:05:21 <quicksilver> mm_freak: it's not atomic, just exception safe
02:05:26 <quicksilver> (the docs don't claim it's atomic, either)
02:05:30 <mm_freak> yeah, indeed
02:05:40 <quicksilver> it's only safe if your code doesn't do any unmatched 'puts'
02:05:42 <mm_freak> on the other hand, it blocks
02:05:54 <ManateeLazyCat> Infact, modifyMVar_ not atomic action.
02:06:06 <quicksilver> using MVars typically requires a discipline
02:06:11 <quicksilver> (there is more than one to choose from)
02:06:24 <ManateeLazyCat> So my question, how to replace modifyIORef? I want transform IORef code to MVar version.
02:06:28 <quicksilver> one possible discipline is 'mvar is always pull, all takes matched by puts, no unmatched puts'
02:06:30 <mm_freak> but actually it only blocks the taking and putting back
02:06:41 <quicksilver> s/pull/full/
02:06:55 <mm_freak> ManateeLazyCat: maybe you should rethink your design
02:07:05 <mm_freak> MVars are used for communication between threads
02:07:13 <quicksilver> ManateeLazyCat: modifyMVar_ is probably the right way. It's observationally atomic as long as you don't have unmatched puts
02:07:36 <ManateeLazyCat> mm_freak: Yep, i have re-design my project from single-process to multi-threads/multi-processes.
02:07:49 <ManateeLazyCat> mm_freak: So i was think about remove IORef code.
02:09:03 <mm_freak> what were you using the IORef for?
02:09:10 <ManateeLazyCat> quicksilver: So modifyMVar_ still will block current thread if MVar value is empty? Until some thread put new value again?
02:09:43 <mm_freak> yes
02:09:57 <mm_freak> takeMVar implies that =)
02:10:01 <ManateeLazyCat> mm_freak: Well, my project just use single-thread/single-process, IORef for some update status, such as PageList, WindowList.
02:10:32 <mm_freak> ManateeLazyCat: with rethinking your design i mean:  do you need variables at all?  maybe StateT is what you're looking for
02:10:49 <ManateeLazyCat> mm_freak: Now, perhaps will have many thread update those status in same time. So i want replace IORef with MVar for safely refactory.
02:10:53 <mm_freak> or alternatively you want a manager thread, which you can communicate to using an MVar
02:11:19 <mm_freak> no, you don't want to replace IORef by MVar…  you want a thread, which manages your state
02:11:41 <eflister> hey can anyone help me out?  i have a paste ready, but hpaste.org is down...
02:11:47 <ManateeLazyCat> mm_freak: Yep, i know some Monad will easily, but my project use many gtk2hs code (FFI), and some C event function must use IO Monad.
02:12:03 <mm_freak> nothing wrong with that =)
02:12:11 <eflister> @paste
02:12:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:12:11 <mm_freak> eflister: codepad.org
02:12:13 <ManateeLazyCat> mm_freak: If you add StateT or other monad, C event function won't pass.
02:12:36 <mm_freak> ManateeLazyCat: i don't know what you mean
02:12:45 <mm_freak> StateT MyState IO ResultType
02:13:06 <mm_freak> that gives you State on top of IO
02:14:23 <ManateeLazyCat> mm_freak: So if you use StateT, in your function signature, you need add StateT, write?
02:14:42 <eflister> mm_freak: thx -- could you take a quick look?  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7732
02:15:10 <ManateeLazyCat> mm_freak: Such as, "foo :: StateT -> IO bar"
02:15:57 <mm_freak> eflister: the fundep doesn't make sense to me
02:16:28 <mm_freak> ManateeLazyCat: you should read a tutorial about monad transformers
02:16:54 <eflister> mm_freak: it's been a long time since i wrote it and i don't have much of a handle on fundep, but it works in all respects except this one (and is mostly copied from the wiki/rwh anyway :)
02:17:09 <mm_freak> ManateeLazyCat: but anyway, if you're updating state from multiple threads, you will want to use StateT and a management thread
02:17:23 <eflister> mm_freak: i think the error isn't because of MonadSupply -- what in general would cause you to not be able to make a list of some type?
02:17:32 <ManateeLazyCat> mm_freak: Some gtk2hs functions, such as onKeyPress, just accept "Event -> IO Bool", you can't add any monad wrapper in it. You can't write "Event -> MonadWrapper -> IO Bool".
02:18:09 <mm_freak> ManateeLazyCat: that's why you need a tutorial about monad transformers =)
02:18:38 <mm_freak> ManateeLazyCat: http://codepad.org/qRHwLu10
02:18:45 <mm_freak> an old paste with an example chat server
02:19:57 <mm_freak> eflister: your code seems overly complex to me
02:21:24 <eflister> mm_freak: hm, ok :)  in what respect?  it's really just slightly modified from those sources (http://www.haskell.org/haskellwiki/New_monads/MonadSupply, and rwh adds the implementation hiding, deriving from Identity, etc)
02:21:28 <ManateeLazyCat> mm_freak: You mean: i don't need replace IORef by MVar, just keep *one* manager-thread update status, other threads just send *update request* to manager-thread?
02:22:37 <mm_freak> eflister: in the respect that RWH isn't overusing abstractions =)
02:23:46 <eflister> mm_freak: specific suggestions would help?  but like i said, what i really want to understand is how it could be that i can't make a list out of any type.
02:23:48 <mm_freak> ManateeLazyCat: yes, you get rid of the IORef completely and replace it by a StateT
02:24:12 <mm_freak> ManateeLazyCat: the manager thread runs 'forever' in the StateT, taking requests and returning/updating the state as appropriate
02:24:32 <mm_freak> eflister: you can
02:24:49 <ManateeLazyCat> mm_freak: So StateT is status update channel.
02:25:05 <ManateeLazyCat> ?
02:25:10 <ManateeLazyCat> mm_freak: I was build some DBus/Haskell framework.
02:25:29 <eflister> mm_freak: except [f] gives an error, both in ghci and if compiling...
02:25:44 <mm_freak> ManateeLazyCat: if you don't understand StateT, you should experiment with State first
02:25:54 <ManateeLazyCat> mm_freak: Thanks for your suggestion, i will read it.
02:25:55 <mm_freak> it's a monad encoding implicit state
02:25:56 <ManateeLazyCat> :)
02:27:30 <eflister> mm_freak: is this the transformer tutorial you mean?  http://www.haskell.org/all_about_monads/html/transformers.html
02:27:58 <Ian_Corne> lambdabot: help
02:28:30 * ManateeLazyCat MVar just like mutex to block thread to protected status, but this model is difficult to debug when multi-thread blocking....
02:28:30 <mm_freak> eflister: i didn't mean any specific transformer tutorial
02:29:00 <mm_freak> ManateeLazyCat: MVars are for safe inter-thread communication
02:29:08 <mm_freak> you _can_ use them for locking, though
02:29:40 <mm_freak> do sendQuit (putMVar waiterVar ()); () <- takeMVar waiterVar
02:29:45 <c_wraith> locking is a form of interthread communication
02:29:57 <mm_freak> c_wraith: then let me call it messaging =)
02:30:18 <eflister> mm_freak: how should i interpret "no instance for (MonadSupply Int m)?  why does putting f in a list require that f be in some class?  and what class?
02:30:18 <ManateeLazyCat> mm_freak: I use DBus for multi-process communication, and want refactory my program for multi-thread communication.
02:30:38 <ManateeLazyCat> mm_freak: I need compare exist solution and find easiest one. :)
02:32:09 <mm_freak> eflister: i haven't run your code, but one thing is that you can't have MonadSupply Int m without (Monad m, Functor m)
02:32:20 <c_wraith> locking is like every thread yelling "I got it!".  deadlocks are like when all the threads bonk their heads trying to get the same things at once. :)
02:33:08 <int-e> thread 1: I got A, want B! thread 2: I got B, want A! ... like two goats on a narrow bridge :)
02:33:12 <mm_freak> ManateeLazyCat: then concurrency is what you want, unless you have specific reason to run multiple _processes_ =)
02:33:49 <int-e> (in fact if you divde the bridge into two halves labeled A and B, that image becomes a perfect analogy)
02:33:57 <ManateeLazyCat> mm_freak: Multiple-Process design through DBus is for protected uncatch exception crash program.
02:34:01 <mm_freak> there is an even simpler interlocking scenario
02:34:07 <mm_freak> newEmptyMVar >>= takeMVar
02:34:08 <mm_freak> =)
02:34:46 <int-e> right. "Got A, want another A!"
02:34:52 <ManateeLazyCat> mm_freak: Multi-Threads for multiple-process framework, example, main thread handle Graphics render, other threads handle DBus message or other working.
02:35:01 <mm_freak> int-e: rather like:  want A, but there is no A =)
02:35:28 <int-e> mm_freak: that depends on how exactly you model newEmptyMVar.
02:35:42 <mm_freak> ManateeLazyCat: crash resistance should be handled by separate applications
02:35:52 <mm_freak> for example there is svscan for that
02:36:20 <mm_freak> one thread handling graphics is fine, because at least gtk2hs relies on that
02:36:47 <mm_freak> other than that i'd have a thread for every tiny task =)
02:37:04 <mm_freak> int-e: well, as its name states, and _empty_ MVar ;)
02:37:21 <mm_freak> thread waits for it to become full, but it never gets full =)
02:37:25 <ManateeLazyCat> mm_freak: I was build Haskell/Gtk+ platform, i keep Core is enough simple and bug free, then make any other application running in separate process, all process communication with DBus, if any uncatch exception or error, just crash application, won't crash other module.
02:37:41 <eflister> mm_freak: the code runs fine -- "f" is defined in my real code, this is just extracted.  it only breaks if i try to put f in a list.  the functor idea sounds like the right track, but Supply s is a MonadSupply s, and so is SupplyT s.  and both are Functors, as far as i understand what's going on...
02:37:42 <quicksilver> ManateeLazyCat: I think mm_freak has already guided you down a better path, listen to him.
02:37:55 <quicksilver> ManateeLazyCat: BUT, just to finish the discussion : make sure the MVar is never empty.
02:38:13 <quicksilver> ManateeLazyCat: (if your'e converting IORef code; IORefs can never be empty so the most natural model is as an MVar which is never empty)
02:39:09 <mm_freak> eflister: i don't see anything wrong with putting f into a list
02:39:18 <int-e> mm_freak: well, you can also model newEmptyMVar as handing the calling thread a token along with the empty slot to put it.
02:39:57 <int-e> It doesn't matter really. In the end it depends on how you're going to use the MVar.
02:40:34 <eflister> mm_freak: me either!  :)  the error is "no instance for MonadSupply Int m" .  anyone else have ideas?  if you try running it you should see the error...
02:41:20 <mm_freak> int-e: that token is what is put in the slot, but in my case, no token is ever put, so you can say that there is no token at all (or a thousand or infinitely many, if you insist)
02:41:34 <mm_freak> your model may be overcomplicating things =)
02:42:01 <mm_freak> eflister: can you _define_ f without error?
02:42:02 <ManateeLazyCat> Thanks all for help, i read StateT resources now...
02:42:13 <eflister> mm_freak: yep, no problem
02:42:36 <eflister> mm_freak: the real definition is big and application specific -- but works fine.  i omitted it cuz the error is the same without it.
02:43:20 <int-e> mm_freak: It's modeling MVars-as-Mutexes, with an empty MVar representing a locked mutex, and the token belonging to the thread who holds the lock.
02:43:33 <mm_freak> eflister: try leaving the fundep out
02:43:41 <mm_freak> (i don't know why you put it anyway)
02:43:57 <mm_freak> although RWH puts it, too
02:44:47 <mm_freak> int-e: that doesn't work too well, because it doesn't capture the fact that an MVar could hold different values
02:45:57 <eflister> mm_freak: huh, same error.  i thought i needed it to compile -- like i said, i never had a great handle on what i was doing.  i think it came from a version before i was deriving from identity?
02:46:07 <int-e> mm_freak: I know, Mutexes are just the simplest use of MVars.
02:46:44 <mm_freak> int-e: then you're modelling MVar (), not MVar a =)
02:47:55 <mm_freak> eflister: currently i got some other things to do, so i can't look closer
02:48:01 <mm_freak> but i'm very sure the error comes from elsewhere
02:48:33 <eflister> mm_freak: ok, thx for your help!
02:49:01 <eflister>   can anyone take a look, or help me understand why putting a function in a list could have an error like "no instance for ..."?
02:49:02 <int-e> mm_freak: In general there may be several tokens, and tokens can be labeled. threads can introduce new tokens, erase tokens ... and it's all a big mess ;)
02:50:31 <mreh> @pl (\f g h x -> f x `h` g x)
02:50:32 <lambdabot> flip . (ap .) . flip (.)
02:50:58 <mreh> @pl (\g h x -> f x `h` g x)
02:50:58 <lambdabot> flip (ap . (. f))
02:51:13 <mm_freak> int-e: i think the following model is much simpler:  an mvar is just a box put in the middle of the room, which can only contain one value at a time =)
02:51:39 <mreh> :t ap
02:51:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:51:55 <int-e> mm_freak: in fact I had not even modelled MVar (); I had modeled mutexes as they are supposed to be used for mutual exclusion, where unlocking an unlocked mutex is an error.
02:53:51 <mreh> :t ap (.)
02:53:52 <int-e> mm_freak: And I guess that's the point - the model was supposed to capture the intended use of use of the MVar, not its capabilities in all glory.
02:53:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> f a) -> (a -> b) -> f b
02:54:19 <mm_freak> is that the intended use of MVars?
02:54:20 <mreh> weee
02:54:29 <int-e> mm_freak: not /the/, /a/.
02:54:59 <mm_freak> anyway, i think Control.Concurrent needs a specific locking construct anyway =)
02:55:05 <mm_freak> using MVars is fine, but a bit ugly
03:02:19 <mm_freak> something like this:
03:02:27 <mm_freak> askThread f = do v <- newEmptyMVar; f (putMVar v); takeMVar v
03:02:50 <mm_freak> waitThread f = do v <- newEmptyMVar; f (putMVar v ()); takeMVar v
03:14:34 <eflister> anyone able to help with this?  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7738  i've simplified it down -- i have a function f that i can define and works just fine, but i can't put it in a list or even assign it to a variable -- i get the error "No instance for (MonadSupply Int m)
03:16:37 <fasta> Did anyone ever suggest making every value a monadic value by default and only adding a runIdentity implicitly if there is no other run<mymonad> at the top of the expression?
03:17:23 * hackagebot upload: hsx 0.6.2 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code. (NiklasBroberg)
03:17:35 <fasta> While non-monadic code looks quite neatly, it is often the case that for some reason you have to convert it to a monadic version for a variety of reasons.
03:19:24 * hackagebot upload: HJavaScript 0.4.6 - HJavaScript is an abstract syntax for a typed subset of JavaScript. (NiklasBroberg)
03:19:26 * hackagebot upload: HJScript 0.4.8 - HJScript is a Haskell EDSL for writing JavaScript programs. (NiklasBroberg)
03:34:39 <mm_freak> fasta: i think there is nothing wrong with that
03:34:45 <mm_freak> 90% of my code is monadic
03:35:04 <mm_freak> 60%-70% of it being IO
03:37:03 <mm_freak> somehow people come to think that using monads is a bad thing, but IMO the opposite is true =)
03:38:02 <fasta> mm_freak, monadic code is more flexible, but it is harder to read.
03:38:09 <freiksenet> mm, how can I convert from type Int to Float? fromInteger looks like it should work, but it couldnt match for some reason.
03:38:42 <Dementati> freiksenet: fromInteger seems to expect an Integer, not an Int.
03:38:43 <mm_freak> fasta: it's not more flexible
03:38:52 <RayNbow> :t fromIntegral
03:38:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
03:38:59 <freiksenet> ok
03:39:01 <freiksenet> thanks
03:39:12 <freiksenet> that works :)
03:39:15 <mm_freak> fasta: monads are just types with a Monad instance after all
03:39:28 <mm_freak> they are a certain way to express certain computations
03:39:51 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
03:39:52 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:40:29 <mm_freak> if a monad seems to encode your computation well, use it =)
03:40:47 <mm_freak> for me, i find a suitable for monad for almost all of the computations i do
03:40:57 <mm_freak> -for
03:41:25 <idnar> I'd rather use functors or applicative functors if I can
03:41:38 <fasta> mm_freak, the problem being for example that you have an algorithm which computes a certain object, now you decide to add some visualization to it, but you don't want to change any line of the algorithm.
03:42:17 <mm_freak> idnar: me too, but i didn't want to confuse fasta =)
03:42:36 <mm_freak> fasta: remember you've got laziness
03:42:47 <idnar> hmm, re: more flexible, I guess it depends on what you mean by "monadic code"
03:42:48 <ManateeLazyCat> Functors is handy.
03:43:00 <mm_freak> usually you'll change little to add progress bars or visualization
03:43:29 <idnar> a function (Monad m) => m Foo -> m Bar is "more flexible" than a function [Foo] -> [Bar]
03:43:40 <mm_freak> idnar: IMO code becomes "monadic", as soon as a monad is used to encode the particular algorithm
03:44:19 <mm_freak> of course most parts of it are non-monadic in that their type doesn't use monads
03:44:26 <idnar> as far as using a /particular/ monad goes, sure, there's no difference
03:45:24 <mm_freak> fasta: to give you an example, you can encode an algorithm as an infinite list
03:45:36 * idnar sighs at Haskell trolling on stackoverflow
03:45:48 <mm_freak> like calculating a square root, which starts with a very rough approximation and approaches the actual square root with each iteration
03:46:26 <mm_freak> then you can have a pure sqrt function, which just (head . dropWhile)s that list
03:46:45 <fasta> mm_freak, yes, but it is not that easy when you have a mutable algorithm.
03:46:56 <mm_freak> in parallel you can have an sqrtWithProgress, which displays a progress bar along the way
03:47:12 <mm_freak> lists encode "change" very will =)
03:47:13 <fasta> mm_freak, yes, for functional code those things can work.
03:47:19 <mm_freak> well
03:47:52 <mm_freak> each list element is the state of an object after a single iteration of the algorithm
03:47:52 <fasta> mm_freak, for mutable code, you can do the same thing, I suppose, by converting the mutable code to functional copies.
03:48:02 <fasta> Er mutable data structures.
03:48:20 <mm_freak> there are no mutable data structures in pure world
03:48:30 <fasta> mm_freak, STRefs
03:49:22 <mm_freak> if you need STRefs, that's a somewhat clear indication that your implementation is flawed anyway =)
03:49:34 <mm_freak> try using State monads instead
03:49:38 <fasta> mm_freak, ...
03:50:29 <fasta> mm_freak, you are suggesting that lazy functional programming is equal to a RAM.
03:50:48 <mm_freak> i'm suggesting that you shouldn't try to write C in haskell
03:50:50 <fasta> mm_freak, all practical evidence suggests this is not the case.
03:51:11 <fasta> mm_freak, according to some people they find it easier to write C in Haskell than to write C.
03:51:19 <mm_freak> of course
03:51:31 <mm_freak> but in general there is a better solution, which doesn't require writing C in haskell
03:52:02 <fasta> mm_freak, if general=often, then yes, otherwise no.
03:52:14 <mm_freak> can you name an example?
03:53:01 <fasta> mm_freak, consider the dynamic path data structure.
03:53:20 <fasta> mm_freak, one of the most advanced data structures that I know of.
03:53:57 <mm_freak> my search engine doesn't give useful results
03:54:02 <fasta> mm_freak, it is like a Data.Sequence.Seq, but with a lot more operations.
03:54:14 <mm_freak> so you're implementing a data structure?
03:54:48 <fasta> mm_freak, http://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf
03:55:00 <fasta> mm_freak, no, I already implemented that one years ago.
03:55:36 <fasta> mm_freak, you can get quite far with zippers, but in some algorithms it seems to be completely impossible to go functional all the way.
03:55:54 <fasta> mm_freak, if you do not count DiffArrays as being functional.
03:56:22 <mm_freak> well yeah, there are some algorithms, which are difficult to write in a functional style
03:57:01 <fasta> mm_freak, my strong belief is that it is _impossible_ to write them in a functional style.
03:57:50 <mm_freak> that depends on when code can be considered to be in "functional style" =)
03:57:55 <mm_freak> i think there is no clear distinction
03:58:18 <fasta> mm_freak, basically whether you have an operation to read or write some index in constant time.
03:59:02 <fasta> mm_freak, if you have that, you can do everything, but without it some things are simply impossible (like emulating a machine with a language with operations that do assume these operations).
03:59:27 <mm_freak> Array has such operations and using it is still perfectly functional =)
04:00:37 <mm_freak> you probably mean explicit mutability
04:00:41 <fasta> mm_freak, no, it has not.
04:00:49 <fasta> mm_freak, you cannot write an array in constant time.
04:01:09 <fasta> mm_freak, only DiffArrays can do that, as I already explained before.
04:02:00 <mm_freak> well, have a look at stuff like uvector/vector
04:02:36 <mm_freak> the base library isn't pretty good at fast array operations
04:04:01 <Cale> Accessing an arbitrary amount of memory in constant time is a bit of a lie regardless.
04:04:46 <Cale> It only makes sense that memory access is constant time if you put some bound on the amount of memory, and if you do that then the asymptotics go out the window anyway.
04:05:03 <fasta> Cale, yes, but it is an extra log n factor.
04:05:16 <mm_freak> well, usually there is some sense of a "smallest operation"
04:05:29 <mm_freak> in the case of Array, it's reading an element
04:05:35 <Cale> log n is even being generous for physically implementable systems :)
04:06:11 <fasta> Cale, yes, but since n is usually below the size of your machine it is useful reasoning.
04:06:28 <Cale> As your memory grows, so do the pointers to it, and they grow at log n.
04:06:53 <bastl> yesterday I asked about the category "Hask". How do Typclasses fit into that picture? Is there an analogon in category theory ?
04:07:13 <Cale> Yeah, usually you know that n is small because memory is finite, and so you can treat the log n as being part of the constant.
04:07:28 <Cale> bastl: Not directly, no.
04:07:43 <Egbert9e9> guys, i have a question regarding problem 7 in haskell.org/haskellwiki/99_questions
04:08:04 <bastl> I read in a german book on functional programming about "typeclasses as categories" which confuses me .
04:08:28 <Cale> bastl: hmm...
04:08:58 <Cale> bastl: Yeah, confuses me a bit too, though typeclasses are predicates on types, so there would be an induced subcategory.
04:09:03 <bastl> As an intro to monads: 11.1.1 in http://www.springerlink.com/content/x7l11502v4wh7688/fulltext.pdf
04:09:11 <Cale> bastl: I'm not sure if that's what they mean
04:09:16 <Egbert9e9> it talks about a function which takes a list that holds lists, but in haskell a list can have items only of a certain type
04:09:35 <mm_freak> Egbert9e9: that certain type would be a list of objects of another certain type =)
04:09:44 <mjrosenb> hey, is there something like a state monad in order to get random numbers?
04:09:47 <mm_freak> > [[1,2,3], [4,5,6], [7,8,9]]
04:09:48 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
04:09:56 <mm_freak> mjrosenb: yes, there is the MonadRandom package
04:10:13 <bastl> Cale: Ah, that matches my intution: Eq induces a subcategory of Hask whose types have a equality function ?
04:10:27 <Cale> bastl: yeah
04:10:34 <mjrosenb> mm_freak: does it ship with the standard basis?
04:10:52 <mm_freak> mjrosenb: no, you need to install it separately
04:10:53 <Cale> mjrosenb: Nah, it's on Hackage though
04:11:01 <Cale> cabal install MonadRandom
04:11:03 <mm_freak> use cabal =)
04:11:18 <Cale> It's just a thin wrapper around State StdGen
04:11:55 <mm_freak> in fact i'd just use State/StateT or an infinite list of random values
04:12:48 <bastl> Cale: Hmmm, how do I explain the signature of eq :: a -> a -> Bool, when I think only in Hask? "a" is not in Hask. Signatures are not in Hask ... !?
04:13:00 <mm_freak> not that there is anything wrong with MonadRandom, but it is an additional dependency, and also most good random number libraries don't use the RandomGen interface anyway
04:13:36 <bastl> (background: I want to explain some haskell things to my supervisor who knows more about categories than about haskell, for me it's the other way around ...)
04:14:12 <Cale> bastl: Well, normally, parametrically polymorphic functions correspond to natural transformations
04:14:26 <Cale> However, there aren't many functions which are really of type a -> a -> Bool
04:14:54 <Cale> (just the constant ones)
04:14:55 <bastl> ah. I read that in B.Pierces Introduction to CT
04:14:57 <Egbert9e9> mm_freak: their example is flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]])
04:15:34 <zygoloid> Cale: (9 distinct functions once you include 'seq') :)
04:15:37 <bastl> have to think about that...
04:16:04 <Cale> Egbert9e9: Ah, the List thing (really trees) is to simulate lisp's lists
04:16:24 <Egbert9e9> it doesn't work in ghc
04:16:38 <Cale> oh?
04:17:14 <Cale> Works for me.
04:17:28 <Cale> Did you put the solution in a file and load it with ghci?
04:17:38 <mjrosenb> @pl \x -> f x >>= g
04:17:38 <lambdabot> (g =<<) . f
04:18:21 <Egbert9e9> i don't want to read the solution before i write one
04:18:22 <Cale> f >=> g
04:18:34 <Cale> (or  g <=< f)
04:18:55 <Cale> Egbert9e9: Yeah, their solution is to define a custom datatype
04:20:19 <Egbert9e9> oh, I haven't got to it yet in learn you a haskell
04:20:41 <Egbert9e9> still in Higher Order Functions
04:21:36 <bastl> Cale: You said parametric polymorphic functions correspond to nat. transformations. Ok, but I want to explain type-classes. That's ad-hoc polymorphism / overloading. Does that match to natural transformations too? I believe there is missing something to explain typeclasses in Hask.
04:21:50 <Cale> bastl: Not really.
04:21:58 <Egbert9e9> thanks for your help!
04:22:10 <Cale> Typeclasses don't really naturally correspond to anything well-known in category theory.
04:23:28 <Cale> bastl: It's possible to treat typeclass constraints as simply being additional function parameters.
04:23:41 <quicksilver> speaking fairly naively, typeclasses of kind * are structures on (some set) of objects of Hask.
04:24:24 <quicksilver> For example 'Monoid' identifies a set of objects of Hask for which we have an arrow (() -> O) called mempty and an arrow (O x O -> O) called mappend
04:25:06 <quicksilver> but the concept 'typeclass' doesn't correspond to an elementary cat theory concept.
04:26:02 <sinelaw> cat theory: http://a6.vox.com/6a00fad69128e900040110166ea1ae860d-500pi
04:27:53 <mreh> are identity lists O(n) access complexity?
04:28:25 <Cale> "identity lists"?
04:28:39 <Stalafin> in ghci, how would i declare a data type? i thought something like 'let data Foo = bas | bar' would work
04:28:47 <mreh> uhh, I'm not sure what they're called in haskell
04:28:52 <Cale> Stalafin: Put the definition in a file and load it
04:29:09 <Cale> Stalafin: Also, be sure that your data constructors start with an uppercase letter
04:29:19 <bastl> Cale, Quicksilver: thanks.
04:29:27 <mreh> Cale: I need to find a time efficient implementation, Its a kind of map... Map is O(log n) access isnt it?
04:30:03 <idnar> maybe if you describe what an identity list is...
04:30:22 <Cale> mreh: Yes, which is theoretically the best you can do for such a thing.
04:30:26 <mjrosenb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22032#a22032
04:30:28 <mjrosenb> whoops
04:33:17 <Cale> mreh: I highly recommend Data.Map as a sane default
04:33:22 <ketil> Anybody use cmdArgs?  And know what it means when the executable complains "Can't handle a type of XXX"?
04:33:42 <ketil> I'm trying to use a custom type, and derived Typeable, Data, and KitchenSink, but to no avail.
04:36:53 <Cale>         case toFlagType $ typeOf i of
04:36:53 <Cale>             _ | [FldEnum xs] <- info -> return [x{flagName=n} | x <- xs]
04:36:53 <Cale>             Nothing -> error $ "Can't handle a type of " ++ show (typeOf i)
04:36:53 <Cale>             Just x -> return [flagInfo flagDefault{flagName=n,flagKey=n,flagVal=toDyn i,flagType=x} info]
04:38:18 <Cale> i is a lambda-bound variable, in a function which is the parameter to gmapQ
04:38:49 <Cale> this is in the function 'mode' in System.Console.CmdArgs.UI
04:39:55 <ketil> Yes, I got that far - I just don't understand what it is doing, and how it is doing it.  I can dig some more, but I was hoping somebody would jump out with 'Oh you just need to derive Data.Zfu' :-)
04:40:59 <Stalafin> if i wanted to create an object (a lattice node), which is just a combination of three primitive vectors, how would i do that? node = (m*a1, n*a2, o*a3) << this is essentially a node ,with a1,a2,a3 predefined, and m,n,o integers
04:42:27 <Cale> Stalafin: Not sure that I understand that question... does a triple not work?
04:42:51 <Stalafin> Cale: you mean a triple of tuples?
04:42:57 <Stalafin> pairs*
04:43:04 <ketil> @hoogle
04:43:04 <lambdabot> No query entered
04:43:04 <Cale> Oh, or a triple of integers
04:43:04 <lambdabot> Try --help for command line options
04:43:20 <Stalafin> Cale: actually yeah... why don't i do that :D
04:43:32 <Cale> You could also invent a new datatype
04:43:56 <Cale> which may be a good idea to help confer the meaning of the data
04:45:39 <Stalafin> Cale: what is the reasoining behind defining something like data Point = Point Float Float? Why not data Point = Float Float?
04:46:10 <int-e> @src Maybe
04:46:11 <lambdabot> data Maybe a = Nothing | Just a
04:46:37 <Stalafin> I took that example from learnyouahaskell
04:46:38 <Cale> Stalafin: Data types have data constructors which construct values of the new type that you're defining.
04:46:43 * ketil sighs. You're in a twisty maze of Data.Typeable constructs.....  I'll just make it a bleeding string and use 'read' on it.
04:47:07 <Stalafin> Cale: so data Point = Point would be a constructor?
04:47:12 <Cale> The first name in each | separated case is not the name of a type, but the name of the data constructor you're defining to be able to make values of that type
04:47:24 <Stalafin> ok
04:47:45 <ketil> I'll give it one final shot by reading the documentation, but that's it. :-)
04:48:06 <int-e> toFlagType is funny. But how does it ever return Nothing? http://hackage.haskell.org/packages/archive/cmdargs/0.1/doc/html/src/System-Console-CmdArgs-Type.html
04:48:36 <Cale> int-e: I looked at it and couldn't figure that out either.
04:48:57 <Cale> Pattern guard magic?
04:49:38 <Cale> Stalafin: So yeah, if you define something like  data Colour = Red | Green | Blue, this defines Red, Green, and Blue as values of type Colour.
04:49:58 <Cale> Stalafin: and if you wrote  data Point = Point, you get a type with only a single defined value, whose name is Point
04:50:34 <Cale> To make more interesting types, you give the constructors parameters, which you indicate by just listing the types of the parameters after the name
04:52:05 <Stalafin> Cale: so does it make sense to define my Node like this: data Node = Node (Int,Int,Int)?/
04:52:09 <SamB_XP> Cale: what, you mean it gets more interesting than Ordering?
04:52:17 <Cale> Or  data Node = Node Int Int Int
04:53:19 <Cale> SamB_XP: Sorry, I was mistaken. Ordering, Bool and () are the most interesting possible types in Haskell.
04:53:30 <SamB_XP> ;-P
04:53:36 <SamB_XP> you forgot Void
04:54:47 <Cale> If you think about it, Void only contains nonterminating programs, which is sort of interesting.
04:58:45 <McManiaC> hmmm
04:58:53 <McManiaC> is there no way to use HSP XML without the IO monad?
05:00:10 <McManiaC> i know theres HSPT, but run/evlHSPT needs a "HSPEnv" and HSPEnv has a NumberGen (incNumber :: IO Int) in it
05:02:06 <Stalafin> is there a way to make a function, that takes a tuple and creates a tuple of higher order out of it? say, i am passing a pair, i want to get a triple; I am passing a triple, I want to get a quadruple, etc
05:03:03 <Cale> Stalafin: Well, think about what type that function would have...
05:03:12 <McManiaC> or actually, I want to use XML without HSP at all, but with the nice HSP preprocessor :O
05:03:27 <Cale> Stalafin: You could do something with typeclasses, if you're willing to write an instance for each sort of tuple you want to handle
05:03:41 <Stalafin> Cale: no way to generealize that?
05:03:53 <osaunders> Template Haskell.
05:04:06 <Cale> Stalafin: You could just produce a pair, one of whose parts is a tuple, in some cases :)
05:04:08 <Roman01> Can anyone send me a decent video\text guide for C#\Java\ASP\PHP, I'm a beginner with background.
05:04:13 <Stalafin> Cale: so, i can't take whatever arbitrary tuple of order n and make a tuple of order n+1?
05:04:19 <Cale> Stalafin: right
05:04:23 <Stalafin> :(
05:04:27 * Stalafin is sad.
05:04:30 <Cale> Stalafin: tuple types are completely separate and unrelated
05:04:32 <Botje> Roman01: wrong channel
05:04:33 <Axman6> what would the type be?
05:04:36 <Cale> (except for their syntax)
05:04:43 <MissPiggy> you can make a function that turns (a,(b,(c,(d,())))) into (foo,(a,(b,(c,(d,())))))
05:04:53 <MissPiggy> and the type of that is a -> (Foo,a)
05:04:54 <Cale> Stalafin: actually in practice, people rarely use anything larger than a triple anyway
05:05:20 <Cale> Stalafin: since if you have lots of fields, you're probably better off defining a new type with a name
05:05:37 <Stalafin> Cale: well, i want to create a permutations of Integers a,b,c, so that i have a list of all possible permutations
05:05:40 <Axman6> if it's more than 4 elements, you'd usually just make your own type (and often if it's less too)
05:05:55 <Stalafin> Cale: thought i start with all permutations of c, then do b,c, then do it with a,b,c,
05:05:56 <Axman6> Stalafin: sounds like what lists are for
05:06:06 <Cale> Yeah, use lists
05:06:08 <Stalafin> Axman6: list of triples...
05:06:12 <Stalafin> that's what i intended
05:06:16 <Axman6> or.. lists of lists
05:06:18 <Cale> Stalafin: a list of lists
05:06:27 <Stalafin> that's still clean?
05:06:32 <Axman6> yes
05:06:32 <Stalafin> ok then........
05:06:39 <Axman6> why woul;dn't it be?
05:06:52 <Axman6> the results could (presumably) be of any size
05:06:56 <MissPiggy> Stalafin desn't that do what you want
05:07:12 <Axman6> so, they basically have to use some kind of recursive data structure
05:07:31 <Stalafin> MissPiggy: i guess... i just thought i should avoid doing smth with lists if i have a clearly defined list of triples
05:07:36 <MissPiggy> ugh
05:07:53 <Stalafin> MissPiggy: don't say ugh :p
05:08:14 <Axman6> Stalafin: if you use lists of lists, then the function should work with all input lists
05:08:29 <Axman6> so, you would be definint a permutations function
05:08:29 * theorbtwo wonders if fst and snd have obnixious names specifically so that you won't use large tupples.
05:08:36 <Axman6> defining*
05:12:18 <Cale> theorbtwo: Would you prefer p1 and p2?
05:12:33 <Botje> car & cdr :)
05:12:41 <Cale> If the names were any longer of course, there wouldn't be any point to defining them
05:12:49 * Axman6 stabs Botje 
05:13:03 <Cale> (\(x,y)->x) is pretty short as it is.
05:13:06 <theorbtwo> I'd prefer first and second.
05:13:16 <MissPiggy> why all this horrible violence
05:13:33 <benmachine> :t first
05:13:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
05:13:35 <Cale> If you use names like first and second, there's barely any point to making the definitions, you might as well use lambda which is unambiguous.
05:13:44 <theorbtwo> However, the ugly names *do* suggest a nice rule of thumb; if you want to use anything past snd, you should probably use a proper data type.
05:13:59 * Axman6 agrees with Cale 
05:14:00 <Cale> (and yeah, first and second make for better higher-order functions :)
05:15:29 <Cale> If you want to extract components from larger tuples, I recommend the same -- just use lambda with a pattern match.
05:16:00 <Cale> (or incorporate the pattern match into something else, of course)
05:20:24 <MissPiggy> @instances Arrow
05:20:25 <lambdabot> (->), Kleisli m
05:20:51 <MissPiggy> useless...
05:21:52 <quicksilver> theorbtwo: N-tuples have a place as convenient anonymous datatypes, but normally in an isolated setting
05:22:04 <quicksilver> theorbtwo: e.g. probably not as part of your API
05:22:13 <quicksilver> I use them for structured constant data
05:22:33 <quicksilver> normally very close to a map (\(a,b,c,d,e) -> ... do something useful with this stuff) constant_list
05:22:39 <sm> how can I trigger an error rather than a failure, within a hunit test
05:22:41 <sm> ?
05:35:54 <MissPiggy> another day another failed attempt!
05:36:46 <Polarina> MissPiggy, :)
05:39:00 * ksf decides to open up a list of coding tips that have nothing to do with coding. The first one I got is "Neither wash your dishes before cooking nor while eating, but after burping."
05:40:44 <ManateeLazyCat> mm_freak: Are you still here?
05:41:23 <mm_freak> ManateeLazyCat: yes, how can i help you?
05:41:52 <ManateeLazyCat> mm_freak: http://thread.gmane.org/gmane.comp.lang.haskell.gtk2hs/1543/focus=1611 is discuss about StateT and gtk2hs, what do you think?
05:42:39 <ManateeLazyCat> mm_freak: I talk in gtk2hs mail-list about how to use StateT in gtk2hs program, and discuss is use IORef or MVar.
05:43:33 <ManateeLazyCat> http://thread.gmane.org/gmane.comp.lang.haskell.gtk2hs/1543/focus=1611 have Axel's explain that why StateT can't work.
05:44:17 <micah> anyone here a parsec expert?
05:44:22 <micah> :)
05:44:32 <MissPiggy> I am an expert parsec user
05:44:38 <micah> :D
05:45:00 <micah> how would you handle keywords and names in a parsec parser?
05:45:29 <MissPiggy> well there is two basic ways:
05:45:31 <Botje> if you're going to do something serious, use a tokenizing parser
05:45:42 <micah> ok I thought so
05:45:54 <micah> using parsec?
05:46:13 <mm_freak> ManateeLazyCat: in what i proposed you don't need StateT inside your gtk2hs-using code
05:46:40 <ManateeLazyCat> mm_freak: I can't understand.
05:46:54 <mm_freak> ManateeLazyCat: see the example code i linked
05:47:04 <ManateeLazyCat> mm_freak: Where?
05:47:19 <mm_freak> http://codepad.org/qRHwLu10
05:47:45 <ManateeLazyCat> mm_freak: Okay, i read it.
05:48:30 <MissPiggy> http://maxima.sourceforge.net/i/imaxima.png
05:48:39 <MissPiggy> look at this awesom mode
05:48:59 <micah> cool
05:49:24 <Stalafin> i use the standard distribution of haskell from my linux distr (archlinux); how can i check if i have a package or not (package is 'vector' as in http://haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial )
05:50:03 <silver_> pacman <something>
05:50:10 <Stalafin> lol
05:50:27 <Stalafin> silver_: i thought about haskell packages... don't i have to use cabal?
05:50:38 <silver_> cabal info vector
05:50:41 <silver_> I guess
05:50:47 <Stalafin> thanks
05:51:22 <ManateeLazyCat> mm_freak: How to use your program?
05:51:37 <mm_freak> ManateeLazyCat: how about compiling and running it? =)
05:51:55 <silver_> you can use pacman (or another arch package manager) to install haskell libs AFAIK
05:51:58 <ManateeLazyCat> mm_freak: I have compile and run it, nothing
05:52:17 <ManateeLazyCat> mm_freak: Like list port 40000, but nothing.
05:52:23 <mm_freak> ManateeLazyCat: it's a chat server
05:52:29 <Stalafin> ok... to put it differently - is there a package in haskell to work with vectors? (i am talking about vector calculus... i just need addition and multiplication... can write it myself, but maybe there is soemthing)
05:52:32 <mm_freak> you need to connect to it using netcat/telnet
05:54:33 <silver_> Stalafin, try "cabal list vector"
05:55:56 <sinelaw> how do i do inline code in latex lhs?
05:56:08 <sinelaw> by non-inline i mean \begin{code}
05:56:19 <sinelaw> i'm using lhs2tex
05:56:54 <ManateeLazyCat> mm_freak: Sorry, i don't know how to use it, detail? I haven't use netcat.
05:57:06 <sm> http://gist.github.com/308712 tries to be a reliable shell command runner - how does it look ? I seem to be getting no stdout
05:57:21 <mm_freak> ManateeLazyCat: just connect to it
05:57:32 <mm_freak> nc localhost 40000
05:57:47 <ManateeLazyCat> mm_freak: Okay, have result.
05:58:00 <ManateeLazyCat> Client on: localhost (42151)
05:58:11 <mm_freak> the client manager thread keeps track of all the client handles
05:58:19 <mm_freak> so if any client sends something, it's send to every client
05:58:52 <ddarius> Stalafin: The purpose of Cabal is not to replace the system package manager.
06:01:19 <Stalafin> my haskell doesn't like the following: type A1 = (1,1,(-1)) ... it gives me bcc.hs:11:16: parse error on input `-'
06:01:34 <Stalafin> what could be wrong with that thing?
06:01:59 <ddarius> Stalafin: What do you intend that to do?
06:02:17 <Stalafin> ddarius: i want to give a name to a triple
06:02:30 <ddarius> Stalafin: Then why are you using 'type'?
06:02:32 <Stalafin> ddarius: and my triple is simply (1,1,-1)
06:02:45 <Stalafin> ddarius: hm... learnyouahaskell? :D
06:03:31 <Stalafin> oh, i must have misunderstood something
06:03:31 <BONUS> hey, i never said you could do that! :)
06:03:33 <Stalafin> it sees
06:03:36 <Stalafin> smmes
06:03:46 <Stalafin> geez.... seems*; sorry
06:03:46 <dolio> type is for defining types.
06:03:57 <dolio> Is (1, 1, -1) a type?
06:03:57 <BONUS> type synonyms, yeah
06:04:17 <Stalafin> apparently not :(
06:04:43 <Stalafin> arrite, thanks a bunch
06:05:43 <ddarius> :k (1,1)
06:05:44 <lambdabot> *
06:05:51 * ddarius sows confusion.
06:07:09 <etpace> Anyone here use haskell-mode for vim? I've installed it with the vimball, and things like :make: and quickfix, _T etc work, but it seems the comand :DocSettings etc does not exist, so I cant make use of _? etc, any ideas?
06:07:49 <Zao> > let x = (1,1,(-1)) in [x,x]
06:07:50 <lambdabot>   [(1,1,-1),(1,1,-1)]
06:08:10 <Zao> @type (1,1,(-1))
06:08:11 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (t, t1, t2)
06:08:39 <ManateeLazyCat> mm_freak: I use "IORef WindowList" to manager Window. And type `Window` contain some Gtk+ Widget for test Event. So from your suggestion and above link, i can't change "IORef WindowList" with StateT, right?
06:09:10 <zygoloid> > (1,1,-1)
06:09:11 <lambdabot>   (1,1,-1)
06:09:13 <mm_freak> ManateeLazyCat: that really depends
06:09:32 <mm_freak> ManateeLazyCat: IIRC gtk2hs requires all GTK-related functionality to be in a single OS thread
06:09:48 <ManateeLazyCat> mm_freak: Yes.
06:09:51 <mm_freak> you can use bound threads
06:10:20 <mm_freak> ManateeLazyCat: but are you sure you understand StateT fully?
06:10:37 <ManateeLazyCat> mm_freak: I will use `PostGUIAsych` to make sure all Gtk+ function running in main thread.
06:11:27 <ManateeLazyCat> mm_freak: Problem is, i can't use StateT with gtk2hs code. But i can't understand what you mean.
06:11:55 <ManateeLazyCat> mm_freak: The status i need manager infact is some Gtk+ widget.
06:12:27 <sinelaw> @hoogle gscan
06:12:28 <lambdabot> No results found
06:12:37 <sinelaw> @hoogle tscan
06:12:37 <lambdabot> No results found
06:12:43 <mm_freak> ManateeLazyCat: i think you haven't understood state monad transformers
06:12:55 <sinelaw> @type scanl
06:12:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:13:32 <mm_freak> ManateeLazyCat: take your time to learn it properly…  best without gtk2hs and concurrency
06:13:42 <mm_freak> as soon as you understand it, try using concurrency properly
06:13:49 <mm_freak> then go ahead with your GTK project
06:15:36 <ManateeLazyCat> mm_freak: I think i haven't found key. :)
06:17:59 <theorbtwo> @hoogle reads
06:17:59 <lambdabot> Prelude reads :: Read a => ReadS a
06:18:00 <lambdabot> Text.Read reads :: Read a => ReadS a
06:18:00 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
06:20:46 <xerox> Is there an arch-haskell channel?
06:21:29 <silver_> yes
06:21:35 <silver_> #haskell-arch
06:21:39 <xerox> Thanks.
06:21:43 <silver_> oh sec
06:21:46 <silver_> \not that
06:22:06 <silver_> #arch-haskell
06:22:54 <Stalafin> what is the proper expression for the first 2 elements in a list? i thought x:y:xs would work, but it does not
06:23:50 <Zao> > let (x:y:xs) = [1..10] in (x,y,xs)
06:23:51 <lambdabot>   (1,2,[3,4,5,6,7,8,9,10])
06:24:14 <Stalafin> hm, odd
06:24:17 <Zao> Stalafin: You probably need parens when matching.
06:24:35 <ManateeLazyCat> mm_freak: Thanks for your help. I think spend more time one StateT, hope it will help with my multi-thread program.
06:24:44 <ManateeLazyCat> s/think/need
06:24:57 <Stalafin> Zao: indeed! that was the problem
06:25:00 <Stalafin> thank you
06:26:17 <mm_freak> ManateeLazyCat: StateT has nothing to do with multithreading actually
06:26:22 <mm_freak> you can use it everywhere
06:26:44 <Vitka> Can anyone point me in right direction to implement recursion for equations like http://tinypic.com/r/ddme5 ?
06:27:23 <Zao> 404
06:28:05 <Vitka> oops
06:28:29 <Vitka> http://tinypic.com/r/ddme5j/6
06:28:35 <Vitka> That should do it.
06:28:47 <sm> aha!
06:29:51 <sm> how come  runhaskell script.hs shows output on the console, but if you add >t 2>&1 , leaves t empty as if there was no stdout or stderr ?
06:30:56 <ManateeLazyCat> mm_freak: I just think this model: RootProcess keep some Gtk+ status, and many other process will send *request* to RootProcess to modified those status, and those request perhaps send at same time. Just RootProcess and modified status, but have some many *request*, i hope RootProcess handle those *request* one by one.
06:31:15 <ManateeLazyCat> mm_freak: So i want to some solution to replace IORef.
06:31:47 <ManateeLazyCat> s/and modified/can modified
06:33:07 <mm_freak> ManateeLazyCat: again, first learn how to use monad transformers (in particular StateT) and concurrency properly =)
06:33:13 <ManateeLazyCat> mm_freak: RootProcess will running many threads for listen client request, but just one thread have permission to update status.
06:33:19 <gwern> I wonder what is up with either the PDF format or ImageMagick that 'convert *.jpg foo.pdf' leads to 70MB of JPEGs comically becoming a 445M PDF
06:33:44 <Zao> gwern: Draw one vector box per source pixel?
06:33:50 <ManateeLazyCat> mm_freak: Okay.
06:34:00 <gwern> Zao: but how could either be so moronic?
06:35:03 <Zao> gwern: Over-generic abstractions not allowing for clever handling?
06:35:06 <kpreid> gwern: maybe the images were recoded as something less compact than JPEG?
06:35:19 <gwern> kpreid: also possible but I struggle to understand why
06:35:29 <gwern> jpeg is ancient
06:35:35 <mm_freak> ManateeLazyCat: sorry, but otherwise i can't help you…  i can propose solutions all day, but that's pretty pointless, if you don't know how to use them
06:35:36 <kpreid> if the pdf render takes pixmaps as input
06:35:42 <kpreid> s/render/generator/
06:35:48 <gwern> gosh jpeg first came out in 1992
06:35:52 <quicksilver> they might be being recoded as tiff
06:36:03 <osaunders> Is + a monoid?
06:36:06 <quicksilver> should be options to control it though
06:36:24 <gwern> osaunders: as is *
06:36:27 <quicksilver> osaunders: Int is a monoid (small m) under +, yes
06:36:52 <quicksilver> osaunders: it's not a Monoid (large m) just because there are too many possibly Monoids and no canonical one
06:36:53 <ManateeLazyCat> mm_freak: Nevermind, thanks for you help. :) I just don't know why need StateT and how to use it.
06:37:24 <kpreid> gwern: according to wikipedia images in pdf may be compressed with, among other things, "DCTDecode a lossy filter based on the JPEG standard"
06:37:33 <mm_freak> ManateeLazyCat: you don't _need_ it
06:37:39 <osaunders> quicksilver: Too many what?
06:37:42 <mm_freak> it's just that it encodes precisely what you want to do =)
06:37:55 <Stalafin> if i get an error like Not in scope: `hputStr' does that mean that there is smth wrong with my code, or is there a library missing?
06:37:58 <quicksilver> osaunders: too many possible ways you could make Int into a Monoid
06:38:12 <kpreid> gwern: so that implies that you can't *just* stick jpeg data into a pdf, so the software may not be clever enough to recognize this situation and recode it appropriately
06:38:20 <quicksilver> osaunders: (+), (*), (max), (min) for starters
06:38:29 <gwern> well, we'll see what pdfjam does; if it's stupid too then that implies the problem is PDF
06:38:33 <kpreid> and using lossy compression without *asking permission first* would be Bad.
06:38:36 <fasta> Ah, cool, I can write a program in ghci, when evaluated prints Exception a million times without catching any exception!
06:38:36 <osaunders> quicksilver: OK, so if you wanted those things you would write them yourself or get a library.
06:39:02 <kpreid> osaunders: the monoid library already has them
06:39:12 <fasta> And by cool, I mean "that is not supposed to happen".
06:39:37 <kpreid> osaunders: well, Sum and Product in Data.Monoid anyway. No min or max, actually
06:39:46 * ManateeLazyCat Why need StateT this wrapper? It's looks complicated than IORef and MVar. 
06:40:37 <gwern> > fix error
06:40:38 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
06:40:38 <mm_freak> ManateeLazyCat: after learning it, you won't write projects without StateT ;)
06:40:53 <ManateeLazyCat> mm_freak: Really?
06:40:59 <gwern> hm. pdfjam gave me just 71M
06:41:02 <ManateeLazyCat> mm_freak: Or just kidding? :)
06:41:06 <gwern> for 69MB of jpegs
06:42:13 <quicksilver> @remember fasta And by cool, I mean "that is not supposed to happen".
06:42:13 <fasta> Hmm, I was wrong. In fact it is possible to write legal (but wrong) code which does this.
06:42:14 <lambdabot> I will never forget.
06:42:30 <Twey> :t fix error
06:42:31 <lambdabot> [Char]
06:42:44 <Twey> :t fix
06:42:45 <lambdabot> forall a. (a -> a) -> a
06:43:01 <kpreid> fasta: by what standard is the code "wrong"? :-)
06:43:11 <mm_freak> ManateeLazyCat: really
06:43:22 <fasta> kpreid, my standards.
06:43:34 <kpreid> Oh good.
06:44:09 <ManateeLazyCat> mm_freak: Okay, i think it's worth to learning, even it's confuse me now. :)
06:44:48 <mm_freak> ManateeLazyCat: learn about State first
06:45:06 <mm_freak> then StateT
06:45:17 <ManateeLazyCat> mm_freak: Can you recommend me some books that talking StateT?
06:46:39 <ManateeLazyCat> mm_freak: I'm search HaskellWiki, but i prefer to reading book.
06:48:08 <mm_freak> i don't know, try RWH
06:48:16 <mm_freak> but i haven't read it
06:48:18 <ManateeLazyCat> mm_freak: Last question, StateT can replace IORef anywhere?
06:48:38 <mm_freak> anywhere where you use IORef as a mutable variable
06:49:03 <ManateeLazyCat> mm_freak: I mean, StateT can do everything that IORef can do?
06:49:13 <fasta> ManateeLazyCat, you are confusing two concepts.
06:49:14 <mm_freak> you can't compare the two
06:49:32 <mm_freak> StateT is a completely different way to encode what you're currently encoding using IORef
06:52:04 * zygoloid ponders, if the Mendler-style encoding of a Functor is Yoneda and of a Monad is Codensity, then the encoding of a Monoid is... Endo?
06:53:40 <Saizan> Mendler-style encoding?
06:56:14 <Saizan> ManateeLazyCat: no, if you want to communicate between threads or similar StateT can't help you
06:57:06 <ManateeLazyCat> Saizan: mm_freak recommend me use StateT and a manager thread to handle common status.
06:57:25 <ManateeLazyCat> Saizan: But i don't know how to use StateT, i haven't understand it fully.
06:59:50 <mreh> is -XArrows the arrow syntax pragma?
07:00:30 <Saizan> yes
07:00:54 <mreh> curiously, there's -XNoArrows, but I suppose that's to override a global option
07:01:09 <osaunders> Can you have monoids for characters, strings, lists etc?
07:01:23 <Saizan> [a] is a monoid
07:01:44 <fasta> I use no unsafe operations, other than unsafePerformIO $ putStrLn and I get a program which segfaults. Long live great implementations.
07:01:46 <osaunders> Ok.
07:01:51 <mreh> with ++ and []?
07:01:58 <Saizan> yes
07:02:30 <osaunders> Saizan: Isn't that a type that can be a monoid?
07:02:45 <mreh> it's polymorphic
07:02:50 <osaunders> Rather than a monoid itself. Because a monoid is a concept, right?
07:03:01 <Saizan> ManateeLazyCat: ah, ok, StateT will work inside that manager thread, you'd use some other thing to communicate between that and other threads
07:03:45 <Saizan> osaunders: well, yeah, ([a],++,[]) is the monoid
07:04:05 <ManateeLazyCat> Saizan: Oh, i understand. Use MVar communication with other thread, then use StateT replace IORef in manager thread, right?
07:04:07 <Saizan> osaunders: but it's not uncommon to just refer to the set/type as the monoid
07:04:17 <osaunders> Right, OK.
07:04:20 <Saizan> ManateeLazyCat: yeah
07:04:28 <ManateeLazyCat> mm_freak: Are you this mean?
07:04:59 <mm_freak> ManateeLazyCat: that's what i mean, yes
07:05:10 <mm_freak> StateT to carry the state, MVar to communicate commands
07:05:21 <ManateeLazyCat> mm_freak: Oh, i understand what you mean now. :)
07:05:33 <mm_freak> great =)
07:05:40 <ManateeLazyCat> mm_freak: I consider you use StateT replace IORef and MVar.
07:11:52 <fizruk> @src on
07:11:52 <lambdabot> (*) `on` f = \x y -> f x * f y
07:12:12 <ben> @src comparing
07:12:12 <lambdabot> Source not found.
07:12:23 <fizruk> @src compare
07:12:24 <mreh> @src compare
07:12:24 <lambdabot> compare x y | x == y    = EQ
07:12:24 <lambdabot>             | x <= y    = LT
07:12:24 <lambdabot>             | otherwise = GT
07:12:24 <lambdabot> compare x y | x == y    = EQ
07:12:24 <lambdabot>             | x <= y    = LT
07:12:26 <lambdabot>             | otherwise = GT
07:13:02 <ben> I meant comparing p x y = compare (p x) (p y)
07:13:25 <mreh> you do "compare `on` snd" usually
07:14:01 <idnar> isn't that just comparing second?
07:14:11 <ben> comparing snd?
07:14:16 <idnar> err, that
07:14:23 <fasta> :t comparing
07:14:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:14:24 <mreh> second is the Arrow
07:14:33 <\yrlnry> :t on
07:14:34 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:14:36 <opqdonut> :t comparing second
07:14:37 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a, Ord (a (d, b) (d, c))) => a b c -> a b c -> Ordering
07:14:40 <idnar> @type (compare `on`)
07:14:41 <opqdonut> it's not nonsensical!
07:14:41 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
07:14:56 <opqdonut> I love the Ord (a (d, b) (d, c)) constraint tho
07:14:58 <idnar> comparing = (compare `on`)
07:15:31 <mreh> comparing second doesn't make sense
07:15:47 <idnar> mreh: it depends on what arrow you're using
07:16:02 <idnar> but anyway, I meant "comparing snd"
07:16:13 <mreh> (y)
07:17:25 <mreh> i have haskell neck.. ow
07:17:45 <osaunders> When one says that [a] is a monoid, does it mean that values of any type in a homogenous list can be combined in a way that satisfies monoidic laws? Or, does it mean that multiple [a] values could be combined in a way that satisfies monoidic laws?
07:17:59 <mreh> the first one
07:18:16 <osaunders> OK.
07:18:37 <mreh> osaunders: [a] isn't a monoid on its own
07:18:48 <osaunders> mreh: Yeah.
07:18:54 <mreh> it's a monoid with the operator ++ and the zero ([])
07:19:14 <mreh> xs ++ [] == xs
07:19:19 <mreh> [] ++ xs == xs
07:19:38 <osaunders> mreh: I'm trying to write up my understanding.
07:19:44 <osaunders> I have this so far: Confusingly, it is not uncommon for a type that can be combined in a way that satisfies the monoidic laws to be called a monoid, also. Technically, such types aren't monoids; they have the potential to be monoids but they aren't monoids themselves. In this sense, it is true to say the type `[a]` is a monoid as values of any type in a homogenous list can be combined in a way that satisfies monoidic laws.
07:20:12 <mreh> osaunders: [a] is a description of a type
07:20:28 <mreh> it is a monoid, it's just more abstract, it describes a set of monoids
07:20:36 <zygoloid> Saizan: it's a term I saw in a -cafe post by EdwardK. the idea seems to be to create a type which enforces the laws of some structure for any object
07:21:23 <zygoloid> Saizan: so for instance, newtype Yoneda f a = Yoneda { runYoneda :: forall r. (a -> r) -> f r } allows you to make a functor out of any 'f'
07:21:41 <osaunders> mreh: Wait, so [a] is a set of monoids now?
07:21:42 <zygoloid> Saizan: with the restriction that you need to provide something akin to an fmap to actually get the 'f r' out
07:22:18 <mreh> osaunders: yes, for all a, [a] is a monoid
07:22:52 <dolio> I don't think I've ever seen the word monoidic before.
07:23:03 <mreh> monoidal?
07:23:03 <osaunders> OK, I'm going to forget [a] for now. Int is a monoid and that's good enough for me, for now.
07:23:07 <zygoloid> monoidal, yeah
07:23:12 <dolio> I have seen monoidal, yes.
07:23:14 <osaunders> Oh, OK.
07:23:25 <osaunders> I just thought because it's monadic.
07:23:28 <osaunders> ...
07:23:37 <zygoloid> and functorial?
07:23:50 <mreh> :) you're making these up
07:24:05 <dolio> Tensorial.
07:24:10 <zygoloid> applicative
07:24:23 <opqdonut> applicatial?
07:24:26 <opqdonut> applicial?
07:24:28 <benmachine> foldalicious
07:24:33 <opqdonut> :D
07:24:43 <mreh> functional programming?! That's a bit presumptuous isn't it?
07:24:46 <zygoloid> traversty?
07:25:09 <mreh> I like that one
07:25:19 <benmachine> mreh: as opposed to PHP which can be described as non-functional programming
07:25:28 <mreh> :)
07:25:50 <opqdonut> arrowific
07:26:10 <zygoloid> nummy?
07:27:33 <opqdonut> ordacious, equified
07:27:58 <zygoloid> fractive
07:28:36 <zygoloid> (as in "fractive index", a term applied to an array where the indices need not be integers)
07:28:58 <osaunders> Functional is a terrible word.
07:29:07 <osaunders> It should be funtion-oriented or something.
07:29:15 <zygoloid> dysstructural
07:29:56 <osaunders> There's function-basd which is apparently different from functional.
07:30:03 <osaunders> *based
07:31:47 <endojelly> osaunders, intensionally or extensionally? ;)
07:32:24 <osaunders> endojelly: What are you referring to?
07:33:25 <zygoloid> osaunders: whether they're defined differently but equivalent, or whether they actually mean different things
07:34:16 <endojelly> exactly!
07:34:47 <osaunders> I don't know what intension or extension mean in the logical sense.
07:34:47 <endojelly> and with "defined differently" I was actually referring in how it's spelt differently
07:35:00 <endojelly> err, referring to, not referring in
07:35:13 <osaunders> endojelly: I think they are actually different although they no doubt both involve functions.
07:35:52 * hackagebot upload: ConfigFile 1.0.6 - Configuration file reading & writing (JohnGoerzen)
07:36:04 <endojelly> osaunders, sorry it wasn't that serious
07:37:06 <BenceF> anyone else fainding irritating how prelude functions handle [] ?
07:37:10 <osaunders> endojelly: Sorry for being such a wet blanket.
07:37:21 <BenceF> > head []
07:37:22 <lambdabot>   * Exception: Prelude.head: empty list
07:37:40 <osaunders> BenceF: Maybe you'd like #alt-stdlib ?
07:37:49 <zygoloid> > (listToMaybe [], listToMaybe [1,2,3])
07:37:50 <lambdabot>   (Nothing,Just 1)
07:38:12 <BenceF> id like listToMaybe
07:38:16 <endojelly> osaunders, no problem, it wasn't a good joke to begin with 8)
07:38:20 <BenceF> thank you zygoloid
07:38:25 <zygoloid> no problem :)
07:38:55 <BenceF> :info listToMaybe
07:39:02 * zygoloid thinks that listToMaybe should be Prelude.maybeHead :)
07:39:09 <zygoloid> BenceF: it's in Data.Maybe
07:39:16 <BenceF> thanks
07:40:24 * zygoloid was amused to note that one can make a ZipList monad from Codensity []
07:41:42 <zygoloid> (and that you can in fact mix and match between ZipList-style list operations and backtracking-style list operations, as well as use things like "take' :: Int -> Codensity [] ()" within the monad)
07:46:25 <osaunders> In the definition "A monoid is a collection of things and a method for combining them that obeys certain laws." by collection does it mean any number of items of any type or a specific number of items from a single collection e.g. type?
07:47:00 <osaunders> I have a hunch it's the latter and that the specific number is 2.
07:47:30 <BONUS> osaunders: i'd say it's the second and that number can be whatever
07:47:32 <mm_freak> osaunders: any set
07:47:35 <dolio> It means something like a set, but it's trying to not be tied to set theory.
07:47:54 <BONUS> you can view a type as a set of values
07:48:17 <mm_freak> are there groups, for which the underlying collection is not a set?
07:48:37 <osaunders> BONUS: Yes, so it means it in that sense?
07:49:06 <dolio> If you're defining groups in type theory, the underlying collection is likely to be a type.
07:49:52 <MissPiggy> stuff like groups in type theory is really hard
07:49:56 <osaunders> Does a monoidal operation always take 2 args?
07:49:59 <BONUS> for instance, a monoid is + along with numbers, where 0 is the identity
07:50:15 <MissPiggy> one reason is because you have to do setoids (quotients would be nicer)
07:50:16 <BONUS> and if we limit ourselves to whole numbers, then those are countably infinite
07:50:27 <MissPiggy> another is trying to structure an algebra heierarcly is very difficult
07:50:53 <MissPiggy> like if you have to type 20 lines of imports and opening up modules instead of saying "let G be a group"
07:51:31 <ManateeLazyCat> MissPiggy: Haskeller like me? :)
07:51:39 <mm_freak> i think a type always resembles a set
07:51:44 <mm_freak> at least in haskell
07:52:20 <osaunders> Is it better to say then: A monoid is a way of combining two items from a single set in a way that obeys certain laws?
07:53:17 <MissPiggy> ManateeLazyCat hi! yes :)
07:53:30 <ManateeLazyCat> MissPiggy: Hey. :)
07:53:33 <dolio> Also, in category theory, you can define group objects in arbitrary categories with binary products and a terminal object (I believe that's what you need).
07:53:45 <dolio> So if that's what you refer to as a group, it has an underlying object, so to speak.
07:54:16 <ManateeLazyCat> Have some many spy from #emacs. :)
07:54:26 <ManateeLazyCat> s/some/so
07:54:28 <dolio> And for any particular category, the underlying object could be a sort of collection that isn't conceptually just a set.
07:54:29 <BONUS> i'd say: a monoid is a set S along with a binary operation that is associative and there is an element i in S such that it's a left and right identity for the operation
07:54:32 <fizruk> in what module is 'on'?
07:54:38 <MissPiggy> on is no monad
07:54:42 <dolio> fizruk: Data.Function
07:54:42 <MissPiggy> it's Data.Function
07:54:47 <BONUS> damn, beaten
07:54:50 <fizruk> thanks
07:54:57 * hackagebot upload: ftphs 1.0.6 - FTP Client and Server Library (JohnGoerzen)
07:55:19 <dolio> So, a topological group is (I think) a group object in the category of topological spaces, and it has an underlying topological space.
07:55:25 <osaunders> BONUS: Yeah, my definition was incomplete.
07:55:35 <osaunders> I'm getting to the other stuff =)
07:56:36 <BONUS> but essentially you could say that a monoid is a tuple (S,*) where S is a set and * is a binary operation on S x S -> S and then there are some laws involved
07:57:40 <Entroacceptor> but that would include groups, semigroups and other stuff, too
07:58:00 <BONUS> yeah well you have to specify the laws too
07:58:11 <zygoloid> you could say that a monoid is a pair (S,r) where r :: [S] -> S, with the law that partitioning the input and recursively running r reduces to the same result, but that's not the traditional definition
07:58:45 <zygoloid> BONUS: in your case you need (S,*,0) where 0 is in S
07:58:53 <Entroacceptor> zygoloid: is that really equivalent?
07:59:23 <BONUS> zygoloid: yeah, true, i meant to define the 0 in the laws but it's better like that
07:59:50 <zygoloid> Entroacceptor: no, you also need the law that r [x] = x :)
07:59:55 <MissPiggy> zygoloid, that's kind of wild why would you say that?
08:00:11 <MissPiggy> zygoloid, to define it with r I meant
08:00:30 <zygoloid> MissPiggy: because it has 1 primitive rather than 2. it's just another way of viewing it.
08:00:36 <MissPiggy> aha
08:01:18 <domor> > "The universe and everything
08:01:19 <lambdabot>   <no location info>:
08:01:19 <lambdabot>      lexical error in string/character literal at end o...
08:01:36 <domor> > "The universe and everything: \42" -- dang enter
08:01:37 <lambdabot>   "The universe and everything: *"
08:02:23 <zygoloid> it also provides a more direct way of seeing why it's important (that it allows arbitrary parallelization)
08:03:18 <osaunders> I understand that the concept of a monoid entails but it is hard to pin down what the noun "monoid" actually means. It is a pair, a function, a set of possible values?
08:03:45 <Entroacceptor> an algebraic thing
08:03:53 <jmcarthur> it's a set with an associative obinary operations that has an identity, in abstract algebra
08:03:55 <osaunders> Perhaps a monoid isn't a thing so much as a thing-you-do.
08:03:59 <jmcarthur> *operation
08:04:04 <dolio> "Monoid" is typically formally defined to be the (M, *, e) satisfying the relevant laws.
08:04:32 <dolio> But mathematicians also typically refer to the collection M as the monoid, because it's easy short-hand.
08:04:45 <osaunders> So a monoid is a triple?
08:04:57 <osaunders> And a type?
08:04:59 <dolio> If you decide to define it that way, yes.
08:05:02 <jmcarthur> but can be ambiguous when you can make more than one monoid from that one collection
08:05:05 <mreh> turing machines are a 5-tuple IIRC
08:05:13 <jmcarthur> usually not ambiguous in context
08:05:56 <mreh> Int for example
08:05:56 <mreh> has two
08:06:03 <dolio> More than that.
08:06:10 <MissPiggy> turing machines don't exist!
08:06:19 <mreh> I only know two
08:06:46 <dolio> (Int, max, minBound) and (Int, min, maxBound) are two more.
08:06:49 <mreh> * 1, + 0, / 1(?), - 0(?)
08:06:59 <mreh> they're inverses, they don't count :)
08:08:40 <Berengal> Subtraction and division aren't associative
08:08:53 <mreh> very true
08:09:22 * MissPiggy isn't associative
08:09:27 <quicksilver> +,*,min,max are the obvious four but there are plenty more
08:09:37 * Berengal is commutative
08:09:38 <quicksilver> xor is another.
08:09:43 <mreh> lets see if we can name them all!
08:09:54 <quicksilver> bitwise or is another.
08:09:59 <quicksilver> bitwise and *isn't* (no identity)
08:10:10 <quicksilver> well actually it is for Int, I was thinking of Integer.
08:10:32 <dolio> min and max aren't for Integer, because there are no identities.
08:10:41 <dolio> But you can do min for naturals.
08:10:50 <dolio> Wait, max.
08:10:54 <quicksilver> yes :)
08:11:01 <Berengal> You can do min and max for I+
08:12:10 <Berengal> And bitwise or depends on how you define the conversion from Integer to a bitfield
08:12:26 <Entroacceptor> (N, *, 1) is even a free monoid
08:13:45 <zygoloid> Entroacceptor: is it? (N, +, 0) is the free monoid over ().
08:14:13 <quicksilver> (N, *, 1) is the free monoid over the primes
08:14:24 <mreh> what can I do with all these monoids?
08:14:25 <zygoloid> hah, lovely :)
08:14:58 <Entroacceptor> how do you construct 4 from addition over the empty set??
08:15:19 <dmwit> That's not the empty set, it's the number 0.
08:15:25 <Entroacceptor> still
08:15:26 <MissPiggy> 1 is not a prime!!
08:15:38 <Entroacceptor> oh
08:15:48 <quicksilver> MissPiggy: yes, but the identity isn't one of the generators
08:15:51 <Entroacceptor> well, 'over the primes ++ (0, 1)
08:15:59 <Berengal> dmwit: The empty set can be 0 in some definitions
08:16:02 <quicksilver> zygoloid should rather have said (N, +, 0) is the free monoid over 1
08:16:06 <Entroacceptor> does unicode have all those mathematical characters?
08:16:22 * dmwit nods at Berengal
08:16:28 <zygoloid> quicksilver: (N, *, 1) is the free commutative monoid over the primes
08:16:30 <quicksilver> and (N\{0},*,1) is the free monoid over the primes, I meant
08:16:44 <quicksilver> zygoloid: ah yes, good point
08:16:50 <quicksilver> zygoloid: N\{0}, too :)
08:16:52 <zygoloid> the types 1 and () are isomorphic; i stand by my statement :)
08:17:04 <quicksilver> generators aren't types
08:17:08 <quicksilver> generators are elements of the set.
08:17:51 <Berengal> Is GHC a set?
08:17:58 <Berengal> Because it now has a LLVM generator :)
08:18:30 <zygoloid> quicksilver: yes, but types are effectively sets (more or less)
08:18:48 <aledge> what does that mean, over the primes?
08:19:03 * hackagebot upload: ftphs 1.0.7 - FTP Client and Server Library (JohnGoerzen)
08:19:32 <zygoloid> and 'the free monoid over ()' is unambiguous anyway since the set i'm referring to by () contains only one element also called () ;-)
08:19:53 <Entroacceptor> zygoloid: I'm not convinced. :)
08:19:59 <MissPiggy> wait a second
08:20:03 <MissPiggy> what's a free moniod
08:20:09 <quicksilver> zygoloid: it's not ambigous, with reference to N
08:20:13 <MissPiggy> because I thought to be free you have to be like * -> *]
08:20:18 <aledge> the wikipedia article isn't especially illuminating :(
08:20:18 <MissPiggy> of course () is *
08:20:28 <quicksilver> zygoloid: the point about saying "over 1" is you identify the generator within the set N
08:20:44 <quicksilver> zygoloid: sure, you can work it out (there's only one choice for generator once you understand it)
08:20:56 <quicksilver> zygoloid: but it's much clearer to call the generator by the name it has.
08:21:46 <zygoloid> quicksilver: elements of the free monoid over set S are taken from set S*. {11111} isn't in N anyway. in both cases there's an implicit isomorphism
08:22:59 <Entroacceptor> damn, you lost me
08:23:32 <Entroacceptor> what is () is this context?
08:24:08 <aledge> Oh i see, (N,*,1) being a free monoid over the primes simply means that the elements of N are generated by p1*p2*p3...etc
08:24:46 <aledge> and (N,+,1) being the free monoid over 1 means that elements of N are generated by 1+1+...+1
08:24:54 <zygoloid> aledge: except that pi*pj = pj*pi so it's only the free commutative monoid
08:25:11 <aledge> zygoloid, well I haven't gotten that far in the wikipedia article yet :)
08:25:42 <aledge> so in a sense being a free commutative monoid is weaker?
08:26:28 <MissPiggy> bigger quotient
08:26:45 <MissPiggy> 4/10 is smaller/weaker than 4/5
08:26:59 <zygoloid> in one sense it's weaker, in another sense it's stronger :)
08:27:02 <aledge> hehe
08:27:08 <MissPiggy> free/associativity <= free/(associativity & symmetry)
08:27:21 <aledge> i guess what i mean it's more restrictive
08:27:36 <aledge> anywya
08:27:50 <Entroacceptor> as I'm still lost on the meaning of ()
08:27:51 <zygoloid> it has fewer distinct elements
08:27:59 <aledge> wasn't much for me to be gained by asking that question since i don't have a context to interpret strength right now
08:28:02 <aledge> lunchtime :)
08:28:19 <Entroacceptor> I'll go and hide in my hilber space with an uncountable infinite base
08:28:27 <zygoloid> Entroacceptor: i meant it in the haskellish sense of a set with exactly one element
08:28:58 <zygoloid> Entroacceptor: (N,+,0) is isomorphic to the free monoid generated by a single element
08:30:08 <Entroacceptor> mh
08:30:10 <Entroacceptor> ok
08:30:30 <Entroacceptor> then I think I understand
08:30:35 <Entroacceptor> but I gtg nonetheless
08:30:47 * Entroacceptor particles
08:42:11 <mietek> How can I regenerate /usr/lib/ghc-6.12.1/package.conf.d/package.cache?
08:43:54 <c_wraith> if it's really just a cache, it should function just fine if you remove it.  (But if you try that, just move it, rather than deleting it)
08:45:00 <mietek> I found ghc-pkg recache
08:45:28 <c_wraith> that sounds safer, if less adventurous. :)
08:47:17 <mietek> c_wraith: :)
08:54:39 <kuribas> Is there an order in which you guys write your functions in the file?  Or is it just the newest one on the bottom?
08:56:47 <zygoloid> kuribas: by size. i don't want to give ghc a hard problem until it's up to speed.
08:56:47 <Lemmih> kuribas: I usually sort them by the numerical value of the SHA1 hash of their name.
08:57:51 <zygoloid> Lemmih: i have a design for a programming language based on that principle. except the names are the SHA1 hashes of the function bodies...
08:58:14 <kuribas> Cool, so you don't have to invent new names...
08:58:34 <kuribas> Maybe I'll write an emacs mode for that.
08:58:44 <medfly> I usually try to group related functions together
08:58:48 <Lemmih> Wonderful. Even the silly answers are in stereo.
08:59:10 <xyz> FUCK YOU ALL
08:59:10 <xyz> FUCK YOU ALL
08:59:10 <xyz> FUCK YOU ALL
08:59:10 <xyz> FUCK YOU ALL
08:59:10 <xyz> FUCK YOU ALL
08:59:11 <xyz> FUCK YOU ALL
08:59:11 <xyz> FUCK YOU ALL
08:59:11 <xyz> FUCK YOU ALL
08:59:12 <xyz> FUCK YOU ALL
08:59:12 <xyz> FUCK YOU ALL
08:59:13 <xyz> FUCK YOU ALL
08:59:13 <xyz> FUCK YOU ALL
08:59:14 <xyz> FUCK YOU ALL
08:59:14 <xyz> FUCK YOU ALL
08:59:15 <zygoloid> @where ops
08:59:15 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
08:59:22 --- mode: ChanServ set +o Lemmih
08:59:23 <absentia> thank you sir, may I have another?
08:59:26 <xyz> FUCK YOU ALL
08:59:26 <xyz> FUCK YOU ALL
08:59:26 --- mode: Lemmih set +b *!*x@*.dyn.optonline.net
08:59:27 --- kick: xyz was kicked by Lemmih (xyz)
08:59:37 <medfly> it's how you say "I'm interested in monads, why don't you tell me all about them?"
08:59:38 <mreh> why wasn't he k-lined?
08:59:46 <medfly> Lemmih, I think that is an entire ISP
08:59:51 <medfly> oh, nvm
08:59:52 <medfly> right :)
09:01:01 <zygoloid> kuribas: seriously though, i try to arrange things so that earlier functions don't call later functions (so you can read the code top-down)
09:01:29 <kuribas> zygoloid: Ah, I see.
09:01:33 <zygoloid> coincidentally this does actually tend to be size ordered :)
09:01:34 <jmcarthur> i do that for libraries, but for executables i do the opposite. not sure why
09:01:55 <kuribas> zygoloid: Then you prefer "let" to "where"?
09:02:22 <chupish> yeah, other people are on that ISP Lemmih
09:02:25 <jmcarthur> actually i think i'm just inconsistent
09:02:35 <zygoloid> kuribas: actually no. i try to avoid let wherever possible :)
09:03:01 <zygoloid> i guess i'm inconsistent too :D
09:03:22 <Berengal> zygoloid: Just like untyped LC
09:04:01 <zygoloid> Berengal: yep, i deduce contradictions all the time :D
09:04:13 <gwern> er, isn't it a bad thing to ban an entire ISP?
09:04:21 --- mode: Lemmih set -b *!*@212.200.65.73
09:04:35 <Lemmih> Oops.
09:04:55 --- mode: Lemmih set -b *!*x@*.dyn.optonline.net
09:05:03 <chupish> gwern: to be fair, most of the malicious connexion attempts against my server are from other machines on dyn.optonline.net
09:05:12 <MaciejP> What package provides module Control.Exception.SomeException?
09:05:20 <quicksilver> kuribas: I usually put more 'basic' or 'fundamental' stuff at the top
09:05:37 <gwern> MaciejP: extensible-exceptions maybe?
09:05:40 <quicksilver> kuribas: so the "uses" arrows point upwards, except in the case of recursive dependencies.
09:05:48 <quicksilver> kuribas: and types at the top, or at least above the first function that uses them
09:06:40 <Berengal> Types on top, fundamentals, combinators, interesting combinations
09:06:48 <MaciejP> gwern: Nope.
09:08:19 * hackagebot upload: gtkrsync 1.0.4 - Gnome rsync progress display (JohnGoerzen)
09:09:42 <MaciejP> Even Google doesn't know.
09:10:29 <kuribas> quicksilver: I see.  I also use types on top, but I don't have a system for functions...
09:10:55 <kuribas> Top down should be a good idea.
09:12:16 <osaunders> Is it possible to define types from lists?
09:13:05 * jmcarthur is kind of excited about the llvm backend
09:13:13 <jmcarthur> it'll be nice once it's all polished and optimized
09:13:32 <osaunders> jmcarthur: How will it affect you?
09:13:35 <jmcarthur> and it's a step in the right direction for JIT and runtime code generation
09:13:52 <sm> http://hackage.haskell.org/packages/archive/regex-pcre-builtin/0.94.2.1.7.7/doc/html/Text-Regex-PCRE.html says you will need to have libpcre, from www.pcre.org, to use this module. Isn't this an error ?
09:14:03 <jmcarthur> plus i've been wanting to look into llvm, and it will be educational to see how this backend works
09:15:04 <jmcarthur> if we ever get to the point that we have JIT we can use it on partial application (perhaps automatically, but maybe more likely with a new primitive function?)
09:15:14 <Twey> sm: Isn't it a binding?
09:15:26 <sm> I thought the -builtin version was pure haskell
09:15:36 <Twey> Oh, hm
09:15:56 <sm> I'll ask the maintainer
09:18:52 <jmcarthur> we need edwardk to get on this http://pindancing.blogspot.com/2010/02/haskell-journey.html
09:19:03 <sm> come on hackage, where are you
09:20:39 <Ke> basically anything with llvm is nowadays extra awesome
09:20:53 <Janni> I don't want to complain (In fact I do), but GHC is rather dumb about certain parse errors. Like when you forget a closing parentheses it says "parse error (possibly incorrect indentation)". "missing parentheses" wouldn't be too bad...
09:21:26 * Janni is desperately trying to be upopular amongst GHC developers.
09:25:09 <jmcarthur> Ke: i don't mean to jump on a bandwagon. i just think it will be a good thing to have
09:25:23 <Ke> ;o)
09:26:01 <osaunders> jmcarthur: Does the author of http://pindancing.blogspot.com/2010/02/haskell-journey.html hang out on IRC?
09:26:19 <jmcarthur> osaunders: i have no idea
09:26:23 <nolrai_FG> I have a list of arrays and I want to sum at each index of the array, is there a zipWith for arrays? (are arrays significatly faster for smallish sizes (i.e. like 5-20 indexes)?)
09:27:07 <jmcarthur> nolrai_FG: if you want fast, try the new Vector library :D
09:27:14 <jmcarthur> and there should be a zipWith in that
09:27:18 <gwern> anyone know where bytestring lives these days? the d.h.o repo is gone, and the c.h.o says it's a redundant fork and hasn't been touched since 2007
09:27:23 <gwern> @seen dons
09:27:23 <lambdabot> Unknown command, try @list
09:27:25 <nolrai_FG> jmcarthur: which one?
09:27:27 <gwern> preflex: seen dons
09:27:28 <preflex>  dons was last seen on #haskell 3 days, 10 hours, 38 minutes and 59 seconds ago, saying: not sure if anything but demos has been written with it. frag is a famous FRP-based 3d game in haskell
09:27:33 <jmcarthur> ?hackage vector
09:27:33 <lambdabot> http://hackage.haskell.org/package/vector
09:27:43 <jmcarthur> nolrai_FG: ^^
09:28:17 <gwern> @ask dons where is bytestring's repo? the hackage package doesn't say, and the d.h.o repo is gone, and the c.h.o MOTD says it's a redundant fork and hasn't been touched since 2007
09:28:17 <lambdabot> Consider it noted.
09:28:20 <gwern> @flish
09:32:09 <burp> what library/data structure would you use for "md5 of ipv4" -> ipv4 mapping? maybe http://hackage.haskell.org/package/PerfectHash?
09:34:24 <gwern> hm. I can't help but think, as I read this JoeE paper on capability-based Java, that their logging append-only example is well-solved by haskell & monoids :)
09:35:02 <gwern> 'For instance, a JPEG decoder could implement this inter-
09:35:02 <gwern> face, interpreting the data passed to it as a JPEG image and
09:35:03 <gwern> converting the result to a bitmap to be displayed. If the plu-
09:35:03 <gwern> gin is only invoked through this interface, Joe-E guarantees
09:35:03 <gwern> the following remarkable security property: multiple invo-
09:35:05 <gwern> cations of this method will be independent, and no state can
09:35:07 <gwern> be retained or leaked from invocation to invocation.
09:35:12 <gwern> amazing!
09:40:04 <Berengal> gwern: They invented purity?
09:40:54 <lament> plu-gin sounds like a type of gin
09:41:27 <nolrai_FG> Hey I am using cabal install on windows, and it is giveing me this error "CreateDirectory: permission denied (access denied)" any idea how to tell it to put the librarys in somwhere I can create directorys?
09:41:56 <Berengal> nolrai_FG: In your cabal config
09:42:13 <Berengal> I have no idea where that lives on windows
09:42:33 <Twey> AppData\.cabal maybe
09:42:59 <Berengal> Or you could try --user...
09:43:06 <Berengal> I think
09:43:12 <Berengal> Again, no cabal-windows experience
09:43:18 <nolrai_FG> Berengal: that was with --user
09:54:50 <nolrai_FG> whats the pragma for passing a flag to ghc?
09:54:56 <Twey> OPTIONS_GHC
09:56:04 <nolrai_FG> thanks!
10:03:24 <Mitar> if a function returns IO Either ... how can i make this an exception ... so that if it is left an exception is raised and if it is right that value is returned ...
10:04:16 <Twey> val <- either id (throw whatever) <$> yourIO
10:04:35 <Twey> Er, vice versa
10:04:40 <Twey> val <- either (throw whatever) id <$> yourIO
10:04:53 <Mitar> val <- either fail id <$> yourIO
10:04:54 <Mitar> ?
10:05:26 <tARrAScH> @paste
10:05:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:05:34 <Twey> That would do it, though it's a different sort of ‘exception’
10:05:39 <zygoloid> do Right x <- yourIO; return x
10:05:42 * zygoloid ducks
10:05:50 <Twey> Yeah, that's about equivalent
10:06:19 <zygoloid> it has a worse error message
10:06:20 <Mitar> but that would return pattern match exception ;-)
10:06:22 <Ziphilt> hello everyone
10:06:31 <medfly> hey
10:06:39 <zygoloid> Mitar: you just said "an exception". how you have a preference as to which? ;-)
10:06:45 <tARrAScH> Is there anyway to un-C-ify this arbitrary if-else-code?
10:06:47 <tARrAScH> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7764#a7764
10:06:48 <Mitar> i agree ;-)
10:06:57 <Mitar> you answer is correct given my question ;-)
10:07:01 <Ziphilt> i was just wondering: "why do Haskell's True and False values have capitalization?"
10:07:24 <medfly> yes
10:07:34 <tARrAScH> I could make a datatype with 3 different good descriptiv values, but that would kinda soil my namespace, no?
10:07:41 <Mitar> <$> is lifted $?
10:07:55 <ddarius> <$> is fmap
10:08:06 <Mitar> defined where?
10:08:10 <zygoloid> tARrAScH: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7764#a7765
10:08:13 <ddarius> @hoogle (<$>)
10:08:13 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:08:36 <alexsuraci> Ziphilt: data Bool = True | False. they're just like any other type/data constructor
10:09:10 <zygoloid> alexsuraci: data Bool = False | True, so the deriving (Ord) gets them the right way around :)
10:09:19 <alexsuraci> right, right. :P
10:09:24 <tARrAScH> hmm is there any way to create a data-type inside a function and limit its scope, in the purpose I want ?
10:09:40 <tARrAScH> zygoloid: Yea, that's a quite good solution :)
10:09:45 <Mitar> hmm, why it is necessary there?
10:09:58 <Ziphilt> is the capitalization just to distinguish that they are different from other things, or something?
10:10:36 <Mitar> i was talking about <$> ... ;-)
10:10:48 <zygoloid> Mitar: "either fail id <$> yourIO" is unlikely to be what you want
10:11:00 <jmcarthur> Ziphilt: constructors must be capitalized
10:11:02 <zygoloid> "either fail return =<< yourIO" seems more likely
10:11:11 <Mitar> yes ...
10:11:13 <HugoDaniel> i need an xml parser for some heavy weight lifting, whats the fastest lib to parse xml in haskell ?
10:11:18 <zygoloid> @type either fail id <$> ?yourIO
10:11:19 <jmcarthur> Ziphilt: it's to help the parser, especially for things like pattern matching
10:11:20 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, ?yourIO::f (Either String (m a)), Functor f) => f (m a)
10:11:27 <Mitar> so: result <- either fail return =<< yourIO
10:11:27 <zygoloid> @type either fail return =<< ?yourIO
10:11:28 <lambdabot> forall (m :: * -> *) a. (Monad m, ?yourIO::m (Either String a)) => m a
10:11:49 <Ziphilt> that is interesting
10:12:15 <Ziphilt> if it is to help the machine, then i am all for typing in capitals for some things
10:12:20 <HugoDaniel> hxt, haxml, or hxml ? which of these is the fastest one ?
10:12:34 <jmcarthur> > let foo true = 0 in foo "foo"
10:12:35 <lambdabot>   0
10:12:42 <jmcarthur> > let foo True = 0 in foo "foo"
10:12:43 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:12:43 <lambdabot>         against inferred type ...
10:12:47 <jmcarthur> > let foo true = 0 in foo True
10:12:48 <lambdabot>   0
10:13:03 <jmcarthur> > let foo True = 0 in foo True
10:13:03 <lambdabot>   0
10:13:16 <zygoloid> > let foo true = 1; foo false = 0 in foo True
10:13:19 <lambdabot>   1
10:13:23 <zygoloid> > let foo true = 1; foo false = 0 in foo False
10:13:24 <lambdabot>   1
10:15:55 <mm_freak> > let 1 + 1 = 3 in 1 + 1
10:15:56 <lambdabot>   3
10:16:23 <zygoloid> > let 3 = 1; 7 = 9 in 3 + 7
10:16:24 <lambdabot>   10
10:16:35 <djahandarie> lol what
10:16:46 <mm_freak> > let 1 = 2 in 1 + 1
10:16:47 <lambdabot>   2
10:16:56 <mm_freak> that's strange
10:17:01 <zygoloid> > let True = False in 3 * 3
10:17:02 <lambdabot>   9
10:17:11 <zygoloid> > let !True = False in 3 * 3
10:17:12 <lambdabot>   * Exception: <interactive>:1:145-157: Non-exhaustive patterns in pattern bi...
10:17:18 <mm_freak> ah, ok
10:17:37 <Mitar> is it possible to print a type of a variable in haskell from haskell program?
10:17:47 <alexsuraci> zygoloid: clever girl. you had me check let 3 = 1 in ghci here. ;)
10:17:49 <mm_freak> Mitar: see Typeable
10:18:18 <mm_freak> Mitar: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Typeable.html
10:18:26 <Mitar> thanks
10:19:24 <Mitar> aha, so show of typeOf
10:20:28 <mm_freak> > show $ typeOf (^2)
10:20:29 <lambdabot>   "Integer -> Integer"
10:27:07 <Mitar> hpaste is down?
10:27:15 <medfly> :t typeOf
10:27:16 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:27:18 <medfly> codepad / moonpatio.org
10:28:56 <Mitar> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=7771#a7771 << how can i fix this type error?
10:30:45 <medfly> maybe put parens around the second bit of the either
10:30:51 <medfly> parameter?
10:33:50 <Saizan> Mitar: what's the type of importFile?
10:34:26 <Saizan> Mitar: oh, i think you've to add a type annotation to specify the type of the elements.
10:35:53 <Saizan> e.g. wave <- either fail return =<< importFile filename :: IO (DiffUArray Double)
10:36:02 <ceii> no
10:36:26 <Saizan> substituting the right type instead of Double (and possibily IO)
10:36:37 <ceii> it's not directly an array
10:37:00 <ceii> you need an IO (Audio something)
10:37:06 <ceii> but apart from that this is right
10:37:22 <ceii> I have no idea what the type parameter for Audio means, though
10:37:38 <Saizan> the type annotation would apply to the whole  "either fail return =<< importFile filename", btw
10:37:50 <HugoDaniel> ok, ill use hexpat
10:37:53 <aavogt> can unfoldr be written in terms of foldr?
10:38:29 <Botje> what would be the role of the list you feed to foldr?
10:38:53 <aavogt> it's a HList
10:39:03 <aavogt> and I would like to reuse hFoldr
10:39:28 <lispy> aavogt: well, one is a reducer and the other is a generator
10:39:30 <aavogt> I am building a HList out of a regular list
10:39:44 <lispy> aavogt: so rewriting unfoldr in terms of foldr is going to look funny :)
10:40:00 <aavogt> so I can either start with a 100% undefined HList
10:40:08 <aavogt> or I can build one from HNil
10:40:19 <lispy> :t unfoldr
10:40:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:40:34 <lispy> ?src unfoldr
10:40:35 <lambdabot> unfoldr f b  = case f b of
10:40:35 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
10:40:35 <lambdabot>    Nothing        -> []
10:41:06 <Saizan> i'm not sure if hFoldr is lazy enough to work over an undefined HList
10:41:11 <Saizan> that would work
10:42:10 <aavogt> actually hMap should be enough
10:42:35 <aavogt> my input can be a parameter to the function I'm hMapping over an increasingly defined HList
10:46:33 * Saizan thinks this would be much nicer using a gadt to express the types contained in the HList
10:47:00 <Saizan> which you could generate from the type with a typeclass method
10:47:48 <Saizan> it wouldn't give _so_ much information actually, but you could recurse over it for cases like this
10:48:41 <MissPiggy> yeah GADT is much better, I never use HList
10:49:04 <MissPiggy>  of course GADT is just a (really cool) hack  taht approximates something else
10:56:15 <Pete1> hi, I have a GADT that is a monad. Rep a where a must be in the Show class.
10:56:21 <Pete1> ﻿I can declare that it should be in the show class for individual functions but not for the monad functions (>>=) and (return).
10:57:04 <Pete1> How are you supposed to do it?
10:57:27 <lament> instance (Show a) => Monad Rep a where
10:57:33 <Saizan> won't work.
10:58:05 <Saizan> Pete1: see the rmonad package on hackage, it's not seamless as one would like, but it's probably the best solution available
10:58:21 <aavogt> @src sequence
10:58:22 <lambdabot> sequence []     = return []
10:58:22 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:58:22 <lambdabot> --OR
10:58:22 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:59:47 <Pete1> ﻿Saizan: it's a school assignment so I don't think we are supposed to use rmonad
11:00:05 <m0nkfish> is sequence equivalent to:
11:00:06 <m0nkfish> sequence xss = [x | xs <- xss, x <- xs]
11:00:07 <m0nkfish> ?
11:01:22 <Saizan> Pete1: well, you can look at it for insipiration
11:01:42 <Saizan> Pete1: or rework your design so that you don't need the Show constraint for >>= and return
11:01:58 <dolio> What does Rep look like?
11:03:27 <doserj> m0nkfish: now. that is just concat (== join in the list monad). sequence in the list monad gives the cartesian product
11:03:32 <HugoDaniel> bye
11:03:44 <m0nkfish> doserj, sorry what is the cartesian product?
11:03:58 <doserj> > sequence [[1,2],[3,4]]
11:03:58 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
11:04:10 <Zao> m0nkfish: All elements in the first set paired with all elements in the second.
11:04:17 <m0nkfish> oh right, cool
11:04:34 <m0nkfish> > sequence [[1,2],[3,4],[5,6]]
11:04:35 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
11:19:31 <iFire> Is it viable to use haskell to prototype a udp protocol? ideally it should output to c
11:19:42 <iFire> What libraries are useful?
11:22:51 <opqdonut> sure it is viable
11:23:28 <opqdonut> there's Networ.BSD, Network.Socket for low level stuff
11:23:47 <opqdonut> Data.Binary has serialisation, but there are other options too
11:24:08 <opqdonut> there's a ton of packages on hackage: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:network
11:27:26 <iFire> opqdonut what about outputting to c
11:29:50 <opqdonut> iFire: do you mean generating c code?
11:29:51 <Smeden> Is there any one using the "Chart" package?
11:29:56 <iFire> opqdonut yes
11:30:12 <iFire> for example in use for a executable
11:30:35 <pikhq> iFire: Do you actually mean generating C code, or do you mean creating an executable?
11:30:44 <pikhq> Or do you mean creating functions callable from C?
11:30:58 <iFire> pikhq I mean interfacing with c++/c code system
11:31:09 <pikhq> iFire: In what way?
11:31:15 <Berengal> It has a pretty good FFI
11:31:18 <opqdonut> (if you really want to generate c: http://hackage.haskell.org/package/language-c )
11:32:05 <iFire> I have a c++ library I want it to call an haskell udp library for communication
11:32:14 <iFire> opqdonut I'll check that out
11:32:23 <Zao> opqdonut: A crash course in syb helps if you're to use that.
11:32:55 <opqdonut> haven't used it personally
11:32:55 <bolmar> @hoogle m a -> m b -> m (a b)
11:32:57 <lambdabot> Text.ParserCombinators.ReadP endBy :: ReadP a -> ReadP sep -> ReadP [a]
11:32:57 <lambdabot> Text.ParserCombinators.ReadP endBy1 :: ReadP a -> ReadP sep -> ReadP [a]
11:32:57 <lambdabot> Text.ParserCombinators.ReadP sepBy :: ReadP a -> ReadP sep -> ReadP [a]
11:33:03 <Berengal> Isn't foreign export good enough if you want c-callable functions?
11:33:09 <MissPiggy> :t undefined :: m a -> m b -> m (a b)
11:33:10 <opqdonut> bolmar: that's not a valid type...
11:33:10 <lambdabot>     `b' is not applied to enough type arguments
11:33:11 <lambdabot>     Expected kind `k', but `b' has kind `k -> k1'
11:33:11 <lambdabot>     In the type `a b'
11:33:20 <opqdonut> ^ see that error
11:33:22 * Berengal never tried to export any c functions
11:33:30 <Berengal> *haskell functions to c
11:33:44 <bolmar> oops
11:33:57 <Zao> Language.C is mostly for parsing/analyzing/generating C code.
11:34:47 <iFire> Berengal I'll look into ffi
11:34:56 <iFire> how portable is ffi?
11:35:01 <opqdonut> Zao: it was unclear whether he wanted code generation or just linking
11:35:19 <iFire> opqdonut O
11:35:26 <iFire> I'm not sure which one I want
11:35:44 <opqdonut> i'd say start with ffi, generating code is a hassle
11:38:22 <Zao> opqdonut: It's a lovely library, albeit slightly hard to query the resulting structure.
11:44:19 <Gracenotes> Zao: C structs are really just offsets. Except not nice ones the compiler calculates.
11:44:53 <Gracenotes> struct { int x; double y; }.. what is y's byte offset? dunno.
11:45:08 <Gracenotes> It'd be nice of GHC hooked into this somehow
11:45:10 <Gracenotes> *if
11:48:28 <MissPiggy> offsetof
11:48:53 <freiksenet> hello! I am a bit confused on how to convert heavily imperative algorithms to functional ones. For example I was trying to implement negascout algorithm and I even found existing haskell solution, but I was quite taken aback by it's complexity and, frankly, ugliness. I wonder if there is a better way to do stuff like that. http://hackage.haskell.org/packages/archive/game-tree/0.1.0.0/doc/html/src/Data-Tree-Game_tree-Negascout.html
11:49:16 <Zao> #starttype OMG  #field x, int  #field y, double  #stoptype   -- bindings-DSL
11:50:44 <Berengal> iFire: Just tried out the exporting of function, and a main in C. Worked very nicely
11:51:24 <freiksenet> also I have problems with functions that need to keep track of state of something AND have several recursion paths, eg flood fill
11:51:41 <Zao> Berengal: Don't you have to call some hs_init_whatnot function?
11:51:51 <freiksenet> I thought that I did make it work, but after some debugging it seems that it's not really working :/
11:52:00 <Berengal> Zao: Yeah, just hs_init(&argc, &argv) on top of main
11:56:37 <Twey> Help!  Can anybody figure out why my HXT pickler isn't working?  http://paste.lisp.org/display/95273
11:56:52 <Twey> It parses the RSS okay, but returns an empty list for the channels
11:57:52 <MissPiggy> differentials are tensors O_O
12:01:43 <Berengal> MissPiggy: Maybe they should relaxors?
12:03:32 <MissPiggy> lol
12:07:10 <Zeiris> So I want to generate a lot of random numbers, modify a lot of unboxed arrays, and probably interface to time functions. The last requires an IO monad, but the first two can be done with a State right?
12:08:32 <Berengal> Zeiris: Techincally, yes
12:08:37 <BONUS> you probably want ST for modifying unboxed arrays
12:08:52 * hackagebot upload: RSA 1.0.3 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1. (AdamWick)
12:09:14 <Berengal> Zeiris: For random numbers State is fine, but if you're modifying arrays in State you'll be doing alot of copying. As BONUS said, you probably want ST mutable arrays
12:09:44 <Berengal> Zeiris: And only some time functions require IO (getCurrentTime being one)
12:10:29 <Zeiris> How do I tell if an array is mutable unboxed? :(    :: STMUArray?
12:10:56 <opqdonut> are you sure you want an array and not a IntMap
12:11:11 <opqdonut> IntMaps perform often really well when compared to arrays
12:11:14 <Zeiris> Does IntMap allow me to define my own order and have repeats?
12:11:31 <Zeiris> (I'm representing a 2D array of bools/ints as a 1D array. Game board.)
12:11:55 <opqdonut> IntMap let's you have arbitrary mappings Int->sometype
12:12:26 <opqdonut> you can perfectly well "emulate" an array with an Int index with an IntMap
12:12:46 <Zeiris> Are they mutable and continuous in memory?
12:13:18 <opqdonut> not continuous, why would you need that?
12:13:31 <opqdonut> they have a persistent update operation which is pretty efficient
12:13:33 <Zeiris> Um. Well I don't need it but it certainly would make me feel better.
12:13:40 <opqdonut> cache performance?
12:13:54 <Zeiris> I can see the C code to do this in my head, I'd like to believe that Haskell is doing something similar and equally efficient :(
12:14:00 <opqdonut> bah
12:14:09 <opqdonut> try out the IntMap :)
12:14:12 <Zeiris> Rather than holding a hashmap of integers and doing lookups every time I just want arr[n].
12:14:19 <opqdonut> it's not a hash-map
12:14:48 <opqdonut> it's a tree-based structure
12:14:50 <BONUS> imo you're thinking about performance too early
12:14:58 <Berengal> In my experience, Haskell is either doing something similar to C but much less efficient, or it's doing something entirely different from C but equally efficient
12:15:00 <opqdonut> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-IntMap.html
12:15:14 <opqdonut> anyway, how big is your board?
12:15:51 <opqdonut> with (only) thousands of locations you wont get a significant performance boost from using arrays
12:16:08 <Zeiris> Up to 50*50, so tiny, really.
12:16:12 <opqdonut> yepp
12:16:21 <opqdonut> you could even use a Map (Int,Int)
12:16:31 <opqdonut> at first
12:16:34 <Zeiris> The hint of high level data types fills me with fear and mistrust :(
12:16:35 <opqdonut> to make the code simpler
12:16:53 <opqdonut> why? the guys who implemented them are way better coders than you :)
12:16:56 <MissPiggy> Zeiris because they are abstract?
12:17:00 <Zeiris> It's simple enough that I can practically see the assembler in my head as it is. The only problem is getting the compiler to agree with me :p
12:17:35 <opqdonut> the way you can get some benefit from using haskell is using the abstractions it gives
12:17:54 <opqdonut> of course you can throw around CPtrs in the IO monad, but what's the point?
12:18:35 <CosmicRay> opqdonut: you are nostalgic for SIGSEGV?
12:19:38 <DrTeggy> Who is Guy Taylor and why does he hate Haskell?
12:19:41 <DrTeggy> :-)
12:19:56 <iFire> know any good imperative to function guides? I'm learning to making a udp protocol in haskell.
12:20:50 <Gracenotes> well, there is inevitably going to be a sequential imperative reading of packets through an IP socket interface
12:20:54 <DrTeggy> www.ihatehaskell.com
12:21:00 <medfly> lol
12:21:06 <medfly> that's a funny domain to buy
12:21:20 <DrTeggy> To buy and to actually operate.
12:21:21 <Berengal> Means we're too successful :(
12:21:45 <medfly> DrTeggy, is it you? it looks like it was created recently.
12:21:48 <Gracenotes> well, I thought it might be about some local football team named Haskell or something, but the airplane logo does not lie
12:22:02 <MissPiggy>  Default_profile_6_normal   TheBiggerGuycom  #IHateHaskell  WTF x+1 is not a int when x is a int !!! WTF is 1 then!
12:22:06 <MissPiggy> ^ what?
12:22:23 <DrTeggy> medfly, sorry?  This Guy guy is not me.
12:22:38 <Gracenotes> MissPiggy: his logic is bottoming out
12:22:50 <Gracenotes> you could say his definition was loopy
12:23:18 <medfly> @type \x->x + (1 :: Int)
12:23:19 <lambdabot> Int -> Int
12:23:19 <Berengal> WTF x + 1 is obviously of type WTF
12:23:21 <Gracenotes> I'll just stick with WTF
12:23:31 <DrTeggy> hehe
12:23:34 <Berengal> WTF must be an instance of Num, of course
12:24:12 <medfly> what is he talking about with that? :)
12:25:02 <Berengal> Oh, and he must be using some alternative prelude where (+) :: (Num a, Num b) => a -> b -> AddResult a b, and AddResult is a type family
12:25:22 <Berengal> Or something...
12:25:30 * Berengal feels he added a bit too many assumptions
12:25:41 <medfly> HASKELL SUCKS! it can't do <my problem>!
12:25:48 <medfly> ^ how to get answers very easily.
12:27:12 <Berengal> medfly: Your problem is simply an epimorphism in a category of commutative monoids
12:27:21 <medfly> :(
12:27:45 <Berengal> ^ How to learn mathematics
12:27:45 <medfly> Berengal, wtf is an epimorphism in a category of commutative monoids, Haskell sucks so much it can't even explain things simply!
12:29:04 <medfly> seriously, what is it?
12:29:06 <mreh> Hate is a strong word
12:29:11 <Berengal> medfly: Well, assume you have a type ¢ and a type Ħ, then ¢ → Ħ → solution
12:29:45 <Zeiris> Is there some interact equivalent for functions like (String -> IO String)?
12:30:06 <mreh> (return .)
12:30:10 <Heffalump> Zeiris: it'd be a bit odd, because the IO could work with stdin/stdout
12:30:14 <medfly> @hoogle a -> IO a
12:30:15 <lambdabot> Control.Exception evaluate :: a -> IO a
12:30:15 <lambdabot> Control.OldException evaluate :: a -> IO a
12:30:15 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
12:30:17 <RayNbow> @quote byorgey learn
12:30:17 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
12:30:17 <lambdabot> like learn $ zip math haskell.
12:30:22 <medfly> oooh.
12:30:39 <Zeiris> Good point Heffalump  :(
12:30:53 <Heffalump> @src interact
12:30:53 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:31:00 <Heffalump> obviously you could write your own though
12:31:02 <medfly> @type return
12:31:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:31:18 * ksf wants postfix type operators
12:31:29 <ksf> specifically, type a? = Maybe a
12:31:33 <Heffalump> medfly/mreh: I believe Zeiris wants something like interact, but of type (String -> IO String) -> IO () instead of (String -> String) -> IO ()
12:31:38 <RayNbow> > let (!) n = product [1..n]   in  (10!)
12:31:39 <lambdabot>   3628800
12:31:47 <RayNbow> ^ like this, ksf?
12:31:53 <mauke> RayNbow: TYPE OPERATORS
12:31:54 <RayNbow> oh wait
12:32:40 <RayNbow> mauke: yeah, I noticed the word "type" after I hit enter :p
12:32:57 <medfly> RayNbow, you noticed the word type after you type
12:32:59 <medfly> d
12:32:59 * Janni wants a ? pattern as new syntactic sugar. f x ? z === \y -> f x y z.   discr = case ? of ...
12:33:04 <Berengal> I want more relaxed grammar
12:33:21 <Berengal> Let the operatorness be defined at the definition, not by which symbols are used
12:34:42 <Heffalump> Berengal: people who have to read your code might prefer a stricter grammar :-)
12:34:54 <Berengal> type _? a = Maybe a; _defaulting-to_ :: a? -> a -> a; Nothing defaulting-to y = y; (Just x) defaulting-to y = x
12:35:05 <Berengal> Heffalump: No, they just want a better editor
12:35:14 <MissPiggy> hypothetical 'code readers' are annoying because nobody reads my code
12:35:24 <opqdonut> not even you?
12:35:29 <medfly> hehe
12:35:31 <medfly> "never!"
12:35:31 <mreh> opqdonut, got there first
12:35:39 <ksf> ...and I don't want to use parens.
12:35:52 <Berengal> I like to think that GHC reads my code, and therefore the Simons do too, indirectly
12:35:59 <ksf> we have infixr and infixl, why not postfix and prefix?
12:36:12 <mreh> function application is prefix
12:36:13 <Berengal> mixfix!
12:36:21 * ksf applauds Berengal 
12:36:28 <aledge> randfix
12:36:36 <ksf> though I don't like agdas spacing rules
12:36:46 <Janni> aledge: lol
12:37:02 <Berengal> ksf: They're a price I'm more than willing to pay for the otherwise awesome grammar
12:37:10 <ksf> ...allowing [ [ 1 + 2 ] + 3 ] but not [[1+2]+3]
12:37:25 <Berengal> ksf: Besides, I like spaces.
12:38:04 <ksf> ...but I don't want to have ) ) ) ) ) ) ). I don't want to see it, and I don't want to type it.
12:38:08 <mreh> I think the answer may lie in how parsers work
12:38:18 * Berengal wonders if there's room for custom sequence syntax in agda's syntax as well
12:38:21 <kw317> is there a way to define some new brackets in haskell? suppose I want something like (| x |).. can I do that?
12:38:29 <OscarZ> generally speaking, what other benefits are there in using a functional language than avoiding the world of pain caused by internal state ?
12:38:36 <opqdonut> kw317: no, not really
12:38:43 <ksf> mreh, it's an ambiguity thing. there could be a ((_)) operator, so the (_) operator has to have spaces...
12:38:45 <Heffalump> OscarZ: higher-order functions, algebraic datatypes
12:38:53 <mreh> OscarZ: girls love it
12:38:53 <opqdonut> kw317: you can do a hack that uses two matching infix operations, like <^ and ^>
12:38:54 <Berengal> Coq has it, but I don't really know coq's syntax
12:38:57 <opqdonut> kw317: see:
12:39:06 <opqdonut> > Just 1 <^(+)^> Just 2
12:39:08 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
12:39:14 <ksf> but I very much think making all kind of parens and | special case would be worth the bother.
12:39:15 <opqdonut> oh, they're not here
12:39:35 <OscarZ> Heffalump: what do you mean by "algebraic datatypes", can you give some practical example ?
12:39:40 <opqdonut> anyway that would've been Just 3, x <^ f ^> y is equivalent to liftA2 f x y
12:40:18 <Heffalump> OscarZ: data Foo = Foo1 Int | Foo2 Char
12:40:20 <kw317> OscarZ: essentially haskell's datatypes are made of products, disjoint unions, tuples, constants
12:40:24 <ksf> OscarZ, avoiding the infinite pain of having to go to length to express a slightly more convoluted data dependency
12:40:26 <Heffalump> well, that's not practical :-)
12:40:29 <kw317> OscarZ: and hence the name algebraic
12:40:36 <Berengal> ksf: Or all (open-paren-symbol symbol*) and (close-paren-symbol symbol*) productions
12:40:42 <ksf> (I happen to have an example ready)
12:40:46 <kw317> OscarZ: in practice, it's just a nice way of writing a datatype :)
12:40:52 <ksf> pArgs =  pParen (flip ($) <$> pListSep (pTok ',') (pArg False)
12:40:52 <ksf>                                   <*> (flip VarArgs <$> (pTok ',' *> pArg True)
12:40:52 <ksf>                                                     <|> pure Args))
12:41:04 <Toxaris> Berengal: Coq has very flexible syntax with the notations mechanism. you can essentially make it recognize the kind of math notation on writes in emails.
12:41:28 <Toxaris> I'm not sure why something like this is not adopted in programming-centric programming languages.
12:41:41 <OscarZ> kw317: interesting, im not a math guy myself but if it were not defined like that, what "wormholes" would that leave in the typing system of a language ?
12:41:45 <Berengal> Toxaris: Neat. Also, I believe all programming languages are programming-centric...
12:41:53 <ksf> ...depending on whether there's an argument that has "..." in it, two different constructors are returned, which is then applied to the rest of the arguments
12:41:59 <Toxaris> Berengal: Well, Coq is a theorem-proving-centric programming language
12:42:12 <MissPiggy> even though Coq has good notation system I still find some things I write terribly verbose
12:42:20 <kw317> OscarZ: I'm not sure if I understand the question
12:42:21 <MissPiggy> I suppose it is my own inexperience though
12:42:32 <Berengal> Toxaris: I guess that's a valid classification
12:42:36 <kw317> MissPiggy: if you want some concise language try Q ;-)
12:42:39 <Twey> Help!  Can anybody figure out why my HXT pickler isn't working?  http://paste.lisp.org/display/95273  It parses the RSS okay, but returns an empty list for the channels
12:42:51 <ksf> ...I noticed that I need to fiddle data and stuff in strange patterns, and haskell readily supported it. in any other language I know I'd have to go to lengths to do the same.
12:42:54 <kw317> for what it's good for, Q is the most concise language I have ever seen
12:42:59 <MissPiggy> kw317 is that the rewrite language?
12:43:12 <MissPiggy> or some APL based thing?
12:43:17 <kw317> MissPiggy: nope, that's a language / query language for kdb+
12:43:21 <kw317> MissPiggy: in some sense yes
12:43:38 * MissPiggy has a look at Q Language Primer
12:43:51 <kw317> MissPiggy: you could argue the chain of descendance APL -> A+ -> K -> Q
12:44:01 <MissPiggy> where does J fit into that?
12:44:10 * MissPiggy only really ever used J...
12:44:13 <kw317> some fork along the road
12:44:36 <kw317> I think J is forked K
12:44:53 <Zeiris> @src interact
12:44:54 <lambdabot> interact f = do s <- getContents; putStr (f s)
12:45:13 <FCo> Hi guys, hpaste.org seems to be down
12:45:21 <medfly> codepad.org or moonpatio.org
12:45:27 <Berengal> @paste
12:45:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:45:30 <kw317> ix.io
12:45:48 <OscarZ> kw317: i mean that you summaried your statement about products, disjoint unions, etc... and said thats a nice thing. I was just wondering why are these such good properties for a typing system .. and what would be bad choices causing trouble? (they must exist in the various programming languages alive and dead today)
12:45:48 <FCo> thx!
12:46:42 <Zeiris> Why does interact' f = do s<- getContents; o <- f s; putStr o freeze up?
12:46:42 <kw317> OscarZ: well, I didn't say why it's good, I only attempted to explain where the somewhat odd (at first) name comes from
12:47:07 <kw317> OscarZ: why this stuff is good is a long story, and I'm still learning it ;-)
12:47:21 <OscarZ> ok..
12:47:32 <kw317> OscarZ: but for practial purposes, it's just a nice way of declaring datatypes
12:47:35 <dolio> I think "algebraic" might come from the fact that datatypes are initial algebras.
12:47:35 <OscarZ> i dont mean to challenge what you but to learn ..
12:47:48 <dolio> (And/or terminal coalgebras)
12:47:55 <kw317> dolio: well, that as well
12:47:56 <FCo> I want to have a monad that logs several steps of a transformation, I came out with some code like this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7773#a7773 but it seems I can not constrain the type to be a member from Show, how do I do this?
12:48:10 <kw317> hmm.. speaking of this
12:48:18 <MissPiggy> FCo don't constrain anything
12:48:19 <kw317> why there is no difference between data and codata in haskell?
12:48:26 <MissPiggy> FCo it will be inferred
12:48:43 <MissPiggy> delete this: Show a =>
12:48:55 <nolrai_FG> Are you useing Writer?
12:49:13 <MissPiggy> if you write a function that needs show, that will have the constaint
12:49:19 <OscarZ> dolio: what is the fundamental difference vs. the typing system of say Java or other mainstream imperative languages ?
12:49:21 <FCo> MisPiggy, it won't work
12:49:37 <FCo> MisPiggy, it won't work because then I'll need to add that to the type of return
12:49:54 <kw317> dolio: I wouldn't say that datatypes _are_, but rather that _are modelled_
12:50:25 <FCo> I am not using Writer, but I don't want to log a message, I want to log the result of the transformation "automagically"
12:51:08 <kw317> OscarZ: expressive power perhaps, compared to Haskell's, Java's type system is a toy
12:51:39 <MissPiggy> FCo: no you don't have to add it to return
12:51:54 <kw317> OscarZ: also Java type system is not static -- you have dynamic type checks in the presence of downcasts
12:51:59 <Toxaris> OscarZ: One high-level difference is that an OO type system is about which methods you can call on objects, and algebraic datatypes are about which form a value has. So in Java, if you get some object, you can ask it to do things, and in Haskell, if you get same value, you can destruct it into pieces.
12:52:22 <nolrai_FG> FCo: I think you need to use resticted monads, its a library on hackage. Maybe, i'm new to this stuff too.
12:52:23 <FCo> MissPiggy: I just deleted the Show declaration, and ghc told me to add Show to the type of return :(
12:53:16 <OscarZ> Toxaris: thanks, thats exactly the "type" of answer i was looking for ;) I need to think about that
12:53:20 * FCo is googling restricted monads
12:53:21 <MissPiggy> FCo, it is impossible to do this with Monad
12:53:24 <MissPiggy> FCo, yes
12:54:58 <nolrai_FG> FCo: also your version breaks the monad laws. I don't know how bad that is.
12:55:11 <Heffalump> FCo: http://hackage.haskell.org/package/rmonad is one way of doing restricted monads
12:56:07 <dolio> kw317: More or less, for the category of haskell types and functions (or categories that could serve as semantic models, or what have you), initial algebras are also terminal coalgebras (and vice versa).
12:56:25 <dolio> Due to, or giving rise to general recursion.
12:56:31 <FCo> wow, thx, restricted monads seem to be a bit of black magic right now, I will look into that, or I will use writer monad and i will log manually each step :P
12:56:32 <Toxaris> kw317: What would be the point of distinguishing data and codata in Haskell? Would you like to go all the way and disallow non-termination for recursive functions resp. disallow non-productiveness for co-recursive functions?
12:56:59 <Heffalump> you should certainly be dubious of writing a monad that breaks the laws, though
12:57:21 <Heffalump> though actually, if you elided adjacent duplicates, I don't think your monad would actually break the laws
12:57:29 <nolrai_FG> Toxarisu: it would be nice to be able to at points. Though if you do you have a non-turng languge so..
12:57:30 <badsheepy> a monad is born free, but everwhere in chains :(
12:57:34 <Heffalump> so you could either explicitly do that, or just accept that adjacent duplicates are ignorable and not worry about it
12:57:42 <nolrai_FG> Toxaris: it would be nice to be able to at points. Though if you do you have a non-turng languge so..
12:58:46 <dolio> I'm not really sure what your distinction of "are" vs. "are modelled" is. "data Foo = ..." is essentially a declaration "Foo is an initial F-algebra", F being determined by the "..." in some way.
12:58:50 <FCo> sorry, elide the adjacent duplicates? I don't get that
12:59:25 <Heffalump> FCo: treat ["foo", "bar", "bar", "baz"] as equivalent to ["foo", "bar", "baz"]
12:59:25 <dolio> Assuming we're thinking about Haskell in terms of some categorical semantics.
13:00:44 <Zeiris> Why does going from String to IO String and interact to interact' stop producing output? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7775#a7775
13:00:57 <FCo> ah ok, thx, you've convinced me, I will the use Writer monad :P
13:01:06 <FCo> otherwise I won't ever finish
13:01:23 <Zeiris> @src interact
13:01:23 <lambdabot> interact f = do s <- getContents; putStr (f s)
13:02:07 <Berengal> Zeiris: What does your interact' look like?
13:02:21 <Berengal> (getContents >>=), I hope
13:02:23 <Zeiris> do input <- getContents; f input >>= putStr
13:03:10 <Berengal> Zeiris: Ah, well, IO is strict, so it won't print the string until f has returned
13:03:15 <OscarZ> What kind of relationship Haskell has with the concept of time ?
13:03:20 <Zeiris> Oh. Welp.
13:03:57 <dolio> kw317: If you start from a more traditional domain theoretic semantics perspective, all types contain _|_, and data types also contain partially defined elements built out of _|_ and constructors, as well as some sort of limits/upper bounds/whatever of sequences of those partially defined  elements, I guess, which is kind of a general sketch of how initial algebras can also be terminal coalgebras.
13:04:03 <lament> Haskell is a timeless classic of programming language design
13:04:15 <Berengal> Zeiris: The way around this is liberal use of unsafeInterleaveIO. It's not enough to just use it on your f, because once f's output is forced it'll still block inside f
13:04:16 <dolio> But I don't really know that much about that area.
13:04:18 <lament> (also, see the IO monad)
13:04:21 <Berengal> Zeiris: In other words, it's a bad idea.
13:04:23 <Heffalump> Zeiris: you can use lazy IO, I think
13:04:44 <Heffalump> interact' f = do s <- getContents ; res <- unsafeInterleaveIO (f s) ; putStr res
13:04:55 <Heffalump> whether this is safe or not depends entirely on what 'f' gets up to
13:04:56 <Zeiris> I think I can split the output by lines, and putStr each line.
13:05:04 <Zeiris> Err, *map putStr to each line
13:05:23 <Berengal> Heffalump: Won't make a difference, because putStr forces res at once, entering f and blocking until it returns
13:05:38 <djahandarie> Man I just sat in on a seminar about linear programming and constraint-based programming and my mind was blown
13:05:40 <Zeiris> Oh.
13:05:41 <Berengal> Heffalump: Which is why you need lots of unsafeInterleaveIOs inside f as well, for all f
13:06:05 <Heffalump> Berengal: oh, duh
13:06:44 <Zeiris> Good god something this simple should not be this complex :(
13:06:48 <Toxaris> So one needs UnsafeInterleaveT IO instead of IO, where MonadIO of UnsafeInterleaveT calls unsafeInterleaveIO in liftIO?
13:07:04 <Berengal> Zeiris: A sign you're Doing It Wrong (tm)
13:07:07 <Toxaris> which sounds somewhat unsafe.
13:07:26 <Toxaris> hmm, no, not in liftIO, but somehow in >>=.
13:08:08 <Toxaris> Zeiris: hint: interact is bad. You should now rely on laziness that deeply for the overall correctness of your program.
13:08:13 <Heffalump> Zeiris: why do you think it's simple?
13:08:16 <Toxaris> s/now/not
13:08:22 <FCo> let's suppose that instead of Show a, i want to accumulate the a's with no restriction, is it possible (something in the spirit of http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7773#a7777)
13:08:40 <dolio> kw317: I'm not really sure how to flip that around and show that terminal coalgebras are also initial algebras for a suitable category of domains.
13:08:47 <Zeiris> Well, I've never had this much trouble getting some lines from stdin and printing them to stdout, ever, in any language.
13:08:48 <Heffalump> FCo: no, because the types don't match
13:08:57 <Zeiris> Except maybe javascript.
13:09:02 <Heffalump> FCo: you could use an existential, but then you wouldn't be able to do much with the stuff in the result list
13:09:12 <Heffalump> Zeiris: why don't you just use normal IO instead of interact?
13:09:35 <Zeiris> Well, because the code was written with interact in mind and I guess that was a really, really, really bad idea :[
13:10:06 <osaunders> Whoa, Haskell news: http://www.haskell.org/pipermail/cvs-ghc/2010-February/052606.html
13:11:28 <FCo> :( thank you Heffalump
13:13:24 <RayNbow> @google "most beautiful monad"
13:13:25 <lambdabot> No Result Found.
13:14:07 <opqdonut> the backwards state monad!
13:14:11 <sm> would anyone know why I can't seem to capture stdout and stderr output from runghc ?
13:14:23 <RayNbow> opqdonut: that one still blows my mind
13:14:35 <sm> if I run it, i see it on the console, but if I redirect it into a file, I get nothing
13:15:01 <osaunders> sm: How are you redirecting?
13:15:27 * hackagebot upload: HaskellForMaths 0.2.1 - Combinatorics, group theory, commutative algebra, non-commutative algebra (DavidAmos)
13:15:27 * RayNbow personally likes the vector space monad sigfpe blogged about
13:15:43 <sm> osaunders: eg, /opt/local/lib/ghc-6.10.4/runghc -f/opt/local/bin/ghc shelltestrunner.hs >t 2>&1
13:15:57 <sm> or runhaskell shelltestrunner.hs >t 2>&1
13:16:06 <djahandarie> Didn't the Utretch Haskell Compiler also do LLVM Code Generator?
13:16:19 <MissPiggy> yes you are right djahandarie
13:16:54 <osaunders> sm: Maybe you can't do that.
13:17:17 <sm> it's a bit broken
13:17:27 <osaunders> I'm not sure about >t 2>&1
13:19:15 <roconnor> comonoids are really boring in cartesian categories.
13:19:33 <osaunders> sm: Wait you're basically copying the example in man bash character for character.
13:20:01 <sm> it's standard bash.. works with all normal commands, but not with runhaskell/runghc
13:20:03 <osaunders> ls > dirlist 2>&1 directs both standard output and standard error to the file dirlist
13:20:46 * osaunders doesn't have the answer.
13:23:15 <sm> could someone with 6.12 possibly confirm this ? runhaskell some.hs >t  <- t should contain the output
13:23:38 <sm> otherwise, I will file the bug
13:23:56 <Heffalump> sm: any particular some.hs ?
13:24:05 <sm> anything that prints output
13:24:08 <sm> on stdout
13:24:53 <osaunders> http://codepad.org/iELCod22
13:25:09 <Heffalump> sm: works fine for me on 6.12.1
13:25:28 <osaunders> That's runghc 6.10.4
13:25:32 <osaunders> ... for mine.
13:25:53 <sm> thank you both.. and wait.. it does work here with a simpler some.hs
13:29:07 <BONUS> if runhaskell some.hs prints output to the standard output and runhaskell some.hs > t doesn't write to the file, then the culprit seems to be your shell or whatever
13:29:10 <BONUS> at first glance
13:30:14 <Vulpyne> Try runhaskell blah.hs > t 2>&1
13:30:17 <Vulpyne> Assuming bash.
13:30:21 <sm> it's triggered by my use of cmdargs I feel.. narrowing it down
13:30:30 <Vulpyne> Maybe it is writing to stderr.
13:32:14 <sm> no, it's triggered by calling test-framework's defaultMain. Both stdout and stderr are affected
13:35:27 <sm> wait.. that is weird
13:39:46 <osaunders> In algebra what is a model?
13:40:16 <nolrai_FG> How do I tell ghci where I installed my libraries?
13:42:05 <MissPiggy> osaunders, model would be a set and an interpretation -- that turns your syntax into an element of the model
13:42:39 <MissPiggy> osaunders, like a model of say "group theory" could just be some arbitrary group (not a very interesting one)
13:43:16 <Berengal> nolrai_FG: -package-conf <file>
13:43:39 <MissPiggy> osaunders, one interesting use of models it transforming them, you can enlarge a model of the real numbers to make non-standard reals -- which satisfy all the same first order theorems (on internal sets), but they also have infinite and infintesimal elements
13:43:43 <osaunders> MissPiggy: It is equivalent to what an instance is, compared to a class, in object-oriented programming?
13:43:50 <MissPiggy> no
13:44:27 <sm> a 3-line main function - http://gist.github.com/309241 . If I uncomment either the cmdArgs or the defaultMain line, stdout becomes unredirectable
13:44:31 <sm> what is going on ?
13:44:56 <osaunders> sm: "Repository temporarily unavailable.
13:44:56 <osaunders> The backend storage is temporarily offline. Usually this means the
13:44:56 <osaunders> storage server is undergoing maintenance. Your repository should
13:44:56 <osaunders> be available again very soon."
13:45:33 <Heffalump> sm: I think you need to inline what cmdargs and test-framework are doing until you find the precise code that triggers it
13:45:33 <sm> osaunders: pardon ? are you fetching one of my repos ?
13:45:42 <Heffalump> sm: that's what your gist.github link returns
13:46:13 * osaunders nods
13:46:16 <sm> argh! it was working seconds ago
13:46:50 <osaunders> Github has pretty serious reliability problems.
13:46:59 <sm> so much for my careful paste. gist was my only reliable pastebin, till now..
13:47:24 <byorgey> osaunders: a model is indeed similar to, say, a type class instance in Haskell
13:47:37 <sm> Heffalump: that makes sense (inlining). Odd coincidence that either one triggers it
13:47:55 <osaunders> byorgey: Right.
13:48:01 <osaunders> Nice.
13:48:46 <ddarius> byorgey: But a type class is not similar to an OO class.
13:49:09 <MissPiggy> hey I read about Functors today
13:49:24 * osaunders is getting there, slowly. He now understand the first two—count 'em, one, two—paragraphs of http://en.wikipedia.org/wiki/Algebraic_structure
13:49:26 <MissPiggy> but now I am wonder what does functor in haskell have to do with it???
13:49:41 <Heffalump> MissPiggy: ML functors?
13:49:42 <Twey> I think you got your capitalisation backwards, MissPiggy?
13:49:48 <Heffalump> or category theory functors?
13:50:19 <byorgey> ddarius: agreed.
13:50:32 <donsbot> how did a heffalump sneak in here
13:50:43 <Heffalump> huh?
13:51:00 <Heffalump> oh, you're not dons :-)
13:51:10 <Heffalump> I didn't sneak in, I came in the front door :-p
13:51:25 <MissPiggy> im reading Category Theory for Computer Science
13:51:28 <wissel> are you really referencing what I think?
13:51:32 <byorgey> MissPiggy: an instance of the Haskell Functor class can be thought of as an endofunctor on the category of Haskell types
13:51:33 <MissPiggy> because of the people here saying category theory is good
13:51:45 <osaunders> MissPiggy: Is it good?
13:52:00 <byorgey> the actual type constructor is the object mapping part, and fmap is the arrow mapping part
13:53:04 <sm> http://gist.github.com/309241 back up, fwiw
13:53:52 <MissPiggy> endofunctor on Haskell types
13:54:24 <MissPiggy> but how come there is different instances of functor? it's not just one functor
13:55:01 <MissPiggy> maybe it's too early for me to try andd connect up the concepts
13:55:12 <ddarius> MissPiggy: That's like asking why are there different functions between two given sets and not just one.
13:55:19 <Twey> It's also possible that there is little connection.  :þ
13:55:23 <MissPiggy> in category theory there is lots of maps
13:55:24 <osaunders> sm: Do you still get that behavior if you ghc --make ?
13:55:38 <ddarius> MissPiggy: A functor is a "map" (an arrow or morphism) in Cat.
13:55:41 <MissPiggy> but there is just one functor per functor
13:55:47 <ddarius> Cat being the category of (small) categories.
13:55:49 <byorgey> MissPiggy: if something is an instance of the Functor class, then it is an endofunctor on the category of Haskell types
13:55:54 <byorgey> there are many such endofunctors.
13:56:08 <byorgey> the Functor class is not a functor itself.
13:56:15 <byorgey> that doesn't even make sense.
13:56:22 <sm> osaunders: I was just trying.. and the answer is no - it works when compiled
13:56:29 <MissPiggy> hm
13:57:03 <osaunders> sm: I've heard someone say that runhaskell isn't really meant for any serious work.
13:57:23 <MissPiggy> it says something like, a functor F is a pair F_0 and F_1, which takes a map f : A --> B to F_0(f) : F_1(A) --> F_1(B)
13:57:26 <sm> I don't really believe that.. it's quite important
13:57:27 <ddarius> runhaskell invokes GHCi or Hugs.
13:57:46 <MissPiggy> and in haskell you have  fmap :: (a -> b) -> (f a -> f b)
13:57:58 <MissPiggy> so they LOOK similar but is that enough reason to call it a functor? just because they look alike
13:58:08 <Twey> osaunders, sm: Well, it's okay for ‘scripting’…
13:58:20 <dolio> fmap is F_1.
13:58:28 <dolio> Roughly.
13:58:35 <osaunders> Twey: sm is trying to debug a problem that only occurs with runhaskell.
13:58:36 <ddarius> f is F_0
13:58:38 <MissPiggy> dolio, I thought it would be F_0 ?
13:58:41 <ddarius> dolio: It is pretty much exactly.
13:58:42 <dolio> Wait, F_0.
13:58:45 <sm> runghc, to be precise
13:59:08 <sm> I find it quite important to run code interpreted while developing
13:59:09 <ddarius> Er, okay, F_0 should be the action on objects and F_1 on arrows.
13:59:21 <dolio> Yeah, I'm used to _0 being objects.
13:59:28 <MissPiggy> yeah but why call it functor? it is just because they look similar and the name is as good as any
13:59:33 <dolio> When stuff like that is used at all.
13:59:51 <ddarius> I usually don't differentiate.  Context always makes it clear.
13:59:53 <MissPiggy> maybe the book switched the numbers around
13:59:54 <dolio> Because Functors are endofunctors over Hask.
14:00:03 <osaunders> sm: Make a shell script that "ghc --make"s and then runs it.
14:00:08 <MissPiggy> is Hask and omega-CPO?
14:00:11 <dolio> Hand-waving away the fact that there is no Hask.
14:00:16 <ddarius> MissPiggy: Hask is undefined.
14:00:18 <MissPiggy> :(
14:00:20 <MissPiggy> this sucks
14:00:29 <MissPiggy> why do we bother with category theory if it doesn't even exist
14:00:46 <ddarius> Why do we bother with real numbers?
14:00:47 <dolio> What?
14:00:47 <Berengal> sm: Run code interpreted, or run code in an interpreter?
14:00:59 <sm> well, both
14:01:01 <ddarius> (And most categories "exist" much more so than real numbers.)
14:01:02 <MissPiggy> I just don't really see it
14:01:03 <Berengal> Wait, that doesn't even make sense...
14:01:11 <MissPiggy> can we make up a Hask that works for a subset of haskell
14:01:12 <ddarius> (Well "most" is kind of meaningless here...)
14:01:15 <dolio> The problem with Hask is that various operation in Haskell aren't nice enough to follow the laws for a category.
14:01:16 <ddarius> MissPiggy: Sure.
14:01:22 <MissPiggy> and what is it?
14:01:27 <dolio> Unless you ignore stuff, like seq, or bottoms.
14:01:33 * sm understood it anyway
14:01:37 <MissPiggy> I can't imagine bottom had a problem for a category, does it?
14:01:42 <MissPiggy> but what about omega-CPOs
14:01:42 <Berengal> sm: Running code in an interpreter perl-style doesn't offer much of an advantage over compiling imho. The real benefit comes from REPLs
14:01:43 <ddarius> MissPiggy: Drop seq and Hask is at least a category.  Drop bottoms and Hask is pretty much a subcategory of Set.
14:01:47 <osaunders> Is there a magma type class in Haskell? Would it be any use?
14:01:57 <MissPiggy> yes I am happy to forget about seq
14:02:03 <ddarius> osaunders: No and probably not.
14:02:24 <MissPiggy> so what is Hask?
14:02:33 <ddarius> MissPiggy: I already said Hask is undefined.
14:02:40 <MissPiggy> but didn't we just fix that?
14:02:43 <MissPiggy> (by dropping seq)
14:02:58 <ddarius> MissPiggy: You can call whatever you want Hask, just make sure you include your definition when you do.
14:03:15 <MissPiggy> what does this have to do with haskell programming language?
14:03:23 <Berengal> sm: If you think there's some advantage to running a batch in an interpreter that isn't offered by running it in the REPL, I'd like to know what I'm missing
14:03:36 <MissPiggy> it seems like category theory is totally separate from haskell
14:03:38 <dolio> Hask is the name people usually use to refer to a hypothetical category where the objects are Haskell types, and the arrows are Haskell functions.
14:03:52 <MissPiggy> why is it hypothetical
14:04:29 <dolio> Because as I said before, various stuff in Haskell isn't nice enough for it to actually be a category. You have to ignore some ugliness.
14:04:43 <MissPiggy> if we ignore seq can we have a real (concrete?) category for Haskell
14:05:11 <dolio> Probably. But it's still not that great, because Either isn't a categorical sum, and tuples aren't categorical products.
14:05:14 <sm> Berengal: well, it lets me be certain I'm testing the code I just saved; it avoids recompilation delay; it makes certain dev processes which require running the program more robust (not having to find a compiled binary)
14:05:19 <MissPiggy> my book says you can have omega-CPO for functional programming but maybe it means (the pure fragment) of SML or ocaml ?
14:05:42 <MissPiggy> dolio but why does that matter?
14:05:47 <MissPiggy> they are just arbitrary data types
14:05:50 <jvoorhis> how does seq break Hask?
14:06:11 <dolio> Because datatypes corresponding to categorical constructions would be nice.
14:06:13 <Berengal> sm: Yes, I agree, but don't you get that from loading it up in ghci as well?
14:06:28 <ddarius> > ((id . undefined) `seq` (), undefined `seq` ())
14:06:52 <MissPiggy> dolio I guess so but you could porobably make a new langauge if you wanted that (Charity?) but what I am wondering about is how all this nonsense has anything to do with haskell
14:07:08 <sm> that's for interactive use, I'm talking about automated tasks (preparing a release, running functional tests...)
14:07:18 <dolio> The point of category theory is to abstract those sorts of constructions to their essence, so they can be applied as widely as possible.
14:07:25 <MissPiggy> other than the cosmetics like (a -> b) -> (f a -> f b) has the same shape as f : a --> b |- F(f) : F(a) --> F(b)
14:08:00 * Cale computes the groupoid cardinality of categories of vector spaces over finite fields.
14:08:13 <Berengal> sm: Ah, true. I tend to just use cabal and do a full clean-build cycle when I'm at that point
14:08:13 <dolio> But what people refer to as "products" in Haskell don't satisfy the conditions on a product in the alleged category of Haskell types and functions. And same for sums.
14:08:18 <MissPiggy> hi Cale! I just found out differential forms are tensors!!
14:08:30 * sm tries to automate a lot
14:08:31 <ksf> @pl \xs x -> xs ++ [x]
14:08:36 <ksf> (I know that's inefficient
14:08:41 <ksf> @bot
14:08:47 <Gracenotes> is that an (xs:x)?
14:08:52 <MissPiggy> dolio so why don't we use something other than category theory which actually works
14:08:59 <Gracenotes> er. no. mathy var name sense tingling
14:09:17 <dolio> Like what?
14:09:21 <Berengal> sm: It's what computers are for, is it not :)
14:09:42 <MissPiggy> dolio yyou mean there isn't one so category theory is the best fit we can manage?
14:09:46 <BONUS> > liftA2 (++) id return "haha" 'z'
14:09:50 <ksf> ...no it's having mandatory space after the last element in a list so I've got pList pIdent <*> pIdent'
14:10:04 <dolio> Why should I learn type theory? It has nothing to do with Haskell. I can do things in Haskell that aren't valid in Martin-Loef type theory.
14:10:08 <sm> Berengal: yes, but.. they giveth with one hand and they taketh away with the other :/
14:10:26 <MissPiggy> I don't know what type theory has to do with it
14:10:28 <Gracenotes> ksf: (. return) . (++)
14:10:29 <sm> I shall stop fiddling with this now
14:10:53 <sm> but maybe take up the battle anon. Thanks all
14:10:59 <MissPiggy> maybe I just don't understand the stuff well enough to connect it with haskell yet
14:11:05 <jvoorhis> that is, what law does seq violate?
14:11:25 <ddarius> jvoorhis: If lambdabot was here, I demonstrated it above.
14:11:29 <Cale> I tend to think that maybe the pair type is just not quite defined properly if it's not the categorical product. It's close enough though.
14:12:09 <MissPiggy> the analogy in my book says:
14:12:11 <Cale> We tend to ignore _|_ whenever it's convenient to do so, and this is one of those times :)
14:12:17 <MissPiggy> Category as a 'mathematical workspace'
14:12:18 <ddarius> jvoorhis: I'm pretty sure it breaks both the unit laws and the associativity law.   So, all of them.
14:12:30 <MissPiggy> and the idea is that we want haskell to be (rougly) a mathematical workspace too?
14:13:02 <dolio> The point is that despite Haskell-as-strictly-defined having some warts with respect to it being a category, it's close enough to make lots of stuff from category theory relevant.
14:13:35 <Berengal> MissPiggy: It's all about patterns. Some patterns in CT are similar to patterns in Haskell, so by learning CT we might learn more about Haskell and how to write better programs. If Haskell doesn't fit perfectly, we can sometimes pretend it does and write our beautiful mathematics in it, and hopefully we're able to restrict the ugly parts so they won't fit in our code
14:13:37 <MissPiggy> dolio are the examples just those normal typeclasses, or can there be something deeper?
14:14:07 <MissPiggy> Berengal oh but why not make a programming language that is more accurate?
14:14:15 <jvoorhis> ddarius: thanks, that does make sense
14:14:19 * jvoorhis is here to ask the hard questions
14:15:11 <BONUS> > (flip (.) return . (++)) [1,2,3] 4
14:15:37 <ksf> oh. Now I got it. I shouldn't be fooling around and make a ReaderT for the parser to figure out whether whitespace is mandatory or optional
14:15:47 <Berengal> MissPiggy: Because they're too bothersome to actually program in :P
14:16:12 <MissPiggy> this doesn't really make sense to me but maybe I will have some kind of flash of insight later on
14:16:29 <Cale> That's not necessarily the case
14:16:42 <Cale> We could fix the product type in Haskell to be the categorical product
14:16:57 <MissPiggy> Cale what about Charity?
14:16:58 <Berengal> Cale: If you were refering to my claim then I certainly hope so.
14:16:58 <ksf> ...in the meantime, though, I simply won't care if people like to write iffoothenbarelsebaz. It's perfectly parsable.
14:17:08 <ddarius> Cale: Not really.  We can in somewhat idealized Haskell.
14:17:09 <roconnor> wow, gaussian elimination and shortest path algorithms are the same algorithm over different kleene-algebras
14:17:10 <Cale> Berengal: yeah
14:17:22 <roconnor> we need a kleene-algebra type class
14:17:23 <SubStack> roconnor: O_O
14:17:26 <ddarius> roconnor: Make it.
14:17:30 <MissPiggy> roconnor how did you find that out! :)
14:17:52 <roconnor> one sec, getting the reference from my supervisor
14:17:57 <Berengal> A language that follows a well-known mathematical model perfectly yet is still easy to program pretty much arbitrary things in would be awesome
14:18:08 <roconnor> the paper talks about *-semirings, but they are really kleene algebras
14:18:48 <MissPiggy> grobner basis is guassian elimination in the case of linear equations
14:18:59 <ddarius> A lot of algorithms on semirings apply widely and specialize into distinct, useful things.
14:19:59 <roconnor> oh, a *-semiring is more general than a kleene algebra
14:20:25 <Berengal> This is why I love mathematics. Useful abstractions :)
14:20:37 <dolio> Cale: I think proper categorical products for Haskell would be unlifted products, which I've heard are bad for performance.
14:21:04 <roconnor> http://geomete.com/abdali/papers/TCviaElim.pdf
14:21:14 <Alpounet> dolio, what are they ?
14:21:19 <Alpounet> (unlifted products)
14:21:31 <Cale> dolio: I'm not sure they'd always be bad for performance...
14:21:40 <roconnor> ya, most of the examples are kleene algebras, but not all.  In particular the star-algebra for gausian elimination isn't a kleene algebra.
14:21:52 <dolio> Alpounet: _|_ = (_|_, _|_), but you can still have (_|_, y) and (x, _|_) which are non-bottom.
14:22:01 <Alpounet> okay
14:22:07 <dolio> Assuming x and y are non-bottom.
14:24:26 <roconnor> so this paper should show why reachability, shortest path, largest capacity paths, most reliable paths, and solutions of linear equations are all the same problem in different *-semirings
14:24:47 <MissPiggy> roconnor I am looking forward to it :
14:24:49 <roconnor> the nice thing is that the * operation for the reals is x* = 1/(1-x)
14:24:55 <MissPiggy> but I can't read it yet
14:25:25 <roconnor> and as we recall list X (which is obviously X*) is equal to 1 + X + X^2 + X^3 + ... = 1/(1-X)
14:25:27 <MissPiggy> oh the expansion of x* is a classic
14:25:29 <MissPiggy> yes
14:25:42 <roconnor> so clearly it is the right star operation for real numbers!
14:25:43 <roconnor> :D
14:25:54 <dolio> seq would be really tricky on those, since you need 'p `seq` () = _|_' only if both components of p are bottom, but not if either component is non-bottom.
14:25:55 <ozataman> hey all.. any idea why I would get errors like these from cabal-install:
14:25:56 <MissPiggy> hehe
14:25:57 <MissPiggy> maybe I will understand this paper..
14:25:57 <ozataman> For the dependency on base >=4 && <=5 there are these packages: base-4.0.0.0,
14:25:57 <ozataman> base-4.1.0.0 and base-4.2.0.0. However none of them are available.
14:25:57 <ozataman> base-4.0.0.0 was excluded because of the top level dependency base -any
14:27:12 <dolio> Something like: seq ~(x, y) z = ((x `seq` ()) `lub` (y `seq` ())) `seq` z
14:27:22 <fizruk> is there standard function, counting list elements, corresponding to condition?
14:27:30 <dolio> Using conal's magic lub.
14:27:32 <ddarius> dolio: Indeed.  You'd need some kind of "parallel" search.
14:27:48 <ddarius> fizruk: You could just do length . filter p
14:28:41 <fizruk> ddarius: yes, i just was interested if there is short name for that
14:28:59 <conal> dolio: remember that lub carries a proof obligation / precondition
14:29:02 <ddarius> @. hoogle type \p -> length . filter p
14:29:14 <dolio> conal: That's why I used (). :)
14:29:22 <MissPiggy> I like typeclass Seq
14:29:24 <ddarius> Freakin' bot.
14:29:29 <conal> dolio: oh!
14:29:31 <Heffalump> conal: how well does unamb work with GHC 6.12?
14:29:33 <etpace> @hoogle Random
14:29:33 <MissPiggy> that does not throw a spanner in the works I think
14:29:47 <etpace> when I do uh, +m System.Random or import System.Random, ghc/i cant find it, any ideas?
14:29:54 <conal> Heffalump: i hear it works much better than in 6.10.x.  don't know how well.
14:30:54 <conal> i think of the current unamb as a placeholder.  allows people to experiments with applications, and from there motivate a better implementation.
14:30:55 <dolio> I guess with (), unamb is enough, too, since there's no interesting structure.
14:31:02 <Warrigal> > compare 5 3
14:31:20 <Warrigal> I'm beginning to think our bot is gone.
14:32:08 <roconnor> ... clearly a Kleene algebra is simply a *-semiring that is also a diod ...
14:32:14 <roconnor> dioid
14:32:21 <MissPiggy> wnhat the heck is a dioid ?
14:32:36 <Warrigal> So, tell me, guys, what is map (compare 5) [3,5,7]?
14:32:36 <MissPiggy> roconnor I wonder how to organize all this stuff into a formal mathematics library
14:32:41 <dolio> Like a monoid, only with two of something?
14:32:52 <Berengal> Like a monoid, only twice as good.
14:33:12 <Berengal> Warrigal: [LT, EQ, GT]
14:33:23 <Warrigal> Wonderful.
14:33:23 <Berengal> Or the reverse
14:33:38 <medfly> > map (compare 5) [3,5,7]
14:33:43 <Zao> Warrigal: Look at the individual functions and types.
14:33:43 <medfly> er...
14:33:46 <Berengal> It's the reverse
14:33:47 <medfly> Cale, lambdabot!
14:34:11 <Zao> map :: (a -> b) -> [a] -> [b]
14:34:12 <Cale> hmm
14:34:45 <medfly> > map (compare 5) [3,5,7]
14:34:51 <djahandarie> lambdabot, o/
14:34:53 <lambdabot>   [GT,EQ,LT]
14:34:54 <medfly> > map (\n-> compare 5 n) [3,5,7]
14:35:03 <lambdabot>   [GT,EQ,LT]
14:35:11 <Zao> @type compare
14:35:17 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:35:20 <roconnor> MissPiggy: that is my job now
14:35:22 <idnar> > map (5 `compare`) [3,5,7]
14:35:29 <lambdabot>   [GT,EQ,LT]
14:35:49 <Warrigal> > let analyze x = analyze' x 0 1 1 1; analyze' x nl dl nh dh = case compare x ((nl+nh)/(dl+dh)) of LT -> False : analyze' x nl dl (nl+nh) (dl+dh); EQ -> []; GT -> True : analyze' x (nl+nh) (dl+dh) nh dh in analyze (5/13)
14:35:57 <lambdabot>   [False,True,False,True]
14:36:09 <Warrigal> > let analyze x = analyze' x 0 1 1 1; analyze' x nl dl nh dh = case compare x ((nl+nh)/(dl+dh)) of LT -> False : analyze' x nl dl (nl+nh) (dl+dh); EQ -> []; GT -> True : analyze' x (nl+nh) (dl+dh) nh dh in analyze (89/144)
14:36:15 <lambdabot>   [True,False,True,False,True,False,True,False,True]
14:36:19 <Warrigal> > let analyze x = analyze' x 0 1 1 1; analyze' x nl dl nh dh = case compare x ((nl+nh)/(dl+dh)) of LT -> False : analyze' x nl dl (nl+nh) (dl+dh); EQ -> []; GT -> True : analyze' x (nl+nh) (dl+dh) nh dh in analyze (1/16)
14:36:25 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
14:36:29 <Warrigal> It seems to work.
14:36:45 <medfly> what is it?
14:36:54 <MissPiggy> roconnor ooh!!
14:37:34 <Warrigal> analyze is the function that computes the inverse of a certain function.
14:37:38 <Warrigal> Namely, the inverse of analyze.
14:38:06 <tARrAScH> > :t analyze
14:38:07 <lambdabot>   <no location info>: parse error on input `:'
14:38:09 <Warrigal> It's a bijection between the rational numbers between 0 and 1, and the finite lists of Booleans.
14:38:22 <MissPiggy> roconnor  so is that CoRN or ?
14:38:27 <Warrigal> If you include 0 and 1 and irrational numbers between them, you can get infinite lists of Booleans.
14:38:30 <ksf> @pl \xs x -> xs ++ [x]
14:38:30 <lambdabot> (. return) . (++)
14:39:00 <ksf> :t (. return) . (++)
14:39:01 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => m a -> a -> m a
14:39:29 <Warrigal> @let analyze x = analyze' x 0 1 1 1; analyze' x nl dl nh dh = case compare x ((nl+nh)/(dl+dh)) of LT -> False : analyze' x nl dl (nl+nh) (dl+dh); EQ -> []; GT -> True : analyze' x (nl+nh) (dl+dh) nh dh
14:39:30 <tARrAScH> :t (<$>)
14:39:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:39:31 <lambdabot>  Defined.
14:39:39 <Warrigal> > analyze (1/pi)
14:39:40 <lambdabot>   [False,False,True,True,True,True,True,True,True,False,False,False,False,Fal...
14:39:53 <roconnor> MissPiggy: it is MathScheme at McMaster University
14:39:58 <tARrAScH> > analyze 1
14:39:59 <roconnor> gotta go
14:40:00 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:40:09 <tARrAScH> > analyze (1/2)
14:40:10 <lambdabot>   []
14:40:19 <tARrAScH> > analyze (1/2.0)
14:40:20 <lambdabot>   []
14:40:26 <tARrAScH> > analyze (0)
14:40:27 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
14:40:30 <Nereid> > analyze (1/3)
14:40:31 <lambdabot>   [False]
14:40:35 <tARrAScH> > analyze (2/3)
14:40:36 <lambdabot>   [True]
14:40:45 <tARrAScH> > analyze (0.50000001)
14:40:46 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
14:40:50 <tARrAScH> > analyze (0.51)
14:40:51 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
14:40:58 <tARrAScH> > analyze (0.6)
14:40:59 <lambdabot>   [True,False]
14:41:04 <Nereid> > analyze 0.6666
14:41:06 <lambdabot>   [True,False,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
14:41:06 <tARrAScH> oh sorry I should stop spaming
14:41:08 <Warrigal> > map analyze [1/12,2/12,3/12,4/12,5/12,6/12,7/12,8/12,9/12,10/12,11/12]
14:41:09 <lambdabot>   [[False,False,False,False,False,False,False,False,False,False],[False,False...
14:41:17 <Warrigal> Well, that wasn't very helpful.
14:41:21 <Nereid> lol
14:41:24 <Warrigal> > analyze 0.66
14:41:25 <Nereid> What does it do?
14:41:25 <tARrAScH> lol
14:41:26 <lambdabot>   [True,False,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
14:41:34 <Warrigal> Keep experimenting until you figure out what it does. :P
14:41:36 <tARrAScH> Nereid - confuse you
14:41:40 <medfly> > analyze 0
14:41:41 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
14:41:47 <Berengal> Warrigal: It's not a bijection if you include irrational numbers though
14:41:47 <medfly> > analyze 1
14:41:49 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:41:55 <Warrigal> Berengal: yes it is.
14:41:56 <medfly> > analyze 1.01
14:41:57 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:42:05 <tARrAScH> > analyze NaN
14:42:05 <lambdabot>   Not in scope: data constructor `NaN'
14:42:09 <Gracenotes> analyze this! boom.
14:42:11 <Warrigal> medfly: oi, this function's domain is values in the interval [0,1].
14:42:12 <tARrAScH> > analyze (1/0)
14:42:13 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:42:18 <medfly> oh, ok
14:42:25 <medfly> > analyze 0.5
14:42:26 <tARrAScH> > analyze (0/0)
14:42:26 <lambdabot>   []
14:42:27 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
14:42:29 <Warrigal> It never compares a number to anything outside that interval.
14:42:34 <Gracenotes> /query lambdabot
14:42:43 <Gracenotes> ^ please, PM for copious querying
14:42:43 <tARrAScH> :i analyze
14:42:47 <bolmar> @hoogle [m b] -> m [b]
14:42:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:42:47 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:42:47 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
14:43:02 <Berengal> Warrigal: The set of lists of bools are countable, but irrational numbers aren't
14:43:10 <tARrAScH> Gracenotes: ok.
14:43:19 <Warrigal> Berengal: the set of lists of bools is uncountable if you include infinite lists.
14:43:54 <Berengal> They're still countable even if they're infinite... I think
14:43:58 <Nereid> but the set of computable lists of bools is countable
14:44:13 <Nereid> Berengal: nope
14:44:21 <Warrigal> Berengal: Cantor's diagonal argument was practically made to prove that the set of infinite lists of Bools is uncountable.
14:44:30 <Gracenotes> Nereid: are they?
14:44:31 <Nereid> there's an injection from the set of infinite lists of bools to [0,1]
14:44:41 <Nereid> (think: binary expansion)
14:44:46 <Nereid> er surjection
14:44:47 <Nereid> f
14:45:01 * Berengal hasn't read enough Cantor
14:45:07 <Nereid> and [0,1] is uncountable
14:45:23 <Gracenotes> I know almost no reals are computable, but is it really on par with the natural numbers?
14:45:26 <Nereid> Gracenotes: there are only countably many programs so yes
14:46:00 <Berengal> Gracenotes: On par?
14:46:14 <Cale> Gracenotes: There are countably many programs
14:46:24 <Cale> Er, yeah, Nereid covered that ;)
14:46:30 <Gracenotes> Cale: oh, right
14:46:39 <Gracenotes> if you cross that with number of inputs
14:46:53 <Gracenotes> duh.
14:47:38 <tromp> almost all numbers in [0,1] are uncomnputable, but hard to define any
14:48:25 <Berengal> Just pick one at random :P
14:48:32 <Nereid> how?
14:48:34 <dolio> Chaitin's constant is an easy one.
14:48:38 <burp> can someone think of a reduction function for rainbow tables for "hash to ipv4"? is it possible to create a rainbow table for "hash -> ipv4"?
14:50:17 <BONUS> man i so don't get LLVM
14:50:37 <BONUS> i mean, like, what does it *do*
14:50:48 <Dementati> BONUS: Hey, thanks for the guide. It's awesome.
14:50:59 <BONUS> hey np :D more is on the way
14:51:08 <BONUS> as soon as i get my lazy ass to finish and upload it
14:51:21 <pikhq> BONUS: In essence, it provides a single, well-implemented backend for compilers to use.
14:51:32 <Zao> BONUS: Fancypants code generation backend, or somesuch.
14:51:33 <pikhq> That also can be used for JITing.
14:51:48 <copumpkin> BONUS: you get a pseudo assembly language to output, and it will perform low-level optimizations on it and generate code for real architectures
14:51:51 <Berengal> Portable assembly, isn't it?
14:51:51 <BONUS> i guess i get stuck with not really getting what a compiler backend is
14:51:51 <Dementati> BONUS: No rush, I'm only halfway through. =P
14:52:20 <BONUS> copumpkin: oooh, now that sounds cool
14:52:26 <Zao> Take some nice intermediate representation, map it down to concrete registers and operations.
14:52:28 <pikhq> BONUS: A compiler backend takes some intermediate language form, does a metric fuckton of optimisations on it, and outputs machine code.
14:52:33 <Zao> Preferably with awesome perf.
14:52:37 <BONUS> aha
14:52:52 <Berengal> Possibly run it on a vm or do JIT compilation
14:52:57 <copumpkin> how does a metric fuckton compare to an imperial fuckton?
14:52:58 <Berengal> Or both
14:53:20 <Berengal> copumpkin: The metric fuckton stays the same independent of which day of the week it is
14:53:30 <pikhq> Yeah, it can also be used for JIT.
14:53:37 <copumpkin> Berengal: interesting
14:53:50 <BONUS> so it it takes your pseudo assembly, compiles it to architecture specific assembly code and then links that and generates machine code
14:54:03 <pikhq> IcedTea has it as an option for the JIT engine instead of a native JVM.
14:54:18 <pikhq> (LLVM supports more architectures than the normal JVM)
14:54:34 <pikhq> BONUS: Yeah.
14:54:58 <bolmar> @hoogle  m [[a]] -> m [a]
14:54:58 <lambdabot> Prelude concat :: [[a]] -> [a]
14:54:58 <lambdabot> Data.List concat :: [[a]] -> [a]
14:54:58 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
14:55:10 <copumpkin> BONUS: and performs some optimizations too
14:55:38 <Berengal> Does having a LLVM backend provide some sort of free FFI to other LLVM-compiling languages?
14:56:08 <copumpkin> I doubt it
14:56:26 <copumpkin> x -> llvm and y -> llvm doesn't mean x <-> y :P
14:56:47 <copumpkin> you have a coproduct and want projections from it :o
14:56:48 <pikhq> No, still have to do FFI manually.
14:56:51 <Berengal> No, but I was hoping you'd get something like x <~> y
14:56:56 <pikhq> Nope.
14:57:02 <pikhq> LLVM is too low-level for that.
14:57:13 * copumpkin 's mom is too low-level
14:57:20 <copumpkin> oh wait, that's not how your mom jokes work
14:57:21 <Berengal> pikhq: not even foreign export llvm / foreign import llvm?
14:57:40 <pikhq> (C family languages end up producing machine-specific LLVM, for one thing...)
14:57:47 <Berengal> :/
14:58:12 * Berengal wants an FFI to java
14:58:23 <pikhq> Berengal: It's just like a normal binary, except it just happens to have been produced with LLVM.
14:59:34 <Berengal> pikhq: I haven't really studied LLVM that much. Isn't the language-compiler output LLVM bytecode?
14:59:43 <Berengal> (Which is then compiled with an LLVM compiler)
14:59:50 <Berengal> Or did I miss something?
14:59:57 <iazr> @pl (\n c -> 2*n + f c)
14:59:57 <lambdabot> (. f) . (+) . (2 *)
15:00:51 <BONUS> llvm.org is down now of all times :[
15:01:01 <pikhq> Berengal: The language compiler output is either LLVM bytecode or machine code.
15:01:25 <pikhq> If it's LLVM bytecode, then what you have is a normal binary that happens to be for a low-level virtual machine.
15:01:32 <pikhq> If it's machine code, then you have a normal binary.
15:02:35 <djahandarie> BONUS, yeah I noticed that awhile back when I was trying to look at something
15:02:59 <Berengal> pikhq: Right, so any FFI would be less interface, more foreign...
15:04:07 <p_l> pikhq: AFAIK LLVM doesn't support binary output other than flat binaries (used for JIT)
15:04:42 <BONUS> what do you mean flat binaries
15:04:44 <copumpkin> mmm, GADTs for balanced trees
15:04:52 <MissPiggy> yeah!
15:05:04 * copumpkin is writing a haskell module playing with the idea
15:05:04 <MissPiggy> hey can you do balanced trees with nested data types?
15:05:17 <copumpkin> I'm just trying the naive peano numeral approach
15:05:24 <copumpkin> how do you mean nested data types?
15:06:02 <p_l> BONUS: a flat binary is an unstructured, flat blob of machine code :)
15:06:11 <MissPiggy> data Perfect a = Perfect a | Absolutely (Perfect (a,a)) -- perfect trees with 2^n leaves
15:06:35 <pikhq> p_l: It does output ordinary binaries just fine.
15:06:36 <p_l> BONUS: last time I checked, LLVM required external assembler to generate local, platform-specific binaries
15:06:38 <copumpkin> MissPiggy: oh, yeah, mine allows for non powers of two
15:06:43 <BONUS> ahh
15:06:54 <MissPiggy> that's an example of a nested data type
15:07:04 <MissPiggy> they are quite strangely expressive
15:07:11 <BONUS> i thought that you just gave it the virtual code and it did everything else
15:07:11 <p_l> pikhq: it does so by outputting assembler sourcecode that then is assembled by native assembler
15:07:25 <pikhq> p_l: So does GCC. Your point?
15:07:31 <BONUS> nested data types always give me head aches
15:07:38 <MissPiggy> BONUS yeah me too :P
15:07:47 <p_l> BONUS: full linker is in works, iirc
15:08:27 <pikhq> p_l: No, just a replacement for binutils' ld that supports linker plugins.
15:08:53 <pflanze> How to I add a method to a class? I want to have show call my own code for a particular type.
15:08:58 <p_l> pikhq: One could argue that LLVM is slightly weird in that aspect, that it is perfectly capable of generating the opcodes by itself. Still, I'm looking forward to it :-)
15:09:24 <pflanze> Just creating show for that type doesn't seem to be it (well it's a union type, but I'm covering all cases).
15:09:28 <dancor> pflanze: http://www.haskell.org/tutorial/classes.html
15:10:06 * p_l wonders if he could manage to get LLVM to compile itself given only C library to link with...
15:10:39 <pikhq> p_l: No. LLVM is not a compiler.
15:11:11 <pikhq> You're not going to have any more luck doing that than you could compiling binutils with only gas available. :P
15:11:18 <dancor> pflanze: instance Show MyType where show (MyType myInt) = "mytype " ++ show myInt
15:11:32 <pflanze> Thanks
15:11:33 <copumpkin> jaspervdj: very nice rank on AI :)
15:11:52 <pikhq> p_l: However, Clang can build itself and LLVM just fine right now.
15:12:19 <ddarius> copumpkin: I wrote an AVL tree thing using type-level programming.  Then Oleg did the same thing the next day.
15:12:29 <copumpkin> ddarius: damn!
15:12:56 <copumpkin> mine isn't any particular kind of tree, I just wanted to see if I could encode balancedness in the type
15:13:05 <BONUS> ddarius: at least you did something *before* Oleg
15:13:14 <BONUS> not many have managed such a feat
15:13:20 <RayNbow> copumpkin, either Que's staff is getting flooded with emails... or my question was too hard to answer :p
15:13:28 <copumpkin> RayNbow: oh no
15:13:50 <Berengal> copumpkin: I wrote a RB tree in GADTs, right after I did that in Agda.
15:13:59 <RayNbow> ...or my email has been lost in the darkest seas of the internet
15:14:04 <RayNbow> that's also a possibility
15:14:15 <ddarius> RayNbow: Or they just don't like you.
15:14:33 <copumpkin> Berengal: yeah, I've experimented with RB trees, but you can't express the "all paths to subnodes have equal number of black nodes" invariant in the (haskell) type system
15:15:13 <jaspervdj> copumpkin: myeah, I think it is currently mostly a matter of luck
15:15:19 <jaspervdj> copumpkin: thank you, though
15:16:01 <lispy> copumpkin: I bet Oleg could express it
15:16:11 <p_l> pikhq: I know, but LLVM included GCC-LLVM. The plan was to port LLVM to a system that doesn't support C++ at all :D
15:16:23 <copumpkin> lispy: well if you move far enough to the type level I imagine it's possible, but you want value-level stuff too
15:16:28 <copumpkin> but yeah, I bet he could :P
15:16:42 <p_l> (well, there are some C++ implementations running there... but it was like COBOL)
15:18:18 <pikhq> p_l: If you don't mind not having any support for the C++ ABI at all, you can just have LLVM output C for the C++.
15:18:27 <pikhq> p_l: And then compile the C on that computer.
15:19:45 <dancor> what dependent type programming language is the most useful/used for practical programming?  like what if i wanted to write and prove correct a simple game
15:20:07 <dancor> ATS?
15:20:17 <copumpkin> agda
15:20:20 <erikc> none
15:20:32 <copumpkin> but just because it's most practical doesn't mean it's practical
15:20:37 <dancor> heh
15:20:42 * RayNbow wonders what kind of logo the Haskell reddit uses currently... something with black wings?
15:20:46 <copumpkin> it's LLVM
15:21:22 <RayNbow> ah
15:21:24 <p_l> pikhq: the ABI was pretty irrevelant on system without shared libraries nor dynamic loader
15:21:35 <pikhq> p_l: True.
15:22:03 <dolio> ATS is almost certainly more useful for practical programming than Agda. But whether it has dependent types, strictly speaking, is questionable.
15:22:06 <seit> I'm trying to get a "pure" list of random Ints.  I'm using:  `take 5 (randomRs (0,10) (mkStdGen 1) :: [Int])'
15:22:22 <seit> but I can't figure out how to get the seed for 'mkStdGen' to be random.  Any hints?
15:22:39 <jaspervdj> seit: newStdGen
15:22:41 <MissPiggy> dolio ooh why might it not?
15:22:56 <benmachine> seit: randomness and purity don't really mix
15:22:56 * seit looking up newStdGen
15:22:59 <MissPiggy> dancor prove that it is fun?
15:23:05 <dancor> ha
15:23:08 <benmachine> at least in that, a pure function has got to return the same result every time
15:23:28 <dancor> maybe prove that it can still be fun to write in such a language
15:23:32 <benmachine> if you want something that varies unpredictably, you're going to have to get it from the outside world
15:23:35 <benmachine> i.e. IO
15:24:02 <seit> benmachine, I don't mind one of my functions being in the IO monad, but I'd like to pass the generated values to a pure function
15:24:20 <dolio> MissPiggy: Because it's divided into a static language and a dynamic language, just like GHC. Types in the dynamic language can be parameterized by the types in the static language, but that's not different in kind to replicating stuff at the type level, and using GADTs.
15:24:39 <jaspervdj> seit: have your pure function take a list of values, and generate the list in the IO function
15:24:40 <benmachine> seit: the normal thing is to fetch your seed with newStdGen or getStdGen from IO, and then pass it to your pure code
15:24:44 <dolio> It's like Omega.
15:25:00 <benmachine> @hoogle StdGen
15:25:01 <dancor> i find randomness things easier to chain in the rand monad than purely
15:25:01 <lambdabot> System.Random data StdGen
15:25:01 <lambdabot> System.Random getStdGen :: IO StdGen
15:25:01 <lambdabot> System.Random mkStdGen :: Int -> StdGen
15:25:25 <dolio> At least, that's what it looks like to me. I haven't really taken an interest in it, so I may have misjudged it.
15:25:28 <dancor> are you supposed to avoid monads if you can
15:25:30 <benmachine> the random monad's basically just State StdGen isn't it?
15:25:50 * seit is trying to digest the help at the moment
15:26:07 <dancor> benmachine: i think so
15:26:26 <benmachine> wrt avoiding monads, I think that's a bad general principle
15:26:31 <benmachine> you should avoid complexity
15:26:49 <MissPiggy> dancor avoid monads/?
15:26:50 <MissPiggy> ???
15:26:52 <aledge> does it allow you to put/get?
15:26:53 <benmachine> so if you don't need monads then don't use them, sure, but if there's a short monad answer or a long non-monad answer
15:26:57 <aledge> I guess I could look it up
15:27:01 <benmachine> then the short one's always best
15:27:09 <benmachine> (fsvo always)
15:27:14 <aledge> fsvo eh
15:27:16 <MissPiggy> dancor you mean should you avoid monads for proof?
15:27:23 <aledge> for some value of
15:27:25 <aledge> aaahahaha
15:27:27 <benmachine> heh
15:27:34 <aledge> this is one of the only places where 'fsvo' would be used
15:27:39 <benmachine> :P
15:27:39 <aledge> mb here and like
15:27:42 <aledge> #algebra
15:27:51 <benmachine> I've seen it around
15:27:59 <benmachine> but mostly from maths/CS geeks, yes
15:28:15 <Draconx|Laptop> apparently it's in my wtf database.
15:28:20 <dancor> shorter is always better, but for what metric
15:28:23 <MissPiggy> :(
15:28:38 <lament> shorterisalwaysbetterbutforwhatmetric
15:28:38 <aledge> hehe 'maths'
15:28:54 <seit> benmachine, how do I fetch the random seed from the randomIO function and pass it as a pure value?
15:29:21 <benmachine> if you want to fetch a random seed you use newStdGen or getStdGen
15:29:29 <benmachine> randomIO fetches a random value
15:29:30 * dancor imagines lament using an irc client that supports easy arbitrary manipulation of previous lines
15:29:39 <benmachine> (insofar as the concept of "random value" actually makes sense)
15:30:05 <aledge> just say pseudorandom
15:30:20 <seit> benmachine, for my purposes pseudorandom is fine :-)
15:30:27 <benmachine> I didn't mean like that :P
15:30:33 <benmachine> I just meant like, is 4 more or less random than 7
15:30:40 <aledge> oh
15:30:41 <benmachine> the terminology's a bit weird
15:30:41 <aledge> hehe
15:30:48 <aledge> instead of a value chosen at random?
15:30:55 <benmachine> yeah
15:31:04 <lament> "this sentence is completely random"
15:31:07 <benmachine> I guess you just have to be careful about your wording
15:31:12 <benmachine> or
15:31:15 <benmachine> you have to be not-pedantic
15:31:20 <benmachine> one of the two!
15:31:25 <aledge> well this is #haskell
15:31:25 <aledge> so
15:31:29 <aledge> be careful about your wording
15:31:33 <benmachine> I know which one I choose :P
15:32:02 <aledge> this isn't a criticism, but I would say people who enjoy haskell might also enjoy being a little bit pedantic
15:32:21 <aledge> brb
15:33:12 <copumpkin> aledge: not really
15:33:20 <copumpkin> if anything this channel tends to be less pedantic than others, I find
15:34:51 <Twey> copumpkin: That depends.  What do you mean exactly by ‘pedantic’?  If you mean the property of attempting to increase the perceived extent of one's learning above its actual value, then almost certainly, but if you simply mean requiring unusual levels of detail, then I'd say that this channel is certainly above the norm.  That said, though, there is of course a need to more precisely define our metrics here…
15:35:54 <copumpkin> I mean the channel contains fewer pedants than other channels. People don't correct your questions as often, if your intent is clear but you didn't quite use the right terminology
15:36:20 <MissPiggy> copumpkin, that's not strictly correct: I am a pedant but one of several and there are channels with only one pedant
15:37:32 <aavogt> those channels probably contain only one user
15:39:10 <Twey> Hahaha
15:43:45 <aledge> alright me droogs
15:46:41 <Dementati> time for a bit of the old ultraviolence?
15:47:06 <aledge> i suppose, if by that you mean go home
15:47:07 <aledge> ps
15:47:17 <Twey> Hm
15:47:36 <Dementati> Those two activities are not mutually exclusive. =]
15:47:57 <Twey> When I runhaskell Setup.hs configure on happstack-util, after cabal unpacking it, I get a list of unmet dependencies that cabal-install insists are already presetn
15:48:00 <Twey> present**
15:48:02 <Twey> What am I missing?
15:53:40 <Dementati> http://pastebin.org/94267 <- What am I doing wrong?
15:54:44 <aavogt> Twey: use cabal install, cabal unpack doesn't fetch dependencies
15:55:17 <aavogt> oh actually,  Setup.hs uses --global, while cabal install does --user installs by default
15:55:25 <Cale> Dementati: The result of applying td to 2 arguments should be a list with type [Dynamic]
15:55:29 <Twey> Ahh
15:55:40 <Cale> Dementati: so [td f (val y) | y <- xs] is a list of lists
15:55:41 <Dementati> Cale: Oh, right.
15:55:45 <aavogt> and it wouldn'b be very good security wise to have global libraries depend on user packages
15:55:50 <Dementati> Cale: Thanks.
15:55:57 <DevHC> do we have support for elastic tabstops?
15:56:27 <dancor> "Dawn entered safe mode due to a programming error during its February 17, 2009 Mars flyby."  doesn't it seem like all code in a spaceship should be proven correct?
15:56:28 <DevHC> @faq elastic tabstops
15:56:28 <lambdabot> The answer is: Yes! Haskell can do that.
15:56:48 <Cale> DevHC: That's something that a text editor does, not a Haskell implementation.
15:57:04 <idnar> safe mode? as in windows?
15:57:07 <aavogt> it could be done in an IDE that blends the two...
15:57:11 <DevHC> i mean support for elastic tabstop based layout
15:57:15 <Cale> In any case, I recommend not putting hard tab characters in your source.
15:57:31 <dancor> idnar: ha.  "only essential functions such as thermal management, radio reception and attitude control"
15:57:52 <DevHC> i know how to manage my tab indentation
15:58:08 <dons> dolio: any chance for vector-algorithms on hackage soon?
15:58:09 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:58:10 <dons> i could use it.
15:58:12 <DevHC> but in any case support for elastic tabstop in the layout would be nice
15:58:18 <Twey> aavogt: Nice, --user works — thanks ☺
15:58:27 <seit> getStdRandom (randomR (1,6)) :: IO Int -- how can I pass the 'Int' value to a pure function?
15:58:38 <Twey> aavogt: Having installed it, though, I can't access its modules…
15:59:02 <aavogt> access them how?
15:59:04 <Cale> seit: Run the IO action, and pass the resulting Int along
15:59:15 <Twey> aavogt: Via GHCi
15:59:25 <aavogt> has this ghci been running the whole times?
15:59:26 <Twey>     Could not find module `Happstack.Util':
15:59:26 <Twey>       it is not a module in the current program, or in any known package.
15:59:28 <aavogt> *time
15:59:30 <Twey> No, I just started it
15:59:32 <dancor> seit: main = do {res <- fmap myPureFunc (getStdRandom (randomR (1,6))); print res}
15:59:34 <Cale> seit: do x <- getStdRandom (randomR (1,6 :: Int)); print (f x)
16:00:03 <seit> dancor, Cale : ahh, gotcha.  Thanks!
16:00:14 <aavogt> Twey: seems to me that happstack-util doesn't export that module
16:00:39 <Twey> aavogt: Sorry, .AutoBuild or any of the others
16:00:48 <Twey> Basically, I don't have any Happstack.* modules
16:02:48 <Scriptor> hi everyone
16:06:28 <Cale> hello Scriptor
16:07:19 <Scriptor> so my college has a program where students can teach a class on a math/cs subject to high school students
16:07:56 <Scriptor> I'm planning on doing one as an intro to functional programming (partly just to introduce them to non-Java code)
16:08:28 <hzap> does anyone know why I get "cabal: Codec.Compression.Zlib: premature end of compressed stream" when doing cabal update?
16:09:10 <nolrai_FG> If I want to apply a linear transeform to a Data.Vector, whats the best way to do that?
16:09:13 <Scriptor> I've been trying to come up with advantages functional offers, so far I've got "easier for concurrency" and "easy to test"
16:09:31 <Scriptor> meaning, referential transparency
16:09:56 <Twey> ‘Appreciative of the comparative value of sanity’
16:11:44 <cads> hello
16:16:58 <gwern> oh #haskellers! remind me what to do with an error like 'ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi6_DataziGenericsziSYBziWithClassziInstances_constrZMabOTZN_closure'
16:17:17 <Twey> --make
16:17:22 <gwern> this is with cabal
16:17:27 <Twey> Hm
16:17:28 <gwern> I think it supplies --make somewhere
16:17:54 <gwern> the funny thing is, the build-depends uses a different syb-with-class version
16:17:56 <gwern> 0.5.1
16:17:58 <gwern> not 0.6
16:18:07 <gwern> (this is ghc 6.10.4)
16:19:35 <ddarius> Scriptor: Do these students know how to program at all?
16:22:32 <gwern> ok, looks like forcing an ghc-pkg unregister *finally* convinces template-haskell not to be idiotic
16:24:53 <gwern> 'ghc: dist/build/Happstack/Data/Default.o: unknown symbol `sybzmwithzmclasszm0zi5zi1_DataziGenericsziSYBziWithClassziInstances_constrZMabNEZN_closure'
16:24:57 <gwern> dang it!
16:25:30 * gwern hates template-haskell. it's caused me so much grief over the years
16:25:47 <hzap> hi
16:26:11 <gwern> SO MUCH
16:26:46 <hzap> anyone know what's with 'cabal update' giving this error: cabal: Codec.Compression.Zlib: premature end of compressed stream
16:27:16 <copumpkin> I think there's a cream for that
16:27:46 <gwern> preflex: seen dcoutts
16:27:47 <preflex>  dcoutts was last seen on #ghc 12 days, 5 hours, 5 minutes and 44 seconds ago, saying: ok, ta
16:29:24 <gwern> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7797#a7797 <-- look at that, I removed syb-with-class entirely and let cabal-install pull it in, and yet!
16:29:37 <aavogt> preflex: zdec sybzmwithzmclasszm0zi5zi1_DataziGenericsziSYBziWithClassziInstances_constrZMabNEZN_closure
16:29:38 <preflex>  syb-with-class-0.5.1_Data.Generics.SYB.WithClass.Instances_constr[abNE]_closure
16:30:02 <cads> Hey, the channel opinion is that haskell mode for emacs is highly worth learning, correct?
16:30:36 <dancor> what's the state-of-the-art for reversible parsers
16:30:54 <MissPiggy> dancor good question .........
16:30:59 * ddarius doesn't use emacs...
16:31:07 <MissPiggy> I've been playing with this again, just a bit
16:31:17 <dancor> MissPiggy: ah
16:31:52 <ddarius> dancor: If I'm understanding what you mean, look up pickling combinators, or serialization combinators.
16:32:17 <aavogt> gwern: I think it's this issue: http://hackage.haskell.org/trac/hackage/ticket/624
16:32:33 <aavogt> do you build documentation for syb-with-class?
16:33:02 <cads> ddarius: I'm looking for something that'll make sure what I'm writing is correctly typed, and I remember something about haskell mode with flyckeck
16:33:21 <cads> ddarius: what's your preferred editing environment for haskell?
16:34:13 <cads> Hehe, sorry to bring up the 'wat editor do u uze?' conversation :X
16:36:17 <copumpkin> gah, "Pattern signature must exactly match"
16:36:37 <aavogt> copumpkin: I saw that today
16:37:12 <copumpkin> do instances get automatic scoped type variables?
16:37:18 <copumpkin> cause I can't stick a forall anywhere
16:37:24 <copumpkin> must I define a helper function?
16:37:27 <gwern> aavogt: probably
16:37:29 <aavogt> instance are automatically scoped
16:37:32 <ddarius> cads: I use vim.  I don't use any mode, just the syntax highlighting files that come in the default distribution.
16:38:01 <aavogt> *instance type variables
16:38:13 <copumpkin> hm
16:38:21 <ddarius> cads: A lot of people use emacs, and I presume a lot of people use the emacs-mode.  A lot people also use vim and a vim mode.  Others use other things.
16:38:30 * copumpkin gets the impression his pain is coming from assuming his type family addition is injective
16:39:34 <ddarius> Use a data family?
16:39:38 <dancor> ddarius: thanks, pickler/unpickler pair in http://lambda-the-ultimate.org/node/2243 looks interesting to me
16:40:06 <copumpkin> ddarius: for addition? that'd be pretty ugly I thin
16:40:09 <gwern> aavogt: that seems to've been it
16:40:16 <ddarius> copumpkin: Probably.
16:40:22 <ddarius> dancor: Look also at Nick Benton's work.
16:41:50 <copumpkin> meh, take and drop are a pain to write yourself
16:41:51 <Scriptor> ddarius: sorry for the late reply, you can specify requirements for knowledge so they probably will know how to program
16:41:58 * copumpkin should just use SHE
16:42:12 <copumpkin> but the latest darcs version of SHE doesn't seem to be working and I'm too lazy to find out why
16:42:33 <dancor> ddarius: i'm not sure what's relevant looking at http://research.microsoft.com/en-us/um/people/nick/publications.htm
16:42:57 * copumpkin needs a pi type
16:43:17 <jlouis> mmmm
16:43:23 <jlouis> They exist you know
16:43:30 <jlouis> in Dependent types :P
16:43:38 <copumpkin> not only
16:43:47 <ddarius> jlouis: He does know.  He's an Agda fanboy.
16:43:50 <copumpkin> lol
16:43:53 <jlouis> haha
16:43:54 <Walt> ddarius, what do you mean with "vim mode"? a collection of scripts?
16:44:06 <copumpkin> I am an agda fanboy :(
16:44:11 <jlouis> I am more of a Coq fanboy currently, but I have yet to seriously try Agda
16:44:27 * copumpkin is just trying to write a sized vector in haskell with take/drop
16:44:41 <copumpkin> drop :: Vec (m :+: n) a -> Vec n a
16:45:06 <copumpkin> and I can't get my type variables to behave nicely in the helper classes
16:45:20 <ddarius> dancor: Hmm, I might have been thinking of "Embedding Interpreters" and if that is the case, then I think I'm thinking of a different paper (by a different author) that uses a similar approach.
16:45:33 <dancor> ah
16:45:57 <ddarius> Walt: I guess.  I haven't used the vim haskell-mode and I don't use anything else described as a "mode" for vim.
16:46:21 <Walt> ddarius, I dont even know what a mode means in a vim context
16:46:33 <copumpkin> what's even more amusing is getting an error from instance Drop m n => Drop (S m) n where that says Could not deduce (Drop m n)
16:46:53 <MissPiggy> copumpkin, drop :: Vec (m :+: n) a -> Vec n a -- wow how do you implement that?
16:46:59 <Dementati> ddarius: Not even command mode? =]
16:47:04 <copumpkin> MissPiggy: I fail, for now :P
16:47:18 <MissPiggy> copumpkin, it seems impossible to me!
16:47:22 <jlouis> haha
16:47:26 <MissPiggy> well I don't know what :+: is exactly..
16:47:27 <copumpkin> MissPiggy: I'm pretty sure it's possible :o
16:47:33 <copumpkin> it's a type family for type-level addition
16:47:41 <MissPiggy> yeah then I think it's impossible! prove me wrong :)
16:47:54 * MissPiggy is an epigram fan -- obviously...
16:47:56 <copumpkin> just curious, why is it impossible?
16:48:26 <Walt> Dementati, ah right, well, you know what I meant
16:48:32 <Heffalump> MissPiggy: why obviously?
16:48:51 <jpcooper> hello
16:48:54 <copumpkin> I guess the type signature will be a pain to call unless I pass in the m
16:48:58 * copumpkin tries that
16:49:00 <Dementati> Walt: Hm?
16:49:12 <jpcooper> which data type should I use for Ratio to get bigger numbers than Int?
16:49:24 <MissPiggy> Heffalump e-pig-ram
16:49:32 <copumpkin> oh!
16:49:36 <copumpkin> I hadn't made the connection :)
16:49:38 <jpcooper> took me a while to figure out why I was getting negative probabilities
16:49:42 <aavogt> @type Rational
16:49:43 <lambdabot> Not in scope: data constructor `Rational'
16:49:52 <Heffalump> do you use/hack on epigram then?
16:49:52 <copumpkin> oh sweet
16:49:52 <jpcooper> at least I hope it's because the integers are wrapping around
16:49:56 <copumpkin> MissPiggy: I wrote it :P
16:50:00 <copumpkin> but I added a parameter
16:50:13 <aavogt> jpcooper: Integer isn't bounded
16:50:18 <copumpkin> to force it to figure out the m for the non-injective type family
16:50:30 <MissPiggy> hhm can you show me?
16:50:38 <jpcooper> aavogt: but Int is, right?
16:51:06 <aavogt> > maxBound :: Int
16:51:07 <lambdabot>   9223372036854775807
16:51:10 <copumpkin> MissPiggy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7798#a7798
16:51:17 <copumpkin> MissPiggy: it may not be correct :P
16:51:19 <copumpkin> let me test it
16:51:26 <jpcooper> maxBound :: Integer
16:51:34 <dayz> hi
16:51:35 <dayz> can automated first order provers prove something like, a(x,y) = b(x,y) * c(x,y) given c(x,y)=a(x,y) / b(x,y)? is it decidable?
16:51:50 <jpcooper> 13!
16:52:01 <copumpkin> MissPiggy: nope, it works
16:52:15 <MissPiggy> dayz: yes sure
16:52:21 <jpcooper> hmm. I'm evaluating 13! different card deals, so I can't be going over the limit
16:52:31 <copumpkin> > product [1..13]
16:52:31 <jpcooper> oh well. I'll look for the bug elsewhere
16:52:32 <lambdabot>   6227020800
16:52:53 <medfly> > 2^64 - 1
16:52:54 <lambdabot>   18446744073709551615
16:52:57 <MissPiggy> copumkin, ahh that's a typeclass though! I thuoght you were doing it as a single function :)
16:52:57 <medfly> > 2^63 - 1
16:52:58 <lambdabot>   9223372036854775807
16:53:04 <medfly> > 2^31 - 1
16:53:05 <lambdabot>   2147483647
16:53:07 <copumpkin> MissPiggy: oh, no :P I wish
16:53:15 <medfly> jpcooper, hope it's 64bit?:)
16:53:18 <copumpkin> in that case I think you're right that it isn't possible
16:53:22 <jpcooper> medfly: yes
16:54:18 <dayz> MissPiggy, hmm but isn't FOl semidecidable? the language which as predicates with arity >2 is undecidable, right?
16:54:30 <jpcooper> I have no minus signs anywhere, so I can't see why I should be getting minus signs in my supposed probabilities
16:54:48 <MissPiggy> dayz: it looked likee a trival statement in group theory or something
16:55:06 <Twey> Grrr
16:55:11 <ddarius> @src Rational
16:55:11 <lambdabot> type Rational = Ratio Integer
16:55:21 <Twey> I cannot get GHCi to see Happstack.Util
16:56:20 <MissPiggy> dayz geez..
16:56:32 <ddarius> jpcooper: Why aren't you using Rational?
16:56:41 <dayz> MissPiggy, hm?
16:56:49 <jpcooper> ddarius: I'll give it a try
16:57:20 <ddarius> jpcooper: Okay, a similar question, why didn't you use Rational from the get-go?  Why use Ratio Int?
16:57:21 <dayz> I can get the prover to prove that if each function has only an arity of 1. but somehow not 2.
16:58:03 <jpcooper> ddarius: I have no specific reason
16:58:16 <jpcooper> I hadn't used Ratio before
17:00:28 <jpcooper> how do I convert an Int to an Integer?
17:00:41 <ddarius> @quote fromIntegral!
17:00:41 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:00:49 <jpcooper> thanks
17:02:39 <Esteban25> hey, i'm having a problem with higher order functions, can anyone givem e ahint? : http://www.pastebin.com/m4b450f33
17:02:50 <jlouis> jpcooper: fromIntegral and realToFrac are the type conversion workhorses for integers and doubles respectively
17:02:57 <Esteban25> i need to be able to pass a (>=) function but its not letting me
17:03:19 <Esteban25> as a second parameter
17:03:26 <MissPiggy> Esteban25, it's just because you wrote it as g
17:03:31 <MissPiggy> Esteban25, try this instead:
17:03:39 <MissPiggy> funcion f (>=) (x:xs) | (f (snd (x))) >=  2000 = (fst x): cobraBonoVentas xs
17:04:09 <Esteban25> but (>=) needs to be passed on the function call
17:04:16 <MissPiggy> yes
17:04:16 <MissPiggy> it is
17:04:30 <MissPiggy> funcion f (>=>=>=) (x:xs) | (f (snd (x))) >=>=>=  2000 = (fst x): cobraBonoVentas xs
17:04:33 <MissPiggy> that should work too
17:04:38 <MissPiggy> but it's the same idea really, just a different name
17:04:40 <Esteban25> something like funcion sum (>=) [list]
17:04:46 <Esteban25> let me check that one
17:04:50 <monochrom> If you like to call it g, (f (snd (x))) `g`  2000
17:04:53 <dayz> strange enough.. i can prove a(x,y) = b(x,y) / c(x,y) given c(x,y)=a(x,y) * b(x,y) but not a(x,y) = b(x,y) * c(x,y) given c(x,y)=a(x,y) / b(x,y)
17:05:25 <monochrom> Of course, could also be g (f (snd (x))) 2000
17:05:43 <ddarius> dayz: Unless you have some extra conditions, that first statement isn't true.
17:06:27 <ddarius> If for any x and y, a(x,y) or b(x,y) is zero, then b(x,y)/c(x,y) is undefined.
17:06:50 <dayz> ddarius, sorry. typo. prove a(x,y) = c(x,y)/b(x,y) given c(x,y)=a(x,y)*b(x,y)
17:07:18 <Esteban25> how is ` ` supposed to work?
17:07:26 <monochrom> enables infix syntax
17:07:27 <copumpkin> gah, I wrote drop and now I can't write take
17:07:30 <Esteban25> ahh
17:07:39 <dayz> ddarius, and yes, b(x,y) or a(x,y) are > 0
17:07:39 <monochrom> > 4 `mod` 3
17:07:40 <lambdabot>   1
17:07:41 <Esteban25> i get it now
17:07:47 <Esteban25> > mod 4 3
17:07:48 <lambdabot>   1
17:08:39 <Esteban25> haskell is hard but nice
17:09:14 <MissPiggy> I agree
17:13:33 <damd> uhm...that's what she said.
17:13:35 <damd> HIYOOOO
17:24:08 <dobblego> @pl \f a b -> Just (case a of Nothing -> b; Just k -> f b k)
17:24:08 <lambdabot> (line 1, column 35):
17:24:08 <lambdabot> unexpected ">"
17:24:08 <lambdabot> expecting variable, "(", operator or ")"
17:24:12 <dobblego> boo
17:24:18 <Twey>  @pl can't do case
17:24:26 <Twey> For obvious reasons
17:24:54 <copumpkin> it could probably figure it out for a case like that
17:25:01 <copumpkin> :t  \f a b -> Just (case a of Nothing -> b; Just k -> f b k)
17:25:02 <lambdabot> forall t a. (a -> t -> a) -> Maybe t -> a -> Maybe a
17:25:31 <medfly> :t maybe
17:25:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:25:36 <copumpkin> that's almost it
17:25:40 <medfly> ?
17:25:43 <dobblego> @type \f a b -> Just (fromMaybe b (fmap (f b) a))
17:25:44 <lambdabot> forall a a1. (a -> a1 -> a) -> Maybe a1 -> a -> Maybe a
17:25:57 <dobblego> oh maybe, the cata
17:26:38 <dobblego> @type \f a b -> Just (maybe b (f b) a)
17:26:39 <lambdabot> forall b a. (b -> a -> b) -> Maybe a -> b -> Maybe b
17:26:50 <dobblego> @pl \f a b -> Just (maybe b (f b) a)
17:26:51 <lambdabot> ((Just .) .) . flip . ap maybe
17:27:13 <Twey> @pl \f a b -> Just $ maybe b (f b) a
17:27:14 <lambdabot> ((Just .) .) . flip . ap maybe
17:27:17 <Twey> Oh, you got there already :þ
17:27:24 <copumpkin> why do you want the result in Maybe if it's unconditionally Just?
17:27:32 <Twey> Good point
17:27:36 <Twey> @pl \f a b -> maybe b (f b) a
17:27:36 <lambdabot> flip . ap maybe
17:27:46 <medfly> :-p
17:27:57 <dobblego> I want a maximum that doesn't error on []
17:28:09 <Twey> I can't get GHCi to see Happstack.*.  It's delaying my project.  ☹
17:28:38 <medfly> that's one angry face
17:28:44 <medfly> better fix it immediately
17:28:59 <Twey> The modules appear in ghc-pkg describe happstack-util, and happstack-util is listed in ghc-pkg list
17:29:09 <gwern> bleh. anyone remember what the wordcount of '10-12 standard double-spaced pages' is?
17:29:19 <Twey> medfly: I've been fighting with this for a few days now.  I'm ANGRY.  :þ
17:29:24 <SubStack> wordcounts are silly
17:29:31 <SubStack> minimum ones anyhow
17:29:45 <Twey> gwern: Depends on what characters you type
17:29:52 <gwern> -_- assume ascii
17:30:13 <medfly> there's a wordcount? :)
17:30:19 <SubStack> fixed width fonts or otherwise?
17:30:25 <adu> gwern: depends on the average wordsize
17:30:26 <gwern> tiems new roman
17:30:27 <Twey> gwern: Still depends on what characters you type
17:30:29 <Twey> Right
17:30:31 <copumpkin> ascii on zapfino?
17:30:36 <Twey> TNR is proportional
17:30:37 <medfly> there's ##english :S
17:30:42 <gwern> copumpkin: I've never even heard of zapfino
17:30:44 <Twey> Question doesn't have an answer
17:30:57 <copumpkin> I think he's looking for a lower and upper bound
17:31:01 <medfly> for probably less anal answers
17:31:19 <gwern> ok, let's try it this way, is 2200 words within a page of 10-12 standard double-spaced times new roman setting prose written in standard american english
17:31:30 <adu> gwern: my estimate would be 18,000 words
17:31:38 <copumpkin> lol
17:31:42 <idnar> ?!?
17:31:54 * copumpkin remembers to avoid asking adu for estimates in future
17:31:59 <gwern> adu: a novel is around 100k words, so in your world novels are about 50 pages long?
17:32:01 <medfly> doesn't a word processor answer this
17:32:09 <idnar> you must have really powerful reading glasses
17:32:11 <medfly> gwern, oh, I read novels like that
17:32:14 <gwern> medfly: dammit I'm in #haskell do you think I use word processors
17:32:30 <adu> how many lines are there on a standard double-spaced page?
17:32:30 <medfly> gwern, well it looks like this question requires a word processor
17:32:43 <medfly> worst case scenario, just try printing
17:32:43 <copumpkin> process :: [Word] -> Fail
17:32:56 <gwern> may the fleas of a thousand chias infest y'all's beard!
17:32:58 <damd> > (:"enis") 'p'
17:32:59 <lambdabot>   "penis"
17:33:00 <medfly> gwern, if it doesn't work, print both sides. still within "a page", right?
17:33:02 <damd> :O
17:33:10 <SubStack> I don't even have openoffice installed anymore
17:33:21 <SubStack> since I type everything out in latex anyways
17:33:29 <copumpkin> @let zomg w = w ++ " the p" ++ w
17:33:30 <lambdabot>  Defined.
17:33:33 <copumpkin> > zomg "elvis"
17:33:34 <lambdabot>   "elvis the pelvis"
17:33:39 <medfly> hehehe
17:33:53 <medfly> that's a silly function
17:34:03 <monochrom> > zomg "rune"
17:34:04 <lambdabot>   "rune the prune"
17:34:14 <gwern> it's about 9 pages in OO but the rest of the world uses MS word
17:34:15 <idnar> and here I was expecting "zomg" to be a completely serious function
17:34:17 <damd> 'zomg' composes an isomorphic distribution group
17:34:18 <gwern>  well, close enough
17:34:19 <medfly> > zomg "am"
17:34:20 <lambdabot>   "am the pam"
17:34:31 <idnar> > zomg "lume"
17:34:33 <lambdabot>   "lume the plume"
17:34:40 <damd> > zomg "fuck"
17:34:41 <lambdabot>   "fuck the pfuck"
17:34:54 <SubStack> > zomg "purple"
17:34:55 <lambdabot>   "purple the ppurple"
17:35:17 <SubStack> > zomg "multiple words"
17:35:18 <lambdabot>   "multiple words the pmultiple words"
17:35:20 <Twey> 10 pages is 37440 letter i's or 13260 m's.  12 pages is 44928 i's or 15912 m's.
17:35:31 <adu> gwern: i think 9 pages is less than 10
17:35:32 <Twey> @ gwern
17:35:42 <SubStack> assignments should be specified in utf8 string lengths
17:35:43 <copumpkin> SELECT * FROM words a INNER JOIN words b ON a.value = 'p' || b.value
17:35:44 <gwern> adu: ah but it's within 1 page as I specified
17:35:45 <damd> @let zomg = "penis"
17:35:45 <lambdabot>  <local>:12:0:
17:35:46 <lambdabot>      Equations for `zomg' have different numbers of arguments
17:35:46 <lambdabot> ...
17:35:55 <damd> @let zomg = const "penis"
17:35:56 <lambdabot>  <local>:12:0:
17:35:56 <lambdabot>      Equations for `zomg' have different numbers of arguments
17:35:56 <lambdabot> ...
17:36:00 <medfly> @undefine
17:36:01 <damd> bah
17:36:11 * copumpkin wonders if his SQL works
17:36:13 <medfly> @let zomg = "penis"
17:36:14 <lambdabot>  Defined.
17:36:21 <monochrom> > zomg ""
17:36:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
17:36:22 <lambdabot>         against inferr...
17:36:26 <copumpkin> fail
17:36:26 <medfly> heh
17:36:56 <adu> damd, medfly, please stop
17:37:11 <medfly> he left
17:37:11 <Twey> Divide by five to get a word count gives us 7488 words of i's, 2652.0 words of m's for ten pages, and 8985.6 words of i's or 3182.4 words of m's for twelve
17:37:14 <medfly> I made hisstuff work
17:37:34 <copumpkin> how many Ws?
17:37:44 <medfly> lol
17:37:59 <medfly> what's a word of i
17:38:10 <adu> Twey: is that double-spaced?
17:38:21 <Twey> We can estimate, then, by taking a mean, that ten pages will be 5070 words, and twelve pages 6084 words
17:38:22 <copumpkin> medfly: five is in a row
17:38:24 <Twey> gwern
17:38:26 <Twey> adu: Yes
17:38:28 <gwern> Twey
17:38:39 <copumpkin> Twey: did you take into account the distribution of letter usages in common english?
17:38:40 <Twey> adu: Double-spaced 12pt Times New Roman, on A4 pages
17:38:50 <idnar> etaoin shrdlu
17:38:50 <Twey> I believe that's the ‘standard’ referred to
17:38:51 <medfly> lol
17:38:51 <copumpkin> oh, A4
17:38:55 <Twey> copumpkin: Sadly not
17:38:58 <copumpkin> gwern is in the US
17:39:01 <adu> Twey++
17:39:01 <copumpkin> clearly he doesn't want A4
17:39:02 * adu <3 A4
17:39:08 <Twey> They don't use A4 in the US?
17:39:16 <monochrom> Not too different.
17:39:17 * gwern shrugs. paper usually comes in one size here
17:39:18 <copumpkin> hell no, we have irregular paper sizes
17:39:20 <idnar> supposedly they use US Letter
17:39:22 <medfly> ?!
17:39:23 <lambdabot> Maybe you meant: . ? @ v
17:39:24 <Twey> Oh, bloody hell
17:39:31 <adu> Twey: maybe at some secret government lab
17:39:32 <medfly> you've gotta be joking...
17:39:36 <SubStack> pretty sure people use A4 here
17:39:39 <copumpkin> it's too easy to be able to split paper in half and get another useful size
17:39:44 <Twey> >.<
17:39:48 <adu> Twey: the US government uses Letter for all official documents
17:39:48 * medfly checks wikipedia...
17:39:55 <Twey> adu: But do universities?
17:40:16 <adu> Twey: 9/10 office stores don't even carry A4
17:40:23 <idnar> how about C4?
17:40:25 <Twey> Seriously?  Argh.
17:40:29 <copumpkin> BOOM
17:40:38 <Draconx|Laptop> Twey, in Canada, and I assume the US as well, A4 paper is non-trivial to acquire.
17:40:43 <SubStack> it's pretty silly that we still use paper
17:40:52 <dons> dolio: ping?
17:40:53 <idnar> SubStack: who is this "we"?
17:40:53 <Draconx|Laptop> SubStack, nobody's invented anything better yet.
17:40:56 <dolio> pong
17:40:59 <SubStack> idnar: humanity
17:41:00 <Twey> SubStack: Monitors are still kind of expensive
17:41:05 <SubStack> Draconx|Laptop: see computers
17:41:09 <monochrom> We should use gold foils
17:41:11 <ksf> "This specification should be read like all other specifications. First, it should be read cover-to-cover, multiple times. Then, it should be read backwards at least once. Then it should be read by picking random sections from the contents list and following all the cross-references."
17:41:15 <idnar> SubStack: I'm a bot, who cares about humanity? ;P
17:41:23 <Draconx|Laptop> SubStack, I have yet to see a computer display that looks better than print.
17:41:33 <adu> yes, getting A4 paper in the US is like obtaining a new copy of Windows XP these days
17:41:45 <medfly> people have invented tablets,but somehow modern humans refuse to use them
17:41:47 <medfly> what is this laziness
17:42:02 <SubStack> I hate staring at paper personally.
17:42:09 <copumpkin> BAH
17:42:12 <medfly> adu, I'm having second thoughts about wanting to visit your part of the world.
17:42:13 <copumpkin> I can't write take :(
17:42:29 <monochrom> Try writing give first :)
17:42:34 <xerox> yeah what about undo-able prints, no ink needed http://www.engadget.com/2010/02/09/prepeat-rewritable-printer-lets-you-undo-print-jobs-no-ink-or-t/
17:42:39 <copumpkin> :(
17:42:43 <gwern> @src take
17:42:43 <lambdabot> take n _      | n <= 0 =  []
17:42:44 <lambdabot> take _ []              =  []
17:42:44 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
17:42:48 <gwern> doesn't look too hard
17:42:51 <Twey> take 0 xs = xs; take (n + 1) (x:xs) = x : take n xs
17:42:53 * Twey hides
17:43:01 <adu> medfly: don't, the only good thing about the US is that it is near Winnipeg
17:43:04 <copumpkin> take :: -> Vec (m :+: n) a -> Vec n a
17:43:08 <Twey> Oh, and take _ [] = []
17:43:09 <SubStack> Twey: n-1?
17:43:11 <medfly> adu, what's winnipeg?
17:43:12 <Entroacceptor> medfly: anything with a dpi<600 isn't worth reading from :)
17:43:20 <Draconx|Laptop> medfly, a city.
17:43:21 <Twey> SubStack: (n + 1) ;)
17:43:33 <dolio> dons: pong
17:43:38 <copumpkin> pang
17:43:42 <gwern> ping
17:43:43 <gogonkt> PONG, now at #haskell
17:43:43 <adu> medfly: http://en.wikipedia.org/wiki/Winnipeg
17:44:20 <medfly> adu, looks cold
17:45:07 <adu> it looks warmer than where I am right now... DC... oh the snow...
17:45:34 <SubStack> there aren't enough breadth-first list monads
17:45:56 <MissPiggy> why not
17:46:48 <SubStack> I want one with alpha-beta pruning
17:46:53 <SubStack> jmcarthur claims to have built such a thing
17:46:54 <MissPiggy> is that a monad
17:47:15 <MissPiggy> SubStack what about LogicT
17:47:25 <MissPiggy> I think there's an example of alpha-beta in there
17:48:30 <SubStack> hmmm
17:51:59 <copumpkin> anyone have any ideas? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7798#a7799
17:53:28 <dolio> copumpkin: Write take :: Vec (m :+: n) a -> Vec m a instead.
17:54:54 <copumpkin> dolio: good idea :P
17:54:55 <copumpkin> thanks
17:55:01 <copumpkin> I still need the extra parameter I think?
17:55:22 <copumpkin> yeah
17:55:30 <dolio> If you really need it for drop, then yes.
17:55:50 <copumpkin> well, it can't figure out that if x is a :+: b, then if I have a I can figure out b
17:57:22 <dolio> What GHC can actually figure out with regard to those is still not particularly intuitive to me.
17:57:41 <copumpkin> they added a more descriptive error to what it can't figure out in 6.12, at least
17:57:51 <copumpkin> they say "this is a type family, not injective, be careful!" or something along those lines
18:05:26 <DevHC> is anyone updating haskell-98-tutorial.pdf?
18:08:02 <Veinor_> I'm playing around with basic parsec stuff, and I can't get the simple = letter example to work
18:10:24 <Veinor_> oh hey, it's the monomorphism restriction!
18:10:29 <Veinor_> ...
18:13:05 <gwern> DevHC: probably not. how much is it worth to you?
18:16:11 <copumpkin> hmm, I'm going to need a better strategy to go from Vec to balanced trees
18:28:17 <EvilMachine> hey, I have a question on how to design something that is a bit “meta”. anyone reading this at these times? :)
18:28:20 <DevHC> gwern: not at all
18:28:41 <DevHC> (just noticed a couble of bugs :P)
18:28:46 <gwern> DevHC: then you can hardly care
18:28:58 <gwern> EvilMachine: we are legion. we always lurk.
18:29:17 <EvilMachine> :)
18:33:06 <Alpounet> EvilMachine, so, go ahead, explain
18:35:20 <EvilMachine> let’s say i have an interface to a class. a class of functions that take xml-like data, and returns the data with some changes. now i want the interface to have a function, that allows a user to set some parameters of that function. ok, all fine. BUT: I want to be able to set the parameters, no matter what the actual type of that function is. (type agnostic) so that i get a generic interface.
18:35:32 <EvilMachine> does this make sense? ;) how would i do that?
18:36:22 <Cale> I don't understand
18:36:30 <EvilMachine> additional info: the reason that i can not make assumptions about the function’s exact type, and have to use a class, is that they are supposed to be user-defined extension modules.
18:36:39 <EvilMachine> with user-defined parameter types
18:38:58 <Zeiris_> Can you use ! on mutable arrays, or do you have to use readArray instead?
18:39:17 <EvilMachine> maybe i can explain it in a more basic way: let’s just say i want to formally define this in haskell: „the type ‘plugin‘, that takes a set of parameters (depending on the plugin, of course), and then can, based on those parameters, be used to process data of a xml-like data type”
18:39:34 <monochrom> cannot use ! on mutable arrays.
18:39:58 <ddarius> The type system explains all of this.
18:40:09 <ddarius> Who needs educators when you have a type system?
18:40:13 <EvilMachine> ddarius: did you mean me?
18:41:47 <EvilMachine> hmm… seems to be a hard nut, my question? ;)
18:43:15 <Saizan> i'm not sure how you can even think of setting the parameters generically if they are specific to the type?
18:43:56 <EvilMachine> Saizan: hi. :) what do you mean by “specific to the type”?
18:44:36 <Saizan> well, that each plugin has its own set
18:44:59 <Saizan> i thought that meant that each plugin has different kind of parameters
18:45:09 <Saizan> +a
18:45:43 <Veinor> I'm playing around with Parsec; how can I write a parser that succeeds only on balanced parens?
18:46:47 <EvilMachine> Saizan: wait, i think one could say it like this: my “plugin” type should not actually know or define anything about the “parameter set” type. it should just define that it must exist. nothing more. the actual handling will be done in the actual plugin implementation, and its corresponding UI implementation. those would have to know how to handly the “parameter set” type. but my program should not have to know it
18:47:02 <EvilMachine> +is
18:47:46 <EvilMachine> Saizan: Correction: those would have to know how to handly THEIR “parameter set” type. (and theirs only)
18:48:47 <EvilMachine> Saizan: don’t hold back in case you see a more Haskell-way-like way of thinking about this. :)
18:49:06 * EvilMachine can take it. ^^
18:49:11 <ddarius> Veinor: fix parens
18:49:58 <Veinor> ddarius: ?
18:50:01 <ddarius> fix (\p -> parens p <|> return ())
18:50:22 <lpsmith> preflex,  seen zygloid
18:50:22 <preflex>  Sorry, I haven't seen zygloid
18:50:24 <copumpkin> this shit is hard!
18:50:27 <lpsmith> preflex,  seen zygoloid
18:50:27 <preflex>  zygoloid was last seen on #haskell 8 hours, 33 minutes and 16 seconds ago, saying: > let !True = False in 3 * 3
18:50:38 <copumpkin> I'm probably doing it wrong!
18:50:46 <Saizan> EvilMachine: how does setting the parameters come into this?
18:50:59 <lpsmith> I'm usually doing it wrong...
18:51:26 <Saizan> when you're describing sounds like Plugin should be an existential type quantifying over the "parameter set" type
18:51:50 <Saizan> s/when/what/
18:52:46 <Saizan> with methods to fetch the values for the parameters via the UI, and to accept them by the plugin
18:53:21 <EvilMachine> Saizan: well, since the “plugin” interface would just declare that a corresponding “parameter set” type exists, and also specify, that a “plugin” can “take” (via the setter for that property of the object) such a corresponding “parameter set“…
18:53:48 <Saizan> data Plugin = forall params. Plugin { getParams :: UI params; runPlugin :: params -> Something }
18:54:47 <omgacow> Enter text here...Hello
18:55:14 <EvilMachine> Saizan: or did you mean: “how would one actually change anything inside a specific “parameter set” (for a specific “plugin‘)?… well: the corresponding “pluginUI” would handle that like a black box. so we would never have to think about it in the core module that contains the master “plugin” interface.
18:55:51 <EvilMachine> Saizan: give me time to understand that forall again. :)
18:55:54 <Saizan> EvilMachine: ok, i thought you were asking for a way to edit the parameters of an arbitrary plugin from the outside
18:56:32 <Saizan> EvilMachine: but what you're describing is simpler and that Plugin type should capture the gist of it
18:56:39 <EvilMachine> Saizan: hey, your example above looks really good. i think that’s what i meant. :)
18:57:19 <Saizan> cool :)
18:57:38 <EvilMachine> Saizan: yes. it is supposed to be as generic as physically possible for a description of a plugin that has a parameter/property set (think photoshop plugins)
18:57:50 <EvilMachine> Saizan: thank you! :D
19:05:32 <joe1> @hoogle split
19:05:33 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
19:05:33 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
19:05:33 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
19:10:18 <EvilMachine> Saizan: what is the pragma again, that enables this forall.?
19:13:38 <Saizan> EvilMachine: ExistentialQuantification
19:14:47 <joe1> is there a function to split a string such as "abcdef" to ["abc","ef"]. I do not need the "abc" and was thinking of using dropWhile. wondering if that is the best approach?
19:15:26 <joe1> dropWhile (<> 'd') "abcdef"
19:15:29 <joe1> > dropWhile (<> 'd') "abcdef"
19:15:30 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
19:15:30 <lambdabot>         agains...
19:15:41 <Saizan> > dropWhile (/= 'd') "abcdef"
19:15:42 <lambdabot>   "def"
19:15:51 <Saizan> > brak (/= 'd') "abcdef"
19:15:52 <lambdabot>   Not in scope: `brak'
19:15:53 <joe1> saizan: thanks.
19:15:54 <Saizan> > break (/= 'd') "abcdef"
19:15:55 <lambdabot>   ("","abcdef")
19:16:01 <Saizan> > span (/= 'd') "abcdef"
19:16:02 <lambdabot>   ("abc","def")
19:17:16 <EvilMachine> Saizan: hmm… it always gives me parse error on input `;' (char 60) for your example.
19:17:40 <Saizan> EvilMachine: ah, yeah, you need a , there
19:17:50 <EvilMachine> Ah, ok. :)
19:18:53 <EvilMachine> i should have known that. ;)
19:22:07 * Saizan wishes the record syntax were more like the declaration syntax
19:26:44 <EvilMachine> what are escaped type variables (inside a class declaration)?
19:38:12 <copumpkin> hmm
19:41:24 <dobblego> @hoogle maxBy
19:41:24 <lambdabot> No results found
19:42:18 <medfly> @hoogle maximumBy
19:42:19 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
19:42:19 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
19:42:56 <dobblego> @src max
19:42:56 <lambdabot> max x y = if x <= y then y else x
19:52:06 <alatter> hi haskell!
19:52:24 <Zao> Ehlo.
19:58:28 * copumpkin hates writing show instances
19:58:38 <copumpkin> (GADT, so no autoderivation)
19:59:50 <Veinor> Gon't Ask Don't Tell
20:03:36 <tensorpudding> geriatric armored duck troopers
20:14:42 <EvilMachine> hmm, why does the following make no sense? data TR p = TP p -> OG -> OG
20:14:59 <EvilMachine> oops
20:15:04 <EvilMachine> TP=TR
20:15:51 <EvilMachine> copumpkin: Can’t you automatically derive them?
20:15:58 <copumpkin> not with GADTs
20:16:02 <EvilMachine> copumpkin: ah ok
20:16:32 <Veinor> EvilMachine: because you're trying to define it in terms of itself?
20:17:06 <copumpkin> ?
20:17:18 <EvilMachine> Veinor: ok, then that line does mean something entierly different from what i thought it meant. ;)
20:17:23 <copumpkin> missing parentheses?
20:17:33 <copumpkin> data TR p = TR (p -> OG -> OG) ?
20:17:33 <Zeiris_> In this snippet http://paste.factorcode.org/paste?id=1411 the code "let (choice,gen) = randomR (0, length directions - 1) gen" eventually ends up in a <<loop>> once "choice" gets evaluated. What could cause that?
20:17:48 <Veinor> copumpkin: isn't that still recursive?
20:17:53 <copumpkin> Veinor: nope
20:17:59 <EvilMachine> copumpkin: lol, yes
20:18:01 <copumpkin> TR on RHS is data constructor
20:18:01 <Veinor> ... oh, yeah
20:18:14 <EvilMachine> copumpkin: thx
20:18:27 <Veinor> I was parsing it as TR p = TR (TR (p -> OG -> OG))
20:18:31 <copumpkin> :)
20:18:33 <Veinor> or something.
20:18:38 <Zeiris_> Is it the fact that I assign to gen, from gen? There's no name overriding?
20:18:55 <copumpkin> data OMG a = OMG (OMG a -> a)
20:19:00 <copumpkin> try that
20:19:03 <Veinor> yeah. that's recursive.
20:19:17 <LordofKings> can some one help me how to understand Monads ...ljnks would be helpful
20:19:23 <LordofKings> links*
20:19:31 <Cale> LordofKings: Well, I wrote some tutorials
20:19:33 <copumpkin> LordofKings: how long have you been haskelling?
20:19:41 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
20:19:48 <dobblego> LordofKings, http://blog.tmorris.net/what-does-monad-mean/
20:19:50 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
20:20:00 <LordofKings> well don't remmember exactly..
20:20:03 <copumpkin> Zeiris_: yeah, that makes it circular
20:20:09 <Zeiris_> Woops, so it does.
20:20:11 <LordofKings> its an on/off relation with haskell
20:20:18 <Zeiris_> Nice to see that laziness is working though :)
20:20:22 <copumpkin> :)
20:21:09 <copumpkin> http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html, is the type signature for fold correct in there?
20:21:16 <copumpkin> it seems to be missing a zero case
20:22:38 <ddarius> Read "The essence of functional programming."
20:23:09 <dobblego> @where essencefp
20:23:09 <lambdabot> I know nothing about essencefp.
20:23:52 <roconnor> anyone have an example of a non-trivial comonoid?
20:24:18 <ddarius> roconnor: In any category?
20:24:38 <roconnor> sure, cause I think they are all trivial in cartiesian categories
20:24:39 <dobblego> @where+ essencefp http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps
20:24:39 <lambdabot> Good to know.
20:24:51 <dolio> roconnor: Comonads.
20:24:54 <roconnor> no
20:24:59 <roconnor> comonoids
20:25:03 <ddarius> roconnor: You misunderstood dolio.
20:25:05 <ddarius> He is correct.
20:25:07 <dolio> Comonads are comonoids.
20:25:10 <roconnor> ah
20:25:14 <copumpkin> are comonoids in categories of endofunctors? :P
20:25:23 <roconnor> copumpkin: I assume so
20:25:27 <roconnor> duh
20:25:41 <roconnor> good
20:25:52 <roconnor> it will give me something to think about
20:26:09 <ddarius> roconnor: Comonoids also often come up in the semantics of linear logics to handle weakening and contraction.
20:26:16 <sm> has anyone got a systematic process for designing and debugging parsec parsers ?
20:26:17 * roconnor tries to figure out what the tensor product is.
20:26:26 <ddarius> roconnor: In CT, it isn't anything.
20:26:28 <sm> that doesn't make your brain hurt ?
20:26:39 <ddarius> roconnor: It's the product of the monoidal category that you provide.
20:26:49 <roconnor> sure
20:26:53 <copumpkin> what's the tensor pudding?
20:27:00 <ddarius> sm: Start from the EBNF. Done.
20:27:04 <roconnor> in the case of comonads, aka endorfunctors
20:27:12 <SamB_XP_> copumpkin: it's where you find the proof, I think
20:27:16 <ddarius> roconnor: Oh, composition.
20:27:16 <SamB_XP_> have a spoon
20:27:23 <copumpkin> lol
20:27:36 <roconnor> wow
20:27:40 <Cale> Hehe, now we need Tattooinefunctors
20:27:43 <roconnor> it doesn't sound very tesorish
20:27:46 <roconnor> but I guess it is
20:27:48 <sm> ok.. I'll try to write down an EBNF next time
20:27:53 <sm> first
20:27:56 <roconnor> I guess tensors are quite general
20:28:12 <ddarius> roconnor: As I said, "tensor" products in this context don't mean much.
20:28:16 <sm> rather than just mold one out of the code by gut feel.....
20:28:50 <roconnor> ddarius: are coproducts tensors?
20:29:02 <ddarius> roconnor: The "tensor product" nomenclature isn't very accurate or too helpful in my opinion.  Coproducts form a "tensor product"
20:29:07 <ddarius> roconnor: Yes.
20:29:25 <roconnor> ok
20:30:11 <roconnor> I guess comonoids with the coproduct tensor in Set could be non-trivial
20:30:46 * copumpkin grrs
20:32:09 <copumpkin> :t foldr
20:32:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:32:41 <roconnor> oh no
20:32:48 <roconnor> there won't be any counits
20:32:54 <ddarius> Indeed.
20:33:03 <roconnor> grr
20:33:10 <roconnor> comonoids are hard to find
20:33:13 <ddarius> You could consider the category of pointed Sets.
20:33:15 <Cale> The important thing which tensor products share with the operation in a monoidal category is the interchange law.
20:33:16 <roconnor> I mean, sure comonoids
20:33:32 <copumpkin> can anyone see anything obviously wrong with http://snapplr.com/7zp4 ? it seems pretty basic
20:33:33 <roconnor> er
20:33:40 <roconnor> I mean, sure comonads are comonoids
20:33:47 <roconnor> but they are a bit complicated
20:34:15 <ddarius> roconnor: A category that has interesting comonoids is not going to be too Set-like.
20:34:23 <copumpkin> oh I guess I can kill the constraints
20:34:37 <roconnor> Cale: um isn't a monoidal category a category with a tensor product?
20:34:44 <roconnor> or have I got the terminology wrong?
20:35:29 <ddarius> roconnor: He means the original notion of "tensor product" (I'm assuming)
20:35:29 <Cale> roconnor: Well, I mean that's why it's often called a tensor product
20:35:36 <kuitang> copumpkin: your fold f z (Cons x xs) is trying to pattern-match, right?
20:35:43 <copumpkin> yep
20:35:45 <kuitang> write fold f z (x:xs)
20:35:47 <copumpkin> it works fine if I take the Nat constraints
20:35:50 <copumpkin> I can't
20:35:52 <Cale> Yeah, I mean the tensor product in vector spaces, and the tensor product of linear maps
20:37:39 <Cale> If you have vector spaces V, V', W, W', and linear maps A: V -> V' and B: W -> W', you can define A ⊗ B: V ⊗ W -> V' ⊗ W' by  (A ⊗ B) (v ⊗ w) = (Av) ⊗ (Bw), and you get that (A . B) ⊗ (C . D) = (A ⊗ C) . (B ⊗ D)
20:37:55 <roconnor> ok
20:38:07 <Cale> and this 'interchange law' is something which you also get in any weak 2-category
20:38:31 <ddarius> The interchange law is just bifunctoriality.
20:38:36 <Cale> So in particular, monoidal categories, and strict 2-categories, like the category of small categories.
20:39:32 <copumpkin> FINALLY
20:39:46 <ddarius> INITIALLY
20:40:01 <copumpkin> :)
20:41:15 <copumpkin> this is a lot of work for not much benefit
20:41:20 <copumpkin> maybe I'll stop
20:41:40 * ddarius actually thinks of the interchange law for natural transformations now as just bifunctoriality.
20:42:46 <absentia> hi giga
20:43:07 <gigamonkey> Hi
20:43:08 <ddarius> gigamonkey: What have you been up to?
20:43:20 <gigamonkey> You guys see the thing about Gigamonkeys Quarterly?
20:43:25 <gigamonkey> Soon to be renamed.
20:43:48 <absentia> no
20:44:01 <Cale> "pruchase (19.99 €)" -- http://snapplr.com/
20:44:05 <gigamonkey> http://gigamonkeys.com/blog/2010/02/18/gigamonkeys-quarterly.html
20:44:33 <copumpkin> hmm, I need a type numeral logarithm
20:44:36 <leimy> anyone know a way to expedite the hackage account getting process?
20:44:42 * leimy has a package to contribute
20:44:45 <copumpkin> Cale: yep :P
20:45:25 <absentia> giga: I love the idea and will definitely follow that.
20:45:43 <copumpkin> Cale: YOU HAVE A PROBLEM WITH THAT?
20:46:15 <ddarius> leimy: It should be reasonably quick if Ross(?) isn't busy.  If he isn't being responsive, there are others you can talk to.
20:46:29 <ddarius> (Responsive meaning at least > 24 hours)
20:46:44 <ddarius> (or I guess non-responsive)
20:46:49 <leimy> ddarius: yeah... I'm thinking I won't get a shot again at uploading this until sunday or so if not tonight
20:47:00 <leimy> I just had a bunch of momentum  :-)
20:47:15 <gigamonkey> absentia: I'm imagining that some Haskellites would probably have stuff to contribute.
20:47:59 <absentia> sadly, I knew less haskell than scheme/lisp.. and my scheme/lisp is limited to small academic items.  but, ya, get haskellites involved.
20:47:59 <ddarius> gigamonkey: Well, this overlaps slightly (in the Haskell community) with The Monad Reader.
20:48:21 <absentia> this isn't highlander.. there can be more than one.
20:48:35 <gigamonkey> ddarius: yeah, I was trying to look at that yesterday when wordpress was down.
20:49:54 <gigamonkey> ddarius: I think the overlap is pretty slight.
20:51:16 <ddarius> gigamonkey: The licensing and distribution seems different, but the target audience and format seem similar (restricting to the Haskell community).
20:53:01 <gigamonkey> ddarius: eh? Gigamonkeys Quarterly is targeted at hackers of all stripes.
20:53:22 <ddarius> gigamonkey: Yes, hence my parenthetical comment.
20:53:37 <gigamonkey> Sorry, couldn't quite parse that.
20:53:42 <gigamonkey> The parenthetical, that is.
20:54:17 <gigamonkey> So the target audience of GMQ is a very large superset of that of the TMR.
20:54:18 <ddarius> gigamonkey: I'm saying people planning to make a Haskell related article would likely consider both venues about equal.
20:54:40 <gigamonkey> Unless they wanted to write something with a haskell flavor for a larger audience.
20:54:52 <gigamonkey> And potentially get paid. ;-)
20:55:13 <absentia> oooh
20:59:40 * copumpkin has a deinterleave function for sized vectors!
20:59:43 <copumpkin> zomg
21:01:07 * hackagebot upload: vector-binary-instances 0.1 - Instances of Data.Binary and Data.Serialize for vector (DonaldStewart)
21:01:18 <copumpkin> dons: nice!
21:04:48 <scutigera> speaking of binary vectors: what's the best way to write "double"'s to disk , i.e. the equivalent of fwrite(&x, sizeof(double), 1, s) ?
21:05:07 * copumpkin was just thinking of writing a quick vector-mmap
21:05:50 <scutigera> is this something that would require an ffi hack ?
21:06:32 <ddarius> scutigera: You presumably could use the Storable instance of CDouble.
21:06:33 <pikhq> scutigera: That is a terrible way to write doubles to disk.
21:06:53 <pikhq> scutigera: Like, "I will kill you for it".
21:07:04 <copumpkin> pikhq: not that terrible
21:07:21 <copumpkin> the Binary instances for Double are terrifying
21:07:25 <scutigera> pikhq: well obviously I wouldn't write an an array out 1 at a time
21:07:34 <pikhq> scutigera: That's not the horrible part.
21:08:02 <scutigera> pikhq: don't leave me in suspense...
21:08:08 <pikhq> scutigera: Do not, do not, *do not ever* just write the raw binary of C data to a file.
21:08:18 <copumpkin> hmm
21:08:19 <pikhq> It *will* break.
21:08:27 <copumpkin> it really depends what you're doing
21:08:44 <copumpkin> a lot of what I do involves storing temporary data to disk and I need it to save/load quickly
21:08:48 <copumpkin> it's same machine same arch
21:08:52 <scutigera> pikhq: well if you're using graph(plotutils) in binary mode and graphing 20000 vaules, it work _really_ well
21:08:54 <copumpkin> no need to convert to an arch-independent format
21:09:14 <pikhq> copumpkin: If you are willing to assume a specific architecture with specific compiler options with a specific compiler version, then it'll work just fine.
21:09:19 <pikhq> For instance, temporary data.
21:09:44 <pikhq> copumpkin: However, if you're doing that, you know enough to realise that you can ignore that advice. :P
21:09:49 <copumpkin> :)
21:09:55 * copumpkin doesn't know how he feels about http://hackage.haskell.org/package/mmap
21:09:58 <scutigera> well that's essentially what I am doing. I'm just doing it because graph is noticeably faster with binary rather than ascii input
21:10:05 <copumpkin> dependencies on bytestring and HUnit bother me
21:10:32 <copumpkin> HUnit dependency could be optional
21:10:35 <scutigera> ddarius: Storable and CDouble...thanks.
21:10:39 <copumpkin> so could bytestring
21:20:06 <dons> copumpkin: i like bytestring-mmap
21:20:21 <copumpkin> dons: yeah, I was going to follow its pattern
21:20:23 <dons> but it might not work on windows
21:20:33 <copumpkin> @hackage mmap
21:20:33 <dons> i didn't quite work out how to fill a vector in the Get monad, btw
21:20:33 <lambdabot> http://hackage.haskell.org/package/mmap
21:20:42 <dons> if you want to play with that (makes loading from Data.Binary more efficient)
21:20:58 <copumpkin> hm okay, I'll take a look
21:21:21 <dons> so no conversion via lists. but: unstream . stream get
21:21:22 <copumpkin> oh, the mmap package works on windows too
21:21:24 <dons> or some such.
21:21:27 <copumpkin> yeah
21:21:52 <copumpkin> you can have conditional dependencies in cabal, right?
21:21:55 <dons> yeah
21:28:30 <c_wraith> CPP is kinda fiddly.  I ended up having to absolutely minimize the file it was running on to eliminate errors.
21:28:51 <c_wraith> (like, move only the things that needed to be compiled conditionally to a different file
21:28:53 <c_wraith> )
21:32:02 <dancor> why is http://en.wikipedia.org/wiki/Boomerang_(programming_language) its own language instead of like an ocaml library/possibly-extension?
21:32:55 <ddarius> Ask Benjamin.
21:33:23 <dolio> So that it doesn't have to use OCaml's awful syntax?
21:35:16 <scutigera> dancor: hadn't seen that before, boomerang's pretty nifty
21:38:05 <dancor> ah what's this http://hackage.haskell.org/package/lenses
21:38:15 <dolio> Also, if you're trying to enforce some kind of bidirectional programming, embedding it in a language that lets you write arbitrary other stuff may not be the best idea.
21:39:18 <dancor> well naively i would expect types to come to the rescue
21:40:01 <dolio> Types aren't going to force you to write only boomerang code without any regular OCaml.
21:43:37 <copumpkin> mmm, segfault on my mmap
21:53:27 <copumpkin> tada, vector-mmap
21:53:38 <copumpkin> world's smallest package, after spoon
21:54:18 <scutigera> the fans go wild
21:55:00 <copumpkin> dons: do you know of a function for copying from an immutable vector to a mutable one?
21:55:21 <dolio> There isn't one yet.
21:55:25 <copumpkin> oh
21:55:36 <dolio> Well, you can do unstread . stream.
21:55:43 <dolio> But that's as good as you get so far.
21:55:55 <dolio> unstream, that is.
21:57:13 <dolio> unstream being the mutable vector version, and stream being the immutable vector version.
21:57:19 <copumpkin> yeah
21:57:26 <dolio> So you may need to have qualifications.
21:59:14 <dolio> I guess that's not even what you want if you want to copy into an already made vector.
22:01:36 <copumpkin> yeah, hmm
22:01:45 <copumpkin> any idea how that PrimMonad in MVector works?
22:02:06 <copumpkin> just an abstraction from ST and IO?
22:02:12 <alatter> copumpkin: yep
22:02:41 <copumpkin> if my MVector definitely lives in IO, do I want MVector IO a ?
22:02:55 <dolio> No. It'd be MVector RealWorld a.
22:03:03 <copumpkin> oh, I see
22:03:08 <copumpkin> PrimMonad is a type family
22:04:04 <copumpkin> or rather, PrimState is
22:04:05 <dolio> GHC 6.12.1 has some serious problems with code generation with IO, though.
22:04:31 <copumpkin> like what?
22:04:36 <dolio> It casts between PrimState IO and RealWorld on every vector operation.
22:04:48 <dolio> For some reason, the simplifier can't figure out that those are the same.
22:05:27 <alatter> well, there's always stToIO
22:05:56 <copumpkin> oh wow
22:06:02 <copumpkin> I thought RealWorld didn't even exist at runtime
22:06:15 <dolio> Apparently it works much better in HEAD.
22:06:25 <pikhq> copumpkin: I don't think it's supposed to.
22:06:36 <pikhq> But clearly, it can if something's wrong.
22:07:23 <dolio> It's obviously doing something, even if it's only building and passing around and taking apart some sort of type equality evidence.
22:07:40 <dolio> It seems to do weird things to inlining, too.
22:07:57 <scutigera> let a = [2.0::Double ]; in; do h <- openBinaryFile "foo.bin" WriteMode; withArray a (\c -> hPutBuf h c 4)  I get 00 00 00 00 in foo.bin ??
22:09:02 <dolio> Anyhow, I get order of magnitude speed differences between "foo" and "\v -> stToIO (foo v)" in vector-algorithms.
22:11:36 <copumpkin> w00t, my mmap mutable works too
22:11:52 <copumpkin> I should really write a testsuite but I'm sleepy
22:13:01 <copumpkin> I must say, it's pretty awesome to be able to write set y 666
22:13:09 <copumpkin> and see the file change on disk without explicitly saving
22:13:21 <copumpkin> the beauty of mapped memory
22:14:47 * copumpkin wonders what grow is supposed to do on vectors that come from unsafeFromForeignPtr
22:16:26 <copumpkin> something equally unsafe, I guess :)
22:22:28 <scutigera> seems like I need something to convert from Double to CDouble ??
22:22:41 <copumpkin> :t realToFrac
22:22:41 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
22:24:46 <copumpkin> tada
22:24:59 <Draconx|Laptop> sadly, realToFrac fails.
22:25:20 <copumpkin> anyone want to test it?
22:25:26 <Draconx|Laptop> > realToFrac (-0 :: Double) :: Double
22:25:27 <lambdabot>   0.0
22:25:30 <copumpkin> http://hackage.haskell.org/package/vector-mmap
22:26:10 <scutigera> :t withArray
22:26:11 <lambdabot> Not in scope: `withArray'
22:26:26 <Draconx|Laptop> as far as I can tell, the only correct way to convert from Double to CDouble (and vice versa) is unsafeCoerce.
22:26:31 * hackagebot upload: vector-mmap 0.0.1 - Memory map immutable and mutable vectors (DanielPeebles)
22:26:55 <scutigera> aha, I was about to write an ffi stub
22:27:27 <Gracenotes> it is that important to have negative zero?
22:27:38 <copumpkin> scutigera: this one works on windows too, using the mmap package
22:27:48 <Draconx|Laptop> it is important for data marshalling to not lose information, yes.
22:28:01 <Draconx|Laptop> > realToFrac (0/0 :: Double) :: Double
22:28:02 <lambdabot>   -Infinity
22:28:06 <Draconx|Laptop> also broken.
22:28:36 <copumpkin> > 0/0 :: Double
22:28:37 <lambdabot>   NaN
22:28:52 <copumpkin> unfortunately realToFrac goes through Rational I think
22:28:55 <Draconx|Laptop> indeed.
22:29:00 <Draconx|Laptop> which is silly.
22:29:03 <scutigera> oops, what's unsafeCoerce going to do with that.
22:29:14 <scutigera> Nan, I mean
22:29:20 <copumpkin> Draconx: what's silly is for a numeric type to contain non-numeric options
22:29:31 <copumpkin> Draconx: not sure the interface should be polluted for the sake of IEEE
22:29:31 <Draconx|Laptop> scutigera, well, it abuses the fact that CDouble is just a newtype wrapper around Double, so unsafeCoerce happens to work.
22:29:44 <Pirace> Hi!  Is it possible to compile current bindings to SDL for Windows?
22:29:47 <Draconx|Laptop> copumpkin, the problem is not that the interface is broken, but that Double should not be an instance of the Real class.
22:29:54 <copumpkin> yeah, definitely
22:29:56 <Pirace> (The old .cabal trick from WIN32 does not work anymore apparently)
22:29:57 <Draconx|Laptop> or the RealFrac class.
22:29:59 <copumpkin> but that's mostly convenience
22:30:08 <copumpkin> it doesn't fit perfectly, but for most uses it works
22:30:35 <copumpkin> whoops, my URL on that package is bad
22:31:03 <scutigera> it looks to me like the safest thing to do is have a c func which simply returns  a char * pointing at the double ?  Then just write it out as 4 bytes (Word8)
22:31:26 <Draconx|Laptop> scutigera, unsafeCoerce is probably better.
22:31:40 <Gracenotes> @type uncurry encodeFloat . decodeFloat
22:31:41 <lambdabot> forall a a1. (RealFloat a, RealFloat a1) => a1 -> a
22:31:41 <scutigera> I'm confused about how to "unwrap" the Ptr
22:31:43 <Draconx|Laptop> it will presumably be a noop.
22:32:13 <Draconx|Laptop> > encodeFloat . decodeFloat $ 0/0
22:32:14 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
22:32:14 <lambdabot>         agains...
22:32:15 <Gracenotes> hm. even that doesn't check through isNegativeZero
22:32:35 <Gracenotes> or even infinity :P
22:32:51 <Draconx|Laptop> > uncurry encodeFloat . decodeFloat $ 0/0
22:32:52 <lambdabot>   -Infinity
22:33:16 <Gracenotes> read . show, at least, is guaranteed to be correct
22:33:19 <Draconx|Laptop> yes, the entire floating point library feels like it was added at the last minute.
22:34:26 <Gracenotes> the typeclasses have come under scrutiny. there is a balance, you know, between slaving to IEEE's every whims, and providing an interface that is numerical in the mathematical sense of the term
22:34:46 <scutigera> > map unsafeCoerce [0.0, 1.0, 2.0::Double] :: [CDouble]
22:34:47 <lambdabot>   Not in scope: type constructor or class `CDouble'Not in scope: `unsafeCoerce'
22:35:21 <Gracenotes> not just in ways CS people are used to. Still, trying to see if that's an option anywhere.. worst case, just use the CDouble, it's not going to blow up in your face
22:36:02 <Draconx|Laptop> Gracenotes, well, I think the biggest problem is not the type classes, but rather the instances.
22:36:22 <Draconx|Laptop> (although I don't like the RealFrac class)
22:36:34 * hackagebot upload: vector-mmap 0.0.2 - Memory map immutable and mutable vectors (DanielPeebles)
22:36:40 <pikhq> Draconx|Laptop: I doubt you can come up with sane instances of RealFrac for Double.
22:36:43 <Gracenotes> there may be a way though RealFloat. dunno.
22:36:46 <Draconx|Laptop> pikhq, exactly.
22:36:50 <Draconx|Laptop> pikhq, so it should not exist at all.
22:36:57 <pikhq> Agreed.
22:37:10 <Draconx|Laptop> Personally, I think floor should have the type RealFrac a => a -> a
22:37:30 <Gracenotes> that's always annoyed me about the C type, actually
22:37:33 <Draconx|Laptop> why?
22:37:51 <Gracenotes> because, use-case-wise, I cast it to an integer 100% of the time :)
22:39:09 <scutigera> strange - the binary file is still filled with 0s.  Is withArray not actually copying ??
22:39:29 <dobblego> can I tell ghci not to display all the loaded modules?
22:39:39 <Draconx|Laptop> dobblego, :set prompt "> "
22:40:06 <dobblego> ah thanks, can I do it automatically in ~/.ghci ?
22:40:16 <Draconx|Laptop> I don't see why not.
22:40:27 <Gracenotes> NaN, Infinity, -Infinity, -0.0 *are* weird. They're not something you worry about, because if you obtained them accidentally, you're pretty much screwed at that point anyway
22:40:56 <Draconx|Laptop> Gracenotes, personally, I work with them all the time.
22:40:59 <dobblego> of course ta
22:40:59 <Gracenotes> well. besides -0. that's just weird, a not-very-important idiosyncrasy of having to shove it into bits
22:41:25 <Draconx|Laptop> Gracenotes, negative zeros are important when dealing with branch cuts.
22:41:52 <Gracenotes> you're doing math with IEEE floats?
22:42:09 <Gracenotes> not a more rigorous type?
22:42:12 <twink> $ grep prompt ~/.ghci yields :set prompt ">> " here
22:42:40 <Draconx|Laptop> Gracenotes, if you care about performance...
22:43:40 <Gracenotes> then you should be used to sacrificing things? :P
22:43:45 <twink> Gracenotes: branch cuts how then?
22:44:14 <dobblego> can I hide e.g. Prelude.mapM in ~/.ghci ?
22:44:26 <Gracenotes> all around better situation if there were a simple means to convert. as it is, RealFloat handles the extreme cases for you
22:44:56 <Gracenotes> and realToFrac works for, as the name implies, real numbers, those RealFloat's "is it weird" methods say no to
22:45:02 <Draconx|Laptop> well, the problem could be solved with two functions: toDouble :: RealFloat a => a -> Double and fromDouble :: RealFloat a => Double -> a
22:45:27 <Draconx|Laptop> (assuming Haskell never ever gets any floating point types more precise than Double)
22:45:29 <Gracenotes> generic number type conversion is more difficult than it looks
22:45:56 <copumpkin> especially when number types contain non-numeric values!
22:45:57 <Draconx|Laptop> it's not too hard to implement these functions for the grand total of four instances of the RealFloat class.
22:46:29 <Draconx|Laptop> two of which are newtypes of the other two.
22:51:11 <scutigera> foreign import ccall "foo.h just_a_double" : parse error on input `import' ??
22:51:28 <Draconx|Laptop> scutigera, compile with -XForeignFunctionInterface
22:52:07 <scutigera> thanks, RHW example doesn't show that...
22:53:00 <scutigera> that did it...
22:53:01 <Draconx|Laptop> they use a LANGUAGE pragma instead.
22:53:09 <Draconx|Laptop> (which is probably better in the long run)
22:53:27 <scutigera> doh. yep I see it...
22:57:12 <twink> I thought there was some kind of demand for more precise floating point and maybe something it could be imported from (gmp?).
22:57:58 <Draconx|Laptop> twink, well, many common FPUs support more precise formats natively.
22:58:35 <scutigera> ugh.  I give up... this shouldn't be this hard... better luck tomorrow.
22:59:52 <Draconx|Laptop> although I think Haskell should properly support the two types it currently has before adding another.
23:00:00 <dmwit> Under what conditions are ListT m a monad?
23:00:08 <dmwit> (are? is?)
23:00:16 <dobblego> http://paste.pocoo.org/show/180379/ this warns me about 2 defaulting to Integer, but what is the intended fix?
23:00:26 <copumpkin> dons: rl made the good point that switching Int to Word in vector wouldn't match with the primitive array types :(
23:00:47 <dmwit> dobblego: add a type signature?
23:00:53 <dmwit> dobblego: Turn off whatever warning that is?
23:01:21 <dobblego> dmwit, it's -Wall, which would be a pain in the arse and (2 :: Integer) + 2 is also a pain in the arse
23:01:40 <dmwit> dobblego: That's your problem. If you want -Wall, you have to deal with pain to make clean code.
23:01:50 <dobblego> ok
23:02:11 <dmwit> 2 + 2 :: Integer -- slightly less of a pain, since no parentheses
23:02:58 <copumpkin> anyone want to test my mmap?
23:03:08 <Gracenotes> dmwit: just a monad, right?
23:03:23 <dmwit> Gracenotes: right
23:03:35 <dmwit> doesn't need to be commutative or anything
23:03:58 <Gracenotes> a commutative monad?
23:04:13 * dmwit pauses to consider whether that makes sense
23:04:29 <copumpkin> commutative monads are cool
23:04:50 <Gracenotes> what does that satisfy, again
23:04:50 <pastorn> hey, what's the "mdo" keyword?
23:04:58 <pastorn> is that still in haskell or was it removed?
23:04:59 <dmwit> pastorn: It's for recursive bindings.
23:05:01 <Gracenotes> neat, but complicated
23:05:02 <dmwit> :t mfix
23:05:02 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:05:21 <dmwit> It probably requires an extension.
23:05:32 <copumpkin> Gracenotes: order of "statements" doesn't matter
23:05:39 <pastorn> dmwit: is there a special monad or a special typeclass or what do you need to use it?
23:06:06 <dmwit> pastorn: ...see the type signature of mfix.
23:06:07 <copumpkin> Gracenotes: I think sigfpe mentioned them in one of his talks
23:06:14 <Gracenotes> copumpkin: seems rather neutered
23:06:22 <dmwit> Gracenotes: Is Maybe neutered?
23:06:25 <dmwit> Gracenotes: It's commutative.
23:06:39 <copumpkin> (->) r is too
23:06:42 <augur> so guys
23:06:43 <Gracenotes> I suppose I'm thinking about it operationally, in terms of the work that gets done
23:06:47 <augur> hows life
23:07:09 <Gracenotes> only thing is, what if the order of operation introduces a bottom?
23:07:11 <copumpkin> also, a commutative monoid makes Writer commutative over it
23:07:25 <Gracenotes> as opposed to another one which nicely gives you Nothing
23:07:31 <pastorn> augur: pretty awesome?
23:07:45 <copumpkin> http://vimeo.com/6590617
23:07:53 <augur> pastorn: good :D
23:08:20 <Gracenotes> pastorn: mdo { tid1 <- forkIO (do { result <- somethingExpensive1; killThread tid2; writeMVar mv result; }); tid2 <- forkIO (do { result <- somethingExpensive2; killThread tid1; writeMVar mv result; })
23:08:40 <Gracenotes> courtesy of someone from a few months ago
23:10:03 <pastorn> Gracenotes: amadag that's weird
23:10:21 <pastorn> it makes me think of writing VHDL code
23:11:57 <Gracenotes> the coolest thing about laziness is that you can refer to a value that doesn't exist yet.. one that gets filled in later. In some cases, the value requires you at the same time you require it, for some kind of gradual lazy unfolding. Really neat. mdo does that with monads, which are sequential.
23:12:03 <Gracenotes> (normally)
23:12:30 <Gracenotes> also from that same conversion a few months ago, this nice transformation: mdo { t1 <- f t2; t2 <- g t1; h } .... to .... mfix (\(t1,t2) -> do { t1 <- f t2; t2 <- g t1; return (t1,t2) }) >>= \(t1,t2) -> h
23:12:36 <pastorn> Gracenotes: feels an awefully lot like
23:12:39 <pastorn> f x = f x
23:12:55 <dmwit> pastorn: Your feelings are pretty smart!
23:13:00 <dmwit> They're very closely related.
23:13:33 <Gracenotes> MyCatVerbs came up with that example
23:13:37 <pastorn> Gracenotes: but! but! but!
23:13:56 <pastorn> you don't have t1 when you call g, and you don't have t2 when you call f!
23:14:06 * pastorn dies inside his head
23:14:28 <dmwit> Gracenotes: Uh, is that transformation correct?
23:14:39 <dmwit> Oh, you're abusing shadowing.
23:14:48 <Gracenotes> yes, it's like a cyclic shadow chain
23:14:57 <Gracenotes> you could rename things to make it more clear
23:15:04 <dmwit> Really it's only t2 that needs to be closed over in the fixpoint.
23:15:33 <dmwit> mfix (\t2 -> do t1 <- f t2; g t1)
23:15:38 <pastorn> does the t1 in "g t1" refer to the one in the pair or the one created by "f t2"?
23:15:51 <dmwit> pastorn: The one created by "f t2".
23:15:58 <dmwit> pastorn: The one in the pair is totally ignored.
23:16:08 <dmwit> compare my example =)
23:16:15 <Gracenotes> dmwit: it's a good idea if you want to get both t1 and t2 out of it, though
23:16:29 <Gracenotes> to let h know about
23:17:16 <dmwit> Gracenotes: But h doesn't exist in your concrete example.
23:17:30 <dmwit> So I still prefer (mfix (\t2 -> f t2 >>= g)). =)
23:17:33 * copumpkin loves olives
23:17:36 <dmwit> in fact
23:17:46 <dmwit> That looks like mfix (f >=> g) to me.
23:17:59 * copumpkin has yet to find a good use for mfix... what do you use it for?
23:18:00 <Gracenotes> dmwit: well, yeah, but why make a special case? correct transforms are correct transforms :)
23:18:01 <dmwit> :t \f g t -> f t >>= g
23:18:02 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
23:18:03 <pastorn> @src mfix
23:18:04 <lambdabot> Source not found. That's something I cannot allow to happen.
23:18:16 <Gracenotes> there is a paper on the semantics of fixIO
23:18:16 <pastorn> @type mfix
23:18:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:18:21 <dmwit> pastorn: It's a typeclass function, implemented differently for each instance.
23:18:32 <pastorn> @src mfix :: IO
23:18:32 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:18:37 <Gracenotes> in the transformhere, there's an h
23:18:45 <copumpkin> Gracenotes: I read it a while ago, but none of it stuck :) were there convincing examples of what it's good for in there?
23:19:10 <dmwit> ?instances MonadFix
23:19:11 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:19:22 <dmwit> Wow, rather a lot of them.
23:19:25 <pastorn> @src mfix  IO
23:19:25 <lambdabot> Source not found.
23:19:37 <copumpkin> there's that beautiful RWS(T) with no documentation
23:19:38 <dmwit> Right, as if you're going to get the implementation of any IO function. =P
23:19:38 <copumpkin> mmm
23:19:50 <Gracenotes> it uses unsafeInterleaveIO
23:19:53 <Gracenotes> with MVars
23:19:55 <Gracenotes> the GHC impl
23:19:55 <copumpkin> the beauty of RWS is that the only docs refer to a paper that doesn't mention RWS
23:19:57 <pastorn> @src mfix :: Maybe
23:19:58 <lambdabot> Source not found. Sorry.
23:20:01 <pastorn> halp?
23:20:08 <Gracenotes> so many instances for something that's almost inherently degenerate :)
23:20:15 <dmwit> ?src Maybe mfix
23:20:16 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
23:20:18 <copumpkin> MonadFix on [] ?
23:20:24 <copumpkin> o.O
23:20:35 <copumpkin> > mfix []
23:20:36 <lambdabot>   Couldn't match expected type `a -> m a'
23:20:36 <lambdabot>         against inferred type `[a1]'
23:20:42 <dmwit> > mfix (\x -> [x])
23:20:46 <lambdabot>   mueval-core: Time limit exceeded
23:20:51 <copumpkin> > mfix (const [])
23:20:51 <lambdabot>   []
23:20:59 <dmwit> ?src [] mfix
23:20:59 <lambdabot> mfix f = case fix (f . head) of
23:20:59 <lambdabot>            []    -> []
23:20:59 <lambdabot>            (x:_) -> x : mfix (tail . f)
23:21:10 <Gracenotes> fixIO k = do { ref <- newIORef (throw NonTermination); ans <- unsafeInterleaveIO (readIORef ref); result <- k ans; writeIORef ref result; return result }
23:21:22 <copumpkin> it's sort of like unfold I guess
23:21:35 <copumpkin> treating [] like Maybe
23:21:41 <dmwit> > mfix (\x -> 3:[x])
23:21:42 <copumpkin> or not?
23:21:44 <lambdabot>   mueval-core: Time limit exceeded
23:22:22 <dmwit> > fix ((\x -> 3:[x]) . head)
23:22:24 <lambdabot>   [3,3]
23:23:06 <dmwit> hum
23:23:09 <pastorn> haha! "unJust"
23:23:10 <dmwit> mind-bending
23:23:11 <pastorn> nice :D
23:23:20 <dmwit> :t fromJust -- what they should have used
23:23:21 <lambdabot> forall a. Maybe a -> a
23:23:34 <Gracenotes> they couldn't afford to import Data.Maybe
23:23:41 <Gracenotes> importation costs going up nowadays
23:23:55 <dmwit> Perhaps it predates fromJust.
23:24:29 <pastorn> dmwit: also: 'unJust' is a much better name
23:24:37 * dmwit nods agreement
23:25:11 <Gracenotes> we can call head and tail unConsOne and unConsTwo
23:25:25 <pastorn> Gracenotes: but that's not really funny, is it?
23:25:34 <dmwit> unJust is good because it's a pun. =)
23:25:56 <copumpkin> ORLY
23:26:06 <JokeExplainer> I'm good at this
23:26:26 <JokeExplainer> Gracenotes: ITS FUNY CUZ ITS A PUN, U NO?
23:26:30 <eflister> @djinn m [n -> m b] -> m [b]
23:26:31 <lambdabot> Error: Undefined type []
23:26:39 <dmwit> man
23:26:56 <eflister> @djinn m [(n -> m b)] -> m [b]
23:26:56 <lambdabot> Error: Undefined type []
23:27:05 <copumpkin> eflister: no lists for djinn
23:27:17 <dmwit> Trentemoller's "Miss You" is such an amazing coding tune.
23:27:19 <Gracenotes> wait, JokeExplainer didn't get to tell me what a zygohistomorphic prepromorphism is
23:27:22 <copumpkin> eflister: you could probably tell it about them, but it would probably treat lists like maybe
23:27:25 <dmwit> ...just an amazing tune, really.
23:27:26 <Gracenotes> COME BACK JOEKPLEAINAR
23:27:35 <eflister> @djinn f :: m l (n -> m b) -> m (l b)
23:27:35 <lambdabot> Cannot parse command
23:27:43 <copumpkin> damn, grooveshark is down
23:27:45 <copumpkin> now I can't look up the tune
23:27:46 <dmwit> I thought djinn didn't do recursive types.
23:27:48 <copumpkin> without youtube
23:27:52 <dmwit> hypem.com
23:28:31 <eflister> @djinn m (f (n -> m b)) -> m (f (b))
23:28:31 <lambdabot> -- f cannot be realized.
23:28:39 <dmwit> http://sendmedeadflowers.com/2008/07/trentemoller-miss-you.html more specifically =)
23:29:25 <eflister> @djinn m (f (n -> m b)) -> n -> m (f (b))
23:29:25 <lambdabot> -- f cannot be realized.
23:29:42 <dmwit> eflister: You should take a look at Traversable.
23:29:46 <dmwit> and maybe Foldable
23:29:52 <copumpkin> nice
23:29:54 <eflister> yeah i've been trying T.sequenceA
23:30:52 <eflister> i have:  m [(n -> m b)]   and an n,  and i want   m [b].   any ideas?
23:31:18 <dmwit> I guess 'm' is a Monad here?
23:31:22 <eflister> yeah
23:31:54 <dmwit> :t \mfs n -> do { fs <- mfs; sequence [f n | f <- fs] }
23:31:55 <lambdabot> forall t (m :: * -> *) a. (Monad m) => m [t -> m a] -> t -> m [a]
23:32:08 <eflister> thx :)
23:32:23 <dmwit> :t \mfs n -> mfs >>= mapM ($n)
23:32:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m [a -> m b] -> a -> m [b]
23:32:29 <dmwit> better
23:32:48 <eflister> what's that $?
23:32:52 <dmwit> ?src ($)
23:32:52 <lambdabot> f $ x = f x
23:32:59 <eflister> oh i thought it needed a space
23:33:08 <dmwit> It will work with a space, too. =)
23:33:25 <dmwit> :t \mfs n->mfs>>=mapM($n)
23:33:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m [a -> m b] -> a -> m [b]
23:33:38 <dons> dolio: i need a good sort function on vectors :)
23:33:58 <copumpkin> I thought he'd already ported it
23:34:04 <eflister> huh, how does it know there's not something called >>=m ?
23:34:22 <dmwit> eflister: You can't mix letters and nonletters in an identifier name.
23:34:31 <eflister> orly
23:34:35 <dmwit> eflister: (where digits and single-quotes are considered letters for these purposes)
23:34:45 <Gracenotes> when not in first position
23:34:52 <dmwit> Hm?
23:34:54 <dmwit> No, at all.
23:35:07 <dmwit> You can't mix infix-identifier-characters with prefix-identifier-characters.
23:35:30 <dmwit> oh
23:35:33 <dmwit> I see what you mean.
23:35:39 <Gracenotes> I mean, a' not 'a, wat0 not 0wat
23:35:43 <Gracenotes> you see what I mean. wink.
23:35:43 <dmwit> Yes, digits and single-quotes are considered letters when not in first position.
23:35:46 <dmwit> right
23:36:35 <Gracenotes> > let (∈) = elem in 2 ∈ [1..5]
23:36:36 <lambdabot>   True
23:38:14 <dmwit> Huh, urxvt does a really crappy job on that glyph.
