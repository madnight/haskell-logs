00:00:01 <ablmf> I downloaded data-ordlist and I found there is a Setup.hs in it.
00:00:01 <copumpkin> oh it's an error, even
00:00:05 <ricree> 6.10.4
00:00:11 <copumpkin> ablmf: use cabal-install
00:00:26 <copumpkin> ricree: oh I see
00:00:29 <copumpkin> lowercase T
00:00:31 <copumpkin> in last case
00:00:40 <ricree> ah
00:00:41 <copumpkin> so that's a separate function
00:00:46 <ricree> typos ftw
00:00:54 <copumpkin> funny that I looked for case several times before
00:00:56 <copumpkin> and couldn't see it
00:01:24 <Berengal> ghc should throw warnings for that
00:02:10 <Berengal> "Warning: Possible typo; function foobar declared on the line after function fooBar and has no type signature"
00:02:18 <copumpkin> "Warning: new declaration with levenshtein-damerau distance < 3 found within 2 lines of declaration on line 31. Typo in pattern list?"
00:02:35 <copumpkin> mine is so much cooler
00:03:24 <copumpkin> I think -Wall will warn you for another reason though
00:03:36 <copumpkin> well, it'll just tell you you have non-exhaustive patterns :)
00:03:45 <Berengal> Yeah, no top-level signature + incomplete pattern
00:04:44 <Berengal> levenshtein + (==) `on` map toLower
00:15:15 <mjrosenb> hrmm
00:15:27 <mjrosenb> is there any good way of avoiding repeating IO?
00:15:57 <Axman6> what do you mean?
00:46:46 <mjrosenb> is there an reason that the *modifyIORef functions do not take functions that return values that are in the IO monad?
00:51:21 <int-e> mjrosenb: atomicallyModifyIORef wouldn't work with a non-pure function. There's no fundamental reason in the modifyIORef case though.
00:51:48 <mjrosenb> int-e: i have no clue how it is implemented
00:52:07 <mjrosenb> int-e: is it just because you can attempt to modify the reference within the atomic section?
00:52:43 <int-e> mjrosenb: atomicallyModifyIORef creates a thunk and changes the IORef's reference to that thunk, atomically. That's just a single word update. There is no atomic section, it's a cmpxchg in a tight loop under the hood.
00:53:35 <idnar> that's pretty awesome
00:54:20 <mjrosenb> int-e: right.  that works because the thunk that will evaluate to the function applied to the current value is as good as the current value.
00:54:53 <int-e> yep. you can see how an IO action instead would not nearly work as well.
00:55:11 <mjrosenb> bummer.
00:55:38 <int-e> if you need actual locks, use an MVar.
00:55:44 <mjrosenb> are MVars the same way?
00:56:38 <mjrosenb> i assume the modifyMVar functions are atomic
00:57:50 <solrize> cmpxchg is atomic without a lock??
00:57:51 <int-e> with a caveat - modifyMVar is takeMVar followed by putMVar. So if there's another thread that can put a value into the MVar without taking it first, that can intervene.
00:58:19 <int-e> solrize: it's handled by the cache coherency protocol in hardware.
00:58:32 <mjrosenb> int-e: well i should never be calling take
00:58:34 <benmachine> readMVar can get you into trouble
00:58:36 <mjrosenb> so i should be safe
00:59:12 <mjrosenb> solrize: you mean cmpxchg vs. lock cmpxchg?
00:59:17 <solrize> mjrosenb, yeah
00:59:42 <mjrosenb> because you totally need the lock prefix there.
01:02:20 <solrize> i guess it's lock-free in the sense of not relinquishing the cpu to acquire a lock, but the lock prefix is pretty expensive even inline
01:12:44 <harlekin> Does happstack build with ghc 6.12? Hackage says it does not and the current (?) version 0.4.1 lists some packages which seem to be deprecated.
01:28:57 <cheater> harlekin: did you find out?
01:29:19 <cheater> harlekin: it's also important for me since i want to use happstack.
01:30:31 <harlekin> cheater, I've read that happstack should work with ghc 6.12. on some mailing list post. I'm currently trying to install it using cabal since I don't want to build all packages manually.
01:30:47 <harlekin> cheater, however, currently it fails to install some outdated dependencies.
01:30:52 <cheater> mhm
01:31:01 <cheater> HaXml maybe?
01:31:29 <harlekin> I'm having trouble with a fairly old version of haskell-src-exts which requires happy and that doesn't build for me.
01:32:29 <harlekin> I'm not quite sure why happy doesn't get installed, though. cabal output looks fine to me.
01:33:23 <cheater> can't help you with that, sorry.. maybe a conflict?
01:34:22 <harlekin> I don't know. Its just not flagged as installed although cabal reports it finished with InstallOk. (: I'm using cabal for the first time, though. Could be a very stupid mistake by me.
01:47:50 <solrize> @where sleep
01:47:50 <lambdabot> I know nothing about sleep.
01:48:01 <solrize> @where microsleep
01:48:01 <lambdabot> I know nothing about microsleep.
01:48:12 <solrize> @where timesleep
01:48:12 <lambdabot> I know nothing about timesleep.
01:48:18 <wto> @type foldr
01:48:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:48:30 <harlekin> cheater, I used my os's distrubuted package for happy and then I could build happstack with cabal nicely.
01:49:05 <wto> @src mapM_
01:49:05 <lambdabot> mapM_ f as = sequence_ (map f as)
01:49:24 <cheater> harlekin: nice
01:49:31 <cheater> harlekin: what os is that?
01:50:13 <harlekin> cheater, Linux. Arch Linux in particular.
01:50:54 <cheater> ok
01:51:47 <Saizan> harlekin: do you have ~/.cabal/bin in your $PATH?
01:51:58 <Saizan> harlekin: that's where executables are installed by default
01:52:14 <harlekin> Saizan, I do. I still had trouble with happy, though.
01:52:53 <Saizan> harlekin: so "happy -V" works?
01:53:12 <harlekin> Saizan, yes.
01:53:36 <Saizan> there's no registry of installed executables, so they are searched in the $PATH
01:54:36 <Saizan> harlekin: you can override the search by using --with-happy=/home/user/.cabal/bin/happy
01:54:56 <harlekin> Saizan, thanks. I'll remember that.
01:55:02 <Saizan> changing the path accordingly
01:55:50 <ablmf> How to find how long a function call would call exactly?  I want to compare speed of some algorithm
01:56:00 <Saizan> harlekin: ah, it worked in the end, sorry, i missed that
01:56:09 <_dls> hey guys, kindof an odd question here, but I'm passed a list of ranges :: [(Int, Int)] and a lowercase ByteString, and need to uppercase the elements in the ranges.... map doesn't seem to be correct, nor do most other things I've found
01:56:09 <ablmf> How to find how long a function call would cost exactly?  I want to compare speed of some algorithm
01:56:16 <harlekin> Saizan, no problem. :)
01:56:42 <Saizan> ablmf: don't hask twice
01:56:46 <Saizan> *ask
01:57:19 <Saizan> ablmf: there are packages like timeIt or criterion on hackage for benchmarking
01:58:01 <_dls> ablmf: I think in haskell that's an open research problem... calculating time/space costs in a lazy functional language is hard... check out Okasai if you're looking for big-O style calculations
01:58:20 <_dls> (as in Chris Okasai)
01:58:24 <ablmf> thanks you all!
01:59:50 <Saizan> _dls: inRange c (s,e) = s >= ord c && ord c =< e; \ranges str -> map (\c -> if any (inRange c) ranges then toUpper c else c) str ?
02:00:22 <Saizan> _dls: timing is not that hard :)
02:00:46 <Saizan> _dls: you just have to make sure the results are not cached between repeated runs
02:03:16 <_dls> Saizan: fair enough, I suppose it'll get easier with time :p
02:03:32 <_dls> Does that solution require copying the ByteString to an array of Pairs?
02:04:26 <Saizan> no
02:04:43 <Saizan> the list of pairs is your ranges :: [(Int,Int)] there
02:04:58 <_dls> so org gets the index of the character, or the ascii value?
02:05:00 <Saizan> ?type Data.ByteString.Char8.map -- i meant to use this map
02:05:01 <lambdabot> (Char -> Char) -> BSC.ByteString -> BSC.ByteString
02:05:20 <Saizan> ord gets the ascii value
02:05:42 <Saizan> _dls: maybe i misunderstood your question
02:05:53 <_dls> ahh... sorry, I'm given the indexes of junk dna, and need to mark it in the dna....
02:06:28 <Saizan> ah, i see, so these ranges indicate slices of the bytestring
02:06:33 <maartenm> hello, #haskell.. OT question because I cannot psot to #flex..  does anyone know what the equivalent of Ctrl-D is in win terminal?
02:06:52 <maartenm> I have to use a windows machine and I don't know how to send EOF in the terminal
02:06:57 <RayNbow> Ctrl+Z = EOF in Windows
02:07:01 <maartenm> ah, ok
02:07:02 <maartenm> thanks
02:07:08 <Zao> Ctrl+Z on a new line followed by <CR>
02:07:14 <_dls> right. I like your ascii value solution and am hoping for one on slices that doesn't involve n copies of the bytestring
02:07:16 <maartenm> works well
02:08:01 <Saizan> _dls: is it a strict or a lazy bytestring?
02:08:28 <RayNbow> however, a program like ghci-haskeline in Win32 does not respond to Ctrl+Z
02:08:31 <_dls> Saizan: Lazy
02:08:36 <RayNbow> (it does respond to Ctrl+D)
02:09:05 <maartenm> heh, that's nice of them
02:09:08 <RayNbow> also, some versions of the Python interpreters respond to both Ctrl+Z and Ctrl+D in Win32
02:09:42 <maartenm> I needed it for flex/bison, which of course has none of that
02:09:59 <RayNbow> (I know an early Python 2.5 did... my current install of Python 2.5.4 does not)
02:15:03 <Saizan> _dls: chunk (s,e) str = let (prefix,rest) = splitAt s str; (slice,suffix) = splitAt e str in (prefix,slice,suffix);  uppercase str (r:ranges) = prefix : map toUpper slice : uppercase rest ranges where (prefix,slice,ranges) = chunk r str,  \ranges str -> concat $ uppercase str ranges
02:15:15 <Saizan> _dls: something like that should minimize the copying
02:19:08 <_dls> Saizan: still reading through it, but this is awesome. thanks :-)
02:19:51 <Saizan> _dls: heh, indented properly should be less cryptic :)
02:20:11 <_dls> right. makes sense. splitAt to the rescue :p
02:32:39 <harlekin> @pl (\a -> (a, a))
02:32:39 <lambdabot> join (,)
02:34:37 <harlekin> @pl (not . (`elem` [".", ".."]))
02:34:38 <lambdabot> not . (`elem` [".", ".."])
02:56:22 <Twey> Baughn: Are there any plans in the works for a minor mode that can handle, e.g., Haskell in latex-mode?
02:56:36 <ErhardtMundt> hello Twey
02:56:42 <Twey> Hi, ErhardtMundt
02:56:59 <ErhardtMundt> Twey, how're you?
02:57:48 <Twey> Quite well, thanks
03:00:20 <sioraiocht> Twey: If you find one let me know =p
03:00:35 <Twey> sioraiocht: I'm thinking it might be a task for mmm-mode…
03:01:02 <sioraiocht> Twey: Yes, and if I knew a damn thing about elisp I would make the effort
03:01:04 <Twey> It's annoying to have to edit Haskell in latex-mode, but even more annoying to have to edit LaTeX in haskell-mode :þ
03:01:07 <Twey> Haha
03:01:13 <sioraiocht> agree
03:01:14 <sioraiocht> d
03:01:24 <sioraiocht> excellent use of þorn as a smiley
03:01:39 <sioraiocht> you must be scandinavian ;)
03:02:33 <Twey> sioraiocht: No, English ☺
03:02:37 <sioraiocht> haha, damn
03:03:15 <sioraiocht> Otherwise I would have proceeded to babble at you in Scandinavian
03:03:27 <Twey> Haha
03:03:32 <Twey> Generic Scandinavian ;)
03:03:41 <sioraiocht> well, I don't speak one of the main three
03:03:42 <sioraiocht> only Icelandic
03:03:54 <sioraiocht> but I can write it friendly enough for the others to get the gist
03:03:55 <Twey> Well, arguably Icelandic *is* the main one
03:03:58 <Twey> Heh
03:04:14 <sioraiocht> haha
03:04:15 <sioraiocht> indeed
03:04:20 <Twey> It's on my List
03:04:24 <sioraiocht> but it doesn't have mutual intelligibility with anyone
03:04:26 <Twey> But not very near the top
03:04:32 <Twey> Except Old English!
03:04:34 <sioraiocht> haha
03:04:35 <sioraiocht> yes
03:04:38 <sioraiocht> the northern dialects
03:04:43 <sioraiocht> and a little bit with faroese
03:04:48 <Twey> *nod*
03:04:56 <sioraiocht> but that sounds like a Gael trying to speak icelandic with a strong accent
03:04:59 <Twey> It's like a little slice of living history
03:05:05 <Twey> Haha
03:24:03 <Cale> I wonder if there's a sane way to extend Typeable and safe casts to all types, including polymorphic ones... (obviously not by writing instances, but via extra machinery)
03:25:24 <Cale> Of course, it does seem to immediately imply impredicative polymorphism: cast :: a -> Maybe b -- sometimes you might want b to be instantiated at a polytype.
03:27:09 <Cale> actually, forget Typeable, just typesafe cast :)
03:27:55 <Cale> Though, I suppose it does spoil all the nice parametricity guarantees, so you might want to keep the constraints.
03:28:10 <Cale> (they'd just be trivial to satisfy)
03:29:32 <Saizan> in principle you can just store the representation the typechecker uses for your types
03:29:48 <Saizan> and do an instantiation check when you cast
03:30:47 <Saizan> hence suggesting some "yo dawg" jokes :)
03:31:55 <xerox> haha
03:31:57 <RayNbow> > let {coreturn (x:xs) = x; cobind f [] = []; cobind f l@(_:xs) = f l : cobind f xs; cfix d = coreturn d (cobind cfix d); next = (!!1)} in cobind cfix [sum.tail,next,next,next,next,const 1]
03:31:58 <lambdabot>   [5,1,1,1,1,1]
03:32:06 <harlekin> @pl (\f -> f a)
03:32:06 <lambdabot> ($ a)
03:32:46 <Cale> Saizan: hmm, yeah. I wonder how much trouble it would be.
03:35:54 <Saizan> not sure what happens when you want to cast (show :: Show a => a -> String) to Int -> String, i.e. you need to do instance resolution at runtime too?
03:36:18 <Cale> It seems so...
03:38:43 <Saizan> you could support casting only to the same exact type, not sure how useful that would be though
03:39:36 <Saizan> you can serialize polymorphic values in Clean, so one could look at how they do things
04:00:08 <bastl> has anyone an idea how I could embed a Haskell-CGI-Webapp into some PHP-based CMS/Wiki/Blog ?
04:06:01 <ablmf> I posted a question on stackoverflow.com about O'Neill's "The Genuine   Sieve of Eratosthenes" http://stackoverflow.com/questions/2221378/the-genuine-sieve-of-eratosthenes-algorithm-used-to-generate-primay-numbers
04:06:14 <solrize> bastl, you're asking how to run a cgi from a php script?  you may not be able to, depending on the php host
04:06:41 <bastl> solrize: I am the host :-)
04:06:52 <solrize> you're using mod_php ?
04:07:30 <bastl> I think so. to be honest, I know the admin. But he will do what I want ...
04:07:59 <bastl> solrize: I want to generate wiki code from a haskell app. and let it be rendered via the wiki engine ...
04:08:26 <solrize> is it mediawiki?
04:08:30 <bastl> dokuwiki
04:08:55 <solrize> it sounds like you don't want to use a cgi at all anyway though, i'm not familiar with dokuwiki but it sounds like you want to patch it to run your haskell code
04:09:16 <solrize> the docs at php.net are very good, haskell could learn a thing or two from them
04:09:42 <Twey> Docs are about all PHP has going for it :þ
04:09:52 <medfly> solrize, I pointed that out myself too
04:10:02 <medfly> solrize, Haskell users should assume other Haskell users are stupid more often
04:10:24 <medfly> solrize, I *love* how they have examples of nearly everything. :-p
04:10:33 <solrize> well i think the haskell docs were written by the devs and are sort of minimal
04:10:40 <solrize> there should be a doc sprint at one of the hackathons
04:10:43 <medfly> sometimes they're even exactly what I need.
04:10:52 <solrize> i like the idea of a category 5 doc sprint
04:11:10 <medfly> I mostly care about well-written examples, more than other details, but that's just me I guess :)
04:12:45 <solrize> http://www.php.net/manual/en/function.system.php
04:13:33 <Saizan> the problem with documentation by examples (only) is that extrapolation is never reliable enough :)
04:13:36 <medfly> I wonder if something like comments could help solve the problem, because the comments there have a lot of examples.
04:20:11 <Adamant> I'm sorry, did someone say the docs at php.net were _good_? there are certainly enough of them, but last time I was doing php the quality was pretty awful.
04:20:37 <Twey> Adamant: Really?  They're pretty comprehensive.  What did you miss?
04:20:50 <int-e> I'd like to attach a warning to a class instance that should occur whenever that instance is used (as per type inferencse) anywhere in the code. Is there any trick to do that with ghc?
04:21:08 <Adamant> Twey: specifically, the user contributed ones will get you going in a circle if you read them.
04:21:26 <Twey> Oh, well, we don't read those.
04:21:27 <medfly> I don't know. I liked them when I had to use PHP.
04:21:41 <int-e> (or some other way to find where that instance is used without removing it and looking at the errors one by one)
04:21:57 <medfly> I basically skip anything written, look at an example to how to use the function and modify it for my purpose. it works surprisingly well. it's almost like I am not writing code.
04:22:21 <Adamant> yeah, I think "lots of docs of varying quality" is better than "no docs"
04:22:25 <Twey> o.x
04:23:00 <Adamant> I'm not sure it's better than "a small amount of high quality docs"
04:23:25 <Adamant> but (almost) nobody likes doing docs, anyway, so.
04:26:18 * Twey finds it quite cathartic.
04:27:57 <Adamant> I try to write good ones, and not just bang them out, just because I've experienced too many awful ones to want to perpetuate crappy docs.
04:31:01 <Saizan> we could post each haddock page on reddit, and comment there
04:31:58 <jaj> does anybody know how I could represent a data structure that looks like this: http://www.pastie.org/814506
04:32:14 <jaj> a Tree where 2 nodes can be the same element
04:33:23 <Axman6> looks like a graph to me
04:33:25 <Saizan> that's known as Directed Acyclic Graph, afaiu
04:33:40 <Saizan> i've used fgl for graphs in the past
04:34:11 <Zao> List of nodes and a list/matrix of edges.
04:34:28 <Zao> Or some clever knot tying, but traversing that would be ... painful.
04:34:38 <Alpounet> has anyone herer read 'Lambda-calculus, Combinators and Functional Programming' by G.E. Revesz ?
04:34:42 <Alpounet> here*
04:35:24 <jaj> thanks for the hints
04:36:55 <jaj> I try to solve an exercise where I have to create a pyramid that looks like this graph where every number is the difference on the numbers above, with every number only occuring once in the pyramid. the idea is to solve the pyramid using backtracking mechanisms
04:37:27 <jaj> a friend had to do it in C but I have the feeling like I can do this in an elegant way in haskell
04:41:56 <ski> jaj : you might try Prolog, as well
04:51:42 <jaj> ski: well, I don't know prolog ;)
04:52:15 <ski> well, you could learn it, to compare the approaches ;)
04:53:43 <ski> (if you only need backtracking, then something like e.g. lazy lists might be enough. if you need equality constraints (or other constraints), then Prolog (or various CLP extensions thereof) might be more natural)
04:54:41 <jaj> ok, I'll take a look at prolog then some day
04:55:44 <osaunders> Is there a data type for probability like a number that can only be between 0 and 1?
04:59:31 <Axman6> i don't believe so
05:01:48 <osaunders> Axman6: Do you think writing one would be a good idea?
05:02:06 <Axman6> i don't know how you'd do it, so sure :)
05:03:28 <osaunders> OK, another question is it possible to have a number data type that guarantees a non-zero value.
05:03:30 <osaunders> ?
05:03:44 <Axman6> sure it's possible
05:03:54 <osaunders> :P
05:03:56 <osaunders> how?
05:04:15 <Axman6> make the type not have a zero value :P
05:04:44 <osaunders> data NonZeroNum = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
05:04:49 <osaunders> ....
05:04:52 <osaunders> could take a while.
05:05:43 <Axman6> just have every operation check to see if it has somehow become zero. if it has, then return a constructor that lets you know it's invalid
05:06:09 <ben> You could encode that constructor as 0...
05:08:54 <tomoj> what would be the benefit of such a type?
05:09:09 <ben> A non-nullable int!
05:11:10 <osaunders> Guarantee a valid if for a database table.
05:11:13 <osaunders> *valid id
05:11:54 <tomoj> but.. what happens when you subtract 1 from 1?
05:12:08 <tomoj> oh, guess you won't be doing math on ids
05:12:10 <Axman6> ERROR!
05:12:39 <medfly> ERROR: ZERO IS FORBIDDEN!
05:13:00 <FauxFaux> Zero is just null!  Out of my number system, you post-Christ mathematicians!
05:27:59 <pozic> I want to draw a set of line segments for test purposes. Is there an easy way to do that in Haskell? By easy I mean not more than possibly a do n <- newWindow; mapM drawLineSegment segments ?
05:28:21 <Axman6> i think the HOpenGL or HGL package might let you do that
05:28:29 <Axman6> or, close to it anyway
05:28:55 <pozic> OpenGL is very low-level.
05:29:26 <Axman6> check HGL
05:30:20 <Beelsebob> OpenGL isn't low level – it's just horribly procedural
05:30:55 <pozic> Beelsebob: by low-level, I mean that it doesn't do what I want already out of the box.
05:31:01 <pozic> Beelsebob: there is no high/low-level.
05:31:06 * Beelsebob nods
05:31:16 <Beelsebob> so you're looking for a game engine, not a graphics API?
05:31:49 <pozic> Beelsebob: I guess. I just want to draw some polygons and possibly annotate them with some text and color.
05:32:01 <Beelsebob> oh, then OpenGL does that out of the box
05:32:06 <pozic> HGL looks quite nice.
05:32:08 <Beelsebob> minus the text, which you can get from glu
05:32:37 <ben> I would probably try to use cairo inside a gtk gui
05:32:43 <pozic> Beelsebob: do you know HGL?
05:32:45 <ben> Requires more boilerplate, but eh
05:33:06 <Beelsebob> pozic: I know the standard Haskell OpenGL binding reasonably, I don't remember if that's HGL or HOpenGL
05:33:11 <pozic> I am going with HGL for now.
05:33:19 <pozic> Beelsebob: HOpenGL and HGL are not the same thing.
05:33:25 <Beelsebob> right
05:33:29 <Beelsebob> did I contradict that
05:34:06 <Axman6> quit being so defensive man :P
05:34:19 * Beelsebob stabs Axman6
05:34:29 <Axman6> and offensive!
05:34:32 <Beelsebob> hehe
05:34:33 <Beelsebob> :P
05:35:13 <quicksilver> I'm pretty sure the answer to pozic's question is simply "No."
05:35:24 <quicksilver> nothing is quite that simple with graphics.
05:35:31 <quicksilver> it's not hard, either, though. Just boring.
05:36:10 <Beelsebob> well, there *are* APIs that are dead simple to do that kind of thing quicksilver
05:36:15 <pozic> main :: IO () main = runGraphics $ withWindow_ "Hello World Window" (300, 200) $ \ w -> do drawInWindow w $ text (100, 100) "Hello World" drawInWindow w $ ellipse (100, 80) (200, 180) getKey w
05:36:16 <Beelsebob> they're just not OpenGL
05:36:22 <pozic> This is dead simple.
05:36:35 <Beelsebob> tbh, I want to stab that code
05:36:41 <pozic> (and exactly what I wanted)
05:36:51 * Beelsebob wants to describe a scene and *then* ask it to be painted
05:36:53 <Axman6> it's nicer when properly indented
05:36:57 <Axman6> http://www.haskell.org/ghc/docs/6.6/html/libraries/HGL/Graphics-HGL.html
05:37:05 <Beelsebob> not describe a bunch of actions that end up reproducing the scene through chance
05:37:20 <pozic> Beelsebob: you are right, but show me the libraries to do so.
05:37:25 * Beelsebob nods
05:37:35 <Beelsebob> it's easy enough to write a simple 2D scene graph library though
05:37:39 <pozic> Beelsebob: I can write those libraries, and so can you, but who is paying? ;)
05:37:45 <Beelsebob> hehe
05:37:47 <Beelsebob> fair point
05:39:40 <pozic> Hmm, well, HGL does feel very close to OpenGL. Oh, well.
05:40:06 <Twey> FieldTrip!  :þ
05:40:14 <Beelsebob> FieldTrip is shiny as hell
05:40:33 <Beelsebob> but as with all conal code I know of – it's so damn nice, just not *quite* in a state you would want to use it
05:40:41 <Twey> Hehe
05:40:59 <pozic> Beelsebob: why would you not want to use it?
05:41:19 <Beelsebob> pozic: because it's research quality code, not production quality
05:41:31 <Beelsebob> i.e. it does enough to prove a point, not enough to be used for anything much
05:42:32 <pozic> Beelsebob: so, performance?
05:42:48 <Beelsebob> and completeness
05:42:50 <Beelsebob> and stability
05:43:02 <Beelsebob> it's preformance is actually not bad at all
05:43:09 <pozic> IMHO, the only difference between research and production should be performance.
05:43:09 <Beelsebob> considering some of the scary shit it does
05:43:23 <pozic> Otherwise it is just research not solving the complete problem.
05:43:44 <pozic> Then it is "oh, and btw, in production, you have to figure out the real solution".
05:43:53 <Beelsebob> depends what the research is about
05:44:15 <Beelsebob> whether the research is about one particular small problem, or about "can we create a full featured graphics API in a functional style"
05:44:57 <pozic> Meh, HGL Points are (Int,Int). I just want to use Floats/Doubles.
05:45:10 <Beelsebob> :(
05:45:28 <Beelsebob> (Int, Int) points fail the second you want resolution independence
05:49:51 <pozic> Where is the documentation for LambdaCubeEngine?
05:55:34 <pozic> Does cabal install vacuum-opengl work for anyone on 6.10?
06:00:23 <Cale> pozic: One moment, I will let you know.
06:00:38 <Cale> pozic: There's initially no problem with it, anyway.
06:02:00 <Cale> pozic: Installed successfully.
06:02:14 <Cale> (Linux, GHC 6.10.4)
06:06:00 <pozic> Graphics/UI/GLUT/Initialization.hs:263:15:
06:06:01 <pozic>     Couldn't match expected type `CUInt'
06:06:01 <pozic>            against inferred type `OpenGLRaw-1.1.0.1:Graphics.Rendering.OpenGL.Raw.Core31.TypesInternal.GLenum'
06:06:06 <pozic> Cale: that's what I get.
06:06:33 <Cale> In what package?
06:06:43 <pozic> vacuum-opengl-0.0.3 depends on GLUT-2.2.1.0 which failed to install.
06:06:50 <pozic> Cale: so, GLUT-2.2.1.0
06:06:51 <Cale> I installed GLUT-2.2.2.0
06:08:25 <pozic> Cale: that works.
06:30:43 <pozic> The typical Haskeller: http://www.muitovar.com/img/hvt.jpg ;)
06:32:20 <medfly> huh, why?
06:32:57 <SamB_XP> yeah, he's not even riding a unicycle!
06:44:41 * ksf thinks there's a standard operator for mappend, but can't remember which
06:44:55 <ksf> ...or where, for that matter.
06:45:05 <ksf> <++> would work.
06:45:23 <pumpkin> :t (++)
06:45:25 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:45:34 <ksf> :t Prelude.(++)
06:45:35 <lambdabot> Not in scope: data constructor `Prelude'
06:45:40 <ksf> :t (Prelude.++)
06:45:41 <lambdabot> forall a. [a] -> [a] -> [a]
06:45:58 <opqdonut> some people think that the symbol for mappend shouldn't be symmetric
06:46:05 <opqdonut> as the operation is not required to be commutative
06:46:19 <ksf> even better, there should be three monoid classes
06:46:21 <opqdonut> so one could have for example (+>) = mappend; (<+) = flip mappend
06:46:25 <ksf> ++, ++> and <++
06:46:40 <ksf> er yes, two.
06:46:40 <zygoloid> in the same way that (^) and (**) imply that exponentiation is commutative?
06:46:54 <ksf> one commutative, one noncommutative
06:48:33 <ksf> opqdonut, but does the < point to the first evaluated element, or in the direction stuff is combined?
06:48:46 <pumpkin> I wouldn't want three monoid classes
06:48:56 <ben> I certainly do not want more monoid classes
06:49:01 <ben> I already get confused by mappend versus mplus
06:49:17 <harlekin> @src (Either) fmap
06:49:18 <lambdabot> Source not found. That's something I cannot allow to happen.
06:49:32 <SamB_XP> ben: I know what you mean!
06:49:52 <SamB_XP> lambdabot: so FIND it, then!
06:49:57 <ben> @src Either
06:49:57 <lambdabot> Source not found. My pet ferret can type better than you!
06:50:14 <zygoloid> people who think that symmetric operators are commutative are unfamiliar with the prelude
06:50:18 <pumpkin> @src Either fmap
06:50:18 <lambdabot> fmap _ (Left x) = Left x
06:50:18 <lambdabot> fmap f (Right y) = Right (f y)
06:50:31 <mreh> If you had to generate all hamiltonian cycles over a fully connected graph, how could you eliminate calculating all the duplicates, e.g. [1,2,3] == [2,3,1]
06:50:33 <harlekin> pumpkin, thanks.
06:50:36 <SamB_XP> zygoloid: which operators are symmetric?
06:50:38 <ben> Well, I guess / is asymmetric.
06:50:49 <zygoloid> SamB_XP: ++ . ** ^, for instance
06:50:52 <ben> ... -
06:51:00 <zygoloid> none of which is commutative
06:51:02 <SamB_XP> is that codified in Unicode?
06:51:27 <quicksilver> zygoloid: I am the some people of which opqdonut speaks.
06:51:40 <ben> SamB_XP: Mathematic convention is probably stronger than unicode codification ;)
06:51:49 <quicksilver> and obviously I'm not so blind, or ignorant, not to have noticed that there are plenty of non-commutative symmetric symbols.
06:52:03 <mreh> I wish some people had easier nicks to type
06:52:10 <quicksilver> I just think it's a nice helpful approach and lets you name <+ and +> separately.
06:52:15 <mreh> opqdonut? SamB_XP?!
06:52:17 <SamB_XP> ben: mathematical convention of what ? the shapes in which things are rendered ?
06:52:46 <ben> I meant the way that people commonly write these operators
06:52:50 <ben> On paper, if it has to be
06:53:01 <zygoloid> quicksilver: i think you've probably thought this out better than i have. but it still seems strange to me to reject (++) = mappend on the basis that it's non-commutative, when Prelude.++ is /already/ non-commutative
06:53:21 <SamB_XP> anyway, I like it when symmetric symbols are at least associative
06:53:37 <SamB_XP> zygoloid: yes, that's pretty damn dumb
06:53:39 <zygoloid> also i'm not sure what (<+) and (+>) would mean. which is the one where the left-hand-side is on the left?
06:53:59 <ben> +>, imo
06:54:34 <SamB_XP> isn't the usual convention to use <+> for mappend ?
06:54:35 <zygoloid> ok, but why that one? what does the arrow mean?
06:54:43 <ben> On the other hand I do not necessarily want to repeat my confusion about <**>, <*, *>
06:56:16 <benmachine> mreh: opq<tab>
06:56:21 <benmachine> easy!
06:56:33 <mreh> benmachine?!!
06:56:40 <benmachine> ?!?
06:56:50 <mm_freak_> aren't there some alternative Prelude implementations, which resolve some of the redundancy?
06:56:53 <mreh> zygoloid is my personal favourite for keyboard mashing :D
06:57:19 <opqdonut> opqdonut is really nice to type on a qwerty keyboard, actually
06:57:39 <mm_freak_> there is no apparent advantage of having mappend and (++)
06:57:41 <zygoloid> Twey is nice to type too :)
06:57:44 <benmachine> man who actually types a whole name
06:57:45 <SamB_XP> mreh: what are you playing at ?
06:58:03 <SamB_XP> benmachine: people who are smarter than me!
06:58:11 <quicksilver> zygoloid: not rejecting it.
06:58:13 <harlekin> @ty (fmap (first (map (?::Doc -> String))) `fmap))
06:58:14 <lambdabot> parse error on input `->'
06:58:15 <SamB_XP> I always type too few characters and tab complete the wrong nick!
06:58:21 <quicksilver> zygoloid: just suggesting an alternative for discussion with a reason why.
06:58:44 <mreh> SamB_XP, horsing around
06:58:51 <pozic> What does eventSent mean in Graphics.UI.Gtk.Gdk.Events?
06:58:56 <benmachine> Saizan: I never have that problem.
06:58:56 <pozic> There is no documentation.
06:58:59 <SamB_XP> mreh: didn't you read the sign at the gate?
06:59:04 <SamB_XP> *no horseplay*
06:59:09 * SamB_XP blows whistle
06:59:10 <Saizan> benmachine: :P
06:59:14 <mreh> there is no gate
06:59:14 <SamB_XP> BUDDY CHECK!
06:59:23 <benmachine> Saizan: sry for using you for my humour purposes
06:59:36 <zygoloid> quicksilver: sorry, that was somewhat a strawman. existing practice shouldn't particularly colour our ideals
06:59:39 <mreh> I didn't got to school in the US
07:00:08 <SamB_XP> mreh: 'sokay, my school didn't have a swimming pool anyways -- that was a camp joke
07:00:12 * SamB_XP was homeschooled ;-P
07:00:23 * benmachine was schoolschooled
07:00:28 <mreh> camp == gay?
07:00:32 <SamB_XP> no!
07:00:35 <mreh> haha
07:00:53 <benmachine> camp == tent &c?
07:00:57 <SamB_XP> camp == that fun place that I got too old to go to ...
07:01:14 <mreh> as camp as a row of tents -- that's a camp joke
07:01:17 <SamB_XP> and no, we had cabins
07:01:22 <benmachine> cabins pfft
07:01:26 <SamB_XP> with electricity!
07:01:41 <mreh> sauna cabins
07:01:46 <benmachine> anyway so, mappend
07:01:47 <mreh> this is getting so OT
07:02:03 <SamB_XP> and for the oldest of us, there was even running water in (most of the) cabins
07:02:07 <benmachine> I think (+>) is more practical but less pretty than (++)
07:02:13 <benmachine> and suggests a natural order where there isn't really one
07:02:30 <SamB_XP> I don't get how it suggests anything!
07:02:33 <pozic> What's wrong with this? onKeyPress window (\some_key -> do mainQuit; return True) I just want to close the window on any key pressed.
07:02:53 <benmachine> also having (+>) and (<+) it's not so clear which mconcat uses?
07:03:01 <benmachine> let's introduce mtacnoc
07:03:16 <benmachine> anyway, we have Dual for flipping (++)
07:03:24 <benmachine> but that's kind of awkward I admit
07:04:11 <benmachine> @let mtacnoc = getDual . mconcat . map Dual
07:04:13 <lambdabot>  Defined.
07:04:20 <benmachine> :t mtacnoc
07:04:21 <lambdabot> forall a. (Monoid a) => [a] -> a
07:04:27 <mm_freak_> > let isPalindrome = (==) <$> id <*> reverse in isPalindrome "abba"
07:04:28 <lambdabot>   True
07:04:32 <benmachine> > mtacnoc ["foo", "bar"]
07:04:34 <lambdabot>   "barfoo"
07:04:35 <benmachine> k
07:05:01 * pozic hates having to read a "tutorial" to write code against an API. 
07:05:14 <pumpkin> onoes
07:05:15 <pozic> Just document it sanely.
07:05:27 <pumpkin> which tutorial is this?
07:05:29 <zygoloid> pozic: can't you just play type jigsaw?
07:05:42 <pozic> pumpkin: http://www.muitovar.com/gtk2hs/app1.html
07:05:53 <pumpkin> oh yeah
07:05:56 <pozic> The tutorial is great. The documentation for GTK2HS is not.
07:06:18 <SamB_XP> pozic: you're supposed to use the GTK documentation, aren't you ?
07:06:26 <ben> pozic: What *is* wrong with the code you posted?
07:06:51 <ben> It seems to work for me with an empty window.
07:07:02 <pozic> ben: it doesn't work. The solution is apparently that you have to call widgetDestroy or return eventSent
07:07:20 <pozic> ben: here, I got that the application was "unresponsive".
07:07:22 <Yoshibloke> Hey, I have a haskell file with a module in, is there anywhere I can place it so that GHC will always be able to find it with an "import"?
07:08:06 <pozic> Yoshibloke: what is "always"?
07:08:16 <ksf> gnargh I want an operator called <,>
07:08:16 <manjunaths> hello
07:08:36 <SamB_XP> :t (<,>)
07:08:37 <lambdabot> parse error on input `,'
07:08:49 <Yoshibloke> pozic - Well just so it can find it when I use ghci or ghc --make
07:09:11 <ben> Yoshibloke: cabal it up and install it
07:09:37 <opqdonut> ksf: something like liftA2 (,) ?
07:10:16 <ksf> :t liftA2 (,)
07:10:17 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
07:10:18 <pozic> Yoshibloke: you are confusing a lot of things.
07:10:22 <ksf> in fact, yes.
07:10:38 <ksf> but's a primitive in my case.
07:10:40 <roconnor> is Lluís here?
07:10:53 * ksf settles on <.>, close enough.
07:11:52 <ksf> @pl (\(c, cs) -> c:cs)
07:11:52 <lambdabot> uncurry (:)
07:11:58 <roconnor> oops wrong chan
07:12:22 <zygoloid> surely unicode has a symbol which looks like <,>? ;-)
07:17:13 * ToRA grrs at  'case (!x:xs) of' not being the same as 'case ((!x):xs) of'
07:21:01 <jmcarthur> dang, they finally succumb to my demands to upgrade ghc *after* i abandon my design that needed it
07:21:22 <benmachine> cool
07:25:16 <jmcarthur> well, to be polite i've informed them (perhaps too late) that i no longer need the new ghc, but maybe they have or will upgrade it anyway now
07:25:30 <pumpkin> jmcarthur: wait, they're upgrading it now?
07:25:48 <pumpkin> jmcarthur: did you see that random suggestion I had about breaking into rectangles btw?
07:26:21 * dcolish waves to jmcarthur 
07:27:43 <medfly> @where lyah
07:27:43 <lambdabot> http://www.learnyouahaskell.com/
07:29:49 <jmcarthur> pumpkin: yes i did, but unfortunately i don't see that as helping me too much
07:29:55 <pumpkin> ah okay
07:30:05 <jmcarthur> the goings on in other rectangles is too important to ignore
07:30:09 <pumpkin> I guess I'll have to try it myself
07:30:23 <jmcarthur> it could work for an entirely different ai i suppose
07:30:29 <pumpkin> jmcarthur: oh I'm just talking about a way of simplifying your strategy for maximizing your time in your half of the board
07:30:31 <pumpkin> if you get boxed off
07:30:37 <jmcarthur> i'm not sure if they are actually upgrading it
07:30:57 <jmcarthur> they said they were going to last night some time, but i have also told them i no longer need it, but would still appreciate
07:30:58 <pumpkin> there are simple ways of filling a rectangle with constraints and it's simpler to think of it as a whole rather than a search problem of its own
07:31:21 <jmcarthur> oh, if i get boxed off my algorithm doesn't look outside of the box anyway
07:31:32 <pumpkin> yeah, that's what I mean though
07:31:36 <jmcarthur> neither of them do
07:32:07 <jmcarthur> it doesn't waste any time looking at the rest of the board
07:32:14 <pumpkin> yeah, I didn't mean that
07:32:45 <jmcarthur> anyway, i'm completely changing the structure of my algorithm
07:32:48 <pumpkin> ok :)
07:32:53 <jmcarthur> and i think it will be faster than it would have been with unamb anyway
07:35:39 <pumpkin> cool
07:35:54 <pumpkin> unamb would be extra nice if you had access to 2 native threads
07:38:09 <gwern> the tron optimal strategy is, I think, to seal yourself inside >50% of the area and then perfectly wallhug
07:38:46 <pozic> gwern: I think not.
07:38:48 <gwern> I suspect everyone will be able to do the latter, but figuring out what is the largest area you can seal off is the hard part
07:38:49 <pumpkin> or even <50% as most of the adversaries are going to be ****ing stupid :P
07:39:00 <gwern> pumpkin: :(
07:39:17 <pumpkin> hey, I think about half of the entries up there are the default wallhugger
07:39:18 <pozic> gwern: the optimal strategy is to compute everything and then check what's optimal.
07:39:24 <pumpkin> lol
07:39:51 <pumpkin> one nice thing with wallhugging is that you can hug an entire wall at a time
07:39:56 <pumpkin> so your search space there gets way smaller
07:39:57 <gwern> pozic: I disagree; that is far less efficient than sealing off >50% and walhugging; the latter always wins if a win is possible
07:40:23 <gwern> since if the enemy has <50% and you have >50% and you really are wallhugging, there's no way you can lose
07:40:26 <pozic> gwern: I talked about optimal, not about efficiency.
07:40:44 <gwern> pozic: mine is optimal too
07:41:31 <pozic> gwern: you assume it will always be possible to do that.
07:41:44 <pumpkin> a particularly aggressive opponent will make it hard for you to wall it off
07:42:03 <Yoshibloke> Anyone here use Avast Antivirus?
07:42:18 <Yoshibloke> It keeps flagging a virus when I cabal something
07:42:23 <pozic> Yoshibloke: Antivirus is for people that do not know how to operate a computer.
07:42:24 <pumpkin> smart
07:42:39 <gwern> pumpkin: an aggressive opponent opens up large accessible areas for one to wall off
07:42:42 <osaunders> pozic: No, it's for Windows users.
07:42:45 <Yoshibloke> ^
07:42:53 <pumpkin> osaunders: that's what he sid
07:42:56 <pumpkin> *sadi
07:42:57 <ben> pozic: Arguably also for people on the same internet as people who do not know how to operate a computer or pretend not to
07:42:58 * pumpkin fails
07:43:12 <pumpkin> gwern: depends on how they go about it
07:43:35 <Yoshibloke> Or people who develop games
07:43:40 <pozic> gwern: also, it is not area which is important, but usuable area.
07:44:03 <Yoshibloke> unfortunately forced to use windows on the main machine
07:44:32 <pozic> gwern: if you can compute that you can get more usable area for yourself than your opponent, you have won.
07:45:08 <osaunders> Is there a fold that will work with functions returning a pair, using fst to accumulate a list that will be returned and snd to pass back into the function. Err yeah that was pretty confusing.
07:45:25 <xerox> :t mapAccumL
07:45:26 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:45:28 <xerox> :t mapAccumR
07:45:29 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:45:34 <gwern> I'm not sure that an optimal player could enclose area without area being useful, but I'll admit I have no solid argument for this
07:46:04 <osaunders> Thanks xerox I'll have a look at that.
07:46:24 <pozic> gwern: with random start positions and random walls it can.
07:46:38 <pozic> gwern: even with just random walls it can.
07:47:11 <gwern> pozic: even with cul de sacs like |_|, the bot can just leave enough space to get in
07:47:14 <pozic> I haven't seen the exact problem statement. Is there any prize money btw?
07:47:28 <gwern> or if the width of the passage is just one bot, then it can detour inside
07:47:38 <pumpkin> pozic: not sure
07:47:44 <pozic> gwern: what are cul de sacs?
07:48:05 <pumpkin> dead ends
07:48:08 <pumpkin> bottom of the bag
07:48:19 <quicksilver> gwern: yes, but with two dead ends you have to choose one and only one
07:48:28 <pozic> quicksilver: that was the case I was thinking of.
07:48:34 <quicksilver> so therefore the usable area is (potentially much) less than the total area
07:48:37 <quicksilver> pozic: I know it was :)
07:48:41 <pozic> quicksilver: :)
07:49:16 <gwern> a one-bot wide deadend is a suicide move
07:49:23 <Gracenotes> apparently it took John Conway two years to come up with the rules for the Game of Life
07:49:26 <quicksilver> depending on the way the problem is formulated this is either a really obscure case that never happens, or it's precisely the whole point of the problem.
07:49:37 <quicksilver> gwern: not if the usable area behind the bottleneck is large
07:49:44 <pumpkin> gwern: sounds like you need to enter the contest!
07:49:53 <gwern> Gracenotes: there are a lot of rulesets
07:49:55 <pumpkin> there's a nice premade package that hugs walls I think
07:50:25 <Gracenotes> gwern: the fundamental one, though, not just the implementation particulars
07:50:35 <gwern> Gracenotes: fundmanetal one?
07:50:58 <Gracenotes> :3
08:01:58 <ArtyomKazak> How can I solve DIVSUM problem on spoj.pl (http://www.spoj.pl/problems/DIVSUM/)? I tried like this (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18464#a18464), but got Time Limit Error.
08:04:04 <harlekin> @hoogle Either a b -> b
08:04:04 <lambdabot> Data.Either rights :: [Either a b] -> [b]
08:04:04 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
08:04:04 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
08:04:52 <Beelsebob> harlekin: you probably are after either someDefaultFunction id
08:05:08 <Beelsebob> > either (const 0) id (Right 5)
08:05:10 <lambdabot>   5
08:05:10 <caution> 500 days of summer
08:05:17 <Beelsebob> > either (const 0) id (Left "Jam")
08:05:18 <lambdabot>   0
08:05:19 <caution> 0 balance transfer
08:05:59 <harlekin> Exteris, I'm looking for fromJust for either.
08:06:09 <harlekin> Woops. That was directored to Beelsebob.
08:06:14 <mux> :t fromLeft
08:06:15 <harlekin> *directed
08:06:15 <lambdabot> Not in scope: `fromLeft'
08:06:20 <mux> :t Data.Either.fromLeft
08:06:21 <lambdabot> Not in scope: `Data.Either.fromLeft'
08:06:28 <mux> I thought this one existed
08:06:34 <mux> but it's simple to implement anyways
08:06:57 <Beelsebob> fromRight = either (error "oh bugger") id
08:07:06 <Beelsebob> fromRight = either (const $ error "oh bugger") id
08:07:35 <pumpkin> does anyone know where Data.Functor came from?
08:07:42 <harlekin> Beelsebob, thanks.
08:07:56 <harlekin> @src right
08:07:56 <lambdabot> Source not found. You untyped fool!
08:08:02 <harlekin> @src Control.Arrow.right
08:08:03 <lambdabot> Source not found. My mind is going. I can feel it.
08:13:33 <ozataman> Hey all... Anybody know how fast Map is with lookups? Can I expect good performance or are there better alternatives?
08:13:38 <pumpkin> jmcarthur: did you see what jaspervdj said about the default package?
08:13:48 <pumpkin> http://www.reddit.com/r/haskell/comments/ay5sc/google_ai_challenge_finishes_february_26_you_can/c0k6kwt
08:15:22 <gwern>     "Whether we fall by ambition, blood or lust,
08:15:23 <gwern>     Like diamonds we are cut with our own dust."
08:16:40 <dankna> cute poem
08:23:04 <jmcarthur> pumpkin: i didn't but i've already written my own
08:23:10 <pumpkin> oh ok
08:23:53 <jmcarthur> pumpkin: plus it looks like he is using arrays for the map, but i need efficient mutation and undo, so i'm using IntMap IntSet to store my walls
08:24:03 <pumpkin> I see
08:24:08 <pumpkin> that sounds quite nice
08:25:02 * hackagebot upload: HsOpenSSL 0.8 - (Incomplete) OpenSSL binding for Haskell (MasatakeDaimon)
08:25:34 <jmcarthur> dang, ozataman quit. i was going to answer this question
08:25:41 <jmcarthur> he's participating in the competition
08:25:41 <pumpkin> aw
08:25:45 <pumpkin> yeah, I noticed his name
08:25:57 <pumpkin> who's A1kmmm?
08:26:02 <jmcarthur> i have no idea
08:26:16 <pumpkin> I've seen his/her nick somewhere else but I don't know where
08:26:26 <jmcarthur> yeah me too
08:26:44 <pozic> Does anyone know how I can instruct metacity to raise windows automatically? That is, that they don't stick to the taskbar?
08:26:52 <jmcarthur> but apparently not. A1kmmm has barely any google hits
08:27:07 <pozic> I think I have to switch window manager to do that.
08:27:33 <pozic> There is an auto_raise option, but that one doesn't appear to do anything useful.
08:27:33 <pumpkin> jmcarthur: hmm, maybe on project-euler
08:28:31 <ziman> that's just weird, i've submitted only the starter pack so far and i'm ninth among haskellers
08:28:36 <gwern> pozic: the solution is to use non-crappy wms
08:28:41 <gwern> may I suggest xmonad?
08:28:49 <pumpkin> ziman: it's measuring how awesome the person behind the submission is too
08:29:26 <ziman> too bad i've got exams to do now...
08:29:27 <pumpkin> hmm, no A1kmmm on projecteuler either... I have no clue where I've seen him
08:29:34 <ziman> pumpkin, :)
08:30:38 <medfly> preflex, seen A1kmmm
08:30:38 <preflex>  Sorry, I haven't seen A1kmmm
08:32:14 <Cale> Perhaps you're thinking of a1k0n?
08:34:18 <temoto> Is there such a term 'metamorphism'
08:34:19 <temoto> ?
08:35:20 <RayNbow> about 684k hits on Google :p
08:35:44 <pozic> gwern: my experience with xmonad was that "crappy applications" do not work with xmonad.
08:36:11 <pozic> gwern: the problem being that the crappy applications do not get fixed.
08:36:20 <pozic> gwern: or not even ack. they are wrong.
08:37:02 <RayNbow> temoto, http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
08:37:05 <gwern> what crappy apps do you use?
08:37:08 <gwern> @quote morphism
08:37:08 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
08:37:12 <pozic> gwern: and e.g. that popup windows that normally have size 400*200 pixels fill the whole screen with xmonad.
08:37:23 <gwern> pozic: really? most of my popups are floating
08:37:30 <temoto> RayNbow, thanks
08:37:31 <byorgey> yes, metamorphism is something that happens to rocks
08:37:34 <gwern> I had to add a managehook to get firefox popups to be tiled
08:38:16 <aavogt> it also makes butterflies
08:38:29 <gwern> metamorphs also like to eat humans
08:39:24 <pozic> I just want a window manager where someone sane already made sane choices. Metacity surely isn't that. XMonad seems to like Emacs in that you first have to write >800 lines to make it work like you want (that's the size of my .emacs).
08:39:56 <pozic> <interactive>: warning: too many hs_exit()s
08:40:03 <pozic> That's also a very cute message.
08:40:16 <gwern> pozic: no one has a >800 line xmonad.hs
08:40:54 <byorgey> it will take far fewer than 800 lines to make a sane xmonad configuration, or else you have a very strange definition of 'sane'.
08:41:00 <pikhq> My .emacs is a single line.
08:41:08 <gwern> pikhq: spawn vim?
08:41:15 <pikhq> No, wait, it's 3.
08:41:23 <pikhq> (normal-erase-is-backspace-mode 0)
08:41:23 <pikhq> (menu-bar-mode 0)
08:41:23 <pikhq> (setq haskell-font-lock-symbols t)
08:41:32 <pozic> pikhq: that's probably because either you wrote Emacs yourself or you don't know Emacs that well.
08:41:50 <pikhq> pozic: I know it decently, and am just fond of the normal bindings.
08:41:56 <Twey> Or you modified the system init file.
08:41:58 <Twey> :þ
08:42:05 <Daerim> hmm... is there a way to discard the output of an IO monad? like IO a -> IO ()? I found void, but the fact that it was in the Foreing.Marshal lib scared me.....
08:42:12 <pikhq> I chose my web browser for similar bindings. :P
08:42:17 <aavogt> @type (>> return ())
08:42:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
08:42:20 <zygoloid> there's a lot to be said for learning to use the default configuration - it makes it easy to work on foreign systems for instance
08:42:31 <ben> @type fmap $ const ()
08:42:32 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
08:42:50 <aavogt> @type (() <$)
08:42:51 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
08:43:00 <ben> @fmap r0
08:43:00 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
08:43:01 <ben> err
08:43:03 <gwern> the biddest known xmonad.hs is http://haskell.org/haskellwiki/?title=Xmonad/Config_archive/Brent_Yorgey%27s_darcs_xmonad.hs
08:43:05 <ben> @type fmap r0
08:43:06 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f Done
08:43:22 <gwern> at 500 lines in total
08:43:42 <gwern> and that's with some eccentric formatting
08:43:58 <gwern> byorgey: do you seriously use everything in your 500 line xmonad.hs?
08:43:59 <aavogt> I'm close
08:44:18 <Daerim> aavogt, ahh, thanks :) That should have been obvious
08:44:30 <gwern> pozic: I pick out byorgey 's config by using the config archive downloader script and running 'wc -m *.hs|sort -g'
08:44:49 <gwern> I count by characters since by line seems unfair
08:45:16 <zygoloid> gwern: how many lines does the most-lines one have? is that byorgey's too?
08:45:47 <gwern> zygoloid: think so
08:45:56 <gwern> followed by http://haskell.org/haskellwiki/?title=Xmonad/Config_archive/Mntnoe%27s_xmonad.hs
08:46:04 <gwern> 458 v 503 lines
08:46:37 <gwern> (good grief.)
08:47:07 <byorgey> gwern: no, I probably don't actually use everything
08:47:08 <pozic> I kind of like having icons to click for applications I use a lot. Is that possible too?
08:47:23 <gwern> pozic: well, nothing stops you from keeping nautilus and the gnome status bar
08:47:26 <gwern> that's what I do
08:47:40 <pozic> gwern: where's your configuration?
08:47:43 <gwern> not that I use either very much, but they're still there if I want to click on stuff
08:47:49 <gwern> pozic: in the config archive
08:48:14 <gwern> pozic: noet that the xmonad.hs isn't enough to make your gnome sesion switch from metacity to xmonad; you need to play with some gnome settings
08:48:16 <byorgey> and keep in mind I don't want a 'sane' config, I want one configured to my every eccentric whim =)
08:48:30 <gwern> for me, it's apparently sufficient to have ~/.gnomerc say 'export WINDOW_MANAGER=/home/gwern/bin/bin/xmonad
08:48:37 <gwern> but I gather that doesn't work for many
08:48:50 <gwern> byorgey: eccentric is the charitable term...
08:53:56 <pozic> Where is the syntax for PackageImports documented?
08:54:11 <gwern> packageimports?
08:54:55 <pumpkin> import "package" Module.Moo
08:55:11 <pumpkin> I'm not sure I've seen an explicit syntax overview for it
08:55:37 <pozic> I recall also having seen a {-#PACKAGENAME #-} syntax.
08:55:55 <gwern> I've never seen that before
08:56:05 <gwern> pre-cabal?
08:56:26 <pozic> I don't think so. I will just try it and see whether this works.
08:57:40 <pozic> It seems to work.
08:59:06 <Berengal> February winds / threads share mutable values / STM brings warmth
08:59:30 <int-e> . o O ( keeping the processor busy, eh? )
08:59:31 <FliPPeh>  / Burma Shave
09:00:15 * Alpounet looks closer at Brent's xmonad.hs
09:12:38 <solrize> @hoogle hSetBuffering
09:12:38 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
09:21:30 <pumpkin> is there a notion of intuitionist probability theory? given how probability is linked to logic it seems like there could exist many ideas of probability
09:21:47 <pumpkin> we reject that P(a) + P(not a) = 1 :P
09:23:17 <ddarius> You could rework Cox's theorem with different assumptions: http://en.wikipedia.org/wiki/Cox%27s_theorem
09:24:17 <pumpkin> seems like topoi could be relevant too?
09:24:23 <Cale> pumpkin: Or maybe just P(not (a or not a)) = 0.
09:24:24 <DBAlex> Hi
09:24:28 <solrize> @src forever
09:24:28 <lambdabot> Source not found. Where did you learn to type?
09:24:31 <DBAlex> This is probably completely simple, but I can't work it out :-/
09:24:36 <solrize> @src Control.Monad.forever
09:24:36 <lambdabot> Source not found.
09:24:41 <Cale> DBAlex: "This"?
09:24:48 <pumpkin> hmm
09:24:59 <DBAlex> How do I find if one of the elements in e.g.: [[True,True,True],[False,False,False]] is all True
09:25:17 <Cale> pumpkin: Probability 0 things can still happen :)
09:25:18 <ddarius> :t find . and
09:25:19 <pumpkin> > or (map and [[True,True,True],[False,False,False]])
09:25:19 <lambdabot>     Couldn't match expected type `a -> Bool'
09:25:19 <lambdabot>            against inferred type `Bool'
09:25:19 <lambdabot>     Probable cause: `and' is applied to too many arguments
09:25:20 <lambdabot>   True
09:25:20 <DBAlex> I've tried: map (all True p) p
09:25:21 <DBAlex> e.g.
09:25:30 <pumpkin> or . map and
09:25:31 <ddarius> :t and
09:25:31 <lambdabot> [Bool] -> Bool
09:25:35 <Cale> DBAlex: any and
09:25:40 <DBAlex> Cale: ok
09:25:42 <pumpkin> oh, even nicer
09:25:53 <Cale> > any and [[True,True,True],[False,False,False]]
09:25:54 <lambdabot>   True
09:25:55 <DBAlex> you can't map all to it then?
09:25:58 <ddarius> :t find and
09:25:59 <lambdabot> [[Bool]] -> Maybe [Bool]
09:26:02 <Cale> > any (all id) [[True,True,True],[False,False,False]]
09:26:03 <pumpkin> DBAlex: all takes a function
09:26:03 <lambdabot>   True
09:26:22 <DBAlex> ok
09:26:26 <ddarius> all id = and
09:26:31 <DBAlex> also, is there a way to select betweek two values at random?
09:26:40 <pumpkin> with a random monad or IO, sure
09:26:48 <DBAlex> say theres equal probability for returning True or False
09:26:51 <pumpkin> or you could thread your own PRNG state through manually if you really wanted
09:26:58 <DBAlex> :s
09:27:18 <pumpkin> DBAlex: but haskell functions are functions :P they're deterministic
09:27:24 <DBAlex> yeah
09:28:02 <DBAlex> with the "any and"
09:28:07 <DBAlex> can that be used with any type?
09:28:11 <pumpkin> :t any and
09:28:12 <lambdabot> [[Bool]] -> Bool
09:28:30 <Cale> :t any
09:28:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:28:34 <Cale> :t and
09:28:35 <lambdabot> [Bool] -> Bool
09:28:41 <DBAlex> say I have e.g.: data Shape = Rectangle | Square | Circle
09:28:43 <DBAlex> ?
09:28:50 <pumpkin> how would that work?
09:28:52 <medfly> > (/= []) . filter (== []) . map (filter (==False)) $ [[True,True,True],[False,False,False]]
09:28:53 <Cale> DBAlex: okay, then what?
09:28:54 <lambdabot>   True
09:29:12 <medfly> maybe that sucks.
09:29:14 <DBAlex> yeah :-/
09:29:14 <pumpkin> (/= []) isn't as nice as null
09:29:19 <medfly> well fuck you.
09:29:24 <pumpkin> it imposes an Eq constraint on the elements :P
09:29:27 <pumpkin> but thanks
09:29:38 <Cale> medfly: Be polite to others here :)
09:29:44 <medfly> Cale, why?
09:29:57 <kmc_> sounds like somebody's got a case of the mondays
09:30:03 * pumpkin shrugs
09:30:14 <DBAlex> basically, if any of the list elems have all the same value (in one of the list elems e.g. [True,True,True] ) then it should be true
09:30:17 <Cale> medfly: because we're trying to keep this a helpful and polite forum :)
09:30:24 <medfly> it's not helpful
09:30:27 <medfly> so why bother
09:30:32 <pumpkin> o.O
09:30:50 <Cale> DBAlex: and $ zipWith (==) xs (tail xs)  will compare if all the elements are the same
09:30:58 * pumpkin thinks medfly needs a backrub
09:30:59 <medfly> this channel responds to people asking for help with terms no one even heard of and then sends them to search those i
09:31:01 <Cale> (all the elements of xs)
09:31:07 <DBAlex> Cale: ok
09:31:17 <DBAlex> Cale: I need just elements in a section...
09:31:19 <ksf> I'm utterly failing to transform a gadt
09:31:29 <kmc_> DBAlex: what do you mean by a "section"?
09:31:30 <pumpkin> medfly: that's the stereotype, but we generally give any level of detail the user needs
09:31:32 <kmc_> one of the sublists?
09:31:38 <DBAlex> kmc_: exactly
09:31:49 <kmc_> DBAlex: then you can apply this function over your list-of-lists
09:31:50 <DBAlex> not the whole list
09:31:54 <kmc_> with e.g. map
09:31:55 <pumpkin> we don't always respond with the zygohistomorphic prepromorphism
09:31:57 <DBAlex> yeah
09:32:04 <DBAlex> ok
09:32:07 <ksf> i think I came across every type error ghc knows, so I figure it can't be done in the way I'm trying.
09:32:10 <pumpkin> although it is often relevant and the most appropriate answer ;)
09:32:16 * DBAlex goes and plays with ghci
09:32:18 <DBAlex> thanks! :)
09:32:20 <Cale> DBAlex: you can use all/any with any function that will test the elements of your list
09:32:36 <DBAlex> ok
09:32:59 <Cale> > any (\xs -> and $ zipWith (==) xs (tail xs)) [[1,2,1],[3,3,4]]
09:33:00 <lambdabot>   False
09:33:06 <kmc_> medfly: it's very common that IRC channels work by telling people how to find the answer to their own question
09:33:07 <Cale> > any (\xs -> and $ zipWith (==) xs (tail xs)) [[1,2,1],[3,3,4],[5,5,5],[7,8,7]]
09:33:08 <lambdabot>   True
09:33:25 <kmc_> personally i do sort of enjoy typing out monad tutorials here in full
09:33:29 <kmc_> but it's not an effective use of resources
09:33:33 <pumpkin> I've been on IRC on and off for over a decade and this is by far the friendliest, most helpful channel I've seen
09:33:47 <medfly> kmc_, this one just creates more questions. it doesn't go "rtfm", it goes "rtfm a bunch of other things".
09:34:01 <kmc_> well i didn't even see the comment that you're objecting to
09:34:12 <medfly> what comment?
09:34:27 <Apocalisp_> If I have two Data.Maps, and a monoid, I want to "zip" them together using the mappend, substituting the mempty for the values for keys missing from one or the other. Is there a generic term for this?
09:34:38 <pumpkin> I apparently offended medfly by claiming that (/= []) is not as nice as not . null
09:34:39 <DBAlex> Btw, this channel is great
09:34:49 <DBAlex> If you think it's unfriendly here, don't ever go to ##C
09:34:51 <DBAlex> ;)
09:34:54 <kmc_> haha, true that
09:34:59 <pumpkin> @quote ##c++
09:35:00 <lambdabot> dibblego says: [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
09:35:05 <pumpkin> boo
09:35:09 <kmc_> in ##c++ they have a bot just for dispensing snark to people
09:35:13 <kmc_> @quote ##c\+\+
09:35:14 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
09:35:20 <pumpkin> aha
09:35:28 <DBAlex> ##C is just evil
09:35:32 * Cale notices that he's been IRCing for 15 years now.
09:35:35 <Raevel> id also be unfriendly if i was a c guy
09:35:49 <DBAlex> I wouldn't reccomend going unless you are an expert and know K&R cover to cover
09:36:05 <Zao> Fun fact of the day - list-based prime sieves have suboptimal performance characteristics.
09:36:09 <DBAlex> You better know K&R better than Kernighan and Ritchie :P
09:36:13 <pumpkin> zhivago will own your ass
09:36:31 <Apocalisp_> In general, I want to go from Monoid a, to Monoid (f a).
09:36:42 <kmc_> yeah, i was answering beginner questions in there, then one day i said something incorrect about VLAs
09:36:45 <DBAlex> pumpkin: yup!
09:36:48 <kmc_> and they basically told me to get the fuck out
09:36:54 <kmc_> seriously, who even uses VLAs
09:37:01 * pumpkin does =[
09:37:05 <DBAlex> VLA?
09:37:11 <kmc_> variable length array
09:37:15 <kmc_> it's a feature in C99 i think
09:37:18 <pumpkin> yeah
09:37:19 <DBAlex> ah
09:37:20 <medfly> sounds like a really nice thing!
09:37:22 <DBAlex> Linked lists!
09:37:25 <kmc_> no
09:37:31 <pumpkin> it's basically syntactic sugar for alloca
09:37:35 <DBAlex> Heh
09:37:43 <kmc_> it means that sizeof() is sometimes a runtime function
09:37:48 <DBAlex> No I mean, better to use linked lists right?
09:37:52 <Apocalisp_> Seems like we need a bot for keeping people on topic.
09:37:54 <pumpkin> DBAlex: depends what you need :)
09:37:54 <Cale> Apocalisp_: unionWith
09:38:01 <DBAlex> pumpkin: I guess
09:38:09 <ben> Apocalisp_: Down that path lies ##c++
09:38:14 <Cale> Well, unionWith mappend
09:38:20 <Apocalisp_> ben: Heh. I know.
09:38:25 <pumpkin> DBAlex: if I need a quick O(1) indexing structure for a local computation, then VLA is nice
09:38:27 <DBAlex> In C++ I tend to use vector and try and forget what It crap it's doing behind the scenes
09:38:36 <DBAlex> I'm sure it malloc's much more efficiently than I could...
09:38:38 <pumpkin> no allocation cost, you just add and subtract stack pointers
09:38:57 <pumpkin> well in c++ you get all that stack stuff for free
09:38:59 <mdmkolbe> How do I remove duplicates from a list?
09:39:00 <pumpkin> assuming you use it
09:39:03 <pumpkin> mdmkolbe: nub
09:39:10 <Apocalisp_> Cale: That's specialised for maps. Is there some typeclass describing structures into which you can lift a monoid in this manner?
09:39:15 <pumpkin> or if you don't care about order and want speed, Data.Set.toList . Data.Set.fromList
09:39:16 <kmc_> > nub "mississippi"
09:39:17 <lambdabot>   "misp"
09:39:27 <mdmkolbe> pumpkin: thanks
09:39:35 <kmc_> :t S.toList . S.fromList
09:39:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:39:41 <Apocalisp_> Cale: ... for which unionWith would be the instance for Map
09:39:43 <kmc_> > (S.toList . S.fromList) "mississippi"
09:39:44 <lambdabot>   "imps"
09:39:50 <ben> pumpkin: C++ gives us VLAs?
09:39:50 <kmc_> > (S.toList . S.fromList) $ concat cake
09:39:52 <lambdabot>   " ',-.1258:ACDFINOPSTUabcdefghijklmnoprstuvwxyz"
09:39:52 <Cale> Apocalisp_: Some people have defined a subclass of functors for which there's a "zip" or "zipWith", but not in the standard libraries.
09:40:00 <Zao> ben: No.
09:40:04 <pumpkin> ben: C++ gives you the ability to put anything on the stack
09:40:20 <ben> But it still has to do heap allocations in the background
09:40:28 <pumpkin> ?
09:40:32 <ben> ?
09:40:38 <pumpkin> only if your structure is doing heap allocations of its own
09:40:39 <kmc_> you can stack-allocate an object whose constructor calls "new", of course
09:40:41 <kmc_> yeah
09:40:41 <pumpkin> or you write new
09:40:49 <Apocalisp_> Cale: zip and zipWith take (a -> b -> c), but I specifically want (Monoid a)
09:41:22 <Apocalisp_> Cale: Because I need to be able to substitute "holes" in one structure with the mempty from the monoid.
09:41:41 * pumpkin be Heytin'
09:41:55 <Cale> Apocalisp_: Right, so it's not even quite the same as the class people invent for zipping things. You could just write a lifting monoid instance.
09:42:11 <Cale> instance Monoid a => Monoid (MyFunctor a) where
09:42:12 <Cale>   ...
09:42:29 <Apocalisp_> yeah, that's what I had started. Thanks, Cale.
09:42:37 <absentia> brb
09:42:56 <xerox> pumpkin haha
09:43:05 <pumpkin> :)
09:43:28 <kmc_> > sort "the quick brown fox jumps over the lazy dog"
09:43:29 <lambdabot>   "        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
09:44:36 <lispy> > nub . sort $ "the quick brown fox jumps over the lazy dog"
09:44:37 <lambdabot>   " abcdefghijklmnopqrstuvwxyz"
09:44:46 <mreh> hey there are more than one 'e' and 'o' in that sentance
09:44:50 <narens> hello, could someone tell me what library provides traversal and other things for Data.Tree? I've searched Hackage and can't seem to find it
09:44:58 <mreh> Traversable
09:44:59 <Cale> > map (head &&& length) . group . sort $ "the quick brown fox jumps over the lazy dog"
09:45:00 <lambdabot>   [(' ',8),('a',1),('b',1),('c',1),('d',1),('e',3),('f',1),('g',1),('h',2),('...
09:45:14 <c_wraith> I thought it was the dog that was brown
09:45:26 <lispy> > nub . sort $ "the quick brown fox jumps over the lazy dog" == [' ', 'a', .., 'z']
09:45:27 <lambdabot>   <no location info>: parse error on input `..'
09:45:31 <mreh> everyone knows that foxes are brown
09:45:34 <Cale> > nub "the quick brown fox jumps over the lazy dog"
09:45:35 <lambdabot>   "the quickbrownfxjmpsvlazydg"
09:45:37 <mreh> narens: Traversable
09:45:51 <mreh> it's a type class
09:46:00 <lispy> > nub . sort $ "the quick brown fox jumps over the lazy dog" == (' ' : ['a' .. 'z'])
09:46:01 <lambdabot>   Couldn't match expected type `[a]'
09:46:01 <lambdabot>         against inferred type `GHC.Bool....
09:46:07 <lispy> doh!
09:46:18 <pumpkin> lithpy
09:46:24 <narens> mreh: I don't think thats the one. I think this is an entire mutable library for trees
09:46:59 <narens> mreh: i think its written by nick somebody .. if i am not mistaken. I just can't remember
09:47:03 <lispy> oh, I'm just missing some parens
09:47:12 <lispy> > (nub . sort $ "the quick brown fox jumps over the lazy dog") == (' ' : ['a' .. 'z'])
09:47:13 <lambdabot>   True
09:47:19 <mreh> narens: I dont know it, sorry :)
09:48:08 <Saizan> mutable and Data.Tree don't mix, someone might have written a zipper for it though
09:48:20 <narens> Saizan: ah, thats it. a zipper
09:48:41 <Saizan> narens: http://hackage.haskell.org/package/rosezipper-0.1
09:48:42 <narens> Siazon: found it! thanks! rosezipper
09:48:49 <narens> excellent
09:49:30 <Saizan> mh, Siazon is new :)
09:49:58 <mdmkolbe> ok, so now my real question.  How to generate all the subsequences of a list?  (e.g. for "abc" they should be "", "a", "b", "c", "ab", "ac", "bc" and "abc"  **NOTE** that "bc" is a subsequence)
09:50:21 <narens> Saizan: maybe I can get some input here. I want to create a generic module to take care of command line menu system. So, i wanted to use a tree where the values are IO actions. Is that good design?
09:50:32 <xerox> > subsequences "abc"
09:50:33 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
09:50:49 <Twey> > concatMap inits $ tails "abc"
09:50:50 <lambdabot>   ["","a","ab","abc","","b","bc","","c",""]
09:50:52 <Saizan> narens: sounds good
09:51:03 <mdmkolbe> @where subsequences
09:51:04 <lambdabot> I know nothing about subsequences.
09:51:09 <Twey> @index subsequences
09:51:09 <lambdabot> bzzt
09:51:10 <narens> Saizan: cool.
09:51:13 <Twey> *shrug*
09:51:14 <kmc_> > mapM (const [False ..]) "abc"
09:51:15 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
09:51:21 <kmc_> err that's not it...
09:51:26 <xerox> mdmkolbe Data.List
09:51:39 <Saizan> > foldrM  (const [False ..]) "abc"
09:51:41 <lambdabot>   Not in scope: `foldrM'
09:51:48 <Saizan> > filterM  (const [False ..]) "abc"
09:51:49 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
09:51:57 <Twey> > ([] :) . filter (not . null) . concatMap inits . tails $ "abc"
09:51:58 <lambdabot>   ["","a","ab","abc","b","bc","c"]
09:52:11 <mdmkolbe> Twey: awsome (like the last line of the evolution of a haskell programmer)
09:52:30 <Twey> Of course you should use the predefined one if it exists
09:52:35 <Twey> I've just never seen it before
09:52:52 <Twey> @src subsequences
09:52:52 <lambdabot> Source not found.
09:52:56 <Twey> *shrug*
09:53:08 <Saizan> Twey: you miss ac!
09:53:27 <mdmkolbe> sorry, I meant to say that to xerox not Twey
09:54:01 <Twey> Saizan: I do?
09:54:02 <xerox> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#subsequences
09:54:12 <Twey> mdmkolbe: Damn ;þ
10:01:07 <ddarius> pumpkin: Your foul mouth is now immortalized.
10:01:13 <pumpkin> I saw :(
10:01:26 <pumpkin> at least he didn't take any of my citations of Gabriel
10:03:05 <DekuNut> Help D:, lambdabot is temperamental
10:03:12 <DekuNut> ?src Maybe (==)
10:03:13 <lambdabot> Source not found. Sorry.
10:04:15 <BenceF> heyy is there NaN in haskell?
10:04:26 <Saizan> > 0 / 0
10:04:27 <lambdabot>   NaN
10:04:29 <ddarius> If isIEEE returns true, then yes.
10:04:32 <DekuNut> :t NaN
10:04:33 <pumpkin> > join (/) 0
10:04:33 <lambdabot> Not in scope: data constructor `NaN'
10:04:34 <lambdabot>   NaN
10:04:36 <ddarius> If it doesn't, then maybe.
10:04:48 <ddarius> > isIEEE 1
10:04:49 <lambdabot>   True
10:05:11 <Cale> > isNaN (0 / 0 :: Double)
10:05:12 <lambdabot>   True
10:05:25 <DekuNut> What exactly is that NaN output? Printed from an exception?
10:05:34 <MissPiggy> oh hey Cale
10:05:41 <Cale> NaN is a floating point value.
10:05:41 <ddarius> DekuNut: It's just how the Show instance shows NaN.
10:05:49 <kmc_> NaN isn't an exception (in the control flow sense)
10:06:00 <MissPiggy> I realized that what I said yesterday, about defining  a = b <=> runST a x = runST b x   was wrong
10:06:02 <Cale> Which signifies a particular type of divergence in a calculation
10:06:06 <DekuNut> If it's a value, why doesn't it have a type?
10:06:07 <DekuNut> :t NaN
10:06:08 <kmc_> it's a regular floating point value, but is sometimes called an "exceptional floating point value"
10:06:09 <lambdabot> Not in scope: data constructor `NaN'
10:06:18 <MissPiggy> it can't work because of the types, and I don't know how to correct that
10:06:23 <BenceF> thats the coolest, cause mx next question was gonna be how do i use NaN for Float
10:06:25 <kmc_> the Show instance generates a string which is not a valid Haskell expression
10:06:25 <BenceF> :)
10:06:32 <MissPiggy> maybe that Prompt thing IS the solution
10:06:39 <MissPiggy> but it's really difficult :D
10:06:41 <ddarius> DekuNut: It's how that value is displayed.  NaN isn't a constructor or a valid expression (in the Prelude context)
10:06:50 <Cale> MissPiggy: It's not really that difficult.
10:07:08 <pumpkin> it'd be nice if Float were defined that way
10:07:09 <DekuNut> ddarius, I'm a little lost by this, I don't understand how it can be a value, yet have no type
10:07:17 <DekuNut> It would need a type to be an instance of Show
10:07:18 <kmc_> it has a type
10:07:23 <kmc_> its type is Float or Double etc
10:07:26 <kmc_> :t 0/0
10:07:27 <lambdabot> forall t. (Fractional t) => t
10:07:27 <kmc_> > 0/0
10:07:28 <Berengal> > read "NaN" :: Float
10:07:28 <lambdabot>   NaN
10:07:29 <lambdabot>   NaN
10:07:30 <pumpkin> data Float = NaN | Infinity | NegativeInfinity | Value FloatValue
10:07:41 <pumpkin> but without the explicit Value constructor
10:07:44 <kmc_> > show (0/0)
10:07:45 <lambdabot>   "NaN"
10:07:47 <DekuNut> Oh
10:07:52 <DekuNut> Yeah I get what you mean, sorry I confused myself
10:07:53 <kmc_> > read "NaN" :: Float
10:07:54 <lambdabot>   NaN
10:08:02 <kmc_> > NaN :: Float
10:08:03 <lambdabot>   Not in scope: data constructor `NaN'
10:08:42 <BenceF> so i should     data Mydatatype = NaN | Mydatatype value        ?
10:09:02 <MissPiggy> data MyDataType = ...
10:09:10 <MissPiggy> data MyDataType value = ...
10:09:35 <DekuNut> Right, the other question though, why will lambdabot not cough up the source:
10:09:41 <BenceF> ok im getting lost again with data
10:09:41 <DekuNut> ?src Maybe (==)
10:09:41 <lambdabot> Source not found. Where did you learn to type?
10:09:51 <ddarius> BenceF: Calling a constructor NaN doesn't do anything different than calling it Bar would.
10:09:56 <kmc_> because lambdabot has a small and arbitrary database of source
10:10:01 <ddarius> DekuNut: It's derived.
10:10:28 <kmc_> because @src simply searches a text file and nobody added that one to the text file
10:10:31 <Cale> BenceF: NaN is already a part of Float and Double. You can access it explicitly by writing 0/0.
10:10:41 <BenceF> ok. ill try that
10:10:50 <DekuNut> Ah, thansk kmc_
10:10:56 <Cale> BenceF: If you want to indicate the failure of a computation, you should use the Maybe type.
10:11:00 <ddarius> kmc_: I'm pretty sure there isn't anything to add.  I'm pretty sure the Prelude and GHC define that by data Maybe a = ... deriving (Eq, Show, etc.)
10:11:13 <ddarius> s/Prelude/Report
10:11:46 <DekuNut> Oh right, as in
10:11:54 <DekuNut> The compiler automatically derives Eq? etc
10:12:30 <ddarius> It will automatically derive Eq if you ask for it.
10:12:39 <kmc_> ddarius: but it could be instructive to add a non-derived instance to the @src databaseu
10:12:55 <Cale> It's just the obvious thing.
10:13:01 <BenceF> Cale: then ill read about Maybe that sounds more proper.
10:13:06 <Cale> instance Eq a => Eq (Maybe a) where
10:13:18 <Cale>   Nothing == Nothing = True
10:13:29 <Cale>   Just x == Just y = x == y
10:13:32 <DekuNut> Nah I can guess the definition easy enough, I was just wondering why lambdabot wasn't able to find it
10:13:34 <Cale>   _ == _ = False
10:14:02 <DekuNut> I also didn't know the Eq was derived automatically, I knew Show was but not Eq, how would Eq know what to compare in the case of something like
10:14:06 <BenceF> Cale: could you write that template to a pastebin for me?
10:14:12 <DekuNut> data MyType a b = MyType a b
10:14:21 <kmc_> DekuNut: the instance will get an (Eq a, Eq b) constraint
10:14:40 <DekuNut> Ah, so it will compare both a and b then
10:14:44 <Cale> yep
10:14:49 <DekuNut> Pretty badass
10:14:50 <kmc_> instance (Eq a, Eq b) => Eq (MyType a b) where { MyType a1 b1 == MyType a2 b2 = (a1 == a2) && (b1 == b2) }
10:14:58 <Cale> and if you derive Ord, it will compare in lexicographical order
10:15:12 <DekuNut> I love haskell
10:15:22 <Cale> BenceF: What template?
10:15:33 <kmc_> DekuNut: the Haskell report specifies a few typeclasses for which an implementation must support "derive".  GHC supports a few more
10:15:50 <BenceF> the eq instance
10:15:53 <DekuNut> Yeah, I was aware of Haskell98 requiring Show, but not the others
10:15:58 <DekuNut> Thanks kmc_, Cale
10:16:00 <Cale> BenceF: It's not intended for actual use.
10:16:05 <kmc_> http://www.haskell.org/onlinereport/derived.html
10:16:26 <kmc_> H98: Eq, Ord, Enum, Bounded, Read, Show
10:16:27 <Cale> BenceF: I just wrote essentially what the compiler derives.
10:17:14 <kmc_> GHC: Typeable, Data, Functor, Foldable, Traversable, any class for a "newtype"
10:17:33 <kmc_> i also saw some code claim that GHC can derive Storable, but I haven't seen that documented anywhere
10:18:17 <DekuNut> I'll need to check out Storable, that sounds interesting. Also Functor, especially after finding about about Contrafunctors and the like, I'd like to see if it dies
10:19:20 <kmc_> Storable allows you to peek/poke the value via an explicit pointer.  mostly useful when marshaling in C FFI interfaces
10:19:42 <BenceF> ok im gonna tell what i wanna do. im writing a vector library as an excercise. and i wanna handle somehow when you try to add vectors of different dimensions
10:20:26 <DekuNut> I see, kmc_ while I have you actually, hold on
10:20:29 <BenceF> so i should use maybe?
10:20:48 <kmc_> BenceF: if you are implementing Num's (+), you can't
10:20:56 <BenceF> no
10:21:00 <kmc_> if you're implementing addition yourself, makes sense
10:21:11 <BenceF> its .+.
10:21:11 <kmc_> but there are alternatives
10:21:34 <kmc_> if you return a Maybe value, users will probably want to do nested calculations via Maybe's Monad or Applicative instances
10:21:39 <kmc_> and that could get cumbersome
10:21:49 <BenceF> i have addition subtarction and scalar product so far
10:22:06 <kmc_> you can throw a "real" exception without affecting the type, but you can only catch it in IO
10:22:20 <BenceF> thats what i thought
10:22:50 <BenceF> otherwise i should return Maybe Vector ?
10:23:09 <kmc_> or you can introduce another vector value that represents an error, and propagate errors silently... this is how NaN works for floating point values (in most every language)
10:23:53 <DekuNut> kmc_, http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Foreign-C-Types.html#(line99)
10:23:56 <kmc_> floats are a special case, though, because usually what the user wants is exact real arithmetic, and floating point is a leaky abstraction providing an approximation of that
10:24:02 <BenceF> like mismatch = Vector [0/0] ?
10:24:09 <DekuNut> Sorry, didn't mean to interrupt, I'll wait
10:24:09 <kmc_> no
10:24:10 <MissPiggy> 0/0] ?
10:24:23 <kmc_> data Vector = GoodVector [Double] | BadVector
10:24:30 <kmc_> the reference to NaN was an analogy only
10:24:48 <kmc_> DekuNut: no problem.  what's your question?
10:24:54 <MissPiggy> basically symbols don't mean anything
10:25:01 <MissPiggy> is that what you are getting at?
10:25:22 <DekuNut> kmc_ right yeah, inside CTypes.h (I can't remember where the file is on my drive), there's several C style defines which just define the C version of HTYPE_Whatever
10:25:24 <BenceF> oh i get it. and i should return BadVector which is still a Vector
10:25:35 <DekuNut> Which is fine, and I've seen several macro definitions in some haskell source files
10:25:44 <DekuNut> but where does INTEGRAL_TYPE come from, and it's brothers
10:26:02 <BenceF> and i could derive Show for BadVector as an error message
10:26:25 <kmc_> DekuNut: probably from one of the files #included by that file
10:26:39 <kmc_> i don't think there are any "built in" CPP symbols
10:28:03 <DekuNut> I need to find it, I mean
10:28:09 <zygoloid> kmc_: there's a list of predefined macros here: http://haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
10:28:36 <kmc_> ah good call
10:29:28 <DekuNut> I don't see anything about these types though, need to track down a CTypes.h file, I don't appear to have one
10:29:40 <BenceF> It works as expected
10:29:55 <BenceF> and i can even patternmatch it this way
10:29:59 <BenceF> this rules
10:30:14 <kmc_> sure, but you can pattern match a Maybe Vector too
10:31:00 <BenceF> yeah but it tells more for me
10:32:01 <BenceF> now on to implementing vector product :) dont tell. i wanna figure it out on my own
10:32:13 <MissPiggy> vector product???
10:32:57 <pumpkin> cross, dot, or pointwise? :O
10:33:03 <BenceF> dont know. how does it called in english
10:33:05 <pumpkin> or many others
10:33:29 <BenceF> cross
10:33:54 <BenceF> whats pointwise?
10:34:23 <MissPiggy> outer product only exists in 3D?
10:34:29 <pumpkin> and 7
10:34:32 <pumpkin> apparently
10:34:34 <MissPiggy> what lol
10:34:38 <BenceF> :D
10:34:40 <MissPiggy> do you think there's a 7D world
10:34:44 <pumpkin> hell yeah!
10:34:46 <BenceF> 11
10:34:50 <BenceF> isnt it?
10:35:05 <int-e> BenceF: (a, b) * (c, d) = (a*c, b*d). In general f * g = \x -> f x * g x  would be the pointwise product of f and g.
10:35:20 <Cale> You can take the cross product of (n-1) vectors in F^n.
10:35:25 <pumpkin> http://en.wikipedia.org/wiki/Seven-dimensional_cross_product
10:35:26 <MissPiggy> have anyone figured out why the world is 3D? (other than some terribly vauge anthropic principle)
10:35:42 <Cale> The seven dimensional cross product is something else though.
10:35:46 <int-e> MissPiggy: ask your favourite String theorist about that
10:35:50 <kmc_> they'll say it's not
10:35:51 <BenceF> int-e: where is that used?
10:36:06 <Cale> (A different, more algebraic generalisation of it)
10:36:25 <MissPiggy> int-e, if a string theorist shows me a non-self-intersecting klein bottle maybe I'd listen, but until then the world is 3D
10:36:39 <int-e> BenceF: it has no geometric relevance, I think (it's not invariant under orthonormal transformations for starters)
10:37:15 <BenceF> MissPiggy: if he would show you one, you would only see its 3d projection
10:37:25 <BenceF> which still intersects
10:37:32 <int-e> BenceF: on the other hand we write stuff like  2 * sin(x) * cos(x) = sin(2*x) all the time and think of these as functions.
10:37:35 <MissPiggy> copumpkin "The seven-dimensional cross product has the same relationship to the octonions  as the three-dimensional cross product does to the quaternions." -- so why isn't there a 15 dimensional one?
10:38:40 <MissPiggy> BenceF, yeah gonna stick with 3D then :P
10:38:44 <Cale> MissPiggy: It's very much dependent on how you define "cross product"
10:39:34 <kmc_> that wp page gives a general definition
10:39:43 <Cale> Yeah
10:39:52 <kmc_> "the cross product should be perpendicular to each of its arguments.... the norm of the cross product should be equal to the area of the parallelogram formed by the arguments."
10:40:10 <MissPiggy> wow octonions are nonassociative
10:40:26 <MissPiggy> but they go well with lamb??
10:41:43 <Cale> MissPiggy: It's a meaningless question to ask if the universe is *really* n-dimensional for any given n. A better question to ask is how many dimensions are needed in various physical models.
10:42:40 <Cale> General relativity uses a 4-dimensional spacetime, but it's not just R^4, but a different manifold that has intrinsic curvature.
10:42:48 <MissPiggy> Cale, I do know you can say that -- it seems completely obvious to me that the world is 3D
10:43:06 <MissPiggy> maybe I don't go on enough 0.9xlight-speed travels
10:43:08 <Zao> Sooo... I've got an euler solution that will terminate in a week.
10:43:23 <kmc_> euler :(
10:43:24 <Zao> I have a feeling that it can be done _slightly_ faster.
10:43:24 <zygoloid> Zao: i'd suggest you need a new algorithm.
10:43:32 <Berengal> Zao: ByteString, seq, etc
10:43:37 <Zao> zygoloid: The optimized solution takes 8s.
10:43:38 <kmc_> no you should just rewrite it in Prolog
10:43:42 <zygoloid> or possibly a computer from this century or the previous one :)
10:43:44 <Zao> zygoloid: And that's not even the clever way to solve it.
10:43:48 <kmc_> no wait, Scala
10:43:52 <Cale> (you can see this curvature every time you throw a ball up and it travels along an apparently curved path which is (ignoring air resistance) the straightest path it can follow through spacetime.
10:43:52 <kmc_> no wait, learn category theory instead
10:44:02 <MissPiggy> kmc_ what do you mean? prolog can be efficient
10:44:15 <Berengal> zygoloid: Nonsense! Algorithms only provide small improvements! You need assembly to get real speed!
10:44:16 <Zao> The week one used a list of 78k primes. The fast one a 1M element array of Bool.
10:44:26 <Zao> O(1) primality testing vs O(N) helps.
10:44:35 <kmc_> haha Berengal
10:44:36 <mreh> how can I get latex code from my haskell sources (non-literate)? or import the code wth the proper highlighting
10:44:55 <MissPiggy> Cale, my point is that I can build a cube and not a klien bottle
10:44:57 <kmc_> (echo '\begin{code}'; cat foo.hs; echo '\end{code}') | lhs2tex
10:45:00 <kmc_> :D
10:45:15 <Cale> MissPiggy: A Klein bottle is not that hard to build.
10:45:19 <mreh> latex can do that?!
10:45:21 <mreh> amazing
10:45:34 <MissPiggy> Cale, :(
10:45:48 <kmc_> lhs2tex formats haskell code as latex
10:45:50 <MissPiggy> am I just this crazy person that thinks th eworld is FLAT?
10:45:55 <kmc_> MissPiggy: yes
10:46:03 <MissPiggy> haha damn oh well
10:46:08 <kmc_> also, lhs2tex supports various options to make it look nicer
10:46:21 <mreh> I'm not doing lhs
10:46:29 <mreh> but I'll investigate
10:46:40 <kmc_> mreh: right.  which is what the 'echo' is for
10:46:43 <zygoloid> "Oleg: he who inhabits all types but is not _|_" <- love this
10:46:51 <BenceF> MissPiggy: have you got muscles which can move in 4d?
10:46:51 <kmc_> makes your standard hs source into latex-style lhs
10:47:00 <Cale> Of course, an embedding into 3 dimensional space is impossible. The best you can hope for is an immersion.
10:47:13 <MissPiggy> oh sure the nervous system is like a million degrees (dimension) of freedom
10:47:19 <MissPiggy> but that's not what I am talking about
10:47:43 <MissPiggy> what's an immersion?
10:47:50 <zygoloid> kmc_: don't you need an | awk '{ print "> $0" }' in there or something?
10:48:00 <kmc_> zygoloid: that'd be for Bird-style lhs
10:48:12 <Cale> MissPiggy: A differentiable map whose derivative is everywhere injective.
10:48:14 <kmc_> tex-style lhs encloses code in \begin{code} ... \end{code} with no per-line marker needed
10:48:22 <MissPiggy> hmm
10:48:22 <Cale> (but which itself may fail to be injective)
10:48:36 <MissPiggy> everywhere injective but isn't injective ? D:
10:48:41 <Cale> http://en.wikipedia.org/wiki/File:Klein_bottle.svg
10:48:43 <zygoloid> kmc_: ok :)
10:48:55 <Cale> That's a picture of an immersion of the Klein bottle into R^3.
10:49:01 <MissPiggy> it self intersects
10:49:06 <MissPiggy> how is that injective?
10:49:15 <Cale> The *derivative* is injective at each point.
10:49:20 <MissPiggy> ohh
10:49:31 <kmc_> what does that mean, intuitively?
10:50:00 <zygoloid> kmc_: around each point there's an open set which is mapped injectively
10:50:39 <Cale> Yeah, that's a good way to put it.
10:50:42 <zygoloid> the reverse image of each point doesn't contain arbitrarily close-together points
10:50:52 * hackagebot upload: progression 0.2 - Automates the recording and graphing of criterion benchmarks (NeilBrown)
10:51:04 <kmc_> ah
10:51:39 * MissPiggy still isn't relaly getting it but okay
10:52:05 <kmc_> so on the intersection points on the klein bottle, a single point's preimage has two distinct points, but those points can be separated by disjoint open sets
10:52:20 <zygoloid> yes
10:52:20 <Cale> yeah
10:52:37 <BenceF> MissPiggy: imagine thefollowing: youre a 2D creature, you see an 8 shape which intersects, but in 3D its a projection of a closed rope which is twisted
10:52:39 <kmc_> i don't see how that relates to the derivative
10:53:25 <Cale> MissPiggy: It's not hard to imagine how the 4D embedding can be obtained from that 3D immersion. You just take the part where it self-intersects, and push that out in the new direction a little.
10:53:29 <BenceF> no thats maybe not a good example
10:53:41 <BenceF> mine
10:53:47 <MissPiggy> I can imagine the 4D version
10:53:53 <BenceF> but ill think up a better one
10:53:58 <aledge> Cale, the analogy sounds like you are compressing the surface to fit in the smaller space
10:54:12 <aledge> Cale, is that somewhat of a crude but reasonable mental image?
10:54:17 <MissPiggy> and I know that you can't have a non-self-intersecting klien bottle in 3D, OR this world
10:54:21 <MissPiggy> so I conclude this world is 3D
10:54:41 <kmc_> you know you can't have a non-self-intersecting klein bottle in this world?
10:54:43 <kmc_> how?
10:54:44 <MissPiggy> (and by this world I mean the one I'm in.. dunno about you worm hole people from the future)
10:54:44 <Veinor> I like this description of Oleg: 'he who inhabits all types, but is not _|_'
10:54:45 <kmc_> you haven't seen one
10:54:55 <kmc_> yet
10:55:00 <zygoloid> am i right in thinking that a moebius strip can't be immersed in R2?
10:55:06 <Veinor> zygoloid: yes.
10:55:07 <Cale> aledge: Which analogy?
10:55:14 <MissPiggy> kmc_ how do you know there's not an invisible dragon in my garage?
10:55:24 <BenceF> the observations of space corresponds to a more than 3 dimensional universe
10:55:35 <aledge> Cale, err, s/the analogy/it
10:55:49 <kmc_> i don't
10:56:33 <BenceF> measure the effects of the dragons gravity
10:57:21 * quicksilver thinks the invisible dragon probably ate MissPiggy, and it's actually the dragon on IRC now.
10:58:15 <lament> the sight of an invisible creature eating a human must be quite disturbing
10:58:26 <Cale> aledge: The one for immersion? An immersion sort of loosely folds one manifold up so that it fits into another, but it does so in a particularly nice way, so that even if it's not an injective map (some points in the domain are sent to the same point in the codomain), you might roughly think of it as being that there's some minimum distance between any two points that are being sent to the same point, so you can't just
10:58:26 <Cale>  crush out details altogether, or have something which doubles back on itself.
10:58:54 <Veinor> whee, alexander's horned sphere
10:59:25 <aledge> Cale, so an immersion differs from just a regular projection in that it has those nice properties
10:59:28 <Cale> yeah
11:00:15 <aledge> ok
11:00:17 <Cale> You can't immerse a circle into the real line for example.
11:00:54 <quicksilver> but you can immerse a circle onto itself in some interesting non-identity ways, like 'going around twice'
11:01:04 <Cale> yeah :)
11:01:14 <MissPiggy> is this topology?
11:01:21 <Zao> It's madness.
11:01:25 <MissPiggy> heh
11:01:28 <Cale> topology / differential geometry
11:01:29 <MissPiggy> or homotopy
11:01:44 <MissPiggy> everyone seems to have an intuitive understanding of differential geometry and special relativity
11:01:49 <MissPiggy> for me it's a mystery, so it's kind of scary :P
11:01:55 <BenceF> you only see (<1 1 1 0> Dragon) however all off the dragons points are (0 0 0 l) thats why you dont see it
11:02:30 <osaunders> w00t! My password generator <http://codepad.org/HOfIGm2N>. What do you guys think?
11:02:50 <BenceF> osaunders: is it 4dimensional ?
11:03:29 <osaunders> I don't think so.
11:04:08 <BenceF> its 404ed for me
11:04:16 <BenceF> so maybe it is after all
11:04:17 <MissPiggy> osaunders: that's pretty cool I'm probably going to use it
11:04:31 <osaunders> I think pick and patternPick could be improved by using a monad to handle the passing over of new random generators.
11:04:35 <mauke> how random is StdGen?
11:04:39 <BenceF> ohh i see what did i do wrong
11:04:51 <Alpounet> mauke, not the best around
11:05:46 <aavogt> isn't StdGen seeded off of the system clock?
11:05:49 <Alpounet> http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
11:06:13 <aavogt> @hackage monadrandom
11:06:14 <lambdabot> http://hackage.haskell.org/package/monadrandom
11:06:21 <osaunders> aavogt: It is when you use getStdRandom
11:06:30 <aavogt> @hackage MonadRandom
11:06:31 <lambdabot> http://hackage.haskell.org/package/MonadRandom
11:06:46 <c_wraith> MonadRandom is no improvement, though.  It punts on the issue of generator source and quality
11:06:54 * c_wraith is dealing with that right now
11:07:30 <quicksilver> well 'seeded off' / quality of the PRNG are independent notions
11:07:38 <quicksilver> I think the seeding is probably fine
11:07:45 <osaunders> The documentation on Random makes some references to books to how random it is exactly.
11:07:45 <quicksilver> it's just a fairly simplistic and slow PRNG
11:08:25 <osaunders> c_wraith: You're using a monad in random generation?
11:09:15 <c_wraith> osaunders: I like the MonadRandom idea, in that you present a consistent interface to randomness without caring about the details...  But it's really hard to get a good source into the interface.
11:09:34 <osaunders> MissPiggy: Sorry I forget to respond, thank you and you may use this if you wish.
11:09:55 <c_wraith> osaunders: and yes, the generation is being done in monad contexts
11:10:57 <c_wraith> blah.  Has no one written a framework for secure random generation in Haskell?
11:11:56 <osaunders> c_wraith: What do you mean "really hard to get a good source into the interface"?
11:12:32 <c_wraith> osaunders: There's no apparent crypto-quality source that implements MonadRandom.  Nor are there even good tools for fitting the pieces together.
11:14:10 <osaunders> Hm.
11:15:19 <BenceF> pure functions always give the same output on the same input, so you gotta use monads for random. do i get it wrong?
11:15:56 <MissPiggy> BenceF, sounds good to me
11:16:03 <osaunders> BenceF: Oh yeah, but there's an additional use of monads here. (At least that's what I'm talking about).
11:16:08 <c_wraith> BenceF: You can always write a function that takes an initial PRNG state, and returns a different PRNG state.  MonadRandom lets you implicitly sequence events that do that.
11:16:56 <c_wraith> I'm specifically looking at the problem that the MonadRandom instance for IO is bad in every way possible.  Slow, not a great generator, bases its seed on the time.
11:17:14 <osaunders> Right, the way Random works is that you create a generator and that will give you one random number and another generator.
11:17:39 <aledge> like diablo1
11:17:50 <osaunders> And if you want a whole slew of random numbers you have to use the new generator and then get another new generator two get a third and so on.
11:17:59 <osaunders> *to get a third
11:18:04 <medfly> @hoogle randoms
11:18:05 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
11:18:13 <medfly> ??
11:18:20 <osaunders> Yeah that does it for you.
11:18:48 <aavogt> you lose the RandomGen because it doesn't know how much you're going to consume
11:19:03 <osaunders> Except you need to use those new generators or else you'll end up generating the same things again.
11:19:17 <osaunders> randoms discards it.
11:19:27 <osaunders> (Such is my understanding).
11:20:04 <osaunders> do putStrLn $ show $ randoms someGen; putStrLn $ show $ randoms someGen
11:20:10 <osaunders> ^ prints same thing twice
11:20:31 <osaunders> Uh, if it wasn't infinite that is. :P
11:20:45 <osaunders> You'd need take 10 .... in there or something.
11:22:52 <c_wraith> agh, Random is horrible.  why are randomRIO and randomIO in Random?
11:24:22 <quicksilver> in case they have a more efficient implementation, basically.
11:24:36 <quicksilver> (via mutationg instead of state copying)
11:24:57 <quicksilver> you could imagine that might be better for crypto algorithms which have huge states and cycle through which bits they mutate
11:25:04 <quicksilver> not that I know anything about crypto-random.
11:25:05 <BenceF> im waiting for quantumphysics to conclude theres no true random
11:26:19 <c_wraith> Looks like for a crypto-quality source for MonadRandom, it's going to have to be a wrapper around IO.  Well, that should be obvious.  Less obviously, it looks like it's going to have to create a new RandomGen of some sort for every call.
11:26:27 <mreh> the latex "listing" package's haskell syntax highlighting is bananas
11:27:17 <c_wraith> Hmm.  I should go with simplicity and optimize later.  Unless it's clearly a performance issue, I'll just use StdGen
11:28:53 <kmc_> do people here use the GHCi Debugger on a regular basis?
11:29:07 <BenceF> premature optimazation is the root of all evil
11:30:13 <kmc_> unfortunately, refactoring non-monadic to monadic code can be painful
11:31:02 <MissPiggy> use idiom brackets
11:31:13 <MissPiggy> that should make it easy
11:31:26 <kmc_> yeah, Applicative seems like a good fit for RNG
11:31:45 <osaunders> c_wraith: Sounds like a good decision.
11:32:16 <c_wraith> now for the fun part.  using binary to create a StdGen from /dev/urandom
11:32:21 <c_wraith> wee.  >_>
11:32:41 <Alpounet> heh
11:32:48 <osaunders> You know getStdRandom comes ready seeded?
11:33:07 <c_wraith> osaunders: from the current time.  Not secure
11:33:14 <kmc_> err, urandom is not secure either
11:33:18 <kmc_> use /dev/random if you care
11:33:27 <c_wraith> /dev/random blocks.
11:33:31 <kmc_> correct
11:33:40 <kmc_> it blocks rather than giving you shitty randomness
11:33:43 <osaunders> c_wraith: Do you need this kind of security?
11:33:48 <kmc_> if you are doing anything with security implications, you should not use StdGen
11:33:48 <c_wraith> osaunders: yes
11:34:22 <c_wraith> I'm kind of stuck with the interface Random gives.
11:34:31 <osaunders> kmc_: In an ideal world...
11:34:42 <c_wraith> I can't provide a RandomGen in IO
11:35:21 <c_wraith> and /dev/random is a ton better than any pure PRNG.
11:35:28 <c_wraith> err, /dev/urandom
11:35:40 <kmc_> then just read that
11:35:49 <c_wraith> I can't, due to the interface in use
11:35:57 <BenceF> hook up something to every port of your pc to populate /dev/random
11:36:06 <c_wraith> I have to go via the Random interface
11:36:14 <c_wraith> Which means I need a randomGen
11:36:20 <kmc_> StdGen is a crappy linear congruential generator, i think
11:36:32 <c_wraith> doesn't matter when you only read a few values from one before throwing it away.
11:36:35 <kmc_> c_wraith: you mean the RandomGen typeclass in System.Random?
11:36:42 <c_wraith> kmc_: yes
11:36:57 <c_wraith> kmc_ those unfortunately don't work in IO
11:37:50 <kmc_> @src IO
11:37:50 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:38:06 <kmc_> hmm, that looks a lot like next :: g -> (Int, g)  ;)
11:38:23 <kmc_> so yes, i would cheat and use unsafePerformIO
11:38:46 <gwern> how pleasant. ubuntu karmic koala did not render my computer unbootable this time
11:38:53 <c_wraith> How would you go about keeping it from being floated?
11:39:05 <kmc_> and thread a bogus gen value through, the same way GHC implements IO
11:39:12 <Twey> gwern: Quickly, perform a sacrifice giving thanks!
11:39:24 <gwern> Twey: I'm glad you volunteered!
11:39:30 <Twey> Ahh!
11:39:37 <c_wraith> kmc_: That requires a magical value along the lines of RealWorld
11:39:43 * gwern sacrifices Twey, burns the tenth as a holocaust, and hands about the rest to #haskell
11:40:02 <kmc_> c_wraith: in which way is it magical?
11:40:18 <BenceF> kmc_: turns into candy
11:40:45 <gwern> 3d accel seems to be still working, good
11:41:00 <c_wraith> "RealWorld is deeply magical. It is primitive, but it is not unlifted (hence ptrArg). We never manipulate values of type RealWorld; it's only used in the type system, to parameterise State#. "
11:41:13 * osaunders begins to eat candy, no really.
11:41:14 <BenceF> gwern: we had to revert to debian lenny
11:41:39 <gwern> d'oh! apparently no sound
11:42:03 <gwern> or no
11:42:06 <gwern> the volume was set to 0
11:42:08 <gwern> ???
11:42:20 <BenceF> alsa?
11:42:30 <osaunders> I'm trying to come up with a super simple thing I can write that requires a bunch of new types and typeclasses to be defined to cement my knowledge of them.
11:42:34 <BenceF> its always 0 after install
11:42:49 <kmc_> osaunders: scheme interpreter?
11:42:50 <gwern> BenceF: yeah, but this wasn't a new install - this was an upgrade from 9.04
11:43:12 <osaunders> kmc_: I don't know Scheme :-(
11:43:18 <kmc_> osaunders: it's easy
11:43:30 <kmc_> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:43:32 <gwern> (ok, video seems to work)
11:43:34 <Twey> osaunders: (func arg1 arg2 ... argN)
11:43:39 <BenceF> just parens and polish notation. its allthere is to it
11:43:45 <medfly> define
11:43:45 <Twey> Recurse as necessary
11:43:52 <kmc_> sure, that's all there is to the syntax
11:43:54 <kmc_> except not really that
11:43:59 <gwern> _Defcon_ plays
11:44:20 <kmc_> the hard part of learning any good language is not its syntax
11:44:25 * MissPiggy wants to rewrite write youself a scheme in 24 hours in 6 hours
11:44:31 <medfly> 48
11:44:37 <MissPiggy> ooh
11:44:40 <MissPiggy> nice idea,
11:44:46 <MissPiggy> Write yourself a Scheme in 10 years
11:44:49 <Twey> Hehe
11:44:51 <kmc_> hehe
11:44:55 <gwern> (gridwars plays too)
11:45:02 <Twey> Apparently the Scheme in that tutorial is pretty crap
11:45:02 <BenceF> id write it in an odd number of hours
11:45:07 <osaunders> kmc_: This might be quite a nice idea actually.
11:45:08 <Twey> Or the implementation of it
11:45:15 <kmc_> and in the case of Scheme, it's also misleading to say that the only syntax is parens and atoms
11:45:19 <osaunders> I guess 48 hours means programming hours not real-time.
11:45:28 <medfly> if you need 10 years to write Scheme, you're doing something wrong.
11:45:50 <Twey> kmc_: But those are all the handle you need to get to start getting stuck into building an interpreter for it.
11:46:19 <MissPiggy> it's not THAT bad a tutorial, but it's not /good/
11:46:24 <kmc_> seems like the interesting part of scheme's syntax is the enumeration of special forms
11:46:34 <kmc_> and you'd certainly need to know that to write an interpreter
11:46:52 <MissPiggy> the interesting thing for me is that you can stick with <s> ::= <a> | (<s> *) and still get by
11:47:05 <kmc_> scheme has a three-layer syntax
11:47:13 <kmc_> most languages have two roughly (lexical and grammatical)
11:47:20 <MissPiggy> hm, I only know 2? :)
11:47:20 <MissPiggy> what's the third
11:47:44 <kmc_> scheme is a lexical and grammatical syntax for writing values made of atoms and cons cells
11:47:55 <kmc_> and also a syntax for describing programs as atoms and cons cells
11:48:09 <kmc_> R6RS is fairly explicit about this separation
11:48:28 <kmc_> s/as/with/
11:48:42 <gwern> @quote install.*mage
11:48:42 <lambdabot> lispy says: I did, 'cabal install mage' and it complains about curses
11:48:49 <Twey> Haha
11:48:51 <gwern> @quote least.*funny
11:48:51 <lambdabot> lament says: just use fix to find the least funny joke
11:49:02 <gwern> @quote bicategory
11:49:02 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
11:49:14 <gwern> @flish
11:51:03 <osaunders> Mm candy was delicious.
11:51:31 <osaunders> Depressingly so.
11:51:44 <kmc_> it's a sad man indeed who can get depressed about candy
11:52:02 <gwern> firefox definitely seems snappier though
11:52:27 <osaunders> Yeah. I don't allow myself to eat candy usually. So having some and realizing how delicious it is makes me sad.
11:56:47 <tromp> some gums are ok
11:57:38 <lament> chocolate is still better than sex
11:57:55 <kmc_> disagree
11:58:46 <tARrAScH> I've always thought you never can have funtion like this: f :: IO a -> OtherMonad a. But apperently you can. Isn't the IO monad only one-way or something prohibiting such functions?
11:59:01 <kmc_> you can infact for IO as well
11:59:07 <kmc_> if OtherMonad is a monad transformer stack with IO at the bottom
11:59:28 <tromp> you just cannot strip off the IO
11:59:36 <kmc_> or otherwise incorporates IO
11:59:39 <mauke> f = const (fail "zomg")
11:59:41 <kmc_> here is a stupid example:
11:59:43 <kmc_> f x = [x]
11:59:46 <tromp> unless resorting to unsafePerformIO
11:59:47 <kmc_> f :: IO a -> [IO a]
11:59:55 <Twey> Well, you can do it anyway
12:00:10 <Twey> const :: IO a -> b
12:00:13 <tromp> oh, by ignoring input
12:00:15 <Twey> Yeah
12:00:17 <Twey> Er
12:00:22 <Twey> IO a -> b -> b
12:00:23 <Twey> No
12:00:25 <Twey> Ugh
12:00:28 <kmc_> IO values are first class; you can store them in data structures, and any monad is just a datastructure
12:00:39 <kmc_> f x = Just x;  f :: IO a -> Maybe (IO a)
12:00:40 <pikhq> Twey: flip const $ return (), though.
12:00:42 <Twey> const :: b -> IO a -> b
12:00:42 <ben> The list monad is not just a datastructure
12:00:47 <ben> The list monad is goddamn crazy
12:00:48 <Twey> pikhq: *nod*
12:00:49 <lament> any monad is Just a datastructure
12:01:02 <tARrAScH> Yea I managed to create my own identity function which takes an IO and ignores it. But is it possible to create functions that "makes sense" ?
12:01:06 <Twey> lament: Nothing to it!
12:01:21 <pikhq> :t liftIO
12:01:23 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:01:26 <kmc_> tARrAScH: yes, making lists of IO actions, or Maybe IO actions, or IO actions that yield other IO actions is quite common
12:01:29 <Twey> tARrAScH: You mean, functions that actually use the IO argument?  Not really.
12:01:32 <lament> Twey: Maybe we're not being general enough
12:01:35 <kmc_> of course you can use it
12:01:38 <kmc_> f x = [x] uses it
12:01:56 <kmc_> tARrAScH: i think you want to distinguish between merely using the argument (e.g. storing it in a data structure), and *executing* its effects
12:02:00 <Twey> lament: It'll get all dysFunctoral.
12:02:00 <tromp> f = repeat  uses it alot:)
12:02:03 <pikhq> liftIO is one of the more general functions that does it.
12:02:13 <tARrAScH> kmc_ yup, just got it :). Thanks
12:02:44 <pikhq> (MonadIOs, BTW, have a function m a -> IO a)
12:02:54 <kmc_> that is, your f :: IO a -> OtherMonad a produces a value in OtherMonad, but does that value itself have an "effect" which is similar to the input IO value's effect?  it can't unless your OtherMonad has some of the IO-nature in it, probably by being a transformer stack on IO
12:03:01 <tARrAScH> Is it possible to do it anyway using unsafePerformIO (not that I intend to, just asking)
12:03:02 <Twey> pikhq: Eh?
12:03:15 <pikhq> Twey: ... What, am I full of shit?
12:03:26 <pikhq> Twey: Hate when I do that by way of thinko.
12:03:39 <pikhq> @src MonadIO
12:03:39 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:03:48 * pikhq shakes a fist at magic
12:04:00 <kmc_> tARrAScH: in general, we strongly separate evaluation (of function application) and execution (of IO actions).  unsafePerformIO allows you to make something that, when evaluated, executes something else, thus breaking the separation
12:04:04 <tARrAScH> kmc_ yea I just figured our it just stores it, doesn't execute it. As you said
12:04:05 <kmc_> so yes it can probably do what you're asking
12:04:06 <Twey> Control.Monad.Trans, pikhq
12:04:18 <Twey> The class method is liftIO, which is m a -> IO a
12:04:19 <Twey> Er
12:04:25 <Twey> IO a -> m a (I did it now, too)
12:09:39 <Berengal> @vixen unsafe
12:09:39 <lambdabot> help help!
12:11:02 <ziman> @vixen unsafePerformIO
12:11:02 <lambdabot> there are a lot of weirdos on here
12:11:57 <kmc_> @quote unsafe
12:11:57 <lambdabot> Pseudonym says: Or did you put in a call to unsafePierceEyeball?
12:12:02 <kmc_> @quote unsafe
12:12:02 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
12:12:07 <kmc_> @quote unsafe
12:12:07 <lambdabot> Binkley says: in response to [Philippa] plus who wants to get unsafeHead? [Binkley] Philippa: not if you're doing it in literate Haskell. because, you know, the LaTeX makes it safe
12:12:13 <kmc_> @quote unsafe
12:12:13 <lambdabot> Pseudonym says: Or did you put in a call to unsafePierceEyeball?
12:12:39 <Twey> What's *safe* head?  Dental dam?
12:13:13 <kmc_> @quote unsafe
12:13:13 <lambdabot> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
12:13:15 <olsner> the proper use of typesetting makes it safe?
12:13:54 <kmc_> @quote type
12:13:54 <lambdabot> kzm says: I therefore propose that all functions should either be of type '() -> ()', or non-terminating.
12:13:58 <kmc_> @quote type
12:13:58 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
12:15:22 <RayNbow> @quote olegs
12:15:22 <lambdabot> Pseudonym says: Olegs can be warded off by adding a note claiming that it's impossible to implement in the type system.
12:15:52 <olsner> wouldn't that just attract them?
12:16:09 <kmc_> what does oleg think of the fact that people here talk about him constantly
12:16:10 <Twey> Haha
12:16:14 <RayNbow> @quote olegs
12:16:14 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
12:16:36 <olsner> that's 40% of the amount that kills an elephant, mind you
12:16:55 <Twey> Ergo a non-lethal dose!  (to an elephant)
12:17:31 <olsner> all this talk about elephants... how many elephants code haskell anyway?
12:17:46 <Twey> Loads.  Have you never seen LYAH?
12:18:15 <kmc_> it's based on the incident where an elephant was given 297 mg of LSD
12:18:19 <kmc_> http://www.erowid.org/chemicals/lsd/lsd_history4.shtml
12:18:19 <Heffalump> my elephant doesn't code inHaskell very much, but my gorilla does quite a bit
12:18:32 <lament> kmc_: you mean LYAH?
12:18:37 <kmc_> hehe
12:18:42 <Twey> Hahaha
12:19:06 <c_wraith> LSD.  the world's most common elephant poison
12:20:39 <kmc_> per weight that's like a 7500 ug dose for a human
12:21:18 <c_wraith> I have no clue what the typical "get high" does is for a human
12:21:25 <kmc_> 100 ug maybe
12:21:41 <c_wraith> err.  dose.  And wow, I didn't realize it was so small
12:21:56 <lament> c_wraith: iirc it dropped 10x or so from 60s to now
12:22:09 <olsner> and iirc they took the (then) normal human dose and scaled it up by weight
12:22:13 <lament> and probably smaller now than 100ug
12:22:42 <kmc_> 10x seems implausible
12:22:54 <pikhq> c_wraith: LSD is *extremely* potent.
12:23:01 <lament> kmc_: not really, the response doesn't have to be linear
12:23:12 * c_wraith considers unsafeInterleaveIO instead of unsafePerformIO
12:23:34 <kmc_> when he first tested LSD on himself, Hofmann took 250 ug because it was much less than the threshold dose of any psychedelic known to that point
12:23:44 <kmc_> turns out, that's a pretty strong dose
12:23:51 <c_wraith> ...  crap, that will result in file handles never getting GC'd.  grah
12:23:59 <kmc_> lazy IO is sad
12:24:45 <monochrom> why do people wish for file handles to be GC'd?
12:24:46 <lament> hoffman's account of his first trip is interesting
12:24:54 <lament> he must have been rather frightened
12:25:07 <c_wraith> monochrom: in this case, because I'll be opening one for every incoming request.  That's bad if they're not GC'd
12:25:24 <kmc_> http://carlspies.com/files/u2/st_hofmann100.jpg
12:25:31 <c_wraith> I guess I could unsafePerformIO opening the file.
12:25:42 <c_wraith> That would fix that issue.  >_>
12:27:55 <monochrom> Perhaps you should wish for your whole computer to be GC'd. You go to sleep, not using the computer, someone comes in to take it away and donate it to Africa.
12:28:30 <tunefish> hi, I've a problem : i tried to write a little parser that returns XHtml, but it fails in evaluating my code (like "++", ...)
12:28:35 <tunefish> here's my code
12:28:36 <tunefish> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18502#a18502
12:28:38 <c_wraith> monochrom: this is a straight-up example of resource exhaustion.  This process has run out of file handles before when it just wasn't handling requests fast enough.
12:29:29 <monochrom> The whole 1st world (and the global warming it causes) is a straight-up example of resource exhaustion too.
12:30:36 <mreh> is there a drug to cancel out the effects of LSD?
12:30:45 <mreh> or bind to it and make it ineffective?
12:31:02 <kmc_> a 5HT2 antagonist maybe
12:31:25 <kmc_> which i guess are the atypical antipsychotics
12:31:29 <mreh> oh good
12:31:47 <mreh> I hope my local LSD man stocks that too
12:31:51 <kmc_> clozapine
12:32:13 <kmc_> thorazine can supposedly abort a trip
12:32:20 <mreh> THC is a hallucinogen
12:32:24 <mreh> correct?
12:32:41 <kmc_> but it has been written that the feeling of having LSD and thorazine fighting in your head is more unpleasant than a bad LSD trip
12:32:49 <kmc_> uh, depends on how you define "hallucinogen"
12:32:52 <medfly> guys
12:32:54 <lament> i never had any hallucinations from THC
12:32:54 <medfly> this is #haskell
12:33:01 <lament> medfly: exactly
12:33:07 <kmc_> it doesn't act on the 5HT-2a receptor the way that classical psychedelics do
12:33:12 <c_wraith> how is haskell unlike LSD?
12:33:12 <mreh> sorry I am on a drug trip
12:33:25 <kmc_> very few drugs cause "true" hallucinations (where you can't distinguish them from reality) at normal doses
12:33:39 <medfly> positive view of #haskell: trashed.
12:33:47 <lament> kmc_: probably because nobody really wants that
12:33:55 <kmc_> medfly: did somebody piss in your wheaties today?
12:34:12 <lament> but yeah, we could take drugs to -blah
12:34:15 <kmc_> lament: indeed, some of the drugs that can cause it are legal and readily available, and still not widely abused even by the most desperate of junkies
12:34:15 <mreh> we're discussing pharmacology, not how to get high
12:34:45 <lament> if i want hallucinations indistinguishable from reality, i can just go sleep
12:34:53 <kmc_> hehe
12:34:55 <medfly> fine, I can tell you that if you get on a drug trip that goes wrong and end up being treated for a psychotic episode at a mental hospital they may not give you anything, but just make sure you stay safe until you get out of it. atypical antipsychotics should work, though.
12:35:06 <mauke> dreams are easy to distinguish from reality if you try
12:35:10 <kmc_> they'll more likely give you benzos
12:35:13 <lament> mauke: i have and they aren't
12:35:16 <kmc_> which seems more reasonable than antipsychotics
12:35:32 <mreh> -blah
12:35:33 <monochrom> I have a haskell trip that goes wrong.
12:35:34 <mauke> lament: reading doesn't work right in dreams
12:35:35 <medfly> I don't want to know why you have more knowledge on this than me.
12:35:51 <MissPiggy> o_O
12:35:52 <lament> mauke: unfortunately, neither does thinking, so it's hard to notice things
12:36:01 * medfly mostly reads stuff online. zero experience with any illegal substance, or even with getting drunk or smoking.
12:36:24 <lament> mauke: i've done lucid dreaming fairly actively for a few months and it's just not easy
12:36:31 * monochrom reads more about the haskell trip experience
12:36:47 <MissPiggy> why would anyone want lucid dreaming???
12:36:49 <mreh> heh
12:37:00 <mreh> lets take it to -blah guys
12:37:06 <mreh> this is interesting
12:37:15 <MissPiggy> when you go to sleep it's like a REST
12:37:17 <medfly> MissPiggy, I find that I am able to visualise things around sleep (I normally don't do too well at visualising). it is very realistic.
12:37:38 <medfly> MissPiggy, some people like to visualise things to reason about them, for some reason.
12:37:48 <p_l> MissPiggy: The brain will work heavily during sleep anyway
12:38:20 <monochrom> /join #haskell-blah
12:38:22 <Berengal> You're still rested, even if you're lucid dreaming
12:38:23 <mreh> medfly: visualisation... pah, for mere humons
12:38:56 <MissPiggy> that sounds pretty screwball to me
12:38:58 <medfly> I used to sleepwalk.
12:39:13 <Berengal> I still sleepwalk. Sometimes lucidly (!)
12:39:15 <medfly> I was told I even sleep-attacked another person.
12:39:21 <Berengal> Or maybe I'm just dreaming...
12:39:23 <medfly> whilst screaming.
12:39:24 <Twey> Berengal: Lucid sleep-walking?
12:39:30 <Twey> I think that's called being awake :þ
12:39:34 <medfly> Berengal, I believe that's called "being awake"
12:39:35 <monochrom> hi Berengal, /join #haskell-blah
12:39:35 <medfly> hehehe
12:39:36 <medfly> :-D
12:39:37 <Twey> Hehe
12:39:42 <monochrom> hi medfly, /join #haskell-blah
12:39:55 <medfly> I am there.
12:40:13 <c_wraith> Man.  unsafeInterleaveIO and unsafePerformIO.  this code is maxing out the unsafe
12:40:20 <c_wraith> I just need some unsafeCoerce now
12:40:27 <MissPiggy> c_wraith what does it do anyway?
12:40:30 <aavogt> main = safePerformIO
12:40:49 <monochrom> There is also unsafeSTMtoIO or something.
12:41:01 <c_wraith> MissPiggy: It's reading /dev/urandom into a lazy list, at the moment
12:41:06 <monochrom> perhaps the other way, unsafeIOtoSTM
12:41:18 <MissPiggy> why????
12:41:31 <MissPiggy> sounds like you are doing this completely wrong lol
12:41:35 <harlekin> I remember seeing a ghc extension which permitted pattern matching concerning the result of a function. Can anyone tell me the name of the extension?
12:41:44 <MissPiggy> ViewPatterns
12:41:51 <harlekin> MissPiggy, thank you. (:
12:42:18 <MissPiggy> c_wraith how come you get unsafePerformIO involved in that?
12:42:21 <Berengal> monochrom: No need for unsafeSTMtoIO when atomically get you there safely
12:42:26 <MissPiggy> or interleave or whatever
12:42:51 <c_wraith> MissPiggy: unsafePerformIO is to avoid opening it multiple times.  unsafeInterleaveIO is to make reading it lazy
12:43:18 <MissPiggy> yeah i donno but that sounds kind of insane
12:43:33 <Berengal> c_wraith: It does sound very much like you're doing something wrong
12:43:36 <MissPiggy> why don't you use Iteratee instead?
12:43:46 <MissPiggy> I think it probably implements what you are doing
12:43:58 <c_wraith> there's no right way to do what I'm doing.
12:44:03 <c_wraith> The interfaces are too restrictive
12:44:06 <MissPiggy> don't do it then :P
12:44:15 <c_wraith> "secure" is not an option
12:44:19 <c_wraith> it's a requirement
12:44:23 <MissPiggy> I can definitely solve what you SAID you were doing
12:44:39 <MissPiggy> but yu seem to be actually solving a different problem
12:45:55 <c_wraith> by the way, I'd be happy to see an example of getting a lazy infinite list from IO via Iteratee, since I've yet to see an actual example of using it.
12:46:14 <MissPiggy> c_wraith write it!
12:46:38 <MissPiggy> maybe it will turn out to solve your problem in the best possible way
12:46:46 <c_wraith> MissPiggy: Every Iteratee codebase I've seen provides a huge question mark between the library and the concept.
12:46:59 <Heffalump> c_wraith: well, presumably it can't be done, otherwise Iteratee would be as unsafe as lazy IO
12:46:59 <c_wraith> And it won't solve this.  There is no solution for this.
12:47:06 <MissPiggy> no solution for what btw?
12:47:27 <c_wraith> Getting crypto-quality random number generation into the MonadRandom interface
12:47:36 <MissPiggy> oh
12:47:42 <MissPiggy> well yeah scrap MonadRandom...
12:47:58 <c_wraith> The problem isn't MonadRandom, though.  The problem is Random
12:48:36 <c_wraith> I don't want to throw out all the useful instances for it, but it doesn't work nicely with using IO as the RandomGen
12:49:33 <Berengal> c_wraith: How are you doing it? /dev/random ?
12:50:02 <c_wraith> Berengal: at the rate random data is being requested, I'd kill the entropy pool nearly instantly reading from /dev/random.
12:50:19 <Berengal> Then how?
12:50:28 <c_wraith> Berengal: the next-best solution is /dev/urandom, which at worst is still better than a deterministic PRNG
12:50:32 <MissPiggy> I wish I knew what that meant :p
12:51:07 <Berengal> MissPiggy: cat /dev/random, then cat /dev/urandom. Notice the difference
12:55:27 <harlekin> Can I take action according to the type wrapped in a Dynamic using ViewPatterns? Or is there even an easier way?
12:56:06 <harlekin> (tyConString . typeRepTyCon . dynTypeRep -> "Int") is somewhat working. But it doesn't seem right. (:
12:57:03 <MissPiggy> harlekin what are you using dynamics for?
12:57:17 <harlekin> MissPiggy, a small templating module.
12:57:30 <MissPiggy> of course you can define   f = tyConString . typeRepTyCon . dynTypeRep, then use (f -> "Int")
12:58:14 <harlekin> It doesn't work quite as I expected. I hoped there was a better way.
12:58:39 <harlekin> > let f = tyConString . typerepTyCon . dynTypeRep $ (toDyn "HelloWorld") in f (toDyn "foo")
12:58:40 <lambdabot>   Not in scope: `typerepTyCon'
12:58:49 <harlekin> > let f = tyConString . typeRepTyCon . dynTypeRep $ (toDyn "HelloWorld") in f (toDyn "foo")
12:58:50 <lambdabot>   Couldn't match expected type `Data.Dynamic.Dynamic -> t'
12:58:50 <lambdabot>         against in...
12:58:53 <ksf> is there a way to resolve conflicting family instances without not doing what I want to do?
12:59:11 <ksf> that is, specify a fallthrough order.
12:59:18 <harlekin> Mh, well. f applied to (toDyn "foo") gives me "[]" instead of "String" or "[Char]".
12:59:27 <Saizan> ksf: no
12:59:49 <Saizan> maybe if you add another index..
13:00:27 <ksf> then how the fuck am i supposed to write a function on an gadt that does both P (a,b) -> P (b,a) _and_ P a -> P a?
13:00:32 * Heffalump has some code with GHC 6.8.2 where adding an unused type constraint to a function, where the type it constrains is uniquely determined at the callsite anyway, changes the entire behaviour of the code
13:00:54 <Heffalump> where P is the GADT constructor?
13:01:03 <ksf> ...the type, yes.
13:01:12 <Heffalump> use different data constructors
13:01:19 <ksf> type instance Norm ((a,b),c) = (a,(b,c))
13:01:20 <ksf> type instance Norm a = a
13:01:23 <Heffalump> or maybe use fundeps
13:01:59 <ksf> ...I want to normalize all my stuff
13:02:56 <ksf> without gadt, I can't say  (:<.>) :: P t a -> P t b -> P t (a,b)
13:03:42 <Berengal> ksf: You don't need gadts for that, just smart constructors
13:03:43 <Saizan> Heffalump: how does that GHC 6.8.2 code look like?
13:04:15 <Heffalump> Saizan: it's quite large, I don't have the energy to cut it down
13:04:21 <Heffalump> unless it happens on 6.12 too
13:04:34 <Saizan> Heffalump: ah, np :)
13:04:39 <Berengal> Well, does it?
13:04:44 <Heffalump> I don't know yet.
13:04:56 <Heffalump> I'm just installing that on the computer in question
13:05:13 <Heffalump> then I'll have to spend a while getting all the relevant libraries to build and install, because they're generally quite temperamental
13:05:29 <MissPiggy> Berengal if you use 'smart' constructor you still don't get it
13:05:51 <Berengal> MissPiggy: Get what? That type?
13:06:02 <MissPiggy> yeah pattern matching doesn't work on smart constructors
13:07:20 <MissPiggy> ksf what's the whole GADT and what you want to write on it?
13:07:24 <Berengal> (<.>) :: P t a -> P t b -> P t (a,b); (>.<) :: P t (a, b) -> (P t a -> P t b -> c) -> c
13:08:00 <MissPiggy> Berengal, ohh that's interesting can you actually implement (>.<)?
13:08:06 <ksf> ...I could do data Res a b = Sum a b | Prod a b | Single a
13:08:48 <ksf> MissPiggy, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18531#a18531
13:08:54 <ksf> that's the backbone of a parser
13:09:08 <Berengal> MissPiggy: Sure, just pattern match on the dumb constructor and dispatch
13:09:24 <MissPiggy> Berengal I can't imagine that type checks though? I'll try it out
13:09:35 <ksf> what I have to do is to factor everything so that each token in the input is checked only once
13:09:45 <ksf> ...that is, no backtracking, like packrat parsers
13:10:01 <c_wraith> So, I can fake it.
13:10:11 <ksf> I don't care much about what it can parse, right now, as long as it parses simple stuff
13:10:17 <c_wraith> Since I'm in a monad wrapping IO, I can implement MonadRandom for that wrapper
13:10:50 <Saizan> c_wraith: overloading to the rescue1
13:10:52 <Saizan> !
13:11:20 <c_wraith> And have it just create a new StdGen with a secure random seed for each call to a MonadRandom function.  It's horrible in every way, but it works within the interfaces I have
13:11:22 <MissPiggy> ksf sort of like ReadP then?
13:11:50 <Berengal> c_wraith: It makes sense that if you want to use IO for random numbers you need to be in IO... though perhaps the real problem in this case is the granularity of IO, or rather, the lack thereof
13:12:06 <ksf> am I reinventing the wheel?
13:12:13 <c_wraith> Berengal: I agree, the lack of granularity is the real problem
13:12:36 <Saizan> ksf: i'd have a GADT that describes only the normal forms, and have combinators for convenience if you need them
13:12:39 <MissPiggy> ksf, well I don't actually know what you're trying to do with this GADT
13:12:41 <Berengal> But you _are_ opening file handles and reading stuff that mutates the real world...
13:13:16 <Berengal> IMHO you shouldn't be able to do that in pure code
13:13:16 <ksf> what I'm trying to do is do non-backtracking parsing.
13:13:32 <Berengal> ksf: Like what parsec does?
13:13:46 <ksf> nope
13:14:15 <ksf> I can't say string "bar" <|> string "baz" in parsec, feed it "baz" and have it match, without introducing backtracking.
13:14:43 <Berengal> Ah, you want to compile to a DFA?
13:14:52 <c_wraith> Berengal: my real complaint is that the Random typeclass doesn't give you any tools to hook into non-pure generation of random numbers.  That's the ultimate cause of this pain.
13:14:56 <MissPiggy> O_o
13:15:01 <ksf> ...so it should be refactored to string "ba" >> char 'z' | char 'r'
13:15:02 <MissPiggy> how do you search hpaste by AUTHOR?
13:15:03 <c_wraith> Or, well, random values.  Not just numbers.
13:15:04 <pumpkin> O.o
13:15:04 <MissPiggy> god dammit...
13:15:08 <pumpkin> MissPiggy: don't think you can
13:15:14 <MissPiggy> .what a stupid website
13:15:17 <pumpkin> MissPiggy: maybe site:hpaste.org on google?
13:15:28 <pumpkin> not sure if google indexes it
13:15:41 <ksf> MissPiggy, I guess so, I don't really know any parsing theory
13:15:46 <bd_> ksf: I don't think that's generally possible with a monad - (fmap id $ string "bar") might be opaque to the optimizer, for example
13:15:46 <Berengal> c_wraith: randomM-ish things I suppose? A MonadIO wrapper isn't good enough?
13:15:58 <MissPiggy> ksf huh?
13:16:01 <ksf> I don't even have a monad
13:16:08 <ksf> ...well at least I didn't find it yet.
13:16:11 <MissPiggy> you should read the ReadP source code
13:16:11 <ksf> just applicative.
13:16:14 <MissPiggy> it's really clever
13:16:20 <c_wraith> Berengal: The problem is that I want to create a RandomGen instance that works in IO, but that isn't possible.  And RandomGen is what Random is specified in terms of.
13:16:40 <ksf> MissPiggy, I'll do.
13:16:42 <bd_> ksf: ah, I thought you were proposing a change to parsec. nevermind then
13:16:49 <handonson> i'm on a GNU/Linux env on which SDL is installed and Pygame apps are working smoothly. However, when I try to install the Haskell SDL, it says "SDL not found!" in the configure step. any idea?
13:16:50 <MissPiggy> really bloody annoying
13:17:00 <MissPiggy> I had a GADT parser thing on hpaste which I want to show ksf
13:17:02 <MissPiggy> but I can't find it
13:17:36 <MissPiggy> I think someone sholud add a feature which shows all pastes by one author
13:17:58 <handonson> it says "If you already installed it, check it's in the path." but i have no idea where i should put the SDL or make symbolic links or whatever.
13:18:19 <ksf> handonson, what does "pkg-config sdl --cflags" say?
13:18:55 <Berengal> c_wraith: You need to come up with new synonyms for "random", like MonadRandom does, but it should be possible to do it in terms of a (MonadIO m) => IndentityT m
13:19:16 <handonson> ksf, "Package sdl was not found in the pkg-config search path"
13:19:32 <MissPiggy> ksf, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16355
13:19:34 <ksf> handonson, then complain with your distro maintainers
13:19:48 <MissPiggy> ksf, maybe interesting if nothing else
13:20:12 <Berengal> handonson: Which distro are you on by the way?
13:20:27 <handonson> Berengal, Ubuntu, Karmic Koala
13:20:50 <Berengal> handonson: Make sure you have libsdl1.2-dev
13:21:27 <Berengal> handonson: Just because you have sdl doesn't mean you have the sdl headers.
13:22:00 <handonson> Berengal, oh yeah. I thought that was already installed when I marked Pygame for installation. I'll give it a try now
13:22:51 <handonson> oops... there's no such package
13:23:24 <handonson> ah, never mind, found it with a different keyword...
13:23:43 <aavogt> how do you teach somebody haskell?
13:23:44 <lpjhjdh> does the Foldable class correspond to any mathematical object?
13:23:50 <aledge> aavogt, give him a fish
13:23:52 <aledge> aavogt, wait...
13:24:08 <aledge> aavogt, I think "learn you a haskell for a great good" is pretty good
13:25:14 <Berengal> aavogt: As with everything else; with great patience
13:26:30 <kwos> I've got this code for finding the length of the longest increasing subsequence http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18541#a18541, but it's kind of ugly.. any ideas how to write it nicely?
13:31:48 <Botje> generate a list of all subsequences, take all of those that are increasing, get their length, grab the maximum one
13:32:22 <kwos> that does not sound very efficient
13:32:57 <c_wraith> it's O(2^n).  not *that* bad.  :P
13:33:00 <kwos> this code is not bad in terms of running time, being O(n^2), but there's a better solution running in O(nlogn).. I just want the code to look nice :D
13:33:32 <Botje> you only need the tails, actually
13:34:08 <FCo> Hi, I have a problem with ghci, I get "ghc: panic! (the 'impossible' happened)" but with the compiler it works just fine
13:34:18 <kmc_> with what code?
13:34:23 <kmc_> @where hpaste
13:34:24 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:34:25 <c_wraith> FCO: something about BCOs and 64k?
13:35:49 <FCo> yeap C_wraith! and the source is rather long, is generated by alex from an .x file
13:36:22 <c_wraith> FCo: known issue.  It's been fixed in 6.12, but that probably doesn't help you
13:37:05 <Botje> kwos: i think you can clean it up a bit if you refrain from wrapping the list in tuples
13:37:14 <FCo> here is the code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18547#a18547
13:37:38 <Berengal> > (succ .maximum . map length . unfoldr (\l -> if null l then Nothing else Just (second (drop 1) $ span (uncurry (<)) l)) . (zip`ap`tail)) [1,2,3,4,3,2,1,2,3,4,5,6,7]
13:37:39 <kwos> Botje: not sure if I see what you mean
13:37:39 <lambdabot>   7
13:38:05 <Berengal> > (succ .maximum . map length . unfoldr (\l -> if null l then Nothing else Just (second (drop 1) $ span (uncurry (<)) l)) . (zip`ap`tail)) ([1..10] ++ [2..12])
13:38:06 <FCo> c_wraith, I see, but is there a way to workit around? is it because the generated code is too long?
13:38:06 <lambdabot>   11
13:38:52 <c_wraith> FCo: I'm not aware of a workaround.  Sorry.  And yes, the underlying problem is that the generated code is too large
13:39:05 <Botje> bleh, never mind
13:39:08 <Botje> it's too late here :)
13:39:26 <pastorn> anyone here used delegates in c#?
13:39:37 <pastorn> seems a lot like higher order functions, but suckier
13:39:40 <Berengal> kwos: I made it shorter, but it's still ugly :)
13:39:58 <FCo> c_wraith: thanks, any idea when the haskell platform will be updated to 6.12?
13:40:07 <kwos> Berengal: and a bit less readable :)
13:40:07 <kmc_> i think "delegate" is just the C# term for a first-class function
13:40:33 <Berengal> kwos: Depends on how much of the kool-aid you've had ;)
13:40:50 <pastorn> kmc_: yeah... they need a weird language hack to make it work
13:40:51 <kwos> Berengal: not enough it would seem
13:40:55 <kmc_> yeah
13:40:58 <pastorn> kmc_: HOW INFERIOR
13:41:11 <kmc_> people keep designing new languages and still they fuck up these basic things
13:41:11 <kwos> Berengal: can you explain in one sentence how you arrived at that code?
13:41:20 <pastorn> haha
13:42:17 <MissPiggy> ~ if everybody looked the same ~
13:42:24 <kmc_> @quote boost
13:42:24 <lambdabot> kmc_ says: you should take a look at Boost, they implement things like Maybe and tuples in only a few thousand lines of C++
13:42:42 <Berengal> kwos: I can explain it in one word: dataflow
13:43:19 <aavogt> @type unfoldr
13:43:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:43:44 <kwos> Berengal: please elaborate a bit, I'm not used to this way of thinking
13:43:47 <pastorn> anyway... i'm trying to make something like this (for a 3d rendering thingy)
13:44:13 <pastorn> makeRenderFunction :: Options -> (RenderableObject -> IO ())
13:44:31 <pastorn> but in c#
13:44:42 <pastorn> and i don't really get delegates... seems all wonky
13:44:42 <Peaker> pastorn: that name's a little funny cause all curried functions are function makers
13:45:34 <pastorn> Peaker: howcome?
13:45:48 <Berengal> kwos: It's thinking in terms of transformations on data. First I take a list and zip it with its tail, then I repeatedly break it up into increasing prefixes until it's empty, then I take the length of each element, find the maximum, then finally add one because we've lost one element in the zip + drop 1
13:46:00 <Peaker> a -> b -> c    is a "function maker", when given an "a" it makes a function (b -> c)
13:46:03 <kmc_> yeah, we'd usually write Options -> RenderableObject -> IO ()
13:46:06 <kmc_> which is equivalent
13:46:17 <kmc_> and can be seen either as a two-argument function or a one-arg function that returns a function
13:46:26 <Peaker> so just:  render :: Options -> RenderableObject -> IO ()
13:46:28 <FliPPeh> Haskell depresses me :(
13:46:38 <Peaker> FliPPeh: me too.. :(  why you?
13:46:47 <kwos> Berengal: thanks
13:46:49 <FliPPeh> No matter what I write, someone can iron it down to 5% of the Lines I needed
13:46:57 <handonson> ksf, Berengal, thank you so much. i missed such a trivial point, and now it works fine.
13:47:00 <FliPPeh> And in the end, I don't get anything of it :(
13:47:11 <Peaker> FliPPeh: ah. I'm depressed by Haskell because I then have to use different languages at work
13:47:28 <FliPPeh> That's why I'm learning Haskell and C in parrallel
13:47:31 <FliPPeh> Also, Python.
13:47:37 <Peaker> FliPPeh: I use C/Python at work
13:47:46 <medfly> FliPPeh, why all those in parallel?
13:47:49 <Peaker> trying to get more and more people there to switch to Haskell. I got a few folks really excited about it
13:47:52 <medfly> FliPPeh, why are you in such a hurry?
13:47:54 <FliPPeh> Being prepared :)
13:48:09 <Peaker> FliPPeh: I think it might be best to learn Haskell last, if you don't want to be sad about learning those others
13:48:10 <pastorn> Peaker, kmc_: i wanted to emphazie that the function in the end is the actual result
13:48:26 <pastorn> which in haskell you'd put in a reader somewhere
13:48:42 <FliPPeh> Peaker: In the last years I "learned" DOZENS of languages, but I yet have to select my toolset to use later
13:48:52 <FliPPeh> One high lever, one low level and Haskell
13:49:18 <medfly> I learnt Haskell first, and then C and then Python, sorta. (some other things were in the middle). I don't feel very confident with any one of those, but it isn't so hard to switch to imperative programming frmo Haskell
13:49:21 <Berengal> kwos: It emphasises a more holistic view of data instead of element-wise. I feel it reduces the complexity of each piece of information, but can become intractable because you need to keep more pieces around in your head at the same time
13:50:01 <pastorn> FliPPeh: what are you working on now?
13:50:04 <Peaker> pastorn: Well, that shouldn't matter to the "render" function that it's going to be partially applied, I don't think it belongs in its name
13:50:09 <FliPPeh> I can't even count the number of languages I can write decent, working programs in
13:50:12 <FliPPeh> It's just too many
13:50:19 <FliPPeh> Of all those, I know C and Haskell best
13:50:22 <FliPPeh> So I want to build on that
13:50:30 <medfly> FliPPeh, I don't view most imperative programming languages as being so different.
13:50:42 <kwos> Berengal: one problem tho: it's incorrect
13:50:50 <Peaker> medfly: well, they're not that different from using Haskell imperatively
13:50:55 <Berengal> kwos: There's also that
13:51:03 <FliPPeh> Peaker: Nothing currently, I'm not done studying yet
13:51:10 <FliPPeh> pastorn: *
13:51:12 <medfly> FliPPeh, I helped my sister with her C homework, and I was learning PHP at the time for something, and she wanted me to correct her code, and I found something wrong wiht the syntax that would be wrong in PHP too, it was the error.
13:51:13 <pastorn> Peaker: i like this way of generating it instead of having a more general function taht just has tons of if-statements, one for each possibel pass
13:51:14 <FliPPeh> Sorry, wrong hilight
13:51:21 <kwos> > (succ .maximum . map length . unfoldr (\l -> if null l then Nothing else Just (second (drop 1) $ span (uncurry (<)) l)) . (zip`ap`tail)) [ 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 ]
13:51:22 <lambdabot>   2
13:51:40 <kwos> the answer is 6
13:51:49 <FliPPeh> Yea, know C and you know most of 'em
13:51:56 <Peaker> pastorn: I am just talking about the name you chose
13:52:11 <Berengal> kwos: Which subsequence would that be?
13:52:20 <medfly> FliPPeh, even the syntax. although I do feel I should get familiar with some more languages...
13:52:22 <kwos> 0, 2, 6, 9, 13, 15
13:52:25 <kwos> it's not unique
13:52:32 <pastorn> Peaker: howcome?
13:52:36 <pastorn> what's wrong with it?
13:52:37 <medfly> @oeis 0,2,6,9,13,15
13:52:37 <Berengal> Oh, they don't have to be adjacent
13:52:37 <lambdabot>  Sequence not found.
13:52:48 <kwos> it does not have to be contiguous
13:52:48 <Peaker> FliPPeh: I think it's a good idea to learn some assembly language and even know a bit about how it's encoded to machine code and a bit about how it's executed to get a good idea/feeling for how the entire software stack is put together
13:52:51 <kwos> what's oeis?
13:52:58 <Berengal> Well then, it's certainly incorrect
13:53:02 <medfly> @help oeis
13:53:02 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
13:53:05 <Peaker> pastorn: it's called "renderFunctionMaker" when it's just "render"
13:53:05 <FliPPeh> Assembler is fun :)
13:53:05 <kwos> @oeis 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15
13:53:06 <lambdabot>  Write n in binary, reverse bits, subtract 1, divide by 2.
13:53:06 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,6,1,5,3,7,0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15,0,16,8,...
13:53:28 <medfly> :o
13:53:31 <FliPPeh> Theorethical knownledge is all there, luckily
13:53:41 <FliPPeh> I just need to work on practical skills
13:53:46 <lispy> Is that an algo for generating random sequences?
13:54:04 <kmc_> @oeis 14 18 23 28 34 42
13:54:04 <lambdabot>  Local stops on New York City Broadway line subway.
13:54:04 <lambdabot>  [14,18,23,28,34,42,50,59,66,72,79,86,96,103,110,116,125,137,145,157,168,181,...
13:54:09 <pastorn> Peaker: in the end you're only supposed to call it one time and in the end you're just going to call the partially evaluated function
13:54:10 <medfly> what the FUCK
13:54:21 <byorgey> lispy: yes, you get a different random sequence every time
13:54:53 <lispy> byorgey: heh, Well pseudo-random is what I meant :)
13:54:57 <Peaker> pastorn: that's what I said earlier, there are tons of functions you're supposed to call partially, but that's not a concern of the called function, just of the caller
13:54:57 <byorgey> =)
13:55:32 <pastorn> Peaker: ok then... so what would be a better name?
13:55:34 <lispy> byorgey: I'm trying to imagine why someone would study a sequence with such an operational description
13:56:07 <lispy> byorgey: and it seems like if you started with an arbitrary number (instead of 0) that it would be fairly arbitrary what you get for the next few values?
13:56:40 <Peaker> pastorn: "render" :)
13:56:54 <pastorn> Peaker: but that's not all it does
13:57:17 <pastorn> "render" should be just :: RenderableThingy -> IO ()
13:57:45 <Peaker> pastorn: Why not:  render :: Options -> Renderable -> IO ()  ?
13:58:06 <pastorn> type Options = [Option]
13:58:23 <Peaker> pastorn: I don't think that's a useful synonym..
13:58:23 <largos> wouldn't you want to be able to render to different things? (screen, surface, etc.?)
13:58:40 <pastorn> Peaker: and i'd call that "renderWithOpts"
13:58:41 <Peaker> pastorn: we don't call "take"   "listTakerMaker"   but if you give it a number, you get a list taker.   takerOf5 = take 5
13:58:59 <Peaker> pastorn: you know   Options -> Renderable -> IO ()  ===  Options -> (Renderable -> IO ())
13:59:04 <byorgey> lispy: dunno, people study sequences for all kinds of reasons.  That one seems a bit too simple to give you something pseudorandom.
13:59:16 <kmc_> > take 5
13:59:17 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
13:59:35 <pastorn> Peaker: i was talking about delegates in C# earlier, so what do you think...
13:59:42 <lispy> byorgey: certainly not cryptographic quality :)
13:59:56 <kmc_> AbstractListTakerMakerFactoryFactory
14:00:03 <kmc_> that's what you need
14:01:06 <kmc_> > take
14:01:07 <lambdabot>   -3->
14:01:07 <lambdabot>    {[]->[];[()]->[];[(),()]->[];[(),(),()]->[]}
14:01:07 <lambdabot>  -2->
14:01:07 <lambdabot>    {[]->[];[()]-...
14:01:39 <pastorn> kmc_: hehe
14:01:50 <sinelaw> yo
14:01:54 <pastorn> kmc_: what's this lambdabot hackery you're doing?
14:02:12 <MissPiggy> yo
14:02:13 <kmc_> it's just that lambdabot has a Show instance for functions
14:02:18 <kmc_> which uses SmallCheck to generate some args
14:02:19 <kmc_> > ($)
14:02:21 <lambdabot>   {{()->()}->{()->()}}
14:02:24 <kmc_> > (.)
14:02:25 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
14:02:25 <lambdabot>                    GHC.Show...
14:02:39 <kmc_> > (.) :: (Char -> Char) -> (Char -> Char) -> Char -> Char
14:02:39 <c_wraith> caleskell strikes again
14:02:40 <lambdabot>   {'a'->'a';'b'->'a';'c'->'a';'d'->'a'}->
14:02:40 <lambdabot>    {'a'->'a';'b'->'a';'c'->'a';'d'-...
14:02:43 <kmc_> ah heh
14:03:44 <MarcWeber> Does Joerg Rudnick show up occasionally here? (Nick ?)
14:11:24 <osaunders> OK someone needs to explain this to me. What is LLVM?
14:11:41 <kmc_> http://llvm.org/
14:11:42 <c_wraith> a compiler.  and a compiler backend
14:11:42 <aavogt> @google llvm
14:11:43 <lambdabot> http://llvm.org/
14:11:43 <lambdabot> Title: The LLVM Compiler Infrastructure Project
14:11:44 <kmc_> "LLVM is: ..."
14:11:49 <Berengal> @wikipedia LLVM
14:11:49 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=LLVM
14:12:02 <kmc_> @vixen LLVM
14:12:03 <lambdabot> help help!
14:12:03 <ray> low level virtual machine, an optimizing backend
14:12:28 <kmc_> hmm @wikipedia failed
14:12:40 <kmc_> osaunders: is one of those four numbered items unclear?
14:13:51 <osaunders> So LLVM optimizes programs and source code?
14:14:17 <kmc_> LLVM is a platform-independent assembly language, and some tools that work with that language
14:14:34 <osaunders> Ah.
14:14:48 <osaunders> Does Haskell use it?
14:14:56 <osaunders> No, wait, Haskell uses C--.
14:15:00 <kmc_> including compiler frontends (produce LLVM from C, C++, Fortran, etc), optimization passes (turn LLVM code into better LLVM code), and backends (convert LLVM to native machine code, all at once or on the flay)
14:15:00 <kmc_> no
14:15:03 <kmc_> GHC uses C--
14:15:08 <kmc_> and in the future may use LLVM
14:15:13 <kmc_> "Haskell" is a document
14:15:17 <kmc_> not a program
14:15:20 <Peaker> kmc_: I thought GHC outputed native code
14:15:26 <kmc_> right
14:15:39 <kmc_> GHC uses C--, just as it uses Core and STG
14:15:41 <gwern> I love how dropbox's https://www.dropbox.com/pricing won't tell you either the price or what you get
14:15:43 <FauxFaux> Haskell is a document that's utterly unusable, we all program in and teach GHC extensions. :/
14:15:54 <ray> peaker: compilers have frontends and backends
14:16:01 <ray> and sometimes assemblers separate from the backend
14:16:05 <FauxFaux> gwern: Shows the prices here.
14:16:23 <gwern> FauxFaux: does it show what you get?
14:16:25 <kmc_> yeah, but it's still a category error to confuse "Haskell spec + spec of GHC extensions" with "implementation strategy taken by current version of GHC"
14:16:26 <ddarius> GHC doesn't really use C--.
14:16:39 <osaunders> Is the main advantage of LLVM portability?
14:16:43 <gwern> FauxFaux: really without either the page is kind of useless
14:16:51 <kmc_> osaunders: depends what you're doing
14:16:56 <FauxFaux> gwern: The pictures say "50gb" and "100gb" respectively, and the text at the top suggest that they're refering to increased storage?
14:16:56 <gwern> 'sign me up for your mystery 20$ month option!'
14:17:09 <gwern> FauxFaux: which is meaningless in isolation
14:17:16 <kmc_> osaunders: writing a compiler backend is a hard and largely solved problem.  if you're implementing a new language, it's nice to use an existing backend like LLVM
14:17:23 <gwern> how much can you transfer, what's the file size limit, etc.
14:17:30 <kmc_> and yes part of that advantage is to get native codegen on multiple architectures
14:17:32 <FauxFaux> It's the 100gb option!
14:17:43 <osaunders> kmc_: Right.
14:17:47 <kmc_> LLVM is also supposed to make it easier to research optimizations, etc. by making them more modular
14:18:00 <kmc_> your compiler can literally be a shell script which invokes a frontend, various optimization passes, and a backend
14:18:02 <gwern> FauxFaux: and then there's the old revisions question
14:18:06 <kmc_> and so it's easy to make new optimizations and drop them in
14:18:15 <Peaker> does LLVM use (ByteCode -> ByteCode) optimizers that are just composed together?
14:18:32 <kmc_> (however, this only applies to fairly late-stage optimizations... much of the interesting optimization of Haskell code in GHC happens on a much higher level that LLVM doesn't represent)
14:18:33 <osaunders> Does GCC use LLVM?
14:18:33 <Peaker> or are the optimizers at the various phases?
14:18:43 <kmc_> osaunders: not the mainline gcc
14:19:01 <Peaker> osaunders: I think since LLVM has its own C and C++ front-ends,  it doesn't add a lot of utility.  I think they're called clang
14:19:01 <osaunders> OK.
14:19:07 <kmc_> the LLVM people distribute a version of GCC which can output LLVM code
14:19:10 <Peaker> osaunders: Used by Apple, and have some nice C extensions (lexical scopes)
14:19:26 <ddarius> I doubt any established native code compiler is going to switch (primarily) to LLVM.
14:19:34 <kmc_> clang is a new C, ObjC, and C++ compiler that uses LLVM as its backend
14:19:52 <osaunders> Hm.
14:19:56 <osaunders> I like lexical scopes.
14:20:32 <Peaker> I want C with a module system rather than #include.  Build times are horrific
14:20:46 <ben> We all do
14:20:48 <kmc_> first class functions in C, only 74 years after the feature was invented
14:21:00 <kmc_> build times are the least of the problems with #include
14:21:06 <kmc_> especially when you go to C++
14:21:24 <kmc_> include and binary link sort of makes sense for a low level systems language
14:21:34 <kmc_> it makes no sense for a supposedly high level language with fancy types
14:22:00 <ben> It makes sense?
14:22:10 <ben> "low level = low-tech implementation" ?
14:22:27 * hackagebot upload: hmatrix 0.8.3.1 - Linear algebra and numerical computation (AlbertoRuiz)
14:22:45 <gwern> (hm. my important files (==non-bittorrent) take up ~30gigs. fits within the 10$ dropbox. but how does versioning work and can I put a dropbox backup job in cron?)
14:23:31 <BCoppens> Peaker: LLVM has basically a lot of ByteCode -> ByteCode transforms, but it also has a lot of pluggable/modular analysis passes as well, and code generation, etc
14:23:32 <ville> Peaker: I think clang/llvm might be great actually for C++ development tools.
14:23:53 <kmc_> yes, it will be nice to have a modular C++ frontend, for writing tools
14:23:57 <kmc_> unfortunately it might postpone the death of C++
14:24:31 <olsner> C++ doesn't need more tools, it needs more death :)
14:24:39 <Twey> Hear hear
14:24:42 <MissPiggy> minion: chant
14:25:00 * kolmodin celebrates 5 years in #haskell! yay!
14:25:19 <kmc_> @quote lamprey
14:25:20 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
14:25:31 <gwern> I love that one
14:25:56 <BCoppens> so C++ is only for men? That's quite woman-unfriendly! ;)
14:25:57 <jmtd> evening folks. Can anyone explain why I get overlapping types warning for the case statement in the following snippet? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18584#a18584
14:26:03 * byorgey celebrates with kolmodin
14:26:15 <kolmodin> byorgey: hia :)
14:26:20 <gwern> BCoppens: actually, it's hugely friendly to women
14:26:22 <byorgey> hey there =)
14:26:34 <c15c8ra1n> is there a way to partially apply the if function?
14:26:37 <gwern> byorgey: no celebration for you until your xmonad.hs is shrunk to sanity! you are making xmonad look bad
14:26:42 <c15c8ra1n> or something similar?
14:26:49 <Twey> @let (y ?? n) p = if p then y else n
14:26:50 <gwern> c15c8ra1n: what, you mean like \f -> if x then y else f?
14:26:54 <MissPiggy> c15c8ra1n for some ridiculous reason if is not a function!
14:26:55 <lambdabot>  Defined.
14:27:03 <Twey> c15c8ra1n: Define that, then you can.  ☺
14:27:08 <gwern> MissPiggy: excuse us for liking infix syntax!
14:27:12 <kmc_> jmtd: those are both variables
14:27:17 <byorgey> gwern: meh =)
14:27:21 <Twey> > map (3 ?? 5) [True, False, False, True, False]
14:27:24 <kmc_> case e of { a -> (); b -> () }
14:27:25 <lambdabot>   [3,5,5,3,5]
14:27:31 <Twey> \b is awfully slow tonight
14:27:34 <kmc_> both "a" and "b" are just a variable pattern and thus will match anything
14:27:35 <MissPiggy> gwern, it is unconscionable.
14:27:50 <kmc_> jmtd: perhaps you wanted to match a constructor (which would start with an uppercase letter)
14:27:51 <Peaker> is byorgey's xmonad.hs larger than xmonad itself?
14:28:10 <sinelaw> Peaker, why, has it many features?
14:28:13 <byorgey> hah, that would be awesome, but no =)
14:28:31 <kmc_> c15c8ra1n: no, "if" is syntax, not a function, and should be destroyed
14:28:42 <kmc_> but you can write an equivalent function as Twey did
14:28:48 <Peaker> sinelaw: gwern is complaining, I donno
14:29:11 <gwern> Peaker: it's uncomfortably close. I think his conf is 1/3 xmonad core
14:29:21 <c15c8ra1n> Twey: thank you very much :)
14:29:29 <gwern> or something like that. (obviously it's a tiny tiny fraction of contrib)
14:29:40 <byorgey> yes, 1/3 sounds about right
14:29:49 <Twey> c15c8ra1n: You're welcome.
14:29:51 <c15c8ra1n> although I'd have to agree with MissPiggy, if not being a function and all :P
14:29:59 <gwern> byorgey: probably too high. we passed 1500 lines a while ago didn't we?
14:29:59 <byorgey> I have no idea why this is a problem.
14:30:06 <Twey> c15c8ra1n: If you feel like standardising, (??) is in the HigherOrder package on Hackage.
14:30:21 <byorgey> gwern: yes, but also my actual config is longer than the one currently on the wiki, I think ;)
14:30:26 <gwern> gah!
14:30:34 <Twey> Given that xmonad is only about 500LoC, I'm not too shocked to hear that
14:30:39 <gwern> twin sins: it's too big and you aren't keeping the config archive up to date
14:30:47 <gwern> Twey: oh no, that was long ago, like 0.1
14:30:49 <aavogt> Twey: it's a bit more than that
14:30:49 <Twey> Haha
14:30:53 <Twey> How big is it now?
14:31:28 * byorgey make elaborate, entirely insincere professions of contrition to gwern
14:31:33 <byorgey> *makes
14:31:46 <sinelaw> do twin sins still fit in the bin?
14:31:58 <Peaker> byorgey: what does your xmonad do that it is so big?
14:32:13 <Peaker> @hoogle ptrComparison
14:32:15 <lambdabot> No results found
14:32:15 <dschoepe> Twey: sloccount says 1.1k but I don't think that includes comments
14:32:21 <Peaker> @hoogle reallyUnsafe
14:32:21 <lambdabot> No results found
14:32:43 <Twey> Ho hum
14:32:48 <Twey> Well, that's not so bad, still
14:33:17 <byorgey> Peaker: I just have lots and lots of keybindings, and lots of special workspaces with special actions attached to them, and various other customizations
14:33:30 <jmtd> kmc_: Hmm ok, thanks. I'm not sure there is an appropriate constructor in this case but I will take a look at the System.Posix.Files source again
14:33:38 <byorgey> it's just accreted over a couple years of using xmonad
14:33:46 <kmc_> jmtd: well, on what basis did you write what you have now?
14:34:10 * kmc_ looks at System.Posix.Files
14:34:16 <kmc_> you probably want to use (==) rather than pattern matching
14:34:33 <gwern> huh. looks like jungledisk, using amazon s2, would run me about 3.3$ a month
14:34:48 <jmtd> kmc_: I originally had a nasty if/else heirarchy if (isSymbolicLink foo) then …
14:35:01 <Peaker> jmtd: no need for () there
14:35:03 <kmc_> case (flibble stat) of v | (v == symbolicLinkMode) -> return "link!" | (v == directoryMode) -> return "dir!"
14:35:14 <jmtd> kmc_: I wanted to try and unwind that if possible so I started digging around inside System.Posix.Files
14:35:19 <jmtd> Peaker: good point, thanks
14:35:25 <kmc_> you can use "case" as a many-way conditional basically
14:35:43 <kmc_> another way to write it would be:  let v = flibble stat in case () of _ | (v == symbolicLinkMode) -> return "link!" | (v == directoryMode) -> return "dir!"
14:36:16 <aavogt> @type symbolicLinkMode
14:36:17 <lambdabot> Not in scope: `symbolicLinkMode'
14:36:19 <Twey> Hmm
14:36:31 <aavogt> perhaps you can access the constructors?
14:36:37 <kmc_> don't the modes or together anyway?
14:36:45 <kmc_> i think you should go back to isDirectory, isSymbolicLink, etc
14:36:54 <kmc_> and use "case" rather than an "if" hierarchy
14:37:12 <jmtd> kmc_: somewhere underneath the abstractions the types are just integrals - `intersectFileModes` seems to provide a set-esque interface to bitwise and/or
14:37:28 <jmtd> kmc_: I will give that a try. thanks!
14:37:47 <Twey> maybe "ARGHNOTFOUND" id $ lookup (flibble stat) [(symbolicLinkMode, "link!"), (directoryMode, "dir!")]
14:37:55 <Twey> Er
14:38:02 <Twey> maybe "ARGHNOTFOUND" return $ lookup (flibble stat) [(symbolicLinkMode, "link!"), (directoryMode, "dir!")]
14:38:15 <Twey> Um
14:38:21 <Twey> maybe (return "ARGHNOTFOUND") return $ lookup (flibble stat) [(symbolicLinkMode, "link!"), (directoryMode, "dir!")]
14:38:26 <Twey> You get the picture, anyway
14:38:55 <Twey> Perhaps: return . maybe "ARGHNOTFOUND" id $ lookup (flibble stat) [(symbolicLinkMode, "link!"), (directoryMode, "dir!")]
14:39:18 <Twey> (and that's what ‘lookup’ is good for)
14:39:34 * jmtd takes a look at lookup
14:39:48 <kmc_> of course you should actually use a cuckoo hash map for BLAZING SPEED
14:39:53 <Twey> ZOOM ZOOM
14:39:58 <ksf> type safety begone!
14:39:59 <kmc_> O(1) is much less than O(log 2) which is in turn much less than O(2)
14:40:01 <jmtd> this is my first serious attempt at a haskell program.. I did toy things at University 6 years ago but nothing that touched IO :)
14:40:07 <Twey> Heheh
14:40:23 <ksf> after all, it doesnt' matter if I got 10000 unused constructors in my ADT
14:40:25 <Berengal> IO is overrated anyway. All you need is Cont ;)
14:40:42 <ksf> kmc_, it's still more than O(leg)
14:40:50 <Zao> It is now less than a week left until my Euler 37 solution completes.
14:41:03 <Zao> Constant factors matter :)
14:41:18 <kmc_> @quote euler
14:41:19 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
14:42:47 <MissPiggy> @quote prolog
14:42:48 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
14:42:54 <MissPiggy> @quote prolog
14:42:54 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
14:43:00 <MissPiggy> @quote prolog
14:43:01 <lambdabot> <mm_freak> says: no prolog channel =/  <inimino> there's a setting that turns that off
14:43:15 <MissPiggy> @quote APL
14:43:15 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
14:43:22 <MissPiggy> haha
14:43:33 <Twey> Haha
14:43:41 <MissPiggy> that's a good one.
14:44:57 <Peaker> is something LogicT equivalent to Prolog in features, or just to a significant part of them?
14:45:19 <Berengal> Peaker: Doesn't do unification, does it?
14:45:28 <Peaker> Berengal: I'm not sure
14:45:31 <ddarius> Peaker: A significant subset.
14:45:43 <ddarius> It doesn't do unification, but you can make monads that support it.
14:45:44 <Berengal> LogicT is just ListT done right, IIUC
14:45:45 <MissPiggy> actually I don't know why LogicT is called "logic"
14:46:04 <ddarius> It also doesn't do assert/retract or reflection.
14:46:06 <Peaker> Berengal: well, an implementation based on continuations/church encoding
14:46:10 <MissPiggy> yeah e.g. they prototyped Kanren in Haskell using LogicT
14:46:19 <Peaker> what's Kanren?
14:46:22 <MissPiggy> woah
14:46:30 <MissPiggy> you are missing out man
14:46:30 <ddarius> The language used in the Reasoned Schemer.
14:46:47 <MissPiggy> Reasoned Schemer is probably the (second) best scheme book ever :P
14:46:51 <MissPiggy> (and it's not even about scheme)
14:47:15 <MissPiggy> it's got Oleg, Amr and Freidman
14:47:28 <MissPiggy> as authurs
14:47:32 <Peaker> MissPiggy: I like Scheme, but I don't know if I'd ever like to use it or read a good book about it :)
14:47:46 <MissPiggy> hmm William E. Byrd
14:48:04 <MissPiggy> yeah like I said you are missing out
14:48:36 <Peaker> MissPiggy: example of a cool thing? :)
14:49:14 <jmtd> ah bending case to my purpose seems to work quite nicely, thank you. (I will still need to checkout `lookup' sometime)
14:49:32 <MissPiggy> well if you don't like logic programming you won't like this book
14:49:50 <MissPiggy> sos maybe my recommendation is a bit strong
14:49:54 <stepcut> I have a package installed in my global and local package indexes. is there someway to get ghci to use the version in my local package index?
14:50:08 <MissPiggy> but I still think everyone shoud have read it (until the end, then stopped)
14:51:22 <gwern> hm. duplicity looks real nice. scriptable CLI, incremental encrypted tar backups to amazons3
14:51:41 <gwern> > 27 * 0.15
14:51:42 <lambdabot>   4.05
14:51:56 <gwern> ~4$ a month; not bad
14:52:36 <ksf> zomg I never noticed
14:52:51 <sbahra> gwern, have you looked at tarsnap before?
14:52:55 <ksf> oleg's name really _is_ printed on the cover of the reasoned schemer
14:52:56 <sbahra> gwern, http://www.tarsnap.com
14:53:28 <gwern> sbahra: pricing looks worse than s3
14:53:39 <gwern> .30 for storing and transmitting gigs?
14:53:47 <gwern> amazon is .15 and .2 resp
14:54:08 <sbahra> "These prices are based on the actual number of bytes stored and the actual number of bytes of bandwidth used  after compression. Due to tarsnap's strong encryption, there is no way for the tarsnap service to know how much data you had before it was compressed."
14:54:33 <Entroacceptor> is there a library to parse the xdg desktop menu files?
14:54:38 <sbahra> gwern, tarsnap is a full-fledged back-up tools. They use S3 as a backend.
14:54:40 <gwern> sbahra: which presumably would be little different from the tar/gzip of duplicity
14:54:56 <sbahra> s/They use/It uses/
14:55:22 <gwern> why would I use tarsnap rather than s3 directly?
14:55:23 <ksf> Entroacceptor, aren't those just ini files?
14:55:53 <Entroacceptor> ksf: maybe? but in lots of different paths, I guess
14:56:20 <Entroacceptor> well, if not, there's something I can try to do to learn haskell
14:56:27 <sbahra> gwern, they're different.
14:56:32 <ben> Throw parsec at it, should be easy enough
14:56:42 * ben spent three hours last night on a similar problem
14:56:44 <ksf> Entroacceptor, try this to gobble up the filenames: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10104
14:56:51 <gwern> sbahra: how? looks to me like duplicity & tarsnap would do much the same thing, and the former would be cheaper & more reliable
14:56:57 <ksf> ...one day, I'm going to finish it up and make it a library
14:57:35 <gwern> ksf: if there's anything 'find' has taught us, it's that such a library can neer be finished
14:57:43 <Entroacceptor> thanks
14:58:05 <ksf> well, it needs to be parametrized more.
14:58:28 <ksf> most importantly, how stuff is appended into the map
14:58:38 <ksf> and it needs an iteratee interface
14:59:13 <ksf> right now, it's completely strict in the filesystem, which isn't really optimal, and not the way unix find does it.
14:59:42 <ksf> ...but it's very, very good at not following sym- and hardlinks.
15:00:20 <ben> How do you get anywhere not following hardlinks?
15:00:38 <ksf> oh, they are followed, exactly once.
15:01:20 <ksf> I guess building a real graph would be even cooler
15:02:26 <Entroacceptor> ok, this was definetly easier in python...
15:02:56 <ksf> also, according to the man page, find is fast because it minimizes the number of stats done, which I don't
15:03:38 <ksf> Entroacceptor, what are you trying to do?
15:03:54 <pumpkin> Entroacceptor: it will stay easier in python for a while, until you get used to thinking in a new way
15:04:12 <Entroacceptor> well, and it's not just doing xdg.Menu.parse() ;)
15:04:20 <Entroacceptor> ksf: writing a start menu
15:04:29 <Entroacceptor> for the once-in-a-week use in xmonad
15:05:08 <Entroacceptor> and it was so easy in python I though I'd take this as an opportunity to finally do somehting in haskell http://mad.unserver.de/2010/xmonad/xmenud.png
15:06:24 <phr> Where can I find a default or example config for cabal?  The bootstrap.sh doesn't create it, and cabal update complains about no remote servers.
15:06:44 <ksf> oh, it's xml
15:06:56 <Zao> phr: cabal update should create one, normally.
15:07:03 <sinelaw> how can i do something like "if read x failed, then A else B"?
15:07:25 <MissPiggy> sinelaw you can use reads
15:07:26 <ksf> Entroacceptor, get yourself haxml and feed menu-latest.dtd through the app that comes with it.
15:07:31 <MissPiggy> it gives [] on fail
15:07:33 <phr> I saw that in the docs, but it complains about no remote server definition, and helpfully says that is usually in the config.
15:07:39 <sinelaw> oh cool, thanks MissPiggy
15:07:45 <Zao> phr: http://www.acc.umu.se/~zao/config
15:07:50 <pumpkin> what does it give on epic fial?
15:07:51 <Dashkal> I may have got too cozy with Either.  IOErrors seem clunky to me now.  This despite a background in java.
15:07:55 <pumpkin> such as my spelling of epic fail
15:08:06 <Zao> Should be a reasonably vanilla config, except for symlink-bindir.
15:08:25 <ksf> ...then use my file finder to get a list of files, parse all of them with haxml + that dtd, and the rest is gui.
15:08:42 <Entroacceptor> well, gui is trivial ;)
15:09:02 <phr> Zao:  Thanks!
15:09:21 <Entroacceptor> mmh, the app menu is xml, the desktop entry files are ini-style
15:09:27 <gwern> ...cabal upgrade prints to stderr?
15:09:31 <gwern> @seen dcoutts
15:09:31 <lambdabot> Unknown command, try @list
15:09:38 <ksf> you could do it with xmonad prompts, to stay with the all-keyboard theme
15:09:38 <gwern> preflex: seen dcoutts
15:09:38 <preflex>  dcoutts was last seen on #ghc 1 day, 3 hours, 47 minutes and 35 seconds ago, saying: ok, ta
15:09:40 <gwern> preflex: seen dcoutts)
15:09:40 <preflex>  Sorry, I haven't seen dcoutts)
15:09:42 <gwern> preflex: seen dcoutts_
15:09:42 <preflex>  dcoutts_ was last seen on #haskell 12 days, 18 hours, 21 minutes and 16 seconds ago, saying: ezyang: thanks, fixed.
15:09:54 <ksf> ...just show all the top-level completitions.
15:10:09 <gwern> @ask dcoutts why does cabal upgrade --dry-run do a silly thing like print the to-upgrade list to stderrr rather than stdout?
15:10:09 <lambdabot> Consider it noted.
15:10:18 <gwern> nvoorhies: hey, are you the Nate of Everything2?
15:10:42 <sinelaw> > reads "3"
15:10:43 <lambdabot>   []
15:10:47 <sinelaw> > reads "3" :: Int
15:10:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:10:48 <lambdabot>         against inferred type ...
15:10:54 <sinelaw> @hoogle reads
15:10:54 <lambdabot> Prelude reads :: Read a => ReadS a
15:10:54 <lambdabot> Text.Read reads :: Read a => ReadS a
15:10:54 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
15:11:10 <sinelaw> > (reads "3") :: ReadS Int
15:11:12 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
15:11:12 <lambdabot>           ...
15:11:24 <sinelaw> huh?
15:12:21 <dschoepe> > (reads "3") :: Prelude.ReadS Int
15:12:22 <doserj> > reads "3" :: [(Int,String)]
15:12:22 <Entroacceptor> ksf: can I use that under gpl?
15:12:22 <lambdabot>   [(3,"")]
15:12:23 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
15:12:23 <lambdabot>           ...
15:12:37 <sinelaw> which one failed?
15:12:42 <doserj> > reads "3" :: [(Int,String)]
15:12:42 <lambdabot>   [(3,"")]
15:12:46 <sinelaw> ah
15:12:48 <ksf> Entroacceptor, you can use it under GPL, BSD3, PD or the Beer License.
15:12:53 <sinelaw> which one failed?
15:13:01 <sinelaw> doh. stupid chat program. ignore that
15:13:14 <sinelaw> > reads "3 bears" :: [(Int,String)]
15:13:15 <lambdabot>   [(3," bears")]
15:13:17 <doserj> > (reads::ReadS Int) "3"
15:13:18 <lambdabot>   [(3,"")]
15:13:20 <Entroacceptor> thx :)
15:16:37 <sinelaw> > reads "bears" :: [(Int,String)]
15:16:38 <lambdabot>   []
15:16:56 <Twey> No parses.
15:17:29 <Twey> > reads "(3, \"bears\")bears" :: [((Int, String), String)]
15:17:30 <lambdabot>   [((3,"bears"),"bears")]
15:17:53 <sinelaw> Twey, that was what i was testing :)
15:18:20 <Twey> sinelaw: Whether "bears" would parse as an Int?  :þ
15:18:29 <sinelaw> Twey, no that it returns []
15:18:32 <Twey> Ah
15:18:35 <Twey> Yeah, it does
15:18:38 <sinelaw> :)
15:18:43 <Twey> readMaybe = fmap fst . listToMaybe . read
15:18:55 <sinelaw> reads
15:19:04 <Twey> Yes
15:19:06 <Twey> >.<
15:19:51 <nvoorhies> gwern: not that I know of, no
15:20:06 <gwern> strange. rather similar names
15:20:10 * gwern shrugs
15:20:35 <BONUS> preflex: seen mmorrow
15:20:36 <preflex>  mmorrow was last seen on #ghc 21 days, 20 hours, 22 minutes and 51 seconds ago, saying: * mmorrow is rtfm'ing
15:20:54 <sinelaw> > let readMaybe = fmap fst . listToMaybe . (reads :: ReadS Int) in readMaybe "3"
15:20:55 <lambdabot>   Just 3
15:20:58 <sinelaw> cool.
15:21:10 <BONUS> hmmm, anyone know the whereabouts of mmorrow?
15:21:20 <pumpkin> BONUS: nope, been wondering myself
15:21:39 <BONUS> HMMM
15:22:22 <Veinor> HUMMMMM
15:22:35 <pumpkin> HUMMMMMMMMER
15:22:35 <Saizan> got sucked into the internals of ghc?
15:22:44 <BONUS> choked on monads
15:22:47 <Sgeo> Would it be possible/easy to use Haskell as a substitute for something like Mathematica?
15:22:56 <MissPiggy> Sgeo that's what I am working on
15:23:12 <sinelaw> @type fmap fst . listToMaybe . reads
15:23:13 <lambdabot> forall a. (Read a) => String -> Maybe a
15:23:16 <BONUS> MissPiggy: really? cool. sort of like sage?
15:23:25 <MissPiggy> well I don't know sage
15:23:36 <lispy> Sgeo: I would expect you'd need to create a fair bit of mathematical 'infrastructure' in Haskell, but otherwise it seems reasonable
15:23:52 <MissPiggy> yeah for sure it's not easy though
15:23:55 <BONUS> sage is a pretty cool library in python that adds that mathematical infrastructure
15:24:00 <BONUS> yeah, it's a big task
15:24:08 <lispy> You might like yacas
15:24:13 <lispy> It's usable from the web
15:24:31 <lispy> (and open source)
15:24:41 <Sgeo> Cool
15:25:04 <Sgeo> Also: Why is WinHugs so attractive? I mean, my understanding is that GHC/GHCi is better, but WinHugs is so pretty
15:25:27 <lispy> http://yacas.sourceforge.net/homepage.html  <-- start with the tutorial link
15:25:35 <sshc> Sgeo: I would consider attractive subjective :P
15:26:10 <Sgeo> It has stuff like a .. hierarchy browser, I think (I installed it at school so I could Haskell away from home)
15:30:01 <BONUS> http://www.sagenb.org/home/pub/1320/ <--- pretty cool, sage demo
15:30:05 <sshc> Is the Real World Haskell ever going to close?
15:32:12 <Sgeo> So Yacas doesn't know sin^2 + cos^2 = 1?
15:32:57 <MissPiggy> @go Yacas
15:32:57 <lambdabot> Maybe you meant: google googleit do
15:34:43 <MissPiggy> Yacas is dumb :/
15:35:30 <Sgeo> MissPiggy, howso?
15:35:40 <MissPiggy> it can't do sin^2 + cos^2
15:35:56 <Sgeo> Well, besides that
15:39:39 <kmc_> Haskell might be a good underlying language for a computer algebra system, the way that deep within Mathematica there is some LISP dialect
15:40:22 <MissPiggy> I don't think haskell is a very good langauge for it
15:40:30 <MissPiggy> but it's the best one I know :/
15:40:56 <MissPiggy> anyway if I just try really hard and don't give up I should get something good eventually?
15:41:13 <arw> well, maybe. but i've not yet seen a computer algebra system that doesn't suck somehow.
15:41:28 <MissPiggy> what does it mean for a computer algebra system to suck?
15:41:48 <arw> well, take for example the included programming languages in all of them.
15:41:49 <MissPiggy> or, what are the main bad points?
15:42:06 <MissPiggy> oh right heh my embedded language is simple combinator calculus :P
15:42:28 <arw> they invariably are broken, tedious, have no debugging / ide / build system, etc.
15:42:35 <dschoepe> arw: sage is better in that respect, since it uses python
15:43:07 <arw> dschoepe: never heard of it.
15:44:09 <dschoepe> arw: http://sagemath.org/
15:46:58 <arw> "The Sage Notebook is a graphical front-end for Sage that runs in a web browser."
15:47:04 <arw> uh. sounds like pain.
15:47:54 <Sgeo> It requires registration
15:48:37 <tensorpudding> it is a bitch to install
15:48:51 <Sgeo> "To run Sage on Microsoft Windows you need the following:
15:48:52 <Sgeo> VirtualBox for Windows"
15:52:12 <arw> "At this point, Sage has only wrapped these functions for numerical use. For symbolic use, please use the Maxima interface directly, as in the following example: maxima.eval("f:bessel_y(v, w)")"
15:52:37 <arw> hm, having to use external libs even for bessel functions sounds somewhat lame.
15:53:26 <dschoepe> Well, sage is mainly a composition of external packages like maxima
15:53:48 <arw> well. there are nicer frontends for maxima :)
15:54:45 <tensorpudding> sage is more than just maxima though, is the thing
15:54:49 <olsner> (prime your zygohistomorphic prepromorphisms, psychobot is here)
15:55:07 <Sgeo> Does Sage know what sin^2 + cos^2 is?
15:55:40 <tensorpudding> though i'm not sure how well it works because it never installed on my computer
15:55:43 <sinelaw> Sgeo, sage just uses other packages
15:55:47 * MissPiggy is confused
15:56:00 <Sgeo> Do the packages that Sage uses tend to know?
15:56:10 <arw> well, that is something which one only learns by using it for some time: how useful are the algorithms for symbolic manipulation...
15:56:14 <MissPiggy> sin^2 + cos^2 is only true on real numbers?
15:56:47 <BONUS> afaik if you do sin^2 + cos^2 in sage you get 1
15:56:52 <tensorpudding> the guy behind sage wrote a story about how sage came about
15:56:58 <MissPiggy> > sin (0:+1)
15:56:59 <lambdabot>   0.0 :+ 1.1752011936438014
15:57:02 <tensorpudding> i remember that he mentioned thinking about using haskell for it
15:57:09 <tensorpudding> but decided on python instead
15:57:11 <MissPiggy> > sin (0:+1)^2 + cos (0:+1)^2
15:57:12 <lambdabot>   1.0000000000000002 :+ 0.0
15:57:15 <MissPiggy> woah
15:57:25 <MissPiggy> > sinh (0:+1)^2 + cosh (0:+1)^2
15:57:26 <lambdabot>   (-0.4161468365471423) :+ 0.0
15:58:16 <BONUS> you can go to sagenb.org and log in using haskell:monads
15:58:19 <BONUS> as the username:password
16:00:11 <osaunders> Hey BONUS.
16:00:19 <BONUS> yo!
16:00:32 <osaunders> Still working on LYAH?
16:00:59 <BONUS> yup, juggling working on the final chapters and going over the old ones with an editor
16:01:03 <BONUS> but it's coming along :)
16:01:32 <Sgeo> "Some functions in Yacas can be "threaded". This means that calling the function with a list as argument will result in a list with that function being called on each item in the list. E.g. Sin({a,b,c}); will result in {Sin(a),Sin(b),Sin(c)}. This functionality is implemented for most normal analytic functions and arithmetic operators."
16:01:40 * Sgeo goes running to Haskell's map
16:01:46 <osaunders> BONUS: Nice.
16:01:59 <Sgeo> BONUS, awesome :)
16:02:04 <BONUS> but actually atm studying for formal languages 1 class :[
16:02:31 <BONUS> its sort of fun but i'd rather be doing lyah
16:02:44 <arw> omg. "Traceback (most recent call last):". the pestilence of python has hit, run!
16:04:28 <olsner> arw: that's what you get for using python :P
16:05:28 <arw> i really really hate that. no python app bothers with any kind of useful error messages, just stacktraces...
16:05:42 <sinelaw> anyone (Cale?) know how to get the list of nicks currently in the channel inside lambdabot code?
16:05:43 <arw> and thats for end users fcol!
16:06:04 <michael|> arw: Error messages are so <insert favourite year>.
16:06:41 <olsner> what really bothers me is how python manages to print its stacktrace *after* it's exited as a result of a Ctrl-C ... why would it fork when it can only use one thread at a time anyway, and why ... beh, never mind </rant>
16:06:56 <tensorpudding> you might say that it was an exceptional year for error messages
16:07:04 <Twey> I particularly like the ‘keyword can't be an expression’ error
16:07:17 <Twey> It parsed fine, it knows what the user intends, but it just refuses to do it
16:07:18 <Yoshibloke> python's runtime errors are there to keep you on your knees
16:07:32 <olsner> Twey: have you tried exiting the python REPL?
16:07:36 <michael|> I'm just going to go hide the vim window I have open right now for the python script I was writing
16:07:36 <djahandarie> Yoshibloke, as opposed to on your toes? haha
16:07:40 <Twey> Oh yes, olsner :þ
16:07:49 <Twey> (but I exit every REPL with C-d anyway)
16:08:20 <Yoshibloke> Twey - My favorite is the "cannot concatenate int object to string object" one. I hit that one just about every 20 lines of code I write.
16:08:36 <Twey> Yoshibloke: That's just type failure on your part :þ
16:09:01 <arw> > 5 : "foo
16:09:02 <lambdabot>   <no location info>:
16:09:02 <lambdabot>      lexical error in string/character literal at end o...
16:09:12 <Yoshibloke> I must need more Haskell. I don't think enough in types yet :P
16:09:18 <Twey> Hehe
16:09:20 <Yoshibloke> or use PERL
16:09:23 <Yoshibloke> :P
16:09:24 <mauke> arw: hah, I know a language where that is a valid expression
16:09:25 <Twey> *shudder*
16:09:30 <mauke> Yoshibloke: it's Perl, not PERL
16:09:40 <Twey> Practical Extraction and Report Language!
16:09:42 <lament> pERL
16:09:46 <mauke> backronym
16:09:46 <arw> mauke: which one is that? some scheme or lisp?
16:09:51 <hzap_> mauke: C?
16:09:59 <hzap_> wait
16:10:00 <mauke> hzap_: you're fired
16:10:03 <Twey> Hahaha
16:10:07 <arw> hzap_: no, in c you need to balance quotes.
16:10:08 <mauke> arw: no, random esoteric language
16:10:16 <Twey> Which one?
16:10:20 <mauke> (the result is 'false', btw)
16:10:24 <mauke> ploki
16:10:27 <Twey> Well that makes sense
16:10:58 <Twey> Hmm, not on esolang?
16:10:59 <hzap_> arw: I was thinking you might be able to put unbalanced quotes in a #define
16:11:03 <sinelaw> @hoogle replace
16:11:03 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:11:04 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
16:11:04 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
16:11:07 <sinelaw> argh.
16:11:25 <mauke> Twey: it's only on my hd
16:11:29 <Twey> Ah
16:11:36 <Twey> You should upload it
16:11:43 <mauke> hzap_: no, the preprocessor is C's lexer
16:11:59 <mauke> macros work on a token stream
16:12:02 <sinelaw> @hoogle [a] -> [a] -> [a]
16:12:02 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
16:12:03 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
16:12:03 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:12:05 <mauke> Twey: but it has bugs :-)
16:12:06 <hzap_> damn. :D
16:12:14 <arw> hzap_: yes, you might, but after the preprocessor run it will probably break, except if you have the balancing quote somewhere else.
16:12:17 <sinelaw> is the something the replaces substrings?
16:12:21 <sinelaw> @hoogle [a] -> [a] -> [a] -> [a]
16:12:21 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
16:12:21 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:12:21 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:12:24 <Twey> mauke: Meh :þ
16:13:46 <sinelaw> i need to replace a substring a with substring b
16:14:49 <arw> Text.Regex would be overkill?
16:14:54 <sinelaw> yes
16:14:55 <aavogt> @hackage split
16:14:55 <lambdabot> http://hackage.haskell.org/package/split
16:15:06 <Twey> Text.Regex wouldn't be overkill
16:15:24 <sinelaw> arw, i have a list of substrings, and i want to replace each with a new substring (actually just add a suffix to the old substr)
16:15:24 <Twey> Substrings are sufficiently complex that regexen are justified
16:15:29 <Twey> pe'i
16:16:00 <olsner> how do regexen perform compared to KMP and other string-search algorithms?
16:16:10 <Twey> Which ones?
16:16:13 <mauke> depends on the regex library
16:16:19 <Twey> POSIX is probably fairly decent
16:16:29 <arw> depends on the kinds of features from the regex library you use.
16:16:45 <mauke> the perl engine might use something boyer-mooreish for constant strings
16:16:46 <Twey> Nay, PCRE is always slow
16:16:54 <arw> the simpler the subset the faster it will match. evil stuff like backreferences make it very slow though.
16:17:15 <olsner> intuitively, it seems that clever string searching algorithms are somewhat like building DFA:s for the string you search for
16:17:40 <arw> correct. thats where the term regex comes from.
16:18:19 <olsner> but I'm wondering if the DFA is or can be more/less efficient than string searching through KMP or boyer-moore
16:18:51 <mauke> I don't think you can make a DFA sublinear
16:19:02 <olsner> I guess since you can use the assumption of a simple string with no repetition, non-DFA-based approaches could be faster
16:19:30 <akappa> why wondering about, since KMP is so good?
16:19:39 <akappa> intellectual curiosity?
16:19:53 <olsner> yep, just wondering which is theoretically the fastest, more or less
16:20:07 <Saizan> KMP seems to simply be a DFA for .*needle.* to me
16:20:22 <arw> i think (but i have to check it on paper) that you can build a DFA for KMP from a regex-DFA
16:21:02 <akappa> mmh, I think it shouldn't be too difficult to built a DFA from the next table of KMP
16:21:38 <arw> hm, you just need to change the arrows going back to start according to the next-table.
16:21:51 <akappa> yes
16:22:26 <akappa> associate a state with the position in the pattern, and then fill the graph according to the next table
16:22:35 <akappa> it could be a doable approach
16:24:30 <sinelaw> > intercalate . words "hi there bot"
16:24:31 <lambdabot>   [[]->
16:24:32 <lambdabot>    ""
16:24:32 <lambdabot>  [""]->
16:24:32 <lambdabot>    ""
16:24:32 <lambdabot>  ["",""]->
16:24:33 <lambdabot> [4 @more lines]
16:24:38 <sinelaw> > intercalate "|" . words "hi there bot"
16:24:39 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:24:39 <lambdabot>         against inferred ty...
16:24:43 <sinelaw> > intercalate '|' . words "hi there bot"
16:24:44 <lambdabot>   Couldn't match expected type `[a]'
16:24:44 <lambdabot>         against inferred type `GHC.Types...
16:24:47 <sinelaw> > intercalate '|' . words $ "hi there bot"
16:24:48 <lambdabot>   Couldn't match expected type `[a]'
16:24:49 <lambdabot>         against inferred type `GHC.Types...
16:24:52 <sinelaw> sorry. :(
16:26:41 <Sgeo> Is there a WinGHCi similar to WinHugs? *googles*
16:27:08 <MissPiggy> > intercalate "|" . words $ "hi there bot"
16:27:09 <lambdabot>   "hi|there|bot"
16:27:11 <sinelaw> yeah
16:27:13 <sinelaw> got it in a pm
16:27:14 <MissPiggy> > intersperse '|' . words $ "hi there bot"
16:27:15 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
16:27:15 <lambdabot>         against inferred type...
16:27:20 <MissPiggy> o_o
16:27:24 <sinelaw> @type intersperse
16:27:25 <MissPiggy> > flip intersperse '|' . words $ "hi there bot"
16:27:25 <lambdabot> forall a. a -> [a] -> [a]
16:27:26 <lambdabot>   Couldn't match expected type `[a]'
16:27:26 <lambdabot>         against inferred type `GHC.Types...
16:27:31 <MissPiggy> oh hm
16:28:39 * kuribas doesn't like unary (-)
16:28:59 <kuribas> It would have been nicer if it was just number syntax.
16:33:08 <pumpkin> > intercalate "|" . words $ " hi there bot"
16:33:09 <lambdabot>   "hi|there|bot"
16:37:04 <kuribas> @src concat
16:37:04 <lambdabot> concat = foldr (++) []
16:37:24 <Sgeo> Well, WinGHCi doesn't have the fun stuff WinHugs has'
16:40:07 <theorbtwo> Fun stuff?
16:40:16 <theorbtwo> Does it do COM?
16:40:35 * ddarius doesn't know how one would associate COM with fun.
16:40:43 <badsheepy> fun stuff like having a small cry when you try to use glut :(
16:41:06 <pumpkin> so gluttonous
16:42:18 <Sgeo> WinHugs has some nice GUI to see hierarchy and the functions associated with a class
16:42:35 <theorbtwo> ddarius: I always wanted a good programming language that does good COM integration.
16:42:50 <theorbtwo> (Preferably real COM, and not just IDispatch.)
16:44:55 <nus> is this my browser, or something wrong with embedded queries in the Haskell' wikipage?
16:45:19 <kmc_> i saw that
16:46:14 <pumpkin> I vaguely remember a fairly complete-looking COM library on hackage
16:51:13 <dibblego> is there a library for parsing haskell source? (using parsec?)
16:51:14 <psychobot> dibblego: You have 1 new message. '/msg psychobot @messages' to read it.
16:51:35 <theorbtwo> Hmm, might have a look at that, then...
16:52:59 <sinelaw> haskell-src
16:53:02 <dibblego> @messages
16:53:02 <lambdabot> You don't have any new messages.
16:53:22 <dibblego> sinelaw, haskell-src is that?
16:53:23 <sinelaw> dibblego, i think that might be a mistake :) but to see what it is, use !messages
16:53:44 <dibblego> ah that worked
16:53:44 <sinelaw> dibblego, i'm just guessing, i know there's a package like that
16:53:53 <sinelaw> was that a real message?
16:54:04 <dibblego> yes, 8 months ago
16:54:10 <sinelaw> weird
16:54:24 <sinelaw> i guess lambdabot has old messages in the darcs repo
16:54:41 <ben> @hoogle Chan a -> Chan b -> IO (Either a b)
16:54:41 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:54:41 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:54:41 <lambdabot> Text.Parsec.Prim runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
16:56:21 <Saizan> sinelaw: yeah, delete State/tell if you don't want to spam everyone!
16:57:13 <sinelaw> done.
16:58:21 <sinelaw> Saizan, do you have any idea how to get a list of users in a channel?
16:58:29 <sinelaw> Saizan, in lambdabot code i mean
16:58:31 <Saizan> no
16:59:10 <sinelaw> theres Message.channels and names, but i'm stuck trying to put things togethers
16:59:15 <sinelaw> *together
16:59:25 <Saizan> i meant ~/.lambdabot/State/tell btw
16:59:47 <Saizan> maybe look at the Seen plugin
16:59:47 <gwern> it's a damn good thing amazon is currently not charging for transfer into S3 because all my duplicity backups are failing >.<
16:59:55 <sinelaw> Saizan, that's what i'm looking at
17:14:33 <gwern> oh, all I had to do was upgrade manually to the lucid debs of duplicity and its libraries
17:14:39 <gwern> gosh, that was no problem at all!
17:14:49 * gwern notes that OS upgrade days always make gwern irritable
17:16:34 <kuribas> It would have been nice to have a c style infix ifthenelse operator in the Prelude.
17:16:48 <kuribas> like (?) a b c = if a then b else c
17:18:15 <kpreid> you'd have to use that as (a ? b) c, which would be weird...
17:18:21 <kpreid> as a prefix that's popularly known as if'
17:18:31 <kuribas> ah..
17:18:44 <pumpkin> I prefer bool :: a -> a -> Bool -> a
17:18:46 <kuribas> kpreid: I use it as (a ? b $ c)
17:18:50 <jmcarthur> i think it would be nicer like :: a -> a -> Bool -> a
17:18:51 <Saizan> a ? b $ c
17:18:57 <jmcarthur> pumpkin: :P
17:18:59 <pumpkin> :D
17:19:08 <kpreid> kuribas: ah
17:19:26 <jmcarthur> it's nice to be able to go point free on the condition
17:20:20 <kuribas> kpreid: is if' defined somewhere?
17:20:29 <kpreid> dunno
17:21:11 <kuribas> The nice thing is that you can chain them like: (a ? b $ c ? d $ e ? f $ g)
17:21:24 <kuribas> Kind of like COND in lisp
17:22:33 <kuribas> jmcarthur: how would you use that?
17:22:38 <Hunner> What does it mean when the compiler says stuff about t, t1, t2, t3?
17:22:48 <Hunner> (ghc)
17:23:18 <kpreid> Hunner: it means that since you didn't write out lots of type sigs, the compiler had to give arbitrary names to them while it's complaining
17:23:42 <theorbtwo> It got bored of using a, b, c...
17:24:47 <jmcarthur> kuribas: i would allow things like, say:  map $ bool a b
17:25:07 <jmcarthur> kuribas: rather than: map $ \c -> if c then a else b
17:25:38 <c_wraith> both bool and ? would be really nice to have somewhere standard.  If is so...  redundant.
17:25:41 <jmcarthur> kuribas:  or:  map $ \c -> c ? a $ b
17:25:54 <jmcarthur> i wish there was at least an extension that removes ifthenelse
17:26:08 <jmcarthur> then i could define a function called if
17:26:09 * ksf wonders whether it's worth to introduce noneOf matching into his parser or just feed the oneOf parser with the other of those 256 characters
17:26:17 <Hunner> > fst . unsafeCoerce (1,2,3)
17:26:18 <lambdabot>   Not in scope: `unsafeCoerce'
17:27:02 <ksf> I guess the latter composes better, but doing that with real-world chars might be insanity.
17:27:42 <theorbtwo> Yeah, the second one *really* doesn't work with unicode.
17:28:00 <pumpkin> Hunner: that would definitely not do what you want
17:28:04 <pumpkin> Hunner: if you add a dollar it might
17:28:20 <ksf> also, one day I might want to match stuff which doesn't have an enumerable inverse, at all.
17:34:13 <Spockz|lap> I'm trying to build the haskell platform on debian, and the ./configure runs okay, but the make install fails on the missing dependency editline in the editline package.
17:35:52 <tommd> Spockz|lap: Have you not installed editline-dev?
17:36:31 <tommd> And yes, that should probably be checked in the config.
17:36:38 <Spockz|lap> tommd: I installed that one, now trying libedit2 and libedit-dev
17:36:42 <tommd> So you could open a bug.
17:37:03 <Spockz|lap> and it looks like that helps
17:38:12 <gwern> phew. the big uploads are going well and the cronjobs look right
17:38:26 <Spockz|lap> tommd: I see it's on the mailinglist already
17:38:34 <gwern> it was a lot of work but these automatic backups to S3 ought to save me in the long run
17:39:07 <gwern> be cheap too. at .15/gig and 17gigs stored
17:39:28 <Spockz|lap> tommd: not for debian specifically though
17:50:47 <nolrai_FG> @ty maybe
17:50:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:52:51 <sinelaw> !flush
18:15:31 <MarcWeber> Can I make cabal preprocess a the main-is file ? http://dpaste.com/156389/
18:16:24 <drdr> ????
18:16:53 <narens> hello! I am coming across a frequent problem and I am not able to find an existing abstraction to do it. I am in an IO monad, and I it validates a given input. I want to be able to exit the monad the moment any part of the verification fails.
18:17:52 <Cale> narens: "exit the monad"?
18:17:57 <theorbtwo> fail "error message", IIRC.
18:18:17 <Cale> narens: Do you perhaps mean that you'd like to throw an exception?
18:18:23 <narens> well, I mean want to for example putStrLn "bad input"
18:18:25 <Cale> (and perhaps to catch it later?)
18:18:32 <narens> Cale: I guess that would work
18:18:57 <narens> Cale: I guess that would be the right thing to do since the input is malformed
18:19:09 <narens> Cale: i was thinking something like guard
18:19:11 <Cale> narens: You could also just not continue with the validation
18:19:46 <narens> Cale: I want to avoid deep nestings of if or case.
18:20:09 <Cale> Yeah, then an exception would be a good bet.
18:20:44 <Cale> The new exception library makes it fairly easy to define your own new exceptions too.
18:21:12 <Sgeo> :t [id, const]
18:21:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
18:21:13 <lambdabot>     Probable cause: `const' is applied to too few arguments
18:21:13 <lambdabot>     In the expression: const
18:21:15 <narens> Cale: new exception library? Sorry, I don't usually make my code robust with exception :-(
18:21:20 <Sgeo> Why doesn't that work?
18:21:24 <Cale> data ValidationFailed = ValidationFailed deriving (Eq, Ord, Typeable, Show)
18:21:31 <Sgeo> Aren't functions all ultimately of the type a->b ?
18:21:38 <Cale> instance Exception ValidationFailed
18:21:49 <Cale> :t id
18:21:50 <lambdabot> forall a. a -> a
18:21:51 <Cale> :t const
18:21:53 <lambdabot> forall a b. a -> b -> a
18:21:56 <narens> Cale: neat
18:22:10 <Sgeo> But surely a -> b -> a fits as a sort of a -> b?
18:22:21 <Cale> Sgeo: In order for t -> t to match a -> (b -> a), you need t = a, and t = b -> a
18:22:25 <Cale> and so a = b -> a
18:22:31 <narens> Cale: wow, I am so lame... I just figured out what lambdabot is.
18:23:01 <Cale> Sgeo: It must match something more specific than a -> b
18:23:01 <Sgeo> Why is it trying to make it fit t -> t though? Why not t -> u
18:23:06 <Cale> Sgeo: id :: t -> t
18:23:22 <Sgeo> And a -> b is simply not allowed?
18:23:29 <Cale> Well, not for id.
18:23:32 <Cale> id x = x
18:23:49 <Cale> Clearly that produces a value only of the same type as it got as a parameter
18:24:14 <Cale> If id :: a -> b were true, I could use it to turn a value of any type into a value of any other type.
18:24:18 <theorbtwo> Cale: But the things of type a -> b are a superset of the things of type a -> a.
18:24:23 <Cale> Which means that either it somehow breaks the type system
18:24:37 <Cale> or it always goes into a nonterminating loop
18:25:03 <Cale> and it does neither of those
18:25:19 <narens> Cale: We were having a discussion a long time ago about learning category theory and such things where some of Haskell's abstractions are derived from. I am just taking a Modern Algebra course and its amazing to see some correlations between haskell and that course on how functions are treated as objects.
18:26:31 <Cale> narens: A lot of things we use in Haskell are taken from category theory. You have a category of groups and group homomorphisms or rings and ring homomorphisms, just as we have types and Haskell-definable functions.
18:26:42 <pumpkin> anyone considering going to ICFP this year btw?
18:27:15 <narens> Cale: haven't got that far, but, nice.
18:27:38 <Cale> (or vector spaces and linear maps)
18:29:07 <narens> Cale: Just one more question thats been nagging me. I see how mplus makes it nice to pick the first non Nothing choice in a bunch of lookups for example... but I don't understand why msum won't quit when it sees a Nothing? Is there something else that does that?
18:29:23 <pumpkin> :t msum
18:29:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:29:37 <pumpkin> there are effects to be had!
18:29:43 <Cale> narens: anyway, with the exception thing, you'd then be able to write   throw ValidationFailed  to throw the error (being careful to use the throw which is in Control.Exception and not the one in the Prelude), and then use catch (...) (\ValidationFailed -> ...) to catch any exception of that type which occurred
18:29:46 <pumpkin> @src msum
18:29:46 <lambdabot> msum =  foldr mplus mzero
18:30:04 <Cale> (You'd also pattern match the parameters if there were any details included about why the failure happened)
18:30:54 <Cale> > msum $ [Nothing] ++ [Just k | k <- [0..]]
18:30:55 <lambdabot>   Just 0
18:31:00 <narens> Cale: makes sense. I guess exceptions are the way to go for that problem. It also makes sense in terms of when it makes sense to use exceptions.
18:31:20 <Cale> msum keeps looking until it finds a Just
18:31:34 <Cale> If it never finds a Just, there's nothing it can do but to continue looking for one.
18:31:44 <Cale> (supposing that the list is infinite)
18:31:45 <pumpkin> it should predict the future
18:31:49 <narens> Cale: what does the opposite? Stopping when you find Nothing
18:32:02 <pumpkin> :t takeWhile (not . isNothing)
18:32:03 <lambdabot> forall a. [Maybe a] -> [Maybe a]
18:32:09 <Cale> any isNothing ?
18:32:16 <pumpkin> :t map fromJust . takeWhile (not . isNothing)
18:32:17 <lambdabot> forall a. [Maybe a] -> [a]
18:32:23 <Cale> > any isNothing $ [Nothing] ++ [Just k | k <- [0..]]
18:32:23 <narens> Cale: Well i mean it should also combine the actions
18:32:24 <lambdabot>   True
18:32:25 <pumpkin> fromJust is safe there!
18:33:11 <Cale> Yeah, see pumpkin's code if you want the values from the initial string of Justs
18:33:25 <Sgeo> Does any criticism of Haskell exist?
18:33:29 <Cale> :t map fromJust . takeWhile isJust
18:33:30 <djahandarie> Sgeo, none!
18:33:31 <lambdabot> forall a. [Maybe a] -> [a]
18:33:31 <pumpkin> :t map fromJust . takeWhile isJust
18:33:32 <lambdabot> forall a. [Maybe a] -> [a]
18:33:34 <pumpkin> hah, yeah
18:33:35 * SamB_XP wonders what happened to copumpkin
18:33:37 <Sgeo> This is the wrong place to ask, probably
18:33:38 <pumpkin> Sgeo: certainly
18:33:39 <SamB_XP> Sgeo: of course!
18:33:45 <SamB_XP> not necessarily
18:33:52 <pumpkin> SamB_XP: I didn't bother logging in with my laptop :) been doing a lot of work recently on my desktop
18:34:02 <Cale> Sgeo: I have lots of quibbles about the Prelude.
18:34:14 <Cale> Sgeo: Also, the monomorphism restriction is stupid.
18:34:18 * SamB_XP has a lot of issues with Prelude too
18:34:26 <SamB_XP> the MR I mostly just forget about
18:34:28 <pumpkin> also, I have lots of things I want
18:34:43 * djahandarie wants Haskell to make cash grow on trees
18:34:46 <SamB_XP> -- it's a lot easier to toss out than the Prelude issues!
18:34:48 <djahandarie> It can already do everything else with trees!
18:35:29 <Cale> fmap (const cash)
18:35:46 <pumpkin> I want a copointed on it though
18:35:52 <pumpkin> otherwise the cash might be trapped
18:36:03 <SamB_XP> too bad cash is actually kept in linear variables :-(
18:36:13 <SamB_XP> that cannot be duped, at that!
18:36:18 <narens> I just wonder why Control.Monad.Loops does not have nameThisM :: MonadPlus m => (a -> m a) -> a -> m a
18:36:26 <kniu> wow
18:36:30 <kniu> for the first time ever,
18:36:44 <pumpkin> narens: hmm...
18:36:45 <kniu> I found myself in need of a for loop instead of a map.
18:36:54 <pumpkin> narens: id ? :P
18:36:55 <Cale> kniu: forM?
18:36:59 <SamB_XP> narens: what would that do ?
18:37:01 <kniu> :t forM
18:37:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
18:37:12 <pumpkin> oh I see what it would do
18:37:19 <narens> its like an unfold
18:37:20 <kniu> no, see, I need the index of the element to do the action.
18:37:46 <pumpkin> narens: untilM? :)
18:37:47 <aavogt> then zip your list with the indexes
18:37:52 <pumpkin> unfortunately it's not very general
18:37:53 <narens> its similar to concat but with a stopping condition
18:38:00 <kmc> Sgeo, are you looking for documents or just individual gripes?
18:38:03 <kmc> i can give you a lot of the latter
18:38:04 <pumpkin> narens: const mzero? :P
18:38:05 <aavogt> :t (forM .) . zip [1..]
18:38:06 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(t, b)'
18:38:06 <lambdabot>       Expected type: [b] -> [[a]]
18:38:06 <lambdabot>       Inferred type: [b] -> [(t, b)]
18:38:12 <aavogt> :t (flip forM .) . zip [1..]
18:38:12 <Cale> narens: there's no way in general to discern that your m a is equivalent in any sense to mzero.
18:38:13 <lambdabot>     Couldn't match expected type `a -> m b'
18:38:13 <lambdabot>            against inferred type `(t, b1)'
18:38:13 <lambdabot>       Expected type: [b1] -> [a -> m b]
18:38:38 <kmc> there's a lot of uninformed criticism of Haskell on programming reddit
18:38:40 <kniu> zip [0 ..] "what, like this?"
18:38:44 <kniu> > zip [0 ..] "what, like this?"
18:38:45 <lambdabot>   [(0,'w'),(1,'h'),(2,'a'),(3,'t'),(4,','),(5,' '),(6,'l'),(7,'i'),(8,'k'),(9...
18:38:46 <kmc> probably some informed criticism too
18:38:53 <Sgeo> kmc, something similar to the C++ FQA, perhaps.. although that document essentially convinced me that C++ is bad
18:39:05 <kmc> i don't know of anything of that nature
18:39:22 <Cale> > zipWith (\n x -> replicate n x) [1..] "hello"
18:39:23 <SamB_XP> kmc: I don't think uninformed counts!
18:39:23 <lambdabot>   ["h","ee","lll","llll","ooooo"]
18:39:35 <Cale> > concat . zipWith (\n x -> replicate n x) [1..] $ "hello"
18:39:36 <lambdabot>   "heelllllllooooo"
18:39:50 <SamB_XP> Sgeo: I'm afraid we would need an FAQ before we could have an FQA?
18:40:03 <aavogt> > zipWithM replicate [1..10] "hello"
18:40:04 <lambdabot>   ["hello","hello","hello","hello","hello","hello","hello","hello","hello","h...
18:40:06 <SamB_XP> @faq do we have an FQA?
18:40:06 <lambdabot> The answer is: Yes! Haskell can do that.
18:40:13 <Cale> Sgeo: Haskell has fewer obvious terrible flaws.
18:40:24 <Cale> Sgeo: But it does have annoying small flaws.
18:40:29 <aavogt> > zipWithM replicate [1..3] "hello"
18:40:30 <lambdabot>   ["hel","hel","hel","hel","hel","hel"]
18:40:48 <kniu> does lambda have guards?
18:40:59 <Cale> kniu: No, but case does.
18:41:02 <narens> I guess I can use until. That's a good alternative
18:41:18 <aavogt> > (\x | x -> "no") True
18:41:19 <lambdabot>   <no location info>: parse error on input `|'
18:41:23 * Sgeo still hasn't seen a helpful example of the State monad
18:41:29 <Sgeo> I understand ST quite well by now
18:41:32 <Sgeo> I think
18:41:37 <Cale> Heh, I accidentally typed № at first.
18:41:48 <Sgeo> Well, not well, but I understand STRefs
18:41:55 <aavogt> that's because using State is like regular imperative programming...
18:42:01 <kmc> no it's not
18:42:15 <Sgeo> Also, Reader and Writer
18:42:22 <Cale> Sgeo: A good simple example of using the State monad is labelling a tree from left to right with the numbers from 1 up to the number of nodes.
18:42:23 <kmc> Sgeo, did you read "All About Monads"?
18:42:41 <Cale> Sgeo: If you try to write that function with plain recursion, you will run into a bit of annoyance
18:42:54 <Sgeo> kmc, the one that has an example for almost each monad? I think I've found those examples too confusing for me
18:42:58 <Cale> Sgeo: Because in order to know what label to apply to the root, you need to label the left subtree
18:42:59 <kmc> fair enough
18:43:18 <Cale> The examples in All About Monads are awful.
18:43:20 <aavogt> kmc: how not? You have a single variable you can `get' or `put' for computations using State s
18:43:44 <aavogt> or are we talking about ST?
18:43:47 <kmc> aavogt, because most imperative languages give you more than one memory cell, and allow you to create cells on the fly
18:44:25 <Sgeo> So State is like ST with only one reference available?
18:44:29 <Cale> Sgeo: So one solution is to initially have your labelling function take as an additional parameter the first remaining number to use as a label, and produce not only the labelled tree as its result, but also the next available label after labelling that tree.
18:44:39 <kmc> Sgeo, not reall
18:44:45 <kmc> Sgeo, the implementations of State and ST in GHC are totally different
18:44:49 <Cale> *sort of*
18:44:58 <kmc> State is just syntactic sugar for the usual pure functional idea of passing a state value around explicitl
18:45:06 <kmc> you can implement State in a few lines of regular pure Haskell
18:45:17 <Sgeo> kmc, unlike ST, apparently?
18:45:19 <kmc> ST on the other hand has reference cells with real in-place memory updates
18:45:29 <kmc> which you can't implement in vanilla Haskell
18:45:29 <Cale> You can think of a value of type State s a as internally just being a function s -> (s,a)
18:45:38 <aavogt> but that's just an implementation detail, kmc
18:45:39 <kmc> @unmtl State s a
18:45:39 <lambdabot> s -> (a, s)
18:45:45 <kmc> aavogt, right, that's where i started
18:45:46 <Cale> That is, a function from an initial state, to a final state paired with a result.
18:45:47 <SamB_XP> and, yeah, MTL has it backwards
18:45:57 <kmc> however the interface is also different, for a non-unrelated reason
18:45:58 <SamB_XP> I never understood why they do thta!
18:46:22 <aavogt> @type runState
18:46:23 <lambdabot> forall s a. State s a -> s -> (a, s)
18:46:35 <kmc> with ST you create new cells dynamically and give an initial value each time
18:46:49 <kmc> with State you have only one state, and you give its starting value as an arg to runState
18:46:56 <aavogt> well that's the only place that inconsistency shows up
18:47:05 <Cale> > let inc = do x <- get; put (x+1); return x in runState (do x <- inc; y <- inc; z <- inc; return (x,y,z)) 0
18:47:06 <kmc> so State code still feels "more functional" than ST code
18:47:06 <lambdabot>   ((0,1,2),3)
18:47:59 <Cale> :t foldBin
18:48:00 <lambdabot> forall t t1. t -> (t1 -> t -> t -> t) -> Bin t1 -> t
18:48:07 <Cale> hehe, it's still hanging around :)
18:48:18 <Sgeo> Cale, thanks
18:50:52 <kmc> i think Haskell has flaws besides the small annoying ones
18:51:42 <ddarius> Yeah.  Like that laziness thing... and that purity thing... and that functional thing.
18:52:20 <dolio> Yeah, everyone knows that you can't write efficient algorithms in a functional language.
18:52:26 <dolio> Only in imperative languages.
18:52:34 <kmc> good thing Haskell is an imperative language, then
18:52:53 <krasno1> I am having a problem with compiling ghc-10.4 on a 64bit core 2 duo
18:52:57 <kmc> we do a really poor job showing off the good support for imperative programming
18:52:57 <Cale> > let inc = (do x <- get; put (x+1); return x); labelTree = foldBin (return Tip) (\x l r -> do l' <- l; v <- inc; r' <- r; return (Branch v l' r')) in runState (labelTree (Branch "a" (Branch "b" Tip Tip) (Branch "c" Tip Tip))) 0
18:52:59 <lambdabot>   (Branch 1 (Branch 0 Tip Tip) (Branch 2 Tip Tip),3)
18:53:15 <krasno1> if anyone is interested in helping, the pastebin of the latest error is: http://pastebin.com/m76711e74
18:53:16 <aavogt> yeah, persistent datastructures are sometimes asymptotically slower
18:53:44 <Cale> > let inc = (do x <- get; put (x+1); return x); labelTree t = evalState (foldBin (return Tip) (\x l r -> do l' <- l; v <- inc; r' <- r; return (Branch v l' r')) t) 0 in labelTree (Branch "a" (Branch "b" Tip Tip) (Branch "c" Tip Tip))
18:53:45 <lambdabot>   Branch 1 (Branch 0 Tip Tip) (Branch 2 Tip Tip)
18:53:46 <aavogt> and haskell datastructures are persistent by default
18:53:57 <Sgeo> I think not having the Y combinator might be a flaw. If nothing else, its lack doesn't help fix people's notion that the reason lambdas can't recuse is because they have no name
18:54:03 <kniu> @src concatMap
18:54:03 <lambdabot> concatMap f = foldr ((++) . f) []
18:54:09 <Cale> Sgeo: huh?
18:54:11 <kmc> Sgeo, ? we have fix
18:54:13 <kmc> :t fix
18:54:14 <lambdabot> forall a. (a -> a) -> a
18:54:20 <Cale> Sgeo:  fix f = x where x = f x
18:54:25 <Sgeo> Oh
18:54:27 <krasno1> let testing_lambdabot = 55.5
18:54:38 <krasno1> > let testing_lambdabot = 55.5
18:54:39 <kmc> > fix (\self n -> if n == 0 then 1 else n * self (n-1)) 5
18:54:39 <lambdabot>   120
18:54:39 <lambdabot>   not an expression: `let testing_lambdabot = 55.5'
18:54:46 <Cale> Sgeo: If you want to write the more traditional Y combinator, you can, but it doesn't typecheck by default.
18:54:47 <aavogt> it's not in the Prelude though
18:54:56 <Cale> Sgeo: So you need to do a little newtype wrapping/unwrapping
18:55:03 <kmc> Sgeo, because "let" is recursive, you don't need "trickery" to write a fixpoint combinator
18:55:08 <kniu> does concatMap equal concat . map ?
18:55:17 <Cale> concatMap f = concat . map f
18:55:26 <kniu> oh, yeah.
18:55:27 <Cale> Or,  concatMap = (concat .) . map
18:56:11 <Sgeo> Anyone want to go slap the people who write that lambdas can't recurse?
18:56:28 <kmc> not really, it's not a thing i hear much
18:56:34 <Cale> Sgeo: Well, the simply typed lambda calculus has no recursion.
18:56:35 <kmc> besides, functional programming is not about lambda
18:56:59 <krasno1> kmc: uhh, I might take issue with statements like that one
18:57:01 <Cale> Sgeo: and it's only by adding various primitives, or fancier types that we can recover recursion
18:57:26 <kmc> functional programming is about function values.  lambda is just the literal syntax for a function value
18:57:38 <kmc> numerical computing is not about floating point literals
18:58:03 <kmc> you can support function values just fine without a literal expression syntax for them
18:58:12 <kmc> though it doesn't hurt to have one and it does make programming nicer
18:59:08 <kmc> i'd much rather slap the people who say "Haskell has no side effects"
18:59:27 <Cale> kmc: That's true to an extent though.
18:59:41 <krasno1> well, one could easily say that haskell is about putting an programmer-friendly face on the lambda-calculus, and lambdas are important to that
18:59:50 <SamB_XP> kmc: slap 'em with an uPIO?
18:59:51 <Cale> Haskell *evaluation* has no side effects.
18:59:54 <krasno1> conversely, C is putting a programmer-friendly syntax on turing machines
18:59:55 <kmc> right
19:00:02 <Veinor> @pl \x -> f x == x
19:00:02 <lambdabot> (==) =<< f
19:00:09 <Cale> (modulo lazy I/O, and various unsafe stuff)
19:00:10 <SamB_XP> krasno1: it's a *bit* better than that
19:00:19 <kmc> it's true if you're okay with omitting an important word
19:00:20 <aavogt> @type (==) `ap` ?f
19:00:20 <SamB_XP> krasno1: that's more like bf, really ;-P
19:00:21 <lambdabot> forall a. (Eq a, ?f::a -> a) => a -> Bool
19:00:30 <aavogt> @type (==) =<< ?f
19:00:31 <lambdabot> forall a. (Eq a, ?f::a -> a) => a -> Bool
19:00:32 <Veinor> > ((==) =<< succ) $ 2
19:00:33 <lambdabot>   False
19:00:35 <kmc> Haskell has values that represent side effects, which can be executed, and we have better first-class support for them than most languages do
19:00:44 <krasno1> I don't think it has to be better than that, I am satisfied with programming in something close to the lambda calculus
19:00:57 <SamB_XP> Haskell takes the "side" out of "side-effect"
19:01:02 <Cale> C is more detached from Turing machines than Haskell is from the lambda calculus.
19:01:09 <krasno1> SamB_XP: bf does not put a programmer-friendly face on turing machines
19:01:12 <SamB_XP> so, naturally, you end up with -effects
19:01:15 <kmc> but IO actions yield a value in addition to performing effects
19:01:22 <kmc> so i still feel like the effect is a side effect
19:01:33 * aavogt wonders why @pl prefers =<< to ap for Monad (r -> )
19:01:56 <dolio> It doesn't.
19:02:10 <aavogt> it's there. Labeled by the IO
19:02:14 <kmc> the thing to emphasize is not presence vs. absence of effects, but whether they're muddled in with functions or they get their own type
19:02:51 <SamB_XP> well, yes.
19:03:01 <SamB_XP> (->) is for functions, IO is for effects ;-P
19:03:05 <Cale> Yeah, the main innovation in Haskell's handling of IO isn't that IO is a monad. It's that IO actions are values.
19:03:29 <kmc> however i think the polymorphism of monads is important for other sorts of imperative programming
19:03:30 <Cale> (of a separate type from functions)
19:03:34 <kmc> like the relationship between STM and IO
19:04:00 <Cale> Well, it doesn't *really* matter that IO and STM are monads specifically.
19:04:17 <Cale> It's nice to know, in that it gives you all that stuff from Control.Monad for free
19:04:33 <Cale> But the more important thing is that we can keep them neatly separate.
19:04:47 <Cale> and that there's *some* set of operations for building those actions up
19:06:58 <dolio> @pl \f g x -> f x (g x)
19:06:59 <lambdabot> ap
19:07:06 <dolio> @pl \f g x -> f (g x) x
19:07:06 <lambdabot> flip flip id . liftM2
19:07:41 <dolio> Well, I'm not sure why it did that.
19:07:50 <dolio> @pl \x -> f (g x) x
19:07:50 <lambdabot> f =<< g
19:07:58 <dolio> @pl \x -> f x (g x)
19:07:58 <lambdabot> ap f g
19:08:07 <dolio> Anyhow, that's how it chooses between ap and (=<<).
19:09:06 <dolio> @pl \x -> x == f x
19:09:06 <lambdabot> ap (==) f
19:09:07 <Cale> krasno1: Why are you compiling GHC anyway?
19:09:13 <kniu> so I'm using readProcess and catch
19:09:35 <kniu> supposedly, if readProcess fails, the output to stderr is still returned.
19:09:46 <kniu> but an exception is thrown, so how would I get that output?
19:09:47 <krasno1> can I do a local install of the haskell platform, without root?
19:09:59 <Sgeo> STM?
19:10:32 <kniu> is there some way to get the result x of an IO x in a catch block even when that IO action throws an exception?
19:10:42 <Cale> krasno1: The easiest way to get things set up on linux is just to install the generic linux binary (in your case the one for x86_64), and then grab the tarball for cabal-install from Hackage.
19:11:00 <Cale> krasno1: Inside that tarball is a bootstrap script which will take you the rest of the way.
19:11:16 <kmc> Sgeo, software transactional memory
19:11:23 <krasno1> ok, thanks, I wasn't sure what the simplest path from where I was to where I want to be
19:11:44 <Cale> After you have a working GHC binary, and cabal-install, you can just use "cabal install <packagename>" to install anything you need.
19:12:05 <krasno1> However, I am still perplexed as to WHY it wouldn't compile
19:12:20 <Cale> You should always try to avoid compiling GHC by hand. There are usually decent binaries, and you need a working GHC to compile GHC anyway.
19:12:37 <krasno1> I have a working ghc, 10.4.1
19:13:03 <kmc> Sgeo, http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf http://book.realworldhaskell.org/read/software-transactional-memory.html
19:13:14 <SamB_XP> Cale: unless you REALLY do it by hand!
19:13:21 <Cale> SamB_XP: indeed :)
19:13:45 <SamB_XP> which Oleg can no doubt do in the type system!
19:14:23 <Cale> SamB_XP: and then about a week later, in the Haskell 98 type system.
19:15:09 <dolio> I don't know. He's been rocking the incoherent instances lately.
19:15:10 <krasno1> do I want 6.12.1?
19:15:22 <krasno1> sometimes oleg terrifies me...
19:15:29 <Cale> krasno1: Maybe soon, but probably not quite yet.
19:15:49 <Sgeo> GHC was written in Haskell?
19:15:57 <dolio> Still is.
19:16:21 <Cale> krasno1: My understanding is that there are still compatibility issues. By the time the next version of the Haskell Platform is released, it should be ready.
19:17:21 <felzix> does ghc work on an ARM processor?
19:17:58 <tommd> felzix: There are unregistered buids for ARM
19:18:01 <tommd> Debian has one
19:18:05 <kmc> felzix, it can output mostly portable C code which can build on ARM
19:18:13 <kmc> but that does not give the best performance
19:18:18 <Cale> felzix: There has been work in that direction, but probably for all practical purposes you should be surprised if it works.
19:18:25 <tommd> felzix: http://tommd.wordpress.com/2010/01/19/ghc-on-arm/
19:18:54 <felzix> thanks everyone!
19:20:02 <kmc> eventually GHC will have an LLVM backend
19:20:10 <kmc> which should make porting to new architectures somewhat easier
19:20:32 <tensorpudding> is the llvm backend under development?
19:20:47 <kmc> it was, recently
19:20:56 <tensorpudding> i saw the thesis by the guy who came up with it
19:21:09 <tensorpudding> it needs work yet
19:21:16 <Cale> Or LLVM does ;)
19:21:28 <tensorpudding> that's also a possibility :P
19:21:38 <Cale> LLVM's optimisations seemed to have a difficult time with Haskell code.
19:21:44 <Sgeo> Hm
19:21:52 <tensorpudding> low-level or not, its optimizations are tuned to imperative code
19:22:00 <Sgeo> I'm looking at the Real World Haskell stuff for STM, and it makes a lot of sense
19:22:11 <Sgeo> I think RWH will be where I go for information as much as possible
19:22:18 <kmc> Sgeo, yeah, RWH is fantastic :)
19:24:39 <ddarius> You should watch Simon Peyton-Jones' talk on STM.  Whether it makes sense or not it will be entertaining.
19:25:47 <djahandarie> All of his talks, and most all of his papers are pretty clear
19:26:08 <djahandarie> He doesn't force you to swim in all sorts of crazy unrelated stuff in order to get to his point, it's pretty refreshing compared to some other stuf
19:27:18 <SamB_XP> he's also animated it's a wonder he's not in .swf ;-P
19:27:21 <SamB_XP> +so
19:28:10 <kmc> does his talk have comic sans ms
19:28:18 <SamB_XP> they tend to
19:28:23 <SamB_XP> iirc
19:28:29 <SamB_XP> and crayon clipart
19:30:08 <jrockway> hmm
19:30:15 <jrockway> has anyone done any android stuff with haskell?
19:30:47 <jrockway> (i have seen a few mailing list threads saying "i wish i could do this", but nobody actually doing anything :)
19:46:08 <dufflebunk> Is there a handy way of encoding an Int32 into a base 62 representation (as in it uses A-Z, a-z, 0-9)?
19:46:24 <kmc> :t showIntAtBase
19:46:25 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
19:46:54 <bookhacker> Hello; Is it common / good practice to use state monads for dynamic programming?
19:47:38 <kmc> common enough
19:47:43 <c_wraith> bookhacker: arrays or the Data.MemoCombinators package are more common
19:47:59 <kmc> i would use data-memocombinators as a first stab
19:48:07 <nolrai_FG> jrockway: How would you..haskell to jvm is difficalt.
19:48:29 <jrockway> yeah
19:48:35 <kmc> yes, JVM does not properly support tail calls
19:48:41 <jrockway> although there are non-JVM langauges in ASE, like perl, lua, etc.
19:49:03 <c_wraith> I thought haskell didn't optimize tail calls by default either
19:49:10 <jrockway> "haskell" or "ghc"?
19:49:11 <kmc> uh
19:49:11 <bookhacker> which would you recommend if performance is the primary concern? arrays, state monads, or memocombinators?
19:49:17 <chrissbx> So, I've run "cabal install sexpr" as normal user, and it should contain Codec.Sexpr, now how should I call it for the import, or what options does ghc need?
19:49:21 <jrockway> but if it didn't, you could not loop in haskell :)
19:49:25 <dufflebunk> Thanks kmc, that should help
19:49:36 <dolio> I wouldn't use a state monad.
19:49:48 <kmc> the Haskell spec requires optimized tail calls, iirc.  but also, these things have different sorts of implications under lazy evaluation
19:49:50 <cp2> see: http://jaskell.codehaus.org/
19:49:53 <dolio> I'd use something like memocombinators.
19:50:15 <pikhq> jrockway: Sure you could. GHC doesn't use the C stack. :P
19:50:23 <kmc> your supposedly tail-recursive function can end up using much more memory than one that looks not tail recursive (but is productive of data)
19:51:32 <dolio> Dynamic programming is something that a lazy functional language is very obviously better at than an average imperative language, so mimicking the imperative algorithm doesn't make much sense to me.
19:51:45 <nolrai_FG> chrissbx: just Import Codec.Sexpr in the file should be enough.
19:51:51 <bookhacker> so um, which has the best performance?
19:52:00 <chrissbx> nolrai_FG, it doesn't find it; so I guess I need to pass ghc some options
19:52:18 <chrissbx> ghci in emacs, that is
19:52:29 <jrockway> pikhq: that was my saying of "it does" :)
19:52:55 <dolio> I'm afraid you'll have to test. I haven't run benchmarks.
19:53:04 <jrockway> chrissbx: ghci does not see newly-intalled modules without a restart, i've noticed
19:53:08 <jrockway> at least not on my machine
19:53:11 <Cale> bookhacker: memocombinators will probably require the least refactoring of your code. Using the State monad should never improve performance (it's just a wrapper around a particular functional idiom). Using the ST monad and mutable STArrays is an option which you can save as a last resort -- unless the arrays you'd be using are certain to be very large, I'd stay away from it until you know you need it.
19:54:44 <chrissbx> jrockway, thanks, restarting ghci makes it find the module, although it now just says: "Failed to load interface for `Codec.Sexpr.Parser':" then nothing after the colon.
19:54:46 <Cale> bookhacker: A nice thing about memocombinators is that typically you can write naive recursive code, and really easily throw in some memoisation after you have that working with minimal changes.
19:55:30 <jrockway> chrissbx: i will install and take a look
19:55:50 <jrockway> i occasionally feel the need to write a toy sexpr-based language, but don't usually get past the sexpr parser ;)
19:56:00 <jrockway> so if i can be familiar with a library to handle that, then that will be good :)
19:56:05 <Cale> bookhacker: Take note of the arrayRange combinator as well -- it gives you nice fast access for a bounded range of inputs, backed by a lazy immutable array.
19:56:17 <pikhq> jrockway: The easy bit. :)
19:56:30 <jrockway> yeah
19:56:39 <jrockway> to be fair to myself, it was only in perl when i never got past the parser
19:56:48 <jrockway> with parrows in haskell, that was about 2 lines of code :)
19:56:58 <pikhq> jrockway: http://sprunge.us/FFHS
19:57:15 <pikhq> Mmm, delicious Parsec.
19:58:15 <jrockway> (parser combinators)++
19:59:54 <nolrai_FG> Is there a idom for apling a function to the first element of a list? I need to captilize a word.
20:00:08 <aavogt> (\(x:xs) -> f x : xs)
20:00:37 <aavogt> longer if you need to handle empty lists
20:00:59 <aavogt> (\x -> case x of a:as -> f a : as; _ -> [])
20:02:01 <chrissbx> ghci -B/home/rchris/.cabal/ says "ghc-6.8.2: Can't find package.conf as /home/rchris/.cabal//driver/package.conf.inplace"
20:02:07 <chrissbx> Is there a problem with that?
20:02:37 <jrockway> i see the same problem on my non-broken system
20:02:41 <jrockway> the cabal file also seems fine
20:02:46 <jrockway> and the test executable builds and runs
20:05:49 <jrockway> in ghci, it seems like Codec.Sexpr is loading quickcheck, and assumes it is getting version 1.2
20:06:02 <jrockway> but in ghci, it actually gets the newest version, 2.whatever, which has a different API
20:06:22 <jrockway> (the problem is its instance of Arbitrary, which includes a coarbitrary function, but that's not part of Arbitrary anymore)
20:06:41 <jrockway> chrissbx: so, do you have quickcheck > 1.2 installed anywhere?
20:06:50 <chrissbx> It got installed by cabal
20:07:22 <chrissbx> actually version 1.2.0.0 got installed by cabal
20:07:31 <jrockway> for me, it works when i "ghc-pkg hide QuickCheck-2.1.0.1"
20:07:34 <dmwit> aavogt, nolrai_FG: \xs -> map f (take 1 xs) ++ drop 1 xs
20:07:44 <chrissbx> aha, hide the newer.
20:07:48 <jrockway> yeah
20:08:02 <chrissbx> but why should that be the problem, if it doesn't mention quickcheck for me?
20:08:14 <dmwit> :t uncurry (++) . (map f *** id) . splitAt 1
20:08:15 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr a) => [a] -> [a]
20:08:16 <chrissbx> what did it say for you?
20:08:18 <jrockway> dunno, but that is the error i get when i :load "Codec/Sexpr.hs"
20:08:22 <dmwit> :t \f -> uncurry (++) . (map f *** id) . splitAt 1
20:08:23 <lambdabot> forall a. (a -> a) -> [a] -> [a]
20:08:28 <jrockway> "import ..." gives me the same error that you got
20:08:40 <jrockway> but that error was not helping me debug anything, so i tried something else :)
20:08:41 <dmwit> > splitAt 1 []
20:08:43 <lambdabot>   ([],[])
20:09:17 <dmwit> :t \f -> uncurry (++) . on map (***) f id . splitAt 1
20:09:18 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
20:09:18 <lambdabot>     In the first argument of `on', namely `map'
20:09:18 <lambdabot>     In the first argument of `(.)', namely `on map (***) f id'
20:09:33 <jrockway> chrissbx: incidentally, that doesn't fix the problem with import
20:09:40 <dmwit> :t \f -> uncurry (++) . on (***) map f id . splitAt 1
20:09:42 <lambdabot> forall a. (a -> a) -> [a] -> [a]
20:10:06 <aavogt> on doesn't look nice prefix
20:10:17 <chrissbx> "cabal register sexpr" says No cabal file found. Couldn't someone who knows how to use cabal tell us?
20:10:19 <dmwit> I agree, but it's hard to fully apply infix.
20:10:32 <dmwit> s/hard/annoying/
20:10:38 <dmwit> And I'm going for obfuscated here anyway. =)
20:10:40 <chrissbx> please :)
20:11:14 <aavogt> :t uncurry (++) . ((***) `on` map) ?f id . splitAt 1
20:11:15 <lambdabot> forall a. (?f::a -> a) => [a] -> [a]
20:11:47 <jrockway> chrissbx: cabal unpack first
20:11:54 <chrissbx> (aha, finally found http://www.haskell.org/haskellwiki/Cabal-Install, I was stuck at How_to_install_a_Cabal_package previously)
20:11:55 <aavogt> :t uncurry (++) . first (map ?f) . splitAt 1
20:11:56 <lambdabot> forall b. (?f::b -> b) => [b] -> [b]
20:12:02 <jrockway> the only .hi files that get copied over are the main Codec.Sexpr
20:12:08 <jrockway> i never write my modules that way, so i have never seen this problem
20:12:21 <jrockway> it will probably work if you runhaskell instead of ghci :)
20:13:22 <chrissbx> no, same problem, "Failed to load interface for `Codec.Sexpr.Parser':"
20:13:24 <jrockway> it works if i change the Exposed-Modules to include all of the modules, instead of the interface module
20:13:53 <jrockway> cabal unpack, edit Exposed-module to Exposed-modules: Codec.Sexpr, Codec.Sexpr.Parser, Codec.Sexpr.Printer, Codec.Sexpr.Internal, "cabal install"
20:13:56 <jrockway> then it works in ghci :)
20:14:09 <jrockway> this is clearly a problem somewhere, but i don't really know what
20:14:15 <jrockway> anyone with a clue should say something now :)
20:32:52 <Sgeo> Ok, I'm officially in love with Haskell's regex handling
20:33:44 <tensorpudding> haskell's regex handling is definitely unique
20:35:01 <dbro> Can someone point me to a working example of using quickcheck to generate a list of random numbers? I'm not able to find one and I can't figure it out
20:35:08 <kmc> i don't like the regex api
20:35:23 <kmc> seems like unnecessary typeclass overloading
20:36:00 <dbro> eg. why doesn't this work? gen_list = vector 10 arbitrary::MyType
20:36:52 <dbro> Couldn't match expected type `Gen a -> MyType'
20:37:04 <dbro> against inferred type `Gen [a1]'
20:38:03 <eggman35639> how do you send a message to just one user in the main chat window?]
20:39:25 <ddarius> kmc: You can use the more explicit/direct API.
20:39:27 <byorgey> eggman35639: /msg username message
20:39:37 <dino-> kmc: I kind of avoid the (~=) thing with regex in H, and go with the matchRegex mkRegex stuff more. Which oddly has harder-to-find docs!
20:39:40 <eggman35639> ok, thx
20:41:05 <Sgeo> Hm
20:41:23 <Sgeo> Is the online version of RWH like a beta, or is it the published version, or is it newer?
20:42:31 <jrockway> dino-: isn't that deprecated?
20:42:33 <dino-> Interesting question. Have the web RWH and dead tree edition diverged?
20:42:37 <jrockway> (Text.Regex.Base?)
20:42:46 <dino-> jrockway: Oh my, I hope not!
20:43:13 <jrockway> it only supports the Text.Regex.Posix, which is the worst regex backend available
20:43:23 <jrockway> (so i learned after spending a day getting it to compile on windows...)
20:44:49 <dino-> jrockway: Well, that's disappointing.
20:45:49 <tensorpudding> there are a lot of regex packages...
20:46:02 <jrockway> the =~ API is considered better
20:46:13 <jrockway> mkRegex is unnecessary because creating the pattern is usually memoized automatically
20:46:17 <jrockway> (or so i've read)
20:46:33 <jrockway> changing from Text.Regex.Base + Posix -> Text.Regex + TDFA made my app like 10x faster though
20:46:40 <aavogt> @hoogle anyM
20:46:41 <lambdabot> Data.Graph.Inductive.Monad matchAnyM :: GraphM m gr => m (gr a b) -> m (GDecomp gr a b)
20:46:51 <jrockway> FWIW, i also like the T.R.Base API better
20:46:55 <jrockway> mkregex, matchregex
20:46:55 <dino-> I guess I could get used to it (just like when you write Perl), but the types are nutty. Make me feel dizzy!
20:47:00 <jrockway> yeah
20:47:04 <jrockway> it is a terrible API really
20:47:12 <jrockway> "oh, haskell has polymorphic return values!!!"
20:47:24 <jrockway> yes, but it doesn't mean that your function needs to take every type and return every type :)
20:47:34 <jrockway> where types are associated with arbitrary meanings
20:47:36 <tensorpudding> regex-tdfa alleges that regex-posix is broken, hmmm
20:47:42 <jrockway> that is just MHO though
20:47:56 <jrockway> tensorpudding: regex-posix is the "regex.c" that comes with UNIX
20:48:04 <tensorpudding> hmm
20:48:04 <jrockway> "comes with UNIX" usually means "is bad" :)
20:48:17 <tensorpudding> what applications use regex.c?
20:48:28 <tensorpudding> is that what the grep-likes use?
20:48:35 <jrockway> very unlikely
20:48:40 <aavogt> > foldrM (\a acc -> tell [a] >> return (a || acc)) False $ replicate 100 False ++ repeat True
20:48:42 <lambdabot>   Not in scope: `foldrM'
20:48:44 <jrockway> not egrep, definitely
20:48:51 <aavogt> > foldM (\acc a -> tell [a] >> return (a || acc)) False $ replicate 100 False ++ repeat True
20:48:52 <lambdabot>   No instance for (Control.Monad.Writer.Class.MonadWriter
20:48:52 <lambdabot>                    ...
20:48:58 <tensorpudding> if regex.c is used by almost nothing...why is it specified to exist...
20:49:00 <aavogt> > execWriter $ foldM (\acc a -> tell [a] >> return (a || acc)) False $ replicate 100 False ++ repeat True
20:49:01 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
20:49:20 <kmc> i want to see that on a cereal box.  "Comes with UNIX!"
20:49:31 <tensorpudding> i guess that's the same question as "does anyone use troff anymore"
20:49:33 <kmc> "Free OpenSolaris CD inside"
20:51:45 <tensorpudding> hmm
20:52:53 <tensorpudding> it's kinda like how cracker jack still comes with prizes
20:53:56 <sshc> is there a way to tell GHC that I want to use hsc2hs instead of CPP in a pragma?
20:54:52 <sshc> if not, can I specify it in the cabal file?
20:55:11 <aavogt> there's some {-# OPTIONS_GHC -Fpgm... #-}
20:55:12 <c_wraith> sshc: you can set anything with the OPTIONS_GHC pragma
20:55:24 <aavogt> not anything, but preprocessors work
20:57:58 <jrockway> cabal auto-detects my .chs files and does the right thing
20:58:08 <jrockway> dunno about other preprocessors (although the docs talk about this, so check there)
20:58:09 <nolrai_FG> > init "add#"
20:58:10 <lambdabot>   "add"
21:01:35 <nolrai_FG> So how do you pass arguments to an app you're trying to debug in ghci?
21:02:26 <mtnviewmark> you use :set args
21:02:43 <mtnviewmark> also :set prog
21:02:44 <aavogt> also :main arg1 arg2
21:03:47 <nolrai_FG> Is there a way to just pass in the string you would use on the terminal?
21:05:13 <monochrom> :main arg1 arg2 is a way to just pass in the string you would use on the terminal.
21:05:19 <nolrai_FG> sweet
21:05:22 <nolrai_FG> thanks
21:05:31 <monochrom> (I wonder if you even tried.)
21:06:46 <nolrai_FG> as soon as I wrote the question it orcorde to me that it probobly was..:S
21:07:21 <nolrai_FG> how ever you spell that. Stupid dixlexia
21:18:54 <sshc> is it possible to detect infinite loops in ghci?
21:19:11 <pumpkin> you mean that <<loop>> stuff?
21:19:27 <pumpkin> I don't think it looks, but those are a very specific case of infinite loop
21:19:30 <pumpkin> in general it's impossible
21:19:41 <Gracenotes> that's when a value requires itself to evaluate itself
21:19:53 <Gracenotes> which GHC can detect
21:20:17 <Gracenotes> or it could just be computing forever
21:22:46 <kmc> iirc ghci doesn't do the blackholing necessary to see <<loop>>
21:22:49 <kmc> only compiled ghc code does
21:23:50 <Veinor> isn't detecting whether a value requires its own evaluation equivalent to the halting problem?
21:23:59 <kmc> not once it happens
21:24:08 <Veinor> well yeah :p
21:24:17 <pumpkin> in general, sure, but if it directly needs itself it's fairly easy to see
21:24:46 <kmc> the idea is that a thunk which will be overwritten when evaluated is first overwritten with a "black hole"
21:24:56 <kmc> forcing a black hole throws the "<<loop>>" exception
21:30:43 <Dashkal> Hmm, I managed an odd situation.  My System.IO is missing some symbols.  Notibly utf8 and NewlineMode.
21:30:46 <alexsuraci> @src sequence
21:30:46 <lambdabot> sequence []     = return []
21:30:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:30:47 <lambdabot> --OR
21:30:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:35:12 <Dashkal> wondering if I managed to get teh docs for 6.12's distro instead of 6.10s...
21:52:20 <c_wraith> wow, hpaste is a mess
21:52:51 <pumpkin> yay spammers
21:53:06 <pumpkin> we need glguy to make us a new one with a captcha :)
21:59:01 <c_wraith> So, am I doing anything wrong by wanting this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=18912#a18912
22:03:04 <ozataman> Hey all
22:03:12 <ozataman> I'm having some trouble installing criterion
22:03:20 <ozataman> I keep getting cabal: cannot configure Chart-0.12. It requires cairo >=0.9.11 and gtk
22:03:21 <ozataman> >=0.9.11
22:03:33 <ozataman> And then something like "There is no available version of cairo that satisfies >=0.9.11"
22:03:37 <ozataman> any ideas?
22:03:42 <c_wraith> yeah, cairo can't be installed from hackage
22:03:49 <c_wraith> You can install it without cairo support
22:04:03 <c_wraith> I believe by adding -f-no-chart to the cabal install line
22:04:16 <c_wraith> But that means it doesn't generate graphs, just the text files
22:06:10 <ozataman> I see.. How can I install cairo?
22:06:17 <ozataman> I'm on OS X
22:06:21 <pumpkin> need to go to egypt
22:06:37 <ozataman> pumpkin: :)
22:06:45 <c_wraith> I've never tried.  I'm not the one to ask about that.
22:07:38 <ozataman> It seems it's included in macports
22:08:00 <ozataman> I hope it plays nicely with the non-macports ghc installation
22:18:22 <dibblego> is there a flip map?
22:18:43 <c_wraith> only if there's an M involved
22:18:54 <dibblego> where?
22:18:58 <dibblego> @type lifTM
22:18:59 <lambdabot> Not in scope: `lifTM'
22:19:00 <dibblego> @type liftM
22:19:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:19:07 <c_wraith> @src forM
22:19:07 <lambdabot> forM = flip mapM
22:19:15 <dibblego> bleh
22:19:17 <tensorpudding> > let pam = flip map in pam [1..10] succ
22:19:17 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
22:27:08 <Sgeo> Why, exactly, doesn't All About Monads cover the ST monad?
22:28:42 <c_wraith> ST isn't very special, as far as monads go.
22:28:50 <pumpkin> and it requires additional knowledge
22:29:00 <pumpkin> (rank-2 types)
22:29:41 <c_wraith> everything that is in ST has a parallel in IO.
22:30:05 <pumpkin> the main interesting thing about ST is how it uses the rank-2 type to remain externally pure
22:41:03 <chelz> i read or heard somewhere not too long ago that haskell takes an approach of some kind of strict adherence to a system even at the expense of efficiency where the system does not line up with the popular processors' design. is there anything written that addresses this and is worthwhile?
22:42:04 <pumpkin> chelz: the fundamental model of haskell you mean?
22:42:08 <mtnviewmark> same could be said about many popular languages.... (notices the lack of HW support for garbage collection....)
22:42:27 <pumpkin> chelz: haskell is very different from most CPU designs, yep. And that's an advantage ;)
22:43:35 <arw> chelz: almost every modern language has constructs, which are very slow to implement on current processors.
22:44:05 <arw> chelz: even C has such features, bitfields for example.
22:44:23 <pikhq> Though C doesn't have many such features.
22:44:32 <pikhq> After all, modern CPUs are basically C machines.
22:45:09 <arw> its the other way round. c was built to fit the most popular processors.
22:45:53 <pikhq> C was built to fit a very specific processor, which happened to use some fairly common design concepts to CPUs at the time.
22:46:06 <pikhq> Later CPUs were then designed specifically *to support C*.
22:46:28 <pikhq> Because C was for the longest time "the" language.
22:47:06 <arw> not really. years before fortran was widely used, which has a execution model not too different from c.
22:47:07 <pumpkin> and now C doesn't really match the CPU model either
22:47:11 <chelz> oh yeah i read a thing about how modern processors have shaped themselves around C
22:47:14 <chelz> oh
22:47:15 <pumpkin> but enough people think it does that the myth will survive for a while
22:49:04 <chelz> well i guess it's good to have solid maintainable code and designs, but it seems only practical to try to take advantage of all one can on a processor
22:49:07 <pikhq> x86 is the one that's most C-supporting in common use.
22:49:31 <pikhq> And that's really just the exposed machine code -- modern x86 microcodes to RISC, anyways.
22:49:39 <pumpkin> chelz: exactly. And you don't want your language to be too sensitive to that, because that's the compiler's job
22:50:03 <pumpkin> so you want a language that doesn't make an attempt to model your CPU in the first place, so the compiler has more freedom to use crazy features
22:50:12 * pumpkin turns down zealot knob
22:50:23 <chelz> are there any essays out there on the topic of haskells rationale behind its design in terms of not being like c and not necessarily taking advantage of processors?
22:50:39 <pumpkin> haskell follows lambda calculus!
22:50:43 <pumpkin> screw actual machines
22:50:46 <pumpkin> we run on abstract machines
22:50:52 <pikhq> chelz: C semantics suck for most things.
22:51:12 <chelz> pumpkin: yeah that's what i'm looking for i guess
22:51:26 <pikhq> This is, in fact, the rationale behind most every higher-level language.
22:51:34 <chelz> oh?
22:51:43 <pikhq> Direct pointer manipulation and manual memory allocation are *painful*.
22:52:03 <dankna> it's absolutely astonishing to me how many good programmers don't see that point
22:52:07 <chelz> but if they're oh so fast, shouldn't a language not ignore such things?
22:52:09 <pikhq> And, really, they're key to C's semantics.
22:52:13 <erikc> chelz: http://research.microsoft.com/en-us/um/people/simonpj/Papers/slpj-book-1987/
22:52:23 <dankna> they know how to do manual memory management, so they don't see why garbage collection is so important, for example
22:52:43 <arw> chelz: many of those features are _not_ fast, if you have a compiler as a layer in between.
22:52:53 <pikhq> dankna: Goodness, you're right...
22:52:58 <mtnviewmark> chelz - many (most?) programming tasks aren't constrained by execution speed ---
22:53:09 <pikhq> Most people don't just link in Boehm GC for quick C hacks or such.
22:53:17 <mtnviewmark> major web sites are run on PHP! consider the waste of CPU cycles there!
22:53:19 <arw> chelz: pointers cause problems with aliasing which prevents the compiler from doing many useful optimizations.
22:53:28 <pikhq> (sure, I can *do* manual memory management, but I'd really prefer not to think about it.)
22:53:49 <chelz> erikc: thanks!
22:54:02 <pikhq> chelz: Most of the time, IO speed is a limiting factor, not execution speed.
22:54:02 <dankna> yeah, exactly.  C was my first serious language and I know manual memory management like the back of my hand, but I hate it.  why would I subject myself to that, when the compiler can do it for me?  to prove I can?
22:54:06 <mtnviewmark> most programming tasks are much more constrained by how fast the programmer(s) can express their intent
22:54:18 <mtnviewmark> and how easily such programs can be maintained and modified
22:54:24 <arw> chelz: fortran doesn't have pointers in that sense, so the aliasing problem (mostly) doesn't exist there. and fortran compilers produce faster code than c compilers for that reason.
22:54:24 <mtnviewmark> here, Haskell comes shining through
22:55:14 <chelz> did fortran do anything to get where it is in terms of speed or did processor makers shape themselves around fortran?
22:55:32 <pikhq> Fortran's semantics are similar to C, except easier to optimise.
22:55:54 <dankna> it's the restricted semantics that make Fortran fast, as I understand it, so in that sense it's to Fortran's credit, which I think is what you're asking
22:56:11 <arw> chelz: well. fortran was around since the beginnings in 1950something, so you can bet that many machines have been built to run fortran.
22:56:11 <chelz> ah
22:56:50 <chelz> i wonder if fortran's designers had to forego anything in the interest of efficiency, which i take it haskell's designers didn't concern themselves with
22:57:14 <arw> well. back then, everything was about efficiency.
22:57:17 <chelz> would be nice if there was some way to measure the non-raw-code-performance metrics of a language
22:57:43 <pikhq> In the 50s? They ommitted *case* for purposes of efficiency then.
22:57:47 <arw> it was the time when people whined about using 4-digit years in a date...
22:57:49 <chelz> arw: can that be gleaned from the design and use of programming languages? or something else?
22:57:56 <chelz> ah haha
22:57:59 <chelz> that's wild
22:58:12 <pikhq> THEY SERIOUSLY USED UPPER CASE FOR EVERYTHING BECAUSE THE EXTRA BIT WOULD USE MORE SPACE.
22:58:12 <mtnviewmark> the original fortran implemetnations were little more than linkers --- converting the program to essentially a series of subroutine calls for each linguistic aspect -- -they are far less efficient than coding to the machine code
22:58:16 <pikhq> YES. SERIOUSLY.
22:58:23 <dankna> I'm not sure whether pointers were an intentional omission or whether it was simply the case that nobody had invented the idea of having them in a high-level language yet
22:58:36 <dankna> but their omission is most of Fortran's speed, as I understand it
22:58:44 <mtnviewmark> so, essentically yes - the Fortran designers happily gave up some execution speed in exchange for expressability
22:59:08 <pikhq> mtnviewmark: Well, pretty much all high-level languages do that.
22:59:38 <pikhq> Even assembly can be said to do that, compared with machine code.
22:59:42 <mtnviewmark> well, original fortran did it much more than you might think!  original implementations had almost no directly compilable constructs
22:59:47 <pikhq> (hey, assembling things takes *time*)
23:00:17 <mtnviewmark> and - yes, when all you have is 4k of memory, four digit years are a consideration
23:00:20 <chelz> has anyone tried to make a bastardized melding of fortran and haskell? perhaps a range could be at least theoretically designed, deciding on a case-by-case basis over issues of design vs efficiency
23:00:34 <arw> pikhq: not only that. the assembler can pick different variants of an opcode, which can have an impact on performance and code size.
23:01:12 <dankna> I can't conceive of how that could be done, chelz.  It's like trying to breed a cat with a dog:  On the surface you can imagine keeping the cat's ears and the dog's tail, but the genetics don't really make that possible.  Pardon my strained analogy. :)
23:02:01 <arw> chelz: there have been attempts at successors to fortran. but all have failed except for (in newer times) C and C++.
23:02:18 <chelz> dankna: yeah. i just don't like the idea of tradeoffs that are impossible to bridge.
23:02:21 <Dashkal> Is there a simple way to do IO with Word8 lists?  Standard binary seems to want Ptrs.  Clostest my research has come up with is by using Data.Array.IO and packing the data into arrays.
23:02:53 <arw> chelz: the other part of fortrans success especially in scientific computing is a huge pile of old but working code and very fast libraries for everything to do with math.
23:02:58 <dankna> Look at it this way.  "Programs are written primarily for people to read and only secondarily for machines to execute."  A program that you can't maintain is worthless, worse than worthless.
23:03:14 <dankna> The increase in readability and expressiveness is well worth the tradeoff.
23:03:17 <chelz> dankna: ah yeah that quote sounds familiar and sums it up nicely
23:03:20 <dankna> yeah :)
23:03:30 <dankna> I forget the guy's name, haha, but google should turn it up if you care
23:04:07 <arw> yes, but always think of cobol when mentioning that sentence.
23:04:19 <chelz> but that leads me to wonder if readability and efficiency are mutually exclusive and what could be done if a processor was designed with something like haskell in mind
23:04:26 <chelz> haha
23:04:30 <dankna> arw: interesting point, haha
23:04:35 <pikhq> arw: COBOL makes it harder for both to read, really.
23:04:40 <pikhq> Well, aids beginners.
23:04:43 <pikhq> Impedes competent programmers.
23:04:59 <pikhq> "ADD 1 TO FOO GIVING BAR" is just more mental work than "bar=foo+1"
23:05:19 <dankna> could be worse.  could be AppleTalk.
23:05:27 * pikhq shudders
23:05:40 <dankna> where you have to spend ten minutes with the manual to figure out which preposition to use, every time.
23:05:43 <chelz> ah yeah, locking users into a simple porcelain that ignores the capacity for learning
23:06:11 <arw> yes. but my grandmother can "read" it like a newspaper.
23:06:19 <dankna> yes.  it's a read-only language :D
23:06:24 <arw> readability isn't everything, writability is as important.
23:06:36 <arw> and there are more aspects a language should have.
23:06:46 <arw> like a lack of "dangerous" constructs.
23:06:54 <dankna> and I guess APL is the classic example of a write-only language, though I'm not so unfortunate as to be familiar with it.
23:06:59 <dankna> so both are possible and bad.
23:07:11 <mtnviewmark> chelz - I don't know about processor support for Haskell - but in the 80s there was lots of work on supporting Object Oriented languages (Smalltalk in particular) in CPU design -- turned out that it was the wrong approach -- Smalltalk could be implemented faster on a RISC machine than on a Smalltalk specific processor
23:07:11 <pikhq> dankna: APL is more readable than you'd think.
23:07:18 <dankna> is it?  well, I'm happy to hear that, of course.
23:07:20 <mtnviewmark> (see Ungar's PhD thesis)
23:07:38 <pikhq> dankna: Just single characters instead of keywords, really.
23:07:40 <chelz> mtnviewmark: thanks for the reference, looking that up now
23:07:44 <pikhq> Bit of a nasty learning curve, though.
23:07:44 <dankna> gotcha.  fair.
23:07:54 <arw> mtnviewmark: there were also lisp-machines, which even had types built into the cpu.
23:08:53 <pikhq> mtnviewmark: The one thing I can think of that would help Smalltalk in a CPU is garbage collection.
23:08:54 <mtnviewmark> That is true - though they came from an earlier era --- the Ungar thesis was about realizing that RISC was SO much better for HW that it out weighed the language specific features
23:09:12 <pikhq> Everything else is already about as fast as can reasonably be expected.
23:09:14 <mtnviewmark> well, you can'd do GC in the processor, but you can have processor support for it: notably a write barrier
23:09:23 <pikhq> Yuh.
23:09:26 <c_wraith> so where'd all the RISC machines go?  The PS3, and custom supercomputers?
23:09:39 <dankna> well, we already have write barriers, they're how segfaults happen.  and paging.
23:09:39 <pikhq> c_wraith: You have a RISC machine, I guarantee it.
23:09:43 <mtnviewmark> indeed, that is essentially Ungar's work --- just add a write barrier to RISC and be done!
23:10:01 <mtnviewmark> where do they go?!?!? They're EVERYWHERE
23:10:28 <mtnviewmark> the just are buried inside your CPU!
23:10:29 <arw> hm. even current x86 are secretly RISC on the inside ;)
23:10:29 <c_wraith> I mean RISC ISAs, not just RISC cores
23:10:39 <pikhq> Oh.
23:10:47 <pikhq> That's "everything that's not x86".
23:10:57 <dankna> yeah, heh.  x86 is the oddball, as someone or other said.
23:10:58 <pikhq> So, most every embedded device.
23:11:08 <pikhq> (modulo the occasional z80)
23:11:14 <arw> pikhq: not quite, there are some CISC cpus other than x86 in common use.
23:11:28 <pikhq> arw: z80 and... What others?
23:12:14 <arw> pikhq: m68k for example.
23:12:26 <pikhq> Oh, m68k is still in use?
23:12:27 <arw> pikhq: they are still widely used in embedded stuff.
23:12:29 <pikhq> Didn't realise.
23:12:36 <pikhq> I thought that most of that had switched to ARM.
23:12:56 <pikhq> Point taken.
23:13:03 <arw> usually depends on which cpu is 2ct cheaper at the moment.
23:16:21 <chelz> http://alarmingdevelopment.org/?p=79 - interesting commentary on the concept of "beautiful code". only about 2 pages.
23:18:04 <dankna> read that.  interesting indeed.
23:18:17 <dankna> I prefer to remain optimistic, but he's basically right that complexity usually defeats us in the end.
23:18:59 <chelz> i take solace in the perhaps naieve belief that something having complexity doesn't necessarily mean it's complicated
23:19:41 <dankna> that's a point as well
23:20:30 <pikhq> chelz: That is half the idea behind abstraction.
23:20:43 <pikhq> It lets complex things not be complicated.
23:21:44 <chelz> ah, good observation
23:57:30 <bastl> the haskell' wiki has some errors: http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions and also a number of [query:?status= ... ] things that should probably be links ...
23:59:09 <c_wraith> wow.  that's broken beyond my knowledge of the wiki
23:59:17 <c_wraith> I just have an account there. :)
23:59:32 <c_wraith> oh, wait.  that's haskell'.  I don't even have an account on that one
