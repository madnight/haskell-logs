00:00:21 <JoshTriplett> Well, in any case, figuring out with the channels help that I just rediscovered catamorphisms, and now understand what they mean, made my day.  Thanks all. :)
00:00:25 <JoshTriplett> *channel's
00:00:43 <edwardk> now, you just need to figure out anamorphisms ;)
00:01:09 <edwardk> @type unfoldr
00:01:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:01:35 <JoshTriplett> edwardk: I actually understand unfoldr pretty well.
00:01:49 <JoshTriplett> edwardk: And now that I know it represents a pattern, I think I can come up with what that pattern means.
00:01:57 <edwardk> cata :: Functor f => (f a -> a) -> Mu f -> a
00:01:59 <copumpkin> it's very very closely related to foldr :)
00:02:00 <JoshTriplett> edwardk: Nothing and Just a correspond to nil and cons.
00:02:04 <edwardk> ana :: Functor f => (a -> f a) -> a -> Mu f
00:02:49 <edwardk> technically Nu f
00:03:00 <JoshTriplett> edwardk: So, if I had a type BiList a b = Cons1 a | Cons2 b, then I could have biunfoldr based on Either a b?
00:03:02 <edwardk> but those are the same in haskell
00:03:03 <copumpkin> edwardk: those two feel so much more "fundamental" than the other *morphisms, somehow
00:03:21 <edwardk> copumpkin: well, hylo
00:03:47 <edwardk> beyond hylo they are all special cases
00:04:01 <copumpkin> well,
00:04:14 <copumpkin> hylo can be made up of the other two, or the other two can be special cases of hylo
00:04:44 <edwardk> yes and no, hylo is arguably the more primitive concept. composing cata and ana to yield hylo involves 'two passes'
00:04:48 <JoshTriplett> @info Mu
00:04:48 <lambdabot> Mu
00:04:57 <JoshTriplett> How very Zen, lambdabot.
00:04:57 <copumpkin> edwardk: that makes sense, I guess
00:05:00 <copumpkin> JoshTriplett: fix on types
00:05:02 <edwardk> newtype Mu f = In f { out :: f (Mu f) }
00:05:11 <copumpkin> @info does nothing at all beyond return what you asked it :)
00:05:12 <lambdabot> Unbalanced parentheses
00:05:15 <copumpkin> @info does nothing at all beyond return what you asked it
00:05:15 <lambdabot> does nothing at all beyond return what you asked it
00:05:16 <JoshTriplett> Oh, of course, naturally. :)
00:05:28 * JoshTriplett tries to figure out Mu.
00:05:37 <copumpkin> JoshTriplett: there's noise in the haskell definition of Mu
00:05:47 <aavogt> @info do is actually; @undo <- a; hah
00:05:48 <lambdabot>  Parse error at "@undo" (column 17)
00:05:53 <edwardk> given the definition of Mu, figuring out the definition for cata is also interesting.
00:05:55 <aavogt> @info do is actually; undo
00:05:55 <lambdabot> is actually >> undo
00:06:00 <copumpkin> :)
00:06:01 <copumpkin> nice
00:06:10 <edwardk> hylo f g = f . fmap (hylo f g) . g
00:06:13 <copumpkin> data ListF a b = [] | (a, b)
00:06:14 <shapr> yow!
00:06:20 <MissPiggy> hylo hylo it's off to work we go
00:06:26 <copumpkin> (assuming that were valid syntax)
00:06:28 <shapr> hylo everybody!
00:06:33 <copumpkin> hylo to you too :)
00:06:37 <MissPiggy> hylo shaprmorphism
00:06:37 * shapr grins
00:06:39 <shapr> haha
00:06:58 <dolio> @yow!
00:06:58 <lambdabot> Couldn't find fortune file
00:07:05 <copumpkin> sad, isn't it
00:07:09 <dolio> Man, it always gives the same one these days.
00:07:18 <edwardk> dolio: hahaha
00:07:27 <shapr> haha
00:07:58 <shapr> I WON'T be home for CHRISTMAS!
00:08:53 <edwardk> shapr has hit the @yow button so many times that he can just replay some of his favorites whenever you need one
00:09:13 <aavogt> @arr
00:09:13 <lambdabot> Yeh scurvy dog...
00:09:14 <shapr> Actually, I make 'em up on the spot.
00:09:44 <shapr> That guy at lunch made BRAIN COOKIES!
00:10:11 <shapr> Except I always leave out any political commentary as well as any category theory.
00:10:46 <copumpkin> damn, what's left?
00:11:15 <shapr> :-P
00:11:20 <edwardk> shapr: i think that would practically render me mute
00:11:42 <shapr> edwardk: I don't think so. You would talk about demoscene graphics.
00:11:49 <JoshTriplett> YOW!  Somebody spilled VENN DIAGRAMS on my PAPERS!
00:11:55 <edwardk> shapr: and /r/fitness ;)
00:12:12 <shapr> edwardk: I thought that was a logical extension of your actuarial training?
00:12:40 <edwardk> looking at the actuarial tables was incredibly motivating in that regard ;)
00:13:08 <aavogt> actual actual table
00:13:20 <shapr> JoshTriplett: I give you a solid B+ on that one. But then, I usually give myself an F+ for mine.
00:13:40 <JoshTriplett> shapr: Considering I've never tried to make one up before, I'll take it. :)
00:13:57 <krainboltgreene> Haskell seems to be getting more popular on HN.
00:14:05 <shapr> Haskell News?
00:14:13 <copumpkin> hacker news
00:14:17 <copumpkin> (I'm guessing)
00:14:21 <shapr> Wishful thinking :-)
00:14:22 <dolio> Sure you are.
00:14:25 <krainboltgreene> Yeah, Hacker News.
00:15:00 <krainboltgreene> If Haskell *wasn't* popular on Haskell News I'd be worried.
00:15:20 * copumpkin got rewarded for his trolling on reddit today, despite MissPiggy disapproving
00:15:43 <krainboltgreene> I can't stand Reddit's design.
00:15:52 <MissPiggy> copumkin, rewarded how?
00:15:52 <dolio> Rewarded?
00:16:01 <Adamant> dolio: fish.
00:16:05 <copumpkin> with a few karma points, even though I was expecting to lose several
00:16:07 <Adamant> on the line.
00:16:09 <Adamant> ah
00:16:12 <MissPiggy> by the way I don't think you were trolling more like falling for the guys trap :|
00:16:19 <MissPiggy> and wtf is a karma point
00:16:25 <copumpkin> somehow a bunch of haskell zealots decided I needed upvotes
00:16:36 <copumpkin> MissPiggy: I called him out on it first thing in the thread, and then decided "what the hell, I'll bite"
00:16:40 <dolio> @karma+ dolio
00:16:40 <lambdabot> You can't change your own karma, silly.
00:16:47 <copumpkin> @karma+ dolio
00:16:47 <lambdabot> dolio's karma raised to 7.
00:17:02 <copumpkin> sadly, lambdabot seems rather exploitable
00:17:28 <dolio> I'm surprised I have that much.
00:17:36 <copumpkin> @karma copumpkin
00:17:36 <lambdabot> You have a karma of 6
00:17:39 <copumpkin> wow
00:17:44 <copumpkin> something must be wrong
00:17:45 <dolio> @karma dons
00:17:45 <lambdabot> dons has a karma of 11
00:17:55 <krainboltgreene> @karma krainboltgreene
00:17:56 <lambdabot> You have a karma of 0
00:17:58 <copumpkin> @karma oleg
00:17:58 <lambdabot> oleg has a karma of 7
00:18:00 <aavogt> @karma Cale
00:18:00 <lambdabot> Cale has a karma of 27
00:18:04 <copumpkin> holy crap
00:18:09 <Adamant> I'm pretty sure reddit language zealotry wars are an advance over rioting over what chariot team won, but I'm not sure by how much.
00:18:12 * MissPiggy still thinks that wasn't a win
00:18:26 <copumpkin> MissPiggy: me bitching on reddit?
00:18:30 <copumpkin> yeah, I agree
00:18:44 <dolio> You don't riot over a certain team winning. You riot regardless.
00:19:03 <Adamant> dolio: I don't think they rolled that way in Byzantium
00:19:07 <Adamant> but I could be wrong.
00:19:18 <krainboltgreene> I was contemplating a KP system where in over time the users score strolls back to 0.
00:19:25 <dolio> That's what I hear about Ohio State, at least.
00:20:01 <aavogt> krainboltgreene: this has already be done with \bot
00:20:02 <Adamant> dolio: possible. but American sport riots tend to happen when someone wins, and it's usually by the winning side.
00:20:26 <copumpkin> wow, I sure am slow
00:20:34 <copumpkin> after over a year in here, I finally got the \bot thing
00:20:36 <krainboltgreene> aavogt: I wasn't suggesting that it was a new idea.
00:20:49 <aavogt> though it happens in sudden jumps ;)
00:21:03 <copumpkin> aavogt: you mean when lambdabot loses its state randomly? :P
00:21:25 <copumpkin> I'd prefer something a bit smoother
00:21:36 <aavogt> copumpkin: so people are supposed to write `\bot ->'?
00:22:25 <aavogt> that would make it harder to miss
00:22:37 <alex404> Does anyone know why ghc-paths is telling me it depends on haddock and won't compile?
00:22:49 <krainboltgreene> Every 10 hrs, -1 or +1.
00:23:26 <aavogt> karma should be stored as CReals
00:25:16 <krainboltgreene> I was thinking about giving Haskell another shot when I saw this cool "Make a GUI text editor in Haskell" post.
00:28:09 <aavogt> which article? I have doubts that such is the best way to learn haskell because the gui libraries are pretty well all direct translations of whatever original library the binding is made from
00:28:14 <dons> krainboltgreene: cool
00:28:18 <dons> the wx tutorial
00:28:30 <krainboltgreene> Yeah, I think it was the Wx Tutorial.
00:28:31 <dons> http://wewantarock.wordpress.com/2010/01/31/building-a-text-editor-part-1/
00:29:21 <krainboltgreene> Every once in a while Ruby frustrates the hell out of me. Amusingly, this time it was the state of GUI libs in Ruby. Saw the article, went "well hello!"
00:30:28 <dons> hehe
00:30:41 <dons> cool cats. wx and gtk2hs are pretty nice
00:30:53 <copumpkin> something like shoes in haskell would be nice
00:30:57 <copumpkin> for simple GUIs
00:31:09 <dons> both our main gui libs are >10 years old too. kinda amazing
00:32:22 <dons> http://tryhaskell.org is turning out super awesome
00:32:47 <krainboltgreene> I very much enjoyed Shoes. Without _why though it's a chicken without a head.
00:33:30 <Zao> Don't forget Win32 :P
00:34:10 <copumpkin> krainboltgreene: I agree
00:34:17 <MissPiggy> what's _why?
00:34:25 <dons> MissPiggy: hehe
00:34:28 <copumpkin> MissPiggy: a prominent figure in the ruby community who disappeared recently
00:34:37 <dons> 2010. no one knows who _why is
00:34:42 <copumpkin> he got rid of his entire internet presence
00:34:46 <krainboltgreene> _why the lucky stiff.
00:34:48 <dons> as if he never existed
00:35:00 <krainboltgreene> He was a guitarist, I have one of his CDs.
00:35:05 <copumpkin> it's an obscure passage out of an ayn rand book, apparently
00:35:07 <MissPiggy> why is it a chicken without a head?
00:35:08 <copumpkin> but I haven't read it
00:35:32 <copumpkin> MissPiggy: _why's guide to ruby was the inspiration for LYAH I think
00:35:35 <krainboltgreene> MissPiggy: Because _why is an incredibly gifted person. Think WillyWonka, or Bonus500.
00:35:58 <krainboltgreene> Er, Willy Wonka, the fictional chocolate factory owner.
00:36:23 <dons> MissPiggy: the  main author and cheerleader left.
00:44:49 <krainboltgreene> So there are no modern GUI libs for Haskell?
00:45:44 <kynky> qt, wx, gtk
00:46:13 <kynky> gtk2hs works fine in 6.12.1
00:46:40 <krainboltgreene> Are they easy to use/read?
00:46:51 <kynky> yep
00:47:24 <kynky> gtk2hs seems well documentedalso with examples on google too
00:47:35 <krainboltgreene> I'll have to check it out.
00:48:27 <kynky> becauseof nature of gtk, u could rob follow a python/ruby/c++ example/tutorial and apply it to haskell in regards to gtk
00:48:42 <kynky> rob=prob
00:48:43 <Zao> *cough* "you"
00:48:51 <Zao> "probably"
00:49:15 <kynky> spelling police :)
00:49:17 <krainboltgreene> I'm not ESL, I understood what he meant ;)
00:49:37 <Zao> It annoys me greatly when people who seem otherwise competent intentionally are "lazy" and can't be arsed making an effort.
00:49:45 <Zao> Not that typing should be effortful anyway.
00:49:52 <copumpkin> one would hope
00:50:00 * copumpkin types with one finger
00:51:06 <Zao> Especially in formal correspondence.
00:51:14 <luqui> Zao, like in this chat room
00:51:15 <luqui> er....
00:51:16 <kynky> well its not my intention to annoy, but at least giving an answer to a question even if it is slightly gramatically wrong, is better than no answer at all.
00:51:31 <Zao> Not that IRC is overly formal.
00:51:42 <Zao> Pet peeve.
00:51:44 <copumpkin> Some people on it are.
00:51:52 <copumpkin> They always type in full sentences with periods at the end of each message.
00:52:21 <Jafet> Be careful Zao, "lazy" might sound like a compliment around here
00:52:25 <copumpkin> I am not one of those people.
00:52:32 <krainboltgreene> Back to reading LYAH.
00:52:32 <kynky> So lol should be LOL or should i always type Laugh Out Loud ?
00:52:41 <krainboltgreene> I really need to update LYAR
00:52:45 <kynky> Jafet, lol
00:52:45 <Zao> None of the above, preferably :)
00:52:49 <copumpkin> kynky: "I am currently laughing out loud"
00:53:05 <copumpkin> With a period, if that's all you have to say.
00:53:12 <Zao> Jafet: Good point.
00:53:15 <krainboltgreene> I laugh silently.
00:53:34 <krainboltgreene> L
00:55:00 <luqui> copumpkin, sometimes it is helpful to switch into that mode though.
00:55:30 <luqui> If you're talking about something tricky and having a hard time achieving clarity, forcing yourself to speak in complete sentences can clear things up.
00:55:40 <copumpkin> oh, definitely
00:55:43 <luqui> See e-prime for even more forced clarity.
00:56:12 <krainboltgreene> There's enhanced clarifty in using "you" over "u"?
00:56:13 <copumpkin> I tend to stick to correct English, but don't feel the need to capitalize the first letter of a sentence or add periods to the end of each message
00:56:32 <copumpkin> krainboltgreene: to people who may not be used to english phonetics, maybe
00:56:39 <luqui> krainboltgreene, no, what I said was not really relevant in the pragmatics of the discussion.  I just wanted to say it :-P
00:56:43 <copumpkin> krainboltgreene: clarity is also a function of not pissing your readership off
00:56:59 <copumpkin> and "u" pisses a lot of people off, so why not avoid it :)
00:57:16 <kynky> well i never really had a problem before with it, even previously in here
00:57:20 <krainboltgreene> If my readership gets pissed off by "u" then they need to see a doctor for blood pressure medication.
00:57:27 <copumpkin> yeah, Zao's just in a bad mood
00:57:50 <Adamant> personal pet peeve - when you use a acronym that has multiple valid meanings with regard to what you are currently talking about as a way to save time, but then you have to expand the acronym anyway :P
00:57:52 <luqui> It's a function of how much you want to communicate to them vs. how much they want to be offended by trivialities.
00:58:02 <Adamant> I have done this myself more than once, sadly.
00:58:16 <copumpkin> Adamant: you mean like TAEWF?
00:58:22 <Zao> copumpkin: I may have been damaged by playing MMOs excessively too.
00:58:30 <krainboltgreene> Where in the world is Richter?
00:58:32 <Zao> copumpkin: Did you know that people abbreviate both "yes" and "why" with "y"?
00:58:42 <copumpkin> Zao: I did not!
00:58:49 <Zao> Now you do, for better or worse.
00:58:55 <copumpkin> y i do
00:59:09 <copumpkin> y, u don't like it?
00:59:10 <Adamant> copumpkin: unless you are going to say TAEWF a bunch, it doesn't work, because now I have to ask what TAEWF is :P
00:59:25 <copumpkin> Adamant: I haven't a clue :) so no time wasted there
00:59:33 <copumpkin> I guess I wasted time telling you that I didn't have a clue
00:59:35 * copumpkin fails
00:59:37 <Adamant> awesome!
00:59:38 <luqui> copumpkin, y y I do like it in fact!
00:59:47 <kynky> so saying c.h.o. is bad too ?
00:59:58 <Zao> kynky: That's a domain-specific abbreviation.
00:59:59 * MissPiggy decides to abbreviate every word to y, y y y y y y y
01:00:05 <krainboltgreene> Ever have the urge to change the syntax of a programming language?
01:00:13 <Zao> I got rather confused the first time people talked about *.d.o in a Debian context.
01:00:23 <MissPiggy> krainboltgreene - when I use lisp I get that
01:00:26 <Jafet> krainbolt, I tried lisp and the urge went away
01:00:28 <krainboltgreene> Ha.
01:00:32 <copumpkin> Zao: \f -> (\x -> f (x x)) (\x -> f (x x)) were u confused?
01:00:37 <kynky> lol
01:00:37 <MissPiggy> haha I said the opposite of Jafet
01:00:38 <luqui> MissPiggy, of course that can be written y ($ y)
01:00:45 <Zao> copumpkin: :Ã¾
01:00:55 * MissPiggy was talking abuot syntax-macros though
01:00:56 <krainboltgreene> I've always hated "elsif", or "def" in Ruby.
01:01:44 <luqui> and we must be careful when abbreviating "homomorphism"
01:02:07 <copumpkin> luqui: surely not
01:02:08 <aavogt> in for changing syntax here are two things: -XTupleSections (now implemented), and also (notimplemented) a shortcut for   \x -> case x of ...
01:02:15 <MissPiggy> luqui y
01:02:27 * copumpkin is a homeophobe
01:02:27 <luqui> MissPiggy, I'm glad you agree
01:02:33 <MissPiggy> :D
01:02:33 <copumpkin> lol
01:02:34 <krainboltgreene> Whomever invented the capslock key needs a capital punch to the nuts.
01:02:43 <copumpkin> not whom
01:02:45 <MissPiggy> Y?
01:03:01 <MissPiggy> oh man this is too much fun I must be annoying everyone else by now
01:03:02 <copumpkin> (since we're being assholes tonight)
01:03:13 <copumpkin> MissPiggy: omit punctuation though, it makes your intent too clear
01:03:15 * MissPiggy abbreviates whom to who
01:03:18 * copumpkin troll-coaches MissPiggy 
01:03:51 * luqui leaves out who altogether
01:03:54 <silver> haha
01:04:02 <copumpkin> hu?
01:04:10 <krainboltgreene> Hmm. I'm going to tweet that.
01:04:17 <copumpkin> omg twittr
01:04:25 <luqui> it's clear from context.  do you think I am?
01:04:26 <silver> get in the car!
01:04:28 <copumpkin> (notice the omission of the E, as that is more 2.0-compliant)
01:04:48 <aavogt> whr do twts come from?
01:04:58 <copumpkin> I think we should definitely abbreviate the apostrophes out of things, except where they don't belong
01:05:00 <Jafet> "What do you call people who use Twitter?"
01:05:02 <copumpkin> it's -> its
01:05:10 <copumpkin> Jafet: twats
01:05:16 <luqui> copumpkin, and don't forget its inverse!
01:05:19 <copumpkin> (full disclosure: I use twitter, quite a lot)
01:05:21 <luqui> er, don't forget it's inverse!
01:05:21 <Jafet> That's the word for people who have used Twitter
01:05:22 <copumpkin> luqui: certainly
01:05:30 <copumpkin> Jafet: *thats
01:05:36 <luqui> metajoke fail
01:05:44 <copumpkin> :)
01:05:45 <kynky> aavogt, twts are from Roald Dahl ?
01:05:55 <copumpkin> james and the giant twt?
01:06:02 <copumpkin> sounds like fun
01:06:03 <krainboltgreene> I made a command line program for twitter named 'twt'.
01:06:47 <krainboltgreene> Didn't work out like I wanted, because *nix systems are dicks that think ' needs to be closed.
01:06:56 <aavogt> this belongs in -blah... maybe we're scaring off real questions?
01:07:15 <copumpkin> aavogt: its they're problem
01:07:25 <luqui> krainboltgreene, just quadruplicate it
01:07:27 <copumpkin> not our's
01:07:37 <kynky> they are problem, i concur
01:07:48 <krainboltgreene> luqui: What'd you call my mom?
01:07:49 <luqui> $ twt @foo, I don''''t agree
01:08:00 <krainboltgreene> Oh jesus, no.
01:08:03 <aavogt> Im havin trouble's to understand you
01:08:10 <Adamant> Jafet: something less than 140 characters
01:08:15 <krainboltgreene> It's supposed to be easy to use, not difficult!
01:08:18 <luqui> aavogt, repeat "lo"
01:08:23 <luqui> cycle "lo", even
01:08:58 <aavogt> > (cycle "lo",even)
01:08:59 <lambdabot>   ("lolololololololololololololololololololololololololololololololololololol...
01:09:22 * aavogt is surprised actually
01:09:53 <luqui> > even
01:09:54 <lambdabot>   {-3->False;-2->True;-1->False;0->True;1->False;2->True;3->False}
01:10:02 <luqui> functions have show in lambdabot
01:10:10 <MissPiggy> > cycle show
01:10:11 <lambdabot>   Couldn't match expected type `[a]'
01:10:12 <lambdabot>         against inferred type `a1 -> GHC...
01:10:13 <aavogt> complete definition apparently
01:10:25 <Jafet> It's a novel technique called eta sampling
01:10:32 <aavogt> luqui: it's an instance from smallcheck
01:10:33 <copumpkin> fancy that
01:10:40 <MissPiggy> > (\(x::Integer)->undefined)
01:10:41 <lambdabot>   * Exception: Prelude.undefined
01:10:57 <MissPiggy> > (\(x::Integer)->if x==0 then undefined else ())
01:10:58 <lambdabot>   * Exception: Prelude.undefined
01:11:01 <aavogt> > (\(x::Bool) -> const undefined)
01:11:02 <luqui> > show cycle
01:11:02 <lambdabot>   * Exception: Prelude.undefined
01:11:03 <lambdabot>   "* Exception: Prelude.cycle: empty list
01:11:58 <aavogt> these `eta' samplages appear strict
01:12:22 <luqui> > show reverse
01:12:23 <lambdabot>   "{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}"
01:12:35 <luqui> > show show
01:12:36 <lambdabot>   "{()->\"()\"}"
01:13:21 <krainboltgreene> I think I'm going to show off Haskell at the next Hack('Eugene') meeting.
01:13:24 <krainboltgreene> That or Clojure.
01:13:26 <Jafet> > fix show
01:13:27 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
01:13:31 <copumpkin> tryhaskell + thejit + vacuum would be pretty awesome
01:13:46 <copumpkin> > fix (interleave [0..])
01:13:47 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
01:14:33 <aavogt> eugenics hacks?
01:14:36 <luqui> :t interleave
01:14:37 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
01:15:05 <krainboltgreene> aavogt: A Hacker group I started up in Eugene, OR.
01:15:20 <luqui> oh I thought it was code for murder
01:15:35 <krainboltgreene> ...O.o
01:15:59 <Jafet> unsafeMurder
01:16:03 <aavogt> @wn eugene
01:16:05 <lambdabot> *** "Eugene" wn "WordNet (r) 2.0"
01:16:06 <lambdabot> Eugene
01:16:06 <lambdabot>      n 1: Austrian general in the service of the Holy Roman Empire
01:16:06 <lambdabot>           during the War of the Spanish Succession (1663-1736)
01:16:06 <lambdabot>           [syn: {Prince Eugene of Savoy}]
01:16:07 <lambdabot>      2: a city in eastern Oregon on the Willamette River; site of a
01:16:09 <lambdabot>         university
01:16:41 <luqui> in the sense of "be careful with that axe, eugene"
01:17:15 <aavogt> "you better clean that mess from your eugenes"
01:17:25 <c_wraith> I went to school in eugene.
01:18:19 <krainboltgreene> Baby's First Functions in LYAH always gets me so excited for Haskell.
01:19:18 <aavogt> http://learnyouahaskell.com/baby.png
01:19:41 <copumpkin> my favorite is the list monster
01:20:03 <dolio> The caterpillar from super Mario world?
01:20:14 <krainboltgreene> Something about methods inside methods.
01:20:24 <aavogt> would lyah posters etc. sell?
01:21:27 <Jafet> Quite successfully; therefore they must not be made
01:32:11 <luqui> hmm, looking for an elegant way to find the last n elements of a list in O(n) space
01:32:32 <MissPiggy> I don't beleive it is possible!
01:32:52 <MissPiggy> oh wait you said O(n) /space/
01:32:54 <luqui> It's certainly possible in ephemeral land
01:32:58 <luqui> yeah
01:33:07 <MissPiggy> in that caes, then I know how to do it in C
01:33:16 <MissPiggy> but in Haskell I could not tell
01:33:19 <silver> store last element with every element of the list? :)
01:33:20 <luqui> yes but by definition it wouldn't be elegant
01:33:35 <MissPiggy> the GC combined with lazyness makes me have no idea baout space
01:34:22 <Jafet> Use something other than a list
01:34:29 <luqui> Jafet, touche
01:34:35 * MissPiggy was thinking about scanning a cyclic buffer over the list, once you hit the end, cycle the buffer back 
01:34:40 <Jafet> ...that seemed pretty obvious.
01:34:51 <cads> luqui: can you count the list first and then read out the final n elements?
01:34:55 <luqui> but it's a huge lazy list with like 10M elements
01:35:07 <luqui> cads, that will force all 10M into active memory
01:35:11 <MissPiggy> actually that would work fine with a mutable array
01:35:13 <Jafet> Sounds like you want a queue, not a list.
01:36:12 <luqui> Jafet, well I could easily convert to a queue, but how would that help?
01:36:28 <krainboltgreene> Oh oh, who here is a web developer?
01:36:36 <Jafet> It would, uh, solve your problem.
01:36:53 <luqui> Jafet, sorry I don't see it
01:36:54 <Jafet> By definition, you can quickly access the last elements of a queue
01:37:14 <cads> luiqui, you could keep the last n items you read in memory, and read em out when you reach the end
01:37:37 <luqui> cads, yes yes, the question was an elegant (i.e. pretty, pure functional) way
01:37:48 <MissPiggy> luqui OH
01:37:53 <MissPiggy> you wanted an ELEGANT way hahaha
01:37:59 <MissPiggy> yeah forget what I said then
01:38:02 <luqui> :-P
01:38:33 <krainboltgreene> Hmm. Q: In the function defining syntax, it's "[function name] [variables plugged into the function] = [things to do with the variables]"?
01:38:41 * MissPiggy would probably bet on this being impossible
01:38:51 <copumpkin> IMPOSSIBLE!
01:38:54 <luqui> Jafet, I still don't see it.  seems like a queue would use O(length list) space
01:39:00 <copumpkin> NOTHING IS IMPOSSIBLE
01:39:01 <MissPiggy> krainboltgreene: roughly
01:39:06 <MissPiggy> krainboltgreene: that's a good first approximation
01:39:12 <Jafet> Well, you'd use the queue instead of the list.
01:39:17 <copumpkin> luqui: I bet it is possible
01:39:35 <luqui> Jafet, okay, but i *have* a list.  I have no way around having a list.
01:39:46 <luqui> it is a big list of lines that would be printed to the screen.
01:39:47 <copumpkin> in fact, I think I can see how to do it
01:39:51 <Jafet> I don't see any way around having to walk through the list, then.
01:39:59 <luqui> Jafet, O(n) SPACE, not time.
01:40:14 <copumpkin> just build a queue of fixed size n, as you walk over the list
01:40:17 <luqui> obviously O(length list) time
01:40:36 <copumpkin> with every new element, enqueue and dequeue (except for the first n)
01:40:44 <monadic_kid> krainboltgreene: <function-name> <binding/pattern>* = <function-defintion>
01:40:55 <luqui> copumpkin, oh right, and as long as I'm careful with where I force things, that ought to work
01:41:03 <Jafet> drop (length list - n) list ?
01:41:13 <luqui> Jafet, you haven't been paying attention.
01:41:13 <copumpkin> Jafet: that would be two passes though
01:41:26 <copumpkin> luqui: yeah, I think you could phrase it nicely as a fold over it
01:41:40 <copumpkin> fold ([a], [a]) as your queue :P
01:41:44 <Jafet> Well, no one asked for a one-pass...
01:42:00 <luqui> Jafet, I asked for O(n) space... two pass would be O(length list) space
01:42:00 <copumpkin> Jafet: it would force the spine of the list
01:42:14 <MissPiggy> luqui I think jafets way is O(n), isn't it?
01:42:29 <Jafet> copumpkin: I don't see how you could avoid that.
01:42:34 <MissPiggy> > drop 300 (repeat [1..])
01:42:35 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:42:42 <luqui> copumpkin's solution avoids it nicely
01:42:49 <MissPiggy> > drop 300 [1..]
01:42:50 <lambdabot>   [301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,31...
01:42:54 <MissPiggy> ^ doesn't force the list
01:42:57 <copumpkin> Jafet: you do force it, but you don't have to keep the entire thing around
01:43:03 <MissPiggy> > length [1..10000]
01:43:04 <lambdabot>   10000
01:43:09 <MissPiggy> ^ doesn't use O(n) space
01:43:17 <MissPiggy> just the space for one integer
01:43:18 <Jafet> I see. Subtle.
01:43:20 <copumpkin> MissPiggy: it does if you keep it around
01:43:32 <MissPiggy> so I think Jafets way actually does fit the space criteria
01:43:34 <krainboltgreene> So these are the same: http://pastie.org/846566
01:43:38 <luqui> > let x = [1..10000] in x !! length x  -- DOES use O(n) space
01:43:39 <lambdabot>   * Exception: Prelude.(!!): index too large
01:43:42 <dolio> > let lasts n l = f (drop n l) l ; f [] l = l ; f (_:xs) (_:ys) = f xs ys in lasts 10 [1..100]
01:43:43 <lambdabot>   [91,92,93,94,95,96,97,98,99,100]
01:43:44 <luqui> > let x = [1..10000] in x !! (length x-1)  -- DOES use O(n) space
01:43:44 <MissPiggy> but have I have a mistake in me reasoning somewhere?
01:43:45 <lambdabot>   10000
01:43:55 <luqui> > let x = [1..1000000] in x !! (length x-1)  -- DOES use O(n) space
01:43:56 <lambdabot>   1000000
01:44:12 <luqui> > let x = [1..10000000] in x !! (length x-1)  -- DOES use O(n) space
01:44:14 <cads> krainboltgreene: that's correct
01:44:18 <lambdabot>   mueval: ExitFailure 1
01:44:18 <luqui> come on memory limit!
01:44:21 <aavogt> if length was lazy... the two traversals could happen at the same time. This leads to less space needed?
01:44:27 <krainboltgreene> Neato.
01:44:28 <luqui> > let x = [1..10000000] in last x  -- doesn't use O(n) space
01:44:33 <lambdabot>   mueval-core: Time limit exceeded
01:44:38 <cads> krainboltgreene: you could also say   add = (+)
01:44:42 <luqui> except i can't prove it.  ...
01:44:44 <MissPiggy> anyone?
01:44:46 <Jafet> You'd have to control the evaluation order carefully, but it would work.
01:44:50 <copumpkin> MissPiggy: ?
01:45:02 <copumpkin> MissPiggy: it doesn't fit the space criteria
01:45:02 <Jafet> (aavogt)
01:45:02 <MissPiggy> did I make a mistake somewhere in my reasoning
01:45:09 <luqui> aavogt, length could only be lazy if its output were not flat, i.e. like a lazy Nat type.  and yes, in that case, you are correct.
01:45:21 <MissPiggy> why not? To me it seems like it does "It doesn't" doesn't help me understand..
01:45:22 <copumpkin> MissPiggy: if I keep a reference to the list and ask for its length, I evaluate its spine O(length) space
01:45:42 <copumpkin> MissPiggy: I then ask for the last n elements based on that length, I'm keeping the entire list in memory while I do that
01:45:52 <copumpkin> it's not going to GC it because I still have a reference to its head
01:46:04 <MissPiggy> oh I thought the list just existed in the program
01:46:14 <copumpkin> I like dolio's
01:46:14 <jlouis> krainboltgreene: yes, more or less
01:46:22 <MissPiggy> and what you wanted was no intermediate data structures which take up too much space
01:46:50 <dolio> Mine is the same as Jafet's if you use lazy naturals instead of Ints.
01:46:54 <copumpkin> yeah
01:47:00 <copumpkin> you'd need genericLength
01:47:12 <dolio> And genericDrop.
01:47:16 <copumpkin> ah, yes
01:47:21 <copumpkin> is there such a thing?
01:47:22 <copumpkin> :t genericDrop
01:47:25 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
01:47:28 <copumpkin> ah, nice
01:47:42 <dolio> Yes, quite a few generic things.
01:47:51 <dolio> :t genericSplitAt
01:47:52 <lambdabot> forall i b. (Integral i) => i -> [b] -> ([b], [b])
01:48:05 <aavogt> ?ty genericBreak
01:48:06 <lambdabot> Not in scope: `genericBreak'
01:48:32 * aavogt supposes that one shouldn't exist anyways
01:48:40 <krainboltgreene> Is it just me or is LLVM really popular right now, and has an awesome logo?
01:48:44 <copumpkin> fix break
01:48:47 <copumpkin> :t fix break
01:48:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
01:48:48 <lambdabot>       Expected type: a
01:48:48 <lambdabot>       Inferred type: [a]
01:48:56 <aavogt> needs a dot
01:48:59 <Jafet> > fix error
01:48:59 <copumpkin> :t fix . break
01:49:00 <lambdabot>     Couldn't match expected type `[a]'
01:49:01 <lambdabot>            against inferred type `([a], [a])'
01:49:01 <lambdabot>       Expected type: (a -> Bool) -> [a] -> [a]
01:49:01 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
01:49:07 <copumpkin> no worky :(
01:49:10 <copumpkin> seemed witty
01:49:15 <copumpkin> :t break
01:49:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:49:24 <copumpkin> ah, no chance of that without some extra work
01:49:25 <Tarrasch> Hello, is it me or is there an error in the definition for bind (>>=) in this tutorial? : http://www.haskell.org/all_about_monads/html/readermonad.html
01:49:29 <aavogt> :t fix.snd.break
01:49:30 <lambdabot>     Couldn't match expected type `(a1, a -> a)'
01:49:31 <lambdabot>            against inferred type `[a2] -> ([a2], [a2])'
01:49:31 <lambdabot>     Probable cause: `break' is applied to too few arguments
01:49:38 <copumpkin> fix (snd . break)
01:49:42 <copumpkin> not even
01:49:48 <dolio> Oh, that dragon is the LLVM logo?
01:49:51 <copumpkin> yeah
01:49:54 <krainboltgreene> Yep.
01:50:09 <luqui> Tarrasch, i think it's just you
01:50:23 <luqui> Tarrasch, oh wait, you are correct
01:50:45 <luqui> should be Reader $ \e -> runReader (f (r e)) e
01:50:49 <krainboltgreene> More programming things need better logos.
01:50:58 <Tarrasch> Thanks luqui :)
01:52:16 <Tarrasch> Btw. "monoid" has nothing do with monads even though the similiar names, right?
01:52:35 <dolio> No, they are related.
01:52:40 <Cale> Tarrasch: They're related at a sufficient level of abstraction
01:53:32 <dolio> The "mon" in monad comes from monoid.
01:53:54 <dolio> Except that people pronounce the 'o' differently for some reason.
01:53:59 <Tarrasch> well I found it hard to find any tutorial-like explanation of what a monoid is, I just found the wikipedia definition for the mathematical pair of a set and a binary operator
01:54:05 <Cale> They are both examples of monoid-objects -- the usual sort of monoid being a monoid object in the category of sets, and monads being monoid objects in the category of endofunctors on a given category.
01:55:28 <krainboltgreene> Waaait, weird. "conan = 'I am conan'" isn't a variable being set? O.o
01:55:44 <Cale> krainboltgreene: Sort of.
01:55:51 <Cale> krainboltgreene: A constant is being defined.
01:56:03 <monadic_kid> Tarrasch: You're probably just thinking about to much. Thats the problem, they have a fancy name, monoids/monads can be many things so they seem scary but just step and don't think about it much
01:56:10 <Cale> There are variables which actually vary, which are the parameters to functions.
01:56:18 <Cale> f x = x^2
01:56:28 <krainboltgreene> Man, that's so going to mess me up coming from Ruby/Python.
01:56:31 <Cale> for instance, x might be 3 at one point, and 6 at another
01:57:07 <Cale> But so long as a variable remains in scope, its value doesn't change.
01:58:18 <Jafet> That's not valid Haskell, at any rate
01:58:38 <Cale> conan = "I am conan" -- this would be though.
01:59:09 <Cale> (watch the quotes -- single quotes are for character literals)
01:59:18 <krainboltgreene> Erf.
02:02:35 <Cale> krainboltgreene: So when you're implementing an algorithm, and you need "something" to take on different values, it's a good bet that it ought to be a parameter to a function.
02:02:59 <Tarrasch> monadic_kid, I think knowing a little about their relationship is not really digging into details, no?
02:03:36 <Cale> Tarrasch: There are a bunch of definitions you need to be comfortable with before you can properly understand that connection.
02:04:56 <Cale> Tarrasch: But vaguely, with a monoid, you have a set M together with an identity element e in M, which I can alternately specify as a function e: 1 -> M, and a multiplication *: M x M -> M
02:05:14 <monadic_kid> it doesn't really matter, I don't know anything about category theory but I just look at it as a specification/interface and I can implement various asbtractions as long as they adhere to the axioms are satisfied then it's fits the framework
02:05:15 <Cale> and with a monad, you have a functor M: C -> C
02:05:42 <Cale> and a 'unit' which is a natural transformation 1 -> M, which we render as the polymorphic function return :: a -> M a
02:06:11 <monadic_kid> think about it what is so special about monoids really, just 2 generic operations that have to adhere a few rules, many things can fit that.
02:06:21 <Cale> and a 'multiplication' which is a natural transformation M.M -> M, which we render as the polymorphic function join :: M (M a) -> M a
02:06:42 <Cale> So you can see a bit of the similarity there
02:07:09 <Cale> We've replaced the one-element set with the identity functor, and the Cartesian product of sets with composition of functors
02:08:07 <Cale> and the laws work out in parallel too, if you write them down in an appropriate way
02:08:24 <Cale> Does that make any sense?
02:08:43 <Tarrasch> Cale, not entirely :)
02:09:03 <monadic_kid> Tarrasch: Well there was a channel 9 video about monoids and monads that might be useful
02:09:10 <Tarrasch> However I saved what you said to read later when I've got a better grasp of it all
02:09:13 <luqui> For those who were following the "last n" discussion, here is copumpkin suggestion implemented:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23090#a23090
02:09:15 <Cale> That one kind of made me cringe, myself.
02:09:18 <monadic_kid> brian beckman
02:09:21 <Cale> Yeah.
02:09:36 <copumpkin> luqui: seqToList is probably superseded by the Foldable version
02:09:52 <luqui> oh right!
02:10:00 <monadic_kid> Tarrasch: http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
02:10:18 <monadic_kid> Tarrasch: talks about monoids before monads if i remember correctly
02:10:27 <luqui> and it has a lot of error because I transcribed it from ghci without checking!
02:10:41 <Tarrasch> monadic_kid, thanks!
02:10:41 <copumpkin> luqui: looks pretty nice otherwise :) too good for ([a], [a]) as a queue? :P
02:10:54 <copumpkin> luqui: I wonder how its performance compares to dolio's solution
02:11:12 <Cale> Yeah, that Brian Beckman video is one that I seem to recall making me wince. Still, if it helps you, then it helps.
02:11:21 <luqui> I started doing ([a],[a]), but there were too many details, and I thought I already have a perfectly good queue in the libraries
02:11:27 <Cale> I don't exactly recall why though.
02:11:46 <copumpkin> ah
02:11:49 <luqui> oh you mean genericSplitAt with lazy nats?
02:11:58 <luqui> yeah that's interesting
02:12:00 <copumpkin> luqui: the one he implemented in lambdabot before that
02:12:06 <luqui> oh
02:12:23 <copumpkin> > let lasts n l = f (drop n l) l ; f [] l = l ; f (_:xs) (_:ys) = f xs ys in lasts 10 [1..100]
02:12:24 <lambdabot>   [91,92,93,94,95,96,97,98,99,100]
02:12:48 <copumpkin> it's pretty elegant :)
02:12:58 <Cale> Tarrasch: If you want to understand this stuff properly, start by understanding the definition of a category and a functor.
02:13:26 <copumpkin> my queue idea was how I would've answered that question two years ago before I learned haskell. Maybe one day I'll come up with something like this instead :P
02:14:15 <Cale> Tarrasch: I'd give a tutorial, but it's a bit late. :)
02:14:21 <luqui> yeah i missed dolio's suggestion.  it is exactly what i asked for
02:14:23 <copumpkin> omg Cale sleeps?
02:14:32 <luqui> faster than the queue solution too (in interpreted mode at least)
02:14:32 <Cale> Well, it's 5am...
02:14:46 <luqui> Cale, seems like a non sequitur for a hacker...
02:14:56 <copumpkin> luqui: awesome! I imagine it has a lot less overhead, if nothing else
02:15:06 <copumpkin> (memory-wise)
02:15:21 <Tarrasch> Cale, Don't worry, I think I need to just play around with more hello-world samples of monads before understanding the monad-monoid relationship. That can wait for quite some time.
02:15:51 <medfly> he is talking about MATHEMATICS!
02:15:52 <Cale> Tarrasch: Yeah, and you can understand monads as they relate to programming without understanding the general definition of monad.
02:15:54 <Tarrasch> It's just important for me to know at this moment that there is a reason why monad is named with a mon starting
02:16:08 <Vitka> @djinn ParseError -> IO ()
02:16:09 <lambdabot> Error: Undefined type ParseError
02:16:11 <Cale> Tarrasch: Ah, it's a portmanteau of monoid and triad.
02:16:14 <Vitka> eh
02:16:22 <medfly> isn'tmonad a greek word?
02:16:30 <copumpkin> I doubt we'll find @djinn doing things with IO anytime soon :)
02:16:50 <Cale> medfly: There's an older, philosophical usage of the term 'monad', which is etymologically unrelated.
02:17:37 <Cale> There were a bunch of terms used for what we now call a monad, including "triple", "standard construction", "triad", and a few others.
02:18:06 <Vitka> I want to break out of Either returned by parsec. Am I stuck? :P
02:18:15 <copumpkin> ?
02:18:17 <Cale> and there's an "obvious" relationship to the definition of a monoid (obvious if you're a category theorist)
02:18:22 <luqui> Vitka, pattern match on the cases
02:18:49 <luqui> :t \x -> case x of Left a -> (); Right b -> ()
02:18:50 <lambdabot> forall t t1. Either t t1 -> ()
02:18:56 <int-e> @type either
02:18:57 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:19:11 <int-e> (pattern match for people who don't like pattern matches)
02:19:52 <luqui> int-e, when I was first starting to learn, even the "maybe" function scared me, much more comfortable with patterns.  So I (perhaps naively) assume the same of others
02:20:01 <Vitka> I'm trying "either foo print a"... But it looks like I need foo of ParseError -> IO () type.
02:20:17 <int-e> luqui: I think you're right
02:20:22 <luqui> Vitka, print ?
02:20:34 <Vitka> Yes, just for testing.
02:20:34 * int-e couldn't resist the temptation to seed some confusion.
02:20:44 <luqui> I assume ParseError is showable, in which case print :: ParseError -> IO ()
02:20:45 <copumpkin> :)
02:20:57 <Vitka> Uuuuh...
02:21:04 <int-e> eh. sow is the verb.
02:21:13 <krainboltgreene> What's the Haskell equiv to list[1][2]?
02:21:26 <Tarrasch> (list !! 1) !! 2
02:21:27 <Vitka> Hah, thanks.
02:21:29 <Cale> krainboltgreene: you can write list !! 1 !! 2
02:21:34 <krainboltgreene> Oh, neat.
02:21:40 <Cale> krainboltgreene: But the list index operator is something that we avoid.
02:21:43 <Vitka> print worked. :)
02:21:46 <luqui> Vitka, :-)
02:21:50 <Tarrasch> just remember it's not an random-access container.
02:21:52 <Cale> Using the list index operator is admitting defeat.
02:21:53 <krainboltgreene> Cale: Why?
02:21:55 <copumpkin> don't do it
02:22:03 <Tarrasch> Cale, lol
02:22:35 <Cale> krainboltgreene: For one, it's inefficient, secondly, it throws exceptions, and third, it prevents you from finding an elegant solution to your problem which works in a nicely uniform way.
02:23:09 <int-e> iterate f x !! n (there's always an exception if you look long enough)
02:23:12 <Cale> Well, when I say that it's inefficient, I mean that it's as efficient as it could be, but there's nothing better than linear time.
02:23:16 <dolio> The only time you should use !! is when, in an imperative language, you'd write: i = 0 ; while(true) { ... ; if (i == n) break ; ... }
02:23:47 <copumpkin> I'd hope you'd increment i too, occasionally
02:23:55 <monadic_kid> lol
02:23:59 <dolio> That'd be going on in the ...s
02:24:01 <int-e> (the point of that example being that the list is only used as a vehicle for implementing a loop, i.e. as a control structure rather than a data structure)
02:24:30 <Tarrasch> int-e, hmm, never thought of in that way
02:24:42 <krainboltgreene> It seems awkward how the order of haskell goes.
02:25:02 <luqui> dolio, thanks again for that beautiful lasts.  nice jewel in my code now :-)
02:25:03 <copumpkin> krainboltgreene: odd, coming from outside, definitely :)
02:25:09 <monadic_kid> krainboltgreene: basically you don't really want to be working with lists like that, there are times when you really do need an array and haskell has various kind of arrays you can use but you don't need them most of the time.
02:25:41 <Cale> Yeah, if you really need to randomly access a list, it's often better to make an array from it first.
02:25:41 <krainboltgreene> list = [4,3,2,1] ; last list => 1 ; tail list => [3,2,1] ; last tail list => ERROR ; last ( tail list ) => 1
02:25:42 <Tarrasch> krainboltgreene, I bet you can get away with some !! in your first programs you write, but you should avoid it when you're more experienced, I think.
02:25:42 <dolio> luqui: Well, I don't think I came up with that general idea on my own, but you're welcome.
02:26:24 <Cale> krainboltgreene: When you write f x y z, it means ((f x) y) z
02:26:32 <Cale> and last only takes a list parameter
02:26:42 <Cale> (not a function parameter, so you can't pass it tail)
02:26:55 <krainboltgreene> Yeah, I understand why the error is popping up.
02:27:16 <monadic_kid> krainboltgreene: there is a time and place for random accessible structures, haskell list is not random accessible because it's a linked list and therefore is a linear time operation to index but haskell does lots of type of arrays.
02:27:34 <monadic_kid> *does have lots of
02:28:39 <krainboltgreene> I guess it seems odd that it wouldn't do: last (tail list) naturally.
02:28:52 <krainboltgreene> Or maybe I'm just really sleep depped.
02:29:30 <Tarrasch> krainboltgreene, lol, i got pissed at that at first too :p
02:29:31 <luqui> Oooh!  Even better!
02:29:45 <copumpkin> luqui: ?
02:29:51 <luqui> > let lasts n xs = zipWith const (tails xs) (drop n xs) in lasts 5 [1..100]
02:29:52 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:29:56 <luqui> wait...
02:29:59 <luqui> that worked in ghci
02:30:04 <copumpkin> I think something like that would work
02:30:06 <luqui> > let lasts n xs = last $ zipWith const (tails xs) (drop n xs) in lasts 5 [1..100]
02:30:07 <lambdabot>   [95,96,97,98,99,100]
02:30:11 <copumpkin> yeah :)
02:30:27 <krainboltgreene> Haskell seems quite capable of functioning on one line.
02:30:42 <copumpkin> now do it with a scanl!
02:30:51 <luqui> Pascal sure as hell can't procedure on one line
02:31:04 * copumpkin shoots himself
02:31:18 <krainboltgreene> Ruby has me working on multiple lines, so that's going to be another hill.
02:31:20 <monadic_kid> you can diss Pascal but there some good things about Pascal compared to C
02:31:40 <Cale> krainboltgreene: Well, it's mostly because we're on IRC here, and the bot requires it ;)
02:32:02 <copumpkin> I'm glad it is
02:32:10 <luqui> monadic_kid, I only used pascal because of the word "procedure"
02:32:16 <copumpkin> just think what abominations people would come up with if lambdabot allowed multiline entry
02:32:54 <luqui> people already do, we just put it on one long line
02:33:02 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
02:33:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:33:15 <copumpkin> > nubBy (
02:33:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:33:23 <int-e> and there's @let
02:33:26 <copumpkin> onoes, no multiline entry :)
02:33:38 <luqui> haha
02:33:40 <copumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
02:33:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:34:06 <copumpkin> I think Cale's is more mind-bending though
02:34:11 <copumpkin> (a good thing)
02:34:12 <Cale> also more efficient
02:34:33 <Cale> (though still not ideal)
02:34:35 <luqui> nubBy should be called sieve
02:34:49 <copumpkin> I guess that would be a good name for it :)
02:34:51 <Cale> yeah, I hate how it's backwards lately too
02:35:02 <copumpkin> damnslowSieve
02:35:17 <luqui> well, that gives you a chance to rename it then
02:35:29 <luqui> @let sieve = nubBy . flip
02:35:31 <lambdabot>  Defined.
02:35:38 <Cale> nubBy should just be fixed to begin with
02:35:38 <copumpkin> why am I still awake
02:35:42 <int-e> > nubBy (((1 /=) .) . gcd) [2..]
02:35:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:35:59 <copumpkin> we need that multicompose operator
02:36:21 <luqui> which multicompose operator?
02:36:34 <copumpkin> there was talk of it recently on haskell-cafe I think
02:36:38 <copumpkin> can't remember, too sleepy :P
02:36:41 <int-e> f .: g = \x y -> f (g x y)
02:36:49 <copumpkin> nah, not that one
02:36:56 <monadic_kid> is there way to find out what a type alias aliases in ghci?
02:37:02 <MissPiggy> (.:) = (.) . (.)
02:37:14 <luqui> so cute
02:37:20 <int-e>  = (.)(.)(.)
02:37:21 <MissPiggy> ?
02:37:24 <Cale> monadic_kid: :info
02:37:30 <Cale> ghci> :info FilePath
02:37:31 <Cale> type FilePath = String 	-- Defined in GHC.IOBase
02:37:31 <monadic_kid> danke
02:37:31 * copumpkin awaits the inevitable comment about female anatomy
02:37:38 <int-e> @type fmap fmap fmap
02:37:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
02:37:43 <Tarrasch> is there any easy explanation to what (m -> s) means in this context?: class MonadState m s | m -> s where  ...
02:37:46 <krainboltgreene> Haha.
02:37:54 <copumpkin> Tarrasch: functional dependency
02:37:59 <krainboltgreene> I saw that as: int-e: @type fap fap fap
02:38:07 <Cale> Tarrasch: It's a functional dependency. It means that m uniquely determines s
02:38:07 <copumpkin> Tarrasch: it means that for any given value of m, there is a fixed value of s
02:38:16 <int-e> > fmap fmap fmap (+) (-) 1 2 3
02:38:17 * MissPiggy guesses #haskell starts to loop after a while
02:38:17 <lambdabot>   2
02:38:23 <copumpkin> MissPiggy: indeed
02:38:27 <int-e> > fmap fmap fmap (+) (-) x y z
02:38:28 <lambdabot>   x - y + z
02:38:42 <luqui> #haskell = cycle xs for some xs?
02:38:43 * copumpkin goes to sleep
02:39:24 <mreh> interesting problem, I'm using MonadRandom getRandomR, but I don't want to generate numbers at the boundaries of the range
02:39:27 <luqui> night
02:40:00 <luqui> mreh, doing this with Doubles?
02:40:10 <Tarrasch> Thanks, I've not entirely understood why it must be so in the case of MonadState but a I got a vague feeling, that'll do for now ...
02:40:28 <mreh> I've written a generic fitness function that takes a population and a fitness value 'Random a => a' for each
02:40:37 <mreh> luqui: was just getting to that
02:40:49 <mreh> I suppose I could map them all to doubles...
02:41:35 <mreh> anyway, I stick the whole fitness landscape in a roulette wheel, and when they fitness function uses integers, it invariable crashes the program when it access the n+1 element, which isn't there
02:41:37 <luqui> map *from* doubles.  [0,1) -> a  is a nice rep of a probability distribution
02:41:58 <mreh> luqui: I don't understand
02:42:08 <luqui> oh it doesn't seem to apply to your problem
02:42:08 <mreh> [0,1) is what I would like
02:42:38 <luqui> well you can generate [0,1] and filter off the 1
02:42:46 <luqui> generate another if you get 1
02:42:50 <mreh> [ <- inclusive, ) <- exclusive?
02:42:58 <Cale> yeah
02:42:59 <luqui> oh yeah, sry
02:43:07 <mreh> luqui: yeah... I could just do that
02:43:34 <MissPiggy> () open  [] closed
02:44:19 <cads> mmm, llvm looks tasty http://kinoko.c.u-tokyo.ac.jp/~duraid/llvm-breakfast.jpg
02:44:26 <mreh> use getRandomRs
02:45:09 <luqui> > dropWhile (== 1) (getRandomRs (mkStdGen 42))
02:45:10 <lambdabot>   Couldn't match expected type `(a, a)'
02:45:11 <lambdabot>         against inferred type `System...
02:45:25 <luqui> > head . dropWhile (== 1) . getRandomRs (0,1) $ mkStdGen 42
02:45:26 <lambdabot>   No instance for (Control.Monad.Random.Class.MonadRandom
02:45:26 <lambdabot>                    ...
02:45:32 <luqui> > head . dropWhile (== 1) . randomRs (0,1) $ mkStdGen 42
02:45:34 <lambdabot>   0
02:46:57 <mreh> that'll just make zeroes :)
02:47:00 <mreh> but I get the idea
02:47:02 <dolio> > map (fst . randomR (0,1) . mkStdGen) [1..]
02:47:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:47:19 <mreh> newStdGen maybe?
02:47:29 <dolio> newStdGen is an IO action.
02:47:29 <mreh> that forks a new gen a seeds it using the old one
02:47:54 <mreh> oh, mkStdGen isnt?!
02:47:59 <mreh> whaa?!
02:48:01 <dolio> > dropWhile (==1) $ map (fst . randomR (0,1) . mkStdGen) [1..]
02:48:02 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
02:48:07 <luqui> Ever since I started hanging out on IRC, I was never sure how to pronounce #.  But now it is clear, #perl is "pound perl" and #haskell is "hash haskell"
02:48:29 <luqui> :t mkStdGen
02:48:29 <MissPiggy> and #scala is sharp scala
02:48:33 <lambdabot> Int -> StdGen
02:48:40 <mreh> it's alright, I'm going it in MonadRandom
02:48:47 <mreh> or "Rand"
02:48:58 <mreh> RandomGen => Rand g, pardon
02:49:18 <luqui> Yep, that's the way to do it
02:49:32 <luqui> System.Random is a low level interface, purely for the purpose of implementing that monad :-)
02:49:51 <progo> luqui, I pronounce it "risuaita", literally twig fence
02:50:02 <luqui> I wish Rand were less strict though.  not sure that's possible.
02:51:07 <progo> I've always wondered how mappings like x -> rand can be functional. The results are hardly unique
02:51:32 <progo> * x |-> rand
02:51:36 <luqui> progo, did you get your answer?
02:52:08 <progo> luqui, no :)
02:52:39 <luqui> the view from 10,000 feet is that we define a type Rand a, which denotes a probability distribution of a's
02:52:55 <luqui> then such a function has type, eg.  Int -> Rand Int instead of just Int -> Int
02:53:20 <luqui> and Rand a needs some extra input before it will give you an actual a back, like a random seed or some IO state or something
02:53:29 <progo> I see.
02:54:00 <luqui> lucky us, probability distributions are monads :-)
02:54:36 <luqui> (er I guess "probability distributions form a monad")
02:54:41 <progo> It certainly helps a lot.
02:55:11 <mreh> is my cat a monad?
02:55:22 <silver> you bet
02:55:40 <mreh> this might be messy
02:55:41 <luqui> it's at least a category
02:55:46 <mreh> OOOOOOOOOOOOH
02:55:53 <mreh> awful
02:56:36 <luqui> and with that, it is bedtime  %-)
02:57:16 <mreh> (no cats were harmed, I don't have a cat)
03:03:33 <pao> Hi all, I suspect association list could perform better for small maps with respect to Data.Map ... is that reasonable?
03:04:45 <dolio> It's conceivable.
03:05:27 <mreh> with Data.MemoCombinators, is it true that I must re-evaluated the memoised values when the thing disappears off the call stack?
03:05:44 <c_wraith> yes.
03:05:56 <mreh> right, that would follow from Haskell being purely functional
03:06:03 <dolio> What's a call stack?
03:06:17 <Cale> There is no call stack
03:06:26 <c_wraith> well, it follows from the garbage collector.  Once there's no reference to the memo table, the GC collects it
03:06:35 <Cale> yeah
03:06:36 <mreh> graphs, callstack
03:06:38 <dolio> Cale: I think my version was more clever. :)
03:06:41 <mreh> its all the same to me
03:06:49 <pao> dolio: my map size is bounded to 20/30 elements... I guess there's no need to use Maps... I'll do some benchmarking
03:07:30 <mreh> can I unsafePerformIO If I really really really don't want that to be garbage collected?
03:07:54 <dolio> pao: That's the only way you'll know for sure.
03:08:11 <c_wraith> Or you can figure out another way to structure the program so the memo table stays around between function calls.
03:08:13 <Cale> mreh: There is a stack in use in the way GHC evaluates things, but it's used essentially to hold the case expressions which are waiting for their scrutinee to be evaluated enough so that they can pattern match
03:08:24 <mreh> c_wraith: I was thinking that at first
03:08:46 <Cale> You can just put the memo table at the top level
03:08:53 <Cale> define it as a constant
03:09:13 <Cale> and it'll never be GC'd as long as there's a reference to it
03:09:26 <mreh> Cale: it's a functional value though, the problem is when it is dereferenced
03:09:33 <Cale> With Data.MemoCombinators, this is the natural way to do things
03:09:34 <mreh> it needs recomputation
03:09:39 <mreh> okay
03:09:45 <Cale> You should define it without parameters
03:09:47 <mreh> i'll try and figure out how to restructure the program
03:09:53 <Cale> fib = Memo.integral fib'
03:10:22 <Cale> fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2)
03:10:42 <mreh> that can still be garbage collected though, no?
03:10:44 <Cale> Note that fib is nicely a constant.
03:10:58 <Cale> fib will never be garbage collected as long as there's a reference to it
03:11:00 <mreh> and the memo table emptied?
03:11:04 <mreh> okay
03:11:04 <c_wraith> as long as fib is in scope, it won't be collected.  and top-level values are always in scope
03:11:04 <Cale> and so neither will the memo table
03:11:26 <Cale> But if you were to write  fib x = Memo.integral fib'
03:11:34 <Cale> then it's a different story
03:11:46 <mreh> so If I wrote a program using fib, it would have to be passed around
03:12:18 <Cale> mreh: what?
03:12:33 <Cale> mreh: No, just define it at the top level and use it wherever.
03:12:45 <Cale> Oh, you mean with the extra parameter like that?
03:12:46 <Polarina> Is there some function that factorizes two integers?
03:12:53 <mreh> Cale: not really
03:13:47 <MissPiggy> two integers??
03:13:51 <Cale> In the fib x = ... case, only the result of the function will be a memoised function
03:13:52 <Polarina> Yes.
03:13:55 <MissPiggy> why
03:13:55 <mreh> if fib were an auxiliary function used in a fitness function that gets called many times over generations of a GA, the memo table would have to be spared GC between generations
03:14:01 <Polarina> No, factorizes one integer.
03:14:03 <Polarina> Returns two, sorry.
03:14:12 <MissPiggy> oh
03:14:25 <MissPiggy> numbers has one that gives a list of numbers
03:14:27 <mreh> between fitness evaluations even
03:15:05 <mreh> can I use Data.Memocombinators to nest memoized functions?
03:15:17 <Heffalump> I would expect so
03:15:31 <Heffalump> the way they work internally is to use nesting of things like tries
03:15:34 <mreh> does this all take place in a monad?
03:15:43 <Heffalump> they're pure, AFAIK
03:15:50 <Heffalump> they are just a big memory leak (no purging)
03:15:51 <mreh> is it hackery?
03:16:03 <Heffalump> I don't think so. It certainly doesn't *need* to be hackery.
03:16:14 <Heffalump> Consider the standard trick of memoising a function over a known range via a Map.
03:16:32 <Heffalump> or an array
03:16:52 <Heffalump> memocombinators can just use that kind of trick but with some nesting to cover the entire state space without using huge space up front
03:16:57 <mreh> yes, I see, you just wrap it in a pure function
03:17:14 <Heffalump> well, it *is* a pure function
03:17:18 <Heffalump> no unsafePerformIO in sight
03:17:27 <Heffalump> at least, it could be
03:17:39 <c_wraith> It's taking advantage of the language's laziness.  laziness is good!
03:17:54 <mreh> laziness is indeed amazing
03:18:07 <mreh> c_wraith: howso?
03:18:12 <Cale> mreh: The only thing which Data.MemoCombinators relies on is the fact that lazy evaluation ensures that a parameter to a function will not be evaluated more than once.
03:18:30 <c_wraith> using Memo.integral tells it to store the output for *every* input for the program.
03:18:31 <Cale> (Even if it occurs more than once in the body of the function)
03:18:44 <c_wraith> It just happens to only do the calculations on request
03:19:05 <mreh> Cale: you mean the function will not be evaluated more than once for the same parameter
03:19:11 <Cale> mreh: no
03:19:30 <Cale> mreh: Functions *will* be evaluated more than once for the same parameter
03:19:56 <mreh> Cale: doesn't the memo combinator stop that, and just return a cached value?
03:20:13 <Cale> It does, I'm talking about how the library itself works
03:20:32 <Cale> The simplest place to begin understanding it is with the bool function
03:20:35 <Cale> bool :: Memo Bool
03:20:35 <Cale> bool f = cond (f True) (f False)
03:20:35 <Cale>     where
03:20:35 <Cale>     cond t f True  = t
03:20:35 <Cale>     cond t f False = f
03:21:38 <mreh> right, that seems simple enough
03:21:50 <Cale> This memoises a function f of a Bool parameter
03:22:26 <Cale> By using the fact that the parameters to cond, once reduced, will remain reduced.
03:22:54 <Cale> So if we define some function like:
03:22:57 <Cale> g = bool f
03:23:01 <mreh> right, but I thought you meant "if you pass the same redex to the function, it is only evaluated once"
03:23:16 <Cale> then as g is evaluated, it will become  cond (f True) (f False)
03:23:19 <c_wraith> no in general.
03:23:47 <Cale> If you write f 5 + f 5, then f 5 *will* in general be computed twice.
03:24:44 <Cale> So it takes at least a little cleverness to see how to do memoisation without doing low-level hackery and mutation.
03:25:04 <mreh> I understand
03:25:41 <Cale> But essentially, it's that as g gets used there, its definition effectively evolves as bits get evaluated.
03:26:21 <Cale> Until the memo table is fully computed and it looks like g = cond 23 42  (or whatever the results of that f function were as applied to True and False)
03:26:23 <mreh> that defintion of bool confused me at first because of the f shadowing the other f
03:26:34 <mreh> Cale: uhuh
03:26:36 <Cale> oh, yeah, that's confusing and unfortunate
03:26:39 * monadic_kid <3 vbox
03:26:52 <Cale> list :: Memo a -> Memo [a]
03:26:52 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
03:26:52 <Cale>     where
03:26:52 <Cale>     table nil cons [] = nil
03:26:52 <Cale>     table nil cons (x:xs) = cons x xs
03:27:25 <Cale> ^^ this pulls a similar trick, but somewhat more complicated as it's memoising recursively
03:27:55 <Cale> You get a nice implicit tree in the structure of the resulting function
03:28:13 <Cale> and with bool and list then, you can memoise functions of sequences of bits
03:28:27 <Cale> and so those can be exploited to memoise more arbitrary data
03:29:33 <mreh> Cale: well I'm evaluating just that, sequence of boolean values
03:29:40 <mreh> that's handy
03:30:15 <mreh> Cale++
03:31:16 <Cale> The integral memoiser works by converting the numbers involved into lists of bits
03:31:47 <Cale> There's a bit of overhead involved in that, but it's a lot cheaper than computing most functions you'd care to memoise
03:33:26 <Cale> and if that's not good enough, there's the array memoisers, which use a constant array to memoise a finite range of values with constant time access
03:34:03 <mreh> is that generic? does it have a Map layer of indirection?
03:34:12 <Cale> (I felt like putting quotes around that "constant time", because memory accesses couldn't really be constant time as the amount of memory in your system grows without bound, but that's being picky)
03:34:23 <Cale> It's using Array
03:34:39 <Cale> So you can use anything which is an instance of Ix
03:34:47 <mreh> oh.
03:35:22 <Cale> You can also use the switch combinator to switch between an array for values in a particular range, and, say, the integral memoiser outside that range
03:38:15 <mreh> thanks Cale
03:38:21 <Cale> no problem
03:42:51 <Polarina> What is a good way to throw my own exception?
03:43:35 <Axman6> make something an instance of Exception i think
03:43:57 <Polarina> Do you happen to have an example?
03:43:59 <mreh> Polarina: do you want to know how to throw exceptions?
03:44:02 <Cale> yeah, you don't even have to provide methods
03:44:04 <mreh> or make your own?
03:44:13 <Cale> Just make sure to derive Typeable
03:44:17 <Cale> and then you can write
03:44:24 <Axman6> Cale: instance Exception Foo where?
03:44:30 <Axman6> ah
03:44:30 <Cale> instance Exception MyException
03:45:03 <Polarina> mreh, yes.
03:45:04 <Cale> (you can leave off the 'where' even, since you're not filling in any methods, the defaults will use the Typeable instance)
03:49:42 <mreh> Cale: so the "list" memo just maps the function to the list, in effect
03:52:17 <Cale> mreh: It uses a memoiser for each element of the list -- there's a sort of implicit tree in the resulting function structure
03:55:03 <Cale> (the tree is potentially infinite, as the lists can be arbitrarily long)
03:55:04 <asdf_> why we cannot use unboxed datatype in data, instead of only using it via newtype declaration?
03:56:11 <Axman6> eh?
03:56:39 <Cale> I'm pretty sure you can use unboxed types in data declarations
03:56:52 <Cale> after all, Integer does
03:57:12 <Cale> data Integer
03:57:13 <Cale>   = GHC.Integer.Internals.S# GHC.Prim.Int#
03:57:13 <Cale>   | GHC.Integer.Internals.J# GHC.Prim.Int# GHC.Prim.ByteArray#
03:57:15 <asdf_> Cale: Are you sure? I just read it on GHC User guide.
03:57:31 <Cale> asdf_: Where did you read it?
03:57:45 <Cale> You can't use data to *define* unboxed types, of course.
03:58:53 <Cale> There are only a few primitive unboxed types, and they're treated specially. Newtypes of them would be okay because that's only about the type system at compile time, not the representation of the data.
03:59:16 <asdf_> oh. got it. thanks Cale
04:14:36 <osaunders> preflex: seen chrisdone
04:14:36 <preflex>  chrisdone was last seen on #haskell-blah 8 hours and 49 seconds ago, saying: splerge http://www.reddit.com/r/haskell/comments/b7dil/try_haskell_now_with_t_and_wip_interactive/
04:16:48 <ben> welp
04:17:18 <ben> the try haskell thing suggested I use 'sort' on my name to get the name of my evil twin nemesis
04:17:29 <ben> apparently I am the evil twin after all...?
04:17:35 <osaunders> > sort "ben"
04:17:36 <lambdabot>   "ben"
04:17:38 <osaunders> lol
04:17:53 <osaunders> > sort "osaunders"
04:17:54 <lambdabot>   "adenorssu"
04:18:00 <theorbtwo> > sort "theorbtwo"
04:18:01 <lambdabot>   "behoorttw"
04:18:05 <tb177> are there any vb programmers here
04:18:07 <tb177> ?
04:18:18 <theorbtwo> Well, it's *almost* pronouncable.
04:18:21 <osaunders> tb177: Wrong channel, dude.
04:18:33 <tb177> where do I go lol#
04:18:50 <ben> tb177: why ask us
04:19:00 <theorbtwo> Try ##vb?  Or just google for visual basic IRC.
04:19:20 <osaunders> theorbtwo: Nah, it's not that.
04:19:33 <osaunders> @google visual basic irc
04:19:34 <lambdabot> No Result Found.
04:19:47 <osaunders> Maybe VB guys don't use IRC.
04:20:37 <theorbtwo> Hm.  Actually googling finds about 6.2Mhits, the 8th of which actually looks like what you want.
04:21:11 <osaunders> I'm really excited about this Try Haskell thing. I want to contribute / use it for my own evil purposes.
04:21:23 <osaunders> Wait, I should tell chrisdone that.
04:21:30 <osaunders> How do you leave a msg for someone?
04:23:56 <osaunders> @msg
04:23:56 <lambdabot> Not enough privileges
04:24:02 <osaunders> @help
04:24:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:24:08 <osaunders> @list
04:24:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:24:22 <osaunders> @help tell
04:24:22 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
04:24:52 <osaunders> @tell chrisdone I'm really excited about this Try Haskell thing. I want to contribute / use it for my own evil purposes.
04:24:52 <lambdabot> Consider it noted.
04:25:37 <osaunders> @thanks lambdabot
04:25:37 <lambdabot> you are welcome
04:25:51 <osaunders> lol, awesome. I honestly didn't know that was going to work.
04:33:07 <osaunders> @b52
04:33:07 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
04:33:15 <osaunders> @brain
04:33:15 <lambdabot> Wuh, I think so, Brain, but burlap chafes me so.
04:33:22 <osaunders> @brain
04:33:22 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
04:34:22 <Itkovian> If XmlRpcType a => XmlRpcType [a] and XmlRpcType a => XmlRpcType [(String, a)] and XmlRpcType String, then why is [(String, String)] not an instance of XmlRpcType?
04:36:43 <Alpounet> maybe it prioritarily looks for an instance for (String, String), trying to use XmlRpcType a => XmlRpcType [a] ?
04:41:24 <Itkovian> Well, if I explicitly do a toValue of [("k", "v")] it yields the desired result, so why can't it infer this when I compile my code?
04:41:35 <Itkovian> Would the order of definition of the instances matter?
04:44:18 <Alpounet> Itkovian, I'm not sure, but it seems to be the only plausible explanation
04:44:33 <Alpounet> I'll just write a test to check this
04:44:51 <krainboltgreene> And I return.
04:45:19 <Zeiris_> When should I define a monad, or a monad transformer stack in my code? When I start to notice more than two read-only/state components that occur in at least several functions?
04:48:56 <Alpounet> Itkovian, the problem probably comes from the fact that String is [a], with a = Char
04:49:41 <Itkovian> OK, but ghci seems to have no trouble inferring it at runtime.
04:50:06 <Zao> ghci contains trace amounts of magic.
04:50:44 <sinelaw> ghci is functional homeopathy
04:51:21 <Zeiris_> ghci feeds you small amounts of poison in the hope that it's good for you?
04:51:40 <ben> "Small"?
04:51:55 <Itkovian> haha
04:53:26 <zygoloid> Itkovian: looks like your instances overlap? that way lies madness
04:54:05 <sinelaw> i thought homeopathy is about feeding you things that have "memory" of once being with some molecule. you can buy homeopathic plutonium in NYC
04:54:15 <sinelaw> it's really just tap water
04:54:51 <medfly> I wonder if they really bother to mix it with plutonium
04:54:56 <medfly> I mean, just pour in some water
04:55:08 <sinelaw> nah
04:55:13 <sinelaw> too much effort
04:55:52 <theorbtwo> If homeopathy works, then we've all been drinking an awful lot of homeopathic piss.
04:55:56 <medfly> yes
04:56:19 <ben> The problem with homeopathy is not that it does not work, it is that lots of potentially useful medical research gets wasted on it
04:56:22 <medfly> I recall a complaint about homeopathy that tried ti calculate what are the odds that you've drank a similar portion of a specific person's piss
04:56:36 <Itkovian> I did not define the XmlRpcType instances
04:59:42 <benmachine> ben: and tax money :(
05:00:58 <medfly> there is a famous quote in local politics here... "the public is stupid and therefore the public will pay" :)
05:01:11 <benmachine> yes but I pay tax
05:01:12 <benmachine> sometimes
05:01:51 <jkingkong> what does the error message "is not applied to enough type arguments" mean?
05:01:59 <ben> medfly: In the tiny village I was from, the public got a chance to vote against a ridiculous useless expensive prestige project, and the mayor's office was all like "the public is too stupid to know what is good for them" for the next year or so <:)
05:02:03 <benmachine> the *other* problem with homeopathy is the erosion of trust in science which actually works
05:02:11 <benmachine> > 4 :: Maybe
05:02:12 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
05:02:12 <lambdabot>  Expected kind `...
05:02:37 <seit> I'm not sure how to express the following in haskell, but what I'd like to do is:
05:02:39 <benmachine> jkingkong: you have a type constructor, presumably, that takes more type arguments than you have given it
05:02:45 <seit> fs = [(a -> b), (b -> c), ...]
05:02:51 * hackagebot safer-file-handles 0.4 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.4 (BasVanDijk)
05:02:51 <seit> xs = [a, b, ...]
05:03:00 <seit> zipWith fs xs
05:03:05 <jkingkong> so i have type CovarMatrix r = [[r]]
05:03:07 <medfly> :t zipWith
05:03:08 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:03:09 <dschoepe> seit: zipWith ($) fs xs
05:03:14 <medfly> er :)
05:03:21 <jkingkong> and i try declaring another type
05:03:22 <ksf> you want <*>
05:03:24 <benmachine> > tail [a,b,c,d,e]
05:03:25 <lambdabot>   [b,c,d,e]
05:03:26 <jkingkong> with CovarMatrix Double
05:03:27 <ksf> :t <*>
05:03:28 <lambdabot> parse error on input `<*>'
05:03:31 <ksf> :t (<*>)
05:03:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:03:34 <jkingkong> what's the issue exactly?
05:04:03 <ksf> though there's two ways to make an applicative instance for lists...
05:04:05 <benmachine> jkingkong: like, Maybe CovarMatrix Double?
05:04:12 <seit> ah, interesting 'zipWith ($)' -- let me try it out.  Thanks!
05:04:15 <benmachine> jkingkong: that'd be, Maybe (CovarMatrix Double)
05:04:20 <ksf> > [(+1), (*2)] <*> [10,12,14]
05:04:21 <lambdabot>   [11,13,15,20,24,28]
05:04:40 <ksf> ...as you see, the default is multiplicative, not like a zip.
05:04:47 <benmachine> jkingkong: make sure you have parentheses where they are necessary
05:05:06 <ksf> there's a newtype do do that in Control.Applicative though, afair.
05:05:21 <jkingkong> benmachine thanks for the help but i still get the same error
05:05:22 <jkingkong>  Expected kind `*', but `CovarMatrix Double' has kind `* -> *'
05:05:33 <ksf> and seit, you can't have polymorphic lists
05:05:48 <ksf> ...not without existentials or HList, that is.
05:05:52 <seit> ksf: that was the next part I was thinking about :-)
05:06:15 <benmachine> jkingkong: maybe pastebin the type definition and the line that causes the error?
05:06:22 <ksf> ...or just wrapping up your stuff so the polymorphism doesn't show through.
05:06:25 <seit> ksf: any recommended data haskell data structures for that?
05:06:40 <seit> ksf: what do you mean by wrapping it so the polymorphism doesn't show through?
05:06:52 <ksf> data Foo  = Foo (a -> b)
05:07:11 <ksf> somewhere along the line, though, you're going to run into typing problems.
05:07:18 <jkingkong> i'm using the library levmar http://hackage.haskell.org/packages/archive/levmar/0.2.1/doc/html/LevMar-Intermediate-Fitting.html
05:07:35 <ksf> what is it that you are trying to do, anyway?
05:07:36 <jkingkong> and making a "result" type that displays the data
05:08:27 <seit> ksf: I have a list of functions, a list of current inputs and would like to evaluate each of their outputs
05:08:32 <jkingkong> and the type i'm declaring is "type Result n = Either LevMarError ([Double], Info Double, CovarMatrix Double)
05:09:17 <seit> ksf: and store each of the function outputs as well
05:09:36 <ksf> ...I mean the reason you're insisting on using that kind of polymorphism
05:09:49 <benmachine> jkingkong: is it intentional that you don't actually use n anywhere?
05:10:13 <ksf> you're basically shooting static typing in the head
05:10:21 <jkingkong> hmm i see i might be taking covarMatrix from the wrong library
05:10:22 <benmachine> seit: do you have an actual literal list i.e. [a -> b] or just lots of them
05:11:16 <seit> I have lots of (say 100's) functions.  So [(a1 -> a2), (a2 -> a3), ... (a99 -> a100)]
05:12:09 <ksf> isn't that one function of type a1 -> a100?
05:12:15 <benmachine> how are you making these functions
05:12:51 <seit> ksf, it is one function type.  But I'd like to store the results of all the "intermediate" functions
05:13:07 <handonson> how can i write a platform-specific code in Haskell?
05:13:17 <ksf> handonson, why would you want to?
05:13:44 <benmachine> seit: if it's one type then I think the original answer of zipWith ($) was right
05:13:50 <benmachine> and we are all just getting confused by your notation
05:13:59 <ksf> I'm always surprised that my code runs on windoze, too. I never intend it to.
05:14:12 <seit> benmachine: sorry about the notation, just started with haskell
05:14:46 <handonson> ksf, I want a simple prompt messagebox to get a very simple input from the user, and i don't want to include gigantic libraries like wx/gtk/qt/etc, so i think i would write some platform-specific code only for that
05:14:59 <benmachine> seit: sorry about the confusion :)
05:15:11 <ksf> runProcess, xmessage
05:15:30 <benmachine> xmessage is platform specific surely
05:15:42 <seit> benmachine: no worries.  let me try and see if I can come up with a better description
05:15:51 <benmachine> seit: does zipWith ($) work?
05:16:09 * seit going back to code
05:16:20 <ksf> you can figure out which OS you're running on either statically through cabal or on runtime using some function somewhere in System.*, don't remember which
05:16:23 <handonson> i mean i don't want to have different copies of my code for different platform
05:17:07 <Zao> Roll a small helper module with some CPP to pick the right function?
05:17:55 <seit> benmachine, ksf: great, yes ($) is what is I was looking for to evaluate the list of functions.  The next problem I have is handling the typing
05:18:06 <ksf> handonson, http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Info.html
05:18:51 <benmachine> handonson: you could have a single module that was selected at build time
05:19:02 <benmachine> and you could put your platform-specific stuff in there
05:19:09 <ksf> handonson, look at its source to see how its done statically
05:22:03 <paolino> handonson: haskeline runs on windows and linux, and partly on osx
05:23:45 <handonson> paolino, true, but since this is a gl code, i thought it'd be annoying for the user to have to switch between the console and the gl window..
05:23:53 <handonson> #if defined(__NHC__) omg i never thought i could use #if in haskell omgrofl
05:24:13 <ksf> ...don't forget -XCPP or {-# LANGUAGE CPP #-}
05:25:16 <ksf> isn't there gluMessage or something?
05:25:23 <ksf> If there isn't, there should be.
05:25:33 <tibbe> how do I compile the libraries that ship with GHC for profiling, when building from source?
05:33:24 <ksf> mk/build.mk
05:33:31 <ksf> GhcLibWays += p
05:38:37 <krainboltgreene> You know what'd be cool? Syntax highlight rules based on something similar to CSS and RE.
05:39:10 <damd> in?
05:39:20 <pantsman>  
05:44:24 <krainboltgreene> In?
05:53:58 <Tarrasch> Why isn't the censor for the MonadWriter implemented like this:
05:54:29 <Tarrasch> censor f (Writer (a, w)) = Writer (a, f w)
05:55:25 <blueonyx> is there any way to compile "plugins" with ghc 6.12?
05:55:59 <blueonyx> or is there an alternative?
05:56:07 <Alpounet> blueonyx, hs-plugins ?
05:56:25 <progo> has anyone thought of an ncurses IRC client done in Haskell so that the configuration blends into executable like in Xmonad & co?
05:56:53 <blueonyx> Alpounet: http://hackage.haskell.org/package/plugins?
05:57:30 <Alpounet> blueonyx, yeah
05:58:18 <blueonyx> Alpounet: so? :>
05:58:44 <Alpounet> blueonyx, isn't this close to what you want ?
05:58:48 <Alpounet> I may have misunderstood your problem
05:59:00 <Alpounet> so can you give us a bit more about what you actually are willing to do ?
05:59:05 <blueonyx> it does not compile with ghc 6.12, thats my problem :)
06:01:48 <benmachine> if arr is an immutable array, is there a faster way of writing its elements to an area of memory than pokeArray ps (elems arr)
06:02:04 <benmachine> (ps is a Ptr of some kind)
06:02:30 <Alpounet> blueonyx, have you tried playing with the .cabal files to make it work ?
06:02:52 <Alpounet> sometimes dependencies are just mis-written, or people forget to update them, etc
06:04:46 <blueonyx> the problem is Distribution.Package i think, because of src/System/Plugins/PackageAPI.hs:61:24: Not in scope: `package'
06:05:17 <osaunders> OH SHIT! http://pioneerplus.ejournalism.ca/files/images/garlic.jpg
06:06:28 <benmachine> is it normal for compiling with profiling to change whether things are unboxed or not?
06:06:36 <benmachine> (thus drastically affecting runtime)
06:06:58 <blueonyx> http://hackage.haskell.org/package/Cabal-1.8.0.2 has no online haddock, where should i find them on my system?
06:07:29 <benmachine> hmm on further inspection that might not actually happen
06:12:24 <jkingkong> for some reason, my program works when loaded as a module in GHCI
06:12:34 <jkingkong> but the moment i put a main function in and try to compile
06:12:46 <jkingkong> the compiler complains about undefined references and such
06:13:19 <jkingkong> and terminates the compilation with "ld: symbol(s) not found)" and "ld returned 1 exit status"
06:13:26 <jkingkong> anybody ever experience this?
06:14:20 <byorgey> jkingkong: try compiling with --make, perhaps?
06:14:45 <byorgey> which tells ghc to chase down and link in any dependencies
06:16:30 <jkingkong> like ghc make ---?
06:16:54 <jkingkong> oh ghc --make
06:17:26 <jkingkong> still doesn't link it
06:17:37 <jkingkong> thanks for the suggestion though byorgey
06:19:02 <mreh> jkingkong, rm *.o *.hi
06:19:09 <mreh> then recompile
06:19:13 <jkingkong> yea
06:19:14 <mreh> that might do it
06:19:19 <jkingkong> it was that and a module type
06:19:22 <jkingkong> typo
06:19:34 <jkingkong> thanks guys you're all the best
06:19:40 <mreh> o/
06:21:42 <jkingkong> wait
06:21:46 <jkingkong> i don't see any output file
06:21:47 <jkingkong> ....
06:22:02 <mreh> jkingkong: binary?
06:22:09 <jkingkong> yea no binary
06:22:13 <mreh> what is your main called?
06:22:27 <mreh> do you have a module called Main, and a function Main.main?
06:22:28 <jkingkong> the module name?
06:22:40 <jkingkong> oh no
06:22:42 <jkingkong> gawd
06:22:45 <mreh> yes, Module called Main in a file called Main.hs/Main.lhs
06:22:47 <jkingkong> it's too early in the morning
06:22:47 <mreh> it's okay
06:22:50 <Alpounet> jkingkong, -o foo
06:22:51 <mreh> use -main-is
06:22:53 <jkingkong> thanks for the help
06:23:08 <mreh> if you use -o it will complain you don't have a main
06:23:17 <mreh> do you have to use -o and -main-is
06:23:33 <mreh> ghc -main-is Foo.bar -o Baz -etc -etc
06:24:32 <mreh> jkingkong, did it work?
06:25:05 <jkingkong> it tries to link
06:25:08 <jkingkong> and fails ...
06:25:18 <jkingkong> so i guess the problem won't be so easy
06:25:23 <mreh> jkingkong, what's the message?
06:25:39 <jkingkong> ld: symbol(s) not found
06:25:39 <jkingkong> collect2: ld returned 1 exit status
06:25:49 <jkingkong> and a bunch of referencing errors before that
06:26:02 <jkingkong> Undefined symbols:
06:26:02 <jkingkong>   "_sgemm_", referenced from:
06:26:02 <jkingkong>       _slevmar_trans_mat_mat_mult in libHSbindings-levmar-0.1.1.1.a(misc.o)
06:26:02 <jkingkong>   "_dpotrf_", referenced from:
06:26:02 <jkingkong>       _dAx_eq_b_Chol in libHSbindings-levmar-0.1.1.1.a(Axb.o)
06:26:02 <jkingkong>   "_dpotrs_", referenced from:
06:26:03 <jkingkong>       _dAx_eq_b_Chol in libHSbindings-levmar-0.1.1.1.a(Axb.o)
06:26:03 <jkingkong>   "_spotrf_", referenced from:
06:26:04 <jkingkong>       _sAx_eq_b_Chol in libHSbindings-levmar-0.1.1.1.a(Axb.o)
06:26:04 <jkingkong>   "_spotrs_", referenced from:
06:26:05 <jkingkong>       _sAx_eq_b_Chol in libHSbindings-levmar-0.1.1.1.a(Axb.o)
06:26:05 <jkingkong>   "_dgemm_", referenced from:
06:26:06 <jkingkong> etc
06:26:11 <Zao> I hear paste sites are nice.
06:26:15 <mreh> jkingkong: don't paste more than 4 lines or so
06:26:21 <mreh> @paste
06:26:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:26:28 <jkingkong> sorry i'll use the pastebin
06:27:12 <mreh> this is all GCC output but the looks of things
06:27:35 <mreh> s/but/by
06:29:04 <jkingkong> s/but/by?
06:30:03 <mreh> it's shorthand for, "I didn't meant to write 'but', I meant 'by'"
06:30:20 <mreh> I'm having such a bad typing day
06:30:31 <sieson> I am very new to haskell. Can anyone in the simplest way tell me how I can add to a list and change the list. I know the : or the insert function add to the list. I can add to the list and see that the string is added to my list. But when I print the original list nothing is changed.
06:30:52 <mreh> sieson: lists are immutable
06:31:03 <jkingkong> oh ok
06:31:11 <sieson> mreh: so what can you do when you want to store something?
06:31:27 <benmachine> sieson: welcome to functional programming, we do things differently :P
06:31:38 <progo> sieson, get a book to learn about functional paradigm
06:31:47 <benmachine> or an internet tutorial
06:31:55 * benmachine has never read a haskell book
06:32:10 <mreh> there aren't many good ones about
06:32:20 <mreh> get a scheme book, there are lots of good scheme books
06:32:25 <benmachine> sieson: basically, you'd be surprised how rarely it's necessary to do things that you thought were essential in other languages
06:32:36 <jkingkong> mreh the thing is, it links completely fine in ghci
06:32:43 <jkingkong> i have never seen this before
06:32:47 <krainboltgreene> Haha
06:33:05 <mreh> did someone tell a joke?
06:33:16 <jkingkong> can i specify what packages ghc links?
06:33:29 <mreh> jkingkong: you don't need to
06:33:43 <mreh> have you tried recompiling the module that you're linking to?
06:33:48 <sieson> mreh: just tell me the keyword that I need to search for. I already have a lot of tutorials and an ebook but not enough time right now.
06:34:06 <jkingkong> mreh: yes i've tried recompiling
06:34:09 <mreh> sieson: it's not an easy thing to learn, you need to take the time
06:34:13 <jkingkong> the compilation failed
06:34:20 <jkingkong> and i loaded it up in ghci
06:34:20 <benmachine> sieson: basically you make a new list similar to the old one
06:34:22 <jkingkong> and ran main
06:34:26 <jkingkong> and it worked
06:34:27 <mreh> jkingkong, what module are you linking into? you must be using an import statement?
06:34:27 <jkingkong> ...
06:34:32 <benmachine> and use that one instead
06:34:32 <jkingkong> yes
06:34:40 <jkingkong> import LevMar (etc)
06:34:45 <jkingkong> among others
06:34:55 <jkingkong> but that's the main one giving me trouble
06:35:05 <benmachine> because haskell lists are immutable, that won't waste more memory than is strictly necessary
06:35:16 <benmachine> because the shared bits can be... shared
06:35:16 <mreh> well the linker errors seem to be about LevMar, so do "cabal install --reinstall LevMa"
06:35:20 * hackagebot darcs-monitor 0.3.7 - Darcs repository monitor (sends email)  http://hackage.haskell.org/package/darcs-monitor-0.3.7 (MarcoSilva)
06:35:27 <sieson> benmachine: cool thanks
06:35:46 <mreh> benmachine: that's not strictly true
06:35:54 <benmachine> mreh: close enough
06:35:57 <krainboltgreene> Those who were talking to me about Shoes: http://www.ruby-forum.com/topic/205095#892743
06:35:59 <mreh> you just don't have to worry about freeing up the memory
06:36:04 <krainboltgreene> Might find that amusing.
06:36:06 <jkingkong> yea still no cigar
06:36:20 <jkingkong> i guess ghci has a better linker or something
06:36:33 <benmachine> mreh: if I have a 1000-element list called xs, and I do let ys = 3 : drop 1 xs, I don't store 2000 elements in memory
06:36:38 <mreh> jkingkong: ghci doesn't do any linking
06:36:46 <benmachine> the 999 elements in common only need to exist once
06:36:54 <mreh> it's an interpreter
06:37:08 <mreh> IIRC
06:37:19 <benmachine> it compiles to bytecode
06:37:25 <mreh> oh
06:37:37 <benmachine> it's kind of a halfway-house I think
06:37:44 <benmachine> well
06:37:51 <benmachine> pretty much all interpreters compile to bytecode
06:37:54 <mreh> an intermediate representation, a virtual machine
06:37:57 <benmachine> but that doesn't mean they don't link, I think
06:38:25 <Jafet> Depends on what you mean by link
06:38:34 <Jafet> It can load modules, of course
06:38:42 <mreh> dumping code from another module into my binary
06:39:00 <mreh> static linking, that's what I'm thinking of
06:39:02 <benmachine> well whatever it does it's got to find all the external functions that you use
06:39:09 <benmachine> and pair them with the names locally
06:39:11 <Jafet> What binary?!
06:39:24 <mreh> the bytecode
06:39:51 <mreh> if GHCi isn't a pure text interpreter, then what else?
06:40:10 <benmachine> ghc interprets text :P
06:40:37 <mreh> you just said it compiles to byte code
06:40:58 <benmachine> um
06:41:12 <benmachine> right
06:41:19 <benmachine> ghc compiles binaries
06:41:23 <benmachine> ghci compiles bytecode
06:42:47 <benmachine> anyway
06:42:57 <mreh> benmachine: about your lists, that's true, but you don't store 2000 elements as a consequence of your C code either, you just store the pointer
06:43:26 <mreh> as soon as the list is no longer referenced, the RTS garbage collects it
06:43:28 <benmachine> mreh: depends how the lists are represented
06:43:40 <benmachine> in python, you'd probably store 2000 elements
06:43:44 <benmachine> unless you were pretty clever
06:43:55 <benmachine> in C if you only knew about arrays you'd store 2000 elements
06:43:59 <mreh> I don't know anything about python
06:44:22 <mreh> only if you copied the memory into another duplicate array
06:44:32 <mreh> you request the memory once, and then pass the pointer around
06:44:36 <benmachine> well how else are you going to get an array with the first element different?
06:45:12 <mreh> the same way you would do it in haskell, make a copy and change the first element
06:46:02 <mreh> I'm not entirely sure of the point I'm making, so don't take my directness as a sign of competence, I'm pretty sure this is right though
06:46:10 <benmachine> well
06:46:17 <benmachine> hmm
06:46:32 <benmachine> what I am saying is not impossible in any other language
06:46:42 <benmachine> but probably requires more effort
06:47:00 <benmachine> there is no linked list in the standard C libraries
06:47:09 <mreh> yeah, you have to use structs
06:47:21 <mreh> but they're just records with pointers
06:47:26 <Jafet> There is no garbage collection in standard C
06:47:38 <mreh> who said that?
06:47:42 <benmachine> mreh: the point is you have to do the dirty bit yourself :P
06:47:54 <benmachine> in haskell it is done for you already
06:47:57 <mreh> of course, memcpy and all that
06:48:03 <Jafet> (Unless you subscribe to the view that all C programs are garbage.)
06:48:12 <krainboltgreene> I'd bother to learn C if it wasn't so syntatically ugly.
06:48:22 <krainboltgreene> Bwahahaha @ jafet
06:48:25 <zygoloid> mreh: Jafet's bang on the money. you /can/ make singly-linked lists in C easily. but sharing tails requires more work if you ever want to deallocate them...
06:48:37 <benmachine> C is not syntactically ugly really
06:48:40 <benmachine> C++ is
06:48:45 <krainboltgreene> They both are.
06:48:46 <McManiaC> anyone working with FFI on 64bit? I always get a "/usr/include/gnu/stubs.h error: gnu/stubs-32.h not found" error
06:48:47 <benmachine> C is just incredible verbose
06:48:50 <benmachine> y
06:48:59 <zygoloid> why do people feel the need to bash c++ when it's not even pertinent to the discussion?
06:49:01 <mreh> hello world in C is how many lines?
06:49:09 <krainboltgreene> 6? 7?
06:49:14 <krainboltgreene> Or maybe that was Java.
06:49:16 <benmachine> umm
06:49:17 <benmachine> two
06:49:22 <Jafet> Lisp has inner beauty; C has outer beauty; Haskell has both; C++ has none
06:49:23 <benmachine> well
06:49:26 <Tarrasch> int main(){printf("Hello World.")}
06:49:28 <benmachine> quite
06:49:32 <zygoloid> +;
06:49:33 <McManiaC> main () { printf("Hello world\n"); }
06:49:37 <benmachine> only preprocessor directives actually demand a newline in C
06:49:38 <McManiaC> *int
06:49:39 <McManiaC> :>
06:49:41 <mreh> what about importing the std libraries
06:49:46 <mreh> and making it look nice to read
06:49:52 <mreh> it's atleast 5
06:49:54 <benmachine> that is all strictly optional
06:50:07 <benmachine> it's four or five depending on your brace style
06:50:30 <benmachine> or six if you insist on blank lines sometimes
06:50:34 <mreh> I do
06:50:53 <zygoloid> how is the size of the smallest possible program relevant? that's maybe just a constant overhead
06:50:53 <benmachine> well it's seventy if you insist on enough of them :P
06:51:00 <McManiaC> mreh: but the binary isnt 800kb big :>
06:51:02 <krainboltgreene> puts "Hello World"
06:51:17 <benmachine> I think the smallest possible C program is zero-length
06:51:23 <benmachine> or, I've heard some compilers will compile an empty file
06:51:24 <Tarrasch> lol
06:51:30 <mreh> only with hackery
06:51:32 <benmachine> don't know what the standard says
06:51:32 <krainboltgreene> Hmm. Does Syntax Verbosity == Syntax Ugly? I think so.
06:51:37 <zygoloid> benmachine: pretty sure you'll usually get a link error if you don't define main
06:51:47 <benmachine> mreh: mv file.c a.out; chmod +x a.out :P
06:52:02 <benmachine> best compiler ever
06:52:34 <mreh> or cheating
06:52:37 <benmachine> zygoloid: I just remember a zero-length file being submitted to the IOCCC as the shortest ever quine
06:52:51 <benmachine> don't recall the details
06:53:13 <medfly> lol
06:53:56 <benmachine> anyway what was the point
06:54:06 <benmachine> zygoloid made it ages ago
06:54:19 <benmachine> and then we (/I) started talking nonsense about short C programs
06:55:16 <Jafet> >
06:57:02 <mreh> :D
06:57:07 <jkingkong> when i try using constants in a function, i get the error  Inferred type is less polymorphic than expected
06:57:08 <mreh> I was thinking that
06:57:25 <mreh> jkingkong: paste the code
06:57:36 <jkingkong> poisson :: Num r => Model r r
06:57:37 <jkingkong> poisson [l] t = ((l*r*a)/(1.0+r))*(1+(a*b)/(d^2))*(exp(-l*t))*(1.0+(l+c)/(r*l)*(exp(-c*t)))+(a*(a-b)*w)/(d^2)
06:57:43 <jkingkong> that's the function
06:57:50 <jkingkong> and i have things like b=2990.0
06:57:52 <jkingkong> and such
06:58:04 <mreh> that doesn't look quite right
06:58:08 <mreh> what's the type of Model?
06:58:34 <jkingkong> type Model r a = [r] -> a -> r
06:58:46 <mreh> okay, that makes more sense
06:59:08 <jkingkong> all the letters in the line are defined elsewhere except l and t
06:59:13 <mreh> and it compiles? It shouldn't...
06:59:24 <sinelaw> dpkg: "Warning: one warning was ignored"
06:59:29 <sinelaw> *boom*
06:59:31 <jkingkong> no it doesn't
06:59:44 <jkingkong> it gives the inferred type is less polymorphic than expected error
06:59:51 <mreh> the type signature doesn't match the function definition's type
06:59:52 <Jafet> sinelaw, perhaps you're supposed to ignore it
06:59:54 <benmachine> sinelaw: was it that one?
07:00:25 <sinelaw> i wish i knew
07:00:31 <jkingkong> mreh what's the proper way to do it?
07:01:06 <benmachine> jkingkong: if you are going to use exp, you need a Floating type
07:01:07 <benmachine> I think
07:01:08 <mreh> jkingkong: well your type signature is of the type Num r => [r] -> r -> r
07:01:27 <jkingkong> oh i see
07:01:54 <mreh> hmm... wait a second
07:02:23 <jkingkong> how do i specify the type of a constant?
07:02:31 <jkingkong> and i feel like the signatures work
07:02:36 <medfly> :t  (1 :: Int)
07:02:37 <lambdabot> Int
07:03:17 <mreh> jkingkon: that definition is missing some cases
07:03:33 <mreh> poisson [] t, and poisson (l:ls) t
07:03:41 <mreh> are they written too?
07:03:58 <jkingkong> no it's not type safe
07:04:13 <mreh> why not?
07:04:13 <jkingkong> there will always be one parameter to the first argument
07:04:19 <mreh> don't use a list then
07:04:26 <jkingkong> it's how the library works
07:04:45 <mreh> that doesn't matter, what if you were call the function with an empty list?
07:04:49 <benmachine> this is beside the point though, it's the Num that's the problem
07:05:01 <benmachine> Num contains Int, and you can exp an Int
07:05:03 <benmachine> er
07:05:04 <benmachine> can't
07:05:10 <jkingkong> yea i see
07:05:20 <mreh> cryptic error message
07:05:38 <benmachine> not really
07:05:42 <mreh> or cryptic problem exposition
07:05:43 <benmachine> it infers a type of Floating
07:05:47 <benmachine> expects a type of Num
07:05:54 <benmachine> and the inferred type is less polymorphic
07:05:54 <jkingkong> is there a more flexible exp?
07:06:06 <jkingkong> yea i think that must be it
07:06:13 <benmachine> (by Floating I mean (Floating f) => f)
07:06:21 <benmachine> (and by f I mean Model f f)
07:06:29 <jkingkong> haha understood
07:06:39 <benmachine> (and by "and by I mean" I mean, don't expand that recursively)
07:09:23 <jkingkong> so i tried setting e = exp 1::Double
07:09:29 <jkingkong> and using e ^^ instead of exp
07:10:00 <jkingkong> and it tells me "No instance for (Integral Double) arising from a use of ^^ at ...
07:10:54 <int-e> there are three exponentiation operators in Haskell, ^, ^^ and **
07:11:32 <jkingkong> oh shoot
07:11:41 <jkingkong> yea ^^ only works for integers
07:11:52 <jkingkong> and ** only works with floats
07:13:16 <integral> :t ((^^),(^))
07:13:17 <lambdabot> forall a b a1 b1. (Fractional a, Integral b, Num a1, Integral b1) => (a -> b -> a, a1 -> b1 -> a1)
07:14:57 <mreh> @pl (\x y -> x + fromEnum y)
07:14:57 <lambdabot> (. fromEnum) . (+)
07:15:12 <mreh> @pl (\x y -> fromEnum x + y)
07:15:12 <lambdabot> (+) . fromEnum
07:15:30 <mreh> infix operators... bleh
07:15:57 <McManiaC>     Warning: -#include is deprecated: No longer has any effect
07:16:02 <McManiaC> whats "the new way"?
07:16:03 <DerisionSnort> @pl \x -> if x == EQ then EQ else if x == LT then GT else LT
07:16:03 <lambdabot> ap (flip if' EQ . (EQ ==)) (flip (flip if' GT . (LT ==)) LT)
07:16:13 <DerisionSnort> is there no built-in function to reverse an order?
07:16:29 <mreh> DerisionSnort: flip compare?
07:16:32 <benmachine> McManiaC: there's a pragma, I think?
07:16:38 <mreh> :t compare
07:16:39 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:16:50 <mreh> > flip compare 1 2
07:16:52 <lambdabot>   GT
07:16:53 <DerisionSnort> ah, makes sense. thanks.
07:16:59 <Igloo> McManiaC: Simply do nothing
07:17:34 <McManiaC> Igloo: ?
07:19:11 <zygoloid> > compare EQ
07:19:12 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
07:19:12 <lambdabot>    arising f...
07:19:32 <zygoloid> > map (compare EQ) [LT, EQ, GT]
07:19:33 <lambdabot>   [GT,EQ,LT]
07:19:53 <McManiaC> During interactive linking, GHCi couldn't find the following symbol: (...)
07:20:43 <tensorpudding> does Ord imply Eq?
07:20:50 <mreh> @pl (\x -> 7 <= x && x <= 9)
07:20:50 <lambdabot> liftM2 (&&) (7 <=) (<= 9)
07:21:19 <mreh> @undo liftM2 (&&) (7 <=) (<= 9)
07:21:19 <lambdabot> liftM2 (&&) (7 <=) (<= 9)
07:22:02 <zygoloid> tensorpudding: yes.
07:22:13 <zygoloid> @type \x -> x > x && x == x
07:22:14 <lambdabot> forall a. (Ord a) => a -> Bool
07:22:17 <McManiaC> benmachine: what pragma?
07:23:11 <benmachine> McManiaC: oh, never mind
07:23:18 <benmachine> "The INCLUDE used to be necessary for specifying header files to be included when using the FFI and compiling via C. It is no longer required for GHC, but is accepted (and ignored) for compatibility with other compilers."
07:26:16 <McManiaC> benmachine: so how do I tell haskell what lib to use?
07:27:22 <benmachine> McManiaC: the implication of that line is that GHC works it out
07:27:41 <benmachine> but I don't know enough about the FFI to tell you really
07:30:52 <McManiaC> :S
07:33:26 <mm_freak> how can i convert an MVector to a Vector in the 'vector' package?  is there a runSTUArray equivalent?
07:38:04 <DerisionSnort> Is there something like a NOT_EQ monad? Given a sequence of Comparing-values, I want to find the first that is not EQ. Once I found that, the rest of the sequence does not matter anymore.
07:38:54 <benmachine> monoid
07:39:05 <benmachine> > mconcat [EQ, EQ, EQ, LT, GT, EQ]
07:39:06 <lambdabot>   LT
07:39:16 <benmachine> > mappend EQ GT
07:39:17 <lambdabot>   GT
07:39:21 <benmachine> > mappend GT LT
07:39:22 <lambdabot>   GT
07:39:25 <benmachine> etc.
07:39:33 <benmachine> not everything is a monad :)
07:40:47 <DerisionSnort> awesome! so Comparing is a monoid?
07:41:02 <benmachine> Ordering is
07:41:12 <DerisionSnort> :t Comparing
07:41:13 <lambdabot> Not in scope: data constructor `Comparing'
07:41:16 <DerisionSnort> :t Ordering
07:41:17 <lambdabot> Not in scope: data constructor `Ordering'
07:41:21 <benmachine> :t GT
07:41:22 <lambdabot> Ordering
07:41:36 <DerisionSnort> @src Ordering
07:41:36 <lambdabot> data Ordering = LT | EQ | GT
07:41:44 <DerisionSnort> yeah, that's what i meant, sorry
07:42:11 <DerisionSnort> :info Ordering
07:42:15 <DerisionSnort> @info Ordering
07:42:15 <lambdabot> Ordering
07:42:21 <DerisionSnort> > :info Ordering
07:42:22 <lambdabot>   <no location info>: parse error on input `:'
07:42:23 <benmachine> lambdabot doesn't do :info
07:42:26 <benmachine> use ghci
07:42:26 <DerisionSnort> ah okay
07:42:33 <benmachine> also, import Data.Monoid first
07:42:40 <DerisionSnort> works like a charme!
07:44:06 <DerisionSnort> @src mconcat
07:44:06 <lambdabot> Source not found.
07:44:36 <DerisionSnort> ah, because its different for every instance, right?
07:44:45 <benmachine> potentially
07:44:51 <benmachine> but it has a default implementation
07:44:55 <benmachine> foldr mappend mempty
07:45:01 <benmachine> :t foldr mappend mempty
07:45:02 <lambdabot> forall a. (Monoid a) => [a] -> a
07:45:10 <benmachine> mappend and mempty are different for every instance
07:45:12 <DerisionSnort> foldr? so it only works for finite lists?
07:45:20 <benmachine> no foldr work for infinite lists
07:45:24 <benmachine> if the folding function is lazy
07:45:54 <benmachine> > foldr (||) False ([False, False, False] ++ repeat True)
07:45:55 <lambdabot>   True
07:46:29 <benmachine> @src foldr
07:46:29 <lambdabot> foldr f z []     = z
07:46:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:46:43 <benmachine> ^ if f ignores its second argument, foldr ignores the tail of the list
07:47:03 <benmachine> in the case of Ordering, mappend ignores its second argument if the first is LT or GT
07:47:09 <benmachine> hence:
07:47:14 <benmachine> > mconcat (repeat GT)
07:47:15 <lambdabot>   GT
07:47:17 <benmachine> but!
07:47:19 <benmachine> > mconcat (repeat EQ)
07:47:24 <lambdabot>   mueval: ExitFailure 1
07:49:13 <benmachine> :t comparing length ++ compare
07:49:14 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
07:49:44 <benmachine> > sortBy (comparing length ++ compare) [[1], [2,1], [2, 2], [2]]
07:49:45 <lambdabot>   [[1],[2],[2,1],[2,2]]
07:49:48 <benmachine> er
07:49:51 <benmachine> > sortBy (comparing length ++ compare) [[1], [2,1], [1, 2], [2]]
07:49:52 <lambdabot>   [[1],[2],[1,2],[2,1]]
07:50:25 <dschoepe> :t (++)
07:50:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:50:36 <benmachine> lambdabot has some strange ideas
07:50:37 <dschoepe> that's Caleskell, right?
07:50:50 <benmachine> it has been called that
07:50:54 <benmachine> but not by Cale :P
07:51:06 <dschoepe> > (+1) . (+3) 4
07:51:07 <lambdabot>   No instance for (GHC.Num.Num (f a))
07:51:07 <lambdabot>    arising from the literal `3' at <int...
07:51:14 <benmachine> $
07:51:33 <dschoepe> benmachine: I saw an example that didn't need that, due to (.) = fmap for lambdabot
07:51:53 <benmachine> you are thinking of something else I am sure
07:51:57 <benmachine> (+3) 4 == 7
07:52:08 <benmachine> function application always binds the most tightly
07:52:14 <benmachine> > (+1) . Just 4
07:52:15 <lambdabot>   Just 5
07:52:56 <dschoepe> > reverse . replicateM 3 [True, False]
07:52:57 <lambdabot>   [[True,True,True],[False,True,True],[True,False,True],[False,False,True],[T...
07:53:03 <dschoepe> that was the one I meant
07:53:31 <benmachine> oh
07:53:52 <benmachine> that is reverse fmapped over (replicateM 3 [True, False])
07:54:34 <dschoepe> yes, I forgot that one of the (.)-functions was monadic
07:54:54 <benmachine> > reverse . replicate 3 True
07:54:55 <lambdabot>   Couldn't match expected type `[a]'
07:54:56 <lambdabot>         against inferred type `GHC.Bool....
07:55:06 * benmachine hmms
07:55:09 <benmachine> oh of course
07:55:13 <benmachine> > reverse . replicate 3 [True, False]
07:55:14 <lambdabot>   [[False,True],[False,True],[False,True]]
08:00:06 <DerisionSnort> benmachine: is [Ordering] a different monoid than [a] for other types a?
08:00:17 <dschoepe> DerisionSnort: [a] is not a monoid, in general
08:00:19 <benmachine> no
08:00:25 <benmachine> dschoepe: what
08:00:27 <dschoepe> err, sorry
08:00:29 <benmachine> > mappend [4] [5]
08:00:30 <lambdabot>   [4,5]
08:00:37 <dschoepe> yeah, I'm a bit tired today
08:00:55 <benmachine> DerisionSnort: you can't have "exceptions" to the [a] monid instance
08:00:56 <DerisionSnort> > mconcat [4, 5, 6, 7]
08:00:57 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:00:57 <benmachine> in general
08:00:57 <lambdabot>    `GHC.Num.Num t' arising ...
08:01:05 <benmachine> *monoid
08:01:08 <tensorpudding> (++) is the same for every list
08:01:15 <benmachine> mmhm
08:01:23 <DerisionSnort> > mconcat [EQ, EQ, LT, GT]
08:01:24 <lambdabot>   LT
08:01:39 <DerisionSnort> How exactly does this work for Ordering, I don't get it :(
08:02:23 <tensorpudding> i suppose you could define a special kind of cons-list that is sorted by default, and for which (++) would insert each element in the proper place, which would be a monoid
08:02:51 <tensorpudding> it would only work on elements which have an Or instance
08:03:07 <tensorpudding> Ord*
08:03:09 <benmachine> tensorpudding: see: Data.Set
08:03:24 <tensorpudding> Data.Set isn't actually a cons-list though, is it?
08:03:32 <benmachine> no I think it's actually a tree
08:04:03 <benmachine> :t mconcat
08:04:04 <lambdabot> forall a. (Monoid a) => [a] -> a
08:04:17 <benmachine> DerisionSnort: notice that this uses the Monoid instance for a, not for [a]
08:05:02 <benmachine> tensorpudding: there's more than one monoid relating to lists, I suppose, but whatever one you choose you can only use that one
08:05:08 <benmachine> for every list
08:05:36 <choffstein> Hey all.  Has anyone tried using Cassandra in Haskell with the thrift bindings?
08:08:03 <MadHatterDude> What would be a good 3 symbol operator for unfold?
08:11:56 <voker57> #%^
08:12:31 <blueonyx> lambdabot: what's your birthday?
08:13:51 <DerisionSnort> benmachine: What is the exact operation that is begin performed on the elements of [Ordering] when applying mconcat to it?
08:13:55 <DerisionSnort> being
08:14:51 <benmachine> if you have a list [LT, EQ, GT] then
08:14:53 <Tarrasch> DerisionSnort, I think you've to look into the Monoid defintion of Ordering to find out ... (btw. im kinda n00b)
08:14:58 <benmachine> mconcat on that will do
08:15:22 <dschoepe> DerisionSnort: it folds using mappend
08:15:23 <benmachine> mappend LT (mconcat [EQ, GT])
08:15:32 <benmachine> and mappend LT _ = LT
08:15:35 <benmachine> so that will be LT
08:15:44 <DerisionSnort> ah, and mappend EQ x = x ?
08:15:47 <dancor> i want to associate millions of board game positions to the games where they occurred.  what is the correct format to save to disk from haskell?  use Data.Binary on IntMap [Int]?
08:15:48 <benmachine> yes
08:15:56 <DerisionSnort> cool
08:16:07 <DerisionSnort> and mappend [x] = x ?
08:16:22 <benmachine> er
08:16:25 <byorgey> DerisionSnort: mconcat [x] = x
08:16:30 <benmachine> mconcat [x] = x
08:16:32 <benmachine> although
08:16:32 <dancor> i guess IntMap (Set Int) is better probably
08:16:35 <benmachine> strictly speaking
08:16:42 <benmachine> mconcat [x] = mappend x mempty = x
08:16:50 <benmachine> usually, anyway
08:16:58 <byorgey> "usually"?
08:17:07 <benmachine> well mconcat can be overridden
08:17:07 <byorgey> if mappend x mempty /= x it is a bug =)
08:17:18 <McManiaC> can anyone help me getting started with the foreign function interface? is there any up to date tutorial that you guys can recommand?
08:17:24 <byorgey> yes, but if mconcat [x] /= x that is a bug too.
08:17:45 <byorgey> it can be overridden to make it more efficient, but you shouldn't change the semantics.
08:17:46 <MadHatterDude> What real world language would you like Haskell to?
08:17:47 <benmachine> byorgey: mm, but it might not go through that intermediate step
08:17:59 <benmachine> but I guess the equation still holds
08:18:01 <byorgey> benmachine: operationally speaking, it might not, you're right
08:18:27 <byorgey> MadHatterDude: I don't understand your question.
08:18:32 <DerisionSnort> How can i see the source for the Ordering Monoid instance?
08:18:36 <Alpounet> MadHatterDude, to what ?
08:18:41 <Alpounet> look like ?
08:18:48 <MadHatterDude> Yeah
08:18:50 <dschoepe> McManiaC: http://haskell.org/haskellwiki/FFI - those are a good start
08:18:52 <MadHatterDude> Or feel like
08:19:06 <benmachine> MadHatterDude: I'd like it to look like haskell
08:19:08 <byorgey> DerisionSnort: I think it is in Data.Monoid, search for Monoid on Hoogle (haskell.org/hoogle)
08:19:10 <Alpounet> none, if by real world you mean 'mainstream'
08:19:18 <benmachine> @hackage base
08:19:18 <lambdabot> http://hackage.haskell.org/package/base
08:19:25 <byorgey> DerisionSnort: then click the 'Source Code' link in the top right
08:19:46 <bsdemon> Hello, I am novice haskell programmer, can you please review my simple network echo server code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23092#a23092
08:19:50 <MadHatterDude> Sorry, I meant to write "liken Haskell to"
08:20:10 <byorgey> MadHatterDude: I would liken it to Haskell, which is a real world language =)
08:20:15 <DerisionSnort> byorgey: thanks, found it!
08:20:37 <byorgey> MadHatterDude: and it's quite different from most "mainstream" languages
08:21:00 <MadHatterDude> byorgey: yes. yes it is
08:21:15 <DerisionSnort> instance Monoid Ordering where
08:21:16 <DerisionSnort>         mempty         = EQ
08:21:16 <DerisionSnort>         LT `mappend` _ = LT
08:21:16 <DerisionSnort>         EQ `mappend` y = y
08:21:16 <DerisionSnort>         GT `mappend` _ = GT
08:21:18 <DerisionSnort> okay that makes sense
08:21:32 <MadHatterDude> byorgey: but a speakable one, like english.
08:22:00 <byorgey> yep, that's it.  It implements lexicographic ordering.
08:22:00 <benmachine> MadHatterDude: that's an odd question
08:22:12 <MadHatterDude> byorgey: I saw an analogy today where PHP was likened to english, perl to chinese and lua to a constructed one like lojban
08:22:15 <benmachine> MadHatterDude: do you have an example of an answer for any other programming language
08:22:20 <byorgey> so (compare xs ys == mconcat (zipWith compare xs ys))
08:22:35 <MadHatterDude> benmachine: what I just said to byorgey
08:22:48 <benmachine> byorgey: isn't that slightly off if the lists are unequal
08:22:50 <byorgey> MadHatterDude: I see.  In that case I think Haskell is like Quenya.
08:23:01 <byorgey> benmachine: hmm, it might be
08:23:01 <benmachine> I don't think PHP is like english
08:23:06 <MadHatterDude> byorgey: ? *googles*
08:23:09 <benmachine> byorgey: in length I mean
08:23:16 <chrisdone> @check \xs ys -> compare xs ys == mconcat (zipWith compare xs ys)
08:23:17 <lambdabot>   "Falsifiable, after 2 tests:\n[(),()]\n[]\n"
08:24:25 <byorgey> good point.
08:24:50 <byorgey> @check \(xs :: [Int]) ys -> length xs == length ys ==> compare xs ys == mconcat (zipWith compare xs ys)
08:24:50 <lambdabot>   Parse error in pattern at "ys" (column 16)
08:25:02 <MadHatterDude> byorgey, benmachine: http://forums.xkcd.com/viewtopic.php?f=11&t=14661&start=1560 - Scroll down and you will find a post by "; DROP DATABASE;--"
08:25:05 <byorgey> @check \xs ys -> length (xs :: [Int]) == length ys ==> compare xs ys == mconcat (zipWith compare xs ys)
08:25:06 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:25:06 <lambdabot>                     (Test.QuickCh...
08:25:23 <bsdemon> Hey, anyone, please review http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23092 it is a simple network echo server, am I missing something in error handling?
08:26:52 <benmachine> bsdemon: do you have a specific problem
08:26:52 <chrisdone> MadHatterDude: I always saw Haskell analagous to Lojban. everything in Lojban comes from what linguists think would be neat. everything in Haskell comes from what computer scientists think would be neat. (add a grain of salt here)
08:27:27 <MadHatterDude> chrisdone: good point
08:27:54 <bsdemon> benmachine: no, just wonder if I am doing it right...
08:29:18 <benmachine> bsdemon: if I read your code without looking for anything in particular I will probably not find anything
08:29:40 <benmachine> people browsing quickly over stuff aren't going to help much
08:29:45 <benmachine> just use it and see if it works
08:29:54 <bsdemon> benmachine: I am interesting in issues with coding style and error handling
08:30:00 <bsdemon> ti pretty works
08:30:04 <benmachine> ok
08:30:22 <benmachine> handleConnection doesn't need a do
08:30:32 <benmachine> do x = x when x is only one thing
08:30:43 <benmachine> imo main doesn't really need a do either
08:30:54 <benmachine> you can do it directly as putStrLn blah >> bracket blah
08:31:05 <benmachine> but people will have differing opinions on that
08:31:19 <benmachine> also, you use a lot of line space for your imports
08:31:35 <benmachine> explicit importing is good but they don't all have to be on separate lines
08:32:14 <benmachine> acceptConnections and interact could both make use of "forever"
08:32:17 <benmachine> @src forever
08:32:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:32:20 <benmachine> hmph
08:32:27 <benmachine> forever is in Control.Monad.Forever
08:32:38 <benmachine> forever x = x >> forever x
08:32:42 <benmachine> so it's good for infinite loops
08:32:45 <chrisdone> I thought it was just in Control.Monad
08:32:54 <benmachine> err
08:32:54 <benmachine> yes
08:32:58 <benmachine> you are right
08:33:03 <benmachine> I was thinking of Control.Monad.Fix
08:33:06 <benmachine> which is something else
08:33:12 <chrisdone> aye
08:33:58 <bsdemon> ok, thx, this is code review I was looking for
08:34:15 <benmachine> by the way
08:34:23 <benmachine> I make no guarantee that anything I said is actually sensible
08:34:25 <benmachine> just ideas
08:34:29 <MadHatterDude> Does ML languages produce faster code than haskell?
08:34:29 <benmachine> if you don't like them don't use them
08:34:53 <benmachine> MadHatterDude: languages don't have speed, implementations do
08:35:02 <benmachine> http://shootout.alioth.debian.org/
08:35:24 <benmachine> hmm that doesn't actually have ML
08:36:08 <MadHatterDude> benmachine: (sarcasm)Thank you, for such a nice and productive reply.
08:36:16 <dancor> it can ocaml
08:36:20 <dancor> it has ocaml
08:36:43 <chrisdone> dancor: I can has programming?
08:36:58 <dancor> MadHatterDude: are you interested in ocaml when you say ml
08:37:07 <benmachine> MadHatterDude: what I said is true, and then I linked you to a popular benchmarking website
08:37:07 <dancor> chrisdone: lol
08:37:12 <tensorpudding> lol, Mozart/Oz is a "multi-multi-multi-paradigm distributed language"
08:37:33 <MadHatterDude> dancor: Just strict pure-func languages in general...
08:37:43 <benmachine> is ML even pure?
08:37:51 <tensorpudding> OCaml isn't "pure"
08:39:30 <dancor> MadHatterDude: i would look at http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ocaml&lang2=ghc
08:42:03 <Philippa> benmachine: no, it's not
08:42:11 <HugoDaniel> hi
08:42:33 <gwern> patch-tag now has 457 repos.
08:42:36 <gwern> not too shabby
08:42:45 <gwern> but it's taking annoyingly long to get them all :)
08:42:50 <HugoDaniel> :)
08:42:55 <HugoDaniel> how about git-hub ?
08:43:27 <HugoDaniel> i like git as much as i like linus...
08:43:34 <gwern> it'd go a lot faster if I used --lazy
08:43:57 <sm> gwern: what are you up to *now* :)
08:44:03 <gwern> sm: downloading patch-tag
08:44:11 <gwern> ya got a problem wit dat?
08:45:26 <sm> I known this is part of your fiendish plan for world domination, but of course I can't see how
08:45:38 <Alpounet> gwern, why are you getting all the repos ?
08:45:41 <Alpounet> is it compulsive ?
08:45:45 <gwern> Alpounet: yes
08:45:49 <gwern> gotta download them all!
08:45:59 <sm> will you keep your mirror up to date ?
08:46:00 * gwern will travel the nets / searching far and wide 
08:46:14 <sm> seems like a nice workout for darcs, anyway
08:46:39 <gwern> sm: well, depends on what you mean by mirror; if you mean each repo I have gets a weekly 'darcs pull', then yes. if you mean I periodically darcs get any new repos, not yet
08:47:13 <gwern> (I need to write a script for that. thomas hartman added a master list to patch-tag for me, but I still need to write a script to parse it, check for existing repos, and get new ones)
08:47:32 * MadHatterDude is away: autoaway [l(on) p(on)]
08:47:35 <sm> patch-tag seems to be going great. If only it could get some github-style ui slickness
08:47:38 <gwern> see http://patch-tag.com/publicrepositoriessimplelisting
08:48:14 <gwern> it do be a jobbie for tagsoup, methinketh
08:48:51 <tensorpudding> i would happy with less fancy than github, so long as it was not ugly and hard to navigate
08:49:01 <sm> yup
08:49:07 <merijn> Which style is preferable? "sum . (filter even) . (takeWhile (<100))" or "sum $ filter even $ takeWhile (<100)" or is it just personal preference?
08:49:21 <ddarius> Neither
08:49:26 <MissPiggy> I prefer the .'s
08:49:26 <ddarius> sum . filter even . takeWhile (<100)
08:49:30 <Beelsebob1> merijn: the former but with fewer parens
08:49:37 <ddarius> Also they mean different things
08:49:42 <ddarius> The latter is a type error.
08:49:45 <Beelsebob1> what ddarius said
08:50:03 <Beelsebob1> and in fact, the latter being a type error is more generally why the former is better
08:50:18 <Beelsebob1> because you can refactor by grabbing out a chunk of a . b . c . d
08:50:25 <Beelsebob1> but you can't do the same with a $ b $ c $ d $ x
08:50:46 <merijn> ddarius: Ah, I think I'm being screwed over by not knowing the fixity of '.', then.
08:50:47 <chrisdone> indeed. it's a pain to refactor $'d code by comparison
08:50:55 <Twey> That and the deprecated fixity of ($)
08:51:15 <tensorpudding> using more than one ($) is a sign you're probably not doing it right
08:51:56 <MadHatterDude> I think that ($) should be right associative like function calls
08:51:58 <ddarius> merijn: The fixity of (.) isn't important.  Application always binds tightest.
08:52:13 <ddarius> MadHatterDude: Function application is left associative.
08:52:42 <dancor> well, putStrLn $ "hi " ++ show (abs $ x + 1)
08:52:45 <MadHatterDude> ddarius: It does? My brain myst be malfunctioning...
08:53:05 <merijn> ddarius: . is an application to, isn't it?
08:53:12 <sm> wow, http://tryhaskell.org/ is getting slick
08:53:15 <ddarius> merijn: No, it's composition.
08:53:44 <chrisdone> sm :D
08:53:47 <mreh> can haskell optimise a boolean to a single bit? that's not really going to be quicker though is it? the minimum unit of efficient storage is a word... isn't it
08:53:49 <benmachine> it's an infix application
08:53:53 <sm> good work chrisdone  :)
08:54:00 <gwern> @hoogle basename
08:54:00 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
08:54:01 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
08:54:01 <lambdabot> System.FilePath.Posix takeBaseName :: FilePath -> String
08:54:04 <pokoko222> haskellers mortals, how to solve two unknowns system algorithmically
08:54:08 <benmachine> mreh: I've heard things about Data.Array.Unboxed on Bools
08:54:11 <sm> I got a "time limit exceeded" warning during the tutorial
08:54:12 <pokoko222> like: a1x + b1y = c1 and a2x + b2y = c2
08:54:14 <dancor> sm: heh but try: > print 4
08:54:14 <ddarius> mreh: UArray of Bools is a bit array.
08:54:27 <merijn> ddarius: (.) is a function which gets applied, right? Or is there a difference between a function that gets applied infix vs one that gets applied prefix?
08:54:33 <gwern> pokoko222: we only answer algebra questions formulated in heroic couplets or hexameters
08:54:39 <benmachine> pokoko222: with matrices
08:54:53 <Beelsebob1> sm: it is indeed, shame it doesn't have the same "you're in a monadness" that ghci does
08:55:06 <pokoko222> benmachine u mean brute force with two for loops?
08:55:09 <dancor> sm: they should at least make a show instance of IO a that is like "io not allowed here"
08:55:11 <pokoko222> talking imperatively
08:55:13 <benmachine> ((a1 b1) (a2 b2))(x y) = (c1 c2)
08:55:21 <benmachine> then you just find the inverse of the 2x2 matrix on the left
08:55:29 <benmachine> "just"
08:55:36 <ddarius> merijn: Well, fixity is irrelevant for prefix application (clearly).  But "application" is the operation implied by juxtaposition.
08:56:14 <chrisdone> sm: yeah, it's quite strict on time limits. sometimes an eval happens when my computer's doing something heavy so it takes longer and gets killed. I may end up popping it on a linode server
08:56:15 <benmachine> hmm my notation is weird
08:56:16 <pokoko222> bemachine nah forget the haskell solution i am talking in general solutions
08:56:22 <merijn> ddarius: Well, I beg to differ on the "clearly" part of that. But I guess I just need to read up on function application and fixity again
08:56:24 <pokoko222> although i did not understand yours
08:56:32 <benmachine> pokoko222: mine was not specific to haskell
08:56:41 <merijn> pokoko222: His solution WAS the general solution for solving equation systems
08:56:51 <benmachine> pokoko222: are the equations linear?
08:56:59 <pokoko222> benmachine yes
08:57:01 <sm> chrisdone: in the lists intro, it seems you introduce two concepts at once, might be a little easier to do one at a time ( a:[] = [a], and [char] = "string" )
08:57:11 <benmachine> then you use matrix methods
08:57:12 <gwern> chrisdone: you could increase the timeouts
08:57:20 <benmachine> I think it's called Gaussian elimination?
08:57:31 <ddarius> merijn: One way of putting it is all you really need to know is, in an expression context, f x is always the same as (f x)
08:57:34 <sm> chrisdone: it gave the warning after I typed > (1,"2")
08:57:42 <benmachine> http://en.wikipedia.org/wiki/Gaussian_elimination
08:58:34 <chrisdone> gwern: I think I made it a bit lower than mueval's default after some fiddling, but I can give it more leeway
09:00:53 <pokoko222> benmachine i know what you talk about but i cant do it algorithmically
09:00:56 <chrisdone> sm: good point maybe I can separate the (:) concept from string syntax
09:01:16 <gwern> (goo@hoogle cmd
09:01:20 <gwern> @hoogle cmd
09:01:20 <lambdabot> Network.Socket data ShutdownCmd
09:01:33 <gwern> @hoogle String -> IO ()
09:01:33 <lambdabot> Prelude putStr :: String -> IO ()
09:01:33 <lambdabot> Prelude putStrLn :: String -> IO ()
09:01:33 <lambdabot> System.IO putStr :: String -> IO ()
09:01:36 <benmachine> pokoko222: well, I've not done it myself so I can't help you any further
09:01:50 <pokoko222> benmachine ok son
09:02:15 <ddarius> Usually an LU decomposition is better than fully inverting a matrix.
09:07:25 <yaru1022> Hi, I found something strange in this code...
09:07:34 <yaru1022> let recur = [1] ++ concatMap (\x -> if x < 5 then [x+1] else []) recur
09:07:47 <yaru1022> why would that fall into infinite recursion?
09:07:55 <ddarius> It does.
09:07:57 <yaru1022> I expect it to stop after 5
09:08:51 <yaru1022> Does anybody know why..?
09:08:59 <ddarius> > fix ((1:) . concatMap (\x -> if x < 5 then [x+1] else []))
09:09:03 <lambdabot>   mueval-core: Time limit exceeded
09:09:19 <ddarius> > take 3 $ fix ((1:) . concatMap (\x -> if x < 5 then [x+1] else []))
09:09:20 <lambdabot>   [1,2,3]
09:09:33 <ddarius> > take 5 $ fix ((1:) . concatMap (\x -> if x < 5 then [x+1] else []))
09:09:34 <lambdabot>   [1,2,3,4,5]
09:09:40 <ddarius> > take 6 $ fix ((1:) . concatMap (\x -> if x < 5 then [x+1] else []))
09:09:43 <lambdabot>   mueval-core: Time limit exceeded
09:10:02 <yaru1022> Is it supposed to be like that?
09:12:04 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23093#a23093
09:12:06 <gwern> tres charmant
09:12:13 <gwern> behold my patch-tag downloader
09:12:23 * benmachine likes Nothing Nothing Nothing Nothing Nothing
09:12:28 <gwern> 4 or 5 lines
09:12:36 <ddarius> yaru1022: When it return [], it catches up with itself.
09:13:15 <chrisdone> I wrote the bidding process on a C# .net ebay-like web site as one pure function. it takes the bidding state and returns a new bidding state. as a result it's testable, isolated/easy to understand, easy to plugin to a page for manual experimentation, and doesn't have any actual side-effects to care about. delicious pure code
09:13:40 <ddarius> yaru1022: However, just evaluate.  Change the bound to 1 so that it comes up quicker and go through step by step.
09:14:00 <mreh> is there an equiv sizeof in haskell98? I'd like to calculate the approx memory footprint
09:16:17 <roconnor> > sizeOf (0::Int)
09:16:18 <yaru1022> ddarius, so how would I get around this problem then? Is there an obvious fix?
09:16:18 <lambdabot>   Not in scope: `sizeOf'
09:16:44 <mreh> sizeOf!
09:16:47 <roconnor> > bitSize (0::Int)
09:16:48 <lambdabot>   64
09:17:08 <mreh> > bitSize (undefined::Bool)
09:17:09 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
09:17:09 <lambdabot>    arising from a use of `Da...
09:17:20 <mreh> <:(
09:17:40 <McManiaC> can you put the "-l..." flag in something like "ghc --make Foo.hs -lfoo" into a .hs header?
09:17:55 <gwern> OPTIONS_GHC, innit it?
09:18:47 <McManiaC> {-# OPTIONS_GHC -lpurple -lglib-2.0 #-}
09:18:48 * gwern feels satisfied. what a pleasant little bit of haskelling
09:18:48 <McManiaC>  ?
09:18:59 <gwern> looks good to me. does it work?
09:19:02 <McManiaC> nope
09:19:08 * hackagebot MagicHaskeller 0.8.5 - Automatic inductive functional programmer by systematic search  http://hackage.haskell.org/package/MagicHaskeller-0.8.5 (SusumuKatayama)
09:19:21 <gwern> ah! and years of persistence pay off!
09:19:35 <gwern> I first emailed susumu about uploading magichaskeller back in, like, 2998
09:19:47 <gwern> (good day indeed)
09:19:54 <McManiaC> ? ^^
09:19:55 <Polarina> Can I somehow catch an exception thrown by pure code in pure code by then returning something of an compatible type instead?
09:20:04 <mreh> catch
09:20:06 <Lemmih> gwern: 2998 will indeed be a good year.
09:20:10 <Polarina> Preferably without using unsafePerformIO.
09:20:18 <McManiaC> hehe
09:20:21 <gwern> Lemmih: I particularly liked the winter wine that year
09:20:29 <ddarius> recur -> 1:concatMap (\x -> if x < 1 then [x+1] else []) recur -> 1:concatMap (\x -> ...) (1:tail recur) -> 1:concat (map (\x -> ...) (1:tail recur)) -> 1:concat ([]:map (\x -> ...) (tail recur)) -> 1:([] ++ concatMap (\x -> ...) (tail recur)) -> 1:concatMap (\x -> ...) (tail recur)
09:20:33 <mreh> 1998... I was but a small boy
09:20:40 <ddarius> So you get tail recur = concatMap (\x -> ...) (tail recur)
09:20:44 <gwern> the blood of the slave earthlings sweetened it even further
09:20:58 <mreh> oh, 2998
09:21:13 <benmachine> Polarina: you can't catch exceptions in pure code without someone using unsafePerformIO, but that someone can be not-you if you use the spoon package
09:21:18 <mreh> the year of the vargon invasion
09:21:30 <Polarina> benmachine, :(
09:21:48 <benmachine> Polarina: what kind of exception anyway?
09:22:00 <Polarina> benmachine, ArithException, Overflow.
09:22:01 <benmachine> mostly you should have functions that don't throw exceptions when used properly
09:22:06 <benmachine> hmm
09:22:28 <benmachine> don't divide by zero?
09:24:04 <Polarina> benmachine, it's a function I made that takes Integer and returns String with literal representation of that number (127 -> one hundred twenty-seven), and throws that exception because it cannot handle numbers larger than 1e+2703.
09:24:20 <benmachine> make it return Maybe instead
09:24:29 <benmachine> Maybe is basically a pure exception
09:24:41 <Polarina> That would work, but it's using recursion.
09:25:21 <benmachine> well, then you use the fact that Maybe is a functor
09:25:25 <benmachine> or maybe a monad if necessary
09:25:39 <Polarina> benmachine, I was thinking of something like that, just trying to find out where to begin.
09:28:36 <Polarina> benmachine, do you got a link to an example? :)
09:28:44 <ddarius> > let recur = 1:takeWhile (< 5) (map (1+) recur) in recur
09:28:45 <lambdabot>   [1,2,3,4]
09:29:38 <ddarius> > let recur = 1:map (1+) (takeWhile (<5) recur) in recur
09:29:39 <lambdabot>   [1,2,3,4,5]
09:30:55 <yaru1022> ddarius, hm.. I see. I guess I have to think about how to apply that type of solution to my code.
09:31:01 <yaru1022> ddarius, thanks for your insight though =)
09:32:56 <knightmare01> hey guys somebody told me haskell is a good language to learn to program, were they right?
09:33:17 <MissPiggy> yes
09:33:29 <yaru1022> lol
09:33:49 <Rotaerk> nah, it's a better means of learning to cook
09:33:59 <Jafet> Maybe.
09:33:59 <mreh> sarcasm
09:34:18 <mreh> it's a great first language
09:34:19 <knightmare01> i mean, the source is kind of meh, so i wasn't sure if they were giving me bad information
09:34:25 <knightmare01> for lulz
09:34:39 <Twey> So you came to #haskell for an unbiased second opinion?  ;)
09:34:43 <MissPiggy> I think they are right
09:34:57 <Twey> There are certainly many worse languages to start with.
09:35:00 <krainboltgreene> knightmare01: It's good if you're naturally inclined toward math.
09:35:03 <knightmare01> i came here more to find out that if its my first language, am i in waaaaay over my head
09:35:07 <merijn> knightmare01: I'm not sure how it works as a first language (most people seem to start with imperative languages). But I do think learning a functional language is crucial to becoming a good programmer
09:35:12 <Rotaerk> at least you aren't trying to start with C++
09:35:15 * Rotaerk shudders.
09:35:20 <Twey> Aye to that
09:35:31 <MissPiggy> I don't find haskell much at all like math
09:35:39 <mreh> hahahaha
09:35:45 <knightmare01> well i got this book and it says you just glue functions together
09:35:47 <knightmare01> sounds pretty cool
09:35:52 <merijn> knightmare01: I recommend just trying and starting with Haskell, if you find yourself getting completely stuck I'd recommend switching to python to learn programming first and then come back to haskell after that
09:35:58 <MissPiggy> apparently that's funny?
09:36:08 <mreh> MissPiggy: why mention it?
09:36:11 <monadic_kid> knightmare01>: function composition
09:36:12 <krainboltgreene> Knightmare01:My suggestion list is always: Ruby -> Python -> Haskell -> erlang
09:36:18 <MissPiggy> mreh what are you laughing at
09:36:37 <Drk-Sd> krainboltgreene: ?
09:36:40 <mreh> not you, just the way you phrased what you said
09:36:56 <krainboltgreene> Drk-Sd ? what
09:37:08 <Drk-Sd> nothing.
09:37:10 <MissPiggy> odd that you feel the need to make it known to me that my writing style is so hilarious
09:37:21 <merijn> krainboltgreene: I wouldn't bother learning both ruby and python, they're pretty much the same (I think python has cleaner syntax making it more sensible for beginners)
09:37:23 <monadic_kid> knightmare01: "glue functions together" usually when people say that they are talking about function composition
09:37:30 <mreh> you'll survive
09:37:37 <krainboltgreene> Bwahaha.
09:37:39 <monadic_kid> knightmare01: http://learnyouahaskell.com/
09:37:42 <MissPiggy> mreh, yeah it's just kind of obnoxious and irritating
09:37:45 <knightmare01> yea thats the book i have monadic
09:37:55 <knightmare01> thats what linked me here
09:38:06 <krainboltgreene> merijn: You think that Ruby and Python are the same, and that Python is clearn syntax? Mmmm
09:38:27 <mreh> that's my name, don't rub it out
09:38:37 <monadic_kid> knightmare01: there is also a wikibook which is decent read
09:38:55 <monadic_kid> knightmare01: http://en.wikibooks.org/wiki/Haskell
09:38:55 <krainboltgreene> Ruby is more human readible, it has a good list of educators that are kind and patient. Python is similar enough to ruby, but more functional when you get deeper.
09:39:09 <merijn> krainboltgreene: As far as I'm aware the only real difference is that ruby has anonymous blocks.Which can be useful, but then I might as well just use lisp instead of ruby
09:39:21 <Jafet> ruby is a ripoff of python which is a ripoff of scheme which is a useless academic language with no libraries or web frameworks
09:39:26 <Twey> mreh: Your name is âobnoxious and irritatingâ?  ;)
09:39:39 <mreh> did someone say my name?
09:40:00 <krainboltgreene> merijn: You might as well be saying that England is the same as America.
09:40:08 <knightmare01> alright, i guess im going to learn me a haskell then =]
09:40:09 <mreh> it isnt?
09:40:12 <krainboltgreene> Or rather, the UK.
09:40:22 <cebewee> krainboltgreene: as i thought about learning ruby, i really missed good (reference) documentation
09:40:47 <cebewee> (which was a few years ago, so this might have changed)
09:40:49 <merijn> krainboltgreene: When you look at the underlying programming structure they are the same. The difference between python and ruby is trivial compared to difference between lisp, C, python and haskell...
09:40:51 <krainboltgreene> cebewee: Lack of ref documentaion is a serious ruby disease.
09:40:58 <krainboltgreene> And no, it hasn't changed much :(
09:41:13 <krainboltgreene> merijn: Are you an engineer?
09:41:15 <cebewee> sad :/
09:41:20 <Twey> Mmm, difficult one that.  Ruby is the one with the total lack of culture, but also the one with assorted unrelated knobs tacked on that don't really have much to do with one another, or get along very well.  :Ã¾
09:41:32 <merijn> krainboltgreene: No? I'm a CS major
09:41:45 <mreh> what is haskell culture?
09:41:49 <krainboltgreene> merijn: Ok, then it makes sense.
09:42:07 <merijn> mreh: Academics and people who like inventing overcomplicated abstractions? :D
09:42:25 <krainboltgreene> Twey: Ruby has a more culture than most languages, including C and Python. They just have *larger* communites.
09:42:54 <MissPiggy> mreh for someone who cares so much about people saying something that might be misinterpreted as rude you don't seem to worry too much about things you say
09:43:10 <krainboltgreene> If you really want to look at the differences between Python and Ruby, look at Sinatra and Rake.
09:43:14 <merijn> krainboltgreene: My point is that if you learn python you could probably start programming Ruby after a day or so (maybe less) of studying syntax (and vice versa)
09:43:30 <MissPiggy> mreh: I'm just kind of hinting at the idea that going "hahahahaha" when someone says something serious is less than nice
09:43:32 <krainboltgreene> Beautiful clean syntax like in Sinatra and Rake simply isnt possible in Python.
09:43:55 <mreh> why are we discussing Python in #haskell?
09:44:03 <mreh> could we please take it -blah
09:44:23 <krainboltgreene> merijn: I actually agreee with that, they are syntactically similar. However, since Ruby is more human readabile people have an easier time learning it as their first langauge (in my eperience.
09:44:52 <krainboltgreene> 1. What is "-blah", 2. No one ist alking about Haskell so this is filling the silence.
09:45:19 <mreh> #haskell-blah
09:45:21 <merijn> krainboltgreene: #haskell-blah is the off-topic channel for #haskell (and we did get sorta side-tracked)
09:45:27 <mreh> thanks
09:45:48 <krainboltgreene> Oh, another channel. No thanks.
09:45:48 <merijn> I need to go back to working on my compiler anyhoo
09:45:52 <mreh> peoples haskell questions tend to get lost in the misc.
09:46:02 * krainboltgreene somehow doubts that.
09:46:26 * MissPiggy is not quite sure why mreh it taking upon themselves to boss people around
09:46:26 <mreh> please respect our rules
09:46:42 <mreh> MissPiggy: I'm sorry I hurt your feelings
09:46:52 <krainboltgreene> Where are the rules at?
09:47:21 <MissPiggy> krainboltgreene, I wouldn't worry about it mreh is relatively new and used to other much more draconian IRC channels
09:47:21 <mreh> we do not have a written constitution, just a long history of legal precedent
09:47:46 * mreh sighs
09:48:07 <krainboltgreene> Don't worry Mreh, I wont hold it aginst you. Everyone gets a little bossy sometimes.
09:48:15 <tumult> haha
09:48:43 <mreh> woah... do I feel like the social pariah
09:49:09 <mreh> could we please get back on topic
09:49:25 <krainboltgreene> We're on IRC talking about programming languages. I'm pretty sure we're all social pariahs :D
09:49:26 <Tarrasch> mreh - At what age did this behavior start?
09:49:50 <tumult> no way, i'm pimp
09:49:59 <krainboltgreene> Except tumult, he's pimp.
09:50:03 <Tarrasch> tumult - you're mom said so :p ?
09:50:05 <merijn> tumult: Pimp, programmer, what's the difference?
09:50:14 <Tarrasch> your*
09:50:31 <opqdonut> shouldn't that be: pimp, manager, what's the difference?
09:51:57 * RayNbow pimps his lambdas
09:53:39 <mreh> god, I love memocombinators now
09:53:47 <mreh> I used to be afraid of them
09:54:05 <tumult> memo :: UArray Int Int16
09:54:08 <tumult> :(
09:54:34 <mreh> I just discovered how you can memo parts of functions by wrapping up an argument in a memo combinator
09:58:30 <evanbd> I'm having trouble getting cabal to work (trying to install things causes dependency errors).  Can anyone help?  I'm on Debian Squeeze.
10:00:03 <jkingkong> how would i convert a list of strings to doubles
10:00:10 <Zao> read?
10:00:13 <evanbd> It says I have base-3.0.1.0 installed, and things need 4.*
10:00:18 <jkingkong> well you need to specify the datatype
10:00:30 <Zao> @type map (read :: String -> Double)
10:00:30 <lambdabot> [String] -> [Double]
10:00:31 <MissPiggy> :t map (read :: String -> Double)
10:00:32 <lambdabot> [String] -> [Double]
10:00:43 <jkingkong> oh i see thanks
10:00:44 <Twey> > map read ["3", "4.0", "-5.6"] :: [Double]
10:00:45 <lambdabot>   [3.0,4.0,-5.6]
10:00:46 <carnieri> > map (read :: String -> Double) ["1.2", "3.4"]
10:00:47 <lambdabot>   [1.2,3.4]
10:00:53 <jkingkong> i tried twey's way
10:00:59 <MissPiggy> @quote contra
10:00:59 <lambdabot> Makoryu says: < roconnor > I keep coming back to #haskell and thinking there is an online boxing game written in haskell. (regarding frequent spamvertiser) < Makoryu > Maybe it could be in contrast
10:00:59 <lambdabot> to online unboxing, rather than offline boxing...
10:01:04 <jkingkong> it didn't like it for some reason
10:01:20 <Twey> You did it wrong
10:01:41 <jkingkong> i must have
10:01:44 <Zao> It's a bit limited though, as it fails on fine literals like ".3", "0.3f", etc.
10:02:56 <jkingkong> x= map read ((lines inf) :: [Double])
10:03:16 <MissPiggy> jkingkong,
10:03:17 <jkingkong> it gives me couldn't match expected type 'Double' against inferred type '[Char]'
10:03:18 <MissPiggy> no
10:03:21 <evanbd> check your parentheses
10:03:32 <aavogt> yeah, get rid of the outer ones
10:04:05 <jkingkong> thanks :P
10:04:13 <evanbd> (lines inf) is type [String], not [Double]
10:05:52 <jkingkong> yea
10:06:37 <evanbd> Anyone using Cabal on Debian?  Any idea why I get weird dependency errors, or how to fix them?
10:08:15 <byorgey> evanbd: what sorts of weird dependency errors?
10:08:46 <evanbd> byorgey: When I try to install things, it says I have base-3.0.1.0 installed, and it needs 4.*
10:09:10 <evanbd> byorgey: And it won't install a new version of base ("cabal: internal error: impossible")
10:09:34 <byorgey> evanbd: base 4.* comes with ghc-6.10+
10:09:42 <byorgey> base 3.* goes with ghc 6.8 and before
10:10:09 <byorgey> if you're trying to install something requiring base-4 you'll need to install a newer version of ghc
10:10:16 <byorgey> in which case I recommend installing the Haskell Platform
10:10:50 <byorgey> evanbd: cabal-install won't install a newer version of base because without upgrading ghc this would cause everything to break =)
10:11:36 <evanbd> Lovely.
10:12:14 <byorgey> evanbd: unfortunately Debian's native packages for ghc are rather old.
10:12:20 <evanbd> And the version of ghc6 in sid (yuck) is 6.12, which hackage shows as producing a build error on the package I wanted to try (dimensional).
10:12:55 <byorgey> evanbd: well, on the one hand, sometimes hackage reports spurious build errors, but I don't know about dimensional in particular
10:13:07 <byorgey> 6.12 is pretty new, I wouldn't upgrade to it yet
10:13:16 <aavogt> no, dimensional builds with 6.12
10:13:25 <byorgey> the kinks are still getting worked out with respect to library compatibility
10:13:31 <evanbd> aavogt: Oh, weird.
10:13:43 <aavogt> well it fails on building docs I believe
10:13:44 <byorgey> ghc 6.12 itself is great though.
10:14:21 <chrissbx> How do you debug a stack overflow?
10:14:39 <mreh> chrissbx: are you summing a big list?
10:14:45 <chrissbx> no
10:14:54 <chrissbx> I suspect I've got a cycle somewhere
10:14:59 <HugoDaniel> im using 6.12 for my pet projects and 6.10 for production stuff
10:15:03 <aavogt> ghci debugger can sometimes help
10:15:39 <chrissbx> I've got 6.8.2, is this good for debugging?
10:15:44 <mreh> chrissbx see Debug.Trace also
10:16:10 <mreh> testing code fragments in isolation in GHCi normally works for me
10:16:57 <chrissbx> That's what I'm doing but I'd be glad to see where it stacks up things.
10:18:13 <ddarius> @hoogle fix
10:18:14 <lambdabot> Data.Function fix :: (a -> a) -> a
10:18:14 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
10:18:14 <lambdabot> module Control.Monad.Fix
10:22:06 <millertime> dons: i was told to ask you about a haskell error im getting :)
10:23:09 <Polarina> Is there a shorthand version of (\x y -> x ++ "-" ++ y)?
10:24:59 <sepp2k> (++).(++"-")
10:25:14 <medfly> @pl (\x y -> x ++ "-" ++ y)
10:25:14 <lambdabot> (. ('-' :)) . (++)
10:25:29 <Polarina> o.O
10:25:32 <Polarina> Thanks.
10:25:34 <aavogt> (\x y -> x ++ '-':y)
10:27:11 <Beelsebob1> Polarina: intercalate "-" [x,y]
10:27:20 <Polarina> Beelsebob1, :D
10:27:35 <Beelsebob> somewhat nicer than the other suggestions
10:28:18 <millertime> anyone mind lookin at an error i got following a tutorial from haskell.org
10:28:19 <DerisionSnort> :t intercalate
10:28:20 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:28:36 <millertime> http://pastie.org/846970
10:29:03 <Beelsebob> millertime: what's the error?
10:29:43 <millertime> ambiguous type variable 'b' in contraint 'Exception b' arising from use of catch. line 25
10:29:58 <millertime> constraint*
10:33:01 <aavogt> this is because Control.Exception has changed
10:33:10 <aavogt> you could import Control.OldException
10:33:37 <aavogt> oh, that's already mentioned in that code
10:33:48 <ddarius> concat [x,"-",y]
10:33:53 <millertime> yeah the tutorial mentioned there is a base-3 and a base-4
10:33:59 <millertime> didnt know which was which
10:34:08 <Tarrasch> @paste
10:34:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
10:34:20 <aavogt> well your fix is to use the other import
10:34:34 <millertime> alrighty :)
10:34:54 <Tarrasch> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8125#a8125
10:34:58 <aavogt> hmm, and the code that uses the new exceptions is also commented out....
10:35:06 <aavogt> Tarrasch: no
10:35:24 <Tarrasch> aavogt, is there any way to make them the same :s ?
10:35:27 <millertime> i commented out the part the tutorial showed
10:36:00 <aavogt> Tarrasch: well for your example it doesn't matter, but if you need it, look into -XScopedTypeVariables
10:36:20 <Tarrasch> aavogt, thanks :)
10:38:35 <millertime> "not in scope: data constructor 'SomeException'"
10:39:44 * Polarina wonders why (++"-"++) results in a parse error.
10:40:17 <blueonyx> @type  (++"-"++)
10:40:18 <lambdabot> parse error on input `)'
10:40:29 <blueonyx> @type  ((++"-")++)
10:40:30 <lambdabot> ([Char] -> [Char]) -> [Char] -> [Char]
10:40:40 <Polarina> Oddities.
10:40:58 <Beelsebob> Polarina: because one of the (++)es needs to be fully applied
10:41:04 <Polarina> I see.
10:42:05 <aavogt> double-sided sections for associative operators?
10:45:11 <ddarius> blueonyx: That's abusing lambdbot's generalized definition of (++)
10:45:13 <ddarius> :t (++)
10:45:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:45:26 <Tarrasch> aavogt, seems like I just could've remoed the type signature :p
10:49:16 <chrisdone> what does it mean when a process is a "zombie" waiting on channel "do_exit"?
10:49:31 <chrisdone> I'm on ubuntu and that's what I see in my system monitor
10:49:53 <millertime> didnt reap your children!
10:50:13 <Polarina> chrisdone, it means the process died a horrible death, but something's preventing the body from being cleaned up.
10:51:26 <chrisdone> Polarina: the process is being "killed" by rlimits. does this commonly cause zombies?
10:52:13 <Polarina> chrisdone, if the process refuses to "collaborate" when rlimit tries to kill it, it becomes a zombie.
10:53:39 <chrisdone> Polarina: can I remove the head or destroy the brain, as it were?
10:53:57 <chrisdone> Polarina: I notice the process buggers off when the parent process ends
10:54:36 <Polarina> chrisdone, kill -9 <pid>
10:55:14 <Polarina> chrisdone, that will drop a nuclear bomb on the process in a contained field as to not cause any external damage.
10:55:51 <chrisdone> ah, I just read this: "A zombie process doesn't react to signals because it's not really a process at all- it's just what's left over after it died. What's supposed to happen is that its parent process was to issue a "wait()" to collect the information about its exit. If the parent doesn't (programming error or just bad programming), you get a zombie. The zombie will go away if its parent dies- it will be "adopted" by init which will do
10:55:51 <chrisdone> the wait()- so if you see one hanging about, check its parent; if it is init, it will be gone soon, if not the only recourse is to kill the parent..which you may or may not want to do."
10:55:52 <Polarina> chrisdone, sometimes, but rarely, it might survive the nuclear bomb, then there's little as nothing you can do.
10:56:31 <Polarina> :)
10:56:32 <chrisdone> I'm not issuing waitForProcess in the parent (I didn't realise that was necessary if the process ended itself). I'll do that
10:57:02 <eldragon> chrisdone, then it's a problem for kill -9 to a zombie process, this zombie process doesn't process the signal SIGKILL.
10:57:22 <mreh> If I need to memoize a constant, how could one achieve that?
10:57:37 <Polarina> chrisdone, kill -9 doesn't throw a signal.
10:58:08 <Heffalump> mreh: x = 5
10:58:21 <chrisdone> Polarina: issuing waitForProcess did the trick
10:58:29 <chrisdone> Polarina: doesn't kill -9 throw a SIGKILL?
10:58:33 <mreh> Heffalump: more along the lines of a computationally complex value
10:58:56 <mreh> something defined functionally because it's less code than writing it out in ful
10:58:58 <Polarina> chrisdone, I doubt that it does.
10:59:32 <chrisdone> Polarina: I just read the man page, it sends KILL
10:59:35 <chrisdone> "KILL       9   exit      cannot be blocked"
10:59:39 <Polarina> Weird.
11:00:34 <chrisdone> it was the tryhaskell mueval process. when it dies and gets restarted, I wasn't cleaning up properly so I had a load of zombies taking over :D
11:02:44 <nomeata> Hi. I just reserved two beds in the City Backpacker for ZÃ¼riHac. Is there another group of attendees who are up to four persons, so that I can ask the hostel to put us in the same room?
11:03:08 <chrisdone> attending what?
11:03:20 <nomeata> The hackathon in ZÃ¼rich in March.
11:04:08 <jutaro> nomeata: I will be in ZÃ¼rich to. Maybe you can help me with packaing Leksah for Debian?
11:04:21 <nomeata> jutaro: Sure!
11:04:24 <medfly> do you really want to sleep with a bunch of random haskellers in the same room?
11:04:59 <Heffalump> nomeata: check the darcs wiki page about the hackathon
11:05:12 <jutaro> nomeata: That's great! Looking forward to meet you again
11:06:07 <nagnatron> medfly: possibly better than random people in a hostel
11:06:21 <ddarius> Haskellers are kinda weird...
11:06:32 <Polarina> :-)
11:06:42 <mreh> some of us have normal lives
11:06:47 <chrisdone> medfly: enterRoom (sort haskellers) >>= sleepWith
11:06:48 <mreh> in our minds
11:07:34 <chrisdone> @seen peaker
11:07:34 <lambdabot> Unknown command, try @list
11:07:40 <chrisdone> preflex: seen peaker
11:07:40 <preflex>  peaker was last seen on ##c 6 days, 21 hours, 44 minutes and 57 seconds ago, saying: Mehdi, maybe ask ##posix
11:07:42 <mreh> foldr spoon medfly haskellers
11:07:52 <medfly> :(((
11:07:56 <chrisdone> mreh: hahaha
11:09:28 <mreh> can I not explicitly expand a functional value at the top level then?
11:09:47 <chrisdone> mapM (dance >>= takePictures) . permutations $ haskellers
11:09:54 <mreh> it's kind *, so it just needs expanding to RNF
11:10:10 <chrisdone> woops, I meant >=>
11:10:17 <chrisdone> good old fish
11:11:38 <chrisdone> :t (>=>)
11:11:39 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:11:49 <chrisdone> best. operator. ever
11:12:09 <mreh> Kleiski Arrow, aka fish
11:12:36 <mreh> @google Kleiski Arrow
11:12:37 <lambdabot> No Result Found.
11:13:01 <mreh> Kleisli
11:13:36 <mauke> daisuki arrow
11:13:51 <chrisdone> ^=^
11:20:11 <Polarina> Which is better: "notnull a@(_:_) = True" or "notnull a | not . null $ a = True"?
11:20:40 <edwardk> notnull = not . null ?
11:21:12 <Polarina> edwardk, my situation is a bit tighter, trying to simplify.
11:21:37 <edwardk> personally i'd probably go with something like the former, without the superfluous a@
11:21:46 <edwardk> notnull (_:_) = ...
11:21:58 <Polarina> Forgot to mention that I need the "a". :)
11:22:13 <edwardk> then definitely the former
11:22:22 <Polarina> Thanks.
11:22:24 <ddarius> Perhaps you should provide the code you are actually working with...
11:22:27 <damd> your second case is btw just a lengthier version of notnull = not . null
11:22:56 <ddarius> damd: No it isn't.
11:22:56 <edwardk> damd: i presume the method is much longer, but needs to handle the cons case separately
11:23:21 <damd> ddarius: how is it not?
11:23:22 <MissPiggy> what's wrong with not . null ?
11:23:31 <ddarius> damd: Both of Polarina's definitions are non-exhaustive.
11:23:43 <edwardk> MissPiggy: "Polarina: edwardk, my situation is a bit tighter, trying to simplify."
11:23:49 <damd> ddarius: i'm assuming that the rest of the definitions was omitted for brevity
11:23:56 <MissPiggy> le tssee the real thing
11:24:18 <mauke> le tssÃ©e
11:24:26 <Polarina> All right, I'll paste it in a moment. :)
11:26:56 <Polarina> http://codepad.org/mihLgOHR
11:27:12 <MissPiggy> hehe
11:27:17 <Polarina> :-)
11:27:26 <MissPiggy> ninteen ?
11:27:48 <Polarina> MissPiggy, so said my spell checker.
11:27:56 <zygoloid> @wn nineteen
11:27:59 <lambdabot> *** "nineteen" wn "WordNet (r) 2.0"
11:28:00 <lambdabot> nineteen
11:28:00 <lambdabot>      adj : being one more than eighteen [syn: {19}, {xix}]
11:28:00 <lambdabot>      n : the cardinal number that is the sum of eighteen and one
11:28:00 <lambdabot>          [syn: {19}, {XIX}]
11:28:04 <MissPiggy> that's interesting
11:28:11 <MissPiggy> I wonder if it's the correct spelling in another language
11:28:22 <Polarina> I'll change it then, thanks.
11:28:27 <zygoloid> @wn ninty
11:28:28 <lambdabot> No match for "ninty".
11:28:34 <zygoloid> :D
11:28:37 <Polarina> But see line 23 for that notnull thing.
11:29:31 <mreh> http://markmail.org/message/6w6632oys2icxhsl -- this what I've been getting at
11:29:34 * zygoloid . o O ( also eww US number spelling ;-) )
11:29:39 <ddarius> Polarina: x:[] can be written [x]
11:29:43 <mreh> but this clearly isn't possible in purely FP is it?
11:29:55 <Polarina> mreh, FP?
11:30:00 <Polarina> ddarius, thanks.
11:30:07 <mreh> functional programming
11:30:16 <mreh> not the language
11:30:18 <Polarina> mreh, this is functional.
11:30:30 <mreh> yes
11:30:31 <ddarius> Polarina: Similarly for x:y:[] can be [x,y]
11:30:46 <Polarina> ddarius, I figured. Thank you.
11:30:49 <Polarina> :-)
11:30:57 <mreh> Polarina: I wasn't responding to that
11:31:05 <ddarius> Polarina: Don't use fromInteger.  Use fromIntegral.
11:31:07 <MissPiggy> Polarina, I would put 'numbers' into a file on its own
11:31:33 <MissPiggy> with a comment about the exact details of what's allowed
11:31:37 <Polarina> ddarius, what's the significance?
11:32:28 <copumpkin> Dirichlet's theorem is neat
11:32:32 <MissPiggy> so what is 'dot' exactly?
11:32:39 <Polarina> MissPiggy, just some name.
11:32:55 <MissPiggy> you have defined a function called dot
11:33:00 <MissPiggy> what is that function?
11:33:18 <Polarina> MissPiggy, it does the "magic", it's what foldM calls while folding.
11:33:54 <MissPiggy> > let x = "abcxyz" in transpose [x,tail x]
11:33:55 <lambdabot>   ["ab","bc","cx","xy","yz","z"]
11:33:58 <ddarius> Polarina: Consistency, there is no reason to ever use fromInteger.  Furthermore, I'm not sure if the rewrite rules are written for fromInteger, though they probably are as well.
11:34:31 <MissPiggy> Polarina: you have not supported 'and' like one hundred /and/ twenty two
11:34:33 <Polarina> rewrite?
11:34:47 <Polarina> MissPiggy, I know, american english.
11:35:34 <ddarius> There are no "ands" in (proper) American English pronunciation of numbers.
11:35:48 <MissPiggy> Polarina, ooh I did not know about this!
11:35:55 <MissPiggy> interesting ddarius
11:36:04 <MissPiggy> I have actually never noticed this
11:36:19 <ddarius> Well, I'm pretty sure either form is widely accepted nowadays.
11:38:05 <MissPiggy> Polarina: it seems to me that numbers could be subdivided -- since the numbers like 'one' have a different meaning than ones such as 'hundred'
11:38:42 <MissPiggy> Polarina, or maybe adding some kind of attributes to them like numbers of the sort you can prefix etc etc
11:39:07 <Polarina> MissPiggy, could you elaborate, please?
11:39:45 <MissPiggy> Polarina, well it makes sense to say   three hundred (for 300),  but you can't say   three ten (for 30)  or  three seven (for 21)
11:40:13 <MissPiggy> Polarina, but the list 'numbers' does not reflect that structurally -- and that is one way I find bugs can creep in
11:41:25 <Polarina> MissPiggy, ordering matters. :)
11:41:53 <Polarina> MissPiggy, at least that's how I thought it out.
11:42:07 <MissPiggy> oh I was meaning that you could split it into two lists (or more) rather than shuffle it around
11:42:28 <Polarina> MissPiggy, what do you mean?
11:42:52 <MissPiggy> did you see what i mean about how hundred is a different kind of word than seven?
11:43:02 <MissPiggy> (because you can prefix another number to it)
11:43:03 <Polarina> Yes.
11:43:27 <Polarina> I got guards in line 25 and 26 that differentiate, but I would've liked to make it better.
11:43:45 <MissPiggy> so I was thinking that you have  base numbers  with one and seven and such in it,  and then  free numbers  with things like hundred in it
11:44:05 <MissPiggy> oops got those mixed up
11:44:19 <MissPiggy> free numbers are ones like "one" and "seven", base numbers are liek "hundred" and similar
11:44:39 <edwardk> shouldn't num2wstr 0 = Just ["zero"] ?
11:44:55 <langtree> We're making a number to string thing ?
11:45:04 <Polarina> edwardk, then it would recurse infinitely.
11:45:09 <Polarina> langtree, yes.
11:45:15 <edwardk> Polarina: i didn't see that it was being used by itself
11:45:21 <edwardk> makes sense
11:45:32 <edwardk> so it needs a wrapper basically
11:45:42 <Polarina> edwardk, well, it wouldn't resure infinitely, but you would then get "twenty zero".
11:46:50 <Polarina> edwardk, yes, a wrapper.
11:47:06 <edwardk> Polarina: yes, what i mean is you need something like num2str x | Just [] <- y = Just ["zero"] | otherwise = y
11:47:09 <edwardk> *nods*
11:47:21 <edwardk> er 'where y = num2wstr x =)
11:57:51 <stevenmarky> ~
12:01:08 <Kruppe> Can anyone tell me what the type singature of 'a' is in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23096#a23096 ? I've tried a few different things but I'm having trouble figuring it out.
12:03:01 <MissPiggy> Krugge, the thing is..
12:03:10 <MissPiggy> runST has this special 's' parameter
12:03:37 <MissPiggy> so to write a sig for a you must use _that exact s_
12:03:39 <Kruppe> has to do with existentially quantified types right?
12:03:45 <MissPiggy> and the only way to get ahold of that s is to use an extension
12:03:56 <ben> Are you sure that should not be a <- array ...
12:04:14 <Kruppe> ben: yup, im trying stuff out to understand ST better
12:04:17 <c_wraith> Kruppe: the type of a can't be derived from the code you've specified.  It could be STArray something, or STUArray, something
12:04:57 <BONUS> um
12:05:00 <MissPiggy> Kruppe, so with that signature you can do this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23096#a23097
12:05:00 <BONUS> :t Data.Array.array
12:05:01 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
12:05:06 <c_wraith> oh.
12:05:09 <McManiaC> can somebody tell me how to convert da "CInt -> IO ()" function into a Foreign.Ptr.FunPtr?
12:05:15 <McManiaC> *a
12:05:17 <MissPiggy> Kruppe -- do you want to explain how I calculated that type? (for a)
12:05:20 <c_wraith> Well.  Don't you *want* to be using an ST*Array?
12:05:20 <BONUS> its only polymorphic in the Ix i if you import Data.Array instead of IArray
12:06:13 <Kruppe> c_wraith: no actually, im just plumbing around, not actually doing anything useful
12:06:27 <MissPiggy> Kruppe (you may notice that I removed the runST too, that's just to put the type signature down)
12:06:41 <runningscared> hello people
12:06:56 <Kruppe> MissPiggy: yeah I think I get it
12:08:27 <BONUS> it takes a while until you get used to the type cleverness used in ST
12:08:38 <BONUS> but once you understand it you see it's very smart
12:09:14 <Kruppe> BONUS: yeah, something almost like magic (to me right now anyways) is happening
12:09:31 <BONUS> let me fetch some cool reading for you
12:09:31 <Kruppe> BONUS: I'll get it after a while I'm sure
12:09:42 <Kruppe> BONUS: oh... BONUS!
12:09:48 <BONUS> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_runST
12:09:49 <Kruppe> BONUS: shameless I know
12:09:56 <BONUS> hi :)
12:10:49 <Kruppe> BONUS: ah, wikibooks, very good
12:11:19 <ddarius> toForall :: (exists a. f a -> b) -> (forall a. f a) -> b; toForall pf m = open pf as (t, f :: f t -> b) in f (m [t])
12:12:14 <inverse> BONUS: You should italicize 'where' and 'let' in ch 4 of learnyouahaskell.com, I kept getting confused as to what was a english and what was haskell :s
12:12:14 <MissPiggy> ddarious, what's [t]?
12:12:17 <MissPiggy> ddarius*
12:12:23 <ddarius> MissPiggy: Type application.
12:12:27 <MissPiggy> ah
12:12:32 <BONUS> basically when you have STRef s Int, the s is there because the type system makes the s from the s in ST s Int. so when runST has a type of (forall s. ST s a) -> a, it says: if you want to get this "a", the "a" must not have any s inside its type
12:12:37 <BONUS> because only I see the s
12:12:53 <BONUS> inverse: hey, i'll do that yeah! i have a lot of error fixes that i'm gonna incorporate soon
12:13:34 <inverse> thanks
12:13:45 <BONUS> no no thank you
12:15:36 <Polarina> :-)
12:15:53 <Polarina> BONUS, having any luck with the new chapters?
12:16:06 <BONUS> hey
12:16:15 <BONUS> yeah, i know i keep saying this all the time, but they'll be up soon :)
12:16:27 <Polarina> soon = undefined -- I guess.
12:16:27 <BONUS> we're going over the old chapters now and fixing them up real good as well
12:16:30 <BONUS> so it's busy
12:16:34 <Polarina> Cool.
12:16:37 <BONUS> haha
12:21:27 <Heffalump> how are package version numbers compared?
12:22:11 <c_wraith> as integers by segment
12:22:23 <c_wraith> and an absent segment is less than any existing segment
12:22:28 <Polarina> Heffalump, data Version = {minor :: Int, middle :: Int, major :: Int} deriving (Eq, Ord)
12:22:33 <Polarina> Heffalump, just like Ord would there.
12:22:50 <Saizan> Polarina: wrong order?
12:22:50 <Heffalump> that can't be right, it would compare on minor before major
12:22:51 <Polarina> s/=/= Version/
12:22:58 <Polarina> Saizan, no, Ord takes first to last.
12:23:07 <Polarina> Oh.
12:23:09 <Polarina> I am an idiot.
12:23:31 <Heffalump> it also can't be right because versions can have more elements than three
12:23:42 <Heffalump> so you can't use all Ints
12:23:45 <Polarina> Heffalump, just an example.
12:23:50 --- mode: Heffalump set -o Heffalump
12:24:20 <Heffalump> my question was how it happens, not how it might happen :-) (I only need to know the semantics, not the precise implementation)
12:25:05 <Polarina> Sorry, no idea. :(
12:26:14 <Nereid_> Heffalump: a.b.c.d sorts like [a,b,c,d]
12:26:41 <Heffalump> ok, so a.b.c.d < a.b.c.d.e < a.b.c.(d+1), thanks
12:28:11 <MissPiggy> why don't you write a function listify a.b.c.d |--> [a,b,c,d]
12:28:19 <MissPiggy> then  x < y = listify x < listify y
12:28:42 <Berengal_> That's probably how it's done already
12:28:56 <Nereid_> http://www.haskell.org/haskellwiki/Package_versioning_policy
12:29:25 <Heffalump> Nereid_: I did read that but didn't think it answered my question precisely
12:29:31 <Nereid_> heh
12:29:42 <Heffalump> oh, so it does
12:29:53 <Heffalump> I completely missed the entire paragraph where it gives a clear example :-)
12:32:18 <Nereid_> also the doc for the Data.Version module
12:33:15 <Heffalump> ah yes, didn't know where that lived
12:38:08 <sinelaw> anyone aware of haskell bindings to v4l?
12:43:01 <chrissbx> Wow, instead of giving a stack overflow, ghc 6.8.2 would now make my program just hang (no cpu eating) if I replace "v" with ((\msg x-> x) "foo" v) in some place.
12:43:21 <chrissbx> I guess it's time for upgrading.
12:43:26 <Polarina> :)
12:43:41 * Polarina hugs ghc 6.12.1
12:44:06 <BONUS> when's ghc 6.12 going to the haskell platform, march 8, right?
12:49:05 <Polarina> Would anyone like to take a look and comment on my number to string implementation? http://codepad.org/w7tOOnxQ
12:49:20 <Polarina> BONUS, I am not certain, I'll look it up for you if you wish.
12:49:48 <BONUS> nah, i'm pretty sure it's march 8
12:50:06 <Polarina> All right. :-
12:50:07 <Polarina> :-)
12:51:18 <MissPiggy> Polarina you didn't do it?
12:51:24 <Polarina> MissPiggy, did do what?
12:52:22 <Polarina> MissPiggy, I made that program myself. :)
13:04:07 <michalisko> just starting to write parser for multi-megabyte files, should I use ByteString or is [Char] good enough to get fast parser?
13:04:26 <ddarius> Use ByteString or the textual variant if the files are text.
13:04:42 <Twey> Polarina: readMaybe = listToMaybe . fmap fst . reads
13:04:46 <michalisko> you mean ByteString.Char8?
13:05:01 <Polarina> michalisko, or do what BONUS does, use String and if it's not fast enough, try ByteString.
13:05:10 <Polarina> Twey, ?
13:05:45 <BONUS> yeah, start with String and then tweak performance as needed imho
13:05:48 <Twey> putStrLn . maybe "Not a valid number." num2wstr' =<< getLine
13:05:52 <BONUS> it's not hard to migrate from String to ByteString anyway
13:06:05 <Polarina> Twey, thanks.
13:06:24 <michalisko> thx
13:06:34 <McManiaC> how do you create C structs with the FFI?
13:06:36 <Polarina> Twey, didn't know of maybe, thanks. :)
13:06:54 <Polarina> McManiaC, you don't. You pull out bytes with proper alignment.
13:06:56 <Twey> Errrr
13:07:04 <Twey> I meant: putStrLn . maybe "Not a valid number." num2wstr' . readMaybe =<< getLine
13:07:38 <McManiaC> Polarina: any example?
13:07:49 <Polarina> McManiaC, none that I know of, sorry. :(
13:07:55 <McManiaC> :(
13:08:30 <Polarina> McManiaC, try out by using your own C functions, and start with a struct of a single element.
13:09:10 * hackagebot nonlinear-optimization 0.1 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.1 (FelipeLessa)
13:14:11 * hackagebot nonlinear-optimization 0.2 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.2 (FelipeLessa)
13:15:30 <p_l> ... fasy
13:15:35 <p_l> *fast
13:25:43 <michalisko> Polarina: ++
13:25:54 <michalisko> Polarina++
13:27:30 <Polarina> :)
13:27:51 <RayNbow> 10^9 = billion? Bah... I prefer a different naming scheme :p
13:30:54 <enthymene> RayNbow is a long-scale partisan?
13:31:05 <enthymene> 10^9 is a milliard, right?
13:31:25 * RayNbow nods
13:31:28 <enthymene> ah
13:31:33 <enthymene> I'll have to go learn that sometime
13:31:42 <enthymene> I do chat with a few other longscalers :p
13:32:21 <enthymene> although I'll just as often just read the number in some sort of notation
13:32:23 <RayNbow> although I have to admit, in English "milliard" looks a bit strange to me :p
13:32:33 <enthymene> "Ten 'e' nine." if you will
13:32:45 <enthymene> or "ten to the ninth" which is more cumbersome
13:32:55 * RayNbow is a Dutch longscaler :p
13:33:06 * enthymene is an American descaler :p
13:33:16 <burp> billard :D
13:33:24 * Twey likes ten-ee-nine
13:33:28 <Twey> 10á´9
13:33:33 <enthymene> breaking a billiard billiard balls would be hard
13:33:42 <enthymene> just imagine the side of the table
13:33:58 <enthymene> still, might be doable, if you could use a Linear Induction Motor instead of a cue.
13:34:17 <Twey> Or a railgun
13:34:18 <Polarina> > (\x y -> intercalate "-" [x, y]) <$> ["a", "b"] <*> ["c", "d"]
13:34:19 <lambdabot>   ["a-c","a-d","b-c","b-d"]
13:34:21 <Polarina> How can I modify that to produce ["a", "a-c", "a-d", "b", "b-c", "b-d"]?
13:34:28 <enthymene> that'd be the same thing, wouldn't it Twey?
13:34:51 <damd> impossible
13:34:52 <Twey> enthymene: Different principle
13:34:55 <Twey> I believe
13:34:59 <enthymene> Billiard balls not being magnetic, I suppose a LIM-based launcher would be a railgun, maybe
13:35:06 <enthymene> with the cue ball being the "rail"
13:35:37 <enthymene> but then, I haven't looked at a railgun since I uninstalled nexuiz :p
13:35:53 <Twey> Haha
13:36:15 <enthymene> welp, router hoppin time
13:36:16 <medfly> http://en.wiktionary.org/wiki/milliard#Translations
13:36:24 <medfly> that is a rather strong statement there :)
13:36:33 <enthymene> or long-scale on wikipedia
13:36:45 <enthymene> ,g wikipedia long scale
13:36:52 <enthymene> er, wrong channel
13:36:55 <enthymene> maybe that's #emacs
13:37:04 <medfly> @google wikipedia long scale
13:37:05 <lambdabot> http://en.wikipedia.org/wiki/Long_and_short_scales
13:37:05 <lambdabot> Title: Long and short scales - Wikipedia, the free encyclopedia
13:37:07 <medfly> :)
13:37:12 <enthymene> kk
13:38:05 <Polarina> Does anyone happen to know?
13:39:03 <chrisdone> I got my nonprogrammer friend to try haskell, hehe. giving me interesting feedback
13:39:12 <Polarina> chrisdone, ;)
13:39:38 <chrisdone> "you need to tell them to hit return after typing something"
13:39:39 * medfly was a non-programmer before Haskell
13:39:42 * medfly fell inlove with it.
13:40:00 <BONUS> chrisdone: awesome
13:40:01 <medfly> programming, not Haskell...
13:40:05 <copumpkin> is the inverse of a symmetric matrix always symmetric?
13:40:12 <copumpkin> ah, yes
13:40:16 <maltem> yes it is
13:41:03 <|Jedai|> copumpkin: I guess an easy way to prove it would be the standard det Comat formula
13:41:26 <MissPiggy> Comat = adjugate?
13:41:51 <arw> copumpkin: that is the definition...
13:42:02 <copumpkin> arw: it is?
13:42:11 <copumpkin> I thought the definition was that it was equal to its own transpose
13:42:14 <|Jedai|> MissPiggy: maybe, I learned my maths in French
13:42:21 <maltem> I = I^t = (A A^(-1))^t = (A^(-1))^t A^t   =>  (A^-1)^t = (A^t)^-1 = A^-1
13:42:22 <Polarina> How do I modify  (\x y -> intercalate "-" [x, y]) <$> ["a", "b"] <*> ["c", "d"]  to produce  ["a", "a-c", "a-d", "b", "b-c", "b-d"]?
13:42:49 <maltem> copumpkin, ^^
13:42:55 <copumpkin> maltem: thanks :)
13:43:23 <medfly> @hoogle sequence
13:43:23 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:43:23 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:43:23 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
13:43:31 <Cale> > liftM2 (++) ["a","b"] ([] : map ('-':) ["c","d"])
13:43:32 <lambdabot>   ["a","a-c","a-d","b","b-c","b-d"]
13:43:47 <medfly> Cale, hi
13:43:51 <Cale> hi
13:43:55 <arw> copumpkin: you are right, its not the definition, but it follows from the definition like maltem showed.
13:44:00 <copumpkin> arw: yep :)
13:45:46 * copumpkin has to show a fairly boring property for a homework assignment :P
13:45:51 * copumpkin sighs
13:46:07 <MissPiggy> what is it?
13:46:11 <arw> with enough insight, all homework assignments are boring :)
13:46:20 * hackagebot arbtt 0.4.5 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.4.5 (JoachimBreitner)
13:46:28 <maltem> Transposition is also an adjunction (if that's the English-maths word), so I suppose you can also get it that way. Would be overkill, though
13:46:32 <Polarina> Cale, thanks.
13:46:43 <copumpkin> I just finished it, but I needed to show that the contour lines of a 2d gaussian are elliptical
13:46:58 <copumpkin> anyway, should get back to work :P loads of other problems to do before midnight tonight
13:47:01 <chrisdone> hehe, he's trying other expressions and asking me about them
13:47:14 <chrisdone> even non-programmers can't resist fiddling with a language console
13:47:21 <MissPiggy> what is a 2d gaussian??
13:47:36 <copumpkin> MissPiggy: 2d bell curve? from R^2 -> R
13:47:41 <arw> gauss(x) * gauss(y)
13:48:10 <decker> so I'm a bit confused about algebraic data types.  if a value constructor has no arguments, then it's not really a function?  example: data Bool = False | True
13:48:20 <Cale> decker: Right, it's just a value
13:49:01 <Cale> decker: If you list some type parameters after it, then it becomes a function which takes values of those types and produces a value of the type you're defining.
13:49:22 * hackagebot arbtt 0.4.5.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.4.5.1 (JoachimBreitner)
13:49:35 <arw> decker: you can view it as a function which always returns the same constant value and takes no arguments. like the number '9' would be a function.
13:50:28 <Cale> For example,  data List a = Nil | Cons a (List a)  means that every List Integer, say, will be either the empty list Nil, or will be Cons x xs for some x :: Integer and xs :: List Integer
13:50:43 <chrisdone> would hooking tryhaskell up to #haskell be a really bad idea?
13:50:51 <chrisdone> or #haskell-beginners or some such
13:50:59 <Cale> chrisdone: I don't think it's a bad idea.
13:51:22 <decker> Cale: so this is a bit confusing then.  say I have something like this: "data Foobar = Foo String Int | Bar bool".  Is that legal?
13:52:16 <Cale> chrisdone: btw, one thing I found kind of frustrating was the lack of standard editing in TryHaskell. You can't seem to paste into the terminal for some reason.
13:52:34 <Cale> decker: yes, except that bool should be Bool
13:52:35 <sepp2k1> decker: Why wouldn't it be legal?
13:53:02 <Polarina> @src liftM2
13:53:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:53:11 <Cale> It means that every value of type Foobar is either Foo x y for some x :: String and y :: Int, or it is Bar z for some z :: Bool
13:53:31 <decker> well, what I'm getting at, it seems like Foobar could really be two different types.  how does that fit with haskell being strongly typed?
13:53:44 <Cale> I don't see how it could be two different types.
13:54:17 <Cale> any more than how  data Bool = False | True   could be two different types
13:54:33 <chrisdone> Cale: I was thinking of making all the code snippets clickable, so that they get inserted into the console. should you need to paste? I can probably hack it up but the terminal doesn't support it at the moment. I didn't include it because tryruby didn't
13:55:09 <decker> Cale: well, you could have one Foobar that contains a striing and an int, and another that contains a bool.  you couldn't really have some generic function for dealing with Foobars at that point.
13:55:30 <c_wraith> decker: that's what pattern matching is for
13:55:37 <decker> Cale: in the Bool example, either way we're still talking about a boolean being the data, not two different types of data
13:55:52 <Cale> chrisdone: Well, in your post about it on Haskell reddit, there was an example to try, and it was mildly irritating that I just had to type it out myself after just getting a 'v' from Ctrl-v
13:56:07 <chrisdone> Cale: true, good point
13:56:15 <Cale> decker: You would pattern match.
13:56:20 <sepp2k1> decker: In the Foobar example it's also a Foobar in either case.
13:56:21 <Cale> f (Foo x y) = ...
13:56:24 <Cale> f (Bar z) = ...
13:56:59 <Cale> Just as when defining functions on Bool values, you pattern match:
13:57:05 <decker> alright.  guess I'll just move on for now.  thanks though.
13:57:07 <Cale> not False = True
13:57:11 <Cale> not True = False
13:57:38 <c_wraith> > let False = True in "Everything's true!"
13:57:39 <lambdabot>   "Everything's true!"
13:58:07 <|Jedai|> > let False = True in False
13:58:08 <chrisdone> Cale: I'll add it. should be able to do it cross-browser
13:58:08 <lambdabot>   False
13:58:11 <Cale> decker: It's always a good idea to handle all the cases when pattern matching. The compiler can warn you (though it's turned off by default) about missing cases while pattern matching
13:58:22 <c_wraith> I don't think the language should allow pattern matches that don't bind a name
13:58:41 <Cale> c_wraith: why?
13:58:45 <chrisdone> c_wraith: but how would you define factorial?
13:58:52 <Cale> c_wraith: It seems useful in that 'not' example
13:58:54 <|Jedai|> c_wraith: especially when they're in a position where they won't be matched, it's confusing
13:59:04 <MissPiggy> c_wraith: that's crazy
13:59:06 <hotaru2k3> > let False = True in False == True
13:59:06 <lambdabot>   False
13:59:10 <c_wraith> Cale: in that example, the name "not" is bound
13:59:13 <decker> reddit is a rather odd site for haskell news by the way
13:59:21 <Cale> Oh, I see what you mean
13:59:36 <Cale> But really, that's a function binding, and the patterns are in the parameters
13:59:38 <|Jedai|> decker: why ?
13:59:40 <aavogt> is there a way to decide if a pattern match can syntactically fail?
14:00:05 <Cale> aavogt: yes?
14:00:17 <aavogt> as in to hook into ghc somehow to ask if   case experssion of pat -> undefined; _ -> undefined   has overlapping patterns
14:00:23 <Cale> oh
14:00:28 <Cale> Well, maybe.
14:00:38 <decker> |Jedai|: dunno, just is.  I mean, it's far from the norm here on freenode.  it's reddit after all.  ha, don't mind me.  carry on.
14:00:51 <Cale> I don't know if there's code to do it which is generally usable, but it's possible to do it.
14:01:28 <Cale> decker: reddit has always been mostly about programming, hasn't it?
14:01:50 <Cale> decker: Though I guess in recent years it's become more mainstream and the noise level has gone way up.
14:02:10 <Berengal_> Noise is what the subreddits are for
14:02:12 <decker> Cale: you can make a reddit about anything as far as I know.  it's always been that way
14:02:15 <Cale> The separate subreddits thing has helped a lot.
14:02:24 <aavogt> well in any case I've got this implemented: http://www.reddit.com/r/haskell_proposals/comments/98c96/applicative_bracket_syntax_in_ghc/c0ja8a1, but I think the failing pattern of (Just a) can be translated into some usage of alternative?
14:02:25 <Cale> No, it hasn't always been that way.
14:02:32 <decker> subbreddit I mean
14:02:41 <Cale> For a long time there were only a fixed number of subreddits.
14:02:48 <decker> ok
14:03:06 <Cale> And people would post general technology articles to the programming subreddit which would piss everyone off.
14:03:20 <chrisdone> the quality : quantity ratio always tips from the left side to the right side on any community-driven site that increases in popularity by an order of magnitude
14:04:15 <aavogt> so instead to put     (\x -> case x of Just y -> f y; _  -> empty) <*> foo bar baz <*> ...
14:05:00 <SamB_XP> wow ... I just found a comment in an MS header explaining why it is safe to multiply something by sizeof(char)!
14:05:18 <aavogt> there was something about haskell 1.4 doing something like this with Monad and MonadPlus (in do-notation)
14:06:17 <Cale> aavogt: A pattern is failable if it matches a constructor from a type with more than one constructor.
14:06:50 <ddarius> GADTs would make the notion of failable pattern more complicated.
14:07:05 <aavogt> Cale: and I suppose that also applies recursively
14:07:26 <aavogt> so if any constructors are matched that belong to data types that have multiple constructors
14:07:42 * aavogt thinks this information might be available in TH
14:08:29 <aavogt> ddarius: I would be satisfied if I got it working with regular ADTs
14:08:52 <ddarius> aavogt: Read the Haskell 1.4 Report on how they did it.
14:10:52 <aavogt> I think I'm going to be lazy an use SYB to gather up all the NameS used as ConPS in the pattern
14:12:29 <McManiaC> is there something like {-# GHC_OPTION  ... #-} for ghci?
14:12:37 <aavogt> there's a real problem with all these competing haskell libraries: there isn't enough time give each of them proper consideration
14:12:47 <aavogt> so I'm stuck using mtl and syb :)
14:12:47 <ddarius> :set -f<option>
14:13:15 <McManiaC> ddarius: so that I can just do "ghci <file>"
14:13:21 <aavogt> also I think that ghci might look of .ghci files outside of you home directory?
14:13:27 <aavogt> *your
14:13:34 <benmachine> yeah you can use .ghci in the current directory
14:13:43 <benmachine> and they get laoded in some order
14:13:47 <ddarius> McManiaC: Then a pragma should work.
14:15:09 <lysgaard> Hi, I'm struggeling with the http library. How do i download a file to disk/memory?
14:15:39 <lysgaard> I'm trying to use the Network.Browse.browse but i only get a response stirng
14:16:29 <Alpounet> lysgaard, try the 'download' or 'download-curl' package rather, for that purpose
14:16:57 <benmachine> lysgaard: hmm
14:17:07 <benmachine> I have
14:17:08 <benmachine>  (_, loginPage) <- request . getRequest $ root ++ "login.php"
14:17:10 <benmachine> in a file
14:17:14 <Heffalump> lysgaard: I use request $ getRequest url, and then use rspBody
14:17:19 <benmachine> as part of a browse do-block
14:17:27 <benmachine> and then rspBody loginPage
14:24:05 <lysgaard> Heffalump: Thanks! That's just what i needed :D
14:25:00 <Heffalump> benmachine and I appear to think alike :-)
14:25:41 <benmachine> you appear to think more succintly though
14:25:52 <enthymene> succthinktly?
14:26:19 <Heffalump> I did miss out a "snd" which you didn't though
14:28:26 <McManiaC> hmmmm
14:29:06 <McManiaC> how do I create Foreign.Storable instances? I found this link: http://therning.org/magnus/archives/315 but I only get "Not in scope: `#'" errors etc
14:30:06 <Heffalump> McManiaC: enable the MagicHash extension
14:30:18 <Heffalump> (I'm guessing a bit, but it's very likely from the symptoms you describe)
14:30:52 <McManiaC> magic hash?
14:31:00 <Heffalump> makes # work in symbols
14:31:13 <McManiaC> LANGUAGE MagicHash ?
14:31:17 <Heffalump> yep
14:32:37 <McManiaC> no difference :(
14:33:27 <Heffalump> oh, it's hsc2hs code
14:33:38 <Heffalump> you need to actually run the preprocessor :-)
14:35:53 <McManiaC> and where is the Foo datatype coming from?
14:37:03 <McManiaC> I guess thats the C datatype?
14:37:06 <McManiaC> *struct
14:37:25 <Dementati> Can I import a code file without making a module out of the code inside?
14:37:47 <medfly> @type readFile
14:37:49 <lambdabot> FilePath -> IO String
14:37:52 <medfly> ?
14:38:35 <Dementati> medfly: Was that aimed at me?
14:38:45 <medfly> yep
14:38:58 <badsheepy> :r
14:38:59 <badsheepy> oops
14:38:59 <Dementati> medfly: I don't want to load the file in my program, I want to import the code into my other code so I can use it.
14:39:03 <Axman6> Dementati: not that i'm aware of, unless you use the preprocessor
14:39:25 <Dementati> Axman6: Oh. Shame.
14:39:39 <ivanm> greetings, Axman6
14:39:43 <Axman6> if you add {-# LANGUAGE CPP #-} to the top of the file, you can use #include foo like in C i think
14:39:47 <Axman6> o/ ivanm
14:39:47 <ivanm> ready for your first tutoring session?
14:39:51 <Dementati> It's not that big of a deal, I'm just playing around and creating modules is a hassle.
14:40:46 <ivanm> Axman6: ready for your first tutoring session?
14:42:11 <McManiaC> http://npaste.de/ID/
14:42:13 <McManiaC> >.<
14:42:34 <McManiaC> http://npaste.de/IE/
14:42:36 <McManiaC> code â
14:43:05 <Axman6> ivanm: not quite, i still don't have a contract
14:43:45 <gwern> @wn strewth
14:43:45 <lambdabot> No match for "strewth".
14:43:52 <gwern> pitiful wordnet
14:44:00 <gwern> how can you not have strewth, 'sblood!
14:46:07 <McManiaC> linking EventLoop_hsc_make.o failed
14:46:07 <McManiaC> command was: glib-2.0 EventLoop_hsc_make.o -o EventLoop_hsc_make
14:46:14 <McManiaC> is there a way to get a more verbose output?
14:49:50 <ivanm> Axman6: neither do I... :s
14:50:01 <ivanm> I have to chase down Clem later today
14:50:07 <Axman6> ivanm: you need one before you can do any tutoring
14:50:12 <ivanm> do you at least have a class list?
14:50:22 <Axman6> yeah
14:55:56 <ivanm> so you're one up on me ;-)
14:56:23 <Axman6> https://cs.anu.edu.au/streams/Tutors.php see if you can log in there
14:56:58 <c_wraith> I have to wonder about something named "MonadUnsafeIO"
14:57:40 <MissPiggy> why not safe IO
14:58:06 <c_wraith> It's apparently part of an FFI interface used by some crypto libs
15:00:53 <ivanm> Axman6: 404'd ;-)
15:01:45 <ivanm> (but I can get to it after I log in)
15:02:07 <ivanm> (but I can't enter marks)
15:24:32 <ivanm> preflex: seen chrisdone
15:24:32 <preflex>  chrisdone was last seen on #haskell 1 hour, 21 minutes and 12 seconds ago, saying: the quality : quantity ratio always tips from the left side to the right side on any community-driven site that increases in popularity by an order of magnitude
15:27:38 <ivanm> @tell chrisdone for some reason, tryhaskell.org doesn't let me hit enter and thus do anything haskelly (but it does allow "help" and "stepN")
15:27:39 <lambdabot> Consider it noted.
15:31:08 <copumpkin> dons: I was thinking about your optimization problem
15:31:13 <McManiaC> http://www.mail-archive.com/haskell-cafe@haskell.org/msg48963.html can anyone check if that example works for ghc 6.12 ?
15:31:36 <McManiaC> hsc2hs version 0.67
15:31:44 * ivanm doesn't have anything newer than 6.8 here atm :s
15:33:29 <McManiaC> damnit
15:33:35 <McManiaC> I cant get that hsc2hs to work =(
15:34:48 <copumpkin> dons: maybe you already do this, but if you're just changing llvm settings maybe you can keep around the GHC LLVM IR output between runs so you only pay for llvm at each iteration, and not all of the GHC stuff
15:35:45 <Alpounet> copumpkin, have you tried it ?
15:35:52 <copumpkin> nope
15:37:54 * hackagebot glpk-hs 0.2.0 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.2.0 (LouisWasserman)
15:43:57 * hackagebot glpk-hs 0.2.1 - Comprehensive GLPK linear programming bindings  http://hackage.haskell.org/package/glpk-hs-0.2.1 (LouisWasserman)
15:46:46 <Alpounet> how can I do to be able to have libraries built with the llvm backend along with the same libraries not built with the llvm backend... just using the native code generator ?
15:47:16 <Alpounet> 'cause cabal install'ing something uses the ghc 6.12, since it's the system-wide installed one
15:48:07 <ivanm> Alpounet: build cabal-install using the HEAD ghc
15:48:09 <Polarina> LLVM is still experimental.
15:48:15 <ivanm> (with LLVM enabled)
15:48:47 <Alpounet> Polarina, I know, I don't intend to use it for anything except benchmarking and testing
15:49:46 <Alpounet> ivanm, so I'd carry a specific-to-ghcllvm cabal-install ?
15:50:32 <ivanm> yeah, I think that's your best bet
15:53:22 <mreh> would memoizing something of the form "const bar" be sensible?
15:55:24 <mreh> @src bool
15:55:24 <lambdabot> Source not found. Do you think like you type?
15:55:48 <ivanm> bool f t b = if b then t else f
15:55:49 <mauke> @djinn a -> a -> Bool -> a
15:55:49 <lambdabot> f a b c =
15:55:49 <lambdabot>     case c of
15:55:49 <lambdabot>     False -> b
15:55:49 <lambdabot>     True -> a
15:56:18 <ivanm> mauke: that'd be the wrong way round if keeping it the same as "normal" folds...
15:56:30 <ivanm> (then again, foldr and foldl are the wrong way as well, so *shrug*)
15:57:09 <mreh> foldr folds in the RHS and foldl in the LHS of an infix operator
15:57:38 <ivanm> mreh: I meant that IIRC, by definition a fold is meant to cover the base case first, etc.
15:57:39 <mreh> but in completely different ways....
15:57:42 <ivanm> e.g. the maybe function is a fold
16:02:28 <Alpounet> I can't get to modify correctly the GHC and GHC_PKG vars in cabal's bootstrap
16:02:29 <Alpounet> hmm
16:04:29 <interferon> what's a good tutorial for arrows?
16:05:00 <copumpkin> interferon: it lives in your head!
16:05:09 <ivanm> most people recommend the original paper IIRC
16:05:22 <interferon> is that Generalizing Monads to Arrows?
16:05:25 <ivanm> Alpounet: change your $PATH whilst doing it?
16:05:27 <copumpkin> blackh had a nice tutorial on the haskell wiki I thnk
16:05:29 <dschoepe> interferon: yep
16:06:17 <interferon> are you referring to http://www.haskell.org/arrows/ ?
16:06:24 <interferon> because that is totally impenetrable to me
16:07:10 <Cale> interferon: Do you understand monads?
16:07:25 <interferon> i think so
16:07:29 <dschoepe> interferon: http://en.wikibooks.org/wiki/Haskell -- this also has a chapter on arrows
16:07:36 <Cale> interferon: The monad class is just a general API that many sorts of libraries might conform to
16:07:55 <McManiaC> what are LINE pragmas?
16:08:07 <Cale> interferon: Arrow is similar in that regard, it just has different means of combination -- it's another pattern that libraries might fit into.
16:08:52 <blackh> interferon, copumpkin: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
16:08:52 <interferon> i guess what causes my confusion is that a lot of FRP papers require arrows, and i'm not sure why monads aren't sufficient there
16:09:23 <blackh> This thing probably belongs on the haskell wiki rather that in the wiki book.
16:09:30 <Cale> interferon: Well, okay, one advantage that an arrow library might have over a monad library is that if you have a function a -> M b where M is some monad, there's no way to inspect that
16:09:40 <Cale> Functions are effectively black boxes
16:09:44 <interferon> that being the function itself?
16:09:53 <Cale> and >>= takes such a function as its right parameter
16:10:00 <copumpkin> blackh: oh that was it, thanks :)
16:10:13 <Cale> So it means that computations built up monadically are almost never meaningfully inspectable.
16:10:30 <Cale> that being the type of the function, if it was unclear
16:11:19 <Cale> For example, even though lists could not be more easy to take apart, the only thing you can really do with a function  Integer -> [Integer]  to see what it does is to apply it.
16:11:55 <Cale> So it's hard to do any sort of analysis or runtime optimisation of computations which are written monadically.
16:11:55 <interferon> that makes sense
16:12:22 <Alpounet> ivanm, it's okay now
16:12:39 <Alpounet> I'm having trouble installing manually parsec into the new ghc package database
16:12:48 <Cale> Now, arrows still allow for some black-boxes, via arr :: (Arrow a) => (b -> c) -> a b c
16:12:57 <shapr> @arr
16:12:57 <lambdabot> Keelhaul the swabs!
16:13:17 <blackdog> *sigh* i just saw an instance variable. been hacking ruby too long.
16:13:20 <Cale> But the main way that you compose arrow-computations is via (>>>) :: (Arrow a) => a b c -> a c d -> a b d
16:13:21 <Alpounet> I ran runghc Setup.lhs configure and runghc Setup.lhs build fine, but wonder how I can now install the resulting parsec build in my HEAD ghc package database
16:13:40 <Cale> and in this case, both the parameters to (>>>) are of a type which you have control over
16:13:54 <McManiaC> hmhmhmâ¦ the hsc2hs on hackage is from 2006â¦ is that project dead?
16:14:02 <Cale> So they might very well be inspectable, and the implementation of (>>>) might do something to optimise things.
16:14:41 <ivanm> McManiaC: I would guess more "stable" rather than dead
16:14:56 <McManiaC> then I'm doing something wrong :S
16:15:08 <interferon> Cale: is it wrong to say that the primary purpose of arrows is to optimize monadic computations?
16:15:25 <Cale> Well, that's not quite correct.
16:15:41 <Cale> But it is *a* reason that an arrow interface might be preferred.
16:15:55 <Cale> It might be that the arrow you're working with is not a monad in any way either.
16:16:00 <interferon> so why does FRP require arrows?
16:16:09 <Cale> That is, there are arrows which are not equivalent to a -> M b for some M
16:16:16 <Cale> It doesn't require arrows.
16:16:29 <Cale> Some FRP libraries happen to fit the arrow interface is all.
16:17:01 <copumpkin> http://twitter.com/donsbot/status/9799784516
16:17:43 <mauke> http://twitter.com/failofailo/status/9465120285
16:18:13 <Cale> There are fewer general combinators which apply to Hughes Arrows than to monads, so it's not even as big a deal as knowing that something is a monad.
16:18:14 <copumpkin> interesting...
16:18:20 <McManiaC> ivanm: it also says "Build failureghc-6.10 (log), ghc-6.8 (log)" on hackage
16:18:46 <Cale> But still there are some libraries which are handy, and a nice syntax for Arrow computations.
16:19:03 <ivanm> McManiaC: doesn't hsc2hs come with ghc?
16:19:06 <Alpounet> ivanm, any idea ?
16:19:35 <ivanm> Alpounet: runhaskell Setup.hs configure --help
16:19:39 <Cale> 'Managed to convince ghc -fllvm to turn sum [1..n] into "movabsq $5000000050000000, %r14"' -- I'm hoping that n is a constant in the program ;)
16:20:20 <copumpkin> lol
16:20:33 <copumpkin> that's pretty impressive by the way
16:20:44 <ivanm> copumpkin: why not just paste the message here rather than the twitter link?
16:20:46 <Cale> That seems kind of dangerous.
16:20:47 <copumpkin> considering that sum is foldl (+) 0 (not even foldl')
16:20:47 <ivanm> also, where is dons?
16:21:00 <ivanm> if he just posted that 2 minutes ago surely he would come in here to boast...
16:21:01 <copumpkin> @get-dons
16:21:01 <Cale> It seems like more computation at compile time than I would normally hope would happen.
16:21:01 <lambdabot> Unknown command, try @list
16:21:05 <ivanm> geg
16:21:07 <ivanm> &heh
16:21:09 <ivanm> *heh
16:21:12 <ivanm> @slap keyboard
16:21:12 * lambdabot hits keyboard with a hammer, so they breaks into a thousand pieces
16:21:17 <copumpkin> Cale: that's with a bunch of crazy flags
16:21:19 <ivanm> preflex: seen dons
16:21:19 <preflex>  dons was last seen on #ghc 5 hours, 24 minutes and 9 seconds ago, saying: yeah
16:21:28 <copumpkin> let's get supero instead
16:21:43 <ivanm> anyway, that looks like pre-compilation...
16:21:46 <ivanm> copumpkin: heh
16:22:12 <Cale> Yeah, some real supercompilation would be nice.
16:22:14 <copumpkin> supre-compilation?
16:22:35 <dons> ivanm: ?
16:22:44 <Cale> sucre-complication
16:22:48 <copumpkin> sweet!
16:23:10 <ivanm> dons: just wondering on your priorities in that you do a twitter message before coming in here to say it ;-)
16:23:20 <dons> hey guys
16:23:37 <copumpkin> dons: did you see my earlier message before about your optimization tool?
16:23:41 <dons> there are prob. more people following my tweets than in here, these days. (there's more on reddit haskell than haskell-cafe@!)
16:23:50 <dons> copumpkin: yeah, good idea.
16:23:55 <dons> i'm just writing up my findings.
16:23:58 <copumpkin> cool :)
16:24:26 <dons> yeah, 619 in here, 690 followers on twitter.
16:24:27 <ddarius> copumpkin: Supercompilation is orthogonal to the LLVM usage.
16:24:28 <dons> web 2.0 roxors
16:24:53 <copumpkin> ddarius: yep, I know
16:24:53 <McManiaC> ivanm: I dont knowâ¦ its in the ghc docs, but I cannot get it to work with ghc 6.12
16:25:09 <copumpkin> yay 2.0
16:25:11 <ivanm> dons: :o
16:25:26 <copumpkin> too many luddites in #haskell
16:25:27 * Lemmih tells dons about the difference between quantity and quality.
16:25:46 <copumpkin> Lemmih: not sure the quality of #haskell is much higher, if you consider all the idlers
16:26:01 * ddarius is a Luddite.
16:26:05 <ivanm> copumpkin: well, there's Cale, Lemmih, etc.
16:26:10 * ddarius also, unrelatedly, doesn't use Twitter or Reddit.
16:26:22 <Draconx|Laptop> copumpkin, if you consider the idlers, the quantity of #haskell is probably higher.
16:26:25 <copumpkin> how about facebook? surely everyone has a facebook account
16:26:28 * ivanm doesn't use twitter, but does read reddit (not subscribed though)
16:26:31 <ivanm> copumpkin: I don't
16:26:31 <copumpkin> Draconx|Laptop: he just counted them
16:26:32 <ddarius> copumpkin: God no.
16:26:34 <ivanm> nor myspace
16:26:36 <copumpkin> damn
16:26:39 <copumpkin> you guys are mad!!
16:26:47 <ddarius> copumpkin: If its a "social networking" site/application, I don't use it.
16:27:00 <ivanm> I pretty much read reddit for procrastination purposes
16:27:08 <Draconx|Laptop> copumpkin, I meant *not* counting them.
16:27:18 <McManiaC> for fuck sake
16:27:26 <McManiaC> how do you work with hsc2hs and ghc 6.12? :S
16:27:31 <McManiaC> this gotta be possible
16:27:34 <McManiaC> :(
16:28:17 <ivanm> McManiaC: you sure hsc2hs didn't come with ghc?
16:28:55 <Cale> I don't see the point of Twitter so much.
16:29:02 <ivanm> neither do I
16:29:21 <copumpkin> it allows me to draw pretty graphs like the one I showed yesterday
16:29:33 <copumpkin> that's a pretty worthy cause
16:29:36 <Cale> huh?
16:29:41 <McManiaC> ivanm: so even if it came with ghcâ¦ I cannot get it to work
16:29:43 <McManiaC> >.<
16:29:48 <dons> Cale: for pushing messages to facebook :)
16:29:59 <Alpounet> ivanm, it seems I'm on the right way
16:30:10 <ivanm> McManiaC: sure your paths are right?
16:30:16 <Cale> I also don't see the point of facebook.
16:30:17 <ivanm> copumpkin: heh
16:30:21 <ddarius> http://img641.imageshack.us/img641/8679/testfy.jpg
16:30:23 <copumpkin> http://dl.dropbox.com/u/361503/copumpkin_sfdp_transparentedges.png (that one, massive PNG)
16:30:29 <copumpkin> damn, ddarius beat me to it
16:30:44 <Cale> What does this graph represent?
16:30:47 <luite> massive black hole?
16:30:57 <copumpkin> supermassive black hole?
16:30:58 <ivanm> Cale: twitter IIRC
16:31:02 <copumpkin> Cale: my twitter neighborhood
16:31:14 <copumpkin> the haskellers are in the ball on the left
16:31:40 <ddarius> "What are those glowy bits?!"
16:31:42 <htoothrot> so it's a black hole
16:32:01 <copumpkin> What are those glowy bits?!
16:32:09 <tensorpudding> how is that sorted
16:32:14 <tensorpudding> hoshit, i'm the furthest left in there
16:32:19 <tensorpudding> i'm special
16:32:52 <copumpkin> you sure are
16:33:05 <Cale> How do you decide where to place the vertices?
16:33:19 <copumpkin> Cale: sfdp from graphviz did for me
16:33:34 <Cale> That seems like a suboptimal graph layout...
16:33:42 <copumpkin> I'm sure it is
16:33:47 <ivanm> copumpkin: hawkin radiation (for the glowy bits)?
16:33:52 <copumpkin> but it captured things that I cared about
16:33:57 <tensorpudding> what did you use to determine the edges
16:33:59 <copumpkin> ivanm: that was ddarius' doing :)
16:34:04 <ivanm> heh
16:34:11 <copumpkin> tensorpudding: I crawled the twitter API and pulled out a crapload of edges
16:34:17 * ivanm is disappointed that copumpkin didn't use his library :(
16:34:32 <copumpkin> ivanm: I will, I will! do you bind sfdp btw?
16:34:39 <copumpkin> but I'm looking more into interactive graphs now
16:34:47 <tensorpudding> an edge between vertices indicates following maybe?
16:34:53 <ivanm> copumpkin: yes, you can call sfdp
16:35:03 <copumpkin> tensorpudding: yep
16:35:05 <ivanm> copumpkin: what are you going to use for interactive graphs?
16:35:18 <ddarius> copumpkin: What was your stopping criteria for crawling Twitter?
16:35:24 <copumpkin> ivanm: haven't decided yet, but thejit.org looks pretty neat
16:35:26 <ivanm> copumpkin: note that I don't support the fancy "edge between vertex and cluster" stuff from sfdp yet though
16:35:39 <ivanm> bah, web stuff
16:35:39 <tensorpudding> i don't see anyone i'm following on there
16:35:58 * ivanm thought copumpkin mean an actual library
16:36:07 <copumpkin> ddarius: I take someone I'm interested in, find all his incoming (followers) and outgoing (friends) edges. Then for each follower I find all of his/her/its friends, and for each friend I find all followers
16:36:21 <copumpkin> so this is the what it generated for me
16:36:45 <copumpkin> oh, and then the graph is actually all edges that are between {me U my followers U my friends}
16:36:46 <ivanm> hmmm.... so you need a JSON representation of the graph to use thejit?
16:36:51 <copumpkin> ivanm: yep
16:37:10 <ddarius> copumpkin: So two/three steps from the root?
16:37:57 <copumpkin> just one step, really. Just looking to capture all edges that occur between users who are one step away from me, but the only way to do that with the API is what I did
16:38:00 * ivanm will think about that as an alternate graph visualisation representation
16:38:22 <McManiaC> ivanm: well I see nothing wrong with this: http://npaste.de/IH/hs
16:38:27 <tensorpudding> so everyone that is in that graph is either your friend, or your friends followers which are shared by more than one friend?
16:38:42 <ivanm> McManiaC: I have nfi how to use hsc2hs!
16:38:50 <McManiaC> ok =(
16:38:55 <ivanm> see RWH
16:39:00 <copumpkin> tensorpudding: every node in that graph is a friend or a follower of mine. The only edges included are the ones between them (and myself)
16:39:07 <copumpkin> sorry, not being very clear
16:39:13 <McManiaC> RWH?
16:39:27 <Cale> Are you certain that you want to use hsc2hs?
16:39:32 <ddarius> The nodes are one step away, the edges two.
16:39:47 <tensorpudding> you have a ton of friends and followers then
16:39:48 <McManiaC> Cale: I need to read/write C structs, so yes, I'm sure
16:39:58 <ddarius> copumpkin is famous
16:40:14 <Cale> McManiaC: You don't need hsc2hs to do that
16:40:25 <McManiaC> then tell me :O
16:41:07 <copumpkin> tensorpudding: yeah, and most of them are in the big ball
16:41:17 <copumpkin> which means that they tend to be quite connected to each other too
16:41:26 <ivanm> McManiaC: Real World Haskell
16:41:35 <ivanm> @where RWH
16:41:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:41:35 <McManiaC> ivanm: well, that doesnt work either
16:41:40 <McManiaC> tried it before
16:41:46 <ivanm> ddarius: he is? :o
16:41:55 <Cale> You just need to define a corresponding Haskell type and write an appropriate instance of Storable for it which produces the same layout as the C type.
16:42:14 <Draconx|Laptop> Cale, that's pretty tricky to do portably.
16:42:19 <Cale> I suppose so.
16:42:28 <Draconx|Laptop> requires invoking the C compiler.
16:42:36 <McManiaC> Cale: I dont know how to write that instance
16:42:39 <McManiaC> thats the whole point
16:43:26 <mauke> McManiaC: #include "foo.c"?!
16:43:32 <flippo> what is the "| m->h" doing in the following?  class Monad m => MonadHandel h m | m -> h where ...
16:43:41 <McManiaC> mauke: -#include is depreciated and ignored
16:43:53 <mauke> McManiaC: why are you including a .c file?
16:44:01 <Cale> flippo: Ensuring that for each m there is at most one h for which there is an instance  MonadHandel h m
16:44:02 <peregrine81> ivanm: Are their any signifigant differences between the website or the actual book for RWH?
16:44:19 <ivanm> peregrine81: the book has some stuff that didn't get put back into the website
16:44:22 <McManiaC> mauke: because in the beginning I wanted to read that f struct
16:44:30 <Cale> flippo: So that if the compiler knows m, it can determine h
16:44:31 <stevenmarky> the website has useful comments.
16:44:38 <mauke> McManiaC: what
16:44:44 <Cale> flippo: which helps type inference to go more smoothly
16:44:47 <ivanm> (since it was easy to go from website -> book filetype, but they couldn't do the conversions back easily)
16:45:20 <burkaman> Is there an easy way to retrieve the actual value from a Maybe value?
16:45:33 <flippo> Cale, thanks.  I'll meditate on that.  I never would have guessed.
16:45:34 <tensorpudding> burkaman: you can use case
16:45:35 <Cale> burkaman: pattern matching
16:45:39 <Cale> case foo of
16:45:39 <peregrine81> ivanm: alright thanks!
16:45:41 <Cale>   Nothing -> ...
16:45:42 <BONUS> :t maybe
16:45:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:45:45 <Cale>   Just x -> ... x ...
16:46:03 <ivanm> flippo: the maybe and fromMaybe functions
16:46:07 <ivanm> @type fromMaybe
16:46:08 <lambdabot> forall a. a -> Maybe a -> a
16:46:09 <ivanm> @src maybe
16:46:09 <lambdabot> maybe n _ Nothing  = n
16:46:09 <lambdabot> maybe _ f (Just x) = f x
16:46:11 <ivanm> @src fromMaybe
16:46:12 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
16:46:20 <Cale> flippo: You can read more about it in the GHC User's Guide, under functional dependencies (It's an extension)
16:46:22 <BONUS> so in summary: there are about 4 easy ways :)
16:46:23 * ivanm wonders why there's a case there...
16:46:25 <burkaman> ok, thanks
16:46:29 <tensorpudding> hmm, never heard of maybe
16:46:36 <ivanm> tensorpudding: :o
16:46:37 <tensorpudding> is that in Data.Maybe?
16:46:39 <ivanm> it's in the prelude!
16:46:43 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
16:46:44 <tensorpudding> oh hey
16:46:48 <ivanm> (re-exported from Data.Maybe)
16:46:53 <Cale> oh, oops
16:46:53 <flippo> Cale, aha.   It just starting slipping into RWH examples, without any explanation I could find.
16:46:53 <tensorpudding> i did know about either though
16:47:03 <Cale> there's not as much documentation there as I thought
16:47:07 <tensorpudding> i guess i've not had reason to want a function like maybe
16:47:10 <mauke> McManiaC: your code makes no sense to me
16:47:18 <mauke> McManiaC: it looks like it's simply trying to call a C function
16:47:26 <McManiaC> mauke: yeh and it doesnt work
16:47:27 <mauke> nothing to do with Storable or hsc2hs
16:47:30 <Cale> Oh, I guess there's a fair amount :)
16:47:32 <McManiaC> thats the whole point
16:47:38 <tensorpudding> Either is a bit more obnoxious to use than Maybe
16:47:45 <McManiaC> hsc2hs fucks that little, simple code totaly up
16:47:49 <ivanm> realistically, there's no reason to actually pattern match on Maybe (unless you're also pattern matching on other variables at the same time)
16:48:02 <mauke> McManiaC: well, stop using it then
16:48:13 <Cale> McManiaC: There's c2hs which is supposed to be good.
16:48:14 <tensorpudding> ivanm: why?
16:48:20 <McManiaC> mauke: tell me how to define a Storable instance then
16:48:29 <mauke> McManiaC: that code doesn't need a Storable instance
16:48:34 <mauke> McManiaC: what are you trying to do?
16:48:40 <McManiaC> mauke: tell me how to define a Storable instance then
16:48:43 <McManiaC> THAT
16:48:43 <McManiaC> :<
16:48:44 <McManiaC> sorry
16:48:53 <mauke> ok, let me try to write an example
16:49:28 <ivanm> tensorpudding: because of maybe and fromMaybe pretty much covering anything you're likely to want to do with Maybe
16:49:36 <ivanm> oh, there's also isJust, isNothing, fromJust, etc.
16:49:54 <tensorpudding> that sounds less elegant than pattern matching
16:50:09 <ddarius> Blech isJust/isNothing
16:50:12 <Cale> It often is less elegant, but sometimes those functions are exactly what you want.
16:51:01 <tensorpudding> @type fromMaybe
16:51:02 <lambdabot> forall a. a -> Maybe a -> a
16:51:39 <tensorpudding> fromMaybe would be useful if you had to do a similar action for either case, and had a meaningful default value for Nothing
16:52:12 <burkaman> So what does one generally do when they encounter a stack overflow?
16:52:21 <stevenmarky> cry
16:52:29 <burkaman> yeah that was my first reaction
16:52:35 <ddarius> burkaman: Write better code.
16:52:36 <HugoDaniel> i keep having this same doubt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23110#a23110  how do i match a existential type ?
16:52:38 <tensorpudding> generally try to figure out why
16:52:40 <HugoDaniel> is it possible with typeable ?
16:52:44 <burkaman> right then
16:53:51 <ivanm> Cale: I find it fits better into my coding workflow than pattern matching in many cases
16:54:07 <ivanm> especially if it's in the middle of a function where the Maybe suddenly appears
16:54:18 <blackh> HugoDaniel: The typeclass *is* the interface, so you can't match like that.  You would have to add something to the typeclass interface to give access to that info before you could match it.
16:54:28 <Cale> burkaman: It's important to know that the stack in GHC is not used for what the stacks in strict language implementations are typically used for.
16:54:31 <ivanm> ddarius: I sometimes care about if it's actually got a value or not, so isJust is helpful then
16:54:38 <tensorpudding> the worst-case would be if you have to have different functions for Nothing or (Just x) that are complex
16:55:02 <ivanm> yeah
16:55:04 <HugoDaniel> blackh: i want to match against the existential type, the interface is just where its supposed to be, right ?
16:55:08 <Cale> burkaman: The stack effectively represents case expressions (or other pattern matches that get translated into case expressions) which are waiting for their scrutinee to be sufficiently evaluated so that they can pattern match.
16:55:17 <HugoDaniel> i mean, the interface has not much to do with it
16:55:26 <HugoDaniel> i just can't match with existential types
16:55:26 <tensorpudding> you could create helper functions for them and call them using maybe, but that isn't really that much better
16:55:27 * ddarius doesn't understand why'd you'd care if it is Just or not unless you were planning on using the value.  There are a few cases, but I don't find too many.
16:55:30 <HugoDaniel> which is kind of boring :/
16:55:48 <Cale> burkaman: Stack overflows typically happen when a very large expression consisting of strict functions is built up and not evaluated until the very end.
16:56:11 <burkaman> Cale: so is the solution to fix the expression, or evaluate it sooner?
16:56:13 <Cale> The most common example being accumulating an integer by adding 1 millions of times.
16:56:22 <blackh> HugoDaniel: There are two issues really... one is how to get existential info out of a data structure, and the other is how to get information out of something that you've made a typeclass for.
16:56:24 <McManiaC> Cale: c2hs doesnt even build
16:56:29 <McManiaC> src/C2HS/C/Info.hs:117:53:
16:56:29 <McManiaC>     Not in scope: type constructor or class `CLDouble'
16:56:30 <Cale> To force the evaluation sooner, usually, yes.
16:56:37 <burkaman> ok, i'll try that
16:56:50 <Cale> This is usually easier to accomplish using bang patterns
16:56:56 <tensorpudding> seq might help, or BangPatterns
16:57:02 <ivanm> ddarius: I don't need it often, sometimes just in intermediary stuff
16:57:06 <mauke> crap, now I don't even remember how to build .hsc files
16:57:13 <HugoDaniel> blackh: im interested in the existential datatype, the typeclass is correct
16:57:16 <Cale> So if you have an accumulating parameter, something like  f n ... = f (n+1) ...
16:57:19 <HugoDaniel> i need matching, or else its useless
16:57:26 <blackh> HugoDaniel: Rank N types can be very useful but they're a bit tricky to get right
16:57:31 <McManiaC> mauke: you write them as .hsc then call hsc2hs Foo.hsc
16:57:35 <Cale> then you want to stick a ! in front of the n in that pattern
16:57:41 <Cale> something like  f !n ... = f (n+1) ...
16:57:55 <Cale> and make sure {-# LANGUAGE BangPatterns #-}  appears at the top of the file
16:58:02 <HugoDaniel> blackh: what are Rank N types ?
16:58:11 <Cale> This is only if the n parameter is otherwise not computed
16:58:27 <HugoDaniel> blackh: i just want to be able to match, even a simple match would help...
16:58:36 <Cale> If you're already doing something to pattern match on n, then that isn't your problem.
16:58:39 <tensorpudding> Rank N types allow you to put universal quantifiers in there
16:59:07 <blackh> HugoDaniel: I am starting to understand ... :)  I am not sure whether this is a Rank N type or an Existential type.  I think it's a Rank N type
16:59:10 <tensorpudding> to have things like data MyType = forall a. MyType a
16:59:47 <HugoDaniel> ive been struggling with this for days :/
17:00:09 <blackh> HugoDaniel: OK - so you want to get the 'noiseFunc' value out, right?
17:00:49 <Cale> HugoDaniel: You can pattern match on existential types.
17:00:55 <mauke> McManiaC: http://npaste.de/II/ http://npaste.de/IJ/ http://npaste.de/IK/
17:00:56 <Cale> HugoDaniel: You just have to use case to do it, not let
17:00:58 <burkaman> Why is it that making a list of a million numbers doesn't cause a stack overflow, but finding the maximum does?
17:01:33 <Cale> burkaman: because (:) isn't strict
17:01:40 <Cale> also, you might not even evaluate the whole list
17:01:58 <Cale> You can make a list of infinitely many numbers, and only have one element of that list in memory at any time
17:02:14 <Cale> (:) doesn't need to pattern match on its parameters for any reason
17:02:24 <McManiaC> mauke: Foo.o: In function `s1AC_info':
17:02:24 <McManiaC> (.text+0x2474): undefined reference to `print_struct'
17:02:26 <Cale> It just makes a new list cell which refers to the parameters you give it
17:02:28 <HugoDaniel> Cale: i've tried case... no luck with that :(
17:02:40 <Cale> The stack consists of case expressions, remember
17:02:40 <mauke> McManiaC: hsc2hs Main.hsc  && ghc -Wall --make foo.c Main
17:02:42 <ivanm> burkaman: if you ever need to create such a big list, don't keep it in memory
17:02:49 <ivanm> as in, don't use it in two places
17:02:52 <McManiaC> mauke: jup
17:02:54 <mauke> McManiaC: basically, you need to compile foo.c to foo.o and include that in the compilation
17:03:02 <blackh> HugoDaniel: So, in 'gen', how would we get the NoiseModule value out of a value of type NoiseClasss n => n ?
17:03:05 <Cale> max *does* involve strict functions/case expressions
17:03:21 <McManiaC> mauke: I did exactly that
17:03:25 <Cale> But there's an easy way to fix it...
17:03:28 <burkaman> ivanm: does using the list in two functions mean i've stored it in memory?
17:03:31 <Cale> Use foldl' max
17:03:32 <blackh> HugoDaniel:  You would need a function in the typeclass to give it to you, e.g. getNM :: n -> NoiseModule
17:03:42 <Cale> Or just compile with optimisations
17:03:49 <ivanm> burkaman: quite possibly
17:03:51 <McManiaC> mauke: http://npaste.de/IL/
17:04:02 <ivanm> (depending on order, etc.)
17:04:06 <mauke> McManiaC: you fail at copy/paste
17:04:12 <Cale> The strictness analyser is turned off unless you at least put -O (if not -O2) in the commandline to GHC.
17:04:14 <McManiaC> why?
17:04:15 <blackh> HugoDaniel: You can then pattern match against that using a case statement.
17:04:23 <mauke> <McManiaC> mauke: I did exactly that
17:04:26 <Cale> and it can be critical to avoiding stack overflows.
17:04:45 <McManiaC> mauke: ?
17:04:48 <mauke> McManiaC: now compare 'hsc2hs Main.hsc  && ghc -Wall --make foo.c Main' with 'ghc --make Foo.hs -Wall'
17:04:49 <Cale> I bet it's smart enough to fix the one you have.
17:05:04 <McManiaC> mauke: well, guess how the Foo.hs got created :P
17:05:10 <mauke> irrelevant
17:05:11 <Cale> I sort of wish that -O was turned on by default. It tends to fix a lot of problems.
17:05:22 <McManiaC> mauke: exactly, irrelevantâ¦ it doesnt work :P
17:05:24 <HugoDaniel> :(
17:05:26 <HugoDaniel> ok
17:05:30 <mauke> McManiaC: because you didn't do what I said
17:06:14 <mauke> you're free to change my instructions, but don't tell me you did "exactly what I said"
17:06:37 <mauke> <mauke> McManiaC: basically, you need to compile foo.c to foo.o and include that in the compilation
17:06:37 <Cale> HugoDaniel: What's the deal with that gen function...
17:06:51 <mauke> McManiaC: 'ghc --make Foo.hs -Wall' doesn't mention foo.o
17:06:54 <Cale> HugoDaniel: The pattern 'n' will match anything, which makes the second line useless.
17:07:13 <McManiaC> *facepalm*
17:07:14 <McManiaC> sorry
17:07:15 <McManiaC> ok
17:07:17 <McManiaC> it works
17:07:18 <Cale> burkaman: Did any of that commentary help?
17:07:26 <McManiaC> its too late
17:07:26 <McManiaC> ^^
17:07:38 <HugoDaniel> i keep getting "`n' is a rigid type variable bound by..." on ghc
17:07:39 <burkaman> well
17:07:41 <Cale> burkaman: Try just compiling with -O and see if it fixes the problem. If not, then switch the use of maximum out for foldl' max
17:07:46 <Cale> er
17:07:48 <burkaman> yeah, it didnt
17:07:50 <Cale> sorry  foldl1' max
17:07:52 <burkaman> ill try the foldl' max
17:07:55 <HugoDaniel> which makes sense, since NoiseModule is existential
17:08:05 <McManiaC> mauke: how do I do this with libs that are not local?
17:08:14 <mauke> McManiaC: what do you mean?
17:08:34 <McManiaC> libs in /usr/include/
17:08:49 <blackh> HugoDaniel: Well, the first line of gen (gen n = NoiseModule n []) is a type mismatch because it's not the same n type.
17:08:51 <mauke> er, headers aren't libraries
17:08:52 <Cale> burkaman: foldl'/foldl1' are like foldl/foldl1, except that they force the evaluation of the accumulated expression on each step
17:08:58 <burkaman> yeah
17:09:00 <McManiaC> yeh ok
17:09:01 <burkaman> this is promising
17:09:02 <McManiaC> headers
17:09:02 <McManiaC> ^^
17:09:07 <burkaman> it's at least taking longer to overflow
17:09:15 <mauke> McManiaC: the same way, but with #include <foo.h>
17:09:24 <mauke> McManiaC: (see also the #include <stddef.h> in there)
17:09:32 <Cale> burkaman: Basically, what was happening looks like:
17:09:41 <Cale> foldl1 max [1,2,3]
17:09:48 <McManiaC> mauke: so just "ghc --make Main.hs" ?
17:09:57 <Cale> -> foldl max 1 [2,3]
17:10:04 <McManiaC> with -lmylib
17:10:09 <Cale> -> foldl max (max 1 2) [3]
17:10:19 <Cale> -> foldl max (max (max 1 2) 3) []
17:10:20 <mauke> McManiaC: well, depends which library the functions are in ... but yeah
17:10:26 <Cale> -> max (max 1 2) 3
17:10:35 <blackh> HugoDaniel: Actually I could be wrong about that. :)
17:10:42 <McManiaC> mauke: ok! thx a lot
17:10:46 <Cale> and now at this point, the outer max can't be computed until its first parameter is
17:10:50 <burkaman> wow that's ridiculously complicated
17:10:52 <Cale> So it gets put on the stack
17:11:00 <burkaman> ooooo i see
17:11:27 <Cale> But if the outer max was something that could do some computation without knowing its first parameter, it would do that first.
17:11:39 <Cale> (lazy evaluation is outermost-first)
17:11:56 <burkaman> so could i have solved the problem by just calculated the max of sections of the list at a time?
17:12:02 <HugoDaniel> i feel that this is the kind of stuff that i won't learn with experience in haskell
17:12:07 <burkaman> instead of the whole thing
17:12:25 <Cale> Well, it's just important to use a fold which forces the expressions to evaluate as it goes.
17:13:32 <blackh> HugoDaniel: I think that what you are trying to do can probably be done.  Does "gen n = NoiseModule n []" typecheck?
17:13:38 <Cale> If the list is 1000000 elements long, you end up with this giant unevaluated expression which looks like  max (max (... (max (max 1 2) 3) ...) 999999) 1000000
17:13:52 <burkaman> yeah, i see why that would be a problem
17:14:44 <burkaman> so how long would it generally take to calculate the max of 1000000 numbers?
17:14:46 <Cale> I kind of wish that GHC didn't limit the stack at all, but there are cases where the stack fills up very very quickly, much faster than the heap generally would.
17:15:00 <luite> burkaman: you can build it up in a different way and avoid the stack overflow, could be a fun exercise (but still much slower than the proper way with a strict fold)
17:15:03 <HugoDaniel> blackh: yes...
17:15:27 <HugoDaniel> blackh: it typechecks as n -> NoiseModule
17:15:51 <Cale> Well, not so long, except for this problem.
17:15:57 <blackh> HugoDaniel: I was wrong then. So, in 'gen' you have a thing of type NoiseClass n => n, and you want to match against the underlying NoiseModule value, right?
17:15:59 <Cale> So, foldl' will force the accumulating parameter to be evaluated before it proceeds on each step, so the expression never gets very large.
17:16:43 <Cale> Just a word of warning, it only evaluates it enough to determine the top-level constructor. So in the case of numeric types like Integer or Double, that's fine, but if it's a list, you might need to be more careful.
17:17:00 <Cale> (because it'll only force the evaluation just far enough to determine if the list is empty or not)
17:17:02 <HugoDaniel> blackh: no, i just want to avoid having this: NoiseModule (NoiseModule f []) [] (and so on...), because NoiseModule is an instance of NoiseClass
17:17:28 <pikhq> If you want to force more evaluation, make the function it's applying to the list more strict (via seq or bang patterns).
17:17:46 <Cale> Typically, these problems occur when the function you're folding with is strict anyway.
17:17:57 <blackh> HugoDaniel: Well, even that is not going to work because what you have is a "NoiseClass n => n".  You can't pattern match a NoiseModule against that.  How do you propose to get around that?
17:18:04 <blackh> (I need to understand this bit.)
17:18:14 <Cale> actually, a good way to spot where you'll need more strictness is where you're taking lots of little bits of data, and summarising them somehow.
17:18:14 <HugoDaniel> blackh: it works
17:18:27 <Cale> into a small piece of data
17:18:56 <HugoDaniel> anyway, im back to code, thanks for the help
17:19:07 <blackh> OK
17:19:15 <burkaman> so making my 1000000 item list is almost instantaneous, but finding the maximum was taking an obscenely long time
17:19:26 <burkaman> why would that happen?
17:19:42 <luite> because you didn't actually make that list the first time
17:20:10 <Traveler> http://hyfbt.com/mfQB
17:20:16 <Cale> If you write something like [1..1000000], it doesn't necessarily need to evaluate it unless you give it a reason to do so.
17:20:30 <Cale> > let x = [1..1000000] in 5 + 7
17:20:31 <lambdabot>   12
17:20:36 <Cale> Here, x isn't computed at all.
17:20:49 <Cale> and even if it does get computed, you might not compute the whole list
17:20:51 <Traveler> http://hyfbt.com/mfQB
17:20:53 <burkaman> no, but i mapped a function onto it and printed out the new list
17:20:56 <burkaman> and that was almost instantly
17:21:02 <Cale> okay, then it would compute it
17:21:12 <Cale> What type are the elements of the list?
17:21:16 <Traveler> http://hyfbt.com/mfQB
17:21:24 <burkaman> integral
17:21:27 <burkaman> that's a type, right?
17:21:32 <burkaman> wait no that's a type class
17:21:34 <Cale> Integral is a typeclass.
17:21:37 <burkaman> so
17:21:39 <burkaman> integer
17:21:40 <Cale> Probably Integer really
17:21:40 <burkaman> i guess
17:21:41 <Cale> yeah
17:21:48 <luite> burkaman: it can already print the first element before the rest of the list is computed
17:22:15 <Cale> yeah, when you go to print [1..1000000] it evaluates the first element, prints it, then evaluates the next one, prints that, and so on.
17:22:27 <merehap> is there a conflict between entirely different packages called 'numbers' for cabal? what I have installed is completely different from what is reported on hackage
17:22:28 <burkaman> what if i map a function onto it first?
17:22:30 <Traveler> http://hyfbt.com/mfQB
17:22:38 <burkaman> will it still print the first element before it evaluates the rest?
17:22:43 <Cale> That's right.
17:22:49 <burkaman> oooo
17:22:51 <burkaman> damn
17:23:01 <ivanm> @where ops
17:23:01 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
17:23:04 <luite> burkaman: yes, you could expand the definition a bit to see why
17:23:06 <merehap> I am trying to get the following package from cabal install numbers: http://hackage.haskell.org/packages/archive/Numbers/0.2.1/doc/html/Data-Numbers.html
17:23:09 <Cale> map f [1..1000000] -> map f (1 : [2..1000000]) -> f 1 : map f [2..1000000] -> ...
17:23:17 <ivanm> can someone kick Traveler so he stops spamming that stupid link?
17:23:25 --- mode: ChanServ set +o Cale
17:23:29 --- mode: Cale set +b *!*@pool-173-70-160-250.nwrknj.fios.verizon.net
17:23:29 --- kick: Traveler was kicked by Cale (Traveler)
17:23:29 <burkaman> so that's why it takes so long
17:23:30 <ivanm> ta Cale
17:23:31 <burkaman> ok, thanks
17:23:31 <luite> of course Cale is already faster than me in doing just that :p
17:23:36 --- mode: Cale set -o Cale
17:23:43 <ivanm> MrBlueSky: cabal install Numbers
17:23:44 <ivanm> :p
17:23:44 <allbery_b> likewise
17:23:47 <ivanm> grrr
17:23:51 <ivanm> merehap: cabal install Numbers
17:23:53 <ivanm> sorry MrBlueSky
17:24:02 * ivanm wishes there was xchat on this machine...
17:24:33 <merehap> ivanm: wow, I didn't know it was case sensitive, that's very confusing
17:24:37 <merehap> thanks!
17:24:39 <Cale> burkaman: If you write length (map f xs), then f will never be evaluated even :)
17:24:51 <merehap> now I will have numbers and Numbers on my machine :)
17:24:59 <Cale> burkaman: Though, the map will add a constant factor per element to the cost of computing the list.
17:25:08 <ivanm> merehap: no worries
17:25:13 <Cale> Er, constant term, I should say :)
17:25:37 <burkaman> yeah, that makes sense
17:25:55 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23112#a23112
17:26:49 <burkaman> but if i use foldl1' max
17:26:55 <burkaman> even if it takes an obscenely long time
17:27:04 <burkaman> it won't overflow the stack, right?
17:28:41 <Cale> yeah
17:29:46 <Cale> It may even run in constant space.
17:30:08 <Cale> because only a couple elements of the list ever need to be in memory at any one time.
17:30:25 <asdfqwer> http://hyfbt.com/MUh8
17:30:41 --- mode: ChanServ set +o Cale
17:30:47 --- mode: Cale set +b *!*@gateway/web/freenode/x-piivytiolffrpmzp
17:30:47 --- kick: asdfqwer was kicked by Cale (asdfqwer)
17:30:48 <HugoDaniel> how do i define an infix function without the ugly ` ?
17:30:56 --- mode: Cale set -o Cale
17:30:58 <HugoDaniel> can't a function just be infix ?
17:31:08 <Cale> HugoDaniel: name it using symbol characters only
17:31:20 <HugoDaniel> oh
17:31:22 <HugoDaniel> :(
17:31:30 <HugoDaniel> that reminds me of perl
17:31:38 <Cale> why?
17:31:45 <ivanm> and not ()
17:31:49 <ivanm> or else use `foo`
17:31:56 <Cale> Can you even define new infix functions in perl?
17:32:00 <ivanm> Cale: what do you reckon, that spammer is a bot?
17:32:01 <HugoDaniel> they have the strangest operators... very hard on the readability
17:32:07 <Cale> ivanm: probably...
17:32:26 <HugoDaniel> no, it reminds of perl because of the readability
17:32:39 <Cale> HugoDaniel: It depends on how you make use of things.
17:32:57 <Cale> If you use infix operators appropriately, then you can improve readability
17:33:06 <HugoDaniel> i would like hpaste to highlight functions between `
17:33:18 <HugoDaniel> vim does
17:34:57 <ivanm> HugoDaniel: then provide a patch to mmorrow
17:35:56 <McManiaC> mauke: http://npaste.de/IN/
17:36:12 <McManiaC> http://npaste.de/IO/
17:36:13 <McManiaC> =(
17:36:40 <mauke> --libs looks wrong
17:36:44 <glguy> HugoDaniel, hpaste uses the pygments library for syntax highlighting
17:36:52 <Cale> HugoDaniel: It doesn't highlight other functions though...
17:36:59 <McManiaC> oi! thx
17:37:03 <Cale> (only definitions)
17:37:25 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23113#a23113 -- but it gets this wrong
17:37:49 <HugoDaniel> i also dont understand why integers must be in a diff color than doubles
17:37:55 <Cale> It's `test` which ought to be highlighted, because it's the thing being defined there
17:38:01 <Cale> But that requires proper parsing.
17:38:28 <HugoDaniel> indeed
17:38:41 <HugoDaniel> thats a nice example
17:38:45 <Cale> Fractional literals do have a different type
17:38:49 <Cale> :t 10.0
17:38:50 <lambdabot> forall t. (Fractional t) => t
17:38:52 <Cale> :t 10
17:38:53 <lambdabot> forall t. (Num t) => t
17:38:57 <HugoDaniel> :t 10 :: Double
17:38:58 <lambdabot> Double
17:39:27 <Cale> Double is an instance of Num
17:39:36 <Cale> but for example, Integer is not an instance of Fractional
17:39:53 <HugoDaniel> ah ok, yes :)
17:40:20 <Cale> Whether that warrants using a different colour for them, I don't know.
17:43:57 <HugoDaniel> when im coding in haskell i always have this feeling that im just writing an obscure monad already defined somewhere in hackage
17:44:17 <McManiaC> mauke: it *finally* compiled
17:44:19 <McManiaC> thank you very much
17:44:20 <McManiaC> :D
17:47:09 <HugoDaniel> i also solved my problem with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=23114#a23114
17:47:11 <HugoDaniel> thanks :)
17:50:32 * hackagebot nonlinear-optimization 0.3 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3 (FelipeLessa)
17:50:46 <HugoDaniel> if it aint documented, and if it has no tests, then its a bug...
17:50:54 <Cale> ugh, System.Process defines a function named proc, which conflicts with arrow syntax.
17:51:25 <SubStack> hooray, mueval looks like it does exactly what I had hoped that I wouldn't need to write
17:52:06 <SubStack> in order to build crazy introspective type graphs
18:00:28 <SubStack> oh wow and hint looks like it will be tremendously useful
18:00:40 <HugoDaniel> is there any way to use record selector functions in existential types ?
18:00:49 <HugoDaniel> existential types are quite the pain...
18:03:58 <HugoDaniel> sleepy time, thanks
18:06:16 <choffstein> Hey all -- any idea why I might be getting the error:  Couldn't match expected type `SB.ByteString' against inferred type `bytestring-0.9.1.4:Data.ByteString.Internal.ByteString' where I have 'import qualified Data.ByteString as SB' in my application?
18:07:49 <ivanm> choffstein: do you have two versions of bytestring installed?
18:07:58 <ivanm> (ghc-pkg list | grep -i bytestring)
18:08:10 * ivanm can never remember if the package name is capitalised or not
18:08:19 <choffstein> Looks like I do!
18:08:26 <choffstein> 9.1.4 and 9.1.5
18:08:48 <choffstein> How in the world did that happen...
18:09:39 <ivanm> choffstein: because you probably installed something with cabal-install that figured it could upgrade bytestring
18:09:41 <ivanm> but you shouldn't
18:10:01 <choffstein> so how should I handle this?
18:10:19 <ivanm> how do you install haskell stuff?
18:10:28 <choffstein> well, normally just with cabal
18:10:33 <choffstein> cabal-install
18:10:58 <choffstein> but I just installed the zeromq bindings with runhaskell and what-not
18:10:59 <ivanm> right-o
18:11:04 <ivanm> same diff
18:11:07 <choffstein> Okay
18:11:14 <ivanm> just checking it wasn't a distro package or something
18:11:26 <ivanm> so do "ghc-pkg unregister bytestring-0.9.1.5", then do "ghc-pkg check" and rebuild all packages that are reported to be broken
18:12:06 <choffstein> so force it since it is complaining about breaking packages?
18:14:26 <ivanm> yup
18:15:01 <choffstein> any way to bulk rebuild them?
18:15:08 <choffstein> or do I do them one by one?
18:17:05 <ivanm> cabal-install --reinstall should do it I think
18:17:20 <ivanm> maybe do it with --dry-run first to make sure it doesn't bring bytestring back though
18:17:27 <ivanm> *cabal install --reinstall
18:18:23 <choffstein> still wants a package name
18:18:39 <ivanm> ummm, yeah, give it the package name ;-)
18:18:50 <ivanm> "ghc-pkg check" will spit out the broken packages
18:18:53 <choffstein> Was hoping I could bulk update em :D
18:19:02 <ivanm> give them all to cabal-install
18:19:11 <ivanm> pretty sure it can cope with multiple packages
18:19:56 <choffstein> ah, yes, it can!  fantastic!
18:20:07 <choffstein> well, rebuilding now.  hopefully this works!
18:21:37 <choffstein> VICTORRRRYYY!
18:23:11 <ivanm> \o/
18:23:12 <choffstein> You are a legend.  Thank you
18:23:17 <ivanm> no worries
18:23:45 <choffstein> I just have to power through all these little details so I can really fall in love with haskell
18:25:01 <McManiaC> is it possible to convert a "foo :: a -> b" function into a "bar :: c -> d" function if I have the functions to convert a to c and b to d?
18:25:22 <ivanm> McManiaC: ummm...
18:25:23 <copumpkin> precompose and postcompose!
18:25:44 <ivanm> b2d . foo . c2a
18:25:49 <copumpkin> @djinn (a -> c) -> (b -> d) -> (a -> b) -> (c -> d)
18:25:49 <lambdabot> -- f cannot be realized.
18:25:52 <pikhq> McManiaC: bar = castBtoD . foo . castAtoC
18:25:53 <tensorpudding> (c -> d) . (b -> c) . (a -> b) :: (a -> d)
18:26:02 <ivanm> pickles: you mean castCtoA
18:26:11 <ivanm> copumpkin: so do you
18:26:22 <pikhq> ivanm: Pickles?
18:26:24 <ivanm> @djinn (c -> a) -> (b -> d) -> (a -> b) -> (c -> d)
18:26:24 <lambdabot> f a b c d = b (c (a d))
18:26:26 <ivanm> grrr
18:26:28 <copumpkin> that's the one
18:26:29 <ivanm> I mean pikhq
18:27:06 <ivanm> pikhq: I'm used to xchat's tab-completion behaviour where it returns the last used nick first; I'm using quassel atm which does them in alphabetical order
18:27:10 <ivanm> sorry pickles
18:27:16 <pikhq> ivanm: Mmm.
18:27:21 <copumpkin> ivanm: it's okay sweetie
18:27:26 <ivanm> @slap copumpkin
18:27:26 * lambdabot clobbers copumpkin with an untyped language
18:27:38 <ivanm> anyway, you two need to learn how to match the types up better ;-)
18:27:58 <McManiaC> hmkay
18:28:03 <McManiaC> thx
18:28:04 <McManiaC> =)
18:28:07 <ivanm> no worries
18:28:44 <burkaman> Does anybody have any ideas for a fairly simple Haskell project?
18:29:20 <ivanm> burkaman: stand alone or help out with a larger one?
18:29:29 <burkaman> stand alone
18:29:30 <tensorpudding> write a go compiler
18:29:44 <FliPPeh> write me a sandwich
18:29:44 <ivanm> @slap tensorpudding
18:29:44 * lambdabot would never hurt tensorpudding!
18:29:51 <ivanm> burkaman: see the haskell_projects reddit
18:30:15 <ivanm> (or whatever it is)
18:30:35 <burkaman> oh cool
18:30:35 <burkaman> thanks
18:30:36 <copumpkin> proposals
18:30:37 <ivanm> http://www.reddit.com/r/haskell_proposals/
18:30:39 <ivanm> that's the one
18:31:27 <burkaman> yeah, that's way outta my league
18:31:32 <burkaman> i started learning haskell a week ago
18:33:54 <SubStack> burkaman: there's always http://projecteuler.net/
18:34:07 <burkaman> yeah, that's what i've been doing
18:34:18 <burkaman> i was just wondering if anyone had any other ideas
18:34:20 <SubStack> there are also plenty of libraries that haven't been written
18:34:36 <SubStack> get out there and shave some yaks!
18:35:07 <McManiaC> what would be the Foreign.C type for "NULL"?
18:35:18 <McManiaC> undefined?
18:36:01 <copumpkin> it's a void *
18:36:03 <SubStack> undefined isn't a type
18:36:08 <ivanm> SubStack: noooo!!!!
18:36:16 <ivanm> stop recommending project euler to people!
18:36:28 * ivanm still has nightmares about Haskelllove and his obsession with project euler
18:36:35 <McManiaC> haha
18:36:36 <copumpkin> ivanm doesn't want people overtaking his project euler score
18:36:47 <ivanm> I have never used project euler
18:36:51 <SubStack> I bet
18:36:59 <ivanm> and the only time I have been to the site is when people asked for help with them
18:37:24 * ivanm learnt haskell by converting  a sudoku solver to a generalised latin square generator, not by doing stupid useless problems
18:37:37 <Adamant> ivanm++
18:37:46 <copumpkin> "converting  a sudoku solver to a generalised latin square generator, not by doing stupid useless problems"
18:38:01 * copumpkin tries not to giggle
18:38:45 <McManiaC> copumpkin: so nullPtr ?
18:39:09 <ivanm> copumpkin: I was getting paid AUD$350 a week for a summer research project
18:39:20 <SubStack> o_O
18:39:21 <pikhq> ivanm: Project Euler is decent for getting used to thinking functionally.
18:39:28 <pikhq> Obviously, though, you will outgrow this pretty quickly.
18:39:32 * copumpkin only thinks dysfunctionally
18:39:32 <ivanm> (and I'm still doign that project on and off)
18:39:43 <ivanm> copumpkin: well, yes, but you _are_ dysfunctional
18:39:48 <pikhq> (I'd say after about 5 to 10 Euler problems)
18:39:50 <SubStack> also, hint++
18:39:51 <copumpkin> I guess that would explain it though
18:39:59 <copumpkin> -though
18:41:18 <McManiaC> pikhq: because of those biiiiiiiig numbers at project euler you actually cannot solve many of those problems in a functional way
18:41:38 <McManiaC> I always run out of memory at problem 3 for example with haskellâ¦
18:41:39 <McManiaC> ^^
18:41:57 <ivanm> or else you're just doing it wrong...
18:42:02 <arw> problem 3 was only palindroms, right?
18:42:13 <Adamant> ivanm: I have no idea who would fund a sudoku to latin square generator, but more power to you for getting paid for it :P
18:42:19 <McManiaC> Find the largest prime factor of a composite number.
18:42:26 <ivanm> Adamant: ummm.... a maths department?
18:42:35 <Adamant> ivanm: that would work :P
18:42:38 <ivanm> Adamant: and the project was on generating specific types of latin squares
18:42:39 <McManiaC> and the number is 600851475143 (lol)
18:43:08 <ivanm> I just started off (since I was teaching myself haskell at the same time) by hacking on bird+hutton's sudoku solver
18:43:20 <pikhq> McManiaC: Problem 3? Even my horribly naive implementation of that didn't have issues.
18:43:25 <Adamant> ivanm: I was just thinking getting that funded in a CS department would be fun, to say the least :P
18:43:27 <pikhq> It took forever, but that was it.
18:43:37 <my_haz> anyone wish to recommend a book for someone who knows python but wants to learn haskell?
18:43:41 <pikhq> (... I did prime factors by searching through the list of primes. XD)
18:44:01 <ivanm> Adamant: and it was an undergrad summer vac project, so *shrug*
18:44:04 <arw> McManiaC: http://pbot.rmdir.de/c6278fea3a49084d01695fe6cca27570
18:44:09 <tensorpudding> take the square root, and keep testing numbers for primality going down until you hit one, and then test-divide the number by it
18:44:11 <McManiaC> pikhq: hmmâ¦ I tried the "naive implementation", run out of memory, tried the primes package from hackage, run out of memory, tried a very imperative way, run out of memoryâ¦
18:44:14 <McManiaC> ^^
18:44:23 <arw> McManiaC: my first solution, doesnt run out of stack, memory or cpu time.
18:44:26 <pikhq> McManiaC: ...
18:44:29 <McManiaC> :D
18:44:33 <tensorpudding> writing a fast primality test is the only niggle
18:44:52 <pikhq> I did the *stupidest primality test possible* and didn't have issues.
18:45:08 <McManiaC> weird
18:45:08 <tensorpudding> but even a trial-division one shouldn't cause a stack overflow for < 15 digit numbers
18:45:08 <McManiaC> ;P
18:45:31 <arw> tensorpudding: right, see my stupid solution :)
18:45:56 <pikhq> arw: That's close to what I did.
18:46:14 <pikhq> Though I think I had more crazy pointfree stuff going on.
18:46:28 <pikhq> (so I figured out pointfree-ness that day.)
18:47:54 <McManiaC> arw: how do you ensure you get a prime however?
18:48:05 <McManiaC> oh mhm
18:48:07 <McManiaC> smallest
18:48:08 <McManiaC> ok
18:48:09 <McManiaC> :D
18:48:35 <arw> its actually some stupid kind of primality test...
18:49:52 <tensorpudding> > let isPrime n = all (\i -> n `mod` i /= 0) (takeWhile (\i -> i^2 <= n) primes); primes = 2:3:filter isPrime candidates; candidates = do n <- [1..]; [6*n-1,6*n+1] in take 30 primes
18:49:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:51:18 <ivanm> preflex: seen Cale
18:51:19 <preflex>  Cale was last seen on #haskell 1 hour and 25 seconds ago, saying: ugh, System.Process defines a function named proc, which conflicts with arrow syntax.
18:51:59 <ivanm> anyone here know anything about graph minors?
18:52:47 <burkaman> you could always google it
18:52:59 <tensorpudding> you could probably implement the sieve of eratosthenes too
18:53:14 <twink> Wheels are moderately easy.
18:53:57 <decker> so in something like this: "sumList (x:xs) = x + sumlist xs", are the parenthesis really necessary?
18:54:41 <copumpkin> yes
18:55:04 <ivanm> burkaman: I'm trying to get clarification of what wikipedia says ;-)
18:55:05 <decker> copumpkin: can you expand on that a bit
18:55:29 <ivanm> decker: because that will normally be parsed as: "(sumList x) : xs"
18:55:30 <copumpkin> decker: it's just syntactic. You need those parentheses or it doesn't know what you mean
18:55:56 <ivanm> which is wrong, especially when you're defining the function
18:56:11 <RichardO> Is it possible to work with dph in ghci?
18:56:20 <decker> ivanm: ok, yeah, I gotccha.  thanks.
18:57:49 <ivanm> RichardO: not sure
18:58:03 <ivanm> what's ChilliX's new nick to see if he's here?
18:58:03 <copumpkin> RichardO: I think so, but you won't get any of the advantages
18:58:07 <copumpkin> TacticalGrace
18:58:33 <ivanm> that's the one
18:58:37 <ivanm> preflex: seen TacticalGrace
18:58:37 <preflex>  TacticalGrace was last seen on #haskell-in-depth 1 day, 23 hours, 30 minutes and 29 seconds ago, saying: sure
18:58:54 <ivanm> RichardO: ^^ ask him, he's the head dph guy AFAIK
19:08:24 <decker> ivanm: I guess I should ask then, do functions have the highest precedence?  and I suppose they're left associative?  or is it completely wrong to even talk about precedence and associativity of functions?  I mean, ":info sum" doesn't spit out anything about it.
19:10:34 <arw> functions do have the highest precedence.
19:12:35 <aavogt> record update syntax has higher precedence
19:13:16 <decker> hmm, and I suppose associativity doesn't make sense really now that I think about it.
19:13:43 <aavogt> decker: and if you don't specify  infixr 6 `op` , it ends up being infixl 9 or something like that
19:14:39 <aavogt> > let op = (/); infixr `op` in 1 `op` 2 `op` 4
19:14:40 <lambdabot>   2.0
19:14:50 <aavogt> > let op = (/) in 1 `op` 2 `op` 4
19:14:51 <lambdabot>   0.125
19:15:42 <decker> I see.  thanks
19:16:16 <decker> odd that ":info infixr" complains though.
19:16:31 <aavogt> infixr is a keyword
19:16:55 <decker> ok, thanks
19:22:47 <aavogt> hmm, so Alternative doesn't let you go    f (Maybe a) -> f a, right/
19:24:00 <aavogt> @type sequenceA
19:24:01 <lambdabot> Not in scope: `sequenceA'
19:24:08 <aavogt> @type Data.Traversable.sequenceA
19:24:09 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
19:25:11 * aavogt is looking for an inverse of that...
19:31:10 <idnar> @type (<|>)
19:31:11 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
19:31:23 <idnar> :t maybe
19:31:24 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:31:49 <idnar> :t fromMaybe
19:31:50 <lambdabot> forall a. a -> Maybe a -> a
19:32:04 <idnar> :t fromMaybe empty
19:32:05 <lambdabot>     Ambiguous occurrence `empty'
19:32:05 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
19:32:05 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
19:32:14 <idnar> :t fromMaybe Control.Applicative.empty
19:32:15 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe (f a) -> f a
19:32:19 <aavogt> and yeah, fmap (fromMaybe undefined) isn't enough ;)
19:32:20 <darrint> tryhaskell.org seems dead.
19:32:21 <idnar> :t fmap (fromMaybe Control.Applicative.empty)
19:32:22 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Alternative f, Functor f1) => f1 (Maybe (f a)) -> f1 (f a)
19:32:29 <idnar> hrm, not quite
19:32:37 <aavogt> yeah, then I need join
19:32:45 <idnar> oh, I'm being silly
19:33:36 <aavogt> overall my goal is:     (f :: a -> b -> c -> Maybe d) <*> a <*> b <*> c
19:33:52 <idnar> :t (<*>)
19:33:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:33:53 <aavogt> overall my goal is:     (f :: a -> b -> c -> Maybe d) <*> a <*> b <*> c :: Alternative f => f d
19:35:30 <sshc> is there a ByteString equivilent of Data.ByteString.Lazy?
19:35:54 <idnar> yeah, I don't really see any way to do that
19:35:57 <aavogt> that module is part of bytestring
19:36:27 <sshc> s/ByteString/lookup/
19:36:31 <sshc> @hoogle lookup
19:36:31 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
19:36:32 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
19:36:32 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
19:37:15 <sshc> oh, right, lookup's key isn't limited to String
19:37:29 <aavogt> I'm thinking about how    (Maybe . f)  is also applicative
19:37:50 <idnar> Maybe . f or f . Maybe?
19:37:58 <aavogt> either way
19:39:00 <idnar> you can go the other way around easily
19:39:05 <idnar> :t fromMaybe empty
19:39:06 <lambdabot>     Ambiguous occurrence `empty'
19:39:06 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
19:39:06 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
19:39:10 <aavogt> anyways, I think alternative limits you to stuff like    \x ->  fmap Just x <|> pure Nothing :: f a -> f (Maybe a)
19:39:12 <idnar> :t fromMaybe Control.Applicative.empty
19:39:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe (f a) -> f a
19:39:20 <aavogt> with no going backwards
19:39:56 <aavogt> @hackage spoon
19:39:57 <lambdabot> http://hackage.haskell.org/package/spoon
19:40:46 <idnar> lies, there is no spoon
19:40:49 <aavogt>   spoon $ fromJust <$> x
19:42:06 <aavogt> but if there's no pure way to get that function, I suppose that use of unsafePerformIO isn't good
19:42:39 <tommd> we need a safeUnsafePerformIO
19:43:17 <aavogt> it doesn't matter how many letters it is, it's how you use it
19:43:59 <sshc> tommd: that name is contradictory
19:44:18 <aavogt> though I suppose that the NFData constraint sort of implies that you know the structure of the Alternative
19:44:38 <sshc> we might need reallyVerySafePerformIO, but we don't.
19:45:43 <aavogt> in any case, I'm trying to avoid a confusing case with some quasi-quotes where the result type currently depends on whether or not there are partial patterns being matched
19:46:43 <idnar> hmm, if it's safe, there should be some way to do it more reasonably
19:50:30 <aavogt> well anyways, the actual values that the fromJust operates don't necessarily exist yet
19:50:53 <aavogt> ie. some structures don't have sensible NFData instances because they are like functions
19:51:11 <aavogt> so I think that spoon won't do the right thing
19:56:25 <idnar> aavogt: so there should be some other type class or combination that covers the structures that are safe for this
19:56:31 <idnar> I wonder if that's just Monad
19:58:01 <aavogt> yeah, MonadPlus is sufficient
19:58:37 <aavogt> @type (fromMaybe mzeron =<<)
19:58:38 <lambdabot> Not in scope: `mzeron'
19:58:42 <aavogt> @type (fromMaybe mzero =<<)
19:58:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe (m a)) -> m a
19:58:58 <aavogt> @type (maybe mzero return =<<)
19:59:00 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
20:09:11 <idnar> @type (fmap mzero return =<<)
20:09:12 <lambdabot> forall (m :: * -> *) b a (m1 :: * -> *). (MonadPlus ((->) (m1 a)), Monad m1, Monad m) => m a -> m b
20:09:24 <idnar> oh, I want fold, not fmap
20:09:32 <idnar> nevermind
20:11:30 <krainboltgreene> I return.
20:11:37 <tensorpudding> ugh, IO and lazy lists cannot work together
20:12:58 <c_wraith> tensorpudding: unsafeInterleaveIO  >_>
20:13:07 <c_wraith> (also, don't do anything I recommend)
20:13:47 <tensorpudding> or at least, filterM/mapM on lazy lists won't work
20:13:55 <glguy> Some people when faced with a problem try lazy IO, now they have two problems
20:14:13 <glguy> tensorpudding: it will if the monad is lazy enough
20:14:35 <tensorpudding> (in IO)
20:14:54 <c_wraith> Lazy IO is sometimes not wrong.  But most of the time, it's very wrong.
20:15:17 <aavogt> people are wrong most of the time anyways
20:15:22 <tensorpudding> all i want the IO for is generating random numbers
20:15:37 <pikhq> Less so in Haskell than other languages.
20:15:46 <glguy> tensorpudding: then consider a function like randoms
20:15:49 <glguy> :t randoms
20:15:50 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
20:16:08 <c_wraith> Eh.  the Random interface is unfortunately broken.
20:17:35 <tensorpudding> does that use unsafePerformIO?
20:17:37 <c_wraith> unsafeInterleaveIO *can* be used safely for hooking to a system randomness source like /dev/urandom on linux, or the like
20:17:42 <glguy> tensorpudding: no
20:18:45 <tensorpudding> how does it not get wrapped in IO then...
20:19:01 <glguy> :t random
20:19:02 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
20:19:14 <glguy> it just passes a generator around, like the rest of the non-IO random numbers
20:19:17 <aavogt> because the RandomGen contains the generator state
20:19:25 <tensorpudding> hmm
20:19:34 <pikhq> You only use IO to get the seed.
20:21:31 <tensorpudding> hmm
20:22:16 <tensorpudding> i still need to run the generator though
20:22:50 <c_wraith> which is ok, until you need stronger guarantees.  The RandomGen interface doesn't give any way to reseed a CSPRNG when necessary.
20:23:32 <tensorpudding> i don't see how i can use filterM with this though
20:23:48 <c_wraith> why do you think you need to use filterM?
20:25:06 <tensorpudding> because i need to filter a list of numbers, based on the result of running a function on the number that takes a random variable
20:31:49 <Saizan> seen the Rand monad?
20:31:59 <Saizan> which is just State StdGen
20:34:20 <copumpkin> > fix eat -- ouroborus
20:34:21 <lambdabot>   Not in scope: `eat'
20:36:37 <pikhq> > fix (():) -- What a funny monster, the list. It can be its own tail.
20:36:38 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
20:39:02 <cpettitt> Is there any documentation about how to decode the name mangling in the -ddump_simpl output?
20:40:17 <aavogt> preflex: zdec doeszzitzzinvolveza
20:40:17 <preflex>  doeszitzinvolve&
20:43:41 <ddarius> > fix (Mu . Just)
20:43:42 <lambdabot>   Not in scope: data constructor `Mu'
20:43:47 <ddarius> > fix (In . Just)
20:43:48 <lambdabot>   No instance for (GHC.Show.Show (L.Mu Data.Maybe.Maybe))
20:43:48 <lambdabot>    arising from a u...
20:43:56 <ddarius> 'the heck?
20:46:52 <Saizan> someone forgot to derive it
20:46:57 <copumpkin> writing a Show for Mu is complicated
20:47:07 <copumpkin> I think you need a standalone deriving?
20:47:09 <c_wraith> I hate bits >_>
20:47:16 <ddarius> copumpkin: I've done it before a few times.
20:47:31 <ddarius> Trinary computers all the way!
20:47:36 <copumpkin> :)
20:47:45 <c_wraith> why is this documentation written as though we have variable-length bit arrays, rather than word arrays?
20:48:13 <ddarius> We do have variable length bit arrays.
20:49:00 <rpglover64> I have a question: I have a [IO (Either a b)], and I would like to get the evaluate the IO monads until I get a right and return that; is there a combination of builtin functions that will do that, or do I have to resort to writing my own function to do the traversal/filtering?
20:49:23 <copumpkin> @instances MonadPlus
20:49:24 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:49:37 <ddarius> If you map ErrorT over it and then sequence you might get the behavior you want.
20:49:49 <copumpkin> > msum [Left undefined, Left undefined, Right True, Left ()]
20:49:50 <lambdabot>   No instance for (Control.Monad.Error.Class.Error ())
20:49:51 <lambdabot>    arising from a use ...
20:49:57 <copumpkin> meh, fuck you
20:50:01 <ddarius> Albeit, do to annoyances, a will need to be a instance of Error.
20:50:10 <ddarius> copumpkin: I thought you were a clean mouthed saint?
20:50:12 <copumpkin> > msum [Left undefined, Left undefined, Right True, Left ""]
20:50:13 <lambdabot>   Right True
20:50:19 <rpglover64> a happens to be IOError
20:50:31 <ddarius> Er, you'd also have to switch left and right.
20:50:34 <copumpkin> :t fmap msum
20:50:35 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (MonadPlus m, Functor f) => f [m a] -> f (m a)
20:50:42 <rpglover64> * IOException
20:51:12 <copumpkin> :t fmap msum . sequence
20:51:13 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (MonadPlus m, Functor f, Monad f) => [f (m a)] -> f (m a)
20:51:21 <copumpkin> ugh :)
20:51:24 <ddarius> copumpkin: sequence will execute all the actions first.
20:51:29 <copumpkin> true
20:51:44 <copumpkin> meh
20:51:56 <copumpkin> we really need an untilM
20:51:57 <ddarius> Also, what do you want to happen in the empty list case?
20:52:08 <rpglover64> I don't care
20:52:43 <ddarius> What do you want to happen if there are no Rights?
20:53:03 <aavogt> lazy IO is one answer here
20:53:06 <copumpkin> then we shall fight for them!
20:53:12 <Saizan> why lazy IO?
20:53:20 <rpglover64> I'm not sure
20:53:23 <rpglover64> something
20:53:33 <copumpkin> > msum [Left "moo"]
20:53:34 <lambdabot>   Left ""
20:53:35 <Saizan> ?type msum . map ErrorT
20:53:36 <lambdabot> forall a (m :: * -> *) e. (Monad m, Error e) => [m (Either e a)] -> ErrorT e m a
20:53:50 <rpglover64> sorry; slightly distracted
20:54:10 <aavogt> Saizan: then you can     (fmap (dropWhile isLeft) . sequence . map unsafeInterleaveIO)
20:54:10 <Saizan> this will stop at the first Right and return it, without executing all the IO first
20:54:45 <copumpkin> :t unsafeInterleaveIO
20:54:46 <lambdabot> Not in scope: `unsafeInterleaveIO'
20:54:46 <aavogt> or am I completely wrong here?
20:54:51 <copumpkin> @hoogle unsafeInterleaveIO
20:54:52 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
20:55:03 <Saizan> aavogt: yeah, but we've "msum . map ErrorT" which does the same without messing with IO
20:55:13 <Saizan> s/IO/lazy IO/
20:55:18 <ddarius> aavogt: That should work, but at that point you might as well use map unsafePerformIO and save yourself the sequence.
20:55:45 <rpglover64> I'd prefer to stay away from unsafe functions if I can...
20:56:00 <Saizan> i believe there's even an Error IOError instance
20:56:06 <ddarius> There is.
20:57:06 <Saizan> in fact, if it were just an [IO a] where the IOError's get thrown, you could simply use msum, in case that's simple for you
20:57:21 <Saizan> s/simple/simpler/
20:57:55 <rpglover64> That might work...
20:58:24 <rpglover64> Let me try.
21:01:34 <rpglover64> No instance for (MonadPlus IO)
21:01:50 <copumpkin> yeah, and you can't make it one
21:02:02 <Saizan> it's defined somewhere
21:02:06 <copumpkin> really?
21:02:18 <copumpkin> hmm
21:02:22 <Saizan> yeah, i think Control.Monad.Instances ?
21:02:29 <copumpkin> oh, it's alternative that you can't do
21:03:23 <Saizan> rpglover64: in Control.Monad.Error
21:03:56 <copumpkin> it doesn't satisfy the laws though?
21:04:14 <roboshibby> have you guys seen that tv show NCIS with "abby" character on it?
21:04:19 <Saizan> m `mplus` mzero = mzero is pretty discutible, i guess :)
21:04:21 <copumpkin> #haskell-blah
21:04:31 <roboshibby> well anyway, she sux
21:04:33 <rpglover64> Thank you.
21:04:41 <rpglover64> That's kind of awesome.
21:04:46 <rpglover64> Saizan++
21:04:58 <rpglover64> copumpkin++
21:05:09 <rpglover64> ddarius++
21:05:31 <copumpkin> sounds like you want a map (++) :)
21:11:50 <rpglover64> @instances MonadPlus
21:11:51 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
21:13:00 <maurer_> cabal-install doesn't seem to want to install wxcore for me. No apparent errors other than "configuration failed"
21:15:44 <Saizan> wxcore probably uses a configure script and a custom build system, however there's a page on the haskellwiki on how to install wx
21:22:53 <maurer_> Saizan: The page on the wiki claims that "cabal install wx" will work.
21:23:54 <maurer_> Nevermind, found the issue.
21:48:06 <krainboltgreene> OOM BOP.
21:48:51 <aavogt> is this (ab)use of irrefutable patterns sensible: http://code.haskell.org/~aavogt/ado/Language-Haskell-Meta-QQ-ADo.html
21:49:31 <aavogt> hmm, typo in the case where the pattern has a ~
21:52:10 <ddarius> aavogt: You have at least two typos in the second desugaring.
21:52:42 <ddarius> And what is the desugaring of (x:xs) <- foo bar ?
21:53:19 <aavogt> same as it is for Just
21:53:41 <ddarius> It's not obvious to me what "same" is.
21:54:03 <aavogt> I see
21:55:06 <aavogt> ddarius: on pattern match failures you get   pure Nothing  +- whatever effects all the bindings do
21:56:29 <roboshibby> do any of you guys know the flippo person who just left?
21:56:58 <ddarius> I, personally, would simply put the pattern, unchanged, in the relevant lambda.
21:58:08 <aavogt> yeah, it's probably confusing to implicitly 'catch' those pattern match failures
21:58:26 <aavogt> especially as they result in a different type
22:21:21 <SubStack> hooray I can now build a list of export names and TypeReps for at least simple haskell source files
22:25:46 <krainboltgreene> Hmm, Haskell Cairo binding?
22:26:14 <Cale> It comes with Gtk2Hs
22:30:29 <krainboltgreene> So there isn't a standalone hcairo?
22:36:43 <Cale> not as far as I know
22:38:39 <krainboltgreene> Ah-ha! http://www.cairographics.org/hscairo/
22:39:18 <copumpkin> note that the more up to date ones are in gtk2hs, even on that page
22:41:55 <roboshibby> have you guys seen that rosetta stone tv commercial?
22:42:11 <roboshibby> with the woman in the undersized blue shirt
22:42:19 <roboshibby> the shirt she... bursts, out of
22:43:54 <roboshibby> damn she makes me want to either buy that product or take a cold shower.. *shudder*
22:44:11 <Saizan> roboshibby: that's not a topic appropriate for this forum
22:44:24 <roboshibby> what, showering?
22:45:03 <Saizan> we try to keep the discussion on #haskell focused on the language itself or Computer Science in general
22:45:11 <Saizan> for anything else there's #haskell-blah
22:45:20 <roboshibby> ok, thank you saizan
22:51:12 <krainboltgreene> Yeah, you're disturbing all the Haskell talk going on.
22:51:26 * ski nods gravely
22:55:29 <Saizan> so, anyone has read the scoped labels paper? the implementation part seems to just use arrays behind the scenes, that would make extension O(n), i wonder if it doesn't actually matter
22:55:58 <Saizan> though i'm not sure what would be a good benchmark for extensible records
23:00:51 <roboshibby> scoped labels? please expand
23:02:21 * twink doesn't know what a scoped label is either.
23:02:26 <Saizan> http://lambda-the-ultimate.org/node/1119 <- i'm referring to this paper, it's about adding extensible records to a language like haskell
23:13:41 <twink> Don't row types have that covered?
23:15:48 <Saizan> yeah, this is a small twist on row types
23:16:10 <Saizan> where a label can appear more than once in a single row
23:16:39 <Saizan> which makes things a bit simpler, and perhaps more useful too
23:17:03 <Saizan> the "scopeness" comes from this
23:17:58 <Saizan> since a select operation takes the value associated with the first occurrence of the label
23:21:28 <Cale> Each label/type pair behaves like a stack. It avoids lacks predicates.
23:22:26 <dolio> The rows are stacks of label/type pairs.
23:27:09 <Saizan> i was thinking that it shouldn't be hard to implement it with typeclasses and unsafeCoerce
23:27:46 <twink> "avoids lacks predicates" ?
23:28:08 <Saizan> class HasLabel row l e | row l -> e where index :: row -> l -> Int
23:28:29 <dolio> In previous formulations, you usually had to write things like: forall r :: Row. r / label => { label :: type | r }
23:28:59 <dolio> Where r / label says that r doesn't contain label.
23:29:06 <dolio> Or, lacks label.
23:37:50 * twink has always had trouble understanding row types except as some sort of device to accomplish something basically the same as structural subtyping.
23:52:07 <aavogt> it was not apparent to me that this is legal:    module X (module X) where { ... }
23:54:47 <chrisdone> parentheses are legal?
23:54:48 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
23:54:55 <chrisdone> @messages
23:54:55 <lambdabot> ivanm said 8h 27m 16s ago: for some reason, tryhaskell.org doesn't let me hit enter and thus do anything haskelly (but it does allow "help" and "stepN")
23:55:03 <chrisdone> fixed that
23:55:32 <aavogt> chrisdone: as in you can name the module itself in your export list
23:55:50 <aavogt> as opposed to writing:   module X where { ... }
23:56:49 <Twey> aavogt: But why?  :Ã¾
23:57:43 <dons> a post on using GAs to evolve llvm flags for haskell, http://www.reddit.com/r/programming/comments/b7p40/evolving_faster_haskell_programs_now_with_llvm/
23:58:06 <aavogt> why anybody would do such a thing? or why I was surprised to see that in some code
23:58:17 <Twey> What is the purpose?
23:58:50 <aavogt> it's a placeholder for a more restrictive export list later on?
23:58:55 <Twey> Hm
