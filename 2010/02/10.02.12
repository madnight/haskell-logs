00:00:35 <kmc> it would be problematic for the type checker to figure out when it should see t as t, and when it should see t as [t]
00:02:58 <kmc> the solution in Haskell is to make this explicit.  if you want something like an infinite type, you create a recursive datatype.  the type checker needn't guess when to wrap or unwrap the recursion; you tell it explicitly by applying the type's constructor and deconstructor
00:07:13 <Gracenotes> @type Mu
00:07:15 <lambdabot> Not in scope: data constructor `Mu'
00:07:37 <Gracenotes> @type In
00:07:38 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
00:08:27 <Gracenotes> @type fix In (:[])
00:08:28 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
00:08:29 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
00:08:29 <lambdabot>       Expected type: f (Mu f)
00:08:42 <Gracenotes> oh.. silly
00:10:03 <kmc> @src Mu
00:10:03 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
00:10:08 <kmc> @kind Mu
00:10:09 <lambdabot> (* -> *) -> *
00:10:11 <kmc> @type In
00:10:12 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
00:11:23 <ski> kmc : rational tree unification is possible .. but allowing it would hide and/or delay many common mistakes
00:12:15 <ski> (if you want to play with it, you can try `ocaml -rectypes')
00:13:15 <quicksilver> in fact, it makes every term typecheck doesn't it?
00:13:21 <ski> @type fix (In . repeat)
00:13:22 <lambdabot> Mu []
00:13:56 <ski> quicksilver : no
00:13:59 <quicksilver> hmm, not, not quite.
00:14:08 <ski> (e.g. `let f x = if x then x + 1 else x' still gives a type error)
00:14:13 <quicksilver> not atomic contradictions like Int /= Char
00:17:25 <ski> preflex: seen lunabot
00:17:25 <preflex>  lunabot was last seen on #haskell 13 days, 54 minutes and 39 seconds ago, saying:  31
00:17:33 <ziman> @type fix (In . return)
00:17:34 <lambdabot> forall (f :: * -> *). (Monad f) => Mu f
00:17:53 <quicksilver> it makes surprsiingly many terms typecheck though
00:18:03 <ski> @type fix (extract . out)
00:18:04 <lambdabot>     Couldn't match expected type `source -> source'
00:18:04 <lambdabot>            against inferred type `Mu ((,) Int)'
00:18:04 <lambdabot>     In the second argument of `(.)', namely `out'
00:18:27 <quicksilver> I remember an interesting newsgroup posting which showed how a variety of different ways of typoing an obvious function passed the type checker with -rectypes
00:18:42 <ski> *nod*
00:19:07 <ski> (also things like forgetting to include/add/remove an argument, or ordering thereof)
00:28:40 <nolrai_FG> @hoogle sepby1
00:28:40 <lambdabot> Text.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
00:28:41 <lambdabot> Text.ParserCombinators.ReadP sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
00:28:41 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
00:32:36 <quicksilver> ski: damn. Google fails me. In 15 minutes of searching I cannot find that interesting post which contained a list of 'easy' mistakes and showed how they all type-checked.
00:33:11 <ski> (i assume it occured once upon a time in comp.lang.functional, at least ?)
00:33:32 <ski> (or maybe compl.lang.ml ?)
00:33:48 <quicksilver> or the haskell-list, yes :) I can't remember which.
00:34:40 <ski> (.. reminds me of <http://www.rants.org/2008/03/06/thread_theory/>)
00:37:45 <memowe>  ♩ ♫♪ ♬
00:38:33 <o-_-o> can I have something like data Vector = Vec3 [ Float, Float, Float, Float ]
00:38:34 <o-_-o>  ?
00:38:59 <o-_-o> umm....wait
00:38:59 <ski> maybe you want `data Vector = Vec3 Float Float Float Float' ?
00:39:22 <ski> (or possibly `newtype Vector = Vec3 (Float,Float,Float,Float)' ?)
00:39:43 <o-_-o> ski: yes probably
00:39:58 <kmc> [ Float, Float ] is not a type
00:40:10 <o-_-o> no actually I did the second one, but I was wondering if I could make the Vector type generic for Vecn ?
00:40:10 * ski though wonders why there is a `3' there, when there's four `Float' components
00:40:16 <c_wraith> it's only a couple parens away from being a type
00:40:18 <o-_-o> er...:-)
00:40:22 <kmc> o-_-o, not very easily
00:40:23 <o-_-o> yeah...I pasted wrong
00:40:28 <o-_-o> kmc, ok
00:40:34 <kmc> because you have to represent "n" at the type level
00:40:38 <o-_-o> data Vector = Vec4 (Float, Float, Float, Float) | Vec3 (Float, Float, Float) | Vec2 (Float, Float)
00:40:45 <o-_-o> this is how I first thought of it
00:40:56 <o-_-o> kmc ok
00:41:20 <nolrai_FG> well if you want them to be all the same type its easy Vector = Vec [Float]
00:41:29 <ski> you can of course do `newtype Vector = Vec [Float]' .. but then you don't get static checks that you're using correct lengths together
00:41:51 <o-_-o> ski, ah...
00:41:54 <ski> (well, you don't get that either, with the `Vec4',`Vec3',`Vec2' approach just above)
00:42:25 <nolrai_FG> Template haskell will let you do something like this I think..but thats kind of a pain to use.
00:42:42 <o-_-o> nolrai_FG, ok
00:42:42 <nolrai_FG> You could maybe just make a type class?
00:43:03 <o-_-o> nolrai_FG, I am working my way to that
00:43:25 <o-_-o> nolrai_FG, I couldn't figure out how to do it, so I fell back to learning algebraic data types more thoroughly
00:43:58 <nolrai_FG> Ah.
00:45:01 <Gracenotes> oooor dependent types
00:45:43 <nolrai_FG> I don't know those well, how would they be useful?
00:45:56 <nolrai_FG> @hoogle symbol
00:45:56 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
00:45:56 <lambdabot> Text.ParserCombinators.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
00:45:56 <lambdabot> Text.Read Symbol :: String -> Lexeme
00:47:47 <nolrai_FG> @hoogle alphanum
00:47:47 <lambdabot> Text.Parsec.Char alphaNum :: Stream s m Char => ParsecT s u m Char
00:47:47 <lambdabot> Text.ParserCombinators.Parsec.Char alphaNum :: Stream s m Char => ParsecT s u m Char
00:47:47 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
00:50:09 <nolrai_FG> o-_-o: They type class should be fairly simple. add, scaler multiply, dot product, modulus, exampleBasis.
00:52:29 <o-_-o> nolrai_FG, yeah...ummm...yeah...true
00:52:50 <o-_-o> nolrai_FG, although I don't even know the correct syntax at this time
00:56:50 <shapr> How do I format source code in monospace in latex?
00:57:27 <Gracenotes> @botsnack
00:57:27 <lambdabot> :)
00:57:53 <shapr> @quote
00:57:53 <lambdabot> oink says: <^(oo)^>
00:58:21 <dolio> There's a verbatim thing you can import that will display whatever you quote as monospace, I think.
00:58:26 <Gracenotes> shapr: I use, very basic setup:
00:58:31 <dolio> And there's also a package for source code listings.
00:58:34 <Gracenotes> \footnotesize    \begin{verbatim}   \end{verbatim}    \normalsize
00:58:38 <shapr> \texttt{code} seems to work
00:58:50 <Gracenotes> each on their own line, if you have a code block
00:59:06 <shapr> Gracenotes: I'm using single lines at the moment, but in the future I'll try that.
00:59:07 <nolrai_FG> what do the extra 't' mean?
00:59:07 <Gracenotes> oh, for inline quoting, \text* is nice, lots of them exist :)
00:59:13 <Gracenotes> teletype
00:59:31 <Gracenotes> term stays with us, also in HTML
01:03:51 <jlouis> shapr: \usepackage{listings} or \usepackage{verbatim} is worth a look as well
01:06:20 <o-_-o> I just figured out I'll go nuts while writing the cross product
01:13:19 <quicksilver> mauke: what made you change preflex back from NOTICE?
01:13:41 * c_wraith notes that NIST documents don't actually make good bedtime stories.
01:13:57 <c_wraith> I was hoping this would put me to sleep, but I'm actually becoming excited about implementing it. >_>
01:16:20 <jlouis> quicksilver: NOTICE is technically the right thing for bots to do
01:16:30 * c_wraith is in section 10.1 of NIST SP 800-90
01:16:39 <jlouis> it is just that so many clients misinterpret it
01:19:52 <quicksilver> jlouis: I know.
01:20:02 <quicksilver> jlouis: I'm wondering what made mauke stop using it.
01:28:35 <jlouis> quicksilver: my guess is the misinterpreting client users becomes ravingly mad
01:41:40 <ziman> My irssi generates a highlight with each notice (which is the default). I haven't ever complained but I can imagine that this kind of general (mis)configuration causes many users to be incomfortable with notices.
01:45:13 <osaunders> I made something for us: http://spreadsheets.google.com/oimg?key=0Ane6xwFyx4I6dHR6d0xDNVlBeXJxbUZSWXZIRWRuREE&oid=2&v=1265967823238
01:45:51 <horms> nice
01:46:27 <o-_-o> wha ? how do you do cross product of a 2d vector ?
01:46:32 <Saizan> osaunders: now remove the lines about C++
01:47:07 <osaunders> Saizan: Do people talk about C++ a lot here?
01:47:28 <tensorpudding> yes
01:47:36 <Saizan> osaunders: quite a lot recently, sadly
01:47:51 <tensorpudding> apparently most people have a strong negative opinion about c++ here
01:47:54 <Saizan> but let's stop this conversation now :) sorry
01:47:55 <o-_-o> C++ rocks
01:47:58 <o-_-o> oops
01:48:17 <o-_-o> too soon ?
01:48:18 <osaunders> Anyway, I think you can see that channel activity has grown from roughly 40KB to 400KB.
01:49:00 <osaunders> Hm, maybe that initial value is more like 80KB.
01:49:12 <Saizan> o-_-o: there isn't really a cross product for 2D, afaik
01:49:32 <o-_-o> Saizan, that's what I thought, I am getting some floating point number
01:51:01 <quicksilver> osaunders: have you seen the stuff at http://www.haskell.org/haskellwiki/IRC_channel
01:51:35 <quicksilver> ...which links to ... http://www.cse.unsw.edu.au/~dons/irc/
01:51:38 <osaunders> quicksilver: Aww, someone did a much better job before me :-(
01:51:47 <Cale> You can define the "cross product" of a single vector (x,y) in R^2 to be (y,-x)
01:52:06 <Cale> But it's not much of a "product" :)
01:52:22 <tensorpudding> why should it be called a cross product?
01:52:26 <o-_-o> I want to put the haskell noun map on a T shirt
01:52:32 <quicksilver> ...which has files like
01:52:33 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html
01:52:46 <quicksilver> @tell dons your IRC stats thing seems to have stopped running in november 2009
01:52:46 <lambdabot> Consider it noted.
01:52:47 <fasta> Probably, because it gives the same answer as the general vector cross product.
01:53:10 <Cale> In general, it's possible to define a "cross product" of n-1 vectors in R^n
01:54:02 <o-_-o> hmmm...it should be nice to see if a generic program can be written to calculate the cross product of a n dimensional vector in R^n
01:54:07 <o-_-o> in haskell
01:54:56 <osaunders> lol one of the most common words spoken on this channel is function.
01:55:11 <o-_-o> can I get a bigger pic ?
01:55:14 <osaunders> I wish I could have conversations with people where that was one of the most commonly spoken words.
01:55:18 <o-_-o> how was it generated ?
01:55:26 <int-e> and in R^1 that product is a constant, namely the unit vector.
01:55:27 <osaunders> o-_-o: http://www.cse.unsw.edu.au/~dons/irc/
01:55:37 <osaunders> and: http://www.haskell.org/haskellwiki/Image:Irc-raw.png
01:55:44 <osaunders> ^ much better than mine
01:56:54 <o-_-o> osaunders, not the graph
01:57:09 <osaunders> Oh.
01:57:11 <osaunders> Sorry.
01:57:14 <o-_-o> http://www.haskell.org/sitewiki/images/1/17/Haskell-wordle-irc.png
01:57:40 <o-_-o> the graph will look weird on the T-shirt
01:58:21 <dankna> hm
01:58:28 <dankna> it's a general upward trend in activity
01:58:31 <o-_-o> http://www.wordle.net
01:58:32 <dankna> that's a good sign for the future
01:58:58 <dankna> ah - it should really be laid out like the Haskell lambda logo
01:59:16 <o-_-o> dankna, haskell lambda logo ?
01:59:48 <dankna> http://www.haskell.org/sitewiki/images/a/a8/Haskell-logo-60.png
02:00:08 <dankna> I know it's actually some graphical pun the details of which escape me, but it contains a lambda so that's how I think of it
02:00:12 <o-_-o> ah...that is too boring
02:00:44 <dankna> ah well
02:01:56 <Saizan> it's just a lambda mixed with >>=
02:02:09 <o-_-o> one problem with learning haskell for me is I am forgetting C
02:02:17 <dankna> that happens
02:02:31 <dankna> Saizan: yeah, okay
02:02:45 <o-_-o> I need to prepare for interviews and the targets are non-haskell jobs, I am kinda scared
02:02:58 <dankna> good luck with them
02:03:11 <fasta> o-_-o, do not start about Haskell.
02:03:30 <fasta> o-_-o, that's the single best advice I can give you.
02:03:31 <Itkovian> Saizan: Do you happen to know if there's any way to print out the received XML directly in HaXR?
02:03:39 <o-_-o> fasta, heh why  ?
02:03:53 <fasta> o-_-o, people do not like smart-asses.
02:04:02 <o-_-o> but lately I've started thinking in haskell even :-(
02:04:23 <fasta> o-_-o, also mention that design patterns are important to you.
02:04:41 <fasta> o-_-o, do not ever suggest that you could "automate design patterns".
02:04:56 <Saizan> Itkovian: i don't know
02:05:31 <o-_-o> tomorrow I have to prepare to interview someone (me being the one interviewing) and I am not even prepared yet
02:05:35 <fasta> o-_-o, your first job?
02:05:40 <o-_-o> fasta, no
02:05:48 <fasta> o-_-o, ah, missed that.
02:06:12 <o-_-o> fasta, no I am preparing for interviews and also preparing to interview my potential replacements
02:06:39 <o-_-o> heh...*sigh*
02:06:57 <fasta> o-_-o, in which domain?
02:07:15 <o-_-o> High Performance Computing, Visualization etc.,
02:07:43 <o-_-o> I've been doing mostly systems side qualification, testing etc.,
02:08:04 <o-_-o> and I had completely forgotten programming until I picked up haskell
02:08:08 <o-_-o> on a whim
02:13:41 <o-_-o> is moonpatio down ?
02:14:22 <o-_-o> alternative paste sites ?
02:14:32 <o-_-o> hpaste.org is down too
02:15:20 <ski> maybe try <http://paste.lisp.org/new> ?
02:15:35 <o-_-o> http://haskell.pastebin.com/d39db2075
02:15:45 <o-_-o> how do I make that into a class ?
02:15:56 <o-_-o> ski thanks
02:17:09 <o-_-o> http://paste.lisp.org/+2169
02:17:16 <o-_-o> it is the same thing
02:19:29 <o-_-o> fasta, you can automate design patterns in haskell ?
02:20:03 <Saizan> i'd use a size indexed vector, so that you can write them inductively, rather than duplicating everything for every size
02:20:06 <altmattr> what is the number one choice for regexp in haskell these days?
02:21:10 <fasta> o-_-o, in theory yes. In practice I think Haskell needs a better TH implementation before doing those things.
02:21:20 <o-_-o> TH ?
02:21:26 <fasta> o-_-o, Template Haskell.
02:22:17 <Cale> altmattr: parsec ;)
02:23:07 <altmattr> Cale: you being serious?  I know it is a great parsing lib, but can it do quick and dirty find and replace as well?
02:23:11 <Cale> altmattr: But more directly, regex-base together with one of the other packages which provide an engine. It's somewhat unfortunate since the API is awkward though.
02:23:27 <Cale> I'm "haha only serious" about parsec.
02:23:46 <altmattr> never having ever regretted using anything from dons, I was pondering pcre-light
02:24:02 <Cale> I would tend to use either Parsec or ReadP for anything that people normally use regexes for.
02:24:22 <altmattr> can you give me a quick example of find and replace in parsec?
02:24:32 <altmattr> or will I find that in the documentation
02:24:49 <altmattr> I have used parsec before and been very happy so I would be willing to give that a go.
02:25:09 <fasta> altmattr, if you know your problem won't ever change, you can use regular expressions just fine.
02:25:18 <altmattr> and I do love me some EBNF!
02:26:21 <altmattr> my job is converting qif files to ledger, so regex will do for now and parsec would be the final goal.  Thus quick and dirty parsec would be perfect!!
02:33:07 <Kostafey> How I can divide number by Int? e.g. 2 / length [1,2]
02:34:01 <idnar> Kostafey: do you want an integer as the result?
02:34:14 <Kostafey> I want double
02:34:28 <idnar> > 2 / genericLength [1,2]
02:34:29 <lambdabot>   1.0
02:34:47 <idnar> or you could do fromInteger (length [1,2])
02:35:13 <tensorpudding> is that genericLength something defined locally
02:35:24 <idnar> @hoogle genericLength
02:35:25 <lambdabot> Data.List genericLength :: Num i => [b] -> i
02:35:43 <Kostafey> 2 / fromInteger (length [1,2]) -  Couldn't match expected type `Integer' against inferred type `Int'
02:35:47 <int-e> fromIntegral
02:36:14 <idnar> er, sorry, fromIntegral is what I meant
02:36:26 <Kostafey> Thanks, both solutions looks good!
02:36:32 <tensorpudding> > (genericLength [1..10])  :+ 3.0
02:36:34 <lambdabot>   10.0 :+ 3.0
02:36:37 <idnar> @src genericLength
02:36:38 <lambdabot> genericLength []    = 0
02:36:38 <lambdabot> genericLength (_:l) = 1 + genericLength l
02:37:11 <tensorpudding> fromIntegral is longer but that doesn't require a special import
02:37:42 <idnar> the fromIntegral version isn't quite the same, though
02:37:42 <dobblego> > sequence [[1,2,3], [4,5,6]]
02:37:43 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
02:37:49 <idnar> but that probably doesn't ever matter
02:38:20 <idnar> unless it's possible to have a list that's longer than maxBound :: Int
02:38:24 <quicksilver> there are two cases it might matter but they aren't common ones
02:38:52 <quicksilver> one is lists longer than maxBound int which is perfectly possible with a 32-bit int
02:39:05 <quicksilver> the other is comparisons with a lazy natural
02:39:18 <idnar> do you ever have 32-bit Int in a 64-bit address space?
02:39:32 <Kostafey> Ok, I'll use fromIntegral
02:39:32 <Kostafey>  
02:39:36 <quicksilver> not with GHC, no.
02:39:44 <idnar> anyhow, I forgot the lazy case
02:39:47 <quicksilver> GHC always has Int size = native pointer size
02:40:05 <quicksilver> but I'm still running on a machine with a 32 bit userland and I know I"m not alone in that.
02:40:30 <quicksilver> (and as far as I know people still haven't quite got 64-bit GHC working on OSX)
02:40:30 <idnar> 32-bit userland means 32-bit address space, though
02:40:40 <quicksilver> yes, but that doesn't mean you can't have longer lists than that
02:40:49 <quicksilver> I can quite easily stream a 16GB file through a [Byte]
02:41:08 <idnar> mmm
02:41:39 <idnar> okay, fair enough
02:41:41 <int-e> length $ replicateM_ 32 [0,1] -- takes a while, returns 0.
02:42:28 <quicksilver> shouldn't take *too* long compiled
02:43:08 <idnar> @type replicateM_
02:43:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
02:43:13 <idnar> @src replicateM_
02:43:13 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
02:43:20 <int-e> Or not. sequence is a foldr. all the tails get shared ... so this will run out of memory.
02:44:17 <quicksilver> yes, it does
02:44:26 <quicksilver> good way of garbage collecting my virtual memory :)
02:44:29 <idnar> haha
02:44:48 <idnar> I really need to set memory rlimits on my system
02:44:52 <int-e> length $ foldl (>>) (return 0) (replicate 32 [0,1])  then
02:45:13 <idnar> when I run code that accidentally uses infinite memory, the OOM killer usually takes out half my system before it hits the right process
02:46:25 <o-_-o> wow...this template haskell idea is amazing
02:46:33 <o-_-o> is it implemented in GHCI ?
02:47:04 <zygoloid> idnar: yeah, i keep meaning to set an rlimit for ghci for exactly that reason :/
02:47:24 <int-e> idnar: one of the advantages of having a swap partition is that the system slows down significantly before it starts killing processes, giving you time to kill the offender. ;)
02:48:00 <zygoloid> i find my machine basically locks up pretty hard while it's swapping :(
02:48:23 <QtPlatypus> zygoloid: Pritty damn common
02:49:23 <dobblego> ddarius, does C# have a REPL?
02:49:37 <galdor> int-e: when a really big scary software swaps too much, you won't kill anything, it'll lock the machine
02:49:49 <galdor> only way not to reboot is not to have any swap
02:49:54 <idnar> int-e: I do have a swap partition
02:50:00 <int-e> galdor: I know. Hence the smiley.
02:50:12 <idnar> int-e: the problem is that other processes start getting swapped out before the runaway one does
02:50:25 <galdor> int-e: oh my bad
02:51:01 <idnar> and the OOM killer runs in kernelspace, whereas POSIX signals get delivered in userspace
02:51:19 <idnar> so one the system starts thrashing to death, it might take 20 minutes for that SIGKILL to get through :P
02:52:09 <quicksilver> int-e: print (length $ concat . replicate two16 . replicate two16 $ () ) ran for 4 minutes (user time 3:30) before printing 0
02:52:17 <int-e> > map Seq.length $ drop 61 $ take 65 $ iterate (join (Seq.><)) (Seq.singleton 1)
02:52:17 <lambdabot>   [2305843009213693952,4611686018427387904,-9223372036854775808,0]
02:52:35 <quicksilver> int-e: but it did at least run in constant space :)
02:52:47 <quicksilver> so, about 1 billion items per minute
02:53:02 <quicksilver> around 60 cycles per item on average, including GC cycles
02:53:05 <marcot> Hi, until ghc-6.10.4 doesFileExist "/dev/sda1" returned True.  With ghc 6.12 it returns False.  Is this expected?
02:55:22 <IceDane> Anyone have any links on using the parser combinators? ReadP in particular. I can't seem to find any resources that are about it in particular.
03:00:08 <Alpounet> weeeeeee, TAPL just arrived
03:00:19 <EvilTerran> TAPL++
03:00:43 <Alpounet> :)
03:01:24 <EvilTerran> ben pierce is possibly the most lucid technical writers i've read
03:01:30 <EvilTerran> -s
03:02:35 <Alpounet> it seems I'll agree
03:05:31 <fasta> Why do I always have to disagree? ;)
03:09:22 <PepeSilvia> hi guys, anyone know how I can resolve this gracefully:
03:09:24 <PepeSilvia> Prelude> import Control.Monad.Cont
03:09:24 <PepeSilvia> Could not find module `Control.Monad.Cont': it was found in multiple packages: monads-tf-0.0.0.1 mtl-1.1.0.2
03:10:05 <fasta> PepeSilvia, import "mtl" Control.Monad.Cont
03:10:15 <fasta> PepeSilvia, I don't know whether that works in ghci.
03:10:35 <fasta> PepeSilvia, it is also not H98.
03:10:53 <PepeSilvia> hm, that doesn't seem to work in ghci
03:11:16 <EvilTerran> i think it needs an -XOption to use it in ghc, it may need the same for ghci
03:11:37 <fasta> PepeSilvia, PackageImports
03:12:16 <PepeSilvia> fasta: that still gives me a parse error in ghci
03:12:24 <quicksilver> "import" shouldn't work in ghci
03:12:33 <fasta> quicksilver, that's false.
03:12:34 <quicksilver> just furthers confusion IMO.
03:12:42 <fasta> quicksilver, ah, never mind.
03:12:57 <quicksilver> having said that, I don't know how to choose which package to use in ghci
03:13:00 <fasta> quicksilver, you were expressing an opinion, not how it actually works now.
03:13:00 <EvilTerran> there doesn't seem to be a way you can do it with ":m +" either
03:13:38 <EvilTerran> i guess you could stick ``{-#LANGUAGE PackageImports #-}; import "mtl" Control.Monad.Cont'' in a file somewhere and load that
03:14:37 <PepeSilvia> EvilTerran: thanks, this works at least as a workaround
03:14:44 * EvilTerran likes to work his ghci sessions with a "scratch-pad" file loaded, anyway. for imports and definitions i don't want to disappear when i :r or whatever.
03:15:05 <EvilTerran> and to get around not being able to define types and classes in ghci
03:16:16 <PepeSilvia> EvilTerran: that sounds quite handy indeed
03:16:23 <PepeSilvia> fasta: why shouldn't imports work in ghci?
03:16:41 <EvilTerran> PepeSilvia, because ghci is like a do-block, not a module
03:16:55 <PepeSilvia> but for all intents and purposes it works(?)
03:17:10 <EvilTerran> (hence also why you can't define classes and types)
03:17:26 <fasta> PepeSilvia, quicksilver probably believes that it makes people think that ghci understands Haskell.
03:17:33 <EvilTerran> i think "import ..." is de-sugared into ":m + ..." when you use it in ghci
03:17:41 <PepeSilvia> oh sorry, pinged the wrong guy :p
03:17:47 <fasta> PepeSilvia, there is a slight difference between Haskell and the Haskell you can use in ghci.
03:17:57 <PepeSilvia> ah ok, got it
03:18:08 <fasta> PepeSilvia, and all the newbies always go crazy about it.
03:21:27 <quicksilver> PepeSilvia: ghci is an evaluator, or repl
03:21:33 <quicksilver> PepeSilvia: it interprets haskell expressions
03:21:46 <quicksilver> PepeSilvia: it doesn't handle haskell statements - for example, you can't define new data types in it
03:22:02 <quicksilver> 'statement' is a poor choice of word there.
03:22:12 <quicksilver> declaration/definition is what I mean.
03:22:40 <quicksilver> it doesn't understand, for example, 'data', 'newtype', 'class', 'instance' or 'module'
03:23:01 <quicksilver> It *used* not to understand 'import' because again that's a piece of top-level file syntax
03:23:11 <quicksilver> but they added it in the recent version because it's absence caused confusion.
03:23:27 <quicksilver> I just happen to think its presence causes confusion because it blurs this important boundary about what ghci actually is.
03:23:28 <BONUS> but yeah im against it as well, cause you still can't do qualified imports
03:23:34 <BONUS> but you can do normal ones
03:24:03 <quicksilver> [Incidentally, I'd love it if GHCi *did* allow data/newtype/class/instance/module, that would be very useful. But it doesn't. And while it doesn't, it's easier to have a simple story about what it's capable of]
03:24:56 <BONUS> agreed
03:25:28 <PepeSilvia> ok, I shall force myself to get used to :m ; it's shorter anyway
03:26:10 <PepeSilvia> thanks everyone
03:27:00 <quicksilver> Come to that I'd quite like it if haskell permitted local data / class / module at the expression level.
03:27:07 <quicksilver> and then the picture would be a bit more unified anyway
03:27:13 <Kostafey> Is there simpler way to multiply list to number, e.g. [2*x | x <-[1,2]] ?
03:27:13 <Kostafey>  
03:27:29 <quicksilver> > map (5*) [1,2,8]
03:27:30 <lambdabot>   [5,10,40]
03:27:34 <quicksilver> is how I'd write it.
03:27:40 <quicksilver> it's the same thing as your list comprehension though.
03:27:47 <Kostafey> Great!
03:28:58 <tensorpudding> that's what map is for, applying functions to each element of a list
03:29:32 <Alpounet> > (5*) <$> [1,2,8] -- works too
03:29:33 <lambdabot>   [5,10,40]
03:29:35 <Alpounet> matter of taste
03:30:18 <tensorpudding> <$> is just an infix fmap
03:30:31 <ziman> > (5*) . [1,2,3]
03:30:32 <lambdabot>   [5,10,15]
03:30:37 <quicksilver> that doesn't work, though :)
03:30:46 <quicksilver> that's a local lambdabot definition.
03:30:47 <tensorpudding> using (.) *should* not work
03:30:50 <ziman> hm, caleskell is back.
03:30:55 <medfly> :)
03:30:58 <tensorpudding> but here it does
03:31:03 <idnar> (.) = fmap -- now it does :P
03:31:26 <idnar> but I suppose that's a bad idea
03:31:42 <medfly> not as bad as you might think
03:32:04 <medfly> > succ . succ . succ $ 3
03:32:05 <lambdabot>   6
03:41:30 <Kostafey> How to get [[1,2],[3,4]] -> [2,3] -> [[2,4],[9,12]]? I'm try [x | x <- [[3,4],[5,6]], y <-[1,2]], but it work wrong.
03:42:29 <quicksilver> I don't remotely understand your question.
03:42:35 <Kostafey> [map (y*) x | x <- [[1,2],[3,4]], y <-[2,3]]
03:42:53 <quicksilver> oh now I do
03:43:03 <quicksilver> I explained this to you a couple of days ago but you didn't respond.
03:43:18 <Kostafey> hm
03:43:19 <quicksilver> list comprehension does *every* *possible* combination
03:43:23 <Beelsebob> \x y -> ZipList x <^(*)^> ZipList y
03:43:35 <quicksilver> it's not the answer when you want just 'corresponding' combinations
03:43:59 <quicksilver> > zipWith (\l x -> map (x*) l) [[1,2],[3,4]] [2,3]
03:44:00 <lambdabot>   [[2,4],[9,12]]
03:44:01 <Cale> > zipWith (\xs y -> map (y*) xs) [[1,2],[3,4]] [2,3]
03:44:01 <lambdabot>   [[2,4],[9,12]]
03:44:05 * quicksilver wins.
03:44:36 <Beelsebob> oh right, map (*)
03:44:50 <Beelsebob> \x y -> ZipList x <^(map (*))^> ZipList y
03:45:41 <Kostafey> quicksilver: comprehension = understanding
03:47:14 <quicksilver> Kostafey: if you're referring to my use of the phrase "list comprehension"
03:47:17 <quicksilver> Kostafey: then, no.
03:47:31 <quicksilver> Kostafey: "list comprehension" is what this notation that you are using [ x | blah ] is called.
03:47:50 <quicksilver> it's a clever, convenient shortcut but it's hard to generalise if you don't understand what it translates to.
03:47:56 <Kostafey> quicksilver: can you get the synonym of this wolrd?
03:48:05 <quicksilver> pretend it has no synonym
03:48:09 <quicksilver> what it really means doesn't matter
03:48:24 <quicksilver> "list comprehension" means "this haskell construct that looks like [ x | blah ]"
03:48:41 <quicksilver> it's connection to the ordinary english word 'comprehension' is slightly obscure and not the point.
03:49:15 <zygoloid> [ x | blah ] is the comprehensive list of all x where blah :)
03:49:27 <Kostafey> quicksilver: ok, thanks
03:50:11 <IceDane> http://codepad.org/Xh0Bq8j4 <- I really don't get what's going on. I'm looking at the State monad in RWH. I don't even get what these function are doing or how they work. Someone, hint? Plox. x.x
03:52:17 <zygoloid> IceDane: ok, so a state computation 'State s a' is just a wrapper around a function s -> (a, s).
03:52:54 <fasta> IceDane, these functions only build a function. Nothing actually happens.
03:53:03 <zygoloid> like, for instance, head . reads
03:53:15 <zygoloid> > (head . reads) "123foo" :: (Int, String)
03:53:16 <lambdabot>   (123,"foo")
03:53:28 <Ke> is there some clean packaging for haskell base in ubuntu
03:53:38 <Ke> like one metapackage
03:53:51 <zygoloid> > runState (State (head . reads)) "123foo" :: (Int, String)
03:53:52 <lambdabot>   (123,"foo")
03:53:54 <IceDane> zygoloid: So the "State s a" is a function, no a 'type' ?
03:54:11 <fasta> IceDane, State s a is a type.
03:54:53 <zygoloid> IceDane: function types are types too. data State s a = State (s -> (a, s)). a value of type State s a is a function s -> (a, s) in a box labelled State
03:54:54 <fasta> IceDane, State, as on line 6 constructs a value.
03:55:21 <fasta> IceDane, the only field of that value being a function.
03:55:47 <IceDane> Ah.. So where some types store a value, State s a stores a function, then?
03:56:01 <fasta> IceDane, functions are a kind of value, but yes.
03:56:27 <IceDane> Alright, that makes a bit of sense then.
03:57:00 <IceDane> So what is it get and put are doing exactly? Why is get returning a tuple of s?
03:57:16 <zygoloid> IceDane: the function stored inside the State box takes the old state, and produces a result and a new state
03:57:51 <zygoloid> IceDane: in the 'get' case, it's a fucntion which takes the old state and produces a result (which is the old state) and a new state (which is also the old state)
03:58:44 <zygoloid> in the 'put s' case, it's a function which ignores the old state, and produces () as a result and 's' as the new state
03:59:07 <Ke> there isn't even any haskell-ubuntu or ubuntu-haskell
03:59:14 <ski> @type StateT reads
03:59:15 <lambdabot> forall a. (Read a) => StateT String [] a
03:59:15 <Ke> quite sad
03:59:56 <IceDane> zygoloid: What would those functions look like if they weren't using the 'lambdan notation' of \s ->.. etc?
04:00:01 <IceDane> lambda*
04:00:16 <zygoloid> ski: a parser combinator library in two tokens. nice :)
04:00:42 <ski>   runState get s = (s,s)
04:00:52 <ski>   runState (put s) _ = ((),s)
04:00:54 <zygoloid> IceDane: get = State $ let getState s = (s, s) in getState
04:00:56 <ski> IceDane : ^
04:01:08 <ski> (if that was valid haskell ..)
04:01:10 <zygoloid> put s = State $ let putState _ = ((), s) in putState
04:01:36 <IceDane> Hmm.. I'm going to have to digest this, heh.
04:01:38 <IceDane> Thanks
04:01:46 <IceDane> I'll read the section over a few times
04:04:38 <ski> > [map (y *) xs | xs <- [[1,2],[3,4]] | y <- [2,3]]
04:04:39 <lambdabot>   [[2,4],[9,12]]
04:04:41 <ski> Kostafey : ^
04:05:23 <Kostafey> You are writing faster then I can read :)
04:06:04 <ski> that notation with multiple `|'s in a list comprehension is called "parallel list comprehension", and is an extension
04:06:40 <ski> > [[x * y | x <- xs] | xs <- [[1,2],[3,4]] | y <- [2,3]]  -- alternative
04:06:41 <lambdabot>   [[2,4],[9,12]]
04:07:47 <Kostafey> ski, once again, thanks. It seems, I've understand the mean of this term
04:09:26 <ski> anyway, if you want to do every combination, then use `,' to separate the `y <- [2,3]' "generators" .. if you want to run them in lock-step / parallel, then you possibly want the extension where you separate with `|'
04:09:47 <mreh> @pl map (f a) xs
04:09:47 <lambdabot> map (f a) xs
04:09:53 <mreh> um
04:10:02 <mreh> fair enough
04:10:12 <ski> > [[c,d] | c <- "abc" , d <- "012"]
04:10:13 <lambdabot>   ["a0","a1","a2","b0","b1","b2","c0","c1","c2"]
04:10:17 <ski> > [[c,d] | c <- "abc" | d <- "012"]
04:10:18 <lambdabot>   ["a0","b1","c2"]
04:10:21 <ski> > [[c,d] | c <- "abc" | d <- "01"]
04:10:22 <lambdabot>   ["a0","b1"]
04:11:00 <ski> (mreh : .. heh, what did you expect ?)
04:11:16 <mreh> a points free way of writing that
04:11:33 <mreh> pointsfree is still nice if you want to write something without bound variables
04:11:34 <ski> there are no local variables in it to abstract away
04:11:38 <mreh> unbound variables*
04:11:49 <mreh> with bound variabls*
04:11:50 <thatwasfun> is there any plan to do a full c-- implementation?
04:12:00 <idnar> @pl \f a xs -> map (f a) xs
04:12:01 <lambdabot> (map .)
04:12:29 <mreh> I like (.) as a section
04:13:12 <mreh> does anyone have any ideas how to do evolutionary programming in a haskelly way?
04:13:27 <jaspervdj> mreh: I think there's a package on haskell
04:13:46 <mreh> oh really?
04:13:58 * mreh looks
04:15:01 <jaspervdj> mreh: I was referring to hgalib/hevolisa
04:15:32 <mreh> oh, I've written a GA already
04:15:51 <mreh> representing the genotype and computing the phenotype is what I need to know
04:17:29 <Kostafey> I'm really moron. Can you explain me how to read (\l x -> map (x*) l) ?
04:17:56 <Kostafey> It is a function (Num a) => [a] -> a -> [a]
04:17:57 <mreh> in English that says: "multiply every element of l by x"
04:18:16 <ski> the function that converts arguments `l' and `x' to the list `l' where each argument is multiplied by `x' (on the left)
04:18:22 <mreh> you have to understand the definition of map and what (x*) means
04:18:29 <mreh> @src map
04:18:29 <lambdabot> map _ []     = []
04:18:29 <lambdabot> map f (x:xs) = f x : map f xs
04:18:44 <ski> is we call that function `scalarR', then writing
04:18:50 <ski>   scalarR = \l x -> map (x*) l
04:18:55 <ski> is the same as writing
04:19:01 <ski>   scalarR l x = map (x*) l
04:19:18 <mreh> he wants to know how to read it
04:21:44 <Kostafey> ok, thans for answers. The core of question is in the sequence of function parameters.
04:21:56 <Kostafey> here is \l then x
04:22:07 <ksf> I need some inspiration
04:22:13 <ksf> ...or maybe just approval
04:22:22 <Kostafey> but we call it: zipWith (\l x -> map (x*) l) [[1,2],[3,4]] [2,3]
04:23:03 <ksf> I've got my iteratee-based parser ready, and now I'm worried about not messing with the incrementalness of iteratees by aggregating too big results.
04:23:43 <aleator> Hi! Is there any pragma that I can include in the source file for including additional object files?
04:23:48 <Kostafey> oh, forget, I'he understand it.
04:24:27 <ksf> that is, I could either agrregate something like HttpRequest = HttpRequest Method [Header] Body, or I could do something like [HttpRequestPart], where the parts are method, then any number  of headers, then a body, then a header again...
04:24:39 <ksf> problem being: the first is non-incremental, the second isn't typesafe
04:25:56 <ksf> So I've been thinking into the direction of using Hlist as chunk type (which afair doesnt' support recursion, which is bad, or some adaption of session types
04:26:00 <ksf> any ideas?
04:26:55 <ksf> ski, up to sharing, or did that change?
04:30:27 <Kostafey> Is a better way to sum vector's elements: [sum x | x <- transpose [[1,2,3],[4,5,6]]]
04:30:36 <Kostafey> [5,7,9]
04:31:26 <Kostafey> like sum [[1,2,3],[4,5,6]]?
04:31:56 <mreh> FRP is amazing
04:32:39 <mreh> > sum [[1,2,3],[4,5,6]]
04:32:40 <lambdabot>   No instance for (GHC.Num.Num [t])
04:32:40 <lambdabot>    arising from a use of `Data.List.sum' ...
04:32:54 <m0nkfish> > zipWith sum [1,2,3] [4,5,6]
04:32:55 <lambdabot>   No instance for (GHC.Num.Num [b -> c])
04:32:55 <lambdabot>    arising from the literal `1' at <...
04:33:01 <m0nkfish> :<
04:33:10 <mreh> > map sun [[1,2,3],[4,5,6
04:33:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:33:12 <mreh> > map sun [[1,2,3],[4,5,6]]
04:33:13 <lambdabot>   Not in scope: `sun'
04:33:18 <mreh> > map sum [[1,2,3],[4,5,6]]
04:33:19 <lambdabot>   [6,15]
04:33:37 <mreh> > sum . concat $ [[1,2,3],[4,5,6]]
04:33:38 <lambdabot>   21
04:33:38 <opqdonut> > foldl1 (zipWith (+)) [[1,2,3],[4,5,6],[7,8,9]]
04:33:39 <lambdabot>   [12,15,18]
04:33:42 <m0nkfish> zipWith (+) [1,2,3] [4,5,6]
04:33:45 <m0nkfish> > zipWith (+) [1,2,3] [4,5,6]
04:33:46 <lambdabot>   [5,7,9]
04:33:48 <opqdonut> that's probably what he wanted
04:33:54 <m0nkfish> yeah thats the one
04:35:17 <Kostafey> zipWith (+) [1,2,3] [4,5,6] really!
04:35:25 <mreh> :t foldl1 (zipWith (+))
04:35:26 <lambdabot> forall a. (Num a) => [[a]] -> [a]
04:36:06 <Vitka> Speaking of math.
04:36:31 <mreh> what is that doing? summing rows of a list of column vectors (matrix)?
04:37:05 <mreh> :t zipWith (+)
04:37:06 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
04:37:10 <mreh> that's pretty
04:38:42 <Vitka> If I have downward recurrence relation like f(n)=g(n+1), how do I go around writing a proper function of it? I've gotten around defining boundary for upward recursion, but this one confuses me.
04:38:56 <Kostafey> mreh, right.
04:39:24 <Vitka> In the end, having f(m) I want to unfold to [f(m),f(m-1)..0]
04:39:59 <tARrAScH> Vitka - you mean f(n)=f(n+1) =
04:40:01 <tARrAScH> ?
04:40:43 <tARrAScH> @paste
04:40:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:43:04 <tARrAScH> I've got some problems, I've simplified and explained my problem here: http://haskell.pastebin.com/m523170c7
04:43:44 <Vitka> Not exactly, I have f(n) and downward recurrence relation for f(n-1) down to 0.
04:44:08 <Vitka> down to f(0) I mean.
04:45:11 <tARrAScH> Vitka: You mean how you write a function that has 0 as end-case? Are you new to haskell ?
04:45:21 <Jafet> return.Just makes sense to me, tarrasch
04:45:48 <tARrAScH> Jafet: Yea it makes "sense" but it wont return any random value
04:46:46 <Vitka> I am new, yes. :) I want to make a function from f (n) to f(0), starting with f(n).
04:46:52 <tARrAScH> Jafet: Is my issue understandable? I found it hard to express
04:46:58 <RayNbow> :t (return . Just) 3
04:46:59 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m (Maybe a)
04:47:05 <tARrAScH> Vitka, ah ok, one second
04:47:07 <Jafet> @hoogle (<-)
04:47:07 <lambdabot> Text.Html (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
04:47:07 <lambdabot> Text.XHtml.Table (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
04:47:24 <quicksilver> Vitka: f 0 = base case; f n = ... some expression mentioning f n - 1 ...
04:47:33 <quicksilver> Vitka: make sense?
04:47:43 <tARrAScH> Vitka:  check this: http://haskell.pastebin.com/m7f1cb0dc
04:47:44 <Jafet> Are <- and res_inner from quickcheck, tarrasch
04:47:49 <Vitka> I can start with f(0) in theory, but it\s going to have numerical problems.
04:48:18 <Vitka> quicksilver: Nope, f(n) as base case is whole point.
04:48:31 <Vitka> Or, rather, f n = ... n+1
04:49:19 <quicksilver> Vitka: then f 17 = base case; f n = ... expression mentioning f (n+1) ...
04:49:27 <RayNbow> tARrAScH: how do you want "genMaybe i" to behave?
04:49:37 <RayNbow> what does the i represent?
04:50:05 <Vitka> Hmm.
04:50:15 <ksf> Ha! I should just ask you to explain monads, then you'd be running over each other to answer me.
04:50:49 <Jafet> @quote "back in time"
04:50:49 <lambdabot> No quotes for this person. Where did you learn to type?
04:50:53 <Jafet> @quote back in time
04:50:53 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
04:51:19 <tARrAScH> RayNbow: My problem is that I can't see how I could pass along the lambda expression parameter to the genMaybeConst function and get a random genMaybeConst-value
04:51:44 <ksf> Vitka, or maybe f n | n == end = <base case>
04:52:32 <tARrAScH> RayNbow: Ok I realize now I should just had genMaybe :: Gen Maybe Int and had some hard-codede value instead of i
04:52:35 <Vitka> Hmm, let me think.
04:52:40 <Jafet> @quote invisible
04:52:40 <lambdabot> kmc says: a monad is like an invisible train filled with jello traveling backwards in time
04:53:10 <ksf> oh, I need to add copumpkin to "what monads are not"
04:53:15 <tARrAScH> ok, slightly simplified -- http://haskell.pastebin.com/m76071a08
04:54:20 <RayNbow> "res_inner <- genMaybeConst x)" <-- tARrAScH, if you're trying to extract the Maybe Int from Gen (Maybe Int)... you can't
04:54:28 <tARrAScH> the syntax: "(res_inner <- genMaybeConst x)" Is obviously erroneous, but is it clear whatI want?
04:54:54 <RayNbow> (at least, not with the functions in the monad type class)
04:55:38 <Saizan> ksf: i'd go with some simple session types, probably implementing the communication via callbacks rather than channels though
04:55:38 <tARrAScH> RayNbow: hmm, shouldn't there be any way? Is it conceptually a wrong idea too? Even if genMaybeConst was returning different random values.
04:56:01 <Saizan> ksf: keeping it more similar to iteratee
04:57:08 <Saizan> ksf: i've wanted to experiment with session types on top of this http://hackage.haskell.org/packages/archive/scc/0.4/doc/html/Control-Concurrent-Coroutine.html , but i don't have any application
04:57:25 * Saizan doesn't write server code
04:58:28 <ksf> oh i never saw scc
04:58:39 <ksf> according to oleg, iteratees are just coroutines.
04:58:52 <tARrAScH> RayNbow: I mean usually you actually can, you just write "do myint <- arbitrary :: Gen Int"
04:59:23 <Saizan> yeah
04:59:30 <Saizan> but they are coroutines inside-out
04:59:50 <Saizan> i.e. you don't manipulate streams, but stream transformers
04:59:53 <RayNbow> tARrAScH: the last line of a do-block should always be of type "m a", in this case Gen Int
05:00:15 <Saizan> i find that pretty unnatural and unflexible
05:00:21 <ksf> I usually don't write server code either, but I once wrote a one-off http server to get aquainted with haskell, and noticed a couple of very interesting problems there
05:00:30 <ksf> ...not really hard ones, but important and interesting
05:00:43 <tARrAScH> RayNbow: Yea yea. But my point is that you can take out the Gen from Gen x inside a Gen-function, no?
05:01:24 <RayNbow> tARrAScH: that's only how it appears on the surface
05:01:34 <ksf> ...mostly in the area of avoiding dos attacks.
05:01:42 <RayNbow> you're allowed "to take stuff out of Gen", only if you promise to package it up again in the end
05:02:19 <tARrAScH> RayNbow: But I do that, I have a return in my code I posted
05:04:01 <Saizan> ksf: how do you consume two streams at the same time with iteratees btw?
05:04:02 <RayNbow> tARrAScH: you're wrapping everything right of the $ up in a Gen
05:04:45 <RayNbow> do you realize you might not need return if the expression right of $ had already the type Gen (Maybe Int)?
05:05:11 <Vitka> Ok, got it. I needed to parametrize base case for different n and stumbled. I'll just write two functions one for computing f(n), other for unfolding [f(n),f(n-1)..f[0].
05:05:21 <tARrAScH> RayNbow: Yes. I'm aware of that.
05:05:44 <RayNbow> tARrAScH: still, I don't quite see what genMaybe should represent... can you describe it with words instead of code?
05:05:49 <tARrAScH> RayNbow: But for the moment what's right of $ just have type comiler error :p
05:06:00 <RayNbow> should it represent random values of type Maybe Int?
05:06:01 <tARrAScH> RayNbow: Certainly:
05:06:17 <RayNbow> can it be Nothing?
05:06:58 <tARrAScH> RayNbow: No, it shouldn't be nothing in this case. My real code looks like something else and deosn't deal with Maybe, I just simplified and took what's important from my real-world example
05:07:16 <tARrAScH> *Nothing
05:08:20 <Saizan> tARrAScH: do i <- arbitrary :: Gen Int; return (Just i) ?
05:08:48 <tARrAScH> Well What I'm trying to do is to use >>= in a way so that the right-side of bind is a random value that can be different random values depending on the left-Side-value of >>=
05:09:09 <Saizan> ok
05:09:21 <Saizan> but then you don't use return $ like in your paste
05:09:39 <Saizan> you apply return to pure values to wrap them in your monad
05:09:54 <Saizan> you don't use return on actions that are already monadic
05:10:03 <RayNbow> :t fmap Just arbitrary
05:10:04 <lambdabot> forall a. (Arbitrary a) => Gen (Maybe a)
05:10:08 <Saizan> also the <- syntax can be used only as part of a do-block
05:10:11 <RayNbow> :t fmap Just arbitrary :: Gen (Maybe Int)
05:10:12 <lambdabot> Gen (Maybe Int)
05:10:26 <RayNbow> :t do i <- arbitrary :: Gen Int; return (Just i)
05:10:27 <lambdabot> Gen (Maybe Int)
05:11:02 <tARrAScH> Saizan: hmm, so must it be a do-block to un-Gen the value of a Generator?
05:11:05 <Saizan> tARrAScH: aah, maybe you don't know that "return $ Just 123 >>= (\x -> (res_inner <- genMaybeConst x))" is parsed as "return $ (Just 123 >>= (\x -> (res_inner <- genMaybeConst x)))"
05:11:35 <Saizan> tARrAScH: so you're not applying return on "Just 123" there, but to the whole rest
05:11:41 <Saizan> tARrAScH: or you can use >>=
05:12:03 <Saizan> tARrAScH: do x <- m; f x == m >>= \x -> f x
05:12:05 <tARrAScH> Saizan: but Maybe a >>= (a -> Maybe b) certainly needs a return to become a  Gen, no?
05:12:59 <Saizan> tARrAScH: but you're using genMaybeConst which is in Gen from inside it
05:13:01 <tARrAScH> Saizan: Yea I knew about how something is parsed after $ ...
05:13:40 <ksf> Saizan, I don't.
05:13:53 <ksf> ...at least not with the same iteratee, that is.
05:13:54 <mlesniak> Are there any ghc pragmas that prevent the optimization on one particular function, despite -O2 on the command line? I have not found anything in the docs, but sometimes that does not mean much...
05:13:54 <Saizan> tARrAScH: so you get Gen (Maybe (Gen (Maybe Int)))
05:14:17 <Saizan> tARrAScH: taking the return into account too
05:14:29 <Saizan> tARrAScH: so the return doesn't help, really
05:14:33 <tARrAScH> Saizan: Indeed, but how can i apply "Just 123 >>= (\x -> ?" where ? is a generated Maybe value from  genMaybeConst where genMaybeConst takes one argument from x.
05:14:39 <ksf> I'm epolling the file discriptors, and have an iteratee for each that produces the stuff to do.
05:14:40 <Alpounet> mlesniak, there is NoInline, IIRC
05:14:48 <Alpounet> that will keep this function from being inlined
05:15:02 <Alpounet> not sure it fits your needs though
05:15:08 <tARrAScH> takes the 'x' as argument *
05:15:39 <Saizan> tARrAScH: you need to transform your Maybe (Gen (Maybe Int)) into (Gen (Maybe Int)), which you can do e.g. with fromMaybe (return Nothing)
05:15:41 <mlesniak> Alpounet, actually I tried this, not exactly what I want
05:15:45 <ksf> there are, however, ways to interleave stuff, but i didn't care about it for now.
05:15:48 <Saizan> ?type fromMaybe (return Nothing)
05:15:49 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe (m (Maybe a)) -> m (Maybe a)
05:16:27 <Alpounet> mlesniak, then you should check the optimization part of the GHC manual
05:16:32 <Alpounet> if not already done
05:16:40 <Alpounet> 'cause I can't think of any other tip
05:16:53 <Saizan> tARrAScH: fromMaybe (return Nothing) $ Just 123 >>= (\x -> genMaybeConst x)
05:17:07 <ksf> ...and I don't think I'm going to be able to do the output io directly with the iteratee that's driven by input IO, as I want to use sendfile
05:17:23 <ksf> so stuff needs to be more opaque than that
05:17:25 <mlesniak> Alpounet, ah, did not look in that part, only into the pragmas section. good idea
05:17:31 <tARrAScH> What I basically wanted to do was. " genMaybe = Just 123 >>= (\x -> unGen (genMaybeConst x)))"
05:17:31 <Saizan> tARrAScH: which is a roundabout way to write genMaybeConst 123, of course
05:17:57 <Saizan> ?hoogle unGen
05:17:57 <lambdabot> Data.Generics.Aliases unGeneric' :: Generic' c -> Generic c
05:18:11 <Saizan> tARrAScH: is there such an unGen function? i don't think so
05:18:33 <Saizan> tARrAScH: it'd need a StdGen as input at least
05:18:35 <benmachine> Just 123 = return 123, return x >>= f = f x
05:18:35 <tARrAScH> Saizan: No there isn't :). But I wish it were, or at least some way to write what I want without using unGen
05:18:54 <Saizan> tARrAScH: you can't in general escape from monads like that
05:19:20 <tARrAScH> Saizan: well note that I would have no problem if there was no arguement to genMaybeConst
05:19:44 <Saizan> tARrAScH: you can only look at the results by using >>= and so building a bigger action in the same monad
05:19:59 <voker57_> how to build "base" package? http://dpaste.com/157863/
05:19:59 <Saizan> tARrAScH: i'm still unsure about what your real problem is
05:20:00 <MissPiggy> how do you make cabal shut up about It requires ghc -any?
05:20:10 <tARrAScH> then I would just've written "do res <- genMaybeConst; return $  Just 123 >> res". No?
05:20:52 <Saizan> tARrAScH: that would typecheck
05:21:06 <Saizan> tARrAScH: how does your real code look like?
05:21:22 <Saizan> here Just 123 makes little sense :)
05:21:41 <Saizan> i.e. why do you not just apply genMaybeConst to 123?
05:21:52 <Saizan> also, Just 123 >> res is just res
05:22:53 <tARrAScH> Saizan - my real problem is that I don't know what result the monad has so I want to use >>=
05:23:04 <tARrAScH> Saizan - http://haskell.pastebin.com/d11509d - line 67
05:24:24 <mreh> does ! before a type make a field strict?
05:24:35 <benmachine> mreh: yeah I think so
05:24:44 <Saizan> tARrAScH: it looks like you need one or the other to be a monad transformer
05:25:17 <tARrAScH> Saizan - which means?
05:26:02 <Saizan> tARrAScH: uhm, you can exploit the fact that:
05:26:03 <Saizan> newtype Gen a = MkGen {
05:26:03 <Saizan> unGen :: StdGen -> Int -> a
05:26:04 <Saizan> }
05:26:25 <Saizan> but i'm not sure what that would do to the distribution of the samples
05:26:54 <tARrAScH> Saizan: ah, so unGen is something real then ...
05:27:55 <Saizan> tARrAScH: e.g. foo = MkGen $ \g i -> do v <- ask (); (_, p) <- unGen g i (randomProgram' inp (v:out)); return p
05:28:04 <ziman> why the Int ?
05:28:13 <Saizan> size of the sample
05:28:34 <ziman> i see
05:29:15 * ksf decides not to be afraid of unsafeCoerce
05:29:35 <benmachine> unsafeCoerce is just a generalisation of id
05:29:36 <Saizan> tARrAScH: you need QuickCheck-2 for that
05:29:38 <ksf> I've done worse in C and Java, after all.
05:29:48 <tARrAScH> Saizan: I've got that :)
05:30:18 <ksf> thereExistsAProofButTheTypeSystemIsTooNarrowToContainIt = unsafeCoerce
05:30:59 <ziman> @quote unsafeCoerce
05:30:59 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
05:32:54 <ksf> ...the last and only time I used it it looked like instance MonadFix STM where mfix = unsafeCoerce fixIO
05:34:19 <Jafet> @remember benmachine unsafeCoerce is just a generalisation of id
05:34:19 <lambdabot> Done.
05:36:47 <osaunders> Does anybody know who it was who said programming was essentially reducing duplication and naming things?
05:39:13 <Raevel> i was hoping it could be me
05:40:58 <osaunders> Raevel: Yeah, whoever said it was a smart guy.
05:42:53 <tARrAScH> Saizan: I begin to realize what I want to do makes no sense :-/
05:43:43 <merijn> tARrAScH: That's a realization I've been having on a regular basis since I started programming :p
05:44:23 <tARrAScH> It is as if I try to pull aside two rings that are chained together...
05:45:01 <tARrAScH> Or rather as I'm trying to fit a box A into box B and vice verse simultenously...
05:45:37 <merijn> Anyone that can point to the best way of dealing with variable number of arguments and/or optional arguments in haskell?
05:46:22 <Jafet> merijn, HList!
05:46:48 <MissPiggy> merijn, for optional argument t you can use Maybe t
05:46:50 <tARrAScH> merijn: Isn't that equivalent to using a Data DifferentTypes = Velocity v | Position (x,y) ?
05:47:33 <merijn> tARrAScH: You could declare a data type to handle that, yes. But its a braindead and cumbersome solution
05:47:48 <MissPiggy> can anyone tell me how to fix?
05:47:49 <MissPiggy> cabal: cannot configure QuickCheck-2.1.0.3. It requires ghc -any
05:47:56 <Zao> data Stuff = ...
05:47:59 <MissPiggy> I thought if I build the source instead it would go away but it doesn't..
05:48:35 <merijn> MissPiggy: Ah yeah, I didn't think of maybe, that kinda makes sense I suppose. Still a bit ugly, though.
05:48:59 <MissPiggy> merijn, what would the optimal thing be?
05:49:15 <mreh> C pointers
05:49:20 <tARrAScH> lol
05:50:32 <merijn> MissPiggy: More like the way they're written in Python/Lisp, I suppose. But I'm not sure whether that is even possible with haskell's type system
05:50:55 <ksf> "and while addition and multiplication are both monoids over the positive natural numbers, a monad is a monoid object in a category of endofunctors: return is the unit, and join is the binary operation. It couldn't be more simple. If that confuses you, it might be helpful to see a Monad as a lax functor from a terminal bicategory. "
05:50:57 <mreh> oooooh, thems fighting words
05:51:03 <ksf> I think I've never been that wicked before
05:51:40 <MissPiggy> merijn, you could implement your own lisp style brackets (that handled optional arguments) -- now THAT would be guy :)
05:51:41 <tARrAScH> MissPiggy: Are you doing something special? The normal install of QC2 is simpl: cabal install 'QuickCheck > 2'
05:51:43 <MissPiggy> ugly*
05:52:14 <MissPiggy> tARrAScH, I was trying  cabal install agda,  but I get the same error message if I do  cabal install 'QuickCheck > 2'
05:52:38 <mreh> can you separate the IO monad into input and output?
05:52:40 <Jafet> merijn, the usual solution is to transform the problem into a problem that you can solve in Haskell
05:53:15 <ksf> the last time I tried, agda wasn't cabal-installable, but the darcs version built fine
05:53:21 <ksf> if in doubt, ask in #agda
05:53:42 <tARrAScH> merijn: I think what you want is to use Python, I think what you wan't is impossible due to the Strict type-checking or whatever it's called.
05:53:48 <MissPiggy> mreh, um? newtype I a = I (IO a) ; newtype O a = O (IO a) ?
05:54:10 <MissPiggy> ksf, darcs doesnot build for me either (same error about QuickCheck)
05:54:20 <MissPiggy> ... and QuickCheck is supposed to make programs MORE reliable ...
05:54:25 <benmachine> merijn: printf manages variable numbers of arguments, but it's pretty advanced magic iirc
05:54:26 <merijn> tARrAScH: I know it's not possible right now, but what I want is not inherently impossible in a strongly typed language
05:54:35 <ksf> MissPiggy, then what is openFile ReadWriteMode?
05:54:46 <benmachine> > printf "%d %d %d" 4 3 7 :: String
05:54:47 <lambdabot>   "4 3 7"
05:54:55 <benmachine> it uses typeclasses
05:54:58 <MissPiggy> merijn: that's not strictly true
05:55:09 <ksf> how magic printf is depends on implementation
05:55:11 <MissPiggy> merijn: as I said earlier, you could actually do this -- but it would not be nice
05:55:27 <mreh> printf is witchcraft
05:55:33 <merijn> MissPiggy: Ok, let me rephrase it's not possible to do in a NICE way, right now.
05:55:33 <benmachine> ksf: well I only mean magic in an arthur-c-clarke sense
05:55:36 <tARrAScH> burn it!
05:55:43 <MissPiggy> merijn, yeah I agree with you there
05:55:52 <ksf> oleg has a shift/reset based one which might be quite mindbending, but there's also the spj/oleg version with type families, which is really cool.
05:56:12 <Jafet> There isn't anything inherently nice about variable number of arguments, either
05:56:14 <MissPiggy> merijn, although there is a built in that does implict parameters, I think -- so the implementation is /hidden enough/ that it's hard to decide if it's nice or not
05:57:18 <ksf> merijn, http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf    page 15, section 4
05:57:19 <merijn> What I'm trying to express (for example) is a higher order function of the following type "(b -> b -> a) -> b -> b -> a" but with an arbitrary (but known at compile time) number of b's
05:57:36 <MissPiggy> meijn, that's a pretty interesting problem :)
05:57:59 <MissPiggy> meijn, well first of all -- what does the function actually do? (it looks like id to me)
05:58:42 <benmachine> you could view (b -> b -> a) -> b -> b -> a as (b -> r) -> b -> r with r = b -> a
05:58:46 <benmachine> if that helps
05:58:50 <benmachine> which it probably doesn't
05:58:55 <ksf> merijn, http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
05:59:36 <ksf> that class Monadish he uses there is called an Indexed Monad nowadays, to be found in category-extras
06:01:30 <ksf> ...and i should stop writing IxMonad i j a and use IxMonad i0 i1 a because the former gets confusing as hell as soon as you have a look at bind.
06:01:38 <merijn> MissPiggy: Now that I'm trying to explain I see my type is wrong, lemme think about it again for a sec
06:01:45 <MissPiggy> okay
06:02:01 <mreh> :t (>>>)
06:02:02 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:02:27 <Phyx-> I always say i'll read up on Arrows but never get around to it...
06:02:40 <mreh> they're just abstract computations
06:02:55 <tARrAScH> Saizan: Ok I think I know how to solve my problem now. Thanks for all your support. :)
06:03:00 <mreh> stuff goes in, stuff comes out
06:03:14 <Phyx-> mreh: lol, I heard they can express anything you can with monads?
06:03:29 <mreh> all monads are arrows
06:03:35 <mreh> I think
06:03:40 <Saizan> tARrAScH: do you use unGen in the end?
06:03:59 <ksf> all monads are kleisli arrows
06:04:21 <mreh> :t (>=>)
06:04:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:04:30 <ksf> all monads are burritos, too.
06:04:30 <mreh> aaah
06:04:39 <Phyx-> not ponies?
06:04:45 <Jafet> Unicorns.
06:04:57 <mreh> monads are like analogies
06:04:57 <Phyx-> ah, upgrades
06:05:08 <mreh> >>> = >=>
06:05:15 <tARrAScH> Saizan: No, I realized that would be step in the wrong direction (to complicated for me). I just realized I don't need to make randomProgram' to be a Gen, I just increased it's arguements and now it's pure.
06:05:15 <mreh> for monads
06:05:41 <benmachine> Monad and ArrowApply are the interchangeable ones are they not
06:06:16 <benmachine> newtype (ArrowApply a) => ArrowMonad a b = ArrowMonad (a () b)
06:07:39 <MissPiggy> I have a radical idea that will make software better
06:07:50 <merijn> MissPiggy: Ok, my original idea came from rewriting a crappy Java evolutionary computing framework in Haskell. In evolutionary computing I have a population of individuals and for each generation I have a function that takes N individuals from the population and returns a new individual. So the type would be something like "(Population b) => (a -> a -> a -> a) -> b -> a"
06:08:03 <MissPiggy> version 0.2 should WORK in all the same situations as version 0.1
06:08:29 <MissPiggy> meijn, oh that's less interesting since you can just use a list
06:08:38 <MissPiggy> [a] -> b -> a
06:08:56 <benmachine> er
06:09:01 <benmachine> ([a] -> a) -> b -> a
06:09:08 <Jafet> What
06:09:26 <Jafet> a -> a -> a -> a is a weird type, though.
06:09:31 <benmachine> 'tisn't
06:09:42 <benmachine> :t \x y z -> x + y + z
06:09:43 <lambdabot> forall a. (Num a) => a -> a -> a -> a
06:09:51 <merijn> MissPiggy: I figured that too, but trying to write it I wound up having to pass the number of individuals to every single function in the program
06:10:00 <Jafet> :t sum
06:10:01 <lambdabot> forall a. (Num a) => [a] -> a
06:10:04 <Jafet> Yay
06:10:08 <MissPiggy> merijn, hm why?
06:10:22 <MissPiggy> merijn, I mean what's the number for -- as opposed to just using map or fold or whatever
06:11:21 <merijn> MissPiggy: If (a -> a -> a -> a) has an undefined implementation, how do I map/fold it over my collection?
06:12:46 <merijn> The function "(Population b) => (a -> a -> a -> a) -> b -> a" needs to know how many a's the function is going to need. Which is impossible to deduce from the type ([a] -> a)
06:13:20 <merijn> Unless you explicitly pass around the number of a's that is expected.
06:13:21 <Alpounet> merijn, the a -> a -> a -> a function has to mean something wrt to Population
06:13:32 <MissPiggy> merijn, ahh, I am starting to see the problem
06:13:34 <Alpounet> Population has to provide something that'll give you the a's
06:13:51 <merijn> Alpounet: Yeah, I was going to type that earlier, but I got distracted by the response
06:14:03 <merijn> Alpounet: The population type is assumed to provide a function (b -> a)
06:14:12 <Alpounet> that's all ?
06:14:35 <Alpounet> it means you have to apply that function 3 times, and then call the (a -> a -> a -> a) function ?
06:14:45 <Alpounet> looks a bit odd from here.
06:14:46 <merijn> Alpounet: That's all, BUT the number of a's the original function takes is arbitrary (but known at compile time)
06:15:36 <Alpounet> you can play with data TypeNumber a = Succ a | Zero, and then play with Succ (Succ (Succ a)) etc
06:15:57 <Alpounet> One being Succ Zero, and so on.
06:16:00 <Alpounet> hmm
06:16:16 <Alpounet> I meant data TypeNumber = Succ TypeNumber | Zero, ofc
06:16:18 <merijn> Alpounet: What you might have missed earlier is the context. I'm trying to rewrite an evolutionary computing framework we use from Java to Haskell. So the framework has to accept a function from the programmer using it which generates an a from a number of a's
06:16:47 <Alpounet> well if you want to encode that number in the type system, above is how to do it
06:16:55 <Alpounet> otherwise well the list approach seems to be the most appropriate
06:17:40 <benmachine> that's not numbers in the type system
06:17:52 <benmachine> if you want numbers in the type system, you need type functions
06:17:58 <benmachine> i.e. fundeps or type families
06:18:20 <merijn> Alpounet: Yeah, that's what I figured to (the list approach). But since its mostly a learning problem anyway I figured and try to see if there's a neater way of doing it. As it doesn't seem like a problem that is fundamentally impossible with strict typing.
06:18:23 <benmachine> or
06:18:27 <benmachine> just
06:18:29 <benmachine> data Zero; data Succ n
06:18:38 <MissPiggy> nah
06:18:53 <MissPiggy> use Maybe (Maybe (Maybe Void))
06:19:01 <benmachine> heh
06:19:04 <MissPiggy> that way you can use inhabitants of that as indices into the array
06:19:28 <benmachine> Nothing, Just Nothing, Just (Just Nothing)?
06:19:31 <MissPiggy> yes
06:19:36 <benmachine> weeird
06:20:17 <merijn> Anyhoo, I need to pick up food for tonight. Got plenty of new reading and thinking material anyway. Thanks for the suggestios :)
06:21:54 * MissPiggy still doesn't quite know what the good solution i s
06:28:15 <kamatsu> hey, i have an install of yhc, is it possible to make cabal install a yhc version of a package?
06:32:08 <applicative> kamatsu,  dont know anything about it /.cabal/config has a field for --with-compiler
06:33:06 <kamatsu> applicative: ok
06:34:47 <Saizan> kamatsu: noone wrote a module to support yhc :)
06:35:00 <applicative> I see, the yhc isn't listed as a command line option, indeed
06:35:18 <blueonyx> hi, is the gnuplot package outdated? because it Could not find module `Distribution.Simple'
06:35:57 <benmachine> blueonyx: Distribution.Simple is definitely still around
06:36:08 <byorgey> Distribution.Simple is part of Cabal
06:36:17 <benmachine> comes from the Cabal library, which should be free with GHC
06:36:19 <blueonyx> and cabal is part of ghc?
06:36:26 <blueonyx> :/
06:36:33 <byorgey> it's not *part of* GHC
06:36:48 <byorgey> blueonyx: how did you install ghc?
06:36:56 <blueonyx> pacman -S ghc
06:37:33 <byorgey> I recommend installing the Haskell Platform instead, it comes with Cabal and other good stuff already
06:37:55 <benmachine> so does pacman -S
06:37:58 <benmachine> pretty sure
06:38:16 <benmachine> although, platform comes with cabal-install?
06:38:23 <byorgey> benmachine: yes, it does
06:38:30 <blueonyx> is it better to cabal install or makepkg from the aur?
06:38:31 <benmachine> pacman might not get that for you
06:38:47 <benmachine> blueonyx: probably a matter of personal taste
06:38:48 <Saizan> Distribution.Simple is in Cabal the library, anyway
06:39:01 <benmachine> yes
06:39:05 <benmachine> so you kind of should have it
06:39:09 <benmachine> blueonyx: try ghc-pkg list
06:39:38 <blueonyx> it says Cabal-1.8.0.2 but its red :/
06:39:43 <benmachine> red eh
06:39:54 <benmachine> sounds unpleasant
06:40:11 <Saizan> if it's red it's broken
06:40:12 <benmachine> try reinstalling it?
06:40:27 <blueonyx> okay
06:40:29 <Saizan> blueonyx: can you paste the whole ghc-pkg list?
06:40:32 <Saizan> on a pastebin?
06:40:41 <Saizan> blueonyx: wait
06:41:01 <applicative> I see that if he just installed it he has 6.12, for one thing http://archhaskell.wordpress.com/
06:41:02 <Saizan> reinstalling the same Cabal version globally could break your ghc installation even further :)
06:41:35 <applicative> there is wisdom on http://archhaskell.wordpress.com/ for global uninstall and reinstall
06:41:48 <blueonyx> yea thanks
06:42:09 <sexmachine> does anyone here know how to hck shells easily....am nebies and need help
06:42:59 <Saizan> sexmachine: This channel is about the programming language Haskell
06:43:08 <sexmachine> ok
06:43:13 <blueonyx> the problem is array-0.3.0.0-ed0c6ffecd933bdec33f902cfd4153ec does not exist
06:43:48 <sexmachine> saizan: you know any channel or server i could go and get idea on that
06:43:58 <Saizan> sexmachine: no
06:44:28 <sexmachine> ok and thanks
06:44:42 <Saizan> blueonyx: looks like you've resintalled array-0.3.0.0 replacing the old one, but the hashes don't match
06:44:45 <byorgey> nebies?
06:45:31 <blueonyx> does array come with ghc too?
06:47:02 <nomeata> Hi. Did anyone mange to build a haskell module for hugs using Cabal-1.8? I get an error about --inline not supported.
06:49:55 <Kruppe> I need a fast array like data structure with fast modification and lookup. I would ideally like it to be immutable as well. Ive looked at IntMaps and unboxed immutable arrays (Data.Array.Unboxed), what is the tradeoff between these two and is there any others I should check out?
06:50:35 <ksf> parsers just shouldn't be able to fail.
06:50:53 <ksf> ...the parsing function, that is, not the grammar.
06:51:38 <benmachine> Kruppe: an immutable structure with fast modification?
06:51:42 <tARrAScH> I need help with an unsual lambda expression - http://haskell.pastebin.com/d526176dd - can anyone see any solution?
06:52:03 <Kruppe> benmachine: as fast as I can get :P obviously I can't have my cake and eat it too
06:52:24 <ksf> Kruppe, the arrays are strict. each time you change an element, you need a whole new array
06:52:36 <ksf> you might want to look at Data.Sequence
06:52:40 <Jafet> Sounds like a map to me
06:52:41 <tARrAScH> I kinda need to use a where/let inside of an expression somehow :p
06:52:55 <benmachine> Kruppe: why do you want it to be immutable?
06:53:03 <benmachine> tARrAScH: you can use let in an expression
06:53:05 <BenceF> hi! im new to cabal. i want to install YI but it requires cabal == 1.6.* and ive got 1.8.0.2
06:53:06 <ksf> ...and do you need sparse indexing?
06:53:23 <BenceF> should i force it somehow or it wont work anyway?
06:53:23 <tARrAScH> benmachine: hmm , ok, one second
06:53:35 <byorgey> BenceF: you can install Cabal-1.6 as well
06:53:57 <byorgey> BenceF: just  cabal install Cabal-1.6.0.3
06:54:16 <byorgey> it won't mess anything up to have two versions lying around
06:54:21 <BenceF> byorgey: and wont it conflict with the one already installed?
06:54:27 <byorgey> no
06:54:31 <Kruppe> benmachine: I suppose I could work without immutable
06:54:34 <BenceF> ok. ill try
06:54:42 <tARrAScH> benmachine: I really can't see how that would work without any seperators inbetween :s
06:54:56 <ksf> Kruppe, the question is what you're trying to do
06:55:09 <ksf> ...and whether you're optimizing prematurely
06:55:36 <benmachine> tARrAScH: separators?
06:55:51 <benmachine> tARrAScH: if x is a valid expression, then let y = x in x is too
06:56:03 <Kruppe> ksf: It's going to be storing a graph that's going to change and be accessed a lot
06:56:23 <ksf> Sequences give you non-sparse indexing, O(log n) index and modify, O(1) head, tail and cons from both sides and O(log (min m n)) append
06:56:38 <Saizan> blueonyx: yes, array comes with ghc
06:56:41 <ksf> oh, use an IntMap then, as the indices are going to be sparse
06:56:49 <ksf> or just use
06:56:52 <ksf> @hackage fgl
06:56:53 <lambdabot> http://hackage.haskell.org/package/fgl
06:57:19 <tARrAScH> benmachine: yea, how would the code look like? Like this?
06:57:22 <tARrAScH>   (t1, \tick -> ask () >>= (\x -> t2    let (t1,t2) = (randomProgram' inp (x:out)) ))
06:57:27 <Kruppe> ksf: ohhh nice, for some reason I did not see that (fgl)
06:57:27 <ksf> ...which, incidentally, uses IntMap as one of its backends
06:58:04 <benmachine> tARrAScH: why doesn't the thing in the comment work?
06:58:40 <benmachine> tARrAScH: except in do-syntax, every let needs an in
06:58:45 <benmachine> let <binds> in <expr>
06:58:45 <tARrAScH> benmachine: wouldn't that be recursing twice giving an horrible complexity?
06:59:03 <benmachine> oh, you're worried about complexity
06:59:14 <benmachine> you mean recursing twice in each tuple element?
06:59:19 <benmachine> err, once in each
06:59:20 <tARrAScH> benmachine: yea
06:59:40 <tARrAScH> benmachine: y, lol, twice in each ^^
07:00:04 <ksf> mhh i don't like the fact that my parser needs a one-char lookahead.
07:00:45 <tARrAScH> (t1, \tick -> ask () >>= \x -> let (t1,t2) = (randomProgram' inp (x:out)) in t2 ) --> not in scope t1, well that's not so surprisingly but I bet there's just a few edits required to get it to work
07:01:11 <ski> ksf : sorry, got distracted .. sharing what ?
07:01:14 <benmachine> tARrAScH: how does that make sense though?
07:01:28 <blueonyx> okay, after reinstalling, gnuplot fails because array and containers have version 0.3 and it needs array >=0.1 && <0.3, containers >=0.1 && <0.3 :(
07:01:31 <ski> (merijn : hm, you've mentioned that problem, yes ?)
07:01:36 <benmachine> tARrAScH: suppose I haven't passed a parameter to the second part of the tuple
07:01:45 <benmachine> tARrAScH: then t1 doesn't exist
07:01:46 <ksf> ski, something with lambdas. my scrollback doesnt' suffice.
07:01:49 <BenceF> another question: in GL the Modelview Matrixmode takes a GLsizei. what is that?
07:01:53 <benmachine> but I can access it by looking at the first part of the tuple
07:02:04 <benmachine> what am I expecting to see?
07:02:06 <Saizan> blueonyx: it seems gnuplot hasn't been updated to work with ghc-6.12.1 yet then
07:02:15 <ski> MissPiggy : ty for the GCLA link :) .. i found that long ago, but then couldn't refind it again :/
07:02:16 <Saizan> blueonyx: you might try by editing the .cabal file
07:02:19 <tARrAScH> benmachine: You're completely right. Back to the drawing table.
07:02:21 <zygoloid> @type \tick -> ask >>= \x -> let (t1, t2) = (?something) in t2
07:02:22 <lambdabot> forall t (m :: * -> *) a t1 b. (?something::(t1, m b), MonadReader a m) => t -> m b
07:02:34 <benmachine> tARrAScH: sounds like your data dependencies are a bit odd :)
07:02:35 <blueonyx> Saizan: okay, thanks
07:02:58 <Saizan> blueonyx: "cabal unpack gnuplot" to get the sources
07:03:14 <tARrAScH> benmachine: a bit :p ?
07:03:45 <ksf> ...worse than the one-char lookahead, it's actually matching the same character a couple of times when it changes from one subgrammar to the other.
07:03:49 <ski> ksf : re Kostafey's wanting explanation of `scalarR = \l x -> map (x*) l' ? ..
07:03:52 <ski> ksf : .. or you talking something about iteratee-based parsers and http requests ?
07:06:25 <blueonyx> Saizan: installs just fine :)
07:06:34 <zygoloid> @type let randomProgram' (Just i:inp) out = \tick -> do f <- ask; randomProgram' inp (f tick:out) tick     in randomProgram'
07:06:35 <lambdabot> forall t a t1 (m :: * -> *) b. (MonadReader (t1 -> a) m) => [Maybe t] -> [a] -> t1 -> m b
07:06:50 <zygoloid> ^^ tARrAScH is that what you want? i'm not really sure what you're trying to do...
07:08:22 <tARrAScH> zygoloid: have you seen my paste? Here it is anyway http://haskell.pastebin.com/d526176dd
07:09:24 <zygoloid> tARrAScH: yes i've seen your paste (that's where i got the function name etc from) but what you say there makes no sense
07:09:40 <ski> @type undefined `asTypeIn` \something tick -> ask >>= \x -> let (t1, t2) = something in t2
07:09:40 <lambdabot> forall (m :: * -> *) a t b. (MonadReader a m) => (t, m b)
07:09:47 <zygoloid> you want the fst of the tuple to be the value between stars, which has 'x' free in it
07:11:29 <applicative> tARrAScH: why is it ask ()?    ask () is ()
07:12:03 <tARrAScH> applicative: can I replace all occurences of "ask ()" with "()" ???
07:12:10 <zygoloid> > ask ()
07:12:11 <lambdabot>   ()
07:12:16 <tARrAScH> :O
07:12:28 <tARrAScH> wait
07:12:33 <tARrAScH> is ask a standard function or sth?
07:12:37 <zygoloid> yes
07:12:40 <zygoloid> @type ask
07:12:41 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
07:12:46 <ski> tARrAScH : yes
07:12:46 <applicative> it type checks if you omit the ()
07:12:54 <applicative> though I stil cant follow
07:13:13 <zygoloid> tARrAScH: what are you actually trying to achieve?
07:13:15 <tARrAScH> I'm so sorry, my ask is another ask...
07:13:46 <applicative> @type \randomProgram' -> \inp -> \out -> ( ask  >>= \x -> fst (randomProgram' inp (x:out)) )
07:13:47 <lambdabot> forall t (m :: * -> *) a b b1. (MonadReader a m) => (t -> [a] -> (m b1, b)) -> t -> [a] -> m b1
07:14:01 <applicative> i see not the Reader
07:14:26 <tARrAScH> zygoloid: hmm, let me work on it for  a while
07:14:26 <kuribas> Are there any continuation web frameworks for haskell?
07:14:51 <tARrAScH> zygoloid: thanks for you help really but I think I must think this over once again
07:15:29 <Phyx-> hmm anyone have any luck building ghc on windows? msys is giving me a hard time
07:15:59 <zygoloid> tARrAScH: wisdom you find by yourself is almost always better than wisdom given to you by others :)
07:16:56 <BenceF> Phyx-: as i can tell from the videos on the net most of the people are using it from cygwin. i think theres a reason...
07:17:12 <medfly> strange
07:17:25 <medfly> I recall someone saying that using GHC on Windows shouldn't be much of a problem?
07:17:32 <Igloo> msys is commonly used
07:17:35 <Igloo> What sort of a hard time?
07:17:47 <BenceF> medfly: i havent tried
07:18:42 <applicative> @ type  \randomProgram' -> \ask' -> \inp -> \out -> ( ask'  >>= \x -> fst (randomProgram' inp (x:out)) )
07:18:57 <applicative> @type  \randomProgram' -> \ask' -> \inp -> \out -> ( ask'  >>= \x -> fst (randomProgram' inp (x:out)) )
07:18:58 <lambdabot> forall t (m :: * -> *) a b b1. (Monad m) => (t -> [a] -> (m b1, b)) -> m a -> t -> [a] -> m b1
07:19:12 <applicative> @type  \randomProgram' -> \ask' -> \inp -> \out -> ( ask'  () >>= \x -> fst (randomProgram' inp (x:out)) )
07:19:13 <lambdabot> forall t (m :: * -> *) a b b1. (Monad m) => (t -> [a] -> (m b1, b)) -> (() -> m a) -> t -> [a] -> m b1
07:20:24 <ksf> WAAAAAAAAAAAAAAAAAAAAGHHH!!!
07:20:29 <ksf> HPASTE IS DOWN!
07:20:34 <medfly> codepad.org
07:21:13 <sm> or gist.github.com
07:22:05 <ksf> release early, release often (and hope people don't laugh at you)
07:22:08 <ksf> http://codepad.org/oSeqZyNN
07:23:07 <ksf> the code actually creeps me out, because it parses more than I intended it to
07:23:49 <ksf> ...considering that it's meant to be used with iteratees, those being the ones that do all the context-sensitive stuff
07:24:39 <ksf> ...and don't look at atmost, the implementation is silly.
07:25:17 <ksf> it needs to be based upon the current parse position, not upon the repetition of some parser.
07:25:46 <tARrAScH> zygoloid: I want something like this:   let t2 = \tick -> Replay.ask () >>= \x -> let (rt1, rt2) = randomProgram' inp (x:out) in rt2 tick in (rt1, t2)
07:26:04 <Phyx-> BenceF: yes but cygwin is a problem for me, since you can't have more than 1 version of the cygwin1.dll loaded into memory
07:26:07 <tARrAScH> But of course rt1 is not in scope, is there any way to force it into scope ?
07:26:33 <tARrAScH> yuck, i better paste-bin it or its unreadable
07:26:40 <Phyx-> medfly: my problem isn't so much with ghc as it's with msys, at the very end it tells me "read only filesystem" and just exits
07:27:00 <tARrAScH> http://codepad.org/dk3MmYAv
07:27:49 <medfly> I like to google the exact error when I have problems like that
07:27:50 <medfly> :]
07:28:05 <BenceF> use bing
07:28:08 <BenceF> :)
07:28:29 <Phyx-> medfly: i did, unfortunately something like "read-only filesystem" is so common that all i get is garbage
07:28:53 <BenceF> append msys to the querry
07:29:20 <Phyx-> i did, end up with configurations scripts or manuals, nothing really helpful, i'm hoping someone in #mingw knows
07:30:22 <zygoloid> tARrAScH: it looks like rt1 depends on x. if so, you can't get it to escape the scope of the \x -> ...; if not, you'll need some more refactoring to separate x from the fst of that pair
07:30:43 <BenceF> ive found this: real estate apartment for rent at mingw.org
07:31:13 <Phyx-> lol, odd
07:31:16 <BenceF> definetly gets you closer to the solution
07:31:25 <BenceF> phisically
07:31:25 <Phyx-> the channel said their domain name expired
07:31:29 <Phyx-> but works here
07:31:32 <Phyx-> must be cached
07:31:37 <Phyx-> the dns query
07:31:50 <BenceF> yeah. funny non the less
07:32:12 <Phyx-> LOL, a TRON movie
07:32:57 <BenceF> we're at the heart of the problem i feel it
07:33:46 <Phyx-> i would check the mount entries.. but mount says fstab.conf is not found
07:34:39 <Phyx-> oh, i think... i might know.. it's mixing my normal mingw with the one from devkitpro
07:35:37 <applicative>  <tARrAScH>: what is the ambient monad for >>= ?  Is this IO
07:36:02 <tARrAScH> applicative: ambient? It's my own monad: Replay
07:36:57 * ksf wonders whether a http server needs to distinguish between /foo/ and /foo
07:37:23 <tromp> former might look for foo/index.html
07:37:35 <ksf> ...but so should /foo
07:37:36 <Phyx-> or give a directory listing
07:37:38 <applicative> @type \(ask', rt1) -> \(randomProgram', inp,out) -> let t2 = \tick -> ask' () >>= \x -> let (rt1, rt2) = randomProgram' inp (x:out) in rt2 tick in (rt1, t2)
07:37:39 <lambdabot> forall t t1 t2 (m :: * -> *) a t3 b. (Monad m) => (() -> m a, t) -> (t1 -> [a] -> (t3, t2 -> m b), t1, [a]) -> (t, t2 -> m b)
07:37:41 <ksf> that, too.
07:37:54 <tromp> ah, you're right
07:38:51 <applicative>  tARrAScH, I'm still puzzled by ask () .  In general a function of type () -> blah is a constant in blaj
07:38:56 <ksf> maybe the right way to do it is to hand out the unparsed path along with the parsed one
07:39:41 <Alpounet> @type \() -> getLine
07:39:42 <lambdabot> () -> IO String
07:40:04 <quicksilver> ksf: traditionally, they do not distinguish
07:40:10 <ksf> don't tell me you want to be able to write getLine()
07:40:14 <quicksilver> ksf: however, that means that relative links break
07:40:24 <Alpounet> ksf, no no don't worry heh
07:40:34 <quicksilver> ksf: the traditional solution to this is to redirect "/foo" to "/foo/" in the case that foo is a "directory-like-thing"
07:40:43 <quicksilver> that's what apache does, for example.
07:40:45 <tARrAScH> applicative: well I've defined my own ask, does that unpuzzle you? :)
07:40:45 <applicative> @type (\() -> getLine)(())
07:40:47 <lambdabot> IO String
07:41:10 <applicative> i saw that part, thats why when I asked for the type signature I abstracted ask'
07:41:21 <applicative> @type \(ask', rt1) -> \(randomProgram', inp,out) -> let t2 = \tick -> ask' () >>= \x -> let (rt1, rt2) = randomProgram' inp (x:out) in rt2 tick in (rt1, t2)
07:41:22 <lambdabot> forall t t1 t2 (m :: * -> *) a t3 b. (Monad m) => (() -> m a, t) -> (t1 -> [a] -> (t3, t2 -> m b), t1, [a]) -> (t, t2 -> m b)
07:41:37 <ksf> If I keep my parser as it is now, both are always considered to be the same
07:41:53 <ksf> ...so you could say /foo/index.html/ and get /foo/index.html
07:42:05 <quicksilver> that will break relative links
07:42:07 <applicative> the first pair is the undefined bits, ask and rt1, the triple is (program, input,output)
07:42:17 <ksf> but who says the former?
07:42:34 <ksf> and htf should my parser know whether that's a directory-like thing/
07:42:44 <ksf> ?
07:43:02 <quicksilver> well the parser can't
07:43:09 <quicksilver> so the parser probably needs to consider them different
07:43:12 <quicksilver> if you care about this issue
07:43:36 <ksf> I don't, my perfectionism does.
07:43:58 <tARrAScH> applicative: I must say I've no idea what you're talking about :s
07:45:06 <applicative> <tARrAScH>: I asked ghc what type you could be meaning by something of the form    let t2 = \tick -> ask' () >>= \x -> let (rt1, rt2) = randomProgram' inp (x:out) in rt2 tick in (rt1, t2)
07:45:54 <lispy> ?hoogle Reader
07:45:55 <lambdabot> module Control.Monad.Reader
07:45:55 <lambdabot> Control.Monad.Reader newtype Reader r a
07:45:55 <lambdabot> Control.Monad.Reader Reader :: (r -> a) -> Reader r a
07:45:55 <aep> hm how would i drop the last element from a list?
07:46:07 <mux> > init [1,2,3,4]
07:46:08 <lambdabot>   [1,2,3]
07:46:20 <aep> cool thanks
07:46:28 <applicative> this has five undefined terms, rt1 and ask, on the one hand, and then randomProgram', inp  and out
07:46:29 <mux> you're welcome
07:46:36 <mux> > init [] -- also note that
07:46:37 <lambdabot>   * Exception: Prelude.init: empty list
07:46:42 <MissPiggy> > join (takeWhile . ((/=) . last)) "foobars"
07:46:43 <lambdabot>   "foobar"
07:46:58 <MissPiggy> > join (takeWhile . (/=) . last) "foobars"
07:46:59 <lambdabot>   "foobar"
07:47:00 <mux> > (reverse . drop 1 . reverse) [] -- that works for empty lists
07:47:01 <lambdabot>   []
07:49:44 <Arnar> how do I access operators from qualified modules?
07:50:00 <doserj> @type (Prelude.+)
07:50:00 <lambdabot> forall a. (Num a) => a -> a -> a
07:50:01 <Arnar> Q.(<$>) complains
07:50:03 <Arnar> ah
07:50:05 <Arnar> hm
07:50:25 <Arnar> <$>) = (Q.<$>)  <- "not in scope"
07:50:32 <Arnar> and there is a ( in front
07:51:08 <Arnar> oh wait.. my mistake
07:51:08 <doserj> I would guess (Q.<$>) is not in scope
07:51:50 <Arnar> I was smoking something apparently
07:52:04 <Arnar> just needed to import Applicative
07:52:40 <applicative> it's better than being deported
07:54:01 <ksf> quicksilver, what about /foo/////bar ?
08:24:23 <rubberneck> ?
08:25:42 <Lemmih> !
08:26:50 <quicksilver> ksf: apache tolerates that without canonicalising it
08:26:59 <quicksilver> ksf: but it doesn't break relative links I guess
08:41:27 <tARrAScH> what's the prettiest way to do the function [Just 4, Just 2, Nothing] -> [4, 2] ?
08:41:44 <aep> i need to fix a  hackage package,  how would i make ghc use my version instead of the system one?
08:41:50 <Twey> tARrAScH: catMaybes
08:41:59 <Twey> > catMaybes [Just 4, Just 2, Nothing]
08:42:00 <lambdabot>   [4,2]
08:42:02 <tARrAScH> sweet
08:42:45 <aep> or alternatively, can i "cast" a "data stuff | stuff"  into a record type?  its a c struct
08:43:18 <Twey> aep: Looks like you want Data.Binary.Get
08:43:29 <aep> thanks
08:45:23 <cheater> what is 'Just' ?
08:45:53 <aep> a constructor of Maybe
08:45:57 <fasta> <interactive>: CReal.toRational
08:45:58 <fasta> <interactive>: interrupted
08:45:58 <fasta> <interactive>: warning: too many hs_exit()s
08:45:58 <fasta> Process haskell exited abnormally with code 252
08:46:15 <fasta> Does this message sound familiar to anyone?
08:46:37 <fasta> I see what it says and I know what hs_exit does. I just have no idea, why it would say that.
08:48:32 <Lycurgus> prolly somebody programmed it
08:49:06 <fasta> When I compile the program and execute it I get a stack trace <Data.Number.CReal.CAF><Data.Number.CReal.CAF><MAIN.SYSTEM>.
08:49:13 <CosmicRay> is there any trick to get Hackage to tell me what all packages use a particular one?
08:49:16 <Beelsebob> fasta: hs_exit is GHC's call to shut down the haskell runtime
08:49:27 <fasta> Beelsebob, that would be the part that I would know.
08:49:40 <Beelsebob> oh fail, I misread what you said
08:49:55 <Beelsebob> what is it producing this?  ghci or something else?
08:49:58 <fasta> AFAIK, CReal is pure Haskell.
08:50:14 <copumpkin> yep
08:50:15 <fasta> Beelsebob, the stack trace is from a compiled GHC program.
08:50:21 <Beelsebob> oh wow
08:50:22 <Beelsebob> impressive
08:50:32 <fasta> Beelsebob, the <interactive> stuff is from ghci.
08:50:37 <Beelsebob> oh, okay
08:50:53 <Beelsebob> so it segfaults if you compile it?
08:51:33 <fasta> Beelsebob, it does not say segmentation fault.
08:51:38 <fasta> Beelsebob, just an exit status of 1.
08:53:14 <voker57_> what is GHC.Magic and where to find it?
08:54:03 <fasta> Beelsebob, is there any reason why GTK2HS might call hs_exit?
08:54:30 <Beelsebob> probably may
08:55:59 <fasta> Beelsebob, if I first compute a certain result and then call the code which displays the result manually, it works. If I use the result in the drawing code immediately, I get the above results.
08:56:46 <fasta> The Ghaotic Haskell Compiler. ;)
09:00:44 <ksf> http://codepad.org/AEcBEX0G
09:00:50 <ksf> isn't that beautiful?
09:01:29 <pastorn> ksf: what does it do?
09:01:39 <ksf> it parses.
09:01:52 <ksf> ...looking at each input character at most once
09:02:00 <ksf> no backtracking, no lookahead
09:02:27 <ksf> still, it uses fully monadic parsing combinators
09:03:05 <ksf> ...and by "looking at" I mean "does a Map.lookup"
09:03:21 <Arnar> hmm.. when asking for an arbitrary list (in quickcheck).. can I specify it's length somewhow?
09:03:25 <Arnar> or at least a lower bound
09:06:23 <ksf> pastorn, a simplified parser for the http method looks like this:  http://codepad.org/8JeeKpwt
09:06:54 <ksf> ...notice the interleaved P(UT|OST) and stuff
09:07:25 <MissPiggy> that's nice
09:07:30 <quicksilver> Arnar: yes, that's what the "sized" combinator does
09:08:42 <Arnar> quicksilver: ah thanks..
09:08:47 <Arnar> I thought that only gave an upper bound
09:12:06 <quicksilver> hmm. You could be right. But that's not what I thoguht.
09:12:16 <Arnar> quicksilver: I found it
09:12:20 <Arnar> vectorOf
09:13:24 <Arnar> > sample $ vectorOf 5 (arbitrary :: Int)
09:13:25 <lambdabot>   Not in scope: `sample'Not in scope: `vectorOf'Not in scope: `arbitrary'
09:21:04 <quicksilver> Arnar: that's just replicateM 5 arbitrary isn't it?
09:21:09 <quicksilver> Arnar: don't forget Gen is a monad...
09:25:51 <Phyx-> well.. #mingw was useless
09:26:17 <tommd> But not anymore?
09:26:17 <quicksilver> all channels are useless compared to this one
09:26:36 <quicksilver> apart from #haskell, most channels just exist to abuse people for asking questions the wrong way
09:26:50 <quicksilver> (while this one exists to have long discussions about what's wrong with C++ ?)
09:27:00 <FauxFaux> That's certainly why I'm in most channels.
09:28:32 <Phyx-> tommd: as of 5 mins ago, it still is
09:30:00 <lukeo05> How can I construct a Char which consists of more than one symbol? Specifically, if a function takes an input char of 'n', how can I make the output be '\n' (without just pattern matching the n, because the n could be one of many values)
09:30:27 <pikhq> That's not more than one symbol.
09:30:31 <quicksilver> Chars cannot be more than one symbol.
09:30:42 <quicksilver> '\n' is a newline, which is just one character
09:31:24 <quicksilver> the \-escapes are syntax though, you can't just say '\' +++ 'n' for any simple +++
09:31:51 <quicksilver> you can do the following terrible hack though: read ("'\" ++ [c] ++ "'")
09:32:07 <quicksilver> > read ("'\" ++ "n" ++ "'") :: Char
09:32:08 <lambdabot>   <no location info>:
09:32:08 <lambdabot>      lexical error in string/character literal at chara...
09:32:25 <quicksilver> > read ("'\\" ++ "n" ++ "'") :: Char
09:32:26 <lambdabot>   '\n'
09:33:08 <Phyx-> heh
09:33:55 <lukeo05> Is that really bad practice to do that? The way I have done it looks pretty ugly at the moment so I am just looking for a better way.
09:35:52 <fxr> lukeo05: what are the possible values of n?
09:36:02 <ksf> is there a nice way to override haddock documentation?
09:36:22 <lukeo05> scanner ('\':'n':cs) = '\n', with a different pattern for each one that it could be. It seems like it could be nice if I could do something along the lines of scanner ('\':c:cs) = '\':c or whatever the operator is.
09:36:26 <ksf> i.e. I'd like to re-export <|> and document how my alternative instance behaves
09:36:44 <MissPiggy> scanner ('\':c:cs) = '\':c  is a type error
09:36:53 <quicksilver> MissPiggy: yes, but he just explained all that.
09:36:59 <int-e> > '\LF'
09:36:59 <lambdabot>   '\n'
09:37:05 <quicksilver> hence "...or whatever the operator is"
09:37:18 <lukeo05> it could be 'n', 't', 'r', '\' or '''
09:37:23 <int-e> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Text-Read-Lex.html contains a list.
09:37:24 <quicksilver> lukeo05: well surely it's only a few cases. I'd just list them.
09:37:36 <fxr> me too
09:37:48 <benmachine> it does sound a bit like you are duplicating the work of read on String
09:37:49 <quicksilver> if you really want to be *exactly* haskell syntax then you can re-use the haskell lexing stuff complete though.
09:38:08 <cheater2> aep: and what's "Maybe"?
09:38:13 <lukeo05> Fair enough. I did that and it didn't look so nice, I thought you guys might have some clever way of doing it that I would never think of like you usually do!
09:39:17 <aep> cheater2: http://www.haskell.org/all_about_monads/html/maybemonad.html
09:39:29 <benmachine> > let descape = read . ('\"') . (++ "\"") in descape "foo\nbar\nbaz\n"
09:39:30 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
09:39:30 <lambdabot>         against inferre...
09:39:34 <fxr> > map ord "ntr\\\'"
09:39:35 <benmachine> whoops
09:39:35 <lambdabot>   [110,116,114,92,39]
09:39:42 <aep> cheater2: basicly its a polymorphic datatype which can be either "Just somedata"  or "Nothing"
09:39:42 <benmachine> > let descape = read . ('\"' :) . (++ "\"") in descape "foo\nbar\nbaz\n"
09:39:43 <lambdabot>   * Exception: Prelude.read: no parse
09:39:47 <Phyx-> > map map
09:39:48 <lambdabot>   []->
09:39:49 <lambdabot>    []
09:39:49 <lambdabot>  [{()->()}]->
09:39:49 <lambdabot>    [{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]...
09:39:51 <benmachine> > let descape = read . ('\"' :) . (++ "\"") in descape "foo\nbar\nbaz\n" :: String
09:39:52 <lambdabot>   "foo\nbar\nbaz\n"
09:39:56 <benmachine> ^ silly
09:39:59 <benmachine> wait
09:40:04 <benmachine> > let descape = read . ('\"' :) . (++ "\"") in descape "foo\\nbar\\nbaz\\n" :: String
09:40:05 <lambdabot>   "foo\nbar\nbaz\n"
09:40:10 <aep> cheater2: it should be pretty early in any haskell introduction
09:40:11 <benmachine> ^ still silly
09:40:17 <cheater2> aep: ahhh ok
09:40:24 <benmachine> :t map
09:40:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:40:26 <Phyx-> map (>>=)
09:40:27 <aep> cheater2: which one did you read?
09:40:31 <cheater2> aep: i'm reading 'learn you a haskell', it hasn't mention Maybe yet
09:40:37 <cheater2> i'm on guards and stuff like that
09:40:40 <quicksilver> overall I think it's cleaner to document clearly by your code what escaping rules you're using
09:40:51 <quicksilver> rather than just re-using the host language
09:40:53 <aep> cheater2: yeah, its a really good tutorial, sadly it lacks monads alltogether
09:40:59 <benmachine> that sounds sensible
09:41:03 <Phyx-> > map (>>=)
09:41:04 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
09:41:04 <lambdabot>                    GHC.Show...
09:41:10 <aep> cheater2: i started with it too. poke me if you're done and need more pointers
09:41:13 <Phyx-> :t map (>>=)
09:41:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> [(a -> m b) -> m b]
09:41:19 <cheater2> aep: thanks =)
09:41:28 <Phyx-> :t map (>>=) [Just 1]
09:41:29 <lambdabot> forall a b. (Num a) => [(a -> Maybe b) -> Maybe b]
09:41:51 <benmachine> Phyx-: may I ask what on earth you doing?
09:41:55 <cheater2> aep: i will try to remember (i still don't remember everyone from this channel, i've only been here a few days :) )
09:42:04 <kmc_> aep: i'm not sure that's sad.  a lot of people think it's impossible to learn them any haskell without knowing monads
09:42:06 <Phyx-> benmachine: i'll let you know when i know myself....
09:42:14 <benmachine> Phyx-: (and also point out that you can query lambdabot)
09:42:17 <kmc_> and so it's nice to have a good beginner tutorial that mostly ignores them
09:42:32 <aep> cheater2: you dont have to. the people here are generally all quite nice :)
09:42:39 <cheater2> :)
09:42:41 <Phyx-> benmachine: oh, okies, thanks
09:43:07 <aep> kmc_: i had real trouble moving on from "teach you a haskell", until someone gave me a personal leason.
09:43:19 <benmachine> *learn :P
09:43:35 <kmc_> hmm
09:43:44 <kmc_> well, RWH covers monads
09:44:11 <benmachine> I never got a personal lesson, I just hung around here
09:44:13 <aep> yeah, i dont really like RWH :/  i only understanding it _after_ i learned the basics of haskell
09:44:28 <benmachine> do it for long enough it's more or less the same :P
09:44:46 <benmachine> never got far into RWH personally
09:45:32 <aep> bonus should totally continue learnyouahaskell :)
09:45:45 <aep> i find it far far better then RWH
09:46:03 <kmc_> i don't remember how i learned monads.  i think just by seeing some and using them
09:46:10 <kmc_> i read "All About Monads" but it's not that great
09:46:16 <aep> monads are actually very easy to understand with some analogies, but rwh explains them in an extremly hard way
09:46:24 <kmc_> no no no the analogies are terrible
09:46:31 <aep> all about monads was the thing with the boxes wasnt it?
09:46:40 <shapr> I learned monads by reading Steve Atkins' examples.
09:46:42 <aep> i liked it alot.
09:46:46 <c_wraith> aep: they have different goals.  RWH is for...  well, real-world examples.  LYAH is about "how to learn the language"
09:46:49 <kmc_> i think there's no analogy that works for all monads
09:46:55 <quicksilver> well, the analogies are personal
09:46:58 <kmc_> no simple one
09:47:01 <quicksilver> they work for some people, at some times
09:47:05 <aep> kmc_: yes, but once you understand one analogy, you can move on
09:47:12 <quicksilver> (if you catch them at the right point in their learning process)
09:47:30 <aep> its easier then being dropped right into the whole complexity of what you can do with them
09:47:35 <kmc_> there's a good IO-analogy (IO recpies) and a good Maybe-analogy (failing computations) and a good []-analogy (nondeterminism) etc.
09:48:03 <aep> nah those are for specific monads. that doesnt help understanding monads in general
09:48:17 <kmc_> that's my point
09:48:23 * hackagebot upload: MissingH 1.1.0.2 - Large utility library (JohnGoerzen)
09:50:01 <aep> http://www.haskell.org/all_about_monads/html/analogy.html
09:50:10 <aep> i totally enjoyed this one
09:50:22 <kmc_> @where burrito
09:50:22 <lambdabot> I know nothing about burrito.
09:50:34 <aep> poor lambdabot
09:50:45 <kmc_> @where+ burrito http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:50:46 <lambdabot> Done.
09:50:47 <kmc_> @where burrito
09:50:47 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:51:29 <c_wraith> how does one bump up the ulimit on open files for a haskell process?
09:51:51 * Phyx- gives up and goes to build using cygwin
09:51:53 <kmc_> how do you do it for a C process?
09:52:00 <aep> c_wraith: man ulimit
09:52:10 <aep> (its an external tool)
09:52:31 <aep> ok that manual is useless. hm
09:52:35 <c_wraith> There are syscalls you can use to set the values internally, if they haven't been set externally
09:53:04 <kmc_> System.Posix.Resource ?
09:53:13 <cheater2> does someone have an analogy to monads based on the babbage machine
09:53:16 <aep> isnt that just ulimit() too?
09:53:20 <cheater2> thanks
09:53:36 <kmc_> worst case, you can make an FFI call to the C ulimit() function
09:54:01 <c_wraith> ah, thanks for the pointer to resource, kmc_
09:56:01 <lukeo05> quicksilver: Hmm... I did your read ("'\\"++[c]++"'")::Char and it works a treat. At least now I have one line instead of 5 and you don't have to extend that everytime you want to add a new escape char.
09:56:25 <c_wraith> grah.  ResourceLimits doesn't have a Show instance.  Annoying!
09:59:13 <kmc_> it's not opaque.  you can define one, or use GHC's StandaloneDeriving
10:00:33 <c_wraith> Yeah.  I really just wanted to play with it in ghci.  There's no reason for those to not just derive Show as well as Eq
10:10:25 <c_wraith> ah.  man bash to the rescue.
10:23:34 <PO8> Can anyone explain the situation with the "old-locale" package to me?  This appears to be the current package used by Data.Time.  Why is old-locale deprecated?  Are bug-fixes for it accepted?
10:23:59 <lpsmith> http://www.reddit.com/r/programming/comments/b19gj/ask_proggit_im_writing_an_article_for_the/c0kg9jm
10:25:15 <roconnor> lpsmith: your name is Leon!
10:25:26 <lpsmith> Yeah :)
10:25:40 <roconnor> maybe I'm getting the wrong thing out of this post :D
10:26:24 <lpsmith> Well, honestly,  I'm fishing for upvotes,  in the hopes that the comment gets more noticed :-P
10:26:47 * roconnor upvotes for giving lpsmith's first name
10:27:05 <lpsmith> But it has haskell in it,  and I do think haskell is the best possible language for teaching euclid's algorithm!
10:27:11 <roconnor> lpsmith: actually it has good content
10:27:19 <PO8> old-locale?  Anyone?  Thanks much for whatever help you can give...
10:27:35 * roconnor knows nothing about old-locale
10:27:38 <roconnor> or any locale
10:27:44 * PO8 grins
10:27:47 * roconnor finds locales very very confusing
10:27:56 * PO8 agrees
10:28:07 <roconnor> in paritcual peal is always complaining about something about locales
10:28:11 <roconnor> ugh
10:28:16 <roconnor> in particular perl is
10:28:59 <kmc_> @quote _pizza_
10:29:00 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
10:29:21 <PO8> I am more confused here, though, by the fact that we still seem to be shipping a package that is marked "old" and "deprecated", but which the "new" Data.Time package depends on, and that there is no obvious replacement for, and no obvious reason why it is deprecated.
10:31:20 <Phyx-> OMG, what is that ghc boot sh script doing... there's like 100 perl instances running
10:31:31 <Zao> Phyx-: Mangle stuff?
10:31:48 <Phyx-> Zao: but that many perl instances??
10:32:15 <PO8> There's http://hackage.haskell.org/trac/ghc/ticket/1007, but I'm not quite getting the status of that, either.  It sat for three years: 10 days ago somebody bumped it, but it looks like just a maintenance bump?
10:32:17 <Phyx-> that's one way to occupy every core
10:32:34 <ezyang> What is the current literature about computational systems that emphasize partial information?
10:33:45 <PO8> Oh well; guess I'll email some people.  Thanks anyway.
10:33:57 <Saizan> i've been reading "Semantic foundations of concurrent constraint programming"
10:34:01 <absentia> youtube video
10:34:15 <MissPiggy> Saizan is that online ?
10:34:33 <ezyang> Saizan: That... actually sounds kind of like what I'm reading ("Propagation Networks")
10:35:19 <Saizan> MissPiggy: yeah, i found it via google scholar
10:35:33 <MissPiggy> have you found any good CHR lib for haskell
10:35:38 <MissPiggy> I tried STM CHR but it was very very slow
10:36:02 <Saizan> no, i've found only that one too
10:36:23 <cheater2> CHR?
10:36:35 <ski> Constraint Handling Rules
10:36:41 <ski> (iirc)
10:38:50 <Saizan> yeah
10:39:03 <cheater2> http://www.cs.kuleuven.be/~dtai/projects/CHR/ this thing? looks cool
10:39:18 <Saizan> exactly
10:39:28 <MissPiggy> CHR is awesome
10:39:33 <MissPiggy> the haskell implementations are bad though
10:39:40 <MissPiggy> or at least impractical
10:40:12 <Saizan> which are the others beside stm-chr?
10:40:20 <MissPiggy> some rubbish one that doesn't build :P
10:40:31 <Saizan> heh
10:40:32 <MissPiggy> and it's written in C as well as ahaskell
10:40:41 <ksf> I think I've just opened the door for a whole new type of DOS attack
10:41:41 <ksf> ...the representation of my parsers is potentially unbounded in memory, so an attacker just has to figure out how to force the maximum amount...
10:42:09 <ksf> the problem is that I can't see an easy way to disallow haskell's open recursion
10:42:13 <MissPiggy> ksf if you like then you should have put a limit on it
10:42:22 <BONUS> lol
10:42:28 <ezyang> ksf: What parsers are you referring to?
10:42:34 <BONUS> beyonce
10:42:45 <ksf> ...even if I would change the parser to use looping primitives
10:43:03 <cheater2> BONUS: hi, did you make 'learn you a haskell'?
10:43:17 <BONUS> cheater2: not yet actually, still working on it :)
10:43:24 <cheater2> it's great, you should make more
10:43:27 <BONUS> im a lazy bugger
10:43:31 <BONUS> yeah i will, definitely
10:43:47 <ksf> ezyang, http://codepad.org/JTPtFwZY
10:43:53 <cheater2> it's quite fun and it let me get into haskell much quicker than most other languages
10:44:07 <lament> BONUS: one day i'll ask you for advice about drugs
10:44:14 <kmc_> haha
10:44:17 <BONUS> cool to hear! haskell owns
10:44:22 <cheater2> =)
10:44:35 <BONUS> lament: haha :D
10:44:43 <nlogax> yes, more LYAH please! work harder!!! please
10:44:45 <MissPiggy> @keal
10:44:45 <lambdabot> what the hell does Prelude > mean?
10:44:53 <BONUS> i will! aaa!
10:44:57 * BONUS gets hit with a whip
10:44:58 <nlogax> faster!
10:45:00 <ksf> MissPiggy, I don't like the idea of doing fine-grained recursion control
10:45:42 <benmachine> looks like codepad sucks at packageimports
10:45:43 <ksf> i'd rather limit input length, but that doesn't close the door completely, as there's more than one way to get to the maximum input length
10:45:50 <cheater2> hahaha =)
10:46:33 <cheater2> BONUS: one thing i can't find anywhere online, and it might be cool to have it in an introductory tutorial, is to have a mention of the cool stuff where haskell was used
10:47:05 <BONUS> cheater2: hmm, that might be nice yeah. i think such a list is on haskell.org though
10:47:07 <cheater2> e.g. well known projects, big sites, governments using it for making our life better, ...
10:47:09 <BONUS> let me look it up for you
10:47:39 <cheater2> i've found *some* list but it doesn't go into detail why the stuff they mention is nice
10:48:00 <cheater2> it's just.. sort of.. a list.
10:48:15 <BONUS> this is pretty cool though: http://haskell.org/haskellwiki/Introduction#Does_anyone_use_functional_programming.3F
10:48:28 <kmc_> @where industry
10:48:29 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
10:48:33 <cheater2> for example, i was looking around trying to find out what the fastest computer or cluster of computers running a single app
10:48:33 <kmc_> cheater2: ^^^^
10:48:35 <cheater2> kmc: yeah
10:48:45 <kmc_> cheater2: also look up the slides from CUFP conferences
10:48:47 <kmc_> some good presentations
10:48:52 <cheater2> i've found it after bugging the hell out of this place ;)
10:48:53 <BONUS> also http://haskell.org/haskellwiki/Haskell_in_practice
10:49:18 <cheater2> so what *is* the fastest computer running a haskell app?
10:49:21 <kmc_> imo, the impressive uses of Haskell are not open source desktop apps
10:49:21 <cheater2> :)
10:49:38 <kmc_> they're mostly industrial domain specific languages and a lot of them don't get released publicly
10:49:54 <cheater2> it would still be good to have mentions of them if they exist
10:49:57 <benmachine> "Amoco subsequently transcribed the functional program into C++" -- they did *what*? :P
10:50:01 <cheater2> somewhere!
10:50:09 * ezyang winces 
10:50:13 <benmachine> xmonad's nice though
10:51:29 <benmachine> a complete windowmanager in less than 2500 lines of code says something about haskell's concision
10:52:29 <merijn> ezyang: All code is imperative eventually
10:52:48 <pikhq> merijn: That's not necessarily true.
10:53:00 <merijn> Be it compiling to assembly directly or via another imperative language is largely moot
10:53:08 <BONUS> what if you don't compile it
10:53:11 <pikhq> That our CPUs are imperative is a consequence of imperative programming's popularity a few decades ago.
10:53:33 <ezyang> merijn: I would like to disagree.
10:53:37 <pikhq> (of course, these days it doesn't matter what's popular, since CPUs are pretty distant from what's actually used.)
10:53:45 <ezyang> merijn: The paper I'm reading right now would also like to disagree with you :-)
10:53:46 <merijn> pikhq: True, but until someone invents something else it's rather silly to compile to anything else
10:53:54 <benmachine> logic would suggest that CPUs were developed before programming CPUs was developed
10:53:59 <pikhq> merijn: There exist Haskell machines.
10:54:16 <pikhq> They function via graph reduction.
10:54:17 <ezyang> The universe is not really imperative; it's something more like a giant propagation network.
10:54:25 <merijn> pikhq: Really? That'd be awesome, any links?
10:54:37 <domor> I need arbitrary precision reals. I see one library on hackage (AERN-Real), a few on the wiki, but is there a particularly blessed/good one?
10:54:39 <cheater2> i was wondering a week ago if there's a 'functional' cpu
10:54:40 <ezyang> I'd kind of like to know why we rallied around the von Neumann architecture though :-)
10:54:41 <merijn> I'm still lamenting the fact I never got the chance to work on a LispMachine
10:54:46 <cheater2> that doesn't use 'imperative' assembler
10:55:02 <merijn> cheater2: There were native lisp machines in Ye Olde Times of computer science
10:55:04 <ezyang> Probably because it was much easier and well understood :-)
10:55:12 <benmachine> @hoogle CReal
10:55:12 <lambdabot> No results found
10:55:14 <benmachine> wat
10:55:15 <kmc_> i think LISP machines are still quite imperative
10:55:22 <MissPiggy> lisp doesn't exist
10:55:23 <MissPiggy> it's a myth
10:55:23 <cheater2> merijn: i don't know what those do
10:55:35 <benmachine> :t showCReal
10:55:36 <lambdabot> Int -> CReal -> String
10:55:39 <domor> benmachine: I saw this one, but it's not on hackage
10:55:44 <kmc_> since much LISP code is quite imperative
10:55:48 <cheater2> haha, i didn't know that.. perl 6 is written in haskell!
10:55:48 <merijn> cheater2: The hardware is a lisp interpreter
10:56:00 <cheater2> merijn: i don't know lisp, that's the problem =)
10:56:02 <domor> benmachine: I'll give it a try then, thanks
10:56:04 <kmc_> cheater2: no, perl 6 is a language.  it's written in English, probably
10:56:12 <kmc_> pugs is one perl 6 interpreter; it's written in Haskell
10:56:13 <cheater2> kmc_: well, pugs is :)
10:56:16 <ksf> I guess we should get an extra executables section for hackage
10:56:17 <benmachine> domor: http://hackage.haskell.org/packages/archive/numbers/latest/doc/html/Data-Number-CReal.html#t:CReal
10:56:24 <cheater2> kmc_: i was making a funny :)
10:56:37 <merijn> kmc_: Well, I'll grant you Lisp is not as pure as all the people here always insist on. But its difficult to argue its not a functional language
10:56:40 <benmachine> is pugs finished?
10:56:55 <ezyang> Lisp is a language that tries not to get in your way
10:57:03 <kmc_> merijn: i personally take "functional language" to mean "has first-class functions".  so i'd say Lisp is a functional and imperative language, as is Haskell
10:57:18 <kmc_> Haskell is more of an imperative language than C++, because in Haskell imperative actions are first-class
10:57:25 <opqdonut> heh
10:57:37 <domor> benmachine: ahh great. I thought that CReal was related to FFI but it's not.
10:57:44 <kmc_> in C++ it's really tedious to abstract over imperative actions
10:58:01 <kmc_> domor: i think HERA is a newer library with the same features as CReal
10:58:10 <cheater2> what does it mean that 'imperative actions are first class'?
10:58:14 <kmc_> domor: what are you using these numbers for?
10:58:25 <pikhq> cheater2: They are values.
10:58:31 <kmc_> cheater2: imperative actions are values like any other.  you can pass them to functions, return them from functions, store them in data structures...
10:58:39 <merijn> I'm reading http://www.info.ucl.ac.be/~pvr/VanRoyChapter.pdf right now, very interesting discussion of programming paradigms and their interrelations, underlying concepts, etc
10:58:44 <cheater2> what is an imperative action?
10:58:50 <sbahra> <kmc_> they're mostly industrial domain specific languages and a lot of them don't get released publicly
10:58:53 <kmc_> cheater2: a sequence of steps to perform
10:58:56 <sbahra> kmc_, could you give me an example of such a DSL?
10:58:57 <cheater2> ok
10:58:57 <domor> kmc_: I want to port a toy pi calculating algorithm from Clojure to Haskell
10:59:19 <kmc_> sbahra: not of the ones not released... but look at atom or bluespec, or any of the financial modeling languages
10:59:28 <kmc_> afaik all are described on the "industry" page
10:59:47 <cheater2> kmc_: if you abstract away an imperative action, what are you left with? general program structure with 'blank spaces' for function calls and literals?
11:00:15 <kmc_> cheater2: a simple example is "forever"
11:00:16 <pikhq> cheater2: Are you familiar with Haskell's IO?
11:00:24 <kmc_> it's a function that takes an imperative action and returns another imperative action
11:00:32 <kmc_> in most languages it would be a "while" loop, which is magical built in syntax
11:00:41 <kmc_> in Haskell since actions are first class, it's an ordinary user-defined function
11:00:45 <kmc_> and a very simple one
11:00:45 <sbahra> Wow, industry section has been revamped since last year.
11:00:46 <kmc_> @src forever
11:00:46 <lambdabot> Source not found. Where did you learn to type?
11:00:50 <MissPiggy> ohhh nice explanation kmc
11:00:51 <kmc_> forever a = a >> forever a
11:01:25 <cheater2> pikhq: no.
11:01:27 <hzap> a haskell "IO a" is kinda like a function of type "() -> a" in other languages
11:01:39 <kmc_> kinda
11:01:43 <cheater2> kmc_: gotcha
11:01:45 <kmc_> cheater2: so we can define our own control flow structures
11:01:48 <jmcarthur> but with more type information
11:01:51 <kmc_> including domain specific ones
11:01:59 <cheater2> kmc_: so what i meant
11:02:04 <sbahra> http://www.londonhug.net/2008/08/11/video-paradise-a-dsel-for-derivatives-pricing/
11:02:06 <cheater2> great
11:02:18 <kmc_> which also subsumes Python's "with" statement, C++'s RAII, exception handling syntax...
11:02:24 <kmc_> all with ordinary functions
11:02:49 <kmc_> imperative programming in Haskell actually gets much more interesting from there, but i'll stop rambling ;)
11:02:59 <cheater2> i don't know how i could use python's with for what you are talking about
11:03:12 <cheater2> or, you mean that it's possible to define 'with' in haskell
11:03:16 <ben> It subsumes RAII?
11:03:23 <kmc_> cheater2: yes
11:03:26 <cheater2> ok
11:03:42 <ben> Does that mean I can stop using withFile and just create a file?
11:03:47 <ben> s/create/open/
11:03:57 <kmc_> ben: no, my point is that you can write things like withFile
11:04:08 <benmachine> withFile is said subsumption
11:04:20 <ben> I like RAII better :(
11:04:23 <kmc_> for example the Haskell OpenGL library has a function that takes an action consisting of OpenGL commands, and returns another action which does the same thing but also preserves the transformation matrix stack
11:04:32 <roconnor> @type withFile
11:04:33 <lambdabot> Not in scope: `withFile'
11:04:38 <kmc_> you can also send first-class actions between threads in a message channel, which is quite powerful
11:05:00 <kmc_> your threads don't need a protocol to communicate; their protocol is Haskell
11:05:01 <sbahra> "Our EC 561/2006 component is part of the IVU.crew software suite and as such is in wide-spread use all over Europe, both in planning and dispatch. So the next time you enter a regional bus, chances are that the drivers roster was checked by Haskell."
11:05:56 <kmc_> so yeah this is why functional programming and imperative programming are a logical fit for each other
11:05:56 <merijn> I swear, after like 15 minutes in this channel I always feel a lot less smart then I think I am before joining.
11:06:12 <MissPiggy> why not
11:06:15 <MissPiggy> PROCEDURAL?
11:06:21 <kmc_> the people who treat them as warring camps piss me off
11:06:24 <MissPiggy> what is 'imperative'
11:06:44 <kmc_> MissPiggy: sequence of steps which can interact with the outside world
11:06:45 <pikhq> Imperative is treating programs as a sequence of steps to do.
11:07:04 <HiPerPhreak> hi, i am trying to build cabal-install and I am really stuck. I get a lot of "undefined reference to" errors all regarding libHSnetwork-2.2.1.7.a, could anyone please help me?
11:07:05 <kmc_> although -- STM doesn't interact with the outside world, but i'd consider it imperative
11:07:08 <kmc_> not all monads are though
11:07:12 <luqui> kmc_, imperative programming is a stupid paradigm for jerks.  if you think imperative is not evil you must be a Bad Person.  %-)
11:07:17 <kmc_> luqui: ;)
11:07:18 <jmcarthur> merijn: unlearning is necessary before learning :)
11:07:39 * kmc_ hands merijn a bottle of Unlearning Potion
11:07:45 <kmc_> (hint: it's vodka)
11:07:51 * roconnor is confused by kmc_'d definition
11:07:53 <merijn> The paper I'm looking at actually argues "imperative" to mean functional with named state, in which case haskell can't do imperative since haskell can't do named state as far as I know
11:08:05 <MissPiggy> luqui sounds like you came from scheme :o
11:08:08 <kmc_> merijn: an IORef value is a name for some state
11:08:23 <kmc_> the value itself is immutable; it's the "tag" by which you access a mutable cell; the cell is not a value
11:08:27 <kmc_> that sounds like named state
11:08:34 <Cale> MissPiggy: "Procedural" usually refers to the idea that we should break programs into smaller separate procedures instead of a tangled mess, rather than the idea that programs are sequences of steps.
11:08:34 <MissPiggy> anti SET! people are mentalists..
11:09:00 <luqui> MissPiggy, actually i came from perl :-P.  but i am now a pure functionalist, and consider myself a Bad Person when I do imperative programming :-P
11:09:17 <jmcarthur> Cale: is "imperative" a reprequisite for that definition of "procedural"?
11:09:22 <jmcarthur> *prerequisite
11:09:36 <benmachine> HiPerPhreak: I probably can't help you but you stand a better chance if you give more detail
11:09:45 <Cale> jmcarthur: I don't think it is, but I'm not sure.
11:09:48 <merijn> kmc_: I might be wrong, I don't know enough haskell yet to be certain about anything. But every time I discuss something here I end up adding 5 papers to my to read stack and reading stuff rather then hacking :p
11:09:50 <ski> jmcarthur : if one squints, one can view Prolog as procedural
11:10:12 <benmachine> HiPerPhreak: what is your system setup, how far did you get in the installation process, etc.
11:10:22 <Cale> jmcarthur: Usually I think of procedures as being like effectful functions, but I'm not sure if I care so much that the definitions of everything line up so nicely, and there are other ways to describe effects :)
11:10:25 <kmc_> merijn: well i don't know how your paper defines "named state".  to me that sounds like something that's frequently used in Haskell
11:10:32 <ski> (but procedural with initialize-once variables, and backtracking)
11:10:41 <HiPerPhreak> I am calling runghc Setup build and get:
11:10:42 <HiPerPhreak> D:\Haskell\cabal-install-0.8.0>runghc Setup build
11:10:42 <HiPerPhreak> Preprocessing executables for cabal-install-0.8.0...
11:10:42 <HiPerPhreak> Building cabal-install-0.8.0...
11:10:42 <HiPerPhreak> Linking dist\build\cabal\cabal.exe ...
11:10:42 <HiPerPhreak> Warning: resolving _WSAGetLastError by linking to _WSAGetLastError@0
11:10:43 <HiPerPhreak> Use --enable-stdcall-fixup to disable these warnings
11:10:43 <HiPerPhreak> Use --disable-stdcall-fixup to disable these fixups
11:10:44 <HiPerPhreak> C:\Software\Haskell\network-2.2.1.7\ghc-6.12.1/libHSnetwork-2.2.1.7.a(Socket.o):fake:(.text+0x19): undefined reference t
11:10:44 <HiPerPhreak> o `ntohs'
11:10:47 <kmc_> @where paste
11:10:47 <lambdabot> http://hpaste.org/new
11:10:50 <jmcarthur> woah woah hpaste
11:10:54 <kmc_> or codepad.org if it's still down
11:11:00 <benmachine> or unsafecoerce.com
11:11:08 <kmc_> 500 err
11:11:10 <MissPiggy> I hate hpaste!!!!!!!!!!
11:11:17 <sbahra> If it's still down, I don't imagine it's of much use.
11:11:18 <MissPiggy> it doesn't have a good search facility
11:11:26 <ben> kmc_: Guess that is why it says unsafe
11:11:27 <benmachine> oh drat
11:11:43 <jmcarthur> MissPiggy: on google:     site:hpaste.org <query>
11:11:53 <kmc_> merijn: you don't need to know much to use IORef; see http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Data-IORef.html
11:12:06 <kmc_> we have some fancier reference cells for concurrent programming
11:12:12 <kmc_> if you're interested in that, see the last few chapters in RWH
11:12:30 <merijn> I sorta lost interest in RWH about half way in
11:12:37 <kmc_> then skip ahead :)
11:12:50 <HiPerPhreak> Ok, posted the whole output to http://codepad.org/sfnoqsJ6
11:13:38 <HiPerPhreak> (sorry for pasting the code in irc, I am a irc newbie :( )
11:14:14 <simplesimon2k>  /join #ghc
11:15:05 <Cale> HiPerPhreak: hmm
11:15:07 <ski> (.. there's also <http://paste.lisp.org/new>)
11:15:26 <HiPerPhreak> I am running Windows Server 2003 and Cygwin
11:16:06 <glguy> hpaste uses Takusen, and Takusen has some memory corruption bugs
11:16:28 <glguy> so it isn't "stable"
11:16:30 <Cale> glguy: That's unfortunate... how does that happen in a Haskell library?
11:16:47 <HiPerPhreak> installed latest version of mtl, parsec, zlib, HTTP and network (using runghc Setup ...)
11:16:49 <glguy> Cale, have you looked at Takusen's implementation? It isn't exactl Haskell 98
11:17:04 <Cale> glguy: I haven't looked at it at all
11:17:11 <glguy> It has to do lots of FFI
11:17:13 <jmcarthur> i think it uses some FFI
11:17:21 <kmc_> it talks to SQL databases
11:17:23 <Cale> HiPerPhreak: If you're on windows, why not just install the binary of cabal-install?
11:17:41 <jmcarthur> it's a shame because takusen is really quite neat
11:17:51 <glguy> it certainly is
11:18:09 <glguy> (both a shame and quite neat)
11:18:26 <HiPerPhreak> Cale: because it gave the "cabal: failed to parse output of 'ghc-pkg dump' " error
11:18:34 <glguy> When I tried the ODBC support it also has a data corruption bug
11:18:43 <glguy> had*
11:19:23 <HiPerPhreak> my path is set to "PATH=C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Software\Darcs;C:\Software\Haskell\bin;C:\ghc\bin;C:\cygwin\bin;C:\ghc\mingw\bin"
11:19:31 <Cale> HiPerPhreak: That sounds like something is wrong with your GHC install...
11:19:57 <Cale> HiPerPhreak: Though, I'm not on Windows, so I'm not sure.
11:20:24 <Cale> HiPerPhreak: There are binary versions of GHC and cabal install for Windows though. You shouldn't need cygwin.
11:20:39 <Cale> I haven't actually heard of many people trying to build GHC using cygwin.
11:20:46 <HiPerPhreak> I found this thread: http://stackoverflow.com/questions/1908333/getting-cabal-to-work-with-ghc-6-12-1 where the say "Currently latest version of cabal-install is 0.6.4, and it's not compatible with Cabal-1.8.0.2. The very soon coming version 0.7.x will support Cabal-1.8.0.2 and GHC 6.12.1. "
11:22:39 <nat`> Is anyone familiar with Graphics.Rendering.Chart?
11:24:06 <Cale> HiPerPhreak: Well, for now most people are using 6.10.4, but cabal-install 0.8.x is out already, and is compatible with Cabal 1.8.0.2 (even on GHC 6.10.4)
11:24:13 <c15c8ra1n> is it me, or do the haskell date/time types and functions kind of suck :(
11:24:28 <Cale> c15c8ra1n: Nah, they're rather good actually.
11:24:34 <Cale> c15c8ra1n: Which library are you using?
11:24:42 <c15c8ra1n> they're "politically correct"
11:24:48 <c15c8ra1n> uhm.. I have the haskell platform installed
11:24:57 <HiPerPhreak> where can I get cabal-install 0.8.x?
11:24:58 <Cale> Data.Time.* are the ones you want to be using.
11:25:12 <Cale> From hackage.
11:25:18 <c15c8ra1n> HiPerPhreak: yes, those are the ones
11:25:29 <Cale> Sorry, you get cabal-install from hackage :)
11:25:38 <Cale> The Data.Time.* library comes with GHC :)
11:25:59 <glguy> Data.Time is frustrating in most cases
11:26:36 <c15c8ra1n> what I'm trying to do is a showPrettyDate function that shows "today", or "3 hours ago"
11:26:50 <Cale> http://hackage.haskell.org/package/cabal-install
11:26:56 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.8.0/cabal-install-0.8.0.tar.gz
11:27:06 <int-e> c15c8ra1n: will it also print "once upon a time"? :)
11:27:10 <BONUS> where is mmorrow :(
11:27:31 <c15c8ra1n> but I keep getting deeper into the rabbit hole, UTCTime ~> DiffTime ~> Day, etc
11:27:48 <c15c8ra1n> int-e: that's not a bad idea for stuff older than 6 months :))
11:28:00 <pflanze> How do I convert an Int to an Integer?
11:28:06 <Cale> pflanze: fromIntegral
11:28:07 <BONUS> fromIntegral
11:28:10 <pflanze> thx
11:28:15 <int-e> @src fromIntegral
11:28:15 <lambdabot> fromIntegral = fromInteger . toInteger
11:28:17 <lpsmith> So I somebody convinced me to add  mergeLists :: (Ord a) => [[a]] -> [a]   that can merge a infinite list of infinite lists to data-ordlist.  I'm probably going to use an implementation based of a blogpost by Heinrich Apfelmus,  which is essentially a simplification of BayerPrimes
11:28:24 <ezyang> fromIntegral is a smidge more general than just that
11:28:45 <Cale> pflanze: 90% of all questions about "how do I convert numeric type X to numeric type Y" are answered by fromIntegral, and a further 9% are handled by realToFrac :)
11:29:10 <kmc_> :t fromRational
11:29:10 <lambdabot> forall a. (Fractional a) => Rational -> a
11:29:13 <int-e> ezyang: in what way?
11:29:17 <kmc_> :t realToFrac
11:29:18 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:29:31 <HiPerPhreak> Cale: That exactly what I downloaded. But when I try to run "runghc Setup build" I get the pasted errors
11:29:48 <Cale> HiPerPhreak: It looks like something is wrong with the network library
11:30:10 <Cale> Like, maybe it didn't link properly.
11:30:27 <lpsmith> So anyway,  I noticed some time ago that fold-left-ish implementations such as byorgey's http://byorgey.wordpress.com/2007/09/01/squarefree-numbers-in-haskell/   are significantly slower than right folds such as foldr (\(x:xs) ys -> x : merge xs ys) []
11:30:28 <ezyang> :t fromIntegral
11:30:29 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:30:46 <lpsmith> I thought I had figured out why,  but I went to check my work,  and found mistakes
11:31:12 <HiPerPhreak> Is there maybe somewhere a tutorial or some info how to get cabal-install running with ghc 6.12.1 on Windows?
11:31:15 <Cale> lpsmith: I know a couple reasons why.
11:31:26 <nat`> what is a PlotWindowType?
11:31:34 <lpsmith> Cale:  why's that?
11:32:22 <Cale> lpsmith: Well, for one, foldr f z applied to an empty list immediately passes control to f, and if it can produce a constructor without referring to its second parameter, the computation stops.
11:32:39 <HiPerPhreak> I start feeling quite dumb... I just want to get cabal-install working, nothing more...
11:32:43 <Cale> a nonempty list*
11:33:01 <Cale> HiPerPhreak: Does it have to be 6.12.1?
11:33:05 <cheater2> so is a monad basically an abstracted-away structure of a program in haskell?
11:33:20 <kmc_> no
11:33:26 <kmc_> a monad is a type constructor
11:33:29 <kmc_> like Maybe or IO
11:33:38 <lpsmith> Cale:  I hadn't considered that;   my argument was via counting the number of times an element is copied before it shows up in the final result
11:33:39 <Phyx-> HiPerPhreak: I could upload the version i compiled for you
11:33:40 <kmc_> a value of type (IO ()) is not called a "monad"
11:33:41 <Lycurgus> do a lot of people use windows?
11:33:42 <kmc_> IO itself is
11:33:50 <cheater2> mhm
11:33:59 <lpsmith> Only problem is,  I messed up the fold-leftish case
11:34:07 <MissPiggy> it's funnyy how people ask
11:34:10 <pikhq> If (IO ()) were a monad, then IO would be a monad transformer.
11:34:14 <HiPerPhreak> Phyx-: That would be great!
11:34:21 <MissPiggy> I've got an IO a  and I need a, and they never ask,  I've got an IO (IO a) and I need an IO a
11:34:22 <int-e>  (IO ()) is a monad action.
11:34:29 <kmc_> hah MissPiggy
11:34:32 <jmcarthur> pikhq: that would require that () be a monad
11:34:34 <int-e> @type join
11:34:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:34:36 <pikhq> Which would be... Bizarre. I'm not entirely sure of the consequences of that.
11:34:36 <HiPerPhreak> Cale: I don't know. The book "Real World Haskell" recommended to always download the latest version of ghc, so I did...
11:34:42 <pikhq> jmcarthur: Ah, right.
11:34:48 <kmc_> HiPerPhreak: i'd get the latest Haskell Platform
11:34:49 <lpsmith> (the number of times a given element is copied using the fold right is pretty straightforward:  it's just how far right the element is in the overall list)
11:34:50 <ben> If () took a type argument, it could easily be a monad :(
11:34:50 <kmc_> not the latest GHC itself
11:34:53 <Phyx-> HiPerPhreak: ok, one sec
11:34:56 <pikhq> jmcarthur: I doubt there's any sane instances of that. ;)
11:35:00 <ben> "Const ()" might be a monad
11:35:04 <jmcarthur> well the kind is wrong
11:35:06 <Cale> HiPerPhreak: Yeah, but 6.12.1 is out mainly as a service to library authors, so that they can prepare their libraries for the next release of HP
11:35:22 <MissPiggy> ben point less monad :P
11:35:38 <ben> It is a bit like the identity monad, I guess
11:35:43 <ben> except without the identity
11:35:54 <benmachine> heh
11:36:00 <kmc_> cheater2: it's hard to say what a value of a monadic type represents, in general.  each monad defines sort of a "computational world" with the ability to glue together computations and pipe output of one into another.  but really, i think it's best to avoid analogies regarding monads-in-general and just get comfortable with a few specific monads (and their specific analogies)
11:36:04 <benmachine> it is like the state monad without the state, too
11:36:08 <HiPerPhreak> Cale: Ah, ok, didn't know that. Where can I find such information? Or how can I find out what version is the right one for general development?
11:36:10 <ben> I suppose you could use it in order to be able to use do-notation to write evaluation strategies
11:36:12 <benmachine> well sort of
11:36:15 <int-e> ben: it's an all-consuming monad. at least with identity you get the values you put in back.
11:36:33 <ben> Like, for `par` or whatever
11:36:44 <Cale> HiPerPhreak: I thought there was a great big warning at the top of the 6.12.1 download page
11:36:46 <benmachine> HiPerPhreak: by hanging around here, mostly :P
11:36:57 <Cale> http://haskell.org/ghc/download_ghc_6_12_1.html "
11:36:57 <Cale> Stop!
11:36:57 <Cale> For most users, we recommend installing the Haskell Platform instead of GHC. The current Haskell Platform release includes GHC 6.10.4 as well as some other tools (such as cabal), and a larger set of libraries that are known to work together. This initial 6.12.1 release is aimed primarily at package maintainers and early adopters."
11:37:50 <cheater2> kmc: what if i want to write a monad of my own?
11:38:00 <Cale> Haskell Platform is more useful to install on Windows than on Linux.
11:38:11 <nat`> What does " No instance for (Fractional Int)" mean?
11:38:17 <kmc_> cheater2: do you mean, how would you learn how to do that?
11:38:17 <pikhq> cheater2: Well, what about it?
11:38:30 <lpsmith> cheater2, sure, go for it :)
11:38:34 <kmc_> cheater2: you'd learn how to do it by studying the implementation of a few monads, and reading about the monad laws
11:38:35 <pikhq> nat`: An Int is not a Fractional, and you're trying to treat it as such.
11:38:35 <int-e> nat`: you can't divide Ints using / ; maybe you meant div?
11:38:41 <lpsmith> instance Monad somthing where ....
11:38:43 <jmcarthur> cheater2: you can do it if you can prove it's a monad (not normally difficult)
11:38:43 <Cale> On Linux, you either want to use your distribution's packages (which will have been created with the help of the Haskell Platform stuff), or just install GHC and then cabal-install using the bootstrap script.
11:38:45 <pikhq> is the most likely cause of that, yes.
11:38:45 <int-e> @type (/)
11:38:46 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:38:56 <kmc_> a monad is just an ordinary algebraic data type which is an instance of an ordinary typeclass named Monad
11:39:00 <HiPerPhreak> Cale: hmmmmmm, thanks for the pointer
11:39:01 <c15c8ra1n> is there anything "standard" I can use to trace values?
11:39:10 <Cale> kmc_: That additionally satisfies some laws
11:39:10 <kmc_> c15c8ra1n: for debugging?
11:39:12 <kmc_> Debug.Trace
11:39:12 <c15c8ra1n> yes
11:39:20 <pikhq> c15c8ra1n: Debug.Trace
11:39:22 <jmcarthur> c15c8ra1n: Debug.Trace.trace
11:39:25 <cheater2> kmc: how do i prove that something is a monad?
11:39:27 <int-e> nat`: note the type of (/) - it demands that the type you use it with is an instance of Fractional. (I'm guessing that you used / because that's the most likely candidate)
11:39:31 <jmcarthur> :t Debug.Trace.trace
11:39:33 <lambdabot> forall a. String -> a -> a
11:39:33 <kmc_> cheater2: read about the monad laws
11:39:45 <ski> (kmc_ : it doesn't need to be an algebraic data type)
11:39:47 <Cale> cheater2: You check three laws, which can be written in a number of different forms
11:39:47 <cheater2> what are the monad laws?
11:39:52 <pikhq> Technically, it breaks referential transparency, but for debugging, it's just fine.
11:39:53 <lpsmith> cheater2,  have you ever done a few proofs in an abstract algebra course?
11:39:54 <c15c8ra1n> I made this, is it.. uhm.. sane?   a >>> b = (unsafePerformIO $ putStrLn $ show a) `seq` b
11:39:59 <kmc_> cheater2: you can google that
11:40:03 <cheater2> lpsmith: loads
11:40:04 <Phyx-> msys just took over my box
11:40:09 <cheater2> kmc: ok
11:40:11 <MissPiggy> c15c8ra1n?? lol
11:40:16 <Cale> cheater2: The most memorable way to understand the monad laws is in terms of an operation called Kleisli composition, written (<=<)
11:40:20 <merijn> Cale: It doesn't have to satisfy the laws to be a haskell monad. It's just that its a rather pointless thing if it doesn't
11:40:22 <kmc_> cheater2: the simplest way to state the laws is:  (<=<) is associative, and "return" is its identity
11:40:34 <int-e> cheater2: return >=> a = a >=> return = a and a >=> (b >=> c) = (a >=> b) >=> c
11:40:37 <Cale> merijn: It has to satisfy the laws to be a monad, but not to be an instance of Monad.
11:40:37 <jmcarthur> cheater2: expressed a bit differently than normal:  return <=< a  ==  a ; a <=< return  ==  a ; (a <=< b) <=< c  ==  a <=< (b <=<c)
11:40:38 <lpsmith> cheater2,  use the same approaches that you used to prove that X is a group to prove X is a monad works pretty well in most cases
11:40:39 <kmc_> however that's a bit indirect, since (<=<) is not directly a member of the Monad typeclass, but is defined in terms of >>=
11:40:58 <int-e> @quote fugue
11:40:58 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:40:59 <Cale> merijn: Libraries which are polymorphic over monads will function inconsistently if you don't satisfy the monad laws.
11:41:00 <kmc_> cheater2: http://haskell.org/haskellwiki/Monad_laws
11:41:03 <nat`> @type 1.0
11:41:04 <lambdabot> forall t. (Fractional t) => t
11:41:05 <c15c8ra1n> MissPiggy: I'll take that as a no then :(
11:41:06 <MissPiggy> I learned a new monad today
11:41:11 <pikhq> merijn: It doesn't have to, but it is a bug if it doesn't.
11:41:11 <MissPiggy> oh wait it wasn't a monad
11:41:15 <jmcarthur> kmc_: arguably, it's the Monad type class that is indirect
11:41:18 <int-e> nat`: ah, that would do it as well
11:41:24 <cheater2> so those are only two laws?
11:41:27 <MissPiggy> c15c8ra1n I think you implement Debug.Trace?
11:41:32 <jmcarthur> cheater2: it's three laws, but yeah
11:41:36 <Cale> cheater2: there are three
11:41:39 <kmc_> cheater2: two or three, depending on how you express them
11:41:48 <cheater2> i only see 'associative' and 'identity'
11:41:53 <jmcarthur> "return is an identity" is kind of like two laws
11:41:57 <kmc_> identity applies on the left and the right
11:42:02 <jmcarthur> since it has to be a right and left identity
11:42:08 <nat`> int-e: I'm not sure why I'm getting this error, I'm using FromIntegral everywhere I'm dividing
11:42:19 <MissPiggy> I learned a new category not a monad
11:42:48 <jmcarthur> MissPiggy: what was it?
11:42:54 <cheater2> what does it mean that 'return' is the identity?
11:43:00 <cheater2> how should i understand it?
11:43:00 <MissPiggy> (1) every poset is a category
11:43:02 <cheater2> can you give me some examples?
11:43:05 <MissPiggy> (2) category of posets
11:43:07 <Vitka> @pl unfoldr f (g x y)
11:43:07 <lambdabot> unfoldr f (g x y)
11:43:11 <jmcarthur> cheater2: return <=< a == a   and   a <=< return == a
11:43:20 <pikhq> c15c8ra1n: You probably shouldn't use (>>>) for that -- that's a function for Arrows. But yes, that is Debug.Trace.trace.
11:43:21 <kmc_> cheater2: look at the link i sent, it has examples in the "do" notation
11:43:23 <lpsmith> >   [2] >>= return
11:43:24 <lambdabot>   [2]
11:43:29 <kmc_> do { e }    ===   do { x <- e; return x }
11:43:30 <cheater2> jmcarthur: i know how to write it, but i don't understand it.
11:43:31 <lpsmith> >   [2,4,6,8] >>= return
11:43:32 <lambdabot>   [2,4,6,8]
11:43:37 <MissPiggy> @pl x y (unfoldr f g)
11:43:37 <lambdabot> x y (unfoldr f g)
11:43:41 <jmcarthur> cheater2: it means return doesn't change anything
11:43:53 <kmc_> similarly,    do { f x }   ===   do { y <- return x; f y }
11:44:01 <MissPiggy> it's a trip
11:44:08 <merijn> @type (<=<)
11:44:09 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
11:44:16 <cheater2> jmcarthur: i know what an identity is, but i don't understand how return can be 'an identity'
11:44:20 <HiPerPhreak> Cale: Thank your for you help!
11:44:26 <jmcarthur> cheater2: everybody is giving examples
11:44:33 <cheater2> i am looking through all that
11:44:41 <cheater2> it'll take me some time :-) just a sec
11:44:44 <int-e> cheater2: if you don't use Kleisli composition, the laws look less symmetric. f >>= return = f, return x >>= f = f x, and associativity is too ugly ;)
11:45:13 <MissPiggy> that's what I learned anyway
11:45:24 <MissPiggy> it's called Poset
11:45:34 <int-e> @type (>=>)
11:45:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:45:45 <int-e> @type (return >=>)
11:45:45 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> a -> m c
11:45:50 <int-e> @type (>=> return)
11:45:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> a -> m b
11:46:09 <nat`> I'm trying to make a chart of a bunch of doubles
11:46:55 <nat`> But plotWindow is giving telling me no instance for Fractional Int
11:47:00 <ski> MissPiggy : .. and each poset is a preorder (which is a category) :)
11:47:29 <monochrom> "no instance for Fractional Int" indicates you have some Int's you pretend are Double's.
11:47:58 <MissPiggy> a poset is a preorder which has also an extra property
11:48:07 <MissPiggy> I think the property is that  x < y and y < x ==> x = y
11:48:08 <roconnor> @fromIntegral fairy
11:48:08 <lambdabot> Unknown command, try @list
11:48:10 <MissPiggy> antisymmetry
11:48:24 <monochrom> replace < with <=, similarly >
11:48:24 <MissPiggy> preorder is equivalence relation without symmetry
11:48:36 <MissPiggy> oh yes thank you
11:49:05 <nat`> I'm not sure what I need to use fromIntegral on
11:49:07 <int-e> but ... it's true for < as well :)
11:49:24 <nat`> I try printing what I want to graph, and I see doubles
11:50:15 <Hunner> How slow is (!!)?
11:50:25 <roconnor> very
11:50:28 <ezyang> O(n)
11:50:33 <ski> Hunner : `xs !! n' is an `O(n)'-operation
11:50:36 <Hunner> Does the compiler still have to walk the list, or is it O(1)
11:50:38 <Hunner> thanks
11:50:50 <ezyang> Lists in many scripting languages are pretty bastardized
11:50:53 <nat`> @type length
11:50:54 <lambdabot> forall a. [a] -> Int
11:50:54 <int-e> it's O(1) if n is constant. *ducks*
11:50:56 <Hunner> how about take?
11:51:02 <Zao> If you want indexability, consider a map or an array.
11:51:04 <ezyang> int-e: Well, it's true :-)
11:51:10 <MissPiggy> the thing is when you say O(n)....
11:51:16 <benmachine> it's O(size of ram) which is O(1)
11:51:18 <jmcarthur> take is O(i) where i is the number of elements you are taking
11:51:19 <roconnor> take is lazy
11:51:24 <int-e> benmachine: not true
11:51:26 <MissPiggy> one length 10 list might take hours longer than another length 10 list
11:51:35 <int-e> > repeat 1 !! 10^9
11:51:36 <lambdabot>   1
11:51:38 <jmcarthur> assuming you evaluate the whole result
11:51:47 <benmachine> int-e: hmph.
11:51:50 <Hunner> Okay, so there are no O(1) ops for list access, and I should look for something else than a list?
11:51:56 <ski>   (!!) :: (n :: [a]) -> Int is O(n)  -- :)
11:51:57 <jmcarthur> yup
11:51:58 <benmachine> is infinity a constant factor
11:52:00 <ezyang> yes
11:52:01 <kmc_> like Data.Sequence
11:52:04 <roconnor> Hunner: Data.Sequence
11:52:06 <jmcarthur> Hunner: AI?
11:52:06 <int-e> benmachine: but the index is of type Int, so bounded.
11:52:07 <ezyang> benmachine: What cardinality? :-)
11:52:09 <Hunner> jmcarthur: ^^
11:52:13 <xerox> > repeat 1 !! (10^(10^10))
11:52:14 <lambdabot>   1
11:52:25 <MissPiggy> xerox wow!!
11:52:28 <jmcarthur> Hunner: you trying to do map access quickly or something?
11:52:32 <MissPiggy> > repeat 1 !! undefined
11:52:33 <lambdabot>   * Exception: Prelude.undefined
11:52:34 <Cale> cheater2: In terms of fmap, return, and join, the laws would be  join . return = id, join . fmap return = id, and join . join = join . fmap join
11:52:39 <Zao> xerox: Too bad !! uses Int.
11:52:39 <int-e> > (10^(10^10)) :: Int
11:52:40 <lambdabot>   0
11:52:42 <int-e> :)
11:52:43 <xerox> Zao he he.
11:52:43 * ski wonders whether there is any programming language that can express (and check) complexities like that, in the types
11:52:50 <MissPiggy> yikes
11:52:55 <jmcarthur> Hunner: i'm using IntMap IntSet to represent the locations of the walls in the map
11:53:04 <Hunner> jmcarthur: I need a function like `move :: [[Spot]] -> Spot -> move -> [[Spot]]` as far as I can tell
11:53:09 <ski> @type genericIndex  -- Zao
11:53:10 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
11:53:16 <pflanze> I'm going to combine a number of predicates that all apply to a given object; for example (x /= 'a') && (x /= 'b') && (not (isWhitespace x) etc.; (notIs 'a') && (notIs 'b') && (not isWhitespace)
11:53:39 <pflanze> eh, that shoul have been: I'd like to write something like  ((notIs 'a') && (notIs 'b') && (not isWhitespace) x)
11:53:42 <monochrom> xs!!n is O(n mod 2^64) = O(1)?
11:53:50 <Zao> ski: Known.
11:53:53 <ezyang> pflanze: You could use the reader monad for that
11:53:55 <nat`> Are there any other libs for making charts besides Graphics.Rendering.Chart?
11:53:55 <jmcarthur> Hunner: somebody else is using UArray for his map, i think
11:53:55 <cheater2> Cale: hm
11:54:14 <xerox> monochrom oh yeah!
11:54:16 <pflanze> k
11:54:16 <c15c8ra1n> how can I get an Integer from a Real ?
11:54:17 <jmcarthur> Hunner: what should that function do? insert a new wall?
11:54:31 <benmachine> c15c8ra1n: try floor/ceiling/round
11:54:32 <ezyang> @hoogle Real -> Integer
11:54:32 <kmc_> :t floor
11:54:33 <lambdabot> Warning: Unknown type Real
11:54:34 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:54:34 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
11:54:36 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:54:39 <kmc_> :t ceil
11:54:40 <lambdabot> Not in scope: `ceil'
11:54:42 <kmc_> :t round
11:54:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:54:52 <c15c8ra1n> benmachine: ok, thanks :)
11:54:57 <Hunner> jmcarthur: Spot is either Enemy or Player, and it returns a tronMap with a wall where they were and a player in the direction they moved... but that's probably really slow
11:55:08 <kmc_> @check \x -> round x `in` [floor x, ceiling x]
11:55:08 <lambdabot>   Parse error at "in`" (column 16)
11:55:09 <Cale> and in terms of return and (>>=), they become:  return v >>= f = f v,  x >>= return = x, and (x >>= f) >>= g = x >>= (\v -> f v >>= g)
11:55:42 <ski> @type liftM and (sequence [(/= 'a'),(/= 'b'),not . isSpace])  -- pflanze ?
11:55:42 <lambdabot> Char -> Bool
11:55:43 <jmcarthur> Hunner: i've been thinking about taking my code and making a starter package from it with some nicer data structures
11:56:03 <cheater2> i don't know what >>= is
11:56:08 <Cale> cheater2: okay
11:56:12 <Hunner> jmcarthur: :)
11:56:14 <jmcarthur> Hunner: i think you gave me the wrong type for the function you want, given what you just told me about Spot
11:56:33 <Cale> cheater2: Which definition of monad are you familiar with, if any?
11:56:34 <jmcarthur> Hunner: because surely there is not a player or enemy on every tile of the map
11:56:42 <cheater2> none
11:56:47 <Cale> cheater2: Ah, okay
11:56:54 <ski>   ma >>= amb = do a <- ma
11:56:55 <ski>                   amb a
11:57:13 <Hunner> jmcarthur: it finds their location using a modified version of `me`. I called mine `loc` and it takes a map and a player and returns (Int,Int) of where they are
11:57:13 <ski> cheater2 : that's what `(>>=)' does, in terms of `do'-notation
11:57:24 <kmc_> @undo do { x <- a; b }
11:57:24 <lambdabot> a >>= \ x -> b
11:57:41 <cheater2> define 'do notation'
11:57:50 <kmc_> it's part of the syntax of Haskell
11:58:06 <ski> cheater2 : `do'-notation is defined in terms of `(>>=)' ;)
11:58:16 <jmcarthur> Hunner: my representation is something like:  data GameState = GameState { myLoc :: Loc, oppLoc :: Loc, walls :: IntMap IntSet }
11:58:20 <Cale> cheater2: In the general picture that monads are different sorts of computations (where the word "computations" is intentionally vague), you think of x >>= f as being the computation which first "runs" the computation x, producing some result v, and then runs the computation f v
11:58:37 <jmcarthur> Hunner: and i have     type Loc = (Int, Int)
11:58:44 <Cale> cheater2: But what a "computation" is, and what it means to "run" one depends on the monad in question.
11:58:50 <cheater2> so >>= is the same as the bash | ?
11:58:55 <kmc_> sort of
11:58:59 <cheater2> ok
11:59:00 <Cale> cheater2: It's more like function application
11:59:01 <kmc_> it's also like ; in C
11:59:02 <jmcarthur> Hunner: means i can update player positions easily and i can add or query for walls in constant time
11:59:08 <Cale> >=> is more like bash's |
11:59:21 <djahandarie> >_>
11:59:29 <pikhq> Still, >>= is at least vaguely akin to |.
11:59:35 <monochrom> do { x ∈ getLine; ... }  monad is container :)
11:59:36 <Cale> (f >=> g) x = f x >>= g
11:59:41 * djahandarie kicks Cale's _|_
12:00:05 <cheater2> mhm
12:00:07 <Hunner> jmcarthur: sounds spiffy
12:00:25 * Hunner is learning so much about haskell from this thing
12:00:27 <Cale> cheater2: In the list monad, which is a good simple example...
12:00:30 <Cale> return v = [v]
12:00:39 <mat_p> Has anyone used distributed haskell? I was looking at erlang in comparision.
12:00:40 <Cale> and  x >>= f = concat (map f x)
12:01:02 <Cale> cheater2: This leads to the idea that "running" a list means to select an element from it, in all possible ways.
12:01:07 <Cale> So...
12:01:19 <Cale> > [1,2,3] >>= (\x -> [x,10*x])
12:01:20 <lambdabot>   [1,10,2,20,3,30]
12:01:34 <int-e> @type flip ((concat .) . map)
12:01:35 <lambdabot> forall a a1. [a1] -> (a1 -> [a]) -> [a]
12:01:39 <Cale> > do v <- [1,2,3]; [v,10*v]
12:01:40 <lambdabot>   [1,10,2,20,3,30]
12:01:59 <Dodek> hm, i'm trying to generate a random string, and the result is not so random
12:02:08 <cheater2> mhm
12:02:23 <Cale> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)
12:02:24 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
12:02:28 <Dodek> randomStr len = do g <- getStdGen
12:02:29 <Dodek>                    return (take len . map chr $ randomRs (ord 'a', ord 'z') g)
12:02:46 <Dodek> i get the same result every time
12:02:56 <kmc_> Dodek: because you're using the same generator over and over
12:02:58 <IceDane> Dodek: you need to update the generator each round
12:03:07 <kmc_> like every Haskell function, randomRs returns the same output for the same input
12:03:24 <cheater2> mhm
12:03:25 <roconnor> Dodek: use randomRIOs
12:03:27 <kmc_> take len $ mapM (getStdGen >>= randomRs (ord 'a', ord 'z'))
12:03:34 <kmc_> or what roconnor said
12:03:43 <cheater2> keep going cale
12:03:47 <jmcarthur> ?hackage MonadRandom
12:03:47 <lambdabot> http://hackage.haskell.org/package/MonadRandom
12:03:50 <monochrom> «map chr $ randomRs (ord 'a', ord 'z') g» = «randomRs ('a','z') g»
12:03:52 <jmcarthur> ^^ another possibility
12:03:56 <Cale> cheater2: In, say, the IO monad, 'running' a computation of type (IO t) means something much closer to the usual idea of running a program.
12:04:00 <roconnor> ya, MonadRadom would be even more generic
12:04:19 <monochrom> > randomRs ('a','z') (mkStdGen 4)
12:04:20 <lambdabot>   "ncofdtbklnjiakzzbvyybiyauhxpjlzsllkatswpizgfnlkosexxsrrptgbspaloezblbaihtc...
12:04:23 <monochrom> works
12:04:25 <Cale> cheater2: So, for example,  getLine >>= putStrLn  will be the IO action which gets a line of text from the user, and then prints it back at them
12:04:28 <roconnor> but if you are new to haskell, just use randomRIOs
12:04:46 <c15c8ra1n> floor (picosecondsToDiffTime 1000000000001) -> No instance for (RealFrac DiffTime) arising from a use of `floor'
12:04:47 <Cale> cheater2: and using do-notation, we could also write that  do v <- getLine; putStrLn v
12:04:49 <roconnor> no need to get too abstract too quickly
12:04:53 <Dodek> hm, randomRIOs?
12:05:01 <c15c8ra1n> soo.. DiffTime is only Real, and not RealFrac
12:05:03 <kmc_> picoseconds :O
12:05:03 <monochrom> @quote monochrom premature
12:05:03 <lambdabot> monochrom says: premature generality is the root of OOP
12:05:05 <c15c8ra1n> any suggestions? :(
12:05:10 <Dodek> there is randomRIO in documentation
12:05:12 <cheater2> cale mhm
12:05:16 <Dodek> but no mention about randmonRIOs
12:05:31 <jmcarthur> i disagree with that quote about premature generality
12:05:42 <jmcarthur> some kinds of generality are good even if you will only use it one way
12:06:08 <roconnor> aww, no randomRIOs :(
12:06:10 <c15c8ra1n> kmc_: that's just an example; I'm actually trying to get an integer out of a DiffTime
12:06:11 <Cale> cheater2: Or, if it's a parsing monad, x is a parser, and f is a function which takes the result of parsing the first part of the input, and produces a parser for the remainder of the input, then x >>= f is just what you need.
12:06:13 <monochrom> Then they are not so premature.
12:06:14 <kmc_> randomRsIO ?
12:06:17 <jmcarthur> for example, writing a function with the most polymorphic type possible lowers your input space, making it easier to focus on the implementation of the function
12:06:24 <kmc_> we have loads of premature generality in Haskell as well
12:06:28 <jmcarthur> *shrinks your input space
12:06:36 <kmc_> sometimes the cost is small
12:06:50 <kmc_> cheater2: you might like to read Typeclassopedia
12:07:06 <roconnor> Dodek: use randomRIO
12:07:11 <kmc_> which works up from very simple classes to Monad
12:07:16 <roconnor> @hoogle replicateM
12:07:16 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
12:07:16 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
12:07:26 <roconnor> Dodek: use randomRIO and replicateM
12:07:38 <Cale> cheater2: and in general, return v is the computation which "does nothing" and produces v as its result
12:07:49 <Cale> (whatever it means to do nothing in the given context)
12:07:52 <jmcarthur> it's easier for me to come up with a correct definition for something of type (b -> c) -> (a -> b) -> (a -> c) than something of type (Int -> Int) -> (Int -> Int) -> (Int -> Int)
12:07:52 <Dodek> ok, i already have a solution
12:07:53 <Dodek> randomRIOs r = getStdRandom split >>= (return . randomRs r)
12:07:53 <Dodek> randomStr len = do r <- randomRIOs ('a', 'z')
12:07:53 <Dodek>                    return (take len r)
12:08:02 <Dodek> thank you guys
12:08:22 <Cale> So, in the list monad, return v is the list [v] from which there's only one choice available, and it's just v.
12:08:25 <roconnor> Dodek: that works
12:08:40 <Cale> In the IO monad, return v is the no-op action which produces v as its result
12:08:57 <Cale> and in a parsing monad, return v is a parser which doesn't eat any of the input string, and produces the result v
12:08:59 <cheater2> mhm
12:09:08 <mypetclone> jmcarthur: And the fun thing about general types is that you don't have access to functions to generate some random value of type a, and thus often can't really screw things up.
12:09:18 <jmcarthur> mypetclone: exactly!
12:09:20 <mmaruseacph2> lambdabot, help
12:09:33 <mmaruseacph2> how do I search for the link for some book
12:09:37 <Cale> cheater2: The advantage to this approach is that there are useful functions which can be written to operate in an arbitrary monad.
12:09:48 <mmaruseacph2> I need the link to awodey's one
12:10:01 <Cale> (if we couldn't do this, then there would be no point in this abstraction)
12:10:02 <mmaruseacph2> @link awodey
12:10:02 <lambdabot> Maybe you meant: kind list ping
12:10:07 <Cale> @where awodey
12:10:07 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
12:10:13 <mmaruseacph2> thanks Cale
12:10:17 <mmaruseacph2> forgot the command
12:10:27 <Cale> mmaruseacph2: @where works just for things that people have put into it though
12:10:39 <mmaruseacph2> yup
12:10:48 <mmaruseacph2> but I knew that it was there
12:11:00 <Cale> cheater2: So, for example, there is the function  sequence :: (Monad m) => [m a] -> m [a]
12:11:01 <mmaruseacph2> because someone gave that link to someone else a couple weeks ago
12:11:04 <mmaruseacph2> back to reading
12:11:24 <Cale> cheater2: It takes a list of computations, and produces a computation which will run each in turn, producing a list of results.
12:11:42 <Cale> cheater2: In the list monad, this is (perhaps surprisingly, perhaps not) Cartesian product
12:11:49 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
12:11:49 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
12:12:08 <Cale> All ways of picking one element from each of the lists.
12:12:12 <MissPiggy> Cale is awodey difficult
12:12:27 <Cale> MissPiggy: It's probably the least difficult treatment of category theory you'll find.
12:12:46 <cheater2> kmc: thanks
12:13:42 <Cale> cheater2: In the IO monad, sequence applied to a list of actions will run each of them in turn -- a primordial sort of loop
12:13:43 <monochrom> jmcarthur: But do you write (Arrow p, Arrow p1, Arrow p2, Arrow p3, Arrow p4) => p1 (p b c) (p2 (p3 a b) (p4 a c)) ?  That would be premature generality.
12:13:55 <Cale> cheater2: and in a parsing monad, sequence gives the concatenation of parsers
12:13:56 <tromp> > sequence . words $ "foo bar baz"
12:13:57 <lambdabot>   ["fbb","fba","fbz","fab","faa","faz","frb","fra","frz","obb","oba","obz","o...
12:14:43 <Cale> cheater2: As you might imagine, in other monads it does something which is sensible, and related to the overall idea of running a bunch of things in sequence, but in a rather abstract way.
12:14:45 <jmcarthur> monochrom: Arrow is actually not all that general anyway. it's just obfuscation, IMO
12:15:04 <jmcarthur> but you do have a point
12:15:15 <Cale> Note that this has practically nothing to do with evaluation order, only an artificial sort of execution order which is encoded by the values in whatever monad you're using.
12:15:48 <Cale> (in the list monad, for instance, evaluation will move between the various lists -- first picking off one element from the head of each of them, and then backtracking)
12:16:05 <jmcarthur> the ordering is implied by the fact that monads are associative but not necessarily commutative
12:16:49 <cheater2> cale: i like the sequence thing
12:16:52 <roconnor> Cale: did you talk about the role of the empty list in the list monad yet?
12:17:00 <Cale> I didn't.
12:17:11 <Cale> cheater2: There's a whole library of useful functions which work in an arbitrary monad in Control.Monad
12:17:26 <Cale> cheater2: and of course, spread out throughout various other libraries
12:17:55 <Cale> (for example, I have an implementation of an A* search which works in an arbitrary monad)
12:18:05 <monochrom> jmcarthur: "premature" means no benefit here and now, only probable benefit in probable future. Suppose "b->c" brings you more benefit than "Int->Int" here and now. Then there is nothing premature about it. You have concrete benefits here and now.
12:18:08 <Cale> (though that would be sort of weird to use in some monads)
12:18:54 <jmcarthur> monochrom: okay, perhaps this is a case of myself accepting a more mainstream definition of premature in the context of programming than you are (where yours is more correct)
12:19:48 <Cale> A fun example is when xerox and I wrote an L-system drawing tool called nymphaea. If you're unfamiliar, L-systems are string rewriting systems. They consist of an initial string, and a collection of rules for rewriting the symbols of that string with other strings.
12:20:23 <Cale> We were playing around with nondeterministic L-systems, where the right hand side of any of the rules is a list of possible options for expanding the symbol.
12:20:32 <MissPiggy> can string rewriting systems do general computation
12:20:37 <xerox> (together with their probabilities)
12:20:58 <roconnor> MissPiggy: I believe so
12:21:19 <jmcarthur> Cale: i'm curious about this monadic A* you speak of
12:21:28 <jmcarthur> is the source public?
12:21:29 <Cale> jmcarthur: astar package on Hackage
12:21:34 <jmcarthur> sweet thanks
12:21:36 <copumpkin> @hackage astar
12:21:36 <lambdabot> http://hackage.haskell.org/package/astar
12:22:01 <Cale> jmcarthur: It's just the obvious monadisation of the pure algorithm.
12:22:09 <kmc_> MissPiggy: yes, http://en.wikipedia.org/wiki/Chomsky_hierarchy
12:22:09 <Cale> jmcarthur: Because someone requested it.
12:22:20 <Cale> anyway
12:22:20 <jmcarthur> Cale: cool!
12:22:26 <jmcarthur> i might have a use for it
12:22:31 <cheater2> i like nondeterministic programming :-)
12:22:55 <Cale> At first we had an algorithm for expanding nondeterministic L-systems in the list monad.
12:23:10 <Cale> But then we wanted to generate a random choice efficiently.
12:23:10 <roconnor> MissPiggy: also http://planetmath.org/encyclopedia/PostSystem.html might be helpful
12:23:24 <Cale> Generating a combinatorially large list of possibilities and then picking one at random is expensive
12:23:54 <Cale> So we just changed the monad we were using -- It turns out we didn't even have to change the code for expanding the L-systems
12:23:59 <Cale> Just the input to it :)
12:24:04 <cheater2> i find it's quite important to give nondeterministic programming, for example because it's difficult to figure out how to write a 'fully' random program.
12:24:09 <xerox> Cale high-five!
12:24:12 <cheater2> *give it a thought
12:24:29 <Cale> So instead of lists of options, the right hand side of each rule was a computation in a random generation monad.
12:25:06 <Cale> and of course, by picking the identity monad, you could get back to standard deterministic L-systems
12:25:19 <cheater2> mhm
12:26:19 <cheater2> can we look at some simple monad and prove that return is the neutral element?
12:26:22 <monochrom> presumably you can just plug LogicT and get some results
12:26:47 <Cale> cheater2: Sure, let's start with the list monad.
12:26:48 <xerox> MonadRandom was written for that purpose, I guess there was no LogicT around.
12:27:05 <Cale> return v >>= f
12:27:11 <Cale> = [v] >>= f
12:27:16 <Cale> = concat (map f [v])
12:27:17 <monochrom> combine LogicT and random monad :)
12:27:23 <Cale> = concat [f v]
12:27:31 <Cale> = f v
12:27:57 <Cale> so that's one half
12:28:07 <Cale> xs >>= return
12:29:10 <Cale> Oh, I suppose this one is a little bit trickier, but the idea is basically that  concat (map return xs)  will put each element of xs in a one element list, and then concatenate the resulting lists, so of course you get back xs again.
12:29:53 <Cale> (I'm sure you could do it by induction on the structure of xs, but I'm lazy :)
12:29:56 <adu> i'm confused
12:30:01 <MissPiggy> :t join . fmap return
12:30:02 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m a -> m a
12:30:12 <MissPiggy> me too
12:30:29 <jmcarthur> looks like a haddock bug: http://hackage.haskell.org/packages/archive/astar/0.2.1/doc/html/Data-Graph-AStar.html
12:30:46 <Cale> jmcarthur: yeah, there's an obvious haddock bug in it
12:30:49 <adu> isn't (return v >>= f) :: [typeof (f v)]
12:30:53 <jmcarthur> the parameters are no documented properly. the first one has the documentation for the second, and so on
12:31:03 <roconnor> [] >>= return   -->   concat (map return [])   -->  concat []   ---> []  && (x:xs) >>= return   --> concat (map return (x:xs))   ---> concat ([x] : map return xs) --->  [x]++(concat (map return xs)) ---> x:xs
12:31:12 <Cale> jmcarthur: Oh, that one is new
12:31:25 <MissPiggy> :t         []  &
12:31:26 <lambdabot> parse error (possibly incorrect indentation)
12:31:30 <MissPiggy> :t [] >>= return
12:31:31 <lambdabot> forall a. [a]
12:31:41 <Cale> jmcarthur: There's also the problem that it doesn't parenthesise the types correctly, somehow managing to delete some of the parens which are in the source.
12:32:06 <jmcarthur> yeah, but at least it uses new lines, which helps
12:33:04 <Cale> Haddock is surprisingly buggy for something so critical.
12:33:13 <jmcarthur> yeah :(
12:33:30 <monochrom> <troll> ever since it started using GHC API </troll>
12:34:28 <adu> isn't there 2 different forms? like "---" for docs before decls, and "--<" for decls before docs?
12:34:39 <jmcarthur> Cale: thanks for writing this. it'll save me a lot of trouble tonight
12:35:15 <HiPerPhreak> I have to ask for help once more: I want to follow the tutorial of Happstack (http://tutorial.happstack.com/tutorial/run-tutorial-locally) but I always get the same error as described in http://groups.google.com/group/happs/browse_thread/thread/7e86fc2f3535c9f0
12:35:34 <monochrom> "-- |" and "-- ^"
12:35:48 * adu is thinking of javadoc, sorry
12:36:17 <jmcarthur> that package is using them correctly though. it's a true haddock bug
12:36:47 <cheater2> cale: hm
12:36:47 <cheater2> mhm
12:38:45 <cheater2> Cale: so basically when you do return v >>= f 'in the list monad', then >>= signifies the monad?
12:39:20 <jmcarthur> >>= is simply the operation which forms the monad along with return
12:39:24 <MissPiggy> >>= signifies bind
12:39:43 <MissPiggy> like + signifies plus (rather than integers, or vectors or what have you)
12:40:24 <jmcarthur> cheater2: think of >>= and return forming a monad the way you might think of + and 0 forming a monoid
12:40:24 <kmc_> cheater2: the type of f will constrain the type of >>=
12:40:32 <kmc_> thus choosing which instance of Monad to use
12:40:32 <jmcarthur> or * and 1
12:40:33 <cheater2> so how do you do this 'in the list monad'?
12:40:43 <kmc_> the same way that in (a + b), the type of b (say, Integer) determines which (+) to use
12:40:48 <jmcarthur> "in the X monad" is loose terminology, honestly
12:42:18 <roconnor> 'in the list monad' means using intepreting >>= and return using the list instance of these overloaded operators
12:42:27 <roconnor> @instance Monad []
12:42:27 <lambdabot> Maybe you meant: instances instances-importing
12:42:42 <roconnor> @src (>>=) []
12:42:42 <lambdabot> Source not found. My mind is going. I can feel it.
12:42:46 <roconnor> @src [] (>>=)
12:42:46 <lambdabot> xs >>= f     = concatMap f xs
12:42:49 <roconnor> @src [] (return)
12:42:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:42:50 <MissPiggy> in the monad~ you can JOIN your fellow man .. ~
12:42:51 <aledge> @instances []
12:42:52 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
12:43:18 <roconnor> @src [] return
12:43:18 <lambdabot> return x    = [x]
12:43:34 <kmc_> cheater2:  (>>=) :: m a -> (a -> m b) -> m b.  so if, say,  f :: Int -> Maybe Char,   that type has to match (a -> m b), so m = Maybe, which tells the type system which Monad instance to use
12:43:57 <roconnor> @src Maybe (>>=)
12:43:58 <lambdabot> (Just x) >>= k      = k x
12:43:58 <lambdabot> Nothing  >>= _      = Nothing
12:44:02 <roconnor> @src Maybe return
12:44:02 <lambdabot> return              = Just
12:44:17 <mauro> hello?
12:44:19 <MissPiggy> @src Cont join
12:44:19 <lambdabot> Source not found. You speak an infinite deal of nothing
12:44:30 <mauro> i have a sql question
12:44:36 <MissPiggy> mauro what is it?
12:44:50 <cheater2> mhm
12:45:01 <medfly> WE ARE ALL READY
12:45:15 * kmc_ puts his SQL pants on
12:45:58 <gwern> launch query
12:46:01 <gwern> you know what you doing
12:46:21 <roconnor> @src join
12:46:22 <lambdabot> join x =  x >>= id
12:46:36 <MissPiggy> lol
12:46:45 <MissPiggy> @src Cont >>=
12:46:46 <lambdabot> Source not found. Sorry.
12:46:48 <MissPiggy> @src Cont (>>=)
12:46:49 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
12:47:05 * kmc_ rarely knows what he doing
12:47:16 <MissPiggy> @src runCont
12:47:16 <lambdabot> Source not found. Do you think like you type?
12:47:20 <MissPiggy> @pl \x -> (Cont $ \c -> runCont m $ \a -> runCont (id a) c)
12:47:20 <lambdabot> const (Cont (runCont m . flip runCont))
12:47:32 <medfly> actually looks better
12:47:52 <monochrom> newtype Cont r a = Cont { runCont :: (a->r)->r }
12:48:05 <mauro> ok, I have arround 10 rows that I would like to transpose. one column has a name, and the second column has some counts...so I would like to display it in 1 row and 10 columns. I m getting this ouput using INNER JOIN and LEFT JOIN. However one of the columns will have the SUM of all of them, but it is adding more than I am expecting
12:48:22 <mauke> mauro: how is that a haskell question?
12:48:29 <medfly> mauke, it's not
12:48:32 <mauro> it looks like that it is adding 10 times all the data
12:48:33 <monochrom> hehehehe
12:48:35 <MissPiggy> mauro that is way too confusing for me
12:48:47 <medfly> mauke, at least he is not complaining about C++
12:48:58 <MissPiggy> what has complaining about C++ got to do with C++??
12:49:09 <medfly> this is #haskell
12:49:12 <mauke> SQL doesn't offer any useful abstractions like classes or templates!
12:49:15 <kmc_> hahaha
12:49:50 <medfly> mauro, I'm an SQL noob but why aren't you doing those tow things separately, first transposing then summing?
12:49:54 <cheater2> Cale: that story about monads was interesting. thanks :-)
12:50:46 <kmc_> randomly choose large channel on freenode -> ask question
12:50:58 <mauro> medfly, I am doing it in once
12:51:13 <medfly> "do not want"
12:51:15 <monochrom> No no no. do { c <- channel; ask c question }
12:51:18 <mauke> SELECT channel FROM freenode WHERE users > 300
12:51:34 <kmc_> #haskell :: Chan MonadTutorial
12:51:54 <cheater2> SQL has a very useful thing called SQL Sentences
12:52:12 <aledge> mauro, probably get more help if you /join #sql
12:52:51 <mauro> let say, I hace 1 row of potatoes and 10 units, second row of lettuce and 5 units. I would like to display in one row: veggie 10 5 15(where 15 is the sum of all my veggies)
12:53:06 <MissPiggy> what's an SQL sentence?
12:53:14 <cheater2> google it
12:53:14 <mauke> mauro: this is #haskell
12:53:16 <cheater2> =)
12:53:17 <MissPiggy> mauro, is that gaussian elimination?
12:53:26 <RayNbow> kmc_: what kind of type constructor is Chan? :p also a monad? :p
12:53:55 <djahandarie> I seriously wonder how people mistakenly join the wrong channel and further more not realize they are in the wrong channel
12:53:58 <kmc_> no
12:54:04 <kmc_> it builds message channels
12:54:06 <monochrom> perhaps Control.Concurrent.Chan
12:54:18 <aledge> it's like mauro isn't even listneing
12:54:24 <lpsmith> Ok,  anybody have a suggestion for the name of a function that can merge a (possibly infinite) list of (possibly infinite) ordered lists?   merges, mergeAll,  mergeLists,  mergeInfs,  venturi?
12:54:33 <RayNbow> kmc_: is it at least a functor then?
12:54:51 <kmc_> actually, i was wondering if it has some functor-like structure.  you can't lift a function (a -> b) to (Chan a -> Chan b), but if the first function is an isomorphism then the second one exists and is an isomorphism too
12:55:06 <monochrom> lpsmith: "merge" is fine by me
12:55:10 <kmc_> i don't know what to call that kind of not-a-functor
12:55:16 <mauke> "pointer"
12:55:16 <Vitka> :t unfoldr
12:55:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:55:48 <medfly> why can't you do that to Chans, kmc_ ?
12:55:52 <lpsmith> monochrom, "merge" is already taken by :: Ord a => [a] -> [a] -> [a],    I'm implementing :: Ord a => [[a]] -> [a]  :-)
12:55:54 <medfly> I think you can
12:56:04 <monochrom> mergeAll then
12:56:19 <Zao> concat?
12:57:02 <MissPiggy> unfoldr is interesting
12:57:06 <kmc_> to turn a Chan a into a Chan b, you have to be able to convert b to a when you put stuff in, and a to b when you take it out
12:57:32 <monochrom> adjunction
12:57:47 <medfly> ??
12:58:01 <monochrom> .
12:58:08 <lpsmith> Zao:  nice idea,  but I'd prefer to avoid the name clash,  and this is conceptually a little different :)
12:58:27 <RayNbow> kmc_: ah, a Chan represents a two way communication?
12:58:32 <kmc_> one way
12:58:42 <mauke> kmc_: solution: split Chan in separate halves
12:58:44 <kmc_> well, many-to-one
12:58:53 <mauke> ReadEnd, WriteEnd
12:59:05 <kmc_> RayNbow: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Control-Concurrent-Chan.html
12:59:18 <kmc_> i guess it's even many-to-many
12:59:23 <kmc_> each written value will be read once
12:59:27 <kmc_> by one reader only
12:59:40 <mauke> hmm, WriteEnd seems to be a natural contrafunctor
12:59:44 <kmc_> (in the absence of "dupChan")
13:00:09 <RayNbow> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-Exponential.html#v:xmap ?
13:00:26 <kmc_> cool
13:00:36 <kmc_> looks like it
13:00:48 * RayNbow found that by typing in the type of xmap
13:00:56 <RayNbow> didn't know it something like xmap existed :p
13:01:39 <kmc_> if only the type were (g : a -> b) -> (h : b -> a) -> (forall x. h (g x) = x) -> f a -> f b
13:05:41 <MissPiggy> o_o
13:12:01 <gwern> where did Data.Data go in 6.12?
13:13:34 <monochrom> Data.Data is still in base.
13:14:19 <gwern> bloody packedstring and template-haskell
13:15:06 <monochrom> "My God, it's full of blood!"
13:15:35 <gwern> 'blood. the taste I hate.'
13:23:11 <lpsmith> heh, I was strugging with that exact same issue, gwern
13:23:17 <lpsmith> I haven't gotten to the bottom of it yet
13:23:54 <lpsmith> however,  if you unpack packstring and manually run runghc Setup.hs, it works fine
13:24:23 <lpsmith> I complained about cabal-install in the channel though;  I hope I didn't annoy Saizan!
13:26:46 <lpsmith> So,  is there a standard technique for tests for writing a cabal package using quickcheck (or another library(s)) without introducing dependencies for people who don't want to run the test suite?
13:34:27 <Hunner> @quote *****
13:34:27 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
13:34:39 <lispy> ?quote Hunner
13:34:39 <lambdabot> No quotes match. Sorry.
13:34:43 <lispy> ?quote
13:34:43 <lambdabot> sarehu says: <magnus_> are there any recommendations for module names? <sarehu> how about "Trogdorothy"
13:34:51 <Hunner> ?quote *****
13:34:51 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
13:34:59 <mauke> Hunner: no.
13:35:04 * Hunner wonders what that function that used just *'s was...
13:35:45 <lispy> ?quote \*\*\*\*\*
13:35:46 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
13:36:01 <mauke> :t (***)
13:36:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:36:19 <lispy> Oh, the pirate api
13:36:29 <lispy> It's full of arrs
13:36:38 <Hunner> :t (*****)
13:36:39 <lambdabot> Not in scope: `*****'
13:37:08 <Hunner> hmm. I remember someone made lambdabot evaluate a string that was different lengths of *'s, like ** and ****
13:37:18 <Hunner> s/string/function
13:37:30 <doserj> only (*), (**), and (***) are standard functions
13:37:44 <aledge> ?quote \**
13:37:45 <lambdabot> sorear says: We need to fork #haskell.  I can't read fast enough.
13:38:02 <aledge> ?quote \*\**
13:38:03 <lambdabot> ksf says: * lambdabot locks up ksf in a Monad <ksf> mmmmh it's warm and fuzzy in here.
13:38:03 <lispy> > forkIO #haskell
13:38:04 <lambdabot>   Not in scope: `forkIO'Not in scope: `haskell'Not in scope: `#'
13:38:09 <aledge> ?quote \*\*\**
13:38:10 <lambdabot> Lemmih says: <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
13:38:16 <aledge> ehh i give up
13:38:24 <aledge> ?quote \*\*\*\**
13:38:25 <lambdabot> lambdabot says: *** "Jezebel" hitchcock "Hitchcock's Bible Names Dictionary (late 1800's)": Jezebel, chaste
13:38:27 <aledge> ok one more
13:38:28 <aledge> haha
13:39:12 <jmcarthur> > unwords . map ('*' <$) . words $ "hunner look at this"
13:39:13 <lambdabot>   "****** **** ** ****"
13:39:45 <lispy> :t (<$)
13:39:46 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:40:10 <aledge> isn't that <$>
13:40:20 <aledge> oh no that's applicative?
13:40:23 <lispy> > 1 <$ (Just 2)
13:40:24 <lambdabot>   Just 1
13:40:26 <aledge> oh
13:40:31 <lispy> It replaces the contents of the functor
13:40:35 <aledge> oh i see
13:40:40 <lispy> > 1 <$ []
13:40:41 <lambdabot>   []
13:40:47 <copumpkin> in 6.12 <$> doesn't have to be from applicative
13:40:56 <lispy> > 1 <$ "hello"
13:40:56 <aledge> what is it in 6.12?
13:40:56 <lambdabot>   [1,1,1,1,1]
13:40:58 <copumpkin> for some reason there's a new Data.Functor that popped out of nowhere
13:41:06 <copumpkin> not sure why it's Data. and not Control.
13:41:23 <aledge> > let doink = <$
13:41:24 <lambdabot>   <no location info>: parse error on input `<$'
13:41:29 <aledge> > let doink = (<$)
13:41:30 <lambdabot>   not an expression: `let doink = (<$)'
13:41:33 <aledge> bah
13:41:45 <lispy> > let doink = (<$) in doink 1 "hello"
13:41:46 <lambdabot>   [1,1,1,1,1]
13:42:05 <aledge> isn't there a way to set the binding though
13:42:05 <lispy> > sum $ 1 <$ "hello"
13:42:06 <lambdabot>   5
13:42:13 <lispy> ?let
13:42:14 <lambdabot>  Defined.
13:42:18 <aledge> oh
13:42:49 <aledge> 1 `doink` "hello" is a funny string is all
13:42:50 <aledge> haha
13:43:40 <Gracenotes> hheelllloo
13:47:47 <Raynes> hi
13:50:06 <monochrom> Strange coincidence that both hpaste and moopatio are error 500.
13:51:14 <monochrom> It almost feels like haskell-cgi contains a time bomb. "go nuts when it's two days before St. Valentine's"
13:51:35 <lispy> I <3 happs?
13:51:41 <monochrom> or "a few days before Chinese New Year" :)
13:53:05 <sahazel> @src (<$)
13:53:06 <lambdabot> (<$) = (<$>) . const
13:53:12 <sahazel> @src (<$>)
13:53:12 <lambdabot> f <$> a = fmap f a
13:53:22 <sahazel> oh it's fmap
13:53:43 <sahazel> now I can stop writing `fmap` all the time
13:54:26 <monochrom> Yeah! Isn't Haskell exciting?
13:54:47 <aledge> > (+3) <$> [1..10]
13:54:48 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
13:54:51 <aledge> hooray!
13:54:52 <aledge> haha
13:55:10 <roconnor> > (+3) . [1..10]
13:55:11 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
13:55:17 <roconnor> caleskelll!!!
13:55:25 * sahazel <3s caleskell
13:55:34 <MissPiggy> noooooo
13:55:35 <c_wraith> > (+3) <$> (+5)
13:55:36 <lambdabot>   {-3->5;-2->6;-1->7;0->8;1->9;2->10;3->11}
13:55:51 <lpsmith> monochrom, yeah,  I tried emailing mmorrow about it;  moonpatio is his box, right?
13:55:53 <sahazel> whaaat?
13:55:58 <lpsmith> preflex, seen mmorrow
13:55:58 <preflex>  mmorrow was last seen on #ghc 25 days, 18 hours, 58 minutes and 13 seconds ago, saying: * mmorrow is rtfm'ing
13:56:00 <monochrom> I don't know.
13:56:07 <sahazel> what is that thing it printed for  (+3) <$> (+5)?
13:56:07 <lpsmith> hmm
13:56:15 <roconnor> > (+8)
13:56:16 <lambdabot>   {-3->5;-2->6;-1->7;0->8;1->9;2->10;3->11}
13:56:25 <MissPiggy> > (+)
13:56:26 <lambdabot>   -3->
13:56:26 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
13:56:26 <lambdabot>  -2->
13:56:26 <lambdabot>    {-3->-5;-2->...
13:56:35 <sahazel> what, it just uses some sample values?
13:56:36 <lispy> sahazel: it's a function so it prints some evaluations of it
13:56:39 <MissPiggy> yes
13:56:42 <ben> > show
13:56:42 <aledge> wait how do you compose a function with a list
13:56:43 <sahazel> nice
13:56:43 <lambdabot>   {()->"()"}
13:56:46 <aledge> my n00b is showing
13:56:50 <MissPiggy> my favorite is
13:56:50 <lispy> > fix
13:56:51 <ben> > show :: Int -> String
13:56:52 <lambdabot>   {-3->"-3";-2->"-2";-1->"-1";0->"0";1->"1";2->"2";3->"3"}
13:56:53 <lambdabot>   mueval-core: Time limit exceeded
13:56:55 <c_wraith> aledge: you don't, usually
13:57:00 <MissPiggy> > \(b :: Bool -> Bool) -> b . b . b
13:57:01 <c_wraith> :t (.) -- aledge
13:57:02 <lambdabot>   {True->True;False->True}->
13:57:02 <lambdabot>    {True->True;False->True}
13:57:02 <lambdabot>  {True->True;False->...
13:57:02 <sahazel> I guess it knows sample values for a few simple types?
13:57:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:57:08 <aledge> c_wraith, definitely not usually, but how does that typecheck?
13:57:11 <ben> sahazel: Well, quickcheck knows
13:57:12 <roconnor> aledge: don't worry.  It is only something that lambdabot does because Cale is evil.
13:57:14 <lispy> Why doesn't it work for fix? ;)
13:57:22 <sahazel> oh it uses quickcheck!
13:57:24 <sahazel> that's really cool
13:57:26 <lispy> sahazel: correct
13:57:26 <aledge> grrr
13:57:34 <lispy> > (==)
13:57:35 <lambdabot>   {()->{()->True}}
13:57:52 <Cale> I am not evil, and Caleskell doesn't exist. :)
13:57:57 <lispy> > (== :: Int -> Int -> Bool)
13:57:57 <lambdabot>   <no location info>: parse error on input `::'
13:58:04 <aledge> lies!
13:58:08 <lispy> (==) :: Int -> Int -> Bool
13:58:16 <lispy> > (==) :: Int -> Int -> Bool
13:58:17 <lambdabot>   -3->
13:58:17 <lambdabot>    {-3->True;-2->False;-1->False;0->False;1->False;2->False;3->False}
13:58:17 <lambdabot> ...
13:58:20 * lispy can't tye
13:58:21 <Cale> There are, however, a few extra definitions which I put into lambdabot.
13:58:24 <ben> > elem 42
13:58:25 <lambdabot>   []->
13:58:25 <lambdabot>    False
13:58:25 <lambdabot>  [-2]->
13:58:25 <lambdabot>    False
13:58:25 <lambdabot>  [-2,-1]->
13:58:27 <lambdabot> [4 @more lines]
13:58:39 <aledge> @src (.)
13:58:40 <lambdabot> (f . g) x = f (g x)
13:58:52 <aledge> oh well
13:58:56 <sahazel> lies
13:58:57 <MissPiggy> why doesn't lambdabot read @src from a wiki or sometihng
13:59:24 <Cale> MissPiggy: Because you didn't write a patch to make it do so.
13:59:30 <aledge> haha
13:59:39 <aledge> well played.
14:00:35 * MissPiggy thinks.. it might be an interesting experiment to write that and see if it gets put in... (currently I expect it would not)
14:01:12 <SubStack> hmatrix needs 3d transformation routines so I can swap out my GLmatrix code
14:01:15 * SubStack writes some of those
14:01:32 <Cale> MissPiggy: I could add it if you wrote the patch.
14:01:50 <monochrom> Cale is too modest when saying "I just added a few lines of code". I cite two historical precedences. We now attribute electromagnetism to Maxwell, but Maxwell could have said "I did nothing! I just took 3 existing laws and added one more line, hell the new line is just copied from one of the 3 laws except with two variables swapped." Going further back, there is Pell's equation, but Pell could have said "I did nothing! I didn'
14:01:50 <monochrom> t even write that letter, all I did was receiving it from Fermat."
14:02:04 * SubStack bases it on Data.Vec.LinAlg.Transform3D
14:02:41 <MissPiggy> Cale do you think it is a great idea?
14:03:21 <Cale> MissPiggy: Well, it's not terrible, though there would be potential for spam.
14:04:14 <lpsmith> So,  is there a standard technique for tests for writing a cabal package using quickcheck (or another library(s)) without introducing dependencies for people who don't want to run the test suite?
14:04:42 <kmc_> put the tests in another package?
14:05:39 <xerox> monochrom well said.
14:05:54 <monochrom> It becomes difficult when some tests are about unexported functions.
14:05:57 <Cale> Don't add the tests to cabal?
14:06:00 <Cale> oh
14:06:06 <Cale> yeah, I suppose that is difficult
14:06:06 <kmc_> hm
14:06:55 <monochrom> My first instinct: use lots of #ifdef's to delineate quickcheck calls.
14:06:55 <kmc_> yeah i wish there was some kind of "intrusive" import declaration
14:07:04 <Lemmih> lpsmith: You could use a configuration flag + CPP.
14:07:37 <lpsmith> hmm,  well
14:07:45 <sahazel> @pl \s z -> s . s $ z
14:07:45 <lambdabot> join (.)
14:07:53 <sahazel> @pl \s z -> s . s . s $ z
14:07:54 <lambdabot> ap (.) (join (.))
14:08:51 <lpsmith> The testsuite for NumberSieves isn't hooked into cabal,  just in the tests/ subdirectory.   There is no way to run it "automatically".   It also doesn't really use quickcheck,  because I can test much more accurately and efficiently in that case without it
14:09:12 <lpsmith> So what's the advantages of hooking it into cabal?
14:10:42 <lpsmith> (My test suite consists of finding the primes under 1,000,000 using O'Neill's sieve,  comparing that to the results of the factor sieve,  and then calculating euler's phi function using both the factor sieve and my phi sieve.
14:11:09 <lpsmith> oh,  and checking the prime factorization is actually a prime factorization
14:24:37 <MissPiggy> haskell can do this http://i11.tinypic.com/54ipno4.jpg
14:24:42 <MissPiggy> to you
14:26:31 <jmcarthur> hasn't done that to me yet
14:26:37 <jmcarthur> i'
14:26:40 <jmcarthur> oops
14:26:46 <jmcarthur> i'm still here
14:27:13 <jmcarthur> i should really just find a way to disable the enter key after i type a quote and reenable it after i type another character
14:27:24 <jmcarthur> i fat finger that way too often
14:27:54 <kmc_> use a different keyboard layout
14:28:13 <jmcarthur> that involves slowing me other projects down to learn a new layout
14:28:18 <jmcarthur> *my other
14:28:42 <kmc_> if you have other projects you want to work on, you will get up to speed quickly
14:29:36 <MissPiggy> kmc what do you use
14:29:40 <kmc_> i switched from qwerty to dvorak on a weekend that i had to write a 1000 word essay
14:29:56 <MissPiggy> I already did dvorak and colemak and it's like, now what?
14:29:58 <MissPiggy> what do I do now?
14:30:08 <kmc_> now you stick with dvorak because it's good enough and also comes with every OS
14:30:28 <MissPiggy> that's no fun :|
14:30:57 <OscarZ> heh.. is that dvorak a lot better than qwerty? are you able to switch easily between the two ?
14:31:11 <MissPiggy> yyeah it is loads better
14:31:16 <MissPiggy> so is colemak
14:31:23 <MissPiggy> I don't  like qwerty at all
14:31:32 <MissPiggy> but I want to learn a new one
14:32:51 <Summermute> Howdy, is there a decent GUI library for GHC that works well under both Windows and Linux???
14:33:09 <ezyang> gtk2hs seems to be a standard choice
14:33:56 <Summermute> cool. I'm a Haskell newbie (not developer newbie). Any idea what the install procedure and docs are like?
14:34:58 <ezyang> I haven't tried installing it on Windows. Probably look at http://www.haskell.org/gtk2hs/ ?
14:35:06 <kmc_> OscarZ: yes, and yes
14:35:33 <kmc_> OscarZ: dvorak is way more comfortable
14:36:02 <kmc_> it may be a little faster but that's more a matter of practice in any layout, and i don't think it's so important in any case.
14:36:10 <Summermute> I'll take a  peek. Pity it's not installed with the standard  GHC distribution - would make life easier
14:36:20 <kmc_> indeed, and it can't be installed via cabal-install eiteher
14:36:29 <ezyang> use yer package manager!
14:36:36 <MissPiggy> Summermute once you get cabal install then (usually) it's really really easy to install new stuff
14:36:51 <kmc_> it'd be bad for GHC or even Haskell Platform to have a dependency on GTK though
14:37:05 <MissPiggy> Summermute sometimes there is a pretty strange problem with it but #haskell people always are very nice and help me...
14:37:23 <kmc_> we're moving towards a world where GHC comes with only essential packages and Haskell Platform is the bigger "standard distribution"
14:37:43 <Summermute> "Haskel Platform" ?
14:37:48 <kmc_> @where platform
14:37:48 <lambdabot> http://hackage.haskell.org/platform/
14:37:56 <Summermute> Aha!
14:38:35 <Summermute> Yes, and I do need to learn cabal pronto to keep going with my Haskell studies
14:40:05 <Summermute> Haskell Platform looks very cool - I think I'll uninstall my current GHCI and install this on Win and Ubuntu instead
14:40:49 <osaunders> Does haskell-platform-2009.2.0.2-i386.dmg mean 2nd of Feb there?
14:41:08 <osaunders> I think it does.
14:41:15 * osaunders rubs hands together excitedly.
14:41:48 <osaunders> Oh wait.
14:41:52 <osaunders> 2009 is last year.
14:41:56 <osaunders> Epic fail.
14:42:26 <Summermute> For Platform, I'm looking at the packages. I see Win32 and OpenGL - but no x-platform or Unix specific GUI lib to "host" the OpenGL - what gives?
14:42:33 <Summermute> Or am I missing something??
14:42:42 <ezyang> Generally you ask for those from your package manager.
14:43:08 <ezyang> Since it's slightly tricky to compile everything together.
14:43:23 <Summermute> Then it's curious it automagically includes Win32 ???
14:43:35 <osaunders> Summermute: Win32 doesn't come with a package manager.
14:43:45 <osaunders> But I'm sure you knew that.
14:44:20 <Summermute> Platform, under "Packages and Docs" list "Win32" as an item. What am I not getting?
14:44:43 <osaunders> Summermute: What are you asking?
14:45:47 <Summermute> I'm just asking why Win32 is included as a "default" and not 1) something x-platform or 2) Win32 installed via cabal or whatever. Odd choice, I guess I'm saying.
14:46:14 <Zao> Summermute: Because it depends on it?
14:46:33 <osaunders> Summermute: Haskell Platform gives you GHC which is required for Cabal to work.
14:46:35 <Zao> Touch Win32 and you'll rebuild half the core packages. With tears.
14:47:09 <Summermute> Oh, I see. Win32 is needed for the Win32 distribution to compile the other "standard" libs???
14:47:30 <Zao> Basically.
14:47:46 <Summermute> I can see that - like Win's tcp and so on and so forth.
14:48:26 <Zao> Blargh. I keep hitting Mod-q every time I want to build my regular Haskell projects.
14:48:34 <Zao> I think I've been hitting the xmonad a bit too much recently.
14:49:31 <Summermute> So has anyone installed gtk2hs on top of Haskell Platform on both Win32 and Ubuntu (or some other Linux) before ?????
14:49:51 <Summermute> I mean, here, on the list. Looking for any experience reports.
14:49:53 <Zao> Summermute: I've tried building gtk2hs myself. It kind of didn't work in the end.
14:50:05 <Zao> Summermute: The binary installers from the gtk2hs site are solid, as long as you have the same GHC version.
14:50:26 <Zao> (on Windows all, that is)
14:50:26 <Summermute> That's kind of a big ouch!
14:50:28 * hackagebot upload: shoap 0.1 - A very basic SOAP package (RichardFergie)
14:50:48 <osaunders> Is the guy who wrote that binary DSL on channel?
14:51:06 <osaunders> It was on Haxx0rs news.
14:51:12 <Summermute> Is the FFI that fragile? Or is either the FFI or gtk2 that much of a moving target????
14:52:17 <ben> Is there an introduction to using opengl in gtk2hs
14:52:28 <jutaro> Summertime: Yes I installed on Ubuntu and Windows. But it is hard to compile on Windows. So better use an installer, but then you have to pick the fitting ghc version.
14:52:52 <Zao> Summermute: To build it on Windows, you need to have the whole msys shebang installed, I believe.
14:53:07 <Zao> Summermute: As well as all the GTK2 libraries built gtk2hs needs.
14:53:15 <Zao> Summermute: And have the right moon phase.
14:53:30 <Summermute> Aha. I have Mingw32, but I went with the IDE based install which is actually pretty slick and makes life very easy.
14:53:52 <c_wraith> well.  This is awesome.  persistent-map leaks memory all over the place.
14:54:06 <kmc_> OT, but has anyone worked Benjamin Pierce's Software Foundations exercises in Agda (instead of Coq)?
14:54:10 <ben> c_wraith: Persistent memory!
14:55:08 <ezyang> http://web.mit.edu/cesium/Public/trans.png
14:55:16 <kmc_> hahaha
14:55:18 <kmc_> brilliant
14:55:34 <gwern> kmc_: software foundations?
14:55:49 <kmc_> http://www.cis.upenn.edu/~bcpierce/sf/
14:56:09 <kmc_> it's a great introduction to Coq or to programming languages theory
14:56:13 <kmc_> (possibly both at the same time?)
14:56:14 <Summermute> Just by way of comparison, the fairly lovely Alice ML includes GTK with both the Linux and Win install. Same with wxWindows install along with PLT-Scheme on both Win32 and Linxux. (I'm trying to write a x-platform compiler, so this stuff matters to me)
14:56:59 <MissPiggy> alice ml is crazy
14:57:02 <MissPiggy> that's a cool language
14:57:20 <gwern> kmc_: easier or harder than TAPL?
14:57:47 <MissPiggy> it IS tapl
14:58:10 <gwern> > "SF" == "TAPL"
14:58:11 <lambdabot>   False
14:59:25 <osaunders> MissPiggy: Tried Befunge?
14:59:32 <MissPiggy> no
14:59:37 <MissPiggy> I know what it is though :P
15:00:11 <osaunders> A stack overflow in befunge: 1
15:00:13 <visualbasicgui> I got my wisdom teeth out today dear god
15:00:18 <visualbasicgui> I'm all drugged up
15:00:35 <gwern> visualbasicgui: you'll bleed for weeks
15:00:40 <visualbasicgui> yeah
15:00:46 <visualbasicgui> I realized this is what it feels like to be a zombie
15:00:50 <gwern> very true
15:00:52 <copumpkin> I wonder if vampires like getting their wisdom teeth taken out
15:00:59 <gwern> copumpkin: no one likes it
15:01:04 <copumpkin> but vampires like blood
15:01:05 <visualbasicgui> my dentist liked it
15:01:11 * gwern had teeth removed a few years ago
15:01:13 <visualbasicgui> bill was 1100 dollars lol
15:01:19 <copumpkin> wow, crazy
15:01:21 <MissPiggy> why don't people just keep wisdom teeth?
15:01:30 <copumpkin> mine hurt a little bit and then stopped, so I think I'm fine
15:01:35 <visualbasicgui> oh don't worry I've got them in a little box
15:01:40 <visualbasicgui> so there's no net loss of wisdom
15:01:55 <visualbasicgui> um
15:01:58 <visualbasicgui> I came here for a reason
15:02:05 <visualbasicgui> I'm also a little stoned :P but... um
15:02:06 <visualbasicgui> oh yes
15:02:11 <visualbasicgui> a date function in haskell
15:02:22 <visualbasicgui> can I fetch unix time somehow? Or can I get a date string?
15:02:28 <MissPiggy> well if I was you I'd try and fit them back in
15:02:31 <aavogt> look for Data.Time?
15:02:35 <visualbasicgui> maybe i've just got too many painkillers in me but google hasn't helped
15:02:46 <visualbasicgui> aavogt: mmmm good lead
15:03:04 <gwern> MissPiggy: if they don't fit in the jaw, it can mess you up later
15:03:16 <aavogt> anyways, it should come up in ghc's library documentation
15:03:33 * ddarius didn't even bleed a full day after getting his wisdom teeth out.
15:03:48 <osaunders> ddarius: Same here, just about.
15:03:53 <osaunders> Didn't hurt much either.
15:03:55 <gwern> ddarius: maybe you had easy ones
15:04:10 <gwern> (I had 4 out and it was quite a job, they were so rooted)
15:04:21 <visualbasicgui> yeah tbh I haven't bled much
15:04:23 <ddarius> gwern: No.  Not particularly hard ones, but one was around the nerve and according to the dentist, I was bleeding more than normal while he was operating.
15:04:23 <visualbasicgui> I'm just doped up
15:04:25 <visualbasicgui> no swelling
15:04:43 <visualbasicgui> they all came in and out cleanly and at right angles :P
15:04:50 <ddarius> osaunders: Yeah, I didn't take any pain medication whatsoever afterwards.
15:05:13 <osaunders> ddarius: I think some people are bleeders and some aren't.
15:05:18 <visualbasicgui> oh god i NEED my pain meds :P
15:05:22 <visualbasicgui> otherwise there's a bad headache, that's all
15:05:26 <Summermute> I was just ready to starting building my compier with Alice ML (love the lazy options and on and on with all its features) until I read that Alice ML would no longer be supported
15:05:41 <MissPiggy> what does supported mean?
15:05:48 <Kostafey> While using Data.Encoding.CP866 I need to set let ?enc = CP866 before every "do". Is it possible to set it to whole program?
15:06:11 <Summermute> The folks behind AliceML said that they we're focused on different projects now (funding?)
15:06:22 * Cale got 10 percocet when he had his wisdom teeth out. Mmmm... percocet.
15:06:28 <gwern> go not to academia for long-term support
15:06:55 <Cale> also, two shots of morphine
15:07:07 <Summermute> gwern: truer words never spoken. I love SML/NJ vs. Ocaml, but it looks fairly dead in the water :-(
15:07:37 <Cale> (I think there were complications taking mine out -- I bled fairly badly for a while after I got home)
15:07:54 <gwern> it's one of the biggest issues with being an academia-oriented community
15:08:08 <Summermute> Cale: Morphine is *pretty* heavy duty for wisdom teeth :-)
15:08:36 <MissPiggy> I don't really understand
15:08:37 <copumpkin> gwern: what is?
15:08:51 <MissPiggy> why can't you just use a language even if nobody maintains the implementation
15:09:05 <gwern> MissPiggy: hahaha. try that for a few years and get back to us
15:09:37 <kmc_> gwern: the early exercises are easier than most of the exercises in TaPL, because they're just introducing you to coq
15:09:39 <gwern> (why don't you try that philosophy with your car too? screw oil changes or fresh gas or air in your tires - just use it man)
15:09:41 <Summermute> Kind of a stupid q, but I want want to learn haskell 1) because it seems to becoming the lingua franca of type theory, but 2) I'm also presuming I can write robust, commercial grade software with it with long term "support". Am I delusional on the 2nd point or not?
15:09:59 <gwern> Summermute: what is 'support'?
15:10:06 <kmc_> @where industry
15:10:06 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
15:10:08 <kmc_> Summermute: ^^^^
15:10:17 <kmc_> you're not delusional, but it's still a rare thing to do
15:10:31 <Berengal> But not unheard of :)
15:10:39 <kmc_> there are some impressive success stories but not too many of them
15:10:46 <kmc_> i haven't heard any big failure stories
15:10:59 <kmc_> also there are probably more unannounced successes, e.g. from finance
15:11:01 <MissPiggy> gwern that sucks :/
15:11:06 <MissPiggy> computers should not be like cars
15:11:11 <gwern> and yet
15:11:24 <kmc_> gwern: i never had the motivation to do exercises while reading TaPL.  whereas Coq is a fun addictive puzzle game
15:11:24 <Cale> Summermute: You're not delusional, it should be possible, with the understanding that Haskell is probably going to change over time a bit more rapidly than most languages (at least we hope that it keeps changing)
15:11:39 <Cale> It's already suffering from overstandardisation, in my opinion :P
15:11:54 <MissPiggy> Cale what about new haskell dialects?
15:11:58 <gwern> MissPiggy: well, if you never want to change software or fix the bugs or add features or interoperate with anything else, then sure, just freeze on a particular version, maintenance is then irrelevant
15:11:59 <MissPiggy> is that agood thing
15:12:07 <kmc_> i think we should extend the language dramatically and also standardize each extension independently
15:12:09 <gwern> MissPiggy: you may find that you will want some of those things...
15:12:15 <lispy> Anyone know where http://darcs.haskell.org/takusen has moved?
15:12:18 <Cale> MissPiggy: I would consider it a good thing
15:12:28 <Summermute> Support means 1) an active core team that track *quickly* any serious bugs, os changes, required performance increases as application trends change (think GUI -> Web) and 2) an active community of folks who write high quality and long term supported libraries to support ever changing "required" functionality, like SOAP or XML-RPC or whatever crap happens to be "in fashion" at the time.
15:12:34 <kmc_> MissPiggy: i don't know of any very popular
15:12:38 <kmc_> Haskell dialects
15:12:39 <MissPiggy> Cale I was thinking about prototyping one but I couldn't find a good CHR implementation so I'm not sure what to do
15:12:44 <kmc_> unless you count each GHC extension as a dialect
15:12:44 <MissPiggy> like impleement it in prolog maybe
15:12:55 <Summermute> Python is slow as mollasses and is latently typed, but it pretty much fits the bill, just for example.
15:13:00 <kmc_> uh, Python is not slow
15:13:02 <kmc_> CPython is slow
15:13:04 <MissPiggy> (the type system in prolog, the rest of the language in haskell)
15:13:17 <kmc_> Python is a language, it has no speed
15:13:31 <Berengal> kmc_: Speed of inovation
15:13:36 <Summermute> kmc_: Um. ok.
15:13:44 <kmc_> woah, the Haskell wikipedia page shrank like crazy
15:13:55 <MissPiggy> Cale -- there should be a thingy for crazy ideas for haskell :p
15:13:59 <kmc_> guess they split it up
15:14:04 <MissPiggy> like what mad ideas someone came up with to change the language
15:14:38 <Cale> MissPiggy: A lot of those show up on the mailing lists, though admittedly, I am almost 10000 messages behind in the mailing lists.
15:15:03 <Cale> actually, over 10000, if you add them up
15:15:10 * MissPiggy doesn't even read mailing list
15:15:19 <osaunders> Cale: You're the most active IRC member though.
15:15:35 <osaunders> That's gotta be worth something.
15:15:39 <Berengal> Summermute: GHC is pretty well maintained, and there's lots of libraries on hackage. The smaller community means it's not quite at the level of python or java, but it's pretty liveable
15:15:40 <Cale> osaunders: Close to it anyway
15:16:28 <kmc_> i think Haskell's FFI is much nicer than Java's
15:16:56 <kmc_> not as simple as Python's ctypes, probably
15:17:09 <Berengal> Summermute: I've found plug'n'play libraries for almost all my needs on personal projects. I haven't had the chance to test it in a commercial setting yet, except for small one-off utilities
15:17:28 <Summermute> Berengal: I can live with a smaller community, but while i do read LTU religiously, I can't live with a language that's only the lang of choice for academic papers on type theory :-)
15:17:51 <Summermute> Berengal: That's very encouraging to hear.
15:17:57 <kmc_> Summermute: there are a lot of academic papers about practical aspects of Haskell
15:18:06 <kmc_> lots of impressive work on GHC's optimizations, for example
15:18:37 <lispy> I guess Takusen is missing at the moment, how unfortunate
15:22:16 <jutaro> Summertime: I would say you can write robust, commercial grade software in Haskell, but GUI libraries are a weak point. By the way the gtk2hs team works to make the next release installable with cabal.
15:22:50 <Summermute> kmc_: I hear you loud and clear! I'm super interested in type theory and compiler theory and pragmatics. Haskell here is "the man."  OTOH, I'm not in love with lazy by default, curried by default, and I *always* hope for a larger community of "pragmatists* no matter what language I choose (right now, I'm banging on problems with PLT Scheme (great libs, not so fast), gcc and nasm (for the low...
15:22:52 <Summermute> ...level stuff).
15:23:29 <kmc_> yeah, lazy by default is a big deal and has major drawbacks
15:23:38 <kmc_> i don't see the big deal about curried-by-default
15:23:42 <ddarius> Haskell isn't really "curried by default," except insofar as that is the convention and most of the libraries are that way.
15:23:50 <Summermute> jutaro: that's great to hear about the cabal install. I'm really not fond of mussing around with tools - never have been (and oddly, I've written a few compilers myself)
15:23:59 <MissPiggy> currying is awesome!
15:24:07 <MissPiggy> why would you not want it?
15:24:17 <kmc_> currying seems like one of those things which makes the theory nicer without making the practice harder
15:24:25 <kmc_> if anything, making the practice easier
15:24:35 <kmc_> it's very practical to map a partially-applied function over a list
15:24:55 <ddarius> Currying isn't really a "language feature."  If you have HOFs, you have currying.
15:25:10 <Summermute> ddarius: I did read SPJ's paper on how to efficiently handle curried functions when used higher order (map, fold) and he did mention that a good compiler should have a faster calling convention entry point when a "curried" function is called directly.
15:25:11 <jutaro> Summermute: Hope the long winter will soon end, and, yes: summertime
15:25:23 <kmc_> yeah, it's mostly an issue of whether the syntax for a curried or an uncurried function is simpler
15:25:54 <Summermute> MissPiggy: I actually  prefer just any partial application     foo (_, bar, 1, _, baz)
15:26:01 <ddarius> kmc_: They are about equal in Haskell and in the MLs'.  And ML's and Haskell syntaxes are pretty similar on this point, yet different conventions were chosen.
15:26:19 <MissPiggy> Summermute,  oh right
15:26:34 * ddarius dislikes these kind of "implicit" lambda constructs.
15:26:38 <MissPiggy> Summermute,  it's not kind of awkward when they don't have names?
15:26:46 <kmc_> Summermute: yeah, special care is needed to efficiently compile code which uses currying heavily
15:26:59 <kmc_> such code is much more common in Haskell because the syntax encourages it
15:27:53 <ddarius> kmc_: I would not say its the syntax.  The syntax for ML and Haskell are identical in this regard and yet such code is not very common in ML.
15:28:01 <Summermute> ddarius: yes, it  is just an implicit lambda construction, but man, it makes code easier to write and easier to read when one gets used to it - less boilerplate "noise" over these simple types of partial applications.
15:28:10 <kmc_> ddarius: so it's purely a community convention?
15:28:28 <MissPiggy> Summermute -- do you have an example script where this is used quite often?
15:28:36 <copumpkin> I want typelambda
15:28:37 <MissPiggy> just want to have a poke around and see what I think about it
15:28:43 <ddarius> kmc_: Not entirely.  You probably won't see too much of it in C#, but between ML and Haskell, yes.  Again, once you have HOFs, you have currying.
15:28:43 <MissPiggy> copumpkin - yeah me too
15:28:48 <MissPiggy> copumpkin - why do you wnat it? :P
15:28:52 <kmc_> yeah, i meant between ML and Haskell
15:29:21 <copumpkin> MissPiggy: I've had various things I've wanted it for in the past but can't think of much right now :P
15:29:24 <Summermute> MissPiggy: no I don't. I have random code fragemnts in my own language in a big 400 page pretty rambling design document / design diary / whatever
15:29:33 <kmc_> Summermute: yes, the implicit lambda holes are a nice feature.  in Haskell one must take care to order function args such that the likely-useful partial application goes left to right
15:29:36 <ddarius> Summermute: Such syntax quickly leads to ambiguity and is not very much clearer than an explicit lambda.  It is also more fragile, i.e. to refactorings.  Say you wanted foo (_, bar, 1, _, baz) but now you want to switch the arguments.
15:29:43 <kmc_> Data.Map often annoys me in this regard
15:29:47 <MissPiggy> Summermute yeah I would like to see that!
15:29:52 <kmc_> in cases where it doesn't go right, you can use a combinator like "flip"
15:29:56 <kmc_> but it's not ideal
15:30:11 <kmc_> we also have operator sections as a limited special case of the expression holes
15:31:09 * MissPiggy thinks it might be possible to write a function:   implicitLambda quote f x UNDERSCORE z w UNDERSCORE p
15:31:18 <MissPiggy> or roughly close to that anyway..
15:31:50 <Summermute> It's not really all that fancy or a "great' feature. To me it just makes sense. Dumb "textbook/paper" example is "incr x delta = x + delta;  incr2 = incr _ + 2;
15:32:31 <Summermute> so incr2 5; _:Int = 7 - Or something like that if there's a REPL
15:32:58 <ezyang> Currying higher order functions with higher order functions can get confusing quickly.
15:33:33 <MissPiggy> yeah it's just that the gut reaction on micro-examples like that is "but I'd just do <alternative>" -- it needs to be a bigger example to understand the real use I think
15:33:56 <ezyang> I use (+1) in Haskell /all the time/. It's such a convenient little piece of syntax.
15:34:01 <kmc_> in this case <alternative> is an operator section
15:34:09 <kmc_> which you can do even with things defined as normal prefix functions
15:34:09 <Summermute> ezyang: That's a good point. Using an underscore for an argument "wildcard" in an implicit lambda is certainly no more confusing than just eliding arguments from a curried function, particularly if it's a fun of many arguments. Hard to read.
15:34:15 <copumpkin> 1+ > +1
15:34:24 <ddarius> MissPiggy: Or illustrate the real issues...
15:34:30 <MissPiggy> ddarius yeah :)
15:34:31 * ddarius agrees with copumpkin 
15:34:35 <Cale> > compare "1+" "+1"
15:34:36 <lambdabot>   GT
15:34:43 <copumpkin> :D
15:34:43 <ezyang> bah commutativity :-)
15:34:55 <ddarius> ezyang: What commutativity?
15:34:56 <copumpkin> it'd be cool if we could tell haskell things are commutative
15:35:07 <ezyang> ==
15:35:26 <ddarius> But (+) isn't commutative without context.
15:35:39 <copumpkin> with my enumerable package you can verify that (1+) == (+1) for a given (finite) type
15:35:56 <damd> commutativity is the opiate of the people
15:36:19 <OscarZ> can you guys recommend a good book on type theory ?
15:36:37 <damd> TAPL
15:36:42 <ddarius> TAPL is the typical recommendation and it seems like a good, relatively CSy intro.
15:36:44 <Cale> OscarZ: Types and Programming Languages, Pierce
15:36:55 <OscarZ> thanks
15:37:06 <Summermute> damd: It sort of has an "isomorphism" with order of evaluation if the language is strict. I'd like a lang that defaulted to l->r evaluation unless told otherwise or vice versa
15:37:13 <MissPiggy> what do you mean by type theory
15:37:44 <damd> Summermute: you lost me at isomorphism
15:38:54 <Summermute> I'm tipsy - i probably used the wrong word :-)
15:38:57 <kmc_> OscarZ: TaPL, definitely, and also take a look at http://www.cis.upenn.edu/~bcpierce/sf/ (same author).  it covers some similar material while introducing you to a proof assistant program
15:39:18 <Summermute> I got a nice new copy of TAPL for Christmas from my father :-)
15:39:47 <damd> so commutativity is isomorphic with order of evaluation if the language is strict?  what does that mean?
15:40:01 <OscarZ> MissPiggy: well, someone mentioned it on the channel and ive just looked it up from wikipedia.. it sounds like the stuff im interested in
15:40:08 <kmc_> @where tapl
15:40:08 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
15:40:09 <MissPiggy> okay
15:40:14 <damd> i have a rough idea of what isomorphism means (newtype?)
15:40:27 <kmc_> damd: isomorphism in general means a function with an inverse
15:40:47 <kmc_> or perhaps a "structure-preserving" function with an inverse
15:41:06 <kmc_> what "structure-preserving" means depends on the particular thing you're talking about
15:41:18 <damd> i think i got it, but i don't believe you
15:41:34 <damd> aren't morphisms abstractions of functions?
15:41:37 <ddarius> Both of those are a specialized meaning of isomorphism.
15:41:54 <Summermute> Ok, I'm thinking that e(1) + e(2) is    plus(e1,e2) or thus plus(e2,e1). In a lang that defines order of eval for functions, commutativity would count for an optimizer. I think? :-)
15:41:56 * MissPiggy cannot think of a good example of isomorphism
15:42:07 <ddarius> MissPiggy: They are all over the place.
15:42:16 <ezyang> isomorphisms are great
15:42:20 <kmc_> damd: the word "morphism" from category theory is a sort of abstract function, yes
15:42:21 <ezyang> They make hard problems easy!
15:42:21 <Summermute> kmc_: yes, I meant "structurally simillar" that's all
15:42:29 <copumpkin> not necessarily a function
15:42:30 <kmc_> but "isomorphism" has a meaning in other areas of maths
15:42:36 <MissPiggy> what does iso- mean?
15:42:39 <kmc_> (which usually corresponds to the CT defn once you consider that area of maths to be a category)
15:42:44 <kmc_> iso- means "same"
15:42:47 <ddarius> MissPiggy: "equal" "identical"
15:43:03 <kmc_> 'iso- is a prefix from the Greek isos, meaning "equal."'
15:43:04 <MissPiggy> so what's the diffrence between morphism and homomorphism?
15:43:16 <Summermute> isnt' "iso" a latin prefix for "fits" and "morph" a latin root for "shape" ?
15:43:20 <kmc_> MissPiggy: the morphisms of the category Grp are homomorphisms
15:43:30 <MissPiggy> :(
15:43:33 <ddarius> Summermute: No.
15:43:40 <kmc_> the category Grp is the category whose objects are groups and whose morphisms are group homomorphisms
15:43:45 <copumpkin> Summermute: both greek
15:43:46 <kmc_> similarly you have monoid homomorphisms, etc
15:43:53 <copumpkin> not fits though
15:43:54 <copumpkin> equal
15:43:55 <Summermute> Ah greek, and I went to "Boys' Latin" school. I should have known better.
15:44:03 <MissPiggy> today I learned that each individual poset forms a category, and then I learned that posets as a collection form a category
15:44:09 <IceDane> Is the 'type' keyword in haskell only used for type synonyms?
15:44:15 <kmc_> yes
15:44:28 <kmc_> (and type synonym families / associated type synonyms)
15:44:32 <ddarius> MissPiggy: "Morphism" is an abstract term and doesn't really mean anything.  It's just a name for part of a structure.  "Homomorphism" is more specialized and is a algebraic structure-preserving function for various structures of abstract algebra.
15:44:36 <kmc_> (with GHC extension)
15:44:43 <MissPiggy> where poset means you have a reflexive, transitive, antisymmetric <= operation
15:45:13 <MissPiggy> so morphism is basically the same as map?
15:45:36 <notallama> as far as i can tell, "morphism" just means function. perhaps i'm missing something, though.
15:45:37 <ddarius> MissPiggy: No, "morphism" as a (mathematical, specifically CT) word, means nothing.
15:45:44 <copumpkin> morphism is just a concept in a category
15:45:54 <copumpkin> a directed edge in the induced grap
15:45:57 <MissPiggy> so it's like a set?
15:45:58 <Berengal> morph is greek for shape, is it not?
15:45:59 <Mitar> what is a nice way to map over a list but also have an index of the current element passed to a function you map with? I would like to make a mathematical sum operation over a list of values where function also needs to know index of the element
15:46:12 <MissPiggy> Mitar: you can first zip with [0..]
15:46:17 <ddarius> Berengal: More or less, yes.
15:46:24 <IceDane> Can someone (attempt to) explain how this works then? type SimpleState s a = s -> (a, s) Does that mean that SimpleState is just a synonym for a function that takes an s and return an (a, s) ?
15:46:33 <kmc_> MissPiggy: a category is made of "objects" and "morphisms".  those are just arbitrary names that you attach to the two sorts of things that make up a category
15:46:36 <copumpkin> IceDane: yeah
15:46:37 <ddarius> Mitar: Or just zipWith [0..]
15:46:38 <Summermute> hmmmm, there has to be a clear and deterministic answer regarding the meaning of "morph" - it's just used in way too many normal, everyday words alongside "technical" terminology
15:46:42 <kmc_> they are only really defined in terms of the laws a category must satisfy
15:47:02 <kmc_> IceDane: yes, every time you see (SimpleState s a) you can substitute (s -> (a, s)) as if it were a simple text-substitution macro
15:47:05 <kmc_> (mostly?)
15:47:07 <ddarius> Summermute: As a suffix, there is.  It is as Berengal said, it means "form" or "shape"
15:47:11 <MissPiggy> what about homsets
15:47:11 <IceDane> kmc_: I see..
15:47:16 <Mitar> ok, that was also my idea ... i thought there is also something else
15:47:17 <Mitar> ok
15:47:42 <eflister> hey - i'm on osx and have ghc installed via macports, but it only has 6.10.4.  i wanted to try some things in 6.12, so i downloaded and installed that.  i have cabal but don't know how to direct it to install packages to my 6.12 install rather than 6.10.  i tried running 6.12 with the -i option pointed to my 6.10's lib dir but that didn't work.  hint?
15:47:48 <kmc_> each morphism has a "type signature" of the form A -> B, where A and B are "objects"
15:47:50 <ddarius> MissPiggy: Homsets are sets of morphisms between objects.  Which is to say, they are sets of thingies between other thingies for some (given, but variable) thingies.
15:47:55 <kmc_> Hom(A, B) is the set of morphisms with the signature A -> B
15:48:02 <ddarius> MissPiggy: Homsets are what really hold the structure of a category.
15:48:27 <MissPiggy> so category theory is basically about stuff?
15:48:28 <kmc_> categories are about morphisms; the "objects" (types) just classify which morphisms can be combined and how
15:48:41 <ddarius> MissPiggy: They can be sets of frogs between princesses as long as you can make the laws hold.
15:48:48 <IceDane> MissPiggy: that is the impression I got as well when I read about it as well
15:48:57 <kmc_> and the point of CT is to consider morphisms abstractly, without the idea that they are functions which can be applied to arguments
15:48:57 <IceDane> I understood nothing, but that's the way it seemed
15:49:01 <kmc_> you compose but do not apply them
15:49:10 <Berengal> MissPiggy: The mathematical model for things and things inbetween things
15:49:42 <Berengal> With types
15:49:47 <MissPiggy> the main thing I am seeing come up is that you define some structure X[p] on something p, then you define a new structure X[X[p]]
15:49:56 <ddarius> MissPiggy: It's like when you talk about a group, say.  When you are talking about group theory in general, the elements of the group aren't any particular thing.
15:50:01 <MissPiggy> that's not a really good description but hopefully it makes sense
15:50:07 <eflister> anyone can hint me on my 6.12/6.10 question up there?
15:52:05 <Berengal> eflister: cabal just looks in the path for the ghc binaries I think
15:52:30 <eflister> yeah, my old 6.10 is the one it will see -- no way to direct it to install tomy new 6.12 without changing my path?
15:52:50 <Berengal> eflister: And also, haskell objects are only compatible with the exact compiler version they were built on
15:53:16 <eflister> Berengal: yeah i was worried about that.  not even worth trying the old lib dir then?  :)
15:53:22 <eflister> Berengal: it's just for mtl...
15:54:03 <OscarZ> is Int -> Int a morphism .. or what ?
15:54:08 <Berengal> eflister: using "cabal install" you can use the -w flag to set the compiler. See cabal install --help for more info (and the cabal user manual)
15:54:20 <doserj> OscarZ: it is a type
15:54:42 <Berengal> eflister: But you want to point cabal to a different .cabal directory. You don't want to mix your 6.10 packages with your 6.12 packages
15:54:45 <eflister> Berengal: i saw that option, but figured it would only choose the compiler, not the dir where the package would be installed.  does it do both?
15:54:50 <OscarZ> ok.. how does morphism relate to a type ?
15:54:51 <copumpkin> OscarZ: a value of that type would be a morphism
15:55:01 <ddarius> OscarZ: A value of type Int -> Int is a morphism in a category that has such things as morphisms.
15:55:12 <Berengal> eflister: The .cabal/config file holds the install dirs and other configuration options
15:55:23 <copumpkin> OscarZ: that type is an object in the category (and is an exponential object if you squint)
15:55:36 <OscarZ> so some function that has type Int -> Int is a morphism ?
15:55:41 <doserj> eflister: the point is not the dir where the package is installed, but the pkg database where it is registered
15:55:47 <ddarius> OscarZ: In a particular category.
15:56:00 <copumpkin> in haskell's pet category
15:56:00 <osaunders> In a category of functions?
15:56:25 <copumpkin> @quote moarphisms
15:56:26 <lambdabot> tensorpudding says: lolcategory demands moarphisms
15:56:29 <Berengal> osaunders: If objects are types, functions are morphisms between them
15:56:35 <ddarius> osaunders: In some suitable category, a category of Haskell functions and Haskell types would do.
15:56:53 <MissPiggy> an omega-CPO?
15:57:25 <ddarius> MissPiggy: You could use that category if you like.
15:57:29 <eflister> Berengal: i was looking at that too but it seemed to have too many dirs to configure (lib,libsub,libexec,data,datasub,etc).  can i have a .cabal.6.12 next to my old .cabal?
15:58:19 <Berengal> eflister: Should be possible, but I'm not sure how. You'll have to rtfm I'm afraid
15:58:43 <Berengal> eflister: though switching dirs should just be a matter of setting the $prefix dir
15:58:46 <eflister> Berengal: and is there any way to have cabal make a .cabal.6.12 with the appropriate config?  ok thx -- if anyone else knows, please chime in :)
16:00:31 <OscarZ> associativity seems to pop up everywhere in this stuff... why is it such an important concept?
16:00:39 <Saizan> eflister: you're worrying too much :)
16:00:52 <OscarZ> it seems so trivial
16:00:57 <ddarius> OscarZ: It is.
16:01:02 <Saizan> eflister: libsubdir: $pkgid/$compiler <- the library files are already in a distinct directory for each compiler
16:01:16 <Berengal> OscarZ: Just because it's trivial doesn't mean it's not important. Food is trivial :)
16:01:35 <Berengal> Saizan: Is ghc-6.12 different enough?
16:01:44 <Saizan> eflister: i.e. you don't have to do anything to keep libraries for multiple versions of ghc installed
16:02:00 <Berengal> Seems like it is
16:02:06 <eflister> Saizan: oh cool -- thx.  so i just tell cabal to use 6.12 and it handles the rest?
16:02:12 <Saizan> Berengal: $compiler includes the version, if that's what you're asking
16:02:12 <ddarius> OscarZ: Associativity is what you add when you want "lists" or "chains" or "sequences" of things.
16:02:23 <Berengal> Saizan: Indeed it was
16:02:33 <Saizan> eflister: yeah, just pass it -w ghc-6.12.1
16:02:47 <ddarius> OscarZ: The free algebraic data structure generated from an associative, binary operator is a (non-empty) list.
16:03:13 <OscarZ> Berengal: that's true :) I just ment that its hard to see why its so important because of its apparent simplicity
16:03:38 <Berengal> OscarZ: Not uncommon
16:03:46 <ddarius> OscarZ: If you drop associativity, you get a binary tree.
16:03:52 <ddarius> (non-empty)
16:04:15 <OscarZ> interesting.. are these kind of topics discussed in "type theory" ?
16:04:24 <ddarius> Not really.
16:04:44 <Berengal> Type theory is more about logic, isn't it?
16:05:48 <OscarZ> ddarius: I guess i dont really understand whats a list.. i understand it as an ordered list of objects
16:06:14 <Veinor> http://web.mit.edu/cesium/Public/trans.png
16:06:23 <MissPiggy> how do you generate the free algebraic data structures?
16:06:36 <OscarZ> without understanding how associativity relates to that
16:06:42 <ddarius> OscarZ: I'm pretty confident you understand what a list is.  The intuitive notion is adequate for this.
16:07:11 <ddarius> MissPiggy: Define "generate."  Or are you asking me what I mean by "generate"?
16:07:33 <MissPiggy> well I think this is probably a theorem in universal algebra?
16:07:42 <MissPiggy> that you can freely generate stuff
16:07:54 <Summermute> It seems packages are super sensitive to compiler version. If a whole linux distribution can be source-> compile based and still *convenient* and *reliable*, then why not with GHC?
16:08:11 <Summermute> Is it just a LOE and person hours issue?
16:09:42 <Saizan> there are both API and ABI incompatibilities
16:10:00 <doserj> MissPiggy: you take the set of all terms, modulo the equivalence relation generated by the algebraic laws you want
16:10:37 <Saizan> also the metadata in .hi files often changes between ghc versions too
16:11:05 <Summermute> Saizan: API meaning language features, "base" library function signatures and data type definitions - or both?
16:11:08 <eflister> Saizan: i get 'cabal: failed to parse output of 'ghc-pkg dump''
16:11:21 <Saizan> eflister: you need a newer cabal-install
16:11:34 <Saizan> Summermute: more like the latter
16:11:37 <OscarZ> ddarius: why do i need associativity to have lists or chains or sequences ? i seem to be able to grasp these concepts without understanding why associativity has to come in ?
16:12:15 <Summermute> I must say, that's a real pity. Hate to bring up something lame like C, but if stdlib changed all the time, we'd all be SOL !
16:12:15 <doserj> mathematics has no grasp of these concepts unless you define it
16:12:28 <ddarius> OscarZ: Associativity -leads to- list-like things.  And lists are what you get if all you assume is that you have an associative, binary operation.
16:12:36 <OscarZ> is it related to how the order of the list is defined ?
16:12:37 <newsham> conal around?
16:12:46 <conal> newsham: yep
16:12:53 <doserj> OscarZ: and of course you can define lists without the need to refer to associativity
16:12:59 <MissPiggy> how can you make programs out of this?
16:13:02 <newsham> conal: I dropped you mail yesterday or the day before.  my email address often gets me in spam boxes
16:13:05 * ezyang is reminded of the foldr/foldl considered slightly harmful presentation 
16:13:06 <newsham> just wanted to check to see i fyou got
16:13:06 <Saizan> eflister: if you still have a ghc-6.10 around you can cabal install -w ghc-6.10.x "cabal-install >= 0.8.0"
16:13:30 <Berengal> Summermute: Haskell's still at a point where a changing api isn't too painful, and it's better to change the API than be left with something like Java's arrays
16:13:52 <conal> newsham: i don't think i got your note :(
16:14:03 <newsham> woulda been from newsham@lava.net.
16:14:05 <newsham> *sigh* oh well
16:14:16 <Saizan> Summermute: base doesn't change _so_ much, now that it's much smaller at least
16:14:23 <Summermute> Are there any languages similar to Haskel where "the language" is NOT the feature, but is fairly stable (over many,  many years at least) but there IS an intense focus on tools, efficiency, accumulation of libraries and on and on?
16:14:28 <MissPiggy> it is just magic coincidence that you can actually /define/ data List a = ...?
16:14:40 <ddarius> Summermute: No.
16:14:46 <MissPiggy> or can you make data types in general?
16:14:46 <Berengal> Summermute: Also, since most things are open-source, and there's a central package repository, any breakages are quickly fixed and distributed
16:15:05 <Summermute> Berengal: that's encouraging
16:15:09 <conal> newsham: i just searched & didn't find a note.
16:15:27 <newsham> conal: just wanted to say that your idea to use integration as a way to access past history reminds me a lot of control theory and signals and systems.  where in discrete time you use a single time unit delay as a building block
16:15:32 <Summermute> ddarius: victim of research funded languages? :-)
16:15:45 <newsham> and that it seems to me what you're doing (maybe without knowing it) is making memory explicit, which would be good for reasoning about it
16:16:11 <conal> newsham: "making memory explicit" sounds right to me.
16:16:48 <Mitar> if i have a list of pairs ... what is a nice way to map just second elements of those pairs to new values?
16:16:57 <ddarius> Summermute: There are very few languages like Haskell period, and if more existed, they would have a community similar to (or worse than) Haskell's with regards to those metrics, e.g. Agda.
16:17:06 <ddarius> Mitar: map . second
16:17:07 <newsham> ie: diagrams in digital signal processing like this: http://upload.wikimedia.org/wikibooks/en/b/be/Cannonical_DSP_Filter.JPG   where z^-1 is a unit delay
16:17:11 <conal> newsham: my intuition is to make memory be a present input rather than a record of the past.
16:17:27 <newsham> give you a system that has an infinitely long response to stimulus, but one that fades over time
16:17:35 <Mitar> ehm, yes, but the result should be again pairs with original value as the first element kept
16:17:37 <ddarius> Yay IIR filters!
16:17:51 <OscarZ> ddarius: oh right.. this has to do with how lists are defined by the concatenation operator binding together objects? for some reason im thinking lists as primitive objects..
16:17:52 <ddarius> Mitar: That's what my code does.
16:17:55 <ddarius> :t map . second
16:17:56 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
16:18:05 <newsham> and obviously have a finite amount of memory, and explicitely show exactly how much memory
16:18:22 <newsham> in control theory they have similar diagrams with integral signs in boxes
16:19:04 <Mitar> nice, i am also doing dps ;-)
16:19:05 <Mitar> with haskell ;-)
16:19:05 <MissPiggy> the reason I aske is because you can use [] as a normal form
16:19:18 <MissPiggy> and that's really useful if you want to decide equality modulo associativity
16:19:30 <narens> help! anyone use arch linux and ghc? My ghc no longer can find Control.Monad. anything
16:19:38 <Mitar> :t second
16:19:39 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
16:19:49 <Mitar> aha, arrows ;-)
16:19:54 <ddarius> I mentioned control theory on one of your blog posts recently.  Particularly Willems work.
16:19:56 <MissPiggy> but in more complex cases, I don't know any method that is <can't think of the word...>
16:19:58 <Saizan> narens: what does ghc-pkg list mtl says?
16:20:15 <newsham> so basically I was just wondering if there's much connection between control theory and the FRP stuff
16:20:28 <narens>   Cabal-1.8.0.2
16:20:28 <narens>    array-0.3.0.0
16:20:28 <narens>    base-3.0.3.2
16:20:28 <narens>    base-4.2.0.0
16:20:31 <narens>    bin-package-db-0.0.0.0
16:20:34 <newsham> intuitively seems like there should be (ie. I want there to be :)
16:20:34 <narens>    bytestring-0.9.1.5
16:20:37 <narens>    containers-0.3.0.0
16:20:39 --- mode: ChanServ set +o Saizan
16:20:40 <narens>    directory-1.0.1.0
16:20:42 --- mode: Saizan set +b *!*user@*.ntc.blacksburg.shentel.net
16:21:00 <ddarius> newsham: Certainly there is for much of the work that has been done, e.g. there definitely is a strong connection for Yampa.
16:21:07 <Saizan> narens: i've banned you to make you stop flooding, you have to paste such things on a pastebin site in the future
16:21:17 <Saizan> narens: i'll now remove the ban
16:22:01 <newsham> cool
16:22:21 --- mode: Saizan set -b *!*user@*.ntc.blacksburg.shentel.net
16:22:23 <narens>    stm-2.1.1.2
16:22:31 <narens> sorry
16:22:34 <narens> sorry, i didn't mean to paste the thing like that
16:22:42 <Saizan> narens: ok, np :)
16:22:43 <narens> sorry, didn't mean to do that
16:22:47 <narens> but, yeah mtl exists
16:22:57 --- mode: Saizan set -o Saizan
16:23:00 <Saizan> narens: is it red?
16:23:05 <narens> nope
16:23:52 <Saizan> what error do you get when you're trying to use one of those modules, exactly?
16:24:12 <narens> <no location info>:
16:24:12 <narens>     module `Control.Monad.Writer' is a package module
16:24:13 <narens> Failed, modules loaded: none.
16:24:34 <Saizan> ah, are you trying to :load that?
16:24:50 <Mitar> aha, the problem is that the function i have is [a] -> [b]
16:25:00 <Mitar> so map . second does not work as it expects a -> b
16:25:08 <narens> ah...dear god! I've been having a bad linux day after a nasty pacman -Syu
16:25:17 <narens> thanks
16:25:29 <ezyang> lift!
16:25:29 <Saizan> heh
16:25:39 <narens> and another thing is I can't seem to install wxhaskell with cabal
16:25:53 <narens> it complains about not being able to install container
16:26:09 <SubStack> hooray, I now have hmatrix transformation routines
16:26:12 <ezyang> oh wait, wrong direction
16:26:22 <Saizan> narens: the package is probably not meant for your ghc version then
16:26:27 <SubStack> now to swap out my thread-unsafe glut matrix manipulations
16:26:42 <narens> hmm, thats what i found in forums... just wanted to confirm
16:26:43 <ezyang> Mitar: Do you have a smidge more context?
16:26:50 <Mitar> so, if i have a list of pairs ... what is a nice way to map just second elements of those pairs to new values with a function which takes a list and returns a list?
16:27:20 <Saizan> Mitar: will it return a same-sized list?
16:27:21 <narens> Saizan: last question. Do you recommend I install haskell-platform?
16:27:24 <Mitar> so one way would be to unzip, then map and then zip
16:27:25 <Mitar> yes
16:27:37 <Saizan> yeah, i'd do it with unzip
16:27:40 <Mitar> it is just a complex map (fft)
16:27:47 <Mitar> complex complex map ;-)
16:28:00 <ezyang> I'd prolly unzip and then rezip
16:28:07 <Saizan> ?type \f -> zip . second (map f) . unzip
16:28:08 <lambdabot>     Couldn't match expected type `[a]' against inferred type `(d, [b])'
16:28:09 <lambdabot>     In the first argument of `(.)', namely `second (map f)'
16:28:09 <lambdabot>     In the second argument of `(.)', namely `second (map f) . unzip'
16:28:27 <Saizan> ?type \f -> uncurry zip . second (map f) . unzip
16:28:28 <lambdabot> forall a b a1. (a1 -> b) -> [(a, a1)] -> [(a, b)]
16:29:15 <Mitar> (that function needs complete list as input as it has to know the length of the list)
16:29:32 <Saizan> narens: i just use cabal-install to get anything, but if you've ghc-6.10.4 it might be nice
16:30:00 <Saizan> ?type \f -> uncurry zip . second f . unzip -- no map..
16:30:01 <lambdabot> forall a b b1. ([b1] -> [b]) -> [(a, b1)] -> [(a, b)]
16:30:09 <narens> yea thats what i use too.. i might just stick with that for a little longer
16:30:16 <narens> thanks!
16:33:02 <Mitar> thanks saizan ...
16:33:38 <Mitar> but i will probably go for unzip/zip and where ;-) it will be more readable after i will read this code one year later ;-)
16:34:23 <ezyang> Saizan: hmmmmm
16:34:47 <ezyang> ooh, clever use of uncurry
16:35:41 <Veinor> does/can Haskell have any kind of eval function?
16:36:04 <ezyang> "sort of"
16:36:18 <Veinor> sort of?
16:36:20 <Susan> O hai
16:36:39 <ezyang> http://www.cse.unsw.edu.au/~dons/hs-plugins/html/System-Eval-Haskell.html
16:37:22 <eflister> Saizan: great it all worked, thanks!  when i :l my code in ghci (6.12), i get a weird message 'mkUsageInfo: internal name? s{tv aGK}' -- but everything runs fine.  i don't recognize those symbols...
16:37:30 <Veinor> that seems.... rather odd
16:37:49 <ddarius> A basic "eval" is simply a normal function.
16:38:44 <MissPiggy> I like eval
16:38:58 * ezyang rehashed the argument about eval with Sussman, and Sussman won by saying the Lisp had a much more natural eval. 
16:39:25 <MissPiggy> in haskell I write eval myself
16:39:30 <MissPiggy> for a small data type
16:39:40 <MissPiggy> you do not want something like lisp eval
16:41:42 <balboa02> would System.Eval.Haskell be the best choice for something a parser that can except interspersed haskell code?
16:49:15 <Saizan> eflister: seen that too on some code, not sure what causes it though
16:53:34 <eflister> Saizan: huh, google seems to suggest it may be template haskell (which i'm not using -- could one of my imports be using it without me knowing?)  or another post suggets it's something that didn't get recompiled for 6.12 has leftover 6.10 symbols?
16:54:37 <kyagrd> Thanks to the debian haskell team I am finally upgrading to 6.12
16:55:30 <Saizan> eflister: i've seen it happen where TH were involved and the libs you're using could use TH
16:55:45 <Saizan> eflister: i didn't get any problem because of this
17:01:16 <Mitar> where can i find parma?
17:01:18 <Mitar> parmap
17:01:31 <Mitar> in 6.12?
17:01:37 <Lemmih> Aisle 5.
17:02:14 <Saizan> Mitar: Control.Parallel.Strategies
17:02:23 <Saizan> you might need to install the parallel package
17:03:12 <geoaxis> hello people
17:08:51 <Mitar> thanks
17:13:14 <eflister> Saizan: yeah seems to be asymptomatic.  so the reason i wanted to try 6.12 was for existential record updates.  it let me get rid of two workarounds, but i still need the third cuz we still can't use record updates for existential fields.  i don't get why...
17:18:32 <MissPiggy> haskell solves the world problem for associative binary ops
17:18:42 <MissPiggy> I mean lists
17:19:24 <MissPiggy> but since it's undecidible in general, we shouldn't expect data types that solve arbitrary equational systems -- so that answers my earlier question negatively
17:26:45 <stoic75> hi all.  I'm having a problem with xmonad.  I created the xmonad.hs file and am getting an error that says, 'could not find module 'xmonad''
17:28:22 <Zao> Case matters.
17:28:30 <Zao> Also, #xmonad.
17:28:46 <stoic75> oh, am I in the wrong channel?  sorry
17:28:54 <Cale> stoic75: hmm, yeah, that suspiciously starts with a lowercase letter
17:29:15 <stoic75> sorry cale, I th ink it actually states 'Xmonad'
17:29:28 <Cale> I believe it should be  import XMonad
17:29:39 <stoic75> yes, i just checked.  it is Upper case X
17:29:52 <Cale> and M?
17:30:02 <stoic75> I edited the xmonad.hs with vim and put the import in.
17:30:18 <stoic75> oh.  nope.  the M is lower case
17:31:55 <MissPiggy> What can I solve the world problem for?
17:32:07 <MissPiggy> (1) binary operation with associatiity
17:32:30 <MissPiggy> (2) beta(/eta) conversion on typed lambda terms
17:32:45 <MissPiggy> any more examples?
17:32:50 <MissPiggy> I can't think of more
17:33:08 <dfdfdf> what is the problem?
17:33:31 <stoic75> cale:  I got it!  you were right.  no errors this time.  wow, one M and that's the difference.  thanks so much for your help!
17:34:03 <MissPiggy> dfdfdf, showing when some things are equations
17:34:08 <Zao> Hrm, seems like language.c stealthily requires happy and alex. How annoying.
17:34:11 <MissPiggy> by the both my examples are using a normal form
17:34:22 <MissPiggy> I would like to find some word problem that has no normal form?
17:34:45 <Zao> Does anyone know the rationale to why they are not bundled with GHC proper?
17:35:29 <MissPiggy> any good books like Term Rewriting and all that?
17:35:29 <sjanssen> Zao: lately they've been working on making the GHC distribution smaller
17:35:51 <sjanssen> Zao: this lets the GHC people focus on GHC rather than a dozen other libraries and tools
17:35:55 <Zao> Does the HP include them at least?
17:36:01 <sjanssen> I would assume
17:36:03 <Zao> Not that it helps me, as 6.12.1 doesn't have a HP yet.
17:36:19 <sjanssen> Zao: HP is overrated anyway, just 'cabal install' them
17:36:31 <Zao> sjanssen: No cabal either :)
17:36:51 <Zao> I wonder why Language.C doesn't depend on said cabal packages for happy and alex then.
17:37:31 <sjanssen> Zao: in Cabal one can only depend on libraries, not executables
17:37:31 <Saizan> they should be specified as build-tools
17:38:02 <Zao> Saizan: And so they are.
17:38:53 <Saizan> cabal doesn't install build-tools for you, anyhow
17:39:42 <Zao> Which is the core problem here.
17:39:55 <Zao> I didn't even know they were available as packages.
17:40:03 <Zao> As I assumed that if they were, they'd be automagically pulled in.
17:40:16 <dfdfdf> MIssPiggy: http://en.wikipedia.org/wiki/Word_problem_for_groups , gives a list of solved instances
17:40:46 <Zao> Which is a bit sad, as it turns my "cabal install me" instructions to "cabal install all this crap; then cabal install me"
17:40:57 <MissPiggy> dfdfdf that'spretty tough stuff
17:41:18 <geoaxis> any one up for a challange
17:41:19 <dfdfdf> aye
17:41:28 <MissPiggy> what challenge
17:42:08 <geoaxis>   http://kpc2010.klarna.com/web/problem1/
17:42:29 <geoaxis> its already solved by few people so you wont win
17:42:49 <geoaxis> but i cannot wrap my head around it, not sure how this would be solced
17:43:02 <geoaxis> its suppose to be a general programming puzzle
17:43:25 <MissPiggy> you have to login ?
17:43:29 <dfdfdf> geoaxis: the page doesn't load for me
17:43:35 <Zao> Seems to cycle reload here.
17:43:42 <MissPiggy> well what is the problem?
17:43:51 <MissPiggy> or puzzle
17:43:56 <geoaxis> ok may be here http://kpc2010.klarna.com/
17:44:12 <geoaxis> its essentially a PPM file (an image)
17:44:21 <geoaxis> and there is a text on it in pixels
17:44:31 <geoaxis> whichs says that there is a hidden text in it
17:44:49 <MissPiggy> oh
17:44:50 <geoaxis> and a hint in the description says that what is red and insignificant is not
17:44:58 <Cale> mmm... redirect loopy goodness
17:45:19 <geoaxis> Cale , yeah I just noticed, will let the site admin know
17:45:24 <geoaxis> but second link works
17:45:53 <geoaxis> oh dam
17:46:00 <geoaxis> propblem tow has aslo been solved
17:46:57 <MissPiggy> @let t = [True]
17:46:58 <lambdabot>  Defined.
17:47:53 <MissPiggy> > concat . iterate (join (++) id (map not)) $ t
17:47:54 <lambdabot>   Ambiguous occurrence `t'
17:47:54 <lambdabot>  It could refer to either `L.t', defined at <local...
17:49:12 <MissPiggy> > concat . iterate (join (++) id (map not)) $ [True]
17:49:14 <lambdabot>   [True,False,False,True,True,True,True,False,False,False,False,False,False,F...
17:50:47 <kyagrd> There is certain magical sequence when you are dealing with cabal
17:51:31 <kyagrd> I just upgraded to cabal and succeeded to install gitit trying about 5 differrent ways :(
17:51:43 <kyagrd> I mean I upgraded to 6.12 and then
17:54:29 <MissPiggy> how do you do thue morse sequence in haskell?
17:54:57 <MissPiggy> as an infinite list
17:58:04 <Zao> geoaxis: A good place to start is likely to feed the file through xxd to see the colour values and try to discern what might lie within.
17:58:28 <geoaxis> Zoo, you mean a histogram
17:58:58 <geoaxis> (i can do a histogram with ppmhist )
17:59:09 <Zao> geoaxis: xxd is a hexdump tool standard on any unix platform.
17:59:27 <Zao> In any way, try to discern the method of steganography and attempt to decode it.
17:59:51 <Zao> The hint makes it a bit too easy to know where to start :)
18:00:17 <Zao> And now, glorious threadDelay.
18:00:18 <ddarius> Zao: Even without the hint ...
18:00:58 <geoaxis> Zao: ok
18:05:57 <MissPiggy> "This file contains copies of a paper written in 1969 by Claude Pair that shows that the equality in recursive types is decidable. "
18:07:19 <hkarim> I am new to Haskell, Can I invoke a function using a postfix notation
18:07:31 <Cale> > let t 0 = 0; t n = if even n then t k else 1 - t k where k = n `div` 2 in map t [0..]
18:07:32 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
18:07:34 <MissPiggy> hkarim, no you can't
18:07:47 <MissPiggy> the best you get is like  (f !)  where ! is an infix operator
18:07:58 <MissPiggy> but you can't omit the brackets
18:08:01 <MissPiggy> that's cool cale!
18:08:20 <hkarim> oh, thanks
18:08:27 <ddarius> MissPiggy: That's a direct transliteration of one of the definitions on Wikipedia.
18:08:43 <hkarim> nothing like F#'s |> either?
18:08:55 <MissPiggy> im trying to learn more about term rewriting
18:09:09 <MissPiggy> hkarim, |> isn't postfix though (is it?)
18:09:33 <hkarim> yeh, but similar effect, right
18:09:40 <MissPiggy> not really
18:09:47 <MissPiggy> if you have a postfix operator x!
18:09:51 <ddarius> hkarim: |> is a user-defined operator in F# and easily defineable in Haskell.
18:09:52 <copumpkin> hkarim: that's composition isn't it?
18:09:59 <MissPiggy> I could just make a new prefix operator called $, where $x = x!
18:10:01 <dobblego> let (|>) = flip ($)
18:10:05 <MissPiggy> and it would have exactly the same effect
18:10:10 <ddarius> > let x |> f = f x in 3 |> negate
18:10:11 <lambdabot>   -3
18:10:17 <copumpkin> I thought it was flip (.)
18:10:23 <copumpkin> guess not
18:10:26 <dobblego> > let (|>) = flip ($) in 3 |> negate
18:10:27 <lambdabot>   -3
18:10:29 <MissPiggy> oh |> is for writing things backwards
18:10:33 <MissPiggy> that sucks...
18:10:33 <dobblego> copumpkin, it's not even that special :)
18:10:39 <copumpkin> dobblego: lol, nice
18:10:56 <hkarim> it is just a pipe operator
18:11:10 <ddarius> It's somewhat useful for OO code, but not terribly useful for FP code.
18:11:28 <hkarim> [1;2;3] |> List.fold ..
18:11:32 <Cale> hkarim: Usually we use (.), which is function composition, together with ($) to apply a composed chain of functions to a value.
18:11:42 <Cale> > map head . group . sort $ "mississippi"
18:11:43 <lambdabot>   "imps"
18:11:44 <Veinor> F# looks interesting; is it any good?
18:12:03 <hkarim> it's OCaml on .Net
18:12:14 <hkarim> with some Microsoft beef
18:12:18 <ddarius> Basically.  There are some significant differences, but mostly that.
18:12:31 <Veinor> I... don't know what that means.
18:12:46 <Veinor> "basically, should I learn F# or Haskell?"
18:13:01 <ddarius> Veinor: If you want FP and .NET, then use F#.  If you don't care about .NET, then F# isn't particularly notable.
18:13:03 <luite> are there people here with experience (or who know good references) in using theorem proving to improve algoritms (by generating improvement/modifications according to some rules and proving their correctness)?
18:13:36 <ddarius> @google algebra of programming in agda
18:13:37 <lambdabot> http://www.iis.sinica.edu.tw/~scm/2009/algebra-of-programming-in-agda-dependent-types-for-relational-program-derivation/
18:13:38 <lambdabot> Title: Algebra of programming in Agda: dependent types for relational program derivatio ...
18:13:59 <copumpkin> proving that kind of stuff can be quite painful though
18:14:31 <luite> copumpkin: it's supposed to take me four years to get some results ;)
18:14:39 <copumpkin> :O
18:15:04 <Cale> > map head . transpose . iterate (>>= \x -> [x,1-x]) $ [0]
18:15:05 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
18:15:15 <astroboy> why is this code wrong http://hpaste.org/fastcgi/hpaste.fcgi/view?id=19719#a19719 ?
18:15:22 <Veinor> Cale: thue-morse?
18:15:25 <Cale> yep
18:15:30 <ddarius> Cale: A version of the L-system definition of the Thue-Morse sequence.
18:15:34 <Veinor> whoo
18:15:35 <Cale> yeah
18:16:03 <dobblego> astroboy, prefer init . init . showJSON $ j but what does the compiler say is wrong?
18:16:19 <Cale> map head . transpose . iterate f  is a handy pattern, I'll have to remember that.
18:16:45 <luite> copumpkin: nah it's one of the 'options' on the research grant application (for one phd student, 4 years) my prof handed me today. he was asking for suggestions for improvement, it's due next week
18:16:48 <ddarius> Cale:  That is a cleverish trick.
18:16:52 <astroboy> dobblego: Illegal instance declaration for `Show JSON'        (All instance types must be of the form (T t1 ... tn)
18:16:54 <copumpkin> ah
18:18:56 <Cale> MissPiggy: In case you missed it, there's another one :)
18:18:57 <luite> oh crap he said that "Programming will be done in C++", I should make him change that ;)
18:19:03 <MissPiggy> I saw it
18:19:05 <Veinor> astroboy: I think you want instance (Show a) => Show JSON a
18:19:07 <MissPiggy> thank you
18:19:09 <Veinor> where
18:19:34 <ddarius> That's a parse error.
18:19:40 <Veinor> er... something like that
18:19:41 <astroboy> Veinor: why JSON a?
18:19:43 <dobblego> instance (Show a) => Show (JSON a) where
18:19:46 <Veinor> yeah, that
18:19:51 <astroboy> ok thanks
18:20:02 <astroboy> no but
18:20:41 <astroboy> my type is type JSON = [(String, JSONType)]
18:20:51 <astroboy> so it should be just JSON
18:20:54 <astroboy> without the a
18:21:03 <astroboy> but it doesn't work in that way
18:21:06 <Veinor> oh. hm.
18:21:16 <sjanssen> Haskell '98 doesn't let you write instances of that form
18:21:21 <ddarius> astroboy: You can't make instances of type synonyms.  I think it says that further in that error message.
18:21:21 <MissPiggy> http://www.cs.unm.edu/~mccune/sobb2/
18:21:33 <Cale> > map length . group . map head . transpose . iterate (>>= \x -> [x,1-x]) $ [0]
18:21:34 <lambdabot>   [1,2,1,1,2,2,2,1,1,2,1,1,2,1,1,2,2,2,1,1,2,2,2,1,1,2,2,2,1,1,2,1,1,2,1,1,2,...
18:21:51 <sjanssen> you also can't make instances of constructors applied to non-variable types
18:22:04 <ddarius> Yep, right after the instance message it says "where T is not a type synonym"
18:22:12 <astroboy> ddarius: ooh yes you are right
18:22:20 <astroboy> why is that anyway?
18:22:37 <ddarius> astroboy: Well it also tells you how to enable an extension that allows it.
18:22:49 <astroboy> ok yeah
18:22:52 <astroboy> but I mean
18:22:59 <astroboy> is there something wrong about doing that
18:23:02 <astroboy> that I can't see :P
18:23:36 <Cale> > map head . transpose . iterate (>>= \x -> case x of 1 -> [1,2,1]; 2 -> [1,2,2,2,1]) $ [1]
18:23:37 <lambdabot>   [1,2,1,1,2,2,2,1,1,2,1,1,2,1,1,2,2,2,1,1,2,2,2,1,1,2,2,2,1,1,2,1,1,2,1,1,2,...
18:23:37 <sjanssen> astroboy: I think the idea behind that restriction in Haskell '98 was just to simplify implementation
18:23:45 <astroboy> ok
18:24:03 <ddarius> astroboy: I believe the reason it is disallowed is to avoid surprise, because there are very good reasons why you can't write instances for partially applied type synonyms and also some people may expect to be able to write: instance Foo String; type Bar = String; instance Foo Bar;
18:24:18 <ddarius> sjanssen: I don't think that actually simplifies the implementation much or at all.
18:24:42 <ddarius> sjanssen: Well, at least insofar as relative to what the extension that allows that allows.
18:24:44 <Veinor> ddarius: I don't get what that Foo/Bar example is meant to do
18:25:13 <ddarius> Veinor: Make String and Bar an instance of some class in presumably two different ways.
18:25:17 <Veinor> ah, okay
18:25:23 <sjanssen> ddarius: yeah, you're probably right
18:25:27 <Veinor> I keep thinking it's instance Type Class not instance Class Type
18:25:56 <Veinor> like.... instance Foo (of) Bar
18:26:27 <ddarius> Veinor: Think of it like a predicate from Prolog or (first order) logic.
18:26:33 <astroboy> mhmm... actually
18:26:40 <astroboy> I get this error
18:26:42 <astroboy>  Overlapping instances for Show [([Char], JSONType)]
18:26:57 <ddarius> Yep.  The error is self-explanatory.
18:26:59 <astroboy> instance (Show a) => Show [a] -- Defined in GHC.Show      instance Show JSON -- Defined at hangman.hs:(60,0)-(62,50)
18:27:19 <copumpkin> just newtype it
18:27:42 <copumpkin> I'm guessing you enabled TypeSynonymInstances?
18:27:45 <astroboy> mhm how do I do that?
18:27:50 <astroboy> copumpkin: yes
18:27:52 <MissPiggy> does anyone know books that are great like Term Rewriting and all that?
18:28:21 <luite> copumpkin: most of their research is in exact exponential time algorithms, which are typically branch and reduce (first reduce the instance by removing things that cannot influence the solution, then branch). one of the things could be verification of reduction rules. this kind of algorithms kan also be easily described functionally, which is nice, I guess
18:28:56 <Cale> > map head . transpose . iterate (>>= \x -> case x of 1 -> [1,2,3]; 2 -> [1,3]; 3 -> [2]) $ [1]
18:28:57 <lambdabot>   [1,2,3,1,3,2,1,2,3,2,1,3,1,2,3,1,3,2,1,3,1,2,3,2,1,2,3,1,3,2,1,2,3,2,1,3,1,...
18:29:17 <MissPiggy> whats that hehe
18:29:25 <MissPiggy> oh it's a general rewrite system
18:29:32 <MissPiggy> can you compute anything with it
18:29:38 <Cale> @oeis 1,2,3,1,3,2,1,2,3,2,1,3,1,2,3,1,3,2,1,3,1,2,3,2,1,2,3,1
18:29:38 <lambdabot>  A square-free (or Thue-Morse) ternary sequence: closed under 1->123, 2->13, ...
18:29:39 <lambdabot>  [1,2,3,1,3,2,1,2,3,2,1,3,1,2,3,1,3,2,1,3,1,2,3,2,1,2,3,1,3,2,1,2,3,2,1,3,1,2...
18:30:24 <ddarius> Now I want to consider Dirichlet generating functions.
18:30:54 <MissPiggy> map head . transpose . iterate (>>= \x -> case x of 1 -> [1,2] ; 2 -> [1,1,3] ; 3 -> [2,3,2]) $ [1]
18:31:10 <ravi_mohan> Good Day Newbie Here. Can someone reccomend some Haskell code to read? To pick up good style and idioms.
18:31:29 <ravi_mohan> I've worked thru "learn you a haskell" and most of RWH
18:32:52 <astroboy> so what should I do i fmy instances is overlapping with the one defined in GHC
18:33:00 <Cale> > scanl (\a x -> 2*a + x) 0 . map head . transpose . iterate (>>= \x -> [x,1-x]) $ [0]
18:33:01 <lambdabot>   [0,0,1,3,6,13,26,52,105,211,422,844,1689,3378,6757,13515,27030,54061,108122...
18:33:20 <copumpkin> @oeis 0,0,1,3,6,13,26,52,105,211,422,844,1689,3378
18:33:20 <lambdabot>  Sequence not found.
18:33:41 <Cale> @oeis 0,1,3,6,13,26,52,105,211,422,844,1689,3378
18:33:41 <lambdabot>  First n elements of Thue-Morse sequence A010060 read as a binary number.
18:33:41 <lambdabot>  [0,1,3,6,13,26,52,105,211,422,844,1689,3378,6757,13515,27030,54061,108122,21...
18:33:59 <copumpkin> it should do subsequence searching
18:34:23 <ddarius> Not that way it shouldn't.
18:34:28 <MissPiggy> did lambda bot just totally ignore me
18:34:32 <MissPiggy> > map head . transpose . iterate (>>= \x -> case x of 1 -> [1,2] ; 2 -> [1,1,3] ; 3 -> [2,3,2]) $ [1]
18:34:33 <lambdabot>   [1,2,1,1,3,1,2,1,2,2,3,2,1,2,1,1,3,1,2,1,1,3,1,1,3,2,3,2,1,1,3,1,2,1,1,3,1,...
18:34:34 <copumpkin> ddarius: fair enough
18:34:42 <Cale> MissPiggy: you needed moar >
18:35:11 <copumpkin> > iterate (>>= \x -> [2 * x, 4 * x + 1]) 0
18:35:12 <lambdabot>   No instance for (GHC.Num.Num [a])
18:35:12 <lambdabot>    arising from the literal `0' at <inter...
18:35:18 <copumpkin> > iterate (>>= \x -> [2 * x, 4 * x + 1]) [0]
18:35:19 <lambdabot>   [[0],[0,1],[0,1,2,5],[0,1,2,5,4,9,10,21],[0,1,2,5,4,9,10,21,8,17,18,37,20,4...
18:35:53 <ddarius> L-systems, the first refuge of a wayward programmer.
18:37:07 <Cale> › map (foldl (\a x -> 2*a + x) 0) . iterate (>>= \x -> [x,1-x]) $ [0]
18:37:09 <Cale> oops
18:37:11 <Cale> > map (foldl (\a x -> 2*a + x) 0) . iterate (>>= \x -> [x,1-x]) $ [0]
18:37:12 <lambdabot>   [0,1,6,105,27030,1771476585,7608434000728254870,140350834813144189858090274...
18:37:33 <ravi_mohan> Is there something equivalent to PAIP, where you can learn good HAskell style?
18:37:46 <ddarius> > scanl1 (+) [0,2..]
18:37:47 <lambdabot>   [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462...
18:37:53 <ddarius> > scanl1 (+) [1,3..]
18:37:54 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:37:58 <Cale> > map (($ []) . showHex . foldl (\a x -> 2*a + x) 0) . iterate (>>= \x -> [x,1-x]) $ [0]
18:37:59 <lambdabot>   ["0","1","6","69","6996","69969669","6996966996696996","6996966996696996966...
18:38:02 <mjrosenb> ravi_mohan: paip?
18:38:16 <MissPiggy> wow why is that
18:38:29 <MissPiggy> show hex!
18:38:40 <MissPiggy> > 0x6996966996696996
18:38:41 <lambdabot>   7608434000728254870
18:38:44 <ravi_mohan> mjrosenb: Paradigms of Artificial Intelligence Programming by Peter Norvig
18:38:51 <MissPiggy> how strange
18:39:13 <Cale> Well, I'm just showing the steps in the construction of the Thue-Morse sequence as hexadecimal instead of binary.
18:39:33 <MissPiggy> but the digits are all 6's and 9's
18:39:45 <Veinor> heh heh. 69.
18:39:52 <Cale> > 6 .|. 9
18:39:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:39:52 <lambdabot>    `Data.Bits.Bits t'
18:39:52 <lambdabot>      a...
18:39:54 <mreh> why can't GHC find source files imported relative to a file?
18:39:57 <Cale> > 6 .|. 9 :: Integer
18:39:57 <lambdabot>   15
18:40:11 <Cale> > 6 .&. 9 :: Integer
18:40:12 <lambdabot>   0
18:40:19 <Cale> They're complements of each other.
18:40:24 <ddarius> Uh, display 6 and 9 as binary.
18:40:25 <Veinor> 6 = 0110, 9 = 1001
18:40:44 <ddarius> Veinor: @botsnack
18:40:51 <Veinor> ?
18:40:58 <Veinor> :P
18:41:00 <copumpkin> omnom
18:41:04 <Veinor> omnomnom bits
18:41:31 <mreh> imports look for files relative to the import first don't they?
18:41:43 <mreh> then they go look in the database
18:41:53 <MissPiggy> oh
18:42:00 <MissPiggy> wow!
18:42:37 <mjrosenb> mreh: i have noticed that ghci only likes to import things that have been imported in the dependency tree of what you have :load'ed
18:43:20 <mreh> GHCi does act strangely sometimes
18:43:51 <mreh> like a drunk uncle
18:45:02 <mjrosenb> Cale: the Thue-Morse sequence seems kind of boring.
18:45:13 * MissPiggy bites mjrosenb
18:45:44 <mreh> @slap MissPiggy
18:45:44 <lambdabot> I won't; I want to go get some cookies instead.
18:45:48 <ravi_mohan> ok so I guess I'll go back to trawling the net.
18:46:31 <ravi_mohan> Anyone writing any production grade machine learning code in Haskell?
18:46:49 <mreh> ravi_mohan I'd like to think so
18:46:50 <mjrosenb> ravi_mohan: iirc, someone was working on an AI competition in haskell
18:47:41 <ravi_mohan> :mreh ok! Anything Open Source you know of?
18:47:47 <luite> I wrote some algorithms for order restricted inference in haskell, but recently rewrote them in java :p
18:48:16 <Cale> mjrosenb: Well, in the sense that it doesn't have very much information in it, sure.
18:48:21 <ravi_mohan> :luite :-P Why? I guess you needed a gui?
18:48:26 <Cale> mjrosenb: But it has some nice properties.
18:48:34 <mreh> ravi_mohan: there are libraries on hackage, hmatrix, galib
18:48:55 <luite> ravi_mohan: nah my prof didn't understand haskell
18:49:01 <ravi_mohan> I worked through most of (norvig and russell's) AIMA in java (and open sourced it)
18:49:25 <ravi_mohan> I amm very much a newbie in Haskell and am looking for some good code to read
18:49:39 <ravi_mohan> :luite Well, that is a good reason :)
18:50:08 <luite> bah he should've learned haskell instead :p
18:50:18 <ravi_mohan> :luite :-P
18:50:29 <Cale> For one, it is overlap-free, which means that it has no subword of the form axaxa where x is any string, and a is any single letter. It also has no cubes: xxx for any string x.
18:50:30 <mjrosenb> Cale: i guess the fact that 6 and 9 look similar led me to believe that it was just a sequence of 4 or 8 repeating.
18:50:33 <luite> the alternative was rewriting in R, but I don't know anything about that...
18:51:03 <ravi_mohan> :luite IS your code available for  a HAskell newbie to read by any chance? :-)
18:51:25 <mjrosenb> Cale: for whatever reason, i like sequences where any string of n bits is guaranteed to appear.
18:53:03 <luite> ravi_mohan: not at the moment, it's also quite messy and unfinished, so probably not a good read for a beginner. maybe I'll clean it up after this project and paper are done
18:53:24 <ravi_mohan> :luite ok no problem worth a try :)
18:54:51 <luite> but hackage has a great amount of code available, you might find something to your liking there, especially if you like undocumented code with lots of functional 'cleverness' but no examples
18:55:06 <Cale> While not any string of n bits appears, it does have the property that for any finite string that does appear, there is some length n such that any n consecutive elements will contain that string as a subword.
18:56:00 <ravi_mohan> :luite yes thanks, but  I was looking for examples of *good* Haskell code (analogous to lisp code in Norvig's PAIP) . Written by experienced haskellers
18:56:14 <ravi_mohan> :luite in "good" style
18:56:37 <ravi_mohan> :luite so I can pick up good idoms and so on
18:57:16 <ravi_mohan> :luite Right now I am not in  aposition to recognize really good Haskell code from not so good code
19:00:37 <ravi_mohan> ok so maybe I'll just write some terrible beginner's code and ask for a critique vs looking for great code to read.
19:01:13 <luite> writing terrible code is always a good way to start :p
19:02:04 <ravi_mohan> luite:  :-P Thanks :-P
19:05:53 <ravi_mohan> \quit
19:23:38 <mreh> I don't understand what I am supposed to call modules in a package, GHCi complains if I don't fully qualify them, using cabal it tells me off for fully qualifying them
19:41:37 <saiko_> hi all.. I had a (perhaps silly) newbie question.. Is there a strict version of map?
19:42:20 <shachaf> saiko_: What do you want it to do?
19:42:30 <pikhq> saiko_: Why do you want it?
19:42:44 <roconnor> > foldl' (flip (:)) [] [1,2,3]
19:42:45 <lambdabot>   [3,2,1]
19:42:45 <luite> saiko_: deepseq provides a nfdata instance for Map, maybe that's enough?
19:43:11 <roconnor> hmm
19:43:21 <saiko_> to apply a function to each of its arguments strictly.. the function im mapping over has lots of big data structures that kept retained..
19:43:40 <mreh> I don't understand why running "cabal build" ignores my package name when looking for things in the namespace
19:44:21 <mreh> Hs-Src-Dir is specified in the .cabal file, and just points to Package/src
19:44:36 <roconnor> map (\x -> f $! x) ?
19:44:58 <mreh> do I need to put everything inside of that again into a dir named "Package"
19:45:51 <saiko_> roconnor: wont that only evaluate x and not f's application on x? i.e.  i would get [<f x1>, <f x2>, ...]
19:46:20 <roconnor> oh
19:46:32 <roconnor> saiko_: well, map f l won't even do anything until it is demanded
19:46:53 <roconnor> saiko_: so you should be more worried about how it is consumed rather than generated I think
19:47:51 <saiko_> roconnor: true, but if I want to consume the list after a batch of multiple mappings, it will retain all the thunks
19:47:59 <saiko_> its eating memory!
19:48:23 <roconnor> saiko_: I'm confused.  even map f (map g (map h l)) won't do anything until demanded
19:48:59 <roconnor> after taking the head using it and discarding it the memory will be freed before consuming the next element
19:50:23 <saiko_> roconnor: you're right.. but im not consuming it one element at a time.. im basically using the list members as state variables, modified by the maps each run.. is there a better way to do this? I want to be able to easily change the number of 'state vars' and their order
19:51:37 <saiko_> roconnor: the problem is my 'consumption' occurs much later, and the functions i map over the list have big data structures.. so the thunks are huge.. and the big data structures are retained
19:52:03 <saiko_> anyways, i can make a strict mapper.. just found it interesting that it isnt already available in any of the regular/std libraries
19:52:27 <roconnor> I really don't understand what you are doing, but list sounds inappropriate for your task
19:53:11 <roconnor> how many functions are you mapping?
19:54:00 <roconnor> I think I understand now though
19:54:14 <roconnor> @quote maiden
19:54:14 <lambdabot> Meehl says: [The null hypothesis significance test is] a potent but sterile intellectual rake who leaves in his merry path a long train of ravished maidens but no viable scientific offspring
19:55:59 <saiko_> its a loop on a map... i map an typeclassed function on a list composed of multiple instances of that typeclass.. PROBLEM: the function i map holds a data structure, lets call it A.. i do this everytime I update my A. this happens a LOT of times.. so the idea is i can create an instance of the typeclass that captures some proprty of the data structure over iterations..
19:56:31 <saiko_> and i wanted to have a list so adding or removing properties is easy.. i just modify a list that the program start with
19:56:49 <saiko_> im just surprised there's no strict map!
19:56:56 <saiko_> alreayd written i.e.
19:57:07 <roconnor> saiko_: ya, it gets rewritten from time to time
19:59:12 <saiko_> oh well.. one more rewrite :-P
20:01:02 <roconnor> oh wait
20:01:12 <roconnor> I'm thinking of strictifying the spind of a list
20:01:16 <roconnor> that is a different problem
20:01:21 <roconnor> *spine
20:01:32 <saiko_> yeah, thats different
20:02:43 <saiko_> here's what im saying:
20:03:08 <saiko_> map' f = map (\x -> let x' = f x in seq x' x')
20:04:58 <gwern> preflex: seen zooko
20:04:58 <roconnor> saiko_: that's not what I was expecting
20:04:58 <preflex>  zooko was last seen on #haskell 112 days, 34 minutes and 37 seconds ago, saying: And by "folks" I mean Saizan.
20:05:10 <shapr> preflex: seen ibid
20:05:10 <preflex>  ibid was last seen on #haskell 9 days, 17 hours, 53 minutes and 21 seconds ago, saying: wtf, a chat bot inside irc?
20:05:36 <roconnor> saiko_: I was expecting you to write strictifyList l = foldr seq l l
20:06:13 <roconnor> @type join (foldr seq)
20:06:14 <lambdabot> forall a. [a] -> [a]
20:06:47 <roconnor> > let strictifyList = join (foldr seq) in strictifyLIst [1,2,3]
20:06:48 <lambdabot>   Not in scope: `strictifyLIst'
20:06:52 <roconnor> > let strictifyList = join (foldr seq) in strictifyList [1,2,3]
20:06:53 <lambdabot>   [1,2,3]
20:06:58 <roconnor> > let strictifyList = join (foldr seq) in strictifyList [1,2,undefined]
20:06:59 <lambdabot>   * Exception: Prelude.undefined
20:07:09 <roconnor> > let strictifyList = join (foldr seq) in strictifyList 1:2:3:undefined
20:07:10 <lambdabot>   No instance for (GHC.Num.Num [a])
20:07:10 <lambdabot>    arising from the literal `1' at <inter...
20:07:20 <roconnor> > let strictifyList = join (foldr seq) in strictifyList (1:2:3:undefined)
20:07:21 <lambdabot>   * Exception: Prelude.undefined
20:07:46 <roconnor> saiko_: then map' f l = strictifyList (map f l)
20:08:38 * roconnor wonders if that is even good enough
20:09:46 <saiko_>  wow cool.. gimme 15 mins to think it thru.. hehe slow here..
20:11:15 <saiko_> is join in Prelude?
20:11:38 <roconnor> no
20:11:56 <roconnor> just use strictifyList l = foldr seq l l
20:14:14 <saiko_> awesome.. thanks.. thats a better version than mine!
20:15:54 <bssj> I'm encountering an odd error at the ghci prompt.
20:16:10 <bssj> I have two functions that work correctly.
20:16:40 <bssj> Prelude> chance_all_mythic_playset 10
20:16:42 <bssj> 1 % 13292279957849158729038070602803445760000000000000000000000000000000000000000
20:16:52 <bssj> That's the first one.
20:17:14 <bssj> Prelude> mythic_playset_combinations_ratio 10 40
20:17:15 <bssj> 12868639981414579848070084500000000 % 1
20:17:19 <bssj> That's the second one.
20:17:40 <bssj> Of course, combining them manually works fine.
20:17:58 <bssj> Prelude> chance_all_mythic_playset 10 * mythic_playset_combinations_ratio 10 40
20:18:00 <bssj> 25737279962829159696140169 % 26584559915698317458076141205606891520000000000000000000000000000000
20:18:33 <bssj> However, if I define I function that combines them, the function fails.
20:19:37 <absentia> xn/win shrink 3
20:20:18 <bssj> Prelude> let foo m n = chance_all_mythic_playset m * mythic_playset_combinations_ratio m n
20:20:19 <bssj> Prelude> foo 10 40
20:20:21 <bssj> *** Exception: Ratio.%: zero denominator
20:22:45 <copumpkin> heh
20:22:46 <bssj> Any hints?
20:26:03 <bssj> I'm trying to build mure functions on top of that, and having the short form would be really nice.
20:27:32 <bssj> Fixing the "m" argument gives good results.
20:27:43 <bssj> Prelude> let foo10 = \n -> chance_all_mythic_playset 10 * mythic_playset_combinations_ratio 10 n
20:27:44 <bssj> Prelude> foo10 40
20:27:46 <bssj> 25737279962829159696140169 % 26584559915698317458076141205606891520000000000000000000000000000000
20:28:04 <bssj> Fixing the "n" argument gives bad results.
20:28:28 <bssj> Prelude> let bar40 = \m -> chance_all_mythic_playset m * mythic_playset_combinations_ratio m 40
20:28:29 <bssj> Prelude> bar40 10
20:28:31 <bssj> *** Exception: Ratio.%: zero denominator
20:30:34 <copumpkin> @hpaste
20:30:34 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:30:41 <copumpkin> ugh
20:30:55 <copumpkin> @where hpaste
20:30:55 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
20:39:04 <manjunaths> Hashell/Eval.hs:45:19: Not in scope: `GHC.newSession'
20:39:12 <manjunaths> anyone know how to fix this ?
20:39:14 <roconnor> bssj: sounds like defaulting
20:39:18 <roconnor> bssj: add types?
20:39:37 <roconnor> or add -fno-monomorphismrestriction
20:39:58 <copumpkin> or don't write lambdas where you can use parameters
20:59:08 <manjunaths> is there a version of LYAH for the sony ebook reader ?
21:04:25 <sshc> does a package similar to binary but checks its input exist?
21:07:36 <sshc> dons: loch doesn't build with the newest GHC, because the -Werror flag is used, and the "Warning: Module `Prelude' is deprecated:" is generated
21:08:55 * Alpounet enjoys tapl
21:15:07 <manjunaths> BONUS, ?
21:15:31 <manjunaths> The source of LYAH is it available ? What was it written in ?
21:20:07 <copumpkin> LYAH source should be in haskell, I hope :P
21:23:40 <shachaf> copumpkin: They have GHC for neurons nowadays?
21:32:18 <Veinor> how can I get the current hostname?
21:32:44 <Veinor> do I need Network.BSD?
21:33:17 <Alpounet> @index host
21:33:17 <lambdabot> bzzt
21:33:21 <Alpounet> @hackage host
21:33:21 <lambdabot> http://hackage.haskell.org/package/host
21:33:25 <Alpounet> noo
21:33:28 <Alpounet> @hoogle host
21:33:29 <lambdabot> Network.HTTP.Base host :: URIAuthority -> String
21:33:29 <lambdabot> Network.Socket type HostAddress = Word32
21:33:29 <lambdabot> Network.Socket.Internal type HostAddress = Word32
21:33:44 <Alpounet> @hoogle hostname
21:33:44 <lambdabot> Network type HostName = String
21:33:46 <lambdabot> Network.BSD type HostName = String
21:33:48 <lambdabot> Network.Socket type HostName = String
21:33:55 <Veinor> looks like I do.
21:34:04 <Alpounet> yep, sorry :/
21:34:15 <Veinor> dang.
21:39:41 * manjunaths converting a single page of LYAH to lrf (for my sony PRS-505)
21:40:49 <manjunaths> awwww...it looks like hell
21:41:44 <manjunaths> actually it is not bad in fact
21:41:51 <manjunaths> but the code is printed twice
21:47:20 <Veinor> whoo, I got a haskell script to print out my usual prompt
21:47:49 <Veinor> but I have to compile it, otherwise it's noticeably laggy... this might be a use case for python instead
21:48:38 <Alpounet> oh no, not Python, don't join the type-unsafe side of the force.
21:48:46 <Veinor> :P
21:48:52 <Veinor> 'at least it won't be perl'
21:49:27 <kmc> sigh
21:49:41 <Veinor> I mean, I could just make it after every time I save it
21:50:16 <kmc> use dyre
21:50:23 <Veinor> dyre?
21:50:25 <kmc> dyre
21:50:31 <kmc> @hackage dyre
21:50:32 <lambdabot> http://hackage.haskell.org/package/dyre
21:50:32 <Veinor> dyre?
21:51:04 <Veinor> eh... I think that'd be overkill
21:51:38 <Veinor> I'll just ghc --make
21:56:41 <copumpkin> dyre consequences
22:11:25 <sahazel> @src <*>
22:11:25 <lambdabot> Source not found. My mind is going. I can feel it.
22:11:33 <sahazel> @src (<*>)
22:11:34 <lambdabot> Source not found. I feel much better now.
22:11:38 <sahazel> hm
22:11:40 <shachaf> @src Applicative
22:11:41 <lambdabot> class Functor f => Applicative f where
22:11:41 <lambdabot>     pure  :: a -> f a
22:11:41 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
22:11:58 <sahazel> the type isn't helping me understand how to use them
22:12:12 <shachaf> (<*>) = ap
22:12:15 <shachaf> @src ap
22:12:15 <lambdabot> ap = liftM2 id
22:12:24 <sahazel> ow
22:12:39 <shachaf> liftM2 ($), rather.
22:13:12 <shachaf> > ap (Just succ) (Just 1)
22:13:13 <lambdabot>   Just 2
22:13:39 <shachaf> > ap [(+1),(*2)] [3,4]
22:13:40 <lambdabot>   [4,5,6,8]
22:13:47 <shachaf> And so on.
22:14:41 <sahazel> ah!
22:15:29 * ddarius prefers the German, "und so weiter"
22:16:09 <dmwit> preflex: seen dcoutts
22:16:10 <preflex>  dcoutts was last seen on #ghc 5 days, 10 hours, 54 minutes and 7 seconds ago, saying: ok, ta
22:16:20 <dmwit> not so likely, huh?
22:16:32 <sahazel> > [(+1)] <$> [1]
22:16:33 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
22:16:37 <sahazel> uh?
22:16:44 <shachaf> sahazel: (<$>) = fmap
22:16:44 <sahazel> > ap [(+1)] [1]
22:16:45 <lambdabot>   [2]
22:16:48 <sahazel> oh
22:16:50 <sahazel> geez
22:16:55 <sahazel> persistent typo
22:17:39 <tingi>  does anyone know about approximate shortest path algorithms with vertexes being added and removed  with total vertices around 10^5 ?
22:18:05 <dmwit> I just read a paper about that, actually.
22:18:23 <dmwit> Drop me an email, and next time I'm in my office I can send you a citation. =)
22:19:01 <sahazel> okay so what does pure do?
22:19:08 <dmwit> pure = return
22:19:10 <sahazel> I can make it pull things into a functor
22:19:17 <dmwit> yep
22:19:20 <dmwit> That's it.
22:19:30 <sahazel> but e.g.
22:19:33 <sahazel> > pure (+1) <*> pure 1
22:19:33 <lambdabot>   No instance for (GHC.Show.Show (f a))
22:19:34 <lambdabot>    arising from a use of `M9195886330...
22:19:46 <sahazel> uh?  that works locally and returns 2
22:19:54 <dmwit> [2], surely
22:19:57 <dmwit> but:
22:20:02 <sahazel> no 2!
22:20:07 <dmwit> > pure (+1) <*> pure 1 :: [Int]
22:20:08 <lambdabot>   [2]
22:20:28 <sahazel> ghci says:
22:20:30 <dmwit> > pure (+1) <*> pure 1 :: Int -- sahazel, are you sure?
22:20:30 <sahazel> Prelude Control.Applicative> pure (+1) <*> pure 1
22:20:30 <sahazel> 2
22:20:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
22:20:31 <lambdabot>         against inferred type ...
22:20:46 <applicative> > [(+1)] <*> [1]
22:20:47 <lambdabot>   [2]
22:21:06 <dmwit> :t pure (+1) <*> pure 1
22:21:07 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a
22:21:28 <dmwit> sahazel: I don't believe you. =)
22:21:32 <sahazel> even in :: Int, how does it decide that lists are the right functor?
22:21:38 <sahazel> that was a copy/paste!
22:22:28 <dmwit> huh
22:22:31 <dmwit> ghci does say that
22:22:35 <dmwit> Oh!
22:22:36 <dmwit> hahaha
22:22:42 <dmwit> > pure (+1) <*> pure 1 :: IO Int
22:22:43 <lambdabot>   <IO Int>
22:22:46 <dmwit> hahaha
22:22:51 <applicative> he wrote :[Int]
22:23:07 <applicative>  > pure (+1) <*> pure 1 :: [Int] --not int
22:23:20 <dmwit> sahazel: It *printed* 2, but the result wasn't 2, it was (return 2 :: IO Integer).
22:23:34 <sahazel> applicative: ah, duh
22:23:46 <sahazel> ohhh
22:23:52 <sahazel> it's in the IO monad already
22:23:54 <applicative> :: Int, how does it decide that lists are the right functor?
22:24:10 <dmwit> mispaste?
22:24:14 <sahazel> sneaky
22:25:56 <applicative> sahazel, I see what your difficulty was now, about an applicative instance that seemed to return 2
22:26:05 <portnov> what with ghc 6.12 status now? Is it usable? Does most usable libraries compile with ghc 6.12?
22:27:45 <dmwit> I believe 6.10.4 is still recommended for the casual Haskeller.
22:28:12 <sahazel> is there a nice name for flip ($)?
22:28:21 <ddarius> Nope.
22:28:27 <ddarius> Or rather, not a standard one.
22:28:29 <copumpkin> sahazel: nor should there be
22:28:50 * copumpkin is practicing his internet opinionation skills
22:29:23 <sahazel> I'll assume that's wise, for now
22:30:19 <applicative> I thought sahazel was trying to think of a nice name.
22:32:36 <applicative>  > let (£) = flip ($) in 2 £ (2*)
22:33:23 <applicative> > let (£) = flip ($) in 2 £ (2*)
22:33:24 <lambdabot>   4
22:35:04 <sahazel> >> seems appropriate given bind
22:35:33 <sahazel> :t (>>)
22:35:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
22:35:36 <applicative> Its taken.
22:35:44 <sahazel> :t (>>=)
22:35:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:36:11 <sahazel> @src (>>)
22:36:12 <lambdabot> m >> k      = m >>= \_ -> k
22:36:17 <sahazel> ah
22:37:01 <applicative> > [1,2,3] >> [4,5,6]
22:37:02 <lambdabot>   [4,5,6,4,5,6,4,5,6]
22:37:03 <portnov> :t (>>>)
22:37:04 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:37:32 <portnov> for functions, it works as flip (.)
22:38:26 <Sgeo> @src (>>>)
22:38:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:38:30 <Sgeo> @src get
22:38:31 <lambdabot> Source not found. There are some things that I just don't know.
22:39:03 <applicative> @source cat
22:39:03 <lambdabot> cat not available
22:39:17 <applicative> @source Category
22:39:17 <lambdabot> Category not available
22:39:24 <sahazel> weird that >> is like <$
22:40:10 <dobblego> class Category cat where (>>>) ::  cat a b -> cat b c -> cat a c; id :: cat a a -- iirc
22:40:26 <portnov> :i Category
22:40:35 <portnov> :/
22:41:36 <sahazel> and >>= is like flip (<$>)
22:41:46 <dobblego> no
22:41:49 <sahazel> no>
22:41:50 <sahazel> ?
22:42:05 <dobblego> (>>=) is like flip (=<<)
22:42:20 <kmc> @src (=<<)
22:42:20 <lambdabot> f =<< x = x >>= f
22:42:57 <applicative> @src (<<)
22:42:58 <lambdabot> Source not found. My mind is going. I can feel it.
22:44:10 <sahazel> I'm comparing the operators on applicative functors to the ones on monads
22:44:19 <sahazel> and finding that their names are confusing
22:44:22 <dobblego> ap =
22:44:24 <dobblego> (<*>)
22:44:26 <dobblego> pure = return
22:44:56 <dobblego> (all monads are applicative)
22:45:38 <sahazel> is there a good example of something that is naturally an applicative functor but not a monad?
22:45:49 <sahazel> I use lists as my example for everything, and they fit all of these
22:45:58 <dobblego> there is one in the applicative paper (Applicative Programming with Effects)
22:46:11 <dobblego> lists give several applicatives, but only one monad
22:46:17 <dobblego> (ZipList)
22:46:34 <sahazel> oh, that's helpful
23:21:49 <Cale> http://picturesforsadchildren.com/ :)
23:52:32 <kaos> Hi, I have a data-type, say 'data Thing r = Stuff r | Error String' now, I have a lot of functions using this sample datatype, that all enforces the type constraint (Show r, Read r). Is there anyway that I don't have to say this explicitly in each function-declaration but perhaps somehow in the definition of the type? so the functions operating on the type can deduce this implicitly?
23:53:16 <dmwit> Yes, you can.
23:53:25 <dmwit> It's generally considered bad style, but it's valid Haskell.
23:53:34 <kaos> oh?
23:54:18 <Jonno_FTW> how can I add in a literal % symbol using printf?
23:54:29 <dmwit> %%
23:54:34 <Jonno_FTW> thanks
23:56:05 <kaos> dmwit: so where do I put the type constraint?
23:56:44 <dmwit> oh, um
23:57:00 <Jonno_FTW> did you ask your question on stackoverflow?
23:57:31 <dmwit> data Show r => Thing r = Thing r
23:58:00 <kaos> me?
23:58:24 <dmwit> kaos: ...but you'll regret it later. I 85% guarantee it.
23:58:27 <nathanic> kaos: there's a couple paragraphs advising against it here http://learnyouahaskell.com/making-our-own-types-and-typeclasses
23:59:49 <kaos> hmm, right - I think I can see how it may cause some trouble... Thanks for the help and for the link, I will read up!
