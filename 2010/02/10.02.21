00:14:37 <chrissbx> In Text.ParserCombinators.ReadP I'm missing a way to specify a non-greedy match;
00:16:31 <chrissbx> for example, skipComment = skipSpaces >> (string "<!--") >> (many anyCharacter) >> (string "-->")
00:16:52 <chrissbx> should really take the first --> that follows <!--, any other interpretation would be invalid.
00:17:25 <dmwit> You probably want to tokenize first.
00:17:47 <dmwit> (In fact, the problem is even worse than you think. Look up the real syntax for SGML comments. ;-)
00:17:55 <Jafet> No one uses the real syntax
00:18:03 <dmwit> true
00:18:10 <chrissbx> Well, that was only an example; my real work is dealing with Scheme multiline comments.
00:18:21 <dmwit> sure
00:18:30 <dmwit> I still think you probably want to tokenize first.
00:18:50 <chrissbx> Just because this isn't covered by ReadP?
00:19:02 <copumpkin> you really want to be parsing HTML with parser combinators?
00:19:19 <copumpkin> or xml/sgml
00:19:25 <dmwit> sounds like no
00:19:38 <dmwit> He wants to be parsing scheme with parser combinators. =)
00:19:59 <chrissbx> Why would separate tokenizing be any better?
00:20:14 <dmwit> Because then it would look like
00:20:58 <dmwit> skipSpaces >> token "<!--" >> many (satisfy . (/= "-->")) >> satisfy (== "-->")
00:21:01 <dmwit> or something like that
00:21:36 <chrissbx> And how would I recognize the tokens?
00:21:38 * dmwit admits to knowing Parsec better than ReadP but suspects there is something like satisfy anyway
00:21:47 <chrissbx> --> could be part of a symbol
00:22:08 <dmwit> That's your tokenizer's job, right?
00:22:08 <chrissbx> So there is still a priority problem.
00:22:09 <shapr> #haskell has a birthday in two months, 9 years old!
00:22:42 <shapr> I have to bake a cake.
00:22:58 <kamatsu> shapr: lambda cake?
00:23:06 <shapr> Yeah :-)
00:23:40 <shapr> Makes me wish I'd bought those cast iron cornbread pans today, I could assemble a lambda cake out of those...
00:23:44 <chrissbx> I don't see why it wouldn't be trivial to add the functionality to ReadP. Should be just taking the first of all possible matches of the respecting subparser.
00:23:51 <pragma_> Yellow bubblegum trees swaying on the breeze and the bee's knees come to bring peace.
00:23:54 <chrissbx> respective
00:24:35 <dmwit> You're right, that's probably much easier.
00:24:55 <shapr> psykotic: Dude, you going to demo your merssengine on channel?
00:25:26 <psykotic> shapr: sorry, what?
00:25:50 <shapr> Did you write the tiny little mersenne generator?
00:25:55 <psykotic> oh right
00:26:05 <psykotic> hang on :)
00:27:05 <psykotic> > [n | (p, n + 1) <- zip [2..] (iterate (2 *) 4), iterate (\  s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
00:27:09 <lambdabot>   mueval-core: Time limit exceeded
00:27:19 <shapr> Along similar lines, I was thinking the online encyclopedia of integer sequences could hire psykotic to write their 'code' sections :-)
00:27:19 <psykotic> oh, it doesn't print as it go
00:27:39 <psykotic> > take 15 [n | (p, n + 1) <- zip [2..] (iterate (2 *) 4), iterate (\  s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
00:27:43 <lambdabot>   mueval-core: Time limit exceeded
00:27:46 <copumpkin> omg it's psykotic
00:28:11 <psykotic> > take 10 [n | (p, n + 1) <- zip [2..] (iterate (2 *) 4), iterate (\  s -> (s^2 - 2) `mod` n) 4 !! (p - 2) == 0]
00:28:12 <lambdabot>   [7,31,127,8191,131071,524287,2147483647,2305843009213693951,618970019642690...
00:28:14 <copumpkin> psykotic: I tried your generator earlier and could only get 10 out
00:28:28 <Jafet> That's the most interesting typographical rendition of Lucas-Lehmer I've seen
00:28:35 <psykotic> thanks
00:28:50 <shapr> It's purty :-)
00:29:50 <shapr> psykotic: Thanks!
00:39:05 <psykotic> it's a little disheartening to see the assembly code generated by ghc
00:40:47 <copumpkin> all the more impressive that its output already performs so well :) just think what we could do with a super duper code generator
00:44:55 <Hunner> How can I create a cross of a list with itself?
00:45:10 <ddarius> join (liftM2 (,))
00:46:16 <copumpkin> or for less golf, use a list comprehension :)
00:46:42 <Hunner> oh. duh :)
00:53:03 <Hunner> @hoogle a -> [a -> b] -> [b]
00:53:04 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
00:53:04 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
00:53:04 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:53:35 <dmwit> :t map . ($)
00:53:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:53:44 <dmwit> :t map . flip ($)
00:53:45 <lambdabot> forall a b. a -> [a -> b] -> [b]
00:59:43 <mjrosenb> is there any way to get ghc to treat -> and <- as one character for alignment purposes?
01:00:42 <psykotic> @type maximum . map product . take 5 . transpose .  tails
01:00:43 <lambdabot> forall a. (Ord a, Num a) => [a] -> a
01:00:44 <dmwit> I doubt it.
01:01:13 <Zeiris_> Can you have a multi-argument lambda?
01:01:13 <dmwit> ?check ap (==) (transpose . tails)
01:01:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:01:22 <dmwit> Zeiris_: sure
01:01:37 <dmwit> :t ap (==)
01:01:38 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
01:02:01 <dmwit> ?check ap (==) transpose . tails
01:02:02 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
01:02:37 <dmwit> > transpose (tails [1..5])
01:02:39 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
01:03:02 <dmwit> ?check \xs -> transpose (tails xs) == init (tails xs)
01:03:03 <lambdabot>   "OK, passed 500 tests."
01:03:30 <copumpkin> interesting
01:05:27 <chrissbx> Is there a function to select the most extreme element out of a list with regards to a given comparison function?
01:05:35 <copumpkin> :t maximumBy
01:05:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
01:05:36 <dmwit> :t maximumBy
01:05:37 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
01:05:41 <copumpkin> :)
01:05:42 <chrissbx> Thanks
01:05:50 <copumpkin> EXTREME
01:08:47 <copumpkin> psykotic: have you developed that Bayesian topos idea any more?
01:13:53 <chrissbx> Also, is there a function \f g a b -> g (f a) (f b) already?
01:14:04 <dmwit> :t on
01:14:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:14:10 <copumpkin> damn, he beat me to it
01:14:22 <chrissbx> :) thanks
01:14:26 <dmwit> ?pl \f g a b -> g (f a) (f b)
01:14:26 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
01:14:29 <dmwit> dang
01:14:37 <copumpkin> no glorious stereo this time :(
01:16:14 <copumpkin> chrissbx: ask another!
01:16:24 <chrissbx> lambdabot: what does ?pl do?
01:16:29 <eflister> i'm having trouble understanding the common pattern of defining constructors as a record containing an unwrapper fcn.  in the source for dlist and writer, for example, the unwrapper is used a lot but never defined.
01:16:34 <dmwit> ?wiki Pointfree
01:16:34 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
01:16:35 <copumpkin> chrissbx: gives you the expression in pointfree form
01:16:43 <copumpkin> damn, he even gave a better answer
01:16:44 * copumpkin gives up
01:16:47 <dmwit> heh
01:18:43 <chrissbx> Where can I find on and maximumBy? Or rather, how do I search for then, other than google?
01:18:46 <eflister> does my question make sense?  for example:  newtype DList a = DL { unDL :: [a] -> [a] } -- unDL's type is given, but never defined?
01:18:51 <dmwit> hoogle
01:19:02 <dmwit> ?hoogle maximumBy
01:19:02 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
01:19:03 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
01:19:05 <dmwit> ?where hoogle
01:19:05 <lambdabot> http://haskell.org/hoogle
01:19:28 <copumpkin> @hoogle on
01:19:28 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
01:19:28 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
01:19:28 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
01:19:31 <dmwit> eflister: Record syntax implicitly creates the selector.
01:19:31 <lpsmith> @let newtype L a = L [a]
01:19:31 <lambdabot>  Invalid declaration
01:19:49 <dmwit> eflister: It's just something to know.
01:20:16 <lpsmith> unfortunately maximumBy (compare `on`  ...)   is a bad way to implement maximumOn
01:20:33 <dmwit> data Foo = Foo { a :: Int, b :: String } -- this is very similar to
01:20:38 <dmwit> data Foo = Foo Int String
01:20:43 <dmwit> a (Foo v _) = v
01:20:47 <dmwit> b (Foo _ v) = v
01:21:00 <dmwit> Except that the record syntax also defines modifiers.
01:21:51 <eflister> dmwit: ok that makes sense that there would be a selector called unDL, but it's type would be DL -> [a] -> [a], right?  how does it know what to do?
01:22:22 <dmwit> eflister: Yes, that's its type.
01:22:28 <dmwit> eflister: I'm not sure how to answer the second question.
01:22:53 <eflister> dmwit: i don't get why we don't need to say what particular [a] -> [a] we want
01:22:53 <dmwit> unDL' (DL f) = f -- how does this function know what to do?
01:23:02 <dmwit> eflister: You do... when you build a DList.
01:23:21 <dmwit> DL (\xs -> reverse xs) :: DList a
01:23:23 <dmwit> for example
01:23:34 <lpsmith> @let maximumOn f (x:xs) = loop x (f x) xs where { loop x fx [] = x ; loop x fx (y:ys) = let fy = f y in if fy > fx then loop y fy ys else loop x fx ys }
01:23:36 <lambdabot>  Defined.
01:23:55 <lpsmith> > maximumOn abs [-100..50]
01:23:56 <lambdabot>   -100
01:24:06 <copumpkin> nice
01:24:28 * copumpkin stands on his head
01:24:36 <dmwit> > let maximumOn f = snd . sortBy fst . head . map (f &&& id) in maximumOn abs [-100..50]
01:24:37 <lambdabot>   Occurs check: cannot construct the infinite type:
01:24:37 <lambdabot>    a = (a, b) -> GHC.Orde...
01:24:52 <dmwit> whoops, head too soon!
01:25:03 <dmwit> > let maximumOn f = snd . head . sortBy fst . map (f &&& id) in maximumOn abs [-100..50]
01:25:04 <lambdabot>   Occurs check: cannot construct the infinite type:
01:25:05 <lambdabot>    a = (a, b) -> GHC.Orde...
01:25:13 <dmwit> argh
01:25:22 <lpsmith> > maximumOn abs [-100..100]
01:25:22 <dmwit> > let maximumOn f = snd . head . sortBy (comparing fst) . map (f &&& id) in maximumOn abs [-100..50]
01:25:23 <lambdabot>   -100
01:25:23 <lambdabot>   0
01:25:24 <copumpkin> why not just use maximumBy (comparing `on` fst)
01:25:26 <copumpkin> compare
01:25:38 <dmwit> sure
01:25:55 <lpsmith> copumpkin:   you recompute the fst over and over again;  not that big of a deal in the case of fst,  but
01:26:03 <copumpkin> yeah :P
01:26:14 <dmwit> lpsmith: But you compute the 'f' only once.
01:26:16 <lpsmith> There is not a lot of cost to never recomputing fst
01:26:18 <dmwit> fst is much cheaper than f =)
01:26:20 <copumpkin> > let maximumOn f = snd . maximumBy (comparing fst) . map (f &&& id) in maximumOn abs [-100..50]
01:26:21 <lambdabot>   -100
01:27:01 <lpsmith> dmwit,  what do you mean,  fst is cheaper than f?
01:27:13 <copumpkin> what if f is fst!!!
01:27:27 <dmwit> lpsmith: If you're worried about recomputing an expensive function, it's probably okay to memoize with a tuple.
01:27:35 <copumpkin> > let maximumOn f = snd . maximumBy (comparing fst) . map (f &&& id) in maximumOn fst (zip [5..] [-100..50])
01:27:36 <lambdabot>   (155,50)
01:27:45 <dmwit> lpsmith: That's all I meant.
01:27:50 <lpsmith> ahh
01:27:51 <copumpkin> :P
01:27:52 <lpsmith> true
01:28:03 <lpsmith> but I don't need tuples :)
01:28:15 * copumpkin stops being intentionally stupid and goes back to being unintentionally stupid
01:28:19 <dmwit> No, but if you use tuples, you get to reuse lots of stuff from the standard library.
01:28:21 <copumpkin> lpsmith: yeah but you lose readability
01:29:07 <eflister> dmwit: huh, so when using a dlist, when do i use the DL constructor?
01:29:15 <copumpkin> usually pretty rarely
01:29:22 <lpsmith> @def maximumBy
01:29:22 <lambdabot> Maybe you meant: bf do let
01:29:29 <dmwit> eflister: Probably only indirectly, via fromList and friends.
01:29:52 <copumpkin> is DL even expored?
01:29:54 <copumpkin> exported
01:30:12 <eflister> it says Dlist(..)
01:30:17 <copumpkin> ah ok
01:30:32 <eflister> i see, so toList is setting me up with (++)
01:30:58 <eflister> i mean fromList
01:32:03 <eflister> why is it fromList = DL . (++) instead of fromList = DL (++)  ?
01:32:12 <copumpkin> only one of those works
01:32:26 <copumpkin> DL :: ([a] -> [a]) -> DList a
01:32:36 <copumpkin> :t (++) :: [a] -> [a] -> [a]
01:32:37 <lambdabot> forall a. [a] -> [a] -> [a]
01:33:58 <lpsmith> Well,  the only possible advantage of using the standard definition of maximumBy that I see is the possibility of list fusion,  in some cases.   Who cares about the readability of a library implementation,  too much?   I mean, it's nice,  but what would you sacrifice for readability alone?
01:36:54 <lpsmith> @let maximumOn' f (x:xs) = foldl (\(x, fx) y -> let fy = f y in if fy > fx then (y,fy) else (x,fx)) (x, f x) xs
01:36:56 <lambdabot>  Defined.
01:37:04 <lpsmith> only problem there is that it's not strict enough
01:37:21 <lpsmith> > maximumOn' abs [-100..100]
01:37:22 <lambdabot>   (-100,100)
01:41:00 <chrissbx> why does maximumBy and similar take Ordering instead of Bool?
01:41:08 <chrissbx> When it only checks for GT and _ then?
01:41:44 <copumpkin> it's the more flexible approach, and a Bool would be unclear
01:41:45 <lpsmith> consistency,  I think
01:41:54 <copumpkin> is the Bool greater than? less than?
01:42:00 <copumpkin> greater than or equal to? :P
01:42:03 <lpsmith> although Data.Ord really needs some TLC
01:42:40 <chrissbx> (So I assume there is a replacement for < and >) aha compare
01:42:49 <chrissbx> TLC?
01:42:54 <dmwit> tender, loving care
01:42:55 <lpsmith> tender loving care?
01:46:03 <lpsmith> @let maximals [] = [] ;  maximal xs = last . group . sort $ xs
01:46:04 <lambdabot>  Defined.
01:46:14 <copumpkin> :o
01:46:34 <lpsmith> > maximals (map (^2) [-10..10])
01:46:35 <lambdabot>   * Exception: <local>:6:0-15: Non-exhaustive patterns in function maximals
01:46:43 <lpsmith> hmm
01:46:52 <lpsmith> oops
01:46:59 <lpsmith> @undef
01:47:09 <lpsmith> @let maximals [] = [] ;  maximals xs = last . group . sort $ xs
01:47:10 <lambdabot>  Defined.
01:47:23 <lpsmith> > maximals (map (^2) [-10..10])
01:47:24 <lambdabot>   [100,100]
01:47:40 <lpsmith> Though really,  I find maximalsOn to be quite useful from time to time
01:47:46 <Zeiris_> !hoogle m a -> m b -> m c -> (a -> b -> c -> m d) -> m d
01:48:07 <copumpkin> Zeiris_: liftM3, backwards
01:48:09 <lpsmith> That's a very suboptimal implementation,  though readable :)
01:48:11 <copumpkin> or liftA3
01:48:26 <copumpkin> actually
01:48:33 <lpsmith> > group []
01:48:34 <lambdabot>   []
01:48:48 <copumpkin> :t \x y z f -> join (liftM3 f x y z)
01:48:49 <lambdabot> forall a1 a2 a3 (m :: * -> *) a. (Monad m) => m a1 -> m a2 -> m a3 -> (a1 -> a2 -> a3 -> m a) -> m a
01:49:02 <copumpkin> Zeiris_: ^
01:50:22 <chrissbx> Well, Ordering is nice and dandy, but now I have to inverse it. That's where < and > come in handy :)
01:50:37 <chrissbx> How do I invert Ordering?
01:50:41 <lpsmith> > flip compare 3 2
01:50:42 <lambdabot>   LT
01:50:46 <Zeiris_> So, apparently when people say lists represent non-deterministic/ambiguous calculations they aren't just talking about a way of thinking, but about actually using the List monad to do calculations with many possible results.
01:50:50 <Zeiris_> That's, uh, cool.
01:51:00 <copumpkin> yep
01:51:02 <dmwit> Totally!
01:51:18 <copumpkin> @let msqrt x = [sqrt x, -(sqrt x)]
01:51:18 <lambdabot>  Defined.
01:51:32 <copumpkin> > (msqrt <=< msqrt) 5
01:51:32 <lambdabot>   [1.4953487812212205,-1.4953487812212205,NaN,NaN]
01:51:41 <copumpkin> > (msqrt <=< msqrt) (5 :+ 4
01:51:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:51:43 <copumpkin> > (msqrt <=< msqrt) (5 :+ 4)
01:51:44 <lambdabot>   [1.5681571890361377 :+ 0.26706284823899096,(-1.5681571890361377) :+ (-0.267...
01:51:51 <lpsmith> continuations can be a more efficent,  though more esoteric way of dealing with non-determinism.   It can be algorithmically more efficient to boot.
01:53:11 * copumpkin is too dense to understand codensity
01:54:04 <lpsmith> heh,  it's a challenge.  I'm not sure that many people fully grok it;  I know I don't
01:54:23 <copumpkin> I have a vague idea of it and how it works
01:54:48 <copumpkin> but that's it
01:54:55 <lpsmith> I've seen some pretty well known and knowlegable programmers flub statements regarding continuations
01:55:19 <copumpkin> basic Cont I think I'm pretty comfortable with
01:55:56 <copumpkin> I think Codensity is also related to those damn right Kan extensions edwardk is always talking about :P
01:56:23 <copumpkin> ah, yes
01:56:24 <lpsmith> well,  codensity is extensionally the same,  but the use of the higher-ranked type restricts how it's used.  (although, mysteriously,  allows for mfix)
01:56:56 <lpsmith> basically,  you have no choice but to call the continuation
01:57:00 <copumpkin> yeah
01:57:14 <copumpkin> it's pretty odd that Codensity is a functor without the inner bit being one
01:57:16 <lpsmith> and calling the continuation once and only once;
01:58:04 <lpsmith> I mean,  you can "call" the continuation more than once,  but all you can do is ignore the result,   which means it never gets evaluated
01:58:16 <lpsmith> I suppose Codensity in ML is a slightly different beast
01:58:38 <lpsmith> although the same if you don't use side effects...
01:58:41 <lpsmith> sort of
01:58:43 <ManateeLazyCat> I saw some resource of STM, STM is really beautiful solution to replace MVar!
01:58:53 <ManateeLazyCat> STM never use lock, use ThreadLog free you head.
02:00:06 <Alpounet> with such sentences, STM will take over all the market share in the multithreading world
02:00:09 <ManateeLazyCat> STM is really simple for convert exist code.
02:00:57 <blick> I had a question the other day about compilation....  Suppose I write a lexer and parser, so I have a "String -> [Token]" and "[Token] -> Expr".  If I put a string in my source code, "x::String", could lexing and parsing happen at compile time?
02:01:07 <ManateeLazyCat> You just try to use STM replace IO Monad, when you want IO result, just wrapper `atomically`, that's all.
02:01:16 <blick> (i would be *very* surprised if this happens, but i don't see why it couldn't)
02:03:18 <dmwit> I'm pretty sure that no, it won't happen at compile time.
02:03:31 <dmwit> This is a good thing, as you don't know a priori which functions produce finite results. =)
02:04:26 <copumpkin> it could have a time limit, though
02:04:43 <dmwit> Everybody's favorite answer to the halting problem. =)
02:04:57 <copumpkin> if supero finishes getting integrated into GHC we might see it
02:05:15 <blick> is that what "supercompilation" is?
02:07:15 <ManateeLazyCat> STM will use ThreadLog keep trace action for some Variable, and keep change in ThreadLog, it will check when multi-threads access common Variable concurrently, it will check ThreadLog, if ok, write to memory, otherwise resume origin value, and *re-execute*. So we can use STM write *module* concurrent program, and haven't *locking* trouble by MVar.
02:08:15 * copumpkin should really go to sleep
02:08:24 <dmwit> ManateeLazyCat: That's the idea, yes!
02:08:27 <dmwit> It really seems nice.
02:08:32 <dmwit> ?localtime copumpkin
02:08:33 <lambdabot> Local time for copumpkin is 2010-02-21 05:08:08 -0500
02:08:33 <lpsmith> wouldn't there be a way to do lexing and parsing with those functions at compile time with Template Haskell
02:08:36 <ManateeLazyCat> dmwit: Yes, i love it.
02:09:22 <ManateeLazyCat> dmwit: I think it's really and complete solution for *lock*, *lock* make me crazy and hard to debug.
02:10:15 <dmwit> Now if we could just get hardware support!
02:10:23 <dmwit> HTM would be awesome.
02:10:26 <copumpkin> then STM would be misnamed
02:10:31 <copumpkin> it should just be TM
02:11:00 <shachaf> Huh, each installation of GHC apparently takes up hundreds of megabytes of space. For some reason I assumed they wouldn't. :-)
02:11:03 <ManateeLazyCat> dmwit: If hardware use STM and not *lock*, then have many people study Haskell! :)
02:11:09 <ManateeLazyCat> Kidding.... :)
02:11:25 <lpsmith> preflex,  seen HaskellLove
02:11:25 <preflex>  HaskellLove was last seen on #haskell 17 days, 15 hours, 16 minutes and 54 seconds ago, saying: sm and there are links to "books" basically links to buy yourself one http://web2.comlab.ox.ac.uk/oucl/publications/books/algebra/
02:11:43 <copumpkin> isn't he pokokoN now?
02:11:52 <copumpkin> where N is some number I do not recal
02:11:55 <copumpkin> +l
02:12:02 <lpsmith> Is he?  I dunno
02:12:09 <ManateeLazyCat> dmwit: But i still have problem, if STM always *re-execute* that because *ThreadLog check* always break, how do that?
02:12:56 <dmwit> Yes, it can be slow if there are a lot of conflicts.
02:13:00 <lpsmith> Ahh,  I miss me some HaskellLove excitement and entertainment.
02:13:21 <dmwit> The idea is that you use "atomically" on small chunks of STM, so that they can commit.
02:13:25 <lpsmith> hahaha
02:13:27 <HaskellLove> lpsmith: do you know higher categories and operads?
02:13:32 <dmwit> The smaller, the better -- but make sure they're actually transactions. =)
02:13:34 <lpsmith> no
02:13:43 <lpsmith> :)
02:13:52 <HaskellLove> lpsmith: then u just r writing haskell syntax, not a true ninja!
02:13:59 <ManateeLazyCat> dmwit: But it's easy debugging than *some many lock* trouble? :)
02:14:00 <dmwit> HaskellLove: Don't worry, you can just read a lot and you'll understand and grok them totally.
02:14:10 <HaskellLove> lpsmith: I'm reading a book on operads I started a few minutes ago
02:14:18 <HaskellLove> I'll tell you how it was in an hour
02:14:25 <ManateeLazyCat> dmwit: *Locking* is triesome thing.
02:14:26 <HaskellLove> then I will be ninja
02:15:01 <ManateeLazyCat> dmwit: Infact, Haskell should be drop MVar, use STM replace it completely.
02:15:15 <copumpkin> STM isn't as fast
02:15:23 <copumpkin> having options is good :)
02:15:37 <copumpkin> unless it's the option to index outside of your vector
02:15:43 <copumpkin> then you should have no options
02:16:43 <ManateeLazyCat> copumpkin: Maybe STM is not fastest, but free programmer head. *Deadlock* is fast, is DEAD. :)
02:16:56 <copumpkin> @let fibs = fix ((0:) . scanl (+) 1)
02:16:57 <lambdabot>  Defined.
02:16:58 <ManateeLazyCat> is not fast
02:17:42 <lpsmith> reading an index outside your vector isn't _quite_ as worrisome as writing
02:18:17 * dmwit executes code outside his vector
02:18:28 <copumpkin> > let zomg n = (fibs !! (2 * n - 1), 2 * (fibs !! n) * (fibs !! (n - 1)), (fibs !! n)^2 - fibs !! (n - 1))^2) in zomg 3
02:18:29 <lambdabot>   <no location info>: parse error on input `)'
02:18:46 <copumpkin> > let zomg n = (fibs !! (2 * n - 1), 2 * (fibs !! n) * (fibs !! (n - 1)), (fibs !! n)^2 - (fibs !! (n - 1))^2) in zomg 3
02:18:46 <lambdabot>   (5,4,3)
02:18:51 <copumpkin> > let zomg n = (fibs !! (2 * n - 1), 2 * (fibs !! n) * (fibs !! (n - 1)), (fibs !! n)^2 - (fibs !! (n - 1))^2) in zomg 7
02:18:52 <lambdabot>   (233,208,105)
02:19:03 <copumpkin> > let zomg n = (fibs !! (2 * n - 1), 2 * (fibs !! n) * (fibs !! (n - 1)), (fibs !! n)^2 - (fibs !! (n - 1))^2) in zomg 5
02:19:04 <lambdabot>   (34,30,16)
02:19:16 <dmwit> > sqrt (105^2 + 208^2)
02:19:17 <lambdabot>   233.0
02:19:19 <dmwit> hum
02:19:23 <dmwit> neat =)
02:19:37 <copumpkin> just reading the huge list of random facts about fibonacci numbers on wikipedia :)
02:19:43 <copumpkin> (sleep is for the weak)
02:19:52 * dmwit concurs
02:19:54 <dmwit> ?localtime
02:19:58 <lambdabot> Local time for dmwit is Sun Feb 21 05:19:30 2010
02:20:08 <copumpkin> :D
02:20:50 <ManateeLazyCat> If don't use multi-processes for protect, just use *single* process, haven't any solution to avoid program crash, right?
02:21:38 <ManateeLazyCat> If have solution, i will try to use Haskell Thread, then i can running thousand Threads concurrently.
02:22:15 <dmwit> Well, you can catch exceptions.
02:22:15 <ManateeLazyCat> I mean un-catch exception crash program.
02:22:30 <ManateeLazyCat> dmwit: Hehe, un-catch exception?
02:22:51 <dmwit> :t catch
02:22:52 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
02:22:52 <ManateeLazyCat> dmwit: I want program always running and won't crash.
02:23:11 <ManateeLazyCat> dmwit: I think haven't.
02:23:13 <dmwit> ManateeLazyCat: Threads are nice for that, but not required.
02:23:41 <lpsmith> > quickCheck (\n -> fibs !! (2 * n - 1) == (fibs !! n)^2 + (fibs !! (n - 1))^2)
02:23:42 <lambdabot>   Not in scope: `quickCheck'
02:23:48 <ManateeLazyCat> dmwit: Multi-Processes design will make my program won't crash, but need too much memory.
02:23:58 <lpsmith> > (\n -> fibs !! (2 * n - 1) == (fibs !! n)^2 + (fibs !! (n - 1))^2)  50
02:23:59 <lambdabot>   True
02:24:05 <lpsmith> > (\n -> fibs !! (2 * n - 1) == (fibs !! n)^2 + (fibs !! (n - 1))^2)  30
02:24:06 <lambdabot>   True
02:24:16 <lpsmith> > all (\n -> fibs !! (2 * n - 1) == (fibs !! n)^2 + (fibs !! (n - 1))^2) [1..100]
02:24:17 <lambdabot>   True
02:24:35 <lpsmith> That seems more interesting
02:25:02 <ManateeLazyCat> dmwit: I know Haskell Thread is lightweight, and every thread just use few hundred Bits, really?
02:25:19 <dmwit> Yes, Haskell threads are very light.
02:25:25 <dmwit> Lighter than Erlang, even.
02:25:52 <ManateeLazyCat> dmwit: But thread will be crash. :-(
02:26:05 <dmwit> ?
02:26:44 <ManateeLazyCat> dmwit: If a program have few threads, any thread throw un-catch exception will make all program crash.
02:27:04 <dmwit> That doesn't sound right.
02:27:13 <domor> ManateeLazyCat: what does your program do?
02:27:27 <ManateeLazyCat> domor: Platform
02:27:37 <ManateeLazyCat> dmwit: ?
02:27:46 <domor> a server?
02:27:53 <ManateeLazyCat> domor: OS
02:28:15 <ManateeLazyCat> dmwit: Haskell has any speical solution for protected program won't crash?
02:29:05 <dmwit> ManateeLazyCat: I'm so confused.
02:29:12 <dmwit> You can catch exceptions in a single thread.
02:29:20 <dmwit> And exceptions that get thrown in a thread don't affect any other threads.
02:29:25 <ManateeLazyCat> dmwit: You know Google Chrome?
02:29:41 <dmwit> Are you asking about separate *processes*?
02:29:48 <dmwit> That's a very different story.
02:30:04 <dmwit> And Haskell doesn't have lighter process creation than any other language, since that's an OS thing, not a library thing.
02:30:15 <domor> ManateeLazyCat: but if you make an OS , aren't you the one implementing the threads?
02:31:33 <ManateeLazyCat> dmwit: Yep, i mean separate *processes*.
02:31:49 <ManateeLazyCat> domor: Not OS like Linux.
02:31:55 <ManateeLazyCat> domor: :)
02:32:03 <ManateeLazyCat> domor: I called it SoftOS.
02:32:22 <ManateeLazyCat> domor: Base on Linux kernel and Gtk+/Haskell.
02:32:36 <mjrosenb> if i haave a class that gives a prototype for a function, foo
02:32:40 <ManateeLazyCat> domor: Build GTK+ application Platform.
02:32:41 <dmwit> ManateeLazyCat: For separate processes, STM vs. MVar is a meaningless argument.
02:33:13 <ManateeLazyCat> dmwit: I know
02:33:22 <ManateeLazyCat> dmwit: I use DBus for multi-processes communication
02:33:31 <mjrosenb> is there any way to instantiate the class and have foo be instantiated using a selector from a datatype?
02:33:48 <ManateeLazyCat> dmwit: Then use STM for multi-threads communication in Process. :)
02:36:21 <ManateeLazyCat> dmwit: Bye, need dinner for my Haskell belly. :)
02:55:03 <eflister> i have an MVar that i use to sequence some events.  if there are conditions under which the contents of the MVar are not used, can i depend on readMVar actually running (and blocking until the appropriate time?)  it seems it could lazily decide not to...
02:56:05 <dmwit> Oh, yes.
02:56:37 <eflister> yes i can depend on it to block?
02:56:58 <dmwit> yes
02:57:13 <eflister> how come it's not lazy?
02:57:36 <dmwit> The value you get out of the MVar is lazy, of course.
02:57:48 <eflister> hm, cool
03:28:14 <ClaudiusMaximus> why can't i mix C++ and Haskell in the same literate source file? GHC gives a lexical error :( http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7943#a7943
03:31:05 <ben> Presumably the # is magical
03:32:20 <ben> Try wrapping the include in > {- and > -}
03:33:42 <tensorpudding> though doing that will probably make it no longer compile with g++
03:35:14 <monadic_kid> trying using a digraph/trigraph :D
03:35:46 <monadic_kid> "??=" == "#"
03:36:16 <ClaudiusMaximus> ben: that works, provided i enclose the > {-  and > -}  each in /* and */ as tensorpudding suggests
03:36:45 <ClaudiusMaximus> trigraphs might make more sense given the amount of extra empty lines needed...
03:41:37 <xpika> has anyone here built gtk2hs using the haskell package on osx 10.6?
04:11:44 <opqdonut> can I somehow override the export list of a module in ghc
04:11:45 <opqdonut> i
04:12:07 <opqdonut> i have this module that exports a very strict interface but i'd like to play around with the insides in ghci
04:13:03 <dmwit> The default is to import all the symbols, even ones not exported by the module.
04:13:16 <dmwit> However, to get this default, you have to interpret the file.
04:13:27 <dmwit> The easiest way to do this is to delete the .o, if you have one.
04:17:13 <opqdonut> dmwit: ah
04:25:06 <Zeiris_> @hoogle ((a,b)->(a,m b)) -> [(a,b)] -> m (a,b)
04:25:06 <lambdabot> No results found
04:26:06 <chrisdone> BONUS_: bump
04:28:45 <opqdonut> this is probably not a new invention: build :: [Tree] -> Tree; build ts = tree where [tree] = f ts; f [] = []; f [x] = [x]; f (l:r:ts) = f (Node l r : f ts)
04:28:55 <opqdonut> but i'm pretty proud :)
04:31:38 <tobe> hi, I want to translate a list Integers to a list of Nats by using mapM. I wrote the toEnum function from Integers to Nats. How do I have to use it now?
04:32:13 <damd> map toEnum [1..]
04:33:31 <damd> hm, or maybe "(map toEnum [1..]) :: [Nat]"
04:34:53 <Jafet> Or just [1..]::[Nat]?
04:36:04 <Zeiris_> Any tips on debugging those "The last statement in a 'do' construct must be an expression" compiler errors?
04:36:22 <Zeiris_> I think I'm using all the variables I 'define' with <- :\
04:36:37 <damd> got a paste?
04:36:41 <Botje> Zeiris_: can you pastebin your code?
04:36:45 <Zeiris_> It won't be pretty, but okay.
04:36:45 <Botje> it's probably an indentation error.
04:37:06 <tobe> damd: thanks, that works. I missed the brackets :)
04:37:17 <CalJohn> Zeiris_: make sure that it's not intentation and ensure that the last statement actually is an expression :)
04:37:23 <damd> tobe: you might want to try Jafet's suggestion, i don't know
04:37:56 <Zeiris_> do construct must be expression at 17:8    http://pastebin.com/m1ff47192
04:38:34 <CalJohn> a pattern match is not an expression
04:39:26 <Zeiris_> Which line is the pattern match?
04:40:00 <Zeiris_> Or do you mean that I can't throw in the 'where f = ...' thing in the middle of a do ... like that?
04:40:13 <Botje> you can't, no
04:40:54 <Botje> also, you should try to push some of your definitions outside of the do bloc
04:40:54 <Botje> k
04:41:19 <Zeiris_> I should do a lot of things :(
04:42:12 <Botje> well, it will sove your parser error here ;)
04:42:37 <Botje> *solve
04:45:42 <CalJohn> Zeiris_: http://pastebin.com/m562a76c1 <-- some changes which I think bring it significantly closer to compiling
04:45:59 <Zeiris_> CalJohn, sorry, I shoulda mentioned that I got it to compile :)
04:46:09 <CalJohn> i've merged all the lets, removed a where, and changed [Pos,Int] to [(Pos,Int)]
04:46:11 <CalJohn> oh
04:46:22 <CalJohn> well, i don't have the rest of your types anyway
04:46:23 <Zeiris_> That does make it a good deal prettier though.
04:53:10 <tobe96> damd: a problem now is, that the function should be ints2nats :: [Int] -> Maybe [Nat] because it should output Nothing if there is a negative Integer in the list
04:56:54 <Botje> map (\x -> if x < 0 then Nothing else Just (toNat x))
04:59:29 <damd> inefficient: ints2nats xs = if any (< 0) xs then Nothing else Just $ map toNat xs
04:59:48 <Jafet> map (\x -> if x >= 0 then toNat x else head [])
04:59:59 <Botje> oh, if there's one in the list ..
05:00:25 <damd> Jafet: what?
05:00:43 <Botje> sequence $ map (\x -> if x < 0 then Nothing else Just (toNat x))
05:01:21 <damd> @src sequence
05:01:21 <lambdabot> sequence []     = return []
05:01:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:01:21 <lambdabot> --OR
05:01:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:02:31 <dmwit> :t mapM (\x -> guard (x >= 0) >> return x)
05:02:32 <lambdabot> forall a (m :: * -> *). (Num a, Ord a, MonadPlus m) => [a] -> m [a]
05:03:00 <dmwit> mapM (\x -> guard (x >= 0) >> return (toNat x)) -- should do what you want
05:03:16 <tobe96> me?
05:03:25 <dmwit> yes
05:04:06 <Botje> heh, cool
05:22:32 <osaunders> What is Z in denotational semantics called?
05:30:12 <kw317> osaunders: the integers? why would it have any special name?
05:30:23 <osaunders> Yeah, dw.
05:30:30 <osaunders> I didn't know it meant integers. I do know.
05:30:36 <osaunders> *now
05:31:13 <kw317> if you're doing denotational semantics, then I recommend winskel's book
05:35:02 <monadic_kid> Z is the typical letter for the SET of integers. It's uppercase to denate it's a set
05:35:34 <monadic_kid> *denote
05:36:26 <monadic_kid> instead of lowercase for a scalar variables
05:39:16 <monadic_kid> R is set of reals, R^2 set of cartesian product of reals.
05:40:08 <monadic_kid> R^3 set of  R x R x R, and so on
05:41:02 <monadic_kid> kw317: does that make sense now?
05:43:30 <benmachine> > mapM (\x -> toNat x <$ guard x >= 0)
05:43:31 <lambdabot>   Not in scope: `toNat'Precedence parsing error
05:43:31 <lambdabot>      cannot mix `Control.Appl...
05:43:42 <benmachine> :t \toNat -> mapM (\x -> toNat x <$ guard x >= 0)
05:43:43 <lambdabot>     Precedence parsing error
05:43:43 <lambdabot>         cannot mix `<$' [infixl 4] and `>=' [infix 4] in the same infix expression
05:43:47 <benmachine> bah
05:43:51 <benmachine> :t \toNat -> mapM (\x -> toNat x <$ guard (x >= 0))
05:43:52 <lambdabot> forall a b (m :: * -> *). (Num a, Ord a, MonadPlus m, Functor m) => (a -> b) -> [a] -> m [b]
05:44:44 * benmachine thinks a flipped <$ would be useful for such cases
05:52:36 * hackagebot upload: hprotoc 1.7.0 - Parse Google Protocol Buffer specifications (ChrisKuklewicz)
05:53:50 <osaunders> Huh, this sounds wrong. http://en.wikibooks.org/wiki/Haskell/Denotational_semantics says "The intuition is that every partial function g should yield more defined answers for more defined arguments"
05:54:21 <osaunders> But isn't it less defined answers for more defined arguments?
05:54:40 <osaunders> g(_|_) can't be 1. But g(1) can be _|_
05:54:54 <Jafet> Why not
05:54:55 <xerox> g = const
05:55:09 <xerox> g = const 1 -- I mean
05:55:21 <osaunders> Jafet: Because _|_ isn't a real value. A function can't really accept it.
05:55:40 <dmwit> nonsense
05:55:48 <Jafet> It is a placeholder.
05:56:01 <cebewee> osaunders: A function can accept it, if it discards the argument
05:56:39 <Jafet> something_which_triggers_segfault would be _|_.
05:56:47 <osaunders> Doesn't _|_ signify the absence of value though?
05:56:57 <xerox> it stands for either error or nontermination
05:57:08 <osaunders> Right, so how can you pass it as a valid argument?
05:57:35 <osaunders> In the case of nontermination.
05:57:37 <cebewee> f = f
05:57:37 <Jafet> > let g = const 1 in g $ sum [1..]
05:57:38 <lambdabot>   1
05:57:39 <dmwit> Don't get hung up on eagerness. =)
05:57:40 <xerox> > let loopy = loopy; g x = const 1 x in g loopy
05:57:41 <lambdabot>   1
05:59:41 <osaunders> I don't understand what's happening xerox's example
05:59:48 <xerox> same as Jafet's
06:00:17 <xerox> Haskell evaluates only the stuff it needs in order to compute the answer
06:01:09 <Twey> @src const
06:01:09 <lambdabot> const x _ = x
06:01:19 <Twey> The second argument is never used, so it's never evaluated
06:01:22 <osaunders> Why is it producing loopy though?
06:01:28 <Twey> It's producing 1
06:01:44 <Twey> loopy is an infinite loop; if evaluated, it would cause the program to not terminate
06:01:48 <osaunders> Oh!
06:01:54 <xerox> > let loopy = loopy in loopy
06:01:58 <osaunders> Line wrapping is confusing me.
06:01:58 <lambdabot>   mueval-core: Time limit exceeded
06:02:10 <osaunders> It's OK, I was just reading it wrong.
06:02:23 <xerox> widen the terminal :D
06:02:27 <Twey> Heh
06:02:42 <osaunders> Yeah, hehe
06:02:42 <Twey> > fix id
06:02:46 <osaunders> Makes sense now! :D
06:02:46 <lambdabot>   mueval-core: Time limit exceeded
06:04:53 <osaunders> Can you test is a value is _|_?
06:04:57 <osaunders> *if a
06:05:00 <Twey> No
06:05:05 <Twey> Because to test it would require evaluating it
06:05:11 <dmhouse> Sort of.
06:05:15 <Twey> (or solving the halting problem)
06:06:00 <capitrane>  
06:06:01 <dmhouse> Well actually no.
06:06:24 <dmhouse> (I had in mind a scheme which would get you a non-bottom value if the argument was non-bottom, and bottom otherwise, but this is no better than id.)
06:06:38 <Twey> Yeah :þ
06:07:54 <osaunders> So g(_|_) can only produce 1 if it doesn't have to evaluate it's argument.
06:08:41 <dmhouse> Yeah, f _|_ != _|_ is pretty much the definition of a lazy function
06:09:08 <osaunders> Hm, yeah.
06:10:29 <osaunders> I still don't really understand what "The intuition is that every partial function g should yield more defined answers for more defined arguments" means,
06:11:33 <osaunders> Does denotational semantics only describe lazy languages?
06:11:40 <dmwit> No.
06:11:55 <dmwit> However, this stuff applies only to lazy languages.
06:12:07 <osaunders> In an eager language g _|_ must be _|_ always.
06:12:37 <osaunders> Although I don't think you could ever get as far as to attempt to apply g.
06:12:45 <Twey> Hmm
06:12:56 <dmwit> Yes, in an eager language, no part of the input may be undefined, so the definedness relation is uninteresting.
06:13:14 <dmwit> Luckily, we are not in an eager language. =)
06:13:26 <dmwit> So there is something interesting to be said about how defined a value is.
06:14:04 <osaunders> Was denotational semantics created to help reason about lazy languages?
06:14:12 <osaunders> Or did it exist before them.
06:14:38 <dmwit> This is the kind of thing that I should know.
06:14:40 <dmwit> (but don't)
06:16:18 <osaunders> http://en.wikipedia.org/wiki/Denotational_semantics#Development_of_denotational_semantics
06:17:22 <osaunders> "[...] work has continued in investigating appropriate denotational semantics for aspects of programming languages such as sequentiality, concurrency, non-determinism and local state."
06:17:51 <osaunders> I'm going to draw from that: The characteristics of programming languages is driving the development of denotational semantics.
06:18:18 <Jafet> Well, I can't really think of any other use case
06:18:21 <mreh> am I going to get job adverts over haskell@haskell.org?
06:21:39 <mreh> I want to get job adverts when they arrive
06:22:04 <Saizan_> they generally go to -cafe too
06:23:15 <mreh> if that's a yes, then goody, I think I'll just read the -cafe logs
06:24:21 <Saizan_> osaunders: the treatment of partial information (i.e. more or less defined values) is used to give a proper treatment of recursion too
06:26:22 <Saizan_> osaunders: and the order of definedness for functions matters in eager languages too, it just means that they give defined outputs for more inputs
06:27:12 <luite> does this partial order have a name: I have tuples x = (x_1, ...., x_n) with each element real. x <= y iff forall i \in [1..n]: x_i <= y_i
06:28:13 <opqdonut> i've herad it called something like "strictly less than"
06:28:43 <dmwit> luite: pointwise less than?
06:28:55 <luite> opqdonut: hmm, but it's not really strict, because x=y also implies x<=y in the partial order
06:29:31 <opqdonut> luite: well not strict in that sense
06:29:34 <luite> dmwit: hmm, sounds good
06:29:40 <Saizan_> i'd use a name like "radial"
06:29:41 <kw317> luite: isn't this lexicographic order?
06:29:46 <opqdonut> pointwise sounds good
06:29:54 <luite> kw317: the lexicographic order is a total order
06:29:54 <opqdonut> kw317: no, it's not an ordering
06:29:56 <opqdonut> only a partial
06:30:42 <Saizan_> in lexicographic (1,2,3) < (1,1,4)
06:30:55 <kw317> ah, true, my bad
06:31:05 <kw317> pointwise sounds good indeed
06:34:48 <tobe96> can someone give me an example for how to implement mapM for [Int] -> Maybe [Nat] by using toEnum from Int to Nat
06:35:04 <dmwit> eh?
06:35:08 <dmwit> Didn't we do this one already?
06:35:18 <tobe96> i didn't get it working
06:36:28 <Jafet> IRC is purely functional -- if you ask the exact same question, expect the exact same answer.
06:36:37 <tobe96> i want to do it like that map (toEnum [1,2,3,4]) ::[Nat]
06:36:38 <tobe96>  but that issn't wokring with the Maybe
06:36:41 <dmwit> Tell us more about what you've tried, and how it failed.
06:36:45 <tobe96> or doesn't it work that way
06:37:40 <Jafet> toEnum probably won't like being passed a list
06:38:04 <tobe96> yeah
06:38:26 <sieson> How do you add elements to a list that contains a user defined data structure? ( I am a newbie)
06:38:45 <Jafet> Give an example.
06:38:54 <opqdonut> sieson: exactly as you would to any other list
06:39:03 <opqdonut> so with ++ or :
06:39:30 <opqdonut> inserting in the middle of the list is a bit harder, and you shouldn't do that anyway :)
06:40:22 <sieson> opqdonut: so how do I define a function to add the given element to my list? like add (x:xs) = x ++ add xs ???
06:40:25 <tobe96> and I didn't understand the guad-things form dmwit
06:40:59 <dmwit> sieson: (:) *is* the function to add the given element to your list.
06:41:06 <dmwit> sieson: There's no need to define anything.
06:42:19 <sieson> dmwit: I want to be able to add to my list from the command line. i.e ask the user to enter an element and then add it to the list. So I need to define a function don't i?
06:42:39 <CalJohn> sieson: how and where are you learning haskell?
06:42:58 <mreh> (:) is the list constructor
06:43:06 <sieson> CalJohn: By practice and using haskell's .org tutorials
06:43:11 <kw317> CalJohn: hi
06:43:18 <CalJohn> kw317: hello
06:43:22 <kw317> sieson: check learnyouahaskell.org
06:43:32 <dmwit> sieson: What would you want your function to do that (:) doesn't do?
06:43:37 <kw317> s/.org/.com/
06:44:15 <CalJohn> dmwit: he is trying to create a command line program that will add and remove elements from an array.  it's a post-"Hello, World!" program
06:44:23 <dmwit> Yep, I got that.
06:44:25 <npouillard> @qc \k1 \k2 xs -> take k1 . drop k2 $ xs == drop k2 . take (k2 + k1) $ xs
06:44:26 <lambdabot> Not enough privileges
06:44:30 <sieson> dmwit: I want my function to get the element that I want to add to the list and then add it to the list.
06:44:41 <sieson> CalJohn: yes thats right
06:44:56 <CalJohn> dmwit: well, then I don't understand how your question was going to elucidate the situation any?
06:45:42 <opqdonut> @qc \k1 k2 xs -> take k1 . drop k2 $ xs == drop k2 . take (k2 + k1) $ xs
06:45:42 <dmwit> It's not clear to me that sieson understands what (:) does. I was trying to get him to think about it, but perhaps I was too roundabout. =)
06:45:42 <lambdabot> Not enough privileges
06:45:48 <opqdonut> @scheck \k1 k2 xs -> take k1 . drop k2 $ xs == drop k2 . take (k2 + k1) $ xs
06:45:49 <lambdabot>   Couldn't match expected type `a -> b'
06:45:54 <CalJohn> sieson: right, so, in Haskell, you use something called do-notation to do "IO" work.  If you look that up, you might find an example you can use to get a little more clarity
06:46:02 <kw317> dmwit: I think he wants to escape IO ;-)
06:46:12 <opqdonut> @scheck \k1 k2 xs -> (take k1 . drop k2 $ xs) == (drop k2 . take (k2 + k1) $ xs)
06:46:13 <lambdabot>   "Falsifiable, after 16 tests:\n5\n-6\n[(),(),(),()]\n"
06:46:18 <dmwit> ?go the io monad for people who just don't care
06:46:18 <lambdabot> Maybe you meant: google googleit do
06:46:20 <opqdonut> npouillard: there, :)
06:46:22 <dmwit> ?google the io monad for people who just don't care
06:46:23 <lambdabot> No Result Found.
06:46:27 <dmwit> bleh
06:46:38 <opqdonut> @scheck \k1 k2 xs -> k1+k2 < length xs ==> (take k1 . drop k2 $ xs) == (drop k2 . take (k2 + k1) $ xs)
06:46:39 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:46:39 <lambdabot>                     (Test.QuickCh...
06:46:43 <CalJohn> sieson: the program is that you are obviously very new, and perhaps you haven't noticed many things about this language which are different from others
06:46:48 <kw317> sieson: could you try to give us a type of the thing you want?
06:46:48 <opqdonut> hmmh
06:46:54 <dmwit> sieson: You might like http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
06:47:10 <npouillard> opqdonut: thks
06:47:11 <CalJohn> i would suggest you now pick some book for other structured learning document to learn from, like the link kw317 posted
06:47:14 <CalJohn> :)
06:47:35 <Heffalump> opqdonut: there's no point in using ==> with small check, because it won't do anything differently for x ==> y compared to not x || y
06:47:51 <opqdonut> @scheck \k1 k2 xs -> k1+k2 < length xs ==> (take k1 . drop k2 $ xs) == (drop k2 . take (k2 + k1) $ xs))
06:47:51 <lambdabot>  Unbalanced parentheses
06:47:53 <dmwit> sieson: On the other hand, you might also like to skip I/O for a while, and focus on writing pure functions instead. =)
06:47:54 <opqdonut> gah
06:48:00 <sieson> kw317: this is the type of my list books :: [BookData] -> [BookData] and I want to add to it elements
06:48:07 <opqdonut> @scheck \k1 k2 xs -> k1+k2 >= length xs || ((take k1 . drop k2 $ xs) == (drop k2 . take (k2 + k1) $ xs))
06:48:07 <lambdabot>   "Falsifiable, after 30 tests:\n4\n-4\n[(),(),(),(),(),(),(),(),()]\n"
06:48:13 <opqdonut> oh, positive too
06:48:16 <kw317> sieson: that user typed in?
06:48:31 <npouillard> opqdonut: yes positives
06:48:37 <Vitka> Non-exhaustive pattern means it cannot pick from several patterns, right?
06:48:41 <sieson> kw317: what do you mean?
06:48:50 <dmwit> Vitka: No, it means none of the patterns matched.
06:48:56 <Vitka> Hmm.
06:48:58 <sieson> dmwit: sure but I didn't know that adding to a list involves IO business.
06:49:14 <dmwit> sieson: Getting something that the user typed in involves IO.
06:49:38 <dmwit> sieson: Just adding to the list is easy: it's (:), as we've said several times. =)
06:49:39 <kw317> sieson: you mentioned something about reading stuff from command line " ask the user to enter an element and then add it to the list"
06:50:06 <kw317> sieson: first of all, you need something of the type BookData -> [BookData] -> [BookData]
06:50:31 <kw317> sieson: it takes a new BookData entry, and the list of BookDatas and add this new entry to the list it returns
06:50:38 <sieson> dmwit: Ok, I will try to find some other way to do this. But what happens to the side effect free business? If I can add to the list I am changing the state.
06:50:47 <kw317> sieson: if you look at the type of cons (:) :: a -> [a] -> [a]
06:50:58 <sieson> kw317: so I got the type wrong?
06:51:10 <dmwit> sieson: Hm?
06:51:20 <McManiaC> how do you use bang patterns with data definitions? "data Foo = Foo !Int !Bool" gives me an "Unexpected strictness annotation" error
06:51:21 <sieson> kw317: that was the type of my list. Is that wrong?
06:51:35 <dmwit> sieson: (:) is a function that takes two immutable values and returns a new immutable value constructed from them. There are no side effects here.
06:51:36 <dmhouse> McManiaC: try {-# LANGUAGE BangPatterns #-} at the top of your file.
06:51:43 <kw317> sieson: [BookData] is fine
06:51:55 <kw317> oh, wait
06:52:01 <sieson> kw317: I thought I don't need to define the type of the fucntion as haskell can find it itself?
06:52:23 <dmwit> McManiaC: Works here. Are you sure you're looking at the right line?
06:52:46 <kw317> sieson: your books is a function, why?
06:52:49 <dmwit> dmhouse: BangPatterns is something else.
06:52:57 <Vitka> I'm trying to continue my stuff from yesterday, I have two recurrence formulas that look like f (x+1) y and f x (y+1) plus f 0 0, f 0 1 and f 1 0 base cases. I'm getting non-exhaustive patterns error while trying to evaluate anything but base cases. Can anyone tell me if I'm missing something?
06:52:59 <kw317> sieson: sorry I only just looked at this properly
06:53:05 <dmhouse> dmwit: oh, oops, you're right.
06:53:13 <sieson> kw317: its not a function. books is a list
06:53:18 <kw317> sieson: books is supposed to be a list of BookData, right?
06:53:22 <dmhouse> Vitka: it might be exhaustive but the compiler can't figure that out
06:53:28 <sieson> kw317 : yes
06:53:34 <kw317> sieson: " type of my list books :: [BookData] -> [BookData]"
06:53:41 <dmhouse> Vitka: well, it might not be (e.g. have you accounted for negative arguments?)
06:53:50 <kw317> sieson: that is a function from the list of BookData to a list of BookData
06:54:06 <McManiaC> dmhouse, dmwit: is this also possible with newtype/types?
06:54:12 <dmwit> Vitka: I recommend that you avoid (n+k) patterns. They do very, very strange things.
06:54:23 <dmhouse> Vitka: p.s. you shouldn't use the f (n+k) patterns. They're going in the next version of Haskell
06:54:27 <dmwit> McManiaC: newtypes don't have a constructor at runtime, so strictness annotations don't make sense
06:54:38 <McManiaC> okay
06:54:39 <dmhouse> McManiaC: newtypes are strict anyway
06:54:41 <dmwit> McManiaC: types are just macro-expanded, so strictness annotations don't make sense there either
06:54:45 <sieson> kw317: but I saw an example which defined the list type like that. So whats the correct type?
06:55:14 <kw317> sieson: a type of list of BookData is [BookData]
06:56:01 <Vitka> At that point I'm just trying to get stuff to work. As for negative arguments, that's a good point, I'll see if I've missed it.
06:56:10 <kw317> sieson: if you want some function that adds an entry to a list of entries, then you need something like extend :: BookData -> [BookData] -> [BookData]
06:56:44 <dmhouse> Vitka: the exhaustive patterns warning can generally be ignored if you know they're actually exhaustive
06:56:58 <dmwit> I doubt it's a warning.
06:57:00 <sieson> kw317:  ah right, I got it. Thanks for the help. I'll change the type thats why I was getting all those errors.
06:57:06 <dmwit> He's probably talking about the runtime exception.
06:57:13 <dmhouse> Ah.
06:57:32 <dmhouse> Then you're probably accidentally passing a negative value, Vitka.
06:57:36 <dmwit> It's nearly impossible to tell for sure without the actual code, though. =)
06:57:40 <Vitka> Function shouldn't take negative arguments at all, and I have this error while trying positive Int arguments that are supposed to go in there.
06:57:51 <dmwit> ?hpaste
06:57:51 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:57:52 <Vitka> I'll paste the code.
06:58:08 <Twey> 14:54:10 < dmwit> Vitka: I recommend that you avoid (n+k) patterns. They do very, very strange things.
06:58:13 <Twey> dmwit: What sort of strange things?
06:58:32 <dmwit> > let f (n+1) = n; f 0 = 0 in f (-1)
06:58:33 <lambdabot>   * Exception: <interactive>:1:153-172: Non-exhaustive patterns in function f
06:58:47 <kpreid> there's un-clarity about whether + is a variable or a n+k pattern, too
06:59:05 <dmwit> > let f 0 = 0; f n = (n-1) in f (-1)
06:59:06 <lambdabot>   -2
06:59:14 <dmwit> Twey: weird, huh?
06:59:16 <Twey> Ah, they only work for… nat…u…rals?
06:59:22 <Twey> Wait what?  xD
06:59:45 <Vitka> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7959
06:59:51 <Twey> > let f (n + 1) = n in f (-1)
06:59:52 <lambdabot>   * Exception: <interactive>:1:145-157: Non-exhaustive patterns in function f
06:59:57 <Twey> > let f (n + 1) = n in f (-2)
06:59:58 <lambdabot>   * Exception: <interactive>:1:145-157: Non-exhaustive patterns in function f
07:00:00 <Twey> Yeah
07:00:14 <dmwit> > let f (n+2) = n; f 0 = 0 in f 1
07:00:15 <lambdabot>   * Exception: <interactive>:1:153-172: Non-exhaustive patterns in function f
07:00:20 <dmwit> surprise!
07:00:32 <Twey> Arrgh
07:00:38 * Twey swears off n+k patterns
07:01:16 <Vitka> For now it's, what is it called, boilerplate?
07:02:22 <Twey> > let f (subtract 2 -> n) = n in f (-2)
07:02:23 <lambdabot>   Illegal view pattern:  (subtract 2 -> n)
07:02:24 <lambdabot>  Use -XViewPatterns to enable view...
07:02:33 <Twey> Curse you, lambdabot!
07:02:40 <Twey> But anyway, much nicer.  :þ
07:02:51 <dmwit> Vitka: Please paste enough code that we can test it ourselves.
07:03:07 <dmwit> Vitka: As well as an input that should work but doesn't. =)
07:03:40 <dmwit> I suspect it will be as easy as moving the (+k) patterns to the top, though.
07:04:08 <Vitka> Hmm.
07:04:22 <Sternmull> hi
07:09:08 <Sternmull> Can someone help me to define a datatype in ghci? When i do "data Blah = Blah A | B" it sais "parse error on input `data'".
07:09:19 <CalJohn> i don't think you can, sorry :(
07:09:21 <dmwit> You have to put it in a file.
07:09:37 <Sternmull> oh, so there is no way to do it interactively?
07:09:46 <Vitka> Moving + patterns to top didn't work, here is the code that should be runnable: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7959#a7961 I crammed every used function there.
07:09:48 <MaciejP> Hi! Is there a SQL package that includes an escape function for user input?
07:10:00 <Saizan_> Sternmull: no
07:10:08 <Sternmull> ok. Thanks.
07:10:26 <Saizan_> Sternmull: there's :r which reloads the last loaded file though :)
07:10:50 <Sternmull> thanks. So i will go and put it in a file :)
07:11:18 <benmachine> Sternmull: you can use :e to open the current module in an editor
07:11:23 <benmachine> and then add the datatype
07:11:36 <benmachine> and then use :r to reload it (although this nukes your ghci let-bindings)
07:11:57 <dmwit> Vitka: And how can I trigger the problem?
07:11:59 <Sternmull> at the moment i hav not opened any file. Just wanted to quickly try something.
07:12:47 <Vitka> Any input that is not base case, i1 and i2 being 00, 01 and 10.
07:13:00 <Vitka> All other arguments are Doubles.
07:14:12 <dmwit> Vitka: So, for example, you expect f 2 2 0 0 0 0 to work?
07:16:53 <Vitka> I'm trying to get overlapInt to work. I'll probably useless answer or even NaN in your case, but I'm concerned with pattern matching at this point.
07:17:21 <dmwit> Vitka: overlapInt and f mutually recurse until i1 and i2 are both zero.
07:17:37 <dmwit> Vitka: At that point, f calls overlapInt with a negative argument.
07:17:47 <dmwit> Vitka: So I suggest again: don't use (n+k) patterns.
07:17:51 <dmwit> They will hose you every time.
07:17:55 <zachk> what is overlapInt?
07:18:10 <dmwit> zachk: See Vitka's paste.
07:18:19 <Vitka> Hmm.
07:20:08 <Vitka> So if I avoid n+k pattern, there will be two "overlapInt i1 i2 a b x1 x2"s, will it even work?
07:20:36 <dmwit> Use guards.
07:20:41 <zachk> why are (n+k) patterns bad?
07:20:47 <Sternmull> Another question: Is there a "standard-way" to create a copy of a data structure where some components are updated? I need something that allows me to update parts of a state structure.
07:21:03 <Vitka> Hmm.
07:21:13 <Twey> > let f (n + 2) = n in f 1 -- zachk
07:21:14 <lambdabot>   * Exception: <interactive>:1:141-153: Non-exhaustive patterns in function f
07:21:15 <monadic_kid> Sternmull: record update pattern
07:21:26 <Sternmull> thanks, i will google for that
07:21:30 <dmwit> Sternmull: It depends on the data structure. Each structure has its own update functions.
07:21:32 <benmachine> zachk: they are surprising
07:21:34 <osaunders> What are denotational semantics for?
07:21:42 <benmachine> surprising is bad
07:22:14 <Twey> Surprisingly partial
07:22:15 <osaunders> I mean, how will it help me to know about them?
07:22:34 <Sternmull> dmwit; i think i will need "data" types that contain things that would be variables in an imperative language.
07:22:50 <monadic_kid> Sternmull: hold on i'll show u an example
07:26:46 <batmanmen> http://tiny.cc/pSIOC
07:27:05 <benmachine> > let f (n+1) = n in f 1
07:27:05 <lambdabot>   0
07:27:37 <monadic_kid> Sternmull: http://haskell.pastebin.com/d58051b52
07:27:42 <benmachine> let f m = let (n+1) = m in m in f 1
07:27:46 <benmachine> > let f m = let (n+1) = m in m in f 1
07:27:47 <lambdabot>   1
07:27:51 <benmachine> whee
07:27:53 <benmachine> wait
07:28:01 <benmachine> > let f m = let (n+1) = m in n in f 1
07:28:02 <lambdabot>   0
07:28:06 <Saizan_> osaunders: they are for reasoning about your code, proving things about your programs, writing interpreters, etc..
07:28:07 <benmachine> hmm
07:28:11 <benmachine> > let f m = let n+1 = m in n in f 1
07:28:11 <lambdabot>   n
07:28:16 <benmachine> heh
07:28:35 <benmachine> oh right, so
07:29:17 <benmachine> > let foo = 7; (bar + 3) = foo; baz + 3 = foo in (bar, baz)
07:29:17 <lambdabot>   Not in scope: `baz'
07:29:24 <Sternmull> thanks monadic_kid, i think that is exactly what i need
07:29:27 <benmachine> ^ that is why n+k is evil
07:29:40 <monadic_kid> no worries
07:31:38 <Saizan_> osaunders: in general, a denotational semantic is an evaluation function from the language to some simpler model, i.e. one for which you can have a reasonably simple axiomatic semantic
07:33:59 <osaunders> Saizan_: OK. If I'm not interested in proving correctness (yet) or writing interpreters is denotational semantics any use to me?
07:35:53 <Saizan_> osaunders: "interpreters in denotational semantics" doesn't make much sense
07:36:23 <osaunders> Saizan_: That's not a quote
07:36:40 <Saizan_> ah, ok, parsed it wrong then :)
07:36:56 <osaunders> Probably should be a comma before "is".
07:37:06 <Saizan_> ah, is
07:37:13 <Saizan_> sorry, i'm not fully awake :)
07:37:21 <osaunders> hehe, OK.
07:38:15 <Saizan_> well, conal would say that thinking about the denotational semantic of what you want to write helps to get better designs
07:39:11 <osaunders> Interesting. How so?
07:39:33 <Saizan_> and i agree to some extent, you should have a fairly precise meaning for the main structures of your program in mind, to design an interface for them
07:39:34 <osaunders> (I have read the first 1/4 of the Wikibooks page on denotational semantics BTW).
07:40:00 <Saizan_> ah, that wikibook page mostly helps to understand fix
07:49:33 <monadic_kid> is there a prelude function like dropLast?
07:49:57 <ben_> init?
07:49:58 <Saizan_> no
07:50:10 <Saizan_> > init [1..5]
07:50:11 <lambdabot>   [1,2,3,4]
07:50:54 <monadic_kid> cool
07:52:31 <monadic_kid> ahh it fails with empty lists
07:55:48 <jbe> What's the idiom for chaining together a sequence of IO Maybe actions a la the Maybe monad?  Do I need to learn how to use transformers?
07:56:41 <Heffalump> jbe: yes, you do
07:57:46 <monadic_kid> Heffalump: does he really want a maybe monad, he might just mean a composing actiion with a return type if IO Maybe
07:57:53 <MaciejP> Why is there no Data.List.singleton?
07:58:10 <monadic_kid> *return type of
07:58:21 <ben_> > let a = return Nothing; b = return (Just ()) in liftM2 (>>) a b
07:58:22 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe ())))
07:58:22 <lambdabot>    arising from a...
07:59:17 <monadic_kid> jbe: do you want to compose an IO Monad with a Maybe Monad?
07:59:39 <monadic_kid> jbe: if you want something like that then you'll need a monad transformer
08:00:15 <jbe> monadic_kid: Not sure what "compose an IO Monad" means.  I want to run one IO action, if it returns Just, run another one, etc.
08:00:36 <CalJohn> MaciejP: probably because it's a bit trivial: x:[]
08:01:29 <jbe> I will try ben_'s code.  Maybe, thanks to the magic of types, I can yet again get away without understanding the math. :)
08:01:42 <jbe> s/types/type checking/
08:01:53 <MaciejP> CalJohn: Indeed it is, but then why we have id? ;-)
08:02:19 <monadic_kid> jbe: sounds like you want a monad transformer MaybeT
08:02:40 <CalJohn> heh, i don't know :p
08:02:57 <CalJohn> at least id is shorter to type than \x->x
08:03:13 <monadic_kid> jbe: http://hackage.haskell.org/packages/archive/MaybeT/0.1.0/doc/html/Control-Monad-Maybe.html
08:03:41 <monadic_kid> jbe: check the example
08:03:44 <MaciejP> @pl c -> [c]
08:03:44 <lambdabot> (line 1, column 3):
08:03:44 <lambdabot> unexpected ">" or "-"
08:03:44 <lambdabot> expecting variable, "(", operator or end of input
08:03:51 <MaciejP> @pl \c -> [c]
08:03:51 <lambdabot> return
08:03:58 <jbe> monadic_kid: Thanks.  No time like the present to learn!
08:05:02 <MaciejP> Hey cool, and it's even shorter than singleton.
08:05:13 <RayNbow> @pl (:[])
08:05:14 <lambdabot> return
08:05:34 <RayNbow> does @pl hate the monkey operator?
08:05:49 <theorbtwo> Well, now we know what monad pointless operates in...
08:07:45 <CalJohn> heh, i don't know why i didn't think of return as the list singleton
08:08:17 <McManiaC> > round (1/0)
08:08:18 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:08:20 <McManiaC> hehe
08:08:29 <Entroacceptor> :D
08:08:41 <jbe> ha
08:08:51 <McManiaC> > length . show $ round (1/0)
08:08:52 <lambdabot>   309
08:08:57 <jbe> > round (2/0)
08:08:58 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:09:09 <theorbtwo> This thing is driving me fucking crazy.  Ambiguous occurrence `main' It could refer to either `main', defined at dumpkey.hs:6:0 or `main', imported from BioWare.KeyBif at dumpkey.hs:1:0-20 (defined at BioWare/KeyBif.hs:30:0)"
08:09:33 <theorbtwo> BioWare/KeyBif.hs line 30 is not main.  In fact, the word "main" appears nowhere in that file at all.
08:09:53 <theorbtwo> Wait.
08:10:19 <theorbtwo> Gaaaaah.
08:10:42 <theorbtwo> Never, ever, ever, save a file in emacs, and then mv it to where it should be outside of emacs.
08:11:13 <McManiaC> just dont use emacs :>
08:11:25 <McManiaC> editor wars \o/
08:11:26 * hackagebot upload: serialport 0.3.1 - Cross platform serial port library. (JorisPutcuyps)
08:11:28 <theorbtwo> McManiaC: The "emacs" here doesn't actually matter.
08:11:36 <theorbtwo> No editor will get that case "right".
08:11:37 <McManiaC> although I guess many ppl in here prefer emacs =(
08:13:27 <jbe> As soon as yi does everything emacs does, I'll make the switch.
08:16:05 <medfly> lol
08:16:16 <medfly> including yirc?
08:16:29 <jbe> Exactly!  And email.
08:16:46 <medfly> yimail
08:16:50 <jbe> Oh, right.
08:16:55 <medfly> :)))
08:17:13 <McManiaC> :D
08:18:39 <Entroacceptor> it should be possible to make yi load emacs scripts, no?
08:19:04 <jpcooper> hello
08:19:10 <medfly> I don't really get the point in wanting one thing to do all the stuff for you... I mean, it rarely does more than one thing good
08:19:19 <medfly> so I'm basically burdened with more things :)
08:19:36 <The_third_man> Kiss
08:19:41 <The_third_man> keep it simple stupid
08:19:44 <The_third_man> \Oo/
08:20:19 <jpcooper> I'm trying to generate a tree which will give probabilities of outcomes if winning the next stage and further on in exchange hi-lo. I have the main functions on http://pastebin.com/m61da413b . Could anyone suggest a more efficient way to do this? It uses over 1 gigabyte of memory when working for 13 cards, and I don't even know how long it would take to finish
08:21:22 <jpcooper> quite simply it looks at a sequence of cards, evaluates how many stages into the game it wins and then goes into the existing tree and updates the win/loss ratios of successive stages in the tree
08:24:12 <jpcooper> I just can't see why the foldr should take up so much memory
08:24:45 <Botje> have you tried a foldl?
08:25:11 <jpcooper> is foldl meant to take up less memory? I wasn't sure of which was meant to
08:25:36 <roconnor> fold'
08:25:38 <roconnor> foldl'
08:25:52 <Botje> foldr will build up a giant set of thunks before reducing
08:25:56 <roconnor> the purpose of foldl is to implement reverse
08:26:03 <medfly> lol
08:26:09 <jpcooper> right
08:26:14 <monadic_kid> foldr is lazy, fold' is strict
08:26:22 <jpcooper> yeah I suppose 13! thunks isn't too easy on the memory
08:26:26 <monadic_kid> *foldl'
08:26:30 <medfly> > 13!
08:26:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:26:33 <medfly> :(
08:26:39 <medfly> > product [1..13]
08:26:40 <lambdabot>   6227020800
08:26:45 <medfly> guess so.
08:27:24 <roconnor> > let (!) x = product [1..x] in 13 !
08:27:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:31:31 <Entroacceptor> I think infixes have to be binary?
08:32:05 <dmwit> > let (!) x = product [1..x] in (13 !)
08:32:06 <lambdabot>   6227020800
08:32:08 <jpcooper> does anyone know of a script to transpose type names in type definitions?
08:32:16 <jpcooper> (for emacs)
08:32:22 <Entroacceptor> oh, no
08:32:27 <dmwit> jpcooper: transpose?
08:32:41 <roconnor> I think, but I'm not sure, that jpcooper may need a better algorithm
08:33:53 <jpcooper> roconnor, I am still getting large memory use with foldl'
08:34:02 <monadic_kid> Entroacceptor: if you use infix form with functionw with more than 2 args you'll get a function returned
08:34:13 <monadic_kid> Entroacceptor: no different than normal
08:34:27 <Entroacceptor> then my docs where wrong
08:34:47 <monadic_kid> what docs?
08:34:57 <Entroacceptor> one of the haskell tutorials I read
08:35:17 <dmwit> Entroacceptor: infix operators with less than two arguments are only available as an extension.
08:35:25 <dmwit> Entroacceptor: Your docs are probably technically correct.
08:35:27 <roconnor> jpcooper: what is a ProbTree?
08:35:38 <Saizan_> the fact that (13 !) worked there is not really haskell98, iirc
08:36:06 <roconnor> jpcooper: you might need a deepfoldl'
08:37:39 <roconnor> seq does only enough evaluation on a value to determin that it isn't _|_ and no more
08:37:44 <jpcooper_> I managed to crash my computer there
08:37:53 <jpcooper_> roconnor, could you suggest some alternatives to my algorithm?
08:38:02 <roconnor> seq is so terrible I wonder why they even added it to Haskell
08:38:54 <dmwit> Minimality+functionality appeals strongly to PL folks.
08:39:16 <dmwit> seq is the smallest thing you can get away with and still have strictness.
08:40:41 <jpcooper> or anyone else?
08:40:51 <roconnor> jpcooper_: well, I don't know what you are doing exactly, but I did <http://election.princeton.edu/faq/> to solve my problem (see the "how can you possibly go through 2.3 quadrillion possibilities?") question
08:40:54 <benmachine> Saizan_: I think haskell98 says (foo +) means (\b -> foo + b) while GHC says it means (+) foo
08:41:03 <jpcooper> thanks
08:41:07 <Saizan_> benmachine: yeah
08:41:54 <jpcooper> roconnor, I have all of the permutations of 13 cards, and to each permutation will be associated a certain score. This score must then be reflected in the tree of permutations of cards.
08:42:06 <roconnor> dmwit: having a normal form function seems like it would be more useful, but ya I do see your point.
08:43:01 <roconnor> jpcooper: presumably the score of each permulation is somehow related to the score of a subpermutation
08:43:09 <roconnor> sounds like you are repeating a *lot* of work
08:43:11 <jpcooper> yes
08:43:36 <jpcooper> for instance the score of [1,2,3,4,5] in a deck of 5 cards is 4
08:43:41 <jpcooper> as it's winning four stages in
08:44:20 <jpcooper> so I'll put a win for each stage of the top level 1, and then a win for the first four stages of 1 -> 2, and a win for the first three stages of 1 -> 2 -> 3 and so on
08:45:06 <dmwit> roconnor: Yep. You can create a normal-form function with seq, but you can't create seq from a normal-form function. (Or can you?)
08:45:30 <dmwit> I guess you can make seq out of a normal-form function.
08:45:34 <roconnor> hmm
08:45:47 <dmwit> data JustTheConstructor = Cons | Nil
08:45:51 <roconnor> I guess you write a function that inspects the portion you care about and seq that
08:46:11 <roconnor> like normalForm (null xs)
08:46:12 <dmwit> constructor (x:xs) = Cons; constructor [] = Nil; seq xs = normalForm (constructor xs)
08:46:19 <dmwit> exactly
08:46:44 <MissPiggy> data JustTheTypedConstructor t where Cons :: JustTheTypedConstructor (t -> [t]) ; Nil :: JustTheTypedConstructor [t]
08:46:54 <roconnor> that almost seems easier the defining normalForm in terms of seq
08:46:55 <MissPiggy> got cons wrong but anyway
08:47:17 * dmwit starts siding with roconnor
08:47:36 <benmachine> if you wanted it to be exactly seq though, you'd require a class of seqable things, wouldn't you?
08:47:43 <benmachine> or you could use Data I suppose
08:47:51 <roconnor> oh wait
08:47:54 <dmwit> benmachine: Yes, but you need that for normalForm now, anyway.
08:47:57 <roconnor> seq does crazythings with functions
08:48:02 <dmwit> :t rnf
08:48:03 <lambdabot> forall a. (NFData a) => a -> Done
08:48:05 <roconnor> that is stupid
08:48:14 <benmachine> dmwit: mm, I guess whichever you have needs a typeclass for the other?
08:48:20 <dmwit> benmachine: right
08:48:35 <benmachine> roconnor: elaborate on crazythings
08:48:46 <benmachine> > seq (+) 3
08:48:47 <lambdabot>   3
08:48:52 <benmachine> > seq undefined 3
08:48:53 <lambdabot>   * Exception: Prelude.undefined
08:49:08 <dmwit> benmachine: seq evaluates functions far enough to find a lambda
08:49:38 <benmachine> what would normalForm do?
08:49:46 <dmwit> same, I guess =)
08:50:20 <benmachine> well, then.
08:50:40 <benmachine> @instances NFData
08:50:41 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
08:50:54 <benmachine> hrm
08:50:59 <dmwit> ?index NFData
08:50:59 <lambdabot> Control.Parallel.Strategies
08:51:08 <benmachine> @instances-importing Control.Parallel.Strategies NFData
08:51:08 <lambdabot> (), (a, b), (a, b, c), Assoc a b, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, [a]
08:51:13 <benmachine> no a -> b
08:53:06 <dmwit> <3 version control
08:56:33 <dmwit> Hm. The gkt2hs hello-world example segfaults when I close the window.
08:57:10 <Heffalump> DDTT :-)
08:57:38 <dmwit> um
08:57:44 <dmwit> Closing windows is pretty basic... =P
09:14:55 <CalJohn> dmwit: do you mean demo/hello?
09:15:21 <dmwit> CalJohn: I mean the code here:
09:15:25 <dmwit> http://www.haskell.org/gtk2hs/documentation/#examples
09:17:36 <CalJohn> dmwit: it works for me, what version of gtk2hs and ghc do you have?
09:17:51 <dmwit> GHC 6.12.1
09:18:04 <dmwit> gtk2hs 0.10.1
09:18:45 <CalJohn> http://haskell.org/gtk2hs/archives/category/announcements/ <-- have you seen this page?
09:19:09 <CalJohn> probably unrelated, now i think about it
09:19:36 <dmwit> I just installed my distro's binary.
09:19:58 <CalJohn> lame
09:20:38 <CalJohn> i use 10.3, maybe you should email the person who wrote it?
09:21:09 <dmwit> Maybe I should go to bed and figure it out in the "morning".
09:21:43 <dmwit> Thanks, though, if it looks like something in the library build I have, I'll build it myself.
09:21:53 <CalJohn> goodnight :)
09:22:05 <dmwit> g'night =)
09:23:46 * hackagebot upload: bamboo-theme-blueprint 2010.2.22 - bamboo blueprint theme (JinjingWang)
09:25:46 * hackagebot upload: bamboo-theme-blueprint 2010.2.22.1 - bamboo blueprint theme (JinjingWang)
09:28:41 <MissPiggy> > let (n,n0,n1,n2,n3,n4,n5,n6) = (6,8,4,2,6,9,7,5,1) in n * n3 + n0 * n4 + (n1 * n6 + n2 * n5) = n1 * n5 + n2 * n6 + (n * n4 + n0 * n3)
09:28:42 <lambdabot>   <no location info>: parse error on input `='
09:32:59 <aavogt> > let len (_:(succ . len -> n)) = n; len [] = 0 in len "hello"
09:33:00 <lambdabot>   Illegal view pattern:  (succ . len -> n)
09:33:00 <lambdabot>  Use -XViewPatterns to enable view...
09:35:06 <MissPiggy> > let (u,v)`times`(x,y) = (u*x+v*y,u*y+v*x) in ((6,7)`times`(4,6),(6-7)*(4-6))
09:35:07 <lambdabot>   ((66,64),2)
09:43:39 <McManiaC> is there a way to turn a lazy list into a strict?
09:43:39 <McManiaC> ^^
09:43:54 <burp> use vectors
09:44:02 <burp> strict vectors ;)
09:44:03 <dmwit> McManiaC: see Control.Parallel.Strategies
09:45:12 <dmwit> seqList :: Strategy a -> Strategy [a] -- in particular
09:47:15 <McManiaC> hmmm
09:49:32 <McManiaC> how would I use that? I have an infinit list and a veeeeeeeery big number… now I want to do "num `elem` lis", but since the number is so big I always get a stack/ram overflow
09:50:15 <MissPiggy> @qucikcheck \x y z -> x == y ==> x + z == y + z
09:50:16 <lambdabot> Unknown command, try @list
09:50:18 <MissPiggy> @check \x y z -> x == y ==> x + z == y + z
09:50:19 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:50:19 <lambdabot>                     (Test.QuickCh...
09:50:27 <MissPiggy> @check \(x y z::Integer) -> x == y ==> x + z == y + z
09:50:27 <lambdabot>   Parse error in pattern at "->" (column 19)
09:50:30 <MissPiggy> :[
09:50:58 <medfly> @check \x y z -> x == y ==> x + z == (y + z :: Integer)
09:50:58 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:50:58 <lambdabot>                     (Test.QuickCh...
09:51:00 <medfly> :/
09:51:19 <MissPiggy> ;_;
09:53:00 <dmwit> McManiaC: Then you have a problem before you even get to the stage where you can apply seqList.
09:53:21 <Alpounet> how do you plan to handle a *strict infinite* list ?
09:53:57 <burp> infinite powerful computer
09:54:40 <Alpounet> haha
09:55:13 <Twey> An oracle, of course
09:56:22 <Kedorlaomer> !ds_askforsession
09:57:24 <McManiaC> Alpounet: well, thats my question basicly
09:57:25 <McManiaC> :D
09:57:39 <Alpounet> strict means without laziness
09:57:43 <Alpounet> that is, you evaluate stuffs
09:57:55 <Alpounet> you can't have an infinite list evaluated
09:58:01 <McManiaC> of couse not
09:58:03 <Alpounet> it'd need infinite memory
09:58:22 <manjunaths> hello
09:58:27 <sepp2k> Infinite time, too.
09:58:34 <Alpounet> yeah
09:58:34 <Kedorlaomer> !ds_sessionstart
09:58:53 <dmwit> Kedorlaomer: What are you trying to do?
09:59:16 <Alpounet> McManiaC, can you rather tell us what you *globally* want to do ?
09:59:30 <Kedorlaomer> !ds_adddoc test-test-test text
10:00:06 <manjunaths> In this (http://stackoverflow.com/questions/2302493/stack-overflow-in-ocaml-and-f-but-not-in-haskell) question dons is able to answer 'expand' the  code
10:00:10 <manjunaths> how does he do it ?
10:00:17 <manjunaths> it seems like the code is autogenerated
10:00:44 <McManiaC> Alpounet: get the biggest prime factor of 600851475143
10:01:08 <dmwit> manjunaths: Check the "-ddump" flags for ghc.
10:01:15 <dmwit> manjunaths: There's one like -ddump-core or so.
10:01:23 <McManiaC> :D
10:01:40 <manjunaths> dmwit, thanks
10:06:46 <Kedorlaomer> !ds_askforsession
10:06:57 <Kedorlaomer> !ds_sessionstart
10:07:22 <Kedorlaomer> !ds_adddoc test-test text
10:08:18 <MissPiggy> Kedorlaomer: ERROR
10:08:47 <Alpounet> manjunaths, check the ghc-core tool, too
10:09:02 <manjunaths> Alpounet, ok thanks
10:16:04 <Kedorlaomer> !ds_sessionend
10:18:10 <Kedorlaomer> !ds_askforsession
10:22:47 <v3ctor> > pl \x y -> x y
10:22:48 <lambdabot>   <no location info>: parse error on input `\'
10:23:02 <aavogt> @pl \x y -> x y
10:23:02 <lambdabot> id
10:23:02 <Alpounet> it's ($)
10:23:25 <v3ctor> @pl \x y -> x y
10:23:26 <lambdabot> id
10:24:51 <Alpounet> @unpl id
10:24:51 <lambdabot> (\ a -> a)
10:24:55 <Alpounet> @unpl ($)
10:24:55 <lambdabot> (\ a b -> a b)
10:30:45 <aavogt> > id `asTypeOf` ($)
10:30:46 <lambdabot>   {{()->()}->{()->()}}
10:31:45 <MaciejP> In a Monad, what would this syntax mean: ... UserNameUrlString user <- getData ... ?
10:32:04 <MaciejP> Where UserNameUrlString is a record Data type.
10:32:17 <ben_> MaciejP: It is pattern-matching
10:32:20 <ben_> Left of the <- is a pattern
10:32:35 <Alpounet> getData returns a "m <your record data type>"
10:32:42 <Alpounet> where m is your monad
10:32:46 <doserj> MaciejP: UserNameUrlString is the name of a constructor there, not the name of a type
10:33:20 <Alpounet> data Foo = UserNameUrlString String | [Other stuffs...]
10:33:25 <Alpounet> or similar
10:33:28 <MaciejP> Hm, but what would user that match on?
10:33:46 <MaciejP> data UserNameUrlString = UserNameUrlString {profilename :: String}
10:34:05 <aavogt> but it is common enough give data types the same names as constructors as you have there
10:34:17 <MaciejP> So user is the profilename?
10:34:22 <aavogt> MaciejP: it pulls the profilename out
10:35:03 <MaciejP> Ah I see. Would it work with more than one record element?
10:35:14 <aavogt>   data T = Con { x :: Int, y :: String, z :: Double }, defines con that can be matched as:    Con x y z <- ...
10:35:26 <MaciejP> Ok
10:35:43 <aavogt> but that gets kind of unweildy, so you could also write    Con { x = variable } <- ...
10:36:12 <aavogt> depending on whether you want to access all of the elements
10:40:18 * hackagebot upload: darcs-benchmark 0.1.6 - Comparative benchmark suite for darcs. (EricKow)
10:40:26 <Sternmull> is anyone using SDL with HOpenGL? My drawing area does not resize when the window and the viewort get resized. :(
10:41:22 <Sternmull> i mean it is always clipped to the initial size.
10:48:18 <mietek> Does array-0.2.0.0 build under GHC 6.12.1?
10:48:31 <mietek> cabal pulls this in as a dependency for darcs, and it fails for me.
10:48:46 <mietek> I'm trying to figure out whether this is a problem with my setup.
10:49:24 <Zao> http://hackage.haskell.org/package/array-0.2.0.0 <- that seems to imply that it failed on 6.12
10:50:18 <Zao> Looks like it depends on some internal gunk to me, so I'd be surprised if arrays-0.2 ran on 6.12 and arrays-0.3 ran on 6.10.
10:50:30 <mietek> Hm.
10:50:44 <Zao> Laymans opinion, I don't know anything about the library.
10:51:00 <mietek> Looks like darcs-2.3.1 also fails, on Hackage at least.
10:51:16 <mietek> That's odd, isn't it?
10:53:06 <mietek> I mean, it's understandable, since array doesn't build, but I'd have thought darcs is maintained.
10:53:09 <erg0t> what can I use like readFile but for binary files?
10:54:33 <Heffalump> darcs 2.3.1 doesn't build on 6.12
10:55:19 <mietek> Heffalump: thanks.
10:55:44 <Heffalump> darcs is maintained, but you have to wait for the next major release for 6.12 support
10:56:05 <Heffalump> if you really care, you can pull a few patches from unstable and build the 2.3 branch, IIRC
10:56:11 <MissPiggy> i find myself writing my program in two languages at once
10:56:16 <MissPiggy> in parallel...
10:56:23 <MissPiggy> I need a way to connect them up
10:57:06 <luite> is there a rng that can be efficiently used for this pattern: run 1000 iterations, check some value, if not converged: run 2000 iterations (but the last 1000 iterations must get exactly the same random numbers as in the previous run!), check convergence again, if not converged, run 4000 iterations (and the last 2000 iterations need to get the same values again)?
10:57:07 <Sternmull> use sockets :)
10:57:34 <Cale> luite: Sounds like a job for randoms and infinite lists
10:58:00 <Heffalump> luite: do the first 1000 iterations of the second run differ from the 1000 iterations of the first run somehow?
10:58:14 <Cale> :t randomRs
10:58:15 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
10:58:34 <luite> Heffalump: yes, those are the new values, the simulation runs from negative time to time zero
10:58:45 <opqdonut> luite: just store the seed you've used and change it when needed
10:59:26 <opqdonut> 1) run simulation with seed 0 from -1000 to 0 2) run simulation with seed 1 from -2000 to -1001 and then with seed 0 from -1000 to 0 3) ...
10:59:32 <doserj> or just store the numbers
10:59:42 <opqdonut> sure, if that's not a problem
10:59:54 <opqdonut> prefixes of an infinite list of random numbers
10:59:56 <opqdonut> or so
11:00:05 <luite> storing numbers would take a lot of space, storing snapshots of the rng state could be done
11:00:26 <luite> the usual infinite random lists seem to 'go the wrong way' :)
11:00:42 <opqdonut> well you can always reverse a prefix
11:01:03 <Cale> luite: go the wrong way?
11:01:29 <opqdonut> also you could do something like f(t) = hash(seed+t)
11:01:37 <opqdonut> and use f(t) as the seed of the random numbers for step t
11:01:38 <luite> Cale: the problem is that in the second run, the last 1000 values have to be the same (first run simulates time -1000..0, the second -2000..0)
11:01:45 <opqdonut> (or as the sole random number if you only need one)
11:02:02 <Cale> luite: ah, I see.
11:10:27 <stoic75> hi all.  I'm having a problem with xmobar.  I'm very new to all this.  Where to I find the xmobarrc file so I can configure it?
11:11:11 <Botje> i think you mean xmonad, and there's a channel dedicated to it (#xmonad)
11:11:48 <DrTeggy> xmobar is a companion to xmonad, Botje
11:11:55 <Botje> really?
11:12:02 <DrTeggy> (a textual status bar thingy)
11:12:05 <Botje> ah
11:12:08 <stoic75> Botje:  well, I'm trying to configure xmonad.hs with xmobar.  the wiki references xmobarrc and I can't find it.
11:12:09 <Botje> so it's a dmenu replacement
11:12:38 <stoic75> should I be using dmenu instead?  thanks for your help.
11:12:59 <Botje> no idea, i haven't used xmonad ever, and dmenu is now .. four years ago :)
11:13:35 <stoic75> ok.  thanks anyway.  have a good one.
11:15:06 <stoic75> DrTeggy:  are you able to assist me?  I'm able to find .xmobar in my /user/bin but no xmobarrc
11:15:54 <DrTeggy> stoic75, I am Mac OS X-based and do not have xmonad or xmobar installed.
11:16:17 <stoic75> ok.  thank you anyway.
11:16:23 <Botje> stoic75: have you tried #xmonad yet? there's probably a bigger proportion of xmobar users there
11:16:49 <stoic75> I went over there and didn't get any responses.  I'll try again.  take care,
11:17:04 <Botje> okay, good luck!
11:21:51 <tobe96> can someone tell me how to use toEnum for lists in mapM?
11:22:22 <thoughtpolice> copumpkin: ping
11:23:11 <Botje> tobe96: why mapM?
11:23:59 <tobe96> Botje: I have to write [Int] -> Maybe [Nat] or can it be done in another way?
11:25:20 <Botje> oh, you're not the same guy who came asking here before.
11:25:53 <Botje> you probably want to use the guard function
11:26:25 <Botje> mapM (\x -> guard (x >= 0) >> return (toNat x)) list
11:28:01 <tobe96> what is guard and do I have to change toNat so that it calls my toEnum Nat?
11:28:11 <Botje> :t guard
11:28:12 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:28:29 <Botje> if the bool is false, guard fail's
11:28:48 <Botje> and the fail aborts the mapM
11:29:10 <tobe96> but it says Not in scope: `guard'
11:29:42 <Botje> it's part of Control.Monad ..
11:35:42 <Veinor> @src guard
11:35:42 <lambdabot> guard True  =  return ()
11:35:42 <lambdabot> guard False =  mzero
11:37:04 <tobe96> ah, i didn't import it. And what do I have to change that it calls my instance Enum Nat for each int in the list?
11:38:46 <Botje> .. you call toEnum instead of toNat?
11:39:16 <Veinor> how can I see how, say, the list monad defines mzero?
11:39:32 <ben> @src [] mzero
11:39:33 <lambdabot> mzero = []
11:39:36 <Veinor> there we go.
11:39:51 <ben> Or you click yourself through Hoogle until you find the source to the instance
11:40:07 <tobe96> Botje:  for single values I used toEnum 5 :: Nat
11:40:18 <Veinor> I should learn how the list monad works.
11:40:27 <ben> Sporadically.
11:40:30 <Veinor> cause I want to understand how guard works.
11:40:42 <ben> @src guard
11:40:42 <lambdabot> guard True  =  return ()
11:40:42 <lambdabot> guard False =  mzero
11:41:04 <Veinor> yes, but I don't get why that works
11:41:34 <ben> @type guard
11:41:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:41:41 <ben> hm
11:41:41 <Botje> tobe96: you just need to lock down the type to Nat, somewhere.
11:41:46 <Botje> haskell will infer it
11:41:51 <ben> > return () :: [a]
11:41:52 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
11:41:53 <lambdabot>    `a' is a rig...
11:41:55 <ben> > return () :: [()]
11:41:56 <lambdabot>   [()]
11:41:56 <Botje> or leave it upen, and your functill will work for all Enum instances
11:42:13 <Botje> *open
11:42:29 <ben> Veinor: The list monad's >>= runs the right hand side once for each element in the left hand side list
11:42:47 <ben> Veinor: mzero is the empty list, so it does not run the right hand side. return () is a list with one element, so it runs the right hand side once.
11:43:22 <Veinor> I see.
11:43:29 <ben> > [1, 2, 3] >> return "toot"
11:43:31 <lambdabot>   ["toot","toot","toot"]
11:43:54 <Veinor> remind me, is a >>= b >>= c  (a >>= b) >>= c or a >>= (b >>= c)?
11:44:02 <tobe96> Botje: i don't really understand how you mean it. What do I have to change so that it calls my toEnum of my instance Enum Nat for each value in the list?
11:44:30 <ben> Veinor: One of the monad laws is that it is either
11:44:31 <Botje> tobe96: the type. lock it down to Nat instead of a random Enum instance.
11:44:40 <ben> Err, no
11:44:48 <ben> It would be if you used >=>, I believe!
11:44:57 <ben> I think it is the latter
11:45:00 <Botje> or write a toNat = toEnum :: Int -> Nat
11:45:13 <ben>  m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
11:45:50 <Veinor> is there a @parenthesize? :P
11:46:19 <tobe96> "lock it down to Nat"? i'll try it with a toNat function
11:46:45 <ben> Veinor: Does it really matter?
11:47:41 <Veinor> well, I am a member of CATSUP
11:49:59 <tobe96> Botje: now I created: toNat x = do toEnum x :: Nat which calls my toEnum, but the mapM still doesn't work
11:50:33 <Botje> what code do you have now? put it on hpaste
11:50:45 <Botje> along with the error you got,
11:51:18 <HugoDaniel> hello
11:52:41 <temoto> Is there a builtin coalesce function?
11:54:04 <doserj> temoto: what should it do?
11:54:25 <temoto> doserj, in SQL it picks first non-null.
11:54:48 <temoto> I suppose, least general version would work with Maybes.
11:55:35 <doserj> head.catMaybes?
11:55:38 <ddarius> :t listToMaybe . catMaybes
11:55:39 <lambdabot> forall a. [Maybe a] -> Maybe a
11:56:05 <temoto> @src catMaybes
11:56:05 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:56:28 <temoto> @src listToMaybe
11:56:28 <lambdabot> listToMaybe []        =  Nothing
11:56:28 <lambdabot> listToMaybe (a:_)     =  Just a
11:56:37 <copumpkin> listToMaybe = unsafeCoerce
11:56:54 <copumpkin> (and cross your fingers)
11:57:17 <temoto> > let coalesce = listToMaybe . catMaybes in coalesce [Nothing, Just 20]
11:57:18 <lambdabot>   Just 20
11:57:42 <temoto> Cool, thanks.
11:58:07 <temoto> > let coalesce = listToMaybe . catMaybes in coalesce [Nothing, Nothing]
11:58:08 <lambdabot>   Nothing
11:58:25 <copumpkin> > msum [Nothing, Nothing]
11:58:26 <lambdabot>   Nothing
11:58:33 <copumpkin> > msum [Nothing, Just 20]
11:58:34 <lambdabot>   Just 20
11:59:09 <doserj> ah, right
11:59:13 <tobe96> Botje: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22529#a22529  that's what I have in my file currently
12:00:44 <ddarius> listToMaybe . catMaybes === msum -- on Maybe
12:00:56 <Botje> and what error do you get?
12:02:04 <MaciejP> > msum [Just 10, Just 20]
12:02:05 <lambdabot>   Just 10
12:02:19 <tobe96> Botje: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22530#a22530
12:02:53 <Botje> that has nothing to do with the toNat.
12:03:03 <Botje> haskell isn't sure which MonadPlus instance you want for the mapM
12:03:09 <Botje> lock it down by giving a type.
12:04:09 <tobe96> you mean :: Nat?! but where?
12:04:11 <erg0t> do I have to pass some flag to ghc in order to compile code that uses ByteString?
12:04:18 <erg0t> I'm having linking problems
12:04:47 <Botje> tobe96: no, i don't mean Nat.
12:04:57 <Botje> tobe96: I mean the *monad* instance you want it to have
12:05:20 <Botje> mapM (...) [1..4] :: SOMETHINGHERE
12:06:09 <tobe96> hmm
12:06:44 * hackagebot upload: zeromq-haskell 0.2 - bindings to zeromq (ToralfWittner)
12:09:08 <Botje> erg0t: you're using ghc --make, right?
12:09:24 <erg0t> no, let me try
12:09:38 <erg0t> Botje: thanks :)
12:10:05 <Botje> np :)
12:11:58 <tobe96> do you mean Nothing, or Just, or Maybe?
12:12:21 <Botje> it should be a type.
12:13:00 <Botje> only one of those three is a type, the other two are data constructors
12:13:36 <doserj> none of those three will work...
12:14:23 <temoto> Botje, not one of those is type.
12:14:30 <tobe96> doserj: yeah, i already tried it :(
12:14:31 <Botje> right, type constructor.
12:15:42 <temoto> Interesting similarity between "type" vs. "type constructor" and "?" vs. "data constructor".
12:16:08 <temoto> Integer is a complete type, but Nothing is still a data constructor, right?
12:16:11 <Twey> Value?  :þ
12:16:18 <Twey> Yes
12:16:44 <Botje> tobe96: mapM (...) [1..4] :: Maybe ...
12:16:48 <Botje> one less blank for you to fill out.
12:17:00 <Twey> ‘Maybe a’ is a type.  ‘Integer’ is a type.  ‘Just a’ is a value.  ‘Nothing’ is a value.  Whatever that constructor for Integer is called, is a value.
12:17:08 <Twey> @src Integer
12:17:09 <lambdabot> data Integer = S# Int#
12:17:09 <lambdabot>              | J# Int# ByteArray#
12:17:22 <Twey> ‘S# a’ is a value.
12:17:39 <ben> @src Int
12:17:39 <lambdabot> data Int = I# Int#
12:19:06 <ddarius> Yes, but Just is a value as well as Just 3.
12:19:16 <Twey> A function
12:19:26 <temoto> @type Just
12:19:27 <lambdabot> forall a. a -> Maybe a
12:19:49 <ddarius> Functions are values, that's the whole basis of higher order functional programming.
12:20:18 <tobe96> hmm again. it's horrible
12:21:30 <temoto> ddarius, i was wondering about the other side: we don't call 'Integer' a type constructor, but we call 'Nothing' a data constructor.
12:22:02 <ben> Do we not also call type constructors types?
12:22:34 <Twey> ben: No
12:22:35 <ddarius> ben: No.
12:22:46 <ddarius> We do call types type constructors, though.
12:22:47 <MissPiggy> I do :|
12:22:49 <Twey> Type constructors can't have values, so they're not types
12:22:58 <ddarius> Types are members of *.
12:23:00 <Twey> You can't have a value of type ‘Maybe’
12:23:10 <MissPiggy> I just call everything a tpe
12:23:15 <MissPiggy> type*
12:23:48 <Sternmull> but i can pass Maybe as an argument to a function
12:23:49 <CalJohn> ben: type constructors are really functions
12:23:54 <Twey> Sternmull: No you can't
12:23:56 <MissPiggy> and things in *  concrete types
12:24:01 <Sternmull> no?
12:24:04 <Twey> Nope
12:24:16 <tobe96> Botje: ahhhhhhhhhhhhh, now there was one error message I understood: Maybe [Nat]
12:24:18 <Twey> You can use it as an argument to another type constructor
12:24:19 <mauke> Sternmull: functions take values, not type constructors
12:24:21 <Sternmull> But i can pass functions as arguments. Are constructor no simple functions?
12:24:28 <Twey> But not a function
12:24:30 <jlouis> Yay, GHC612 slowly getting onto Debian/Unstable
12:24:33 <Twey> Sternmull: Data constructors are
12:24:37 <mauke> Sternmull: type constructors aren't values
12:24:38 <Twey> Sternmull: Type constructors aren't
12:24:39 <CalJohn> Sternmull: no, you can just pass things _of_type_ Maybe a to a function (ie: either Just a or Nothing)
12:25:33 <MissPiggy> do yuo read * as type? I read it as  star
12:25:51 <ddarius> MissPiggy: In some languages, * is written as Type.
12:26:15 <temoto> And in some, it is written as MUL.
12:27:38 <Sternmull> oh. I confused Maybe with Just :)
12:29:02 <Sternmull> What i ment to say was that i can pass Just as an argument to a function. And i think in this case i use Just as a value of an argument.
12:29:23 <Twey> Yes
12:29:23 <thoughtpolice> copumpkin: ping
12:29:30 <copumpkin> PONG
12:29:44 <Twey> That's what ddarius meant about data constructors being values
12:29:54 <Sternmull> ah, ok
12:30:10 <tobe96> is there a reason with my mapM function doesn't really work for list like [1..]?
12:30:26 <Twey> :t mapM
12:30:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:30:34 <mauke> @src sequence
12:30:34 <lambdabot> sequence []     = return []
12:30:35 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:30:35 <lambdabot> --OR
12:30:35 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:30:37 <copumpkin> tobe96: do you understand what mapM works?
12:30:40 <copumpkin> *does
12:30:59 <Botje> tobe96: why do you think it "doesn't really work" ?
12:31:02 <ddarius> tobe96: mapM will never end on that unless your monad allows "aborting" computation.
12:31:04 <mauke> Botje: infinite loop
12:31:04 <robokop> i'm trying to cabal install lambdabot, but it gives me an error on show
12:31:09 <opqdonut> tobe96: it does for monads that are lazy enough
12:31:18 <thoughtpolice> copumpkin: so, for vector-static, have you looked at using tfp?
12:31:21 <tobe96> copumpkin: ok, if I would know how it works I maybe could answer the question
12:31:24 <thoughtpolice> or type-level from hackage?
12:31:33 <tobe96> ok, it works but makes a stack overflow
12:32:34 <thoughtpolice> copumpkin: http://hackage.haskell.org/package/tfp <- I think this would work fine for the purposes of vector-static
12:32:44 <Twey> > mapM return [1 .. 10]
12:32:45 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
12:32:45 <lambdabot>    arising from a use of `M57561498...
12:32:45 <copumpkin> thoughtpolice: I was looking for something with a nice fast underlying rep, but neither of them seemed to
12:32:50 <pokoko222> anyone does graph algorithms in haskell?
12:32:55 <Twey> > mapM (return :: a -> [a]) [1 .. 10]
12:32:56 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
12:32:58 <copumpkin> thoughtpolice: tfp has Integer and type-level is building it on the fly
12:33:02 <Beelsebob> \o/
12:33:04 <Beelsebob> it's working
12:33:04 <Twey> > mapM (return :: a -> [a]) [1 ..]
12:33:04 <Beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/pdf.png
12:33:06 <lambdabot>   * Exception: stack overflow
12:33:10 <Twey> Boo
12:33:31 <copumpkin> thoughtpolice: it would be nice to have a premade type-level package though :/
12:33:38 <ddarius> Twey: That would be an infinite cartesian product.
12:33:53 <ddarius> However, return :: a -> Identity a would word fine.
12:33:55 <ezyang> Hey guys, I'm writing a fast popcount: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22539#a22539
12:33:58 <thoughtpolice> copumpkin: what's the representation for the stuff in current vector-static
12:33:59 <ezyang> But it doesn't work on big Words
12:34:04 <copumpkin> thoughtpolice: just an Int
12:34:13 <pokoko222> anyone does graph algorithms in haskell?
12:34:14 <robokop> i'm trying to cabal install lambdabot, but it gives me an error on show-0.3.4, but that version of show is already installed
12:34:17 <ezyang> so I think Haskell has some interesting behavior on overflows. Please advise?
12:34:21 <copumpkin> thoughtpolice: so you have unary numbers at compile time but Ints at runtime
12:34:23 <Twey> > mapM (return :: a -> Identity a) [1 ..]
12:34:24 <lambdabot>   No instance for (GHC.Show.Show
12:34:24 <lambdabot>                     (Control.Monad.Identity....
12:34:29 <Twey> > runIdentity $ mapM (return :: a -> Identity a) [1 ..]
12:34:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:34:31 <tobe96> but why doesn't it prints the results in the infinite loop?
12:34:37 <copumpkin> pokoko222: check out fgl
12:35:04 <ddarius> tobe96: It doesn't know if there are any results until it reaches the end.
12:35:08 <pokoko222> copumpkin lot of things come out on google, give me link
12:35:24 <copumpkin> @google fgl haskell
12:35:24 <lambdabot> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
12:35:24 <lambdabot> Title: Functional Graph Library/Haskell
12:36:11 <monochrom> > case undefined of x -> "x"
12:36:12 <lambdabot>   "x"
12:36:14 <thoughtpolice> copumpkin: hm. it would be nice to have something using an underlying Int + some of the nice alias stuff from tfp/type-level (seriously, TH-generated type synonyms for that kind of stuff is a godsend)
12:36:35 <ddarius> Beelsebob: Are you writing your own PDF generating library or using an existing one, because ones do exist.
12:36:53 <Beelsebob> ddarius: writing my own, what ones exist?
12:37:04 <copumpkin> thoughtpolice: yeah, and a readable output format (I could write a QQ for literals in my rep, but if you get an error, it's basically unreadable) would be nice too
12:37:17 <ddarius> @hackage HPDF
12:37:17 <lambdabot> http://hackage.haskell.org/package/HPDF
12:37:28 <monochrom> ezyang: "case blah of x ->" does not force.
12:38:23 <copumpkin> case blah of x | x `seq` True  =
12:38:25 <copumpkin> ;)
12:38:37 <Beelsebob> ddarius: interesting, it's half what I want
12:38:45 <Beelsebob> it's all monaddy around paths, which is a little icky
12:38:47 <ddarius> Beelsebob: Cairo can also generate PDFs and there is at least one more.
12:38:54 <ezyang> monochrom: Hm, ok
12:38:59 <Beelsebob> cairo is an impreative library though
12:39:13 <ezyang> I was cargo culting syntax from IntMap
12:39:26 <robokop> just generate TeX/LaTeX :P
12:39:32 <ezyang> although I suppose I don't really care if it forces or not if it doesn't work ;-)
12:39:39 <Beelsebob> robokop: the point of this actually is to replace LaTeX
12:39:50 <Beelsebob> LaTeX sucks, just nothing better exists
12:39:58 <robokop> well generate plainTex then :P
12:39:59 <copumpkin> :)
12:40:01 <Botje> docbook is nice
12:40:25 <MissPiggy> how does LaTeX suck?
12:40:32 <Botje> the syntax, for one
12:40:33 <copumpkin> fugliest syntax
12:40:34 <CalJohn> Beelsebob: ah, so your latex hate has taken on project form :)
12:40:39 <Beelsebob> robokop: I find PDF a more friendly language to write as a human than TeX
12:40:45 <copumpkin> I love the output, hate the input
12:40:50 <copumpkin> (output of XeTeX mostly)
12:40:53 <Beelsebob> copumpkin: quite
12:40:53 * hackagebot upload: mersenne-random-pure64 0.2.0.3 - Generate high quality pseudorandom numbers purely using a Mersenne Twister (DonaldStewart)
12:40:58 <MissPiggy> other than syntax?
12:40:58 <Botje> the 1970s way of processing files
12:41:13 <Botje> it's 2010, we have plenty of multipass compilers nowadays.
12:41:31 <copumpkin> you don't love writing pdflatex -> pdflatex -> bibtex -> pdflatex ?
12:41:38 * DrTeggy digs .aux files
12:41:48 <Beelsebob> copumpkin: it's awesome, utterly briliant design
12:41:50 <DrTeggy> and .toc, and .log, and. blg, and ...
12:41:56 <Beelsebob> we should *alwys* have to run a tool 3 times to get useful output
12:41:56 <copumpkin> mmm
12:42:13 <robokop> i still love tex, it is better then latex imho
12:42:14 <ddarius> Beelsebob: This does PostScript, but I thought there was something to do PDF as well built over it. http://www.slavepianos.org/rd/?t=hps
12:42:29 <Beelsebob> ddarius: tbh, I'm *most* of the way to a full pdf library already
12:42:33 <Beelsebob> only got text/fonts to go
12:42:41 <Beelsebob> which look hard work, but not that horrific
12:42:48 * ddarius would really prefer something that -read- PDF.
12:42:56 <Beelsebob> ddarius: this will do that... eventually
12:43:12 <Beelsebob> i.e. I'm going to get to version 0.5 writing pdf before I start on parsing it
12:43:21 <ddarius> @hackage hps
12:43:22 <lambdabot> http://hackage.haskell.org/package/hps
12:43:29 <tobe96> can I change my function easily that it just produces Nothing for the negative Ints but maps the other Ints to the corresponding Nats?
12:43:33 <copumpkin> yeah, I want a pdf reader
12:43:55 <tobe96> like [Int] -> [Maybe Nat]
12:44:13 <Botje> tobe96: sure. use map instead of mapM.
12:44:14 <Beelsebob> > makeNatural x | x < 0 = Nothing; | otherwise = Just x
12:44:15 <lambdabot>   <no location info>: parse error on input `|'
12:44:19 <MissPiggy> write f :: Int -> Maybe Nat, and use map f
12:44:22 <MissPiggy> tobe96
12:44:26 <copumpkin> thoughtpolice: anyway, feel free to submit patches/fork it/whatever :)
12:44:48 <copumpkin> thoughtpolice: I epicly procrastinated real work to do that yesterday so probably won't touch it for a day or two now, since I need to catch up
12:44:55 <thoughtpolice> copumpkin: hm yes, I was thinking about something fun to work on. :)
12:45:20 <Botje> Beelsebob: got a project website? I'm happy to contribute spare cycles
12:45:44 <Beelsebob> Botje: not yet, I'm getting pdf output to do text before I even make the darcs public
12:45:45 <copumpkin> thoughtpolice: felipe lessa sent me an email suggesting sized streams, since a lot of the time the streams contain size hints
12:45:52 <Beelsebob> just got excited that I had a red rectangle, that's all
12:45:53 <Beelsebob> >.>
12:45:56 <Botje> :)
12:46:03 <Botje> may it be the first of many
12:46:08 <tobe96> Botje: ok, easy :)
12:46:10 <Beelsebob> \o/
12:46:11 <ddarius> Beelsebob: At least it's not a rotating cube.
12:46:17 <Beelsebob> ddarius: or a teapot
12:46:50 <copumpkin> thoughtpolice: that would avoid the existential output on stream -> vector. Also, was considering a length-existential Cont (with monad instances) for output of certain functions (otherwise I think we'd need impredicative types)
12:46:50 <thoughtpolice> copumpkin: yes, most of the stream-fusion (tho vector has recycling too) based libraries do keep a size somewhere
12:46:52 <tobe96> MissPiggy: ok, that's what I did
12:46:59 <robokop> i'm trying to cabal install lambdabot, but it gives me an error on show-0.3.4, but that version of show is already installed
12:47:17 <ddarius> Teapot at least means you wrote some model reading code (or did back in the day... *sigh* freakin' youngins don't know what they have)
12:47:25 <copumpkin> thoughtpolice: this one has size hints. It either has a real size, or an upper bound, or unknown size. If the size is unknown it needs to traverse the stream twice to get the length I think
12:47:48 <copumpkin> it seems like a nice approach
12:48:00 <ezyang> How can I use __builtin_ GCC functions from the FFI?
12:48:05 <copumpkin> you can't
12:48:16 <mauke> builtins are built in, not functions
12:48:17 <ben> Write wrappers for them in C
12:48:18 <copumpkin> they aren't real functions
12:48:23 <sinelaw> hello world
12:48:23 <ezyang> ok
12:48:37 <theorbtwo> Sigh.  Is there a langauge exstension of some sort that allows lists to end with a comma?  (Specifically, the list in a record data declaration.)
12:48:47 <copumpkin> foreign import builtincall "alloca" :P
12:48:56 <copumpkin> theorbtwo: no
12:48:59 <ben> But we already have alloca :I
12:49:08 <copumpkin> ben: but I want the c one dammit
12:49:10 <ddarius> Not C's alloca.
12:49:16 <ben> but
12:49:17 <ben> but!!
12:49:18 <mauke> theorbtwo: no, but as a workaround you can use :
12:49:20 <copumpkin> :P
12:51:21 <ddarius> roconnor: That semiring paper does look interesting.
12:51:25 <MissPiggy> theorbtwo, can't you just write   a : b : c : []
12:51:47 <ben> The list in a record data declaration!
12:51:47 <MissPiggy> that semiring stuff was too difficult for me
12:51:49 <copumpkin> hmm, I missed the semiring paper. Have a link?
12:52:08 <theorbtwo> I don't mean lists, the data structure you make with [] and :.  I mean lists, the syntatic structure.
12:52:22 <ddarius> copumpkin: http://geomete.com/abdali/papers/TCviaElim.pdf
12:52:26 <theorbtwo> data Foo = Foo {a, b, c, d,} deriving (Show)
12:52:29 <copumpkin> thanks :)
12:52:35 <MissPiggy> why do you want to write the extra comment?
12:52:39 <MissPiggy> comma*
12:52:47 <mauke> MissPiggy: consistency
12:52:55 <MissPiggy> what is consistent about it?
12:52:55 <theorbtwo> MissPiggy: Because it allows me to simply end all the lines with a comma, without worrying about which is the last one.
12:53:02 <mauke> MissPiggy: you can end every line with ,
12:53:09 <theorbtwo> It also allows me to comment out the last entry without changing the previous one.
12:53:11 <copumpkin> ooh, perfect, this paper is just what I wanted
12:53:28 <tobe96> and once again in my function that it just maps the positive numbers without Maybe/Just
12:53:29 <CalJohn> theorbtwo: is this problem solved by having commas at the start of a line?
12:53:31 <ddarius> copumpkin: Nothing like a little practical application of abstract abstract algebar.
12:53:39 <theorbtwo> CalJohn: Yes, but that's *ugly*
12:53:57 <mauke> CalJohn: no, that special cases the first line
12:53:57 <copumpkin> ddarius: and conveniently, providing some more examples for the paper I'm writing (advocating practical applications of algebra, among other things :P)
12:54:05 <copumpkin> very timely, thanks
12:54:13 <ddarius> copumpkin: Have you seen Provenance Semirings
12:54:16 <theorbtwo> ...especially since the semantic whitespace won't work if I indent the first line an extra two spaces to account for the missing comma-space.
12:54:18 <ddarius> @google "Provenance Semirings"
12:54:20 <lambdabot> http://db.cis.upenn.edu/DL/07/pods07.pdf
12:54:20 <lambdabot> Title: Provenance Semirings
12:54:23 <tobe96> like [Int] -> [Nat]
12:54:26 <theorbtwo> ...and it won't work if I comment out the *first* line.
12:54:31 <MissPiggy> theorbtwo you could put a dummy field in
12:54:38 <MissPiggy> one that is just () or whatever
12:54:47 <theorbtwo> Ew.  I'm trying to make my code prettier, not uglier.
12:54:52 <theorbtwo> Anyway, not that important.
12:54:53 <copumpkin> ddarius: ooh, I hadn't seen that. Looks interesting too, thanks
12:55:01 <mauke> theorbtwo: there is no good solution, haskell syntax hates us
12:55:02 <MissPiggy> theorbtwo it's ugly to write extra commas
12:55:45 <theorbtwo> I don't think it is.  (In that tiny example, yes.  In larger examples, reasonably spaced, it isn't.)
12:55:49 <ezyang> hmm, I keep getting unknown symbol
12:57:22 <sinelaw> copumpkin, what is your paper about?
12:58:58 <copumpkin> sinelaw: mostly type theory and algebra, advocating that despite seeming abstract, knowing about them is actually useful for programmers. was going to attempt to cover CT too but I only have 14 pages (10pt, single-spaced)
12:58:59 * hackagebot upload: vector-random 0.2 - Generate vectors filled with high quality pseudorandom numbers (DonaldStewart)
12:59:09 <copumpkin> wow, vector is getting so much love :)
12:59:18 <luite> wow that's great
12:59:27 <luite> that's something I really needed :)
12:59:40 <theorbtwo> Ah,
12:59:47 <copumpkin> it's surprisingly hard to generate vectors from a monadic stream!
12:59:52 <sinelaw> copumpkin, sounds great, will it be accessible for non-mathematicians?
12:59:55 <theorbtwo> -XDisambiguateRecordFields does seem nice, though.
13:00:27 <copumpkin> sinelaw: that's the goal and the target audience :) whether I succeed or not is another question, but considering I'm absolutely not a mathematician (although I'd like to be), I figure I have a decent idea of what non-mathematicians will understand
13:00:42 <sinelaw> copumpkin, even better :)
13:00:49 <sinelaw> copumpkin, i'm also writing a "paper"
13:00:56 <sinelaw> probably more like an exploded blog post
13:00:58 <copumpkin> mine is for a writing class :)
13:01:04 <copumpkin> if I'm satisfied with it I'll make it public
13:01:17 <sinelaw> mine is for funzorz, and same thing.
13:01:33 <copumpkin> :)
13:02:46 <sinelaw> copumpkin, btw, at least one usage of abstract algebra although probably not the type you're going to advocate, is finite fields
13:02:48 <roconnor> ddarius: I haven't really read it yet
13:02:52 <sinelaw> hey Peaker  :)
13:03:12 <Peaker> sinelaw, hey
13:03:23 <copumpkin> sinelaw: I considered it (for crypto and error codes?) but it didn't seem very accessible
13:03:47 <copumpkin> dons: good job! summing 100M randoms in 2.2 seconds is pretty nice
13:03:58 <roconnor> copumpkin ddarius, maybe I'll read it now
13:04:00 <copumpkin> I guess it never got "materialized" into memory, with the fusion?
13:04:17 <sinelaw> copumpkin, yes for error codes in particular. crypto is more complicated
13:04:33 <tobe96> what do I have to do to change my map/mapM function that it just maps the positive integers without using Maybe/Nothing?
13:04:40 <copumpkin> I would like to cover it, but it's tough to explain
13:04:49 <Peaker> tobe96, you could filter first
13:05:03 <olsner> hmm, I wonder if the mersenne golf would be shorter with a direct expression of the lucas-lehmer residue
13:05:03 <Alpounet> copumpkin, where will your paper be published ?
13:05:10 <ezyang> hmm, is GHCi clever enough to be able to dynamically load in object files that the FFI needs?
13:05:14 <sinelaw> copumpkin, yeah. i tried learning it for my error codes class and it was over the top (they didn't require us to know that stuff, only to be able to solve annoying technical problems)
13:05:19 <copumpkin> Alpounet: at a printer next to my prof's office, going straight into his mailbox :P
13:05:35 <sinelaw> copumpkin, is his mailbox really a shredder?
13:05:39 <Alpounet> haha
13:05:41 <copumpkin> lol, hope not
13:05:41 <sinelaw> as often happens
13:05:50 <sinelaw> :P
13:05:52 <Alpounet> okay, thought it was to be published somewhere public
13:06:00 <sinelaw> copumpkin, the monad reader maybe?
13:06:00 <copumpkin> nah, he really likes writing and seemed interested in the topic
13:06:15 <copumpkin> sinelaw: hm, maybe someday, but I'm really self-conscious about my writing
13:06:30 <tobe96> Peaker: ok, i'll try
13:06:38 <sinelaw> copumpkin, i'm too, but ego often tramples reason
13:06:46 <copumpkin> yep
13:06:50 <sinelaw> could be a good thing, btw
13:07:03 <sinelaw> it's a way to get constructive criticism
13:07:31 <HugoDaniel> i want to help haskell become more known, any plans for stuff to do ?
13:07:50 <Heffalump> how much time do you have? :-)
13:07:55 <copumpkin> sinelaw: true :) and I've considered setting up a blog to get over my self-consciousness by just writing a bunch of crap on it
13:08:04 <sinelaw> copumpkin, great idea.
13:08:05 <sinelaw> do it
13:08:14 <copumpkin> HugoDaniel: you need to hold up a sign at intersections
13:08:14 <DrTeggy> HugoDaniel, distribute lambda stickers
13:08:23 <endojelly> HugoDaniel, start a big project that becomes well-known and well-used
13:08:24 <sinelaw> Peaker, you should also do it.
13:08:27 <copumpkin> HugoDaniel: tell people they're going to hell if tthey don't learn haskell
13:08:37 <sinelaw> HugoDaniel, create a binding for OpenCV
13:08:45 <sinelaw> mail me when you're done, i need it.
13:08:50 <HugoDaniel> :D
13:09:00 <copumpkin> lol
13:09:09 <HugoDaniel> what happened to lua makes me think about "the easy way"
13:09:12 <copumpkin> HugoDaniel: reddit.com/r/haskell_proposals
13:09:27 <HugoDaniel> that is, just w8 for george lucas to decide to use haskell in one of his projs.
13:09:42 <copumpkin> oh yeah, we need more celebrities
13:09:47 <copumpkin> I vote for rainn wilson
13:09:59 <Peaker> sinelaw, do what?
13:10:04 <sinelaw> Peaker, start a blog
13:10:08 <Heffalump> what happened to lua?
13:10:11 <Peaker> sinelaw, I tried - I'm too lazy to write
13:10:17 <ezyang> aha! Needed -l and a shared library
13:10:18 <copumpkin> wolves started howling at it
13:10:23 * Heffalump suggests making Haskell better in some way, instead of more publicity
13:10:42 * sinelaw and a whole crowd of knuckleheads trample Heffalump
13:10:56 <sinelaw> make war, not love.
13:11:08 <MissPiggy> Heffalump named instances!
13:11:13 <sinelaw> j/k :@
13:11:21 <Peaker> I'm trying to show off Haskell to people at work - one of the main things that makes Haskell look bad is the default namespace pollution of "import Blah". I try to "cabal install haxml" but it fails because of bad version specs in the .cabal's, and when I try to find out where a symbol is supposed to come from, it's near impossible because of the imports :(
13:11:40 <sinelaw> Peaker, don't show off the problems
13:11:52 <sinelaw> especially in a new version of haskell that's not stable yet
13:11:58 <sinelaw> i mean the libraries not stable
13:12:01 <Peaker> sinelaw, well, Berko is trying stuff out and hitting these issues. Haskell's open unqualified import default is a horrible mistake
13:12:20 <sinelaw> yah
13:12:20 <MissPiggy> having prelude imported by default sucks too
13:12:26 <sinelaw> Peaker, using it at work, really?
13:12:26 <Peaker> sinelaw, well, it's just ghc 6.10.4.  But cabal-install's version-deps are too fragile. I think something like apt would be easier/nicer
13:12:40 <Peaker> sinelaw, I am trying to get it used for a build system and testing framework as a first taret
13:12:42 <Peaker> target
13:12:47 <sinelaw> cool!
13:12:56 <sinelaw> that would be a major achievement
13:13:40 <Peaker> If the module origin of all names was clear from the code - it'd probably be much easier to figure out what module signatures a module depends on
13:14:01 <Peaker> On the other hand, the syntax chosen for qualified imports is pretty horrible too
13:14:44 <sinelaw> yeah, the qualified should have been the default
13:14:45 <roconnor> whoa, d + ca*b
13:14:48 <sinelaw> not vice versa
13:14:56 <tobe96> Peaker: do I have to write my own filter function or can I do it somehow directly in my map/mapM?
13:15:14 <Peaker> tobe96, instead of mapM f xs - why not just:  mapM f . filter p $ xs  ?
13:15:16 <tobe96> or is there already a function that checks if a Int is >=0
13:15:25 <Peaker> tobe96, The function is called (>=0)
13:15:34 <Peaker> > filter (>=0) [-5..5]
13:15:35 <lambdabot>   [0,1,2,3,4,5]
13:15:46 <tobe96> ok
13:15:47 <jlouis> Could someone explain to me what this means: "Warning: The import of `Data.Maybe' is redundant"
13:15:55 <jlouis> GHC 6.12
13:16:04 <Saizan> Peaker: there's :info to find out where a symbol comes from
13:16:07 <copumpkin> it means, "DON'T DO IT"
13:16:21 <Peaker> Saizan, the problem I had was when a library ceased to export a symbol
13:16:25 <Peaker> Saizan, and it broke the compilation
13:16:30 <Peaker> Saizan, but I had no idea which library did so
13:16:42 <Peaker> Saizan, And there's really no way to find out except try to find it in all libraries
13:16:57 <jlouis> copumpkin: yeah, but I use things from Data.Maybe... what changed from 6.10 ot this version? Something in the base libraries?
13:17:12 <copumpkin> jlouis: I have no clue :( sorry for the useless answer :P
13:17:33 <Saizan> jlouis: the redundancy check has never been so reliable
13:17:54 <Peaker> The PVP recommends changing which of a.b.c  when breaking compatibility?  a or b?
13:18:00 <Peaker> Actually it's a.b.c.d iirc
13:18:08 <Saizan> there's no d
13:18:18 <Peaker> Saizan, Oh, those that have 4 are violating the PVP?
13:18:18 <Saizan> however you've to change at least b
13:18:23 <jlouis> Saizan: so it may be because something else pulls it in?
13:18:29 <jlouis> or the names from the module, that is
13:18:36 <jlouis> the identifiers....
13:18:41 <Peaker> Saizan, well, the packages I saw had version deps like:  >=0.6 <1   and broke upon the upgrade to 0.8
13:18:47 <Saizan> Peaker: the PVP doesn't talk about the fourth, iirc, so you can do what you want
13:18:47 <tobe96> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22556#a22556 what is "m Nat"?
13:18:54 <Heffalump> most languages have unrestricted imports - C#, Java, F#, C/C++
13:19:10 <Peaker> The fact a package has to specify which versions of other packages it works with (which depends on the future) is really problematic
13:19:32 <Saizan> >=0.6 <1 is too optimistic if you stick to the PVP :)
13:19:37 <Botje> tobe96: that code generates [m Nat] whereas you say it's [Nat], with m being a monadplus instance
13:19:48 <Peaker> Heffalump, C/C++ don't really have a module system.  I don't know C#/Java/F# very well.  Python has qualified imports by default. You have to: "from blah import *" to get unqualified, so you feel the pain
13:19:49 <jlouis> Heffalump: what do you mean by unrestricted imports?
13:20:10 <Botje> tobe96: of course if you filter out the bad ints, you don't need to check for them again with guard ..
13:20:20 <Peaker> Saizan, if it says >=0.6 <0.7  then it will too easily conflict with someone else who says >=0.7 <0.8
13:20:29 <tobe96> ahhh
13:20:30 <tobe96> mom
13:20:40 <Peaker> Saizan, This scheme doesn't seem to me like it actually works well in the general case (indeed I hit a lot of issues)
13:21:07 <Peaker> Saizan, Module signatures would be the way to go - but with open unqual. imports, how do you figure out the sigs you depend on?
13:21:08 <Saizan> Peaker: you need fairly active maintainers that release new versions to update the constraints
13:21:16 <sinelaw> C# doesn't let you access unqualified names unless you explicitly ask for it, and by default if you're using some namespace it will be fully qualified.
13:21:38 <Peaker> Saizan, Maybe the constraints of a package can be specified separately from the package, so they can be updated much more easily, say, by a build bot even?
13:21:54 <Saizan> Peaker: yes, that's an idea
13:23:12 <Heffalump> sinelaw: same for Haskell
13:23:36 <sinelaw> Heffalump, no, in haskell the "default way" to import stuff is unqualified
13:23:42 <ben> C++ has namespaces, they are p. cool
13:23:47 <Heffalump> I think that's a pretty minor difference
13:23:57 <Heffalump> most C# programs I've seen start with a whole bunch of "using blah"
13:24:05 <Heffalump> and there's no way to restrict the list of things imported from blah
13:24:09 <sinelaw> Heffalump, that sucks
13:24:21 <sinelaw> Peaker, you know what the real solution is :)
13:24:27 <sinelaw> lui
13:24:31 <Heffalump> jlouis: the ability to import everything exported by some other module
13:24:50 <Saizan> sticking to qualified imports solves very little
13:24:59 <acidjnk> hello
13:25:04 <Axman6> 'lo
13:25:46 <acidjnk> I'm currently trying to work through the Sipser: "Introduction To The Theory Of Computation". But the math part in the beginning is way to much simplified, or just plain wrong.
13:25:50 <jlouis> Heffalump: oh!
13:25:56 <acidjnk> Is there another introduction that is more formal?
13:26:05 <Sternmull> isnt "import Blah as Foo" good enought? As long as you always type "Foo.thingy" nothing bad can happen.
13:26:08 <jlouis> Axman6: 'lo.. your WireProto changes came in, and then I released v0.0 :P
13:26:12 <Alpounet> ben, be careful, every time I say something in C++ is cool I get hurt by 600 people
13:26:14 <chrisdone> check this mother out: http://www.kiboki.net/haskell/console/
13:26:16 <Alpounet> :p
13:26:21 <Axman6> jlouis: yeah i noticed :D
13:26:27 <acidjnk> I have a background in physics. We play very, very dirty already, but not THAT dirty.
13:26:44 <ben> Alpounet: The Haskell people are just jealous that C++ could afford a separate operator for namespace scope resolution
13:26:49 <copumpkin> acidjnk: hmm, like what is wrong? I remember using that book and don't remember anything particularly terrible about it
13:26:56 <Alpounet> ben, heh
13:27:06 <jlouis> Axman6: only nasty bug was that we forgot to encode it as size followed by payload on the wire
13:27:18 <Axman6> jlouis: loved the part of the email where you said you put yourslf as one of the people providing patches :P
13:27:19 <jlouis> other clients did not like that, somehow ,hehe
13:27:20 <tobe96> I got it
13:27:29 <Axman6> heh
13:27:29 <Saizan> Sternmull: lots of bad happen anyway, and now you've Foo.thingy everywhere
13:27:30 <acidjnk> For example Functions and Relations. "Function" is not properly defined (for example as a relation that satisfies certain additional requirements), rather explained simplified in layman terms.
13:27:33 <darkestkhan> sare you playing dirty in physics?? strange
13:27:36 <tobe96> thanks for all your help here! :)
13:28:05 <Sternmull> at least then i can see where what is coming from :)
13:28:07 <jlouis> Axman6: well, I
13:28:17 <jlouis> well, I *did* provide some patches here and there
13:28:30 <Axman6> :P
13:28:46 <acidjnk> http://pastebin.com/m725cb50d << "definition" of a function
13:29:20 * ddarius never actually uses the formal definition of (set) function except, I guess, implicitly to translate a relation to a function into the powerset.
13:29:27 <Axman6> acidjnk: what's wrong with it?
13:29:49 <acidjnk> A proper definition would be for example that a function is a relation that is definite and total (with definitions for definite and total).
13:29:50 <Axman6> seems to explain functions in haskell very well at least
13:30:11 <Saizan> Sternmull: it makes more sense to do an explict import Blah (thingy1, thingy2) at that point, ghc can even generate these lists for you.
13:30:24 <chrisdone> what do you guys think?
13:30:25 <acidjnk> A definition must introduce a new term based on previously defined terms. "input-output relationship" is undefined.
13:30:33 <acidjnk> Also "to take an input" is undefined at that point.
13:30:35 <Axman6> :\
13:30:46 <acidjnk> What it is, is just a layman explanation.
13:30:50 * Axman6 does not like people who nitpick
13:31:01 <Axman6> acidjnk: what's wrong with that?
13:31:19 <Axman6> lots of people, in fact, the majority of people, are laymen
13:31:25 <darkestkhan> not everyone has background in physics or any other science
13:31:46 <Saizan> that you can't _calculate_ with fuzzy definitions like those?
13:31:50 <acidjnk> The term "relation" has just been defined a page ago. Based on that it would have been easy to provide a proper definition.
13:32:18 <acidjnk> A function could be defined as a relation that satisfies two additional properties.
13:32:25 <Axman6> acidjnk: what is the point of the article you're reading?
13:32:29 <ddarius> Yay, tropical semiring.
13:32:34 <Saizan> humans are prone to misunderstandings, a formal definition frees the reader from guessing what the author intended.
13:32:36 <copumpkin> acidjnk: the point is to get the ideas that the book wants to cover across effectively, not get mired in technical definitions of things that most people have an intuitive grasp on (and whose definitions do not affect the topic of the book)
13:32:42 <acidjnk> It's an introduction to theoretical CS.
13:32:57 <Axman6> well, there you have it, and introduction
13:33:02 <chrisdone> @tell BONUS_ bump me
13:33:03 <lambdabot> Consider it noted.
13:33:03 <Axman6> quit whinging ;)
13:33:04 <copumpkin> it's an introduction mostly to complexity/language theory
13:33:26 <acidjnk> I can't check the given CS definitions later in that book, because I don't know much about that. But seing that the math definitions are wrong, I don't trust it.
13:33:30 <copumpkin> as far as I remember, at least
13:33:53 <Axman6> i've done many a course where things were losely (and ill) defined at the beginning, to be later made more concrete
13:34:17 <copumpkin> chrisdone: no :t ?
13:34:21 <Axman6> they don't sound wrong to me
13:34:26 <acidjnk> I'm really used to very dirty pragmatic math. Mathematicians hate my calculations. But that's a little too dirty even for me.
13:34:28 <Axman6> but, wrong /= precise
13:34:41 <Axman6> imprecise even
13:34:55 <copumpkin> my point is that the formal definition of a function (or even a set) is not relevant to the rather more applied stuff they cover in that book
13:35:11 <acidjnk> Ok, thanks.
13:35:28 <acidjnk> Can you recommend a more formal introduction for someone with not much CS knowledge?
13:35:31 <chrisdone> copumpkin: not yet but I've written it with that in mind for future changes
13:35:40 <Axman6> acidjnk: the one you're reading
13:35:48 <MissPiggy> acidjnk how can a definition be wrong?
13:35:52 <copumpkin> acidjnk: also, it's not really wrong (the definition you posted), just informal
13:36:20 <darkestkhan> acidjnk, how can you do some calculations in physics using dirty math??
13:36:45 <acidjnk> A definition is invalid when it uses terms that are not well-defined. This one uses terms that can be grasped intuitively, but are not formally correct given the previous basis.
13:37:04 <Axman6> acidjnk: no, it's not. stop being elitist and nitpicking :\
13:37:06 <copumpkin> acidjnk: so you want an axiomatic definition of a set? a relation?
13:37:12 <Janni> Hi.
13:37:16 <copumpkin> acidjnk: how far are we going to go? the word set is used throughout the book
13:37:18 <darkestkhan> hello
13:37:25 <acidjnk> darkestkhan, for example I can leave out the sets. So I just use for example x as a length of something, without saying what set x is from.
13:37:26 <copumpkin> spend the first chapter on ZFC
13:37:54 <acidjnk> copumpkin, actually just of the CS stuff. I don't mind if it skips the math basics.
13:37:56 <Axman6> acidjnk: CS is a lot about getting things done, not being co9mpletely precise. that's what we use computers for >_>
13:38:04 <acidjnk> I just don't trust the CS part when the math part is not formally correct.
13:38:06 <McFred> http://www.ihatehayley.com/index.php?id=0d560d71dfe3717c4baf54eea22a8933
13:38:14 <Janni> I was wondering where the dollar-operator ($) comes from? Was it a completely arbitrary choice, or is there some background?
13:38:18 * copumpkin shrugs
13:38:20 --- mode: ChanServ set +o mauke
13:38:20 --- kick: McFred was kicked by mauke (McFred)
13:38:22 <copumpkin> it's a good book
13:38:32 <acidjnk> Ok, thanks a lot for the help @all!
13:38:41 <copumpkin> :)
13:38:46 <acidjnk> Since you understand my concerns and still recommend it, I'll continue with this book.
13:38:48 <Axman6> acidjnk: so you're not going to trust this channel then? we're extremely rarely precise
13:39:19 <Saizan> are we?
13:39:21 <acidjnk> It's always valid to ommit and simplify things when it is clear for the reader and the writer how the proper form would look like.
13:39:38 <acidjnk> It's done all the time in proofs and calculations, even by very formal people.
13:39:45 <Axman6> Saizan: how often to you formally define addition before telling someone what the (+) function does?
13:40:08 <Saizan> Axman6: assuming prior knowledge is one thing, giving sloppy definitions is another
13:40:20 --- mode: mauke set -o mauke
13:40:36 <Saizan> however, i don't pretend to be rigorously formal on an irc channel either
13:40:45 <Axman6> i'd suspe3ct the definition given is not sloppy based on the context of the book
13:40:53 <Axman6> -3
13:41:21 <Axman6> if it explains enough to be able to use the rest of the book, then it's the perfect definition to use
13:41:55 <ddarius> Saizan: Few people have prior knowledge of the formal definition of real numbers.
13:41:56 <copumpkin> numb3rs
13:41:58 <Axman6> the purpose of the book is not to teach you the formal theory behind everything mentioned in it, and assuming it should do so is pretty rediculous
13:42:20 <copumpkin> few people even know formal definitions of any mathematical quantities they work with daily
13:42:27 <Sternmull> Can someone suggest me a haskell project with nice code? I would like to have something to look at when I dont know how to express something in haskell. Geometry/graphics related stuff would be really nice. At the moment I cant say what code is good and what is not so good. :)
13:42:32 <copumpkin> many theoretical CS people, even
13:42:42 <Heffalump> Sternmull: xmonad?
13:43:20 <Saizan> well, if it disturbed acidjnk i was assuming there were some point where this imprecise definition made some later logical conclusion appear doubtful
13:43:34 <Sternmull> Heffalump, oh right. I heared from that. Will take a look at it.
13:43:46 <Axman6> seemed to me he stopped when he read something he thought was wrong
13:44:37 <ddarius> Saizan: I don't think he's gotten much beyond that point.
13:44:57 <ddarius> Saizan: Also, its rare (especially in CS) for the set theoretic definition of function to matter.
13:45:17 * Axman6 wonders how acidjnk would treat a paper that showed how to cure all forms of cancer, without nand harm to the patient, which didn't formally define how an MRI machine worked
13:45:42 <Saizan> ddarius: in fact i'd wonder, do they mean set theoretic functions or computable functions?
13:47:36 <Axman6> any*
13:47:42 <copumpkin> Saizan: did you see the definition he linked to?
13:48:04 <copumpkin> I honestly didn't think it was that bad
13:48:51 <copumpkin> it didn't use the word relation, but it did say "relating"
13:49:06 <ddarius> copumpkin: It did use the word "relation."
13:49:15 <copumpkin> ah, I missed that then
13:49:43 <copumpkin> relation+ship
13:50:21 <acidjnk> I meant relation as a term for a subset of a cartesian product of two given sets.
13:50:37 <ddarius> copumpkin: Ah, we were both wrong.
13:50:48 <copumpkin> ddarius: at least yours was a substring
13:51:15 <acidjnk> Give two additional constraints to such a subset, and you have a proper definition of function, without anything dirty.
13:51:23 <ddarius> copumpkin: For me, I think it was the fact that as nouns, "relation" == "relationship" to me.
13:51:39 <copumpkin> automatic stemming in your brain!
13:52:02 <ddarius> copumpkin: They denote the same thing in my brain.
13:52:14 <copumpkin> yep
13:52:15 <Saizan> i guess that definition would just sound wordy and weird to me, but nothing more than that :)
13:52:46 <lysgaard> What would be the best datatype for the surface of a mspaint like program. That would be the image while it's being edited.
13:53:29 <olsner> array of pixels?
13:53:29 <Twey> UArray Pixel
13:53:34 <Twey> STUArray, maybe
13:53:35 <copumpkin> lysgaard: either a mutable array or some sort of region-index spatial datastructure containing smaller mutable arrays
13:53:36 <Twey> Nahh
13:54:05 <olsner> or ((Int,Int) -> Pixel)
13:54:10 <ddarius> @google Avry Smith
13:54:11 <lambdabot> http://www.facebook.com/people/Avry-Smith/1562000555
13:54:11 <lambdabot> Title: Incompatible Browser | Facebook
13:54:14 <ddarius> Curses.
13:54:41 <ddarius> @google Alvy Smith
13:54:42 <lambdabot> http://www.alvyray.com/
13:54:42 <lambdabot> Title: Alvy Ray Smith Homepage
13:54:59 <Twey> olsner: Annoying to update
13:55:05 <copumpkin> wow, that's quite a wegpage
13:55:06 <copumpkin> webpage
13:55:19 <Twey> Straight out of the nineties
13:55:35 <ddarius> http://www.alvyray.com/Memos/MemosMicrosoft.htm
13:56:38 <lysgaard> Twey: The difference between STUarray an Uarray is one is in the ST monad, right?
13:56:45 <Twey> Yeah
13:56:50 <olsner> UArrays are immutable
13:57:06 <Twey> Yeah, you probably want an… IOUArray?
13:57:16 <Twey> I can never remember the names of all the different arrays
13:57:25 <olsner> if there's even such a thing as UArray? IOUArray and STUArray exist though
13:57:37 <ddarius> What if we represent each pixel as a process...
13:57:45 <ddarius> olsner: Yes there is.
13:57:50 <jmcarthur> i think now i would just use the vector package instead of the standard arrys
13:57:52 <jmcarthur> *arrays
13:57:54 <ddarius> @hoogle UArray
13:57:54 <lambdabot> Data.Array.Unboxed data UArray i e
13:57:54 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
13:57:54 <lambdabot> Data.Array.IO.Internals castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
13:58:09 <olsner> ah, the power of hoogle
13:58:35 <xerox> makes one make sing, another man weep
13:58:55 <lysgaard> jmcarthur: Why the vector?
13:59:16 <jmcarthur> because it's fast and has a decent api now (compared to uvector)
13:59:26 <jmcarthur> and supported boxed types
13:59:29 <jmcarthur> *supports
13:59:59 <olsner> for pixels you probably want unboxed though
14:00:07 <jmcarthur> all the more reason to use vector then
14:00:14 <lysgaard> jmcarthur: Hm, okay, good point
14:00:38 <jmcarthur> hmm, i guess vector still doesn't have generic indexing though
14:00:41 <olsner> oh, there's mutable vectors, and even unboxed mutable vectors
14:00:44 <jmcarthur> that could be a pain, but not insurmountable
14:00:49 <jmcarthur> yeah
14:00:53 <copumpkin> I'm not a huge fan of generic indexing anywat
14:01:02 <jmcarthur> copumpkin: why not?
14:01:06 <copumpkin> using nested vectors carries no overhead anyway
14:01:12 <copumpkin> for multi-dimensional vectors
14:01:15 <jmcarthur> syntactic overhead
14:01:16 <lysgaard> jmcarthur: What's the difference of boxed vs. unboxed?
14:01:22 <copumpkin> jmcarthur: I guess
14:01:39 <copumpkin> jmcarthur: quick, vector-genericindexing on hackage ;) make an Ix-aware version
14:01:41 <jmcarthur> copumpkin: i like to think of arrays as dense maps, sometimes
14:01:58 <olsner> (arr ! y ! x) isn't much of an overhead, syntactically
14:02:21 <dolio> It definitely carries an overhead for unboxed vectors, since no Haskell library lets you nest unboxed vectors.
14:03:00 <olsner> hmm, is that just because it hasn't been done or is it actually hard to do?
14:03:30 <copumpkin> it should be possible eventually even with unboxed vectors
14:03:47 <copumpkin> doesn't DPH allow it?
14:03:50 <jmcarthur> sure, with an unboxed unboxed vector type...
14:03:56 <MissPiggy> whats up
14:03:57 <dolio> I guess it's possible.
14:04:09 <copumpkin> the whole thing about DPH was that it stores the flat version and a shape descriptor
14:04:16 <copumpkin> I thought vector was already doing that
14:04:18 <dolio> Well, as long as you're expecting a square vector.
14:04:37 <copumpkin> dolio: hm? it stores an explicit shape, so even ragged vectors work afaik
14:04:43 <copumpkin> but maybe not
14:04:49 <ddarius> Ragged vectors work.
14:05:06 <copumpkin> it's pretty neat
14:05:24 <copumpkin> but you're right, unboxed vectors of unboxed vectors doesn't seem to work in the current version of vector
14:05:30 <Alpounet> copumpkin, are you using your brand new library already on a project ?
14:05:36 <copumpkin> Alpounet: nope
14:05:45 <Alpounet> have one in mind ?
14:05:52 <copumpkin> Alpounet: not really :)
14:06:05 <jmcarthur> i know i've talked smack about DiffArray before, but how good is DiffArray if you actually don't need old versions of the arrays?
14:06:22 <copumpkin> TacticalGrace: do you know much about vector?
14:06:33 <jmcarthur> i've only talked smack about it for cases where you need the old versions, i hope
14:07:00 <Cale> jmcarthur: Actually, the only case I've seen where DiffArray performed admirably was one in which access to the old versions was necessary.
14:07:05 <Cale> (surprisingly)
14:07:10 <jmcarthur> ?!
14:07:10 <lambdabot> Maybe you meant: . ? @ v
14:07:13 <sinelaw> @hoogle (a -> b -> c->d) -> (a,b) -> c -> d
14:07:14 <lambdabot> No results found
14:07:16 <jmcarthur> how does that work?
14:07:17 <sinelaw> @pl (a -> b -> c->d) -> (a,b) -> c -> d
14:07:17 <lambdabot> (line 1, column 4):
14:07:17 <lambdabot> unexpected ">"
14:07:17 <lambdabot> expecting variable, "(", operator or ")"
14:07:27 <TacticalGrace> copumpkin: I'm not actively using or developing it, but depends what you want to know
14:07:29 <dolio> Oh, I see how you'd do ragged vectors. You just wouldn't be able to change the size of the stored vectors easily.
14:07:38 <Cale> jmcarthur: Well, it's all about having just the right amount of access to previous versions.
14:07:43 <sinelaw> @pl \f a b c -> f (a,b) c
14:07:43 <lambdabot> (. (,)) . (.)
14:07:47 <sinelaw> :(
14:07:55 <sinelaw> @pl \f a b  -> f (a,b)
14:07:55 <lambdabot> (. (,)) . (.)
14:07:58 <ddarius> dolio: DPH operates over immutable vectors.
14:08:02 <Cale> If you have *no* need to access the previous versions, the machinery which is making that possible is going to waste.
14:08:25 <dolio> ddarius: But vector has mutable vectors.
14:08:32 <copumpkin> TacticalGrace: I was wondering if you knew if vector was using the same flat + shape representation as DPH, because it doesn't seem possible to have unboxed vectors of unboxed vectors in vector
14:08:51 <ddarius> dolio: Yes, but I don't think vector is using the flattening stuff DPH uses.
14:08:52 <jmcarthur> Cale: well, my use case is in pure code though. i don't really want to go with ST...
14:09:09 <TacticalGrace> copumpkin: Vector is a spinn off of the *flat* layer of DPH
14:09:09 <dolio> And that's primarily what I think about when I'm talking about it, because I have a package that relies on the mutable vectors, and barely touches the immutable ones.
14:09:13 <Cale> Yeah, this was in pure code -- a backtracking puzzle solver.
14:09:17 <copumpkin> TacticalGrace: oh, I see
14:09:25 <jmcarthur> Cale: yeah, i just don't need the backtracking part
14:09:40 <TacticalGrace> copumpkin: so basically: DPH = vector + parallelism + nesting
14:09:40 <copumpkin> TacticalGrace: so no plans for the whole flat + shape representation in it for now?
14:09:45 <sinelaw> @pl (\xs -> zip xs (tail xs))
14:09:45 <lambdabot> ap zip tail
14:09:47 <copumpkin> ah
14:09:48 <jmcarthur> but it's all wrapped up in a tree structure and i don't really want to thread a monad all the way down there
14:09:52 <Cale> Another option is something like Data.Sequence
14:10:10 <jmcarthur> i suppose so
14:10:26 <Cale> I wonder if DiffArray does re-rooting.
14:10:29 <Cale> I don't think it does
14:10:32 <jmcarthur> i'll just stick with my lists for now. they are kind of short anyway
14:10:33 <TacticalGrace> copumpkin: vector is basically an effort to extract the flat + sequential part of DPH as a standalone package as it's useful outside of DPH, too
14:10:38 <copumpkin> I see
14:10:42 <TacticalGrace> if you want nesting, you will need to use DPH
14:10:44 <jmcarthur> it's just that i am indexing into them :\
14:11:10 <TacticalGrace> we are thinking about maybe also factorising the parallel part out at some point
14:11:15 <jmcarthur> they are mostly only 9 elements long. i don't think i can justify Data.Sequence for them
14:11:25 <jmcarthur> s/mostly/at maximum'
14:11:32 <copumpkin> TacticalGrace: so you could get all of DPH minus the P? including nesting etc.?
14:11:35 <TacticalGrace> but if you add nesting, too, you already have dph, so not really a point in doing that
14:11:36 <Cale> There was a nice persistent array implementation which did some clever things to try to keep the chains of modifications as short as possible, and merge them into the physical array when appropriate.
14:11:43 <copumpkin> oh, I see
14:11:53 <copumpkin> hmm
14:11:58 <Cale> But I don't think it was a Haskell implementation. I just saw the paper.
14:12:13 <jmcarthur> i'll just claim n=9 and call it constant time ;)
14:12:19 <Cale> Sudoku?
14:12:22 <TacticalGrace> When you compile a DPH program, you specify whether to use the seq or par version (ie, package dph-seq or package dph-par), that is already implemented
14:12:37 <copumpkin> TacticalGrace: I see, yeah
14:13:00 <Cale> UArray isn't bad when the arrays are small. I actually got a bit of improvement out of using DiffUArray though.
14:13:01 <Janni> When I for example lift a function from (:: a -> Maybe a) to (:: MonadPlus => a -> m a) the type checker complains about the signatures of subfunctions that contain "Monad m", commenting them out amends these type errors. How is this effect called, and how can it be handled?
14:13:03 <jmcarthur> Cale: no, tron. most turns have 3 possible moves for each player, 9 combinations
14:13:07 <Cale> ah
14:13:17 <MissPiggy> I put my code on github
14:13:36 <Cale> Janni: I'm not sure I understand what you mean...
14:13:43 <copumpkin> MissPiggy: nice, where?
14:13:58 <sinelaw> @pl \a -> (1,a)
14:13:58 <lambdabot> (,) 1
14:14:05 <sinelaw> > (1,) 2
14:14:06 <lambdabot>   <no location info>: parse error on input `)'
14:14:06 <heatsink> Janni: Maybe you ned ScopedTypeVariables? It may be assuming the subfunctions' "m" is a different variable than the outer functions' "m"
14:14:07 <MissPiggy> copumpkin please do rummage through and tell me if you get some ideas/suggestions http://github.com/odge/al-jabr
14:14:08 * copumpkin tries to remember all of MissPiggy's usernames
14:14:29 <Janni> heatsink: Yes, I guess that would be it. Makes sense
14:14:34 <xerox> copumpkin fax / soupdragon / vixey / MissPiggy ?
14:14:38 <sinelaw> > 1 `(,)` 2
14:14:39 <Janni> Cale: I'll provide some example in a moment
14:14:39 <lambdabot>   <no location info>: parse error on input `('
14:14:41 <copumpkin> cheshire!
14:14:55 <sinelaw> > 1 , 2
14:14:56 <lambdabot>   <no location info>: parse error on input `,'
14:14:59 <Cale> All type variables which are otherwise unquantified are implicitly bound by forall at the top level of each type signature.
14:15:03 <MissPiggy> anyone who wants to read my code tell me what you think :)
14:15:06 <ddarius> xerox: I can only verify two of those, but I know there are more than that.
14:15:08 <MissPiggy> and I will improve it etc
14:15:20 <Cale> At least, with the ScopedTypeVariables extension off.
14:15:25 <copumpkin> MissPiggy: I'll take a look soon, thanks
14:15:39 <xerox> ddarius more.. oh boy
14:15:57 <MissPiggy> I have not really got to the important parts yet but this shows the overall design
14:17:05 <danblick> hmm. neato. Happy + Alex + Template Haskell can go together to make little embedded DSLs.
14:17:55 <Janni> Cale: Yes, the extension fixes the problem. I'm trying to figure out how it all makes sense.
14:19:23 <sinelaw> @type \a b -> (a/b)
14:19:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:20:43 <heatsink> \ (a) (b) -> (/) a b
14:24:31 <MissPiggy> so yeah I hope that sort of design will hold up
14:24:43 <Philippa> Cale: with it on, you get the same behaviour computed bottom-up?
14:24:46 <MissPiggy> it took me a few attempts to figure out how to do names instances on haskell
14:24:56 <MissPiggy> (and that that was what I wanted)
14:25:14 <Philippa> (end result: fresh implicit quantifier for each type annotation)
14:25:40 <heatsink> What are names instances?
14:26:47 <mreh_> \() -> bar
14:26:57 <mreh_> never seen that before
14:27:13 <MissPiggy> heatsink, they don't actually exist so I ad-hocked them in
14:27:30 <MissPiggy> heatsink the idea is that you can define multiple instances for the same type (without needing a newtype -- this is essential for my stuff)
14:27:41 <MissPiggy> but still distinguish them somehow (by name)
14:27:42 <mreh_> \() -> wtf?
14:28:00 <Veinor> mreh_: ... what?
14:28:03 <Alpounet> these are called evil functions
14:28:05 <heatsink> MissPiggy: I thought those were called.... variables.
14:28:05 <Veinor> why would you do such a thing
14:28:27 <MissPiggy> heatsink yes it is implemented using variables
14:28:38 <mreh_> i'm reading a paper where that lambda expression (or variant) exists
14:28:58 <mreh_> I didn't even think that was valid Haskell, or made any sense either
14:29:15 <ddarius> Why wouldn't it be valid Haskell?
14:29:43 <mreh_> because it's not a lambda expression
14:30:01 <ddarius> Yes it is.
14:30:07 <dolio> > (\() -> 5) ()
14:30:08 <lambdabot>   5
14:30:12 <sinelaw> conal, I'm up to page 5.5 of my rant. What do you think about time shifting?
14:30:26 <mreh_> > (\() -> 5) "hello"
14:30:27 <lambdabot>   Couldn't match expected type `()'
14:30:27 <lambdabot>         against inferred type `[GHC.Types...
14:30:37 <mreh_> aaaaaaaaaaaaaaaaaaaaah
14:30:39 <mreh_> it's typed
14:30:56 <mauke> data () = ()
14:31:34 <mreh_> but... you can't use a constructor in a lambda expression like that, it only really makes sense because () has only one type constructor, and that is ()
14:31:35 <Alpounet> > \() -> 4 $ ()
14:31:36 <lambdabot>   No instance for (GHC.Num.Num (() -> b))
14:31:36 <lambdabot>    arising from the literal `4' at ...
14:31:54 <ddarius> mreh_: Uh, The syntax is \p -> e where p is a pattern and e an expression
14:32:04 <heatsink> MissPiggy: Can you point out an example in your git repo, so I can see what you mean?
14:32:06 <mauke> mreh_: yes, you can
14:32:07 <ddarius> > (\(x:xs) -> x) "foo"
14:32:08 <lambdabot>   'f'
14:32:23 <Alpounet> > (\() -> 4) ()
14:32:24 <lambdabot>   4
14:32:28 <MissPiggy> heatsink, e.g.
14:32:34 <mreh_> > (\(x:xs) -> x) []
14:32:35 <lambdabot>   * Exception: <interactive>:1:134-145: Non-exhaustive patterns in lambda
14:32:38 <MissPiggy> class (Abelian m id, Group m id, Monoid m id') => Ring m id id' where -- (a+b)c = ac+bc & c(a+b) = ca+cb
14:32:47 <mreh_> humm
14:32:56 <MissPiggy> so this is an abelian group (+) on the set m, and a monoid (*) on m
14:33:01 <mreh_> can you kick it?
14:33:05 <olsner> mreh_: since a lambda has only one pattern it has to match
14:33:19 <MissPiggy> you can implement stuff like
14:33:20 <MissPiggy> instance Monoid Integer Multiplicative where getIdentity _ = 1
14:33:24 <MissPiggy> &
14:33:24 <MissPiggy> instance Ring Integer Additive Multiplicative where
14:33:31 <Alpounet> oh
14:33:33 <mreh_> I didn't think lambdas were allowed to pattern match, that's all
14:33:40 <Alpounet> we were talking about that on alt-stdlib's channel
14:33:42 <Alpounet> few weeks ago
14:33:43 <ddarius> MissPiggy: If the where block is empty, you don't need to write 'where'.
14:33:55 <MissPiggy> Alpounet: about what?
14:34:13 <MissPiggy> ah I kind of gave up on that chan because jmcarthurs always doing something else
14:34:13 <heatsink> oh, I see!
14:34:14 <Alpounet> algebra implementation in haskell
14:34:31 <ivanm> dons: you around?
14:34:33 <mreh_> it seems odd that a lamba is pattern matched, they cannot match all cases on their own
14:34:42 <MissPiggy> heatsink -- does that explain it?
14:35:34 <Stalafin> i am searching for a library that helps me with vectors and matrices (in particular, I want to apply a rotation matrix to a set of vectors)
14:35:37 <Alpounet> mreh_, imagine you're sure your list isn't empty, because you pattern-matched it before, e.g, then you can directly use the pattern (x:xs) in the lambda
14:35:45 <ddarius> Stalafin: hmatrix?
14:35:51 <olsner> mreh_: kind of a shame, yeah... it would be nice if you could combine lambdas
14:36:08 <ddarius> There are plenty of irrefutable patterns, e.g. (x,y)
14:36:10 <dolio> I hear there's this thing called a case expression...
14:36:18 <heatsink> MisPiggy: I think so.  Are 'Additive' and 'Multiplicative' phantom types?
14:37:10 <mreh_> why would you put a case expression in a single line lambda
14:37:23 <olsner> to pattern match different constructors :)
14:37:26 <dolio> For branching.
14:37:40 <mreh_> yes I know, but why in a lambda
14:38:21 <Stalafin> ddarius: thank you very much, this looks great!
14:38:30 <dolio> I don't know, but it's a solution that already exists if you want to do branching matching in a lambda expression.
14:38:38 <MissPiggy> heatsink: they are just labels
14:38:41 <MissPiggy> I define like them this:
14:38:43 <MissPiggy> data Additive
14:38:46 <MissPiggy> data Multiplicative
14:38:56 <MissPiggy> but they don't really mean anything
14:39:14 <MissPiggy> you would be better having this named-instances stuff built into the language -- but of course that is not the cacse
14:39:18 <MissPiggy> case
14:39:21 <heatsink> Okay, yeah.
14:39:26 <mreh_> anyway, I need to find a way to manipulate and evaluate boolean logic expressions
14:39:26 <MissPiggy> so I have to do stuff like:
14:39:36 <mauke> mreh_: I've done that
14:39:44 <MissPiggy> ...  where (*) = getBinaryOperation (__ :: Multiplicative)
14:39:46 <heatsink> When using these classes, do you get errors about ambiguous variables if you don't include type signatures
14:39:52 <heatsink> ?
14:39:59 <MissPiggy> no there are no ambiguities, that's what naming things solves
14:40:07 <mreh_> mauke: some kind of AST?
14:40:16 <mauke> mreh_: I used strings and a bunch of regexes
14:40:19 <mauke> in perl
14:40:28 <MissPiggy> > False && True || (True && False || True)
14:40:29 <lambdabot>   True
14:40:30 * mauke laughs maniacally and runs away
14:40:31 <MissPiggy> mreh ^
14:40:32 <ksf> is there a deforestation system that exploits (map toUpper l, map toLower l) == unzipMap (\x -> (toUpper x, toLower x)) $ l ?
14:41:14 <mreh_> mauke: hsiloP?
14:41:17 <dolio> Which one of those is allegedly the better one?
14:41:33 <ksf> ...where unzipMap = unzip . map or the hand-inlined version I just wrote...
14:41:35 <mauke> mreh_: no, Polish
14:41:59 <ksf> dolio, the second one, because it only traverses l once
14:42:10 <mreh_> MissPiggy: I need to manipulate them too :) as far as I am aware, Haskell cannot manipulate Haskell
14:42:19 <MissPiggy> mreh_: what does it mean?
14:42:27 * Zao cues locales and glyphs which have no upper/lower corresponding character.
14:42:32 <ksf> ...there might be sharing and retainment issues, though.
14:42:41 <Alpounet> mreh_, if you need predicates, go for a sort of prolog edsl
14:42:43 <heatsink> MissPiggy: I like the instance naming method, anyway.
14:42:54 <MissPiggy> heatsink :P I don't like it but it's the best I can come up with!
14:43:09 <ksf> and such operations are quite common. for example, you might want to map both "read" and "understand" over a paper.
14:43:14 <Alpounet> ksf, can't a rewrite rule do the job here ?
14:43:38 <ksf> I think capturing the l is the tricky part
14:44:10 <Alpounet> hm
14:44:20 <MissPiggy> heatsink but yeah I am always open to change
14:44:31 <ksf> generally, to fire a rewrite rule you have to have some function to match on.
14:44:44 <MissPiggy> hm I wonder if She can do named instances somehow
14:45:17 <ksf> ...which would prohibit the rules to fire if you use explicit recursion, which disqualifies the approach even if it'd work.
14:47:42 <Stalafin> ddarius: how do i have to understand how the hmatrix library is handled? i have to important Numeric.LinearAlgebra; what I do not understand, is here: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Linear_algebra << those libraries under 2.1, do they all belong to Numeric.LinearAlgebra?
14:47:50 <Stalafin> ddarius: are they overlapping?
14:48:31 <ksf> the result of dons' streams paper is basically "if you want fusion, don't rewrite", after all.
14:50:09 * ksf is becoming cautious and decides not to claim that unzipMap is better before looking at some vacuum output
14:52:34 <ddarius> Stalafin: They don't all belong to Numeric.LinearAlgebra (and anyway, a module name doesn't "own" things below it).  They aren't overlappnig.
14:53:24 <ksf> usually, Foo.Bar exports the commonly used portions of Foo.Bar.*
14:53:35 <MissPiggy> :(
14:54:29 <ksf> ...that is, it might leave out definitions that are only necessary if you want to customize the lib, and internals (for which there isn't any guarantee that they're going to stay the same, or are trivially safe to use)
14:56:09 <ksf> the other possibility is a common prefix, e.g. there's multiple packages that put their modules into Text.ParsingCombinators.*. but Text.ParsingCombinators isn't a module you could import.
14:56:11 <Stalafin> ddarius: i don't quite understand... so HMatrix is a part of Numeric.LinearAlgebra?
14:56:20 <Alpounet> ksf, I guess fusion is your best bet yeah indeed
14:56:23 <Stalafin> ddarius: as i see it, there are several libraries listed there, which do similar stuff
14:56:53 <ivanm> gah! how do I build GHC and install it to ~/ ?
14:56:55 <ksf> Stalafin, the module Numeric.LinearAlgrebra is part of hmatrix
14:57:03 <ivanm> "make install" wants to put it into /usr/local :s
14:57:17 <ksf> ivanm, ./configure --prefix=/home/ivanm/ghc/
14:57:28 <ivanm> grrr...
14:57:34 <ivanm> you mean I have to build it all over again? :(
14:57:35 <ksf> export PATH=/home/ivanm/ghc/bin:$PATH
14:57:43 <ivanm> yes, I know that bit ;)
14:57:48 <ksf> nah reconfiguring won't rebuild everything.
14:57:59 <ivanm> but if I re-configure it, don't I have to re-build it?
14:58:10 <ksf> in fact, only the wrappers will be regenerated
14:58:27 <ivanm> \o/
14:58:41 <Stalafin> ksf: ah! okay... the term Numeric.LinearAlgebra sounds very generic....,thats why i was wondering, I guess
14:58:43 <holmak> hooray for separate build and install stages
14:59:14 <ksf> ...have a look at the ghc and ghci scripts. it's just a path that's passed to the real executable in ghc/lib
14:59:21 * ivanm doesn't think he likes this Quassel IRC client, but the only other option he could find on this computer was pidgin :s
14:59:56 <ksf> Stalafin, if you have multiple packages installed whose module names clash, you can use either "ghc-hide <packagename>" or alternatively import "<packagename>" Foo.Bar
15:00:14 <ksf> ...and enable {-# LANGUAGE PackageImports #-}
15:00:40 * ksf thinks -XPackageImports should be in h'.
15:01:13 <ksf> ...there's no real need to specify what a package is, just that it's a string that might be used to disambiguate imports.
15:03:44 <Veinor> what's PackageImports?
15:04:38 <Alpounet> it's to specify from which package (see ghc-pkg list, and all) you want to import a given module
15:04:57 <ksf> very useful for mtl and transformers
15:05:25 <Veinor> so if you have multiple packages that define Foo.Bar you can say import Foo.Bar from "pkg1"?
15:05:43 <ksf> ...I should configure my vim to start each .hs file with a lengthy list of assorted extensios
15:05:59 <ksf> it's import "mtl" Control.Monad.Trans
15:06:09 <ksf> ...the syntax is quite strange, yet.
15:06:11 <ksf> *yes
15:06:25 <Veinor> http://hackage.haskell.org/trac/ghc/wiki/PackageImports says it's import Control.Monad.Trans from "mtl"
15:06:36 <ksf> but it its'n.
15:06:41 <Veinor> :[
15:06:54 <MissPiggy> actually
15:06:57 <ivanm> preflex: seen byorgey
15:06:57 <preflex>  byorgey was last seen on ##logic 21 hours, 56 minutes and 52 seconds ago, saying: Peeter: I'm not sure what's wrong, sorry
15:07:00 <MissPiggy> I have no idea why differentials are tensors
15:07:32 <ddarius> They are fields of linear transformations.
15:07:37 <ivanm> @ask byorgey when I first saw the headline of your latest post on the haskell reddit, I thought you had re-invented the multiset package on hackage...
15:07:37 <lambdabot> Consider it noted.
15:07:49 <ksf> Veinor, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
15:07:54 <ksf> never trust the trac
15:08:03 <MissPiggy> ddarius, what exactly does that mean?
15:08:19 <MissPiggy> I have computation rusle for them like dx/\dy = -(dy/\dx)
15:08:21 <ddarius> There's a linear transformation valued function defined at each point in the manifold.
15:08:26 <MissPiggy> and I guess this is all from the tensor algebra
15:08:39 <ddarius> I hate tensor algebra.
15:08:52 <ddarius> Particularly traditional presentations of it.
15:08:53 <MissPiggy> so it's a function from  R^n say, into (R^n -> R^k) ?
15:09:01 <ddarius> A tensor is a multilinear function.
15:09:06 <MissPiggy> ddarius I don't know it yet :D I have a book called algebra which talks about it
15:09:34 <MissPiggy> if you know an especially good thing on it I would look that out
15:10:01 <ddarius> An X field is just a X-valued function on a manifold (perhaps with some smoothness guarantees).
15:10:19 <ddarius> So a vector field is just a function from a manifold M to a vector-space V.
15:11:01 <MissPiggy> okay
15:11:28 <MissPiggy> so a tensor field takes a point on the manifold to a tensor-space
15:11:29 <ddarius> MissPiggy: I'd highly recommend learning geometric algebra/calculus, before worrying about tensors.
15:12:13 <ddarius> MissPiggy: To a space of scalar-valued multilinear transformations, yes.  And you can identify some of those with vector-valued linear transformations.
15:12:14 <Cale> Philippa: You get that any variable which is explicitly forall'd in an outer signature doesn't get implicitly forall'd, but is instead bound by the explicit forall.
15:12:36 <Cale> Philippa: I believe ScopedTypeVariables has no effect if you don't explicitly write the foralls.
15:13:10 <MissPiggy> ddarius, this (Geometric algebra) looks like what I have been trying to find for a long time! to make sense of all the stuff
15:14:55 <ddarius> Geometric algebra makes all of physics and mathematical physics much simpler and clearer.
15:15:14 <MissPiggy> :D
15:19:02 <Veinor> I remember once I was reading a book on linear algebra and some guy called me an idiot for not knowing grade school math :|
15:20:09 <ivanm> Veinor: geez, you idiot
15:20:09 <ivanm> ;)
15:20:14 <Veinor> :P
15:21:29 <copumpkin> it's unfortunate that most people think they already know algebra
15:21:50 <MissPiggy> Geometric Algebra is so cool.
15:22:36 <ivanm> greetings, co-squash
15:22:55 <ivanm> bugger, HP failed because of editline :@
15:23:39 <ivanm> editline == libedit, doesn't it?
15:32:47 <Berengal> Yay, gtk2hs on 6.12
15:33:02 <Berengal> Means I don't need 6.10 as well to use threadscope
15:33:55 <Yoshibloke> Is there a quick way I can define show over a function say (Int -> Bool) ?
15:34:06 <MissPiggy> Yoshibloke what do you want it to display?
15:34:19 <Yoshibloke> just a string
15:34:20 <MissPiggy> (with teh right extentions) you can do instance Show (Int -> Bool) where ...
15:34:26 <copumpkin> > (==5)
15:34:27 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->False;3->False}
15:34:27 <MissPiggy> but I think that is flexible instances
15:34:30 <copumpkin> tada
15:34:42 <copumpkin> Yoshibloke: what string would it display?
15:34:42 <MissPiggy> copumpkin any thoughts ?
15:34:56 <copumpkin> MissPiggy: haven't looked at it yet, gonna take a shower then take a look :)
15:35:06 <Berengal> copumpkin: That's not really how you _define_ the show instance though, is it?
15:35:09 <Yoshibloke> Well basically I have a type X and it just want it to display some arbitrary name
15:35:17 <Yoshibloke> for that type
15:35:21 <Berengal> show _ = "Foo"
15:35:26 <copumpkin> :P
15:35:30 * copumpkin goes poof
15:35:43 <Yoshibloke> preferably without extensions :x
15:35:44 <xerox> on your pipe?
15:36:17 <Berengal> > let show _ = "<Function>" in show (==5)
15:36:18 <lambdabot>   "<Function>"
15:36:48 * hackagebot upload: Lastik 0.5 - A library for compiling programs in a variety of languages (TonyMorris)
15:37:16 <abuiles> Hi guys does someone know why if I do something like :i Signal Double I got all the instances for which double is instantiated,  but If I use a type synonym like type Speed = Double, and then I type :i Signal Speed, I don't get those instances
15:37:30 <Gracenotes> > typeOf chr
15:37:31 <lambdabot>   Int -> Char
15:38:15 <Yoshibloke> Berengal - Thanks, that works for now
15:38:22 <Gracenotes> abuiles: there is a funny thing with instance declaration and type synonyms
15:38:25 <ivanm> hmmm... dibblego is online and uploading packages, but he's not on IRC...
15:38:44 <Gracenotes> you can't declare instance AnyTypeClass Speed, either, normally
15:39:16 <Gracenotes> > typeOf id  -- also, sad panda
15:39:17 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:39:17 <lambdabot>    `Data.Typeable.Typeable a...
15:39:26 <ivanm> awwww... I thought Lastik was for internationalisation; wrong kind of languages :s
15:39:35 <Veinor> :t typeOf
15:39:37 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:40:31 <Berengal> ivanm: No, right kind of languages :P
15:40:46 <Veinor> > typeOf typeOf
15:40:47 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:40:47 <lambdabot>    `Data.Typeable.Typeable a...
15:40:55 <ivanm> depends on what kind of languages you were after I suppose...
15:41:19 <iago_> > sequence []
15:41:20 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
15:41:21 <lambdabot>    arising from a use of `M49640123...
15:41:33 <abuiles> Gracenotes : What could I do to fix that ?
15:42:38 <Alpounet> @type sequence
15:42:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:43:05 <iago_> > sequence [] :: [[Int]
15:43:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:43:07 <Gracenotes> @type typeOf :: TypeRep -> TypeRef
15:43:07 <iago_> > sequence [] :: [[Int]]
15:43:08 <lambdabot>     Not in scope: type constructor or class `TypeRef'
15:43:08 <lambdabot>   [[]]
15:43:13 <iago_> > sequence [] :: [[Int]]
15:43:14 <lambdabot>   [[]]
15:43:16 <MissPiggy> ddarius, wow The concinnity of geometry and algebra dates as far back at least to Euclid's Elements in the 3rd century B.C.;[
15:43:31 <iago_> > (sequence [[]] :: [[Int]])
15:43:31 <iago_> []
15:43:32 <lambdabot>   []
15:43:47 <Gracenotes> abuiles: not much. There is -XTypeSynonymInstances, not sure if that helps with :i, but you should probably stick with declaring and searching for instances with Double
15:44:02 <iago_> uhm
15:44:32 <abuiles> Gracenotes: thanks ;)
15:46:22 <iago_> oh I see
16:01:46 <Alpounet> wow 50% speedups on numerical code
16:01:49 <Alpounet> with llvm
16:10:38 <amxx> I have one list with 15 SqlValues from a database, and I want to convert it to a data type with 15 fields
16:10:59 <amxx> is there a better way than calling fromSql 15 times?
16:11:17 <ivanm> map?
16:11:34 <amxx> well, that doesnt work because they are different types
16:11:59 <Alpounet> amxx, don't you have a smart constructor-function that can do it for you ?
16:12:06 <ddarius> > ((,) <$> negate <*> id) 3 4
16:12:07 <lambdabot>   Couldn't match expected type `t1 -> t'
16:12:07 <lambdabot>         against inferred type `(a, a...
16:12:09 <ddarius> > ((,) <$> negate <*> id) 3
16:12:10 <lambdabot>   (-3,3)
16:12:56 <xerox> > (negate &&& id) 3
16:12:57 <lambdabot>   (-3,3)
16:13:41 <amxx> I guess I'm currently writing it
16:13:45 <Alpounet> :t <*>
16:13:46 <lambdabot> parse error on input `<*>'
16:13:50 <Alpounet> :t (<*>)
16:13:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:15:24 <copumpkin> MissPiggy: I like the algebra stuff, and tried something similar myself a while ago (with dummy types to indicate the operation). Unfortunately it got rather painful once I reached the two-operation structures or multiple-set structures
16:15:43 <ddarius> Multisorted algebra
16:15:46 <MissPiggy> I have a two-op but I haven't tried any multiple-set
16:15:54 <MissPiggy> I can't even think of one actually
16:16:00 <MissPiggy> well vector spaces I guess
16:16:00 <ddarius> Vector spaces
16:16:09 <copumpkin> modules
16:16:20 <ddarius> Modules being generalizations of vector spaces.
16:16:22 <MissPiggy> I'll try out vectors and modules asap then
16:16:29 <copumpkin> yep
16:17:33 <copumpkin> MissPiggy: also, the NonZero type isn't doing much
16:17:44 <copumpkin> in the Field module
16:17:53 <copumpkin> (I don't think)
16:18:04 <copumpkin> I think it would have to be a newtype to have a restrictive effect
16:18:56 <MissPiggy> that's a bit of a tricky issue I am not sure I totally sorted it..
16:19:18 <copumpkin> yeah, when I tried I didn't try to model things like that
16:19:30 <copumpkin> it'd be cool if you could figure it out
16:20:20 <MissPiggy> it's not quite accurate to say a field is a group m on +,0 and a group m\{0} on *,1 because you can still multiply by 0.. it's only inverses that are restricted -- I guess
16:21:10 <MissPiggy> but the idea with type Nonzero a = a is that it corresponds to a type which pairs up a proof that the values are not zero
16:21:23 <MissPiggy> of course that proof is erased when you reach haskell
16:21:54 <Alpounet> can be semi-solved using a smart constructor and exposing it only outside your module.
16:22:21 <ddarius> @hoogle fromSql
16:22:21 <lambdabot> No results found
16:23:47 <MissPiggy> copumpkin if I did use a newtype it might get a bit awkward having to unbox it and box it
16:24:02 <MissPiggy> but I guess that would give better error messages so that's a big plus
16:24:41 <MissPiggy> infact there's an easy way to turn (Nonzero a -> Nonzero a) into a total function (a -> a)
16:25:13 <MissPiggy> (all you need is ZEROP)
16:25:38 <ddarius> You don't need anything for that direction.
16:26:03 <copumpkin> MissPiggy: yeah, newtypes are a pain
16:26:24 <ddarius> :t let conjugate f g h = f . h . g in conjugate getZipList ZipList
16:26:25 <lambdabot> forall a a1. (ZipList a1 -> ZipList a) -> [a1] -> [a]
16:27:12 <MissPiggy> :t getZipList
16:27:13 <lambdabot> forall a. ZipList a -> [a]
16:27:21 <MissPiggy> :O
16:27:27 <copumpkin> natural transformation!
16:27:29 <copumpkin> zomg
16:27:53 <MissPiggy> that just blew a fuse in my brain
16:28:07 <Alpounet> and enlightened me
16:28:21 <ddarius> class NPFunctor f where npmap :: (b -> a) -> (c -> d) -> f a c -> f b d; instance NPFunctor (->) where npmap f g h = g . h . f
16:28:22 <copumpkin> :)
16:28:39 <Alpounet> np ?
16:28:53 <copumpkin> it's a no problem functor, man!
16:28:57 <ddarius> Negative-Positive.  It's contravariant in its first argument and covariant in the second.
16:29:00 <Veinor> :D
16:29:33 <ddarius> BiFunctor isn't wrong but usually means a functor covariant in both arguments and in Haskell that's what it would have to be.
16:29:34 <Alpounet> copumpkin, I guess no problem functors are the coolest around, right ?
16:29:40 <copumpkin> yep
16:29:44 <Alpounet> so cool
16:30:29 <Alpounet> ddarius, yeah ok
16:30:31 <Alpounet> thanks
16:30:36 <ddarius> All Hom functors are functors of this sort.
16:30:56 <ddarius> Indeed, that instance is the Hom functor instance.
16:33:45 <MissPiggy> Hom(-,-)
16:33:54 <MissPiggy> Hom(f,g)
16:34:35 <ddarius> Hom(f,g) = h ↦ g . h . f
16:35:04 <Zao> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22625#a22625 <- I have a feeling that this is simplifiable...
16:35:45 <Alpounet> :t maybe
16:35:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:36:37 <HugoDaniel> is there any recent study of haskell popularity growth ?
16:36:40 <MissPiggy> :t mapM print . take 1 . ?splashMessages
16:36:41 <lambdabot> forall a (f :: * -> *). (Show a, ?splashMessages::f [a], Functor f) => f (IO [()])
16:37:15 <MissPiggy> :t mapM_ print . take 1 . (\x -> ?splashMessages x)
16:37:16 <lambdabot> forall a t. (Show a, ?splashMessages::t -> [a], Functor ((->) t)) => t -> IO ()
16:37:18 <damd> let x = listToMaybe (splashMessages ss) in when (isJust x) (print $ fromJust x)
16:37:26 <damd> :\
16:37:26 <Zao> Alpounet: That'd require me to pass in an action for the Nothing case though, which is a bit meh.
16:37:48 <Alpounet> Zao, yeah
16:38:24 <Zao> The optimal way would be with the ability to pattern match on msg.
16:38:30 <Zao> Meh, I'll just define a helper function.
16:39:19 <doserj> when (not . null $ msgs) print (head msgs) where msgs = ...
16:40:53 <isaacd> What benchmarking library/approach should I use? (in this case, to compare Int/Integer implementations)
16:41:08 <benmachine> :t foldr (const . print) (return ())
16:41:09 <lambdabot> forall a. (Show a) => [a] -> IO ()
16:41:26 <adu> isaacd: QuickCheck?
16:41:30 <isaacd> There seem to be about five benchmarking libraries on hackage
16:41:52 <isaacd> adu: Quickcheck is good for correctness, but I don't think it does speed?
16:42:02 <benmachine> Zao: how about foldr (const . print) (return ()) (splashMessages ss)?
16:42:14 <adu> oh
16:42:33 <benmachine> draw = foldr (const . print) (return ()) . splashMessages
16:42:39 <benmachine> a bit weird, I'll grant you
16:42:47 <Zao> benmachine: I only want process the first element, if any.
16:42:51 <benmachine> mmhm
16:42:57 <MissPiggy> Zao did you see my way?
16:43:08 <benmachine> > foldr (const . show) "" [1..]
16:43:09 <lambdabot>   "1"
16:43:19 <Zao> > take 1 [] -- badaboom
16:43:20 <lambdabot>   []
16:43:23 <Zao> Aaw :(
16:43:35 <Zao> Confused it with head, heh.
16:43:52 <benmachine> Zao: foldr is just a condensed form of case on lists
16:44:06 <copumpkin> Zao: I'd be pretty confused with head from you
16:44:06 <benmachine> the "const" in the first argument tells it to ignore the tail of the list
16:44:08 <Zao> benmachine: Your way, while cute, will leave me scratching my head tomorrow :)
16:44:19 <MissPiggy> Zao :(
16:44:46 <mietek> How can I fight "Warning: The documentation for the following packages are not installed"?
16:44:47 <benmachine> Zao: then, case splashMessages ss of msg:_ -> print msg; _ -> return ()
16:44:53 <benmachine> note that print msg already returns ()
16:45:01 <mietek> I can clearly see I have documentation for base-3.0.3.2 installed.
16:45:11 <mietek> How do I tell that to the build system?
16:45:23 <Zao> benmachine: I've got other actions in my proper source, that do not.
16:45:41 <MissPiggy> grumble
16:45:45 <MissPiggy> why is he ignoring me
16:45:51 <benmachine> Zao: oh, well asking us to simplify something which is not actually what you are doing
16:45:56 <Zao> It felt like my example embodied the nub of the problem, but it was probably too simplified.
16:45:59 <benmachine> is going to result in wrong answers :P
16:46:18 <Zao> benmachine: Mostly because I haven't quite fleshed out what the function is supposed to do yet :)
16:46:24 <Zao> MissPiggy: I'm listening, it was a decent way.
16:46:35 <MissPiggy> so why not use it
16:46:35 <MissPiggy> ?
16:46:52 <Zao> MissPiggy: It wouldn't let me match on the result of invoking splashMessages.
16:47:10 <mtnviewmark> what about:    maybe (return ()) print $ listToMaybe splashMessages
16:47:13 <xerox> ?type (=<<) . mapM_
16:47:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m ()
16:47:18 <MissPiggy> Zao, what do you mean?
16:47:22 <dobie_gillis> i have a question about casting that may or may not be specific to GLint: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22634#a22634
16:47:24 <benmachine> mtnviewmark: listToMaybe is redundant there
16:47:34 <benmachine> you're converting one data type to another but then deconstructing it anyway
16:47:40 <mtnviewmark> I thought splashMessages was [String}
16:47:45 <Zao> MissPiggy: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22635#a22635
16:47:45 <benmachine> might as well deconstruct it directly, which is what foldr is for
16:48:00 <Zao> MissPiggy: The value I'm interested in printing is (currently) the string.
16:48:20 <Zao> In my original paste, it'd be like   case ... of   Just (_,msg) ->
16:48:28 <mtnviewmark> @dobie_gillis:   fromIntegral is your friend
16:48:28 <lambdabot> Unknown command, try @list
16:48:42 <mtnviewmark> :t fromIntegral
16:48:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:48:49 <Zao> Now, I can survive with just sneaking in a snd now, but I'd rather have an explicit match.
16:48:58 <benmachine> yeah I'd do that as case splasMessages ss of msg : _ -> whatever; _ -> whatever else
16:49:06 <dobie_gillis> mtnviewmark: ah okay thx..
16:49:09 <benmachine> which isn't much simpler but avoids the listToMaybe at least
16:49:27 <MissPiggy> draw = mapM_ match . take 1 . splashMessages where match (_,msg) = print msg
16:49:47 <MissPiggy> yes ?
16:49:56 <mtnviewmark> I like that one, MissPiggy
16:50:08 <MissPiggy> okay :)
16:50:11 <mtnviewmark> the "take 1" is very clear about the truncation
16:50:34 <mtnviewmark> and makes one think that perhaps, in the future, you might show more!
16:53:11 <tensorpudding> i uninstalled and the reinstalled ghc, and ghc-pkg lists the same packages as being still installed, even though they definitely are not, anyone know why that might be?
16:53:16 <zachk> is there a program out there to apply syntax highlighting to literate haskell and give a printable represenation?
16:53:28 <MissPiggy> zachk lhs2TeX ?
16:53:29 <MissPiggy> maybe
16:53:30 <zachk> tensorpudding: what operating system are you using
16:53:42 <tensorpudding> linux x86, installed to /usr/local
16:53:48 <zachk> MissPiggy: im on windows, but ill check it out
16:54:09 <Alpounet> with the right PATH, it should work zachk
16:54:11 <tensorpudding> i deleted /usr/local/lib/ghc-<version>/, and all the ghc-related binaries in /usr/local/bin/
16:54:20 <zachk> tensorpudding: what version of linux?
16:54:25 <tensorpudding> debian
16:54:36 <tensorpudding> i'm installing it from the binary package
16:54:39 <zachk> did you use the debian package installer or do it manually
16:54:54 <zachk> oh
16:55:25 <tensorpudding> i'm trying to leaf through the ghc install logs to figure out how it divined the existence of these packages but no luck so far
16:55:27 * ezyang has an alternate IntMap implementation... and it's only x5 slower! 
16:56:42 <ivanm> ezyang: you must be so proud...
16:56:44 <Zao> tensorpudding: User or global packages
16:56:45 <Zao> ?
16:56:51 <ezyang> ivanm: :-P
16:56:51 <tensorpudding> they used to be user
16:56:55 <tensorpudding> i'm trying to migrate to global
16:57:05 <tensorpudding> is the reason why i'm having this kerfuffle
16:57:11 <ezyang> anyway, I'm hoping to end up with something faster in the long run
16:57:26 <doserj> well, did you remove the user package database in ~/.ghc/?
16:57:32 <tensorpudding> oh!
16:57:43 <tensorpudding> is that where they keep them...
16:57:47 <tensorpudding> i didn't think of that
16:57:48 <Zao> Or wherever ghc-pkg list tells you they live
16:57:50 <Zao> *cough* /home/zao/.ghc/x86_64-linux-6.10.4/package.conf:
16:58:06 <tensorpudding> how did you get that?
16:58:18 <doserj> ghc-pkg list
16:58:23 <Zao> http://codepad.org/eg8BDzgS
16:58:49 <tensorpudding> oh damn, i didn't read the whole thing
16:58:51 <tensorpudding> i just saw the first line
16:59:08 <tensorpudding> which suggested they were all in /usr/local/lib/ghc-<version>/package.conf...
16:59:08 <Zao> Per-user things have a pesky tendency to live in per-user locations :P
16:59:16 <tensorpudding> yeah...
16:59:33 <tensorpudding> damn
16:59:38 <copumpkin> @quote pokemon
16:59:38 <lambdabot> chrisdone says: it's true that liftM2 is kind of like a pokemon battle where the Pokeball is the monad
16:59:44 <ezyang> ...
16:59:45 <tensorpudding> i have like...six different versions of ghc listed in ~/.ghc
16:59:58 <chrisdone> why I oughta!
17:01:16 <MissPiggy> copumpkin, I'm trying to do the nonzero thing but it's hard :|
17:01:58 <MissPiggy> if I have a m : monoid M and then I need a function m\0 : monoid (Nonzero m)
17:03:25 <MissPiggy> not sure if htat functions exists..
17:11:46 <oskimura> hi all
17:12:20 <ezyang> yo
17:13:15 <MissPiggy> io
17:18:36 <oskimura> how to way Word16 to BinaryString.
17:19:50 <Nereid_> MissPiggy: I don't understand your notation.
17:20:10 <MissPiggy> hm?
17:20:20 <Nereid_> if I have a m : monoid M ...
17:20:22 <Cale> oskimura: How is the BinaryString type defined?
17:20:32 <copumpkin> ByteString maybe?
17:20:38 <MissPiggy> m is some monoid with carrier M
17:20:54 <Nereid_> carrier
17:20:55 <Nereid_> ?
17:21:03 <copumpkin> the set over which the monoid operates
17:21:20 <MissPiggy> im kind of stuck right now though, Not sure what I should do
17:21:28 <Nereid_> and what is Nonzero m?
17:21:32 <copumpkin> MissPiggy: can't think of anything :/
17:22:08 <oskimura> sorry. ByteString
17:22:20 <copumpkin> check out Data.Binary or cereal
17:22:36 <Nereid_> yeah I'm not sure it exists.
17:23:11 <Nereid_> (monoids are nonempty, so what if m is a monoid with one element?)
17:23:38 <MissPiggy> Nereid_, yes this sort of thing is problem I have to think of!
17:24:04 <Cale> oskimura: If you can change it into a list of two Word8's you can use pack on it.
17:24:33 <copumpkin> > (0xFEFF .&. 0xFF00) `shiftR` 8
17:24:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:24:34 <lambdabot>    `Data.Bits.Bits t'
17:24:34 <lambdabot>      a...
17:24:48 <mietek> Any ideas how to get Cabal to stop doing this?  "Warning: The documentation for the following packages are not installed. No links will be generated to these packages: base-3.0.3.2"
17:25:01 <zachk> MissPiggy: lhs2tex is giving me errors im cabaling in pandoc
17:25:19 <ddarius> copumpkin: No need to mask if you are just going to shift and convert to Word8.
17:25:23 <copumpkin> true
17:26:01 <ddarius> mov ax, [word16] mov [bytevar], al
17:26:02 <copumpkin> wait, can you just truncate in a conversion?
17:26:27 <ddarius> > fromIntegral (257 :: Word16) :: Word8
17:26:29 <lambdabot>   1
17:26:41 <copumpkin> I see
17:27:10 <ddarius> > let b = 257 :: Word16 in (fromIntegral (b `shiftR` 8) :: Word8, fromIntegral b :: Word8)
17:27:11 <lambdabot>   (1,1)
17:27:42 <oskimura> thanks copumpkin_.
17:28:21 <ddarius> presumably you could do something like get . put to convert using Binary.
17:31:26 <oskimura> thanks ddarius_. that code is convert Word to Word8?
17:32:14 <copumpkin> fromIntegral
17:36:35 * copumpkin pokes psykotic 
17:37:41 <tensorpudding> so i'm confused
17:37:57 * MissPiggy too
17:38:18 <tensorpudding> does cabal-install ignore configuration to say to install packages globally  whenever you install packages as user through sudo?
17:38:24 <tensorpudding> because that would be *really stupid*
17:38:32 <tensorpudding> and seems to be what it's doing
17:38:47 <ivanm> mietek: the version of haddock is different from the version that came with GHC
17:39:01 <ivanm> just ignore it, it isn't that big a deal (you'll just miss out on some cross-library links)
17:41:50 <sshc> @hoogle Data.ByteString.Internal.ByteString -> Data.ByteString.ByteString
17:41:51 <lambdabot> Parse error:
17:41:51 <lambdabot>   --count=20 "Data.ByteString.Internal.ByteString -> Data.ByteString.ByteString"
17:41:51 <lambdabot>                  ^
17:42:11 <sshc> what is that error?
17:42:27 <mietek> ivanm: I was hoping to fix those links ;)
17:43:35 <sshc> I'm trying to fix    "Couldn't match expected type `L.ByteString' against inferred type `Data.ByteString.Internal.ByteString'
17:44:24 <MaciejP> Are Happstack people around here?
17:45:32 <copumpkin> instance Monad Itus
17:48:43 <twanvl> sshc: fromChunks :: [Strict.ByteString] -> Lazy.ByteString
17:51:40 <ezyang> woot. With an actual random distribution I'm only about x1.5 slower
17:51:45 <kniu> I don't understand.
17:51:50 * ezyang does a little dance 
17:52:05 <kniu> Why does my program use an entire core if left running for a few hours?
17:52:35 <Saizan> it gets hungry after a while?
17:52:40 <kniu> How would one write a daemon in Haskell?
17:52:49 <MissPiggy> a hell daemon?
17:52:57 <MissPiggy> or a nose daemon? I think you have to use C
17:53:11 <Draconx|Laptop> kniu, same way as in any other language.
17:53:26 <Alpounet> kniu, could you be more precise ?
17:53:41 <kniu> actually, nevermind.
17:53:45 <kniu> I can figure this out.
17:58:26 <dons> some initial results with -fllvm for fused code
17:58:27 <dons>  http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
17:58:31 <dons> totally roxors. -fllvm!!
17:58:39 <copumpkin> nice
18:00:24 <ddarius> dons: How about the new NCG coming in 6.14 or 6.16?
18:01:23 <dons> can't use that yet -- needs to get merged in.
18:01:29 <dons> the -fllvm stuff seems to be working really well.
18:02:17 <dons> worth an upmod, imo, http://www.reddit.com/r/programming/comments/b4ter/smoking_fast_haskell_code_using_ghcs_new_llvm/
18:04:27 <ivanm> dons: did you get my message wrt language-dot?
18:04:36 <Alpounet> that looks great
18:04:38 <p_l> hmm... does the LLVM backend use special instructions? Like the GC hooks or extensions?
18:04:51 <dons> ivanm: should be fine. it's all BSD
18:05:01 <dons> p_l: nope. just better low level optimizations
18:05:04 <ivanm> yeah, just figured it'd be polite first to check ;-)
18:05:23 <copumpkin> screw politeness!
18:05:41 <ivanm> @slap copumpkin
18:05:41 * lambdabot loves copumpkin, so no slapping
18:05:45 <ivanm> grrr...
18:05:49 <copumpkin> @slap ivanm
18:05:49 * lambdabot hits ivanm with a hammer, so they breaks into a thousand pieces
18:05:50 <ivanm> stupid squashes...
18:06:03 <ezyang> Question.
18:06:08 <copumpkin> Answer.
18:06:38 <ezyang> I'd like to generate some random data to test the performance with, but it turns out that the generation of this data swamps out any other cost centers in my program. How can I generate this data cheaply?
18:07:06 <dons> ezyang: using say, the vector-random package?
18:07:07 <jmcarthur> ezyang: what PRNG are you using?
18:07:09 <dons> or mersenne-random
18:07:22 <copumpkin> use the power of the vector
18:07:26 <ivanm> hang on, if the LLVM stuff was competitive with NCG but slightly slower than code compiled with GCC, does that mean that NCG is slower than code compiled with GCC?
18:07:27 <copumpkin> om
18:07:29 <dolio> How long does it take to build ghc HEAD?
18:07:36 <dons> ivanm: sometimes.
18:07:43 <Zao> Hour, half an hour?
18:07:46 <dons> but llvm really kills the fused loops. nothing comes close to it.
18:07:51 <dons> half an hour or so
18:07:51 <copumpkin> depends how many cores you have to throw at it
18:07:52 <ivanm> I knew it was meant to be a tad slower for stuff that used a lot of Doubles...
18:07:55 <dolio> Hmm, is that all?
18:07:56 <Zao> I've never completed a GHC build, as it explodes :P
18:08:03 <ivanm> Zao: and how good your machine is
18:08:05 <dons> i built it twice this morning.
18:08:07 <ezyang> jmcarthur: RandomIO
18:08:10 <dons> didn't seem to be a big deal.
18:08:14 <ezyang> dons: Ok, can try that
18:08:15 <dons> ezyang: switch to mersenne-random-pure64
18:08:19 <Zao> ivanm: No machine can save me from stage2 not executing properly :P
18:08:26 <ivanm> bah
18:08:37 <dolio> Maybe I'll build it, so I can work on vector-algorithms with a compiler that doesn't go crazy.
18:09:20 <copumpkin> how does it go crazy right now?
18:09:28 <ivanm> so GHC+LLVM needs not only HEAD GHC but also HEAD LLVM?
18:09:53 <Alpounet> ivanm, for a registered ghc build, apparently
18:09:54 <Zao> ivanm: Patched LLVM.
18:09:59 <ivanm> ahhh
18:10:03 <Saizan> and patched GHC
18:10:11 <dons> i found it very easy to get ghc head and llvm working.
18:10:23 <Zao> As there's some shenanigans going on that are not in upstream.
18:10:30 <dons> -fvia-C seems to be failing on my box (linker / symbol errors), and you need darcs gtk2hs
18:10:34 <dons> but otherwise, pretty good.
18:10:40 <Zao> You need to sneak in some "tables not next to code" or suchlike option too in build.mk.
18:10:49 <dons> yeah. follow the destructions on the wiki.
18:10:51 <Zao> The author's mail ought to be enough to build it.
18:10:59 <Zao> Or the copypastaed wiki page :)
18:11:00 <dolio> copumpkin: It gets really confused with the PrimMonad stuff. Roman's getting approximately uvector-like performance out of my code, but when I run it, it's 2-4x slower for ST, and like 20x or more slower for IO.
18:11:10 <copumpkin> wow
18:11:14 <copumpkin> you on 6.12.1?
18:11:19 <dolio> Yes.
18:11:23 * Alpounet gotta try vector for hnn
18:11:26 <copumpkin> weird
18:20:11 <sheikra> Hi, has anyone explored whether there are connections between separation logic and monads?
18:20:44 <ezyang> aye, Haskell is being too clever and optimizing out my computation :-(
18:20:57 * ivanm has no idea what separation logic is, so will have to go with "no"
18:21:02 <ivanm> ezyang: heh
18:21:51 <copumpkin> ivanm: with the same amount of knowledge, I'd go with "I have no clue", myself
18:22:10 <sheikra> ivanm: nevermind. It's a logic for reasoning about heaps, mutable states etc.
18:22:11 <ivanm> copumpkin: good, so it's unanimous then ;-)
18:22:43 <ivanm> sheikra: so it might be valid for the ST monad then...
18:23:08 <sheikra> ivanm: I guess there is some similarity, but not sure.
18:23:21 <dolio> There may be some work with indexed monads.
18:23:24 <copumpkin> http://comonad.com/reader/2007/parameterized-monads-in-haskell/
18:24:28 <dolio> That might be what YNot is. I'm not really sure.
18:24:41 <sheikra> ivanm: It's for low level languages like assembly or C.
18:25:11 <sheikra> dolio: YNot seems to build on Hoare type theory, a decendent of separation logic
18:25:23 <dolio> Oh, okay.
18:26:02 <sheikra> dolio: ah, I guess you don't find it interesting
18:26:23 <dolio> I do, but it isn't something I've gotten around to looking at yet.
18:26:35 <ivanm> preflex: seen Axman6
18:26:35 <preflex>  Axman6 was last seen on #haskell 4 hours, 38 minutes and 59 seconds ago, saying: any*
18:27:21 <copumpkin> ivanm: any plans about your graph library, or are you just going to wait until superclass equality constraints are added?
18:27:21 <dolio> That's what I'd expect the extension of something like IO into a dependently typed language to be.
18:27:35 <ddarius> sheikra: I think there are connections between (stacks of) state monads and separation logic.
18:27:41 <ivanm> copumpkin: I might do a pre-release at some point without mapping support
18:27:50 <ivanm> but atm I'm trying to improve graphviz
18:28:00 <ivanm> (and starting my PhD... so guess which one I'm doing :p )
18:28:07 <noggle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22647#a22647
18:28:09 <dolio> An indexed monad that somehow encodes logic about how the heap/state/whatever is manipulated via the indices.
18:28:19 <copumpkin> ivanm: hah
18:28:21 <noggle> I am learning haskell
18:28:37 <noggle> can someone look at that paste?
18:28:43 <noggle> let me know if there is a better way
18:28:44 <ivanm> noggle: what are you trying to do?
18:28:57 <sheikra> ddarius: You mean stack and not heap?
18:28:57 <noggle> learn haskell
18:28:59 <aavogt> @type let
18:29:00 <lambdabot> <no location info>: not an expression: `let'
18:29:00 <aavogt> scalarProduct xs ys = sum [fst z * snd z | z <- (zip [x | x <- xs] [y | y <- ys])]
18:29:06 <Zao> Smells like a dot product.
18:29:09 <ivanm> noggle: first of all, "fst z * snd z" == uncurry (*) z
18:29:11 <noggle> yeah
18:29:13 <Twey>  [x | x <- xs] = xs
18:29:31 <ivanm> zipWith (*) xs ys
18:29:36 <noggle> I have not found the uncurry function
18:29:37 <ivanm> sum $ zipWith (*) xs ys -- forgot the sum
18:29:40 <ivanm> @type uncurry
18:29:41 <noggle> ahhh!
18:29:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:29:43 <ivanm> @src uncurry
18:29:43 <lambdabot> uncurry f p = f (fst p) (snd p)
18:29:44 <aavogt> @type let scalarProduct xs ys = sum [a*b | (a,b) <- zip xs ys] in scalarProduct
18:29:45 <noggle> nice zipWith
18:29:45 <lambdabot> forall b. (Num b) => [b] -> [b] -> b
18:29:54 <Twey> scalarProduct xs ys = sum [x * y | x <- xs, y <- ys]
18:30:01 <Zao> @type zipWith
18:30:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:30:08 <Twey> Ah, yeah, that's a zipWith right enough
18:30:25 <Twey> scalarProduct = fmap sum . zipWith (*)
18:30:29 <ddarius> sheikra: I mean transformer stacks.
18:30:29 <dolio> Of course, maybe what I'm saying has nothing to do with separation logic.
18:30:40 <noggle> Twey: wouldnt your version be 20 if vecA = 1,2,3 and vecB = 1,2,3?
18:30:55 <Ziphilt> hello all
18:31:01 <noggle> wow
18:31:02 <Twey> > (fmap sum . zipWith) [1, 2, 3] [1, 2, 3]
18:31:03 <lambdabot>   Couldn't match expected type `[a]'
18:31:04 <lambdabot>         against inferred type `[b] -> [c]'
18:31:04 <ivanm> greetings, Ziphilt
18:31:05 <aavogt> > join (liftA2 (*)) [1,2,3]
18:31:06 <lambdabot>   [1,2,3,2,4,6,3,6,9]
18:31:10 <Twey> Oops
18:31:11 <aavogt> > sum $ join (liftA2 (*)) [1,2,3]
18:31:12 <lambdabot>   36
18:31:14 <Twey> > (fmap sum . zipWith (*)) [1, 2, 3] [1, 2, 3]
18:31:15 <noggle> super helpful room
18:31:16 <lambdabot>   14
18:31:20 <Ziphilt> i am probably being silly by asking this, because i will learn it eventually
18:31:21 <ivanm> Twey: stop confusing the newbie with the (a->) Functor!
18:31:43 <Twey> ivanm: Why?  All compositions are fmaps here anyway :þ
18:31:45 <noggle> well, since I am a programing noob
18:31:48 <Twey> :t (.)
18:31:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:31:53 <Ziphilt> but does Haskell have anything like Lisp's eval and apply?
18:31:53 <noggle> I am enjoying this language
18:32:00 <ivanm> Ziphilt: not really
18:32:22 <ivanm> Ziphilt: you can use the hint library to get GHC to evaluate code "on the fly", but you usually don't want to do that
18:32:27 <Saizan> you can use the ghc-api to interpret haskell code
18:32:27 <dons> Ziphilt: in the form of template haskell (compile time metaprogramming)
18:32:46 <ivanm> oooh, didn't think about TH
18:32:53 <Ziphilt> interesting
18:33:11 * ezyang can't make it fast enough, and is running out of ideas 
18:33:21 <noggle> what is a functor?
18:33:31 <noggle> wikipedia hooooo!
18:33:40 <ivanm> noggle: very simply, it's a structure containing an arbitrary value to which you can apply a function
18:33:42 <ivanm> @src Functor
18:33:42 <lambdabot> class  Functor f  where
18:33:42 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:33:47 <Twey> noggle: Nah, that won't help — try Typeclassopedia
18:34:01 <noggle> good lord
18:34:09 <Twey> But as ivanm was implying, mine could have been written: scalarProduct = (sum .) . zipWith (*)
18:34:10 <noggle> this explanation sucks on wikipedia
18:34:14 <ivanm> noggle: lists are Functors, with fmap = map; Maybe is a functor (you can apply a function to the value in a Just), etc.
18:34:17 * noggle is not a mathematician
18:34:19 <ivanm> agreed; Typeclassopedia
18:34:21 <Twey> noggle: You'll get the mathematical definition instead of the Haskell definition
18:34:22 <ivanm> @where Typeclassopedia
18:34:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:34:26 <ivanm> noggle: ^^
18:34:26 <aavogt> wikipedia has an article about more general functors
18:34:40 <Ziphilt> thanks ivanm, Saizan, and dons for the quick responses
18:34:40 <MissPiggy> r?
18:34:42 <Twey> > fmap (* 2) (Just 5)
18:34:43 <lambdabot>   Just 10
18:34:45 <Twey> > fmap (* 2) Nothing
18:34:46 <noggle> sweeeeet
18:34:46 <lambdabot>   Nothing
18:34:48 <Ziphilt> that's all i needed to know for now
18:34:52 <MissPiggy> noggle: To know what a FUNCTOR is you need to know a few other things
18:34:59 <ivanm> Twey: I would say even the (sum .) might not be obvious enough to a newbie
18:35:05 <MissPiggy> noggle, but for Haskell you can use it and not worry about the mathematics
18:35:10 <Twey> ivanm: It can be worked through
18:35:16 <ivanm> true
18:35:49 <noggle> cool
18:35:59 <noggle> I am working through the exercises in some slides
18:36:31 <noggle> working up to this IO monad business so I can create a crawler.
18:36:37 <noggle> or at least try
18:36:39 <noggle> haah
18:36:56 <ivanm> as in a web crawler?
18:37:53 <noggle> ivanm: well, not really there will be a user that submits a location of a file
18:38:12 <noggle> my shiny haskell contraption will go fetch that file
18:38:20 <noggle> and hopefully several 1,000 others
18:38:25 <noggle> parsing them
18:38:31 <noggle> and making the data available to other programs
18:38:39 <noggle> I want to learn haskell
18:38:45 <noggle> so I am going to write it in haskell
18:38:57 <noggle> figured it would be a god way to start
18:38:58 <ivanm> fair enough
18:44:03 <ezyang> Is there a way to go from Word# to CUInt?
18:46:13 <dmwit> ezyang: probably via Int or Integer
18:46:28 <dmwit> ezyang: e.g. toEnum . fromEnum or fromIntegral
18:46:39 <aavogt> @instances-importing Word#
18:46:40 <lambdabot> Couldn't find class `Word#'. Try @instances-importing
18:46:42 <aavogt> @instances-importing Word
18:46:43 <lambdabot> Couldn't find class `Word'. Try @instances-importing
18:46:47 <copumpkin> it's an unlifted type
18:46:54 <copumpkin> word2Int# :: Word# -> Int#
18:47:00 <copumpkin> then wrap it in the CUInt constructor
18:47:39 <dmwit> Oh, I thought he was using Word# as a glob for Word8/Word16/Word32.
18:47:42 <dmwit> I guess that was kind of dumb.
18:47:58 <ezyang> won't... that cause overflows?
18:48:15 <ezyang> Or is word2Int# dumb?
18:48:20 <copumpkin> ezyang: well, it's just reinterpreting it as an Int#, which may treat it as negative
18:48:21 <ezyang> (as in a direct internal cast)
18:48:24 <ezyang> aha!
18:48:27 <copumpkin> it's doing absolutely nothing
18:48:31 <copumpkin> :)
18:48:32 <ezyang> excellent, that's precisely what I want
18:49:07 <copumpkin> :k (,)
18:49:07 <lambdabot> * -> * -> *
18:49:10 <copumpkin> :k (#,#)
18:49:11 <lambdabot> ? -> ? -> (#)
18:49:21 <copumpkin> :k (#,,#)
18:49:21 <lambdabot> ? -> ? -> ? -> (#)
18:50:18 <ezyang> those look kinda... scary
18:50:31 <copumpkin> I wonder why they're even available in lambdabot
18:51:22 <dmwit> ezyang: They're supposed to. =)
18:51:45 <ezyang> Ok, who exports the CUInt/CInt constructors?
18:52:00 <ski> @index CInt
18:52:00 <lambdabot> Foreign.C.Types, Foreign.C
18:52:08 <copumpkin> they're kind of hard to find
18:52:16 <copumpkin> they're constructed by macros in there
18:52:33 <ezyang> ski: Those two modules don't have the constructors, just the types..
18:52:47 <ddarius> copumpkin: Why shouldn't they be?
18:52:48 <copumpkin> ezyang: I'd just make an Int and fromIntegral it
18:52:48 <ski> .. i was wondering about that
18:53:05 <copumpkin> ddarius: I'm not saying they shouldn't be, just that looking at the source code won't show you the constructors
18:53:21 <ezyang> I was hoping to make GHC inline the popcount function I wrote
18:53:31 <copumpkin> ezyang: {-# INLINE #-}
18:53:37 <copumpkin> with a function name after it :P
18:53:43 <ezyang> oh lol
18:53:56 <copumpkin> for most things, you probably don't need unlifted types
18:56:52 <ezyang> cool, that shaved like 6% off popCount execution time
18:57:30 <Dark_Shikari> >popcount function I wrote
18:57:33 <Dark_Shikari> just use the CPU instruction ;)
18:57:40 <ezyang> I am
18:57:44 <ezyang> via the FFI
18:57:50 <Dark_Shikari> you have a phenom?
18:58:04 <ezyang> I'm trusting GCC to dtrt
18:58:20 <Dark_Shikari> the only x86 CPU with a popcnt instruction is the phenom
18:58:21 <ezyang> inline int popcount(unsigned int w) {     return __builtin_popcount(w); }
18:58:28 <copumpkin> ah
18:58:32 <Dark_Shikari> gcc's builtins are notoriously terrible if there is no internal instruction for them
18:58:35 <Dark_Shikari> and sometimes, they are even when there is
18:58:42 <ezyang> hmmmm
18:58:49 <Dark_Shikari> see http://hardwarebug.org/2010/01/14/beware-the-builtins/
18:58:55 <Dark_Shikari> and gcc generating 100 instructions for a bswap
18:59:00 <copumpkin> I think my pending gmp additions patches to GHC should have fast popcount for Integer
18:59:05 <ezyang> Yay!
18:59:12 <Dark_Shikari> btw, the fastest way to do popcnt is using a LUT
18:59:12 <ezyang> although, I only need fast popcount for Int/Word
18:59:23 <copumpkin> oh, hrrmpf
18:59:29 <Dark_Shikari> (if there's no instruction for it)
18:59:54 <ezyang> I pretty certainly don't have a phenom
19:00:01 <ezyang> lemme see what algo gcc is using...
19:00:24 <ezyang> wow, that's pretty terrible
19:00:30 <Dark_Shikari> note gcc tends to not use LUTs in its builtins
19:00:39 <Dark_Shikari> you can usually make much much faster algorithms if you're willing to use a LUT for part of it
19:01:03 <ezyang> what does LUT expand to?
19:01:06 <Dark_Shikari> lookup table
19:01:21 <Dark_Shikari> here's an example of a lut-driven bitmath function http://pastebin.com/m59beb8a2
19:01:28 <Dark_Shikari> calculates clz (count leading zeroes)
19:01:47 <ezyang> aah
19:02:33 <ezyang> According to Bagwell, "a CTPOP instruction is available on most modern computer architectures including Intel Itanium, Compaq Alpha..."
19:02:45 <Dark_Shikari> >alpha
19:02:46 <Dark_Shikari> >itanium
19:02:51 <Dark_Shikari> yes, architectures that nobody uses
19:03:05 <ezyang> heh
19:03:36 <Dark_Shikari> UltraSparc, Alpha, Cray have it
19:03:45 <Dark_Shikari> Alliant FX... wow, lists of really old cpus
19:04:04 <Dark_Shikari> oh yeah, ARM doesn't have it
19:04:16 <ezyang> well, this is a ~decade old paper
19:04:19 <Dark_Shikari> so even _good_ instruction sets don't have it
19:04:35 <orbitz> Are there any language where mutable data structures are not first class?  So in the scope of a funciton I could modify a the data structure all I want but i cannot return it or call a function with it?
19:04:56 <ezyang> orbitz: Haskell is one of them, using the ST monad
19:05:15 <orbitz> but isn't the compiler doing some magic there rather than ST actually being mutable?
19:05:21 <copumpkin> no, ST is mutable
19:05:30 <bsdunx> Has Intel made much use of the DEC IP they got from Compaq or have they just buried it?
19:05:33 <ezyang> ok, I'm going to swap in a 8-bit LUT from http://dalkescientific.com/writings/diary/popcnt.c and see what that does to my profile
19:05:37 <orbitz> hrm
19:05:58 <Dark_Shikari> ezyang: which one?
19:06:00 <ezyang> Dark_Shikari: If you approve of that source, anyway:
19:06:22 <ezyang> Dark_Shikari: hard to say, since these implementations are for not-8-bit values
19:06:25 <orbitz> copumpkin: now that just meses me up
19:06:28 <orbitz> pure functional my butt!
19:06:30 <Dark_Shikari> wait, you only need an 8-bit LUT?
19:06:35 <Dark_Shikari> er, 8-bit input values
19:06:40 <copumpkin> orbitz: it's "extensionally" purely functional :)
19:06:47 <kniu> apparently, calling the forever function on anything uses up an entire core.
19:06:56 <orbitz> copumpkin: whta's that mean?
19:06:56 <kniu> how do I prevent this?
19:07:02 <copumpkin> orbitz: it uses the type system to make sure nobody else on the outside can observe the mutation
19:07:07 <copumpkin> orbitz: "seen from the outside"
19:07:19 <ezyang> oh, no, that's not true
19:07:24 <ezyang> I have 32 bit inputs
19:07:27 <Dark_Shikari> ezyang: simple
19:07:30 <Dark_Shikari> make a 256-entry LUT
19:07:51 <Dark_Shikari> lut[x&0ff] + lut[(x>>8)&0xff] + lut[(x>>16)&0xff] + lut[x>>24]
19:07:54 <Dark_Shikari> done.
19:08:03 <Saizan> kniu: which monad is this?
19:09:09 <orbitz> copumpkin: ah sounds exaclty like what i said then
19:09:22 <copumpkin> orbitz: it's a pretty neat trick :)
19:09:25 <ezyang> "too many options!"
19:09:41 <orbitz> copumpkin: Indoobidbly
19:09:45 <copumpkin> lol
19:09:55 <twink> Careful, you accidentally wrote an octal literal with hex digits.
19:10:16 <Dark_Shikari> er, typo, yes
19:10:18 <Dark_Shikari> 0xff
19:10:44 <Dark_Shikari> twink: http://freeworld.thc.org/root/phun/unmaintain.html
19:10:48 <Dark_Shikari> grep "smuggle octal literals"
19:12:45 <kniu> Saizan, the IO monad.
19:13:14 <kniu> I did a (forever $ doStuffWith someHandle).
19:13:43 <kniu> get text input, and if that input is valid, produce some output.
19:15:28 <ezyang> Dark_Shikari: It looks like the lookup tables may be /too/ fast, since most benchmarks improperly load them into the cpu cache when that may not be realistic.
19:16:04 <Dark_Shikari> ezyang: if you're not calling popcnt enough to make a LUT useful, its speed probably isn't very important
19:16:14 <ezyang> fair enough
19:16:21 <Dark_Shikari> and furthermore, code costs space too, so a width-4 LUT (16 entries) could hardly be too costly
19:16:33 <Dark_Shikari> the code would be more space than the table
19:18:15 <Saizan> kniu: weird, id it using a lot of memory too?
19:19:09 <noggle> man
19:19:18 <noggle> I love this language
19:19:24 <noggle> they have thought of everything
19:19:25 <kniu> Saizan, yeah
19:19:29 <noggle> takeWhile...
19:19:31 <noggle> awesome
19:21:43 <kniu> would strictness fix this?
19:22:10 <ezyang> hmm... no noticeable performance boost?
19:22:14 <Saizan> only if you've a lazyness problem :)
19:22:25 <dino-> And the everything they thought of is written in itself. Very low keyword footprint.
19:22:32 <Saizan> kniu: i'd use heap profiling to figure out what that memory is used for
19:22:40 <Dark_Shikari> ezyang: I'd test with START_TIMER/STOP_TIMER macros
19:22:59 <ddarius> @google "Functional Translation of a Calculus of Capabilities"
19:23:01 <lambdabot> http://www.chargueraud.org/arthur/research/2008/icfp/capabilities_icfp_08.pdf
19:23:01 <lambdabot> Title: Functional Translation of a Calculus of Capabilities
19:23:15 <Dark_Shikari> ezyang: http://pastebin.com/m41b483f4
19:23:19 <ezyang> Dark_Shikari: I'm checking timing with GHC's built-in profiling capabilities
19:23:19 <Dark_Shikari> #include "bench.h"
19:23:22 <Dark_Shikari> START_TIMER;
19:23:24 <Dark_Shikari> <your code goes here>
19:23:27 <Dark_Shikari> STOP_TIMER("test");
19:23:29 <Dark_Shikari> it's cycle-accurate
19:23:33 <ddarius> sheikra: That paper above has an indirect connection between monads and separation logic.
19:23:36 <Dark_Shikari> er, STOP_TIMER("your name goes here");
19:23:42 <Dark_Shikari> x86-only.
19:23:48 <ezyang> interesting
19:23:52 <Dark_Shikari> oh, and you have to tune it so that NOP_CYCLES is correct
19:23:53 <Dark_Shikari> i.e.
19:24:03 <Dark_Shikari> run START_TIMER; STOP_TIMER("");, with nothing in between
19:24:09 <sheikra> ddarius: Thanks for the link. I'll have a look
19:24:09 <Dark_Shikari> adjust nop cycles until that reports 0 cycles
19:24:17 <Dark_Shikari> every cpu has a different nop cycles, so you need to calibrate
19:24:23 <Dark_Shikari> 22 is for core i7 for example iirc.
19:25:12 <Dark_Shikari> it automatically tracks and averages results over time, plus it will automatically filter out context switches.
19:28:41 <sheikra> ddarius: Do you think separation logic really works or not?
19:30:06 <ddarius> I haven't really looked into Separation Logic, but Reynolds is always right.
19:30:48 <ManateeLazyCat> What's the difference between `TVar` and `TMVar`? Just use TVar okay?
19:31:00 <ezyang> Dark_Shikari: I suspect that the optimization is getting swamped by the fact that I'm not inlining aggresively enough
19:31:05 <ddarius> ManateeLazyCat: Roughly the difference between IORef and MVar.
19:31:21 <Dark_Shikari> ezyang: inlining doesn't really save much time unless you get constant propagation out of it
19:31:45 <ezyang> "constant propagation"?
19:31:51 <copumpkin> or fusion, in GHC's case
19:31:54 <Dark_Shikari> when at least one function argument is a constant
19:31:59 <Dark_Shikari> and thus the function's code can be simplified after inlining
19:32:11 <Dark_Shikari> extreme cases can result in inlining actually reducing the total code size
19:32:18 <ezyang> hm
19:32:23 <ManateeLazyCat> ddarius: STM is solution design for concurrent thread to replace MVar, so why need use `TMVar` synchronising variable?
19:32:30 <Dark_Shikari> constant propagation is the primary reason that inlining is performed
19:32:33 <ezyang> but w/o inlining, you have to take the cost of a jump
19:32:40 <Dark_Shikari> the cost of a predicted jump is zero
19:32:41 <sheikra> ddarius: haha. you sure?
19:32:41 <ManateeLazyCat> ddarius: STM ThreadLog will check it.
19:32:49 <Dark_Shikari> er, and it's not even predicted, it's just constant
19:32:53 <noggle> Is there recommended web reading for haskell noobs? I am doing the exercises in some slides and I purchased a book called Real World Haskell
19:32:55 <ddarius> sheikra: Yes.
19:32:56 <Dark_Shikari> the only real cost is stack operations
19:33:02 <Dark_Shikari> and modern x86 chips have a dedicated stack engine
19:33:07 <Dark_Shikari> yes, there _is_ a cost, but it's not high
19:33:13 <Dark_Shikari> and on x86_64 it's even tinier
19:33:20 <Dark_Shikari> equally tiny on x86_32 with fastcall
19:33:40 <noggle> RWH is pretty good. It uses some terminology that I am not familiar with but the explanations are good. Great in fact.
19:33:42 <ezyang> hm
19:33:48 <twink> You'd think if they were going to hardwire the stack like that they'd just get register windowing and be done with it (ia64?).
19:33:54 <ManateeLazyCat> ddarius: Or `TMVar` just make easier that convert from `MVar` to STM?
19:33:55 <Dark_Shikari> register windowing sorta sucks for other reasons
19:34:04 <ManateeLazyCat> ddarius: I think `TVar` is enough.
19:34:15 <ddarius> ManateeLazyCat: Sometimes MVar like semantics is what you want.
19:34:35 <sheikra> ddarius: I'm reading his papers, and still trying to figure out how this thing can be implemented in a uniform way.
19:34:54 <ManateeLazyCat> ddarius: No mutex lock is better solution for concurrent thread.
19:35:54 <ddarius> ManateeLazyCat: A MVar can be used as a one-way single element channel.  That's useful upon occassion.  Channels can be used for synchronization and there are TChans as well.  Sometimes you just want those semantics.
19:36:13 <ezyang> heh, and I'm seeing worse performance with inlining
19:36:16 <ezyang> 'ok
19:36:19 <ManateeLazyCat> ddarius: So `TMVar` just make easier that convert from `MVar` to STM? `TVar` still can handle concurrent thread works well, right?
19:36:45 <Dark_Shikari> ezyang: do note that start/stop timer aren't reliable for measuring function overhead when placed inside the function (obviously)
19:37:04 <ddarius> ManateeLazyCat: TVar is still fine for concurrent use, but there is no blocking semantics for it.  TMVar has blocking semantics, but it isn't just there to "make converting easier" anymore than TChan is there to "make converting easier" from Chan based code.
19:37:10 <twink> Dark_Shikari: Which other reasons did you have in mind?
19:37:32 <Dark_Shikari> twink: what happens when you hit the bottom of the register stack
19:37:41 <Dark_Shikari> inability to use all the registers at once
19:38:15 <ManateeLazyCat> ddarius: I just can't understand why STM need blocking? Because it design for remove *lock*. :)
19:40:39 <psykotic> (catching up)
19:40:41 <psykotic> > ddarius: sheikra: That paper above has an indirect connection between monads and separation logic.
19:40:41 <twink> Dark_Shikari: Not sure where the concern about all registers at once comes from.
19:40:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:41:14 <psykotic> well, you can encode regions with monads, and isn't separation logic more or less the same thing as region calculus?
19:41:39 <Dark_Shikari> twink: because if you can only use like 1/8 of the registers at a time, it's a waste
19:41:46 <sheikra> psykotic: I guess he meant "Functional Translation of a Calculus of Capabilities"?
19:41:47 <Dark_Shikari> if you're going to have 128 registers, might as well open them all for use
19:41:59 <psykotic> right, capabilities and regions are almost the same
19:42:09 <Dark_Shikari> I recall register windowing arches having things like 8 for args, 8 local, and 8 for the next function's args
19:42:24 <sheikra> psykotic: good to know
19:42:52 <ddarius> psykotic: Capabalities are more flexible than regions and I think they are more flexible in a way that corresponds more closely to separation logic.  I don't believe separation logic enforces any notion of nesting which region-based systems usually do (unless paired with capabilities as in the URAL system.)
19:43:15 <ManateeLazyCat> When time use TChan?
19:44:05 <ddarius> ManateeLazyCat: Locking and blocking are at different levels of abstraction and are different things.  Channel based concurrency doesn't explicitly use locks (though you can build locks on top of them), but usually has or can support a notion of blocking (usually a blocking read.)
19:44:46 <twink> Dark_Shikari: Okay, I figured out what you meant by that, though I'd probably not give that one much weight vs. objections to the exception-based spilling.
19:44:49 <ddarius> ManateeLazyCat: Any time you want some amount of message passing concurrency, you will probably want to use channels.  If you are using STM, you'd then use TChans.
19:45:10 <dmwit> So does anybody else see some kind of debug output from GHC every once in a while?
19:45:29 <dmwit> Like "constructor name?{gibberish goes here}" or so?
19:45:34 <Dark_Shikari> twink: yeah, exception based spilling is far worse imo
19:45:43 <copumpkin> I've never seen gibberish from it
19:46:01 <dmwit> I should add that I've only ever seen it from 6.12.1
19:46:12 <copumpkin> dmwit: maybe you're in an area with particularly many cosmic rays?
19:46:21 <dmwit> hah
19:46:30 <ManateeLazyCat> ddarius: I see. Thanks for your explain! :)
19:46:30 <dmwit> And a sudden upsurge in them ever since I upgraded GHC? ;-)
19:46:41 <Saizan> i've seen prints like that with older ghc's too
19:46:41 <copumpkin> yep!
19:46:53 <copumpkin> dmwit: what does the gibberish look like?
19:47:15 <dmwit> 5-6 characters, usually in the pattern "aa aaa", each a being alphanumeric.
19:47:17 <noggle> thanks for the help!
19:48:00 <copumpkin> weird
19:49:21 <psykotic> ddarius: re: regions/capabilities, you're right, capabilities don't have a 'stack' discipline for revocation, they can be revoked at any time
19:49:22 <dmwit> I probably should have written it down when I saw it.
19:49:43 <aavogt> dmwit: I've seen similar phenomena
19:50:02 <psykotic> ddarius: but that's also what makes them really hard to statically check
19:50:15 <psykotic> region inference is a nice sweet spot
19:50:42 <dmwit> Oh, good.
19:51:25 <psykotic> cyclone actually uses the full capability calculus, i think
19:51:41 <psykotic> so, when you explicitly free a region, you revoke the capability to use it
19:52:38 <ddarius> psykotic: This is the paper (thesis) I was referring to with the "URAL" comment: http://ttic.uchicago.edu/~fluet/research/thesis/index.html
19:52:53 <psykotic> ah, thanks
19:53:28 <twink> Cyclone's one I'd love to hear more about.
19:53:51 <psykotic> ddarius: fluet was one of the coauthors of the monadic regions paper
19:54:12 <ddarius> Indeed.
19:54:31 <psykotic> the encoding complexity is pretty ridiculous
19:54:34 <psykotic> the oleg trademark
19:54:35 <psykotic> heh
20:09:29 * ezyang has wandered into the land of --show-iface, and is not sure if he likes it here 
20:14:53 <ezyang> the manual mentions something about __S <string>, I don't see this but I do see "Strictness" annotations; are they equivalent?
20:15:44 --- mode: ChanServ set +o dobblego
20:15:48 --- kick: AlaYBtG was kicked by dobblego (AlaYBtG)
20:15:53 --- mode: dobblego set +b *!*Fvalerius@95.66.38.*
20:15:54 --- kick: AlaYBtG was kicked by dobblego (AlaYBtG)
20:16:10 --- mode: dobblego set -o dobblego
20:20:00 <Dashkal> Does anybody have any experience making a Handle from a numeric posix file descriptor?  I see either fdToHandle in System.Posix.IO or mkHandleFromFD in GHC.IO.Handle.FD.
20:20:58 <ddarius> Out of those choices, fdToHandle seems like the one you want.
20:21:58 <MaciejP> > reads "(123)" :: [(Int, String)]
20:21:59 <lambdabot>   [(123,"")]
20:22:03 <Dashkal> The only issue I'm seeing is I can't seem to tell what mode the Handle will think its in when I convert.  Especially if I simply create the Fd from a number
20:22:19 <MaciejP> How do I tell him to read only the digits?
20:23:47 <Dashkal> Ahh, a peek at the source reveals.  It asks the OS what mode the handle is in.  Perfect.
20:29:51 <nolrai_FG> Hey are priority queues implemented in anything? Like a packege or something.
20:30:16 <twink> Where'd those leftist heaps go?
20:30:34 <bos> we have a priority queue in the event library.
20:31:45 <ddarius> http://hackage.haskell.org/package/fingertree-psqueue
20:31:57 <ddarius> @hackage PSQueue
20:31:57 <lambdabot> http://hackage.haskell.org/package/PSQueue
20:32:30 <ddarius> There's also a very small but efficient implementation in Chris Okasaki's Fun of Programming chapter.
20:33:27 <nolrai_FG> Thanks ddarius!
20:35:20 <ddarius> http://www.palgrave.com/PDFs/0333992857.Pdf
20:35:44 <MaciejP> Can cabal/ghc-pkg tell me what packages depend on a certain package?
20:40:59 <ivanm> MaciejP: kinda
20:41:20 <ivanm> you can dump the information, but then you have to match it up yourself
20:41:50 <MaciejP> How do I dump it?
20:42:02 <ivanm> ghc-pkg dump ;-)
20:42:10 <MaciejP> Ah :-)
20:42:34 <ivanm> so you're interested in the depends fields
20:43:06 <ivanm> ooohh, in 6.12 there's "ghc-pkg dot"
20:43:17 <ivanm> so you might be able to get it from that...
20:43:31 * ivanm wonders if he can demo his graphviz library to do that kind of parsing...
20:43:53 <ivanm> looks feasible...
20:44:28 <ivanm> technically you don't even need to parse the output; it's just: digraph { "foo-a.b" --> "bar-c.d" ... }
20:44:37 <MaciejP> I'm using 6.10
20:44:46 <ivanm> yeah, don't think it has it then
20:45:27 <ivanm> MaciejP: alternatively, you could try to code something up using the Cabal library (from 1.6 it parses "ghc-pkg dump" behind the scenes)
20:46:52 <MaciejP> Searching the dump is pretty good for now
20:48:42 <MaciejP> Supposed I use package A depending on Parsec-2.0 and package B depending on Parsec-3.0, will it work in the same program?
20:51:59 <ivanm> probably not unfortunately :s
20:53:46 <bytecolor>  /part
20:54:00 * ivanm heads off
20:54:13 <ivanm> I think I've done enough procrastination^W work for today
20:54:40 <ezyang> eugh, I'm getting slaughtered by memory allocation / GC
20:54:46 <dolio> Well, if people's figures are correct, it's taking longer to darcs get ghc than it will to compile.
20:54:57 <ivanm> dolio: heh
20:55:04 <ivanm> fresh new repo?
20:55:10 <ivanm> duh, darcs get
20:55:16 <ivanm> yeah, I find that's the problem with darcs...
20:55:40 * ivanm points out that he hasn't used any other DVCS, and so isn't sure if this is typical of them in general or just of darcs
21:07:26 <ezyang> Are vectors more memory efficient than arrays?
21:07:41 <bos> No.
21:07:50 <ezyang> ok.
21:07:53 <ezyang> back to arrays I go
21:08:14 <bos> let me be more nuanced: That Depends.
21:08:46 <ezyang> ok...
21:10:39 <ezyang> I guess it wouldn't hurt to test the alternative
21:19:22 <ddarius> bos: Aren't they more or less identical in memory usage?
21:20:03 <dolio> If by arrays you mean boxed arrays, and by vectors you mean unboxed vectors, then maybe not.
21:20:15 <ddarius> dolio: Comparing like to like of course.
21:20:20 <bos> ddarius: they are in principle, except when vector operations get fused.
21:20:21 <dolio> They're just different names for the same thing, though.
21:20:30 <bos> less allocation.
21:21:11 <dolio> The types in uvector involved "Arr" for instance.
21:22:15 <bos> The code inside the vector library is pretty.
21:22:28 <bos> I love how many Haskell hackers pay close attention to the aesthetics of their work.
21:22:49 <bos> "Of course you'd do it this way! That's pellucid and gorgeous!"
21:23:43 <Twey> Hehehe
21:23:48 <dolio> How about that paper on "objects"?
21:24:01 <Twey> And spend long periods of time tweaking their layout for maximum symmetry
21:24:16 <Twey> dolio: What paper's that?
21:24:56 <dolio> http://ww2.cs.mu.oz.au/~sulzmann/manuscript/objects-unify-type-classes-gadts.ps
21:28:20 <dolio> I'm against them just because they decided to call them "objects".
21:31:03 <scutigera> dolio: so they can now write OO programs using something that looks like haskell.  why didn't they just use java ?
21:31:48 <dobblego> the reasons not to use Java are not purely syntactical
21:32:11 <copumpkin> are the main reasons to use vector as a stopgap until DPH is more stable?
21:37:02 <scutigera> dobblego: figure 7 is kind of interesting.  Although I don't find it very much of a problem that there is a sort and sortby. I guess it would be if I like to write out type diagrams in papers (not that I know how to).
21:37:11 <bos> preflex: seen dons
21:37:12 <preflex>  dons was last seen on #haskell 3 hours, 4 minutes and 44 seconds ago, saying: Ziphilt: in the form of template haskell (compile time metaprogramming)
21:39:15 <dobblego> looks very much like Scala
21:40:49 <ezyang> hm. How can I tell how much space an instance of some data type takes up in GHC?
21:41:49 <copumpkin> you can't in general, but http://ghcmutterings.wordpress.com/2009/02/12/53/
21:42:05 <ezyang> ehe, unsafeSizeOf
21:42:09 <ezyang> I'll try that out
21:44:21 <defun> Hi. Would it be accurate to assume that (X IFF Y) is the same as saying (X == Y)? (Where IFF is if and only if).
21:44:35 <dobblego> yes
21:44:40 <defun> thanks.
21:45:05 <ddarius> Where X and Y are Bools, yes.
21:45:58 <ezyang> is this... in bits?
21:45:59 <copumpkin> iff = (not .) . xor :o
21:46:17 <aavogt> @type (:o)
21:46:18 <ezyang> I sure hope they're not bytes...
21:46:18 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
21:46:18 <lambdabot>     In the second argument of `(:)', namely `o'
21:46:19 <lambdabot>     In the expression: (: o)
21:46:28 <aavogt> @type (o:)
21:46:29 <lambdabot> [Expr] -> [Expr]
21:46:31 <copumpkin> ezyang: probably bytes
21:46:49 <ezyang> eugh
21:46:58 <ezyang> the price we pay for laziness
21:47:16 <copumpkin> it isn't an accurate picture though, as a lot of the time the boxes will get removed
21:48:11 <ezyang> I need these to be two bytes large T_T
21:48:50 <Nereid_> :t (not .) . xorg
21:48:51 <lambdabot> Not in scope: `xorg'
21:48:51 <Nereid_> :t (not .) . xor
21:48:53 <lambdabot>     No instance for (Bits Bool)
21:48:53 <lambdabot>       arising from a use of `xor' at <interactive>:1:10-12
21:48:53 <lambdabot>     Possible fix: add an instance declaration for (Bits Bool)
21:48:53 <Nereid_> rofl. D:
21:48:59 <Nereid_> oh
21:49:07 <Nereid_> :/
21:49:11 <mattam> dolio: looks like a nice proposal still, these objects.
21:49:15 <copumpkin> it's a boolean xor :)
21:49:23 <aavogt> xor == /= ?
21:49:24 <copumpkin> @let bxor = (/=)
21:49:24 <lambdabot>  Defined.
21:49:29 <copumpkin> @unde
21:49:33 <ezyang> erm, 8
21:49:44 <copumpkin> @let bxor = (/=) :: Bool -> Bool -> Bool
21:49:44 <lambdabot>  Defined.
21:49:50 <Nereid_> :t (not .) . bxor
21:49:51 <lambdabot> Bool -> Bool -> Bool
21:49:53 <Nereid_> right.
21:50:19 <aavogt> ghc unboxorz types if you're lucky
21:50:30 <copumpkin> it unbox0rz your s0x0rz
21:50:50 <Nereid_> lol
21:51:06 <dolio> mattam: I guess. I'm not sure I want to unify type classes with datatypes.
21:51:09 <dobblego> @check \x y -> let bxor = (/=) in (x == y) == (((not .) . bxor) x y)
21:51:10 <lambdabot>   "OK, passed 500 tests."
21:51:15 <dolio> I think I'd rather type classes were unified with modules.
21:51:39 <Twey> I disapprove of unification.
21:52:11 <dolio> Although, I think open datatypes are also nice.
21:52:42 <mattam> Yeah, it's nice to see it's possible at least.
21:53:19 <dolio> I think the type class half of that proposal is essentially what Coq type classes are.
21:53:36 <dolio> They're sugar over dependent records, which you can fill in yourself if you wish.
21:53:49 <dolio> And you can even program the part of the compiler that fills in instances, I think.
21:54:49 <mattam> Yes, that's how I did it :)
21:55:14 <dolio> Oh, heh.
21:55:39 <mattam> But I've been thinking of sealing classes too, it could be useful sometimes.
21:56:05 <ddarius> It's not immediately clear that the proposal supports constructor classes, which would be a -big- problem.
21:56:14 <mattam> I certainly don't like their dot notation either, it feels backwards :)
21:56:50 <mattam> Hmm, why would that not be supported?
21:57:52 <dolio> Some of their listings looked kind of weird to me.
21:58:17 <dolio> Like 'class Set a where ... ; merge :: Set a -> Set a'.
21:58:41 <copumpkin> where does dph live these days?
21:58:42 <dolio> That doesn't make a lot of sense if 'Set a' is a dictionary of functions.
21:58:52 <copumpkin> googling for its docs gives me broken links and old versions
21:58:59 <ddarius> I guess Set is like a constructor class?
21:59:42 <ddarius> dolio: 'Set a' is vaguely overloaded.  E.g. merge's type is: Set a => Set a -> Set a
22:00:07 <copumpkin> that's an odd typ
22:00:08 <dolio> Yeah, I understand how the types work out.
22:00:31 <dolio> I think it's weird that a 'Set a' is both a set of as, and some kind of method dictionary.
22:00:40 <ddarius> I'm assuming: class Monad a where return :: a -> Monad a; (>>=) :: Monad a -> (a -> Monad b) -> Monad b
22:00:59 <ddarius> Though that seems dangerous...
22:01:11 <dolio> I don't think it can be that, can it?
22:01:27 <ddarius> I'm not sure what else it would be.  How would you write it in their system?
22:02:07 <dolio> I don't know. But they end up writing 'mergeList :: ListSet a -> Set a -> Set a' to implement merge for their [a] implementation of sets.
22:02:38 <ddarius> It's not clear to me, at all, how Monad would be cast in their system and how closely it would correspond to Haskell's current Monad class.
22:02:47 <dolio> Which would suggest to me that that signature for (>>=) doesn't require that either of the Monad bs has anything to do with the monad you're defining.
22:03:00 <ddarius> dolio: Indeed.  Hence "dangerous"
22:03:01 <dolio> Or the Monad a, either, really.
22:03:32 <mattam> From what I understand from the constructors of classes, they always carry their dictionnary somehow.
22:04:08 <mattam> So any ListSet a value contains a reference to its dictionary I guess.
22:05:31 <ddarius> I would have to agree with dobblego, that this just looks a lot like Scala.
22:05:34 <dolio> Anyhow, 'Monad a => a -> Monad a' doesn't look right, either.
22:05:49 <dolio> If you turn the => into ->.
22:05:58 <ddarius> dolio: Yeah, I agree that it is completely broken, but that's the closest I see.
22:06:28 <ddarius> I'm not sure what the normal Monad class definition would turn into in their system assuming it is even valid.
22:06:55 <dolio> Why wouldn't it be the same as it is now?
22:06:59 <mattam> Why not [ Monad m a where return :: a -> Monad m a ] ?
22:07:36 <mattam> [Monad m] is just a regular type constructor now.
22:08:15 <mattam> But then what would it mean for multi-parameter type classes I'm not sure...
22:08:44 <ddarius> They say their stuff works for multi-parameter type classes (though I'm not sure how strong the emphasis is on -type-).
22:10:38 <scutigera> how do I pass haskell strings to C functions taking char * ? Can't quite figure it out from RWH.
22:10:50 <ddarius> dolio: I don't think the syntax of their proposed mini-language allows it, but they certainly could simply do the same dictionary translation that is currently used for Monad; however, I'm not sure how the rest of the language features they propose would fit with it.
22:11:15 <ddarius> @hoogle CString0
22:11:15 <dolio> Oh, I didn't really look at their proposed core language.
22:11:15 <lambdabot> No results found
22:11:48 <scutigera> @hoogle CString0
22:11:48 <lambdabot> No results found
22:11:53 <scutigera> @hoogle CString
22:11:54 <lambdabot> Foreign.C.String type CString = Ptr CChar
22:11:54 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
22:11:54 <lambdabot> Foreign.C.String newCString :: String -> IO CString
22:12:00 <ddarius> scutigera: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Foreign-C-String.html
22:14:49 <scutigera> ddarius: according to RWH, I use CString for the C func, then maybe newCString, but how do I handle the fact that it is IO CString ?
22:15:18 <ddarius> mattam: I think your idea would work better than what I had proposed, but I think it would still have similar issues do to being able to explicitly pass dictionaries.
22:15:42 <ddarius> scutigera: The same way you handle any other IO action.
22:17:14 <tensorpudding> @src concatMap
22:17:15 <lambdabot> concatMap f = foldr ((++) . f) []
22:17:35 <scutigera> ddarius : doh! do s <- newCString "temp.bin"...
22:17:41 <ddarius> A beautiful definition.
22:18:11 <ddarius> A nice fusion of concat = foldr (++) [] and map f = foldr ((:) . f) []
22:18:18 <scutigera> ddarius: well, only took me 20 min and your help to figure it out.
22:20:08 * enthymene hopes dearly that the 'and' in the middle of that sentence wasn't the and operator
22:20:14 <enthymene> otherwise he is very confused
22:21:16 <dolio> ddarius: I mainly think the Set example is very weird. Their desugared example isn't how I'd implement sets even if I'd resolved to do my own dictionary passing.
22:21:16 <ddarius> scutigera: If you haven't already, I highly recommend reading the FFI Addendum.  It's quite readable.
22:21:21 <ddarius> @where ffi
22:21:21 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
22:21:40 <ski> enthymene : `and' is not an operator (in haskell)
22:21:49 <enthymene> er, a function
22:21:53 <Twey> `and` is
22:21:55 <Twey> ;)
22:21:57 <enthymene> you can take the and of alist
22:22:00 <enthymene> er, a list >.>
22:22:14 * ski bashes Twey with a large comonad
22:22:30 <enthymene> yeah, operator, function
22:22:40 <dolio> They've mixed together the specification of what a set is, and the type that implements the specification.
22:23:03 <ski> (`and' is a variable name, whose standard binding is a value of function type, yes)
22:23:30 <ddarius> dolio: Yeah, I'm imagining you'd have data Set s a = Set { merge :: s a -> s a, ... } or something like that.
22:23:39 <scutigera> ddarius: chapter 8 of ghc docs ?
22:23:55 <enthymene> well when you put it that way ski, it's not much use to speak of anything definitively being anything is it? :p
22:23:56 <ddarius> scutigera: The link I induced lambdabot to reveal above.
22:24:11 <ddarius> scutigera: It is the standard that defines the FFI spec.
22:24:18 <ddarius> :t and
22:24:19 <lambdabot> [Bool] -> Bool
22:24:32 <ski> enthymene : well,  +  is an operator, as is  `elem`
22:24:47 <enthymene> you could redefine (+) though, right?
22:25:13 <ddarius> dolio: The Set example seems a bit -too- OO, perhaps.
22:25:14 <enthymene> also note that I'm not used to making distinctions between functions (bound to symbols) and operators, since I started with scheme
22:25:23 <dolio> ddarius: Yes.
22:25:34 <ski> > let (+) = \x -> x ^ 2 in (5 +)  -- `+' is still an operator, here
22:25:35 <lambdabot>   25
22:25:50 <ski> enthymene : yes, which would not change it operator-status
22:25:58 * enthymene nods
22:25:59 <enthymene> hmm
22:26:13 <ski> > let (+) = 42 in (+)  -- and `+' is also an operator, here
22:26:14 <lambdabot>   42
22:26:25 <mjrosenb> @dj a->a
22:26:26 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver do
22:26:33 <mjrosenb> @djinn a->a
22:26:33 <lambdabot> f a = a
22:26:34 <scutigera> ddarius: sorry, missed that link. thank you.
22:26:39 <dolio> ddarius: That's part of my concern. People import enough bad OO design because we have something called "classes". Adding "objects" only encourages more confusion, and this extension actually allows you to write the weird OO solution.
22:27:33 <ddarius> Perhaps: class Monad m where -- as normal would work out fine...
22:28:21 <mjrosenb> @djinn monad m => a->b->c->d->(a->m (b->m (c->d)))
22:28:21 <lambdabot> Cannot parse command
22:28:38 * ski wonders whether `extract' in `class Set a' there would be impure
22:29:15 <ddarius> Hmm, though, now I'm not sure what the object declaration for such a Monad class would look like.
22:29:32 <ski> @djinn Monad m => a -> b -> c -> d -> (a -> m (b -> m (c -> d)))
22:29:32 <lambdabot> -- f cannot be realized.
22:29:45 <ddarius> Djinn can't handle Monad.
22:30:00 <ski> because of the polymorphic methods ?
22:30:15 <ski> or because of `Monad' being a constructor class ?
22:30:22 <ddarius> ski: Yes.  The dictionary translation requires rank-2 types for which doing what djinn does would be a lot harder/impossible.
22:30:29 <ddarius> The constructor classness.
22:30:49 <ski> *nod*
22:31:18 <ddarius> Actually, I guess you have a point, class Foo a where foo :: b -> a should also cause a problem, I suspect.
22:31:50 <ddarius> And conceivably, if djinn supported multi-parameter type classes, class Bar t a where bar :: a -> t a would be fine.
22:33:18 <ski> @djinn Bar t => a -> t a
22:33:19 <lambdabot> f = bar
22:33:30 <ski> .. er
22:33:31 <ski> @djinn Bar t a => a -> t a
22:33:31 <lambdabot> f = bar
22:33:41 * ski raises eyebrow
22:33:44 <ddarius> ...
22:34:14 <ski> @djinn (Bar t a,Bar t (t a)) => a -> t (t a)
22:34:15 <lambdabot> f a = bar (bar a)
22:35:51 <ddarius> Okay, class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; object ListMonad :: Monad m; object ListMonad where return = (:[]); (>>=) = flip concatMap
22:36:19 <ddarius> I think that would work out fine in their system and you'd just have the normal problems that arise when you can explicitly override class instances.
22:36:50 <ddarius> object ListMonad :: Monad []
22:40:01 <ski> does `ListMonad' there work as a type ?
22:40:21 <ddarius> ListMonad is a value.
22:40:58 <ski> ok
22:42:20 <ski> .. oh
22:42:56 <ski> (afaic, upon glancing at the first pages), this appears to "just" be record types, with somewhat strange syntax
22:43:10 <ski> .. probably i'm missing some features/bugs, though
22:43:24 <ddarius> ski: Basically.  It's just basically direct support for the dictionary passing translation.
22:44:13 <ski> i'm not sure why they require putting `object' in the type signature, not the defining equation, though
22:44:26 <ski> .. .. maybe that is for declaring some kind of openess
22:48:19 * ski waits for the paper's definition of "object-oriented"
22:56:57 <ddarius> @hoogle hReadLn
22:56:57 <lambdabot> No results found
22:57:02 <ddarius> @hoogle hRead
22:57:02 <lambdabot> System.IO hReady :: Handle -> IO Bool
22:57:02 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
22:57:02 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
22:57:23 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22743#a22743
22:57:27 <ddarius> @hoogle open
22:57:27 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
22:57:27 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
22:57:27 <lambdabot> Network.Browser OpenConnection :: BrowserEventType ty
22:57:36 <ddarius> @hoogle openFile
22:57:36 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
22:57:41 <dolio> Whoops, I messed that up a little.
22:59:06 <ddarius> @src IOMode
22:59:06 <lambdabot> data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
23:01:06 <ddarius> dolio: What are you getting at?
23:01:45 <dolio> That's part of why I think that way of structuring sets is weird.
23:02:00 <dolio> Inserting an item into a list set doesn't necessarily return a list set.
23:02:16 <tensorpudding> is there a way to produce static binaries using ghc?
23:04:30 <ski> dolio : yes, because of bundling the interface type with the representation type ..
23:06:18 <mjrosenb> what module would have a function that would get the size of a file?
23:06:19 <ski> basically `Set a' there is a record type, which can be constructed using many different functions
23:07:49 <ski> @hoogle fileSize
23:07:49 <lambdabot> System.IO hFileSize :: Handle -> IO Integer
23:07:49 <lambdabot> System.IO hSetFileSize :: Handle -> Integer -> IO ()
23:08:09 <ski> mjrosenb : ^ there, it appears
23:09:14 <mjrosenb> ski: interesting, i need to open the file to get its size
23:09:53 <ski> maybe there's something better somewhere
23:10:21 * ski has never needed to get a file size
23:13:26 <badsheepy> system.posix has a function which calls stat, probably not as portable though
23:13:45 <Berengal> @unpl (zip<*>).(.tails).map
23:13:45 <lambdabot> (\ e -> zip <*> \ k -> map e (tails k))
23:14:10 <Berengal> @unpl (ap zip).(.tails).map
23:14:10 <lambdabot> (\ d -> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) zip (\ o -> map d (tails o)))
23:14:46 <Berengal> @pl \f xs -> zip xs (map f (tails xs))
23:14:47 <lambdabot> ap zip . (. tails) . map
23:18:13 <ski> .. apropos type classes, "Interface-passing style" <http://fare.livejournal.com/155094.html> might be interesting
23:19:03 <Zao> Cabal seems to really want a Main-Is: field for me. Can I get it to build a main-less Executable?
23:19:17 <Zao> That is, providing a driver in a C file.
23:20:52 <Zao> Or do I have to fall back to building stuff manually with batch files :(
23:21:08 <Zao> I probably have to anyway, as I want to build a DLL.
23:28:36 <tommd> Could someone host the llvmbackend-full patch elsewhere?  There seems to be a problem with the current host.
23:28:50 <tommd> Probably didn't like the sudden bandwidth demand.
23:28:54 <copumpkin> I can stick it on my dropbox if you want
23:28:58 <copumpkin> or on my vps
23:29:08 <copumpkin> vps is probably better
23:29:13 <copumpkin> where is it?
23:29:32 <tommd> If you don't have it you can't get it (it seems) http://www.cse.unsw.edu.au/~davidt/downloads/ghc-llvmbackend-full.gz
23:29:49 <copumpkin> works fine for me
23:29:56 <copumpkin> I'll put it on my vps
23:29:58 <tommd> Really?  Humm... grumble.
23:30:32 <copumpkin> http://pumpkinpat.ch/ghc-llvmbackend-full.gz
23:30:52 * ski fails to see how the `sprintf' example is written in direct-style
23:31:25 <tommd> copumpkin - thanks.  wget seems to work where chrome did not... for now.
23:31:41 <Speedy2> www.search2.net
23:33:11 <copumpkin> @where ops
23:33:11 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
23:33:22 --- mode: ChanServ set +o Heffalump
23:34:28 <Heffalump> too slow..
23:34:36 --- mode: Heffalump set -o Heffalump
23:35:14 <copumpkin> well, he was Speedy
23:35:17 <copumpkin> can't blame you
23:47:20 <Axman6> blackdog!
23:47:34 <copumpkin> woof
23:58:46 <ski> having checked with Danvy's "Functional unparsing", it appears the `sprintf' in the present paper is basically just the alternative solution from the former paper .. and not really anymore in direct-style than that
