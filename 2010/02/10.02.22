00:00:32 <ddarius> ski: The Asai paper?
00:01:24 <ddarius> http://pllab.is.ocha.ac.jp/~asai/papers/tr08-2.pdf
00:02:05 <ski> Objects to Unify Type Classes and GADTs <http://ww2.cs.mu.oz.au/~sulzmann/manuscript/objects-unify-type-classes-gadts.ps> by Bruno C. d. S. Oliveira and Martin Sulzmann, 2008-05-01
00:02:17 <ski> ddarius : ^ that one ..
00:02:28 <ski> i don't think i've seen that Asai one
00:02:41 <ddarius> Oh, they have a printf in it.  I saw some Format stuff but I didn't look at the later examples at all really.
00:02:52 <mm_freak_> how do i freeze an MVector from the vector package?
00:03:05 <ski> i just don't see how they can claim it is in direct style ..
00:03:12 <mm_freak_> is there some runSTUArray equivalent?
00:03:52 <ski> basically, their `E' is the initial continuation
00:04:16 <ski> and `I',`C',`S' are continuation transformers (i.e. written in CPS)
00:05:55 <ski> (`E' corresponding to `eod' at page 5 in Functional Unparsing <http://www.brics.dk/RS/98/Abs/BRICS-RS-98-Abs/BRICS-RS-98-Abs.html#BRICS-RS-98-12> by Olivier Danvy)
00:05:57 <ddarius> Yeah, it looks like they just defunctionalized the continuations of sorts.
00:06:11 <copumpkin> mm_freak_: I don't think something like that exists yet
00:06:26 <mm_freak_> hmm
00:06:29 <mm_freak_> but that's bad!
00:06:44 <ski> not even defunctionalized imo -- just wrapped them
00:06:51 <copumpkin> I think the New stuff might be a way of doing that
00:07:00 <ski> (that `Format' is not a "sealed class")
00:07:07 <copumpkin> but it's not done yet, as far as I can see
00:07:44 <ddarius> ski: Yeah.
00:08:07 <Axman6> dons: you around?
00:08:42 <ski> e.g. basically `C' is defined like  c k = MkFormat { sprintf' = \s x -> sprintf' k (s ++ [x])}
00:18:06 <Axman6> man, the results from the LLVM backend are really impressive
00:21:40 <Zao> Blargh. hsc2hs fails if gcc is not in the path.
00:23:02 <nolrai_FG> @hoogle Double -> Int -> Double
00:23:02 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
00:23:02 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
00:23:02 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
00:24:41 <copumpkin> > scaleFloat 3 4
00:24:42 <lambdabot>   32.0
00:24:46 <copumpkin> :O
00:24:54 <copumpkin> > scaleFloat 3 4.5
00:24:55 <lambdabot>   36.0
00:25:04 <copumpkin> interesting
00:25:16 <copumpkin> > scaleFloat (-3) 4.5
00:25:16 <lambdabot>   0.5625
00:25:28 <copumpkin> generalized bitshifting!
00:26:17 <psykotic> that's a really poor name
00:27:18 <copumpkin> yeah
00:32:32 <psykotic> it's probably supported because it's just an increment/decrement of the exponent in the ieee-754 representation
00:32:42 <copumpkin> yeah
00:37:44 <nolrai_FG> @hoogle (Ord a) => [a] -> a
00:37:45 <lambdabot> Prelude maximum :: Ord a => [a] -> a
00:37:45 <lambdabot> Prelude minimum :: Ord a => [a] -> a
00:37:45 <lambdabot> Data.List maximum :: Ord a => [a] -> a
00:39:40 <Claviceps> NEED PEOPLE FOR A (WHITEHAT) SEO DEVELOPMENT TEAM!! WWW.BINGSEOFORUM.COM + WWW.BARELYLEGAL.COM
00:39:52 <Claviceps> #xbox720 on EFNET
00:39:56 <Polarina> Why do people use enumFromTo?
00:40:00 <Claviceps> #xbox720 on EFNET
00:43:54 <copumpkin> Polarina: when you can't use the sugar for it, I guess
00:44:12 <Polarina> copumpkin, sugar?
00:44:29 <copumpkin> > [1..5]
00:44:30 <lambdabot>   [1,2,3,4,5]
00:44:34 <copumpkin> > enumFromTo 1 5
00:44:34 <lambdabot>   [1,2,3,4,5]
00:44:51 <Polarina> Same.
00:45:28 <copumpkin> [x..y] is syntactic sugar for enumFromTo x y
00:45:41 <Polarina> Isn't that always usable?
00:45:48 <Polarina> @src enumFromTo
00:45:49 <lambdabot> Source not found.
00:45:59 <copumpkin> > zipWtih enumFromTo [1..4] [6..]
00:46:00 <lambdabot>   Not in scope: `zipWtih'
00:46:04 <copumpkin> > zipWith enumFromTo [1..4] [6..]
00:46:05 <lambdabot>   [[1,2,3,4,5,6],[2,3,4,5,6,7],[3,4,5,6,7,8],[4,5,6,7,8,9]]
00:46:23 <copumpkin> > zipWith (\x y -> [x..y]) [1..4] [6..] -- is uglier
00:46:24 <lambdabot>   [[1,2,3,4,5,6],[2,3,4,5,6,7],[3,4,5,6,7,8],[4,5,6,7,8,9]]
00:46:38 <copumpkin> maybe not :)
00:46:46 <copumpkin> but maybe people don't use the function anyway
00:46:56 <copumpkin> but it needs to be there or GHC wouldn't have anything to desugar to!
00:47:16 <dmwit> That argument is circular.
00:47:52 <Axman6> wouldn't it be nice if (..) were a function
00:48:12 <dmwit> > let (..) = enumFromTo in 3 .. 5
00:48:13 <lambdabot>   <no location info>: parse error on input `..'
00:48:21 <dmwit> shame
00:48:21 <Claviceps> WWW.WINDOWS.COM
00:48:22 <copumpkin> dmwit: surely not :P
00:48:26 <copumpkin> @where ops
00:48:27 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
00:48:27 <dmwit> > let (...) = enumFromTo in 3 ... 5
00:48:28 <lambdabot>   [3,4,5]
00:48:29 <Claviceps> dude I got an HP
00:48:30 <copumpkin> Claviceps: stop it
00:48:31 <Axman6> ops...
00:48:37 --- mode: ChanServ set +o mauke
00:48:37 --- kick: Claviceps was kicked by mauke (Claviceps)
00:48:37 --- mode: mauke set +b *!*@c-24-17-64-44.hsd1.wa.comcast.net
00:48:44 <Polarina> mauke, :)
00:48:53 <Axman6> ta mauke
00:49:04 <mauke> a swift kick in the pants!
00:49:23 <copumpkin> it would be funny if someone's nick were geule
00:49:40 <copumpkin> and you said "ta gueule"
00:50:15 * Axman6 doesn't get it
00:50:28 <copumpkin> it's a rude way to tell someone to shut up in french
00:50:37 <Axman6> heh
00:50:37 --- mode: mauke set -o mauke
00:51:30 <copumpkin> > 1.39822E316
00:51:30 <lambdabot>   Infinity
00:51:42 <copumpkin> > 1.39822E316 :: CReal
00:51:43 <lambdabot>   139822000000000000000000000000000000000000000000000000000000000000000000000...
00:51:46 <Axman6> heh
00:52:00 <copumpkin> heh
00:55:22 <Axman6> > product [1..100]
00:55:23 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
01:00:51 <Daerim> Axman6, that's pretty impressive
01:02:00 <Axman6> Daerim: the product thing?
01:04:24 <Daerim> Axman6, well yes. C would have sat in a corner crying
01:04:32 <Axman6> yup :P
01:04:38 <Axman6> you'd need to use gmp directly
01:07:41 <Polarina> What is this thing (<|)?
01:08:01 <ski> @hoogle <|
01:08:01 <lambdabot> Data.Sequence (<|) :: a -> Seq a -> Seq a
01:08:01 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
01:08:01 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
01:08:20 <Polarina> Oddities.
01:08:32 <ski> presumably `a <| as' is the sequence having `a' as first element, and continuing with the sequence `as'
01:08:33 <Polarina> Does anyone care to explain, please? :-)
01:09:10 <Daerim> Axman6, python is currently looking at me with those big snake eyes and telling me that the real result is 0.....
01:09:22 <ski> (.. or maybe you're using another operation with the same name ?)
01:10:01 <Daerim> Axman6, aww crud no. Nevermind. It did it just finde
01:10:03 <Daerim> *fine
01:10:40 <ski> (Daerim : .. i presume you started with `0' as initial intermediate product ? :)
01:10:43 <Axman6> heh
01:11:04 <Daerim> ski, yes....
01:11:29 <Axman6> Polarina: where did you find it?
01:12:43 <Polarina> Axman6, in the documentation for lhs2TeX.
01:13:49 <Polarina> Axman6, why do you ask?
01:14:24 <Axman6> well, it might not be from something like Seq. got a link?
01:15:35 <Polarina> Axman6, http://people.cs.uu.nl/andres/lhs2tex/Guide2-1.15.pdf
01:15:39 <Polarina> Axman6, bottom of page 20.
01:17:01 <Polarina> Axman6, while you're at it, perhaps you could tell me what this "forall a." at top of page 33 is. :)
01:17:01 <Axman6> hmm, not sure what it's doing there. but i don't think it's a haskell function at all
01:17:19 <Axman6> forall is something that's implied in things like...
01:17:35 <Axman6> map :: (a->b) -> [a] -> [b]
01:17:39 <Axman6> which can be written as
01:17:40 <Axman6> :t map
01:17:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:17:54 <Polarina> Does it make a difference?
01:18:04 <Axman6> it's banope
01:18:07 <Axman6> oops
01:18:08 <Axman6> nope
01:18:22 <Polarina> Weird stuff.
01:18:25 * copumpkin doesn't like the typography of the output there
01:18:57 <Axman6> yeah, haskell looks nicest when it's just written as code. i hate it when people turn the ->
01:19:02 <copumpkin> http://snapplr.com/pe4e I'd use roman for the word "fix" and add a medium space between . and (
01:19:04 <Axman6> s into arrows, and things like that
01:19:09 <copumpkin> oh, I don't mind that
01:19:27 <nolrai_FG> @hoogle Double -> String
01:19:27 <lambdabot> Prelude show :: Show a => a -> String
01:19:27 <lambdabot> Text.Show show :: Show a => a -> String
01:19:27 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
01:19:36 <Polarina> I just wish to know how to make haskell look pretty in my latex documents. :)
01:19:55 <Axman6> yeah that's ok, but when you replace things  that are standard functions in haskell with say a circle with a dot in it, it makes it more confusing imo
01:20:20 <nolrai_FG> I want to do like setPresision, i.e. show only the first 4 significant digits of a double. How do I do so?
01:20:27 <ski> Polarina : `<|' at page 20 is just a local operation defined in the `where'
01:20:47 <jlouis> With unicode, most of that actually is correct haskell
01:21:06 <mauke> > ""++ printf "%.4f" pi
01:21:07 <lambdabot>   "3.1416"
01:21:19 <Polarina> ski, ok.
01:21:20 <copumpkin> there's a non-printf function for it but I can't remember it
01:21:20 <Axman6> ski: i'd say it's defined in the %format part myself, but i guess as a function it is
01:21:34 <mauke> showFFloat
01:21:41 <copumpkin> that's the one
01:21:48 <copumpkin> it's pretty ugly though
01:21:50 <Axman6> :t showFFloat
01:21:51 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
01:22:08 <Axman6> > showFFloat (Just 4) pi ""
01:22:09 <lambdabot>   "3.1416"
01:22:20 <Axman6> > showFFloat (Just 4) (pi*100) ""
01:22:21 <lambdabot>   "314.1593"
01:22:29 <Axman6> > showFFloat Nothing (pi*100) ""
01:22:30 <lambdabot>   "314.1592653589793"
01:22:36 <Axman6> > showFFloat Nothing (pi*10000) ""
01:22:37 <lambdabot>   "31415.926535897932"
01:24:45 <ski> Axman6 : the `format' directive (presumably) tells the converter how to format that token, but `<|' *is* an ordinary haskell operation, defined locally :)
01:25:25 <Axman6> yeah
01:27:06 <pozic> Is there a function in gtk2hs to mirror an image in its horizontal center?
01:27:07 <lambdabot> pozic: You have 1 new message. '/msg lambdabot @messages' to read it.
01:27:51 <nolrai_FG> Axman6: I totaly aggre with you about -> versis nice arrows
01:28:00 <nolrai_FG> @hoogle printf
01:28:00 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
01:28:01 <lambdabot> module Text.Printf
01:28:01 <lambdabot> Text.Printf class PrintfArg a
01:30:23 <Daerim> I love monte carlo programs where I have to guess the seed that will not make it crash.....
01:31:24 <Dephyrial> do you mean monte carlo literally
01:33:58 * copumpkin used to live there!
01:34:36 <ski> ddarius : hm, do you know when that Asai paper was published ?
01:36:04 <nolrai_FG> @hoogle Double -> Int
01:36:04 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
01:36:04 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
01:36:04 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
01:36:51 <nolrai_FG> I want 0.2 -> 0 3.5 -> 3 that sort of thing.
01:36:57 <nolrai_FG> @ty floor
01:36:58 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:37:25 <ski> > floor `map` [0.2,3.5]
01:37:26 <lambdabot>   [0,3]
01:37:29 <nolrai_FG> > floor (2.3)
01:37:30 <lambdabot>   2
01:38:18 <ski> .. hm, the publications page at the same site seems to suggest 2008-09
01:38:27 <dmwit> pozic: pixbufFlipHorizontally?
01:38:38 --- mode: ChanServ set +o mauke
01:38:39 --- mode: mauke set -b *!*@c-24-17-64-44.hsd1.wa.comcast.net
01:39:03 <Axman6> mauke: what's that for?
01:39:37 * ski thinks papers ought to have publication dates on the first page ..
01:40:02 <Daerim> Dephyrial, yes? I think so?
01:40:38 --- mode: mauke set -o mauke
01:43:23 <nolrai_FG> > printf "%.4f" (2.2222222222222222)
01:43:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:43:24 <lambdabot>    `Text.Printf.PrintfType ...
01:43:33 <nolrai_FG> > printf "%.4f" (2.2222222222222222 :: Double)
01:43:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:43:34 <lambdabot>    `GHC.Show.Show a'
01:43:34 <lambdabot>      a...
01:43:52 <nolrai_FG> > "s" ++ printf "%.4f" (2.2222222222222222 :: Double)
01:43:54 <lambdabot>   "s2.2222"
01:44:15 <ski> > printf "%.4f" 2.2222222222222222 :: String
01:44:16 <lambdabot>   "2.2222"
01:44:43 <ski> > printf "%.40f" 2.2222222222222222 :: String
01:44:44 <lambdabot>   "2.2222222222222223000000000000000000000000"
02:06:31 <pozic> dmwit: if there is a way to convert a Render () into a Pixbuf, that would work.
02:07:15 <Dephyrial> Daerim: i thought you were referring to the monte carlo way of running that program
02:10:43 <Daerim> Dephyrial, you mean guess a seed and bet it works? :p Yeah I was, though it is a monte carlo program
02:11:57 <pozic> dmwit: which it seems there is not.
02:12:46 <ski> @type (>>>)
02:12:47 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
02:13:04 <dmwit> pozic: You said you wanted to muck about with an image.
02:13:10 <dmwit> pozic: For Cairo, it's even easier.
02:13:33 <dmwit> pozic: Let me look up the exact way, but Cairo allows arbitrary affine transformations.
02:15:08 <dmwit> pozic: transform (Matrix -1 0 0 1 0 0) -- should do the trick
02:15:12 <ski> @type (Control.Arrow.>>>)
02:15:12 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
02:15:18 * ski scratches head
02:16:07 <ski> .. oh
02:16:11 <dmwit> ski: Arrow is a subclass of Category.
02:16:25 <benmachine> :t arr (.)
02:16:25 <lambdabot> forall a b (f :: * -> *) (a1 :: * -> * -> *). (Functor f, Arrow a1) => a1 (a -> b) (f a -> f b)
02:16:33 <benmachine> oh ff
02:16:49 <ski> dmwit : yes, apparently i didn't realize that
02:17:12 <dmwit> pozic: Even easier, (scale -1 1) should do the same thing.
02:17:19 * hackagebot upload: base-unicode-symbols 0.1.2 - Unicode alternatives for common functions and operators (RoelVanDijk)
02:23:40 <zygoloid> :t arr (Prelude..)
02:23:41 <lambdabot> forall b c a (a1 :: * -> * -> *). (Arrow a1) => a1 (b -> c) ((a -> b) -> a -> c)
02:24:35 <dmwit> scale (-1) 1, I guess
02:24:37 <dmwit> idiot
02:24:58 <benmachine> scale -1 1 should parse correctly, shouldn't it?
02:25:04 <zygoloid> no
02:25:07 <dmwit> newp
02:25:09 <zygoloid> that's (scale) - (1 1)
02:25:12 <benmachine> oh
02:25:16 <benmachine> agh
02:25:23 <dmwit> gotta love the unary operator (-)
02:25:27 <benmachine> love it.
02:29:10 <pozic> dmwit: I already tried that half an hour ago.
02:29:27 <pozic> dmwit: I already solved it in another way. Thanks, anyway.
02:30:06 <zygoloid> clearly the handling of (-) is correct. and clearly 123.456 should be parsed as 123 . 456 and we should have a Num instance for functions to make that work...
02:30:26 <benmachine> clearly!
02:30:59 <pozic> If you care that much just implement -Overloaded- ;)
02:33:20 <zygoloid> if "scale -1 1" worked, would people expect "scale -x y" to work?
02:34:12 <benmachine> different people would expect different things :P
02:34:31 <benmachine> I'm quite keen on the idea of making - part of numeric literal syntax
02:34:36 <benmachine> so that -1 is different from -x
02:34:48 <benmachine> but that has its own problems
02:34:57 <pozic> Yes, let's add even more rules.
02:35:19 <zygoloid> yeah, i think that's sound. it's always seemed stupid to me that (for instance) in C you can't write -2147483648 without compile-time overflow issues
02:35:21 <pozic> If we have a full moon (+) should really be (-).
02:35:37 <Axman6> benmachine: so let x = 4 in foo -x should be different to foo -4?
02:36:01 <benmachine> Axman6: ref. comment about having its own problems :P
02:36:06 <benmachine> I'm not sure
02:36:06 <Axman6> :P
02:36:10 <benmachine> but I don't know what else to do
02:36:11 <zygoloid> Axman6: yes. and let x = 4 in foo 2x should be different fom foo 24
02:36:16 <benmachine> hah
02:36:26 * hackagebot upload: gt-tools 0.1.2 - Console and GUI interface for Google Translate service (MikhailPobolovets)
02:36:27 * benmachine hugs zygoloid 
02:36:56 <dmwit> Axman6: Perhaps foo - x should be different from foo -x.
02:37:04 <benmachine> that's another idea
02:37:07 <Axman6> agreed
02:37:24 <benmachine> like Just.f is different from Just . f
02:37:33 <benmachine> :t Just . succ
02:37:34 <lambdabot> forall a. (Enum a) => a -> Maybe a
02:37:36 <benmachine> :t Just.succ
02:37:37 <lambdabot> Couldn't find qualified module.
02:37:41 <benmachine> whee
02:37:43 <Axman6> >_<
02:37:47 <dmwit> Oh, that's gotten me before.
02:37:50 <dmwit> But in this one:
02:37:56 <dmwit> > [False..True]
02:37:57 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
02:38:00 <benmachine> oh yeah
02:38:11 <Axman6> eeehhhhh???
02:38:15 <benmachine> I've started doing [x .. y] purely because of that
02:38:21 <dmwit> Me too.
02:38:30 <Axman6> > [False ..True]
02:38:31 <lambdabot>   [False,True]
02:38:32 <dmwit> Axman6: It's looking for the operator (.) in the module False.
02:38:36 <Axman6> > [False.. True]
02:38:37 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
02:38:41 <Axman6> argh -_-
02:39:02 <benmachine> " .. " is kind of a long way of typing "," though :P
02:39:21 <dmwit> Obviously it was a different enumeration type.
02:39:28 <Axman6> heh
02:39:41 <dmwit> But I don't think lambdabot has Data.SGF imported. =)
02:39:49 <benmachine> mm, okay
02:40:01 <idnar> [True .. False] !
02:40:27 <Axman6> > [True .. False]
02:40:28 <lambdabot>   []
02:41:01 <Axman6> hmm, time for a 'what's the longest way you can write []' competition
02:41:13 <benmachine> > id id id id id id id id id id id id id id id []
02:41:14 <lambdabot>   []
02:41:32 <Axman6> pfft
02:41:51 <Axman6> > [                                                                                                                                                                    ]
02:41:52 <lambdabot>   []
02:41:57 <benmachine> haha
02:42:06 <dmwit> > [[1..] | False]
02:42:07 <lambdabot>   []
02:42:07 <Axman6> > [                                                                                                                                                                                                                                                      ]
02:42:08 <lambdabot>   []
02:42:14 <trzkril> @type Infinity
02:42:16 <lambdabot> Not in scope: data constructor `Infinity'
02:42:17 <Axman6> rageirssi
02:42:26 * benmachine remembers sessions in ghci randomly permuting HOFs to see if he could get an id out
02:42:42 <benmachine> > fmap fix pure <$> fmap fix return $ []
02:42:43 <lambdabot>   []
02:42:45 <Axman6> benmachine: doing what?
02:42:48 <dmwit> :t fmap fix return
02:42:49 <lambdabot> forall a. a -> a
02:42:56 <dmwit> benmachine: Did you get that one?
02:42:57 <Axman6> :o
02:43:04 <benmachine> dmwit: I think I stole that one
02:43:09 <dmwit> =)
02:43:14 <Axman6> :t fix
02:43:15 <lambdabot> forall a. (a -> a) -> a
02:43:54 <Axman6> > iterare (fmap fix return) 1
02:43:55 <lambdabot>   Not in scope: `iterare'
02:43:58 <int-e> > init . maybeToList . return $ undefined
02:43:59 <Axman6> > iterate (fmap fix return) 1
02:43:59 <lambdabot>   []
02:44:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:44:35 <pozic> Is the newest Cabal compatible with the old Cabal?
02:44:40 <dmwit> :t join liftM (fmap fix return)
02:44:42 <lambdabot> forall a1. a1 -> a1
02:45:18 <pozic> Or, is there anything that works worse with the newest Cabal than with an older Cabal?
02:45:38 <benmachine> :t appEndo . mconcat . replicate 3 . Endo . join liftM $ fmap fix return
02:45:39 <lambdabot> forall a. a -> a
02:45:51 <benmachine> (contrived I admit)
02:46:29 <dmwit> =)
02:47:12 <benmachine> :t (:) <*> pure
02:47:13 <lambdabot> forall a. a -> [a]
02:48:11 <benmachine> :t (foldr (.) <*> ((:) <*> pure)) . join liftM $ fmap fix return
02:48:12 <lambdabot> forall a. a -> a
03:07:20 <McManiaC>     Could not find module `Distribution.Simple':
03:07:30 <McManiaC> can somebody tell me where this went? :O
03:10:39 <int-e> it's part of the Cabal package
03:10:41 <McManiaC> what package is Distribution.Simple part of?
03:10:50 <McManiaC> thx
03:13:02 * voker57_ for a second thought that telepaths finally joined channel
03:14:10 <McManiaC> int-e: why does "cabal install cabal-install" wants to install old versions of unix/array and fails? :O
03:17:15 <Axman6> McManiaC: try 'cabal install "cabal-install >= 0.8'
03:17:17 <Axman6> "*
03:17:44 <McManiaC> Axman6: okay thx
03:18:12 <McManiaC> <command line>: cannot satisfy -package-id Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a:
03:18:15 <McManiaC>     Cabal-1.8.0.2-a7cb9536dae40bb8d1ebb7fda099f46a is unusable due to missing or recursive dependencies:
03:18:18 <McManiaC>       array-0.3.0.0-ed0c6ffecd933bdec33f902cfd4153ec containers-0.3.0.0-4a33235de7e0cf50661efaa6fa22fd1d
03:21:14 <McManiaC>     Could not find module `System.Directory':
03:21:15 <McManiaC> wtf
03:22:41 <Phyx-> I wonder why http://phyx.pastebin.com/d4d0ec00c is needed when calling the GHC api, without it it panics but it seems very odd
03:22:59 <McManiaC> time to do another reinstall :S
03:23:00 <McManiaC> damn ghc
04:05:33 <ski> @src (->) leftApp
04:05:33 <lambdabot> Source not found. Are you on drugs?
04:06:26 <Phyx-> good question
04:06:46 <ski> well, tea i suppose
04:06:56 <Phyx-> :)
04:07:13 * ski wonders what the difference is between `left' and `leftApp'
04:07:18 <ski> @type left
04:07:19 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
04:07:20 <ski> @type leftApp
04:07:21 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowApply a) => a b c -> a (Either b d) (Either c d)
04:07:33 <Phyx-> @src left
04:07:34 <lambdabot> Source not found. That's something I cannot allow to happen.
04:07:51 <Phyx-> ski: seems to only be in the constraint
04:08:35 <ski> .. hm, oh, the haddocks suggest to me it's a default implementation of `left'
04:11:18 <mreh> could somebody explain the Yampa recurrant switches?
04:11:19 <mreh> rSwitch, drSwitch :: SF a b -> SF (a, Event (SF a b)) b
04:12:25 <ski> i suppose `loop' and `first' form a retract situation
04:13:52 <ski> mreh : not sure, but it looks like they might have something to do with dynamically changing the behaviour of the stream processor
04:14:10 * ski tries to recall what `Event' was
04:14:14 <mreh> ski: yeah, on a high-level I think you're right, I just can't see how they work
04:14:33 <mreh> ski: Event is the same as Maybe
04:14:41 <ski> oh, ok
04:14:49 <mreh> data Event a = Event a | NoEvent
04:14:59 <ski> then i suppose the argument is the initial underlying stream processor
04:15:18 <mreh> it looks like it is define recursively
04:15:39 <ski> and the input of the returned stream processor allows changing the underlying one (henceforth only the next step, or for the current too ?)
04:15:52 <ski> i'm not sure why there's two variants, though
04:16:05 <mreh> one is "delayed" apparently
04:16:20 <ski> ah, that could be it ..
04:17:03 <ski> (maybe that one takes effect on the next step, and the other takes effect on the current step)
04:17:29 <dmwit> What's the difference between "let x = y" and "x <- return y" again? (assuming we're in a do block, of course)
04:17:35 <mreh> ski: delayed happens "instantaneously" after the event
04:18:01 <Heffalump> dmwit: the former is recursive, the latter isn't
04:18:18 <Heffalump> the latter will let you pattern match on a GADT, the former won't
04:18:20 <ski> dmwit : if `y' is an expression, possibly containing (varaibles referenced in the pattern) `x', then the former is recursive, while the latter isn't
04:18:39 <ski> also, the former should allow `x' to be polymorphic, while the latter wouldn't
04:18:40 <kalven> I have a tree structure in haskell that is currently all in one 18000 char line: 'Node "foo" [Node "blah etc..'. Is there some easy way of pretty-printing it?
04:18:43 <kalven> perhaps using haskell-mode
04:18:49 <dmwit> marvelous
04:18:52 <dmwit> Thanks, Heffalump and ski.
04:19:01 <mreh> kalven: there must be a library that sets out trees nicely
04:19:09 <dmwit> :t drawTree
04:19:10 <lambdabot> Tree String -> String
04:19:11 <mreh> kalven: looked on hackage?
04:19:12 <Heffalump> it would be nice if let! x = y was closer to the latter
04:19:24 <ski> in what aspect ?
04:19:35 <Heffalump> GADT matching, principally
04:19:52 * Heffalump had to uglify a lot of darcs code to get round that
04:20:05 <mreh> klaven: if it's anything more than 5 levels deep it's going to go off the edge of the page
04:20:08 <kalven> mreh: don't know what to look for.. but I see now that I was perhaps unclear. I don't want to pretty-print it, I want to reformat it :)
04:20:18 <ski> Heffalump : for a GADT with only one constructor ?
04:20:23 <kalven> so that it's still valid haskell
04:20:51 <dmwit> kalven: Well, that's a little harder... but not much.
04:21:07 <dmwit> kalven: You can probably just rip the code right out of drawTree; it should be easy to modify it to do what you want.
04:21:10 <psykotic> kalven: you could replace the [] by () and use emacs's sexpr pretty printer
04:21:36 <mreh> kalven: write a Parsec parser!
04:21:44 <mreh> it's just like writing Haskell
04:21:57 <dmwit> Argh, no parsing needed. He's got the value as Haskell code!
04:22:15 <dmwit> Just write a Haskell function that outputs the string you want to include in your file...
04:23:13 <ski> psykotic : which one is that ?
04:23:50 <xarch> hi
04:25:00 * hackagebot upload: bibtex 0.0.3 - Parse, format and processing BibTeX files (HenningThielemann)
04:25:12 <kalven> hrm
04:25:22 <ski> lo
04:25:29 <Heffalump> ski: yes
04:26:31 <ski> (/me would guess at `data Equal :: * -> * -> * where Refl :: Equal a a', then ..)
04:26:36 <Heffalump> no :-)
04:27:03 <Heffalump> roughly, data Sealed p where Sealed :: p x -> Sealed p
04:27:44 <ski> oh, the existential quantification
04:27:59 * Daerim is working with fortran code where -all- information is passed by global variables. HORROR!
04:28:32 * ski remembers BASIC
04:29:04 <kamatsu> i am working on a more "Enterprise" boolean implementation in Java.
04:30:06 <mreh> 10 I HATE BASIC
04:30:09 <mreh> 20 GOTO 10
04:30:30 <ski> ?SYNTAX ERROR IN LINE 10
04:30:30 <lambdabot> Unknown command, try @list
04:30:51 <mreh> i can't remember the op to print to screen
04:31:11 <kamatsu> mreh: PRINT
04:31:15 <kamatsu> deshou?
04:32:12 <psykotic> ski/kalven: C-u M-x indent-pp-sexp with the point on the opening of the sexp
04:33:06 <taruti> Can anyone try cabal installing haskell-src-exts-1.6.1 with GHC 6.12.1, it seems to fail for me (and is required for the derive -package) ?
04:33:45 <mreh> what is the class for doing Boolean operations?
04:33:48 <ski> (psykotic : must be a recentish addition ..)
04:33:53 <mreh> bitwise stuff
04:34:15 <ski> @type (.&.)
04:34:16 <lambdabot>     Ambiguous occurrence `.&.'
04:34:16 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
04:34:16 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
04:34:20 <ski> @type (.|.)
04:34:21 <lambdabot> forall a. (Bits a) => a -> a -> a
04:34:22 <kalven> psykotic: thanks
04:34:31 <psykotic> ski: no, it's just a simple wrapper around pp-buffer
04:34:44 <mreh> @info Bits
04:34:45 <lambdabot> Bits
04:34:59 <psykotic> ski: it just narrows to the region around the sexp and calls pp-buffer
04:35:01 <mreh> @list
04:35:01 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:35:13 <ski> (well, no `pp-buffer' either in my (a bit old) emacs)
04:35:27 <psykotic> i thought that was oldish
04:35:30 <ski> @index Bits
04:35:30 <lambdabot> Data.Bits, Foreign
04:35:40 <psykotic> what about pp?
04:35:49 <ski> psykotic : i suppose it could be in an extra package ..
04:35:49 <psykotic> not as an interactive command but as a function
04:36:02 <psykotic> i think pp.el is used in the debugger and other places
04:36:05 <psykotic> so it's been around for a while
04:36:34 <Axman6> > (2^1234) .|. 1
04:36:35 <lambdabot>   Ambiguous type variable `t' in the constraint:
04:36:35 <lambdabot>    `Data.Bits.Bits t'
04:36:35 <lambdabot>      a...
04:36:40 <Axman6> > (2^1234) .|. 1 :: Integer
04:36:41 <lambdabot>   295811224608098629060044695716103590786339687135372992239556207050657350796...
04:36:53 <Axman6> > (2^8) .|. 1 :: Integer
04:36:54 <lambdabot>   257
04:37:14 <ski> (psykotic : .. exists)
04:37:26 <mreh> is it lazy?
04:37:39 <ski> what ?
04:37:51 <mreh> > 0 .&. (2^100000000000000000)
04:37:51 <lambdabot>   Ambiguous type variable `t' in the constraint:
04:37:52 <lambdabot>    `Data.Bits.Bits t'
04:37:52 <lambdabot>      a...
04:37:55 <mreh> > 0 .&. (2^100000000000000000) :: Integer
04:38:01 <lambdabot>   mueval: ExitFailure 1
04:38:04 <mreh> no
04:38:10 <psykotic> kalven: did it do the trick?
04:38:14 <mjrosenb> mreh: i cannot imagine how it could be lazy
04:38:18 <mreh> is it lazy... lol
04:38:24 <mreh> mjrosenb, yeah :)
04:38:37 <mjrosenb> mreh: unless it attempts to evaluate each bit individually
04:39:03 <mjrosenb> mreh: so if you made a new type of integer based on lists of bits
04:39:10 <mjrosenb> mreh: then you may be able to do it
04:40:36 <kalven> psykotic: no ;) I was simplifying a bit, my structure has plenty of parenthesis, brackets and commas so I'd need some way to go back to haskell after pp'ing it. I'll live with the 18k line for now.
04:40:54 <mjrosenb> i'm going to guess that there is no way of forcing a type synonym to have a different instance from the thing that it is a synonym of
04:40:58 <mjrosenb> for example
04:41:10 <ski> kalven : you might try inserting newlines just before every `;'
04:41:34 <ski> (well, not including ones that are quoted)
04:41:57 <psykotic> actually, this is kind of an awesome task for awk! :)
04:42:04 <ski> mjrosenb : correct
04:42:18 <mjrosenb> type Foo = (); f :: (Bar b) => b -> Int; f (()::()) == 1; f (() :: Foo) == 2
04:42:24 <ski> they are the same type, so the system treats them in the same way
04:42:55 <mjrosenb> ugh.
04:43:02 <mjrosenb> this is going to be
04:43:05 <ski> a common trick/work-around to wanting this is to do `newtype Foo = MkFoo ()' and define your other instance of `Bar' on this
04:43:09 <mjrosenb> well not a whol lot of fun
04:43:20 <mjrosenb> ski: yeah, but that will make things much messier
04:43:44 <ski> an alternative could be to pass around a "method" dictionary explicitly
04:43:57 <mjrosenb> once again really messy
04:44:15 <Axman6> implicitly?
04:44:15 <mjrosenb> i would need to change about 1,000 lines of code to handle a single case
04:44:16 <ski> (which is what one'd do in the ML's)
04:44:41 <mjrosenb> ski: ''a is totally an acceptable replacement for (Eq a)
04:45:04 <ski> for `Eq', yes
04:45:38 <ski> (but you can't custom-define equality in the MLs, iirC)
04:45:38 <mjrosenb> ski: except for the fact that you cannot declare new instances of it
04:46:41 <smiler> Is ++ a constant time operation in haskell or is it linear?
04:46:50 <Alpounet> @src (++)
04:46:50 <lambdabot> []     ++ ys = ys
04:46:50 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:46:50 <lambdabot> -- OR
04:46:50 <lambdabot> xs ++ ys = foldr (:) ys xs
04:46:56 <ski> it is (necessarily) linear in the first argument
04:46:57 <Axman6> oh no, found a typo in David T's thesis :(
04:47:17 <mjrosenb> smiler: it hides its linearity pretty well though.
04:47:18 <Heffalump> uhoh, world about to end
04:47:36 * ski looks out the window
04:47:39 <mjrosenb> Heffalump: it is ok, astroboy will save us.
04:47:52 <smiler> ski: why?
04:48:03 <ski> (Heffalump : you may well be right, there's craploads of snow there, and more coming)
04:48:14 * Heffalump only has a bit of snow outside
04:48:17 <smiler> Why just don't store a pointer to the last element in all lists
04:48:24 <smiler> Seems like a sane optimization to me
04:48:31 <Axman6> smiler: because lists can be infinite
04:48:32 <mjrosenb> smiler: because they have not been computed yet.
04:48:37 <smiler> Ah true
04:48:39 <Axman6> > [1..] ++ [0]
04:48:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:48:54 <ski> smiler : because it needs to replace the `[]' in the end of the first list with the second list; so it needs to traverse the first list to get to the end of it
04:49:06 <mjrosenb> let x = x ++ [1]
04:49:28 <ski> smiler : also, if you actually mutate lists, then you lose ref. transp.
04:49:48 <Axman6> and losing referential transparency is a big no no
04:49:54 * mjrosenb ran into many fun issues with lists being empty
04:50:03 <Axman6> don't do it! <points finger>
04:50:13 <ski> ("replace ... with ..." above means "create a copy, with ... exchanged into ...", in imperative parlance)
04:50:34 * mjrosenb susyects that 
04:50:52 * mjrosenb suspects that GADT's will solve my problem
04:51:03 <ski> .. your problem being ?
04:51:15 * mjrosenb also suspects that GADT's will be a royal pain in the ass it use correctly
04:51:48 <mjrosenb> ski: so i have a toy language, and a library written in haskell.
04:52:08 <mjrosenb> ski: i made a class to coerce values back and forth
04:52:31 <mjrosenb> ski: and to derive the types of the functions within the toy language
04:53:07 <ski> do you want to have both an untyped and a typed AST ?
04:53:20 <mjrosenb> ski: so typeof (filter :: (Expr -> Bool) -> Set Expr -> Set Expr)
04:53:26 <ski> or did you mean translating between haskell values and ASTs ?
04:53:43 <mjrosenb> ski: does the right thing and derives (a -> Bool) -> Set a -> Set a
04:53:57 <mjrosenb> ski: by just saying that Expr maps to \alpha
04:54:09 <mjrosenb> ski: now i want to implement Map
04:54:22 <mjrosenb> and i need Expr to be both \alpha and \beta
04:54:23 <ski> is `typeof' a haskell operation, there ?
04:54:29 <mjrosenb> yes
04:55:06 <ski> and that `(filter :: ...)' is not the actual haskell expression given to it ?
04:55:09 * hackagebot upload: concurrent-extra 0.2 - Extra concurrency primitives (RoelVanDijk)
04:55:29 <ski> but yes, it sounds like you want to try GADTs
04:56:26 <mjrosenb> (filter :: ... )is the actual expression given to it.
04:56:46 <ski> what is the type of `typeof' ?
04:57:38 <mjrosenb> Conv a => a -> Type
04:57:47 * ski is not sure what exactly this `typeof' would be good for .. i.e. how it is supposed to be used
04:59:34 <mjrosenb> ski: it is used to derive the type of library functions within the toy language
05:00:44 <mjrosenb> ski: so i do not have to explicitly state everything within the language
05:01:04 <ski> primitive library functions, i suppose
05:01:33 <mjrosenb> yeah, it works for most of what i care about
05:01:43 <mjrosenb> i *do* care about map
05:02:09 <mjrosenb> and so far it is the first function i have tried to add that the type deriving has not worked for
05:03:54 <ski> (hm, you are using `OverlappingInstances' for this, yes ?)
05:04:44 <ski> (er, no, ignore that question)
05:05:31 <mjrosenb> just FlexibleInstance
05:05:40 <mjrosenb> but that because i made a very silly decision early on
05:06:17 <kalven> how would I do something like: fmap read::Int (Just "1")
05:06:43 <Axman6> fmap read (Just 1) :: Maybe Int
05:06:47 <Axman6> ofr
05:06:48 <Axman6> or
05:07:07 <Axman6> fmap (read :: String -> Int) (Just "1")
05:07:17 <kalven> ah, thanks
05:07:23 <Axman6> there should have been quotes around the first 1
05:09:49 <Yoshibloke> quick question. What is the syntax for putting two contraints on a type definition like- :: (Eq v)  (Ord k) => (k,a) -> a -> Bool
05:10:26 <Axman6> (Eq a, Ord a) => ...
05:10:33 <Yoshibloke> thanks
05:19:41 <ski> > fmap (reads :: ReadS Int) (Just "1")
05:19:42 <lambdabot>   Just [(1,"")]
05:22:21 <Axman6> > Just "1" >>= listToMaybe . fmap fst
05:22:21 <Alpounet> @type reads
05:22:22 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:22:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:22:22 <lambdabot>         against inferred type...
05:22:33 <Axman6> > Just "1" >>= listToMaybe . fmap fst . reads
05:22:34 <lambdabot>   Nothing
05:22:39 <ski> @type reads :: Read a => ReadS a
05:22:40 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:23:36 <mjrosenb> gah
05:23:48 <mjrosenb> i cannot make a variable called -->
05:23:49 <mjrosenb> :(
05:24:03 <ski> @type StateT reads
05:24:04 <Axman6> you can make a function called that though
05:24:04 <lambdabot> forall a. (Read a) => StateT String [] a
05:24:16 <ski> > let (-->) = 42 in (-->)
05:24:16 <lambdabot>   42
05:24:26 <mjrosenb> hrmm, perhaps emacs is just hilighting it wrong
05:24:28 <ski> you can make an *operator* called that
05:25:14 <Alpounet> > let (-->) = fmap in (reads :: ReadS Int) --> (Just "1")
05:25:15 <lambdabot>   Just [(1,"")]
05:25:19 <theorbtwo> You can make a function called (-->), which is also a variable called (-->), and implies an infix operator called -->
05:25:25 <benmachine> if emacs is calling it a comment then yes emacs is wrong
05:25:34 <benmachine> comments are started by -- followed by a non-symbol character
05:25:41 <pozic> mjrosenb: Trusting Emacs to do something right is a sin.
05:25:41 <benmachine> (or eol, I guess)
05:26:01 <pozic> mjrosenb: or to be more precise, the Haskell Emacs mode.
05:26:21 <ski> > let x --> y = y ^ x in (`all` [0,1]) $ \a -> (`all` [0,1]) $ \b -> 0 /= ((a --> b) --> a) --> a
05:26:22 <lambdabot>   True
05:26:24 <theorbtwo> So fix it, dear liza, dear liza, dear liza?
05:27:51 * Daerim thought the emacs mode was made to make sure only people who really ment it ever programmed haskell
05:32:57 <ski> > let x --> y = y ^ x in ((\(a,b) -> ((a --> b) --> a) --> a) `graph`) `map` (liftM2 (,) [0,1] [0,1])
05:32:58 <lambdabot>   [((0,0),1),((0,1),1),((1,0),1),((1,1),1)]
05:32:58 <psykotic> emacs is a bit too fond of half-assed regexps for fontlock
05:34:11 <psykotic> isn't there a way to make ghc spit out an ast?
05:34:55 <ski> @type map . graph
05:34:56 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
05:35:09 <benmachine> @index graph
05:35:09 <lambdabot> bzzt
05:35:14 * benmachine bzzt
05:36:22 * Phyx- bzzt
05:37:29 <ski> <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
05:37:45 <ski> <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
05:37:55 * ski is a bit fond of those two
05:37:56 <benmachine> oic
05:38:15 <ski> @type map . cograph
05:38:16 <lambdabot> forall b a. (a -> b) -> [Either a b] -> [b]
05:39:05 <benmachine> @type uncurry (const Left)
05:39:06 <lambdabot> forall a b a1. (a1, a) -> Either a b
05:45:21 <benmachine> > runState (mfix put) ()
05:45:22 <lambdabot>   ((),())
05:45:28 * benmachine considers this
05:46:03 <benmachine> > fix $ execState (mfix put)
05:46:04 <lambdabot>   ()
05:46:08 <benmachine> heehee
05:48:41 <benmachine> :t let unsafePerformState s = evalState s (fix (execState s))
05:48:42 <lambdabot> <no location info>:
05:48:42 <lambdabot>     not an expression: `let unsafePerformState s = evalState s (fix (execState s))'
05:48:46 <benmachine> :t let unsafePerformState s = evalState s (fix (execState s)) in unsafePerformState
05:48:47 <lambdabot> forall s a. State s a -> a
05:48:52 <pozic> What is better naming style? removeXFrom or removeXFromY? When used in the code it will look like removeXFrom y vs removeXFromY y. I like the former.
05:49:45 <bolmar> @hoogle [a] -> [a]
05:49:46 <lambdabot> Prelude cycle :: [a] -> [a]
05:49:46 <lambdabot> Prelude init :: [a] -> [a]
05:49:46 <lambdabot> Prelude reverse :: [a] -> [a]
05:50:04 <benmachine> quite a lot of those, bolmar
05:51:30 <tensorpudding> did utf8-string disappear?
05:52:07 <benmachine> I think it's no longer necessary in 6.12?
05:52:11 <tensorpudding> err, nvm, just my spelling
05:52:14 <benmachine> heh
05:52:19 <tensorpudding> there is no package uft8-string
05:52:31 <benmachine> pozic: I agree with you re. removeFrom
05:53:31 <tensorpudding> however, xmonad appears to dislike that the old version of utf8-string that my config was compiled with has disappeared
05:54:32 <tensorpudding> guess i'll just restart xmonad the old-fasioned way
05:56:17 <ski> @type fst . fix . uncurry . const . runState
05:56:18 <ski> @type ($ ()) . loop . uncurry . const . runState
05:56:18 <lambdabot> forall s a. State s a -> a
05:56:18 <lambdabot> forall s a. State s a -> a
05:57:04 <pozic> What exactly counts as defensive programming?
05:57:51 <pozic> IMHO, it is just a term without any meaning. Code is either right or wrong.
05:58:45 <ski> maybe .. adding type signatures to operations (apart from polymorphic recursion (or rank-n) or constraining them further than the inferred type)
05:59:21 <doserj> code evolves. make sure that parts of your code are robust against changes in other parts
06:00:02 <pozic> All this robustness is nothing else than defining contracts of languages, like in SICP.
06:00:22 <pozic> I.e. techniques from the 80s.
06:00:31 <nomi> hello
06:00:59 <nomi> can some one help me with java please? linked lists
06:01:14 <pozic> nomi: maybe #java?
06:01:20 <ski> nomi : maybe you wanted to try ##java ?
06:01:44 <pozic> In #haskell linked lists are too complicated. We only talk about academic hypothetical code which never works.
06:02:41 <benmachine> pozic: that a technique has been around for decades doesn't mean that anyone has enough sense to use it :)
06:03:19 <CalJohn> nomi: hello, troll
06:03:27 <benmachine> CalJohn: oh be quiet
06:03:40 <benmachine> we get a lot of people here who don't know what haskell is
06:03:48 <pozic> benmachine: I suppose. In the same sense we could argue in 30 years how everyone was stupid to use a non-probabilistic programming language.
06:04:09 <tensorpudding> hmm
06:04:11 <pozic> I wonder how banks solve the cosmic ray programming problem.
06:04:14 <tensorpudding> still getting this weird error
06:04:26 <benmachine> CalJohn: "never attribute to malice that which can be adequately explained by stupidity" :)
06:04:42 <tensorpudding> saying it can't find utf8-string-0.3.5, which is understandable since it no longer exists
06:04:43 <pozic> benmachine: that's what all the malicious people say ;)
06:04:56 <benmachine> :O my cover is broken
06:04:59 * benmachine runs
06:05:41 <CalJohn> benmachine: well, i think you'd have to be perversely misinformed to ask that kind of question.  even so, saying what i said probably isn't helpful either way
06:06:35 * ski topologizes benmachine's cover
06:06:50 <benmachine> CalJohn: you consider perverse misinformation a rarity, then? :P
06:07:11 <CalJohn> heh ;)
06:07:25 * tensorpudding replaces benmachine's cover with a finite subcover
06:27:54 <Daerim> is there a way of making the IO monad stop for a moment before carrying on? I mean, besides asking it to give me the first 22456 numbers of pi. Also that would only work once....
06:29:01 <\yrlnry> Daerim:  Isn't there a sleep : (Num a) => a -> IO () function?
06:29:12 <\yrlnry> I know there is.  Just a minute.
06:29:34 <Daerim> ok, just couldn't find a sleep or wait via hoogle
06:29:49 <doserj> hoogle threadDelay
06:29:51 <doserj> @hoogle threadDelay
06:29:51 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
06:30:03 <\yrlnry> threadDelay
06:30:28 <\yrlnry> sleep :: (RealFrac a) => a -> IO ()
06:30:28 <\yrlnry> sleep n = threadDelay (truncate (n * 1000000))
06:32:14 <ski> @hoogle wake
06:32:14 <lambdabot> No results found
06:32:36 <Daerim> doserj, thanks :)
06:40:48 * hackagebot upload: hjson 1.1 - JSON parsing library (JaroslavGridin)
06:58:54 * hackagebot upload: Useful 0.0.1 - Some useful functions and shorthands. (DanielHolden)
07:04:56 * hackagebot upload: hjpath 2.0 - XPath-like syntax for querying JSON (JaroslavGridin)
07:06:55 * ski wonders what is Useful ..
07:07:26 <ski> possibly not
07:07:30 <ski> > (`map` [0,1,2]) `map` ([0,1,2] `frob` (["a","bc","def"] !!))
07:07:31 <lambdabot>   ["abd","abe","abf","acd","ace","acf"]
07:09:24 <ski> @type \bss -> let ix = [0 .. length bss - 1] in (`map` ix) `map` (ix `frob` (bss !!))
07:09:24 <lambdabot> forall b. [[b]] -> [[b]]
07:09:43 <pastorn> i need to derive monadTrans with generalized newtype deriving
07:09:43 <Yoshibloke> ski - I just uploaded it. Take a look.
07:10:04 <Yoshibloke> although rather embarrassingly there is a bug in the "explode" function. :x
07:10:07 <ski> pastorn : does it work ?
07:10:11 <pastorn> newtype LOL a = LOL { unLOL :: StateT Env Err a } deriving (idunno)
07:10:35 <pastorn> data Err a = Ok a | Bad String
07:11:21 <pastorn> i want both put/get and fail to be monadic "top level" (no heavy lifting wanted)
07:11:24 <ski> Yoshibloke : i was thinking (mayhaps ignorantly) that `Useful' is not a very useful package name ..
07:11:37 <pastorn> deriving (Monad, MonadState Env) works
07:11:41 <zygoloid> newtype Foo m a = Foo (StateT Int m a) deriving (Monad, MonadTrans)
07:11:44 <pastorn> but for MonadTrans i dunno
07:11:45 <zygoloid> ^^ that works here
07:11:46 <Yoshibloke> ski - lol - true :P
07:11:57 * hackagebot upload: hslogger 1.0.10 - Versatile logging framework (JohnGoerzen)
07:12:01 <idnar> rename it to Useless
07:12:11 <opqdonut> gah, Useful doesn't have haddoc
07:12:18 <Yoshibloke> It should do :x
07:12:23 <Yoshibloke> perhaps I uploaded it wrong.
07:12:32 <voker57_> maybe it's not built yet
07:12:37 <opqdonut> perhaps they haven't been generated yet
07:12:38 <opqdonut> yeah
07:12:40 <pastorn> zygoloid: thanks, but why do i need to keep that 'm' free?
07:12:45 <pastorn> very disturbing :(
07:13:00 <ski> pastorn : well, you need a type with kind `(* -> *) -> (* -> *)', to make an instance of `MonadTrans' ..
07:13:06 <zygoloid> pastorn: because MonadTrans has the m free
07:13:38 <pastorn> hah!
07:13:50 <pastorn> i've been struggling for this for way too long to only get this now :)
07:13:53 <pastorn> thanks :)
07:14:08 <ski> the `lift' operation for `MonadTrans t' requires `m a -> t m a', for *any* `Monad' `m'
07:14:27 <ski> so maybe you want `ErrT m a' or something in there ?
07:15:19 * ski tries to figure out how to convince hackage to display the source of `Useful' in the browser ..
07:16:16 <ski> (.. also, i suppose everyone present though my `frob' above looked too scary to play with)
07:16:59 * hackagebot upload: Useful 0.0.2 - Some useful functions and shorthands. (DanielHolden)
07:17:40 <zygoloid> @type frob
07:17:41 <lambdabot> forall a (i :: * -> *) b. (Eq a, Applicative i) => [a] -> (a -> i b) -> i (a -> b)
07:18:17 <ski> @type \f a -> fmap ($ a) f
07:18:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
07:19:04 <zygoloid> > (frob "12345" return) <*> "hello"
07:19:05 <lambdabot>   "* Exception: frob
07:19:28 <zygoloid> > (frob "12345" repeat) <*> "hello"
07:19:29 <lambdabot>   "* Exception: frob
07:19:57 <voker57_> ski: just wait a bit, documentation isn't built instantly
07:20:02 <zygoloid> > (frob "12345" Just) <*> Just 'x'
07:20:03 <lambdabot>   Just * Exception: frob
07:20:38 <Yoshibloke> Sorry about the Usefu upload guys. This is my first package.
07:21:07 <Yoshibloke> I've got the documentation in /dist/doc but it isn't getting packaged. How can I get it into the tarball with cabal?
07:21:17 <ski> > frob [LT,EQ,GT] (\o -> case o of LT -> [LT,EQ]; EQ -> [LT,EQ,GT]; GT -> [EQ,GT]) <*> [LT,EQ,GT]
07:21:18 <lambdabot>   [LT,LT,EQ,LT,LT,GT,LT,EQ,EQ,LT,EQ,GT,LT,GT,EQ,LT,GT,GT,EQ,LT,EQ,EQ,LT,GT,EQ...
07:21:31 <voker57_> Yoshibloke: it should be auto-generated from sources
07:21:45 <voker57_> if it's not, wait a bit
07:22:22 <Yoshibloke> hmm ok
07:23:08 <benmachine> > frob [] (:[]) <*> []
07:23:09 <lambdabot>   []
07:23:16 <benmachine> > frob [] (:[]) <*> [x]
07:23:17 <lambdabot>   [* Exception: frob
07:23:23 <benmachine> > frob [x] (:[]) <*> [x]
07:23:24 <lambdabot>   [x]
07:23:32 <benmachine> > frob [0] (:[]) <*> [0]
07:23:33 <lambdabot>   [0]
07:23:34 <ski> > (`map` [LT,EQ,GT]) `fmap` frob [LT,EQ,GT] (\o -> case o of LT -> [LT,EQ]; EQ -> [LT,EQ,GT]; GT -> [EQ,GT])
07:23:35 <lambdabot>   [[LT,LT,EQ],[LT,LT,GT],[LT,EQ,EQ],[LT,EQ,GT],[LT,GT,EQ],[LT,GT,GT],[EQ,LT,E...
07:24:04 <ski> (i suppose it possibly is not as self-explaining as it might be)
07:24:07 <benmachine> heh
07:24:21 <benmachine> > frob [0] (:[1]) <*> [0]
07:24:22 <lambdabot>   [0,1]
07:24:28 <benmachine> > frob [0,1] (:[1]) <*> [0,1]
07:24:29 <lambdabot>   [0,1,0,1,1,1,1,1]
07:24:30 <ski> voker57_ : are you Yoshibloke ?
07:24:38 <benmachine> > frob [0,1] (:[1]) <*> [1,0]
07:24:39 <lambdabot>   [1,0,1,0,1,1,1,1]
07:25:22 <ski> (hint : consider the type `a' with equality constraint to be some "small" finite type)
07:25:31 <voker57_> ski: no
07:26:11 <ski> oh .. ok, i see
07:27:14 <ski> (btw, it does `error "frob"' when you pass the "result" function an `a' that was not in the input list)
07:28:01 * hackagebot upload: Useful 0.0.3 - Some useful functions and shorthands. (DanielHolden)
07:28:16 <Yoshibloke> hmm
07:29:08 <ski> hm, oh right
07:29:09 <ski> > frob [False,True] (\b -> case b of False -> [True]; True -> [True,False])
07:29:10 <lambdabot>   [{True->True;False->True},{True->False;False->True}]
07:29:21 * ski forgot lambdabot can show some functions
07:33:20 <iFire> what's the recommend haskell book?
07:33:31 <tensorpudding> @where rwh
07:33:31 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:33:39 <tensorpudding> ^ that book
07:33:58 <tensorpudding> online tutorial supplements include:
07:34:01 <tensorpudding> @where lyah
07:34:01 <lambdabot> http://www.learnyouahaskell.com/
07:34:38 <iFire> tensorpudding thanks
07:34:52 * ski liked "Haskell: The Craft of Functional Programming"
07:35:28 <iFire> ski isn't it from 1999
07:35:39 <ski> why, yes
07:35:53 <iFire> is ghc haskell 98
07:35:57 <ski> it uses Haskell 98
07:36:15 <iFire> there's a revised haskell report in 2003
07:36:26 <ski> GHC is GHC, it has lots of extensions (some of which Hugs and, iirc, nhc,jhc support, too)
07:36:38 <aavogt> I don't believe that the book covers any ffi
07:36:38 <tensorpudding> there are some additions in haskell 2010 but they are minor
07:36:40 <ski> the basics are the same, anyway
07:36:46 <DigitalGuru> hi there
07:36:47 <ski> aavogt : *nod*
07:37:06 <tensorpudding> that's not to say at all that the GHC extensions beyond H98 aren't useful
07:37:13 <tensorpudding> just that they aren't included in a standard yet
07:37:16 <ski> (there's not much that has *changed* (i can't think of anything, atm), it's just that there's extensions added)
07:37:37 <DigitalGuru> anybody knows if it's possible to increase the stack size in GHCi ?
07:37:53 <tensorpudding> they're being collated in the Haskell Prime initiative, which is supposedly going to lead to more revisions like Haskell 2010
07:38:14 <CalJohn> DigitalGuru: i don't know if it is possible, but asking if it is might indicate that you are doing something wrong.  what are you doing?
07:38:44 <DigitalGuru> :D I'm trying to find the maximum element of a large list (actually 1 million elements in it)
07:38:56 <jmcarthur> that should take constant space if done correctly
07:39:06 <CalJohn> yeah, that should take constant space
07:39:07 <jmcarthur> if the list is lazily generated, anyway
07:39:26 <DigitalGuru> *Main> maximum [1..1000000] *** Exception: stack overflow *Main>
07:39:31 <iFire> so read learnyouahaskell first or real world haskell?
07:39:34 <jmcarthur> @src maximum
07:39:34 <lambdabot> maximum [] = undefined
07:39:35 <lambdabot> maximum xs = foldl1 max xs
07:39:40 <tensorpudding> LYAH is simpler
07:39:45 <tensorpudding> much less material
07:39:57 <jmcarthur> that should probably be using foldl' (is there a foldl1'?)
07:39:58 <tensorpudding> more conversational less textbooky, fun pictures
07:40:04 <jmcarthur> :t foldl1'
07:40:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:40:08 <jmcarthur> yes there is!
07:40:11 <ski> > foldl' max 0 [1 .. 1234567]
07:40:12 <lambdabot>   1234567
07:40:20 <CalJohn> jmcarthur: bear in mind that lambdabot lies about how things actually are implemented
07:40:27 <jmcarthur> > foldl1' max [1..1000000]
07:40:28 <lambdabot>   1000000
07:40:38 <jmcarthur> CalJohn: i don't think it's lying this time
07:40:43 <tensorpudding> lambdabot lies about her fondness for Caleskell
07:40:43 <jmcarthur> > foldl1' max [1..10000000]
07:40:45 <lambdabot>   10000000
07:40:52 <DigitalGuru> whoa, i should investigate that because i'm an haskell noob
07:41:40 <tensorpudding> @src foldr
07:41:40 <lambdabot> foldr f z []     = z
07:41:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:41:40 <jmcarthur> DigitalGuru: foldr is lazy right associative, foldl is lazy left associative, foldl' is strict left associative
07:41:56 <CalJohn> you're right jmcarthur, maxiumum actually is defined that way
07:41:59 <DigitalGuru> oki
07:42:13 <jmcarthur> DigitalGuru: with -O2 foldl is usually optimized to an equivalent to foldl', but not without optimizations
07:42:31 <jmcarthur> DigitalGuru: (assuming the operation is strict, that is)
07:42:32 <CalJohn> wait, actually, it is lying, there are rewrite rules for ints
07:42:48 <jmcarthur> i doubt rewrite rules fire for ghci
07:43:27 <CalJohn> but probably DigitalGuru is compiling?  either way, this is sorted
07:43:31 <ski> s/lies/takes artistic liberties/
07:43:34 <DigitalGuru> sorry for my question but foldl1' is not defined in GHCi
07:43:35 <jmcarthur> DigitalGuru: most of us just use foldl' instead of foldl by default, but the standard libraries don't because that's the specification
07:43:39 <DigitalGuru> actually, i'm using the interpreter
07:43:43 <jmcarthur> DigitalGuru: it's in Data.List
07:43:51 <DigitalGuru> ok thanks
07:43:57 <ski> (s/interpreter/interactor/)
07:44:12 <DigitalGuru> I works...
07:44:24 <DigitalGuru> pretty subtil way for a noob
07:44:26 <DigitalGuru> :p
07:44:35 <DigitalGuru> thank you all
07:44:46 <iFire> who's using llvm ghc?
07:44:50 <mjrosenb> is there a generalized words?
07:45:48 <benmachine> @src words
07:45:49 <lambdabot> words s = case dropWhile isSpace s of
07:45:51 <lambdabot>     "" -> []
07:45:53 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
07:46:12 <benmachine> I don't think so, but you could construct one with break
07:46:18 <mjrosenb> benmachine: fun.
07:46:36 <benmachine> that definition with isSpace replaced by an arbitrary predicate?
07:46:53 <jmcarthur> there might be one in the split package
07:47:13 <jmcarthur> http://hackage.haskell.org/packages/archive/split/0.1.2/doc/html/Data-List-Split.html#v%3AwordsBy
07:47:17 <jmcarthur> there we go :)
07:56:23 <benmachine> Useful isn't very
08:07:51 <EnglishGent> hi all!
08:08:03 <MissPiggy> hi
08:08:10 <EnglishGent> does anyone here use Haskell with emacs under cygwin?
08:08:14 <EnglishGent> hello MissPiggy :)
08:08:27 * EnglishGent has such a set up on one machine - and it seems to be unhappy
08:08:55 <EnglishGent> specifically emacs will _not_ run the ghcii repl
08:09:11 <EnglishGent> as the name of the program contains a space -- though other cygwin stuff seems to work fine
08:09:25 * EnglishGent not sure if this falls under 'cygwin' or 'emacs' or 'haskell'
08:10:19 <aavogt> @hoogle rnf
08:10:19 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
08:14:22 <twink> > let spew p s@(c:_) | p c = spew' p s | otherwise = spew'' p s ; spew' p s = let (pfx, sfx) = span p s in case pfx of { [] -> [] ; _ -> Left pfx : spew'' p sfx } ; spew'' p s = let (pfx, sfx) = break p s in case pfx of { [] -> [] ; _ -> Right pfx : spew' p sfx } in spew isSpace " hi there "
08:14:22 <lambdabot>   [Left " ",Right "hi",Left " ",Right "there",Left " "]
08:14:59 <Polarina> Does anyone know of a database engine written in Haskell?
08:16:00 * ksf wonders whether he's the first one to need two monoids on a tree
08:16:42 <jmcarthur> ksf: in what sense?
08:16:59 <jmcarthur> two monoids on the measure of a fingertree? two instances of monoid for a single tree type?
08:17:03 <MissPiggy> ksf I think ring theory might have tried that first :P
08:18:09 <dmwit> There's instance (Monoid a, Monoid b) => Monoid (a, b) where, right?
08:18:18 <jmcarthur> right
08:18:25 <EnglishGent> hmm...
08:18:36 * EnglishGent wonders if Instance Monoid Partridge...
08:18:39 <EnglishGent> :)
08:18:42 <jmcarthur> > ("foo", Sum 5) `mappend` ("bar", Sum 2)
08:18:43 <lambdabot>   ("foobar",Sum {getSum = 7})
08:19:11 <ksf> I guess I better state the whole problem: for a glyph cache, I want a data structure that does adaptive key-lookup like a splay tree but also want to drop non-regularily used glyphs from the cache
08:19:12 <MissPiggy> :t (++)
08:19:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:19:36 <jmcarthur> caleskell!
08:19:48 <tommd> wahoo, exponential merge!
08:20:01 <jmcarthur> tommd: you managed that with darcs2?
08:20:26 <ksf> I've turned to finger trees in the hope that I get efficient deletion of those max-priority elements, but right now, I'm just perfectly confused about how to do it.
08:20:26 <tommd> no - ghc is still in darcs 1 format, jmcarthur.
08:20:29 <jmcarthur> i haven't had an exponential merge since darcs 1
08:20:31 <Polarina> Which would me more efficient to work with generally on GHC (performance wise), "type Vector3D = (Double, Double, Double)" or "data Vector3D = Double Double Double"?
08:20:31 <jmcarthur> oh
08:20:37 <jmcarthur> yuck!
08:21:05 <jmcarthur> Polarina: those should be equally efficient i think
08:21:27 <ksf> ah wait.
08:21:33 <Polarina> jmcarthur, ok cool. Which do you think would be easier to use?
08:21:37 <jmcarthur> Polarina: data Vector3D = Vector3D !Double !Double !Double might be nice though
08:22:09 <Polarina> Why the exclamation marks?
08:22:17 <dmwit> he's excited
08:22:22 <Polarina> Ah.
08:22:26 <jmcarthur> Polarina: the type synonym is probably the easiest, but the strict fielded data type is probably going to be faster for most uses
08:22:33 <jmcarthur> Polarina: strict fields
08:22:54 <Polarina> Why would anyone wish to use strict fields? :S
08:23:09 <jmcarthur> because for some things laziness isn't helpful
08:23:16 <Polarina> But it's cool...
08:23:18 <tensorpudding> funbox your strict fields
08:23:29 <jmcarthur> yes, that
08:23:33 <idnar> @quote funbox
08:23:33 <lambdabot> No quotes match. Are you on drugs?
08:23:38 <idnar> what!
08:23:52 <MissPiggy> Polarina, it's to stop huge chains of unevaluated artihmetical work building up and stealing RAM
08:23:54 <tensorpudding> @quote funroll
08:23:54 <lambdabot> No quotes match. I've seen penguins that can type better than that.
08:24:04 <domor``> Polarina: there is a Vector3 in Data.Tensor
08:24:10 <Polarina> domor``, oh, cool.
08:24:15 <jmcarthur> data Vector3D = Vector3D {-# UNPACK #-} !Double {-# UNPACK #-} !Double {-# UNPACK #-} !Double
08:24:21 <Polarina> Unpack?
08:24:27 <domor> it's defined with bangs too
08:24:29 <jmcarthur> or just use -funbox-strict-fields and do my earlier suggestion
08:24:46 <Polarina> What does -funbox-strict-fields do?
08:24:54 <jmcarthur> Polarina: unboxes your strict fields into the constructor
08:24:57 <MissPiggy> funboxes strict fields!
08:24:58 <jmcarthur> less indirection
08:25:17 <Polarina> What's an indirection?
08:25:28 <domor> Polarina: have you done Java before?
08:25:29 <jmcarthur> Polarina: do you know any C?
08:26:17 <Polarina> jmcarthur, yes.
08:26:19 <Polarina> domor, no.
08:26:29 <jmcarthur> Polarina: a pointer is a level of indirection
08:26:41 <jmcarthur> Polarina: boxed fields are pointers, unboxed ones are just values
08:27:35 <Polarina> I am pretty certain that I can trust ghc do make the optimal decision. :)
08:27:38 <jmcarthur> boxing is nice for laziness, but if you aren't using laziness it isn't as useful, especially as a field in a data type
08:27:55 <jmcarthur> ghc will not automagically unbox strict fields, afaik
08:28:10 <benmachine> why not?
08:29:21 <jmcarthur> benmachine: it wouldn't be necessary to use -funbox-strict-fields if -O2 already used it, and -O2 is specified to use every "safe" optimization, so i would assume that because there are cases that unboxing strict fields might be unsafe (or at least not helpful), it doesn't happen by default
08:29:42 <jmcarthur> maybe somebody more familiar with ghc optimization flags could verify?
08:30:21 <mreh> I learned about lists represented as functions today
08:30:31 <mreh> is that done in GHC?
08:30:32 <jmcarthur> yay church encoding!
08:30:37 <jmcarthur> not that i know of
08:30:49 <jmcarthur> i very much doubt it
08:30:58 <mreh> the lecturer said it was useful for optimisation
08:31:12 <mreh> 7 out of 8 people in the lecture seemed unimpressed
08:31:12 <jmcarthur> it can be, considering inlining and stuff, i think
08:31:47 <benmachine> jmcarthur: the user's guide only says "This option is a bit of a sledgehammer: it might sometimes make things worse. Selectively unboxing fields by using UNPACK pragmas might be better."
08:32:00 <jmcarthur> benmachine: yes
08:32:13 <zygoloid> benmachine: unboxing an 8 byte value on a machine with 4 byte pointers could increase memory usage i guess
08:32:17 <jmcarthur> that's why i only use that flag for individual files when i'm pretty sure it would be stupid
08:32:24 <mreh> can I write a function that composes a function n times? I suppose I can
08:32:26 <jmcarthur> *wouldn't be
08:32:34 <benmachine> "This may not always be an optimisation: if the T constructor is scrutinised and the floats passed to a non-strict function for example, they will have to be reboxed (this is done automatically by the compiler)."
08:32:38 <mreh> then I can implement (!!) for church encoding
08:32:46 <benmachine> you can, mreh
08:32:49 <zygoloid> benmachine: ah, of course :)
08:33:00 <benmachine> there are several ways of doing it depending on how much library you want to use
08:33:10 <jmcarthur> :t \f n -> (!! n) . iterate f
08:33:11 <lambdabot> forall a. (a -> a) -> Int -> a -> a
08:33:12 <benmachine> my favourite way is appEndo . mconcat . replicate n . Endo
08:33:14 <zygoloid> @type foldr (.) id (replicate ?n ?f)
08:33:15 <lambdabot> forall b. (?n::Int, ?f::b -> b) => b -> b
08:33:17 <mreh> benmachine: a fold would od it
08:33:33 <benmachine> :t appEndo . mconcat . replicate ?n . Endo
08:33:34 <lambdabot> forall a. (?n::Int) => (a -> a) -> a -> a
08:33:47 <MissPiggy> benmachine my favorite is to define data Nat = Z | S Nat and foldNat
08:34:03 <benmachine> that works too
08:34:10 <jmcarthur> > (!! 10) . iterate (*2) $ 5
08:34:11 <lambdabot>   5120
08:34:30 <MissPiggy> benmachine hey did you see that graph reduction stuff? it is so cool but I could not bring myself to implement it
08:34:37 <mreh> defining (!!) in terms of (!!) wouldn't work
08:34:46 <mreh> but I get the idea
08:34:53 <benmachine> MissPiggy: depends which you mean by "that"
08:35:08 <mreh> MissPiggy: I would like to see that
08:35:09 <jmcarthur> mreh: here's a fun representation for lists: http://hackage.haskell.org/packages/archive/fmlist/0.8/doc/html/Data-FMList.html
08:35:15 <MissPiggy> the one about lambda calculus and optimal graph reduction
08:35:34 <MissPiggy> Lampings algorithm and then there's a simplification/generalization paper too
08:35:42 <benmachine> MissPiggy: don't think I did see it
08:35:43 <benmachine> but
08:35:52 <benmachine> I don't really want to start again at this stage :P
08:36:09 <benmachine> so, if anyone else implements it I will piggyback on their success
08:36:21 <benmachine> otherwise I will do things navely
08:37:30 <zygoloid> @type execState . replicateM_ ?n  . State $ (,) () . ?f
08:37:31 <lambdabot> forall s. (?n::Int, ?f::s -> s) => s -> s
08:37:37 <jmcarthur> mreh: a function that composes a function n times is the church encoding for naturals :)
08:37:40 <zygoloid> ^^ that's quite fun
08:38:06 <mreh> jmcarthur: analogous to Paeno arithmetic
08:38:28 <mreh> if that is the right terminology
08:38:48 <jmcarthur> type Nat = forall b . (b -> b) -> b -> b
08:38:57 <ezyang> Bah, hp2any-manager fails to compile for me.
08:39:18 <benmachine> I got excited about this a few days ago and tried to work out how to encode things in untyped lambdas
08:39:23 <benmachine> but mostly just confused myself
08:39:52 <benmachine> it is something to do with catamorphisms?
08:40:05 <MissPiggy> untyped lambda?
08:40:19 <MissPiggy> oh nevermind
08:40:33 <benmachine> the untypedness lets you do things like
08:40:36 <benmachine> :t \x -> x x
08:40:37 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:40:37 <lambdabot>     Probable cause: `x' is applied to too many arguments
08:40:37 <lambdabot>     In the expression: x x
08:40:38 <stevenmarky> just use backspace to untype lambdas
08:40:40 <zygoloid> jmcarthur: doesn't that have too many values, due to seq? (eg, f _ _ = undefined is extensionally different from f _ !x = undefined)
08:41:15 <jmcarthur> zygoloid: seq is dumb, though :P
08:41:29 <mreh> also, untyped lambdas gives you russell's paradox
08:41:35 <benmachine> mreh: yes that is part of the fun
08:41:38 <mreh> for lambda calculus
08:41:42 <MissPiggy> mreh how?
08:41:59 <zygoloid> yep. how much pain would putting seq in an (automatically-derived) typeclass cause?
08:42:27 <jmcarthur> zygoloid: actually quite a bit, i bet. so many type constraints to add to your code!
08:42:28 <mreh> MissPiggy: I can't remember, but it's analogous to Russell's paradox for naive set theory
08:42:41 <MissPiggy> mreh I don't beleive it :P
08:42:47 <jmcarthur> i think i'd still prefer it, though, but that's just me
08:42:59 <mreh> MissPiggy: if you use the typed lambda calculus it's okay
08:43:03 <Polarina> When implementing an embedded database, should I make it pure or use the IO monad?
08:43:07 <mreh> ....and breath!
08:43:25 <jmcarthur> you should make as much of it pure as you can, Polarina ;)
08:43:48 <benmachine> mreh: if you use typed lambda calculus do you then need to allow recursion?
08:44:25 <mreh> benmachine: are you asking or telling me?
08:44:36 <benmachine> asking
08:44:49 <Polarina> jmcarthur, the front-end interface, I mean. Executing the queries, writing to a file.
08:44:50 <mreh> benmachine: you use one of the infinite number of fix point combinators
08:44:50 <jmcarthur> asking socratically? ;)
08:45:05 <jmcarthur> Polarina: good luck writing that purely anyway
08:45:07 <benmachine> mreh: but things like \x -> x x aren't properly typed, are they?
08:45:07 <EnglishGent> oh before I forget - a question of my own (speaking of lambda calculus) - am I correct in thing that 'combinator' is just a fancy term for 'higher order function'
08:45:08 <mreh> the Y combinator being the most common example
08:45:14 <Polarina> jmcarthur, unsafePerformIO to the rescue!
08:45:17 <mreh> benmachine: no!
08:45:19 <benmachine> jmcarthur: no I know virtually nothing about lambda calculus
08:45:21 <jmcarthur> Polarina: no!
08:45:24 <Polarina> jmcarthur, Yes!
08:45:28 <EnglishGent> lots of people seem to use it that way - e.g. when talking about 'combinator libraries' for Haskell
08:45:38 <MissPiggy> EnglishGent I think it tehnically means a closed term
08:45:39 <EnglishGent> to e.g. glue bits of HTML together!
08:45:41 <mreh> VERBOTEN
08:45:49 <Polarina> jmcarthur, anyway, why not?
08:45:54 <MissPiggy> EnglishGent whereas in "combinator libraries" in haskell have lots of free vars...
08:45:56 <jmcarthur> Polarina: why not unsafePerformIO?
08:46:14 <EnglishGent> that's my understanding of the technical definition too MissPiggy - but that's not what 'combinator' seems to mean in the 'library' sense
08:46:18 <benmachine> Polarina: the clue is in the name :P
08:46:22 <jmcarthur> Polarina: why don't you try it and see?
08:46:32 <jmcarthur> Polarina: you will become enlightened very quickly
08:46:32 <Polarina> jmcarthur, if I make sure the implementation is ACID compliant and other evil stuff will not destroy it, I don't see a problem.
08:46:37 <benmachine> EnglishGent: I think some people use "combinator" to mean, "useful thing" :P
08:47:05 <kw317> how to convert Int# to Int?
08:47:14 <Polarina> Int#?
08:47:17 <jmcarthur> Polarina: using unsafePerformIO for such things is a great way to lose all ability to reasonabout your code
08:47:17 <benmachine> @src Int
08:47:17 <lambdabot> data Int = I# Int#
08:47:18 <Polarina> What's that?
08:47:20 <EnglishGent> benmachine - well that's mean! it just confuses poor students :|
08:47:23 <jmcarthur> *reason about
08:47:26 <Polarina> jmcarthur, hmm...
08:47:28 * EnglishGent is a poor confused student :|
08:47:30 <benmachine> EnglishGent: I don't defend them doing so
08:47:38 <benmachine> that is just the impression I have picked up
08:47:58 <jmcarthur> Polarina: if you've got the time i vote for you to try it, honestly. nothing like hands on experience to learn what not to do!
08:48:08 <Polarina> :)
08:48:21 <benmachine> jmcarthur: but surely there is a slight problem in that
08:48:30 <EnglishGent> hmmm - another question whilst I'm here...
08:48:31 <jmcarthur> Polarina: but if you want to write it right the first time just use IO for IO and pure code for pure things
08:48:35 <benmachine> like uninitialised memory access, unsafePerformIO doesn't *always* break
08:48:36 <kw317> benmachine: thanks
08:48:45 <EnglishGent> @hoogle Eq a => [a] -> [a] -> Bool
08:48:46 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:48:46 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
08:48:46 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
08:48:53 <benmachine> it just occasionally does horrible things
08:48:58 <Polarina> jmcarthur, perhaps you're right. :)
08:49:02 <EnglishGent> is there a function for determining if two lists are equal up-to-permutation?
08:49:12 <jmcarthur> benmachine: it wouldn't necessarily break, but it would take a lot of fragile strictness annotations and uses of seq to keep it steady
08:49:21 <benmachine> EnglishGent: the easiest way'd be to sort them, I guess
08:49:26 <EnglishGent> if not .. I can see a much more efficient way of doing it where both lists are of a type supporting Ord
08:49:35 <EnglishGent> right benmachine
08:49:44 <benmachine> if they're Eq but not Ord you could do some kind of fold/delete
08:49:51 <benmachine> but that would be quite inefficient
08:49:53 <jmcarthur> benmachine: plus the whole only running the action once at most per thunk thing
08:49:56 * Alpounet never even called unsafePerformIO
08:50:10 <EnglishGent> but it's not strictly *necessary* for them to support Ord is it? I was wondering if there would be a way of only using the inefficient approach *if* they didnt support Ord
08:50:18 <zygoloid> Polarina: presumably it would be bad if your "SELECT * FROM stuff" query's results were to be remembered indefinitely (which might happen if the results of the query claim to be pure)
08:50:25 <jmcarthur> i've used unsafePerformIO, but only for dirty caching tricks that are referentially transparent
08:50:44 <EnglishGent> so that you'd have a function perm-equal :: Eq a => [a] -> [a] -> Bool
08:50:58 <EnglishGent> but it would do the obvious thing if in fact a was an instance of Ord
08:51:04 <Polarina> zygoloid, ah, I see.
08:51:05 <benmachine> I once wrote an unsafePerform class with an instance for IO
08:51:31 <EnglishGent> in a dynamically typed language I'd do that using 'instance-of' & switch appropriately
08:51:33 <jmcarthur> benmachine: unsafePerform :: m a -> a ?
08:51:36 <EnglishGent> what's the Haskellish way? :)
08:51:38 <benmachine> jmcarthur: yes :P
08:51:57 <benmachine> EnglishGent: GHC supports specialisations, I don't know if that's what you want
08:52:04 <jmcarthur> unsafePerformIO, unsafePerformST, fromJust, head, etc.?
08:52:05 <benmachine> might only be monomorphic
08:52:06 <pozic> Is there a way to tell Vacuum to show only nodes of a particular type?
08:52:11 <benmachine> jmcarthur: yeah
08:52:15 <jmcarthur> although i guess the latter two aren't "unsafe"
08:52:17 <jmcarthur> just partial
08:52:19 <benmachine> also a weird one for State
08:52:29 <Polarina> Anything that can be ordered can also be logically compared for equality.
08:52:33 <jmcarthur> passing in _|_ for state?
08:52:35 <EnglishGent> I'm not sure what your referring to benmachine
08:52:42 <benmachine> no, passing in fix execState
08:52:51 <jmcarthur> o_O
08:52:55 <benmachine> :P
08:52:56 <jmcarthur> :t fix execState
08:52:57 <lambdabot>     Couldn't match expected type `State s a'
08:52:57 <lambdabot>            against inferred type `s -> s'
08:52:57 <lambdabot>     In the first argument of `fix', namely `execState'
08:52:59 <benmachine> err
08:53:03 <benmachine> :t \s -> fix (execState s)
08:53:04 <lambdabot> forall a a1. State a a1 -> a
08:53:15 <EnglishGent> but not the other way round Polarina - so if you do the equivalence check using a sort - your forcing more conditions than are strictly necessary
08:53:40 <jmcarthur> that's disgusting :P
08:53:56 <ezyang> MUT_ARRAY_PTRS_FROZEN ewww
08:54:02 <Polarina> EnglishGent, I realise that.
08:54:14 <benmachine> EnglishGent: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
08:54:54 <EnglishGent> thanks benmachine :)
08:55:09 <jmcarthur> EnglishGent: if you need lists to be equal up to permutation then perhaps you want a multiset instead of a list in the first place?
08:55:18 * benmachine is milidly amused by the apparently random interchanging of SPECIALISE and SPECIALIZE in the examples
08:55:37 <Berengal> benmachine: It's like INTERCAL's PLEASE
08:56:15 <jmcarthur> EnglishGent: of course that would probably put an Ord constraint on the elements anyway, but at least it would be consistent with the semantics of what you are using the lists for
08:56:38 <EnglishGent> I'm trying to write something to compare boolean expressions jmcarthur - I've defined a BoolEqn type 'data BoolEqn = And [BoolEqn] | Or [BoolEqn] | Not BoolEqn | Term String
08:56:51 <EnglishGent> so in _this_ case my elements are sortable
08:57:16 <ezyang> So... what are they?
08:57:25 <Berengal> benmachine: You State unsafePerform isn't an instance of your class
08:57:43 <Berengal> benmachine: It returns the state, not the value in the state
08:57:54 * EnglishGent trying to define (==) proof-theoretically over BoolEqn
08:58:28 <Berengal> @type \s -> let (a, s') = runState s s' in a
08:58:29 <lambdabot> forall t t1. State t1 t -> t
08:58:30 <benmachine> Berengal: you pass it to evalState
08:58:37 <ezyang> I guess I should bust out my copy of the GHC source code...
08:58:42 <benmachine> oh, I guess that's the same thing
08:58:56 <Berengal> Same problem with eval
08:59:11 <benmachine> hm?
08:59:31 <benmachine> :t evalState ?s (fix (execState ?s))
08:59:32 <lambdabot> forall a a1. (?s::State a a1) => a1
08:59:43 <Berengal> @type \s -> loop (uncurry runState) s
08:59:44 <lambdabot> forall d c. State d c -> c
08:59:52 <benmachine> :t loop
08:59:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:59:56 <benmachine> oic
09:00:06 <benmachine> yes your way is better :P
09:00:13 <mreh> I need to evolve some boolean functions, with free variables
09:00:33 <mreh> "how to represent?" is the question...
09:00:49 <Berengal> mreh: Depends on how you're going to manipulate them
09:01:10 <Berengal> Also, what is a boolean function? * -> Bool?
09:01:23 <mreh> Berengal: boolean expressions
09:01:32 <Berengal> Ah, so Bools
09:01:42 <mreh> coursework project is to evolve a multiplexer
09:01:58 <mreh> 2 selector lines, 4 input lines, that kind of thing
09:02:03 <Polarina> Is it possible to make a note to ghc that it would be a "good idea" to precompute some piece of pure code, such as "sum . enumFromTo 1 4096"?
09:02:14 <EnglishGent> mreh - well I've got  a representation that works - dont know if it would suit your purposes though
09:02:21 <mreh> the fitness function is direct comparison to the truth table of a correct mux
09:02:30 <Berengal> Polarina: Unfortunately not, I believe
09:02:42 <Polarina> :(
09:02:51 <mreh> EnglishGent: what's that?
09:02:56 <Berengal> It's a bit of a shame, since Haskell is such a good description language
09:03:10 <EnglishGent> data BoolEqn = And [BoolEqn] | Or [BoolEqn] | Not BoolEqn | Term String
09:03:16 <Jedai> lift from Template Haskell maybe ?
09:03:32 <EnglishGent> I'm working on some code now for doing things with boolean equations - simplifying, checking for logical equivalence, etc
09:03:39 <Jedai> Berengal : Wouldn't it work ?
09:03:54 <mreh> EnglishGent how do you bind the terms?
09:04:20 <Berengal> Jedai: I don't know. I don't think you get the pure datastructures in your final executable
09:04:28 <Berengal> Maybe though
09:04:48 <EnglishGent> I have an evaluator - you give it a function String -> Bool
09:04:57 <mreh> EnglishGent, okay
09:05:04 <EnglishGent> and it uses that to determine the values for the terms
09:05:08 <benmachine> Polarina: if you love overkill, use TH
09:05:09 <EnglishGent> and then evaluates the expression for you
09:05:21 <mreh> seems easy enough, I would have thought you could do it with CPS or something
09:05:23 <serhalp> Greetings, intimidating 638-person channel.  Is anyone here familiar enough with GLR parsing with Happy to help me out?
09:05:40 <EnglishGent> hello serhalp :)
09:05:41 <mreh> greetings, earthling
09:05:53 <mreh> that was so unbelievably nerdy
09:06:00 <lispy> hey everyone
09:06:02 <serhalp> :)
09:06:03 * EnglishGent hopes we're not *that* intimidating - this is a very friendly channel :)
09:06:04 <benmachine> serhalp: chin up, only 637 left
09:06:07 <malosh> Hi. How to do this ? I've got two classes : a "driver" class A and an "input" class B. There is also a compatibility class C : class (A a, B b)=>C a b, and a default instance of C for any A and B. I'd like to have an existential type forall b. B b=>Input b. It would use the "best" instance of C it can, and rely on the default instance else. Does the type system allow me to do it ?
09:06:10 <EnglishGent> hi lispy :)
09:06:10 <lispy> How are the types today?
09:06:12 <mreh> someone left
09:06:26 <mreh> 2nd biggest on freenode
09:06:35 <benmachine> serhalp: also, only about thirty of them actually ever say anything ever :(
09:06:46 <lispy> ?users
09:06:46 <lambdabot> Unknown command, try @list
09:06:51 <pozic> Java has some nice ideas, like the concept of a "this" reference. In Haskell being able to point to the This module would help.
09:06:53 <benmachine> preflex: users
09:06:57 <benmachine> or
09:06:58 <benmachine> something.
09:07:08 <ezyang> malosh: But wouldn't you need an implementation of a?
09:07:20 <lispy> malosh: What you're describing sounds like an a typical use of type classes.  Is it possible you're thinking of type classes in an object oriented mannor?
09:07:23 <lispy> manner*
09:07:23 <Berengal> pozic: A better module system would help.
09:07:24 <mreh> pozic: "this" is the pointer of the current object
09:07:44 <pozic> mreh: yes, they work in different systems.
09:07:59 <pozic> Berengal: like an ML one?
09:08:05 <malosh> lispy : no, it's not. Look at the quantifiers
09:08:10 * lispy also meant "atypical" instead of "a typical"
09:08:11 <pozic> Berengal: then the class system is kind of redundant.
09:08:19 <benmachine> an object-oriented manor
09:08:38 <malosh> ezyang : suppose I've got it.
09:09:13 * benmachine puts {-# OPTIONS_GHC -w #-} at the top of a file and cackles evilly
09:09:20 <Berengal> pozic: Not redundant I'd say. The class system has some benefits over modules (as well as vice versa), but it could use some reworking
09:09:33 * serhalp pictures an object-oriented manor -- perhaps it was inherited?
09:09:33 <lispy> malosh: Well, I don't quite get what is going.  Do you have an example of something close (but perhaps not working) to help facilitate the discussion?
09:09:42 <lispy> serhalp: heh
09:10:16 <ezyang> malosh: I mean, it's pretty important you encode that into the types
09:10:35 <malosh> lispy : Ok, If I had quantified my existential type over C a b instead of any B b, it would work
09:10:55 * ezyang is now mucking around the RTS documentation 
09:10:57 <lispy> malosh: hmm...okay
09:11:14 <malosh> my idea was to use a king of "typeclass class"
09:11:18 <malosh> s/king/kind
09:11:36 <serhalp> Is my best bet for help with Happy the mailing list?
09:12:37 <pozic> serhalp: what is your problem?
09:13:05 <mreh> how many actually contribute on this channel?
09:13:18 <MissPiggy> 16:57  * EnglishGent trying to define (==) proof-theoretically over BoolEqn
09:13:28 <Alpounet> mreh, contribute ?
09:13:30 <dons> 636
09:14:00 <MissPiggy> EnglishGent: do you have a normal form for these because if you do and nf :: BoolEqn -> NF then b == d = nf b == nf d (== on NF is just syntactic)
09:14:04 <pozic> dons: and how many of them are not bots and have said something remotely intelligent related to Haskell?
09:14:06 <dbbddbdb> Hi!  Any Windows users of Haskell Platform with GHC 6.10.4 here?
09:14:38 <dons> pozic: well, probably about 630 are not bots
09:14:51 <MadHatterDude> dbbddbdb: Is there a problem?
09:15:00 <pozic> Anyway, counting useful libraries is more useful.
09:15:10 <benmachine> @bots
09:15:10 <lambdabot> :)
09:15:14 <benmachine> no luna?
09:15:19 <pozic> And those have been becoming better.
09:15:28 <dbbddbdb> MadHatterDude: yes, with cabal install SDL
09:15:34 <EnglishGent> well the only way I can think of to get a normal form is to cheat and treat the term names as significant - and even then I'm not sure I can define one
09:15:39 <pozic> The tools still suck, though.
09:15:42 <EnglishGent> I can definitely define simplification procedures
09:15:53 <mreh> Alpounet: do more than grace us with their presence :)
09:15:55 <MadHatterDude> dbbddbdb: I'm sorry, i don't use that.
09:16:03 <mreh> delighted as we are to have them all with us
09:16:05 <Alpounet> mreh, oh, okay
09:16:31 <MissPiggy> EnglishGent: if variables are not rigid, then it seems like you should be trying to find a unification rather than equality? (produce a Maybe (Name -> Value))
09:17:40 <EnglishGent> well - this is part of the internals of a somewhat more complex piece of code .. but thanks for the suggestion - I'll add 'unify' to my gradually-evolving BoolEqn library :)
09:18:26 <EvanCarroll> win 9
09:25:05 <ksf> ...there should be a database where you put in what operations you need and how often you want do do each, and it spews out a list of data structures sorted by how well they implement those operations
09:25:23 <ksf> (or combinations of data structures)
09:25:45 <ezyang> ksf: That would be pretty cool
09:25:49 * hackagebot upload: darcs-benchmark 0.1.7 - Comparative benchmark suite for darcs. (EricKow)
09:26:07 <aavogt> so there should be some standardized vocabulary for what the operations actually do
09:26:12 <ezyang> Although putting in "what operations you need" is kind of tricky, at first glance
09:26:32 <aavogt> type signatures are a start?
09:26:37 <mreh> are we going to get record semantic combinators as standard in haskell?
09:26:40 <ezyang> [a] -> Int -> a
09:26:43 <mreh> haskell 2011
09:26:49 <MissPiggy> ksf expert system for programming
09:26:49 <ezyang> so... not enough.
09:26:51 <Heffalump> mreh: write a proposal :-)
09:26:53 <MissPiggy> ksf great idea
09:27:04 <EnglishGent> hmm - I definitely want something where I can provide a set of BoolEqn & another BoolEqn & ask 'is this a necessary consequence of that set of equations' ?
09:27:10 <mreh> Heffalump: I was hoping someone else had done it already
09:27:39 <MissPiggy> EnglishGent: it is RING proofs over a Z/2Z?
09:27:43 <Heffalump> not that I know of. How would it work?
09:27:49 <Heffalump> In particular what would they be called?
09:28:01 <MissPiggy> EnglishGent: you are writing a very good program
09:28:25 <Heffalump> also, it'd have a much better chance of getting in if you first get it into a Haskell compiler as an extension.
09:29:15 <malosh> Has someone here ever used type families ?
09:29:23 <EnglishGent> MissPiggy - I dont follow you on your point re: RING (I know what a ring is) - but I'm not quite sure what you mean
09:29:27 <benmachine> malosh: a little
09:29:28 <MissPiggy> malosh yes
09:29:30 <EnglishGent> your suggesting I have a ring of proofs?
09:29:36 <malosh> then what is it useful for ?
09:29:40 <MissPiggy> EnlighsGent, theorem proving for rings
09:29:48 <EnglishGent> ah!
09:29:52 <Berengal> malosh: Associating types with other types. Type functions
09:29:56 <benmachine> malosh: more or less everything that you can do with functional dependencies you can also do with type families
09:30:20 <MissPiggy> malosh you can make indexed monad! but lots of other stuff too
09:30:22 <Berengal> Also, provably injective associated data types
09:30:38 <malosh> I guessed a little about fundeps. What can you do that you can't do with functional dependencies ?
09:30:51 <benmachine> malosh: I think they are equivalent in expressivity
09:30:59 <benmachine> but type families are more "natural" sometimes
09:31:16 <malosh> ok, thanks
09:31:20 <MissPiggy> EnglishGent: wait do you have a in-progress code online /
09:31:21 <MissPiggy> ?
09:31:24 <Berengal> benmachine: I think data families aren't covered by fundeps
09:31:29 <MissPiggy> like github or something
09:31:31 <benmachine> Berengal: oh, yeah
09:31:39 <EnglishGent> MissPiggy - no, I only started thinking about it this morning
09:31:43 <malosh> Berengal : why ?
09:31:46 <EnglishGent> :)
09:32:00 <MissPiggy> I just want to see your data
09:32:40 <Berengal> malosh: With simply associated types, or fundeps, you can have Assoc String ~ Assoc Int, but with data families that'll always be false
09:33:14 <EnglishGent> currently I dont have data so much as the very beginnings of a BoolEqn library & a wishlist of functions it should provide
09:33:35 <malosh> Berengal : excuse me, but what does Assoc String ~ Assoc Int mean ?
09:33:46 <MissPiggy> BoolEqn means Bool Equation ?
09:33:48 <ezyang> Hmm, I bet converting my code from vectors to 32-tuples would be a bad idea...
09:34:12 <Heffalump> ezyang: how about a record with strict fields?
09:34:40 <EnglishGent> yes
09:34:46 <MissPiggy> so it is
09:34:51 <EnglishGent> life's too short to keep typing Boolean Equation
09:34:52 <EnglishGent> :)
09:34:57 <MissPiggy> data BoolEquation = BoolExpression :=: BoolExpression
09:35:08 <ezyang> Heffalump: Like, a strict vector?
09:35:42 <MissPiggy> and BoolExpression has TT FF Variable :||:/Or :&&:/And?
09:35:48 <Heffalump> of statically known size
09:35:58 <EnglishGent> yes
09:36:09 <EnglishGent> and implies
09:36:46 <EnglishGent> another thing I want to be able to do is pass the system a set of BoolEqns & say 'draw the lattice'
09:36:49 <MissPiggy> EnglishGent okay it needs finite domain solvers!
09:36:55 <EnglishGent> where lattice nodes correspond to terms
09:37:01 <MissPiggy> you can use MonadicCP
09:37:13 <EnglishGent> MonadicCP?
09:37:25 * EnglishGent looking at the chaff algorithm right now
09:37:38 <ezyang> Heffalump: I suppose. It'd be obnoxious to write out 32 of them, as well as the resizing code.
09:37:48 <EnglishGent> & wondering if it's worth trying to generalise to SMT solvers
09:38:56 <ksf> zomg wikipedia actually claims splay trees are height-balanced
09:39:31 <medfly> is someone on the Internet wrong?
09:39:36 <benmachine> oh my goodness warn-unused-do-bind is obnoxious
09:39:53 <benmachine> (I know everyone already knows, but still)
09:40:12 <benmachine> this is like when gcc started complaining about discarding return values of fread
09:40:37 <benmachine> and everyone went wat :O
09:40:40 <Ke> I for one think all warnings are awesome!
09:41:01 <benmachine> Warning: your opinion is wrong
09:41:15 <Ke> if you expect the worst you should most often deal with such
09:43:14 <Heffalump> ezyang: well, you initially suggested a 32-item tuple, I was just continuing in that spirit :-)
09:43:22 <ezyang> Heffalump: heh
09:43:36 <ezyang> Maybe this is an excuse to bring in some template haskell
09:43:38 <Alpounet> 0.232233
09:43:48 <ezyang> Most of this information really should be statically known...
09:43:50 <Alpounet> hmm
09:44:47 <EnglishGent> oh - CP = Constraint Programming?
09:48:46 <benmachine> SourceGraph seems pretty good at creating large numebrs of empty files
09:52:16 <Raynes> EnglishGent: CP = child porn, last I checked. ;)
09:52:42 <medfly> hehe, I am glad to see I wasn't the only one that thought "monadic child porn?" there
09:54:40 <EnglishGent> I'm trying to think of something you might prefix with Monad...
09:54:53 <EnglishGent> my first thought was Corporal Punishment :P
09:55:22 <EnglishGent> (well - it has side-effects doesnt it?) :)
09:55:35 <medfly> heh
09:57:27 <jmcarthur> ksf: i guess splay trees might be height balanced after a bunch of uniformly random lookups...
10:01:44 <ksf> jmcarthur, sure, but you can't use it as a constraint
10:01:51 <jmcarthur> certainly not
10:03:10 <MaciejP> Can I make lambdabot telling me all available commands?
10:03:20 <medfly> @help
10:03:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:03:40 <ehamberg> http://code.haskell.org/lambdabot/COMMANDS
10:05:02 <Polarina> What's template haskell?
10:05:30 <jmcarthur> Polarina: a way to generate haskell code at compile time
10:06:03 <Polarina> jmcarthur, do you got any examples?
10:06:09 <ksf> featuring quasiquoting, type-safety and done in your favourite programming language
10:06:20 <medfly> ksf, is it C++?
10:06:37 <ksf> medfly, we don't serve perverts in here.
10:07:03 <shepheb> working on an assignment, and it's failing the marking scripts but every test case I can come up with is flawless. any suggestions for higher-order functions that don't involve lists?
10:07:10 <jmcarthur> Polarina: the data-accessor-template package generates accessors for data-accessor from a type name using template haskell
10:07:17 <ezyang> ha
10:07:24 <jmcarthur> Polarina: it's basically AST generation
10:07:35 <medfly> what does AST mean
10:07:37 <Polarina> jmcarthur, I understood nothing of that.
10:07:40 <ezyang> abstract syntax tree
10:07:44 <medfly> okay, thanks
10:07:46 <jmcarthur> Polarina: look it up on hackage
10:07:52 <jmcarthur> data-accessor is nice :)
10:08:18 <ksf> Polarina, say you have a binary search tree to lookup something, and you notice it's static. with TH, you can unroll it to be code instead of a lot of pointer lookups.
10:08:27 <jmcarthur> although there are a couple possible more general replacements up now which i haven't checked out i think
10:10:15 <jerome`> is there a way to obtain the next-largest Double?
10:10:19 --- mode: ChanServ set +o mauke
10:10:19 --- kick: Trice was kicked by mauke (Trice)
10:10:19 --- mode: mauke set +b *!*@ip-134-53-244-195.dhcp.muohio.edu
10:10:49 <ksf> jerome`, there is, and it's quite intricate as the bit patterns are quite intricate
10:12:04 <jerome`> ksf: what is it?
10:12:19 --- mode: mauke set -o mauke
10:16:44 <appamatto> Does the absence of type annotations necessarily imply curry-style typing?
10:17:19 <ksf> nope
10:17:33 <ksf> it depends on whether you write f x y or f (x, y)
10:17:44 <ksf> ...it's all about the pattern matching.
10:18:39 <ksf> actually, haskell just doesn't know of uncurried functions. you have to emulate them with tuples or other product types.
10:19:07 <appamatto> why does f x y versus f (x, y) make a difference?
10:19:22 <ksf> because the former takes two arguments, the latter one tuple
10:21:31 <Polarina> Is a lazy ByteString suitable for random access I/O?
10:22:24 <ksf> currying doesn't exist for fall-through patterns, btw. that's the reason why you can't have function definitions where cases have a different number of arguments.
10:23:25 <ksf> Polarina, use bytestring-mmap?
10:24:26 <Polarina> ksf, will check that out.
10:24:27 <ksf> or iteratees, they can seek
10:24:41 <Polarina> Even better. :)
10:24:53 <ski> @. read run (`showsCL` "") $ \xs -> case xs of [] -> False; [x] -> not x; x:y:_ | x || y -> False; [x,_] -> x; x:_:z:_ -> not x && z
10:24:54 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
10:25:01 <ksf> otherwise, you're going to duplicate the data
10:25:03 <ski> hrm
10:25:09 <ski> > (`showsCL` "") $ \xs -> case xs of [] -> False; [x] -> not x; x:y:_ | x || y -> False; [x,_] -> x; x:_:z:_ -> not x && z
10:25:10 <lambdabot>   "\\xs -> case xs of {[] -> False; [False] -> True; [False,False] -> False; ...
10:25:58 <gwern> @quote you.*finger
10:25:59 <lambdabot> uncyclopedia says: Calculations which are undefined are denoted by the _|_ symbol, pronounced Bottom, which the documentation explains as the compiler giving you the finger.
10:26:08 <gwern> @quote not.*supposed.*to
10:26:08 <lambdabot> fasta says: And by cool, I mean "that is not supposed to happen".
10:26:13 <ksf> Polarina, if you want performance, use mmap. the seek/fd interface is usually slower
10:26:19 <gwern> @quote different.ways
10:26:20 <lambdabot> Draconx|Laptop says: mathematics is the art of finding different ways to write "therefore".
10:26:46 <gwern> @quote all.your.*preferences
10:26:46 <lambdabot> medfly says: Cale, #haskell wants to know all your personal preferences so we can all copy you
10:26:54 <gwern> @quote gentoo
10:26:54 <lambdabot> Cale says: Gentoo is a massive waste of electricity.
10:27:03 <burp> full agreement
10:27:04 <ski> > (`showsCL'` "") $ \xs -> case xs of [] -> False; [x] -> not x; x:y:_ | x || y -> False; [x,_] -> x; x:_:z:_ -> not x && z
10:27:04 <gwern> @quote memetic
10:27:05 <lambdabot> hobophobe says: So, I can only conclude that Haskell is a memetic virus, and monads are the eggs it lays out in innocent programming forums to entice others to become infected.
10:27:05 <lambdabot>   "[] -> False; [False] -> True; [False,False] -> False; False:False:False:_ ...
10:27:16 <gwern> @quote unsafeCoerce
10:27:17 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
10:27:19 * ski grumbles
10:27:22 <benmachine> right so I'm playing with SourceGraph and it is throwing a large number of vague IO errors onto stdout and then producing a large number of empty files
10:27:27 <gwern> @quote unsafeCoerce
10:27:28 <lambdabot> ddarius says: isJust . unsafeCoerce
10:27:33 <gwern> bleh
10:27:34 <benmachine> what do people recommend?
10:27:38 <gwern> @quote unsafeCoerce.*id
10:27:38 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
10:27:46 * benmachine hi5 lambdabot 
10:27:48 <ski> > (`showsCL` "") $ \xs -> case xs of [] -> False; [x] -> not x; x:y:_ -> x && not y
10:27:49 <lambdabot>   "\\xs -> case xs of {[] -> False; False:_ -> False; [True] -> False; True:F...
10:27:49 <gwern> benmachine: use different source files
10:27:59 <gwern> @quote i.have.no.idea
10:27:59 <benmachine> gwern: I'm running it on itself
10:27:59 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
10:28:01 <ski> > (`showsCL` "") $ \xs -> case xs of [] -> False; [x] -> not x; _:y:_ -> y
10:28:02 <lambdabot>   "\\xs -> case xs of {[] -> False; [False] -> True; False:False:_ -> False; ...
10:28:12 <benmachine> :t showsCL
10:28:13 <ski> > (`showsCL` "") $ \xs -> case xs of [] -> False; [x] -> not x; x:_ -> x
10:28:13 <lambdabot> ([Bool] -> Bool) -> String -> String
10:28:14 <lambdabot>   "\\xs -> case xs of {[] -> False; False:_ -> False; True:_ -> True}"
10:28:17 <gwern> @quote i.have.no.idea.*hell
10:28:17 <lambdabot> jmcarthur says: what good is a state monad if your state is basically "i have no idea what the hell my state is"?
10:28:22 <ski> > (`showsCL` "") $ \xs -> False
10:28:23 <lambdabot>   "\\_ -> False"
10:28:27 <gwern> benmachine: running sourcegraph on sourcegraph? MADNESS
10:28:31 <gwern> @flish
10:28:36 <medfly> flish flush :)
10:28:47 <benmachine> gwern: it's pretty much the one case you'd think would definitely work
10:28:53 <ski> > (`showsCL` "") $ \xs -> null xs
10:28:55 <lambdabot>   "\\_ -> False"
10:29:03 <benmachine> but it throws me endless SourceGraph: fd:4: commitAndReleaseBuffer: illegal operation (handle is closed)
10:29:06 <gwern> medfly: please. 'flush' is so vulgar
10:29:06 <benmachine> instead
10:29:13 <medfly> it is?
10:29:16 <MaciejP> > showsCL head "abcd"
10:29:17 <lambdabot>   "\\xs -> case xs of {[] -> * Exception: Prelude.head: empty list
10:29:20 <benmachine> (also some broken pipes)
10:29:33 <jmcarthur> never flush with broken pipes!
10:29:37 <ski> (hm, maybe that's a bug)
10:29:45 <gwern> 'tis like saying 'jelly'
10:30:59 <MaciejP> @info showsCL
10:31:00 <lambdabot> showsCL
10:31:07 <benmachine> @info doesn't exist
10:31:07 <lambdabot> doesn't exist
10:31:10 <medfly> @hoogle showsCL
10:31:11 <lambdabot> No results found
10:31:19 * hackagebot upload: concurrent-extra 0.3 - Extra concurrency primitives (RoelVanDijk)
10:31:22 <medfly> @type showsCL
10:31:24 <lambdabot> ([Bool] -> Bool) -> String -> String
10:31:26 <MaciejP> What does showsCL do?
10:31:31 <medfly> I'm guessing someone defined it earlier
10:32:08 <cebewee> @src showsCL
10:32:09 <lambdabot> Source not found. Sorry.
10:32:31 <MaciejP> > showsCL (const True) "0123 abc"
10:32:32 <lambdabot>   "\\_ -> True0123 abc"
10:32:49 <MaciejP> > showsCL (const False) "0123 abc"
10:32:50 <lambdabot>   "\\_ -> False0123 abc"
10:33:08 <benmachine> it seems to be a Show instance for Bool functions
10:33:18 <benmachine> sort of
10:33:33 <benmachine> > showsCL and ""
10:33:36 <lambdabot>   mueval-core: Time limit exceeded
10:33:41 <benmachine> heh
10:33:44 <benmachine> > showsCL or ""
10:33:47 <lambdabot>   mueval-core: Time limit exceeded
10:34:01 * benmachine wonders how that works
10:34:45 <benmachine> > showsCL (\[] -> True) ""
10:34:46 <lambdabot>   "* Exception: <interactive>:1:142-152: Non-exhaustive patterns in lambda
10:34:52 <ski> hm .. i suppose the bug is because the current version doesn't work with finite list
10:34:59 <ski> benmachine : the predicate must be total
10:35:10 <benmachine> > showsCL (foldr (const True) False) ""
10:35:11 <lambdabot>   Couldn't match expected type `b -> b'
10:35:11 <lambdabot>         against inferred type `GHC.Bo...
10:35:58 <benmachine> > showsCL (foldr const False) ""
10:36:00 <lambdabot>   "\\xs -> case xs of {[] -> False; False:_ -> False; True:_ -> True}"
10:36:28 <benmachine> the predicate must also be lazy?
10:36:42 <ski> not really, i think
10:36:53 <ski> it must be total, on total input lists
10:37:18 <MaciejP> > let f [True, False] = True; f [False, True] = True; f _ = False in showsCL f ""
10:37:20 <lambdabot>   "\\_ -> False"
10:37:23 <benmachine> but and and or don't work
10:37:24 <ski> (i.e. passing `and' doesn't work, since that isn't total on `repeat True')
10:37:28 <benmachine> oh
10:37:31 <benmachine> right
10:37:40 <benmachine> that's sort of what I meant by lazy
10:37:48 <benmachine> it must terminate on infinite lists
10:38:08 <benmachine> > showsCL (and . take 40) ""
10:38:09 <lambdabot>   "\\xs -> case xs of {[] -> True; False:_ -> False; [True] -> True; True:Fal...
10:38:15 <benmachine> heh
10:38:19 <benmachine> > length $ showsCL (and . take 40) ""
10:38:21 <lambdabot>   9190
10:38:23 <benmachine> :D
10:38:26 <ski> but there is apparently a bug hiding, because part of the code didn't consider the finite list case
10:46:59 <ski> > (`showsCL_` "") $ \xs -> False
10:47:00 <lambdabot>   "\\_ -> False"
10:47:05 <ski> > (`showsCL_` "") $ \xs -> null xs
10:47:07 <lambdabot>   "\\xs -> case xs of {[] -> True; False:_ -> False; True:_ -> False}"
10:47:14 <ski> > let f [True, False] = True; f [False, True] = True; f _ = False in showsCL f ""
10:47:15 <lambdabot>   "\\_ -> False"
10:47:16 <MissPiggy> I think that I have defined field
10:47:23 <ski> > let f [True, False] = True; f [False, True] = True; f _ = False in showsCL_ f ""
10:47:24 <lambdabot>   "\\xs -> case xs of {[] -> False; [False] -> False; False:False:_ -> False;...
10:48:44 <ksf> ok, here's the plan: one doubly-linked splay tree holding the values, indexed by keys and another splay tree indexed by lookup frequency fingering the first tree.
10:49:51 <ski> hm .. it *appears* to work now
10:51:11 <ski> though it would be nice if it did some factoring out of common parts
10:51:16 <ksf> so lookup would be O(lookup in fst + adjust of snd), insert O(lookupMax snd + splay fst + insert fst + insert snd).
10:51:33 <ksf> er lookupDeleteMax
10:51:48 <ski> such as merging `False:x:_ -> foo x; True:x:_ -> foo x' into `_:x:_ -> foo x'
10:54:22 <ski> > (`showsCL_` "") $ \xs -> case xs of True:_ -> True; _ -> False
10:54:23 <lambdabot>   "\\xs -> case xs of {[] -> False; False:_ -> False; True:_ -> True}"
10:56:50 <ski> MaciejP : yes, a `shows' operation on (total) functions of type `[Bool] -> Bool'
10:59:06 <shapr> Hey, who posts to twitter.com/reddit_haskell ? I'd prefer that it not go directly to comments, but instead show the linked article. Can that be done?
10:59:39 <ben> But then how would you get to the comments?
11:00:08 <Polarina> ksf, ok, cool. But isn't mmap a limitation on 32-bit systems and large files?
11:00:11 <jmcarthur> shapr: i suspect it's just a bot
11:00:21 <jmcarthur> or do you mean who admins it?
11:00:45 <ksf> Polarina, well, then you need to code an extra layer that can move the mmaped portion around
11:00:58 <jmcarthur> i kind of like it linking to the comments
11:01:11 <Polarina> ksf, hmm, ok, thanks.
11:01:28 <Polarina> ksf, will moving a mmap around be any slower than fd/seek?
11:01:31 <ksf> still, you get rid of all that calling into C that the fd interface implies.
11:01:34 <shapr> jmcarthur: I just want to know if there's a good reason links go to the comments part of the reddit posts, not to the links themselves.
11:02:08 <jmcarthur> shapr: the way it is, i can still get to the article, but linking directly to the article would mean i can't easily get to the comments without going to reddit separately
11:02:32 <Polarina> ksf, could you recommend a library?
11:02:51 <ksf> unmapping and mapping should both be real fast.
11:02:54 <shapr> jmcarthur: Yeah, I can see that. Still, navigating from a twitter client on a phone takes a large number of clicks.
11:03:01 <ksf> I'm not aware of any that does that
11:03:09 <jmcarthur> ew
11:03:23 <ksf> and with those amounts of data and truly random access, you're bound to be IO-bound, anyway.
11:03:36 <ksf> mmaping a file doesn't mean that it won't be on disk.
11:04:23 <Polarina> ksf, understandable.
11:04:35 * lispy cautions against mmap, it really is a bit of a hack in most uses
11:04:37 <jmcarthur> what do you mean "moving a mmap around"?
11:04:45 <Polarina> But without a library, does that mean I need to create my own bindings with FFI?
11:04:48 <lispy> jmcarthur: sliding window over the file
11:04:53 <jmcarthur> ah
11:04:58 <lispy> jmcarthur: (I'm just guessing)
11:05:19 <lispy> There is a stack overflow question (more like 10) about the fastest way to read a file
11:06:08 <lispy> Benchmarking it is actually somewhat subtle because the OS tries very hard to adaptively optimize your uses of mmap
11:06:29 <lispy> OSs tend to be lazy
11:06:46 <ksf> ouch. to properly keep track of lookup frequency while not messing up new insertions I need to set the looked up node to (current + size(map) - 1) and all others to (current - 1), which is O(n)
11:08:37 <ksf> better use a deque for that.
11:10:37 <ksf> ...so. doubly-linked splay tree with key to value fingering a doubly-linked list sorted by last-recently-accessed fingering the tree.
11:10:49 <jmcarthur> kinky
11:11:37 <jmcarthur> sounds complex
11:12:23 <ksf> that's not many pointers, though. back in school I did a huffman coder and the code generator ended up having left, right, left child, right child and parent pointers.
11:15:07 <ksf> the nice thing is that all the operations on the doubly-linked list are O(1), so I get the performance of a splay tree for lookups+inserts _and_ can remove the least used item in the time it takes to splay the tree, without looking up the element.
11:17:56 <ksf> ...that not having to look up the element makes sense is based on the intuition that the least-recently accessed element in a splay tree is bound to be quite buried, so definitely more than log n. dunno if that's worth the added constant for keeping track of the pointers, though.
11:18:46 <ksf> hmm. actually, I don't think I have to splay the tree on deletion, but all those docs say it's done.
11:19:47 <jmcarthur> why are you using a splay tree anyway? i've never found a great use for them
11:21:59 <ksf> ...because their performance is better than a balanced tree for skewed distributions.
11:22:58 <jmcarthur> ah. i guess i've never really needed a skewed access container before
11:23:06 <jmcarthur> or at least i never thought i did
11:23:10 <dbbddbdb> Is it possible to emulate epochTime from unix with something from time?
11:23:14 <dbbddbdb> time confuses me :(
11:23:20 <jmcarthur> splay trees don't play nice with pure code, either :(
11:23:27 <dbbddbdb> I just want something like IO Int32 with seconds
11:24:07 <ksf> and distributions _are_ going to be skewed. either because there's more 'e's in text than '%', or because the kern pair 'er' is more common than say 'xt'
11:25:00 <ksf> I need the whole thing to be monadic to be able to delete the least-recently accessed element on insertion of a new one, anyway.
11:25:54 <jmcarthur> i just meant lookups. in most data structures lookups don't require a mutation
11:26:12 <ksf> ...but those all aren't adaptive.
11:26:32 <ksf> if the propability is known beforehand, you can of course optimize the search tree statically.
11:26:48 <jmcarthur> yeah
11:27:13 <ezyang> Of course, whether or not that is easy to do is unclear...
11:28:37 <ksf> ...or you can skew your access pattern to form a bell curve or something that looks similar.
11:29:51 <ksf> oh, how easy the days of ascii have been. back then, with our current machines, you could just do a 256x256 lookup table.
11:36:01 <aavogt> > ord maxBound
11:36:01 <lambdabot>   1114111
11:37:23 <ksf> that doesn't include combined glyps, yet.
11:37:32 <gwern> -_- this redshift software reverses lat/long signs? no wonder it was adjusting my monitor for somewhere in Asia
11:38:02 <syntaxfree> I don't know why this isn't working: http://haskell.pastebin.com/d33c9eedb
11:38:26 <syntaxfree> it's very close to the sample code in the Data.ByteString documentation.
11:38:37 <ezyang> synatxfree: Word8 != Char
11:38:52 <mreh> gwern: who publishes that now?
11:38:57 <mreh> DK went bust
11:39:10 <mreh> I think I had redshift 3
11:39:12 <mauke> syntaxfree: import Data.ByteString.Char8
11:39:14 <mauke> By.split ' ' x
11:39:20 <syntaxfree> oh. ok.
11:39:26 <syntaxfree> thanks.
11:42:30 <ski> > (`showsCLF` "") $ \xs -> null xs
11:42:31 <lambdabot>   "\\xs -> case xs of {[] -> True; _:_ -> False}"
11:43:19 <mauke> > showsCLF null ""
11:43:20 <lambdabot>   "\\xs -> case xs of {[] -> True; _:_ -> False}"
11:44:17 <ski> (it's still pretty dumb in factoring out common cases, but at least it does some factoring now (apart from the constant cases, which is did from the start))
11:44:39 <syntaxfree> maybe I'm asking for trouble prototyping on ByteStrings. But anyway, is a damned long text.
11:44:41 <ski> (dbbddbdb : any relation to bddbddb ?)
11:44:55 <ksf> mhhh http://www.cs.cmu.edu/~jonderry/thesis.pdf . I love recent research.
11:46:07 <ksf> but first I have to understand why splaying is done on deletion. if it's just to make the next deletion meet the amortized bounds, then I can safely leave it out to make each deletion O(1)
11:48:37 <mreh> is the list monad lazy?
11:48:53 <ski> i'd say so
11:48:58 <c_wraith> yes.  It only generates results as demanded
11:49:03 <ski> but what do you mean by a monad being "lazy" ?
11:49:28 <mreh> ski: I'm not sure, I just blurted out that question without taking time to clarify what I want to know
11:49:43 <ski> you're lazy ;)
11:49:49 <syntaxfree> mreh: you might just get answers that aren't quite what you wanted to know.
11:49:53 <mreh> the problem is, specifying every possible truth table for a truth function
11:50:15 <syntaxfree> story of my life: I didn't quite know what economics was, long story short, I'm an economist.
11:50:16 <mreh> without knowing how many unbound variables there are required
11:50:28 <lament> syntaxfree: ouch
11:50:56 <syntaxfree> @remember <lament> syntaxfree: ouch
11:50:57 <lambdabot> Okay.
11:51:12 <syntaxfree> @quote syntaxfree
11:51:12 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
11:51:33 <syntaxfree> man, I was young.
11:51:41 <lament> syntaxfree: something similar happened to me. I was walking down a street when a vegetable cart hit me and rendered me unconscious. When I awoke I was the captain of a starship headed to Earth...
11:52:01 <syntaxfree> lament: I think that's sqrt(-1) cuils.
11:52:13 <jmcarthur> syntaxfree: why did you save lament saying "ouch"?
11:52:26 <syntaxfree> it's a lament.
11:52:30 <c_wraith> lament: you sound suspiciously like fwiffo
11:52:34 * jmcarthur slaps his forehead
11:52:46 <ski> > frob [False,True] (\x -> if x then [True] else [False,True])  -- syntaxfree, here you are
11:52:47 <lambdabot>   [{True->True;False->False},{True->True;False->True}]
11:52:50 <syntaxfree> i'll  be back soon.
11:53:38 <FliPPeh_> @quote flippeh
11:53:38 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:53:40 <FliPPeh_> :(
11:53:53 <lament> @quote fwiffo
11:53:53 <lambdabot> No quotes match. There are some things that I just don't know.
11:54:18 * ksf notes that pre-90's, even better pre-80's papers about data structures are a hell a lot more readable
11:54:51 <MissPiggy> ??
11:54:52 <mreh> now they're all littered with deconstructivist jargon
11:55:22 <tensorpudding> deconstructivist? is that more like constructive logic or literary deconstruction?
11:55:31 * ski ponders how to generalize the above function `Show' instance ..
11:55:34 <ksf> ...you have to search for pointers on how they're implemented under an avalanche of O analysis.
11:55:45 <mreh> did you hear about the post-modernist journal that accepted the MM generated paper?
11:55:49 <lament> I made a deconstructivist Doom map once
11:55:51 <ski> tensorpudding : perhaps dual-intuitionistic logic was meant ?
11:56:06 <enthymene> lament: deconstructivist doom map?  Do tell.
11:56:09 <MissPiggy> Remark A polynomial equals 0 if and only if each of its coefficients equals 0.
11:56:15 <lament> it was shaped like goatse.
11:56:21 <enthymene> haha
11:56:30 <enthymene> gives "rimjob" a new meaning
11:56:43 <mreh> gah, this is the main channel
11:57:09 <mreh> I was working on my stand up comedy routine back there
11:57:11 <mreh> what do you think?
11:58:33 <lament> now, I don't wanna go on a rant, but stand up comedy routines really don't belong in programming-language specific channels
11:58:54 <MissPiggy> @seen seanmcl
11:58:54 <lambdabot> Unknown command, try @list
11:58:56 <MissPiggy> !seen seanmcl
11:59:04 <ski> preflex: seen seanmcl
11:59:04 <preflex>  seanmcl was last seen on #haskell 16 days, 25 minutes and 21 seconds ago, saying: hatds: thanks
11:59:05 <MissPiggy> preflex: seen seanmcl
11:59:05 <tensorpudding> witty repartee is off-topic too
11:59:05 <preflex>  seanmcl was last seen on #haskell 16 days, 25 minutes and 22 seconds ago, saying: hatds: thanks
11:59:09 <ksf> do deconstructivists have anything interesting to say to a radical constructivist who by necessity considers all percievable structure to be illusion?
11:59:23 <tensorpudding> hmm
11:59:38 <tensorpudding> @vixen deconstructivists have anything interesting to say to a radical constructivist who by necessity considers all percievable structure to be illusion?
11:59:39 <lambdabot> good question
12:00:09 <gwern> mreh: redshift 3?
12:00:13 <enthymene> lament: subtle. :p
12:00:36 <MissPiggy> A Deconstruction of the Fundamental Theorem
12:00:36 <MissPiggy> Galois Theory
12:00:41 <MissPiggy> http://coq-galois-theory.googlecode.com/svn/trunk/notes/google/galois.pdf
12:01:04 <xerox> kind of... empty?
12:02:16 <tensorpudding> this channel has always been an appropriate place to talk about pure math i guess
12:02:56 <lament> there's also #math..
12:02:56 <MissPiggy> pure functional programming
12:05:04 <sioraiocht> This channel is better for Category Theory
12:05:48 <tensorpudding> #math is questions-oriented, this channel seems to be more banter-oriented
12:07:49 <MissPiggy> I think I lack the category theory gene
12:08:19 <tensorpudding> there is no category theory gene
12:11:05 <mreh> quiet, the AP might hear you and send out a wire
12:18:39 <mreh> how can I get all possible evaluations of booleans over n variables?
12:18:53 <mreh> list monad I'm thinking
12:19:07 <mreh> but it's a list of lists
12:19:17 <tensorpudding> a list comprehension?
12:19:24 <copumpkin> > replicateM 3 [False, True]
12:19:25 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
12:19:38 <mreh> amazing
12:19:39 <copumpkin> it's not very efficient this way though
12:19:58 <lament> just take the numbers 0..2^n-1, then interpret their bits as your values :)
12:20:01 <mreh> copumpkin: I'll understand, then worry about efficiency, but I'm interested in the other way
12:20:16 <copumpkin> mreh: well the issue is that nearby lists don't share tails
12:20:23 <copumpkin> mreh: so lists need to be kept around in memory for a while
12:20:47 <copumpkin> so reversing your "bit order" would be a lot more memory-friendly
12:20:53 <sizur> i forgot how one can iterate over a simple data (data T = A | B | C)
12:21:07 <mreh> sizur: derives Enum
12:21:13 <mreh> derives?
12:21:20 <copumpkin> deriving
12:21:25 <sizur> mreh: thanks, Enum was what i was looking for
12:21:38 <copumpkin> data T = A | B | C deriving (Enum, ...)
12:21:47 <copumpkin> probably Eq, Ord, Show, Read
12:22:09 <sizur> i couldnt remember -- Countable, Itrerable, what was that again.  hehe, thanks, #haskell rox
12:22:34 <mreh> \m/
12:23:29 <copumpkin> @src replicateM
12:23:30 <lambdabot> replicateM n x = sequence (replicate n x)
12:23:38 <copumpkin> @src sequence
12:23:38 <lambdabot> sequence []     = return []
12:23:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:23:38 <lambdabot> --OR
12:23:38 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:23:49 <mreh> you read my mind
12:23:55 <copumpkin> mreh: if you flipped the sequence order
12:24:00 <copumpkin> mreh: you'd get the more efficient version
12:24:23 <gwern> do we get Foldable derivations?
12:24:30 <copumpkin> @let sequence' [] = return []; sequence (x:xs) = do vs <- sequence xs; v <- x; return (v:vs)
12:24:31 <lambdabot>  <local>:63:53:
12:24:31 <lambdabot>      Ambiguous occurrence `sequence'
12:24:31 <lambdabot>      It could refer to e...
12:24:36 <copumpkin> @let sequence' [] = return []; sequence' (x:xs) = do vs <- sequence' xs; v <- x; return (v:vs)
12:24:38 <lambdabot>  Defined.
12:24:39 <benmachine> gwern: new in 6.12 I think
12:24:51 <copumpkin> @let replicateM' n x = sequence' (replicate n x)
12:24:53 <lambdabot>  Defined.
12:24:58 <copumpkin> > replicateM' 3 [False, True]
12:24:59 <lambdabot>   [[False,False,False],[True,False,False],[False,True,False],[True,True,False...
12:25:10 <benmachine> copumpkin: sharing the list tail?
12:25:17 <copumpkin> yep
12:25:20 <benmachine> clever
12:25:37 <Dementati> I wish ghci would linebreak. =/
12:25:38 <mreh> I don't understand, I need to go to sleep anyway, I'll save this for later
12:25:42 * enthymene sigh
12:25:49 * enthymene goes back to reading Hudak
12:25:52 <mreh> have it for lunch
12:25:55 <enthymene> one day, I will understand this...
12:26:06 <Dementati> Don't suppose I can make it break lines instead of... What it's doing now.
12:26:06 <copumpkin> > length $ replicateM' 10 [1..5]
12:26:09 <mreh> enthymene: HSOE?
12:26:10 <lambdabot>   mueval-core: Time limit exceeded
12:26:14 <copumpkin> > length $ replicateM' 5 [1..5]
12:26:14 <enthymene> mreh: indeed
12:26:15 <lambdabot>   3125
12:26:15 <Dementati> ?
12:26:19 <copumpkin> > length $ replicateM 5 [1..5]
12:26:20 <lambdabot>   3125
12:26:24 <copumpkin> > length $ replicateM 7 [1..5]
12:26:26 <lambdabot>   78125
12:26:28 <copumpkin> meh :)
12:26:31 <mreh> enthymene, where are you stuck, I read that book as my introduction
12:26:40 <enthymene> if I can get off my ass, maybe I can use it for my upcoming math project
12:26:43 <enthymene> oh, I'm not stuck
12:26:55 <enthymene> I'm just at work, so there are other demands on my time
12:27:04 <gwern> I wonder about hseo. I typed in 1 program and it looked different from the screenshot, making me wonder if the gtk bindings are wrong
12:27:13 <enthymene> I really wish I could just sit down and ogg my way through HSoE, SICP, et cetera.
12:27:25 <enthymene> but hey, gotta have the benjamins
12:27:40 <gwern> ogg?
12:27:43 <mreh> enthymene, it's not an easy thing to learn in a short space of time
12:27:49 <gwern> sicp has lectures I know, but hseo?
12:29:15 <MissPiggy> enthymene: I can't imagine that actually helping to LEARN the material though
12:29:26 <enthymene> learn what material?
12:29:36 <enthymene> gwern: ogg: to attack something without regard for resources
12:29:41 <enthymene> brace for link:
12:29:46 <gwern> @wn ogg
12:29:47 <lambdabot> No match for "ogg".
12:30:00 <MissPiggy> enthymene: I thought you were talking about listening to audio versions of books
12:30:12 <gwern> enthymene: english already has perfectly serviceable verbs for that, like 'mob', which don't clash with common file names...
12:30:28 <MissPiggy> oh
12:30:31 <enthymene> http://catb.org/jargon/html/O/ogg.html
12:30:41 <MissPiggy> I thought you meant OGG the audio file format lol!
12:30:44 <enthymene> ogg vorbis was named for it
12:30:46 <enthymene> apparently
12:31:23 <enthymene> ah nevermind, that was pratchett
12:32:37 <gwern> now that's some obscure jargon
12:32:40 <enthymene> heh
12:32:44 <ejpbruel> hello
12:32:47 <enthymene> I played netrek once upon a time
12:32:56 <enthymene> was never any good, but whatever
12:33:04 <ejpbruel> i was wondering if anybody here can recommand some good books about domain theory / category theory?
12:33:05 * ezyang <3 Pratchett 
12:33:06 * gwern will fandango upon enthymene's core if he willfuly continues to obscurantify his language
12:33:27 <gwern> enthymene: incidentally, there was a poem in the New Yorker made of jargon terms; a tribute
12:34:18 <ezyang> oh noes, I got a downvote. Haskell Reddit must not like me anymore T_T
12:34:20 <enthymene> gwern: sorry, I don't do redcode
12:35:15 <copumpkin> ezyang: yeah, we hate you, sry
12:35:27 <gwern> ezyang: we never liked you. we were just being nice because your mom asked us to
12:35:47 * ezyang goes and hides in a corner 
12:35:49 <benmachine> ezyang: I secretly like you but I won't admit it for fear of appearing uncool
12:36:11 <copumpkin> benmachine: U R SO UNCOOL
12:36:12 <gwern> crybaby! nya nya nya boo boo
12:36:15 <Alpounet> ezyang, your post about comonads has been downvoted ?
12:36:27 <benmachine> copumpkin: :(!
12:36:30 <gwern> benmachine: that't it. you're officially *un*invited from my birthday
12:36:39 <ezyang> Alpounet: 'parently so
12:36:49 <ezyang> I think there's a bigger blog market for "FP for imperative programmers"
12:36:52 <benmachine> gwern: well fine I didn't want to come anyway!!
12:36:59 * benmachine cries
12:37:00 <gwern> more cake for the rest of us!
12:37:04 <Dementati> So I was like 'who are all these people?', but then I realize this isn't one of my regular channels.
12:37:06 <Nebasuke> hmm, is there any package that can generate random numbers based on normal distributions that works on windows?
12:37:11 <misk20> in the mehod call  "function exp1 exp1 >> return TBool" what does the last part "return TBool" mean ?
12:37:28 <misk20> i mean what does >> do ?
12:37:31 <ezyang> Nebasuke: Does Data.Random.Distribution.Normal not work?
12:37:42 <benmachine> what >> does depends on which monad you're using
12:37:58 <ezyang> misk20: In IO, it runs the left side, discards the result, runs the right side, and returns that
12:38:00 <misk20> do monad
12:38:12 <benmachine> every monad has do :)
12:38:12 <copumpkin> do isn't a monad :)
12:38:15 * ezyang doesn't think do is a monad? That would be very confusing. 
12:38:34 <copumpkin> misk20: it passes effects along but ignores the values generated by them
12:38:45 <Nebasuke> eyzang: sadly enough no
12:38:50 <Nebasuke> Loading package erf-1.0.0.0 ... linking ... ghc.exe: unable to load package `erf
12:38:50 <Nebasuke> -1.0.0.0'
12:39:19 <Nebasuke> because of ghc.exe: C:\Program Files\Haskell\erf-1.0.0.0\ghc-6.10.4\HSerf-1.0.0.0.o: unknown symbol `_erfc'
12:39:26 <misk20> so it means if id function is successful it returns Book type ?
12:39:29 <ezyang> ah yeah, erf uses the FFI
12:40:32 <ezyang> Relevant thread: http://markmail.org/message/osjic6ezanbsuoow
12:40:44 <Cascade_> http://www.getmepagerank.com/ - new programming forum - Join!
12:40:49 <copumpkin> lol
12:40:59 <copumpkin> that wasn't obvious
12:41:57 <benmachine> misk20: what it means depends on what the type of the functions involved are
12:42:22 <Nebasuke> eyzang: yeah I saw the thread before, but no real solution for me at least
12:42:52 * ezyang goes erf erf 
12:43:04 <ezyang> Yup, doesn't look like it.
12:43:15 <ezyang> You could be evil and hack up a version of erf in pure Haskell
12:43:22 <MissPiggy> erf??
12:43:24 * ezyang recently fixed a compile bug in a package he wanted to use... 
12:43:34 <ezyang> MissPiggy: Error Function
12:43:48 <benmachine> it's the integral of something or other, isn't it?
12:43:57 <ezyang> yup
12:44:06 <benmachine> (that narrows it right down, then)
12:57:04 <MaciejP> Why can't I use type synonyms as monad in ReaderT?
12:57:40 <aavogt> you have to enable appropriate ghc extensions
12:57:47 <copumpkin> because a type synonym isn't its own entity
12:58:08 <copumpkin> you can turn it on but unless your synonym is for something that already "distinct" enough, it won't help
12:58:09 <aavogt> something involving relaxed type synonym ....
12:58:40 <MaciejP> So I have to wrap a newtype around?
12:58:50 <copumpkin> TypeSynonymInstances is probably what you want, but it may lead to OverlappingInstances being necessary, depending on what you're trying to do
13:03:09 <gwern> anyone know whether there are any 'find' analogues?
13:03:19 <ezyang> analogue?
13:03:26 <Alpounet> how analogous to find ?
13:03:27 <gwern> ezyang: yes
13:03:43 <gwern> Alpounet: up to listing everything below a directory, would be good enough
13:03:57 <gwern> I can do any fancy filtering, I think
13:03:59 <Alpounet> oh, ok
13:04:05 <gwern> just need the tree
13:04:26 <gwern> I'm looking at directory-tree, but I don't think it does recursion
13:04:34 <copumpkin> @djinn Not (Either p q) -> (Not p, Not q)
13:04:34 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
13:04:42 <aavogt> is there some way to make a typeclass that's a derivative of another that adds more fundeps?
13:04:42 <Alpounet> gwern, the code in RWH does
13:04:53 <copumpkin> @djinn Not (p, q) -> Either (Not p) (Not q)
13:04:53 <lambdabot> -- f cannot be realized.
13:04:53 <gwern> Alpounet: is that site even up?
13:04:54 <copumpkin> :(
13:04:57 <copumpkin> isn't that sad?
13:05:08 <aavogt> as in I have:   C a b | a -> b where f :: a -> b
13:05:13 <lispy> copumpkin: cute
13:05:24 <copumpkin> sad! :(
13:05:24 <Alpounet> gwern, http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html
13:05:28 * copumpkin weeps
13:05:40 <aavogt> and I want to deal with a subset of f's that also have inverses (for the purposes of type inference)
13:05:42 <Alpounet> there are ready-to-use functions for getting a tree
13:05:51 <gwern> Alpounet: if it's an exercise in rwh, then surely there's a maintained library
13:05:55 <lispy> gwern: what are you working on that you need a haskell version of find?
13:05:57 <Alpounet> and even a predicate DSL
13:06:26 <Alpounet> @hoogle RecursiveContent
13:06:26 <lambdabot> No results found
13:06:27 <gwern> lispy: Ima gonna open everything on my hard drive, find anything that looks like a URL, and archive them in webcitation.org!
13:06:44 <lispy> gwern: Wow
13:06:49 <aavogt> when I do   class C' a b | b -> a where f2 :: a -> b; instance C a b => C' a b where f2 = f, ghc seems to simplify my code
13:06:51 <gwern> genius, I know
13:06:59 <gwern> hard to believe no one ever wanted to do that before
13:06:59 <aavogt> *simplify the inferred type constraints
13:07:08 <lispy> gwern: :)
13:07:12 <luite> is vector supposed to completely replace uvector eventually, or does uvector still have some advantages for specific applications?
13:07:17 <gwern> lispy: but genius often consists of doing the obvious which no one has tried before
13:07:21 <gwern> luite: the former, iirc
13:07:27 <copumpkin> luite: it's supposed to completely replace it
13:07:32 <aavogt> such that my functions now use C, which doesn't let you infer a given b
13:07:37 <lispy> luite: replace; but currently uvector has the uvector-algorithms package
13:07:43 <aavogt> in spite of using f2
13:07:51 <copumpkin> lispy: I think dolio's already got a version working with vector, but I'm not sure he's put it up yet
13:07:58 <copumpkin> not sure if the package will get renamed
13:08:05 <aavogt> is the only way to accomplish my goal to duplicate the implementation of C?
13:08:18 <dolio> It's not on hackage. It's on my code.haskell.org site.
13:08:23 <copumpkin> ah
13:08:29 <lispy> dolio: hey cool
13:08:35 <copumpkin> dolio: will you be starting a new package called vector-algorithms?
13:08:41 <copumpkin> vector-sortalgorithms? :P
13:08:42 <ski> @djinn Not (p, q) -> Not (Not (Either (Not p) (Not q)))
13:08:42 <lambdabot> f a b = void (b (Right (\ c -> void (b (Left (\ d -> a (d, c)))))))
13:08:48 <dolio> Yes, it's already named vector-algorithms.
13:08:55 <copumpkin> oh cool
13:08:59 <dolio> And the modules have moved around to match the vector naming scheme.
13:09:03 <copumpkin> ski: nice
13:09:11 <MaciejP> What is Not?
13:09:18 <copumpkin> MacCoaster: a -> Void
13:09:23 <copumpkin> MaciejP I mean
13:09:23 <lispy> ?djinn-src Not
13:09:23 <ski>   type Not a = a -> Void
13:09:23 <lambdabot> Unknown command, try @list
13:09:38 <ski> lispy : `@djinn-env'
13:09:54 <lispy> ski: ah, thanks
13:09:56 <copumpkin> MaciejP: if you can prove false with a statement, that statement is probably wrong :P
13:09:58 <benmachine> @djinn-src void
13:09:59 <lambdabot> Unknown command, try @list
13:10:04 <benmachine> oh
13:10:08 <benmachine> @djinn-env void
13:10:08 <lambdabot> data () = ()
13:10:08 <lambdabot> data Either a b = Left a | Right b
13:10:08 <lambdabot> data Maybe a = Nothing | Just a
13:10:08 <lambdabot> data Bool = False | True
13:10:08 <lambdabot> data Void
13:10:10 <lambdabot> type Not x = x -> Void
13:10:12 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
13:10:16 <benmachine> erk
13:10:16 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:10:18 <lambdabot> class Bar t a where bar :: a -> t a
13:10:20 <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
13:10:20 <copumpkin> erk indeed
13:10:35 <lispy> wow
13:10:40 <benmachine> still didn't tell me what void was :P
13:10:42 <copumpkin> I like Bar
13:10:51 <Alpounet> haha
13:11:00 <ski> benmachine : `void :: Void -> a; void v = case v of {}'
13:11:11 <benmachine> ski: oh
13:11:15 <benmachine> erm.
13:11:22 <benmachine> what is the point? :P
13:11:23 <ski> copumpkin : that's a leftover from a test this morning ..
13:11:26 <copumpkin> ah
13:11:37 <copumpkin> benmachine: if I have a proof of false, I can get anything at all
13:11:40 <copumpkin> the world collapses
13:11:43 <ski> benmachine : `void' : `Void' :: `either' : `Either'
13:11:46 <ski> @type either
13:11:47 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:12:04 <copumpkin> http://en.wikipedia.org/wiki/Principle_of_explosion
13:12:10 <benmachine> copumpkin: so I've heard
13:12:11 <ski> `void' is the fold/catamorphism for `Void'
13:13:51 <ski> in both `void' and `either', if you can map each case to the result type, then you can map the whole to the result type
13:13:58 <ski> in `either', there's two cases
13:14:04 <ski> in `void', there's zero cases
13:14:17 <lispy> See the most recent xkcd for uses of Void
13:15:11 <Heffalump> lispy: not the most recent any more :-)
13:15:20 <lispy> oh
13:15:43 <lispy> disambiguation: http://xkcd.com/704/
13:16:00 <copumpkin> lispy: will you ever turn into haskelly?
13:16:26 <ski> mayhaps `liskelly'
13:16:26 <lispy> copumpkin: If I could just get Data.Dynamic to catch on
13:17:02 <mreh> > replicateM 3 [True, False]
13:17:03 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
13:17:08 <copumpkin> :)
13:17:21 <copumpkin> mreh: replicateM' ftw
13:17:36 <mreh> copumpkin: i'm trying to make it work in my head first
13:17:37 <copumpkin> I wonder if we could propose changing the order of operations in sequence
13:17:49 <copumpkin> would such a proposal catch on? does it have any downsides?
13:17:56 <copumpkin> I guess it does, eh
13:18:05 <mreh> copumpkin: it's no slower is it?
13:18:14 <mreh> just more stack space needed
13:18:16 <lispy> ?src sequence
13:18:16 <lambdabot> sequence []     = return []
13:18:16 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:18:16 <lambdabot> --OR
13:18:16 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:18:46 <Saizan> recurse first?
13:18:53 <copumpkin> it'd do things backwards for many monads
13:18:55 <copumpkin> sadly
13:19:38 <ski> use the opposite applicative ?
13:19:39 <mreh> > [True, False] >>= [True, False]
13:19:40 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> [b]'
13:19:40 <lambdabot>         against inferre...
13:19:51 <ski> (maybe it was called "dual", not sure)
13:20:07 <copumpkin> I didn't think there was one
13:20:14 <copumpkin> mreh: http://snapplr.com/7x15 this is a downside, I guess :)
13:20:18 <copumpkin> it's a pity
13:21:32 <Saizan> what's the advantage of recursing first?
13:21:38 <ski> hm, right, `Dual' was for `Monoid'
13:21:43 <copumpkin> ski: how would you even write one? I can't see how you'd take one definition of an applicative and flip it, given the types
13:21:57 <copumpkin> Saizan: being able to garbage collect sooner on list generation, I think
13:22:14 <copumpkin> > replicateM 5 [1..5]
13:22:15 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,2,1],[1...
13:22:15 <benmachine> copumpkin: there's a permutations isn't there, which is basically sequence in the list monad?
13:22:27 <mreh> I don't understand...
13:22:35 <mreh> @src replicateM
13:22:35 <lambdabot> replicateM n x = sequence (replicate n x)
13:22:37 <copumpkin> benmachine: yeah, but what if you want to do some other monadic operations like that
13:22:39 <benmachine> copumpkin: so we could fix it for that without messing with the general
13:22:45 <mreh> replicate 3 [True, False]
13:22:48 <mreh> > replicate 3 [True, False]
13:22:49 <lambdabot>   [[True,False],[True,False],[True,False]]
13:22:50 <mreh> yes
13:23:20 <copumpkin> mreh: think of replicateM as picking all possible combinations out of those three lists
13:23:24 <ski>   Opposite iab <*> Opposite ia = Opposite ((flip ($)) <$> ia <*> iab)  -- copumpkin ?
13:23:40 <ski> @type \iab ia -> (flip ($)) <$> ia <*> iab
13:23:41 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b) -> f a -> f b
13:23:47 <copumpkin> ski: hmm, I see :)
13:23:48 <mreh> copumpkin: I want to grasp it intuitively, I can see what it's doing :)
13:24:13 <ezyang> mreh: I haven't been following the conversation closely, but I get intuition from lots of examples, myself
13:24:54 <copumpkin> mreh: do you have intuition for list monad in general?
13:25:11 <mreh> > concatMap (const . return $ []) [True, False]
13:25:12 <lambdabot>   [[],[]]
13:25:17 <mreh> copumpkin: yes
13:25:20 <mreh> in general
13:25:50 <mreh> this specific idiom is outside of my experience
13:26:14 <mreh> I think I geddit
13:26:32 <ski> > sequence ["a","bc","def"]
13:26:33 <ski> > sequenceA' ["a","bc","def"]
13:26:33 <lambdabot>   ["abd","abe","abf","acd","ace","acf"]
13:26:34 <lambdabot>   ["abd","acd","abe","ace","abf","acf"]
13:26:38 <ski> cf.
13:27:04 <mreh> sequenceA = Arrow sequence?
13:27:09 <mreh> @src sequenceA
13:27:10 <lambdabot> Source not found. stty: unknown mode: doofus
13:27:10 <copumpkin> applicative
13:27:11 <mreh> @src sequenceA'
13:27:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:27:34 <copumpkin> you can already sequence with the power of applicative :)
13:27:49 <copumpkin> no point to pulling out the big monadic guns
13:28:08 <mreh> I have no experience with applicative
13:28:20 <mreh> isn't it just fmap?
13:28:22 <benmachine> to the typeclassopedia with you!
13:28:23 <copumpkin> nope
13:28:24 <benmachine> fmap and ap
13:28:28 <jmcarthur> and pure
13:28:30 <benmachine> that is, <$> and <*>
13:28:33 <benmachine> and pure yes
13:29:02 <ski> > replicateM 5 [1..5]
13:29:03 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,1,4],[1,1,1,1,5],[1,1,1,2,1],[1...
13:29:06 <ski> > replicateA' 5 [1..5]
13:29:07 <lambdabot>   [[1,1,1,1,1],[2,1,1,1,1],[3,1,1,1,1],[4,1,1,1,1],[5,1,1,1,1],[1,2,1,1,1],[2...
13:29:20 <mreh> sexy
13:29:57 <mreh> do we have a Haskell joke book? published AWESOME one-liners
13:30:01 <ski> @type Data.Traversable.sequenceA
13:30:02 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
13:30:17 <ski> @type sequenceA'  -- uses the reverse ordering
13:30:18 <lambdabot> forall (i :: * -> *) a. (Applicative i) => [i a] -> i [a]
13:30:26 <ski> @type replicateM
13:30:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:30:33 <ski> @type replicateA'  -- also uses reverse ordering
13:30:34 <lambdabot> forall n (i :: * -> *) a. (Integral n, Applicative i) => n -> i a -> i [a]
13:30:42 <ski> mreh : ^
13:30:48 <mreh> replicateM for other monads now
13:31:38 <mreh> heh, Maybe is pretty pointless
13:31:46 <ski> is not !
13:31:57 <mreh> > replicateM 4 (Just 4)
13:31:58 <lambdabot>   Just [4,4,4,4]
13:32:01 <ski> @unpl Nothing
13:32:01 <lambdabot> Nothing
13:32:02 <mreh> woah
13:32:13 <mreh> I wasn't expecting that
13:32:22 <ski> (`Nothing' is a point in `Maybe a')
13:32:51 <mreh> is the Event in Yampa a monad
13:32:53 <mreh> that would be nice
13:33:12 <ski> someone said `Event' is `Maybe'
13:33:17 <mreh> twas me
13:33:26 <jmcarthur> i don't know about Event in Yampa. it is a Monad in Reactive, though
13:33:29 <mreh> they aren't the same, just homo-thingy
13:33:37 <jmcarthur> but i think it *shouldn't* be a monad in Reactive
13:33:41 <ski> .. isomorphic ?
13:33:47 <mreh> isomorphic
13:34:02 <mreh> Event a -> Just a, NoEvent -> Nothing
13:34:09 <mreh> QED
13:34:15 <conal> jmcarthur: though imperfectly, and not compellingly (no TCM)
13:34:16 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:34:25 <enthymene> mreh: Brilliant!
13:34:30 <jmcarthur> conal: yeah :(
13:34:34 <mreh> A+
13:35:00 <conal> jmcarthur: for me, the TCM issue is deeper than the Monad issue
13:35:19 <jmcarthur> conal: i think they are related, though
13:35:26 * mreh sits under the bodi tree and meditates on the thing they call "Monad"
13:35:30 <jmcarthur> conal: if it was a TCM it would presumably be a valid Monad
13:35:30 <conal> jmcarthur: so do i
13:35:32 <enthymene> that's like what's it called, somebody's law.  If you can write a program in in terms of type T and type T', and they do the same thing (and don't object that it's unprovable in general)...
13:35:33 <enthymene> something
13:35:46 <enthymene> grr
13:35:48 <conal> jmcarthur: yeah.  class laws are implied by TCM.
13:35:49 * enthymene googles
13:36:21 <chrisdone> Cale: bump
13:36:23 <MissPiggy> enthymene, leibniz characterization of equality?
13:36:38 <mreh> > replicateM 4 (Just 4)
13:36:40 <lambdabot>   Just [4,4,4,4]
13:36:52 <mreh> I just did that
13:37:22 <mreh> leibniz didn't know much about metaphysics
13:38:06 <enthymene> MissPiggy: I don't think so, I'd remember if it were the creator of the best calculus notation IN HISTORY
13:38:07 <enthymene> :p
13:38:25 <conal> wow -- it's easier than i expected to close the wrong conversation in adium.
13:38:29 <enthymene> I could have sworn I'd seen it on the Content Creation wiki, but I can't find it.
13:38:32 <mreh> has anyone shed any light on the apparent simultaneous invention of calculus?
13:39:55 <mreh> conal: can you shed some light on Yampa? People seem to be hesitant about it, especially FRP programmers
13:39:57 <enthymene> other than that Newton called Liebiniz gay?
13:40:07 <mreh> banter
13:40:09 <enthymene> like all hetero virgins; obsessed with the relative gayness of things.
13:40:33 <conal> mreh: perhaps i can.  what would you like to know?
13:40:48 <syntaxfree> there was this totally hot new girl on the elevator.
13:41:24 <mreh> conal: is it a bad way to write reactive programs? It seems so very neat in how it divides to the conceptual notions up, making my conceptual stack a bit smaller
13:41:34 <mreh> FRP programmers grumble that it's too easy
13:41:42 <jmcarthur> "too easy"  haha
13:41:45 <syntaxfree> what did I just say?
13:42:03 <mreh> there's a hot girl in my FP class, I couldn't believe it
13:42:10 <mreh> genuinely hot
13:42:22 <enthymene> was she a math major?
13:42:22 <silver> grats?
13:42:25 <mreh> my question might seem incoherent
13:42:34 <mreh> CS major
13:42:37 <syntaxfree> someone said "hetero virgins". I'm in a long-term relationship, and I was about to say one of you guys can have her.
13:42:40 <enthymene> :< I hate you now
13:42:42 <nagnatron> pix?
13:42:53 <silver> syntaxfree, wait what?
13:43:02 <enthymene> hetero virgins, as in Newton
13:43:08 <enthymene> he was a virgin until the day he died
13:43:10 <mreh> i know, hot girl interested in FP... there must be some catch
13:43:11 <conal> mreh: i haven't programmed with yampa.  you'd probably get more helpful info from folks here who have.
13:43:17 <mauke> since when is Newton hetero?
13:43:21 <gwern> mreh: it's a trap!
13:43:26 <ezyang> What do you call it when two electrical engineers go out on a date? Hetero-dining!
13:43:29 <enthymene> mreh: not only interested in FP, but a CS major
13:43:32 <enthymene> I mean what are the odds
13:43:39 <syntaxfree> wasn't there a story about Newton and unrequited love?
13:43:39 <enthymene> ezyang: oh man
13:43:40 <MissPiggy> 00%
13:43:50 <mreh> conal: okay. i'll announce Haskelloids when it's finished, just have to work out how to do the parallel switching
13:43:51 * enthymene givez ezyang a bronze bust of Issac Asimov
13:44:01 <benmachine>  < enthymene> he was a virgin until the day he died <-- don't like the sound of that "until"
13:44:03 <enthymene> that was a truly righteous pun
13:44:03 <syntaxfree> I look at people like Newton and Mozart and feel like a total loser.
13:44:09 <mreh> "I'm getting a 33.3 recurring"
13:44:10 <enthymene> benmachine: well you never know
13:44:14 <lament> once newton was sitting under a tree when unrequited love hit him on the head
13:44:17 <conal> mreh: is Haskelloids a yampa app?
13:44:17 <enthymene> if he went to muslim heaven
13:44:32 <mreh> conal: if by app you mean "game" yes
13:44:36 <syntaxfree> there was this researcher in TED saying that theoretically brain dead people whose heart is still beating can have orgasms.
13:44:38 <lament> benmachine: famous last words - "You're sure I'm not too old for this?"
13:44:48 <enthymene> he'd probably just teach the caclulus of variations to his 72 virgins
13:44:48 <silver> :-)
13:44:59 <MissPiggy> did newton know caclulus of variations?
13:45:01 <enthymene> syntaxfree: 10 things you didnt' know about sex, or somethign right?
13:45:04 <enthymene> he invented it MissPiggy
13:45:06 <syntaxfree> wait up, Newton came up with the calculus of variations?
13:45:08 <MissPiggy> wow
13:45:11 <enthymene> yeah, I think so
13:45:13 <MissPiggy> cool tell me more!!
13:45:14 <enthymene> over night, the story goes
13:45:48 <syntaxfree> You do know that differential calculus and the calculus of variations are different subjects, right?
13:45:55 <syntaxfree> fluxions != calculus of variations.
13:46:00 <MisterN> so newton is almost as clever as cantor!
13:46:02 <enthymene> http://www.google.com/url?sa=t&source=web&ct=res&cd=1&ved=0CAYQFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.90.4445%26rep%3Drep1%26type%3Dpdf&ei=3fqCS5O-F5PgswOp-MSqDw&usg=AFQjCNHuyaesKQHocd-HyOTmY2-grqjB7w&sig2=PBOU5gQUeEebUfFWiLxCvw section 2
13:46:04 <enthymene> umm
13:46:05 <MissPiggy> what the hell is fluxions
13:46:07 <enthymene> lemme find a better one
13:46:11 <enthymene> derivatives
13:46:15 <enthymene> he called them fluxions
13:46:22 <enthymene> leibniz' calculus was SOOO much better
13:46:22 <syntaxfree> I thought the brachistochrone problem remained open until well into the late 1700s
13:46:47 <mreh> derivatives of derivatives?
13:46:50 <enthymene> http://www.todayinsci.com/1/1_26.htm bottom link
13:46:53 <enthymene> er, bottom section
13:47:10 <enthymene> this is the kind of thing you learn while listening to The Skeptic's Guide to the Universe :3
13:47:52 * lispy just discovered that the Takusen library on hackage means "oracle" in Japanese
13:48:02 <syntaxfree> apparently in late life Isaac Newton was a fundie xtian.
13:48:14 <syntaxfree> wrote a number of tracts and whatnot.
13:48:25 <enthymene> yeah
13:48:35 <enthymene> see also: Linus Pauling
13:48:38 <lament> probably not a muslim then.
13:48:41 <lispy> Back then professors all worked for the church
13:49:03 <syntaxfree> true story: Isaac Newton was made master of the Mint, something like a central banker, and screwed up.
13:49:15 <enthymene> anyway syntaxfree, you have problems with your girlfriend?
13:49:35 <jmcarthur> -blah please
13:49:45 <syntaxfree> enthymene: not at all, not at all. I'm just occasionally attracted to women, on a superficial level. It's fine.
13:49:55 <MissPiggy> haha
13:50:00 <enthymene> :^3 I see
13:50:01 <syntaxfree> anyway, Newton set the relative price of silver respective to gold wrong,
13:50:22 <syntaxfree> so silver currency disappeared from circulation.
13:50:45 <syntaxfree> thus ending the bimetallic monetary system in the Kingdom.
13:50:49 <enthymene> bluteflute just judo'd his IRC client O.o
13:51:20 <syntaxfree> I agree with the push for -blah, though.
13:52:08 <lispy> Oh hmm...Takusen forgets to export some types from its modules
13:54:27 <Veinor> I'm taking a basic computer science course, and right now we're learning about state machines!
13:54:40 <chrisdone> state machines are excellent!
13:55:16 <Veinor> the basic function that you define for one is getNextValue(state, input) which returns (state, output)
13:55:20 <copumpkin> Veinor: Cofree ((->) r)!
13:55:36 <MissPiggy> Veinor it's a monad lol!
13:55:43 <ezyang> no...
13:55:44 <copumpkin> it's a comonad!
13:55:44 <Veinor> copumpkin: ow
13:55:46 <MissPiggy> @src State
13:55:46 <lambdabot> Source not found. That's something I cannot allow to happen.
13:55:48 <ezyang> it's a comonad
13:55:52 <domor> @quote comonad
13:55:52 <lambdabot> roconnor says: I can't wait for the Density Comonad chapter of "learn you a haskell"
13:55:53 <Botje> state machines will take over the world!
13:55:56 <MissPiggy> @unmtl State
13:55:57 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
13:55:57 <jmcarthur> it's a cocomonad!
13:56:06 <copumpkin> it's a moore machine!
13:56:13 <Veinor> well, you can obviously write extract for a state machine
13:56:26 <domor> funny coincidence, but I was about to ask if there was a recommended explanation of comonads somewhere?
13:56:35 <jmcarthur> it's the adjunction formed by reader and coreader!
13:56:49 <Veinor> ANYWAY
13:56:57 <copumpkin> now jmcarthur is just showing off his mathpenis
13:57:09 <jmcarthur> copumpkin: proficiency with category-extras, perhaps
13:57:18 <copumpkin> as I said, mathpenis
13:57:24 <jmcarthur> *sigh*
13:57:29 <ezyang> I attempted to do an explanation in my latest blog post
13:57:33 <copumpkin> maff
13:57:34 <Veinor> if I wanted to do this in Haskell for the hell of it, should I just use data StateMachine s i o = StateMachine s ((s,i) -> (s,o))?
13:57:38 <Veinor> or something
13:57:46 <copumpkin> Veinor: or just Cofree ((->) a)
13:57:51 <jmcarthur> State s a
13:57:57 <ezyang> But I don't know if it was effective or not
13:58:14 <Veinor> jmcarthur: so what do s and a represent?
13:58:29 <jmcarthur> Veinor: s is the state type, a is the result type
13:58:38 <Veinor> but what about the input type?
13:58:47 <copumpkin> newtype Moore a b = Moore { runMoore :: (b, a -> Moore a b) } -- as edwardk would put it
13:59:02 <domor> @type extract
13:59:04 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
13:59:07 <jmcarthur> Veinor: the input type exists when you have something of type a -> State s b
13:59:14 <jmcarthur> Veinor: the input type would be a, there
13:59:23 <dolio> copumpkin: How do you remember which is Mealy and which is Moore?
13:59:26 <ski>   extract :: Comonad w => w a -> a
13:59:32 <jmcarthur> Veinor: alternatively, you could have Kleisli (State s) a b
13:59:36 <jmcarthur> Veinor: then all the types are in one sig
13:59:46 <copumpkin> dolio: one has state on nodes, the other on edges, but I don't have mnemonic for which is which
13:59:50 <copumpkin> oh yes I do
13:59:58 <jmcarthur> Veinor: but IMO the Monad interface is nicer than the Arrow interface
14:00:07 <Veinor> jmcarthur: well I don't think you can define a -> State s b
14:00:14 <copumpkin> well, it doesn't really count as a mnemonic
14:00:23 <jmcarthur> Veinor: that's how you use the State monad, though
14:00:36 <jmcarthur> Veinor: it's just the type of a function in the State monad
14:00:36 <Veinor> because what state the input sends you to depends on what state the SM is in
14:00:39 <Veinor> ahh
14:01:01 <byorgey> @tell ivanm no, in fact I first looked into extending the multiset package, but then realized it was unsuitable since I didn't want to impose Eq and Ord constraints.
14:01:01 <lambdabot> Consider it noted.
14:01:09 <dolio> copumpkin: So, you have one, but you're not going to say way it is?
14:01:15 <Veinor> I mean, you need to know your current state to determine what state the input sends you to
14:01:33 <copumpkin> dolio: well, I reconsidered calling it a mnemonic, but I just memorized that Moore is cofree and can figure out the rest from there
14:01:34 <jmcarthur> Veinor: right, that was given by State
14:01:41 <jmcarthur> @unmtl State s a
14:01:41 <lambdabot> s -> (a, s)
14:01:42 <byorgey> @tell ivanm and really it is quite different, I am using multisets not as data structures but just as combinatorial structures.  if the distinction makes sense.
14:01:42 <lambdabot> Consider it noted.
14:01:44 <dolio> Ah.
14:02:05 <jmcarthur> Veinor: a -> State s b  is the same as  a -> s -> (s, b)
14:02:06 <Heffalump> does anyone know where the xhtml darcs repo lives, if anywhere?
14:02:16 <Veinor> ahh.
14:02:16 <jmcarthur> Veinor: which is the same as (s, a) -> (s, b)
14:02:31 <copumpkin> dolio: did you see edwardk's origami.hs? he took something I was playing with and thoroughly categorized it
14:02:43 <Veinor> people that are not the same: edwardk, ezyang
14:02:51 <ezyang> it's true
14:02:56 <ezyang> edwardk is a lot smarter than I am
14:03:06 <Veinor> aww :(
14:03:07 <copumpkin> aw
14:03:10 <jmcarthur> aw
14:03:10 * Botje makes notes
14:03:16 <dolio> Did he go to sit in the rain?
14:03:23 <copumpkin> I think so
14:03:29 <Veinor> sad edward in snow
14:03:34 <Veinor> I'm sorry :(
14:03:35 <enthymene> bwah
14:03:43 <enthymene> oh man, megatokyo.  That takes me back.
14:03:46 <copumpkin> @get-ezyang
14:03:47 <lambdabot> Unknown command, try @list
14:04:08 <Veinor> I just know that one reference which I cannot erase from my mind
14:07:09 <enthymene> if you remember anything, remember the early strip where piro gets a coffee carafe in the face
14:07:43 <Heffalump> Igloo: do you plan to keep old-darcs.well-typed.com around indefinitely? The most recent version of xhtml I can find is there (and it corresponds to the latest hackage upload). Obviously it should move to community but I don't know if the maintainer is accurate since you were apparently the one to tag the most recent version.
14:08:37 <copumpkin> dolio: http://comonad.com/haskell/Origami.hs is the file I'm talking about
14:08:40 <copumpkin> it's pretty fun
14:09:44 <Veinor> I googled density monad, and this is the third result: http://www.google.com/url?sa=t&source=web&ct=res&cd=3&ved=0CBMQFjAC&url=http%3A%2F%2Fwww.learningradiology.com%2Farchives2009%2FCOW%2520374-Air%2520Crescent%2520Sign%2Faircrescentsigncorrect.htm&ei=ewCDS9-hOMiVtgf_2oHgBg&usg=AFQjCNHDBiBHaIElAA1X9_o6KZdD7m89gw&sig2=9ROG-HxXbotdzZIHXxFzHg
14:09:49 <Veinor> ... DAMN YOU GOOGLE URLS
14:09:55 <copumpkin> fail
14:09:55 <Veinor> http://www.learningradiology.com/archives2009/COW%20374-Air%20Crescent%20Sign/aircrescentsigncorrect.htm
14:10:10 <copumpkin> win
14:11:38 <Igloo> Heffalump: That hostname just points to monk, which is about a day away from being turned off
14:11:47 <Heffalump> ah.
14:12:24 <Heffalump> I suspect there'll be a lot of other stuff like that...
14:15:11 <copumpkin> yay, ezyang is back!
14:15:19 <copumpkin> my @get-ezyang command worked
14:15:30 * Heffalump does a darcs get of the entire packages directory
14:17:43 <MissPiggy> @get-ezyang
14:17:43 <lambdabot> Unknown command, try @list
14:18:51 * copumpkin hacks lambdabot to enable the @get-ezyang command
14:18:57 <copumpkin> @get-ezyang
14:18:57 <lambdabot> Unknown command, try @list
14:18:58 <lambdabot> ezyang!!!!!
14:20:42 <MissPiggy> @get-aopfuhaofuphnafph
14:20:43 <lambdabot> Unknown command, try @list
14:21:17 <domor> we conjure the spirits of the lambdabot with our spells
14:22:08 <enthymene> ^^ yay, a SICP reference
14:23:02 <ezyang> wat
14:23:12 <enthymene> okay, so in Hudak's book, I can do the left-handedness test of whether a point is inside a polygon with "map (isLeftOf p) (zip vs (tail vs ++ [head vs]))"
14:23:42 <enthymene> but I can't seem to do it with "(map (isLeftOf p) . zip) vs (tail vs ++ [head vs])"
14:23:51 <MissPiggy> Pollack: structural subtyping depends on accident of
14:23:51 <MissPiggy> structure, and does not suppor t natural mathematical
14:23:51 <MissPiggy> denitions
14:23:53 <MissPiggy> good quote ^
14:24:22 <enthymene> ah, ezyang, you're back
14:25:11 <sinelaw> conal, do you have an opinion about time shifting?
14:25:34 <Veinor>  get-ezyang?
14:25:41 <Veinor> that's... I don't want to know what
14:25:53 <conal> sinelaw: i don't know what you're asking.
14:25:54 <domor> enthymene: there's even a soundtrack! > http://www.tindeck.com/listen/stwv
14:25:57 <enthymene> herm, I guess I should be doing "map ((isLeftOf p) . (\ x y -> (x,y))) vs (tail vs ++ [head vs])"
14:26:05 <cygnus> Is anyone else aware of any known problems with using named chunks in haddock (i.e., "$foo") with LHS source?
14:26:15 <Veinor> enthymene: that lambda is better known as (,)
14:26:17 <enthymene> conal, you mean like, VCRs?
14:26:19 <Veinor> > (,) 2 3
14:26:20 <lambdabot>   (2,3)
14:26:22 <enthymene> oh
14:26:23 <enthymene> coo
14:26:27 <Veinor> :D
14:26:30 <sinelaw> conal, time shift by c of f at t is: f(t - c)
14:26:37 <enthymene> :3 that'll simplify this expression prettily
14:26:53 <conal> sinelaw: okay.  what about it?
14:27:06 <sinelaw> conal, and i'm wondering how/whether that should be in a proper model that disallows arbitrary access in time
14:27:17 <sinelaw> conal, because is seems to requires infinite memory
14:27:34 <conal> sinelaw: ah.
14:28:01 <doserj> enthymene: zipWith (uncurry (isLeftOf p) vs (tail vs ++ [head vs])
14:28:23 <sinelaw> conal, considering WWRD, it seems that in reality time shifting can happen because reality is not only time - it's also space
14:28:29 <conal> sinelaw: i wouldn't have time-shifting as such.  but a restricted & maybe inexact version might be simulated.
14:28:52 <sinelaw> conal, so maybe time shifting is really sending stuff somewhere and back, which wastes time
14:28:56 <conal> sinelaw: finite speed of light?
14:29:05 <doserj> enthymene, or: zipWith (uncurry (isLeftOf p)) vs (tail (cycle vs))
14:29:30 <sinelaw> conal, yes, finite speed
14:30:36 <conal> sinelaw: i'd focus on transmission of info in a medium/environment rather than time shifting.
14:30:56 <conal> sinelaw: i've had a hunch for a long time that there's a missing half to frp -- the environment.
14:31:00 <doserj> enthymene: erm, s/uncurry/curry/, but if you define isLeftOf the right way, you won't need that anyways...
14:31:06 <conal> sinelaw: sort of like anti-objects are to OO
14:31:12 <sinelaw> conal, i was just thinking what is "space" in frp
14:31:28 <sinelaw> what do you mean by environment?
14:31:44 <enthymene> yeah, "isLeftOf :: Ray -> Coordinate -> Bool" as per Hudak's definition
14:31:56 <conal> sinelaw: "input"
14:32:03 <enthymene> where Coordinate = (Float,Float) and Ray = (Coordinate,Coordinate)
14:32:07 <conal> sinelaw: relative to its perceivert
14:32:13 <conal> perceivert
14:32:18 <conal> perceiver
14:32:20 <conal> there!
14:32:23 <sinelaw> :) ok
14:32:24 <doserj> enthymene: then 'zipWith (isLeftOf p)' should do what you want
14:33:26 <enthymene> still doesn't, apparently
14:33:40 <enthymene> Couldn't match expected type `b -> c' against inferred type `Bool'
14:34:06 <sinelaw> conal,  i was thinking erroneously that time shifting is required if we want to model linear time-invariant systems, because convolution requires it
14:34:17 <mreh> anyone doing Yampa who can explain parallel switching to me?!
14:34:31 <damd> anyone doing marijuana???
14:34:43 <mreh> this whole "teaching yourself" is pretty crappy
14:34:51 <sinelaw> conal, but the time shifting in convolution can be done on the impulse response, which is supposedly known in advance if you're simulating via convolutions
14:34:54 <enthymene> I was hoping that (isLeftOf p) . zip would work, since the zip of two [Coordinate]s is [Ray] and (isLeftOf p) is Coordinate -> Bool
14:35:26 <sinelaw> mreh, no, Yampa's documentation is lacking (a lot)
14:35:32 <enthymene> so a Ray -> Bool dotted with a Coordinate -> Coordinate -> Ray should map right.
14:35:33 <enthymene> :/
14:35:39 <mreh> sinelaw: you can say that again
14:35:46 <MissPiggy> enthymene what do you mean dotted?
14:35:52 <enthymene> composition
14:35:56 <enthymene> f . g
14:35:57 <sinelaw> mreh, did you look in the code? there's tons of comments there that may be useful
14:36:01 <MissPiggy> oh
14:36:02 <sinelaw> Yampa's code
14:36:28 <mreh> sinelaw: yeah, I had a real hard go, apart from various papers, there's not a lot in the way of examples
14:36:42 <enthymene> I dunno, I guess because isLeftOf is unary and zip is binary
14:36:46 <sinelaw> mreh, yeah me too
14:36:59 <enthymene> er, (isLeftOf p) is unary ,I mean.
14:37:00 <sinelaw> mreh, if it helps you can look at my code, but i don't use switchers yet
14:37:08 <sinelaw> mreh, http://github.com/sinelaw/graphui
14:37:30 <sinelaw> conal, so environment = input? i'm not sure i understand what you mean there
14:37:40 <sinelaw> (or was it space = input)?
14:37:41 <Heffalump> Igloo: there seems to be an awful lot of stuff on monk that isn't obviously elsewhere. Have you checked whether the ghc-* repos are wanted?
14:38:15 <doserj> enthymene: then you need 'curry (isLeftOf p)', I guess
14:38:47 <doserj> (for the zipWith version)
14:39:03 <enthymene> why is that?
14:39:23 <conal> sinelaw: interactive behaviors in time & space have both input & output.  classic frp organizes output.  arrow frp adds input to the type, but doesn't explain/discipline how the components get their inputs.  reality does.
14:39:43 <doserj> enthymene: or sth like '(map (isLeftOf p).).zip)
14:39:56 <Igloo> Heffalump: I've sent e-mails to the lists and to the apparent repo owners, and SPJ also pinged people about the ghc-* repos a few months ago
14:40:30 <conal> sinelaw: btw, check out the antiobjects paper.
14:41:16 <sinelaw> conal, ok i will. the OOPSLA 2006 one?
14:41:31 <conal> sinelaw: yeah.
14:41:47 <mreh> someone released an FRP RPG today didn't they
14:42:05 <mreh> an FRPG
14:42:25 <sinelaw> mreh, DoW, uses elerea
14:42:39 <mreh> sinelaw: that was it
14:42:52 <mreh> is it a commercial success, or is it open source?
14:43:03 <sinelaw> mreh, open source, see hackage
14:43:24 <sinelaw> mreh, wait i'm not sure i'm talking about the right thing!
14:43:41 <sinelaw> because that thing is a rather simple game, not an RPG
14:43:49 <sizur> LIVE LONG #haskell!
14:44:24 <mreh> Dungeons of War
14:44:44 <mreh> my brain saw FRP and thought RPG
14:44:48 <ezyang> *Wor?
14:44:52 <mreh> stupid brain
14:45:06 * ezyang thinks it would be kind of neat to see a reimplementation of Nethack in Haskell 
14:45:17 <enthymene> hehe FRP = Functional Reactive Programming, not Fantasy Role-Playing?
14:45:22 <sinelaw> haha
14:45:32 <ezyang> "Live Action Reactive Programming"
14:45:35 <enthymene> hahhaa
14:45:37 <idnar> enthymene: those are basically the same, right? ;)
14:45:52 <enthymene> MMORPG -- Many Men Online, Role-Playing Girls
14:45:54 <sinelaw> conal, i'm trying to write something, but not sure when to stop
14:45:58 <MissPiggy> lol
14:46:01 <enthymene> sinelaw: is it "banana"?
14:46:03 <sinelaw> hehe
14:46:14 <mreh> this FyntaxSree guy is driving me nuts
14:46:16 <sinelaw> enthymene, what
14:46:27 <enthymene> the banana problem?
14:46:41 <enthymene> from a girl who told a newscaster that the knew how to spell "banana" but didn't know when to stop.
14:46:46 <fnord123> question regarding comonads. if Monads are a way of wrapping data and unwrapping it. then comonads are a way of binding operations to the data, like callbacks? e.g. instead of asking the IO Monad to get a string, instead we implement Copointed instance to look at the stream and Comonad instance to operate on the data. I'm trying to explain it to some C++ programmers. Monads I can explain by relating Maybe to boost::optional, but comon
14:46:48 <sinelaw> ah.
14:46:49 <ezyang> sinelaw: For me, these "body plans" are useful in that they let me encapsulate the core of some computation I want to do
14:46:51 <enthymene> it's a euphemism for an infinite loop
14:46:51 <sinelaw> sort of
14:47:07 <ezyang> sinelaw: I don't really buy that we should be looking for something that actually encodes reality
14:47:23 <ezyang> fnord123: Not... really
14:47:29 <sinelaw> ezyang, nor do i, physics gets complicated
14:47:40 <Saizan> fnord123: i don't really agree with the premise
14:47:41 <ezyang> fnord123: What you describe is more like a functor
14:47:47 <sinelaw> ezyang, but it's a good hint
14:48:00 <sinelaw> ezyang, if something you want to model does something you can't model
14:48:10 <Saizan> fnord123: maybe look at "The Dual of substitution is redecoration"
14:48:27 <mreh> cheers guys, see you later
14:48:32 <ezyang> fnord123: The insight I have is that you have some sort of stream, and there are many different ways to "view" the stream, each of which result in a different single value that can be combined to form another stream
14:48:48 <gwern> @hoogle (a,b,c) -> c
14:48:49 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
14:48:49 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
14:48:51 <ezyang> sinelaw: Sure.
14:49:17 <ezyang> Saizan: Ooh, now I have to go read that
14:49:42 <ezyang> fnord123: sigfpe has commented that this encodes a sort of locality in computation.
14:51:08 <fnord123> what does that mean. locality in computation
14:51:46 <ezyang> fnord123: The example offered is cellular automata. Any particular cell depends on the contents of its neighbors, but not further than that.
14:51:56 <ezyang> If a cell depended only on its previous value, you'd get a functor
14:52:06 <ezyang> If a cell could result in lots of cells, you'd have a Monad
14:52:30 <ezyang> this is, of course, taking a very structural approach to the matter
14:53:43 <ezyang> and there are more abstract instances of these typeclasses
14:53:57 <ezyang> which I don't understand, but that's another matter :-)
14:55:09 <Heffalump> Igloo: if anyone comes screaming for them later, I've got a mirror of everything but ghc-* now.
15:00:48 <DBAlex> Hey
15:00:51 <DBAlex> I think I found a GHC bug: http://pastebin.ca/1806159
15:00:57 <DBAlex> or, the servers version of GHC is old :P
15:01:35 <ezyang> 6.6 is ancient
15:01:38 <DBAlex> ok
15:01:49 <DBAlex> probably a bug thats been fixed?
15:02:32 <FauxFaux> Try it on a modern version and find out?
15:02:39 <DBAlex> Yeah
15:02:46 <ezyang> hard to say without Main
15:02:46 <DBAlex> ahh
15:02:51 <ezyang> might be a sparc thing
15:02:53 <FauxFaux> Or provide steps for us to try it.
15:02:54 <sizur> BONUS you on?
15:02:55 <DBAlex> forgot I had GHC installed on my laptop :)
15:03:54 <sizur> BONUS: in the functors chapter there's a bunch of lines looking like this: putStrLn "You said " ++ line' ++ " backwards!"
15:04:17 <DBAlex> Nope, works here
15:04:21 <sizur> maybe it should be: putStrLn $ "You said " ++ line' ++ " backwards!"
15:04:30 <DBAlex> Probably a spark thing
15:04:35 <DBAlex> *sparc
15:04:50 <DBAlex> and I can view my gametree
15:04:51 <DBAlex> yay :)
15:04:58 <DBAlex> Looks too small though
15:05:28 <sizur> on an unrelated note, we have getLn, why dont we have showLn :)
15:05:32 <sizur> i mean readLn
15:06:32 <Botje> showLn = flip shows "\n"
15:07:45 <sizur> yeah i know it's easy, but it's inconsistent to have readLn but not showLn in the base
15:08:11 <sizur> in my opinion
15:08:24 <DBAlex> the standard prelude is inconsistent, get over it!
15:08:28 <dolio> showLn is called print.
15:08:30 <sizur> hehe ok
15:09:36 <sizur> dolio: true, i was not aware of print heh
15:11:01 <rawr> hi, what is the line which I need to add to get <$> to work?
15:11:07 <ezyang> import Control.Applicative
15:11:18 <rawr> thank you
15:11:24 <ezyang> @hoogle (<$>)
15:11:24 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
15:15:15 <HugoDaniel2> hi
15:15:45 <HugoDaniel2> the functions that are automatically defined by the record syntax should be more smartly used by the compiler :(
15:16:08 <Cale> HugoDaniel2: huh?
15:16:19 <ezyang> try... unboxing?
15:16:21 <HugoDaniel2> if i have two data types with the same "field name", the ghc complains
15:16:29 <ezyang> ahhh
15:16:34 <ezyang> shared namespace yo
15:16:41 <Cale> HugoDaniel2: Of course.
15:16:49 <Cale> I don't consider that a problem
15:16:52 <HugoDaniel2> say i have two datatypes both with a "frequency" name
15:17:00 <ddarius> Modules are for name space control not records.
15:17:03 <ddarius> Local modules ho!
15:17:08 <HugoDaniel2> well, it could be avoided if ghc knew which one to apply given the data type im using
15:17:13 <HugoDaniel2> after all its different data types
15:17:26 <HugoDaniel2> the functions might have the same name, but diff type sigs
15:17:32 <Cale> There could be a typeclass for every field name, but that's ugly.
15:17:50 <Cale> You could just prefix or postfix one or both of them.
15:17:51 <HugoDaniel2> hmm
15:18:06 <ddarius> Or you could put each type in its own module and use a qualified import.
15:18:36 <HugoDaniel2> myNoise = perlin { frequency = 0.123 }  this becomes myNoise = perlin { perlinFrequency = 0.123 }
15:18:46 <Cale> Sure, exactly.
15:18:52 <HugoDaniel2> :(
15:18:55 <ddarius> or Perlin.frequency
15:19:00 <HugoDaniel2> but it says "perlin" right there...
15:19:10 <HugoDaniel2> ...it seems so... 1980 :(
15:19:22 <Saizan> use shorter names for variables?:)
15:19:28 <ezyang> HugoDaniel2: Smart constructors can help
15:20:14 <HugoDaniel2> Saizan: i like being explicit
15:20:39 <Saizan> myNoise = p { Perlin.frequency = 0.123 } -- pretty explicit
15:21:17 <Phyx-> Saizan: is... that valid?
15:21:21 <HugoDaniel2> oh hmm
15:21:24 <Cale> I don't think perlin is really a variable here.
15:21:31 <HugoDaniel2> im using something like: myNoise = perlin { frequency = 0.123 } `isSourceOf` scalebias { scale = 10.0 } `isSourceOf` absolute
15:21:46 <Cale> It's the default configuration for perlin noise, right?
15:21:46 <HugoDaniel2> perlin is just a constant that returns the datatype filled with default values
15:21:50 <Phyx-> Saizan: oh right, you're using it not defining it, nvm
15:21:52 <HugoDaniel2> yes
15:22:15 <rawr> what type would i need to have for this to work? f = lines <$> readFile "something"?
15:22:33 <rawr> im trying IO String
15:22:36 <Cale> f :: IO [String]
15:22:43 <rawr> thank you
15:22:47 <HugoDaniel2> i hope to get this half ready by the hackaton :/
15:22:51 * ddarius would probably not update the record directly but would write functions that did it for him to get something like, perlinNoise `withFrequency` 0.123 `isSourceOf` ...
15:23:08 <ddarius> Or something even more generic.
15:23:13 <Cale> rawr: Note that defining f like that won't actually read the file, you'll have to execute f to get it to happen.
15:23:30 <rawr> Cale well it didnt work as it gave me an error
15:23:31 <burp> rawr: you can use ":t" of ghci for this
15:23:44 <burp> :t lines <$> readFile "something" -- just as here
15:23:46 <lambdabot> IO [String]
15:23:56 <Cale> rawr: Values of type IO t are not in general anything like values of type t
15:24:21 <sizur> interesting.  a <$> b <$> c feels like i should be able to do foldl1 (<$>) [a,b,c]
15:24:24 <Cale> rawr: In particular, a value of type IO t is a description of some stuff which could be done in order to produce a value of type t, if it were to be executed.
15:24:48 <rawr> Cale im sorry your moving too fast for me.
15:25:05 <rawr> I guess im thinking too much like normal programming.
15:25:09 <Cale> rawr: So, for example, getLine :: IO String  will, when executed, cause a line of text to be read from the user.
15:25:21 <Cale> rawr: But just evaluating it will have no effect.
15:25:23 <burp> rawr: "normal"
15:25:25 <ddarius> [Random] Some pretty pictures made from some data copumpkin had: http://img713.imageshack.us/img713/2642/testkr.jpg http://img641.imageshack.us/img641/8679/testfy.jpg
15:25:50 <augustss> sizur: or, you might think [show x, show y] = map show [x,y]
15:25:58 <rawr> burp as apposed to functional, not meaning haskell not to be normal either.
15:26:00 <rawr> :p
15:26:05 <burp> ;-)
15:26:05 <Cale> rawr: It's important to understand the difference between evaluation and execution. Evaluation just takes expressions and turns them into values.
15:26:26 <Cale> rawr: Execution takes IO actions, and carries out the instructions that they describe.
15:27:05 <noggle> hi
15:27:11 <ddarius> :t foldl1 (<$>)
15:27:11 <Beelsebob> sizur: you probably don't want to use fmap repeatedly like that
15:27:12 <lambdabot> forall a. [a -> a] -> a -> a
15:27:14 <sizur> augustss: nah, i mean Applicative (<$>) cannot be used to fold as the argument types can be different
15:27:19 <Beelsebob> instead, it's more likely you want to use <*>
15:27:46 <ddarius> :t foldl1 (<*>)
15:27:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
15:27:48 <lambdabot>       Expected type: f (a -> b)
15:27:48 <lambdabot>       Inferred type: f a
15:28:04 <ddarius> @hoogle foldA
15:28:05 <lambdabot> module Data.Foldable
15:28:05 <lambdabot> Data.Foldable class Foldable t
15:28:05 <rawr> Cale got a link where I can read the difference's you speak about?
15:28:08 <ddarius> @hoogle foldlA
15:28:08 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
15:28:26 <sizur> Beelsebob: here's more concrete example: sequence_ $ putStrLn <$> (printf "%.5f" ::Float->String) <$> (*10) <$> [1,2,3]
15:28:27 <augustss> sizur: just like x and y could have different types in my example.  some things that look sensible in Haskell don't work because the same identifier has different overloaded types at different occurrences
15:28:32 <Cale> Well, I wrote this short intro to how IO works, http://www.haskell.org/haskellwiki/Introduction_to_IO
15:28:40 <noggle> I am a bit hung up on type definitions: data BookInfo = Book Int String [String] ... Is the only reason that I have Book as the value constructor so I can use :t and see someBook :: Book?
15:28:46 <ddarius> augustss: Solution: get rid of polymorphism.
15:28:58 <augustss> ddarius: just overloading :)
15:29:04 <rawr> Cale thank you
15:29:07 <Cale> noggle: someBook :: BookInfo, you mean
15:29:22 <noggle> Cale: yeah, what is Book for then?
15:29:34 <sizur> ddarius: nice, thanks
15:29:41 <Cale> noggle: For making values of type BookInfo, and pattern matching them apart again
15:29:50 <ddarius> augustss: twice f = f . f, twice id
15:30:01 <noggle> okay
15:30:02 <Beelsebob> sizur: I'd express that as putStrLn =<< unlines . printf "%.5f" . (*10) <$> [1,2,3]
15:30:05 <Cale> As a function,  Book :: Int -> String -> [String] -> BookInfo
15:30:28 <Cale> And when writing a function that works with BookInfo values, you can pattern match:
15:30:50 <Cale> f (Book isbn title authors) = ...
15:31:01 <augustss> ddarius: i'm not sure what that was supposed to illustrate :)
15:31:05 <Beelsebob> sizur: oops, move the unlines over one step
15:31:26 <ddarius> twice ((,) True)
15:31:33 <ddarius> that one works (or rather fails to work) better.
15:31:59 <ddarius> > (((,) True) . ((,) True)) False
15:32:03 <lambdabot>   (True,(True,False))
15:32:10 <ddarius> > let twice f = f . f in twice ((,) True) False
15:32:13 <lambdabot>   Occurs check: cannot construct the infinite type:
15:32:17 <lambdabot>    b = (GHC.Bool.Bool, b)
15:32:51 <noggle> Okay so I could pattern match a book like a record
15:32:53 <ddarius> > show (True, False)
15:32:54 <lambdabot>   "(True,False)"
15:33:10 <ddarius> Hmm.
15:33:16 <sizur> ddarius: ah, i thought there is Applicative fold, but there isn't afterall :)
15:33:18 * ddarius had thought that the show instance put a space after ,
15:33:58 <cebewee> rootnode:
15:34:15 <cebewee> sorry, typing error :/
15:34:15 <sizur> the list would have to be polytype
15:34:24 <rawr> hmm Cale, does this mean that IO String means, the function or datatype will result in an action which will create a string in the end?
15:35:30 <augustss> ddarius: I think twice is an example of something else.  If you need twice to handle (,True) you need some kind of type system extension.
15:35:31 <ddarius> [const 3 'a', const 3 True] == map (const 3) ['a', True]
15:35:56 <ddarius> augustss: Isn't it just monomorphism of lambda bound variables.
15:35:57 <augustss> ddarius: now that's an example of the same thing!
15:35:57 <ddarius> ?
15:36:31 <augustss> ddarius: yes, but sometimes you want twice to work
15:36:38 <ddarius> Indeed.
15:38:03 <ddarius> Crouching types, hidden existential
15:38:27 <MissPiggy> just turn off the type system
15:38:29 * sizur snickers.
15:38:29 <MissPiggy> problem solved
15:38:45 <augustss> a bit of subtyping can handle twice
15:39:10 <ddarius> augustss: Subtyping?  I don't see how that works for that.
15:40:10 <sizur> why oh why dont we have s-exprs syntax for haskell!  macros ftw
15:40:32 <augustss> ddarius: twice ::  (a -> b) -> a -> b | b < a
15:40:42 <MissPiggy> siur what do you want to macro?
15:40:46 <MissPiggy> sizur*
15:41:03 <ddarius> augustss: Would that cover all cases of twice breaking?
15:41:12 <ddarius> sizur: See Liskell.
15:41:19 <augustss> ddarius: I'm not sure it handles all cases
15:41:20 <ddarius> sizur: Also, see Template Haskell.
15:41:36 <augustss> ddarius: I think intersection types can, though
15:41:39 <sizur> MissPiggy: foldlA <$> [a,b,c] = a <$> b <$> c
15:41:45 * ddarius never understands why people think s-expr are necessary for macros.
15:41:51 <ddarius> (or even at all related to macros)
15:42:00 <ddarius> augustss: Yeah, they definitely can.
15:43:04 <oconnore_> ddarius: They aren't necessary. You could have macro's in C if you were willing to manipulate the GCC parse trees! But most people aren't.
15:43:27 <oconnore_> What does a GHC parse tree look like?
15:43:37 <ddarius> oconnore_: See Template Haskell.
15:43:39 <sizur> and since [a,b,c] will be macro expanded, it wont be type checked before the expansion
15:43:54 <ddarius> There's no reason to need to manipulate compiler-specific ASTs.
15:44:00 <ddarius> oconnore_: Also see the FOG C++ compiler.
15:44:12 <Adamant> ddarius: they aren't required, it's just a pain to do it without them in general
15:44:16 <ddarius> Or camlp4
15:44:17 <MissPiggy> sizur, oh this is in She Conor called it Idiom brackets
15:44:24 <ddarius> Adamant: "in general"?
15:45:06 <Adamant> ddarius: for languages close enough to Lisp, at least
15:45:27 <Adamant> which Haskell is and for which TH is a pain
15:45:37 <ddarius> Adamant: The killer thing needed to make macros useable is quasi-quoting which s-expressions provide mostly for free, but you don't need s-expressions for quasi-quoting.
15:46:25 <Adamant> ddarius: you will get people disagreeing on that
15:46:40 <Adamant> quasi-quoting being the killer thing
15:46:47 <Adamant> or at least the one killer thing
15:48:34 <Adamant> regardless, people get stuff done with s-expr based stuff and with TH, and with CPP, and etc.
15:49:07 <Adamant> so in the end, just pick your poison I guess
15:52:49 <sizur> i guess if we'd have haskell with backtracking typechecker and deriving djinn and s-exp syntax, then it's like having IWIN button -- boring
15:53:51 <sizur> aside of 2 hour "Hello, World!" compilation time
15:54:33 <lament> backtracking sounds suspiciously like multiple inheritance
15:54:56 * MissPiggy would rather have CHR (replace typeclasses)
15:56:33 <rawr> Why is functional programming so hard to grasp? I dont understand anything I read.
15:56:46 <medfly> what is there to grasp
15:56:47 <lament> are you reading okmij.org?
15:57:05 <rawr> Im trying to understand how to use IO
15:57:19 <copumpkin> because you probably come from an imperative background and have many false friends
15:57:21 <QtPlatypus> rawr: its because your brain has been trained to think iteratively.  Its not so much that you have to learn functional programing but unlearn some of the assumtions you have made about programing.
15:57:24 <rawr> and also I had some guys help me here a few days ago to write a simple function
15:57:28 <mauke> rawr: http://mauke.ath.cx/stuff/haskell/how-to-io.html
15:57:30 <rawr> and i cant even recreate it
15:58:00 <ivanm> byorgey: I get the distinction; it just wasn't that clear from the title ;-)
15:58:16 <QtPlatypus> http://mauke.ath.cx/stuff/haskell/how-to-io.html
15:58:28 <QtPlatypus> Sorry I ment to past that elsewhere
15:58:32 <ivanm> heh
15:58:32 <rawr> haha what part of the false friends plays into this? copumpkin
15:59:29 <copumpkin> you know the sense I mean by false friends, right?
15:59:36 <copumpkin> http://en.wikipedia.org/wiki/False_friend
15:59:37 <ddarius> rawr: class /= class
16:00:02 <copumpkin> function /= function
16:00:24 <sizur> variable /= variable
16:00:38 <copumpkin> NaN /= NaN
16:00:44 <augustss> haha
16:00:47 <copumpkin> :P
16:00:56 <mauke> /= /= 
16:01:07 <ivanm> @slap mauke
16:01:08 <lambdabot> *SMACK*, *SLAM*, take that mauke!
16:01:21 <rawr> copumpkin i learned something new. Thanks.
16:01:28 <sinelaw> =_-_-_-_-_
16:01:29 <sizur> > let a + b = a - b in 2 + 3
16:01:31 <lambdabot>   -1
16:01:54 <mauke> > let 2 + 3 = -1 in 2 + 3
16:01:55 <lambdabot>   -1
16:02:05 <QtPlatypus> copumpkin: How is funtional.function /= iterative.function ?
16:02:13 <sizur> let (+) = (^) in 2+10
16:02:15 <copumpkin> rawr: even supposedly obvious things you might expect from imperative programming have deeply different meanings in haskell. So let x = x + 1 doesn't bind x to its current value + 1
16:02:26 <sizur> > let (+) = (^) in 2+10
16:02:27 <lambdabot>   1024
16:02:28 <copumpkin> rawr: writing let x = x + 1 will usually get you into an infinite loop if you ask for x
16:02:57 <copumpkin> QtPlatypus: our idea of a function is a pure one, but in other languages you can have side effects, and even have nullary functions which have to have side effects
16:03:11 <copumpkin> arguably ours is the only correct definition but the common definition differs
16:03:20 <sizur> > let a = a + 1 in Nothing <*> Just a
16:03:21 <lambdabot>   Nothing
16:03:22 <ddarius> void nullary() { }
16:03:29 <Polarina> Is there anything that does something similar to a foldM_ but has the type (Monad m) => (b -> m a) -> [b] -> m () ?
16:03:49 <aavogt> @type mapM_
16:03:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:03:53 <cebewee> @type <*>
16:03:54 <lambdabot> parse error on input `<*>'
16:03:57 <copumpkin> I guess they don't have to, but aren't very useful otherwise
16:03:59 <cebewee> @type (<*>)
16:04:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:04:05 <hzap> @hoogle (Monad m) => (b -> m a) -> [b] -> m ()
16:04:05 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:04:05 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
16:04:05 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
16:04:15 <rawr> copumpkin yeah because your calling x right?
16:04:21 <rawr> I get that much
16:04:31 <rawr> but i cant seem to write my own code.
16:04:38 <Polarina> aavogt, thanks.
16:04:39 <copumpkin> rawr: because it's referring to itself :) I guess you could call it that
16:10:46 <benmachine> man, I know I complained about this a few weeks ago
16:10:52 <benmachine> but alpha conversion is *still* hard
16:11:15 <rawr> how do you use print =<<?
16:11:29 * benmachine actually has a nice little self-contained function to do it now but unfortunately none of his use cases are nice, little, or self-contained
16:11:53 <benmachine> rawr: you put an IO thing on the right
16:12:13 <benmachine> where thing is in Show
16:12:23 <augustss> benmachine: alpha conversion in what language?
16:12:38 <benmachine> augustss: does it matter? :P
16:12:55 <benmachine> augustss: I'm writing a thing for stepping you through the evaluation of a haskell expression
16:13:14 <benmachine> but currently the evaluation for (\x y -> x + y) y is misbehaving
16:13:18 <benmachine> no in fact it isn't
16:13:22 <benmachine> I've fixed that
16:13:23 <benmachine> but
16:13:25 <augustss> benmachine: it's easier in very simple languages
16:13:36 <benmachine> what was my test case that went wrong
16:13:54 <benmachine> (\x x' -> x x') (x' x)
16:13:56 <benmachine> that goes wrong
16:13:58 <augustss> benmachine: all you really need is a working substitution
16:14:19 <benmachine> augustss: I've got it so that in ^ that example, it realises it needs to rename x and x'
16:14:28 <benmachine> unfortunately it chooses x'' for both of them
16:14:53 <benmachine> in fact I think I've even fixed that, except that now I have it so that it might choose a different renaming on the LHS and RHS of the ->
16:15:10 <augustss> benmachine: it only needs to rename x' for a beta reduction
16:15:22 <benmachine> hmm
16:15:26 <benmachine> yeah
16:15:29 <benmachine> why did I think otherwise
16:15:38 <benmachine> I think I oversimplified the test case
16:16:25 <augustss> benmachine: if you just care about correctness do it one variable at a time, i.e. treat it as (\ x -> \ x' -> x x') (x x')
16:16:36 <augustss> it's much easier
16:16:39 <benmachine> mm, I'm thinking that might be sensible
16:18:05 <tomberek> hi everyone
16:18:18 <rawr>     Couldn't match expected type `[String]'
16:18:18 <rawr>            against inferred type `IO [String]'
16:18:21 <tomberek> Alpounet: still awake?
16:18:22 <rawr> what does this mean?
16:18:42 <benmachine> patterns can be nested can't they oh dear
16:18:43 <augustss> rawr: exactly what it says
16:18:44 <copumpkin> rawr: you're treating an impure computation as if it were pure
16:18:52 * benmachine attempts to listify
16:18:57 <tomberek> rawr: you have a list of Strings in an IO monad.... yeah, what copumkin said
16:18:59 <copumpkin> you can't take things out of the IO, so you need to move your functions in :)
16:19:13 <QtPlatypus> rawr: Can you paste bin your code?
16:19:16 <ksf> damn data structure researchers. you have to follow _all_ those citations to figure out that they tend to leave out their non-competetiveness in space usage, or abysmally high constant factors while being busy drawing out their big Os in painfull detail
16:19:40 <tomberek> ksf: which data structures you talking about?
16:19:49 <ksf> adaptive binary search trees
16:20:07 <tomberek> ah... i ran into that with fusion trees and some other exotic trees
16:20:33 <c_wraith> isn't any binary tree going to be relatively space-inefficient?
16:20:34 <ksf> I think I've got the candidates down to zipper trees and poke trees which are both log log n -competetive and have log n worst case access
16:20:50 <rawr> QtPlatypus http://www.pastebin.com/m3c56f7d8
16:21:44 <ksf> poke trees are quite interesting because they just hack rb-trees with additional pointers, and rb-trees are height-balanced so they fit into an array.
16:22:19 <rawr> btw the function runNextTest is named wrongly
16:22:31 <ksf> wait, rb-trees don't fill from left to right on the lowest level.
16:22:40 <rawr> as i originally was trying to write a function which executed one test and printed it
16:22:45 <rawr> and would be recursive.
16:22:58 <doserj> rawr: it should be called mapM
16:23:07 <c_wraith> ksf: no, rb-trees can have some paths that are twice the length of others.
16:23:31 <doserj> rawr: erm, map
16:25:35 <tomberek> ksf: what do you know of cache-oblivious trees?
16:25:54 * ksf googles
16:26:27 <Veinor> they're oblivious to cache!
16:26:50 <doserj> rawr: is scanner a pure function? than doTests = print =<< (map scanner <$> readF)
16:27:13 <lispy> :t scanr
16:27:14 <ddarius> Cache-oblivious algorithms are pretty cool.
16:27:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
16:27:40 <lispy> maybe that's a different scanr :)
16:27:50 <rawr> doserj thats what i needed i think
16:28:14 <tomberek> ddarius, ksf: i was going to try to implement one of them
16:28:38 <ksf> ...skimming the first paper I don't see anything about adaptiveness
16:28:50 <bsdunx> can someone show me the what docs I need to read to understand args and return type, I want a function to take a String and an Integer and return a Handle
16:29:14 <benmachine> oh shiiiit GHC prompted me to use -XImpredicativeTypes
16:29:19 * benmachine is probably doing it wrong
16:29:22 <MissPiggy> nooooo don't do it
16:29:26 <Zao> f :: a -> b -> c    -- 2-ary function taking an a and a b, returning a c.
16:29:30 <Zao> benmachine: Flee!
16:29:35 <tomberek> ksf: the point is that they are not tailored to a particular cache structure, but still work better
16:29:51 <tomberek> ddarius: btw, I had my monad/comonad/arrow "epiphany moment"
16:30:20 <ksf> I'm going to keep them in mind
16:30:21 <MissPiggy> what is there to monad/comonad/arrow/
16:30:22 <MissPiggy> ?
16:30:50 <tomberek> MissPiggy: going from bewilderment to understanding
16:30:58 <MissPiggy> understanding what?
16:31:21 <ksf> ...on another scale, I just realized that having separate maps for glyph and kern caches doesn't make any sense, at all. the glyph cache can store kern caches at its leaves.
16:31:22 <rawr> doserj how would I use map to print each test on a seperate line, not creating a [[Token]]?
16:31:33 <tomberek> MissPiggy: monads comonads and arrows
16:31:37 <MissPiggy> :/
16:31:40 <MissPiggy> tomberek ....
16:32:33 <MissPiggy> tomberek don't you know what I am asking
16:32:50 <doserj> rawr: you have an IO [a], and you want to print each of the a's seperately?
16:33:18 <tomberek> MissPiggy: um... give me a hint
16:33:27 <rawr> doserj cos currently after 1 test fails it just stops and throws an error.
16:33:40 <rawr> i want it so that each test is done on its own
16:33:42 <MissPiggy> tomberek oh for fucks sake
16:33:45 <rawr> kinda like a macro for me.
16:34:24 <theorbtwo> MissPiggy: He had the epiphany.  The ah-ha moment.  He now thinks he understands them, and how they are related.
16:34:40 <tomberek> MissPiggy: look, I obviously either missed something or I'm not understanding what you want.
16:34:55 <MissPiggy> tomberek: I just wanted to know what you learned about them
16:34:57 <tomberek> MissPiggy, yeah, what theorbtwo said.
16:35:08 <doserj> rawr: how does it fail?
16:35:35 <zygoloid> tomberek: if this is your first 'a-ha' moment with them, you've probably got several more on the way in the near future :)
16:35:56 <aavogt> how does running each test try to exit?
16:36:01 <tomberek> MissPiggy: Ok, comonads: allow you to specify behavior that needs to be understood in a context.  (my example was the evaluation of a neuron in a neural network)
16:36:14 <doserj> rawr: if you are calling error somewhere in your code, just don't do it. if some other code throws an exception, you will have to catch it.
16:36:14 <rawr> doserj the code is working, But I have the scanner module currently to throw an error when it meets something it shouldnt. using "error "I dont like this""
16:36:27 <doserj> rawr: don't do that
16:36:43 <rawr> how else should i do errors then?
16:36:49 <MissPiggy> okay
16:37:10 <jmcarthur> anybody know if there is an existing binding to the setitimer function anywhere?
16:37:17 <theorbtwo> rawr: If you are inside a monad, use "fail" instead of "error".
16:37:17 <doserj> return Maybe a, or Error e a, where e is a type to describe the error
16:37:24 <jmcarthur> i can find a binding to alarm, but i need something more precise
16:37:29 <tomberek> MissPiggy: monads: allow you to specify behavior that happens in addition to the normal behavior. (eg: state passing)
16:37:38 * MissPiggy nod
16:37:55 <doserj> s/Error/Either/
16:38:03 <tomberek> MissPiggy: arrows: are basically comonads combined with monads using distributivity.
16:38:08 <jmcarthur> i suppose i could just fork a thread and use threadDelay
16:38:13 * twink tries to remember what (im)predicativity is.
16:38:16 <MissPiggy> ahh neat
16:38:26 <QtPlatypus> x
16:38:40 <tomberek> zygoloid: that seem right so far?
16:38:54 <zygoloid> seems like a good intuition to me
16:39:25 <theorbtwo> So arrows are a recombined comonad layer?
16:39:32 <theorbtwo> ...or recola for short?
16:39:36 <tomberek> I think i came to the understanding backwards from most people.  I got comonads before the rest.
16:39:43 <tomberek> Ricola anyone?
16:39:56 <theorbtwo> Oh, damn.  Pun fail.
16:40:14 <dolio> I don't know if you can always show that an arrow arises from a monad and a comonad. Perhaps you can, though.
16:41:06 <ddarius> twink: The ability (or not) to instantiate polymorphic functions to polymorphic types.
16:41:30 <tomberek> dolio: i don't know if this is strictly correct, but sigfpe's guide talks about them that way http://blog.sigfpe.com/2008/03/transforming-comonad-with-monad.html
16:43:05 <dolio> Well, I believe you can get interesting arrows that way.
16:43:15 <dolio> I don't know if you can get *all* arrows that way.
16:43:22 <tomberek> dolio: though you are probably correct that you can't decompose arrows every time... yeah
16:43:56 <tomberek> But the idea is there... anyway, arrows are simpler to understand than the rest.
16:43:56 <dolio> Well, you may be able to. I've seen papers/etc. such that it wouldn't surprise me.
16:45:31 <tomberek> MissPiggy: that seem right?
16:45:55 <MissPiggy> tomberek, I don't know about this stuff so I am learning from it
16:45:57 <MissPiggy> from ou
16:45:59 <MissPiggy> you**
16:46:47 <tomberek> erg... i'm brand spanking new too, so I suggest Saizan, Cale, ddarius, or someone of that ilk. They are higher up on the understanding chain than I am.
16:47:06 <dolio> tomberek: For instance, one paper (Arrows, Like Monads, Are Monoids, I think) mentions that monads are monoids in a category involving C -> C functors, and arrows are monoids in a category involving C^op x C -> C functors, and I think it states that comonads are similar for C^op -> C functors.
16:49:02 <dolio> It doesn't really go into that presentation of comonads, though. And I've never seen it elsewhere.
16:49:20 <tomberek> dolio: yes, but even so, that doesn't mean that they are isomorphic, right? Correct me if this is wrong, but I would think that not every arrow can be split into the two that way.
16:49:46 <rawr> What is the purpose of functional programming?
16:49:51 <dolio> Well, I don't think it's obvious either way.
16:49:57 <MissPiggy> rawr you can write programs with it ...
16:50:00 <MaciejP> Huh, lambdabot has gone sleeping!?
16:50:02 <rawr> its so hard to learn im wondering what its purpose is.
16:50:04 <MissPiggy> rawr what do you mean exactly?
16:50:14 <MissPiggy> rawr oh it is quite difficult yes but it is worth it
16:50:15 <tomberek> dolio: perhaps anyone else has an answer,,, ask some higher ups.
16:50:17 <rawr> I dont mean to offend, its a geniune question
16:50:50 <ddarius> dolio: Comonads are comonoid objects in C -> C
16:50:58 <MissPiggy> rawr the reason it is worth it is because there are many very fundamental aspects of programming which you can learn about in a very clear way in this context
16:51:06 <ddarius> dolio: Comonads in Haskell are still covariant functors.
16:51:42 <tomberek> rawr: i'm learning it too now,, and I wonder about why.  The answer is this: come on here and ask some experienced person about how to do something. They will usually have a simple and elegant solution.  Functional programming makes you think differently.
16:51:56 <dolio> ddarius: Yes, I know that presentation.
16:52:20 <dolio> I think the thrust of the paper is that they're all monoid objects in the appropriate category.
16:52:27 <QtPlatypus> rawr: The perpose of functional programing is the same as all programing.  To solve problems.  There are some problems that are a nice match to the functiaonal paradine.
16:53:03 <tomberek> ddarius: we were talking about arrows being a combination of monads and comonads.  Or rather that some are.
16:53:21 <ddarius> dolio: Well, you could view comonoid objects as monoid objects in the op category.
16:53:22 <Rotaerk> when someone asks what the purpose of functional programming is, they're probably coming from an imperative background, and really mean "what does functional programming do that imperative doesn't?"
16:53:51 <rawr> Rotaerk I wont lie, that IS what I am thinking.
16:54:10 <dolio> ddarius: Yeah, but presumably he also wants to tie together the C -> C, C^op x C -> C, C^op -> C thing.
16:54:10 <rawr> I like it, when I get stuff to work. That is rare though.
16:54:14 <MissPiggy> rawr and it is not yet answered?
16:54:27 <tomberek> rawr: nothing... but then again assembly can do anything,, as can an abacus.
16:54:30 <rawr> MissPiggy Yeah it has, thanks for the reply :D
16:54:53 <dolio> The categories for C^op x C -> C and C^op -> C are significantly less obvious, though, I think.
16:55:25 <dolio> The arrow one has composition involving ends or something, I think.
16:55:31 <ddarius> tomberek: In sigfpe's article, he basically performs the Kleisli construction and then the coKleisli construction (or vice versa) arriving at a category of morphism w a -> m b
16:55:42 <ddarius> (Co)ends are nice.
16:55:55 <Rotaerk> I find recursion with immutable values generally to be more clear than loops with mutables... primarily because it's very obvious what state the next iteration/recursion is going to start with
16:55:55 <ddarius> I don't know why we bother with conical (co)limits so much.
16:57:16 <tomberek> ddarius: ok, we approached and blew past my category theory understanding.... so is it correct to say that arrows CAN be a combination monad and comonad, but not every arrow can be decomposed in such a way?
16:57:53 <chrisdone> ya'll get ready for this http://tryhaskell.org/
16:57:59 <mm_freak_> i'd like to express something like:  "if you would like to see a really advanced language, take a loot at haskell, clean, f#, "
16:58:05 <mm_freak_> what other languages would fit here?
16:58:09 <ddarius> tomberek: I doubt every arrow can be decomposed that way, but it's possible.
16:58:20 <tomberek> chrisdone: that is awesome!
16:58:21 <mm_freak_> loot  look
16:58:29 <chrisdone> tomberek: :D
16:58:35 <lament> mm_freak_: depends. Are you trolling?
16:58:51 <mm_freak_> lament: no, i'm serious
16:59:01 <ksf> since when is laying out a binary tree into an array called "van Emde Boas layout"?
16:59:07 <mm_freak_> it's just that i don't want to provide haskell as the only option
16:59:22 <ddarius> ksf: When you do it in a particular (unusual) way.
16:59:37 <tomberek> chrisdone, do you think you can add an ability to store small bits of code (like a pastebin)... then I can do haskell anywhere!
16:59:38 <mm_freak_> because i'm known for being a haskell enthusiast =)
16:59:38 <QtPlatypus> mm_freak_: How do you qualify "Advanced"
17:00:13 <lament> mm_freak_: i'm still pretty sure you're trolling :P
17:00:28 <chrisdone> tomberek: it'll support @let per user in future, but it's supposed to be pretty limited ;)
17:00:40 <mm_freak_> QtPlatypus: safer, more readable, more concise than C++/C#/java/
17:00:49 <lament> mm_freak_: especially if you're going to recommend languages you don't even know!
17:00:50 <mm_freak_> lament: feel free to be sure =P
17:01:05 <mm_freak_> lament: i know haskell, clean and f#
17:01:10 <lament> so why not end there?
17:01:27 <mm_freak_> because i wonder if those are the only options
17:01:48 <ddarius> Actually, can the Arrows induced by an Applicative be cast as w a -> m b for a comonad w and monad m?
17:01:56 <tomberek> chrisdone... or maybe another frame where normal .hs or .lhs style code can be pasted and loaded... like an online ghci?
17:02:37 <Saizan> ddarius: you mean \a b -> f (a -> b) ?
17:03:06 <chrisdone> tomberek: not my intention -- there are sites that do do that, codepad (iirc) for one, and others!
17:03:07 <ddarius> If that's what it is.  I'd have to look at the papers again.
17:03:19 <sinelaw> @quote monad
17:03:36 <tomberek> chrisdone.. ok.. thanks for the work! what's next?
17:03:47 <sinelaw> I said, @quote monad
17:03:51 <sinelaw> @quote monad
17:03:54 <sinelaw> @bot
17:03:55 <ksf> @bot
17:04:00 <sinelaw> ahem.
17:04:06 <sinelaw> > 1+1
17:04:08 <lament> sinelaw: throw a fit.
17:04:09 <sinelaw> 2
17:04:23 <heatsink> > sqrt 48831
17:04:24 * sinelaw throws a fit at lament
17:04:24 <chrisdone> tomberek: well following the Ruby vein, it will do the whole "type some math. good you typed some math, now let's try.." etc, using the types to work it out
17:04:41 <tomberek> cool
17:04:51 <chrisdone> tomberek: I'm going to come up with the most common lessons from various haskell tutorials and codify them into this form
17:04:55 * ksf calls it a day. It's olympia, after all.
17:04:55 <sinelaw>  220.977374407
17:05:11 * sinelaw too
17:05:39 <ksf> ...though there's certainly more exciting things to watch than figure skating
17:05:43 <tomberek> ddarius: Saizan: verdict?
17:06:05 <benmachine> interesting, ghc doesn't warn about redundant import of a typeclass
17:06:08 <ksf> ski cross has been the best addition to olympia since the ancient greeks.
17:06:47 <ivanm> ksf: you're in greece? :o
17:06:51 <Rotaerk> when were the ancient greeks added to the olympia?
17:06:55 <chrisdone> also had one idea where you could talk to the local DOM... with the remote haskell prompt. would be nice
17:07:07 <Saizan> tomberek: for every Applicative f you can have an Arrow (\a b -> f (a -> b)), which doesn't look decomposable into w a -> m b to me
17:07:14 <ksf> erm the ancient greeks _invented_ olympia
17:07:28 <ksf> in fact, there's a temple there, and that's where the fire is ignited.
17:07:35 <ivanm> ksf: "olympia" is a place IIRC
17:08:09 <ivanm> and wikipedia agrees with me
17:08:13 <tomberek> Saizan: ok, so the decomposable ones are just a special case... but conceptually is it somewhat right to think of arrows and monads with comonads?
17:08:14 <ivanm> so I _must_ be right! ;)
17:08:32 <tomberek> **arrows as**
17:08:34 <theorbtwo> The games are named after the very old games that were held there, which are named after the town.
17:09:03 <ivanm> "named after" /= "the same name as" :p
17:09:07 <ksf> ...confusion subsides as I figure out that "olympiade" and "olympic _games_" are the proper terms in two related, but ultimately distinct, languages.
17:09:25 <ivanm> which language is "olympiade" from?
17:09:30 <ksf> german
17:09:43 <ksf> ...or, well, that's what it's called.
17:09:50 <ksf> "olympische spiele" works too, though.
17:10:07 <theorbtwo> ivanm: Er, right.  Didn't mean to imply that they had the same name.
17:10:43 <mauke> "olympiade" refers to a time span
17:10:50 <benmachine> yesss
17:10:55 <Saizan> tomberek: not sure, i'm actually looking for a concrete example of applicative which makes it break
17:11:00 * benmachine got his alpha conversion sorted, possibly
17:11:52 <ddarius> tomberek: Most likely, it's not conceptually safe to think of Arrows as Comonad+Monad.
17:14:23 <tomberek> on a different topic: a general question about GHC:  in something like f = [ g x , g x ]    will GHC actually calculate g x twice, or must I use a where clause?
17:14:44 <ivanm> twice
17:14:55 <ivanm> use let or where to have only one calculation
17:15:04 <ivanm> (unless GHC is _really_ feeling generous/clever...)
17:15:09 <theorbtwo> Hm.  It won't do common subexpression optimization?
17:15:10 <tomberek> ivanm: that's what I was told, and I don't understand why GHC can't create that let or where for you
17:15:11 <copumpkin> there are some cases in which it will actually do CSE for you
17:15:12 <Saizan> i think the writer applicative Monoid mon => W mon a = (mon, a); which gives arrows like (mon,a -> b) breaks it, because e.g. Id a -> (mon,b) would let you generate the monoid value from 'a'
17:15:13 <copumpkin> but very few
17:15:17 * theorbtwo is surprised.
17:15:29 <copumpkin> theorbtwo: it notices opportunities and then ignores them
17:15:43 <theorbtwo> Er, uh... what?
17:15:45 <ivanm> tomberek: IIRC, there are cases where doing that is _bad_
17:15:46 <ivanm> so it doesn't
17:15:52 <Saizan> tomberek: it's not so easy to spot when it's an optimization
17:15:55 <copumpkin> it can cause space leaks
17:16:02 <ivanm> @google haskell common subexpression elimination
17:16:02 <Saizan> because it can lead to increased memory use
17:16:07 <ivanm> that's right
17:16:07 <theorbtwo> I thought half of the point of pure programming was that the compiler can do that.
17:16:14 <ivanm> oh, we're botless
17:16:17 <tomberek> ditto theorbtwo
17:16:20 <copumpkin> it can, and sometimes it will
17:16:26 <domor> tomberek: AFAIK, this has been tried, but it was judged too complex so it was dropped, since usually it's simple enough to just use the where
17:16:31 <ivanm> theorbtwo: the compiler _can_ do it, it's just not something you _really_ want done in general
17:16:41 <tomberek> if g x will return the same thing every time (referential transparency right?)....
17:16:45 <copumpkin> as I said, it notices opportunities and then mostly ignores them unless it's sure they're safe
17:17:29 <ivanm> "Excuse me, Mr. Sub-Expression, but are you safe to eliminate?"
17:17:44 <copumpkin> No sir, I am not.
17:17:45 <tomberek> so it CAN lead to problems with pure code? or only with impure code?
17:17:47 <domor> there it is: http://tiny.cc/2cBu5   (GHC Faq entry about CSE)
17:17:56 <copumpkin> tomberek: it can lead to problems with pure code
17:17:58 <Saizan> tomberek: performance problems with pure code
17:18:04 <ivanm> domor: why not the real URL?
17:18:15 <copumpkin> it's only pure with respect to values :) there are still side effects in memory usage :P
17:18:21 <tomberek> wow... then that means I am reasoning about it the wrong way
17:18:31 <Saizan> tomberek: your code might get slower because you're keeping the result in memory rather than recalculating it later
17:18:49 <domor> ivanm: it's long because it refers directly to the entry. I didn't want to put a big mess in the channel. is the shortening frowned upon here?
17:19:03 <copumpkin> he be gon!
17:19:12 <tomberek> Saizan: so a where or let can be a conceptual : "remember this somewhere because it might be usefull)
17:19:44 <Saizan> tomberek: yeah, you tell the compiler that you think sharing is beneficial in this case
17:20:33 * benmachine basks in the warm but ultimately temporary glow of having no known bugs
17:20:50 <copumpkin> the only time it does CSE
17:20:55 <copumpkin> is when you have two equal bindings
17:21:19 <tomberek> Saizan: so somehting like f = [ g x , g x] where g x =2 would work?
17:21:21 <copumpkin> it talks about it here: http://www.haskell.org/haskellwiki/Performance/GHC
17:21:57 <Saizan> tomberek: no, "f = [ y , y ] where y = g x" would work
17:22:19 <Saizan> i.e. it'll calculate "g x" only once
17:22:30 <tomberek> Saizan: i understand that,,, but not the way I did it?
17:22:44 <tomberek> it seems the same except the kind
17:23:18 <Saizan> only bindings with no formal arguments are shared
17:23:29 <benmachine> tomberek: you define a function g, Saizan defines a value y
17:23:29 <tomberek> Saizan: ok, got it , thanks for answers
17:23:49 <Saizan> (functions are values too!)
17:23:59 <benmachine> yes but not all values are functions :P
17:24:08 <benmachine> despite what people will try to tell you
17:24:24 <Saizan> true, not sure if it really matters here though
17:24:28 <tomberek> the key phrase there is "bindings with no formal arguments"
17:24:35 <benmachine> yeah
17:24:43 <tomberek> ok, thanks
17:26:34 <Saizan> oh, no formal arguments and not "typeclass" polymorphic in case you've the MonomorphismRestriction off
17:27:14 <tomberek> Is there a way to do the CSE, but in a protected way?  (Saizan: i usually just deal with the MR by writing out the type)
17:27:25 <Saizan> because the typeclass dictionary acts as another argument, essentially
17:27:46 <Saizan> (this is all implementation dependent, but it's fairly standard)
17:27:52 <meanburrito920_> can anyone explain to me the difference between div and quot?
17:28:01 <meanburrito920_> they both have the same type and return the same result
17:28:11 <aavogt> @check \x y -> div x y == quot x y
17:28:11 <Saizan> > (-4) `div` 3
17:28:19 <Saizan> no bot :\
17:28:36 <Saizan> meanburrito920_: they give differents results for negative arguments
17:28:45 <meanburrito920_> ah
17:28:48 <mauke> preflex: seen lambdabot
17:28:49 <preflex>  lambdabot was last seen on #haskell 1 hour, 1 minute and 34 seconds ago, saying: forall a b. (a -> b -> b) -> b -> [a] -> [b]
17:28:58 <ddarius> tomberek: The issue isn't semantics.  CSE is always semantically safe.  The issue is performance.
17:29:25 <ddarius> Also, there is no guarantee in general that a named value will be shared though GHC gives some guarantees.
17:29:28 <copumpkin> lunabot is gone too
17:29:31 <copumpkin> @get-mmorrow
17:29:35 <copumpkin> :(
17:29:47 <meanburrito920_> hm. so i can see they behave differently, but what exactly is the difference in behavior?
17:29:52 <tomberek> ddarius: yes,,, i get that, but there isn't a safe way in terms of performance,,, or is that exactly what ghc does with the "opportunistic"?
17:29:56 <copumpkin> they differ on negative values
17:30:06 <meanburrito920_> ...right. but that doesnt tell me how they differ
17:30:19 <meanburrito920_> for example
17:30:29 <meanburrito920_> div (-3) 2 => -2
17:30:31 <Saizan> meanburrito920_: one truncates towards zero, the other towards -infinity, so to speak
17:30:39 <meanburrito920_> quot (-3) 2 => -1
17:30:52 <ddarius> tomberek: GHC can tell in some cases, but in most cases it can't and anyway the issue isn't a matter of better.  It's a trade-off so GHC should let you say what you want, which is what it does.
17:31:00 <copumpkin> meanburrito920_: http://snapplr.com/2709
17:31:03 <tomberek> roger roger
17:31:24 <theorbtwo> tomberek: "Safe" is an overused term in this discussion -- it's decidedly nontrivial, at least, to say when common subexpression elimination will give you lower CPU for higher memory in amounts that you want.
17:31:31 <theorbtwo> ...so it just doesn't do it.
17:31:58 <ddarius> theorbtwo: Well, the most "non-trivial" part about that is the "you want" part.
17:32:05 <copumpkin> meanburrito920_: http://snapplr.com/sqjp -> (-1 * 6 + 5 = -1) and (0 * 6 + -1 = -1)
17:32:09 <meanburrito920_> copumpkin: I'm not sure that's applicable, but I do understand the difference now from messing around in ghci. thanks :)
17:32:24 <copumpkin> quot and rem go together, div and mod go together :)
17:32:28 <meanburrito920_> oh
17:32:29 <copumpkin> that's why I mentioned them
17:32:32 <meanburrito920_> got it :)
17:32:35 <meanburrito920_> thanks!
17:32:38 <copumpkin> np
17:32:46 <tomberek> ok, so if I want to use less CPU, use lots of let and where,, but I will use more memory.. and vice versa
17:33:07 <ddarius> tomberek: More memory often implies more CPU.
17:33:46 <tomberek> of course there will be places where they should and shouldn't be used... closer to machine vs higher up in abstractions
17:34:01 <ddarius> tomberek: If you want better time or space usage, understand what your code is doing and what the compiler is doing.
17:34:06 <ksf> more cpu can mean faster as getting a cache miss for the result of 1+1 is expensive
17:35:27 <tomberek> yep... that's what I'm saying,,, closer to data manipulation, CPU is better, but higher up in abstractions, memory is better
17:36:11 <ddarius> tomberek: I'm not really sure what you are saying, but I'm sure the rules aren't that simple.
17:36:46 <ksf> ...the rule is that you can easily fit 100 additions into one main memory fetch
17:37:30 <ksf> remember that main memory is _centimetres_ apart from where the data is needed.
17:37:43 <ksf> *away
18:03:20 <gwern> hm.
18:03:29 <gwern> at one point I knew how to use IO Bools
18:03:53 <gwern> @hoogle m Bool
18:04:07 <gwern> @hoogle if
18:04:07 <copumpkin> how to use to do what?
18:04:16 <copumpkin> no bot
18:04:23 <ddarius> when =<<
18:04:28 <aavogt> is an IO Bool a random?
18:04:30 <gwern> copumpkin: in this case, 'maybeRead x = if isText x then B.readFile x else return B.empty '
18:04:44 <copumpkin> oh, so the Bool itself isn't in IO
18:04:55 <copumpkin> or isText also IO?
18:04:56 <gwern> @hoogle when
18:05:03 <ddarius> gwern: You just have to bind them, there is no convenient way.
18:05:04 <copumpkin> no bot
18:05:09 <gwern> copumpkin: IO. can't know whether a file is text or (maybe) binary without reading it
18:05:12 <ddarius> when :: Monad m => Bool -> m ()
18:05:16 <ddarius> when :: Monad m => Bool -> m () -> m ()
18:05:20 <gwern> ddarius: @botsnack
18:05:27 <copumpkin> gwern: oh I see
18:05:29 * ddarius is a bad bot.
18:05:31 <copumpkin> when won't do it though
18:05:36 <copumpkin> if he actually wants to return it
18:05:55 <gwern> bleh. so I'll bind it then
18:05:56 <Saizan> maybeRead x = do b <- isText x; if b then B.readFile x else return B.empty
18:06:25 <gwern> yeah I've got that far
18:06:25 <ddarius> There are some libraries that define things like ifM.
18:06:57 <gwern> the question now is do I steal darcs' C binding for an isText-alike or do I try to find something in the standard libs...
18:07:16 <aavogt> what does isText actually check for?
18:07:29 <aavogt> text vs binary?
18:07:32 <serhalp> Hello, complete Haskell newbie working with Happy here.  I've got an issue that appears to even show up when I compile the provided example expr-tree: "Couldn't match expected type `FiniteMap.FiniteMap key elt' against inferred type `Expr.Forest' In the first argument of `fmToList', namely `f'." (and in the code: type Forest = Map.Map ForestId [Branch]).  Any ideas?
18:07:38 <gwern> aavogt: iirc, it checks for \nul or something unixy like that
18:07:38 <heatsink> A lot of libraries define ifM, actually...
18:07:54 <copumpkin> gwern: what if you get utf-16 text? :)
18:08:03 <gwern> copumpkin: lies! there are no such files
18:08:07 <copumpkin> oh okay
18:08:13 * copumpkin scrubs his mouth out with soap
18:08:16 <heatsink> I thought there was a library that collected lots of monad-lifted functions, but I can't find it.
18:08:41 <gwern> int has_funky_char(const char *s, int len)
18:08:41 <gwern> { // We check first for the more likely \0 so we can break out of // memchr that much sooner. return !!(memchr(s, 0, len) || memchr(s, 26, len));
18:08:44 <gwern> }
18:09:12 <gwern> I don't suppose there's any way to define C functions with includes, inline in a haskell file?
18:09:46 <gwern> (that definition is pretty fast. I spent a fair bit of time benchmarking that against alternatives back in 08)
18:09:57 <aavogt> use template haskell to write your C stubs from your .hs file
18:10:31 <gwern> aavogt: any way which is not worse than suicide to end it all
18:12:19 <serhalp> Should a Map be compatible with a FiniteMap?  Is there... something like the polymorphism of the object-oriented world?  I'm fairly clueless here.
18:12:23 <copumpkin> it is
18:12:35 <copumpkin> FiniteMap is Map, it was just renamed
18:12:36 <copumpkin> as far as I know
18:12:54 <gwern> finitemap on hackage is actuallu just some renaming and argument swapping of map
18:13:34 <serhalp> So would that be the reason this example isn't compiling?  s/Map/FiniteMap/g should make it go?
18:15:47 <aavogt> ah, why does alex have to call error when the lexer fails
18:16:13 <heatsink> aavogt: So it can return a lazy list?
18:16:35 <copumpkin> so if 1 is not prime, does that mean it's composite?
18:16:38 <aavogt> maybe... but that doesn't mean it couldn't explicitly name that exception
18:16:38 <copumpkin> or is it just 1?
18:16:47 <ddarius> copumpkin: It's just 1.
18:16:57 <copumpkin> fair enough
18:17:35 <heatsink> aavogt: You can extend your token datatype with an error token, and return that if nothing else matches.
18:17:46 <aavogt> heatsink: it's also quite inconvenient to track that error down since I'm not directly using alex
18:17:48 <heatsink> Yeah, a dedicated exception type would have been better.
18:17:54 <heatsink> oh.
18:18:12 <heatsink> Yeah, that would be irritating.
18:18:22 <heatsink> Send hate mail to the maintainer.
18:18:24 <aavogt> so suddenly I have Error: lexical error
18:18:38 <aavogt> maintainer of alex or bytestring-csv?
18:19:00 <heatsink> bytestring-csv I think.
18:19:32 <aavogt> nah, dons will just ask for patches ;)
18:19:40 <heatsink> heh :)
18:19:46 <aavogt> which doesn't sound that difficult from what you describe
18:20:53 <gwern> hm. what option to 'ghc --make' makes it use fpstring.c/h in ./?
18:21:10 <heatsink> -I for includes
18:21:19 <heatsink> -I./
18:21:45 <bsdunx> Sorry if I shouldn't be asking here, but what port would I need on Gentoo GNU/Linux for Network.Socket.ByteString
18:22:29 <gwern> hm. -I./ doesn't seem to help
18:22:57 <gwern> bsdunx: try searching for 'network-bytestring'
18:23:50 <aavogt> heatsink: add to that bytestring-csv is already strict in producing / consuming input (due to returing Maybe [[ByteString]], and consuming a strict bytestring)
18:24:04 <gwern> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8108#a8108
18:24:12 <gwern> could I be missing some flag or pragma in the .hs?
18:24:29 <bsdunx> there's only a network port, I get Network.Socket fine, I'm really new to Haskell excuse me.
18:24:57 <gwern> bsdunx: maybe no one has packaged it up for gentoo
18:26:14 <blackh> gwern: You forgot to add fpstring.c to your ghc command?
18:26:38 <gwern> and I would that how?
18:27:36 <blackh> gwern: You would know that because if you want ghc to link something with your program, you have to pass that thing to ghc?
18:27:56 <meanburrito920_> what is the point of the id function?
18:28:07 <gwern> meanburrito920_: sometimes you have to say *something*
18:28:36 <blackh> meanburrito920_: Well, here's an example where I use it (if verbose then trace "something" else id) value
18:28:36 <meanburrito920_> so its just filler?
18:28:43 <gwern> blackh: don't see why ghc couldn't just use it directly. I've told it what directory to look in and even the name of what it needs
18:28:50 <gwern> all the pieces are there
18:28:58 <copumpkin> > filter id [True, False, True, True, True, False]
18:29:01 <copumpkin> hell yeah
18:29:18 <blackh> gwern: Add fpstring.c to your ghc command line and it will work.  It can't guess.
18:29:36 <gwern> blackh: why not?
18:29:46 <blackh> gwern: Because it hasn't been programmed to work that way.
18:30:17 <gwern> blackh: so it won't, not that it can't
18:30:29 <bsdunx> what I am trying to do is convert a String into a ByteString so that it's suitable to be used with send.
18:30:37 <ddarius> The young ones always wonder about the point of id or the point of const.
18:30:44 <heatsink> gwern: C has a global namespace and does not prescribe any directory organization for files.  Thus, a comiler doesn't know where to find a definition, unless it's explicitly stated.
18:30:47 <blackh> gwern: Well, you can decide that question.  The fact is that ghc doesn't work that wy.
18:30:48 <ddarius> bsdunx: pack
18:31:05 <gwern> ddarius: and then they learn about @pl eh
18:31:44 <bsdunx> ddarius, ya that's what I'm attempting to use, how can I concatenate like "foo" ++ bar
18:32:09 <ddarius> ByteString.append (or something like that.)  Check the documentation.
18:33:50 <bsdunx> I should probably convert before I suppose, thanks though at least I'm heading in the right direction.
18:34:28 <tez_> Hi everyone, I am a haskell newbie. Have trouble understanding monads even after reading 4 tutorials. Any idea what is the best way to go about it?
18:35:19 <ezyang> tez_: Try asking questions!
18:35:31 <ezyang> The act of forming a well-posed question is often useful on the road to understanding.
18:36:29 <tez_> okay, what I would like to know is that, what would be the situation underwhich one should consider creating his/her own monads
18:36:47 <tez_> I mean apart from standard type classes, when would you create your own customized monads for a given problem?
18:37:19 <ezyang> tez_: Good question!
18:37:21 * hackagebot upload: iteratee 0.3.4 - Iteratee-based I/O (JohnLato)
18:37:37 <ezyang> tez_: let's consider a slightly modified version of it
18:37:54 <aavogt> bsdunx: bytestrings are basically [Word8], so you probably want to encode your string into utf-8... there is a bytestring-utf or some such package
18:38:11 <ezyang> tez_: The monad can often be seen as an "interpreter" for a bunch of computations you build up with do-notation or hanging lambdas
18:38:13 <ddarius> tez_: Stop reading tutorials.
18:38:24 <ddarius> s/tutorials/monad tutorials/
18:38:30 <ezyang> tez_: So, for something like the Prompt monad, it doesn't /do/ anything unless you customize it in the first place.
18:39:04 <ezyang> You would generally write your own monad if you were doing a bunch of common operations, and then thought to yourself, "Hey, these all have the same patterns as monads", and then write the appropriate datatype
18:39:11 <ddarius> tez_: Usually you don't create your own customized monad.  You, perhaps, stack together transformers, assuming even that is necessary.
18:39:12 <Veinor> lambdabot nooooo D:
18:39:21 <ezyang> If you're having trouble grasping monads, you probably won't write your own, unless it's for a pedagogical exercise
18:39:46 <ezyang> which is useful in its own right
18:40:51 <tez_> @ddarius I am not planning to write any specific monads, I just thought thinking about it this way might help me better fathom their raison d'tre
18:41:08 <ezyang> You should definitely implement the Maybe, List and Reader monads
18:42:59 <dolio> Is it normal for 'darcs get ghc-tarballs' to take up over a gig of memory?
18:43:04 <tez_> @ezyang can you elaborate more on monds being "interpreter" for a bunch of computation one builds up with do notation?
18:43:25 <ezyang> sure!
18:43:35 <tez_> thanks
18:43:35 <ezyang> http://blog.sigfpe.com/2010/01/monads-are-trees-with-grafting.html
18:44:00 <ezyang> also http://themonadreader.wordpress.com/2010/01/26/issue-15/
18:44:44 <tez_> which article in the monad reader should I be looking at?
18:45:06 <ezyang> "Operational Monad"
18:45:13 <tez_> okay
18:45:16 <ezyang> but the "Prompt Monad" section in "Adventures" may also be of interest
18:45:21 <ezyang> I recommend reading the sigfpe one first
18:45:36 <ezyang> It's a bit more theoretical
18:45:46 <tez_> sorry, what is adventures and what is sigfpe?
18:46:00 <tez_> that's ok, in fact, I know a bit of category theory too (no monads though)
18:46:06 <copumpkin> sigfpe is a signal
18:46:12 <copumpkin> when you get a floating-point exception
18:46:30 <copumpkin> but it's also an academy-award-winning mathematician
18:46:39 <ezyang> tez_: "Adventures in Three monads" in the TMR
18:46:42 <tez_> I knew the latter
18:46:44 <tez_> oh
18:46:46 <tez_> okay
18:47:12 <ddarius> copumpkin: I'm not sure sigfpe is a "mathematician" in any formal sense, but perhaps I'm wrong.
18:47:27 <tez_> great
18:47:34 <tez_> thanks everyone
18:47:39 <tez_> will be back soon, hopefully.
18:48:12 <centrinia> What does one need to do to become a formal mathematician?
18:48:34 <copumpkin> ddarius: I could've sworn he actually had a degree in it, but I can't find any evidence of that now. Regardless, I'd still consider him a mathematician regardless of formal qualifications
18:48:49 <ddarius> centrinia: I don't know.  I would say having a doctorate in mathematics would be a sufficient but not necessarily necessary condition.
18:49:15 <copumpkin> there are a lot of people in this community who don't have doctorates in mathematics I'd consider mathematicians
18:49:21 <centrinia> What about a master's degree or a bachelor's degree?
18:49:22 <copumpkin> maybe it's just because they know so much more about math than I do though
18:49:47 <MissPiggy> my idea of mathematician is anyone that improves the understanding of mathematics -- that could include just teaching old/established stuff really well (which is what his blog does)
18:51:15 <ezyang> So, a friend of mine was complaining about the fact that if he applied a monad transformer to a monad implementing FooMonad, the resulting monad didn't have FooMonad unless he explicitly wrote an instance for it
18:51:24 <lament> MissPiggy: so i'm a mathematician because i help retards in #math?
18:51:34 <copumpkin> yep
18:51:58 * lament feels good about himself.
18:52:03 <ezyang> Do we have a cutesy trick for working around this?
18:52:14 <ezyang> (besides doing MTL style n^2 instances for everything...)
18:52:16 <copumpkin> I thought yairchu had some nice way of doing it
18:52:22 <copumpkin> but I can't remember now
18:52:27 <ezyang> looking up
18:53:21 <ezyang> hmm, I don't see anything obvious
18:53:42 <MissPiggy> lament you think it's a bad definition? :)
18:54:04 <copumpkin> preflex: seen yairchu
18:54:05 <preflex>  yairchu was last seen on #haskell 16 days, 3 hours, 34 minutes and 59 seconds ago, saying: becomes a quoter basically
18:54:08 <copumpkin> bah
18:54:33 * sbahra wonders if fax is then also a logician
18:54:55 <copumpkin> mathelogician
18:55:37 <heatsink> ezyang: Could you write a generalized instance for any FooMonad and MonadTrans?
18:55:47 <sbahra> I'm a computer scientigician.
18:55:56 <ezyang> Then you'd get overlapping instances
18:55:57 <heatsink> instance (FooMonad m, MonadTrans t) => FooMonad (t m) where foo = lift foo
18:55:59 <heatsink> oh
18:56:35 <lament> MissPiggy: i think professional mathematicians are mathematicians, and everyone else isn't
18:56:43 <heatsink> I don't see any overlap...
18:56:59 <ezyang> If the module defined /any/ transformer instances, it will overlap
18:57:57 <MissPiggy> lament ah that makes sense yeah 'mathematician as a job' type thing
18:58:08 <copumpkin> so only professional programmers are programmers?
18:58:18 <ezyang> bzzt! Incorrect!
18:58:20 <dibblego> @src interact
18:58:32 * copumpkin returns his programmer badge and pouts
18:59:02 <ezyang> copumpkin: You're a grad student. It doesn't count ;-)
18:59:19 <copumpkin> :'(
18:59:25 <heatsink> To have overlapping instances, there must be more than one way of deriving the same instance.  However, there's only one possible derivation with that rule.
18:59:54 <heatsink> Maybe the implementation can't verify it though...
19:00:53 <ezyang> IncoherentInstances prolly would do the right thing
19:00:58 <ezyang> but it makes me wince
19:01:19 <aavogt> at least they don't have  ChooseInstanceAtRandom
19:01:42 <ezyang> RussianRouletteInstances
19:02:06 * ddarius has probably done a whole lot less programming as a professional programmer than as a uh... nothing.
19:06:58 <heatsink> ezyang: I did it with FlexibleInstances, FlexibleContexts, UndecidableInstances
19:07:34 <copumpkin> that's the scary kind of undecidable instances bt
19:07:34 <copumpkin> w
19:08:05 <heatsink> I don't understand
19:08:19 <copumpkin> undecidable = no guarantee type checking will terminate
19:08:35 <copumpkin> all it takes is something like instance Monad f => Functor f where fmap = liftM
19:09:18 <aavogt> does that actually not terminate?
19:09:18 <heatsink> Yeah
19:09:29 <copumpkin> aavogt: it should terminate
19:09:48 <copumpkin> depends on what instances you have though
19:12:45 * Axman6 proposes a new fundamental theorum of computer science: everything terminates
19:12:52 <aavogt> wow, linking in ghc-api on 6.12 results in 39 M binaries?
19:12:52 <heatsink> Hmm, type functions are useful, but also irritating when the function's domain is a phantom type.
19:14:42 <ksf> 6.12 can link dynamically!
19:14:42 <copumpkin> aavogt: isn't it wonderful?
19:14:59 <heatsink> GHC won't infer the domain from the range, so I have to add a type annotation to a perfectly valid program.
19:15:10 * heatsink is waiting for weak symbol support
19:15:34 * copumpkin wants stronger symbols!
19:15:48 <MissPiggy> Fundamental Theorem of Cellular Automata: Everyone gets their first GOL simulator wrong (ovewriting the memory instead of using a swap)
19:16:04 * heatsink sends copumpkin's symbols to the gym so they can... gymbal...
19:16:26 <copumpkin> do we have a fundamental theorem of fundamental theorems?
19:16:44 <ezyang> MissPiggy: Not if you're in Haskell! :o)
19:17:22 <twink> GOL?
19:17:47 <ksf> iirc gol can be done in constant space
19:17:59 <ddarius> Axman6: In one sense everything does terminate.  In another sense, everything terminates or performs a (detectibly) cyclical loop.
19:18:01 <ksf> ...just don't try to do it in one pass.
19:18:28 <ksf> ...constant space on an array, /me means. of course you should use a sparse structure.
19:19:18 <heatsink> copumpkin: The opposite of a correct theorem is an incorrect theorem.  The opposite of a fundamental theorem is a fundamental theorem in a different axiomatic basis.
19:19:30 <heatsink> Or something like that, my lingo may not be quite right
19:20:28 <ksf> I should develop a mathematical system based on the axiom that all axioms are invalid
19:21:25 <ksf> ...I think proving anything can then be reduced to proving that oneself does exist.
19:22:26 <MissPiggy> I think proving anything can be reduced to proving a turing machine halts
19:22:30 <ezyang> is that... like Nihilskell?
19:22:41 <ksf> for if one wouldn't exist, one couldn't impose the axiom, therefore every axiom would be valid and the system would be inconsistent.
19:27:54 <dancor> is haskell98 still the most recent major revision?
19:28:16 <copumpkin> no
19:28:38 <copumpkin> 2010 is done, but no report exists for it yet
19:28:48 <dancor> actually: "The latest major revision is still Haskell 98."
19:28:54 <dancor> http://hackage.haskell.org/trac/haskell-prime/wiki
19:28:57 <ksf> it's still the default for 6.12, though. at least DoIfThenElse doesn't work.
19:29:12 <copumpkin> hrmpf
19:29:32 <ksf> does it take that much time to apply such a small diff?
19:30:33 <ksf> ...but then, they could possibly have the idea of splitting up the prelude now that we have hierachical modules, and are bikeshedding the topic
19:34:25 <dancor> ksf isn't that just a very simple demonstrably inconsistent system
19:34:31 <dancor> i guess the simplest one
19:47:29 <trie> Can some one explain what exactly is meant by a"rigid" type variable"?
19:48:19 <jmcarthur> it's polymorphic, but every use of it must be as the same type
19:48:33 <jmcarthur> there's probably a more formal explanation, but that's all i know how to say
19:48:53 <trie> is that not true for all type variables in Haskell??
19:49:08 <ksf> one example would be a type annotation that says "a" but the compiler infers it to be "Int"
19:49:54 <ksf> a is rigid because the annotation rigidifies it to be a variable type, not a concrete one.
19:50:01 <trie> ksf: Can you give a concrete example?
19:50:09 <jmcarthur> > (5 :: Int) :: a
19:50:25 <jmcarthur> lambdabot is gone :(
19:50:53 <ksf> it's just like "less polymorphic that expected", just into the other direction.
19:50:55 <trie> I get it. But are there none rigid type variables?
19:50:56 <dolio> It has something to do with the type inference algorithm. Rigid variables probably corresponding to the quantified variables, and the other ones (wobbly?) being the unification variables.
19:51:07 <Ziphilt> is BONUS here, by any chance?
19:51:10 <ksf> yep.
19:51:37 <trie> any examples of a wobbly type var?
19:51:47 <Ziphilt> 'cause i wanted to chat with such a person
19:51:54 <ksf> > undefined
19:52:11 <copumpkin> Ziphilt: probably asleep
19:52:17 <Ziphilt> okay
19:52:18 <trie> ksf: Where is the type variable?
19:52:29 <ksf> undefined has type a.
19:52:34 <Ziphilt> i wanted to discuss learnyouahaskell
19:53:06 <trie> So are rigid ones always programmer supplied?
19:53:09 <ksf> Num a => a is non-rigid, too, but has a typeclass constraint. missing that would give another error.
19:53:11 <copumpkin> I figured :P
19:53:15 <ksf> trie, exactly
19:53:31 <ksf> if in doubt, comment out all signatures and infer them with ghci
19:53:35 <copumpkin> @djinn Maybe a -> Maybe b
19:53:42 <ddarius> dolio: "flexible"
19:53:54 <ksf> soft
19:53:54 <roconnor> f _ = Nothing
19:54:04 <ksf> just like in rigid body / soft body.
19:54:05 <copumpkin> roconnor: nuh uh!
19:54:12 <copumpkin> roconnor: that's a -> Maybe b ;)
19:54:19 <roconnor> damn it
19:54:27 <ddarius> copumpkin: That's a valid implementation.
19:54:28 <jmcarthur> roconnor is a bad bot
19:54:28 <scutigera> ksf: are there magic ghc flags to list just the signatures in a file ?
19:54:36 <copumpkin> ddarius: I know, but it's more general than I wanted it!
19:54:37 <roconnor> f Nothing = Nothing
19:54:41 <jmcarthur> ddarius: not the one djinn would have come up with, is it?
19:54:42 <roconnor> f (Just _) = Nothing
19:54:51 <dolio> ddarius: That was my first thought, too, but the only thing I remember being called "flexible" in ghc's extensions are instances/contexts.
19:54:52 <ddarius> jmcarthur: I'm not sure.
19:54:54 <jmcarthur> roconnor: djinn uses case :(
19:55:11 <ddarius> dolio: It definitely is "flexible."  "wobbly" is something else.
19:55:16 <dolio> Ah, okay.
19:55:20 <ksf> scutigera, there's editor support to get the signature of the thing under the cursor.
19:55:37 <dolio> Oh, wobbly types have to do with GADTs.
19:55:43 <ddarius> Yes.
19:56:04 <ksf> are they related to squiggly arrows?
19:56:37 <scutigera> ksf: I've seen that for prelude functions, but I haven't tried to make it work for files I'm working on.  I just :t in ghci
19:57:08 <aavogt> :browse Module -- dumps all the signatures from that module
19:58:22 <scutigera> aavogt: right.  could do that and cut & paste :-)  I let ghci figure out my types cause usually I don't know what they are or I get them wrong :-)
19:59:27 <ddarius> To prove, forall a. T(a), you introduce a fresh constant, c, and prove T(c).  c is not anything in particular, but is distinct from everything but itself.
20:00:00 <ksf> I think about 70% of the time I don't care about the signature until I haddock the code, and the rest of the time I write the type sig first to have something to cling onto while writing the function.
20:00:37 <copumpkin> wobbly for types sounds like something conor would come up with
20:02:46 <ddarius> c is effectively a rigid type variable.
20:08:12 <ddarius> When proving, exists a. T(a), you need to find some t such that T(t) holds.  This is usually done by introducting a variable v, and proving T(v), and seeing what (unification) constraints that places on v.  In this case, v is called a flexible variable.  It can be any (one) thing as long as it's consistent.
20:10:40 <ddarius> One way to roughly summarize the above is: a rigid variable only unifies with itself, a flexible variable can unify with anything.
20:11:36 <trie> I think I get it. The above summary seems pretty intutive.
20:12:07 <copumpkin> trie: oh, hi patricia!
20:12:17 <ezyang> lol
20:12:56 <trie> heh heh
20:13:17 <trie> How did you know my first name?
20:13:29 <copumpkin> you must not remember me
20:13:35 <copumpkin> I was on your floor freshman year
20:13:55 <badsheepy> and now everyone knows it :p
20:18:16 <scutigera> why is there an otherwise.  it evals to true, so why not use true instead of introducing another keyword ?
20:19:11 <ksf> there's no keyword called "otherwise"
20:19:15 <trie> scutigera: otherwise is not a keyword just a top level def in the prelude to aid readability
20:19:17 <dolio> Because you don't write sentences like "if X, do A, if Y, do B, True, do C."
20:19:23 <aavogt> it looks pretty
20:19:52 <scutigera> > otherwise
20:20:01 <copumpkin> it's not a keyword, just a value
20:20:09 <aavogt> and if you're bothered by it being in scope, you don't have to import it from the Prelude
20:20:14 <badsheepy> course based on that, if should be called either :p
20:20:32 <scutigera> no bother , and that answers the question.  I could just use True in place of it.
20:20:37 <badsheepy> which slightly bugs me every single time :o
20:21:02 <aavogt> either doesn't sound right to me
20:21:31 <badsheepy> perhaps not, but if doesnt require an else in normal thought imo
20:22:09 <badsheepy> i suppose you could argue its just implied :)
20:24:50 <scutigera> lambdabot on vacation ?
20:25:26 <copumpkin> yep
20:25:41 <scutigera> daisy, daisy, ...
20:50:49 <o-_-o> any sites which track latest haskell news (like reddit.com/r/haskell) but better ?
20:51:10 <scutigera> haskell-cafe haskell weekly news
20:51:21 <copumpkin> reddit might be your best bet, otherwise http://planet.haskell.org/ or haskell-cafe, or the haskell twitterverse
20:53:23 <ezyang> I want a hash function. Which one should I use?
20:55:37 <scutigera> what are you hashing ?
20:55:55 <ezyang> integers
20:56:02 <ezyang> and I need 32-bit hash keys
20:56:17 <scutigera> modulo is always nice and easy
20:56:20 <copumpkin> http://hackage.haskell.org/package/data-hash maybe?
20:56:22 <copumpkin> dunno
20:56:30 <copumpkin> it'd be nice to get it for free out of Data.Data or something
20:56:51 <ezyang> Data.Hash is 64-bit :-(
21:09:11 <Sagi> ezyang: I think (no guarantees here) that if the hash function has good properties that you can just use the first 32 bits of the output.
21:09:21 <Sagi> depends on what you want to do with it though.
21:10:19 <ezyang> it's for performance purposes
21:10:25 <ezyang> I'm doing benchmarking
21:10:38 <ezyang> and I want to make sure a reference impl isn't being unduly hurt for doing hashing
21:11:54 <tommd> what the... is gtk2hs made in BOTH chs and hsc?  Needing both hsc2hs and c2hs?
21:14:02 <ezyang> Is there a convenient "timer" function in Haskell?
21:16:49 <Saizan> @hackage timeIt
21:16:58 <ezyang> cool
22:36:34 <Sagi> I'm using System.Console.GetOpt to parse arguments to my program, but I cannot find an example where the arguments are expected to be in some format, throwing errors if they are not.
22:37:08 <Sagi> In my own situation, I want to have IP(v6) addressess as arguments and throw a descriptive error when a typo is made.
22:37:38 <Sagi> I found a decent parsec parser, so that's not the problem. I was just wondering how (and where) I should throw the error.
22:38:58 <Sagi> the getOpt function seems to return an error-list, but I don't think I can add this kind of error to that list, which is too bad imo :( If that _is_ possible, can someone show me a short example?
22:42:23 <dolio> I think about all you can do is make each argument produce something like Either e Result.
22:42:45 <dolio> Or 'Settings -> Either e Settings'.
22:43:40 <dolio> Anyhow, then you can compose them at the end to produce an overall result, or an error if any one of them produces an error.
22:44:39 <dolio> That's the method I've seen suggested for options that need to involve side effects (like, say, reading a file specified by the argument), but it works with throwing errors, too.
22:46:52 <Sagi> hmm
22:47:07 <dolio> Granted, it's not ideal.
22:47:25 <dolio> I haven't seen an argument handling system that I really like yet.
22:48:03 <Sagi> I think I can make that word. I was quite amazed however that the GetOpt module does not contain anything like this, because it would be good practice to validate your input.
22:48:06 <copumpkin> http://community.haskell.org/~ndm/cmdargs/ is quite nice
22:48:13 <copumpkin> if you aren't too bothered by impurity
22:48:16 <Sagi> s/word/work/
22:49:33 <dolio> Maybe one day, we'll have typed operating systems, and all programs will have types like File -> IPAddr -> Whatever. And everything will be wonderful.
22:49:45 <copumpkin> that'd be nice
22:49:59 <sinelaw> except IPAddr should be an unforgeable ID
22:50:07 <Sagi> :)
22:50:22 <dolio> And all our Margaritaville brand margarita machines will have a built-in salsa dispenser.
22:50:24 <sinelaw> and files shouldn't exist
22:51:53 <sinelaw> ...except on Mondays
22:52:28 <sinelaw> no really, why do we need "files"? Why can't we just have values that are automatically persisted if we want them to be?
22:53:15 <dolio> copumpkin: How does this work? It looks evil.
22:53:39 <sinelaw> copumpkin, how goes your paper?
22:53:44 <copumpkin> dolio: it is thoroughly evil, but at least the evil is confined to program startup
22:53:50 <copumpkin> sinelaw: feel thoroughly unmotivated
22:53:55 <copumpkin> I'm very thorough tonight
22:54:32 * dolio is Thoreau tonight.
22:54:39 <sinelaw> copumpkin, ah. i also got fed up with mine, so preempted it at some point pretending that it's finished.
22:54:40 <copumpkin> dolio: unsafePerformIO is pretty pervasive in the code
22:54:52 <dolio> That was my suspicion.
22:55:00 <sinelaw> copumpkin, just write a "Conclusions" section, and you're done!
22:55:03 <sinelaw> like me
22:55:17 <copumpkin> sinelaw: well I have to finish mine for class, but I'm feeling a little down right now so will probably procrastinate
22:55:22 <copumpkin> :)
22:55:36 <sinelaw> procrastination, mother of all mothers
22:55:59 <sinelaw> also one of the longer words i know
22:56:06 <sinelaw> ain't it fun to be silly
22:56:13 <sinelaw> no.
22:56:15 <copumpkin> not antidisestablishmentarian?
22:56:28 <dolio> In my experience, papers and projects are best done in a fevered sweat during the last possible period of time they could be done, where you never actually know if you'll finish in time.
22:56:44 <copumpkin> dolio: probably right
22:56:50 <sinelaw> dolio and sentences 2
22:56:51 <copumpkin> that's how I've approached them in the past
22:57:19 <sinelaw> only if it's stuff you don't care too much about. if you want good results, it's not exactly the best of ways
22:57:36 <sinelaw> though it's a good way to get things to the appearance of "finished"
22:58:55 <freedrull> is there a cabal package for gtk2hs?
22:59:02 <ddarius> no
22:59:38 <sinelaw> it's a cabal
22:59:46 <sinelaw> ....by the creators of gtk2hs
22:59:54 <sinelaw> to not have a cabal
23:00:02 <freedrull> what
23:00:07 <sinelaw> freedrull, ignore sinelaw
23:00:16 <copumpkin> head explodes
23:00:18 <freedrull> ok ^_^
23:00:19 <sinelaw> i'm after 4 hours of sleep
23:25:03 <sinelaw> i want to create bindings for some C stuff, that works by transforming images
23:25:08 <sinelaw> i'd like it to be pure
23:26:57 <sinelaw> unfortunately, the output of the function needs a pointer  to pre-allocated dat to be efficient
23:27:07 <sinelaw> and also, the data it outputs needs to be freed at some point
23:27:40 <sinelaw> how can i wrap it so it looks pure? using unsafeperformIO, but how to manage the allocations?
23:30:58 <ddarius> Use ForeignPtr and finalizers?
