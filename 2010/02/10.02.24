00:26:12 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/2356
00:30:24 <g06|in> Hi, I'm a newbie in haskell and trying to learn the code here http://www.haskell.org/haskellwiki/Memoization. I don't understand why this http://dpaste.com/hold/164039/ is slow and this http://dpaste.com/hold/164040/ fast :(
00:31:56 <cebewee> g06|in: think about how often fib(n) is computed in the first implementation
00:34:00 <cebewee> (and now i need to think about the fast implementation ;))
00:34:56 <g06|in> cebewee: but subsequent calls to the slow_fib fn should be fast since the function might have been invoked at some point in the past! Right?
00:35:12 <Botje> g06|in: no, sorry.
00:35:21 <Botje> haskell does not automatically remember previous function results
00:35:27 <Botje> that would be a HUGE space leak
00:35:35 <g06|in> Botje: ok
00:35:48 <Botje> (although it would be nice to have the compiler automatically memoize functions on demand)
00:36:06 <g06|in> Botje: memoizing means caching previous results, right?
00:36:09 <Botje> yes
00:36:30 <ski> dolio,Saizan : to clarify, i suppose my complaint is with the following
00:36:34 <g06|in> Botje, and in the second case, that's what is happening. right?
00:36:36 <c_wraith> I feel like it should be possible to auto-memoize a function with TH.  I'm just...  Not sure how.
00:36:39 <ski> 7.6. Class and instance declarations - 7.6.3.4. Overlapping instances <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap>
00:36:47 <ski> "Suppose that from the RHS of `f' we get the constraint `C Int [b]'. But GHC does not commit to instance (C), because in a particular call of `f', `b' might be instantiate to `Int', in which case instance (D) would be more specific still. So GHC rejects the program."
00:36:52 <ski> "Notice that we gave a type signature to `f', so GHC had to check that `f' has the specified type. Suppose instead we do not give a type signature, asking GHC to infer it instead. In this case, GHC will refrain from simplifying the constraint `C Int [b]' (for the same reason as before) but, rather than rejecting the program, it will infer the type `f :: C Int [b] => [b] -> [b]'. That postpones the question of which instance to
00:37:44 <g06|in> Botje: I also don't know what the !! is for
00:37:56 <Botje> g06|in: indexing into a list
00:38:01 <cebewee> > [1,2,3] !! 0
00:38:01 <c_wraith> > [12, 13, 14] !! 2
00:38:02 <ski> what i'm seeing is that GHC *does* appear to "commit to instance (C)" (in the language of the above), even though `OverlappingInstances', but not `IncoherentInstances' was used
00:38:02 <lambdabot>   1
00:38:03 <lambdabot>   14
00:38:16 <Botje> intuitively, list !! n = "take the n-1th element from list"
00:38:33 <cebewee> n+1th
00:38:43 <ski> namely, it appears to "commit to instance (C)" if there is no "instance (D)" visible in the module in question
00:38:45 <Botje> uh
00:38:46 <Botje> right
00:38:55 <Botje> it's still morning here :P
00:39:35 <c_wraith> g06|in: the specific way !! is being used there is an operator section, if you're unfamiliar with those
00:40:08 <g06|in> c_wraith: don't want to ask you for an explanation? but can you provide a link/pointer?
00:40:27 <c_wraith> g06|in: it's nothing amazing.  It's just a partially applied infix function.
00:40:52 <cebewee> hm, so if you understand it correctly, memoized_fib is an infinite list wrapped with an "select me an element" function
00:41:05 <c_wraith> > let x = ([1, 2, 3] !!) in (x 0, x 1, x 2)
00:41:06 <lambdabot>   (1,2,3)
00:41:13 <g06|in> c_wraith: got it
00:41:28 * ski tries to recall whether `add revision' or `modify' will add an annotation for a hpaste ..
00:42:43 <cebewee> so computing a very large fib value will fill up memory for the rest of the program run?
00:42:59 <c_wraith> cebewee: no, it'll get gc'd after the original call returns
00:43:18 <c_wraith> cebewee: the cache only exists in the scope of the function
00:43:49 <g06|in> c_wraith: (map fib [0 ..] !!) is it => (map fib [0 ..]) !!
00:44:11 <cebewee> g06|in: yes
00:44:27 <c_wraith> well, it's more precisely \x -> (map fib [0 ..]) !! x
00:44:36 <g06|in> c_wraith:
00:44:40 <g06|in> c_wraith: got that
00:44:44 <c_wraith> But yes.
00:44:49 <g06|in> c_wraith: but I still haven't understood how memoization works here then :(
00:45:01 <g06|in> c_wraith: what I mean is...
00:46:20 <g06|in> c_wraith: if I understand correctly the the results of fib calls on 0, 1, 2, 3 stay on a temp list on which !! is invoked. but how would fib(x) check if fib(x) was already computed and so on... ?
00:46:57 <g06|in> c_wraith: ah! I see it.. thanks c_wraith and cebewee
00:47:33 <c_wraith> Of course, there's a better definition for haskell
00:47:53 <g06|in> ?
00:48:11 <c_wraith> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
00:48:12 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:48:18 <g06|in> c_wraith:
00:48:38 <c_wraith> since the language is lazy, it's often most sane to just make infinite lists when working with infinite sequences
00:48:45 <g06|in> c_wraith: don't understand this one
00:49:23 <cebewee> g06|in: you take a list, starting with 0,1,
00:49:48 <g06|in> cebewee, c_wraith: tell me what happens when fibs gets called (recursively) the first time
00:49:56 <cebewee> g06|in: take the same list, writing it below, shifted by 1 element (fibs vs. tail fibs)
00:50:07 <cebewee> and add both lists together
00:50:08 <c_wraith> g06|in: in my example, or in your second case?
00:51:21 <g06|in> c_wraith: in memoized_function I was wondering if the temp list that map produces (which I presume is used for memoization) caches every single result. Just caching the last two should've been enuf right?
00:51:51 <c_wraith> g06|in: it will cache all of them, which is more than necessary, yes.
00:52:14 <g06|in> c_wraith: in the example you gave me, when "fibs" and "tail fibs" are evaluated the first time I am unable to understand what happens
00:52:44 <g06|in> c_wraith: you have 0, 1 and then you call fibs which sees 0, 1 (because nothing more was added)...
00:53:24 <c_wraith> It sees 0, 1, and "a function that will give the next element when it's evaluated"
00:54:03 <g06|in> but that function again has just 0, 1, and fibs...
00:54:21 <c_wraith> when that function is evaluated, it looks at the list, and sees 0 and 1, and adds them together, puts that value on the list, and adds instructions on how to calculate the next element of the list
00:55:10 <c_wraith> and since nothing ever appends a [] to the list, the list never ends
00:55:41 * ski annotated "Incoherent instances" with "Incoherent overlapping" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16988#a22947>
00:55:44 <g06|in> so if I let it run it will keep running?
00:56:02 <ski> @tell dolio any comment on <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=16988#a22947> ?
00:56:02 <lambdabot> Consider it noted.
00:56:03 <c_wraith> yes.  Until the numbers get big enough that they don't fit in memory, which will take...  a while. :)
00:57:26 <g06|in> c_wraith: thanks!
00:58:03 <c_wraith> @src zipWith
00:58:03 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:58:03 <lambdabot> zipWith _ _      _      = []
00:58:25 <c_wraith> I feel like seeing that helps explain what's going on a bit better.
00:59:26 <g06|in> c_wraith: first line : fn applied to heads in lists and rest of lists are recursed with the same fn
00:59:27 <g06|in> what
00:59:34 <g06|in> c_wraith: what's the 2nd line?
00:59:47 <c_wraith> it's the case where either of the input lists end
00:59:56 <c_wraith> That is, they're not made with the (:) constructor
01:00:20 <g06|in> but I thought that would be more like zipWith _ [] [] = []
01:00:32 <c_wraith> That only matches if *both* lists end
01:00:42 <c_wraith> The way it's written matches all 3 other cases
01:00:54 <c_wraith> (first list ends, second list ends, both lists end)
01:01:33 <g06|in> c_wraith: agree with what I suggested. But _ matches anything, right?
01:01:48 <mreh> _ is the wildcard, it matches the whole universe
01:01:59 <c_wraith> yes, but matches are tried top-down, in the order the alternatives are listed in source.
01:02:24 <mreh> unless you are programming in mathematica
01:02:34 <g06|in> c_wraith: but then i dont understand why the second variant is not always chosen
01:03:11 <c_wraith> g06|in: because the things that do match the first variant go to it, because it's written first.  Order does matter, for pattern matches
01:03:40 <g06|in> hmmm
01:04:26 <c_wraith> That's even used in the fibs definitions you were asking about.  They both checked the more specific cases before the general case that overlapped them.  any number matches "n", after all
01:04:51 <g06|in> I see
01:04:56 <g06|in> let me go back and start reading again from the beginning :(
01:05:53 <c_wraith> I need sleep.  Something about work in the morning.  Good luck with your studies. :)
01:06:40 <g06|in> c_wraith: thanks! thought will look up something on IO as well today; but looks like may be I'll have to postpone it some other time
01:09:28 <mreh> i had a discussion with someone yesterday, he does scheme, I do haskell, he likes strictly prefix-only notation, I don't
01:09:48 <Zao> He's obviously fundamentally disturbed.
01:10:12 <Zao> Easier to see flow at a glance, I guess, but at what cost.
01:10:28 <mreh> he has a stack augmentation in his brain
01:11:04 <mreh> well the conversation went to brackets of course, he conceded that it is hard to read (thank goodness), but he suggested you use an editor to read it
01:11:13 <mreh> swings and round-a-bouts I suppose
01:17:37 * ski thinks sexps are ok
01:18:06 <ski> (mreh : "stack augmentation in his brain" meaning ?)
01:18:45 <mreh> he's more machine than man
01:19:02 <ski> a borg ?
01:19:48 * ski doesn't find properly indented sexp code that hard to read ..
01:21:06 <ski> (of course you need to know which identifiers are bound to syntax, but that usually doesn't change that often, so it is mostly comparable to knowing about `if',`do',`where',&c. in haskell)
01:21:30 <jlouis> ski: same here. s-exp syntax is not particularly harder to read for me
01:22:21 <mreh> scheme eschews all syntax does it not?
01:22:51 <QtPlatypus> mreh: It says it does but there is a little bit of syntax hidden ther
01:23:26 <ski> "syntax" here means not concrete syntax, but things that are not applications, i.e. `let',`lambda',`define',`letrec',`define-syntax',&c.
01:24:02 <ski> e.g. `lambda' and `let' are "just" identifiers bound to syntax in Scheme, so you can shadow those identifiers if you like
01:24:43 <theorbtwo> Anybody see how http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22948#a22948 can output nothing?  I'm pretty sure that it was working OK the last time I tried it...
01:25:11 <theorbtwo> (It is called with one argument, which is a valid file.)
01:25:12 <ski> e.g.
01:25:14 <ski>   ((lambda (lambda) `(,lambda ',lambda)) '(lambda (lambda) `(,lambda ',lambda)))
01:25:49 <ski> is an obfuscated quine that shadows the identifier `lambda' in some sub-scopes
01:28:08 <ski> `args !! 0' can be replaced by `head args'
01:28:28 <ski> `key_filename <- return ...' can be replaced by `let key_filename = ...'
01:29:24 <ski> `args <- System.Environment.getArgs' and later `head args' (/ `args !! 0') can be replaced by `arg : _ <- System.Environment.getArgs' and later `arg'
01:30:04 <theorbtwo> Got it.  Somehow, ./dumpkey ended up being a zero-length file, but new enough that ghc --make didn't rebuild it.  Not a haskell problem.
01:30:11 <theorbtwo> ski: Thanks.  The last of those is useful.
01:30:21 <ski> (similarly, `eitherKey <- return (...)' can be replaced by `let eitherKey = ...')
01:31:37 <ski> in this case, since you only use `eitherKey' in a `case', you can replace
01:31:46 <theorbtwo> Yeah.  I know that foo <- return bar is equiv to let foo = bar, but I'm not sure I like flipping back and forth between let and <-, especially with the high syntatic cost of let ... in.
01:31:52 <ski>   let eitherKey = myRunParser key key_raw key_filename
01:31:57 <ski>   case eitherKey of
01:31:59 <ski>     ...
01:32:01 <ski> with
01:32:07 <ski>   case myRunParser key key_raw key_filename of
01:32:09 <ski>     ...
01:32:25 <ski> (but maybe you prefer naming it ?)
01:32:34 <ski> @type print
01:32:35 <lambdabot> forall a. (Show a) => a -> IO ()
01:33:04 <ski> `print ...' already has type `IO ()', so the `return ()' after them are not needed
01:34:07 <theorbtwo> @type putStr
01:34:08 <lambdabot> String -> IO ()
01:34:12 <ski> (and since this is `main', which can have type `IO a' for any type `a' (you may like this or not, but that's a fact), one could leave out the `return ()'s even if the preceding actions didn't have type `IO a' for `a' being `()', as long as the types unify)
01:35:17 * Twey thinks main should :: IO Int and return an exit code
01:35:44 <ski> i see you also don't use `key_h' more than to get `key_raw' just after
01:35:48 <theorbtwo> ski: Yeah, "as long as the types unify" is the thing here.
01:36:05 <ski> if you prefer not naming `key_h', you can say
01:36:07 <theorbtwo> ski: Yes, but I might soon.
01:36:16 <ski>   key_raw <- hGetContents =<< openBinaryFile key_filename ReadMode
01:36:28 <ski> theorbtwo : you might what soon ?
01:36:28 <Botje> Twey: that would clutter a lot of programs with needless "return 0" statements
01:37:19 <Twey> Botje: class ExitValue where; instance ExitValue Int; instance ExitValue (); main :: ExitValue a => IO a
01:37:25 <ski> @type System.Exit.exitWith  -- Twey : s/Int/ExitCode/
01:37:26 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
01:37:29 <FliPPeh> I used to clutter my programs with "return ()" ;x
01:37:36 * mreh wonders if you could represent all kinds of syntax trees with binary trees...
01:37:37 <Twey> ski: But that's not main :Ã¾
01:37:58 <ski> Twey : no, but if you want `main' to return an exit code, should it not be of type `ExitCode' ?
01:37:59 <Twey> mreh: Sure (see: Lisp)
01:38:03 <mreh> you can encode a Btree as a binary tree can't you?
01:38:15 <Twey> ski: Exit codes are integers on all platforms I know of
01:38:29 <theorbtwo> I'm likely to make myRunParser take a handle instead of a string soon.
01:38:31 <ski> still, `ExitCode' is a separate type, in Haskell
01:38:42 <Twey> ski: Well, I suppose so, then
01:39:08 <ski> (but maybe you argue that we ought to have `type ExitCode = Int' .. that could be argued, i suppose)
01:39:11 <theorbtwo> I think, though I'm not sure, that the lazyness of a string isn't enough for me; I'm getting stack overflow errors that I can't track down.
01:39:52 <theorbtwo> I'm not sure I'm thrilled with var <- function =<< function.  It's very... odd.
01:39:56 <JacksonBrown> There are some truths which are so obvious that for this very reason
01:39:58 <Botje> Twey: i can live with that :P
01:40:06 <JacksonBrown> they are not seen or at least not recognized by ordinary people.
01:40:16 <JacksonBrown> They sometimes pass by such truisms as though blind and are most
01:40:18 <ski> theorbtwo : i prefer it to `pat <- action >>= function'
01:40:20 <Twey> > fromEnum ()
01:40:22 <lambdabot>   0
01:40:26 <JacksonBrown> astonished when someone suddenly discovers what everyone really ought to
01:40:29 <Twey> Botje: Could just use Enum, really
01:40:36 <JacksonBrown> know.
01:40:46 <JacksonBrown> Columbus's eggs lie around by the hundreds of thousands, but Columbuses
01:40:53 <theorbtwo> > fromEnum (1)
01:40:55 <lambdabot>   1
01:40:55 <ski> JacksonBrown : how is this related to Haskell ?
01:40:56 <JacksonBrown> are met with less frequently.
01:40:56 <Botje> okay
01:41:06 <JacksonBrown> Thus men without exception wander about in the garden of Nature; they
01:41:15 <Botje> spammm!
01:41:16 <JacksonBrown> imagine that they know practically everything and yet with few
01:41:26 <JacksonBrown> exceptions pass blindly by one of the most patent principles of Nature's
01:41:27 <Botje> or possibly a mispaste.
01:41:36 <JacksonBrown> rule: the inner segregation of the species of all living beings on this
01:41:46 <JacksonBrown> earth.
01:41:56 <JacksonBrown> Even the most superficial observation shows that Nature's restricted
01:42:04 <Botje> annoying anyway
01:42:06 <JacksonBrown> form of propagation and increase is an almost rigid basic law of all the
01:42:06 <Botje> any ops around?
01:42:16 <ski> use `@where ops'
01:42:16 <JacksonBrown> innumerable forms of expression of her vital urge.
01:42:26 <JacksonBrown> Every animal mates only with a member of the same species.
01:42:34 <ski> @where ops
01:42:34 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
01:42:36 <JacksonBrown> The titmouse seeks the titmouse, the finch the finch, the stork the
01:42:36 <ski> like that
01:42:46 <JacksonBrown> stork, the field mouse the field mouse, the dormouse the dormouse, the
01:42:51 --- mode: ChanServ set +o Saizan
01:42:53 <xerox> JacksonBrown: ?
01:42:56 <JacksonBrown> wolf the she-wolf, etc.
01:43:02 --- mode: Saizan set +b *!*ZCDu56cDH@2001:470:c070:ff6a:7a61:210a:c4d:*
01:43:02 --- kick: JacksonBrown was kicked by Saizan (JacksonBrown)
01:43:09 <LMolr> heh
01:43:18 --- mode: Saizan set -o Saizan
01:43:29 <Botje> oh.
01:43:34 <Botje> it was an excerpt from mein kampf
01:43:36 <Botje> *sigh*
01:43:57 * Botje holds up a cardboard sign with a three
01:45:13 <tensorpudding> that excerpt is pretty boring
01:48:31 <KNOWN_EARTHWORM> tpww 66/67
01:48:43 <xerox> another?
01:48:48 <KNOWN_EARTHWORM> anothe rwhat
01:49:05 <KNOWN_EARTHWORM> hello
01:49:06 <KNOWN_EARTHWORM> rucas here
01:49:13 <xerox> hi rucas
01:49:35 <KNOWN_EARTHWORM> where is my can_flood status
01:49:50 <xerox> what are you talking about
01:51:06 <tensorpudding> can_flood is set to nil
01:53:59 * hackagebot upload: hmatrix-glpk 0.1.0 - Linear Programming based on GLPK (AlbertoRuiz)
01:54:36 <witwewnis> Hows haskell progressing?
01:56:22 <silver> good
01:57:07 <theorbtwo> Hm, is there any nice way to do (key_filename : res_name : res_type : []) <- System.Environment.getArgs , but have res_type be the read of the arugment?
01:57:20 <witwewnis> Same level as Ruby for instance?
01:57:31 <theorbtwo> res_type should be an Integer.
01:57:39 <witwewnis> nearing that level?
01:58:02 <tensorpudding> @type getArgs
01:58:04 <lambdabot> Not in scope: `getArgs'
01:58:06 <tensorpudding> doh
01:58:25 <witwewnis> I guess not
01:58:41 <witwewnis> nevermind
01:58:46 <theorbtwo> @type System.Environment.getArgs
01:58:48 <lambdabot> IO [String]
01:59:13 <Botje> theorbtwo: [key_filename, res_name, res_type] <- getArgs
01:59:17 <witwewnis> There are more users here than last time I was here.
01:59:23 <tensorpudding> res_type has to be a String
01:59:28 <Botje> witwewnis: we're failing at avoiding success.
01:59:31 <witwewnis> Seems like the language have gone long way
01:59:47 <witwewnis> Borje: lol i see
02:00:20 <tensorpudding> the original idea was that haskell would not compromise its flexibility or usability as a research platform for success
02:00:36 <Saizan> theorbtwo: no, you've to use read separately
02:01:04 <Saizan> or reads, so you can see if the parse fails
02:02:49 <tensorpudding> @type reads
02:02:50 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:03:27 <theorbtwo> Saizan: Handling parse errors here seems like more trouble then it's worth.
02:03:32 <tensorpudding> > reads "1 2 3 4 5" :: [(Int, String)]
02:03:33 <lambdabot>   [(1," 2 3 4 5")]
02:04:53 <theorbtwo> tensorpudding: While useful elsewhere, it isn't terribly useful here.
02:04:58 <theorbtwo> Hm.
02:05:11 <theorbtwo> > reads "12 34" :: [(Integer, String)]
02:05:12 <lambdabot>   [(12," 34")]
02:05:18 <theorbtwo> OK.
02:06:58 <tensorpudding> > reads "123451c123214"
02:06:59 <lambdabot>   []
02:07:06 <guerrilla> if i do not implicitely or explicitely import the prelude, what do I import to get Integer?
02:07:24 <tensorpudding> @hoogle Integer
02:07:24 <lambdabot> Text.Parsec.Token integer :: GenTokenParser s u m -> ParsecT s u m Integer
02:07:24 <lambdabot> Text.PrettyPrint.HughesPJ integer :: Integer -> Doc
02:07:24 <lambdabot> Language.Haskell.TH.PprLib integer :: Integer -> Doc
02:07:28 <tensorpudding> doh
02:07:44 <theorbtwo> Yeah.  [key_filename : res_name : res_type_string] <- System.Environment.getArgs doesn't seem to DWIM; I end up getting several Chars.
02:07:56 <guerrilla> tensorpudding: yeah.. i did that..
02:08:07 <tensorpudding> want to say GHC.Num or something like that
02:08:20 <guerrilla> tensorpudding: ok, ill check that out
02:08:21 <Botje> theorbtwo: commas instead of :
02:08:28 <Botje> 10:58 < Botje> theorbtwo: [key_filename, res_name, res_type] <- getArgs
02:08:40 <guerrilla> tensorpudding: seems like it. http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/GHC-Num.html
02:09:56 <tensorpudding> why do you not want to import the prelude though?
02:10:14 <tensorpudding> if you want to avoid conflicts, you could import it with some things hidden
02:12:33 <guerrilla> tensorpudding: yeah, right. that's true. well, this is a good learning experience anyway- finding out where things really come from :)
02:24:51 <ski> theorbtwo : replace `res_type' there with a view pattern `(read -> res_type)' ?
02:25:22 <ski> you can use `reads' (or similar), if you want any read error to occur at this point
02:26:13 <ski> e.g. if you have an `readM :: (MonadPlus m,Read a) => String -> m a', then you can use a view pattern `readM -> Just res_type'
02:26:44 <ski> if there is no parse, you'll get a match error here
02:27:26 <ski> @type let readM s = case reads s of [(a,"")] -> return a; _ -> mzero in readM
02:27:27 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m a
02:27:50 <ski> hm, i suppose
02:28:30 <theorbtwo> ski: How is a match error better then a read error, though?
02:30:23 <theorbtwo> Thanks for the view pattern; that particular bit is much cleaner then it was.
02:31:17 <ski> @type let readM s = do (a,s) <- (foldr (mplus . return) mzero) (reads s); guard (null s); return a in readM
02:31:19 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m a
02:31:34 <ski> maybe that would be better, if we're going for `MonadPlus'
02:32:01 <Robbb> I'm looking for help w/type inference in Parsec library
02:32:15 <ski> theorbtwo : well, it isn't really. what might be better is getting any parse error at *that* point, instead of when you later try to access `res_type'
02:32:35 <ski> @paste
02:32:36 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:32:48 <ski> Robbb : try pasting your code there ^ ?
02:33:18 <theorbtwo> ski: This is one of those cases where any discussion seems to eventually involve lots of stuff I don't understand and doesn't really seem to be about solving the problem.
02:33:20 <Robbb> Exercise from "Write Scheme in 48 Hours"
02:33:34 <Robbb> When I compile  parseNumber :: Parser LispVal
02:33:36 <Robbb> parseNumber = (many1 digit) >>= (liftM (Number . read))
02:33:47 <ski> theorbtwo : which is that problem ?
02:33:47 <Robbb> i get error "Couldn't match expected type `Char' against inferred type `[Char]'
02:33:49 <Robbb> "
02:34:18 <theorbtwo> ski: let readM s = do (a,s) <- (foldr (mplus . return) mzero) (reads s); guard (null s); return a in readM
02:34:53 <ski> theorbtwo : imo, something akin to that should be in a standard library somewhere (maybe it already is, and i haven't noticed, though)
02:35:05 <Robbb> Shouldn't n <- (many1 digit) be [Char] not Char?
02:35:15 <Botje> :t many1 digit
02:35:16 <lambdabot> Not in scope: `many1'
02:35:17 <lambdabot> Not in scope: `digit'
02:35:20 <Botje> boo :P
02:35:31 <Botje> Robbb: it is.
02:35:38 <ski> @type Text.Parsec.many1
02:35:39 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
02:35:53 <Botje> Robbb: are you sure the issue is with parseNumber?
02:36:11 <theorbtwo> All I wanted to do was convert a string to an integer.  Out of 33 lexemes in that snippet, two are actually relevant.
02:36:21 <Robbb> I'm not sure what the issue is with.
02:36:23 <ski> @type \act fun -> act >>= liftM fun
02:36:24 <lambdabot> forall (m :: * -> *) a1 b. (Monad m) => m (m a1) -> (a1 -> b) -> m b
02:36:33 <ski> @type \act fun -> act >>= return . fun
02:36:35 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
02:36:41 <ski> @type \act fun -> liftM fun act
02:36:43 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
02:37:02 <ski> Robbb : i think you don't want to use both `(>>=)' and `liftM', there
02:37:08 <Botje> yeah
02:37:16 <ski> either use `(>>=)' and `return', or use `liftM'
02:37:19 <Botje> many1 digit >>= return . read -- should work
02:37:44 <ski> (s/read/Number . read/)
02:37:51 <Botje> Robbb: because liftM (...) expects an "m a" as argument
02:38:00 <Botje> whereas it's getting an "a" through >>=
02:38:02 <theorbtwo> So... anybody have any good hints for debugging "Stack space overflow: current size 8388608 bytes." ?
02:38:03 <ski>   liftM (Number . read) (many1 digit)  -- this should also work
02:38:13 <Botje> theorbtwo: compile with ghc -O2 :)
02:38:27 <Robbb> Exercise is to rewrite function using >>=
02:38:44 <Robbb> So I'm looking for >>= form of "parseNumber = liftM (Number . read) $ many1 digit"
02:38:49 <ski> Robbb : ok, so don't use `liftM', then
02:39:05 <mauke> Robbb: liftM is >>= return .
02:39:08 <theorbtwo> :t liftM
02:39:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:39:12 <theorbtwo> :t (>>=)
02:39:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:39:16 <ski> Robbb : have you written a version using `do' ?
02:39:33 <Robbb> ski: yes, have the do version.
02:39:38 <ski> @src liftM
02:39:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:39:54 <ski> do you know how to unsugar `do' to `(>>=)' to ?
02:39:54 <mauke> @. undo src liftM
02:39:55 <lambdabot> ()
02:40:25 <ski> (mauke : heh, don't give away the answer, yes ?)
02:40:32 <Robbb> @ski: no
02:40:33 <lambdabot> Unknown command, try @list
02:40:43 <Robbb> ski: no
02:41:03 <theorbtwo> Hm.  -O2 (and, for that matter, -O42) give me exactly the same error message.
02:41:03 <ski> ok, so if you have
02:41:12 <ski>   do x <- act
02:41:19 <ski>      ..x..
02:41:26 <ski> then this is desugared to
02:41:27 <tensorpudding> do x <- y; z  is the same as y >>= (\x -> z x)
02:41:36 <ski>   act >>= \x ->
02:41:40 <ski>     do ..x..
02:42:13 <ski> (tensorpudding : you need to replace one of `z' and `z x' with the other ..)
02:42:18 <mauke> do { x; ... } ==> x >> do { ... }
02:42:31 <mauke> do { v <- x; ... } ==> x >>= \v -> do { ... }
02:42:37 <mauke> do { x } ==> x
02:42:51 <tensorpudding> err, right
02:42:54 <mauke> do { let V; ... } ==> let V in do { ... }
02:42:57 <tensorpudding> do x <- y; z x
02:43:15 <xerox> I think it was zygoloid that showed that actually do { x <- amb; ... }Â is not amb >>= \x -> do { ... } but there is a 'case' in between
02:43:16 <ski> Robbb : so, armed with this desugaring knowledge, maybe you could try starting with the version using `liftM', then unfold the definition of `liftM' into that, and finally desugar `do' into `(>>=)' ?
02:43:47 <xerox> > do { Just x <- [Just 1, Nothing, Just 2, Nothing, Just 3]; return x } -- i.e.
02:43:48 <lambdabot>   [1,2,3]
02:43:59 <ski> xerox : yes, if `x' is not a plain variable, but a possibly failing pattern, there's a `case' and a `fail' in there, too
02:45:06 <Robbb> This isn't working. I'm getting type errors
02:45:18 <ski> what isn't working ?
02:45:57 <tensorpudding> > do x <- [1..10]; [1..x]
02:45:58 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
02:46:50 <Robbb> "parseNumber = (many1 digit) >>= (\x -> (Number . read x))"
02:47:03 <ski> > fix $ \xs -> 1 : do x <- xs; [2 * x,2 * x + 1]
02:47:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:47:17 <mauke> Robbb: what happened to the 'return' in @src liftM?
02:47:39 <Robbb> What is "@src liftM"?
02:47:43 <ski> @src liftM
02:47:43 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:47:46 <mauke> ^ that
02:47:52 <ski> it's a definition of `liftM'
02:48:45 <Robbb> ok, but I have the do form. I'm having trouble desurgaring it to >>= form.
02:49:05 <ski> it says that, e.g., `liftM (Number . read) (many1 digit)' is the same as `do { x1 <- m1; return (f x1) }', with `f' replaced by `(Number . read)' and with `m1' replaced by `(many1 digit)'
02:49:19 <tensorpudding> liftM is also fmap
02:49:27 <mauke> Robbb: you don't have the do form
02:49:30 <Robbb> Ok, I already have the do form.
02:49:36 <ski> (maybe s/he has now)
02:49:50 <Robbb> I've had it for a while:
02:49:53 <Robbb> parseNumber = do n <- many1 digit
02:49:55 <Robbb>                 return $ (Number .read) n
02:50:03 <Robbb> I don't know how to translae it to >>= form.
02:50:07 <tensorpudding> > (liftM (+ 5) $ Just 10) == fmap (+ 5) $ Just 10
02:50:08 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a1'
02:50:08 <lambdabot>         against inferred...
02:50:12 <ski> look at the rules mauke provided above
02:50:35 <mauke> do { v <- x; ... } ==> x >>= \v -> do { ... }
02:50:39 <tensorpudding> > (liftM (+ 5) $ Just 10) == (fmap (+ 5) $ Just 10)
02:50:40 <lambdabot>   True
02:50:54 <ski> > liftM (+ 5) (Just 10) == fmap (+ 5) (Just 10)
02:50:55 <lambdabot>   True
02:50:59 <mauke> so: parseNumber = many1 digit >>= \n -> do { return $ (Number . read) n }
02:52:02 * ski thinks `$' is often overused
02:52:40 <mauke> return . Number . read $ n
02:52:59 <tensorpudding> or you can use liftM for vastly increased readability
02:53:14 <mauke> tensorpudding: THANK YOU FOR MISSING THE POINT
02:53:39 <tensorpudding> the point was writing it in do notation?
02:53:47 <Robbb> mauke: thanks, that works. I'll think about it a bit.
02:54:14 <ski> (return . Number . read) n
02:54:29 <Robbb> (anyhow, the exercise was to translate the function into various equivalent forms.)
02:54:41 <tensorpudding> return . Number $ read n
02:54:52 <ski> <Robbb> Exercise is to rewrite function using >>=
02:55:05 <mauke> tensorpudding: ew, no
02:55:31 <tensorpudding> (f . g . h) is prettier if h only requires one argument
02:55:36 <ski> return $ Number $ read $ n
02:55:42 * ski jests
02:55:42 <int-e> return $ Number . read $ n
02:55:52 <tensorpudding> if it requires more, you can do f . g $ h x y
02:56:08 <mauke> no, the solution is return . Number . read $ n (or ski's version with parens)
02:56:09 * int-e is actually quite serious.
02:56:24 <mauke> because this is the body of a lambda in n
02:56:42 <mauke> and the next step will be lambda removal
02:57:21 <tensorpudding> my point was that f . g . h $ only works if the function has a single argument
02:57:33 <tensorpudding> it was a tangent
02:57:58 <Robbb> return ((Number . read) n) is most readable to me.
02:58:23 <mauke> Robbb: you might be crazy
02:58:34 <mauke> I can understand preferring return (Number (read n))
02:58:46 <tensorpudding> it emphasizes return
02:59:01 <tensorpudding> it looks very imperative to me
02:59:05 <ski> @type \(f,g,h,x,y) -> (($) $ f) $ (($) $ g) $ (($) $ (($) $ h) $ x) $ y  -- tensorpudding
02:59:06 <lambdabot> forall b b1 a b2 a1. (b1 -> b, b2 -> b1, a1 -> a -> b2, a1, a) -> b
02:59:12 <tensorpudding> even with (.) in it
02:59:34 <Robbb> I'm used to parsing parens from Scheme
02:59:40 <ski> (or, simpler `\(f,g,h,x,y) -> f . g . h x $ y')
02:59:43 <Robbb> Anyhow, thanks again
03:00:02 <tensorpudding> you could write haskell to look a lot like scheme
03:00:08 <Robbb> I think I understand $ now. Cleaner than parens.
03:00:30 <ski> only in some special cases, imho
03:01:30 <tensorpudding> > (map ((+) 3) ((:) 3 ((:) 5 ((:) []))))
03:01:31 <lambdabot>   Couldn't match expected type `[t]'
03:01:31 <lambdabot>         against inferred type `[[a]] -> ...
03:01:37 <tensorpudding> oops
03:02:05 <tensorpudding> > (map ((+) 3) ((:) 3 ((:) 5 ((:) 7 []))))
03:02:06 <lambdabot>   [6,8,10]
03:03:18 <ski> > (map ((+) 3) ((((:) 3) . ((:) 3) . ((:) 5) . ((:) 7)) []))  -- clear, yes ?
03:03:19 <lambdabot>   [6,6,8,10]
03:04:06 <ski> (maybe this is enough silliness for one morning, though ?)
03:04:31 <tensorpudding> there isn't a composition function in scheme is there?
03:06:35 <ski> there is no one described in R5RS (dunno about R6RS), but it's easily defined
03:06:51 <ski> (has come up on comp.lang.scheme several times)
03:06:58 <quicksilver> the fact it isn't defined by default is telling, though
03:07:13 <ski> well, not much is defined by default at all in R5RS
03:08:05 <tensorpudding> (map #+ (cons 3 (cons 3 (cons 5 (cons 7 '())))) is the valid scheme
03:08:09 <ski> e.g. there is no `let/cc' or `receive' syntax for `call-with-continuation' and `call-with-values' defined
03:08:13 <tensorpudding> err, not really
03:08:35 <ski> s/#+/(lambda (x) (+ 3 x))/
03:08:39 <tensorpudding> yeah
03:08:56 <tensorpudding> forgot that scheme lacks currying
03:08:59 <ski> and that list would probably be written as  (list 3 3 5 7)  or  '(3 3 5 7)
03:09:19 <tensorpudding> well, yes
03:09:33 <ski> (and `#+' isn't valid anyway .. perhaps you were thinking of CL ?)
03:09:39 <tensorpudding> maybe
03:10:42 <mauke> it's #'+ there
03:11:32 <ski> (the philosophy in R5RS is to (mostly) only mention the primitive stuff that one needs to build a useful language from)
03:11:41 <tensorpudding> my knowledge of lisps kinda meld together since i've never actually used any of them
03:11:49 <tensorpudding> except to write simple stuff
03:15:56 <quicksilver> ski: but still, R5RS has (map) and (for-each) and even the utterly ridiculous (do)
03:16:11 <quicksilver> ski: to have those things and not a notation for function composition is bizarre to me
03:17:42 <zygoloid> is it scheme day today?
03:20:06 <theorbtwo> Thing is, function composition isn't actually that useful / tht difficult to do yourself.
03:20:13 <ski> quicksilver : granted. R5RS still lacks `filter', `foldr', `take', `drop', &c., though .. basically almost all convenience functions on lists are missing
03:20:27 <theorbtwo> Especially the inline style that seems popular in haskell.
03:20:44 <theorbtwo> f . g x is just f (g x).  Why not write it the second way?
03:20:49 <ski> (and since you actually need those, the semi-semi-standard SRFI-1 provides them)
03:21:22 <ski> theorbtwo : but `f . g' is simpler than `\x -> f (g x)'
03:21:43 <quicksilver> theorbtwo: in the circumstance "map (f.g) [some list]"
03:21:59 <quicksilver> theorbtwo: or any other higher-order function in place of map
03:22:22 <theorbtwo> ski: And that means that other languages need an easier function composition, rather then haskell needing easier lambdas?
03:22:23 <ski> zygoloid : yes. what's your scheme of things ?
03:22:38 <blueonyx> hi, when using ghc as a library i want to add DynFlags to a session (importPaths,objectDir,hiDir), i therefore use getSessionDynFlags and setSessionDynFlags which worked fine with 6.10, but in 6.12 i get a panic: defaultDynFlags: No filesToClean
03:22:54 <quicksilver> whereas in scheme you have to write the mildly unaesthetic (map (lambda (x) (f (g x))) ...)
03:23:03 <quicksilver> theorbtwo: I think haskell lambdas are (also) easier than scheme's :)
03:23:04 <mauke> theorbtwo: well, this is a functional language, so operating on functions as values seems natural
03:23:05 <ski> theorbtwo : haskell already have easy lambdas (imo). not sure what you mean by other languages needing easier function composition, though
03:23:22 <theorbtwo> quicksilver: map \(f g) doesn't do the same thing?
03:24:02 <ski> (function composition is easy in Scheme, e.g. (slightly more complicated if you want to handle multiple values correctly) .. it's just that (not that unsurprisingly) R5RS doesn't specify it)
03:24:22 <ski> theorbtwo : `\(f g)' is nonsense
03:24:25 <quicksilver> theorbtwo: anyhow I'm not pretending this is a "Big Problem" with scheme.
03:24:46 <quicksilver> theorbtwo: merely a surprising omission which may or may not be suggestive
03:25:20 <ski> (er s/unsurprisingly/surprisingly/)
03:26:31 <theorbtwo> ski: Why is it, though?  You can happily say foo = functionTakingArguments, even where functionTakingArguments is a quite complex piece of code.  Why do lambdas need to spell out their argument list, but not other forms of function definition?
03:26:35 <ski> theorbtwo : if `\(f g)' would be part of valid haskell syntax, it would have to be (imo) `\(f g) -> ...', so `f g' would be a pattern against which the input to the function is matched
03:26:58 <ski> theorbtwo : lambdas are not a form of function definition
03:27:08 <ski> they are not a definition at all, they are a form of expression
03:27:23 <mauke> theorbtwo: everything needs to spell out its argument list
03:27:35 <mauke> if it doesn't, it has no argument list
03:28:18 <ski> and lambdas need to spell out their argument list because that's their raison d'être
03:28:31 <theorbtwo> mauke: Huh?  Implicit arguments are pretty common.  "second = head drop"
03:28:39 <theorbtwo> second now has an implict argument.
03:28:44 <mauke> theorbtwo: that's a type error
03:28:46 <mauke> or two
03:28:51 <ski> (meaning "the reason they exist")
03:29:19 <ski> @type let second = head drop in second
03:29:20 <lambdabot>     Couldn't match expected type `[a]'
03:29:20 <lambdabot>            against inferred type `Int -> [a1] -> [a1]'
03:29:21 <lambdabot>     In the first argument of `head', namely `drop'
03:29:38 <ski> @type let second = head tail in second
03:29:39 <lambdabot>     Couldn't match expected type `[a]'
03:29:40 <lambdabot>            against inferred type `[a1] -> [a1]'
03:29:40 <lambdabot>     In the first argument of `head', namely `tail'
03:29:44 <ski> @type let second = head . tail in second  -- however
03:29:46 <lambdabot> forall a. [a] -> a
03:29:49 <zygoloid> theorbtwo: if you mean 'second = head . tail' then second is a value which happens to be a function. that's not operationally the same as it having an implicit argument, in general...
03:30:19 <zygoloid> also with the DMR it's not even denotationally the same :)
03:34:33 <zygoloid> > let fib n | n < 2 = n | otherwise = fib (n-1) + fib (n-2);  second = let n = fib 25 in (n*) . head . tail   in map second (replicate 20 [1,2,3])
03:34:34 <lambdabot>   [150050,150050,150050,150050,150050,150050,150050,150050,150050,150050,1500...
03:34:37 <zygoloid> > let fib n | n < 2 = n | otherwise = fib (n-1) + fib (n-2);  second xs = let n = fib 25 in (n*) . head . tail $ xs  in map second (replicate 20 [1,2,3])
03:34:40 <lambdabot>   mueval-core: Time limit exceeded
03:35:52 <blueonyx> hi, when using ghc as a library i want to add DynFlags to a session (importPaths,objectDir,hiDir), i therefore use getSessionDynFlags and setSessionDynFlags which worked fine with 6.10, but in 6.12 i get a panic: defaultDynFlags: No filesToClean, shouldn't this flag be set automaticly after adding Targets?
03:43:31 <Phyx-> I'm still having problems in solving these incoherent instances http://phyx.pastebin.com/Tc0t5r0x , They shouldn't ideally overlap, but because GHC does only instance head matching they do unfortunately
03:45:16 <quicksilver> Phyx-: I don't mean to be unhelpful, but they *do* overlap, because that's how instance search works.
03:45:29 <quicksilver> I can understand what you're asking for but as far as I know it's not possible.
03:46:13 <Phyx-> quicksilver: yeah, i was just looking at them, And the second instance seems unneeded
03:46:16 <quicksilver> you can use things like phantom types, newtypes, and type families to work around.
03:46:33 <quicksilver> It's an almost-FAQ "why doesn't instance search work this way"
03:46:39 <quicksilver> unfortunately I don't have a good answer.
03:46:50 <quicksilver> but I think there are real problems involved.
03:46:56 <quicksilver> (it's not just a simple enhancement)
03:49:15 <Phyx-> quicksilver: if you ever find any paper or so which covers why also including the context in the search is a problem could you pass that along
03:49:28 <mreh> can I do anything to shorten pattern guards by defining things that are used again and again?
03:50:08 <mreh>  | i-1 <= nodes e + nodes e1 = let mid            = nodes e
03:50:08 <mreh>                                    (e', subE', d) = replaceExpr' (i-mid-1) e subE
03:50:08 <mreh>                                in (If (c-d) e e' e2, subE', d)
03:50:13 <mreh> par example
03:50:41 <Phyx-> as a secondary question, anyone know how, if possible to make the translatePartial an syb call? i've tried, but failed.. http://phyx.pastebin.com/6cKPV1kQ
03:50:53 <mreh> nodes e and nodes e1 are used again in my pattern guards for this function def
03:51:20 <quicksilver> give them names in a where clause?
03:51:23 <mreh> but they're out of scope for any 'let' or 'where' sub expression
03:51:46 <mreh> quicksilver: I didn't think you could do that
03:52:02 <quicksilver> the contents of guards have where clauses in scope
03:52:09 <quicksilver> so I imagine pattern guards do too
03:52:11 <quicksilver> but I've never tried
03:54:32 <mreh> I'll do an experiment and observe the results
03:54:45 <mreh> then we will get to the bottom of the matter
03:57:04 <mreh> oh I see what you mean, in a where clause that is in the same scope as all the patterns
03:57:24 <mreh> eh... guards
03:57:36 <mreh> all guards share the enclosing scope
03:57:48 <ski> yes
03:59:00 <mreh> :info (-)
03:59:05 <mreh> @info (-)
03:59:06 <lambdabot> (-)
04:00:54 <mreh> I can't think up an example to disprove the commutativity of (-)
04:01:05 <mreh> you have to use negative numbers don't you
04:01:37 <ski> @check 2 - 0 == 0 - 2
04:01:38 <lambdabot>   "Falsifiable, after 0 tests:\n"
04:02:23 <mreh> @check (a - b) - c == a - (b - c)
04:02:24 <lambdabot>   "Falsifiable, after 0 tests:\n"
04:02:24 <ski> (whether that "uses negative numbers" or not is up to you)
04:02:44 <ski> @check \a b -> a - b == b - a
04:02:44 <lambdabot>   "Falsifiable, after 4 tests:\n-3\n3\n"
04:03:06 <zygoloid> > 5 - 3 == 3 - 5
04:03:07 <lambdabot>   False
04:04:06 <mreh> i was thinking of "associative"
04:04:09 <zygoloid> mreh: if a != b, then a - b != 0, so 2 (a - b) != 0, so a - b != - (a - b), so a - b != b - a
04:04:29 <zygoloid> > 5 - (3 - 2) -= (5 - 3) - 2
04:04:30 <lambdabot>   Not in scope: `-='
04:04:32 <zygoloid> > 5 - (3 - 2) == (5 - 3) - 2
04:04:34 <lambdabot>   False
04:05:21 <mreh> > 5 - 3 - 2
04:05:22 <lambdabot>   0
04:05:35 <mreh> right, that's good
04:05:53 <zygoloid> if (a - b) - c == a - (b - c), then -b - c == -(b - c), so -b - c == -b + c, so c == 0
04:06:01 <mreh> sometimes prefix notation is your friend :)
04:07:22 <pokoko222> hello mortals
04:07:28 <zygoloid> given that 0 is a right identity element for (-), that's really as non-associative as it's possible for it to be
04:07:44 <ski> pokoko222 : hello, divine being
04:07:45 <zygoloid> pokoko222: hello fellow fleshy meatbag
04:08:40 <mreh> they tried to teach me this as a 12 year old, my body rejected it then, still has a hard time going in
04:09:32 <nomi> where do i paste my code?
04:09:35 <ski> @paste
04:09:35 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
04:09:47 <mreh> is it possible to kick a deity from an IRC channel?
04:09:59 <nomi> you can help with java right?
04:10:01 <ski> sure
04:10:12 <mreh> nomi: this is #haskell
04:10:13 <ski> nomi : for Java help, you might want to try ##java
04:10:23 <ski> nomi : this channel is about the Haskell programming language
04:10:58 * ski has no idea about how helpful ##java is, btw, never having visited
04:11:12 <mreh> from what I remember, not very
04:11:19 <mreh> but don't let that stop you
04:11:38 <nomi> http://code.haskell.org/hpaste.git
04:11:51 <nomi> so i'm trying to understand getter
04:12:10 <nomi> it's under noman
04:12:12 <nomi> the code
04:12:22 <NeoMojo> ??
04:12:36 <mreh> nomi: I don't think you pasted the correct link
04:12:39 <ski> why do you give a like to (presumably) the code of hpaste ?
04:12:52 <nomi> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8111
04:13:17 <nomi> is that it?
04:13:18 <mauke> nomi: why are you asking here?
04:13:24 <NeoMojo> still not looking like a Haskell Question, nomi
04:13:26 <nomi> then where?
04:13:30 <ski> nomi : .. this is Java. this isn't the right forum for Java help
04:13:46 <ski> nomi : try `/join ##java'
04:13:47 <mauke> nomi: read what ski said
04:13:58 <nomi> sorry, i bookmarked this channel
04:14:16 <nomi> sorry, i had* bookmarked this channel
04:14:28 <ski> nothing wrong with doing that, as long as you realize that this channel is for the programming language Haskell
04:14:37 <nomi> ooo
04:14:39 <nomi> i see
04:15:32 <nomi> how do i join ##java? i'm talking through applet not mirc
04:15:56 <mauke> what applet?
04:16:03 <nomi> http://gogloom.com/client2/index2?mainCHAT=1&network=FreeNode&channel=%23haskell
04:16:33 <theorbtwo> No matter how you are doing it, typing /join ##java is likely to work.
04:16:45 * ski tries to resist the urge of complaining about the strangeness of that code ..
04:16:59 <ben> ski: Yeah, it mutates a variable all over the place
04:17:02 <nomi> it's not :( but i think i got it thank you.
04:17:05 <Cale> http://webchat.freenode.net/ -- use this one if you're going to use a web client :)
04:17:08 <ski> nomi : maybe try replacing `%23haskell' with `%23%23java' at the end of that URL ?
04:17:46 <NeoMojo> nomi: your name needs to be registered with freenode to be able to chat in ##java
04:17:53 <ski> > chr 0x23
04:17:54 <lambdabot>   '#'
04:17:55 * ski nods
04:17:57 <mreh> nomi: how did you end up in #haskell?
04:18:14 <nomi> i was searching through java channels
04:18:20 <mreh> I'm just interested, it's not a relevant question
04:18:26 <nomi> this room seemed to be most popular
04:18:34 <nomi> populated*
04:18:38 <mreh> 2nd biggest on freenode
04:18:39 <Cale> nomi: Unfortunately, it's not about java at all ;)
04:18:59 <nomi> yes i understand that now lol
04:19:42 <Cale> I'm inclined to say you came to the right place anyway. Java is a silly language to be programming in ;)
04:19:57 <mreh> where did I get that 2nd biggest statistic from? that's not even remotely true
04:20:15 <mreh> #haskell is 8th
04:20:24 <Cale> 8th is the new 2nd.
04:20:27 <nomi> cale YOU'RE SO DANG RIGHT!!!
04:20:33 <mreh> behind ##c++ nooo
04:20:39 <nomi> HATE java!!
04:20:40 <theorbtwo> It's at least remotely 2nd.
04:20:48 <theorbtwo> Now, 200th wouldn't be remotely 2nd.
04:21:07 <int-e> it's also the third of the programming language channels.
04:21:08 <Cale> 200th is congruent to 2nd mod 2.
04:21:13 <mreh> #haskell is in the order of the most popular channel on freenode
04:21:24 <mreh> there's so advertising spiel for you
04:21:32 <malcolmw> @seen me
04:21:32 <lambdabot> Unknown command, try @list
04:21:40 <malcolmw> what's up with lambdabot?
04:21:51 <voker57> > 1
04:21:52 <lambdabot>   1
04:21:55 <Cale> The @seen plugin's been disabled for a long time
04:22:00 <Cale> preflex: seen me
04:22:00 <int-e> the seen module was leaky
04:22:00 <preflex>  me was last seen on #gentoo 312 days, 5 hours, 14 minutes and 36 seconds ago, saying:  imagemagick maybe?
04:22:19 <malcolmw> so preflex is the new lambdabot?
04:22:27 <int-e> @bot
04:22:28 <lambdabot> :)
04:22:32 <int-e> preflex: bot
04:22:33 <preflex>  yes.
04:22:56 <Cale> Well, preflex is another bot, which happens to have the same functionality as @seen :)
04:22:59 <mreh> int-e: bot
04:23:05 <int-e> mreh: boo
04:23:11 <mreh> wuh!
04:23:12 <malcolmw> useful, ta
04:23:44 <theorbtwo> How many bots are there on this channel, anyway?
04:24:12 <Axman6> Cale: well, no, seen works in preflex :P
04:26:58 <mreh> http://www.googlism.com/what_is/h/haskell/
04:27:02 <Cale> Apart from lambdabot and preflex, I'm not sure.
04:27:05 <mreh> this made me chuckle
04:27:38 <mreh> "haskell is an extension of the functional language haskell with data fields"
04:27:49 <Cale> "haskell is a great language to develop games"
04:28:08 <Cale> "haskell is the type class system"
04:28:14 <mreh> Cale: why is that amusing? That's what I' doing
04:28:19 <mreh> :(
04:28:31 <Cale> It's amusing because it's probably true.
04:28:34 <mreh> "haskell is 39 degrees fahrenheit with a july temperature average of 81 degrees"
04:28:49 <Cale> "haskell is a troubadour a journeyman and singer of the song and he communicates"
04:28:53 <NeoMojo> "haskell is anything other than a chaos traitor"
04:29:27 <mreh> this what happens when you name your language after someone
04:29:41 <Cale> "haskell is an object" "haskell is a real dragon"
04:29:46 <NeoMojo> :D
04:29:49 <mreh> surnames have a habit of becoming firstnames too
04:30:16 <theorbtwo> Haskell is first name -- his last name was already taken.
04:30:19 <mreh> I was just looking for warped opinions of haskell, but this has turned out to be a gold mine
04:30:46 <Axman6> "haskell is better late than never"
04:32:20 <Phyx-> bleh, file is locked, time to dump readFile
04:37:07 <Axman6> anyone played with any FPGA's before?
04:37:24 <cheater> i've read up on them :p
04:37:32 <Axman6> heh
04:37:49 <cheater> why?
04:37:59 <Axman6> i'm doing a course where we guy to use them, and i'll be buying one of these: https://www.digilentinc.com/Products/Detail.cfm?NavPath=2,400,792&Prod=S3EBOARD
04:38:29 <cheater> and..
04:39:11 <Axman6> and nothing...
04:39:32 <cheater> ok
04:39:33 <cheater> :P
04:39:36 <cheater> thanks for sharing :p
04:39:46 <cheater> i thought you had a question of some sort
04:39:46 <dschoepe> Axman6: I used the same board in a course I took
04:40:43 <dschoepe> you'll need the inofficial userspace drivers to get it to work under linux: http://rmdir.de/~michael/xilinx/
04:41:41 <Axman6> i try not to use linux when i can avoid it ;)
04:42:43 <Cale> Mac user?
04:42:50 <Axman6> yes
04:43:01 <NEEDMOAR> Hey Cale.
04:43:05 <Axman6> but that's not why i don't like linux
04:43:18 <Cale> The only thing that bothered be about Mac OS X was the UI. Everything else was okay :)
04:43:29 <Cale> me*
04:43:46 <Axman6> what bothered you about it?
04:43:52 <Axman6> couldn't change it?
04:44:16 <kosmikus> Cale: well, the other thing is that their package manager is much worse than that of most current Linuxes
04:44:42 <Axman6> "their" package manager?
04:44:55 <kosmikus> Apple's
04:44:59 <Axman6> OS X doesn't come with a package manager (and doesn't need one)
04:45:16 <kosmikus> of course it has one
04:45:23 <kosmikus> it's called "Software Updates" or something like that
04:45:32 <Cale> Oh, right, yes, it desperately needs a proper package manager, and everything costs money.
04:45:40 <Axman6> :\
04:46:00 <Cale> Lots of things are hard to uninstall. Anything which is not a single file app.
04:46:04 <Axman6> those aren't packages. they're updates. packages, to me at least, mean installing new software, and managing it
04:46:38 <Axman6> Cale: luckily 99% of all OS X apps are one .app
04:47:29 <Cale> Somehow, very few of the apps I used when I was using it came as one .app
04:47:37 <Axman6> can you name any?
04:48:14 <Cale> Well, it was a few years ago, I can't remember which ones were which.
04:48:41 <Axman6> did they happen to be editors? (*vim* or *emacs*)
04:48:43 <Cale> I spent most of my time using GHC and emacs
04:48:58 <Cale> and firefox
04:49:06 <Axman6> (the *'s were wildcards, not for emphasis btw)
04:49:21 <Cale> (and gvim)
04:49:39 <Cale> and there was a replacement terminal emulator
04:49:44 <Cale> iTerm maybe?
04:50:13 <Cale> Because the default Terminal was intolerable, because it wordwrapped in a funny way.
04:51:02 <Axman6> i don't like iTerm, i found it horrible, but lots of other people like it
04:51:38 <harlekin> Speaking in terms of the Curry-Howard isomorphis, is id equivalent to âaâa:a â a?
04:51:38 <Cale> Well, iTerm obviously sucked too, but it sucked a bit less than the other one, and I couldn't find many other decent options.
04:51:43 <mjouk> The old Terminal.app was awful, but it's been fine since Leopard
04:51:53 <Axman6> it does strange things like. it doesn't render fonts properly
04:51:54 <Cale> harlekin: id's type is forall a. a -> a
04:52:53 <harlekin> Cale: So it's âa:a â a?
04:52:57 <Cale> yeah
04:53:20 <harlekin> Cale, what does f = (*2) prove, then?
04:53:29 <harlekin> @type (*2)
04:53:29 <Cale> It's a proof of Integer -> Integer
04:53:30 <lambdabot> forall a. (Num a) => a -> a
04:53:49 <MissPiggy> what does undefined prove
04:53:51 <Cale> (and various other similar things)
04:53:54 <Cale> MissPiggy: everything
04:54:01 <Cale> undefined :: forall a. a
04:54:05 <Axman6> it's a proof that given any number, haskell can double it
04:54:09 <Axman6> maybe...
04:54:34 <harlekin> It doesn't proof "For each integer x there's an integer y that fulfills 2*x = y?
04:54:36 <Cale> Well, Haskell's type system doesn't express the fact that (*2) actually doubles the number
04:54:37 <MissPiggy> calling these guys proofs is kind of..... a stretch
04:54:42 <Cale> only that it takes an integer and produces another
04:55:22 <Cale> harlekin: It might, if you go to enough work at the type level.
04:55:28 <Axman6> hang on, isn't the code a proof that the proposition made by the type is true?
04:55:44 <Cale> harlekin: But its type doesn't express much about what it actually does, in Haskell.
04:55:46 <MissPiggy> it sees totally bogus to me
04:55:55 <Cale> MissPiggy: What does?
04:56:02 <MissPiggy> trying to say that haskell proves stuff
04:56:08 <Cale> MissPiggy: It does.
04:56:18 <Cale> MissPiggy: Well, in an inconsistent intuitionist logic.
04:56:21 <Axman6> MissPiggy: it really does
04:56:21 <MissPiggy> but this is the wrong definition of proof
04:56:27 <Cale> MissPiggy: Huh?
04:56:28 <Axman6> no it's not
04:56:43 <Cale> It's exactly the same definition of proof as you're used to.
04:56:52 <MissPiggy> I mean I could just write random squiggles on bits of paper and say they are proofs of everything
04:56:52 <Cale> Well, apart from missing LEM
04:56:59 <harlekin> How would I translate Integer to a proposition?
04:57:06 <MissPiggy> but we can derive LEM
04:57:08 <Cale> harlekin: It is one.
04:57:12 <MissPiggy> undefined :: Either a (Not a)
04:57:19 <harlekin> Cale, what would it be in formally?
04:57:26 <Cale> harlekin: Integer is essentially the proposition that an integer exists.
04:57:34 <Cale> Each element of it is a proof.
04:58:03 <Cale> (*2) turns a proof that an integer exists into a proof that an integer exists (possibly a different one)
04:58:05 <Axman6> there's no proof to be made for "Integer", it just states that you have an integer
04:58:34 <Cale> Well, there are lots of proofs of Integer
04:58:35 <MissPiggy> I don't know it just seems like a lie to me
04:58:37 <Axman6> Integer -> Integer says that if you have an integer, you can have another integer
04:58:53 <MissPiggy> why don't you say /value/ instead of /proof/?
04:58:57 <MissPiggy> since it doesn't prove anything
04:59:02 <Axman6> it does
04:59:03 <Cale> MissPiggy: What's the difference?
04:59:13 <Cale> A value is the same thing as a proof.
04:59:14 <Axman6> but, these types are trivial to prove, and seem silly
04:59:40 <Cale> All types are trivial to prove in Haskell.
04:59:45 <MissPiggy> why is a value a proof that is ridiculous
04:59:56 <Cale> The interesting stuff happens in *which* proofs of each proposition are available.
05:00:01 <Cale> You have to look at the structure.
05:00:09 <Axman6> Eq a => a -> [(a,b)] -> Maybe b is a proposition that if you are given an a, and a list of a, b pairs, you can produce a Maybe b result. and the implementation of lookup proves this
05:00:17 <Cale> Because Haskell as a proof system is inconsistent.
05:00:33 <Cale> (as is any system which supports general recursion)
05:00:38 <Cale> fix :: (a -> a) -> a
05:00:42 <Cale> id :: a -> a
05:00:47 <Cale> So  fix id :: a
05:00:56 <Cale> So I can prove anything.
05:01:07 <Cale> But that's not a particularly interesting proof.
05:01:20 <Cale> MissPiggy: Let me explain the connection a bit.
05:01:35 <MissPiggy> okay
05:01:37 <Cale> In logic, if you know that A => B, and you know that A, then you can prove B
05:01:56 <Axman6> the point is, that if you can think of a type for a function, and then write an implementation that matches that type (and matches all inputs of the input types), then you have proved the type true
05:02:09 <Cale> In lambda calculus, if you have a term f of type A -> B, and you have a term x of type A, then you have f x is a term of type B
05:02:14 <MissPiggy> yeah sure \x -> m proves A -> B
05:02:33 <Cale> In logic, if by assuming that A is true, you can prove B, then you have a proof that A => B
05:02:43 <medf> a function from A to B is a proof from A to B? :o
05:02:50 <Axman6> yes
05:02:52 <medf> it just sounds like the notation is similar
05:02:55 <medf> whaat
05:03:05 <Cale> In lambda calculus, if by assuming you have a value x of type A, you can construct a value y of type B, then you have a term (\x -> y) of type A -> B
05:03:18 <Axman6> but, only if the function is... total? is that the correct term Cale?
05:03:45 <Cale> Axman6: Not necessarily.
05:04:03 <Axman6> anyway, sleep time. night all
05:04:04 <Cale> If it's partial, then sometimes you get a stupid proof of B, but it's still a proof.
05:04:29 <medf> when someone goes f :: A -> B I think that f maps function from A to B... how is that related to logic
05:04:40 <Axman6> isn't it then a proof that if you have specific A's, you can get some B?
05:04:47 <MissPiggy> medf, it's just notation
05:05:07 <Cale> Axman6: It's a proof that if there's an element of A, that is, if A is true, then there's an element of B
05:05:07 <MissPiggy> and it seems like because haskell use lambda notation and such that it is a proof system ? but that doesn't really make sense
05:05:07 <medf> isn't that what types are about too?
05:05:22 <MissPiggy> also  haskell has some data types which look,notationally similar to stuff from category theory
05:05:31 <MissPiggy> but I don't think haskell has category theory in it
05:05:51 <Cale> MissPiggy: Well, it has as much category theory as we'd care to impose.
05:06:02 <Cale> Every Haskell type is itself a (simple) category.
05:06:07 <medf> can't I have like f 1 = 0 and then write f :: Int -> Int ... how is that a proof
05:06:14 <Axman6> Cale: it's right to say that types are propositions, and functions implementing those types are proofs of those prepositions right?
05:06:29 <Cale> With a unique arrow x -> y whenever y can be obtained from x by replacing undefined parts of x with other values.
05:06:32 <medf> oh...
05:06:37 <medf> nvm, misread
05:06:39 <Cale> The Haskell definable functions are then functors between types.
05:06:41 <MissPiggy> medf I would say it's not a proof but Cale says it is
05:06:41 <harlekin> medf, your implementation doesn't proof it's type.
05:06:55 <harlekin> medf, since f 2 is undefined.
05:07:02 <Cale> medf: It's a proof that if Int has an element, then Int has an element
05:07:06 <Axman6> MissPiggy: it is, it proves that if you have an integer, you can have an integer
05:07:08 <Cale> It doesn't matter than f 2 is undefined
05:07:14 <medf> @type undefined
05:07:15 <lambdabot> forall a. a
05:07:16 <Cale> undefined is also a value of type Int
05:07:29 <medf> can't I go f 1 = undefined f :: Int -> Int ?
05:07:30 <MissPiggy> Axman6 you keep saying "X is true" but not why.. it's kind of getting nowhere
05:07:50 <Axman6> MissPiggy: time to learn some porpositional logic i think :)
05:07:51 <medf> :t (undefined :: Int)
05:07:52 <lambdabot> Int
05:07:55 <medf> odd
05:08:01 <medf> well that's awkward.
05:08:05 <MissPiggy> Axman6 you don't know it or you are saying I don't know it?
05:08:11 <Cale> Haskell is an inconsistent logical system
05:08:18 <Axman6> i'm saying you don't
05:08:20 <Axman6> do you?
05:08:20 <Cale> So every proposition is true in one way or another.
05:08:38 <medf> why is it inconsistent?
05:08:45 <Cale> because everything is true ;)
05:08:56 <medf> everything that typechecks?
05:08:57 <Cale> Well, more specifically, because it supports general recursion
05:09:08 <Cale> There's a typechecking term of any type
05:09:11 <Cale> :t undefined
05:09:12 <lambdabot> forall a. a
05:09:15 <Axman6> but ony to make it useful!
05:09:22 <Cale> :t fix id
05:09:23 <lambdabot> forall a. a
05:09:25 <Cale> :t fix
05:09:27 <lambdabot> forall a. (a -> a) -> a
05:09:31 <MissPiggy> Cale, trying to decide if a 'proof' I write in haskell is valid or not could be a massive research problem (it's probably equivalent to showing some turing machine halts)
05:09:41 <Cale> MissPiggy: Hm?
05:09:57 <Cale> MissPiggy: A proof you write in Haskell is valid in Haskell supposing that it typechecks.
05:09:58 <MissPiggy> like if I write a proof of Int -> Int that impliments 3n+1
05:10:07 <Spockz|lap> is there a way to completely remove the haskell platform on OS X? GHC has a nice uninstaller, but I couldn't find one for the platform.
05:10:21 <Cale> MissPiggy: Whether the program terminates or not.
05:10:43 <danderson> Spockz|lap: can't you just use cabal to uninstall all installed packages before killing GHC?
05:10:44 <harlekin> f :: Int -> Int proposes â(x::Int) : x â x, but f 1 = 0, f _ = undefined doesn't proof it for each argument. Thus the proof is inconsistent, isn't it?
05:10:45 <medf> Cale: what is general recursion
05:11:01 <MissPiggy> Cale but these statements have no model, when I prove  P -> Not P  or whatever
05:11:21 <MissPiggy> so you are not proving something, it's just notation that looks like you are doing proofs
05:11:31 <Cale> medf: that's a good question, but essentially, the ability to use any function that you're defining as part of its definition.
05:11:34 <Spockz|lap> danderson: sure but I want to uninstall the whole system, so I can reinstall it and see whether these zlib problems go away. :(
05:11:35 <Cale> (or value)
05:11:49 <Cale> MissPiggy: You're proving something, it's just in an unusual logical system
05:12:41 <Cale> MissPiggy: Don't bother trying to be a Platonist around here. There is no objective notion of truth, put on your formalist hat. :)
05:13:12 <MissPiggy> Cale I guess this is just a matter of making words like "proof system" and "proof" have a much wider meaning (that includes stuff that doesn't have any reasonable interpretation -- is only syntax)
05:13:13 <Cale> MissPiggy: A logical system is a bunch of statements and rules for deriving more statements from existing ones.
05:13:47 <MissPiggy> I would call that a formal system
05:13:54 <Cale> Sure.
05:14:03 <Cale> formal system, logic, what have you.
05:14:07 <MissPiggy> logic would be something logical but in haskelL I can prove  IfIBuyFish -> ItWillRain
05:14:14 <Cale> As long as there's some notion of entailment, we're all good.
05:14:16 <MissPiggy> which is illogical :p
05:14:36 <Cale> It doesn't have to correspond to *classical* logic.
05:14:41 <Cale> and it doesn't.
05:14:52 <MissPiggy> it doesn't correspond to intuitionistic logic either
05:14:59 <Cale> It does too.
05:15:05 <medf> OH YEAH
05:15:06 <Cale> It is an intuitionist logic
05:15:20 <Cale> With enough axioms to be inconsistent.
05:15:31 <Cale> and an interesting semantics
05:16:09 <Cale> (in fact, we're much more concerned with the semantics than we are concerned with the truth of any given statement, since every statement is true)
05:16:27 <MissPiggy> but if I can prove existential statements which have no witness, is it really intuitionistic?
05:17:00 <Cale> They *do* have a witness.
05:17:00 <quicksilver> yes intuitionistic but not constructive
05:17:10 <quicksilver> (is one way some people use the words)
05:17:11 <Cale> undefined is a witness to every type
05:17:31 * Axman6 pokes copumpkin to get in on the haskell proof explanations
05:17:55 <MissPiggy> Axman6 I think it's a flaw to think if someone disagrees with you that they are wrong/don't know waht they are talking about btw
05:18:04 <Cale> Either a b is like  a \/ b,  (a,b) is like a /\ b
05:18:50 <Cale> Let Void be the type containing only undefined
05:18:56 <Cale> Then a -> Void is like Not a
05:19:17 <Axman6> MissPiggy: i suggested it because it was only after taking a course on proof and other things that i understoof why haskell programs are proofs of their types (to some degree anyway. i'm more a performance guy than a formal guy ;))
05:19:30 <Axman6> anyway, sleep time!
05:19:36 <MissPiggy> bye
05:19:36 <Cale> Note that while we can't get a proof of Not (Not a) -> a other than the undefined one, we can get a defined proof of Not (Not (Not a)) -> Not a
05:19:58 <Cale> See you
05:20:24 <MissPiggy> Cale yeah if you take total programs (and hide all the crazy type system extensions) it will correspond to LJ
05:20:56 <Cale> You can get various logical systems by restricting the amount of recursion you allow.
05:21:18 <Cale> But if you want general recursion/Turing completeness, you lose consistency.
05:22:39 <Cale> MissPiggy: In general, if you have almost any system of entailment, you can form a category from it, where there's an arrow A -> B for every proof of A |- B
05:23:10 <Cale> Of course, you need an associative concatenation of proofs with an identity, but almost any proof system worth its salt has that
05:23:35 <Cale> (and usually if not, you can form equivalence classes to make it happen)
05:24:05 <ski> ("a logic without cut-elimination is like a car without engine" -- Girard)
05:24:05 <Cale> and various logical operators give rise to certain categorical properties
05:25:01 <Cale> AND corresponds to having products, OR corresponds to having coproducts, Exponential objects correspond to having implication
05:25:24 <Cale> (or I should say implication corresponds to exponential objects rather)
05:25:53 <Cale> The initial object 0 corresponds to falsity, and the terminal object 1 corresponds to truth
05:26:10 <Cale> and in any category which has all these things, you can interpret the lambda calculus
05:26:28 <MissPiggy> I read about CCC being equiv. to STLC
05:26:35 <Cale> yeah
05:26:43 <MissPiggy> but that is just simple types so am not sure if that's the same kind of hting
05:26:47 <NEEDMOAR> Cale: how do you define Void in Haskell? What about forall a.a?
05:26:54 <Cale> data Void
05:26:56 <MissPiggy> cut-elimination means what, every proof has an equivalent beta-redex free proof?
05:27:01 <MissPiggy> this does not hold in haskell
05:27:06 <Cale> Or in Haskell 98,
05:27:12 <roconnor> NEEDMOAR: one trick for Haskel 98 is newtype Void = Void Void
05:27:16 <Cale> newtype Void = Void Void
05:27:17 <Cale> yeah
05:28:35 <roconnor> MissPiggy: I think techinically cut-elimination only exists in the sequent calculus, but it is roughly equivalent to normalization in natural deduction
05:28:48 <NEEDMOAR> forall a.a consists just of undefined?
05:29:02 <roconnor> forall a.a is good
05:29:12 <Spockz|lap> is there a way to fix this "incomnptaible zlib" error with cabal on Snow Leopard? I added the the compiler flags and I did a reinstall.
05:29:12 <roconnor> just not haskell 98
05:29:34 <Cale> cut-elimination is too strong
05:29:52 <Cale> If we want to use the perspective of logic to study programming.
05:30:06 <MissPiggy> roconnor oh there's a difference? I mean even a really subtle/technical one? I didn't know
05:30:15 <roconnor> yes
05:30:17 <Cale> (at least for Turing complete languages)
05:30:29 <MissPiggy> what is it?
05:30:50 <roconnor> well I think it is that cut-elimination is for the sequent calculus and normalization is for natural deduction.
05:31:27 <MissPiggy> I would have thought these things be equivalent, if we can make an isomorphism between the set of proofs in each system
05:31:34 <Cale> Er, well, hmm
05:32:09 <Cale> actually, maybe I take that back :)
05:32:10 <roconnor> I don't know how strong the equivalence is, but I think it isn't actually very strong if you look hard
05:32:20 <Cale> Cut elimination is essentially just composition
05:32:23 <ski> cut-elimination is that for every proof in sequent calculus, you can make an equivalent one, that doesn't use the cut rule
05:32:52 <ski> (and natural deduction doesn't have a cut rule; so, technically, it can't have cut-elimination)
05:32:54 <Cale> Oh, no, cut is composition
05:33:28 <ski> Cale : well, it depends a bit on the flavour (of the sequent calculus)
05:33:38 <roconnor> I'm not sure you can make an isomorphism between the two proof systems
05:33:48 <roconnor> gotta to drive to worki
05:33:51 <roconnor> be back soon
05:34:30 <ski> in LK, the cut rule is that if you can derive `Gamma0 |- A , Delta0' and `Gamma1 , A |- Delta1', then you may derive `Gamma0 , Gamma1 |- Delta0 , Delta1'
05:38:40 <MissPiggy> I should probably give in and use Cales terminology because that is in some sense simpler and more general but I want proofs to mean something :[
05:39:05 <MissPiggy> maybe I am plantonist and I just don't know...
05:39:13 <MissPiggy> I don't think that I am
05:39:32 <Cale> MissPiggy: Proofs in different formal systems might have different meanings
05:39:33 * ski might be a platonic formalist ..
05:39:38 <int-e> plankton? Platon? :)
05:39:39 <Cale> Different *kinds* of meaning
05:39:57 <Cale> In Haskell of course, the meaning of a proof is a program which you can run to do useful things.
05:39:58 <NeoMojo> the question is, would you feel comfortable telling your parents?
05:40:20 <ski> .. or not so useful
05:40:28 <Cale> Or not so useful, sure :)
05:40:53 <ski> > undefined undefined undefined
05:40:55 <lambdabot>   * Exception: Prelude.undefined
05:42:08 <MissPiggy> > sqrt(-2)*sqrt(-3)::Complex
05:42:09 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
05:42:09 <lambdabot>  Expected ki...
05:42:16 <MissPiggy> > sqrt(-2)*sqrt(-3)::Complex Rational
05:42:17 <lambdabot>   No instance for (GHC.Float.RealFloat
05:42:18 <lambdabot>                     (GHC.Real.Ratio GH...
05:42:30 <ski> (.. and, of course, the only proofs that really exist (platonically) are the total ones :)
05:42:34 <Cale> > sqrt (-2) * sqrt (-3) :: Complex Double
05:42:35 <lambdabot>   (-2.4494897427831783) :+ (-0.0)
05:42:58 <Cale> Well, and a bunch of other stuff which Haskell can't even represent ;)
05:43:27 <Cale> My platonic world, if I was a platonist, would be much different looking from roconnor's, say. :)
05:43:46 <FliPPeh> > 4/0
05:43:47 <lambdabot>   Infinity
05:43:55 <FliPPeh> :(
05:44:06 <FliPPeh> let chuckNorris = 0 in 4 / chuckNorris
05:44:10 <FliPPeh> > let chuckNorris = 0 in 4 / chuckNorris
05:44:11 <lambdabot>   Infinity
05:44:16 <ski> > recip (4/0)
05:44:17 <lambdabot>   0.0
05:44:26 <FliPPeh> :t recip
05:44:27 <lambdabot> forall a. (Fractional a) => a -> a
05:44:40 * ski briefly read "Infinity" as "Insanity" ..
05:44:49 <FliPPeh> :t Infinity
05:44:51 <lambdabot> Not in scope: data constructor `Infinity'
05:45:04 <Cale> If I were a Platonist, I would definitely consider the axiom of choice to be true.
05:45:26 <NEEDMOAR> Cale: and now? Do you consider it to be true?
05:45:28 <ski> Cale : how about the axiom of constructibility ?
05:45:29 <tensorpudding> is the axiom of choice "true"?
05:45:38 <Cale> NEEDMOAR: I consider it true in those systems where it is true.
05:46:13 <tensorpudding> you can construct systems where the converse of AOC holds that look realistic
05:46:16 <MissPiggy> ??
05:46:20 <ski> AC is true is the categories ( = mathematical universa) where it is true
05:46:31 <ski> s/is the/in the/
05:46:36 <Cale> I don't have a particularly strong opinion of V=L, except that the guy who I tend to trust on matters of set theory says that he thinks it probably ought to be false.
05:47:21 * hackagebot upload: syntax-trees 0.1 - Convert between different Haskell syntax trees. (DominicOrchard)
05:49:26 <Cale> He is a fan of large cardinals :)
05:50:12 <Cale> I'm not totally sure, but I think I'd want CH to be false.
05:50:28 * ski 's gut reaction is that AC should be true
05:50:37 <MissPiggy> in ZFC?
05:50:38 <NEEDMOAR> V=L? What's that?
05:50:53 <ski> (but then maybe i want quotient types ..)
05:50:57 <MissPiggy> V=L is a set theory axiom
05:51:00 <ski> NEEDMOAR : axiom of constructibility
05:51:09 <NEEDMOAR> Ahp.
05:51:11 * MissPiggy wants quotient types in coq...
05:51:19 <Cale> If you have AC and CH, then you can well order the reals in a special way, where the set of predecessors of every real number is countable.
05:51:53 * ski doubts that can be done in a constructive logic, though
05:51:58 <Cale> I'm okay with well ordering the reals, but I think that particular well-ordering goes a bit against the nature of how I'd like the reals to look.
06:03:39 <fasta> Do any of you know of a tool like Kig, but then you know, like works?
06:04:21 <medf> kig seems to work
06:05:15 <fasta> Try creating a half-line: a = (333.64132579485727, 342.89310318467426), b = (333.3443480877794, 342.5632760265683)
06:06:15 <Rneksp> http://tinyurl.com/yko2qsg
06:06:36 --- mode: ChanServ set +o xerox
06:06:46 --- mode: xerox set +b *!*Daz_*@*.tnyt1.lon.bigpond.net.au
06:06:51 --- kick: Rneksp was kicked by xerox (Rneksp)
06:07:57 <medf> I don't have it here but I recall it working okay for me, that's all
06:08:06 <mm_freak> @pl \r x y -> x : r y (x+y)
06:08:06 <lambdabot> liftM2 (.) (:) . (. (+)) . ap
06:08:13 --- mode: xerox set -o xerox
06:09:44 <fasta> medf, never mind. I will do it in some other way.
06:10:07 <FliPPeh> Has anyone ever written a sentence generator using markov chains in haskell?
06:11:41 <Janni> Hi. Once more a question a la "Is this function already in the base libraries, somewhere else, or am I missing something?". I'm just going over my old candidate-for-the-Prelude list, so here we go:
06:11:50 <Janni> churnl :: [a -> a] -> a -> a
06:11:50 <Janni> churnl [] = id
06:11:50 <Janni> churnl (f:fs) = churnl fs . f
06:12:04 <Janni> Of course I already checked with hoogle.
06:12:30 <Janni> This one I found useful quite some times...
06:12:44 <medf> hmm... foldr?
06:12:57 <ski> `churnl' can be written `foldr (flip (.)) id'
06:13:16 <Janni> Ah, OK. That's what I suspected.
06:13:17 <medf> :t (foldr (flip (.)) id)
06:13:18 * ski often calls `foldr (.) id' `compose' .. not sure if it's defined in the library somewhere
06:13:18 <lambdabot> forall a. [a -> a] -> a -> a
06:13:48 <ski> > foldr (.) id [(^ 2),(* 3)] 5
06:13:49 <lambdabot>   225
06:13:52 <ski> > foldr (flip (.)) id [(^ 2),(* 3)] 5
06:13:54 <lambdabot>   75
06:14:03 <ski> > foldr (.) id [(^ 2),(* 3)] a
06:14:04 <lambdabot>   a * 3 * (a * 3)
06:14:06 <ski> > foldr (flip (.)) id [(^ 2),(* 3)] a
06:14:07 <lambdabot>   a * a * 3
06:14:46 <benmachine> ski: I use appEndo . mconcat . map Endo
06:15:04 <ski> works as well
06:15:15 <xerox> > foldr (.) id [f,g,h] x :: Expr
06:15:16 <lambdabot>   f (g (h x))
06:15:20 <xerox> > foldr (flip (.)) id [f,g,h] x :: Expr
06:15:21 <lambdabot>   h (g (f x))
06:15:49 <benmachine> > expr $ foldr (>>>) id [f,g,h] x
06:15:50 <lambdabot>   h (g (f x))
06:16:07 <ski> > (appEndo . mconcat . map Endo) [f,g,h] x
06:16:09 <lambdabot>   f (g (h x))
06:16:19 <ski> @type expr
06:16:20 <lambdabot> Expr -> Expr
06:16:27 <medf> @type f
06:16:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:16:31 <xerox> ?hoogle Endo
06:16:31 <lambdabot> Data.Monoid newtype Endo a
06:16:31 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
06:16:32 <medf> :]
06:16:33 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
06:16:51 <Janni> This lambdabot guy... Thinks he knows everything, huh?
06:16:59 <medf> lol
06:17:10 <Zao> I thought that lambdabot was a she?
06:17:13 <ski> (usually, for some reason, we call it "she")
06:17:14 <benmachine> yeah
06:17:16 <medf> @vixen asl?
06:17:16 <lambdabot> 19/f/California
06:17:19 <medf> :)
06:17:39 <medf> nerdiest girl you'll ever see
06:17:41 <benmachine> bots are quite often female in my experience
06:17:53 <xerox> > (appEndo . mconcat . map Endo) [f,g,h] x
06:17:54 <benmachine> possibly as an attempt to compensate for the dearth of genuine articles >_>
06:17:54 <lambdabot>   f (g (h x))
06:17:56 <xerox> > (appEndo . mconcat . map Endo) [f,g,h] x
06:17:57 <lambdabot>   f (g (h x))
06:17:58 <xerox> sorry
06:18:09 <xerox> > (appEndo . getDual . mconcat . map Dual . map Endo) [f,g,h] x
06:18:11 <lambdabot>   h (g (f x))
06:18:14 <xerox> :D
06:18:22 * ski wonders whether it is common to think of one's computer as a MOTOS
06:18:54 <benmachine> what is a that
06:19:16 * ski replaces xerox's `map Dual . map Endo' with a `map (Dual . Endo)'
06:19:33 <ski> ("MOTOS" standing for "Member Of The Opposite Sex")
06:19:39 <benmachine> oic
06:19:46 <fasta> Is there some Haskell library which can already draw linear equation, half-lines and so on?
06:20:07 <fasta> linear-equations*
06:20:20 <fasta> linear equations*
06:20:20 <benmachine> the self-checkout machines in sainsbury's are all female
06:20:21 <burp> @src intercalate
06:20:21 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
06:20:22 <xerox> http://hackage.haskell.org/package/Chart
06:20:58 <benmachine> what surprised me is that when I went to boot's they had self-checkout machines there too and it was the SAME VOICE :O
06:21:11 <burp> @src intersperse
06:21:11 <lambdabot> intersperse _   []     = []
06:21:11 <lambdabot> intersperse _   [x]    = [x]
06:21:11 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
06:21:16 <benmachine> only it said thankyou for shopping at boots instead of thankyou for using sainsbury's self checkout
06:21:30 <benmachine> I felt deceived
06:23:21 <Janni> It's quite instructive to see how my own functions can be expressed more concisely, so here's another one:
06:23:23 <Janni> iterateMaybe :: Control.Monad.MonadPlus m => (a -> Maybe a) -> a -> m a
06:23:23 <Janni> iterateMaybe f x = Control.Monad.mplus (return x) $ maybe Control.Monad.mzero (iterateMaybe f) (f x)
06:23:27 <ski> @. hoogle type (foldr (.) id .) . intersperse
06:23:28 <lambdabot> Parse error:
06:23:28 <lambdabot>   --count=20 "forall b. (b -> b) -> [b -> b] -> b -> b
06:23:29 <lambdabot> "
06:23:34 <ski> bah!
06:23:53 <ski> @hoogle (a -> a) -> [a -> a] -> (a -> a)
06:23:53 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:23:54 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
06:23:54 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:24:32 <ski> (Janni : i hope you're not repeating that `Control.Monad' prefix in all your code ..)
06:25:10 <benmachine> Janni: imo making that MonadPlus is unnecessarily generic
06:25:18 <fasta> xerox, does zooming already work in Chart?
06:25:20 <Janni> ski: Err no, that's just for this large module with all kinds of functions. Has many imports.
06:25:23 <benmachine> hmm wait
06:25:31 <ski>   iterateMaybe f x = return x `mplus` maybe mzero (iterateMaybe f) (f x)  -- there, now i can read it
06:25:55 <ski> Janni : you know you can `import qualified Control.Monad as CM', and then use `CM' as prefix instead, right ?
06:25:58 <benmachine> that never returns mzero, does it?
06:26:24 <Janni> ski: Yeah, of course...
06:26:36 * benmachine tries to work out if it ever returns anything other than "return y" for some y
06:26:59 <benmachine> (I've written and used iterMaybe :: (a -> Maybe a) -> a -> a before)
06:27:36 <xerox> ?type unfoldr
06:27:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:27:45 <benmachine> yeah, the whole MonadPlus bit of that is redundant, isn't it?
06:28:06 <Janni> benmachine: Yes, think so...
06:28:42 <benmachine> iterMaybe f x = maybe x (iterMaybe f) (f x)
06:28:54 <benmachine> @pl iterMaybe f x = maybe x (iterMaybe f) (f x)
06:28:54 <lambdabot> iterMaybe = fix (ap . flip maybe =<<)
06:28:55 <Janni> But still, with [a] instead of m a this might be a useful function for Data.Maybe?
06:29:04 <ski> > let iterateMaybe f x = return x `mplus` maybe mzero (iterateMaybe f) (f x) in iterateMaybe (\x -> guard (x < 100) >> Just (2*x)) 1 :: [Integer]
06:29:05 <lambdabot>   [1,2,4,8,16,32,64,128]
06:29:18 <benmachine> oh I see
06:29:45 <ski> @hoogle Maybe a -> m a
06:29:45 <lambdabot> Data.Monoid First :: Maybe a -> First a
06:29:45 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
06:29:45 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:29:52 <benmachine> :t until
06:29:54 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
06:31:27 <benmachine> > \f -> until (maybe True (const False)) (>>= f)
06:31:31 <lambdabot>   mueval-core: Time limit exceeded
06:31:31 <benmachine> eer
06:31:45 <benmachine> :t \f -> until (maybe True (const False)) (>>= f)
06:31:47 <lambdabot> forall a. (a -> Maybe a) -> Maybe a -> Maybe a
06:31:53 <benmachine> hm
06:32:05 <benmachine> yeah that is silly actually
06:32:08 * benmachine is silly
06:34:23 <Janni> What about this one? I found it very convenient at times to avoid do notation. I'm not so sure about the naming though...
06:34:25 <Janni> (<<) :: Monad m => m b -> m c -> m b
06:34:25 <Janni> p << q = do
06:34:25 <Janni>   result <- p
06:34:25 <Janni>   q >> return result
06:36:10 <ski> @type uncurry until . ((isJust .) &&& (fromJust .))
06:36:11 <lambdabot> forall a. (a -> Maybe a) -> a -> a
06:37:00 <benmachine> Janni: I think Control.Applicative.<* is pretty similar to that
06:37:28 <benmachine> and by pretty similar I mean does the exact same thing in all cases where both are applicable :P
06:37:41 <zygoloid> Janni: a lot of people think that (<<) should be flip (>>)...
06:37:52 <benmachine> yeah
06:37:56 <benmachine> there is that issue
06:38:06 <benmachine> personally I think <* should be flip (*>) but it isn't
06:38:09 <Janni> Yes, that's what I was refering to myself ("naming")
06:38:24 <zygoloid> benmachine: yeah, but there's analogy to <*> to help out there at least
06:38:49 <zygoloid> all the applicative combinators sequence left-to-right iirc
06:39:32 <benmachine> @src (<**>)
06:39:32 <lambdabot> (<**>) = liftA2 (flip ($))
06:39:36 <benmachine> oic
06:40:09 <ski> Janni : fwiw, in SML, your `<<' is called `before'
06:41:49 <zygoloid> Janni: also, in a parser i wrote a while back, i had an 'ignore :: Monad m => m a -> (b -> m b)', so i could write: openParen >> expression >>= ignore closeParen
06:42:06 <zygoloid> ignore x y = x >> return y
06:43:11 <Janni> Sounds good.
06:44:01 <benmachine> hmm
06:44:08 <manjunaths> is there a haskell equivalent of python dir cmd ?
06:44:08 <benmachine> :t flip (<$)
06:44:10 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f b -> a -> f a
06:44:32 <manjunaths> or something like ctags for haskell ?
06:44:33 * ski would expect `ignore :: Functor f => f a -> f ()' ..
06:44:40 <benmachine> manjunaths: you can :browse a module in ghci, or get :info on stuff
06:45:02 <benmachine> (if I remember what dir does, which I might not)
06:45:10 <benmachine> (well you still can if I don't, it just doesn't help)
06:45:26 <ski> @type flip (fmap . const)
06:45:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> b -> f b
06:45:38 <ski> .. i suppose it's not that far away
06:47:04 <dschoepe> manjunaths: there's hasktags, http://haskell.org/ghc/docs/latest/html/users_guide/utils.html
06:47:30 <manjunaths> dschoepe, thanks
06:47:43 <manjunaths> can I dump the output of :browse into a file
06:48:39 <Janni> OK, next one. You have to tell me, when I'm bothering you with this stuff... An excerpt of my Combine library. Question is the same as before... could I have saved the effort of writing these functions?
06:48:50 <Janni> combineWith :: (a -> a -> b) -> [a] -> [b]
06:48:50 <Janni> combineWith f [] = []
06:48:50 <Janni> combineWith f (x:xs) = map (f x) xs ++ combineWith f xs
06:49:02 <Janni> Most easily to understand by this instance
06:49:03 <Janni> combine :: [a] -> [(a,a)]
06:49:03 <Janni> combine = combineWith (,)
06:49:19 <Janni> s/Most easily/Easiest/
06:49:39 <manjunaths> figured it thanks
06:49:46 <manjunaths> echo ":browse Graphics.Rendering.OpenGL" |ghci
06:50:45 <Janni> combine [1,2,3] = [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
06:51:19 <xerox> > liftM2 (,) [1,2] [2,3,4]
06:51:20 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4)]
06:51:47 <xerox> hm
06:51:55 <manjunaths> what is this ?? -> data Vertex3 a = Vertex3 !a !a !a
06:52:13 <manjunaths> what are the bangs ?
06:52:16 <xerox> portuguese code with exclamations
06:52:21 <aledgior> hur hur
06:52:21 <cebewee> the ! enforce strict evaluation of the parameters
06:52:39 <manjunaths> cebewee, thanks
06:53:28 <benmachine> > let xs = [1,2,3,4] in (,) <$> xs <*> tails xs
06:53:30 <lambdabot>   [(1,[1,2,3,4]),(1,[2,3,4]),(1,[3,4]),(1,[4]),(1,[]),(2,[1,2,3,4]),(2,[2,3,4...
06:53:36 <benmachine> hmm
06:54:51 <Janni> Good thought though.
06:56:46 * benmachine wonders if there is some analogy between foldr and weak induction / strong induction
06:57:08 <ski> > getZipList $ let xs = [0,1,2,3] in (,) <$> ZipList xs <*> ZipList (tails xs)  -- closer
06:57:10 <lambdabot>   [(0,[0,1,2,3]),(1,[1,2,3]),(2,[2,3]),(3,[3])]
06:57:35 <gwern> preflex: seen thartmann
06:57:35 <preflex>  Sorry, I haven't seen thartmann
06:57:38 <gwern> preflex: seen thartman
06:57:38 <preflex>  Sorry, I haven't seen thartman
06:57:41 <ski> > let xs = [0,1,2,3] in zipWith (,) xs (tails xs)  -- simpler
06:57:42 <lambdabot>   [(0,[0,1,2,3]),(1,[1,2,3]),(2,[2,3]),(3,[3])]
06:57:48 * gwern ?_?
06:58:00 <benmachine> > let xs = [0,1,2,3] in zipWith (,) xs (concat (tails xs))
06:58:01 <lambdabot>   [(0,0),(1,1),(2,2),(3,3)]
06:58:06 <benmachine> whoops
06:58:45 <Janni> Still, nice to see such sportsmanship :-)
06:58:49 <benmachine> heh
06:59:00 <benmachine> it's an interesting curiosity
06:59:27 <benmachine> :t \xs -> zipWith (,) xs (tails xs)
06:59:28 <lambdabot> forall a. [a] -> [(a, [a])]
06:59:58 <benmachine> @hoogle (a, [a]) -> [(a, a)]
06:59:58 <lambdabot> No results found
07:00:00 <benmachine> :(
07:00:11 <zygoloid> > uncurry zip . (repeat . head &&& map head . drop 1 . init . tails) <=< tails $ [1,2,3,4]
07:00:12 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
07:00:16 <zygoloid> winner?
07:00:26 * benmachine melts
07:00:28 <Janni> WTF <- sorry :-)
07:00:36 <zygoloid> combineWith f = uncurry (zipWith f) . (repeat . head &&& map head . drop 1 . init . tails) <=< tails
07:00:41 <benmachine> :t \xs -> concatMap (\(x, xs) -> map ((,) x) xs) $ zipWith (,) xs (tails xs)
07:00:43 <lambdabot> forall a. [a] -> [(a, a)]
07:00:43 <ski> > let xs = [0,1,2,3] in (concat . map (uncurry (map . (,)))) (zipWith (,) xs (tails xs))  -- hmpf ?
07:00:44 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
07:00:52 <benmachine> let xs = [0,1,2,3] concatMap (\(x, xs) -> map ((,) x) xs) $ zipWith (,) xs (tails xs)
07:00:58 <benmachine> > let xs = [0,1,2,3] in concatMap (\(x, xs) -> map ((,) x) xs) $ zipWith (,) xs (tails xs)
07:00:59 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
07:01:17 <Janni> yay.
07:01:19 <benmachine> oh I think we're doing the same thing
07:01:20 <zygoloid> nearly
07:01:29 <benmachine> still more complicated, still not quite right :P
07:01:30 <zygoloid> you're keeping (a, a)
07:01:45 <benmachine> > let xs = [0,1,2,3] in concatMap (\(x, xs) -> map ((,) x) (tail xs)) $ zipWith (,) xs (tails xs)
07:01:46 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:01:46 <ski> ah, the `drop 1'
07:02:06 <benmachine> > let xs = [0,1,2,3] in concatMap (\(x, _:xs) -> map ((,) x) xs) $ zipWith (,) xs (tails xs)
07:02:07 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:02:26 <benmachine> > let xs = [0,1,2,3] in (\(x, _:xs) -> map ((,) x) xs) =<< zipWith (,) xs (tails xs)
07:02:27 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:02:57 <benmachine> > let xs = [0,1,2,3] in uncurry (\x -> map ((,) x) . tail) =<< zipWith (,) xs (tails xs)
07:02:58 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:03:06 <benmachine> ok I'm bored now :P
07:03:20 <zygoloid> @hoogle cojoin
07:03:20 <lambdabot> No results found
07:03:26 <benmachine> Janni: in conclusion, your original version was probably fine
07:03:42 <zygoloid> certainly seems like a comonadic problem...
07:03:43 <Janni> I can see that :-)
07:04:19 <benmachine> although I wonder if you couldn't abstract the recursion a little bit by using whatsit
07:04:22 <benmachine> destructList
07:04:25 <benmachine> which doesn't exist
07:04:32 <benmachine> but someone was talking about the other day
07:04:45 <Janni> You have/know the code?
07:04:57 <benmachine> @type destructList
07:04:59 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
07:05:02 <benmachine> oh it's still there
07:05:11 <benmachine> it's fairly trivial though
07:05:12 <benmachine> just an idea.
07:05:19 <Janni> @src destructList
07:05:19 <lambdabot> Source not found. :(
07:05:48 <benmachine> it's basically just, case list of [] -> first arg; x:xs -> secondarg x xs
07:06:47 <benmachine> :t fix $ \cw f xs -> destructList [] (\x xs -> map (f x) xs ++ cw f xs)
07:06:48 <lambdabot>     Couldn't match expected type `[b]'
07:06:48 <lambdabot>            against inferred type `[t1] -> [b]'
07:06:49 <lambdabot>     In the expression:
07:06:56 * benmachine noob
07:07:09 <benmachine> :t fix $ \cw f xs -> destructList [] (\x xs -> map (f x) xs ++ cw f xs) xs
07:07:10 <lambdabot> forall t1 b. (t1 -> t1 -> b) -> [t1] -> [b]
07:07:44 <zygoloid> > concat ([1,2,3,4] =>> (\(t:ts) -> map ((,) t) ts))
07:07:45 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
07:07:47 <zygoloid> hooray for comonads :)
07:08:05 <benmachine> > let cw f = destructList [] (\x xs -> map (f x) xs ++ cw f xs) in cw (,) [0,1,2,3]
07:08:06 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:08:23 <benmachine> okay zygoloid wins
07:08:37 <zygoloid> concat (codo t:ts <- xs; map ((,) t) ts)
07:08:47 <benmachine> codo :O
07:08:53 <zygoloid> :D
07:09:05 * edwardk looks up at the mention of comonads.
07:09:06 * benmachine approves
07:09:22 <edwardk> i've always been fond of calling it 'undo' ;)
07:10:54 <benmachine> @pl \(+) x -> f x + g x
07:10:54 <lambdabot> (line 1, column 3):
07:10:54 <lambdabot> unexpected "+"
07:10:54 <lambdabot> expecting pattern
07:11:01 <benmachine> how is that not a pattern :(
07:11:03 <edwardk> i have a scheme macro for comonad sugar that i rather enjoy using
07:11:14 <benmachine> @pl \h x -> f x `h` g x
07:11:14 <lambdabot> (`ap` g) . (. f)
07:11:15 <ski> > liftM2 (,) pick pick `runAffine` [0,1,2,3] :: [(Integer,Integer)]
07:11:17 <lambdabot>   [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]
07:11:30 <benmachine> :t runAffine
07:11:32 <lambdabot> forall t (m :: * -> *) a. (MonadPlus m) => StateT [t] m a -> [t] -> m a
07:12:07 <zygoloid> edwardk: since getting a handle on monads and comonads i've started seeing monads everywhere and comonads... rarely. when do you use your sugar?
07:13:06 <edwardk> zygoloid: mostly to make the worlds most obfuscated fib =)
07:14:19 <ski> > liftM2 (,) munch munch `runAffine` [0,1,2,3] :: [(Integer,Integer)]
07:14:20 <lambdabot>   [(0,1)]
07:14:21 <ski> > liftM2 (,) select select `runAffine` [0,1,2,3] :: [(Integer,Integer)]
07:14:23 <lambdabot>   [(0,1),(0,2),(0,3),(1,0),(1,2),(1,3),(2,0),(2,1),(2,3),(3,0),(3,1),(3,2)]
07:14:41 <ezyang> I'd like to take a stab at implementing "transient creation" semantics in Haskell, which means you're allowed to use mutation when you're creating a data structure for the first time, and then no further.
07:15:04 <ezyang> I'm not 100% sure how to juggle around the ST monad, nor whether or not I need unsafeFreeze/Thaw
07:15:40 <thoughtpolice> preflex: seen copumpkin
07:15:40 <preflex>  copumpkin was last seen on #haskell 8 hours, 2 minutes and 23 seconds ago, saying: :)
07:18:42 * ksf is looking for an already implemented haskell rtree and is surprised to find none
07:18:56 <ski> @type (readIORef =<<) . mfix . (newIORef .)
07:18:58 <lambdabot> Not in scope: `readIORef'
07:18:58 <lambdabot> Not in scope: `newIORef'
07:19:01 <ski> .. bah!
07:19:14 <ski>   (IORef a -> a) -> IO a
07:19:58 <ski> edwardk : link ?
07:20:39 <ksf> ...there's a set supporting range queries, but no tree, neither one nor two-dimensional
07:20:46 <edwardk> ski: re codo sugar?
07:20:48 <benmachine> how do you get a (IORef a -> a)
07:20:54 <benmachine> that isn't consty
07:21:23 <edwardk> ski: checking to see if i have it online
07:21:45 <edwardk> ski: http://comonad.com/scheme/monads/base.scm od*
07:22:05 <edwardk> ski: the names were to make someone else happy. take them with a grain of salt ;)
07:22:25 <edwardk> i've since converted to something more haskell-ish for my own use
07:23:09 <ski> ty
07:23:18 * ksf wonders what frag and lambdacube use
07:23:24 * ski wondered about `tinu' and `rats' :)
07:23:57 <edwardk> ski: friedman wanted unit and star as the operations for the monad, reverse them for comonads ;)
07:24:17 <ski> yes, i noticed :)
07:24:22 <roconnor> > 2^(2^(2^8)
07:24:23 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:24:25 <roconnor> > 2^(2^(2^8))
07:24:30 <lambdabot>   mueval: ExitFailure 1
07:24:54 <edwardk> i have a plt scheme specific version that doesn't use the horrible hack of positional dictionaries, but requires stuff that is out of scope for the audience
07:25:17 <roconnor> > 2^(2^(8))
07:25:19 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
07:25:37 <roconnor> that's a lot of nodes for a tree
07:25:43 <NeoMojo> > 2^256
07:25:45 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
07:26:10 <Cale> > 2^2^8
07:26:11 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
07:26:12 <roconnor> > 2^(2^(8)
07:26:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:26:16 <roconnor> > 2^(2^4)
07:26:17 <lambdabot>   65536
07:26:23 <Cale> ^ is right-associative anyway
07:26:25 <edwardk> > 2^2^2^2^2
07:26:26 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
07:26:45 <edwardk> er woops.
07:27:08 <benmachine> > 2**2**8
07:27:10 <edwardk> > 2^2^2^3
07:27:10 <lambdabot>   1.157920892373162e77
07:27:12 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
07:27:21 <benmachine> e77, cool
07:27:51 <theDude> hi, why is this code not working? chomp (x:xs) = takeWhile(==x) (take 9 (x:xs)) : chomp (dropWhile(==x) (take 9 (x:xs)) : (drop 9 (x:xs)))
07:29:14 <roconnor> MissPiggy: Do you recall a paper talking about epigram or agda that mentioned (either directly or indirectly) NoConfusiong or NoJunk lemmas?
07:29:24 <Cale> theDude: Did you forget to define a base case?
07:29:27 <benmachine> theDude: elaborate on "not working"
07:29:31 <roconnor> or anyone else
07:29:37 <MissPiggy> yeah SOme Constructions on Construction
07:29:52 <theDude> That keeps giving me error.
07:29:56 <MissPiggy> http://www.e-pig.org/downloads/concon.pdf
07:29:58 <ksf> http://www.dinkla.net/fp/cglib.html
07:30:00 <Cale> > let chomp [] = []; chomp (x:xs) = takeWhile(==x) (take 9 (x:xs)) : chomp (dropWhile(==x) (take 9 (x:xs)) : (drop 9 (x:xs))) in chomp "aaaaaaaaaaaaaaaaaaaaaabbbcccccdddeee"
07:30:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:30:05 <ksf> why isn't that on hackage?
07:30:06 <Cale> ah, I see
07:30:10 <theDude> Also is there a way to put a clause on the takeWhile to only happen at 9 times max?
07:30:11 <roconnor> MissPiggy: thanks!
07:30:14 <roconnor> MissPiggy++
07:30:56 <Cale> theDude: take 9 (x:xs) : drop 9 (x:xs)  makes no sense
07:31:33 <Cale> theDude: you can't take the first 9 elements of a list, and stick that on as the first element of a list
07:31:41 <benmachine> : needs a thing on the left and a list of things on the right
07:31:41 <Cale> er, of the same list
07:31:53 <Cale> if (x:xs) :: [a]
07:32:06 <Cale> then drop 9 (x:xs) :: [a], and take 9 (x:xs) :: [a]
07:32:14 <Cale> but (:) :: t -> [t] -> [t]
07:32:42 <ksf> oh noes, it indexes _points_, not ranges.
07:33:00 <theDude> Ok, can I have takeWhile only happen for 9 items?
07:33:04 <Cale> So in order for take 9 (x:xs) : drop 9 (x:xs) to make sense, you'd need t = [a], and [t] = [a], and so a = [a], which means that these are infinitely-nested lists
07:33:11 <ski> edwardk : the empty case of `do*' looks strange
07:33:32 <Cale> > [1,2,3] : [4,5]
07:33:34 <lambdabot>   No instance for (GHC.Num.Num [t])
07:33:34 <lambdabot>    arising from the literal `4' at <inter...
07:33:37 <theDude> like takeWhile(==x && only do max of 9)
07:33:40 <Cale> ^^ similar problem
07:34:07 <benmachine> takeWhile (== x) (take 9 xs)?
07:34:08 <Cale> theDude: combining takeWhile and take makes sense
07:34:08 <edwardk> ski: ((do* m comp-body) comp-body) ?
07:34:45 <benmachine> theDude: your methods of producing lists are okay, it's just that your methods of combining them afterwards doesn't really work
07:34:48 <benmachine> *don't
07:34:58 <theDude> i think i get it
07:35:12 <burp> :t (++)
07:35:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:35:14 <theDude> I need to use something to join a lists together
07:35:15 <theDude> not :
07:35:21 <burp> :t Prelude.(++)
07:35:22 <lambdabot> Not in scope: data constructor `Prelude'
07:35:28 <edwardk> ski: i haven't looked at this version in a long time. it could very well be wrong
07:35:33 <ski> edwardk : yes, why not `((do* m () comp-body) comp-body)' instead, and then drop the singleton case ?
07:35:38 <NeoMojo> :t (++)
07:35:39 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:35:48 <benmachine> if you've got [1,2] and [3,4] and you want [1,2,3,4] you want to use ++
07:36:07 <burp> :t (Prelude.++)
07:36:09 <lambdabot> forall a. [a] -> [a] -> [a]
07:36:20 <benmachine> if you want [[1,2],[3,4]] that's a bit different
07:36:27 <theDude> I had totally forgot the difference between : and ++ :p
07:36:31 <theDude> thanks :)
07:36:33 <ski> edwardk : also, is `fold-left' defined by you ?
07:36:43 <benmachine> theDude: btw, take 9 xs ++ drop 9 xs == xs :P
07:36:49 <edwardk> ski: the sugar has changed since then to be more haskelly (do (x <- foo bar baz) (quux quaffle x))
07:37:03 <ski> edwardk : no explicit `m' anymore ?
07:37:51 <edwardk> the m is passed, but it is plumbed through as the last argument. so you can often leave it unspecified. everything is 'reader monad transformed' with the monad dictionary as the environment
07:38:00 <edwardk> that way you can say things like
07:38:13 <ski> ah
07:38:37 <theDude> benmachine: yeah I know :), I am doing something slightly different
07:38:37 <edwardk> (define (modify f) (do (x <- get) (put (f x)))
07:38:50 <copumpkin> omg it's edwardk
07:39:05 <copumpkin> back from his long absence!
07:39:18 <edwardk> and it is polymorphic in the state monad. do returns a function from the monad dictionary, and get and put are also functions that expect the dictionary as their last argument.
07:39:26 <edwardk> i use a lot more currying as a result
07:39:26 <edwardk> copumpkin: heya =)
07:39:30 <copumpkin> :)
07:39:41 <Cale> edwardk: Which language is this?
07:39:45 <edwardk> cale: scheme
07:39:46 <ski> Cale : Scheme
07:40:11 <Cale> Okay, so not some other variation you concocted :)
07:40:25 <edwardk> cale: nah, kata is still the same ;)
07:40:40 <Cale> Scheme could use a proper type system, I think ;)
07:40:48 <edwardk> cale: though i'm still running into problems with lexical scoping and my macro system
07:40:49 <ski> edwardk : any more recent changes to `od*', then ?
07:41:03 <ski> (other than the analogous for `do*' into `do')
07:41:05 <edwardk> ski: similar dictionary plumbing changes
07:41:21 <fasta> edwardk: ok, and what about combining a state monad, a writer monad and the st monad in Scheme?
07:41:23 <ski> Cale : there is something called Typed Scheme
07:41:38 <edwardk> ski; even though, in the case of the comonad, you do always have an object to ask for its dictionary, so i could plumb it through by baking it in, vtable-like into every comonad
07:41:41 <ski> (in PLT Scheme (soon to be called Racket), iirc)
07:42:33 * ski idly wonders whether one could bake a dictionary into the continuation for a monadic action ..
07:42:58 <edwardk> fasta: (run-reader myenv (run-writer mymonoid (do (x <- ask) (tell x) (tell x) ))) ; feel free to add state
07:43:10 <Cale> ski: What sort of type system does it use? Something HM-inspired, I hope?
07:43:42 <edwardk> cale: fraid not, its a fairly simple success typing thing, with a bunch of contract fallbacks
07:44:11 <Cale> blah
07:44:16 <copumpkin> lol
07:44:20 <fasta> edwardk: that looks relatively good. Is it open-source?
07:44:32 <ski> Cale : i've not really looked at it, only heard it spoken of .. but iirc, it can track some things like one function only accepting numbers satisfying `prime?' and it noting when an `if' with such a test succeeds
07:44:40 <copumpkin> Calecat demands moar types
07:44:50 <ski> (i'm afraid i don't know very much about it)
07:45:15 <ski> (iirc, samth is involved in it, so you could try asking)
07:45:22 <Cale> ski: statically?
07:45:23 <edwardk> fasta: it is if i ever get around to posting it all in one place. the version i linked ski to was an older version
07:45:27 <ski> Cale : yes
07:45:34 <edwardk> fasta: i think i lisppasted a good chunk of this somewhere
07:45:57 <edwardk> http://paste.lisp.org/display/86914
07:46:05 <edwardk> fasta: check that out
07:46:09 <ski> (there's also a contract system for keeping track dynamically of preconditions and postconditions, and who's to blame when something goes wrong)
07:46:18 <Cale> How's the type inference?
07:47:25 * ski repeats that he's not tried it ..
07:47:39 <Cale> hmm, perhaps I'll look at it :)
07:47:49 <fasta> edwardk: If I need a Scheme programmer, I will know who to call. Nice.
07:47:52 <edwardk> sam gave a talk on typed scheme very recently. hrmm. lemme see if i can dig it up. here is a link though to get a feel: http://www.ccs.neu.edu/home/samth/typed-scheme/
07:48:15 <edwardk> fasta: warning that was the first time i'd written in scheme in several years. ;)
07:48:45 * ski presumes "sam" uses the nick "samth"
07:49:22 <fasta> edwardk: Haskell usually then?
07:49:33 <edwardk> yeah, he's local, over here at northeastern IIRC.
07:50:10 <ksf> gosh. is there a single year of the day where citeseer is available 24 hours?
07:50:17 <ksf> er day of the year
07:50:31 <edwardk> fasta: i'm usually cobbling stuff together in haskell, perl, c#, c++, or er.. well, whatever seems appropriate to the problem domain. ;)
07:50:56 <FliPPeh> God, PHP programmers...
07:51:16 <fasta> edwardk: I am more of the "build fundamental algorithms"-kind.
07:51:22 <FliPPeh> This dude spaced his lines to 135 - 170 chars using spaces.
07:51:25 <Janni> @src tails
07:51:25 <lambdabot> tails []         = [[]]
07:51:25 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
07:51:27 <FliPPeh> For no reason.
07:51:32 <ksf> ...and does the nasa really _have_ to publish their papers as scans?
07:51:37 <badsheepy> i think what you mean is 'incompetent programmers'
07:51:43 <badsheepy> php doesnt make you incompetent :p
07:51:44 <edwardk> fasta: my problem with scheme is that there is no good repository of useful structures that is in use by more than 3 people ;)
07:51:57 <FliPPeh> But lots of them do it, badsheepy :(
07:51:59 <fasta> badsheepy, the thing is, nobody has ever observed a competent PHP programmer.
07:52:09 <FliPPeh> It's like PHP forces you to be a messy
07:52:12 <Ke> paradox
07:52:17 <FliPPeh> No wonder I ditched it
07:52:21 <badsheepy> noone pays any attention to a competent programmer :P
07:52:26 <fasta> It would be like observing the God particle.
07:52:34 <ksf> I bet it's because a digital "approved for public release" stamp is a thing us government agencies just can't fathom.
07:52:59 <badsheepy> i dont become any less competent when i code php than i am normally
07:53:05 <fasta> ksf, you can try sending them an email.
07:53:07 <badsheepy> i guess that means im generally incompetent :(
07:53:28 <fasta> ksf, and also some times people are just ignorant, although they are brilliant in some areas.
07:53:29 <ski> edwardk : arcfide seems to be trying to make useful inter-implementation meta-repository
07:55:00 <edwardk> ski: i'm not holding my breath. the scheme guys don't seem to have a large enough common core for anything useful to port ;)
07:55:31 <ksf> first step to get it readable: ignore the acrobat reader plugin and open the pdf in okular
07:55:34 <edwardk> referring to 'arctic'?
07:55:47 <ksf> ...which is one of those rare kde program that's actually good.
07:55:48 <ski> (yes, that's probably what it was called)
07:56:16 <edwardk> ski: i don't remember who was at the last scheme workshop pitching something similar.
07:56:45 <edwardk> ah. heh, i think the same guy =)
07:56:46 <edwardk> Descot
07:57:03 <edwardk> Aaron W. Hsu == arcfide?
07:57:30 <ski> yes, i was just about to say that :)
07:58:41 <fasta> It is kind of nice that the following works: take 1 $ snd $ runSTLazy(runWriterT $ do newRef "hi"; tell "OMG";error "Universe exploding"; void)
07:58:49 <edwardk> ski: that said, it looks more like a way to find a bunch of scheme code that does something kinda sorta like what you'd want, not necessarily to get code you'd be able to run on your platform.
07:59:21 <fasta> The Tower of Babel people have introduced is really annoying.
07:59:50 <fasta> New programming languages should just be able to call anything anyone has ever written before without issues.
07:59:54 <Cale> Hmm, it does seem to handle algebraic datatypes reasonably well, but the type inference can't cope with even something as simple as fib.
08:00:25 <fasta> It is not even that hard to do that for one platform.
08:00:32 <benmachine> @tell Berengal destructList f z xs = fst (foldr g (z, []) xs) where g x (_, xs) = (f x xs, x:xs) -- is this neater?
08:00:33 <lambdabot> Consider it noted.
08:01:28 <Cale> It supports arbitrary type unions, which makes inference probably out of the question.
08:01:30 <edwardk> ski: oh yeah, did you notice i included idiom sugar in that last paste as well?
08:01:35 * benmachine actually got out his notes from last term on the proof of the strong principle of induction based on the weak principle of induction to work that out
08:01:41 <edwardk> cale: yep
08:02:01 <ski> edwardk : yes .. that's why i wondered about whether `fold-left' was your creation
08:02:46 <edwardk> ski: nah it is a plt-scheme-ism
08:03:01 <ski> benmachine : defining `destructList' in terms of `foldr' ?
08:03:27 <ski> ok
08:04:23 <benmachine> ski: yes
08:04:28 <benmachine> well, sort of
08:04:52 <benmachine> is that weird?
08:04:54 * ski supposes that maybe he should try to implement reflective syntax in Scheme, using a similar dictionary-passing under-the-hood
08:05:04 <edwardk> ski: somewhere around here i have a cps macro for doing Philippa's 'applicative do' sugar as well.
08:05:10 <ski> benmachine : not really :)
08:05:25 <edwardk> ski: i was very pleased when i figured out that hack
08:05:33 <ski> benmachine : i've defined `zipWith' in terms of `foldr', so who am i to complain ? ;)
08:05:46 <edwardk> ski: it works very well with some kind of currying macro that permits over/under-application
08:05:55 <ski> edwardk : not sure if i've seen that sugar
08:05:59 <roconnor> @type let t p = \h g -> h (g . p) in t
08:06:01 <lambdabot> forall (f :: * -> *) a b t. (Functor f) => f a -> (f b -> t) -> (a -> b) -> t
08:06:13 <edwardk> ski: which is what motivated that rather pedantic haskell-ish define-curried
08:06:15 <benmachine> foldr is officially the mother of all list functions
08:06:17 * roconnor sighs
08:06:26 <benmachine> (of course everyone else knew this long before I did)
08:06:56 <ski> @tell Philippa edwardk mentioned "applicative `do'" sugar of yours. any link or elaboration ?
08:06:56 <lambdabot> Consider it noted.
08:07:15 <edwardk> ski: ah the notion is to desugar ado x <- foo; y <- bar baz quux; z <- quaffle; test x y (foo z) into (\x y z -> test x y (foo z)) <$> foo <*> bar baz quux <*> quaffle
08:07:29 <ski> roconnor : what theorem are you trying to prove ?
08:07:37 <edwardk> ski: the bound names are only available in the last clause, but you can get by with just resugaring down to an applicative
08:07:43 <roconnor> I'm still on about Renyold's theorem
08:07:47 <roconnor> trying to understand it
08:07:51 <MissPiggy> parametricity/
08:07:51 <MissPiggy> ?
08:07:55 <MissPiggy> or something else?
08:08:07 <roconnor> MissPiggy: system-F has no set theoretic interpretation
08:08:07 * ski has no idea what Reynold's theorem is .. :/
08:08:18 <MissPiggy> mm
08:08:33 <roconnor> or none that maps (a -> b) to the set function space
08:08:57 <edwardk> ski: but it defies a simple translation, so you need to convert to use cps'd syntax-rules as I recall
08:09:21 <ski> edwardk : oh, like an applicative version of Scheme `let' ?
08:09:27 <edwardk> ski: basically
08:09:50 <roconnor> @type let t (Cont p) = Cont (\h g -> (g . p)) in t
08:09:51 <lambdabot> forall a t b a1. Cont a t -> Cont ((a -> b) -> (t -> a) -> b) a1
08:10:11 <roconnor> er
08:10:18 <roconnor> @type let t p = Cont (\h g -> (g . p)) in t
08:10:19 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => f a -> Cont ((a -> b) -> f b) a1
08:10:37 <MissPiggy> i know you can't do untyped lambda calculus as the function space because of self applications
08:10:43 <roconnor> @type let t p = \(Cont h) g -> Cont (g . p)) in t
08:10:44 <lambdabot> parse error on input `)'
08:10:54 <roconnor> @type let t p = \(Cont h) g -> Cont (g . p) in t
08:10:56 <lambdabot> forall a r a1 t t1. ((a -> r) -> a1) -> Cont t t1 -> (a1 -> r) -> Cont r a
08:11:02 <edwardk> ski: handy because it lets you avoid some of the 'positional bias' when you're building up data types with applicatives. Foo <$> bar <*> baz -- works well, but when you have the args in the wrong order, it is a pain ;)
08:11:13 <MissPiggy> but that's a different thing
08:11:26 <roconnor> @type let t p = \(Cont h) -> Cont (\g ->(g . p)) in t
08:11:28 <lambdabot>     Occurs check: cannot construct the infinite type: r = f r
08:11:28 <lambdabot>       Expected type: r
08:11:28 <lambdabot>       Inferred type: f r
08:11:39 <roconnor> @type let t p = \(Cont h) -> Cont (\g ->h (g . p)) in t
08:11:41 <lambdabot> forall t a r. (t -> a) -> Cont r t -> Cont r a
08:11:46 <roconnor> yay
08:11:54 <ski> `fmap' ?
08:12:01 <roconnor> no wonder it wasn't lookin right
08:12:02 <roconnor> ah yest
08:12:12 <roconnor> @src fmap Cont
08:12:12 <lambdabot> Source not found. You type like i drive.
08:12:22 <ski> @src Cont fmap
08:12:22 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
08:13:12 <roconnor> So obvious now that I look back
08:13:20 <ski> edwardk : itym in the wrong order for preferred reading ..
08:14:41 <edwardk> ski: well, if you didn't define the structure so that you could build it up with applicative side-effects in the right order, then it can be somewhat painful to use <$> and <*>. you need to build a lambda to shuffle everything around anyways
08:14:55 * ski . o O ( `(where-a (test x y (foo z)) (x foo) (y (bar baz quux)) (z quaffle))' ? )
08:21:23 <roconnor> @type (\f (p:forall k. Cont Bool k -> k) -> p f
08:21:25 <lambdabot> parse error (possibly incorrect indentation)
08:21:30 <roconnor> @type (\f (p:forall k. Cont Bool k -> k) -> p f)
08:21:31 <lambdabot>     Illegal view pattern:  (p : forall k . Cont Bool k -> k)
08:21:32 <lambdabot>     Use -XViewPatterns to enable view patterns
08:21:32 <lambdabot> Not in scope: `forall'
08:22:44 <ski> @type \f (p :: forall k. Cont Bool k -> k) -> p f
08:22:45 <lambdabot> forall k. Cont Bool k -> (forall k1. Cont Bool k1 -> k1) -> k
08:23:56 <roconnor> @type (\f (p:forall k. Cont k (Cont Bool k) ) -> runCont p f)
08:23:57 <lambdabot> Parse error in pattern
08:24:04 <roconnor> @type (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f)
08:24:05 <lambdabot> forall r. (Cont Bool r -> r) -> (forall k. Cont k (Cont Bool k)) -> r
08:25:17 <ski> @type \f (p :: forall o. ContT o (Cont Bool) o) -> p `runContT` f
08:25:18 <lambdabot> forall r. (r -> Cont Bool r) -> (forall o. ContT o (Cont Bool) o) -> Cont Bool r
08:31:54 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in (\q :: Cont Bool (forall k. Cont k (Cont Bool k)) f -> f (fmap (m f) q)
08:31:55 <lambdabot> parse error on input `Bool'
08:32:11 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in \(q :: Cont Bool (forall k. Cont k (Cont Bool k)) f -> f (fmap (m f) q)
08:32:13 <lambdabot> parse error (possibly incorrect indentation)
08:32:15 <Trollinator> Hi, is it possible to get a compiler warning for stuff like "maximum []"?
08:32:30 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in \(q :: Cont Bool (forall k. Cont k (Cont Bool k))) f -> f (fmap (m f) q)
08:32:32 <lambdabot> forall r. Cont Bool (forall k. Cont k (Cont Bool k)) -> (Cont Bool r -> r) -> r
08:32:49 <byorgey> Trollinator: unfortunately, no, because maximum has a bogus type
08:33:07 <byorgey> Trollinator: something like hlint might catch it for you though (?)
08:33:09 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in \(q :: Cont Bool (forall k. Cont k (Cont Bool k))) f -> f (fmap (m f) q) :: Cont Bool (forall k. Cont k (Cont Bool k)) -> forall r. (Cont Bool r -> r) -> r
08:33:10 <lambdabot>     Cannot match a monotype with `Cont
08:33:10 <lambdabot>                                     Bool (forall k. Cont k (Cont Bool k))
08:33:10 <lambdabot>                                   -> forall r. (Cont Bool r -> r) -> r'
08:33:25 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in (\(q :: Cont Bool (forall k. Cont k (Cont Bool k))) f -> f (fmap (m f) q)) :: Cont Bool (forall k. Cont k (Cont Bool k)) -> forall r. (Cont Bool r -> r) -> r
08:33:27 <lambdabot> forall r. Cont Bool (forall k. Cont k (Cont Bool k)) -> (Cont Bool r -> r) -> r
08:33:35 <byorgey> Trollinator: or better yet, catch
08:33:38 <byorgey> @where catch
08:33:39 <lambdabot> http://community.haskell.org/~ndm/catch/
08:33:45 <FliPPeh> My brain hurts
08:33:51 <ski> @type let destructList nil cons = maybe nil (uncurry cons) . (foldr (\a0 -> Just . maybe (a0,[]) (\(a1,as) -> (a0,a1:as))) Nothing) in destructList
08:33:53 <lambdabot> forall c a. c -> (a -> [a] -> c) -> [a] -> c
08:34:01 <ski> @type let destructList nil cons as = foldr (\a0 m -> \n j -> m (j a0 []) (\a1 as -> j a0 (a1:as))) (\n j -> n) as nil cons in destructList
08:34:02 <lambdabot> forall t a. t -> (a -> [a] -> t) -> [a] -> t
08:34:13 <ski> @type let destructList nil cons as = foldr (\a0 m n j -> m (j a0 []) ((j a0 .) . (:))) const as nil cons in destructList
08:34:14 <lambdabot> forall b a. b -> (a -> [a] -> b) -> [a] -> b
08:34:20 <ski> @type let destructList nil cons as = foldr (\a0 m n j -> liftM2 m ($ []) ((. (:)) . (.)) (j a0)) const as nil cons in destructList
08:34:22 <lambdabot> forall b a. b -> (a -> [a] -> b) -> [a] -> b
08:34:27 <Trollinator> byorgey: you mean it should be something like Ord a => [a]->Maybe a?
08:34:36 <byorgey> indeed.
08:34:42 <ski> benmachine : 'ow 'bout any o'those ?
08:34:47 <Trollinator> makes sense.
08:34:48 <byorgey> or like  Ord a => NonEmptyList a -> a
08:34:52 <byorgey> if we had a NonEmptyList type
08:34:59 <Trollinator> thanks for the catch thing.
08:35:22 <ski> or `Ord a => [a] -Partial-> a'
08:35:54 <Trollinator> would that be possible in haskell without uglyness? the non-empty list type that is.
08:35:56 <byorgey> ski: that would be a correct, but unhelpful type =)
08:36:06 <byorgey> Trollinator: sure, it's quite possible
08:36:19 <byorgey> data NonEmptyList a = Single a | Cons a (NonEmptyList a)
08:36:21 <benmachine> ski: brainmelt
08:36:37 <Trollinator> oh, right
08:36:45 <byorgey> Trollinator: I think there is probably already a library on hackage with this type
08:36:55 <ski> there is an adjunction translating between `a -Partial-> b' and `a -Total-> Maybe b'
08:37:22 <ski> benmachine : all those versions are basically the same .. and more importantly, only calls `foldr' once
08:37:38 <Trollinator> hm, are those different type constructors for functions?
08:37:50 <benmachine> ski: basically the same as each other, basically the same as mine?
08:37:59 <Trollinator> i have never seen -Partial-> or -Total->
08:37:59 <ski> benmachine : the latter three are just CPS versions of the former (the two latter being more pointless ones)
08:38:09 <ski> benmachine : basically the same as each other
08:38:54 <ski> benmachine : the first, and possibly the next one, shouldn't be that hard to get, i think
08:39:20 <ski> Trollinator : that was pseudo-Haskell for total and partial functions
08:39:22 <benmachine> what's the point of the maybe machinery in the first?
08:39:41 <ski> (partial in the sense of possibly giving pattern-match failure, rather than possibly not terminating)
08:40:33 <Trollinator> Oh, so you can't actually do that, right?
08:40:52 <ski> benmachine : either we haven't seen an element yet (`Nothing'), or we've seen an element `a1', and the tail `as' after it (`Just (a1,as)')
08:40:57 <Trollinator> i've only ever seen stuff like that in ATS.
08:41:33 <benmachine> ski: but we only see Nothing once, and in that case we replace it with (a0, []) - why not just use (a0, []) as your accumulator in the first place?
08:41:33 <roconnor> @type let m = (\f (p::forall k. Cont k (Cont Bool k) ) -> runCont p f) in \(q :: Cont Bool (forall k. Cont k (Cont Bool k))) -> Cont (\f -> f (fmap (m f) q))
08:41:35 <lambdabot> forall r. Cont Bool (forall k. Cont k (Cont Bool k)) -> Cont r (Cont Bool r)
08:42:54 <ski> benmachine : so we initialize with `Nothing' at the end, and whenever we see an element `a0' (going back up), we either set to `Just (a0,[])' (in case this was the first time we saw an element), or to `Just (a0,a1:as)' (in case we were at `Just (a1:as)' before)
08:43:22 <benmachine> hmm
08:43:32 <ski> benmachine : well, i have to get a hold of the initial `a0', first
08:44:00 <ski> i suppose one could try `foldr1' or something similar, but then we have to handle the empty case in some other way
08:44:06 <benmachine> what was wrong with my version? :P
08:44:33 * ski tries to find it again in the backlog
08:44:40 <benmachine> spi' f z xs = fst (wpi g (z, []) xs) where g x (_, xs) = (f x xs, x:xs)
08:44:43 <benmachine> ski: got it here
08:44:55 <ski> `wpi' being `foldr' ?
08:44:56 <benmachine> (with spi = destructList and wpi = foldr because of the weird way I think)
08:45:19 <benmachine> you can make g a lambda if that pleases you better
08:45:37 <ski> well, `spi' calls `g', which calls `spi' again .. and `spi' calls `foldr'
08:45:47 <benmachine> eh?
08:45:51 <ski> so it appears to me that `foldr' will be called multiple times, in general
08:46:05 <ski> er, hm
08:46:11 * ski maybe read it wrongly ..
08:46:43 <ski> ah, now i see why i misinterpreted it
08:46:44 <benmachine> destructList f z xs = fst (foldr g (z, []) xs) where g x (_, xs) = (f x xs, x:xs) -- just so we can only hold one set of names in our heads at once
08:46:45 <ski> <benmachine> @tell Berengal destructList f z xs = fst (foldr g (z, []) xs) where g x (_, xs) = (f x xs, x:xs) -- is this neater?
08:47:08 <ski> for some reason, i skimmed the `destructList' and thought `f' and 'g' were mutually recursive
08:47:13 * ski is sorry
08:47:16 <benmachine> oh right
08:47:40 * ski tries actually *reading* what benmachine wrote ..
08:47:44 <benmachine> :P
08:48:41 * ski tries CPS-ing that
08:49:23 <benmachine> I've not yet got the hang of continuations
08:49:34 <benmachine> I kind of sort of understand what they do
08:49:38 <benmachine> but not when they are appropriate
08:49:47 <copumpkin> when you need MOAR POWER
08:50:18 <og01> Hope you dont mind if i ask #xmonad is a bit quiet at the moment, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22955#a22955 I've got a problem with this code, inparticular on line 6 and/or 10.  I want it to display <-> if it matches the string "Magnifier (off)", <+> if it matches "Magnifier" and "<->" if it matches nothing at all. how can i do this? (sorry im no good at funcitonal language, so explainations will have to be simple!)
08:51:07 <ski> @type let destructList f z xs = foldr g (\k -> k z []) xs const where g x p k = p $ \_ xs -> k (f x xs) (x:xs) in destructList
08:51:09 <lambdabot> forall a b. (a -> [a] -> b) -> b -> [a] -> b
08:51:29 <benmachine> neat
08:52:27 <benmachine> oh, basically you are representing tuples as their deconstruction?
08:52:28 <ski> (CPS is nice to simulate unboxed tuples/records and cotuples/variants)
08:52:59 * benmachine doesn't know what a cotuple or a variant is
08:53:05 <ski> the hope is that it'll be more efficient to not reconstruct intermediate structures all the time
08:53:25 <ski> `Either a b' is a variant type (more or less)
08:53:28 <copumpkin> if a tuple is a product, a cotuple might be a coproduct?
08:53:34 <copumpkin> and so Either, ish
08:53:39 <benmachine> ish?
08:53:46 <copumpkin> well, ignoring bottoms and evil
08:53:49 <benmachine> oh
08:53:50 <benmachine> yes
08:53:54 <benmachine> ignoring those
08:54:02 <ski> by "cotuple" i mean a variant type where the variants are ordered positionally, instead of referred to by name
08:54:05 <benmachine> (Either is a sum, right?)
08:54:16 <copumpkin> ah, guess I was wrong :)
08:54:36 <ski> tuple : record :: cotuple : variant
08:54:46 <int-e> ski: oh, so syntactically, perhaps <1,,>, <,True,>, <,,()> ?
08:54:52 <ski> (yell if you've got a better name)
08:55:04 * benmachine was happy when he worked out that tuples distributed over Eithers
08:55:04 <copumpkin> variant as in what ocaml has?
08:55:14 <nus> og01, were lines 6,7 added by you?
08:55:14 <ski> int-e : something along those lines, yes
08:55:38 * ski has used `(1||)' when playing around with the idea
08:55:39 <og01> nus: yeah...
08:55:53 <og01> nus: most of what im doing is complete guess work...
08:56:02 <ski> copumpkin : variant as in the "constructors" not really being curried
08:56:13 <ski> (since then you get an algebraic type, rather than a variant type)
08:56:23 <copumpkin> hm
08:56:50 <copumpkin> as in I could write x :: Bool `Or` () and have x = True or x = ()?
08:56:57 <copumpkin> and both would typecheck
08:57:08 <int-e> ski: ah I should have used brackets [,]. <,> are products. and of course that makes no sense at all as a syntactic extension to haskell
08:57:22 <ski> copumpkin : now you seem to be thinking of union types ..
08:57:23 <int-e> ski: while using | might work
08:57:47 <copumpkin> ski: okay, I guess I am :) when you said variant I thought you meant polymorphic variants as in ocaml
08:57:48 <int-e> > (1||) -- that's a slice though. ;-)
08:57:49 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
08:57:50 <lambdabot>    arising from the literal `1'...
08:57:52 <int-e> section
08:57:55 <copumpkin> and that's what I thought those gave you
08:57:58 <ski> > [ False | True ]
08:58:00 <lambdabot>   [False]
08:58:28 <ski> int-e : well, how about `(1 | ^ | ^)' (or substitute `^' with some better symbol ..)
08:58:59 <nus> og01, well, you better learn the basic syntax before rushing to whack the code.
08:59:12 <ski> copumpkin : the polymorphic variants in O'Caml are just lightweight variant types with row polymorphism (more or less)
08:59:19 <copumpkin> ah
08:59:21 <int-e> ski: a space would be fine. (1 | | )
08:59:25 <FliPPeh> This is... strange
08:59:32 <FliPPeh> Every website traffic just blocked
08:59:36 <FliPPeh> But IRC kept running
08:59:44 <int-e> dns hickup?
08:59:50 <FliPPeh> Probably
09:00:55 * ski has some nice ideas regarding cotuples in store somewhere, that he'd like to try out, some time
09:01:00 <gwern> do dotted-quad addresses still work on port 80?
09:01:15 <copumpkin> gwern: ?
09:01:37 <FliPPeh> I didn't have enough time to try it, the problem has already solved itself :/
09:01:40 <gwern> copumpkin: as in, 'firefox 66.249.90.104' rather than 'firefox http://www.google.com'
09:01:59 <copumpkin> I think it'll still assume port 80, yeah
09:02:07 <copumpkin> you could put the http:// in there to remind it
09:02:09 <NeoMojo> you'd still need to put the protocol prefix at the beginning, gwern
09:02:15 <gwern> NeoMojo: not in firefox
09:02:19 <NeoMojo> oh
09:02:22 <NeoMojo> well ok then
09:02:52 <NeoMojo> I've just tested it and can confirm that firefox still takes IP addresses
09:03:01 <NeoMojo> in IP4 format
09:03:04 * ski notes Firefox supports gopher ..
09:03:20 <FliPPeh> @hoogle megahal
09:03:20 <lambdabot> No results found
09:03:25 <FliPPeh> @hackage hal
09:03:26 <lambdabot> http://hackage.haskell.org/package/hal
09:03:38 <FliPPeh> :/
09:03:42 <medfly> @hackage lulzitacceptseverything
09:03:42 <lambdabot> http://hackage.haskell.org/package/lulzitacceptseverything
09:03:45 <medfly> :]
09:03:52 <FliPPeh> Doesn't seem like anyone wrote a megahal implementation in haskell yet..
09:04:28 <ski> (istr a bot named "MegaMonad" in here .. not sure if that was in Haskell or not)
09:05:49 * fasta notes that Firefox renders a lot of webpages worse than browsers built on WebKit (or Opera). 
09:06:41 <ski> (re CPS above .. in some cases, using unboxed cotuples/variants would make a function semi-tail-recursive)
09:12:08 <zygoloid> medfly: for a second i thought someone had created a package with that name. i am disappoint
09:12:43 <medfly> hehe
09:14:32 <ksf> does calling c++ still require c stubs?
09:18:33 <ksf> argh no. I won't write bindings.
09:18:36 <ksf> not without c2hs
09:18:49 <ski> hm .. it appears to me that it might be handy with unboxed variants if a `case' expression would return the scrutinee if it doesn't match any of the branches
09:19:26 <ksf> we just need a proper syntax-define
09:19:55 <ski> (that's probably heresy, though, so one would probably have to add some kind of extra annotation to do what i wanted ..)
09:20:37 <ski> (ksf : itym `define-syntax')
09:23:44 <edwardk> ski: actually case in core does just that
09:24:03 <amxx> (Question HDBC) => http://nopaste.narf.at/d67b8cd4f    why?
09:24:25 <MissPiggy> hehe amxx
09:24:32 <MissPiggy> I like the way you phrased that
09:24:36 <copumpkin> amxx: Question is a typeclass?
09:24:50 <edwardk> ski: | Case  (Expr b) b Type [Alt b] -- b is an additional binding for the scrutinee
09:25:03 <edwardk> in http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
09:25:06 <MissPiggy> hi edwardk
09:25:20 <ski> edwardk : i meant more like `case Left x of Right y -> ..y..' returning `Left x'
09:25:26 <ski> (crazy, yes i know :)
09:25:46 <edwardk> case (reverse xs) of y\n    Nil       -> Nil\n   Cons x xs -> append y y
09:25:57 <edwardk> ski: ah
09:25:59 <copumpkin> No instance for (Answer Copumpkin (Question HDBC)) arising from a use of `(Question HDBC)`
09:26:24 <amxx> either I broke something, or it was the hdbc update I just installed
09:26:38 <ski> more specifically, i was looking for a way to avoid generating names `g_0' in `case ... of Left g_0 -> Left g_0; Right x -> ..x..'
09:27:24 <edwardk> ski: either Left (...) =)
09:27:48 <ski> edwardk : well, it should really be `Left#' and not `Left' :)
09:28:27 <edwardk> ski: i was afk when the discussion started, so i'm not entirely sure of the full context
09:28:30 <ski> (and going a detour around `either#' would defeat the purpose, i think, unless it gets unfolded)
09:29:23 <ski> edwardk : oh, i was just CPS-ifying benmachine "`listCase' function in terms of `foldr", and then rambling on about unboxed variants a bit :)
09:29:51 <edwardk> heya MissPiggy
09:29:54 <mapreduce> As I recall, the Scheme Papers invented the term 'closure' as the implementation technique for being able to read free variables.
09:30:02 <ski> (or, rather s/rambling on/mostly thinking/)
09:30:31 * ski is probably not being very coherent, atm
09:30:33 <mapreduce> Functional languages existed before that; were they dynamically scoped, or were lexical closures in Scheme not an invention but a repetition?
09:31:07 <edwardk> mapreduce: closures were first implemented in scheme
09:31:18 <mapreduce> So how did, say, ML, do things?
09:32:00 <gwern> edwardk: surely closures were first in algol?
09:32:08 <gwern> it seems to've done everything first...
09:32:12 <MissPiggy> edwardk I tried to make an algebra heierachy in coq :( to match with my haskell code but it's very hard
09:32:29 <MissPiggy> it's like all th e different ways have pros and cons,... there's isn't a way which is all perfect
09:33:16 <edwardk> ML was late 70s. scheme beat it by a few years in 75, based on an idea of Landin's from the 60s.
09:33:20 <copumpkin> the best way I could come up with was by wrapping everything in a Tagged type and using reify to achieve different "named" instances
09:33:31 <copumpkin> but wrapping everything in Tagged felt icky
09:33:32 <ccasin> mapreduce: Scheme predates ML.  Or at least the classic scheme papers do
09:33:42 <ski> edwardk : in case you wonder what i was thinking on, you could check <http://paste.lisp.org/display/81249> "parsimonious `filter', using `multi'ple alternative continuations" and <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301> "Multi-return Function Call example", and also the Shiver's paper linked to from the latter
09:34:27 <mapreduce> ccasin: I see.  So then I was talking garbage when I said C predates closures.  Thanks.
09:35:37 <copumpkin> C isn't as old as many people think it is
09:35:52 <ccasin> mapreduce: well, I'm not so sure.  Wikipedia puts C at 1972
09:36:05 <pikhq> ccasin: Closures are older.
09:36:12 <edwardk> ski: i'm familiar with shiver's paper but not with this version of the 'multi' combinator.
09:37:32 <ski> edwardk : Riastradh invented a `multi' construction in Scheme, closely modelled after the SML one in the paper. i modified it slightly for greater (imo) convenience
09:37:54 <edwardk> ski: do you have a link to a syntax-rule definition or other definition for it?
09:38:20 <mapreduce> ccasin: Hmm.  Wikipedia puts the lambda papers as starting 1975, which makes C predate closures by at least 3 years.
09:38:29 <edwardk> mapreduce: the idea came from 64
09:38:39 <edwardk> mapreduce: the scheme papers were 11 years later
09:38:54 <ccasin> mapreduce: but scheme wasn't the first use of closures, is pikhq's point
09:38:54 <pikhq> mapreduce: ... Closures are older than Scheme.
09:39:19 <edwardk> gwern: not that i can tell
09:39:30 <ski> edwardk: it is not implemented .. possibly implementing it properly means to change the compiler (maybe using `call-with-current-continuation' could be enough, not sure)
09:39:36 <ccasin> Though I confess I've never read whatever the earlier references are, which is embarrassing
09:39:42 <ski> edwardk : i can explain its semantics, though
09:39:51 <ski> (and the syntax as well, of course)
09:39:55 <edwardk> pikhq: i'll happily be demonstrated to be wrong, what prior implementations are you thinking of?
09:39:58 <pikhq> ccasin: Scheme's the first notable *use* of them as an implementation technique.
09:40:58 <mapreduce> edwardk: Ok, where did it appear in 64?
09:41:17 <pikhq> mapreduce: /The mechanical evaluation of expressions/, by P.J. Landin.
09:41:45 <edwardk> mapreduce: The mechanical evaluation of expressions
09:41:48 <edwardk> yeah
09:42:13 <pikhq> Also, this language used closures: http://en.wikipedia.org/wiki/ISWIM
09:42:39 <pikhq> (not implemented, but hey.)p
09:42:52 <mapreduce> Thank you, very interesting.
09:42:52 <copumpkin> ISWIM, USWIM, HESWIM
09:43:08 <NeoMojo> LISP uses closures, it's been around since the 50s
09:43:33 <mapreduce> NeoMojo: Lisp used dynamic scope until Scheme (elisp still does).
09:43:44 <mapreduce> So that doesn't count as closures, as I understand it.
09:43:49 <edwardk> pikhq: the main reason why scheme gets credit for them is that it is the first place they were fully integrated into a language that was actually implemented ;)
09:43:56 <pikhq> edwardk: Yes.
09:44:18 <copumpkin> ugh dyanmic scope
09:44:20 <pikhq> edwardk: Still, closures are older than Scheme. :)
09:44:29 <edwardk> NeoMojo: lisp uses closures today
09:44:44 <ski> Emacs Lisp doesn't
09:44:54 * ski dunno about Auto-Lisp
09:44:58 <pikhq> Elisp is freaking weird.
09:45:10 <pikhq> copumpkin: So very rarely sane...
09:45:25 <MissPiggy> so closures are old news
09:45:28 <copumpkin> you know what's awesome? the difference between proc and lambda in ruby
09:45:37 <pikhq> MissPiggy: Quite.
09:45:52 <edwardk> ski: i meant the emphasis on that to be 'today' as in as opposed to before the scheme papers. not to imply that every lisp is lexically scoped with closures, etc.
09:46:09 <Cale> ISWIM never used closures because ISWIM was never implemented
09:46:43 <Cale> ISWIM had first class functions though, perhaps that's what you meant to say ;)
09:47:06 * ddarius implements ISWIM with paper and pencil.
09:48:02 <amxx> FWIW: downgrading to HDBC-postgresql-2.2.0.0 solves problems.
09:48:25 <mapreduce> Not a single autocad user I've met uses autolisp, which seems a shame.
09:49:10 <zygoloid> copumpkin: what's the difference between proc and lambda in ruby?
09:49:33 <copumpkin> zygoloid: the behavior of return
09:49:41 <pikhq> Cale: Fine, fine. It was discussed with closures as the implemenation technique to use, should it ever be implemented.
09:50:24 <zygoloid> copumpkin: in the lambda case, i'm guessing it returns from the proc in which the lambda is defined?
09:50:39 <copumpkin> zygoloid: in which it was used
09:50:49 <copumpkin> can't remember which is which actually
09:50:52 <copumpkin> haven't used it in a long time
09:51:01 <zygoloid> sounds a bit wtf
09:51:05 <copumpkin> it is, totally
09:51:21 <Cale> pikhq: Really?
09:51:23 <zygoloid> but it's the same in Tcl, so it's obviously reasonable
09:51:29 <pikhq> Cale: Yes.
09:51:46 <copumpkin> so calling def g(); f(args); more stuff; end might never get to more stuff, if f is the dumb one of lambda/proc
09:51:54 <copumpkin> (with no exceptions)
09:51:56 <pikhq> zygoloid: Actually, not true in Tcl...
09:52:14 <ski> edwardk : roughly BNF for the SML `multi' : `<expr> --> ... | multi <expr> <cont>*',`<cont> -> #<n> | fn <pat> => <expr>'
09:52:31 <pikhq> zygoloid: What happens in Tcl is that procs can execute something in the caller's scope.
09:52:32 <zygoloid> pikhq: 'return' raises an exception in Tcl. if you pass a block of code (as a string) which contains 'return' and execute it, the caller bails out
09:52:38 <pikhq> Oh.
09:52:53 <pikhq> Right, return has the odd exception stuff.
09:53:04 * Cale looks up Landin's original paper to see if it mentions closures anywhere
09:53:14 * copumpkin wants apertures
09:53:17 <zygoloid> but yeah, uplevel exceptions propogate back to the invoker of uplevel
09:53:30 <pikhq> Which is weird, since the times you want that behavior is with control structures *which already are in the caller's scope*...
09:53:43 <Cale> It doesn't seem to
09:53:50 <mapreduce> Cale: Well, exceptions for return only crop up in languages that contain return.
09:53:55 <twink> http://web.archive.org/web/20070417160748/http://www.cs.utah.edu/~wilson/compilers/old/papers/p157-landin.pdf
09:54:06 <mapreduce> So if ISWIM didn't have return, break, continue, etc., it wouldn't even need thinking about.
09:54:15 <monochrom> Landin's paper is full of stacks that store environments.
09:54:32 <mapreduce> Is there a free place to get it from?
09:54:55 <twink> See the URL I just pasted.
09:55:24 <mapreduce> Thanks.
09:56:01 <MaciejP> Is it possible to create a new Haskell file at comple time via TH?
09:56:10 * Cale thinks that monochrom is probably joking :)
09:56:23 <Cale> It talks about functions and substitution
09:57:30 <Cale> Closures are an inappropriate thing to talk about when defining a language.
09:57:52 <Cale> mapreduce: I'm not sure what discussion you're referring to with regard to return.
09:58:18 <Cale> oh, not the one that I was in :)
09:58:28 <monochrom> Oh, the 700-languages paper. I was thinking the SECD paper.
09:58:55 <mapreduce> Cale: Right, because they're an implementation technique.
09:59:21 <mapreduce> Cale: Is there another reasonable implementation technique for lexically-scoped lambdas that can access free variables, besides closures?
09:59:44 <Cale> Sure, graph reduction.
10:00:06 <pikhq> Yeah, graph reduction gets you the free variable behavior for free.
10:00:18 <lispy> hence the name, right? ;)
10:00:35 <lispy> "free variables" for "free", it's so easy!
10:00:47 <monochrom> free as in variable
10:00:47 <MissPiggy> how do you pimlement graph reduction ?
10:00:48 <MissPiggy> in haskell
10:01:05 <twink> FP languages are pretty well-covered with implementors etc. Logic languages are probably where the scope for making up new languages and having them be good enough relative to the field to be useful is.
10:01:07 <monochrom> use STRef or zipper
10:01:18 * hackagebot upload: HCodecs 0.2 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files. (GeorgeGiorgidze)
10:01:54 <mapreduce> Cale: I don't quite get it, but that's ok.  Do you happen to know if this is covered in TAPL?
10:02:03 * monochrom misread Giorgidze as Giorgidize
10:02:29 <roconnor> @src fmap Cont
10:02:29 <lambdabot> Source not found. Maybe you made a typo?
10:02:38 <roconnor> @src Cont fmap
10:02:38 <lambdabot> fmap f m = Cont $ \c -> runCont m (c . f)
10:02:49 <twink> MissPiggy: The graph reduction isn't usually very complicated. I think mostly it involved expanding things out when there is a recursive definition of sorts and CSE-like things when let/etc. ties the knot.
10:03:07 <MissPiggy> twink it is hard though :(
10:03:22 <MissPiggy> other tricky thing is I need to turn expression into a graph and have a way to read them back
10:03:55 <twink> MissPiggy: Basically there is a "tree reduction" sort of thing you do with pencil and paper. Graph reduction just does something like CSE so that let-bound vars don't get copied/duplicated/expanded out multiple times.
10:04:27 * ski misread "Giorgidze" and "Giorgidze" as "Grzegorczyk"
10:04:46 <twink> Cale/monochrom/roconnor: Please step in if I'm getting things wrong.
10:04:52 <twink> ski: You too.
10:04:57 <Cale> twink: nah, that's reasonable :)
10:05:15 <monochrom> It's just too much hand-holding.
10:05:40 <Cale> mapreduce: You could imagine a language implementation which maintains values at runtime as abstract syntax trees, yeah?
10:05:55 <Cale> mapreduce: and just transforms those abstract syntax trees repreatedly to do evaluation.
10:06:01 <Cale> repeatedly*
10:06:42 * ski wonders who this twink might be, that knows this magic incantation
10:07:57 <mapreduce> Cale: I see, but my head's interspersing the environment model with that.
10:08:25 <mapreduce> I'm struggling to see how that fits with chained environments.  Perhaps it doesn't.
10:08:29 <Cale> mapreduce: There's no environment necessarily. Just a big graph representing the whole program, and it gets rewritten over and over.
10:08:35 <mapreduce> I see.
10:08:40 <mapreduce> Thank you.
10:08:57 <MissPiggy> the sharing is done by:  ======|>----
10:09:01 <MissPiggy> it takes two inputs and one output
10:09:06 <MissPiggy> (or two outputs and one input)
10:09:32 <twink> MissPiggy: You know PCF?
10:09:35 <MissPiggy> so you can share parts of expressions (but with a small part chanegd)
10:09:47 <MissPiggy> I know of it
10:09:54 <twink> Some mini-language with let expressions is needed here.
10:10:15 <twink> MissPiggy: Okay, how about a dull lambdacalc with let exprs?
10:10:25 <MissPiggy> I need let for readback
10:10:26 * ski hands twink `M ::= x | M M | \x. M | let x = M in M'
10:10:41 * Cale likes a language with lambda, let and case as a simple core. :)
10:11:05 <Cale> let expressions represent your heap, case expressions drive evaluation and pattern matching
10:12:06 <Cale> and when you apply a function whose parameter occurs more than once in its body, you get a let expression to express the sharing
10:12:14 <twink> bathroom problems, someone please pick up from here (or basically get started)
10:12:21 <ski> E0[let x = M in E1[x]] --> E0[let x = M in E1[M]]
10:12:32 <ski> (Felleisen contexts ftw !)
10:13:52 <MissPiggy> what I need is something that displays the graphs I guess
10:13:59 <MissPiggy> then I could worry about read-back later
10:17:31 <twink> MissPiggy: Give every variable a unique name, then float all the let exprs to the top level.
10:19:25 * hackagebot upload: mps 2010.2.25 - simply oo (JinjingWang)
10:19:37 <twink> MissPiggy: The graphs are all basically like trees except some of the branches get tied together.
10:19:59 <MissPiggy> okay
10:20:13 <twink> MissPiggy: They're tied together whenever they refer to the same let-bound variable.
10:20:16 <MissPiggy> that makes it difficult in haskell
10:20:50 <twink> let x = 1 in x + x gives you a node for (+) with the two operands tied together.
10:21:20 <MissPiggy> as far as haskell knows, a graph is no different than an infinite tree
10:21:26 * hackagebot upload: hack-contrib 2010.2.25 - Hack contrib (JinjingWang)
10:22:08 <twink> MissPiggy: Fortran pointers. Use array indices as handles/whatever to "simulate" pointers.
10:22:43 <ezyang> Does this typeclass make sense? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22958#a22958
10:23:28 <twink> MissPiggy: In Haskell you'd represent let x = 1 in x + x as Op Plus (Ptr 7654321) (Ptr 7654321) where Ptr 765321 is a heap cell initialized with the constant 1.
10:24:08 <twink> MissPiggy: Or, rather, heap ! 7645321 is a heap cell initialized with the constant 1.
10:25:47 <twink> MissPiggy: data G = Op Op | Ptr Int | ...
10:25:56 <ezyang> Basically, I want to write code that is either using mutation or doing things purely
10:26:00 <twink> MissPiggy: data Op = Plus | Minus | ...
10:26:02 <MissPiggy> oh I can't do this
10:26:02 <ezyang> so it might be in ST
10:26:30 * hackagebot upload: bamboo 2010.2.25 - A blog engine on Hack (JinjingWang)
10:27:52 <twink> MissPiggy: none of this is helping?
10:28:01 <MissPiggy> this is too hard for me
10:28:32 <MissPiggy> I understand what you are saying but that's not enough
10:28:44 <MissPiggy> I can't just go from understanding it to have written it
10:29:00 <twink> MissPiggy: well, no, all the complexity is now shunted into building the initial heap
10:30:03 <Runar> Is there documentation on getting cabal+hackage working through a HTTP proxy that requires authentication?
10:30:39 <edwardk> export http_proxy=http://user:pass@proxy/ ; cabal install ...
10:32:07 <MissPiggy> twink ugh I did all the easy stuff but now I can't do anything
10:32:23 <Runar> Rockin. Thanks, edwardk.
10:33:12 <edwardk> MissPiggy: relax. you'll get there.
10:33:39 <ski> edwardk : did you want explanation of my `multi' ?
10:33:40 <edwardk> MissPiggy: what have you got so far?
10:33:53 <edwardk> ski: yes, sorry, i got pulled away when we were talking earlier.
10:35:17 <ski> edwardk : in Shivers' SML `multi <expr> <cont>*', the `<cont>'s can be either `#<n>' or `fn <pat> => <expr>'
10:35:29 * MissPiggy sighs and doesn't know hat to do
10:35:42 <edwardk> ski: it looks reasonably straightforward though. same as shivers' version with numerical multiple returns
10:36:48 <ski> i don't like referring to the continuation in a semi-tail-call by numbering, when the `<cont>' clauses are referred to by position, so my first change is to have `(multi (<var>*) <expr> <cont>*)' so that the continuations are matched by position (and thus named)
10:38:24 <edwardk> ski: of course all of this makes a terrible muddle when it comes to optimizing this away ;)
10:38:39 <ski> secondly, i changed `fn <pat> => <expr>' there to `(=> <pat> <expr> <cont-var>)' (i'm not sure why i did it like that, anyway, that means that i have to select only one of the continuations to use in each branch)
10:39:10 <ski> edwardk : well, the continuation variables should not be ordinary variables .. so they're still not first-class
10:39:55 <edwardk> ski: yeah. i recall the arguments against naming them from the paper
10:40:16 <edwardk> i'm still a bit skeptical that that was the right call, but i'm willing to run with it
10:40:20 <ski> in the second variant (a bit down in the lisppaste) i instead basically let a `<cont>' be either a `<cont-var>' or a `(=> <pat> <expr> <cont>*)', which solves that expressivity problem
10:41:01 <ski> edwardk : anyway, if you look at the second paste (the hpaste one), you'll see how i mapped this into "unboxed variants" in haskell
10:41:16 <edwardk> what are these unboxed variants?
10:41:28 <ski> (there's some things to be figured out there, but i think the basic idea is good)
10:42:02 <ski> edwardk : an unboxed variant (my term) is a variant type whose continuations are unboxed
10:42:22 <edwardk> ?
10:42:45 <ski> edwardk : so the continuation of `Either# a b' is probably stores as two return addresses, in two separate registers (or something like that)
10:43:35 <edwardk> ski: ah, the 'case as a record' model
10:44:09 <ski> so, in `case foo x of Left# a -> f a; Right# b -> g b', instead of calling `foo x' and waiting for it to tell whether to choose the `Left#' or the `Right#' branch, we pass it the branches directly, and it will jump to the appropriate one
10:44:35 <ski> i.e. this works like passing two continuations to `foo x', using the `multi' operation
10:44:53 <ski> to select the first continuation and pass `y' to it, you do `Left# y'
10:45:00 <edwardk> ski: yeah, your case is a record consisting of the two continuations, which are handed over to 'foo x'
10:45:28 <edwardk> ski: which has an implied contract to only use one of them
10:45:29 <ski> (or really s/first continuation/continuation named `Left#'/)
10:45:34 <c_wraith> when doing biography profiling, what are the void and inherent use categories?
10:46:03 <lispy> c_wraith: I don't know what inherent use is, but I thought void was documented in the ghc manual
10:46:06 <ski> edwardk : right (unless you use delimited continuations or similar .. for `foldr'-things)
10:46:44 <edwardk> ski: k. this actually fits with one of my toy compiler backends, so i'm following ;)
10:46:45 <lispy> c_wraith: "An object which is never used is said to be in the 	  void state for its whole 	  lifetime."
10:46:57 <c_wraith> Ah, interesting.
10:47:07 <lispy> c_wraith: http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#biography-prof
10:47:17 <edwardk> ski: from back when i used to use the variant/record duality a lot more.
10:47:41 <ski> edwardk : yeah, i was thinking you'd catch it fast :)
10:48:09 <edwardk> a variant of continuations can annihilate a record of values. (field selection) and a record of continuations can annihilate a variant of values. (case analysis)
10:48:16 <c_wraith> Strange.  This isn't showing anything in the drag state
10:49:10 <ski> edwardk : the one thing that currently bothers me in the unboxed variants version there is that i have `Right# g_1 -> Right# g_1',&c. where the `multi' one just named a continuation to reuse
10:49:47 <ski> so, either the system must recognize that it can (well, must) "eta-contract" `Right# g_1 -> Right# g_1' into not constructing a new continuation
10:50:19 <ski> or i need to have some other notation for denoting this (otherwise, no semi-tail-calls)
10:50:39 <ski> maybe one could say `foo@(Right# _) -> foo'
10:50:49 * ski is not completely satisfied with that, either ..
10:50:55 <edwardk> ski: one option is to do things like cont { case4 = ... }  -- to replace a single continuation in a record of continuations
10:51:24 <ski> edwardk : yes .. but i was thinking of a "value-oriented" way of expressing this
10:51:43 <ski> (hence, trying to avoid naming, or even mentioning, continuations at all)
10:51:45 <c_wraith> gah.  I have a haskell server that *sometimes* will fall over under load, and leak space until the load vanishes.  Sometimes it has no issues whatsoever under load.  This is amazingly hard to track anything down with
10:51:45 <jontore> Is it possible for a function to return two types of monads? Or wrap one inside another ? I
10:51:46 <edwardk> ski: yeah, but you could avoid having to plumb the sugar all the way through by just doing that
10:51:55 * hackagebot upload: bamboo-theme-blueprint 2010.2.25 - bamboo blueprint theme (JinjingWang)
10:52:05 <ezyang> Having indentation problem. Can someone take a peek? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22960#a22960
10:52:06 <ski> edwardk : not sure how you mean
10:52:15 <edwardk> which would also just let you implement this in modern-day haskell
10:52:30 <zygoloid> jontore: you probably want the latter. you can wrap one monad inside another, but it's usually more convenient to use a monad transformer
10:52:39 <gwern> > 100 * 30 * 60
10:52:40 <lambdabot>   180000
10:52:46 <gwern> > (100 * 30 * 60) / 1000
10:52:47 <lambdabot>   180.0
10:52:59 <zygoloid> jontore: what are the two monads?
10:53:02 <ski> edwardk : "implement" as in "simulate with CPS" ?
10:53:13 <mauke> ezyang: what's the error message?
10:53:18 <pastorn> how do i write 'forever p = p >> forever p' points free?
10:53:39 <medfly> @pl forever p = p >> forever p'
10:53:39 <lambdabot> forever = fix (flip (>>) . ($ p'))
10:53:40 <ezyang> " parse error (possibly incorrect indentation)"
10:53:49 <mauke> @pl forever p = p >> forever p
10:53:50 <lambdabot> forever = fix (ap (>>))
10:53:54 <gwern> > (200 * 1000) / 180
10:53:55 <lambdabot>   1111.111111111111
10:53:56 <medfly> oops.
10:53:59 <pastorn> @src ap
10:53:59 <lambdabot> ap = liftM2 id
10:54:01 <mauke> ezyang: where?
10:54:04 <pastorn> @type ap
10:54:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:54:07 <ski>   forever p = p >> forever p
10:54:16 <ezyang> hwere it's marked -# ERROR
10:54:19 <ski>   foo@(forever p) = p >> foo  -- pseudo-haskell
10:54:32 <ski>   forever p = fix $ \foo -> p >> foo
10:54:39 <gwern> hey, anyone know what the ballpark is for registering a domain name for a year?
10:54:43 <ski>   forever p = fix (p >>)
10:54:47 <gwern> 10$? 20$?
10:54:50 <ski>   forever = fix . (>>)
10:54:55 <edwardk> ski: lemme see if i can scribble out what i mean as workable code. not sure if i have time right now, but i'll try in what time i have
10:55:00 <pastorn> @type fix . (>>)
10:55:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:55:08 <pastorn> nice :)
10:55:25 <zygoloid> pastorn: it's: "fix (\forever p = p >> forever p)" = "fix (\forever p -> (>>) p (forever p))" = "fix (\forever p -> ap (>>) forever p)" = "fix (ap (>>))"
10:55:47 * ski prefers only mentioning `p' once
10:55:51 <MaciejP> How do you return 'Just s' in TH where s is a String?
10:56:00 <pastorn> fix (mainFun >>)
10:56:02 <ski> edwardk : no problem
10:56:06 <pastorn> that's what i'll use :)
10:56:39 <ski> @pl forever_p = p >> forever_p
10:56:39 <lambdabot> forever_p = fix (p >>)
10:56:40 <jontore> zygoloid, I have a function that is expected to return a Err monad but it uses a state monad I've created called Generator. I want transProgramSpec to return a Err monad http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22961#a22961
10:56:48 <mauke> ezyang: I don't see the problem :-(
10:57:05 <ezyang> mauke: :-(
10:57:15 <ezyang> I've commented out the offending bits and am slowly bisecting it
10:58:22 * ski =>> \ski -> sleep ski
10:58:50 <medfly> forever?
10:58:52 <pastorn> jontore: programsprÃ¥k?
10:59:25 <jontore> pastorn, jupp
10:59:38 <gwern> > 10 * 10 * 60
10:59:39 <lambdabot>   6000
10:59:53 <pastorn> jontore: at the top of your file: {-# LANGUAGE GeneralizedNewtypeDeriving #-}
10:59:59 * hackagebot upload: scons2dot 0.9 - Generates graphviz file of scons dependency information (LeandroPenz)
11:00:23 <pastorn> newtype LOL m a = LOL { unLOL :: StateT SomeState Err a }
11:00:36 <pastorn> deriving (Monad, MonadState SomeState, MonadTrans)
11:00:47 <pastorn> type LULZ = LOL Err
11:00:58 <pastorn> then all your functions will be in the LULZ-monad
11:01:34 <olsner> I don't trust my judgement, but that may have been quoteworthy
11:02:15 <pastorn> runLULZ s = (execStateT s . unLOL) startOfProgram
11:02:20 <pastorn> (i think...)
11:02:43 <pastorn> jontore: that's all you'll need
11:02:44 <jontore> pastorn, Ok, so then LULZ has both State and ERR
11:02:54 <mauke> but all you need is love
11:03:26 <pastorn> yes, so you can do get, set (gets, modify) and fail from a "top level" perspective (you don't have to say "lift" whenever you want to do fail)
11:03:35 <chrisdone> mauke: do you love me?
11:03:50 <monochrom> "m" is unused
11:04:00 <pastorn> monochrom: no, it isn't
11:04:05 <pastorn> m is used in type LULZ
11:04:20 <MissPiggy> newtype LOL m a = LOL { unLOL :: StateT SomeState Err a }
11:04:25 <MissPiggy> might have been a mistake for
11:04:27 <pastorn> because 'm' has to be specified to data Err a = Ok a | Bad String
11:04:27 <MissPiggy> newtype LOL m a = LOL { unLOL :: StateT SomeState m a }
11:04:30 <MissPiggy> I am guessing
11:04:34 <MissPiggy> probably a typo
11:04:58 <pastorn> MissPiggy: you can't derive monadTrans unless the 'm' is free
11:05:09 <MissPiggy> oh
11:05:18 <pastorn> that's why :)
11:05:26 <MissPiggy> weird I have no idea how that derive stuff works
11:05:52 <pastorn> MissPiggy: GeneralizedNewtypeDeriving is cool
11:06:15 <pastorn> but you can't derive MonadTrans if your stack depth is > 2
11:07:02 <pastorn> so now i'm working with a 'StateT ReaderT m' but that couldn't derive MonadTrans, so i had to just put IO in there and derive MonadIO instead
11:10:51 <edwardk> ski: what keeps you from just doing something like:
11:10:52 <edwardk> type M a = forall r. (a -> r) -> r -> r; just :: a -> M a;just a f _ = f a; nothing :: M a; nothing _ z = z; filter f lis = recur lis id lis where recur [] = nothing; recur (x:xs) | f x = recur xs (just . (x:)) nothing | otherwise = recur xs just (just [x])
11:11:12 <edwardk> ski: using the two continuations explicitly
11:11:28 <pastorn> edwardk: hpaste + linebreaks?
11:11:33 <pastorn> i heard it's AWESOME!
11:11:33 <edwardk> pastorn: =)
11:12:10 <edwardk> pastorn: hah, well, i was working that one out right here in my irc client. lemme scribble it out there. :) that might have been a bit long for an irc comment =)
11:12:21 <edwardk> @hpaste
11:12:21 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:13:43 <MissPiggy> ohd well
11:14:03 <jontore> pastorn, newtype LOL m a = LOL { unLOL :: StateT SomeState Err a } can't get this to work. Is there something I have to think about when using a newType ?
11:15:25 <pastorn> jontore: s/Err/m
11:15:36 <edwardk> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301#a22963
11:15:58 <jontore> sry, my bad. Typo newtype not newType :)
11:16:07 <edwardk> pastorn: better?
11:16:28 <monochrom> <MissPiggy> newtype LOL m a = LOL { unLOL :: StateT SomeState m a }
11:16:30 <edwardk> ski: i also think you had a bug in one of your cases
11:16:31 <monochrom> QED
11:16:39 <pastorn> edwardk: yup :)
11:16:53 <ezyang> vector won't let me unsafeFreeze its innards :-(
11:17:47 <pastorn> edwardk: that "type M a" thing actually works?
11:17:59 <edwardk> pastorn: sure
11:18:08 <pastorn> you nasty person :p
11:18:08 <edwardk> you need to turn on Rank2Types
11:18:49 <pastorn> jontore: you should also fix your state
11:19:11 <edwardk> pastorn: i have a whole library full of those ;)
11:19:19 <pastorn> jontore: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
11:19:40 * ksf doesn't get why my video card seems to treat an alpha of 0 the same as an alpha of 255
11:19:41 <ski> edwardk,pastorn : i could read it here on IRC just fine, but ok :)
11:19:59 <pastorn> ski: i couldn't
11:20:08 * pastorn has the headache that god forgat
11:20:13 <MissPiggy> monochrom: ????
11:20:25 <edwardk> IIRC, Maybe ~ Yoneda Endo
11:20:28 <monochrom> MissPiggy: <pastorn> jontore: s/Err/m
11:20:38 <MissPiggy> monochrom: pastorn told me that was not a typo
11:20:39 <monochrom> which is what you said. QED
11:20:48 <pastorn> maybe it was...
11:20:55 <monochrom> Well now pastorn confesses that it is.
11:21:01 * pastorn still has the headache that god forgot
11:21:03 <MissPiggy> and the reason is that it was essential for GENRALIZEDNEWTYPEDERIVATING
11:21:07 <monochrom> Or else a personality that lacks integrity.
11:21:27 <ski> edwardk : well, that code would be just fine, but it's still CPS .. i was wanting something more primitive
11:21:29 <pastorn> oh, right... i was wrong to begin with
11:21:44 * pastorn actually bothered to press PgUp
11:22:06 <ski> edwardk : possibly usual calls to `Left', &c. could (with some analysis) be converted to `Left#', &c.
11:22:36 <ski> edwardk : where would the bug be ?
11:23:26 <ski> @quote Yoneda
11:23:27 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
11:23:27 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
11:23:47 <ski> so there !
11:25:22 <edwardk> ski: er actually i think i'm wrong =) i need to fix _my_ bug =)
11:25:57 <edwardk> i'd misparsed the purpose of Right# ()
11:26:34 <Young-Goon> hi, i'm trying to install wxfruit, and when i want to compile wxcore i got the following error : Setup.hs: readProcess: wx-config "--libs" "--cppflags" (exit 127): failed    i suppose it's mean i didn't install wx, so i look at my packet installer (synaptic on ubuntu) and i don't know wht i must install
11:26:40 <Young-Goon> does someone know ?
11:27:06 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13301#a22965 fixed
11:27:26 <ski> edwardk : hm, right `recur xs just (just [x])' should be `recur xs just (just xs)', i think
11:27:35 <edwardk> yeah
11:27:45 <edwardk> that was the fix i just hpasted
11:28:03 <edwardk> its been a long time since i read the original paper and had forgotten the purpose of the multireturn
11:29:12 <edwardk> and the use of CPS'd Maybe rather than CPS'd Either is because it is sound in the presence of laziness not to bother passing the () to the continuation
11:29:42 <edwardk> we're in haskell after all, not ml ;)
11:29:43 <Saizan> Young-Goon: google found this http://wiki.wxwidgets.org/Installing_and_configuring_under_Ubuntu
11:29:52 <ski> *nod*, i think i was using `Either#' since i was talking about `Either' and not `Maybe' when i pasted that
11:30:27 <ski> (i.e. to argue for a general `Either#' (and more generally, user-defined unboxed variants))
11:30:38 <Young-Goon> Saizan, thx you
11:31:14 <edwardk> ski: sure. i'm just amused that the direct implementation is to use 'yet another kan extension' =)
11:31:25 <ski> anyway, i consider the use of CPS here a work-around .. i want a direct(-style) solution ! :)
11:31:51 <edwardk> ski: bah, just use Ran (Maybe [a]) instead of Maybe [a] and it happens for free ;)
11:32:29 <ski> edwardk : if i have defined `Ran (Maybe a)' and `Ran [a]', yes
11:32:44 <edwardk> ski: they are already packaged up in monad-ran ;)
11:32:45 <ski> i need to define it on every new datatype i want to use it on, right ?
11:33:02 * ski wants it for free !
11:33:03 <edwardk> sorry the type is Ran Maybe a
11:33:14 <ski> (np)
11:33:14 <bjorkintosh> can anything be typed into the hugs prompt, or must everything be imported from a file first?
11:33:23 <ski> bjorkintosh : expressions
11:33:32 <bjorkintosh> i'm (re)trying some examples from the haskell school of expression
11:33:39 <bjorkintosh> and all i'm getting are $#$# errors from hugs.
11:34:01 <Cale> bjorkintosh: declarations must go in a file
11:34:03 <bjorkintosh> something as simple as import SOEGraphics yields an error... because hugs has no clue what 'import' means. or something.
11:34:11 <ski> bjorkintosh : if you want to define operations (persistently, for the session), you probably want to use GHCi
11:34:11 <Cale> bjorkintosh: Hugs only wants expressions (things which evaluate to values)
11:34:13 <edwardk> ski: write a syntax-rule, and work in scheme, problem solved ;)
11:34:17 <bjorkintosh> ah.
11:34:22 <bjorkintosh> i see.
11:34:34 <ski> edwardk : i'm not sure how that would work
11:34:34 <Cale> Even when using GHCi, it works better to keep a text editor open alongside it
11:34:42 <bjorkintosh> okay.
11:34:52 <Cale> (especially as only some kinds of declarations can be made at the ghci prompt)
11:34:52 <edwardk> ski: you should be able to define a suitable 'case' macro that does what you want
11:34:57 <ksf> ...there's even an :e command to edit the current file
11:35:09 <Cale> I don't use :e, just two windows :)
11:35:24 <Cale> But you can do that too if you like
11:35:25 * ski uses two screen windows
11:35:26 <ksf> me too.
11:35:47 <ksf> vim in 90% of the screen at the top, console at bottom
11:36:11 <bjorkintosh> have any of you succesfully run the examples from the haskell school of expression?
11:36:13 <ski> edwardk : provided i have `multi', then probably yes .. i'm not seeing it otherwise
11:36:22 <jontore> pastorn,  Not quite got the hang of it yet. How do I use the functions of the original state monad when they are wrapped inside LULS ?
11:36:22 * hackagebot upload: yuuko 2010.1.23 - A transcendental HTML parser gently wrapping the HXT library (JinjingWang)
11:36:47 <ski> (maybe it can be simulated with `call-with-current-continuation', i not sure .. hopefully without defining a new language, though)
11:36:57 <edwardk> ski: i was thinking in terms of defining multi in terms of the record of continuations approach mentioned above.
11:37:45 <MissPiggy> transcendental HTML parser??
11:37:51 <ski> mutating a global cell holding the current continuation record ?
11:38:02 <pastorn> jontore: like you normally would with get/put
11:38:13 <gwern> > 21 / 28
11:38:14 <lambdabot>   0.75
11:38:23 <jontore> pastorn, ok thx
11:38:32 <edwardk> ski: its not hard to desugar (ucase (foo bar) (left# a -> ...) (right# b -> ...)) into something like i used.
11:39:28 <edwardk> ski: nah, not mutating, just returning the continuation pair as a record
11:39:39 <pastorn> @hpaste
11:39:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:40:36 <MissPiggy> what should i do?
11:41:17 <ski> write a checker for propositional modal logic ?
11:41:30 <MissPiggy> proof checker?
11:41:37 <edwardk> ski: ufun (left# a -> ...) (right# a -> ...) becomes a record: { left# a = ... , right# b = ... } ... ucase (foo bar) (left# a -> ...) (right# b -> ...) becomes field selection on that record based on the result of foo bar.
11:41:57 <ski> formula checker, i.e. which decides a modal formula
11:42:16 <MissPiggy> okay
11:43:07 <pastorn> jontore: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8112#a8112
11:43:17 <ski> edwardk : well, the point was to let `foo bar' pick the right branch, instead of letting it return a tag to a central place (the `case') and then branch depending on the tag
11:43:25 <pastorn> jontore: didn't typecheck that, though
11:43:51 <ski> iwo, i'm not sure i understand what you mean .. or if i do, i don't understand how it helps implementing this correctly
11:43:52 <pastorn> runLULZ might be wrong, but i don't think so ;p
11:44:36 <MissPiggy> ski but there are quite a few modal logics :(
11:44:38 <MissPiggy> which one/
11:45:18 <MissPiggy> axioms []p->p, [](p->q)->([]p->[]q) and rules p,p->q|-q and p|-[]p ?
11:45:19 <edwardk> ski: thats fine, foo bar can return a function that takes the record that would be built by ufun and selects the appropriate slot. all i was doing was giving you basically a way that you could write a couple of macros and implement your fairly magical haskell code transformation directly in scheme using more or less the same code you wrote
11:45:57 <edwardk> MissPiggy: clearly the modal logic should be pluggable =)
11:46:03 <ski> MissPiggy : well, you could start with K and T, i suppose
11:46:54 <edwardk> MissPiggy: you could even work with display logic so people can mix and match modal logic components
11:47:25 <jontore> pastorn, Ok thank you again. I'll give it a go see how far I get : )
11:47:27 <ski> i'd start with K, and then allow switching on reflexivity, as well as transitivity
11:47:34 <MissPiggy> I don't know what algorithm to use
11:47:41 <MissPiggy> something to do with tableux
11:47:59 * ski has seen one using semantic tableaux in a book
11:48:06 <pastorn> jontore: did you read that page i linked about record syntax?
11:48:08 <MissPiggy> I don't think I can do this ski
11:48:12 <edwardk> MissPiggy: maybe start somewhere around: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.2330
11:48:13 <pastorn> you should use that for you Env.
11:48:26 <pastorn> if you don't you're in for a world of hurt
11:48:28 <edwardk> MissPiggy: there are a few bdd haskell bindings floating around
11:48:49 <ski> "bdd" ?
11:49:21 <edwardk> ski: http://en.wikipedia.org/wiki/Binary_decision_diagram
11:49:26 <jontore> pastorn, recorded syntax ? right No have not gotten that far yet
11:49:37 <ski> edwardk : related to bddbddb, i suppose ?
11:49:48 <gwern> what do we actually use bdds for?
11:49:48 <edwardk> ski: bddbddb uses them, yes
11:50:01 <gwern> knuth seemed to have nerdgasms in his fasicle on them
11:50:43 <edwardk> gwern: they come in rather handy when doing things like pointer analysis, etc. but honestly it turns out they aren't necessarily the best way to solve, say, datalog problems, when you need very precise analyses
11:50:59 <pastorn> jontore: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
11:51:00 <ski> hm, the binary decision tree looks like a trie
11:51:25 <edwardk> http://doop.program-analysis.org/download.html makes a good case for _not_ using BDDs in some analysis scenarios
11:51:47 <gwern> ski: that's what you say about everything! linked lists remind you of tries, skip lists remind you of tries, binary trees remind you of tries, finger trees remind you of tries, ropes remind you of tries. :)
11:51:48 <edwardk> er. they have some papers on http://doop.program-analysis.org/index.html
11:51:55 <pastorn> jontore: you should have data Env = Env [Map VarName Type] (Map FunName TypeSig)
11:51:57 <ezyang> gwern: heh
11:52:04 <pastorn> jontore: but with record syntax
11:52:44 <gwern> edwardk: but no links to said papers?
11:52:59 <ski> gwern : maybe so, but i've not of those latter as tries
11:53:07 <ski> s/not/not thought/
11:53:29 <edwardk> gwern: they don't? lemme check: http://doop.program-analysis.org/documentation.html
11:53:44 <gwern> edwardk: ok there are some links
11:54:03 <edwardk> gwern: I was present at the NEPLS one. great talk.
11:54:08 <jontore> pastorn, linking it with names. Right. I didn't quite get where you ment I should change it to recored sytax ?
11:56:19 <ski> MissPiggy : i would try falsifying the whole formula, working inwards, when a prop. var. is reached, we instantiate its truth value in an environment. the trickier cases are the modal operations
11:57:31 <ski> if we have reflexivity, then if `<> Phi' is false, then `Phi' must also be false and if `[] Phi' is true, then `Phi' must also be true
11:57:46 <edwardk> basically came down to using some primitive database query optimization techniques and a fairly simple b-tree implementation rather than bdds
11:58:39 <ski> if `[] Phi' is false, but `Phi' turns out to be true, we need to construct a new world in which `Phi' is false (and in which every previously true `[] Phi' is true, and every previously false `<> Phi' is false)
11:59:20 * ski hasn't worked out the details of how to do this, but thinks it can probably be done, with some thought
11:59:45 <ski> repeat ad nausaeum
12:00:49 <noggle> hey I am on debian
12:00:57 <noggle> I do not have a Data.Function module
12:01:11 <noggle> hoogle says that it is marked as experiemental
12:01:19 <noggle> I want the on function
12:01:36 <MissPiggy> you can define on yourself
12:01:39 <noggle> so I can sortLists xs = sortBy (compare `on` length) xs
12:01:51 <xerox> sortBy (comparing length)
12:01:56 <doserj> noggle: forget the debian provided packages, install the ghc-6.10.x binary and the haskell-platform
12:02:01 <MissPiggy> ((&) `on` f) x y = f x & f y  or something
12:02:12 <chrissbx> noggle: I have it from Debian
12:02:25 <chrissbx>  /usr/lib/ghc-6.8.2/lib/base-3.0.1.0/Data/Function.hi it seems
12:02:30 * noggle wants on because he does not understand what on is or the ordering type
12:02:39 <noggle> okay haskell platform
12:03:10 <noggle> all I have is Text/Show/Functions.hi
12:03:21 <chrissbx> ghc6 6.8.2dfsg1-1.1
12:03:40 <chrissbx> on lenny
12:03:50 * hackagebot upload: bamboo-theme-blueprint 2010.2.25.1 - bamboo blueprint theme (JinjingWang)
12:04:57 <noggle> uh oh
12:05:02 <noggle> I need to read about ordering
12:05:21 <noggle> I am realizing that this type business needs to be understood very well
12:05:26 <noggle> thanks for the help guys
12:06:51 * hackagebot upload: bamboo-launcher 2010.2.25 - bamboo-launcher (JinjingWang)
12:09:29 <Dementati> Can I pattern match a string that ends in a specific character?
12:09:35 <mauke> no
12:09:47 <Dementati> kk, thanks.
12:10:05 <mauke> foo s@(_ : _) | last s == c = ...
12:10:18 <Cale> Dementati: You can use a guard with isSuffixOf though
12:10:22 <Cale> Or last
12:10:45 <Cale> (but last is a bit unsafe so you have to be careful that it's not empty, like mauke shows)
12:12:38 <aavogt> > "hai" `isSuffixOf` ""
12:12:40 <lambdabot>   False
12:12:54 * hackagebot upload: GtkTV 0.1.4 - Gtk-based GUIs for Tangible Values (ConalElliott)
12:13:18 <Gracenotes> : _)
12:16:01 <pastorn> jontore: instead of having (RGB Int Int Int) it's easier to work with RGB { r :: Int, g :: Int, b :: Int }
12:16:03 <bjorkintosh> is haskell '98 still the standard?
12:16:25 <Twey> bjorkintosh: No
12:16:26 <mauke> bjorkintosh: /topic
12:16:38 <Twey> bjorkintosh: Haskell '98 is dead, long live Haskell 2009
12:16:47 <mauke> it's 2010
12:17:03 <bjorkintosh> ah.
12:17:53 <pastorn> jontore: with the latter of those definitions, be sure to check out what types r, g and b has (hint: they are functions)
12:18:18 <gwern> > nub [True, False, undefined]
12:18:20 <lambdabot>   [True,False* Exception: Prelude.undefined
12:18:20 <benmachine> to be fair the 2010 document hasn't actually been written yet >_>
12:18:25 <gwern> hm. that is bad
12:18:29 <Twey> mauke: It was released in '09, though :<
12:18:33 <pastorn> gwern: what did you expect?
12:18:34 <Twey> Wasn't it?
12:18:36 <gwern> nub on Bools should == take 2
12:18:39 <Twey> benmachine: Really?  Huh.
12:18:50 <ksf> very funny, universe. you could've told me earlier that byte != unsigned byte
12:18:51 <Twey> gwern: Why?
12:18:56 <pastorn> gwern: oh, SPECIALIZE pragma?
12:18:56 <benmachine> Twey: they've finalised what is going to be in it, I think
12:19:01 <Twey> > nub [True, True, False]
12:19:03 <lambdabot>   [True,False]
12:19:05 <gwern> pastorn: Bool only has 2 values, so [True], [False], [True, False], [False, True] are literally the only posible values
12:19:12 <Twey> > take 2 [True, True, False]
12:19:13 <lambdabot>   [True,True]
12:19:13 <benmachine> and []
12:19:32 <Twey> > nub [True, False, True]
12:19:33 <lambdabot>   [True,False]
12:19:36 <leadnose> how about bottom?
12:19:37 <mauke> gwern: how would nub know that?
12:19:44 <doserj> and undefined, [undefined], [True,undefined], etc
12:19:52 <gwern> mauke: some sort of pragma, GHC rewrite rule, typeclass magic
12:20:05 <mauke> that would violate the type system
12:20:07 <mauke> :t nub
12:20:08 <noggle> looking at this notation: insertBy cmp x ys@(y:ys')
12:20:08 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:20:25 <edwardk> > nub [True,False,True]
12:20:26 <lambdabot>   [True,False]
12:20:29 <noggle> what is ys@(y:ys)?
12:20:44 <Twey> noggle: Broken
12:20:45 <mauke> noggle: ys aliased to (y:ys)
12:20:45 <gwern> mauke: sure ghc rewrites can't fire on nub called with [Bool] arg?
12:21:00 <noggle> ahh an alias
12:21:04 <noggle> okay
12:21:08 <mauke> gwern: they can, but then it's no longer parametric polymorphism or something
12:21:17 <monochrom> If you give it [1,2,3], ys refers to the whole, ys' refers to [2,3]
12:21:19 <Twey> :t \x@(x:xs) -> x
12:21:21 <lambdabot>     Conflicting definitions for `x'
12:21:21 <lambdabot>     In a lambda abstraction
12:21:25 <gwern> noggle: in haskell, everything is an alias for something else
12:21:27 <edwardk> mauke: rewrite rules don't care about parametric polymorphism ;)
12:21:27 <Twey> noggle: Broken.
12:21:56 <monochrom> Twey: It's a typo. Just 3 lines before, it was insertBy cmp x ys@(y:ys')
12:22:03 <noggle> gwern: what do you mean?
12:22:04 <Twey> Ah, okay
12:22:11 <edwardk> mauke: well, they do, but you can get a long way with SPECIALIZE pragmas and the occasional rewrite rule in terms of practical rewriting
12:22:13 <gwern> noggle: I mean exactly that
12:23:32 <noggle> gwern: can you give me an example?
12:23:38 <gwern> noggle: "sure"
12:24:05 <noggle> I can see how pattern matching can be similar to an alias, a function name, a value
12:24:14 <noggle> er, name = value
12:26:46 <pastorn> gwern: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22971#a22971
12:27:00 <pastorn> just do something with the SPECIALIZE pragma and you're good to go
12:28:12 <roconnor> hmm, there are no elements of Algebra (Cont Bool) Void
12:28:20 <roconnor> I guess that is to be expected
12:28:25 <edwardk> {-# RULES "nub/nubBool" nub = nubBool #-}
12:28:58 <pastorn> edwardk: does that really work?
12:29:10 <edwardk> pastorn: yeah. it only applies where the types match
12:29:10 <pastorn> you never mention the type
12:29:15 <pastorn> haha, cool
12:29:36 <gwern> edwardk: wait what
12:29:50 <gwern> how does that work? "nub/nubBool" doesn't seem sensible
12:29:55 <doserj> pastorn: in your version, nubBool [True,True,...] doesn't even return the first element
12:30:02 <roconnor> edwardk: what is nubBool ([True,False]++repeat False)?
12:30:24 <gwern> roconnor: [True, False]?
12:30:33 <edwardk> roconnor: it replaces a bottom with an answer. same with the error cases, etc.
12:30:38 <pastorn> doserj: whut?
12:31:39 <gwern> pastorn: maybe it's because of 'repeat True'? True, True... gets replaced with True. ...=True, so you run True : nub True,True...
12:31:43 <edwardk> roconnor: so the substitution is 'at least as defined' as the original, like a lot of rewrite rules.
12:31:52 <roconnor> :)
12:31:58 <doserj> pastorn: take 1 (nubBool (repeat True)) is bottom. take 1 (nub (repeat True)) is [True]
12:31:58 <roconnor> I like rules like that
12:32:24 <MissPiggy> why not just have  class Nub where
12:32:27 <MissPiggy> er
12:32:31 <MissPiggy> Nub a where
12:33:03 <pastorn> doserj: give me an example of wehre nubBool and nub behaves differently
12:33:11 <doserj> repeat True
12:33:38 <pastorn> well... isn't it nicer to actually get it to terminate :p
12:33:39 <roconnor> pastorn: take 1 (nubBool (repeat True)) is bottom. take 1 (nub (repeat True)) is [True]
12:33:53 <gwern> MissPiggy: too much of a change. libraries@ would never go for it
12:33:55 <roconnor> nubBool terminates less
12:33:55 <pastorn> bottom?
12:33:57 <nschoe> Hi all, does anyone know if there is a way to force 'readFile' to close the file please ?
12:34:15 <pastorn> nschoe: look into Handles
12:34:16 <olsner> I think I'd do something like this: nubBool xs = go False False xs; go seenFalse seenTrue xs = [...]
12:34:18 <gwern> nschoe: not easily. just go use strict bytestrings where handles aren't such a nissue
12:34:38 <pastorn> @hoogle FilePath -> IO Handle
12:34:39 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
12:34:39 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
12:34:39 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
12:34:45 <roconnor> @type readFile
12:34:46 <lambdabot> FilePath -> IO String
12:34:48 <pastorn> nschoe: ^^
12:34:59 <doserj> > take 1 (nub (repeat True)) -- pastorn, try that with nubBool
12:35:00 <lambdabot>   [True]
12:35:01 <gwern> olsner: I don't think the specifics matter too much; clearly nub on [Bool] could be far more efficient than it is - O(1) than O(n)
12:35:27 <pastorn> doserj: ok, i get it :)
12:35:34 <nschoe> pastorn : it's the 'manual' way right ? With openFile and hClose isn't it ?
12:35:39 <pastorn> is there any way to write nubBool so that it doesn't do that?
12:35:58 <olsner> could be done generically for any bounded data type in something like O(maxBound) compares, I guess
12:36:02 <nschoe> gwern : You suggest I should use ByteString intead of String ? Will it solve my problem ?
12:36:10 <Cale> nschoe: There isn't. Also, be careful if you use hGetContents on a Handle -- you're supposed to allow hGetContents to close the file on its own. If you hClose a handle that's been hGetContents'ed, the string which resulted from hGetContents will be arbitrarily truncated.
12:36:12 <pastorn> nschoe: you get a handle and then you use hGetLine or whatever and when you're done you just use hClos h
12:36:31 <gwern> nschoe: Data.ByteString.Char8.readFile, besides being faster than Prelude.readFile, is strict and closes the file right away, AFAIK
12:36:35 <Cale> nschoe: (I meant there isn't a way to manually close a file opened by readFile)
12:37:07 <Cale> nschoe: If you just lose the last reference to the string given to you by readFile though, the file will close.
12:37:28 <nschoe> Cale : err, okay, so my only way of doing things is to use openFile and pass the handle to every function that need to write to the file ?
12:37:40 <Cale> Uh, write?
12:37:54 <Cale> If you're writing to the file, you could just build up a String
12:38:00 <Cale> and only write it all at once
12:38:06 <monochrom> I recently pulled this trick. do { h<-openFile blah; s<-hGetContents h; v<-readIO s; hClose h }. Since readIO is eager enough, closing right after is fine.
12:38:07 <edwardk> doserj: no strategy can return a correct answer for 'repeat True' without cheating. the problem is Pi_2^0 complete -- you need an oracle for the halting problem in general =)
12:38:11 <Cale> (at which point the String will be computed)
12:38:18 <doserj> pastorn: nubBool (True:True:xs) = True:filter not xs; nubBool (False:False:xs) = False:filter id xs?
12:38:33 <monochrom> And actually I used withFile rather than my own open-close.
12:38:43 <nschoe> Yeah, actually I have a function that 'readFile' a file, and then it calls a function over the read content,and inside that function, I have to write to the file.
12:38:44 <medfly> dropWhile?
12:38:46 <doserj> edwardk: not for all elements, but for the first, it can
12:38:52 <medfly> :t dropWhile
12:38:53 <edwardk> doserj: true
12:38:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:38:55 <pastorn> doserj: why did you rage about not terminating and not just point that out to begin with?
12:38:56 <Cale> monochrom: Ah, readIO ensures that v is evaluated, because it has to catch the exception.
12:39:21 <monochrom> Not accurately, but we know what you mean.
12:39:23 <Cale> Or rather, throw the exception, in the case that there are no parses
12:39:37 <doserj> pastorn: I said: "...doesn't even return the first element"
12:39:47 <Hunner> can I simplify "f x = case x of"?
12:39:53 <monochrom> It's really "always reads enough of the string because it has to determine good parse or bad parse".
12:40:01 <doserj> pastorn: and then illustrated the take 1 example
12:40:01 <pastorn> s/point out/give a correct version/
12:40:18 <medfly> > let ff True = "True!" in ff True
12:40:19 <lambdabot>   "True!"
12:40:20 <medfly> > let ff True = "True!" in ff False
12:40:22 <lambdabot>   "* Exception: <interactive>:1:137-153: Non-exhaustive patterns in function ff
12:40:25 <nschoe> gwern : okay, it seems the bst way for me, since the file I need to read is rather small.
12:40:27 <medfly> good?
12:40:44 <Cale> Hunner: You can write it as a bunch of separate pattern matching definitions for f, if that's simpler
12:41:15 <nschoe> Cale : thanks, I'll try it, combined with a strict "reading".
12:41:28 <Twey> > (\True -> a) False
12:41:30 <lambdabot>   * Exception: <interactive>:1:134-143: Non-exhaustive patterns in lambda
12:41:51 <Twey> > (\0 -> a) 1
12:41:52 <lambdabot>   * Exception: <interactive>:1:142-148: Non-exhaustive patterns in lambda
12:41:54 <Hunner> Cale: thanks
12:41:57 <Cale> nschoe: What sort of program is this? Are you running out of filehandles?
12:42:00 <ksf> nschoe, you don't want to write to a file you're reading from, ever.
12:42:09 <ksf> write to another one and do an atomic move afterwards
12:42:32 <Cale> yeah, heh, lazy IO actually makes it awkward to do the wrong thing in that regard :)
12:42:46 <nschoe> ksf : nope, but 1/ I get the content of a file 2/ I apply a function to this content, and inside, I may need to write to the file, so .. actually I need to stricly read the file ...
12:43:25 <ksf> ...and your data will still be mosh as soon as your program gets killed doing that.
12:43:35 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22971#a22973
12:43:40 <nschoe> Cale : it's nothing complicated, it's a password manager (my program is similar to the one written on RWH, page 305 if you possess the book).
12:43:44 <monochrom> we need transactional file system now
12:44:01 <mm_freak> lazy IO is great for generating passwords
12:44:06 <mauke> password manager?! you don't want that to corrupt your files
12:44:06 <mm_freak> > take 10 . filter isAsciiLower <$> readFile "/dev/urandom"
12:44:06 <ksf> that won't help you, as you're committing transactions that result in invalid data
12:44:06 <mm_freak> "vblwszmqiu"
12:44:07 <lambdabot>   <IO [Char]>
12:44:27 <Cale> nschoe: which chapter?
12:44:39 <nschoe> Chapter 13 : Data Strucutres.
12:45:25 <nschoe> When they showed us the code for 'Extended Example: /etc/passwd' I thought of doing a program that does something similar, but I added a choice in the menu, namely "Add a new Entry".
12:45:59 <nschoe> mauke : True; but is strict 'reading' risky for my data ?
12:46:06 <mauke> nschoe: no, but writing to files is
12:46:16 <Hunner> @hoogle a -> Maybe a -> a
12:46:17 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
12:46:17 <lambdabot> Prelude asTypeOf :: a -> a -> a
12:46:17 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
12:46:27 <nschoe> mauke : you mean writing to file in a strict way ?
12:46:38 <ksf> writing in any way is unsafe.
12:46:41 <mauke> writing to a file in any way
12:46:43 <Cale> nschoe: In general, writing to files that your program or other programs on the system might be reading is a bit risky.
12:46:47 <ksf> you could be interrupted before you're done.
12:47:03 <nschoe> ksf, mauke : yeah but ... I have to store some data, I don't have the choice ?
12:47:06 <ksf> so the solution is to write to another file, and if that's successful, move it where you want it.
12:47:17 <ksf> as moving can be done atomically
12:47:21 <mauke> also fsync before moving
12:47:24 <nschoe> Cale : so what should I do ?
12:47:28 <nbowler> ksf: on some platforms.
12:47:43 <mauke> nschoe: how about listening to ksf
12:47:45 <ksf> ...well, at least it's got a better chance to be atomic than a series of writes
12:48:15 <ksf> nschoe, and listen to mauke.
12:48:20 <mauke> hah
12:48:32 <mauke> ksf: you should have said "don't listen to mauke"
12:48:39 <ira> hi all -- I'm using Data.Trie which is a map from ByteStrings to any type, and it aliases "ByteString" to "KeyString", so the type inference thinks my keys are a different type. I don't know how to clue it in they are the same.
12:48:51 <ksf> I might have a wicked sense of humor, but I won't tell people not to fsync.
12:49:15 <ksf> doing that is just fsking retarded.
12:49:16 <Cale> nschoe: Write to temporary file, and then use System.Directory.renameFile to move it into place
12:49:27 <mauke> ira: you might be confused
12:49:28 <Nereid_> ira: but KeyString and ByteString are synonymous
12:49:35 <nschoe> Cale : okay, I wasn't sure I had understood correctly what ksf meant.
12:49:58 <nschoe> Thank you, but isn't renameFile risky too ?
12:50:08 <Cale> I will avoid telling people to fsync, because I don't know of a general cross-platform way to do that.
12:50:10 <edwardk> ira: the type KeyString = ByteString already told the compiler they are the same thing. you may now use those words interchangeably.
12:50:12 <ira> Nereid_: yes, yet the inference thinks they're different..
12:50:16 <ksf> nschoe, less risky than writes, and possibly even atomic
12:50:20 <mauke> ira: no, it doesn't
12:50:23 <ksf> (depending on OS and file system)
12:50:30 <Nereid_> ira: what's the error?
12:50:35 <edwardk> ira: you probably have a different ByteString. there are 4 of them
12:50:39 <Nereid_> also that
12:50:40 <Saizan> edwardk: 2
12:50:41 <ksf> in any case, you're still going to have your data.
12:50:42 <Cale> nschoe: It also avoids the lazy/strict I/O problem.
12:50:48 <ira> I think it may have something to do with qualification
12:50:49 <monochrom> "a move is worth a thousand writes"
12:51:02 <mauke> edwardk: I thought only 2
12:51:04 <nschoe> Cale : True.
12:51:05 <edwardk> ira: or is it 2?
12:51:06 <edwardk> ah
12:51:10 <Cale> nschoe: because if you wait until your temporary file is completely written, you must have read everything that you needed to read from the original
12:51:11 <edwardk> mauke: yeah
12:51:12 <Nereid_> ira: Data.Trie uses Data.ByteString from the bytestring package. is that the one you're using?
12:51:14 <Saizan> ira: there are two ByteString types, one from Data.ByteString, the other from Data.ByteString.Lazy
12:51:24 <ira> ah ok
12:51:38 <nschoe> ksf : and (sorry to bother again) how can I test whether the data has been sucessfully written to the temp file before renaming ?
12:51:43 <Cale> (assuming that you don't need to keep the contents of the original file for anything else)
12:51:48 <ira> so i need a particular bytestring, I am using the lazy type
12:51:54 <ksf> nschoe, when you've closed your file and called fsync
12:52:06 <Cale> nschoe: do a writeFile, and if it finishes without throwing an exception, you should be fine
12:52:18 <Saizan> ira: yeah, Data.Trie uses the other
12:52:24 <Cale> fsync is overkill
12:52:28 <ksf> ...fsync will block until everything is on disk
12:52:29 <edwardk> ira: you need to convert to a strict bytestring before feeding it to the library then.
12:52:34 <Cale> Actually, it won't.
12:52:36 <ezyang> ksf: Not necessarily :-/
12:52:44 <mauke> Cale: fsync is necessary
12:52:48 <ezyang> Since app writers abused fsync...
12:52:50 <ira> i see... thanks!
12:53:04 <Saizan> (who thinks it'd be better to have ByteString and LazyByteString types?)
12:53:10 <Cale> mauke: necessary for what?
12:53:24 <mauke> Cale: for working programs that don't leave 0-byte files around
12:53:25 <nschoe> ksf, Cale : okay I'll try it. But when I have finished writing to the temp file, won't I have the same error "resource busy (file locked)" when callign renameFile ?
12:53:26 <ksf> I'm fine with those two types, it's the internal ones that trip me up
12:53:48 <Cale> nschoe: writeFile blocks until the file is written.
12:54:06 <edwardk> ira: if you have imported Data.ByteString.Lazy as L: L.concat . L.toChunks -- would convert it
12:54:07 <ksf> nschoe, not if you've closed the input file.
12:54:39 <pastorn> jontore: have you gotten anything working yet?
12:54:57 <ira> edwardk: awesome
12:55:20 <nschoe> ksf : the input file is read via 'readFile' : is it okay ?
12:55:24 <edwardk> ira: er S.concat . L.toChunks where S is Data.ByteString
12:55:29 <edwardk> ira: sloppy of me
12:56:27 <ira> ok so toChunks produces a list of strict bytestrings -- got it
12:56:29 <Saizan> S.concat . L.toChunks is not cheap though
12:56:56 <ira> my keys should be quite short on average
12:57:03 <ira> if that helps
12:57:11 <mauke> ira: then why are you using lazy strings?
12:57:47 <ira> i'm reading in a large file of them...
12:57:55 <mauke> so?
12:58:06 <ira> does it make no difference?
12:58:44 <mauke> I'd immediately convert each key to a strict bytestring
12:59:36 <ira> eg, if I call 'lines' on a large string being read in from a file, should it make no difference if it's acting on strict vs lazy?
13:00:07 <ksf> lazy IO should just be outlawed.
13:00:26 <Twey> .i'e
13:00:42 <Saizan> ira: strict BS readFile reads the whole content in memory up front, the lazy one doesn't
13:01:15 <Saizan> though lines on a strict bytestring shouldn't do any copying
13:01:47 <Saizan> while transforming each line to a strict bytestring later will do some
13:02:05 <ira> actually now that I check there's not even a 'lines' for the strict version
13:02:34 <Saizan> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.5/doc/html/Data-ByteString-Char8.html#14 <- there is
13:02:44 <ira> ah ok
13:03:08 <Saizan> anyhow, maybe do what's simpler and profile later
13:03:22 <edwardk> so call lines, then convert each one in turn to a strict bytestring. most of those line fragments will consist of a single lazy chunk, so it should be relatively cheap if they've got the right fast path in concat.
13:03:55 <ira> all right ima try that
13:04:06 <bjorkintosh> is there a recommended haskell mode for emacs?
13:04:11 <damd> yeah, haskell-mode
13:04:13 <monochrom> Yes.
13:04:31 <bjorkintosh> but it's playing havoc with the indentation.
13:05:13 <Cale> haskell-mode doesn't get if/then/else right, unfortunately.
13:05:27 <edwardk> concat [ps] = ps is built in in Data.ByteString so in the common case where lines returns a lazy bytestring that doesn't straddle a chunk boundary no copying goes on
13:05:29 <damd> are there any haskell modes for emacs which do?
13:05:33 <Cale> (though apparently you can configure it to do better)
13:05:36 <monochrom> In what sense? You should press tab a few times to cycle through choices, since there are multiple legitimate choices.
13:05:46 <Cale> and you sometimes have to hit tab after the first keyword on a line to get it to indent right
13:05:53 <Saizan> if you found a ghc bug by compiling the agda typechecker with optimizations and running it on Agda's standard library, how would you make it a reasonable testcase?:)
13:06:08 <bjorkintosh> Cale, so is there something else which works better?
13:06:12 <Cale> It seems to like lining up if and then vertically by default, which is wrong.
13:06:26 <Cale> I haven't been using emacs in a while, so I don't know.
13:06:38 <Cale> I've mostly been using vim.
13:06:38 <bjorkintosh> ah. what do you use, vim?
13:06:48 <bjorkintosh> ah good.
13:07:01 <bjorkintosh> that's what i normally use anyway.
13:07:21 <Cale> Just make sure that you set expandtab
13:07:37 <Cale> I also like using smarttab
13:07:52 <Cale> and set my tab width to 2 spaces
13:08:11 <Cale> Basically, you want something that makes it easy to get just the indentation you're after
13:08:27 * monochrom tries out the latest 2.7.0 (Nov 2009). You know, everything you know may be outdated.
13:08:30 <Cale> (any exact number of spaces)
13:11:26 <bjorkintosh> alright all of those are set.
13:12:32 <sizur> can GADTs be mixed with record syntax?
13:13:01 <ksf> not in the same declaration
13:13:06 <ksf> er wait
13:13:11 <ksf> no, they can't.
13:13:40 <Philonous> Actually they can be
13:13:48 <sizur> is there something fundamental prohibiting that or it's simply not yet implemented?
13:13:50 <Cale> There is an extension for that.
13:14:04 <ksf> an extension to an extension?
13:14:13 <MissPiggy> yo dawd I
13:14:22 <Cale> er, I thought so
13:14:24 <ksf> do you need -XExtensibleExtensions to enable those?
13:14:26 <MissPiggy> heard you like extensions....
13:14:29 * Phyx- furiously closes the text editor, damn bug, spend all day on it
13:14:35 <opqdonut> yeah ISTR such an extension too
13:14:48 <mauke> furiously? as in :wq!!!!!!!!?
13:14:49 <sizur> Cale: nice, do you remember the name of the -X for that?
13:14:57 <Cale> ah, no, it's just GADTs
13:15:01 <Phyx-> mauke: almost, no w
13:15:57 <sizur> Cale: so i can do data A where A {blah::String, something::String} :: String -> String -> A?
13:16:01 <Cale> You can use record syntax with GADTs, but every constructor which has a field name in common must have the same result type
13:16:09 <Philonous> data Foo where Foo { bar :: Int} :: Foo
13:16:13 <Cale>   data Term a where
13:16:13 <Cale>       Lit    { val  :: Int }      :: Term Int
13:16:30 <MissPiggy> weird
13:16:32 <Hunner> Do most people put their boilerplate and helper functions above or below their "higher level" code?
13:16:41 <MissPiggy> why would you want projections on a data type with multiple constructors
13:16:53 <Cale> Hunner: I usually put it below
13:16:53 <MissPiggy> hmmmmm
13:16:54 <ezyang> Hunner: Depends on how I'm feeling :-)
13:16:58 <ksf> Hunner, depends on where my cursor is when I write them
13:17:04 <MissPiggy> I suppose the TYPE of the gadt can refine the thing into a single constructor type
13:17:11 <MissPiggy> so that does make sense, infact
13:17:22 <MissPiggy>   Foo :: Term Bool -- Lit is the ONLY Term Int
13:17:36 <Saizan> the same field can be used on more than one costructor too
13:18:00 <ksf> most end up in where-clauses, anyway. another big chunk goes into other modules, and the rest close to those function where they're needed
13:18:38 <sizur> Saizan: interesting. how are internals implemented, c struct for the whole type?
13:18:42 <ksf> (I usually develop everything inside module Main and then move it somewhere else as soon as stuff is getting too big)
13:18:47 <bjorkintosh> alright, so i've done all that. why am i getting this error: gw2.hs:3:7:    The last statement in a 'do' construct must be an expression
13:18:58 <samosa> wtf is haskell
13:19:08 <Hunner> thanks
13:19:09 <samosa> where did it come from
13:19:11 <Phyx-> a brand of legos
13:19:12 <bjorkintosh> http://www.pastebin.com/t8YTTsqs
13:19:18 <bjorkintosh> samosa, it's someone's name.
13:19:23 <ksf> bjorkintosh, because the last statement must not be a <-
13:19:30 <bjorkintosh> but it isn't!
13:19:37 <bjorkintosh> that's the code above.
13:19:50 <medfly> http://en.wikipedia.org/wiki/Haskell_(programming_language)#History
13:19:54 <Saizan> sizur: the runtime representation is the same as normal ADTs i believe
13:19:57 <ksf> oh yes, it is.
13:20:17 <ksf> ...you cannot dedent "drawInWindow" after opening the do block at "w <-"
13:20:28 <bjorkintosh> but i copied it directly from hudak's book.
13:20:28 * ezyang facepalms 
13:20:29 <ksf> the identing level is dictated by the first non-white character after the do
13:20:40 <Saizan> sizur: a tag saying which constructor it is and pointers to the fields (or directly the values if they get UNPACKed)
13:20:45 <bjorkintosh> ah. let me see.
13:21:24 <ksf> main = runGraphics $ do w <- openWindow "Foo" (400,400); drawInWindow ...; ...
13:21:26 <sizur> Cale: thanks for the example
13:21:52 <ksf> those () after main are highly suspect
13:22:33 <bjorkintosh> oops. that's meant to be a 0
13:22:37 <bjorkintosh> main0, not main ()
13:22:41 <bjorkintosh> my typo. let me retry.
13:22:50 <bjorkintosh> so you're saying everything after do must be indented...
13:22:51 <Hunner> another question: `query x y = mapM (putStrLn . showRow) =<< getRows x y` works, but not when I take away the x and y... why? (it's in a where clause)
13:23:26 <ezyang> Hunner: =<< is not a composition operator
13:23:30 <ezyang> swap it with <=<
13:23:39 <ezyang> and that'll only work if you drop only y
13:23:51 <ezyang> since getRows is 2-arity... there might be a builtin combinator for that
13:24:09 <bjorkintosh> same error. everything's nicely indented after do.
13:24:09 <Nereid_> :t <=<
13:24:11 <lambdabot> parse error on input `<=<'
13:24:14 <Nereid_> :t (<=<)
13:24:16 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:24:17 <Saizan> Hunner: are you binding x and y in a do-block and wonder why they are not in scope in a where clause?
13:24:34 <Hunner> Saizan: binding x. y is a string
13:24:53 <Saizan> Hunner: can you paste the code?
13:24:58 <bjorkintosh> ksf, could you paste a properly formatted version of that code in pastebin?
13:25:03 <bjorkintosh> it must be something tiny i'm missing...
13:25:09 <bjorkintosh> or i can't indent at all.
13:25:45 <ksf> http://pastebin.com/FgHMh4f9
13:26:20 <Saizan> Hunner: however if you have foo = do x <- someaction; bar; where bar = return x; <- it's normal for x to not be in scope there, because bar is defined regardless of the execution of someaction, so it can't reference someaction's result
13:26:29 <Hunner> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22974
13:27:02 <Saizan> Hunner: you've to write "foo = do x <- someaction; let bar = return x; bar" instead
13:27:04 <ezyang> Saizan: I don't think that's the issue here...
13:27:18 <ezyang> He's trying to write it in pointless style?
13:27:30 <ezyang> (at least, that's what I interpreted the question as...)
13:27:34 * Hunner doesn't know the difference between <=< and =<< yet... just started getting the hang of monadic ideas
13:27:43 <ezyang> :t (=<<)
13:27:43 <Saizan> ezyang: you're right :)
13:27:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:27:49 <ezyang> :t (<=<)
13:27:50 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:27:57 <bjorkintosh> thanks.
13:28:06 <bjorkintosh> now it says nothing's in scope.
13:28:06 <Saizan> Hunner: (=<<) is monadic application, while (<=<) is monadic composition
13:28:11 <ezyang> so <=< takes a function on the right side
13:28:28 <bjorkintosh> and your version looks a bit different from what i typed.
13:28:29 <Hunner> Thanks. The english answer is more helpful :)
13:28:41 <ezyang> Sorry :o)
13:29:35 <Saizan> yeah, a bit part of learning haskell is to learn how to interpret types, but it does pay in the end
13:30:22 <ezyang> Even outside of Haskell.
13:30:59 <medfly> I started studying some maths in uni and it's so much like Haskell! >.<
13:31:46 <Hunner> Reading the types is fine, but I can't easily tell when they should be applied in the general case from that. And seeing as this is a room of humans who can put it in english easily... :)
13:39:24 <monochrom> Cale: haskell-mode 2.7.0 treats if-then-else inside do-block correctly. "then" and "else" are two spaces inner than "if".
13:40:00 <mm_freak> oh, really?
13:40:28 <monochrom> At least, if you choose the most advanced one of the three indentation algorithms offered.
13:40:32 <mm_freak> monochrom: doesn't seem to work here, do i need to configure it first?
13:40:49 <monochrom> Use this: (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
13:41:24 <mm_freak> the mode works, but it doesn't indent then and else deeper
13:41:36 <monochrom> Inside do-block
13:41:59 <monochrom> Damn English.
13:42:27 <monochrom> I should say every compond sentence in the form and presentation of a checklist.
13:42:50 <mm_freak> i am inside of a do-block
13:42:50 <monochrom> [ ] haskell-mode 2.7.0
13:42:54 <Hunner> ezyang: I know what "2-arity" and "combinator" mean, but what do you mean by putting them together? it seems like that should be implicit in haskell rather than needing a function
13:43:03 <mm_freak> main = do\nif blubb\nthen
13:43:13 <mm_freak> aligns the 'then' with the 'if'
13:43:24 <monochrom> [ ] choose 'turn-on-haskell-indentation instead of 'turn-on-haskell-indent
13:43:40 <mm_freak> oh
13:43:59 <mm_freak> ok, indeed, my fault =)
13:44:02 <monochrom> See? I should really use the checklist format.
13:44:06 <mm_freak> thanks, that's great
13:44:36 <mm_freak> no need to, it's just that i didn't know there was a different indentation mode, since it isn't mentioned in customize-group
13:46:33 * hackagebot upload: hurdle 0.4.0 - Extract function names from Windows DLLs. (StephenTetley)
13:47:36 <monochrom> Yeah, seems to be one of those things you have to write an add-hook manually in .emacs
13:48:08 <monochrom> But once it's up, there are quite a few variables you can change in the customize pages.
13:49:35 <FliPPeh> @pl unsafePerformIO (putStrLn "Cheatery!")
13:49:35 <lambdabot> unsafePerformIO (putStrLn "Cheatery!")
13:49:57 <FliPPeh> @pl unsafePut str = unsafePerformIO (putStrLn str)
13:49:57 <lambdabot> unsafePut = unsafePerformIO . putStrLn
13:50:32 <FliPPeh> unsafePerformIO feels like jamming a knife in Haskell's back
13:50:42 <FliPPeh> For it protects me from side effects
13:51:03 <FliPPeh> But using unsafePerformIO... nothing is safe anymore.
13:52:31 <bjorkintosh> bah. it looks like i'm going to have to start from somewhere else.
13:52:43 <bjorkintosh> hudak's book is hopelessly out of date.
13:54:06 <MissPiggy> FliPPeh: apparently some uses can be shown safe but I don't know which or how
13:54:08 <Alpounet> bjorkintosh, looking for a book to get started ?
13:55:00 <bjorkintosh> Alpounet,
13:55:02 <bjorkintosh> yes.
13:55:13 <bjorkintosh> the one i keep banging my head against is frustrating the heck out of me.
13:55:16 <FliPPeh>  map toUpper $ unsafePerformIO getLine
13:55:17 <FliPPeh> :d
13:55:17 <bjorkintosh> nothing runs from it.
13:55:24 <samosa> MissPiggy: can i pm u a math problem?
13:55:59 <bjorkintosh> Alpounet, do you have a suggestion for one?
13:56:09 <Alpounet> bjorkintosh, check out Real World Haskell and Learn You A Haskell
13:56:12 <Alpounet> @where rwh
13:56:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:56:13 <FliPPeh> Quick question: while XML is so important nowadays, why does the haskell platform include SO much, but not even an XML library?
13:56:15 <Alpounet> @where lyah
13:56:15 <lambdabot> http://www.learnyouahaskell.com/
13:56:44 <bjorkintosh> Alpounet, what sort of background's needed for rwh?
13:57:02 <Alpounet> a minimal programming background
13:57:07 <Alpounet> not necessarily functional
13:57:13 <bjorkintosh> okay.
13:57:16 <FliPPeh> But RWH is really fast moving
13:57:28 <bjorkintosh> FliPPeh, meaning... it's not a good intro?
13:57:53 <FliPPeh> It wasn't too great for me at least
13:58:05 <Alpounet> it depends on your profile
13:58:12 <FliPPeh> learnyouahaskell did a better job in my case
13:58:17 <Phyx-> :t everywhereBut
13:58:18 <lambdabot> forall a. (Data a) => GenericQ Bool -> GenericT -> a -> a
13:58:24 <bjorkintosh> okay.
13:58:26 <sinelaw> hey all
13:58:29 <Alpounet> lyah is much less comprehensive though
13:58:34 <Alpounet> (for the moment)
13:58:35 <FliPPeh> True that
13:58:43 * hackagebot upload: concurrent-extra 0.3.1 - Extra concurrency primitives (BasVanDijk)
13:58:44 <Alpounet> but BONUS is working hard I guess :-p
14:00:12 <FliPPeh> But what bothers me the most.. why no XML in the HS-Platform?
14:00:46 <sinelaw> xml?
14:00:49 <FliPPeh> Yes!
14:01:00 <Saizan> no obvious candidate i guess, but then the HS-Platform is still at the start
14:01:07 <sinelaw> why should it be there
14:01:43 <sinelaw> unless there's one obviously better lib that's also comprehensive
14:01:47 * hackagebot upload: ldif 0.0.5 - The LDAP Data Interchange Format (LDIF) parser (RadoslavDorcik)
14:01:58 <Alpounet> I guess FliPPeh considers an XML library should be part of a standard distribution for a language and expects one from HP
14:01:59 <sinelaw> hackage working hard today
14:01:59 <FliPPeh> Because XML isn't exactly unimportant
14:02:11 <Alpounet> but yeah there is no obvious choice AFAIK
14:02:34 <FliPPeh> In the same way I don't understand how the XHTML package got in there
14:02:39 <sinelaw> since it's so easy to install things for haskell
14:02:43 <bjorkintosh> Alpounet, thanks for the suggestion. i initially thought rwh was a bit advanced, so even though i own a copy, i'd been trying to bang my head against haskell school of expression instead.
14:02:49 <bjorkintosh> i'll read rwh first.
14:02:56 <FliPPeh> Why not include XML and derive XHTML off it?
14:03:00 <sinelaw> i don't think they need to put everything that's not unimportant there
14:03:10 <sinelaw> just cabal install if you need
14:04:11 <Alpounet> bjorkintosh, if you work out RWH's exercises, you should be fine
14:04:19 <Alpounet> and in case you run into troubles, there is #haskell :-)
14:04:29 <FliPPeh> I'm not using the Platform, as bleeding edge packages are what I want.. just wanted to know!
14:04:32 <bjorkintosh> yes indeed.
14:04:51 <bjorkintosh> Alpounet, are the exercises anything like SICP's?
14:04:55 <bjorkintosh> (i'm hoping not.)
14:05:00 <Alpounet> no
14:05:05 <monochrom> because the stock xhtml library is derived from the stock html library, not from an xml angle.
14:05:07 <bjorkintosh> good. whew!
14:05:10 <Alpounet> rwh is really about real world stuffs
14:05:17 <Alpounet> sicp is much theoretic
14:05:23 <Alpounet> much more*
14:05:31 <dolio> @seen ski
14:05:31 <lambdabot> Unknown command, try @list
14:05:35 <monochrom> hxt would be the one that does xml and then derives xhtml
14:05:38 <dolio> preflex: seen ski
14:05:38 <preflex>  ski was last seen on #haskell 2 hours, 5 minutes and 53 seconds ago, saying: repeat ad nausaeum
14:05:43 <lispy> Looks like the latest cgi package no longer builds on 6.10.4.  Is anyone else having a problem with it?  (I'm referring to the Feb 14th release)
14:05:53 <lispy> The error I get is one about exceptions
14:05:53 <mreh> if I have an infinite loop of a recursive function :: -> IO (), can I expect to get stdout from that as it is evaluated?
14:05:58 <Phyx-> > zipWith ($) (concat $ repeat [id, (+1), join (*), join (+), (div 2)]) (map ord "Phyx")
14:05:59 <lambdabot>   [80,105,14641,240]
14:06:11 <lispy> I think cabal is picking the wrong version of base
14:06:45 <Kruppe> I put this ant swarm based routing algorithm together in haskell and when I run it it consumes TONS of memory, it looks to me like things arn't being garbage collected. Is there a good way of figuring out exactly whats going on?
14:07:20 <mreh> Kruppe: have you tried profiling?
14:07:53 <Kruppe> mreh: yeah, the memory consumtion just sorta marches from the bottom left to the top right of the graph
14:08:10 <Kruppe> mreh: it never dips, which is why i was thinking no GC
14:08:18 <mreh> Kruppe: have you checked the memory consumption profiles of the individual functions?
14:08:37 <Kruppe> mreh: do you mean the -hy RTS option?
14:08:50 <Kruppe> mreh: errr
14:08:53 <mreh> Kruppe: +RTS -p
14:09:05 <Kruppe> mreh: yeah ive used that one
14:09:08 <mreh> compile with --make -auto-all -prof
14:09:14 <mreh> ?
14:09:28 <Kruppe> mreh: that one helped me figure out my random number generation was causing some serious problems
14:09:34 <Kruppe> mreh: in terms of memory
14:09:47 <Kruppe> mreh: after that there are two functions that take up most of it
14:10:01 <Kruppe> mreh: but it doesn't make sense to me why they would consume so much
14:10:17 <mreh> Kruppe: well I can't offer anything else other than looking at the code
14:10:27 <mreh> has it ever completed the algorithm?
14:10:33 <Kruppe> mreh: oh yeah
14:10:44 <Kruppe> mreh: it gets results that i would expect infact
14:10:48 <mreh> Kruppe: what algorithms are you using? sorting?
14:11:09 <Kruppe> mreh: mostly foldM i guess
14:11:22 <Kruppe> mreh: im using StateT and IO
14:11:24 <mreh> haven't done swarm intelligence in my classes yet, I'm unfamiliar with ant colony
14:11:43 <mreh> Kruppe: nothing prefixed with unsafe I hope
14:11:46 <Kruppe> mreh: well pretty much I have a list of ants that move around the network and change routing tables at each nodes
14:11:51 <dolio> @tell ski That (your example) isn't really what incoherent instances do. It's just the weirdness of overlapping instances.
14:11:51 <Kruppe> mreh: nope nothing like that
14:11:51 <lambdabot> Consider it noted.
14:12:07 <mreh> Kruppe: the one where the lay pheromone trails :)
14:12:14 <Kruppe> mreh: correct
14:12:18 <Kruppe> mreh: via probabilities
14:12:20 <amxx> > System.Cmd.system "cat /etc/passwd | wc"
14:12:21 <lambdabot>   Not in scope: `System.Cmd.system'
14:12:26 <amxx> :(
14:12:33 <Kruppe> mreh: its the ABC routing algorithm by....
14:12:41 <Kruppe> mreh: lemmie look up his name lol
14:13:04 <Cale> monochrom: It should always do that though, not just inside a do-block.
14:13:29 <Cale> (not that it's required, but stylistically, it's nicer)
14:13:31 <Kruppe> mreh: Schoonderwoerd et al
14:13:44 <mreh> @paste
14:13:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:13:49 <mreh> Kruppe: paste it
14:15:15 <Kruppe> mreh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8113#a8113
14:15:34 <Kruppe> mreh: Its my first real big haskell program, so tips are welcome
14:15:58 <mreh> Kruppe: long module :)
14:16:02 <Kruppe> mreh: the rest of the stuff is just wrappers for IntMaps mostly
14:16:07 <Kruppe> mreh: thats imported
14:16:21 <pastorn> Kruppe: what is this? neural nets?
14:16:23 <mreh> abstraction abstraction abstraction
14:16:24 <lispy> It seems that as cabal changes its dependency resolution some packages will build with one version but not another :(
14:16:26 <Kruppe> mreh: If i get it working well it will be split up a little more :)
14:16:30 <lispy> (version of cabal that is)
14:16:34 <Kruppe> pastorn: Swarm intelligence
14:16:41 <ddarius> lispy: Shouldn't the latest essentially be the end?
14:16:52 <pastorn> Kruppe: so if you would give the main function a meta-type signature, what would it be?
14:17:08 <Kruppe> pastorn: uhh meta type signature?
14:17:14 <lispy> ddarius: latest what cabal?  end of who?  Sorry, not sure what you mean
14:17:21 <mreh> oooh, I'm going to do my ant colony algorithm in FRP :D
14:17:32 <sinelaw> mreh, Yampa?
14:17:32 <mreh> Kruppe: point me to the functions that are bad
14:17:46 <mreh> sinelaw: yes
14:17:48 <pastorn> Kruppe: dijkstra :: WeighedGraph -> StartNode -> EndNode -> [(Path,Time)]
14:17:57 * hackagebot upload: pcre-light 0.3.1.1 - A small, efficient and portable regex library for Perl 5 compatible regular expressions (DonaldStewart)
14:17:58 <sinelaw> cause i'm a little disappointed at it
14:18:15 <mreh> sinelaw: how so
14:18:23 <sinelaw> mreh, unclear semantics
14:18:32 <sinelaw> and messy library
14:18:47 <Kruppe> mreh: updateTables and setupAntCalls
14:18:47 <mreh> sinelaw: the library is a disaster :)
14:19:07 <mreh> Kruppe: are they independent?
14:19:16 <sinelaw> mreh, if i knew what semantics it gives, it'd be much worse
14:19:21 <sinelaw> i'm mean much BETTER
14:19:32 <Kruppe> mreh: they can be run without eachother if thats what you mean
14:19:34 <mreh> sinelaw: I don't know what you mean
14:19:37 <lispy> ddarius: what I was struggling with is that the cabal-install that was installed was failing to build something but after I upgraded cabal-install the package built correctly.
14:19:52 <ddarius> lispy: The latest version of cabal install should have a dependency algorithm that can not be improved upon in results.
14:20:03 <noggle> :t map
14:20:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:20:14 <noggle> :t foldr
14:20:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:21:06 <sinelaw> mreh, for example, when does the library update things and when does it not (if i send a Yampa.NoEvent, does it pass it to the rest of the SFs? If I pass that same thing and it goes into a tuple with something else, what happens? what about non-events grouped with events? etc...)
14:21:27 <sinelaw> battery running out
14:21:37 <monochrom> hahaha haskell-mode binds something to "C-M-S-mouse-3". How do you even press that? :)
14:21:38 <mreh> sinelaw: with parallel switching?
14:21:54 <sinelaw> it's just complicated
14:21:57 <mreh> sinelaw: have you read the "Yampa arcade" paper?
14:22:02 <sinelaw> mreh, yeah
14:22:20 <sinelaw> i've read a whole bunch and nowhere are precise semantics defined
14:23:08 <mreh> sinelaw: I think it needs tidying up, but my intuition is that the semantics are there
14:23:29 <Phyx-> anyone here got one of those addictive flash games? I need a distraction :P
14:23:32 <sinelaw> mreh, I also feel that the semantics  CAN be defined, but they aren't
14:23:35 <chrissbx> ghci can't find my own modules in import statemtnes when I run it from Emacs haskell mode; symlinking my directories into ~/.cabal/ helps, but is there a better way?
14:23:43 <sinelaw> Phyx-, blonics
14:23:50 <sinelaw> or something like that
14:24:07 <mm_freak> monochrom: using haskell-indent instead of haskell-indenting, i can easily cycle between the various indentation levels using the tab key
14:24:10 <Phyx-> wow, googling for that gives the most random results
14:24:17 <mm_freak> this doesn work with haskell-indenting anymoreâ¦  any idea?
14:24:20 <sinelaw> mreh, so we need a modern FRP framework that really works. maybe you wanna check out elerea
14:24:28 <Phyx-> sinelaw: blosics?
14:24:36 <sinelaw> Phyx-, yes
14:24:42 <mreh> Kruppe: you really need to annotate your top level functions with types
14:24:45 <monochrom> mm_freak: tab still cycles. The new algorithm offers fewer choices.
14:24:47 <mreh> Kruppe: I can't read it
14:24:53 <c_wraith> Is there anything like vacuumLazy that shows what's being kept in closures by the unevaluated thunks?
14:24:57 <Phyx-> sinelaw: oooh looks fun, thanks
14:25:00 <sinelaw> Kruppe, and compile with -Wall
14:25:09 <sinelaw> Phyx-, hopelessly addictive though
14:25:19 <Kruppe> mreh: thanks for trying :(
14:25:41 <mm_freak> monochrom: again my failureâ¦  haskell-indenting knows that something must follow a 'do' =)
14:25:43 <mreh> sinelaw: does it have a nice mental model like yampa?
14:25:47 <Hunner> How would I go about doing something like `tee` in haskell? (Taking the monadic return of one function and feeding it to two functions)
14:25:51 <sinelaw> Kruppe, compile with -Wall, and when you're done cleaning up so that there are no warnings, try asking again
14:26:12 <sinelaw> mreh, i have no idea, that's why i suggest you check it out :) maybe you can tell me then
14:26:26 <mm_freak> Hunner: c1 >>= \x -> c2 >> c3
14:26:29 <mreh> sinelaw: I'll put it at the bottom of the list :)
14:26:31 <sinelaw> Yampa's mental model is not nice, it's only nice on the intuitive level. the details are very messy
14:26:34 <monochrom> mm_freak: Also somewhat different set of choices. Actually I find myself liking the new choices regarding e.g. do f <newline> (\x -> <newline> do y ...
14:26:36 <Hunner> thanks
14:26:52 <sinelaw> mreh, elerea DOES work, though, as that DoW game shows.
14:26:57 <sinelaw> which is very promising
14:26:58 <mm_freak> Hunner: or in do-notation:  do x <- c1; c2; c3
14:26:59 <Kruppe> sinelaw: alright ill give it a shot
14:27:04 <mm_freak> uhm
14:27:08 <mm_freak> Hunner: or in do-notation:  do x <- c1; c2 x; c3 x
14:27:32 <mm_freak> monochrom: it autoindents after the return key, which is a bit confusing
14:27:44 <mreh> sinelaw: we've got Frag in yampa too
14:27:45 <mm_freak> monochrom: i'm used to emacs starting at column 0
14:27:55 <mreh> it is possible
14:27:56 <sinelaw> mreh, also yairchu has a framework that works, peakachu
14:28:11 <FliPPeh> > map (negate . abs) [1..20]
14:28:13 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20]
14:28:15 <FliPPeh> :x
14:28:41 <sinelaw> mreh, yes, but it's very complicated, and was written back in the day that Yampa was still being actively developed and supported
14:28:56 <sinelaw> elerea is new, that DoW game was published last week
14:29:05 <monochrom> mm_freak: In the days I wrote in Java, I was used to autoindent at return. Err actually autoindent at a "linefeed" key, which sun sparc keyboards had at school.
14:29:06 <sinelaw> it may be less comprehensive
14:37:17 <abbe> Hi everyone
14:39:09 <abbe> Is it possible to write do { get;  put } statements in (get >>= put) form as mentioned in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22975#a22975
14:41:22 <doserj> abbe: there is modify, but you need to define a function for the record update
14:42:13 <abbe> doserj: thanks, let me try that :)
14:43:54 <MaciejP> What's a simple way to store a list of Class => c values?
14:44:05 <MissPiggy> MaciejP are they different classes?
14:44:07 <MissPiggy> err
14:44:11 <MissPiggy> I mean different instances of the class?
14:44:14 <MaciejP> Yes
14:44:29 <MissPiggy> in that case I think I would use a GADT
14:44:30 <MissPiggy> like
14:44:47 <MissPiggy> data Contain where Thing :: Class => c -> Contain
14:44:56 <MissPiggy> so it would be [Contain]
14:45:07 <MissPiggy> but I think [forall c. Class => c] also works
14:45:46 <MaciejP> Ok, I will try the GADT variant
14:46:59 <Saizan> [forall c. Class => c] is a different type
14:47:22 <FliPPeh> > readFile "EXCEPTION"
14:47:23 <lambdabot>   <IO [Char]>
14:47:28 <FliPPeh> What!
14:47:46 <Saizan> lambdabot doesn't execute actions, it just shows them
14:47:54 <FliPPeh> oh yeah right, I remember
14:47:55 <MissPiggy> Saizan oh differenthow?
14:48:03 <MissPiggy> just one instance?
14:48:09 <FliPPeh> > ioError "Error :)"
14:48:10 <lambdabot>   Couldn't match expected type `GHC.IOBase.IOException'
14:48:10 <lambdabot>         against infer...
14:48:15 <Saizan> MissPiggy: it's a list of polymorphic values
14:48:22 <MissPiggy> okay
14:48:33 <FliPPeh> I wonder, does lambdabot just call GHCI with some restrictions?
14:49:07 <Saizan> it uses mueval, which uses hint, which uses the ghc-api, which is the same thing ghci uses
14:49:20 <FliPPeh> Alright
14:51:52 <abbe> doserj: any ideas about the error in this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22975#a22976
14:52:17 <monochrom> Hahaha *.net *.split
14:52:24 <enthymene> woo
14:52:27 <enthymene> what a ride, huh?
14:53:13 <doserj> abbe: not get >>= modify f, just modify f
14:53:17 <Megant> abbe: modify directly modifies the state, you don't need get
14:53:49 <doserj> modify f = do s <- get ; put (f s)
14:54:29 <abbe> okay
14:56:43 <doserj> btw, I typically write 'f <$> m' instead of 'm >>= return . f'
14:59:29 <doserj> also, putStrLn . show is called print
14:59:51 <FliPPeh> @src print
14:59:51 <lambdabot> print x = putStrLn (show x)
14:59:56 <abbe> OKay, I'm confused a bit, the signatures of 'modify' and 'put' look similar, (s -> s) -> m (), s -> m ()
14:59:56 <FliPPeh> Oh god
15:00:00 <FliPPeh> Not point free!
15:00:14 <FliPPeh> @pl print x = putStrLn (show x)
15:00:15 <lambdabot> print = putStrLn . show
15:00:29 <Cale> Another option in place of m >>= return . f is fmap f m
15:01:03 <Cale> In general if the right hand side of >>= is a composite, I tend to flip it over as well: f . g =<< x  makes more sense than x >>= f . g
15:01:39 <mreh> Cale: unless you use arrows
15:01:50 <Twey> x >>= f >>> g
15:01:58 <mreh> yay
15:05:14 <Hunner> How can I un-inline ++?
15:05:24 <FliPPeh> Erm...
15:05:27 <damd> heh
15:05:27 <mreh> (++)
15:05:39 <FliPPeh> > (++) "Hello " "world"
15:05:41 <lambdabot>   "Hello world"
15:05:41 <mreh> if you meant "infix"
15:05:56 <Hunner> :t putStrLn (++) "Given: "
15:05:57 <mreh> i'm not sure what "in-line" means
15:05:57 <lambdabot>     Couldn't match expected type `String'
15:05:58 <lambdabot>            against inferred type `m -> m -> m'
15:05:58 <lambdabot>     In the first argument of `putStrLn', namely `(++)'
15:06:02 <abbe> thanks guys :)
15:06:38 <Hunner> :t putStrLn . (++) "Given: "
15:06:39 <lambdabot> String -> IO ()
15:07:13 <abbe> doserj: where is this operator ('<$>') defined ?
15:07:20 <damd> Control.Applicative
15:07:28 <damd> @hoogle (<$>)
15:07:28 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
15:07:29 <FliPPeh> let b = putStrLn . (++) "Given: " in b "Hello"
15:07:35 <FliPPeh> > let b = putStrLn . (++) "Given: " in b "Hello"
15:07:36 <lambdabot>   <IO ()>
15:08:03 <abbe> thanks damd
15:09:29 <Someoneigna_> haskell is better as a script language , or used to aplication programing?
15:09:39 <damd> troll detected
15:09:48 <FliPPeh> let b = flip (++) "!" in b "Hello"
15:09:51 <FliPPeh> > let b = flip (++) "!" in b "Hello"
15:09:52 <lambdabot>   "Hello!"
15:09:57 <FliPPeh> :)
15:10:52 <FliPPeh> :t take
15:10:53 <lambdabot> forall a. Int -> [a] -> [a]
15:10:58 <FliPPeh> :t flip take
15:11:00 <lambdabot> forall a. [a] -> Int -> [a]
15:11:48 <FliPPeh> > flip take [1..] 4
15:11:50 <lambdabot>   [1,2,3,4]
15:11:55 <abbe> Is there any way to generate setter functions (for updating records) to be used with 'modify' function ?
15:12:27 <dschoepe> abbe: http://hackage.haskell.org/package/data-accessor
15:12:31 <FliPPeh> @src flip
15:12:31 <lambdabot> flip f x y = f y x
15:13:10 <dschoepe> abbe: and, for more convenience: http://hackage.haskell.org/package/data-accessor-template
15:13:18 <abbe> thanks dschoepe :)
15:13:36 <abbe> I'm feeling the moment of enlightenment...
15:14:15 <FliPPeh> > uncurry take (4, [1..5])
15:14:17 <lambdabot>   [1,2,3,4]
15:14:25 <FliPPeh> What's uncurry used for?
15:14:57 <c_wraith> :t uncurry (==)
15:14:59 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
15:15:14 <c_wraith> It's used for that sort of thing
15:15:51 <FliPPeh> :/
15:16:10 <FliPPeh> The only "useful" thing I can imagine using it for right know is testing both parts of a tuple for equalizy
15:16:13 <FliPPeh> equality
15:16:19 <FliPPeh> > uncurry (==) (1,4)
15:16:20 <lambdabot>   False
15:16:22 <FliPPeh> > uncurry (==) (4,4)
15:16:23 <lambdabot>   True
15:17:08 <c_wraith> :t uncurry (.)
15:17:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b, f a) -> f b
15:17:22 <abbe> Is Control.Category.Category class is implemented by all haskell types ?
15:17:32 <abbe> s/ss is/ss/
15:18:33 <doserj> why would you thinkg that? the only standard instance is (->)
15:19:04 <doserj> (and Kleisli)
15:20:01 <abbe> doserj: hmm..., (->) ?
15:20:32 <doserj> the function type constructor
15:20:59 <copumpkin> :k (->)
15:21:00 <lambdabot> ?? -> ? -> *
15:21:25 <abbe> doserj: it is meta object ?
15:21:56 <doserj> instance Category (->) where id = Prelude.id; (.) = (Prelude..)
15:21:58 <copumpkin> it's a type constructor like Either
15:22:25 <copumpkin> it's a little bit special but not too magic
15:23:16 <abbe> okay
15:23:34 * abbe backtracks.
15:24:08 <endojelly> btw, what is the difference between ??, ? and *? I almost always see *
15:24:09 <FliPPeh> @src const
15:24:09 <lambdabot> const x _ = x
15:24:34 <endojelly> i.e., why is the kind of (->) not just * -> * -> *?
15:24:37 <FliPPeh> > const "Hey!" 0xC0FFEE
15:24:38 <lambdabot>   "Hey!"
15:25:01 <Saizan> endojelly: ?? -> ? -> * is ghc specific to deal with unboxing
15:25:23 <copumpkin> ?? and ? are superkinds of *
15:25:23 <lambdabot> Plugin `compose' failed with: Unknown command: ""
15:25:36 <FliPPeh> @src seq
15:25:37 <lambdabot> Source not found.
15:25:38 <endojelly> Saizan, with unboxing?
15:26:06 <endojelly> copumpkin, superkinds?
15:26:15 <doserj> ? is * + unboxed values, ?? is ? + unboxed tuples, I think
15:26:35 <copumpkin> vice versa
15:27:14 <endojelly> are there other examples for the use of ? and ??, or is it just for (->)?
15:27:26 <copumpkin> it's used in low-level things
15:27:30 <copumpkin> most of the time you never notice
15:27:44 <endojelly> so it's more a thing of Core?
15:27:51 <copumpkin> pretty close to it
15:27:58 <Saizan> ghc primitives anyway
15:27:58 <copumpkin> @src Int
15:27:58 <lambdabot> data Int = I# Int#
15:28:00 <endojelly> I encounter a lot of unboxed values when reading Core code
15:28:04 <copumpkin> that Int# there is of kind #
15:28:21 <endojelly> aaah, unboxed values have kind # instead of *, didn't know that
15:28:32 <endojelly> so ? ist # or *
15:28:35 <endojelly> -t
15:28:38 <copumpkin> or (#)
15:28:48 <copumpkin> (unboxed tuples)
15:28:52 <doserj> ?? is # or *, copumpkin was right
15:28:53 <lambdabot>  is # or *, copumpkin was right
15:28:59 <copumpkin> :)
15:29:28 <endojelly> okay, yeah, makes more sense anyway when (->) has kind ?? -> ? -> *
15:29:40 <doserj> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
15:29:51 <copumpkin> it just means that you can return unboxed tuples from a function but you can't pass them in, really
15:30:09 <copumpkin> I'm not really sure what the rationale is behind disallowing them for input
15:30:19 <dolio> They aren't necessary.
15:30:23 <copumpkin> yeah, but still
15:30:24 <dankna> So.  I have a question. :)
15:30:34 <dankna> I want to have instances Serializable Int and also (Enum a) => Serializable a
15:30:35 <dolio> I'm pretty sure that's the only rationale.
15:30:41 <dankna> but I can't, because there is an instance Enum Int
15:30:58 <dankna> so the compiler, reasonably enough, isn't sure which of my instances to use for Int
15:31:03 <copumpkin> yep, and that general one you wrote is painful
15:31:26 <copumpkin> as in, it's _awfully general_
15:31:30 <dankna> mine?
15:31:36 <copumpkin> (Enum a) => Serializable a
15:31:38 <copumpkin> that
15:31:39 <dolio> Possibly having them only available for return is easier. You don't have to make them completely first-class.
15:31:44 <dankna> yeah, it is awfully general
15:31:49 <copumpkin> dolio: I see
15:31:54 <dankna> I thought that was a good thing :)
15:32:00 <copumpkin> dankna: it's only a step away from instance Serializable a
15:32:04 <dankna> well, yeah
15:32:05 <dolio> And since they aren't necessary except for return...
15:32:12 <dankna> I'm certainly willing to restructure my thing
15:32:26 <dankna> if you have a good workaround.  I basically just have a few types that derive Enum that I want to serialize.
15:32:43 <copumpkin> newtype Zomg a = Zomg a
15:32:47 <dankna> lol
15:32:48 <Saizan> make explicit instances.
15:32:49 <copumpkin> instance Enum a => Serializable (Zomg a)
15:32:58 <mm_freak> does anyone know an implementation of the gamma function in haskell?
15:33:07 <mm_freak> it's the generalization of the factorial function
15:33:13 <copumpkin> mm_freak: if anywhere, I'd expect to find it in haskell for maths
15:33:19 <dankna> and I would then call that by using the Zomg constructor
15:33:21 <dankna> I see
15:33:38 <dankna> okay, I think that'll work for me.  thanks :)
15:33:43 <dolio> Are there good ways to implement it specifically? Or just numerical approximation?
15:33:54 <Kruppe> mreh: Wanna try taking another look? I got rid of the warnings in -Wall and added a few comments.
15:34:09 <copumpkin> can't find it in hfm
15:34:14 <copumpkin> seems mostly discrete stuff
15:34:22 <copumpkin> btw, I hate the new haddock index format
15:34:31 <copumpkin> I liked to have all symbols on a page for easy searching
15:34:39 <mm_freak> dolio: are you talking about gamma?
15:34:49 <mm_freak> well, i need only a special case of it
15:34:55 <mm_freak> namely over the reals
15:35:01 <mm_freak> an approximation would suffice
15:35:07 <copumpkin> http://www.haskell.org/haskellwiki/Gamma_and_Beta_function
15:35:11 <mreh> Kruppe: did you annotate all the top level functions atleast?
15:35:52 <copumpkin> mm_freak: it's in statistics, strangely enough: http://hackage.haskell.org/packages/archive/statistics/0.4.1/doc/html/Statistics-Math.html#v%3AlogGamma
15:36:09 <mm_freak> ah, that helps
15:36:10 <mm_freak> thanks
15:36:23 <Kruppe> mreh: probably not enough detail, ill keep working at it on second thought
15:42:19 <gwern> argh. 'sleep' in javascript is so hard!
15:42:21 <gwern> wtf
15:42:44 <gwern> I've spent at least 2 hours trying to modify a little bit of js http://en.wikipedia.org/wiki/User:Gwern/nostalgia.js
15:43:58 <c_wraith> well, yes.  you're not supposed to sleep in JS, since that blocks all JS execution on that page
15:44:13 <c_wraith> You're supposed to setTimeout with the rest of your function
15:44:19 <gwern> setTimeout sucks too
15:44:49 <gwern> I've played with the millisecond parameter, and either every call occurs nigh simultaneously, defeating the point, or it only runs 8 times!
15:45:19 <c_wraith> eh?  are you doing something timer-driven?
15:45:44 <gwern> you can see the setTimeout yourself
15:46:24 <c_wraith> Oh.  That's a strange way to use setTimeout
15:47:33 <gwern> c_wraith: I'd put a sleep() call in before every open.window call if there were a sleep() !@!#$ that didn't loop the browser and prevent the previous open.windows from making progress
15:47:58 <c_wraith> so what you really want to do is open a list of windows sequentially?
15:48:48 <gwern> no, I want to open them with a delay between each opening
15:49:03 <gwern> when you open 200 wikipedia tabs, no delay = browser crash or tabs failing
15:49:13 <c_wraith> Um.  That sounds like the same thing to me
15:49:51 <c_wraith> You want to open them sequentially, with a delay between each.
15:50:02 <dankna> (at this point I have to mention that browsers aren't really intended to have 200 tabs open at once, nor is your brain intended to read them all!)
15:50:17 <gwern> c_wraith: the loop with open.window opens them all in a few seconds, obviosuly
15:50:44 <c_wraith> The typical use of setTimeout for something like that is building a timer that periodically fires using setTimeout, then performing your action (opening the next tab, in this case) on each timer fire
15:51:00 <gwern> dankna: I have 4 gigs, so it damn well better be able to handle a measly few hundred tabs; and it's easy to go through that many diffs since most edits are good
15:51:15 <dankna> hmmmm okay, I see your use-case now
15:51:20 <dankna> that seems at least halfway reasonable then
15:51:54 <c_wraith> You could try doing it from a single loop if you increment the timeout each time, instead of using the random in a range you current do
15:52:14 <c_wraith> But the browser is almost certain to be better behaved with only one timeout pending at a time
15:52:41 <gwern> c_wraith: I tried just using the loop index, n, as the timeout arg; but that had the same issue
15:52:58 <c_wraith> yeah, you run into scheduling issues
15:53:04 <gwern> (as did n+500, eg.)
15:53:05 <c_wraith> as things slow down, and timers start firing late
15:53:17 <c_wraith> and they start overlapping
15:53:34 <c_wraith> hence it's better behaved if your first timeout sets the next one
15:53:39 <c_wraith> so that they can never stack up
15:53:52 <gwern> (I found a firefox sleep which supposedly was efficient, but it required permissions in some way and always failed)
15:54:05 <gwern> c_wraith: I don't see how that would work in the loop
15:54:14 <c_wraith> gwern: you'd have to replace the loop
15:54:44 <c_wraith> use the loop to generate the list of windows to open instead, then use a timer to open them
15:55:41 <c_wraith> I know, doing event-based programming manually sucks after you get used to not having to.  ;)
15:55:59 <gwern> my kingdom for a sleep()!
15:56:39 <gwern> also, firefox is a bad javascript ide
15:57:03 <benmachine> everything is terrible
15:57:17 <c_wraith> firebug is a decent debugger.  It's saved me before.
15:57:20 <damd> WPF is actually pretty decent for "event-based programming".  largely declarative.
15:57:35 <MaciejP> How can I fix this rigid type variable problem? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22978
15:58:21 <nus> gwern, ever tried treestyletab?
15:58:36 <gwern> nus: since I don't know javascript, assume no
15:59:00 <nus> gwern, that's an add-on.
15:59:10 <nus> for firefox, that is.
15:59:57 <Saizan> MaciejP: well, actually can't there, because there's no guarantee that the 'p' in the type of f is the same as the 'p' wrapped in the IParam constructor
16:00:19 <Berengal> gwern: var links = array; var i = 0;function linkloop(){if (i < links.length){window.open(links[i]); i++; setTimeout(linkloop, 1000);}}; setTimeout(linkloop, 1000);
16:00:19 <lambdabot> Berengal: You have 1 new message. '/msg lambdabot @messages' to read it.
16:00:34 <gwern> Berengal! prince among men!
16:00:40 <Kruppe> mreh: Alright, all the ant, stuff is annotated now, the methods that were taking up all that heap space were all ant functions anyways http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=8113#a8115
16:00:44 <Berengal> gwern: Might need tweaking
16:00:48 <MaciejP> Saizan: So how can I garantee this?
16:01:53 <mreh> Kruppe: okay
16:02:15 <gwern> Berengal: but wait, how do I populate the array 'links'?
16:02:26 <Berengal> gwern: I don't know. They're your links...
16:02:44 <Saizan> MaciejP: what are you really trying to do here?
16:02:51 <Kruppe> mreh: if it's still too cryptic let me know, ill clean it up further and ask another time
16:04:53 <Berengal> gwern: I assume the function addAdahLinks does some link extracting?
16:05:01 <copumpkin> http://twitter.com/bos31337/status/9599572390
16:05:09 <gwern> Berengal: I linked the source
16:05:30 <MaciejP> Saizan: I read a function application form file, like "f p1 p2 p3" and in the Haskell code want to register a handler for f.
16:05:41 <gwern> copumpkin: an easy mistake. I do that all the time
16:05:45 * copumpkin contemplates @remembering bos I read something about the sweet taste of buggery, but he probably shouldn't
16:05:59 <ivanm> copumpkin: where's this from?
16:06:00 <copumpkin> gwern: yeah
16:06:00 <Berengal> gwern: Yes, I'm reading it. I'm just no javascript monkey myself, so it takes some time
16:06:10 <copumpkin> ivanm: see if you can guess from the domain
16:06:36 <ivanm> duh, missed your twitter URL post above
16:06:42 <copumpkin> :)
16:06:43 * ivanm is trying out a new IRC client
16:07:17 <ivanm> copumpkin: then see mwotton's response to that...
16:07:32 <copumpkin> :)
16:07:36 <bos> you know what? if it's tweeted, @remembering it won't do any further harm.
16:07:46 <bos> talk about going down on your permanent record.
16:07:54 <copumpkin> blackdog: enjoy the butter
16:08:08 <gwern> @quote bugg
16:08:08 <copumpkin> bos: at least the tweet has context though :)
16:08:08 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
16:08:08 <lambdabot> useful for functional code
16:08:26 * copumpkin now sees the word debugger in a whole new light
16:08:30 <ivanm> heh
16:08:45 <gwern> copumpkin: well, someone has to bugger things so that they may be *de*bugged
16:08:52 <copumpkin> true that
16:09:11 <gwern> programmers bugger a lot of things
16:09:33 <Berengal> benmachine: Your destructList is indeed neater. It's easily total, which mine wasn't, which is good
16:10:23 <gwern> @wn bugger
16:10:24 <lambdabot> *** "bugger" wn "WordNet (r) 2.0"
16:10:24 <lambdabot> bugger
16:10:24 <lambdabot>      n : someone who engages in anal copulation (especially a male
16:10:24 <lambdabot>          who engages in anal copulation with another male) [syn: {sodomite},
16:10:24 <lambdabot>           {sodomist}, {sod}]
16:10:26 <lambdabot>      v : practice anal sex upon [syn: {sodomize}, {sodomise}]
16:10:30 <Saizan> MaciejP: i think i'd use Data.Dynamic for that
16:10:43 <copumpkin> this is clearly #haskell material
16:11:01 <gwern> huh. 'sod' is a synonym of sodomite?
16:11:08 <gwern> that makes sense yet I never noticed
16:13:57 <MaciejP> Saizan: Isn't that a way to define f :: a -> b?
16:14:52 <MaciejP> @type fromDyn . toDyn
16:14:54 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a1 -> a -> a
16:17:12 <MissPiggy> :t (fromDyn,toDyn)
16:17:13 <lambdabot> forall a a1. (Typeable a, Typeable a1) => (Dynamic -> a -> a, a1 -> Dynamic)
16:17:39 <gwern> 'Dick Cheney has fifth heart attack, only two horcruxes remaining.'
16:17:39 <Saizan> MaciejP: Data.Dynamic is also an easy way to have heterogeneous collections
16:18:39 <lament> gwern: haha
16:18:42 <Saizan> it's easy to write appN :: Dynamic -> [Dynamic] -> Maybe Dynamic
16:19:04 <MaciejP> Saizan: Ok, I'll try it with Dynamic.
16:22:10 <Kruppe> mreh: If you've had a chance to look at it, anything obvious I could be doing better?
16:22:28 <noggle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22979#a22979
16:22:35 <noggle> type problems!
16:22:41 <noggle> because I am a noob!
16:22:47 <mreh> Kruppe: sorry, I've been nodding off, I need to catch some Zs
16:23:41 <abbe> Is it find to implement traditional 'Plugin' class (from imperative programming world) as a 'class' (in Haskell) ? The 'Plugin' class has several functions which it expects various modules to implement.
16:23:49 <Saizan> noggle: annotate with the errors.
16:24:00 <Kruppe> mreh: sall good, go ahead and catch some Zs then, I gotta head out anyways :)
16:24:09 <Kruppe> mreh: thanks for your help anyways
16:24:14 <Saizan> noggle: oh, you miss an argument to isFstMatch on line 19
16:24:20 <mreh> I'm not sure I did much :)
16:24:23 <ddarius> abbe: Does it make sense to associate a "plugin" with a particular type and only have one "plugin" per type?
16:24:36 <Kruppe> mreh: eh, you tried, better than nothing
16:24:53 <noggle> oh jesus lol
16:24:56 <noggle> hahaha
16:26:58 <abbe> ddarius: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22980#a22980
16:27:21 <MaciejP> Saizan: It works! But is it "good style" to use it? :-)
16:27:27 <ddarius> abbe: That's not an answer to my question.
16:27:36 <abbe> ddarius: i'm trying to write a webserver in haskell, and i'm planning to plugin multiple handlers.
16:28:00 <abbe> ddarius: I didn't understand your reply actually, can you elaborate it ?
16:28:27 <abbe> ddarius: I want all those 4 functions to be implemented by various handlers.
16:29:13 <ddarius> abbe: And why do you want each handler to be a different type?
16:29:16 <Saizan> MaciejP: since you're parsing dynamically from a file it's not bad imo
16:29:18 <abbe> ddarius: and I'm new in FP world, so I'm confused what is the best approach
16:29:47 <FCo> I have some code with the State monad, that produces a weird error message about "When using functional dependencies to combine
16:29:47 <FCo>       MonadState s (State s)" I have the code and the message at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22981#a22981, does someone have a clue on the cause?
16:30:55 <abbe> ddarius: I basically wanted something like that. And I'm not sure if thats the best way.
16:31:57 <ddarius> abbe: Well that's not an answer to my second question.
16:31:59 <Saizan> FCo: it means you're trying to put a value of the wrong type
16:32:24 <Saizan> FCo: "put $ buildEvalEnv declarations" <- here you're putting the whole "buildEvalEnv declarations" action
16:34:17 <abbe> ddarius: Because I thought this is a way to declare an interface/specification with several functions which one needs to be implement to be compliant to that interface.
16:35:00 <FCo> Saizan: thx! let me try it!
16:35:29 <ddarius> abbe: Apparently me asking you questions is pointless and I'm about to leave anyway.  So I'll leave you with this: consider the type of a putative function that will search for plugins in a directory, say, and return the ones it finds.
16:36:15 <FCo> Saizan, you are awesome!
16:36:16 <abbe> ddarius: okay, but those plugins need to implement some interface, right ?
16:36:18 <doserj> abbe: thought about sth like: data Handler = Handler { doGet:: SomeType, doPost:: SomeType, ...}
16:36:42 <thetallguy1> Is it possible to split mutually recursive data structures across modules?
16:37:21 <abbe> doserj: yes, but I was confused whether thats the recommend way to implement such thing.
16:38:52 <doserj> thetallguy: in theory, yes. in ghc practice, not really. see http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html, section 4.6.9
16:40:29 <thetallguy1> doserj: thanks, I just found that.  Not sure how I missed it before.
16:40:34 <domor> anyone using Scripting.Lua?
16:41:42 <Saizan> abbe: you use typeclasses for type-directed overloading, to abstract things out a record of functions is fine and can be more versatile
16:42:42 <abbe> Like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22980#a22982
16:43:03 <Saizan> abbe: right
16:43:21 <abbe> Sorry for the typo.
16:43:28 <abbe> thanks Saizan doserj ddarius :)
16:44:56 <Hunner> is String of type m a? (since list is a monad, and String is just [Char])
16:45:19 <Saizan> yes
16:45:51 <Saizan> well, in the sense that Monad m => m a can be specialized to String
16:46:35 <Saizan> > "foo" >>= \c -> [toUpper c, c]
16:46:36 <lambdabot>   "FfOoOo"
16:46:38 <theorbtwo> @hoogle unsafePerformIO
16:46:38 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:46:38 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
16:46:56 <Dr_Decker> i think string is a type rather than newtype or data
16:47:04 <Dr_Decker> so its not a monad
16:47:25 <Saizan> for the typechecker String and [Char] are the same thing
16:47:34 <Saizan> [] is a monad
16:47:43 <Dr_Decker> ok, i think i'm getting it
16:47:46 <theorbtwo> That is... unfortunate.
16:47:53 <theorbtwo> IMO, anyway.
16:48:09 <RayNbow> > join . mapM (\c -> [toUpper c,c]) $ "foo"
16:48:11 <lambdabot>   "FOOFOoFoOFoofOOfOofoOfoo"
16:48:29 <copumpkin> > mapM (\c -> [toUpper c,c]) $ "foo"
16:48:30 <lambdabot>   ["FOO","FOo","FoO","Foo","fOO","fOo","foO","foo"]
16:48:37 <HugoDaniel2> hi
16:49:00 <byorgey> hi HugoDaniel2
16:49:06 <HugoDaniel2> hi byorgey
16:49:11 <HugoDaniel2> are you going to the hackaton ?
16:49:22 <byorgey> in Zurich?  no, too far away for me
16:50:05 <RayNbow> Zurich is like a 6 hours drive by car from here... (if I take my father's car and drive at max speed through Germany)
16:54:17 <noggle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22983#a22983
16:54:20 <noggle> doh
16:54:22 <noggle> dropWhile
16:54:32 <noggle> sorry if I am bothering you guys
16:55:07 <aavogt> @type span
16:55:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:55:12 <astroboy> I've been to a conference about F# today and it seemed really nice to me... does someone have looked better into it?
16:55:29 <noggle> see you guys later
16:55:32 <gwern> astroboy: what more do you need to know than it's a warmed-over caml really?
16:56:10 <astroboy> gwern: well a language is not just that... support is important as well
16:56:36 <astroboy> I mean I think that it will be way easier to code in F# than in other functional programming languages
16:56:49 <astroboy> for examples the libraries for parallelism seem really nice
16:56:51 <tensorpudding> if you want to interface with C#, absolutely
16:58:13 <astroboy> tensorpudding: they seemed nice C# apart to me
16:58:35 <tensorpudding> F# has the benefits and drawbacks of being tied to .NET
16:59:12 <astroboy> yeah exactly. I don't think I'll ever us it anyway (can't use windows eheh) but I was just asking for opinion
16:59:19 <astroboy> and imho they did a great job anyway
16:59:22 <gwern> well, could work on mono
16:59:23 <tensorpudding> you can run F# through Mono
16:59:29 <astroboy> yeah I know
16:59:46 <tensorpudding> i tried and failed to get it set up, but they'll probably improve that aspect of it as it grows
16:59:48 <ben> Why does nobody ever care for Nemerle? :( It has functional features too!
16:59:55 <astroboy> but I will lose a lot of advantages
17:00:26 <dmwit> I guess people that use it after Haskell get annoyed by the lack of higher kinding.
17:00:34 <astroboy> for example the bindings for the win apis are really good as well
17:00:43 <tensorpudding> mono matters if you want to be cross-platform
17:01:00 <dmwit> For example, you can't do a monad typeclass:
17:01:02 <dmwit> :k Monad m => m
17:01:04 <lambdabot>     `m' is not applied to enough type arguments
17:01:04 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
17:01:05 <theorbtwo> Argh.  I need to get multiple (mostly short) segments out of a file.  I was simply doing hGetContents, and passing that about, but ended getting a stack overflow error... presumably caused by that, because as far as I can tell, there's no way to tell.
17:01:08 <tensorpudding> but if you want to use the win32 api's, you can't be
17:01:14 <astroboy> the microsoft guy said that they will support mono in anyway...
17:01:28 <astroboy> and they already released the compiler source code I think
17:01:34 <dmwit> theorbtwo: hGetContents is unlikely to cause a stack overflow.
17:02:27 <dmwit> theorbtwo: Stack overflows generally happen when you have a deeply-nested thunk that you finally force all at once; for example, from using foldl or scanr instead of foldr, foldl', or scanl.
17:03:11 <theorbtwo> I just tried passing around a Handle instead, and calling hGetContents multiple times, to get multiple, independent, lazy strings, but (a) I can't figure out how to do it without unsafePerformIO, and (b) hGetContents makes the handle half-closed, so you can't do it multiple times to the same handle.
17:03:12 <blackdog> copumpkin: it's everywhere, i can't get it off... i've so far managed to strike out on getting Git and HAML introduced at work. Let's see how i go on suggesting we use Haskell with Hubris... :)
17:03:34 <dmwit> theorbtwo: Yeah, don't do that.
17:03:44 <dmwit> theorbtwo: That's not helpful, and likely is actively hurtful.
17:03:50 <theorbtwo> dmwit: Hm.  I'm not using any sort of fold or scan, at least not explicitly.  I may well have several layers of thunk.
17:04:16 <aavogt> you are using recursion?
17:04:39 <dmwit> ?tell noggle you might also like Data.Split, try ?hackage split
17:04:39 <lambdabot> Consider it noted.
17:04:54 <theorbtwo> aavogt: No.  I'm using parsec's count, which may well do any of the above itself.
17:05:08 <theorbtwo> ...but presumably doesn't do it in a way that is actively bad.
17:05:11 <monochrom> parsec causes the stack overflow.
17:05:13 <aavogt> @type Text.Parsec.count
17:05:14 <lambdabot> forall t s u (m :: * -> *) a. (Text.Parsec.Prim.Stream s m t) => Int -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m [a]
17:05:40 <aavogt> @type replicateM
17:05:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:05:48 <aavogt> is there a difference?
17:07:32 <theorbtwo> Damn.  Should be using version control, if only cp version control...
17:07:38 <monochrom> No difference apart from checking the number for negatives.
17:08:43 <aavogt> > replicateM (-2) (Just 1)
17:08:44 <lambdabot>   Just []
17:09:06 <monochrom> No difference.
17:09:36 <theorbtwo> @src Text.Parsec.count
17:09:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:10:04 <monochrom> count n p = sequence (replicate n p)  (slightly abridged).
17:10:07 <aavogt> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/src/Text-Parsec-Combinator.html#count
17:10:15 <monochrom> @src sequence
17:10:15 <lambdabot> sequence []     = return []
17:10:15 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:10:15 <lambdabot> --OR
17:10:15 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:10:26 <monochrom> can cause stack overflow
17:11:05 <RayNbow> > replicateM (-1) (undefined :: Tree Int)
17:11:06 <lambdabot>   Node {rootLabel = [], subForest = []}
17:12:17 <theorbtwo> Right.  Back to the String version.  Any idea how to do this without causing stack overflows?
17:13:28 <monochrom> n has to be pretty large to cause stack overflow.
17:15:45 <dmwit> theorbtwo: It's almost impossible to give advice like that without seeing the original code.
17:15:50 <aavogt> > fmap (const []) (undefined :: Tree Int)
17:15:51 <lambdabot>   * Exception: Prelude.undefined
17:16:11 * theorbtwo throws about some trace calls ... the count in question seems to be 549696.
17:17:29 <theorbtwo> http://pastie.org/841603 is the code, if you like.  The explosion seems to be at resTableEntry.
17:17:36 <monochrom> > foldl1 (+) [1..600000]
17:17:38 <lambdabot>   * Exception: stack overflow
17:17:52 <monochrom> is large enough to cause stack overflow
17:19:15 <theorbtwo> monochrom: I want to pull out a string of resDataSize bytes.  Is there a better way then count resDataSize anyToken?
17:20:01 <Saizan> you can use a loop with an accumulator
17:20:56 <monochrom> I don't know how much you are willing to step out of parsec.
17:21:27 <Saizan> count' acc 0 p = return acc; count' acc n p = do x <- p; count' (acc . (x:)) (n-1) p
17:21:28 <aavogt> @src replicateM
17:21:28 <lambdabot> replicateM n x = sequence (replicate n x)
17:22:09 <Saizan> count n p = ($[]) <$> count' id n p
17:22:14 * monochrom has a cunning plane
17:22:33 <theorbtwo> If there is a superiour technique for implementing count... why does parsec implement it the way it does?
17:22:48 <dmwit> theorbtwo: Based on the names of things in your source, it looks like you're reading a binary format.
17:23:11 <theorbtwo> I am.
17:23:18 <dmwit> theorbtwo: Generally, Data.Binary is considered superior to Parsec for that task.
17:23:25 <theorbtwo> Hm.
17:23:48 <dmwit> ?hackage binary
17:23:49 <lambdabot> http://hackage.haskell.org/package/binary
17:24:17 <Saizan> (funny that the Binary instance for lists/maps had this same exact problem for quite a while :)
17:25:27 <copumpkin> I thought they fixed it
17:25:29 <monochrom> I am not convinced that building a lot of (acc . (x:)) will not cause a stack overflow.
17:25:53 <c_wraith> It's not often that you cheer when you see your program leaking space all over the place...
17:26:49 <Saizan> > foldl (\acc x -> acc . (x:)) id [1..600000] []
17:26:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:27:02 <dmwit> huh
17:27:03 <c_wraith> so...  It's a call to concatMap that's leaking so badly.
17:27:23 <dmwit> :main in ghci causes a segfault, but runhaskell doesn't.
17:27:23 <monochrom> > let { mee acc 0 = acc; mee acc n = mee (acc . ('x':)) (n-1) } in take 10 (mee id 600000 "")
17:27:24 <Saizan> copumpkin: yeah
17:27:26 <c_wraith> err.  If I understand my profiling results at all
17:27:27 <lambdabot>   "xxxxxxxxxx"
17:27:28 <copumpkin> c_wraith: it's because it's _binding_ the memory ;)
17:27:31 <dmwit> Any idea why?
17:27:41 <monochrom> > let { mee acc 0 = acc; mee acc n = mee (acc . ('x':)) (n-1) } in last (mee id 600000 "")
17:27:44 <lambdabot>   'x'
17:27:57 <Hunner> @hoogle (a -> b) -> m b
17:27:57 <lambdabot> Data.Generics.Aliases GQ :: GenericQ r -> GenericQ' r
17:27:57 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
17:27:57 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
17:28:13 <dmwit> :t Cont
17:28:15 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
17:28:17 <copumpkin> dmwit: not a clue
17:28:22 <dmwit> err
17:28:23 <theorbtwo> Hm.  Binary does look slick... except for one major failing.
17:28:27 <dmwit> Maybe I should paste. =P
17:28:39 <copumpkin> that might indeed help :)
17:28:42 <c_wraith> @src concatMap
17:28:42 <lambdabot> concatMap f = foldr ((++) . f) []
17:29:05 <theorbtwo> I don't see anything speaking to offsets.  In a library that's about parsing text, that's completely understandable.  In one that's supposed to be for parsing binary file formats, it's a major failing.
17:29:35 <copumpkin> pff no binary formats use offsets! silly
17:29:39 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22984#a22984 is the Gtk2Hs hello world program
17:30:08 <dmwit> ...which causes ghci to segfault, but which runhaskell has no problem with.
17:30:12 <copumpkin> dmwit: looks pretty vanilla :) have you tried running it in gdb to see where the segfault comes from?
17:30:14 <dmwit> (as soon as you exit)
17:30:21 <dmwit> Good idea!
17:30:48 <dmwit> argh
17:31:02 <Saizan> all the gui libraries are pretty delicate when used from ghci
17:31:09 <copumpkin> ah
17:31:37 * copumpkin never even writes text UIs (command-line options, etc.), let alone GUIs
17:32:19 <Saizan> maybe :main doesn't get called from the main thread in ghci?
17:32:26 <dmwit> oh
17:32:29 <dmwit> Wouldn't that be nasty?
17:32:40 * Saizan doesn't know
17:32:50 <dmwit> Still, it's just supposed to be true that all calls come from the *same* thread, not necessarily the *main* thread, right?
17:32:53 <Alpounet> copumpkin, haha, I'll create an algebraic UI library so that you'll write UIs
17:32:55 <Alpounet> mouhahaha
17:32:59 <copumpkin> :o
17:33:05 <copumpkin> groups for undo!
17:33:11 * theorbtwo sighs.
17:33:56 <copumpkin> theorbtwo: wut
17:33:57 <dmwit> uh
17:34:26 <dmwit> /usr/lib/ghc-6.12.1/ghc
17:34:29 <dmwit> zsh: segmentation fault
17:34:30 <dmwit> lol
17:34:33 <c_wraith> *sigh*
17:34:36 <theorbtwo> I'm a razor's edge away from deciding that haskell just isn't ready as anything but a toy language, and adding lazyness in to my own (non-haskell) binary file parsing library.
17:34:39 * copumpkin sighs
17:34:53 <copumpkin> theorbtwo: sad, isn't it
17:34:57 <c_wraith> anyone know how to get the *full* trace from the profiler?  I see "ccm/combineText/bareT..."
17:35:09 <c_wraith> I'd really love to know where that's being called from
17:35:10 <monochrom> I see why (acc . blah) does not overflow stack. it just overflows heap.
17:35:11 <Saizan> c_wraith: there's an -L flag
17:35:20 <c_wraith> Saizan: for the RTS?
17:35:28 <Saizan> c_wraith: yeah
17:35:45 <c_wraith> ah, I see it.  thanks. :)
17:35:50 <mm_freak> monochrom: i switched back to -indent
17:36:04 <mm_freak> it seems to 'understand' my source code better
17:36:14 <dmwit> gdb is pretty unhelpful, but Saizan does seem to be right that it's a threading problem.
17:37:03 <Saizan> monochrom: yeah, you've to put things somewhere.. maybe this is a case where one should just let the stack grow indefinitely
17:37:03 <dmorti> Hi folks.  I'm trying to install hoogle, but keep getting a "premature end of compressed stream" error from cabal.
17:37:23 <dmorti> Can anyone tell me how to fix this?
17:37:29 <Alpounet> dmwit, yeah, generally GUI libraries need their GUI stuffs to run in the main thread of the program executing them ?
17:37:32 <Alpounet> -?
17:37:34 <dmorti> I realise the problem's been around for a while, but I don't understand the fixes
17:37:55 <dmwit> I had no idea ghci was multithreaded by default.
17:38:02 <dmwit> In fact, it surprises me quite a lot.
17:38:08 <copumpkin> I don't think it eve nis
17:38:23 <dmwit> Oh, it definitely is.
17:38:24 <c_wraith> oh, come on.  fall over, memory use!
17:38:29 <copumpkin> :o
17:38:31 <c_wraith> I hate non-deterministic space leaks
17:38:35 <copumpkin> what's the multithreading for?
17:38:38 <dmwit> As soon as I typed :main, gdb said "[New Thread blah blah blah]".
17:38:45 <dmwit> Before I even hit enter. =)
17:39:34 <dmwit> copumpkin: Let me know if you find out what it's for. =)
17:39:43 <c_wraith> no space leak this run.  I'll pretend it's fixed!
17:39:53 <copumpkin> dmwit: we may never find out if you wait for me!
17:40:08 <dmwit> That's a risk I'm willing to take.
17:40:27 <Saizan> dmorti: which version of HTTP did you use to build your cabal-install ?
17:40:46 <monochrom> (f.g)x to f(g x) is a very cheap step stackwise.
17:41:11 <c_wraith> ah, it decided to spring a leak this time.
17:41:17 <copumpkin> does (.) have a runtime cost at all?
17:41:28 <Saizan> if it's not inlined
17:41:31 <monochrom> It should.
17:41:31 <Alpounet> dmwit, that's a question for #ghc I guess
17:41:45 <copumpkin> it's small enough to be inlined all the time though
17:41:55 <dolio> It has a cost if it's left to fool around with higher-order functions.
17:41:57 <monochrom> But we're recursing over it.
17:42:02 * dmwit isn't sufficiently interested to make somebody put in the mental effort of composing a reply
17:42:08 <c_wraith> It can't be inlined if it's not provided both arguments in place.
17:42:21 <c_wraith> Like if it's being folded across a list of functions
17:42:25 <Alpounet> then is (.) . (.) {- for example -} likely to be inlined for example ?
17:42:32 <Saizan> in this case it is, though :)
17:42:35 <Alpounet> I guess GHC isn't lost at that level of abstraction.
17:42:41 <monochrom> Like mee f n = mee (f . ('x':)) (n-1)
17:43:04 <Saizan> (\rest -> acc (x : rest)) <- you get this
17:43:10 <dmorti> So... I guess that's what I used.
17:43:38 <Saizan> dmorti: ah, you should try recompiling it against 4000.0.9
17:43:39 <dmwit> dmorti: I didn't catch that, what did you use?
17:43:48 <c_wraith> Is there any way to tell hp2ps to put the legend on a second page?
17:44:02 <c_wraith> oh.  -M
17:44:06 <dmorti> 4000.0.4
17:45:27 <monochrom> isn't haskell exciting?
17:46:05 <copumpkin> not for theorbtwo
17:46:33 <c_wraith> Err.  -M causes it to not spit out the key at all, for me.  >_>
17:47:41 <monochrom> I don't take confrontational-provocative tactics such as "isn't ready, toy language" seriously.
17:47:47 <Alpounet> c_wraith, isn't hp2any the new space profiling choice of choice (TM) ?
17:47:53 <Alpounet> tool of choice*
17:47:59 <copumpkin> monochrom: yeah
17:48:29 <c_wraith> Alpounet: it doesn't seem to be, at least on 6.10
17:48:31 <theorbtwo> I can certianly see that point.
17:48:45 <dolio> Wow, GHC 6.13 lists 14 1/2 pages of optimizations it did in ghc-core.
17:48:58 <dolio> 6.12 gives about 1/2 a page, as I recall.
17:49:00 <Alpounet> c_wraith, ok
17:49:27 <theorbtwo> On the other hand, the major library for dealing with binary file formats seems to ignore the largest problem in parsing binary file formats.
17:49:30 <chrisdone> ghc-pkg list shows two directories for packages:
17:49:30 <chrisdone> /home/chris/Programs/lib/ghc-6.10.4/./package.conf:
17:49:30 <chrisdone> /home/chris/.ghc/x86_64-linux-6.10.4/package.conf:
17:49:30 <chrisdone> what does this mean?
17:49:56 <Saizan> one is the global package db, the other is the user specific
17:50:07 <theorbtwo> The major library for general purpose parsing is implemented in such a way that it dies with a very opaque error when you try to use large counts.
17:50:14 <monochrom> global means system-wide, all-users
17:50:22 <theorbtwo> In general, runtime error messages are highly opaque.
17:50:36 <monochrom> of course, except that you put the global one under your home directory too :)
17:50:37 <chrisdone> right. so my global one happens to be installed in my home
17:51:25 <monochrom> I put ghc in /usr/local, so it's really system-wide. except I'm just being pompous, like, this is my laptop, who else is using it anyway :)
17:51:37 <chrisdone> hehe
17:52:08 <chrisdone> annyoingly, cabal --global tries to write to /usr/local/
17:52:13 <chrisdone> so I'm confused
17:52:27 <dmwit> vim ~/.cabal
17:52:36 <dmwit> uh
17:52:39 <dmwit> vim ~/.cabal/config
17:52:51 <monochrom> cabal --global is controlled by flags in ~/.cabal/config, there is a line to set the correct directory.
17:52:52 <Saizan> the data will be written there, the packages will be registered in your global db
17:53:07 <chrisdone> ahhh install dirs global
17:53:09 <chrisdone> excellent
17:54:39 <asdf2> f _|_ = 3  , what does _|_ mean?
17:56:47 <monochrom> infinite loops, errors, undefined things are all summarized collectively as _|_
17:57:01 <phnglui> pronounced "bottom"
17:58:13 <copumpkin> om nom
17:58:14 <monochrom> If you define "f _ = 3", then f (infinite loop) and f (1/0) will still give you 3, this is what f _|_ = 3 says.
17:58:20 <dmorti> So... I've installed HTTP-4000.0.9, and tried to recompile cabal-install, but I'm still getting the same error.
17:58:43 <dmorti> I'm guessing I haven't properly recompiled.  Is there any way to tell which HTTP was used for the currently active cabal-install?
17:59:25 <forrest> Is it correct to say that in haskell there is no way to cast from one type to another as there is in C and Java?
17:59:53 <forrest> and no need
18:00:01 <c_wraith> :t unsafeCoerce -- nothing at all like java casts.  not at all what you want
18:00:02 <lambdabot> Not in scope: `unsafeCoerce'
18:00:15 <c_wraith> :t Unsafe.Coerce.unsafeCoerce -- nothing at all like java casts.  not at all what you want
18:00:16 <lambdabot> forall a b. a -> b
18:00:44 <forrest> yeah, i'm writing a paper about haskell which as of yet i know nothing about, so I wanted to be sure I was saying something correct
18:01:21 <forrest> the type inference system is powerful enough there's no need to "cheat" ... sound reasonable?
18:01:28 <c_wraith> there are some edge cases where things that look very much like dynamic casting exist.  The Data.Dynamic stuff, for instance.  But it's not a standard part of the language
18:01:31 <monochrom> unsafeCoerce is closer to C casts, but not all C casts. Like C casts between pointer types.
18:02:07 <monochrom> Unlike Java casts because Java casts do runtime checks.
18:02:42 <dolio> In Haskell, there's nothing to check. :)
18:02:57 <forrest> so there's something kinda sorta a little like casts, this unsafeCoerce. but not really very much like casts.
18:03:37 <c_wraith> I'd argue that java-style casts aren't necessary because there's no subclass relationships.
18:03:48 <monochrom> It is more like: the type system gives you alternatives so you don't always use "open types" and downcasts.
18:04:37 <forrest> is unsafeCoerce something that arises in connection with I/O ?
18:04:43 <monochrom> Suppose you say, you want a list containing some integers and some booleans. You can do [Either Integer Bool]. No open type necessary yet.
18:04:59 <c_wraith> unsafeCoerce arises mostly in connection with interaction with foreign libraries
18:05:14 <c_wraith> ...  Which is where most of the unsafe parts of haskell arise
18:05:16 <forrest> oh, hooks into C libs and the like
18:05:20 <c_wraith> yes
18:05:39 <Saizan> dmorti: not really
18:05:41 <forrest> ok, that makes sense now
18:06:09 <Saizan> dmorti: though when you compile you can pass -v to the configure step to tell which version of HTTP got used
18:06:27 <dolio> I'm not sure it's typically used with C libraries.
18:06:47 <asdf2> @monochrom: thanks, i got it :)
18:06:47 <lambdabot> Unknown command, try @list
18:07:05 <dolio> Generally, it's for use when you know two types are the same, but there's no way to get the type system to know that.
18:07:32 <forrest> when would that happen?
18:07:46 <dolio> Not often.
18:08:10 <c_wraith> I've never seen an unsafeCoerce outside of toy code
18:08:35 <dolio> It happens, for instance, if you're implementing dynamic types by coupling every value with a runtime type representation.
18:08:44 <copumpkin> I used it in my vector-static the other day
18:08:46 <copumpkin> probably shouldn't have
18:08:52 <copumpkin> but I doubt it'll hurt
18:09:24 <dolio> If you're sure that no one has been malicious about producing type reps, then when you do a runtime check that two type reps are equal, you know that the types that they tag are equal.
18:10:25 <dolio> But you may not be able to get that information back into the type system, so you'd have to unsafeCoerce (that's how GHC's implementation of Dynamic works).
18:12:26 <dolio> Extractors from dependently typed languages tend to use a lot of unsafeCoerce as well, I think.
18:12:37 <c_wraith> But yes.  In general, due to the way polymorphism works in Haskell, you just write a polymorphic function that will specialize to your specific type, rather than downcasting.
18:12:46 <Saizan> basically unsafeCoerce can be used to extend the type system, but you've left with the burden of proving it's sound
18:12:47 <dolio> Since those type systems sometimes have more information that can't be encoded in Haskell's type system.
18:13:05 <Saizan> but this is done in exceptional and well-encapsulated cases.
18:16:00 <forrest> to what extent does real-world haskell rely on hooks into existing C libraries for things like database access and http? seems like you'd want to leverage existing code but otoh you'd lose haskell's type safety that way.
18:16:27 <c_wraith> it's actually pretty easy to create type-safe wrappers
18:16:30 <c_wraith> and that's done quite a bit
18:16:58 <forrest> oh, that makes sense
18:17:09 <tensorpudding> RWH has a chapter on the FFI doesn't it?
18:18:45 <Alpounet> tensorpudding, it does yeah
18:19:01 <jmillikin> Is there a "best" library for playing with FRP? Reactive looks like it's the most mature, but comments like "This version of Reactive has some serious bugs" are a bit scary
18:19:32 <c_wraith> well, looks like I've confirmed what the heap profile was telling me...  The space leak goes away when I turn off the logger.  >_>
18:20:21 <c_wraith> The server is also way faster without it!
18:25:57 <monochrom> the delimited continuation library uses unsafeCoerce between prompts. this use is protected by a GADT that ensures correctness.
18:26:52 <ddarius> Extractions from dependently typed languages ofte use unsafeCoerce way more than needed.
18:27:02 <dolio> Actually, that's not true. The unsafeCoerce is used to cast the GADT to the right type.
18:27:40 <dolio> The prompts contain integers which are unique within the region by construction.
18:27:42 <copumpkin> monochrom: what library is that?
18:27:47 <monochrom> del-cont
18:27:52 <copumpkin> @hackage del-cont
18:27:52 <lambdabot> http://hackage.haskell.org/package/del-cont
18:28:04 <monochrom> oops sorry.
18:28:05 <dolio> @hackage CC-delcont
18:28:06 <lambdabot> http://hackage.haskell.org/package/CC-delcont
18:28:11 <monochrom> Haha
18:28:20 <copumpkin> hadn't come across it, thanks :)
18:29:42 <Saizan> c_wraith: how are you doing the logging?
18:30:13 <dolio> So, when you're gathering up a stack, for the prompt 'P i :: Prompt a' and you find a prompt 'P j :: Prompt b', if i == j, you know a = b, so it gives unsafeCoerce Refl :: TEq a b.
18:31:09 <forrest> thanks, guys -- got to hop off now
18:34:44 <c_wraith> ...  It's a mess.  it involves a Chan.  fork for each connection, each thread writes to the Chan when it completes the request, and a single reader thread pulls from the chan and pushes to stderr.  I've talked about this a bit before in here.  I made the thread that reads the chan use buffered writes to speed it up significantly, and I made writes into the Chan fully force their string args to avoid holding closures into the rest o
18:34:44 <c_wraith> f the code.
18:35:14 <copumpkin> we're going to have to write a @get-mmorrow command soon
18:35:40 <Saizan> hpaste is locked
18:35:44 <dolio> Let him read his manual in peace.
18:35:45 <Saizan> c_wraith: ah, i remember
18:35:49 <copumpkin> dolio: lol
18:35:55 <copumpkin> well I mostly want him, not hpaste
18:36:05 <copumpkin> ;)
18:36:08 <c_wraith> I wonder if this is just the reader thread getting behind.  I can test that
18:36:12 <copumpkin> preflex: seen mmorrow
18:36:12 <preflex>  mmorrow was last seen on #ghc 37 days, 23 hours, 38 minutes and 27 seconds ago, saying: * mmorrow is rtfm'ing
18:38:20 <copumpkin> I just sent him an email
18:39:34 <mm_freak> why can't i import GHC.Integer.GMP.Internals?
18:39:44 <copumpkin> mm_freak: you tell us
18:39:47 <copumpkin> what does GHC say?
18:40:20 <mm_freak> it doesn't find the module at all, even though GHC's base library depends on it
18:40:34 <copumpkin> did you -package integer-gmp ?
18:40:39 <copumpkin> not sure if that would affect things
18:40:40 <ivanm> mm_freak: but it is presumably not an exported module...
18:41:05 <mm_freak> <command line>: unknown package: integer-gmp
18:41:16 <copumpkin> what version of ghc?
18:41:26 <mm_freak> well, i just want to find a way to talkThe Glorious Glasgow Haskell Compilation System, version 6.10.4
18:41:29 <mm_freak> wah
18:41:30 <mm_freak> The Glorious Glasgow Haskell Compilation System, version 6.10.4
18:41:39 <copumpkin> mm_freak: works fine for 6.12
18:41:41 <mm_freak> i just want to find a way to talk to GMP
18:41:50 <mm_freak> hmm, ok
18:42:10 <copumpkin> mm_freak: GHC was the only option in 6.10
18:42:16 <copumpkin> so I doubt it was separated into a separate module
18:42:26 <Saizan> *GMP
18:42:30 <copumpkin> lol
18:42:38 <copumpkin> mm_freak: what are you doing, out of curiosity?
18:43:01 <mm_freak> i thought maybe i could use the fast number-theoretic functions of GMP
18:43:09 <copumpkin> that'll be a pain
18:43:15 <mm_freak> it frustrates me that the functions are there, but you can't use them
18:45:08 <monochrom> I can get you more frustrated about similar things in hardware.
18:45:57 <mm_freak> copumpkin: are you saying that GHC 6.12 has an alternative to GMP?
18:46:01 <copumpkin> yeah
18:46:09 <copumpkin> but you need to recompile ghc to get it
18:46:16 <copumpkin> integer-simple, in pure haskell
18:46:24 <mm_freak> hmm
18:46:27 <copumpkin> pretty fast for some operations, others not so much
18:46:38 <MissPiggy> is it binary integers?
18:46:42 <MissPiggy> like lists of bits
18:46:47 <copumpkin> yeah
18:46:51 <mm_freak> UArray Int Bool, probably
18:46:56 <copumpkin> nope, actual lists
18:47:13 <mm_freak> hmm, lists?  isn't that slow as hell?
18:47:22 <copumpkin> http://darcs.haskell.org/libraries/integer-simple/
18:47:48 <regalia> As I understand it, RWH deals with IO the entire time. I'm on the IO chapter of LYAH right now, should I just move into RWH now?
18:48:03 <regalia> Or is there something else I should read after having basically finished LYAH?
18:48:07 <copumpkin> oh, it's chunks of bits now
18:48:11 <copumpkin> data Digits = Some !Digit !Digits
18:48:11 <copumpkin>             | None
18:48:11 <copumpkin> type Digit = Word#
18:48:20 <copumpkin> maybe it always was, but I thought not
18:49:03 <regalia> I need more Haskell to chew on!
18:49:15 <ivanm> regalia: RWH is nost just about IO ;-)
18:49:17 <mm_freak> well, almost the same, though Digits is stricter
18:49:35 <ivanm> finish LYAH or some other tutorial first; then read RWH to get a different perspective and get into more advanced topics
18:49:46 <regalia> ivanm: Ok thanks
18:54:30 <mm_freak> the intSqrt function from the Crypto package is quite questionable
18:54:38 <mm_freak> intSqrt :: Integer -> Integer
18:54:38 <mm_freak> intSqrt i = floor (sqrt (fromIntegral i ) )
18:56:07 <copumpkin> lol
18:56:11 <mm_freak> also i notice that Crypto is using a weak random number generator
18:56:14 <copumpkin> mm_freak: haskell for maths v1 has a much better one
18:56:24 <copumpkin> Crypto has a lot of questionable parts to it
18:56:31 <mm_freak> indeed
18:56:37 <copumpkin> mm_freak: "better one" = better intSqrt
18:56:42 <mm_freak> but somehow it's very fast
18:56:59 <copumpkin> well I'd expect such a simplistic intSqrt to be fast
18:57:06 <copumpkin> but it'll lose accuracy
18:57:14 <copumpkin> > floor (1/0)
18:57:15 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
18:57:18 <copumpkin> lol
18:57:22 <ivanm> yeah, it should use round, not floor!
18:57:29 <copumpkin> > floor (-1/0)
18:57:30 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
18:57:36 <ivanm> copumpkin: any idea why it comes up with that particular Integer value?
18:58:01 <copumpkin> nope
18:58:21 <Saizan> bit twiddling?
18:58:29 <mm_freak> it's 2^1024
18:58:32 <mm_freak> > 2^1024
18:58:35 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
18:58:39 <copumpkin> how about the NaN value?
18:58:43 <copumpkin> > floor (0/0)
18:58:44 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
18:58:50 <ivanm> OK, so 1/0 \approx 2^1024? :p
18:58:52 <pastorn> is STM a good idea for writing an IRC-bot?
18:58:59 <copumpkin> pastorn: nope
18:59:15 <pastorn> (to be able to have many threads and input from the socket as well as terminal)
18:59:16 <monochrom> Yes.
18:59:38 <pastorn>     h <- asks socket
18:59:39 <copumpkin> doing IO in STM? /me shrugs
18:59:40 <pastorn>     s <- liftIO $ hGetLine h
18:59:44 <pastorn> that's what i have now
18:59:47 <mm_freak> pastorn: in general MVars/Chans will suffice
18:59:50 <copumpkin> you'll get a lot of repetitions, potentially
18:59:57 <monochrom> No one is doing IO in STM.
19:00:05 <Saizan> well, you'd STM just to communicate
19:00:05 <mm_freak> pastorn: if you find that MVars don't suffice, either use more threads or use STM
19:00:06 <pastorn> so my program will stand there until stuff happends, but i also want to have a
19:00:10 <Saizan> not to do the I/O
19:00:12 <pastorn>     cmd <- getLine
19:00:14 <pastorn> somewhere
19:00:26 <copumpkin> Saizan: ah
19:00:53 <monochrom> More like: s<-HGetLine blah; atomically (add s to some TChan)
19:00:53 <pastorn> so put my state in an MVar?
19:01:24 <pastorn> and then have one thread for terminal input and one for socket input?
19:02:15 <Saizan> you can have a thread for irc output that reads from a Chan, where bot the socket input and terminal input threads write
19:02:51 <copumpkin>  2815 pumpkin   20   0 2774m 2.7g 1760 R 100.0  8.6   1381:38 learnwts
19:02:54 <mm_freak> > fromIntegral (2^1024) :: Double
19:02:55 <lambdabot>   Infinity
19:02:57 <copumpkin> that's been running for quite a while :)
19:03:28 <pastorn> Saizan: hmm... ok
19:03:42 <pastorn> i'll have to study up on chans for when i get to that part :)
19:04:07 <Saizan> Chans are just unbounded FIFO queues
19:04:15 <mm_freak> use MVars unless you have a reason to use Chans
19:04:17 <Saizan> threadsafe ones
19:04:48 <mm_freak> somewhere on hackage there is also a bounded chan
19:04:59 * copumpkin also has a network chan
19:05:12 <copumpkin> never released it though cause I was waiting for a nicer lower level
19:05:50 <mm_freak> a network MVar would be great =)
19:10:00 <pikhq> mm_freak: So... Erlang?
19:11:49 <c_wraith> hmph.
19:12:00 <mm_freak> pikhq: i'd like to stick with haskell
19:12:07 <c_wraith> I may have just solved this...  By replacing STM with an MVar.
19:13:14 <c_wraith> Is it possible STM has a transient space leak when an operation gets retried?  (transient in that it gets cleaned up when the action finally finishes successfully)
19:18:14 <MissPiggy> what shold I write in haskell??
19:18:24 <ivanm> anything you want to!
19:18:25 <MissPiggy> something cool that I can complete in a short time
19:18:32 <c_wraith> lyrics to a programming filk
19:18:38 <MissPiggy> the thing I want to write is too difficult it is making me upset
19:18:50 <ivanm> what do you want to write?
19:19:08 <c_wraith> This looks like...  STM wasn't leaking, it was actually entering into contention.
19:19:20 <c_wraith> and STM in contention is *badly* slow
19:19:36 <c_wraith> and hence things were getting behind, and everything was building up
19:19:37 <MissPiggy> something that solves equations and the like
19:19:37 <monochrom> there is a chance you're doing it wrong.
19:20:00 <c_wraith> monochrom: using STM for a single TVar is using STM wrong. :)
19:20:38 <copumpkin> jmcarthur: ooh, you're top 100!
19:22:47 <ksandstr> c_wraith: how so? it's still composable, right?
19:23:45 <codemac> Is work on yi at all active anymore?  I want emacs (minus elisp), and it seems to be my best chance.
19:23:59 <c_wraith> ksandstr: true.  semantically, it's correct.  But it has horrible behavior under contention...  and all concurrent access will be contention, by definition
19:24:03 <MissPiggy> so any ideas?
19:24:31 <ivanm> MissPiggy: hmmm...
19:24:37 <ivanm> what are your interests?
19:24:46 <ksandstr> c_wraith: so it's something to keep in mind if/when it becomes a bottleneck. why worry?
19:25:00 <c_wraith> ksandstr: it became a bottleneck that was causing a space leak under load
19:25:10 <MissPiggy> I can't say
19:25:13 <ksandstr> c_wraith: oh, that kind of horrible behaviour
19:25:14 <jmcarthur> copumpkin: yeah i was higher last night
19:26:17 <copumpkin> jmcarthur: weed?
19:27:52 <jmcarthur> copumpkin: ?
19:27:55 <jmcarthur> oh
19:27:58 <jmcarthur> *sigh*
19:28:15 <dolio> citeseer sure has a lot of downtime.
19:28:20 <jmcarthur> copumpkin: i got in the top 50 last night
19:28:28 <jmcarthur> but then my submission was suspended
19:28:40 <monochrom> I guess all threads "waiting" on a TVar are woken up, whereas at most one thread waiting on an MVar is woken up.
19:28:44 <jmcarthur> because i suck at writing timing code or the server sucks at timing things or something (i think the latter)
19:28:56 <copumpkin> aw
19:29:10 <c_wraith> monochrom: That would make sense, I think
19:29:14 <MissPiggy> :(
19:30:09 <ivanm> MissPiggy: so you want us to tell you what we'd like you to write?
19:30:18 <ivanm> why not look at the haskell proposal reddit for ideas then?
19:30:38 <MissPiggy> no it has to be something easy
19:30:41 <MissPiggy> which I can actually do
19:31:22 <Cale> MissPiggy: I would appreciate a program that generates nurikabe puzzles :)
19:31:29 <ivanm> there are heaps of easy ones there probably
19:31:41 <DigitalKiwi> write something hard and you'll learn more
19:31:45 <ivanm> or else go to a bug tracker for cabal, cabal-install, darcs, etc. and find their easy problems to fix
19:32:43 <MissPiggy> Cale how might one generate such a puzzle? just put down some which patches check they satify the rules and then number them?
19:33:31 <ivanm> MissPiggy: that's part of the problem to solve!
19:33:34 <ivanm> greetings blackdog
19:34:37 <MissPiggy> not this
19:34:39 <MissPiggy> oops
19:36:52 * MissPiggy is happy to learn that Nuikabe is NP complete
19:43:43 <codemac> I'm trying to build Yi, is there any way to create a cabal installed set of libraries local to just the Yi build?
19:43:52 <noggle> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Data-List.html#words
19:43:52 <lambdabot> noggle: You have 1 new message. '/msg lambdabot @messages' to read it.
19:44:33 <noggle> what is {-partain:Char-}
19:44:39 <noggle> :t partain
19:44:40 <lambdabot> Not in scope: `partain'
19:44:43 <Cale> A strange comment
19:44:51 <Zao> {- is an opening comment.
19:44:58 <Zao> -} is the corresponding close.
19:45:04 <noggle> oh I did not notice it was a curly
19:45:05 <Zao> cf. /* omg */  in C-ish langauges.
19:45:11 <ablmf> If I have 2 list [1,2],  [3, 4, 5],   and I want to generate [ [(1,3), (1,4), (1,5)] ,  [(2,3), (2,4), (2,5)] ]   Is there any convinient way to do that?
19:45:19 <ivanm>  Cale: oh, good, so I'm not the only one who can't figure it out
19:45:19 <noggle> zip
19:45:20 <Zao> ablmf: Lots.
19:45:22 <Cale> As for why that comment is there, I have no idea.
19:45:27 <ivanm> list comprehensions
19:45:39 <Cale> ablmf: liftM2 (,)
19:45:39 <MissPiggy> > map (\x -> map (\y -> (x,y)) [3, 4, 5]) [1,2]
19:45:40 <lambdabot>   [[(1,3),(1,4),(1,5)],[(2,3),(2,4),(2,5)]]
19:45:46 <Cale> > liftM2 (,) [1,2] [3,4,5]
19:45:47 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
19:45:56 <Cale> oh, I see, you want it nested
19:46:01 <ivanm> > [[(x,y) | x <- [1,2] | y <- [3,4,5]]
19:46:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:46:09 <ivanm> grrr...
19:46:15 <ivanm> > [[(x,y) | x <- [1,2] ] | y <- [3,4,5]]
19:46:16 <lambdabot>   [[(1,3),(2,3)],[(1,4),(2,4)],[(1,5),(2,5)]]
19:46:22 <ivanm> ablmf: ^^
19:46:25 <aavogt> that can be accepted by ghc...
19:46:32 <ivanm> oh, it's nested the wrong way
19:46:44 <aavogt> your first one can be interpreted as a zip
19:46:45 <Cale> MissPiggy got it :)
19:46:48 <ivanm> switch the lists around
19:46:55 <ivanm> yeah, yeah
19:46:59 <MissPiggy> Cale this problem (generate puzzles) is very difficult!!
19:47:12 <Hunner> liftM doesn't seem to want to lift my function into IO... how can I tell it this is the monad I want?
19:47:30 <Cale> MissPiggy: Yeah, you'll want to write a solver which is able to partially solve puzzles whose solution is not completely determined
19:47:45 <ablmf> thx !
19:48:16 <copumpkin> These are not the monads you are looking for.
19:48:23 <tensorpudding> Hunner: you could specify the type explicitly
19:49:01 <ivanm> Hunner: what's the actual error message?
19:49:06 <tensorpudding> > liftM  (+5) :: IO Int -> IO Int -- for instance
19:49:07 <lambdabot>   No instance for (Test.SmallCheck.Serial
19:49:07 <lambdabot>                     (GHC.IOBase.IO ...
19:49:07 <Cale> > [[(x,y) | y <- [3,4,5] ] | x <- [1,2]]
19:49:08 <lambdabot>   [[(1,3),(1,4),(1,5)],[(2,3),(2,4),(2,5)]]
19:49:46 <ivanm> @remember copumpkin These are not the monads you are looking for.
19:49:47 <lambdabot> It is forever etched in my memory.
19:49:51 <tensorpudding> but that's not usually what you want; ghc is good at inferring the right type depending on the situation
19:49:59 <Hunner> tensorpudding: thanks
19:49:59 <ivanm> you've been saying it enough recently, you obviously wanted it @remember'd :p
19:50:11 <monochrom> ha
19:50:16 <copumpkin> ivanm: I've said it more than once? :o
19:50:19 * copumpkin is losing his mind
19:50:28 <ivanm> I'm sure someone said it the other day....
19:50:43 <Hunner> tensorpudding: It did want I wanted ... it was lifting it into the list monad before or something... I forgot since I took a few hour break
19:51:06 <aavogt> > (\(length -> 1) -> True) "a"
19:51:07 <tensorpudding> ah, you have to be careful with mixing and matching monads
19:51:07 <lambdabot>   Illegal view pattern:  (length -> 1)
19:51:07 <lambdabot>  Use -XViewPatterns to enable view pat...
19:51:22 <ivanm> heh
19:51:24 <tensorpudding> for instance, you can't use multiply monads in do notation
19:51:32 <monochrom> Sounds like a ghost story.
19:51:36 <tensorpudding> err, multiple*
19:51:41 <ivanm> about to ask...
19:51:48 <ivanm> what are multiply monads? :p
19:52:05 <tensorpudding> there's a multiply monoid
19:52:33 <aavogt> list sort of multiplies your possibilities
19:53:00 <tensorpudding> the list monad can make a poor-man's powerset
19:55:14 <ablmf> I want to generate a large list of numbers,  which are under a certain upper boundary, with all repeats removed.  I found 2 ways to do that : 1. create the list and use nub.   2. User Data.Set            I found both of them inefficient.
19:55:30 <ablmf> Any better solution ?
19:55:54 <ablmf> In C, I can use an array of bits to indicate that a number is in the list
19:56:02 <ivanm> ablmf: you want it lazy?
19:56:07 <ablmf> No
19:56:11 <ablmf> I need the sum
19:57:01 <ivanm> ablmf: OK, what you can do is this:
19:57:09 <monochrom> Like [1..50000] ?
19:57:16 <ablmf> Yeah
19:57:37 <ablmf> When there any many repeats, nub is not very efficient
19:57:42 <ablmf> Data.Set is better
19:57:50 <monochrom> But there is no repeat in [1..50000]
19:57:52 <ivanm> rather than using sum yourself, use foldr to do a manual sum with a Set of seen numbers; that way, if the number isn't in the Set add it to the current sum as well as the Set
19:58:00 <ivanm> monochrom: I think he's generating them elsewhere
19:58:10 <ivanm> and said that that's the kind of size he's talking about
19:58:41 * ivanm has used something like that to create a lazy version of nub
19:58:53 <ablmf> ivanm: sounds reasonable
19:59:14 <ivanm> you can, of course, just use the Set to create a version of nub that's lazy and then use normal sum
19:59:23 <Cale> map head . group . sort is similar to the Data.Set version
19:59:30 <ddarius> Isn't nub already lazy?
19:59:34 <ivanm> nub is lazy; any sorting-based one isn't
19:59:42 <Cale> If you know that the list is already sorted, then you can just map head . group
19:59:48 <ivanm> ddarius: yes, but my way is n log n vs n^2
19:59:57 <Cale> map head . group is linear
20:00:08 <ablmf> I just still feel that the bit array solution in C is more clear.
20:00:18 <ivanm> bit array solution?
20:00:24 <ablmf> Yeah
20:00:28 <Cale> ablmf: You could use an array of Bool if it suits you
20:00:29 <ivanm> what is it? :p
20:00:49 <ablmf> Use a bit array to indicate if a number is in the list
20:00:51 <ivanm> Cale: I always find it a bit amazing that we "know" we can safely use head on the result of group...
20:01:00 <Cale> ivanm: we do.
20:01:00 <ddarius> @src group
20:01:00 <lambdabot> group = groupBy (==)
20:01:05 <ddarius> @src groupBy
20:01:06 <lambdabot> groupBy _  []       =  []
20:01:06 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:01:06 <lambdabot>     where (ys,zs) = span (eq x) xs
20:01:12 <Cale> ivanm: every list which group produces is nonempty
20:01:15 <ivanm> Cale: I know that
20:01:24 <ivanm> but if you just look at the type sig, you can't tell that
20:01:31 <ivanm> we only know it's safe because we know the source
20:02:03 <monochrom> That is wrong. We know the specification. We prove that it implies nonempty list.
20:02:06 <ddarius> That's true of any (safe) use of any partial function.
20:02:21 <ddarius> And yes, we know the semantics not necessarily the source.
20:02:24 <monochrom> We also prove that the source refines the specification.
20:02:32 <ivanm> monochrom: true
20:02:40 <ablmf> Each bit repesent a number, of course in a limited range
20:03:01 <monochrom> I am amazed at all kinds of worries about specifications not completely represented by types.
20:03:20 <ivanm> heh
20:03:39 <Cale> ablmf: UArray Int Bool will be packed such that you have one bit per Bool.
20:03:40 <ablmf> In that way, the time to reach the bit for a number shall be very very fast.
20:03:51 <ivanm> monochrom: it's just that there are so many tutorials, etc. that warn you about using head... and then there's a couple of cases where we always use head
20:04:16 <ddarius> If there weren't cases where we use head, then it wouldn't be in the library (modulo foldl)
20:04:20 <Cale> ablmf: You could also use, say, Integer with Data.Bits
20:04:23 <ivanm> heh
20:04:35 <ivanm> ddarius: IIRC, there are still some cases where foldl is preferred over foldl' ...
20:04:43 <ivanm> (i.e. the seq isn't needed)
20:05:11 <Cale> Wouldn't foldr make a better head?
20:05:21 <ddarius> ivanm: If the seq isn't needed, but doesn't really hurt, I still prefer foldl'.  I haven't found any compelling cases where the seq is needed (I can make artificial cases.)
20:05:49 <Cale> > foldr (\x xs -> x) undefined [1..]
20:05:50 <lambdabot>   1
20:07:12 <Cale> foldl makes it easier to write last
20:07:56 <ddarius> > foldl (flip const) undefined [3,4]
20:07:57 <lambdabot>   4
20:08:07 <ddarius> > foldl' (flip const) undefined [3,4]
20:08:08 <lambdabot>   4
20:08:25 <Cale> > foldl (\a x -> a . const x) id [1..10] 0
20:08:27 <lambdabot>   1
20:08:40 <ivanm> did you just write head using foldl? :o
20:08:53 <ddarius> Higher order folds are cheating.
20:09:00 <Cale> > foldl (\a x -> a . const x) id [1..10] undefined
20:09:01 <lambdabot>   1
20:09:25 <ivanm> ddarius: you mean a fold returning a function?
20:09:39 <ddarius> ivanm: Yes, in certain cases.
20:11:56 <copumpkin> > head []
20:11:57 <lambdabot>   * Exception: Prelude.head: empty list
20:12:20 <Cale> > foldl (\a x -> a . const x) id [1..] undefined
20:12:25 <Cale> ^^ fail ;)
20:12:25 <lambdabot>   mueval-core: Time limit exceeded
20:12:35 <pastorn> how do i reload code that is running+
20:12:55 <pastorn> (like xmonad does with config loading)
20:13:18 <Cale> pastorn: xmonad doesn't reload code that's running, it just builds a new binary and execs it
20:13:22 <ddarius> pastorn: That's not something intrinsic in Haskell.
20:14:17 <ddarius> The only special thing xmonad does is serialize its state (and then deserialize it upon start-up).
20:14:51 <pastorn> so there's no dynamic loading like in scheme or erlang to be had?
20:14:57 * monochrom has a cunning plan. Hack prelude source so head [] = error "my head has exploded"
20:15:18 <Cale> pastorn: You can use hint to load Haskell code at runtime.
20:15:21 <ddarius> pastorn: There are a few plugin libraries based on the GHC API, but that is not how xmonad works and, of course, those are GHC specific.
20:15:40 <pastorn> ddarius: it's fine... i only use GHC
20:15:58 <ddarius> @hackage hint
20:15:58 <blackdog> Cale: that's not quite the same thing - that loads an interpreter that you can run code in, doesn't it?
20:15:59 <lambdabot> http://hackage.haskell.org/package/hint
20:16:06 <ddarius> @hackage plugins
20:16:07 <lambdabot> http://hackage.haskell.org/package/plugins
20:16:10 <pastorn> since i work on an IRC bot it's kindo tedious to restart it to tets all the new features i write
20:16:40 <Cale> blackdog: Well, hint can interpret or load compiled Haskell code in the form of .o/.hi files
20:17:09 <Cale> blackdog: and then you can evaluate things in the context of the loaded modules
20:17:40 <blackdog> Cale: really? I missed that feature... how do you do that?
20:17:49 <blackdog> loadModules seems to want the source
20:17:55 <Cale> blackdog: Same as GHCi, if the .o files are there, it will load them.
20:18:07 <Cale> So you just run GHC over your source beforehand.
20:18:08 <pastorn> what i just want to do is to not close my socket each time i reload
20:18:16 <pastorn> is there perhaps some simpler hack to do that?
20:18:36 <ddarius> pastorn: Work in GHCi.
20:18:42 <Cale> pastorn: If you can devise a standard interface to modules that you're loading, then you can use something like hint to do it.
20:18:57 <pastorn> ddarius: where do i put the socket? ghci forgets everything when i do :r
20:19:55 <ddarius> pastorn: Another possibility would be to talk to a program over a pipe or some such and that program can maintain the connection.
20:19:55 <pastorn> a globally defined ioref?
20:20:07 <ivanm> Cale: do you know what "triangulation" refers to wrt graph theory? this paper I'm trying to read (http://arxiv.org/abs/0907.1421) just starts using the term without defining it, and wikipedia isn't much help (several possible options)
20:22:30 <ddarius> pastorn: You could write a tiny little proxy server that just constantly listens on a local port and echos to the network port.
20:24:06 <pastorn> hmm...
20:24:14 <monochrom> How to use hint like a loader: use a "load" function to load Prelude and your module. then use an "eval" function to evaluate the name of the function or whatever in your module that you want to call. bind the result to a variable name and pass it around if you want to use it many times.
20:25:30 <noggle> hey, how long will it take for me to actually be decent at "reasoning" about haskell programs
20:25:34 <noggle> hahah
20:25:46 <monochrom> The problem with hint is it takes Î(n) space in your tmp directory if you call the "load" function n times.
20:27:07 <ddarius> 0 and Î look almost identical in my font
20:27:17 <monochrom> And the problem with GHCi and the GHC API is that it also takes Î(n) memory if you call the "load" functions n times.
20:27:42 <copumpkin> ooh, someone using big-X notation correctly
20:27:52 <dolio> A recent ubuntu upgrade made ~ and - look identical in my monospace font of choice.
20:27:55 <ivanm> big-X notation?
20:27:56 * ddarius is unaware of big-X notation.
20:27:57 <ivanm> what's that?
20:27:59 <monochrom> Of course, I was the one whining about it!
20:28:08 <copumpkin> where X is one of O/omega/theta
20:28:25 * copumpkin is feeling lazy
20:28:29 * ddarius endeavors to misuse little-o notation.
20:28:30 <ivanm> ahhh
20:29:03 * copumpkin has never seen people actually use little-X notation for anything much
20:30:03 <monochrom> real analysis, numerical analysis, and those parts of number theory that estimate things like "how many primes in this interval", "how many steps for factoring" use little-o
20:30:17 * ivanm was unaware there were little versions of the big-O/theta/omega notations
20:30:55 <dolio> Is there little theta and omega? It might just be little-o.
20:31:04 <copumpkin> ah, I've never taken any of those
20:31:05 <path[l]> no they all have babies
20:31:14 <monochrom> Among the little ones, I have only seen little-o.
20:31:25 <Draconx|Laptop> dolio, little omega is to big omega as little o is to big O.
20:31:34 <path[l]> yeah
20:33:22 <dolio> I have trouble keeping them all straight.
20:33:42 <monochrom> I have seen little-Ï too, but much more rarely.
20:33:45 <ddarius> There is a little-Î¸, but it's notated differently.
20:34:16 <copumpkin> dolio: peer really has it in for you
20:34:36 <dolio> Yeah, my connection is pretty shakey.
20:39:10 <SamB_XP_> what the heck are the little-things
20:39:25 <dolio> Wikipedia doesn't mention a little-theta.
20:39:39 <copumpkin> proof it does not exist
20:40:05 <ddarius> dolio: As I said, it is notated differently.
20:40:06 <copumpkin> reductio-ad-wikipedium : (Wikipedia a -> _|_) -> a -> _|_
20:40:19 <copumpkin> reductio-ad-wikipaedium : (Wikipaedia a -> _|_) -> a -> _|_
20:40:34 <path[l]> afaik when you have big O saying you can find a k such that f(x) <= kx, then small O is f(x) < kx
20:40:39 <path[l]> something like that
20:40:44 <ddarius> dolio: What it would be is the twiddle, ~.
20:40:44 <path[l]> so just reverse the signs
20:42:33 <dolio> The description I'm reading says that little o denotes that forall k > 0, there is an n beyond which f(n) <= k*g(n).
20:42:48 <arw> big X ist just lim sup or lim inf, small x is without the sup/inf.
20:42:48 <SamB_XP_> copumpkin: you're scaring me like that librarian in Star Wars!
20:44:18 <Draconx|Laptop> dolio, the definitions in terms of limits are a lot nicer, imo.
20:44:31 <dolio> Yeah.
20:44:32 <arw> http://de.wikipedia.org/wiki/Landau-Symbole <- hm, seems we finally found a case where german wikipedia has it right and the english one doesn't ;)
20:44:39 <copumpkin> SamB_XP_: huh? :)
20:45:33 <ivanm> episode 2?
20:45:34 <SamB_XP_> copumpkin: the one who was all "\planet \notin \archives => \not\exist\planet"
20:45:41 <copumpkin> oh
20:46:04 <SamB_XP_> like she'd never seen a spy movie or something!
20:46:32 <shapr> dangit
20:46:37 <shapr> I don't want to poke ioctls by hand.
20:46:41 <ivanm> SamB_XP_: not intellectual enough, obviously
20:46:52 <ivanm> shapr: maybe put some gloves on first then? :p
20:47:31 <copumpkin> bedtime
20:48:32 <shapr> yarr
20:53:30 <ivanm> copumpkin: no it's not!
20:53:40 <ivanm> it's not even 4PM yet!
20:53:45 <ivanm> (siesta time, maybe...)
20:53:57 <blackdog> ivanm: always siesta time in canberra
20:54:13 <ivanm> blackdog: heh, not quite
20:54:24 <ivanm> I'm apparently meant to do some work whilst I'm here...
20:54:26 <ivanm> >_>
20:54:28 <ivanm> <_<
20:54:33 <ivanm> blackdog: you're in Sydney, right?
20:55:01 <blackdog> ivanm: certainly am. it's a self-respect thing.
20:55:15 <blackdog> where's axman6? i haven't unfairly abused him for ages:)
20:55:21 <ivanm> he's around
20:55:40 <ivanm> his girlfriend was having wisdom teeth removed today, so he's most probably comforting here or some such...
20:55:50 <ivanm> + he said he's got some SES thing on tonight
21:03:42 <dolio> So, how about this: I seem to be getting consistent results showing that my radix sort is around 30% faster on randomized data than on already sorted data.
21:03:56 <pastorn> @pl \msg -> if msg_command msg == "001" then return () else (dispatch msg >> waitFor001)
21:03:56 <lambdabot> (line 1, column 51):
21:03:56 <lambdabot> unexpected " "
21:03:57 <lambdabot> expecting variable, "(", operator or "else"
21:04:17 <pastorn> @pl (\msg -> if msg_command msg == "001" then return () else (dispatch msg >> waitFor001))
21:04:18 <lambdabot> (line 1, column 52):
21:04:18 <lambdabot> unexpected " "
21:04:18 <lambdabot> expecting variable, "(", operator or "else"
21:04:51 <pastorn> hmm... this is 'when', which i see now :)
21:06:09 <pastorn> @pl \msg -> when (msg_command msg == "001") (dispatch msg >> waitFor 001)
21:06:09 <lambdabot> ap (when . ("001" ==) . msg_command) ((>> waitFor 1) . dispatch)
21:06:16 <pastorn> my stars....
21:07:12 * ddarius actually finds that fairly understandable.
21:07:20 <pastorn> haha
21:07:38 <pastorn>             case msg_command msg of
21:07:39 <pastorn>                 "001" -> return ()  -- proceed
21:07:41 <pastorn>                 _     -> dispatch msg >> waitFor001
21:07:47 <pastorn> might be better...
21:07:53 <dolio> I think you want 'unless' if your original is correct.
21:08:00 <pastorn> oh
21:09:11 <pastorn> @pl \msg -> unless (msg_command == "001") (dispatch msg >> waitFor001)
21:09:11 <lambdabot> unless (msg_command == "001") . (>> waitFor001) . dispatch
21:09:46 <pastorn> that's loads betetr
21:10:52 <ddarius> pastorn: There's a reason it's better...
21:12:10 <pastorn> @pl \eSM -> case eSM of {Left  str -> liftIO (putStrLn $ "BAD FORMAT: " ++ str); Right msg -> (case msg_command msg of {"001" -> return (); _ -> dispatch msg >> waitFor001})}
21:12:10 <lambdabot> (line 1, column 21):
21:12:10 <lambdabot> unexpected "{"
21:12:10 <lambdabot> expecting variable, "(", operator or end of input
21:12:54 * ddarius recommends not piping your code through @pl.
21:13:20 <pastorn> ddarius: but wai?!
21:14:54 <dankna> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22987#a22987  Why is that second instance matching?
21:15:18 <dankna> (I didn't provide the source, just the error message, because it's my belief that the error has all the requisite information in it, but let me know if not)
21:15:50 <Saizan> the context doesn't matter wrt instance matching
21:15:56 <dankna> hmmmmm
21:16:04 <Saizan> it's only added as an additional constraint after the fact
21:16:05 <dankna> that sort of explains it, I need to ponder
21:16:51 <dankna> so basically you're saying it is matching (t, t1, t2) against (array index content)
21:18:03 <dankna> I don't get how those things can match - I mean, one is a tuple and the other isn't.  Hmm.  Unless the comma in the tuple is a type constructor and is matching against my type variable "array"?  Hmm.
21:18:45 <dankna> but even if that's the case, shouldn't the tuple constructor have three parameters and "array" only has two?  or am I totally misunderstanding how instance matching happens?
21:19:24 <dolio> As far as (Haskell 98) overlapping is concerned, that instance is an instance for: forall a b c. a b c.
21:20:09 <ddarius> array = (,,) t; index = t1; content = t2.
21:20:24 <dankna> ddarius: hmmmm!
21:20:43 <dankna> oh
21:20:45 <dankna> that does explain it then
21:21:11 <dankna> well, I'm glad I understand why it's happening.  does anyone have advice on what I can do about it? :)
21:21:26 <dolio> Don't write instances like that.
21:21:43 <Saizan> use a newtype if you want to write an instance for all arrays
21:22:34 <dankna> ah - yeah, I see how that would be done, I think (someone demonstrated it for me earlier, for a slightly different problem)
21:22:34 <Saizan> newtype WrapArray array index content = W (array index content)
21:23:07 <dankna> gotcha.  appreciated.
21:23:29 <dankna> I know this stuff is kinda newbie questions, but I couldn't figure it out on my own.
21:25:06 <Saizan> no problem with newbie questions :)
21:25:10 <dankna> good :)
21:33:36 <dankna> Saizan: got that solution working, thanks again
21:35:07 <zoheb> @pl (\x-> x*x)
21:35:07 <lambdabot> join (*)
21:35:17 <zoheb> :t join
21:35:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:45:54 <pastorn> argh!
21:46:01 <pastorn> i have a record syntaxex ADT
21:46:01 <jmcarthur> copumpkin: #52
21:46:20 <pastorn> data A = A {a :: [String] }
21:46:29 <pastorn> now i want to do this
21:46:30 <jmcarthur> and holding
21:46:49 <pastorn> f myA@(A { a = a } = ...
21:46:50 <pastorn> BUT
21:47:08 <pastorn> i want it to pattern match on the record field a
21:47:20 <pastorn> f myA@(A { a = [s1,s2] } = ...
21:48:24 <pastorn> this isn't going too well
21:48:50 <tensorpudding> f myA@(A [s1,s2]) =
21:49:11 <pastorn> tensorpudding: but then you're throwing the record out of the window
21:49:30 <pastorn> i want to pattern match on a specific field in my record type
21:49:37 <jmcarthur> that's how you do it
21:49:37 <ddarius> pastorn: Modulo the missing closing parenthesis, that should work fine.
21:49:44 <jmcarthur> oh, a specific field
21:49:51 <tensorpudding> wait, what?
21:50:06 <jmcarthur> umm... i'm not sure how one would do that
21:50:09 <tensorpudding> can you even do that?
21:50:11 <jmcarthur> maybe ViewPatterns?
21:50:32 <pastorn> tensorpudding: data A = A { a :: [String], b :: B, c :: C, ET CETERA...}
21:51:12 <pastorn> and i want to patternmatch against a consinting of two strings
21:51:31 <ddarius> data Foo = Foo { a :: Int, b :: String }; f (Foo { a = 3, b = c:cs }) = c -- works fine in GHCi.
21:51:44 <shapr> absentia: What?
21:51:46 <pastorn> cool
21:51:59 <pastorn> ddarius: oh, i just can't use [x,y] then?
21:52:03 <tensorpudding> huh that does work
21:52:09 <pastorn> but (x:y:[]) should work?
21:52:11 <ddarius> pastorn: You can, you can use any valid pattern.
21:52:25 <ddarius> pastorn: Have you even tried your code?  Other than a small lexical error, it should work fine.
21:52:47 <pastorn> http://files.myopera.com/Mysticmaster/blog/facepalm.jpg
21:52:54 <pastorn> i had a missing paretheses
21:52:59 <ddarius> I said that.
21:53:10 <pastorn> ddarius: i ignored that ;)
21:53:16 * pastorn can't be wrong. EVAR
21:53:30 <tensorpudding> won't always succeed though
21:53:41 <tensorpudding> matching on [x,y] that is
21:55:01 <pastorn> tensorpudding: yes i will
21:55:24 <tensorpudding> err rather, the pattern is not complete sorry
21:55:28 <ddarius> http://lambda-the-ultimate.org/node/3840
21:55:28 <pastorn> (this is another instance of me not being wrong)
21:57:00 <tensorpudding> inexhaustive is the word i was looking for
21:57:48 <ddarius> "nonexhaustive"
21:58:24 <tensorpudding> yes, non-exhaustive
21:58:41 <tensorpudding> according to ghc
21:58:46 <pastorn> tensorpudding: i promise i'll put an if-statement in the caller making sure there's two elements in that list, mmmkay?
21:59:14 <ddarius> pastorn: And what will the else branch do?
21:59:23 <pastorn> return () or whatever
21:59:39 <pastorn> nothing of importance
22:01:51 * ddarius wonders if there is even one record type in the Prelude.
22:02:38 <roboshibby> hey guys, simple math question for a routine im trying to code, indulge?
22:02:41 <ddarius> > let Just {} = Nothing in True
22:02:42 <lambdabot>   True
22:02:43 <tensorpudding> record types are pretty common outside of the prelude
22:02:45 <dons> i don't think so. records are for losers who can't use 'case' :-)
22:02:53 <dons> roboshibby: ask
22:03:39 <roboshibby> let's say i have 10. now, i want to divide it by x as many times as i can, and then get the qty left over
22:03:50 <roboshibby> so if i give 3 to 10, i'd get 1 back
22:03:59 <roboshibby> (3, 6, 9 cleanly, 1 remaining)
22:04:01 <tensorpudding> modular arithmetic?
22:04:05 <roboshibby> no clue what this is
22:04:09 <roboshibby> i just know i need it
22:04:28 <roboshibby> (building an algorithm to dynamically position UI controls in a field)
22:04:30 <ddarius> :t mod
22:04:31 <lambdabot> forall a. (Integral a) => a -> a -> a
22:04:32 <jmcarthur> > 10 `mod` 3
22:04:33 <lambdabot>   1
22:04:36 <roboshibby> whoa
22:04:37 <tensorpudding> x = a (mod b) is the same as saying that a is the remainder of dividing x by b
22:04:41 <roboshibby> this is what mod is!?
22:04:56 <jmcarthur> mod gives the remainder
22:05:01 <pikhq> ... Yes, that is how mod is defined.
22:05:05 <ddarius> > 10 `rem` 3
22:05:06 <lambdabot>   1
22:05:09 <pastorn> roboshibby: you also have the function divMod which gives BOTH the result of the division as well as the remainder
22:05:12 <tensorpudding> it's written in haskell as a = mod x b
22:05:18 <jmcarthur> 10/3 = 3 and 1/3.  mod returns the 1
22:05:20 <roboshibby> > 10 `mod` 4
22:05:21 <lambdabot>   2
22:05:24 <pastorn> > 10 `divMod` 3
22:05:24 <roboshibby> nice!
22:05:25 <lambdabot>   (3,1)
22:05:44 * pastorn gets happy when people get amazed
22:05:46 <tensorpudding> mod only works for instances of Integral
22:05:52 <tensorpudding> though
22:05:54 <pastorn> tensorpudding: don't mess with his head
22:06:23 <pastorn> (the idea being that if you're asking how to do mod you don't really know about typeclasses yet)
22:06:34 <tensorpudding> so only Integer, Int, Word8/16/32 and Int8/16/32 etc.
22:07:28 <roboshibby> clock arithmetic
22:07:30 <roboshibby> nice
22:07:45 <roboshibby> yea no clue on what type classes are
22:07:54 <roboshibby> does ( ) around 3,1 mean negative?
22:08:02 <tensorpudding> no
22:08:07 <tensorpudding> it's a tuple (3,1)
22:08:09 <ivanm> it forms a pair of numbers
22:08:15 <roboshibby> nice
22:08:16 <ivanm> @type ('a', Just 3)
22:08:17 <lambdabot> forall t. (Num t) => (Char, Maybe t)
22:08:20 <tensorpudding> it has type (Int,Int), say
22:08:29 <tensorpudding> it's just like ordered pairs in maths
22:08:37 * ddarius finds it unfathomable not being at all familiar with mod even though at some point he himself must not have been.
22:08:53 <tensorpudding> only you can tuple any two types together
22:09:18 <roboshibby> thanks for the help fellas
22:11:03 <ivanm> dons: wrt Taladar on the haskell reddit: I'm assuming he's one of those people that whinge because we don't put the "bleeding edge" haskell packages into the main gentoo tree, even though we have a perfectly good external haskell repository
22:11:55 <pastorn> haha... he just left
22:12:05 <tensorpudding> whinge?
22:12:21 <ddarius> tensorpudding: Welcome to #haskell, an international forum.
22:12:31 <ivanm> pastorn: who?
22:12:35 <ivanm> @wn whinge
22:12:37 <lambdabot> No match for "whinge".
22:12:40 <ivanm> grrr
22:12:47 <ddarius> @google define:whinge -- this won't work
22:12:48 <lambdabot> No Result Found.
22:12:52 <tensorpudding> i thought only quebecois used the word whinge
22:12:54 <roboshibby> > 9 `mod` 3
22:12:55 <lambdabot>   0
22:12:57 <ivanm> http://en.wiktionary.org/wiki/whinge
22:13:00 <ddarius> Will work in the real google.
22:13:01 <pastorn> and again
22:13:06 <pastorn> ivanm: roboshibby
22:13:13 <ivanm> oh, that's Talador?
22:13:27 <tensorpudding> mistaken view from infinite jest i think
22:14:04 <ablmf> how to convert a number to a list of its digits efficient?  Like 123 to [1, 2, 3]
22:14:15 <ivanm> @hoogle digits
22:14:16 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
22:14:16 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
22:14:16 <lambdabot> Numeric lexDigits :: ReadS String
22:14:30 <ivanm> one of the packages on hackage has a good function to do this...
22:14:34 <ivanm> use hayoo to find out
22:24:05 <hotaru2k3> > let {digits 0 = []; digits x = uncurry (++) . (digits *** (:[])) $ (x `divMod` 10)} in digits 123
22:24:06 <lambdabot>   [1,2,3]
22:24:45 <ddarius> hotaru2k3: Your use of (++) is ugly.
22:25:35 <blackdog> > words $ show 123
22:25:37 <lambdabot>   ["123"]
22:25:38 <ddarius> I'm also pretty sure, while not the most efficient definition, map digits . show is a more efficient definition than that.
22:25:46 <ddarius> > map digit . show $ 123
22:25:48 <lambdabot>   Not in scope: `digit'
22:26:03 <blackdog> blah. ruby rots the brain, clearly.
22:26:04 <Saizan> > map digitToInt . show $ 123
22:26:05 <lambdabot>   [1,2,3]
22:26:51 <mreh> @pl (\x -> (x, f x))
22:26:51 <lambdabot> ap (,) f
22:26:56 <ddarius> > let (.) = flip ($) in 123.show.map digitToInt
22:26:57 <lambdabot>   [1,2,3]
22:30:18 <ablmf> how to convert an Int to RealFloat?
22:30:25 <ivanm> ablmf: fromIntegral
22:30:31 <ivanm> @type fromIntegral
22:30:32 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:38:06 <pastorn> @hoogle until
22:38:06 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:38:12 <pastorn> untilM?
22:38:54 <jmcarthur> gotta write it yourself methinks
22:39:10 <ivanm> @hoogle when
22:39:10 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:39:22 <ivanm> @src until
22:39:22 <lambdabot> until p f x | p x       = x
22:39:22 <lambdabot>             | otherwise = until p f (f x)
22:39:27 <pastorn> hmmm...
22:39:43 <jmcarthur> :t unless
22:39:44 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:40:05 <ivanm> @hoogle (a -> Bool) -> (a -> m a) -> a -> m a
22:40:05 <lambdabot> No results found
22:40:36 <jmcarthur> :t until :: (a -> Bool) -> (a -> m a) -> a -> m a
22:40:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
22:40:38 <lambdabot>     In the expression: until :: (a -> Bool) -> (a -> m a) -> a -> m a
22:41:06 <ivanm> untilM p f a = if p a then return a else untilM p f =<< f a
22:41:13 <ivanm> pastorn: ^^ I think that might be it
22:41:25 <ivanm> @type @let untilM p f a = if p a then return a else untilM p f =<< f a in untilM
22:41:26 <lambdabot> parse error on input `@'
22:41:31 <ivanm> @type let untilM p f a = if p a then return a else untilM p f =<< f a in untilM
22:41:32 <pastorn> untilM prop mx continuation = do { x <- mx; if prop x then continuation else untilM prop mx continuation }
22:41:32 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> (a -> m a) -> a -> m a
22:41:51 <ivanm> pastorn: if you're copying the definition of until, then you do the check _first_
22:42:11 <pastorn> ivanm: with a monadic value i can't...
22:42:13 <pastorn> or can i?
22:42:25 <ivanm> pastorn: on, you want it to take in an (m a)
22:42:26 <ivanm> ?
22:42:29 <ivanm> rather than just an a?
22:42:41 <pastorn> yes
22:42:46 <ivanm> hmmm...
22:42:52 <ivanm> then yeah
22:42:59 <pastorn> and that makes me wonder how to actually bild this
22:43:34 <pastorn> untilM :: (a -> Bool) -> m a -> m a
22:43:39 <pastorn> will cause it to run one extra time
22:43:42 <ivanm> @type let untilM p f ma = do { a <- ma; if p a then ma else untilM p f (f =<< ma) } in untilM
22:43:44 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> Bool) -> (b -> m b) -> m b -> m b
22:43:57 <ivanm> pastorn: oh? how do you get it to recurse?
22:44:18 <ivanm> pastorn: what happens if the condition is false?
22:45:01 * ivanm wonders how complicated he should make the new HTML stuff for graphviz...
22:46:03 <pastorn> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22988#a22988
22:47:31 <ivanm> pastorn: ummm.... you're never changing f...
22:47:41 <pastorn> ivanm: should i?
22:47:41 <ivanm> I presume it's a mutable monadic value (IO or some such)?
22:47:54 <pastorn> not necesarily (but it is)
22:48:09 <ivanm> pastorn: consider: untilM even (Just 1)
22:48:13 <ivanm> that will never end
22:48:18 <pastorn> hmm...
22:48:20 <pastorn> true
22:48:31 <pastorn> what should the monadic part here be?
22:48:36 <pastorn> (a -> m Bool) ?
22:48:38 <ivanm> I mean, that is valid for some monads
22:48:40 <pastorn> (like with filterM)
22:48:46 <ivanm> just put a big warning sign on it ;-)
22:48:56 <ivanm> pastorn: nah, filterM has the m Bool because it's a monad predicate
22:49:04 <ivanm> that's the whole point of filterM
22:49:11 <ivanm> @hoogle (a -> Bool) -> m a -> m ()
22:49:11 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
22:49:11 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
22:49:11 <lambdabot> Foreign.C.Error throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
22:49:17 <pastorn> ivanm: this is for my MIRKK-bot, not exactly code that's going up for code review
22:49:17 <ivanm> @hoogle when
22:49:17 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:49:35 <ivanm> pastorn: right; as long as you're careful about it it should be OK
22:49:46 <ivanm> pastorn: better still, restrict it to IO or whatever monad you're going to be using
22:49:50 <ivanm> rather than generalising it
22:50:03 <ivanm> that way you won't accidentally mis-use it and get into an infinite loop
22:50:11 <pastorn> ivanm: i don't exactly have commit rights to Control.Monad
22:50:27 <ivanm> pastorn: so? you could stil have been putting this into another library...
22:50:37 <pastorn> ivanm: dude... no way
22:50:54 <ivanm> heh
22:51:07 <roboshibby> ok, new question. is there some math concept which, if you have 10 and give 3, it will give you 4? (as in, it has > 3 parts of 3, so rounds up to 4)
22:51:09 <pastorn> roboshibby: hello again
22:51:13 <roboshibby> hello
22:51:20 <pastorn> roboshibby: you know that it's ok to just stay in this channel?
22:51:21 <roboshibby> > 10 `divMod` 3
22:51:22 <lambdabot>   (3,1)
22:51:32 <roboshibby> ok, nice
22:51:37 <ivanm> hmmm.... is there a better way of expressing this data type? data Foo = Base Bar | Recurse Foo Bar
22:51:41 <pastorn> you don't have to log out whenever you've asked a question :)
22:51:50 <roboshibby> thanks pastorn
22:51:54 <ddarius> ivanm: (Bar, [Bar])
22:52:11 <ivanm> roboshibby: are you Taladar on reddit?
22:52:26 <ivanm> ddarius: that's not right... the order is specific
22:52:39 <ivanm> if anything, ([Bar], Bar)
22:53:12 <pastorn> roboshibby: should it become 4 because (3,1) ==> 3+1 = 4
22:53:21 <ivanm> but that still looks a little fugly :s
22:53:31 <pastorn> > 11 `divMod` 3
22:53:32 <lambdabot>   (3,2)
22:53:37 <pastorn> shoud that become 5?
22:53:39 <ivanm> Or I could just have [Bar] and tell users they should make sure they have at least one value...
22:53:49 <hotaru2k3> > ceiling $ 10 / 3
22:53:50 <lambdabot>   4
22:54:13 <ivanm> ddarius: actually, your specification would work as well...
22:54:58 <pastorn> roboshibby: you don't see it there in what hotaru2k3 did, but (10/3) is actually a decimal number (Float or Double) and thus you can call the function cieling on it, which rounds it upwards
22:59:35 <pastorn> ivanm: here we go: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=22988#a22989
22:59:44 * pastorn forgot about return
23:00:35 * ivanm believes he already proposed something along those lines...
23:00:51 <pastorn> well, *I* din't come up with that
23:04:11 <roboshibby> interesting
23:04:21 <roboshibby> i will do some more thinking on the issue. thank you fellas
23:05:13 <ivanm> roboshibby: are you Taladar on reddit?
23:05:25 <roboshibby> nope
23:05:29 <roboshibby> sorry, forgot to answer that
23:05:32 <ivanm> OK, someone said you were
23:05:38 <roboshibby> how would someone even know?
23:05:40 <roboshibby> lol
23:05:55 <ivanm> *shrug*
23:06:05 <roboshibby> well anyway, !Taladar
23:06:13 <ivanm> anyway, you are safe... for now...
23:06:17 <ivanm> mwahahahahahahahha!!!!!
23:06:20 <ivanm> *cough, cough
23:06:22 <ivanm> *
23:06:33 <pragma_> stfu
23:06:45 <ivanm> why?
23:06:53 <pragma_> i sed
23:07:15 <ivanm> and I awk
23:07:18 <ivanm> what's your point?
23:08:17 <SubStack> pesky plugins module isn't installing >_<
23:08:27 * SubStack gets to the bottom of this
23:10:55 <SubStack> pesky #if
23:13:29 <roboshibby> > 11 `mod` 3
23:13:30 <lambdabot>   2
23:13:57 <roboshibby> nice
23:14:00 <ivanm> roboshibby: you can always have a private conversation with lambdabot...
23:14:08 <roboshibby> any time i want?
23:14:13 <ivanm> /msg lambdabot > 11 `mod` 3
23:14:42 <roboshibby> seems to not respond to social pleasantries
23:15:16 <c_wraith> roboshibby: just prefix them with @vixen
23:15:58 <roboshibby> what does @vixen do to change the behavior?
23:16:05 <roboshibby> like, what kind of construct is @vixen
23:16:06 <c_wraith> @vixen How are you doing?
23:16:06 <lambdabot> i truely am
23:16:20 <c_wraith> ...  ok, the plugin didn't handle that well
23:16:38 <ivanm> there's a typo in the @vixen plugin? :o
23:21:32 <edwardk1> preflex: xseen ddarius
23:21:32 <preflex>  ddarius was last seen on freenode/#haskell 29 minutes and 38 seconds ago, saying: ivanm: (Bar, [Bar])
23:24:58 <ivanm> preflex: seen gwern
23:24:58 <preflex>  gwern was last seen on #haskell 6 hours, 25 minutes and 36 seconds ago, saying: well, could work on mono
23:25:41 <ivanm> @tell gwern wrt your comment about hare vs hlint, my understanding is that there's pretty much no overlap... and that simon thompson is wanting to update it to support new GHC as soon as he can find a decent parser that satisfies what HaRe needs
23:25:42 <lambdabot> Consider it noted.
